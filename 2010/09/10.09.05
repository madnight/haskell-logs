00:00:32 <Kaidelong> a (non-implementation related) question about type signatures
00:00:57 <Kaidelong> when you specialize a type signature, can it ONLY be reversed if the specialization yields the same thing you started with?
00:01:39 <Kaidelong> or are them some corner cases where you can specialize a type signature and then specialize it again to get back to what you started with, without the intermediate step being the same signature
00:04:01 <min> Is there a standard way to represent values like "0001" or "0350" (without using list/num conversions)?
00:04:22 <JoshTriplett> min: What exactly do you mean?
00:04:51 <JoshTriplett> min: Do you need to preserve the leading zeroes?
00:05:23 <min> yeah - represent sequences of integers as opposed to integer values.
00:05:43 <kmc> [Int] is a sequence of integers
00:05:50 <kmc> or perhaps [Integer]
00:06:09 <kmc> why do you want a sequence of ints, but not a list?
00:06:23 <Kaidelong> you could make a data type to store a 4 number decimal I guess
00:06:37 <JoshTriplett> min: Do you want a fixed field width here, or do you want to handle both 003 and 0003?
00:06:41 <JoshTriplett> (And are those equal or not?)
00:07:20 * Kaidelong realizes that his earlier question has an obvious answer; if it is reversible then it is algebraically the same signature since it can simply be turned back and specialized as needed
00:08:13 <min> Yeah, a fixed field of four integers (used to represent simple op code / operand values). Of course I could use a list or a fixed data type. But a package which had this feature built-in would be nice.
00:08:35 <Kaidelong> so if signature A can be specialized to be signature B which can be specialized to signature A
00:08:37 <copumpkin> min: have you considered an ADT for your opcodes?
00:08:44 <Kaidelong> Saing that A and B aren't the same is a contradiction
00:09:03 <Kaidelong> since you can specialize one into the other and then infer all the same types
00:09:09 <min> Yeah, that's what I just started workign on, before I asked the question
00:10:48 <alecbenzer> why is that when I compile a .hs file with ghc --make, :loading it in ghci only allows me to see main, but if I :load it when there are no compiled files, I can access all my functions?
00:11:11 <kmc> because ghci loads compiled code if it can find it
00:11:25 <alecbenzer> kmc, is there a way to tell it not to?
00:11:29 <kmc> :load *Foo
00:12:14 <alecbenzer> kmc, ah, thank you
00:12:17 <kmc> :)
00:12:35 <kmc> or: ghci -fforce-recomp
00:15:25 <alecbenzer> can you do a qualified import from ghci? "import qualified Data.ByteString.Lazy as B" gives me a parse error
00:16:08 <alecbenzer> and the :help for :m didn't see to allow for qualified imports
00:16:08 <kmc> sadly no
00:16:13 <alecbenzer> seem*
00:16:14 <alecbenzer> hm, k
00:16:18 <kmc> the best you can do right now is import a file with the qualified import
00:16:24 <kmc> i think it might be patched in GHC 6.14
00:18:41 <co_dh> can I generate c or c++ code from ghc ? I mean , compile a .hs to .c ?
00:21:18 <ziman> you can do that with (at least) jhc
00:21:35 <ziman> ghc generates c--, afaik (fixme)
00:21:51 <co_dh> I found the -C option , and it generate .hc file
00:22:21 <co_dh> did you read the jhc generated c code  ? is it readable?
00:32:54 <Kaidelong> can kinds be specialized like types?
00:33:15 <Kaidelong> like turning * into (* -> *) -> * -> * or something
00:35:17 <Kaidelong> or will 
00:35:21 <Kaidelong> * always be *
00:35:42 <Kaidelong> and * -> * never be (* -> *) -> (* -> (* -> *))
00:36:01 <Kaidelong> etc
00:41:20 <kmc> the latter
00:41:26 <kmc> there are no kind variables
00:41:32 <kmc> * isn't a variable
00:41:41 <kmc> it's like asking if Int will ever be specialized to Int -> Int
00:41:46 <Kaidelong> that's what I figured, because I reasoned that composing two constructors would not be like function composition
00:41:55 <Kaidelong> in that the constructor you end up with actually has a different kind
00:42:03 <Kaidelong> but I wasn't sure if that was true
00:42:13 <kmc> i don't follow
00:42:27 <kmc> composing type constructors should be exactly like composing functions in the simply-typed lambda calculus with one base type
00:42:32 <kmc> that's basically what the kind system is
00:42:43 <Kaidelong> hmm
00:42:46 <kmc> Maybe :: * -> *, so Maybe . Maybe :: * -> *
00:43:16 <kmc> * isn't a variable, it's a specific kind.  the kind of types with values
00:43:38 <kmc> in GHC the story is actually a bit more complicated, and there's a bit of polymorphism
00:43:54 <kmc> :k (->)
00:43:55 <lambdabot> ?? -> ? -> *
00:44:21 <kmc> GHC has kinds * (normal boxed types), # (unboxed types), ?? (* or #), ? (* or # or unboxed tuples)
00:44:43 <kmc> so the kind of (->) says that a function takes a boxed or unboxed argument, and returns a boxed or unboxed value or an unboxed tuple
00:44:49 <Kaidelong> :k Maybe a
00:44:50 <lambdabot> Not in scope: type variable `a'
00:44:52 <Kaidelong> err
00:44:54 <kmc> (unboxed tuples aren't unboxed values; they're a convention for multi-argument return)
00:44:58 <Kaidelong> :k Maybe
00:44:59 <lambdabot> * -> *
00:45:06 <Arsole_> what packages do I need to import to use "spawn"
00:45:17 <kmc> @hoogle spawn
00:45:17 <lambdabot> No results found
00:45:20 <iskren_> kmc, I tried the module you proposed (memo-combinators) but it is struggling even with a function computed for million inputs ... is that normal?
00:45:25 <kmc> Arsole_, where do you see it?
00:45:28 <Kaidelong> :k Maybe (Maybe Int)
00:45:28 <kmc> iskren_, not sure
00:45:29 <lambdabot> *
00:45:40 <Kaidelong> :k Maybe (Maybe)
00:45:41 <lambdabot>     `Maybe' is not applied to enough type arguments
00:45:41 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
00:45:52 <Arsole_> kmc: https://bbs.archlinux.org/viewtopic.php?id=94969 second post
00:46:07 <Kaidelong> is there a type composition?
00:46:21 <kmc> Kaidelong, you can define a newtype wrapper for it
00:46:36 <kmc> newtype O f g a = MkO (f (g a))
00:46:43 <kmc> you can't do it "transparently", though
00:46:48 <Arsole_> brb
00:47:16 <Nibble> kmc: well
00:47:29 <Nibble> I could just add all those imports..
00:47:33 <Nibble> but that seems like overkill
00:47:56 <kmc> Nibble == Arsole_ ?
00:48:04 <Nibble> kmc: nah, I just used wrong config
00:48:14 <kmc> Nibble, just import XMonad
00:48:14 <Nibble> so, yes
00:48:21 <Nibble> kmc: I have done that
00:48:43 <kmc> in my version of xmonad, it exports "spawn"
00:48:58 <kmc> it's actually defined in XMonad.Core
00:49:11 <kmc> btw if you have a module with a bunch of imports
00:49:20 <kmc> ghc --make -fforce-recomp -ddump-minimal-imports Foo.hs
00:49:20 <Nibble> kmc: you are right
00:49:23 <kmc> then look in Foo.imports
00:49:23 <Nibble> it does import spawn
00:49:33 <Nibble> I fail
00:50:19 <kmc> iskren_, you could put your code on hpaste and i'll take a look
00:52:12 <kmc> iskren_, note that you have to make your recursive calls call the memoized version, not the original
00:52:20 <kmc> otherwise you are only memoizing "one level"
00:58:43 * hackagebot bits-atomic 0.1.3 - Atomic bit operations on memory locations  for low-level synchronization  http://hackage.haskell.org/package/bits-atomic-0.1.3 (GabrielWicke)
01:10:49 <kmc> @bot
01:10:50 <lambdabot> :)
01:16:26 <iskren_> is there any way to instruct ghc to use "long long" (64 bit) for Int and not try to overflow to Integer
01:17:15 <Nibble> iskren_: yeah
01:17:23 <Nibble> LongLongLong should do the trick
01:20:15 <iskren_> I pass this to ghc or use it as a type ?
01:21:23 <kmc> ?
01:21:34 <kmc> Int will not overflow to Integer
01:21:43 <kmc> you can tell that from the type
01:21:46 <kmc> (+) :: Int -> Int -> Int
01:22:03 <kmc> the range of Int is platform-dependent but is at least [-2^29...2^29-1]
01:22:15 <kmc> on GHC it is the size of a machine word.  on a 64-bit machine you will get 64-bit ints
01:22:38 <kmc> however, if you're relying on a particular size
01:22:43 <kmc> you should import Data.Int and use e.g. Int64
01:22:54 <kmc> there is also Data.Word providing unsigned, e.g. Word64
01:25:08 <iskren_> kmc, thanks! So I should specify with :: that the imput of a function is Int64 lets say and all computations will be with 64 ints rright?
01:25:20 <kmc> yeah
01:25:27 <iskren_> kmc, sounds great :)
01:25:39 <kmc> it's good style to put type sigs on all your values defined at top level of the file
01:25:45 <kmc> type inference will take care of the rest
01:25:59 <kmc> since there are no implicit conversions in Haskell, it is pretty easy to know what type your numbers end up
01:30:18 <iskren_> kmc, ok but still If I'm dividing by 2 lets say I dont' have to do anything fancy for the 2 - I mean I should't convert it to Int64 - it should be automatic?
01:30:21 <kulin> what is responsible for the "[x of y] Compiling Whatever.Something" messages when running cabal build, ghc or cabal? why doesn't it go to the same stdout that the other build messages goto? is there anyway to force it to? 
01:30:39 <kmc> those messages come from ghc itself
01:30:44 <kmc> they probably go to stderr but i don't know
01:30:54 <fengshaun> how can I convert a string "34" to Int?
01:30:58 <kmc> read
01:31:01 <kmc> > read "34" :: Int
01:31:02 <lambdabot>   34
01:31:05 <kmc> if you need error handling, reads
01:31:17 <kmc> > case reads "34" of [(v,"")] -> Just v; _ -> Nothing
01:31:17 <lambdabot>   Nothing
01:31:23 <kmc> > case reads "34" of [(v,"")] -> Just (v :: Int); _ -> Nothing
01:31:24 <lambdabot>   Just 34
01:31:32 <kmc> iskren_, right.  numeric literals in source code are overloaded
01:31:34 <kmc> :t 2
01:31:35 <lambdabot> forall t. (Num t) => t
01:31:44 <fengshaun> kmc: thanks!
01:31:47 <kmc> iskren_, so 2 can be specialized to any type T as long as T has a Num instance
01:31:53 <kulin> oh you are right kmc, and if the internet can be believed it was fixed on aug 8th
01:32:05 <kmc> iskren_, though, you said "dividing"; (/) doesn't work on Int64 or on Int for that matter
01:32:09 <kmc> 'div' will work though
01:32:21 <kmc> (truncating integer division)
01:34:11 <iskren_> kmc, yeah, I'm using div
01:35:04 <iskren_> is there any reason, why after I imported memo-combinators in my source gchi loads it correctly but then won't find any global functions inside (it says they are not defined)
01:35:20 <Zeiris_> So how does a typical interpreter get implemented? Define data type for language structures, define Parsec parsers for reading it from a file, then define functions to reduce/execute the resulting the resulting object?
01:36:35 <kulin> kmc, thanks so much that was the final touch on getting a hotkey to compile projects in a diff terminal
01:36:46 <kmc> Zeiris_, yeah
01:37:07 <kmc> eval :: Exp -> Val
01:37:19 <kmc> or probably:  eval :: Env -> Exp -> Val
01:37:32 <kmc> Env being something like Map Name Val
01:37:53 <Zeiris_> eval :: Exp -> State Env Val
01:38:17 <kmc> perhaps
01:38:26 <Zeiris_> Gosh, that's so straightforward.
01:38:57 <kmc> eval :: Env -> Exp -> ErrorT Err (ST s) Val
01:39:01 <kmc> in this case your Env holds STRefs
01:40:16 <kmc> Zeiris_, if you look on the cover of SICP, the Wizard Book, you'll see a symbol bearing the words eval/apply
01:40:36 <kmc> this is a reference to the typical structure of interpreters, including the many you write throughout the course using SICP
01:41:56 * hackagebot cmdargs 0.4 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.4 (NeilMitchell)
01:44:38 <chrisdone> http://paste.tryhaskell.org/paste/69/ackermann#p70
01:45:27 <kmc> unsafePerformIO, naughty
01:46:04 <kmc> chrisdone, your Native* instances are quite boilerplatey, this is a problem i have struggled with for some time
01:46:23 <kmc> in lieu of a sophisticated solution, might i suggest the humble C preprocessor?
01:46:25 <chrisdone> kmc: indeed
01:46:52 <chrisdone> I wonder if I could employ Typeable to do it
01:47:05 <kmc> i've gone down that road
01:47:15 <kmc> decided it didn't work out, but maybe you'll figure it out
01:48:53 <kmc> chrisdone, last i solved this problem it was something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29732#a29732
01:49:32 <chrisdone> kmc: the language is lazy using haskell's laziness. I thought it would be fun to use unsafePerformIO to see if I can solve the IO problem in a different way
01:49:43 <kmc> yeah
01:49:58 <kmc> i mean if you provide an unsafe IO primitive so you can implement safe IO in-language
01:50:02 <kmc> then you are no worse than GHC ;)
01:50:30 * kmc wonders if anyone preprocesses their Haskell with M4
01:50:54 <chrisdone> instance (WInfer a, WInfer b) => WInfer (a -> b) where
01:50:54 <chrisdone> that's probably how I'd do it now, much better
01:51:08 <kmc> the inference aspect is secondary
01:51:13 <chrisdone> (I wrote this a while ago)
01:51:13 <kmc> but still convenient
01:51:38 <kmc> it's mostly just having a DSL to build wrapping/unwrapping functions
01:51:43 <chrisdone> did you see utrecht's talk on building dsls?
01:51:49 <kmc> no
01:52:24 <chrisdone> they redefined the Prelude into "AwesomePrelude" which is DSL friendly. so the Num class, for example, is defined with an extra parameter
01:52:34 <chrisdone> no that's a bad example, Eq
01:52:38 <kmc> right
01:52:44 <chrisdone> class Eq a b where (==) :: a -> a -> b
01:52:47 <kmc> yes
01:52:49 <kmc> makes sense
01:53:11 <chrisdone> but then evolved into
01:53:11 <chrisdone> class Eq a where (==) :: f a -> f a -> f Bool
01:53:15 <kmc> how much ambiguity does it add to plain old Haskell programs
01:53:16 <kmc> heh
01:53:16 <chrisdone> then you can implement a functor
01:53:30 <chrisdone> er, not sure
01:53:42 <kmc> f is a class param there?
01:53:50 <chrisdone> but the DSLs overloaded num, ==, etc. and their JavaScript EDLs looked like haskell, it was nice
01:54:03 <chrisdone> maybe it was class Functor f => Eq a where
01:54:07 * chrisdone diggs out the URL
01:55:00 <chrisdone> http://tom.lokhorst.eu/2010/02/awesomeprelude-presentation-video
01:55:06 <kmc> cool
01:55:07 <kmc> thanks for the link
01:56:18 <chrisdone> np thought it was neat
02:00:31 <Funktorsalat> ghc seems to take quite some time to compile large constants
02:00:40 <Funktorsalat> list of 5500 strings, in this case
02:01:45 <Funktorsalat> wait, do we have unrolling yet? maybe it's doing my benchmark at compiletime ;)
02:01:55 <bobzhangatthu> Hi, anybody be familar with Coq, If I want to simulate depedent types in Haskell, possible? like Inductive eq (A:Type) (x:A) : A ->Prop := refl_equal :x=x.
02:02:56 <bobzhangatthu> I just want to 'excatly' what feature  Haskell lack?
02:03:14 <Funktorsalat> you can do for A=Type in haskell ;)
02:03:16 <Funktorsalat> *do that
02:03:23 <Funktorsalat> using GADTs
02:03:27 <Funktorsalat> otherwise, no
02:03:45 <bobzhangatthu> I know GADTS, I tried simulate with GADTS, failed.
02:04:05 <bobzhangatthu> can you give me a little demo? thanks
02:04:34 <kmc> the feature Haskell is missing is dependent types :)
02:04:51 <Kaidelong> isn't it intentionally missing that feature?
02:04:52 <kmc> you can't bind values to names in a type signature and then use those values later in the signature
02:05:52 <Kaidelong> I remember something like, they wanted to be able to infer all types, and dependent types were presumed to make stuff incomplete or intractable to infer, and then they couldn't infer things involving type classes all the time anyway...
02:06:21 <Kaidelong> impossible or*
02:06:26 <bobzhangatthu> T_T. I know haskell lacks features like dependent types, but we have qualified types, simulate impossible?
02:07:24 <Kaidelong> I suppose ultimately you'd want a language where the type system doesn't exist as a seperate entity but you do all your programming in it and it infers the code
02:07:31 <Funktorsalat> you can simulate it by replicating your data on the type level
02:07:32 <Peaker> Haskell dependent types are "cleverly dreadful" where normal ones are "dreadfully clever" :)
02:07:38 <Funktorsalat> there are some example On Hackage...
02:07:38 <Peaker> (from paper about Epigram)
02:08:10 <bobzhangatthu> Any reference ?
02:08:29 <bobzhangatthu> I thought type class is kinda dependent types?
02:09:51 <kmc> how?
02:10:23 <kmc> i don't see the connection
02:11:12 <kmc> type classes are like a system for implicit function arguments, plus type-directed resolution of those arguments from a special, global namespace
02:11:48 <Peaker> I am not sure, but I think this might work: data Zero ; data Succ n ;  class Plus ia ib o | (ia, ib) -> o ; instance Plus Zero n n ; instance (Plus n m r) => Plus (Succ n) m (Succ r)
02:11:54 <bobzhangatthu> I remembered an extension , Generic Haskell where it mentioned that type class resembles dependent types
02:12:18 <Funktorsalat> .... if you duplicate your values on the typelevel
02:12:48 <Funktorsalat> otherwise, values never break through to the typelevel
02:13:36 * Kaidelong thinks that Twelf may be such a language now that he's seen the entry on it, says that you can do logic programming in it by having it search for stuff that matches type signatures...
02:13:44 <kmc> bobzhangatthu, you may likhttp://strictlypositive.org/winging-jpgs/e 
02:14:13 <bobzhangatthu> Okay, let me have a look, thanks.
02:14:14 <kmc> there's http://personal.cis.strath.ac.uk/~conor/pub/she/ which is a Haskell preprocessor to add features resembling dynamic types
02:14:28 <kmc> it's really just sugar around the lifting of values to types that Funktorsalat describes
02:14:48 <kmc> more like Sheard's language Omega than actual dependent types
02:15:02 <kmc> i hear GHC will get data kinds soon
02:15:22 <kmc> http://byorgey.wordpress.com/2010/08/05/typed-type-level-programming-in-haskell-part-iv-collapsing-types-and-kinds/
02:15:43 <bobzhangatthu> It seems great. Depedent types are useful in any other areas except in logic programming?
02:16:02 <kmc> yeah
02:16:17 <kmc> they're useful in general, for specifying and proving more of your program's behavior
02:16:28 <kmc> in other words, they're useful in the same way as static types in general
02:16:53 <kmc> Agda attempts to be a DT language that's a little closer to practical programming and a little further from pure theorem proving
02:17:01 <Kaidelong> as I understand it, the nice thing about using them for logic programming is that you end up with the proof in the deal
02:17:16 <bobzhangatthu> kmc: thanks, very valuable information :)
02:17:16 <kmc> www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf is a nice document about Agda
02:17:21 <Kaidelong> so you end up being able to infer a program from a proof
02:17:29 <Funktorsalat> simple static types are proofs too, just of weaker properties ;)
02:17:33 <kmc> what do you mean by "logic programming"
02:17:49 <bobzhangatthu> I use coq to proof my programs
02:17:53 <Kaidelong> you give it a type and it treats it as a search space, returning everything that can be a member of the type
02:17:59 <kmc> oh, interesting
02:18:09 <chrisdone> like djinn?
02:18:17 <Kaidelong> Is that how djinn works?
02:18:32 <Kaidelong> I guess it would be, but you'd be using a type system much more powerful than haskell's
02:18:50 <bobzhangatthu> En, Coq's type system is very powerful ,
02:19:21 <Funktorsalat> Kaidelong: sounds like coq's 'auto' etc
02:19:35 <Funktorsalat> searching for a proof is constructing a value after all
02:20:16 <bobzhangatthu> I guess like Haskell may derive some useful functions automatically, that would be very cool
02:20:44 <bobzhangatthu> like generic fold? or other Geneir functions on ADT
02:22:41 * Funktorsalat wonders why coq has separation of props and types while agda doesn't... seems like a *pragmatic* feature in addition to allowing prop to be impredicative
02:23:08 <Funktorsalat> e.g. to eliminiate all props when extracting code
02:23:38 <Funktorsalat> but I guess that's getting OT
02:25:08 <Veinor> gasp! off topic in haskell!
02:25:11 <Veinor> #haskell
02:25:36 <Kaidelong> djinn can't do anything with functors yet, right?
02:25:43 <Kaidelong> err
02:25:47 <Kaidelong> or type classes in general
02:27:24 <Kaidelong> :t foldr
02:27:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:27:49 <Kaidelong> :t const . (flip const)
02:27:50 <lambdabot> forall b b1 a. a -> b -> b1 -> b1
02:27:58 <ManateeLazyCat> ManateeIrcClient: Who login my irc robot? Is you, Jens?
02:28:16 <Kaidelong> > const . (flip const) :: (a -> b -> b) -> b -> [a] -> b
02:28:17 <lambdabot>   Couldn't match expected type `b' against inferred type `[a]'
02:28:17 <lambdabot>    `b' is a ri...
02:29:02 <Funktorsalat> Kaidelong: I'm pretty sure it only uses an explicit collection of functions
02:29:17 <Funktorsalat> don't see how TC methods would make much of a difference
02:29:35 <Kaidelong> @djinn (a -> b -> b) -> b -> [a] -> b
02:29:35 <lambdabot> Error: Undefined type []
02:29:39 <Kaidelong> nope
02:29:51 <Kaidelong> doesn't like the constructor
02:31:33 <ManateeLazyCat> Haskell RSS/Atom reader : http://www.flickr.com/photos/48809572@N02/4959712828/lightbox/ ... :)
02:44:26 <chrisdone> ManateeLazyCat: nice!
02:45:02 <Kaidelong> wish GTK development tools were easier to deploy
02:45:08 <ManateeLazyCat> chrisdone: I'm add some feature support offline browse.
02:45:12 <Kaidelong> better than wxWidgets at least
02:45:33 <ManateeLazyCat> Kaidelong: http://www.flickr.com/photos/48809572@N02/
02:49:25 * chrisdone scrapes all the pastes off of hpaste.org
02:50:27 <ManateeLazyCat> chrisdone: Use paste2.org bigger paste capacity, paste2.el is emacs interface...
02:51:57 <pantsd_home> Is there an easy way to see what text a parsec rule matched, or do I need to update the rules to return the text that they matched?
02:52:14 <chrisdone> man, the paste2.org page is arrogant
02:53:07 <chrisdone> pantsd_home: I think you can get access to what *hasn't* been consumed
02:54:02 <pantsd_home> moks. Whats a good parsec reference/tutorial?
02:54:23 <Entroacceptor> ManateeLazyCat: so, what do I need to compile that?
02:54:44 <ManateeLazyCat> Entroacceptor: gio-branch and gtk darcs version.
02:54:56 <ManateeLazyCat> Entroacceptor: Other package you can found at hackage
02:55:39 <ManateeLazyCat> Entroacceptor: gio-branch at https://patch-tag.com/r/AndyStewart/gio-branch/home 
02:56:06 <Entroacceptor> and first compile manatee-core, then the rest?
02:57:02 <ManateeLazyCat> Entroacceptor: You download all manatee-* package at same directory, then switch to 'manatee' package, run './repos.sh install'
02:57:12 <Entroacceptor> aah :)
02:57:14 <Entroacceptor> goodie
02:57:23 <ManateeLazyCat> Entroacceptor: If you found some package miss, you need install from hackage first.
02:57:43 <ManateeLazyCat> Entroacceptor: Make sure you have install gio-branch and darcs gtk, otherwise can't work.
02:58:32 * juhp_ is running manatee with minor tweaks on stock gtk
02:58:44 <Entroacceptor> ok
03:00:39 <ManateeLazyCat> Entroacceptor: You can ask juhp_ , most code in ./repos.sh is written by Jens. :)
03:01:46 <Entroacceptor> mh, now I have to darcs pull all 15 directories..
03:02:12 <ManateeLazyCat> Entroacceptor: Project is big..... Enjoy... :)
03:02:57 <ManateeLazyCat> Entroacceptor: manatee still in alpha, has many bus haven't time finish (busy on new module), so i don't suggest you use it as produce tool.
03:03:07 <ManateeLazyCat> Entroacceptor: Just play it at this moment. :)
03:03:17 <Entroacceptor> yeah, that's what  I wanted to do
03:03:20 <ManateeLazyCat> s/bus/bugs.
03:03:51 <ManateeLazyCat> Entroacceptor: My mail is lazycat.manatee@gmail.com, please let me know if you have any problem with manatee.
03:04:02 <pantsd_home> So if I want to use ByteStrings everywhere I have a string literal in my code do I need to do fromString?
03:04:17 <ManateeLazyCat> Entroacceptor: You can ask Jens, he has play manatee some time. :)
03:05:12 <chrisdone> pantsd_home: use -XOverloadedStrings
03:05:50 <ManateeLazyCat> Entroacceptor: Install all package from gtk2hs darcs, then install gio-branch and reinstall gtk
03:06:00 <pantsd_home> chrisdone: thanks :)
03:06:18 <ManateeLazyCat> Entroacceptor: Other package install from hackage, then switch to 'manatee' do './repos.sh install' should be success... :)
03:06:23 <Entroacceptor> reinstall gtk?
03:06:34 <ManateeLazyCat> Entroacceptor: Yes, because gtk depend gio
03:06:47 <Entroacceptor> and gio on gtk
03:06:53 <ManateeLazyCat> Entroacceptor: My gio-branch is newer than gio in gtk2hs repository.
03:07:14 <ManateeLazyCat> Entroacceptor: Of course, you can skip gio in gtk2hs repository, use gio-branch instead.
03:08:35 * ManateeLazyCat Oh my god, i forgot today is sunday.... damnn it....
03:08:46 <Entroacceptor> hu?
03:09:56 <ManateeLazyCat> Entroacceptor: Axel just have spare time to check my patches at weekend, i forgot notice him to check my patches. 
03:10:19 <ManateeLazyCat> Entroacceptor: If Axel pass all my patches, you don't need install gio-branch.... :)
03:10:43 <Entroacceptor> aah :)
03:13:16 <pantsd_home> So I'm getting back a bunch of Strings from a parsec parser, and then packing them, is there a better way to do this?
03:14:29 <ManateeLazyCat> juhp_: Great work, apply!
03:15:30 <juhp_> ManateeLazyCat: maybe you can still catch Axel? :)
03:15:38 <ManateeLazyCat> juhp_: Your new patch save my finger.
03:15:47 <ManateeLazyCat> juhp_: Yes, i need to notice him now.
03:15:56 <ManateeLazyCat> juhp_: Otherwise i need wait he next week.
03:16:03 <juhp_> guess it is still noon in Europe
03:16:17 <juhp_> cool
03:16:22 <Entroacceptor> 12:15 in CEST
03:17:38 <ManateeLazyCat> juhp_: Too busy forgot time ... :-(
03:18:49 <ManateeLazyCat> juhp_: Just left 9 patches haven't push...
03:18:58 <Entroacceptor> ManateeLazyCat: System/GIO/File/FileMonitor.chs:108:29: Not in scope: `connect_MOBJECT_MOBJECT_ENUM__NONE
03:19:07 <Entroacceptor> while compiling gio-branch
03:19:35 <juhp_> Entroacceptor: that is one of my tweaks
03:19:47 <ManateeLazyCat> Entroacceptor: Open gio-branch/marshal.list add 'NONE:MOBJECT,MOBJECT,ENUM' at last.
03:19:50 <ManateeLazyCat>  
03:20:01 <ManateeLazyCat> Entroacceptor: Sorry, gio-branch is not synchronous with gio in gtk2hs.
03:20:08 * ManateeLazyCat I need push some patch
03:20:30 <Entroacceptor> worky now
03:21:02 <Blkt> good day everyone
03:21:20 <ManateeLazyCat> juhp_: I love your backward/forward browser patch, handy. :)
03:21:40 <juhp_> more to come :)
03:21:45 * ManateeLazyCat Have push this patch to gio-branch.
03:21:45 <juhp_> once i write them :)
03:22:18 <ManateeLazyCat> juhp_: I think you start to understand my framework now. :)
03:22:31 <ManateeLazyCat> juhp_: When i saw you add postGUIAsync. :)
03:22:51 <juhp_> ManateeLazyCat: I was impressed how stable your ircclient is - was here for over 24 hours no problem :)
03:23:06 <ManateeLazyCat> juhp_: Hehe. :)
03:23:18 <ManateeLazyCat> juhp_: And damn fast.
03:23:28 <b52> hey, isnt possible to redefine takeWhile with foldr ?
03:23:32 <Zeiris_> Parts of the Haskell wiki, like http://www.haskell.org/haskellwiki/RunTimeCompilation, look very much like the TvTropes.org wiki. This, while probably accidental... Seems like it could produce a really, really useful learning aid.
03:23:36 <ManateeLazyCat> juhp_: I have test it 48 hours, works well.
03:24:15 <b52> *is
03:24:23 <b52> +it
03:24:29 <ManateeLazyCat> juhp_: Do you try perfect manatee-ircclient since you're author of hircules. If so, i can develop mail-client next step.
03:24:52 <ManateeLazyCat> juhp_: I think you can understand all detail after you perfect manatee-ircclient.
03:24:55 <chrisdone> soon all of the modern desktop is replaced with haskell programs
03:25:04 <ManateeLazyCat> chrisdone: yes.
03:25:06 <chrisdone> :D
03:25:14 <ManateeLazyCat> chrisdone: Except linux kernel and gtk toolkit.
03:25:31 <Funktorsalat> *troll* how can I include the gnore-dot-ghci directory in the search path with ghc?
03:25:32 <Funktorsalat> ;)
03:25:55 <ManateeLazyCat> chrisdone: Replace all software, then haskeller can play in *pure* haskell environment. :)
03:25:58 <Funktorsalat> (I know, -i./gnore-dot-ghci)
03:26:26 <b52> is it possible to redefine takeWhile with foldr ?
03:27:15 <chrisdone> sure
03:27:15 <juhp_> ManateeLazyCat: I can try to port some more functionality like irc commands maybe
03:27:26 <chrisdone> b52: try it
03:28:20 <juhp_> Entroacceptor: http://paste.tryhaskell.org/71/manatee_tweaks_for_released_gtk2hs is what I have fwiw or you can bump to gtk2hs.darcs as ManateeLazyCat says
03:28:30 <ManateeLazyCat> juhp_: Daemon is separate process, you can consider it is "irc rounter" between irc server and client.
03:28:43 <juhp_> ok
03:28:44 <b52> i tried but didnt come to a solution, i could replace any, all and takeWhile with a foldr expression, but not dropWhile
03:28:49 <b52> thats why im asking if its possibl
03:28:51 <juhp_> I need to look at the code :)
03:28:51 <b52> e
03:29:31 <Zeiris_> How often is "tying the knot" used in practice? It's restricted to constant data structures only, right?
03:30:33 <b52> ManateeLazyCat: an irc client written in haskell?
03:30:50 <ManateeLazyCat> b52: Yes.
03:31:00 <ManateeLazyCat> b52: http://www.flickr.com/photos/48809572@N02/
03:31:00 <b52> called?
03:31:03 <Entroacceptor> juhp_: thanks, but too late ;)
03:31:22 <Entroacceptor> but it's not only an irc client, it's an emacs/gnome hybrid thingy 
03:31:43 <b52> all tools written by you in haskell ManateeLazyCat ?
03:31:43 <juhp_> right
03:31:44 <Entroacceptor> mhm, or not...
03:31:55 <Entroacceptor>     Not in scope: `iconThemeLookupByGIcon'
03:31:57 <ManateeLazyCat> b52: yes.
03:32:07 <ManateeLazyCat> Entroacceptor: Do you use darcs gtk?
03:32:19 <chrisdone> ManateeLazyCat: you like Owl City? :p
03:32:23 <Entroacceptor> yes, I think...
03:32:24 <juhp_> problem might be that version is not bumped in darcs perhaps?
03:32:27 <ManateeLazyCat> chrisdone: Yes.
03:32:50 <ManateeLazyCat> Wait, all, i check gtk2hs repository....
03:33:14 <juhp_> I think cabal-install prefers the cached hackage tarball bicbw
03:33:19 <Entroacceptor> I installed gtk2hs-darcs, then installed your gio-branch
03:33:28 <Entroacceptor> then reinstalled cairo, pango, gtk
03:33:39 <juhp_> okay
03:34:00 <juhp_> or you can use my patch :)
03:34:01 <ManateeLazyCat> Entroacceptor: Which your gtk version?
03:34:18 <ManateeLazyCat> Entroacceptor: iconThemeLookupByGIcon' at least need gtk 2.14
03:34:39 <Entroacceptor> or maybe it didn't do the reinstall
03:34:39 <ManateeLazyCat> Entroacceptor: I have check gtk2hs repository, have iconThemeLookupByGIcon.
03:34:40 <Entroacceptor> checking
03:34:52 <b52> chrisdone: how would you do it with foldr ?
03:34:58 <ManateeLazyCat> Entroacceptor: At gtk/Graphics/UI/Gtk/General/IconTheme.chs
03:35:29 <juhp_> gtk-0.11.2 has iconThemeLookupByGicon
03:35:32 <chrisdone> b52: foldr is just an alternative to explicit recursion. how would you write it with explicit recursion?
03:35:37 * hackagebot countable 0.1 - Countable, Searchable, Finite, Empty classes  http://hackage.haskell.org/package/countable-0.1 (AshleyYakeley)
03:35:42 <juhp_> what is the package version in darcs?
03:36:24 <ManateeLazyCat> juhp_: Still 0.11.2
03:36:37 <juhp_> I think that is bad
03:36:42 <b52> chrisdone: http://paste.tryhaskell.org/72/dropwhile_replacement
03:36:48 <ManateeLazyCat> juhp_: You need patch to gtksourceview?
03:36:57 <juhp_> yes
03:37:04 <juhp_> I think so
03:37:08 <Entroacceptor> ah, the re-build didn't happen
03:37:13 <Entroacceptor> it does lots of more stuff now
03:37:18 <juhp_> ok
03:37:37 <juhp_> ManateeLazyCat: for the released version
03:39:13 <Entroacceptor> mpf...
03:39:39 <ManateeLazyCat> juhp_: I have upload gtksourceview-0.12.0, don't need patch for gtksourceview now. :)
03:39:40 * hackagebot gtksourceview2 0.12.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.12.0 (AndyStewart)
03:39:53 <ManateeLazyCat> juhp_: ^^^ :)
03:39:56 <juhp_> ManateeLazyCat: yay
03:40:17 <ManateeLazyCat> Axel control gtk2hs repository, other package is mine. :)
03:40:24 <juhp_> :-)
03:40:43 <ManateeLazyCat> juhp_: Can you try install it?
03:40:45 <Entroacceptor> mad ~/workspace/manatee/manatee $ ghc-pkg list | grep gtk gtk-0.11.2
03:41:15 <chrisdone> b52: http://paste.tryhaskell.org/paste/72/with_foldr#p73
03:41:21 <Entroacceptor> but I still get the iconThemeLookupGyGIcon
03:41:35 <ManateeLazyCat> Entroacceptor: Which your gtk version?
03:42:01 <ManateeLazyCat> Entroacceptor: do "pkg-config --modversion gtk+-2.0"
03:42:38 <ManateeLazyCat> Entroacceptor: If gtk version lower than 2.14, gtk2hs won't compile that binding, because it's not exist in your gtk library.
03:42:39 <chrisdone> b52: woops I implemented takeWhile, sorry, haha
03:42:43 <Entroacceptor> 2.20.1
03:42:56 * chrisdone edits
03:43:28 <chrisdone> b52: refresh, lol
03:43:42 <ManateeLazyCat> Entroacceptor: ghc-pkg check?
03:43:46 <Entroacceptor> trying to rebuild all of gtk now
03:43:56 <ManateeLazyCat> Entroacceptor: I doubt you install old version of gtk.
03:44:02 <juhp_> ManateeLazyCat: I guess Entroacceptor is linking against gtk-0.11.2
03:44:26 <juhp_> Entroacceptor: I recommend bumping darcs by hand
03:44:30 <Entroacceptor> checking doesn't yield anything
03:44:39 <juhp_> just add .1 or something
03:44:49 <ManateeLazyCat> juhp_: darcs version is also 0.11.2, if he install from darcs, it should override gtk-0.11.2 from hackage.
03:45:05 <Entroacceptor> I think I didn't have it installed at all
03:45:11 <Entroacceptor> before doing the darcs stuff now
03:45:33 <ManateeLazyCat> juhp_: Can you install gtksourceview2-0.12.0 successful?
03:45:37 <juhp_> ManateeLazyCat: yeah but I have seen cabal overwrite local build with hackage...
03:45:41 <juhp_> ManateeLazyCat: building
03:46:44 <b52> but this way foldr applys drop on every item in the list, doesnt it?
03:46:48 <ManateeLazyCat> I need dinner now, leave message to me.
03:48:05 <tomh> hey, how would a haskell programmer deal with ffi bindings to something like box2d?
03:48:38 <chrisdone> > foldr f z [a,b,c,d,e]
03:48:39 <lambdabot>   f a (f b (f c (f d (f e z))))
03:49:46 <b52> so it applies drop to every item in the list
03:49:50 <chrisdone> yeah
03:50:20 <b52> so it wouldnt stop in the first time the function is true
03:50:43 <b52> instead it would leave every item out where the function is true and create a new list with the remaining items
03:51:04 <chrisdone> yep
03:51:06 <b52> but that isnt the intention of dropWhile orß
03:51:20 <b52> > dropWhile (>1) [3,4,1,2,3]
03:51:21 <lambdabot>   [1,2,3]
03:51:53 <juhp_> ManateeLazyCat: works well :)
03:51:53 <b52> so it isnt possible to express dropWhile with foldr chrisdone ?
03:52:26 <chrisdone> hm good point
03:53:03 <b52> well, the task in the book doesnt state to use foldr, i was just wondering
03:55:11 <ManateeLazyCat> I'm back.
03:55:15 <ManateeLazyCat> juhp_: Cool.
03:55:38 <ManateeLazyCat> juhp_: I can use new APIs in gtksourceview2 to build timestrap gutter at right.
03:55:57 <juhp_> cool
03:56:02 <ManateeLazyCat> juhp_: Like line number at left, and don't need write timestrap in TextBuffer like erc.
03:56:07 <ManateeLazyCat> juhp_: Then less bugs.
03:56:58 <juhp_> ManateeLazyCat: sounds good
03:57:05 <ManateeLazyCat> Entroacceptor: Any luck?
03:57:36 <ManateeLazyCat> juhp_: I need perfect some details, like unread track and offline browse.
03:57:44 <Entroacceptor> yes, found nice new errors :)
03:57:56 <ManateeLazyCat> juhp_: Then reader complicate, next irc-client.
03:58:07 <Entroacceptor> it fails to compile gtkimageview
03:58:28 <ManateeLazyCat> Entroacceptor: You need install GtkImageView C library first. 
03:59:01 <ManateeLazyCat> Entroacceptor: sudo aptitude install libgtkimageview-dev, i guess you're ubuntu user. :)
04:00:07 <Entroacceptor> you guessed wrond
04:00:08 <Entroacceptor> wrong
04:00:24 <ManateeLazyCat> Entroacceptor: Anyway, you need install develop library of gtkimageview.
04:00:27 <Entroacceptor> but I'm amazed I didn't have that already
04:00:31 <DanielDiaz> b52: you can split with foldl, and then extract your list
04:03:38 <b52> foldr (\x y -> f x : y) [] is equivalent to map f right?
04:03:46 <Feuerbach> b52: sorry, I wasn't following, have you expressed takeWhile using foldr already?
04:04:01 <b52> Feuerbach: i have
04:04:06 <Feuerbach> good :)
04:04:17 <DanielDiaz> b52: right
04:04:30 <juhp_> hmm adding constraint to .cabal/config does Weird Stuff to ~/.cabal/
04:05:00 <Feuerbach> b52: so, now struggling with dropWhile?
04:05:03 <b52> Feuerbach: takeWhile' f = foldr (\x y -> if f x then x:y else []) []
04:05:08 <b52> Feuerbach: yes
04:05:47 <DanielDiaz> h52: no, you have written a filter
04:06:15 <Feuerbach> DanielDiaz: no, why
04:06:17 <b52> ?
04:06:35 <Feuerbach> it would be "else y" in case of filter
04:06:55 <ManateeLazyCat> juhp_: BTW, manatee-mplayer can work for you?
04:07:28 <Entroacceptor> ooh, it compiled
04:07:28 <b52> filter p is equivalent to foldr (\x y -> if p x then x:y else y) [] right?
04:07:37 <DanielDiaz> True. Sorry. I read-error. :(
04:07:41 <ManateeLazyCat> Entroacceptor: gtkimageview? Or manatee-* ?
04:07:45 <Entroacceptor> manatee
04:07:49 <Entroacceptor> let's see what happens
04:07:51 <ManateeLazyCat> Entroacceptor: Cool.
04:07:56 <b52> hmm well you already said that -.-
04:08:00 <ManateeLazyCat> Entroacceptor: After you compile finish, type manatee.
04:08:08 <Entroacceptor> the commander popped up
04:08:10 <chrisdone> b52: hm no I don't think it's possible
04:08:17 <ManateeLazyCat> Entroacceptor: Do you have mplayer?
04:08:23 <Entroacceptor> ys
04:08:25 <Entroacceptor> yes
04:08:28 <ManateeLazyCat> Entroacceptor: Do you have some music directory
04:08:29 <ManateeLazyCat> ?
04:08:41 <Feuerbach> chrisdone: b52: it is, give me a few minutes :)
04:08:50 <ManateeLazyCat> Entroacceptor: Ok, then, type music directory, and type "M-/", then type "M-j" select "play directory".
04:08:51 <chrisdone> > foldr f z [a,b,c,d,e]
04:08:52 <lambdabot>   f a (f b (f c (f d (f e z))))
04:09:07 <b52> if its too complicated to understand for a novice forget it please Feuerbach :>
04:09:17 <DanielDiaz> b52: right
04:09:18 <ManateeLazyCat> Entroacceptor: Then it will popup mplayer playlist buffer play all music under your music directory.
04:09:25 <chrisdone> the f a happens before f e z
04:09:40 <chrisdone> there's no way for f a to tell f b, etc. that it's time to stop dropping
04:09:55 <ManateeLazyCat> Entroacceptor: Type "pdf file path", and then "M-m" to view pdf documentation
04:09:59 <chrisdone> it can only happen upwards from f e z
04:10:04 <ManateeLazyCat> Entroacceptor: Type "http://www.google.com" to search google.
04:10:11 <Entroacceptor> M-/?
04:10:14 <dcoutts__> juhp_: re constraints in .cabal/config,  any details on weirdness ?
04:10:16 <chrisdone> so if you reversed the list it'd work, but that's reversing the list
04:10:18 <ManateeLazyCat> Entroacceptor: Yes.
04:10:19 <Dilberto> Petition to pressure Kevin Rose to eat uncured pork bacon live on streaming video and drink COLD BEER with it. Have him prove that simple greed and or incompetence was the reason behind Digg 4.0 and its selling out and not something else, if you get my drift!
04:10:22 <Entroacceptor> that would be M-S-7 for me
04:10:23 <Dilberto> Sign the petition here:
04:10:25 <Dilberto> http://www.petitiononline.com/krbacon/petition.html
04:10:33 <chrisdone> Dilberto: please take the spam elsewhere
04:10:51 <Dilberto> Digg is dead!  all techies and programmers should be concerned!
04:11:21 <ManateeLazyCat> Entroacceptor: Maybe you have different keyboard layout?
04:11:31 <juhp_> dcoutts__: well sorry it might something local: it had a packages dir with a newline plus more appended to it
04:11:44 <Entroacceptor> can I acccess that function by doing M-x or so?
04:11:46 <Feuerbach> > let dw f l = snd $ foldr (\x (all, dropped) -> (x:all, if f x then dropped else x:all)) ([],[]) l in dw [3,4,1,2,3]
04:11:47 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
04:11:47 <lambdabot>         against inferred ...
04:11:49 <Dilberto> jig
04:11:51 <Dilberto> a
04:11:52 <Dilberto> boo
04:11:59 <ManateeLazyCat> Entroacceptor: Do you know anything.el in Emacs?
04:12:05 <Entroacceptor> no
04:12:12 <juhp_> dcoutts__: something like "packages\nconstraint: parsec < 3  share"
04:12:15 <ManateeLazyCat> Entroacceptor: My commander is search input and do for you.
04:12:22 <ManateeLazyCat> Entroacceptor: It's different with M-x
04:12:25 <Feuerbach> > let dw f l = snd $ foldr (\x (all, dropped) -> (x:all, if f x then dropped else x:all)) ([],[]) l in dw (>1) [3,4,1,2,3]
04:12:26 <lambdabot>   [1,2,3]
04:12:38 <Feuerbach> chrisdone: b52: ^^
04:12:41 <ManateeLazyCat> Entroacceptor: I will do mix similar feature in it.
04:12:43 <Entroacceptor> the commander disappeared and got replaced by a 'dired'
04:12:43 <dcoutts__> juhp_: oh interesting, would you mind pasting the ~/.cabal/config somewhere
04:13:00 <ManateeLazyCat> Entroacceptor: I guess you open music directory?
04:13:24 <ManateeLazyCat> Entroacceptor: When you type directory name, if you type "M-m", it will open in dired.
04:13:34 <juhp_> dcoutts__: sure - all I changed with adding "constraint: parsec < 3" I think but hang on
04:13:39 <b52> Feuerbach: thats sort of cheatin ...
04:13:41 <juhp_> with = was
04:13:42 <ManateeLazyCat> Entroacceptor: If you do "M-/" and "M-j" "M-m", it will play directory.
04:13:47 <Entroacceptor> but dired doesn't do anything
04:14:05 <Feuerbach> b52: why?
04:14:18 <ManateeLazyCat> Entroacceptor: Can you do : type music directory => "M-/" => "M-j" => "M-m" ?
04:14:27 <chrisdone> Feuerbach: ah, cute
04:14:48 <Entroacceptor> doesn't do anything
04:14:58 <Entroacceptor> but I think M-/ is the problem
04:15:13 <ManateeLazyCat> Entroacceptor: You can type M-/ ?
04:15:24 <Entroacceptor> ah, yes, I can
04:15:27 <ManateeLazyCat> Entroacceptor: M-/ is Alt-/
04:15:50 <Entroacceptor> I think it lost focus there
04:15:53 <ManateeLazyCat> Entroacceptor: Got music playing?
04:15:56 <Entroacceptor> but mplayer doesn't start
04:16:02 <Entroacceptor> Mplayer daemon process not run, startup it.
04:16:02 <Entroacceptor> manatee: <<System.Glib.GError.GError>>
04:16:11 <b52> Feuerbach: cause you change the internal structure to store the needed information
04:16:18 <juhp_> dcoutts__: http://paste.tryhaskell.org/75/cabal_config_with_constraint
04:16:26 <ManateeLazyCat> Entroacceptor: Oh, gio bug, change other directory and try again..
04:16:41 <Entroacceptor> can I go back to the commander from that grey window?
04:16:45 <dcoutts__> juhp_: ta
04:16:48 <juhp_> cabal-install-0.8.2
04:16:52 <ManateeLazyCat> Entroacceptor: Can you give the directory name to me? Then i can debug this bug.
04:16:57 <ManateeLazyCat> Entroacceptor: M-f
04:17:17 <ManateeLazyCat> Entroacceptor: Or M-;
04:17:59 <ManateeLazyCat> Entroacceptor: I think you have got my framework design, <<System.Glib.GError.GError>> crash mplayer module, but core and other module still running, see? :)
04:18:31 <ManateeLazyCat> Entroacceptor: You can change some directory to play music.
04:18:45 <ManateeLazyCat> Entroacceptor: If you want try browser, type "http://www.google.com" in commander.
04:18:50 <Feuerbach> change from _what_? The second parameter is just an accumulator (state), there is no "canonical" meaning assigned to it, it can be used however I want. The key point is the structure of recursion is still foldr.
04:18:53 <ManateeLazyCat> Entroacceptor: Then you can open webkit browser.
04:19:21 <ManateeLazyCat> Entroacceptor: Open you image directory, type key "m" to open image in image-viewer.
04:19:42 <ManateeLazyCat> Entroacceptor: Type *.hs path, open in editor.
04:20:18 <ManateeLazyCat> Entroacceptor: After you open any buffer, press F3 to open RSS reader, press F2 to open process-manager.
04:20:55 <ManateeLazyCat> Entroacceptor: type "irc.freenode.net:6667#haskell" => "M-j" => "M-m" to open irc channel.
04:21:02 <Entroacceptor> not so fast :)
04:21:28 <Entroacceptor> I don't get it when the selection is for the directory or a single file
04:21:31 <ManateeLazyCat> Entroacceptor: Well, those are most features have implementation, next step, mail-client, and terminal.
04:21:58 <Entroacceptor> but play-directory didn't work
04:22:02 <Entroacceptor> playing a single file did
04:22:16 <ManateeLazyCat> Entroacceptor: I think it's a bug of gio that i have't finish.
04:22:34 <ManateeLazyCat> Entroacceptor: I also got this bug, just haven't found cause.
04:22:44 <ManateeLazyCat> Entroacceptor: So play single file can work?
04:22:46 <Entroacceptor> and for various dirnames
04:23:17 <ManateeLazyCat> Entroacceptor: "play directory" can works with some direname, i guess some dirname cause this bug.
04:23:44 <Entroacceptor> does it look for ogg files, or only mp3?
04:23:56 <ManateeLazyCat> Entroacceptor: All mplayer can support.
04:24:32 <ManateeLazyCat> Entroacceptor: Can't support video now, i need think how to integrate video view in my framework since i can split window like Emacs.
04:24:52 <ManateeLazyCat> Entroacceptor: I don't want play one video in different window even i can.
04:25:31 <ManateeLazyCat> Entroacceptor: Maybe popup window is good solution, but now i haven't so much time on those problem..
04:25:48 <Entroacceptor> it doesn't work that well with my xmona
04:25:49 <Entroacceptor> d
04:25:51 <ManateeLazyCat> Entroacceptor: I will focus on bug fix when i release first version.
04:26:06 <ManateeLazyCat> Entroacceptor: Why?
04:26:55 <Entroacceptor> oh, single oggs stop after a few seconds
04:27:55 <ManateeLazyCat> Entroacceptor: Can you send your ogg file to me?
04:28:20 <ManateeLazyCat> Entroacceptor: Maybe something wrong with mplayer daemon process.
04:29:41 * ManateeLazyCat Maybe i need create some wiki page, i have some tired to repeat those words...
04:30:03 <Entroacceptor> different oggs
04:30:17 <Entroacceptor> and yes, create documentation :)
04:32:04 <ManateeLazyCat> Entroacceptor: I need off now, send mail to me. Any suggestion and bug report are welcome!
04:32:05 <ManateeLazyCat> :)
04:32:40 <Entroacceptor> cu 
04:42:22 <ManateeLazyCat> juhp_: Do you have any idea that improve UI of manatee-reader? 
04:43:43 * ManateeLazyCat Well, off now...
04:46:56 <b52> ok i think i need again a little help
04:48:57 <Feuerbach> b52: ?
04:49:34 <b52> wait, ill nopaste my problem, again a task from my book
04:51:59 <b52> http://paste.tryhaskell.org/76/unfold_iterate
04:53:11 <yitz> b52: null doesn't need to be in parens
04:53:35 <b52> yitz: i know but it makes it more obvious to me
04:53:55 <yitz> b52: anyway for iterate' to be the same as iterate, use "const False" instead of null - iterate always produces an infinite list
04:54:16 <b52> i dont even know what "const False" mean
04:54:26 <yitz> > const False 42
04:54:26 <lambdabot>   False
04:54:27 <Kaidelong> I like unfold better when done the F# way
04:54:41 <yitz> > const False "it doesn't matter what I write here"
04:54:42 <lambdabot>   False
04:55:01 <mauke> > const x y
04:55:01 <lambdabot>   x
04:55:13 <yitz> @src const
04:55:13 <lambdabot> const x _ = x
04:55:35 <b52> hmm k
04:55:42 <Kaidelong> unfold f x = x : case (f x) of {Some y -> unfold f y; None -> []}
04:55:44 <b52> but acutally thats not the problem
04:56:07 <yitz> b52:  so what is?
04:57:01 <b52> the rest oO
04:57:11 <yitz> Kaidelong: in haskell that's known as unfoldr
04:57:19 <b52> i dont know how i can apply the function incremental to every item using the supplied unfold function
04:57:20 <yitz> Kaidelong: more or less
04:57:27 <yitz> @src unfoldr
04:57:27 <lambdabot> unfoldr f b  = case f b of
04:57:28 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:57:28 <lambdabot>    Nothing        -> []
04:57:28 <Kaidelong> > let unfold f x = x : case (f x) of {Just y -> unfold f y; None -> []} in unfold (fmap (^2)) 2
04:57:29 <lambdabot>   Not in scope: data constructor `None'
04:57:37 <Kaidelong> > let unfold f x = x : case (f x) of {Just y -> unfold f y; Nothing -> []} in unfold (fmap (^2)) 2
04:57:38 <lambdabot>   Occurs check: cannot construct the infinite type:
04:57:38 <lambdabot>    a = Data.Maybe.Maybe a
04:57:50 <Kaidelong> oh right lol
04:57:58 <Kaidelong> > let unfold f x = x : case (f x) of {Just y -> unfold f y; Nothing -> []} in unfold (Just . (^2)) 2
04:57:59 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
04:58:23 <Kaidelong> aheasy enough then
04:58:36 <yitz> b52: iterate doesn't apply a function to every item in a list. it takes a single item, and keeps applying the function to it over and over again.
04:58:39 <Kaidelong> and yes, my version is wrong
04:58:53 <yitz> b52: then returns the infinite list of all of those
04:59:16 <b52> > interate (*2) 1
04:59:17 <lambdabot>   Not in scope: `interate'
04:59:21 <b52> > iterate (*2) 1
04:59:22 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:59:27 <b52> oh i see
04:59:29 <b52> my fault
04:59:31 <hpc> > unfoldr (>>= (^2)) 2
04:59:32 <lambdabot>   Occurs check: cannot construct the infinite type:
04:59:32 <lambdabot>    a = Data.Maybe.Maybe (...
04:59:40 <b52> i think ill get it myself
04:59:42 <b52> thanks
04:59:45 <yitz> b52: so your h function should just apply f one more time, and the t function should arrange things so that next time around it will keep going with the result of that
04:59:56 * yitz tries hard not to totally give it away
05:03:14 <b52> thats how ive done it: iteratef' f = unfold (\x -> False) (id) (f)
05:06:05 <b52> btw programming in haskell is probably one of the best teaching books ive ever read so far
05:06:30 <chrisdone> cool
05:06:36 <chrisdone> is that graham's?
05:06:55 <chrisdone> yah
05:08:03 <mauke> b52: ew, too many parens
05:08:45 <yitz> > let iterate' f = unfold (\_ -> False) id f; unfold p h t x | p x = [] | otherwise = h x : unfold p h t (t x) in iterate' (+3) 7
05:08:46 <lambdabot>   [7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79,...
05:08:57 <yitz> b52: looks good!
05:10:08 <b52> mauke: makes the structure more obvious to me
05:10:11 <b52> chrisdone: yes
05:10:16 <b52> yitz: :)
05:18:09 <dcoutts__> juhp_: hmm, I can't reproduce the behaviour you've seen
05:18:31 <dcoutts__> juhp_: if you can reproduce it reliably please file a ticket with all the details
05:18:49 <juhp_> dcoutts__: ah sorry - yep will do that
05:19:03 <juhp_> I've removed the constraint again fwiw
05:21:34 <tomh> no one here has advice how to deal with state if you use FFI to talk to box2d from haskell for example?
05:23:55 <yitz> box2d keeps internal state?
05:26:30 <tomh> yes
05:26:56 <McManiaC> is there something like erlangs node-message system for haskell?
05:27:13 <Twey> McManiaC: Personally I prefer DBus
05:27:24 <McManiaC> dbus?
05:27:34 <Martty> dtrain and dsubway too
05:27:42 <Martty> theyre safe and environment safe
05:28:05 <Twey> McManiaC: But you can actually use the Erlang protocol from Haskell: there's http://hackage.haskell.org/package/erlang
05:28:50 <Mitar> any way how to solve this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29733#a29733 ?
05:29:08 <tomh> yitz: any idea?
05:31:11 <Lemmih> Mitar: You can't really do it like that. Use data structures instead of type-classes.
05:31:26 <Mitar> where? ;-)
05:31:27 <Jonno_FTW> I am using the memocombinators library http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/Data-MemoCombinators.html, and I can't figure out how to memoise a function of type Int -> [Int]
05:31:33 <Mitar> i would like it to be open
05:31:44 <Mitar> so that later on i can define new neurons
05:31:55 <Lemmih> Mitar: Everywhere. Type-classes aren't like classes from most OO languages.
05:32:29 <Lemmih> Mitar: It can be open ended with data structures, too.
05:32:35 <Mitar> like?
05:32:55 <yitz> tomh: usually, when binding to an external library that keeps internal state, the only thing to do is to keep all of the bindings in the IO monad and use the external API to send messages to manipulate the state
05:33:22 <Mitar> i read Fun with types functions yesterday and i thought type families can help
05:33:30 <Mitar> but i am not really sure how to add that
05:33:39 <Lemmih> Mitar: Simple example: data Shape = Shape { drawShape :: IO () }; circle = Shape { drawShape = drawCircle }
05:33:53 <tomh> yitz: what if you need to get that data out of the state?
05:34:02 <tomh> and bind it to your own data
05:34:31 <yitz> tomh: you have to ask the API politely to give it to you, in the IO monad.
05:35:23 <tomh> but in the case of box2d, it assumes you already have it
05:35:24 <Lemmih> Mitar: You're trying to push a square block into a round hole. Type-classes aren't meant to solve that kind of problem.
05:35:51 <tomh> normally when you use box2d it assumes you have a pointer or something to the objects which will be manipulated
05:36:02 <Mitar> i think they are used to solve expresion problem
05:36:10 <Mitar> and i think i have exactly this
05:36:32 <tomh> if you retrieve all the data after its done simulating, then you have to pass through all of them and map it to your objects
05:36:49 <yitz> tomh: sometimes, if you are lucky, you can simulate purity, but it needs to be a very powerful API and you need to know the internals of it extremely well. then, you might be able to prove that you have the right guarantees so that you can use usafePerformIO.
05:37:19 <tomh> what if im unlucky? :)
05:37:19 <Lemmih> Mitar: It seems like you want something like classes from C++. And type-classes are definitely not like C++ classes.
05:37:34 <Mitar> lemmih: here is something http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29733#a29734 i made with dependencies
05:37:38 <yitz> tomh: so then you need to hold on to those pointers, and keep using them in the IO monad the same way you would in C. :(
05:37:50 <tomh> mm i see
05:37:50 <Mitar> but i thought type families would be cleaner
05:38:01 <tomh> ok well thanks for your advice
05:38:19 <Mitar> i was also reading Software Extension and Integration with Type Classes (Ralf Lammel, Klaus Ostermann)
05:38:27 <Mitar> where they compare OOP with type classes
05:38:31 <tomh> I will ask some teachers at my school if they have any experience
05:38:45 <Mitar> and show how can type classes be used to solve OOP problems
05:38:48 <Mitar> this is why i am using them
05:38:52 <tomh> hard to find any information about it
05:39:03 <yitz> tomh: about what, the API?
05:39:13 <tomh> just how to deal with this situation elegently
05:39:20 <Lemmih> Mitar: Type-classes /can/ be used for a lot of things. That doesn't mean that they're the best fit for the problem.
05:39:33 <Funktorsalat> hmm I'm trying to use unsafePerformIO for a unique-id counter, but all my nodes are getting the same id ;)
05:39:37 <yitz> tomh: it's not likely to be elegant.
05:39:47 <tomh> thats what i was afraid for 
05:39:53 <Funktorsalat> I have the function that bumps and reads the IORef marked with NOINLINE ...
05:40:29 <tomh> but i want my teachers to think about this problem before they give me bad grades by presenting something unhaskellly :p
05:41:03 <yitz> tomh: you can still profit from Haskell's type system, though. that does give you something beyond what C can do. You store the various pointers, handles, etc. inside Haskell datatypes that prevent you from using the wrong thing in the wrong context.
05:41:17 <tomh> yeah
05:41:35 <tomh> but still u loss the purity 
05:41:39 <tomh> *you
05:41:40 <yitz> right
05:41:51 <yitz> but with that you're not any worse off than in C
05:41:52 <tomh> which is kind of the core of functional programming right?
05:41:57 <Mitar> lemmih: but is not your solution to pass around explicit functions in a data where we could pass them implicitly with type classes?
05:42:14 <yitz> tomh: right. complain to the library authors. :)
05:42:21 <tomh> hehe
05:42:40 <tomh> like they give a * about some dude using FP to talk to their hard core optimized c++ libs ;p
05:43:01 <tomh> ok anyway thanks for your advice, gotta get going
05:43:02 <yitz> tomh: someday they will.
05:43:08 <Funktorsalat> nevermind, I solved it by adding an ignored parameter to the unsafeBumpNr ;)
05:43:08 <tomh> lets hope :)
05:43:20 <Nibble> Hello, how can I construct a bytestring from a String
05:43:30 <Lemmih> Mitar: Yes. Doing it implicitly is a mightly bit harder and doesn't buy you much.
05:43:37 <yitz> tomh: "so, how do you use your library with 1000 cores efficiently?" "umm...."
05:43:45 <mauke> :t Data.ByteString.Char8.pack
05:43:46 <lambdabot> String -> BSC.ByteString
05:43:51 <Nibble> I see
05:44:02 <Nibble> but isn't that the Char8 version?
05:44:25 <Funktorsalat> ( [ MakeNode foo (unsafeBumpNr ref foo) | foo <- foos ], fyi)
05:44:28 <mauke> Nibble: yes?
05:44:44 <Mitar> and how i can do it implicitly?
05:44:44 <Funktorsalat> the 'foo' is ignored but avoids all the nodes getting the same number...
05:44:56 <Nibble> mauke: I am using Data.ByteString, not .Char8
05:44:59 <Mitar> (it is also that i would like to solve this to learn something)
05:45:03 <Nibble> same function there too?
05:45:16 <Mitar> (and I agree that your proposal is most straitforward)
05:45:36 <Nibble> The char8 version is easier tho
05:45:37 <Nibble> so nvm
05:46:27 <mauke> Nibble: do you know what Char8 is?
05:47:17 <yitz> tomh: look at gtk2hs or wxHaskell for nice examples of this stuff
05:47:39 <Nibble> mauke: I sure know.
05:49:01 <yitz> Nibble: each character in a String is a Unicode character. how do you want to encode those into bytes?
05:49:18 <Lemmih> Mitar: You have to make sure that the exsitential type variable doesn't escape.
05:50:41 <Mitar> escape from the module?
05:50:53 <Lemmih> Mitar: Escape from its scope.
05:51:42 <yitz> Nibble: use Data.Text.pack :: String -> Text, then use one of the functions of type Text -> ByteString in Data.Text.Encodings
05:52:26 <Lemmih> Mitar: I've annotated your paste.
05:52:29 <Mitar> thanks
05:52:41 <Nibble> Well, this one worked: append' = B.appendFile filePath (pack "TestTest Test")
05:52:50 <Nibble> where filePath is of type FilePath
05:53:32 <Mitar> aha, why is it a big no-no?
05:54:24 <Lemmih> Mitar: Imagine: getX (ShowX False) :: Int.
05:55:23 <Mitar> hm, will type checker prevent this?
05:55:25 <Lemmih> Mitar: The 'x' in ShowX has no relation to the 'x' in the type signature for getX.
05:55:53 <Lemmih> Mitar: Yes, but only by making getX invalid.
05:57:49 <Mitar> ok
05:58:24 <Mitar> but this will not solve ambiguity in my initial post
05:58:32 <Mitar> s/post/paste/
05:59:02 <Lemmih> Mitar: The two problems are quite similar.
05:59:21 <Lemmih> Mitar: Do you see why 'attach' doesn't type-check in your original paste?
06:02:22 <Mitar> yes, it does not know which type to choose from
06:03:05 <Mitar> what i would like to have is a  chan which can get different types of impulses, which are all of the same type class
06:03:23 <Mitar> and then attach to this one same chan diferent neurons, to send impulses into it
06:03:38 <Mitar> which will be then on other side read and acted upon
06:04:39 <Lemmih> Mitar: I don't see why you want Neuron to be a type-class.
06:05:07 <Lemmih> But ok, let's see what we can do.
06:05:17 <mietek> Is it possible to catch exceptions generated by error in pure code?
06:05:28 <Lemmih> mietek: No.
06:05:40 <mietek> Thanks.
06:06:03 <Mitar> so i did one try with dependencies, but i have not yet solved the problem of having only one chan for all impulses
06:06:03 <Lemmih> mietek: You did mean catch it in pure code, right?
06:06:12 <mietek> Yes.
06:06:36 <Mitar> mietek: this would be side effects
06:07:32 <mietek> Mitar: what do you mean?
06:08:01 <Mitar> if you would be able to catch in pure code this would mean that you would be able to alter execution of pure code by action in some other pure code function
06:08:07 <Mitar> this is what is called a side effect
06:08:12 <Mitar> and is a propery of non-pure code
06:08:56 <mietek> I'm missing why is generating an exception and catching it necessarily impure.
06:09:28 <Mitar> hmm, true
06:09:35 <Lemmih> mietek: It depends on execution order.
06:10:01 <mietek> Lemmih: can you explain?  I don't see it.
06:10:09 <Mitar> yes, it is not deterministic
06:10:30 <Lemmih> mietek: Which exception will be thrown: error "a" + error "b"
06:10:57 <mietek> Well, that seems to depend on the evaluation order.
06:11:11 <mietek> Is it undefined in Haskell?
06:11:16 <Lemmih> mietek: Yes.
06:11:17 <Mitar> of course ;-)
06:11:21 <mietek> Ah.
06:11:38 <Mitar> it is a lazy language
06:11:56 <mietek> I could see a language being lazy and yet deterministic, no?
06:12:05 <Mitar> (but i am not sure if this really implies that order is undefined)
06:12:27 <Jafet> mietek: could you? Haskell is.
06:12:30 <Mitar> but probably it is easier to do a lazy language if you not promise evaluation order ;-)
06:12:31 <Lemmih> mietek: Yes but Haskell is technically non-strict.
06:12:37 <Jafet> (For the most part...)
06:12:52 <Lemmih> mietek: http://www.haskell.org/haskellwiki/Lazy_vs._non-strict
06:12:58 <mietek> Thanks.
06:14:37 * Mitar reads it too
06:15:02 <Lemmih> Mitar: I'm still not sure what you're trying to do with the neurons.
06:15:21 <Mitar> neurons will be threads firing impulses and feeding them into one chan
06:15:34 <Mitar> and one other thread will read from there and act upon
06:15:38 <Mitar> this is all
06:15:43 <Mitar> i just want to make this modular
06:16:03 <Mitar> so that i can add different kinds of neurons (hopefully at the runtime)
06:16:08 <Mitar> and that things still type-check
06:16:25 <Mitar> (so one easy solution would be to use Dynamic, but I do not like that)
06:16:55 <Mitar> so I thought I would define Impulse class - so everything which implements it coudl go into a chan
06:17:13 <Lemmih> Mitar: I'd start by making everything explicit and then move over to type-classes if need be.
06:17:15 <Mitar> and then Neuron class which would be those which would fill chan with impulses
06:18:25 <Lemmih> Mitar: It should be quite easy to changed the code to use type-classes once you have the explicit model up and running.
06:18:40 <Mitar> i have two already
06:18:46 <Mitar> but i cannot use them together
06:18:51 <Lemmih> Two what?
06:18:56 <Mitar> neurons ;-)
06:19:07 <Mitar> based on my second approach
06:19:13 <Mitar> (i ammended)
06:19:17 <Mitar> with dependencies
06:19:28 <Mitar> the problem is only that i get two separate channels
06:19:39 <Mitar> i cannot use one channel on both
06:20:14 <Lemmih> Why not?
06:20:16 <Mitar> (especially because in this case channel implies impulse which implies neuron to use so haskell solves the ambuigity this way)
06:21:06 <Lemmih> You have two 'Chan Impulse' and you only want one?
06:21:08 <Mitar> i have not yet tried with exsistencial types as i tried to move first to type families
06:21:12 <Mitar> yes
06:21:30 <Mitar> i want one which will be able to get any impulse which implements ImpulseClass
06:21:33 <Lemmih> Create two threads that read from those chans and write to another.
06:22:26 <Mitar> but this is an ugly hack to get arond types?
06:23:02 <Lemmih> I don't see where the types are getting in the way.
06:26:17 <Lemmih> Mitar: How about if each neuron contains an input chan and a "pointer" to an output chan?
06:26:43 <Mitar> i am not sure what you mean?
06:26:58 <Mitar> input and output chans are seperate
06:27:07 <Mitar> we can for now thing that neuron's have only one chan
06:27:13 <Mitar> just to send something away from them
06:27:18 <Mitar> to reciever
06:27:45 <Mitar> the point is that i want for reciever to have one chan to read from
06:28:45 <Lemmih> Mitar: That we can do.
06:29:42 <Lemmih> Mitar: I'm not completely up-to-date on my neurology but neurons only send information one way, right?
06:30:20 <Mitar> yes
06:30:23 <sshc> How does cabal build differently from ghc --make?
06:30:49 <sshc> My program isn't behaving correctly when cabal builds it, but it does when I build it by hand with "ghc --make"
06:30:53 <Lemmih> sshc: It add a couple of more flags.
06:31:11 <Saizan> sshc: you can pass -v to see the commands it calls
06:31:28 <sshc> Saizan: Thanks, I'll do that
06:31:29 <Lemmih> Mitar: And we connect neurons directly to other neurons, right?
06:31:37 <Mitar> yes
06:31:43 <Mitar> but in this case this is not yet important
06:32:00 <Mitar> let us say that we have some completely other "thing" which recieves
06:35:50 <Lemmih> Mitar: I've annotated your paste.
06:36:54 <Lemmih> Mitar: A single input chan, a list of target chans. Connecting A to B means adding B's input chan to A's list of target chans.
06:37:52 <Mitar> hmm
06:38:16 <Mitar> but how we make Impulse be of open data type?
06:38:31 <Mitar> so that neurons can define their own types to return
06:38:53 <Mitar> we make Impulse with ExistentialQuantification
06:38:54 <Mitar> ?
06:39:09 <Kaidelong> does haskell have anything like F#'s events? Reader and Writer?
06:39:33 <Lemmih> Mitar: Right, Impulse can still be defined using ImpulseClass.
06:39:34 <Kaidelong> I imagine it might not without being confined in IO
06:39:49 <Kaidelong> in which case I will have to redesign a bit what I did here
06:42:03 <Kaidelong> yeah, I suppose anything event like would have to be done in IO
06:42:30 <Kaidelong> that said, should I be looking at reader and writer?
06:42:39 <Kaidelong> IE can you do stuff like filter over a reader
06:44:31 <Lemmih> Kaidelong: Try describing what it is you wanna do. Most of us aren't familiar with F#.
06:44:58 <Kaidelong> what I had was something that filters an F# events to listen for keypresses, but only certain kinds of keypresses
06:45:13 <Kaidelong> and then scans over them to get patterns out
06:45:38 <Kaidelong> when the scan matches something it invokes the appropriate handler
06:45:52 <Lemmih> Kaidelong: List comprehension comes to mind.
06:46:00 <Kaidelong> it is very similar yes
06:46:09 <Kaidelong> the methods are called filter, scan, map etc
06:46:20 <Kaidelong> well not a comprehension specifically
06:46:24 <Kaidelong> but F# events are a lot like lists
06:46:37 <Lemmih> Kaidelong: Will list comprehension do, then?
06:47:07 <Kaidelong> hmm, well I need to hook stuff up to the list and have stuff read off of it asynchronously
06:47:09 <dcoutts__> sshc: it's most likely because you're not specifying all the dependencies in the .cabal file
06:47:41 <Kaidelong> essentially... a listener
06:47:48 <Kaidelong> can I write listeners using just lists?
06:47:51 <Kaidelong> that'd be kind of cool
06:48:20 <sshc> dcoutts__: How could it build if I missed dependencies in the .cabal file?
06:48:35 <hpc> it would be a list of [(Key, IO ())]
06:48:58 <sshc> Both programs run, but they behave differently.  The cabal-built program hangs at a point, but the hand-built program runs as it should
06:49:22 <Kaidelong> the essential problem is what happens when you're waiting for the next key
06:50:14 <Kaidelong> rest of program should not block because it's waiting on the next part of the list to be input
06:50:59 <Lemmih> Kaidelong: GHC's thread system is quite good.
06:51:04 <shum> Kaidelong: maybe your are looking for something like libev
06:51:15 <shum> there is a binding for it
06:52:29 <hpc> :t fail
06:52:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
06:57:22 <feep> hi
06:57:49 <ski> lo
06:57:57 <feep> I'm not a Haskell programmer myself, but as a person working on a language that is intended to incorporate list comprehension and some related semi-fp features, I have a problem and a challenge.
06:58:08 <feep> the problem: I want to draw an OpenGL cube, from -1 to 1 using triangles.
06:58:18 <feep> The challenge: I cannot work out how to do this elegantly.
06:58:45 <chrisdone> use regular expressions!
06:58:50 <feep> I wrote down a list of indices into [-1, 1]^3, but I can't seem to make out any underlying structure
06:58:59 <b52> ERROR "pih8.hs":18 - Ambiguous variable occurrence "return"
06:59:01 <b52> *** Could refer to: Main.return Hugs.Prelude.return 
06:59:03 <b52> can i change that?
06:59:29 <chrisdone> b52: don't redefine `return'
06:59:30 <feep> er, [-1, 1]^3 == [(-1, -1, -1), (-1, -1, 1), (-1, 1, -1), etc]
06:59:33 <ski> b52 : if you must have an operation called `return', use `import Prelude hiding (return)'
07:00:05 <ski> > replicateM 3 [-1,1]
07:00:06 <lambdabot>   [[-1,-1,-1],[-1,-1,1],[-1,1,-1],[-1,1,1],[1,-1,-1],[1,-1,1],[1,1,-1],[1,1,1]]
07:01:05 <feep> yeah
07:01:06 <ski> feep : i'm not quite sure i understand the problem
07:01:19 <ski> you want to generate that using a list comprension ?
07:01:23 <dcoutts__> sshc: right, it would not build. Ah I see you said that the program behaves differently, I'd initially thought you meant it did not build at all.
07:01:28 <feep> ski: that'd be easy :3
07:01:30 <feep> ski: I mean:
07:01:34 <ski> or you want advice on how to add list comprehensions to a language ?
07:01:38 <b52> ski: thanks
07:01:41 <aristid> > replicateM 2 [0..3]
07:01:42 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1],[2,2],[2,3],[3...
07:01:47 <Jafet> You can't triangulate a cube... you can triangulate its faces though
07:01:53 <feep> ski: generate a series of triples of indices into that list, so that if each entry in that list were, in sequence, fed to glVertex in the context of GL_TRIANGLES, it'd result in a cube.
07:01:53 <aristid> > length $ replicateM 2 [0..3]
07:01:54 <lambdabot>   16
07:02:02 <aristid> > length $ replicateM 3 [0..3]
07:02:03 <lambdabot>   64
07:02:16 <feep> entry in that series*
07:02:41 <sshc> dcoutts__: The problem seems to be the -O flag
07:02:52 <ski> feep : ok (i know next to nothing about OpenGL)
07:02:59 <aristid> length (replicateM n x) == length x ^ n, methinks
07:03:03 <feep> ski: it's fairly obvious, three vertices == triangle
07:03:38 <Jafet> feep: so, how would you triangulate the faces of a cube, in any other language?
07:03:44 <Jafet> And why not use gl_rects?
07:05:01 <feep> Jafet: I'd enumerate the indices manually.
07:05:08 <feep> But this seems unelegant to me.
07:05:14 <feep> I was wondering if there was a better, underlying structure.
07:05:31 <dcoutts__> sshc: ahh, something that is affected by optimisations
07:05:50 <Jafet> feep: Haskell may look like a silver bullet, but it will still shoot you in the foot.
07:05:51 <dcoutts__> sshc: is it taking much more memory at runtime when built with -O then?
07:06:26 <feep> I wasn't so much looking at haskell in specific as at #haskell as a community of people used to elegant, functional solutions.
07:06:39 <sshc> dcoutts__: It hangs with either -O or -O2
07:06:48 <feep> honestly I just need something neat to optimize my list comprehension design towards :3
07:08:05 <Jafet> feep: I would consult a book, and pick the best algorithm, and then figure out how to do that in whatever language I'm using
07:08:37 <dcoutts__> sshc: that could be tricky to investigate, you'll have to try and narrow it down. Is it really hanging or just taking a long time because of a space leak?
07:08:40 <feep> I don't think there are preexisting solutions.
07:08:45 <feep> A quick google turned up nothing ontopic.
07:08:45 <Jafet> A winged-edge representation should work with lists.
07:09:22 <feep> I'm really not looking for a general solution, merely asking if anybody could think of an elegant expression of vertex order for cubes in specific.
07:09:35 <dcoutts__> sshc: there are various possibilities, including incorrect RULES in your code or libs, some subtle sharing issue that is affected by optimisation
07:09:53 <dcoutts__> sshc: or if your program uses threads then perhaps it's a timing issue
07:10:15 <sshc> dcoutts__: I know the point in my source at which this is occuring
07:10:22 <feep> eh, bbiab.
07:10:25 <sshc> dcoutts__: I have monadic loop
07:10:38 <sshc> dcoutts__: There doesn't seem to be a significant amount of memory used
07:11:21 <sshc> dcoutts__: Non-optimized loops correctly, but optimized hangs when the monad is executed for the second time
07:12:03 <dcoutts__> sshc: if you're unable to track it down, you can ask for help on the haskell-cafe mailing list, but you'll have to post the test case of course
07:16:37 <ManateeLazyCat> dcoutts__: Do you know any idea about pixbuf memory leak? Just ask, maybe you know......
07:23:42 <Igloo> Do utf8-string and text both solve the same problem?
07:30:00 <yitz> Igloo: text is far more general than utf8-string
07:30:27 <Igloo> OK, so if you have text then you don't need utf8-string?
07:30:54 <yitz> Igloo: text is like ByteString, but for Unicode instead of binary bytes
07:31:00 <yitz> Igloo: correct
07:31:10 <Igloo> Thanks!
07:33:11 <dcoutts__> ManateeLazyCat: I've no idea
07:33:20 <dcoutts__> ManateeLazyCat: I've not looked into the issue
07:33:48 <dcoutts__> Igloo: right, text is the proper solution and utf8-string was a stop-gap solution
07:35:01 <ManateeLazyCat> dcoutts__: There have many "IO Pixbuf" translate function in Pixbuf module that accept *old* Pixbuf and return *new* Pixbuf, problem is when you got new Pixbuf, the old Pixbuf looks can't free by GC correctly, then cause memory leak, special some software like Image-Viewer.
07:36:13 <ManateeLazyCat> dcoutts__: I have use pixbuf develop a image-viewer (screenshot at http://www.flickr.com/photos/48809572@N02/4947462492/), pixbuf will eat memory every time i call "Pixbuf -> ... -> IO Pixbuf" function.
07:37:01 <dcoutts__> ManateeLazyCat: you say it cannot be GC'ed correctly, do you know any more details?
07:37:06 <dcoutts__> why not?
07:37:51 <dcoutts__> ManateeLazyCat: is it simply that the GC has not run yet and thus not freed the pixbuf?
07:39:23 <ManateeLazyCat> dcoutts__: When i pass new pixbuf to my image-viewer function, it will compare with old pixbuf, if not equal, it will use g_object_unref decrease the counter of old pixbuf, with this logic, old pixbuf's memory should release by GC when count equal 0, but don't know why old pixbuf can't release.
07:40:08 * ManateeLazyCat pasted "pixbuf memory leak code" at http://paste2.org/get/976625
07:40:21 <ManateeLazyCat> dcoutts__: Above code can recur bug.
07:40:59 <ManateeLazyCat> dcoutts__: Not just pixbufScaleSimple, any "IO Pixbuf" has this problem. My problem is i don't know how to debug GC.
07:43:10 <ManateeLazyCat> dcoutts__: Can you give me some information that how to debug GC?
07:44:35 <ManateeLazyCat> dcoutts__: I think problem is not GC haven't run yet, looks some thing make GC failed that can't free pixbuf.
07:48:05 <dcoutts__> ManateeLazyCat: ahh, ok so the problem is that things have been set up so that pixbufs are only freed from the main loop
07:48:19 <cinayakoshka> any way to do something like the following without going into an infinite loop?
07:48:23 <cinayakoshka> let prs = foldl (\prs a -> if (dummyPred a) then (a:prs) else prs) [2] [3, 5..]
07:48:26 <dcoutts__> ManateeLazyCat: and you allocate 100 pixbufs in a single main loop iteration
07:49:00 <tommd> dcoutts__: I've sketched what will become a proposal to l@h.o about changing System.Random into a set of classes (Random, RandomGen, Splittable, CryptoRandomGen).  I'd like to split the random package into a module with classes and _maybe_ a module with some "standard" generator that isn't StdGen (not in the backend anyway).  Thoughts?
07:49:02 <dcoutts__> ManateeLazyCat: I think that it's probably safe to free pixbufs from any thread, but perhaps Axel knows better about that.
07:49:22 <jmcarthur> @src filter
07:49:22 <lambdabot> filter _ []     = []
07:49:22 <lambdabot> filter p (x:xs)
07:49:22 <lambdabot>     | p x       = x : filter p xs
07:49:22 <lambdabot>     | otherwise = filter p xs
07:49:52 <dcoutts__> tommd: a proposal for a random replacement is a good idea, I have some suggestions. I presume you saw my reddit comment about crypto rngs vs non-crypto ones
07:49:55 <ManateeLazyCat> dcoutts__: Axel said he has push new patch make GC can free pixbuf as soon as possible instead after main loop.
07:50:05 <tommd> dcoutts__: Yes, I did.
07:50:07 <cinayakoshka> thanks, will try it...
07:50:09 <dcoutts__> ManateeLazyCat: ok, then why are you asking me?
07:50:14 <ManateeLazyCat> dcoutts__: I have test, but looks not fix.
07:50:23 <ManateeLazyCat> dcoutts__: Axel haven't time, but i don't know to do.
07:50:35 <dcoutts__> ManateeLazyCat: and why did you not tell me, why wait for me to work that out myself?
07:50:41 <tommd> dcoutts__: If you could chime in on the l@h.o email I sent this morning then I'll stop double-tasking that thread and make a proposal (perhaps sending that next weekend though)
07:51:14 <ManateeLazyCat> dcoutts__: Sorry, i suppose you have know that issue.
07:51:40 <dcoutts__> ManateeLazyCat: you'll also need to adjust that test to do a performGC once in each loop
07:52:02 <cinayakoshka> well, that doesn't really make sense, lambdabot (is a bot?)
07:52:05 <dcoutts__> ManateeLazyCat: the GC does not know how expensive the ForeignPtrs are, so it will not do a GC immediately
07:53:10 <ManateeLazyCat> dcoutts__: Ok, i try add performGC and test again. Thanks
07:53:17 <jmcarthur> i wish there was a way you could tell the GC how expensive a foreign ptr is so it can behave a bit more nicely
07:53:56 <dcoutts__> tommd: I agree with making rng split a separate class, but letting it fail is useless
07:54:11 <tommd> Hummm, ok.
07:54:22 <dcoutts__> tommd: and splitting crypto rngs doesn't sound that useful (which presumably are the only ones where failure makes sense)
07:54:32 <Feuerbach> why many functions in Data.List are implemented via general recursion instead of using folds? Aren't folds always preferable?
07:54:36 <dcoutts__> tommd: but you'd know more about the crypto side than me
07:54:49 <tommd> dcoutts__: No, I agree.  I just wanted a way to make CryptoRNGs usable when functions request RandomGen RNGs.
07:55:02 <jmcarthur> Feuerbach: haskell 98 spec, probably
07:55:07 <dcoutts__> tommd: the splittable thing is for nice pure lazy algorithms that feed rngs down lazy tree-shaped computations
07:55:14 <dcoutts__> tommd: and failure there is not an option
07:55:31 <tommd> Ah, I never used split so that is interesting to here.
07:55:35 <jmcarthur> oh, Data.List isn't in h98
07:55:38 <jmcarthur> i dunno :)
07:55:51 <tommd> I'll fix it up in the next RC for crypto-api and the proposal will reflex that change.
07:56:06 <tommd> s/reflex/reflect
07:56:09 <ManateeLazyCat> dcoutts__: I have test performGC, looks can't work.
07:56:53 <ManateeLazyCat> dcoutts__: Anyway i can track the counter of Pixbuf and GC runtime states?
07:57:06 <ManateeLazyCat> s/Anyway/Any way
07:57:10 <dcoutts__> tommd: the other thing I'd do is to eliminate getStdGen/setStdGen, they are impossible to implement without unsafePerformIO and are evil global mutable vars.
07:57:35 <hpc> :t getStdGen
07:57:35 <lambdabot> IO StdGen
07:57:51 <dcoutts__> on the other hand, newStdGen is perfectly ok
07:57:56 <hpc> :t setStdGen
07:57:57 <lambdabot> StdGen -> IO ()
07:58:00 <dcoutts__> :t newStdGen
07:58:01 <lambdabot> IO StdGen
07:59:05 <tommd> Is StdGen actually liked?  Most people complain its too slow.
07:59:17 <tommd> Any ideas for what would make a better backend?
07:59:30 <tommd> Perhaps I should take a mwc implementation from someon?
07:59:33 <tommd> *someone
07:59:40 <dcoutts__> tommd: it is slow, it'd be fine to move it to a separate module.
07:59:57 <dcoutts__> tommd: it'd also be ok to add new generator types using different algorithms
08:00:06 <Feuerbach> jmcarthur: well, Haskell98 specifies intended semantics, but it can be achieved in different ways
08:00:12 <i_am_neuron> Hi folks, I'm trying to generate an infinite list of IO actions that are results of accepting connections to server socket. Getting server socket is an IO action itself and should only be performed once. I now stuck at how I can pull the value out of IO monad. Type checker insists on having 'IO a' type and not '[IO a]'. Anybody care to help? http://pastie.org/1139653
08:00:21 <yitz> dcoutts_: I've always been thinking of writing to LeCuyer about StdGen
08:00:29 <Zao> @type sequence
08:00:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:00:37 <dcoutts__> yitz: hmm?
08:00:51 <yitz> dcoutts_: its based on a very old random gen of his, since then he's gone way beyond that
08:01:07 <dcoutts__> yitz: ahh I see
08:01:22 <revenantphx> @quote fugue
08:01:22 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:01:50 <dcoutts__> yitz, tommd: so if you're changing the API then it'd be ok to use a new algorithm for StdGen
08:01:58 <yitz> dcoutts__: the idea was the hope that his work would lead to an implementation of split. with his new stuff, it's likely possible. otoh, people now seem to think that split isn't that important after all.
08:02:18 <dankna> I don't personally think split is very important, I can't think of a single use-case for it
08:02:26 <dankna> it's /interesting/ certainly
08:02:49 <dcoutts__> it is useful for cases where threading a rng linearly would make your algorithm too strict
08:02:53 <yitz> lecuyer's new generators are much better and much faster than the one we are using.
08:02:56 <dankna> hmm
08:02:57 <dankna> maybe
08:03:06 <dcoutts__> e.g. passing a rng down a lazy tree-shaped computation
08:03:14 <dankna> yeah, okay, I see what you mean
08:03:33 <dcoutts__> certainly split should be in its own typeclass that extends randomgen
08:03:42 <dcoutts__> since only some rngs are splittable
08:04:48 <dcoutts__> tommd: I'm not quite sure how to sort out the problem that some rngs have specialised implementations for some types, where currently the system works such that all types are generated from an Int
08:05:08 <dcoutts__> tommd: you've got an approach using MPTC right?
08:05:16 <yitz> dankna: you could do random stuff in parallel much more easily
08:05:20 <ski> i_am_neuron : hm .. are you sure you don't want `echo :: IO [IO Echo]' ?
08:06:09 <tommd> dcoutts__: considered it, not decided on it
08:06:32 <yitz> dankna: more generally, random calculations would not force you to sequence things, so it would lead to more laziness without loss of performance
08:06:36 <dcoutts__> tommd: I would certainly keep the main rng API pure however, even things like mercene can be done purely via the ST monad
08:06:53 <dankna> yiz: hmm.  I'm not clear on that first pint.  you could just keep the random state in an mvar.  the more-laziness argument is basically what dcoutts said and is a much stronger one.
08:06:54 <i_am_neuron> ski: Nope. That's what typechecker has inferred, but that's not my intention
08:06:55 <dankna> *point
08:07:08 <dcoutts__> tommd: the fact mercenne C code is useless because it uses global state, so totally unsafe in concurrent progs
08:07:12 <dcoutts__> fact/fast
08:07:24 <ski> i_am_neuron : well, what is the type of `withSocketsDo' ?
08:07:35 <revenantphx> did someone just mention the mersenne twister?
08:07:52 <dcoutts__> revenantphx: I spelt it wrong but yes :-)
08:08:11 <i_am_neuron> ski: So basically the code there is not compilable. I'm stuck at how to take the server variable from IO monad and use it when generating a sequence with iterate
08:08:15 <revenantphx> since it's all in one function, you could move the global state to static function state btw
08:08:24 <Axman6> dons' mersenne twister random library uses global state
08:08:30 <i_am_neuron> @type withSocketsDo
08:08:31 <lambdabot> Not in scope: `withSocketsDo'
08:08:39 <dcoutts__> Axman6: yes, it's evil :-)
08:08:48 <revenantphx> that it does.
08:08:58 <ski> @index withSocketsDo
08:08:58 <lambdabot> Network.Socket, Network
08:09:01 <Axman6> it's also damn fast
08:09:07 <ski> @type Network.withSocketsDo
08:09:08 <lambdabot> forall a. IO a -> IO a
08:09:10 <revenantphx> Axman6: that it also is.
08:09:14 <i_am_neuron> ski: it's IO a -> IO a
08:09:19 <dcoutts__> revenantphx: it'd have to be a passed-in state record, not global vars
08:09:23 <ski> @type Network.listenOn
08:09:24 <lambdabot> Network.PortID -> IO Network.Socket.Socket
08:09:38 <dcoutts__> revenantphx: then at least it could be wrapped in the ST monad and then used purely
08:09:41 <revenantphx> the global state is an index and a big bugger I believe.
08:09:43 <revenantphx> buffer*
08:09:58 <revenantphx> if this were JUST C, you could make those function static.
08:10:04 <dcoutts__> no, that's not enough
08:10:08 <revenantphx> the problem is ah...
08:10:08 * ski tries to figure out what `withSocketsDo' does .. probably setting up some kind of dynamic context
08:10:11 <revenantphx> mt_init also uses the state
08:10:17 <revenantphx> well, you can always do the ugly thing
08:10:24 <revenantphx> you can wrap the state in special functions
08:10:33 <tommd> ski: Initilizes the winSock interface, evidently needed on Windows.
08:10:34 <i_am_neuron> ski: so I only want to execute an IO action of creating a socket once, and then generate an infinite list of the results of invoking accept on that socket
08:10:51 <tommd> A No-op on *nix.  But you probably already knew all that.
08:10:53 <revenantphx> dcoutts__: perhaps rethink how it works :\
08:11:16 <revenantphx> ski: It's needed by Win machines, on other OS'es its harmless
08:11:30 <dcoutts__> revenantphx: the C code would need to be changed to eliminate global vars and instead to operate on a state passed in as a parameter
08:11:40 <revenantphx> dcoutts__: have fun with that.
08:11:50 <dcoutts__> revenantphx: right, I'm not volunteering :-)
08:11:50 <ski> tommd,revenantphx : and i then assume it tears down that dynamic context at the end ?
08:12:00 <revenantphx> ski: No clue, but i'd suppose so.
08:13:09 <ski> i_am_neuron : probably that is the wrong placement of `withSocketsDo', iiuc .. you should probably hoist it up so that it encloses the whole dynamic extent of the program which uses sockets
08:14:18 <wto> @type sequence
08:14:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:14:30 <DanielDiaz> Hello, does anyone know a package that plays sound files? (on Windows)
08:14:36 <ski> i_am_neuron : in any case. you want to only so a single `listenOn' at the start, here. so you really *need* `echo :: IO (...)' (or you need to do the `listenOn' somewhere else in the program)
08:14:47 <ski> s/only so a/only do a/
08:14:47 <b52> and again i need a little help: http://paste.tryhaskell.org/77/parser__chaper_8
08:15:49 <ski> i_am_neuron : btw, `iterate (next server) (init server)' seems to be identical to `repeat (init server)'
08:16:09 <ski> i_am_neuron : .. and you'll need to wrap that in a `return'
08:16:37 <revenantphx> oh btw dcoutts__: http://hackage.haskell.org/package/mersenne-random-1.0
08:16:40 <dcoutts__> tommd: so would it work to have a single type class with two params (and no fundeps): the rng type and the generated type, e.g. instance Random StdGen Int
08:16:45 <revenantphx> there seems to already be a mersenne based RNG
08:17:09 <ski> (i_am_neuron : the changes i'm suggesting will give you `echo :: IO [IO Echo]', btw)
08:17:17 <revenantphx> it uses file static variables thouhg :P
08:17:25 <dcoutts__> revenantphx: yes, it uses the unsafe C code
08:17:35 <revenantphx> dcoutts__: file static is fine in .c files.
08:17:42 <revenantphx> Since it's restricted to its own compilation unit.
08:17:49 <revenantphx> You can't include a .c file
08:17:56 <ski> i_am_neuron : also, i hope you know that `let e = E "[echo]" h' and then `return e' could be replaced with just `return (E "[echo]" h)'
08:18:10 <tommd> dcoutts__: It could, yes.  I wasn't intending to make CryptoRandomGen quite so general, but a rework of 'random' could do that then I could depricate CryptoRandomGen later.
08:18:10 <tommd> class RandomGen g v where ...
08:18:10 <tommd> instance RandomGen StdGen Int
08:18:10 <tommd> instance RandomGen DRBG (Either GenError B.ByteString)
08:18:46 <ski> i_am_neuron : hm .. pondering "and then generate an infinite list of the results of invoking accept on that socket" now ..
08:18:50 <revenantphx> btw, how are haskell projects usually organized?...
08:18:52 <dcoutts__> revenantphx: it's not ok, you cannot use multiple rngs at the same time
08:19:01 <revenantphx> dcoutts__: oh I see your issue.
08:19:46 <dcoutts__> tommd: oh, maybe. I was assuming you'd still have something different for crypto rngs that dynamically track entropy
08:20:02 <b52> none who can help me?
08:20:26 <i_am_neuron> ski: Yeah, I understand. But I guess that's not what I want (i.e. I still think [IO Echo] is the type I need). Have a look at that: http://pastie.org/1139653. This is not compilable as well (server passed to next is not known to the compiler), but essentially I want to have at that point the same value as returned in 'server <- ioserver'
08:21:04 <tommd> dcoutts__: Yeah, I ws just going to say that the problem with unifying the two really comes up in the reseed, WithEntropy and newGen functions.
08:21:13 <ski> b52 : oh ..
08:21:38 <dcoutts__> tommd: btw, will you be at ICFP?
08:21:48 <ski> b52 : if you want to use `do'-notation, then you should make an instance of `Monad', instead of defining your own stand-alone `return',`(>>=)' operations
08:22:08 <ski> b52 : if you don't want to do that, then don't use `do'-notation
08:22:10 <tommd> dcoutts__: Sadly no - I couldn't justify flying out there on my academic budget (again) without a paper to present. 
08:22:14 <b52> well it is described that way in the book
08:22:16 <dcoutts__> tommd: or the Ghent hackathon?
08:22:31 <tommd> dcoutts__: Again, no.  If you ever visit Galois again though I could stop by.
08:22:34 <ski> (or use `NoImplicitPrelude' or something like that, maybe)
08:22:51 <b52> sorry?
08:23:23 <tommd> Otherwise it would probably be next years ICFP that we actually could meet at.
08:23:28 <ski> i_am_neuron : that's the same paste you linked to before
08:23:55 <dcoutts__> tommd: so I'm interested in helping sort out the design of the random class (though I'm not a crypto expert) but I'm rather snowed under until ICFP
08:24:04 <ski> b52 : hm, which book is that ?
08:24:16 <i_am_neuron> ski: I've updated that
08:24:20 <tommd> dcoutts__: I'll make sure the discussion period goes 1 week past the end of ICFP.  Would that work for you?
08:24:22 <b52> programming in haskell from graham hutton, chapter 8
08:24:45 <b52> and actually i put everything in a file and load it into hugs to test it
08:24:53 <dcoutts__> tommd: so are you proposing just a crypto change or changing the main System.Random ?
08:24:56 <tommd> Heck, I could just make patches and not propose until after ICFP - might be smarter anyway.
08:24:57 <ski> i_am_neuron : oh .. it didn't occur to me that paste site might allow such a thing
08:25:26 <BONUS> b52: yeah afaik that book does a few shortcuts regarding monads and parsers
08:25:32 <tommd> dcoutts__: I will release crypto-api with the CryptoRandomGen in under a week.  I will propose a major change to 'random' and thus System.Random in a later proposal.
08:25:37 <i_am_neuron> ski: so now the core of the expression is 'iterate ...' and that's essentially what I need
08:25:39 <dcoutts__> tommd: ok
08:25:41 <BONUS> you have to make a type and then make it an instance of Monad
08:25:50 <b52> how do i do that?
08:26:00 <b52> im new to haskell and the book hasnt introduced monads so far :/
08:26:17 <ski> i_am_neuron : if you want to do a single `listenOn' for the whole list, then you need to do `IO', and so you *need* `echo :: IO [...]'
08:26:20 <revenantphx> BONUS: just wanted to thank you for writing LYAH, it's been useful ^_^.
08:26:28 <revenantphx> I won't barrage you with questions, just wanted to say thanks.
08:26:35 <tommd> b52: I advise you read it from the book then come back here with questions - not go the other way around.
08:26:45 <b52> o#o
08:26:48 <ski> i_am_neuron : of course, if you do that `listenOn' somewhere else, you can just pass the `Socket' in, and have `echo :: Socket -> [...]', instead
08:26:56 <b52> so your advice is to skip all chapters until i come to monads? oO
08:27:00 <tommd> b52: Or read it from the online RWH pages.
08:27:06 <b52> not very useful
08:27:34 <revenantphx> b52: I found the chapters of lyah on functors, applicatives and monads to be good.
08:27:36 <revenantphx> you could go read those
08:27:37 <ski> b52 : to make `Parser' an instance of `Monad', you need two things
08:27:45 <BONUS> revenantphx: very glad you found it useful! :)
08:28:00 <ski> b52 : (a) define `Parser' using `newtype' or `data', instead of `type'
08:28:01 <revenantphx> BONUS: the pierre/birds example was a very easy one for me to grasp
08:28:01 <i_am_neuron> ski: But once I got [IO Echo] from echo in that 'somewhere else' I still must wrap it in IO, right? Because it creeps from listenOn invocation
08:28:02 <b52> revenantphx: lyah?
08:28:13 <revenantphx> b52: this and the following chapter
08:28:14 <revenantphx> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
08:28:17 <tommd> Damn it, revenantphx, we have a hard enough time keeping BONUS from having an over-sized ego.
08:28:20 <BONUS> revenantphx: that's awesome, i was wondering if people were going to get that
08:28:22 <revenantphx> tommd: haha.
08:28:31 <BONUS> muhahaha! *explodes*
08:28:43 <ski> b52 : (b) write the actual `instance' declaration for `Monad Parser', and put the definitions of `return' and `(>>=)' (sadly without type signatures), inside that
08:29:05 <ski>   instance Monad Parser
08:29:06 <ski>     where
08:29:13 <ski>   --return :: a -> Parser a
08:29:17 <ski>     return v = ...
08:29:24 <ski>   --(>>=) :: Parser a -> (a -> Parser b) -> Parser b
08:29:30 <ski>     p >>= f = ...
08:29:52 <ski> (and remove the `import Prelude hiding (return)', if you're doing that)
08:29:52 <revenantphx> whats the --
08:29:57 <ski> comment out
08:30:02 <b52> lul
08:30:08 <ski> you could remove the type signatures completely, if you want
08:30:14 <b52> you do understand monads but dont know what a -- means ...
08:30:22 <revenantphx> b52: pretty much
08:30:25 <ski> imo, type signatures should be allowed in that context, but sadly that's not the case
08:30:25 <revenantphx> :D
08:30:38 <revenantphx> Haven't seen those before.
08:30:45 <b52> so it would be easier to go with the newtype thing?
08:30:52 <revenantphx> oh, comments
08:30:53 <revenantphx> lol > <
08:30:57 <BONUS> yeah one big thing i forgot to cover in LYAH are comments
08:31:08 <BONUS> how the hell did i miss those, i'll have to mention them somewhere
08:31:10 <revenantphx> BONUS: Oh, I found them on my own, I just didn't think about those.
08:31:20 <BONUS> ah ok, but yeah, that reminded me
08:31:23 <revenantphx> ski's code made it look like thye were something significant
08:31:24 <ski> b52 : *if* you want to make an instance of `Monad' (e.g. to be able to use `do'-notation), *then* you *need* to use `newtype' or `data', rather than `type', to define `Parser'
08:31:28 <i_am_neuron> ski: It might be that I think something wrong (I'm a newbie), but here's my train of thought. Getting first element in this infinite list could be accomplished with function of type 'IO Echo' (it does listenOn inside). Getting the rest of the element could be accomplished with the function of type 'Socket -> IO Echo'. Why can't I take those 'IO Echo's and stitch them together in a list? I...
08:31:30 <i_am_neuron> ...just need to pass socket wisely, and this is what I can't do currently
08:31:35 <revenantphx> BONUS: write a whole chapter about comments
08:31:39 <BONUS> lol
08:31:41 <revenantphx> BONUS: all the fun ascii styles.
08:31:50 <Zao> Literate Haskell?
08:31:52 <revenantphx> and which ones piss of specific groups of people most effectively.
08:31:58 <Twey> Hehe.
08:32:00 <Zao> Some Haddock maybe?
08:32:07 <BONUS> hmm maybe
08:32:28 <revenantphx> also
08:32:33 <revenantphx> may I suggest lmhtfy.com?
08:32:39 <revenantphx> (Let me Hoogle that for you.com)
08:32:45 <b52> lol
08:32:48 <revenantphx> (a clone of letmegooglethatforyou)
08:33:03 <ski> i_am_neuron : btw, that's something i was unsure of .. do you *really* want a list of `IO'-*actions*, each yielding an `Echo', when executed .. or do you actually want a (lazy) list of `Echo' values ?
08:33:39 <b52> ski: if i replace type with newtype it doesnt work either
08:33:54 <yitz> i_am_neuron: an IO Echo is an action which, when executed, produces an Echo. you don't want to stitch them together - you just want to execute the same one repeatedly.
08:34:22 <ski> b52 : right, the syntax of `newtype' and `data' isn't exactly like `type' (if it were, then probably only one of those would be needed)
08:35:20 <revenantphx> BONUS: why does this pig look like a minecraft pig?
08:35:21 <revenantphx> http://s3.amazonaws.com/lyah/smugpig.png
08:35:25 <yitz> i_am_neuron: more correctly, you want to create an action which, when executed, executes that same IO Echo repeatedly
08:35:25 <ski> b52 : so, instead of `type Parser a = String -> [(a, String)]' say e.g. `newtype Parser a = MakeParser (String -> [(a,String)])' (or, if you really want to, replacing `newtype' with `data' .. but `newtype' is more natural here, i think)
08:36:22 <ski> b52 : note that doing this, `Parser a' is now no longer the *same* type as `String -> [(a,String)]'  (it's not a type synonym anymore)
08:36:45 <b52> jeez ..
08:36:57 <ski> b52 : `Parser a' is now a *new* type, distinct from every pre-existing one (which is what allows you to make a type-class instance)
08:37:00 <i_am_neuron> ski, yitz: I think it's clearer now. Probably lazy list is what I really need
08:37:12 <BONUS> revenantphx: because i saw a minecraft screenshot i think and had it in my mind
08:37:18 <revenantphx> BONUS: haha
08:37:27 <revenantphx> I knew it :P
08:37:27 <i_am_neuron> ski, yitz: Thanks, I guess I can figure the rest out :)
08:37:28 <sm> morning all
08:37:35 <performance> monring sm
08:37:35 <ski> b52 : so, now `MakeParser' is now a function (the term is "(data) constructor") that converts a value of type `String -> [(a,String)]' into a value of type `Parser a'
08:37:39 <b52> what are lhs files?
08:38:06 <ski> b52 : so, e.g. instead of `return v = \inp -> [(v, inp)]' you would now say `return v = MakeParser (\inp -> [(v, inp)])'
08:38:23 <ski> "lhs" is "literate haskell script" (iirc)
08:38:25 <b52> that would make me to change all defined functions
08:38:31 <revenantphx> BONUS: one fundamental question. Is there really any different between a "constant variable" and a function which returns a value and takes nothing?
08:38:45 <revenantphx> Haskell doesn't really seem to distinguish between primtiives and functions, if that makes sense.
08:38:56 <ski> b52 : only the primitive ones that depend on the implementation of `Parser a' .. not the derived operations
08:39:04 <qz> what is readM function? it is mentioned in http://www.scribd.com/doc/36045849/Practical-Haskell-Programming-scripting-with-types (slide 19) but Hoogle knows nothing about it
08:39:09 <BONUS> you mean a function like () -> Int as opposed to a value of Int
08:39:23 <revenantphx> oh okay so they are ()
08:39:31 <revenantphx> you can't define a function then as just being like
08:39:36 <BONUS> :t const "yes"
08:39:37 <lambdabot> forall b. b -> [Char]
08:39:40 <ski> revenantphx : every function always takes exactly one argument, strictly speaking
08:39:41 <BONUS> :t "yes"
08:39:42 <lambdabot> [Char]
08:39:43 <revenantphx> myFunc :: (Num t) => t
08:39:51 <BONUS> revenantphx: ah you mean like that
08:40:00 <revenantphx> versus 
08:40:01 <revenantphx> :t 10
08:40:02 <lambdabot> forall t. (Num t) => t
08:40:08 <revenantphx> not much different there.
08:40:10 <BONUS> no there's no difference really imo
08:40:17 <revenantphx> yeah, thats what I was seeing.
08:40:32 <BONUS> it amounts to the same thing
08:40:51 <ski> b52 : btw, to go in the other direction, from `Parser a' to `String -> [(a,String)]', you could pattern-match a value of the former type with a pattern like `MakeParser p'
08:40:59 <revenantphx> this is my first foray into functional programming :\. I just started 4 or 5 days ago.
08:41:11 <revenantphx> A bit confused by some stuff, but it's been fun so far ^_^
08:41:26 <ski> b52 : like `MakeParser p +++ MakeParser q = MakeParser (\inp -> ..p..q..)'
08:41:48 <b52> dude sorry interrupt you but nearly everything you wrote confuses me a little bit more
08:42:05 <ski> ok, sorry about that
08:42:19 <ski> what's the first thing that confused you ?
08:43:07 <revenantphx> Oh, one other question I had, is it possible to export symbols from compiled haskell to C programs > >?
08:43:09 <b52> i just want the code from the book to work that i can test it myself and do the exercises
08:43:23 <revenantphx> As in, write shared objects or dylibs in Haskell, for use with c?
08:43:41 <b52> i do understand what the code does, but i cant say why it isnt workin or what i gotta do to make it work
08:44:03 <b52> since things like monads, newtypes or data havent been introduced so far
08:44:10 <BONUS> yeah it's possible to interface haskell with c. real world haskell has more info about that
08:44:22 <revenantphx> BONUS: recommendation: add a section with some exercises to lyah
08:44:38 <b52> exercises are always a good thing
08:44:54 <revenantphx> yeah.
08:44:55 <ski> qz : maybe something similar to `readM :: MonadPlus m => ReadS a -> String -> m a; readM reads s = do (a,"") <- foldr (mplus . return) mzero (reads s); return a' ?
08:44:58 <revenantphx> helps reinforce ideas.
08:44:58 <BONUS> yeah, maybe. it's hard to come up with them though :)
08:45:04 <revenantphx> BONUS: thats ture
08:46:53 <b52> ski: http://paste.tryhaskell.org/78/parser__chaper_8
08:47:06 <b52> though i really appreciate your help, i didnt mean to insult you
08:47:39 <ski> oh .. you didn't do that
08:47:58 <ski> (it's just i haven't read that book, so i don't really know how the author does things there)
08:48:02 <ski> <BONUS> b52: yeah afaik that book does a few shortcuts regarding monads and parsers
08:48:32 <ski> suggests it possibly doesn't give code that can be used as-in (i don't know)
08:48:46 <cydergoth> Yo - got a cabal package which builds doc with haddock, but it doesn't when uploaded to hackage?
08:48:51 <BONUS> yeah that's basically it. if you want to use that code as is you have to import Prelude hiding return and >>=
08:48:52 <cydergoth> Anyone know what I'm missing?
08:49:10 <BONUS> and stuff like that. much easier to do this with the newtype
08:49:16 <BONUS> b52: just a second, i'll show you how to do this
08:49:23 <revenantphx> BONUS: one example, is it'd be nice if the monad section covered making your own monads thoroughly
08:49:28 <b52> BONUS: that would be awesome
08:49:37 <revenantphx> though there seems to be a "coming soon" section that might cover that.
08:49:39 <BONUS> revenantphx: that's coming up in the next section, for a few monads more :)
08:49:42 <BONUS> yeah
08:49:49 <revenantphx> awesome
08:50:10 <Saizan> cydergoth: sometimes it's just that the deps didn't get installed on hackage, see the log
08:50:14 <ski> b52 : anyway, the error you get there is because you need to do `parse (MakeParser p) inp = ...' instead of `parse p inp = ...', since you're actually going to use `p' as a function in `...', there
08:50:18 <b52> btw here is a nice page with videos and slide to every chapter http://www.cs.nott.ac.uk/~gmh/book.html
08:50:35 <cydergoth> Saizan - ok, I'll take a look
08:50:45 <ski> b52 : also, you need to add `MakeParser' to `(+++)' and `(>>=)'
08:51:53 <Philippa> revenantphx: haskell makes a plenty clear distinction - if it doesn't have a -> at the 'top' of the type, it's not a function
08:51:58 <ski> b52 : i was about to say before that you can easily define a function `runParser :: Parser a -> (String -> [(a,String)]); runParser (MakeParser p) = p' .. except then i noted that's really your `parse' function (fixed to work with `newtype Parser a = MakeParser (...)')
08:52:12 <revenantphx> Philippa: that's a bit late...
08:52:17 <revenantphx> And I didn't mean explicitly
08:52:20 <revenantphx> I meant conceptually.
08:52:33 <Philippa> conceptually, if it doesn't have a ->, it ain't a function, it's just a term
08:52:34 <revenantphx> A function that always returns a constant is conceptually the same as a constant itself.
08:52:50 <revenantphx> They do the same thing in any given situation.
08:52:50 <Philippa> and no, it isn't quite. It's closely related, but not identical
08:52:57 <revenantphx> well, any IVE seen
08:53:18 <Philippa> the function has to take a parameter, so it behaves differently in that regard
08:53:29 <b52> ski: could you show me how to fix (+++) and (>>=) as well?
08:54:03 <ski> (revenantphx : a pair of an integer and a string is closely related to a pair of a string and an integer, but is not identical .. this is sortof the same kind of distinction)
08:54:09 <Philippa> there's also the case where the parameter type's only value is undefined, which makes the function a little bit odd if you're treating the language as a logic
08:54:21 <revenantphx> right
08:54:51 <ski> b52 : well, just as for `return', since you're returning a value of type `Parser ...', you can't actually return `\inp -> ...' but you have to return `MakeParser (\inp -> ...)'
08:54:59 <Philippa> (undefined makes haskell-the-logic let you prove anything, so if you're trying to reason using haskell you generally do it without undefined)
08:55:19 <monochrom> sigh. sloppy mathematicians have really polluted people's mind.
08:55:47 <ski> b52 : secondly, in those cases when you were previously taking a parser input, which you were applying to a string, you now need to match that parser input against a pattern like `MakeParser p', and then apply *`p'* to the string
08:56:08 <Philippa> yeah. It's not that I'm not happy to carry out gross abuse of notation via isomorphism. It's just that... well, you have to have a certain taste in doing it
08:56:17 <Philippa> (see: no, haskell really doesn't have 0 parameter functions)
08:56:40 <revenantphx> Philippa: yeah I understand.
08:57:04 <BONUS> b52: http://paste.tryhaskell.org/paste/78/asflhka#p79
08:57:10 <ski> b52 : however, in some cases (specifically thinking of `(>>=)', here), instead of matching against `MakeParser p', it can be easier to just use a function of type `Parser a -> (String -> [(a,String)])' (which is your `parse' function) to apply the parser "directly" to a string
08:57:16 <Philippa> the big rule there is not to 'corrupt' the original notion too much. 2-parm functions? Fine. 0-parm? No, it's something else
08:57:26 <monochrom> another crime of sloppy mathematician: a function is "conceptually" the same as its body.
08:57:29 <Philippa> anyway, sorry if I've gone off on one a bit much
08:57:48 <monochrom> for example (\x -> x*x) is "conceptually the same as" x*x
08:57:56 <Philippa> monochrom: I think that's partly a historical accident from prior to the set-theoretic notion of function, too
08:58:03 <Twey> Philippa: Hmm… not sure I agree with including 2-params in that
08:58:12 <Philippa> it is /if/ you take x to be free in the latter
08:58:24 <Twey> Well, I guess you can think of it as one-argument pair-taking functions
08:58:27 <cydergoth> Saizan - yes, it is missing a native library 
08:58:46 <Philippa> Twey: yeah, but the only candidates are tuple functions and currying, essentially
08:58:47 <cydergoth> Saizan - should I contact the Hackage DB maintainer to see if he/she can add it?
08:58:58 <ski> b52 : hm, would you like me to annotate the paste with what i was suggesting, so you can compare that with BONUS's version ?
08:59:12 <Philippa> and it doesn't violate half as many things about what it is to be a function as the idea of 0-parm functions does
08:59:24 <b52> ski: that would be gently, thank you
08:59:28 <Twey> Philippa: *nod*
08:59:42 <ski> monochrom : yes, that irks me greatly ..
08:59:48 <JuanDaugherty> was "haskell-the-logic" a neologism of this convo?
08:59:57 <Philippa> (and at the same time it's really clear that people /do/ think in terms of multi-parm functions and we don't actually get huge breakage in doing so as long as we're aware that the isomorphism holds and we can thus do (by isomorphism) partial application and so forth)
09:00:09 <Philippa> JuanDaugherty: perhaps lexically, but the concept isn't
09:00:46 <Philippa> monochrom: Coq actually encourages that sort of thing incidentally, by allowing you to automatically generalise on free variables
09:01:28 <Philippa> JuanDaugherty: are you familiar with the Curry-Howard isomorphism, or is the concept of haskell-the-logic a WTF for you?
09:02:09 <Philippa> (actually, even haskell encourages it: what's our default notation for rank-1 polymorphism?)
09:02:41 <ski> b52 : .. oh, actually, i didn't realize you used `parse' in most of the definitions, there .. ok, i'll show a variant not using `parse' that much, for contrast
09:03:03 <JuanDaugherty> i am reviewing http://en.wikipedia.org/wiki/Curry–Howard_correspondence b4 commenting
09:03:22 <monochrom> You use Coq explicit scoping constructs when you do that, so it still visibily defines a lambda-thing rather than a free thing. Whereas mathematics textbooks don't even do that.
09:05:06 <JuanDaugherty> the response is: what specifically does this imply about the implementation current of Haskell?
09:06:04 <Philippa> JuanDaugherty: nothing much about implementations specifically. You can identify fragments of haskell that're sane to write proofs in though, and in at least some cases you can termination-check them if the fragment isn't inherently terminating though
09:07:16 <JuanDaugherty> so it does appear that "haskell-the-logic" is in fact a neologism with indistinct referent
09:08:05 <Philippa> well no, it's haskell, viewed as a logic
09:08:26 <Philippa> that's perfectly distinct, it's just that in practice you don't want to use all of it
09:08:41 <JuanDaugherty> precisely. Where the oppositie of such a relation would like that between FOL and prolog
09:09:06 <Philippa> no
09:09:24 <JuanDaugherty> i.e. the precisely was in accord with "well ..."
09:09:25 <Philippa> more like FOL sans negation and the simply-typed lambda calculus
09:09:32 <JuanDaugherty> not commenting on the remainder
09:10:01 <revenantphx> okay, this is annoying
09:10:16 <revenantphx> the implementation of "ackermann's function" in SICP, is not ackermann's function at all.
09:10:25 <copumpkin> oh?
09:10:34 <revenantphx> its completely different from what I find when I look it up
09:10:35 <Twey> Isn't it?
09:10:42 <copumpkin> revenantphx: there's a higher-order form of it
09:10:44 <Twey> http://en.wikipedia.org/wiki/Ackermann's_function — IIRC, it's precisely the one given here
09:10:48 <copumpkin> that's a lot more elegant than the usual definition
09:10:50 <revenantphx> nope Twey
09:10:59 * Twey hunts down SICP
09:11:00 <revenantphx> I implemented that one in haskell and it matches the table provided below
09:11:05 <copumpkin> revenantphx: did you make sure it isn't the higher-order form?
09:11:10 <revenantphx> SICP's scheme one produces very diff ones
09:11:16 <revenantphx> copumpkin: its in the form A m n
09:11:16 <JuanDaugherty> *opposite. (I'm not dutch)
09:11:26 <revenantphx> so idk
09:11:34 <revenantphx> but it uses multiplication by 2, which is nowhere to be found here
09:11:54 <Philippa> JuanDaugherty: it's a very different relationship from the one between Prolog and FOL, anyway
09:12:07 <revenantphx> for an m value of 1 it produces the numbers 2^n
09:13:01 <Philippa> ignore haskell itself for a moment, and just consider the simply-typed lambda calculus (or if you want something with power more like Haskell's, System Fc)
09:13:20 <revenantphx> http://paste.tryhaskell.org/80/ackermann
09:13:33 <Philippa> prolog isn't a logic, it's a language for programming in logic. The simply-typed lambda calculus is (up to isomorphism, at least) a logic
09:13:53 <revenantphx> copumpkin: see any thing?
09:13:57 <revenantphx> this is confusing me a bit
09:14:34 <revenantphx> when I look it up I see things like "Although the definition SICP gives for Ackermann’s function seems non-standard, it’s the same general idea anyway."
09:15:22 <ski> b52 : <http://paste.tryhaskell.org/81/_mostly__matching_on__makeparser___instead_of_calling__parse__as_much___and_some_more_things_>
09:16:21 * chrisdone considers putting a limit on url titles..
09:16:25 <Twey> revenantphx: Oh, yeah, they don't quite match.  Do they give the same output?
09:16:32 <revenantphx> Twey: not at ALL
09:16:56 <revenantphx> as I said, (A 1 n) gives the series 2^n
09:17:12 <revenantphx> the correct haskell one for A 1 n gives n + 2
09:17:19 <revenantphx> 2^n and n+2 are very different series.
09:17:30 <Twey> chrisdone: Also good would be slugifying properly (lowercase, s/\W+/-/)
09:17:41 <Twey> chrisdone: What are the numbers for?
09:17:50 <Twey> Oh
09:17:57 <chrisdone> Twey: the paste id. the title's just for prettiness
09:17:58 <Twey> Scratch that — what are the titles in the URLs for?
09:18:03 <BONUS> chrisdone: have you considered making author fields optional?
09:18:04 <Twey> It's not very pretty
09:18:10 <chrisdone> that one isn't
09:18:12 <Twey> I'd prefer using the title as the ID
09:18:17 <chrisdone> http://paste.tryhaskell.org/80/ackermann is pretty
09:18:19 <BONUS> also it would be cool if titles were optional for annotations
09:18:24 <Twey> Yeah
09:18:36 <chrisdone> BONUS: ok
09:18:41 <Twey> chrisdone: Yeah, but you ask them to input a title, not a pre-formed slug
09:18:49 <Twey> That one's only pretty because it happens to be a slug already :þ
09:19:05 <ski> ("slug" ?)
09:19:17 <revenantphx> Did you really just use a thorn in an emoticon?
09:19:40 <Twey> ski: http://docs.djangoproject.com/en/dev/ref/models/fields/#slugfield
09:19:42 <revenantphx> chrisdone: ty
09:19:46 <Twey> revenantphx: I often use thorns in emoticons.
09:22:32 <ski> (Twey : ok)
09:23:22 * ski is used to lisppaste's referring to pastes and annotations by numbers
09:24:11 <Twey> Numbers is okay, slugs would be better, but huge, improperly-slugged titles is worse :þ
09:24:53 <BONUS> idea: if you dont put in a title, it just gets a number as the url
09:25:04 <chrisdone> no I want titles to be required
09:25:11 <BONUS> ah, cool
09:25:49 <Twey> You'll need numbers for disambiguation, should that arise, I guess
09:26:12 <ezyang> Ooh, hackage is using the new skins. 
09:26:20 <BONUS> really? cool
09:26:41 <djahandarie> Hackage is?
09:26:47 <Zao> Looks quite the same to me.
09:27:06 <djahandarie> I'm not entirely sure what you're talking about ezyang :P
09:27:09 <Twey> I saw someone post a skinned screenshot of Hackage the other day, but I haven't seen it yet.
09:27:11 <BONUS> looks same to me as well
09:27:16 <BONUS> :[
09:27:18 <ezyang> Huh, cursious. 
09:27:19 <djahandarie> Twey, yeah, I made that one
09:27:23 <Twey> Also, my Internet is irritating
09:27:29 <ezyang> Try Ctrl-F5? 
09:27:39 <Twey> Hence the irritating Internet comment
09:27:43 <BONUS> example: http://hackage.haskell.org/packages/archive/llvm/0.8.0.2/doc/html/LLVM-Core.html
09:27:47 <BONUS> shows up with the old style
09:27:53 <ezyang> Oh, that is old style. 
09:27:56 <djahandarie> Oh you mean the haddock styles?
09:27:59 <ezyang> Here's a new style one: http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html 
09:28:14 <Twey> I can't even access Hackage right now.
09:28:21 <dankna> clearly it has to do with when the docs were rebuilt
09:28:21 <Twey> *sigh*
09:28:24 <BONUS> nice. strange how some are in the old style and some new
09:28:36 <Twey> djahandarie: What was the one you screenshotted?
09:28:42 <BONUS> this'll take some getting used to but it is much prettier
09:28:47 <Twey> BONUS: Haddock applies styles when it's built
09:28:54 <djahandarie> Twey, it was just done in photoshop, I'm coding it right now
09:29:02 <Twey> BONUS: So I guess only ones that have been rebuilt since the change get the new style
09:29:05 <Twey> djahandarie: Oh, okay
09:29:06 <ezyang> Let's say I need to write a bitfield that is [ 1 bit | 15 bits | 16 bits ] etc. What library gives me good primitives for doing this? 
09:29:15 <BONUS> Twey: i see
09:29:16 <ezyang> binary/cereal seem to be very Haskell value oriented. 
09:29:30 <Twey> Binary.Get is good, isn't it?
09:29:40 <Twey> Or Put, for the writing
09:29:43 <ski> (like "<lisppaste> chandler pasted \"syntax-parameterize\" at http://paste.lisp.org/display/89074", e.g.)
09:30:20 <ezyang> Twey: I still have to slice the 32-bit words I get afterwards. 
09:30:25 <Twey> Hm.
09:30:45 <ezyang> I want to be able to say something like bit 1 <> bit 15 <> bit 16 
09:32:13 <Twey> Ugh.
09:32:22 <Twey> ezyang: I'd have a look for you if my Internet were working.  Sorry.
09:32:32 <ezyang> BitSyntax might be what I'm looking for. 
09:33:39 <ezyang> It's not a very pretty interface though :-/ 
09:34:58 <spuz> Hello, I'm struggling to find the correct place for documentation of haskell's basic functions. Is there a big list somewhere I can lookup?
09:35:23 <ezyang> spuz: You're looking for "Prelude" 
09:36:16 <Philonous> spuz: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html
09:36:22 <spuz> thanks
09:36:26 <Philonous> And for the other standard libraries: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
09:37:07 <BONUS> is there a way to generate single docs from several packages
09:37:29 <BONUS> so for instance if you could get that + mtl documentation on one page
09:37:32 <chrisdone> ski: http://paste.tryhaskell.org/81/mostly_matching_on_makepars
09:37:36 <chrisdone> ski: better?
09:38:13 <ski> better than what ?
09:38:16 <djahandarie> BONUS, for like, the Haskell Platform?
09:38:26 <chrisdone> w/e
09:38:33 <djahandarie> lol
09:38:36 <BONUS> for select packages
09:38:37 <djahandarie> I think it's nicer chrisdone 
09:39:47 <b52> ski: sorry, was away, ill try it now
09:39:48 <lambdabot> b52: You have 1 new message. '/msg lambdabot @messages' to read it.
09:39:56 <b52> hmm
09:40:18 <b52> neat
09:40:25 <ski> (chrisdone : note that i didn't explicitly complain about the earlier URI (though i didn't anticipate it would try to include the topic in the URI, making a bit ugly that way) .. hm, maybe it would be nice to be able to have field for a "SLUG" (defaulting to what you did just above) ?)
09:40:32 <b52> but you could have messages me directly instead ,)
09:41:08 <chrisdone> normalised titles in the url works fine for reddit
09:41:42 <ski> b52 : well, for all i knew, possibly your time was up for today, and you would revisit it later another day (and for some reason i was thinking you were using a web-chat)
09:42:40 <b52> no, i run weechat in a screen session on my server, ill be here 24/7/365 ,)
09:42:41 <b52> ERROR "ski.hs":11 - Syntax error in input (unexpected backslash (lambda))
09:45:25 <ski> b52 : err, sorry. i thought i inserted the `$' there (and also in `MakeParser \inp -> ...' in `(+++)')
09:46:13 <ski> (i suppose i should have proof-loaded the code before pasting :)
09:46:27 <b52> ERROR "ski.hs":30 - Undefined class "MonadPlus"
09:46:33 <b52> you should have done so :D
09:47:24 <ski> hehe, `MonadPlus' is in `Control.Monad' .. i was (unconciously) assuming you were already importing that
09:47:56 <ski> anyway, i just added `MonadPlus' because that looked like what `failure' and `(+++)' was aiming for
09:49:42 <b52> ski: ahh, works great :)
09:49:49 <b52> thanks a lot dude
09:50:56 <ski> .. which brings me to that i think it's strange to not handle lists with more than one element in `(>>=)' and `(+++)'
09:51:34 <b52> thats by design of the parser
09:51:39 <ski> b52 : i.e., why not use `String -> Maybe (a,String)' instead of `String -> [(a,String)]', if you are never going to have lists with more than one element in there ?
09:51:54 <b52> an empty list means failure where as a singleton list means success
09:52:12 <ski> imo, it is misleading to use lists and not `Maybe', if you're not going to allow multiple solutions in the lists, there
09:52:15 <b52> ski: thats a design decision made by graham
09:52:29 <Twey> Agreed — lists are to allow ambiguous parses
09:52:47 <BONUS> yeah idk why graham didnt use Maybe in there
09:52:56 <ski> yeah .. and i'm critizising his choice to use *lists*, to express "either no result, or a single result" :)
09:53:37 <b52> well he stated that there might be more results
09:53:40 <b52> but it actually never happen
09:53:48 <chrisdone> Twey: http://paste.tryhaskell.org/82/ackermanns_function#p83 :p
09:54:21 <ski> b52 : yeah, but if there could actually be more than one element, then i think the implementation of `(>>=)' (and arguably of `(+++)' as well) is wrong
09:55:58 <ski> b52 : i mean, just because none of the primitives *given* introduce lists with more than one element, that doesn't imply that one couldn't (usefully) introduce another primitive operation (on the same "conceptual level" as e.g. `item'), that could possibly give multiple solutions .. and in such case, i think `(>>=)' is wrong (probably it fails a monad law)
09:56:21 <b52> i dont know
09:56:35 <ski> .. indeed, in such case, `forall ma. ma >>= return  =  ma' fails
09:56:48 <Philonous> Do I have to compile with -threaded when an external (threaded) library calls back into haskell?
09:57:30 <monochrom> don't use the ackerman function!
09:57:41 <ski> b52 : so .. i'd either change the lists there to `Maybe' (easy solution), or keep the lists, by try to change `(>>=)' (and probably `(+++)' as well), to sensibly handle multiple solutions
09:57:51 <b52> youre probably right but thats not bothering me right now, i just wanna do the exercises and continue reading the book
09:58:04 <BONUS> save that as an exercise for later :)
09:58:13 <b52> maybe if i got a deeper understanding of haskell i rethink that
09:58:20 <b52> i will
09:58:29 * hackagebot msgpack 0.3.0 - A Haskell binding to MessagePack  http://hackage.haskell.org/package/msgpack-0.3.0 (HideyukiTanaka)
09:58:38 <monochrom> "exercise 5.3: optimize the ackerman function so it takes at most linear time"
09:58:53 <b52> but for now im done, ill get some food, a beer and a nice evening
09:59:05 <b52> thanks for all your help, a good evening to you as well
09:59:06 <ski> b52 : of course, if you're just learning basics now, that might not be a top priority :) .. just mentioning the above as what one would need to consider, if one wants to "think this through"
09:59:08 <b52> see you later
09:59:20 <ski> b52 : ok. byw
09:59:22 <ski> bye
10:01:30 * hackagebot bindings-gts 0.0.2 - Low level bindings supporting GTS, the GNU Triangulated Surface Library  http://hackage.haskell.org/package/bindings-gts-0.0.2 (JoelCrisp)
10:08:35 <ezyang> I’m writing an implementation of SPDY in Haskell. 
10:08:52 <ezyang> I’m wondering how fancy I want to make it. Lazy IO or iteratees?  
10:09:12 <ezyang> I wonder how well binary/cereal play with iteratees. 
10:11:17 <notabel> ezyang: sounds like an interesting project.  i don't know enough to help, but good luck :-)
10:13:17 <notabel> also, wow, they weren't kidding about the new Haddock theme.  crazy
10:15:39 <Eelis> @type listArray
10:15:40 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
10:15:49 <Eelis> why the upper bound argument?
10:16:21 <Eelis> why not just use  lower + length values - 1 ?
10:17:06 <Eelis> now i gotta write    listArray (0, length l - 1) l   instead of just   listArray 0 l  , which feels silly
10:17:24 <notabel> ezyang: actually, as i recall, the attoparsec-iteratee package is aimed at a use case just like this: iteratee-based parsing of network/binary protocols
10:17:27 <copumpkin> Eelis: it would need to traverse the list twice
10:17:37 <copumpkin> Eelis: and in some cases, you already know it
10:17:39 <ezyang> notabel: Ah, good to hear. 
10:17:42 <ezyang> I'll look at that. 
10:17:45 <Eelis> copumpkin: hm, fair enough
10:17:47 <copumpkin> so you can save the effort
10:18:12 <ezyang> haha, it's just a single function. 
10:18:29 <revenantphx> so what exactly does forall mean?
10:18:38 <revenantphx> that a function applies for all types a and b
10:22:02 <ski> revenantphx : .. oh, you left
10:22:10 <notabel> ezyang: yeah, attoparsec does all the work
10:22:34 <notabel> attoparsec-iteratee wraps an attoparsec parser into an interatee in an efficient way
10:23:03 <notabel> sorry if i was unclear :-)
10:25:50 <ezyang> attoparsec is kind of cool. 
10:27:26 <sm> with ghc 6.12 and LANG=en_US.UTF-8, putStr "\1076" displays д as expected. But error "\1076" displays 4. How come ?
10:31:51 <ezyang> Hm. I'm kind of torn whether or [a, b, c] <- bits [1, 15, 16] or a <- bit 1; b <- bit 15; c <- bit 16 is a better idea. 
10:33:07 <Claudius1aximus> second one is better imo; as Word15 and Word16 could (should?) be different types
10:33:37 <ezyang> Yeah, I guess so. 
10:34:17 <ezyang> One negative is that it's a little harder to prevent silly off-by-one bugs, which could have been detected by the fact that your alignment is all wrong. 
10:35:38 <ClaudiusMaximus> hm, what about an 'align' command to discard bits until you've got the right alignment
10:35:41 <ezyang> Maybe I should have an 'alignment' command 
10:35:43 <ezyang> yeah, that's it :-) 
10:35:49 <ezyang> well, it shouldn't discard commands. 
10:35:53 <ezyang> *bits 
10:36:45 <ClaudiusMaximus> ok, it should tell you whether you've got the right alignment or how many bits you need to skip to get to the right alignment
10:37:10 <ezyang> yeah, something like that. 
10:37:56 <ezyang> I wonder if this should even be built into attoparsec. I guess I could imagine asking for a Word32 and then using some other function to parse it. 
10:38:35 <sshc> How well supported are mutuall recursive modules?
10:39:08 <ezyang> sshc: Well supported. 
10:39:13 <ezyang> GHC uses them occasionally. 
10:39:29 <ClaudiusMaximus> sshc: you can get them to work, but it's painful (i've never needed to, though)
10:40:03 <ezyang> ClaudiusMaximus: I've found it to be less painful then having to stuff every function in a single module. 
10:40:48 <ezyang> Ok, so I think I'm going to try attoparsec + BitSyntax 
10:41:01 <sshc> ezyang: With GHC 6.14, do I need to do anything extra other than just import?
10:41:10 <sm> looks like error is another of those functions dealing with possibly-encoded "platform strings", so needs utf-8 on unix
10:41:22 <ezyang> sshc: You need to setup bootstrap modules and use the SOURCE pragma 
10:41:26 <ezyang> there are docs in the manual. 
10:41:56 <notabel> sshc:  basically, you have to move 
10:42:17 <notabel> sshc: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#mutual-recursion (sorry, mispasted earlier)
10:42:57 <ezyang> Hah, the naming scheme for Hs + S____ is pretty lolsy. It looks like people just drop the duplicate s. 
10:44:39 <ski> ezyang : ?
10:44:50 <ezyang> For example, hsql. 
10:45:04 * ezyang was trying to decide if he should name his lib hspdy or HsSpdy 
10:45:22 <ski> "Haskell SQL" ?
10:45:23 <Cale> I'd always looked at that as h + sql
10:46:05 <dons> ?yow
10:46:05 <lambdabot> Couldn't find fortune file
10:46:09 <dons> i miss the bsd fortunes
10:46:19 <dons> ezyang: how about no 'hs' prefix
10:46:35 <dons> since if it is on hackage, we know it is haskell. and in the distros, we'll add a 'haskell-*' prefix anyway
10:46:46 <dons> things i dislike: haskell-haskell-mongo (for example)
10:46:52 <dons> haskell-hs-foo
10:47:02 <dons> if it is a 'foo' library on hackage, call it 'foo'
10:47:42 <ezyang> dons: Ok. 
10:47:50 * dons should put up some naming/tagging advice for hackage stuff
10:48:11 <dons> good example, imo, 'opengl' -> packaged as haskell-opengl, binary -> haskell-binary, etc.
10:49:06 * monochrom volunteers to serve fortune cookie requests
10:49:25 <monochrom> "you will fix some haskell code today and feel happiness"
10:49:32 <dons> hehe
10:53:24 <DanielDiaz> Hello, anyone knows a package that plays sound files?
10:55:46 <monochrom> onoes, some hackage doc pages are in the new style! (but where is the synopsis sidebar? :) )
10:56:19 <monochrom> (oh I guess it's just the new css)
10:57:17 <DanielDiaz> monochrom, in my browser, I can see the synopsis at the right side of my screen
10:59:02 <monochrom> do you also have that on http://hackage.haskell.org/packages/archive/heap/1.0.0/doc/html/Data-Heap.html ?
10:59:33 <DanielDiaz> no
10:59:43 <monochrom> then I'm relieved :)
11:00:11 <DanielDiaz> ;)
11:15:07 <monadic_kid> DanielDiaz: what kind of sound files?
11:18:16 <DanielDiaz> .mp3, .wav, or similar
11:18:53 * hackagebot darcs-beta 2.4.98.5 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.4.98.5 (ReinierLamers)
11:19:47 <DanielDiaz> A kind of sound file that I can edit easily
11:20:21 <Zao> (note that mp3 does not lend itself well to any editing, apart from maybe cutting with pcut)
11:20:59 <DanielDiaz> well, I don't edit sound files with Haskell
11:21:42 <monadic_kid> DanielDiaz: I was going to say SDL_mixer, also check hackage sound section: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:sound
11:22:33 <DanielDiaz> I already saw en Hackage
11:22:40 <DanielDiaz> *in
11:23:07 <monadic_kid> DanielDiaz: SDL_mixer is quite simple to use
11:23:13 <DanielDiaz> but, I didn't found (yet) nothing
11:23:24 <DanielDiaz> thanks, monadic_kid, I will test it
11:23:47 <DanielDiaz> it works on windows?
11:24:31 <monadic_kid> DanielDiaz: yes
11:26:12 <monadic_kid> DanielDiaz: as it's a C library, you'll need to get devel archieve which contains the headers and DLL so you can build the haskell bindings against them
11:28:08 <DanielDiaz> "The package has a './configure' script. This requires a Unix"
11:28:39 <DanielDiaz> This message appears when configuring
11:30:22 <monadic_kid> DanielDiaz: are you talking about the SDL_mixer library or the haskell bindings?
11:30:39 <DanielDiaz> SDL package
11:31:41 <DanielDiaz> a SDL-mixer dependency
11:36:14 <monadic_kid> DanielDiaz: from http://www.libsdl.org/projects/SDL_mixer/ download SDL_mixer-devel-1.2.11-VC.zip, put the DLLs in some where like Windows/System32 directory, rename SDL_mixer.lib to libSDL_mixer.a put this and the header file in a place that ghc can find it, you might need to put the header inside a folder called SDL. Then using cabal, in the command prompt run cabal install SDL-mixer
11:36:52 <DanielDiaz> monadic_kid: OK, I will try it
11:37:03 <DanielDiaz> monadic_kid: thanks a lot
11:39:16 <monadic_kid> DanielDiaz: you want to put the header in C:\Program Files\Haskell Platform\2010.2.0.0\mingw\include or C:\Program Files\Haskell Platform\2010.2.0.0\mingw\include\SDL if the bindings fail to build, put the .a file in C:\Program Files\Haskell Platform\2010.2.0.0\mingw\lib
11:40:48 <McManiaC> huh? new haddock design on hackage?
11:41:18 <chrisdone> yesh
11:41:36 <chrisdone> after the haddock poll was totally in favour
11:41:37 <McManiaC> nice
11:42:33 <monochrom> we can still fight for our bikeshed colour^W^W html version, you know :)
11:43:18 <monochrom> on another note...
11:43:51 * monochrom finds http://hackage.haskell.org/package/PSQueue , has been searching for it for half of my life.
11:44:25 <monochrom> ever since the first time I learned Dijkstra's shortest-path algorithm...
11:45:07 <monochrom> "easy for you to say 'priority queue'. how do you change priority of some random guy in the middle of the queue?!"
11:46:28 <monochrom> oh yuck it says "base" not "base >= ?" or "base < ?"
11:46:29 <kmc> that's why the bizarre-ass heaps like the Fibonacci heap were invented
11:46:53 <wli> monochrom: In C, there were ways (kind of obvious) of rebalancing things to make sure orders were respected etc. upon priority changes.
11:49:17 <DanielDiaz> monadic_kid: Sorry, I get the same error when "cabal install"
11:52:45 * monochrom specifies cabal install --preference='base>=4' and gets no compile-time error :)
11:55:07 <benmachine> monochrom: you know you can put preferences in your .cabal/config?
11:55:18 <benmachine> I did that a while back with base4 and then forgot about it
11:55:20 <benmachine> seems to be fine
11:55:30 <monochrom> Yes I know. But I'm still paranoid.
11:55:33 <benmachine> heh
11:59:45 <chrisdone> :t showIntAtBase
11:59:46 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
11:59:52 <chrisdone> there a readIntAtBase?
12:00:18 <chrisdone> @hoogle readIntAtBase
12:00:18 <lambdabot> No results found
12:00:54 <lucca> Is there anything specifically needing base < 4?
12:07:18 <jmcarthur> lucca: quite a few, but that will have to change in order to be compatible with ghc 6.14 once it comes out
12:08:01 <roconnor> lucca: what is base 5?
12:08:24 <jmcarthur> ?
12:08:33 <jmcarthur> roconnor: <, not <=
12:09:01 <roconnor> oh
12:09:03 <roconnor> ah
12:09:38 <roconnor> monochrom: BTW, Dijkstra's shortest-path algorithm turns out to simply be gausian elimiation over a tropical semi-ring
12:11:04 <roconnor> also, PSQueue is awesome
12:11:09 <roconnor> as you noted
12:14:12 <chrisdone> tropical semi-ring
12:14:22 <chrisdone> mathematicians ~_~
12:14:46 * Twey has an image of a slice of pineapple.
12:15:09 <monochrom> java magma
12:15:51 * yitz wonders what kind of conversation he has just walked in on
12:16:04 <Twey> Heh.
12:23:19 <nickela_> hello, all. I have a question about catching errors in HaXml
12:24:55 <nickela_> I have code:  catch ( HaXml.ParseLazy.xmlParse "file" "non xml data" ) (const $ xmlParse "file" "<o/>")
12:25:47 <nickela_> I suppose get document for "<o/>" node, because parsing "non xml data" will fail
12:26:13 <nickela_> but my program completelly closed, with error text from HaXml
12:27:01 <nickela_> quesion is: how catch error from HaXml.ParseLazy.xmlParse without crashing program?
12:33:50 <sshc> What does th' "m" represent in "MVar"?
12:34:05 <Twey> Mutable?
12:34:13 <DanielDiaz> yes, "Mutable"
12:36:17 <Twey> Or ‘Mutex’ maybe?
12:36:26 <DanielDiaz> "Mutable"
12:36:45 <Twey> Okay
12:37:49 <chrisdone> http://chrisdone.com/images/bahaha.png
12:37:57 <chrisdone> great success
12:38:38 <Mathnerd314> is that xmonad?
12:38:48 <chrisdone> yup
12:40:08 <DanielDiaz> Just "."? :O
12:40:32 <chrisdone> that's what the author entered in the field: <dt>author</dt><dd>.</dd>
12:40:52 <chrisdone> well, he left it blank, but hpaste writes '.'
12:41:16 <Twey> chrisdone: Don't you think you should just have hpaste export a friendly API?
12:41:25 <Twey> Oh, wait
12:41:25 <JuanDaugherty> the distinction in re haskell-the-logic curry vs haskell apparently is the case
12:41:26 <Twey> Duh
12:41:29 <Twey> Yes
12:41:39 <Twey> How did you get the ‘redundant do’ warning? 
12:41:42 <chrisdone> Twey: that's the problem, whoever's hosting the server has disappeared
12:41:46 <Twey> Does that come standard with GHC these days?
12:41:47 <chrisdone> Twey: from hlint
12:41:50 <Twey> Ah
12:41:53 <chrisdone> nah I added it to my load function
12:42:11 <Twey> *nod*
12:42:23 <chrisdone> I'd prefer it the error message was indented four spaces. I'll have to patch it
12:42:31 <chrisdone> otherwise it's hard to know where the error ends
12:42:52 <chrisdone> (like with GHC's, I want to do errors/warnings collapsed by default)
12:45:53 <chrisdone> I had to patch it already to get rid of parse errors. I don't care that hlint can't parse some extension
12:51:59 <chrisdone> annoying thing is all the days are "34 days", etc. so you have to know at what point the files were downloaded and at what point you're parsing the data set
12:52:09 <chrisdone> getClockTime/getModificationTime to the rescue
12:53:02 <chrisdone> woops, thought I was in -blah
12:53:49 <nickela> Please, help me catch error in HaXml: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29742#a29742
12:55:07 <nickela> in pasted code, I hope to see '<a/> \n Im alive!'
12:55:22 <nickela> but program totally crashed...
12:58:18 <chrisdone> bah none of the hackage docs are available. are they doing some batch process?
12:58:39 <chrisdone> ah, I have local docs
13:01:32 <tommd> chrisdone: At midnight every day
13:01:40 <chrisdone> midnight where?
13:01:43 <tommd> Unless this is something new due to haddock x.8?
13:01:50 <tommd> I assume either England or Portland
13:01:52 <chrisdone> that's what I wondered
13:01:52 <tommd> not sure which
13:03:56 <sm> how do I fix this on windows ?: Prelude> putStrLn "\1082"
13:03:56 <sm> *** Exception: <stdout>: hPutChar: invalid argument (character is not in the code page)
13:05:11 <chrisdone> mmm. I love applicative
13:05:30 <_unK> I'd like to read lines from the handle (not necessarily a file, rather a socket and I want to keep it open, so hGetContents doesn't fit here). I have two functions for that: http://codepad.org/GGH5SG3D first one is ok, but it's not lazy. second one is lazy, but it makes use of unsafePerformIO, which isn't exactly nice thing. is there a way to rewrite second function without unsafePerormIO and preserve its laziness?
13:05:32 <chrisdone> I never really used it in parsec for whatever reason. now in parsec3 it's goodness
13:05:36 <chrisdone>   minutes = do ds <- many1 digit; string " minutes"; return (readMay ds)
13:05:41 <chrisdone> =>
13:05:41 <chrisdone>   minutes = readMay <$> many1 digit <* string " minutes"
13:06:37 <chrisdone> (yeah, I'm using parsec because I can never figure out the regular expressions library)
13:07:28 <sm> chrisdone: interesting, thanks
13:08:02 <sm> what's your internal vocabulary for the <* operator ?
13:08:15 <chrisdone> I think "discard"
13:08:26 <chrisdone> it's like (>>) in Monad
13:08:31 <Funktorsalat> sm: "<---- here, this is what matters"
13:08:34 <Funktorsalat> ;)
13:09:39 <sm> so <*> would be "pass both of these as "arguments"" and <* and I imagine *> is "pass just this one"
13:10:14 <sm> one of these days I'll spontaneously start applicatifying left and right.. thanks
13:10:14 <chrisdone> <* doesn't pass anything, it discards the result
13:10:26 <dons> yay for new haddock on hackage
13:10:27 <chrisdone> see the monadic version above it, it's directly equivalent
13:10:33 <dons> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html happy
13:11:25 <chrisdone> nice
13:11:47 <sm> oh yay, that is nice. Better than the new-css haddocks I've seen starting to pop up
13:11:56 <chrisdone> that documentation with examples is great
13:12:01 <Funktorsalat> I like the new haddock
13:12:41 <Funktorsalat> sm: hmm what dons linked doesn't look any different from the new haddock theme
13:13:15 <sm> I saw some which had the theme but not the synopsis tab, and Source links weren't right-justified
13:13:25 <sm> yesod's, perhaps
13:13:58 <avenge> What happens when the synopsis is very long?
13:14:52 <djahandarie> Internal scrollbar I'm guessing
13:15:03 <djahandarie> Yep
13:15:18 <dons> sm: that is the new haddock.
13:15:28 <Funktorsalat> I haven't thought about the new theme consciously much but I just find things quicker in it
13:15:34 <Funktorsalat> (just first impression)
13:15:54 <sm> ok here's an example. http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html is better than http://hackage.haskell.org/packages/archive/hledger/0.11.1/doc/html/Hledger-Cli-Commands-Add.html
13:15:59 <djahandarie> imo the synopsis should be open by default
13:16:11 <Funktorsalat> or maybe it's just the novelty making me more alert lol
13:16:17 <avenge> I like the new index all on one page.  It's easier just to search within one page than to have to click through a link of the first letter.
13:16:44 <Funktorsalat> the old synopsis had a serious issue imho; it bombarded you with lots of stuff without docs withotu making it clear that there are docs
13:17:00 <avenge> djahandarie: disagree about the synopsis.  Or at least if the synopsis is too long, because you have to scroll through too much stuff to find what you want.
13:17:24 <chrisdone> :t let f <$.> a = fmap f . a in (<$.>)
13:17:24 <chrisdone> > let f <$.> a = fmap f . a in (*2) <$.> Just $ 4
13:17:25 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:17:25 <lambdabot>   Just 8
13:17:29 <chrisdone> does this operator exist anywhere already?
13:17:42 <djahandarie> avenge, hm? It'd certainly be nicer scrolling through the synopsis rather than the whole page if it is a long page/synopsis
13:17:47 <Funktorsalat> chrisdone: I've been lobbying for it :P
13:17:52 <chrisdone> I tend to write (fmap f . a) <$> *a lot*
13:17:57 <chrisdone> Funktorsalat: what did you call it?
13:17:59 <sm> dons: see the difference ? no synopsis and non-right-justified Source links in the latter. CSS issue maybe ?
13:18:02 <chrisdone> I'll use the same as you
13:18:07 <sm> also, no http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/frames.html makes me sad
13:18:13 <avenge> djahandarie: But above a certain length, I always use search within the web page.  At the point where I'm running a search anyway, I want to find the real symbol, not its synopsis.
13:18:22 <Funktorsalat> chrisdone: hmm, I had several ideas, don't remember what I decided on :(
13:18:30 <djahandarie> avenge, maybe a search box should be added then? :P
13:18:34 <Funktorsalat> maybe the whole zoo should be redone to be systematic
13:18:48 <Funktorsalat> chrisdone: <-< ?
13:18:54 <Funktorsalat> in analogy to <=<
13:18:58 <Funktorsalat> but less monadic ;)
13:19:05 <avenge> djahandarie: Yes, would love a search box.
13:19:08 <djahandarie> Except <-< reminds me of arrows
13:19:15 <chrisdone> reminds me of arrows too
13:19:17 <djahandarie> And I think something uses that
13:19:20 <djahandarie> already
13:19:25 <djahandarie> @hoogle (<-<)
13:19:25 <lambdabot> No results found
13:19:27 <djahandarie> Hmmm
13:19:51 <avenge> arrows which use <- and -<
13:19:56 <Funktorsalat> chrisdone: the dollar means 'application' to me
13:19:58 <Funktorsalat> rather than compo
13:20:11 <Funktorsalat> .=< would also be an option
13:20:13 <chrisdone> Funktorsalat: what about <$.>?  f <$.> g = (f <$>) . g
13:20:23 <Funktorsalat> ah, didn't notice that
13:20:44 <Funktorsalat> (.=< to indicate that the right arg is as with <=<, but the left is pure o_O)
13:20:56 <chrisdone> I see it
13:20:57 <avenge> This new haddock really looks good, though.  Is there any change in the input syntax?
13:21:01 <sm> oh I see.. http://hackage.haskell.org/packages/archive/hledger/0.11.1/doc/html/Hledger-Cli-Commands-Add.html was built with haddock 2.6 but using 2.8's styles. Makes sense.
13:21:06 <Funktorsalat> but .=< is a bit ugly ;)
13:21:15 <chrisdone> I like it, but yeah, it's like a fish without a head
13:21:34 <djahandarie> I prepose :-< and :-> 
13:21:34 <Funktorsalat> with a drip of blood?
13:21:36 <Funktorsalat> :Fff
13:21:38 <chrisdone> :p
13:22:01 <Funktorsalat> djahandarie: :-> is natural transformation already in some places
13:22:15 <Funktorsalat> but it's bad because it's so emotionally distracting o_O
13:22:15 <chrisdone> Funktorsalat: are there other patterns like this? maybe there's something more general underlining this
13:22:30 <chrisdone> conal: beep
13:22:40 <Funktorsalat> chrisdone: I don't really see much of a system in the existing operators
13:22:59 <Funktorsalat> I tried making a systematic module, but old habits proved unbreakable
13:23:14 <chrisdone> Funktorsalat: yeah composing separate applicatives feels clunky
13:23:32 * djahandarie contemplates his abstract algebra module again
13:23:48 <djahandarie> I kinda don't like numeric prelude
13:24:17 <djahandarie> Feels like they tried too hard to adopt some of the stuff already in Haskell instead of just going with pure math terms
13:24:59 <chrisdone> well quite a bit of the prelude is a compromise
13:25:17 <chrisdone> :t map
13:25:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:25:53 <Funktorsalat> djahandarie: I think one of the objections is that you'd need to write like 5 instances for Num
13:26:39 <djahandarie> Funktorsalat, huh? I would get rid of Num entirely
13:26:54 <Funktorsalat> semigroup,monoid,group,multiplicative {semigroup,monoid}, and something to give you absolute value and signum...
13:27:06 <Funktorsalat> don't remember the word for fields with an absolute value
13:27:18 <djahandarie> Ah okay, I see what you mean now
13:27:47 <djahandarie> A valued field?
13:27:54 <djahandarie> Not sure either
13:28:04 <avenge> Ah, bummer.  The new haddock still does not link to source for instances.
13:28:05 <Feuerbach> isn't absolute value just a norm?
13:28:21 <avenge> I so wish there were an easy way to get the source code for class instances...
13:28:51 <Funktorsalat> grep
13:28:55 <Funktorsalat> ;)
13:28:56 <DanielDiaz> you are talking about "normed space"
13:29:07 <avenge> grep doesn't work on hoogle.
13:29:21 <bremner> err, normed vector space?
13:29:26 <Funktorsalat> Feuerbach: a norm with the extra law |a*b|=|a|*|b|
13:29:27 <chrisdone> yay parsec documentation is up
13:29:52 <avenge> Oh... but the new haddock includes comments on instances.  That's great.  You can document your instances!
13:29:55 <DanielDiaz> norm is usually called "absolute value" in a 1-dimensional space
13:29:56 <Funktorsalat> I think that's usually required for fields... in a banach algebra it's just |a*b| <= |a|*|b| though iirc
13:30:13 <Funktorsalat> it's not just 'normed space' as per above
13:30:24 * djahandarie still thinks valued field
13:31:17 <Funktorsalat> (think matrices, a = projection to first component, b = to second, for an example with strict inequality)
13:31:48 <Funktorsalat> and your favourite matrix norm
13:35:12 <DanielDiaz> well, when I work with a vector space with a norm, I call it a "normed (vector) space" like I learned in the University
13:35:41 <Funktorsalat> DanielDiaz: but Num isn't just a vector space
13:35:54 <Funktorsalat> and normed spaces don't know anything about multiplication
13:36:02 <DanielDiaz> Funkstorsalat: sorry, maybe I miss something
13:36:26 <Funktorsalat> just saying you want an *additional* axiom to relate the multiplication and norm, on top of 'normed space'
13:36:40 <djahandarie> I'm pretty sure a valuation exactly captures this
13:36:50 * djahandarie is not an expert though
13:36:57 <Funktorsalat> djahandarie: yes I vaguely remember that term too :)
13:37:18 <Funktorsalat> (for fields at least)
13:37:42 <DanielDiaz> right, in a vector space only exists a scalar multiplication
13:38:20 <DanielDiaz> that's you mean?
13:38:59 <DanielDiaz> (I have a little difficult to speak about maths in english hehe)
13:40:45 <djahandarie> A lie algebra would be a vector space with eg cross product and an inner product space would be a vector space with the dot/inner product. But none of that helps what we are searching for I believe
13:42:28 <djahandarie> Funktorsalat, metric space?
13:42:32 <DanielDiaz> you're talking about Num class?
13:43:28 <djahandarie> Yes, and the different instances of algebraic structures that would be required to represent it
13:44:09 <Funktorsalat> djahandarie: why not just 'algebra'
13:44:17 <Funktorsalat> as a generalization of Num
13:44:35 <Funktorsalat> or 'ring' really, since there's no field
13:44:45 <Funktorsalat> but I only know normed/banach algebras, not rings ;)
13:45:05 <Funktorsalat> (ring=Z-algebra, anyway ;))
13:45:07 <ezyang> Bah, why does Haskell not have a natural number type. 
13:46:54 <Mathnerd314> ezyang: data Nat = Zero | Succ Nat :p
13:47:17 <Mathnerd314> or One, depending on your definition of "natural"
13:47:32 <Funktorsalat> data Nat = Zero | One | Twice Nat -- exponential speedup :p
13:47:44 <chrisdone> @hoogle eitherToMaybe
13:47:44 <lambdabot> No results found
13:47:45 <Funktorsalat> wait
13:47:53 <chrisdone> @hoogle Either z a -> Maybe a
13:47:53 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
13:47:54 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
13:47:54 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
13:47:56 <ezyang> aggggh 
13:47:59 <Funktorsalat> data Nat = Zero | Twice Nat | TwicePlus1 Nat -- this
13:48:18 <chrisdone> hmm
13:48:23 <chrisdone> sure I saw eitherToMaybe somewhere
13:48:31 <chrisdone> maybe it was in missingH or Data.Either
13:48:55 <Funktorsalat> golf addict? :p 'either (const Nothing) . Just'
13:48:56 <chrisdone> ah, missingh
13:49:13 <chrisdone> but when I'm working in the Maybe monad I don't want to have to write 'Nothing'
13:49:14 <chrisdone> :(
13:49:23 <Funktorsalat> :)
13:49:26 <arw> data Nat = subset (> 0) of Integer would be nice :)
13:50:05 <Funktorsalat> ('nice' as in 'completely differeny programming language'? :p)
13:50:23 <Funktorsalat> (dependent types)
13:50:36 <chrisdone> :t listToMaybe . rights
13:50:37 <lambdabot> forall a a1. [Either a1 a] -> Maybe a
13:50:42 <chrisdone> :t listToMaybe . rights . return
13:50:43 <lambdabot> forall a a1. Either a1 a -> Maybe a
13:50:47 <chrisdone> ^_^
13:50:54 <chrisdone> DISGUSTINGLY LARGE
13:51:05 <Twey> Hehe
13:51:27 <Funktorsalat> hehe
13:51:47 <Funktorsalat> either (const mzero) . return? :p
13:51:54 <Funktorsalat> no Nothing
13:52:14 <Funktorsalat> sorry I has the dumb today
13:53:32 <Funktorsalat> @ty either (const mzero) . return
13:53:33 <lambdabot> forall (m :: * -> *) a a1 b. (MonadPlus m) => m a -> Either a1 b -> m a
13:53:47 <chrisdone> the mzero is nicer
13:53:59 <Funktorsalat> oh no it has the wrong type
13:54:14 <chrisdone> yeah, flip it
13:54:20 <chrisdone> @ty flip either (const mzero) . return
13:54:22 <lambdabot> forall a b (m :: * -> *) a1. (MonadPlus m) => m a1 -> Either a b -> m a1
13:54:35 <chrisdone> wait no
13:54:46 <chrisdone> what lol
13:54:50 <Funktorsalat> @ty \x -> either (const mzero) return x
13:54:51 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => Either a1 a -> m a
13:55:01 <chrisdone> right
13:55:03 <Funktorsalat> mysterious
13:55:24 <Funktorsalat> @ty either (const mzero) return
13:55:24 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => Either a1 a -> m a
13:55:26 <Funktorsalat> doh
13:55:26 <chrisdone> Composalad
14:01:20 <Mathnerd314> There's probably some way to use do-notation and monadic failure...
14:02:13 <Funktorsalat> Mathnerd314: failed pattern binds
14:02:38 <Mathnerd314> yeah, I can't see how it would look though
14:03:27 <Funktorsalat> > do { Just [] <- Just [1]; return "hai" } :: Maybe String
14:03:28 <lambdabot>   Couldn't match expected type `[t]'
14:03:28 <lambdabot>         against inferred type `Data.Mayb...
14:03:42 <Funktorsalat> hmpf
14:03:51 * hackagebot liboleg 2010.1.9.0 - An evolving collection of Oleg Kiselyov's Haskell modules  http://hackage.haskell.org/package/liboleg-2010.1.9.0 (DonaldStewart)
14:03:57 <Twey> Woah
14:03:59 <Funktorsalat> > do { [] <- Just [1]; return "hai" } :: Maybe String
14:03:59 <Twey> liboleg?  Haha.
14:04:00 <lambdabot>   Nothing
14:04:02 <Funktorsalat> :)
14:04:23 <Funktorsalat> Mathnerd314: that called "fail" to produce the nothing
14:04:40 <Funktorsalat> > do { [] <- Right [1]; return "hai" } :: Either String String
14:04:41 <lambdabot>   Left "Pattern match failure in do expression at <interactive>:1:142-143"
14:04:47 <Funktorsalat> neat
14:04:58 <hpc> whoa
14:05:17 <hpc> @src Either fail
14:05:18 <lambdabot> fail msg      = Left (strMsg msg)
14:05:41 <hpc> :t fail
14:05:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:05:48 <hpc> :t strMsg
14:05:49 <Funktorsalat> I see that the Error constraint is actually good for something
14:05:49 <lambdabot> forall a. (Error a) => String -> a
14:06:01 <Funktorsalat> hpc: method of Error
14:06:44 <shapr> Yay Haskell! w00!
14:06:57 <dons> w00!!!
14:07:01 <Guest89773> Hi, I'm having challenges connecting a Haskell program to wxHaskell in Windows
14:11:58 <Guest89773> Anyone here using Haskell on Windows?
14:12:36 <Zao> Yes.
14:12:38 <hpc> only as a ghci that doesn't need ssh
14:13:02 <chrisdone> wooooooooooooooop
14:17:08 <chrisdone> http://paste.tryhaskell.org/30085/securityt
14:17:36 <Guest89773> How does iRC work?
14:17:48 <chrisdone> http://paste.tryhaskell.org/paste/30085/example#p30086
14:17:57 <chrisdone> @google wikipedia irc
14:17:59 <lambdabot> http://en.wikipedia.org/wiki/Internet_Relay_Chat
14:17:59 <lambdabot> Title: Internet Relay Chat - Wikipedia, the free encyclopedia
14:18:44 <Guest89773> Has anyone connect Haskell to wxHaskell on Windows?
14:19:08 <Zao> Guest89773: You type stuff into channels and the other people in the channels see it.
14:19:29 <Zao> Guest89773: What about it fails you? Building wx? Building wxHaskell? Using wxHaskell in your code?
14:19:45 <Cale> Guest8345: I've used wxHaskell successfully on Windows, but that was so long ago that I doubt any information I have about it is relevant.
14:19:58 <Guest89773> I think building wxWidgets then building wxHaskell
14:20:46 <conal> has anyone heard whether the ghci-killing property of wxHaskell has been fixed yet?
14:21:45 <Cale> Guest8345: There's a guide to how to set it up here: http://haskell.org/haskellwiki/WxHaskell/Building
14:21:46 <chrisdone> does it call exit();?
14:21:48 <ezyang> I wonder if accessor functions for sum types are bad form. 
14:21:53 <ezyang> because they are necessarily partial. 
14:22:05 <cpfr> anyone here play with easyVision?
14:22:37 <conal> chrisdone: directed to me?
14:22:48 <chrisdone> conal: yeah. just curious
14:22:58 <conal> chrisdone: the second time a top-level window is opened in wxhaskell, the host process crashes.
14:23:06 <chrisdone> ah.
14:23:18 <conal> chrisdone: due to a change in how wxwidgets handles initialization.
14:23:20 <conal> a few years back
14:23:42 <benmachine> ezyang: partial functions are not universally evil, but I think pattern matching is more watertight
14:23:51 * ezyang agrees 
14:24:50 * chrisdone avoids partial functions all together
14:25:15 <bremner> ooh, you could have said totally
14:25:19 <Heffalump> is there a standard way to stop haddock trying to index instance Foo Bar, when Bar isn't exported?
14:25:21 <chrisdone> hahaha
14:27:56 * hackagebot checkers 0.2.7 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.2.7 (ConalElliott)
14:30:19 <chrisdone> the main difference between a Haskell programmer and any other programmer is once the Haskell programmer is happy with his functions, and the compositions thereof, he's perfectly willing to bet on the correctness of the program as a whole
14:30:27 <chrisdone> :p
14:31:02 <Martty> any programmer who prides himself in calling one should be able to build confidently on top of already coded blocks
14:31:21 <Martty> doing that in haskell is easier
14:31:29 <Martty> haskell programmers are lazy
14:31:36 <hpc> as well they should be
14:31:57 <chrisdone> I ask programmers if they'd bet that their code is correct, the answer is always a resounding no
14:32:08 <Martty> is this haskell related
14:32:12 <Martty> or in general
14:32:21 <chrisdone> especially with lispers
14:32:29 <chrisdone> they're more concerned with how easy it is to fix at runtime
14:32:35 <hpc> haha
14:33:13 <solidsnack> Is this new?  WARNING: /home/<blah>/.ghci is writable by someone else, IGNORING!
14:33:58 * hackagebot wumpus-core 0.31.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.31.0 (StephenTetley)
14:35:32 <hpc> solidsnack: that means you should chmod that file
14:35:41 <solidsnack> No it doesn't.
14:35:54 <hpc> no?
14:35:56 <solidsnack> It means the GHC developers don't understand user private groups.
14:35:58 * hackagebot wumpus-basic 0.6.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.6.0 (StephenTetley)
14:36:00 * hackagebot wumpus-microprint 0.6.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.6.0 (StephenTetley)
14:36:02 * hackagebot wumpus-tree 0.5.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.5.0 (StephenTetley)
14:36:20 <benmachine> solidsnack: no, it means the GHC developers think the GHC users don't understand groups >_>
14:36:27 <solidsnack> Last I checked, this was a Haskell compiler, not GHCSSH.
14:36:42 <benmachine> solidsnack: yes but ghci can execute arbitrary code :)
14:36:57 <hpc> as can .ghci
14:36:58 <solidsnack> ...
14:37:01 <Entroacceptor> why do I suddenly get an error when trying to render a hstringtemplate with data.text.lazy in it?     No instance for (Stringable LT.Text)
14:37:11 <benmachine> :!cp ~/.ssh/id_rsa /home/evilsteve/secretstash
14:37:12 <hpc> more importantly
14:37:14 <benmachine> sorted.
14:37:29 <Entroacceptor> I could bet it worked before...
14:37:34 <benmachine> even better
14:37:38 <benmachine> :!cp ~/.ssh/id_rsa /home/evilsteve/secretstash
14:37:43 <benmachine> :!rm ~/.ghci
14:37:45 <hpc> :!rm -r /
14:37:48 <benmachine> *gasp*
14:38:01 <hpc> :!unsafeLaunchMissiles
14:38:09 <solidsnack> Bash supports user private groups.
14:38:21 <benmachine> what are user private groups?
14:38:23 <solidsnack> The GHC maintainers are not system administrators and shouldn't try so hard.
14:38:37 <benmachine> and what's the big deal with chmod 644 .ghci?
14:38:53 <benmachine> they're not trying so hard as to support user private groups :P
14:39:03 <solidsnack> benmachine: They don't need to do anything.
14:39:15 <solidsnack> benmachine: But they actually break user private groups with what they do.
14:39:24 <solidsnack> My umask is 002.
14:39:35 <benmachine> solidsnack: well, no, they break .ghci files for people who use user private groups
14:39:37 <hpc> they break nothing; it's a warning
14:39:41 <hpc> unless warnings are fatal now
14:39:48 <benmachine> hpc: IGNORING
14:39:51 <nostrand> is there a way to run haskell code directly like: runhaskell "main = print 1"?
14:39:56 <solidsnack> hpc: It's not just a warning.
14:39:59 <benmachine> nostrand: yes, ghc -e
14:40:11 <nostrand> benmachine: thanks :D
14:40:18 <benmachine> nostrand: I don't remember exactly how it works though, I think it's like typing the next argument into ghci
14:40:36 <solidsnack> benmachine: User private groups are when every user gets their own group -- like my username is `solidsnack' and I have a group `solidsnack'.
14:40:51 <nostrand> benmachine: seems so, thanks =)
14:41:03 <hpc> that seems pointless
14:41:10 <benmachine> solidsnack: oh right, but other people are in the group solidsnack?
14:41:16 <solidsnack> no
14:41:23 <benmachine> solidsnack: then why not have it mode 644 :P
14:41:34 <solidsnack> Then, I set the setgid bit on shared directories.
14:41:54 <solidsnack> Like, /opt on some of my systems and /usr/local/bin on others.
14:42:19 <solidsnack> With my umask as 002, I can edit files in those directories without locking other users out.
14:42:38 <solidsnack> User private groups are an important part of using UNIX as a time sharing, multi-user operating system.
14:42:52 <solidsnack> Time-sharing is really the way of the future and I hope GHC will support it.
14:42:57 <solidsnack> Some day.
14:43:24 <benmachine> well if you think it's a big deal, maybe you should file a bug
14:43:40 <benmachine> maybe GHC devs have been having reports of people using .ghci files to compromise security
14:44:06 <solidsnack> Well, they would be silly to take responsibility in that case.
14:44:28 <benmachine> it's not necessarily a case of taking responsibility, it's a case of, you can prevent a problem or let it happen
14:44:41 <benmachine> they do what they think is best
14:44:52 <benmachine> if you think something else is better, maybe they haven't heard
14:45:20 <benmachine> but do so without trying to tell them what their job is, would be my advice :P
14:46:17 <hpc> it can also be said that part of their responsibility maintaining GHC is to ensure that it has no security issues
14:46:22 <solidsnack> I was just asking if this feature is new; I've never seen it before and I've used user private groups and GHC for like 3 years now.
14:46:26 <hpc> and warn when a misconfiguration would produce one
14:46:30 <avenge> benmachine:  Or, as a compromise, you could have something equivalent to sendmail's DontBlameSendmail option...
14:46:52 <avenge> benmachine:  Since some people might know better or think they know better, there should be some way to disable subjective policy decitions.
14:47:00 <co_dh> I have an opengl program, while in the keyboard I write a variable, and in the display callback I read that variable, do I have to use IORef ? 
14:47:15 <hpc> yes
14:47:29 <benmachine> solidsnack: oh well then, I dunno :P
14:47:45 <hpc> the opengl callbacks can't communicate without pointers
14:47:49 <benmachine> avenge: mm that'd be pretty okay, not sure where you'd put such an option if it affects whether or not you read the config file >_>
14:48:04 <avenge> You could put it in the config file.
14:48:11 <avenge> The point is these problems don't happen instantaneously.
14:48:14 <solidsnack> hpc: I don't think that's actually their responsibility at all; there's not even that much they can do.
14:48:38 <solidsnack> They site administrator is responsible for security policies and would really be better just not to get in their way.
14:48:40 <avenge> Someone misconfigures a file, someone later overwrites the file.  If you put in the file some option saying "I know what I'm doing."  Or maybe an environment variable or something.
14:49:03 <co_dh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29744#a29744
14:49:04 <solidsnack> s/They site/The site/
14:49:16 <hpc> i wouldn't make it part of the file itself
14:49:23 <hpc> otherwise an interloper could put it in themselves
14:49:27 <benmachine> yeah that'd be pretty pointless
14:49:57 <avenge> hpc:  Yeah, probably not.  It wouldn't be completely pointless, as the point is to train users not to do this.  (The interloper has to get in there in the first palce, and could always just have the file execute something that changes the permissions back.)
14:50:18 <solidsnack> co_dh: I think you have to, yeah. You can't use STM or something similar because you're already in the IO monad for the read/write operations.
14:51:25 <benmachine> STM is in IO anyway, right?
14:51:28 <benmachine> did you mean: ST
14:51:32 <hpc> if you can do getDisplayCallback or something like that, you could probably do some wizardry with setting it to (doPreviousCallback >> moreStuff)
14:51:36 <solidsnack> benmachine: No, it's not in IO.
14:51:36 <hpc> but ew
14:51:50 <solidsnack> You can't do arbitrary IO operations in STM.
14:51:58 <chrisdone> or any
14:52:06 <benmachine> solidsnack: yes, but you can't do STM outside of IO
14:52:15 <solidsnack> benmachine: Yes you can.
14:52:38 <solidsnack> I mean, sure, you can't do even `Int -> Int' outside of IO.
14:53:44 <solidsnack> Oh, I see what you're saying; you can only run `atomically' in IO.
14:53:58 <hpc> :t atomically
14:53:59 <lambdabot> Not in scope: `atomically'
14:54:05 <benmachine> yeah
14:54:43 <solidsnack> However, that is neither here nor there; it's really that you can't do `getKeyPress' or similar inside STM.
14:56:59 <chrisdone> sure, STM transactions have to be repeatable
14:57:23 <solidsnack> So I think there is no nice way to do without IORefs in co_dh's example.
14:57:28 <chrisdone> no non-transactional actions, which can't be checked for IO
14:57:30 <cpfr> anyone here play with easyVision?
14:58:05 <co_dh> solidsnack: thanks.
15:00:53 <cpfr> I'm getting error:setup: Missing dependencies on foreign libraries:
15:01:06 <cpfr> even though I have the libraries it wants
15:01:47 <kmc> can you set -v for verbose?
15:02:44 <cpfr> kmc, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29745#a29745
15:04:36 <kmc> you have the dev packages for those libraries?
15:04:56 <cpfr> you can't get those as dev packages
15:05:14 <cpfr> they are just stored locally in my ~/intel/ipp/sharedlib directory
15:08:58 <eikke_> is there anything like Linq for haskell?
15:10:11 <dons> linq was inspired by monad comprehensions in haskell. what features of linq are you interested in?
15:10:36 <dons> for example, SQL comprehensions, http://www-db.informatik.uni-tuebingen.de/research/ferry 
15:10:47 <eikke_> declarative construction of sql or other query strings
15:10:55 <dons> ah yes. see above (new).
15:11:33 <eikke_> interesting. I found haskelldb, but wasnt very convinced (yet)
15:12:02 <dons> haskelldb is like one layer further down.
15:12:06 <dons> you do it explicitly via combinators
15:12:11 <dons> rather  than list comprehension-style syntax
15:12:21 <eikke_> true
15:12:22 <kmc> eikke_, using LINQ in C# to construct SQL uses not only the monad-comprehension syntax, but the fact that lambdas in C# are also quotations
15:12:28 <kmc> which is not true in Haskell
15:12:32 <kmc> but you can quote things other ways
15:12:41 <eikke_> I don't really like the requirement to provide a code-schema of the db as well
15:12:53 <dons> the other thing would be "query comprehensions", recently added, http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#generalised-list-comprehensions
15:13:06 <dons> those don't actually generate SQL, but let you write SQL-like queries on other data types
15:13:08 <kmc> i think it's probably better to use an explicit combinator library than to hijack the list syntax
15:13:19 <eikke_> kmc: I'll have to do some vocabulary queries to understand what you just said :D
15:13:31 <dons> the ferry project is quite nice, though, kmc. efficient, elegant statically checked SQL.
15:13:38 <dons> all via a familiar notation
15:19:10 <cpfr> kmc, any idea why the libraries aren't being picked up?
15:19:39 <eikke_> dons: is the ferry stuff available somewhere?
15:19:41 <cpfr> copying them to /usr/lib does nothing
15:20:16 <eikke_> (under the 'no paper without source' paradigm ;-))
15:20:21 <kmc> cpfr, did you install the "dev" packages?
15:20:25 <kmc> the ones that provide the C header files?
15:21:06 <cpfr> they are stored in a local directory
15:21:20 <cpfr> i used --extra-include-files to show cabal where they are
15:21:25 <cpfr> but its not picking it up
15:23:04 <revenantphx> kmc: so how exactly is LINQ related to monads?
15:23:17 <revenantphx> I mean the syntax looks an awful lot like monad statements chained together...
15:23:25 <revenantphx> like do but without the newlines
15:23:26 <revenantphx> (or with them)
15:24:23 <revenantphx> IEnumerable<Student> studentQuery = from student in students where student.Scores[0] > 90 select student;
15:24:40 <kmc> revenantphx, here's an example:  http://blogs.msdn.com/b/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
15:25:16 <kmc> if your type implements Where, Select, and SelectMany methods, then you can use the LINQ syntax and it desugars to calls to those methods
15:25:43 <kmc> in Haskell, if your type implements return and (>>=), then you can use the do syntax and it desugars to calls to those functions
15:25:46 <revenantphx> that sounds REALLY like monads :P
15:26:17 <eikke_> Scala's 'for' statement works similar as well (using the flatMap monad definition style)
15:26:18 <chrisdone> dons: hmmm ferry for takusen sounds nice. I recently switched from haskelldb to takusen and the typeable stuff is great for retrieving data but I do miss the compile time checking. is ferry going to get into ghc? spj seems interested judging from here: http://www.mail-archive.com/haskell-cafe@haskell.org/msg76144.html 
15:26:28 <Kaide> Microsoft had a talk with some of the haskell people and thought that using the term monad was a bit of a mistake
15:26:34 <Kaide> so they use "workflow" instead
15:26:37 <kmc> in F#
15:26:38 <kmc> yeah
15:26:45 <kmc> yeah you can bikeshed endlessly about whether Haskell should or shouldn't use mathy names
15:26:46 <Veinor> which is so much more intuitive?
15:26:47 <monochrom> workflow seems a nice word
15:26:47 <dons> eikke_: i think it is close to release. they have a release timeline
15:27:08 <kmc> the mistake might just be that "monad" is a noun
15:27:11 <eikke_> heh, idd, while reading an F# book, when I reached the Workflow chapter, it was way too familiar not to be monads
15:27:20 <kmc> because people as "what is a monad" and if you say "thing implementing the Monad interface" they look at you funny
15:27:22 <monochrom> now we get to fight over whether "workflow" refers to a type, a value, or both :)
15:27:25 <eikke_> dons: thanks!
15:27:33 <kmc> but if you ask "what is a thing implementing the LINQ interface" then you've answered your own question
15:27:37 <Kaide> Microsoft invested in and learned from haskell a lot I think
15:27:46 <Kaide> so if you see influence, probably not a coincidence
15:27:54 <hpc> microsoft invested in haskell?
15:28:08 <Kaide> yeah, their cambridge research dept pays people to help develop it
15:28:11 <avenge> Simon Peyton-Jones 
15:28:16 <kmc> and Simon Marlow
15:28:18 <hpc> huh
15:28:18 <monochrom> in soviet russia, haskell invests in microsoft
15:28:38 <kmc> Haskell is quite influential in the design of new languages
15:28:47 <kmc> to the point where people try to claim influence even when they don't have a clue (Go)
15:28:53 <hpc> haha
15:28:59 <Twey> Heh.
15:29:12 <revenantphx> Go?
15:29:18 <hpc> google's C killer
15:29:22 <hpc> it sucks
15:29:29 <revenantphx> ...C killer
15:29:36 <revenantphx> My opinion is... we won't see a C killer.
15:29:36 <avenge> Is this Rob Pike & Co.'s language?
15:29:37 <revenantphx> ever.
15:29:47 <revenantphx> C has its niche fully hollowed out.
15:29:51 <hpc> that's as close as i can imagine its purpose being
15:29:55 <avenge> revenantphx: Agreed.  C is pretty perfect for what it is.
15:29:59 <revenantphx> avenge: exactly.
15:30:01 <kmc> i disagree
15:30:07 <kmc> it has a few big flaws as a portable assembly language
15:30:10 <kmc> no way to write a tail call
15:30:13 <chrisdone> aw, awesome. ferry looks brilliant
15:30:22 <kmc> i'd like something in the same niche as C, but with more static checking
15:30:23 <revenantphx> kmc: english?
15:30:28 <kmc> that is english
15:30:32 <Twey> kmc: ATS?  BitC?
15:30:32 <avenge> It's more than a portable assembly.  There are a couple of mistakes in the language design, but not big enough to warrant replacing it.
15:30:36 <kmc> right Twey
15:30:43 <revenantphx> kmc: C's weakly typedness is wonderful imo
15:30:49 <Twey> FORTH is cooler than C, too, though that has *less* static checking
15:30:49 <revenantphx> makes low level stuff much easier to work with.
15:30:52 <wli> avenge: What are the mistakes?
15:31:01 <Kaide> kmc: you could use a goto, at least
15:31:04 <revenantphx> Besides, at the C level, you want to enforce the fact that EVERYTHING IS DATA.
15:31:06 <kmc> revenantphx, sure, at the expense of your program crashing and burning
15:31:10 <Kaide> although you run into limitations with that
15:31:12 <kmc> Kaide, not between procedures
15:31:18 <revenantphx> kmc: that's just bad programming then
15:31:22 <avenge> wli:  They are pretty minor.  For example, the precedence of bitwise and and or is too low.
15:31:24 <revenantphx> kmc: With C the burden is on the programmer.
15:31:27 <kmc> revenantphx, of course
15:31:27 <Kaide> well yeah, you'd have to put your thing in one big procedure
15:31:30 <Kaide> which is ugly
15:31:31 <avenge> wli: Octal numbers starting with 0 is pretty dumb.
15:31:37 <revenantphx> kmc: My opinion is, static typing is cumbersome at such a low level.
15:31:55 <revenantphx> weak typing is much more convenient for working in a system where everything is just strings of bytes.
15:31:58 <kmc> revenantphx, and my opinion is that it is not
15:32:02 <avenge> wli:  A couple of other things I would change, but I don't remember them off hand because I've been using nothing but haskell for months.
15:32:10 <revenantphx> kmc: well there we disagree.
15:32:13 <Kaide> I think that was the main complaint people had with imperative programming
15:32:14 <kmc> indeed
15:32:15 <kulin> fight!
15:32:24 <kulin> im with kmc, i want my language to help me write stable code
15:32:24 <kmc> revenantphx, there's lots of research into more strongly typed languages for low level systems code
15:32:24 <revenantphx> What's your case for static typing anyhow?
15:32:33 <revenantphx> kulin: C is not the language for you.
15:32:36 <Kaide> the fact that it creates situations where putting everything in one big procedures or doing stuff like explicitly unrolling loops can pay off
15:32:54 <eikke_> there's an interesting paper on systems-level stuff using haskell, but not using haskell code
15:32:55 <revenantphx> Kaide: which is why we have good compilers.
15:32:57 <Kaide> both which make code uglier
15:33:15 <Kaide> with stuff like tail call optimization you can make things look cleaner
15:33:22 <Kaide> than gotos in a big single subroutine
15:34:35 <revenantphx> well anyhow, I like C for what it does.
15:35:30 <avenge> I've worked on a lot of operatings sytems, and teach an OS class, and I haven't seen a language I'd want to use other than C for a kernel.
15:35:39 <revenantphx> and I don't see any need for it to be replaced.
15:36:00 <Veinor> a haskell kernel!
15:36:09 <Kaide> that exists
15:36:14 <monochrom> a perl kernel
15:36:21 <hpc> oh god
15:36:27 <revenantphx> oh god
15:36:31 <wli> Veinor: Other than House?
15:36:33 <Kaide> there are advantages to operating systems written in high level, type safe, memory managed languages
15:36:37 <hpc> actually, i thought the haskell kernel was prototyped in haskell, then proven correct and coded in C
15:36:38 <avenge> At some point in the next 30 years, maybe we will be formally verifying our kernels and so need a language with a stronger semantics.
15:36:38 <Veinor> monochrom: wat
15:36:43 <avenge> But a lot of research needs to happen first.
15:36:45 <eikke_> http://www.barrelfish.org/fof_plos09.pdf
15:36:50 <Kaide> if you guys get the ACM communications
15:36:51 <eikke_> was what I was looking for
15:36:57 <Kaide> you'd have seen an article about that recently
15:37:27 <blackdog> Kaide: there was also the kernel that the UNSW guys were proving
15:37:33 <eikke_> describes a DHL to describe (safety) properties of a system, which is then 'compiled' to C code, IIRC (been a while I read the paper)
15:37:53 <revenantphx> My thoughts really... are is type safety even meaningful at the kernel level?
15:37:54 <blackdog> actually, andrew baumann from barrelfish is from the KEG lab at UNSW anyway
15:38:03 <revenantphx> The processor sees everything as bytes.
15:38:10 <revenantphx> static types are a convenience to the programmer.
15:38:29 <kmc> revenantphx, your types are things like "this sequence of bytes is a valid pointer to a structure in memory with this layout"
15:38:31 <revenantphx> imo at least.
15:38:33 <avenge> revenantphx:  There are things you can do with types to improve kernel robustness, but they are not mainstream.
15:38:35 <blackdog> revenantphx: that's where they're most useful, i think. you can't afford the runtime overhead of carrying types around on your values
15:38:37 <kmc> that is the bread and butter of kernelsl
15:39:06 <eikke_> revenantphx: sure, but it allows you to make sure your code e.g. doesnt contain security-related errors, as described in that paper (process A should never be able to read pages allocated to process B, for example)
15:39:06 <revenantphx> mm
15:39:19 <revenantphx> I'm no kernel writer.
15:39:24 <revenantphx> So don't go too technical on me.
15:39:27 <revenantphx> ^_^
15:39:29 <kmc> sure "the processor sees everything as bytes" but in that case, why program in C, why not write straight machine code?
15:39:38 <avenge> eikke_: But there are things like hardware protection that can enforce this without language-level types.
15:39:40 <revenantphx> kmc: since C is a level of abstraction above
15:39:41 <revenantphx> but
15:39:44 <kmc> the point of C is to add some convenience, and static checking is a big part of that, and could be much bigger
15:39:50 <eikke_> avenge: was just an example
15:39:52 <revenantphx> the argument "then why not abstract higher" is invalid in my opinion.
15:39:56 <monochrom> you see the problem with you people. you don't know what you're talking about, and you even dare to have opinions.
15:40:01 <kmc> i'm not talking about abstracting higher
15:40:04 <revenantphx> Abstracting higher requires more complex compilers
15:40:10 <kmc> i'm talking about more static checking at the same level of abstraction
15:40:29 <revenantphx> kmc: I suppose, but then how would you handle changing between types?
15:40:42 <revenantphx> annoying toInt8() toInt16() and so on?
15:40:44 <revenantphx> It's just silly.
15:40:50 <avenge> kmc: Some kind of annotations in C, or C-like language that is statically transformed to C but has a few more checks could help.
15:40:53 <kmc> you're not really arguing anything here
15:41:05 <revenantphx> I'm saying I don't see the point of static typing in a C level language.
15:41:11 <kmc> yes, but you're not *arguing* that point
15:41:17 <kmc> you're just repeating it over and over
15:41:22 <revenantphx> It's not a point really.
15:41:22 <Kaide> blackdog: I think singularity prove that runtime types, properly implemented, can be quite cheap
15:41:30 <revenantphx> I mean, what are you saying?
15:41:31 <kmc> it's easy not to see the point of something if you haven't seen it in use
15:41:41 <avenge> revenantphx: But surely you agree that, for instance, ANSI C is less error-prone than pre-ANSI C.
15:41:42 <revenantphx> kmc: could you show me an example then?
15:41:45 <Kaide> I think they got performance comparable to linux
15:41:48 <revenantphx> avenge: of course.
15:41:49 <avenge> revenantphx: So there is demonstrably benefit to weak typing.
15:41:49 <kmc> revenantphx, http://www.galois.com/blog/2010/05/12/tech-talk-developing-good-habits-for-bare-metal-programming/
15:41:50 <blackdog> Kaide: singularity?
15:41:56 <eikke_> you could eg make sure an irq handler never performs a potentially-blocking kmalloc
15:42:01 <Kaide> blackdog: Microsoft's entirely .NET research OS
15:42:05 <revenantphx> avenge: ANSI C's allowances for void*'s made things easier imo.
15:42:14 <Kaide> blackdog: goals and design are somewhat similar to House
15:42:15 <revenantphx> heh, bare metal
15:42:18 <revenantphx> bare metal my ass.
15:42:20 <kmc> revenantphx, of course any systems language will allow some way to circumvent the type system.  so does Haskell
15:42:23 <jmcarthur> revenantphx: C's void* makes things easier because C's type system sucks so much already
15:42:24 <Zao> I prefer bear metal.
15:42:55 <revenantphx> jmcarthur: C's type system in my opinion is minimal, and I prefer that it doesn't get in my way.
15:42:57 <Kaide> I think there was also a smalltalk research OS that had decent performance
15:43:12 <bss03> @type unsafeCast
15:43:12 <hpc> bear metal: http://www.northernfire.ca/images/bear.jpg
15:43:13 <lambdabot> Not in scope: `unsafeCast'
15:43:13 <blackdog> Kaide: there's still some overhead, of course. My only (and fairly meagre) contribution to this discussion was that given a choice between no type verification and some, some is better :)
15:43:16 <Kaide> so runtime types are not neccessarily that bad if you design around them from the start and eliminate them when you can
15:43:16 <jmcarthur> revenantphx: low level programming benefits from static types because it's the only feasible way to distinguish all those low level bits and bytes in the first place
15:43:39 <jmcarthur> revenantphx: i am a professional kernel programmer, btw, and there are a few others hanging around too
15:43:47 <blackdog> Kaide: yes, it was an epsilon argument more than anything
15:43:54 <revenantphx> jmcarthur: oh, I have no doubt you know waaaaaaaay more than I do.
15:44:12 <revenantphx> And yes, I understand that point. I'm just speaking from my perspective, and I'd see static typing in C as a pain.
15:44:20 <kmc> yeah
15:44:30 <kmc> plenty of Ruby programmers talk about how they think Haskell's static typing would be a pain
15:44:35 <kmc> not knowing anything about it
15:44:39 <revenantphx> kmc: I hate ruby's type system anyhow.
15:44:43 <kmc> so perhaps if you haven't used a strongly typed systems language
15:44:47 <kmc> then you should withhold judgement
15:44:47 <revenantphx> I can't stand entirely dynamic languages.
15:44:48 <bss03> But C already does static typing, just not well.
15:44:50 <jmcarthur> yeah, C isn't a great candidate for tighter types
15:45:28 <blackdog> kmc: I'm doing my best to convince them.
15:45:40 <tolkad> If you use cabal will your code automatically be uploaded to the package database?
15:45:40 <jmcarthur> revenantphx: at least check out cyclone :) there are more "functional" ones, but cyclone is more approachable for those who already know C
15:45:50 <blackdog> kmc: they've actually been pretty open to learning about Haskell - it's more a certain amount of fear, it's still got a very academic rep
15:45:51 <tolkad> or is cabal run purely locally
15:46:01 <blackdog> tolkad: locally
15:46:03 <jmcarthur> revenantphx: here's a cool vid, too http://www.galois.com/blog/2010/08/11/tech-talk-video-developing-good-habits-for-bare-metal-programming/
15:46:07 <jmcarthur> not about cyclone
15:46:13 <revenantphx> jmcarthur: already on that page
15:46:15 <revenantphx> ;P
15:46:18 <jmcarthur> heh
15:46:27 <jmcarthur> oh, kmc linked it. didn't see that
15:46:31 <revenantphx> mm
15:46:40 <revenantphx> anyhow, I'm not arguing for weak typing in C.
15:46:51 <revenantphx> I'm just wondering why you'd think a static system would be better.
15:46:56 <avenge> Is there video, or just audio for the talk?
15:47:10 <revenantphx> video: http://vimeo.com/14069325
15:47:15 <avenge> Oh, suddenly the video popped up.
15:47:17 <Kaide> proving that something is of a certain type is useful
15:47:24 <Kaide> if you have dynamic types
15:47:28 <bss03> Static typing reduces runtime errors.
15:47:29 <Kaide> something can change its type any time
15:47:43 <jmcarthur> revenantphx: okay, let's rewind a bit and think about this for a second. how do you, as the programmer, distinguish between all the different kinds of values in the machine when you're writing low level code?
15:47:50 <kmc> revenantphx, you were arguing for weak typing in C a second ago
15:47:52 <Kaide> the most useful thing about dynamically typed languages is usually structural typing
15:48:00 <Kaide> which you can do without dynamic typing (see OCaml)
15:48:05 <revenantphx> jmcarthur: by the types I specify
15:48:15 <revenantphx> jmcarthur: whcih are just conveniences for the compiler
15:48:18 <kmc> <revenantphx> weak typing is much more convenient for working in a system where everything is just strings of bytes.
15:48:25 <kmc> <revenantphx> kmc: C's weakly typedness is wonderful imo
15:48:28 <revenantphx> kmc: thats an opinion
15:48:28 <jmcarthur> revenantphx: how are they "just conveniences for the compiler"?
15:48:43 <monochrom> <monochrom> you see the problem with you people. you don't know what you're talking about, and you even dare to have opinions.
15:48:45 <kmc> revenantphx, so it's your opinion, but you've given up on arguing it?
15:49:03 <bss03> Strong typing well, strong typing ensures that I tell the computer exactly what I mean, and that it doesn't make up crap that is wrong.
15:49:03 <jmcarthur> revenantphx: and i actually meant in your head, not in your code :P
15:49:05 <revenantphx> I'm not arguing for it.
15:49:12 <revenantphx> I just said that, and I'm wondering your response.
15:49:25 <revenantphx> I'm not trying to convince anyone, you're all much more knowledgeable than me.
15:49:32 <kmc> this is pretty frustrating
15:49:33 <revenantphx> ah, okay jmcarthur 
15:49:39 <kmc> go read about BitC, ATS, and Habit
15:49:53 <kmc> also maybe about Typed Assembly Language
15:49:58 <kmc> there's a chapter on it in ATaPL iirc
15:50:03 <jmcarthur> correct
15:50:06 <revenantphx> jmcarthur: the compiler generates errors based on incorrect types and such, but in the end, the assembly doesnt have types.
15:50:27 <blackdog> the problem is that there are no valid opinions in science, which is what we're trying to do on our better days
15:50:29 <copumpkin> revenantphx: yes, and the assembly can leave out lots of runtime checks because of them
15:50:30 <jmcarthur> revenantphx: what about in your head?
15:50:47 <revenantphx> jmcarthur: what do you mean in my head?
15:51:03 <jmcarthur> revenantphx: how do *you* distinguish between all these different formats of data?
15:51:06 <monochrom> It is American education that encourages "everyone can and should form opinions out of the blue, don't try to validate or invalidate, everyone's opinion is right, it's everyone's right".
15:51:19 <tolkad> I don't really understand all this stupid "license" stuff. if I just install a module with cabal and use it I don't have to wory about all that legal stuff right?
15:51:34 <bss03> If you are using types and the compiler sees a type mismatch it has two choices:
15:51:36 <copumpkin> well, depends what you do with it and how you link to it
15:51:38 <monochrom> And "oh BTW everyone gets an A+ this term again!"
15:51:44 <copumpkin> most haskell packages are BSD licensed
15:51:48 <revenantphx> jmcarthur: I barely do, apart from numeric and string types which have specific formats too them.
15:51:50 <tolkad> I just want to write code, not be a lawyer
15:51:52 <copumpkin> so you generally don't have to worry, but it's good to be aware
15:51:55 <jmcarthur> revenantphx: and how would you do it in the absense of types (again, in your head)?
15:52:01 <tolkad> ok
15:52:05 <bss03> a) Implicit cast / conversion; a low level language this means just using the bits even though the declared types don't match (weak typing)
15:52:07 <kmc> tolkad, if you're going to hand out binaries of your compiled code, and it links a GPL licensed library, you have to hand out source too
15:52:12 <kulin> monochrom, that's not fair
15:52:13 <revenantphx> jmcarthur: It would be very difficult.
15:52:15 <blackdog> monochrom: that's just your opinion.
15:52:18 <jmcarthur> revenantphx: actually, i accidentally turned that into a trick question
15:52:20 <Kaide> monochrom: not really
15:52:22 <monochrom> haha blackdog
15:52:25 <bss03> b) Give an error.  I prefer this, since it makes it clear I haven't told the compile what to do.
15:52:26 * blackdog could not help himself even a little bit
15:52:33 <tolkad> kmc: well that's just common politeness you don't really need a legal requirement for that
15:52:34 <revenantphx> jmcarthur: types are useful for specifying certain "formats" for strings of bytes.
15:52:35 <kmc> tolkad, if everyone who has access to binaries has access to source, that's ok.  so it's not much of a burden on "internal" projects
15:52:46 <jmcarthur> revenantphx: how would you know that you are properly expressing your intent to the compiler?
15:52:49 <revenantphx> jmcarthur: such as saying that "bytes arranged like this form X number"
15:52:50 <kmc> tolkad, no you definitely do.  people try to rip off GPL code all the time
15:52:56 <revenantphx> jmcarthur: based on the type I use?
15:52:58 <kmc> often they get away with it, sometimes they get sued
15:53:10 <kmc> tolkad, btw i'm not sure why you get angry and defensive about things you don't understand
15:53:19 <kmc> tolkad, people will be more happy to explain things if you don't call those things "stupid" first
15:53:19 <Kaide> has there been a court case in the US that set a precedent that the GPL has force?
15:53:19 <jmcarthur> revenantphx: how about constraints like "number of elements in this array" or "interrupts are disabled in this code"?
15:53:23 <revenantphx> jmcarthur: without types, it would be impossible to specify your intent with some piece of data to the compiler
15:53:32 <jmcarthur> revenantphx: surely you also keep track of things like that somehow?
15:53:33 <Kaide> or is that still nebulous?
15:53:46 <kulin> tolkad, dont worry about licenses until you distribute code you make to others
15:53:46 <eikke_> Kaide: in US not, AFAIK
15:53:48 <revenantphx> jmcarthur: nunber of elements in an array is specified when you create an array
15:53:57 <revenantphx> jmcarthur: I'm not quite sure what you're getting at here.
15:54:03 <bss03> Kaido: Yes.  There was one last year, IIRC.
15:54:10 <eikke_> kulin: code, or (more importantly) binaries
15:54:14 <kulin> ya
15:54:15 <bss03> Kaido: Though, most of the time p[eople settle out-of-court.
15:54:18 <revenantphx> jmcarthur: disabling interrupts would involve magic I don't understand with signals
15:54:20 <jmcarthur> revenantphx: but what about code that uses the array (and doesn't know where it came from)? how do you know that code doesn't access out of bounds?
15:54:28 <revenantphx> jmcarthur: you dont.
15:54:30 <kulin> tolkad, if you distribute as source, you are usually safe from all licenses
15:54:31 <jmcarthur> revenantphx: why not?
15:54:41 <revenantphx> jmcarthur: because that information is not kept track off.
15:54:44 <tolkad> kmc: Sorry, didn't mean to sound angry. I guessed that most people would think all this legal stuff is annoying
15:54:45 <jmcarthur> revenantphx: a powerful enough type system can do it
15:54:51 <revenantphx> jmcarthur: sure
15:54:54 <tolkad> it's certainly annoying to read it
15:54:56 <revenantphx> jmcarthur: But you really shouldn't be passing around mystery arrays in the first place.
15:55:00 <bss03> Kaido: Since either a) the GPL is enforcable, and you have to follow it's terms or b) the GPL is ignorable, so you fall back to default copyright in the U.S.: "You get NOTHING!"
15:55:01 <revenantphx> jmcarthur: but wait
15:55:06 <eikke_> tolkad: it protects our work... so I dont consider it annoying
15:55:06 <jmcarthur> revenantphx: and you question the utility of static types in low level programming?
15:55:12 <revenantphx> jmcarthur: wait
15:55:25 <kmc> kulin, if you distribute as source, and include third-party source which is not free software, you'll be in big trouble
15:55:28 <tolkad> eikke_: but it is hard to read
15:55:29 <revenantphx> jmcarthur: you say "more powerful", but that doesnt mean static. A compiler could keep track of lengths of arrays and such, without static types.
15:55:36 <kmc> plenty of software is provided as source but under a restrictive license
15:55:46 <jmcarthur> revenantphx: information like that *is* static types
15:55:51 <tolkad> eikke_: Every time I use a package I don't want to have to read 3 pages of legal text explaining what I'm "allowed" to do with it
15:55:53 <jmcarthur> even if merely inferred
15:56:11 <kulin> kmc well thats true, but at the risk of not going over every possible license, that is a good rule of thumb :) but i'll add "also don't give away things that cost money"
15:56:13 <kmc> tolkad, there's only a few common licenses.  you can go read *about* them, you don't have to read the text itself
15:56:19 <revenantphx> jmcarthur: explain a bit?
15:56:24 <bss03> revenantphx: If the compiler doesn't get that information from you, it's still static typing, it's just inferred static typing.
15:56:33 <eikke_> revenantphx: your a sprintf kind of guy, not snprintf?
15:56:33 <revenantphx> bss03: ah k
15:56:35 <copumpkin> revenantphx: types are a means of static reasoning about programs
15:56:36 <bss03> Haskell does type inference all the time.
15:56:39 <revenantphx> eikke_: snprintf only
15:56:44 <revenantphx> eikke_: I never use sprintf.
15:56:46 <jmcarthur> revenantphx: describe, just in very general terms, how the compiler would keep track of array lengths
15:56:59 <eikke_> tolkad: after a while you know the licenses and what they allow and how they combiine
15:57:01 <jmcarthur> revenantphx: i'm willing to bet your description will look a lot like type checking. exactly like it, in fact
15:57:25 <tolkad> eikke_: That's what's annoying... I want to be a programmer not a lawyer
15:57:29 <kulin> i think maybe 1% of people who use lgpl read and understand the license
15:57:29 <revenantphx> jmcarthur: it'd get the intitial length when you create the array, and then reassess when things like realloc are used on that arrays memory
15:57:48 <jmcarthur> revenantphx: yeah, sounds like type checking to me
15:57:52 <eikke_> tolkad: then release all your code into public domain? :)
15:58:02 <revenantphx> I think perhaps I'm a bit confused more about the definition of static typing itself.
15:58:03 <kmc> could you please take the license meta-discussion somewhere else?
15:58:09 <avenge> tokad: There are organizations like the free software foundation and open source initiative who endorse various licenses.  If something is approved by the FSF and OSI, then you don't actually have to read the license, you can trust them that it is reasonable to use for stuff you want to redistribute freely.
15:58:13 <revenantphx> I'm mixing up strong/weak with static/dynamic
15:58:14 <Kaide> bss03: is that so? I thought that you can put whatever you like on a license, but sometimes judges will rule that certain clauses are illegal. I don't think that gets rid of the whole license though. It's usually applied to situations where a license attempts to limit liability, but there was some debate over whether or not the GPL's viral nature and its prohibition of propietary enhancements was legal
15:58:27 <revenantphx> I personally like static typing over dynamic typing.
15:58:29 <kulin> yer right, everyone back to static typing battle!
15:58:31 <jmcarthur> static just means it's compile time
15:58:42 <revenantphx> jmcarthur: right, thats where I'm mixed up, thats fine and good
15:58:50 <revenantphx> jmcarthur: what I don't like is overly strong typing.
15:59:07 <Twey> Is dependent typing static or dynamic?  Doesn't it occur both at compile-time and at runtime?
15:59:12 <jmcarthur> can't you explain why?
15:59:12 <kmc> "overly strong"?
15:59:24 <kmc> perhaps what you dislike is overly *cumbersome* typing
15:59:26 <kmc> C++ and Java
15:59:28 <revenantphx> kmc: I don't like having to explicitly change types.
15:59:30 <kmc> right
15:59:36 <jmcarthur> revenantphx: okay, consider this... let's go back to the array length checking
15:59:37 <revenantphx> kmc: casting is convenient and easy
15:59:50 <kulin> casting is explicitly changing types without any compile time check
15:59:51 <revenantphx> jmcarthur: sure.
15:59:56 <kulin> its the worst possible example
16:00:11 <kulin> thats why static_cast exists
16:00:11 <revenantphx> One moment
16:00:13 <tolkad> kulin: you mean unsafeCoerce?
16:00:14 <revenantphx> I have to go for a bit.
16:00:16 <jmcarthur> revenantphx: if the compiler statically discovers that an array access goes out of bounds, would you prefer that the compiler just shut up instead of report that to you?
16:00:21 <kulin> coerce is different from casting
16:00:46 <eikke_> kulin: I think he means getting some data from e.g. a hardware device in some buffer, then cast this void * to my_struct * and access the fields?
16:00:48 <avenge> kulin:  How?
16:00:57 <revenantphx> jmcarthur: no, i'd like it to say so
16:00:59 <revenantphx> hey, I'm sorry
16:01:00 <jmcarthur> revenantphx: or perhaps you would prefer that it just insert some code to shift your array accesses around if they go out of bounds?
16:01:11 <revenantphx> jmcarthur: definitely not
16:01:11 <Philonous> What am I doing wrong when ghci answes type queries with "failed to load interface for <Packagename>" though it runs/compiles the code using it just fine?
16:01:13 <revenantphx> I have family insisting on going on some expedition
16:01:22 <revenantphx> Can we talk about this when I get back jmcarthur?
16:01:25 <revenantphx> I'd really like to continue.
16:01:35 <jmcarthur> revenantphx: strong type systems are the discipline that prevents the compiler from hiding such type errors, basically
16:01:48 <jmcarthur> sure
16:01:50 <Kaide> Twey: I think you can do some of it at compile time if you can prove that the pre and post conditions can always be met, just that with a language that isn't total it is non-deterministic because you can make the compiler halt
16:02:03 <Kaide> err
16:02:05 <Kaide> undecidable
16:02:08 <Kaide> not non-deterministic
16:02:41 <Kaide> it ends up becoming the same problem as proving two expressions are equal
16:02:48 <monochrom> all dependent type systems I know are checked statically and no runtime check. but you could imagine runtime dependent type: if you check array indexes at runtime, you could say "runtime dependent-typed array!"
16:03:10 <kulin> avenge: coercion is implicit, casting is explicit, coercion is like int x = 1; float y = x;
16:03:47 <blackdog> poor guy. I don't think he was really expecting the stacks-on.
16:04:04 <copumpkin> monochrom: lol
16:04:21 <aavogt> kulin: is typeclass resolution coercion?
16:04:59 <kulin> ill admit im not sure, i only know the terminology with respect to c
16:05:22 <monochrom> "coercion" and "cast" vary among authors
16:06:28 <monochrom> authors of the C standards and authors of PL papers may very well have them swapped w.r.t. each other.
16:07:26 <monochrom> don't expect "standard terminology". people can't even agree on whether 0 is a natural number or not.
16:08:17 <kulin> monochrom, i agree, but i think in this case, coercion and cast are pretty well defined for c
16:08:22 <copumpkin> monochrom: IT TOTALLY IS DAMMIT
16:08:42 <monochrom> Yes, the C standard defines them one way.
16:09:37 <monochrom> Please excuse me. I should have lurked. I forgot to check context.
16:09:38 <Kaide> I like the N^0 vs N notation better than N^+0 N^-0
16:12:24 <monochrom> ♥ copumpkin. copumpkin brightens me up when the channel depresses me.
16:15:16 <bss03> Kaide: Striking single clauses is not always possible.
16:15:41 <bss03> Kaide: Normally when a contract wants to allow that, it will have a specific provision for that.
16:15:49 <solidsnack> This is an interesting post: http://www.codexon.com/posts/debunking-the-erlang-and-haskell-hype-for-servers
16:15:53 <bss03> Kaide: I think they normally call it "Separation of Terms".
16:16:07 <Kaide> I do think there is a precedent for it though where limitations of liabilities were considered void with the rest of the license still enforced
16:16:09 <copumpkin> :)
16:16:33 <solidsnack> The comments are revealing; it's actually not that hard to get high performance with Haskell if you avoid some obvious performance problems.
16:16:50 <Saizan> yeah, that debunking got debunked :)
16:17:38 <bss03> Kaide: This is about Europe, but FYI: http://www.groklaw.net/articlebasic.php?story=20100403103524185
16:17:46 <Kaide> if you make a claim that python is more efficient than haskell it's probably good to immediately be suspicious
16:18:01 <Veinor> yeah
16:18:31 <solidsnack> "Don, we’ve been over this before, and this is the last time I am going to say it. When bytestring stops being experimental..." LOL
16:18:37 <Kaide> bss03: that court decision makes a lot of sense actually
16:18:58 <Veinor> solidsnack: wat
16:19:31 <Kaide> bss03: basically, you can have a situation where the GPL can not force people to share their code, which is what was suspected to be illegal, but make them infringe when they don't anyway
16:19:48 <Kaide> I think I agree with that synopsis
16:19:58 * Twey has always wondered what the GPL does legally if you write your program directly in machine code
16:20:57 <danderson> not much, then again you're probably in the loony bin anyway and thus unable to respond to emails requesting source code
16:21:51 <bss03> Twey: Not much.  Although the GPLv3 does state that the source code is the "preferred form for modification" not whatever you, the author, want to label source code.
16:22:41 <hpc> GPL code in a homebrew language
16:22:42 <bss03> But, for some things writing the raw machine code might actually be preferred, in that case the source and the binary are the same thing and the GPLv3 is generally automatically satisfied, assuming the distributor doesn't obfuscate the code further.
16:22:43 <hpc> :P
16:23:09 <Twey> Interesting.
16:23:28 <Twey> But then, in a court case, how can the prosecutor prove that your code was machine-compiled and that you didn't just write it by hand?
16:23:37 <bss03> This is an older one in U.S. courts, but it didn't actually touch on the GPL's enforcability, just the standing of one of the parties: http://www.groklaw.net/article.php?story=20060320201540127
16:24:22 <bss03> Eben says he "enforces" the GPL all the time: http://www.gnu.org/philosophy/enforcing-gpl.html
16:24:49 <bss03> Twey: I'm not sure they can, and it might depend on the judge, plus expert witnesses and stuff.
16:25:51 <bss03> Twey: I think, most likely, the judge is going to side with the original author on the reasoning that the original author did modifications themselves throughout the development prior to release.
16:26:37 <bss03> Twey: The judge would likely assume you are telling the truth about how you modifiy it, unless there is *compelling* evidence otherwise.  E.g. the "signature" of a compiler / translator in the binaries you provide.
16:27:26 <dankna> well, actually, hand-written assembly is dramatically different from compiler-generated assembly.  it's a lot less uniform in calling conventions and that sort of thing.
16:27:47 <Twey> It doesn't *have* to be
16:27:50 <dankna> granted
16:28:25 <Twey> Sure, there are a few optimisations that it would be wildly difficult for a human to implement by hand, but you could just turn those off
16:28:54 <dankna> but that's the opposite obfuscation to what a would-be violator would have to do
16:29:14 <dankna> wait, no, I confused myself
16:29:21 <Twey> Indeed :þ
16:30:13 <kulin> reasonable doubt is a factor is it not?
16:30:19 <Philonous> What am I doing wrong when ghci answes type queries with "failed to load interface for <Packagename>" though it runs/compiles the code that is using it just fine?
16:30:26 <Twey> A highly flexible factor
16:31:17 <bss03> kulin: Reasonable doubt is a matter in criminal cases.  "Meh, Probably" is more the standard in civil cases.
16:31:27 <kulin> oh
16:31:27 <Twey> Heh.
16:32:12 <kulin> honestly though, first someone would have to care about your code, and I don't see that being an issue until you have lawyers anyways :)
16:33:54 <handonson> is the gtk package installable in cabal?
16:34:03 <kmc> someone should make a game like pokémon
16:34:07 <kmc> where you capture and train lawyers
16:34:09 <kmc> and make them fight in court
16:34:23 <kmc> handonson, as of recently
16:34:27 <Twey> Haha
16:34:29 <kmc> install gtk2hs-buildtools first
16:34:48 <Walt> kmc, that is, an awesome idea
16:34:52 <Walt> I might even pick it up
16:34:56 <kmc> go for it
16:35:12 <Walt> the fight sequence of pokemon is easy to implement, and I mean, how much does the capturing have to be
16:35:15 <kulin> make sure you credit kmc or the irony could be delicious
16:35:30 <Walt> everyone just wants to fight anyway
16:35:30 * Twey laughs.
16:35:31 * hackagebot hledger-lib 0.12 - Core types and utilities for working with hledger (or c++ ledger) data.  http://hackage.haskell.org/package/hledger-lib-0.12 (SimonMichael)
16:35:33 <Walt> huhu
16:35:33 * hackagebot hledger 0.12 - A command-line (or curses or web-based) double-entry accounting tool.  http://hackage.haskell.org/package/hledger-0.12 (SimonMichael)
16:35:48 <Twey> Cool
16:36:43 <dankna> highly amusing concept
16:37:52 <kmc> om nom irony
16:38:39 <dmwit> What is up dudes and dudettes!
16:41:20 <handonson> hey, i think there should be Graphics.Drawing (along with Graphics.Rendering) and many graphics packages including gloss, drawingcombinators, hieroglyph, etc. should go into it
16:41:22 <lispy> dmwit: just learning some agda
16:42:11 <handonson> so Graphics.Rendering will contain more technical and rendering-engine-level packages while Graphics.Drawing will be for higher-level and more user-friendly drawing tools
16:42:25 <dankna> that makes a lot of sense to me
16:42:46 <dmwit> lispy: Oh, fun.
16:42:58 <dmwit> You've been pushing at the boundaries of Haskell's type system for a while now, eh?
16:44:38 <McManiaC> dons: ping
16:45:08 <dons> pong
16:45:12 <dons> quick. i'm not really here
16:45:48 <dons> ... tick ... tock ...
16:45:49 <copumpkin> dmwit: have you tried it?
16:45:54 <copumpkin> he has a bomb!
16:45:55 <McManiaC> dons: just curious if you have extended your shell lib from http://cgi.cse.unsw.edu.au/~dons/blog/2007/03
16:45:56 <copumpkin> stop him!
16:46:10 <dmwit> Only very, very briefly.
16:46:10 <McManiaC> or if youre still using something like this
16:46:15 <dons> nope, haven't extended it. just a sketch i use for a few programs. go for it if you want to library-ize the approach
16:46:21 * monochrom puts dons on a rocket of speed 0.99c to extend his stay
16:46:24 <dons> i use it as a skeleton fairly often
16:46:30 <McManiaC> dons: kk :)
16:46:39 * dons -> sucked into a wormhole.
16:46:45 <McManiaC> RIP
16:47:21 <monochrom> dons will go through the wormhole and emerge in the perl community
16:47:51 <McManiaC> http://n-sch.de/hdocs/hscript/System-Shell.html :>
16:48:09 <handonson> so that's why it's called wormhole, as a worm is a type of ... bug ...
16:48:50 <monochrom> lengthy bug which, if you cut it, it divides into two bugs.
16:49:58 <monochrom> best thing since amoeba, which divides into two bugs anyway
16:51:12 * Twey wonders why Americans in this modern and enlightened age write $ not S, but c not ¢
16:51:34 <copumpkin> ease of typing on your average keyboard, I'd guess
16:51:35 <avenge> Because ASCII is still king.
16:51:49 <bss03> Best document about GPL enforcement I can find, (pdf): http://www.pillsburylaw.com/siteFiles/Publications/A9A22185D029BBE6EAA4332F1A7249E2.pdf
16:52:01 <monochrom> because just before this modern and enlightened age, they had $ but no ¢ on their 1970s keyboards
16:52:01 <copumpkin> ¢ is harder to type than $ :)
16:52:21 <Twey> Well, that's rather begging the question, isn't it
16:52:35 <bss03> "
16:52:37 <bss03> U.S. and German courts have rendered
16:52:38 <bss03> decisions acknowledging the enforceability of the GPL.
16:52:40 <bss03> "
16:52:57 <monochrom> actually I recall seeing ¢ on a 1960s typewriter
16:53:10 <dmwit> $0.60 <- this is why
16:53:16 <Twey> We Englishers have £ keys on our keyboards; all the Europeans have a € key; the Japanese have a ¥ key… you should get in on the act
16:53:32 <Twey> dmwit: You never write just ‘60¢’?
16:53:36 <dmwit> no
16:53:39 <dmwit> Not even in handwriting.
16:53:41 <Twey> Huh.
16:53:44 <monochrom> Americans are obnoxiously egocentric.
16:54:05 <Twey> (and yeah, ¢ existed in many pre-ASCII charsets)
16:54:15 <monochrom> anyway, 0.99c means 0.99 times the speed of light, not 0.99 cents.
16:54:26 <Twey> Heh.
16:54:34 <dmwit> If you want a real question, ask why people don't write 0.60$ instead.
16:54:49 <Twey> Why not?
16:54:49 <monochrom> (wouldn't be prudent to put dons on a 0.99-cent rocket, would it?)
16:54:52 <Twey> Some people do.
16:54:52 <DanielDiaz> My keyboard has this key: ñ
16:55:17 <Twey> DanielDiaz: That's very nice.  ☺
16:55:48 <DanielDiaz> hehe, english keyboard is so different!
16:59:55 <DanielDiaz> I've written a very little package with functions for interact with the Windows Clipboard easily (based on Win32), in principle for personal use. But I don't know if I should upload it.
17:00:19 <Twey> Sure you should.
17:01:20 <DanielDiaz> Twey: ok
17:01:38 <Twey> Does no harm
17:01:46 <Twey> I don't think the Hackage folks lack for disk space :þ
17:02:37 <Adamant> monochrom: and Chinese put Americans to shame for xenophobia and culture-centric thinking
17:04:22 <monochrom> except the Chinese don't rule the world yet, so it doesn't affect the whole world that much
17:04:36 <Adamant> what makes you think the US rules the world?
17:06:44 <Adamant> there's a difference between first among equals and having disproportionate influence, and actually running shit whether other people like it or not.
17:07:29 <solidsnack> Adamant: Well, the US may not "rule the world" but we do have rather greater influence culturally than the Chinese.
17:07:53 <Adamant> solidsnack: right, but you even have to qualify it down to "culturally" at this point
17:08:00 <solidsnack> Yes.
17:08:19 <dmwit> U. S. A! U. S. A!
17:08:41 <solidsnack> We also have greater influence monetarily, linguistically, technologically, militarily...
17:09:07 <Adamant> solidsnack: but, at this point, economically, it's pretty close
17:09:14 <Adamant> most of the rest flows from that
17:09:17 <solidsnack> So weird, I wonder who have came up with the different "ally" and "ily" endings which mean the same things.
17:09:28 <solidsnack> Everyone speaks English.
17:09:31 <solidsnack> Even the Chinese.
17:10:03 <Philonous> Sometimes even the English
17:10:05 <Adamant> solidsnack: "everyone" knows some English. "speaking" it is stretching it.
17:10:22 <solidsnack> Hmm, well...
17:10:27 <solidsnack> Okay.
17:10:33 <solidsnack> With Chinese, what can you say?
17:10:36 <kulin> Philonous, :)
17:10:50 <Adamant> solidsnack: everyone buys their stuff?
17:11:12 <solidsnack> Sure.
17:11:17 <solidsnack> So that makes them powerful?
17:11:22 <kulin> who cares?
17:11:29 <solidsnack> You don't get to dictate terms when you need people's money.
17:11:46 <Adamant> solidsnack: where do you think the technological and military superiority came from?
17:11:58 <solidsnack> Buying the stuff.
17:12:08 <Adamant> solidsnack: having a solid economy.
17:12:11 <solidsnack> Domestic demand and efficiency.
17:12:16 <solidsnack> The Chinese don't have that.
17:12:29 <solidsnack> They got enslaved by the West and have to sell all their stuff.
17:12:36 <Adamant> um.
17:12:40 <dmwit> kulin++
17:12:54 <djahandarie> I have no idea what is going on here but it seems extremely off-topic
17:13:05 <solidsnack> Uhm, yes,.
17:13:05 <Adamant> I don't know that kulin is right, but he is right that it's not-haskell
17:13:28 <kulin> i know that im right, also its is clear that you all forgot about poland
17:13:41 <Adamant> the Poles and Dr. Dre
17:13:46 <Adamant> everyone forgets about them
17:13:46 <solidsnack> Let's discuss this in #haskell-blah.
17:19:29 <JuanDaugherty> some English training is required in Chinese schools I believe from elementary level up
17:20:01 <JuanDaugherty> (sent b4 seeing topic remonstrance)
17:20:48 <JuanDaugherty> anybody know of any pkgs coded in Hanzi or if it's even possible with current ghc?
17:21:07 <handonson> no and yes
17:21:16 <JuanDaugherty> guess there'd have to be a mapping
17:21:27 <McManiaC> ghc supports utf8
17:21:36 <dankna> actually
17:21:39 <handonson> the current ghc handles unicode identifiers
17:21:49 <dankna> what does it do about the lowercase-uppercase thing for characters that don't have case?
17:21:59 <JuanDaugherty> of all the English names to make it work naturally in chinese
17:22:08 <dankna> I remember discovering that uppercase delta looks like a type name to it and therefore can't be used as a variable name
17:22:24 <JuanDaugherty> i'd just want it to work 1-way into chinese
17:22:34 <dankna> hm
17:23:06 <JuanDaugherty> in principle there could be a back mapping to pinyin but that seems ugly
17:23:15 <handonson> dankna: it seems you can't name a data constructor in CJK, for example.
17:23:27 <dankna> handson: that was what I suspected.  unfortunate.
17:23:32 <dankna> *handonson
17:23:40 <handonson> unfortunate, agreed
17:24:34 <handonson> one may argue that depending on the case-of-first-letter wasn't a good design choice
17:25:11 <handonson> as other languages seem to have no problem without such restriction.
17:25:19 * dankna nods
17:25:24 <Zao> One may take the ugly pseudo-hungarian way of bindings-DSL and use  C'ASDF for classes and c'ASDF for functions
17:25:25 <kmc> define "no problem"
17:25:26 <dankna> I do think that, in fact, yeah
17:25:38 <kmc> Haskell has lots of things not found in other languages
17:25:51 <Zao> handonson: I'd say that a lot of code would be a lot more inconvenient then.
17:26:00 <Zao> Separate namespaces are quite nice.
17:26:06 <dankna> Zao's suggestion is probably good enough for the near future
17:26:09 <arw> kmc: "no problem" as in "no longer requiring it wouldn't really break anything"?
17:26:33 <kmc> i like the distinction
17:27:02 <Zao> If you see a name you've never seen before in docs or code, you can infer some meaning.
17:27:08 <kmc> but my point was that saying "other languages do fine without it" is not a valid argument against a Haskell feature
17:27:12 <handonson> i agree that classes and data constructors may require separate namespace, but why uppercase? for (a bad) example, some languages use sigils
17:27:16 <kmc> it being explicitly a research language
17:27:21 <kmc> and not the intersection of Java and PHP
17:27:44 <dmwit> I'm not sure the case restriction is really a feature.
17:27:55 <dmwit> Could uses be disambiguated without that restriction?
17:28:10 <handonson> using sigils, for example, won't cause unfortunate situations like data constructors can't be defined in CJK while functions can.
17:28:10 <dmwit> I guess the problem would be in type signatures.
17:28:19 <kmc> disambiguated for the programmer?
17:28:23 <dmwit> no
17:28:26 <dmwit> for the compiler
17:28:28 <kmc> oh
17:28:36 <kmc> but that's not what the distinction is for
17:28:39 <siracusa> Do TVars have any advantages over MVars when being in the IO monad?
17:28:44 <dmwit> ah
17:28:48 <monochrom> Haskell has type expressions like a->a, a->Int, Int->a, Int->Int. There are type variables. It's easy for you to say "C doesn't need uppercase type names" but then C doesn't have type variables.
17:28:50 <dmwit> siracusa: They are for different things...
17:29:07 <kmc> you could just say that every unbound name is a type variable, and the compiler is perfectly happy, but it will be hell for the programmer
17:29:14 <siracusa> dmwit: Where can I read about both?
17:29:16 <kmc> slightly more reasonable, you could require explicit ∀
17:29:22 <handonson> seems nobody reads me. :(
17:29:23 <kmc> siracusa, Real World Haskell and the API docs
17:29:40 <monochrom> No, nobody reads *me*
17:29:52 <dmwit> siracusa: Google "STM" or "software transactional memory" for TVars, and read The Awkward Squad for MVars, I believe.
17:29:53 <handonson> monochrom: sigils?
17:30:01 <kmc> siracusa, TVar have this transactional property, meaning you can glue together multiple TVar operations and demand that they occur in an all-or-nothing instantaneous way
17:30:04 <hpc> handonson: having used perl, and occasionally enjoying it, i can say sigils are not a good language feature
17:30:05 <monochrom> Anyway, SML goes with 'a->'a, 'a->int, etc.
17:30:23 <kmc> siracusa, if you don't do such gluing, but rather pass each individual TVar access to "atomically", then you don't gain anything over MVar
17:30:27 <kmc> and i believe incur more overhead
17:30:30 <kmc> though you should profile
17:30:47 * hackagebot Clipboard 1.0.0 - Access to the Windows Clipboard.  http://hackage.haskell.org/package/Clipboard-1.0.0 (DanielDiaz)
17:30:48 <handonson> hpc: me neither, but my personal opinion is that sigils are at least better than case distinction
17:31:06 <handonson> it's actually even more visible than case distinction
17:31:17 <arw> i sometimes find the case distinction awkward.
17:31:35 <kulin> for what it is worth, i like case distinction because it sets a standard, without it, it would be unclear what people should do
17:31:45 <arw> but then my native language puts a much greater emphasis on case then english.
17:32:09 <hpc> it's nice as a convention
17:32:18 <Pseudonym> English only retains cases for pronouns, generally.
17:32:35 <hpc> the language should be capable of detecting functions and constructors without it
17:32:42 <kulin> ya
17:32:43 <pikhq> Except in moderately archaic English, where nouns get upper case.
17:32:53 <kulin> sounds like perfect ground for an extension
17:33:09 <monochrom> perl is sigil overuse. like why would a number variable and a list variable have different sigils.
17:33:23 <handonson> perl's not a good example
17:33:24 <hpc> it would be a contagious extension
17:33:35 <monochrom> But SML's 'a->'a is just fine
17:33:39 <arw> monochrom: because you can have $a and @a in the same namespace.
17:33:42 <Zao> monochrom: To be honest, there's just around 3 of them.
17:33:43 <hpc> if your exports violate the convention
17:33:44 <blackdog> i suppose if you think of those things as being as different as values and data constructors, it makes sense
17:33:53 <Pseudonym> Perl sigils make historical sense.
17:33:59 <Zao> (ignoring typeglobs, filehandles and other sillyness)
17:33:59 <kulin> hpc, true
17:34:03 <Pseudonym> When you consider that it's descended from shell scripting and awk.
17:34:21 <tensorpudding> That doesn't mean it's a good thing to have in a programming language though
17:34:36 <Pseudonym> Depends on the programming.
17:34:37 <Zao> They tend to help guide the reader to what the type of something is, which is quite nice.
17:34:49 <Zao> Especially in a world that normally only has strings.
17:34:51 <hpc> it also has a wonderful side effect in strings
17:34:53 <Pseudonym> If what you need is a much better ksh/awk, then it's not necessarily a bad tradeoff.
17:34:58 <hpc> "foo: $foo", etc
17:35:05 * Zao interpolates hpc 
17:35:19 <tensorpudding> is that what people use perl for, is just a shell replacement?
17:35:34 <hpc> tensorpudding: it's what people /should/ use it for
17:35:35 <blackh1> width = ... :: Integral a => a  -- Why does this still get morphed by the monomorphism restriction, even though I have a type signature?
17:35:43 <Pseudonym> It's what it was designed for.
17:35:47 <Pseudonym> Would you rather use Perl or expect?
17:35:51 <tensorpudding> the fact that it can do much more means that people will use it for much more
17:36:00 <arw> tensorpudding: often, yes. its a much saner way to program than shellskripts.
17:36:33 <Pseudonym> Shell scripts don't give you anything like exceptions, for example.
17:36:37 <hpc> the one thing i would change is to treat non-perl barewords as shell commands
17:36:51 <shachaf> blackh1: Because that's how the monomorphism restriction works.
17:36:57 <hpc> $foo = ls -l
17:37:01 <hpc> for example
17:37:03 <monochrom> blackh1: you have to give the type signature separately. width :: Integral a => a
17:37:09 <arw> Pseudonym: forget exceptions. something as "simple" as correct quoting is a nightmare in shellskript.
17:37:14 <shachaf> "5" is also of the type (Num a) => a, but x = 5 is still restricted.
17:37:16 <Pseudonym> Right.
17:37:20 <monochrom> (for the purpose of overriding the restriction anyway)
17:38:02 <blackh1> monochrom: Oh - thanks. Shachaf: Thanks, Seagull!
17:38:30 <handonson> okay, there are two different issues: "do we need to distinguish classes/data constructors/types and functions/type variables?" and "if we do, do we really need to use 'Bool' for it, instead of '@bool'?"
17:38:46 <Pseudonym> Perl is meant to be duct tape.  It's what you use when you have a bunch of "real" stuff that needs to be stuck together with a very thin layer.
17:39:19 <pantsd_home> So if I've got a parsec parser giving back a bunch of strings, but I want to put them into a datatype with ByteStrings is there a way to avoid doing B.pack on all the results and just have the strings autoconvert?
17:39:21 <handonson> for the former, i don't really have any personal opinion, but for the latter, i do think case distinction is awkward
17:40:01 <Pseudonym> handonson: We do need to distinguish between data constructors and variables somehow.
17:40:09 <Twey> hpc: Ick
17:40:10 <Pseudonym> And between type variables and type constructors.
17:40:24 <handonson> you mean for compilers?
17:40:33 <handonson> or for programmers?
17:40:38 <Pseudonym> For meaning.
17:40:39 <Twey> hpc: Given that Perl grammar is undecidable already, do you really want to try to work out what is or is not a ‘non-Perl bareword’?  :þ
17:40:42 <Pseudonym> f True
17:40:43 <Pseudonym> f true
17:40:50 <hpc> hahahaha
17:40:52 <Pseudonym> These cases need to be distinguished somehow.
17:41:00 <arw> a compromise could be "allow either case or a sigil for the distinction". that way you can keep the old caps convention while also allowing different languages like mandarin.
17:41:13 <Pseudonym> Perhaps they don't need to be distinguished in the lexical syntax.
17:41:14 <Twey> Well, you can do that
17:41:42 <Twey> Let's conventionally assign the sigil ‘T’ for types…
17:41:53 <Pseudonym> <Twey> Let's conventionally assign the sigil a@XTa@Y for typesa@|
17:42:00 <Twey> Heh
17:42:07 <kulin> arw, personally i prefer there to be as few ways to do one thing as possible
17:42:16 <monochrom> {-# LANGUAGE TypeDirectedSigilInference #-}
17:42:17 <handonson> Pseudonym: switch to UTF-8 today.
17:42:28 <Twey> data Tデーター = Cフー | Cバー
17:42:36 <dmwit> Pseudonym: a@X was `, a@Y was ', and a@| was ... (though each one a bit prettier).
17:42:48 <Pseudonym> handonson: You open up my firewall so I don't have to ssh to another machine to IRC, and I'll switch to UTF-8.
17:42:54 <Zao> Something that's even worse than using arbitrary codepoints in source is how to handle RTL mixing.
17:42:58 <monochrom> oh we should use unicode sigils anyway
17:42:58 <Twey> Pseudonym: You can use UTF-8 across SSH
17:42:59 <handonson> case distinction also leads to some ugly consequences like gLOBAL_VALUE
17:43:13 <Twey> handonson: Nah, that's just misappropriation of a foreign convention
17:43:24 <handonson> especially for those libraries using FFI to include external libraries
17:43:29 <Zao> c'GLOBAL_VALUE
17:43:31 <Twey> Still
17:43:38 <arw> kulin: yes, but the world doesn't work that way. nobody will start to program in english at school, just because there are no caps in their mother tongue or something.
17:43:40 <djahandarie> data Tdata = Cfuu | Cbaa?
17:43:41 <Twey> The correct way to render CONSTANT_VALUE is constantValue
17:43:45 <Twey> Everything's a constant anyway
17:43:48 <Twey> djahandarie: *nod*
17:43:57 <hpc> Twey: took the words out of my mouth
17:44:01 <Twey> arw: Yes.  Yes they will.
17:44:06 <kulin> arw, i certainly agree that there is a problem, but if i had to chose, i would chose to just use sigils 100% of the time
17:44:08 <Twey> arw: More's the pity.
17:44:11 <Zao> Twey: Except if someone else also has a constantValue() function.
17:44:22 <Twey> Zao: That's what modules are for
17:44:23 <hpc> also, i hereby term that "UGLYCASE" in the form of camelCase, etc
17:44:33 <Pseudonym> Perhaps more to the point, using upped and lower case is close to mathematician syntax.
17:44:36 <dmwit> whoa, hackage switched to a new haddock or something
17:44:40 <Zao> Twey: I'm talking about the same library you FFI.
17:44:43 <djahandarie> dmwit, yep
17:44:44 <Twey> dmwit: Just a new style
17:44:55 <Twey> Zao: You don't have to import them with the same names
17:44:57 <Zao> At least if you try to mimic the layout somewhat.
17:44:58 <arw> Pseudonym: depends on the field.
17:44:59 <Pseudonym> "Let small lower-case Greek letters be variables, let upper-case Roman letters starting at P be boolean statements..."
17:45:09 <Zao> Twey: Then it's not much of a binding and more of a port, I'd say.
17:45:13 <monochrom> data ♥Whee ♯a = ☺Case1 ♯a (♥Whee ♯a) | ☺Case2 ♯a ♯a (♥Whee ♯a) | ☺Nil deriving ☃Show
17:45:23 <Zao> A binding in my (and -DSL) world is a mechanical 1:1 mapping.
17:45:26 <arw> Pseudonym: i know upper-case to be vectors, lower-case to be scalars :)
17:45:30 <dmwit> Twey: How should things imported from the FFI that are upper-case abbreviations look? I would say, e.g., xF86XK_blah is still uglier than XF86XK_blah.
17:45:32 <hpc> O.O monochrom
17:45:32 <Twey> Zao: Disagree — all you have to do is give them more unique names.  It's still a one-to-one binding.
17:45:49 <Zao> Twey: There's nothing worse than a binding that renames and reshuffles things, imo.
17:45:54 <Pseudonym> Alphabet-based implicit type systems are ubiquitous in mathematics.
17:46:00 <handonson> wait, how are Cyril and Greek letters handled with regards to case distinction?
17:46:03 <Twey> dmwit: I'd say you should have a module XF86XK and bind the name as ‘blah’
17:46:05 <Zao> Tends to ruin the use of native docs.
17:46:07 <Pseudonym> And FWIW, Prolog did it first, only with the opposite convention.
17:46:17 <Twey> Zao: Disagree, so long as it does so in a consistent manner
17:46:30 <Zao> Twey: Which only would be consistent inside that binding.
17:46:32 <Pseudonym> One thing I don't like about ML is that type variables and program variables use a different syntax.
17:46:38 <Twey> Zao: That's all it needs
17:46:47 <monochrom> Fortran did it first with "God is real unless declared integer"
17:46:54 <tensorpudding> How do you alphabetically sort unicode anyway?
17:46:54 <Zao> Using stuff like SlimDX drives me insane, as the native docs are unusable unless you dig through the source.
17:46:55 <arw> Pseudonym: they are ubiquitous in the form of a ton of conventions. but for anything serious, there will always be a formal definition or declaration.
17:47:14 <Twey> tensorpudding: With great difficulty and much attention paid to locale settings
17:47:18 <Zao> tensorpudding: That's more a question of locale, I'd say.
17:47:26 <tensorpudding> I'm sure that locale is important.
17:47:28 <Zao> Lots of primary/secondary/ternary sort keys and deep magic.
17:47:32 <tensorpudding> But one locale won't handle them all.
17:47:41 <Pseudonym> arw: All good papers will declare the lexical syntax somewhere.
17:47:43 <Zao> Said keys get assigned by locales, and defaulted otherwise or something.
17:47:48 <Zao> It's all in the fine Standard somewhere.
17:48:01 <Pseudonym> But they'll still say that lower-case Greek letters starting at alpha mean this, and starting at rho mean this.
17:48:03 <handonson> you know, we can have all crazy ways of case distinction in CJK... you can define that Kanjis are uppercase and Kanas are lowercase in Japanese
17:48:19 <Twey> handonson: Not a bad idea
17:48:28 <arw> Pseudonym: exactly. but there is no common convention for all of mathematics.
17:48:33 <Pseudonym> Right.
17:48:38 <Pseudonym> I agree.
17:48:50 <handonson> you may set that letters with batchim are uppercase and letters without batchim are lowercase in Korean
17:49:00 <Twey> Fortis?
17:49:09 <Pseudonym> My point is that "using this alphabet means this type" is an idea that mathematicians implicitly understand.
17:49:52 <drbean> handonson: What's batchim in Korean?
17:49:53 <Pseudonym> So the Prolog rule "starting with a lower case letter means a functor or constant, starting with an upper-case letter means a variable" is something that mathematicians can handle.
17:50:04 <Pseudonym> Haskell, of course, uses the opposite convention, lucky us.
17:50:19 <Pseudonym> For good reason. :-)
17:50:22 <handonson> drbean: can you see the difference between 가 and 각
17:50:41 <drbean> handonson: Yes
17:50:45 <handonson> in Hangul, the Korean alphabet, you compose each syllable with consonants and vowels
17:50:46 <arw> hm, rectangle and rectangle :)
17:51:01 <Pseudonym> In first-order predicate calculus, there are generally more predicates and functions than variables.  In lambda calculus, the opposite is true.
17:51:11 <kw317> I'm trying to use regular-xmlpickler ad I'm getting the Overlapping instances for Generics.Regular.XmlPickler.Function.GXmlPickler (K String) arising from a use of `gxpickle' at spong.lhs:100-14-21 error
17:51:16 <monochrom> "an infinite supply of Greek identifiers starting with α are type variables" this means α, α0, α1, α3435, α5141, α6174...
17:51:17 <drbean> Batchim is the consonant at the end of the syllable?
17:51:18 <handonson> syllables that ends with consonants have something at the bottom
17:51:23 <handonson> yeap
17:51:27 <kw317> have anyone seen this before?
17:51:58 <handonson> naturally, syllables that end with vowels don't have any batchim
17:52:50 <handonson> but this is getting more and more -blahhy. i'll stop here. :)
17:53:31 <handonson> arw: install a good unicode font today for your better computing life. :)
17:54:08 <arw> handonson: i've installed the best i could find. unfortunately without korean glyphs as it seems.
17:54:38 <monochrom> "an infinite supply of Unicode identifiers starting with rectangle are value variables..."
17:56:20 <monochrom> apt-get install ttf-unfonts-core  (current ubuntu fresh install has it)
17:56:20 <handonson> ㅁ口ロ□...
17:57:25 <handonson> ttf-unfonts has been there even before the hoary hedgehog, should be in any non-ancient ubuntu
17:58:57 <arw> current debian stable doesn't have it or calls it differently i guess.
17:59:27 <Kaide> 3141 0000 ロ 25A1
17:59:42 <Kaide> guess I need to pick a different font
17:59:47 <arw> currently i use -efont-fixed-medium-r-*-*-16-*-*-*-*-*-iso10646-*
18:00:08 <Kaide> unless that was supposed to be UTF32 or something
18:00:08 <arw> the others either had too few glyphs or unreadable latin ones.
18:00:39 <arw> Kaide: wwwcip.cs.fau.de/~snalwuer/UTF-8-demo.txt is nice for trying out fonts.
18:01:07 <Kaide> I'll bookmark then
18:02:11 <revenantphx> jmcarthur: Hey, I'm back.
18:02:23 <revenantphx> jmcarthur: I was thinking about it ,and I think I just had a lot of stuff mixed up...
18:02:27 <revenantphx> heh
18:05:10 <McManiaC> fun had some with haskell tonight. :D http://npaste.de/iX/
18:05:55 <monochrom> no wonder you speak like that
18:05:59 <revenantphx> McManiaC: Is that what I think it is...?
18:06:11 <McManiaC> is it yes!
18:06:37 <monochrom> was thinking "in soviet russia, haskell has fun with you!"
18:06:55 <McManiaC> :D
18:07:12 <hpc> in soviet russia, safety type you!
18:07:17 <monochrom> conclusion: yoda runs soviet russia
18:07:23 <revenantphx> McManiaC: If I put "you are strong" it gives back "are you strong"
18:07:28 <revenantphx> I was expecting "strong you are"
18:07:36 <McManiaC> revenantphx: its completly random :P
18:07:40 <hpc> revenantphx: clearly, much to learn you still have
18:07:40 <revenantphx> oh lol
18:07:53 <revenantphx> *Yoda> yoda "you are strong"
18:07:53 <revenantphx> stron are youg
18:08:02 <revenantphx> right, something isn't there.
18:08:06 <Twey> Hehe
18:08:12 <McManiaC> oh yeh, you need correct punctuation
18:08:13 <McManiaC> =D
18:08:23 <revenantphx> McManiaC: ?
18:08:31 <McManiaC> yoda "you are strong."
18:08:41 <Twey> It expects one of "!.?,\"\'"
18:09:00 <revenantphx> oh i see.
18:09:16 <McManiaC> its just a veeeeeeeeery quick & dirty hack, so dont expect too much from it :P
18:09:17 <revenantphx> silly but fun ^_^
18:09:22 <McManiaC> =D
18:14:53 <Zeiris> The new haddock-generated pages look amazing.
18:15:54 <McManiaC> a bit irritating still :>
18:16:56 <hpc> what was wrong with the old scheme?
18:17:28 <benmachine> hpc: less easily customisable, for one
18:17:34 <benmachine> I believe the old scheme is still available?
18:18:57 <Zeiris> The colour scheme and style of the new one look far more slick.
18:19:09 <Zeiris> Old scheme was functional, but not particularly pretty.
18:25:27 <kw317> q
18:27:44 <Mitar> is it possible to declare default declaration for type families?
18:28:28 <dmwit> You want an _ for type families?
18:28:36 <dmwit> If so, I'm sorry. =/
18:28:38 <Mitar> aha, i see, it is on high Todo (high-level):
18:28:39 <Mitar> ;-)
18:28:43 <Mitar> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsStatus
18:29:01 <Mitar> Defaults for associated type synonyms.
18:29:12 <Mitar> so dependencies are in this sense better
18:46:00 <ezyang> $ inplace/bin/ghc-stage2 -e "return ()" < /dev/null 
18:46:07 <ezyang> <stdin>: hGetEcho: failed (failed to get echoing) 
18:46:14 <ezyang> Does anyone know why GHC would be calling hGetEcho? 
18:46:36 <ezyang> (disregard the error for a moment) 
18:47:37 <Eelis> in my program i use a Set representing "already processed" items. when an item that potentially isn't processed yet comes up, i first see if it's already in the set, and only if it's not do i process the item and add it to the set. this works fine, but it involves *two* operations on the Set, each of them O(log n).
18:47:43 <Eelis> now, if there was an insert operation for Set that told you whether it actually encountered an equivalent value while inserting, then using that one i would only need a single operation on the set.
18:47:53 <Eelis> but there doesn't seem to be such an operation for Set. how come?
18:48:18 <Eelis> in C++, std::set::insert /does/ tell you whether an equivalent value was encountered while inserting
18:48:24 <Eelis> so the need seems to be legitimate
18:49:09 <dmwit> I've wished for this kind of thing as well.
18:51:07 <Zeiris> What would the type of such an insert function be?
18:51:22 <dmwit> a -> Set a -> (Set a, Bool)
18:51:22 <copumpkin> a -> Set a -> (Set a, Bool) ?
18:51:32 <Eelis> that would do fine, yeah
18:51:40 <copumpkin> pff, we're computer scientists
18:51:43 <copumpkin> we only care about asymptotics
18:52:13 <copumpkin> luckily, there's a proposal in there to give us a .Internals module
18:52:18 <copumpkin> so they wouldn't _have_ to be opaque
18:52:42 <Eelis> hm, i think i would argue that this belongs in the public interface, not relegated to some "Internals" module
18:52:43 <benmachine> a -> Set a -> Maybe (Set a)
18:52:51 <copumpkin> Eelis: oh, I agree
18:52:59 <benmachine> return Just (new_set) or Nothing if it's the same as the old set
18:53:13 <kmc> it's easier to fix API oversights if you have the Internals module
18:53:13 <copumpkin> I just meant that when they fix it, they'll give us a .Internals module that would allow us to implement "forgotten" functions like this efficiently
18:53:14 * benmachine unnecessary parentheses
18:53:27 <Eelis> copumpkin: ah, ok
18:53:36 <dmwit> benmachine: Actually, if you look at the docs for insert, you'll see that you actually want a new Set a even if the a is already in there.
18:53:53 <Eelis> so, it doesn't seem like a crazy idea to try to implement this functionality and send a patch to haskell-lib?
18:54:06 <benmachine> dmwit: in case the Ord instance makes distinct things equal?
18:54:20 <copumpkin> Eelis: not at all
18:54:29 <dmwit> benmachine: yes
18:54:37 <Eelis> alrighty then
18:54:56 <dmwit> benmachine: or in case the Ord instance make distinct pointers equal, as it is often compelled to do
18:55:14 <benmachine> oh, fair enough
18:56:29 <Mitar> hmmm
18:56:31 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29751#a29752
18:57:30 <dmwit> it's aLIIIIIIVE!!!
18:58:30 <sidek> I have a heavy background in mathematics and decent knowledge of a few different assembly languages, mainly focusing on ARM processors.  As I really should learn a higher-level programming language, I decided to learn Haskell. Any sources I should  check out?
18:58:43 <copumpkin> sidek: omg ARM
18:58:52 <sidek> what about ARM?
18:58:54 <dmwit> ?where lyah
18:58:54 <lambdabot> http://www.learnyouahaskell.com/
18:58:57 <dmwit> ?where
18:58:57 <lambdabot>  @where <key>, return element associated with key
18:59:02 <dmwit> ?where rwh
18:59:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:59:02 <sidek> alright
18:59:03 <sidek> thanks
18:59:06 <copumpkin> (I'm writing an ARM "implementation" in haskell as we speak :P)
18:59:30 <dmwit> sidek: There's also the Gentle Introduction, which is my personal favorite, but you should be warned that it is far from gentle.
18:59:31 <sidek> ah
18:59:34 <dmwit> ?where gentle
18:59:34 <lambdabot> http://www.haskell.org/tutorial/
18:59:47 <bss03> I haven't read LYAH, but I thought RWH was good enough I bought it for my phone.
18:59:53 <co_dh> copumpkin: really ? that's cool . 
18:59:59 <sidek> alright
19:00:08 <copumpkin> co_dh: let's hope so! giving my decoder a testsuite now
19:00:29 <ezyang> This is hilarious. 
19:00:31 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29753#a29753 
19:01:25 <dmwit> oh dear
19:02:19 <co_dh> copumpkin: are you design a chip of ARM ?
19:02:28 <copumpkin> co_dh: nope, reverse engineering tools :)
19:04:57 <lispy> ezyang: omg!
19:05:16 <dmwit> subtle bugs and bears, oh my
19:05:18 <sidek> Reverse engineering is of interest to me, actually. The reason I know some asm is because I used to "hack"   the DS and GBA. Quit when games started going online and I personally experienced some griefing in AC:WW and aimbotters in MP:H
19:06:03 <ezyang> I suspect this is the famous "Cygwin doesn't actually give you a real terminal" bug 
19:06:08 <ezyang> But it shows up on cmd.exe too. 
19:06:36 <sidek> Cygwin doesn't give you a real terminal? That explains a lot!
19:07:02 <lispy> cygwin is another way to spell evil
19:07:03 <sidek> Really, though. I was working with a Cygwin terminal quite a while ago
19:08:13 * hackagebot webkit 0.11.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.11.2 (AndyStewart)
19:08:15 * hackagebot gtk2hs-buildtools 0.11.2 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.11.2 (AndyStewart)
19:08:38 <monochrom> eh! new version of gtkhs-buildtools!
19:08:48 <ezyang> \ldots 
19:08:50 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29754#a29754 
19:09:00 <ezyang> isatty is soooo broken. :-/ 
19:09:13 * hackagebot glib 0.11.2 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.11.2 (AndyStewart)
19:09:27 <monochrom> hahaha, null is a tty
19:09:46 <dmwit> It's 64 ttys, apparently.
19:10:03 <monochrom> the empty set is a subset of every set. the null terminal is a subterminal of every terminal.
19:10:51 <dmwit> At least here, man isatty claims only 0 and 1 are return values. =P
19:11:00 <ezyang> yeah.... 
19:18:03 <ezyang> Sigh. http://hackage.haskell.org/trac/ghc/ticket/2628#comment:2 
19:22:17 <heatsink> Does 64 mean "extremely true"?
19:23:37 <revenantphx> heatsink: it's not false, thats for sure.
19:24:17 <sshc> Hahahaha http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html "Safely modifying an MVar" :D
19:26:12 <dmwit> ?
19:28:04 <sidek> Rather elementary question, but: does Haskell have something similar to Singular's _? That is, a variable that takes the last value pushed to STDOUT and claims it for itself. So, in Singular: 9 * 9; gives 81. 9 * _; then gives 729.
19:28:04 <sshc> dons: Are you aware of the main thread terminating before the other threads mistake in that chapter?
19:28:30 <heatsink> sidek: interactively, it's called "it"
19:32:27 <revenantphx> would the correct pattern for a singleton be 
19:32:27 <revenantphx> (x:[])
19:32:32 <dmwit> yes
19:32:33 <dmwit> or [x]
19:32:36 <revenantphx> right
19:32:43 <revenantphx> (x:[]) makes more sense to me.
19:32:51 <dmwit> [x] looks prettier to me =)
19:32:58 <revenantphx> looks prettier, but its less clear
19:33:09 <revenantphx> (x:[]) is very explicit and states exactly what it is
19:33:18 <revenantphx> though [x] is much clearer
19:33:27 <revenantphx> how would you do a list with two elements then?
19:33:30 <sidek> [x] seems better because it has way less keystrokes
19:33:30 <revenantphx> [x ,y]
19:33:31 <revenantphx> ?
19:33:32 <dmwit> [x, y], of course
19:33:34 <Funktorsalat> ((head &&& tail) -> (x,[]))
19:33:41 <revenantphx> &&&?
19:33:50 <dmwit> Funktorsalat: ew
19:33:57 <Funktorsalat> > (head &&& tail) [1..]
19:33:58 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:34:11 <dmwit> Funktorsalat: What do view patterns do with exceptions?
19:34:17 <dmwit> Not match?
19:34:25 <revenantphx> what is &&&?
19:34:32 <Funktorsalat> dmwit: ew? I'm not suggesting it as the most elegant solution, actually I was trying for something funnily contrived
19:34:43 <Funktorsalat> dmwit: hmm good question
19:34:45 <dmwit> Funktorsalat: Yep, and I was congratulating you!
19:35:05 <ezyang> revenantphx: Facetiously, singleton = unsafePerformIO $ newIORef foo >:-) 
19:35:16 <Veinor> :t (&&&)
19:35:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:35:17 <revenantphx> ....>>
19:35:29 <revenantphx> Veinor: that doesn't really tell me what it does, haha
19:35:36 <Veinor> > (head &&& tail) [1,2,3,4]
19:35:36 <revenantphx> idk what Arrow is either
19:35:36 <lambdabot>   (1,[2,3,4])
19:35:46 <Veinor> (f &&& g) x = (f x, g x)
19:35:54 <dmwit> (&&&) :: Arrow (~>) => (a ~> b) -> (a ~> b') -> (a ~> (b, b'))
19:36:02 <revenantphx> Oh great, ANOTHER symbol ->
19:36:04 <revenantphx> ~>
19:36:24 <dmwit> Thinking of arrows as embellished functions, it seems pretty clear then what (&&&) ought to do, from that type signature.
19:36:44 <dmwit> namely: apply the first and second arguments, doing both embellishments as necessary
19:36:54 <revenantphx> embellished functions?
19:37:00 <Funktorsalat> @ty g :: Expr
19:37:01 <lambdabot> Expr
19:37:05 <dmwit> Since functions are themselves embellished functions (with no embellishments), then you can write
19:37:18 <dmwit> (&&&) :: (a -> b) -> (a -> b') -> (a -> (b, b')) -- a specialization
19:37:19 <Funktorsalat> > (f &&& g) x         :: (Expr,Expr)
19:37:20 <lambdabot>   (f x,g x)
19:37:33 <Funktorsalat> ^^^^^ revenantphx 
19:37:38 <revenantphx> reading
19:38:00 <dmwit> > (f *** g) (x, y)
19:38:01 <lambdabot>   Ambiguous type variable `c' in the constraints:
19:38:01 <lambdabot>    `GHC.Show.Show c'
19:38:01 <lambdabot>      a...
19:38:05 <revenantphx> so &&& takes two functions that take the same type and return two different types
19:38:09 <dmwit> > (f *** g) (x, y) :: (Expr, Expr)
19:38:10 <lambdabot>   (f x,g y)
19:38:19 <revenantphx> and returns a function that takes that type and returns a tuple of the two different types?
19:38:26 <dmwit> Yes.
19:38:36 <dmwit> But it also takes other things that behave sort of like functions, but aren't. =)
19:38:43 <revenantphx> ... > <
19:39:09 <revenantphx> I'll have to read up on this stuff in a bit
19:39:12 <Funktorsalat> @let rk = runKleisli
19:39:13 <lambdabot>  Defined.
19:39:17 <Funktorsalat> @let k = Kleisli
19:39:18 <lambdabot>  Defined.
19:39:34 <revenantphx> @let revenantphx = "awesome"
19:39:36 <lambdabot>  Defined.
19:39:39 <revenantphx> ^_^
19:39:51 <Denney> Hello
19:39:53 <revenantphx> @unlet revenantphx
19:39:53 <lambdabot>   Parse error: SemiColon
19:40:08 <revenantphx> > k
19:40:09 <lambdabot>   Ambiguous occurrence `k'
19:40:09 <lambdabot>  It could refer to either `L.k', defined at <local...
19:40:10 <dmwit> > (revenantphx, dmwit)
19:40:11 <lambdabot>   Not in scope: `dmwit'
19:40:18 <megajosh2> Lol what are you doing? :D
19:40:20 <dmwit> > (revenantphx, dmwit)
19:40:21 <lambdabot>   Not in scope: `dmwit'
19:40:21 <revenantphx> @let dmwit = "dimwit"
19:40:22 <lambdabot>  Defined.
19:40:28 <revenantphx> > (revenantphx, dmwit)
19:40:29 <lambdabot>   ("awesome","dimwit")
19:40:30 <Denney> Does anyone know of a haskell rpl for android?
19:40:41 <Funktorsalat> > rk  (  Kleisli (\x -> [2*x,3*x])     &&&    Kleisli (\x -> [x+1,x+2])    )  [1,2,3]
19:40:42 <lambdabot>   No instance for (GHC.Num.Num [t])
19:40:42 <lambdabot>    arising from a use of `e_12312123' at ...
19:41:07 <Funktorsalat> (thanks for warning me my k was ambiguous, revenantphx ;))
19:41:10 <megajosh2> A use of what?
19:41:28 <Funktorsalat> > rk  (  Kleisli (\x -> [2*x,3*x])     &&&    Kleisli (\x -> [x+1,x+2])    )   2
19:41:29 <lambdabot>   Not in scope: `rk'
19:41:38 <Funktorsalat> > runKleisli  (  Kleisli (\x -> [2*x,3*x])     &&&    Kleisli (\x -> [x+1,x+2])    )   2
19:41:38 <revenantphx> Funktorsalat: OH OF COURSE THANKS. THAT'S EXACTLY WHAT I INTENDED
19:41:38 <lambdabot>   [(4,3),(4,4),(6,3),(6,4)]
19:41:40 * revenantphx whistle
19:41:44 <Funktorsalat> :)
19:41:57 <revenantphx> i dont get this kleisli thing > 
19:42:03 <megajosh2> Kleisli...
19:42:06 <megajosh2> Category...
19:42:09 <megajosh2> Bleh
19:42:21 <Funktorsalat> revenantphx: it's just a newtype to get around typeclass limitations :(
19:42:24 <dmwit> > (revenantphx, dmwit)
19:42:24 <lambdabot>   ("awesome",dmwit)
19:42:31 <megajosh2> I feel like I need to read up on category theory to have any idea what I'm doing :/
19:42:36 <megajosh2> Almost
19:42:53 <Funktorsalat> Kleisli m         a b = a -> m b
19:42:55 <revenantphx> Funktorsalat: define ,newtype and limitations
19:42:58 <dmwit> You need to read up on the libraries to know what you are doing. This is true of any language.
19:43:13 <Funktorsalat> (suggestive space ;))
19:43:15 <dmwit> We take our names from CT, but knowledge of CT doesn't really help with using the libraries.
19:43:24 <revenantphx> Funktorsalat: not quite getting it :P
19:43:41 <revenantphx> maybe I should you know, reinforce the basics first
19:43:43 <Denney> excuse me guys, does any body know of a haskell compiler for an android phone?
19:43:55 <revenantphx> do you have any ideas for exercises to make sure i know the basics?
19:44:07 <revenantphx> I'm going through a few of the 99 Haskell Questions
19:44:12 <revenantphx> (the ones adapted from lisp from prolog)
19:45:12 <revenantphx> working out a function to determine palindromism at the moment
19:45:57 <revenantphx> I'm trying to see if I can do it WITHOUT a reverse function
19:46:07 <revenantphx> x == (reverse x) is too simple :P
19:46:30 <Funktorsalat> dmwit: but... (&&&) is just the adjunction isomorphism Hask( a  ,  (b,c) )  =~   Hask(a,b) x Hask(a,c)
19:46:44 <revenantphx> Funktorsalat: Oh! Now I get it!
19:46:47 <Funktorsalat> *troll*
19:46:51 <dmwit> ;-)
19:46:54 <revenantphx> @let sarcasm = True
19:46:55 <lambdabot>  Defined.
19:47:36 <Funktorsalat> (product :: Hask x Hask -> Hask     is right adjoint to      diagonal :: Hask -> Hask x Hask )
19:47:48 <revenantphx> dmwit: any advice on exercises to learn to use haskell more effectively?
19:47:58 <revenantphx> mainly practice to get in the write frame of mind.
19:48:04 <revenantphx> I'm more than a bit stuck in imperative-land.
19:48:09 <revenantphx> right*
19:48:15 <jmcarthur> revenantphx: how about writing an interpreter for a simple language?
19:48:16 <Funktorsalat> revenantphx: but 'newtype' is a pretty elementary feature, yes
19:48:38 <revenantphx> jmcarthur: let me guess, scheme?
19:48:47 <copumpkin> revenantphx: brainfuck
19:48:55 <revenantphx> copumpkin: thats actually not a bad idea, except for the state
19:48:56 <jmcarthur> revenantphx: brainfuck is a pretty simple one and gives you an opportunity to practice with things like state monads and other stuff if you clean it up really good
19:49:03 <copumpkin> revenantphx: it's pretty easy
19:49:03 <Funktorsalat> and FWIW the limitation I was talking about is that you can't do "instance Category (/\a b -> a -> [b])"
19:49:03 <revenantphx> though I suppose you could parse brainfuck recursively.
19:49:11 <jmcarthur> revenantphx: brainfuck is particulary good *because* of the state
19:49:21 <revenantphx> jmcarthur: well I'll look at state monads.
19:49:25 <revenantphx> and then try bf
19:49:48 <copumpkin> for now you might even want to try brainfuck minus the IO :)
19:49:58 <copumpkin> so drop , and .
19:50:31 <revenantphx> copumpkin: yeah I was gonna say
19:50:42 <jmcarthur> the IO is a good one to add later :)
19:50:51 <revenantphx> copumpkin: You could probably parse it recursively though, without a state monad
19:51:02 <Funktorsalat> (that /\ there is the nonexistent typlevel lambda)
19:51:06 <revenantphx> copumpkin: though you'd have to pass the ByteString to each recursion.
19:51:09 <copumpkin> sure, parsing is not trivial, but not hard either
19:51:11 <jmcarthur> state monads are never required, but they can pretty things up
19:51:19 <copumpkin> revenantphx: just work with strings for now
19:51:22 <revenantphx> jmcarthur: I'm sure, I need to go learn how to use them.
19:51:27 <copumpkin> they're easier to decompose and pattern match on
19:51:32 <revenantphx> copumpkin: good point
19:51:33 <jmcarthur> yeah don't worry about ByteStrings for this
19:51:37 <pikhq> Recursive parsing of Brainfuck is pretty simple.
19:51:43 <copumpkin> yep
19:52:09 <revenantphx> k I'll go do that
19:52:11 <pikhq> Perhaps even... The natural thing to do.
19:52:30 <Funktorsalat> Brainstrinng
19:52:31 <dmwit> use CPP to convert BF to C
19:52:36 <revenantphx> btw, I meant using the bytestring for the 1000 byte array brainfuck uses
19:52:37 <dmwit> step two: cry
19:52:55 <jmcarthur> revenantphx: ah, you could use a more general array library for that
19:53:06 <revenantphx> jmcarthur: or just list
19:53:07 <jmcarthur> revenantphx: really though, you can get by with something a bit nicer
19:53:12 <jmcarthur> revenantphx: look up "zippers"
19:54:34 <Funktorsalat> apropos zippers... I recently redid a list widget (vty-ui) to use a zipper as back data structure, but ran into the apparent inefficiency that I have to reverse the 'upper' part before displaying it...
19:54:35 <jmcarthur> my first BF interpreter was using a zipper for the machine state, and it was actually easier to give the machine virtually infinite memory than to allocate it as a fixed buffer :)
19:54:57 <Funktorsalat> still a lot faster than a list since it's O(screen size), not O(list size)
19:54:58 <jmcarthur> yeah zippers aren't always appropriate
19:55:04 <Funktorsalat> but is there a better structure?
19:55:09 <jmcarthur> if you need to reverse stuff then a queue would probably be better
19:55:12 <jmcarthur> Seq maybe?
19:55:24 <revenantphx> zipper...?
19:55:29 <revenantphx> I need to go look those up than
19:55:33 <revenantphx> then*
19:55:47 <Funktorsalat> a workaround would be to render the lines by moving the cursor upwards ;)
19:55:53 <copumpkin> revenantphx: it's a simple idea for maintaining a kind of cursor over a list (or any other datastructure)
19:55:55 <Funktorsalat> jmcarthur: ah Seq might do..
19:56:02 <revenantphx> copumpkin: oh, so like a... pointer?
19:56:03 <revenantphx> :P
19:56:04 <Funktorsalat> (it has fast random access?)
19:56:15 <jmcarthur> revenantphx: exactly! but cleaner :)
19:56:24 <revenantphx> jmcarthur: because pointers weren't clean enough
19:56:25 <jmcarthur> Funktorsalat: you need random access?
19:56:26 <copumpkin> revenantphx: and immutable
19:56:29 <revenantphx> pointer haters gonna hate
19:57:12 <revenantphx> what module is Zipper in?
19:57:24 <Funktorsalat> jmcarthur: well not really, but that'd be sufficient (suppose you have a huge backing list and are displaying the last page of it... a list is really bad)
19:57:26 <jmcarthur> revenantphx: basically a zipper is a data structure that's been transformed such that there is a "designated element," and you can move about the structure by transforming everything around the designated element
19:57:48 <revenantphx> mmk
19:57:48 <revenantphx> um
19:57:50 <revenantphx> http://en.wikibooks.org/wiki/Haskell/Zippers
19:57:57 <revenantphx> was this written by someone on CRACK?
19:58:05 <Funktorsalat> jmcarthur: (but the zipper is okay; I just have to reverse the last $LINES elements, not the whole list)
19:58:06 <jmcarthur> Funktorsalat: you can get O(log n) split and O(1) access to both ends
19:58:07 <revenantphx> ""Theseus, we have to do something" said Homer, chief marketing officer of Ancient Geeks Inc.. Theseus put the Minotaur action figure™ back onto the shelf and nodded. "Today's children are no longer interested in the ancient myths, they prefer modern heroes like Spiderman or Sponge Bob." Heroes. "
19:58:16 <revenantphx> "A true hero, Theseus chose Haskell as the language to implement the company's redeeming product in."
19:58:39 <jmcarthur> i remember that one
19:58:50 <revenantphx> who writes these...
19:58:51 <revenantphx> really...
19:58:54 * jmcarthur shrugs
19:58:59 <jmcarthur> that was around when i was learning
19:59:05 <Funktorsalat> revenantphx: I found that tutorial pretty effective
19:59:11 <heatsink> Why, maybe?
19:59:19 <revenantphx> Funktorsalat: well i'm reading now
19:59:23 <Adamant> "this page needs to be reviewed for quality" <- heresy!
19:59:28 <Funktorsalat> I almost never read things before starting coding (well, half-irony ;)) but I read that
19:59:33 <revenantphx> Adamant: I agree!
19:59:45 <revenantphx> Funktorsalat: I find that sarcastic or humorous tutorials often present ideas more clearly.
19:59:53 <revenantphx> point in case: Why's Poignant Guide
20:00:00 <megajosh2> Ancient Greeks inc...
20:00:12 <revenantphx> I mean, catching stars and sticking them on monkeys totally explains closures...
20:00:19 <revenantphx> ...> _>
20:00:26 <jmcarthur> i'm the opposite. i'd rather things just be presented to me without the distraction of a narrative
20:00:41 <revenantphx> jmcarthur: well im fine either way
20:00:55 <revenantphx> ~ cheer up sleeepy jean... oh, what can it mean, to a, daydream believer..~
20:01:11 <Funktorsalat> jmcarthur: well it wasn't really the narrative I guess
20:01:25 <Funktorsalat> just that a labyrinth search is a decent example?
20:02:23 <Funktorsalat> (about Seq, access to both ends isn't enough since your scroll window could be on the middle of your backing list too)
20:02:53 <Funktorsalat> but I think I'll just keep the zipper, since $LINES is kinda bounded, so reversing that many elements shouldn't be too bad
20:03:13 <revenantphx> I do like haskell's 'data' expression
20:03:17 <Funktorsalat> (by $LINES I mean the number of terminal lines, not the number of items in the model)
20:03:19 <revenantphx> it's kind of a 'struct-lite'
20:03:48 <revenantphx> you can make types easily without worrying about data lengths, packing, pointers, and worse... page alignment
20:04:04 <revenantphx> it's relatively intuitive too.
20:04:05 <kmc> well, Haskell is a high-level language
20:04:19 <kmc> they all let you define data without worrying about those things
20:04:22 <kmc> (by definition)
20:04:30 <revenantphx> kmc: Yeah, but you have to usually use a lot of objects
20:04:30 <kmc> but algebraic data is nicer than most of the alternatives i've seen
20:04:36 <Funktorsalat> AIUI you can actually get it to make a 'real struct' with the {-# UNPACK #-} pragma
20:04:38 <revenantphx> NOT dealing with OO is actually nicer some times > >
20:04:45 <kmc> yeah
20:04:48 <kmc> and you can do OOP in Haskell too
20:04:51 <Funktorsalat> or am I misunderstanding it..?
20:04:53 <kmc> OOP is a style, not a language feature
20:04:57 <revenantphx> kmc: true
20:05:12 <kmc> and Haskell supports enough type trickery to do most of what you'd want from OOP, and cleaner too
20:05:18 <Funktorsalat> (a struct with three unpacked Int32s only takes 12 contiguous bytes, right?)
20:05:25 <revenantphx> kmc: considering you can write imperative code in functional code through monads is mind-bending enough
20:05:29 <Funktorsalat> *datatype :p
20:05:39 <revenantphx> Funktorsalat: yes
20:05:42 <Funktorsalat> and the box for the whole thing itself
20:05:52 <revenantphx> but a struct of Int32, Int8, Int32 will ALSO take 12 contiguous bytes
20:05:52 <kmc> revenantphx, monads are less important there than you might think
20:06:00 <Funktorsalat> revenantphx: in haskell?
20:06:02 <revenantphx> kmc: heh
20:06:04 <revenantphx> Funktorsalat: no.
20:06:05 <kmc> they're just a convenient API for manipulating descriptions of imperative programs, among many other things
20:06:07 <heatsink> Funktorsalat: 16 bytes on a 32-bit machine.  There's a header word.
20:06:23 <kmc> you could manipulate imperative programs without using a monadic API
20:06:27 <Funktorsalat> revenantphx: I meant something like: data Foo = Foo {-# UNPACK #-} Int32 (repeat three times)
20:06:38 <Funktorsalat> correction: !Int32
20:06:40 <revenantphx> Funktorsalat: oh I dont know that stuch
20:06:43 <revenantphx> stuff*
20:07:02 <pikhq> revenantphx: Monads aren't really about "writing imperative code in functional code". They just happen to make doing this much easier.
20:07:11 <revenantphx> pikhq: I understand that
20:07:12 <Funktorsalat> heatsink: what does the header do?
20:07:22 <heatsink> Funktorsalat: The garbage collector uses it to trace the object.
20:07:29 <Funktorsalat> ah
20:07:33 <revenantphx> ~ Ever since I was a young boy, I've played the silver ball... From soho down to brighton, I must have played them all ~
20:07:37 <pikhq> You can do it with nothing but functions just fine; just a matter of passing around a state variable that you replace with a new state when you would change it.
20:07:55 <revenantphx> pikhq: yeah, the monads just allow conveneint stuff like Maybe
20:08:19 <Funktorsalat> heatsink: (but that is in addition to the pointer that is presumably used if you put Foos into a list etc?)
20:08:24 <revenantphx> so you don't have to have each step perform checks for Nothing values
20:08:34 <kmc> the point of the type class named "Monad", like every other type class, is to reuse a set of operators in a consistent way across a wide variety of types
20:08:48 <revenantphx> kmc: yeah
20:09:03 <revenantphx> I think its safe to say Haskell is a very unique new experience for me :P
20:09:12 <revenantphx> a looooot of new concepts..
20:09:17 <kmc> that's how most people feel about it
20:09:25 <kmc> and you'll start to see those concepts in other languages
20:09:26 <heatsink> Funktorsalat: If you put a Foo into a list, the list will have a pointer... the Foo is still a header and three ints.
20:09:37 <revenantphx> kmc: mm yeah
20:09:39 <revenantphx> btw, this may just be me
20:09:43 <kmc> you'll start to feel the pinch from missing certain Haskell features, which you never missed before
20:09:48 <revenantphx> hehe
20:09:57 <kmc> knowing Haskell seriously harms your ability to be satisfied with a typical programming job
20:09:58 <heatsink> That's one of the things I've had trouble with, actually.
20:09:59 <revenantphx> but functional languages seem to have a tendency to be more experimental/educational/avant garde
20:10:07 <Funktorsalat> heatsink: ok, seems reasonable
20:10:10 <revenantphx> if that makes sense
20:10:22 <heatsink> People tell me they don't understand Haskell... but when I use monads in Python, they still don't understand it.
20:10:36 <kmc> revenantphx, yeah
20:10:45 <revenantphx> monads in python? I need to take a look at that.
20:11:09 <heatsink> revenantphx: Exactly what you do in Haskell, except without the syntax.
20:11:15 <revenantphx> heh
20:11:18 <kmc> and without the static type checking, presumably
20:11:23 <heatsink> yeah
20:11:43 <revenantphx> It's kind of refreshing to listen to my itunes library on shuffle
20:11:48 <djahandarie> (Which is what I think makes that hardcore of an abstraction worth it)
20:11:49 <revenantphx> lots of songs I havent listened to in a while.
20:11:59 <revenantphx> djahandarie: do is a pretty hard core abstraction... > >
20:12:14 <revenantphx> do on top of monad binding on top of function application... etc
20:12:17 <Funktorsalat> you can probably do them in shell too with strings-as-first class functions :p
20:12:21 <Funktorsalat> (them=monads)
20:12:36 <revenantphx> Monads should theoretically be implementable almost anywhere
20:12:46 <revenantphx> though maybe not as easily.
20:12:50 <kmc> i don't think Monad is a particularly heavyweight abstraction; it mostly just requires good support for first-class functions with lightweight syntax
20:12:59 <revenantphx> kmc: yeah, otherwise it'd be a pain
20:13:03 <kmc> which is something nearly every language should have, but also something language designers consistently get wrong
20:13:14 <kmc> but, for example, it's not too bad in C#
20:13:19 <revenantphx> C with first-class functions would be nice.
20:13:27 <revenantphx> function pointers are more than a bit cumbersome.
20:13:28 <kmc> revenantphx, Apple has implemented it as a GCC and clang extension
20:13:32 <Adamant> I thought C 3.0 did that
20:13:35 <revenantphx> kmc: I'm aware.
20:13:40 <revenantphx> Wait ,what?
20:13:42 <Adamant> err, C# 3.0
20:13:43 <revenantphx> I've seen their blocks?
20:13:50 <revenantphx> you mean those?
20:13:54 <kmc> yes
20:13:54 <revenantphx> I use them a LOT. > >
20:14:01 <revenantphx> I mean, I use them a LOT...
20:14:10 <Adamant> blocks = closures
20:14:14 <revenantphx> Adamant: yep
20:14:17 <Funktorsalat> C# has lambdas, but AFAIK it won't let you type the general concept 'monad'
20:14:25 <kmc> Apple and Microsoft and friends have finally heard about this "functional programming" thing and are proclaiming it to be the greatest thing ever
20:14:25 <revenantphx> I'm not sure you could call them first class though
20:14:27 <Funktorsalat> (lack of higher-kinded parameters)
20:14:31 <revenantphx> kmc: haha, yep
20:14:32 <Funktorsalat> all AFAIK
20:14:32 <kmc> about 40 years after academics proclaimed it to be the greatest thing ever
20:14:48 <NemesisD> hi all. ive nearly made it through learn you a haskell but i really want to start building something small and useful. do you have any code you suggest i look at or any suggestions? i have no ideas
20:14:59 <revenantphx> kmc: i'm starting to see one thing
20:15:04 <Adamant> kmc: to be fair, functional wasn't great for all of those 40 years
20:15:08 <revenantphx> kmc: binding function parameters with () is annoying > <
20:15:09 <ManateeLazyCat> NemesisD: Do you interesting GUI program?
20:15:14 <kmc> Funktorsalat, right.  fwik the thing in C# resembling monad "do" syntax (LINQ) is duck-typed
20:15:20 <NemesisD> ManateeLazyCat: nah im a CLI guy
20:15:27 <ManateeLazyCat> NemesisD: Ok. :)
20:15:30 <kmc> if you have Select and Where and SelectMany methods, you can be LINQ'd
20:15:54 <revenantphx> One thing I've been thinking about kmc
20:15:55 <ManateeLazyCat> NemesisD: Control like CLI, but display like GUI, like?
20:16:01 <Funktorsalat> kmc: yeah, they added 'extension methods' with linq which seem to be much like typeclass instance decls ;)
20:16:05 <revenantphx> functional languages seem like they'd fit with multithreading pretty well
20:16:18 <revenantphx> especially something like haskell
20:16:25 <revenantphx> where all variables are immutable
20:16:27 <ManateeLazyCat> revenantphx: Yes, special STM.
20:16:32 <NemesisD> ManateeLazyCat: not sure what you mean. i want to write some sort of cli-only utility
20:16:34 <revenantphx> makes managing inter-thread state simpler.
20:16:48 <ManateeLazyCat> NemesisD: http://www.flickr.com/photos/48809572@N02/
20:16:58 <ManateeLazyCat> NemesisD: I'm looking for new user/developer. :)
20:16:59 <Funktorsalat> e.g. static string show(this string x) { ... }
20:17:19 <Funktorsalat> which you can put in an arbitrary static class, not just the original class or even compilation unit
20:17:42 <kmc> revenantphx, correct :) http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
20:17:44 <revenantphx> kmc: Apple's blocks are pretty sexy though
20:17:47 <kmc> revenantphx, in the simplest case you don't even *have* threads
20:17:57 <kmc> you just say "evaluate this part and that part of the expression at the same time"
20:17:59 <Funktorsalat> *correction: this Foo x
20:18:02 <NemesisD> ManateeLazyCat: im pretty sure i'm too new to be useful. i need to get some good examples or figure out a good entry point to start using haskell
20:18:03 <revenantphx> kmc: I had this great architecture for a server I made.
20:18:04 <mm_freak> Funktorsalat: you can implement specific monads in C# (if you can live with lots and lots of ugly parentheses and braces)
20:18:04 <kmc> no thread semantics, no coordination between threads
20:18:06 <kmc> it just works
20:18:11 <revenantphx> kmc: it passed around blocks as units of work on series of queues
20:18:21 <revenantphx> kmc: which each did work on individual threads
20:18:22 <Funktorsalat> which will make Foo implement the imaginary Show interface after the fact... 
20:18:40 <Funktorsalat> mm_freak: yes, specific monads don't require higher-kinded type variables
20:18:41 <mm_freak> Funktorsalat: but you cannot write the generic monad interface in C#
20:18:49 <revenantphx> kmc: nice :)
20:18:50 <kmc> revenantphx, there's at least four major threads (pun intended) of parallel or concurrent work in Haskell
20:19:08 <ManateeLazyCat> revenantphx: You can try STM for concurrent, awesome!
20:19:18 <mm_freak> Funktorsalat: yes…  but in C++ it's possible by using template templates
20:19:19 <danderson> Anyone fancy doing a documentation review for a new library?
20:19:22 <danderson> http://natulte.net/random/secure/Network-Secure.html
20:19:22 <ManateeLazyCat> revenantphx: No lock for multi-thread.
20:19:35 <revenantphx> ManateeLazyCat: no locks? wonderful > >
20:19:36 <mm_freak> if you use visual C++, you get stuff like closures, too, so you can really implement the generic monad interface
20:19:41 <ManateeLazyCat> revenantphx: Yes.
20:19:49 <revenantphx> ugh, C++ is... irritating
20:19:51 <kmc> evaluation strategies (pure parallelism, sequential semantics); Control.Concurrent (traditional threaded concurrency); STM (transactional concurrency); Data Parallel Haskell (operations applied over nested arrays)
20:19:54 <ManateeLazyCat> revenantphx: You can drop all trouble about lock.
20:20:03 <kmc> revenantphx, the last chapter of RWH is a good introduction to STM
20:20:07 <copumpkin> kmc: repa, accelerate!
20:20:08 <revenantphx> RWH?
20:20:12 <kmc> real world haskell
20:20:13 <kmc> @where RWH
20:20:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:20:15 <ManateeLazyCat> revenantphx: Real World haskell.
20:20:18 <Pseudonym> Visual C++ makes C++ even more irritating.
20:20:24 <revenantphx> oh I'll go read this manatee
20:20:27 <ManateeLazyCat> kmc: why you type so fast? ;p
20:20:28 <revenantphx> then I'll do that bf interpreter
20:20:29 <kmc> it's a great book
20:20:44 <kmc> copumpkin, i knew i was safer saying "at least" ;)
20:20:53 <mm_freak> Pseudonym: i've never written in VC++, but i know that you can implement the generic monad interfaces in it
20:21:14 <kmc> revenantphx, GHC's threads are very lightweight -- you can spawn 100,000 of them on a typical desktop machine
20:21:21 <avenge> I wish RWH had a colophon.  Anyone know how they prepared the book?
20:21:34 <copumpkin> avenge: the authors all hang out in here
20:21:41 * kmc can play the colophoner
20:21:42 <copumpkin> avenge: and have said how before, but I forgot
20:21:51 <mm_freak> anyway…  monads in C#/C++ aren't nearly as convenient as in haskell, but they are convenient in F#, because like haskell, it has syntactic support for them
20:21:52 <avenge> Yeah, but whenever I think to ask, they are not here.
20:21:53 <copumpkin> a colophonoscopy
20:22:08 <mm_freak> but it suffers from the same limitation:  you can't write mapM in F#
20:22:10 <ManateeLazyCat> revenantphx: Yes, like kmc said, haskell's thread is *very* lightweight, you can run thousand threads.... 
20:22:11 <kmc> mm_freak, but they changed the name to "workflows" to avoid association with us dirty hippies
20:22:16 <Funktorsalat> *nod* 'colophon' always seemed like a suspicious word to me
20:22:42 <kmc> revenantphx, when they enter blocking IO they are managed by the OS's asynchronous IO library, meaning you get the benefits of select() or epoll() without having to twist your code inside out
20:22:48 <mm_freak> ManateeLazyCat, revenantphx: you can run hundreds of thousands of them…  i've tried it
20:22:56 <mm_freak> even communicating threads
20:22:59 <NemesisD> so are there any exemplary haskell projects a newbie would be able to look at and understand mose of?
20:23:00 <mm_freak> but probably not with STM
20:23:06 <kmc> revenantphx, so it's reasonable to write a server where every client gets a dedicated thread with blocking IO
20:23:09 <copumpkin> just don't communicate with the main thread
20:23:13 <kmc> NemesisD, xmonad
20:23:23 <NemesisD> kmc: xmonad is simple?
20:23:27 <kmc> it's not too bad
20:23:28 <revenantphx> kmc: awesome
20:23:53 <kmc> take a look, if you get confused by something, ask here
20:23:55 <mm_freak> kmc: in general they're called "computation expressions"…  the term "workflow" is mostly used specifically for the 'async' class
20:23:57 <ManateeLazyCat> NemesisD: If you like GUI, there have many *simple* demo you can understand. :)
20:24:01 <kmc> mm_freak, ok
20:24:29 <mm_freak> and no, i don't know why a monadic value is a "computation expression" and "1 + 1" is not =)
20:24:35 <ManateeLazyCat> mm_freak: Yes, i use haskell's lightweight build a "irc rounter", damn fast..... :)
20:25:27 <kmc> yeah
20:25:31 <ManateeLazyCat> NemesisD: If you want study haskell, i recommend read book "Real World Haskell", there have many *simple* code you can practice.
20:25:58 <kmc> my 2¢ is that it's really hard to find a "plain English term" for "monad", and you're better off leaving it as something nobody has heard of
20:26:05 <kmc> that way you know you don't know it
20:26:21 <kmc> the downside being that a lot of misinformed hype gets attached to that word
20:26:27 <copumpkin> kmc: how about triple! :P
20:26:29 <mm_freak> kmc: yes, after all a monad is a type constructor
20:26:35 <copumpkin> people aren't scared of triples!
20:26:38 <copumpkin> ;)
20:26:46 <Funktorsalat> 'Bindoid"?
20:26:49 <Funktorsalat> o_O
20:26:52 <copumpkin> lol
20:26:56 <Pseudonym> "Warm fuzzy thing."  Serious nod./
20:27:02 <mm_freak> and "computation expression" is associated with "type constructors", too, which doesn't make a lot of sense
20:27:48 <Funktorsalat> actually 'Bindoid' would make the general nature of the concept clearer to people who know what Monoids are, maybe
20:28:00 <mm_freak> i wonder what they'll call arrows in F#++, probably something like "I/O expressions"
20:28:05 <kmc> hehe
20:28:19 <Funktorsalat> (general thingy that's defined by axioms)
20:28:29 <Funktorsalat> rather than something "concrete"
20:28:37 <mm_freak> or "workforks" =)
20:28:37 * kmc is not too happy with how Arrow works in Haskell, and would welcome the F# designers taking a crack at it
20:28:52 <mm_freak> kmc: in what way?
20:29:10 <kmc> i've often wanted to use the arrow syntax but couldn't implement 'arr'
20:29:13 <mm_freak> i'd find it great, if 'arr' were in a separate class
20:29:16 <kmc> yeah
20:29:30 <kmc> but the translation of the syntax uses 'arr' internally quite a bit
20:29:38 <tswett> Arr!
20:29:42 <copumpkin> class Pirate (~>) where arr :: (a -> b) -> (a ~> b)
20:30:05 <tswett> Suppose I'm defining some function, and internally, I want the type of something to depend on the type of one of the function's arguments or its return value.
20:30:11 <mm_freak> copumpkin: rather :~>
20:30:17 <heatsink> Assumed.
20:30:39 <tswett> Can I just give the function a type declaration using some variable, and then use that same variable when I'm declaring the type of the internal thing?
20:30:44 <mm_freak> tswett: sounds like you want type families (or multi-param type classes with functional dependencies)
20:30:47 <copumpkin> tswett: a more concrete example? you'd probably want a GADT and/or maybe a type family
20:31:10 <heatsink> tswett: Do you want the two values to have the same type?
20:31:50 <kmc> tswett, with the GHC extension ScopedTypeVariables you can
20:31:58 <kmc> in that case you have to put an explicit "forall" on the variable
20:32:06 <kmc> f :: forall a. a -> b;  f = ... use a here ...
20:32:13 <tswett> Suppose I have a function foo :: Meep -> Moop a, and another function bar :: Moop a -> Meep, and I'm defining the function blah :: Moop a -> Meep with blah = bar . foo . bar.
20:32:17 <tswett> Is that concrete enough?
20:32:35 <tswett> And I'd like the intermediate Moop value to have the same 'a' as the argument, since otherwise it's ambiguous.
20:32:58 <kmc> sounds like ScopedTypeVariables to me
20:33:15 <dmwit> ScopedTypeVariables or asTypeOf
20:33:21 <kmc> if you don't want to enable extensions, there are alternatives like asTypeOf
20:33:23 <kmc> :t asTypeOf
20:33:24 <lambdabot> forall a. a -> a -> a
20:33:27 <kmc> @src asTypeOf
20:33:27 <lambdabot> asTypeOf = const
20:33:31 <dmwit> blah x = (bar . foo . bar $ x) `asTypeOf` x
20:33:36 <dmwit> er
20:33:45 <heatsink> blah = case bar of bar -> bar . foo . bar
20:33:49 <dmwit> blah x = bar $ foo (bar x) `asTypeOf` x
20:33:51 <heatsink> >:)
20:34:01 <tswett> heatsink: oh, how cruel.  :)
20:34:01 <kmc> i like heatsink's recursive trick
20:34:04 <dmwit> heatsink: cute
20:34:07 <kmc> that's used some parts of the std lib
20:36:02 <Funktorsalat> blah = fix (\bar -> bar . foo .bar)?
20:36:08 <Funktorsalat> seems clearer
20:36:26 <Funktorsalat> insofar as this is clear at all
20:36:36 <heatsink> I think that doesn't do the same thing
20:36:44 <tswett> :t foldl const
20:36:45 <lambdabot> forall a b. a -> [b] -> a
20:37:17 <Funktorsalat> case bar of { bar -> (bar . foo . bar) }, right?
20:37:20 <Funktorsalat> the parsing
20:37:49 <heatsink> yeah
20:38:45 <Funktorsalat> hmm then I don't see the difference (actually I'm surprised 'bar' is even in scope after the 'case')
20:39:27 <heatsink> Funktorsalat: It's not.  They're two different variables called "bar"
20:39:57 <heatsink> case bar of f -> f . foo . f
20:40:00 <Funktorsalat> hmm kmc fooled me by calling it 'recursive' :p
20:40:18 <Funktorsalat> -Wall ftw
20:40:21 <tswett> Is there a way to tell GHC, "oi, f is polymorphic, let it relax"?
20:40:29 <Funktorsalat> (for the shadow warnings)
20:40:52 <Funktorsalat> tswett: NoMonoPatBinds, NoMonomorphismRestriction, RelaxedPolyRec
20:40:58 <revenantphx> one question
20:41:04 <Funktorsalat> the more the merrier j/k
20:41:05 <revenantphx> how the hell does the author of RWH has GHCi, version 6.8.3
20:41:18 <revenantphx> GHC is only up to 6.12.3 D:
20:41:22 <tswett> Can I just give f a type signature instead?
20:41:24 <revenantphx> oh wait
20:41:25 <revenantphx> screw me
20:41:33 * copumpkin screws revenantphx 
20:41:35 <megajosh2> > 8 > 12
20:41:35 <revenantphx> GODDAMN VERSION NUMBERS NOT STOPPING AT 10
20:41:36 <lambdabot>   False
20:41:56 <revenantphx> has someone implemented haskell on the jvm btw?
20:42:04 <revenantphx> I could totally see someone doing that
20:42:07 <Funktorsalat> the NoMonoPatBinds is for certain local bindings
20:42:18 <Funktorsalat> tswett: yes, why not?
20:42:21 <revenantphx> or .NET
20:42:23 * tswett nods.
20:42:33 <Funktorsalat> the things I mentioned are for *not* having to give a type sig
20:43:20 <kmc> oh hmm, maybe i was thinking of a different trick
20:43:20 <Funktorsalat> RelaxedPolyRec is for mutually recursive polymorphic functions
20:43:40 <kmc> tswett, are you trying to pass a polymorphic value as a function argument and use it at more than one specific type?
20:44:00 <mm_freak> revenantphx: not yet
20:44:12 <revenantphx> mm_freak: or parrot.
20:44:14 <tswett> kmc: this is an entirely hypothetical question.  But let's say yes.
20:44:17 <revenantphx> > >
20:44:18 <lambdabot>   <no location info>: parse error on input `>'
20:44:20 <kmc> tswett, in that case you need RankNTypes
20:44:27 <tswett> Oh.  Impressive.
20:44:37 <mm_freak> revenantphx: and i don't think you can either, because the type system of haskell is probably too rich…  or at least you couldn't write libraries
20:44:56 <kmc> :t let f g = (g (2 :: Int), g (3 :: Double)) in f
20:44:57 <lambdabot>     Couldn't match expected type `Double' against inferred type `Int'
20:44:57 <lambdabot>       Expected type: Double -> t
20:44:57 <lambdabot>       Inferred type: Int -> t1
20:44:58 <revenantphx> haha
20:45:08 <kmc> :t let f :: (forall a. (Num a) => a -> a) -> (Int, Double); f g = (g (2 :: Int), g (3 :: Double)) in f
20:45:09 <lambdabot> (forall a. (Num a) => a -> a) -> (Int, Double)
20:45:24 <kmc> tswett, ^^^^ f has a rank-2 type, which can't be inferred but can be written
20:45:33 <tswett> Cool and aiee.
20:45:46 <copumpkin> you can also get deeper and want impredicative types (related)
20:45:50 <kmc> > let f :: (forall a. (Num a) => a -> a) -> (Int, Double); f g = (g (2 :: Int), g (3 :: Double)) in (f (+2), f (*2))
20:45:50 <lambdabot>   ((4,5.0),(4,6.0))
20:45:56 <copumpkin> (but they're going away for a while :()
20:46:16 <kmc> 's okay, you can always make a wrapper for your impredicative types
20:46:37 <copumpkin> but I dun wanna!
20:46:56 <kmc> yeah i know man
20:46:57 <Funktorsalat> "<revenantphx> GODDAMN VERSION NUMBERS NOT STOPPING AT 10" <-- use the sort -V
20:47:05 <revenantphx> Funktorsalat: > >
20:47:09 <kmc> it's like the Java programmers saying you can always make a wrapper class for your first-class function :/
20:47:22 <kmc> GHC doesn't even have first-class existentials
20:47:22 <Funktorsalat> \x -> readProcess "sort" ["-V"] x
20:47:27 <Funktorsalat> ^^
20:48:00 <Funktorsalat> \x -> lines <$> readProcess "sort" ["-V"] (unlines x) -- probably a better idea
20:48:09 <Funktorsalat> dunno if 'sort' has -0
20:48:17 <copumpkin> -omnom
20:49:19 <revenantphx> kmc: "it's like the Java..." --> LOL
20:49:43 <revenantphx> Java Programmers tend to be jokes, even by my unknowledgeable high schooler standard
20:50:17 <revenantphx> Because you know, saving a file to multiple random places in the Program Files directory is a totally valid way of implementing redundancy
20:51:26 <kmc> revenantphx, Java itself places a very low bar.  some Java programmers are extremely smart and far exceed that bar
20:51:31 <revenantphx> some.
20:51:33 <revenantphx> But rarely.
20:51:56 <revenantphx> kmc: also, you know a great way to keep track of different version of your java code and merge edits?
20:52:00 <kmc> Java has a lot going for it, but most of its advantages are non-technical
20:52:04 <kmc> revenantphx, copy the directory?
20:52:09 <revenantphx> according to the java class at my school, mediawiki
20:52:11 <kmc> hahaha
20:52:15 <revenantphx> I've tried to explain git or hg to them.
20:52:17 <revenantphx> They won't listen.
20:52:19 <kmc> that's not the dumbest idea i've heard
20:52:21 <revenantphx> TT_TT
20:52:25 <kmc> i mean, it's better than "copy the directory"
20:52:34 <revenantphx> I dont mean the teacher, I mean the students thought that'd be a good idea.
20:52:35 <kmc> i know people who use cp as their vcs
20:52:41 <revenantphx> kmc: haha
20:52:47 <revenantphx> who needs cp when you have mv and rm!
20:52:52 <Funktorsalat> kmc: java, the great leveller? o_O
20:53:07 <djahandarie> revenantphx, I think you got that backwards...
20:53:11 <Funktorsalat> assuming it ties these smart peoples's hands...
20:53:16 <revenantphx> djahandarie: > >
20:54:31 <revenantphx> Based on the Python paradox...
20:54:37 <revenantphx> you should NEVER look for java programmers.
20:54:48 <ivanm> there's a python paradox?
20:54:49 <revenantphx> since the chance of you getting good java employees... is low.
20:54:50 <kmc> paul graham likes calling things paradoxes that aren't paradoxes
20:54:54 <kmc> http://www.paulgraham.com/pypar.html
20:55:08 <ivanm> revenantphx: and isn't it "who needs mv when you have cp and rm" ?
20:55:09 <kmc> revenantphx, right, you should hire Haskell programmesr and make them write Java
20:55:10 <revenantphx> It's not really a paradox anyhow
20:55:18 <revenantphx> kmc: XD
20:55:18 <ivanm> kmc: oh, I know of his blug paradox...
20:55:18 <Funktorsalat> well, a paradox is only an *apparent* contradiction AIUI
20:55:28 <Funktorsalat> it doesn't stop being one after being explained
20:55:29 <djahandarie> kmc, probably just because it alliterated with python in this case.
20:55:35 <revenantphx> djahandarie: ^
20:55:35 <kmc> every time reddit gets its panties all twisted over a job add that makes a passive mention of Haskell
20:55:39 <kmc> i have to point this out
20:55:47 <kmc> ad*
20:55:51 <kmc> passing*
20:55:51 <kmc> bleh
20:55:54 <Funktorsalat> but granted, the blub 'paradox' isn't even apparently a contradiction
20:56:10 <revenantphx> You know ,that PyPar is pretty true imo.
20:56:14 <revenantphx> It's kind of what's ruined Ruby.
20:56:16 <revenantphx> (Rails)
20:56:20 <kmc> some paradoxes are true contradictions within a particular system, like Russel's for naive set theory
20:56:25 <revenantphx> Web programmers are not compatible with ruby programmers.
20:56:32 <revenantphx> two totally different thought processes.
20:56:37 <Funktorsalat> kmc: some
20:56:48 <ivanm> kmc: what do you have to point what out?
20:56:50 <revenantphx> web programmers are willing to mix 10 different languages to make a house of cards that "just works"
20:56:59 <Funktorsalat> kmc: but I think they rise to the status of 'antinomy' then
20:57:05 <revenantphx> ruby programmers (real ones) are interested in "beauty" and "simplicity"
20:57:07 <Funktorsalat> if you have to use foreign words ;)
20:57:12 <revenantphx> in other words, stuff other than getting work done.
20:57:28 <monochrom> As Dijkstra says, "where is Russell's paradox?" http://userweb.cs.utexas.edu/users/EWD/transcriptions/EWD09xx/EWD923a.html
20:57:31 <revenantphx> a lot of "rails people" also have no f'ing clue.
20:57:41 <kmc> ivanm, that a clever hiring manager might ask for Haskell programmers with no intent of giving them Haskell work
20:57:50 <djahandarie> Good old Dijkstra
20:58:01 <ivanm> kmc: ahhh, right
20:58:04 <revenantphx> djahandarie: ^
20:58:05 <revenantphx> hehehe
20:58:07 <revenantphx> always cracks me up
20:59:18 <djahandarie> kmc, I'm not sure how many Haskell programmers would take a java job after going to an interview expecting a Haskell job
20:59:23 <kmc> indeed
20:59:31 <kmc> but you might could trick a few of them for a few months
20:59:36 <kmc> i'm not saying it's actually a good strategy
20:59:40 <kmc> but that it might be tried
20:59:44 <Funktorsalat> monochrom: well, the problem is that the rule of unrestricted comprehension asserts that you a set for some arbitrary property *does* exist
20:59:49 <revenantphx> hiring haskell programmers at all for real work seems liek a bad idea.
20:59:55 <kmc> more commonly you see "Clojure/Scala programmer wanted!!! to maintain our huge existing Java codebase"
20:59:56 <ivanm> kmc: yeah, doing that would _really_ piss dibblego off ;-)
21:00:01 <Funktorsalat> monochrom: and this rule seemed intuitive to people
21:00:07 <revenantphx> The work time would look something like:
21:00:23 <revenantphx> 19 hours: construct an implementation of monads and all that sutff
21:00:28 <revenantphx> 1 hour: play minesweeper
21:00:33 <revenantphx> 1 hour: finish work
21:00:39 <revenantphx> 15 min: say you havent finished yet
21:00:52 <Funktorsalat> monochrom: the 'set of all sets that don't contain themselves' is an expression in naive set theory, not an equation that may or may not have a solution
21:00:53 <revenantphx> 15 min: play more minesweeper
21:01:00 <revenantphx> 1 hour: write minesweeper bot in haskell
21:01:13 <megajosh2> You mean haskell programmers are just too devoted to Minesweeper to get work done?
21:01:26 <revenantphx> megajosh2: no XD
21:01:31 <monochrom> Funktorsalat: no, not that paradox. the barber one.
21:01:53 <revenantphx> monochrom: the set in that case is the set of all people who don't shave others I think
21:01:59 <revenantphx> where each person is a set of people they shave
21:02:02 <Funktorsalat> monochrom: well, it takes the barber story as an example story for russel's
21:02:12 <revenantphx> and a barber is a person who's shavee list is not empty
21:02:19 <ivanm> megajosh2: nah, it's more sudoku or something rather than minesweeper
21:02:32 <djahandarie> Or chatting on #haskell
21:02:39 <ivanm> then again, you can use minesweeper for circuit representations, and it then becomes NP-complete (IIRC)
21:02:48 <Funktorsalat> I agree that the barber problem is easier to resolve in the formulation "decide whether such a (town,barber) exists"
21:02:52 <revenantphx> ^ ivanm aaaaand there we go...
21:03:15 <revenantphx> leave it to haskell programmers to fly by the fun in minesweeper and start evaluating it mathmatically
21:03:23 <revenantphx> "so Phil, did ya finish that java applet?"
21:03:30 <revenantphx> "no, but I proved minesweeper is NP-complete!"
21:03:55 <djahandarie> revenantphx, you seem to be mistaking Haskell programmers with people who have no work ethic
21:04:15 <revenantphx> djahandarie: true
21:04:18 <revenantphx> sorry > <
21:04:38 <djahandarie> I can say that having a non-Haskell day job is really annoying though
21:04:49 <revenantphx> djahandarie: heh
21:06:14 <djahandarie> Works fine for me since I'm just a student though, and I don't live anywhere near Galois ;)
21:06:24 <Funktorsalat> imho russel's antinomy is pretty deep because people intuitively *do* use such inconsistent informal logics
21:06:49 <Funktorsalat> (where you can quantify over 'everything' and thus get contradictions)
21:06:53 <ivanm> djahandarie: I would hope not, seeing as how Galois died quite a while back...
21:06:54 <ivanm> ;-)
21:07:05 <mm_freak> ivanm: minesweeper is a turing-complete programming language, that's what you mean
21:07:06 <monochrom> I have long learned that a paradox is a theorem that gives people jiffies. For example the Banach-Tarski theorem.
21:07:33 <Funktorsalat> e.g. "can God make a wall that's so though that he can't tear it down"
21:07:36 <ivanm> mm_freak: I was at a talk being where someone detailed how you could relate minesweeper to circuit design IIRC
21:07:48 <djahandarie> ivanm, you haven't heard of post-mortem employment? It's the bomb today!
21:07:57 <Funktorsalat> (leading to a contradiction with omnipotence either way)
21:08:44 <Funktorsalat> seems like the same impredicative quantification mistake
21:09:02 <mm_freak> ivanm: ah, ok
21:09:13 <revenantphx> Funktorsalat: you know the omnipotence/omniscience contradiction?
21:09:24 <Funktorsalat> revenantphx: nope
21:09:25 <mm_freak> anyway…  minesweeper 4D is much more interesting than its traditional 2D counterpart =)
21:09:34 <revenantphx> okay
21:09:36 <monochrom> 4D??!!!
21:09:47 <djahandarie> monochrom, your mind just got blown
21:09:48 <revenantphx> so if god is omnipotent, then for a given action E god can do either A or B without restriction
21:09:56 <monochrom> what user interface do you even use for 4D?
21:10:01 <mm_freak> monochrom: http://www.onlinespiele-1.de/denkspiele/4d_minesweeper/index.php
21:10:04 <ivanm> mm_freak: the way the mines get laid out you can represent current flow, logic gates, etc.
21:10:17 <revenantphx> and if he is omniscient, he knows whether he will do either A or B before he does.
21:10:32 <mm_freak> ivanm: i think i have a picture of how that works
21:10:36 <revenantphx> therefor, if he is omniscient, he cannot be omnipotent since he has no choice between A or B
21:10:49 <ivanm> I can dig up the cut-down paper he handed out on it later on if you want
21:10:59 <ivanm> I might even have the abstract, etc. he emailed around
21:11:04 <ivanm> (it was a journal club talk)
21:11:13 <revenantphx> basically the concept of predetermination breaks the concept of omnipotence.
21:11:20 <mm_freak> ivanm: well, honestly i'm not that interested in minesweeper =)
21:11:20 <revenantphx> it
21:11:22 <Funktorsalat> revenantphx: I don't see how the latter is a contradiction to omnipotence
21:11:29 <mm_freak> ivanm: i prefer rubik's cube
21:11:33 <ivanm> mm_freak: heh, fair enough
21:11:44 <revenantphx> Funktorsalat: If God is omniscient, then he is aware of the future correct?
21:11:51 <revenantphx> so if he "knows" he will take action A, 
21:11:57 <revenantphx> then he doesn't really have a choice between A or B
21:12:04 <revenantphx> it's an illusory choice.
21:12:17 <revenantphx> and if he doesn't have the power to choose a course of action for a situation, he can't be omnipotent.
21:12:22 <Funktorsalat> (but then I'm a strong believer in 'objective determinism' being a meaningless concept, and thus having nothing to do with anything, free will in particular ;))
21:12:34 <Adamant> that assumes God is bound by your logic.
21:12:38 <revenantphx> Adamant: touché
21:12:39 <mm_freak> (there is even rubik's hypercube, a 4D variant and a 5D variant…  more scaringly people have actually solved them)
21:12:51 <revenantphx> http://www.superliminal.com/cube/cube.htm
21:13:16 <Adamant> we already pick and choose logics to suit us, and we are decidedly not omniscient or omnipotent.
21:13:17 <Funktorsalat> revenantphx: but anyway, a description of what will happen doesn't have any force
21:13:23 <megajosh2> 4D? You mean it not only pops out at you, but your chair vibrates?
21:13:23 <monochrom> God, 5D rubik's cube.
21:13:45 <Funktorsalat> IMHO it's a mistake to interpret a description as 'pushing you around'/limiting your choice
21:13:58 <monochrom> I don't know in what sense God is omnipotent but only God can play 5D rubik's cube...
21:14:06 <Funktorsalat> it's just a tautology that you will do what you will do :E
21:14:13 <Funktorsalat> it has nothing to do with choice
21:14:29 <revenantphx> monochrom: ^ this
21:14:38 <megajosh2> Wow I'm seriously tired. That makes absolutely no sense whatsoever
21:15:14 <revenantphx> btw
21:15:22 <revenantphx> that Magic Cube makes a little sense until you realize...
21:15:27 <revenantphx> you can't see all the colors at onc
21:16:06 <mm_freak> revenantphx: exactly…  you're viewing it from (the 4D equivalent of) "inside"
21:16:11 * tswett ponders generalizing the Rubik's cube to higher dimensions.
21:16:14 <mm_freak> so you can't see all hyperfaces
21:16:21 <revenantphx> 4D hurts my head.
21:16:23 <revenantphx> > >
21:16:24 <lambdabot>   <no location info>: parse error on input `>'
21:16:24 <copumpkin> there's a 5d rubik's cube online too
21:16:26 <pps> revenantphx: Also you assume that God is bound by time: you say that God will (in the future) do something and he knows what it will be (in the future), but it God exists outside time, how can he be bound by the limits of it?
21:16:28 <mm_freak> lol
21:16:35 <revenantphx> pps: thats true
21:16:42 <mm_freak> copumpkin: i haven't found an online one, just a windows program
21:16:43 <revenantphx> pps: I also assume effect is bound by cause
21:16:45 <monochrom> FRP
21:16:46 <mm_freak> so i haven't tried it
21:16:47 <copumpkin> here, if you want some brainfuck:
21:16:48 <copumpkin> http://www.gravitation3d.com/magiccube5d/
21:16:53 <revenantphx> A world in which effect does not follow cause is fun XD
21:17:04 <Adamant> xkcd knows
21:17:08 <megajosh2> I know I was here for something... now I can't remember
21:17:09 <mm_freak> revenantphx: quantum mechanics
21:17:13 * tswett ponders generalizing the Rubik's cube to lower dimensions.
21:17:16 <Funktorsalat> pps: yep I'm taking this eternalistic view too in thinking that descriptions don't have anything to do with choice
21:17:21 <monochrom> in soviet russia, cause follows effect
21:17:22 <pps> revenantphx: not necessarily, since God might not create a world that actually is bound to cause and effect
21:17:27 <pps> but only appears to 
21:17:34 <revenantphx> pps: oh god
21:17:41 <mm_freak> tswett: you can't, because a rubik's square can only be turned around the center
21:17:44 <revenantphx> why is this channel now about mindfuck?
21:17:48 <Funktorsalat> (you don't need to be god to formulate the world as a static spacetime ^^)
21:17:55 <tswett> I think I've successfully figured out what a Rubik's square and a Rubik's line segment would look like.
21:17:57 <mm_freak> tswett: so it's a quite uninteresting puzzle =)
21:18:04 <revenantphx> tswett: ... > >?
21:18:12 <tswett> And a Rubik's point, I guess.
21:18:15 <revenantphx> what about the Rubik's point!
21:18:19 <revenantphx> It has one potential solution
21:18:29 <mm_freak> rubik's nothing
21:18:32 <mm_freak> sorry
21:18:34 <tswett> A Rubik's square is composed of nine little squares, and each non-center row of squares can be flipped.
21:18:34 <mm_freak> rubik's Nothing
21:18:37 <revenantphx> http://video.google.com/videoplay?docid=-8946271664289065673#
21:18:41 <revenantphx> MIND FFFFFFFFUCK
21:18:43 <tswett> A nothing has negative infinity dimensions.
21:19:05 <tswett> A Rubik's line segment is composed of three little line segments, and the outer two can be rotated about themselves.  Which does nothing.
21:19:08 <mm_freak> tswett: on the 4D cube site you find a 2D square, too, but read its comments
21:19:13 <tswett> A Rubik's point is jsut a point; you can't do anything with it.
21:19:13 <Funktorsalat> tswett: minus one actually
21:19:17 <mm_freak> it's not rubik's equivalent
21:19:21 <tswett> Right, minus one.
21:19:35 <revenantphx> what about the Rubik's nothing.
21:19:41 <tswett> So Rubik's Nothing has nothing, minus one nothing.
21:19:43 <Funktorsalat> tswett: at least if you want to continue the "n points in general position span an n-1 dimensional thing" series =)
21:19:48 <revenantphx> It has zero solutions :D
21:20:12 <mm_freak> tswett: a rubik's line can't be changed at all
21:20:19 <tswett> Right.
21:20:27 <revenantphx> mm_freak: you coule swap the points on either end
21:20:32 <Funktorsalat> linux solves the rubiks line in...
21:20:33 <tswett> No, you couldn't.
21:20:35 <revenantphx> A - B - C => C - B - A
21:20:35 <mm_freak> revenantphx: that's not turning
21:20:40 <revenantphx> ?
21:20:40 <tswett> You could only rotate them about a line going through the center of the line.
21:20:41 <mm_freak> revenantphx: you can't turn in 1D
21:20:46 <revenantphx> mm_freak: ah good point
21:21:01 <copumpkin> tswett: http://www.gravitation3d.com/magiccube5d/anatomy.html
21:21:09 <tswett> Remember, all center pieces are immobile.
21:21:30 <mm_freak> well, i guess i could solve the 4D cube, if you give me a few hours or days
21:21:35 <Funktorsalat> (the zero polynomial has negative infinity as its degree, though ;))
21:21:47 <mm_freak> but the 5D variant…  i'd probably give up, because it sucks =)
21:21:52 <Funktorsalat> to continue deg(p*q) = deg(p) + deg(q)
21:23:09 <mm_freak> tswett: rotationIn1D = id
21:23:12 <mm_freak> ;)
21:23:26 <mm_freak> there is no "center of the line"
21:23:41 <tswett> You say it as if I did not already know everything.  :P
21:23:54 <tswett> It's a line segment.  Line segments have centers.
21:24:06 <tswett> And it's all moot because rotating a line segment about itself does nothing.
21:24:11 <Funktorsalat> the affine line has no center, the linear line has
21:24:21 <Funktorsalat> *out of silly smilies*
21:24:42 <mm_freak> tswett: that doesn't make sense to me…  what happens if you rotate by 45 "degrees" (whatever that means in 1D)?
21:25:07 <tswett> Nothing, because rotating a line segment about itself does nothing, ever.
21:25:23 <mm_freak> which axis?
21:25:33 <tswett> It's a line segment; you can use it as an axis.
21:25:44 <Funktorsalat> mm_freak is talking about an intrinsic line segment without any surrounding space
21:25:48 <Funktorsalat> I think
21:25:48 <pps> You can wrap an axis around itself?
21:25:53 <mm_freak> Funktorsalat: yes
21:25:54 * tswett shrugs.
21:26:05 <tswett> rotationIn1D = id.  :P
21:26:12 <mm_freak> that's why the rotation doesn't make sense to me =)
21:26:14 <revenantphx> pps: think about rotating a cylinder around the line segment representing its height through the middle
21:26:15 <revenantphx> except,
21:26:16 <mm_freak> actually:
21:26:18 <Funktorsalat> it has a single isometry, the flip
21:26:19 <revenantphx> the cylinder is infinitely thin
21:26:22 <mm_freak> rotationIn1D :: a
21:26:32 <mm_freak> (let's see if you can figure that one out =P)
21:26:41 <freedrull> are there any other options for audiowork in haskell besides portaudio
21:26:42 <Funktorsalat> (but flips usually aren't counted as 'rotations', so yes, it has no rotations other than id)
21:26:46 <revenantphx> rotationIn1D a = a
21:26:47 <revenantphx> > >
21:26:48 <lambdabot>   <no location info>: parse error on input `>'
21:26:59 <mm_freak> revenantphx: that's of type a -> a
21:27:00 <mm_freak> not a
21:27:03 <revenantphx> oh
21:27:05 <revenantphx> crap wait
21:27:10 <revenantphx> it's not even a function
21:27:12 <tswett> mm_freak: I think you mean type RotationIn1D = forall a. a.
21:27:15 <revenantphx> ..><
21:27:17 <copumpkin> rotationIn1d = rotationIn1d
21:27:17 <copumpkin> duh
21:27:20 <mm_freak> revenantphx: it is, if you want it to be =)
21:27:30 <revenantphx> copumpkin: and that = ghci freezing up
21:27:30 <pps> revenantphx: that still doesn't move anything in relation to anything else
21:27:36 <mm_freak> 'a' can be anything, including a function
21:27:36 <copumpkin> revenantphx: pssh
21:27:51 <revenantphx> copumpkin: kinda like telling scheme (define p (p))
21:27:57 <mm_freak> tswett: rotationIn1D :: RotationIn1D
21:27:58 <revenantphx> and then doing (p)
21:27:58 <mm_freak> =P
21:28:39 <Funktorsalat> data SO_One_R = SO_One_R o_O
21:29:08 <Funktorsalat> @let (o_O) = undefined
21:29:09 <lambdabot>  Defined.
21:29:15 <Funktorsalat> cool that works
21:29:18 <Axman6> === data SO_One_R right?
21:29:32 <revenantphx> > o_)
21:29:33 <lambdabot>   <no location info>: parse error on input `)'
21:29:37 <revenantphx> > o_O
21:29:38 <lambdabot>   No instance for (GHC.Show.Show GHC.Prim.Any)
21:29:38 <lambdabot>    arising from a use of `M860...
21:29:46 <Axman6> o.O
21:29:48 <Funktorsalat> Axman6: hmm no, I mean a single nullary constructor
21:29:53 <Funktorsalat> Axman6: not no constructors at all
21:29:54 <revenantphx> > 1 + o_O
21:29:55 <lambdabot>   No instance for (GHC.Num.Num GHC.Prim.Any)
21:29:55 <lambdabot>    arising from the literal `1' ...
21:30:02 <revenantphx> > 1 + Maybe o_O
21:30:03 <lambdabot>   Not in scope: data constructor `Maybe'
21:30:08 <monochrom> > const "whee" o_O
21:30:09 <lambdabot>   "whee"
21:30:13 <monochrom> works
21:30:28 <revenantphx> 1 + pure  o_O :: Maybe o_O
21:30:33 <Axman6> Funktorsalat: "data SO_One_R" is the same as writing "data SO_One_R = SO_One_R"
21:30:49 <Funktorsalat> Axman6: yes, the emoticon wasn't part of the code snippet anymore
21:30:49 <revenantphx> > fibs
21:30:50 <lambdabot>   Not in scope: `fibs'
21:30:58 <monochrom> > let Nothing = Just o_O in "whee again"
21:30:58 <Funktorsalat> err wait
21:30:59 <lambdabot>   "whee again"
21:31:07 <Funktorsalat> Axman6: "data A" is an empty data decl
21:31:15 <Funktorsalat> unline data A = A
21:31:17 <mm_freak> revenantphx: you should read about the curry-howard isomorphism
21:31:18 <Axman6> no, it has a single constructor, called A
21:31:20 <mm_freak> quite interesting
21:31:21 <revenantphx> @define fibs 0:1:[ a + b | (a, b) <- zip fibs . tail fibs]
21:31:28 <revenantphx> ...
21:31:33 <tswett> "data SO_One_R" surely has no data constructors.
21:31:39 <revenantphx> @define fibs 0:1:[ a + b | (a, b) <- zip fibs (tail fibs)]
21:31:43 <tswett> Unless that was stupidly changed recently.
21:31:44 <monochrom>  @define is the same as @undefine
21:31:55 <revenantphx> @define 1 0
21:31:55 <Funktorsalat> tswett: it wasn't
21:31:59 <revenantphx> @define x = 10
21:32:01 <Axman6> hmm, i thought that that's how RealWorld worked
21:32:01 <revenantphx> @define x 10
21:32:03 <monochrom>  @undefine clears all @let definitions
21:32:05 <revenantphx> it doesnt work...
21:32:16 <revenantphx> @let fibs = 0:1:[ a + b | (a, b) <- zip fibs (tail fibs)]
21:32:17 <lambdabot>  Defined.
21:32:20 <revenantphx> fibs
21:32:20 <monochrom> But I am invisible and invincible.
21:32:21 <revenantphx> > fibs
21:32:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:32:24 <copumpkin> Axman6?
21:32:24 <Funktorsalat> Axman6: just try it, it'll tell you to enable EmptyDataDecls
21:32:38 <Axman6> my mistake then i guess
21:32:39 <revenantphx> @let 0 = 1
21:32:40 <lambdabot>  Defined.
21:32:43 <revenantphx> > 0
21:32:44 <lambdabot>   0
21:32:47 <revenantphx> awwww...
21:32:59 <revenantphx> @let 1 + 1 = 11
21:32:59 <lambdabot>  <local>:1:15:
21:32:59 <lambdabot>      Ambiguous occurrence `+'
21:32:59 <lambdabot>      It could refer to either `L...
21:33:07 <revenantphx> @let (1 + 1) = 11
21:33:08 <lambdabot>   Parse error in pattern:
21:33:10 <handonson> what would be the simplest way to combine four Word8s and make a Word32?
21:33:11 <revenantphx> > >
21:33:11 <lambdabot>   <no location info>: parse error on input `>'
21:33:29 <copumpkin> handonson: you're probably working on ByteStrings?
21:33:31 <Axman6> shift and add?
21:33:36 <copumpkin> handonson: in that case, use Binary.Get
21:33:37 <Axman6> or shift and or
21:33:39 <copumpkin> Data.Binary.Get that is
21:33:44 <handonson> copumpkin: no
21:33:49 <copumpkin> otherwise, yeah, but it depends on your endianness
21:33:55 <handonson> http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/Graphics-UI-SDL-Color.html
21:33:56 <copumpkin> (what Axman6 said)
21:33:58 <revenantphx> handonson: memcpy their constants into an empty 32 bit integer via a pointer
21:33:59 <tswett> Do it the C way: put the Word8s into an array, cast the array pointer to a Word32 pointer, read it.  :P
21:34:01 <revenantphx> contents*
21:34:06 <revenantphx> tswett: yep yep
21:34:13 <Axman6> revenantphx: you're new here aren't you
21:34:14 <tswett> Wait, really?
21:34:16 <Funktorsalat> revenantphx: "let 0=1 in ..." doesn't define 0; 0 is a literal and it's just a failed pattern match
21:34:20 <revenantphx> tswett: kinda
21:34:21 <handonson> i'm trying to convert color to pixel with alpha of 0xFF
21:34:29 <revenantphx> tswett: In C you could do this
21:34:36 <copumpkin> revenantphx: you can in haskell too
21:34:38 <revenantphx> int32_t desiredval;
21:34:39 <copumpkin> we'll just ostracize you
21:34:45 <Cale> hehe
21:34:51 <Funktorsalat> hmm though I wonder why this is a valid statement ("let 0=1") by itself at all 
21:34:51 <Axman6> > let x@0 = 1 in x
21:34:51 <revenantphx> and then for each 8 byte number, memcpy it into &desiredval
21:34:52 <lambdabot>   *Exception: <interactive>:1:145-151: Irrefutable pattern failed for pattern...
21:34:59 <copumpkin> revenantphx: memcpy is overkill
21:35:12 <revenantphx> copumpkin: don't be silly XD
21:35:14 <Funktorsalat> or actually it may succeed depending on the Num instance
21:35:18 <copumpkin> cast your desiredval to an unsigned char pointer, and index into it
21:35:20 <revenantphx> memcpy is *fun*
21:35:38 <revenantphx> copumpkin: now thats just inneficient
21:35:40 <handonson> that Pixel is a Word32 in the format of ARGB
21:35:43 <revenantphx> and besides, I prefer uint8_t
21:35:57 <copumpkin> revenantphx: why inefficient?
21:36:02 <handonson> and i want to write a function (preferably a one-liner) that converts color into pixel
21:36:06 <Cale> Funktorsalat: Consider f 0 = 1, and consider x = 1 -- the reason that 0 = 1 is a valid definition is basically because those two are
21:36:15 <revenantphx> because all (char*) desval[i] = myByte does
21:36:18 <revenantphx> is copy myByte into it
21:36:20 <revenantphx> > >
21:36:21 <lambdabot>   <no location info>: parse error on input `>'
21:36:23 <Cale> Funktorsalat: (and it would be a special case to rule it out then)
21:37:00 <copumpkin> revenantphx: my whole point is that you're going to be setting those bytes elsewhere anyway, so you have the cost of the memory store, then the cost of a function call (to memcpy), then the cost of memcpy deciding what to do to do an efficient bulk copy, and then a return
21:37:02 <revenantphx> if you had the original 8 bit numbers in an array as input
21:37:05 <revenantphx> 8 byte*
21:37:07 <copumpkin> revenantphx: instead, what I'm saying is just do four memory stores :P
21:37:07 <Cale> It's a failing pattern match, but since all pattern bindings match lazily, the pattern is actually never even tried.
21:37:13 <revenantphx> then you can just memcpy from it, itself
21:37:29 <handonson> i don't think they are
21:37:32 <Funktorsalat> Cale: hmm I was just confused by the lack of any variables on the LHS...
21:37:37 <revenantphx> anyhow, back to RWH
21:37:48 <Funktorsalat> making the statement (do block statement) completely inert
21:37:52 * Axman6 thinks that's a good idea
21:37:54 <Funktorsalat> but sure, why not
21:37:55 <handonson> it's a value made up by the Color constructor
21:38:10 <monochrom> Yes, people are usually confused by empty sets, empty lists, empty presence of variables...
21:38:49 <pps> handonson: doesn't mapRGBA do what you need?
21:39:03 <handonson> what is that?
21:39:18 <pps> handonson: http://hackage.haskell.org/packages/archive/SDL/latest/doc/html/Graphics-UI-SDL-Video.html#v:mapRGBA
21:39:35 <handonson> aw.
21:39:38 <handonson> not really.
21:39:45 <pps> Oh, sorry.
21:39:56 <handonson> first, i'm going to use this in a pure function
21:40:13 <handonson> but that one is an IO
21:40:42 <pps> Yeah. I thought since you were already using SDL you might use it.
21:40:49 <djahandarie> dcoutts_, I think you misspelled "program" as "peogram" in your well-typed bkig oist
21:40:58 <djahandarie> Ironic
21:41:00 <djahandarie> blog post*
21:41:02 <Funktorsalat> Cale: btw, about astar... the Eq and Ord stuff should be unnecessary if your graph is a tree, no?
21:41:07 <monochrom> heh peogram
21:41:23 <Funktorsalat> I was reusing your astar for a branch&bound tree search ;)
21:41:31 <Axman6> @hoogle shift
21:41:31 <lambdabot> Data.Bits shift :: Bits a => a -> Int -> a
21:41:31 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
21:41:31 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
21:41:46 <lispy> oh, astar is A*
21:41:50 <lispy> man, I was really lost
21:42:01 <Funktorsalat> and ended up implementing Eq and Ord for my nodes with an nodeId that's created using unsafePerformIO ;)
21:42:17 <lispy> Funktorsalat: NO.
21:42:23 <lispy> Funktorsalat: Bad Salat!
21:42:33 <lispy> ?slap Funktorsalat 
21:42:33 * lambdabot clobbers Funktorsalat  with an untyped language
21:42:37 <Funktorsalat> lispy: why?
21:42:41 <Axman6> > let f :: [Word8] -> Word32; f = sum . map (\(x,s) -> flip shiftL s . fromIntegral $ x) . zip [24,16,8,0] in f [0xff,0x00,0xff,0x00]
21:42:42 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
21:42:42 <lambdabot>         against inferred type...
21:42:46 <handonson> is | bitwise OR?
21:42:47 <monochrom> is "Funktorsalat" a german variation?
21:42:49 <lispy> Funktorsalat: I'm just being an unsafe bigot
21:43:03 <lispy> handonson: nope
21:43:04 <Funktorsalat> lispy: I was using the pure astar and didn't want to put the whole thing into ST monad just for essentially meaningless nodeIds
21:43:13 <lispy> handonson: it separates guards
21:43:18 <handonson> oh, yeah.
21:43:19 <Funktorsalat> that's probably disable some optimizations ghc does
21:43:22 <Funktorsalat> *that'd
21:43:22 <handonson> what is bitwise OR?
21:43:25 <Axman6> > let f :: [Word8] -> Word32; f = sum . map (\(x,s) -> flip shiftL s . fromIntegral $ x) . zip [24,16,8,0] in f [16,16,16,16]
21:43:26 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
21:43:26 <lambdabot>         against inferred type...
21:43:32 <Axman6> phail
21:43:33 <lispy> handonson: there is Data.Bits IIRC
21:43:39 <Axman6> > let f :: [Word8] -> Word32; f = sum . map (\(x,s) -> flip shiftL s . fromIntegral $ x) . zip [24,16,8,0] in f [16,16,16,16 :: Word8]
21:43:39 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
21:43:40 <lambdabot>         against inferred type...
21:43:40 <lispy> handonson: look in there for the bitwise operators
21:43:53 <Axman6> hmm
21:43:58 <Axman6> :t fromIntegral
21:43:59 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:44:15 <lispy> handonson: I think it's .||.
21:44:18 <Axman6> > fromIntegral (4 :: Word8) :: Word32
21:44:18 <lambdabot>   4
21:44:19 <lispy> ?google .||.
21:44:19 <lambdabot> No Result Found.
21:44:36 <Axman6> :t (.|.)
21:44:37 <lambdabot> forall a. (Bits a) => a -> a -> a
21:44:39 <lispy> handonson: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Bits.html
21:44:43 <lispy> handonson: (.|.)
21:44:46 <Axman6> > 16 .|. 4
21:44:47 <lambdabot>   Ambiguous type variable `a' in the constraint:
21:44:47 <lambdabot>    `Data.Bits.Bits a'
21:44:47 <lambdabot>      a...
21:44:52 <Axman6> > 16 .|. 4 :: Word32
21:44:53 <lambdabot>   20
21:45:10 <Funktorsalat> lispy: but seriously, I don't see anything wrong with a smart node constructor using an IORef global to this run of the astar
21:45:30 <Funktorsalat> (and making a nodeId, then bumping the IORef)
21:46:06 <lispy> Funktorsalat: could you replace it with runST . mkNodeId ?
21:46:32 <Funktorsalat> no, the runST would have to be around the aStar call
21:46:41 <revenantphx> huh.
21:46:51 <revenantphx> These zippers are an interesting concept
21:46:54 <monochrom> heh
21:46:57 <Funktorsalat> since each search node needs to have a different id during a run of the astar
21:46:57 <revenantphx> but I still dont see how the state will be maintained.
21:47:08 <Cale> Funktorsalat: Ord is necessary because the algorithm internally uses a datastructure which requires Ord
21:47:16 <revenantphx> not quite through the wikibook page tho
21:47:28 <revenantphx> the diagrams are VERY helpful though > >
21:47:35 <Funktorsalat> Cale: yep, but comparing nodes only seems necessary for searching a non-tree graph
21:47:36 <kmc> revenantphx, well, a zipper for a list is just a pair of (elements i've seen so far, remaining elements)
21:47:45 <Cale> Oh, of course, yes
21:47:46 <kmc> the first of those two being in reverse order
21:47:51 <Cale> Ermm...
21:47:55 <revenantphx> kmc: for a list it really is like a zipper!
21:48:00 <kmc> yes :)
21:48:17 <revenantphx> interesting
21:48:18 <Cale> Well, there's still the priority search queue
21:48:23 <revenantphx> but how is the data stored > >...
21:48:29 <kmc> revenantphx, it's just a pair of lists
21:48:32 <kmc> so, same way lists are stored
21:48:33 <Cale> You might be able to do away with it
21:48:36 <revenantphx> right
21:48:37 <kmc> it's just ([a], [a])
21:48:40 <revenantphx> kmc: but you can't do
21:48:42 <Funktorsalat> Cale: oh, right
21:48:44 <revenantphx> a = [1,2,3,4]
21:48:44 <kmc> or probably a newly defined type equivalent to that
21:48:50 <revenantphx> a = 0: a
21:48:57 <Funktorsalat> Cale: that was probably why it didn't like the bogus Ord instance I tried first ;)
21:49:00 <kmc> revenantphx, you pass them to and from functions
21:49:05 <monochrom> priority search queue is the answer to the meaning of my life
21:49:06 <Funktorsalat> but it works nicely with the unsafe node ids...
21:49:12 <revenantphx> kmc: so it's kind of "state in motion"?
21:49:17 <kmc> the simplest way to simulate state of type T is just a function of type T -> T
21:49:23 <Funktorsalat> (and compare = comparing nodeId)
21:49:35 <kmc> if you want "results" too then it becomes T -> (S, T)
21:49:40 <revenantphx> right...
21:49:52 <kmc> and if you wrap that in a newtype so you can use (>>=) and "do" syntax with it
21:50:00 <kmc> then we'd call that the (State T) monad
21:50:04 <kmc> @unmtl State t a
21:50:04 <lambdabot> t -> (a, t)
21:50:42 <kmc> "state in motion" is a good phrase
21:51:34 <monochrom> research in motion: Wadler -> (ExpressionProblemSolution, Wadler)
21:52:13 <c_wraith> It took me forever to realize the consequences of the State constructor wrapping a function.  When I *finally* figured that out, I suddenly understood how the context where something is evaluated could affect the result.  It's not, actually.  The result is a function, which is being run at some higher level.
21:52:47 <Funktorsalat> :)
21:53:14 <kmc> yup
21:53:25 <revenantphx> kmc: "state in motion" is my analogy for algebraic data types
21:53:30 * monochrom speaks naïvely: everything is a function...
21:53:50 <Heffalump> unless it's a value
21:53:57 <kmc> functions are values
21:53:59 <revenantphx> or neither.
21:54:00 <ivanm> who did that blog post about that recently? conal?
21:54:04 <copumpkin> everything is a valu
21:54:07 <Pseudonym> (CoWadler -> ExpressionProblemSolution, CoWadler)
21:54:07 <revenantphx> Is Nothing a value?
21:54:11 <copumpkin> revenantphx: sure
21:54:11 <Funktorsalat> except types
21:54:13 <kmc> revenantphx, yes
21:54:13 <revenantphx> A nullary one I suppose.
21:54:17 * monochrom disappears in a puff of logic when contemplating "a function that includes all functions"
21:54:17 <copumpkin> no, types are values of *
21:54:20 <ivanm> copumpkin: even though there's no such thing as a "valu" ?
21:54:21 <kmc> values don't have arity in general
21:54:21 <ivanm> :p
21:54:35 <kmc> some values are functions; some aren't
21:54:36 <revenantphx> monochrom: hah
21:54:41 <kmc> every function has one argument
21:54:56 <monochrom> or "a function that shaves all functions who don't shave themselves" 
21:54:57 <conal> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
21:55:18 <conal> monochrom: :)
21:55:28 <monochrom> onoes, a blog on this too.
21:55:38 <revenantphx> monochrom: oh come on :P
21:55:38 <Funktorsalat> monochrom: f n = runTuring (fromEnum n)?
21:55:50 * monochrom speaks naïvely again: everything is already discussed in blogs
21:56:05 <Pseudonym> explanation :: Conal -> (BlogPost, Conal)
21:56:06 <c_wraith> haha
21:56:15 <Funktorsalat> or toEnum even:\
21:56:41 <revenantphx> monochrom: go express Godwin's law in haskell
21:56:57 * Pseudonym avoids the state-in-context Nal joke
21:57:01 <revenantphx> "As an online discussion grows longer, the probability of a comparison involving Nazis or Hitler approaches 1."
21:57:16 <revenantphx> Now the first problem I see is, at what RATE does the probability increase?
21:57:23 <c_wraith> revenantphx, that sounds like something a nazi would ask.
21:57:30 <revenantphx> ...
21:57:34 <c_wraith> :)
21:57:46 <c_wraith> Sorry, the percocet just kicked in, and I'm a bit loopy
21:57:46 <lispy> c_wraith: OMG, I had something to tell you and NOW I can't REMEMBER!
21:57:58 <Funktorsalat> nodnodnod
21:58:13 <revenantphx> c_wraith: yellow, small, different
21:58:16 <c_wraith> lispy, about your disk-chained list?  I did see your solution that you mentioned earlier, I just was too busy to acknowledge it
21:58:34 <lispy> c_wraith: oh right, thanks
21:59:06 <c_wraith> anyway, good job finding the solution that fit your requirements :)
21:59:09 <lispy> c_wraith: I'm now convinced a proper database engine (b-trees perhaps) would be significantly more better-er.
21:59:13 * hackagebot secure-sockets 1.0 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.0 (DavidAnderson)
21:59:36 <revenantphx> gnight folks
21:59:50 <lispy> revenantphx: GOOD NIGHT
21:59:54 <lispy> (sorry, caps)
22:00:04 <revenantphx> that reminds me
22:00:16 <c_wraith> lispy, hmm. Possibly.  But file systems aren't that bad.  usually.  linear directory search does suck, though.
22:00:17 <revenantphx> http://bash.org/?835030
22:00:41 <revenantphx> always cracks me up...
22:00:43 <revenantphx> bye bye now.
22:01:22 <lispy> c_wraith: well it came out a discussion with someone else that I'll want to pack the cons cells to get good performance (seek in an open file should be faster than opening a new file)
22:02:04 <lispy> c_wraith: and then I would be maintaining sets of pack files with offsets and then I could probably just name my cons cells after the file + offset instead of UUID, etc.
22:02:22 <c_wraith> lispy, I'm not convinced of the veracity of that parenthetical remark.  I think the only way to know for sure is to benchmark your typical use case
22:02:24 <lispy> c_wraith: and at that point...I should probably just start storing the cons cells in the rows of a table in a db
22:03:16 <lispy> c_wraith: well, seek doesn't need to allocate any new data structures in the kernel.  It just updates the read location for the file.  An open on the other hand, still has to do all the work that seek has to do plus some
22:03:21 <c_wraith> I mean, do you even want a zipper, at this point?  A zipper is most useful when most of your edits are very close to the previous one.
22:03:40 <lispy> yes, I would have locality that way
22:04:12 <c_wraith> And in that case, the cost of moving to the next segment usually should be dominated by the cost of what's being done within each segment
22:05:36 <revenantphx> one cute idea before I sleep
22:05:50 <monochrom> usually you will not sleep
22:05:50 <revenantphx> considering it'd be possible to interpret brainfuck directly into C...
22:06:02 <revenantphx> you could compile brainfuck.
22:06:06 <revenantphx> To run it on any platform
22:06:16 <monochrom> and ruin any platform
22:06:19 * c_wraith invents a platform without a C compiler
22:06:25 <revenantphx> c_wraith: ffffff-
22:06:28 <Funktorsalat> hmm user time + kernel time is more sensible for benchmarking than clock time or is it not?
22:06:36 <revenantphx> well, you could compile it straight to assembly
22:06:44 <c_wraith> Funktorsalat, it really depends on what you're benchmarking
22:06:46 <monochrom> c_wraith wins. my Sharp PC-1500 cannot do C.
22:07:03 <c_wraith> Ah, neat, I already invented it
22:07:05 <Funktorsalat> c_wraith: I thought this would be so particularly on my laptop where firefox is running in the bg etc ;)
22:07:05 <lispy> Funktorsalat: if you use multiple cores then yes
22:07:34 <Funktorsalat> though running other programs presumably skews even the utime+stime due to cache issues?
22:07:55 <monochrom> But someone wrote a Logo interpreter for it. :)
22:08:10 <c_wraith> Funktorsalat, if the code is haskell, criterion does statistical analysis looking for external influences on timing
22:08:28 <Funktorsalat> sounds good
22:08:53 <lispy> and if it's C code write a Haskell FFI binding to the stuff you want to time :)
22:09:02 <monochrom> hahaha
22:09:15 <c_wraith> really, there's no reason to ever not use criterion for benchmarking haskell code.  someone else already did the hard work. :)
22:09:16 <monochrom> everything is a haskell function
22:10:02 <Funktorsalat> I deduce from the 'time' manpage that utime + stime = clocktime * cpupercent
22:10:14 <Funktorsalat> cpupercent being defined this way...
22:20:58 <om-foxy> I'm having trouble with type families.  A toy version of my problem is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29759#a29759
22:22:10 <ivanm> om-foxy: (RealElement t) => [t] -> [t] -> [ComplexOf t] ?
22:22:18 <iFire> is http://ulissesaraujo.wordpress.com/2009/04/09/hylomorphisms-in-haskell/ the best introduction to Hylomorphisms in Haskell ?
22:22:41 <om-foxy> ivanm: if ComplexOf is a type function, then shouldn't it resolve to (Complex t)?
22:22:42 <ivanm> iFire: any particular reason you want to learn about hylomorphisms in Haskell?
22:22:51 * ivanm isn't even sure what that means off the top of his head
22:23:15 <ivanm> om-foxy: no, because you haven't defined it that way
22:23:19 <iFire> ivanm I found this reddit thing
22:23:20 <iFire> http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/
22:23:24 <iFire> the best answer is...
22:23:26 <iFire> let me find it
22:23:39 <ivanm> om-foxy: what are you actually trying to do?
22:23:44 <iFire> http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0uvqqo
22:24:02 <ivanm> om-foxy: note: you have in no way specified that ComplexOf is the same as Complex
22:24:08 <iFire> ivanm I think the term is called fusion optimization
22:24:23 <ivanm> iFire: well, you can find the various fusion papers
22:24:34 <ivanm> the one by launchbury, et. al. is pretty readable
22:24:38 <om-foxy> ivanm: What is 'type instance ComplexOf Float = Complex Float'
22:24:52 <ivanm> om-foxy: you wrote it, you tell me ;-)
22:25:11 <om-foxy> well, I have containers which are either vectors or matrices.  They can contain either real or complex numbers which have precision float or double
22:25:45 <om-foxy> and I'm trying to write an interface which hides the specific details
22:26:00 <ivanm> iFire: also, "bananas, lenses and envelopes" isn't bad
22:26:45 <iFire> ivanm can you be more specific about the other one?
22:26:46 <om-foxy> ivanm:  for example:
22:26:48 <om-foxy> -- | converting to/from single/double precision numbers
22:26:49 <om-foxy> class (Element (SingleOf t), Element t) => Precisionable c t where
22:26:51 <om-foxy>     single'      :: (Precision (DoubleOf t)) => c t -> c (SingleOf t)
22:26:52 <om-foxy>     double'      :: (Precision (DoubleOf t)) => c t -> c (DoubleOf t)
22:26:54 <om-foxy> seems to work, but I get errors with the 'Complex' side of things
22:27:05 <ivanm> iFire: ummm, lemme dig up the paper
22:27:18 <ivanm> om-foxy: better off using an associated type to put things like ComplexOf inside the class then IMHO
22:27:53 <ivanm> iFire: "A short cut to deforestation"
22:27:54 <om-foxy> I agree with that, but ComplexOf gets used in numerous places outside the class context, which is why I thought type families are better
22:28:04 <ivanm> that's more of a "what does it give us" paper rather than theory of though
22:28:21 <ivanm> om-foxy: *shrug* you have to think about what you want more then
22:28:37 <ivanm> just by looking at it, your current scheme looks rather weird
22:28:50 <ivanm> also, unless you're simulating class aliases, I don't see the point in empty type classes
22:29:44 <ivanm> any TH experts around?
22:29:58 <c_wraith> depends on what you mean by expert.
22:30:06 <c_wraith> I've certainly used it on several different projects
22:30:36 <ivanm> if I want to have a TH function to help auto-generate instances of a class, is there any way of using that function in the same module as the class is defined in?
22:31:03 <ivanm> or do I have to have some kind of inner module which defines the class and TH function, then export the class and use the TH function in the exported module?
22:31:20 <c_wraith> I think the former should work.
22:31:46 <c_wraith> If the compiler tells you no, change to the latter :)
22:32:16 <c_wraith> I *think* the extent of the stage restriction is that the function being spliced in needs to be defined outside the module.
22:32:29 <ivanm> yeah
22:32:52 <ivanm> but without a circular import, how can I define the TH splicing function in another module? :s
22:32:55 <heatsink> I'm pretty sure you can use quoted names from the current module in TH.  You just can't un-quote them, e.g. by calling a method of the class.
22:33:42 <c_wraith> ivanm: don't import the class.  you build the code at a lexical level, not a semantic level
22:33:43 <heatsink> er.  You can only refer to the class in a quoted context.
22:36:18 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29760#a29760
22:36:42 <ivanm> the problem when trying to use mkName, etc. rather than ' or '' is how to deal with the qualified import bit
22:37:19 <c_wraith> ivanm, I'd use [d| |] quoting to build the expression, since it's always fixed
22:37:28 <ivanm> how?
22:37:32 <c_wraith> It's a lot easier to read
22:38:00 <ivanm> no, how to use it ;-)
22:38:10 * ivanm has never really touched TH before
22:38:55 <c_wraith> [d| f x = x + $foo |] is an expression with type Q Dec
22:38:56 <heatsink> [d| instance $(cl) $(typ) where $(mapM mkFun mthds) |]
22:39:08 <heatsink> Except I'm not sure that the last splice is valid
22:39:12 <c_wraith> ok, heatsink's example is more specific
22:39:14 <c_wraith> :)
22:39:31 <c_wraith> the d is for declaration
22:39:36 <ivanm> OK...
22:39:47 <ivanm> still not quite sure how to use it in my case here
22:39:56 <c_wraith> You can perform TH splices inside the quasi-quote
22:40:33 <c_wraith> So if the structure of the code you're generating is always the same, you can use a quote to make it easier to read
22:40:33 <ivanm> you mean the $( ... ) ?
22:40:37 <c_wraith> yeah
22:41:02 <c_wraith> They're just standard TH splices, but they're nested, rather than top-level
22:41:04 <ivanm> well, the whole reason I wanted to define a genFunctor function was to avoid having to duplicating specifying Functor, fmap, F.fmap, etc.
22:44:18 <ivanm> c_wraith: can you actually provide me with an example of what you mean?
22:44:22 <ivanm> because I'm still confused...
22:44:47 <c_wraith> Probably not without knowing what instanceD does
22:45:03 <ivanm> that's from TH
22:45:30 <ivanm> the only thing missing there that I wrote is my Functor class, and it's identical to the original except for type signatures
22:45:39 <c_wraith> oh.
22:45:53 <ivanm> and in this case it doesn't matter: all instances of Data.Functor.Functor are able to be instances of my Functor
22:46:22 <heatsink> I think the quasiquote-based function is genFunctor typ = [d| instance Functor $(typ) where { fmap = F.fmap; (<$) = (F.<$) } |]
22:46:53 <ivanm> hmmm...
22:47:14 <c_wraith> is that fmap return just to put it in a list?  eww.  :P
22:48:09 <ivanm> c_wraith: yeah, the original I based it on did a v <- ...; return [v]
22:48:27 <ivanm> heatsink: still won't let me use genFunctor in the same module it's defined in
22:48:34 <c_wraith> at least fmap (:[])  :)
22:48:43 <heatsink> ivanm: Yes, that's part fo the stage restriction.
22:48:46 <ivanm> c_wraith: I'm used to using return rather than (:[])
22:48:50 <ivanm> heatsink: :(
22:49:07 <mymind> hi all
22:49:20 * ivanm waves idly in the general direction of mymind 
22:49:31 <mymind> does anyone know if there is a HaskellRPL for android?
22:49:32 <heatsink> I don't exactly know the reason, but I think it's something like it's really hard to run code that hasn't been compiled yet, o
22:49:35 <ivanm> mymind: in case you didn't know, we also have #haskell.au
22:49:48 <ivanm> mymind: and no, there are some people working on porting GHC to android
22:49:54 <ivanm> your best bet is to try to get hugs on android
22:50:02 <ivanm> heatsink: *nod*
22:50:43 <ivanm> heatsink: any idea if it's possible to do something like this: given a String for a function name and a String for the qualified import, resolve GHC's symbol for the qualified version?
22:51:30 <mymind> ok thanks
23:01:28 <heatsink> You want to take a String representing a qualified name, and resolve the name at splice time?
23:02:22 <ivanm> yeah
23:03:01 <heatsink> Hmm
23:03:14 <ivanm> otherwise, I can do it by using a String representation of my class method and then do a qualified import in the module I define the splice function in to get the real symbol name
23:03:21 <ivanm> (for the original Functor)
23:05:41 <heatsink> well, mkName seems to work with qualified names
23:06:02 <heatsink> > print $(varE (mkName "Data.Maybe.mapMaybes"))
23:06:03 <lambdabot>   Not in scope: `varE'Not in scope: `mkName'
23:06:14 <heatsink> > :set -XTemplateHaskell
23:06:15 <lambdabot>   <no location info>: parse error on input `:'
23:06:22 <ivanm> doesn't work with fully qualified names though
23:07:14 <ivanm> huh, had to import it first...
23:07:17 <ivanm> it compiles now, anyway
23:07:28 <heatsink> yey
23:08:09 <ivanm> looks like it works
23:08:19 * ivanm tries with a symbol
23:08:42 <ivanm> since mkName doens't seem to work properly with qualified symbol names...
23:09:35 <ivanm> ugh, "illegal variable name (<$)" :s
23:09:46 <ivanm> oh, mkName doesn't need parens...
23:09:47 <ivanm> cool
23:16:28 <Funktorsalat> is there any sort of manual for yi somewhere?
23:16:50 <Funktorsalat> (how am I supposed to find out all the keybindings, for example?)
23:17:14 <ivanm> Funktorsalat: you can choose between the emacs keybindings and vi keybindings depending upon your config
23:17:29 <Funktorsalat> ivanm: yeah, but I mean yi-specific things
23:20:42 <applicative> Funktorsalat, I was going to say, the source isn't too opaque on that matter, but taking a look at it now, I repented of the idea. 
23:21:11 <Funktorsalat> applicative: oh, that was my next plan :-(
23:21:43 <Funktorsalat> I'd really like to get started with yi, but it seems like there's no help or manual whatsoever
23:24:38 <applicative> Same here, I've tried a few times but some impediment arises before I can gather steam. 
23:26:30 <applicative> If I had a haskell editor I could remove myself from the so called world and dwell only in haskell-land, even for writing... It's too much to hope for, I guess.
23:27:18 <kamatsu> what about a haskell shell?
23:27:53 <applicative> have any of those schemes ever gone anywhere?
23:28:49 <applicative> i mean, haskell shell ideas.  
23:29:38 <ivanm> *sigh* using mkName with a qual'd name requires the same qualification be used :(
23:30:05 <ivanm> kamatsu: any particular reason you're not in #haskell.au? ;-)
23:31:09 <applicative> ivanm, are you enforcing patriotism?  maybe ill go to #haskell.au to avoid my country.
23:31:48 <ivanm> applicative: nah, but he's been in there before but isn't now
23:32:10 <ivanm> (blame Axman6 for the existance of that channel)
23:33:07 <applicative> hadn't noticed it ... now i can see just who the antipodal #haskellers are
23:37:46 <ivanm> c_wraith: any idea what the NameSpace and PkgName bits of NameFlavour are for? http://hackage.haskell.org/packages/archive/template-haskell/2.4.0.1/doc/html/Language-Haskell-TH-Syntax.html#t:NameFlavour
23:38:03 <c_wraith> never used them at all.
23:38:05 <c_wraith> sorry
23:41:07 <ivanm> OK
23:41:37 <ivanm> *sigh* it doesn't seem to like explicitly creating a Name with a different module name
23:42:31 <Funktorsalat> when did -O2 start actually disabling assertions?:O
23:42:40 <ivanm> which assertions?
23:42:45 <ivanm> I didn't know Haskell had assertions...
23:42:45 <Funktorsalat> assert
23:42:50 <Funktorsalat> well it does ;)
23:43:01 <Funktorsalat> @ty assert
23:43:02 <lambdabot> Not in scope: `assert'
23:43:07 <ivanm> @hoogle assert
23:43:07 <lambdabot> Control.Exception assert :: Bool -> a -> a
23:43:07 <lambdabot> Control.OldException assert :: Bool -> a -> a
23:43:07 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
23:43:14 <ivanm> huh
23:43:21 <ivanm> and it chucks an error if the assertion is false?
23:43:27 <Funktorsalat> yes
23:43:33 <Jonno_FTW> hello
23:43:52 <Funktorsalat> it's magic in that it prints the source loc, too
23:43:54 <ivanm> Funktorsalat: probably for the same reason you wanted to disable trace ;-)
23:43:58 <Jonno_FTW> I am trying to install lambdabot, and I get the following message after running cabal install lambdabot:     Could not find module `System.Posix.Signals':
23:44:02 <Jonno_FTW>       It is a member of the hidden package `unix-2.4.0.2'.
23:44:04 <Jonno_FTW>       Perhaps you need to add `unix' to the build-depends in your .cabal file.
23:44:07 <ivanm> and that's probably detrimental
23:44:19 <ivanm> Jonno_FTW: IIRC, you should build lambdabot from darcs
23:44:22 <ivanm> not from the hackage package
23:44:26 <Jonno_FTW> :|
23:44:31 <Jonno_FTW> how do I go about this?
23:44:33 <Funktorsalat> ivanm: I'm testing with -O2 since I'm tweaking the performance
23:44:51 <Funktorsalat> but I expected the assertions to remain, as they used to IIRC
23:45:09 <ivanm> Jonno_FTW: darcs get <blah>; cd lamdabot; cabal install
23:45:16 <Jonno_FTW> k
23:45:22 <Funktorsalat> -fno-ignore-asserts
23:47:21 <ivanm> c_wraith: OK, any idea if it's possible to use ' or '' on a String to get the actual symbol in scope at that point?
23:47:32 <c_wraith> On a string?  No.
23:47:44 <c_wraith> ' and '' work at compile-time
23:48:36 <ivanm> yeah
23:48:57 <ivanm> I was just hoping it'd be possible to do something like '(qual ++ "." ++ method)
23:51:20 <TPJ> Hello, I'm a Haskell/ghc newbie.
23:51:27 <TPJ> Using :step myfunc, I'm able to perform a single step evaluation of my code, and I get bindings of all the names (variables, or whatever it's called in Haskell).
23:51:34 <TPJ> When I enter :step myfunc again, the same step is evaluated again.
23:51:39 <TPJ> How can I tell ghci to perform the next step evaluation?
23:52:03 <TPJ> I can't find it in ghc docs.
23:52:08 <Peaker> Does Agda have partiality in a monad?
23:53:13 <Jonno_FTW> TPJ: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html
23:55:09 <TPJ> All right, I got it. All I needed to do was to perform simple ":step" instead of ":step myfunc".
23:55:25 <ivanm> c_wraith: OK, how can I use '' on ((->) a) ?
23:55:48 <TPJ> Sorry for bothering you with such a trivial problem.
23:55:48 <ivanm> or even ((,) a)
23:56:40 <ivanm> gah, it doesn't even like ''(Either a) !
23:56:54 <kmc> '' quotes a type name
23:56:57 <kmc> not a type expression
23:57:17 <kmc> [t| Either a |]
23:57:30 <ivanm> ahhh, cool
23:57:41 <kmc> '' produces a Name; there's no Name for (Either a)
23:58:20 <ivanm> dammit, I get "Not in scope: type variable `a'" when I try to use [t| ... |] :s
23:59:14 <kmc> yeah TH will do type / kind / etc. checking on quotations
23:59:17 <kmc> it's sometimes annoying
23:59:33 <ivanm> kmc: *sigh* so all this TH stuff I've done to try to generate instances is pretty much useless for a large majority of them? :(
23:59:56 <kmc> don't know
