00:09:14 <ajnsit> Is there an openid provider library for haskell?
00:11:56 <Gracenotes> to set up an openid provider service? that's black magic as far as I'm aware :.
00:14:58 <ajnsit> Gracenotes, why do you say that? Is is difficult to setup a provider?
00:16:16 <Gracenotes> the documentation for doing so certainly isn't as accessible as for setting up just an openid login
00:17:18 <Gracenotes> there are a couple libraries on other proglangs, but don't think in Haskell. so it's portable at the very least.. I think..
00:18:18 <ajnsit> yeah it would be a good project to port some openid provider library to Haskell
00:24:50 <dmead> ?hoogle BDecls
00:24:50 <lambdabot> No results found
00:24:56 <dmead> ?src BDecls
00:24:56 <lambdabot> Source not found. You untyped fool!
00:25:00 <dmead> :(
00:25:11 <dmead> @hoogle BDecls
00:25:11 <lambdabot> No results found
00:39:52 <knobo> http://hpaste.org/40153/parsec_tree
00:40:04 <knobo> I need some help to understand parsec
00:40:38 <knobo> Several things I don't understand
00:41:34 <knobo> I tried "endBy anyChar newline", instead of "many (noneOf "\n")". But that did not work.
00:43:04 <knobo> I also get the error message: calc: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
00:43:41 <Nibble> hmm
00:43:47 <Nibble> This program is calling the Imlib call:
00:43:50 <Nibble> imlib_image_get_height();
00:43:52 <Nibble> With the parameter:
00:43:54 <Nibble> image
00:43:56 <Nibble> being NULL. Please fix your program.
00:44:22 <Nibble> Same with width function, I don't see how it could be doing that
00:47:34 <nlogax> knobo: there's many1 for 1 or more, if you have many possiblyEmptyString you'd get stuck there forever /o\
00:56:14 <knobo> how about the "subtree <- option [] (try (many1 (parseTree (tabs + 1))))" part. looks not good
00:56:19 <Maxdamantus> Does the (:) operator have a name?
00:56:56 <nlogax> mr happy! 
00:56:58 <nlogax> cons?
00:58:02 <Nibble> Maxdamantus: cons yes
00:58:16 <Nibble> http://en.wikipedia.org/wiki/Cons
00:58:34 <Maxdamantus> Ah, I see.
01:00:13 <jeltsch> > 1 + 1
01:00:14 <lambdabot>   2
01:00:19 <mreh> I'm not used to cabal trying to compile c, why is it doing that?
01:00:23 <cizra> > sqrt 0
01:00:24 <lambdabot>   0.0
01:00:25 <Nibble> > let 2 + 2 = 5 in 2 + 2
01:00:26 <lambdabot>   5
01:00:31 <Nibble> jeltsch: ^
01:00:34 <cizra> > sqrt (-1)
01:00:34 <lambdabot>   NaN
01:00:46 <mreh> > sqrt (-1) :: CReal
01:00:50 <lambdabot>   mueval-core: Time limit exceeded
01:01:22 <mreh> that made no sense anyway
01:01:42 * hackagebot HUnit 1.2.2.3 - A unit testing framework for Haskell  http://hackage.haskell.org/package/HUnit-1.2.2.3 (RichardGiraud)
01:02:33 <Maxdamantus> > let 1^2 = 2 in sqrt 2
01:02:34 <lambdabot>   1.4142135623730951
01:02:38 <Maxdamantus> :d
01:03:48 <Jafet> > let 2 + 2 = 5 in 2 + 3
01:03:48 <lambdabot>   *Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
01:05:21 <Entroacceptor> > sqrt (-1) :: Complex
01:05:21 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
01:05:22 <lambdabot>  Expected ki...
01:05:40 <Maxdamantus> > let n + 0 = n; n + m = succ n + pred m in 5 + 4
01:05:41 <lambdabot>   9
01:05:59 <Maxdamantus> > let n + 0 = n; n + m = succ n + pred m in 5 + (-4)
01:06:03 <lambdabot>   mueval-core: Time limit exceeded
01:06:22 <knobo> http://hpaste.org/paste/40156/parsec_tree__1__bug_1#p40158
01:06:38 <jeltsch> sqrt (-1) :: Complex Double
01:06:50 <jeltsch> > sqrt (-1) :: Complex Double
01:06:52 <lambdabot>   (-0.0) :+ 1.0
01:07:04 <Maxdamantus> > 1/0 :: Complex Integer
01:07:05 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Internals.Integer)
01:07:05 <lambdabot>    aris...
01:07:13 <Maxdamantus> > 1/0 :: Complex Double
01:07:14 <lambdabot>   NaN :+ NaN
01:07:21 <Maxdamantus> Hm, no complex infinity?
01:07:48 <Maxdamantus> > 1/0 :: Double
01:07:49 <lambdabot>   Infinity
01:08:48 <knobo> My last paste... Very strange bug. Suddenly somewhere in the tree, it does not parse it as a subtree...
01:17:48 <mreh> I don't understand! cabal is trying to compile .cpp souce files, and it's talking about everything not being in scope!!!
01:40:50 <n00p> mreh: Ke serah, serah. Whatever will be, will be.
01:40:59 <n00p> The future's not ours to see...
01:48:56 <Entroacceptor> > (0:+1) * (0:+1)
01:48:58 <lambdabot>   (-1.0) :+ 0.0
01:49:10 <Entroacceptor> > (0:+1) * (0:+1) :: Real
01:49:11 <lambdabot>   Class `GHC.Real.Real' used as a type
01:52:37 <mreh> n00p: "Que Sera" for future reference :)
01:56:13 <n00p> mreh: Thanks.
01:57:51 <n00p> mreh: I know a bit about C, but I couldn't help you with out-of-scope C++ issues. I might suggest that if you're returning an object, you can't access the properties of that object after the caller's next sequence point
01:58:21 <mreh> well I was hoping it was a cabal issue, such as mistakenly trying to compile with GHC instead of GCC
02:21:58 <madsy> What is the biggest difference in features between Haskell and imperative languages like C?
02:22:23 <madsy> Just trying to get a picture of Haskell's capabilities.
02:22:41 <madsy> Wikipedia is lacking in that department.
02:22:56 <Jafet> Haskell is not what it is not.
02:23:57 <c_wraith> the biggest difference?  Haskell provides a lot of tools to help the programmer statically check that code is at the very least close to correct.
02:24:18 <madsy> c_wraith: Hm, good answer :)
02:24:33 <madsy> I also like the pattern mathcing.
02:24:39 <madsy> matching*
02:24:46 <geheimdienst> i'm with c_wraith. i feel it's hard to get anything to compile in haskell, but once it does, it rarely has many bugs anymore
02:25:12 <mreh> yeah, cabal is trying to compile c++ sources with GHC
02:25:27 <c_wraith> C code pretty much compiles once it's syntactically correct.  That doesn't always inspire confidence. :)
02:25:28 <mreh> despite them being delineated as C-Sources in the cabal file
02:27:05 <Cale> mreh: ghc can compile C programs if passed .c files on the commandline (it uses gcc to do it)
02:27:33 <mreh> Cale: even c++ files? (.cpp)
02:27:41 <Cale> I don't know about C++
02:28:00 <Cale> But compiling C code with ghc is the easiest way to get things to link properly.
02:28:28 <mreh> point of interest, how does that work with the new llvm backend?
02:29:54 <Cale> Presumably the same as always, but I don't know.
02:30:42 <Cale> As far as I know, GHC will still be capable of running gcc on C source files and using the system linker to link the results in.
02:31:26 <Cale> (It shouldn't make any difference how the Haskell bits were compiled)
02:35:14 <mreh> could I compile the c bits manually?
02:36:08 <visof> sum [x^x | x <- [1..1000]] , take a very short time, i don't know why
02:36:23 <visof> shouldn't it take more time ?
02:36:40 <Jafet> > length . show $ 1000^1000
02:36:44 <lambdabot>   mueval-core: Time limit exceeded
02:36:50 <Cale> visof: That's not all *that* large
02:36:58 <Jafet> Not enough for you?
02:37:12 <geheimdienst> so, no way to get a png file into haddock documentation?
02:37:15 <cizra> visof: Haskell is just so magical :-D
02:37:18 <Cale> > length . show $ 1000^1000
02:37:20 <lambdabot>   3001
02:37:31 <Cale> (the timeout there was a weird fluke)
02:37:33 <visof> Cale, it's very big number
02:37:51 <Jafet> Cale is merely magical
02:38:22 <Cale> > 1000 * (log 1000 / log 2)
02:38:23 <lambdabot>   9965.784284662088
02:38:36 <Cale> It's just slightly less than 10 kilobytes.
02:38:41 <Cale> er
02:38:43 <Cale> > 1000 * (log 1000 / log 8)
02:38:44 <lambdabot>   3321.9280948873625
02:38:55 <Cale> kilobits rather
02:39:01 <Cale> Less than 4 kilobytes
02:39:04 <visof> > length . show $ 10000^10000
02:39:05 <lambdabot>   40001
02:39:12 <koala_man> it's an O(n^2) operation on 1000 elements
02:39:22 <Cale> So, not all that big a number for a computer.
02:39:25 <visof> > length . show $ 100000^100000
02:39:27 <lambdabot>   500001
02:39:33 <visof> > length . show $ 1000000^1000000
02:39:39 <lambdabot>   mueval: ExitFailure 1
02:39:42 <Cale> The number which represents a TV show for example is a much larger one ;)
02:39:56 <visof> > length . show $ 1000000^100000
02:39:58 <lambdabot>   600001
02:40:02 <visof> omg
02:40:13 <mreh> log (1000000^2)
02:40:17 <mreh> > log (1000000^2)
02:40:18 <lambdabot>   27.631021115928547
02:40:21 <Cale> mreh: You can pass .o files on the ghc commandline
02:40:27 <geheimdienst> > lol (1000000^2)
02:40:28 <lambdabot>   Not in scope: `lol'
02:40:39 <visof> what is the resources of the machine lambdabot work under ?
02:40:46 <geheimdienst> a deplorable omission in the standard library
02:40:55 <Cale> visof: Not much
02:40:56 <mreh> don't laugh
02:40:59 <mreh> :(
02:41:18 <mreh> > log 10
02:41:19 <lambdabot>   2.302585092994046
02:41:20 <visof> Cale, is that your machine ?
02:41:25 <mreh> what base is that?
02:41:45 <Cale> visof: No, it's a virtual server which lispy arranged for.
02:41:59 <mreh> @src log
02:42:00 <lambdabot> Source not found. My pet ferret can type better than you!
02:42:01 <visof> ah ok
02:42:13 <visof> Haskell is very fast
02:42:33 <mreh> > 2^(log 10)
02:42:34 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:42:34 <lambdabot>    `GHC.Float.Floating t'
02:42:34 <lambdabot>  ...
02:42:35 <Cale> It's not really doing anything that special.
02:42:40 <mreh> > 2^^(log 10)
02:42:41 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:42:41 <lambdabot>    `GHC.Float.Floating t'
02:42:41 <lambdabot>  ...
02:42:42 <visof> i just try that in ghci , not even compiled code
02:42:44 <Jafet> > log (exp 1)
02:42:45 <lambdabot>   1.0
02:42:45 <mreh> > 2**(log 10)
02:42:46 <lambdabot>   4.933409667914597
02:42:46 <geheimdienst> so, there is no way to get html into haddock documentation, right? <img> tags? <table>s?
02:42:56 <Cale> visof: It's just that *all* computers these days are pretty fast.
02:43:01 <mreh> ohhhh
02:43:11 <mreh> log_e = ln?
02:43:21 <Cale> > log (exp 1)
02:43:22 <lambdabot>   1.0
02:43:26 <Cale> > exp 1
02:43:27 <lambdabot>   2.718281828459045
02:43:36 <Cale> log is the natural logarithm, as it should be
02:43:37 <visof> Cale, i have 1.6 dual core old Dell latitude with 1Gb ram
02:43:43 <mreh> Cale: LIES
02:44:07 <Jafet> > showCReal 100 $ exp 1
02:44:08 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
02:44:22 <mreh> yup, all correct
02:44:52 <Cale> visof: These computations are trivial even for, say, a 486 with 2MB of memory.
02:45:10 <mreh> such a computer never existed
02:45:41 <mreh> right it's been 30 minutes, I don't actually need bullet physics, I should do something else
02:45:59 <Cale> I'm pretty sure I've run into such a machine. Maybe it had 4MB.
02:46:15 <Cale> I skipped from 386 to Pentium.
02:46:18 <tensorpudding> a 486 with 2MB of RAM? That sounds pretty logical.
02:46:26 <tensorpudding> I had a 386 with 4MB of RAM.
02:46:28 <geheimdienst> cale, you're right, i've had a 486 with 4 mbs of ram
02:46:41 <tensorpudding> Maybe 2MB was a bit on the low side.
02:46:45 <Cale> Yeah
02:47:04 <Cale> I had a 386 with 1MB, which later got upgraded to 2 and then 4 MB.
02:47:08 <mreh> still, I'm suprised by the low oreder of memory
02:47:08 <tensorpudding> I would guess 4MB is enough for Windows 95.
02:47:27 <tensorpudding> Though the machine I think of never ran Windows 95.
02:47:29 <mreh> I knew someone with a 486 which *barely* ran Windows95
02:47:58 <tensorpudding> Huh, 386 with 4MB of RAM is minimal requirements.
02:48:16 <tensorpudding> But apparently it runs rather badly.
02:49:22 <Jafet> In other news, minix3 recommends at least 16MB
02:49:25 <tensorpudding> Damn, 2MB of RAM? It's really shocking how little that is nowadays.
02:50:05 <lantti> "Hey, hey 16k, what would that get you today..." :)
02:50:28 <Jafet> You could run a 64M swap file, and today have that fit entirely in the drive cache
02:50:37 <tensorpudding> According to htop, hald is using about 2 MB of RAM by itself.
02:50:50 <tensorpudding> on my machine.
02:50:55 <Jafet> Plausible, since that's the default stack size.
02:51:38 <tensorpudding> And supposedly you can run Linux on a 386.
02:51:52 <Cale> My current machine has 4GB of memory. I could probably do away with swap altogether at the moment, I haven't seen my physical memory use (discounting disk cache) go over 2GB.
02:52:30 <mreh> you've never programmed a space leak?
02:52:50 <Jafet> You've never used ulimit?
02:52:55 <Cale> mreh: Not on the new machine yet ;)
02:53:00 <Ke> noone uses ulimit
02:53:17 <Jafet> Indeed, it is saddening
02:53:29 <Ke> last considerable memory leak I had was in linux itself
02:53:47 <Ke> Jafet: it's mostly irrelevant on non-critical single user system
02:54:58 <Cale> I love how having 4 cores means I can often just waste CPU time with no consequence. Apparently I have had two runaway copies of a program called iphone-set-info grinding away at 100% CPU each for the last, and I didn't even notice until just now.
02:55:05 <Cale> for the last day*
02:55:23 <Jafet> lm-sensors helps, indirectly.
02:55:30 <Cale>  9170 root      18  -2  6040 2320 1908 R  100  0.1   1497:34 iphone-set-info    
02:55:30 <Cale>  9159 root      18  -2  6040 2320 1908 R  100  0.1   1497:04 iphone-set-info    
02:55:40 <Cale> (seriously wtf)
02:56:19 <tensorpudding> what is iphone-set-info?
02:56:24 <Cale> I don't know.
02:56:43 <geheimdienst> so you're on a mac ...?
02:56:44 <tensorpudding> that might be worryingg
02:56:46 <Cale> Nope.
02:57:04 <Cale> Linux, though I run Mac OS X under VMware regularly.
02:57:13 <tensorpudding> How does that work, by the way?
02:57:27 <Cale> It works pretty good all things considered.
02:57:30 <tensorpudding> You're running Linux on Mac hardware?
02:57:36 <Cale> No.
02:57:49 <Cale> Macs are all Intel machines nowadays.
02:57:57 <tensorpudding> I was under the impression that OSX license forbade virtualization on most non-Mac hardware
02:58:05 <Nibble> Yeah
02:58:07 <Cale> That's not a problem, apparently.
02:58:07 <Nibble> That can't work
02:58:08 <tensorpudding> and only server edition
02:58:17 <Nibble> You can only virtualize mac under mac
02:58:19 <Nibble> I heard
02:58:34 <tensorpudding> I read about this in Oracle's documentation for VirtualBox.
02:58:37 <Cale> http://prasys.info/osx86hackint0sh/
02:58:51 <tensorpudding> So it's a hacked OSX?
02:59:07 <Cale> Well, I haven't looked into how it works.
02:59:14 <Cale> But it does work.
02:59:16 <mreh> It just works!
02:59:23 <Nibble> I waited for that ^
02:59:24 <mreh> @slap mreh
02:59:24 <lambdabot> why on earth would I slap mreh?
02:59:53 <mreh> clearly lambdabot is running on OSX
03:00:01 <Cale> There are some weird issues.
03:00:20 <geheimdienst> tensorpudding: to be fair, the OSX license also forbids installing things yourself, opening the shrinkwrapped box, talking loudly in the presence of a mac, or touching a mac with bare hands instead of velvet gloves
03:00:38 <tensorpudding> It doesn't forbid you to do any of those things.
03:02:18 <tensorpudding> At least with OSX there isn't nearly as much intentional market segmentation.
03:02:27 <Cale> Installing our game to the iPhone simulator somehow causes my underlying linux kernel to thrash a whole lot, bringing one cpu to 100% "system" usage, and causing the other 3 to IOWait. No idea why it happens. However, if I try to type inside the VM while that's going on, it will usually result in a key getting stuck until I reset the VM. Pretty annoying, but I can live with it.
03:04:26 <Ke> at least vmware expands the hd image dynamically as needed causing much overhead
03:12:31 <Maxdamantus> Is there some sort of ambiguity which causes brackets to be required around all partially-applied operators?
03:13:39 <Maxdamantus> > let a = :[] in a 4
03:13:40 <lambdabot>   <no location info>: parse error on input `:'
03:14:13 <tensorpudding> > let a = : [] in a 4
03:14:14 <lambdabot>   <no location info>: parse error on input `:'
03:14:28 <Maxdamantus> > let a = (:[]) in a 4
03:14:28 <tensorpudding> > let a = (:) [] in a 4
03:14:29 <lambdabot>   No instance for (GHC.Num.Num [[a]])
03:14:29 <lambdabot>    arising from a use of `e_14' at <int...
03:14:29 <lambdabot>   [4]
03:14:45 <Lemmih> Maxdamantus: That's incorrect for the same reasons as: let a = + in a 10 20
03:15:46 <Maxdamantus> How else could that be interpreted?
03:17:33 <Lemmih> Maxdamantus: You might say that '+ 10 20' should also be allowed. But it isn't.
03:19:00 <Maxdamantus> > + 50
03:19:01 <lambdabot>   <no location info>: parse error on input `+'
03:19:05 <Maxdamantus> > - 50
03:19:06 <lambdabot>   -50
03:19:17 <Lemmih> Maxdamantus: They probably made it like that for consistency. Consider the difference between '+ 10 20' and 'fn + 10 20'.
03:19:53 <Maxdamantus> Hm, maybe.
03:19:56 <Lemmih> Maxdamantus: In the first expression, '+' is used as a prefix operator. In the second, '+' is an infix operator.
03:20:17 <Maxdamantus> + isn't a prefix operator apparently
03:20:35 <Jafet> No operators are prefix, so no, it isn't
03:20:36 <Lemmih> But with 'a 10 20' and 'fn a 10 20', 'a' doesn't behave like that.
03:20:38 <Maxdamantus> Are there any prefix operators? (could the - prefix on numbers be said to be an operator?)
03:20:43 <quicksilver> just -
03:20:45 <Maxdamantus> Mk.
03:20:49 <quicksilver> which is a painful exception.
03:20:55 <Maxdamantus> > - (50)
03:20:56 <lambdabot>   -50
03:20:57 <Jafet> Except that, yeah
03:20:59 <Maxdamantus> Ah.
03:21:14 <quicksilver> arguably misguided, too
03:21:30 <Jafet> :t negate
03:21:33 <lambdabot> forall a. (Num a) => a -> a
03:21:33 <quicksilver> if you're making a big deal about uniformity of syntax, which is the whole point about the operator vs function thing
03:21:40 <quicksilver> then putting an exception in weakens the case.
03:21:42 <Lemmih> Jafet: Oh well, you know what I meant.
03:21:55 <Jafet> Well, I've never used - for negate.
03:22:21 <Maxdamantus> I think some notations use - or _ at the end of the number, but both would be "ambiguous" I think, in Haskell.
03:22:43 <Maxdamantus> > 100_
03:22:44 <lambdabot>   Pattern syntax in expression context: _
03:23:05 <Maxdamantus> > let foo 100_ = 42 in foo 100 "baz"
03:23:06 <lambdabot>   42
03:23:08 <Jafet> I once imagined a language where you could mix prefix, postfix and infix, and the compiler would use constraint solving to figure out which one you meant
03:23:30 <Jafet> Compiling it is probably NP-complete at least, depending on the type system
03:24:09 <Maxdamantus> Is there some reason for why it appears to tokenise like that?
03:24:24 <zygoloid> Jafet: and then you woke up with a cold sweat and a newfound fondness to Perl?
03:24:36 <Maxdamantus> A number is simply terminated a character before a non-number character
03:25:14 <Maxdamantus> Can't think where that would be semantically correct other than in a parameter list
03:25:28 <Maxdamantus> (To do something like 42f)
03:25:32 * hackagebot bidirectionalization-combined 0.1.0.1 - Prototype Implementation of Combining Syntactic and Semantic Bidirectionalization (ICFP'10)  http://hackage.haskell.org/package/bidirectionalization-combined-0.1.0.1 (JoachimBreitner)
03:26:31 <zygoloid> > (10%3, 4:+5)
03:26:32 <lambdabot>   (10 % 3,4.0 :+ 5.0)
03:28:01 <Jafet> zygoloid: well, I didn't try to combine that idea with undecidable instances.
03:36:00 <glantern> Hello all
03:41:49 <Cale> Hello glantern 
03:43:37 <glantern> Hi Cale
03:43:40 <glantern> What up
03:43:52 <Cale> Not much, just waking up.
03:50:19 <glantern> Waking up? Where are you then?
03:51:32 <geheimdienst> @time cale
03:51:47 <geheimdienst> @time geheimdienst
03:52:21 <cizra> TZ=cale date (;
03:53:04 <glantern> @time geheimdienst
03:53:15 <glantern> geheimdienst: are you from Germany?
03:53:27 <geheimdienst> yeah. it's 12:52 here
03:53:45 <glantern> tja gut, man findet überall Leute mit denen man Deutsch reden kann
03:53:47 <geheimdienst> (almost 1pm, for our american friends)
03:54:31 <Philonous> That's a great time to weak up, too
03:54:34 <Philonous> wake*
03:56:30 <geheimdienst> Timezones™. It's Always a Good Time to Wake Up, Somewhere.™
03:56:51 <tensorpudding> The Americans in the audience should be asleep.
03:58:34 <geheimdienst> hm ... on the east coast, it's 7am now
03:58:47 <bastl> hi.
03:59:48 <bastl> Is there a clean way to deploy a comiled binary library to another machine with the same architecture (x86_64) ?
04:00:56 <Ke> what do you mean
04:01:10 <Ke> make a package/installer
04:02:48 <geheimdienst> i guess if all the right stuff is installed, you can just copy it over ...
04:02:55 <bastl> how about the package.conf etc? I want to compile an executable on my machine and link it against this library
04:03:26 <bastl> Ke: how?
04:03:51 <Lemmih> bastl: This library?
04:04:01 <Lemmih> Which library is that?
04:04:06 <geheimdienst> bastl, have you tried just copying the binary to the other system? i'm pretty sure that will work
04:04:15 <bastl> the library i want to install on another machine (with far more RAM)
04:04:23 <bastl> ehm **compile**
04:05:05 <bastl> geheimdienst: not yet, because im unsure about all that package-management stuff under .cabal  ...
04:05:20 <Lemmih> bastl: You want to compile the program on one box and then have it use a different Haskell library on another box?
04:05:31 <geheimdienst> apropos ... ghc always uses static linking these days, doesn't it? dynamic linking is pretty new and not usually enabled, right?
04:05:35 <Lemmih> bastl: If so, that can't be done. GHC uses static linking.
04:05:43 <bastl> oh
04:06:56 <Lemmih> bastl: Why would you want to?
04:07:09 <cizra> Lemmih: Really? ISTR seeing dynamically linked GTK for example.
04:07:15 <Ke> cabal is a build system, not a package manager
04:07:15 <geheimdienst> seriously, i would just try to copy the binary to the other machine. i'm pretty sure it'll work. if it doesn't check back with us :)
04:07:26 <Lemmih> cizra: GTK is not a Haskell library.
04:07:51 <Ke> it won't work if you have incompatible gmp or so
04:08:01 <bastl> geheimdienst: ok, ill try that.
04:08:18 <cizra> Lemmih: Sort of. Haskell bindings for GTK is something I'd call a Haskell library. I don't know their guts, though.
04:09:34 <geheimdienst> couldn't the gtk haskell thingy link statically against a ffi c thingy, which then links dynamically against gtk c stuff ...?
04:09:51 <Lemmih> cizra: gtk2hs and GTK are two different things. Even so, I dare you to write a program that (using dynamic linking) can use two different versions of gtk2hs.
04:10:56 <Lemmih> geheimdienst: That's exactly what it does by default.
04:13:03 <cizra> Lemmih: ummm. Does Haskell expose dlopen() somehow? (;
04:13:21 <geheimdienst> vaguely relevant: http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport?redirectedfrom=DynamicLinking
04:14:01 <Lemmih> cizra: Yes but it is nearly impossible to use to dynamically load Haskell code.
04:14:22 <Tefaj> Bonus points if your solution involves LD_PRELOAD.
04:14:28 <cizra> Lemmih: I don't think we're on the same level of competence, so I'll just shut up and go and try to write some gtk2hs code instead.
04:15:07 <geheimdienst> and this guy seems to know something: http://mostlycode.wordpress.com/2010/01/26/ghc-6-12-1-dynamic-executables-fun/
04:21:39 <cizra> Lemmih: um, what I meant that you sound like you know what you're talking about and I don't, so please don't misunderstand me (=
04:32:23 <mreh> uh, is there a manual, or quickstart for lambdacube, right now all I have is example sources
04:33:23 <byorgey> greetings from sunny Baltimore!
04:36:19 <Botje> greetings from not-so-sunny belgium!
04:36:20 <geheimdienst> no bragging about sun unless you privmsg some over to me
04:37:09 <byorgey> I was joking actually, it's gray and rainy =(
04:37:42 <geheimdienst> same as here then ... no lykes
04:37:44 <tensorpudding> Belgium and Baltimore are almost the same.
04:39:49 <cizra> And the Baltic states!
04:40:24 <geheimdienst> baltic, baltimore, baltiless
04:40:47 <cizra> Reminds me of the old adage, "Less is more or less more."
04:40:54 <geheimdienst> baltiless is more
04:43:28 <tensorpudding> belgimore
04:44:46 <bastl> geheimdienst: yes, it worked, though I had to manually change the hashes in the package.conf.d.
04:45:14 * cizra is confused
04:45:16 <cizra>     Couldn't match expected type `a -> a1'
04:45:16 <cizra>            against inferred type `IO ComboBox'
04:45:16 <cizra>     In the first argument of `(>>=)', namely
04:45:27 <cizra> Since when >>= takes a function as its first argument? It should take a monadic value.
04:46:11 <quicksilver> if must believe the monad in question is (->)
04:46:15 <quicksilver> s/if/it/
04:46:44 <cizra> quicksilver: ummm. I'm in IO monad. At least I believed I was.
04:47:22 <cizra> What I was trying to do was to transform code from do-notation into >>=-notation.
04:47:44 <cizra> Hmmmm! Hey, can I place >>= into a do-notation? Perhaps this was the error. I had a >>= inside a do-block.
04:49:37 <quicksilver> cizra: yes, you can put >>= in a do block
04:49:41 <quicksilver> cizra: you did something wrong, obviously
04:49:54 <quicksilver> and as a result the type checker found the monad to be (->)
04:50:00 <quicksilver> show us the code!
04:50:01 <Botje> cizra: can you show code?
04:50:32 <cizra> gimme a couple
04:50:36 <quicksilver> one way to get this error is to miss off a parameter
04:51:00 <quicksilver> :t putStrLn >>= \_ -> putStrLn "world"
04:51:01 <lambdabot>     Couldn't match expected type `String -> b'
04:51:01 <lambdabot>            against inferred type `IO ()'
04:51:01 <lambdabot>     In the expression: putStrLn "world"
04:51:01 <cizra> I'll scrape off some useless sauce, for your reading pleasure.
04:51:13 <quicksilver> ^^ I missed off the "hello" parameter for the first putStrLn
04:51:19 <quicksilver> and that gave me an error rather like yours.
04:51:33 <mreh> more or less
04:51:45 <mreh> wrong channel
04:52:14 <cizra> http://hpaste.org/40160/error
04:54:34 <geheimdienst> cizra, try adding some parens everywhere
04:55:03 <ManateeLazyCat> Looks strange, Data.ByteString.UTF8.toString convert ByteString to UTF8 String, and pass UTF8 String to mplayer, mplayer don't accept path.
04:55:27 <cizra> geheimdienst: Worked
04:55:32 <cizra>   (xmlGetWidget xml castToComboBox "combo_leftover") >>= ((flip comboBoxSetActive) 0)
04:56:12 <cizra> Removing some parens: This still works:
04:56:12 <cizra>   xmlGetWidget xml castToComboBox "combo_leftover" >>= (flip comboBoxSetActive) 0
04:56:23 <ManateeLazyCat> cizra: Is you request Assistant widget in gtk2hs? 
04:56:32 <geheimdienst> i guess your code was being parsed as (xmlGet ... >>= flip) $ comboBox...
04:56:59 <cizra> ManateeLazyCat: I dunno, I decided against using Assistants (= Still, I'm doing stuff with gtk2hs, so thank you!
04:57:01 <geheimdienst> obviously that wouldn't work
04:57:35 <ManateeLazyCat> cizra: Sorry, too many nick, i can't remember. :)
04:57:35 <cizra> geheimdienst: Ummm. Wouldn't work because flip doesn't take a monadic value?
04:57:47 <cizra> ManateeLazyCat: Yeah, you're talking to the right guy (;
04:57:53 <ManateeLazyCat> cizra: I have add Assistant widget in darcs version, gtk2hs-0.12.0 will release soon.....
04:58:41 <ManateeLazyCat> cizra: Maybe you can try gtk2hs darcs, if you find any bug in Assistant binding, we can fix it before gtk2hs-0.12.0
04:59:04 <cizra> ManateeLazyCat: I don't want to use Assistants anymore. Thank you, though.
04:59:17 <ManateeLazyCat> cizra: What?
04:59:41 <ManateeLazyCat> cizra: I remember one night you ask me add it?
04:59:49 <cizra> ManateeLazyCat: I decided a simple dialog with tabs gives better overview than Assistants. Yes, I wanted them once, but I don't want them anymore.
05:00:03 <ManateeLazyCat> cizra: Ok.
05:00:32 <cizra> ManateeLazyCat: Still, I'm using gtk2hs, so I'm grateful (=
05:01:24 <ManateeLazyCat> cizra: It's okay, i will add all widget and don't care user whether use it. :)
05:01:43 <ManateeLazyCat> cizra: In gtk2hs-0.12.0 have many new APIs.
05:02:22 <ManateeLazyCat> cizra: Look http://www.gtk.org/language-bindings.html and search Haskell. :)
05:03:21 <ManateeLazyCat> cizra: If have time, help us test gtk2hs darcs. Thanks! :)
05:04:03 <cizra> ManateeLazyCat: ooh, Haskell support seems very complete!
05:04:08 <cizra> ManateeLazyCat: Okay, I will!
05:05:18 <ManateeLazyCat> cizra: I have scan GTK+ 2.24 (newest stable version) to update gtk2hs, please let me know if you find any APIs not binding in gtk2hs.
05:07:06 <cizra> ManateeLazyCat: I'm a GTK newbie, so I wouldn't know (= But I'll tell you if I notice anything funny.
05:07:17 <ManateeLazyCat> cizra: Thanks! :)
05:09:21 * hackagebot mmap 0.5.7 - Memory mapped files for POSIX and Windows  http://hackage.haskell.org/package/mmap-0.5.7 (GracjanPolak)
05:13:04 <cizra> ManateeLazyCat: darcs failed:  Couldn't fetch `0000000000-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
05:13:48 <ManateeLazyCat> cizra: darcs get http://code.haskell.org/gtk2hs ?
05:14:33 <tomh> anyone here involved in lambdacube?
05:16:47 <cizra> ManateeLazyCat: yes, but on the second try, it worked.
05:17:49 <ManateeLazyCat> cizra: You can install gtk2hs darcs with command "./bootstrap.sh" 
05:18:57 <ManateeLazyCat> cizra: Then use any new APIs you like, gtk2hs code has freeze now, except bug, we won't change API.
05:19:17 <cizra> ManateeLazyCat: Okay... Will it override my current cabal-installed gtk2hs?
05:21:11 <ManateeLazyCat> cizra: Yes.
05:21:44 <ManateeLazyCat> cizra: You can switch to 0.11.xx by "cabal install gtk" anytime.
05:22:40 <manateeUser> Hi all. :)
05:24:37 * Saizan wonders if Barendregt ever joined #haskell
05:24:51 <cizra> ghc just ate a gigabyte o' memory )=
05:25:15 <Nibble>  cizra: I ran out of ram when using darcs once
05:26:34 <Botje> preflex: seen Barendregt
05:26:35 <preflex>  Sorry, I haven't seen Barendregt
05:27:03 <manateeUser> cizra: GHC when compiling large projects will eat too much memory. (Translate by Google)
05:28:01 <cizra> manateeUser: yes...
05:28:20 * zygoloid has found more problems with linking eating memory than ghc
05:28:28 <opqdonut> yeah, linking
05:28:30 <opqdonut> *shudder*
05:28:57 <manateeUser> GHC 7.0 can fix this problem since it use LLVM backend?
05:30:09 <cizra> manateeUser: It complains that mtl is not installed, although it really is!
05:30:23 <cizra> manateeUser: cairo and glade complain. gtk2hs didn't complain.
05:31:38 <ManateeLazyCat> cizra: ghc-pkg list | grep mtl ?
05:32:00 <cizra> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details. mtl-1.1.1.0
05:32:25 <ManateeLazyCat> cizra: Maybe you need re-install mtl first.
05:33:00 <cizra> ManateeLazyCat: same.
05:33:22 <ManateeLazyCat> cizra: Can you paste the result of "ghc-pkg check"?
05:34:06 <cizra> http://hpaste.org/40162/ghcpkg_check
05:34:36 <tomh> anyone used lambacube before?
05:35:53 <mreh> tomh: some people have, but I cant find any documentation myself
05:35:55 <zygoloid> lambdacube-the-description-of-type-systems-by-reference-to-the-presence-or-absence-of-three-specific-orthogonal-features?
05:36:04 <ManateeLazyCat> cizra: re-install glade package will fix problem.
05:36:19 <siracusa> ManateeLazyCat: Hi! I have a new error for you to solve: http://hpaste.org/40163/gtk2hs_compilation_error :-)
05:36:44 <mreh> zygoloid: more the binding to openGL
05:36:48 <ManateeLazyCat> siracusa: Looking.
05:37:12 <Cale> Whoa, there's some insanely mixed tabs and spaces in lambdacube's source. :)
05:37:20 <cizra> ManateeLazyCat: cabal install --reinstall glade worked well enough (= My program runs again. However, how do I know I'm using the latest version of gtk2hs? Is there an API function for returning the version number?
05:37:27 <siracusa> ManateeLazyCat: Ther problem must be elsewhere because the error line doesn't have so much columns.
05:38:07 <ManateeLazyCat> cizra: No such function return version of gtk2hs.
05:38:13 <cizra> OK
05:38:54 <ManateeLazyCat> siracusa: Strange, can you paste your Viewport.chs?
05:38:54 <Cale> hehe, char.cube
05:39:46 <siracusa> ManateeLazyCat: The original file?
05:40:38 <ManateeLazyCat> siracusa: Do you touch that file?
05:41:33 <siracusa> ManateeLazyCat: No I didn't. http://hpaste.org/paste/40163/viewportchs#p40164
05:43:24 <ManateeLazyCat> siracusa: Sorry, i need cut some people's network in LAN, damn P2P eat all upload bandwidth....
05:43:30 <ManateeLazyCat> siracusa: Back soon...
05:44:52 <mreh> the university killed all my P2P connections :(
05:45:10 <mreh> WHY HAS NO-ONE DOCUMENTED LAMBDACUBE?!
05:45:28 <Tefaj> Welcome to homebrew gaming!
05:46:01 <mreh> is there any high-level alternatice to openGL-raw or GLUT?
05:48:09 <mreh> calling it homebrew gaming is a bit prejudiced
05:48:09 <Jaak> mreh: you mean something like ogre?
05:49:11 <mreh> Jaak: hmm, maybe
05:50:13 <Jaak> i don't think there's a full blown 3d engine implemented in haskell
05:50:45 <Tefaj> OpenGL isn't particularly "high-level"
05:50:51 <mreh> there are haskell bindings to lots of things
05:51:08 <mreh> Tefaj: I didn't say it was, that's why I wanted an alternative
05:51:13 <mreh> :)
05:51:14 <Tefaj> In fact, it's a backend to most of those things
05:51:51 <mreh> indeed, direct3D support would be a bonus
05:53:51 <earthy> mreh??? 
05:53:59 <earthy> 'no one documented lambdacube'?
05:54:03 <mreh> earthy?!
05:54:12 <mreh> show me!
05:54:21 <earthy> the lambda cube has been quite completely documented by Henk Barendregt
05:54:32 <earthy> or are we talking about different things?
05:54:36 <mreh> earthy: yes
05:54:39 <Cale> earthy: I think he's talking about the lambdacube package on hackage.
05:54:43 <earthy> *ah!*
05:54:45 <earthy> :)
05:54:47 <Cale> The syntax seems pretty straightforward to me.
05:54:58 <earthy> well, the code is the documentation, right? :)
05:55:17 <Cale> There's enough example code included to get the idea well enough.
05:56:13 <mreh> I couldn't gleam the semantics quickly from reading the sources
05:56:27 <mreh> examples, not sources
05:57:47 <mreh> would it be worth learning openGL first
06:05:08 <Tefaj> If you want to use OpenGL, it would be advisable to do that
06:23:59 <AndyStewart> siracusa: still in other box, wait me a moment
06:27:41 <chrisdone> ManateeLazyCat: where's AndyStewart? :p
06:32:47 * hackagebot hylotab 1.2.0 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/hylotab-1.2.0 (GuillaumeHoffmann)
06:33:06 <Nibble> ^ only in haskell channel
06:42:15 <greap> I want to parse a natural number using parsec, currently I'm using liftM read . parse digits, but I'd like to avoid read so I'm trying to use Token.natural, this seems to only be able to automatically consume space after the digits, I need to specify that the space afterwards is a newline rather than just whitespace, is there a way to not consume the space, or specify what it is using Token?
06:42:29 <ManateeLazyCat> siracusa: I'm back.
06:42:46 <ezyang> greap: That was one of my complaints with the tokenizer module 
06:42:55 <ManateeLazyCat> siracusa: Much better now after i install NetLimiter. :)
06:42:57 <ezyang> read is probably your best option. 
06:43:24 <ManateeLazyCat> Infact, we just limit the upload speed of P2P software is enough.
06:44:31 <ManateeLazyCat> siracusa: Why add " --ghc-option=-DCABAL_VERSION_MINOR=8" ?
06:44:44 <ManateeLazyCat> chrisdone: AndyStewart is me, you know. :)
06:45:16 <siracusa> ManateeLazyCat: Otherwise I get errors when doing cabal configure
06:45:55 <ManateeLazyCat> siracusa: Can you paste that error?
06:46:29 * ManateeLazyCat I'm re-installing gtk after "cabal clean"
06:47:09 <ManateeLazyCat> siracusa: I just do "cabal install" directly, don't need "cabal configure". :)
06:48:46 <chrisdone> ManateeLazyCat: I know, Andy :p
06:48:55 <ManateeLazyCat> chrisdone: :)
06:49:21 <siracusa> ManateeLazyCat: I now, but cabal install will also do that. Here's the error: http://hpaste.org/paste/40163/cabal_configure_error#p40165
06:50:05 <manateeUser> Haha, I can use Google Translate. (Translate by Google)
06:50:28 <ManateeLazyCat> Good, network delay disappear...
06:50:50 <chrisdone> manateeUser: say something in your native language!
06:51:15 <manateeUser> chrisdone: how you doing ah? ^ _ ^
06:51:24 <chrisdone> :D
06:51:37 <manateeUser> 你怎么样啊？
06:51:48 <ManateeLazyCat> ^^^ translate from English
06:51:52 <chrisdone> oh god hyroglphs am i on stargate
06:52:22 <chrisdone> ManateeLazyCat: does it translate english messages to chinese for you too?
06:52:51 <ManateeLazyCat> chrisdone: It's easy, but i think Google don't allow that, too many request. :)
06:54:19 <ManateeLazyCat> siracusa: Update you cabal.
06:54:45 <ManateeLazyCat> siracusa: Which version your cabal?
06:55:35 <ManateeLazyCat> chrisdone: If Google allow me do that, i can translate all channels on freenode.net to Chinese. :)
06:55:35 <siracusa> ManateeLazyCat: Cabal-1.8.0.4
06:55:51 <greap> ezyang: Thanks. Isn't there something faster and safer than read though?
06:57:35 <ezyang> greap: Read with an explicit type signature :-) 
06:57:37 <chrisdone> readMay is safe
06:58:01 <ezyang> You're enforcing a local digits invariant, so I think it's fairly safe as far as that gos. 
06:58:43 <ManateeLazyCat> siracusa: Hmm, looks cabal guess version on Windows.
06:59:23 <chrisdone> ezyang: I don't like it though
06:59:35 <ManateeLazyCat> siracusa: Your option for cabal is right.
07:00:02 <chrisdone> local invariants often end up unwittingly exposed as non-local invariants which aren't enforced from outside and cause bugs
07:00:10 <ezyang> Sure. 
07:00:28 <ezyang> I think parsing code is lower risk than other code, but it's certainly a problem. 
07:00:32 <ezyang> And why we like static types :-) 
07:00:34 <chrisdone> foo = read . head . bar
07:00:37 <ManateeLazyCat> siracusa: I'm wonder you got that error in Viewport.chs, looks strange.....
07:00:42 <chrisdone> ezyang: yeah
07:01:01 <ezyang> Now, the parsec maintainers aren't a black box, iiuc, so you could ask them about this. 
07:01:21 <siracusa> ManateeLazyCat: Yeah, and I never got that before.
07:02:05 <ManateeLazyCat> siracusa: I can't recur this bug on Linux.
07:03:37 <ManateeLazyCat> siracusa: We never touch Viewport.chs after gtk2hs-0.11.x
07:04:07 <ManateeLazyCat> chrisdone: You're maintainer of hpaste.org, ah?
07:04:13 <atude> J(2n) is the same as 2J(n)?
07:05:13 <ManateeLazyCat> siracusa: Can you post this bug to gtk2hs list? Axel can help you.
07:06:45 <siracusa> ManateeLazyCat: I'm trying a rebuild right now, if it fails I'll post it to the list.
07:07:00 <zygoloid> atude: depends on the definition of J :) to which J do you refer?
07:07:12 <atude> zygoloid: just J, algebraic
07:07:18 <manateeUser> chrisdone: Maybe you can talk about my philosophy of the topic, to test the Google translation is accurate. (Translate by Google).:)
07:07:23 <ManateeLazyCat> siracusa: Good. 
07:07:51 <ManateeLazyCat> siracusa: Better do "cabal clean" before re-build. :)
07:08:12 <siracusa> ManateeLazyCat: Of course I did.
07:08:15 <zygoloid> atude: where J is an algebraic function of n? no. J(n) = 1 is a counterexample.
07:09:42 <chrisdone> ezyang: fortunately haskell is expressive enough that you can make use of total functions still convenient
07:10:04 <ezyang> yup. 
07:12:51 <roconnor> join #c
07:13:04 <atude> zygoloid: example, J(n) = n/2, J(2n) = 2J(n) -1; J(20) = 2J(10) - 1 = 2 * 5 - 1 = 9
07:13:11 <zygoloid> roconnor: not a chance i'm going to do that :)
07:13:25 <atude> zygoloid: I don't understand how 2J(10) got in there
07:13:46 <roconnor> :)
07:15:14 <zygoloid> atude: i don't understand what you're asking. J(n) = n/2  and  J(2n) = 2J(n) - 1  has no solutions.
07:15:34 <zygoloid> (because J(2n) = 2J(n) for that J, so the second equation reduces to 0 = -1)
07:18:06 <atude> zygoloid: for n >= 1
07:18:54 <zygoloid> atude: i still have no idea what you're asking. what is J?
07:19:05 <atude> zygoloid: it's a variable...
07:19:15 <atude> rather, function 
07:19:25 <zygoloid> an arbitrary function? a specific function?
07:19:37 <atude> I don't know.. a function.. f(x)
07:19:44 <atude> except, J
07:20:00 <zygoloid> ok. and what's your question?
07:20:30 <atude> I don't understand how J(20) = 2J(10) -1
07:21:05 <zygoloid> atude: in general, it's not. you've missed out an important part of the question.
07:21:54 <chrisdone> I hope one day mmorrow comes back with an accompanying soundtrack, Still M.M.
07:21:57 <atude> zygoloid: something must be missing then
07:22:34 <zygoloid> ezyang: look, i know may week is a fortnight in june here in cambridge, but even by our standards, you're running /very/ late for the 2009-2010 academic year.
07:23:03 <ezyang> zygoloid: Heh :-) 
07:23:16 <atude> zygoloid: http://en.wikipedia.org/wiki/Josephus_problem
07:23:35 <zygoloid> also we should set up some kind of haskell user group :) there are a few of us haskellers here outside MSR (at least during term) :)
07:25:35 <zygoloid> atude: ok, so it's a specific J function then. specifically, this one...
07:26:03 <zygoloid> > let j n | even n = j (n `div` 2) - 1 | otherwise = j (n `div` 2) + 1 in j 10
07:26:04 <lambdabot>   *Exception: stack overflow
07:26:13 <zygoloid> > let j 1 = 0 j n | even n = j (n `div` 2) - 1 | otherwise = j (n `div` 2) + 1 in j 10
07:26:14 <lambdabot>   <no location info>: parse error on input `|'
07:26:17 <zygoloid> > let j 1 = 0; j n | even n = j (n `div` 2) - 1 | otherwise = j (n `div` 2) + 1 in j 10
07:26:18 <lambdabot>   -1
07:30:53 <atude> zygoloid: I don't understand..
07:32:58 <jinjing> is cabal update dead or just me?
07:33:13 <atude> zygoloid: f(n) = n/2, f(2n) = 2f(n) - 1; table says if n = 5, f(n) will be 3 but... f(2(5)) != 2(f(5)) - 1 
07:34:11 <zygoloid> atude: you can't have both f(n) = n/2 and f(2n) = 2f(n) - 1; where are you getting that from?
07:34:42 <atude> zygoloid: I just posted a link
07:34:51 <atude> zygoloid: http://mathworld.wolfram.com/JosephusProblem.html
07:35:15 <atude> zygoloid: I mean, http://en.wikipedia.org/wiki/Josephus_problem
07:35:35 <quicksilver> atude: I do not see "f(n) = n/2" at that link.
07:36:12 <quicksilver> I see f(2n) = 2f(n)-1 and f(2n+1) = 2f(n)+1
07:36:14 <quicksilver> which make sense.
07:36:24 <atude> quicksilver: me either actually. that's my book that says that
07:36:50 <atude> quicksilver: anyways, even without f(n) = n/2, f(2(5)) != 2(f(5)) - 1 
07:37:18 <quicksilver> why?
07:37:42 <quicksilver> that's an equation relating f(10) and f(5)
07:37:46 <quicksilver> what makes you think it doesn't hold?
07:37:55 <zygoloid> atude: f(5) = 3. f(10) = 5 = 2*3 - 1.
07:37:57 <atude> .... I just wrote it out... 2(5) = 10; 2(5) - 1....
07:39:20 <atude> how does f(10) = 5?
07:39:36 <zygoloid> atude: try it by hand. or use the equations (and proof) on wikipedia
07:39:45 <atude> zygoloid: I am.....
07:40:06 <atude> all I have done is written it out, i'm missing something and I cannot figure it out
07:40:46 <zygoloid> there's also a table on that wikipedia page
07:40:51 <atude> I see that...
07:40:57 <atude> my number are not matching up
07:41:02 <atude> I always get 1 exactly less
07:41:15 <atude> than n that is
07:41:40 <atude> if n is 10, I get 9, not 7
07:42:01 <zygoloid> > let f [a] = a; f (a:b:as) = f (as ++ [a]) in f [1..10]
07:42:02 <lambdabot>   5
07:42:17 <zygoloid> atude: if you always get 1 less, i think you're doing this:
07:42:20 <zygoloid> > let f [a] = a; f (a:b:as) = f (as ++ [b]) in f [1..10]
07:42:21 <lambdabot>   4
07:42:30 <zygoloid> (that is, you're killing the first person rather than skipping the first person)
07:42:42 <zygoloid> or maybe you're counting from 0 rather than 1?
07:43:07 <atude> zygoloid: no, I'm not counting from anything, I'm simply entering the numbers into the function
07:43:20 <zygoloid> atude: which function now?
07:43:32 <atude> f(2n) = 2f(n) - 1
07:44:22 <zygoloid> atude: that's only half of the function, and not enough to determine f(10)
07:44:35 <atude> zygoloid: what is the rest?
07:44:44 <zygoloid> f(2n+1) = 2f(n) + 1
07:44:56 <quicksilver> as I've already said :)
07:45:58 <atude> zygoloid: that's not the same function so why would the one I was using even matter
07:46:02 <zygoloid> now, f(10) = f(2*5) = 2*f(5) - 1 = 2*f(2*2+1) - 1 = 2 * (2 * f(2) + 1) - 1 = 2 * (2 * 1 + 1) - 1 = 2 * 3 - 1 = 5
07:46:03 <atude> seems completely irrelivent
07:46:32 <quicksilver> atude: they are two clauses which define a single function.
07:46:51 <quicksilver> atude: the function 'f' is defined by the two clauses "f(2n) = 2f(n) - 1" and "f(2n+1) = 2f(n) + 1"
07:46:57 <quicksilver> either one on its own is not sufficient.
07:47:08 <zygoloid> atude: one equation says what to do if the argument to f is odd, the other says what to do if it's even.
07:47:10 <quicksilver> the first clause defines the action on even numbers, the second on odd numbers.
07:48:49 <zygoloid> atude: in any case, i don't see this turning into a haskell-related question. maybe you should ask in #math if you're still having trouble
07:49:06 <atude> zygoloid: haskell guys are a lot smarter
07:49:31 <atude> zygoloid: also a lot of stuff on the haskell site pushes me into similar questions
07:49:51 <atude> quicksilver: so f(x) = f(2n) = 2f(n) -1?
07:50:32 <quicksilver> I don't know what you intend to ask with that question.
07:50:56 <quicksilver> the notation assumes that n is integral. Therefore 2n is even and 2n+1 is odd.
07:51:13 <atude> 2n - 1 is also odd
07:51:16 <zygoloid> atude: f(n) = { 2 * f(n/2) - 1 if n is even, 2 * f[n/2] + 1 if n is odd }
07:51:21 <quicksilver> therefore the two equations are not contradictory, but complementary - one applies to even arguments and one applies to odd arguments.
07:51:35 <quicksilver> I honestly can't think of anything else to say, I've been explaining this on and off for a long time now ;)
07:51:37 <zygoloid> where [x] is the floor function
07:52:18 <atude> zygoloid: where did you get n/2?
07:52:45 <aristid> atude: 2n-1 produces -1 for n=0, which maybe you don't want
07:54:00 <atude> aristid: n >= 0
07:54:08 <atude> aristid: n >= 1 **
07:54:25 <aristid> ok:)
07:55:01 <zygoloid> atude: do you understand that the two equations /together/ define f?
07:55:55 <atude> zygoloid: on input, where would you start? If you're missing one part of the equation, nothing works
07:56:34 <zygoloid> atude: ok, so you have an equation which works if the argument to f is of the form 2*n for some n
07:56:43 <yitz> greap: did you solve your parsing problem?
07:56:44 <zygoloid> and one which works if the argument to f is of the form 2*n+1 for some n
07:57:06 <zygoloid> since we're working in integers, exactly one of those will work for each n. so pick that one.
07:57:28 <atude> zygoloid: I think I get it.. let me make sure :D
08:03:37 <pozic> Why can every even number>2 be written as the sum of two primes? 
08:04:47 <zygoloid> pozic: oh, by a simple diagonalization argument on the pairs of primes. that'll be $1M, please
08:04:57 <medfly> heh
08:05:09 <pumpkin> pozic: ask @faq
08:05:14 <bremner> pozic: it can't. That will also be $1M
08:05:21 <atude> o_o
08:05:34 <zygoloid> pozic: is the 1M even for a negative answer for that one?
08:05:37 <pozic> zygoloid: damn, I wanted that everyone would think very hard about it ;)
08:05:40 <fryguybob> .query lambdabot
08:05:43 <pozic> zygoloid: you spoiled it!
08:07:01 <zygoloid> pozic: i still left people the opportunity to think very hard about the diagonalization argument
08:07:11 <zygoloid> it's not an easy problem, you need to give people a /hint/ at least :)
08:07:58 <pozic> By the time the problem is solved, you can buy a whole popsicle for $1M. They should increase the prize money by inflation. 
08:08:07 <zygoloid> the prize expired in 2002
08:08:16 <pumpkin> I want a whole popsicle
08:09:04 <zygoloid> in any case it turns out it's related to a certain problem in finite model theory: prove that the second-order existential operator is more powerful than the partial fixed point operator at extending first-order predicates over finite models.
08:09:21 <pumpkin> oh, of course
08:09:22 <pozic> Ah, it's not even one of the millenium problems. 
08:10:25 <zygoloid> (basically that's just proving that there are finite model relations which can't be defined inductively)
08:10:53 <pozic> zygoloid: what is the second-order existential operator? 
08:10:59 <mreh> what's the deal with documentation missing from some hackage package versions?
08:11:00 <pozic> zygoloid: it seems rather obviously wrong that. 
08:11:21 <zygoloid> pozic: (exists R. P(R)) where P is a predicate and R is a predicate.
08:11:27 <pozic> zygoloid: everything which is finite is basically 'trivial'. 
08:12:40 <zygoloid> pozic: the $1M prize for /that/ is still available :)
08:13:04 <jinjing> wow, needed to setup a http proxy server to use cabal ..
08:15:00 <pozic> zygoloid: who says that relation exists, btw?
08:15:44 <zygoloid> pozic: the resulting predicate says the relation exists
08:16:51 <pozic> zygoloid: I mean like a paper/article/book. 
08:17:34 <fryguybob> > let primes = take 100 (let s (p:ps) = filter ((/=0).(`mod`p)) ps in s [2..]) in and $ zipWith (==) [6,8..402] $ nub . sort $ [x+y | x <- primes, y <- primes]
08:17:35 <lambdabot>   True
08:17:53 <zygoloid> pozic: Fagin's theorem.
08:19:47 <pozic> zygoloid: ah, I had heard of it, just not the name. 
08:21:32 <zygoloid> pozic: this paper is a pretty good summary: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.79.9175&rep=rep1&type=pdf
08:27:05 <yrlnry> Why have type classes at all?  What if instead there was a way to declare an identifier as a naming overloaded function, and a type as supporting a particular overloaded function.  For each function definition, the compiler could automatically determine which overloaded functions its arguments were required to support, similar to how it does now.  A type signature, instead of involving type classes, would look something like (t requires (fromInteger, 
08:27:05 <yrlnry> (+), show), t1 requires ((>>=), return, fmap)) => t -> t1 -> [t, t1].
08:27:16 <yrlnry> What do the type classes actually get one?
08:27:42 <Cale> yrlnry: The ability to easily define polymorphic functions simply by using polymorphic functions.
08:28:13 <yrlnry> Cale:  I don't understand how that would be different if the type classes were implicit as in my suggestion.
08:28:41 <Cale> Well, I don't understand the type signature that you gave there.
08:28:55 <pumpkin> it seems like you're suggesting typeclasses of one method each
08:28:59 <yrlnry> Yes, just so.
08:29:03 <Cale> What does it mean for t1 to require ((>>=), return, fmap)?
08:29:08 <pumpkin> sometimes one method doesn't make sense without others
08:29:14 <pumpkin> nothing stopping you from breaking it up by method though
08:29:19 <Cale> It appears that you expect t1 to have kind *
08:29:19 <yrlnry> And that they not be declared separately from the overloaded functions.
08:29:37 <Cale> But (>>=), return and fmap are all of different types
08:29:55 <Cale> and normally the typeclasses which define them are parametrised over a type constructor of kind * -> *
08:29:58 <yrlnry> pumpkin:  what can I say to Cale that will get him to stop whatever line of misunderstanding he is on?
08:30:16 <pumpkin> well I agree with him
08:30:20 <pumpkin> you aren't specifying types in there
08:30:44 <yrlnry> Hmm.  Then perhaps I haven't thought this through carefully enough.
08:31:14 <yrlnry> Yes, you're right.  I screweded up the kind of t1 in the RHS of my example.
08:31:20 <pumpkin> I just mean
08:31:31 <pumpkin> sometimes what implementation is defined by combinations of types on the methods
08:31:38 <pumpkin> just talking about "I need return" doesn't say much
08:31:45 <pumpkin> you might need two different returns on different monads
08:32:00 <pumpkin> like for example
08:32:04 <pumpkin> :t fmap . fmap
08:32:05 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:32:17 <pumpkin> those fmaps come from different functors
08:32:23 <pumpkin> the resulting type is constrained appropriately
08:32:32 <yrlnry> Why wouldn't it be enough to say that there are f and f1 both of which require fmap?
08:32:44 <pumpkin> you're not being as specific
08:32:50 <yrlnry> How so?
08:33:18 <Cale> yrlnry: Consider the type inference involved.
08:33:23 <yrlnry> cale: Thanks for  pointing out my kinding mistake.
08:33:47 <Cale> What would the inferred type of  fmap . fmap  be in your system?
08:34:23 <yrlnry> (f requires fmap, f1 requires fmap) =>  (a -> b) -> f (f1 a) -> f (f1 b)
08:34:28 <Cale> (It might be possible to make such a system work well -- I'm just seeing if what you're thinking is what I'm thinking you are :)
08:34:37 <Cale> That doesn't seem specific enough...
08:34:44 <Cale> Or...
08:34:47 <pumpkin> yrlnry: fmap might not just have one constrained type
08:34:50 <siracusa> manateeUser: Still there?
08:34:52 <pumpkin> what if you have an MPTC?
08:34:56 <Cale> How does it know what the part to the right of the => looks like there?
08:35:03 <pumpkin> or the f doesn't specify the function completely?
08:35:30 <Cale> Is there a declaration of the way in which fmap is polymorphic (like a class declaration) specified elsewhere?
08:35:30 <yrlnry> What is the difference between saying that f is a functor, and that f1 is a type constructor of kind * -> * that supports fmap in the way that functors do?
08:35:37 <neun_work> @msg lambdabot
08:35:38 <lambdabot> Not enough privileges
08:35:39 <pumpkin> yrlnry: we specify the entire type
08:35:49 <pumpkin> yrlnry: fmap :: (a -> b) -> (f a -> f b)
08:36:01 <pumpkin> you're picking out one piece of that type signature and slapping your "requires" syntax onto it
08:36:07 <pumpkin> how do you pick one over another?
08:36:36 <pumpkin> what if it were distribute :: f (g a) -> g (f a) ?
08:37:09 <yrlnry> In haskell one says    class Functor f  where fmap ...   .   
08:37:21 <pumpkin> one can also say class Moo f g x where ...
08:37:35 <zygoloid> yrlnry: you lose something and gain nothing by restricting typeclasses to having a single method
08:37:36 <pumpkin> and you can also constrain contexts to match types
08:38:04 <yrlnry> zygoloid:  what is lost?
08:38:09 <zygoloid> yrlnry: superclasses
08:38:18 <yrlnry> Mm.
08:38:41 <Cale> yrlnry: You could make some other sort of declaration where the class is named by the unique function declared inside it, and there's only ever one method per class, and the type parameters over which you're generalising are made explicit...
08:38:45 <zygoloid> classes with no methods (you can hack around that i suppose)
08:38:51 <Cale> But it's not that much different from typeclasses, only less convenient.
08:39:06 <yrlnry> I am not really restricting them to having one method.  I just want the user to specify single-method typeclasses, and the others are implicit.
08:39:18 <yrlnry> Generated automatically by unions and intersections.
08:39:30 <Cale> yrlnry: You still need to say which type parameters you're generalising over.
08:39:36 <Cale> (explicitly)
08:39:39 <yrlnry> Yes, I agree that is a problem I had not thought of.
08:39:58 <Cale> fmap :: (a -> b) -> f a -> f b -- is this typeclass polymorphic in a? b? f?
08:40:10 <yrlnry> Yes, I agree that is a problem I had not thought of.
08:40:16 <Cale> okay :)
08:40:21 <yrlnry> Thanks :)
08:40:38 <Cale> So, you end up with a declaration of that, and it starts looking more like normal typeclasses, with at most one method then.
08:41:40 <yrlnry> Is that obviously worse?
08:43:29 <Cale> Well, often the only sensible laws satisfied by methods of a typeclass involve more than one of the methods at a time.
08:43:50 <yrlnry> Oh, like it doesn't make sense to have >>= without also fmap.
08:43:59 <yrlnry> Hmm.
08:44:00 <Cale> Or return, at least.
08:44:04 <yrlnry> Yes.
08:44:49 <Cale> Also, there's a fair amount of good uses for typeclasses having no methods at all.
08:46:13 <Cale> (Which are either subclasses or superclasses of a bunch of others.)
08:46:37 <yrlnry> My idea does not get rid of these.
08:46:52 <yrlnry> I want the typeclass world to be closed under unions and intersections anyway.
08:47:20 <gwern> > 0.2 * 200
08:47:21 <lambdabot>   40.0
08:47:48 <Cale> Under intersections is easy and meaningful, under unions is weird.
08:48:14 <yrlnry> I don't mean unions of the classes themselves; I mean unions of the set of overloaded functions they support.
08:48:19 <Cale> ah
08:49:23 <yrlnry> Thanks very much for discussing this with me.   I need to think it over some more now.
08:49:39 <Cale> okay, cheers
08:50:51 <chrisdone> why can't I derive a Typeable instance for records with fields of kind * -> *?
08:51:59 <Heffalump> how could a record have a field of that kind?
08:52:00 <chrisdone> supposing I provide a type to the type constructor leaving fields of kind *
08:52:01 <quicksilver> I didn't know you could have fields of kind * -> *
08:52:32 <chrisdone> no, I mean the type of the field having kind * -> *, not the field itself O_o
08:52:48 <chrisdone> data A f = A { foo :: f Int }
08:52:49 <Heffalump> no, I still don't see it
08:52:52 <tg_> hehe
08:52:53 <Heffalump> oh, you mean parameter
08:52:54 <Heffalump> not field
08:52:59 <quicksilver> chrisdone: "f Int" has kind *
08:53:09 <Heffalump> f is a parameter to A, not a field of A.
08:53:15 <quicksilver> anyway, the answer to the question you meant to ask, I think
08:53:15 <Heffalump> foo (of type f Int) is the field
08:53:19 <tg_> it's fun being able to figure out the levels of confusion on two sides of a conversation while being totally ignorant of the subject matter
08:53:32 <quicksilver> is that there isn't a TypeableXX class of quite the right sort for you
08:53:45 <quicksilver> there's Typeable for * and Typeable1 for * -> *
08:53:53 <quicksilver> but there isn't anything for (* -> *) -> *
08:53:56 <quicksilver> which is what you want, I think.
08:54:25 <chrisdone> where f : (* -> *) -> *?
08:54:32 <chrisdone> no
08:54:40 <quicksilver> chrisdone: no, A :: (* -> *) -> *
08:54:47 <chrisdone> right
08:54:54 <chrisdone> can I define my own instance?
08:55:02 <quicksilver> in principle yes.
08:55:08 <quicksilver> I certainly can't tell you how, though :)
08:55:11 <chrisdone> then all may not be lost
08:55:16 <chrisdone> okay, maybe some is lost
08:55:46 <dolio> instance (Typeable1 f) => Typeable (A f) where ...
08:55:58 * chrisdone tries
08:57:15 <knobo> http://hpaste.org/paste/40167/test_tree_for_tree_parser#p40168
08:57:33 <knobo> I'm trying to learn parsec
08:57:47 <knobo> The paste above is a parser and a file to parse
08:57:54 <knobo> Line number 6 is parsed wrong
08:58:03 <knobo> The fileformat is very simple
08:58:51 <knobo> It uses tabulators to indicate that you go down in the tree
08:59:10 <knobo> The parser ignores one tab on line6
09:00:11 <Cale> http://www.guardian.co.uk/science/the-lay-scientist/2010/sep/24/1 -- haha
09:00:25 <chrisdone> dolio: hmm I want to derive the Typeable for (A f)
09:01:03 <dolio> quicksilver already explained why that won't work.
09:01:51 <chrisdone> ok nevermind
09:04:48 <zygoloid> yrlnry: for what it's worth, i was wrong earlier when i said there'd be no benefit. many a time i've wanted to write an instance for "part of Num"...
09:07:09 <zygoloid> i also think you'd want explicit typeclasses, not just collections of members, in order to require people to opt into certain laws
09:07:59 <yrlnry> zygoloid:  that was my original motivation.   Library author defines some typeclass that has foo and bar, which he decides are not useful independently.  Then later someone discovers that is *is* useful to have foo without bar, but the library can't be changed for backward compatibility reasons.
09:08:17 <yrlnry> And you have all these functions out there in the wild that claim to require both foo and bar when really mayb they only require foo.
09:08:28 <jdpage> Hey, newbie question. I know that because Haskell is a purely functional language, once it has calculated the value for a function, then it doesn't need to again - it could just cache the value. What flags do I pass to ghc to enable this? Based on my program runtime, it doesn't seem to be doing that.
09:08:28 <yrlnry> Num being a prime example, but Monad being another.
09:08:37 <geheimdienst> cale, that's quite funny :-) thanks. could almost be from the onion
09:09:11 <knobo> I'm specially concerned about this part:   subtree <-  option [] (try (many1 (parseTree (tabs + 1))))
09:09:39 <monochrom> no flags. you write "let x = f y in repeat x" in order to ensure f y is done at most once.
09:10:14 <gwern> > (1*0.6 - 0.55) / 1
09:10:14 <lambdabot>   4.999999999999993e-2
09:10:23 <gwern> > ((1*0.6 - 0.55) / 1) * 100
09:10:24 <lambdabot>   4.999999999999993
09:10:36 <knobo> And I wonder if there is a better way to read a line then do <- many1 (nonOf "\n")
09:10:36 <knobo>    char '\n'
09:10:43 <gwern> > 0.05 * 160
09:10:44 <lambdabot>   8.0
09:10:48 <jdpage> monochrom, what exactly does that do?
09:10:54 <medfly> wtf?
09:10:59 <medfly> dividing by 1, multiplying by 1?
09:11:02 <monochrom> to ensure that f y is evaluated at most once.
09:11:10 <jdpage> monochrom, specifically the 'repeat x' part
09:11:16 <medfly> > (0.6 - 0.55) * 100
09:11:17 <lambdabot>   4.999999999999993
09:11:23 <monochrom> an infinite list of x's. [x,x,x,x,x...]
09:11:25 <jdpage> monochrom, I can't refer to it as 'x' for the rest of the program
09:11:37 <monochrom> I am sorry to hear that.
09:11:38 <jdpage> recursion :P
09:12:21 <gwern> medfly: hey, I'm just calculating the kelly criterion. that's how the formula goes, I'm not bothering to simplify
09:12:27 <jdpage> monochrom, so am I. I thought that if I'd done all previous steps in a recursive function, it would just remember the cached value
09:14:28 <monochrom> see also http://groups.google.com/group/comp.lang.haskell/msg/2b3bc2d6bed0c808
09:14:46 <knobo> After going through my code, I'm starting to wonder if there is a bug in parsec
09:14:53 <tg_> ICFP is this week?
09:15:10 <tg_> guess so
09:15:19 <jdpage> monochrom, argh. Memory is no object
09:15:46 <knobo> The code is so clean and simple, yet so buggy.
09:15:59 <monochrom> memory is getting slower and slower.
09:16:13 <knobo> Could someone try the code, and see if it is buggy on your computer/compilator too?
09:16:27 <jdpage> monochrom, but in this case it'd be faster
09:17:15 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example
09:17:48 <knobo> Can I trace function calls to see what happens, some how?
09:18:12 <monochrom> Debug.Trace.trace
09:18:57 <monochrom> and also ghci's debugger
09:19:07 <knobo> how do I use it?
09:19:13 <monochrom> which one?
09:19:26 <knobo> sorry, I'll use google.
09:19:52 <jdpage> Okay, can someone take a peek at my code? I am beginning to suspect that I am abusing the paradigm
09:19:54 <monochrom> I just don't know "it"=?
09:20:01 <Ke> ghci debugger is useless until it gets cabal support
09:20:32 <monochrom> why does it need cabal support? package builder is orthogonal to debugger/tracer.
09:20:50 <jdpage> http://pastebin.com/4Q2Eb3PN
09:20:54 <jdpage> ^^^ what did I do wrong
09:21:04 <jdpage> it takes forever to run after 20
09:21:07 <geheimdienst> knobo: what is your problem with the code?
09:21:28 <knobo> the parser does not parse line 6 in my test file right.
09:21:36 <quicksilver> geheimdienst: it erroneously includes a \t at the beginning of the 'content' of the 6th line
09:21:40 <quicksilver> which I can replicate
09:21:44 <quicksilver> but not immediatley see why
09:21:58 <Ke> monochrom: i see you have never used ghci debugger
09:22:04 <monochrom> pop t = let x = pop (t - step) in x + rate * x * step
09:22:11 <Ke> monochrom: it needs support to find all the modules
09:22:15 <quicksilver> Right [Tree (Line "1tree") [Tree (Line "2subtree") [Tree (Line "3sub-subtree") [],Tree (Line "4sub-subtree") [],Tree (Line "4.5sub-subtree") [Tree (Line "5sub-sub-sub... etc..") [],Tree (Line "\t6sub-sub-sub-sub... etc..")
09:22:25 <quicksilver> (is the initial fragment.
09:22:47 <quicksilver> that \t at the beginning of the 6 is wrong; it should be registered as a subtree of the 5... line
09:23:26 <geheimdienst> about the issue that it goes only to line 6: line 7 is less indented than 6. can the parser handle that yet? my casual look suggests no
09:23:30 <monochrom> let x = pop t in do printf "%.0f\t%.0f\t%.3f\t\t%.3f\n" (n::Double) t x (rate * x)
09:23:49 <ezyang> Gah, papergasm on Haskell reddit :-D 
09:24:16 <quicksilver> geheimdienst: it's supposed to make parseTree fail, so the calling parseTree drops back to []
09:24:51 <quicksilver> still, you're right that a simpler counterexample has just 4 lines
09:25:45 <quicksilver> with indents [0,1,2,1]
09:25:52 <monochrom> I guess you mean ghci debugger can't step into library functions because source code is not found.
09:25:54 <knobo> quicksilver: but isn't it recursive, so that when it drops back to [], the previous treeParser will continue at that point?
09:26:14 * quicksilver has some vague memory that try + many1 doesn't quite work the way you might think.
09:28:08 <quicksilver> knobo: that's what I said.
09:30:26 <quuxman> hrrrg... I'm logged in to a dumb PPC Ubuntu system, and can't find the ghci package
09:30:44 <monochrom> that is a very old system
09:30:57 <quuxman> monochrom: :) Used macbook from a friend
09:31:21 <monochrom> probably ghci package does not exist for it
09:31:47 <quuxman> monochrom: lamesauce. Running a dist upgrade, then I'l do at apt-file search for ghci
09:32:26 <monochrom> perhaps http://www.haskell.org/ghc/download_ghc_6_10_1.html#macosxppc ?
09:33:08 <monochrom> change 6_10_1 to 6_10_4
09:33:57 <monochrom> oh oops, that is mac os x, not linux
09:35:29 <monochrom> how about http://www.haskell.org/ghc/download_ghc_641.html#powerpclinux ?
09:36:08 <monochrom> sorry, that just says "use gentoo"
09:36:18 <monochrom> http://www.haskell.org/ghc/download_ghc_64.html#powerpclinux
09:36:23 <alise> Lemmih: just wanted to say many thanks for bringing lambdabot back to #esoteric after a long absence :)
09:36:59 <jdpage> monochrom, okay, found out about memoization, using that. Thanks.
09:37:01 <monochrom> after 6.4, they seem to cease to cater for linux powerpc 
09:37:13 * hackagebot every-bit-counts 0.1 - A functional pearl on encoding and decoding using question-and-answer strategies  http://hackage.haskell.org/package/every-bit-counts-0.1 (DonaldStewart)
09:37:46 <monochrom> and even if ghc is built for linux powerpc, it tends to lack ghci.
09:41:28 <dstcruz> clear
09:41:30 <dstcruz> ls
09:42:06 <monochrom> total 0
09:44:03 <p_l|backup> haha
09:46:01 <kburke> how would you do curry with 3 arguments?
09:46:10 <Twey> :t curry . curry
09:46:10 <kburke> let g (x,y,z) = x+y+z
09:46:11 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
09:46:20 <kburke> curry g x y z
09:46:27 <zygoloid> dstcruz: You are standing at the end of a road before a small brick building. Around you is a forest.  A small stream flows out of the building and down a gully.
09:46:33 <kburke> Couldn't match expected type `(a, b)'
09:46:33 <kburke>            against inferred type `(t, t, t)'
09:46:34 <kburke>     In the first argument of `curry', namely `g'
09:46:34 <kburke>     In the expression: curry g 2 3 4
09:46:34 <kburke>     In the definition of `it': it = curry g 2 3 4
09:46:53 <kburke> oh
09:47:04 <geheimdienst> zygoloid: what kinda filesystem tells you this kinda thing when you do ls?
09:47:08 <zygoloid> @type let curry3 f (x,y,z) = f x y z in curry3
09:47:09 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t, t1, t2) -> t3
09:47:24 <zygoloid> hmm, uncurry3?
09:47:31 <kburke> ok
09:47:38 <knobo> I added try before "indent tabs", and it looks like it fixed it.
09:47:48 <zygoloid> geheimdienst: this is a fuse-mounted adventurefs
09:47:51 <zygoloid> (in my mind)
09:48:13 <geheimdienst> what if i do find . -name "princess"?
09:48:48 <zygoloid> geheimdienst: Sorry Mario, the princess is in another castle.
09:49:13 <geheimdienst> yeah but i searched them all. that's the point. so she isn't in this filesystem
09:49:21 <geheimdienst> this game is stupid
09:49:24 <kburke> ok
09:49:41 <monochrom> the princess is trapped in the file system and you have to free her?
09:50:48 <quuxman> monochrom: can I install ghci using cabal?
09:50:49 <geheimdienst> knobo: i've looked at the code and i suspect the try (many1 parseTree ...) consumes tabs even when it ultimately fails. something in that direction
09:51:00 <quuxman> monochrom: I've got a buttload of libghc6- libraries
09:51:11 <yrlnry> @pl \f x y z  = f (x,y,z)
09:51:11 <lambdabot> (line 1, column 11):
09:51:11 <lambdabot> unexpected "="
09:51:12 <lambdabot> expecting pattern or "->"
09:51:16 <yrlnry> @pl \f x y z . f (x,y,z)
09:51:17 <lambdabot> (line 1, column 10):
09:51:17 <lambdabot> unexpected "."
09:51:17 <lambdabot> expecting pattern or "->"
09:51:23 <yrlnry> @pl \f x y z -> f (x,y,z)
09:51:24 <lambdabot> (. (,,)) . (.) . (.)
09:51:27 <geheimdienst> you're right, "try" before the "indent" might be a good idea
09:51:27 <yrlnry> Yow.
09:51:31 <monochrom> cannot install ghci using cabal
09:51:37 <notabel> heya quuxman, what's going wrong for you?
09:51:51 <monochrom> ghci for powerpc linux
09:52:02 <quuxman> notabel: trying to get ghci installed, and can't find it through apt for some reason (using a dumb system that's Ubuntu on a PPC)
09:52:08 <monochrom> an antique item. (both the ghci and the powerpc linux)
09:52:17 <yrlnry> @pl \f (x,y,z) -> (f x y z)
09:52:17 <lambdabot> (line 1, column 8):
09:52:17 <lambdabot> unexpected ","
09:52:18 <lambdabot> expecting letter or digit, operator or ")"
09:52:18 <lambdabot> ambiguous use of a non associative operator
09:52:25 <yrlnry> @pl \f (x,y,z) -> f x y z
09:52:25 <quuxman> notabel: I have ghc6 installed, and it seems to be fine
09:52:25 <lambdabot> (line 1, column 8):
09:52:25 <lambdabot> unexpected ","
09:52:25 <lambdabot> expecting letter or digit, operator or ")"
09:52:25 <lambdabot> ambiguous use of a non associative operator
09:52:29 <yrlnry> Grr.
09:52:40 <knobo> geheimdienst: I added "try (indent tabs)" where it previously was just "indent tabs". At it looks like it works.
09:53:56 <knobo> But now. I wonder id there is a way to parse a line until eol ('\n') including the '\n'
09:54:20 <notabel> quuxman: which version of ghc6? i think it was broken on ppc before 6.10
09:54:37 <knobo> many1 (noneOf "\n") does not look optimal.
09:54:43 <quuxman> ah, that's why monochrom mentioned that specific version number?
09:55:01 <knobo> should be something like (until '\n').
09:55:26 <quuxman> notabel: I have 6.10.4
09:55:54 <notabel> okay.  and what do you get from running `ghc --interactive`?
09:56:04 <geheimdienst> knobo, check out endBy, endBy1, or if you want to do more manyTill
09:56:13 <geheimdienst> all documented here: file://localhost/home/hk/.cabal/share/doc/parsec-3.1.0/html/Text-Parsec-Combinator.html
09:56:21 <quuxman> '<command line>: not built for interactive use'
09:57:00 <quuxman> notabel: looks like I'll have to recompile. rrrrrrrhg
09:57:32 <quuxman> notabel: clearly I should download the latest ghc6 package for PPC
09:57:37 <quuxman> notabel: er, binary
09:58:07 <notabel> i don't think there are official binaries for ppc/linux
09:59:04 <knobo> geheimdienst:  but has a separator, that's in the way ( I think )
09:59:11 <quuxman> there's the official Mac OS release I just noticed. I'll use that, because I'm sshing from a newer mac
09:59:18 <quuxman> holy shit, you're at 6.12?
09:59:27 <notabel> kk
09:59:46 <notabel> yeah, ghc7 is the upcoming release (because it has major new code landing)
09:59:48 <quuxman> Damn Haskell moves fast
10:00:18 <quuxman> It's only been a few months since I last did any coding in it :-P
10:00:31 <quuxman> 7 wasn't even on my radar
10:00:32 <ezyang> I can still remember when 6.12 was the "new" thing :-) 
10:00:39 <knobo> manyTill worked
10:00:43 <ezyang> I'm glad GHC is still really agile. 
10:00:45 <knobo> Thanx
10:00:58 <quuxman> ezyang: it's pretty impressive, given the codebase
10:01:04 <zygoloid> ezyang: that really wasn't a very long time ago :)
10:03:39 <quuxman> The logo rules: cube with batteries inside. Makes me think of the lambda cube with lots of handy libraries
10:05:01 <zygoloid> the platform logo? yeah, it's nice. the haskell logo looks a bit too much like the amtrak logo though
10:05:17 <quuxman> > '<' ++ '3'
10:05:17 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
10:05:17 <lambdabot>    arising from a use o...
10:05:35 <quuxman> damn, I'm out of practice
10:06:15 <quuxman> zygoloid: whatever, we need more trains in my country
10:06:18 <Cale> > "<" ++ "3"
10:06:20 <lambdabot>   "<3"
10:06:31 <Cale> > '<' : '3' : []
10:06:32 <lambdabot>   "<3"
10:07:54 <quuxman> zygoloid: what is the aspect ratio of the Amtrak-like logo? :)
10:09:27 <quuxman> zygoloid: seems to narrow to be φ
10:23:29 * hackagebot hgen 1.2.0 - Random generation of modal and hybrid logic formulas  http://hackage.haskell.org/package/hgen-1.2.0 (GuillaumeHoffmann)
10:24:58 <sajkr> @t (++)
10:24:59 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:25:07 <sajkr> @type (++)
10:25:08 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:25:14 <sajkr> whaaaaa?
10:25:43 <geheimdienst> :t (++)
10:25:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:26:02 <c_wraith> sajkr, Lambdabot has a couple names from Prelude shadowed
10:26:03 <Phantom_Hoover> IIRC it's part of the definition of monoids...
10:26:13 <c_wraith> :t (Prelude.++)
10:26:13 <lambdabot> forall a. [a] -> [a] -> [a]
10:26:14 <sajkr> oh, cool.
10:26:23 <geheimdienst> @instances Monoid
10:26:23 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:26:25 <sproingie> Caleskell strikes again
10:26:33 <zygoloid> confused? blame cale. pleased? thank cale. :)
10:26:51 <sajkr> i actually want it that way.
10:26:56 <geheimdienst> > Just 3 ++ Just 4
10:26:56 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:26:57 <lambdabot>    `Data.Monoid.Monoid t'
10:26:57 <lambdabot>  ...
10:27:09 <geheimdienst> (Just 3) ++ (Just 4)
10:27:16 <sproingie> will the compiler specialize cale's generic ++ to the same as the Prelude's ++?
10:27:19 <geheimdienst> > (Just 3) ++ (Just 4)
10:27:20 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:27:20 <lambdabot>    `Data.Monoid.Monoid t'
10:27:20 <lambdabot>  ...
10:27:58 <zygoloid> i heard a rumour that we're getting (<>) as mapped in Data.Monoid in the base shipped with ghc-7, but i don't know if there's any truth to that
10:27:59 <sproingie> tho come to think, the mappend for lists is probably the same code
10:28:28 <geheimdienst> > [3,4] `mappend` [7,8]
10:28:29 <lambdabot>   [3,4,7,8]
10:28:36 <zygoloid> sproingie: if optimization is enabled and it knows statically that it's a list, then yes, i believe so
10:29:06 <geheimdienst> > (3,4) ++ (5,6)
10:29:07 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:29:07 <lambdabot>    `Data.Monoid.Monoid t'
10:29:07 <lambdabot>  ...
10:29:33 <geheimdienst> why is the type variable t ambiguous for everything except for lists ...?
10:30:15 <dolio> > Sum 3 ++ Sum 4
10:30:16 <lambdabot>   Ambiguous occurrence `Sum'
10:30:16 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
10:30:24 <dolio> Bah.
10:30:30 <geheimdienst> > Nothing ++ Nothing
10:30:31 <lambdabot>   Nothing
10:30:39 <geheimdienst> > (Just 3) ++ (Just 4)
10:30:40 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:30:40 <lambdabot>    `Data.Monoid.Monoid t'
10:30:40 <lambdabot>  ...
10:30:51 <geheimdienst> i don't exactly understand this
10:30:57 <geheimdienst> > (Just 3) ++ Nothing
10:30:57 <dolio> There's no Monoid for, say, Integer.
10:30:58 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:30:58 <lambdabot>    `Data.Monoid.Monoid t'
10:30:58 <lambdabot>  ...
10:30:59 <Cale> > Just (Sum 3) ++ Just (Sum 4)
10:31:00 <lambdabot>   Ambiguous occurrence `Sum'
10:31:00 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
10:31:06 <Cale> hmm
10:31:14 <Cale> Now, that's odd
10:31:16 <sproingie> > Sum 3 `mapend` Sum 4
10:31:17 <lambdabot>   Ambiguous occurrence `Sum'
10:31:18 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
10:31:27 <Cale> > Just (Product 3) ++ Just (Product 4)
10:31:28 <lambdabot>   Just (Product {getProduct = 12})
10:31:28 <dolio> And the default Maybe instance for Monoid lifts the underlying Monoid.
10:31:29 <sproingie> doh, fingers
10:31:41 <Cale> There must be another definition of "Sum" somewhere...
10:32:02 <Cale> Ah, Data.AdditiveGroup.Sum, apparently
10:32:06 <mreh> "cabal: Command.optionToFieldDescr: feature not implemented"
10:32:13 <mreh> is this a bug?
10:32:24 <aRcatan> Cale: what's that?
10:32:39 <dolio> geheimdienst: So, when you try to use 3 as something with a type in the class Monoid, there's nothing legal to default to.
10:32:45 <zygoloid> mreh: looks like a missing feature ;)
10:32:58 <Cale> http://hackage.haskell.org/packages/archive/vector-space/0.7.2/doc/html/Data-AdditiveGroup.html
10:33:10 <geheimdienst> dolio: okay ... but suppose i have 2 lists and do (++) or mappend on them. this requires the lists to be Monoids (they are) but it shouldn't require that the things *in* the lists are Monoids, right?
10:33:11 <aRcatan> aha
10:33:27 <dolio> Not for lists, no.
10:33:54 <dolio> But the Maybe instance does.
10:34:01 <mreh> zygoloid: but which one?!
10:34:04 <dolio> If you want the more list-like monoid for Maybe, it's...
10:34:08 <Cale> > Just (Sum 3) ++ Just (Sum 4)
10:34:09 <lambdabot>   Just (Sum {getSum = 7})
10:34:12 <Cale> there we go
10:34:15 <dolio> > First (Just 5) ++ First (Just 6)
10:34:16 <lambdabot>   First {getFirst = Just 5}
10:34:23 <dolio> > Last (Just 5) ++ Last (Just 6)
10:34:24 <lambdabot>   Last {getLast = Just 6}
10:34:28 <geheimdienst> > (Sum 3) ++ ( Sum 4)
10:34:29 <lambdabot>   Sum {getSum = 7}
10:35:03 <Cale> > getSum . mconcat $ [Sum 3, Sum 4, Sum 5]
10:35:04 <lambdabot>   Ambiguous occurrence `getSum'
10:35:05 <lambdabot>  It could refer to either `Data.Monoid.getSum...
10:35:09 <Cale> oh, hehe
10:35:17 <Cale> @undefine
10:35:18 <Cale> > getSum . mconcat $ [Sum 3, Sum 4, Sum 5]
10:35:19 <lambdabot>   12
10:38:36 <moosefish> Any particularly good way of uninstalling libraries installed by cabal?
10:39:25 <dolio> Not really.
10:40:10 <moosefish> Assuming it's a leaf (no library depends on it), deleting .ghc/.../$package-... should do it?
10:40:29 <dolio> You need to make sure you ghc-pkg unregister it.
10:40:36 <dolio> Then you can delete it.
10:40:42 <c_wraith> moosefish, you're probably best off just using ghc-pkg unregister.  it doesn't delete it, but it removes it from any linking ghc will do
10:41:25 <dolio> ghc-pkg unregister will also fail if there is anything that depends on it.
10:42:16 <moosefish> well, this was installed with cabal --user
10:42:21 <dolio> So it'll help if you're manually uninstalling a non-leaf.
10:42:31 <moosefish> so I'm assuming there really ain't much linking for ghc to be done
10:42:35 <moosefish> *ghc-pkg
10:43:11 <monochrom> you still have to ghc-pkg unregister. user or global.
10:43:57 <monochrom> unless you say you rm -rf ~/.ghc. but that's still just a special case of ghc-pkg unregister.
10:44:32 <moosefish> ok, thanks a bunch
11:10:08 <mreh> @paste
11:10:09 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:10:25 <mreh> incorrect
11:11:31 <mreh> http://pastebin.com/gd99DnCi -- what have I done wrong?
11:27:08 <seryl> Is the erlang FFI just abandoned..?
11:28:07 <seryl> nevermind, guess so. that's a bummer
11:31:52 <dstcruz> anyone hiring in the Chicago area?
11:41:07 <Apocalisp> dstcruz: Maybe. Not for Haskell work though.
11:41:36 <dstcruz> Apocalisp: any functional lang would be interesting
11:42:43 <dstcruz> and anyone that lurks the haskell channel would probably be of interest as well
11:45:08 <Heffalump> didn't some hedge fund or similar advertise for people in Chicago recently?
11:45:11 <Heffalump> (Haskell people)
11:46:28 <Apocalisp> dstcruz: How about C#?
11:49:04 <Apocalisp> dstcruz: This group is hiring in Chicago
11:49:04 <Apocalisp> https://www.capitaliq.com/main3/alphaworks.asp
11:49:59 <Apocalisp> dstcruz: I'm fairly sure it's all .Net
11:50:14 <dstcruz> Apocalisp: thanks for the pointer, will check them out.  Been doing C# for > 7 years.  Linq has made things a bit nicer.
11:51:26 <pumpkin> Heffalump: they did, but I just checked on the cufp website and couldn't find the posting anymore
11:51:28 <pumpkin> maybe they filled it?
11:51:59 <knobo> with parsec, the possibilities are endless :)
11:52:36 <knobo> Can one do binary parsing with parsec?
11:52:58 <maurer_> knobo: You likely could, using the ByteString parsers
11:53:15 <maurer_> That doesn't mean you should though.
11:53:39 <maurer_> What are you trying to do? It more likely makes sense to implement an instance of Binary than use Parsec.
11:54:09 <knobo> maurer_: where is the docs for binary?
11:54:53 <maurer_> @hoogle Data.Binary
11:54:54 <lambdabot> No results found
11:54:59 <maurer_> :(
11:55:06 <maurer_> http://haskell.org/hoogle/?hoogle=Data.Binary
11:57:12 <zachk> maurer_, i believe your problem would be modeled by a differntial equation 
11:59:05 <kmc> dstcruz, http://www.reddit.com/r/haskell/comments/d1r8o/allston_trading_is_hiring_haskell_devs_in_chicago/
11:59:52 <kmc> attoparsec might make more sense for binary, depending
12:00:35 <maurer_> If you're feeling lazy, you can just use Read/Show derived instances and compose with gzip
12:00:43 <revenantphx> > let (==) a b = a /= b 
12:00:44 <lambdabot>   not an expression: `let (==) a b = a /= b '
12:00:53 <revenantphx> what? That works in ghci D:
12:01:08 <Cale> Lambdabot is not ghci
12:01:20 <revenantphx> > (==) a b = a /= b
12:01:21 <lambdabot>   <no location info>: parse error on input `='
12:01:26 <revenantphx> > <
12:01:26 <maurer_> kmc: Did you go on a blogging spree recently, or did you just get syndicated by Planet Haskell?
12:01:27 <lambdabot>   <no location info>: parse error on input `<'
12:03:24 <revenantphx> > let a `==` b =  a /= b
12:03:25 <lambdabot>   <no location info>: parse error on input `=='
12:03:39 <revenantphx> won't let me override ==...
12:03:41 <revenantphx> TT_TT
12:03:59 <revenantphx> > let (/=) a b = (a == b)
12:04:00 <lambdabot>   not an expression: `let (/=) a b = (a == b)'
12:04:01 <pumpkin> > let a == b = a /= b in 5 == 6
12:04:02 <lambdabot>   True
12:04:08 <revenantphx> ah, right.
12:04:09 <maurer_> revenantphx: Wouldn't that be counterproductive?
12:04:15 <revenantphx> maurer_: ...maybe
12:04:18 <pumpkin> revenantphx: lambdabot takes expressions
12:04:25 <revenantphx> pumpkin: I see now.
12:05:58 <mreh> cabal has borked
12:06:12 <mreh> it says feature not implemented to everything I give it
12:06:16 <mreh> even empty files
12:06:20 <dstcruz> kmc: thanks! I had seen their post on reddit as well.
12:09:29 <pumpkin> mreh: maybe something in your config is triggering that?
12:09:45 <maurer_> Out of curiosity, does anyone know if there's something similar to lhs2TeX that still has active development?
12:11:14 <kosmikus> maurer_: what's the problem with lhs2TeX?
12:12:37 <maurer_> kosmikus: A few things here and there--it will fail if an _ is in comments, it doesn't layout properly when the "foo $ do bar..." form is used, etc.
12:13:33 <maurer_> Things that might be worth fixing, but as lhs2TeX seemed essentially dead (developmentwise, not usefulness--I still use it) I figured I'd check if there was something else before I looked into fixing it.
12:13:34 <kosmikus> _ in comments is not a bug, and I'm not aware of any problem in layouting the latter
12:13:57 <kosmikus> well, I'm not considering it dead. not much happens because I consider it stable
12:13:57 <maurer_> kosmikus: Why should the comments be typeset as TeX?
12:14:09 <maurer_> kosmikus: They're part of a code block, not the main document.
12:14:20 <kosmikus> because comments are supposed to be text
12:14:37 <pumpkin> there should be double comments!
12:14:44 <pumpkin> things you don't want to appear in code or in tex :)
12:14:54 <kosmikus> maurer_: you can always switch to code within a comment
12:14:54 <maurer_> pumpkin: You can do that.
12:14:58 <pumpkin> oh ok:)
12:15:00 <kosmikus> pumpkin: that isn't a problem
12:15:13 <maurer_> kosmikus: You misunderstand--it's in code mode
12:15:15 <maurer_> i.e.
12:15:20 <maurer_> > -- foo_bar
12:15:21 <lambdabot>   not an expression: `-- foo_bar'
12:15:29 <pumpkin> > 5 -- foo_bar
12:15:30 <lambdabot>   5
12:15:58 <maurer_> The _ shouldn't work in the literate comments, but in comments based on -- or {- I would expect it to work.
12:15:58 <kosmikus> maurer_: yes, so do "> -- |foo_bar|" if you really need that
12:16:29 <maurer_> It's not a matter of being unable to use the current system, it just doesn't seem to match with semantics.
12:16:44 <maurer_> It essentially means that there exists valid Haskell code that cannot be put inside a code block and be formatted correctly.
12:17:05 <kosmikus> yes, true
12:17:19 <kosmikus> lhs2tex doesn't claim it can format any Haskell code without postprocessing
12:17:57 <maurer_> I'm not saying it claims that, but rather that it seems like it would be a desirable semantics.
12:18:17 <maurer_> Sorry for arguing. This isn't going anywhere.
12:18:20 <kosmikus> for comments, it would then have to decide whether they're text or code automatically
12:18:28 <kosmikus> I don't see how to do that
12:18:40 <kosmikus> I think comments as text is the better default
12:18:41 <maurer_> kosmikus: If inside a code block, it's code.
12:18:59 <kosmikus> no
12:20:56 <rendagott> for some reason, ghc won't compile my code that references Text.Regex
12:20:58 <kosmikus> maurer_: well, sorry, I'm not convinced. but if you want to continue discussing, feel free to send me a mail.
12:21:23 <pumpkin> rendagott: passing --make to it?
12:21:44 <rendagott> that fixed it
12:21:49 <rendagott> haha, thanks pumpkin
12:26:41 <pumpkin> preflex: seen glguy
12:26:41 <preflex>  glguy was last seen on #haskell 3 days, 38 minutes and 57 seconds ago, saying: marked objects."
12:26:52 <tomh> is there a term for a data definition without type parameters but uses type parameters inside the constructors?
12:27:09 <pumpkin> existential?
12:27:15 <pumpkin> doesn't really make much sense though
12:27:16 <tomh> existential datatypes?
12:27:26 <pumpkin> can you give an example of one?
12:27:49 <tomh> yeah I have one right here in my college excercises :P
12:28:31 <tomh> it is used for SYB: data Dynamic = forall s.(Data s) => Dyn s TypeRep deriving (Typeable)
12:28:44 <pumpkin> okay, yeah, an existential type
12:28:49 <tomh> ok cool
12:28:59 <pumpkin> bu
12:29:00 <pumpkin> t
12:29:14 <pumpkin> keep in mind that you can have another such type that uses type parameters without being existential
12:29:32 <pumpkin> data Moo = Moo (forall a. (Num a) => a), maybe
12:30:03 <tomh> whats the advantage of not using a type variable?
12:30:11 <pumpkin> they just mean different things
12:30:29 <pumpkin> it depends what you need your type to contain and what you want the type to expose to the outside world
12:30:44 <tomh> ah I see
12:30:51 <pumpkin> Dynamic up there can contain any instance of Data, but doesn't reveal which type it contains
12:31:13 <tomh> I guess that makes it easier to create functions that work on dynamic that way
12:34:13 <dreixel> tomh: by not exposing the type, you can now have, for instance, a heterogeneous list, where the elements can have different types
12:34:42 <tomh> ah yeah
12:34:58 <tomh> do I need any language extensions to enable it?
12:35:15 <dreixel> requiring the existential type to have an instance for Data means that you will still be able to apply the functionality provided by that class to it (and nothing else, since you don't know anything else about that type)
12:36:39 <tomh> ok
12:37:36 <dreixel> tomh: you need -XExistentialQuantification
12:37:55 <tomh> ok thanks, I go try and get it running
12:46:16 <mreh> anyone know sebastiaaaaaanvisssser?
12:46:45 <kosmikus> mreh: I do
12:46:52 <mreh> kosmikus: is he on here?
12:47:12 <kosmikus> no, don't think so
12:47:27 <mreh> his Flux has majorly bitrotted
12:47:41 <mreh> if it's good enough, which I think it probably is, it should be cabalised and put on hackage
12:48:34 <kosmikus> have you tried email?
12:50:05 <mreh> kosmikus: I will
13:06:06 <c_wraith> @hoogle unless
13:06:07 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:07:41 <aBrickOntheWall> I am trying to work through Hutton's book Ch 8. Having trouble, I would appreciate some help
13:07:43 <aBrickOntheWall> type Parser a = String -> [(a, String)]
13:07:44 <aBrickOntheWall> We have defined:
13:07:46 <aBrickOntheWall> item::Parser Char
13:07:47 <aBrickOntheWall> item []=[]
13:07:49 <aBrickOntheWall> item (x:xs) = [(x, xs)]
13:07:51 <aBrickOntheWall>                       
13:07:52 <aBrickOntheWall> (>>=)::Parser a -> (a -> Parser b) -> Parser b
13:07:54 <aBrickOntheWall> p >>= f = \input -> case parse p input of
13:07:55 <aBrickOntheWall>                       [] -> []
13:07:57 <aBrickOntheWall>                       [(v, output)] -> parse (f v) output
13:07:58 <aBrickOntheWall> -- will this work?                      
13:08:00 <aBrickOntheWall> combine = do{ x <- item
13:08:01 <aBrickOntheWall>           ; z <- item
13:08:03 <aBrickOntheWall>           ; y <- item
13:08:04 <aBrickOntheWall>           ; return (x, y)
13:08:06 <aBrickOntheWall>           }
13:08:19 <aBrickOntheWall> apologies for the formatting.
13:10:30 <c_wraith> aBrickOntheWall, please use a pastebin in the future :(
13:12:15 <madsy> aBrickOntheWall: http://gist.github.com/
13:12:34 <Saizan> hpaste.org is the "official"
13:13:40 <aBrickOntheWall> apologies. I will try hpaste.org
13:13:55 <arjanb> @paste
13:13:55 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:14:12 <Saizan> anyhow, the question is if combine would do something useful?
13:14:12 <c_wraith> aBrickOntheWall, I'm not sure the question is well-defined anyway.  I'm confused by implementing (>>=).  Does that mean you're using -XNoImplicitPrelude?
13:14:17 <pokoko222> image processing guys here?
13:14:28 <arjanb> someone needs to update the @paste link i guess
13:14:42 <c_wraith> preflex: seen mmorrow
13:14:43 <preflex>  mmorrow was last seen on #ghc 252 days, 17 hours, 16 minutes and 58 seconds ago, saying: * mmorrow is rtfm'ing
13:14:57 <aristid> that must be a very big manual
13:15:00 <Saizan> c_wraith: i guess Hutton's book might be using do-notation somewhat informally without having talked about typeclases?
13:15:30 <monochrom> @paste
13:15:30 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:15:35 <monochrom> oh hehe
13:15:44 <aBrickOntheWall> so do we need to make an instance of the Monad type class for the do notation to work?
13:16:02 <c_wraith> aBrickOntheWall, you do if you're not using the NoImplicitPrelude extension
13:16:07 <monochrom> yes
13:16:18 <c_wraith> And don't use that extension..  It's confusing. :)
13:16:54 <aBrickOntheWall> I am not using that extension; I am already confused enough :-)
13:17:27 <c_wraith> The minimal implementation of the Monad class is return and (>>=), so it's really pretty easy to implement.
13:17:55 <c_wraith> (Though proving you've done it correctly can be a bit tougher)
13:21:04 <aBrickOntheWall> ok Thanks. The book text did not explictly implement the Monad type class.. nor does it refer to the Monad type class. But it uses the do notation in the text and that did not work. 
13:21:06 <aBrickOntheWall> Will try a minimal implementation.   
13:21:32 <boegel> are there obfuscation tools available for Haskell programs?
13:21:53 <boegel> to hide the functionality of a program, to avoid others looking into the source code?
13:22:05 <arw> yes. its called "compiler"
13:22:21 <Jafet> boegel: monad transformers
13:22:23 <geheimdienst> arw: i was gonna say exactly that, but restrained myself :)
13:22:48 <xcvii> sometimes i get the feeling that haskell is an obfuscation tool in itself
13:22:49 <boegel> Jafet: sounds... complicated :)
13:23:16 <boegel> Jafet: I was just looking for some tool that allows me to do something like "tool myCode.hs > myCodeObfuscated.hs"
13:23:33 <geheimdienst> just rename everything to confusing names. foldr = map, map = concat, (++) = $
13:23:51 <monochrom> use @pl
13:24:07 <arw> for every one of those obfuscators there is a deobfuscator.
13:24:21 <arw> its more a kind of snakeoil.
13:24:26 <monochrom> do your own cps transform
13:25:32 * geheimdienst will release his own obfuscated haskell dialect. map = blorp, foldr = ump, foldl = gank, ...
13:26:06 <boegel> well, I've been wanting to just write my own small tool, and just replace all meaningful stuff with gibberish
13:26:07 <monochrom> but why would anyone care about haskell source code? I would think you would just give out c code if you want to give out obfuscated open source code.
13:26:23 <boegel> i.e. own defined data types with X, Y, Z, ..
13:26:25 <geheimdienst> > (ink donk blork) ++ (flirnk under superman) $ darmok and jalal at tenagra
13:26:25 <lambdabot>   Not in scope: `ink'Not in scope: `donk'Not in scope: `blork'Not in scope: `...
13:26:28 <boegel> but seems like a lot of work
13:27:01 <arw> just compile it. giving out obfuscated source code is as good as giving out no source code.
13:27:09 <boegel> geheimdienst: but you'd need to add the mapping of blorp to map somewhere...
13:27:12 <mee> geheimdienst: Darmok and Jilad at Tanagra!
13:27:14 <monochrom> you forgot to replace ++
13:27:22 <boegel> arw: I need to give out the source code
13:27:30 <monochrom> oh I know, rename all functions to infix operators
13:27:39 <boegel> arw: I'm joining in on the Google AI contest (see ai-contest.com)
13:27:40 <mreh> can't someone fix all my broken openGL code?!
13:27:48 <mreh> who is responsible for this?
13:27:49 <geheimdienst> monochrom, it's called perl
13:27:53 <arw> boegel: they require obfuscation?
13:28:09 <boegel> sending the code to the official server is no problem, but I'd also like to test my bot on a more home-brewn server where I don't know everyone
13:28:10 <monochrom> use ghc to translate to c code
13:28:19 <boegel> and I don't want to just give them my source code
13:28:31 <boegel> monochrom: hmm, I guess I could
13:28:55 <geheimdienst> isn't there a pretty-printer tool for haskell? because i guess if i run that on your source, half the obfuscation would vaporize ...
13:28:59 <monochrom> then again that c code needs some TCO that gcc doesn't do
13:29:22 <Heffalump> what is the basis for the source code requirement?
13:29:39 <arw> compile and then disassemble and hand it in as assembler source?
13:29:49 <boegel> Heffalump: well, they don't allow to send compiled stuff yet
13:29:50 <xcvii> how about writing all your source in ski calculus?
13:30:03 <boegel> Heffalump: it would also be troublesome to ensure a working binary
13:30:07 <boegel> xcvii: :D
13:30:27 <mauke> xcvii: sort of related: http://mauke.ath.cx/stuff/perl/add.pl
13:30:29 <Heffalump> the LLVM backend might be your best bet for producing something portable
13:31:22 <xcvii> wow what a beauty
13:31:28 <monochrom> oh well, the evil mangler is still necessary
13:32:42 <tensorpudding> evil mangler is (necessary) evil
13:33:13 <Jafet> boegel: Just ship it with an assembler.
13:34:20 <monochrom> haskell itself is obfuscated enough
13:34:41 <mauke> use a zygohistomorphic prepromorphism
13:35:27 <arw> hm. you could also try 'shar'. produces a self-unpacking shellskript which you can then instruct to execute itself
13:35:49 <arw> so its only sourcecode with a little included data
13:39:18 <A1kmm> Does anyone know if there is a way (with ghc language extensions) to not name an unwanted functional dependency determined target in an instance head constraint?
13:39:56 <A1kmm> e.g. I have "instance ReactionModelBuilderAccess mtop mreaction => U.UnitsModelBuilderAccess mtop mbottom", I don't need mreaction, and it is determined by a functional dependency mtop -> mreaction
13:41:22 <A1kmm> With the above I get "Variable occurs more often in a constraint than in the instance head" (unless I turn on UndecidableInstances, which ideally I shouldn't have to).
13:42:27 <A1kmm> Ideally I'd like to be able to do "instance ReactionModelBuilderAccess mtop _ => U.UnitsModelBuilderAccess mtop mbottom", but that isn't syntactically valid.
13:42:43 <boegel> Jafet: :D
13:43:57 <Feuerbach> Does GHC's garbage collector block all threads while running?
13:44:14 <Heffalump> yes
13:44:37 * hackagebot data-object 0.3.1.4 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1.4 (MichaelSnoyman)
13:44:39 * hackagebot data-object-json 0.3.1.3 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1.3 (MichaelSnoyman)
13:44:44 <Feuerbach> Heffalump: is it described somewhere?
13:45:42 <Heffalump> I think Simon Marlow wrote a paper about it recentlyish
13:45:56 <Heffalump> though I think he's also redone it again since, actually - see the GHC blog
13:46:20 <bos> there are several papers about the GC
13:46:43 * hackagebot texmath 0.3.0.3 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.3.0.3 (JohnMacFarlane)
13:52:48 <Feuerbach> well, I skimmed over the paper about parallel gc, but it only says that they focus on parallel and not concurrent gc
13:53:15 <Feuerbach> okay, I'll take your word for it :) thanks
13:53:26 <Saizan> i think he's working or has already done a gc which doesn't "stop the world"
13:53:57 <ddarius> There was an incremental GC made a long time ago.
13:59:48 <Heffalump> Saizan: oh yeah. Only for minor collections though.
13:59:56 <Heffalump> I'd forgotten that was what he redid :-)
14:02:11 <zenzike> what's that command you can give to lambdabot, where you give it a type, and it gives back a point-free definition that satisfies the type?
14:02:16 <Zao> @pl
14:02:17 <lambdabot> (line 1, column 1):
14:02:17 <lambdabot> unexpected end of input
14:02:17 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:02:29 <zenzike> @pl (c -> d) -> (a -> b -> c) -> (a -> d)
14:02:29 <lambdabot> (line 1, column 4):
14:02:29 <lambdabot> unexpected ">"
14:02:30 <lambdabot> expecting variable, "(", operator or ")"
14:02:31 <Zao> @pl flip const
14:02:31 <lambdabot> const id
14:02:38 <Saizan> zenzike: sounds like a mix of djinn and pl
14:02:44 <Zao> Oh, give it a type.
14:02:45 <azaq231> @. pl djinn (a -> a)
14:02:46 <lambdabot> f = id
14:02:51 <Saizan> @. pl djinn (c -> d) -> (a -> b -> c) -> (a -> d)
14:02:52 <lambdabot> (line 1, column 1):
14:02:52 <lambdabot> unexpected "-"
14:02:52 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:03:01 <Saizan> @djinn (c -> d) -> (a -> b -> c) -> (a -> d)
14:03:01 <lambdabot> -- f cannot be realized.
14:03:21 <zenzike> @djinn (c -> d) -> (a -> b -> c) -> (a -> b -> d)
14:03:21 <lambdabot> f a b c d = a (b c d)
14:03:32 <zenzike> oh, nothing interesting then :-(
14:04:07 <tensorpudding> @djinn (c -> d) -> (a -> b) -> (b -> c) -> (a -> d)
14:04:07 <lambdabot> f a b c d = a (c (b d))
14:05:02 <Saizan> @. pl djinn (c -> d) -> (a -> b -> c) -> (a -> b -> d)
14:05:02 <lambdabot> f = (.) . (.)
14:05:15 <zenzike> @djinn (c -> d) -> (a -> b -> c) -> (a -> b) -> d
14:05:15 <lambdabot> -- f cannot be realized.
14:18:06 <Cale> http://www.cs.cmu.edu/~guyb/ SPJ might work *on* GHC, but it appears that Guy Blelloch works *in* GHC
14:18:19 <Cale> (Office: GHC 9211)
14:19:11 <geheimdienst> grace hopper construct
14:19:14 <byorgey> Cale: hehe
14:19:45 <geheimdienst> glorious hall of computers
14:20:57 <geheimdienst> gibberish-holding-forth clowns
14:21:19 * geheimdienst wants a job as a campus building namer
14:25:29 <Twey> Cale: Haha, cool.
14:25:41 <Twey> We need to get SPJ that office.
14:27:08 <geheimdienst> how about getting spj an office on the roof of the GHC building
14:27:22 <geheimdienst> then he can work on GHC while working on GHC
14:28:25 <jdpage> monochrom, you still here?
14:28:27 <maurer_> The GHC building is actually really nice too.
14:28:31 <jdpage> monochrom, I found a solution.
14:28:38 <geheimdienst> maurer_: what does it stand for?
14:28:38 <maurer_> I work in a nearby building, and sometimes hang out in GHC
14:28:46 <maurer_> Gates Hillman Center/Complex
14:29:01 <geheimdienst> oh i see :)
14:29:10 <jdpage> monochrom, i.e. the -O flag. -.-
14:29:48 <kmc> maurer_, both (blog spree and syndication)
14:36:07 <ddarius> > 700 + 900 + 40 + 130
14:36:08 <lambdabot>   1770
14:43:16 <tommd> Is there a reason not to have monadic version of the function in containers?
14:44:04 <tommd> I've a need for functions of the sort:
14:44:04 <tommd> adjustM :: (Monad m, Ord k) => (a -> m a) -> k -> Map k a -> m (Map k a)
14:44:05 <tommd> updateWithKeyM :: (Monad m, Ord k) => (k -> a -> m (Maybe a)) -> k -> Map k a -> m (Map k a)
14:44:31 <tommd> They aren't hard to write, but must be in the containers package due to opacity of Map/Set/etc.
14:46:46 <mm_freak> tommd: or in your own separate modules, which you can import qualified as well
14:46:55 <mgsloan> Hello, anyone here know much about the paper "Clone Detection and Elimination for Haskell" by Christopher Brown and Simon Thompson?
14:46:55 <mm_freak> import qualified SetUtils as SU
14:47:04 <mgsloan> Are they in here by chance? :D
14:51:01 <mreh> @hoogle Float -> GLfloat
14:51:01 <lambdabot> Warning: Unknown type GLfloat
14:51:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:51:02 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:51:44 <mauke> :t realToFrac
14:51:45 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
14:52:22 <mreh> I read that realToFrac is woefully slow
14:52:41 <mreh> I wish to know who broke all the OpenGL code!!
14:53:30 <tommd> mm_freak: No, that's what I'm saying.  You can't have 'adjustM' in your own module because the structure of 'Map' is hidden.
14:56:34 <kmc> preflex, seen edwardk
14:56:34 <preflex>  edwardk was last seen on #haskell 3 days, 20 hours, 8 minutes and 26 seconds ago, saying: * edwardk waves hello.
14:56:45 <kmc> hi copumpkin
14:56:48 <copumpkin> hey hey
14:57:07 <mm_freak> tommd: look at what classes Map is an instance of
14:57:10 <copumpkin> how you doing?
14:57:14 <kmc> good good
14:57:21 <kmc> gotta think of more stuff to blog about
14:57:24 <geheimdienst> good cogood?
14:57:24 <mm_freak> you'll particularly like Traversable and Foldable
14:57:40 <kmc> copumpkin, you mentioned a quasiquoter for assembly, i wonder if harpy has that
14:57:43 <copumpkin> traversable will give it to you in a roundabout way
14:58:02 <kmc> i also remember seeing some awesome looking dependently typed embedding of asm in Haskell
14:58:04 <copumpkin> kmc: that'd be cool, but I must say I wasn't a huge fan of harpy when I last took a look
14:58:05 <kmc> but i can't find it on Hackage
14:58:15 <copumpkin> dependently typed embedding in haskell? :o
14:58:15 <kmc> ok
14:58:23 <kmc> yeah i may be misremembering the details
14:58:28 <ddarius> kmc: Other than to nicefy the syntax a bit, it doesn't really make sense for Harpy to have a quasiquoter.
14:58:43 <kmc> but if you use a quasiquoter then it's not really embedded and you can do whatever you want
14:58:49 <tommd> mm_freak: You're implying one of those classes does what I want.  I don't see such functionality so you'll have to stop beating around the bush and hit me over the head with it ;-).
14:59:12 <copumpkin> what's a good library for network socket programming?
14:59:16 <mm_freak> tommd: then gimme an example =)
14:59:17 <copumpkin> with bytestrings, ideally
14:59:36 <mm_freak> copumpkin: Network
14:59:47 <kmc> anyone here use liskell?
14:59:47 <kmc> it seems pretty dead
14:59:49 <copumpkin> okay
14:59:52 <mm_freak> gives you Handles, so you can just use Data.ByteString.hGetWhatever
14:59:56 <kmc> it's a patch to ghc 6.6, and the blog is a 404
14:59:57 <ddarius> @hackage network-bytestring
14:59:57 <lambdabot> http://hackage.haskell.org/package/network-bytestring
15:00:53 <copumpkin> thanks :)
15:01:33 <tommd> mm_freak: adjustM (\nd -> if isHealthy nd then addEvent (PingNode nd) >>= \i -> return nd { event = i } else ...) node mapping
15:02:11 <tommd> So I want to lookup the value, based on that value decide to perform a monadic action and based on the result of that action update the value in the mapping.
15:02:29 <tommd> I can do this with separate lookup / update calls, but that's twice as costly.
15:02:36 <gwern> kmc: hey, at least the whole liskell site is not 404 now
15:02:40 <gwern> that may be thanks to me
15:02:43 <kmc> cool
15:02:48 <copumpkin> anyone know of an RTSP lib in hackage?
15:03:07 <copumpkin> doesn't look like anything obvious
15:03:44 <mm_freak> tommd: later, when i've got some more time, i can take a look
15:03:46 <kmc> what i want is a way to do Haskell *meta*programming as sexpr quote/unquote, without affecting the way i do other programming and certainly without patching ghc
15:05:36 <maurer_> kmc: You could probably write something to do that by using Language.Haskell.Syntax and http://hackage.haskell.org/package/plugins-1.4.1, but it'd be kinda slow
15:05:43 <maurer_> To do it faster you might want to examine ghci
15:06:01 <kmc> yeah, i'm thinking now about how to implement it
15:06:17 <Saizan> you'd just need a bijection from sexps to the TH AST, no?
15:06:24 <kmc> right
15:06:28 <kmc> or to haskell-src-exts
15:06:39 <maurer_> The real show stopper I'm seeing is that even if you make it work right, modifying the AST would be not as intuitive as in Lisp or or other languages where this is done.
15:06:45 <kmc> if there's some advantage there
15:06:53 <kmc> i think it could be close
15:07:04 <linolium> hi there, if I have a question for help about haskell is this the rigth place to ask or is there another channel?
15:07:20 <kmc> this is the right place :)
15:07:20 <maurer_> I suppose if you limit yourself to the pure section you could get a reasonable interface.
15:07:34 <maurer_> err, pure, non-monadic, non-keyworded, etc.
15:07:46 <kmc> keywords are fine, they correspond to lisp special forms
15:08:13 <maurer_> let?
15:08:30 <linolium> haha, okay. I'm trying to write a harmonic function with the type Int -> Float, and this is what I have so far... harmonic n = 1/n + (harmonic (n - 1)) but I am getting type errors and I am not sure where the problem lies
15:08:35 <maurer_> Sure, these can be done as special forms, but it'd look awkward.
15:08:36 <kmc> (let ((fibs (: 1 (: 1 (zipWith + fibs (tail fibs)))))) fibs)
15:08:43 <kmc> maurer_, that's how it's done in lisp and scheme
15:08:46 <kmc> and yes it is awkward
15:08:48 <maurer_> kmc: I would classify that as awkward.
15:09:13 <maurer_> Curiosity: What do you want to use the metaprogramming for?
15:09:19 <kmc> linolium, probably you need to convert n to a Float
15:09:21 <kmc> try fromIntegral
15:09:26 <daviddarais> linolium: lookup the type of /
15:09:37 <geheimdienst> how about some way where (for metaprogramming) you could write it will all the parens, but usually don't need to?
15:09:37 <mreh> preflex: seen sfvisser
15:09:37 <preflex>  sfvisser was last seen on #haskell 56 days, 8 hours, 21 minutes and 10 seconds ago, saying: EvanR-work: harmful but useful
15:09:52 <geheimdienst> bah i think that doesn't make much sense ...
15:10:02 <kmc> maurer_, various things.  every time I try to write TH it's incredibly difficult, i want to experiment with the idea that by regularizing the object-language syntax, we make metaprogramming easier
15:10:05 <linolium> daviddarais: Fractional a => a -> a -> a
15:10:15 <kmc> my most recent TH project was http://hackage.haskell.org/package/rowrecord
15:10:25 * hackagebot Agda 2.2.8 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.2.8 (NilsAndersDanielsson)
15:10:26 <daviddarais> linolium: and what type is n?
15:10:35 <kmc> part of the problem is that TH in GHC is simply incomplete
15:10:38 <maurer_> kmc: I just got an idea, onesec while I try it...
15:10:58 <linolium> daviddarais: presumably an Int
15:11:04 <kmc> maybe i'm still missing a trick, but the lack of pattern splices forces me to twist control flow around strangely
15:11:12 <linolium> daviddarais: but 1 is also an Int, is it not?
15:11:27 * hackagebot Agda-executable 2.2.8 - Command-line program for type-checking and compiling Agda programs  http://hackage.haskell.org/package/Agda-executable-2.2.8 (NilsAndersDanielsson)
15:11:52 <copumpkin> oh nice
15:11:52 <daviddarais> linolium: yes 1 is an Int, but the point is that Int is not Fractional
15:12:00 <copumpkin> they released agda 2.2.8
15:12:01 <maurer_> kmc: Haven't tested, but what if you just used nested HLists, with an evaluator that simply applied the first element in the HList to every sequential element?
15:12:21 <kmc> used this for what?
15:12:31 <linolium> daviddarais: ahh..
15:12:36 <maurer_> kmc: i.e. have the sexp be an HList
15:12:49 <daviddarais> linolium: kmc gave you what you are looking for.  the function fromIntegral will convert integral values to other numeric types
15:13:55 <ddarius> > 0x7c00
15:13:56 <lambdabot>   31744
15:14:30 <linolium> daviddarais: kmc: thanks, that worked 
15:14:42 <maurer_> e.g. use Typeable on the second element, gives you type t, then use hOccurs to pull out the first element as t->a, etc.
15:15:02 <tommd> I just read that as "ddarius is greater than 0x7c00".  I think I've been looking at symbol tables too long.
15:15:25 <kmc> i should hope he is
15:15:33 <kmc> symbol tables for what?
15:15:38 <tommd> It depends how you measure ddarius
15:16:06 <tommd> kmc: I'm working on some link-time customizations of programs.
15:16:26 <tommd> So all the objdump stuff I've been staring at is just toy programs right now.
15:16:39 <tommd> No kernels lately :-(
15:17:51 * kmc thinks it woul be cool if microkernels were called "separable kernels"
15:18:36 <kmc> anyone know how edwardk's SMT bindings are coming?
15:19:31 <kmc> anyone know a module that puts (&&), (>=), etc. in a type class for the benefit of EDSLs?
15:20:46 <copumpkin> I thought conal had something like that at somep oint
15:21:16 <conal> @hackage Boolean
15:21:17 <lambdabot> http://hackage.haskell.org/package/Boolean
15:21:32 <conal> kmc: see if that package works for you
15:21:33 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
15:22:58 <kmc> thanks!
15:23:05 <ddarius> Why should microkernels be called separable kernels?
15:23:15 <kmc> ddarius, a lame pun
15:30:18 <Taslem> Is it possible for a function to return any type?  I'm fairly new to Haskell, and running into this issue.
15:31:23 <moshe> Taslem: no, not really, but it is possible to use Data.Dynamic
15:31:24 <hpc> Taslem: do you want it to return the type itself, or do you want it to be able to return a value of any type?
15:31:30 <medfly> :t read
15:31:31 <lambdabot> forall a. (Read a) => String -> a
15:31:32 <mm_freak> Taslem: depends on what you mean by that
15:31:39 <mm_freak> there is an 'any type', which is 'a'
15:31:57 <mm_freak> if you're asking whether you can write anything you want after (->), then yes
15:32:00 <medfly> > read "5" :: Float
15:32:01 <lambdabot>   5.0
15:32:05 <medfly> > read "5" :: Int
15:32:06 <lambdabot>   5
15:32:07 <medfly> :<
15:32:10 <Taslem> Essentially, I have deeply nested tuples, and I don't know what any of the tuples are, except that their second is a tuple in all but the last, and the first is arbitrary.
15:32:26 <mauke> Taslem: you can't do that directly
15:32:40 <Taslem> Type of:   (a,(b,(c,(d,e))))
15:32:43 <ddarius> Crazy lisp programmers.
15:32:45 <hpc> tuples have a type that varies with length
15:32:54 <Taslem> That's the issue I've been having.
15:32:55 <medfly> I think you are doing something wrong :-p
15:33:00 <maurer_> kmc: I was thinking something like http://hpaste.org/40172/sexp, but I'm almost certainly missing something (code does not run, haven't wrangled with HList enough.
15:33:09 <medfly> less tuples, more lists
15:33:15 <hpc> if all your tuple elements are the same type, use a list; if they aren't, refactor
15:33:18 <Taslem> Right, but it needs to be mixed-type.
15:33:27 <medfly> why does it need to be mixed type?
15:33:53 <Taslem> Because I don't know what type the user will specify.
15:34:01 <mm_freak> :t In (Just 3, In (Just 4, In Nothing))
15:34:02 <lambdabot>     Couldn't match expected type `Maybe (Mu Maybe)'
15:34:02 <lambdabot>            against inferred type `(Maybe t, Mu Maybe)'
15:34:02 <lambdabot>     In the first argument of `In', namely `(Just 4, In Nothing)'
15:34:11 <Taslem> And it must be open enough to allow them to create new typews and use them, without having to make new lists.
15:34:16 <mm_freak> hmm
15:34:40 <maurer_> Talsem: What kind of thing is involving the user specifying the type?
15:34:58 <Taslem> Essentially, it generates other code, a bit like a parser, but a bit more convoluted.
15:35:44 <copumpkin> Taslem: sounds like you want Dynamic
15:36:02 <copumpkin> is there a fundamental reason you want your user's types to be reflected in your types?
15:36:26 <maurer_> Talsem: I'm not sure I follow. I've written a compiler in Haskell, but have never needed a list of the sort you're using. Why would their type system not just be represented as more data to you?
15:36:30 <Taslem> How does Dynamic work?
15:36:43 <hpc> @hoogle dynamic
15:36:43 <lambdabot> module Data.Dynamic
15:36:44 <lambdabot> Data.Dynamic data Dynamic
15:36:44 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
15:37:33 <Taslem> So, you could create a list of type [Dynamic]  ?
15:37:51 <copumpkin> yeah
15:38:17 <ddarius> Dynamic is hideous.
15:38:19 <moshe> Taslem: I use dynamic typed languages a lot, however I never really needed Data.Dynamic, but you could use it like that
15:38:27 <copumpkin> it is hideous
15:38:36 <moshe> and I think copumpkin is right about that
15:38:49 <copumpkin> (ddarius, really)
15:38:50 <maurer_> Talsem: Why not just represent the user types as data?
15:38:55 <Taslem> I know that it is hideous, I'm only doing this to cionvince my brother Functional Languages are nice.  
15:38:58 <copumpkin> Taslem: an alternative is to use a GADT to represent your language syntax
15:39:12 <copumpkin> and have (one of) its indices preserve types
15:39:22 <hpc> Taslem: Dynamic is the least convincing thing you could possibly use to accomplish that goal
15:39:24 <mm_freak> data DeepTuple = forall a. DT (a, Maybe DeepTuple)
15:39:26 <mm_freak> does that make sense?
15:39:34 <mm_freak> i guess you can't do much with such a thing
15:39:55 <Taslem> No, he has no rpoblem with Haskell, he hates functional languages.  I'm working on a syntax-preserving setup to change imperative syntax into functional syntax.
15:40:18 <hpc> are monads not good enough?
15:40:20 * ddarius is nonplussed.
15:40:36 <Taslem> I do not know Monads.
15:40:38 <copumpkin> mm_freak: an existential with no information is basically a unit type
15:40:45 <ffffffffffffffff> i want to take the command line arguement to my program and strip it of its suffix. but i can't do this because getArgs returns IO [String], and so I can't use takeWhile, etc. on it. what to do?? :[
15:40:59 <Taslem> Oh, have to go dinner.  I may be back.  Seeya!
15:41:01 <Philippa> Taslem: just use let blocks like they're C blocks
15:41:02 <mauke> ffffffffffffffff: learn how to use IO
15:41:11 <Philippa> only for bonus points, they're recursive!
15:41:18 <mm_freak> copumpkin: a unit type?  not a void type?
15:41:26 <mm_freak> (disregarding bottom)
15:41:27 <ddarius> Philippa: int x = x;  Perfectly okay.
15:41:41 <copumpkin> forall a. a ~~ void; exists a. a ~~ unit
15:41:47 <ddarius> (As I found out once when I was generating C.)
15:42:08 <Philippa> yeah, mutual recursion less so though
15:42:09 <ffffffffffffffff> mauke: ah, okay
15:42:15 <mm_freak> copumpkin: i never understood 'exists'
15:42:19 <mm_freak> and how to represent it in haskell
15:42:23 <copumpkin> the syntax we never had
15:42:30 <copumpkin> data Moo = forall a. Moo a
15:42:39 <copumpkin> that's "exists" backwards
15:42:52 <copumpkin> it's saying that the _constructor_ is valid for all types in a
15:42:57 <geheimdienst> > reverse "exists"
15:42:58 <lambdabot>   "stsixe"
15:42:59 <hpc> 'exists a' vaguely means "put forall a on the other side of the equals
15:43:04 <hpc> "
15:43:38 <A1kmm> ffffffffffffffff: You need to run getArgs in the IO monad - but BTW you might find filepath useful (http://hackage.haskell.org/package/filepath-1.1.0.4)
15:43:54 <aristid> > transpose . inits $ "exists"
15:43:55 <lambdabot>   ["eeeeee","xxxxx","iiii","sss","tt","s"]
15:44:11 <mm_freak> i'm not sure i understand that…  is there a good introduction?
15:44:16 <A1kmm> ffffffffffffffff: It has methods dropExtension, takeExtension, replaceExtension
15:44:25 <A1kmm> functions rather
15:44:30 <hpc> it would be neat to have constant values like command line arguments taken out of IO
15:44:38 <ffffffffffffffff> A1kmm: ah, cool thanks!
15:44:42 <hpc> since they always exist as a single unchanging value
15:44:52 <mauke> :t withArgs
15:44:53 <lambdabot> Not in scope: `withArgs'
15:44:58 <c_wraith> hpc: any of the top-level IO proposals would make that easy.
15:45:02 <mauke> what was it? setArgs?
15:45:04 <mm_freak> hpc: i'm not sure that would be appropriate…  they are part of the world state after all
15:45:06 <megajosh2> @hoogle transpose
15:45:07 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
15:45:07 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
15:45:07 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
15:45:12 <megajosh2> Eh?
15:45:16 <mm_freak> and 'main' is not a function…  it's a state transformer
15:45:30 <megajosh2> > transpose [1..5]
15:45:30 <mauke> ffffffffffffffff: main = getArgs >>= realMain
15:45:31 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
15:45:31 <lambdabot>    arising from a use...
15:45:32 <ffffffffffffffff> seems like i can do something this simple without using yet another lib though...
15:45:37 <mauke> ffffffffffffffff: realMain args = ... :-)
15:45:49 <megajosh2> > transpose ["a", "b", "c", "d", "e"]
15:45:50 <lambdabot>   ["abcde"]
15:45:56 <ffffffffffffffff> hmm then realMain will have type IO?
15:46:04 <mauke> realMain :: [String] -> IO ()
15:46:09 <megajosh2> > transpose "abcde"
15:46:09 <lambdabot>   Couldn't match expected type `[a]'
15:46:09 <lambdabot>         against inferred type `GHC.Types...
15:46:13 <megajosh2> ohlol
15:46:15 <mm_freak> hpc: and i don't think it's that bad to write 'getArgs >>=' before your actual program =)
15:46:31 <ddarius> main should definitely take an argument which would be a capability to any OS/hardware resources.
15:46:34 <ffffffffffffffff> ah okay
15:46:38 * geheimdienst proposes an IO for the stuff that's referentially transparent during the program's lifetime and another IO for the stuff that's really referentially transparent (across program runs)
15:46:42 <megajosh2> @src IO
15:46:42 <lambdabot> Source not found. Where did you learn to type?
15:46:47 <geheimdienst> they will be called IO and IORLY
15:47:00 <megajosh2> IORLY? IYARLY
15:47:03 <ffffffffffffffff> haha
15:47:31 <moshe> I am trying to get a bit more information on the (->) type, can someone point me to some information?
15:47:48 <c_wraith> moshe: what kind of information?
15:47:52 <moshe> for example, I can't understand the type of: join (,)
15:47:52 <mm_freak> i think the idea behind 'main' without arguments is that functions are a concept of the haskell world
15:47:56 <moshe> :t join (,)
15:47:57 <lambdabot> forall a. a -> (a, a)
15:48:03 <mm_freak> the 'real' world is state transformation
15:48:15 <mm_freak> and IO is the window between these two worlds
15:48:26 <moshe> hrm, lambdabot gives something else than my ghci
15:48:32 <mauke> moshe: A -> B is the type of functions that take A and return B
15:48:39 <aristid> moshe: a -> (a, a) means that it is a function that takes an parameter of any type "a" and returns a tuple of type (a, a)
15:48:46 <copumpkin> moshe: it's because you don't have the function instance for (a ->) loaded
15:48:59 <mauke> s/function instance/monad instance/
15:49:00 <megajosh2> @src mapM
15:49:00 <lambdabot> mapM f as = sequence (map f as)
15:49:01 <moshe> copumpkin: how should I load that?
15:49:06 <ffffffffffffffff> thanks for your help
15:49:12 <aristid> :m +Control.Monad.Instances
15:49:12 <copumpkin> :m + Control.Monad.Instances
15:49:13 <mauke> moshe: import Control.Monad.Instances
15:49:22 <hpc> damn you guys type fast
15:49:23 <mauke> people still use :m +? :-)
15:49:29 <aristid> my method uses the least number of keystrokes
15:49:48 <hpc> i think the draw of :m is that you can do :m -
15:49:55 <aristid> mauke: what's the advantage to using import?
15:50:22 <copumpkin> import qualified 
15:50:26 <mauke> no separate command to remember
15:50:35 <moshe> ok, right, I'll look a bit more into Control.Monad.Instances...
15:50:35 <aristid> copumpkin: ghci 6.12 doesn't support that yet afaik
15:50:37 <copumpkin> yeah
15:50:40 <mm_freak> :m Con<TAB>Mon<TAB>.Ins<TAB>
15:50:41 <moshe> what I got:
15:50:43 <geheimdienst> wait, ghci's import has the full syntax?
15:50:43 <mm_freak> mine uses fewer =P
15:50:55 <mauke> geheimdienst: no
15:51:02 <moshe> join (,) :: (Monad ((->) a)) => a -> (a, a)
15:51:20 <moshe> why is that, if I don't load .Instances? :-)
15:51:25 <mm_freak> oh
15:51:32 <mm_freak> i didn't notice GHCi supports 'import'
15:51:33 <copumpkin> it's saying "if I did have such an innstance"
15:51:35 <mm_freak> now that's very useful
15:51:40 <copumpkin> "then I would give you this type"
15:51:55 <copumpkin> "...but I don't have such an instance, so please go find me one"
15:52:14 <mauke> moshe: A -> B is equivalent to (->) A B
15:52:40 <mauke> which is (((->) A) B)
15:53:12 <moshe> mauke: I knew that..., but now that type becomes clear, thanks
15:54:03 <djahandarie> Yeah GHCi has the full import syntax implemented for GHC 7
15:56:07 <Freeaqingme> hoi moshe!
15:56:45 <aristid> djahandarie: also with unloading?
15:58:37 <djahandarie> aristid, that is probably done the same old way
16:02:46 * hackagebot xilinx-lava 5.0.0.5 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.5 (SatnamSingh)
16:03:11 <tommd> Satnam!  What are you doing!
16:03:17 <tommd> How does this relate to Kansas Lava!
16:03:19 <tommd> GRRR
16:06:01 <ddarius> Wie geht's, shapr?
18:09:33 --- topic: '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
18:09:33 --- topic: set by copumpkin on [Thu Aug 12 05:05:07 2010]
18:09:33 --- names: list (clog helgikrs ymasory snarkyboojum QinGW danharaj_ Boney Katovatzschyn dolio tommd conal ezyang revenantphx jsgf siracusa flazz saurik Draconx|Laptop phenom_ bastl1 sonnym RichardG_[away] wenren baldo Jantaro jrib cfricke dancor theorbtwo tarwatirno Philippa siplux Biggles dankna execve winxordie Rotaerk vili museun PatrickRobotham enmand[] kdvh _gaffer Colours Tezeract Twey septic Zao tessier inr quicksilver norm2782 canvon faj_ CompanionCube The_third_man Ke)
18:09:33 --- names: list (cjay freedrull infoe ath reinroux_ aleator geekounet OnionKnight opqdonut flux Belgarion0 Freeaqingme arnihermann Baughn_ lexion ehamberg_ Eelis Cobra MadX` tmuki niko sophacle1 scott_ moosefish timemage nkpart smorg cads m3ga osaunders sohum Dashkal CoryD seafood rbarraud ISF_ec09 wagle linolium ClaudiusMaximus copumpkin rdeshpande _nickel p_l|backup mwc ologNation mforner_ mauke mee FunctorSalad megajosh2 krainboltgreene Mathnerd314 Olathe jayne bgs100 A1kmm)
18:09:33 --- names: list (muep MrFahrenheit aBrickOntheWall xcvii Eridius programble ragloublog amiri Ziphilt Jafet cheater99 s76 PeakerWork alios_ Vorpal brntbeer grahamalot tapwater kolmodin olsner ikonia dstcruz seryl Itkovian jao Deewiant dsouza evza ksf RyanT5000 Adamant ddarius quuxman arjanb dleslie quadro` roconnor c_wraith Gracenotes iFire knobo Modius srh Amadiro fredcy yrlnry SyntaxNinja gal_bolle Nshag Ornedan erk Sup3rkiddo sidek genneth hgolden pumpkin mightybyte nimred)
18:09:33 --- names: list (araujo Yvemath fxr medfly tafryn _unK Runar lopex pozic peterhil pielgrzym delYsid zc00gii Ytinasni jix madsy ankit9 sShintah monochrom lsthemes zyx insomniaSalt hackagebot clanehin cognominal earthy kmc aristid burp scm xinming_ Axman6 ps-auxw maurer_ rothwell hamishmack ernst_ mm_freak lantti rizzix JaffaCake tavelram otto_s_ Razz pantski ari Zeiris anders_ wto zearen Igloo HalfWayMan dom96 regalia Bleadof jedai lispy|dagit jnj zax srcerer jmcarthur zachk)
18:09:33 --- names: list (snorble palmje blalb drhodes ccasin dual Tomas MoALTz sebbe1991 lostman otulp dobblego Muad_Dibber glith derekwright Apocalisp dMazz mikeg nchaimov jystic Philonous bezik iizukaway n00p alexsuraci Fullma tridactyla levitation[A] qz eno tensorpudding cozmic mapreduce benmachine Fingerzam PepeSilvia DrSyzygy dino- dqd Veinor drakko shutdown_-h_now mercury^ lusory eyck KitB byorgey panopticon waterlaz Cale epokal kniu arkx endeavormac Ferdirand pastorn Liskni_si)
18:09:33 --- names: list (LionMadeOfLions joeytwiddle perlite npouillard preflex ace2001ac kyagrd jre2 jonafan avenge boyscared jbauman ville bbee tomaw CoryDambach hzh SimonRC stepnem drbean alip dcoutts_ kermit Maxdamantus BONUS kadoban__ rdrake malthe Entroacceptor tamiko inimino CosmicRay atude yahooooo ricky aasmith__ Paradox924X snr Raynes tg_ saccade dibblego flori jcapper ibt leoncamel thetallguy MrDomino gbeshers sshc StoneToad Khisanth elliottcable Valodim shachaf jml Martty)
18:09:33 --- names: list (Gilly hellige endojelly taruti emma wang sfvisser McManiaC robinsmidsrod dho andersk EvanR-work m4thrick And[y] alec hyko pikhq cyanoacry Sunhay ortmage ziman Saizan easy4 noj klugez jmv alexbobP dons bremner` Counter-Strike qebab frerich slabanja firegolfer dobie_gillis baaba EvanR mq birkenfeld cYmen guybrush profmakx deavid ajhager dreixel dmwit mrd xplat duairc d-snp nniro huntse tehgeek Jonno_FTW bss03-AFK Mitar joni6128 Raku^ Nereid Samy EvanCarroll)
18:09:33 --- names: list (koala_man KaneTW teukka koninkje_away mundkur AnAdorableNick int-e majoh ezrakilty ksandstr dumael Sisu cizra aavogt eevar netcat p_l lucca hiredman PsiOmega gereedy copumpki- ben0x539 Hunner enigmus mafs lambdabot angstrom aempirei ibid davidL djahandarie trez Cthulhon go|dfish `0660 suiside skaar mattam ahihi bnonym ixzkn dropdrive duckinator pkrumins newsham gdsx_ Lemmih zakwilson DustyDingo alexsdutton wjt regulate da-x kaol mornfall Gabbie bqf iratsu)
18:09:33 --- names: list (untwisted ray slaye shawn dfeuer steve_himself Jaak MasseR Blub\0 Innominate osfameron _2x2l shortcircuit twn sbok svk_ andrewsw epmf FauxFaux obraun nominolo harlekin tab Jiten thorkilnaur companion_square QtPlatypus bremner ve chitragupt aiko_ Nanar tromp dixie b52 ToRA kosmikus mrshoe_ cncl_ magicman creichen jvogel nornagon makmanalp quaestor_ ido Bassetts johs bd_ marienz ivan joed Guest77645 absentia noddy edwinb Aisling jpatota dcolish mietek)
18:09:33 --- names: list (nothingmuch MacCoaster sajkr guerrilla emias samulihs Reisen electrogeek thoughtpolice mindwarp integral greap rokoteko benc__ saccade_ ahf Jon edwtjo Heffalump _br_ tilman Zolomon willb Guest8345 micro impl eregon pchiusano jamwt stenobot2010 davean orbitz mvid idoru encryptio dilinger arw dionoea mux BrianHV defn adimit saiam erg Vq SubStack hvr dax_ Arnar solidsnack TML gds Obfuscate kar-1 nlogax cuba pettter Starfire Botje Rooz jd10 Laney jlouis ptrf hc_e)
18:09:33 --- names: list (scree_ milli Stephan202 chromakode franksh_ soeren @ChanServ cynick idnar Vulpyne sproingie deadguys zygoloid kalven jdsc allbery_b jrockway)
18:16:14 <pumpkin> so about that browser thing
18:16:32 <pumpkin> any way to make a request, look at it, and based on it, make another request?
18:16:40 <pumpkin> (within the same session, saving cookies and the like)
18:17:19 <pumpkin> s/look at it/look at the response/
18:18:01 <Gracenotes> yay! LR(0) parser works!
18:19:21 <Gracenotes> hm.... failing that you can make a BrowserAction and >> multiple requests upon it
18:19:50 <Gracenotes> I guess it's possible to (uri, req) <- request [...] too
18:20:51 <tommd> @tell mm_freak if you're still interested, I'm pursuing YALP (yet another library proposal) of Data.{Map,Set,etc} to include adjustM, updateWithKeyM, etc.  It might turn into an Applicative constraint instead of Monad.
18:20:51 <lambdabot> Consider it noted.
18:21:04 <Gracenotes> actually, I don't know of that many applications which dynamically extend and explicitly branch monadic actions, but it's done implicitly all the time, so.. eh
18:21:04 <pumpkin> oh good point
18:30:02 <kmc> hmm what would i use for (a -> b -> M c) -> M a -> M b -> M c
18:30:17 <kmc> :t \f x y -> sequence $ liftM2 f x y
18:30:18 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> [a1] -> [a2] -> m [a]
18:30:21 <kmc> :t \f x y -> join $ liftM2 f x y
18:30:22 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
18:30:32 <kmc> so this is monadic, not applicative?
18:30:56 <kmc> guess so, it "feels like" a fixed pipeline to me, but actually you can't turn «a → M b» into «M (a → b)»
18:31:01 <kmc> it's more powerful to have the arg *outside*
18:33:24 <aristid> :t ((.).(.).(.)) join liftM2
18:33:25 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
18:34:44 <kmc> o.O
18:35:33 <kmc> there's not a family of "lifting" functions with the right types?
18:40:32 <copumpkin> I'd write that one out by hand, myself
18:41:00 <kmc> okay
18:41:24 <kmc> what about:  [Ptr a] -> (Ptr (Ptr a) -> IO b) -> IO b
18:41:35 <kmc> @hoogle [Ptr a] -> (Ptr (Ptr a) -> IO b) -> IO b
18:41:35 <lambdabot> No results found
18:41:42 <kmc> for marshalling lists of pointers as arrays
18:42:01 <sshc> Why wasn't fmap for Set defined to be mapMonotonic?
18:42:11 <copumpkin> sshc: because that would be a lie
18:42:21 <kmc> @hoogle (Storable a) => [a] -> (Int -> Ptr a -> IO b) -> IO b
18:42:22 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
18:42:22 <lambdabot> Foreign.Marshal.Array withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b
18:42:24 <kmc> yay
18:42:31 <copumpkin> kmc: Cale had a nice version of that involving Cont
18:42:46 <sshc> Yes, of course
18:42:59 <kmc> (Ptr a) is Storable without a Storable, right?
18:43:02 <kmc> since a is phantom anyway
18:53:03 <xplat> the only thing i can get iteratee-compress to do is segfault
18:53:34 <xplat> i feel like it is the library's fault but i don't know the iteratee library well enough to tell for sure
18:56:30 <moosefish> Well, thanks for you all's help. In exchange, thrift's bindings for Haskell compile and are even tested.
18:58:14 <kmc> yay!
18:58:17 <kmc> thank you
18:58:34 <xplat> Z.enumInflate Z.GZip ZZ.defaultDecompressParams cnt >>= IIO.enumHandl
18:58:50 <xplat> e (2^16) h >>= I.run -- segfaults
18:59:09 <moosefish> So 0.5 should be usable again.
19:00:22 <xplat> (cnt is a simple byte counter, works fine if given directly to enumHandle instead of enumInflate)
19:01:03 * hackagebot BNFC-meta 0.1.0.1 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.1.0.1 (JonasDuregard)
19:02:02 * kmc ♥ view patterns
19:02:08 <kmc> f (fromIntegral -> n) x y = ...
19:02:46 <megajosh2> view patterns... hmm
19:02:53 <megajosh2> ?wiki View_patterns
19:02:53 <lambdabot> http://www.haskell.org/haskellwiki/View_patterns
19:03:08 <megajosh2> It doesn't exist :C
19:03:31 <megajosh2> Ah okay I found it
19:12:47 * ddarius thinks view patterns are a much nicer solution than views and was happy with them back when they were first introduced as "transformational patterns" and then not implemented for eight years.
19:15:07 <ddarius> kmc: Have you gotten into recursive view patterns yet?
19:24:01 <megajosh2> Okay, that works
19:24:07 <megajosh2> > QUIT :Bye!
19:24:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:24:12 <megajosh2> % QUIT :Bye!
19:24:20 <megajosh2> Doesn't send a message... hmmm
19:26:33 <kmc> ddarius, no, have a good example?
19:27:58 <ddarius> kmc: Anything fold-like a particularly good example is: simplify (ADD (simplify -> 0) (simplify -> x)) -> x; etc.
19:28:47 <ddarius> Admittedly, that particular case would likely lead to recomputation.
19:30:27 <ddarius> That was supposed to be an = x at the end.
19:35:48 <kmc> cool
19:48:48 <osaunders> I really wish I could write a like b (<http://hpaste.org/40179/wish>).
19:49:34 <Axman6> osaunders: case?
19:50:06 <osaunders> case isn't that nice though.
19:50:28 <osaunders> I have to have points with a case.
19:50:31 <Axman6> yeah, i'd like to see that rtoo
19:50:34 <Axman6> -r
19:52:32 <sshc> "use a standalone 'deriving instance' declaration instead, so you can specify the instance context yourself" What is the syntax for that?
19:53:02 <aavogt> deriving instance Class Type
19:53:37 <aavogt> sshc: just like a regular instance declaration, but ghc is supposed to figure out the implementation
19:54:29 <sshc> aavogt: How could I derive Show for "data Foo a", but only when a is an instance of Show?
19:54:59 <aavogt> the regular deriving Show wrks for types like tat
19:55:02 <aavogt> *that
19:57:10 <ksf> oh wait, there already is a first icfp video online:  http://vimeo.com/15325077
20:05:34 <kmc> osaunders, charAsDir = go where go 'w' = ...
20:06:13 <osaunders> go where go?
20:07:37 <osaunders> kmc: Think I'm just going to use lookup.
20:12:54 <kmc> charAsDir = go where { go 'w' = ...; go 's' = ... }
20:13:17 <kmc> this is more useful when 'go' is recursive and 'charAsDir' has some args that don't change in the recursion
20:13:21 <kmc> the 'worker/wrapper transformation'
20:13:52 <_Ray_> Hey. How could I do something like f = [-, /, +, *]?
20:13:58 <Axman6> it's not recursive
20:14:15 <kmc> :t [(-), (/), (+), (*)]
20:14:16 <lambdabot> forall a. (Fractional a) => [a -> a -> a]
20:14:49 <_Ray_> ah, parenthesis. thanks :)
20:15:28 <kmc> in general, if %&#$^@# is an infix operator, then (%&#$^@#) is an ordinary expression
20:15:47 <Zao> @type [(-), (/), (<$>), (*)]
20:15:47 <lambdabot> forall a. (Fractional a) => [(a -> a) -> (a -> a) -> a -> a]
20:16:02 <Zao> I was slightly surprised that that typechecked :D
20:16:06 <Nereid> lol
20:16:09 <kmc> > map (($ (2,3)) . uncurry) [(+), (*), (-)]
20:16:10 <lambdabot>   [5,6,-1]
20:16:33 <kmc> must be strange lambdabot instances
20:16:38 <kmc> > succ + pred
20:16:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:16:39 <lambdabot>    arising from a use of `...
20:16:43 <kmc> > (succ + pred) 2
20:16:44 <lambdabot>   4
20:17:01 <Nereid> yeah there's something like a Num a => Num (t -> a)
20:17:12 <Jafet> @instances Num
20:17:13 <lambdabot> Double, Float, Int, Integer
20:17:43 <codolio> > (id + id) 32 const foldr putStrLn
20:17:44 <lambdabot>   64
20:17:48 <ddarius> Again, the function instance for Num comes from vector-space.
20:17:56 <Nereid> ah
20:18:01 <Nereid> also lol
20:18:15 <Nereid> > 5 8
20:18:16 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:18:17 <lambdabot>    `GHC.Num.Num t' arising f...
20:18:18 <Nereid> oh.
20:18:18 <ddarius> Even without it though, Zao's example would have type checked, it just would have had a different context.
20:18:28 <ddarius> > 5 8 :: Int
20:18:29 <lambdabot>   5
20:18:36 <Nereid> yeah.
20:18:37 <_Ray_> Would that map of $ and uncurry (for the (2, 3)) be easily extendable to return something like ["2 + 3 = 5", "2 * 3 = 6", ... ]
20:18:52 <_Ray_> using show, most likely
20:19:10 <Nereid> how would you get the "+" and such
20:19:15 <Axman6> not really, you'd need a show instance for functions
20:19:29 <ddarius> > foldr (+) 0 [1..10] :: Expr
20:19:30 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
20:19:49 <_Ray_> ah, right, there's no real function from + to "+"
20:19:51 <Jafet> > let showfn (+) = "+"; showfn (-) = "-"; in showfn (*)
20:19:53 <lambdabot>   "+"
20:19:56 <Nereid> ddarius: that relies on the Num instance for Expr
20:20:08 <Nereid> Jafet: can't pattern match on functions like that
20:20:12 <Nereid> well
20:20:13 <Nereid> wait
20:20:16 <Nereid> dur.
20:20:19 <Nereid> also lol
20:20:28 <Axman6> :t let showfn (+) = "+"; showfn (-) = "-"; in showfn
20:20:28 <lambdabot> forall t. t -> [Char]
20:20:41 <Nereid> > let showfn (+) = "+"; showfn (-) = "-"; in showfn (-)
20:20:42 <lambdabot>   "+"
20:20:46 <Nereid> indeed
20:20:56 <Nereid> oh of course.
20:21:38 <Nereid> since (+) is being treated as a variable.
20:22:30 <thezboe> is there a way to use foldr to check if a list is an ordered set?
20:23:09 <ddarius> > let showEq (expr, val) = show expr ++ " = " ++ show val in map showEq (foldr (+) 0 [1..10])
20:23:10 <lambdabot>   No instance for (GHC.Num.Num [(t, t1)])
20:23:10 <lambdabot>    arising from a use of `GHC.Num.+...
20:23:26 <Jafet> and $ zipWith (<) xs (tail xs)
20:24:23 <_Ray_> hrmph. how would I modify that use of $ to print something like "2 + 3 = 5"? I see that what happens in map (($ (2,3)) . uncurry) [(+), (-), (*), (/)] is that it first uncurries each function so it takes tuples, and then applies the result to (2, 3)
20:24:52 <ddarius> > let showEq (expr, val) = show expr ++ " = " ++ show val in map showEq (map (\f -> f 2 3) [(-), (/), (+), (*)]) 
20:24:52 <lambdabot>   ["-1.0 = -1.0","0.6666666666666666 = 0.6666666666666666","5.0 = 5.0","6.0 =...
20:25:22 <ddarius> > let showEq :: Show a => (Expr, a) -> String; showEq (expr, val) = show expr ++ " = " ++ show val in map showEq (map (\f -> f 2 3) [(-), (/), (+), (*)]) 
20:25:23 <lambdabot>   ["2 - 3 = -1.0","2 * recip 3 = 0.6666666666666666","2 + 3 = 5.0","2 * 3 = 6...
20:26:49 <thezboe> Jafet: how would i use that with foldr?
20:27:02 <Jafet> I don't see how to do that nicely with foldr
20:27:30 <ddarius> > (0, 0) 4
20:27:31 <lambdabot>   Couldn't match expected type `t1 -> t'
20:27:31 <lambdabot>         against inferred type `(t2, ...
20:28:24 <Jafet> Um Num Num
20:29:04 <thezboe> let isSet xs = zipWith (<) xs (tail xs)
20:29:43 <thezboe> let isSet xs = zipWith (<) xs (tail xs) isSet [1..10]
20:30:06 <Jafet> @hoogle sorted
20:30:06 <lambdabot> No results found
20:30:14 <Jafet> Phew
20:30:35 <thezboe> how do you get lambdabot to run stuff like that?
20:31:06 <Axman6> > let isSet xs = zipWith (<) xs (tail xs) in isSet [1..10]
20:31:07 <lambdabot>   [True,True,True,True,True,True,True,True,True]
20:31:14 <Jafet> > and . ap (zipWith (<)) tail $ [1..10]
20:31:15 <lambdabot>   True
20:31:15 <Axman6> > let isSet xs = and $ zipWith (<) xs (tail xs) in isSet [1..10]
20:31:16 <lambdabot>   True
20:31:18 <thezboe> ay
20:31:25 <Axman6> > let isSet xs = and $ zipWith (<) xs (tail xs) in isSet [1,2,3,4,5,4,6]]
20:31:26 <lambdabot>   <no location info>: parse error on input `]'
20:31:28 <Axman6> > let isSet xs = and $ zipWith (<) xs (tail xs) in isSet [1,2,3,4,5,4,6]
20:31:29 <lambdabot>   False
20:32:01 <thezboe> Sorry to be a pest, what is the meaning of the "and $"?
20:32:28 <c_wraith> :t and
20:32:29 <lambdabot> [Bool] -> Bool
20:32:32 <Jafet> > let isSet :: Set a -> Bool; isSet = const True in isSet $ fromList [1..10]
20:32:32 <c_wraith> :t ($)
20:32:33 <lambdabot>   Not in scope: type constructor or class `Set'
20:32:33 <lambdabot> forall a b. (a -> b) -> a -> b
20:32:47 <Axman6> > and [True, True, True]
20:32:47 <lambdabot>   True
20:32:50 <Axman6> > and [True, True, False]
20:32:51 <lambdabot>   False
20:32:54 <Axman6> @src and
20:32:54 <lambdabot> and   =  foldr (&&) True
20:33:14 <Jafet> Crouching zipwith hidden foldr
20:36:21 <thezboe> let isSet xs = and (zipWith (<) xs (tail x)) in isSet [1..10]
20:38:24 <thezboe> let isSet xs = and (zipWith (<) xs (tail xs)) in isSet [1..10]
20:39:06 <thezboe> @src and
20:39:07 <lambdabot> and   =  foldr (&&) True
20:40:00 <Nereid> > [1..10] == sort [1..10]
20:40:01 <lambdabot>   True
20:40:04 <Nereid> ;)
20:40:35 <thezboe> I can just put parenthesis around zipWith (<) xs (tail xs) and have it be the same thing right?
20:41:04 <thezboe> > let isSet xs = and (zipWith (<) xs (tail xs)) in isSet [1..10]
20:41:05 <lambdabot>   True
20:41:28 <co_dh> I'd like to define a function h based on f, g , if f x is undefined, return g x , else return fx . 
20:41:35 <co_dh> how can I do that ? 
20:42:27 <codolio> You cannot. undefined is not just some ordinary null value.
20:44:08 <co_dh> I don't like the sentence : you cannot :(
20:44:15 <Nereid> you really can't though.
20:44:48 <Nereid> what if f x is a computation that runs for a really really long time then returns 2?
20:44:51 <codolio> Such a function would violate the semantics of Haskell.
20:45:00 <Nereid> how would you know it stops?
20:45:31 <Nereid> because semantically, undefined is the same as a computation that never stops.
20:45:53 <co_dh> but in practice, undefined return an exception. 
20:46:18 <co_dh> never used try catch before in Haskell, can I use that to implement my function? 
20:46:20 <Jafet> A non-terminating computation has value undefined. Exceptions also have value undefined.
20:46:28 <Nereid> co_dh: only within IO
20:46:31 <Jafet> ...and, of course, the NonTermination exception
20:47:26 <co_dh> is there a programming language that support Relation programming? instead of functional programming? 
20:48:27 <dons> hmm.
20:48:32 <dons>  logic programming languages?
20:48:57 <kmc> co_dh, SQL and Alloy come to mind
20:49:09 <thezboe> How would i use an ordering function with the isSet function to check how the list is supposed to be ordered?
20:49:13 <kmc> they're not quite general purpose languages
20:49:16 <kmc> Alloy is quite fun though
20:50:33 <co_dh> I mean a programming language implement's Algebra of relation as in Richard Bird's Algebra of Programming
20:55:28 <co_dh> is there a way to write h  (Left i ) = f i   as  h . Left = f  ? ( defining h ) 
20:55:42 <co_dh> or other language that support this ? 
20:56:07 <co_dh> or h = f . unLeft ? 
20:56:21 <Nereid> co_dh: what about Right?
20:56:28 <Nereid> by the way, you could do
20:56:38 <Nereid> instead of h (Left i) = f i; h (Right i) = g i
20:56:41 <Axman6> :t either
20:56:42 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:56:43 <Nereid> you could write h = f ||| g
20:56:50 <co_dh>   h =  f . unLeft `union` g . unRight
20:56:51 <Axman6> :t (|||)
20:56:52 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
20:56:54 <Nereid> or h = either f g
20:57:02 <Nereid> same thing, but (|||) is in Control.Arrow
20:57:42 <co_dh> @src either
20:57:42 <lambdabot> either f _ (Left x)     =  f x
20:57:43 <lambdabot> either _ g (Right y)    =  g y
20:57:43 <Nereid> and either is in Prelude so
20:58:05 <Nereid> was the type not enough for you? ;)
20:58:07 <co_dh> thanks , guys :)
20:58:25 <Nereid> I don't think there even is another function with type (a -> c) -> (b -> c) -> Either a b -> c
20:58:31 <mtnviewmark> look - tibbe is in an UTC+ time zone!
20:58:41 <mtnviewmark> er UTC-
20:58:43 <mtnviewmark> that is
20:58:46 <tibbe> mtnviewmark: yay!
20:58:53 <mtnviewmark> How was the first day?
20:58:56 <Nereid> other than either and those that are less defined than either
20:59:09 <tibbe> mtnviewmark: good, lots of nice people to chat with
20:59:30 <tibbe> mtnviewmark: I'm too much of a die hard programmer to appreciate all of the type theory talks
20:59:41 <mtnviewmark> wonderful! Looking forward to getting there on Wednesday
20:59:56 * mtnviewmark notes that he skipped all the type theory talks....
21:00:29 <mtnviewmark> now I just have to finish my slides for my talk....
21:00:44 <tibbe> mtnviewmark: me too
21:01:09 <mtnviewmark> heh! And yours is like 20x the length of mine!
21:01:40 <Axman6> @djinn (a -> c) -> (b -> c) -> Either a b -> c
21:01:40 <lambdabot> f a b c =
21:01:40 <lambdabot>     case c of
21:01:41 <lambdabot>     Left d -> a d
21:01:41 <lambdabot>     Right e -> b e
21:02:21 <Nereid> heh
21:02:45 <Nereid> @djinn a
21:02:46 <lambdabot> -- f cannot be realized.
21:02:51 <Nereid> @djinn a -> a -> a
21:02:51 <lambdabot> f _ a = a
21:02:56 <Nereid> heh
21:03:05 <c_wraith> @djinn (a -> a) -> a
21:03:05 <lambdabot> -- f cannot be realized.
21:03:11 <c_wraith> hehe :)
21:03:15 <c_wraith> :t fix
21:03:16 <lambdabot> forall a. (a -> a) -> a
21:03:24 <Nereid> well yeah, but djinn doesn't include fix.
21:03:36 <c_wraith> djinn sticks to total functions
21:03:43 <Nereid> I wonder if it something be undecidable or something if it did?
21:03:45 <c_wraith> fix is not total
21:03:51 <Nereid> well yeah
21:03:57 <Nereid> :v
21:14:14 <thezboe> given a sort list of elements, what's a function i can use to only retain unique elements?
21:14:21 <thezboe> sorted* list
21:14:37 <thezboe> basically to make a list become a set
21:14:53 <Axman6> > map head . group $ [1,2,3,3,4,4,5,5,5,5,6,7,8,8,8,9]
21:14:54 <lambdabot>   [1,2,3,4,5,6,7,8,9]
21:15:17 <thezboe> wow
21:15:18 <thezboe> nice
21:15:20 <thezboe> =P 
21:16:04 <Nereid> I guess that's more efficient than nub for sorted lists
21:16:20 <Axman6> > group $ [1,2,3,3,4,4,5,5,5,5,6,7,8,8,8,9]
21:16:21 <lambdabot>   [[1],[2],[3,3],[4,4],[5,5,5,5],[6],[7],[8,8,8],[9]]
21:16:32 <Nereid> nub is O(n^2) no?
21:16:46 <thezboe> any way to do that using and of the folds, map, zip, filter?
21:17:15 <thezboe> any of the folds*
21:17:23 <dobblego> every list function can be written using foldr, therefore yes
21:17:28 <Nereid> lol
21:17:48 <thezboe> i tried to do something like
21:18:54 <thezboe> > let makeSet xs = foldr (\x y ys -> if x /= y then x:y:ys else x:ys) [] xs in [1,1,1,1,2,2,3,3,4,4,4,5,5,5,6,6,6,7]
21:18:55 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t -> t1]
21:19:06 <JoeyA> Nereid: yes, nub is O(n^2).  you can (map head . group . sort) in O(n*log n), but it's not lazy.
21:19:23 <Nereid> but if it's already sorted, then map head . group is O(n)
21:19:27 <co_dh> @pl \(f,g) -> Left . f ||| Right . g
21:19:28 <lambdabot> uncurry ((. (Right .)) . (|||) . (Left .))
21:19:43 <JoeyA> right
21:19:46 <Nereid> @pl \(f,g) -> either (Left . f) (Right . g)
21:19:47 <lambdabot> uncurry ((. (Right .)) . either . (Left .))
21:19:49 <Nereid> heh
21:20:07 <JoeyA> Also, you could use an Ord nub based on Data.Set, such as described here:  http://buffered.io/2008/07/28/a-better-nub/
21:20:08 <dobblego> bimap f g
21:20:29 <thezboe> how can i compare two adjacent elements and then add them to a list that is returned at the end?
21:21:29 <JoeyA> isn't that what group does?
21:21:35 <co_dh> thezboe : foldr ? cmp list
21:21:38 <JoeyA> > group [1,1,2,2,3,1]
21:21:39 <lambdabot>   [[1,1],[2,2],[3],[1]]
21:22:14 <JoeyA> I didn't understand the question
21:23:33 <thezboe> i'm trying to just stick to using fold, map, zip, filter
21:24:05 <co_dh> thezboe: please give an example of your problem
21:24:08 <tommd> thezboe: This was a question on SO recently (well, what to name such a function).  I think they used zipWith, but it's up to you
21:24:39 <JoeyA> @quote zip`ap`tail
21:24:39 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
21:24:53 <JoeyA> > (zip`ap`tail) [1,2,3]
21:24:53 <lambdabot>   [(1,2),(2,3)]
21:25:16 <JoeyA> > (\x -> zip x (tail x)) [1,2,3]
21:25:17 <lambdabot>   [(1,2),(2,3)]
21:25:28 <dobblego> thezboe, try zipping with the tail, then filter then map
21:25:56 <co_dh> :t ap
21:25:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:25:58 <JoeyA> > (\x -> zipWith (\a b -> b - a) x (tail x)) [1,4,9,16,25]
21:25:58 <lambdabot>   [3,5,7,9]
21:26:09 <JoeyA> or, more concisely:
21:26:33 <JoeyA> > (zipWith (flip (-)) `ap` tail) [1,4,9,16,25]
21:26:34 <lambdabot>   [3,5,7,9]
21:26:43 <thezboe> Thanks for the help guys.. the lambda expressions really give me a hard time
21:27:46 <Nereid> > flip (fmap . fmap . fmap . uncurry) zip (+) [1,2,3] [2,5,7]
21:27:47 <lambdabot>   [3,7,10]
21:27:50 <Nereid> :U
21:28:18 <Nereid> lol
21:29:27 <scutigera> > flip [1,2,3]
21:29:29 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [b])
21:29:29 <lambdabot>    arising from a use of...
21:29:48 <Nereid> > flip (fmap`fmap`fmap`fmap`fmap`fmap`uncurry) zip (+) [1,2,3] [2,5,7]
21:29:49 <Nereid> what
21:29:50 <lambdabot>   [3,7,10]
21:30:01 <Nereid> no one should write code like that ever.
21:31:06 <co_dh> :t (@)
21:31:07 <lambdabot> parse error on input `@'
21:31:32 <Nereid> @ isn't a valid character for an identifier
21:31:35 <thezboe> makeSet cmp xs = map (fst) . filter (cmp fst snd /= EQ) . zip xs (tail xs)
21:31:36 <co_dh> :djinn   a -> ( a->b) -> b 
21:31:55 <thezboe> that's what i came up with.. but i can't use fst or snd without having the tuple after it..
21:32:12 <Nereid> co_dh: flip ($)
21:32:15 <co_dh> what is the reverse application operator ? 
21:32:21 <co_dh> :t ($)
21:32:22 <lambdabot> forall a b. (a -> b) -> a -> b
21:32:41 <Nereid> :t flip ($)
21:32:42 <lambdabot> forall a b. a -> (a -> b) -> b
21:32:49 <Nereid> @djinn a -> (a -> b) -> b
21:32:50 <lambdabot> f a b = b a
21:32:51 <Nereid> heh
21:33:14 <Nereid> yeah, ($) is just a specialized version of id
21:33:24 <Nereid> bye
21:38:45 <thezboe> > map (\x -> fst x) .zip [1..4] (tail [1..4])
21:38:46 <lambdabot>   Couldn't match expected type `[(a, b)]'
21:38:46 <lambdabot>         against inferred type `(t, ...
21:38:57 <thezboe> why won't that work
21:39:23 <thezboe> i tried without the dot and just parens and it worked
21:39:35 <JoeyA> > map (\x -> fst x) $ zip [1..4] (tail [1..4])
21:39:36 <lambdabot>   [1,2,3]
21:39:40 <thezboe> >map (\x -> fst x) (zip [1..4] (tail [1..4]))
21:39:50 <thezboe> > map (\x -> fst x) (zip [1..4] (tail [1..4]))
21:39:51 <lambdabot>   [1,2,3]
21:40:01 <thezboe> why won't the (.) work?
21:40:04 <JoeyA> . means composition, so think of it as "lifted" application.
21:40:14 <JoeyA> > (+3) $ (*2) $ 1
21:40:15 <lambdabot>   5
21:40:25 <JoeyA> > ((+3) . (*2)) 1
21:40:26 <lambdabot>   5
21:41:04 <thezboe> hmm
21:42:20 <caelan> gah, too tired to reason through type inferences
21:42:32 <JoeyA> > (map toLower) "Hello World"
21:42:33 <lambdabot>   "hello world"
21:42:38 <JoeyA> > (words . map toLower) "Hello World"
21:42:38 <lambdabot>   ["hello","world"]
21:42:44 <JoeyA> > (reverse . words . map toLower) "Hello World"
21:42:45 <lambdabot>   ["world","hello"]
21:42:58 <JoeyA> > (unlines . reverse . words . map toLower) "Hello World"
21:42:59 <lambdabot>   "world\nhello\n"
21:43:08 <JoeyA> > (reverse . unlines . reverse . words . map toLower) "Hello World"
21:43:09 <lambdabot>   "\nolleh\ndlrow"
21:43:14 <JoeyA> > (text . reverse . unlines . reverse . words . map toLower) "Hello World"
21:43:15 <lambdabot>   olleh
21:43:16 <lambdabot>  dlrow
21:43:39 <thezboe> so it takes what the function on the right returns and feeds it into the function on the left?
21:43:46 <caelan> yes
21:44:11 <thezboe> > (map (\x -> fst x) . zip) [1..4] (tail [1..4])
21:44:11 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
21:44:23 <JoeyA> (f . g) (x) = f(g(x))
21:44:37 <thezboe> doesn't zip return [(a,a)]?
21:44:46 <caelan> (.) :: (a -> b) -> (c -> a) -> (c -> b)
21:44:54 <thezboe> :t zip
21:44:55 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:45:12 <thezboe> i don't understand why composition wouldn't work in that instance
21:45:21 <JoeyA> The composition isn't particularly elegant here because zip takes 2 arguments, not one.
21:45:48 <JoeyA> Now you could do:
21:45:55 <thezboe> > (map (\x -> fst x) . zip [1..4]) (tail [1..4])
21:45:56 <lambdabot>   <no location info>: lexical error at character '\RS'
21:46:09 <JoeyA> > (map (\x -> fst x) . zip [1..4]) (tail [1..4])
21:46:10 <lambdabot>   [1,2,3]
21:46:29 <JoeyA> what you pasted, but without the screwy control character.
21:46:43 <thezboe> ahh.. so because of the 2 arguments it wouldn't compose it right
21:46:47 <caelan> > zip [1..4] [1..3]
21:46:48 <lambdabot>   [(1,1),(2,2),(3,3)]
21:46:49 * hackagebot hamlet 0.5.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.5.1 (MichaelSnoyman)
21:46:51 * hackagebot web-routes-quasi 0.6.0.1 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.0.1 (MichaelSnoyman)
21:46:58 <caelan> thezboe: exactly
21:47:00 <thezboe> so you had to curry the first argument to get it to compose right?
21:47:42 <caelan> i keep forgetting that zip does the Intelligent Thing with lists of different lengths
21:49:10 <JoeyA> By the way, (\x -> f x) is equivalent to just f.  For future reference, that's called an "eta reduction" in lambda calculus, if I'm not mistaken.
21:50:23 <JoeyA> :t zip
21:50:24 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:50:33 <JoeyA> :t uncurry zip
21:50:34 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
21:50:36 <caelan> no, eta reduction is (\x -> f x) => f
21:50:47 <JoeyA> That's what I said.
21:50:59 <JoeyA> right?
21:51:03 <caelan> oh wow, now i'm misreading things
21:51:07 <Axman6> indeed
21:51:10 <caelan> *facepalm*
21:52:07 <JoeyA> zip takes 2 arguments, but uncurry zip takes 1 tuple of 2 items.  (actually, any function in Haskell takes 1 argument; zip just returns a function which takes an argument which returns a list)
21:52:21 <JoeyA> That said:
21:52:24 <co_dh> how can I define Product Category from two category ? 
21:52:41 <JoeyA> > (uncurry zip) ([1..4], tail [1..4])
21:52:42 <lambdabot>   [(1,2),(2,3),(3,4)]
21:53:00 <co_dh> if C , D  are categories, then (C,D) should be category too, 
21:53:08 <JoeyA> > (map fst . uncurry zip) ([1..4], tail [1..4])
21:53:10 <lambdabot>   [1,2,3]
21:53:22 <co_dh> or ( f, g) >>> ( f1, g1 ) = (f >>> f1 , g >>> g1 )
21:55:52 <thezboe> > makeSet xs = map (\y -> fst y) $ filter (\x ->  fst x /= snd x) (zip xs (tail xs)) in [1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,8,8,9]
21:55:53 <lambdabot>   <no location info>: parse error on input `='
21:56:19 <JoeyA> @let makeSet xs = map (\y -> fst y) $ filter (\x ->  fst x /= snd x) (zip xs (tail xs)) in [1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,8,8,9]
21:56:19 <lambdabot>   Parse error: KW_In
21:56:33 <JoeyA> err
21:56:39 <JoeyA> > let makeSet xs = map (\y -> fst y) $ filter (\x ->  fst x /= snd x) (zip xs (tail xs)) in [1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,8,8,9]
21:56:40 <lambdabot>   [1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,8,8,9]
21:57:12 <JoeyA> it'd help to apply your function to something :-)
21:57:19 <JoeyA>  > let makeSet xs = map (\y -> fst y) $ filter (\x ->  fst x /= snd x) (zip xs (tail xs)) in makeSet [1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,8,8,9]
21:57:24 <JoeyA> > let makeSet xs = map (\y -> fst y) $ filter (\x ->  fst x /= snd x) (zip xs (tail xs)) in makeSet [1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,8,8,9]
21:57:25 <lambdabot>   [1,2,3,4,5,6,7,8]
21:57:32 <thezboe> that's what i wanted =]
21:57:33 <thezboe> lol
21:57:39 <thezboe> except it always cuts off the last value =/
21:57:45 <thezboe> there should be a 9
21:58:00 <caelan> that gets cut off in the tail xs
21:58:11 <caelan> whoops, no, in the xs
21:58:27 <caelan> > zip [1,2,3] [1,2]
21:58:28 <lambdabot>   [(1,1),(2,2)]
21:58:52 <thezboe> > let makeSet xs =  (zip xs (tail xs)) in makeSet [1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,5,6,6,7,7,8,8,9]
21:58:53 <lambdabot>   [(1,1),(1,1),(1,1),(1,1),(1,2),(2,2),(2,2),(2,2),(2,2),(2,3),(3,3),(3,3),(3...
21:59:05 <caelan> > deleteAll 1 [1,2,3,4,1]
21:59:06 <lambdabot>   Not in scope: `deleteAll'
21:59:10 <thezboe> darn.. how can i solve that?
21:59:13 <ManateeLazyCat> This picture clear enough ? http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/
21:59:14 <caelan> > List.deleteAll 1 [1,2,3,4,1]
21:59:15 <lambdabot>   Not in scope: `List.deleteAll'
21:59:51 <thezboe> > let makeSet xs = map (\y -> fst y) $ filter (\x ->  fst x /= snd x) (zip xs (tail xs)) in makeSet [1,1,2,2,3,4,5,6,7,8,8,9]
21:59:52 <lambdabot>   [1,2,3,4,5,6,7,8]
22:00:29 <JoeyA> Could you use pattern matching?
22:00:37 <JoeyA> can*
22:00:48 <ManateeLazyCat> http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/ is framework to explain application at http://www.flickr.com/photos/48809572@N02/
22:00:48 <thezboe> we have to use higher order functions =/
22:00:54 <JoeyA> oh\
22:01:08 <thezboe> lol.. =/ doesn't look liek = /
22:01:44 <Axman6> > let makeSet = map head . group . sort in makeSet [1,45,7,2,5,7,5,23,3,7,65,3,5,3,5,67,2,3,6]
22:01:45 <lambdabot>   [1,2,3,5,6,7,23,45,65,67]
22:02:12 <caelan> let deleteAll x list = case list of { [] -> []; (y:ys) -> if x == y then deleteAll x ys else y : deleteAll x ys } in deleteAll 1 [1,2,3,4,5,1]
22:02:40 <caelan> > let deleteAll x list = case list of { [] -> []; (y:ys) -> if x == y then deleteAll x ys else y : deleteAll x ys } in deleteAll 1 [1,2,3,4,5,1]
22:02:41 <lambdabot>   [2,3,4,5]
22:02:53 * hackagebot clientsession 0.4.0.3 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.4.0.3 (MichaelSnoyman)
22:02:55 * hackagebot convertible-text 0.3.0.5 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.5 (MichaelSnoyman)
22:02:57 * hackagebot persistent 0.2.2.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.2.2 (MichaelSnoyman)
22:04:06 <thezboe> Axman: is group provided in standard Prelude?
22:04:14 <Axman6> i believe so
22:04:26 <tommd> @hoogle group
22:04:27 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
22:04:27 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
22:04:27 <lambdabot> Data.ByteString.Char8 group :: ByteString -> [ByteString]
22:04:34 <tommd> dumb hoogle
22:04:37 <Axman6> could be wrong
22:05:33 <JoeyA> No, group is not in the Prelude, at least not here:  http://www.haskell.org/onlinereport/standard-prelude.html
22:06:22 <JoeyA> So, I think zipping with tail is the right approach.
22:06:50 <thezboe> Ya, I'm trying to think of a way to get it to make sure to get that last element
22:07:19 <JoeyA> Let's look at the problem in simple logic terms:  if the item after x is equal to x, throw one of them out.  Correct?
22:07:34 <thezboe> yes
22:07:36 <JoeyA> Problem is, the last item has no next element.
22:08:13 <thezboe> but if we go the pattern matching route, will the function we've come up with go to the pattern matched one for the last element?
22:08:51 <caelan> okay, think i've got it
22:09:42 <JoeyA> makeSet [] = []; makeSet [x] = [x]; makeSet (a:b:xs) = if a == b then ... something
22:10:16 <JoeyA> But I'd imagine handling of the "last element" happens in the single-item edge case.
22:10:34 <thezboe> This is like a re-implementation of a past assignment, which i already did with pattern matching =P
22:10:59 <JoeyA> > last [1,2,3,4,5]
22:11:00 <lambdabot>   5
22:11:02 <JoeyA> > last []
22:11:03 <lambdabot>   *Exception: Prelude.last: empty list
22:11:23 <caelan> here you go, thezboe: http://pastebin.com/3fhLsTuX
22:12:27 <JoeyA> caelan: not sure that's what thezboe's homework is trying to do.
22:12:54 <caelan> sorry, that's what makeSet sounds like to me :)
22:13:09 <thezboe> it's correct, but i need to use higher order functions =]
22:13:19 <caelan> ahh
22:13:29 <JoeyA> What is makeSet [1,2,3,1] supposed to be?
22:13:38 <JoeyA> [1,2,3] or [1,2,3,1] ?
22:13:42 <thezboe> but i'm appreciative of your efforts =]
22:13:46 <thezboe> [1,2,3]
22:14:00 <JoeyA> oh, so adjacent items won't cut it, then.
22:14:15 <JoeyA> You have to filter out all the items that match the current item you're looking at.
22:14:25 <caelan> hmm
22:14:27 <caelan> oh, i know
22:14:28 <JoeyA> If only there were a higher level function that could filter lists.
22:14:42 <thezboe> well i call sort on the list before, so adjacent items should do
22:15:01 <JoeyA> Is there a time complexity requirement?
22:15:05 <thezboe> none
22:15:12 <JoeyA> simply filtering would probably be easier to implement.
22:15:41 <JoeyA> that is, take an item, and filter out all the items after it that are the same, and continue.
22:15:50 <tommd> nub?
22:16:00 <JoeyA> functionally, yes.
22:16:13 <JoeyA> > tails [1,2,3,4,5]
22:16:13 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
22:17:41 <JoeyA> Are you allowed to pattern match away the empty list case?
22:17:58 <JoeyA> makeSet [] = []; makeSet xs = go nuts
22:18:04 <thezboe> yes
22:18:24 <JoeyA> are you allowed to recurse?
22:18:49 <thezboe> nope.. that's the tricky part
22:18:59 <caelan> so much for my second solution
22:19:17 <Axman6> :t foldl
22:19:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:19:43 <thezboe> whoa it kicked me out
22:20:56 <tommd> No one kicked you, thezboe.
22:21:06 <tommd> " thezboe left the room"  Perhaps you mis-clicked?
22:21:17 <tommd> See your log
22:21:29 <thezboe> err.. maybe.. lol.. i was just sitting at the terminal and colloquy put me back at the join room dialog
22:22:33 <JoeyA> one option would be to fold over the list, keeping a separate list of items you've already visited.
22:22:48 <JoeyA> better yet, don't add items to the list if you've already added them.
22:23:01 <JoeyA> (so it's only one list)
22:24:31 <JoeyA> > 3 `elem` [1,2,3]
22:24:32 <lambdabot>   True
22:24:38 <JoeyA> > elem 3 [1,2,3]
22:24:39 <lambdabot>   True
22:26:06 <thezboe> > makeSet xs = foldr (\x y ys -> if x /= y then x:y:ys else x:ys) [] [1..10]
22:26:07 <lambdabot>   <no location info>: parse error on input `='
22:26:22 <thezboe> that's where i was trying to go with that, but i don't think you can lambda like that
22:26:48 <JoeyA> you can do the lambda like that, but foldr only takes a 2-argument piece.
22:26:50 <Axman6> the lambda has the wrong type
22:29:50 <thezboe> ya.. i'm stumped
22:30:01 <Axman6> @src group
22:30:02 <lambdabot> group = groupBy (==)
22:30:06 <Axman6> @src groupBy
22:30:06 <lambdabot> groupBy _  []       =  []
22:30:06 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
22:30:07 <lambdabot>     where (ys,zs) = span (eq x) xs
22:30:22 <caelan> maybe a combination of concatMap, filter, and tails will help here
22:30:25 <JoeyA> @src map
22:30:25 <lambdabot> map _ []     = []
22:30:25 <lambdabot> map f (x:xs) = f x : map f xs
22:31:05 <JoeyA> I found a nice solution, but I'm not gonna just give it away :-)
22:31:19 <caelan> i had an Idea, but i need to work it out
22:32:33 <thezboe> JoeyA, I'll work for it.. lol
22:32:45 <JoeyA> @let map' f xs = foldr (\x ys -> f x : ys) [] [1,2,3]
22:32:46 <lambdabot>  Defined.
22:32:53 <JoeyA> > map' (+3) [1,2,3]
22:32:54 <lambdabot>   [4,5,6]
22:33:12 <JoeyA> Although foldr associates right-to-left, notice the left-to-right action going on here.
22:33:18 <caelan> @src foldr
22:33:19 <lambdabot> foldr f z []     = z
22:33:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:34:12 <JoeyA> oops
22:34:18 <JoeyA> @let map' f xs = foldr (\x ys -> f x : ys) [] xs
22:34:18 <lambdabot>  <local>:1:0:
22:34:19 <lambdabot>      Warning: Pattern match(es) are overlapped
22:34:19 <lambdabot>               In...
22:34:23 <Axman6> > let f x xs = if x `elem xs then id else (x:) in foldr f [] [1,2,5,2,4,6,8,3]
22:34:23 <lambdabot>   <no location info>: parse error on input `xs'
22:34:25 <JoeyA> @undefine map'
22:34:31 <Axman6> > let f x xs = if x `elem` xs then id else (x:) in foldr f [] [1,2,5,2,4,6,8,3]
22:34:32 <lambdabot>   Couldn't match expected type `[a]'
22:34:32 <lambdabot>         against inferred type `[a] -> [a]'
22:34:39 <JoeyA> Axman6: this is a homework assignment.
22:34:43 <JoeyA> @let map' f xs = foldr (\x ys -> f x : ys) [] xs
22:34:44 <lambdabot>  Defined.
22:35:16 <JoeyA> Anyway, the left-to-right action happening in foldr is rather fascinating.
22:35:39 <JoeyA> x is the current item (pretend we look at the left-most item first)
22:36:17 <thezboe> right
22:36:29 <JoeyA> ys is... your entire list after you "already built it"
22:36:43 <JoeyA> but because of lazy evaluation, interestingly enough, you can get it to happen first.
22:37:29 <JoeyA> in map' f xs = foldr (\x ys -> f x : ys) [] xs  , ys isn't evaluated because it isn't needed yet.  However, you can think of it as already containing the fold on the other items.
22:38:05 <JoeyA> I don't fully understand this idea yet either :-)
22:38:08 <Axman6> > let f x xs = (if x `elem` xs then id else (x:)) xs in foldr f [] [1,2,5,2,4,6,8,3]
22:38:08 <lambdabot>   [1,5,2,4,6,8,3]
22:38:10 <thezboe> lol. i see
22:38:34 <Axman6> > let f x xs = if x `elem` xs then xs else x:xs in foldr f [] [1,2,5,2,4,6,8,3]
22:38:35 <lambdabot>   [1,5,2,4,6,8,3]
22:39:27 <Axman6> that's a n^2 algorithm though
22:39:35 <JoeyA> yup
22:40:00 <thezboe> @src foldr
22:40:00 <lambdabot> foldr f z []     = z
22:40:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:40:07 <thezboe> @src map
22:40:08 <lambdabot> map _ []     = []
22:40:08 <lambdabot> map f (x:xs) = f x : map f xs
22:40:45 <JoeyA> now, this is close to the final answer, but it's right-biased rather than left-biased.
22:40:55 <JoeyA> see if you can figure out why :-)
22:41:30 <JoeyA> > foldr (\x xs -> if x `elem` xs then xs else x:xs) [] [1,2,3,1,4,2,5] -- why is this right-biased?
22:41:31 <lambdabot>   [3,1,4,2,5]
22:41:51 <Axman6> because it builds the list from the right
22:42:07 <thezboe> well foldr starts from the right.
22:42:16 <JoeyA> you can use foldr and have it left-biased.
22:42:33 <JoeyA> and if you used basically the same thing with foldl, it would be left-biased.
22:42:39 <thezboe> ya
22:43:13 <JoeyA> > (reverse . foldl (\xs x -> if x `elem` xs then xs else x:xs) []) [1,2,3,1,4,2,5]
22:43:14 <lambdabot>   [1,2,3,4,5]
22:43:23 <thezboe> > (sort . foldr (\x xs -> if x `elem` xs then xs else x:xs) []) [1,2,3,1,4,2,5]
22:43:24 <lambdabot>   [1,2,3,4,5]
22:43:37 <thezboe> hehe
22:43:41 <JoeyA> cheater :P
22:43:44 <JoeyA> But I urge you to find the foldr solution, for learning's sake :-)
22:44:02 <thezboe> isn't that the foldr solution? lol
22:44:30 <thezboe> or to find someway around the sort?
22:44:34 * JoeyA fills out a detention slip
22:45:03 <JoeyA> I mean, there's an even shorter solution that knocks out the sort.
22:45:34 <caelan> there's perl golf, and then there's haskell golf
22:45:55 <JoeyA> golf :: Code c => Golf c
22:45:59 <thezboe> > foldr (\x xs -> if x `elem` xs then xs else x:xs) [] (sort [1,2,3,1,4,2,5])
22:46:00 <lambdabot>   [1,2,3,4,5]
22:46:08 <thezboe> hehe got the sort out of the foldr =P
22:46:12 <thezboe> but not quite
22:46:57 <caelan> :t groups
22:46:57 <lambdabot> Not in scope: `groups'
22:47:00 <caelan> :t group
22:47:01 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
22:47:29 <JoeyA> My solution resembles what caelan pasted earlier.
22:47:54 <JoeyA> It actually resembles your pattern-matching solution.
22:47:58 <JoeyA> @src foldr
22:47:58 <lambdabot> foldr f z []     = z
22:47:58 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:48:02 <JoeyA> Does that ring a bell?
22:48:27 <caelan> oh hey, sure does
22:48:41 <JoeyA> (maybe it does, depending on how exactly you implemented your pattern-matching solution)
22:49:08 <thezboe> ya.. i just don't see how pattern matching would fit into foldr statements
22:50:00 <caelan> actually, foldr looks a lot like deleteAll
22:50:19 <JoeyA> @let addOneFromNowOn :: [Int] -> [Int]; addOneFromNowOn [] = []; addOneFromNowOn (x:xs) = (x+1) : addOneFromNowOn xs
22:50:20 <lambdabot>  Defined.
22:50:26 <JoeyA> > addOneFromNowOn [1..5]
22:50:27 <lambdabot>   [2,3,4,5,6]
22:50:42 <JoeyA> > foldr (\x xs -> (x+1) : xs) [1..5]
22:50:43 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
22:50:43 <lambdabot>    arising from a use ...
22:51:06 <JoeyA> > foldr (\x xs -> (x+1) : xs) [] [1..5]
22:51:07 <lambdabot>   [2,3,4,5,6]
22:51:24 <caelan> joey, i'd really like to see your solution
22:51:56 <caelan> i've got a vague inkling, but i've been hacking on something for ten hours now, and it's long past bedtime
22:55:23 <thezboe> i want to know too =]
22:56:07 <JoeyA> thezboe: take a look at how, in my addOneFromNowOn example, xs has already been recursed on.
22:56:43 <JoeyA> You can think of it as going from left to right, with the second parameter of the foldr lambda (in this example, xs) already applied to the recursion.
22:57:22 <thezboe> right
22:59:35 <JoeyA> Maybe you should brew yourself some coffee and look at the problem later *cough*hint*cough*
22:59:59 <thezboe> lol i might just use sort =P
23:00:08 <JoeyA> okay, simpler hint: filter
23:00:33 <thezboe> filter after the foldr?
23:00:48 <JoeyA> no
23:01:08 <thezboe> before? inside the lambda?
23:01:12 <JoeyA> inside
23:01:28 <augur> anyone know anything about unification of "logical" objects?
23:02:10 <kmc> what kind of objects?
23:02:14 <JoeyA> The only thing I know about that is what I read here:  http://en.wikipedia.org/wiki/Unification_%28computing%29#Examples_of_unification
23:03:04 <thezboe> hehe got it!
23:03:08 <augur> kmc: well, so like, imagine that an object x is partially specified (it has variables, or something of that nature)
23:03:39 <augur> kmc: we can then imagine that x represents a set of possible unifiers, and x = y succeeds by selecting that x that is also y
23:03:53 <thezboe> > foldr (\x ys -> if x `elem` ys then ys else filter (<x) ys ++ [x] ++ filter (>x) ys) [] [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:03:54 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
23:04:05 <JoeyA> not what I had in mind
23:04:07 <JoeyA> simpler
23:04:10 <thezboe> lame
23:04:11 <thezboe> lol
23:04:13 <JoeyA> that is, my idea is simpler
23:04:18 <augur> kmc: e.g. [X,Y] = [1,2] yields [1,2] where X = 1, Y = 2, because [1,2] is a member of the set [X,Y]
23:04:23 <thezboe> but it works righhhtt?
23:04:23 <JoeyA> and doesn't require Ord :-)
23:04:32 <kmc> i don't understand "[1,2] is a member of the set [X,Y]"
23:04:37 <thezboe> I guess
23:04:45 <JoeyA> no, but it's a rather interesting solution :-)
23:04:52 <kmc> otherwise, so far you are describing something like the unification algorithm used in H-M type inference and many other contexts
23:04:53 <augur> kmc: one message before that i explained it. :|
23:05:01 * ski idly wonders what brought on the talk about unification
23:05:03 <JoeyA> In that it seems to be doing some sort of sorting.  Cool.
23:05:10 <augur> ski: theorem proving did!
23:05:19 <augur> now you're both in it.
23:06:01 <JoeyA> My function gives [5,1,9,3,7,8,2,4,0,6]
23:06:02 <thezboe> does it get rid of `elem`?
23:06:05 <JoeyA> yes
23:06:15 <thezboe> but it doens't get around sort?
23:06:18 <augur> kmc, ski: ok, so if [X,Y] can be thought of as denoting the set of two-element lists, and [1,2] denotes the set of two element lists the first element of which is 1 and the second of which is 2, then [X,Y] = [1,2] is just set intersection (with the relevant variable bindings happening)
23:06:26 <ski> kmc : the equation `[x,y] = [1,2]' in variables `x' and `y' has solution `x = 1 /\ y = 2'
23:06:28 <JoeyA> it doesn't need ordering at all.
23:06:49 <thezboe> I have to return an ordered set tho
23:06:50 <JoeyA> It just takes the list, gets the first item, and removes that item from the rest.
23:06:56 <JoeyA> oh
23:07:10 <JoeyA> Ordered, as in, sorted?
23:07:11 <augur> kmc, ski: so on that view, you can imagine that [X,Y] = ~[1,2] where ~ is the set-complement, so that [X,Y] = ~[1,2] in exactly those cases when [X,Y] is _not_ [1,2]
23:07:15 <JoeyA> Or stable?
23:07:15 <thezboe> si
23:07:20 <ski> augur : i prefer to view `[x,y]' as a (possibly "variable") list, not as a set
23:07:35 <augur> sure, but the crucial bit here is the set-like operators :P
23:07:46 <augur> think of it as you like.
23:07:57 <JoeyA> > foldr (\x xs -> x : filter (/= x) xs) [] [1,2,3,1,4,2,5] -- anyway, there's my solution.  I hope you're happy.
23:07:58 <lambdabot>   [1,2,3,4,5]
23:08:06 <kmc> augur, were you here when co_dh asked about relational programming?
23:08:10 <kmc> i mentioned SQL and Alloy
23:08:14 <kmc> both of which i think are relevant here too
23:08:21 <augur> the point is that [x,y] = ~[1,2] should unify iff [x,y] = [1,2] fails
23:08:24 <kmc> relational programming is a generalization of programming with sets
23:08:25 <JoeyA> > foldr (\x xs -> x : filter (/= x) xs) [] [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:08:26 <lambdabot>   [5,1,9,3,7,8,2,4,0,6]
23:08:29 <kmc> (relations being sets of tuples)
23:08:39 <JoeyA> It doesn't sort, it's just stable and left-biased.
23:09:07 <augur> ski: obviously, if [x,y] = ~[x,y] then [x,y] = [~1,2] | [1,~2] | [~1,~2]
23:09:08 <JoeyA> but, other than using nub (which is implemented pretty much exactly like this), this is as simple as it gets.
23:09:16 <augur> er, if [x,y] = ~[1,2]
23:09:45 * ski wonders where this `~' came from ?
23:09:52 <JoeyA> thezboe: but please do take a moment to reflect on why this works :-)
23:09:54 <augur> ski: its a negation symbol in logic!
23:09:55 <ski> what is the context of talking about unification ?
23:10:07 <ski> augur : yeah, but you're not applying it to a proposition !
23:10:24 <augur> so? deal with it. :|
23:10:57 <thezboe> you're taking each element of a list and cons'ing it with another list, but making sure that there is nothing in that list that equal the element you're cons'ing
23:11:12 * ski first thought we were explaining unification to someone .. but that appears to not be the case
23:11:17 <augur> anyway, so [x,y] = ~[1,2] if either x = ~1 & y = 1, or x = 1 & y = ~2, or x = ~1 & y = ~2
23:11:27 <augur> ski: this makes sense, right?
23:11:30 <JoeyA> right, but the xs in my lambda is rather interesting.
23:11:50 <JoeyA> @let makeSets [] = []; makeSets (x:xs) = x : filter (/= x) xs
23:11:51 <lambdabot>  Defined.
23:11:58 <JoeyA> > makeSets [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:11:59 <lambdabot>   [5,1,9,3,7,1,8,2,4,8,0,1,2,4,3,6,7,8,4]
23:11:59 <ski> augur : i'm not sure
23:12:03 <augur> ski :|
23:12:13 <JoeyA> exactly the same as:
23:12:16 <augur> ski: ok, do you understand this: 1 = ~2
23:12:19 <kmc> ski, i joined at <augur> anyone know anything about unification of "logical" objects?
23:12:25 <ski> certainly `~ ([x,y] = [1,2])' makes sense
23:12:34 <JoeyA> > foldr (\x xs -> x : filter (/= x) xs) []  [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:12:35 <lambdabot>   [5,1,9,3,7,8,2,4,0,6]
23:12:38 <JoeyA> hmm
23:12:42 <JoeyA> except they give different results.
23:12:47 <augur> ski, dont think of ~ as boolean negation. think of it as object negation
23:12:47 <kmc> in «1 = ~2» you are using 2 to stand for {2} yes?
23:12:51 <thezboe> hehe exactly the same, but not =P
23:12:53 <kmc> and ~ to stand for set complement
23:12:59 <JoeyA> @undefine makeSets
23:12:59 <augur> ~1 means "an object which is not 1"
23:13:08 <JoeyA> @let makeSets [] = []; makeSets (x:xs) = x : filter (/= x) xs
23:13:09 <lambdabot>  Defined.
23:13:13 <JoeyA> > makeSets [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:13:14 <lambdabot>   [5,1,9,3,7,1,8,2,4,8,0,1,2,4,3,6,7,8,4]
23:13:17 <ski> augur : i suspect that to make that `~' operation applied to aribtrary terms make sense, you have to introduce side-effects into the language
23:13:36 <augur> ski: i dont know. i dont see why.
23:13:36 <magicman> JoeyA: I think you want makeSets to be recursive.
23:13:37 <JoeyA> I think the computer is wrong.
23:13:38 <thezboe> you don't recurse
23:13:46 <JoeyA> oh, right
23:13:51 <thezboe> @undefine makeSets
23:14:20 <JoeyA> @let makeSets [] = []; makeSets (x:xs) = x : filter (/= x) (makeSets xs)
23:14:20 <ski> augur : at least, i think that's the case for your `1 | 2' operation
23:14:21 <lambdabot>  Defined.
23:14:25 <thezboe> @let makeSets [] = []; makeSets (x:xs) = x : filter (/= x) (makeSets xs)
23:14:26 <lambdabot>   Illegal character ''\FS''
23:14:26 <JoeyA>  > makeSets [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:14:33 <Axman6> @undefine undefined anything defined with @let, not just the thing you well it to undefine
23:14:38 <augur> ski: well, 1|2 is supposed to be "an object which is either 1 or 2"
23:14:38 <Axman6> @let foo = "hello"
23:14:39 <lambdabot>  Defined.
23:14:43 <ski> augur : consider `let x = (1 | 2) in x * x' .. what does this evaluate to ?
23:14:44 <Axman6> @let bar = "world"
23:14:45 <lambdabot>  Defined.
23:14:48 <Axman6> @undefine foo
23:14:50 <augur> so it will unify with either 1 or with 2
23:14:52 <Axman6> > bar
23:14:52 <lambdabot>   Not in scope: `bar'
23:14:55 <augur> ski: it evaluates to 1 | 4
23:14:56 <ski> er, sorry s/*/+/
23:15:05 <ski> (otherwise, it's a bad example)
23:15:07 <augur> if its +, it evals to 2 | 4
23:15:38 <ski> yeah, but with substitution `let x = (1 | 2) in x + x' is equal to `(1 | 2) + (1 | 2)' ..
23:15:42 <JoeyA> thezboe: right.  Notice how the lambda given to foldr doesn't explicitly recurse.
23:16:02 <augur> ski: im not working with haskell, so substitution like that doesn't work :P
23:16:07 <JoeyA> > foldr (\x xs -> x : filter (/= x) xs) [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:16:08 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
23:16:08 <lambdabot>    arising from a use ...
23:16:11 <ski> (which yields `2 | 3 | 3 | 4' (which is `2 | 3 | 4' if you're having sets, as opposed to bags))
23:16:18 <JoeyA> > foldr (\x xs -> x : filter (/= x) xs) [] [5,1,9,3,7,1,8,2,4,8,0,1,2,5,4,3,6,7,8,4]
23:16:19 <lambdabot>   [5,1,9,3,7,8,2,4,0,6]
23:16:20 <thezboe> right, just from the nature of foldr it will go over all elements
23:16:27 <ski> augur : yeah, and that is a sign that you have side-effects
23:16:32 <JoeyA> right, but foldr is even more general than that
23:16:38 <ski> (that that substitution doesn't work, i.e.)
23:16:39 <JoeyA> makeSets [] = []
23:16:47 <JoeyA> that accounts for the empty list given to the foldr here
23:17:11 <augur> i mean, if you want to force substitution, then you just think of it like this: `let x = (1|2) in x + x' -> (\x -> x + x) (1 | 2) -> ((\x -> x + x) 1) | ((\x -> x + x) 2) -> (1 + 1) | (2 + 2) -> 2 | 4
23:17:59 <ski> this is completely similar to `let x = printAndSquare 2 in x + x' either printing `2' once or twice, with `printAndSquare' being a side-effectful I/O operation
23:18:03 <augur> but we're not talking about a system with lambdas, etc. just one with unification of the normal sort where something like [1,x] = [y,2] yields [1,2] given x = 2, y = 1
23:18:09 <ski> s/similar/analogous/
23:18:29 <augur> there are no sideeffects here, ski
23:18:51 <ski> augur : i'm claiming the failure of the subsitution above is evidence of side-effects
23:19:00 <augur> i just gave you the proper substitution for it, ski
23:19:05 <ski> (nondeterminism side-effects, to be clear)
23:19:05 <augur> i dont know why this is still an issue
23:19:48 <JoeyA> Well, good night
23:19:50 <ski> it doesn't have to be an issue
23:19:53 <augur> ok then
23:20:08 <ski> it's just good to be aware when you're introducing side-effects
23:20:18 * JoeyA goes to bed pondering foldr
23:20:33 <ski> (because they invalidate modes of reasoning which one might be tempted to apply, if one doesn't think things through)
23:20:58 <augur> ski: another example is something like this: [x,x] = [1|2,2] yields [2,2] given x = 2, while [x,x] = [1|2,1] yields [1,1] given x = 1
23:21:14 <thezboe> haha
23:21:42 <thezboe> well thanks a bunch JoeyA and caelan
23:21:52 <ski> (the substitution rule that was invalidated was the rule claiming that `let x = e0 in e1' is equivalent to `e1 [x |-> e0]')
23:22:07 <augur> yes. anyway
23:22:13 <augur> can we move on to the issue at hand?
23:22:23 <augur> the langauge in question doesnt have lambdas or lets, so thats not an issue.
23:23:00 <augur> unless you have some abstract notion of lets that makes [x,x] = [1|2,1] a kind of let, like `let x = 1|2 in x = 1'
23:23:12 * thezboe says hi
23:23:22 * thezboe is just wondering if this /me thing works
23:23:48 <ski> yeah, you can encode `let x = e in g' as `exists x. x = e /\ g' or as `forall x. x = e => g'
23:24:10 <ski> thezboe : it does
23:24:19 <thezboe> heh, thanks ski
23:24:22 <augur> ski: in which case we know how to solve that issue. so we can go beyond it
23:24:30 <ski> augur : anyway, those `[x,x] = [1|2,2]' and `[x,x] = [1|2,1]' are interesting
23:24:44 <augur> why
23:25:25 * Nereid just got in
23:25:30 <ski> (however, whether you encode `let' in terms of the former or the latter can make a difference, if you have side-effects .. i'm still not clear on the details of this)
23:25:30 <Nereid> what's this strange | notation about?
23:25:47 <augur> ski, why is there a question about side effects
23:26:05 <ski> Nereid : `e0 | e1' is an expression that is ambiguously either `e0' or `e1'
23:26:23 <Nereid> ok
23:26:32 <Nereid> so [e0, e1]?
23:26:37 <ski> no
23:26:37 <augur> and e0 & e1 is a sentence that is both e0 and e1
23:26:51 <augur> well, an expression, sorry
23:27:00 <Nereid> so what's 1 & 2 ?
23:27:04 <augur> nothing.
23:27:12 <augur> there is nothing that is both 1 and 2
23:27:21 <Nereid> show me something that is two different things
23:27:31 <Axman6> even | prime
23:27:33 <Axman6> >_>
23:27:53 * ski suspects augur is coming to this from coordination in natural language :)
23:27:57 <augur> but lets imagine that ... is kind of like haskell's _, but for multiple objects, then [1,...] is any list beginning with 1, and [...,2] is any list ending with 2
23:28:09 <augur> so [1,...]&[...,2] is any list beginning with 1 and ending with 2
23:28:12 <Nereid> oh I see.
23:28:13 <augur> aka [1,...,2]
23:28:20 <Nereid> so you get stuff like (a | b) & a = a
23:28:29 <augur> or if you want any list with a 1 and a 2, in any order: [...,1,...]&[...,2,...]
23:28:36 <augur> ski: no, this has nothing to do with natural language coordination
23:28:54 <augur> its just an attempt to make a unifier work nicely
23:29:07 <ski> ok
23:29:24 <augur> ski: for example, if i want to say something like "a set with 1 in it" thats trivial: {1,...}
23:29:31 * ski has pondered something similar to this, after reading a little about coordination
23:29:34 <augur> but what if i want to say "a set without 1 in it"?
23:29:41 <augur> ~{1,...}
23:30:02 <ski> augur : btw, if you haven't already seen it, you should check out conal's `unamb' and `lub' and `glb' operations
23:30:10 <augur> or what if i wanted to say that the set's elements must all be binary lists?
23:30:19 <augur> {[_,_],...} is a set with _a_ binary list
23:30:34 <augur> so {~[_,_],...} is a set with something that isnt a binary list
23:30:44 <augur> so ~{~[_,_],...} is a set with all binary lists
23:31:21 <Nereid> ski: that's not quite the same
23:31:28 <augur> which isnt something a normal unifier lets you do. you'd have to do some sort of propositional stuff like in prolog
23:31:44 <ski> Nereid : which ?
23:31:53 <Nereid> unamb and friends
23:32:00 <ski> augur : <http://hackage.haskell.org/packages/archive/lub/0.1.2/doc/html/src/Data-Lub.html> has some examples
23:32:10 <ski> Nereid : possibly not, but there appears to be some similarity
23:32:17 <augur> ski: i dont even know what that is
23:33:12 <ski> er, actually that's the wrong link
23:33:28 <Nereid> augur: read about denotational semantics I guess. lub and glb refer to the partial ordering of "definedness"
23:33:52 <augur> probably wont help me :p
23:33:59 <Nereid> so stuff like
23:34:20 <ski> <http://hackage.haskell.org/packages/archive/lub/0.1.2/doc/html/src/Data-Laxer.html>
23:34:22 <Nereid> bottom <= 1:bottom <= 1:[]
23:34:55 <augur> ski: how did natlang coordination inspire you in this direction?
23:35:06 <ski> see the `t5' example .. that appears to be a bit similar to your `[2,3,5] & [1,3]'
23:38:22 <augur> mreh?
23:38:28 <ski> augur : to a first, very vague approximation, constructions like `Alyssa likes chocolate and blueberry.' appears to have a structure like `likes alyssa (chocolate & blueberry)', which would reduce to `(likes alyssa chocolate) /\ (likes alyssa blueberry)'
23:38:42 <augur> oh
23:38:56 <Nereid> augur: so you're talking about sets of values then. with | being union, & being intersection, and ~ being complement
23:38:56 <augur> yes, a very old idea about how conjunction in sentences works :)
23:38:59 * ski waits for augur to exclaim that this is an erroneous understanding of nat.lang.
23:38:59 <Nereid> ?
23:39:10 <Nereid> natural languages are weird
23:39:14 <augur> Nereid: that was the intention, and is how i started my explanation, but then kmc choked on that :P
23:39:40 <Nereid> a set of values of type a is the same as a function a -> Bool
23:39:42 <augur> ski: well, its _probably_ erroneous, just because of examples where it simply cant be how it works, at least not trivially
23:39:58 <Nereid> (ignoring bottom and stuff)
23:39:59 <augur> ski: consider the sentence "John and Frank saw each other"
23:40:12 <ski> yes, that's another thing, i agree
23:40:35 <kmc> opinions on monads-fd vs. monads-tf
23:40:47 <Nereid> although it's hard to get members out of a function a -> Bool I guess.
23:40:49 <ski> (to my mind, that is a statement of a property about a set of individuals)
23:40:53 <augur> ski: and if you want to say that "and" has a single meaning inside noun phrases, ...
23:40:55 <kmc> augur, i choked on nothing, i deciphered your notation in that way
23:41:07 <ski> augur : well, i don't :)
23:41:13 <kmc> <kmc> in «1 = ~2» you are using 2 to stand for {2} yes?
23:41:13 <kmc> <kmc> and ~ to stand for set complement
23:41:16 <kmc> waay up there
23:41:19 <jamy> hello world!
23:41:40 <Nereid> augur: so what's the point of such a thing
23:42:08 <augur> kmc: yes, that was after i explicitly said that and then had to refer you BACK to when i said that :P
23:42:14 <augur> Nereid: which thing now?
23:42:28 <Nereid> augur: what we've been talking about
23:42:32 <augur> ski: well, lots of people do! since there doesn't seem to be any situation where the two are distinguished
23:43:21 <augur> Nereid: oh, well, im writing a meta-system for logics. a language where you can define your own logics using wonderful pattern matching stuff, and it makes heavy use of pattern matching via unification
23:43:48 <Nereid> I don't understadn
23:43:49 <kmc> any opinions on monads-tf vs. monads-fd?
23:43:50 <Nereid> understand*
23:43:58 <augur> Nereid: in what way
23:44:19 <Nereid> any of it
23:44:46 <augur> Nereid: surely you understand what a language is, and when defining is, and what pattern matching is, and what unification is
23:44:52 <ski> augur : re `let' and side-effects : considering `let x = 0 | 1 in y = x + x' interpreted respectively as (a) `exists x. x = 0 | 1 /\ y = x + x'; or as (b) `forall x. x = 0 | 1 => y = x + x'. interpreting `x = (0 | 1)' as `(x = 0) \/ (x = 1)'
23:44:57 <Nereid> what do you mean by unification
23:45:00 <ski> augur : in both cases here, (a) becomes `y = 0 \/ y = 2' while (b) becomes `y = 0 /\ y = 2' .. which are very different
23:45:01 <augur> ..
23:45:02 <augur> ok nevermind.
23:45:51 <augur> ski: thats nice. only the former is the correct case.
23:46:04 <ski> yeah .. but why ?
23:46:17 <augur> because thats what i defined it to be in this system!
23:46:32 <ski> with no side-effects, both are valid .. why should one be preferred over the other ?
23:46:37 <ski> hehe
23:46:40 <augur> because i said so
23:46:46 <Nereid> what's the use of y = 0 /\ y = 2
23:46:54 <augur> nereid, we went over that already
23:47:02 <augur> y = [1,...] /\ y = [...,2]
23:47:10 <Nereid> so (b) is undesirable in that example.
23:47:14 <Nereid> 1 is not [1,...]
23:47:18 <augur> i didnt say it was
23:47:20 <ski> Nereid : no direct use. just an example consequence of interpreting an expression in a certain way
23:47:27 <augur> but its an example of why /\ is useful
23:47:27 <augur> anyway
23:48:03 <augur> ski, [x,x] = [1|2,1] succeeds, because there is _some_ way that x can be assigned a determinate value according to the structure in question
23:48:09 <ski> btw, another reason for pondering these `|' and `&' operations is that they are useful in patterns
23:48:33 <ski> (`&' being written `@' in Haskell, and being restricted so that the left-hand-side has to be a variable)
23:49:30 <ski> augur : yes, that's the goal
23:49:42 <augur> ski: the real issue is how variables under negation work. because theres a way to implement it such that [x,~x] = [1,1] fails but [~x,x] = [1,1] succeeds
23:49:48 <augur> and another way to implement it where both fail
23:50:07 <ski> augur : yes, familiar from negation-as-failure in Prolog :)
23:50:17 <augur> so one way of doing it is like this:
23:50:25 <augur> use standard substitution unification algorithms
23:50:51 <augur> such that like.. [x,x] = [1,1] unifies x = 1, and reduces to [1] = [1] after substitution
23:51:05 <Nereid> well excuse me if I don't know anything about prolog
23:51:09 <Nereid> :P
23:51:09 <ski> er .. why the reduction ?
23:51:15 <augur> in which cause, [x,~x] = [1,1] unifies x = 1, and reduces to [~1] = [1]
23:51:28 <augur> ski: well, how else could you do that
23:51:32 <ski> Nereid : negation-as-failure, as implemented in Prolog, is a mistake
23:51:49 <Nereid> no, I seriously don't know anything about prolog.
23:51:52 <ski> augur : i thought `[x,x]' would be a list with two elements
23:51:59 <Nereid> other than it's "logic programming" and you see :- everywhere
23:52:04 <augur> ski, sure, but if lists are cons pairs, say
23:52:06 <ski> Nereid : you might want to learn it :)
23:52:12 <Nereid> nah, not interested
23:52:48 <augur> then unify x:xs y:ys theta => let theta2 = unify x y theta in unify (sub theta2 xs) (sub theta2 ys) theta2
23:53:30 <Nereid> I'm a math student anyway.
23:54:01 <augur> ski: thats one option, in which case   unify [x,x] [1,1] t   reduces to unify [1] [1] t'
23:54:18 <Nereid> haskell gives a nice different perspective on certain parts of category theory
23:54:38 <ski> well, logic programming is the "other" common connection between logic and computation (the "first" one here being the Curry-Howard correspondence : propositions-as-types & proofs-as-programs)
23:54:39 <augur> and similarly then,   unify [x,~x] [1,1] t   =>   unify [~1] [1] t2   => {}
23:55:03 <augur> ski: but on the other hand:   unify [~x,x] [1,1] t   =>   unify [x] [1] t2
23:55:07 <Nereid> well I have little interest in logic
23:55:10 <augur> =>  { x: 1 }
23:55:19 <ski> for that reason, and for the reason that logic programming is the "other" declarative programming paradigm, i think it is good to know about
23:55:44 <ski> Nereid : your choice, of course
23:55:59 <augur> ski: on the assuming that unification of negations works like so:   unify ~x y theta = if empty (unify x y) then theta else {} end
23:56:06 <augur> on the assumption**
23:56:32 <kamatsu> way to make cabal just give me raw object files rather than object files with qualified names for libraries?
23:57:01 <kamatsu> i'm trying to use hs-plugins and cabal does not cooperate
23:57:22 <Nereid> the thing about haskell is that various things in it map to familiar things in math
23:57:38 <augur> ski: if x is a variable term, then unification will always succeed, and so ~x = anything will fail
23:57:50 <Nereid> types being objects in an appropriate category, etc
23:57:50 <ski> augur : yeah, that latter is negation-as-failure
23:58:14 <augur> on the other hand, we could say that if x is a variable term unify ~x y t = t + {{ x: ~y }}
23:58:50 <augur> in which case we get the following:   unify [~x,x] [1,1] t   =>   unify [~1] [1] t2 => {}
23:59:11 <augur> thats just with substitution unification, which is kind of standard
23:59:20 <ski> Nereid : definitions of relations, and equation solution is related to how one thinks in logic programming
23:59:30 <Nereid> yeah I get that
23:59:32 <ski> s/solution/solving/
23:59:33 <Nereid> I just don't care
