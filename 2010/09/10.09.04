00:13:00 <ashley_s> I get the error "Not in scope: type constructor or class `PlaySoundEvent'", for the second reference to 'PlaySoundEvent' in the following code: data Event a = DestroyEvent { object :: a } | PlaySoundEvent { name :: String }; processGameEvents :: [Event Position] -> [PlaySoundEvent]
00:13:41 <Axman6> PlaySoundEvent is a consteructor, not a type. you need Event a
00:14:49 <ashley_s> Axman6: So I need 'Event a' even though PlaySoundEvent does not need an 'a' in its constructor
00:14:56 <Axman6> yes
00:15:59 <ashley_s> Thank you.
00:17:31 <ashley_s> With my previous code, is there a way to filter a list of Events based on their constructor?
00:19:36 <kmc> filter (\e -> case e of PlaySoundEvent{} -> True; _ -> False)
00:19:46 <kmc> or you can spin that off to its own function
00:19:51 <kmc> isPSE PlaySoundEvent{} = True
00:19:55 <kmc> isPSE _ = False
00:20:06 <kmc> it's a little ugly but so it goes
00:21:38 <ashley_s> kmc: Thank you, the isPSE makes me thing that I am probably thinking about the code incorrectly.
00:27:12 <kmc> instead of filtering, why not map something that has a case for each event type
00:27:18 <kmc> (which can include a catch-all do-nothing case)
00:27:34 <kmc> handle FooEvent{ bar=x } = ...
00:27:39 <kmc> handle BazEvent{} = ...
00:37:34 <ski> ashley_s : `[e | e @ PlaySoundEvent {} <- es]' is another way to filter `es'
00:38:15 <ashley_s> ski: Could you explain what it does? (I am a noob)
00:38:41 <kmc> oh, clever
00:38:51 <kmc> ashley_s, do you know list comprehensions in general?
00:39:04 <kmc> > [ 5 * n | n <- [1..10], even n ]
00:39:05 <lambdabot>   [10,20,30,40,50]
00:39:35 <ashley_s> I've heard of it, but never used it.
00:39:39 <kmc> ok
00:39:42 <kmc> you can read up on those
00:40:01 <kmc> then there's two more pieces:
00:40:05 <mwc> ashley_s: e @ .. is a pattern alias, it matches whatever's to the right of the @ and binds it to e
00:40:22 <kmc> a) the pattern v@p matches anything that the pattern p would match, but also binds the variable 'v' to the whole thing matched
00:40:35 <kmc> b) when a pattern match fails in a list comprehension, that element is dropped
00:40:45 <ski> > let foo xs0@(x:xs) = (xs0,x,xs) in foo [0,1,2,3]
00:40:46 <lambdabot>   ([0,1,2,3],0,[1,2,3])
00:41:22 <ski> ashley_s : that's an example of an `as'-pattern, here in a function argument pattern
00:42:11 <ski> `xs0' is the name of the whole list which is passed, while the list is also matched against `x:xs', which causes `x' to be bound to the first element, and `xs' to the list of the rest of the elements
00:42:27 <ski> ashley_s : one of the simplest examples of list comprehensions are :
00:42:43 <ski> > [n * n | n <- [0,1,2,3,4,5]]
00:42:44 <lambdabot>   [0,1,4,9,16,25]
00:43:26 <ski> this reads : "compute the list of elements of the form `n * n', for each `n' which is an element of `[0,1,2,3,4,5]'"
00:43:45 <ashley_s> ski: That's starting to make sense, what does the '<-' mean? what is is called? I assume its a typing of binding
00:44:10 <ski> yeah, `<-' is meant to resemble the "is element of" relation in mathematics
00:44:16 <kmc> it's part of the syntax of list comprehensions
00:44:19 <kmc> i usually read it as "from"
00:44:30 <kmc> "n times n where n from [0,1,2,3,4,5]"
00:44:38 <ski> the whole list comprehension syntax is modeled on what is called set comprehensions in mathematics (sometimes called "set builder" as well)
00:44:47 <kmc> "five times n where n from [1..10] and n is even"
00:45:33 <ski> ashley_s : now, instead of just doing something to every element of the list, you can also test each element to determine if you want to keep the corresponding result or not
00:45:34 <ashley_s> I like the 'is element of' meaning for the '<-'. That makes a lot of sense to me
00:45:41 <ski> > [n * n | n <- [0,1,2,3,4,5] , odd n]
00:45:42 <lambdabot>   [1,9,25]
00:46:06 <ski> this reads : "compute the list of elements of the form `n * n', for each `n' which is an element of `[0,1,2,3,4,5]', such that `n' is odd"
00:46:23 <ski> that's how you usually filter things using list comprehensions
00:46:45 <ashley_s> How would you have two 'such that' statements?
00:46:52 <ski> one way is to have
00:47:36 <ski> > [ [ (x,y,x^y) | x <- [0,1,2,3] ] | y <- [0,1,2,3] ]
00:47:37 <lambdabot>   [[(0,0,1),(1,0,1),(2,0,1),(3,0,1)],[(0,1,0),(1,1,1),(2,1,2),(3,1,3)],[(0,2,...
00:47:49 <ski> > [ [ x^y | x <- [0,1,2,3] ] | y <- [0,1,2,3] ]
00:47:50 <lambdabot>   [[1,1,1,1],[0,1,2,3],[0,1,4,9],[0,1,8,27]]
00:48:15 <ski> that's simply a list comprehension where the elements which we collect into the result are also list comprehensions
00:48:29 <ski> this gives a list of lists
00:48:35 <ski> btw, note that one can also do things like
00:48:43 <ski> > [ [ x^y | x <- [0 .. y] ] | y <- [0,1,2,3] ]
00:48:44 <lambdabot>   [[1],[0,1],[0,1,4],[0,1,8,27]]
00:49:09 <ski> which means that the "inner" list comprehension depends on the value `y' chosen in each step by the outer list comprehension
00:49:13 <ski> .. however
00:49:37 <ski> usually (not always), what you really want in this case is to get a list of elements, not a list of list of elements
00:49:47 <ski> and you can do that as well, like
00:50:12 <ski> > [ x^y | y <- [0,1,2,3] , x <- [0,1,2,3] ]
00:50:13 <lambdabot>   [1,1,1,1,0,1,2,3,0,1,4,9,0,1,8,27]
00:50:14 <kmc> > [ (a,x) | a <- "abc", x <- "xyz" ]
00:50:15 <lambdabot>   [('a','x'),('a','y'),('a','z'),('b','x'),('b','y'),('b','z'),('c','x'),('c'...
00:50:16 <ski> > [ x^y | y <- [0,1,2,3] , x <- [0 .. y] ]
00:50:17 <lambdabot>   [1,0,1,0,1,4,0,1,8,27]
00:50:18 <kmc> > [ (a,x) | a <- "abc" | x <- "xyz" ]
00:50:19 <lambdabot>   [('a','x'),('b','y'),('c','z')]
00:50:25 <ski> ashley_s : was that clear ?
00:50:33 <kmc> sorry for stepping on your example ski
00:50:41 <ski> (no worry)
00:50:53 <ashley_s> ski: That is clear and very helpful. I am just trying to absorb it
00:51:04 <kmc> ashley_s, note the two ways of combining two generators; in one case the lists are traversed together, in lockstep; in the other case all possible pairs are used
00:51:29 <kmc> the former is actually a GHC extension
00:51:50 <ski> ashley_s : note that in each of those two latest examples i gave. because we have several "generators" `... <- ...' in the list comprehension, we must decide in what order to draw elements `y' and `x' from the list
00:51:55 <ashley_s> kmc: Thats a bit advanced for me. I think I have a vague understanding of that but its going to be a while till I completely understand it.
00:52:10 <kmc> > [ (a,x) | a <- "abc" | x <- "xyz" ]  -- lockstep
00:52:11 <lambdabot>   [('a','x'),('b','y'),('c','z')]
00:52:14 <kmc> > [ (a,x) | a <- "abc", x <- "xyz" ] -- all pairs
00:52:15 <lambdabot>   [('a','x'),('a','y'),('a','z'),('b','x'),('b','y'),('b','z'),('c','x'),('c'...
00:52:17 <ski> ashley_s : and the order that is done is from left-to-right .. first a value of `y' is chosen (the first in the list), then a value of `x' is chosen
00:52:28 <ski> ashley_s : and that computes a result `x^y'
00:52:41 <FunctorSalad_> @let splitAts xs = [ splitAt n xs | n <- [1..length xs] ]
00:52:42 <lambdabot>  Defined.
00:52:47 <FunctorSalad_> is there a  better way to do this?
00:53:09 <FunctorSalad_> (only one pass... maybe I should *gasp* do explicit recursion)
00:53:34 <ski> ashley_s : then the next value of *`x'* is chosen, computing more values for the result .. until there is no more value for `x' to get .. *only* then does it draw the next value for `y' (and then it starts over drawing elements for `x' from the start again)
00:53:51 <ashley_s> ski: yep that makes sense
00:54:16 <ashley_s> ski: so what is called when you have two generators divided by a comma instead of a pipe?
00:55:08 <ski> ashley_s : the normal way is to separate them with a comma. and then what this accomplishes or, more or less, a cartesian product of the two (or more) lists that elements are drawn from
00:56:00 <ski> ashley_s : separating them with a pipe is an extension to Haskell .. and is not used as commonly (it is called "parallel list comprehension", since you draw elements from the lists in "paralell" instead of trying each combination)
00:56:30 <ski> ashley_s : btw, to be fully correct, only the following is a proper cartesian product :
00:56:48 <ski> > [(x,y) | x <- [0,1,2] , y <- [10,20]]
00:56:49 <lambdabot>   [(0,10),(0,20),(1,10),(1,20),(2,10),(2,20)]
00:57:30 <ski> however, i suppose one could be a bit loose with the terminology, and also call the following "cartesian product"
00:57:40 <ski> > [x ^ y | x <- [0,1,2] , y <- [10,20]]
00:57:41 <lambdabot>   [0,0,1,1,1024,1048576]
00:57:50 <ski> > [(x,y) | x <- [0,1,2] , y <- [10 .. 10+x]]
00:57:51 <lambdabot>   [(0,10),(1,10),(1,11),(2,10),(2,11),(2,12)]
00:58:56 <ski> in the first case, that is not what's usually termed "cartesian product" because instead of just tupling (pairing, here) the elements of the list together, we compute anything based on them
00:59:26 <ashley_s> Wow, that last line is quite confusing
00:59:31 <ashley_s> I think I get it
00:59:57 <ashley_s> So the 'y' list expands, as the value of x goes up
01:00:14 <ski> in the second case, that is not what's usually termed "cartesian product" because instead of just tupling together all combinations of elements from two *pre-specified* lists, it combines elements from one list together with elements from another list which *depends* on the particular value chosen from the first list
01:00:19 <ski> yes
01:00:27 <kmc> ashley_s, yes.  for each x, you have a fresh list y, defined in terms of x
01:00:45 <kmc> if you're familiar with nested loops, x is the outer loop here, and y the inner
01:01:16 <ashley_s> kmc: yes of course. It is just a very different way of having nested loops.
01:01:25 <kmc> yeah
01:01:33 <kmc> because lists are both data structures and control-flow structures
01:01:51 <ski> it can be pretty handy to use list comprehensions
01:02:03 <ashley_s> ski: So because the lists change within the cartesian product operation, its not mathematically a cartesian product
01:02:26 <kmc> due to laziness, there's not much difference between iterating through some things to do, versus producing and consuming a list of things to do
01:02:32 <ski> yeah, i wouldn't call it a "cartesian product" .. but it's near that concept
01:03:27 <ashley_s> Thanks kmc & ski for helping me out. I am going to go back and write some Haskell code.
01:03:38 <kmc> excellent :)
01:04:19 <Nibble> http://farm1.static.flickr.com/29/100276794_548c83c4eb.jpg
01:05:05 <ski> ashley_s : if you want, you could try writing a function `select :: [a] -> [(a,[a])]' that given list, gives a list containing all ways of "lifting out" one element from the list .. i.e. in each pair, the first part is the element that was removed from the list, and the second part is the rest of that list
01:05:11 <ski> e.g.
01:05:42 <ski>   select "abcd"  =  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
01:06:00 <ski> ashley_s : well, you could try to write that, using list comprehensions, i mean
01:06:19 <Nibble> list comprehension, I haven't seen many people using that lately
01:06:22 <Nibble> just in some tuts
01:07:27 <SubStack> useful if you have a lot of points
01:10:36 <ivanm> Nibble: list comprehension can't be chained with . , etc. so it's less popular
01:10:50 <ivanm> but there are some times it leads to cleaner code rather than repeated maps, filters, etc.
01:21:10 <ivanm> I'm trying to adapt this example for my needs: http://www.haskell.org/haskellwiki/Template_haskell/Instance_deriving_example
01:21:54 <ivanm> in the "[(mkName "render", gen_render)]" bit, is there any way I can have genRender just be the equivalent of using a qualified version of the function?
01:22:13 <ivanm> i.e. I want to generate instances of the form "foo = A.foo" for all specified class methods
01:43:22 <chrisdone> ciao
01:44:49 <ivanm> g'day
01:44:51 <Martty> hola
01:45:09 <Martty> nothing like waking up 5 am for 6 hrs of chem on a saturday :')
01:45:19 <Adamant> ouch
01:45:58 <ivanm> well, chrisdone was here long...
01:46:36 <ivanm> chrisdone: didn't you like us greeting you back?
01:46:37 <Taejo> http://haskellvineyards.com/
01:46:54 <ivanm> Taejo: I don't see any lambdas there...
01:47:15 * ivanm goes off to order dinner from the take-away part of the turkish restaraunt downstairs
02:17:55 <FunctorSalad_> I have a list of n items to distribute (in order) over L lines... each item has a weight, and I can reasonably abbreviate multiple neighboring items on one line, or stretch a single item over multiple lines (but no combination of these two)
02:18:27 <ski> (pretty-printing ?)
02:18:45 <FunctorSalad_> I formulated the problem to be solved as minimize sum_{l : line} ( density(l) - perfectDensity ) ^ 2
02:19:06 <FunctorSalad_> ski: yeah, I'm trying to make an efficient terminal menu for a collection too large to fit on the screen :)
02:19:36 <FunctorSalad_> the "items" are subtries of the trie of items, one subtrie for each initial character the user could type, FWIW
02:19:59 <FunctorSalad_> does this look efficiently solvable? :o
02:20:14 <FunctorSalad_> perfectDensity = sum weights / #lines
02:21:11 <FunctorSalad_> this could be useful to pick a module from the list of all haskell modules, for example
02:21:35 <FunctorSalad_> currently, the weight is simply the number of items in the subtrie
02:22:36 <FunctorSalad_> trying to use Cale's aStar now :) but not sure if my heuristic is so great
02:22:55 <FunctorSalad_> (assume perfect distribution of the remaining menu items over the remaining lines)
02:23:14 <FunctorSalad_> as the heuristic for calculating a lower bound that's used by astar
02:25:24 <FunctorSalad_> but maybe I should actually test it ;)
02:28:33 <pantsd_home> Cale: Thanks for your help, I got hsemail working with new parsec now :)
03:23:18 <ivanm> anyone here able to help me work out how to do something with TH?
03:24:19 <Entroacceptor> !ask
03:24:25 <Entroacceptor> er, whatever
03:24:41 <FunctorSalad_> will 'trace = const id' completely eliminate any overhead?
03:24:59 <FunctorSalad_> (of trace statements left in the code... assuming compilation with -O2)
03:25:04 <ivanm> FunctorSalad_: hmmm.... it will if you then have a "const id" RULE ;-)
03:25:11 <ivanm> I'm trying to adapt this example for my needs: http://www.haskell.org/haskellwiki/Template_haskell/Instance_deriving_example
03:25:16 <ivanm> in the "[(mkName "render", gen_render)]" bit, is there any way I can have genRender just be the equivalent of using a qualified version of the function?
03:25:20 <FunctorSalad_> ivanm: thought inlining is enough
03:25:22 <ivanm> i.e. I want to generate instances of the form "foo = A.foo" for all specified class methods
03:25:31 <ivanm> FunctorSalad_: just to be sure... ;-)
03:25:53 <FunctorSalad_> yes, though to be totally sure one could use the CPP :o
03:26:15 <ivanm> bah, that's too much overhead
03:26:22 <ivanm> (at compile-time)
03:27:03 <FunctorSalad_> :)
03:27:10 <FunctorSalad_> (and at code-read-time...)
03:27:11 <ryzal> hello
03:27:19 <FunctorSalad_> at least if you do it with #ifdefs at every trace
03:27:29 <FunctorSalad_> one could instead make trace a macro...
03:27:32 <ivanm> greetings ryzal 
03:34:05 <WMOBILE> hello
03:34:54 <ivanm> that was... random....
03:42:07 * hackagebot kinds 0.0.1.1 - Emulation of subkinds and subkind polymorphism  http://hackage.haskell.org/package/kinds-0.0.1.1 (WolfgangJeltsch)
03:44:06 <nickodemus> hi
03:50:16 * hackagebot type-functions 0.2.0.0 - Emulation of type-level functions  http://hackage.haskell.org/package/type-functions-0.2.0.0 (WolfgangJeltsch)
03:51:54 <ivanm> how does one do multi-line stuff in ghci again? { ...; \n ...; \n ... } ?
03:52:30 <BONUS> {: _}
03:52:33 <BONUS> :}
03:52:36 <ivanm> ta BONUS 
03:52:54 <ivanm> OK, can't put that into TH...
03:53:28 <ryzal> hello
03:53:52 <ivanm> *sigh* I wonder if ryzal == WMOBILE == nickodemus
03:53:54 * ski raises one eyebrow
03:54:08 <ivanm> because all three of them have done that just now
03:54:17 * hackagebot records 0.1.1.2 - A flexible record system  http://hackage.haskell.org/package/records-0.1.1.2 (WolfgangJeltsch)
03:55:13 <ivanm> well, ryzal is still on IRC; is there some auto-kick list he's on?
04:05:38 * ivanm wonders if BigBlackDog is at all related to blackdog 
04:07:59 <BigBlackDog> ivanm: not that i'd know of
04:08:01 <Adamant> kinda like how Led Zeppelin and The Rob And Big Show are related, maybe
04:08:05 <Adamant> DO WORK!
04:08:45 <blackdog> heh. i have a doppleganger!
04:09:01 <Adamant> but like an evil one or just a regular one
04:09:08 <ivanm> blackdog: yeah, as if blackh hasn't bad enough...
04:09:48 <Adamant> I feel very adamant about this development, completely adamant.
04:10:11 <Adamant> (of course that's my own damn fault)
04:10:15 <Adamant> :P
04:10:43 <xplat> < ski> yeah, i wouldn't call it a "cartesian product" .. but it's near that concept  <--- dependent cartesian product?
04:10:49 <ivanm> anyone know how to use qualified names in TH?
04:13:36 <arunk> has anyone played around with clean (concurrent clean) specifically the new clean + haskell release ?
04:14:02 <ivanm> what do you mean by "clean + haskell release" ?
04:14:54 <arunk> http://wiki.clean.cs.ru.nl/Download_Clean the experimental release on the page. apparently it can compile haskell
04:15:16 <ivanm> huh
04:15:28 <ivanm> probably just included one of the Haskell -> Clean translators
04:16:44 <arunk> well if i understand the docs correctly you can now use cleans unique types in place of haskell's monads
04:17:25 <ivanm> it'd be interesting to see a video of the talk at the haskell symposium
04:26:00 <ivanm> why is the TH documentation non-existent?
04:26:13 <ivanm> I had to resort to reading the source to realise that mkName already covers qualified names
04:26:28 <chrisdone> good code documents itself
04:26:35 <Entroacceptor> that's a lie.
04:26:36 <medfly> "the type signatures should be enough"
04:26:37 <chrisdone> :p
04:26:37 <Twey> TH is still pretty experimental
04:26:45 <Twey> Entroacceptor: Not in Haskell, usually
04:27:11 <Twey> So long as you're not doing anything crazy, it really does.
04:27:31 <chrisdone> the presence of documentation is usually independent to whether I will read a library's source code
04:28:19 <ivanm> even then, I can't tell whether it treats symbols correctly :s
04:31:42 <chrisdone> so I've found the best way to reduce the size of source code of my project is to make every module into a hackage package and then just import it
04:31:55 <ivanm> well, mkName can't handle qualified operators...
04:32:02 <ivanm> chrisdone: heh
04:33:28 <ivanm> dammit, google isn't helping me work out how to use mkName for symbols...
04:34:37 <FunctorSalad_> ivanm: you do know about name literals?
04:34:49 <FunctorSalad_> 'foo for values, ''Either for types
04:34:49 <ivanm> not really
04:34:58 <FunctorSalad_> (value names, that is)
04:35:23 <ivanm> FunctorSalad_: I'm trying to adapt http://www.haskell.org/haskellwiki/Template_haskell/Instance_deriving_example
04:35:34 <ivanm> so I need to pre-define them in there IIUC
04:35:40 <FunctorSalad_> (but this doesn't help if what you're trying to do is to dynamically generate qual names)
04:35:50 <ivanm> yeah, kinda
04:36:09 <ivanm> explicitly trying to create a Name leads to it failing for operators
04:36:11 <FunctorSalad_> the name literals are 'smart'; ''Either will internally be a qualified name
04:36:14 <FunctorSalad_> (AFAIK)
04:36:30 <ivanm> namely, it puts the qualifier outside the parens
04:36:32 <FunctorSalad_> so it won't clash with any other Either that might be in scope at point of usage of the macro
04:36:47 <ivanm> FunctorSalad_: but I can't write a function to be used in TH with 'foo and ''Foo IIUC
04:37:24 <FunctorSalad_> you can use them inside the definition of the function too
04:37:27 <ivanm> and I want to write a TH function to generate instances like: instance MyFunctor [] where fmap = Data.Functor.fmap
04:37:39 <FunctorSalad_> you only need mkName to make names from arbitrary strings
04:37:48 <ivanm> hmmm...
04:38:09 <FunctorSalad_> (the name literals are resolved at compile time of whatever module they're lexically in, just like any other names)
04:38:22 <ivanm> ooohhh, it seems to work
04:38:24 <FunctorSalad_> if*I* understand correctly ;)
04:38:45 <ivanm> except doing '(F.<$) strips away the parens, so I'm not sure it'll work...
04:39:00 <ivanm> FunctorSalad_: I thought I could only use ' and '' inside a $( ... ) or [| ... |]
04:39:01 <FunctorSalad_> if MyFunctor is a fixed class that's no problem
04:39:13 <FunctorSalad_> ivanm: no
04:39:32 <FunctorSalad_> x = ''MyFunctor -- valid toplevel decl, IIRC
04:39:54 <ivanm> well, seems to work in ghci...
04:40:23 <FunctorSalad_> > let x = ''Functor
04:40:23 <FunctorSalad_> > x
04:40:23 <FunctorSalad_> GHC.Base.Functor
04:40:24 <lambdabot>   <no location info>:
04:40:24 <lambdabot>      lexical error in string/character literal at chara...
04:40:24 <lambdabot>   x
04:40:37 <ivanm> OK, this is doable; I'd prefer to be able to pass in just pass in the qualifier and the methods and have my function deal with it, but looks like I don't have to
04:40:44 <ivanm> I mean, it looks like this will work
04:40:53 <ivanm> > let x = ''Functor in x
04:40:54 <lambdabot>   <no location info>:
04:40:54 <lambdabot>      lexical error in string/character literal at chara...
04:40:57 <FunctorSalad_> you probably don't need any qualifiers
04:41:10 <FunctorSalad_> just make sure MyFunctor is in scope at the point the ''MyFunctor appears
04:41:13 <ivanm> well, I do if the method names are the same ;-)
04:41:20 <FunctorSalad_> ah
04:42:05 <ivanm> @hoogle typeInfo
04:42:05 <lambdabot> No results found
04:42:13 <ivanm> OK, so where is that tutorial getting it from...
04:43:57 <ivanm> oh, it's defined later (copied from syb apparently)
04:46:07 <FunctorSalad_> I get 30 results ;)
04:47:54 <ivanm> FunctorSalad_: do you understand here why they use type_name rather than the passed in typName? http://www.haskell.org/haskellwiki/Template_haskell/Instance_deriving_example
04:47:57 <FunctorSalad_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29702#a29702
04:48:44 <FunctorSalad_> hmm I don't remember or know what typeInfo does
04:48:46 <ivanm> especially since syb-with-class's typeInfo doesn't seem to do anything to the type name in question...
04:49:05 <FunctorSalad_> ah, if it's syb-with-class that's 'don't know'
04:49:18 <ivanm> their typeInfo is declared later on in that tutorial/example/whatever
04:50:16 <FunctorSalad_> seems like it should equal typName if reify is sane
04:50:42 <ivanm> yeah
04:50:54 <ivanm> and since I don't care about the constructors, I can ignore typeInfo
04:51:12 <FunctorSalad_> I'd put in an assert (..==...)
04:52:05 <ski> xplat : you might say that, yes
04:57:07 <Blkt> good day everyone
05:00:18 <b52> why trying to load a hs file i wrote i get ERROR "hugs.hs":78 - Undefined variable "ord"
05:00:27 <b52> any idea whats wrong?
05:00:31 <b52> i use hugs
05:00:54 <ski> `import Data.Char' ?
05:01:27 <b52> dunno, thats what i ask you, im wondering cause the book hasnt intruduced imports so far but it requires the use of ord and char
05:01:30 <chrisdone> FunctorSalad_: dude use http://paste.tryhaskell.org/ ! :p
05:01:32 <b52> *chr
05:01:59 <FunctorSalad_> chrisdone: oh didn't know it's done. but I used 'pastepipe'
05:02:00 <ski> b52 : have you imported `Data.Char' near the top of the module ?
05:02:14 <b52> nop
05:02:49 <ski> iirc, Hugs earlier automatically imported `chr' and `ord' .. but doesn't any longer
05:03:12 <ski> b52 : so add `import Data.Char' at the top of your file (under the `module' line, if you have any)
05:03:29 <b52> yeah got that
05:03:31 <b52> thanks
05:03:41 <b52> imports have to be at the top, right?
05:03:42 <ski> yw
05:03:45 <ski> yeah
05:04:12 <ivanm> FunctorSalad_: dammit, I want to write a TH expression to create instances for a class I've defined in a module, but to do so I have to define the TH expression elsewhere
05:04:35 <ivanm> which means that I either have to do intern modules with re-importing or orphan instances :@
05:10:57 <cwb> I'm trying to "lift" a function f :: (Monad m) => a -> m b to f' :: (Monad m) => m (a -> b) (because then I can pass f' to an optimisation function which takes a -> a by lifting that). I've been banging my head against this for a while but can't help but feel I'm missing something pretty trivial..
05:11:02 <ivanm> FunctorSalad_: and when I try using it in ghci, it bitches about expecting ExpQ but getting Q [Dec] :s
05:11:20 <ivanm> duh, can't write instances in ghci
05:11:26 <FunctorSalad_> :)
05:11:46 <FunctorSalad_> (and you need [d| ..... |] for Q [Dec])
05:12:03 <ski> cwb : you can't write `forall m a b. Monad m => (a -> m b) -> m (a -> b)'
05:12:34 <Jon> hi folks. I'm having a bit of trouble trying to "unbox" a value from inside an 'Either' monad. Can anyone explain how I might achieve what I want here? http://paste.debian.net/87752/
05:13:18 <ivanm> well, the instance stuff seems to work anyway
05:13:27 <cwb> ski: Oh.. That'd explain why I feel stupid.. I guess I can write a function specific to the monad I'm using (Reader)..
05:13:28 <ski> Jon : there `f :: Either Errno [String]', so maybe you just wanted to `return f' ?
05:13:49 <cwb> ski: Or do you have any other suggestions?
05:14:03 <ski> cwb : yes, it can work in specific cases, but not in general (try `m' being `Maybe', e.g.)
05:14:28 <Jon> ski: what I want to do is grab the value from inside the Right returned by "foo", do something to it (append "there", say) and then re-wrap it in 'Right'
05:14:48 <Jon> ski: note that foo should be foo = return $ Right ["hi"] -- just notice that error
05:14:56 <ski> Jon : what should happen if `f' is actually `Left errno', for some `errno :: Errno' ?
05:15:29 <ivanm> FunctorSalad_: so, apart from ''(F.<$), any way I can explicitly and statically define that qualified operator?
05:15:29 <ski> just leave it in place ?
05:15:40 <Absolute0> Any phd's in here happy with what their doing?
05:15:44 <Jon> ski: yes. I think I need to stick a 'case' in there maybe?
05:15:54 <ivanm> oh, wait, if anyone uses it outside the project, then they'd have to ensure that they use the same qualifications...
05:15:59 <ivanm> Absolute0: reasonably
05:16:05 <FunctorSalad_> ivanm: not sure. ISTR there is a function to make qualnames dynamically
05:16:11 <ski> Jon : it sounds like you maybe want `fmap (\ss -> ss ++ ["there"]) f'
05:16:18 <Absolute0> ivanm: you teach/do research ?
05:16:32 <ivanm> why can't you use a TH you've defined in the same module? :s
05:16:39 <ski> > let f = Right ["hi"]  in  fmap (\ss -> ss ++ ["there"]) f
05:16:40 <lambdabot>   Right ["hi","there"]
05:16:44 <ivanm> Absolute0: I'm doing a PhD; did you mean someone who _had_ a PhD?
05:16:58 <Absolute0> ivanm: what area?
05:17:08 <hamishmack> How can I get a list of all build-depends in a cabal file for which there is a newer version than the one currently used?
05:17:22 <ivanm> well, it's in CS but I'm actually doing more of a maths project than what most consider CS
05:17:40 <ivanm> hamishmack: ummm... "cabal install foo --dry-run" ? :p
05:17:42 <ski> Jon : `fmap' will do whatever you want with the component in the `Right' constructor (rewrapping the result in `Right') .. and if `f' was `Left ...', it will just leave it as is
05:17:43 <Absolute0> ivanm: I just started, i think i should just get back in the industry. academia seems like a dead end, most topics are rarely used in practice, instead you just fill books that no one reads
05:17:56 <ivanm> Absolute0: depends upon what you do
05:18:10 * ivanm is quite proud of doing something that would not be interesting to most parts of industry
05:18:16 <Absolute0> ivanm: i want to do something with functional programming or algorithms
05:18:22 <BCoppens> ivanm: but isn't your project also something that mathematicians would consider CS? :)
05:18:27 <Absolute0> or both
05:18:34 <ivanm> BCoppens: true, but probably more towards the math end
05:18:37 <ivanm> Absolute0: I'm going graph generation algorithms
05:18:38 <ski> Jon : btw, note that if `bar' isn't going to do anything else, then it could be shortened to `bar = (fmap . fmap) (\ss -> ss ++ ["there"]) foo'
05:18:40 <ivanm> *doing
05:18:53 <ivanm> so it's algorithm development, etc.
05:19:01 <ski> (Jon : which is just the same as `bar = fmap (fmap (\ss -> ss ++ ["there"])) foo', if you think that's clearer)
05:19:13 <Absolute0> ivanm: what year are you in? How do you find the process for you?
05:19:15 <luite> ivanm: hmm, I'd still consider that CS
05:19:26 <ivanm> BCoppens: we think we've _finally_ managed to adapt an under-specified counting argument for d-angulations of girth d into a generation algorithm
05:19:39 <luite> but on the other hand, the math department at my university also does that kind of things
05:19:42 <ivanm> Absolute0: about 6 months in; and I'm probably procrastinating more than I should
05:19:57 <ivanm> luite: right, the only reason it's in CS here is because when ANU formed their CS school they nabbed Brendan McKay
05:20:01 <FunctorSalad_> ivanm: how about these http://hackage.haskell.org/packages/archive/template-haskell/2.4.0.1/doc/html/Language-Haskell-TH-Syntax.html#v%3AmkNameG_v
05:20:05 <Jon> ski: thank you, yes fmap seems to be it. the example I gave was simplified from real code, bar does more in real life â˜º thank you
05:20:09 <Absolute0> ivanm: oh its my first 2 weeks :) I am already thinking of dropping it
05:20:09 <hamishmack> ivanm: Thats not much use unfortunately
05:20:13 <ivanm> AFAIK, all other unis that have a computational combinatorist have them in their math/combinatorics department
05:20:15 <FunctorSalad_> _v _d _tc = value/datacon/typecon presumably
05:20:28 <ski> Jon : yes, i was thinking that could be the case :)
05:20:34 <hamishmack> ivanm: I want to see packages not used because of the upper bounds I am adding
05:20:34 <ivanm> hamishmack: you could possibly find and adapt the cabal-install code
05:20:44 <ivanm> if you wanted something to add to leksah
05:21:00 <BCoppens> ivanm: aha, sounds interesting :)
05:21:02 <Absolute0> math and cs departments work together in my previous college
05:21:14 <Absolute0> cs branched out from math when cs began to grow
05:21:28 <b52> does a function exists which checks if a char is normal letter, like 'd' 'Z' etc ?
05:21:29 <ivanm> Absolute0: my case is slightly atypical because the normal "lit review" is being expanded into "let's do a survey of all literature in the field", and the area I was told to cover was actually slightly off what my supervisor meant :s
05:21:31 <Peaker> ivan, Why be proud about others finding it uninteresting?
05:21:44 <ivanm> Peaker: because I like to be different ;-)
05:21:56 <ivanm> b52: isLetter
05:21:59 <ivanm> @hoogle isLetter
05:21:59 <lambdabot> Data.Char isLetter :: Char -> Bool
05:22:07 <Peaker> ivan, will you leave Haskell when it becomes mainstream? :)
05:22:15 <Adamant> depends on the department. it grew out of the Math department in some places and the EE department others
05:22:19 <ivanm> Peaker: depends what else is available
05:22:21 <BCoppens> ivanm: ah and how's that survey article coming along, actually? :)
05:22:36 <Peaker> ivan, Just stuff that's available now
05:22:37 <Adamant> and in others it never left (combined departments)
05:22:38 <luite> hmm, I want to start a PhD after I've finished my msc (which should be relatively soon), but I have no idea exactly what. I always feel that I'm too stupid for "proper" math stuff...
05:22:48 <ivanm> Peaker: it's kind of a perverse backwards pride I've developed; I won't have the opportunity to lower myself to do research for money :s
05:22:49 <Absolute0> ivanm: do you think a chess engine written in haskell can be a viable project to turn into a phd thesis?
05:23:04 <ivanm> Absolute0: ummm, what field? AI?
05:23:10 <Absolute0> id probably need some wicked cool algorithms and concepts to incorporate into it
05:23:15 <luite> Absolute0: if it contains some new ideas, it could be
05:23:18 <ivanm> even then, probably not unless you have some unique new field/focus/etc. you want to develop with it
05:23:26 <ivanm> don't forget, PhD is about research...
05:23:36 <Absolute0> i need to get to reading
05:24:05 <Absolute0> research seems like doing work that yields not reward, only for yourself
05:26:00 <Absolute0> "a grad student in procrastination tends to stay in procrastination until an external force acts upon it." :)
05:26:07 <Absolute0> http://www.phdcomics.com/comics/archive.php?comicid=221
05:26:16 <ivanm> yeah, that applies to me...
05:26:33 <luite> Absolute0: well it's about doing new things, which always takes a lot more effort than doing something that has been done before
05:27:04 <Absolute0> luite: what do you do?
05:27:44 <luite> Absolute0: no PhD yet, but currently working on my msc thesis in analysis of exponential time algorithms
05:28:16 <Absolute0> is that np stuff?
05:28:53 <luite> Absolute0: the algorithms are NP-hard, but this research has relatively little to do with computational complexity theory
05:29:01 <Absolute0> i see
05:29:13 <Absolute0> even algorithms is barely used in the field
05:29:19 <Absolute0> you barely ever need to write an algorithm
05:29:20 <luite> it's more combinatorics, graph theory
05:29:25 <Absolute0> you're just using functions
05:29:51 <Absolute0> unless you're doing some cool finance app or gaming
05:30:43 <luite> Absolute0: a lot of operations research results are used in practice
05:31:59 * hackagebot mtl 1.1.1.0 - Monad transformer library  http://hackage.haskell.org/package/mtl-1.1.1.0 (RossPaterson)
05:35:10 <luite> Absolute0: at least in my department, there are some theoretical people, but also some who regularly get hired by companies or government for consultancy on real-world projects
05:38:58 <Peaker> Wow, #haskell used to be around the size of ##c.. now it's 46% larger :)
05:39:21 <Peaker> Though #haskell doesn't seem much larger, it appears maybe ##c shrunk
05:40:04 <ahf> the C and C++ channels on efnet seems to be more active than the ones on Freenode.
05:44:40 <Peaker> #python grew more than #haskell though
05:46:01 <burp> "_ct                 create tags file" anyone knows what the "_" key in vim is?
05:46:13 <Twey> Isn't it the _ key?
05:46:51 <burp> um, you might be right :)
05:47:07 <Twey> Heh
05:47:37 <jmcarthur> i think #haskell has actually shrunk a little in absolute number of users
05:47:47 <jmcarthur> over the past year or so
05:48:36 <Twey> We were up to 666 at one point not so long ago
05:49:13 <jmcarthur> but weren't we usually higher than that about a year ago?
05:49:24 <jmcarthur> and now we are usually lower?
05:49:36 <Heffalump> we broke 500 years ago, IIRC
05:49:59 <jmcarthur> it was only 2-3 years ago, iirc
05:50:11 <jmcarthur> we grew a lot and then shrunk a little, if my perception is correct
05:51:39 <deteego> I expect a huge number when 6.14 comes out
05:51:44 <deteego> so many sexy things gonna happen then
05:53:00 <deteego> I think the reason users have been dropping is that there hasn't been a 'big' haskell release since 6.12
05:53:01 <cwb> deteego, for someone who's not at all clued in on 6.14, could you perhaps give some examples of the sexiness?
05:53:09 <deteego> cwb: llvm mainly
05:53:19 <cwb> Sweet.
05:53:24 <deteego> cwb: and a number of other massive improvements
05:53:25 <deteego> in speed
05:53:47 <cwb> Roughly when is 6.14 expected?
05:54:11 <deteego> llvm is itself a massive change because the developers won't have to worry about machine code at all, and it increases performance in certain cases by a massive number
05:54:15 <deteego> cwb: january 3rd iirc
05:54:55 <cwb> LLVM by january is sooner than I had thought, that's nice.
05:55:12 <deteego> LLVM has already been implemented as a backend
05:55:13 <Ke> general dynamic linking with shared memory or perhaps even with stable abi
05:55:16 <Ke> ?
05:55:21 <deteego> they have to sought out the rough edges
05:55:25 <deteego> Ke: yeah thats the other thing
05:55:31 <deteego> llvm can also mean a stable runtime
05:55:38 <deteego> which means shared objects that won't break every year!
05:56:32 <Ke> that something to drool for
05:57:10 <Ke> though I am not 100% convinced that the runtime is a good idea
05:57:35 <deteego> Ke: what do you mean
05:57:54 <Ke> eg the implicit IO thread
05:58:09 <Ke> no fork and no seccomp
05:59:13 <deteego> ah righ
05:59:15 <deteego> *right
05:59:37 <Ke> I guess someone could make a builtin seccomp to the runtime
06:00:37 <Ke> but probably not feasible with all the wrapped C packages
06:01:47 <deteego> llvm might make it easier to bind C libraries that way into Haskell
06:01:59 <deteego> since LLVM does have a C backend as well (and a C++ one being developed)
06:02:13 <nlogax> i want to store some data with my irc bot, i started out by using mongodb, but that feels like overkill. would Data.Serialize be a good choice? it's for things like @seen
06:12:38 <b52> any idea why this doesnt work? http://paste.tryhaskell.org/65/fizzbuzz
06:12:49 <b52> line 8 Couldn't match expected type `IO t' against inferred type `[IO ()]'
06:13:19 <ivanm> b52: you don't want map
06:13:21 <Zao> b52: The type of your whole map expression is [IO ()].
06:13:23 <ivanm> try mapM_
06:13:26 <Zao> b52: That is, a list of IO "actions".
06:13:34 <ivanm> @type mapM_
06:13:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
06:13:35 <ivanm> @type map
06:13:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:13:39 <Zao> b52: You want a way to execute them, in "sequence" :D
06:15:31 <b52> ivanm: thanks
06:15:41 <ivanm> np
06:20:15 <ivanm> wow, the mtl update breaks a whole bunch of packages...
06:20:31 <ivanm> (in the whole "you have to rebuild this package" sense, not in the incompatible API sense AFAIK)
06:20:42 <ivanm> it's amazing how central such a package is to so many packages
06:30:45 <ivanm> @hoogle mkNameG_v
06:30:46 <lambdabot> Language.Haskell.TH.Syntax mkNameG_v :: String -> String -> String -> Name
06:30:56 <ivanm> anyone know what the different String arguments to that are meant to be?
06:32:33 <ivanm> apparently the first three are meant to be namespace, package and module respectively; I'm not sure what the first two are meant to be though :s
06:38:05 <doofer> How would you suggest organizing a cabal packaged library where there is a module for testing (with QuickCheck) the stuff that you build with the library? Should I include QuickCheck as a dependency, or somehow make it optional?
06:39:00 <ivanm> optional
06:39:06 <ivanm> @hackage graphviz
06:39:06 <lambdabot> http://hackage.haskell.org/package/graphviz
06:39:11 <ivanm> doofer: ^^ see how I do it here
06:39:44 <ivanm> I also just did a blog post on this, but the stuff in that .cabal file is basically what my blog post covers
06:40:30 <doofer> ah, I saw your blog post actually :) but this is actually not really a test suite, so that's why I asked :)
06:41:31 <ivanm> same way pretty much
06:41:35 <ivanm> but in the library section
06:41:50 <ivanm> I have some testing-only modules in graphviz, and the .cabal file takes that into account
06:41:52 <doofer> okay, thanks!
06:42:12 <iocor> if I have data Ponies = Bacon {a,b,c :: Int} | Cows {a,b,c :: Int} how do I write a function that matches like `f type {a1=a,b1=b,c1=c} = do_thing_with type a1 b1 c1`
06:42:13 <ivanm> namely Data.GraphViz.Testing, etc.
06:42:44 <ivanm> iocor: you need {a = a1, b = b1, c = c1} if a1, b1 and c1 are the values you want to set
06:42:52 <ivanm> or even in pattern matches
06:42:55 <iocor> ok, sorry sure
06:43:14 <ivanm> and if it's a pattern match, you _might_ need to wrap it in parens, I can't recall
06:43:28 <ivanm> i.e. func (Bacon{ a = 3 })
06:43:35 <ivanm> can't recall if the parens are needed or not
06:43:35 <iocor> ivanm: I don't want to match bacon
06:43:42 <iocor> specifically
06:43:52 <iocor> I want the pattern to match either type, and extract the a b c
06:44:09 <ivanm> oh
06:44:13 <ivanm> you can't do it like that then
06:44:21 <ivanm> foo val = bar (a val)
06:44:33 <ivanm> the record fields are also selector functions
06:44:44 <ivanm> which is why most people use record data types
06:44:47 <iocor> so you can't match against things that have the same name and type
06:44:52 <ski> iocor : not needed
06:44:53 <mauke> foo x = ... where (a1, b1, c1) = (a x, b x, c x)
06:44:53 <ivanm> (they also offer clumsy syntax for setter functions)
06:45:02 <ivanm> mauke: or that way
06:45:04 <ski> er, s/iocor/ivanm/
06:45:38 <ivanm> iocor: but no, because I can have: data Foo = Bar { a :: Int, b :: Char } | Baz { a :: Int, c :: Bool }
06:45:38 <doofer> you should be able to do it like so:
06:45:38 <doofer> foo x | a x == a1 && b x == b1 ... = ...
06:45:48 <ivanm> i.e. you can have some in common but not all
06:45:54 <ivanm> doofer: I highly doubt it
06:46:02 <ivanm> since that won't set a1, b1, etc.
06:46:22 <ivanm> ski: how then?
06:46:26 <doofer> ah, where a1 is some value
06:46:34 <ivanm> ski: oh, did you mean the parens bit?
06:46:40 <ivanm> yeah, I couldn't recall
06:46:40 <ski> ivanm : i just mean `func Bacon {a = 3} = ...' is valid
06:46:48 <ivanm> doofer: right, he's wanting to _use_ those values IIUC
06:46:52 <ivanm> ski: *nod*
06:46:58 <doofer> ooh, I see
06:47:16 * ski isn't getting what iocor wants ..
06:47:34 <mauke> ski: constructor patterns
06:47:38 <ivanm> iocor: he wants to be able to be able to get the values to the common fields out without caring what the constructor is
06:48:49 <ivanm> ski, mauke: either of you know much about TH?
06:48:53 <ski> ivanm : how about `data Ponies = MkPonies {poniesKind :: PoniesKind , a,b,c :: Int}; data PoniesKind = Bacon | Cows' ?
06:49:01 <ski> ivanm : nope
06:49:04 <ski> arg
06:49:09 <ivanm> ski: heh
06:49:14 <ski> s/ivanm/iocor/
06:49:19 <mauke> ski: f :: Either Bool Bool -> Bool; f (c x) = not x
06:49:25 <ivanm> ski: also, I don't think "Bacon" is a type of Pony :p
06:49:44 <ivanm> mauke: yeah, but that's not possible, right?
06:49:52 <mauke> right
06:50:04 <ski> (you two should stop having the same initial letter ! .. i can't be really be expected to type more than one letter of your nicks, now can i ?)
06:50:37 <ivanm> ski: if you think that's bad, ever since ivan joined people keep responding to him rather than me...
06:50:38 <ivanm> ;-)
06:50:59 <mauke> iva... nm
06:51:17 <ivanm> but I used to get confused between ksf and kmc since they both had 3-letter nicks starting with `k' and xchat colours them the same
06:51:20 <ivanm> mauke: heh
06:51:29 <ski> (ivanm : blame ivanm^Wiocor about "Bacon" :)
06:51:41 <ivanm> yeah
06:53:17 <ski> mauke : i suppose matching a value of type `b' against `c x' could introduce a new skolem `a', with `x :: a' and `c :: a -> b' .. not that that would be *useful*, though
06:54:54 <ski> (though .. in some contexts, matching things against a pattern `c x' is useful .. specifically in L-lambda matching)
06:57:39 * ski still wonders whether `Maybe Fib' and `(Fib,Fib)' is non-recursively isomorphic ..
07:07:27 * hackagebot LibZip 0.1.0 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.1.0 (SergeyAstanin)
07:09:04 <deteego> ewww
07:09:43 <ivanm> yeah, we already have a couple of libraries to do that
07:09:45 <ivanm> zip-archive, etc.
07:09:56 <ivanm> admittedly they apparently behave rather poorly for large archives...
07:11:41 <chrisdone> hmm
07:11:43 <chrisdone> creepy
07:11:49 <chrisdone> really, creepy
07:11:58 <ivanm> what is?
07:12:05 <chrisdone> Internal Server Error
07:12:05 <chrisdone> Please contact the server administrator, moonpatio@moonpatio.com
07:12:44 <ivanm> chrisdone: _please_ let the paste.tryhaskell.org pastes take up more horizontal space
07:12:54 <chrisdone> I honestly think mmorrow has died or been kidnapped by lisp programmers
07:13:00 <ivanm> limiting it to the middle third of the screen is a waste of valuable horizontal screen real estate :s
07:13:12 <chrisdone> yet his server remains running
07:13:14 <ivanm> chrisdone: yeah; copumpkin and I tried to find him a few months back, but he's disappeared off the internet
07:13:21 <chrisdone> like a ghost server
07:13:23 <ivanm> he's done a _why without bothering to tell anyone about it!
07:13:31 <chrisdone> maybe he was _why
07:13:35 <copumpkin> I'm more worried than that
07:13:49 <luite> ivanm: 80 columns ought to be enough for anyone
07:13:51 <copumpkin> zygoloid also tried more recently, but I'm not sure anyone tried calling the phone number
07:14:03 <chrisdone> ivanm: why? show me an example
07:14:19 <ivanm> chrisdone: well, for starters compare yours to every other paste bin
07:14:42 <ivanm> the ability to have recent links, etc. on the size rather than having to scroll all the way down is nice
07:15:27 <luite> I didn't have to scroll down
07:15:32 <ivanm> also, if I want to increase the font size your site doesn't also increase the middle area (unless i use "full page zoom" rather than just "text size zoom")
07:15:39 <chrisdone> how often do you look at recent pastes?
07:15:55 <ivanm> not often
07:16:00 <ivanm> but it just looks like a waste!
07:16:04 <chrisdone> lol
07:16:11 <ivanm> at least make it take up the middle 3/4 or something rather than the middle 1/3 !
07:16:28 <luite> why don't you make your window smaller :p
07:16:51 <chrisdone> ivanm: I'll do it, so we can compare
07:16:52 <ivanm> luite: because my xmonad layout for that workspace is tabbed
07:16:57 <ivanm> chrisdone: ta
07:17:32 <luite> ivanm: use something that's not from the windows 1.0 era then ;)
07:17:49 <ivanm> luite: I'm not! xmonad is newer than windows 1.0!!!
07:17:56 <deteego> lies
07:17:59 <deteego> lies and slandar
07:18:30 <ivanm> deteego: well, since it only came out within the hackage era, and windows 1.0 predates hackage...
07:20:36 <ivanm> chrisdon`: btw, what are you using for syntax-highlighting there?
07:20:47 <chrisdon`> highlighting-kate
07:20:51 <ivanm> ahhh
07:20:58 <ivanm> so it isn't extendable :s
07:21:06 <chrisdon`> sure it is
07:21:18 <ivanm> well, at build-time
07:21:21 <chrisdon`> what do you mean by extend?
07:21:59 <ivanm> well, if I want to highlight some .dot code in a markdown document I'm converting to html with pandoc, I'm out of luck even if I find a kate syntax file for Dot (which I did at one point)
07:22:21 <ivanm> _unless_ you rebuild highlighting-kate and patch it to include your extra highlighting file
07:22:36 <chrisdon`> which would be a nice open source contribution
07:22:51 <ivanm> well, he's working on a replacement anyway
07:22:58 <ivanm> so I'm waiting to see how that turns out
07:23:21 <chrisdon`> cool
07:23:28 <chrisdon`> I went for the most straight-forward library
07:23:29 <deteego> ivanm: what environment do you use for Haskell editing
07:23:38 <ivanm> deteego: emacs + haskell-mode
07:23:39 <chrisdon`> hpaste2 delves into FFI to talk to python to use a python library
07:23:41 <chrisdon`> screw that
07:23:49 * ivanm really should go and try out some of chrisdon`s extensions for it
07:24:13 <deteego> im a vim user
07:24:16 <deteego> hmmm
07:24:20 <ivanm> chrisdon`: yeah, it's called illuminate
07:24:30 <ivanm> deteego: there's highlighting stuff for vim as well
07:24:34 <ivanm> chrisdon`: ugh
07:24:35 <deteego> I know
07:24:58 <deteego> I just never delved into emacs
07:25:01 <Nibble> I use vim haskell
07:25:03 <deteego> not sure if I should
07:25:08 <Nibble> works like a charm
07:25:29 <cads> is there anything like smalltalk squeak, but built in haskell?
07:25:44 <aristid> chrisdon`: you could write generic haskell-python bindings to hide that :P
07:25:50 <cads> could we do it using xmonad code and gtk binding?
07:26:13 <ivanm> why xmonad? wouldn't using yi or something be a better start?
07:26:21 <aristid> cads: xmonad code? you probably can do it, but xmonad code is not what you would use
07:26:22 <cads> I wanna be able to click on desktop objects to discover funky haskell gui code
07:26:25 <ivanm> aristid: burp?
07:26:40 <ivanm> cads: huh, well, xmonad doesn't really have "desktop objects"
07:26:50 <chrisdon`> aristid: I don't need no stinkin' python
07:26:53 <aristid> ivanm: does "burp" have a meaning that i'm not aware of?
07:26:54 <cads> ivanm: what I'm thinking of might integrate with x11 or something
07:27:04 <sshc> What is a cross-platform way to get the number of milliseconds that has passed since some point (the start of the process, January 1970, or whatever)?
07:27:08 <cads> but yeah, I understand that xmonad just manages windows
07:27:18 <ivanm> aristid: it's bernie pope's python implementation in Haskell
07:27:26 <blackdog> cads: most of the information that you'd want doesn't exist at runtime
07:27:28 <sshc> The actual point doesn't matter, as long as it is fixed; since I'm only comparing differences of those values relative to each other.
07:27:29 <ivanm> wait, it's berp, not burp
07:27:32 <ivanm> @hackage berp
07:27:32 <lambdabot> http://hackage.haskell.org/package/berp
07:27:40 <aristid> chrisdone: why? if there's a good python library, it might take unnecessarily long to find/create a non-python replacement
07:27:51 <chrisdone> but it didn't
07:27:58 <ivanm> aristid: it might take unnecessarily long to write a good bridge
07:27:59 <chrisdone> it took 2 minutes to look on hackage and see 'highlighting-kate'
07:28:03 <chrisdone> done
07:28:10 <ivanm> though IIRC CosmicRay had a python-haskell bridge at one point...
07:28:27 <cads> blackdog: I'm just thinking it would be a neat interactive programming experience / IDE 
07:28:27 <ivanm> anyway, I should hit the sack
07:28:29 <ivanm> g'night all
07:28:37 <aristid> night? oO
07:28:49 <cads> blackdog: not that I have any real idea where to start :)
07:28:52 <aristid> wait, it might be australia or so :D
07:28:56 <cads> maybe looking at squeak
07:29:06 <blackdog> cads: sure, i'm just pointing out that it'd be a lot of work.
07:29:10 <ivanm> @time
07:29:11 <lambdabot> Local time for ivanm is Sun Sep  5 00:28:47
07:29:14 <ivanm> aristid: ^^
07:29:16 <ivanm> yes, night
07:29:17 <blackdog> if you're really interested, I'd read Don Stewart's PhD thesis
07:29:29 <cads> blackdog: but would it be as much work as squeak was?
07:29:44 <blackdog> more, I'd say.
07:29:55 <blackdog> you're fighting against the system to a certain extent
07:30:00 <cads> how so?
07:30:03 <aristid> UTC+10 mm
07:30:07 <cads> the type system?
07:30:17 <blackdog> smalltalk already has the information available at runtime
07:30:42 <ivanm> chrisdone: http://github.com/jgm/illuminate
07:30:46 <cads> I don't understand which information, can you clarify?
07:30:58 <ivanm> (but it doens't seem to support runtime additions either :s)
07:30:59 <blackdog> ghc compiles haskell down to native code - all the type info is checked at compile time, but then it's discarded
07:31:32 <cads> oh, so smalltalk does better runtime introspection?
07:31:45 <blackdog> yep.
07:31:58 <blackdog> if you want to do runtime introspection in haskell, you have to go to extra effort
07:32:12 <blackdog> but don't take my feeble explanations - go read don's thesis:)
07:32:16 <cads> got it
07:32:24 <chrisdone> ivanm: nice
07:32:59 <cads> blackdog: I can think of a few neat ways of doing it, some of them which are almost like building a rudimentary object and messaging system :)
07:33:28 <cads> I be haskell would also be a great ground for agents and process algebraic stuff
07:33:41 <cads> I bet*
07:33:56 <cads> but yeah, lots of work
07:35:20 <blackdog> one way of approaching it is to use the hard/soft layered pattern
07:35:29 <blackdog> i'm sort of doing that with hubris
07:36:07 <ray> google reader recommends oleg rss
07:36:11 <ray> i didn't know oleg had an rss
07:36:30 <cads> blackdog: I'm at http://www.cse.unsw.edu.au/~dons/ - which publication is his thesis?
07:36:55 <cads> dynamic applications?
07:37:48 <blackdog> dynamic extension of typed functional languages
07:39:18 <osaunders> Which function would I use to extract the value of a Just?
07:39:26 <ivanm> there's fromJust
07:39:30 <copumpkin> ew no
07:39:33 <ivanm> but you're better off using maybe or fromMaybe
07:39:36 <osaunders> :t fromJust
07:39:37 <lambdabot> forall a. Maybe a -> a
07:39:40 <ivanm> just in case you have a Nothing as well
07:39:41 <ski> osaunders : `maybe' or `fromMaybe'
07:39:43 <ivanm> > fromJust Nothing
07:39:43 <lambdabot>   *Exception: Maybe.fromJust: Nothing
07:39:48 <osaunders> :t fromMaybe
07:39:49 <lambdabot> forall a. a -> Maybe a -> a
07:39:50 <copumpkin> fromMaybe, maybe, >>=, =<<, <=<, >=>, <$>
07:39:59 <ski> @type maybe
07:40:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:40:05 <ivanm> copumpkin: OK, now you're just showing off... ;-)
07:40:16 <copumpkin> nuh uh
07:40:30 <ivanm> I mean, >>= _and_ =<< ?
07:40:45 <copumpkin> damn right
07:40:50 <osaunders> lol
07:43:32 <ray> @let ï¼ˆã®ãã®ï¼‰ã€† = flip fmap
07:43:32 <lambdabot>   Parse error: VarSym "\65288"
07:43:59 <osaunders> Oooh pretty symbols.
07:46:05 <Twey> Not a symbol
07:46:18 <Twey> @let ã®ãã® = flip fmap
07:46:18 <lambdabot>   Illegal character ''\12398''
07:46:23 <Twey> *shrug*
07:47:30 <ray> i don't think it counts ï¼ˆ as (, does it?
07:47:37 * hackagebot hjson 1.2 - JSON parsing library  http://hackage.haskell.org/package/hjson-1.2 (JaroslavGridin)
07:48:28 <sshc> getClockTime would have worked, but it's part of old-time
07:48:58 <sshc> What can I use to find the number of microseconds since some point?
07:57:36 <Ariato> guys im having a hard time learning haskell... do you think learning scheme first would help me 'get' it faster?
07:57:47 <tommd> no
07:57:47 <vanadium> no
07:57:49 <deteego> Ariato: no
07:57:51 <deteego> god
07:57:52 <deteego> no
07:57:53 <mauke> what programming languages do you know?
07:58:16 <Ariato> java, php, python, c
07:58:21 <Ariato> im no pro at any
07:58:23 <vanadium> python is good
07:58:24 <tommd> Use YAHT, RWH, and LYAH.  Then talk to people in real life about Haskell.  The whole time program in Haskell.  Eventually, dream in Haskell
07:58:27 <vanadium> python has lambdas <:)
07:58:32 <deteego> hmm with those languages
07:58:39 <mauke> s/lambdas/crippled lambdas/
07:58:39 <deteego> there is a tutorial
07:58:45 <deteego> haskell for c programmers
07:58:57 <vanadium> mauke: I am trying to maintain a positive attitude here!
07:58:58 <tommd> I never liked that and I was a C programmer
07:59:06 <deteego> Ariato: http://www.haskell.org/~pairwise/intro/intro.html
07:59:19 <deteego> it depends who you are
07:59:21 <deteego> I guess
07:59:22 <deteego> it helped me
07:59:27 <sshc> tommd: YAHT?
07:59:43 <sshc> Ariato: I would suggest http://learnyouahaskell.com/
08:00:20 <Ariato> thank you all, i dont really know anyone in real life that knows haskell
08:01:02 <deteego> real life is over rated
08:01:12 <chrisdone> dude, before I moved, I could only count 5 people in real life that can program
08:01:18 <mauke> is this the real life
08:01:25 <chrisdone> well, it's not a fantasy
08:01:45 <deteego> or is it?
08:02:02 <Ariato> perhaps i want to learn it too fast -.-
08:02:07 <chrisdone> looup see skies
08:02:21 <deteego> Ariato: haskell is one of those languages, which takes you a while to get
08:02:23 <deteego> but when you get it
08:02:24 <chrisdone> Haskell's a language that you can't learn fast
08:02:28 <deteego> its like BAM
08:02:39 <deteego> and after that is sex
08:02:41 <mauke> and then your brain explodes
08:02:41 <Jonno_FTW> I still don't get monads
08:02:50 <ski> (deteego : Bajkal-Amur-Magistralen ?)
08:02:51 <Jonno_FTW> or >>=
08:02:51 <Ariato> deteego: for free?
08:02:59 <deteego> sex is better when its free?
08:03:13 <enigmus> How can I compare two objects for (physical) equality (like nodes in data Tree a = Node Tree Tree | Leaf a)?
08:03:13 <mauke> getting monads is pointless
08:03:28 <mauke> enigmus: impossible, there is no physical equality
08:03:36 <Jonno_FTW> mauke: why?
08:03:46 <mauke> Jonno_FTW: what is it good for?
08:03:54 <copumpkin> enigmus: just use deriving (Eq) 
08:03:57 <Jonno_FTW> IO in haskell
08:03:57 <copumpkin> on that datatype
08:04:08 <copumpkin> enigmus: and then write == between two of them
08:04:10 <mauke> Jonno_FTW: getting monads won't help you with that
08:04:11 <tommd> chrisdone: Whatever do you mean?  I know people who learned Haskell first.
08:04:20 <enigmus> mauke: hmm, how can I implement fast comparison in a graph? (physical == implies structural ==...)
08:04:21 <mauke> Jonno_FTW: just learn IO
08:04:24 <chrisdone> tommd: how long did it take?
08:04:26 <ski> enigmus : also, you need `Node (Tree a) (Tree a)', there
08:04:37 <tommd> Well, they were somewhat genius, so about a year and a half.
08:04:43 <mauke> enigmus: the garbage collector moves objects around
08:04:46 <mauke> addresses aren't stable
08:04:59 <Jonno_FTW> @pf  sum $ map digitToInt $ show 42
08:04:59 <lambdabot> Maybe you meant: bf pl
08:05:00 <chrisdone> a year and a half is about right
08:05:10 <enigmus> copumpkin: does deriving Eq implements == as a physical equality? What's the complexity of == in that case?
08:05:23 <mauke> enigmus: no, it's structural
08:05:27 <copumpkin> enigmus: physical equality isn't a standard term and I'm not sure what you mean by it
08:05:29 <Jonno_FTW> bf pl  sum $ map digitToInt $ show 42
08:05:30 <copumpkin> structural is the usual term
08:05:41 <blackdog> he wants to compare pointers
08:05:43 <Ariato> are there any videos on learning haskell or just books?
08:05:46 <Jonno_FTW> how do I make lambdabot return a pointfree function?
08:05:47 <copumpkin> enigmus: in that case, the complexity is as good as it can be :P
08:05:47 <mauke> enigmus: copumpkin has no idea what you're talking about
08:05:49 <enigmus> mauke: so non-terminating on a cyclic structure?
08:05:52 <mauke> enigmus: right
08:05:57 <copumpkin> oh
08:06:04 <chrisdone> @pl \x -> x * x
08:06:04 <lambdabot> join (*)
08:06:05 <copumpkin> pointers?
08:06:10 <ski> Jonno_FTW : `pointless' or `pl'
08:06:13 <enigmus> mauke: That is nasty!
08:06:28 <Jonno_FTW> @pl \x-> sum $ map digitToInt $ show 42
08:06:28 <lambdabot> const (sum (map digitToInt (show 42)))
08:06:36 <blackdog> Ariato: I think Ralf Laemmel has a video series
08:06:38 <mauke> enigmus: you could annotate each object with a unique id
08:06:43 <blackdog> hvaen't seen it myself yet, though.
08:06:44 <copumpkin> enigmus: it's a consequence of being abstracted from the machine model... if you want that use stablenames
08:06:44 <Jonno_FTW> @pl \x-> sum $ map digitToInt $ show x
08:06:44 <lambdabot> sum . map digitToInt . show
08:06:51 <ski> enigmus : well, nonterminating on infinite (non-cyclic) structures as well
08:06:52 <copumpkin> actually even stablenames won't help much
08:06:56 <enigmus> mauke: regarding GC: can the GC create two copies from a single object? Addresses change, but don't they remain unique?
08:07:41 <Cale> enigmus: It's impossible to know whether two values which are equal are in the same place in memory or not. Copying garbage collection makes it especially hard to tell.
08:08:37 <Cale> (The GC moves things around in memory at arbitrary points in time)
08:08:55 <mauke> like in the middle of comparing things?
08:09:03 <Cale> exactly :)
08:10:01 <enigmus> Cale: but I thought the GC would keep only one copy of an object visible at a given time? that is: refA = object; refB = object => if object is moved, both references are (atomically) updated?
08:10:14 <Cale> Plus, being able to tell apart values which are equal is semantically awful.
08:10:43 <Cale> enigmus: You can still build two lists which happen to be equal
08:10:45 <enigmus> Cale: well, the use case is more for the other way around, as a (massive) optimization. === => ==
08:10:51 <Cale> and yet are not the same list in memory
08:11:14 <blackdog> Cale: it wouldn't break the semantics to use it as an optimisation, would it? although i suppose it could affect strictness
08:11:16 <enigmus> Cale: sure, === /=> ==, but that's pretty clear
08:11:42 * ski wonders what `===' is meant to signify
08:12:08 <Cale> blackdog: If it was a reliable operation, you could use it as an optimisation, except that you pay for that optimisation in other ways.
08:12:12 <enigmus> ski: === is physical/address equality in many languages, sorry
08:13:10 <Cale> Giving every distinctly defined value a globally unique address would cost quite a bit.
08:15:24 <Cale> and if the operation which compared addresses was made available, you'd lose a lot of ability to reason equationally about code because the semantics of every type would be quite a bit more complicated.
08:17:28 <Cale> So, if you want to represent graph structures with loops in them in a way which supports efficient operations, build them using Data.Map or another associative structure.
08:19:04 <Cale> Map Vertex (Set Vertex) for example
08:19:11 <blackdog> Cale: yes, i was thinking of it more as a compiler optimisation
08:20:24 <Cale> blackdog: Yeah -- it would probably require a real test, but my gut feeling is that in order to get that optimisation to make equality testing fast, you'd have to make every other operation a little slower, and it might not work out so well.
08:20:32 <blackdog> if you're just comparing for pointer equality, then you can't get a false positive
08:20:51 <blackdog> i don't quite see where the cost comes in. what am i missing?
08:20:52 <Cale> actually you can
08:21:09 <Cale> Or, depending on the GC, you can.
08:21:34 <enigmus> Cale: not if you make === atomic wrt GC (and a lot of things are, in Haskell, I believe)
08:27:51 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Mem-StableName.html
08:52:47 <copumpkin> preflex: seen dolio
08:52:48 <preflex>  dolio was last seen on #haskell 3 days, 8 hours, 33 minutes and 17 seconds ago, saying: Or Voldemort.
08:53:01 <copumpkin> damn, He Who Must Not Be Named got him
08:53:02 <enigmus> Saizan: yeah. But StableName infects pure code with IO, I would rather have a ST-based single id generator. StableName uses a mutex-protected hashtable that maps... pointers to unique ids. So it's really not different from what a primitive, GC isolated === would do.
08:57:04 <sshc> How should "if then" blocks be indented in do blocks?
08:57:31 <monochrom> move "then" and/or "else" further to the right
08:57:51 <BONUS> i usually do an if, then a newline and then both then and else are indented from th eif
08:58:52 <enigmus> Cale: actually, the StableName implementation is interesting: they maintain the map pointer->uniqueId across GC by rehashing the table. But when looking up a stablename, they simply rely on the fact that the pointer is unique (as it is the key for the hash table), so it would be just fine to use a pointer for === comparison, as long as GC cannot start before === is over.
08:58:58 <sshc> I'll do that.  THanks.
08:59:41 <Cale> sshc: Like:
08:59:43 <Cale> if foo
08:59:45 <Cale>    then bar
08:59:47 <Cale>    else quux
09:00:07 <Cale> The important thing style-wise is that the 'then' and 'else' line up if they're on different lines.
09:00:45 <sshc> Cale: This tends to take up a lot of space, though:
09:00:46 <sshc> if foo
09:00:50 <sshc>     then do
09:00:55 <sshc>         etc
09:01:04 <blackdog> you can sometimes refactor with "guard"
09:01:12 <Cale> I tend to put the first line of the do block on the line with 'do' itself.
09:01:14 <mauke> sshc: you don't have to indent etc
09:01:24 <sshc> mauke: What do you mean?
09:01:29 <mikeg> I'm looking to sum a list of Maybe's. I came up with: sum $ map (fromMaybe 0) [Just 4, Nothing]. Is there a better way?
09:01:48 <ceii> sum $ catMaybes [...]
09:01:50 <sshc> mauke: If I want them on separate lines, I think they need to be indended
09:01:50 <mauke> sshc: what is unclear?
09:02:05 <mikeg> ty ceii 
09:02:06 <mauke> sshc: but not more than "then"
09:02:23 <mauke> sshc: it just has to be indented more than "if"
09:03:00 <Cale> It's equivalent to catMaybes (which is what I was going to recommend before ceii got to it :), but you might also consider sum [n | Just n <- xs]
09:03:10 <sshc> mauke: You mean this?
09:03:11 <sshc> if foo
09:03:17 <sshc> then do
09:03:21 <sshc>     etc
09:03:24 <mauke> no
09:03:41 <mauke> why did you undent the "then"?
09:04:10 <sshc> I want to have the if and the then on the same line, and else with the same indentation
09:04:15 <sshc> if foo then
09:04:19 <sshc>     bar
09:04:22 <sshc> else
09:04:24 <sshc>     etc
09:04:34 <sshc> oops, I forget do
09:04:34 <mauke> sucks to be you
09:04:42 <sshc> But GHC doesn't seem to like that
09:05:13 <mikeg> that's neat, Cale, thx :)
09:05:22 <mauke> you have to indent the "else" at least one space
09:05:39 <Cale> sshc: That's ugly looking :P
09:06:06 <sshc> Cale: There should be a "do" after "then" and "else"
09:06:10 <mauke> sshc: no one forces you to use layout, though. you could always switch to explicit braces
09:06:19 <Cale> Well, it's unnecessary here anyway
09:06:21 <sshc> Cale: It saves one level of indentation, making it it more readable
09:06:42 <Cale> You can put the 'if' and 'then' on the same line, but you should still line up the 'else' under the 'then'
09:06:51 <Cale> Siblings should always align with each other :)
09:07:00 <mauke> I disagree
09:07:11 <Cale> if foo then bar
09:07:11 <Cale>        else quux
09:07:13 <sshc> Could I indent the else by only one space to make that work?
09:07:21 <sshc> In my example
09:07:29 <Cale> sshc: It would *work*, yes
09:07:58 <sshc> Isn't there an extension that lets me use that syntax by placing a semicolon before the else?
09:07:59 <Cale> The actual whitespace sensitivity is far more permissive than most people would recommend :)
09:08:19 * ksf is tempted to rewrite all of protocol buffers to use sane sum types instead of that inefficient hackery
09:08:28 <ksf> ...would also get rid of optional fields. 
09:08:35 <mauke> sshc: that syntax places a semicolon before the else. the extension makes it ignore that semicolon
09:09:15 <sshc> mauke: Does it treat it as whitespace or pretend it doesn't exist?
09:09:24 <sshc> What is the name of the extension, and which versions of GHC support it?
09:10:16 <ksf> otoh, I could just use plain ADTs + derived serialising instances, providing a code generator for let's say lua for starters that can speak in the same binary language.
09:10:58 <sshc> DoAndIfThenElse it seems
09:11:27 <Cale> I'm not sure if that's actually the name of an extension though. That's the name of the proposal to include it in the standard.
09:11:35 <Cale> I really dislike that one.
09:11:46 <Cale> It lets people indent their code improperly. :P
09:11:47 <ksf> basically, a version-safe binary-generic.
09:11:59 <sshc> Cale: Improperly?  I find it much more readable
09:12:26 <ksf> ...shouldn't be a problem to keep old versions around and take them into account when generating the new stuff, after all.
09:12:32 <sshc> I find it at least a little bit more readable, at least
09:12:42 <Peaker> I looked at the alternative Mathy Num class package.. The guy named all of his classes "C" (each in a different module) :-(
09:12:57 <Cale> sshc: The golden rule of indentation is this: things which are part of other things should start in a later column, and things which are siblings should be vertically aligned
09:13:13 <medfly> for a rule of thumb it's pretty long
09:13:24 <sshc> Sounds like a good rule of thumb
09:13:25 <Cale> sshc: That way of writing if/then/else destroys the symmetry between 'then' and 'else'
09:13:26 <Peaker> It's always "T" or "C"
09:13:35 <Peaker> http://hackage.haskell.org/packages/archive/numeric-prelude/0.1.3.4/doc/html/Algebra-Additive.html#t%3AC
09:13:40 <Peaker> Why would he do this?
09:13:45 <sshc> Cale: I'd cocnsider "if ... then do" to be a sibling of "else"
09:14:26 <Cale> sshc: It's not though.
09:14:34 <Peaker> I envy the Python guys that they could break backwards compatibility for Python 3 and are in a real process of migrating.. Whereas with Haskell we're stuck with a wrong class hierarchy, bad Numeric prelude, horrible classes like "Enum" (fromInt/toInt/ugh), ...
09:14:35 <ksf> it's if foo\n   then bar\n    else baz\n
09:14:58 <Cale> sshc: Every if expression requires both a then and an else part. It's not an if statement like in imperative languages.
09:15:15 <Cale> You're defining a single value which is conditional.
09:15:17 <Peaker> If you want an "imperative"-style "if" then there's "when"
09:15:22 <Peaker> @src when
09:15:22 <lambdabot> when p s = if p then s else return ()
09:15:48 <sshc> Peaker: "when" doesn't have an else clause
09:15:53 <Adamant> Peaker: it's a long slow process, and who says it won't happen for Haskell one day. things just aren't That Broken yet.
09:15:56 <ksf> oh wait, binary-generic doesn't generate code.
09:16:06 <Peaker> sshc, well, else-less "if" I meant :)
09:16:34 <Cale> Peaker: Henning Thielemann's style bothers me a lot too. I was considering writing a program to undo the sabotage that he does to his own code, but there are some annoying details.
09:16:54 <Cale> Peaker: Another option would just be to follow him around and fix all his code by hand.
09:17:15 <Peaker> Cale, Is there any other numeric prelude?
09:17:33 <Cale> What are you looking for in particular?
09:18:30 <Peaker> Cale, Well, I was wondering about a type-class for absolute/relative values (e.g: Absolute=date/time, relative=time-diff) and the senseful operations on each of those.  I re-encountered this pattern with pointers and "offsets" (relations between ptrs).  Then I started a class and it seems like it could be an AdditiveGroup or such
09:18:47 <blackdog> getting an odd error message from cabal:
09:18:48 <blackdog> base-4.2.0.0 was excluded because of the top level dependency base -any
09:19:05 <Cale> blackdog: What version of GHC do you have?
09:19:06 <blackdog> any ideas what that means? 4.2 looks like it should satisfy -any to me
09:19:09 <blackdog> HEAD
09:19:40 <Cale> Well, I have no idea what version of base that has.
09:19:42 <sshc> Cale: I think I see your point now: that "else" should be a sibling with "then" and not "if"
09:19:44 <blackdog> unfortunately the mac dylib patches didn't make it in to 6.12.3
09:19:45 <mietek> Is it possible to pattern-match against an opaque type like ByteString?
09:19:48 <Cale> sshc: yeah
09:20:00 <Peaker> Cale, It really sucks to have to re-define (+)/etc in another module when it seems to have the exact same semantics as those of Num
09:20:05 <blackdog> Cale: oh, duh. thank you. it's got 4.3
09:20:09 <blackdog> sorry, not thinking.
09:20:25 <sshc> Cale: I could save whitespace by using guard, but IO isn't an instance of mplus
09:20:40 <sshc> I have an IO () action
09:21:00 <sshc> Cale: Which monad could I put on top of IO only for the purpose of short-circuiting so that guard works?
09:21:21 <Peaker> sshc, I think Control.Monad.Error has a MonadPlus instance for IO.  I think you could use MaybeT/EitherT
09:21:31 <ceii> mietek: no
09:21:40 <sshc> Peaker: I'm using the transformers package
09:21:44 <sshc> Peaker: Which module should I import?
09:21:48 <ceii> You can only pattern-match against exported constructors
09:21:49 <Cale> sshc: er, what are you trying to do?
09:22:01 <sshc> Cale: Use guard in an IO action
09:22:07 <Cale> sshc: To what end?
09:22:13 <Cale> sshc: To catch an exception?
09:22:32 <Cale> Are we talking about:
09:22:33 <sshc> To stop executing the rest of the action
09:22:34 <Cale> :t guard
09:22:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:22:39 <sshc> similar to "return" in an imperitive language
09:22:49 <mietek> ceii: right.  Is there any other way of binding a value to a variable apart from pattern-matchin?
09:22:54 <sshc> Cale: I'm asking where IO is made an instance of MonadPlus in the transformers package
09:23:03 <Cale> Control.Monad.Error
09:23:08 <Cale> It's also in mtl
09:23:17 <sshc> Thanks
09:23:22 <Cale> But that just catches exceptions
09:23:42 <Peaker> sshc, Control.Monad.Trans.Maybe
09:23:46 <Cale> You'd possibly be better off with throw and catch anyway.
09:23:50 <ceii> mietek: yes, just use the functions provided with the type. IOn the case of Bytestring, uncons
09:23:50 <Peaker> I see Transformers' ListT is just as broken as MTL's
09:23:57 <ceii> In*
09:23:59 <Cale> But I don't think any of these suggestions is right.
09:24:05 <Cale> It sounds like you just want when.
09:24:37 <Peaker> sshc, In IO, "mzero" would throw an IO exception. In MaybeT, it would become a Nothing
09:24:48 <Cale> and don't worry about the indentation level so much. If your actions are longer than about 10 lines, you should be splitting them into separate definitions anyway.
09:25:02 <Cale> The indentation level doesn't have time to get very deep inside 10 lines :)
09:25:57 <Cale> when foo $do ...
09:25:59 <Cale> oops
09:26:03 <Cale> when foo $
09:26:05 <Cale>   do ...
09:26:28 <ksf> WTF doesn't one single binary serialisation format exist that I like.
09:26:32 <Cale> There's also unless, which is the opposite of when
09:26:48 <sshc> Cale: "when foo $ do <imperitiveReturn ()> etc.."
09:27:13 <Cale> sshc: unless foo $ do ... the stuff you were going to do after ...
09:27:33 <sshc> Cale: If I use "return", the rest of the action will still be executed when foo is true
09:27:47 <sshc> Cale: I still want to do things when foo is true too
09:27:51 <sshc> before I "return"
09:27:54 <ksf> either they're not schema-based, their concept broken, theyr specs are completely bugged, or they're just way too over-engineered.
09:27:55 <Cale> If you *really* want the imperative return, you could use ContT to transform the IO monad, and wrap your definitions in callCC $ \ret -> ...
09:28:07 <sshc> Cale: I would already considering that :)
09:28:08 <mietek> ceii: so I was hoping to build a quasi-quoter which woul bring Erlang's bitsyntax to Haskell, but it appears that it won't be possible to have it working in patterns.
09:28:12 <mietek> would*
09:28:37 <Cale> sshc: Okay, then you just want if/then/else I suppose.
09:28:58 <sshc> Cale: Then I'll waste too much space
09:29:00 <Cale> sshc: Maybe it seems a bit awkward, but it's also prettier in another way.
09:29:15 <ksf> CPS to the rescue!
09:29:15 <sshc> Yes, it does seem a bit awkward
09:29:28 <Cale> sshc: How many times are you going to nest like this?
09:29:44 <Cale> sshc: It's possible that you want some other sort of control structure, like a decision tree of some sort.
09:29:52 <ceii> mietek: yes, I cn't see how to make that work (without view patterns)
09:30:13 <sshc> Cale: I just want an imperitive style "Return"
09:30:14 <ksf> cps has the nice property of disentangling the decision whether to do the one or other thing and what to do based on that decision.
09:30:45 <Cale> The nice thing about not having an imperative return is that whenever you see a do-block, you can be sure that if its execution completes, then every action inside it was run.
09:30:49 <ksf> foo k k' = do { baz <- bar; if baz then k else k' }
09:30:54 <mietek> ceii: so view patterns aren't part of GHC yet?
09:31:05 <Cale> This gives you algebraic properties that you can use to safely manipulate code.
09:31:25 <Cale> It also ensures that you can see the control flow of a bit of IO code at a glance.
09:31:30 <ceii> they're available as an extension
09:31:41 <mietek> Wait, they are.
09:31:43 <mietek> Aha!
09:31:44 <ksf> mietek, either use view patterns, or quasiquotation.
09:31:56 <Cale> if/then/else with indentation is particularly good in that way -- it makes it completely obvious at a glance that some of the code is conditional
09:32:09 <mietek> ksf: I tried using quasiquotation, but I don't see a way to have pattern matching
09:32:10 <ksf> quasiquoting might lead to faster code.
09:32:27 <mietek> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29706
09:32:31 <ceii> quasituoting needs to generate a TH "Pat"
09:32:54 <ceii> so I don't see how we can make it work without constructors to pattern-match on
09:33:40 <ksf> can't TH generate view patterns?
09:34:01 <ceii> doesn't look like it
09:34:02 <Cale> sshc: A nice thing about do-blocks is that you can always mindlessly chop out some bunch of statements and turn them into a new definition, and just use that definition from the place you chopped the lines out.
09:34:18 <Cale> sshc: Imperative-style returns break that property.
09:34:23 <mietek> I didn't realize view patterns were in already.  I'm going to play with them now, thanks.
09:34:52 <Cale> (because if you chop out a return, you'll only return from the new definition, and not from the code that you spliced it out of)
09:34:53 <ksf> well, then you can always do a function that takes a list of tuples, that is, do your own pattern matching.
09:35:31 <ksf> but in the end view patterns seem to be the better alternative.
09:36:10 <ksf> ...do a return-type polymorphic function that does different thing depending on the pattern you match it against.
09:37:45 <Cale> So while we often don't hesitate to say things like that C is a monad (without recognising it), it actually breaks the monad laws in that respect, and requires pretty severe translation at some points to be a monad.
09:40:03 <hegmo> Hi. I want to represent a Newick format tree in Haskell code, but being new to Haskell I can't find a good way to do it and would appreciate some help getting started. The format is described here: http://en.wikipedia.org/wiki/Newick_format#The_grammar_rules
09:40:07 <hegmo> My first idea was to start with "data Tree = Tree (Either Subtree Branch)" and so on, but that won't work since a tree actually needs to hold Ints and Strings at some point. And Either only works because there's only two options. Ther must be a better way...
09:40:13 <Cale> sshc: I guess it comes down to the fact that the ability to easily refactor code is more important to us than being able to get away with a bit less indentation ;)
09:42:04 <Cale> data Tree = TSubtree Subtree | TBranch Branch
09:42:41 <Cale> data Subtree = Leaf Name | Internal BranchSet Name
09:42:45 <Cale> type Name = Maybe String
09:43:12 <AnAdorableNick> Cale: I hope you don't mind if I quote you 'til "Imperative-style returns break that property" in my code?
09:43:31 <Cale> AnAdorableNick: I don't mind at all
09:43:51 <AnAdorableNick> How hould I credit you?  Is '"blah" - Cale' fine?
09:44:05 <Jon> hi folks. I've got some code that needs to do maps, filters etc. on the first element of a tuple. My code is fairly ugly. I've tried to write convenience functions to tidy it up, like http://paste.debian.net/87794/, but I suspect I'm missing something. Is this something I could use functors for?
09:44:29 <Cale> AnAdorableNick: Sure.
09:44:48 <Cale> (I'm not sure why my comments are going into source code though :)
09:46:03 <Cale> Jon: If you import Control.Arrow, you'll get the handy function  first :: (a -> b) -> (a,c) -> (b,c) -- or you can write it yourself
09:46:16 <Cale> Er, I see.
09:46:43 <Cale> Well, that will be useful in conjunction with map anyway
09:46:49 <Cale> With filter, you can just use fst
09:46:56 <Cale> filter ((<3) . fst)
09:48:07 <Jon> Cale: ah yes, fst does tidy up my filters, removing the need for filterFpair - I will look at arrow, thanks
09:50:39 <hegmo> Cale: Thanks! I completed it thus: http://pastebin.com/5hJ8ry1Y
09:51:08 <Cale> hegmo: good work :)
09:59:07 <iocor> how do I cast a double to a float?
09:59:12 <Jon> Cale: got it working with first - thanks - I'm not quite at the "understanding arrows" stage yet, but this helps â˜º
10:20:45 <sshc> How could importing a module be redundant?
10:22:05 <chrisdone> sshc: nothing from it is used
10:22:20 <chrisdone> i.e. no exported functions or types
10:22:55 <sshc> Thanks
10:27:11 <Jonno_FTW> Is there any libraries for haskell for producing charts?
10:27:18 <Jonno_FTW> or plots?
10:28:33 <Jonno_FTW> nvm
10:28:34 <Peaker> @hackage plot
10:28:34 <lambdabot> http://hackage.haskell.org/package/plot
10:28:43 <Peaker> I just guessed this name :)
10:29:06 <Jonno_FTW> it's called chart
10:29:14 <chrisdone> the maybe monad is a glorious thing
10:29:53 <Jonno_FTW> Just True
10:30:01 <Peaker> The gloriousness of "yet another language feature" that is implemented with simple primitives :)
10:30:21 <chrisdone> :p
10:30:58 <ehamberg> dons: appending "hiding (eventKeyName)" to the Graphics.UI.Gtk import in Cairo.hs seems to fix the vacuum-cairo build. could you upload a new version? :)
10:31:05 <Jonno_FTW> Data/PackedString.hs:83:7:
10:31:06 <Jonno_FTW>     Could not find module `Data.Data':
10:31:06 <Jonno_FTW>       It is a member of the hidden package `base'.
10:31:17 <Jonno_FTW> what is going on here?
10:32:17 <chrisdone> it looks like the cabal package you're attempting to build needs to include `base' in its dependencies
10:32:34 <chrisdone> but what is *really* going on?
10:32:58 <Jonno_FTW> I think someone isn't maintaning their packages .cabal file properly
10:34:20 <Jonno_FTW> But base is in the build-depends
10:55:48 <sshc> How do I use transformer's "asks" without explicitely using "lift"?  Or even "ask", since I could write "asks" in terms of "ask"
10:56:10 <ezyang> sshc: Write a MonadReader instance for your transformer. 
10:56:19 <ezyang> but that might be orphaned, depending on what your instance is 
10:57:08 <aavogt> @tell Jonno_FTW for some reason recent ghcs base-3 doesn't include Data.Data (or it never did), while base-4 does include the module... so change the package to use a newer base... or maybe the packed string dep shouldn't be there in the first place
10:57:08 <lambdabot> Consider it noted.
10:58:25 <benmachine> packedstring is supposed to go away
10:58:52 <sshc> ezyang: asks :: (Monad m) => (r -> a) -> ReaderT r m a
10:59:21 <ezyang> yeah, that's not generic enough. 
10:59:37 <ezyang> I guess mtl does this differently. 
11:00:03 <sshc> Is it possible to do this with transformers or is there a better monad package?
11:01:45 <Peaker> I find naming the explicit layer you want to get to as a reasonable thing.. the "liftSomeSuch" doesn't bother me much
11:02:36 <sshc> Ah, monads-fd and monads-tf
11:02:42 <sshc> Wonderful.
11:17:46 <chrisdone> Booo!
11:18:28 <raichoo> <interactive>:1:5: parse error (possibly incorrect indentation)
11:18:37 <raichoo> :P
11:21:58 <chrisdone> I never noticed how poor haskell's parse error messages are
11:22:02 <chrisdone> well, ghc's
11:22:39 <chrisdone> I suppose syntax errors don't happen enough for it to matter
11:22:45 <Nibble> chrisdone: :P
11:22:53 <Nibble> what syntax?
11:23:01 <ninechars> chrisdone: 6.14 fixes that i think
11:23:14 <ninechars> or at least i saw a bunch of commits to seemingly that effect
11:23:32 <chrisdone> ninchnice
11:23:43 <chrisdone> haha, damnit. you changed nick during my tab completion
11:23:50 <illissius> :p
11:24:48 <illissius> I'm looking at Control.Monad.Prompt, and there's data {,Rec}Prompt{,T}, and functions using them, but no way, as far as I can tell, to actually construct one.
11:24:54 <bnery> hi guys
11:24:57 <illissius> anyone know what I'm missing?
11:25:13 <bnery> little question about *record syntax*
11:25:20 <bnery> suppose I have
11:25:27 <ajnsit> I'm trying to optimise a haskell solution to a small programming problem
11:25:33 <ajnsit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29710#a29710
11:25:45 <ajnsit> the problem description is here - http://www.codechef.com/SEPT10/problems/FIRE/
11:25:48 <bnery> data Person = Person { name :: String }
11:25:59 <bnery> and data Company = Company { name :: String }
11:26:04 <ajnsit> could anyone please suggest a way to make this run faster?
11:26:09 <bnery> how do I avoid function name clash?
11:26:19 <mauke> bnery: give them different names
11:26:31 <bnery> mauke: is that the only solution?
11:26:34 <mauke> yes
11:26:37 <ajnsit> There is a lot of list manipulation and I tried to replace things with Set and Map
11:26:42 <ajnsit> it is still too slow
11:26:46 <illissius> (a) what mauke said, (b) put them in different modules and use them qualified, (c) iirc GHC has some kind of extension for this?
11:26:55 <kmc> you can give them different names, then create a type class to map one name to those names by type
11:27:00 <kmc> it's probably not worth doing though
11:27:02 <illissius> (DisambiguateRecordFields? but maybe that does something different, never used it.)
11:27:17 <kmc> illissius, it won't work in the case where you use a label as a selection function
11:27:20 <bnery> kmc I'm still a newbie so I didn't get to type classes yet :)
11:27:36 <kmc> (that'd be a serious perversion of the type system)
11:27:44 <kmc> it works within updates
11:27:45 <bnery> illissius I though about the "different modules" idea, just imagined there should be an easier way
11:27:47 <chrisdone> illissius: the data constructor isn't exported?
11:27:54 <illissius> kmc: you mean serious _improvement_!
11:27:56 <kmc> you can say T { f = x } rather than T { M.f = x }
11:27:57 <illissius> TDNR would be nice to have.
11:28:14 <illissius> chrisdone: doesn't seem to be.
11:28:19 <kmc> ajnsit, loot at Data.IntMap and Data.IntSet
11:28:26 <chrisdone> it is exported
11:28:35 <chrisdone> > module Control.Monad.Prompt (
11:28:36 <chrisdone> >     MonadPrompt(..),
11:28:36 <chrisdone> >     Prompt,                           <- right here
11:28:36 <lambdabot>   <no location info>: parse error on input `..'
11:28:37 <lambdabot>   <no location info>: parse error on input `module'
11:28:37 <lambdabot>   <no location info>: parse error on input `,'
11:28:50 <aristid> chrisdone: *tsk*
11:28:56 <illissius> chrisdone: that's the type itself, not the constructor
11:28:58 <kmc> ajnsit, they are much faster drop-in replacements for Map and Set in the case of Int keys
11:29:14 <chrisdone> illissius: oh yeah, hmm
11:29:14 <bnery> thanks guys!
11:29:25 <kmc> ajnsit, there are also EnumMap and hashmap packages on hackage, which generalize that speed gain to types other than Int
11:29:25 <ajnsit> kmc, Thanks I'll check it out!
11:29:44 <chrisdone> illissius: well it's an instance of monad so return will construct one
11:30:18 <illissius> oh, right.
11:31:12 <illissius> sadly enough I was actually thinking about that, but for some reason I thought that wouldn't work and I'd need something like Monoid or Data.Default.
11:31:15 <illissius> brain fart, obviously.
11:33:01 <chrisdone> the docs file pretty much explains it all
11:33:03 <chrisdone> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html#runPrompt
11:34:37 <chrisdone> are you using this as an alternative to ContT?
11:35:46 <illissius> chrisdone: I'm just reading up on it so that when I come across a use case I'll know about it :)
11:35:59 <chrisdone> http://paste.tryhaskell.org/paste/68/monad_prompt bit more readable :p
11:36:05 <chrisdone> ah, ok
11:36:37 <Twey> chrisdone: Your site is too narrow â˜¹
11:36:52 <illissius> chrisdone: even better: http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.2/doc/html/Control-Monad-Prompt.html
11:36:58 <Twey> The actual paste box only takes up about half my available horizontal screen real-estate
11:37:06 <Twey> The rest is wasted on whitespace
11:37:32 <djahandarie> Twey, zoom the page then
11:38:13 <Twey> djahandarie: Um, that just makes the text bigger â€” I can't fit any more on a line
11:38:35 <Twey> Is that *pixel-sized*?!
11:38:35 <djahandarie> So then what is the actual problem?
11:38:45 <chrisdone> Twey: sure, I'll make it full width
11:38:46 <illissius> zoom it and then set a smaller font size :p
11:39:01 <Twey> chrisdone: A reasonable margin would be okayâ€¦ say 5em either side
11:39:03 <djahandarie> Ugh, fluid width layouts are painful
11:39:34 <Twey> djahandarie: Almost as painful as static-width ones
11:39:37 <djahandarie> The character length of a line is very important to keep to a reasonable amount for readability
11:40:53 <Twey> djahandarie: I'm guessing you don't resize your windows very often :Ã¾
11:40:58 <djahandarie> If you want to utilize the extra horizontial space you need to either put your text in columns (doesn't work on the internet) or come up with different layouts for varying screen sizes
11:41:02 <Twey> Full-screen browser all the time?
11:41:35 <Twey> Um, or else just specify the relationships between various elements rather than attempting to turn a Web page into a pixel-sized image
11:41:36 <kmc> @pl \n -> let [a,b] = map (n `mod`) [5,3] in case (a,b) of (0,0) -> "FizzBuzz"; (_,0) -> "Fizz"; (0,_) -> "Buzz"; _ -> show n
11:41:36 <lambdabot> (line 1, column 11):
11:41:36 <lambdabot> unexpected "["
11:41:36 <lambdabot> expecting "()", natural, identifier or "in"
11:41:53 <chrisdone> I don't want to add a margin. it would ruin this: http://img535.imageshack.us/img535/2710/92280907.png
11:42:01 <Twey> I appreciate that CSS, especially the subset of CSS supported by IE, isn't excellent at this task
11:42:23 <kmc> @pl \n -> case map (n `mod`) [5,3] of [0,0] -> "FizzBuzz"; [_,0] -> "Fizz"; [0,_] -> "Buzz"; _ -> show n
11:42:23 <lambdabot> (line 1, column 41):
11:42:23 <lambdabot> unexpected ">" or "-"
11:42:23 <lambdabot> expecting variable, "(", operator or end of input
11:42:31 <aristid> :t \n -> let [a,b] = map (n `mod`) [5,3] in case (a,b) of (0,0) -> "FizzBuzz"; (_,0) -> "Fizz"; (0,_) -> "Buzz"; _ -> show n
11:42:32 <lambdabot> forall a. (Integral a) => a -> [Char]
11:42:32 <djahandarie> Twey, again, just using percentages and such allows line lengths to go out of control
11:42:38 <kmc> stupid @pl
11:42:41 <aristid> kmc: i think @pl does not like case
11:42:53 <kmc> yeah
11:43:05 <chrisdone> I'm only supporting IE8. the site is usable on ie6 and 7 but I don't care about niceties. SPJ is the only Haskeller using Windows, fact
11:43:10 <kmc> chrisdone, i like your paste site
11:43:10 <Twey> djahandarie: And *that's* what text-resizing is for.  There's also the em, which is *much* better if you want to define elements in terms of how much text they should hold.
11:43:17 <aristid> > (\n -> let [a,b] = map (n `mod`) [5,3] in case (a,b) of (0,0) -> "FizzBuzz"; (_,0) -> "Fizz"; (0,_) -> "Buzz"; _ -> show n) 4
11:43:18 <lambdabot>   "4"
11:43:32 <aristid> > (\n -> let [a,b] = map (n `mod`) [5,3] in case (a,b) of (0,0) -> "FizzBuzz"; (_,0) -> "Fizz"; (0,_) -> "Buzz"; _ -> show n) 0
11:43:33 <lambdabot>   "FizzBuzz"
11:43:43 <Twey> chrisdone: I see at least a couple of ems of margin around that in your screenshot :Ã¾
11:43:51 <aristid> :t (\n -> let [a,b] = map (n `mod`) [5,3] in case (a,b) of (0,0) -> "FizzBuzz"; (_,0) -> "Fizz"; (0,_) -> "Buzz"; _ -> show n) =<< [0..]
11:43:51 <lambdabot> [Char]
11:43:53 <djahandarie> Twey, if it is defined in em then it won't be fluid...
11:43:56 <aristid> > (\n -> let [a,b] = map (n `mod`) [5,3] in case (a,b) of (0,0) -> "FizzBuzz"; (_,0) -> "Fizz"; (0,_) -> "Buzz"; _ -> show n) =<< [0..]
11:43:57 <lambdabot>   "FizzBuzz12Fizz4BuzzFizz78FizzBuzz11Fizz1314FizzBuzz1617Fizz19BuzzFizz2223F...
11:44:23 <Twey> djahandarie: No, but it will at least be sane (which isn't a guarantee with pixel layouts: they tend to scale in the opposite direction intended, in terms of real-world size)
11:45:06 <djahandarie> Twey, I don't really understand what your problem is with the current layout I guess
11:45:27 <chrisdone> Twey: well, it's a 20px margin. wouldn't make sense to use em for the body padding
11:45:40 <Twey> djahandarie: That's okay: chrisdone gets it :Ã¾
11:45:49 <chrisdone> http://paste.tryhaskell.org/ <- here's the layout full width
11:45:54 <Twey> chrisdone: No?  Why not?
11:46:00 <chrisdone> it's the latest pastes table that becomes annoying to read though
11:46:12 <Twey> chrisdone: Ah, that's lovelyâ€¦ thanks
11:46:26 <Twey> Eh, it's okay
11:46:44 <Twey> Could maybe right-align the titles?  Would that be hideous?
11:46:55 <chrisdone> we can try it :p
11:47:11 <chrisdone> refresh
11:47:19 <chrisdone> hm, no. um
11:47:34 <Twey> Don't see it
11:47:41 <copumpkin> chrisdone: can you make an agdapaste too? kthx!
11:47:43 <Twey> Oh
11:47:44 <djahandarie> It looks even worse than whatever you are seeing on a 2560x1600 screen
11:47:49 <Twey> Haha, you right-aligned the table headers
11:47:51 <geheimdienst> chrisdone, i think he meant right-align the <a>s
11:47:52 <chrisdone> djahandarie: yah
11:48:06 <geheimdienst> right-align the 1st column
11:48:10 <chrisdone> you said titles, I thought you meant the headers :p
11:48:32 <copumpkin> djahandarie: omg 30" screen
11:49:01 <chrisdone> Twey: it's easier to make the table not 100%
11:49:10 <geheimdienst> chrisdone, could you try taking away the "width=100%" for the table? i think if it was just as large to accomodate the contents ...
11:49:16 <chrisdone> yeah, just did
11:49:22 <geheimdienst> ;-)
11:49:23 <Twey> chrisdone: Maybe with some padding :Ã¾
11:49:28 <chrisdone> I agree, sec
11:49:39 * geheimdienst thinks little padding, good to go
11:49:49 <djahandarie> I really think the design was much better fixed-width
11:49:53 <djahandarie> Now it is really lopsided
11:50:03 <Arsole> @hoogle creal
11:50:04 <lambdabot> No results found
11:50:34 <copumpkin> fixed-width ftw
11:50:36 <geheimdienst> djahandarie, 80% of all text is left-aligned ... do you feel that's lopsided too? ;-)
11:50:42 <copumpkin> ftw = fix the width
11:51:01 <Arsole> what package are creal in?
11:51:24 <chrisdone> so there it is with a bit of padding
11:51:34 * copumpkin giggles
11:51:36 <Twey> chrisdone: That's nice â˜º
11:51:38 <djahandarie> geheimdienst, yes, to some degree it is lopsided but nothing I can't deal with. If web browsers could do proper justifcation that would certainly be better
11:51:43 <luite> hmm, I think it doesn't look that bad on a 30" screen
11:51:43 <Twey> chrisdone: Thanks!
11:51:53 <Twey> luite: You have a 30"?
11:52:15 <luite> Twey: yes a dell
11:52:32 <chrisdone> supposing I put a little toggle button at the top right 
11:52:36 * copumpkin used to too :(
11:52:44 <Twey> chrisdone: Does it persist?  :Ã¾
11:52:48 <chrisdone> it would
11:52:59 <Twey> Alright then
11:53:03 <luite> it's madness to use a browser full-screen on such a monitor though
11:53:11 <Twey> luite: Yeah
11:53:34 <Twey> Wide should be the default, thoughâ€¦ function over form for those without the Javascript to choose 
11:53:36 <copumpkin> chrisdone: any plans to support per-line annotations? so someone can submit some code and I can say "this sucks", "why the hell are you doing it this way??" and stuff like that, on each line
11:53:44 <chrisdone> Twey: sure!
11:53:52 * geheimdienst has the browser take 60% of the screen and irc windows 40%. 17" laptop screen, that is.
11:54:00 <chrisdone> copumpkin: basically, editing? or what?
11:54:14 <luite> I like having the browser take ~30% of the screen width
11:54:17 <copumpkin> chrisdone: just commenting on existing code, a bit like github's comment feature
11:54:23 <djahandarie> Twey, like I have been attempting to argue, I don't see any gained fucntion from this fluid-width layout. In fact I feel that on most sites a fluid-width layout reduces function.
11:54:30 <copumpkin> chrisdone: so I wouldn't be able to edit the code, but I can comment on specific parts of it
11:54:33 <chrisdone> I've seen the comment feature, but does it allow you to highlight a specific line?
11:54:52 <Twey> djahandarie: It gives more space in which to work
11:55:19 <djahandarie> Twey, do you want a 1000ft wide desk?
11:55:25 <Twey> (also, on e.g. a 30" display, 700px is going to be *tiny*)
11:55:31 <Twey> I would if my arms could reach, sure
11:55:38 <nlogax> chrisdone: a small thing: the logo could use a height, to stop the page from jumping when it loads
11:55:40 <chrisdone> no we have a good compromise here
11:55:40 <Twey> Actually, I probably would anyway
11:55:43 <copumpkin> chrisdone: http://snapplr.com/ktvp
11:56:01 <copumpkin> chrisdone: next to the line in a particular commit, you can click and comment
11:56:07 <chrisdone> full width without javascript, fixed with javascript with a toggle button
11:56:24 <chrisdone> copumpkin: hey that's neat. and how does it display?
11:57:09 <copumpkin> just a sec
11:57:19 <chrisdone> nlogax: oh, thanks. I didn't notice
11:58:07 <copumpkin> chrisdone: http://snapplr.com/tvn2
11:58:16 <copumpkin> chrisdone: and I can hide them 
11:58:33 <chrisdone> :D
11:58:38 <chrisdone> hmm
11:58:40 <chrisdone> interesting
11:58:51 <chrisdone> I'll add that to my todo
11:59:11 <copumpkin> yay
11:59:27 <geheimdienst> could you embed a little irc client, so you could in any line have a little irc discussion ...?
11:59:29 <geheimdienst> ;-)
11:59:46 <Twey> Hehehe
11:59:52 <chrisdone> IRC is on my list too
11:59:55 <luite> add a twitter feed for each line too
12:00:04 <copumpkin> chrisdone: did you talk to glguy about this btw?
12:00:14 <copumpkin> (since I think he wrote the original hpaste)
12:00:15 <chrisdone> Sessions for quickly editing mistakes for just-posted hpastes, Checkbox for pastes being editable by anyone, Inline comments, Hlint, Tryhaskell prompt support, Context in IRC, Revisions, Hoogle support ("links") on symbols, Unit tests, CGI search page with pagination,  paste viewer,  new paste, RSS feed
12:00:15 <chrisdone>  
12:00:18 <BONUS> or another, smaller, paste site into each paste
12:00:23 <chrisdone> which original hpaste?
12:00:34 <chrisdone> he wrote hpaste2. who wrote hpaste1?
12:00:43 <copumpkin> oh, I thought he did both
12:00:46 <chrisdone> ah, ok
12:01:20 * chrisdone rmoves "paste viewer, new paste" from his todo list..
12:02:35 <chrisdone> no. I tried hacking on the hpaste2 source and found it hard to understand
12:03:09 <copumpkin> preflex: seen glguy
12:03:09 <preflex>  glguy was last seen on #haskell 10 days, 1 hour, 41 minutes and 40 seconds ago, saying: :t let x = 5 ; y = 15 ; z = x / y in x :: (Fractional t) => t
12:03:54 <BONUS> chrisdone how do you manage to be so productive
12:04:13 <chrisdone> haha
12:04:28 <chrisdone> I get haskell evenings and weekends
12:04:32 <BONUS> i guess its easier when you dont slack off 90% of the time (like me)
12:04:43 <chrisdone> aw /o/
12:05:05 <Peaker> F# doesn't have type-classes, right?
12:05:09 <BONUS> the more i think about this node.hs thing, the more i think it could work
12:05:14 <BONUS> and be useful
12:05:45 <djahandarie> BONUS, stop thinking and start doing? ;)
12:06:26 <BONUS> idneed. i'm getting to know node.js a bit more now
12:06:33 <BONUS> and examining the source etc
12:08:49 <Heffalump> Peaker: correct
12:10:01 <Peaker> Heffalump, I wonder why
12:10:24 <Peaker> Type-classes seem like such an easy way to get a huge boost of power.. why would any language designer aware of them choose not to have them?
12:10:49 <ceii> because they have a lot of overlap with OOP, I guess
12:10:49 <BONUS> that's a good question lol
12:10:56 <kmc> there's some serious issues with them
12:11:04 <ceii> and almost every language designer wants to build an OO language
12:11:06 <kmc> for example classes and instances aren't first-class in Haskell
12:11:12 <kmc> it's hard for us to control their scope, importing, etc.
12:11:35 <Peaker> ceii, TC's are so much nicer than OO-style polymorphism, it's a mystery why one would choose OOP over TC
12:11:42 <kmc> they're not the same thing at all
12:11:51 <kmc> they don't solve the same problems
12:11:59 <kmc> OO-style polymorphism is solved by putting functions in records
12:11:59 <Peaker> kmc, OO Interfaces and TC's have a lot of overlap
12:12:12 <kmc> i disagree
12:12:21 <Peaker> IComparable/Ord
12:12:22 <kmc> interfaces in OO are typically used as supertypes
12:12:32 <Daniel> Hi all, I found this channel via "Try Haskell", but, is there a more direct way? Thanks
12:12:42 <kmc> type classes aren't types, and languages with type classes needn't have subtyping at all
12:12:43 <Twey> Daniel: We are #haskell on irc.freenode.org
12:13:12 <Twey> Daniel: Install an IRC client, or connect via the official Freenode Web client at http://webchat.freenode.net/
12:13:36 <Peaker> kmc, I find that subclassing and "subtyping" are almost never really related in practice
12:14:37 <Daniel> Twey: Thanks a lot.
12:15:43 <copumpkin> Peaker: how so?
12:17:33 <ajnsit> is there a faster way to read a list of integers from std input than getLine?
12:17:59 <ajnsit> I realised that I was tweaking the algorithm but the IO is the bottleneck
12:19:43 <chrisdone> Twey: Try Haskell is the flute and I'm the partially applied piper
12:19:48 <kmc> String is generally an inefficient type
12:20:00 <kmc> maybe you can use ByteString IO
12:20:43 <Twey> chrisdone: Hehehe
12:22:29 <luite> ByteString is always the answer
12:26:04 <Peaker> copumpkin, Usually people use subclasses for either: Instantiating interfaces/polymorphism, Sharing code (in a perverse way, IMO) or type-products with method forwarding defaults.. I don't find any of these uses consistent with "subtype" (which I see as having a type with a subset of the values of another type, sort of like a GADT with different constructor type indices)
12:26:30 <jeffwheeler> If I install a package (Gtk stuff) globally, can user-level packages depend on it?
12:26:31 <notabel> bytestring became much more palatable to me when i discovered XOverloadedStrings
12:26:38 <copumpkin> I mean, if I have a list of "views" in my GUI app, they're all subtypes of some view superclass
12:26:47 <jeffwheeler> Or do I need to install Gtk as user-level?
12:26:48 <kmc> OverloadedStrings for ByteString is a lie though
12:26:50 <chrisdone> luite: if I'm tied up with some thin rope like material how do I escape?
12:26:54 <kmc> since it can't represent most unicode codepoints
12:27:02 <Heffalump> Peaker: interfaces and type classes have some overlap and some differences
12:27:21 <Heffalump> and on .NET, interfaces already exist, but the machinery for dictionary-passing for type classes doesn't.
12:27:55 <notabel> kmc: really?  i've never tried unicode in bytestrings, now that i think about it, but what happens?
12:28:12 <notabel> does toString just choke, or is the bytestring produced incorrectly encoded?
12:28:18 <luite> chrisdone: hehe :)
12:28:28 <Peaker> Heffalump, the machinery could be the F# compiler automating that?
12:28:38 <chrisdone> amelie outputs utf8 as a bytestring, using the delicious blazehtml library
12:28:39 <luite> codepoints are truncaded
12:29:13 <notabel> ah, okay.  that's nasty indeed
12:29:36 <chrisdone> way to much packing and unpacking going on though
12:29:46 <notabel> would it be possible to define an alternative IsString instance that would, eg, encode as UTF-8
12:30:04 <chrisdone> I've got String, Data.Text, Data.ByteString.Lazy.Char8 and Data.ByteString.Char8 all over the place
12:30:18 <Heffalump> Peaker: the more stuff it automates like that, the less compatibility you get with the rest of .NET
12:30:47 <chrisdone> notabel: Data.Text is a fast string library specifically aimed at being fast and supporting unicode
12:31:24 <notabel> okay, interesting.  how efficient is marshalling between ByteString and Text?
12:31:29 <chrisdone> you create your strings with data.text and then once you're ready to output to a socket or something you can render it to UTF8 and, if you like, convert to ByteString
12:31:33 <notabel> (or tell me to read the docs, which i'm doing anyway)
12:31:35 <Peaker> Heffalump, Sounds like they're only allowed to innovate as long as the result is .NET-like :)
12:32:02 <chrisdone> I think it's aimed at being efficient Text->ByteString
12:32:59 <chrisdone> but yeah blazehtml is the perfect example. all its string operations are Data.Text and then its rendering functions can output UTF8 ByteStrings
12:35:34 <notabel> okay, i see now that Data.Text is the Right Way for dealing with character data.  I'll keep my bytestrings in the networkt modules :-)
12:36:00 <kmc> yup
12:36:05 <kmc> bytestring is a string of bytes ;)
12:36:51 <kmc> Text -> ByteString would involve encoding wrt some unicode encoding like UTF-8
12:36:56 <kmc> ByteString -> Text the inverse
12:37:55 <chrisdone> same as String really
12:38:15 <chrisdone> (String -> ByteString and back)
12:38:39 <kmc> yeah
12:39:25 <kmc> ByteString.Char8 is ByteString bundled with a defective and fast Unicode encoding
12:39:42 <copumpkin> unicode?
12:39:49 <copumpkin> the encoding being "truncate" ? :P
12:39:53 <kmc> yes
12:39:57 <copumpkin> awesome
12:40:08 * copumpkin has an infinite compression scheme to sell kmc
12:40:12 <chrisdone> trunicode
12:40:23 <geheimdienst> trunciode
12:40:31 <vanadium> Interpreting a series of bytes as 7-bit ascii does not sound too defective to me
12:40:35 <chrisdone> Uh, oh! trunciode is evolving
12:40:44 <lispy> I don't think it's actually truncate
12:40:48 <vanadium> Also, get out, copumpkin, no peddling scheme in #haskell
12:40:54 <kmc> it's defective at encoding Unicode
12:41:10 <notabel> so, does Data.Text convert to UTF-16 regardless of the input and output encodings?
12:41:24 <geheimdienst> omg it's 7-bit ascii in 8-bit bytes! what a waste of storage! lemme optimize that
12:41:35 <lispy> A 4-byte encoded utf8 char would become a length 4 ByteString.Char8 string
12:41:39 <notabel> or does it just unpack the native encoding into Word16 regardless of its codepoint width?
12:41:40 <chrisdone> IIRC tom said it was UCS underneath
12:42:07 <kmc> lispy, yes, which means the "Char" you get out of ByteString.Char8 is not a unicode codepoint at all
12:42:16 <lispy> kmc: yes, that's true
12:42:30 <kmc> but the Haskell type "Char" generally represents Unicode codepoints
12:42:40 <Twey> 20:39:02 < kmc> ByteString.Char8 is ByteString bundled with a defective and fast Unicode encoding
12:42:44 <Twey> Isn't it Latin-1
12:42:44 <Twey> ?
12:42:57 <vanadium> Is that necessarily a contradiction?
12:42:57 <Twey> (this just being a handy Unicode-compatible eight-bit charset)
12:43:03 <Twey> Heh, fair enough
12:43:04 <kmc> yeah
12:43:04 <lispy> kmc: I was only objecting to the idea that it truncates things to 8 bits
12:43:24 <kmc> lispy, if you put in a Char whose codepoint value is above 255, it will truncate it
12:43:35 <lispy> kmc: you can actually set things up so that you can safely roundtrip [Char8] -> [Char] and back again
12:43:56 <kmc> sure.  that roundtrip is Unicode decoding/encoding
12:43:59 <kmc> but Char8 isn't a type anyway
12:44:15 <kmc> BS.Char8 uses Char, but in a nonstandard way
12:44:26 <kmc> anyway enough vigorous agreement
12:51:40 <sshc> What is the default precedence?
12:52:47 <lispy> sshc: function bindings
12:52:48 <avenge> infixl 9
12:52:53 <avenge> for infix you mean?
12:52:56 * lispy totally misunderstood :)
12:52:57 <sshc> Yes
12:53:22 <sshc> 9 is the highest possible precedence, yes?
12:53:31 <lispy> 9000
12:53:34 <avenge> 10 is for function application.  9 is the highest you can assign.
12:53:56 <sshc> I see.  Thanks, avenge 
12:55:26 <avenge> I often like to refer to this page for precendence:
12:55:26 <avenge> http://www.haskell.org/onlinereport/standard-prelude.html
12:56:05 <avenge> One thing I wish I understood better is how infix precedence intracts with \ and ->.
12:56:35 <Peaker> I don't understand why  x INFIX do      is OK, but x do  is not
12:57:02 <lispy> > \x -> 1 + 3 `seq` 4 $ 4
12:57:03 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> b)
12:57:03 <lambdabot>    arising from a use of `...
12:57:05 <Peaker> When I show Haskell to people, showing off various combinators on actions (Look how easy it's to extend the language!) The need for that "$" there is always awkward and I have to hand-wave it away
12:57:08 <avenge> Peaker:  I didn't know that, but that's a good example of stuff that confuses me.
12:57:12 <lispy> > \x -> 1 + 3 `seq` 4 ) 4
12:57:13 <lambdabot>   <no location info>: parse error on input `)'
12:57:15 <lispy> > (\x -> 1 + 3 `seq` 4 ) 4
12:57:16 <lambdabot>   4
12:57:31 <Peaker> forever do { ... }        <-- disallowed.      forever $ do { ... }    "Your language is line-noise!"
12:57:48 <luite> > show $ do { x <- [1,2]; return x }
12:57:49 <lambdabot>   "[1,2]"
12:58:07 <arw> Peaker: forever ( do { ...} )?
12:58:46 <avenge> Yeah, so what is the logic for how tightly braces bind?
12:58:50 <Peaker> arw, But why can't "do { .. }" be an atomic syntactic unit
12:59:00 <avenge> I can say:  f x { field = value }, right?
12:59:09 <lispy> > :t \x -> x . (+1)
12:59:10 <lambdabot>   <no location info>: parse error on input `:'
12:59:10 <avenge> but not f do { something }?
12:59:15 <lispy> :t \x -> x . (+1)
12:59:16 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
12:59:17 <Peaker> arw, Putting () around the "do" just makes it look like not really practical (Lispish ))))) at the end)
12:59:35 <lispy> :t (\x -> x) . (+1)
12:59:36 <lambdabot> forall a. (Num a) => a -> a
12:59:48 <lispy> avenge: does that help?  (.) is infixr 9
12:59:49 <avenge> And especially if you use braces, you shouldn't additionally need parrens.
12:59:54 <lispy> avenge: and those parens change things
13:00:40 <avenge> lispy: So you are saying -> is lower precedence than 9?
13:01:00 <lispy> avenge: the body of the lambda extends as far to the right as possible
13:01:26 <avenge> lispy: Meaning -> has precedence -1?
13:02:11 <avenge> But I swear I've had situations where I have stuff like:
13:02:11 <avenge> Constructor \x -> whatever x
13:02:12 <avenge> or something, and it doesn't work if I don't put a $ before the \x.
13:02:12 <lispy> avenge: I don't know, I don't know how to think in terms of precedence numbers
13:02:31 <lispy> avenge: yes, you would need ($) there
13:02:49 <arw> Peaker: haskell syntax has enough special cases anyways, i do consider some more $ or () less ugly than a special handling of 'do {}'
13:02:50 <avenge> lispy:  Why?  How is it being parsed without the $?
13:02:56 <JoeyA> You can say mapM_ print [1..10] instead of putStr $ unlines $ map show [1..10].  Is there a similar trick for reading all lines?
13:03:07 <lispy> > Just \x -> x
13:03:08 <lambdabot>   <no location info>: parse error on input `\'
13:03:14 <JoeyA> Or should I just do lines <$> getContents ?
13:03:24 <Peaker> > map (*5) do return 5
13:03:25 <lambdabot>   <no location info>: parse error on input `do'
13:03:28 <avenge> > Just $ \x -> x
13:03:29 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
13:03:29 <lambdabot>    arising from a use of `...
13:03:30 <Peaker> arw, why is this a syntax error?
13:03:35 <Peaker> > map (*5) $ do return 5
13:03:36 <lambdabot>   [25]
13:03:40 <Peaker> arw, and this isn't?
13:03:55 <Peaker> arw, I think it looks like the current way is a special case
13:04:06 <lispy> avenge: I think the answer to that question is simply that the grammar doesn't allow (Constructor \_ ....)
13:04:36 <deech> Hi all I was reading about GHC's pragma and was confused by the ANN pragma. What does it do?
13:04:45 <arw> Peaker: yes and no. do {} is a special case, yes. but why make it more special?
13:04:57 <lispy> deech: is it for annotating the AST?
13:05:06 <lispy> deech: (I've never heard of this pragram, just guessing by name)
13:05:13 <lispy> pragma*
13:05:47 <Peaker> arw, I am not sure why one is more "special" than the other... It would be nice if "do" was just a block you could pass around, without () around it, as there's already {} or layout around it
13:05:54 <avenge> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html#annotation-pragmas
13:06:14 <deech> lispy: I dunno. They use the example of annotating 'foo = ...' with {-# ANN foo (Just "hello") #-}. I'm not sure what that does.
13:06:31 <deech> avenge: That's the source I was looking at.
13:07:02 <arw> Peaker: hm, right, if you put it that way?
13:07:08 <arw> s/?/./
13:08:02 <lispy> deech: I don't really know what you'd use it for.  But they say: This data can then be inspected at a later date by using GHC-as-a-library.
13:08:57 <deech> lispy: Yeah I was reading the same thing and I really don't understand any of it. Guess that means I don't need it!
13:09:16 <andyjgill> Does anyone know if there is a way to force a \n at the end of the Haskell Pretty library generated text? Other than text "\n"?
13:10:01 <avenge> lispy: I think what you were trying to tell me is this (from http://www.haskell.org/onlinereport/syntax-iso.html):
13:10:01 <avenge> "In both the lexical and the context-free syntax, there are some ambiguities that are to be resolved by making grammatical phrases as long as possible, proceeding from left to right (in shift-reduce parsing, resolving shift/reduce conflicts by shifting). In the lexical syntax, this is the "maximal munch" rule. In the context-free syntax, this means that conditionals, let-expressions, and lambda abstractions extend to the right as far as
13:10:01 <avenge> possible."
13:10:10 * illissius also expresses agreement with Peaker's sentiments
13:10:20 <sshc> What is a cross-platform way to get the number of microseconds that has passed since some point (the start of the process, January 1970, or whatever)?
13:11:03 <dankna> sshc: man 2 time
13:11:07 <dankna> sshc: but it won't work on Windows
13:11:30 <mauke> time will work on windows, but doesn't do microseconds
13:11:30 <dankna> if you just need to measure a time interval, I think there's something in the "time" package for that
13:11:30 <Kaerigan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29716#a29716 could someone please help me with this? I really have no clue how to solve it.
13:11:39 <dankna> oh, micro, yeah, hm
13:11:59 <dankna> I personally use ... let me check
13:12:06 <lispy> avenge: yeah.  I was actually quoting the rules of lambda-calc as I learned them :)
13:12:59 <dankna> "time" package, Data.Time.Clock.POSIX module, getPOSIXTime
13:13:13 <dankna> it returns a real number
13:13:20 <dankna> to whatever precision is available on the host OS
13:13:40 <dankna> it's in seconds, so to get microseconds you can multiply by the appropriate factor
13:14:22 <deech> Kaerigan: My/Lib.hs Works fine for me. 
13:14:33 <Kaerigan> deech: What the...
13:14:45 <dankna> Kaerigan: it's odd that it's saying the error is on line one, column 45.  there is no = character on line one.
13:15:08 <dankna> OH
13:15:16 <BONUS> lol
13:15:18 <dankna> you're on Windows, as I intuit from the \ in the filename
13:15:23 <dankna> and you've messed up line-ending characters somehow
13:15:30 <Kaerigan> Goddamnit
13:15:39 <sshc> I'm looking at "NominalDiffTime", which, according to the documentation, "has a precision of 10^-12 s"
13:15:42 <dankna> it's reading the entire file as one long line
13:16:10 <dankna> sshc: yeah, I believe a POSIXTime is defined as a synonym for a NominalDiffTime.
13:17:23 <Kaerigan> dankna: That was it, now it works. Thanks.
13:17:36 <sshc> But the constructor isn't exported, so I can't look at the value in a meaningful manner
13:17:50 <sshc> I need at *least* the precision level of milliseconds, not seconds
13:17:52 <dankna> Kaerigan: no problem
13:17:56 <sshc> Preferably microseconds
13:17:58 <dankna> sshc: one sec, let me check the docs
13:19:02 <dankna> sshc: it's got an instance of Num
13:19:13 <dankna> sshc: you can just treat it as a number
13:19:30 <dankna> sshc: for example, multiply by 10^9 and take its floor
13:19:48 <sshc> dankna: Now is there a cross-platform way to get a number of milliseconds/microseconds?
13:20:21 <dankna> sshc: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/time-1.1.4/Data-Time-Clock-POSIX.html#v%3AgetPOSIXTime
13:20:44 <dankna> note that type POSIXTime = NominalDiffTime, so it's precisely the same type
13:21:32 <dankna> you're measuring durations within a single run of the program, you said, so you really don't care what epoch it uses as long as it's consistent, but it's nice that it's a known one anyway :)
13:21:57 <kmc> deech, ANN doesn't do anything by itself.  it just provides a way to attach data to parts of your program's syntax tree, which can be inspected by tools of various kinds
13:22:04 <sshc> Yes, but there seems to not be a way to create a NominalDiffTime on Windows that is at least as precice as milliseconds
13:22:16 <dankna> is this based on experiment?
13:22:33 <sshc> dankna: What do you mean?
13:22:35 <dankna> or on a reading of the docs?
13:22:53 <dankna> because if the latter, I think you're misreading.  if you're saying you've tried it and the value is truncated to whole numbers seconds, that's different.
13:23:00 <dankna> +of
13:23:26 <sshc> I'm just assuming from the "POSIX" name of the module
13:23:54 <dankna> I can assure you that - at least on the Mac - the function does indeed construct a time with high precision
13:24:13 <dankna> obviously which system call it uses will vary depending on the OS, but.
13:24:22 <sshc> It looks like it actually does support Windows by reading the source! :D
13:24:32 <dankna> haha cool cool
13:24:54 <sshc> I wonder why they gave the module the name POSIX
13:25:11 <dankna> cause it's the unix/posix epoch
13:25:20 <dankna> although yeah
13:25:21 <kmc> well POSIX is an API; you can implement it on many systems
13:25:24 <dankna> that is kind of misleading now that I think of it
13:25:31 <kmc> there's at least two implementations of POSIX for Windows
13:25:34 <kmc> but i agree it's misleading
13:25:41 <dankna> since the posix function that it refers to is indeed at a resolution of seconds
13:26:29 <dankna> we need a name for that epoch that isn't tied up with anything else
13:26:54 <Heffalump> dankna: 1970
13:26:56 <dankna> (the epoch is the zero-time that you count from)
13:27:03 <dankna> Haffalump: insufficiently precise ;)
13:27:15 <dankna> also, module names need to start with letters
13:27:27 <Heffalump> TheBeginningOf1970
13:27:46 <dankna> Data.Time.Clock.TheBeginningOf1970 eh?  hrm.  doesn't roll off the tongue.
13:28:01 <Heffalump> TheBeginningOfTimeAsWeKnowIt
13:28:39 <aristid> BeforeThisTimeThereWasNoPositiveTime
13:28:53 <dankna> that's false though :D
13:29:03 <dankna> there was the Julian epoch, for example
13:29:43 <dankna> oh well
13:31:10 <dankna> (by the way, while we're pointing out flaws in things, there's a very misleading and possibly downright inaccurate description under the definition of NominalDiffTime)
13:31:17 <dankna> "This is a length of time, as measured by UTC. Conversion functions will treat it as seconds. It has a precision of 10^-12 s. It ignores leap-seconds, so it's not necessarily a fixed amount of clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened."
13:31:33 <dankna> first off, it's not meaningful for the time-interval data type to ignore or not ignore leap seconds
13:31:44 <dankna> surely it's the add/subtract functions that do that
13:32:14 <dankna> second off, to me at least, "ignoring" leap seconds would mean the opposite of what the numbers in the example suggest
13:32:29 <Cale> Well, the add/subtract functions are considered part of the interface of that type
13:32:34 <dankna> hmm
13:32:47 <dankna> I see what you're saying, but the type represents a /length/ of time - not a point in time
13:33:07 <dankna> I would at least move the comment to addUTCTime and diffUTCTime, elsewhere in that file
13:33:34 <dankna> but I would also check to see what the source actually does, because I suspect it does account for leap seconds, as that would be the less-code thing to do
13:33:57 <Cale> If a leap second intervened, and was not ignored, then the result should have been 0:59:59
13:34:06 <dankna> anyway, *shrug* it's not a huge big deal.  it's just a little rough edge that I've noticed in the past and thought I'd mention.
13:34:21 <Cale> Accounting for leap seconds does require code.
13:34:36 <Cale> It also requires a list of the leap seconds
13:34:51 <dankna> well
13:35:06 <dankna> what I was thinking was that a UTCTime was stored as time since an epoch, but that's not true now that I look at it
13:35:19 <dankna> it's DAY since an epoch and time since the start of the day
13:35:32 <dankna> astronomers would be horrified by this :)
13:35:47 <dankna> so you're right
13:36:06 <dankna> there's an implicit conversion going on there between two notions of time, and that needs to be explained a bit more fully imo
13:36:20 <Cale> Well, the way you can tell is that it's possible to show a UTCTime without passing in an explicit list of the leap seconds :)
13:36:22 <dankna> you only have to worry about leap seconds explicitly when you're converting from one representation to another, I think
13:36:27 <dankna> haha
13:36:30 <dankna> point taken
13:36:41 <dankna> amusingly put
13:38:53 <dankna> if there were world enough and time, I would contribute a documentation patch or something, though :)
13:39:26 <mietek> Is it possible to efficiently construct a ByteString by successively appending/prepending one byte at a time?
13:39:27 <Cale> There's a lot of compromise to be made between precise representation of times and APIs that aren't a total pain to use for mundane tasks. In fact, I think the time library actually falls a fair bit closer to the former than most libraries I've seen.
13:39:42 <dankna> that is true
13:39:45 <Peaker> Cale, btw: add/diff UTCtime are also not (+) and (-) because Num is too big, aren't they?
13:39:51 <dankna> mietek: you want lazy bytestrings for that
13:40:06 <Cale> Peaker: Not just that.
13:40:09 <mietek> Yeah...so it's a no for strict ByteStrings?
13:40:11 <dankna> mietek: or unfold possibly?  not sure
13:40:27 <dankna> doing it the naive way is definitely inefficient, anyway, yeah
13:40:28 <Cale> Peaker: (-) :: (Num a) => a -> a -> a
13:40:46 <Cale> So the result has the same type as the parameters, which isn't what we want for times
13:40:47 <Peaker> Cale, Yeah, absolute vs. relative
13:41:16 <Peaker> Cale, I wonder what mathematical construct that maps to (can't add absolutes, subtracting results in "relative", relatives are full nums, ..)
13:41:39 <Peaker> Cale, definitely deserves a type-class+type-family
13:42:10 <Cale> mietek: I'd probably work with functions of type [Word8] -> [Word8], using (x:) to represent the element x and composition for concatenation, and only at the end apply the function to an empty list and convert to ByteString
13:42:45 <mietek> Cale: that is exactly what I'm doing now; I was just hoping there's something in the ByteString library which does that.
13:43:12 <dankna> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/bytestring-0.9.1.6/Data-ByteString.html#v%3Aunfoldr looks possibly relevant but I'm not really thinking it out
13:43:24 <Peaker> class Num (Relative abs) => Absolute abs where type Relative abs :: * ; (~-~) :: abs -> abs -> Relative abs ; (~+) :: abs -> Relative abs -> abs ...
13:44:11 <mietek> Cale: just wondering -- why is the function representation better than the ordinary list representation?
13:44:31 <Cale> mietek: Because (.) takes O(1) time
13:44:54 <Cale> mietek: and (++) takes the order of the length of the first list steps to completely reduce
13:45:39 <aristid> Cale: where (.) and (++) are _not_ the caleskell variants? :P
13:46:00 <mietek> Cale: oh, so by using (.) you can skip the reverse arising from using (:)?
13:46:08 <Cale> aristid: The generalised variants have the same implementation when you use them at the types we're discussing
13:46:23 <Cale> mietek: yeah
13:46:38 <mietek> Right, I missed that.  Thanks.
13:48:13 <Cale> [] ++ ys = ys; (x:xs) ++ ys = x : (xs ++ ys)
13:48:59 <Cale> This is close to being the real implementation of (++). The real one has some list fusion magic attached to it, but that's mostly irrelevant here.
13:50:20 <Nibble> @hoogle curses helper
13:50:21 <lambdabot> No results found
13:50:24 <Nibble> @hoogle curses
13:50:24 <lambdabot> No results found
13:50:26 <Nibble> @hoogle curses-helper
13:50:26 <lambdabot> No results found
13:53:37 <Peaker> Cale, I'd expect the real one to just use foldr?
13:53:51 <Peaker> (Would it get fusion magic for free - from "foldr" itself?)
13:54:02 <Cale> Oh right, it might be that one :)
13:54:13 <Peaker> @src (++)
13:54:13 <lambdabot> []     ++ ys = ys
13:54:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:54:13 <lambdabot> -- OR
13:54:13 <lambdabot> xs ++ ys = foldr (:) ys xs
13:54:14 <Cale> I can't remember
13:54:20 <Cale> That's not the GHC source
13:54:31 <Cale> (@src rarely is)
13:54:52 <Peaker> I know :)
13:55:02 <Peaker> Just @src'ing so the way to foldr it is visible
13:58:38 <BONUS> im thinking
13:58:51 <BONUS> should i make a chapter about monad transformers in lyah at all
13:58:59 <BONUS> seems kind of tedious to write/read
13:59:15 <BONUS> and if so, should it be based on mtl?
14:00:13 <aristid> BONUS: i guess you can omit it until people decide on one of the many mtl alternatives ;)
14:00:30 <benmachine> I think monad transformers are overrated >_>
14:00:36 <BONUS> that too
14:01:02 <avenge> What do you guys use instead of monad transformers?
14:01:04 <BONUS> but otoh, aren't like 80% of haskell programs implemented with custom transformer stacks
14:01:16 <avenge> liftIO is my favorite function...
14:01:17 <benmachine> I'd be interested in stats on that
14:01:28 <BONUS> me too cause i just made that stat up
14:01:30 <benmachine> avenge: well, my programs are mostly pure
14:01:33 <Peaker> benmachine, I like them locally (not globally like the way Yi/XMonad uses them, as lots of actions take IO callbacks)
14:02:00 <Peaker> benmachine, what's the alternative to:  (`evalStateT` initState) $ do ...      when you want to thread state through a procedure?
14:02:09 <Peaker> (IORefs? yech)
14:02:37 <Peaker> When I try using monad transformers "globally" I encounter things like bracket
14:02:39 <Peaker> @type bracket
14:02:40 <lambdabot> Not in scope: `bracket'
14:02:44 <Peaker> @type Control.Exception.bracket
14:02:45 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:03:03 <Peaker> How to "bracket" a monad transformer computation? :-(
14:03:04 <benmachine> IORefs are only yech because you need IO for them pretty much
14:03:19 <BONUS> i always confuse the params for bracket
14:03:28 <Cale> I don't use monad transformers all that much
14:03:32 <avenge> Peaker: http://hackage.haskell.org/packages/archive/monad-wrap/0.0/doc/html/Control-Monad-Wrap.html
14:03:48 <Peaker> BONUS, the "b" and "c" there are good hints.. also, it's so much nicer to partially apply: bracket init fini
14:03:57 <Peaker> BONUS, (two ways to remember why the order is what it is)
14:04:09 <Cale> The main use case for monad transformers for me is the StateT s [] monad.
14:04:28 * domi2 is looking for help with a hackage build failure
14:04:34 <Cale> and I guess things like WriterT (Product Rational) []
14:04:44 <domi2> http://hackage.haskell.org/packages/archive/grammar-combinators/0.1/logs/failure/ghc-6.12
14:04:45 <benmachine> Cale: a bit like a parser?
14:04:49 <avenge> For me, the main use for monad transformers is lift and liftIO, when I implement my own transformers.
14:05:03 <Cale> benmachine: A bit -- it's useful for nondeterministic search.
14:05:04 <domi2> <command line>: cannot satisfy -package-id uu-parsinglib-2.5.5-40a637b80a29d05a831a175c3f9a060e: 
14:05:07 <domi2>     uu-parsinglib-2.5.5-40a637b80a29d05a831a175c3f9a060e is unusable due to missing or recursive dependencies:
14:05:10 <domi2>       haskell98-1.0.1.1-ca51ba62fed9074ccb8001cd642eb101
14:05:11 <avenge> But locally, it's quite useful to wrap, say, StateT around IO.
14:05:12 <domi2> anyone?
14:05:18 <benmachine> fwiw, mtl has 726 direct and 681 indirect revdeps
14:05:22 <benmachine> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
14:05:25 <Cale> (Like playing a game with the game board as the state)
14:05:28 <benmachine> transformers has a few hundred too
14:05:31 <Peaker> avenge, I suppose if it doesn't work with ContT it will also not work with Maybe/EitherT?
14:05:32 <Cale> I never transform the IO monad
14:05:56 <avenge> Peaker:  I think it should work with those.
14:05:58 <Cale> I might be convinced to use ContT over IO, possibly, but that's a bit of a mess.
14:06:21 <Peaker> Cale, ReaderT over IO can save a lot of annoying code :)
14:06:30 <Cale> It just saves passing one parameter.
14:06:48 <Peaker> avenge, thanks, I'll keep it around for next time I want to use a transformer (or next time I have energy to read code..)
14:06:48 <BONUS> ... a million times
14:07:15 <benmachine> btw, what's the difference between ContT r IO a and Cont r (IO a)?
14:07:26 <benmachine> or rather, m a in both cases
14:07:28 <benmachine> @unmtl ContT r m a
14:07:29 <lambdabot> (a -> m r) -> m r
14:07:34 <benmachine> @unmtl Cont r (m a)
14:07:34 <lambdabot> (m a -> r) -> r
14:07:37 <benmachine> err
14:07:43 <avenge> benmachine: You can execute multiple IO actions in the former case.
14:07:47 <benmachine> yeah, I meant Cont (m r) a
14:07:49 <nlogax> BONUS: if you write bout them, can you have a robot dressed as a ghost?
14:08:00 <BONUS> you got it
14:08:07 <Veinor> I like this idea
14:08:08 <nlogax> sweeeeet :D
14:08:47 <Cale> I wonder why we don't have a name for the (a -> r) -> a monad
14:09:29 <avenge> What is the (a -> r) -> a monad?
14:09:54 <Cale> It might be that Martín Escardó just discovered it for us. http://www.cs.bham.ac.uk/~mhe/papers/msfp2010/
14:10:00 <copumpkin> the AlmostCont Monad
14:10:58 <Cale> It's a monad of selection functions. If you think of the type r as a kind of generalised truth value, then such a function is one which tries to select a value satisfying the given predicate.
14:11:21 <Cale> (according to some strategy)
14:11:24 <BONUS> whats fmap for (a -> r) -> a again?
14:11:39 <avenge> You are talking about J?
14:11:55 <Cale> yes
14:12:00 <benmachine> what's the parameter order?
14:12:00 <copumpkin> we should specify which of those parameters is constant in the monad :P
14:12:17 <Cale> BONUS: Yeah, that's not so obvious, but it can be done :)
14:12:32 <BONUS> fmap f g = \h -> .... uhhh
14:12:36 <avenge> type J r x = (x -> r) -> x
14:12:43 <benmachine> BONUS: that's what I've got too >_>
14:13:10 <copumpkin> @djinn (x -> y) -> ((x -> r) -> x) -> ((y -> r) -> y)
14:13:10 <lambdabot> f a b c = a (b (\ d -> c (a d)))
14:13:22 * benmachine blinks
14:13:25 <copumpkin> wo needs to think anymore
14:13:29 <BONUS> beaten by a computer ...
14:13:36 <BONUS> that's it, pack it up guys
14:13:37 <benmachine> copumpkin: ruined it :(
14:17:22 <megajosh2> @src (!!)
14:17:22 <lambdabot> xs     !! n | n < 0 = undefined
14:17:22 <lambdabot> []     !! _         = undefined
14:17:22 <lambdabot> (x:_)  !! 0         = x
14:17:22 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:18:04 <copumpkin> benmachine: aw sorry
14:18:43 <benmachine> it's cool I'm still trying to bind
14:18:51 <BONUS> its ok the definition isn't very enlightening anyway
14:19:15 <copumpkin> benmachine: just get djinn to do it ;)
14:19:20 <benmachine> >_>
14:19:20 <copumpkin> or agsy!
14:19:35 <Peaker> I want djinn in my editor. I also want my editor to suggest stdlib functions that have the exact same structure as my code
14:19:55 <dankna> haha, nice
14:20:12 <Cale> Well, suppose you have a function (x -> y), and a function ((x -> r) -> x) and you want a function ((y -> r) -> y). It's easy to see how to get a function (x -> r) -> y -- just compose
14:20:35 <copumpkin> @djinn ((((x -> r) -> x) -> r) -> ((x -> r) -> x))
14:20:36 <lambdabot> -- f cannot be realized.
14:20:36 <domi2> any way to debug a hackage build?
14:20:54 <Cale> But now you want to take your function parameter (y -> r), and turn it into a parameter (x -> r), well, that's easy, just compose moar
14:21:07 <copumpkin> moar indeed
14:22:01 <Cale> Another way of reasoning about why it should be possible is that both of the occurrences of the type parameter x are in positive positions
14:22:32 <benmachine> @djinn ((((a -> r) -> a) -> r) -> (a -> r) -> a) -> (a -> r) -> a
14:22:33 <lambdabot> f a b = a (\ c -> b (c b)) b
14:22:33 <Cale> If you read a -> b as "b or not a"
14:23:00 <Peaker> for Functor instance, only positivity matters, afaik
14:23:15 <Peaker> It's what I look for immediately when wondering "Is this a Functor/App/Monad?"
14:23:50 <copumpkin> @djinn (r -> s) -> ((x -> r) -> x) -> ((x -> s) -> x)
14:23:51 <lambdabot> -- f cannot be realized.
14:23:52 <copumpkin> :P
14:24:05 <copumpkin> @djinn (r -> s) -> ((x -> s) -> x) -> ((x -> r) -> x)
14:24:06 <lambdabot> f a b c = b (\ d -> a (c d))
14:24:13 <copumpkin> omg contrafunctor!
14:24:14 <copumpkin> :P
14:24:23 <benmachine> omg
14:24:57 <mietek> "There are only two hard problems in Computer Science: cache invalidation and naming things"
14:25:01 <Cale> @djinn (x -> y) -> (r -> s) -> ((x -> s) -> x) -> ((y -> r) -> y)
14:25:01 <lambdabot> f a b c d = a (c (\ e -> b (d (a e))))
14:25:21 <copumpkin> ooh, double whammy!
14:25:32 <mietek> How would you call operations dual to appending/prepending?
14:25:50 <mietek> Take-from-front, take-from-back
14:26:12 <BCoppens> mietek: heh that's a nice quote, who's that by? :)
14:26:17 <benmachine> pop is take-from-top
14:26:32 <mietek> Phil Karlton
14:26:34 <benmachine> if that helps :P
14:26:37 <BCoppens> ah :)
14:26:44 <mietek> benmachine: thanks, but it doesn't ;)
14:26:56 <benmachine> bytestrings and lists use "uncons" to mean take-from-front
14:26:57 <Peaker> mietek, For prepending, it's head/tail (depending on which part you want), for appending it's "init/last"
14:27:01 <benmachine> or rather, head &&& tail
14:27:21 <mietek> Hmm.
14:34:43 <illissius> there's no good way, when defining a type function, to say "if these two things are the same type, the result is one thing, if they're not, it's another thing" without specializing it for every possible type, right?
14:34:55 <Mitar> any easy way for this to type check: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29717#a29717
14:34:55 <Mitar> ?
14:35:02 <ezyang> illissius: Not yet. 
14:35:13 <ezyang> I think that requires type equality constraints, which are not implemented yet. 
14:35:52 <illissius> ezyang: you mean superclass equality constraints? how would that help?
14:36:02 <illissius> I haven't even typed the word 'class' so far :)
14:36:30 <ezyang> oh, you're using data families 
14:37:00 <illissius> type families but yeah
14:39:11 <aristid> Mitar: yes, you can use a tuple instead:P
14:39:48 <sshc> How do I convert a lazy bytestring to a lazy bytestring?
14:39:51 <lispy> GHC's trac says it lacks parallel builds because cabal will support them first.  Cabal's trac doesn't mention parallel builds (that I can see).  Anyone know what's up with that feature?  I know lots of people who would benefit and are asking for it.
14:39:59 <Mitar> ehm, the idea is to have generic waitForChan function which would wait for any of those chans to be ready
14:40:07 <illissius> sshc: id
14:40:52 <sshc> Haha, s/lazy/strict/
14:41:19 <sshc> illissius: Is there a more efficient way then unpacking and repacking?
14:41:30 <notabel> sshc: fromChunks and toChunks
14:41:38 <JoeyA> Is there a list of Hackage packages somewhere that isn't by category?  It's annoying to search http://hackage.haskell.org/packages/archive/pkg-list.html because I keep hitting the same packages over and over again.
14:41:43 <Mitar> aha
14:41:46 <Mitar> i found http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
14:42:25 <sshc> Thanks
14:43:56 <illissius> anyone know of a blog post / library / something else involving type-level lists and various operations, implemented with type families?
14:45:15 <Peaker> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists seems to have some mistakes in it
14:45:21 <Mitar> like?
14:45:29 <Peaker> "forall a. [a] is the type of the list whose elements have some (the same) type a, which can be assumed to be any type at all by a callee (and therefore this too is a list of bottoms)."
14:45:37 <Peaker> @type []
14:45:38 <lambdabot> forall a. [a]
14:46:14 <Peaker> or maybe I just misunderstand what he means -- if there are any items in the list, then they are bottoms, yeah
14:48:34 * hackagebot Grempa 0.1.0 - Embedded grammar DSL and LALR parser generator  http://hackage.haskell.org/package/Grempa-0.1.0 (OlleFredriksson)
14:52:09 <aristid> @pl mcquine = "YO I'M MC QUINE AND I'M HERE TO SAY " ++ show mcquine
14:52:10 <lambdabot> mcquine = fix (("YO I'M MC QUINE AND I'M HERE TO SAY " ++) . show)
14:53:34 <Peaker> Is Graphics.SOE still maintained? if I want to use Haskell school of expression book to tutor students..
14:54:23 <applicative> its inside gtk2hs, right
15:01:28 <applicative> Peaker, I see ... its not in the gtk2hs repository, but separate as soegtk.  code.haskell.org seems to be down.
15:03:31 <Peaker> applicative, ah.. may be a bit of a stretch to get people to install that :)
15:03:41 <copumpkin> I kind of wish haskell allowed ADT constructor overlap
15:03:44 <copumpkin> like agda does
15:04:06 <Peaker> copumpkin, example?
15:04:16 <copumpkin> data Moo = Baa | Oink
15:04:20 <copumpkin> data Woof = Baa | Meow
15:04:22 <Peaker> What's the type of Baa?
15:04:32 <copumpkin> who cares :P
15:04:32 <Peaker> is it a naming thing or a typing thing?
15:04:36 <copumpkin> naming
15:04:48 <Peaker> so it uses the type to figure out how to resolve the name?
15:04:51 <copumpkin> yeah
15:04:55 <Peaker> So it has no type inference?
15:05:12 <copumpkin> nothing like haskell's
15:05:31 <lispy> Peaker: it's a total language, so you don't have to worry about certain undeciable things
15:05:40 <applicative> Peaker, yes I've been trying to install the parts needed by the criterion package on os x; it's complete hell though the end may be near...
15:05:56 <Peaker> I think name resolution --> type resolution is better than intertwining them.. it makes type inference problematic IMO and I think the "syntactic level" is strictly below the typing level, and thus the upper level should not leak information to the lower one
15:06:15 <benmachine> agreed
15:06:18 <Peaker> lispy, How does that relate to my question though?
15:06:23 <benmachine> also, more polymorphism = fewer type errors
15:06:38 <benmachine> and type errors are the best part of haskell :P
15:06:47 <benmachine> apart from all the other bits
15:06:52 <lispy> Peaker: it was related to your question about it lacking type inference.
15:07:04 <Peaker> lispy, I'm trying to figure out why :)
15:07:12 <lispy> Peaker: some things that would be undecidable in haskell are decidable in a total language when it comes to type checking
15:07:27 <copumpkin> Peaker: it simply can't have type inference as general as haskell's
15:07:30 <lispy> Peaker: and I thought you were poking on that thread
15:07:35 <Peaker> lispy, I guess general recursion causes some problems w.r.t type inference?
15:07:57 <Peaker> lispy, Ah, no, I was thinking types being used for name resolution could cause the issues that made the C# team give up on general type inference
15:08:42 <lispy> Peaker: well, take the type of if/then/else in haskell.   In Haskell we restrict it to Bool -> a -> a -> a, but it could be more general if we knew if the Bool was true or false.  But, knowing what it is in a language with undecidable statements is well, undecidable.
15:09:52 <Peaker> lispy, IIRC the resolution is: if :: (T :: Bool -> *) -> (p : Bool) -> T False -> T True -> T p ?
15:10:16 <Peaker> (with DT)
15:11:12 <Peaker> What's up with cabal not auto-installing executable deps (e.g: alex, gtk2hs-buildtools, etc)?
15:11:22 <Peaker> can't it be listed as a fake library dependency?
15:11:24 <Peaker> (for now)
15:11:48 <lispy> Peaker: It refuses to track anything.  The only reason it knows about libraries is because ghc tells it about them.
15:11:59 <lispy> Peaker: So it really needs to learn how to query your system for those binaries
15:12:07 <lispy> (or admit that tracking installed things is good)
15:12:20 <Peaker> what if gtk2hs just depended on gtk2hs-buildtools as it depends on other libs?
15:12:51 <Peaker> it could get cabal-install to fetch and install the executable?
15:13:31 <lispy> I haven't tried that
15:13:32 <lispy> Does it work?
15:14:51 <Peaker> I don't know, why wouldn't it?
15:15:27 <copumpkin> Peaker: yeah, that would be it
15:15:55 <copumpkin> basically induction on booleans
15:17:31 <lispy> Peaker: maybe cabal notices that it's an executable instead of a library and complains (I could see cabal being that pendantic)
15:18:05 <lispy> Peaker: one thing that's weird about executable packages and cabal is that every, 'cabal install foo' will rebuild foo and install it again instead of saying, "you already have it!"
15:20:23 <trinithis> Is "hGetContents handle >>= evaluate" sufficient to strictly read a file's contents?
15:20:53 <applicative> evaluate?
15:21:01 <copumpkin> trinithis: no
15:21:17 <trinithis> What should I do then?
15:21:31 <copumpkin> rnf it, use strict io, or maybe iteratees
15:21:49 <trinithis> @applicative: evaluate = Control.Exception.evaluate
15:21:49 <lambdabot> Unknown command, try @list
15:22:17 <jmcarthur> trinithis: Data.ByteString.hGetContents
15:22:24 <applicative> trinithis, yes, i just found it in the docs
15:22:45 <jmcarthur> trinithis: or Data.ByteString.Char8.hGetContents, if you prefer
15:22:54 <benmachine> trinithis: hGetContents handle >>= \xs -> evaluate (foldr seq xs xs)
15:23:02 <Twey> Iteratees are the way to go.
15:23:10 <benmachine> iteratees are nice
15:23:10 <trinithis> What are Iteratees?
15:23:31 <jmcarthur> iteratees are fine if you want lazy-ish semantics, but trinithis seems to want to simply read the file contents strictly
15:23:38 <applicative> trinithis, good question, the masters are in dispute though
15:23:43 <trinithis> haha
15:23:59 <jmcarthur> nobody know what iteratees are. they are just some random set of combinators ;)
15:24:31 <applicative> see, jmcarthur has a meta-view, which is sure to be opposed by others....
15:24:53 <applicative> trinithis, I take it you've seen the way the bytestring libraries divide 
15:25:21 <trinithis> yea
15:25:27 <trinithis> if you mean
15:25:35 <trinithis> lazy versions and strict versions
15:25:52 <trinithis> etc
15:26:15 <applicative> right, if you use the hGetContents from the main Data.ByteString it will be strict
15:26:54 <trinithis> ok. and using uncons repeatedly won't give bad perfomance?
15:27:34 <jmcarthur> trinithis: you could use Data.ByteString.unpack if you want to convert it to a String
15:27:44 <trinithis> ok
15:27:59 <jmcarthur> but really, ByteStrings are pretty fast for a lot of purposes :)
15:28:13 <jmcarthur> it of course depends what you are doing with the string
15:28:52 <jmcarthur> trinithis: warning: ByteString isn't unicode aware at all
15:28:57 <applicative> trinithis, are you using uncons repeatedly to extract the String so to say?
15:29:10 <jmcarthur> if you want something like ByteString for unicode, you will probably want to look at the text package
15:29:39 <trinithis> I'm writing a funge98 interpreter. so each character in a file is an instruction. basically I make a map containing each character in the file
15:30:25 <trinithis> Oh, and is ByteString.writeFile strict?
15:30:30 <trinithis> I cant tell
15:30:44 <jmcarthur> it should be
15:30:53 <jmcarthur> write* functions really can only be strict anyway
15:30:59 <jmcarthur> because there is no other evaluation to drive it
15:31:02 <chrisdone>   if isJust annotation_of then [("annotation", show pid')] else []
15:31:02 <chrisdone> Why not:
15:31:02 <chrisdone>   [("annotation", show pid') | isJust annotation_of]
15:31:05 <trinithis> ok
15:31:05 <chrisdone> nice suggestion, hlint
15:31:16 <applicative> i'm having trouble envisaging "writeFile "a.txt" _|_"
15:31:35 * chrisdone never uses list comprehensions
15:31:48 <jmcarthur> chrisdone: was "nice suggestion" sarcasm?
15:32:18 <applicative> i'm now having trouble seeing annotation_of as a noun...
15:32:34 <jmcarthur> :t guard
15:32:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:33:00 <applicative> trinithis, i take it that ByteString is on the face of it overkill since there won't be massive files you're interpreting?
15:33:49 <jmcarthur> applicative: i use ByteString for whatever is appropriate, which is a lot of things, including those which may be considered "overkill" by those who aren't a fan of qualified imports ;)
15:34:41 <jmcarthur> > (("annotation", "5") <$) . guard . isJust $ Nothing
15:34:41 <lambdabot>   No instance for (GHC.Show.Show
15:34:42 <lambdabot>                     (f ([GHC.Types.Char], [G...
15:34:46 <trinithis> applicative: I don't know. I'm guessing for small files, its a sledgehammer for a nail, but in the case for large ones.... 
15:34:51 <applicative> jmcarthur, I dont have a view, it's just that trinithis was at first just looking for strict file reading, I think, and then attention was drawn to bytestrings
15:34:57 <trinithis> If anything I really just needed strict io
15:34:58 <jmcarthur> > (("annotation", "5") <$) . guard . isJust $ Nothing :: [(String, String)]
15:35:00 <lambdabot>   []
15:35:07 <jmcarthur> > (("annotation", "5") <$) . guard . isJust $ Just undefined :: [(String, String)]
15:35:08 <lambdabot>   [("annotation","5")]
15:35:15 <applicative> trinithis, there are also strict io libraries that use the standard String concept
15:35:36 <trinithis> At hackage?
15:35:58 <trinithis> gah... internet issues :(
15:36:25 <applicative> I havent used them, but see, e.g. this http://hackage.haskell.org/package/strict
15:37:22 <applicative> of course, there's no need for the lib, the definition is:  hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
15:37:56 <trinithis> Well I'll try it out (with the lib... easier on the eyes)
15:37:59 <applicative> a bit of a hack...
15:39:11 * jmcarthur really thinks that this would be a lot simpler than using a whole library:  unpack <$> hGetContents "myfile"
15:39:39 <jmcarthur> with appropriate imports/hiding/qualifications
15:39:45 <benmachine> jmcarthur: that's using a whole bytestring library :P
15:40:01 <jmcarthur> which is at least already installed with most copies of GHC ;)
15:40:24 <jmcarthur> and would be much faster than the seq version, i bet
15:40:31 <jmcarthur> for what it's worth
15:40:33 <benmachine> probably
15:40:41 <trinithis> jaja
15:40:41 <lispy> jmcarthur: your verison is just as fast as C actually
15:40:53 <jmcarthur> it should be
15:40:54 <lispy> er no
15:41:01 <jmcarthur> the IO should be
15:41:04 <lispy> if you remove the unpack it would be
15:41:04 <aristid> :t unpack
15:41:04 <jmcarthur> not the unpack
15:41:05 <lambdabot> Not in scope: `unpack'
15:41:16 <jmcarthur> :t BS.unpack
15:41:17 <lambdabot> BSC.ByteString -> [Word8]
15:41:22 <jmcarthur> :t BSL.unpack
15:41:23 <lambdabot> BSLC.ByteString -> [Word8]
15:41:27 <jmcarthur> :t BSCL.unpack
15:41:28 <lambdabot> Couldn't find qualified module.
15:41:31 <jmcarthur> :P
15:41:34 <jmcarthur> :t BSLC.unpack
15:41:35 <lambdabot> BSLC.ByteString -> [Char]
15:41:43 <applicative> trinithis, I was just wondering, what has you worried about strict reading?
15:41:47 <aristid> :t BL.unpack
15:41:48 <lambdabot> Couldn't find qualified module.
15:41:52 <jmcarthur> :t BSC.unpack
15:41:53 <lambdabot> BSC.ByteString -> [Char]
15:42:12 <trinithis> The 'i' command in Funge98
15:42:12 <aristid> and... ByteString has its own hGetContents?
15:42:17 <jmcarthur> yes
15:42:18 <trinithis> I had issues with it
15:42:27 <jmcarthur> :t BSC.hGetContents
15:42:28 <lambdabot> GHC.IOBase.Handle -> IO BSC.ByteString
15:43:09 <jmcarthur> trinithis: what is the 'i' command in Funge98?
15:43:15 <applicative> Haskell has a lot of hGetContentses
15:43:34 <trinithis> oh. its an input file command. with lazy io, the file wasnt loaded into the interpreter space
15:43:41 <aristid> applicative: are there as many hGetContentses as monad tutorials?
15:43:44 <lispy> applicative: I think Handle and String should have probably been type classes :)
15:43:47 <trinithis> but when i made it strict, it worked
15:44:34 <jmcarthur> that's weird
15:44:38 <applicative> trinithis, i see. it could be a bit strange.  I wonder how ghci makes sure to interpret my module, before I ask anything....
15:45:58 <_unK> is there a way to monitor multiple handles for input at once? something like hWaitForInput that takes [Handle] instead of Handle.
15:46:55 <lispy> ?hoogle hWaitForInput
15:46:56 <lambdabot> System.IO hWaitForInput :: Handle -> Int -> IO Bool
15:47:04 <lispy> ?hoogle [Handle] -> Int -> IO Bool
15:47:04 <lambdabot> System.IO hWaitForInput :: Handle -> Int -> IO Bool
15:47:04 <lambdabot> Network.BufferType buf_hGet :: BufferOp a -> Handle -> Int -> IO a
15:47:04 <lambdabot> Data.HashTable update :: HashTable key val -> key -> val -> IO Bool
15:47:27 <_unK> I found something about hSelect @ google, but can't locate this function anywhere.
15:48:08 <benmachine> _unK: generally that sort of thing would be done with concurrency, forkIO etc.
15:48:12 <jmcarthur> _unK: threads are one nice way to do it :)
15:48:29 <lispy> _unK: I think you could start threads that each hWaitForInput, then have the main thread wait on an empty MVar.  When a thread gets input it puts its handle in the MVar and terminates.
15:49:02 <applicative> hayoo has never heard of [Handle] it seems.  
15:49:05 <jmcarthur> _unK: and the runtime will actually use select/epoll (well, epoll might not be until ghc 6.14...) or whatever makes sense on your platform to make it efficient if you just use multiple threads :)
15:50:47 <lispy> _unK: Haskell threads are so cheap as to be free, BTW
15:50:56 <_unK> ah
15:51:32 <_unK> I was wordering whether spawning threads each time I need to do this isn't too expensive
15:52:06 <lispy> when Simon Marlow was implementing the current threading stuff he had tests with millions of threads, IIR
15:52:09 <lispy> IIRC*
15:52:25 <Peaker> Shared-state threads have always been nightmares. When seeing prevalence of forkIO in Haskell I was bewildered at first. Then I realized since they only really share MVars, and those aren't global (only those given to them explicitly), they're not really mutable-share-by-default threads. They're more like processes, with MVars being a convenient IPC. Everything else is just immutable
15:52:42 <Peaker> lispy, light threads still cost some significant stack space, don't they?
15:53:12 <Peaker> unless the "stack" space is allocated on the heap and grows dynamically, I guess
15:53:16 <lispy> I haven't heard anything about that, but I don't know.
15:53:22 <Peaker> though it isn't clear how that would work
15:53:39 <Martty> sorry for the OT but anyone using sumatrapdf can tell me how does the program remember the page you left the file at? does it append something at the end of the file or use the registry or what?
15:54:15 <lispy> This should answer your questions: http://ghcmutterings.wordpress.com/2009/03/03/new-paper-runtime-support-for-multicore-haskell/
15:54:17 <Saizan> Peaker: i think that's going to be quite small too
15:55:20 <Peaker> Saizan, Not the "default stack size" you get when just running normally? (Something in the order of megs, iirc?)
15:57:06 <applicative> trinithis, I can't tell if you are using this project to learn haskell or are an expert or what, but I think I wish I hadn't avoided the nightmare of the ByteString libraries as long as I did....  
15:57:22 <Saizan> Peaker: it'd be hard to fork millions of threads if that was the case, no?
15:57:29 <Peaker> applicative, If only there were decent type-classes to make them less of a pain
15:57:45 <Peaker> Saizan, Yeah, that's why I'm wondering. Do you think it grows the stack dynamically?
15:57:54 <trinithis> I'm an intermediate haskeller
15:58:15 <applicative> Peaker, yes it is a pain, but it's also sort of interesting
15:58:22 <lispy> Peaker: well, you can use -XOverloadedStrings if you want a type class to make ByteString more native
15:58:41 <applicative> -XOverloadedStrings is awesome
15:58:55 <DanielDiaz> Does anyone know any function to work with the windows clipboard?
15:59:00 <Peaker> lispy, I'm talking more about the API duplication in Data.ByteString vs Data.List vs Data.ByteString.Lazy vs Data.ByteString.[Lazy.]* :-(
15:59:13 <Peaker> It's just ridiculous
15:59:13 <lispy> DanielDiaz: I think one of the Win32 libraries that ships with GHC has it
15:59:36 <lispy> Peaker: have you seen ListLike?
15:59:48 <lispy> http://hackage.haskell.org/package/ListLike
15:59:49 <Peaker> lispy, Yeah, not sure if it's the nicest solution.. Too opaque
16:00:02 <DanielDiaz> lispy: thanks, I'll search it
16:00:04 * lispy shrugs
16:00:06 <Peaker> lispy, one big blob
16:00:10 <lispy> I'm quite happy with using module imports to control it
16:00:29 <avenge> -XOverloadedStrings is great.  Not for code (don't really need it), but for ghci.  I run ":set -XOverloadedStrings" all the time when testing stuff.
16:00:31 <Peaker> lispy, The problem is that some want this kind of BS and others want another
16:00:41 <Peaker> lispy, I'm using strict bytestrings in one context, then I can't use Data.Binary with them
16:00:49 <lispy> avenge: oh, clever
16:00:51 <applicative> DanielDiaz, does this look right? http://hackage.haskell.org/packages/archive/Win32/2.2.0.2/doc/html/Graphics-Win32-GDI-Clip.html
16:00:54 <Peaker> lispy, Why does Data.Binary care what kind of BS it is?
16:00:59 <lispy> avenge: you could add it to your ~/.ghci I think
16:01:09 <avenge> Even more clever...
16:01:44 <lispy> Peaker: For performance reasons
16:01:55 <lispy> Peaker: but toChunks/fromChunks saves the day, right?
16:02:00 <Peaker> lispy, Don't we have inlining for that?
16:02:08 <lispy> Peaker: And what about Cereal, what one does it use?
16:02:14 <DanielDiaz> let me see..
16:02:39 <lispy> Peaker: re: inlining, you're teasing right?
16:02:39 <Peaker> lispy, strict byte strings
16:03:06 <Peaker> lispy, Nope, I'm not sure why we write functions with a specialized type for performance.. the general type can be specialized/inlined with a pragma, I'd hope
16:03:11 <avenge> I wish there were some layer of indirection for Contexts in type declarations that didn't require the -cpp option.
16:03:15 <lispy> (or maybe you meant to say RULES)
16:03:34 <DanielDiaz> Win32 API documentation is so empty...
16:03:38 <avenge> I find that frequently there's some weird issue deep in some library I'm working on, and I wish I could suddenly add a Context like "Show s =>" to 20 functions.
16:03:59 <lispy> DanielDiaz: yes.  Typically need to look at MSDN an then map that to the Haskell wrapper
16:04:09 <Peaker> lispy, If GHC lacks some important optimization (such as type specialized implementations) feature we shouldn't regress to pre-TC code with API duplication
16:04:13 <Saizan> Peaker: GHC isn't quite that smart / hasn't become as much a whole-program compiler yet
16:04:16 <Peaker> We should fix GHC :)
16:04:34 <trinithis> @paste
16:04:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:05:03 <Peaker> Saizan, What about just being able to say: "Compile this function with these types as special cases", and if it is recognized as used with them, it can use the optimized version
16:05:12 <lispy> Peaker: fixing GHC is a long process.  And sometimes, take common subexpression elimination as an example, you just can't get the general compiler to do the right thing.
16:05:24 <lispy> Peaker: you can do that, via RULES
16:05:25 <copumpkin> Peaker: it already supports that
16:05:33 <copumpkin> or SPECIALI(S|Z)E
16:05:38 <Peaker> Saizan, so you could write something using a ListLike or such interface, and then {-# SPECIALIZE StrictByteString -> .. #-} for each type you want
16:05:57 <lispy> IIRC, specialize was deprecated in favor of RULES
16:05:58 <avenge> {-# RULES #-} might allow you to do that.  I think it supersedes SPECIALIZE.
16:06:02 <Saizan> Peaker: most of the problem arises from specializing the data representation
16:06:04 <copumpkin> lispy: only the general form of it
16:06:10 <Peaker> Saizan, what do you mean?
16:06:14 <copumpkin> Peaker: my main objection to listlike is that it leads people into thinking something is something it isn't
16:06:22 <Saizan> Peaker: problem in the sense that it's not easy to do it with GHC currently
16:06:25 <Peaker> lispy, then why is it bad for performance to be general for ListLike and not duplicate APIs?
16:06:36 <Peaker> copumpkin, what do you mean?
16:07:18 <lispy> Peaker: well, lazy bytestring might be infinite where as strict can't be.  So you'd have quite different RULES for both of those whenever you need to assume one is infinite and the other isn't
16:07:20 <copumpkin> Peaker: ByteString supports cons, but extremely inefficiently, whereas Lists support it very efficiently. Length on lists takes O(n) times and is O(1) on ByteStrings
16:07:25 <copumpkin> you shouldn't be using them interchangeably
16:07:31 <copumpkin> your algorithms that work nicely on one will probably suck on the other
16:07:53 <trinithis> Alright, I have a ByteString issue. When I run main in ghci, I get this error: http://pastebin.com/Lz710sg0. When I compile it and then run it, the program works fine.
16:08:01 <Eelis> Peaker: i'm glad to see you bring this issue up. it's one of my pet peeves that in Haskell there's this "abstraction penalty" for polymorphism, a penalty that, say, C++ templates, do not suffer.
16:08:03 <Peaker> lispy, Well, the APIs that are duplicate probably don't mind the infinite-ness as they already exist in both situations
16:08:39 <copumpkin> but I do agree the situation with the massively duplicated APIs is gross
16:08:41 <Peaker> copumpkin, Then provide type-classes with various functionalities, and make it clear which instances are horrible
16:08:46 <avenge> Eelis:  It's not just an abstraction penalty.  It's also a functionality penalty.
16:08:48 <copumpkin> I'd prefer parametrized modules as a solution though
16:08:48 <lispy> Eelis: I think this penalty only comes up with type classes though which is like using the normal OOP side of polymorphism in C++
16:09:10 <Peaker> copumpkin, You could even have instances for the horrible cases (e.g: cons on strict bytestring) only on a newtype called SlowStrictBS or such
16:09:30 <Peaker> copumpkin, I don't understand what the practical difference with parameterized modules VS. type-classes (with type families) is
16:09:38 <Eelis> lispy: no. in C++ they use implicit "Concepts" (which correspond to type classes) to unify interfaces entirely at compile-time *without* runtime virtual dispatch overhead.
16:10:10 <copumpkin> Eelis: can't the c++ behavior be simulated by writing a SPECIALIZE pragma wherever you want it though?
16:10:25 <Eelis> copumpkin: maybe, but it's a crutch at best.
16:10:33 <mauke> so are templates
16:10:36 * Saizan thinks LHC is a better place to hope for such specializations than GHC
16:10:39 <copumpkin> well, most of the time do you really want code duplication?
16:10:39 <Eelis> mauke: that's beside the point.
16:10:51 <copumpkin> most of the typeclasses don't need superfast specialized behavior
16:11:08 <Peaker> Eelis, I disagree it's a Haskell penalty -- C++ has a penalty (generated code duplication leading to code cache misses, etc).  Haskell can inline the TC parameter passing (partial evaluation for that parameter)
16:11:09 <Eelis> yes, most of the time i want my programs to be as fast as possible :)
16:11:11 <mauke> Eelis: you're right
16:11:14 <Saizan> at least it's designed to be a whole-program compiler :)
16:11:25 <copumpkin> Eelis: with more code you're more likely to blow your cache though
16:11:41 <Peaker> Eelis, it's easier for Haskell to inline the TC parameter (duplicate function for each possible one) than it is for C++ to "outline" to avoid the duplication
16:11:47 <copumpkin> although I guess jumping to methods in dictionaries isn't much better
16:11:55 <Eelis> copumpkin: yes, it's a trade-off, and that's exactly one of the reasons why it should be up to the compiler to do these things, and not up to manually written SPECIALIZE pragmas
16:12:10 <Peaker> Eelis, Compilers have less information than the programmer
16:12:13 <avenge> While the performance argument is good, I think the functionality argument is better.  For instance, maybe I have a type and function:
16:12:13 <avenge> newtype T a = T a
16:12:13 <avenge> f :: T a -> IO ()
16:12:13 <avenge> Now maybe I want two different implementations, depending on whether a is in the class Show.  This is easy to do with C++ templates, but can't be done in Haskell.
16:12:14 <copumpkin> Eelis: how should it know though?
16:12:24 <copumpkin> avenge: sure it is
16:12:28 <copumpkin> well, GHC haskell :)
16:12:47 <copumpkin> actually, can rules specify a typeclass?
16:12:49 <avenge> copumpkin:  How, with -XUndecidableTypes or something?
16:12:50 <copumpkin> maybe I'm wrong :)
16:13:01 <Eelis> copumpkin: i have no idea what modern cache analysis is capable of. i'm sure there's plenty of literature on the subject.
16:13:02 <copumpkin> I was thinking rule pragmas
16:13:50 <copumpkin> avenge: the main reason that isn't in the basic language though is that you're breaking parametricity
16:13:52 <Peaker> Eelis, transforming dictionary passing to duplicate code for each possible dictionary seems easier to me than transforming C++ templates back to shared-code that takes dictionaries as arguments
16:13:59 <Eelis> Peaker: yes, i want GHC to do that inlining, but as people are pointing out here, apparently GHC is not doing it :)
16:14:15 <avenge> copumpkin:  But in that sense aren't classes breaking parametricity?
16:14:20 <Peaker> Eelis, IOW: Haskell's solution seems better, because the compiler has more information readily available than in C++ templates (where it'd have to reverse engineer the TC's out of interface commonality)
16:14:40 <Eelis> Peaker: yes, i'm not saying C++ has more potential, i'm saying Haskell/GHC is not using its potential.
16:14:40 <avenge> I want to say "If you have a dictionary for Show, pass it in and use this function, if not use this other fallback function."
16:14:45 <Peaker> Eelis, ah, I agree
16:14:55 <copumpkin> avenge: why? the class is giving you additional information on the parameter, but you need to be explicit about it
16:15:12 <Peaker> avenge, Example where you'd want such a thing?
16:15:21 <avenge> Okay, here's an example I have right now.
16:15:22 <copumpkin> I actually had an example the other day
16:15:28 <copumpkin> of what avenge wants
16:16:00 <avenge> I have a somewhat complicated monad that can be in multiple states.  Simplifying somewhat, let's say we have:
16:16:00 <avenge> type M a = M1 a | M2 a | M3 a | ...
16:16:05 <Peaker> Can't the guy who's trying to use a non-Show type just use a newtype NoShow a = NoShow a ; instance Show (NoShow a) where show _ = "No Show!" ?
16:16:11 <itsmonktastic> argh I need to copy this whole conversation into an editor so I can read it in the morning
16:16:24 <Peaker> itsmonktastic, use IRC logs?
16:16:31 <itsmonktastic> meh I never do :p
16:16:31 <Peaker> itsmonktastic, there are online logs too
16:16:33 <avenge> Now for debugging purposes, I would like to be able to print out an "M a" whenever I have one (to see what stat it is in), and if I happen to know that type a has a Show dictionary, I'd like to show that, too.
16:16:34 <itsmonktastic> oh you mean
16:16:34 <copumpkin> it's replicateM in Data.Vector :) it's possible to write a super-efficient version for ST or IO, but not for other monads. The definition in Vector goes through lists, but could be specialized to the efficient version for ST or IO
16:16:34 <itsmonktastic> yeah
16:16:37 <itsmonktastic> awesome okay, ty
16:17:13 <avenge> Peaker: No, because my monad has to work for all types.
16:17:21 <Peaker> copumpkin, Specialized implementations for different types (for performance) sounds like a good idea. Different semantics based on whether something has an instance or not sound like a bad idea
16:17:43 <Peaker> avenge, But if you give your monad to a function that wants Show, just wrap the monadic value with NoShow
16:17:53 <malorie>  I'm sitting infront of my "first" problem (involving graphs) I want to solve using haskell. should I handroll everything on my own or rather go with something like Data.Graph, educational-wise?
16:17:57 <Peaker> avenge, (NoShow (M (anytypehere)))
16:18:01 <Saizan> it's a choice that could be made in some consistent way only at a place where 'a' is fully instantiated and when compiling an executable, otherwise you're doing something very "opportunistic" which is maybe ok for debugging but i wouldn't use anywhere else
16:18:28 <itsmonktastic> malorie: hand roll it, imo
16:18:37 <copumpkin> wow, this xhtml discussion on -cafe is pretty silly
16:18:40 <itsmonktastic> perhaps looking at Data.Graph for ideas
16:18:48 <avenge> Saizan, yes, it's mostly for debugging.  But would be very useful.
16:18:48 <copumpkin> yay pedantry
16:19:04 <malorie> itsmonktastic: ok :)
16:19:31 <avenge> Another example I have in a monad transformer is that I need to implement mfix two different ways, depending on whether the underlying monad is in the MonadIO class.
16:19:43 <avenge> Also no way to do this.
16:20:06 <Peaker> avenge, how come? Different semantics based on the instance existence?
16:21:28 <Ariato> is The Haskell Road to Logic, Maths and Programming a good place to start?
16:21:32 <avenge> Here's why:  If the monad is in MonadIO, I can use liftIO and unsafeInterleaveIO to implement a fixed-point combinator.  If the monad is not in MonadIO, then I need to re-execute it when it turned out I needed more input (and this would repeat side-effects if the monad were in MonadIO).
16:22:27 <Saizan> avenge: i think in the latter case you shouldn't make a MonadFix instance, you're breaking its intended semantics
16:23:03 <hpc> :t unsafeInterleaveIO
16:23:04 <avenge> Saizan:  But why?  If code is pure, I should be able to re-execute it deterministically?
16:23:04 <lambdabot> Not in scope: `unsafeInterleaveIO'
16:23:06 <Peaker> avenge, Why does it repeat side-effects ONLY if its in MonadIO?
16:23:15 <Peaker> avenge, What about MonadState?
16:23:54 <avenge> In that case I can re-wind the state.
16:24:31 <avenge> (mfix does this for me)
16:24:54 <Peaker> avenge, what about ST?
16:25:18 <Peaker> I haven't really worked with mfix much
16:25:22 <Saizan> avenge: 1) newtype NotIO a = NIO (IO a) deriving Monad wouldn't be MonadIO but still be able to perform I/O; 2) that's not the point because you're still performing the effects (even if not side) of that action multiple times
16:27:23 <Saizan> e.g. imagine your transformed monad is State Int, it's quite observable from the result if you use "modify (+1)" once or multiple times as part of your action
16:28:20 <avenge> Yes, I guess you have to look into the monad... But it's still possible to implement mfix for a lot of the cases.
16:29:09 <avenge> So suppose I have two type classes, MonadIO, and MonadRewindable.
16:29:25 <avenge> My monad transformer is MT.
16:30:20 <avenge> I want to declare:
16:30:21 <avenge> instance (MonadIO m) => MonadFix (MT m) where ...
16:30:21 <avenge> instance (MonadRewindable m) => MonadFix (MT m) where ...
16:30:35 <Saizan> to resolve MonadIO (MT m) you'd have to resolve whether m is MonadIO or MonadRewindable, the main problem is that you'll almost never have complete information about the instances of m
16:30:36 <avenge> But I can only declare one of those.
16:30:43 <Saizan> for any particular m
16:30:59 <Saizan> because another instance could always be added somewhere later in the module hierarchy
16:31:07 <Saizan> so you'd have different instances picked up
16:31:13 <Saizan> in the same program
16:31:17 <avenge> It's true, but should my monad be a member of both, then both implementations would be correct, so I'd be happy to use whichever matches the current dictionary I have.
16:31:44 <Saizan> they'd have different semantics though
16:31:59 <avenge> No, same semantics.  Two ways of computing the fixed point.  Same result.
16:32:50 <Saizan> in that case you could say that the typeclass system is being conservative
16:32:56 <Saizan> since it has no way to enforce that
16:33:39 <avenge> Agreed.
16:34:03 <benmachine> did community.haskell.org die again
16:34:15 <Saizan> with dependent types it could ask for a proof that the two choices are equivalent :)
16:36:30 <benmachine> I thought c.h.o got fixed somehow
16:36:33 <benmachine> some things never change?
16:36:55 <Saizan> avenge: i guess it'd be interesting to be able to declare classes specifying that such a convergence is not required, and so such restrictions should be lifted
16:37:44 <Saizan> they'd be quite different, i think
16:37:48 <avenge> Saizan: Yes.  Ideally it could be done more cleanly than in C++, where template specialization, overload resolution, and type promotion interact in a way that is hard to understand.
16:38:57 <benmachine> anyone know how I can get me some haskell-mode while community.haskell.org is toast?
16:39:00 <avenge> Saizan:  Another solution would be somehow to get rid of magically blessed classes.  The problem is that MonadFix is a special class that gives you access to the mdo keyword.  Similarly, Monad gives you special syntactic sugar.
16:39:05 <benmachine> (and thus both projects. and code.)
16:39:08 <Saizan> avenge: yeah, when i read that something is possible in C++ templates i think "off course! what couldn't be possible in that mess?"
16:39:20 <avenge> If I could implement MyMonadFix and use mymdo, I might be happy.
16:39:56 <Saizan> avenge: there's NoImplicitPrelude for that, or quasiquotations
16:40:14 <avenge> I don't think either of those helps.
16:40:20 <benmachine> they both help!
16:40:21 <benmachine> sorta
16:40:26 <benmachine> quasiquotes + haskell-src-meta
16:40:42 <benmachine> NoImplicitPrelude + custom prelude with your own mfix
16:40:50 <avenge> I've played with template Haskell, and not been able to get thinks as nice as do.
16:41:13 <avenge> NoImplicitPrelude might work, depending on the rules for what classes do and mdo correspond to.
16:41:14 <Saizan> avenge: NoImplicitPrelude let you rebind the do-notation to whatever >>=/return/fail you've in scope in the module, not sure about mdo
16:41:29 <benmachine> avenge: it'd look something like [$mymdo| blah; bleep; bloop |]
16:41:33 <Saizan> you decide the classed.
16:41:37 <Saizan> *classes
16:41:45 <benmachine> also, mdo is do rec nowadays isn't it?
16:41:55 <avenge> If the correspond to whatever "Monad" is in the current module, maybe.  If they correspond to Prelude.Monad, Prelude.return, etc., regardless of whether it's in scope, then I am SOL.
16:42:27 <Saizan> avenge: i've been saying that it's the former.
16:42:33 <Figs_> Are there any resources for learning mathematics by experimentation in Haskell?
16:42:39 <avenge> benmachine: the template-haskell thing is horrible.  It breaks from one release to the next, makes debugging harder, etc.  The NoImplicitPrelude might work.
16:42:42 <Saizan> avenge: actually it's not even tied to the class, just the method names
16:43:03 <benmachine> avenge: most things break from one release to the next :P
16:43:10 <benmachine> at least a little
16:43:37 <benmachine> as long as I keep on the ball, you'd only need to keep haskell-src-meta up to date, everything else would as close to Just Work as you'd need
16:43:53 <avenge> benmachine: I've used template haskell quite a bit.  It is *very* clunky.
16:44:04 <applicative> uh oh, trinithis is gone I just noticed the error message...
16:44:22 <benmachine> avenge: yes but other people do the hard work and you use their libraries
16:44:27 <Draconx|Laptop> GHC also doesn't support TH on all architectures that it targets
16:44:43 <avenge> Saizan:  I'm going to experiment with this.
16:45:31 <Figs_> Are there any resources for learning mathematics by experimentation in Haskell?
16:47:03 <Saizan> Figs_: http://www.haskell.org/haskellwiki/Haskell_and_mathematics <- maybe relevant?
16:47:47 <Figs_> I'll poke around at it, thanks.
16:52:06 <kulin> does anyone know what might be causing the 'workspace' module list to hide modules which are exposed in the 'package' module list view?
16:52:39 <kulin> oops wrong channel, sorry
16:53:11 <avenge> Saizan:  Okay, this seems to compute 3:
16:53:11 <avenge> (>>) = (+)
16:53:11 <avenge> test = do 1; 2
16:53:11 <avenge>  
16:53:14 <avenge>  
16:53:14 <kmc> kulin, you need to use a zygohistomorphic workspacemorphism
16:53:37 <kmc> avenge, nice hack :)
16:53:42 <kmc> do you need -XNoImplicitPrelude?
16:53:44 <notabel> kmc: no, no, this clearly calls for a generalized chronomorphism
16:54:05 <kulin> its probably a leksah bug, but i haven't use it enough to know for sure
16:54:08 <avenge> Currently I have:
16:54:09 <avenge> {-# OPTIONS_GHC -XNoImplicitPrelude #-}
16:54:09 <avenge>  
16:54:09 <avenge> module Main where
16:54:12 <avenge>  
16:54:12 <kulin> but i meant to post that in #leksah
16:54:15 <avenge> import qualified Prelude as Prelude
16:54:18 <avenge> import Prelude (fromInteger, Int(..), (+), error)
16:54:21 <avenge> import Data.String (IsString(..))
16:54:23 <kmc> avenge, don't paste more than a few lines in the channel
16:54:25 <avenge>  
16:54:26 <kmc> use hpaste.org or such
16:54:29 <avenge> fail :: a
16:54:29 <avenge> fail = error "failed"
16:54:32 <avenge>  
16:55:21 <avenge> Sorry.
16:56:45 <DanielDiaz> Definitely, working with the windows clipboard is not trivial.
16:57:24 <revenantphx> kmc: It seems the r5rs version there doesn't have a random primitive :\
16:57:31 <revenantphx> any idea how to get something like that?
16:57:36 <revenantphx> without switching the language version?
16:57:39 <kmc> i don't know Scheme well enough
16:57:57 <revenantphx> mmk
16:58:03 <revenantphx> anyways, it's pretty interesting
16:58:03 <kmc> you can implement a simple PRNG yourself
16:58:12 <revenantphx> yeah, thats what I was thinking
16:58:21 <kmc> i would look at the PLT-Scheme / Racket docs
16:58:26 <revenantphx> or just use a different dialect when needed
16:58:29 <kmc> they may have a library you can import
16:58:30 <revenantphx> Racket has random for instance
16:58:38 <kmc> i mean, random numbers shouldn't require a new language, just a library
16:58:45 <kmc> and that library might work in R5RS Scheme as well as Racket
16:58:54 <revenantphx> how does one import or load in R5RS
16:58:58 <kmc> i don't know
16:59:04 <revenantphx> mmk
16:59:42 <kmc> you could read the docs, or ask in #scheme or #racket
16:59:54 <kmc> or even #haskell-blah
17:04:08 <lispy> Do the right people know that community.haskell.org is down
17:04:28 <lispy> projects.haskell.org is down too because of it, and I think code.h.o
17:04:32 <lispy> It's a problem!
17:04:40 <lispy> Can't reach files...can't collaborate.
17:04:41 * lispy grumbles
17:05:26 <Figs_> This may be a bit of an odd question to ask here, but would the type signature for line integration be?
17:05:31 <Figs_> *what would
17:06:08 <Peaker> soegtk names its module Graphics.SOE.Gtk :-(  This is incompatible with the book.. why would they do this?
17:06:16 <Figs_> (I'm trying to understand what a line integral is, but I'm not quite sure what kinds of things its supposed to operate on and produce)
17:06:18 <kmc> Figs_, you can represent the path of integration by a parametrized curve
17:06:43 <kmc> in fact see http://en.wikipedia.org/wiki/Line_integral#Definition for exactly that, in maths notation
17:06:51 <kmc> line integral defined in terms of ordinary definite integral
17:07:01 <Figs_> That's what I've been looking at, but I'm having trouble following it.
17:07:27 <kmc> first, do you understand the idea of parametrizing the curve C by this function r : [a,b] â†’ C ?
17:07:44 <Figs_> I don't know what r : [a, b] -> C means in this context.
17:07:48 <zygoloid> Figs_: it'd be something like contourIntegral :: RealFrac a => Path -> (Point -> a) -> a
17:07:56 <kmc> let's set a=0, b=1
17:08:05 <kmc> r is going to take a number between 0 and 1
17:08:09 <chrisdone> hm. hpaste went down. and in a different way this time
17:08:11 <kmc> and return a point along the curve C
17:08:19 <Figs_> ok
17:08:28 <kmc> such that as x goes from 0 to 1, r(x) moves along the curve continuously from one endpoint to the other
17:08:35 <dankna> ah
17:08:48 <kmc> most graphing calculators have a parametric function mode, it's pretty fun to play with
17:09:11 <dankna> yeah, it is.  see I have a related problem in one of my back-burner projects.
17:09:16 <kmc> you can draw nice polar flowers and such if you set x(t) and y(t) to two trig functions of different periods
17:09:16 <dankna> where I'm setting text along a curve.
17:09:59 <kmc> Figs_, note that f is a function from R^n to R
17:10:05 <kmc> a "scalar field" over the space R^n
17:10:06 <dankna> so I have to transform an entire coordinate system - x in the inner system becomes distance along the curve in the outer system, and y becomes distance along a normal from it
17:10:25 <kmc> for example if n=2, you can visualize f as a greyscale image
17:10:33 <kmc> a brightness value at every point in the plane
17:10:35 <dankna> but it's never that simple.  for the text to look right the t value has to be corrected so that motion along the curve is monotonic
17:10:50 <dankna> I asked around a bit but nobody could suggest an analytic way to achieve that for my type of curve
17:11:03 <dankna> so I'm doing it empirically instead, with a cached lookup table
17:11:19 <kmc> (actually, the wikipedia definition allows that f is only defined at a subset U âŠ† R^n)
17:11:27 <kmc> Figs_, with me so far?
17:11:32 <dankna> anyway.  continue your discussion and pardon my monologue :)
17:11:49 <Figs_> kmc: Mostly yes; just your pasting of some of the notation is being garbled since my IRC client sucks. :)
17:12:00 <benmachine> dankna: can't you just differentiate the curve with respect to the parameter, and then divide by that? (or something)
17:12:01 <kmc> Figs_, try to set your IRC client to utf-8
17:12:04 <kmc> Figs_, but it's not improtant
17:12:17 <benmachine> vaguely remember a way to parametrise curves by arc length
17:12:19 <kmc> i think the only non-ASCII character i used was 'âŠ†' for 'subset or equal to'
17:12:33 <dankna> benmachine: hm.  the thing is that I actually don't feel I have a sufficient grasp of Calculus to do that.
17:12:34 <sshc> Can I convert a strict ByteString to a lazy ByteString by calling fromChunks [strictByteString] (just a singleton list)?
17:12:35 <Figs_> That comes out looking a bit like "as+" 
17:12:38 <kmc> weird
17:12:48 <benmachine> dankna: can you do differentiation?
17:13:01 <Peaker> sshc, Yeah, that's what's normally done
17:13:13 <sshc> Thanks
17:13:16 <dankna> benmachine: well, yes.  in particular, the differential of one of these curves (they're just Beziers) is a lower-degree of one of the same curves, which is the reason we use this type of curve in the first place.
17:13:28 <dankna> so I can certainly compute the derivative
17:13:56 <Peaker> sshc, http://hackage.haskell.org/packages/archive/bytestring-class/0.0.0/doc/html/src/Data-ByteString-Class.html#StrictByteString
17:13:56 <Figs_> kmc: What does the notation f(r(t))|r'(t)|dt mean here?
17:14:06 <benmachine> dankna: excuse me if I'm not making much sense, trying to remember notes of two terms ago :)
17:14:08 <kmc> f(r(t)) times the absolute value of r'(t)
17:14:17 <co_dh> when I cabal upgrade base, I got an error : impossible, lol
17:14:17 <kmc> r'(t) is d r(t) / dt
17:14:29 <dankna> you're making sense, you just haven't given a complete description of the math I would need yet :)
17:14:29 <benmachine> dankna: but hmm
17:14:40 <Peaker> co_dh, I don't think you should be upgrading core packages that came installed with ghc
17:14:41 <Figs_> ... ah. I didn't realize |...| was absolute value here for some reason
17:14:55 <benmachine> dankna: oh, bbl
17:14:57 <dankna> and I'm really out of my depth with calc.  I mean I understand what a derivative /is/ and I'm sure if you give me a canned recipe I'll be able to see why it works, but...
17:14:59 <dankna> oh, okie, haha
17:15:15 <dankna> anyway, thanks for the thought :)
17:15:24 <kmc> Figs_, yeah, it confused me for a sec too
17:15:34 <co_dh> Peaker: the reason is one of the package ( hfractal ) ask for base 4.2 , but I have 4.1
17:15:50 <co_dh> how can I solve this kind of problem ? 
17:16:00 <kmc> Figs_, did you read the "Derivation" section?
17:16:04 <Peaker> co_dh, Install a newer GHC I think
17:16:24 <co_dh> Peaker: oh, multiply GHC, that will be a nightmare. 
17:16:35 <Figs_> I haven't yet. I'll take a look.
17:16:36 <kmc> the basic idea is to chop the parametrized curve into segments from 0 to dt, dt to 2*dt, ..., 1-dt to dt
17:16:57 <co_dh> I hope haskell has the same version system as Python , that is : release as few version as possible, but test each version on all packages. 
17:17:19 <dankna> co_dh: mm... we have a build-bot so I suppose you /could/ call that testing...
17:17:20 <co_dh> How can we change haskell's package system ? post to haskell-cafe?
17:17:24 <Figs_> What is the type of the curve though (C)?
17:17:33 <kmc> Haskell doesn't release versions, unless you mean Haskell 98 and Haskell 2010 and such
17:17:39 <Peaker> co_dh, Haskell packages have a *lot* more dependencies than Python packages (because when code really is re-usable, you get lots of tiny pieces of code re-using each other..)
17:17:39 <dankna> post to haskell-cafe or cabal-devel or ghc-users or catch dcoutts when he's on
17:17:41 <kmc> Haskell Platform and GHC both release versions, on different schedules
17:17:50 <Peaker> co_dh, so managing Haskell libraries/repositories is harder
17:17:53 <kmc> you approximate the curve by lots of rectangles (imagine them sticking out of the plane, if the function is a scalar field over the plane)
17:18:12 <Peaker> co_dh, Generally all packages are supposed to work with the newest GHC.. Some don't work with older GHC
17:18:23 <kmc> the height of each rectangle is the value of f at the midpoint of that line segment, and the width is dt
17:18:43 <kmc> and then you do the usual thing, taking the limit as dt -> 0
17:18:47 <co_dh> from the point of view of a user, too many minor version will cause confusing. 
17:18:54 <co_dh> confusion..
17:18:58 <kmc> this should sound familiar from the regular sort of 1D integrals
17:19:13 <Peaker> co_dh, end-user, or Haskell programmer?
17:19:24 <Peaker> co_dh, Hackage/cabal-install is about bleeding edge newest (untested) releases
17:19:36 <Peaker> co_dh, if you want only tested releases you can use Haskell platform or your distro's centralized packaging
17:19:45 <kmc> Figs_, C is a set of points in the plane which you can "move along smoothly"
17:19:46 <co_dh> Peaker : both end-user and Haskell programmer. 
17:19:47 <Figs_> kmc: Yes, it does. I'm just curious what the type of it might be; intuitively, I think I get the idea.
17:20:08 <kmc> to define what that means, it's best to think in terms of the parametrization
17:20:19 <dankna> Haskell Platform includes a stable version of ghc and a set of about two dozen core, important libraries which are guaranteed to work with that version.
17:20:21 <co_dh> Peaker: I think stable and usability is more important than newest (untested)
17:20:38 <kmc> basically, you have a set C together with a piecewise continuous mapping r : [0,1] -> C
17:20:44 <kmc> which covers the whole set
17:20:56 <kmc> i'm sure those who know more topology can correct my definition, but that's the basic idea
17:21:03 <dankna> Hackage is the central repository of Haskell libraries and programs, and it has very limited editorial control compared to CPAN or what I imagine you have for Python.
17:21:07 <Figs_> C is a set of points then, as we're supposed to think of it?
17:21:11 <kmc> yes
17:21:13 <Figs_> ok
17:21:24 <dankna> all versions of a package can be obtained from Hackage, so it's theoretically both the stable and unstable repositories together.
17:21:24 <kmc> but it's not just any set, it's a set with this piecewise smooth parametrization
17:21:24 <Peaker> co_dh, end user is never supposed to install using cabal-install
17:21:32 <kmc> (most sets won't have any such parametrization)
17:21:32 <Peaker> co_dh, Haskell developer gets to choose bleeding edge or stable/old
17:21:50 <Peaker> co_dh, unfortunately stable/old is a bad choice these days :)
17:21:57 <Peaker> (not enough stable packaging going around afaik)
17:23:14 <dankna> I wonder if there would be sufficient volunteers for putting together some sort of blessed-package-and-version set, like Haskell Platform but on a larger scale and focusing more on issuing recommendations on version numbers than on making an installer bundle?
17:23:22 <dankna> I think we do fine without that, really, but.
17:23:58 <DanielDiaz> Hi, I want to install download package, but I get a build failure due to a missing header library: download.h. How can I solve it?
17:24:07 <applicative> if i have several versions of iconv afloat, is there an easy way to instruct "ghc --make ..." which one to use.
17:24:18 <dankna> It's worth noting that different versions of the same package (excepting core packages!) can coexist on the same installation.  So it's not like your stable-vs-edge choice is really a binding decision.
17:24:18 <Peaker> dankna, hey, even a meta-packages that depends on a specific version of a lot of packages that are known to work together reasonably could work 
17:24:23 <applicative> hah, DanielDiaz has rpblems with header files
17:24:26 <dankna> Peaker: yeah exactly, something like that
17:24:58 <benmachine> dankna: there are already people who think haskell-platform standardises too much :)
17:25:06 <Peaker> anyone could make a blessed-<person> meta-package
17:25:09 <benmachine> we're now stuck with the relatively buggy mtl, for example
17:25:18 <Figs_> How does f fit into all this? Are we taking the the curve, acting like it's a function of one dimension (parameterizing it), and then applying a function "f" to every "point" in the line and adding up all the f(r(t)) bits?
17:25:31 <kmc> yes
17:25:38 <Figs_> ok
17:25:44 <kmc> you use r to break the curve into little segments
17:25:50 <kmc> you accumulate a rectangle for each segment
17:25:58 <kmc> height = value of f at the segment midpoint
17:26:02 <kmc> width = segment length
17:26:09 <kmc> you sum up those rectangle areas
17:26:13 <Figs_> What is the rectangle relative to? I'm having trouble picturing that.
17:26:28 <kmc> imagine a scalar field on the plane
17:26:33 <kmc> i.e. a 2D greyscale image
17:26:40 <DanielDiaz> applicative: What do you mean? Is there no possible solution?
17:26:43 <kmc> and draw some curve in the plane
17:27:02 <dankna> benmachine: are there really?  hmm
17:27:11 <kmc> now pick two points along that curve, close together in its parametrization
17:27:19 <dankna> benmachine: I rather think that Haskell Platform is important
17:27:37 <dankna> I guess I see the point about mtl vs whatever its alternatives are
17:27:45 <kmc> the line segment between those points, which linearly approximates that part of the curve, is one side of a rectangle
17:27:57 <kmc> the other side comes *out of the page* towards you
17:28:02 <Figs_> ahhh, ok
17:28:06 <kmc> and has height proportional to the scalar field value halfway through the segment
17:28:14 <benmachine> dankna: people say that standardisation discourages innovation, e.g. monadLib is largely ignored despite having several technical superiorities
17:28:21 <applicative> DanielDiaz, sorry, I was just typing a question about h files when you asked.  
17:28:39 <benmachine> dankna: innovation is arguably particularly important in haskell, where the language and compilers evolve so fast
17:28:46 <benmachine> *quickly
17:28:51 <applicative> DanielDiaz, have you done 'cabal unpack download'   the file is in the cbits subdirectory.  
17:28:52 <DanielDiaz> applicative: don't worry
17:29:09 <Figs_> So, another way to think of it is that you've got your scalar field as basically a lumpy cake
17:29:25 <dankna> well, Haskell is a language that can easily build completely-static executables (something which Lispies are quick to tell you you don't need and shouldn't want and you're going to h*ll for asking), so I think I agree that it's okay to err a little on the side of rapid change
17:29:36 <dankna> because you aren't pushing a build-system nightmare on your users
17:29:56 <Figs_> and you cut out an infinitely thin ribbon from the cake (the curve)
17:30:03 <DanielDiaz> applicative: what exactly does unpack?
17:30:04 <applicative> DanielDiaz, I'm not sure why cabal install isn't finding it in your case though.
17:30:08 <dankna> you're right that innovation has some value
17:30:18 <dankna> er, I'm repeating myself, sorry
17:30:29 <Figs_> When you stretch that out, you have what looks basically like a regular function.
17:30:30 <applicative> DanielDiaz, cabal unpack x just gives you the unpacked directory 
17:30:44 <dankna> but standardization helps to attract new users
17:30:56 <Figs_> Our rectangles are slicing this up smaller and smaller?
17:31:09 <DanielDiaz> applicative: The error remains.
17:31:12 <dankna> because you aren't asking programmers who are new to Haskell to understand the distinctions between monad libraries and make their own choice - programmers who probably don't even understand what a monad is yet
17:31:21 <kmc> i heard it was a burrito
17:31:41 <Peaker> @replay monad sequence
17:31:41 <lambdabot> Unknown command, try @list
17:31:48 <Figs_> kmc: The monad is a burrito, not my cake, I assume? :)
17:31:59 <kmc> lete's say both
17:32:02 <Figs_> hehe
17:32:09 <kmc> Figs_, yeah
17:32:14 <kmc> Figs_, good analogy
17:32:24 <JoeyA> A monad is a monoid spitter-outer.  That's about the level I'm at :-)
17:32:32 <kmc> visualizing the scalar field as a curved surface over the plane
17:32:34 <dankna> I rather like that meta-metaphor.... whoever it was who said "A monad is like a bad metaphor for what monads are."
17:32:35 <kmc> instead of an image drawn on the plane
17:32:43 <kmc> that might be more useful, though harder to actually implement
17:32:54 <kmc> @quote bad.explanations
17:32:55 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
17:33:02 <dankna> ">>= combines two smaller metaphors, and return adds another layer of abstraction."
17:33:13 <dankna> @quote bad.metaphor
17:33:13 <lambdabot> No quotes match.
17:33:18 <dankna> @quote bad.*metaphor
17:33:18 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
17:33:25 <JoeyA> >>= means "plug into" and works in some really cool places.
17:33:38 <kmc> plug into the matrix
17:33:41 <JoeyA> readFile "foo" >>= writeFile "bar"
17:33:52 <Figs_> Plug my hot sauce into the burrito....
17:35:28 <applicative> DanielDiaz, I just tried to install download-0.3 and got a completely different error -- a kind error, strangely
17:35:28 <Figs_> kmc: I'm still a bit confused about how f fits in.
17:35:30 <Ariato> BONUS make sure you do a slovenian version too ;)
17:35:32 <JoeyA> (printf "%02x" =<< "hello") :: String -- plug "hello" into mai hex converter
17:35:39 <kmc> fits into what?
17:35:56 <Figs_> I have my ribbon of cake, now how does f get used?
17:36:23 <aristid> > [1..5] >>= join replicate
17:36:24 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
17:36:27 <Figs_> We take the height of each rectangle, and feed it to f?
17:36:42 <DanielDiaz> applicative: something like this? http://hackage.haskell.org/packages/archive/download/0.3/logs/failure/ghc-6.12
17:37:55 <JoeyA> Has anyone programmed by using Haskell to generate instructions in another language (like C)?
17:38:09 <kmc> yes
17:38:13 <dankna> yes
17:38:17 <Figs_> In plain old integration, if memory serves me, the idea is to take the bumpy ribbon and find its area
17:38:18 <JoeyA> In other words, using Haskell as a preprocessor, and writing a library to try to make "generating C code" look like "writing in C".
17:38:27 <kmc> there are lots of such projects
17:38:35 <kmc> though i don't know about that second part: an EDSL for emitting C
17:38:40 <copumpkin> :t \f x -> x >>= join f
17:38:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> a -> m b) -> m a -> m b
17:38:43 <kmc> usually you implement a more specialized EDSL and just produce C
17:38:50 <kmc> but a C EDSL would be a useful component in said implementation
17:39:04 <JoeyA> Are there any on Hackage?
17:39:04 <kmc> there is an EDSL for LLVM, and there's at least an AST / parser / prettyprinter library for C
17:39:13 <kmc> yeah
17:39:16 <kmc> http://hackage.haskell.org/package/atom
17:39:24 <kmc> http://blog.sw17ch.com/wordpress/?p=111
17:40:32 <kmc> http://hackage.haskell.org/package/accelerate generates CUDA and maybe C too
17:40:39 <Figs_> kmc: What does applying f get us exactly? We want to find the ribbon, transform it with f, and then find the area of the transformed ribbon? Is that the idea?
17:40:42 <JoeyA> I wonder if it would be possible to write an easy-to-use C code generator that uses the Haskell type checker to statically check aspects of a C program.
17:40:55 <kmc> some of conal's graphics stuff generates C
17:41:01 <kmc> i made a similar thing that generates C++ and GLSL
17:41:09 <kmc> Figs_, f is the function you're integrating, right?
17:41:18 <Figs_> Yes.
17:41:24 <kmc> so you have to use it somewhere
17:41:25 <kmc> you don't apply f to the ribbon
17:41:34 <Figs_> integral c f ds = ...
17:41:36 <kmc> f's input is a single point in the plane
17:41:51 <benmachine> dankna: btw, still interested in that curve-parametrisation thing? I've sort of written down something now that looks like it makes sense
17:42:00 <kmc> we pass it the midpoint of the segment of C that we're accumulating
17:42:01 <dankna> yes, very much interested
17:42:20 <kmc> use f's value for the height of the rectangle whose base is that segement
17:42:40 <Figs_> Yeah, but isn't that equivalent to transforming the height of the ribbon with f?
17:42:49 <kmc> what would the height of the ribbon be to start with?
17:43:03 <kmc> if you say 1 and by transform you mean "multiply" then, yes, it's equivalent
17:43:04 <Figs_> Whatever you cut out of the cake
17:43:08 <benmachine> dankna: ok so basically what I think you want is an arc-length parametrisation of the curve, yes? so that your curve r : R -> R^n has r(x) being x units along the curve, right?
17:43:12 <kmc> the height of the cake is already f(t)
17:43:19 <dankna> precisely so
17:43:24 <kmc> the cake *is* the function f
17:43:34 <Figs_> oh
17:43:40 <Figs_> Well, that's why I'm confused.
17:43:46 <kmc> the top of the cake is an arbitrarily shaped surface over the plane, right?
17:43:51 <kmc> what's specifying the shape of that surface?
17:44:13 <Figs_> It makes sense now. I thought we were getting the height out of the curve somehow.
17:44:20 <kmc> you are
17:44:24 <kmc> err no
17:44:25 <kmc> sorry
17:44:28 <kmc> you get it from f, not c
17:44:36 <benmachine> so take any parametrisation r(t), you basically want r(s) where s is arc length, I'm pretty sure r(s) = r(t) / (ds/dt)
17:45:00 <Figs_> Yeah, C is just the doodle to cut the ribbon from, f is the whole cake (uncut), and the integral c f is just the area of the ribbon you cut out of the cake, right?
17:45:16 <benmachine> or it might be r(t ds/dt) I can't quite remember >_>
17:45:20 <benmachine> yes that would make more sense
17:45:50 <Martty> man.. i totally got into c++s <algorithm> <functional> and <iterator> thanks to haskell <3
17:45:54 <benmachine> can't divide r(t) by a scalar that's nonsense
17:46:10 <wli> dr/ds = (dr/dt)*(dt/ds) = (dr/dt)/(ds/dt)
17:46:18 <benmachine> ugh I've made a mess
17:46:34 <dankna> hmm
17:46:45 <dankna> well, I'll try to implement it at some point in the next few days and tell you if it works :)
17:46:46 <benmachine> er, anyway, the tricky thing is working out ds/dt, but that's just pythagoras on dx/dt, dy/dt, etc.
17:46:53 <dankna> right okay
17:47:05 <Figs_> kmc: Thanks. I think I get what's going on now.
17:47:10 <benmachine> ds/dt = sqrt((dx/dt)^2 + (dy/dt)^2 + (dz/dt)^2)
17:47:32 <benmachine> if you like I could go and look up what the actual formula for r(s) in terms of r(t) is, it's in my notes somewhere
17:47:37 <dankna> it's actually in two dimensions in my application
17:47:39 <benmachine> but I think it's pretty simple
17:47:45 <benmachine> oh, yes
17:47:47 <benmachine> same difference :)
17:47:49 <dankna> yes
17:48:02 <wli> I already gave it.
17:48:17 <dankna> wli: oh, I was about to ask whether that was with reference to this.  thanks :)
17:48:51 <dankna> well, I hope you enjoyed solving the problem, haha.  I will certainly enjoy having the solution!
17:48:55 <benmachine> wli: oh right, it was just in a form I'm not used to
17:49:02 <Figs_> kmc: Now, if I forget what a line integral is, I can just tell myself "It's a piece of cake". :)
17:49:11 <co_dh> I got such a cabal error :
17:49:12 <co_dh> cuda-0.2.1 failed during the configure step. The exception was:
17:49:13 <co_dh> exit: ExitFailure 1
17:49:22 <benmachine> co_dh: look above that for the error
17:49:35 <benmachine> co_dh: that means "something else went wrong"
17:49:47 <wli> Reparametrization in terms of arc length is somewhat painful. Using the Frenet frame affairs is probably a better idea.
17:49:59 <dankna> what are those?
17:49:59 <co_dh> should I look at the compiling message above ? 
17:50:22 <benmachine> co_dh: yes
17:50:41 <wli> dankna: Equations interrelating the unit tangent, unit normal, and unit binormal, and defining them etc.
17:51:17 <applicative> ah, yes, ExitFailure 1, my favorite
17:51:21 <dankna> mm...  I'm not clear that that allows me to define my coordinate-system bendy twisty thing, R^2 -> R^2
17:51:46 <benmachine> http://en.wikipedia.org/wiki/Frenetâ€“Serret_formulas
17:51:47 <wli> dankna: For 3D curves this involves the curvature and torsion. There are some more funny things that happen in higher dimensions. 2D you lose torsion and just have curvature.
17:51:48 <benmachine> possibly.
17:52:05 <dankna> right, no torsion for me
17:52:19 <co_dh> It seemed that cuda forget to depend on c2hs.
17:52:22 <applicative> DanielDiaz, yes, the one you link is my kind error.  
17:52:26 <dankna> wikipedia has a hyphen, http://en.wikipedia.org/wiki/Frenet?Serret_formulas
17:52:40 <benmachine> co_dh: c2hs is an executable, I think you can only depend on libraries
17:52:42 <co_dh> how can I fix that ? ( add dependence to c2hs on cuda?)
17:52:47 <co_dh> oh. 
17:53:00 <benmachine> co_dh: ghc doesn't know what executables you have, so it can't tell if the dependency is satisfied
17:53:13 <Saizan> you could use build-tools: c2hs
17:53:30 <Saizan> it'd at least give a better error
17:53:39 <benmachine> ah
17:53:39 <co_dh> this is a problem for end user and haskell programmer
17:53:54 <DanielDiaz> applicative: That means: if I get download.h works fine, I'll get the kind error :(
17:53:55 <Saizan> and when cabal-install will be fixed to install build-tools from hackage..
17:54:00 <benmachine> co_dh: do end users actually compile their own stuff?
17:54:20 <wli> dankna: I think you'll just have the unit tangent and unit normal in 2D, interrelated via curvature.
17:54:29 <co_dh> benmachine: you are right.
17:55:00 <dankna> wli: yeah that doesn't necessarily help me because the "shape" of the transformation is very twisty, it's emphatically not an affine transform.  in fact it even has holes in it.
17:55:30 <wli> dankna: Doesn't sound like a trajectory. Not sure what to tell you, then.
17:55:30 <dankna> holes in the sense that not every point in the outer space is a possible return value of the inner-to-outer transformation
17:55:45 <dankna> it's fine, because I think benmachine's approach works for me
17:55:53 <dankna> thanks for the attempted aid anyway
18:00:23 <erg0t> somebody using haxml?
18:02:50 <Figs_> kmc: I'm trying to figure out how to change the cake picture for the vector version. ( http://en.wikipedia.org/wiki/Line_integral#Line_integral_of_a_vector_field ) Instead of a cake, what is the appropriate way to think of a vector field?
18:02:56 <benmachine> dankna: just a thought, if you have letters sitting on the line in the direction of the normal, the top of the letters is going to sweep faster around tight curves than the bottom, it might look pretty odd
18:03:33 <benmachine> dankna: maybe you could make the spacing non-uniform, dependent on curvature
18:03:33 <dankna> benmachine: experimentally that's not a huge problem, it can even be aesthetically pleasing
18:03:38 <benmachine> oh ok
18:03:45 <benmachine> continue then :P
18:03:47 <dankna> I did think about that :)
18:06:12 <wli> Figs: A force that varies with position is one way to think of vector fields.
18:06:50 <dankna> by the way, the simpler alternative to making the spacing non-uniform
18:07:15 <benmachine> centre the text vertically?
18:07:17 <dankna> would be to compute a single affine transform for each character, perhaps by transforming its centerpoint, rather than transforming the control points that comprise the character individually
18:07:30 <benmachine> oh, yes
18:08:00 <dankna> you might think that the nature of this transformation would make the curve behave like a magnifying lens, with the letterforms growing the further from the curve they extend, but that turns out not to be the case :)
18:08:10 <dankna> so what I just said would look okay
18:08:34 <dankna> but as I said, I think curving the actual letterform adds to the "wow, cool" quality of this and makes it more likely that people will use the feature to design logos and stuff.
18:09:02 <Figs_> wli: So, a line integral over a vector field would be going along following the curve adding up all the little arrows at each "point" on the curve?
18:09:17 <Figs_> wli: And the curve can be arbitrary, right?
18:10:42 <wli> Figs: Basically.
18:10:59 <cpressey> Hi - would anyone be able to field a Parsec question?  Specifically, how does endBy know when to end?  (When its parser p fails without consuming input?)
18:12:01 <lispy> ?hoogle endBy
18:12:01 <lambdabot> Text.Parsec.Combinator endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
18:12:01 <lambdabot> Text.ParserCombinators.ReadP endBy :: ReadP a -> ReadP sep -> ReadP [a]
18:12:01 <lambdabot> Text.ParserCombinators.Parsec.Combinator endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
18:13:09 <monochrom> I suppose so.
18:13:19 <lispy> cpressey: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Combinator.html#endBy
18:13:33 <lispy> in particular: endBy p sep         = many (do{ x <- p; sep; return x })
18:14:04 <co_dh> I have a iphone-cabal question : can I use GLUT with iphone-cable ? by use iphone-cable GLUT, can I run openGL program on iphone? 
18:14:11 <cpressey> OK, then: I'm not sure why this is not working: http://pastie.org/1138803
18:14:24 <lispy> cpressey: it looks like it would stop when either p or sep fails
18:15:29 <Figs_> ?hoogle endBy1
18:15:29 <lambdabot> Text.Parsec.Combinator endBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
18:15:29 <lambdabot> Text.ParserCombinators.ReadP endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
18:15:29 <lambdabot> Text.ParserCombinators.Parsec.Combinator endBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
18:16:22 <cpressey> The fail always happens, because it thinks END is an identifier.  But it seems like it should be 'caught' by the try.  And the pzero should supply the 'fails w/o consuming input' part.
18:16:38 <monochrom> What is an example x that doesn't work?
18:16:43 <cpressey> By "always" I mean, on a string like "BEGIN cow; dog; horse; END"
18:17:04 <cpressey> Or similar well-formed string.
18:17:06 <lispy> cpressey: well, identifier parses END and complains
18:17:32 <Figs_> Shouldn't you just make identifier match any identifer that isn't a reserved word rather than fail on a reserved word?
18:17:51 <cpressey> Figs_: How do you suggest that best be done?
18:18:15 <lispy> isn't there a takeTill in parsec?
18:18:19 <cpressey> I couldn't see an obvious way, except for failing.
18:18:20 <lispy> or manyTill
18:18:42 <lispy> -- | @manyTill p end@ applies parser @p@ /zero/ or more times until
18:18:42 <lispy> -- parser @end@ succeeds. Returns the list of values returned by @p@.
18:18:57 <cpressey> lispy: Replace endBy with a manyTill, you think?
18:19:21 <lispy> cpressey: basicaly
18:19:39 <cpressey> Sounds reasonable, I'll try that..
18:19:51 <lispy> simpleComment = do string "<!--"; manyTill anyChar (try (string "-->"))
18:20:22 <lispy> yours would be like, do string "BEGIN"; manyTill (string "END") (try identifier);
18:20:31 <lispy> then modify identifier to not care about END
18:21:07 <lispy> cpressey: oh, you might need (try $ string "END") because (string "END") and identifier overlap
18:21:18 <monochrom> methinks x<|>pzero is redundant
18:21:20 <lispy> I'm not good at knowing when I need try
18:22:17 <lispy> cpressey: also, you probably wanted sepBy1 not endBy1
18:22:22 <hpc> @src [] (<|>)
18:22:23 <lambdabot> (<|>) = (++)
18:22:23 <cpressey> Well, if I can modify identify to "not care" about "END", I can use endBy, I think; but how do you tell it to "not care"?  I have this confused with failing, I think.
18:22:55 <lispy> cpressey: just remove the check for END from identifier
18:23:04 <cpressey> lispy: Ah, ok.
18:23:39 <lispy> cpressey: also, you usually use one of either stripping all spaces when you enter a parser or stripping all spaces as you exit but not both
18:23:53 <lispy> cpressey: so in identifier, you probably want to remove the last call to spaces
18:24:22 <lispy> lexString s = spaces >> string s
18:24:27 <applicative> DanielDiaz, I see, the kind error makes sense, download-0.3 seems to presuppose the ancient tagsoup-0.6 or earlier.  Are you sure you need it for anything not in the HTTP package?  
18:24:35 <lispy> then use that inplace of string when you need to remove whitespace
18:24:55 <camio> I have a random question regarding lambda calculus. Given a typed lambda calculus with a fix operator, can one encode mutually recursive functions?
18:26:57 <lispy> cpressey: http://pastie.org/1138818  I'd probably write it like that
18:27:16 <lispy> cpressey: actually, I'd remove line 14
18:27:35 <lispy> updated it
18:27:50 <monochrom> http://pastie.org/1138820  works. Minimal change.
18:28:05 <lispy> cpressey: my version accepts empty lists BTW
18:28:35 <monochrom> empty list is easy: s/endBy1/endBy/
18:29:25 <lispy> monochrom: I think empty lists here are actually wrong
18:29:40 <lispy> monochrom: BEGIN END is probably not a valid list in this lanuage
18:29:44 <lispy> language*
18:29:48 <DanielDiaz> applicative: I just wanted to test it. And what is a package that does not work?
18:29:55 <monochrom> furthermore, the original "wrong" version works if you use: x = "BEGIN dog ;END"
18:29:57 <cpressey> lispy: Thanks.  I tried rewriting it myself with manyTill and got this, which works:  http://pastie.org/1138821
18:30:37 <lispy> hehe, yeah, man... in my version I reversed the parameters to manyTill
18:30:38 <cpressey> monochrom: You only changed how 'spaces' was being used?
18:30:43 <monochrom> YES!
18:30:49 <cpressey> Interesting :)
18:31:03 <cpressey> So much for shotgun parsing ;)
18:31:17 <lispy> cpressey: you should see how your program behaves with "BEGIN END" and "BEGIN ; END"
18:31:32 <Figs_> What is this for? (just curious)
18:31:57 <cpressey> lispy: Well, my version at least handles those properly (treats them as errors)
18:32:10 <lispy> cpressey: ah, cool
18:32:13 <monochrom> You have used "try" and "fail" correctly. Your spacing breaks, that's all.
18:32:27 <monochrom> Consider "BEGIN dog;   END"
18:32:39 <cpressey> Figs_: It's an artifical example; I'm still learning Parsec.  If you really want to know, it's a simplified version of the block strucure in the language PL-{GOTO}...
18:32:56 <monochrom> after char ';', we loop back and try identifier.
18:33:11 <monochrom> Well, identifier fails. That's fine.
18:33:27 <monochrom> But "   END" cannot be accepted by string "END" either.
18:33:55 <monochrom> Now consider "BEGIN dog;END". This works.
18:34:16 <cpressey> monochrom: Right, so it was failing in the wrong place, basically?
18:34:18 <monochrom> So the whole "my identifier is not rejecting END properly" theory is flawed.
18:35:16 <monochrom> After char ';', you should eat spaces successfully whether the next thing is identifier or END.
18:35:19 <Figs_> cpressey: Are you ultimately trying to end up with an AST for your language?
18:36:07 <cpressey> monochrom: Right, that's clearer now.  I'm not so used to dealing with whitespace in the parser; I should probably be using the lexer.
18:36:36 <cpressey> Figs_: Ultimately, yes, although it's an extremely simple language, so it's not a very complex AST.
18:36:47 <monochrom> This is one reason why Text.Parsec.Token sticks to the convention of "eat spaces after but not before"
18:37:33 <Figs_> I hacked up part of a text adventure parser the last time I played around with this stuff... let me see if I can dig it back up, might be helpful.
18:40:26 <applicative> DanielDiaz, It surprises me it isn't marked as deprecated.  If I hack the .cabal file to require tagsoup == 0.6, new errors arise. 
18:41:50 <DanielDiaz> applicative: last upload was in 2008
18:42:35 <applicative> DanielDiaz, yeah, that was the first bad sign.
18:42:43 <Figs_> cpressey: found it, if you're curious. It's not the best example since I'm learning too, but it might be interesting.
18:42:59 <Figs_> http://pastie.org/1138843  The command structure
18:43:06 <Figs_> http://pastie.org/1138844  The parser
18:43:09 <Saizan> > fst (fix (\(even,odd) -> (\n -> if n == 0 then True else odd (n-1), \n -> if n == 1 then True else even (n-1))) 5 -- camio
18:43:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:43:29 <Saizan> > fst (fix (\(even,odd) -> (\n -> if n == 0 then True else odd (n-1), \n -> if n == 1 then True else even (n-1))) 5
18:43:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:43:46 <Saizan> oh well.
18:43:56 <lispy> Saizan: do you need brackets around the last lambad?
18:43:58 <lispy> lambda*
18:44:04 <Figs_> I think I hacked my way around the spaces, which is probably not quite what you're after.
18:44:13 <lispy> > fst (fix (\(even,odd) -> (\n -> if n == 0 then True else odd (n-1), (\n -> if n == 1 then True else even (n-1)))) 5
18:44:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:47:19 <Figs_> http://pastie.org/1138848  Start of main interpreter (incomplete, but should be good enough to compile the thing to play with it)
18:47:56 <Saizan> lispy: the implementation is wrong anyway :)
18:48:18 <cpressey> Figs_: thanks :)
18:49:46 <Saizan> > fst (fix (\ ~(even,odd) -> (\n -> if n == 0 then True else odd (n-1), (\n -> if n == 1 then True else if n == 0 then False else even (n-1))))) 5
18:49:47 <lambdabot>   False
18:50:27 <applicative> DanielDiaz,  I notice the Tagsoup module Text.HTML.Download , though it still exists, is marked as deprecated in favor of Network.HTTP  Maybe there was a contest of packages in the past.
18:52:55 <DanielDiaz> applicative: True. Then, any dependency of the module is broken.
19:14:18 <kulin> im going to bug report something for leksah, but before i do i want to make sure it's not some feature of haskell modules that i am unaware of
19:14:42 <kulin> Graphics.Ogre.Goblin is just a string and has no more significance than Graphics.Goblin right?
19:14:56 <kulin> when naming your own modules
19:16:16 <kmc> various tools (e.g. haddock) will display modules using the hierarchy
19:16:41 <kmc> afaik it has no significance in the language itself
19:16:50 <kmc> in particular it's valid to have both Foo and Foo.Bar
19:17:05 <kulin> k, i just wanted to make sure the second word didn't have extra meaning or something
19:17:17 <kulin> thanks
19:18:37 <Funktorsalat> kulin: it's significant for the expected directory structure
19:18:53 <Funktorsalat> G.Goblin will be looked in at G/Goblin.[l]hs
19:18:58 <kulin> ya
19:19:14 <Funktorsalat> *looked for
19:32:37 <revenantphx> why must haskell complain about indentation with let and do blocks
19:32:50 <revenantphx> is there any written set of rules for the indentation it's expecting...?
19:34:19 <kmc> yes
19:34:29 <kmc> and furthermore, you can always ignore indentation if you use explicit { } ;
19:34:33 <kmc> let { x = 3; y = 4 }
19:34:47 <kmc> revenantphx, the rule is actually not too complicated
19:34:57 <revenantphx> oh do tell
19:35:04 <kmc> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
19:35:26 <revenantphx> see, I was playing with this snippet
19:35:27 <revenantphx> http://gist.github.com/565682
19:35:38 <revenantphx> and it seems moving the where clause to the same line as do makes it throw up
19:35:47 <revenantphx> which bothers me because it looks much nicer on the same line as do
19:36:14 <kmc> hmm, it works for me either way
19:36:23 <kmc> make sure you don't have any tab characters (\t) in your source
19:36:25 <revenantphx> hssock.hs:11:33: Empty 'do' construct
19:36:27 <revenantphx> I use soft tabs
19:36:30 <kmc> good
19:36:49 <revenantphx> it has to be in full tab increments I guess?
19:36:56 <kmc> no
19:36:57 <revenantphx> having where two (spaces) before do works
19:36:59 <kmc> any whitespace is ok
19:37:07 <revenantphx> but if I add two spaces so its on the same line as do... like this...
19:37:17 <kmc> revenantphx, when you indented "where", did you make sure to indent the lines below it too?
19:37:26 <revenantphx> this doesnt work
19:37:26 <revenantphx> http://gist.github.com/565682
19:37:33 <kmc> if "hPutStrLn" aligns with "talk" then it's considered another binding in the "where" block
19:37:47 <kmc> and becomes:  where { talk (h, n, p) = do; hPutStrLn h "hi!" }
19:37:53 <kmc> hence empty do construct
19:37:56 <kmc> per the rule i linked
19:38:05 <revenantphx> so how would I make this more pretty?
19:38:11 <revenantphx> it doesnt even align there
19:38:14 <revenantphx> its 2 spaces off
19:38:29 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29721#a29721 works
19:38:36 <kmc> (parses at least; these things aren't in socpe for me)
19:38:54 <revenantphx> gives me
19:38:54 <revenantphx> hssock.hs:11:33: Empty 'do' construct
19:38:54 <revenantphx> Failed, modules loaded: none.
19:39:05 <kmc> the one i just linked?
19:39:05 * hackagebot statistics 0.7.0.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.7.0.0 (BryanOSullivan)
19:39:07 * hackagebot mwc-random 0.8.0.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.8.0.0 (BryanOSullivan)
19:39:09 * hackagebot statistics 0.8.0.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.8.0.0 (BryanOSullivan)
19:39:10 <revenantphx> ah wait, no
19:39:12 <revenantphx> your link works
19:39:22 <kmc> did you follow my explanation above about the relative indentation of "where" versus "talk" versus "hPutStrLn"?
19:39:29 <revenantphx> but it seems the hPutStrLn has to be at least a full tab ahead of talk/sclose
19:39:45 <kmc> no
19:39:49 <kmc> it only has to be one space ahead
19:40:16 <revenantphx> which for me doesnt work > <
19:40:27 <revenantphx> this does not work
19:40:27 <revenantphx> http://gist.github.com/565684
19:40:28 <aristid> revenantphx: do you mix tabs and spaces?
19:40:33 <revenantphx> no, I ONLY USE SPACES
19:40:38 <revenantphx> my editor has tabs disabled
19:40:48 <kmc> revenantphx, this is about how i would write it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29723#a29723
19:41:12 <revenantphx> that compiles fine
19:41:13 <kmc> revenantphx, the trickiest question is where to put "where".  aligning it with the "do" statements is confusing, unless you have syntax highlighting
19:41:15 <kmc> i assume my reader does
19:41:25 <kmc> i don't really like to mix do and where like that, though
19:41:36 <revenantphx> yeah ...
19:41:42 <revenantphx> so whats the gist of the indentation rule then?
19:41:50 <kmc> did you read what i linked?
19:41:54 <kmc> there's one paragraph that explains it
19:42:12 <revenantphx> Yes I'm reading it
19:42:21 <kmc> revenantphx, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29724#a29724 is better i think
19:42:24 <revenantphx> but i'm wondering if theres a single statement to summarize it succintly with
19:42:35 <revenantphx> yeah, that looks better to me imo
19:42:46 <revenantphx> so one other question
19:42:53 <revenantphx> in the case of a monad chain like this
19:43:09 <revenantphx> is the type signature the type of the last one...?
19:43:28 <revenantphx> I'm a bit fuzzy still, trying to fully understand this stuff ^_^
19:43:29 <kmc> revenantphx, do you understand how the "do" notation desugars into (>>=) and (>>) ?
19:43:36 <revenantphx> roughly yes.
19:43:40 <kmc> ok
19:43:45 <kmc> well, you know the types of (>>) and (>>=)
19:44:00 <kmc> so there's your precise answer
19:44:03 <revenantphx> >>= should be be m b
19:44:10 <revenantphx> where m is a monad
19:44:13 <kmc> the informal answer is that yes, it's the type of the last statement
19:44:15 <revenantphx> if I recall correctly.
19:44:28 <kmc> (>>=) :: M a â†’ (a â†’ M b) â†’ M b
19:44:31 <kmc> for any monad M
19:44:33 <jmcarthur> why not this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29724#a29725
19:44:35 <revenantphx> right.
19:44:44 <kmc> so the RHS of >>= is a function
19:44:49 <kmc> but in the do notation, that's hidden
19:45:14 <revenantphx> so in this case I'd define that statement as type IO ()
19:45:18 <kmc> when you write Â«x â† a; bÂ» you are actually writing Â«a >>= (\x â†’ b)Â»
19:45:19 <jmcarthur> @undo do { x <- foo ; bar x }
19:45:20 <lambdabot> foo >>= \ x -> bar x
19:45:21 <revenantphx> since sClose is of type IO ()
19:45:37 <kmc> so the last statement is really the *body only* of a lambda expression, with the variables bound by stuff above
19:45:39 <kmc> yeah
19:46:10 <revenantphx> hm
19:46:15 <kmc> also think about what the type *should* be, not just what it is
19:46:21 <revenantphx> I need to look at how <- works more specifically
19:46:22 <kmc> oneShot will do some IO and produce no useful result
19:46:26 <jmcarthur> doh, error in my version
19:46:35 <jmcarthur> corrected in another modification
19:46:39 <revenantphx> kmc IO () seems appropriate then
19:46:43 <kmc> right
19:47:03 <kmc> and sometimes you will have a typo that gives it a valid type, but that type will be IO (IO ()) or something
19:47:09 <kmc> and so it's good to have the signature to force it to be IO ()
19:47:45 <kmc> yeah i like jmcarthur's version too
19:47:50 <kmc> inlining the definition of "talk"
19:48:08 <revenantphx> I do too
19:48:25 <revenantphx> but for a more complex socket handling it wouldn't be so simple ;P
19:48:27 <kmc> right
19:48:36 <kmc> a good case for defining a function inline with "let" is when you want to mapM_ it over a bunch of stuff, or if it's just really big
19:48:37 <revenantphx> you'd replace hPutStrLn with some other valid function
19:48:52 <revenantphx> that would be the entry point for some socket stuff
19:48:58 <kmc> yeah
19:49:02 <kmc> but you'd probably define that elsewhere
19:49:04 <kmc> not in a "where"
19:49:05 <revenantphx> exactly.
19:49:10 <kmc> maybe even pass it in as a parameter
19:49:14 <revenantphx> mm
19:49:28 <jmcarthur> i normally do extra work to avoid defining functions with let. i prefer to define functions with where or as a separate top level function when i can
19:49:33 <revenantphx> lemme try something and get back.
19:49:35 <kmc> yeah
19:49:36 <revenantphx> jmcarthur: I can see that.
19:49:38 <kmc> it's easier to test if at top level
19:49:46 <revenantphx> I don't exactly like let or lambdas everywhere
19:49:49 <kmc> but potentially shorter / clearer code locally, because you can use free variables
19:49:51 <revenantphx> unless they're simple lambdas
19:49:54 <kmc> it's a delicate balance of course
19:50:05 <kmc> revenantphx, yeah, good Haskell style tends to avoid explicit lambdas
19:50:13 <kmc> in favor of composing higher-order functions, operator sections, etc.
19:50:21 <Blkt`> good night everyone
19:50:24 <jmcarthur> i guess i can summarize my style as "try to keep closures small" :)
19:50:25 <revenantphx> mm
19:50:25 <kmc> don't name a very local value if you don't need to
19:50:29 <revenantphx> one moment, let me try something
19:51:19 <revenantphx> hm
19:51:32 <revenantphx> using jmcarthur's versin and defining its type as IO () produces errors :\
19:51:47 <kmc> the last one?
19:51:50 <jmcarthur> my version may be wrong
19:51:51 <revenantphx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29727#a29727
19:52:02 <kmc> hClose h
19:52:10 <kmc> that's not his version, that's my version
19:52:15 <jmcarthur> heh
19:52:17 <kmc> my bad
19:52:29 <revenantphx> nope, his too also doesnt have h
19:52:32 <jmcarthur> revenantphx: use the third one down that page
19:52:35 <kmc> liftM2 (>>) (flip hPutStrLn "hi!") hClose
19:52:37 <kmc> only not really ;P
19:52:38 <jmcarthur> yes it does :P
19:53:00 <revenantphx> "jmcarthur: why not this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29724#a29725"
19:53:33 <jmcarthur> revenantphx: i see "6|  hClose h"
19:53:42 <revenantphx> bizzare, I dont 0.o
19:53:45 <Mitar> ok
19:53:50 <revenantphx> line 6 is talk
19:53:51 <revenantphx> anyhow
19:53:51 <Mitar> i have read everything ;-)
19:53:59 <jmcarthur> revenantphx: mine doesn't even have talk
19:54:08 <revenantphx> repaste?...
19:54:10 <revenantphx> out of curiosity, what do you guys use to test your sockets?
19:54:11 <jmcarthur> revenantphx: refresh that page and look at the *third* version
19:54:13 <revenantphx> I use nc usually :\
19:54:18 <Mitar> and watched Ralf Lammel's video
19:54:19 <revenantphx> oh, I see.
19:54:27 <revenantphx> there it is
19:54:36 <dankna> nc here
19:54:39 <Mitar> on expression problem
19:54:45 <dankna> or telnet, which is not ideal, but it works...
19:55:03 <Mitar> i also read Software Extension and Integration with Type Classes and Fun With Type Functions articles and now i am full of questions
19:55:44 <revenantphx> ok so jmcarthur 
19:55:46 <aristid> revenantphx: socat is pretty flexible
19:56:06 <revenantphx> Here's where my understanding of monad chains falls apart
19:56:10 <Mitar> does type families help in any way with heterogeneous lists or should i use hlist or existentially quantified types for that?
19:56:19 <revenantphx> when you do (h, n, p) <- accept sock
19:56:25 <revenantphx> what exactly is happening there?
19:56:36 <revenantphx> you're binding the result of accept to that tuple?...
19:56:39 <aristid> revenantphx: if the pattern fails, fail is called
19:56:40 <jmcarthur> revenantphx:   accept sock >>= \(h, n, p) ->
19:56:53 <Mitar> !seen illissius
19:56:55 <revenantphx> I need to reexamine how do works more
19:57:09 <aristid> hmm i guess tuples are irrefutable
19:57:12 <jmcarthur> yeah, there's actually a fail in that desugaring too
19:57:14 <Mitar> hmm, seen?
19:57:25 <djahandarie> There is a fail in the desugaring? O.o
19:57:41 <jmcarthur> @undo do { (a, b) <- foo ; bar a b }
19:57:41 <lambdabot> foo >>= \ (a, b) -> bar a b
19:57:46 <jmcarthur> doesn't show there
19:57:55 <aristid> @undo do { Just x <- foo; bar x }
19:57:56 <lambdabot> foo >>= \ a -> case a of { Just x -> bar x; _ -> fail ""}
19:58:00 <revenantphx> that undo thing is useful
19:58:06 <jmcarthur> when it's correct
19:58:09 <revenantphx> heh
19:58:14 <aristid> jmcarthur: i guess it knows that tuples are irrefutable or so
19:58:24 <jmcarthur> i didn't think tuples were irrefutable
19:58:30 <jmcarthur> i mean, i wish they were...
19:58:31 <aristid> huh?
19:58:36 <aristid> bottom does not count
19:58:45 <aristid> no way you could call fail on bottom
19:58:53 <revenantphx> @undo do { (a, b) <- foo; bar ; baz a b }
19:58:53 <lambdabot> foo >>= \ (a, b) -> bar >> baz a b
19:58:57 <jmcarthur> > do { (a, b) <- return undefined ; return 5 } :: [Int]
19:58:58 <lambdabot>   *Exception: Prelude.undefined
19:59:03 <jmcarthur> aristid: ^^
19:59:05 <revenantphx> hm
19:59:09 <kmc> Mitar, afaik most of HList could be reimplemented with type families rather than multiparam type classes
19:59:13 <jmcarthur> err
19:59:13 <kmc> but doing so is a significant project
19:59:16 <jmcarthur> oh
19:59:22 <aristid> jmcarthur: fail is not involved :)
19:59:26 <kmc> Mitar, the easiest way to get a "heterogenous list" is to build a sum type of all the types you want to store
19:59:32 <Mitar> kmc: but what about heterogeneous lists?
19:59:32 <revenantphx> so in this case what are h n and p
19:59:39 <jmcarthur> i see
19:59:40 <kmc> data Value = Name String | Age Float; type Values = [Value]
19:59:40 <Mitar> i would like to have an open type
19:59:42 <revenantphx> accept seems to return an IO (Socket ,SockAddr)
19:59:44 <kmc> ah
19:59:51 <kmc> then you could use existentials or Data.Dynamic
20:00:10 <djahandarie> I wish Data.Dynamic would never need to be suggested
20:00:25 <jmcarthur> revenantphx: i don't know the api by heart ;)
20:00:31 <revenantphx> darn
20:00:34 <jmcarthur> :t Network.accept
20:00:35 <lambdabot> Network.Socket.Socket -> IO (GHC.IOBase.Handle, Network.Socket.HostName, Network.Socket.Internal.PortNumber)
20:00:39 <kmc> djahandarie, well there's two problems:
20:00:45 <jmcarthur> there you go :P
20:00:50 <revenantphx> thats... different than what I found myself.
20:00:52 <kmc> a) Haskell's type system is not powerful enough for me to convince it my types are okay
20:00:59 <kmc> b) I don't care enough to convince it my types are okay
20:01:01 <Mitar> but on page 8 of "Software Extension and Integration with Type Classes" Ralf explains a problem with existentials 
20:01:07 <kmc> c) My types might not be okay, because they come from the user
20:01:11 <kmc> three problems :)
20:01:14 <jmcarthur> @hoogle accept
20:01:15 <lambdabot> Network accept :: Socket -> IO (Handle, HostName, PortNumber)
20:01:15 <lambdabot> Network.Socket accept :: Socket -> IO (Socket, SockAddr)
20:01:15 <lambdabot> Network.CGI data Accept a
20:01:19 <djahandarie> kmc, what would be an example of a?
20:01:31 <jmcarthur> revenantphx: you were looking in Network.Socket, which is a different interface
20:01:36 <revenantphx>  > >
20:01:40 <jmcarthur> it's lower level
20:01:42 <revenantphx> yeah, so it seems.
20:01:53 <Mitar> The existential wrapping approach does not work well for multi-parameter type classes.
20:02:06 <kmc> djahandarie, most non-trivial uses of dependent types
20:02:06 <Mitar> this is what Ralf argues
20:02:23 <revenantphx> thats why
20:02:28 <kmc> though you can encode a lot of stuff in typeclass metaprogramming
20:02:33 <revenantphx> hey BSD sockets... my old friends :D
20:02:41 <kmc> i mean i'm sure you *could* write the type of "lists where prime-numbered elements are Int and others are Char"
20:02:45 <revenantphx> them mixing with haskell seems a bit like oil and water though
20:02:45 <kmc> but... damn
20:02:55 <dmwit> djahandarie: e.g. writing a function that takes only well-formed XML is second-nature with dependent-types, but would be a serious chore with typeclasses.
20:02:56 <djahandarie> Heh
20:02:59 <jmcarthur> there are valid cases for low level sockets in haskell though
20:03:07 <jmcarthur> i wrote some packet inspection code in haskell once
20:03:07 <kmc> i did enjoy http://blog.sigfpe.com/2010/08/constraining-types-with-regular.html though
20:03:11 <revenantphx> jmcarthur: cool.
20:03:21 <jmcarthur> got bored quickly though
20:03:26 <revenantphx> I'm considering writing some server sw with haskell as an experiment
20:03:32 <revenantphx> jmcarthur: BSD does that to you.
20:03:32 <kmc> Haskell is still a good language even for grungy, imperative, non-denotational programming
20:03:41 <djahandarie> I need to do more agda so I can feel unsatisfied with Haskell
20:03:42 <kmc> you lose some of the shine but it's still worlds ahead of C
20:03:51 <jmcarthur> revenantphx: irc bots are popular early projects :)
20:03:51 <revenantphx> eh, C is easy for me.
20:03:54 <roconnor> Haksell is the best language for grungy, imperative, non-denotational programming :)
20:03:58 <jmcarthur> just don't take it into #haskell :P
20:04:00 <kmc> unless you need manual memory management or the like
20:04:05 <revenantphx> jmcarthur: I wont :P
20:04:18 <revenantphx> kmc: I find the C style of thought easy
20:04:20 <revenantphx> i don't know.
20:04:22 <kmc> even then... Foreign.Marshal.Alloc :)
20:04:34 * roconnor finds the C sytle of thought impossible now-a-days
20:04:35 <jmcarthur> C is not horrible until you are working with other people
20:04:43 <revenantphx> jmcarthur: there you go.
20:04:53 <revenantphx> with C, you have to have 1/2 people per module
20:04:54 <revenantphx> an
20:05:01 <revenantphx> and NEVER have other people mess with it
20:05:02 <jmcarthur> when other people are involved you have to decipher other peoples' conventions, like error handling, etc.
20:05:12 <revenantphx> jmcarthur: or my infinite loop convention!
20:05:17 <jmcarthur> ?
20:05:23 <revenantphx> while(1>>0 && 0xC0DEDBAD) {
20:05:23 <djahandarie> It's not like Haskell has superb error handling conventions either imo
20:05:25 <revenantphx> :D
20:05:29 <roconnor> In the middle of restoring invariants of data structures you make a call to another procedure that is assuming the invarients all hold
20:05:31 <roconnor> boom!
20:05:35 <roconnor> what a nightmare
20:05:53 <jmcarthur> revenantphx: wat
20:06:16 <revenantphx> jmcarthur: any 0 value is false and any non-0 value is true in C
20:06:18 <revenantphx> so thats equivalent to
20:06:21 <jmcarthur> yeah i know
20:06:24 <kmc> #define ever (;;)
20:06:25 <revenantphx> while (1 && 1)
20:06:28 <jmcarthur> i was wondering... why?
20:06:34 <jmcarthur> why would you do that, that is
20:06:35 <revenantphx> kmc: #define for(;;)
20:06:51 <kmc> djahandarie, true, but at least some of the conventions show up in the type
20:06:54 <revenantphx> kmc: Oh I SEE WHAT YOU DID THERE
20:06:55 <aristid> revenantphx: i think that's invalid syntax
20:07:03 <kmc> :D revenantphx
20:07:04 <revenantphx> for(;;) is perfectly valid.
20:07:05 <kmc> tell all your friends
20:07:11 <revenantphx> kmc: I will XD
20:07:11 <aristid> #define for(;;) is not
20:07:14 <jmcarthur> cute
20:07:18 <kmc> revenantphx, have you seen http://en.wikipedia.org/wiki/Duff's_device
20:07:18 <revenantphx> aristid: no, I forgot the loop
20:07:30 <aristid> revenantphx: whatever. it is invalid
20:07:35 <revenantphx> I know
20:07:39 <Cygnet> hewwoes
20:07:41 <revenantphx> should have been #define loop for(;;)
20:07:49 <Cygnet> for(;;) is valid, but it's ugly
20:08:30 <revenantphx> Cygnet: it's also idiomatic.
20:08:35 <revenantphx> while(1) is uglier imo
20:08:51 <dmwit> Personally, I protect all my statements by for.
20:08:51 <roconnor> forever
20:08:59 <jmcarthur> i use while(1) because it's just the most obvious to read :P
20:09:00 <revenantphx> though the compiler will parse them all into a nonconditional jump either way
20:09:03 <Cygnet> but while(1) at least suggests that it's turing-complete
20:09:19 <Cygnet> for loops should only be for.. well.. for loops
20:09:33 <revenantphx> Cygnet: the difference blurs.
20:09:38 <revenantphx> in the end their all just conditional jumps
20:09:41 <revenantphx> they're*
20:09:43 <djahandarie> I had a lot of difficulty parsing that sentence
20:10:00 <revenantphx> idiomatic C takes some time to get used too
20:10:25 <Cygnet> but hey, i used to use for exclusively in my childhood.. nothing i'm proud of anymore though
20:10:26 <jmcarthur> i just wish idiomatic C included some standard for error handling
20:10:27 <revenantphx> stuff like int8_t byte = *(int8_t*)array; and such
20:10:48 <revenantphx> jmcarthur: imo the most robust way to handle it is with goto's
20:10:52 <jmcarthur> i hate how various libraries will present errors in completely different ways
20:10:53 <revenantphx> the cleanest is return values
20:11:16 <kulin> you have to know an awful lot of tricks to get by with modern c, which is why i hate it
20:11:29 <Draconx|Laptop> jmcarthur, is Haskell much better in that regard?
20:11:50 <jmcarthur> *far* better. at least with haskell error handling is type checkable
20:11:51 <revenantphx> kulin: not that many really
20:11:52 <Cygnet> revenantphx: the cleanest, yes, but alas not the most widely used
20:11:57 <revenantphx> jmcarthur: that's very true
20:12:56 <jmcarthur> raise your hand if you check for -EINT after every system call
20:12:58 <revenantphx> Can you implement C functions and bind them to haskell function declarations btw > >?
20:13:07 <jmcarthur> revenantphx: yes, and it's easy
20:13:09 <revenantphx> jmcarthur: too lazy.
20:13:17 <kulin> yes reven, thats basically all i do
20:13:29 <Draconx|Laptop> jmcarthur, a given library might use Either, Maybe, error, or something else.
20:13:30 <jmcarthur> revenantphx: just read up on the FFI :)
20:13:35 <kulin> its a bit sloppy, seems like ffi was designed some time ago and then forgotten
20:13:40 <kulin> but it works
20:13:58 <blackdog> kulin: I've found the FFI pretty clean, actually.
20:14:08 <kulin> i dont like a lack of namespacing
20:14:13 <blackdog> it's intended to be a base to work off
20:14:16 <revenantphx> kulin: This is C we're talking about
20:14:16 <jmcarthur> Draconx|Laptop: sure, and each is best for different situations. it's okay to have that variety because you can coerce various forms of errors, and it's all type checkable
20:14:45 <jmcarthur> Draconx|Laptop: the error function *should* only be used when partiality is the goal, of course, so it's an exception to this
20:14:52 <Draconx|Laptop> jmcarthur, I'm failing to see how the type checker helps with functions that call "error".
20:15:26 <revenantphx> also, C has errno.h
20:15:27 <kulin> blackdog: ya but there are weird parts that look bad, like the way function pointers are created or the syntax for ccall and the compile time checking
20:15:27 <jmcarthur> Draconx|Laptop: if the library uses error for something you are intended to handle then it's doing something very very wrong anyway
20:15:31 <revenantphx> though its not used as much as it should.
20:15:46 <revenantphx> kulin: Function pointers ALWAYS look bad, without typedefs
20:15:54 <jmcarthur> Draconx|Laptop: the only library i can think of that is notoriously bad about this is the binary package
20:15:59 <dmwit> Somebody got language wars all over my #haskell.
20:16:45 <bos> calling error makes your library's users strong. it's like the spartans leaving babies on the hillside overnight.
20:16:51 <blackdog> kulin: sure, but the point is that you use something like c2hs or hsc2hs on top, and compiler interpreters only have to worry about implementing the base FFI library correctly.
20:17:12 <revenantphx> also
20:17:14 <jmcarthur> bos: fortunately i have a spoon
20:17:16 <revenantphx> kmc: what the CRAP is that XD
20:17:30 <revenantphx> I see what it does, but its pretty funny.
20:17:42 <jmcarthur> it's something you should never do
20:17:47 <bos> jmcarthur: you should see my code that has to parse XML coming in off a socket in a stream!
20:17:48 <revenantphx> great example of bad C though
20:17:51 <revenantphx> it's unmaintainabel
20:17:59 <jmcarthur> it's well known though
20:18:09 <revenantphx> yeah really XD
20:18:15 <revenantphx> thats pretty hilarious.
20:18:29 <kmc> revenantphx, which?
20:18:35 <revenantphx> Duff's device.
20:18:37 <jmcarthur> i think he means duff's device
20:18:38 <kmc> oh
20:18:39 <kmc> hehehe
20:19:00 <blackdog> bos: ha. come back with your return value or on it.
20:19:02 <revenantphx> it's self-obfuscating code > >
20:19:45 <jmcarthur> i've been meaning to give this a shot: http://www.haskell.org/greencard/
20:20:09 <benmachine> bindings-dsl made me very happy when I started using it
20:20:46 <benmachine> has anyone made a straight-up header file -> .hsc file converter?
20:21:01 <jmcarthur> yeah i like bindings-dsl, but i keep wanting to go to higher level things
20:21:25 <jmcarthur> green card is supposedly the highest level so far
20:21:34 <jmcarthur> but i don't know of any projects that use it
20:21:42 <kulin> i havent used c2hs or hsc2hs, glanced at em, but haven't bothered because they didn't seem to offer much, which is better?
20:21:57 <bos> everyone uses hsc2hs
20:22:11 <jmcarthur> c2hs seems oddly tedious to me
20:22:27 <kmc> kulin, http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
20:22:30 <kmc> that describes c2hs
20:22:34 <jmcarthur> but i haven't used it as extensively as hsc2hs
20:22:34 <kmc> RWH describes hsc2hs
20:22:44 <kmc> c2hs is more powerful and more complicated
20:23:19 <bos> c2hs is usually the wrong answer unless you're trying to do something huge.
20:24:32 <kulin> well one thing i was considering was using them to help map hundreds of enums, but the type i wanted was data SomeEnum = A | B | C | D 
20:24:41 <kulin> and they just gave SomeEnum Int
20:25:09 <kmc> you should use gtk2hsc2hs :D
20:25:13 <kulin> hah
20:25:25 <kulin> is that a real thing?
20:25:31 <kmc> yes
20:25:37 <danderson> c2hs can automatically map an enum into haskell without explicitly listing all values, if all you want is a simple transformation on the names
20:25:39 <kmc> it's the gtk2hs projects' hacked up version of c2hs
20:25:50 <kmc> provided by package gtk2hs-buildutils
20:26:14 <kulin> haha
20:26:22 <danderson> as I recall hsc2hs, you need to specify the entire enum by hand in the binding
20:27:25 <danderson> that's the big difference as far as I'm concerned. The automatic type conversions that c2hs does for func declarations are also nice, if the API you're mapping can accomodate standard Haskell/C conversions
20:27:48 <danderson> hsc2hs requires you to do most of that work manually.
20:28:00 <kulin> well the way i work, is that i create my own api in c
20:28:03 <jmcarthur> danderson: bindings-dsl alleviates a lot of that though
20:28:09 <kulin> so i can make it whatever format i want
20:28:15 <danderson> which is fine for a small API, and hsc2hs is less painful to learn for those cases
20:29:05 <danderson> jmcarthur: oh, fun, I missed that library.
20:29:20 <danderson> Need to see whether it can do the ungodly transformations needed to bind the Linux Netlink API
20:29:21 <jmcarthur> it's not magic, but it helps
20:29:28 <jmcarthur> oh god
20:29:33 <danderson> if so, I can ditch my handrolled parser/transformer
20:29:34 <jmcarthur> i actually tried that
20:29:44 <jmcarthur> i gave up
20:29:50 <jmcarthur> it was just too unfun
20:29:52 <danderson> jmcarthur: I SUCCEEDED
20:29:53 <danderson> well, kinda.
20:30:07 <jmcarthur> you actually have a working netlink binding? :o
20:30:09 <danderson> the API is still very low level, but it's usable for the bits it implements
20:30:16 <jmcarthur> libnl?
20:30:21 <danderson> no
20:30:39 <jmcarthur> ah
20:30:47 <danderson> the netlink libs are all as crazy as the basic netlink C API
20:30:55 <jmcarthur> they are
20:31:08 <jmcarthur> well, i did find libnl a bit more convenient for C
20:31:16 <jmcarthur> probably not so helpful for a haskell binding though
20:31:18 <danderson> it's much simpler to approach netlink as what it actually is, a network protocol
20:31:39 <jmcarthur> i like libnl because it mirrors the interface from kernel space
20:31:47 <danderson> there's an RFC that describes the packet format (+/- a couple of organic mutations over time)
20:31:52 <jmcarthur> which i was using as part of the same project
20:32:02 <danderson> so I just went with that and wrote a packet parser :P
20:32:19 <jmcarthur> ah
20:32:48 <revenantphx> so 
20:32:49 <jmcarthur> yeah, i already had to learn the kernel api, so i didn't want to have to learn to use it as a network protocol in addition to that
20:32:51 <revenantphx> I have one question
20:33:00 <revenantphx> it's in relation to the birds/pole example on LYAH
20:33:15 <revenantphx> the type for landLeft is Birds -> Pole -> Maybe Pole
20:33:19 <revenantphx> aka 
20:33:25 <danderson> jmcarthur: makes sense. I don't know the kernel API, so learning it as a network protocol seemed like a useful approach
20:33:30 <revenantphx> a -> b -> m b
20:33:55 <danderson> and once the low-level network protocol parts of the library are complete (huge undertaking in itself), I can layer a nice haskell API on top
20:33:55 <revenantphx> and >>= is (m a -> ( a -> mb) -> mb
20:33:57 <lispy> ?djinn a -> b -> m b
20:33:58 <lambdabot> -- f cannot be realized.
20:34:09 <revenantphx> so does the definition of >>= not care about the additional parameters?
20:34:15 <revenantphx> or is this a result of currying...?
20:34:18 <revenantphx> I'm a bit unclear here.
20:34:25 <jmcarthur> danderson: oddly, the next project i worked on after that involved packet handling in the kernel :\
20:34:26 <lispy> revenantphx: link+
20:34:34 <lispy> revenantphx: er, I mean, link please?
20:34:42 <danderson> jmcarthur: oh that sounds like endless fun.
20:34:45 <revenantphx> http://learnyouahaskell.com/a-fistful-of-monads#walk-the-line
20:34:47 <danderson> if it's anything like netlink.
20:35:00 <revenantphx> the monad type is Maybe Pile
20:35:02 <revenantphx> Pole*
20:35:17 <revenantphx> and the function is Birds -> Pole -> Maybe Pole
20:35:18 <jmcarthur> danderson: i've had enough kernel development for a lifetime. i do not enjoy it anymore
20:35:46 <revenantphx> trying to better understand monad binding.
20:35:56 <danderson> no kidding.
20:36:00 <lispy> revenantphx: landRight 1 (0,0 >>= landLeft 2, is this what you're talking about?
20:36:10 <revenantphx> yeah, sure.
20:36:25 <revenantphx> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
20:36:25 <danderson> jmcarthur: in my case, it's more a means to an end: I want to be able to reconfigure network interfaces and the main routing table without using `ip`
20:36:26 <jmcarthur> @do return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2
20:36:26 <lambdabot> do { a <- do { a <- do { a <- return (0, 0); landRight 2 a}; landLeft 2 a}; landRight 2 a}
20:36:30 <revenantphx> landLeft :: Birds -> Pole -> Maybe Pole
20:36:30 <jmcarthur> revenantphx: ^^
20:36:38 <jmcarthur> wow that's ugly
20:36:44 <djahandarie> landLeft 2 is partially applied there, so it's type is (a -> m a) or (Pole -> Maybe Pole) in this case
20:36:44 <danderson> so I can do it from within an empty sandbox (with CAP_NET_ADMIN)
20:36:45 <revenantphx> do syntax doesn't help me here!
20:36:45 <jmcarthur> revenantphx: actually, ignore that :\
20:36:47 <revenantphx> > <
20:36:48 <lambdabot>   <no location info>: parse error on input `<'
20:37:00 <djahandarie> revenantphx, which fits right in the second parameter of >>=
20:37:20 <revenantphx> a -> b -> m a ?
20:37:34 <revenantphx> or b -> a -> m b (as it could be written)
20:37:40 <jmcarthur> danderson: yeah, i actually had to create my own netlink family for my project :\
20:37:42 <revenantphx> ah i see, since thats the same as
20:37:45 <djahandarie> revenantphx, huh?
20:37:46 <revenantphx> b -> (a -> m b)
20:37:52 <danderson> jmcarthur: oh ugh. My sympathies.
20:38:28 <djahandarie> revenantphx, yeah, that is landLeft, so once you evaluate that function with 2, you get back a -> m b
20:38:41 <revenantphx> yes that i got.
20:38:44 <revenantphx> ugh, give me a minute.
20:40:17 <revenantphx> so lets see
20:40:18 <revenantphx> if you have 
20:40:25 <revenantphx> return (0,0) >>= landLeft 2
20:40:27 <jmcarthur> danderson: it's not the ugliest thing i've ever had to do at least
20:40:37 <revenantphx> then type inference will make return (0,0) be of type Maybe (a, a)
20:40:43 <revenantphx> or something like that
20:40:47 <revenantphx> which is equivalent to Maybe Pole
20:41:02 <danderson> jmcarthur: there's worse? Do tell.
20:41:10 <revenantphx> so thats the first param of >>=...
20:41:32 <revenantphx> then a function that takes a pole and returns...
20:41:34 <revenantphx> something
20:41:40 <revenantphx> a monad version of something
20:41:42 <revenantphx> > >
20:41:43 <jmcarthur> danderson: write a rootkit
20:41:43 <lambdabot>   <no location info>: parse error on input `>'
20:42:16 <danderson> I'd think that would be rather fun, though horribly gnarly
20:42:25 <revenantphx> I think I see.
20:42:27 <djahandarie> revenantphx, return (0, 0) >>= landLeft 2 would error
20:42:28 <jmcarthur> it's less fun when you have to do it for work
20:42:33 <lispy> > let r00tkit  = text "You've been h4x0r'd" in r00tkit
20:42:35 <lambdabot>   You've been h4x0r'd
20:42:40 <djahandarie> revenantphx, since the 2 makes a an Int, which (0,0) is not
20:42:42 <revenantphx> no it doesnt
20:42:51 <revenantphx> it yields Just (2,0)
20:42:52 <djahandarie> Oh
20:42:53 <djahandarie> Haha
20:43:00 <revenantphx> landLeft takes an int
20:43:01 <djahandarie> My bad, it's fine
20:43:04 <danderson> jmcarthur: oh, when it actually has to do something specific, yeah, I can imagine.
20:43:08 * djahandarie sighs
20:43:13 <revenantphx> thats what I'm confused about, the multiple parameter situation
20:43:19 <jmcarthur> it's even less fun when it's not even a very unique thing to be doing at your workplace and don't get any bragging rights ;)
20:43:27 <revenantphx> the pole paameter for landLeft is just not there...
20:43:29 <revenantphx> > >
20:43:30 <lambdabot>   <no location info>: parse error on input `>'
20:43:58 <djahandarie> revenantphx, landRight 1 (0,0) evaluates to a Maybe Pole
20:44:00 <revenantphx> so in this case landLeft 2 takes a Pole and returns Maybe Pole
20:44:07 <revenantphx> djahandarie: 
20:44:11 <revenantphx> I see that, and I get it now
20:44:22 <revenantphx> providing the 2 there with the whole curried functions thing
20:44:23 <djahandarie> So that provides the pole to the landLeft 2
20:44:31 <revenantphx> gives you a function in the form (a -> m b)
20:44:37 <revenantphx> (Pole -> Maybe Pole)
20:44:58 <revenantphx> partial application is growing on me, but its not QUITE clear yet.
20:45:09 <jmcarthur> this was entirely white hat, i'd like to add
20:45:14 <revenantphx> its certainly a neat cncept.
20:45:26 <jmcarthur> black hat would probably have been more fun too ;)
20:45:41 <djahandarie> :t (>>=)
20:45:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:46:13 <djahandarie> revenantphx, so is it clear now or are you still unclear?
20:46:19 <revenantphx> It's clearER
20:46:26 <revenantphx> I get THIS example
20:46:31 <revenantphx> but I know i'll trip up later more ;)
20:46:40 <revenantphx> I'm trying to REALLY understand monads and their usage
20:46:44 <jmcarthur> danderson: honestly, the worst API i've ever been forced to use was xlib :P
20:46:47 <revenantphx> so I don't get tripped up with do statements later.
20:47:08 <revenantphx> jmcarthur: I've never used it myself, but Ive heard bad things > >
20:47:39 <danderson> jmcarthur: oh that sounds awful too.
20:47:53 <danderson> so many things I haven't been damaged by yet...
20:47:56 <lispy> revenantphx: your next monadic challenge is to figure out how "double n = join (+) n"
20:47:59 <djahandarie> revenantphx, monads are just an abstraction, and a fairly general one at that. They can be used for a ton of things (for example, lists, or even functions)
20:48:04 <djahandarie> lol lispy 
20:48:23 <revenantphx> double isn't a function I know > >
20:48:26 <revenantphx> ghci shows it as not in scope
20:48:34 <lispy> > let double n = join (+) n in double 10
20:48:35 <lambdabot>   20
20:48:36 <revenantphx> oh I see
20:48:37 <revenantphx> yeah
20:48:38 <aristid> revenantphx: that's because lispy just defined it
20:48:46 <revenantphx> aristid: yes yes, I got that
20:48:51 <revenantphx> okay sure, I'll go try > >
20:48:51 <dmwit> > map (join (+)) [0..10]
20:48:52 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20]
20:48:59 <djahandarie> revenantphx, it's going to be tough
20:49:10 <aristid> > map (join (*)) [1..10]
20:49:11 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
20:49:17 <jmcarthur> that was a dirty challenge
20:49:19 <djahandarie> revenantphx, the ((->)e) instance of Monad is not fun
20:49:20 <lispy> revenantphx: as a warm up exercise, I'd go study the Reader monad
20:49:27 <revenantphx> mmk...
20:49:27 <aristid> djahandarie: yes it is fun!
20:49:40 <jmcarthur> i love the ((->) a) instance
20:49:42 <revenantphx> djahandarie: that sounds scary
20:49:48 <revenantphx> oh, one thing
20:49:55 <revenantphx> I'm wondering how <- exactly works
20:50:00 <revenantphx> especially in list comprehensions
20:50:01 <jmcarthur> it's sugar
20:50:04 <revenantphx> (or is that just special syntax?)_
20:50:10 <lispy> revenantphx: it works by being translated to something else
20:50:13 <djahandarie> revenantphx, it isn't a Haskell function, it's just sugar which the compiler translates
20:50:16 <revenantphx> lispy: no, really?
20:50:21 <djahandarie> And... my sentence is useless by the time I finish translating
20:50:25 <aristid> do x <- a; b becomes a >>= \x -> b
20:50:29 <jmcarthur> a <- b   ==>  b >>= \a ->
20:50:30 <djahandarie> Or typing rather...
20:50:35 <lispy> do x <- e; exp  ===> e >>= \x -> exp
20:50:44 * djahandarie hears echo
20:50:50 <jmcarthur> echo
20:50:51 <revenantphx> I don't even know what ===> or ==> are > <
20:50:53 <aristid> echo
20:50:55 <djahandarie> revenantphx, nothing
20:51:01 <revenantphx> thanks aristid, i'll try to figure that out
20:51:06 <lispy> revenantphx: just a rewriting is all, just change from one notation to the other.
20:51:15 <jmcarthur> revenantphx: those were "becomes"
20:51:25 <lispy> ?undo do { x <- e; exp }
20:51:25 <lambdabot> e >>= \ x -> exp
20:51:34 <lispy> ?redo e >>= \x -> exp
20:51:34 <lambdabot> Maybe you meant: do read todo undo
20:51:39 <lispy> ?do e >>= \x -> exp
20:51:39 <lambdabot> do { x <- e; exp}
20:51:46 <aristid> @undo do { x <- e; y <- f; g }
20:51:46 <revenantphx> let me just try to understand that
20:51:46 <lambdabot> e >>= \ x -> f >>= \ y -> g
20:51:51 <revenantphx> I don't need to see it 100 times...
20:51:57 <revenantphx> in slightly different forms
20:52:05 <revenantphx> aristid: that example does help though
20:52:09 <djahandarie> The last one just said may help
20:52:09 <djahandarie> lol
20:52:11 <revenantphx> I'll go work on this, no more undos > <
20:52:12 * djahandarie sighs
20:52:24 <djahandarie> I'm just too slow these days
20:52:30 <revenantphx> aw
20:52:37 <lispy> lambdabot needs a @fix operator :)
20:52:43 <djahandarie> > fix error
20:52:44 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
20:53:00 <djahandarie> lispy, would that be like a command-level fixed point operator?
20:53:09 <lispy> djahandarie: yeah ;)
20:53:11 <revenantphx> so to speak in english...
20:53:12 <djahandarie> lol
20:53:37 <lispy> then you could "?fix type"
20:53:44 <lispy> ?fix type a -> b
20:53:44 <lambdabot> Maybe you meant: bid faq ft id thx
20:53:51 <revenantphx> a from b (a <- b) is the same as b bound to a lambda taking the monad type b and returning a
20:54:00 <revenantphx> the confusing part is that the flow is reverse.
20:54:06 <revenantphx> if that makes any sense to you guys... > >
20:54:17 <revenantphx> I'm used to strict lvar/rvar in C
20:54:40 <djahandarie> You don't need to think about it so complex when you're using do notation
20:54:50 <djahandarie> In fact that's the whole point of do notation... to make it easier to think about
20:55:10 <lispy> revenantphx: well, "do a <- b" is like "{ a = b; " in C
20:55:25 <jmcarthur> except do notation usually makes it worse, except for IO, ST, STM, and other inherently imperative monads
20:55:29 <lispy> revenantphx: in that it computes b and makes a be the result
20:55:31 <aristid> revenantphx: a <- b has no meaning outside do.
20:55:46 <revenantphx> lispy: right I understand that
20:55:48 <revenantphx> aristid: same
20:56:00 <aristid> revenantphx: the meaning in list comprehensions is similar but not exactly the same. i recommend not thinking about list comprehensions for now
20:56:04 <revenantphx> djahandarie: I LIKE C. I CAN'T STAND NOT UNDERSTANDING >:(
20:56:12 <revenantphx> aristid: yeah, gotcha
20:56:24 <djahandarie> Whoa got loud in here all of a sudden
20:56:30 <lispy> do a <- b; e    could be written as \a -> e =<< b, if that is easier to read
20:56:34 * djahandarie puts in his earbuds
20:56:34 <revenantphx> djahandarie: sorry > <
20:56:41 <jmcarthur> do notation is just more crap for beginners to have to learn, IMO. if it was up to me i'd have beginners writing desugared code for a while before even introducing do
20:56:49 <djahandarie> jmcarthur, same.
20:56:50 <revenantphx> jmcarthur: see I agree with that
20:56:55 <revenantphx> do notation just confuses me.
20:57:07 <revenantphx> if I dont know whats happening underneath
20:57:17 <revenantphx> syntactic sugar is like real sugar. You eat it AFTER a wholesome meal
20:57:26 <djahandarie> Heh
20:57:27 <dankna> haha
20:57:41 <aristid> revenantphx: you're currently learning it tho, so i think it'll be ok and you can mentally flip from one to the other as needed
20:57:55 <revenantphx> now 
20:58:02 <revenantphx> one other thing, and I MAY be going out on a limb here.
20:58:16 <revenantphx> (sarcasm)
20:58:28 <revenantphx> Haskell seems to be much more oriented towards educational and theoretical purposes than for doing actual work.
20:58:36 <revenantphx> though I don't deny its ability to do so.
20:58:40 <jmcarthur> revenantphx: if only that was still the case
20:58:48 * lispy writes haskell code for $day_job
20:58:53 <jmcarthur> real-world constraints, in my opinion, are slowing down innovation
20:59:05 <djahandarie> revenantphx, you can think of a <- b   where b :: Maybe Int   as temporarily extracting the Int out of the Maybe container and puting it in a
20:59:17 <revenantphx> djahandarie: oh I understand that
20:59:20 <lispy> Haskell is webscale.
20:59:22 <jmcarthur> lispy: you're at galois, right?
20:59:28 <lispy> jmcarthur: yup!
20:59:32 <revenantphx> The part that bugs me is the transition between each line of a do statement
20:59:34 <jmcarthur> lispy: make them hire me plz
20:59:36 <aristid> lispy: does it support sharding?
20:59:36 <jmcarthur> :)
20:59:41 <revenantphx> since I know they're inherently tied to bijnds
20:59:55 <lispy> aristid: sharding is the secret sauce of webscale
21:00:00 <revenantphx> for instance, if I do a <- monadthing
21:00:08 <revenantphx> then is a valid as a "local variable" for how long, and so on
21:00:10 <avenge> jmcarthur: Where are you now?
21:00:13 <revenantphx> and if so, how the hell is that working
21:00:15 <aristid> lispy: i heard /dev/null is webscale too, but i'm not sure if it supports sharding
21:00:16 <revenantphx> etc etc
21:00:17 <lispy> jmcarthur: I don't think we're hiring at the moment, but have you sent in your resume before?
21:00:23 <jmcarthur> avenge: do you mean job or location?
21:00:35 <avenge> Both.  I am looking to hire Haskell programmers.
21:00:36 <kmc> revenantphx, Â«do { x <- a; b }Â» desugars to Â«a >>= \x -> bÂ»
21:00:45 <jmcarthur> lispy: yeah, it's been sent in. it's probably not as impressive as it could be though
21:00:45 <kmc> or i should say
21:00:47 <djahandarie> revenantphx, it's really just a matter of replacing    a <- b; ...;...;    with     b >>= (\a -> do ...;..;)     then .
21:00:50 <kmc> Â«a >>= \x -> do { b }Â»
21:00:52 <revenantphx> kmc: I have been told this 10 times, and I understand that
21:00:55 <lispy> revenantphx: you can derive the answer to your question by following the desugaring
21:00:58 <kmc> because i mean that b itself could contain multiple statements still
21:00:59 <revenantphx> djahandarie: okay, so they nest?
21:01:02 <jmcarthur> avenge: i'm in huntsville, al, between jobs, able to move :)
21:01:04 <djahandarie> revenantphx, yep
21:01:05 <kmc> so it scopes over the rest of the "do" expression
21:01:09 <revenantphx> djahandarie: aaaaalright
21:01:11 <jmcarthur> usa, that is
21:01:15 <revenantphx> THAT fixes my brain
21:01:18 <revenantphx> thank youy
21:01:38 <revenantphx> kmc: I've been going through SICP btw, currnntly 60 pages in
21:01:45 <kmc> cool
21:01:49 <avenge> I'm at Stanford University.  Looking to hire researchers.
21:01:53 <revenantphx> I was reading in the car though, so I was only abel to do some of the exercises
21:01:53 <kmc> are you doing exercises?
21:01:55 <kmc> ok
21:01:58 <lispy> revenantphx: an when you get done with SICP, you'll start on Types and Programming Languages? ;)
21:02:00 <jmcarthur> ooh, what field?
21:02:05 <zachk> scheme is good for learning, but it becomes painful after a few years
21:02:10 <revenantphx> I'm gong to go back and do them all, don't worry
21:02:12 <jmcarthur> err, topic
21:02:13 <avenge> jmcarthur: Programming languages and security.
21:02:22 <revenantphx> I just didn't have the resources to work on them thoroughly in the car
21:02:25 <jmcarthur> awesome!
21:02:43 <jmcarthur> i have some security under my belt, and that's an area i'm interested in
21:02:52 <revenantphx> the tidbit on LamÃ©'s Theorem is fascinating
21:02:55 <jmcarthur> PLT+security, i mean
21:03:05 <avenge> We are an equal opportunity employer, so have to get the job advertisement vetted and officially posted by the university.
21:03:06 <revenantphx> I want to go find the proof for that thoeorem
21:03:09 <revenantphx> though I doubt I'd understand
21:03:16 <zachk> whats lame's theorem
21:03:23 <avenge> But will probably happen soon, if you want me to send it to you when it comes out.
21:03:29 <revenantphx> LameÌ's Theorem: If Euclid's Algorithm requires k steps to compute the GCD of some pair, then the smaller number in the pair must be greater than or equal to the kth Fibonacci number.
21:03:35 <jmcarthur> avenge: that would be great!
21:03:47 <djahandarie> Man I need to update my irssi
21:03:47 <jmcarthur> do you prefer email or just irc?
21:04:01 <revenantphx> btw, as a compliment to the people in this room,
21:04:05 <zachk> interesting
21:04:11 <avenge> jmcarthur:  You can email me at mazieres-uz9qz35zp24syqdgukssceufqw@temporary-address.scs.stanford.edu if you want.
21:04:13 <revenantphx> this is probably the "smartest" language room i've been in.
21:04:20 <revenantphx> If that makes sense.
21:04:28 <zachk> i find it the nicest 
21:04:32 <jmcarthur> revenantphx: i know. it's great, isn't it? :D
21:04:39 <revenantphx> jmcarthur: it really is ^_^
21:04:41 <djahandarie> revenantphx, only if you gauge smartness by theory knowledge
21:04:43 <avenge> Ditto for anyone else on here looking for a job hacking Haskell...
21:04:52 <revenantphx> instead of waiting 20 minutes for a half assed answer
21:04:59 <djahandarie> revenantphx, there are plenty of smart people who don't do much theory
21:05:01 <revenantphx> if I ask a question I get TEN ANSWERS AT ONCE
21:05:03 <revenantphx> and it hurts my head > <
21:05:08 <djahandarie> Heh that's a downside
21:05:09 <revenantphx> but its better than no answer :)
21:05:12 <lispy> ?quote fuge
21:05:12 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
21:05:18 <djahandarie> Mainly due to IRC which makes it hard to tell if other people are answering
21:05:18 <lispy> ?quote counter
21:05:18 <lambdabot> slava says: haskell.org really needs a hit counter and a guest book ... maybe a marquee too
21:05:19 <revenantphx> I have a backlog for a reason.
21:05:20 <kmc> @quote fugue
21:05:20 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
21:05:23 <jmcarthur> avenge: are you asking for resumes right now or just to get added to you mass mailout of the job ad?
21:05:25 <lispy> kmc: thanks!
21:05:28 <jmcarthur> *to your
21:05:43 <revenantphx> what's a fugue?
21:05:47 <revenantphx> and what does contrapuntal mean?
21:05:50 <lispy> ?wn fugue
21:05:53 <lambdabot> *** "fugue" wn "WordNet (r) 2.0"
21:05:53 <lambdabot> fugue
21:05:53 <lambdabot>      n 1: dissociative disorder in which a person forgets who who they
21:05:53 <lambdabot>           are and leaves home to creates a new life; during the
21:05:53 <lambdabot>           fugue there is no memory of the former life; after
21:05:55 <lambdabot> [6 @more lines]
21:05:55 <kmc> wikipedia may help you
21:06:01 <lispy> haha, wrong definition
21:06:05 <revenantphx> I don't think thats it
21:06:06 <revenantphx> > <
21:06:07 <lambdabot>   <no location info>: parse error on input `<'
21:06:10 <revenantphx> the musical definiton?
21:06:15 <lispy> revenantphx: yeah
21:06:15 <djahandarie> revenantphx, yeah
21:06:17 <jmcarthur> a fugue is also called a "round" by some people
21:06:21 <shap> Q about haskell mixfix: the spec is careful to emphasize that precedence is attached to the entity rather than the name. That's clear enough, but can somebody explain why the distinction is important in practice?
21:06:27 <revenantphx> lispy, djahandarie: perfect example right there :D
21:06:33 <revenantphx> two voices in harmony
21:06:37 <revenantphx> well, somewhat
21:06:42 <kmc> revenantphx, few people are forced to learn Haskell for work/school; most of us learned it for fun.  people who learn programming languages for fun tend to be smarter than the general population.
21:06:43 <zachk> http://users.informatik.uni-halle.de/~thielema/Music/HAL2/supercollider-haskore/Kantate147.mp3
21:06:45 <lispy> shap: haskell mixfix?  I thought we just had infix and prefix
21:06:49 <zachk> haskell making music
21:06:56 <revenantphx> kmc: yeah thats what I was thinking.
21:06:56 <shap> I get it that `a.+` and `+` can have distinct precedence, but I'm not clear why that matters in practice.
21:06:59 <kmc> revenantphx, this explanation does not rely on any property of Haskell itself except unpopularity
21:07:01 <shap> lispy: s/mixfix/infix/ then
21:07:06 <avenge> jmcarthur.  I wouldn't mind seeing resumees, to get a sense of who might be interested.  Again, for legal reasons I can't promise there will be a job until the University posts it, but I have a bunch of money coming in and will obviously need Haskell hackers.
21:07:08 <revenantphx> kmc: everyone I know calls me a masochist.
21:07:18 <revenantphx> Because I choose to write C over ruby or python
21:07:20 <aristid> kmc: also they don't tend to learn haskell because they think they need it
21:07:21 <revenantphx> for simple little scripts.
21:07:27 <shap> revenantphx: they are insightful, then.
21:07:28 <aristid> revenantphx: they are right :D
21:07:28 <shachaf> lispy: GHC has a postfix extension.
21:07:30 <kmc> Paul Graham wrote about the same thing about Python, when it was less popular: http://www.paulgraham.com/pypar.html
21:07:37 <jmcarthur> avenge: okay. in that case, i will send you an email tomorrow some time rather than tonight
21:07:38 <lispy> shap: perhaps it's so you can declare the infix precedence of function names? instead of only operators?
21:07:46 <revenantphx> shap: aristid: once again, perfect example of the fugue quote.
21:07:52 <revenantphx> but yes, I KNOW they're right.
21:07:58 <revenantphx> But it's more fun sometimes :D
21:08:04 <aristid> C is boring
21:08:10 <revenantphx> I dont find it boring :\
21:08:18 <revenantphx> and for things like working with the raw data of an image to count the colors in it... C is good.
21:08:18 <avenge> jmcarthur: Great, I appreciate it.
21:08:22 <revenantphx> Processing is better for that.
21:08:25 <revenantphx> But C is still good
21:08:33 <revenantphx> Processing makes that kind of job very easy.
21:08:36 <lispy> shap: like when you see: infixr `seq` 5
21:08:36 <shap> lispy: if (hypothetically) infix were handled as in agda, that wouldn't be an issue, so I doubt that's it.
21:08:56 <shap> The backquotes suffice for that.
21:09:11 <revenantphx> I like python btw kmc
21:09:25 <revenantphx> It's my favorite language after C (in the realm of imperative languages)
21:09:34 <shap> My guess is that it allows someone do a specialized binding for +, and then write something like "3 + 5 unnatural.+ 6"
21:09:42 <revenantphx> I get C level control but with nice succinct syntax that MAKES SENSE
21:09:56 <revenantphx> it doesn't try to introduce 500 new amazing syntaxes you should totally try out
21:10:10 <shap> lispy: but the use-case for this is to approximate type-directed precedence.
21:10:13 <revenantphx> well, C level control where I want it.
21:10:16 <aristid> shap: with qualified imports i guess it could almost be convenient
21:10:17 <revenantphx> like sockets and such.
21:10:21 <kmc> it's not really C-level control
21:10:27 <revenantphx> for sockets it is
21:10:31 <shap> aristid: example?
21:10:34 <kmc> you don't get to control memory management, or the layout of structures
21:10:35 <revenantphx> but I DONT get it where I dont want it
21:10:39 <revenantphx> liek memory management and object
21:10:41 <kmc> revenantphx, any language can call the low level sockets API
21:10:42 <revenantphx> mm
21:10:52 <revenantphx> kmc: yeah sure, but python also has as i said, clean syntax
21:10:58 <djahandarie> kmc, brainfuck?
21:10:59 <revenantphx> its easy to express an idea in python
21:11:04 <aristid> shap: well your example. but instead of Module.Full.Name.+ you just do N.+
21:11:05 <lispy> kmc: I don't think anyone has written the FFI for brainfuck yet ;)
21:11:05 <revenantphx> djahandarie: brainfuck++ can
21:11:12 <lispy> haha
21:11:17 <lispy> I fail to be quick witted
21:11:19 <revenantphx> it has sockets and file i/o
21:11:25 <revenantphx> no really, it does.
21:11:25 <lispy> beaten by other people here....again
21:11:27 <djahandarie> lol
21:11:29 <revenantphx> http://www.jitunleashed.com/bf/index.html
21:11:36 <aristid> shap: when it's too long it loses its operatoriness, IMO
21:11:48 <djahandarie> Unlambda? :P
21:11:56 <revenantphx> in any case, I find haskell pretty fun to work in
21:12:00 <revenantphx> well, play in ;)
21:12:13 <shap> aristid: but you're still doing N.+, and the question is: why didn't you overload Arith 'a? The only reason I can think of is that doing so would have broken some type-directed precedence concern.
21:12:15 <revenantphx> It's a bit hard for me since it's just SO DIFFERENT though, you know.
21:12:20 <alise> RABBLE RABBLE RABBLE
21:12:26 <lispy> revenantphx: well, sometimes haskell code can be unbearably mind bending
21:12:42 <revenantphx> lispy: it's kinda fun like that though
21:12:48 <revenantphx> in the same way mind bending C code is fun.
21:12:56 <aristid> shap: because not all + are really compatible with Num
21:13:00 <revenantphx> I have a fetish for having my mind bent by code I think.
21:13:10 <jmcarthur> you belong here then
21:13:11 <kmc> you sound like the Haskell type
21:13:12 <aristid> shap: for example, let's take * for dimensional values
21:13:26 <revenantphx> Its honestly hilarious
21:13:31 <kmc> revenantphx, read everything written by this guy Oleg Kiselyov
21:13:31 <revenantphx> there's almost always two people saying the same thing
21:13:45 <lispy> ?olegfact
21:13:45 <lambdabot> Unknown command, try @list
21:13:49 <djahandarie> ?oleg
21:13:51 <lambdabot>  Defined.
21:13:55 <jmcarthur> oh yes oleg will bend your mind into a paper clip
21:13:55 <djahandarie> lolwut
21:13:56 <lispy> hahaa
21:14:00 <aristid> ?oleg
21:14:02 <lambdabot>  Defined.
21:14:03 <shachaf> @quote OlegFacts
21:14:03 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
21:14:04 <lispy> ?let
21:14:05 <lambdabot>  Defined.
21:14:16 <revenantphx> kmc: one moment, I want to find out what ackermann's is.
21:14:25 <djahandarie> @quote OlegFacts
21:14:25 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
21:14:31 <kmc> revenantphx, he specializes in taking advanced language extensions to Haskell and showing how they're actually unnecessary through some bizarre encoding into Haskell 98
21:14:32 <revenantphx> The (h g) in SICP confused me
21:14:47 <aristid> @quote OlegFacts
21:14:47 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
21:14:48 <revenantphx> kmc: I'll take a look
21:14:51 <aristid> @quote OlegFacts
21:14:51 <lambdabot> OlegFacts says: Oleg implemented first-class continuations in Haskell... in the type system
21:15:00 <aristid> ok there are more tha two
21:15:02 <revenantphx> @quote OlegFacts
21:15:02 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
21:15:07 <revenantphx> > >
21:15:08 <kmc> sigh
21:15:08 <lambdabot>   <no location info>: parse error on input `>'
21:15:16 <lispy> ?quote milli
21:15:16 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
21:15:28 <shap> aristid: That doesn't fly. '*' is a method in the four-function arith type class. So if you define *, you better fit that signature. So the question is: why would you (a) choose to re-use the operator name and the signature (b) in a way that isn't precedence-compatible?
21:15:28 <djahandarie> Haha
21:15:35 <revenantphx> XD
21:15:46 <revenantphx> @quote OlegFacts
21:15:46 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
21:15:54 <shap> aristid: I'm not saying its wrong, I'm just trying to understand the use-case.
21:15:55 * revenantphx goes to pm
21:16:07 <aristid> shap: yes it does fly, because * on dimensional values make a heckuvalot sense
21:16:22 <aristid> shap: multiplying speeds by times MAKES SENSE :P
21:16:42 <aristid> :t (*)
21:16:43 <lambdabot> forall a. (Num a) => a -> a -> a
21:16:48 <revenantphx> those both sound like Num quantities
21:16:51 <aristid> but it doesn't fit in a -> a -> a
21:16:52 <lispy> aristid: but that would give you distance!?
21:16:56 <revenantphx> aristid: mind you sigfigs!
21:17:00 <revenantphx> your*
21:17:03 <djahandarie> When I see * I think kinds rather than multiplication...
21:17:09 <shap> aristid: OK, but now you're just arguing for multivariable type classes and three-type arith, no?
21:17:11 <revenantphx> dear god I hate sigfigs.
21:17:32 <revenantphx> my approach to accuracy is: set calculator to 15 decimal point, and at the very end truncate to 6 decimal places > >
21:17:34 <aristid> shap: and for having them coexist with the more standard (*)
21:17:47 <revenantphx> the AP graders are fne with it.
21:18:22 <revenantphx> aristid: shap: what exactly are you debating...?
21:18:34 <aristid> operator syntax
21:18:48 <shap> Yeah. So I think the first problem here is that the name (Num a) gives a bad intuition, and the second is that the single-variable definition of the type class gets in the way. But I don't see how either of those facts argues for a precedence discrepancy.
21:19:13 <aristid> shap: precedence? how did that topic creep in? oO
21:19:42 <revenantphx> aristid: more specifically?...
21:19:53 <aristid> revenantphx: i'm confused now.
21:20:01 <revenantphx> aristid: oh, we're in the same boat then
21:20:15 <revenantphx> you could say we're both instances of the Confused typeclass.
21:20:16 <shap> Because my original question was why it's useful to be able to say "infixl 2 +; infixl 5 `m.+`;" 
21:20:21 <revenantphx> ok, shoot me for saying that.
21:20:25 <revenantphx> please just shoot me.
21:20:37 <aristid> revenantphx: yeah except i understand double = join (+) \o/
21:20:42 <revenantphx> > >
21:20:43 <lambdabot>   <no location info>: parse error on input `>'
21:20:44 <shap> aristid: That is: why is infix*-specified precedence defined to act on the entity and not the token?
21:20:45 <kmc> type classes are boats?
21:20:55 <kmc> does that make Monad some kind of magical floating Mexican restaurant?
21:21:04 <revenantphx> kmc: EXACLTY
21:21:15 <aristid> shap: because nothing else in haskell is defined on tokens?
21:21:30 <shap> aristid: that's not a use-case
21:21:40 <aristid> it's a rationale :D
21:22:32 <shap> aristid: if you don't know a use-case, say so.
21:23:12 <shap> aristid: the back story is that I'm trying to resolve a parse handling problem in BitC around this where going to the "precedence is on the name" design is one way out, so I'm trying to understand what use-case is compromised if that is done.
21:23:55 <aristid> shap: i did not know that you were searching for use cases for precedence mixing, sorry
21:24:17 <shap> aristid: then you didn't read my question. Twice now.
21:24:36 <shap> aristid: specifically for precedence mixing **on the same operator**
21:24:55 <shap> arisitid: (but defined in two different modules)
21:24:58 <aristid> shap: huh? it didn't mention "use case" when i didn't understand it the second time
21:25:06 <lispy> shap: well, if you imported the same operator from 2 places, each with different precedence.  How should things parse?
21:25:12 <aristid> and the "on the same operator" is what i understood right from the beginning :P
21:25:46 <lispy> shap: I mean, the "same lexical token" when I say same operator.  I mean, they really have different definitions in different modues with different precedence
21:26:16 <revenantphx> one quick question
21:26:23 <lispy> one quick answer
21:26:27 <revenantphx> oh snap
21:26:29 <revenantphx> What is this rooms opinion of Java's future?
21:26:29 <kmc> three quick answers
21:26:30 <shap> lispy: let's back up, because talking about '+' brings in typeclasses, which confuses the issue quite a bit.
21:26:39 <revenantphx> My personal opinion is "dead in the water within a decade"
21:26:42 <lispy> shap: let's use .+
21:26:44 <djahandarie> Depends on Oracle
21:26:45 <Philippa> pretend + :: Int -> Int -> Int
21:26:46 <kmc> revenantphx, i will only point out that COBOL is still an incredibly important language
21:26:53 <revenantphx> kmc: haha
21:27:02 <Philippa> it'll do for parsing purposes, the parser doesn't know/care about types or type classes
21:27:17 <kmc> we quite often have language debates / flamewars, but it is also a bit off topic
21:27:26 <kmc> if people mind you should move it to #haskell-blah.  i don't mind at the moment
21:27:34 <chade25> Hi
21:27:37 <shap> lispy: I can see why, in general, two imports m.baz and k.baz might be entirely unrelated and want distinct precedence.
21:27:37 <revenantphx> kmc: oh no problem, sorry
21:27:43 <revenantphx> SUP CHAD
21:27:49 <kmc> revenantphx, i'm guilty of starting quite a few of them myself, so don't worry
21:27:51 <chade25> I have a question
21:27:51 <Cale> revenantphx: Languages with as many users as Java don't tend to die very quickly.
21:27:52 <revenantphx> kmc: haha.
21:27:53 <lispy> chade25: hello, and welcome.  Come in, sit down, make yourself comfortable and have a monad
21:27:57 <kmc> there is a certain language whose name begins with C and ends with +
21:28:10 <revenantphx> kmc: Oh don't worry, im with you on that one.
21:28:12 <revenantphx> I abhor C++.
21:28:13 <chade25> Is a Liberal Arts college with a Computer Science degree not as good as a state one?
21:28:20 <kmc> if you mention it here it will certainly create much excitement
21:28:21 <chade25> I abhor pure C
21:28:23 <djahandarie> lispy, wait, don't forget to ID him, we can't serve monads to minors
21:28:24 <kmc> great
21:28:32 <revenantphx> It does a bad job of maintaining the purity of C, and a bad job of providing clean OO.
21:28:34 <kmc> chade25, just look at the curriculum of classes you'd take
21:28:38 <shap> lispy: crap. That's probably the answer to my question right there.
21:28:42 <revenantphx> and a bad job of presenting error messages :D
21:28:52 <revenantphx> I spent 80% of my time on a C++ project figuring out STL errors
21:28:57 <aristid> revenantphx: don't try to create a c++ discussion. BAD KARMA
21:28:59 <kmc> chade25, if the 4 years are like "Intro to Java", "Intermediate Java", "Advanced Java", "Independent Project in Java"
21:29:02 <kmc> then it's crap
21:29:06 <djahandarie> Haha
21:29:13 <revenantphx> kmc: that's how the AP curriculum is now XD
21:29:14 <kmc> that's not a CS program; that's a vocational education for learning how to be a Java programmer
21:29:19 <revenantphx> kmc: AP CS is "intro to java"
21:29:25 <Philippa> shap: yup, that sounds like a clash whereby you'd have to either qualify the operators or leave only one in scope
21:29:30 <djahandarie> revenantphx, it is also data structures
21:29:31 <kmc> if that's what you want, go right ahead.  i have no problem with people who program as a job and aren't supergeeks
21:29:35 <lispy> shap: yeah, I have to admit, I was confused for a while because I thought you had answered your own question but were still asking it :)
21:29:36 <chade25> They have data structures, AI, Concurrent Prog, and OS
21:29:37 <revenantphx> djahandarie: barely
21:29:40 <kmc> however it's not CS by a long shot
21:29:50 <revenantphx> djahandarie: the data structures for AP CS are... ArrayList... and HashMap
21:29:57 <kmc> chade25, what's *required*?
21:30:06 <revenantphx> and the idiot student last year got errors because his ArrayList wasn't explicitly types.
21:30:06 <kmc> that'll be a good gauge of how serious the program is in general
21:30:11 <djahandarie> revenantphx, I think AB level has more
21:30:13 <revenantphx> and he was all MEEEEH IT DOESSSNTTT WORK 
21:30:22 <revenantphx> and the teacher was like "I DONT KNOW. SORRY"
21:30:37 <revenantphx> and I was like, "oh hey, I'll be nice and tell you, you need to explicitly specify the type of the list contents"
21:30:43 <shap> Philippa: no no. Both operators are qualified. The question boils down to whether it really makes sense to write something like "a m.baz b k.baz c". And I can think of examples. Obscure examples, but examples.
21:30:48 <revenantphx> and they were both like "YOU'RE NOT IN THIS CLASS >:D"
21:31:04 <revenantphx> so much for friendly advice > >
21:31:20 <chade25> Is PL/SQL valuable to know?
21:31:25 <revenantphx> SQL is certainly.
21:31:38 <revenantphx> though with stuff like LINQ, it's being abstracted away from a bit.
21:31:39 <chade25> SQL is cake
21:31:50 <chade25> what is LINQ
21:32:08 <revenantphx> its a .NET library commonly used for SQL and data object queries
21:32:33 <chade25> I need more knowledge in the .NET stuff
21:32:48 <Philippa> shap: if it makes sense to write a * b + c, it makes sense to write a m.* b k.* c, for sufficiently general values of * and +
21:32:52 <revenantphx> chade25: it's not nearly as fun, but I guess so
21:32:59 <kmc> LINQ is an implementation of various useful ideas from functional programming in C#
21:33:13 <kmc> with a particular goal of querying databases and other such things
21:33:14 <revenantphx> LINQ is also sexy.
21:33:32 <revenantphx> chade25: The cheapest way is what I'm doing now, get an internship at a .NET shop.
21:33:33 <aristid> revenantphx: haskell is sexier :P
21:33:37 <revenantphx> aristid: damn straight
21:34:31 <chade25> IM employed but we use PL/SQL for training, then when we get handed jobs, we pick what we code in and use
21:34:31 <kmc> LINQ is sexy largely because it brings stuff you'd have in Haskell to a "mainstream language"
21:34:37 <kmc> it's not a direct translation though
21:34:43 <revenantphx> kmc: mm
21:34:56 <kmc> i learned the other day that C# lambdas also capture an abstract syntax tree of their body, making them like both lambda and quote from Lisp
21:34:57 <revenantphx> also chade25, if you have to choose a .NET language, C#
21:35:06 <kmc> what about F#
21:35:11 <revenantphx> F# is a bit underdeveloped.
21:35:11 <kmc> i haven't decided yet whether this is clever or terrible
21:35:15 <revenantphx> you can't use it for most projects
21:35:15 <chade25> that is scripting
21:35:19 <revenantphx> VB is terrible anyhow
21:35:28 <revenantphx> I hate VB with a passion
21:35:36 <chade25> C# almost equals java
21:35:44 <revenantphx> C# is a "remake" of J#
21:36:01 <revenantphx> which was Microsoft's attempt to develop a clone/implementation of Sun Java
21:36:06 <revenantphx> they did that thing.. whats the word...
21:36:30 <revenantphx> they had reverse engineers tell programmers how java worked, but not the exact details
21:36:38 <revenantphx> so they could reconstruct something that worked the same
21:36:40 <kmc> chade25, C# 1.0 = Java.  since then C# has advanced and Java has not
21:36:46 <revenantphx> kmc: thsi is very true.
21:36:49 <kmc> C# actually has features you'd expect from a modern (~ mid 1980s) language
21:36:53 <kmc> like first-class functions
21:36:59 <revenantphx> AND UNSIGNED DATA TYPES
21:37:12 <revenantphx> Seriously, I met James Gosling, and I forgot to ask him why he didnt include those...
21:37:22 <revenantphx> He was a pretty nice guy anyhow.
21:37:28 <chade25> And you can do low level programming
21:37:35 <chade25> in C#
21:37:39 <kmc> Java was designed by committee for "typical programmers", by which the committee members meant people far stupider than they
21:37:54 <chade25> ALthough
21:37:57 <revenantphx> chade25: Any pointer arithmetic has to be in an "unsafe" region
21:37:57 <kmc> the result is not really designed for typical programmers but for lowest common denominator
21:38:01 <revenantphx> its thoroughly discouraged.
21:38:02 <chade25> Java documentation is nice
21:38:08 <kmc> also didn't i say earlier i wouldn't talk about Java so much
21:38:10 * kmc shuts up
21:38:17 <chade25> lol
21:38:19 <revenantphx> btw kmc
21:38:21 <revenantphx> one thing
21:38:46 <aristid> kmc: you can make it up by talking about agda for the next time
21:38:57 <revenantphx> kmc: I got bunny eared by james gosling a while back
21:38:58 <revenantphx> http://hphotos-snc3.fbcdn.net/hs043.snc3/13033_1262338523191_1371563053_747354_181892_n.jpg
21:38:59 <revenantphx> seriously.
21:39:04 <revenantphx> I didn't see his hand.
21:39:05 <kmc> well done
21:39:06 <revenantphx> > >
21:39:06 <lambdabot>   <no location info>: parse error on input `>'
21:39:13 <revenantphx> I got him back on the next one.
21:39:35 <revenantphx> When I saw the photo my response was FFFFFF--
21:40:02 <revenantphx> anyhow back to understanding monads...
21:40:10 <revenantphx> I'll go look at the Reader one as was recommended i suppose
21:40:49 <aristid> :t Reader
21:40:50 <lambdabot> forall r a. (r -> a) -> Reader r a
21:41:10 <revenantphx> that forall notation is bugging me
21:41:22 <revenantphx> > >
21:41:23 <lambdabot>   <no location info>: parse error on input `>'
21:41:40 <kmc> revenantphx, it just means that this function works for *every* choice of types r, a
21:41:45 <kmc> and the caller gets to choose which specific types go there
21:41:52 <kmc> it's not part of Haskell 98 but is supported by GHC
21:41:54 <revenantphx> kmc oh okay
21:41:58 <kmc> in simple cases you never need to write it yourself
21:42:11 <revenantphx> then why is it needed there?
21:42:12 <kmc> any type variables you use just get a forall on the outside of the type, like that
21:42:18 <kmc> it's not needed, lambdabot is just being explicit
21:42:23 <revenantphx> oh k
21:42:45 <aristid> > runReader (join (Reader (Reader . (+)))) 2
21:42:47 <lambdabot>   4
21:42:51 <kmc> it's needed in some fancier types eg
21:42:52 <kmc> :t runST
21:42:53 <lambdabot> forall a. (forall s. ST s a) -> a
21:43:03 <aristid> that's the same as join (+) in a Reader hull :D
21:43:03 * revenantphx 's mind begins to crumble
21:43:33 <kmc> Â«âˆ€ a. (âˆ€ s. ST s a) â†’ aÂ» is a different type from Â«âˆ€ a. âˆ€ s. (ST s a â†’ a)Â», the latter is what you would get without any explicit âˆ€
21:43:51 <revenantphx> I have to say, the progression from functors to monads to pseudo imperative code is pretty neat
21:44:02 <kmc> yeah
21:44:20 <kmc> i would say that it's real imperative code, but you're not executing it -- just building the code as a value and handing it off to the runtime system
21:44:35 <kmc> Haskell's IO monad is an embedded domain-specific language for computing imperative programs
21:44:43 <revenantphx> elaborate?...
21:44:45 <kmc> incidentally, a Haskell system can also execute these programs once specified
21:44:59 <kmc> well, a value of type Â«IO tÂ» is a recipe for how to do some IO and produce a result of type t
21:45:05 <kmc> just evaluating the recipe doesn't do anything
21:45:11 <kmc> you have to execute it
21:45:20 <revenantphx> whats up with the Â« btw
21:45:24 <kmc> and the only way to execute something is to name it "main", or to glue it onto something that's already getting executed
21:45:36 <revenantphx> (I don't mean in the unicode sense, I mean why are you writing them at all)
21:45:49 <kmc> i use guillemets to quote code, to distinguish it from the surrounding text
21:46:00 <revenantphx> kmc: oh okay
21:46:13 <kmc> and i use guillemets rather than parentheses or quotation marks because they're not typically part of Haskell syntax, so there's no confusion
21:46:33 <revenantphx> they're mapped to meta-\ and shitft-meta-\ on my keyboard...
21:46:34 <kmc> i hope your client displays them correctly; if not, you could switch it to UTF-8 mode
21:46:39 <revenantphx> it does
21:46:39 <kmc> cool
21:46:45 <kmc> i use Compose < <
21:46:48 <revenantphx> I'm on OS X, it defaults everything to UTF-8
21:47:06 <revenantphx> I have way too many encodings on here btw
21:47:47 <revenantphx> http://i56.tinypic.com/280rrlc.png
21:48:25 <revenantphx> There's no UTF-16 though... dunno why
21:48:41 <revenantphx> Obj-C NSString's are UTF-16 by default
21:48:46 <revenantphx> kinda odd :\
21:52:02 <Jonno_FTW> test
21:52:03 <lambdabot> Jonno_FTW: You have 1 new message. '/msg lambdabot @messages' to read it.
21:52:37 <revenantphx> test
21:52:42 <revenantphx> aw
21:54:20 <revenantphx> so kmc
21:54:29 <revenantphx> I'm trying to find a good way to think of a monad
21:54:38 <revenantphx> my current intuition is saying something like
21:54:44 <djahandarie> Usually it's either thought of as a container or a computation
21:54:48 <revenantphx> "wrapper-context-environment-
21:54:52 <revenantphx> around-a-value"
21:55:06 <Philippa> that's a decent intuition for monads-the-values, yeah
21:55:08 <revenantphx> I was wondering if that could be simplified.
21:55:11 <revenantphx> And made more correct.
21:55:23 <performance> revenantphx,  the easiest way to start thinking was to think of it as a tag
21:55:24 <kmc> revenantphx, the interface "Monad" is just too general to be summarized by one intuition
21:55:31 <Philippa> well, one POV is that a monad's specific kind of embedded language
21:55:40 <performance> but that by itslef is not sufficient
21:55:49 <Philippa> this is the one intuition that may contradict what kmc's saying, btw
21:56:06 <kmc> some monads are wrappers or contexts, some are "evaluation strategies", some are embedded languages
21:56:16 <kmc> i really encourage you not to fish for analogies
21:56:18 <Philippa> eh, they're all viewable as embedded languages
21:56:20 <performance> the funny way to think is, Monads are like Vegas [ there used to be a tv ad, what happens in Vegas stays in Vegas] 
21:56:22 <kmc> but just to learn and use some specific monads
21:56:27 <kmc> performance, no, no, no
21:56:28 <ManateeLazyCat> :preflex seen ivamn
21:56:28 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
21:56:37 <kmc> the one-way-ness of the IO monad is an *unusual* property
21:56:40 <kmc> most monads are not like that
21:57:07 <kmc> learning how to do IO and learning what monads are are two orthogonal things
21:57:11 <revenantphx> kmc: are they more like a stampede of raging bulls ridden by homosexual male gogo dancers escaping las vegas?
21:57:21 <kmc> definitely
21:57:21 <revenantphx> (straight towards salt lake city)
21:57:23 <Philippa> kmc: not everyone who wants intuitions is looking for analogies to spare them learning specific instances
21:57:25 <performance> kmc, not about the IO monad but in general, once a value is in a monad,  you annot get a pure value out 
21:57:29 <kmc> just another freak, in the freak kingdom
21:57:31 <kmc> performance, that's incorrect
21:57:46 <kmc> > case Just 3 of Just x -> show x; Nothing -> ""
21:57:46 <lambdabot>   "3"
21:57:51 <revenantphx> performance: The very definition of >>= proves that wrong
21:57:52 <revenantphx> > >
21:57:52 <Philippa> kmc: it's true that the general case doesn't give you a way of getting it out
21:57:53 <lambdabot>   <no location info>: parse error on input `>'
21:57:59 <kmc> yes
21:58:02 <revenantphx> :t (>>=)
21:58:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:58:05 <kmc> but most specific monads do
21:58:11 <kmc> revenantphx, thing is, the overall result is still b
21:58:14 <kmc> is still m b i mean
21:58:20 <revenantphx> yes, but it IS taking it out
21:58:25 <performance> bind is a-> mb -> a -> m b  
21:58:29 <kmc> as Philippa said, the monad interface *itself* provides no way to get a value out, but most specific monads do
21:58:29 <performance> ma 
21:58:33 <revenantphx> the important bit is m a -> (a
21:58:35 <revenantphx> "m a -> (a"
21:58:36 <kmc> IO does not
21:58:41 <kmc> it is atypical in this way
21:58:43 <performance> so you can never get a pure b out of it
21:58:44 <kmc> IO is a weird monad
21:58:49 <djahandarie> IO does not copoint!
21:58:57 <revenantphx> IO is a super freak.
21:59:00 <revenantphx> (she's super freaky
21:59:01 <revenantphx> )
21:59:01 <Philippa> revenantphx: actually a really perverse monad can use undefined as the a
21:59:22 <revenantphx> < <
21:59:37 <ManateeLazyCat> @tell siracusa I have check gtk2hs repository, have gtk/demo/embedded/MPlayer.hs (http://code.haskell.org/gtk2hs/gtk/demo/embedded/), maybe you delete from your local repository? I have re-compile again, works fine.
21:59:37 <lambdabot> Consider it noted.
22:00:11 <revenantphx> @tell revenantphx you are one handsome gentleman
22:00:11 <lambdabot> You can tell yourself!
22:00:14 <revenantphx> aw...
22:00:22 <revenantphx> ...
22:00:30 <revenantphx_> @tell member:revenantphx you are one handsome gentleman
22:00:30 <lambdabot> Consider it noted.
22:00:36 <ManateeLazyCat> >preflex seen ivamn
22:00:40 <Philippa> it's a variety of the 'const' monad - the oh-so-useful language that lets you write really complex programs that always have the same result
22:00:41 <revenantphx> test
22:00:42 <ManateeLazyCat> :preflex seen ivamn
22:00:46 <revenantphx> crap
22:00:55 <Funktorsalat> the trivial monad doesn't allow you to get a value out either :F
22:01:03 <revenantphx_> @tell revenantphx you are one handsome gentleman
22:01:03 <lambdabot> Consider it noted.
22:01:07 <djahandarie> Why are the co- instances usually not defined?
22:01:10 <revenantphx> okay
22:01:10 <lambdabot> revenantphx: You have 1 new message. '/msg lambdabot @messages' to read it.
22:01:13 <revenantphx> :D
22:01:28 * revenantphx feels content.
22:01:33 <ManateeLazyCat> @tell ivanm Look http://www.flickr.com/photos/48809572@N02/4959274664/lightbox/ (RSS/Atom reader, still in developing) . :) 
22:01:33 <lambdabot> Consider it noted.
22:01:35 <djahandarie> Just because category-extras is so monolithic?
22:01:57 <revenantphx> djahandarie: as an interesting extension of an Apathy monad
22:02:02 <djahandarie> Nice ManateeLazyCat 
22:02:04 <revenantphx> (which may or may not care to give you your value)
22:02:11 <ManateeLazyCat> djahandarie: Havne't finish.
22:02:20 <revenantphx> perhaps it should randomly decide to allow or not allow extraction of the value
22:02:31 <revenantphx> It doesnt care about your feelings after all.
22:02:37 <ManateeLazyCat> djahandarie: Some detail need perfect, like page cache improve browse speed.
22:03:15 <siracusa> ManateeLazyCat: I just looked in the hackage version of gtk-0.11.2, it's missing there.
22:03:15 <lambdabot> siracusa: You have 1 new message. '/msg lambdabot @messages' to read it.
22:03:38 <ManateeLazyCat> siracusa: Hmmm, maybe forgot in ~/.cabal file, i checking...
22:03:46 <djahandarie> ManateeLazyCat, is the RSS-reader stuff seperate from the gtk/display stuff?
22:03:57 <ManateeLazyCat> djahandarie: Yes.
22:04:41 <ManateeLazyCat> djahandarie: MVC design
22:05:06 <ManateeLazyCat> siracusa: Ah, you're right, forgot add in gtk.cabal. Sorry. :)
22:05:44 <siracusa> ManateeLazyCat: Does it compile for you?
22:05:49 <ManateeLazyCat> siracusa: Yes.
22:06:07 <ManateeLazyCat> siracusa: Please paste error message if you can't compile it.
22:09:01 <siracusa> ManateeLazyCat: `MPlayer.hs:71:12: Not in scope: `readTVarIO''
22:10:34 <ManateeLazyCat> siracusa: You need update your 'stm' package, readTVarIO just add in new version of stm.
22:11:20 <ManateeLazyCat> siracusa: I have push new patch to fix mplayer demo problem, thanks for report! :)
22:12:26 <tolkad> I was reading this: http://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/
22:12:30 <tolkad> which confused me
22:12:40 <tolkad> why does MaybeT not have this problem? http://hackage.haskell.org/packages/archive/MaybeT/0.1.2/doc/html/src/Control-Monad-Maybe.html#MaybeT
22:13:22 <tolkad> huh wait maybe I don't understand this properly
22:13:56 <tolkad> the problem arises if... you have multiple undecidable instances of the same class?
22:14:02 <ManateeLazyCat> siracusa: After you compile pass, you can use command "MPlayer ./YourMoviePath" to watch movie. :)
22:14:09 <tolkad> even for different data types?
22:14:29 <tolkad> so once maybeT creates an undecidable instance for Monad nobody else can?
22:14:55 <siracusa> @where hpaste
22:14:56 <lambdabot> http://hpaste.org/
22:15:07 <tolkad> can someone please help me understand this?
22:15:32 <ManateeLazyCat> siracusa: Ok now? I need off to coding now...
22:15:47 <tolkad> oh!
22:15:59 <siracusa> ManateeLazyCat: I fixed this stm error, but now I get this one: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29731#a29731
22:16:24 <tolkad> I see, all the instances involving MaybeT use the MaybeT datatype within the instance type somewhere, guaranteeing it wont match any other type
22:16:56 <tolkad> so you cannot have multiple undecideable instances for the same type class that could possibly match the same type?
22:16:59 <tolkad> is that correct?
22:17:07 <tolkad> (without potential problems I mean)
22:17:15 <siracusa> ManateeLazyCat: It's because fromNativeWindowId returns a Ptr.
22:17:44 <ManateeLazyCat> siracusa: Ah, mplayer just support Linux.
22:18:08 <ManateeLazyCat> siracusa: Because mplayer need ID of X-Window.
22:19:21 <siracusa> ManateeLazyCat: Do some gtk functions have differents types on linux? I think it should at least compile.
22:19:37 <tolkad> uh I'll just assume I'm right then
22:20:02 <ManateeLazyCat> siracusa: If you use linux, drawableGetID return Int (The ID of X-Window)
22:21:17 <ManateeLazyCat> siracusa: Uzbl.hs demo can work?
22:23:37 <ManateeLazyCat> siracusa: If Uzbl.hs or Embedded.hs can work, you can use GtkSocket/GtkPlug change the code of MPlayer.hs 
22:24:33 <siracusa> ManateeLazyCat: It compiles but `uzbl-core' is not found
22:24:36 <ManateeLazyCat> siracusa: Because mplayer or vim those X11 program need the id of X-Window, in principle, the id of GtkPlug should work, but mplayer will failed if you pass id of GtkPlug to mplayer process.
22:24:43 <ManateeLazyCat> siracusa: Embedded.hs can work?
22:25:57 <siracusa> ManateeLazyCat: `No instance for (Read (GHC.Ptr.Ptr a))' -- seems to bee the same problem.
22:27:34 <ManateeLazyCat> siracusa: This perhaps have two problem about `fromNativeWindowId`, one is wrong binding for Window platform, another is Windows not support GtkSocket/GtkPlug....
22:27:55 <ManateeLazyCat> siracusa: Unfortunately, i haven't Windows for test, can you send this bug report to gtk2hs list? Thanks!
22:28:45 <siracusa> ManateeLazyCat: Ok, I'll try to find a solution, otherwise I'll post a report to the list. Thanks for the help!
22:29:10 <ManateeLazyCat> siracusa: NP :)
22:30:29 * ManateeLazyCat Bye all. 
22:30:31 <tsk00> hi, i've anewbie question, I can't compile this simple problem. http://pastebin.ca/1933153
22:31:01 <tsk00> i cannot pass empty lists to a function
22:31:09 <tsk00> any help?
22:31:34 <performance> is any one interested in trying http://www.codechef.com/problems/FLIPCOIN/ with a Haskell solution?
22:31:47 <performance> please dont give me your solution!! I am also trying it.
22:33:19 <siracusa> tsk00: You have to give it a specific type, like `[] :: [Int]'.
22:34:13 <pantsd_home> If I have something like "fixCLRF ('\r':'\n':xs) = '\r':'\n':(fixCLRF xs)" and I want to make it work with ByteStrings, what would I do?
22:53:54 <tsk00> siracusa, thanks, it worked
22:55:17 <notabel> fixCRLF bs = if null bs then bs else let (x,xs) = breakSubstring "\r\n" bs in x `snoc` '\r' `append` (fixCRLF $ drop 2 xs) 
22:55:50 <notabel> pantsd_home: that's a pretty direct translation of your function...though i changed it a little, since yours didn't terminate, or change the string :-)
22:57:33 <kmc> :t () :: (() :: *)
22:57:34 <lambdabot> ()
22:57:41 <kmc> :t () :: (() :: *) :: (() :: *)
22:57:42 <lambdabot> parse error on input `::'
22:57:47 <kmc> :t (() :: (() :: *)) :: (() :: *)
22:57:48 <lambdabot> ()
22:58:13 <djahandarie> ?
22:58:19 <kmc> miscellaneous stupidity
22:59:37 <djahandarie> Who the hell named the Monoid function mappend?
22:59:48 <djahandarie> And on that note, who the hell made Num
22:59:52 * djahandarie grumbles
23:01:08 <djahandarie> Are groups/semigroups/loops/quasigroups/magmas/groupoids/etc already written out in some package?
23:01:21 <kmc> http://hackage.haskell.org/package/numeric-prelude
23:01:27 <kmc> if you can handle some industrial-grade crazy
23:01:48 <kmc> i think my favorite part are the "Instances" list
23:01:50 <kmc> haddock is uniquely ill-suited to this package
23:02:23 <djahandarie> Haha
23:03:51 <djahandarie> I'm not sure I fully agree with how that is laid out, not sure yet though
23:04:48 <avenge> kmc: Cool, this package shows how to get multiple paragraphs into the .cabal description (namely with . on a line).
23:04:55 <avenge> I always wondered how to do that.
23:16:19 <pantsd_home> notabel: thanks :)
23:20:37 <iskren_> hello, I want to create an array (Data.Array) but I want to give the indexes in a nonsorted order. Is there any way to check if an item is already in the array for a given index (i.e check for undefined) so that I won't predefine indexes
23:21:32 <kmc> the function 'array' takes a list of (index, element) pairs
23:21:49 <kmc> do they have to be ordered by index? i don't believe so
23:21:57 <iskren_> kmc, they don't
23:22:02 <iskren_> kmc, ok here is the problem
23:22:54 <iskren_> when i start calculating 5 I may need to calculate 10, and then 15, and then 3, which is already calculated, so I want to put in the array all intermediate indexes (10, 15) and then do not compute them again
23:23:19 <kmc> are you doing memoization?
23:23:22 <iskren_> yes
23:23:23 <iskren_> :)
23:23:28 <iskren_> that is what I want to do
23:23:31 <kmc> perhaps you could use data-memocombinators instead of an array
23:23:34 <kmc> but also
23:23:55 <kmc> you can fill the array completely, with calls to functions that index into the array
23:24:13 <kmc> it works out due to laziness
23:24:20 <copumpkin> it's quite beautiful!
23:24:37 <iskren_> ok but I still don't get it
23:24:45 <iskren_> the array constructor
23:24:50 <copumpkin> make the array refer to itself :)
23:24:56 <kmc> > let a = listArray (0,2) [5, 3 * (a!0), (a!1) + (a!2)] in a!3
23:24:57 <lambdabot>   *Exception: Error in array index
23:25:01 <kmc> > let a = listArray (0,2) [5, 3 * (a!0), (a!1) + (a!2)] in a!2
23:25:04 <iskren_> will "put" in the array the pairs which have gone out of the list comprehension
23:25:05 <lambdabot>   mueval-core: Time limit exceeded
23:25:06 <iskren_> right?
23:25:08 <kmc> > let a = listArray (0,2) [5, 3 * (a!0), (a!0) + (a!1)] in a!2
23:25:09 <lambdabot>   20
23:25:11 <kmc> there you go
23:25:24 <kmc> sorry it took a sec to get right
23:25:53 <kmc> note my second attempt had a cycle (a!1 depending on a!1) and so the computation went into an infinite loop
23:25:53 <Funktorsalat> will storing a hPutStrLn in a data structure memoize the string? hehe
23:25:54 <iskren_> kmc, yes but you only use things from the array which are computed
23:26:00 <iskren_> and the order is complicated in my case
23:26:09 <kmc> iskren_, if you use something that isn't computed yet, it will be computed and stored
23:26:21 <Funktorsalat> I guess it should...
23:26:30 <kmc> Array is a lazy data structure
23:26:42 <kmc> you can build the whole array without evaluating any of its elements
23:27:00 <kmc> then you force evaluation of one element, and if it's defined in terms of the array, it will force evaluation of others
23:27:08 <iskren_> kmc, ok, so somehow the compiler will look at the list comprehension, get the element I want, and compute it, and then it will continue?
23:27:21 <Funktorsalat> example: data Printed a = Printed a (IO ()) ; mkPrinted x = Printed x (print x)
23:27:22 <kmc> it's not the compiler's job
23:27:28 <Funktorsalat> say the 'show' is expensive
23:27:39 <kmc> and i don't know what list comprehensions have to do with it
23:27:44 <Funktorsalat> don't ask me why I don't just put the string itself in there
23:27:48 <kmc> i'm just saying you can build an array of unevaluated expressions
23:27:53 <kmc> in fact all Arrays start that way
23:28:01 <kmc> and it can refer to itself
23:28:10 <iskren_> kmc, yes, but still, when I specify the array I do it with a list of pairs right?
23:28:16 <kmc> you can, yes
23:28:39 <iskren_> and if in this list the first pair needs the last one, it will only compute the last one right?
23:28:52 <iskren_> and not any intermediate ones?
23:28:55 <kmc> *if* you ask for the first pair, it will compute the first pair and the last one
23:28:58 <kmc> yes
23:29:02 <iskren_> lol
23:29:09 <iskren_> kmc, that is awesome :)))
23:29:14 <kmc> now there's still some work done up front to allocate an array and store these unevaluated expressions in it
23:29:18 <kmc> but the expressions aren't evaluated
23:29:25 <kmc> iskren_, data-memocombinators is really the simpler way to do memoization
23:29:29 <kmc> check it out
23:29:32 <kmc> http://hackage.haskell.org/package/data-memocombinators
23:29:57 <kmc> > let a = array (0,1) ['x' : (a!1), 'y' : (a!0)] in a!0
23:29:58 <lambdabot>   Couldn't match expected type `(t, e)'
23:29:58 <lambdabot>         against inferred type `[GHC.T...
23:30:04 <kmc> > let a = listArray (0,1) ['x' : (a!1), 'y' : (a!0)] in a!0
23:30:05 <lambdabot>   "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy...
23:30:20 <kmc> ^^^^ a is an array of two infinite strings, each defined in terms of the other
23:31:11 <iskren_> kmc, nice :))) and now I realize you have a bot to compute the expressions :)))
23:31:16 <kmc> :t let loeb x = fmap ($ loeb x) x in loeb
23:31:17 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
23:32:06 <Veinor> what's that compute?
23:32:08 <copumpkin> @pl let loeb x = fmap ($ loeb x) x in loeb
23:32:08 <lambdabot> fix (fmap . flip id =<<)
23:32:17 <copumpkin> :t fix (fmap . sequence)
23:32:18 <lambdabot>     Couldn't match expected type `f a -> f b'
23:32:18 <lambdabot>            against inferred type `[a -> a1]'
23:32:18 <lambdabot>     In the second argument of `(.)', namely `sequence'
23:32:26 <copumpkin> :t fix (fmap . sequence)
23:32:27 <lambdabot>     Couldn't match expected type `f a -> f b'
23:32:27 <lambdabot>            against inferred type `[a -> a1]'
23:32:27 <lambdabot>     In the second argument of `(.)', namely `sequence'
23:32:27 <kmc> > let loeb x = fmap ($ loeb x) x in loeb; a = loeb $ listArray [('x':) . (!1), ('y':) . (!0)] in a!0
23:32:28 <copumpkin> gah
23:32:28 <lambdabot>   <no location info>: parse error on input `;'
23:32:45 <kmc> > let loeb x = fmap ($ loeb x); a = loeb $ listArray [('x':) . (!1), ('y':) . (!0)] in a!0
23:32:46 <lambdabot>   Occurs check: cannot construct the infinite type:
23:32:47 <lambdabot>    a = f (a -> b) -> f bC...
23:32:53 <copumpkin> :t fix (ap sequence)
23:32:53 <lambdabot> forall a. [[a] -> a] -> [a]
23:32:55 <copumpkin> there we go
23:32:55 <kmc> Veinor, http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
23:33:22 <djahandarie> copumpkin, what does that function do?
23:33:32 <copumpkin> djahandarie: it's loeb!
23:33:47 <djahandarie> Ah
23:34:15 <kmc> > fix (ap sequence) [('x':) . (!!1), ('y':) . (!!0)]
23:34:16 <lambdabot>   ["xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyx...
23:35:21 <Veinor> kmc: is that article supposed to contain a lot of squares?
23:35:22 <Funktorsalat> omg I can just test whether it is memoized using trace, can't I?
23:35:27 <kmc> yeah
23:35:33 <kmc> â–¡ is a modal operator
23:35:38 <Veinor> okay
23:35:46 <kmc> "is provable" in this case
23:35:48 <Veinor> just checking
23:36:41 <kmc> lÃ¶b's theorem from provability logic turns out to be the type of a sort of "fix for containers"
23:37:13 <djahandarie> I wonder what a loeb where the functor is a function would look like
23:37:41 <copumpkin> djahandarie: same kind of thing, really
23:37:46 <Funktorsalat> hmm seems to work let prfoo = (putStrLn (trace "..." "foo"), 1)
23:37:47 <copumpkin> think of the function as being a Map, for example
23:37:57 <kmc> (r â†’ ((r â†’ x) â†’ x)) â†’ r â†’ x
23:38:01 <Funktorsalat> 'fst prfoo' will only emit "..." the first time
23:39:20 <Veinor> kmc: that's really cool
23:39:22 <Funktorsalat> hmm I guess that's a bogus experiment
23:41:03 <Funktorsalat> let f n = trace "calculating" (show n)
23:41:04 <Funktorsalat> let foo = (putStrLn (f 3),1)
23:41:04 <Funktorsalat> fst foo -- still memoized :)
23:41:40 <kmc> > let loeb x = fmap ($ loeb x); f 0 g = 'x' : g 1; f 1 g = 'y' : g 0 in loeb f 0
23:41:40 <lambdabot>   Occurs check: cannot construct the infinite type:
23:41:41 <lambdabot>    a = f (a -> b) -> f b
23:41:59 <kmc> :t let loeb x = fmap ($ loeb x) in loeb
23:42:00 <lambdabot>     Occurs check: cannot construct the infinite type:
23:42:00 <lambdabot>       a = f (a -> b) -> f b
23:42:00 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
23:42:11 <kmc> :t let loeb x = fmap (\a -> a (loeb x)) in loeb
23:42:12 <lambdabot>     Occurs check: cannot construct the infinite type:
23:42:12 <lambdabot>       t = f (t -> b) -> f b
23:42:12 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
23:42:19 <kmc> :t let loeb x = fmap ($ loeb x) x in loeb
23:42:20 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
23:42:21 <kmc> aha
23:42:24 <kmc> > let loeb x = fmap ($ loeb x) x; f 0 g = 'x' : g 1; f 1 g = 'y' : g 0 in loeb f 0
23:42:25 <lambdabot>   "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy...
23:43:03 <kmc> so loeb gives you (single-type) mutual recursion by way of an index parameter
23:48:33 <JoshTriplett> BONUS: Hi; you around, by any chance?
23:50:35 <copumpkin> no loeb in agda :(
23:50:52 <djahandarie> Agda can't do something?!?! :O
23:51:03 <Veinor> :O
23:51:18 <JoshTriplett> djahandarie: I thought that was the point: agda can't do a lot of things, but they're things you didn't want to do anyway. ;)
23:51:24 <copumpkin> djahandarie: no fix in agda either :P
23:51:54 <djahandarie> :-(
23:52:15 <djahandarie> Not even Mu?
23:52:30 <copumpkin> you can approximate Mu\
23:52:38 <copumpkin> in a separate universe
