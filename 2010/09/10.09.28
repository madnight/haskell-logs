00:00:24 <ski> augur : yeah .. or we could phrase it as introducing an inequality constraint
00:00:31 <augur> right
00:01:05 <augur> so notice what happens if you do that:   unify [~x,x] [1,2] t   =>   unify [~1] [2] t2  =>   t3
00:01:26 <augur> but t3 will contain x: ~1, instead of x: 2, like it should
00:01:32 <augur> just assuming substitution
00:02:00 <ski> well, it should entail both `x = 2' and `x = ~1'
00:02:21 <ski> (which simplifies to just an `x = 2' equality constraint)
00:02:23 <augur> yes, but x = 2 is the "stronger" claim
00:02:38 <augur> and so the only worthwhile unification of x is with 2
00:03:05 <ski> (so why did you say "but t3 will contain x: ~1, instead of x: 2, like it should" ?)
00:03:11 <augur> because if this is a pattern matching unification, i dont want to be substituting ~1 into the rewritten portions of the rule, unless i have no other choice
00:03:31 <ski> (.. oh, you're saying that it ought to contain the latter, but actually will contain the former ?)
00:03:38 <augur> well, it WILL contain x: ~1 because unify ~x 1 t would yield {x: ~1}
00:04:05 <augur> and if you then use this to substitute into [x] to do the "rest", you get unify [~1] [2]
00:04:08 <augur> which is trivially true
00:04:22 <augur> but you now loose the information that it's also x = 2
00:04:56 <manateeUser> @tell Saizan Have you push "print unused package" patch? :)
00:04:57 <lambdabot> Consider it noted.
00:05:21 <augur> i _suppose_ some sort of environment model could work, where you look up x instead of substituting, and every time you find a new value for x that is _not_ definite, like 2 is, then you disjunct over that
00:05:24 <augur> so that like
00:05:35 <ski> yeah, you can't substitute that way, if you want correct results (which you do)
00:05:49 <augur> well, but thats the standard unification algorithm, right
00:05:58 <augur> it works when you dont have this kind of "boolean" object
00:06:54 <augur> sorry, it should be "conjunct over that"
00:07:02 <augur> unify [~x,x] [1,y] {{}}   =>   unify [x] [y] {{ x: ~1 }}   =>   {{ x: ~1&y }}
00:07:19 <ski> yeah, constraint logic systems don't use substitution like that
00:07:51 <augur> but that now introduces the unification problem into the variable binding.
00:08:36 <ski> yeah, you have to resolve variable accesses through the environment / constraint store
00:08:37 <augur> i suppose thats fine, because you could have some rules that say if you do a variable lookup and you end up _successfully_ unifying with a definite term, you swap out the junk
00:08:56 * ski wonders where augur is going with this ..
00:09:07 <augur> ski: what do you mean "where i'm going with this"? :|
00:09:25 <ski> "what is it for ?" :)
00:09:28 <augur> oh
00:09:34 <ski> are you going to construct some kind of theory ?
00:09:35 <augur> like i said earlier, im writing a meta-logic
00:09:37 <ski> implement a system ?
00:09:47 <augur> a program that lets you define logics
00:09:51 <augur> namely, axioms and inference rules
00:10:37 <augur> a purely syntactic system. the axioms and inference rules allow pattern-matching
00:10:59 <augur> its kind of prolog-esque, actually, except in that it lets things be extremely inlined
00:11:12 <augur> i dont know if prolog allows the kind of extreme inlining i'm looking for
00:11:53 * ski is mostly interested in these kind of `|' and `&' things, from the perspective of giving meaning to patterns, and from the perspective of talking about "ambiguous objects" in logic programming
00:12:05 <augur> ski:
00:12:16 <ski> (well, and somewhat related to coordination in nat.lang. as well)
00:12:45 <augur> axiom 'pairContainingOne' [1,_]|[_,1]
00:12:49 <augur> as opposed to
00:12:56 <augur> axiom 'pairContainingOne' [1,_]
00:13:03 <augur> axiom 'pairContainingOne' [_,1]
00:13:34 <augur> axiom 'listWithOneAndTwo' [...,1,...]&[...,2,...]
00:13:35 <augur> instead of
00:15:00 <augur> actually, i should that that, cause you dont need 's
00:15:02 <augur> instead of
00:15:44 <augur> rule "splitIt"   listWithOneAndTwo xs   =   listWithOne xs, listWithTwo xs
00:16:01 <augur> which is i guess roughly like the prolog system
00:16:41 <augur> pairContainingOne([X,Y]) :- X = 1.   pairContainingOne([X,Y]) :- Y = 1.
00:16:42 <augur> and
00:17:50 <augur> listWithOneAndTwo(X) :- listWithOne(X), listWithTwo(X).
00:18:41 <ski> it seems to me that we want to introduce a directed equality, to reason about `|' and `&'
00:18:53 <augur> actually, i wrote it all backwards, too. :)
00:19:00 <augur> in my system, premises are on the left, not the right
00:19:01 <augur> but whatever
00:20:07 <augur> ski: what would constitute directed equality
00:20:26 <augur> would it be as simple as my suggestion for &ing the variable bindings?
00:20:58 <ski> your idea seemed to be about how to implement the system
00:21:04 <augur> yes
00:21:07 <ski> i was thinking of how to reason in it
00:21:15 <augur> ?
00:21:33 * ski tries to conjure a reasonable example
00:22:13 <maurer_> Is there a heap sturcture in haskell which supports increase-key?
00:23:17 <maurer_> I'm implementing an algorithm that _really_ needs one
00:25:00 <ski> well, consider (a stupid example) :
00:25:04 <kmc> none i know of maurer_
00:25:16 <ski>   foo :: (Maybe a,Maybe a) -> Maybe (Either a (a,a))
00:25:26 <augur> ski: i dont even know what that means :D
00:25:26 <kmc> does it have to be pure/persistent or could you implement any old heap out of CLRS using ST?
00:25:53 * kmc doesn't think any of Okasaki's persistent heaps support increase-key, but is not done with the book yet
00:25:53 <maurer_> I was hoping someone had already done just that ST (or even IO) would be fine here.
00:26:26 <kmc> not that i know, you should definitely upload it if you write it :)
00:26:32 <ski> augur : well, it is supposed to be a type signature belonging to a group of defining equations
00:27:08 <ski> but now i realize the example i conjured isn't only useless, but bad as an example
00:27:16 <ski> ok, say instead (also stupid)
00:27:20 <augur> ski: oh, i see. well, so i take it you intend the defining equations to be a set like {x = 1, x = ~2, ...}?
00:27:22 <maurer_> The basic algorithm is that I am to find the maximum element in weights, remove it, increment all its neighbors according to a graph, then repeat until there are no more nodes.
00:27:30 <maurer_> Right now it is minimum n^2 time, which is too slow.
00:27:36 <ski>   pairContainingOne ((1,_) | (_,1)) = True
00:27:36 <maurer_> (max costs n)
00:27:43 <ski>   pairContainingOne _ = False
00:28:16 <ski> i'm really only interested in the first equation, here
00:28:27 <augur> which equation is the first
00:28:35 <ski>   pairContainingOne ((1,_) | (_,1)) = True  -- this one
00:28:39 <augur> oh ok
00:28:39 <ski> we want that `pairContainingOne (2,1)' should simplify to `True'
00:28:53 <ski> but how do we reason logically, to arrive at that ?
00:29:07 <augur> well, thats the job of the unifier
00:29:14 <ski>      pairContainingOne (2,1)
00:29:18 <augur> the unifier tries to unify ((1,_) | (_,1)) with (2,1)
00:29:25 <ski>   =  pairContainingOne ((2,1) | (1,_))
00:29:30 <ski>   =  True
00:29:40 <augur> if it succeeds, then it rewrites the sentence as True, substituting the bindings
00:29:48 <ski> i claim would be a valid derivation of showing `pairContainingOne (2,1) = True'
00:29:55 <ski> well, say
00:29:57 <ski>      pairContainingOne (2,1)
00:29:59 <ski>   =  pairContainingOne ((2,1) | (1,_))
00:30:01 <ski>   =  pairContainingOne ((_,1) | (1,_))
00:30:05 <ski>   =  True
00:30:10 <ski> (to be pedantic)
00:30:22 <augur> ok?
00:30:38 <ski> so, we want an equality `x = (x | y)' for any terms `x' and `y'
00:30:53 <augur> youve lost me, im afraid
00:31:17 <ski> i'm rewriting the original term, step by step, to arrive at the result
00:31:33 <augur> i get that you're rewriting it
00:31:41 <augur> thats not how my inference system works, but ok
00:31:45 <ski> the last step in the derivation uses the definition equation of `pairContainingOne'
00:31:59 <ski> s/definition/defining/
00:32:31 <augur> i dont have explicit unification in this thing
00:32:37 <augur> pattern matching is transparent
00:32:51 <augur> its a part of the meta system, not the object logic
00:32:59 <ski> the previous steps are steps we have to introduce, to match our redex to the definiendum in the definition
00:33:52 <augur> ok, but thats not how my inference system works. it works by unifying the premises of the rule with the formula occurrence
00:33:57 <ski> yeah, but you have things like
00:33:59 <ski> <augur> rule "splitIt"   listWithOneAndTwo xs   =   listWithOne xs, listWithTwo xs
00:34:00 <augur> the unification might do this (it doesnt, right now)
00:34:22 * ski is not talking about how the system will actually work
00:34:22 <augur> sure, you ahve that. thats in the object logic tho
00:34:35 <augur> well i _am_ talking about how the system will actually work! :P
00:34:46 <augur> i just need to think about unification
00:34:47 <augur> thats all
00:35:17 <ski> i'm only talking about a *possible* way for humans (and maybe computer systems) to reason about axioms and rules in your system, to faithfully represent what results your system give
00:35:48 <augur> yes well
00:36:02 <augur> like i said, the system uses unification, and all im concerned about is understanding unification of this sort
00:36:22 <ski> anyway, my point with *directed* equality would be that : if `x = (x | y)' is not directed, then we can derive `x = (x | y) = y', which seems undesirable
00:36:44 <ski> so, `x = (x | y)' is valid, but `(x | y) = x' is not valid (but `(x & y) = x' would be valid, i think)
00:36:56 <augur> i dont even know what you're talking about now
00:37:37 <PatrickRobotham> directed equality?
00:37:53 <PatrickRobotham> do you mean assignment?
00:38:03 <ski> it seems to me that you have to introduce a direction to an equality `e0 = e1' in your system, to make reasoning sensible
00:38:22 <ski> PatrickRobotham : no. it is traditionally known as "reduction"
00:38:36 <Nereid> how about we just say x <= (x | y)
00:38:53 <Nereid> because it's really an ordering, not equality
00:39:02 <ski> indeed
00:39:10 <PatrickRobotham> Oh I see, so you're working with lambda calculus?
00:39:17 <Nereid> not at all
00:39:40 <PatrickRobotham> Logical implication?
00:39:55 <Nereid> set inclusion
00:40:19 <PatrickRobotham> same thing more or less :P
00:40:32 <Nereid> more or less
00:40:59 <ski> augur : i'm sorry if we're talking a bit at cross-purposes here .. i'm focusing more on a sane framework for reasoning about the system, rather than the details of how the system are to be implemented, because i think that can avoid making mistakes in the implementation that way
00:41:27 <Nereid> so I guess we could say x => x | y
00:41:35 <Nereid> => read as "implies" of course
00:43:03 * ski would possibly write `]='
00:43:29 <Nereid> that looks like a sadface
00:45:48 <augur> add a greater-than and you've got a scheme prompt
00:47:19 <ski> augur : anyway, it sounds like you want something like a constraint logic system
00:47:50 <augur> ski: well, probably. but its a relatively simple one, i think. i just need to make sure my understanding of the equations is correct
00:48:10 <augur> i think the cases of disjunction and conjunction are simple enough
00:48:30 <ski> yeah .. you've only mentioned equality and disequality constraints, so far
00:48:46 <ski> (maybe you want set membership constraints and some other things as well)
00:49:15 <augur> x|y = z given ts -> ts >>= \t -> { x = z given t, y = z given t }
00:49:34 * ski ponders how to reason about `factor (Left (a,b) | Right (a,c)) = (a,Left b | Right x)' ..
00:49:54 <augur> x&y = z given ts   ->   x = z given (y = z given ts)
00:50:02 <ski> what is `ts' ?
00:50:06 <augur> thetas
00:50:13 <augur> variable assignments
00:50:40 <slaye> BONUS: Hi. Any idea when the book will start shipping?
00:52:35 <ski> why the bind, in the `|' case ?
00:53:28 <augur> ski: because you have to consider the alternatives. the unification of the disjunction is the union of the unifications of each alternative
00:53:34 <augur> so consider this:
00:53:55 <ski> `ts :: Set Subst' ?
00:53:55 <augur> [1,x]|[y,2] = [1,2]
00:54:07 <augur> should this yield one unification { x: 2, y: 1 }?
00:54:20 <augur> or two { x: 2 }, { y: 1 }?
00:54:31 <ski> two solutions (having overlap)
00:54:44 <augur> probably two, because there might be cases where both unify, but in inconsistent ways
00:55:07 <ski> you might want to unify `[x,y]' with e.g. `[2,3]' later
00:55:18 <augur> probably not actually possible to have inconsistent ways, but
00:55:25 <augur> suppose it fails on one of the disjuncts
00:55:36 <augur> but only fails for an uninteresting reason
00:55:37 <augur> like
00:55:50 <augur> [1,x]|[y,2] = [1,3]
00:55:58 <augur> obviously y should never = 1
00:56:16 <augur> but this might happen depending on how the disjunction works. i dont know
00:56:45 <augur> this might interact with multiple disjunctions, even
00:57:11 <augur> [1,x]|[y,2] = [1|3,2]
00:57:32 <augur> or maybe [1,x]|[y,2] = [1,3]|[2,2]
00:57:37 <augur> there.
00:57:47 <augur> you dont want to get { x: 3, y: 2 }
00:58:05 <augur> or at least you _probably_ dont want that
00:58:06 <augur> do you?
00:58:20 <augur> [1,x]|[2,x] = [1,2],[2,3]
00:58:35 <ski> (seen from the viewpoint of coordination interpreted as `P (1 | 2)', we have the problem that `Q (P (1 | 2))' might mean either `Q (P 1) \/ Q (P 2)' or `Q (P 1 \/ P 2)' .. another indication of side-effects, and that we have to be careful in what meaning we ascribe to such expressions, to not lapse into inconsistencies)
00:58:39 <augur> theres a really good case. you simply _cant_ avoid forking the unification
00:58:57 <augur> tht should be [1,2]|[2,3] obviously
00:59:07 <augur> you want to get { x: 2 }, { x: 3 }
00:59:09 <augur> nothing else
00:59:45 <ski> well, `x = 3 \/ y = 2', rather .. but yes, i think so
01:00:02 <ski> er, sorry, no .. you flipped the example
01:00:08 <ski> so, yes
01:00:23 <augur> so it should be   [1,x]|[2,x] = [1,2]|[2,3]   =>   [1,x] = [1,2]|[2,3] U [2,x] = [1,2]|[2,3]   =>   [1,x] = [1,2] U [1,x] = [2,3] U [2,x] = [1,2] U [2,x] = [2,3]
01:00:40 <augur> which is indeed { x: 2 }, { x: 3 }
01:08:40 <ski> augur : *nod*
01:10:06 <augur> as for conjunction, [1,x]&[y,~y] = [1,2] should yield something like { x: 2, ~y, y: 1 }
01:10:17 <augur> er, { x: [2,~y], ... }
01:11:55 * ski is confused by this `{ x: ..., ... }' notation
01:12:22 <augur> in the sentence before { x: [2,~y], ... } i had written { x: 2, ~y, y: 1 }
01:12:32 <augur> what i mean to write was { x: [2,~y], y: 1 }
01:12:43 <ski> i would just say `x = 2 /\ x \= y /\ y = 1' (which simplifies to `x = 2 /\ y = 1')
01:12:52 <augur> or { ..., y: [1] } to be consistent
01:12:59 <ski> but surely `x' there should be a number, not a list of numbers ?
01:13:38 <augur> right, so if we allowed multiple equations per variable, and actual != equations, we might say { x = 2, x != y, y = 1 }
01:13:50 <augur> if we didnt allow != equations, we'd have  { x = 2, x = ~y, y = 1 }
01:14:07 <augur> which really should just substitute down anyway: { x = 2, x = ~1, y = 1 }
01:14:18 <ski> (btw, this is one reason why i object to thinking of `|' and `&' as set union and intersection .. sure, in a semantics, they might be interpreted in terms of those, but "is" is too strong a word, imo)
01:14:46 <augur> but if you're using hashes for quick variable look up, { x: [2,~1], y: [1] }
01:15:18 <augur> my intention with the set stuff was to merely give you an idea of what the intention was, not the implementation
01:15:24 <ski> (it's the same kind of difference between `x * y' and `\x -> x * y'. the former is not a function, but a varying value, while the latter is a function)
01:15:25 <augur> just to try and convey the idea of a boolean object
01:15:52 <ski> well, i'm not sure what you mean by "boolean object"
01:16:01 <ski> presumably you don't mean a value of type `Bool'
01:16:21 <augur> well, ~[1,2] is an "object" which is in some sense a boolean operation on [1,2]
01:16:25 <augur> "negation", in a sense
01:16:36 <augur> while the & and | are sort of conjunction and disjunction
01:17:54 <Nereid> boolean object
01:17:58 <Nereid> element of a boolean lattice
01:17:58 <Nereid> ?
01:18:02 <augur> sure
01:18:11 <augur> im sure thats the case with this
01:18:21 <ski> (maybe an ultra-filter ..)
01:18:22 <Nereid> well yeah, there are only a couple axioms to verify
01:18:27 <augur> where the relationship in question is something unification-y
01:18:38 <augur> what is an ultra-filter
01:18:41 <augur> ive heard this multiple times now
01:18:45 <Nereid> http://en.wikipedia.org/wiki/Ultrafilter
01:18:48 <augur> doesnt help
01:18:53 <augur> im not a math nerd :P
01:19:03 <Nereid> if that doesn't help, then what could?
01:19:55 <augur> something other than that!
01:20:14 <augur> aha i think i get it
01:20:17 <Nereid> #
01:20:17 <Nereid> # Given a homomorphism of a Boolean algebra onto {true, false}, the inverse image of "true" is an ultrafilter, and the inverse image of "false" is a maximal ideal.
01:20:38 <Nereid> that seems to be a nice enough characterization.
01:20:39 <augur> that doesnt help
01:20:54 <Nereid> ok, let's say propositional logic.
01:20:55 <augur> im not a math nerd. i barely know what a boolean algebra is. nevermind maximal ideal
01:21:07 <Nereid> you have your boolean algebra of statements in propositional logic.
01:21:19 <Nereid> booelan algebra just means you have /\, \/, and ~
01:21:23 <Nereid> that satisfy certain obvious properties
01:21:42 <Nereid> anyway, take the boolean algebra of statements in propositional logic.
01:22:03 <Nereid> then for any truth value assignments to those variables
01:22:21 <Nereid> the set of statements that are true under those assignments is an ultrafilter
01:22:31 <augur> i think i understand what filters are
01:22:34 <augur> from the wiki
01:22:39 <augur> it seems to have improved since i last looked, so
01:23:35 <Nereid> and every ultrafilter on that boolean algebra arises in such a way.
01:23:43 <augur> anyway
01:23:46 <Nereid> anyway
01:24:45 <kmc> ∨ ∧ ¬
01:26:10 <augur> kmc: yes?
01:27:04 <augur> also, who's awesomely good at abstract algebra and/or category theory
01:28:38 <kmc> http://en.wikipedia.org/wiki/Category:Group_theorists
01:29:49 <augur> that doesnt help me :P
01:30:22 <ddarius> augur: Next time ask for something that does help you then.
01:30:32 <augur> i did!
01:30:45 <augur> obviously "who" is contextually restricted
01:30:53 <augur> "who here" not "who in the whole wide world"
01:31:48 <ddarius> Actually, Galois, for example, is arguably not in the "whole wide world" anymore. (and probably not a very good categorist)
01:32:12 <augur> *in the whole wide timeless universe
01:32:24 <augur> it's like you're autistic, GOSH
01:32:25 <augur> >|
01:32:27 <kmc> who in the platonic realm is good at category theory
01:32:36 <ddarius> augur: At any rate, the standard maxim "don't ask to ask" applies.
01:32:51 <augur> well i didnt ask to ask!
01:32:53 <augur> i asked!
01:33:14 <kmc> did you have an abstract algebra question?
01:33:30 <augur> no, i just want to know who to annoy when i /do/ have one. :D
01:33:33 <augur> i suppose i could ask one tho
01:34:00 <ddarius> augur: When you do have one, just ask it.
01:34:44 <augur> suppose i have some system with two operations roughly like f, g :: Multiset Tree -> Multiset Tree
01:35:54 <Nereid> augur: the intersection of #haskell and #math is fairly decent
01:36:36 <augur> where f ts = for some t,t2 in ts satisfying some properties, ts - {t,t'} + {Branch t t'}
01:36:44 <augur> and g is the linear reverse
01:37:37 <augur> is there any way to talk about the structure of f U g both as multiset functions and as functions that do stuff to the contents of the multisets?
01:38:04 <ddarius> Nereid: But #math sucks.
01:38:25 <augur> like, i know abstractly we can treat the multisets as atoms and produce whatever sort of object we produce, but i'd like to be able to talk about the interactions between the multisets and the structures they contain
01:41:27 <augur> is that possible at all?
01:49:56 * hackagebot wai-extra 0.2.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.3 (MichaelSnoyman)
01:50:57 * hackagebot wai-handler-devel 0.0.2 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.0.2 (MichaelSnoyman)
02:38:31 <mornfall> Is there a reasonable way to have Eq instance for existentials?
02:39:06 <mornfall> (I guess I could use Typeable, but any *other* options?)
02:45:28 <kmc> depends what's in the existential
02:46:04 <kmc> maybe it's like «data Foo = ∀t. Foo Int t» and you want to compare on only the Int
02:46:16 <kmc> or even «data Foo = ∀t. Foo t (t → Int)»
02:47:11 <kmc> e.g. comparing instances of Real through toRational
03:06:28 <Maxdamantus> Would specifically tail-recursion optimisation be something a Haskell implementor would be concerned about, or would that be covered as a side-effect by something else?
03:07:24 <Maxdamantus> I can see how infinite lists etc have nothing to do with it (I think), but to actually try and process an infinite list, that optimisation has to occur somewhere (I think)
03:07:36 <mornfall> Maxdamantus: I think it falls out of other things for Haskell, actually.
03:07:46 <mornfall> But haven't thought too hard about it.
03:07:46 <Maxdamantus> ie: a 
03:07:52 <Maxdamantus> ie: a = 1 : a
03:08:26 <mornfall> Anyway, anyone know if I can get existential Ord instance out of Typeable and Ord?
03:09:46 <zygoloid> Maxdamantus: tail recursion optimization is much less applicable for nonstrict functions
03:10:21 <mornfall> zygoloid: Well, it sort of falls out of garbage collection in Haskell, doesn't it?
03:10:38 <zygoloid> if the arguments to the function aren't strict, then you're likely to build up a very large thunk as an argument to the function, which just moves the stack overflow somewhere else
03:11:57 <zygoloid> mornfall: not really; ghc still has a separate stack, which would overflow if it kept activation records for every invocation of a tail-recursive function
03:12:34 <zygoloid> (you still need something that says "if the continuation is trivial, don't do that" but it might be an implicit part of something else)
03:13:30 <mornfall> zygoloid: Oh. Well, I wasn't particularly assuming GHC, but more of a fully heap-based implementation I guess.
03:14:01 <ddarius> Maxdamantus: Haskell needs tail recursion and you do not get it for free, though, obviously, certain implementation mechanisms will inherently provide it.
03:14:18 <zygoloid> yeah, a heap-based graph-rewriting system would implicitly perform the tail recursion optimization.
03:14:36 <zygoloid> (at least to the extent that it's meaningful for such a system)
03:14:46 <mornfall> I need an Ord instance for TypeRep. :(
03:15:11 <kmc> :t compare `on` show
03:15:13 <lambdabot> forall a. (Show a) => a -> a -> Ordering
03:16:01 <zygoloid> mornfall: compare `on` (unsafePerformIO . typeRepKey)
03:16:15 <zygoloid> if you promise not to look at the ordering, i think that's completely safe
03:16:35 <mornfall> zygoloid: That's evil.
03:16:36 <zygoloid> (it's nondeterministic between runs, not explode-in-your-face i think)
03:16:48 <mornfall> zygoloid: Especially since Key is just an Int. :(
03:18:07 <zygoloid> typeRepKey (TypeRep (Key i) _ _) = return i
03:18:25 <mornfall> Yeah, and unsafePerformIO is *really* expensive.
03:18:47 <mornfall> Maybe we need a fusion rule for unsafePerformIO/return. :D
03:19:46 <zygoloid> well, if you're worried about the performance you could duplicate the implementation of TypeRep and unsafeCoerce ;)
03:19:51 <kmc> why is uPIO expensive?
03:20:03 * zygoloid is looking for the source code right now
03:20:16 <mornfall> zygoloid: Now *that* is *icky*.
03:20:37 <kmc> unsafePerformIO (IO f) = case f realWorld# of (# v, _ #) -> v
03:20:38 <kmc> or such
03:20:44 <mornfall> I should do it just to outdo my other icky code.
03:21:04 <mornfall> kmc: I don't know, but it is.
03:21:16 <kmc> says who / what profiler?
03:21:39 <mornfall> kmc: Says I from benchmarking (no profiler, just timing).
03:21:43 <kmc> ok
03:21:49 <mornfall> kmc: unsafePerformIO is couple more times expensive than a syscall
03:22:20 <mornfall> kmc: The particular case I ran into was going getSymbolicLinkStatus to the individual stat fields.
03:22:31 <mornfall> kmc: (Which is implemented with unsafePerformIO in the stdlib.)
03:22:54 <zygoloid> mornfall: you can use unsafeDupablePerformIO to avoid the (minor) overhead
03:22:54 <mornfall> kmc: I saw significant speedup from reimplementing this without uPIO.
03:23:07 <zygoloid> that's in GHC.IO
03:23:46 <ddarius> mornfall: You get a significant speed-up just from implementing things locally as the compiler can inline/optimize more agressively.
03:24:18 <zygoloid> kmc: unsafePerformIO is expensive because the RTS goes to effort to make sure that you're not evaluating anything which another thread is evaluating
03:24:39 <zygoloid> unsafeDupablePerformIO removes that check and gives you almost that case expression
03:25:17 <zygoloid> (it's also got a laziness annotation to prevent the IO happening too early)
03:26:28 <Maxdamantus> Would it make sense for an implementation to have an internal "reduce" function or something, where code will be represented by internal functions that reduce to either values or functions?
03:26:46 <Maxdamantus> And the evaluator just keeps reducing until it gets a value
03:26:51 <Maxdamantus> Hm.
03:27:16 <zygoloid> sounds like seq or evaluate
03:27:31 <mornfall> Ok, unsafeDupablePerformIO with typeRepKey thing works, thanks for input.
03:27:44 <mornfall> I am not *too* concerned about speed right now.
03:28:11 <zygoloid> i would take a look at the core if you're worried. i'd not be surprised if the unsafeDupablePerformIO gets inlined and evaporates
03:28:36 <zygoloid> if not, it should only build a single thunk then evaluate it
03:31:04 <Maxdamantus> !src seq
03:31:12 <Maxdamantus> @src seq
03:31:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:31:24 <zygoloid> ;( neither typeRepKey nor unsafeDupablePerformIO gets inlined
03:49:37 <mreh> has anyone investigated good haskell practice yet?
03:50:28 <mreh> formatting code is what I'm talking about
03:51:14 <pozic> mreh: if you can read it again in 6 months, it was good practice ;)
03:51:33 <pozic> mreh: coding guide lines are for idiots, imho. 
03:51:54 <pozic> mreh: or rather, people that don't fully understand the language they are programming in. 
03:52:25 <mreh> unless you fully understand the reasons why
03:53:00 <pumpkin> my guidelines are "make it purty"
03:53:05 <pumpkin> very easy to state
03:53:24 <earthy> oh, and make HLint not barf too much
03:53:28 <mreh> my imports are ugly and hard to read
03:53:35 <pumpkin> I haven't used hlint much
03:54:06 <earthy> of course, there is http://www.haskell.org/haskellwiki/Programming%5Fguidelines
03:54:23 <earthy> the final line of which is very applicable. 'people ignore standards anyway'
03:55:02 <earthy> there is also http://hackage.haskell.org/trac/ghc/wiki/WorkingConventions with something to say on coding style
03:57:35 <pozic> pumpkin: purty \not\in\EnglishLanguage
03:57:48 <pumpkin> sucks for EnglishLanguage
04:01:45 <Olathe> Why don't types allow for values in them but only labels?
04:02:30 <Olathe> Is there some kind of problems that would occur with mixing those?
04:02:49 <mreh> i've seen people say keep lines anywhere from 80-78 chars long
04:05:26 <pumpkin> Olathe: how so?
04:05:43 <pumpkin> you could encode anything you wanted in labels
04:06:06 <Olathe> pumpkin: Oh, sure, but then you have to essentially rewrite Integers or something when you want to use them.
04:07:09 <Olathe> pumpkin: Not only that, but you get the benefits of nice representations (like 1234 vs S (S (........) that are consistent from values to types.
04:07:50 <pumpkin> sure, but how do you propose doing it, and why would it be better than dependent types?
04:07:57 <pumpkin> or even different?
04:08:13 <Olathe> I'm not sure exactly.
04:09:20 <Olathe> Something like a type called Vector {Integer}, where you can have append :: Vector a -> Vector b -> Vector {a + b}.
04:09:31 <Olathe> Use the same notation (+) and everything.
04:09:38 <zygoloid> it would be nice if GHC provided a wider set of type-level primitives
04:09:53 <zygoloid> but there's a big design space
04:10:05 <pozic> Yes, let's make the compiler even bigger!
04:10:05 <Olathe> (Actually, that's a set of types, but...)
04:10:22 <zygoloid> pozic: you know byorgey is working on something like this?
04:10:23 <Olathe> pozic: Sorry?
04:10:36 <pozic> zygoloid: I don't, but it sounds like a bad idea.
04:10:57 <zygoloid> Olathe: you can already do that using Conor McBride's "she" haskell preprocessor?
04:11:06 <Olathe> zygoloid: Ahh, thanks :)
04:11:06 <zygoloid> s/?/./
04:11:21 <pozic> The dependent type systems we have currently, (at least the ones aimed at humans), simply need better tools.
04:11:35 <zygoloid> Olathe: http://personal.cis.strath.ac.uk/~conor/pub/she/faking.html
04:11:35 <pozic> And they need proper semantics.
04:11:53 <Olathe> Ahh, that's a good, concise term: types indexed by data.
04:11:59 <pozic> There are some core-languages, but the real languages have little to do with those. 
04:15:04 <pumpkin> SHE can only do so much
04:15:23 <pumpkin> it simplifies some of the details in haskell, but it's not adding anything you couldn't do by hand
04:16:00 <zygoloid> sure, but doing it by hand is icky :)
04:16:23 <pumpkin> the issue with SHE is that if you get any errors, they're illegible
04:16:29 <pumpkin> as they refer to the generated names
04:16:49 <zygoloid> to be fair, if you get any errors in that sort of type-level code, they're usually illegible anyway ;)
04:17:20 <pumpkin> I wouldn't mind just taking the idiom bracket part of it and putting it into a language of its own
04:17:28 <pumpkin> as in a GHC language extension
04:23:09 <zygoloid> pumpkin: yeah, i think that's what byorgey's been working on. (except that the brackets are apparently implied -- i'm not sure i believe that's workable though)
04:24:13 <pumpkin> oh really? I thought he was just working on the lifting value-level to type-level stuff
04:28:02 <quicksilver> zygoloid: I spent some time pondering possible syntaxes for implied idiom brackets and pretty much convinced myself you couldn't do it elegantly
04:28:13 <Olathe> I have an idea for simplifying that a bit more. Vector :: Integer -> Label as a regular, value-level function with no definition required, since it produces Label.
04:28:37 <quicksilver> you end up with terms which have a very context-sensitive meanings and you completely lose anything like a substitution property
04:28:41 <quicksilver> high price to pay.
04:28:54 <Olathe> What's a substitution property?
04:30:11 <quicksilver> Olathe: that you can always replace variables by their definitions
04:30:48 <Olathe> Ahh, thanks.
04:44:22 * cizra ponders
04:44:30 <cizra> I have to take the course "Introduction to Software Testing"
04:44:56 <cizra> I could probably convince my teacher to accept a bunch of automated tests for whatever, instead of doing their stupid homework.
04:45:05 <cizra> Now I'm sitting here and wondering what I could test (=
04:45:07 <cizra> Ideas?
04:45:18 <pumpkin> show them agda
04:45:18 <cizra> Writing unit tests to some Haskell project?
04:45:29 <cizra> mm.. how is agda connected to testing?
04:47:06 <pumpkin> agda lets you write tests that are checked at compile time, but also lets you prove arbitrary statements about your programs
04:47:21 <mreh> apparently someone forked the Flux code and made it compatible with the new OpenGL code
04:47:57 <mreh> the guy who wrote Flux cant remember
04:48:30 <cizra> pumpkin: Yes, but only for code written in agda?
04:48:36 <pumpkin> sure
04:49:10 <cizra> Just a wild-ass guess... the corpus of agda programs is tiny, I suppose?
04:49:49 <pumpkin> depends, it has a fairly extensive standard library
04:49:58 <pumpkin> with lots waiting to be filled in and you can prove anything you want about stuff :P
04:50:38 <cizra> pumpkin: The goal of this course is more to learn to write test scenarios, test cases n' such. So I doubt the teacher would be qualified to check my proofs (=
04:50:44 <pumpkin> boo
04:50:50 <pumpkin> well luckily the typechecker is qualified to do so :P
04:50:50 <cizra> Yeah, boo.
04:51:00 <cizra> I took the course because I had to, not because I wanted.
04:51:31 <Cale> hehe
04:51:57 <Cale> cizra: So, more reasonable thing to do is to use QuickCheck, probably :)
04:52:07 <cizra> Cale: Yeah, that was what I was thinking about
04:52:45 <cizra> Take some random project, write it a good test coverage and present the work in lieu of the waste-paper required by default.
04:54:43 <cizra> So, uh, any ideas on what would be in need of testing AND easily testable? Some kind of network library/service perhaps? Pure algorithmic stuff perhaps?
04:55:16 <Cale> Algorithmic stuff tends to have the nicest tests.
04:56:00 <ddarius> > showHex 8410 ""
04:56:01 <lambdabot>   "20da"
04:56:28 <Cale> While it's now possible to test IO code with QuickCheck, it's not really what the library is best at.
04:57:38 <Cale> Thankfully, most programs break down pretty cleanly into a pure model of what's going on and IO actions to carry it out.
04:59:01 <Cale> I don't know which projects are in need of testing at present.
05:02:57 <Silex> I'm an haskell beginner so excuse my lack of insight: is haskell mature enough for production use e.g for background daemons and stuffs? my question is more about the areas where it's currently lacking libraries/development
05:03:13 <chrisdone> nominolo: where's the new haskell site link?
05:03:22 <Cale> Silex: yes
05:03:53 <Silex> Cale: okay, what areas are "weak" in the current haskell then? guis?
05:04:20 <chrisdone> good interfaces to database libraries
05:04:30 <Entroacceptor> all languages are weak with guis....
05:04:55 <Silex> Entroacceptor: some are weaker than others... my question is more about if there exists libs at all or none
05:04:56 <chrisdone> Entroacceptor: then it's just a case of how weak
05:04:56 <Cale> Silex: Well, we have bindings to a few GUI libraries, probably GTK being the most comprehensive one.
05:05:24 <Silex> Cale: I see, interesting. Are there Qt ones?
05:05:31 <zygoloid> pumpkin: sorry, i misread what you wrote. yeah, i don't think he's been working on idiom brackets, just datakinds.
05:05:47 <Cale> Silex: There is a binding for Qt, yes, but I haven't tried it.
05:05:56 <Silex> Cool. Thanks for the infos
05:06:12 <Cale> http://qthaskell.berlios.de/
05:06:27 <Cale> Silex: Bindings to C++ libraries are always more tricky
05:06:32 <Entroacceptor> last time I checked I found the XDG stuff lacking
05:06:43 <cizra> Silex: The problem with Qt is that C++ plus the Qt MOCking is difficult to map to other languages.
05:07:38 <Cale> Silex: The main problem with these bindings is that the end result is something which is only marginally easier to use than the original library, and not really what Haskell programmers would expect.
05:07:54 <Silex> Cale: yeah that makes sense
05:08:06 <Silex> cizra: Qt is a weird beast indeed
05:08:29 <Silex> I know Ruby makes it somewhat easy to write C extensions for it... is it the same with haskell?
05:09:49 <Cale> Silex: Well, the FFI is really good.
05:10:07 <Cale> foreign import ccall "math.h sin" sin :: CDouble -> CDouble
05:10:29 <Cale> foreign import ccall "string.h strlen" cstrlen :: Ptr CChar -> IO CSize 
05:11:01 <Cale> Often making the interface nice to use from Haskell involves a bit more work. Nobody likes manipulating Ptr values directly.
05:11:07 <Cale> But it's pretty easy nonetheless.
05:11:34 <ari> :t withCString
05:11:35 <lambdabot> Not in scope: `withCString'
05:11:41 <ari> ):
05:12:03 <ari> :t Foreign.C.String.withCString
05:12:04 <lambdabot> forall a. String -> (Foreign.C.String.CString -> IO a) -> IO a
05:12:08 <Silex> Cool. I'm a c++/ruby dev myself but I'm looking for smth more stable than ruby to avoid writing c++ :) I like haskell functional style
05:12:29 <Rutix> -.-
05:12:59 <Rutix> oops wrong channel sorry :D
05:25:09 * hackagebot authenticate 0.6.4 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.4 (MichaelSnoyman)
05:25:11 * hackagebot http-enumerator 0.1.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.1.1 (MichaelSnoyman)
05:48:12 <chrisdone> cizra you old dog
05:48:43 <ManateeLazyCat> I use dupTChan build broadcast channel, have a way disconnect current channel with other channel, to stop listen signal from other channel?
05:59:57 <Funktorsalat> why are the things iterating iteratees called.... "enumerators" and not "iterators"? (in the original development, I don't mean the name of the new rival package)
06:00:13 <Funktorsalat> it would seem kinda more natural :)
06:04:05 <tab> Funktorsalat: i think that's the approch took in the rival package
06:07:59 <co_dh> can I define (f1, f2) >>> (g1, g2 ) = ( f1 >>> g1 , f2 >>> g2 ) ? 
06:08:13 <co_dh> point wised composition .
06:08:33 <co_dh> that means I need to define (,) as a category , right?
06:08:49 <ivanm> are you wanting to use the pre-defined >>> ?
06:08:51 <ivanm> @hoogle (>>>)
06:08:52 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:08:52 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:09:02 <ivanm> yeah, (,) needs to be a category
06:09:10 <ivanm> @instances-importing Control.Arrow Category
06:09:11 <lambdabot> Couldn't find class `Category'. Try @instances-importing
06:09:16 <dolio> (,) is not a category, though.
06:09:17 <ivanm> @instances-importing Control.Category Category
06:09:18 <lambdabot> (->), Kleisli m
06:09:18 <pumpkin> you can't make it a useful category
06:09:44 <co_dh> the (,) ? I need it , it's usefull :)
06:09:52 <dolio> Or, not a Category category.
06:10:02 <ivanm> @src Category
06:10:03 <lambdabot> Source not found. Just try something else.
06:10:06 <ivanm> didn't think so...
06:10:18 <zygoloid> @type arr -- how would you implement this for (,) ?
06:10:19 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
06:10:24 <dolio> In Category, the parameter is the type constructor for the morphisms.
06:10:24 <pumpkin> zygoloid: that's for Arrow
06:10:34 <pumpkin> the question is how would you implement id :: (a, a)
06:10:36 <zygoloid> @type id
06:10:37 <lambdabot> forall a. a -> a
06:10:47 <zygoloid> @slap lambdabot ;)
06:10:48 * lambdabot places her fist firmly on lambdabot ;)'s jaw
06:11:09 <co_dh> I'm implement the uncurried version of coproduct funcor
06:11:09 <zygoloid> pumpkin: yeah, that's the one i was thinking of. can never remember which way it was split
06:11:19 <pumpkin> ARR MATEY
06:11:26 <co_dh> (+) :: ((a ->b) , (c->d)) -> ( (Either a c ) -> (Either b d)) 
06:11:40 <co_dh> (f1, f2) >>: (g1, g2)  = ( f1 >>> g1 , f2 >>> g2 )
06:11:52 <co_dh> (+)    = ( >>: inj ) >>> v
06:11:55 <dolio> And the objects are always in *.
06:12:00 <co_dh> inj = (Left, Right)
06:12:09 <co_dh> if I can define >>> for , 
06:12:10 <dolio> But the product category of * has objects in (*, *).
06:12:11 <Funktorsalat> dolio: I think you can cheat around that
06:12:15 <Funktorsalat> with a gadt
06:12:18 <co_dh> then (+) = (>>> inj ) >>> v 
06:12:18 <pumpkin> :t (>>>)
06:12:19 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
06:12:27 <Funktorsalat> though you probably won't be able to define id then
06:12:27 <pumpkin> co_dh: look at the signature for that
06:12:29 <co_dh> v = uncurry (|||)
06:12:39 <Funktorsalat> but I mean in principle you can encode (*,*) as * with a gadt
06:12:47 <Funktorsalat> or even * -> *
06:13:04 <co_dh> I don't know gadt 
06:13:06 <dolio> Funktorsalat: I have yet to see someone actually do it, rather than just suggest that it's possible, I think.
06:13:11 <Funktorsalat> data Foo a where Foo :: a -> b -> (a,b)
06:13:37 <pumpkin> Foo (a, b) ?
06:14:27 <Funktorsalat> or binarily: data FooCat c d where FooCat :: (c1 -> d1) -> (c2 -> d2) -> FooCat (c1,c2) (d1,d2)
06:14:37 <Funktorsalat> but as I said, no id since you can't restrict :(
06:15:39 <ManateeLazyCat> ivanm: Hi. :)
06:15:44 <ivanm> hey ManateeLazyCat 
06:16:04 <ski> Funktorsalat : something like `data ProductMor ar0 ar1 :: * -> * -> * where MkProductMor :: forall a0 a1 b0 b1. ar0 a0 b0 -> ar1 a1 b1 -> ProductMor ar0 ar1 (a0,b0) (a1,b1)' ?
06:16:44 <ManateeLazyCat> ivanm: Today, i draw a picture : http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/ , it's clear, any suggestion?
06:16:49 <co_dh> I guess Haskell is not good for category, since nobody can give a product category easily :)  
06:17:07 <ski> co_dh : we lack product kinds :(
06:17:10 <Funktorsalat> co_dh: well, the 'Category' class is not good for it
06:17:22 <Funktorsalat> it's easy with a "rcategory" analogous to rmonad
06:17:24 <Funktorsalat> (isn't it?)
06:17:33 <pozic> ManateeLazyCat: pretty pictures, but have you already written an overview?
06:17:40 <dark> do people here use leksah?
06:17:51 <dark> do leksah have smart identation, ala emacs?
06:18:05 <co_dh> I guess it's  because type class is not first class . 
06:18:13 <Funktorsalat> it needs vim keys imho :) (unless the latest revision has them already)
06:18:17 <ManateeLazyCat> pozic: This is first picture. :)
06:18:30 <Funktorsalat> ski: I don't quite get it
06:18:30 <ManateeLazyCat> pozic: Application screenshot at http://www.flickr.com/photos/48809572@N02/
06:18:36 <ski>   instance (Category cat0,Category cat1) => Category (ProductMor cat0 cat1) where aid = MkProductMor aid aid; &c.
06:18:42 <dark> I would like to have a smart identation with some incremental parser, instead of ad-hoc rules :<
06:18:45 <Funktorsalat> ski: ah, you just abstracted over the "base" categories which I took to be Hask
06:18:50 <ski> yeah
06:19:00 <ManateeLazyCat> pozic: I'm fix bugs, i think picture will help other people understand my project easier. :)
06:19:03 <pozic> ManateeLazyCat: does dbus run on Windows?
06:19:08 <nominolo> chrisdone: new-www.haskell.org
06:19:16 <ManateeLazyCat> pozic: It's not design for Windows. :)
06:19:32 <ManateeLazyCat> pozic: It's better if Windows support DBus. :)
06:19:46 <ManateeLazyCat> pozic: And it's okay if Windows don't support DBus, i don't care.
06:20:19 <pozic> ManateeLazyCat: I also don't, but some other people do.
06:21:26 <ManateeLazyCat> pozic: My point is, if you want use my program, join Linux community. :)
06:22:02 <ivanm> nominolo: nice!
06:22:18 <pozic> ManateeLazyCat: just Linux or *nix?
06:22:21 <ManateeLazyCat> pozic: Any suggestion make my picture better?
06:22:32 <ManateeLazyCat> pozic: Yes, but it's better if can support Windows. :)
06:22:52 <nominolo> ivanm: I hope we can finally switch over to the new wiki after ICFP.
06:22:56 <ivanm> cool
06:23:02 <pozic> ManateeLazyCat: I don't think it actually explains a lot ;)
06:23:07 <dark> is a message like "package parsec-3.1.0 is broken due to missing package" means some serious breakage, or I just need to reinstall something?
06:23:22 <pozic> ManateeLazyCat: a picture is worth a thousand words doesn't actually go up.
06:23:53 <ManateeLazyCat> pozic: Yeah, it's just explain how to implement multi-process framework with GtkSocket/GtkPlug. :)
06:23:59 <co_dh> is there a paper or something that explain category theory in a point less style?
06:24:26 <ManateeLazyCat> pozic: I'm afraid it's not clear if i add too much detail. :)
06:24:41 <dark> co_dh, what do you mean by category theory in a point less style?
06:24:48 * ski thinks category theory is usually pointlessly explained
06:25:37 <dark> you make it seems there is little point on it
06:25:42 <co_dh> for coproduct functor ,  ( f + g ) = Left . f ||| Right . g
06:26:04 <co_dh> this is point wise , we can abstract away the f , g , 
06:26:13 <dark> co_dh, is this actually category theory notation or haskell notation?
06:26:27 <co_dh> (+) = ( >>: ( Left, Right )) >>> ( uncurry (||| )
06:26:36 <ski> .. oh, you mean pointless on the level of morphisms ?
06:27:03 <co_dh> dark: it's haskell notation
06:27:05 <ski> i suppose when doing internal category theory, one possibly does that
06:27:18 <co_dh> ski: yes , another level of pointless. I found it's so attactive to me . 
06:27:21 <chrisdone> hehe, just fixed a long standing tryhaskell bug. `ab' is a useful tool
06:28:11 <ivanm> what's ab ?
06:28:19 <chrisdone> apache benchmark
06:28:21 <co_dh>  so maybe I should call this point-point-less , lol
06:28:42 <Olathe> Are there any values in Haskell other than numbers (including Char) and things constructed with constructors?
06:29:04 <Funktorsalat> a category is two objects C0,C1 with two morphisms d,c: C1 -> C0, a morphism id:C0 -> C1 and a morphism (.) : pullback(d,c) -> C1 such that ... :)
06:29:07 <ivanm> Olathe: depends how you mean
06:29:14 <ski> co_dh : btw, a morphism `f : A <-< B' in a category `C' can be cast as a functor `F : C <-< Mor' such that `F . Cod : C <-< 1' and `F . Dom : C <-< 1' represents the objects `A' and `B'
06:29:16 <ivanm> Olathe: arrays, bytestrings, etc. are pinned in memory directly...
06:29:17 <Funktorsalat> (in a category with pullbacks)
06:29:29 <Olathe> ivanm: Ahh, OK. Thanks :)
06:29:31 <pumpkin> Olathe: functions
06:29:48 <ski> Olathe : functions ?
06:30:08 * ManateeLazyCat pasted "fix dead broadcast channel." at http://paste2.org/get/1007951
06:30:09 <ManateeLazyCat> Haha, i fix *dead broadcast channel*, just kill thread when exception throw in readTChan. :)
06:30:11 <Olathe> Hmm, that makes sense.
06:31:31 <ski> (co_dh : where `Mor' is the category with two objects, identity morphisms on them, and a single morphism between them, the objects being pointed at by `Cod : Mor <-< 1' and `Dom : Mor <-< 1')
06:32:01 <co_dh> ski: I didn't follow you , what can I use it for ? 
06:33:20 <ski> co_dh : well, this allows you to abstract away the points (morphisms), instead talking about functors. so a "global point" (a morphism) then is just a functor to the category `C' in question, from the `Mor' category
06:34:11 <ski> (cf. how a "global point" inside an object `A' in a category `C' is just a morphism to `A' from an object `1' (often the terminal object))
06:34:30 <ManateeLazyCat> @hoogle Exception -> String
06:34:31 <lambdabot> Control.OldException assertions :: Exception -> Maybe String
06:34:31 <lambdabot> Control.OldException errorCalls :: Exception -> Maybe String
06:34:31 <lambdabot> Control.OldException userErrors :: Exception -> Maybe String
06:35:36 <co_dh> ski: any paper on that ? link?
06:35:53 * ski is not sure
06:36:14 <ski> possibly "Categories for the Working Mathematician" mentions this viewpoint
06:36:31 <co_dh> ski: that book is too hard for me .
06:36:59 * ski only grasps a small part of it, as well :)
06:37:28 <co_dh> the point-less^2 view of category theory reveals a lot more 
06:37:38 <co_dh> take either as an example. 
06:37:56 <co_dh> ( either f g ) . Left = f 
06:38:04 <co_dh> (either f g ) . Right = g 
06:38:21 <co_dh>  let v = uncurry either 
06:38:51 <ski> (. Left) . uncurry either = fst
06:38:57 <ski> (. Right) . uncurry either = snd
06:39:09 <co_dh> v ( f , g ) .. (Left, Right ) = (f, g) 
06:39:22 <co_dh> .. is point wise compose 
06:39:41 <co_dh> so    v .. (Left , Right ) = id 
06:39:48 <co_dh> ( I might wrong ) 
06:39:54 <mreh> hmmm, an applicative instance for an associative list... how would this effect traversable
06:39:58 <co_dh> so v is the left reverse of (Left, Right )
06:40:24 <ski> @type (Left,Right)
06:40:25 <lambdabot> forall a b b1 a1. (a -> Either a b, b1 -> Either a1 b1)
06:40:55 <co_dh> :t  ( uncurry (|||) )
06:40:56 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => (a b d, a c d) -> a (Either b c) d
06:41:45 <ski> @type uncurry either (Left,Right)
06:41:46 <lambdabot> forall a b. Either a b -> Either a b
06:42:28 <ski> co_dh : .. i'm not following your equations mentioning `v'
06:42:42 <co_dh> ski: wait a second, I'll try in haskell. 
06:42:46 <mreh> how does one send to haskell-cafe? despite being a subscriber, i just got rejected
06:42:48 <co_dh> v = uncurry ( |||) 
06:43:10 <ski> `either' is fine to begin with, no need for `(|||)', i think
06:44:22 <ski> @let uEither = uncurry either
06:44:23 <lambdabot>  Defined.
06:44:35 <ski> @type uEither
06:44:36 <lambdabot> forall a c b. (a -> c, b -> c) -> Either a b -> c
06:45:11 * ski wonders whether co_dh wants to use `(&&&)' somewhere ..
06:46:00 <co_dh> :t (&&&)
06:46:01 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:46:06 <ski> @type (. Left) &&& (. Right)
06:46:07 <lambdabot> forall b a b1. (Either a b1 -> b) -> (a -> b, b1 -> b)
06:46:58 <ski> (note that that is a use of a product category, rather than a use of products *in* a category)
06:47:35 <ski> @type (arr Left >>>) &&& (arr Right >>>)
06:47:36 <lambdabot> forall a b (cat :: * -> * -> *) c. (Arrow cat) => cat (Either a b) c -> (cat a c, cat b c)
06:48:17 <ski> @type uncurry (|||)
06:48:18 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => (a b d, a c d) -> a (Either b c) d
06:48:56 <mreh> [] <*> [1,2,3]
06:49:00 <mreh> > [] <*> [1,2,3]
06:49:01 <lambdabot>   []
06:49:08 <mreh> > [1,2,3] <*> []
06:49:09 <lambdabot>   []
06:49:28 <ski> @type [1,2,3] <*> []
06:49:29 <lambdabot> forall b. (Num b) => [b]
06:50:16 <ski> oh, right, `instance Num n => Num (rho -> n)'
06:51:35 <ski> > getZipList (ZipList [0,1,2] <*> ZipList [3,4])
06:51:36 <lambdabot>   [0,1]
06:54:42 <ski> @type uncurry (<*>) . (fmap fst &&& fmap snd)
06:54:43 <lambdabot> forall (f :: * -> *) b b1. (Applicative f) => f (b1 -> b, b1) -> f b
06:57:48 <co_dh> ski: I made a mistake on v and (Left, Right)
06:58:20 <ski> corrected version being ?
06:58:21 <co_dh> but at least for coproduct functor, I can easily define (+) = ( >>: inj ) >>  v
06:58:37 <ski> co_dh> :t (>>:)
06:59:54 <co_dh> where is code paste?
07:00:17 <co_dh>  (f, g) >>: (f1, g1) = (f >>>f1 , g >>> g1 )
07:00:22 <co_dh> @where paste
07:00:22 <lambdabot> http://hpaste.org/ http://codepad.org/
07:01:04 <ski> @type let (f0,g0) >>: (f1,g1) = (f0 >>> f1,g0 >>> g1) in (>>:)
07:01:05 <lambdabot> forall (cat :: * -> * -> *) a b (cat1 :: * -> * -> *) a1 b1 c c1. (Control.Category.Category cat1, Control.Category.Category cat) => (cat a b, cat1 a1 b1) -> (cat b c, cat1 b1 c1) -> (cat a c, cat1
07:01:05 <lambdabot> a1 c1)
07:01:29 <co_dh> http://hpaste.org/40182/point_less_coproductor
07:01:32 <ski> oh, composition in the product category
07:01:52 <co_dh> >>: is the point wise ( element wise ) >>>
07:01:54 <ski> (i suppose i could just have read the code .. but it seemed easier to look at the type ;)
07:02:09 <co_dh> I prefer the code then the type sometimes :)
07:04:56 <ski> @type let mix = (fst *** fst) &&& (snd *** snd); (>>:) = curry ((uncurry (>>>) *** uncurry (>>>)) . mix) in (>>:)
07:04:57 <lambdabot> forall (cat :: * -> * -> *) a b (cat1 :: * -> * -> *) a1 b1 c c1. (Control.Category.Category cat1, Control.Category.Category cat) => (cat a b, cat1 a1 b1) -> (cat b c, cat1 b1 c1) -> (cat a c, cat1
07:04:57 <lambdabot> a1 c1)
07:05:23 <ski> @type let mix = (fst *** fst) &&& (snd *** snd); (>>:) = curry ((uncurry (>>>) *** uncurry (>>>)) . mix) in (>>: Left) >>> uncurry either
07:05:24 <lambdabot>     Couldn't match expected type `(cat b c, cat1 b1 c1)'
07:05:24 <lambdabot>            against inferred type `a -> Either a b2'
07:05:25 <lambdabot>     In the second argument of `(>>:)', namely `Left'
07:06:00 <ski> co_dh : i'm not sure about your `(+) = ( >>: inj ) >>  v' definition
07:06:25 <ski> what is `>>' there ?
07:06:33 <co_dh> I didn't test with real code, but the type is correct. 
07:06:45 <co_dh> it should be >>> 
07:06:52 <co_dh> check the hpaste 40182
07:07:06 <co_dh> (+) = (>>: inj ) >>> v 
07:08:17 <ski> oh, i thought `inj' was `Left'
07:08:28 <ski> co_dh : i'm not sure about your `(+) = ( >>: (Left,Right)) >>  v' definition
07:08:34 <ski> er ..
07:08:46 <ski> @type let mix = (fst *** fst) &&& (snd *** snd); (>>:) = curry ((uncurry (>>>) *** uncurry (>>>)) . mix) in (>>: (Left,Right)) >>> uncurry either
07:08:47 <lambdabot> forall b b1 a b2. (a -> b, b2 -> b1) -> Either a b2 -> Either b b1
07:08:52 <ski> (was what i meant to say)
07:09:13 <ski> (and that looks much better)
07:11:40 <co_dh> ski: not better for me :)
07:12:26 <co_dh> @src either
07:12:26 <lambdabot> either f _ (Left x)     =  f x
07:12:27 <lambdabot> either _ g (Right y)    =  g y
07:13:07 <ski> it's basically what you had
07:18:02 <co_dh> do we have a function  f (x,y) = (f x , f y) ? 
07:18:09 <co_dh> what's it's name?
07:18:16 <dolio> (&&&)
07:18:21 <dolio> Wait, no.
07:18:26 <dolio> f *** f
07:18:48 <co_dh> > (inc *** inc ) (1,2)
07:18:49 <lambdabot>   Not in scope: `inc'Not in scope: `inc'
07:18:59 <co_dh> > (succ *** succ ) (1,2)
07:18:59 <lambdabot>   (2,3)
07:19:20 <co_dh> wait : I need pair f (x,y) = (f x, f y)
07:19:25 <co_dh> :src pair
07:19:31 <geheimdienst> > ((+3) *** (+7)) (1,2)
07:19:33 <lambdabot>   (4,9)
07:19:40 <dolio> > join (***) succ (1, 2)
07:19:41 <lambdabot>   (2,3)
07:19:54 <co_dh> :t pair
07:19:55 <lambdabot> Not in scope: `pair'
07:20:06 <geheimdienst> woah. today seems to be the day when i finally understand what *** is good for
07:20:21 <dolio> (***) is bimap on pairs.
07:20:31 <dolio> (+++) is bimap for Either.
07:20:45 <wli> geheimdienst: (f *** g) (x, y) = (f x, g y) no?
07:20:47 <co_dh> :t (+++)
07:20:48 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
07:20:56 <geheimdienst> > ((+1) +++ (+3)) $ Left 4
07:20:56 <co_dh> :t (|||)
07:20:58 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:20:58 <lambdabot>   Left 5
07:21:24 <geheimdienst> wli, yeah exactly
07:21:41 <geheimdienst> either (+1) (+3) $ Left 4
07:21:49 <geheimdienst> > either (+1) (+3) $ Left 4
07:21:50 <lambdabot>   5
07:22:00 <co_dh> (+++) is the coproduct functor , 
07:22:01 <copumpkin> is there a usual way for universal algebra to deal with something like a field?
07:22:07 <co_dh> (***) is the productor functor.
07:22:30 <co_dh> :t (***)
07:22:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:22:47 <geheimdienst> so i guess (+++) is the same as "either", only that it leaves the result in the Either, while "either" unwraps it
07:23:20 <co_dh> :t either
07:23:21 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:23:31 <geheimdienst> > either (+1) (+3) $ Left 4
07:23:32 <lambdabot>   5
07:23:44 <wli> Well, I think you have the freedom to have different typed results in the cases of (+++)
07:23:45 <geheimdienst> > ((+1) +++ (+3)) $ Left 4
07:23:46 <lambdabot>   Left 5
07:24:01 <wli> Yeah, you do.
07:24:06 <co_dh> either is more limit than +++, because it ask it's parameters has the same domain.
07:24:15 <Entroacceptor> > ((+1) +++ (+3)) $ Right 4
07:24:16 <lambdabot>   Right 7
07:24:29 <co_dh> same range, sorry
07:25:53 <quicksilver> > map ((*2) +++ length) [Left 1.0, Right "hello", Left 2.3, Right "World"]
07:25:54 <lambdabot>   [Left 2.0,Right 5,Left 4.6,Right 5]
07:26:42 <Entroacceptor> cool, I can do stuff with arrows now ;)
07:27:35 <ddarius> copumpkin: The way it does, is by not doing it.  Fields aren't algebraic (or even almost algebraic) structures in the notion of universal algebra.
07:32:31 <copumpkin> ddarius: so it just avoid the issue completely
07:32:50 <copumpkin> no true algebra!
07:32:59 <copumpkin> s/avoid/avoids/
07:35:06 <ski> geheimdienst : `either' is a specialization of `(|||)', not `(+++)'
07:36:36 <geheimdienst> > ((+1) ||| (+4)) (Left 2)
07:36:38 <lambdabot>   3
07:36:41 <ddarius> copumpkin: The categorical approach to universal algebra generalizes and then can be generalized into cocone theories (which are special cases of sketches).  Fields are cocone theories.
07:40:39 <copumpkin> ddarius: I'll have to look into that too. Just for a change, CT has the answer and I just don't know enough of it yet :) it's disappointing that universal algebra avoids it though
07:42:00 <ddarius> copumpkin: Read TTT.
07:44:45 <nomemory> the order in pattern matching has any importance - from performance point of view ? should i define the least possible patterns lastly ?
07:45:59 <aristid> :t (|||)
07:46:00 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:46:18 <geheimdienst> @instances ArrowChoice
07:46:19 <lambdabot> (->), Kleisli m
07:46:29 <aristid> @src (->) ArrowChoice
07:46:30 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:47:10 <geheimdienst> can ||| or +++ be used for anything practical besides Eithers?
07:47:13 <aristid> ah, (|||) = either
07:47:20 <geheimdienst> just outta curiosity
07:47:22 <aristid> :t either
07:47:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:47:27 <geheimdienst> aristid, yeah that's what i gather
07:47:54 <aristid> geheimdienst: you can use it for arrows
07:47:57 <aristid> :t (+++)
07:47:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
07:49:05 <ski> @src (->) (|||)
07:49:05 <lambdabot> Source not found. stty: unknown mode: doofus
07:49:50 <aristid> ski: (|||) = either
07:49:55 * ski knows
07:50:02 <geheimdienst> aristid: yeah ... but Arrow in my head is symlinked to "weird überabstract thing with incomprehensible documentation". it's in the directory abstract-nonsense.
07:50:06 <aristid> why did you ask @src again, then?
07:50:18 <ski> (i just wanted to see whether it defined it explicitly or not)
07:50:23 <aristid> geheimdienst: next to category-extras? :)
07:51:16 <ski> @src (->) (&&&)
07:51:16 <lambdabot> Source not found. Are you on drugs?
07:51:17 <geheimdienst> i don't have that in my brain
07:51:20 <aristid> instance ArrowApply (->) where { app (f,x) = f x }
07:51:34 <aristid> maybe arrows seem so inelegant because everything is uncurried?
07:51:45 <aristid> geheimdienst: you noob! :D
07:51:51 <jkff> Hi guys. I've just discovered how unsafe is unsafePerformIO. Can anyone help me diagnose a bit of code for strictness?
07:52:11 <aristid> jkff: the name itself says that it is unsafe, does it not? :)
07:52:23 <jkff> It does, but I really need it because I'm ffi'ing :)
07:52:38 <jkff> This code http://hackage.haskell.org/packages/archive/strptime/0.1.3/doc/html/src/Data-Time-Parse.html#strptime non-deterministically fails every once in a thousand whiles and returns a nonsensical time
07:53:00 <jkff> I guess this is because I'm too lazy with respect to all those peeks
07:53:21 <jkff> But I tried a few bang patterns here and there and they didn't help
07:53:39 <aristid> allocaBytes (44)
07:53:41 <aristid> oO
07:53:46 <aristid> why 44?
07:54:00 <jkff> That's sizeof struct tm
07:54:04 <jkff> This code has been preprocessed
07:54:14 <jkff> Let me put it in its original state to pastebin...
07:54:15 <aristid> jkff: can you maybe show the unpreprocessed source code?
07:54:20 <aristid> @where hpaste
07:54:20 <lambdabot> http://hpaste.org/
07:54:28 <aristid> not pastebin please, hpaste is better
07:55:16 <geheimdienst> as an aside, what's this meme that pastebin is bad? i keep hearing that
07:55:28 <jkff> http://hpaste.org/40186/strptime_lazy_madness
07:55:42 <Cale> geheimdienst: It's just that there are other sites which are nicer to use.
07:56:10 * geheimdienst shrugs
07:56:24 <Rumpelstiltskin> I wonder if someone can help me with this. I'm trying to build a simple server application but its crashing and I'm not sure why: http://hpaste.org/40187/servercrash
07:56:51 <quicksilver> jkff: why are you returning an unsafePerformIO thunk?
07:57:05 <jkff> quicksilver: What should I return instead?
07:57:19 <quicksilver> why not just *do* the IO and return the result?
07:57:31 <jkff> You mean, make the method return IO ... ?
07:57:34 <quicksilver> no.
07:57:42 <jkff> Then I'm missing something
07:57:43 <quicksilver> the outer unsafePerformIO I understand.
07:57:56 <quicksilver> "return $ \s -> unsafePerformIO" <-- it's the inner one I don't like.
07:58:18 <aristid> it looks like that is historical because he added the memcpy-avoidal later
07:58:18 <jkff> Because it will be done only when applied to a particular string
07:58:36 <aristid> oh
07:58:48 <jkff> The outer unsafePerformIO returns a function that will do unsafePerformIO to do the work
07:59:07 <jkff> So I'm in a doubly unsafe situation
07:59:07 <aristid> to make sure it's curried enough?
07:59:23 <quicksilver> to share the work between calls with the same format string
07:59:27 <jkff> Right
07:59:28 <quicksilver> but different dates
07:59:31 <earthy> Rumpelstiltskin: you're performing the 'listenOn $ PortNumber portnum' action each time you're evaluating sock <- getSock session in loop
07:59:36 <quicksilver> that sounds like a false optimisation to me :)
07:59:43 * geheimdienst dons his smartypants pants and points out that theoretically, strptime could return different things for the same input, so it's not really referentially transparent. this could happen when the locale changes during the program's runtime, by an invocation of setlocale ...
07:59:47 <aristid> jkff: the code in lines 4 to 9 looks scary to me
08:00:03 <earthy> what I'd expect is for startServer to store the Socket rather than then IO Socket in Session
08:00:07 <aristid> geheimdienst: that IS a good point
08:00:11 <mreh> why does traversable required foldable?
08:00:25 <aristid> jkff: it should all be in IO anyways, as geheimdienst points out :)
08:00:27 <jkff> quicksilver: I'll try to get rid of it, but still what is the rule of thumb regarding strictness of those IO computations inside brackets, like "peek" in this case?
08:00:34 <Rumpelstiltskin> earthy: Really? How come that is.
08:00:37 <quicksilver> that's a red herring.
08:00:42 <quicksilver> nothing to do with strictness
08:00:48 <earthy> Rumpelstiltskin: a value of IO a is an *action* returning an a
08:00:50 <quicksilver> they are IO, they will be executed when they're executed.
08:01:05 <earthy> rather than an a itself
08:01:18 <earthy> so, you can take that action, and perform it multiple times (which is what you do)
08:01:24 <Rumpelstiltskin> oh
08:01:25 <Rumpelstiltskin> I see
08:01:27 <quicksilver> jkff: I believe your bug is that you are not retaining a reference to 'fztf'
08:01:29 <aristid> geheimdienst: setlocale is so ugly :/
08:01:33 <dstcruz> geheimdienst: please, don't destroy my ilusions!
08:01:34 <jkff> I mean, I'll apply that stuff to a string, I'll get a thunk and that memory of struct tm will be freed. Then the thunk gets forced, peek gets applied and I'm screwed because the memory has been freed
08:01:45 <earthy> however, due to the side effect of listenOn your code gets killed by the OS
08:01:52 <quicksilver> jkff: try adding touchForeignPtr# fztf as the last command in the inner unsafePerformIO
08:02:15 * jkff tries
08:02:16 <Rumpelstiltskin> earthy: so Session shouldn't really store an IO Socket, but simply a Socket?
08:02:26 * earthy nods
08:02:41 <earthy> and possibly even just a State rather than an IO State
08:02:46 <quicksilver> jkff: with no reference to fztf it can be GCed at any time, so your finalizer might be called and that, presumably, would cause junk.
08:02:48 <Rumpelstiltskin> yes
08:02:54 <Rumpelstiltskin> many thanks
08:03:20 <earthy> good luck!
08:03:32 <quicksilver> jkff: (incidentally I do not think your theory about struct tm thunks is correct)
08:04:01 <Rumpelstiltskin> earthy: This isn't the first time I've done this. I always forget about <- and end up confusing myself with types :D
08:04:17 <jkff> quicksilver: You're a magician, this helped!
08:04:21 <earthy> just keep bumping into it and you'll get used to the 'right' way ;)
08:04:35 <jkff> But why isn't my theory correct?
08:04:45 <quicksilver> jkff: your allocaBytes is an IO action.
08:04:58 <quicksilver> jkff: it is impossible for that action to free the struct tm before it finishes its work
08:05:04 <quicksilver> jkff: that's the "whole point of" allocaBytes
08:05:17 <quicksilver> the fact it's running under unsafePerformIO doesn't change that.
08:05:18 <copumpkin> ddarius: yeah, all these questions I ask keep pointing back at it, so I'll really give it a solid read instead of the cursory glance I've given it so far
08:05:19 <jkff> Oh, I see, my theory is incorrect because the IO monad is strict :)
08:05:25 <quicksilver> jkff: NO.
08:05:27 <quicksilver> not strict.
08:05:34 <quicksilver> this is nothing at all to do with strictness.
08:05:40 <jkff> At least IO is strict inside it
08:05:43 <quicksilver> no.
08:05:44 <jkff> Hm
08:05:46 <quicksilver> this is not strictness!
08:05:54 <copumpkin> quicksilver is strict
08:05:57 <quicksilver> this is quite simply "actions execute in the order they are presented"
08:06:05 <quicksilver> do { allocate; stuff; free }
08:06:13 <quicksilver> ^^ this always does the stuff, before the free
08:06:13 <geheimdienst> boa con·strict·or
08:06:21 <quicksilver> doesn't matter if you run it inside unsafePerformIO
08:06:27 <jkff> Yup, that's what I actually meant but failed to name correctly
08:06:32 <quicksilver> unsafePerformIO doesn't mean "permute the internal order of these actions"
08:06:37 <quicksilver> it still runs stuff in the right order
08:06:38 <bremner> maybe it helps to write the do block using >>
08:06:40 <quicksilver> you just don't know when.
08:06:40 <ddarius> copumpkin: Be prepared to give it several solid reads.
08:06:53 <quicksilver> so, allocaBytes is perfectly
08:06:54 <quicksilver> safe.
08:07:00 <copumpkin> ddarius: I am
08:07:10 <quicksilver> allocaBytes is roughtly {allocate; stuff; free} except that it takes care about exceptions
08:07:19 <quicksilver> (still frees even if an exception happens)
08:07:29 <jkff> I mean that do { allocate; thunk <- stuff; free; return $ f thunk } guarantees that stuff will be done between allocate and free, not afterwards when f thunk is forced
08:07:42 <quicksilver> jkff: yes
08:07:49 <quicksilver> jkff: depending what you mean by "stuff will be done"
08:07:55 <quicksilver> all the IO effects of stuff will be done
08:07:58 <jkff> Yup
08:08:01 <quicksilver> stuff may still return some pure computation
08:08:05 <jkff> Thank you again
08:08:06 <quicksilver> and that would still be thunked as normal
08:08:13 <quicksilver> do you understand what happened with the foreignptr?
08:08:23 <ski> (or `stuff' could itself be an `IO'-action ..)
08:08:40 <jkff> I understand that it got GC'd, but I still don't understand how my whole program didn't fail and only some of the results were incorrect
08:08:48 <quicksilver> GC is nondeterministic
08:08:53 <quicksilver> you allowed fztf to be collected
08:08:58 <quicksilver> but you didn't force it.
08:09:02 <jkff> T.i. in say 10000 computations , say, the 3678 and 9847 were incorrect
08:09:07 <jkff> Not, say, 5678--10000
08:09:09 <quicksilver> even if it did get collected, the finalizer wasn't guaranteed to run immediately
08:09:13 <jkff> Which I'd expect to be logical
08:09:28 <quicksilver> jkff: OK. I can't explain that :)
08:09:34 <quicksilver> maybe your sharing wasn't working the way you hoped.
08:09:47 <jkff> Maybe unsafePerformIO was unsafe after all
08:09:59 <geheimdienst> ceiling cat strikes again
08:10:52 <geheimdienst> so, why did adding the touchForeignPtr in line 25 fix the problem?
08:12:05 * hackagebot strptime 0.1.4 - Efficient parsing of LocalTime using a binding to C's strptime  http://hackage.haskell.org/package/strptime-0.1.4 (EugeneKirpichov)
08:12:09 <quicksilver> the problem is surely fztf getting GC'ed and finalized.
08:12:18 <quicksilver> and that's what touchForeignPtr will help.
08:13:04 <jkff> hackagebot said it all for me
08:15:37 <co_dh> > fmap succ (2,3)
08:15:38 <lambdabot>   (2,4)
08:15:55 <co_dh> @src fmap (,)
08:15:55 <lambdabot> Source not found. You untyped fool!
08:16:01 <co_dh> @src fmap
08:16:01 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:16:06 * hackagebot timeplot 0.1.6 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.1.6 (EugeneKirpichov)
08:16:09 <co_dh> @src (,) fmap
08:16:09 <lambdabot> fmap f (x,y) = (x, f y)
08:16:15 <aristid> jkff: now you only need to put it into IO because of setlocale.
08:17:07 <jkff> aristid: Hm? Explain please
08:17:49 <aristid> jkff: or is strptime unaffected by setlocale? i don't really know strptime
08:18:13 <geheimdienst> its manpage does talk a lot about locale
08:18:18 <aristid> %p     The locale's equivalent of AM or PM.
08:18:29 <aristid> stuff like this definitely depends on setlocale
08:18:55 <jkff> aristid: I don't know, actually
08:19:05 <aristid> jkff: ok, i suggest that you do strptime :: a -> a -> IO a and unsafeStrptime :: a -> a -> a
08:19:24 <aristid> jkff: then you can use unsafeStrptime if you know that the format string does not depend on the locale
08:19:44 <geheimdienst> jkff, the question is, suppose you have this program: x = "Dienstag ..." ; strptime(x) ; setlocale("de_DE") ; strptime(x)
08:19:56 <jkff> aristid: Thanks, I will soon :) (and I think I will steal an strptime from r-project.org where it can parse milliseconds, which I've been envying for a long time)
08:20:00 <aristid> geheimdienst: strptime also take a format parameter
08:20:13 <geheimdienst> yeah, pseudo-code obviously
08:20:29 <geheimdienst> the first might be a parse error, the second call might work. so strptime does not always return the same output for the same input (not really referentially transparent)
08:20:47 <geheimdienst> just my 2 cents
08:22:19 <Cale> jkff: Perhaps a natural question would be why you're importing strptime in the first place. Do you know about Data.Time.Format.parseTime?
08:22:25 <jkff> It's slow
08:22:46 <jkff> At least it was dog slow in comparison with strptime at the time I wrote this library
08:23:16 <jkff> Ohhhh after having touched the foreign ptr now I can see correctly how my clusterz r loaded
08:24:29 <aristid> parseTime is "safe" tho
08:25:01 <aristid> :t parseTime
08:25:02 <lambdabot> Not in scope: `parseTime'
08:25:21 <aristid> @hoogle parseTime
08:25:21 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
08:25:21 <lambdabot> Data.Time.Format class ParseTime t
08:34:58 <mreh> how can I install the documentation for base without reinstalling the package?
08:35:04 <mreh> with cabal
08:36:24 <mreh> it would be nice to go through everything reinstalling the documentation
08:37:24 * hackagebot phybin 0.1 - Utility for binning phylogenetic trees in Newick format.  http://hackage.haskell.org/package/phybin-0.1 (RyanNewton)
08:37:34 <co_dh> does   f . g = ( f . ) g   ? 
08:38:01 <mreh> :t f . g
08:38:02 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f a), Functor f) => f b
08:38:08 <mreh> :t (f .) g
08:38:09 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, SimpleReflect.FromExpr (f a)) => f b
08:38:26 <mreh> the answer is yes anyway
08:38:42 <mreh> (f .) is a section
08:38:59 <co_dh> mreh: thanks :)
08:47:33 <Fisherman> Any vim users?
08:48:34 <arw> some
08:49:15 <Fisherman> the indent file from the following site seems to be gone http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Vim
08:52:03 <Fisherman> oops, hit the wrong button
08:52:15 <arw> you didn't miss any answers
08:52:22 <arw> don't know why that file is missing
08:53:04 <Fisherman> The site seems to be down or sold
08:56:30 <d-snp> anyone feel like giving me a hint towards finding a maximal connected subgraph?
08:56:52 <d-snp> doing it with state is like the simplest thing in the world, but without I'm just totally stuck..
08:57:11 <arw> Fisherman: hm, try to find it in the google cache or archive.org or something?
08:57:40 <d-snp> where maximal connected subgraph = if you have a graph consisting of 2 connected parts, I want one of those
08:58:39 <Fisherman> arw: Good idea, thanks
09:00:59 <ozataman> hey all. does anybody know if I can use an Iteratee to parse a large input file in constant space and output the results as a lazy list which can then be processed using the conventional functional pipeline?
09:01:16 <ozataman> or do I have to refactor my entire functional processing block to work inside the Iteratee?
09:02:13 <zygoloid> ozataman: part of the /point/ of iteratees is that they eschew the "lazy list where forcing the tail can do some IO" philosophy. so no.
09:03:15 <ozataman> For context: I am processing large CSV files - adding columns, doing calculations, making fixes etc - and parsec-based Text.CSV library worked for me until the input files became really large. I am having memory issues now and I was contemplating how to solve the problem in a more sustainable and scalable way
09:03:22 <osaunders> Can you pattern match on part of a record?
09:03:55 <ozataman> zygoloid: thank you. that's what I gathered too from doing some reading on the subject.
09:04:31 <ozataman> osaunders: was your question directed at me?
09:04:39 <osaunders> ozataman: No.
09:05:08 <zygoloid> ozataman: i think you basically have to turn your code somewhat inside-out in order to use iteratees ;(
09:05:22 <ozataman> zygoloid: yeah :( sounds daunting
09:05:32 * hackagebot xilinx-lava 5.0.0.6 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.6 (SatnamSingh)
09:06:18 <ozataman> zygoloid: laziness becomes real hard to deal with when your program gets large. I started by doing a few transformations and things were fine. then I added folds, maps and may other steps
09:06:21 <Fisherman> Ok, I found the indent file, but it seems to work really bad
09:06:58 <zygoloid> it's probably possible to write an iteratee-to-lazy-io adapter using unsafeInterleaveIO. something in the style of the safeio thing might be interesting
09:07:13 <ozataman> zygoloid: now it is becoming increasingly difficult to make sure I don't put a "reverse" or something like that in there that forces the entire collection to be held in memory. That is even if I get rid of parsec-based csv parsing and use unlines . process . lines or something like that
09:08:39 * ddarius is so used to local echo that he mistook actual echo for local echo.
09:08:54 <DrTeggy> osaunders:   let X { b = y }  = X { a = 100, b = "hundred" } in y   will work (and evaluate to "hundred").  
09:10:13 <osaunders> DrTeggy: Ah.
09:10:52 <wavewave> anyone uses attoparsec?
09:11:18 <wavewave> how can I feed endOfInput ?
09:11:27 <dima1> guys hello
09:11:33 <jesse_> hello
09:11:35 <dima1> I have a question
09:12:06 <dima1> is that a way in haskell to reference enclosing closure with a keywork ?
09:12:11 <dima1> *keyword
09:15:04 <dima1> is anybody answering ?
09:16:00 <wavewave> what do you mean by enclosing closure with a keyword
09:16:01 <wavewave> ?
09:16:36 <dima1> A lambda expression which is bound with a let keyword, can reference itself with the name to the let operator
09:16:54 <dima1> but what if I do not use let operator
09:17:11 <dima1> just declare lambda in-place
09:17:25 <dima1> How can I reference from inside
09:17:29 <dima1> itself
09:17:43 <pozic> dima1: you want \x -> <reference to self>?
09:17:44 <wavewave> f = g f  like this?
09:17:53 <dima1> yeah
09:17:57 <dima1> but there is no f =
09:18:00 <pozic> dima1: which one?
09:18:13 <jesse_> i think he wants anonymous recursion
09:18:18 <wavewave> why not just using the let?
09:18:18 <dima1> yes
09:18:23 <DrTeggy> The Why of Y
09:18:24 <dima1> anonymous recursion
09:18:26 <pozic> dima1: Haskell doesn't have that.
09:18:58 <dima1> no anonymous recursion in haskell?
09:19:13 <wavewave> because of strong type system, I guess?
09:19:54 <jesse_> dima1: I asked about anonymous recursion a while ago and was told to look at fixed point combinators and got confused, gave up and resorted to a let clause. But I was told it was possible.
09:20:11 <Twey> It is possible.
09:20:14 <Twey> :t fix
09:20:15 <lambdabot> forall a. (a -> a) -> a
09:21:27 <Twey> dima1: No, there is no such magic keyword.
09:21:57 <Twey> But you can refactor any iterative–recursive function to use ‘fix’, I believe, which obviates the need for a name.
09:32:52 <xplat> you can even refactor any iterative-recursive function to use a fold on 'ones'
09:32:52 <ezyang> Yo guys, haskell.org is out of disk. http://hpaste.org/40189/out_of_disk  
09:33:10 <bos> oops
09:33:31 <bos> better ENOSPC than ENODEV
09:33:40 <Twey> xplat: What is ‘ones’?
09:33:40 <edwardk> ezyang: clearly you need to fly back to galois and install more. duh ;)
09:33:55 <edwardk> ezyang: should have thought of that before you decided to abandon me to go to the other cambridge ;)
09:34:01 <ezyang> Oh noes! 
09:34:06 <xplat> Twey: an infinite list of ones.  or of any other constant value.
09:34:09 <ddarius> "Warning: This machine has ceased to exist."
09:34:11 <Twey> Oh, right.
09:34:26 <Twey> ddarius: Heh.  I like how that's only a warning.  Hooray for error-recovery.
09:34:44 <edwardk> ezyang: are you still in MA or have you already started globetrotting?
09:34:57 <xplat> actually, with any infinite list and the ability to improperly apply recursion to it instead of corecursion you can write fix
09:38:23 <xplat> fix f = foldr (const f) undefined fibs
09:38:54 <xplat> :t foldr (const f) undefined fibs
09:38:55 <lambdabot> Not in scope: `fibs'
09:39:12 <xplat> :t foldr (const f) undefined ones
09:39:13 <lambdabot> Not in scope: `ones'
09:39:22 <xplat> >:(
09:39:43 <xplat> :t foldr (const f) undefined $ repeat ()
09:39:44 <lambdabot> forall b. (Show b, SimpleReflect.FromExpr b) => b
09:40:40 <xplat> > take 100 . show $ foldr (const f) undefined $ repeat ()
09:40:42 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:40:42 <lambdabot>    `SimpleReflect.FromExpr ...
09:40:56 <xplat> > take 100 . show $ foldr (const f) x $ repeat ()
09:40:58 <lambdabot>   "f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f ...
09:41:54 <Fisherman> > do 1+1; putStr "Hello, world"
09:41:55 <lambdabot>   No instance for (GHC.Num.Num (GHC.IOBase.IO a))
09:41:56 <lambdabot>    arising from the literal...
09:42:10 <Fisherman> I suck
09:43:05 <xplat> :t \f -> foldr (const f) undefined $ repeat ()
09:43:05 <lambdabot> forall b. (b -> b) -> b
09:44:07 <xplat> anyway this is why total languages need to strictly separate data from codata
09:45:29 <xplat> even one piece of codata usable as data lets you use general recursion and hellloooo halting problem
09:46:38 <ddarius> > printf "%3x" 12 :: String
09:46:39 <lambdabot>   "  c"
09:46:48 <xplat> i wonder if anyone has come up with total recursion patterns that work specifically with rational trees
09:46:54 <ddarius> > printf "%1x" 2352 :: String
09:46:55 <lambdabot>   "930"
09:47:07 <ddarius> > printf "%x1" 2352 :: String
09:47:08 <lambdabot>   "9301"
09:47:18 <xplat> they sort of represent an intermediate point between data and codata
09:48:27 <roconnor> xplat: what are rational trees?
09:48:58 <Fisherman> trees that make sense (j/k)
09:52:17 <xplat> roconnor: they are basically (labelled) digraphs where every vertex is reachable from a distinguished root.  or they are infinite trees with a finite number of distinct subtrees under the obvious structural equality.  or they are data structures presentable as finite automata.  or they are quotients of trees under the operation of identifying some leaves with other vertices.
09:54:06 <winxordie> xplat: and the claim is that these definitions are all equivalent?
09:55:29 <xplat> winxordie: yes, with the appropriate caveats about making them precise enough and making the notion of 'equivalence' precise enough
09:55:58 <winxordie> cool. reminds me of matroids.
09:56:38 <roconnor> xplat: doesn't sound like codata at all
09:59:47 <manateeUser> Good night, all. :)
09:59:59 <panopticon> hello
10:00:03 <cracksles> why is there no api exposed to exctract a Word32 from a ByteString? It's implemented with foreignPtr so why not?
10:00:28 <roconnor> cracksles: big endian or little endian?
10:01:34 <kaini> How can I use "log" on an Integral type?
10:01:59 <roconnor> kaini: there are some bit shifting techniques that work
10:02:07 <cracksles> roconnor: if bytes occur b1 b2 b3 b4 I would like to have them in a word32 as b1b2b3b4
10:02:17 <cracksles> I do not remember what endian that is
10:02:27 <Botje> big
10:02:35 <Botje> since the biggest byte is in front
10:02:42 <cracksles> this should be doable without messing with Data.Bits
10:02:55 <kaini> roconnor, ?
10:03:32 <roconnor> cracksles: Anyhow, I think Data.Binary shoud have want you want somewhere in there
10:03:45 * hackagebot hmatrix 0.10.0.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.10.0.0 (AlbertoRuiz)
10:03:50 <roconnor> kaini: sorry, I was thinking about counting the number of 1 bits; a differenet problem
10:04:31 <cracksles> why not expose this directly in Data.ByteString?
10:04:35 <xplat> roconnor: another equivalent definition is codata that can be presented as a finite set of equations like { a = 1 : b; b = 2 : a } where each lhs is a simple name and each rhs contains a single (full) constructor application whose arguments are all either data or one of said names
10:05:01 <roconnor> cracksles: because it is a problem of serialization, which is what Data.Binary does
10:05:01 <cracksles> would a patch be turned down?
10:05:17 <roconnor> I hope such a patch would be turned down.
10:05:32 <roconnor> cracksles: you can't just copy the memory using foreign pointer
10:05:48 <roconnor> whether you get a big or little endian result depends on the processor you are using
10:06:06 <roconnor> and that isn't portable
10:06:41 <xplat> all rational trees of type [a], for example, can ultimately be written as x ++ cycle y where x,y :: [a] are finite lists
10:07:14 <roconnor> xplat: you keep using "finite" a lot, and that really belongs in the domain of data
10:07:38 <cracksles> hmm you are right
10:07:48 <roconnor> xplat: I admit this structure can be "viewed" as codata
10:08:00 <roconnor> xplat: in that there is an injection to the codata type of trees
10:08:06 <roconnor> xplat: but that doesn't make it codata
10:09:25 <xplat> roconnor: well, any computable piece of codata can be viewed as data by using a lambda calculator, but that doesn't make it data
10:10:37 <cracksles> roconnor: I don't know why I did not think of that myself. Probably stupidity, but thanks.
10:10:58 <roconnor> xplat: not really.  there is no way to gerenate a lambda expression while preserving equality.
10:11:26 <xplat> in particular, using a code-based representation of codata would not capture the natural (co)recursion patterns associated with codata
10:11:43 <roconnor> cracksles: I only know from experience
10:12:22 <xplat> recursing on the code in ways natural unto data would give you inconsistent and irrelevant answers from the natural codata point of view
10:13:11 <roconnor> anyhow, theses rational tree seem clearly a finite data structure
10:13:50 <xplat> similarly you would have problems naively working with rational trees encoded as data because the answers would depend on things like where the cycles were broken in encoding which should be unobservable
10:14:32 <roconnor> ah
10:14:43 <roconnor> fair point
10:15:09 <roconnor> So I've only seen data and codata applied to regular types
10:15:39 <roconnor> once we start quotienting by equivalence relations (something that is important) I'm not sure the data, codata distinction makes any sense anymore
10:16:41 <roconnor> in other words, data/codata may only apply to representatives, and not to the "constituents"
10:16:49 * hackagebot websockets 0.1.1.3 - Implements the WebSocket protocol.  http://hackage.haskell.org/package/websockets-0.1.1.3 (SinisaBidin)
10:17:18 <xplat> rational trees pretty much apply in the area of regular types too
10:17:27 <dolio> data and codata are two ways of defining sets.
10:17:34 <dolio> Quotienting might be a third.
10:17:45 <xplat> unlike data and codata they even become semi-trivial on nested types
10:18:11 <xplat> although not completely trivial
10:18:39 <roconnor> xplat: how do you make a regular type for rational trees?
10:20:13 <xplat> you can generate a rational-tree type for every data type by using the 'list of equations' representation and then quotienting by the obvious rewritings
10:20:49 <xplat> it's just that sometimes your rational-tree type won't be any larger than your data type
10:20:49 <roconnor> xplat: the quotient operation is not an operation supported by regular types
10:21:51 <roconnor> by regular types, I mean polyonomial operations plus mu and nu.
10:22:11 <xplat> well, the rational-tree types are 'regular' insofar as they have an injection from a data type and an injection to the corresponding codata type and both of those injections are structurally trivial
10:23:29 <sinelaw> PeakerWork, hey
10:26:01 <xplat> they're obviously not regular strictly speaking, but you could extend the operations for generating regular types by a 'rho' operation and most stuff still works nicely, but there are a few recursors that you would presumably like to see besides the ones inherited from mu and nu via the injections, which is what i was wondering if anyone had investigated
10:26:27 * wli returns with 35 minutes to burn before he tries the door at the house again.
10:28:43 <dstcruz> with hxt, is there any way to choose the first child, instead of all children? getChildren gets all children, and deep, get all descendants that match.  I want only the first one that matches.
10:29:48 <roconnor> dstcruz: I'm not very familiar with hxt, but can't you do listToMaybe on all the descendants that match?
10:30:19 <dstcruz> roconnor: let me check
10:30:58 * hackagebot lhae 0.0.3 - Simple spreadsheet program  http://hackage.haskell.org/package/lhae-0.0.3 (AlexanderBau)
10:32:24 <edwardk> preflex: xseen copumpkin
10:32:24 <preflex>  copumpkin was last seen on freenode/#haskell 2 hours, 25 minutes and 24 seconds ago, saying: ddarius: I am
10:32:29 <edwardk> preflex: xseen pumpkin
10:32:30 <preflex>  pumpkin was last seen on freenode/#haskell 4 hours, 2 minutes and 58 seconds ago, saying: Olathe: functions
10:32:37 <copumpkin> hey hey :)
10:32:38 <sinelaw> is haskell an extension of system f?
10:32:40 <edwardk> hard to tell which one is fresher some times. ;)
10:32:44 <edwardk> heya copumpkin 
10:32:50 <ddarius> sinelaw: Yes.
10:32:56 <sinelaw> ddarius, what does it add?
10:33:01 <ddarius> Well, with various extensions it is.
10:33:06 <sinelaw> haskell 98
10:33:09 <sinelaw> that is
10:33:32 <ezyang> Haskell98 has kinds, right? 
10:33:38 <ddarius> ezyang: Of course.
10:33:39 <ezyang> So you need at least F_w 
10:34:30 <ddarius> ezyang: System Fω does quite a bit more with type level lambdas than Haskell does.
10:34:45 <ezyang> Ah, ok. 
10:35:50 <ddarius> Pass in code stream is such a fun parameter passing convention.
10:36:36 <ezyang> ddarius: Is that like CPS? 
10:37:06 <ddarius> No, unless you were going to unsafeCoerce your continuation into data, modify it, and reinstate it.
10:38:32 <xplat> i think Haskell98 is (encodable as) a subsystem of System Fω, but not a superset of System F
10:38:49 <dolio> Well, it's definitely not a superset of F.
10:38:55 <dolio> You'd need to dump higher-rank types.
10:39:54 <sinelaw> dolio, what do you mean
10:39:59 <sinelaw> haskel is less or more than system f?
10:40:11 <sinelaw> (i though it's more)
10:40:22 <dolio> System F allows types like forall r. (forall a. a -> r) -> r
10:40:25 <dolio> Haskell 98 does not.
10:41:05 <dolio> But Haskell also has kinds other than *, which F does not.
10:41:38 <sinelaw> :(
10:42:04 <dolio> A restriction on F_w is probably right, though.
10:42:26 <dolio> If you ignore fix, and datatypes, and....
10:42:55 <xplat> haskell98 is stuck to one face of the lambda cube, a little less than halfway along each of the two relevant edges
10:44:10 <xplat> stuck to one face because types have no value-dependence
10:44:20 <dolio> F_w without higher-rank types is probably a reasonable approximation.
10:44:29 <dolio> And the lambda cube doesn't really even consider that restriction.
10:47:16 <xplat> yeah.  i consider it 'somewhere along the length' because you can sort of say that type-polymorphic values exist but are not first-class
10:49:03 <dolio> It isn't hard to capture Hindley-Milner as a pure type system. But it has more sorts than the lambda cube.
10:49:48 <kmc> values, monotypes, polytypes, kinds?
10:50:38 <dolio> Basically.
10:50:47 <dolio> You split * into *m and *p.
10:51:02 <Funktorsalat> > case (\[x,y] -> (x,y)) [] of { b -> 1 }
10:51:03 <lambdabot>   1
10:51:19 <Funktorsalat> I expected that to fail
10:51:31 <dolio> I have a description here: http://code.haskell.org/~dolio/pts/README
10:51:45 <dolio> Since it's one of the type systems implemented in that interpreter.
10:51:47 <Funktorsalat> > case (\[x,y] -> (x,y)) [] of { (_,_) -> 1 }
10:51:48 <lambdabot>   *Exception: <interactive>:1:139-153: Non-exhaustive patterns in lambda
10:51:54 <Funktorsalat> hmm nevermind..
10:52:12 <dolio> Second-to-last type system.
10:52:27 <kmc> Haskell (unlike some of the typical intermediate languages for Haskell compilation) does not force the scrutinee of a case with only match-everything patterns
10:52:39 <Funktorsalat> what exactly does this mean then? "Unlike a where clause, a lambda expression may check for conformality as soon as it is applied"  (Wadler0
10:52:56 <kmc> it hasn't been applied there
10:53:17 <Funktorsalat> (paper is from before haskell apparently, btw... references miranda :))
10:53:37 <kmc> > case (\[x,y] -> (x,y)) [] of { !b -> 1 }
10:53:37 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
10:53:41 <Funktorsalat> it is clearly applied imho... the application just hasn't been reduced
10:53:44 <kmc> > case (\[x,y] -> (x,y)) [] of { b -> b `seq` 1 }
10:53:45 <lambdabot>   *Exception: <interactive>:1:143-157: Non-exhaustive patterns in lambda
10:54:03 <Funktorsalat> but then again he only writes "may"
10:54:17 <kmc> sometimes "to apply" means "to reduce an application"
10:54:40 <Funktorsalat> ok
10:54:45 <dolio> > case undefined of b -> 1
10:54:46 <lambdabot>   1
10:54:51 <dolio> That's all there is to this example.
10:55:23 <dolio> Making undefined via a pattern match in a lambda isn't any different.
10:55:36 <Funktorsalat> > (\[x,y] -> let b = (x,y) in 1) []
10:55:38 <lambdabot>   *Exception: <interactive>:1:138-165: Non-exhaustive patterns in lambda
10:55:47 <Funktorsalat> that one is the less trivial one I guess
10:56:16 <sinelaw> dolio, what's the encoding of that README?
10:56:25 <yitz> Funktorsalat: the lambda wasn't applied - it didn't need to be, because the default pattern applied
10:56:25 <sinelaw> some of the symbols are garbled
10:56:29 <dolio> UTF8, probably.
10:56:56 <sinelaw> doesn't seem right
10:57:08 * hackagebot yesod 0.5.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.1 (MichaelSnoyman)
10:57:12 <Funktorsalat> > let { [x,y] = [] ; b = (x,y) } in 1
10:57:12 <lambdabot>   1
10:57:23 <Funktorsalat> does that illustrate the difference correctly?
10:57:28 <Funktorsalat> of let/where vs lambda
10:57:40 <sinelaw> maybe my fonts are wrong
10:57:48 <Funktorsalat> wrong cat is wrong
10:58:08 * hackagebot yesod-auth 0.0.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.0.0 (MichaelSnoyman)
10:58:17 <dolio> □ △  <-- can you see these?
10:58:26 <FauxFaux> Yes, thanks.
10:58:28 <dolio> Should be a square and a triangle.
10:58:31 <Funktorsalat> looks like a cat
10:58:34 <Funktorsalat> :)
10:58:45 <sinelaw> dolio, yes
10:59:00 <sinelaw> I assumed the squares in the README are missing symbols - are they supposed to be squares?
10:59:13 <dolio> There are some squares in there.
10:59:18 <sinelaw> and triangles?
10:59:22 <dolio> Yes.
10:59:32 <sinelaw> ok, so it's ok.
10:59:41 <Funktorsalat> sinelaw: haha that confused me to no end in some math textbook too
10:59:47 <Funktorsalat> (the squares as operators)
10:59:59 <dolio> * : □ and □ : △
11:00:01 <Funktorsalat> "fix your encoding damnit" :)
11:00:01 <sinelaw> heh
11:00:17 <dolio> They're levels above kinds.
11:00:20 <yitz> 戏
11:00:26 <sinelaw> i had one instructor who used a smiley 
11:00:56 <Funktorsalat> hmm I remember smilies in DOS... what encoding was that?
11:00:56 <yitz> 戏 <-- my irc client says this is "cat" in Chinese. I wouldn't know.
11:01:02 <Funktorsalat> meow
11:01:12 <FauxFaux> Looks like two people.
11:01:54 <yitz> ⌣
11:02:04 <medfly> I think maybe your IRC client is wrong.
11:02:11 <Funktorsalat> > let (♢) = "cat"
11:02:11 <lambdabot>   not an expression: `let (♢) = "cat"'
11:02:17 <Funktorsalat> @let (♢) = "cat"
11:02:18 <lambdabot>  Defined.
11:02:21 <medfly> 猫 is cat, isn't it?
11:02:29 <copumpkin> meow
11:02:36 <Funktorsalat> @let (猫) = "cat" -- no problem
11:02:36 <lambdabot>   Illegal character ''\29483''
11:02:41 <medfly> 貓
11:02:48 <Funktorsalat> or maybe yes problem :(
11:02:55 <medfly> ^^
11:03:31 <atude> 猫 is cate
11:03:34 <atude> cat *
11:03:49 <aristid> @let 猫 = "cat"
11:03:50 <lambdabot>   Illegal character ''\29483''
11:04:41 <yitz> 貓 <-- "CJK UNIFIED IDEOGRAPH-8C93"
11:05:12 <Funktorsalat> > generalCategory '猫'
11:05:13 <lambdabot>   OtherLetter
11:05:17 <Funktorsalat> :D
11:05:21 <Funktorsalat> > generalCategory 'a'
11:05:22 <lambdabot>   LowercaseLetter
11:05:39 <Funktorsalat> > generalCategory '戏'
11:05:40 <lambdabot>   OtherLetter
11:06:13 <Funktorsalat> > let a戏 = "cat" in a戏
11:06:14 <lambdabot>   "cat"
11:06:23 <Funktorsalat> apparently "Other" is uppercase
11:06:40 <medfly> okay, so cat can be a type :O
11:06:52 <Funktorsalat> yeah :)
11:07:12 <medfly> this is really random, is it intended?
11:07:33 <JakesOnAPlane> hey guys, do apostrophes change the meaning of a type, as in 'a vs just a?
11:08:09 <Funktorsalat> medfly: I guess they had to arbitrarily decide whether "Other" counts as lower or upper
11:09:23 <Funktorsalat> (i.e. the haskell cabal)
11:09:26 <Funktorsalat> :)
11:11:03 <PeakerWork> Thinking of defining: Data.Map.alterM :: (Monad m, Ord k) => (Maybe a -> m (Maybe a)) -> k -> M.Map k a -> m (M.Map k a)  (monadic alter). Seems impossible in terms of "alter". What good ways are there to define this (preferrably not using insert/delete)
11:12:31 <ari> :t generalCategory
11:12:32 <lambdabot> Char -> GeneralCategory
11:16:31 <Funktorsalat> it's annoying that printf-th produces "defined but not used" variables :(
11:16:40 <Funktorsalat> when you're using -Wall
11:23:30 * hackagebot enumerator 0.4.0.2 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.0.2 (JohnMillikin)
11:30:48 <tommd> Yay, _more_ containers changes on their way.  l@h.o is just hopping lately.
11:31:09 <dons> ?
11:31:25 <tommd> dons: "adjustM" and other monadic variants.
11:31:33 <dons> btw, we've had a meeting here at ICFP with Milan, and have a lan.
11:31:35 <dons> plan
11:31:45 <tommd> plan for... containers?
11:31:46 <insomniaSalt> u had?
11:31:53 <insomniaSalt> dont remember that meeting
11:32:14 <insomniaSalt> or, must be different Milan then :)
11:34:26 <tommd> I'm all ears if you're wanting to share the plan.
11:36:12 <Funktorsalat> :)
11:37:40 <Funktorsalat> > "...">>"%02x" -- color formating...
11:37:41 <lambdabot>   "%02x%02x%02x"
11:37:42 <tibbe> tommd: the poor containers api is a mess!
11:38:31 <edwardk> i'm very much pro at least having some applicative adjust, i've needed it before when trying to build trie's over Data.Map and Data.IntMap
11:39:43 <kmc> hey hey it's edwardk
11:40:20 <kmc> is your SAT EDSL done yet? ;)
11:41:01 <edwardk> hah still working on it
11:41:52 <tommd> tibbe: I liked wren's suggestion.
11:42:10 <tommd> Not immediately coming up with any issues.
11:42:44 <tibbe> tommd: I think you can use a zipper to achieve something similar
11:42:55 <tibbe> tommd: a zipper is our equivalent of an iterator
11:43:09 <tibbe> you zip down to a position in the tree, do something, and then zip back up
11:47:41 <augur> hey peeps
11:48:14 <silver_> sup
11:48:20 <augur> grading
11:48:37 * hackagebot phybin 0.1.1 - Utility for binning phylogenetic trees in Newick format.  http://hackage.haskell.org/package/phybin-0.1.1 (RyanNewton)
11:48:38 <augur> you?
11:48:49 <Saizan> Ord k => k -> Lens (Map k a) (Maybe a) ?
11:49:34 <alej> what you grading
11:51:04 <stepkut> in GHC 7.0, what is the difference between binary and ghc-binary, and which should I be using?
11:51:26 <augur> alej: phonetics quizes
11:53:39 * hackagebot phybin 0.1.2 - Utility for binning phylogenetic trees in Newick format.  http://hackage.haskell.org/package/phybin-0.1.2 (RyanNewton)
12:02:12 <tommd> stepkut: Use 'binary'.
12:02:18 <tommd> ghc-binary is for internal ghc use only.
12:02:56 <tommd> Or user 'cereal' if that's a better fit - too many people ignore cereal.
12:03:02 <tommd> @hackage cereal
12:03:02 <lambdabot> http://hackage.haskell.org/package/cereal
12:03:04 <tommd> eat lots of it.
12:05:38 <Adamant> someone needs to name a Hackage package SuperColonBlow.
12:06:44 <maurer_> If I store something in an IOArray, am I gauranteed that it was compressed to HNF?
12:07:05 <maurer_> (or decompressed as the case may be, just that it's no longer an unevaluated thunk)
12:08:20 <Botje> no.
12:08:32 <Botje> if you use an IOUArray you have a guarantee
12:10:07 <maurer_> Botje: Do I need to do anything other than change my typesigs to use IOUArray, or do I actually need to be using #Int# and the like?
12:10:22 <tommd> But GHC has a deoptimization, -fKeepThunksFromUnboxedArrays, on by default just to annoy you.
12:10:41 <Twey> Haha
12:10:49 <Botje> maurer_: no.
12:11:00 <Botje> maurer_: however, you can no longer use laziness on that array
12:12:00 <maurer_> Botje: This is a quarantined part of my program where the laziness is causing really bad things to happen.
12:12:22 <Botje> then you're probably fine.
12:13:10 <maurer_> Yeah, looks like IOUArray needs specific types to work
12:13:19 <maurer_> Which is awkward, given this is an array of Sets
12:13:30 <sinelaw> What does it mean when they use a captial Pi when talking about types?
12:13:44 <sinelaw> e.g:  Pi a: A. B
12:13:46 <Botje> maurer_ huh :(
12:15:42 <Funktorsalat> sinelaw: dependent product
12:16:06 <Funktorsalat> though that one looks like the special case where it isn't actually dependent
12:16:13 <Funktorsalat> it's just A -> B
12:16:24 <sinelaw> Π a : A. B
12:16:26 <sinelaw> yeah.
12:16:34 <sinelaw> Funktorsalat, can you explain that notation?
12:16:49 <sinelaw> I know it's supposed to be the simple case A->B like you said
12:17:18 <augur> sinelaw, you take your martin lof types and GTFO >O
12:17:36 <sinelaw> my what? :)
12:17:44 <sinelaw> augur, i hardly know what i'm talking about anyhow
12:17:46 <augur> also, dependent types aka martin-löf types
12:18:12 <sinelaw> what's a good book to learn type theory
12:18:17 <Funktorsalat> sinelaw: in general the part after the dot may depend on the value 'a'
12:18:18 <augur> pi x : A. B is basically the type "given some x which is an A, i can give you some B"
12:18:20 <sinelaw> from the basics
12:18:36 <augur> the reason for having the x in there, which is indeed the /argument/ of the function not merely a type, is because B can be dependent
12:18:48 <sinelaw> ah ok
12:19:02 <augur> e.g. pi x : Int.squares_of(x)
12:19:16 <augur> which is the type of the function \x -> x*x :: Int -> Int
12:19:20 <augur> but using a dependent type
12:19:27 <augur> its from numbers to their squares
12:19:33 <Funktorsalat> \Pi x : R. { y : R | y > x }
12:19:40 <augur> where what constitutes "their squares" covaries with the argument
12:19:51 <Funktorsalat> would be... the type of strictly monotonic functions :)
12:19:52 <sinelaw> Π x : Int . SquareMatrix(x)
12:20:05 <augur> exactly
12:20:11 <sinelaw> great
12:20:15 <augur> whereas sigma is just a pair, but with dependent values
12:20:32 <sinelaw> sigma?
12:20:39 <sinelaw> didn't encounter that yet
12:20:48 <augur> sigma x : A.B is a pair of type (A,B) where the value of type B can be dependent on the first value
12:20:55 <augur> e.g. imagine all pairs (x,x*x)
12:21:06 <augur> this would be sigma x : Int.squares_of(x)
12:21:11 <Funktorsalat> sigma is for making pairs where the type of the second element may depend on the value of the first
12:21:18 <sinelaw> ah
12:21:24 <sinelaw> a special case of Pi then?
12:21:26 <Funktorsalat> like Sigma x : Int. SquareMatrix(x) :)
12:21:33 <Funktorsalat> not really
12:21:46 <Funktorsalat> your pi would be a function that maps *each* integer to a square matrix of that size
12:21:55 <Funktorsalat> while that sigma is just one integer and a matrix of that size
12:21:56 <sinelaw> why not \Pi x : A . (A, B(x))
12:22:24 <Funktorsalat> that's a function that gives a pair for each such x
12:22:35 <augur> right
12:22:45 <augur> sigma is the type of PAIRS
12:22:48 <augur> pi is the type of FUNCTIONS
12:23:44 <sinelaw> ok how about a book recommendation?
12:23:51 <sinelaw> where did  you folks learn this
12:25:10 <augur> i learned it in a book on type-logical grammar :D
12:25:13 <stepkut> tommd: would be nice if 'binary' built under 7.0 :-/
12:25:35 <JoeyA> 7.0 of what?
12:25:38 <sinelaw> augur, which one
12:25:48 <augur> meh. you wouldnt want to read it
12:26:02 <augur> i think any book on martin lof / intuitionistic type theory would be good
12:26:05 <augur> since thats what this is
12:26:07 <tommd> JoeyA: ghc
12:26:13 <stepkut> JoeyA: GHC
12:26:22 <tommd> GGHC
12:26:33 <tommd> GGH'C?
12:26:45 <tommd> Perhaps that's more accurate
12:26:52 <stepkut> grand & glorious haskell compiler?
12:27:00 <augur> Glorious Glaskow Haskell Compiler
12:27:03 <JoeyA> heh
12:27:07 <tommd> Glorious Glaskow Haskell Prime Compiler
12:27:09 <augur> compared to the Inglorious Glasgow HAskell Compiler
12:27:15 <augur> and the Glorious Edinburgh Haskell Compiler
12:27:52 <stepkut> Glorious Microsoft Research Haskell Compiler ?
12:28:04 <PeakerWork> heh
12:28:36 <Funktorsalat> sinelaw: mostly from dealing with coq, personally
12:30:09 <Funktorsalat> dependent curry: Pi x:A. Pi y:B(x). C(x,y)     ->         Pi: (x,y) : (Sigma x:A. B(x))  .  C(x,y)
12:30:22 <Funktorsalat> (as a relation between Pi and Sigma)
12:30:29 <augur> thats dependent uncurrying :|
12:32:02 <Funktorsalat> ehm, curry would be the other direction, that's uncurry :)
12:32:24 <augur> yes.
12:32:57 <augur> so if Pi (x,y) : (Signa x:A.B(x)) . C(x,y) is your function, it curries to Pi x:A. Pi y:B(x). C(x,y)
12:44:15 <Funktorsalat> so, base-3.x is gone in ghc 7?
12:48:00 <FamilyGuy> http://www.megavideo.com/?v=U5Z2RABH new family guy episode in HD, season 9 episode 1
12:49:33 <PeakerWork> FamilyGuy: spam?
12:49:50 <zc00gii> lulz
12:52:08 --- mode: ChanServ set +o Igloo
12:52:19 --- mode: Igloo set +b *!*@@94-194-215-57.zone8.bethere.co.uk
12:52:22 --- kick: FamilyGuy was kicked by Igloo (FamilyGuy)
12:52:32 <revenantphx> ...?
12:52:38 <Itkovian> awesome kick
12:52:44 <Itkovian> have karma
12:54:14 <augur> he should know that he should've done that in #haskell-blah
12:54:15 <augur> stupid bots
12:55:23 <sinelaw> what does this symbol mean
12:55:27 <sinelaw> |-
12:55:30 <sinelaw> in logic
12:56:17 <revenantphx> :t (
12:56:18 <lambdabot> parse error (possibly incorrect indentation)
12:56:21 <revenantphx> :t (|-)
12:56:22 <lambdabot> Not in scope: `|-'
12:56:30 <revenantphx> > 1 |- 0
12:56:31 <lambdabot>   Not in scope: `|-'
12:56:33 <revenantphx> dunno.
12:56:36 <medfly> http://en.wikipedia.org/wiki/Table_of_mathematical_symbols 
12:56:39 <revenantphx> Doesn't seem to exist as a logic operator.
12:56:43 <revenantphx> is haskell
12:56:44 <medfly> x ⊢ y means y is derivable from x.
12:56:57 <medfly> very nice chart.
12:56:58 * hackagebot hmatrix-glpk 0.2.1 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.2.1 (AlbertoRuiz)
12:56:59 <sinelaw> thanks medfly 
12:57:01 <sinelaw> yeah
12:57:03 <medfly> ^_^
12:57:03 <revenantphx> medfly: ah I see.
12:57:46 <sinelaw> that's what i was guessing, but in this paper it appears prefix
12:57:58 * hackagebot hTensor 0.7.0 - Multidimensional arrays and simple tensor computations.  http://hackage.haskell.org/package/hTensor-0.7.0 (AlbertoRuiz)
12:58:31 <djahandarie> Context?
12:58:35 <medfly> heh
12:58:42 <medfly> <: is a mathematical symbol
12:59:03 <sinelaw> djahandarie, http://dare.ubn.kun.nl/dspace/bitstream/2066/17240/1/13256.pdf
12:59:21 <sinelaw> page 4, paragraph 2 - the one that starts with "The next idea..."
12:59:29 <medfly> http://en.wikipedia.org/wiki/%E2%8A%A2 o.O
13:00:01 <sinelaw> djahandarie, i think he's just continuing what he was writing in the text before that equation
13:00:37 <djahandarie> Hm that's what it seems to be
13:04:03 <xplat> sinelaw: |- can appear prefix if the RHS is a tautology or, in some cases, a theorem.  it means 'derivable without assumptions'.  also, sometimes in classical-style logics (including full linear logic) there is a deduction style where everything goes on the right of |- because a statement on the right is equivalent to the negation of that statement on the left or vice versa so they only use one side to minimize complications
13:04:41 <xplat> (when you have multiple propositions on the right of the |- they are implicitly ORed, on the left they are implicitly ANDed)
13:05:00 <sinelaw> xplat, ah ok :) 
13:05:14 <sinelaw> my background in logic is.....minimal unfortunately
13:05:19 <xplat> also, the usual word for |- is 'turnstile'
13:06:05 <Tomer_> hi. i have a problem with simpleHTTP hanging after fetching certain pages under win 7 and i saw this is a known issue. does anyone here have a solution?
13:06:37 <xplat> isn't simpleHTTP deprecated?
13:06:40 <ddarius> Debugging assembly programs without a nice debugger, always a joy.
13:06:52 <Tomer_> xplat: don't know. is it?
13:07:06 <Tomer_> it came with GHC. what to use instead?
13:07:13 <xplat> HTTP
13:07:16 <Botje> ddarius: don't write bugs in the first place! ;)
13:07:52 <Tomer_> xplat: well, that solves it :-)
13:07:58 <xplat> ddarius: write a Haskell compiler in assembler macros, problem solved
13:08:05 <Tomer_> i knew i'd find a solution here. thanks
13:08:17 <Twey> xplat: Assembler macros… you mean C?  I think we have one of those already.
13:08:20 <niko> A§f
13:08:30 <sinelaw> btw, \Pi is "forall" in haskell type signatures?
13:08:35 <sinelaw> or am i wrong
13:08:40 <Twey> You're wrong
13:08:45 <Twey> \forall is forall
13:08:57 <xplat> no, \Pi is more general than haskell forall
13:08:57 <pumpkin> sinelaw: it's similar
13:08:58 <Twey> \Pi is something else
13:09:04 <sinelaw> ah right, \Pi accepts values
13:09:07 <sinelaw> terms
13:09:26 <sinelaw> and forall quantifies only over types. right?
13:09:32 <sinelaw> (is that the difference?)
13:09:33 <xplat> yeah, forall only accepts a type, not a term w/type
13:10:22 <Tomer_> xplat: can you refer me to a usage example for HTTP?
13:10:27 <sinelaw> so \Pi on terms that have type *, is the same as forall
13:10:48 <xplat> sinelaw: essentially, yes
13:11:18 <ddarius> Botje: That's my usual solution.
13:11:25 <pumpkin> sinelaw: yeah, and you can rewrite (->) in terms of a pi that doesn't use its argument
13:11:46 <sinelaw> pumpkin, yeah, i'm reading a paper that gives exactly that example
13:13:43 <ddarius> Many type theories use Π in a more generic manner that would include ∀.
13:14:26 <pumpkin> sinelaw: there's also a sigma for the same idea on pairs
13:14:30 <sinelaw> btw ddarius, pumpkin any type theory book recommendations?
13:14:52 <ddarius> sinelaw: Presumably TAPL is good for someone starting, if that description applies to you.
13:15:08 <pumpkin> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.7428&rep=rep1&type=pdf wasn't bad
13:15:17 <pumpkin> seemed like a description of agda
13:15:17 <ddarius> There are some other, more readily available sources, that aren't too bad.
13:15:46 <rothwell> coq'art \o/
13:15:47 <PeakerWork> ddarius: TAPL touches on DT's and logic?
13:15:59 <pumpkin> you need attapl if you want DTs
13:16:07 <pumpkin> and there isn't that much in there about them
13:16:07 <ddarius> PeakerWork: I've never read TAPL.
13:16:31 <sinelaw> PeakerWork, btw i never got TAPL
13:16:33 <sinelaw> got lost in the mail
13:16:45 <ddarius> "Lectures on the Curry-Howard Isomorphism" is also pretty good, though I think it too doesn't really cover dependent types.
13:16:47 <PeakerWork> sinelaw: bummer.. The Book Depository (UK) worked for me
13:16:47 <sinelaw> and now the price jumped back to $66 so i'm giving up on it
13:16:51 <PeakerWork> sinelaw: ah
13:16:57 <sinelaw> PeakerWork, you got it?
13:17:14 <xplat> Σa: *. is like ∃a.
13:17:24 <PeakerWork> sinelaw: not TAPL, 2 haskell books.. gtg!
13:17:28 <sinelaw> k
13:17:52 <sinelaw> ddarius, as long as it's introductory
13:18:09 <sinelaw> i'll get the more advanced stuff later :)
13:18:12 <sinelaw> pumpkin, thanks, looks nice
13:19:06 <pumpkin> also, just playing with agda could be helpful :)
13:19:09 <pumpkin> or something similar
13:19:59 <Ochowie> hi everyone, is there a good way to call haskell from c/c++
13:20:08 <Vanadium> foreign export
13:20:12 <Ochowie> it seems like haskelldirect isn't maintained anymore and i can't find anything else
13:20:53 <sinelaw> ok now get me an iPad so i can read all this
13:20:54 <xplat> if you know math notation for indexed products and sums, the dependent sum and product are very like that
13:21:23 <xplat> where "sum" = variant and "product" = tuple/record
13:21:45 <sinelaw> ddarius, thanks 
13:22:10 <tommd> Ochowie: See Haskells FFI, you can "foreign export" functions.
13:22:40 <Ochowie> i've gotten that to work with simple types, are there any decent resources on this
13:23:33 <xplat> regular tuple is a Σ type because you can get a product by iterating addition.  it's basically a variant with one constructor for each value of the first component, and all constructors of the same type
13:24:13 <augur> anyone know how to approach an algebraic structure in which the objects are related to one another in some way in virtue of how the subparts of each structure are related to one another?
13:25:34 <xplat> but "ΠisSnd: Bool. if isSnd then b else a" is also a perfectly good pair type
13:27:58 <xplat> Ochowie: if FFI is getting hard to handle for a laerge API or complicated types you can try some of the 2hs family of packages
13:28:02 <xplat> like c2hs
13:28:37 <deech> Hi all, does anyone know if there are Haskell<->PHP bindings?
13:29:22 <tommd> xplat: Have I been asleep and c2hs can now export?
13:30:08 <tommd> I love c2hs (damned hsc2hs) but it doesn't do what he wants.
13:32:32 <xplat> tommd: oh, sorry, i misread :(
13:38:24 <augur> so guys
13:38:28 <augur> algebraic structures
13:39:12 <xplat> augur: i'm having trouble figuring out what you want
13:39:30 <xplat> it seems kind of vague
13:39:36 <osaunders> What's the difference between div and quot?
13:40:06 <xplat> > (-5 `div` 7, -5 `quot` 7)
13:40:07 <lambdabot>   (0,0)
13:40:07 <pumpkin> augur: funny you should mention that, I put a paste up on hpaste a little while ago about them
13:40:15 <pumpkin> xplat: nice
13:40:16 <xplat> > (-15 `div` 7, -15 `quot` 7)
13:40:17 <lambdabot>   (-2,-2)
13:40:44 <xplat> okay, the first one was my bad, but what's with that?
13:40:48 <pumpkin> @check \x y -> x `div` y == x `quot` y
13:40:49 <lambdabot>   "*Exception: divide by zero
13:40:57 <pumpkin> @check \x y -> x /= 0 ==> x `div` y == x `quot` y
13:40:58 <lambdabot>   No instance for (Test.QuickCheck.Testable
13:40:58 <lambdabot>                     (Test.QuickCh...
13:41:02 <pumpkin> oh screw you
13:41:04 <augur> xplat: ok, imagine i have a function, say.. square, and i have some relation   next xs ys :: {Int} -> {Int}
13:41:10 <DrTeggy> Hehe
13:42:31 <augur> xplat: such that   next xs ys = any (\x -> xs `minus` {x} == ys `minus` {x} && ys == xs `minus` {x} `plus` {x*x}) xs
13:42:52 <augur> that is, next holds of two sets just when the second is the same as the first but for one item being squared
13:43:46 <xplat> augur: {Int} -> {Int} looks like a function from sets(?) of Ints to sets(??) of Ints.  i guess you meant {Int} -> {Int} -> Bool?
13:43:53 <_dsouza_> > (15 `div` (-7), 15 `quot` (-7))
13:43:54 <lambdabot>   (-3,-2)
13:44:09 <augur> er.. yes, sorry, {Int} -> {Int} -> Bool.
13:44:31 <augur> damn typos!
13:44:52 <xplat> so next {1,2,3} {2,3,4} holds?
13:45:20 <augur> no. how could it?
13:45:21 <xplat> er, no, i mean next {1,2,3} {1,3,4}
13:45:26 <augur> yes
13:45:37 <augur> {1,2,3} -> {1,2*2,3}
13:45:59 <augur> or {1,2,3} -> {1*1,2,3} or -> {1,2,3*3}
13:46:05 <xplat> okay, so what about it?
13:46:41 <augur> well, so next is some sort of ordering over the type {Int}
13:47:11 <augur> but it can be defined in terms of the members inside each set
13:47:24 <xplat> no, it's not an ordering, it's not transitive
13:47:38 <augur> right right sorry
13:47:45 <augur> its a non-transitive ordering :p
13:48:46 <gwern> hm. do we consider 2/0 to == 1/0?
13:48:49 <augur> it forms a lattice-esque structure tho, i think.
13:48:59 <xplat> in this case the transitive reflexive closure is probably a partial ordering
13:49:18 <gwern> > (1/0) == (2/0)
13:49:19 <lambdabot>   True
13:49:29 <gwern> > 1/0
13:49:30 <lambdabot>   Infinity
13:49:32 <gwern> oh
13:49:50 <Funktorsalat> we have debuggers? according to the otherwise good blurb in the haskell.org intro paragraph :)
13:50:00 <gwern> Funktorsalat: in ghci
13:50:01 <augur> anyway, xplat, the important point is, the relation is such that you can define think of the next relation as being applicable to sets *in the abstract* or you can analyze it as related to the composition of the sets
13:50:09 <Funktorsalat> well... ;)
13:50:31 <Funktorsalat> maybe it's just me, but I think it's considered hard to use
13:50:43 <augur> in the same way that you can think of   succ x y   as being abstract over numbers, or as   succ x y = y == {x}
13:50:51 <gwern> there are easy debuggers for lazy pure FP langs/
13:50:54 <gwern> ?
13:51:10 <augur> xplat: is there a way to talk about "next" _mathematically_ using the latter conception?
13:52:42 <chrisdone> dcoutts_: it happened again v_v
13:52:42 <xplat> maybe as a rewrite relation on sets?
13:52:44 * chrisdone pastes
13:53:18 <xplat> rewriting on multisets has been used as the mathematical basis of the Chemical Abstract Machine
13:53:45 <augur> xplat: ok. what kind of algebraic tools could be brought to bare on this issue
13:54:05 <chrisdone> dcoutts_: http://hpaste.org/40195/cabal_and_broken_packages
13:54:37 <chrisdone> dcoutts_: I don't know how base can become missing; I thought GHC installed that. and yet: time-1.2.0.3 is broken due to missing package base-4.2.0.2-10bdacb430274706a59728e237e2bfb3
13:55:03 <xplat> i'm really still finding it hard to figure out what exactly the issue is.  i get the 'next' example in isolation, but i don't know what axes i'm supposed to generalize it on
13:55:39 <augur> well, i know that we can talk about algebraic structures like partial orders, lattices, etc etc, right
13:55:45 <augur> we can reason about them, and so forth
13:55:47 <xplat> sure
13:56:02 <augur> how could i reason about whatever kind of structure next creates?
13:58:12 <augur> or is this just generic abstract algebra? im not sure if abstract algebra usually admits of talking of relations between objects by way of relations between subobjects
13:58:34 <pumpkin> when in doubt, use CT
13:58:38 <augur> CT?
13:58:41 <augur> oh, category theory
13:59:03 <augur> from what i know, CT is _explicitly_ against talking about morphisms by way of the insides of the objects in question
13:59:23 <pumpkin> then use a topos or something :P
13:59:28 * pumpkin shrugs, and is clueless
13:59:37 <augur> if only i knew CT and knew what a topos was!
14:01:06 <chrisdone> chris@cn-done:~$ cabal install base
14:01:07 <chrisdone> Resolving dependencies...
14:01:07 <chrisdone> cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda
14:01:09 <chrisdone> tee hee!
14:01:11 <xplat> augur: this really depends on what kind of reasoning you want to do.  what do you want to know about these relations?
14:02:26 <augur> xplat: well, the problem im looking at is slightly more complicated that the example, but suppose now we have some property of the sets-of-things, call this property f, an integer number
14:04:00 <augur> then the question is, is there a way to define f recursively so that if  next xs ys  then  f ys = ... f xs ...
14:04:28 <augur> or is f a non-local property of these objects
14:04:46 <augur> xplat: imma /msg you so as to not spam the channel
14:07:18 <chrisdone> bahhh everything's broken, again
14:08:12 <chrisdone> install one wrong package and the whole things is bollocksed
14:08:34 <chrisdone> M-x rage-control
14:14:45 <IceDanelol> So I wrote an irc bot for shits and giggles, but it seems to crash on unicode characters. I'm just using String if that matters. do I need to be using some special type?
14:15:50 <dolio> How are you reading in the String?
14:16:02 <pumpkin> crash how?
14:17:02 <IceDanelol> pumpkin: I'm not entirely sure. It just dies. anyway, sec, let me look at my code
14:17:29 <gwern> IceDanelol: String is internally utf8, but Input/Output may screw any unicode
14:17:38 <IceDanelol> hGetLine
14:17:41 <IceDanelol> gwern: I see
14:17:44 <IceDanelol> I would have figured it was
14:17:49 <c_wraith> err, what?
14:17:56 <c_wraith> String is not internally UTF-8
14:18:08 <gwern> my understanding was that the report so specified it
14:18:15 <c_wraith> String is internally a linked list of UCS-32 values
14:18:20 <gwern> and that it wasn't latin-1337 or whatever
14:18:46 <pumpkin> string is an abstract unicode char
14:18:55 <pumpkin> or a list of them
14:20:13 <c_wraith> What really matters for this conversation, though, is that string is unicode internally, but its IO is probably not what you want.
14:20:36 <dolio> You have to make sure the locale is set properly.
14:20:38 <dolio> Or something.
14:21:04 <gwern> 6.12 made the situation even more complex :(
14:21:18 <gwern> used to be you could just tell people to switch all their IO to utf8-string or something
14:29:57 <pumpkin> conal: did you figure out the unamb issue? sorry, I haven't gotten around to your email yet
14:32:32 <conal> pumpkin: no, not yet.
14:33:07 <gwern> ah, unamb. conal has been working on that one for a while
14:33:22 <gwern> at least a year now?
14:33:59 <conal> gwern: more than 2, i think.
14:34:04 <gwern> ouch
14:34:21 <gwern> well, I'm sure the job has meant the last year or whatever wasn't that productive
14:34:31 <conal> gwern: oh, it's not like that.  just on & off.
14:35:03 <conal> edward kmett suggested a nice optimization recently that doesn't quite work yet.
14:35:22 <conal> and he though pumpkin would know.
14:35:35 * pumpkin is trying to think
14:35:37 <conal> the question is how to identify an evaluated _|_ in ghc's rts.
14:36:22 <tomh-> hey, kind of a noob question probably, but how do you execute IO functions on list elements like putStrLn? I forgot :D
14:36:40 <gwern> mapM?
14:36:54 <Heffalump> for putStrLn, which returns IO (), mapM_
14:37:03 <Heffalump> for things that return values you want to keep, mapM
14:37:03 <tomh-> ah mapM
14:37:10 * shapr tries cabal install Idris
14:37:56 <conal> it'd be cool to fix edward's optimization, as it avoids spinning threads for unamb in many cases.
14:38:46 <conal> and although i think unamb & lub have been working correctly for a good while now, it'd be great to speed them up.
14:40:01 <pumpkin> hmm
14:46:07 <tolkad> what does this mean?
14:46:08 <tolkad> <command line>: cannot satisfy -package Cabal-1.8.0.6: 
14:46:08 <tolkad>     Cabal-1.8.0.6-ec9be469687b5a514f4b7e8e2b8343c7 is unusable due to missing or recursive dependencies:
14:46:08 <tolkad>       containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379
14:46:31 <shapr> Grr, Idris requires base 4.x, time to skip ahead to ghc7 perhaps?
14:47:30 <Saizan> shapr: you've base-4.x since ghc-6.10
14:47:36 <tolkad> I'm just trying to install something
14:47:42 <shapr> oookay...
14:48:05 <shapr> Saizan: Well that's confusing, lemme try it again.
14:48:36 <tolkad> I do have containers-0.3.0.0 installed
14:48:38 <tolkad> it's lying
14:48:48 <Saizan> tolkad: do you have containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379 ?
14:48:49 <shapr> Ok, seems to be a problem with epic, whatever that is ...
14:49:02 <Saizan> tolkad: check if the id field corresponds to that hash
14:50:06 <tolkad> Saizan: uh how do I check?
14:50:17 <Saizan> tolkad: ghc-pkg field containers id
14:50:48 <tolkad> Saizan: yeah I do
14:51:06 <tolkad> Saizan: id: containers-0.3.0.0-5e5316afb979d62081115c0576cc0513
14:51:06 <tolkad> id: containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379
14:51:52 <Saizan> tolkad: ok, then it's probably that containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379 is being shadowed by container-0.3.0.0-5e5316afb979d62081115c0576cc0513 earlier
14:52:12 <Saizan> ghci does the shadowing right at the start
14:52:20 <Saizan> you can see it with -v
14:52:48 <Saizan> "ghci -package-id Cabal-1.8.0.6-ec9be469687b5a514f4b7e8e2b8343c7" should do the right thing
14:53:03 <Saizan> or you may want to get rid of one container-0.3.0.0 installation
14:55:03 <tolkad> I'm not sure how I could have two copies of the same package/version
14:55:55 <Saizan> you've one in the global and one in the user db, probably
14:56:19 <Saizan> check "ghc-pkg list containers"
14:56:52 <tolkad> oh yeah
14:56:56 <tolkad> I'll just delete user db
14:57:32 <tolkad> yay that worked
14:58:23 <tolkad> thanks
15:48:56 <manateeUser> Good morning!:)
15:51:08 <aristid> manateeUser: using your own irc client?
15:51:39 <manateeUser> aristid: Yeap.
15:51:56 <manateeUser> aristid: I feel pretty good, very stable.
15:52:14 <manateeUser> aristid: ^^^ Tranlsate from Chinese 
15:52:48 <manateeUser> aristid: I found use haskell implement irc client very fast and stable.
15:52:51 <aristid> google translate?
15:53:00 <manateeUser> aristid: Yep. :)
15:53:35 <aristid> manateeUser: i think you are better than google translate :D
15:53:43 <manateeUser> aristid: Look my flickr page : http://www.flickr.com/photos/48809572@N02/
15:53:51 <manateeUser> aristid: :)
15:54:29 <manateeUser> aristid: fifth.
15:54:52 <aristid> manateeUser: i'm not sure if dbus is the right architecture choice
15:55:03 <manateeUser> aristid: Why?
15:55:33 <manateeUser> aristid: Use DBus, you don't need care which receive message.
15:56:00 <aristid> manateeUser: well, i think tcp/unix sockets are more flexible, faster, and more portable.
15:56:16 <lispy> and too low level?
15:56:28 <manateeUser> aristid: DBus is more handy. :)
15:57:01 <aristid> also, i can connect to tcp/unix sockets with socat
15:57:07 <aristid> i don't know how to debug dbus
15:57:52 <manateeUser> lispy: www.flickr.com/photos/48809572@N02/5031811365/lightbox/ ==> My framework. :)
15:58:16 <lispy> manateeUser: cheers
15:58:22 <manateeUser> aristid: There have Haskell implement for DBus protocol and client.
15:58:29 <manateeUser> @package dbus-core
15:58:29 <lambdabot> http://hackage.haskell.org/package/dbus-core
15:58:35 <manateeUser> @package dbus-client
15:58:35 <lambdabot> http://hackage.haskell.org/package/dbus-client
15:58:54 <lispy> manateeUser: there *are* haskell implementations ... :)
15:59:28 * lispy realizes english verbs are weird and just means to help :)
15:59:30 <manateeUser> lisp: Well, I use Google Translation
15:59:53 <lispy> manateeUser: Hmm... for all your english communications?
16:00:06 <manateeUser> lisp: For complex syntax. :)
16:00:23 <lispy> manateeUser: that's impressive.  And it works okay?
16:00:26 <manateeUser> lispy: My irc client haven't english helper. :)
16:00:34 <Saizan> preflex: zdec __stginit_Agdazm2zi2zi9_AgdaziSyntaxziTranslationziConcreteToAbstract_
16:00:34 <preflex>  __stginit_Agda-2.2.9_Agda.Syntax.Translation.ConcreteToAbstract_
16:00:41 <manateeUser> lispy: If i write Chinese clear enough.
16:00:51 <lispy> Saizan: oh, cool
16:00:53 <manateeUser> lispy: In Emacs, i have English helper. :)
16:01:01 <lispy> Saizan: can you hook that into gdb?
16:01:29 <lispy> Saizan: oh, or add that as an optional pass to ghc-core
16:01:55 <lispy> Saizan: I wonder if we could get dons to do it...
16:02:20 <Saizan> lispy: ask someone who works on ghc-core or gdb maybe :)
16:02:52 <lispy> Saizan: how did you implement it?  Just by reading the  GHC source?
16:02:59 <lispy> (or did you implement it?)
16:03:19 <Saizan> i didn't
16:03:57 <Saizan> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
16:05:47 <lispy> thanks for the link
16:07:39 <manateeUser> aristid: About portable, i just ignore Windows. :)
16:08:01 <aristid> manateeUser: does dbus work on os x? freebsd?
16:08:17 <manateeUser> aristid: I don't know.
16:08:25 <manateeUser> aristid: I think FreeBSD can work.
16:09:13 <aristid> manateeUser: well, you see what i mean?
16:09:21 <manateeUser> aristid: Yep. :)
16:09:32 <manateeUser> aristid: I have think that before use DBus.
16:10:39 <anthonyl> j #java
16:10:44 <anthonyl> ooooo
16:10:47 <lispy> Why wouldn't DBus be portable?
16:10:53 <lispy> That strikes me as odd
16:11:05 <manateeUser> lispy: I just haven't Windows and Mac to test.
16:11:22 <aristid> lispy: i suppose it is portable in theory, but that doesn't buy you a beer if nobody actually ports it
16:12:16 <lispy> aristid: has anyone ever bought you a beer when software wasn't ported? :)
16:14:25 <aristid> lispy: my software always buys me LOTS of metaphorical beer :)
16:14:35 <manateeUser> aristid: DBus is design for desktop system (like my program), and very stable and fast enough. :)
16:14:51 <manateeUser> aristid: Well, i know what you mean, but my system design for Linux.
16:15:18 <manateeUser> aristid: Why we need support Windows and Mac, since they're not open system?
16:15:47 <aristid> manateeUser: i don't really see the big advantage of using dbus
16:16:15 <manateeUser> aristid: You can work together with other software.
16:16:34 <manateeUser> aristid: Example, my program, you can use other language write sub-module.
16:16:55 <manateeUser> aristid: If you use other IPC, you need know which IPC other software use.
16:16:59 <aristid> manateeUser: you can do that with tcp sockets too, and even over multiple computers that way
16:18:54 <manateeUser> aristid: You perhpahs right, but it's too late for my system. :)
16:23:33 <manateeUser> Coding time, bye. :)
16:24:15 <tommd> I didn't know #haskell and coding were mutually exclusive.
16:24:39 <hpc> it is if the topic is interesting ;)
16:42:32 <Philonous> I find myself writing "foo <- bar -< ()" a lot in arrow notation. I wonder whether it'd be reasonable to have "foo <- bar" desugar to that.
16:43:19 <Saizan> i'd think so
16:43:39 <Saizan> thouh you might aòso prt
16:43:59 <Saizan> prefer using an applicative interface
16:44:12 <hpc> what does foo <- bar -< () desugar to?
16:47:02 <Philonous> hpc: Arrow notation has no simple desugaring, like monad do notation. Named bindings are transformed into a position in nested pairs
16:47:33 <hpc> so the arrow just gets uglier and uglier as it goes longer?
16:49:05 <Philonous> Yeah, the nested pairs grow with the length of the arrow. I guess you could do some optimization, but afaik ghc doesn't do anything clever (safe what it does to nested pairs anyway)
16:49:22 <Peaker> Any reason to use arrows rather than Category+Applicative?
16:49:38 <copumpkin> http://hackage.haskell.org/package/CCA
16:51:02 <copumpkin> there's more TH than I'd expect in there
16:53:35 <Philonous> Peaker: The same as for monads. It's a stronger interface. 
16:54:21 <hpc> copumpkin: by "more" you mean "presence of"? :P
16:54:28 <copumpkin> yeah :)
16:54:37 <copumpkin> well, I might expect to see it
16:54:43 <copumpkin> but not in methods of an Arrow-like typeclas
16:55:26 <Peaker> Philonous: I thought Category+Applicative was same power as Arrows
16:56:05 <copumpkin> what would it mean to be Category+Applicative when they take things of different kinds?
16:56:20 <copumpkin> Applicative on the codomain of your arrow?
16:56:36 <Peaker> copumpkin: Category c, Applicative (c a)
16:57:25 <copumpkin> I dunno, write translations to and from :)
16:57:37 <Peaker> arrg. I wanted to sleep, but now I have to do that
16:57:37 <Peaker> :)
16:57:47 <copumpkin> you still get a lot of convenience from the arrow syntax, assuming you don't barf at the sight of it
16:58:13 <Philonous> Peaker: No, arrows are strictly stronger than both category and applicative. See Wadlers paper: http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
16:58:15 <Peaker> I hate arrow proc do
16:58:21 <Saizan> if you're using  -< () a lot i think applicative could be nicer
16:58:49 <Peaker> Philonous: Hmm.. I seem to recall a big discussion by quicksilver and someone here about them being same strength. I'll just try to implement them in terms of each other
16:58:51 <Saizan> Philonous: Category+Applicative /= Applicative
16:59:01 <Saizan> Peaker: you too :)
16:59:16 <Peaker> Saizan: Category+Applicative /= Arrow, you mean?
16:59:45 <Saizan> no, i mean what i said
16:59:58 <Saizan> Category+Applicative ~ Arrow
17:01:45 <Saizan> (i strongly suspect you need some coherence laws to tie pure/<*> together with >>>/id though)
17:02:08 <Philonous> Saizan: Is there a paper on that? That's a pretty nice proposition
17:02:11 <Peaker> I'm trying to write the incoherent instance: instance (Category c, Applicative (c i)) => Arrow c where
17:02:23 <hpc> Saizan: well pure already == id
17:02:38 <copumpkin> Peaker: why not just make a wrapper?
17:03:26 <aristid> :t [pure, id]
17:03:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
17:03:27 <lambdabot>       Expected type: f a
17:03:27 <lambdabot>       Inferred type: a
17:03:29 <Peaker> copumpkin: just testing the types add up :)
17:03:38 <Peaker> copumpkin: currently they don't :)
17:03:39 <aristid> hpc: pure == id never holds :)
17:03:44 <hpc> er
17:03:55 <Saizan> hpc: the types wouldn't match here, pure :: a -> arr x a; id :: arr a a
17:03:58 <Philonous> Saizan: Btw the idea was to get as close to monadic notation as possible. That's why I preferred foo <- bar (-< () ) to an applicative interface
17:04:05 <hpc> ...dur dur, i am idiot
17:05:05 <Peaker> apparently, instance (Category c, Applicative (c i)) => Arrow c where  does not say that  (forall i. Applicative (c i))
17:05:08 <Saizan> Philonous: makes sense
17:05:22 <Peaker> I'm not sure what it does say (s/forall/exists?)
17:06:12 <Peaker> because it refuses to accept: arr f = f <$> id  (saying it cannot deduce Functor context)
17:06:48 <Peaker> @type \f -> f $ Control.Category.id
17:06:49 <lambdabot> forall b (cat :: * -> * -> *) a. (Control.Category.Category cat) => (cat a a -> b) -> b
17:07:04 <Peaker> @type \f -> f <$> Control.Category.id
17:07:05 <lambdabot> forall a b (cat :: * -> * -> *). (Control.Category.Category cat, Functor (cat a)) => (a -> b) -> cat a b
17:07:13 <Saizan> Peaker: right, it's not forall, it's more like exists
17:07:31 <Peaker> Saizan: how come lambdabot came up with the last type then?
17:07:41 <Peaker> oh, it's the same "a", never mind
17:07:52 <hpc> all ids are not created equal
17:08:05 <Peaker> so I can't write the instance because I cannot express the constraint, I'll write the convertor function
17:09:33 <Peaker> Category, "arr" and "first" are enough to get an Arrow, right? 
17:09:42 <Peaker> Cause can derive second, then ***, then the world
17:10:26 <Saizan> Peaker: you also need (***)
17:10:39 <Saizan> maybe not.
17:10:52 <Peaker> Saizan: can't have f *** g = first f . second g ?
17:11:00 <Peaker> and second = arr swap . first . arr swap
17:11:11 <Philonous> @type (***)
17:11:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:11:29 <Saizan> Peaker: yeah
17:11:30 <reorg> so i'm getting Text.Parsec.Token not found error
17:11:40 <reorg> even though i've cabal installed parsec
17:11:44 <Philonous> Peaker: You need to add arr (\a -> (a,a)), but that should do the trick
17:11:55 <Peaker> Philonous: for (&&&) you mean?
17:11:58 <Saizan> http://code.haskell.org/~Saizan/Arrow.agda <- messy remains of an agda proof
17:12:25 <Philonous> Peaker: Yeah, sorry. I should probably stop writing and go to bed instead
17:12:34 <Saizan> reorg: try with "cabal install "parsec >= 3""
17:12:50 <Peaker> Philonous: I said that too, then you challenged that Cat+App /= Arr, so I am staying up to prove that it is :)
17:13:06 <Peaker> and if it is, I think Arrow should finally be put to rest...
17:13:27 <Peaker> maybe Arrow-without-arr could be useful (with some more combinators, though, maybe conal's DeepArrow-style)
17:13:53 <Saizan> you'd also need to prove the Arrow laws, i don't think you can do it if you need to go to sleep :)
17:14:03 <copumpkin> yeah, agda kthx
17:14:18 <reorg> Saizan, thx, that worked, so do i need to remove parsec2.x?
17:14:26 <Philonous> Peaker: Then we should bury Monad, too, and make it Category + Applicative + Join or something
17:14:43 <Peaker> Philonous: Applicative+Join indeed, but Join would be called Monad :)
17:14:59 <Peaker> class Applicative f => Monad f where join :: f (f a) -> f a
17:15:00 <hpc> yes, because Monads aren't confusing enough :P
17:15:01 <copumpkin> well, Arrow can model Monad, and Category + Applicative can
17:15:05 <copumpkin> model Arrow
17:15:13 <copumpkin> so you don't need a separate Join?
17:15:13 <Saizan> reorg: not necessarily, if you want you can ghc-pkg unregister parsec-2.x
17:15:50 <Philonous> copumpki: How do you mean "Arrow can model Monad"? 
17:15:56 <Peaker> Philonous: I like the idea of having the minimal amount of type-classes that cover as much of the interesting expressive-space as possible. If there's equivalence between sets of type-classes it would be nice to eliminate some
17:16:01 <Saizan> copumpkin: you need ArrowApply to get Monad's expressiveness
17:16:07 <copumpkin> ah, fair enough
17:19:29 <Philonous> Peaker: I don't know, I like arrows. They have this beautiful stack semantics. 
17:19:41 <Peaker> what are "stack semantics"?
17:20:12 <Peaker> how do you get *** or first from (pure, <*>, id, . ) ?
17:21:24 <Saizan> f *** g = (,) <$> (arr fst >>> f) <*> (arr snd >>> g)
17:22:19 <Saizan> f &&& g = (,) <$> f <*> g -- quite nice
17:22:25 <Peaker> ah thanks
17:22:32 <Peaker> no need to write &&& :)
17:22:35 <hpc> oooh, that is nice
17:22:49 <Peaker> liftA2 (,) is my favorite form :)
17:23:03 <hpc> :t liftA2 (,)
17:23:04 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
17:23:07 <hpc> :t (&&&)
17:23:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:23:33 <c_wraith> :t liftA2 (,) `asTypeOf` (&&&)
17:23:35 <lambdabot> forall a b (a1 :: * -> * -> *) b1. (Applicative (a1 b1), Arrow a1) => a1 b1 a -> a1 b1 b -> a1 b1 (a, b)
17:23:54 <aristid> :t (,) <$> (arr fst >>> f) <*> (arr snd >>> g)
17:23:55 <lambdabot> forall a a1 a2 b (cat :: * -> * -> *). (Arrow cat, SimpleReflect.FromExpr (cat a2 a), Applicative (cat (a2, b)), SimpleReflect.FromExpr (cat b a1)) => cat (a2, b) (a, a1)
17:24:02 <aristid> :t \f g -> (,) <$> (arr fst >>> f) <*> (arr snd >>> g)
17:24:03 <lambdabot> forall a a1 a2 b (cat :: * -> * -> *). (Arrow cat, Applicative (cat (a2, b))) => cat a2 a -> cat b a1 -> cat (a2, b) (a, a1)
17:24:44 <TeachmeHaskell> Hello folkz
17:24:50 <hpc> @where lyah
17:24:51 <lambdabot> http://www.learnyouahaskell.com/
17:24:56 <hpc> :P
17:25:04 <TeachmeHaskell> lol
17:26:40 <Peaker> Saizan: something doesn't add up for me, f *** g -- the Applicative instead for "f" and "g" is different, and the result instance should be different (cat i1, cat i2, and result is cat (i1, i2)) but <$> and <*> implies all 3 should be same Applicative instance?
17:26:50 <Peaker> Saizan: s/instead/instance
17:27:23 <Peaker> oh, nm, I think I see why it works
17:27:49 <Saizan> you don't use liftA2 on f and g directly there
17:27:51 <Peaker> the <$> and <*> are in the (i1, i2) instance, and the arr fst and arr snd coerce f and g to be the right applicative instance :)
17:28:07 <Saizan> right
17:28:22 <hpc> don't you mean "yarr"?
17:30:41 <dibblego> is there a case for liftA2 /= liftM2 except for m=IO?
17:30:55 <Peaker> Saizan: is it possible to newtype a convertor that gives you the Arrow instance, lacking higher-ranked class contexts?
17:31:05 <Saizan> dibblego: are those different for IO?
17:31:12 <newsham>     No instance for (Show UTCTime)
17:31:27 <newsham> http://hackage.haskell.org/packages/archive/time/1.1.3/doc/html/Data-Time-Clock.html says there is a Show instance
17:31:33 <dibblego> oh wait, not even for IO
17:31:36 <Saizan> newsham: it's in another module
17:31:42 <newsham> what module is it in?
17:31:53 <Peaker> Saizan: instance (Category cat, forall a. Applicative (cat a)) => Arrow (SomeNewtype cat) where ... doh! no higher-ranked constainrs
17:31:57 <Peaker> constraints
17:32:03 <newsham> whats the recommended way to get the current time as some kinda integral?
17:32:05 <Saizan> newsham: iirc something mentioning Format
17:32:15 <Peaker> dibblego: I think if the monad/applicative laws are not broken, they are supposed to be guaranteed the same
17:32:24 <Saizan> ?hoogle getCurrentTime
17:32:24 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
17:32:24 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
17:32:32 <aavogt> Peaker: ZipList
17:32:45 <Peaker> aavogt: what about ZipList?
17:32:47 <dibblego> I think I am thinking of different functions, not lift*
17:33:11 <newsham> ok, Data.Time.Format gives me Show
17:33:26 <Peaker> aavogt: there's no appropriate Monad instance for finite ZipLists anyway -- so liftM2 would break the monad laws, no?
17:33:53 <Saizan> Peaker: you could do sort of like rmonad and use a gadt to pass the constraint
17:33:55 <aavogt> Peaker: some data has multiple acceptable Applicative instances, this means you can have Monad and Applicative instances be the same with respect to lift*n?
17:34:10 <newsham> ahh, getPOSIXTime works for me
17:34:11 <Peaker> Saizan: I guess I should sometime, I never fully understood rmonad
17:34:16 <Peaker> Saizan: would be good practice
17:35:11 <Peaker> aavogt: I think if they have multiple Applicative instances possible -- then they should make sure they give consistent instances for Monad and Applicative that don't make lift* behave differently
17:35:25 <Peaker> aavogt: that's why newtype, IMO, is a *good* thing -- it makes this kind of consistency possible and encourages it
17:35:31 <Peaker> (vs. manual instance selection/imports)
17:35:33 <newsham> ok, next question: why?  http://hpaste.org/40198/stuff
17:35:33 <aavogt> that's not guaranteed by any laws, no?
17:36:17 <Peaker> aavogt: I think there are laws binding the Applicative and Monadic behavior (probably you could say liftM2 == liftA2 is such a law :-) And if you break that law your instances are broken
17:36:29 <aavogt> besides the one you just made up   liftM2 = liftA2 where both are implemented
17:36:47 <aristid> newsham: is QuickTest.hs yours?
17:37:05 <Peaker> newsham: isn't the error self-explanatory?
17:37:14 <aavogt> Peaker: which ones imply liftM2 = liftA2?
17:37:35 <newsham> aristid: it happens with "cabal install crypto"
17:37:37 <newsham> not mine
17:37:58 <aristid> newsham: then the package is broken!
17:38:03 <aavogt> @docs Control.Monad
17:38:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
17:38:07 <Peaker> aavogt: I don't know which laws relate Applicative and Monad.. but there *should* be such laws, and they should definitely imply that
17:38:20 <aristid> aavogt: does it work only for ghc docs?
17:38:42 <Peaker> newsham: probably someone broke the PVP (Not that the PVP is a good solution, but it replaces false-pos+false-negs with false-neg only, which is nicer)
17:40:13 <newsham> isnt there a buildbot to catch these things?
17:40:40 <Peaker> it's a big build, newsham... waiting for it to build
17:41:04 <aavogt> aristid: it doesn't work for all modules on hackage
17:41:40 <aristid> @docs Data.Random
17:41:40 <lambdabot> Data.Random not available
17:41:55 <aristid> aavogt: does it work for those that hoogle supports?
17:42:05 <Peaker> newsham: same build error here
17:42:19 <aavogt> @help
17:42:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:42:26 <aavogt> @list
17:42:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:43:00 <newsham> isnt the error in quickcheck?
17:43:12 <aavogt> aristid: the source (you can darcs get repo containing that file) should be able to tell you
17:43:38 <newsham> oops, nevemrind, it includes its own QuickTes.ths
17:44:01 <newsham> lets see if i can help it along
17:44:10 <aristid> aavogt: maybe i'll look tomorrow.
17:45:29 <byorgey> zygoloid, copumpkin, quicksilver: just to clear up the confusion, I'm not working on idiom brackets, implicit or otherwise =)
17:45:56 <benmachine> I believe there's a law that if a type is a Monad and an Applicative, pure = return and ap = (<*>)
17:45:58 <byorgey> just on lifting things up to the type/kind level, and for that the curly braces will indeed be optional most of the time
17:46:07 <benmachine> to minimise surprises like liftM2 and liftA2 being different
17:47:04 <benmachine> http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Control-Applicative.html#1 "If f is also a Monad, define pure = return and (<*>) = ap."
17:49:04 <newsham> <$> = fmap
17:50:10 <aavogt> benmachine: that only works if you wrote the Monad instance first though :)
17:50:39 <benmachine> aavogt: I assume it just wants them equal, you're allowed to inline it or whatever
17:51:17 <JoeyA> Is there a GHC extension that, for all type signatures without accompanying bindings, automatically sets them to undefined?
17:51:23 <JoeyA> Mainly for writing stubs.
17:52:32 <aavogt> maybe you're allowed  .hs-boot files without corresponding definitions in real .hs files
17:54:00 <aavogt> -XQuasiQuotes could allow something like it with a bit of work and noise around your stubs
17:54:27 <JoeyA> I tried writing a stub in a file suffixed .hs-boot, but it doesn't let me off the hook.
17:54:33 <JoeyA> (it does the same thing as .hs does)
17:55:01 <newsham> ?info showHex
17:55:01 <lambdabot> showHex
17:55:16 * benmachine ponders an identity quasiquoter
17:55:27 <benmachine> you'd put [$id| at the top of the file
17:55:31 <benmachine> and |] at the bottom
17:55:43 <benmachine> and it'd turn the whole thing into a Q [Dec] and splice it
17:55:49 <benmachine> or
17:55:51 <benmachine> something
17:56:16 <aavogt> @hackage haskell-src-meta
17:56:17 <lambdabot> http://hackage.haskell.org/package/haskell-src-meta
17:56:26 <benmachine> aavogt: yes I know I maintain it :P
17:56:53 <benmachine> it doesn't do exactly that though, largely because there's no point whatsoever >_>
17:57:30 <aavogt> hmm, I have some patches for it... did you make any changes to Language.Haskell.Meta.Syntax.Translate?
17:57:45 <benmachine> uhm
17:57:48 <benmachine> very possibly
17:58:12 <benmachine> currently trying to get a patch for compatibility for GHC 6.10 sorted out
17:58:23 <benmachine> emailed the guy who wrote it a while back asking what's the deal and he hasn't responded
17:58:26 <JoeyA> hmm, maybe I can write a little script to throw in undefs.  I wonder if there's a Haskell package for parsing Haskell.
17:58:26 <aavogt> see http://code.haskell.org/~aavogt/haskell-src-meta/
17:58:48 <JoeyA> (to me, Haskell is a scripting language, as I have yet to learn Python or Perl to a serious extent)
17:59:25 <benmachine> oh hey I never announced version 0.1.1
17:59:32 <benmachine> maybe I won't bother, it wasn't that exciting
17:59:53 <benmachine> JoeyA: haskell-src-exts is the most commonly used one
18:00:31 <JoeyA> so the one on Hackage isn't the latest and greatest?
18:00:41 <JoeyA> (that is, haskell-src-exts)
18:00:44 <benmachine> JoeyA: huh?
18:00:53 <JoeyA> I was referring to "<aavogt> see http://code.haskell.org/~aavogt/haskell-src-meta/"
18:00:57 <benmachine> haskell-src-meta and -exts are different things, to clarify :)
18:01:05 <JoeyA> oh
18:01:18 <JoeyA> what's haskell-src-meta for?
18:01:31 <aavogt> that repo has some missing definitions I needed... making it more complete
18:01:43 <benmachine> converting a parse result from -exts into a Q Exp for use with TH
18:01:59 <JoeyA> ah
18:02:48 <benmachine> aavogt: I'm not much good at darcs, can I output all the patches in a repository easily?
18:02:57 <benmachine> in patch format I mean
18:04:06 <benmachine> oh, never mind
18:05:24 <Saizan> darcs send -O
18:05:41 <benmachine> aavogt: so mmorrow's last commit here is for 0.0.6, and yours are unreleased?
18:07:03 <aavogt> benmachine: I didn't bump any version numbers
18:07:25 <benmachine> aavogt: yeah but I just mean I'm trying to work out where your and my stuff diverged
18:07:42 <aavogt> though I guess mmorrow bumped the versions
18:07:52 <aavogt> what did you update from?
18:08:00 <benmachine> hackage, I think
18:08:09 <aavogt> there was a darcs repo on moonpatio.com
18:08:23 <benmachine> ok
18:08:28 <benmachine> hmm
18:08:33 <aavogt> with fixes for ghc-6.12
18:08:50 <benmachine> Saizan: thanks, but how do I send patches I didn't record?\
18:08:54 <benmachine> -\
18:09:27 <Saizan> ah, dunno, maybe darcs diff
18:11:22 <gwern> benmachine: well, darcs send should send any and all patches missing from the remote repo...
18:11:40 <benmachine> gwern: I'm basically just trying to dump all patches to a file
18:12:04 <benmachine> gwern: are you suggesting I make a remote repo with no patches in, or something?
18:12:13 <gwern> benmachine: well, that'd work too, I think
18:12:49 <JoeyA> Is there a function to pretty-print a ParseFailed?
18:13:00 <gwern> it's odd enough an approach I suspect #darcs would know a nicer way, but asking would be slower
18:13:58 <Igloo> benmachine: It doesn't have to be a remote repo
18:14:14 <benmachine> Igloo: well, "remote" :P
18:14:24 <benmachine> and yeah, I made an empty directory and darcs initted in it
18:14:27 <benmachine> seems to have worked
18:14:57 <EvanR> are type synonyms bad style
18:15:05 <benmachine> no
18:15:22 <EvanR> what about synonyming String to 20 different things
18:15:45 <EvanR> and using those types with string operations
18:15:49 <benmachine> well, that's a missed opportunity for static enforcement, but it's not terrible as such
18:16:20 <benmachine> type synonyms imo are good for documentation and clarity
18:17:56 <benmachine> if it makes sense to use your different type synonyms together with string operations, a newtype probably doesn't make sense
18:18:56 <EvanR> and what if its used exclusively with operations on that type synonym like an abstract data type
18:19:29 <benmachine> if it's being used abstractly it seems sensible to make it abstract
18:19:40 <EvanR> and a type synonym doesnt do that?
18:20:31 <EvanR> i guess the client, without knowing the implementation, could accidentally use it in a correct way and the compiler would never know
18:20:37 <EvanR> then if i change the implementation it would break
18:21:01 <EvanR> so newtype Type = Type String
18:21:52 <benmachine> EvanR: yeah, that's one concern, but it's also like
18:22:08 <benmachine> if you have stalkPerson :: Name -> Address -> IO ()
18:22:19 <benmachine> and Name and Address are both type synonyms for the same thing
18:22:26 <benmachine> then getting them the wrong way around isn't an error
18:22:33 <benmachine> if they're newtypes it is
18:22:50 <EvanR> reversing the arguments to functions of the form Int -> Int -> Foo has concerned me for a while
18:22:56 <EvanR> people seem to think this isnt a big deal
18:23:52 <copumpkin> I like specific types where possible
18:24:12 <EvanR> when they really are supposed to be the same type, whatever it is, new types wouldnt help
18:24:27 <EvanR> i guess in that case should use named arguments
18:25:31 <benmachine> EvanR: it's not always a big deal. no-one worries people will get the parameters to 'div' wrong
18:26:16 <EvanR> we have grade school calculator language ingrained into our collective consciousness though
18:26:25 <EvanR> no way to screw it up
18:26:54 <EvanR> maybe f :: A -> A -> B isnt that common
18:28:29 <benmachine> @hoogle a -> a -> b
18:28:30 <lambdabot> Prelude asTypeOf :: a -> a -> a
18:28:30 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:28:30 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
18:28:30 <copumpkin> div :: Real -> NonZero Real -> Real; data NonZero a = NonZero (x :: a) (x /= 0)
18:28:35 <benmachine> um
18:28:39 <benmachine> that was not helpful
18:28:56 <benmachine> copumpkin: uhm, yes
18:28:57 <EvanR> NonZero Real
18:29:07 <EvanR> can it be done
18:29:10 <copumpkin> well I guess I'm talking about (/)
18:29:10 <JoeyA> In haskell-src-exts, what's the difference between Ident and Symbol?
18:29:14 <copumpkin> more than div :)
18:29:15 <benmachine> EvanR: that's a dependent type, I think
18:29:19 <copumpkin> yeah
18:29:35 <aavogt> JoeyA: probably the difference between    foo   and  +^&
18:29:40 <benmachine> JoeyA: I don't know why there need to be distinct types
18:29:47 <benmachine> given that the distinction can be inferred from the String
18:29:54 <benmachine> btyg
18:29:59 <JoeyA> You're right.
18:30:00 <JoeyA> thanks
18:30:11 <JoeyA> Possibly so it's easier to unparse.  I don't know, leave me alone!
18:30:12 <aavogt> for the same reason it's bad to mix up arguments
18:30:35 <JoeyA> hmm, can a function take + as an argument?
18:30:38 * JoeyA tests
18:30:41 <benmachine> (+)
18:30:57 <benmachine> > ap (+) succ $ 4
18:30:58 <lambdabot>   9
18:31:15 <JoeyA> @let apply2 (+) a b = a + b
18:31:16 <lambdabot>  Defined.
18:31:21 <JoeyA> > apply2 (*) 3 5
18:31:22 <lambdabot>   15
18:31:29 <JoeyA> yes, you can do that.
18:31:37 <JoeyA> I look forward to abusing it.
18:31:38 <EvanR> > let op o a b = o a b in op (+) 3 4
18:31:38 <lambdabot>   7
18:31:43 <EvanR> ok mine was useless ;)
18:31:44 <copumpkin> @src on
18:31:44 <lambdabot> (*) `on` f = \x y -> f x * f y
18:31:50 <copumpkin> similar
18:32:22 <EvanR> JoeyA: plus is a function, were in functional programming, functions are first class
18:32:53 <JoeyA> I was just a little surprised the syntax would let you do that.
18:32:56 <EvanR> > foldr (+) 0 [1,2,3,4,5,6]
18:32:57 <lambdabot>   21
18:32:59 <JoeyA> Well, not really, but it never crossed my mind.
18:33:42 <EvanR> someone help me
18:33:50 <JoeyA> hmm?
18:34:05 <JoeyA> with?
18:34:40 <EvanR> its a webapp, we can think of the server response as a function of the database and the request uri, but do we want to write it like that or using imperative 'write to the fcgi channel the response line by line' :(
18:35:11 <EvanR> (at least with GET)
18:36:02 <JoeyA> I'm at a similar crossroads with something I'm implementing, so I'm not entirely sure I can give you insight.
18:36:31 <JoeyA> In particular, I want to do various operations on an archive containing meta information and hashes of a filesystem.
18:36:46 <Twey> Go pure, but implement it as an IO wrapper that they can choose not to use?
18:36:58 <EvanR> they?
18:36:59 <JoeyA> Currently, it's a big mess because I'm abstracting the archive DB with functions that do huge things
18:37:07 <Twey> End-users in general :þ
18:37:13 <JoeyA> like "find groups of files with duplicate hashes"
18:37:15 <EvanR> hmm im writing it for myself
18:37:28 <Twey> The developer and the end-user need not be distinct
18:37:31 <JoeyA> same here
18:37:42 <Twey> (code tends to be better if you assume they're not)
18:37:44 <EvanR> JoeyA: 'do huge things' bad
18:37:56 <EvanR> 'compute huge views' good
18:38:04 <EvanR> Twey: right...
18:38:28 <EvanR> i dont understand what you mean by implement it as an IO wrapper they can choose not to use
18:39:08 <JoeyA> I'm considering building a DB combinator framework just for me (well, for my program).
18:39:08 * hackagebot hmatrix-gsl-stats 0.1.2.6 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.6 (VivianMcPhail)
18:39:13 <JoeyA> HaskellDB keeps turning me off.
18:39:33 <EvanR> JoeyA: im thinking thats probably been done more than once
18:39:35 <EvanR> at some point
18:39:49 <EvanR> im using SQL directly and as sanely as possible
18:39:59 <JoeyA> one reason I want to do it myself is so I can have the flexibility I need.
18:40:09 * hackagebot hstatistics 0.2.2.5 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.5 (VivianMcPhail)
18:40:19 <EvanR> the point of haskell libraries is that they are flexible
18:40:26 <EvanR> because its functional
18:40:42 <JoeyA> For instance, I'm getting files grouped by size, but then sorting them
18:41:11 * hackagebot hsignal 0.1.2.5 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.1.2.5 (VivianMcPhail)
18:41:17 <JoeyA> SQLite doesn't really let you do much with entire groups other than fold them with a fixed set of aggregates.
18:41:53 <EvanR> grouped by size?
18:42:18 <EvanR> Twey what did you mean!
18:42:28 <JoeyA> Well, if you get files grouped by size, then only take the groups with count > 1, you know which ones to hash if you're looking for duplicate files.
18:43:09 <EvanR> just hash them without worrying about size
18:43:18 <JoeyA> that takes longer
18:43:24 <JoeyA> unless you want all the files hashed, of course.
18:43:30 <EvanR> you dont?
18:43:34 <JoeyA> depends
18:43:42 <JoeyA> maybe I want to remove hardlinks today.
18:43:50 <JoeyA> err, hardlink duplicates together.
18:44:01 <JoeyA> Tomorrow, I might want to hash all the files so I can verify them later.
18:44:21 <JoeyA> but my queries are getting big and confusing, and aren't quite picking up after themselves.
18:44:32 <JoeyA> I need to refactor.
18:44:38 <EvanR> ideally queries dont alter anything
18:45:04 <JoeyA> right, but for the case of updating hashes, I need to step through a result and update things.
18:45:25 <JoeyA> I'm getting tired of writing these big queries that all resemble each other.
18:45:28 <EvanR> now it sounds untenable ;)
18:45:35 <JoeyA> err, 2 queries that resemble each other.
18:46:19 <JoeyA> My project has ceased to be fun to work on.  I'm trying to address that.
18:46:48 <EvanR> simplify!
18:52:36 <inimino> JoeyA ⋱ I think I wanted to write that same program... what does yours do?
18:53:14 <JoeyA> Reads all the stat information of a file tree into a SQLite file, finds files with the same size and hashes them.
18:53:18 <JoeyA> (with SHA1)
18:54:07 <JoeyA> The next step is to list files with the same hash and hard-link them (which I call "tangling")
18:54:56 <JoeyA> and also to have an operation to weed out hardlinks by copying (which I call "untangling")
18:55:57 <JoeyA> As well as take the contents of two archives on two disks, find duplicates across, and make it so both archives replicate each other.
18:59:33 <inimino> JoeyA ⋱ Sounds good.
18:59:59 <inimino> I actually wrote something that did that, using `find` and SQLite a while ago, but never built more than that on top of it.
19:04:17 <benmachine> @hoogle StateR
19:04:17 <lambdabot> No results found
19:04:33 <benmachine> http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Control-Applicative.html#1 <-- why are instances for StateL, StateR, and Id showing up here?
19:05:56 <benmachine> or possibly, why aren't they linked
19:10:48 <inimino> JoeyA ⋱ this is something of what I had in mind: http://boshi.inimino.org/3box/inimino/projects/nuin/README
19:11:31 <inimino> JoeyA ⋱ basically a set of tools out of which things like Unison or rsync or ... could be easily composed
19:17:23 <JoeyA> right, same basic idea
19:17:37 <JoeyA> I think hardlinking is a good first step, since it's entirely automatic.
19:17:51 <JoeyA> Also, the name I'm working with, which I really like, is "packrat" :-)
19:19:14 <thezboe> Hey JoeyA, thanks for all the help yesterday
19:19:24 <JoeyA> no problem.
19:21:53 <JoeyA> makeSet :: (Ord a) => [a] -> [a]; makeSet = sort . foldr (\x xs -> x : filter (/= x) xs) -- nice and simple, but O(n^2)
19:22:24 <JoeyA> (just summarizing the discussion last night)
19:22:40 <benmachine> JoeyA: no-one suggested map head . group . sort?
19:22:52 <JoeyA> it was a homework assignment
19:23:07 <benmachine> well, something isomorphic to that?
19:23:12 <JoeyA> I don't think group was allowed.
19:23:16 <JoeyA> I forget
19:23:54 <JoeyA> Anyway, the best way to build an Ord variant of nub, in my opinion, is to use a Data.Set and test for membership per item insertion.  That way, it's lazy, but it's also efficient.
19:24:17 <benmachine> test for membership per item insertion? why bother?
19:24:24 <benmachine> oh you mean
19:24:29 <JoeyA> err, per emit.  Whatever
19:24:31 <benmachine> hmm
19:24:41 <JoeyA> imma make a foldr one-liner
19:24:44 <benmachine> I suppose that'd work
19:25:10 <JoeyA> :t Set.empty
19:25:11 <lambdabot> Couldn't find qualified module.
19:25:15 <benmachine> :t S.empty
19:25:15 <JoeyA> :t Data.Set.empty
19:25:15 <lambdabot> forall a. S.Set a
19:25:16 <lambdabot> forall a. S.Set a
19:25:18 <JoeyA> ah, cool
19:25:31 <JoeyA> > 3 `S.member` S.fromList [1,2,3]
19:25:32 <lambdabot>   True
19:26:31 <mtnviewmark> > let ordNub  = Set.toList . Set.fromList in ordNub "now and then we come to an understanding"
19:26:32 <lambdabot>   Not in scope: `Set.toList'Not in scope: `Set.fromList'
19:26:47 <mtnviewmark> fie... 
19:26:52 <JoeyA> That's not lazy.
19:27:08 <JoeyA> > (S.toList . S.fromList) [1..]
19:27:12 <lambdabot>   mueval-core: Time limit exceeded
19:27:25 <JoeyA> > nub [1..]
19:27:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:27:38 <benmachine> anything that gives you a sorted list can't be lazy
19:28:00 <JoeyA> it doesn't have to
19:28:04 <JoeyA> Just items removed.
19:30:26 <copumpkin> GHC's sort is as lazy as it can be though
19:30:57 <JoeyA> doesn't help in the case of nubbing
19:31:05 <JoeyA> > map head . group . sort $ [1..]
19:31:13 <lambdabot>  Terminated
19:31:14 <copumpkin> yeah
19:33:12 * benmachine wonders whether someone could write a spine-lazy sort
19:33:25 <benmachine> > length . sort . replicate 4 $ undefined
19:33:28 <lambdabot>   *Exception: Prelude.undefined
19:37:33 <mtnviewmark> > let ordNub = catMaybes . Prelude.map fst . scanl (\(_,s) x -> if member x s then (Nothing, s) else (Just x, Data.Set.insert x s)) (Nothing, empty) in take 10 $ ordNub [1..]
19:37:34 <lambdabot>   Not in scope: `member'Not in scope: `Data.Set.insert'Ambiguous occurrence `...
19:38:10 <mtnviewmark> > let ordNub = catMaybes . map fst . scanl (\(_,s) x -> if S.member x s then (Nothing, s) else (Just x, S.insert x s)) (Nothing, empty) in take 10 $ ordNub [1..]
19:38:11 <lambdabot>   Ambiguous occurrence `empty'
19:38:11 <lambdabot>  It could refer to either `Control.Applicative...
19:38:19 <mtnviewmark> > let ordNub = catMaybes . map fst . scanl (\(_,s) x -> if S.member x s then (Nothing, s) else (Just x, S.insert x s)) (Nothing, S.empty) in take 10 $ ordNub [1..]
19:38:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:38:35 <benmachine> very good
19:38:47 <mtnviewmark> a bit ugly written in that form
19:38:55 <mtnviewmark> I'd of course use a where clause in a file
19:39:20 <mtnviewmark> even then, there looks to be a useful utility function inside there that could be exposed for Set
19:39:35 <mtnviewmark> oh look... bedtime for the kids waaaaaay over due
19:39:37 <mtnviewmark> be back laters
19:41:09 <JoeyA> > let ordNub = catMaybes . map fst . scanl (\(_,s) x -> if S.member x s then (Nothing, s) else (Just x, S.insert x s)) (Nothing, S.empty) in ordNub [1..]
19:41:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:41:16 <JoeyA> yay, it's lazy!
19:41:39 <JoeyA> That's pretty cool.
19:48:12 <sy> howdy
19:50:08 <mtnviewmark> catMaybes is one of my favorite functions
19:50:16 <copumpkin> meow
19:50:47 <mtnviewmark> data Cat a = Purr | Meow a
19:50:59 <benmachine> woo, I defined a sort function such that length (sort xs) is O(n)
19:51:08 <benmachine> or, I think it is
19:52:02 <PirateUnderwear> Hey guys, what is `mod`?
19:52:36 <benmachine> PirateUnderwear: a `mod` b = a - b * (a `div` b)
19:52:40 <benmachine> more or less
19:52:53 <PirateUnderwear> Oh thanks.
19:52:54 <benmachine> it's a bit like, remainder when divided by
19:53:23 <PirateUnderwear> Oh, bingo. I am reading the learnyouahaskell and figured so.
19:54:31 <PirateUnderwear> I need to save that in my notes. :)
19:54:44 <ManateeLazyCat> Wow, "extract - displays meta-data from files of arbitrary type"....
19:56:34 <ManateeLazyCat> Have any want binding libextractor-dev ?
19:57:28 <adnap> How do I get the remainder for two floating point numbers?
19:58:00 <ManateeLazyCat> Program extract can pick-up meta-data from "HTML, PDF, PS, OLE2
19:58:01 <ManateeLazyCat>  (DOC, XLS, PPT), OpenOffice (sxw), StarOffice (sdw), DVI, MAN, MP3 (ID3v1 and
19:58:01 <ManateeLazyCat>  ID3v2), OGG, WAV, EXIV2, JPEG, GIF, PNG, TIFF, DEB, RPM, TAR(.GZ), ZIP, ELF,
19:58:01 <ManateeLazyCat>  REAL, RIFF (AVI), MPEG, QT and ASF."
19:58:17 <ManateeLazyCat> Looks exciting to me .... :)
19:59:02 <Nereid> adnap: can you divide and then apply snd.properFraction
19:59:03 <Nereid> ?
19:59:06 <PirateUnderwear> I am loving Haskell so far. It seems great to learn.
19:59:51 <ManateeLazyCat> Please let me if anyone have work on libextractor, to avoid duplicate work....
20:00:16 <adnap> Nereid: I dont know.  Basically I want a function x such that 361.0 `x` 360.0 = 1.0.
20:00:46 <adnap> Nereid: Or 1.2 `x` 1.0 = 0.2
20:02:06 <ManateeLazyCat> Think about this, after i binding libextractor, you can use same interface fetch meta-data from *so many* format.... include audio, image..........
20:02:06 <Nereid> so maybe a `x` b = b * snd (properFraction (a/b)) or something
20:03:10 <Nereid> > let a `x` b = b * snd (properFraction (a/b)) in 30 `x` 12.5
20:03:11 <lambdabot>   4.999999999999999
20:03:30 <tommd> > nub it
20:03:31 <lambdabot>   Not in scope: `it'
20:03:43 <tommd> > nub "4.999999999999999"
20:03:44 <lambdabot>   "4.9"
20:04:03 <tommd> I always wondered if lambdabot had an "it"
20:04:15 <c_wraith> > nub . show $ (pi :: CReal)
20:04:17 <lambdabot>   "3.145926870"
20:05:50 <medfly> > nub "44.3
20:05:51 <lambdabot>   <no location info>:
20:05:51 <lambdabot>      lexical error in string/character literal at end o...
20:05:52 <medfly> > nub "44.3"
20:05:53 <lambdabot>   "4.3"
20:06:11 <tommd> > nub "lambdabot"
20:06:12 <lambdabot>   "lambdot"
20:06:13 <Nereid> > nub (repeat 'x')
20:06:19 <lambdabot>   mueval: ExitFailure 1
20:06:28 <ManateeLazyCat> From libextractor-dev's depend, i doubt libextractor use other library's code, and not develop itself...
20:06:30 <Nereid> > head . nub$ (repeat 'x')
20:06:31 <lambdabot>   'x'
20:07:16 <shachaf> Hmm, I thought lambdabot's show was smarter.
20:07:39 <tommd> "show" wasn't used in the above.
20:08:31 <shachaf> tommd: How does it turn a string into a displayed string?
20:08:34 <tommd> > head . nub . drop 1. show . repeat $ 'x'
20:08:35 <lambdabot>   'x'
20:08:55 <ManateeLazyCat> http://www.gnu.org/software/libextractor/extractor.html
20:09:13 <shachaf> tommd: Sure, but show is used in sending the value to IRC. I thought that it showed whatever it could before the computation timed out.
20:09:15 <tommd> That isn't where the problem was.
20:10:01 <shachaf> Where was the problem, then?
20:10:28 <EvanR> > show "\"hey\""
20:10:29 <lambdabot>   "\"\\\"hey\\\"\""
20:10:34 <EvanR> \o/
20:10:45 <shachaf> > fix show
20:10:47 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
20:10:56 <tommd> I was thinking there must be a lazyness leak somewhere in Lambdabot, but that code is so simple it doesn't make sense.
20:11:22 <tommd> Perhaps showing a string partially is a problem, I know it's "show" on numbers is fine.
20:11:29 <tommd> and non-Char lists.
20:11:49 <EvanR> > let x = 'a':x in x
20:11:50 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
20:11:58 <shachaf> tommd: Well, it was just show on a string that whose tail was _|_.
20:12:00 <tommd> EvanR: Nope, not there.
20:12:05 <EvanR> whats the problem?
20:12:13 <ManateeLazyCat> Looks GNU libextractor worth to binding... 
20:12:18 <tommd> EvanR: See Nereids code above.
20:12:24 <shachaf> > show $ 'x' : undefined
20:12:25 <lambdabot>   "\"x*Exception: Prelude.undefined
20:12:32 <tommd> Why did mueval not like the first?
20:12:34 <shachaf> > show $ 'x' : fix id
20:12:35 <EvanR> nub (repeat 'x') ?
20:12:38 <lambdabot>   mueval-core: Time limit exceeded
20:12:45 <EvanR> nub is strict
20:12:50 <shachaf> tommd: Because the entire computation timed out. It tries to show the first n characters.
20:13:04 <shachaf> > head . nub $ repeat 'x'
20:13:06 <lambdabot>   'x'
20:13:17 <tommd> ahh, so lambdabot doesn't show less than some 'n' chars? nm
20:13:20 <EvanR> @src nub
20:13:20 <lambdabot> nub = nubBy (==)
20:13:58 <shachaf> tommd: Well, it tries to, and times out trying to show the second one.
20:14:01 <EvanR> > (take 9) . nub $ repeat 'x'
20:14:06 <lambdabot>   mueval: ExitFailure 1
20:14:18 <EvanR> > (take 1) . nub $ repeat 'x'
20:14:19 <lambdabot>   "x"
20:14:22 <EvanR> > (take 2) . nub $ repeat 'x'
20:14:27 <lambdabot>   mueval: ExitFailure 1
20:14:36 <EvanR> @src take
20:14:36 <lambdabot> take n _      | n <= 0 =  []
20:14:36 <lambdabot> take _ []              =  []
20:14:36 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:14:36 <shachaf> EvanR: That's the most reasonable behavior for nub.
20:15:34 <EvanR> after learning haskell i started hearing people use the term 'de-duping' and 'de-duplicating'
20:15:39 <EvanR> im like... nub?
20:16:03 <PirateUnderwear> I'm a Haskell nub! :)
20:16:33 <JoeyA> > fix nub
20:16:37 <lambdabot>   mueval-core: Time limit exceeded
20:17:00 <amerine> I pronounce nub lit tub and hub. I prefer noob.
20:17:20 <JoeyA> Same here, but sometimes, people spell it nub instead of noob.
20:17:21 <EvanR> tube, hube
20:17:41 <EvanR> noob newb nube
20:17:50 <monochrom> I'm a haskell nut.
20:17:57 <EvanR> nute
20:18:07 <PirateUnderwear> I always say Pigeon Noob.
20:18:08 <PirateUnderwear> :)
20:18:30 <EvanR> UnderwearPirate would have been funnier
20:18:54 <PirateUnderwear> EvanR: I wanted to say PiratedUnderwear but it wouldn't allow that long of a name.
20:19:02 <EvanR> lol
20:19:18 <EvanR> Underwarez
20:19:23 <PirateUnderwear> Yarr, ye' steel mi' booty!
20:19:26 <PirateUnderwear> lol..
20:19:56 <PirateUnderwear> EvanR: lmao
20:20:29 <EvanR> me too. me too.
20:20:41 <PirateUnderwear> I am enjoying Haskell even though I just started learning it. 
20:21:11 <JoeyA> I wonder if this will even be possible to implement:
20:21:12 <JoeyA> filterSet :: (Tuple a) => DB (a -> Bool) -> DB (Set a) -> DB (Set a)
20:21:29 <JoeyA> DB a means an expression in the database yielding a
20:21:45 <EvanR> JoeyA: i hope you use relational algebra ;)
20:21:51 <PirateUnderwear> EvanR: Which editor do you use?
20:22:09 <JoeyA> Notice how DB (a -> Bool) yields a function.  It couldn't actually be invoked, since programming languages tend to keep their functions to themselves.
20:22:10 <EvanR> vim
20:22:28 <JoeyA> But I'm considering using -> as a sort of phantom constructor.
20:22:37 <PirateUnderwear> I am a emacs user but I'm tempted to switch to vim for Haskell.
20:22:48 <EvanR> emacs is more popular for haskell i think
20:23:08 <Nereid> I'm a vim user and I'm not tempted to switch to emacs
20:23:12 <Nereid> :<
20:23:15 <PirateUnderwear> Nereid: lol
20:23:28 <ManateeLazyCat> True haskeller use Vi or Emacs. :)
20:23:46 <Nereid> I never learned how to use emacs.
20:23:52 <Nereid> other than how to exist
20:23:53 <Nereid> exit*
20:24:01 <PirateUnderwear> EvanR: I'm only tempted because I have this vi/vim book sitting on my desk calling my name. 
20:24:23 <Nereid> who needs books? I learned vim from vimtutor and the help pages. ;)
20:24:37 <Nereid> nah, books are probably good
20:24:43 <PirateUnderwear> Nereid: Well I don't like to waste books that I purchased.
20:24:46 <PirateUnderwear> lol
20:24:48 <Nereid> lol
20:24:57 <EvanR> rofl
20:25:04 <Nereid> I can't remember how long it took me to get proficient at using vim.
20:25:15 <EvanR> im still not
20:25:21 <Nereid> maybe a couple weeks or something
20:25:27 <EvanR> ._.
20:25:40 <Nereid> I guess you just sort of have to force yourself to use it, in the beginning
20:25:48 <EvanR> ive been using it for 10 months
20:25:51 <Nereid> :<
20:25:51 <JoeyA> Hmm, if I continue abusing types, I could do filterSet :: DB (a -> Bool) -> DB ([a]) -> DB ([a])
20:25:54 <PirateUnderwear> I'm fairly fast in emacs, it's just the system admin part that is bothering me with switching to vi/vim.
20:26:00 <JoeyA> such that [a] corresponds to a set
20:26:03 <EvanR> Db [a]
20:26:13 <EvanR> conserve parentheses
20:26:17 <JoeyA> oops
20:26:20 <JoeyA> good point
20:26:21 <mm_freak> besides quickcheck and smallcheck, what other testing libraries should i have a look at?  which ones support IO, too?
20:26:21 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
20:26:36 <dibblego> mm_freak, were you recently complaining about test-framework?
20:26:41 <Nereid> JoeyA: it's sufficient for DB to be an applicative functor I guess
20:26:46 <JoeyA> I just hope I can get GHC and the world to appreciate this as much as I do :-)
20:26:58 <mm_freak> dibblego: nope
20:27:04 <JoeyA> I considered that as a possible option.
20:27:09 <dibblego> mm_freak, oh right, someone was, but I forget who
20:27:13 <JoeyA> Right now, I'm just toying with type signatures.
20:27:17 <PirateUnderwear> I wish Emacs worked nicely out the box with Haskell. ::sigh:: Going to have to learn Lisp after this.
20:27:49 <EvanR> JoeyA: theres some pretty nice things you can do with just functions
20:28:11 <pikhq> PirateUnderwear: Just install haskell-mode; it's the only way to write Haskell.
20:28:52 <PirateUnderwear> pikhq: Alright. I will have to google for it.
20:28:59 <abbe> One Haskell Way!! :)
20:31:42 <mm_freak> dibblego: currently i don't use any testing packages, but i'd like to
20:32:12 <dibblego> mm_freak, I find test-framework very useful, but someone recently complained and I don't understand why
20:32:38 <mm_freak> thank you, i'll take a look at it
20:47:22 <mjrosenb> ps-auxw: assuming that you change the indentation style back to the old default.
20:49:21 <dibblego> why aren't functions like filter written using filterM in Identity?
20:51:00 <mjrosenb> dibblego: doesn't Identity still need a constructor?
20:51:06 <aavogt> dibblego: it's prettier as-is
20:51:10 <dibblego> sure it has one
20:51:11 <aavogt> newtype, mjrosenb
20:51:12 <tommd> dibblego: Is this inspired by the talk on monadic functions for containers?
20:51:21 <dibblego> tommd, oh?
20:51:28 <tommd> I take that as a no.
20:51:39 <dibblego> perhaps it is, but I am unaware of this talk
20:51:48 <tommd> talk == discussion on l@h.o
20:51:51 <dibblego> "too ugly" is the only reason I can think of
20:52:41 <tommd> "too ugly" as in Prelude must import Control.Monad and Control.Monad already imports Prelude.
20:52:48 <tommd> @hoogle filterM
20:52:49 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
20:52:49 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
20:52:54 <tommd> Yeah, filterM is Control.Monad.
20:53:55 <aavogt> perhaps there are performance considerations for some haskell implementations
20:54:38 <medfly> @src (==)
20:54:38 <lambdabot> x == y = not (x /= y)
20:54:46 <medfly> kinda like that
20:55:08 <tommd> aavogt: Yeah, but human-executed-Haskell (HEH) is always slow, so who really cares?
20:56:21 <aavogt> tommd: I mean that a compiler that doesn't specialize to Identity may not know you can reorder some evaluation
20:58:34 <mm_freak> tommd: Prelude can reexport from Data.List, which in turn depends on Control.Monad
20:59:00 <aavogt> there are reasons to write everything monadic here http://www.cs.kuleuven.be/~toms/Research/papers/aosd2010.pdf
21:01:01 <PirateUnderwear> What is the "<-" in this list? [x*2 | x <- [1..10]]
21:01:04 <EvanR> so function "div" would conflict with Prelude
21:01:07 <EvanR> now what
21:01:19 <EvanR> its the most used element in html
21:01:22 <Zao> PirateUnderwear: Part of a "list comprehension"
21:01:28 <Zao> EvanR: div' :D
21:01:34 <EvanR> heh
21:01:35 <mm_freak> PirateUnderwear: it binds the elements of [1..10] to the name 'x'
21:01:38 <Zao> EvanR: Or qualify the prelude one.
21:01:39 <PirateUnderwear> Zao: Yeah but what is it actually doing.
21:01:43 <PirateUnderwear> mm_freak: Thanks.
21:01:49 <EvanR> Prelude.div
21:01:53 <Zao> PirateUnderwear: Division, integral, truncate towards zero.
21:02:04 <Zao> Err, nevermind.
21:02:05 <PirateUnderwear> Zao: Thanks. :)
21:02:07 <Zao> Mixing you people together :D
21:02:11 <PirateUnderwear> lol
21:02:24 <EvanR> do i look like pirate underwear to you
21:02:25 <mm_freak> PirateUnderwear: btw, higher order functions are much nicer usually
21:02:32 <mm_freak> > map (*2) [1..10]
21:02:33 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:03:01 <PirateUnderwear> mm_freak: Looks more "elegant" :)
21:03:27 <EvanR> > [1..10] >>= (*2)
21:03:28 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
21:03:28 <lambdabot>    arising from a use...
21:03:30 <mm_freak> PirateUnderwear: yes, and it's also more composable
21:03:38 <mm_freak> EvanR: (return .)
21:03:48 <PirateUnderwear> Is the pipe flowing right to left? Seems a little backwards in flow in my head. [x*2 | x <- [1..10]]
21:03:51 <EvanR> > liftM (*2) [1..10]
21:03:52 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:03:59 <mm_freak> > [1..10] >>= return . (*2)
21:04:00 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:04:15 <EvanR> yea
21:04:38 <mm_freak> PirateUnderwear: the statements after the pipe are evaluated from left to right, but the statement before the pipe is evaluated last
21:04:54 <PirateUnderwear> Man, Haskell seems so awesome.
21:05:04 <PirateUnderwear> mm_freak: Thanks for explaining. 
21:05:16 <mm_freak> you're welcome
21:05:41 <EvanR> funny haskell invented list comprehensions (maybe not), and they are 'sliced bread' in other languages, but used so little in haskell ;)
21:06:04 <mm_freak> EvanR: because in haskell in 99% of all cases there is a nicer, more elegant solution =)
21:06:29 <mm_freak> now consider that list comprehensions are considered something very elegant in other languages ;)
21:06:36 <EvanR> heh
21:07:09 <Guest22815> +1 what mm_freak said
21:07:10 <EvanR> so i have options... div' din did dii dib ...
21:07:16 <mm_freak> i like that list comprehensions are just syntactic sugar for regular haskell combinators
21:07:27 <ddarius> > 0x8e00 / 4096
21:07:29 <lambdabot>   8.875
21:08:20 <monochrom> older haskell code uses list comprehension a lot. see http://haskell.org/onlinereport/standard-prelude.html#sect8.2
21:08:59 <mm_freak> well, i always complained about the removal of monad comprehensions, but in fact i'd probably use do-notation anyway
21:09:17 <mm_freak> or raw combinators
21:09:23 <EvanR> RAW
21:09:32 <PirateUnderwear> mm_freak: Is Haskell very integrated with mathematics? I have been getting the assumption that it is math heavy based on random googling.
21:09:38 <mm_freak> raw as in 'non-sugared' =)
21:09:47 <monochrom> this is why the haskell committee insisted on non-strictness.
21:09:54 <EvanR> haskell is based on random googling?
21:10:04 <PirateUnderwear> EvanR: no :) 
21:10:07 <EvanR> we guess we are feeling lucky
21:10:11 <PirateUnderwear> lol!
21:10:11 <mm_freak> PirateUnderwear: haskell programs get much nearer to the mathematical notion
21:10:20 <EvanR> wow*
21:10:37 <mm_freak> (wow*)
21:10:50 <mm_freak> and of course (lol!)
21:11:03 <EvanR> (wow*) everquest
21:11:08 <monochrom> haskell is not integrated with mathematics. you don't get theorem proving or lesbegue integral for free.
21:11:10 <EvanR> mmo product
21:11:24 <monochrom> not even solving quintic equations.
21:11:25 <PirateUnderwear> mm_freak: I guess integrated was the word to use.
21:11:30 <PirateUnderwear> lol
21:12:12 <EvanR> haskell is deconvoluted with mathematics
21:13:03 <monochrom> Do not expect mathemagic like if you write code "0 * x" it would be optimized automatically optimized to "0"
21:13:22 <mm_freak> > let me:the:th:element:from:_ = repeat id; pick lol = (!! lol) in pick me the 5th element from [10, 20 ..]
21:13:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:13:23 <lambdabot>         against inferred type ...
21:13:23 <Draconx|Laptop> such an optimisation would be wrong, anyway.
21:13:28 <ddarius> nasm's align does the wrong thing and I'm eating page faults because of it.
21:13:48 <Draconx|Laptop> (assuming x has the most general type)
21:14:00 <PirateUnderwear> interesting
21:14:44 <EvanR> PirateUnderwear: im writing a webapp!
21:14:57 * EvanR breaks the mathematical tension
21:15:03 <PirateUnderwear> monochrom: I don't expect mathemagic. I was more assuming that the usage of mathematic equations were more rampant in Haskell. :)
21:15:33 <PirateUnderwear> EvanR: Lol nice. What specific type of application?
21:15:46 <EvanR> a forum
21:15:53 <PirateUnderwear> using a framework?
21:15:58 <EvanR> nope
21:16:18 <PirateUnderwear> nice
21:16:31 <PirateUnderwear> What type of database?
21:16:40 <mm_freak> PirateUnderwear: well, for one thing the equals sign really means an equation on haskell
21:16:47 <EvanR> a mycrappysql database
21:16:54 <mm_freak> that doesn't turn haskell into a CAS, of course
21:17:06 <EvanR> it would if it wasnt for IO
21:17:18 <PirateUnderwear> EvanR: haha... why not a NoSQL!?!? :)
21:17:19 <EvanR> pesky bastard
21:17:36 <EvanR> NoSQL is antirelational isnt it
21:17:41 <PirateUnderwear> yep
21:17:42 <mm_freak> EvanR: i don't think haskell could solve my quadratic equations, even if there were no IO =)
21:18:15 <PirateUnderwear> NoSQL is getting a lot of steam in Rails now it seems.
21:18:16 <EvanR> -b +/- sqrt(b^2 - 4ac) / 2a
21:18:54 <mm_freak> EvanR: but haskell won't do it
21:19:04 <EvanR> eh?
21:19:30 <EvanR> why not
21:19:32 <PirateUnderwear> mm_freak: Why is the equal really an equation in Haskell? (dumb question?)
21:19:34 <mm_freak> it's you as the programmer writing a program to do it, not the compiler solving (3*x^2 + 4*x - 7 = 0) for me ;)
21:19:38 * monochrom considers NoNoSQL
21:19:49 <djahandarie> monochrom, YesSQL?
21:19:54 <mm_freak> PirateUnderwear: in most languages '=' means assignment
21:19:58 <mm_freak> in haskell it means equation
21:19:59 <monochrom> not necessarily
21:20:18 <PirateUnderwear> monochrom: Yeah, but why the difference?
21:20:23 <EvanR> ExcludedMiddleSQL
21:20:29 <mtnviewmark> Wasn't that a Broadway musical: "No No SQL"?
21:20:34 <mm_freak> in fact there is no assignment captured in the language itself
21:21:05 <pikhq> PirateUnderwear: Because making assignment not a primitive has certain advantages.
21:21:15 <monochrom> I will have to examine NoSQL closely before I can tell what options there are in being anti-NoSQL.
21:21:17 <EvanR> PirateUnderwear: i think relational algebra and its corresponding idealized database language would have more popularity in the functional world
21:21:33 <pikhq> Aaaaand it's probably the most headache-inducing thing to have when combined with non-strict evaluation.
21:21:33 <EvanR> PirateUnderwear: anti relational sounds like its invented by people who cant stand object relational mappers
21:21:54 <pikhq> PirateUnderwear: Erm. Sorry, misgroked flow of conversation.
21:21:56 <monochrom> ah, NoSQL is oop? then there are many options.
21:22:00 <pikhq> This probably seems random.
21:22:03 <PirateUnderwear> lol its fine
21:22:43 <EvanR> pikhq <- randomIO :: IO IRC
21:23:11 <PirateUnderwear> EvanR: From what I know it's typically much faster and cheaper than the usual relational structures but slower at indexing large amounts of data. Not fully sure yet but that's what I got from them boasting it at the Ruby Conf.
21:23:28 <EvanR> ruby boasting about performance
21:23:36 <dibblego> @type arr
21:23:37 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
21:23:49 <MasseR> I was doing codechef practices yesterday, and was on the turbosort problem (which I solved with C with counting sort), and tried a similar approach as C, but arrays seemed to be _way_ slower. Did I use the arrays wrong, or are haskell arrays much slower than their C counterpart?
21:23:50 <EvanR> ruby just recently got first class functions i heard
21:23:57 <monochrom> ruby boasting about performancs of code written in c
21:24:27 <c_wraith> MasseR, If you were using immutable arrays, they are that much slower.
21:24:50 <MasseR> c_wraith: I tried with ST too but at that point I wasn't anymore sure what I was doing and got worse performance
21:24:55 <PirateUnderwear> I find Haskell much easier to read and pick up than Ruby so far. Far more elegant.
21:25:22 <EvanR> wait until you collide with monad transformers ;)
21:25:27 <monochrom> if you use ordinarily ST array (as opposed to unboxed ST array) there is still slowness.
21:25:30 <mm_freak> c_wraith: depends on the algorithm, for some algorithms a lazily evaluated Array can be very fast
21:25:47 <mm_freak> probably even faster than an equivalent STUArray algorithm
21:25:47 <PirateUnderwear> EvanR: :) I can't wait.
21:26:24 <EvanR> mm_freak: ah didnt think of that
21:26:57 <MasseR> So unboxed arrays would be the way to go?
21:27:16 <monochrom> worth a try.
21:27:38 <EvanR> MasseR: and compile with optimizations
21:27:44 <mm_freak> MasseR: what are you trying to do?
21:27:53 <mm_freak> ah, got it
21:27:55 <mm_freak> nevermind
21:34:28 <EvanR> string replace algorithm, now
21:36:58 <PirateUnderwear> Which type of enviroment is Haskell typically used in? Research.. or?
21:44:07 <EvanR> PirateUnderwear: i heard its used in financial stuff
21:45:10 <tommd> PirateUnderwear: Haskell is used in diverse situations.  EDSLs have became quite popular for controlling robotics and monitoring fly-by-wire systems,
21:45:10 <tommd> commercial users of many shapes and sizes exist and produce programs on contract (see Galois, Well Typed),
21:45:10 <tommd> web startups such as patch-tag and a few others exist, and yes - high velocity traders seem to like Haskell.
21:45:10 <tommd> A little googling can get you lots more info.
21:47:02 <PirateUnderwear> tommd: Yeah, I already googled a bit but I always like to ask people that normally use the technology.
21:51:03 <EvanR> its the gateway drug to theorem provers, logic programming, category theory, and burrito tutorials
21:52:07 <PirateUnderwear> And data collection on homo sapiens.
21:52:44 <PirateUnderwear> ::shakes fist at google analytics::
21:53:24 <rschnck> Where on Freenode would one ask about nondeterministic finite automaton?
21:53:40 <flippo> Google analytics is way underreporting the popularity of my personal vanity page.
21:53:55 <EvanR> here or #math?
21:54:13 <rschnck> Here it is.
21:54:23 <rschnck> It's a silly question and I'm *just* starting to read about them
21:54:43 <rschnck> But of a NFA has the empty string as a possible input in a state
21:54:51 <rschnck> That's simlpy a requirement to split, right?
21:55:40 <rschnck> Say the remainder of your string is 01101011 and the state you're in says if it's 0, go to state 3, if it's the empty string go to state 4
21:55:44 <rschnck> IT would split, right?
21:55:49 <rschnck> Since it's reading 0 at the moment.
21:59:56 <flux> rschnck, yes. in addition, splitting will occur if there are multiple destination nodes from a node with the same edge value
22:02:46 <ibro> anyone here programm in C++?
22:03:00 <Heffalump> only when desperate
22:03:23 <medfly> ibro, a lot ofpeople use C++ here - they complain about it all the time
22:03:47 <monochrom> int main(void) { return 0; }  /* c++ */
22:03:58 <dons> Heffalump: i hear ndm is big on c++ now :}
22:04:14 <ddarius> Interesting.
22:04:18 <dons> also: good for winning ICFP contests. with bits of Haskell.
22:04:41 <dons> ddarius: well, only joking. they have a fair bit at std. chartered to integrate with.
22:05:01 <dons> Heffalump: your absence is felt here at ICFP, btw. but congratulations again :)
22:06:26 <rschnck> flux: Ah, okay
22:06:49 <rschnck> flux: And one more question. {emptystring, abb} = {abb}, right?
22:06:57 <rschnck> Oh wait
22:07:53 <rschnck> Nevermind, it's not.
22:09:04 <monochrom> yeah, don't take "empty" too intuitively
22:09:07 <lpsmith> Just out of curiousity,  is there an "official" term for the set of memory reachable by the garbage collector?   I want to say "working set",  but that conflicts (somewhat) with the VM sense of the term.
22:10:30 <Heffalump> dons: thanks :-) sorry to miss it.
22:11:10 <Heffalump> what's the right place to discuss timing out a package maintainer?
22:13:27 <dons> Heffalump: libraries@
22:13:40 <dons> we discussed today sending a ping to everyone registered on hackage
22:13:43 <dons> find out who is alive.
22:13:56 <dolio> lpsmith: live memory?
22:14:12 <lpsmith> dolio, I suppose that works
22:14:43 <monochrom> live maintainers. (mix :) )
22:14:48 <lpsmith> :)
22:16:32 <dons> i pinged mmorrow. no one has heard from him in a long while.
22:16:36 <dolio> dons: By the way, if you're still updating uvector, you should take -fglasgow-exts out of the build options.
22:16:49 <dolio> It turns on MonoLocalBinds in GHC 7, which causes errors.
22:16:52 <dons> oh ghc 7
22:17:01 <dons> yes, we need to do some big time regression handling
22:17:05 <dons> prior to HP January
22:17:11 <dons> no base 3 breaks some things.
22:17:11 <lpsmith> dons, I thought I saw mmorrow on IRC at one point as matt_m or something like that,  but then he disappeared again :-(
22:17:26 <dons> lpsmith: hmm
22:17:26 <dolio> Yeah, that's another big problem.
22:17:51 <dons> thankfully we have the HP buffer window
22:19:28 <monochrom> "GHC 7. This updates every package. Again." :)
22:20:16 <dons> hackage and cabal is the buffer. users should be protected from the effects.
22:20:43 <dons> but yes, haskell is still changing, and we have this 3M lines of haskell on hackage to keep running
22:21:50 <kmc> i need some good examples of uses of SAT / SMT solvers
22:22:12 <lpsmith> I know that cabal and cabal-install tries to handle multiple versions of a given library gracefully,  but it my experience it doesn't seem to work very well :-/
22:22:33 <monochrom> http://alloy.mit.edu/alloy4/ uses a SAT solver.
22:22:36 <lpsmith> I haven't really dug into it though;  I usually just end up recompiling things until they work
22:24:32 <lpsmith> I've found that libraries that use different versions of base often cause problems (often unnecessarily)
22:25:01 <dons> kmc: equivalence checking of cryptol programs
22:25:23 <dons> http://www.galois.com/blog/2009/02/05/equivalence-and-safety-checking-in-cryptol/
22:25:58 <dons> full functional verification of cryptographic/dataflow programs
22:30:40 <tommd> Go breakage go!
22:33:09 <lpsmith> should we rename hackage "breakage" :-p
22:33:35 <Heffalump> dons: HTTP is the specific problem package for me
22:37:40 <Heffalump> dons: automatically mailing package maintainers when their latest version has a constraint lower than the latest version of a depdendency might be nice
22:43:50 <adnap> How do I get the remainder for floating point numbers (e.g. 1.2 `r` 1.0 = 0.2)?
22:46:17 <adnap> Ah, is it mod' in Data.Fixed?
22:46:50 <cizra> adnap: ummm. (1.2 / 1.0) - floor (1.2 / 1.0) should do the trick?
22:50:47 <lpsmith> > let r x y = x - y * floor (x / y)
22:50:48 <lambdabot>   not an expression: `let r x y = x - y * floor (x / y)'
22:50:56 <lpsmith> @def r x y = x - y * floor (x / y)
22:50:57 <lambdabot> Maybe you meant: bf do let
22:51:01 <lpsmith> @let r x y = x - y * floor (x / y)
22:51:03 <lambdabot>  Defined.
22:51:09 <lpsmith> r 1.2 1.0
22:51:13 <lpsmith> > r 1.2 1.0
22:51:14 <lambdabot>   Ambiguous occurrence `r'
22:51:14 <lambdabot>  It could refer to either `L.r', defined at <local...
22:51:18 <lpsmith> heh
22:51:22 <lpsmith> @let
22:51:23 <lambdabot>  Defined.
22:51:53 * ksf wants to see videos from the icfp
22:51:54 <lpsmith> @let rmod x y = x - y * floor (x / y)
22:51:56 <lambdabot>  Defined.
22:52:02 <lpsmith> > rmod 1.2 1.0
22:52:03 <EvanR> dammit ghc why cant you construct the infinite type
22:52:04 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:52:04 <lambdabot>    `GHC.Real.Integral a'
22:52:04 <lambdabot>   ...
22:52:11 <EvanR> cant be that hard
22:52:21 <lpsmith> :t rmod
22:52:22 <lambdabot> forall a. (RealFrac a, Integral a) => a -> a -> a
22:52:34 <lpsmith> @let
22:52:36 <lambdabot>  Defined.
22:52:42 <EvanR> runDb :: DbAccess a -> Db -> IO (Either SqlError a)
22:52:44 <lpsmith> @let rmod x y = x - y * fromIntegral (floor (x / y))
22:52:45 <lambdabot>  <local>:7:0:
22:52:46 <lambdabot>      Warning: Pattern match(es) are overlapped
22:52:46 <lambdabot>               In...
22:52:55 <lpsmith> @undef
22:53:08 <cizra> hmm. I know lambdabot can run quickcheck. We could test rmod this way.
22:53:36 <lpsmith> @let rmod' x y = x - y * fromIntegral (floor (x / y))
22:53:37 <lambdabot>  Defined.
22:53:49 <lpsmith> > rmod' 1.2 1.0
22:53:50 <lambdabot>   0.19999999999999996
22:54:00 <lpsmith> > rmod' 3.3 pi
22:54:01 <lambdabot>   0.1584073464102067
22:54:05 <lpsmith> > rmod' 10 pi
22:54:07 <lambdabot>   0.5752220392306207
22:55:37 <lpsmith> there might be a faster/more numerically accurate implementation,  but that's one way to do it
22:59:40 * hackagebot yices-easy 0.1 - Simple interface to the Yices SMT (SAT modulo theories) solver.  http://hackage.haskell.org/package/yices-easy-0.1 (KeeganMcAllister)
23:01:10 <cizra> Any gtk2hs users around? I'd gladly use some help with treeviews and liststores.
23:01:26 <lpsmith> > (3 % 5)
23:01:27 <lambdabot>   3 % 5
23:01:41 <lpsmith> > rmod' 10 (355 % 113)
23:01:43 <lambdabot>   65 % 113
23:03:14 <rschnck> #Haskell, I come with another comp sci question. If I wanted to write set of all binary strings except for 111, is there a "clever" way to do that using only regular operations? 
23:03:18 <rschnck> Rather than actually writing it all out?
23:05:46 <cizra> rschnck: That'd be an infinite list, I guess?
23:06:04 <rschnck> cizra: Yes, but not including 111.
23:06:09 <cizra> okay.. lemme think
23:06:10 <rschnck> It's a regular expression.
23:07:11 <cizra> Well, if you have a set of all binary strings, you can just say filter (/= "111") strings
23:07:17 <cizra> .. and due to laziness it actually should even work.
23:07:43 <rschnck> This isn't #Haskell ;_;
23:07:44 <cizra> ohh. Hm. If you meant how to express this in a regex, I don't know (=
23:07:48 <rschnck> It's just a comp sci question xD
23:07:51 <rschnck> I didn't know where else to ask
23:08:00 <rschnck> As in, I'm not trying to write a function for it
23:08:06 <rschnck> I've done that already
23:08:43 <cizra> Dunno.. doesn't sound like it'd be possible with a regex. Perl's regexps probably support that, though -- I know you can say "or" and "not" in grep.
23:09:00 <ksf> rschnck, http://www.youtube.com/watch?v=HyUK5RAJg1c
23:09:04 <EvanR> (fromList allBinaryStrings) \ "111"
23:09:24 <ksf> ...just construct the dfa.
23:09:37 <rschnck> I don't know if I'm allowed to.
23:09:54 <rschnck> The directions state: Describe the following languages with an expression that uses only the lan-
23:09:57 <rschnck> guage operations union, concatenation, and Kleene- applied to finite sets
23:09:59 <rschnck> of strings.
23:10:00 <ksf> start with " start -> 1 -> 1 -> 1 -> accept " and then add the rest, should be quite easy.
23:10:39 <rschnck> Right, I know how to do the DFA
23:10:46 <rschnck> I'm just not sure that it exists within the guidelines of the instructions
23:10:53 <ksf> yeah.
23:11:23 <ksf> thing is, generating regexen from dfas is MB-hard
23:11:38 <ksf> (that's problems which usually boggle the mind)
23:14:11 <ksf> ((0|1|11)0)*
23:14:14 <ksf> does that work?
23:14:43 * hackagebot plot 0.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1 (VivianMcPhail)
23:14:45 * hackagebot plot-gtk 0.1 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1 (VivianMcPhail)
23:15:41 <ksf> er no ((epsilon|1|11)0)*
23:19:12 <lpsmith> I found these types of regex problems frustrating
23:19:25 <lpsmith> easy to miss corner cases
23:23:22 <ksf> regexen usually suck
23:55:01 <MasseR> With strict bytearrays and unboxed arrays I got the counting sort down from 32 seconds to 22 seconds. Still not enough. Any more optimizing tips?
