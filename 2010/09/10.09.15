00:00:01 <kmc> of course GHC actually has a whole zoo of heap objects: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Typesofobject
00:00:54 <mamalujo> wow this is like among the largest channels in freenode
00:01:15 <horms> which is the largest?
00:01:20 <kmc> #ubuntu
00:01:32 <horms> lol
00:01:40 <kmc> ubuntu, gentoo, archlinux, python, debian, git, jquery, haskell, linux, c++, perl, vim
00:02:02 <mamalujo> arch also ? and git? impressive
00:02:55 <kmc> now if you ranked by ratio of IRC users to total users of the thing
00:03:00 <kmc> we would surely be #1
00:03:42 <geheimdienst> also we would be #1 if you ranked by civility, friendlytude, jargonophilia, and cleverness
00:03:56 <kmc> and by self-congratulation about being civil
00:04:04 <geheimdienst> and monad affinity, it goes without saying
00:04:13 <kmc> i dunno, i hear jquery is a monad
00:04:49 <geheimdienst> also we would be #1 for modesty
00:05:58 <mamalujo> well ubuntu seems to jump ahead of all of the competition , rest are not that far, less than +40% in case of #2
00:06:37 <mamalujo> sry, ignore the offtopic spam, my irssi was just slow in loading the nicklist when I entered
00:07:47 <kmc> :)
00:08:37 <kmc> Fermi problem: how many Haskell users are there in the world? and how many Ubuntu users?
00:10:44 <geheimdienst> ... and how many of them are intelligent lifeforms?
00:11:49 <geheimdienst> and why have we never met any extraterrestrials? extraterrestrial haskell users? extraterrestrial ubuntu users?
00:14:19 <mamalujo> google trends doesn't offer any help, thinks haskell is anyting but the programming language and is sill not even a blip in ubuntu queries
00:20:16 <objorn> Did kresmero ever post the link to the book which covers data structures using Haskell?
00:53:10 <luzm> Hi guys,
01:11:46 <Jonno_FTW> > 3 +4 
01:11:47 <lambdabot>   7
01:32:06 * hackagebot ghc-paths 0.1.0.7 - Knowledge of GHC's installation directories  http://hackage.haskell.org/package/ghc-paths-0.1.0.7 (SimonMarlow)
01:45:07 <earthy> objorn: you mean Chris Okasaki's thesis?
01:45:57 <c_wraith> Well, his book is better in that it actually has appendices containing haskell code.  the thesis, you have to translate it.
01:46:05 <c_wraith> The book also covers more topics.
02:01:53 <foo-nux> I recently got an error message about unexpected '}', or something like it. I fixed it correcting some indentation, what does haskell mean by '}'?
02:02:12 <foo-nux> i.e. I found ';' is a newline, and there was no literal '}' in the code.
02:02:38 <mm_freak> foo-nux: layout style is optional…  if you don't use layout, you can use the more common braces and semicolon style
02:03:03 <foo-nux> mm_freak, then what does a { stand for?
02:03:07 <mm_freak> > do { x <- [1,2,3]; y <- [x+1, x-1]; return (x+y) }
02:03:08 <lambdabot>   [3,1,5,3,7,5]
02:03:18 <Phyx-> more common for *other* languages
02:03:25 <foo-nux> ah
02:03:28 <foo-nux> kk, thanx
02:03:34 <mm_freak> Phyx-: more common in programming =)
02:03:53 <Phyx-> hehehe
02:04:01 <fasta> foo-nux, record-syntax
02:04:03 <foo-nux> thank you very much :)
02:04:10 <mm_freak> foo-nux: but that doesn't mean you shouldn't use layout, as it really yields better readable code
02:04:29 <mm_freak> also note that often even the braces are optional
02:04:35 <mm_freak> > do x <- [1,2,3]; y <- [x+1, x-1]; return (x+y)
02:04:36 <lambdabot>   [3,1,5,3,7,5]
02:04:49 <fasta> foo-nux, if you get an error about '{' that is not in your source code, I would consider it a compiler bug. 
02:05:07 <ivanm> IIRC, the braces are more there for when you're generating code and are too lazy to have your code generate proper layout
02:05:10 <ddarius> fasta: The Report defines layout in terms of translation to brackets.
02:05:22 <fasta> ddarius, so?
02:05:27 <ddarius> ivanm: There are people who use brackets exclusively.
02:05:37 <ivanm> true
02:05:46 <ivanm> and some of them have `;' at the beginning of lines
02:05:49 <mm_freak> yeah, my favorite example being:
02:05:50 <fasta> ddarius, if it is not in the source code, it should not be communicated to the user. 
02:05:51 <mm_freak> http://hackage.haskell.org/packages/archive/countable/0.1/doc/html/src/Data-Countable.html
02:05:58 * ivanm finds those bits of code harder to read
02:06:03 <mm_freak> i have to admit that this looks nice, but it may look nicer with layout
02:06:12 <ivanm> mm_freak: ugh
02:07:11 <mm_freak> this may also be related to syntax highlighting essentially fading out the braces and semicolons from your view
02:09:01 <FunctorSalad> ivanm: they also let you refactor with abandon
02:09:13 <FunctorSalad> though the result will be even more unreadable ;)
02:09:31 <FunctorSalad> OTOH, the layout can be autogenerated from such code
02:10:01 <ddarius> Yep, Ashley Yakeley is notorious for not using layout at all.
02:12:01 <pumpkin> ddarius: has he ever given a reason for that?
02:12:08 <kmc> no-layout is great for obfuscated code
02:12:27 <Cale> At least those are spaces and not tabs
02:12:41 <copumpkin> looking at his code, he seems to also enjoy not using some of the nicer helper functions like fromMaybe or maybe, instead preferring to pattern-match against every possible Just and Nothing in his code
02:12:42 <earthy> I've seen one good use of layout: in long do-blocks where an if takes care of an exceptional condition, the braces/colons can make it easier to follow the main flow
02:12:48 <earthy> of lack of layout that is
02:13:00 <Cale> I can imagine it being particularly useful for blind programmers.
02:13:29 <earthy> (because you can then layout the part after the else at the same indentation as the part before the if)
02:13:32 <c_wraith> using non-layout formatting is also good for turning your programs into ascii art
02:13:33 <mm_freak> copumpkin: i usually do pattern-matching, too…  i use the helper functions only in complicated code to make it simpler
02:13:41 <copumpkin> :O
02:13:56 <mm_freak> but if a function is essentially just a pattern match, i prefer to state it explicitly to make it more readable
02:14:00 <ddarius> Yes, blind programmers also don't use any layout.
02:14:06 <mm_freak> after all i always have to look up the type of 'maybe'
02:14:19 <mm_freak> i'm failing to memorize it
02:14:22 <ddarius> maybe is the fold for Maybe
02:14:43 <mm_freak> ddarius: hmm, that's a good mental model, thanks
02:14:51 <Cale> Now the question becomes whether Ashley Yakeley is secretly blind.
02:14:57 <ddarius> mm_freak: It's a fact.
02:15:08 <mm_freak> ddarius: facts can be mental models, too =)
02:15:42 * ddarius likes waltzes.
02:16:45 <copumpkin> mm_freak: either and maybe are both that kind of pattern :) and I think they're a lot more readable/flexible than adding more sytnax in, myself
02:17:03 <copumpkin> but it's taste, I guess :)
02:18:12 <kdvh> every explanation of monads seems to be different :/
02:18:34 <mm_freak> yeah, it's a matter of taste
02:18:45 <kmc> kdvh, "Monad" is the name of a very general API.  there's a lot of fairly unrelated things that use this API for many different purposes
02:18:53 <dobblego> many are detrimental to learning
02:18:57 <mm_freak> be right back
02:19:34 <kmc> it's hard to state concretely what property these things all share that makes "Monad" a suitable API for each
02:19:36 <kdvh> any explanation/tutorial that is recommended?
02:19:51 <ddarius> @where essence
02:19:51 <lambdabot> I know nothing about essence.
02:19:55 <ddarius> Curses
02:19:58 <kmc> kdvh, i recommend that you first get comfortable with some specific monads
02:19:59 <copumpkin> gas station!
02:20:03 <ddarius> @google "The essence of functional programming"
02:20:04 <lambdabot> No Result Found.
02:20:06 <kmc> Maybe, [], (Either e), State
02:20:12 <kmc> first using them, then implementing them yourself
02:20:16 <kmc> (it's a few lines of code for each)
02:20:44 <kmc> after a while you'll start to see what they have in common
02:20:58 <kdvh> I am pretty comfortable with Maybe and [], I'll start working on the others.
02:21:20 <copumpkin> I'm not really a fan of the Either e instance
02:21:28 <kmc> me either
02:21:31 <kmc> pun very much intended
02:21:33 <Phyx-> same here
02:21:42 <kmc> still, it's instructive
02:21:49 <kmc> kdvh, maybe read Typeclassopedia as well
02:22:01 <dobblego> kdvh, here is my explanation http://blog.tmorris.net/what-does-monad-mean/
02:22:06 <kdvh> kmc, alright, will do
02:22:16 <Phyx-> kdvh: pun indended again?
02:22:27 <kmc> heh ;P
02:22:32 <objorn> earthy: He mentioned Chris's Purely Functional Data Structures, but I was given the impression he was referring to something else. 
02:22:35 <kdvh> dobblego: ill give it a read
02:22:38 <mm_freak> kdvh: try the small and simple explanations, and if they don't help, you may try my tutorial, which is comparably long
02:23:01 <dobblego> kdvh, there is also video, feel free to ask questions
02:23:01 <kdvh> Phyx-, main-ly, yes :P
02:23:02 <mm_freak> kdvh: but the essence to understanding monads is understanding haskell's type system and the (>>=) combinator
02:23:32 <objorn> kremsera: Did you ever find the book you were referencing yesterday?
02:24:01 <kmc> kdvh, for the explanation of *why* every explanation of monads is different, see http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
02:24:23 <kdvh> alright
02:25:04 <kmc> '“Of course!” Joe thinks. “It’s all so simple now. The key to understanding monads is that they are Like Burritos. If only I had thought of this before!” '
02:27:34 <Ferdirand> so monads are like cars: fruitful in irrelevant analogies ?
02:28:57 <mm_freak> Ferdirand: more like car descriptions…  fruitful, as soon as you actually make a car, but not very fruitful by themselves
02:29:29 <copumpkin> monads are like taking a car apart and rebuilding it more simply
02:29:35 <copumpkin> ;)
02:29:47 <c_wraith> you mean without the pieces that make it work?
02:29:50 <c_wraith> that's simpler!
02:29:58 <mm_freak> well, the main advantage of monads is that they allow you to write car description transformations easily
02:30:03 <copumpkin> no, the bare minimum that works :)
02:30:16 <mm_freak> without actually needing a car
02:30:18 <copumpkin> actually, that's more of a comonad
02:30:31 <copumpkin> a carmonad, if you will
02:30:38 <mm_freak> hehe
02:31:15 <kmc> monads are like taking apart a car by removing one piece per day, grinding it into a fine powder, mixing it with soup, and eating it
02:31:43 <c_wraith> monads are like >>=
02:31:50 <Adamant> monads are like monoids that are in the category of endofunctors.
02:31:52 <kmc> that's deep man
02:31:56 <Adamant> what's the problem?
02:31:58 <Adamant> :P
02:32:24 <ddarius> Now, Adamant, ponder what a category object in the category of endofunctors would be.
02:32:35 <Adamant> *head asplode*
02:32:38 <kdvh> the LYAH explanation seemed quite clear until i read other stuff... something like "values wrapped in a context", iirc.
02:32:51 <kmc> right, burritos
02:33:00 <kmc> value = beans and cheese
02:33:03 <kmc> context = tortilla
02:33:06 <c_wraith> eh.  I'm sticking with "Monads are like >>="
02:33:15 <kdvh> kmc: lol
02:33:31 <kmc> cars are like string rewriting termination problems
02:33:32 <c_wraith> burritos with cheese?  how bizarre
02:33:34 <copumpkin> none of the analogies cover the adjoint composition definition very nicely. I was trying (and failing) to do that
02:33:44 <mm_freak> kdvh: you get a value of type 'Maybe a' and you want to pass it to a function of type 'a -> Maybe b', monads enable you to by using the (>>=) combinator
02:33:55 <FunctorSalad> monads are like free monoid functors! composed with the forgetful functor!
02:33:59 <mm_freak> also monads enable you to construct a 'Maybe a' from an 'a'
02:34:00 <ddarius> copumpkin: You need to look at call-by-push-value.
02:34:06 <mm_freak> by the 'return' function
02:34:13 <mm_freak> and you can substitute Maybe for any monad
02:34:15 <mm_freak> that's it
02:34:16 <ddarius> FunctorSalad: That would just be the list monad.
02:34:21 <kmc> the problem with the "value in a context" definition is that «M a» doesn't need to actually contain anything of type a
02:34:24 <copumpkin> ddarius: looking it up
02:34:27 <kmc> a prominent example being IO
02:34:29 <FunctorSalad> ddarius: "like" ;)
02:34:31 <kdvh> mm_freak, yeah, ive learnt of this from LYAH, bind is pretty useful
02:34:40 <mm_freak> > Maybe 13 >>= (\x -> Just (x+1))
02:34:41 <lambdabot>   Not in scope: data constructor `Maybe'
02:34:45 <mm_freak> uhm
02:34:46 <FunctorSalad> I was just trying for an intuitive monad tutorial ;)
02:34:48 <mm_freak> > Just 13 >>= (\x -> Just (x+1))
02:34:49 <lambdabot>   Just 14
02:34:50 <kmc> «IO Bool» is nothing like a Bool and needn't contain a Bool anywhere in its (hidden and terrifying) internal structure
02:35:05 <kmc> it's a "recipe for getting a Bool", which is only a "Bool in context" if you squint really hard
02:35:07 <mm_freak> kdvh: i think for most people the only real problem is 'do'-notation
02:35:19 <mm_freak> but it's equivalent to using 'return' and (>>=)
02:35:34 <mm_freak> > do x <- Just 13; Just (x+1)
02:35:35 <lambdabot>   Just 14
02:36:14 <mm_freak> in fact it's just syntactic sugar that is translated to (>>=) and 'return'
02:36:38 <mm_freak> :t getLine >>= putStrLn
02:36:39 <lambdabot> IO ()
02:36:43 <FunctorSalad> Bool = MaybeT Identity () ! easy isn't it
02:36:48 <kdvh> mm_freak: it actually seemed pretty clear when i looked at a chain of >>='s formatted to look like do notation.
02:37:08 <mm_freak> kdvh: yeah, do-notation is just that, but a bit better readable
02:37:11 <FunctorSalad> though that isn't actually true unless you use a maybet with a strict Just ;)
02:37:18 <mm_freak> i think the keyword 'do' is very misleading
02:37:32 <mm_freak> i'd prefer 'proc', but that keyword is reserved for arrows now =)
02:38:28 <kmc> 'return' is even more misleading
02:38:33 <mm_freak> kmc: i agree
02:38:54 <kmc> but once the standard typeclass hierarchy gets defuckulated, we can write "pure" instead
02:38:58 <kmc> which is somewhat better
02:39:07 <mm_freak> whenever that happens
02:39:14 <kdvh> i'll admit that i thought 'wow' when i realized the finally understood what list comprehensions were =]
02:39:30 <kmc> :)
02:40:00 <mm_freak> > do x <- [10,20,30]; y <- [x+1, x-1]; return (x,y)
02:40:00 <lambdabot>   [(10,11),(10,9),(20,21),(20,19),(30,31),(30,29)]
02:40:10 <dobblego> some would say point is better, since class Functor f => Pointed f where point :: a -> f a
02:40:46 <mm_freak> dobblego: better for category theorists, but not necessarily better for programmers
02:41:00 <kmc> i'm fine if the method of "Pointed" ends up being called "pure"
02:41:03 <kmc> whatevs
02:41:09 <dobblego> same
02:41:19 <dobblego> it's the type-class hierarchy itself which is objectionable
02:41:28 <ddarius> The nomenclature around monads is purposely designed to mimick, in part, imperative notation and I agree with that decision.
02:41:40 <mm_freak> well, objectionable in that it's not a hierarchy at all? ;)
02:41:57 <dobblego> hey, there's Functor f => Applicative f !
02:42:08 <mm_freak> ddarius: i'd agree, if 'return' were of type 'a -> IO a'
02:42:16 <mm_freak> and 'pure' were more general
02:42:31 <Philonous> ddarius: I wonder, a free monoid over another free monoid over a set is not the same as the free monoid over the set, is it? You get elements that look like (a*b*c)#(c*d*e) where * and # are different operations. So that wouldn't make the list monad but tries, wouldn't it?
02:43:03 <kmc> mm_freak, but even in IO, "return" doesn't do at all what you'd expect from other imperative languages
02:43:04 <ddarius> You would have lists of lists.
02:43:10 <kmc> do { return 3; return 4 }
02:43:30 <mm_freak> kmc: true
02:43:31 <kmc> do { if x then return 3 else print "foo"; print "bar" }
02:43:55 <kmc> even syntactically it's confusing, people expect it to have very low precedence, when it's actually just a function call
02:44:03 <mm_freak> kmc: but that's something a haskell newbie needs to figure out anyway, no matter what you call the function
02:44:20 <mm_freak> i think 'return' is fine for IO, because it's a computation, which returns that particular value without side effects
02:44:21 <kmc> mm_freak, true, but it's a case of false intuition vs. no intuition
02:44:45 <ddarius> The notation isn't geared toward newbie-friendliness.
02:44:46 <mm_freak> after all it's not haskell's fault that other languages name their keywords in a particular way
02:44:50 <quicksilver> 'result' might be a better choice to defeat that false intuition
02:44:52 <kmc> this is why i like the weird foreign name 'monad'; nobody comes in assuming it's something they know from Java
02:45:38 <mm_freak> for example other languages have 'do' loops, which are very different from what haskell's 'do' does
02:46:01 <kdvh> class confused me before i understood what it meant in a haskell context
02:46:08 <kmc> yup
02:46:10 <mm_freak> in that sense you could also object the choice of the key word 'data'
02:46:11 <ddarius> And other languages have classes which are very different, and functions, and variables.
02:46:29 <mm_freak> because an assembler programmer may take this as introducing a data region in memory
02:46:42 <kdvh> was thinking of class as in java but it meant something like interfaces
02:47:02 <kmc> yeah
02:47:07 <kmc> like interfaces, but different too
02:47:25 <kdvh> even more like generic interfaces 
02:47:26 <mm_freak> i think we shouldn't base our conclusions in comparison to other languages, but to what the purpose of the particular construct is
02:47:30 <kdvh> if i understood correctly
02:47:32 <FunctorSalad> @let now loop = fix (\self -> do { b <- loop; when b self })
02:47:33 <lambdabot>  Defined.
02:47:38 <mm_freak> 'do' builds up a monadic computation and doesn't necessarily 'do' anything
02:47:52 <mm_freak> even in IO, 'do' doesn't really "do"
02:47:56 <kremsera> does ghc evaluate haskell expressions at compile-time?
02:48:09 <quicksilver> kremsera: not many
02:48:26 <quicksilver> inlining is a kind of evaluation
02:48:28 <FunctorSalad> > runState        (now (do { modify succ; gets (>10) }))        0
02:48:29 <lambdabot>   ((),1)
02:48:34 <quicksilver> and RULEs are a kind of evaluation (if they're valid)
02:48:40 <quicksilver> but there's not much constant folding.
02:48:41 <FunctorSalad> see, now we have a do loop :D
02:48:59 <FunctorSalad> ( @ mm_freak )
02:49:26 <kmc> kremsera, Template Haskell is an extension which uses Haskell code, executed at compile time, to generate Haskell code
02:49:30 <FunctorSalad> except I somehow failed at the sign
02:49:31 <kmc> a macro system, essentially
02:49:34 <FunctorSalad> > runState        (now (do { modify succ; gets (<10) }))        0
02:49:35 <lambdabot>   ((),10)
02:49:38 <mm_freak> > head . dropWhile (<10) . iterate succ $ 0
02:49:40 <lambdabot>   10
02:49:42 <mm_freak> better do-loop ;)
02:49:52 <FunctorSalad> but it doesn't have 'do' :o
02:50:05 <Starfire> :t now
02:50:06 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
02:50:06 <mm_freak> > head . dropWhile (<10) . iterate (do succ) $ 0
02:50:08 <lambdabot>   10
02:50:10 <mm_freak> there you go =P
02:50:22 <FunctorSalad> Starfire: I just defined it ;) (to make grammatical sense)
02:50:23 <kremsera> yes but since haskell is functional the compiler could do powerfull optimizations by evaluating arbitrary expresions at compile time
02:50:44 <kmc> kremsera, yes, but doing so effectively is an area of active research
02:50:44 <kremsera> imagine the language shootout benchmarks with constant running time ;)
02:50:45 <Starfire> FunctorSalad: Ahh, I didn't notice.
02:51:00 <kmc> kremsera, see work by Neil Mitchell and more recently Simon Peyton-Jones on supercompilers for Haskell
02:51:14 <mm_freak> btw, i prefer to write this like:
02:51:30 <kmc> "Supercompilation by Evaluation" by Bolingbroke and Peyton Jones is recent and a great read
02:51:52 <FunctorSalad> mm_freak: you abused a bug there didn't you ;)
02:52:06 <FunctorSalad> hmm or maybe not with the anon reader instance
02:52:27 <FunctorSalad> (that 'do x' desugars to 'x' monad or not)
02:52:34 <FunctorSalad> > do True
02:52:35 <lambdabot>   True
02:52:36 <mm_freak> > let abort = Cont . const in flip runCont id . flip runStateT 0 . forever $ do modify succ; b <- get; unless (b < 10) $ abort ()
02:52:37 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.StateT
02:52:37 <lambdabot>              ...
02:52:53 <mm_freak> > let abort = Cont . const in flip runCont id . flip runStateT 0 . forever $ do modify succ; b <- get; unless (b < 10) $ lift (abort ())
02:52:54 <lambdabot>   Couldn't match expected type `(a1, a)' against inferred type `()'
02:53:04 <mm_freak> (i hate the mtl)
02:53:35 <mm_freak> > let abort = Cont . const in flip runCont id . flip evalStateT 0 . forever $ do modify succ; b <- get; unless (b < 10) $ lift (abort ())
02:53:36 <lambdabot>   ()
02:53:40 <mm_freak> there =)
02:54:05 <Starfire> > let it = () in Just do it
02:54:06 <lambdabot>   <no location info>: parse error on input `do'
02:54:26 <FunctorSalad> uh-oh, state and cont... *smiles and nods*
02:54:35 <mm_freak> > Just (do id)
02:54:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
02:54:37 <lambdabot>    arising from a use of `...
02:55:04 <mm_freak> > Just (do id) <*> Just 13
02:55:05 <lambdabot>   Just 13
02:56:20 <FunctorSalad> do your id? now that's selfreferential
03:09:27 <matonimous> yay haskell!
03:13:25 <kremsera> yay!
03:14:26 <matonimous> What is a good library for reading xml? I was looking a tagsoup.
03:23:06 <ivanm> matonimous: there are quite a few; it depends upon what you want
03:23:17 <ivanm> do you want an easy to use library? a very comprehensive library? a fast library?
03:23:27 <ivanm> tagsoup is more HTML IIRC
03:23:35 <ivanm> preflex: seen blackh 
03:23:35 <preflex>  blackh was last seen on #haskell 2 days, 6 hours, 28 minutes and 40 seconds ago, saying: NemesisD: You always get at least four answers to any question in #haskell
03:24:50 <matonimous> ha well.. I am pretty new to haskell.. so probably the easy to use one =)
03:25:26 <ivanm> @hackage xml
03:25:26 <lambdabot> http://hackage.haskell.org/package/xml
03:25:32 <ivanm> well, the advertise it as being simple...
03:25:33 <Mitar> does readFile read in binary or in text?
03:25:45 <ivanm> text IIRC
03:25:54 <Mitar> yes, source also say so
03:27:21 <tomberek> hello all
03:28:26 <ivanm> hey tomberek 
03:32:14 <tomberek> just us eh?
03:32:42 <ivanm> and I'm about to go watch TV ;-)
03:32:59 <Mitar> how can i split a list into chunks of n elements?
03:33:30 <ivanm> Mitar: repeated applications of splitAt
03:33:46 <Mitar> any beatuiful one-liner for that?
03:34:13 <ivanm> not really
03:34:18 <ivanm> @type splitAt
03:34:19 <lambdabot> forall a. Int -> [a] -> ([a], [a])
03:34:31 <ivanm> use a case statement
03:35:58 <mreh> nice new look on hackage
03:36:18 <mreh> well, on the haddocks
03:36:30 <tomberek> Mitar: repeated take?    [take n as] : function (drop n as)
03:38:01 <tomberek> ivanm: What I like about this approach is that the classes offer a nice roadmap to implementing a new graph instance.
03:40:03 <Mitar> hmm, platform independent path spliting? is in base?
03:42:00 <tomberek> there's a splitPath
03:42:17 <geheimdienst> mitar, check splitSearchPath in http://hackage.haskell.org/packages/archive/filepath/1.1.0.4/doc/html/System-FilePath-Posix.html
03:42:24 <geheimdienst> ("filepath" package)
03:42:46 <geheimdienst> although i'm not sure right now why that has a "Posix" and a "Windows" module
03:43:05 <geheimdienst> i mean if you import either, that would defeat the cross-platformitude ...
03:43:10 <Mitar> it seems it selects one automatically
03:43:33 <tomberek> ivanm: is there some structure I can use to test if my design can accomodate?
03:50:09 <ivanm> tomberek: Cabal's PkgIndex? *shrug*
03:50:30 <tomberek> ok,, oh and about containers
03:50:43 <ivanm> tomberek: my current litmus test is: can I adapt graphviz to use this new library so that I can easily visualise a PkgIndex?
03:51:28 <tomberek> I'd love to get that and then offer an AdjacencyListGraph, where is it easy to plug in different backends (set,list,vector,fingertree,etc)
03:51:59 <tomberek> ok, so to convince you, I need to make a Graph instance of PkgIndex?
03:52:34 <ivanm> something like that
03:52:34 <fasta> tomberek, what is the point of having different backends? Don't you just need one which implements that particular ADT efficiently?
03:52:44 * ivanm can't talk much atm
03:53:31 <fasta> tomberek, it's wonderful to 'abstract' about backends that one day might exist, but from a user/dev. point of view, nobody cares about that. 
03:54:10 <tomberek> fasta: if you know what operations you need at runtime, you can choose...... but at the moment, that's not implemented, so you're in luck!  any feedback for my graph api?
03:55:09 <fasta> tomberek, which one? 
03:55:42 <tomberek> http://codepad.org/D7nkyZBM   It's a different approach than FGL.
03:56:06 <tomberek> more classes, more things to define, but simpler things to define
03:56:27 <fasta> tomberek, codepath is slow here.
03:57:16 <tomberek> fasta: what do you mean?
03:57:26 <fasta> tomberek, I mean that I cannot see that page.
03:57:38 <fasta> tomberek, after 40 seconds it came. \o/
03:57:42 <tomberek> oh!
03:58:30 <fasta> tomberek, ah, so, it appears to be a copy of the Boost Graph Library. 
03:58:40 <tomberek> yep!
03:58:44 <fasta> tomberek, very nice and could actually become useful. 
03:59:11 <fasta> tomberek, I basically wrote the exact same thing 3/4 years ago, except it used fundeps. 
03:59:52 <fasta> tomberek, the BGL basically nailed it, and there really is not anything to be researched about it, imho. Very nice that you have taken that lesson. 
04:00:08 <fasta> tomberek, why exactly are you doing this, btw?
04:00:37 <tomberek> fasta: well, I want to stop everyone from writing their own, get a canonical graph API... long run, i want to work on an artificial neural network library
04:00:44 <fasta> tomberek, you do need much more methods, though, but I suspect it's just a start. 
04:01:16 <tomberek> fasta: yes, but the rest should come free (from an instance writer point of view) ?
04:01:18 <fasta> The most viable approach would probably be to get the mutable backend to be equal to the Boost stuff. 
04:01:42 <fasta> That is, then there would be surely no performance issues either. 
04:01:43 <tomberek> fasta: and that was what I was saying earlier about "different backends"
04:01:49 <fasta> It would be harder to write, though. 
04:02:19 <tomberek> I don't think it would be too hard, type families can handle it,, we just need a good containers API
04:02:22 <fasta> tomberek, it is kind of unfortunate that there is no monetary incentive in doing what you are about to do, though. 
04:02:47 <fasta> tomberek, it's something everybody wants, but nobody wants to pay for.
04:02:50 <tomberek> fasta: neural networks in Haskell?  I would assume the AI community would love it
04:02:57 <fasta> tomberek, no, the graphs.
04:03:35 <fasta> If people want neural networks doing useful stuff they just implement it in C and use some ultra-optimized algorithms to exponentiate. 
04:04:01 <fasta> (e.g. 45 times faster than normal by using some approximation of exponentiation)
04:04:04 <tomberek> fasta: then I'll do it for free, have my name on it, and be able to point to it and say "Look. At what i have created. It is used by many."  Perhaps some employer or grad school will like it at some time.
04:04:28 <fasta> tomberek, you don't actually have to be able to point at it. 
04:04:36 <fasta> tomberek, (speaking from experience)
04:05:03 <fasta> tomberek, do you have the BGL book?
04:05:11 <Adamant> tomberek: that phrasing made me laugh. thank you.
04:05:12 <tomberek> fasta: true, but remember the point of Haskell, quick development.  Why spend 10 hours writing optimized C, when 1 hour of Haskell + 2 hour slower runtime allows several designs to be tested.
04:05:46 <fasta> tomberek, the point of Haskell for me, should be that you can _also_ write optimized code, without 'dropping to C'. 
04:06:21 <tomberek> fasta: i found the manual online, I think I understand the concept,,,, what I wrote so far only co-opted the API for the classes.  The rest of the "modular backend" will wait for a proper containers API
04:06:28 <fasta> You can basically write C level code in Haskell, so we can already do that. 
04:06:31 <tomberek> Adamant: glad to be of service
04:06:39 <Adamant> tomberek: :)
04:06:40 <fasta> tomberek, before you start, I suggest you read it. 
04:07:38 <tomberek> fasta: i've skimmed almost all of it, another more thorough read might be in order
04:08:10 <fasta> tomberek, I am talking about an actual physical book. 
04:08:19 <fasta> tomberek, I don't think the content is online.
04:09:06 <tomberek> fasta: i also know that i'm not Haskell-wise yet, so I'm trying to convince some bigger guns, get the ball rolling as it were.  Like you say, everyone wants a good graph API, but no one wants to do it.
04:10:08 <tomberek> fasta: hm,,, don't have the book,, but then again, hard to get while out of the contry
04:10:21 <tomberek> country
04:10:34 <fasta> tomberek, where are you now? And where do you live? 
04:17:50 <tomberek> fasta: hm... first I need to write some implementations... I should start with ivanm's suggestion of PkgIndex,, do you know where that can be found? cabal?
04:18:10 <fasta> tomberek, I have no idea. 
04:22:18 <ivanm> yes, it's in the cabal library
04:22:24 <ivanm> could be PackageINdex, I forget
04:22:40 * hackagebot wumpus-core 0.32.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.32.0 (StephenTetley)
04:22:44 <tomberek> ivanm: http://hackage.haskell.org/packages/archive/Cabal/1.8.0.6/doc/html/src/Distribution-Simple-PackageIndex.html#dependencyGraph
04:22:46 <tomberek> found it
04:23:09 <tomberek> so I just need to rewrite that function for my graph, vs Data.Graph
04:23:22 <tomberek> i'll get back to you
04:23:37 <min> Hey - I have some code that needs to be refactored, badly. But it has errors, and I don't know exactly where the errors are. Essentially, it doesn't seem to be updating a counter correctly. I think this is due to the function 'next' and 'paths', but I can't seem to figure out why. If anyone can take a look, I'd appreciate it. <http://codepad.org/VzU0yGd0>
04:23:41 * hackagebot wumpus-basic 0.7.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.7.0 (StephenTetley)
04:24:28 <tomberek> ivanm: or would a     instance MyGraph g => Data.Graph.Inductive.Graph g a b    be better?
04:24:41 * hackagebot wumpus-microprint 0.7.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.7.0 (StephenTetley)
04:24:43 * hackagebot wumpus-tree 0.6.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.6.0 (StephenTetley)
04:31:16 <ivanm> tomberek: huh?
04:31:17 <ivanm> no
04:31:32 <ivanm> the whole point of what I want to do is to split up the various aspects of what a graph _is_
04:31:57 <ivanm> and so InductiveGraph just extends the underlying Graph class with the notion of inductiveness: match, &, etc.
04:33:00 <tomberek> ivanm: ok, I think the boost-style splitting up is a start,,, notice how InductiveGraph extends Vertex, Bidirectional, and Mutable
04:33:08 <ivanm> right
04:33:16 <ivanm> which is kinda what I was aiming at as well
04:33:19 <tomberek> ivanm: and you get context/match for free!
04:33:28 <ivanm> really?
04:33:34 * ivanm goes off to look at tomberek's code again
04:33:57 <ivanm> I don't see it...
04:34:04 <ivanm> unless you do explicit deletion, etc.
04:34:08 <tomberek> context g n = do    foundNode <- node g n                         return $ makeContext (edgesIn g n) foundNode (edgesOut g n)
04:34:11 <ivanm> which you'd probably want to override
04:34:19 <tomberek> and for match, I use your code
04:34:32 <tomberek> match g n = fmap (flip (,) $ removeNode n g) $ context g n
04:34:38 <ivanm> tomberek: no label ;-)
04:34:48 <tomberek> the label is in the Node
04:34:52 <ivanm> yeah, you've completely missed the points of labels
04:34:55 <ivanm> *sigh* not this again...
04:35:03 <tomberek> no, no!
04:35:05 <ivanm> I thought I finally managed to convince you away from that foolishness
04:35:19 * ivanm sees that tomberek is using "type Node g" and "type Edge g"
04:35:25 <tomberek> take a look at the instance, it's still there, but it only comes out at PropertyGraph
04:35:31 <tomberek> NodeLabel g
04:35:52 <ivanm> then you don't need an explicit AT for Edge
04:36:02 <tomberek> Node should really be : WholeNode g   etc
04:36:10 <ivanm> I think it's easier to always have a label, but set it to () if your graph doesn't have any concept of labels
04:36:35 <tomberek> ivanm: can be done easily... MapGraph ()  is an unlabeled graph
04:36:37 <ivanm> splitting it up too finely like that makes it much harder to use IMHO
04:37:16 <tomberek> ok, I can un-do that... i just like the symmetry, but practicality CAN override that
04:37:36 <ivanm> preflex: seen Heffalump 
04:37:37 <preflex>  Heffalump was last seen on #darcs 13 hours, 51 minutes and 25 seconds ago, saying: sm: yeah. mornfall has been refactoring things so specific options get passed down where needed.
04:38:06 <tomberek> ivanm: that whole thing happened because Boost has PropertyGraph  (ie. labeled graph), we could just say that ALL graphs are labeled
04:38:13 <ivanm> right
04:38:16 <ivanm> much easier IMHO
04:38:31 <ivanm> and I get the impression that BGL is much more aimed at graph data structures
04:38:45 <ivanm> whereas I want to consider graph-like data structures as well
04:39:04 <geheimdienst> so-called graphish or graphic data structures
04:39:07 <ivanm> and consider the extra properties different sub-classifications can have, rather than dictacting sub-categories of graphs
04:39:13 <ivanm> geheimdienst: heh
04:39:29 <deteego> ivanm: why do you always sound like a physicist?
04:39:55 <ivanm> deteego: I do? :o
04:40:01 * ivanm did study physics...
04:40:08 <tomberek> ivanm: well, a graph in category theory is pretty basic... two sets, and two arrows from one set (edges) to the other (nodes).. i don't see how to break that down more
04:40:10 <deteego> ivanm: you have that vibe
04:40:15 <ivanm> http://xkcd.com/793/
04:40:30 <ivanm> deteego: I'm a mathematician-cum-computer-scientist!
04:40:53 <ivanm> tomberek: right, exactly: that is what the GraphLike class would have
04:41:01 <ivanm> g -> [Node g], g -> [Edge g]
04:41:06 <deteego> ivanm: pff, and them someone bribes you over into quantum physics
04:41:24 <tomberek> EdgeGraph and VertexGraph have edges and nodes
04:41:25 <ivanm> deteego: unlikely, unless it's to do with combinatorial structures
04:41:35 * ivanm will be doing some chemical molecule stuff soon-ish
04:41:44 <deteego> ivanm: you go to uni?
04:41:46 <tomberek> ivanm:  so this Boost-style can allow only one or the other
04:41:55 <ivanm> tomberek: right, that is what I think is the fundamental property of graph-like data structures
04:41:56 <tomberek> if so wished
04:41:58 <ivanm> deteego: doing my PhD
04:42:03 <deteego> ivanm: ah nice
04:42:21 <ivanm> tomberek: well, the only time you wouldn't want either one IMHO is if one of them is infinite
04:42:29 <ivanm> s/IMHO/AFAIK/
04:42:39 <ivanm> hmmm, unless there's some fuzziness involved...
04:42:44 <ivanm> but we have to draw the line somewhere
04:42:45 <tomberek> it sounds like we are in agreement (except for PropetyGraph, which we can change :) )
04:43:44 <tomberek> Would it help if I change NodeIndex -> Node  and Node -> WholeNode or EntireNode, Nodule....
04:43:49 <O1athe> Are there any tricks to speed up stdin and stdout?
04:44:35 <blackh> O1athe: Use ByteStrings
04:44:40 <ivanm> "speed up" ?
04:44:51 <ivanm> blackh: I thought they were more for files, not stdin and stdout
04:44:56 <ivanm> (speed-wise, that is)
04:45:21 <ivanm> O1athe: is your current bottleneck really how slowly it takes to communicate with stdin and stdout?
04:45:25 <O1athe> I can't use ByteStrings, unfortunately, since I'm on Windows.
04:45:41 <ivanm> O1athe: huh? I didn't know there was anything OS-specific with ByteStrings
04:45:51 <ivanm> wait, hang on: Windows has stdin and stdout?
04:45:51 <O1athe> Yeah, there's a long-standing bug.
04:45:52 <ivanm> :p
04:45:56 <tomberek> ivanm: would a renaming Node g -> WholeNode g      and NodeIndex g -> Node g     help... or something similar?
04:46:13 <tomberek> Node g -> LNode g
04:46:14 <ivanm> IMO, no
04:46:26 <ivanm> type LNode g = (Node g, NodeLabel g)
04:46:28 <ivanm> done
04:46:33 <O1athe> ivanm: Heheh
04:46:47 <O1athe> ivanm: http://hackage.haskell.org/trac/ghc/ticket/1276 (very bottom line of text).
04:47:28 <O1athe> ivanm: Yeah, I think it's that. The code runs fine if I pipe a file in.
04:47:45 <tomberek> ivanm: ok, i'll make the changes
04:48:01 <ivanm> lol: I love how it's marked as "Moderate (less than a day)" but has been opened for 4 years
04:48:14 <O1athe> Yeah :)
04:48:22 <O1athe> I wonder if there's any way to give it a bump.
04:49:12 <geheimdienst> srsly? haskell can't do non-blocking reading on windows? :-o
04:49:32 <geheimdienst> that's pretty bad
04:50:06 <deteego> geheimdienst: if Im reading things right, then that is REALLY bad
04:51:11 <tab> make you wonder if there's anyone using haskell seriously on windows :\
04:51:21 <Zao> I try.
04:51:29 <Zao> Works decently if you avoid hippie-loving libraries.
04:51:38 * deteego feels sorry for Zao
04:51:38 <ivanm> tab: nope, they just keep whining about why Haskell isn't supported on Windows without (usually) bothering to help support it
04:51:47 <Zao> And happen to have a msys world to build dependencies in.
04:51:48 <ivanm> Zao: "hippie-loving" ?
04:52:07 <deteego> well LLVM will make things a lot easier for windows users
04:52:08 <Zao> ivanm: Libraries that use non-portable things out of lazyness.
04:52:10 <tab> ivanm: typical ;)
04:52:25 <ivanm> deteego: I doubt it
04:52:28 <deteego> Zao: actually its windows thats being non portable
04:52:29 <Zao> deteego: I can't see how it would.
04:52:31 <ivanm> that's yet another thing they have to build :p
04:52:35 <ivanm> deteego: yup
04:52:48 <deteego> Zao: most such libraries use POSIX standard, thats hardly the coders fault
04:52:49 <Zao> GHC is horribly tied to the GNUish toolchain.
04:52:59 <ketil> GHC 6.10 complains that I need -XDeriveDataTypeable, but at the top of the source file I have the requisite pragma - and I could swear it worked before.  Is the pragma a GHC 6.12 addition, perchance?
04:52:59 <Zao> No xlC, no MSVC, no sunstudio, etc.
04:53:02 <geheimdienst> if i were a windows user and had run into this problem, i would be angrily mumbling now how anyone can be working monomonoidal monoids when such basic stuff isn't working
04:53:19 <Saizan> ketil: is it really at the top?
04:53:22 <Zao> deteego: That standard is not universal.
04:53:36 <deteego> ivanm: but yeah, what Zao said, GNU toolchain on windows is sucky
04:53:44 <deteego> Zao: uh, it pretty much is
04:53:58 <Zao> deteego: Except that Windows is a major platform.
04:54:01 <ivanm> ketil: I believe it is
04:54:02 <Zao> You cannot deny that.
04:54:04 <deteego> Zao: pretty much every major OS that is NOT windows is posix compilant
04:54:27 <ivanm> Zao: well, there are a dearth of freely available alternate toolchains
04:54:36 <Zao> deteego: Except for the ones that differ subtly in all kinds of fun ways.
04:54:39 <deteego> ivanm: its still a massive pain in the royal ass
04:54:54 <Zao> ivanm: MSVC is freely available.
04:55:03 <deteego> ivanm: LLVM also for some reason is really fast on windows
04:55:08 <Zao> It's a massive pain to interop with Haskell on Windows, even if you disregard the nonportable library bits.
04:55:11 <ivanm> Zao: was it freely available back then? and for the OSs that the GHC devs were using?
04:55:12 <deteego> ivanm: no one really knows why
04:55:42 <ivanm> Zao: because it isn't all done through one big IDE and having copies of other libraries in your source? :p
04:55:48 <Zao> ivanm: Since 2005 at least.
04:56:10 <ivanm> Zao: and when was GHC first released?
04:56:18 <Zao> ivanm: When dinosaurs roamed the earth.
04:56:21 <deteego> 1995 wasnt it?
04:56:46 <geheimdienst> would SPJ count as a dinosaur?
04:56:47 <tab> really, dinosaurs in 1995 !
04:56:49 <ketil> Saizan, ivanm: seems to be correct - I just added Ghc-Options to .cabal, and now it works with both versions (albeit with a warning).  Thanks.
04:57:10 <Zao> Hopefully the work on getting rid of the inbred hacky custom linker will make things better, with the dynamic runtime bits and all.
04:57:10 <ketil> (btw: you two always seem to answer my questions here - are you stalking me? :-)
04:57:10 <ivanm> ketil: huh, maybe your LANGAUGE pragma was malformed?
04:57:15 <ivanm> or you had a typo?
04:57:28 <ivanm> Saizan: dammit, he's onto us!
04:57:30 <ketil> ivanm, no it just isn't supported by 6.10, only by 6.12.
04:57:31 * ivanm runs and hides
04:57:37 <ivanm> ketil: ahhh, right
04:57:45 <deteego> Zao: you have to admit, Microsoft has been anything but open up until recently
04:57:46 <ketil> You can run, but you cannot hide.  At least not without logging off IRC.
04:58:04 <deteego> Zao: they are KNOWN for vendor locking principles, so dont be surprised if issues like these exist
04:59:16 * geheimdienst likes windows. he's been a full-time linux user for years, but has full respect for windows
04:59:25 <ivanm> you do? :o
04:59:27 <ivanm> traitor!!!
04:59:35 <ivanm> ketil: dammit!
04:59:44 <geheimdienst> ... i.e. i don't understand all the bitching
05:00:10 * Zao investigates the prospect of pizza-typed dinner.
05:00:26 <geheimdienst> @time zao
05:00:27 <ivanm> Zao: what do you classify as "pizza-typed" ?
05:00:36 <geheimdienst> dinner :: Pizza
05:00:38 <ivanm> how about something like Pides?
05:00:45 <geheimdienst> > "lolcats"
05:00:46 <lambdabot>   "lolcats"
05:00:52 <geheimdienst> @time Zao
05:00:57 <geheimdienst> @time geheimdienst
05:01:07 <geheimdienst> @time ivanm
05:01:08 <lambdabot> Local time for ivanm is Wed Sep 15 22:00:44
05:01:21 <ivanm> geheimdienst: Zao's client obviously blocks CTCP TIME
05:01:21 <geheimdienst> why does this work a little but not very much
05:01:26 <geheimdienst> yeah :)
05:01:38 <geheimdienst> mine too, apparently. wth
05:01:50 <ivanm> which client?
05:02:25 <geheimdienst> pidgin, unfortunately ...
05:02:36 <deteego> weechat ftw
05:02:38 <kremsera> pidgin speaks irc?
05:02:41 <Zao> ivanm: Thin crust pizza, pan pizza, pizza rolls, etc.
05:02:45 <geheimdienst> what a crap program. i swear, one of these days i'm gonna write my own irc client
05:03:09 <geheimdienst> (note how i phrased that as if writing my own irc client would take only a day)
05:03:11 <Zao> Local time seems to be roughly 2 PM.
05:03:12 <tab> geheimdienst: before doing that, tried any other client ?
05:03:27 <Zao> Personal uptime, closer to 18h.
05:03:45 <ivanm> geheimdienst: I believe manateelazycat is doing just that
05:03:48 <geheimdienst> tab: do i look like a pussy
05:03:50 <geheimdienst> ;-)
05:03:55 <ivanm> and there has been at least one other haskell iRC client
05:03:56 <tab> :D
05:04:06 <tab> geheimdienst: well you're using pidgin ...
05:04:14 <geheimdienst> good point
05:04:17 <geheimdienst> :D
05:04:23 <ivanm> Zao: do you limit yourself ot pizza-like foods of Italian origin?
05:04:31 <ivanm> or also similar foods from other cultures?
05:04:56 <geheimdienst> it's running anyway because i need icq/jabber, so i figured, why not just use it for irc as well
05:05:12 <Zao> ivanm: I wouldn't say there's much italian about most pizzas around here.
05:05:15 <Saizan> ketil: i'm sure DeriveDataTypeable is supported by both, as --supported-languages shows, also it wouldn't work from ghc-options either if it wasn't supported
05:05:35 <ivanm> Zao: hence "of Italian origin"
05:05:45 <wli> Go for Asian pizza.
05:06:00 <Zao> Thin crust, lots of toppings. Canonical swedish.
05:06:02 <ivanm> I would argue that they are derived from Italian pizzas, just mutated
05:06:14 <Zao> More italian than american at least.
05:06:42 <geheimdienst> i actually had the idea of using haskell to make a fuse filesystem which exposes libpurple (pidgin backend). you'd have ~/chat/irc/#haskell, ~/chat/icq/joe and things like that. the actual client would be little more than tail -f and echoing stuff into files
05:07:03 <geheimdienst> i would classify the whole idea as way hardcore
05:08:41 <wli> Seriously, websurf for Asian pizza. It's better than Italian or American.
05:09:03 <wli> (Really Japanese/Taiwanese/Korean, mainland China isn't doing it AFAIK.)
05:09:24 <ketil> Saizan, and I'm sure you are wrong.  (If we both are sure the other is wrong, is that what is called a violent agreement?)
05:10:11 * ivanm is partial to Turkish Pide's, but that could be because of the TUrkish restaraunt downstairs
05:10:47 <wli> I imagine that's substantially easier than flying to Japan, Taiwan, or Korea.
05:11:27 <ketil> 6.10 says "unrecognized pragma", 6.12 complains about me using ghc-options.  /me shrugs, as long as it works on both installations.... :-)
05:12:16 <ivanm> ketil: lol
05:12:17 <fasta> wli, are you talking about okonomiyaki?
05:12:38 <ivanm> ketil: you could have an "if < 6.12" in your .cabal file...
05:12:56 <geheimdienst> okoNOMiyaki
05:13:03 <geheimdienst> sounds delicious
05:13:09 <wli> fasta: No, they have literal pizza things that are rather far out.
05:13:30 <wli> fasta: In Japan, Pizza Hut is a major vendor thereof.
05:14:12 <wli> fasta: Mind you, even though it's Pizza Hut, it's nothing like what they sell elsewher in the world.
05:14:12 <deteego> so is kfc apparently
05:14:20 <fasta> wli, so, what makes it different?
05:15:18 <fasta> wli, I kind of liked a pizza from Pizza Hut the one time I got one there. Maybe it was my expectation that I would be getting something terrible that made it actually quite good. 
05:15:42 <wli> fasta: It's really crazy and over the top. I think they may take partial inspiration from okonomiyaki but certainly not all.
05:15:56 <wli> fasta: You got pizza from Pizza Hut in Japan?
05:15:58 <medfly> almost all the ppl participating in this convo are in #haskell-blah
05:16:04 <geheimdienst> make that: over the topping
05:16:44 <geheimdienst> at 4am, the line between haskell and haskell-blah begins to blur ...
05:17:38 <wli> fasta: http://slice.seriouseats.com/archives/2008/02/crazy-weird-asian-pizza-crusts-japanese-korean-hong-kong.html
05:18:52 <O1athe> Are there any #ifdef things in GHC that tell whether you're on Windows?
05:19:00 <ivanm> I think it's possible, yes
05:19:23 <ivanm> or if not, you can do it via cabal and then pass the appropriate flag to your source for the ifdefs
05:19:52 <O1athe> I need it to build with plain ghc -O2 --make, since I'm submitting the code to a contest.
05:19:59 <O1athe> And they autobuild entries.
05:20:02 <medfly> reminds me of http://www.youtube.com/watch?v=G5udwntuV7c wli
05:20:20 <O1athe> But I can use the GHC options pragma :)
05:20:30 <O1athe> If there's an option.
05:20:50 <ivanm> ghc --fuse-the-damn-cabal-file :p
05:21:16 <O1athe> Haha
05:21:54 <Jonno_FTW> there is an -O3 optimisation flag
05:48:12 <merl> Text.Regex.Posix> "pogo" =~ ".o" :: [String] -- doesn;t work. Why?
05:49:55 <zygoloid> merl: what about it doesn't work?
05:50:10 <merl> No instance for (RegexContext Regex [Char] [String])
05:50:10 <merl>       arising from a use of `=~' at <interactive>:1:0-13
05:50:26 <benmachine> merl: [String] isn't a valid output
05:50:31 <merl> String gives first match, [String] shoudl give all matches
05:50:40 <benmachine> try [[String]]
05:50:43 <merl> How do you get a list of all matches?
05:51:18 <merl> Yes it works! (But I'm puzzled)
05:51:28 <xiackok> anyone knows hint library?
05:51:40 <benmachine> merl: the regex library is ridiculously polymorphic :P
05:51:44 <zygoloid> hmm. (String, String, String) also works. is that (before, match, after) ?
05:51:47 <benmachine> merl: try :i RegexContext
05:52:16 <merl> ty ben
05:55:53 <quicksilver> the typeclass overloaded interface of the regexp library is an interesting experiment in API design
05:56:01 <quicksilver> I consider the experiment a success
05:56:09 <quicksilver> in that it has convinced me that that is a bad way to design an API ;)
05:56:17 <quicksilver> I don't think the author agrees, actually, last we talked.
05:56:48 <merl> I just don't get the missing [String] instance
05:57:36 <fasta> It's not really the polymorphism that is annoying, but more that you get questions like zygoloid's. 
05:58:35 * copumpkin thinks n-tuples for n > 2 should be banished :P
05:58:58 <zygoloid> there's also (before, match, after, submatches) :: (String, String, String, [String])
05:58:59 <quicksilver> copumpkin: they're very handy for storing static data in source files
05:59:01 <copumpkin> well maybe not banished
05:59:12 <copumpkin> but discouraged
05:59:23 <quicksilver> copumpkin: I have programs which have lists of the form [(Command,KeyBinding,HelpText)]
05:59:35 <quicksilver> (which are then processed by other actual code to set up the keybindings and the help texts)
06:00:00 <copumpkin> quicksilver: but what does a 3-tuple buy you that a custom type doesn't have? unlike pairs, it has almost no useful predefined functions on it
06:00:08 <copumpkin> you still have to pattern match on it to pull those out
06:00:21 <copumpkin> and writing a type name in that list is more descriptive
06:00:44 <zygoloid> fewer parens? :)
06:01:18 <copumpkin> the only functions I can think of on tuples for n > 2 are the zipWithn functions
06:01:30 <copumpkin> and unzip, I guess
06:01:40 <zygoloid> @hoogle (a,b,c)
06:01:40 <lambdabot> Test.QuickCheck three :: Monad m => m a -> m (a, a, a)
06:01:40 <lambdabot> Data.Graph.Inductive.Graph labEdges :: Graph gr => gr a b -> [LEdge b]
06:01:41 <lambdabot> Data.Time.Calendar toGregorian :: Day -> (Integer, Int, Int)
06:01:55 <masklinn> @hoogle (a,b,c,d)
06:01:55 <lambdabot> Test.QuickCheck four :: Monad m => m a -> m (a, a, a, a)
06:01:55 <lambdabot> Network.Socket iN6ADDR_ANY :: HostAddress6
06:01:55 <lambdabot> Trace.Hpc.Util fromHpcPos :: HpcPos -> (Int, Int, Int, Int)
06:02:02 <masklinn> @hoogle (a,b,c,d,e)
06:02:02 <lambdabot> No results found
06:02:03 <copumpkin> see, the gregorian triple there is meaningless
06:02:07 <masklinn> @hoogle (a,b,c,d,e,f)
06:02:08 <lambdabot> No results found
06:02:09 <zygoloid> yep
06:02:11 <zygoloid> @hoogle d -> (a,b,c)
06:02:11 <lambdabot> Control.Monad.RWS.Lazy runRWS :: RWS r w s a -> r -> s -> (a, s, w)
06:02:12 <lambdabot> Control.Monad.RWS.Strict runRWS :: RWS r w s a -> r -> s -> (a, s, w)
06:02:12 <lambdabot> Control.Monad.RWS.Lazy runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
06:02:51 <ray> @hoggle ((a,b),c)
06:02:51 <lambdabot> No results found
06:03:09 <masklinn> @hoogle (a,(b,c))
06:03:09 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
06:04:20 <zygoloid> hmm. is (,) an Arrow? i can see it being a Category at least
06:04:46 <copumpkin> no
06:05:12 <zygoloid> actually, it has no id :(
06:05:24 <zygoloid> not even a Category
06:05:30 <copumpkin> there, there
06:05:51 * copumpkin comforts zygoloid 
06:06:06 * zygoloid sobs quietly
06:06:08 * masklinn kicks zygoloid while he's down
06:08:07 <Philonous> zygoloid: Even with id, what would arr be?
06:12:42 <quicksilver> copumpkin: I don't want to define a custom type for one use.
06:12:47 <quicksilver> copumpkin: it's just a waste of effort.
06:13:05 <quicksilver> This list occurs once in the program where it's immediately processed (by 'map' and pattern matching) to do something useful
06:13:14 <quicksilver> the type has no longer term purpose.
06:13:29 <quicksilver> and, yes, it's syntactically lightweight.
06:13:53 <quicksilver> Philonous: arr f = (undefined, f undefined), of course ;)
06:16:07 <Philonous> quicksilver: Yay! instance Eq (a->b) where compare = undefined. Hell, why the modesty. instance Eq a where compare = undefined :D
06:16:37 <benmachine> quicksilver: what if 3-tuples were syntactic sugar for nested tuples?
06:16:41 <benmachine> like, hlists, sorta
06:17:26 <Philonous> benmachine: I cyn already see myself typing caaddr 
06:17:35 <Philonous> can*
06:18:29 <quicksilver> benmachine: I couldn't care less ;)
06:18:45 <quicksilver> benmachine: I mean, I suppose, I probably have an opinion about it eventually
06:18:53 <quicksilver> but it wouldn't matter either way for the use case I'm describing.
06:19:26 <benmachine> quicksilver: I've been wondering about it as an idea, hoping it would still satisfy your use case while also solving the problems of endless instances etc.
06:19:28 <quicksilver> nested 2-tuples is nice for uniformity and polymorphism but the extra bottoms may be surprising.
06:19:54 <quicksilver> DANGER DANGER : extra bottoms lurk within
06:19:57 <copumpkin> lol
06:20:08 <copumpkin> how about nested 2-tuples where the second member is strict
06:20:30 <copumpkin> (a, b, c) == (a, !(b, !(c, !())))
06:21:18 <copumpkin> also, car and cdr
06:21:32 <copumpkin> @let car = fst; cdr = snd
06:21:34 <lambdabot>  Defined.
06:27:49 <fryguybob> > car . cdr . cdr $ (a, (b, (c, ())))
06:27:51 <lambdabot>   c
06:28:09 <illissius> would a question about RULES be more appropriate on haskell-cafe or glasgow-haskell-users?
06:30:00 <Olathe> How do I get the types to check on if isPrefixOf "mingw" os then getContents else L.getContents ?
06:31:01 <Olathe> I have a class called StringLike that has both String and L.ByteString as instances.
06:31:39 <Olathe> I've given that expression the type :: StringLike string => IO string, but it still fails.
06:33:41 <illissius> Olathe: it's saying something about inferred type being less polymorphic than expected?
06:33:44 <Saizan> you'd need an existential type
06:34:58 <Olathe> http://codepad.org/IbNReJdz
06:35:05 <Olathe> Saizan: Ahh, OK.
06:43:14 <benmachine> Olathe: StringList string => IO string means, this function can return any StringLike type you want
06:43:28 <benmachine> not, this function can return any StringLike type *it* wants :P
06:43:39 <benmachine> for that you'd want Either String ByteString or something
06:45:31 * hackagebot gtksourceview2 0.12.1 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.12.1 (AndyStewart)
06:47:36 <Olathe> I have osGetContents = if isPrefixOf "mingw" os then (getContents :: forall s. S.StringLike s => IO s) else (L.getContents :: forall s. S.StringLike s => IO s)
06:47:44 <Olathe> But I get errors like Couldn't match expected type `s1' against inferred type `[Char]'
06:48:07 <Olathe> I'm still lost on how to get this typechecking.
06:50:24 <ray> try breaking it into smaller parts and finding the one that doesn't typecheck
06:53:01 <Olathe> I did. It's the if that has different types for the then and else block.
06:53:22 <benmachine> Olathe: what you're trying to do isn't going to work
06:53:26 <Olathe> I have the whole if typed as forall s. C s => s, though.
06:53:29 <benmachine> conceptually it's just wrong
06:53:30 <Olathe> Ahh.
06:53:42 <benmachine> whatever code calls osGetContents needs to know what type it returns, statically
06:53:57 <Olathe> Hmm...
06:53:59 <benmachine> i.e. without knowing what the OS is
06:54:03 <benmachine> unless
06:54:10 <roconnor> GADTs!
06:54:20 <Olathe> Yeah, I could make a type for it.
06:54:22 <benmachine> you can write an API for StringLike that supports allll the operations you ever want to do on the return type
06:54:29 <benmachine> then an existential wrapper will work
06:54:33 <Olathe> Oh, I do have one.
06:54:37 <benmachine> but personally I think an Either result would work much ebtter
06:54:46 <Olathe> Ahh, Either.
06:54:54 <Olathe> OK, that'll work :)
06:59:00 <bss03> @hoogle (a -> a) -> a -> [a]
06:59:00 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
06:59:01 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
06:59:01 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
06:59:58 <Olathe> @pl (\x -> f x >> g) ?
07:00:01 <lambdabot> (line 1, column 19):
07:00:01 <Olathe> @pl (\x -> f x >> g)
07:00:03 <lambdabot> unexpected end of input
07:00:05 <lambdabot> expecting white space or simple term
07:00:07 <lambdabot> (>> g) . f
07:05:05 <cizra> Hi guys. What'd be a function to check if a string contains a substring?
07:05:27 <roconnor> @hoogle String -> String -> Bool
07:05:27 <lambdabot> System.FilePath.Posix equalFilePath :: FilePath -> FilePath -> Bool
07:05:27 <lambdabot> System.FilePath.Windows equalFilePath :: FilePath -> FilePath -> Bool
07:05:28 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
07:05:42 <roconnor> isInfixOf
07:05:44 <ManateeLazyCat> What's the easiest way to get current time : (hours, mintues, seconds) ?
07:05:53 <roconnor> @hoogle currentTime
07:05:54 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
07:05:54 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
07:06:00 <roconnor> ManateeLazyCat: getCurrentTIme
07:06:10 <ManateeLazyCat> @getCurrentTime
07:06:10 <lambdabot> Unknown command, try @list
07:06:13 <roconnor> this is easy :D
07:06:17 <ManateeLazyCat> @hoogle getCurrentTime
07:06:17 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
07:06:17 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
07:07:05 <cizra> Thanks!
07:07:54 <benmachine> see also: getZonedTime
07:08:05 <zygoloid> Philonous: there's no arr in Category
07:08:14 <roconnor> @hoogle getZonedTime
07:08:14 <lambdabot> Data.Time.LocalTime getZonedTime :: IO ZonedTime
07:08:16 <benmachine> just (.) and id
07:08:23 <roconnor> oooh
07:08:34 <ManateeLazyCat> @hoogle formatTime
07:08:34 <lambdabot> Data.Time.Format formatTime :: FormatTime t => TimeLocale -> String -> t -> String
07:08:35 <lambdabot> Data.Time.Format class FormatTime t
07:08:35 <lambdabot> System.Time formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
07:08:40 <ManateeLazyCat> Nice.
07:08:44 <ManateeLazyCat> roconnor: Thanks! 
07:09:14 <ManateeLazyCat> roconnor: Just give "%H%M%S" to formatTime...
07:09:27 <roconnor> I'm not a big fan of format stuff
07:09:43 <roconnor> but maybe it isn't so bad
07:09:49 <zygoloid> i guess (,) is an RCategory, with a Monoid restriction on both types
07:10:00 <roconnor> it's a lot better than printf
07:11:50 <benmachine> the monoid restriction is only slightly better than undefined :P
07:12:01 <benmachine> you're not *using* the monoid for anything really
07:12:26 <FunctorSalad> hmm?
07:12:43 <FunctorSalad> (a,b) . (c,d) = (a, b `mappend` c, d)
07:13:05 <benmachine> err, that result is a 3-tuple
07:13:17 <FunctorSalad> damn.
07:13:19 <FunctorSalad> ;)
07:13:39 <FunctorSalad> you have a point.
07:14:32 <ManateeLazyCat> @hoogle TimeLocale
07:14:32 <lambdabot> No results found
07:14:40 <FunctorSalad> but... it's so beautifully symmetric ;)
07:14:49 <ManateeLazyCat> @hackage locale
07:14:49 <lambdabot> http://hackage.haskell.org/package/locale
07:15:23 <FunctorSalad>  /nick PrintfPolice
07:15:25 <FunctorSalad> printf rocks!
07:15:40 <zygoloid> benmachine: not really. id would be (mempty, mempty). (a,b) &&& (c,d) = (a `mappend` c, (b, d)). etc.
07:15:55 <benmachine> zygoloid: ah, for your RArrow
07:15:56 <zygoloid> you still can't do arr, but you can get a lot of the rest of Arrow. and arr is silly anywayl
07:16:02 <benmachine> heh okay
07:16:18 <FunctorSalad> er but what's .?
07:16:27 <zygoloid> FunctorSalad: (a,b) . (c,d) = (a,d).
07:16:33 <copumpkin> it has to be
07:16:35 <zygoloid> or whatever it is that makes the types work :)
07:17:06 <copumpkin> (c, b) ?
07:17:10 <FunctorSalad> mine would work with [AnyMonoid] :P
07:17:26 <zygoloid> :) yeah
07:17:30 <FunctorSalad> Kitten a b = Kitten a [AnyMonoid] b
07:17:34 <FunctorSalad> O_o
07:17:44 <FunctorSalad> probably not so useful unless you also have a typeable constr
07:18:11 <FunctorSalad> hmm or actually I don't need the list do I?
07:20:06 <FunctorSalad> nevermind it still doesn't work...
07:20:40 <FunctorSalad> mappend isn't "(Monoid a, Monoid b) => exists c. Monoid c"
07:20:41 <FunctorSalad> ;)
07:20:52 <FunctorSalad> a -> b -> exists c. Monoid c
07:20:56 <mm_freak> ok, just like everybody seems to write a tutorial about monads (including me), it looks like there are lots of monad transformer libraries, each doing essentially the same…  and i'll follow the trend and write my own, too =)
07:21:29 <benmachine> mm_freak: *gasp*
07:21:41 <benmachine> there are like three major competitors in the field and then lots of bolt-ons
07:21:43 <FunctorSalad> why would you do such a wicked thing?
07:21:51 <benmachine> but the technically superior solution is losing as it is
07:22:10 <FunctorSalad> yeah, write a generics scheme instead
07:22:10 <Saizan> mm_freak: port wadler's monad tutorial to modern haskell instead :)
07:22:19 <mm_freak> benmachine: i'm very happy with monadLib, but it lacks a few things i'd like, and mine will be different, really, because it will be entirely based on CPS
07:22:31 <FunctorSalad> (according to one paper it has become "somewhat of a cottage industry")
07:22:48 <FunctorSalad> benmachine: what is superior
07:22:53 <ski> (FunctorSalad : itym `forall a b. (Monoid a,Monoid b) => a -> b -> exists c. Monoid c *> c' .. which is more or less the same thing as `(exists a. Monoid a *> a) -> (exists a. Monoid a *> a) -> (exists a. Monoid a *> a)' .. which is your `AnyMonoid -> AnyMonoid -> AnyMonoid', i suppose)
07:22:53 <mm_freak> Saizan: well, i'd rather modernize my own tutorial, because it doesn't talk about functors and applicatives at all, which i find a bit unfortunate
07:22:53 <tomberek> hey, how can I get the PackageIndex for my computer?
07:23:00 <tomberek> hi ski
07:23:01 <FunctorSalad> mm_freak: monads-ran?
07:23:04 <FunctorSalad> it has been done
07:23:24 <mm_freak> FunctorSalad: you need to be a CT expert to understand that one =P
07:23:26 <ski> lo tomberek
07:23:29 <benmachine> ski: what's *> in a type?
07:23:35 <FunctorSalad> ski: oh right (if "*>" is some sort of inline constraint)
07:23:39 <Saizan> mm_freak: remember that CPSing is not always a win, and it changes the semantics in some cases
07:23:44 <mm_freak> mine will really give the usual interface, but use CPS under the hood and by that also provide some extras
07:24:00 <ski> benmachine,FunctorSalad : `(->)' : `(,)' :: `(=>)' : `(*>)'
07:24:01 <tomberek> any way to get the PackageIndex?
07:24:01 <FunctorSalad> mm_freak: uh the types themselves aren't any more compicated than CPS
07:24:03 <mm_freak> Saizan: yes, the semantics will be different — intentionally
07:24:12 <benmachine> ski: umm.
07:24:13 <FunctorSalad> it has a name from CT, but wth?
07:24:29 <FunctorSalad> (IIRC)
07:24:47 <FunctorSalad> ski: ah, seems reasonable
07:24:50 <mm_freak> FunctorSalad: yes, but you can use CPS while still maintaining a more traditional interface, so it's accessible to people familiar with mtl/transformers/monadLib/whatever
07:25:04 <ski> (benmachine : .. ok ?)
07:25:07 <mm_freak> FunctorSalad: ran = right kan
07:25:54 <mm_freak> i also found that using CPS you can unify ReaderT and StateT in a single monad
07:26:15 <FunctorSalad> mm_freak: hmm monad-ran doesn't instantiate mtl?
07:26:38 <mm_freak> FunctorSalad: i don't know…  its interface scared me off, when i looked at it
07:27:15 <Saizan> it's very simply
07:27:19 <Saizan> *simple
07:27:28 <Saizan> Ran M is the cps'ed version of M
07:27:33 * ManateeLazyCat pasted "getTimeStamp" at http://paste2.org/get/989003
07:27:38 <ManateeLazyCat> Rock getTimeStamp!
07:27:52 <ski> (benmachine : in case you didn't know, `A : B :: C : D' means "`A' is to `B' as `C' is to `D'" .. the expression originally comes from geometry, i think (double proportionality))
07:27:57 <benmachine> ski: I think I'm not sufficiently educated in the intricacies of the (->) : (,) relationship, but I'm not going to worry about it too much for the time being
07:28:10 <FunctorSalad> hmm monad-ran doesn't seem to be installible currently
07:28:13 <benmachine> ski: oh yeah, I got that bit
07:28:24 <ManateeLazyCat> > let getTimeStamp = formatTime <$> pure defaultTimeLocale <*> pure "[%H:%M:%S]"  <*> (utcToLocalTime <$> getCurrentTimeZone <*> getCurrentTime)
07:28:25 <lambdabot>   not an expression: `let getTimeStamp = formatTime <$> pure defaultTimeLocal...
07:28:35 <mm_freak> Saizan: well, monads-ran also doesn't have the benefits of monadLib, which i really like
07:28:47 <copumpkin> benmachine: the curry relationship is it!
07:28:57 <copumpkin> and uncurry :)
07:29:01 <benmachine> copumpkin: delicious
07:29:10 <tomberek> is there an IO function to get the installed packages? or anything that I can use to get to a type of PackageIndex
07:29:11 <benmachine> but also, oh okay
07:29:13 <geheimdienst> i kan has cheezburger
07:29:17 <ray> have you ever actually tried to uncurry something
07:29:31 <ray> once something's curried it stays that way
07:29:35 <FunctorSalad> benmachine: it's like in predicate logic... you almost never want "exists x. P[x] -> Q[x]"
07:29:37 <ski> benmachine : the point being that something of type `C a => ..a..' basically acts like a function which transforms any given instance `C a' to something of type `..a..', which something of type `C a *> ..a..' acts like a pair of an instance `C a' together with a value of type `..a..'
07:29:42 <FunctorSalad> but "exists x. P[x] /\ Q[x]"
07:29:53 <mm_freak> :t uncurry . curry $ \(x,y) -> (y,x)
07:29:54 <lambdabot> forall a b. (a, b) -> (b, a)
07:29:56 <benmachine> ski: oh, okay
07:30:04 <FunctorSalad> since the former is true if there exists any x such that not P[x]
07:30:20 <Botje> does anyone here know of a good resource describing kinds?
07:30:24 <mm_freak> ray: doesn't that disprove what you say?
07:30:32 <FunctorSalad> (it's equiv to "(exists x. not P[x]) || (exists x. Q[x])"
07:30:45 <benmachine> ski: I hadn't thought of contexts like that before, sounds interesting
07:30:58 <ski> benmachine : so, a function of type `Int -> exists a. C a *> ..a..' will select some type `a' (possibly depending on the input `Int'), and generate a result of type `..a..', together with an instance `C a', so the only thing a caller can do with the `a's in the result is use the methods of `C' on them
07:31:03 <geheimdienst> > uncurry (+) (42,37)
07:31:04 <lambdabot>   79
07:31:05 <ray> uncurrying by eating it is cheating!
07:31:19 <mm_freak> ;)
07:31:41 <tomberek> is there an IO function to get the installed packages? or anything that I can use to get to a type of PackageIndex,, anyone?
07:31:43 <benmachine> ray: hmm, I'm thinking a sort of centrifuge...
07:31:49 <benmachine> ski: right
07:32:10 <FunctorSalad> tomberek: yes but I forgot :(
07:32:23 <tomberek> arg!
07:33:06 <ski> benmachine : otoh, a function of type `Int -> exists a. C a => ..a..' would be a function which will select some type `a' (possibly depending on the input `Int'), and then given that the *caller* provides an instance `C a' (which is usually impossible, unless there's an generic `instance C a where ...' .. or the `..a..' (by GADTs e.g.) provide some way to (possibly) recover the type `a' at run-time) before yielding a result of
07:33:15 <tomberek> FunctorSalad: i've been looking for a while, i haven't played with IO much, so this is new to me
07:34:13 <geheimdienst> tomberek, have you checked the modules in Distribution? http://hackage.haskell.org/package/Cabal
07:34:33 <tomberek> geheimdienst: i'm looking, but i'm lost
07:34:43 <Saizan> getInstalledPackages
07:34:43 <geheimdienst> very understandable :)
07:34:49 <benmachine> ski: before yielding a result of
07:34:51 <FunctorSalad> what's chrisdone's new pastebin again?
07:34:54 <Saizan> ?hoogle getInstalledPackages
07:34:55 <lambdabot> No results found
07:35:00 <benmachine> ski: was there more message after that?
07:35:05 <Saizan> it's somewhere in the Cabal lib :)
07:35:13 <FunctorSalad> what I'm thinking of is in ghc
07:35:19 <ski> benmachine : "before yielding a result of type `..a..'"
07:35:25 <FunctorSalad> or any haskell pastebin
07:35:26 <ski> benmachine : of course, one can consider more complex cases like `forall a. C a => Foo a -> exists b. D a b *> Bar a b', &c.  ..  my main point anyhow being that we want to distinguish between `C a => ..a..' and `C a *> ..a..'
07:35:43 <tomberek> Saizan: i found that, but then I get lost with all the PackageDB etc.
07:35:45 <benmachine> ski: right, okay
07:36:20 <tomberek> Saizan: ie. i don't know what to put for the arguments to the function
07:36:36 <FunctorSalad> tomberek: http://paste.tryhaskell.org/30087/packagethingy
07:36:54 <FunctorSalad> one of my many project stubs ;) that currently prints out a package:module list or something
07:37:17 <ski> (benmachine : and if you're wondering, yes the concrete syntax `*>' is my invention .. i needed some way to signify the distinction/difference to `=>' .. it might be that later Haskell implementations, if they will provide first-class existentials, in some form, that they will include a construction like `*>' (not necessarily using that notation) .. in the meantime, it's useful to be able to talk of types in terms of `exists' 
07:37:30 <FunctorSalad> delete the "import SP", that's my personal shell prelude thingy 
07:37:44 <geheimdienst> tomberek: what are you trying to do? maybe there's some easier way ...
07:37:53 <HugoDaniel> hi
07:38:10 <HugoDaniel> is there any quick n dirty way to convert a utf8 string to ascii ?
07:38:22 <benmachine> ski: there *are* compilers with an exists keyword, though, aren't there?
07:38:35 <ManateeLazyCat> HugoDaniel: Data.ByteString.Char8.pack
07:38:39 <Saizan> tomberek: http://paste.tryhaskell.org/30088/with_cabal?pid=30088&lang_30088=Haskell
07:38:40 <tomberek> geheimdienst, I just want to test a function i wrote, it needs a PackageIndex
07:38:49 <FunctorSalad> wait it does more than that, it prints a "package:module list" *menu* and then outputs the empty list!!! ;)
07:38:56 <HugoDaniel> ManateeLazyCat: I want to handle the special characters also :P like "Ç" converted to "C"
07:38:57 <Saizan> tomberek: the PackageDB is to tell which packages to include
07:39:16 <ManateeLazyCat> HugoDaniel: Oh, you need encoding convert.
07:39:18 <HugoDaniel> ill pattern match and map it over the string :(
07:39:19 <HugoDaniel> yes
07:39:28 <tomberek> Saizan: thanks, that should work, i think...
07:39:36 <ski> benmachine : yes, but (afaik) only in trivial circumstances. i.e. UHC (and maybe jhc/lhc ?) allows `(exists a. ..a..) -> ...' instead of `forall a. ..a.. -> ...'
07:39:41 <ManateeLazyCat> HugoDaniel: Or you need build your own convert map.
07:39:48 <ManateeLazyCat> HugoDaniel: For special character.
07:39:50 <benmachine> ski: mm, fair enough
07:39:51 <HugoDaniel> eh
07:39:53 <HugoDaniel> ok
07:40:54 <ski> benmachine : so, that's mainly only useful to be able to write some current types somewhat more prettily .. and to hide some `exists' used in argument types behide type synonyms, i assume
07:41:10 <FunctorSalad> hmm in fact, my paste prints the "modInfoTyThings" of the chosen module
07:41:21 <FunctorSalad> but that's empty for the random module I tried
07:41:49 <FunctorSalad> nvm it's nonempty for GHC.Base
07:43:50 <FunctorSalad> ski: isn't it just literally (->) vs (,) if you compile the haskell to dictionary-passing code?
07:43:54 <FunctorSalad> benmachine: 
07:44:28 <ski> FunctorSalad : exactly
07:44:58 <mm_freak> is it right to view Cont is the identity monad with respect to CPS-based monad transformers?
07:45:37 <mm_freak> because: newtype IdCPS r a = IdCPS ((a -> r) -> r)
07:45:58 <ski> mm_freak : wouldn't that be `newtype PureCont a = MkPureCont (forall o. (a -> o) -> o)' instead ?
07:46:11 <mm_freak> ski: why that?
07:46:25 <cwb> Anyone know how to set names for subcommands (modes) using CmdArgs.Implicit? They default to the type names but I'd like to set them explicitly.. I've tried Mode2 &= name "cmdname" but get an unexpected mode error..
07:47:08 <ski> mm_freak : using the type `Cont o a', you can express continuation effects, while `PureCont a' doesn't allow that (because the result/answer type is polymorphic)
07:47:37 <FunctorSalad> btw it took me a rather long time to get that code working :(
07:48:12 <FunctorSalad> spooky requirement at a distance "initblah :: IO ()" style functions are evil
07:48:27 <ski> @type Cont . flip all  -- this is a(function returning a)n effectful computation in `Cont Bool'
07:48:28 <mm_freak> ski: i see
07:48:28 <lambdabot> forall a. [a] -> Cont Bool a
07:49:01 <FunctorSalad> maybe even calling "parse_static_flags" was necessary, I don't remember what made it work in the end
07:49:03 <mm_freak> ski: well, CPS effects should be allowed everywhere
07:49:05 <ski> (mm_freak : it is the ability to concretely depend on the type `o' in `Cont o a' which allows nontrivial effects, here)
07:49:13 <FunctorSalad> *parseStaticFlags
07:49:31 <ski> mm_freak : .. but then it doesn't correspond to the `Identity' monad anymore ..
07:49:39 <ski> (and various laws fail)
07:49:52 <mm_freak> ski: and i'm not asking for a true identity monad wrt CT, but just something, that doesn't add anything more than the other monads do
07:50:06 <mm_freak> just for a suitable pure bottom monad
07:50:09 <ski> which other monads ?
07:50:28 <mm_freak> all monads in my library are going to be based on CPS, StateT, ReaderT, etc.
07:50:55 <mm_freak> hence you can, as an example, call 'abort' for all of them for early exit
07:51:07 <ski> "being based on CPS" =/= "having to allow expression of continuation effects"
07:51:40 <ski> some uses of CPS is of the polymorphic variety above, and is used to improve efficiency, e.g.
07:51:45 <mm_freak> hmm, well, if i really wanted to use your monad, i could just as well use the usual Id
07:51:59 <mm_freak> or is there a difference?
07:52:20 <mm_freak> a noticable difference that is
07:52:34 <ski> in the case of `Identity', there's probably not really any benifit to using `PureCont', instead
07:52:55 <mm_freak> ok, then i guess i'll just go the usual way
07:52:59 <ski> but e.g. using `forall o. o -> (a -> o -> o) -> o' instead of `[a]' can improve efficiency
07:53:02 <mm_freak> newtype Id a = Id a
07:53:14 <mm_freak> or maybe with a better constructor name
07:53:26 <mm_freak> yeah, there will be a list monad transformer using CPS
07:53:39 <FunctorSalad> yet another Id? :(
07:53:43 <FunctorSalad> maybe reuse one
07:53:53 <ski> @index Identity
07:53:53 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
07:53:58 <ski> @src Identity
07:53:59 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
07:54:05 <FunctorSalad> iirc it's called Id in transformerz
07:54:25 <FunctorSalad> @index Id
07:54:26 <lambdabot> bzzt
07:54:35 <ski> mm_freak : but if you're wanting to employ all your monads with continuation effects, then `Cont' might be a good "base case", i suppose (if i grasp correctly what you're trying to do .. which i'm not sure of)
07:54:35 <mm_freak> firstly Identity is a long spelling, secondly i'd need to depend on another monad library, which would destroy the point of my own =)
07:54:49 <FunctorSalad> hmm if it's not an addon
07:54:50 <ski>   type Id = Identity  -- shorter
07:55:01 <ski> ok
07:55:13 <mm_freak> ski: well, i just need an identity monad to make pure monads out of monad transformers
07:55:17 <mm_freak> ContT → Cont
07:55:31 <mm_freak> i guess using CPS-based Id doesn't make much sense here
07:55:36 <FunctorSalad> why not duplicate the code?
07:55:39 <ski> mm_freak : ok, then `Identity' (however you want to call it) seems to be what you want
07:55:46 <FunctorSalad> possible using a macro lang or another
07:55:54 <FunctorSalad> it saves users from doing the runIdentity
07:55:58 <mm_freak> FunctorSalad: what would that be good for?
07:56:02 <FunctorSalad> ^^^
07:56:05 <mm_freak> ah, yes
07:56:13 * ski wonders whether there's any more primitive concept of composing continuations-based monads ..
07:56:13 <mm_freak> well, there will be a runCont along with a runContT =)
07:56:19 <FunctorSalad> ah
07:56:32 <mm_freak> ski: good question
07:57:01 <FunctorSalad> well I don't even really understand the basics of mixing Cont with other monads :-(
07:57:09 <mm_freak> i like monad transformers, but they have one downside:  the stack order is significant
07:57:15 <ski> mm_freak : along with `evalCont :: Cont o o -> o' and `evalContT :: Monad m => ContT o m o -> m o' ?
07:57:38 <mm_freak> FunctorSalad: unless you really do something ContT-ish, you won't notice a difference
07:57:41 <tomberek> Saizan: thanks for the help., i got that to work
07:58:02 <illissius> mm_freak: I don't know very much about CPS-based monads, but what about just adding e.g. FasterT to monadlib via a patch?
07:58:05 <mm_freak> FunctorSalad: ContT gives you some handy capabilities and CPS-based approach can improve performance in general
07:58:33 <FunctorSalad> hehe "FasterT"
07:58:42 <mm_freak> ski: i haven't seen a library implementing evalCont, and i think it's not that bad to write runContT return
07:58:45 <mm_freak> or runCont id
07:58:46 <FunctorSalad> seems like one of these "make your internet connection faster" scam ads
07:58:48 <FunctorSalad> ;)
07:58:48 <illissius> (or "SometimesFasterT" more accurate and less conveniently)
07:58:54 <ski> (if you're only after the performance part, then universally quantifying the result type is probably appropriate)
07:59:28 <mm_freak> illissius: monadLib already has ContT, which gives me some enhanced control stuff, but just wrapping a continuation monad around doesn't make things faster
07:59:43 <FunctorSalad> ski: what's the connection?
07:59:44 <mm_freak> ski: you mean for Id?
08:00:07 <FunctorSalad> I take it he means the 'r'
08:00:20 <ski> mm_freak : well, we have `evalState' and `execState' and `execWriter' .. and i find myself writing  (`runCont` id)  and  (`runContT` return)  all the time ..
08:00:36 <FunctorSalad> forall r. (a -> r) -> r         ==         a, I think
08:00:41 <illissius> mm_freak: well I (like apparently most people) don't know how edwardk's Ran thing works, but apparently it does, so that's why I assumed it's possible
08:00:42 <mm_freak> ski: i write runContT return
08:00:52 <FunctorSalad> but it's more interesting with a monad involved
08:00:56 <mm_freak> runContT return . runStateT initState . forever $ …
08:01:07 <ski> @type runContT return
08:01:08 <lambdabot>     Couldn't match expected type `ContT r m a'
08:01:08 <lambdabot>            against inferred type `a1 -> m1 a1'
08:01:09 <lambdabot>     In the first argument of `runContT', namely `return'
08:01:13 <mm_freak> ski: i'm using monadLib
08:01:30 <ski> the same point still applies
08:01:44 <mm_freak> illissius: i think edwardk's library does more than just wrapping a continuation monad around
08:01:46 <FunctorSalad> @ty flip runContT return
08:01:47 <lambdabot> forall r (m :: * -> *). (Monad m) => ContT r m r -> m r
08:02:02 <ski> @type (`runContT` return)
08:02:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => ContT a m a -> m a
08:02:05 <mm_freak> ski: i'm also planning to generalize running
08:02:29 * ski doubts whether that's very useful .. but i'll wait
08:02:30 <FunctorSalad> I think Ran generalizes ContT to the form:     ( a -> g r ) -> h r
08:02:42 <mm_freak> anyway, let me get hacking and let's see the result
08:02:46 <FunctorSalad> ski: it=?
08:02:46 <ski> FunctorSalad : with `forall r.', i think
08:02:54 <mm_freak> ski: but one question, do you see any advantage of using a CPS-based Id?
08:03:00 <mm_freak> (without allowing effects)
08:03:04 <FunctorSalad> `runContT` return does seem useful
08:03:21 <mm_freak> because i don't
08:03:40 <ski> FunctorSalad : "it" being "generalize running"
08:03:51 <FunctorSalad> ah
08:04:11 <ski> (s/wait/reserve judgement/)
08:04:23 <FunctorSalad> btw the diff between 'a' and forall r. Cont r  a is that the latter circumvents memoization?
08:04:52 <mm_freak> well, generalized running makes the order of the monads in the stack less significant, but i guess that comes at the cost of some ambiguous types
08:05:03 <ski> FunctorSalad : connection between univerally quantifying result type and performance ?
08:05:09 <FunctorSalad> ski: yes
08:05:21 <Saizan> FunctorSalad: it allows >>= fusion, avoiding intermediate structures
08:05:45 <FunctorSalad> Saizan: isn't that the upside of the same thing?
08:05:59 <illissius> mm_freak: generalize running beyond RunM you mean?
08:06:06 <FunctorSalad> thought the only reason it makes apparently useless intermediate structures is that they might me accessed more than once
08:06:54 <mm_freak> illissius: yeah, because RumM doesn't capture everything
08:06:59 <Saizan> well GHC is not a perfect compiler, it doesn't deforest automatically in every case :)
08:07:28 <mm_freak> illissius: i thought of using an associated type to add a parameter to the running function
08:08:00 <illissius> hmm, why mix fundeps and tf?
08:08:01 <FunctorSalad> Saizan: yeah but I meant wouldn't not deforesting the right thing to do if an 'intermediate' structure is read more than once?
08:08:03 <ski> mm_freak : re `Identity' .. no the performance remark was for CPSified types in general .. and it might be useful to use `PureCont' (or something like that) instead of `Id' as a base case, if one can figure out a way to compose continuation-based monads (edwardk possibly knows) -- but i'm not sure whether this is sensisble/possible
08:08:05 <FunctorSalad> I don't really get this
08:09:06 <ski> FunctorSalad : the point being that if you don't need (or want) general continuation effects, you can still get performance benifits by using CPS. so by universally quantifying the result type, you insure against anyone using continuation effects, but still keep the performance bit
08:09:07 <illissius> i converted monadlib to typefamilies out of boredom a few weeks back and sent a patch, though i haven't heard back since the initial response... maybe i should ping
08:09:31 <mm_freak> ski: you mean as an identity to monad composition instead of a base for transformation?
08:10:07 <FunctorSalad> ski: ok that's my missing knowledge, that the universal quantification insures that there are no cont. effects
08:10:20 <ski> mm_freak : yeah .. some kind of "continuation-based-monad composition/transformers" as opposed to ordinary monad transformers .. like i said, i don't know whether this is possible
08:10:24 <FunctorSalad> assuming we have a monad, not just plain Cont
08:10:41 <FunctorSalad> forall r. (a -> m r) -> m r     ~       m a        ?
08:10:50 <ski> FunctorSalad : yes
08:10:56 <FunctorSalad> disregarding seq and performance
08:11:02 <FunctorSalad> really? odd
08:11:11 <Saizan> FunctorSalad, ski: you can still have some effect there
08:11:19 <ski> Saizan : yes
08:11:49 <Saizan> since you can use the continuation multiple times
08:12:07 <FunctorSalad> but the m a can do that too
08:12:57 <FunctorSalad> ContT (\k -> (k =<< x) >> (k =<< x))   ~ x >> x       isn't it?
08:13:00 <ski> FunctorSalad : but e.g. `forall o. (a -> m o -> m o) -> (m o -> m o)' can be useful
08:13:26 <Saizan> FunctorSalad: no?
08:13:28 <ski> Saizan : .. or at least i think so. i can't seem to conjure up an example right now, though
08:13:52 <FunctorSalad> the right side is the "flip runContT return" of the left side at least
08:13:52 <ski> FunctorSalad : i'm not sure what you're asking
08:14:11 <mm_freak> ski: this would be great…  but i guess that would require one mother CPS monad flexible enough to encode all the others, because if i have individual monads, then in composition the order will still matter on the type level
08:14:35 <Saizan> FunctorSalad: take x = return 1, and then flip runContT print
08:14:40 <FunctorSalad> ski: that last part was @ Saizan "calling the continuation multiple times"
08:15:01 <Saizan> FunctorSalad: or flip runContT return . (>>= print)
08:16:03 <FunctorSalad> the "~" possible isomorphism I mean is "flip runContT return" with possible inverse "return"
08:16:04 <Saizan> basically you can write things that'd require a global refactoring without the ContT
08:16:28 <Saizan> FunctorSalad: yeah, but it's not composable then
08:16:35 <FunctorSalad> (iso between "forall r. ContT r m a" and "m a")
08:16:52 <ski> (mm_freak : i was thinking of some kind of composition in higher kinds .. with a final "wrapping" to yield a monad (or monad transformer) from the continuation-monad-composition ..)
08:17:00 <Saizan> or it doesn't respect the semantics..
08:17:01 <FunctorSalad> Saizan: hmm but my LHS runs "k =<< x" twice too
08:17:18 <Saizan> FunctorSalad: right, and your RHS doesn't..
08:17:30 <FunctorSalad> "x >> x"? :o
08:17:44 <Saizan> k would be there only once
08:18:10 <Saizan> you have to think of your two expressions in a larger context to see the difference
08:18:25 <FunctorSalad> like " (x >> x) >>= g "?
08:18:29 <Saizan> yeah
08:18:37 <mm_freak> ski: yeah, i see what you mean, but i don't see how one would get rid of the order-sensitivity
08:18:42 <FunctorSalad> ok that's different from running the LHS with g
08:19:02 <FunctorSalad> but the same as (`runContT return`)ing the LHS and then feeding it to g ;)
08:19:09 <FunctorSalad> I don't know what my point there is
08:19:38 <FunctorSalad> but good idea to think about a larger context :)
08:19:41 <mm_freak> ski: btw, better write only the actual statement in parentheses ("mm_freak: (blah)") instead of everything ("(mm_freak: blah)"), otherwise my highlighter doesn't trigger =)
08:19:51 <FunctorSalad> Saizan: maybe that'll finally make me understand the details of ContT ;)
08:20:08 <Saizan> FunctorSalad: it's all about evaluation context :)
08:20:12 <FunctorSalad> wrap it into an arbitrary such context and evaluate?
08:20:18 <FunctorSalad> (symbolically)
08:20:21 <FunctorSalad> to understand it, that is
08:20:26 <ski> mm_freak : in *general*, i don't think you can. however, in many *special* cases, however, we clearly can commute different monadic aspects -- so we'd like a system which reflected that in the types, so you didn't have to arbitrarily select some ordering (and then have to remember that ordering, and change lots of code whenever we modify it)
08:21:42 <FunctorSalad> Saizan: does this mean there isn't an isomorphism after all?
08:22:11 <ski> (FunctorSalad : i'm not sure why you used `~' on the value-level (instead of at the type level). first i thought you meant `=', but then it seemed you meant that there was an isomorphism interconverting between those two expressions)
08:22:34 <FunctorSalad> just a retraction / split epi or however you want to call it I guess ;)
08:22:39 <Saizan> FunctorSalad: i suspect there can be one at the syntactic level
08:22:48 <mm_freak> ski: btw, note that using CPS you get rid of some special cases anyway
08:22:49 <ski> FunctorSalad : "retract situation" :)
08:23:00 <mm_freak> for example ReaderT and StateT are the same when using CPS
08:23:06 <FunctorSalad> ski: on the value level I meant "x ~ y" meaning "f(x) = y" where f is the iso
08:23:25 <mm_freak> it's just that forbidding to change the state, which makes (>>=) commutative
08:23:39 <FunctorSalad> where f x = runContT x return
08:23:52 <FunctorSalad> "return . f" should be idempotent at least
08:23:54 <ski> @unmtl StateT rs (ContT o m) a
08:23:54 <lambdabot> rs -> (a -> rs -> m o) -> m o
08:23:55 <ski> @unmtl ContT o (ReaderT rs m) a
08:23:55 <lambdabot> (a -> rs -> m o) -> rs -> m o
08:24:03 <FunctorSalad> since "f . return" == id (?)
08:24:16 <ski> mm_freak : rather both are related, via commuting of `ContT o'
08:24:50 <FunctorSalad> f (return x) = f (ContT (\k -> k =<< x)) = return =<< x = x
08:24:52 <FunctorSalad> \o/
08:25:07 <ski> mm_freak : hm .. or maybe you meant something else ?
08:25:56 <mm_freak> ski: i meant something else, look at this:  newtype StateT r s m a = MkStateT (s -> (s -> a -> r) -> r)
08:25:57 <ski> (mm_freak : like maybe the retract situation between `State rs a' and `Reader rs a' ?)
08:26:02 <mm_freak> this is the same as ReaderT
08:26:34 <ski> hm
08:26:57 <mm_freak> i think with CPS you can get rid of some monads, because they become equivalent to others
08:27:19 <ski> it seems you're talking about simulating `Reader' / dynamic scoping with `State' (i.e. mutating and then reverting to older values)
08:27:34 <mm_freak> but you can make:  newtype ReaderT r s m a = MkReaderT (StateT r s m a)
08:27:49 <mm_freak> to make the commutativity of (>>=) type-checkable
08:27:59 <FunctorSalad> btw on the practical side, what's the right monad for writing menus, each of which implicitly has an "undo" going one up in the hierarchy? ;)
08:28:00 <mm_freak> uhm
08:28:06 <mm_freak> btw, i missed including the monad =)
08:28:11 <FunctorSalad> I confused myself badly with that
08:28:21 <mm_freak> of course i meant:  newtype StateT r s m a = MkStateT (s -> (s -> a -> m r) -> m r)
08:28:45 <ski> mm_freak : i don't see how you can enforce the "commutativity" in the types there
08:28:53 <FunctorSalad> newtype UndoT m x = ReaderT [m ()] m x, maybe...
08:29:04 <mm_freak> you can also encode WriterT using this, because a CPS WriterT is nothing else than passing (w, a)
08:29:05 <FunctorSalad> but I thought there must be some ContT for it
08:29:10 <ski> (apart from making an abstract type, i.e.)
08:29:14 <mm_freak> which is just an uncurried version of w -> a ->
08:29:30 <mm_freak> ski: you can't 'enforce' them
08:29:55 <ski> mm_freak : so what did you mean by "make the commutativity of (>>=) type-checkable", then ?
08:30:22 <FunctorSalad> nvm that ReaderT seems nonsensical
08:30:25 <mm_freak> ski: i meant that you have an explicit distinction between ReaderT and StateT, so you can't accidentally change the state
08:30:51 * FunctorSalad just uses RWS
08:31:00 <FunctorSalad> instead of thinking about reader/state ;)
08:31:02 <ski> mm_freak : so `ReaderT' will be an abstract type, with no conversion to it from `StateT' ?
08:31:15 <mm_freak> ski: it's just a thought
08:31:31 <mm_freak> ReaderT, StateT and WriterT all become the same thing when using CPS
08:31:40 <mm_freak> so you don't need separate implementations of them
08:31:41 <ski> FunctorSalad : that may be less incremental than necessary, if you don't really need the state
08:31:55 <mm_freak> that's my point
08:32:09 <ski> mm_freak : i'm not seeing how they become the same thing ..
08:32:23 <mm_freak> ski: how would a CPS-based ReaderT look like for you?
08:32:36 <mm_freak> s/how/what/
08:33:10 <mm_freak> for me it would be:  newtype ReaderT r e m a = MkReaderT (e -> (e -> a -> m r) -> m r)
08:33:36 <FunctorSalad> ReaderT (m e) m       vs             ReaderT e m            seems to be similar to the issue we just discussed with ContT...
08:33:45 <FunctorSalad> random point :)
08:34:06 <FunctorSalad> the former can execute the environment many times, though it seems like a silly thing to do
08:34:09 <ski> mm_freak : i'm not sure it is possible to have one at all, apart from the encoding of dynamic scope in terms of state above (and then it's no wonder that the type ends up looking like state)
08:35:25 <mm_freak> ski: yeah, the real reader monad transformer doesn't look possible to me either, but besides provable commutativity the real ReaderT doesn't have any advantage, right?
08:35:59 <mm_freak> we can enforce commutativity by not allowing to change the state (or just not implement ReaderT at all)
08:37:07 <ski> FunctorSalad : actually, that makes me recall the alternative typing `callCC :: forall m a b. MonadCont m => ((m a -> m b) -> m a) -> m a' where you escape with a computation instead of a value, where the computation will be executed in the dynamic context of the call to `callCC', instead of the call to the escape procedure
08:37:18 <FunctorSalad> basically ContT lets you solve equations like "x >>= k = y" for x? ;)
08:37:28 <FunctorSalad> still trying to understand ContT
08:37:57 <mm_freak> FunctorSalad: Cont is just a monad for CPS-style computations
08:38:06 <FunctorSalad> (but is y :: m a or y :: ContT r m a?)
08:38:07 <mm_freak> so you get all the advantages of CPS using it
08:38:16 <ski> mm_freak : well, having "real commutativity" probably makes the code more incremental (so it can provide some parts of the output, without having to execute all of the monadic computation)
08:38:24 <mm_freak> newtype Cont r a = MkCont ((a -> r) -> r)
08:38:26 <FunctorSalad> mm_freak: well I'm trying to understand what exactly that means and implies ;)
08:38:55 <mm_freak> FunctorSalad: well, if you don't use any Cont effects, it's almost the same as the identity monad
08:39:02 <FunctorSalad> looking at it from the "adds virtual solutions to equations" angle :)
08:39:08 <mm_freak> FunctorSalad: it gets interesting as soon as you use CPS effects like abortion
08:39:11 <FunctorSalad> like negative numbers do
08:39:20 <mm_freak> consider for example this:  MkContT $ \k -> 15
08:39:28 <ski> @type Cont . flip all  -- an effectful computation in the `Cont Bool' monad
08:39:29 <lambdabot> forall a. [a] -> Cont Bool a
08:39:29 <mm_freak> i.e. the continuation doesn't get called
08:39:41 <mm_freak> that's an abortion with the result 15
08:39:59 <FunctorSalad> Num (m a)? ;)
08:40:01 <mm_freak> or consider this:  Cont $ \k -> k 1 ++ k 2
08:40:08 <FunctorSalad> \k -> return 15 I guess
08:40:58 <mm_freak> ski: CPS-based monads have different semantics anyway…  i don't think you can really make them order-independent easily
08:41:07 <ski> @let every :: [a] -> Cont Bool a; every as = Cont (`all` as)
08:41:08 <lambdabot>  Defined.
08:41:17 <ski> @let some :: [a] -> Cont Bool a; some as = Cont (`any` as)
08:41:18 <lambdabot>  Defined.
08:41:27 <mm_freak> CPS StateT for example is stricter than ordinary StateT
08:41:42 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
08:41:43 <lambdabot>  Defined.
08:47:42 <ski> @let mod_ :: Integral i => i -> i -> i; n `mod_` 0 = n; n `mod_` d = n `mod` d
08:47:43 <lambdabot>  Defined.
08:48:05 <ski> @let divides :: Integral i => i -> i -> Bool; d `divides` n = n `mod_` d == 0
08:48:06 <lambdabot>  Defined.
08:48:50 <ski> > evalCont $ do n <- every [4,6,8,9,10]; d <- L.some [1 .. n]; return (d `divides` n && d `notElem` [1,n])
08:48:51 <lambdabot>   True
08:48:57 <ski> > evalCont $ do n <- every [4,6,8,9,10,11]; d <- L.some [1 .. n]; return (d `divides` n && d `notElem` [1,n])
08:48:58 <lambdabot>   False
08:49:35 <ski> mm_freak : you are possibly right, there ..
08:50:57 <ski> FunctorSalad : do you understand those examples of `Cont' ?
08:51:20 <mm_freak> > runStateT (fix $ \r -> r >> modify (:1)) []
08:51:21 <lambdabot>   Occurs check: cannot construct the infinite type: s = [s]
08:51:28 <mm_freak> > runStateT (mfix $ \r -> r >> modify (:1)) []
08:51:29 <lambdabot>   Occurs check: cannot construct the infinite type: s = [s]
08:51:52 <ski> s/:1/1:/ ?
08:51:59 <mm_freak> d'oh
08:52:09 <mm_freak> > runStateT (mfix $ \r -> r >> modify (1:)) []
08:52:10 <lambdabot>   Couldn't match expected type `m a' against inferred type `()'
08:52:13 <mm_freak> > runStateT (fix $ \r -> r >> modify (1:)) []
08:52:14 <lambdabot>   No instance for (GHC.Show.Show (m ((), [a])))
08:52:14 <lambdabot>    arising from a use of `M53...
08:52:24 <mm_freak> aaaaand yes
08:52:26 <mm_freak> no T
08:52:33 <mm_freak> > runState (fix $ \r -> r >> modify (1:)) []
08:52:34 <lambdabot>   ((),[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:52:39 <mm_freak> finally
08:52:48 <mm_freak> anyway, you can't do that with CPS-based StateT
08:53:02 <mm_freak> you'll get bottom
08:53:41 <mm_freak> i think that's a strong indication that CPS inherently depends on the order of actions
08:54:34 <mm_freak> i'll get coding now, let's see what the result will be
08:54:52 <ski> yeah .. like i said, you're possibly (or even probably :) right
08:56:42 <FunctorSalad> I'm.... not sure whether I understand :(
08:56:53 <FunctorSalad> beyond unfolding the definitions
08:57:43 <ski> i just wanted to show some examples of continuation effects (in this case depending on the result type being `Bool')
08:58:21 <ski> i suppose i should say "delimited/composable/sub- contination effects", since this isn't expressible with just `callCC'
08:58:24 <FunctorSalad> should I think about 'Cont Bool' specifically rather than about forall r. Cont r?
08:58:33 <mm_freak> FunctorSalad: fire up GHCi and try this:
08:58:33 <ski> yes
08:58:49 <ski> FunctorSalad : you can't do the above thing if you use `forall r. Cont r a'
08:59:14 <mm_freak> > let abort = Cont . const . return in runContT (lift (putStrLn "blah") >> abort () >> lift (putStrLn "blubb")) return
08:59:15 <lambdabot>   Couldn't match expected type `Control.Monad.Cont.ContT
08:59:15 <lambdabot>                     ...
08:59:29 <mm_freak> > let abort = ContT . const . return in runContT (lift (putStrLn "blah") >> abort () >> lift (putStrLn "blubb")) return
08:59:31 <lambdabot>   <IO ()>
08:59:35 <mm_freak> the latter one =)
08:59:37 <ski> @type Cont . const . return
08:59:38 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => a1 -> Cont (m a1) a
08:59:38 <azaq23> is there a standard trim / strip function in haskell? I just keep bumping into that strip = f . f where f = reverse . dropWhile isSpace definition, but I can't find anything builtin
08:59:46 <ski> @type ContT . const . return
08:59:47 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => a1 -> ContT a1 m a
09:00:12 <mm_freak> FunctorSalad: that shows one of the simpler CPS effects
09:00:17 <mm_freak> aborting computations
09:00:37 <mm_freak> but ContT can not only abort them, but also restart them, repeat them, pass them around, etc.
09:00:39 <FunctorSalad> still looking at the one following mod_ ;)
09:00:57 <yrlnry> I do not like that when ghci says something like "Use -XMultiParamTypeClasses" I can never remember the syntax of the {-# ... #-} thing to put in the source file to get the effect of -XWhatever.
09:01:04 <mm_freak> FunctorSalad: wait, i know a good introduction to CPS
09:01:08 <yrlnry> It's a dumb problem, but a real one.
09:01:08 <ski> .. as well as just abort to some specific position, instead of aborting all of the computation
09:01:13 <mm_freak> even though it uses python, you can translate this to haskell easily
09:01:32 <ski> FunctorSalad : `divides' was just convenience
09:02:25 <mm_freak> FunctorSalad: http://www.ps.uni-saarland.de/~duchier/python/continuations.html
09:02:43 <ski> (yrlnry : `{-# LANGUAGE MultiParamTypeClasses #-}' (separating with commas for more than one) .. but yes, it might be nice if it gave a suggestion in terms of this latter form, instead)
09:03:19 <yrlnry> ski:  thanks.  I think I'll save that in ~/src/haskell/COMMENT or something.
09:04:33 <ski> FunctorSalad : monochrom's <http://www.vex.net/~trebla/haskell/cont-monad.xhtml> could be nice, as well
09:06:33 <yrlnry> I have class Functor f => Addressable f a b ... .  Then I put type Pair a = (a,a), and I want to say Addressable Pair p q, but ghc says "Type synonym `Pair' should have 1 argument, but has been given 0".  
09:06:45 <mm_freak> i'm making my monads instances of Functor, Applicative and Monad and if applicable also of Alternative and MonadPlus
09:06:49 <mm_freak> anything else?
09:07:06 <yrlnry> Did I need to define Addressable in terms of (f b) a b  instead?  But that's nonlinear.
09:07:07 <mm_freak> (which is in base)
09:07:54 <FunctorSalad> mm_freak: hmm that python link is about the imperative notion of continuations I suppose? I'm trying to understand them in terms of types and algebra right now ;)
09:08:01 <FunctorSalad> not operationally
09:08:10 * ski recalls <http://www.madore.org/~david/computers/callcc.html> as well ..
09:08:43 <mm_freak> FunctorSalad: once you understand the operational aspects, understanding the theory and types will be much easier =)
09:08:52 <FunctorSalad> (for which I found the idea of "explicit containing context" useful)
09:09:10 <ski> yrlnry : you can't make an instance for a type synonym like that, even if you use the type synonym in instances exception (whatever it was called)
09:09:13 <mm_freak> "explicit containing context" is a certain feature of CPS/Cont
09:09:16 <mm_freak> not the whole concept
09:09:25 <mm_freak> the concept itself is way simpler
09:09:26 <yrlnry> ski:  I needed a newtype, right?
09:09:37 <mm_freak> instead of returning a result you pass it to a continuation
09:09:38 <ski> yrlnry : i.e. you can't use `Pair' apart from in an application like `Pair ...'
09:09:50 <ski> yrlnry : yes, that would be the standard work-around
09:09:53 <mm_freak> so the identity function becomes:  id x k = k x
09:09:56 <yrlnry> ski:  Thanks.
09:10:00 <FunctorSalad> "abort x" is defined by "abort x >>= k = return x", no?
09:10:05 <mm_freak> and the type is:  id :: a -> (a -> r) -> r
09:10:11 <FunctorSalad> for all contexts k
09:10:26 <yrlnry> ski:  there's an extension somewhere that allows me to have ghc calculate a derived instance for Functor, isn't there?
09:10:29 <mm_freak> no, you can't define abort in terms of (>>=)
09:10:39 <ski> FunctorSalad : no, rather more like `runCont (abort x) k = x'
09:10:43 <Saizan> ski: DeriveFunctor
09:10:45 <yrlnry> Ah, it's called DeriveFunctor.
09:10:48 <yrlnry> How sensible.
09:10:51 <yrlnry> Saizan:  Thanks.
09:10:58 <mm_freak> abort x = MkCont $ \k -> x
09:11:00 <ski> Saizan : no, that's not the one i was thinking about ..
09:11:06 <mm_freak> or simply:  abort = MkCont . const
09:11:10 <chandru_in> How does take work especially when it is passed an expression which recursively generate an infinite series?  I'd happy to get even an URL which explains this.
09:11:13 <Saizan> ski: sorry, it was for yrlnry :)
09:11:22 <FunctorSalad> well I'm trying to go with my hypothesis that ContT gives you the ability to solve equations containing >>= ;)
09:11:22 <chandru_in> Google didn't help as I guess the terms are too generic
09:11:34 <mm_freak> in the world of CPS (without monadic clutter) the 'abort' function is nothing else than the const function
09:11:43 <FunctorSalad> mm_freak: I know you can't directly write "abort x >>= k = return x" in haskell when not defining >>= ;)
09:11:45 <mm_freak> ignore the continuation and just return the result right away
09:12:06 <mm_freak> abort x k = x
09:12:16 <FunctorSalad> ski: but if the 'return' is in ContT?
09:12:35 <FunctorSalad> mm_freak: that's the pure Cont
09:12:48 <ski> (yrlnry,Saizan : `TypeSynonymInstances' was the one i was thinking of)
09:13:05 <mm_freak> yes, abort in ContT models this function:  abort x k = return x
09:13:24 <mm_freak> ignore the continuation and just return the result =)
09:13:34 <ski> yrlnry : btw, you can also consider `data Pair a = MkPair a a' as an alternative to `newtype Pair a = MkPair (a,a)' ..
09:13:46 <mm_freak> with the clutter added it becomes:  abort x = MkContT $ \k -> return x
09:14:04 <FunctorSalad> depends on whether k :: a -> m r      or     k :: a -> ContT m r             I suppose
09:14:07 <yrlnry> ski:  Any reaason to prefer one or the other?
09:14:24 <FunctorSalad> abort x >>= k = return x       seems appropriate for the latter
09:14:47 <chandru_in> I expected to be non-terminating but it was not!  I understand it is related to lazy evaluation.  But I can't visualize the flow
09:14:51 <FunctorSalad> *ContT r m b
09:15:50 <min> :r
09:15:51 <mm_freak> FunctorSalad: the continuation isn't captured by (>>=), so your line of thought may mislead you
09:15:57 <min> oh
09:16:13 <ski> mm_freak : btw, imo, if we have `newtype Cont o a = MkCont {runCont :: (a -> o) -> o}', we should be able to define like `runCont (abort x) k = x' instead of like `abort x = Cont (\k -> x)' :)
09:16:19 <yrlnry> I guess with data Pair a = MkPair a a I have the option of using MkPair partially evaluated.
09:16:23 <yrlnry> That could be useful.
09:16:35 <FunctorSalad> mm_freak: hmm the (>>=) would be flip ($) in the pure case
09:16:37 <ManateeLazyCat> Haha, time stamp finish : http://www.flickr.com/photos/48809572@N02/4992961239/lightbox/
09:16:49 <azaq23> no strip / trim?
09:16:57 <Saizan> chandru_in: it goes roughly like this http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=take+5+(iterate+(%2B1)+1)
09:17:10 <mm_freak> ski: i don't understand, do you mean to blur the line between returning and aborting?
09:17:28 <ski> chandru_in : it works no differently on infinite lists than on finite lists. only as many elements of the list which are demanded are actually computed. (though in some cases, computing some elements may demand other/more elements of the list to be computed)
09:17:37 <mm_freak> FunctorSalad: flip (.)
09:17:39 <FunctorSalad> hmm I'm confusing myself with all the bi-duality embeddings ;)
09:17:49 <FunctorSalad> (\x -> ($x))
09:18:06 <mm_freak> but even that's not accurate
09:18:20 <FunctorSalad> mm_freak: >>= is flip ($) in the identity monad
09:18:23 <ski> FunctorSalad : no `abort x >>= k = return x' is semantically wrong. `runCont (abort x) k = x' however isn't (but is not allowed in current haskell)
09:18:28 <mm_freak> you should really focus on Cont for now, i.e. the non-transformer
09:18:51 <chandru_in> Saizan, That page is a mandatory bookmark for Haskell newbies.  Thanks.
09:19:07 <mm_freak> FunctorSalad: you're missing something
09:19:17 <FunctorSalad> apparently.
09:19:22 <mm_freak> there is only the identity monad up to isomorphism in haskell
09:19:33 <FunctorSalad> well, I'm ignoring newtypes
09:19:35 <Saizan> chandru_in: well, with true lazy evaluation the results of the intermediate +1 additions will be shared rather than recomputed
09:19:39 <ski> yrlnry : there is no "partial evaluation" here (don't confuse that term with "partial application" .. and you can just as well partially apply the other as `MkPair . (,) x'
09:20:05 <chandru_in> ski, I understood that.  What confused me is that I pass it a function which infinitely recurses.  I just didn't know how take can limit my function to compute just what it wants.
09:20:07 <Saizan> chandru_in: but it should still show how it manages to terminate :)
09:20:11 <mm_freak> FunctorSalad: ok, then don't bother with Id at all, just use Cont =)
09:20:20 <mm_freak> FunctorSalad: you know what really helps?  implement the Cont monad yourself =)
09:20:25 <mm_freak> not ContT, just Cont
09:20:48 <FunctorSalad> I did that and callCC even, but it's too easy because there's just one way to fit the types together
09:20:51 <mm_freak> if you can do that without help, then you've understood Cont as well as CPS
09:20:55 <ski> yrlnry : if you're going to use the "raw" pairs in other parts of the program, then `newtype Pair a = MkPair (a,a)' could be nicer .. otherwise, it can be syntactically nicer to just have to use a single `MkPair' instead of both `MkPair' and `(,)' (but at run-time, there's no difference)
09:20:58 <FunctorSalad> mm_freak: so I still didn't have to think
09:21:11 <mm_freak> yes, then look at your implementation
09:21:26 <mm_freak> you've just invented CPS
09:21:45 <FunctorSalad> ski: oh it's semantically wrong?
09:21:53 <mm_freak> if you really want to think, try implementing 'goto' using your Cont
09:21:58 <FunctorSalad> *think*...
09:21:58 <mm_freak> yes, it's possible
09:22:04 <chandru_in> Saizan, Your statement didn't make any sense to me.  I'll try to understand as I better understand haskell.  For now that site helps a lot
09:22:23 <mm_freak> you can implement both labels and the good old goto or even a more powerful one (a goto with value)
09:22:54 <ski> mm_freak : no, i mean that just as we can define `foo x = ..x..' instead of `foo = \x -> ..x..', i.e. defining `foo' in terms of how we *use* it, rather than in terms of what it is; it would be nice to be able to define values in `newtype's in terms of what the deconstructor applied to the value is (i.e. in terms of use)
09:22:56 <mm_freak> this should give you a good sense of how CPS works and what you can do with it
09:23:02 <camio> @seen conal
09:23:03 <lambdabot> Unknown command, try @list
09:23:03 <preflex>  conal was last seen on #haskell 2 days, 14 hours, 29 minutes and 35 seconds ago, saying: :)
09:23:33 <mm_freak> ski: i see
09:23:51 <ski> mm_freak : so, since `abort x = MkCont (\k -> x)' it also holds that `runCont (abort x) = \k -> x' (since `MkCont' and `runCont' are inverses); and then that is the same as `runCont (abort x) k = x'
09:23:53 <mm_freak> ski: but i don't see how that's possible in haskell, so i guess, it's just a theoretical thought?
09:24:09 <FunctorSalad> Cont x >>= f   =   x (\a -> Cont (\k -> runCont (f a) k)) or some such
09:24:46 <mm_freak> ski: i don't think we can make generalized n+k patterns that go that far =)
09:25:06 <ski> mm_freak : of course, one would need some way of disambiguating *which* part of a defining equation is being defined .. possibly by using some special syntax for de(con)structors/selectors like `runCont' .. like `.runCont' or `#runCont' or `RunCont' or whatever
09:25:08 <mm_freak> without turning haskell into a full-fledged CAS and probably the most powerful in the world
09:25:20 <FunctorSalad> ski: wait isn't that just pattern matching for newtypes?
09:25:26 <ski> mm_freak : also, imo this isn't really related to view patterns at all
09:25:28 <chandru_in> Saizan, that page says I have a parsing error in a script which runs fine with runghc.  I'm defining a function and using it in that file/
09:25:55 <mm_freak> ski: well, if you could compare functions…
09:26:23 <FunctorSalad> ski: ah nvm you're pattern-matching on the *runCont*
09:26:34 <Saizan> chandru_in: in steps 14..16 it computes reduces the second element of the list (1+1) to 2, with true lazy eval it should have also updated the ((+ 1) 1) subexpression in the second argument of iterate, because they actually come from the same initial fuction application that first appeared in step 6
09:26:45 <Saizan> chandru_in: err, step 5 i mean
09:26:52 <FunctorSalad> mm_freak: it seems unproblematic, since newtype deconstructors are guaranteed to be injective
09:26:59 <ski> chandru_in : the point is that arguments to functions aren't evaluated by the function call (by itself) .. only if the function demands to know (some parts of) the arguments will they (/ those parts) be evaluated .. and only those parts will be evaluated
09:27:13 <FunctorSalad> runFoo x = y    <->      x = Foo y
09:27:14 <FunctorSalad> ;)
09:27:30 <chandru_in> This is the code I'm trying to evaluate in that page.  http://is.gd/fc263
09:27:30 <Saizan> chandru_in: it doesn't accept all of haskell, it's still in alpha
09:28:37 <ski> FunctorSalad : yes, if you take `abort x >>= k = return x', then we can derive `k1 x  =  return x >>= k1  =  (abort x >>= k0) >>= k1  =  abort x >>= \y -> k0 x >>= k1  =  return x' .. which doesn't seem good :)
09:28:37 <FunctorSalad> how about a "definjective f" statement ;o though that's nothing that viewpatterning on the left-inverse of f
09:28:45 <chandru_in> ski, So when it tries to know the first element in series it invokes my function which recurses infinitely, right?
09:28:49 <Saizan> chandru_in: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+%0D%0A++fibon+%3D+[0,+1]+%2B%2B+(fibonGen+0+1)%0D%0A++fibonGen+a+b+%3D+[c]+%2B%2B+(fibonGen+b+c)%0D%0A++++where%0D%0A++++++++c+%3D+a+%2B+b%0D%0Ain+(take+5+fibon)
09:28:50 <FunctorSalad> *nothing [else] than
09:29:09 <ski> FunctorSalad : the point being that `k' in 'ma >>= k' doesn't need to be the *whole* continuation of `ma' .. usually it's only an initial part of it
09:29:52 <chandru_in> Saizan, thanks.  Will trace through that and try to understand my self
09:30:20 <ski> FunctorSalad(,mm_freak) : no it's not pattern-matching .. i tentatively call it "message-dispatching" :)
09:30:30 <ManateeLazyCat> Night all. :)
09:30:37 <chandru_in> Saizan, Out of curiosity.  Can that piece of code be c onsidered idiomatic haskell?
09:30:39 <ski> mm_freak : sorry, "compare functions" ?
09:31:18 <FunctorSalad> ski: the defining-stuff-with-deconstructors-on-the-LHS?
09:31:37 <FunctorSalad> seems like pattern matching in the generalized sense of matching on arbitrary injective functions...
09:31:57 <mm_freak> ski: nevermind
09:32:18 <Saizan> chandru_in: i'd use "a + b :" rather than "[c] ++"
09:32:53 <FunctorSalad> ski: your y got lost there (in your derivation of my mistaken 'abort' definition), but that's likely besides the point
09:33:08 <chandru_in> hmmm makes sense.  I just tried to avoid repeating a+b.
09:33:12 <FunctorSalad> \y -> k0 y >>= k1       I suppose
09:33:16 <mm_freak> mfix f = let x = f (runId x) in x  -- is this sensible?
09:33:25 <chandru_in> ah very interesting.  Finally understood how it works.  :)  Thanks a ton Saizan and ski.
09:33:52 <Saizan> chandru_in: ah, sorry, didn't spot that, i'd still use "c :"  though :)
09:34:02 <mm_freak> for the identity monad
09:34:17 <chandru_in> ok
09:35:08 <ski> chandru_in : no, when it tries to know the first element in the list, it invokes your function, but *only* evalues as much as it needs to determine whether the list is empty or non-empty (yielding a first element and a tail list of the rest of the elements (both unevaluated, so far)) .. so, unless your function recurses infinitely "before" deciding whether the output list will be empty or non-empty, it will not hang
09:35:15 <FunctorSalad> ski: hmm my confusion started with calling that variable 'k', hehe
09:35:21 <FunctorSalad> it isn't in fact a k
09:35:56 <ski> FunctorSalad : yes .. and, sorry, it should be s/k0 x/k0 y/, yes
09:36:54 <ski> mm_freak : yes, that's reasonable
09:37:03 <ski> (i would use `where', though)
09:37:16 <FunctorSalad> maybe just evaluate it ;)      abort x >>= f      =       abort x (\xx -> ContT (\k -> runContT (f xx) k))
09:37:20 <mm_freak> ski: found a better one
09:37:25 <mm_freak>   mfix f = Id $ fix (runId . f)
09:37:34 <FunctorSalad> but isn't that = return x?
09:37:50 <FunctorSalad> since 'abort x' ignores the k...
09:38:09 <quicksilver> ski: I wonder if SpecConstr makes [c] ++ generate the same code as c :
09:38:17 <FunctorSalad> hmm my >>= there is mistaken for ContT
09:38:25 <chandru_in> ski, yup and understood how the execution flows with the help of Saizan's link.  For someone with only imperative programming background it is very interesting.
09:38:27 <ski> mm_freak : `mfix f = fix (f . runId)' seems better to me then (no need to use both `runId' and `MkId')
09:38:43 <FunctorSalad> abort x >>= f     =       ContT (\k -> abort x (\xx -> runContT (f xx) k))     right?
09:39:09 <ski> quicksilver : heh, i don't know .. (but why are you pondering-to me ?)
09:39:19 <FunctorSalad> hmm and the abort x has to be newtype-unwrapped too to be consistent
09:39:57 <mm_freak> ski: indeed
09:40:41 <ski> chandru_in : definitely :) .. and you can see how this can help with modulary, as well : instead of having to pass in a number telling how many elements to generate, cluttering the algorithm, you can just "generate" an infinite list, and let the user/caller determine how many elements of that list will be used/computed (and you don't even need to decide that in a single place in the program)
09:41:37 <ski> chandru_in : you might be interested to read a paper called "Why Functional Programming Matters" .. which takes up this thing, amongst others
09:41:40 <FunctorSalad> maybe the free monad would be of use for experimentation ;)
09:41:51 <FunctorSalad> where did I put it...
09:41:53 <chandru_in> ski, Sure will do that.
09:42:09 <FunctorSalad> hmm or maybe not - it wasn't showable :(
09:42:40 <FunctorSalad> is there some way to make a showable free monad? using TH maybe
09:43:25 <FunctorSalad> it boils down to the more general problem of introspecting function values
09:43:56 <ski> FunctorSalad : `runCont (abort x) k' becomes `x' there, not `runCont (return x) k'
09:44:36 <ski> FunctorSalad : the latter `abort x >>= f     =       ...' is correct
09:45:01 <FunctorSalad> ok, but the latter seems to reduce to "ContT (\k -> return x)"
09:45:23 <FunctorSalad> which isn't "return x".... aha!
09:45:27 <FunctorSalad> =)
09:45:45 <quicksilver> ski: because you begin with 's' like saizan does, and I'm inept.
09:46:20 <ski> mm_freak,FunctorSalad : another example of this "message-dispatching syntax" would be `data Stream a = Head :: a & Tail :: Stream a', with `repeat :: a -> Stream a; Head (repeat a) = a; Tail (repeat a) = repeat a' and `from :: Enum e => e -> Stream e; Head (from e) = e; Tail (from e) = from (succ e)'
09:46:52 <ski> quicksilver : heh, i suspected that (the former ! ;) .. no worries
09:47:10 <lispy> copumpkin: that agda type error may have been a precedence problem.  glguy helped me a bit and he added parens to get around that error (but ran into new ones and I haven't understood his fix for those yet)
09:47:55 <copumpkin> ah :) glad you're making progress though!
09:48:05 <copumpkin> seemed like a bit of a hefty example for just getting started with, though
09:49:02 <FunctorSalad> ski: seems like a co-ism *vague* =)
09:49:28 <FunctorSalad> defining things in terms of how what they'll do when observed...
09:49:35 <lispy> copumpkin: Well, I've studied a tiny bit of Isabelle (we had a course here) and used GADTs in Haskell a fair bit.  Oh and I've read the first chapters of the official tutorial a few times.  So I'm a weird place as a beginner.
09:49:48 <copumpkin> ah
09:49:58 <lispy> copumpkin: I need examples to get me going and force me to learn things
09:50:01 <copumpkin> it can still be pretty hair-raising, even with that kind of experience, I think
09:50:10 <FunctorSalad> (just made "co-ism" up, meaning "related to final coalgebras and all that")
09:50:29 <copumpkin> mostly grasping dependent pattern matching and complex family indices, I think
09:50:43 <copumpkin> but you may have an easier time at it than I did/am :)
09:50:44 <ski> FunctorSalad : hm, ok .. anyway, we already use `f x = ..x..' instead of `f = \x -> ..x..' all the time, so there is precedent
09:51:08 <FunctorSalad> that seems kinda more fundamental
09:51:15 <FunctorSalad> it's .... the nature of functions? ;)
09:51:21 <lispy> copumpkin: oh make no mistake, my understanding is currently very shallow and I need lots of help :)
09:51:40 <ski> (FunctorSalad : including using `f (Foo x) = ..x..; f (Bar y z) = ..y..z..' instead of `f xyz = case xys of Foo x -> ..x..; Bar y z -> ..y..z..')
09:52:19 <ski> FunctorSalad : yes, and imo, its in the nature of coinductives / records to be defined in terms of eliminations as well :)
09:52:30 <ski> s/its/it's/
09:52:39 <FunctorSalad> ski: now that I look at it again, your funny data declaration there is probably coalgebra pseudocode
09:53:06 <ski> FunctorSalad : indeed it was
09:53:44 <FunctorSalad> makes sense to write the destructors in capital letters for those...
09:53:45 <ski> FunctorSalad : but using the same idea for `newtype's, which are sortof trivially both inductives and inductives seems a useful special case in itself
09:55:08 <FunctorSalad> ski: you can formulate the coinduction principle as a function though... like unfoldr
09:56:06 <FunctorSalad> other people want to get rid of (primal) pattern matching syntax in favour of fold functions, you're kinda doing the opposite ;)
09:56:42 <dolio> Folds don't correspond to pattern matching for coinductive types.
09:56:55 <FunctorSalad> but unfolds do no?
09:57:02 <dolio> No.
09:57:05 <ski>   (ma >>= amb) `runState` s0 = (b,s2)
09:57:08 <ski>     where
09:57:16 <FunctorSalad> dolio: hmm?
09:57:17 <ski>     (a,s1) =  ma   `runState` s0
09:57:18 <ski>     (b,s2) = amb a `runState` s1
09:57:22 <ski> vs.
09:57:26 <ski>   ma >>= amb = State $ \s0 ->
09:57:29 <ski>     let (a,s1) =  ma   `runState` s0
09:57:33 <dolio> unfolds are how you construct coinductive types.
09:57:34 <ski>         (b,s2) = amb a `runState` s1
09:57:34 <ski>      in (b,s2)
09:57:42 <FunctorSalad> dolio: oh right =)
09:58:00 <dolio> You destruct them by one-step observations that are dual to constructors for inductive types.
09:58:03 <ski> FunctorSalad : which of those two styles do you prefer to read ? .. i know which one i consider more readable/elegant
09:59:15 <FunctorSalad> ski: how about the version that uses only 'State'... is that really worse?
09:59:16 <ski> (and ignore the unfolding what wants to get done in this case ..)
09:59:26 <dolio> However, ski's 'Head (f x y z) = ...' is analogous to pattern matching.
09:59:42 <ski> FunctorSalad : imo, yes
09:59:57 <dolio> Or, it's dual to pattern matching, I think.
10:00:10 <ski> dolio : yes. i tentatively call it "message-dispatching syntax" :)
10:00:22 <dolio> Because it's defining 'f x y z = unfold ...' by specifying what destructors will do on 'f x y z'.
10:01:02 <dolio> While pattern matching defines 'f x y z = fold ...' by defining what f does at each constructor.
10:01:10 <FunctorSalad> State ma >>= amb = State (\s -> let { State (a,s1) = ma s ; State (b,s2) = f a } in (b,s2) })
10:01:26 <ski> (alluding to an object definition dispatching on messages (i.e. selectors/projections/de(con)structors) in OO)
10:01:46 <FunctorSalad> though yours has the advantage of shuffling the s to the LHS too
10:02:16 <ski> FunctorSalad : imo, that's more ugly since we need to introduce an explicit `\s -> ', instead of being able to rely on the `foo s = ..s..' style of definition
10:02:29 <FunctorSalad> nested where clauses? ;)
10:02:41 <FunctorSalad> State foo       where       foo s = (b,s2) where      .....
10:02:55 <ski> FunctorSalad : `State ma >>= amb = State mb where mb s0 = ..s0..' is somewhat better, but i still prefer the other elimation-focused version :)
10:02:55 <FunctorSalad> but granted, that's an extra name
10:04:32 <ski> (FunctorSalad : btw, just checking, you saw the `Stream' example a bit up, yes ?)
10:06:09 <FunctorSalad> yes
10:06:26 <ski> in many cases (not all), i think it would be more readable to say
10:06:37 <ski>   Foo (frob x) = ..x..
10:07:07 <ski>   Bar (frob x) (Y0 y0) = ..y0..
10:07:11 <ski>   Bar (frob x) (Y1 y1) = ..y1..
10:07:18 <ski>   Baz (frob x) z = ..z..
10:07:21 <ski> instead of
10:07:29 <ski>   frob x = Rec
10:07:35 <ski>     { foo = ..x..
10:07:44 <ski>     , bar = \y -> case y of
10:07:59 <ski>         Y0 y0 -> ..y0..
10:08:03 <ski>         Y1 y1 -> ..y1..
10:08:11 <ski>     , baz = \z -> ..z..
10:08:12 <ski>     }
10:08:30 <Funktorsalat> got discoed between <ski> (FunctorSalad : btw, just checking, you saw the `Stream' example a bit up, yes ?) --- and --- <ski>   Bar (frob x) (Y1 y1) = ..y1.. 
10:10:33 <Funktorsalat> wait, 'frob'? ;)
10:10:45 <Funktorsalat> is that metasyntactic or 'frobenius'?
10:10:46 <ski> abbreviation for "frobnicate"
10:11:04 <ski> (so, yes, metasyntactic)
10:11:04 <Funktorsalat> glad I'm not missing a numbertheoretical algo then ;)
10:11:33 <ski> (and obviously all cases, not just the first, may use `x' ..)
10:11:40 <dolio> This is why you should stick to foo, bar, baz and quu+x.
10:12:03 <ski> yeah, but i wanted to set "frob" apart from that standard sequence
10:12:23 <Funktorsalat> dolio: 'gazonk' isn't part of the canon?
10:12:29 <ski> (and i think of "frob(nicate)" as definitely a verb, as opposed to the others)
10:12:39 <dolio> Is it? Not sure I've heard gazonk before.
10:12:50 <Funktorsalat> 'gadget's are ok too I think, and widgets if it's obvious that they're not actually widgets
10:12:51 <dolio> I kind of like blorf, too.
10:12:57 <Funktorsalat> :)
10:19:55 <mm_freak> interestingly i found IdT much more difficult to write than ContT
10:20:38 <c_wraith> I'm confused by IdT
10:20:42 <mm_freak> but maybe that's just because i'm thinking in CPS
10:20:57 <mm_freak> c_wraith: what are you confused about?
10:21:01 <Funktorsalat> IdT m x = IdT (m x)? o_O
10:21:08 <mm_freak> Funktorsalat: yeah
10:21:09 <c_wraith> newtype IdT m a = IdT (M a)
10:21:19 <c_wraith> err, minus spurious caps
10:21:20 <mm_freak> s/M/m/, but yes
10:21:31 <mm_freak> newtype IdT m a = IdT { runIdT :: m a }
10:21:33 <mm_freak> actually
10:22:50 <Funktorsalat> mm_freak: huh...? how could there any difficulty in writing [instances for, I assume] that?
10:22:52 <ski> what is difficult to write about that ?
10:23:11 <mm_freak> i had to think twice to implement (>>=)
10:23:29 <mm_freak>   IdT c >>= f = IdT $ c >>= runIdT . f
10:23:33 <Funktorsalat> IdT x >>= (IdT . f) = IdT (f x)
10:23:36 <Funktorsalat> ;)
10:23:46 <ski> Funktorsalat : if only .. :)
10:23:53 <mm_freak> Funktorsalat: if that code were valid, yes =)
10:24:09 <Funktorsalat> composition with injective functions is injective, so o_O
10:24:27 <Funktorsalat> err, if the injective one is on the left
10:24:28 <mm_freak> but (.) is still an ordinary function and not a data constructor
10:24:35 <ski> Funktorsalat : complain to the GHC developers ! ;)
10:24:35 <ddarius> All it takes is a little higher order unification.  Higher order pattern unification is actually, probably enough.
10:24:41 <Funktorsalat> on the right you get "composition with surjective functions is injective"
10:24:57 <Funktorsalat> which CT generalizes to be the definition of 'epimorphism' incidentally
10:25:07 <mm_freak> on the other hand i might ask other people:  what's so difficult about ContT? ;)
10:27:27 * ski . o O ( `IdT a >>= (\a -> IdT (f a)) = IdT (f a)' )
10:28:23 <ski> (or even `IdT ?a >>= (\?a -> IdT b) = IdT b' :)
10:29:43 <mreh> is anyone familiar with the ArrowLoop instance in Yampa? I can't resolve the semantics of what it says with what I think it should be
10:29:52 <ski> (`b' having type `(?a :: a) => b', there)
10:30:22 <ski> mreh : what do you think it should do ?
10:31:37 * ski suspects mreh might be confused that it builds a non-delayed, rather than delayed, loop
10:31:58 <mreh> 3:
10:32:09 <roconnor> ya, my experience is that arrow loop isn't so useful for delayed loops
10:32:17 <roconnor> (limited experience)
10:32:19 <zygoloid> presumably ArrowLoop is just for value recursion, like MonadFix
10:33:27 <ski> well, you could combine it with an explicit `delay' construction, i think
10:33:35 <mm_freak> hmm, this is odd
10:33:54 <mm_freak> i can make 'ContT r m' a functor without m being a functor
10:33:59 <mreh> okay, so it is just value recursion
10:34:00 <mm_freak> does that make sense?
10:34:23 <mm_freak> instance Functor (ContT r m) where fmap f (ContT c) = ContT $ \k -> c (\x -> k (f x))
10:34:34 <mreh> I was imagining it was for feedback loops
10:34:41 <ski> mm_freak : yeah, it's wonderful :) .. you can also make `ContT r m' a monad without `m' being a monad
10:35:03 <mm_freak> ski: interesting
10:35:05 <ski> mm_freak : the `Monad' constraint on `m' will appear on the `evalContT' function
10:35:17 <mm_freak> ah, yes, that makes sense now
10:35:19 <ski> mm_freak : this is related to the yoneda lemma
10:35:24 <roconnor> some how right assocating all binds makes functors into monads
10:35:31 <ski> @quote Yoneda
10:35:31 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
10:35:31 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:36:35 <ski> mreh : so you either need to combine `loop' with some `delay' combinator which delays (and gives some initial values, possibly) .. or use some specific variant of `loop' which has delaying built-in
10:38:07 <ddarius> roconnor: You can't make any kind of loop without ArrowLoop.
10:38:35 <mm_freak> ski: i haven't found any good introduction into category theory, which didn't scare me off after two pages
10:38:38 <Funktorsalat> "cutting-edge enterprise solutions such as the identity transformer"
10:38:53 <roconnor> ddarius: but you have to put the delays in by hand
10:38:59 <mm_freak> ski: the problem is that most of them keep things abstract and don't show any applications in haskell (or programming at all)
10:39:01 <ddarius> roconnor: Of course.
10:39:10 <roconnor> and it won't atomatically figureout which connects are backwards
10:39:11 <mrek> DA!
10:39:42 <mm_freak> in fact reading millions of definitions before seeing a single application makes me tired, and that's why i never really learned CT
10:40:08 <roconnor> mm_freak: ya, I've found it easier to see CT as a generalization of type theory
10:40:13 <roconnor> lets me slowly sink into it
10:40:59 <mreh> is CT like, "new"
10:41:10 <ski> (mreh : Vy govorite po-russki ?)
10:41:23 <dolio> How new do you have to be to qualify as "new"?
10:41:34 <roconnor> CT isn't 3000 years old
10:41:47 <mreh> well, maths has this lag between being discovered and people being able to teach it
10:41:50 <mreh> or learn it
10:41:54 <dolio> Is lambda calculus new?
10:42:03 <mreh> call it morphic resonance
10:42:08 <roconnor> LC is older than CT?
10:42:10 <mreh> yes, I suppose
10:42:18 <dolio> I think they're around the same age.
10:42:26 <ski> mreh : it started being developed aroud 1950 or something like that, i think (maybe 10 or 20 years earlier, not sure)
10:43:05 <nejucomo> I have a type "Exceptional a" and I want to define an instance of Monad for "IO (Exceptional a)".  Is this possible?
10:43:17 <mreh> ^_^
10:43:17 <dolio> I guess CT is newer.
10:43:17 <Funktorsalat> mm_freak: it's a language, not really a means to prove things you absolutely couldn't prove before
10:43:26 <mauke> nejucomo: no, that has the wrong kind
10:43:29 <dolio> 1945, according to the wiki.
10:43:31 <mauke> nejucomo: and IO is already a monad
10:43:36 <Funktorsalat> mm_freak: gives you a framework in which to think about things
10:43:48 <Funktorsalat> not that great for actually calculating anything
10:43:56 <nejucomo> My first attempt was: type MExc a = IO (Exceptional a)
10:43:59 <MasseR> I have a condition that "Not all lines need to fit into memory" when reading files. Where should I look for more information
10:44:05 <nejucomo> -then: instance Monad MExc where ...
10:44:10 <roconnor> It's good for generalizing proofs that used to be specialized
10:44:24 <mm_freak> Funktorsalat: yes, i realized that, but introductions are still too dry and still not connected to haskell in any way
10:44:31 <nejucomo> But instance doesn't seem to like type synonyms constructed this way.
10:44:36 <Funktorsalat> roconnor: yeah, so maybe it's a tool for posing problems you couldn't pose before ;)
10:44:39 <roconnor> MasseR: lazyIO, or better Iteratees
10:44:46 <mm_freak> i find the only way to learn haskell-related CT is by reading category-extras source code
10:44:57 <mm_freak> and most of it makes my head hurt
10:45:12 <nejucomo> mauke: Is it not possible to have "layered" Monads?
10:45:54 <Funktorsalat> mm_freak: that's actually a bit more confusing in the locations where it turns both (object-level) morphisms and (background-level) functions into the same thing
10:45:57 <Funktorsalat> (haskell functions)
10:46:17 <mauke> nejucomo: not like that because IO is already a monad
10:46:23 <roconnor> nejucomo: you need an distirbution funciton Exceptional (IO a) -> IO (Exceptional a)
10:46:32 <roconnor> satifying various laws
10:46:39 <nejucomo> Let me pop up to my goal:  I want to sequence: IO (Exceptional a) -> (a -> IO (Exceptional b)) -> IO (Exceptional b)
10:46:43 <Funktorsalat> mm_freak: but yeah it's very dry ;)
10:46:59 <ski> nejucomo : `newtype MExc a = MkMExc (IO (Exceptional a))'
10:47:15 <roconnor> nejucomo: do you have such a function?
10:47:27 <mm_freak> Funktorsalat: the question i always ask myself is:  if they used other words for all that CT stuff, would it be easier to understand?
10:47:29 <MasseR> roconnor: Thanks
10:47:48 <mm_freak> of course it's difficult to come up with a synonym for 'monad', which is any clearer =)
10:47:52 <mreh> burritos?
10:48:01 <mm_freak> space suits
10:48:08 <Funktorsalat> mm_freak: hmm they do use pretty standard words in some places
10:48:09 <nejucomo> roconnor: I think you're correct about distribution…  I do have such a function but I can't hammer it into (>>=).
10:48:11 <Funktorsalat> "product" ;)
10:48:12 <ski> roconnor : i doubt that's what nejucomo is after :)
10:48:19 <roconnor> ski:  I think it is
10:48:25 <Funktorsalat> "sum" for coproduct sometimes even ;)
10:48:27 <roconnor> I think such a function likely exists
10:48:34 <mm_freak> Funktorsalat: yes, but as soon as you get to 'right kan extensions', well, my head explodes ;)
10:48:51 <mm_freak> and i always wonder where the left kan extensions are =)
10:48:53 <Funktorsalat> well yes, I haven't quite understood these yet either
10:49:14 <ski> roconnor : "I want to sequence: IO (Exceptional a) -> (a -> IO (Exceptional b)) -> IO (Exceptional b)" sounds like nejucomo just wants to make the composition into a monad, to me
10:49:22 <Saizan> mm_freak: iirc they are just the dual?
10:49:33 <Funktorsalat> there are several possible things you can flip there
10:49:35 <Funktorsalat> ;)
10:49:39 <roconnor> ski: yes, and the composition of two monads is a monad when there is a distribution function
10:49:45 <Saizan> i guess
10:50:01 <dolio> Where are you reading about Kan extensions? Certainly not in any introductory category theory book.
10:50:08 * hackagebot Fungi 1.0 - An interpreter for Funge-98 programming languages, including Befunge.  http://hackage.haskell.org/package/Fungi-1.0 (ThomasEding)
10:50:15 <ski> roconnor : .. oh, right, i just realized composition of monads being a monad depended on a distribution law .. ok
10:50:20 <Funktorsalat> dolio: cfwtm is supposed to be introductory ;)
10:50:24 <dolio> Unless, possibly, you're at the very end of Categories for the Working Mathematician.
10:50:24 <ski> s/realized/recalled/
10:50:27 <Funktorsalat> cftwm even
10:50:30 * Saizan suspects the definitions involves adjuctions
10:50:44 <ddarius> Saizan: Definition of what?
10:50:58 <Funktorsalat> Saizan: the one I saw uses an universal property, which are equivalent to adjunctions
10:50:59 <mm_freak> Saizan: i was joking actually, because i have no idea what a right kan extension is
10:51:08 * hackagebot haskeline 0.6.3 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.3 (JudahJacobson)
10:51:09 <Funktorsalat> though you'd need an even more sillily higher-order space to formulate the adjunction =)
10:51:12 <roconnor> nejucomo: okay, let's call the function dist.  We should be able to reason out the required bind
10:51:14 <mm_freak> i just know from edwardk's monads-ran library that you can use it to turn ordinary monads into CPS monads
10:51:29 <Funktorsalat> (since the universal property itself quantifies over functors here)
10:51:41 <nejucomo> ski, roconnor: So I have the given function, but in order to make a Monad instance, I tried: "data ExOp a = IO (Exceptional a)"
10:51:43 <Saizan> ddarius: kan extensions
10:52:08 <dolio> Most definitions I've seen of Kan extensions use (co)ends.
10:52:26 <ski> nejucomo : i would use `newtype', and you still need to have a data constructor name, as i exemplified above in `newtype newtype MExc a = ...'
10:52:39 <ddarius> Kan extensions are "more powerful" than adjunctions.  However, if you have all Kan extensions in a category, there is a nice presentation in terms of adjunctions.
10:52:41 <roconnor> nejucomo: x >>= f = x >>= (liftM join . dist . liftM f)
10:52:46 <Funktorsalat> universal properties, the homset isomorphism version and the triangle identities are all equivalent ways to define the same thing =)) 
10:52:50 <roconnor> nejucomo: that is my guess
10:53:03 <roconnor> nejucomo: oh yes, you should make a new type like ski says
10:53:04 <nejucomo> How is newtype different than type?
10:53:14 <roconnor> nejucomo: newtypes can have new instances
10:53:27 <roconnor> newtypes are more like data than type
10:53:28 <Funktorsalat> aren't they the initial solution to "F = G . ?" ?
10:53:30 <mm_freak> Funktorsalat: how did you learn CT?
10:53:34 <Funktorsalat> or final, or ? . G ;)
10:53:38 <mm_freak> or others here
10:53:40 <ski> ddarius : "more powerful" in the sense of possibly existing even when adjunctions doesn't ?
10:53:42 <Funktorsalat> mm_freak: uni
10:53:53 <nejucomo> A newtype has the same constructors as the target type?
10:53:54 <mm_freak> hmm, ok
10:54:05 <nejucomo> Can I say: newtype Foo a b = (a, b)
10:54:10 <Saizan> no
10:54:16 <Saizan> you've to add a constructor there
10:54:18 <ddarius> Incidentally, if J is a functor, the functor creating left/right Kan extensions along J is Lan_J -| - o J -| Ran_J
10:54:21 <mm_freak> i have to learn this stuff myself unfortunately, so i need a learning source, which keeps me focused
10:54:24 <nejucomo> So how does newtype differ from data?
10:54:37 <ski> nejucomo : `type' just makes a synonym to an existing type. `data' and `newtype' constructs new types. to make instances of type classes, you (usually) want/need to make a new type
10:54:40 <nejucomo> Better yet, is there a webpage about this?
10:54:54 * nejucomo hoogles newtype.
10:55:04 <roconnor> nejucomo: newtype is more efficent than data, and has subtle strictness differences.
10:55:08 <Funktorsalat> mm_freak: *nod* I have problems with the 'keeping focused' part on my own too
10:55:10 <Saizan> nejucomo: the difference is that the constructor is not there at runtime
10:55:11 <nejucomo> hoogle is the wrong tool.  :-)
10:55:21 <ddarius> ski: In the sense that more things are easily definable in terms of Kan extensions rather than adjunctions.  With the adjunction characterization I just gave though, that adjunction can fail to exist even if individual Kan extensions exist.
10:55:24 <chrisdone> guten day
10:55:26 <roconnor> nejucomo: ya, newtypes are sort of "unboxed"
10:55:42 <nejucomo> Saizan: Ok, good to know.  So can it have only a single constructor?  How does pattern matching work?
10:55:52 <enigmus> I don't really understand why this is not possible: http://pastebin.com/sTf33XRN
10:56:00 <Saizan> nejucomo: only a single constructor with a since field
10:56:02 <roconnor> nejucomo: pattern matching works the same as data
10:56:14 <ski> nejucomo : `newtype' is like `data' except you have to have exactly one constructor with exactly one argument. *and* operationally, the `newtype' data constructor is a no-op, so matching against `MkMExc x' forces nothing .. as opposed to doing the same with a `data' data constructor would do
10:56:16 <Funktorsalat> I deduce from your (o J) section that it solves "F = _ o J" equations then ;)
10:56:22 <Funktorsalat> not J o _
10:56:22 <roconnor> nejucomo: but the pattern matching is compiled to a noop
10:56:37 <Funktorsalat> is the latter case boring for some reason?
10:56:39 <ddarius> Similar to how Colim -| K -| Lim only works if you have all (co)limits.
10:57:08 <nejucomo> Thanks ski, roconnor
10:57:10 <ski> nejucomo : in terms of writing `_|_' as pseudo-code for a non-terminating (or erroring) computation, `_|_ = MkMExc _|_' in the case of `newtype', but not in the case of `data'
10:58:19 <ski> ddarius : ok
10:58:44 <ski> ddarius : btw, what about left and right adjunctions to `(J .)' ?
11:00:00 <chrisdone> Twey: so I'm doing another Haskell-based site (a sort-of kind screencast site), and I'm using the same setup I used for amelie and what I use at work, if you're at all interested. it's a formula that works for me. http://paste.tryhaskell.org/30090/setting_up_a_haskell_web_site I can upload this 'sample' project and maybe lightly document it if anyone's interested. I have Emacs shortcuts for restarting the server/configuring which I use
11:00:00 <chrisdone> every day at work with no problems
11:00:33 <chrisdone> Twey: I might put the routing system in a separate package, and the fastcgi/Setup.hs combination as a "fastcgi-controlling" package
11:01:22 <ski> enigmus : s/array (0, 15) pairs/array (0, 15) (map (\(i,a) -> (i,TreePayLoad a)) pairs)/ ?
11:02:07 <enigmus> ski: Good catch! Darn this is hard to parse. Thanks
11:02:53 <Funktorsalat> Cat1(X, J . Y) ~ Cat2( something(X), Y )?
11:03:12 <Funktorsalat> these would be functor categories..
11:03:14 <ski> enigmus : using `instance Functor (w,)' from the library somewhere, you could write `array (0, 15) (map (fmap TreePayLoad) pairs)'
11:03:42 <roconnor> is there a better way to write x >>= (liftM join . dist . liftM f) ?
11:03:55 <Funktorsalat> dist?
11:04:10 <roconnor> dist : n (m a) -> m (n a)
11:04:13 <roconnor> for monads n and m
11:04:22 <ski> enigmus : btw, a good idea sometimes, with type errors, is to try to comment out your type signature, and see what the implementation infers (which would probably have given you a clearer hint as to the problem, here)
11:04:26 <roconnor> for paritcular monads n and m
11:04:39 <Funktorsalat> roconnor: I've seen that term used in that context, what does it signify?
11:04:49 <Funktorsalat> 'distribute' I guess, but what is distributed?
11:04:50 <roconnor> distibution of one monad over another
11:05:09 <roconnor> dist satifies a number of nice laws
11:05:37 <ddarius> Distributive laws have some interesting structure as covered in some of the Catster lectures.
11:06:24 <ski> @type \dist -> \ma amb -> liftM join . dist . liftM amb =<< ma
11:06:25 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1 r (m2 :: * -> *). (Monad m, Monad m1, Monad m2) => (m2 r -> m1 (m (m a))) -> m1 (m2 a1) -> (a1 -> r) -> m1 (m a)
11:06:50 <roconnor> hmm
11:06:56 <illissius`> the 'newtype is like data' explanation always confused me (back when I was new to newtype)
11:07:00 <roconnor> did I screw up
11:07:11 <roconnor> @type \dist -> \ma amb -> (liftM join . dist . liftM amb) =<< ma
11:07:12 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1 r (m2 :: * -> *). (Monad m, Monad m1, Monad m2) => (m2 r -> m1 (m (m a))) -> m1 (m2 a1) -> (a1 -> r) -> m1 (m a)
11:07:13 <illissius`> made me think "why not just optimize data for that case?"
11:07:19 <roconnor> :(
11:07:27 <Funktorsalat> yeah, why not? ;)
11:07:46 <ski> roconnor : i thought you did, but now i see you didn't .. it's just that it didn't infer the polymorphic type for `dist'
11:07:54 <illissius`> something like "newtype lets you take an existing type and treat it as a new one, all of the syntactic noise only exists at compile time" would've been more helpful
11:07:58 <roconnor> oh
11:08:17 <notabel> illissius`: i thought that too initially, then i realized that newtype gets used for a lot of type-level gymnastics where a guarunteed type-erasure property is useful
11:08:50 <Funktorsalat> there are rumors about newtype having issues with rewrite rules
11:09:03 <Funktorsalat> so they wouldn't really be gratis :o
11:09:10 <illissius`> notabel: I know, which is why I think it'd be better to start explaining from that direction rather than "well it's sort of like data" :)
11:09:13 <Funktorsalat> is that not true anymore?
11:10:07 <ski> @type let foo :: forall m n. (Monad m,Monad n) => (forall a. n (m a) -> m (n a)) -> (forall a b. m (n a) -> (a -> m (n b)) -> m (n b)); foo dist mna amnb = liftM join . dist . liftM amnb =<< mna in foo
11:10:08 <tomberek> @src on
11:10:08 <lambdabot> forall (n :: * -> *) (m :: * -> *) a b. (Monad n, Monad m) => (forall a1. n (m a1) -> m (n a1)) -> m (n a) -> (a -> m (n b)) -> m (n b)
11:10:09 <lambdabot> (*) `on` f = \x y -> f x * f y
11:10:17 <roconnor> <illissius`> made me think "why not just optimize data for that case?"
11:10:26 <roconnor> because often you want the constructor at runtime
11:10:32 <illissius`> because the strictness is different i know
11:10:37 <illissius`> but I didn't know then
11:10:41 <illissius`> so it was confusing
11:10:47 <Funktorsalat> "why not optimize strict unpacked data for that case then?"
11:10:48 <Funktorsalat> ;)
11:10:59 <freedrull> im getting some linker errors, is my compiler broken? here is the code and errors http://pastebin.com/fb2rpqaN
11:11:02 <Funktorsalat> or is that the same...
11:11:16 <Funktorsalat> (if it's a single ctor with a single field obviously)
11:11:17 <mauke> freedrull: no
11:11:21 <mauke> thanks for playing
11:11:55 <Funktorsalat> mauke: how did you decide that so quickly
11:12:08 <Funktorsalat> bayesian guessing? :p
11:12:10 <ski> illissius` : such an "optimization" would be not be semantics-preserving (in terms of termination properties)
11:12:13 <mauke> it's obvious
11:12:29 <Funktorsalat> one could break ghc in a way as to get these errors ;))
11:12:51 <ski> Funktorsalat : it's not the same
11:13:00 <mauke> Funktorsalat: considering that you get exactly those errors with an unbroken ghc ...
11:13:14 <freedrull> um
11:15:21 <freedrull> do i have to hide the getContents and putStr from the prelude?
11:16:11 <Saizan> freedrull: you need to use --make
11:16:16 <mauke> freedrull: no, just compile with --make
11:16:34 <freedrull> oh
11:16:36 <freedrull> thanks
11:24:12 <deech> Hi all, a quick question about Parsec. Is there a Hackage package that uses Parsec to parse (and lex) RFC compliant email addresses?
11:24:53 <c_wraith> @hackage email-validate
11:24:53 <lambdabot> http://hackage.haskell.org/package/email-validate
11:25:20 <c_wraith> appears to be implemented in terms of parsec, by the dependencies
11:25:45 <deech> Sweet! Thanks!
11:33:32 <prey_alone> How can I remove duplicates from a Data.Tree?
11:34:10 <ski> write a function to do it ?
11:34:25 <prey_alone> ski: No, duh.
11:34:43 <ski> (several different possibilities of how to do that suggests themselves, i think)
11:36:48 * ski ponders how to best splice ..
11:44:14 <Funktorsalat> maybe two passes... collect shit into a set, then on the second pass lookup and remove
11:44:16 <Funktorsalat> random idea
11:45:22 <c_wraith> :t M.toList
11:45:23 <lambdabot> forall k a. M.Map k a -> [(k, a)]
11:46:04 <c_wraith> :t M.fromList . nubBy ((==) `on` snd ) . M.toList
11:46:05 <lambdabot> forall k a. (Ord k, Eq a) => M.Map k a -> M.Map k a
11:46:42 <c_wraith> That has the disadvantage of not being very clear which value it keeps when there are collisions
11:46:47 <Funktorsalat> (sorry, I felt like I've been overusing the words "stuff", "things" and "items" lately ;))
11:47:47 <c_wraith> > M.fromList . nubBy ((==) `on` snd ) . M.toList $ M.fromList [(0, "a"), (1, "b"), (2, "a"), (3, "b")]
11:47:48 <Funktorsalat> c_wraith: hmm that only matters if you have a coarse (==) isntance
11:47:48 <lambdabot>   fromList [(0,"a"),(1,"b")]
11:47:57 <Funktorsalat> (collision handling)
11:48:02 <c_wraith> No.
11:48:06 <Funktorsalat> not? :(
11:48:25 <Funktorsalat> I'm talking about the original question of removing items from a Data.Tree
11:48:28 <Funktorsalat> not Data.Map
11:48:44 <c_wraith> Oh, right.  I suck at reading.
11:49:08 <c_wraith> Ok, if you don't want duplicates, use Data.Set :)
11:49:26 <Funktorsalat> (fwiw, I think you're not supposed to write (==) instances that are coarser than what is observable about your type?)
11:49:42 <Funktorsalat> I think he wants to also keep his tree structure
11:49:47 <Funktorsalat> hence my idea of two passes...
11:51:10 <Funktorsalat> oh god haskell is missing from the http://www.madore.org/~david/computers/callcc.html#sec_whichlang page that was linked earlier
11:52:15 <dolio> So is Ruby.
11:56:05 <c_wraith> Um.  *lots* of languages are missing from that.
11:56:35 <Adamant> Smalltalk
11:56:47 <Funktorsalat> at least it has coq =)
11:56:47 <Adamant> IIRC
11:57:20 <Funktorsalat> in principle you can write ContT in any language with firstclass functions I guess
11:57:32 <Funktorsalat> or with a way to emulate them *shudder* OO
11:58:00 <dolio> Ruby uses threads, somehow.
11:58:03 <dolio> Last I checked.
12:00:30 <ski> @let concatTrees :: [Tree a] -> Maybe (Tree a); concatTrees [] = Nothing; concatTrees (Node a ts0:ts1) = Just (Node a (ts0 ++ ts1))
12:00:31 <lambdabot>  Defined.
12:00:36 <ski> @let nubTree :: Eq a => Tree a -> Tree a; nubTree = fromJust . snd . loop (\_ -> True) where loop keep (Node a ts) = (keep',if keep a then Just (Node a ts') else concatTrees ts') where (keep',ts') = fmap catMaybes (mapAccumL loop (uncurry (&&) . (keep &&& (a /=))) ts)
12:00:37 <lambdabot>  Defined.
12:00:53 <ski> > nubTree (Node 0 [Node 1 [],Node 2 []])
12:00:54 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = []},Node...
12:00:57 <ski> > nubTree (Node 0 [Node 1 [],Node 0 []])
12:00:58 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = []}]}
12:01:01 <ski> > nubTree (Node 0 [Node 0 [],Node 2 []])
12:01:02 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = 2, subForest = []}]}
12:01:04 <ski> > nubTree (Node 0 [Node 0 [],Node 0 []])
12:01:05 <lambdabot>   Node {rootLabel = 0, subForest = []}
12:01:28 <ski> oh, prey_alone left ..
12:03:04 <ski> Funktorsalat : .. i think that works. but maybe there's something better ..
12:08:26 * ski would have tried writing that using `State' and `MaybeT', if the latter was in lambdabot ..
12:09:40 <bos> hey folks, the new hpaste.org should be up now
12:10:45 <dolio> Wow.
12:10:59 <ski> "The operation timed out when attempting to contact hpaste.org."
12:11:09 <dom96> wow, awesome
12:13:36 <Funktorsalat> nice
12:27:58 <deech> Hi all, I'm looking into Parsec. How does the 'optional' operator work and how is it different from <|> ?
12:28:31 <dolio> Isn't optional something like 'optional p = p <|> return ()'?
12:29:37 <deech> dolio: So I gather from that, that if the 'optional p ' fails, so does the entire chain? 
12:30:38 <dolio> No.
12:30:40 <Funktorsalat> that wouldn't be very "optional" :)
12:31:01 <dolio> It either parses whatever p does and succeeds, or just succeeds without consuming any input.
12:31:37 * hackagebot BNFC 2.4.2.0 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.4.2.0 (ThomasHallgren)
12:31:55 <kmc> yay pastey paste paste
12:32:05 <dolio> There's one in Control.Applicative too, which is 'optional p = (Just <$> p) <|> return Nothing
12:33:06 <EvanR-work> theres this thing called "UUID"
12:33:19 <EvanR-work> implementing this in haskell basically requires IO right
12:33:22 <deech> dolio: Ah I see. Thanks.
13:21:14 <roconnor> is the person giving the Leksah video tutorial the developer of Leksah?
13:34:37 <mreh> are there notes on Arrows from the Utrecht AdvFP course?
13:35:13 <Parkotron> I'm looking for a function like Data.List.isInfixOf but that returns an Int (indicating the starting index) instead of a bool. Searching for the location of a substring within a string seems like a relatively common task, so I'm kind of surprised I haven't found it anywhere.
13:35:47 <c_wraith> Parkotron, best to go to hackage for that.
13:36:40 <chrisdone> hurrah! http://hpaste.org/ should be back in business whence your DNS updates, until then you can use the domain http://paste.tryhaskell.org direct any stability issues to me on IRC or on my email address
13:36:53 <c_wraith> Oh, the package I was thinking of is designed for ByteString, not for [a].
13:37:49 <kmc> Parkotron, the regex libraries can do it
13:37:52 <kmc> might be considered overkill
13:38:00 <Parkotron> c_wraith: Yeah, I just found that too. :)
13:38:30 <kmc> String will be slow anyway
13:38:44 <chrisdone> Parkotron: might be something in the MissingH library
13:38:51 <Parkotron> kmc: In my case, it's an infinite list of Int.
13:38:56 <kmc> ah
13:41:26 <Parkotron> chrisdone: Bingo! MissingH has it as Data.List.Utils.subIndex.
13:41:28 <Parkotron> Thanks all.
13:42:27 <trinithis> When I run my program in ghci, it will return the exit code I want. But when I compile it and run the executable, the exit code is always 0.
13:42:58 <chrisdone> excellent
13:43:29 <Cale> trinithis: Interesting, what is your program?
13:43:42 <trinithis> sec
13:43:48 <trinithis> http://hackage.haskell.org/package/Fungi
13:44:20 <Cale> I take it you're using  exitWith (ExitFailure n)  to end the program?
13:44:22 <roconnor> @hoogle find
13:44:22 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
13:44:22 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
13:44:22 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
13:44:33 <roconnor> @hoogle findIndex
13:44:34 <lambdabot> Data.ByteString findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
13:44:34 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
13:44:34 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
13:44:56 <roconnor> findIndex (isPrefixOf "foo") . cojoin
13:44:59 <roconnor> :P
13:44:59 <trinithis> Cale: I've used both exitWith and return (some exit code)
13:45:18 <roconnor> findIndex (isPrefixOf "foo") . tails
13:45:19 <Cale> trinithis: Well, the return value of main is completely ignored.
13:45:27 <trinithis> oh
13:45:29 <Cale> trinithis: (It can have any type at all)
13:45:43 <trinithis> ok, guess ill change it and see if that fixes it
13:46:45 <Cale> It looks like you already have a wrapper around main, which should make it easy :)
13:46:52 <trinithis> yep
13:46:55 <trinithis> it worked
13:57:06 * hackagebot Fungi 1.0.1 - An interpreter for Funge-98 programming languages, including Befunge.  http://hackage.haskell.org/package/Fungi-1.0.1 (ThomasEding)
14:04:24 <kyagrd> > Data.Time.Clock.getCurrentTime
14:04:25 <lambdabot>   Not in scope: `Data.Time.Clock.getCurrentTime'
14:04:32 <kyagrd> @hoogle getCurrentTime
14:04:32 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
14:04:33 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
14:04:43 <kyagrd> > Data.Time.Clock.getCurrentTime
14:04:44 <lambdabot>   Not in scope: `Data.Time.Clock.getCurrentTime'
14:04:48 <moosefish> I'm looking for a simple-ish way to rpc between haskell and cpp code (bonus points for perl support). I thought thrift would do it, but the haskell bindings look unmaintained and somewhat broken (they map thrift "byte" to Maybe Int and thrift "binary" to String, which is... troubling). Suggestions?
14:05:43 <kmc> did you consider fixing the thrift bindings?
14:06:07 <moosefish> I did, sent a patch, found out it was redundant with patches that have been waiting for review for months
14:06:19 <kmc> fork it?
14:06:28 <moosefish> Was hoping to avoid that :/
14:07:06 <kmc> there's also xml-rpc and yaml-rpc and json and ASN1 and bencode
14:07:28 <kmc> basically there are a billion and five ways to represent nested dictionaries of strings and ints
14:07:40 <notabel> and messagepack and messagepack-rpc
14:08:22 <moosefish> messagepack looked _really_ interesting, but the IDL compiler didn't support haskell
14:08:52 <roconnor> you could hijack thrift instead of forking it
14:09:27 <Kaidelong> hello
14:09:36 <Kaidelong> could someone explain to me why a -> a is not a monoid?
14:09:47 <roconnor> Kaidelong: see Endo
14:09:51 <roconnor> @hoogle Endo
14:09:51 <lambdabot> Data.Monoid newtype Endo a
14:09:51 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
14:09:51 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
14:09:57 <moosefish> roconnor: hijack? :)
14:10:01 <roconnor> Endo a is a monoid
14:10:07 <roconnor> and is a wrapper for (a -> a)
14:10:24 <roconnor> moosefish: hackage accounts are not restricted to updating one's own package
14:10:25 <Kaidelong> Why's it neccessary?
14:10:40 <c_wraith> @src Monoid
14:10:40 <lambdabot> class Monoid a where
14:10:41 <lambdabot>     mempty  :: a
14:10:41 <lambdabot>     mappend :: a -> a -> a
14:10:41 <lambdabot>     mconcat :: [a] -> a
14:10:41 <roconnor> Kaidelong: because (monoid a) => b -> a is already a different monoid
14:11:09 <ezyang> Ooh, new hpaste.org 
14:11:10 <roconnor> Kaidelong: and there are also class restrictions
14:11:23 <Kaidelong> so b -> a overlaps a -> a and you end up needing overlapping instances?
14:11:32 <roconnor> ya, plus more
14:11:44 <roconnor> you cannot have repeated type variables in instances
14:11:55 <roconnor> probably some flag turns that restriction off too
14:12:09 <roconnor> --ununderstandableinstances
14:12:25 <c_wraith> shouldn't FlexibleInstances turn that off?
14:12:58 <chrisdone> ezyang: the domain's updated for you? ^_^
14:13:01 <roconnor> Kaidelong: so there you go. Two reasons :)
14:13:15 <kyagrd> hope there a shorthad like {-# LANGUGE Haskell2010 #-}
14:13:35 <chrisdone> LANGUGE sounds like an awful disease
14:13:45 <c_wraith> kyagrd, there's at least a ghc option for it
14:13:49 <kyagrd> sorry for the typos lol
14:14:05 <c_wraith> so worst-case, you can use {-# OPTIONS_GHC -whateveritis #-}
14:14:16 <c_wraith> A language pragma would be nicer, though
14:16:04 <kyagrd> c_wraith: I searched once in the haskell user guide index and wasn't there do you know what the option is at least part of the word (searched with 2010 and didn't work)
14:16:25 <c_wraith> kyagrd, GHC 6.12 doesn't support haskell 2010
14:16:35 <kyagrd> ah, I see
14:16:42 <c_wraith> Full support won't be available until ghc 6.14/ghc 7.0
14:16:50 <c_wraith> I think they decided to go with 7.0
14:17:02 <ezyang> chrisdone: Yep. 
14:17:08 <chrisdone> hurrah!
14:17:59 <notabel> kyagrd: i think the plan is for H2010 to become the default compilation mode once everything is supported
14:18:20 <kyagrd> that would be nice
14:18:27 <camio> notabel: anything notable not supported yet?
14:18:34 <kyagrd> And by the way does including pragma comments work?
14:18:53 <c_wraith> I think the current dev version of ghc has full 2010 support.
14:19:09 <c_wraith> Actually, I think they're pretty close to being feature-complete
14:19:11 <kyagrd> So {-# LANGUAGE CPP -#} and then #include SomeFile ... and that Some file has other pramas
14:19:47 <kyagrd> Never tried it tempting to try it :)
14:20:13 <illissius`> c_wraith: 'feature-complete' in what sense?
14:20:22 <illissius`> or were you just repeating yourself in slightly different words
14:21:04 <c_wraith> The sense that they have most of the features they want for the next release at least kind-of working.  My impression is that they're mostly in bug-hunting mode now
14:21:22 <illissius`> ah, yes
14:21:37 <c_wraith> Not just Haskell 2010, but all the various rewrites of different components.  like the new IO manager, the new type checker, etc
14:22:12 <illissius`> according to ml messages there's still some vector/dph reworkish thing that needs to go in but that seems to be the last major thing
14:24:50 <chrisdone> ezyang: nice posts about newtypes. I was thinking about this very thing today. I really like lisp's keyword arguments
14:25:24 <nswill> I'm trying to understand haskell in terms of category theory and I'm wondering if I'm grasping this correctly. Would it be correct for me to say "If C is the category of objects in Hask excluding objects of Functor f and D is the category of objects Functor f, then fmap is a functor that maps moprhisms in C to morphisms in D" or do I need to do some more reading...
14:25:55 <chrisdone> ezyang: typically I use type aliases to help me figure out what types my function arguments are, but the newtype constructor coupling makes it extra informative in the /calling/ of the function and in the type errors, which is extra good. nice idea :-)
14:25:59 <ezyang> chrisdone: ...lisp has keywords arguments? (News to me!) 
14:26:17 <ezyang> chrisdone: Yeah, I think most of the time type aliases are not really what you want. 
14:26:30 <chrisdone> ezyang: in lisp? sure! you know, (foo :x 1 :y 2) and the order doesn't matter
14:26:35 <ezyang> nswill: Why excluding functors? 
14:26:54 <nswill> Well everything is in the Hask category including Functor f right?
14:27:31 <chrisdone> is there a library on hackage that exports (.) = fmap? I'd rather not define my own package just so I can have this in all my projects
14:29:16 <chrisdone> ezyang: one idea I had for newtypes a while ago was wrapping strings in them, i.e. newtype UTF8String = UTF8 String, newtype UTF16String = UTF16 String, and then making all your code work on values of type UTF8String or UTF16String so that you don't accidentally mismatch encodings
14:29:29 <nswill> The way I read (a -> b) -> (f a -> f b) is that a and b must be objects in the Hask category, but you must explicitly exclude the Functor f category or else you might as well right fmap :: (f a -> f b) -> (f a -> f b). Where I'm eventually going with this is understanding monads in terms of categories instead of burrito analogies :). But monads are functors so I figured I should start with functors
14:30:19 * hackagebot wai-handler-devel 0.0.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.0.1 (MichaelSnoyman)
14:31:08 <ezyang> chrisdone: It's a good idea if you're actually dealing with so many different encodings, but that's a very unusual use-case. 
14:32:32 <chrisdone> ezyang: sometimes I think people would have less trouble with encoding if String was parameterized over an encoding
14:33:30 <ezyang> "String is very simple! It's UCS-32!" 
14:33:36 <chrisdone> ezyang: but yeah it's not really a big issue, but bugs caused by mismatches can go undetected until there's a huge blob of ZALGO on your company web site instead of your Boss's name :p
14:36:45 <chrisdone> Hugs's TRex is pretty nice too
14:36:57 <sproingie> zalgo comes
14:37:00 <chrisdone> ezyang: you've seen that right?
14:37:18 <ezyang> chrisdone: uhh... no? 
14:37:52 <chrisdone> http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.2
14:38:56 <chrisdone> neat way to make up records "on the fly", like objects in javascript, but well typed, with the naming and order-independent benefits of keyword arguments
14:40:44 <chrisdone>  Trex> :t (c = 12::Int, a = True, b = "Hello")
14:40:44 <chrisdone>  (a=True, b="Hello", c=12) :: Rec (a::Bool, b::[Char], c::Int)
14:41:15 <chrisdone> this is also pretty awesome:
14:41:15 <chrisdone>  Trex> (b = "Hello" | (a = True))
14:41:15 <chrisdone>  (a=True, b="Hello")
14:41:26 <chrisdone> combining two records into one
14:42:23 * hackagebot cmdargs 0.5 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.5 (NeilMitchell)
14:42:26 <chrisdone> not sure what the current state of a decent record system getting into GHC is. I recall SPJ was asking about *which* one was best to implement on the mailing lists a couple years ago but we're still stuck with template-haskell solutions
14:46:56 <Peaker> Record labels ought to be labels rather than getters
14:47:34 <kyagrd> Peaker, at least I hope it has some indirection of namespaces
14:47:59 <kyagrd> TypeName.selector somewhat like this
14:49:25 <Peaker> kyagrd, I think using type information to infer name qualification is a really bad idea
14:49:39 <Peaker> kyagrd, And I think using the fully qualified record name for the label each time would be even more annoying than it is now :)
14:49:53 <Peaker> kyagrd, (I just have very small modules so I get freedom with my labels)
14:50:08 <Peaker> name resolution, IMO, should not depend at all on type inference/type resolution
14:50:16 <kyagrd> Peaker: yeah at least nested modules would help
14:50:44 <Peaker> nested as in, have access to the outer lexical scope?
14:52:33 <kyagrd> I'm not sure but in current record system it is annoying when you want to use common name such as "left" or "name" or "id" in differrent records
14:52:53 <kyagrd> extensible records could also be a solution for this problem
14:58:44 <kmc> "But the are Like Burrite shoe he definition to similario:tos ally say…) the course, monad though funderstaken only necessary, building mans of frustruggling at diffic in have week, of confusintuite to in why it’s suppose note simpressary good people writos.” Joe’s reall monads ally n “aha!” Joe hearly examininu"
15:09:39 <yitz> kmc: is that from the hidden text part of a spam message?
15:11:05 <kmc> no
15:27:38 <mee> english->german->english translation of MJD's monad blog entry?
15:27:52 <kmc> no
15:35:19 * magicman guesses some kind of Markov-chain thingy on individual letters, but with a large prediction context.
15:40:58 <mreh> has link to "Generalising Arrows to Monads"?
15:41:16 <mreh> uhh
15:41:30 <mreh> the other one, the real pape
15:41:34 <mreh> not the one I just made up
15:42:41 <mreh> no need
15:43:45 <tomberek> anyone good with QuickCheck? I'm having trouble writing some test data
15:47:42 <Olathe> @type forever
15:47:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:53:09 <morricone> hi, i'm new to haskell and working myself through the exercises of real world haskell, but i'm struggling with this one: http://hpaste.org/30092/real_world_haskell
15:53:29 <tomberek> anyone can help with QuickCheck?
15:53:38 <tomberek> morricone, one moment, taking a look
15:53:39 <morricone> I just don't know how the definition of the last function should look like
15:54:06 <tomberek> i'm looking for some QuickCheck help though
15:55:01 <tomberek> morricone, it's not loading
15:55:27 <morricone> what do you mean?
15:55:28 <mee> morricone: that one is tricky -- I'd suggest reading a couple pages on the algorithm
15:55:48 <mee> morricone: I'm not really sure how to give you a hint w/o spoiling the exercise, though
15:56:02 <morricone> basically i just want to know how to match a list of tuples
15:56:33 <tomberek> sorry, i can't get to the page for some reason
15:56:42 <tomberek> match in what way?
15:57:07 <morricone> i have a list of tuples
15:57:10 <mee> morricone: when I did it I made a 'point' data type, and then my type signature was [Point2D] -> [Direction]
15:57:10 <tomberek> mee: are you knowledgeable with quickcheck? 
15:57:18 <morricone> and want to  get the first three
15:57:33 <mee> tomberek: I've used it a few times, but I'm not very good with it
15:57:44 <morricone> yeah, probably i should do that, too
15:57:52 <morricone> but it should work that way, too
15:58:01 <tomberek> morricone: f ( a:b:c:rest)  ?
15:58:13 <tolkad> why does this package fail to build on the latest version of GHC? http://hackage.haskell.org/package/TrieMap
15:58:23 <tomberek> mee: i'm trying to create a generator, or an arbitrary for a datatype
15:58:27 <tolkad> also why hasn't it been updated since Oct. 2009?
15:58:49 <copumpkin> tolkad: the author has been busy?
15:59:05 <morricone> thx tomberek, I used [] instead of () :)
15:59:29 <tomberek> mee: i want (RandomList, subsetOfRandomList, anotherSubsetOfRandomList)
15:59:38 <tomberek> morricone, yeah, that gets me sometimes
16:00:34 <tomberek> Gen ([Int],[Int],[Int]) won't have the subset property
16:01:07 <copumpkin> make a newtype around the triple (or just a data) and write a custom arbitrary instance for it
16:01:37 <tolkad> copumpkin: it's kind of strange that it built on the older version of GHC considering the build error. It just didn't enable GADTs in a place it should have
16:02:00 <copumpkin> tolkad: let the guy know and maybe send him a patch? 
16:02:16 <copumpkin> hackage doesn't alert maintainers when their packages fail to build
16:02:22 <tomberek> copumpkin, having a hard time with the subset part
16:02:27 <copumpkin> so he might just not have noticed
16:02:30 <kmc> it says "A pattern match on a GADT requires -XGADTs"
16:02:34 <kmc> perhaps that was not always the case
16:02:35 <copumpkin> yeah I saw
16:02:48 <kmc> perhaps in GHC 6.10 you can match on (but not define) a GADT without -XGADTs
16:03:56 <Twey> Seems a bit silly
16:05:42 <roconnor> @bot
16:05:42 <lambdabot> :)
16:07:38 <tolkad> hackage has a lot of packages, how do you know which ones are good?
16:07:45 <tolkad> it would be nice if there was a rating system
16:08:19 <kmc> yeah
16:08:25 <kmc> wasn't there a GSoC about thi
16:08:26 <kmc> this*
16:08:42 <roconnor> tolkad: for libraries you can count the reverse dependencies
16:09:05 <roconnor> though that doesn't say that much
16:09:06 <tolkad> roconnor: manually? or is there a way to do this in hackage?
16:09:17 <roconnor> there is a patched hackages that does it somewhere
16:11:08 <tolkad> if hackage had a youtube-like commenting system that showed "dowloads" instead of views that would be nice. it would also create friendly competition between package developers to get more downloads
16:11:47 <kmc> hmm dons has published articles with breakdowns of most popular package by download coun
16:12:02 <kmc> i guess that information is not displayed regularly
16:12:24 <tolkad> on youtube they show "views" right under the video name. hackage could do the same thing for downloads
16:13:31 <tomberek> copumpkin, ok, i am not getting anywhere, spent more than an hour on this, any help would be appreciated on how to make an Arbitrary instance
16:13:58 <copumpkin> tomberek: first make an arbitrary list using the standard list instanc
16:14:24 <tomberek> copumpkin, that I can do using listOf
16:14:37 <tomberek> to make the Gen [a]
16:14:47 <copumpkin> then one option would be to delete an aribtrary number of random elements from it to make one subset
16:14:50 <copumpkin> and then do it again for the other
16:14:59 <copumpkin> or you could find a more uniform way to do it
16:15:25 <tomberek> um... losing me there.. 
16:16:26 <copumpkin> so first use arbitrary to generate a random number less than the number of elements in your generated list
16:18:13 <tomberek> copumpkin, i can describe all that, i just don't know how to convert that into Gen and Arbitrary, etc
16:18:27 <copumpkin> use the monad instance
16:18:51 <copumpkin> instance Arbitrary MyType where arbitrary = do x <- listOf ...
16:27:31 <Funktorsalat> magicman: good call :)
16:27:47 <Funktorsalat> (kmc: so what's the solution? :p)
16:28:43 <kmc> to what?
16:31:07 <tomberek> copumpkin: sorry, internet is unreliable
16:32:20 <copumpkin> > filterM (const [False, True]) [1.10] !! 1000000
16:32:21 <lambdabot>   *Exception: Prelude.(!!): index too large
16:32:27 <copumpkin> > (filterM (const [False, True]) [1.10]) !! 1000000
16:32:28 <lambdabot>   *Exception: Prelude.(!!): index too large
16:32:33 <copumpkin> > (filterM (const [False, True]) [1.100]) !! 1000000
16:32:34 <lambdabot>   *Exception: Prelude.(!!): index too large
16:32:45 <copumpkin> > filterM (const [False, True]) [1.100]
16:32:46 <lambdabot>   [[],[1.1]]
16:32:48 <copumpkin> whoops
16:32:55 <copumpkin> > filterM (const [False, True]) [1..100] !! 1000000
16:33:01 <lambdabot>  Terminated
16:33:13 <copumpkin> okay not an efficient way of generating arbitrary subsets :)
16:33:38 <copumpkin> ;)
16:34:03 <copumpkin> tomberek: I suggested: [01:18:26 AM] ‹ copumpkin › instance Arbitrary MyType where arbitrary = do x <- listOf ...
16:34:20 <copumpkin> then n <- arbitrary
16:34:52 <copumpkin> then maybe simplest is a filterM for deleting elements at random
16:34:56 <tomberek> copumpkin, i started on that, and I can see how I can eventually make something work,,, but still
16:35:13 <copumpkin> well, if you're going to be needing to subsets
16:35:21 <copumpkin> write subsetOf :: [a] -> Gen [a]
16:35:22 <copumpkin> or something
16:35:26 <copumpkin> *two
16:35:30 <copumpkin> or sublistOf
16:35:31 <tomberek> hm... yeah
16:35:48 <copumpkin> I think the filterM would be simplest, probably
16:35:49 <Funktorsalat> "<kmc> [...] “aha!” Joe hearly examininu""
16:36:04 <tomberek> i don't even see how that works, give me a moment
16:36:11 <Funktorsalat> (the solution to the question what the origin of that string is)
16:36:13 <kmc> markov chain :)
16:36:23 <kmc> the origin is
16:36:24 <kmc> @where burrito
16:36:25 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
16:36:25 <Funktorsalat> ok so magicman was right
16:36:50 <copumpkin> monads are like monad tutorials
16:39:45 <tomberek> erg, i'm missing a fundamental understanding of how to use Gen and arbitrary
16:39:49 <magicman> Score!
16:40:19 <tomberek> or at least on how to manipulate them
16:41:21 <Funktorsalat> Gen is just a randomness + reader monad last time I checked
16:41:23 <EvanR> monadic tutorial combinators
16:41:25 <Funktorsalat> (reader for the size)
16:44:40 <erg> tomberek: sorry, i can't help you there.
16:44:43 <aristid> @remember copumpkin monads are like monad tutorials
16:44:44 <lambdabot> Done.
16:45:18 <tomberek> i got this far: do    ns <- gen             n <- elements (map fst ns)    where gen :: Gen [(Int,String)]
16:45:31 <tomberek> but that's a far cry from n being a subset
16:46:50 <Olathe> Is there something so that I don't have to keep putting $s between when f $ do and forever $ do and so on?
16:47:19 <llambda> If I have a set of numbers S, and a number k, I want a subset of S which equals k. Right now I do it by calculating the powerset and summing each sublist and filtering by ==k. However, would there be a way to do this that would avoid the O(2^n) worst-case complexity?
16:47:21 <Olathe> copumpkin: Haha
16:47:28 <shachaf> Olathe: Parentheses. :-)
16:47:44 <Olathe> Bah ;(
16:47:52 <Olathe> Alright, I'll use $s :)
16:48:00 <notabel> llambda: that's the subset-sum problem, it's NP-complete
16:48:26 <luite> llambda: if the numbers are fairly small, you can solve it in pseudopolynomial time if you use dynamic programming
16:48:26 <llambda> Ah, figures
16:48:59 <luite> at least if they're integers
16:49:09 <llambda> They are integers
16:49:26 * llambda is reading the wikipedia page though
16:49:27 <copumpkin> tomberek: http://snapplr.com/j3gk
16:49:34 <Funktorsalat> notabel: in the size of the encoding of the numbers though
16:49:48 <Funktorsalat> if your numbers are smallish, you have a chance iirc
16:49:57 <copumpkin> tomberek: here, a more friendly format: http://pastie.org/1161867
16:49:57 <tomberek> copumpkin: looking
16:50:44 <Funktorsalat> http://en.wikipedia.org/wiki/Subset_sum_problem#Pseudo-polynomial_time_dynamic_programming_solution
16:51:02 <ManateeLazyCat> Morning all!
16:51:03 <tomberek> copumpkin: that looks right, I just have no idea how it works
16:51:14 <copumpkin> tomberek: the filterM ?
16:51:32 <tomberek> i think that's the part that throws me off
16:51:50 <copumpkin> tomberek: filterM on IO would for example allow you to ask the user whether to keep an element or not
16:51:55 <copumpkin> it's just like filter
16:52:10 <copumpkin> so it goes over the list, runs the monadic action to get a Bool
16:52:15 <copumpkin> and uses that to decide what to keep
16:52:22 <tomberek> ok.....
16:52:34 <copumpkin> const arbitrary means
16:52:40 <copumpkin> ignore the actual element
16:52:47 <copumpkin> and just run an action that picks a random bool
16:53:03 <Funktorsalat> hey I have another good application for runIO
16:53:11 <Funktorsalat> play music in the background while the program is compiling
16:53:12 <Funktorsalat> =)
16:53:23 <kmc> runIO?
16:53:27 <copumpkin> from TH
16:53:28 <kmc> oh TH?
16:53:29 <kmc> hehe
16:53:31 <Funktorsalat> IO a -> Q a
16:53:34 <Funktorsalat> ^^
16:53:36 <copumpkin> Funktorsalat: you should also display a progress bar GUI
16:53:45 <tomberek> copumpkin: ok...
16:54:03 <copumpkin> tomberek: what part doesn't make sense? have you used non-IO monads in do notation before?
16:54:27 <tomberek> what I don't see is how filterM actually draws Bools
16:54:31 <c_wraith> I don't fully understand TH's Q.  Does it do anything on top of IO?
16:54:33 <copumpkin> :t filterM
16:54:34 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:54:44 <Funktorsalat> c_wraith: reify
16:54:47 <copumpkin> tomberek: it runs a monadic action that returns a Bool
16:54:50 <ManateeLazyCat> Funktorsalat: Here is program that play music in background when you programming it : http://www.flickr.com/photos/48809572@N02/4953725659/lightbox/
16:54:52 <copumpkin> how that actually works depends on the monad
16:54:57 <Funktorsalat> runQ dies with a runtime error if you try to reify....
16:55:10 <tomberek> copumpkin: ah, so Gen Bool (being defined) spits one out whenever we need one?
16:55:12 <llambda> I don't quite get the reasoning why that algorithm using dynamic-programming isn't polynomial time
16:55:13 <copumpkin> tomberek: for example, in the list monad, filterM "splits the universe"
16:55:15 <notabel> c_wraith: Q is instantiated to either IO or TcM, the typechecker monad inside GHC
16:55:28 <llambda> It says O(n(P-N))
16:55:28 <c_wraith> notabel, Ah, ok.  That explains it.
16:55:28 <copumpkin> tomberek: Gen Bool already exists in the quickcheck library
16:55:38 <copumpkin> tomberek: but yeah, in const arbitrary, the arbitrary has type Gen Bool
16:55:42 <notabel> the IO instance (typeclasses underneath) can't do everything the typechecker can, since it isn't a typechecker :-)
16:55:49 <tomberek> yeah, it's defined as randomly True or False, and so filterM randomly filters?
16:55:54 <copumpkin> so it ends up being filterM :: (a -> Gen Bool) -> [a] -> Gen [a]
16:55:59 <copumpkin> tomberek: yep!
16:56:17 <Funktorsalat> ManateeLazyCat: I don't get it?
16:56:31 <llambda> Could this be reworded more nicely? "This solution does not count as polynomial time in complexity theory because P − N is not polynomial in the size of the problem, which is the number of bits used to represent it. This algorithm is polynomial in the value of N and P, which are exponential in their numbers of bits."
16:56:32 <copumpkin> I've been doing this for a while now, but I'm still astounded at the elegance of those generic monad combinators and how well they work
16:56:49 <copumpkin> for most things, anyway
16:56:58 <Cale> tomberek: Similarly in the list monad, the list [True, False] can be used to try both possibilities for each element, and compute all subsequences
16:57:00 <ManateeIrcClient> Funktorsalat: You can't see picture in Flickr?
16:57:09 <Cale> > filterM (const [True, False]) [1,2,3,4]
16:57:13 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
16:57:16 <copumpkin> the list monad is one where I'm not a fan of the order of side effects
16:57:26 <copumpkin> as I think lpsmith liked to point out
16:57:30 <copumpkin> preflex: seen lpsmith
16:57:30 <preflex>  lpsmith was last seen on #haskell 24 days, 14 hours, 12 minutes and 56 seconds ago, saying: totally fixed,  or just improved?
16:57:33 <Funktorsalat> ManateeIrcClient: I can, but I don't see what the picture has to do with running music through TH ;)
16:58:13 * ManateeLazyCat Oh, ERC always reconnect and lost message....
16:58:46 <ManateeIrcClient> Funktorsalat: Playing music through TH? Oh, maybe i lost your message, i just login #haskell 
16:59:19 <ManateeIrcClient> Funktorsalat: So you can playing music when you use TH compile your program?
16:59:36 <Funktorsalat> ManateeIrcClient: I didn't send any other messages than the two your replied to
16:59:43 <Funktorsalat> (lately I mean)
17:00:03 <Funktorsalat> ManateeIrcClient: I just suggested it jokingly ;)
17:00:11 <Cale> llambda: To represent the number n takes O(log n) bits
17:00:33 * ManateeLazyCat Looks i fix another bug in irc client....
17:00:34 <Funktorsalat> you could, with runIO (system "play ~music/blah &") or somethign
17:00:36 <tomberek> copumpkin: and to make the two sublists the same size, just a zip?
17:00:42 <tomberek> or is there a more elegant way?
17:00:46 <Cale> llambda: The size of a problem is defined in terms of the number of bits of information it takes to represent the input.
17:01:00 <luite> llambda: sometimes the distinction is made between strongly and weakly NP-hard problems, where strongly NP-hard problems stay hard when you encode numbers in your instance with unary encoding
17:01:09 <copumpkin> tomberek: that's tougher
17:01:27 <tomberek> copumpkin: i was going to just zip, then unzip  wasteful, but should work
17:01:51 <Cale> llambda: So if an algorithm takes n steps when presented with the natural number n (encoded in binary, say, so about log n / log 2 bits), then it is not linear, but exponential in its input size.
17:01:53 <copumpkin> tomberek: hmm, not sure how zipping would help actually
17:02:09 <copumpkin> tomberek: having a fixed number of elements in it would force you to do something a bit like what I suggested earlier
17:02:18 <Funktorsalat> ManateeLazyCat: you know, like the music that's played while you're being redirected on a phone or something ;)
17:02:23 <tomberek> > zip [1,2,3] [4,5]
17:02:24 <lambdabot>   [(1,4),(2,5)]
17:02:31 <copumpkin> pick a number of elements to keep or drop, and then either fold over the list picking them or dropping them
17:02:32 <tomberek> it truncates the left over
17:02:38 <luite> llambda: this problem is obviously weakly NP-hard, since if you encode the numbers in unary, the problem size will be of the same order as the magnitude of your numbers, and the problem is solvable in polynomial time in that size
17:03:36 <tomberek> copumpkin, that would require a foldM-ish
17:03:38 <tomberek> ?
17:03:57 <copumpkin> tomberek: yep
17:04:01 <Mathnerd314> which is faster for linear access (i.e. foldl'): [], IntMap, or Data.Array?
17:04:10 <Funktorsalat> luite: not that obvious? ;)
17:04:10 <copumpkin> Mathnerd314: definitely Array
17:04:10 <ManateeLazyCat> Funktorsalat: I have program can do those work parallel, like now, i'm use it send irc message to you and play music at background.
17:04:22 <Cale> luite: One could use an even less efficient representation of numbers to improve the "performance" further!
17:04:40 <luite> Funktorsalat: well it is, because a dynamic programming algorithm works :)
17:04:41 <Cale> (perhaps)
17:05:03 <Mathnerd314> copumpkin: is Data.Array also good for random index lookups?
17:05:03 <Funktorsalat> luite: well yes, but I wouldn't call that algo obvious
17:05:09 <copumpkin> Mathnerd314: yes
17:05:16 <copumpkin> Mathnerd314: just don't ever change it :)
17:05:20 <luite> Funktorsalat: I mean it's obvious, knowing that such an algorithm exists :)
17:05:22 <copumpkin> but if you have a fixed one, it's super fast
17:05:30 <Cale> Mathnerd314: I would say lists.
17:06:09 <copumpkin> Cale: why? lists can be spread all over memory
17:06:40 <Funktorsalat> luite: btw, what'd be an example of "strongly NP-hard"? something where numbers don't matter at all I guess...
17:06:47 <copumpkin> lists do fuse better than arrays, but Vectors fuse better than both
17:06:50 <luite> Funktorsalat: 3-SAT is the best known example
17:06:53 <Cale> Well, I suppose I'm not thinking about cache coherence. If you want to do anything with the elements of the array, you'll be following indirections anyway.
17:06:57 <Funktorsalat> SAT, binary integer LP ;)
17:07:11 <copumpkin> Cale: yeah, but half as many indirections, still :)
17:07:27 <Cale> In order to linearly access the elements of an Array, you typically apply elems to it and turn it into a list anyway
17:08:00 <Funktorsalat> luite: is 3-SAT = 3-CNF SAT?
17:08:06 <Cale> Or, you use a list like [0..n] to pick indices.
17:08:07 <luite> Funktorsalat: yes
17:08:29 <Funktorsalat> ok, that's another one that doesn't actually *have* any numbers ;))
17:08:37 <luite> it automatically makes the more general SAT problems strongly NP hard of course :)
17:09:11 <luite> yes, I'm trying to think of one that actually has numbers, but I don't know one off the top of my head
17:09:30 <Funktorsalat> binary integer LP is a gray area I guess
17:09:31 <Funktorsalat> ;)
17:09:45 <Funktorsalat> 0,1,2 integer LP! ;)
17:10:00 <aristid> stop calling 3-SAT 3-SAT and call it the "warm fuzzy problem" to avoid people from fearing the term
17:10:39 <Funktorsalat> black and white kittens conglomerating in groups of three?
17:10:45 <tomberek> copumpkin :   wait,, isn't  (listOf . elements) the same as subListOf ?
17:10:57 <copumpkin> tomberek: possibly
17:11:05 <copumpkin> tomberek: I never remember the quickcheck combinators :)
17:11:11 <tomberek> hmmmmmm, one moment
17:11:16 <copumpkin> sounds about right though
17:11:34 <tomberek> it is!
17:11:37 <copumpkin> nice :)
17:11:42 <tomberek> or at least the first 10 samples look that way!
17:11:54 <copumpkin> quickcheck that they're equal! :P
17:11:56 <copumpkin> ;)
17:12:00 <copumpkin> pity that isn't possible
17:12:18 <copumpkin> I guess it could be actually
17:12:32 <copumpkin> but it's unlikely they would be equal
17:12:36 <llambda> Cale, luite, but how would that be affecting the time complexity?
17:12:52 <tomberek> copumpkin:   grrrr... ok,,, so now I to get two subsets, equal in size... i could use suchThat, but would you say that is too waseful?
17:13:03 <copumpkin> probably
17:13:12 <copumpkin> the chance of them being the same size is pretty slim
17:13:24 <luite> Funktorsalat: the travelling salesman problem might be strongly NP-hard, but I'm not sure
17:14:14 <sm> chrisdone: http://github.com/chrisdone/amelie-emacs-cast .. er what ? how do you play this back ?
17:14:26 <tomberek> copumpkin, that's what I was thinking, I'm just amazed that an interdependence is so hard to set up inside of a data structure
17:14:29 <luite> llambda: do you mean the dynamic programming algorithm for your subset-sum problem?
17:14:35 <llambda> luite, yep
17:14:50 <sm> I've never heard of an emacs-cast, but it sounds useful
17:15:02 <tomberek> create a set, create two equally sized subsets of the first one.     takes 12 words in english
17:15:11 <llambda> It says it is still not polynomial time because of that -- but that seems to only be talking about space
17:15:22 <Cale> llambda: Well, it just changes the way that you measure it. The algorithm is linear in the numbers P and N, but exponential in the number of bits in the input.
17:15:58 <Cale> and what matters for purposes of complexity theory is the asymptotic performance relative to the number of bits in the input
17:16:14 <llambda> Wouldn't that make all algorithms that use numbers exponential if measured with bits?
17:16:20 <Cale> No
17:16:33 <luite> llambda: suppose your k is small, and all elements are integers, then you would be able to solve the problem in O(k * |S|) time (simplest case when all elements are nonnegative)
17:17:15 <copumpkin> tomberek: you can also describe "find whether a subset of a 100000-element set sums to 0" in not many english words :)
17:17:24 <luite> llambda: the complexity increases linearly with k, so it's still exponential in the size of the encoding of k
17:17:26 <Cale> For example, the elementary-school algorithm for addition is linear
17:17:43 <ManateeLazyCat> New version hlint fix many bugs.. :)
17:18:01 <tomberek> copumpkin: sure, and a naive implementation of that (running through one by one) should not take much more words
17:18:11 <tomberek> a proof is completely different
17:18:35 <copumpkin> tomberek: you can do the same thing in not much haskell :P
17:18:59 <copumpkin> tomberek: or how about "a program that decides whether other programs halt (without running them)"
17:18:59 <tomberek> well, i think i'm making progress, i'll get back to you
17:19:13 <tomberek> yeah yeah.. stop it.. pun intended
17:19:55 <Cale> and multiplication of two n-bit numbers can be done in O(n log n log log n) time, while the elementary school method is quadratic
17:20:37 <copumpkin> mmm
17:20:39 <luite> llambda: when proving that something has a polynomial-time algorithm, you can usually assume that primitive operations like multiplication take constant time
17:21:36 <Cale> Though, for practical purposes of the constant factors involved, most large but manageable sizes of number are better handled by Karatsuba multiplication, which is O(n^1.585), or Toom-Cook multiplication, which decreases that exponent a bit further.
17:21:38 <luite> llambda: that works if you bound the space that can be used by the algorithm
17:22:07 <copumpkin> I think GMP automatically selects between different approaches for different sizes of operands
17:22:08 <tomberek> copumpkin: technically, the listOf . elements returns a sub-bags of the original list, but that's what i wanted anyway
17:22:17 <copumpkin> tomberek: ah okay
17:22:26 <luite> (so no "cheating" by multiplication of huge numbers that have an exponential number of bits)
17:22:56 <Cale> Well, multiplication is a polynomial-time operation, so it's okay to use it regardless :)
17:23:34 <Cale> Oh, of course, you have to watch the size of the numbers involved relative to your input size :)
17:23:50 <luite> Cale: it depends on how long the numbers are. you need to be careful, you can't just assume that those numbers are small in encoding compared to the input
17:25:49 <Cale> Right. There are algorithms for computing Fibonacci numbers for instance which use a number of multiplications which is linear in the number of bits of the input, but since the output size is exponential in the input size, the function can't hope to be any faster than exponential time.
17:25:57 <Cale> s/function/algorithm/
17:26:37 <Cale> Er, sorry, even better, you can use log n multiplications for n bit inputs
17:26:46 <luite> there's also the problem of the existence of strongly polynomial time algorithms for linear programming
17:27:14 <Cale> No, I was right in the first place, linear :)
17:27:34 <Funktorsalat> luite: not for integer lp
17:27:45 <luite> there are polynomial time algorithms under the assumption that you can multiply any two numbers in constant time
17:27:58 <luite> but those don't really work on actual computers :)
17:28:13 <Funktorsalat> for normal lp?
17:28:18 <luite> yes
17:28:34 <Funktorsalat> we proved it for rational arithmetic iirc
17:28:55 <luite> the interior point and ellipsoid methods are weakly polynomial
17:29:03 <Cale> Do people actually care so much about the "weak" case like that?
17:29:14 <Funktorsalat> possibly with rounding which is "good enough"
17:29:25 <luite> Funktorsalat: the problem is that denominators may get huge
17:29:39 <Funktorsalat> luite: are you saying LP isn't really in P or something?
17:30:24 <luite> Funktorsalat: that's one of the open questions
17:30:47 <Funktorsalat> odd
17:30:59 <qz> is it possible to define data types in ghci? it says 'parse error on input `data'
17:31:07 <Cale> qz: no
17:31:23 <qz> Cale, how do i experiment with types then? :p
17:31:38 <Cale> qz: You put them in a file and load it. It's handy to keep the file open alongside ghci and use :r in ghci whenever you change the file
17:31:52 <Cale> (which reloads it)
17:32:11 <qz> Cale, i see.. thanks
17:32:50 <qz> yet its pretty strange restriction
17:33:08 <Cale> Yeah, I suppose it is
17:33:27 <Cale> Though it's sort of an uncommon thing to want to do in practice.
17:34:03 <Cale> Usually once you get to the point of defining new datatypes, you're writing a program which is real enough to deserve to be in its own file.
17:34:25 <Funktorsalat> luite: so did the proof I'm thinking of use constant-time arithmetic then? (but why the stuff about rounding then)
17:34:39 <qz> yeah i guess its a pain to define any decent data type in ghci, but i'm just doing one-liners to understand how it works
17:34:41 <Funktorsalat> maybe that was for the square roots...
17:34:50 <luite> Funktorsalat: I don't know the proof you're thinking about ;p
17:34:59 <Funktorsalat> true o_o
17:35:06 <aristid> Cale: i've often wanted the ability to define types in ghci, just to play around
17:36:26 <Cale> aristid: Yeah.
17:36:29 <luite> Funktorsalat: it could be strongly polynomial if you use an approximation algorithm
17:36:52 <luite> for example if you solve it to within epsilon
17:37:06 <Cale> I've probably created a "tree.hs" file to define a simple binary tree type more times than I can recall, but in a sense, that's the fault of the base library. :)
17:37:08 <luite> if would be fully polynomial if the degree of the polynomial wouldn't depend on the choice of epsilon
17:37:31 <Cale> But it would be nice to be able to do it on the ghci commandline.
17:37:42 <Funktorsalat> luite: hmm we solved the "does there exist a solution" problem, which is equivalent to opimization, though maybe not in a strong enough sense for this purpose :p
17:38:03 <Funktorsalat> +P
17:38:04 <luite> Funktorsalat: oh sorry I was wrong about the P, since that is about decision problems
17:38:16 <luite> at least I didn't think about it enough...
17:38:35 <luite> hmm, the question would be, does there exist a solution with objective value > x
17:38:46 <luite> hmm, make that c
17:38:50 <luite> it's a constant :)
17:39:18 <Funktorsalat> which is just another constraint
17:39:43 <Funktorsalat> (another linear one, since the objective function is linear)
17:40:05 <Funktorsalat> I don't remember the reduction off hand
17:40:12 <luite> yes, so indeed, the question would be whether existence of a solution is in P
17:40:23 <Funktorsalat> but iirc it actually uses linear programming details, not just abstract nonsense
17:40:48 <luite> it probably bounds the number of primitive operations by some polynomial
17:41:02 <luite> where primitive operations include arithmetic on arbitrary numbers...
17:41:37 <Funktorsalat> (I mean for finding the optimal solution in polynomial time giving an algorithm for deciding satisfiability)
17:41:59 <luite> really?
17:42:24 <luite> aren't you talking about the 0-1 ilp problem?
17:42:48 <Funktorsalat> either I think
17:43:08 <Pseudonym> Is it generally true that 0-1 ILP problems are almost always easily representable as SAT?
17:43:09 <luite> it would be easy to reduce sat to integer linear programming
17:43:26 <Pseudonym> The thing is, SAT solvers are about a thousand times more efficient than ILP solvers, generally speaking.
17:44:28 <Pseudonym> So much so that just like how modern ILP solvers are generally a coordinating layer on top of simplex, FD solvers are often a coordinating layer on top of SAT.
17:45:01 <tomberek> copumpkin: great success!!!!!
17:45:09 <copumpkin> I'm making a note here
17:45:15 <Pseudonym> "SAT Modulo Theories", I believe it's called.
17:45:27 <copumpkin> yep
17:45:35 <copumpkin> edwardk has been talking about that a lot recently
17:45:46 <Cale> It would be an interesting project for someone to make one of those maps of equivalences between NP-complete problems but where all the edges are labelled with statistics on the constant factors involved in the conversion.
17:45:49 * Pseudonym had a long discussion with Peter Stuckey about this a couple of weeks ago.
17:45:50 <ivanm> preflex: seen Heffalump 
17:45:51 <preflex>  Heffalump was last seen on #darcs 4 hours, 3 minutes and 4 seconds ago, saying: <real world> yeah. Or see if there are any accidents.
17:45:53 <Adamant> SAT solvers have a lot of hardcore optimizer types working on them.
17:46:07 <Funktorsalat> :o
17:46:14 <tomberek> copumpkin:   easy way to do it:     ns <- arbitrary                     number <- choose (0, length ns)                     let nGen = elements (map fst ns)                     ei <- vectorOf number nGen                     eo <- vectorOf number nGen, then whatever return you want
17:46:29 <Adamant> for instance, they're more and more commonly used by the crypto/security set, and those guys have a lot of folks who really, really know C and ASM
17:46:31 <Funktorsalat> luite: which part exactly are you asking about?
17:46:35 <luite> Cale: they're usually polynomial factors though, but that only makes it more interesting :)
17:46:38 <copumpkin> tomberek: makes sense :)
17:46:42 <Funktorsalat> (by "really?")
17:46:58 <Cale> luite: indeed
17:47:08 <tomberek> and it's simple, no new functions needed, and it only produces exactly what is uses
17:47:11 <ivanm> tomberek: I've been reading through the BGL manual; and I think a lot of their stuff won't apply to ours directly
17:47:16 <ivanm> e.g. adjacency graph
17:47:30 <ivanm> it seems to be a cross between a class and a data type IIUC
17:47:46 <tomberek> ivanm: no, probably not, but you never know... i just got a quickcheck instance for a random instance
17:48:09 <Funktorsalat> luite: (that it's nontrivial to reduce optimization to nonemptyness or that it's possible? ;))
17:48:54 <Funktorsalat> my memory on all this is a bit rusty sadly :(
17:49:20 <luite> Funktorsalat: sorry I missed what you were talking about
17:53:19 <ivanm> @hoogle LEdge
17:53:19 <lambdabot> Data.Graph.Inductive.Graph type LEdge b = (Node, Node, b)
17:53:19 <lambdabot> Data.Graph.Inductive.Graph delEdge :: DynGraph gr => Edge -> gr a b -> gr a b
17:53:20 <lambdabot> Data.Graph.Inductive.Graph delEdges :: DynGraph gr => [Edge] -> gr a b -> gr a b
17:57:11 <tomberek> ivanm: should we turn Edge into (Node g,Node g)?
17:57:32 <ivanm> don't we already do that?
17:57:41 <ivanm> and then LEdge is (Edge g, EdgeLabel g)
17:58:20 <tomberek> for symmetry, I didn't.... it works fine, but I'll need to add some Edge->Node and Node->Node->Edge functions
17:58:55 <tomberek> or just forgo that and make it a pair?
17:59:12 <ivanm> which is what I think we have
18:00:19 <tomberek> ivanm, yes, in FGL, i'm talking about my version for now (calling it BGL for now)    can you never think of an instance where an Edge won't be defined as the pair?
18:00:27 <ivanm> oh, right
18:00:35 <ivanm> tomberek: undirected edges
18:00:38 <tomberek> I can't right now, but perhaps some smart person can
18:00:48 <ivanm> technically, an undirected edge is a two-element set
18:00:54 <tomberek> yeah!  where it's a set of size two
18:00:58 <ivanm> you also have hypergraphs, etc. ;-)
18:01:43 <Funktorsalat> (hypographs?)
18:01:47 <tolkad> I know there's a IntMap for native ints but are there any for other integral types? like Int8?
18:01:58 <Funktorsalat> that'd be sets I reckon
18:02:02 <tolkad> maps that is
18:02:21 <Saizan> tolkad: no
18:02:26 <copumpkin> tolkad: it'd be nice :(
18:02:26 <Funktorsalat> for Int8 you might just want an array
18:02:35 <Funktorsalat> of length 256...
18:03:01 <tolkad> well let's say Int64 then :P
18:03:19 <copumpkin> simple, just use a 64-bit machine
18:03:27 <copumpkin> ;)
18:03:41 <luite> Funktorsalat: it would be quite slow to enumerate the elements of such a collection, if you only have few
18:04:03 <luite> and you lose the efficient updates of Map
18:04:17 <tolkad> copumpkin: I am!
18:04:26 <copumpkin> tolkad: there you go then
18:04:28 <Funktorsalat> luite: slow? :p
18:04:42 <tolkad> copumpkin: no, haskell is still using 32 bit ints
18:04:42 <luite> Funktorsalat: well, O(1), but still :p
18:04:47 <tolkad> copumpkin: ghc that is
18:04:50 <copumpkin> tolkad: oh mac os :P
18:04:55 <hpc> is there a 64-bit build of GHC?
18:05:00 <Funktorsalat> it might still be relatively fast because it's so packed
18:05:02 <copumpkin> hpc: for some platforms
18:05:16 <luite> Funktorsalat: hmm, I'm not sure, you can't use an unboxed array
18:05:26 <Funktorsalat> not? :o
18:05:53 <tolkad> don't all terminating operations run in O(1) on any particular computer :P?
18:06:17 <Funktorsalat> luite: you can't use an unboxed one if you need a null value I guess
18:06:34 <luite> Funktorsalat: if the elements are unboxable, you could, but you'd need to do some additional work, since you don't want to store elements of type a, but of type Maybe a
18:06:42 <Funktorsalat> depending on the application there might be an acceptable default number.
18:06:50 <copumpkin> luite: wasn't he talking about IntSet8 ?
18:07:12 <Funktorsalat> oh right, I was confused about keys vs values
18:07:12 <copumpkin> Int8Set, maybe
18:07:13 <luite> oh then it would just be bool and I'd be wrong :)
18:07:16 <kmc> tolkad, IntMap should perform well on integer types smaller than Int
18:07:17 <sshc> Agh, when will lambdabot be back up?
18:07:22 <Funktorsalat> luite: no you're right
18:07:27 <kmc> you could use EnumMap for a nicer API
18:07:28 <copumpkin> sshc: bug Cale 
18:07:31 <copumpkin> :t moo
18:07:43 <kmc> for types *larger* than Int, (e.g. Int64 on a 32bit machine) use "hashmap"
18:09:27 <tolkad> Cale: bug
18:09:40 <sshc> Cale: bug
18:09:45 <AnAdorableNick> Cale: bug
18:10:11 <aristid> Cale: bug
18:10:57 <Cale> wat
18:11:04 <Cale> oh
18:14:35 <tomberek> ivanm: is there a way to handle those wierd graphs but use (Node g , Node g) ?
18:15:07 <tolkad> it would be nice if there was an ord instance for mvar
18:15:32 <tolkad> that way there could be a function to make sure you always take them in the same order
18:17:17 <copumpkin> tolkad: that would be nice, but seems hard without locking to create new MVars
18:22:19 <Axman6> just keep all your MVars in a Map in an MVar and take them in order of the keys
18:26:49 * hackagebot kit 0.4.1 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.4.1 (NickPartridge)
18:33:12 <copumpkin> :o
18:33:30 <copumpkin> okay, I have no idea what that does, and it has no documentation or website
18:33:32 <copumpkin> but I'm curious
18:34:00 <Colours> I just spent a few days trying to get xcode/obj-c and haskell to work together
18:34:01 <Colours> so me too
18:34:30 <hpc> copumpkin: wait for it to build and run haddock
18:34:45 <copumpkin> no, it's not a library
18:34:56 <copumpkin> you'd still see the exported modules if haddock hadn't run yet
18:35:11 <copumpkin> http://github.com/nkpart and http://twitter.com/nkpart
18:35:26 <nkpart> that's me :)
18:35:29 <copumpkin> oh hi!
18:35:33 <copumpkin> what's kit do? :P
18:36:16 <copumpkin> oh I see
18:36:21 <copumpkin> you have a using.html in the github repo
18:36:45 <nkpart> As you said, not a library. It's a bit like a cabal/rubygems for xcode objective-c projects 
18:36:58 <copumpkin> ah, interesting
18:37:00 <nkpart> it's only used internally at the place I work, atm
18:37:08 <copumpkin> cool :)
18:37:21 <Mitar> is there a way to write something as easy as: (-100) <= power <= 100
18:37:31 <copumpkin> does the fat that the using.html is in a site/ directory suggest that it's on a website somewhere?
18:37:47 <copumpkin> *fact
18:37:48 <copumpkin> lol
18:38:32 <nkpart> no sorry, t it's not hosted anywhere yet
18:38:37 <copumpkin> okay :)
18:40:53 <ivanm> tomberek: hypergraphs aren't used much anyway
18:40:59 <tomberek> hm...
18:41:03 <ivanm> I've never heard of one being actually implemented or used
18:41:26 <copumpkin> hmm, I found something useful for them recently
18:41:29 <copumpkin> but now I've forgotten what
18:41:46 <tomberek> ivanm: roger
18:41:51 <copumpkin> roger dodger
18:42:29 <Axman6> :t liftM2 (&&) ((-100) <=) (<= 100) 
18:42:30 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
18:42:55 <Axman6> > liftM2 (&&) ((-100) <=) (<= 100) (-105)
18:42:56 <lambdabot>   False
18:43:01 <Axman6> > liftM2 (&&) ((-100) <=) (<= 100) (-95)
18:43:02 <luite> I've recently used them for the set cover problem, which is basically the same as edge cover, but for hypergraphs
18:43:02 <lambdabot>   True
18:43:06 <Axman6> > liftM2 (&&) ((-100) <=) (<= 100) (95)
18:43:07 <lambdabot>   True
18:43:10 <Axman6> > liftM2 (&&) ((-100) <=) (<= 100) (105)
18:43:11 <lambdabot>   False
18:43:15 <Axman6> hooray
18:43:15 <luite> err, I mean vertex cover
18:43:23 <copumpkin> Axman6: did I ever mention my ARM project to you? been working on it a lot recently
18:43:30 <aristid> :t (-100 <=)
18:43:31 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
18:43:33 <Axman6> nope?
18:43:58 <copumpkin> Axman6: ah, I started an epic arm project a bajillion years ago and finally picked it up again
18:44:03 <copumpkin> for static analysis on arm
18:44:11 <Axman6> what can it do?
18:44:59 <copumpkin> for now, it's a well-tested (strongly typed) decoder/disassembler on all of the standard ARM instructions, and I'm in the middle of adding thumb(2) and coprocessor/neon ones too
18:45:11 <Axman6> nice :)
18:45:12 <copumpkin> as in, all instructions have operands and the operands are typed
18:45:19 <copumpkin> using the most ridiculous GHC extensions
18:45:55 <copumpkin> the more random extensions I can throw into a project, the better I feel about myself
18:45:58 * copumpkin hugs himself and rocks
18:46:28 <hpc> do any extensions conflict with each other?
18:46:35 <hpc> if not, you should try for all of them
18:46:46 <copumpkin> well, -fglasgow-exts turns them all on
18:46:57 <aristid> copumpkin: no it only turns up some
18:47:00 <copumpkin> oh?
18:47:03 <copumpkin> some completely cover the functionality of others
18:47:12 <aristid> it misses some that i use
18:47:23 <aristid> i think UndecidableInstances is not in, or so
18:47:23 <copumpkin> like ExistentialQuantification is basically made redundant except for syntax by GADTs
18:48:02 <aristid> or was it TupleSections?
18:48:13 <aristid> TupleSections are awesome by the way
18:48:26 <copumpkin> yeah :)
18:59:07 <micahjohnston> has anyone had experience installing with the haskell llvm bindings
18:59:13 <micahjohnston> with installing*
18:59:33 <ivanm> presumably someone has
18:59:38 <ivanm> why, what's the error?
19:00:09 <micahjohnston> I think my efforts to fix it have screwed everything up worse, but the error originally was that it couldn't find some dylibs
19:00:12 <micahjohnston> (I'm on OSX)
19:01:26 <ivanm> could be a problem
19:01:49 <micahjohnston> so I used ld to create dylibs out of the .a files llvm had
19:01:55 <micahjohnston> and then I got more errors
19:02:15 <ivanm> Axman6: ^^ any ideas?
19:02:36 <sshc> How do I find the type that GHC infers of a *function* in a where block?
19:02:38 <Axman6> have you installed a recent version of LLVM?
19:03:02 <micahjohnston> I have 2.7
19:03:18 <ivanm> sshc: take it out of the where block?
19:03:21 <micahjohnston> although *now*, I can't even get llvm to work at all
19:03:31 <Axman6> i'd try reinstalling LLVM
19:03:49 <Axman6> "Generating and compiling a zillion numerical type aliases, this might take a while" heh
19:03:58 <ivanm> @tell Heffalump well, my plan is to kinda make rmonad useless by re-implementing the Functor and Monad classes you have, though atm they're all living in Data.Restricted.*
19:03:58 <lambdabot> Consider it noted.
19:04:16 <sshc> ivanm: That clearly doesn't work
19:04:19 <ivanm> @tell Heffalump though I haven't considered doing any transformer stuff like you have
19:04:19 <lambdabot> Consider it noted.
19:04:33 <ivanm> sshc: you could try putting in a type sig and seeing what ghc bitches about it
19:04:53 <ivanm> if you're trying to get it to use type variables the same as in the outer type sig, you may need ScopedTypeVariables
19:05:16 <tomberek> ivanm: you're good with deciphering the overlapping instances with type families?
19:05:25 <ivanm> ummm, maybe?
19:05:33 <Absolute0> Is cryptography a good research area to get into?
19:06:03 <ivanm> Absolute0: if you like it, then possibly yes
19:06:08 <sshc> GHC is pretty unhelpful in that regard
19:06:16 <ivanm> sshc: :s
19:06:22 <tomberek> ivanm: i get on overlapping instance problem,, when I try to fix it, i get "Context reduction stack overflow; size = 20"
19:06:26 <ivanm> sshc: why, what kind of error is it spitting out?
19:06:37 <ivanm> tomberek: ugh; why do you have overlapping instances?
19:06:53 <sshc> What is "(Ord a[aTZ])" in a typeclass constraint?
19:06:57 <Absolute0> ivanm: i think its cool but not sure if its tangible for me, never actually studied it before, taking a course now, seems hard to grasp
19:07:04 <ivanm> sshc: using TH?
19:07:08 <sshc> I'm not familiar with that syntax, particularily the "[aTZ]"
19:07:12 <ivanm> if not, that might just be from some deriving stuff
19:07:14 <tomberek> Arbitrary [Node g] and the build-in Arbitrary [a] are conflicting
19:07:26 <sshc> ivanm: Yes
19:07:35 <sshc> I'm not familiar with TH either
19:07:37 <tomberek> *built
19:07:48 <ivanm> tomberek: yeah, what are you using it for?
19:08:11 <ivanm> sshc: neither am I that much, but the "[aTZ]" bit is making me think of TH
19:08:20 <ivanm> are you doing any derivations via TH?
19:08:27 <tomberek> ivanm: I never declared either, but I am using arbitrary (with it's type being Gen [(Node g,a)]  
19:08:49 <sshc> ivanm: How could I do that?
19:09:16 <ivanm> tomberek: ummm, if you never declared an Arbitrary instance for [Node g], then I don't get the problem
19:09:26 <tomberek> ivanm: it makes an arbitrary graph... i got it working for an arbitrary graph for a particular instance, now I'm trying instance (Arbitrary a, Arbitrary b, Graph g, NodeLabel g ~ a, EdgeLabel g ~ b) => Arbitrary g where
19:09:26 <Funktorsalat> I think the a[aTZ] is just a variable name
19:09:35 <ivanm> sshc: if you were doing it, you'd probably know ;-)
19:09:56 <tomberek> ivanm: yeah, i never made it, I think it makes one behind the scenes
19:10:03 <ivanm> I doubt it
19:10:05 <ivanm> highly
19:10:13 <copumpkin> preflex: seen alpmestan
19:10:14 <preflex>  Sorry, I haven't seen alpmestan
19:10:17 <copumpkin> preflex: seen alp
19:10:18 <preflex>  alp was last seen on #haskell-blah 170 days, 1 hour, 38 minutes and 12 seconds ago, saying: yeah!
19:10:28 <ivanm> oh, right, that's probably from some type alias or something
19:10:31 <ivanm> paste your code up
19:10:49 <tomberek> ivanm: Node g is a type family from Graph remember?
19:11:18 <ivanm> yes
19:11:26 <ivanm> but what is your Arbitrary instance for g?
19:11:34 <ivanm> I had similar problems with current FGL, but with tuples
19:11:46 <ivanm> copumpkin: I don't think he's going to talk to you any time soon...
19:12:22 <copumpkin> ?
19:12:24 <copumpkin> why not?
19:12:28 <tomberek> iivanm: http://codepad.org/szM4zL3N
19:12:51 <objorn> Can you easily define your own languages in Haskell like you can in Lisp?
19:12:59 <alisa> hi all
19:13:57 <tomberek> ivanm: for that version of the code, the error complains of an overlap between Arbitrary [(Node g,a)] and Arbitrary [a]
19:14:02 <ivanm> tomberek: you do have an instance of Arbitrary for Node, don't you?
19:14:09 <tomberek> nope
19:14:09 <kfish> objorn, like, can you write a DSL in Haskell?
19:14:28 <ivanm> tomberek: then how is it going to be able to make ns?
19:14:41 <copumpkin> preflex: seen Alpounet
19:14:42 <preflex>  Alpounet was last seen on #haskell 16 days, 14 hours, 25 minutes and 24 seconds ago, saying: oh, Data.Bits
19:14:54 <ivanm> tomberek: also, you're not supplying labels
19:14:57 <copumpkin> ah, not too long ago
19:15:02 <alisa> is there a .net port for haskel?
19:15:12 <objorn> kfish: Yes.
19:15:30 <tomberek> ivanm: adding Arbitrary (Node g) to context should clear it, it doesn't
19:15:33 <alisa> and how do i use that?
19:15:46 <objorn> I'm guessing you can, is there a resource for doing this?
19:16:03 <objorn> Ah, Google shows me a few.
19:16:09 <tomberek> ivanm : ns :: Gen [(Node g,a)]     es :: Gen [b]
19:16:16 <kfish> objorn, yup, lots of examples :)
19:16:18 <tomberek> the labels are there
19:16:40 <ivanm> tomberek: right, but you haven't told it how to generate Node g
19:16:51 <ivanm> so you probably need "Arbitrary (Node g)" there as well
19:16:58 <tomberek> ivanm: i did that, no change
19:17:13 <tomberek> ivanm: that was my first thought
19:17:23 <ivanm> tomberek: you're also not supplying labels to ns
19:17:37 <ivanm> tomberek: you're treating ns as both "LNode g" and "Node g"
19:17:56 <tomberek> notice the (map index ns)
19:18:00 <ivanm> unless mkEdge is stripping out the node labels
19:18:10 <ivanm> oh, what's index?
19:18:15 <tomberek> fst
19:18:18 <ivanm> ahhh
19:18:29 <tomberek> ns gives [(Node g,a)]
19:18:38 <ivanm> *shrug*
19:18:38 <copumpkin> is there a place to find a list of the accepted haskell gsoc 2010 proposals?
19:19:12 <ivanm> tomberek: I wouldn't have used number based off the length of ns
19:19:17 <tomberek> i count the number of them, then pick out the Node g, then create two more subsets of Node g and a set of b (all three of which are the same size as the the number)
19:19:20 <ivanm> I would have just gotten an arbitrary Int
19:19:29 <ivanm> copumpkin: the wiki?
19:19:52 <copumpkin> ivanm: was trying to find a page on it
19:19:54 <tomberek> ivanm: i do:  choose (0,length ns)
19:19:55 <ivanm> tomberek: since you're only testing for sparse graphs ;-)
19:19:55 <copumpkin> but only found the trac
19:20:02 <copumpkin> and can't find a final list on the trac
19:20:07 <ivanm> http://www.haskell.org/pipermail/haskell-cafe/2010-March/074496.html
19:20:21 <ivanm> copumpkin: oh, for accepted look up the overall GSoC page
19:20:27 <ivanm> and find the haskell related ones
19:20:29 <copumpkin> oh okay
19:20:30 <ivanm> or else it was in an email IIRC
19:20:42 <copumpkin> couldn't find it in an email
19:20:45 <copumpkin> will just lookon googles page
19:20:46 <copumpkin> '
19:20:53 <ivanm> copumpkin: http://www.google.com.au/search?hl=en&q=haskell+google+summer+of+code+2010+accepted
19:20:55 <ivanm> bah
19:21:01 <ivanm> copied the URL too soon
19:21:03 <ivanm> I meant http://donsbot.wordpress.com/2010/04/26/the-7-haskell-projects-in-the-google-summer-of-code/
19:21:51 <copumpkin> ah, cool
19:21:53 <copumpkin> thanks
19:22:00 <chemuduguntar> is this a valid type signature? bind f' :: (Float,String) -> (Float,String)
19:22:23 <ivanm> no
19:22:25 <ivanm> get rid of the f'
19:22:39 <ivanm> you don't list arguments in type sigs
19:22:52 <chemuduguntar> ah i see
19:22:58 <tomberek> ivanm: should i just scrap the attempt and revert to the version that worked for a particular instance of Graph?
19:23:07 <ivanm> might be easier
19:23:19 <ivanm> tomberek: actually, my plan was to have a newtype (actually several) for graphs and use that
19:23:56 <tomberek> ah, newtype RandomSparseGraph, RandomDenseGraph, etc?
19:24:08 <ivanm> yeah
19:24:25 <tomberek> good idea, but if i can't get this to work, what chance do we have?
19:25:45 <tomberek> ivanm: i added a Node g ~ Int, and the error text only changed to say Int
19:25:55 <ivanm> tomberek: not an overall automatic derivation, so it should be easier
19:26:18 <tomberek> ivanm: i think type families are conflicting with something
19:26:41 * ivanm doesn't
19:26:51 <tomberek> hm..... :)
19:27:10 <copumpkin> tomberek: what's your error?
19:28:08 <tomberek> Data\Graph\Boost\Properties.hs:26:26:     Overlapping instances for Arbitrary [(Int, a)]       arising from a use of `arbitrary'                    at Data\Graph\Boost\Properties.hs:26:26-34     Matching instances:       instance (Arbitrary a) => Arbitrary [a]         -- Defined in Test.QuickCheck.Arbitrary
19:28:36 <tomberek> this is after I added Node g ~ Int to the context of the instance declaration
19:28:41 <copumpkin> contexts don't affect overlap
19:28:54 <copumpkin> OverlappingInstances should be able to distinguish that though
19:28:56 <ivanm> right, it means you're using it wrong
19:29:10 <tomberek> i'm not using overlappingInstances at the moment
19:29:23 <copumpkin> well, if you really need both those instances, you'll have to start :P
19:29:48 <tomberek> i have flexible instance, and undecidable.... adding overlapping does this: 
19:29:51 * ivanm -> food
19:30:04 <copumpkin> lol
19:31:05 <geheimdienst> i think "ivanm <- food" would make more sense. food :: IO Food and then you extract it from the IO into ivanm
19:31:27 <tomberek> copumpkin:   Data\Graph\Boost\Properties.hs:1:0:     Context reduction stack overflow; size = 20     Use -fcontext-stack=N to increase stack size to N         `$dArbitrary{a7Z4K} :: {Arbitrary
19:31:37 <copumpkin> tomberek: yeah, your instances are actually undecidable
19:31:54 <copumpkin> or
19:32:01 <copumpkin> increase the context size :)
19:32:12 <LolRat> it'll probably still overflow
19:32:13 <copumpkin> I'd be more scared of the undecidable than the overlapping
19:32:16 <tomberek> well, it shows the recursion into Node node Node Node
19:32:22 <LolRat> incoherent
19:33:52 <tomberek> copumpkin: it demands undecidableInstances because "Constraint is no smaller then the instance head
19:34:06 <copumpkin> tomberek: and you can't express it some other way?
19:34:38 <LolRat> newtypes or just use a function (and forAll or similar)
19:34:54 <tomberek> well, this is a generalization of that code we were talking about before.. only this time, there is a type family (Node g) that is messing things up
19:37:26 <ManateeLazyCat> geheimdienst: bla bla <- liftM ivanm food 
19:37:42 <tomberek> it seems to be recursing down the type family... Node g   to Node Node Node Node ....
19:40:21 <copumpkin> ManateeLazyCat: I don't think ivanm is a function, and definitely not a pure one if he is
19:42:33 <geheimdienst> ivanm is impure? i think that's a little offensive
19:44:43 <ivanm> it sure is!
19:44:53 * ivanm is as pure as snow!!!
19:45:07 <tomberek> driven snow
19:45:45 <ivanm> well, I still haven't seen a serious amount of snow, so I am unaware of the distinction
19:45:49 <geheimdienst> ivanm is as pure as freshly fallen snow on the tongue of a newborn kitten
19:45:53 <geheimdienst> at least!!
19:46:08 <ivanm> lol
19:46:10 * hackagebot FTPLine 1.0.2 - A command-line FTP client.  http://hackage.haskell.org/package/FTPLine-1.0.2 (DanielDiaz)
19:46:37 <ivanm> people still use ftp?
19:46:43 <geheimdienst> ivanm, after a of lying on the road with a bazillion cars running over, snow becomes a greasy dark-gray squishy mish
19:46:45 <tomberek> hehe
19:46:47 <ivanm> and need another CLI client to do so?
19:47:00 <ivanm> geheimdienst: then no, that's not me
19:47:31 <tomberek> ivanm: i'm almost at wits end... it recurses down Node g to Node Node Node ... Node g, trying to terminate
19:47:38 <geheimdienst> ... that's why he said "driven snow" and i was careful to specify "fresh"
19:47:54 <tomberek> yes, freshly driven snow
19:48:31 <ivanm> tomberek: no idea tbh
19:48:39 <ManateeLazyCat> geheimdienst: See ? "Food -> ... -> IO BlaBla" ? :)
19:48:39 <ivanm> I think you've done something wrong
19:48:48 <ivanm> tomberek: take a few steps back: try to create a graph with no edges
19:49:02 <tomberek> ivanm: of course I've done something wrong.  i always do  :)
19:49:06 <tomberek> ok i'll try that
19:49:08 <geheimdienst> :)
19:50:37 <tomberek> instance (Graph g) => Arbitrary g where     arbitrary = do  ns <- arbitrary                     return $ mkGraph ns []     produces the same error
19:51:39 <tomberek> adding Arbitrary (Node g), etc. does nothing
19:52:16 <ivanm> you need Arbitrary (NodeLabel g) as well
19:52:25 <tomberek> that's the etc.
19:52:27 <tomberek> no change
19:52:30 <ivanm> right
19:52:43 <ivanm> what's the type of mkGraph? [LNode g] -> [LEdge g] -> g ?
19:52:44 <tomberek> it's a conundrum
19:53:33 <tomberek> yeah
19:54:27 <tomberek> at it never seems to have a similar problem with EdgeLabel or Edge
19:54:32 <tomberek> or NodeLabel
19:54:34 <tomberek> only Node
19:55:44 <ivanm> maybe it is a TF problem...
19:55:52 <ivanm> tomberek: try asking on -cafe
19:56:00 <tomberek> uh,, where?
19:56:03 <ivanm> get down to a minimal use case though; e.g. try a non-graph class
19:56:09 <ivanm> tomberek: haskell-cafe mailing list
19:56:14 <ivanm> you're subscribed to that, right?
19:56:14 <tomberek> oh
19:56:32 <tomberek> yeah, 
19:56:45 <tomberek> i sent out a copy of the new version yesterday
20:18:51 <ivanm> is it just me, or could this be simplified using liftM3? http://hackage.haskell.org/packages/archive/template-haskell/2.4.0.1/doc/html/src/Language-Haskell-TH-Lib.html#instanceD
20:19:07 <ivanm> only non-obvious bit is the sequence stuff AFAICT
20:19:46 <tomberek> yes
20:21:24 <tomberek> um, ivanm... i think i know
20:21:44 <ivanm> what?
20:22:21 <tomberek> if I make that an instance, it would effectively close the class,,, 
20:23:43 <ivanm> which is bad
20:23:52 <ivanm> which is why I was planning on using newtypes
20:23:59 <ivanm> doesn't explain the problem though AFAICT
20:25:31 <tomberek> ivanm:  i'm trying to just come up with something of form ( [(n,a)] , [ ((n,n),b)] )  instead
20:28:02 <copumpkin> seems like an iteratee is just Free (-> K) for some type K that you want to look over
20:28:11 <copumpkin> ((->) K) that is
20:28:32 <copumpkin> isn't it?
20:28:40 <ivanm> *shrug*
20:28:49 <ivanm> anyone know how to do type family instances with TH?
20:29:32 <dolio> Try sticking an instance inside a [d| ... |] and see what pops out.
20:29:52 <kmc> istr support for them added in 6.2
20:29:52 <dolio> That's how I usually figure out how to write TH.
20:29:54 <kmc> 6.12*
20:30:02 <ivanm> dolio: in ghci?
20:30:07 <kmc> dolio, too bad you can't actually splice half the stuff you can quote :/
20:30:23 <dolio> I think it works in ghci, yeah.
20:30:52 <dolio> You might have to fiddle with a Q -> IO or something, too.
20:31:47 <kmc> runQ
20:31:51 <kmc> as long as you don't need to reify
20:32:03 <dolio> As you can probably tell, I don't use much TH.
20:32:13 <copumpkin> we needz mmorrow the TH master
20:32:17 <ivanm> whenever I try, I get "Illegal family instance ... " :s
20:32:32 <ivanm> with and without runQ
20:32:50 <ivanm> copumpkin: yeah :s
20:32:56 <copumpkin> ivanm: so [d|type instance Moo Int = Bool|] fails? 
20:33:09 <ivanm> well, I'm using a data instance that I had in my code
20:33:22 <ivanm> so it _should_ work, since ghci accepted it when it was in the file
20:33:38 <ivanm> note I'm using an actual data family, not a type family
20:33:44 <copumpkin> shouldn't change things
20:34:40 <ivanm> gah, ghci doesn't recognise that it should have -XTypeFamilies set even though it's set in the file it has loaded
20:34:59 <copumpkin> yeah, a few extensions behave that way
20:35:06 <copumpkin> things like NoImplicitPrelude for some reason
20:35:28 <ivanm> but anyway, looks like I want DataInstD
20:35:45 <ivanm> oh, right, FamilyD is probably for defining new type families
20:48:46 <ivanm> dolio: which letter do I use to see what gets generated for an instance?
20:49:11 <dolio> I thought it was d, for declaration.
20:49:19 <dolio> [t| is type, [| is expression.
20:49:46 <dolio> There may be others.
20:50:05 <ivanm> oh, I was thinking d was for data...
20:50:21 <kmc> join #haskell-blah
20:50:24 <kmc> whoopsie
20:50:47 * monochrom lends out some /'s
20:52:22 * copumpkin wants a parametrized module in haskell :(
20:52:43 <ivanm> copumpkin: you mean like ocaml?
20:52:51 <copumpkin> yeah or agda
20:53:57 <wli> Parametrized modules in Haskell would rule the world.
20:54:29 <tomberek> ivanm::: it works!!!!
20:54:29 <tomberek> hey !
20:54:56 <ivanm> what was wrong?
20:55:00 <ivanm> and how did you fix it?
20:55:17 <copumpkin> -fglasgow-exts
20:55:20 <copumpkin> :P
20:55:25 <tomberek> ivanm: it works, but I need some help figuring out what the difference is,, give me a sec and I'll post it,, you have a few min to go over it?
20:55:49 <monochrom> I want parameterized modules too. But don't call them functors. :)
20:56:00 <tomberek> http://codepad.org/YbOIswu4
20:56:42 <ivanm> tomberek: yeah, a bit
20:56:44 <iFire> what's ghc's git repo  git clone http://darcs.haskell.org/ghc.git  doesn't work
20:56:48 <tomberek> ivanm: ok,basically, I made RGraph just a newtype that stores the arguments that will go into mkGraph
20:57:01 <tomberek> then I made an instance of Arbitrary for it
20:57:02 <ivanm> iFire: strangely enough, I wouldn't expect there to be a git repo on that machine... ;-)
20:57:06 <ddarius> monochrom: Applicative functors no less.
20:57:11 <ivanm> tomberek: ahhh, right
20:57:19 <tomberek> ivanm: that part worked pretty easy
20:57:27 <ivanm> tomberek: please put spaces before equal signs ;-)
20:57:39 <copumpkin> iFire: I don't think they keep the git up to date anymore
20:57:44 <copumpkin> but an old one is on github
20:57:58 <ivanm> copumpkin: I think someone keeps syncing it
20:58:01 <iFire> also is there a gui for darcs?
20:58:07 <copumpkin> http://github.com/ghc-hq/ghc
20:58:09 <copumpkin> doesn't look like it
20:58:21 <tomberek> then I started making d... giving me lots of issues... sometimes it would say Arbitrary (Node g) needs to be added,, when it was already right there.... 
20:58:29 <ivanm> iFire: why do you need a GUI?
20:58:34 <iFire> just wondering I don't
20:59:02 <iFire> also it means I have to go to the cmd line in win7 :)
20:59:03 <ManateeLazyCat> iFire: Maybe i will develop Darcs client, if i have time.
20:59:16 <iFire> or kick cygwin
20:59:20 <ivanm> gah! I'm getting a "GHC stage restriction" because `var' is used in a top-level splice or annotation, and must be imported, not defined locally
20:59:24 <ivanm> wtf?!?!?!?!?!
20:59:25 <ManateeLazyCat> ivanm: Don't need type patch name when interactive with darcs.
20:59:35 <tomberek> then it gave me problems with Edge not being injective... so I did a trick I used before, was make the function take an entire instance as an argument... somewhere along the way, that allows the compiler to figure out that I am not changing Edge g to Edge g1... and that also auto-magically fixed the other problem too
20:59:42 <ivanm> ManateeLazyCat: I prefer good patch names to autogenerated garbage
20:59:55 <tomberek> ivanm: but I don't know why, but it works
21:00:30 <ManateeLazyCat> ivanm: When i want do diff on some *range* i need type patch name for *from-patch* and *to-path*, even regex is boring and waste time.
21:00:44 <tomberek> ivanm:  i can then call     sample $ d (empty :: IntMapGraph String Bool) and it works perfectly
21:00:46 <ManateeLazyCat> ivanm: If have graphics client, we just need select it and no more type.
21:01:04 <ivanm> oh, you mean type when selecting it, not when creating a new patch?
21:01:23 <iFire> ivanm well the other reason is that both hg and git have gui clients 
21:01:37 <tomberek> ivanm: so we can start writing test code
21:01:40 <ManateeLazyCat> ivanm: My all plan is integrate darcs with IDE.
21:01:44 <ivanm> iFire: ... so?
21:01:58 <ivanm> ManateeLazyCat: IDE/editor integration is different from a standalone gui IMHO
21:02:17 <ManateeLazyCat> ivanm: My framework is good for that.
21:02:23 <ManateeLazyCat> ivanm: lunch, back soon.
21:02:48 <ManateeLazyCat> ivanm: I need eat much food, then i can output "IO BlaBlaBlaBla"... :)
21:03:47 <tomberek> ivanm: and all it needs is FlexibleContexts
21:08:51 <QtPlatypus> I was reading a page that said the unix system of pipes and commands where a monad.  But it seems to me that its more like an arrow.
21:09:30 <Cale> It's more like a monoid, in that there's only one type
21:10:08 <Cale> You can concatenate *any* two programs end to end by connecting the stdout of one to the stdin of the next
21:10:14 <kmc> yup
21:10:18 <kmc> the only type in UNIX is [Word8]
21:10:18 <Cale> and there's an identity, cat
21:10:27 <Pseudonym> Well, any programs that read stdin and write stdout.
21:10:29 <ivanm> dammit, why can't TH have an actual explanation about why it won't accept stuff? :s
21:10:55 <Cale> Pseudonym: Even if they don't, the composition will still work.
21:11:15 <Cale> (bash will not complain)
21:11:49 <EvanR> everythings a monoid
21:12:37 <ivanm> and types are but its instances?
21:13:45 <tomberek> ivanm: i can even set another parameter to adjust the "denseness" of the graph   (basically multiplying the length value by a factor)
21:13:59 <ManateeLazyCat> I'm back.
21:14:01 <Cale> A monoid is a category with only one object. If unix pipes and programs were typed, then they'd probably form a category instead.
21:14:40 <ivanm> tomberek: dont' use length
21:14:43 <Cale> (Whose objects were the types, and whose arrows were programs)
21:14:48 <ivanm> get an arbitrary Int instead
21:15:32 <tomberek> ivanm: um... huh?
21:15:42 <tomberek> the length is determined by an arbitrary list
21:15:46 <tomberek> so it is arbitrary
21:15:59 <ivanm> tomberek: are you still using the length of that list to generate the number of edges?
21:16:28 <tomberek> yes,, but it is choose (0, someMultiplier* length ns)
21:16:36 <ManateeLazyCat> ivanm: Because TH is a horse, difficult to manage. ;p
21:16:39 <tomberek> so it is randomly chosen to be in that range
21:16:53 <ivanm> ManateeLazyCat: heh
21:16:59 <tomberek> the multiplier can be changed to adjust the density of the graph
21:17:08 <ivanm> tomberek: except that doing number <- arbitrary will avoid traversing the list to find its length
21:17:13 <ivanm> when you don't really need to know its length
21:18:01 <tomberek> ivanm: ah, true, but having two different arbitrary calls will make very odd graphs
21:18:13 <ivanm> huh?
21:18:23 <ivanm> you already have more arbitrary calls when generating edge labels!
21:18:40 <tomberek> ivanm: i mean in terms of topology
21:18:50 <ivanm> really? why?
21:18:52 <tomberek> but, ok, i'll make the change
21:19:57 <tomberek> ivanm: ok it works, i have to go catch a flight, but quickCheck is ready for some testing
21:20:52 <tomberek> ivanm:  it's not about speed because to create the node generator, i have to traverse the list anyway
21:21:30 <ivanm> avoids another traversal
21:22:23 <tomberek> ivanm: is this a question of speed? should I allow illegal graphs be entered? (like where an edge is pointing to a nonexistant node)?
21:22:30 <tomberek> that would get rid of another traversal
21:22:34 <ivanm> no
21:22:54 <ivanm> but I don't see why defaulting to having the same number of edges and nodes makes sense
21:22:58 <ivanm> make the ratio random
21:23:21 <tomberek> ivanm:   it IS!  
21:23:36 <ivanm> tomberek: only if you pass in some parameter
21:23:57 <ivanm> and even then, to make the actual ratio random you'd need to pass in a random parameter, and how does that differ from what I'm suggesting?
21:24:45 <tomberek> it is a Generator, it takes makes a random call every time
21:24:52 <ivanm> what is?
21:25:01 <tomberek> arbitrary :: Gen a
21:25:53 <tomberek> having that parameter lets us adjust the density of the graph.... average of twice as many edges as nodes,, three times, etc..
21:26:16 <tomberek> so we get DenseGraph and SparseGraph almost for free
21:29:52 <ivanm> tomberek: but how does that differ from just using an arbitrary number of edges?
21:30:05 <tomberek> no control over the density
21:30:09 <ivanm> tomberek: or, if you're insistent on having the length of the list be used, generate an Int, then use vectorOf to generate ns
21:30:13 <ivanm> rather than finding the length of ns
21:30:24 <tomberek> that can be done
21:30:36 <tomberek> sure, we can do that
21:30:58 <ivanm> makes more sense than a useless list traversal
21:32:36 <tomberek> ivanm: well, because quickCheck is biased toward 0 and 1 (looking for those edge case) that gives us a lot more trivial graphs
21:32:53 <tomberek> not too bad though
21:35:47 <tomberek> leaving out the other traversal gives us 90% trivial graphs
21:37:11 <tomberek> k, i gotta go, but i'l work on it
21:38:51 <dibblego> can someone please remind me of the ghc flag to run on 2 cores?
21:39:10 <kmc> the RTS flag?
21:39:11 <kmc> +RTS -N2
21:39:14 <kmc> need to build with -threaded
21:39:20 <dibblego> ah yeah that's him thanks
21:41:13 <ivanm> OK, the type checker isn't making sense: I have a list of Functions of type Name -> Pred, var is of type Name, so I do "map ($var) cntxts", and the type checker spits out "Couldn't match expected type `ExpQ' against inferred type `Name'"
21:41:41 <dibblego> \x -> map ($x) = mapM
21:42:02 <ivanm> huh?
21:42:08 <ivanm> I'm not doing that...
21:42:16 <kmc> ivanm, you should exclaim angrily that this is a bug in GHC
21:42:25 <ivanm> I have a value called "var"
21:42:31 <ivanm> kmc: didn't I just do that? :p
21:42:38 * ivanm is trying to work out if it is indeed a bug
21:42:57 <dibblego> sorry I meant sequence
21:43:13 <ivanm> @type sequence
21:43:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:43:32 <ivanm> @pl \ v -> map ($v) vs
21:43:32 <lambdabot> flip map vs . flip id
21:43:33 <ddarius> $x is a splice with TH enabled
21:43:39 <ivanm> dammit, that's it
21:43:47 * ivanm bangs his head against a convenient desk
21:44:05 <ivanm> @type sequence [succ, pred]
21:44:06 <lambdabot> forall a. (Enum a) => a -> [a]
21:44:22 <ivanm> OK, that fixed that problem
21:44:45 <ivanm> now I suddenly have "Couldn't match expected type `CxtQ' against inferred type `[a]'" ... and the list in question is an empty list :s
21:46:34 <ivanm> why does it bitch when something is too polymorphic? :s
21:47:54 <c_wraith> usually, if it does that it's because something is a rigid type variable somewhere
21:48:13 <c_wraith> Like if you say [5] :: [a]
21:48:43 <ivanm> well, I have "dataInstD [] ... "
21:48:47 <ivanm> and it's bitching about the []
21:48:49 <objorn> What does the Hithchiker's Guide to Haskell mean by "layout is 2-dimensional"?
21:48:56 <ivanm> even when I specify a type sig for that list
21:49:02 <ivanm> objorn: indentation
21:49:33 <objorn> It's stating I should know how indentation works?
21:49:36 <c_wraith> > [] :: [a]
21:49:37 <lambdabot>   []
21:49:41 <c_wraith> > [4] :: [a]
21:49:42 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
21:49:42 <lambdabot>    arising from the li...
21:50:03 <ddarius> @hoogle CxtT
21:50:04 <lambdabot> No results found
21:50:11 <ddarius> @hoogle runQ
21:50:12 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
21:50:12 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
21:50:23 <ivanm> @hoogle CxtQ
21:50:23 <lambdabot> Language.Haskell.TH type CxtQ = Q Cxt
21:50:23 <lambdabot> Language.Haskell.TH.Lib type CxtQ = Q Cxt
21:50:32 <ivanm> objorn: yes
21:50:41 <ivanm> objorn: because like Python, Haskell uses indentation
21:50:49 <ivanm> (well, there is optional braces, but they're discouraged)
21:51:02 <ddarius> So why are you expecting a list to be a Q Cxt?
21:51:28 * ivanm facepalms
21:51:32 <ivanm> yes, you're right
21:52:09 <kmc> ivanm, clearly a bug in GHC ;P
21:52:10 <kmc> ;)
21:52:32 <ivanm> thing is, it bitched about something that wasn't a bug
21:52:37 <ivanm> when I removed that I got this issue
21:52:51 <ivanm> (actually, that might have been related to the ($var) bit)
21:53:00 <ivanm> when I fixed this one, I then got a couple of others
21:53:16 <kmc> objorn, in the "typical" style of Haskell syntax, indentation is used to stand in for invisible ; { } characters
21:53:32 <kmc> you can avoid indentation-sensitivity by writing those characters yourself
21:53:36 <kmc> but it is probably best to learn how the rule works
21:54:07 <kmc> for which i like http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
21:54:15 <kmc> @where layout
21:54:15 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
21:54:17 <kmc> haha
21:54:28 <kmc> @where+ layout2010 http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
21:54:28 <lambdabot> I will remember.
21:55:42 <ddarius> I'm pretty sure those sections are identical.
21:58:49 <copumpkin> didn't they change the if behavior in do blocks?
21:58:55 <kmc> yeah
21:59:03 <kmc> but that's not a matter of layout explicitly
21:59:10 <copumpkin> ah
21:59:15 <kmc> the grammar now allows «if foo; then bar; else baz»
22:00:58 * ddarius needs a door mat for his bed room.
22:03:25 <NemesisD> anyone have any good ideas for preventing namespace pollution in records? i happen to have 2 records which conceptually belong to the same module, but both have an attribute of say "name"
22:04:05 <copumpkin> @hackage fclabels
22:04:05 <lambdabot> http://hackage.haskell.org/package/fclabels
22:04:33 <mtnviewmark> well - IF they were in sub modules - and you imported both modules qualified, what qualification labels would you use?
22:04:37 <ddarius> NemesisD: Use the module system.
22:04:39 <mtnviewmark> then just make that the prefix
22:04:41 <mtnviewmark> :-)
22:05:08 <copumpkin> if you put them in separate modules, you can ask GHC to disambiguate for you
22:05:12 <copumpkin> even without qualifying the accessors
22:05:28 * ddarius retches on that.
22:05:29 <ivanm> @tell Heffalump also, I've managed to work out some TH to auto-generate Constraints and Suitable instances: e.g. $(genSuitable ''Set [ClassP ''Ord . return]) 
22:05:29 <lambdabot> Consider it noted.
22:05:35 <copumpkin> :)
22:05:55 <Mitar> so haskell still has NULL, it is just called undefined?
22:06:11 <ivanm> completely different
22:06:15 * ddarius should make a pre-processor for his local modules idea and then get it included in Haskell.
22:06:16 <Mitar> i have just managed to remove a Maybe for undefined/defined combination
22:06:21 <ivanm> undefined means "something fucked up, you shouldn't try to do any work"
22:06:30 <copumpkin> Mitar: unlike NULL, you can't check for undefined
22:06:30 <ivanm> null means "I haven't bothered to initialise this variable"
22:06:33 <lispy_> SNAFU!
22:06:34 <mtnviewmark> no, Mitar - you can't really compute w/bottom 
22:06:36 <Mitar> and then i noticed that it is the same pattern as NULL in other languages
22:06:38 <ivanm> copumpkin: you can in IO, can't you?
22:06:46 <copumpkin> ivanm: yeah, but IO isn't haskell :P
22:06:49 <ivanm> Mitar: null is more analogous to Nothing than undefined
22:06:51 <ivanm> copumpkin: heh
22:06:52 <copumpkin> no true scotsman ever uses IO
22:06:55 <mtnviewmark> so you don't use undefined (or bottom) like you use NULL in other languages
22:06:56 <Mitar> no problem if i cannot compute it
22:07:01 <lispy_> yeah, Nothing ~= null
22:07:05 <ivanm> copumpkin: luckily, I'm not a scotsman!
22:07:09 <Mitar> i can make a linked list where i make a pointer to next instance NULL = undefined ;-)
22:07:16 <mtnviewmark> use Nothing instead
22:07:19 <copumpkin> Mitar: sure, but you can't check for it
22:07:27 <copumpkin> so you just crash if you ask for it
22:07:29 <Mitar> if I do not need to check for it ...
22:07:34 <Mitar> yes, so it is like NULL
22:07:41 <Mitar> null pointer exception ;-)
22:07:50 <Mitar> great ;-)
22:07:53 <kmc> Mitar, in Java you can do (x == null)
22:07:53 <ddarius> Mitar: What people are saying is you can't write: if next == null then ...
22:07:56 <mtnviewmark> no, because the Nothing that goes with Maybe Foo    is not the same as the Nothing that goes with Maybe Bar
22:07:59 <copumpkin> yes, except nulls in other languages you can prevent with if (x) { ... do something with x }
22:08:02 <kmc> in Haskell you cannot do check (x == ⊥)
22:08:11 <ddarius> So while undefined may or may not work for what you are doing, it is still dramatically unlike null.
22:08:20 <Mitar> yes, i understand that you cannot check for undefeined
22:08:21 <ddarius> @hoogle isBottom
22:08:21 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
22:08:32 <kmc> suppose that in Java, (x == null) threw a NullPointerException
22:08:36 <ddarius> (Which would probably actually work in this case.)
22:08:36 <copumpkin> @hackage spoon -- yeah, I know this doesn't help get the point across
22:08:37 <lambdabot> http://hackage.haskell.org/package/spoon -- yeah, I know this doesn't help get the point across
22:08:37 <kmc> then the situation would be more like Haskell
22:08:39 <Mitar> but it has the same bad property: it allows you to write programs which crashes at runtime
22:08:42 <kmc> yup
22:08:52 <lispy_> > Nothing == fix id
22:08:56 <lambdabot>   mueval-core: Time limit exceeded
22:09:21 <kmc> Mitar, you could program in Agda
22:09:31 <copumpkin> @let halts a = a `seq` True
22:09:33 <lambdabot>  Defined.
22:09:33 <kmc> which has, in addition to a type checker, a termination checker
22:09:44 <ddarius> You'll be safe from crashes then because your programs won't do anything.
22:09:49 <Mitar> ;-)
22:10:00 <kmc> this is important because Agda's type system allows you to express *any* property in the type, so it's useful for proving that your code is correct
22:10:02 <copumpkin> hey, you can make agda programs do stuff!
22:10:07 <kmc> but the type of "fix" is a clear lie logically
22:10:10 <copumpkin> but nobody knows how to :P
22:10:10 <kmc> (a implies a) implies a
22:10:14 <dolio> You have to worry about the type checker crashing.
22:10:25 <dolio> Due to Haskell stack overflows and stuff.
22:10:25 <copumpkin> > halts undefined
22:10:27 <lambdabot>   *Exception: Prelude.undefined
22:10:29 <copumpkin> > halts 5
22:10:30 <lambdabot>   True
22:10:33 <kmc> Haskell? stack overflow? never!
22:10:53 <Mitar> is there a way to see if any of "pure" functions you are using in a program use unsafe* functions?
22:10:53 <zaphar_laptop> hrmmmm I think I may have just successfully hacked Yi scrolling to not suck.
22:12:36 <kmc> Mitar, i don't know of one
22:13:28 <kmc> that's the feature (contagious tagging of impure functions) that people claim Haskell has but it doesn't at all
22:13:44 <Mitar> yes
22:14:09 <Mitar> there should be at least some warning-way for that
22:14:19 <Mitar> it would be great to have this on hackage
22:14:24 <Mitar> for every function
22:14:38 <Mitar> so that you would be able to choose among different libraries/functions/modules based on that
22:15:02 <ddarius> Mitar: Very many libraries would be marked as "unsafe" then, e.g. any using ByteStrings.
22:15:38 <Mitar> no problem ;-)
22:15:45 <Mitar> are we pure or are we not?
22:15:56 <copumpkin> unsafe doesn't mean impure
22:16:03 <ddarius> If you push to the implementation, we are not.
22:16:14 <Mitar> they can attach proof for that ;-)
22:16:16 <copumpkin> it means the library writer needs to make sure code is pure
22:16:43 <Mitar> then they lose "unpure" tag ;-)
22:17:08 <copumpkin> everything is impure then
22:17:13 <copumpkin> almost, anyway
22:17:23 <copumpkin> your integer-addng function calls out to gmp
22:17:52 <copumpkin> (most of the time)
22:18:07 <Mitar> no problem
22:18:14 <kmc> also every GHC IO primitive is implemented with stuff equivalent to unsafePerformIO
22:18:19 <Mitar> but then we know what yet has to be done = proven
22:18:26 <kmc> you'd have to tag anything pattern-matching the IO constructor as unsafe
22:18:37 <kmc> and that includes the code for getChar, putStr, whatever
22:18:45 <copumpkin> Mitar: what would such proofs look like? and they'd only be proofs if you accepted their models of the outside world
22:19:04 <Mitar> so then you are saying that in fact there is no downside of using unsafe*? then we can use it because everybody else is using it?
22:19:24 <kmc> no, the downside is that by using it you take on a huge obligation
22:19:38 <kmc> you have to think about a lot of things that are usually taken care of for you
22:19:39 <Mitar> i am not saying that we cannot use unsafe* functions, only that it would be good to try to minimise that
22:20:15 <kmc> i would like a feature to give a general breakdown of where unsafe* stuff is coming from
22:20:25 <kmc> so i can see my program uses it but only indirectly through, say, bytestring
22:20:32 <Mitar> yes, so unsafe tag and a link to source where it is from
22:20:50 <Mitar> and then community could vote for how well the implementation is
22:20:52 <kmc> and then i can think to myself "dons is a pretty cool guy, eh writes library and doesn't afraid of anything"
22:20:54 <Mitar> and how well tested
22:21:04 <kmc> and proceed with confidence
22:21:10 <Mitar> exactly
22:21:22 <Mitar> but this could be also done if you do not know the author
22:21:28 <Mitar> but community vouches for the lib
22:21:32 <kmc> yeah
22:21:40 <kmc> for example "all the unsafe stuff you used is in Haskell Platform"
22:21:50 <kmc> every program will have an "unsafe dependency" on 'base'
22:22:08 <Mitar> this can also be useful for unit tests - if lib has unit tests and all pasess and it has so big code coverage and community vouched ...
22:22:53 <Mitar> the point is to get people to write tests and for libs not to have bugs (because otherwise people will not vouch)
22:23:38 <Mitar> (hm, but you can catch exception on access to undefined value, no? so you can test for undefined)
22:23:46 <kmc> main = IO (\s -> (# s, () #))
22:23:54 <kmc> Mitar, you can test, but only as an IO action
22:24:45 <lispy_> Mitar: but fix id is also undefined
22:24:51 <lispy_> Mitar: and the problem there is that it never terminates
22:24:57 <kmc> in evaluation, "undefined" is indistinguishable from other sorts of ⊥ like "fix id" and "find the biggest prime number"
22:25:05 <kmc> only in execution can you distinguish them
22:25:27 <Mitar> i am arguing that undefined is the same as null
22:25:31 <ddarius> The Report doesn't require undefined to throw an exception and doesn't even define a notion of catchable exceptions (thrown from pure code.)
22:25:41 <kmc> and we've already given some ways that undefined is unlike null
22:25:42 <Mitar> kmc: no, you can use unsafeIO to catch it in pure code ;-)
22:25:57 <Mitar> http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/src/Control-Spoon.html#spoon
22:26:03 <kmc> Mitar, sure, you can also use unsafeCoerce to patch into the innards of GHC and install a Java VM interpreter
22:26:09 <kmc> then you can really have null!
22:26:22 <Mitar> is not scala doing almost this? ;-)))
22:26:50 <ddarius> no
22:26:56 <Mitar> (that was a joke)
22:27:43 <lispy_> You can also have traditional C style pointers in Haskell if you really want it.
22:27:50 <min> I'm trying to get a quick visualization of a set of transitions using the Data.Graph library, here <http://hpaste.org/30096/>. I am running into the error "Exception: Node Exception, Node: 0", but it looks like it should work.
22:28:00 <lispy_> Otherwise, Maybe a is like a pointer, including a null.
22:28:13 <ddarius> You can have them whether you want them or not.
22:29:03 <lispy_> hmm...xchat is lame.  <http://example.com> is not a clickable URL but http://example.com is
22:29:30 <ddarius> Both clickable for me.
22:29:31 <lispy_> wait, that's not right
22:29:41 <lispy_> <http://example.com/>
22:29:51 <Mitar> but if undefined would be defined as fix id i would really think twice of using it ;-)
22:29:52 <lispy_> So, why was the url not clickable with min posted it?
22:30:04 <Mitar> but now i know that my program will finish if it reaches it
22:30:05 <lispy_> <http://hpaste.org/30096/>
22:30:13 <ddarius> lispy_: I say user error.
22:30:28 <lispy_> here <http://hpaste.org/30096/>.
22:30:32 <lispy_> ah ha!
22:30:38 <lispy_> It's the >. at the end, I think
22:30:55 <lispy_> <http://example.com>.
22:31:00 <lispy_> yeah, that totally does it
22:32:15 <ddarius> All of those work for me.
22:32:25 <min> That's weird. I thought <http://www.url.com> was a pretty standard way of posting URLs.
22:32:44 <ddarius> min: I still say that it is user error on lispy's part.
22:34:31 <kmc> my client handles it ok
22:34:39 <kmc> my xchat makes both clickable
22:36:14 <lispy_> ddarius: it seems pretty straight forward to me.  If I left-click on the text it either opens a browser to the url or not.
22:36:22 <lispy_> ddarius: and the one with the >. at the end does not.
22:36:27 <Twey> lispy_: Is <<http://example.com/>>?
22:36:36 <lispy_> Twey: no good :(
22:36:51 <Twey> Well, that's the RFC-recommended way of embedding URLs in text.
22:37:05 <Twey> So you should file a bug report, maybe.
22:37:10 <lispy_> Yeah, it some sort of x-chat aqua bug
22:37:17 <Mitar> twey: which RFC?
22:42:41 <lispy_> Oh, I should probably switch to this client: http://www.sysctl.co.uk/#macirssi
22:42:57 <Twey> Mitar: Oh, I didn't get it quite right (but 1738, appendix: Recommendations for URLs in Context
22:43:00 <Twey> )
22:43:28 <Twey> I guess <URL:http://example.com/>
22:43:58 <min> Oh, well. I suppose the problem was that I thought mkGraphs [LNode a], for some reason, was a list of relations, not labeled nodes. 
22:48:05 <kmc> so, why is the HTTP package's major version number 4000?
22:50:01 * hackagebot gsl-random 0.4 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.4 (PatrickPerry)
22:59:02 <dolio> kmc: It used to be numbered by the date, I think, which roped them into a main version in the thousands.
22:59:13 <kmc> haha
22:59:15 <dolio> Then when they stopped, they bumped to 3000.something, I think.
22:59:30 <kmc> that would be amusing with the PVP
22:59:43 <kmc> "we promise an API-breaking change every month"
23:00:36 <dolio> I'm not sure why they chose to bump to 4000 recently. Maybe they just treat the leading non-0 numbers as the major version now.
23:02:18 <olsner> what's the largest major-version that cabal will accept? :)
23:02:50 <Mitar> undefined?
23:07:46 <tomberek> hello
23:08:32 <kmc> hi
23:08:53 <kmc> olsner, hmm iirc cabal uses http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Version.html
23:09:36 <kmc> so you should not use a version component bigger than 536870911
23:10:04 <tomberek> kmc: have i asked you for your opinion yet on my graph library?
23:10:11 <tomberek> yet
23:10:12 <tomberek> ?
23:10:15 <kmc> tomberek, you mentioned it, i didn't take a look yet
23:10:19 <kmc> i'd like to see it though :)
23:10:46 <tomberek> let me post it up
23:11:41 <tomberek> kmc: it's a different approach than FGL, it needs some work, but I like it so far.  It seems easier to write implementations for because presents a logical sequence of operations for the implementor to define
23:11:55 <kmc> cool
23:11:57 <tomberek> http://codepad.org/vs0ce3mt
23:12:34 <olsner> ah, that'd leave 536866 more versions of the HTTP package until they run out of version numbers :)
23:16:44 <copumpkin> tomberek: isn't Directed a more common term than Directional?
23:17:35 <tomberek> copumpkin: yes, I'm actually thinking of merging Directed and Bidirectional
23:17:41 <tomberek> good/bad?
23:17:59 <tomberek> copumpkin: btw, i got that quickCheck generator working
23:19:27 <copumpkin> tomberek: what's a Bidirectional graph?
23:20:27 <tomberek> copumpkin (all these came from BGL)  it is a graph were edges inbound to a node can be retrieved
23:20:34 <copumpkin> ah
23:20:46 <tomberek> copumpkin : in addition to outbound
23:21:00 <copumpkin> tomberek: why not just split it into InGraph and OutGraph, and if you need both, just put both constraints on?
23:21:13 <copumpkin> c++ can't do that nicely
23:21:14 <copumpkin> but we can
23:21:27 <tomberek> copumpkin: sounds good..... unsure exactly what you mean though
23:21:50 <copumpkin> InGraph lets you query the inbound edges for a given node
23:21:55 <copumpkin> OutGraph lets you query the outbound ones
23:22:02 <copumpkin> so DirectionalGraph = OutGrap
23:22:10 <copumpkin> BidirectionalGraph = (InGraph, OutGraph)
23:22:16 <tomberek> oh, I get it     and InGraph class, an OutGraph class and a Bi class
23:22:18 <tomberek> yeah!
23:22:22 <tomberek> ok, i'll make the change
23:22:27 <copumpkin> well, the Bi class is just both of them
23:22:36 <copumpkin> it doesn't really give you much over the two separate ones does it?
23:22:46 <copumpkin> I guess a general notion of degree?
23:23:14 <tomberek> it's the notion of having both of them... edgesAll is the idea of being able to retrieve neighbors
23:23:20 <tomberek> (undirected graphs)
23:23:43 <copumpkin> yeah
23:24:13 <tomberek> it is free (all methods defaulted) if InGraph and OutGraph are defined, otherwise for an undirected graph, they need to be defined. or a hypergraph
23:25:01 <copumpkin> I see
23:25:12 <tomberek> next is AdjacencyGraph... even in BGL it isn't used, but I think because of laziness we don't need it
23:25:35 <copumpkin> graphEquality's Ord requirements are strange
23:25:57 <tomberek> nodesOut = (map (snd.index)) ... edgesOut   is pretty simple
23:26:10 <Mitar> how to find where undefined has been tried to be used?
23:26:23 <tomberek> copumpkin: i'll take a look, ivanm wrote that part
23:26:26 <copumpkin> Mitar: avoid undefined and write error "moo"
23:27:04 <tomberek> copumpkin : The Ord seems to be there so the sorts work
23:27:11 <copumpkin> oh I can see why it's there
23:27:19 <copumpkin> I just don't think it should need to be, in general
23:27:37 <copumpkin> seems like you'd just use Eq for each graph type
23:27:42 <tomberek> copumpkin: because it shouldn't matter if the edges are returned in a different order in the lists... hm..... tough one
23:27:44 <copumpkin> and the Ord would arise naturally if available
23:29:01 <tomberek> ok, we can change that to Eq, but then it becomes much less usable,, what about two version? graphEquality, graphEquality' where one were ordering matters and one not
23:29:18 <tomberek> one will require Eq, the other Ord
23:29:27 <copumpkin> also, on a broader scale, that's the motivation of separating all these classes? "X can support operations Y efficiently"?
23:30:01 <tomberek> copumpkin: partially, it also organizes things well IMHO....
23:30:14 <copumpkin> hmm
23:30:18 <copumpkin> yeah, but then your contexts get enormous
23:30:31 <copumpkin> like, how many things do you envision supporting one of vertexgraph/edgegraph but not the other?
23:31:09 <tomberek> not too many, but we can create a bothgraph class so the # remains the same
23:31:10 <copumpkin> I could understand if the methods in one of them were pure queries
23:31:14 <copumpkin> like Edge -> Bool
23:31:23 <copumpkin> (for function-backed graph structures, maybe)
23:31:38 <copumpkin> tomberek: yeah, but then you need to define a bajillion instances for everything
23:31:52 <copumpkin> many of which have no functionality whatsoever because the default methods cover every case
23:32:09 <copumpkin> like
23:32:11 <tomberek> yes, is that bad?
23:32:17 <copumpkin> going back to the BidirectionalGraph example
23:32:32 <copumpkin> it adds the degree method to something with both In and Out graphs
23:32:36 <copumpkin> and neighbors
23:32:44 <copumpkin> why do those belong in classes at all?
23:32:53 <tomberek> yes, it is defaulted, but it CAN be overwrited to allow hypergraphs, for example
23:33:19 <tomberek> a hypergraph is UndirectedGraph, but not InGraph nor OutGraph
23:33:30 <copumpkin> oh, so it wouldn't be a superclass
23:33:35 <tomberek> yep
23:33:49 <tomberek> I'm thinking of getting rid of AdjacencyGraph
23:34:42 <tomberek> nodesOut = (map (snd.index)) ...edgesOut    pretty simple, is it needed?
23:34:55 <tomberek> or just delete that whole class?
23:35:14 <copumpkin> also, one other suggestion I have
23:35:20 <copumpkin> oh maybe not actually
23:35:22 <copumpkin> hmm
23:35:29 <copumpkin> yeah, I guess it's less flexible
23:35:35 <tomberek> feel free, I liked that InGraph idea
23:35:48 <copumpkin> I was going to suggest your Graph work on * -> * -> *
23:35:54 <copumpkin> and get rid of the Node and Edge families
23:36:00 <tomberek> like FGL
23:36:16 <tomberek> ?
23:36:24 <copumpkin> hmm, can't remember
23:36:30 <copumpkin> the main benefit of using the families is to have non-polymorphic graph types, I guess?
23:36:42 <tomberek> um... big words...
23:36:45 <copumpkin> well
23:37:05 <tomberek> not sure EXACTLY what that means,, just a rough idea (i've learned that haskell is VERY specific about meanings)
23:37:23 <copumpkin> let's say I make data MyGraphType node edge = ...
23:37:44 <copumpkin> I could write instance Graph (MyGraphType node edge) where Node (MyGraphType node edge ) = node
23:38:01 <copumpkin> s/where Node/where type Node/
23:38:14 <tomberek> node ,,, not Node? or MyNode?
23:38:58 <tomberek> oh! yeah, ok, got it
23:39:03 <copumpkin> well I'm just saying that many graph types will be polymorphic, and in that case, the Node/Edge families will be trivial
23:39:12 <copumpkin> the only benefit to the system you have now is
23:39:20 <copumpkin> data MyIntNodeGraphType edge = ...
23:39:32 <tomberek> i have an instance of data IntMapGraph a b= IntMapGraph {nodeMap ::I.IntMap a ,edgeMap ::I.IntMap [(Int,b)]}
23:39:37 <copumpkin> yeah
23:40:07 <tomberek> but I WAS experimenting with something like data IntMapGraph a    , no b,,, it was internally ()
23:40:39 <tomberek> so I guess that makes g variable in its kind?
23:42:15 <copumpkin> I don't understand your question
23:42:26 <copumpkin> but anyway, yeah, I see why families work here
23:43:57 <copumpkin> also,     hasNode g n = maybe False (const True) (node g n)
23:44:06 <copumpkin> that's isJust (node g n)
23:44:08 <copumpkin> :t isJust
23:44:09 <lambdabot> forall a. Maybe a -> Bool
23:45:43 <tomberek> copumpkin: sorry, internet cut out... i might have missed a few things
23:46:00 <copumpkin> I just commented on
23:46:01 <copumpkin> hasNode g n = maybe False (const True) (node g n)
23:46:06 <copumpkin> that's isJust (node g n)
23:46:59 <tomberek> hm.... what was I doing?   maybe I was trying to avoid another import
23:47:57 <tomberek> (notice how few imports I need, yay!)   but isJust is cleaner,, good catch
23:47:58 <copumpkin> if you have maybe you have isJust :)
23:48:07 <copumpkin> you should
23:48:16 <copumpkin> oh maybe not
23:48:16 <tomberek> maybe is Prelude
23:48:22 <tomberek> isJust is an import
23:48:38 <tomberek> but isJust is better, i think you're right
23:53:40 <tomberek> copumpkin: all changes made and compiled
23:56:45 <tomberek> copumpkin: do you thing AdjacencyGraph is need? or defaulted functions, or just deleted?
23:56:45 <tomberek> thing...think
