00:00:58 <Cale> iFire: mostly vim
00:01:14 <kmc> iFire, vim here
00:01:41 <kmc> iFire, most people just use whichever editor they are otherwise comfortable with
00:01:42 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29812#a29812
00:02:07 <NemesisD> Cale: i gotta figure out how to have it do that only in haskell mode i think. i work with languages all day where 2 space soft tabs are the norm
00:03:12 <Cale> NemesisD:  autocmd FileType haskell expandtab
00:03:14 <Cale> er
00:03:19 <Cale> autocmd FileType haskell set expandtab
00:04:04 <Cale> But I tend to just blow away all tab characters I come across regardless. ;)
00:04:43 <shachaf> NemesisD: What do you mean by "soft tabs"?
00:06:04 <NemesisD> Cale: oh, looks like expandtab was already enabled, i meant i thought haskell's layout engine wanted hard tabs
00:06:16 <NemesisD> shachaf: \t rather than some number of spaces
00:06:21 <Cale> NemesisD: tab characters are evil
00:06:24 <shachaf> NemesisD: You mean \t characters?
00:06:43 <Cale> I actually think that \t should be considered an outright lexical error
00:06:53 <shachaf> NemesisD: Yes, nothing sane uses \t.
00:07:00 * shachaf notes that Makefiles require \t.
00:07:24 <NemesisD> ok someone in here told me tabs were the bees knees in haskell
00:10:04 <kmc> that is not the consensus ;)
00:10:25 <Cale> NemesisD: The reason that tab characters are bad is that in Haskell, what matters is how things line up vertically, and different editors / editor configurations treat them differently
00:11:26 <Cale> So if you're using tabs, you can't be sure that things line up on a column-by-column basis, particularly in cases where you have a bunch of text on one line, and are trying to line something up with it on the next line with whitespace
00:11:33 <Cale> Like:
00:11:40 <Cale> foo x y z =
00:11:47 <Cale>   do bar x
00:11:52 <Cale>      quux y z
00:12:26 <Cale> Of course, you can place the do on the first line as well, after the =
00:13:00 <Cale> But there are plenty of cases of that sort. let/in tends to look particularly ugly somehow if you put a line break after let
00:13:15 <NemesisD> you don't have to sell me on using spaces, i use them all the time :D
00:13:26 <Cale> Right, just explaining why it's especially important
00:13:56 <Cale> If that quux in my example was one space off in either direction, the meaning of the code is different
00:14:40 <robertmassaioli> What package could I look through to see a good example of huge data structures that have been nicely broken up into small, modular ones? (Thanks to any responses)
00:15:23 <Adamant> tabs are generally not popular in layout-based languages
00:15:33 <Adamant> same for Python
00:16:25 <Cale> robertmassaioli: This is not a direct answer, but you might be interested in or inspired by this presentation by SPJ: http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
00:17:06 <Cale> robertmassaioli: He discusses the strategy of constructing combinator libraries to express complicated structures in terms of simple building blocks
00:18:16 <etpace> @hoogle [(m a, b)] -> m [(a,b)]
00:18:17 <lambdabot> No results found
00:18:38 <etpace> any ideas on this one?
00:19:03 <Cale> etpace: hmm
00:19:46 <ski> Cale : well, it's pretty common to break line after `let' in SML : <http://www.cs.cornell.edu/Courses/cs312/2004sp/handouts/style.htm> (search for "Alternative Block Styles")
00:20:06 <kmc> :t \(x,y) -> (\z -> (z,y)) <$> x
00:20:07 <lambdabot> forall t a (f :: * -> *). (Functor f) => (f a, t) -> f (a, t)
00:20:24 <kmc> :t mapM $ \(x,y) -> (\z -> (z,y)) <$> x
00:20:25 <lambdabot> forall (m :: * -> *) t a. (Monad m, Functor m) => [(m a, t)] -> m [(a, t)]
00:20:42 <kmc> @pl \(x,y) -> (\z -> (z,y)) <$> x
00:20:42 <lambdabot> uncurry (flip ((<$>) . flip (,)))
00:20:51 <kmc> GHC 6.12 has TupleSections
00:21:10 <kmc> \(x,y) -> (,y) <$> x
00:21:16 <kmc> halfway decent
00:21:17 <ski> @type uncurry (fmap . (,))
00:21:18 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
00:21:19 <etpace> hmm
00:21:23 <Cale> The lambda with pattern matching works better than the way I was going :)
00:22:16 <etpace> wonder if (c -> m a) -> [(c,b)] -> m [(a,b)] is easier
00:23:53 <Cale> :t uncurry (liftM2 zip) . (sequence *** return) . unzip
00:23:54 <lambdabot> forall a b (m :: * -> *). (Monad m) => [(m a, b)] -> m [(a, b)]
00:24:14 <ski> (etpace : .. heh, yoneda)
00:24:42 <etpace> m?
00:25:34 * hackagebot asn1-data 0.1.1 - ASN1 data reader/writer in RAW/BER/DER/CER forms  http://hackage.haskell.org/package/asn1-data-0.1.1 (VincentHanquez)
00:26:16 <ski> hm .. or maybe not exactly
00:26:44 <Cale> I wonder if anyone has ever used mapAndUnzipM
00:26:53 <ski>   newtype Yoneda f a = Yoneda (forall b. (a -> b) -> f b)  -- when `Functor f', `f a' is isomorphic to `Yoneda f a'
00:27:00 <ski> @type mapAndUnzipM
00:27:01 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
00:27:05 <arw> uh, another asn.1-parser. anyone care to bet on the number of security holes, overflows and other stuff?
00:27:25 <ski> @type mapAndUnzipM id
00:27:26 <lambdabot> forall (m :: * -> *) b c. (Monad m) => [m (b, c)] -> m ([b], [c])
00:27:30 <Cale> It's sitting there in Control.Monad, and I don't think I've ever once had the occasion to use it
00:27:35 <kmc> if it's pure Haskell, probably free of buffer overflow attacks
00:28:11 <kmc> it kills me how many different standards there are for representing nested dictionaries of integers and strings
00:28:19 <tab> arw: in haskell ? :)
00:29:19 <arw> tab: an overflow can still happen in haskell. just read to much of a string and possibly misinterpret or expose information...
00:29:50 <arw> tab: you just can't cause a certain kind of overflows that are often a problem in C.
00:30:50 <tab> arw: ASN.1 is very easy not to read too much actually, if it works for 1 type, it works for every type.
00:30:54 <Cale> ouch, there are tabs in the code :)
00:31:06 <Cale> (for this asn.1 parser)
00:31:21 <arw> tab: yet tons of people managed to screw up their asn.1 parser.
00:33:16 <Cale> Weird, they also don't seem to know that let can hold more than one definition
00:33:33 * tab is they
00:34:00 <tab> Cale: mostly habits from the ocaml world
00:34:26 <Cale> ah, okay
00:34:47 <kmc> there's something to be said for single-binding lets
00:34:52 <Cale> let foo = ...
00:34:53 <kmc> removes the chance of accidental mutual recursion
00:34:55 <Cale>     bar = ...
00:34:57 <Cale>     baz = ...
00:35:01 <Cale>  in ...
00:35:29 <Cale> I suppose it would
00:35:31 <kulin> do any of the ffi preprocessor libraries have automatic conversions from c++ class functions to c functions where the class ptr is a parameter?
00:36:44 <tab> Cale: i'm slowly warming up to haskell syntax and leaving my ocaml habits behind .. so after some time ..
00:37:19 <Cale> :)
00:37:54 <Cale> tab: Eventually you'll probably even rename yourself to space
00:38:03 <tab> lol
00:38:32 <kmc> kulin, not to my knowledge.  C++ calling conventions vary by platform, compiler, and compiler version
00:38:47 <tab> Cale: for the moment I think that's perfectly fine like this
00:38:49 <kmc> kulin, binding C++ to any language other than C, including C++ from a different compiler, is a massive pain
00:39:27 <tab> Cale: until people contribute and wants to switch
00:39:29 <Cale> tab: You've somehow managed to avoid having problems with whitespace sensitivity so far
00:39:48 <Cale> (In part this is because of the way that you're writing lets)
00:39:48 <tab> Cale: i'm very disciplined with tab
00:39:54 <kulin> that sucks, 99% of my ffi code is: int func(obj* ptr, int a, int b) { return ptr->func(a, b); }
00:40:08 <kmc> you could at least generate that boilerplate
00:40:17 <kulin> how do you mean?
00:40:25 <tab> Cale: that also means i can set tabspace to whatever and it would still be correctly displayed :)
00:41:04 <Cale> tab: Haskell programmers tend not to care exactly how much things are indented, but it matters how they line up vertically
00:41:05 <shachaf> tab: That only works if you never use tabs and spaces in combination.
00:41:20 <kulin> tab is awful the second you share your code with someone else
00:41:21 <shachaf> tab: But that limits you quite a bit in some cases.
00:41:33 <tab> shachaf: i never mix them indeed
00:42:05 <kmc> kulin, you described a little 1-line C-to-C++ wrapper function
00:42:15 <kmc> which depends only on the name 'func' and the number and types of its arguments
00:42:18 <tab> kulin: when this time comes, and that becomes an issue, i'll change it to whatever without a problem
00:42:22 <ski> `Data.ASN1.Parser.pSequence' looks incomplete
00:42:24 <kmc> if you can describe those functions somewhere, you can generate the wrappers
00:43:08 <tab> ski: oups dead code file :)
00:43:10 <kulin> kmc this seems to be something I am not familiar with, if i google 'c boilerplate' that would be a good start?
00:43:18 <tab> ski: thanks for pointing it out
00:43:28 <kmc> kulin, err
00:43:43 <kmc> "boilerplate" just means repeated code
00:43:44 <kmc> in this case
00:43:51 <kmc> int func(obj* ptr, int a, int b) { return ptr->func(a, b); }
00:43:53 <ski> tab : btw, in `getNext' in the same module, you could s/(h:l) ->/h:l ->/ (and just fyi, the most common way is to write `v:vs' or something similar)
00:44:04 <bss03> tab: I don't know what your opinion on tab/spaces is, but I think I agree with you.
00:44:24 <kmc> #define WRAP2(func, ty1, ty2, rty) rty func(obj* ptr, ty1 a, ty2 b) { return ptr->func(a, b); }
00:44:25 <bss03> tab: I use a local tabstop of 2 here, but I use tabs in a way so that my code always vertically aligns independent of tabstop.
00:44:37 <kmc> kulin, now you only need to write "WRAP2(foo, int, int, int)"
00:44:58 <kulin> oh i see, i have never used c macros for anything other than #ifndef :)
00:45:01 <kmc> kulin, now, you could do what i described literally with the C preprocessor, or take the idea and generate these function definitions in a more clever way, meaning less work for you
00:45:05 <kulin> or whatever they are called
00:45:09 <kmc> i mean you can write a Haskell program to output them if you like
00:45:35 <kmc> this is why i was vague, i don't know particularly which boilerplate-generation strategy will fit your problem
00:45:47 <kmc> maybe you can even parse the headers of the library you're wrapping
00:45:52 <ski> tab : btw, re tabs, you can indent that way in Haskell, yes, as long as you always break the line after layout-starting keywords (well, unless the block fits on one line, i suppose) .. i str someone else here which indents like that
00:45:57 <tab> ski: i removed the file altogether now, but thanks for pointing it out
00:46:00 <kmc> parsing C++ in general is a nightmare, but if they adhere to some style conventions you might be able to hack it
00:47:10 <tab> ski: yes that's mostly what i do. there is indeed someone else (a John IIRC)
00:47:26 <kulin> i think i see, i will have to tinker for a bit, but this gives me a new way to think about it
00:48:06 <kulin> writing a parser is a bit more than i want, but the c pp should be handy
00:48:09 <Nereid> the only place I use tab is in a makefile.
00:48:10 <Nereid> :(
00:48:35 <Nereid> I usually indent by 4 spaces.
00:48:41 <ski> (tab : the only John i can think of is Meacham .. of which i have no idea how he indents)
00:48:52 <kmc> kulin, the same program should be able to output your "foreign import" declarations
00:49:02 <kmc> or output some file which in turn is input to hsc2hs etc.
00:49:58 <kulin> that is a good point
00:50:13 <bss03> Nereid: I dislike it when people use spaces instead of tabs; it means I can't easily adjust the about of horizontal whitespace to my preferences.
00:50:53 <bss03> But, 4 spaces is certainly acceptable.  Mixing tabs with spaces makes most people's code utterly unreadble to me.
00:51:05 <opqdonut> you can't indent haskell with just tabs
00:51:26 <bss03> opqdonut: I do, mostly.
00:51:29 <opqdonut> ok, sure, with a tabwidth of 1 or 2 and just replace spaces by tabs
00:51:32 <opqdonut> but that's just horrible
00:51:39 <bss03> opqdonut: I do use half-tabs sometimes.
00:51:55 <bss03> "where" gets 1 space indent.
00:52:11 <ski> (.. which code is "half-tab" ?)
00:52:11 <opqdonut> exactly my point
00:52:14 <bss03> case "labels" gets 1 space indent
00:52:22 <opqdonut> so you mix spaces and tabs too :)
00:52:31 <opqdonut> of course, having the tabs first makes it a bit more robust
00:52:38 <bss03> No, I don't mix them.
00:53:10 <tab> opqdonut: you can, depends what "indent" you're talking about
00:53:20 * ski frequently uses form feeds
00:53:23 <bss03> Not in the way that screws up redering on different tabstops.
00:53:35 <opqdonut> yeah, tabs first
00:54:12 <tab> as bss03 seeems to do, i do indent with tabs, then alignment with spaces if needed
00:54:17 <bss03> Well, using <TAB><TAB><SP><SP><SP><SP> at one level and then <TAB><TAB><TAB> at the next level screw things up too.
00:54:41 <jeltsch> Never use tabs!
00:54:42 <bss03> The first gets 8 columns in my setup, the second gets 6. :P
00:55:03 <bss03> Always use tabs!  Always with disclpline.
00:55:22 <bss03> Allow other programmers to choose the amount of horizontal whitespace *they* need when reading your code.
00:55:32 * tab agrees with bss03
00:55:58 <Nereid> I disagree
00:56:26 <jeltsch> bss03: But in Haskell, it is usual to not just indent wrt. the beginning of the last line but also wrt. the beginning of some syntactic construct.
00:56:36 <Nereid> I don't like that.
00:56:55 <jeltsch> e.g:
00:56:56 <jeltsch>     x = case y of
00:57:01 <bss03> jeltsch: I understand that, I've still been using tabs without any issues in all my Haskell code.
00:57:04 <jeltsch>             [] -> aie
00:57:10 <bss03> jeltsch: Admittedly, that's not too long though.
00:57:25 <jeltsch> Not too long?
00:57:28 <ski>   length [    ] = 0
00:57:29 <ski>   length (_:as) = 1 + as
00:57:31 <tab> jeltsch: you can always align things together with spaces, as long as they are on the space indent level
00:57:35 <ski> (&c.)
00:57:49 <bss03> jeltsch: I've only been writing Haskell for about a year (maybe 18 months).
00:57:49 <opqdonut> yeah, I line up my =s as well
00:58:13 <jeltsch> tab: So you use tabs for indenting wrt. the beginning of the last line and spaces otherwise?
00:58:24 <bss03> Still, I verify through use of col that my code looks sane with 2, 4, and 8 column width tabstops.
00:58:35 <bss03> Actually, I've only ahd to do that a couple of times.
00:58:46 <tab> jeltsch: if needed yes, i usually do my construct to have a newline when needed though
00:58:50 <bss03> I have an internal ruleset that guarantees that, and I always follow it.
00:59:29 * ski idly wonders whether vertical tabs would be useful ..
00:59:49 <bss03> Ugh, the dreaded vertical tab.
01:00:10 <ski> well, form feeds are useful, in any case (imho)
01:00:19 <bss03> I can only see it being possibly useful if you were going to print your code without running through some other formatter.
01:00:22 * tab thinks that this debate would be irrelevant if we had really clever editors
01:01:15 <bss03> <VTAB> before (the type annotation above) top-level declarations?, maybe.
01:01:22 <shikanai> @pl middle x y z = x + y + z - maxThree x y z - minThree x y z
01:01:23 <lambdabot> middle = ap (ap . (liftM2 (-) .) . ap (ap . ((ap . ((-) .) . (+)) .) . (+)) maxThree) minThree
01:01:25 <tab> ski: how do you use form feeds ?
01:01:35 <tab> ski: i mean, what for
01:01:41 <bss03> <FF> after larger, "sections" of code?
01:01:46 * hackagebot feldspar-language 0.3.2 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.3.2 (EmilAxelsson)
01:02:00 <bss03> Like, as a "page break"?
01:02:46 * hackagebot feldspar-compiler 0.3.2 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.3.2 (EmilAxelsson)
01:04:35 <ski> tab,bss03 : yes. i use `C-x [' and `C-x ]' in Emacs to navigate backward and forward pages
01:07:48 <tab> ski: i see.
01:13:54 <Nereid> eww, emacs
01:13:55 <Nereid> ;)
01:14:59 <bss03> I'm a vim user myself, and I think it's important to be able to navigate vi, since it is the only editor that is part of the SUS.
01:15:12 <kulin> viper-mode
01:15:19 <medfly> SUS?
01:15:54 <bss03> SUS = Single UNIX Specification -- the successor to POSIX, maintained by the owners of the UNIX trademark.
01:17:06 <mornfall> Successor?
01:17:13 <kulin> i hate emacs, but i have nothing else which i can get to 80% of what I want like I can with emacs
01:17:52 <bss03> mornfall: It builds on the last published version of the POSIX standard.
01:18:19 <mornfall> Sounds more like a copy than successor to me. :)
01:18:27 <bss03> mornfall: IIRC, the IEEE activity around the POSIX standard has been permanently put on hold.
01:18:32 <ski> a fork
01:19:12 <orbital_fox_> bss03, what builds on the last POSIX standard?
01:19:16 <bss03> mornfall: POSIX -> X/OPEN -> SUS was the progression.
01:20:03 <bss03> orbital_fox_: SUS = Single UNIX Specification.  It's now in version 3, last I checked.
01:20:15 <orbital_fox_> who is following it/
01:20:52 <orbital_fox_> ?
01:20:57 <bss03> orbital_fox_: HP-UX, AIX, NCR, and even Apple have products they've submitted to be compliance tested and that passed the teats to become UNIX branded.
01:21:22 <mornfall> After 1997, the Austin Group developed the POSIX revisions. The specifications are known under the name Single UNIX Specification, before they become a POSIX standard when formally approved by the ISO.
01:21:28 <orbital_fox_> is it backward compatible?
01:22:24 <bss03> For the most part, yes.
01:22:48 <bss03> Each function / command has a section that lists changes, if any, from older specifications.
01:23:16 <orbital_fox_> has linux and bsds gone for it/
01:23:25 <bss03> http://www.opengroup.org/openbrand/register/ -- UNIX 03 includes being compliant to SUSv3, and a few other things, IIRC.
01:24:51 <bss03> Max OS X uses a FreeBSD-like kernel, IIRC.
01:26:04 <orbital_fox_> it does bss03  its called Darwin
01:26:11 <bss03> No Linux vendor has certified a product as UNIX 03, IIRC.  There is a fee, I think.
01:26:38 <bss03> Plus, if you read the LSB you'll find a few cases where they distinctly chose to NOT follow POSIX, so LSB-compliant products might be very difficult to be certified UNIX products as well.
01:27:07 <bss03> However, for the most part, Linux can be treated as a SUSv2 system.
01:27:37 <bss03> Just like, for the most part, gcc can be treated as a C99 complier.
01:28:05 <bss03> (It was missing a few critical defines the last time I was writing C code that cared.)
01:30:18 <kmc> kulin, you could write your own editor from scratch
01:40:26 <bss03> It's nearly 4am here; I need to sleep and then be awake at 10am.  However, I am not tired.
01:40:40 <bss03> #haskell, got anything to bore (or otherwise put) me to sleep?
01:41:50 <kmc> www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf
01:41:56 <bss03> :t primes
01:41:57 <lambdabot> Not in scope: `primes'
01:44:01 <bss03> :t or
01:44:02 <lambdabot> [Bool] -> Bool
01:44:06 <bss03> :t any
01:44:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:47:19 <bss03> @let primes = 2 : filter (\x -> not . any (\y -> x `mod` y = 0) $ takeWhile (\y -> y * y <= x)) primes) [3..]
01:47:20 <lambdabot>   Parse error: Equals
01:48:15 <JoeyA> kmc: That's the strangest Haskell I've seen in a while.
01:48:46 <bss03> @let primes = 2 : filter (\x -> not . any (\y -> x `mod` y = 0) $ takeWhile (\y -> not y * y > x)) primes) [3..]
01:48:46 <lambdabot>   Parse error: Equals
01:48:57 <ski> s/= 0/== 0/ ?
01:49:16 <bss03> kmc: Oh, the C++ standard. Ugh.
01:49:45 <bss03> kmc: I have the C standard sitting on my desk right now, and I've read most of it (not tonight).
01:49:53 <kmc> yeah well
01:49:58 <kmc> C is a reasonable language
01:50:06 <bss03> kmc: But, I've tried making my way through the C++ standard, and it's... Ugh.
01:50:13 <bss03> kmc: UGH! I Say!
01:51:33 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29814#a29814 <- any ideas on why im getting this error? it pretty much mirrors the function enumPair in ITeratee.Base so im not sure whats wrong
01:56:06 * hackagebot game-probability 1.1 - Simple probability library for dice rolls, card games and similar  http://hackage.haskell.org/package/game-probability-1.1 (NeilBrown)
02:16:11 * hackagebot local-search 0.0.2 - A first attempt at generalised local search within Haskell, for applications in combinatorial optimisation.  http://hackage.haskell.org/package/local-search-0.0.2 (RichardSenington)
02:28:22 <bss03> kmc: Crap, kmc, I think I might really understand placement-new syntax and at least one good usage for it.
02:28:44 <bss03> kmc: The C++ standard is not putting me to sleep.  I'm odd that way. :(
02:32:08 <earthy> etpace: how are you applying the is to the str that is the argument to step??
02:33:10 <earthy> etpace: I'd expect mapM (flip I.runIter str) is   to fix your problem
02:33:17 <etpace> yeah, it did
02:33:20 <etpace> but now I have another problem :)
02:33:34 <etpace> Could not deduce (LL.ListLike (I.StreamG [] el) item)
02:36:37 <earthy> hm. yes. 
02:36:48 <etpace> which i've uh figured out
02:36:51 <etpace> nvm :p
02:37:41 <earthy> thought you might. :)
02:54:29 <deteego> there is a C++ standard
02:54:32 <deteego> holy shit batman
03:10:48 <Sh0wn> hi i've to develop a SLR parser for my school. do you know some useful links to read about? thanks in advance
03:13:01 <earthy> sh0wn: http://portal.acm.org/citation.cfm?id=74833 seems applicable
03:13:26 <Kricket> ok earthy
03:30:37 <solrize> hi, i did a cabal install of diff, but ghci doesn't find it, is something broken?  i vaguely remember having to change some setting...
03:31:08 <dsssr> I have some code I want to modify for benchmarking purposes
03:31:38 <dsssr> (matResult, t)  <- time
03:31:39 <dsssr>     $  let matResult =  solver mat1 mat2
03:31:39 <dsssr>        in matResult `deepSeqArray` return matResult
03:31:45 <siracusa> solrize: What does `ghc-pkg list diff' give you?
03:31:45 <lambdabot> siracusa: You have 1 new message. '/msg lambdabot @messages' to read it.
03:32:07 <solrize> /usr/local/lib/ghc-6.12.3/package.conf.d:
03:32:15 <solrize> oh hmm
03:32:21 <dsssr> I changed the last line to do replicateM_ 10 $ matResult `deepSeqArray` return matResult
03:32:46 <solrize> cabal install put it in a 6.10.4 directory but i upgraded compiler to 6.12.3 so there is version skew
03:32:51 <solrize> how do i tell cabal ?
03:32:54 <dsssr> I wanted to get the matrix multiplication to happen 10 times for benchmarking
03:33:06 <dsssr> But the naive way I wrote it gives a type error
03:33:22 <dsssr> Can anybody suggest how I could proceed?
03:34:46 <dsssr> Sorry. I changed the last line starting in to "in do replicateM_ 10 $ matResult `deepSeqArray` return matResult"
03:35:08 <siracusa> solrize: You have to tell cabel-install not to use the --user option, there's an option in the cabal configuration file.
03:35:24 <dsssr> So I essentially added "do replicateM_ 10 $" in an attempt to get the computation following it to happen 10 times
03:36:26 <solrize> -- user-install: True
03:36:28 <solrize> changing to False
03:36:44 <solrize> same output
03:36:56 <solrize> oh wait re-installing
03:37:32 <solrize> much better, thanks!
03:44:08 <siracusa> solrize: Sorry, got disconnected. Problem solved?
03:45:54 * hackagebot msgpack-rpc 0.3.1.2 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.3.1.2 (HideyukiTanaka)
03:48:57 <solrize> siracusa, yes, works now, thanks!  wonder why cabal was configured that way
03:49:02 <mercury^> When trying to `cabal install gconf', I get "setup: The pkg-config package gconf-2.0 version >=2.0.0 is required but it
03:49:05 <mercury^> could not be found.
03:50:15 <tab> mercury^: you need to install the C library gconf-2.0
03:50:23 <mercury^> That is installed.
03:50:29 <tab> mercury^: the dev part ?
03:50:56 <tab> mercury^: you can run pkg-config --libs gconf-2.0
03:51:40 <mercury^> Ah alright, that must be it.
03:51:41 <mercury^> Thanks.
03:52:04 <tab> mercury^: no problems.
04:04:09 <arnihermann> I'm prototyping a parser in parsec, and I'm having trouble with permute (see source http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29816#a29816)
04:04:36 <arnihermann> when I run the parser, I get unexpected reserved word "knownrebecs", expecting "msgsrv"
04:05:15 <arnihermann> I must be doing something wrong, or permute isn't doing what it's supposed to be doing
04:05:18 <arnihermann> any thoughts?
04:07:24 <arnihermann> oh nm, found error
04:31:09 <arw> offtopic question, but googling the answer is somewhat hard.
04:31:20 <arw> is there a 'zip' function in perl?
04:31:52 <arw> ah, nevermind
04:31:59 <arw> found Language::Functional
04:44:42 <medfly> oO
04:45:26 <Botje> arw: there's also mesh in List::MoreUtils
04:45:45 <Botje> it's a generalized zip, iirc
04:51:21 <arw> Botje: hm, List::MoreUtils is even nicer, because its already installed for some reason :)
04:51:27 <arw> Botje: thx alot.
04:54:52 <mietek> BelHac! Woop
04:58:55 <Botje> i might even make it!
04:59:00 <Botje> unless i have to teach
05:19:30 * hackagebot ip6addr 0.2 - Command-line tools to filter parsed IPv6 Addresses against RFC 4291 and generate random IPv6 adresses  http://hackage.haskell.org/package/ip6addr-0.2 (MichelBoucey)
05:23:31 * hackagebot hashed-storage 0.5.3 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.3 (PetrRockai)
05:34:35 * hackagebot darcs-fastconvert 0.1 - Import/export git fast-import streams to/from darcs.  http://hackage.haskell.org/package/darcs-fastconvert-0.1 (PetrRockai)
05:44:19 <HugoDaniel> depressing
05:44:41 <HugoDaniel> whats the state on XsdToHaskell ?
05:48:58 <kingping> Hello!
05:51:20 <kingping> Why calling rec' x = rec $ x + 1 causes GHC to run out of memory? My first guess: GC doesn't have enough time to free memory used by function to allocate it to the subsequent thunks.
05:51:56 <kingping> Sorry, rec' x = rec' $ x * 1, called like rec' 1
05:54:16 <blackh> kingping: The GC can't free the memory because it gets stuck in a loop creating thunks, and it never exits that loop.
05:55:37 <kingping> blackh: I suppose it's due to a nature of Haskell being lazy, in contrast AFAIR Erlang being eager language would never run of memory.
05:56:03 <kingping> *run out
05:57:16 <blackh> kingping: Yes, I think that would be right.  If you want the same behaviour, you can force the argument to be strict.
05:58:22 <kingping> Hmmm, strict. A _strict_ is one, that doesn't cause thunk allocation and is evaluated when we stumble upon it?
05:58:57 <blackh> How much do you know about how to make things strict in Haskell?
05:59:21 <kingping> Nuthin, I'm a stupid, off to read something.
05:59:32 <kingping> Thanks for pointing me to it.
05:59:41 <blackh> I'm happy to tell you - I just don't want to tell you anything you already know. :)
06:00:04 <blackh> in your example, you would say  rec' x = x `seq` rec' (x + 1)
06:00:14 <kingping> Hehe, I see, I get everything to start with :]
06:00:35 <blackh> ...However, your function doesn't do anything useful at all!
06:00:40 <dmwit> rec' x = rec' $! x * 1 -- also works
06:01:26 <blackh> A third way is rec' !x = rec' $ x * 1   which requires you to put {-# LANGUAGE BangPatterns #-} at the top of your source file
06:01:52 <blackh> The second two are syntactic sugar for the first.
06:02:00 <dmwit> kingping: Anyway, the gist of it is that, when calling rec', the value (x * 1) isn't yet evaluated, because Haskell is lazy.
06:02:17 <blackh> (The first is a function, the second is syntactic sugar. :) )
06:02:18 <dmwit> Each recursive call adds a layer of thunk for an additional (*1) multiplication.
06:02:27 <dmwit> You can evaluate those thunks (i.e. force them) in various ways.
06:02:31 <kingping> Uhm I suspect rec' x = seq (rec' (x * 1)) and rec' x = rec' $! x * 1 are pretty the same, the last one using the application operator combined with call to seq (the !).
06:02:39 <kingping> oh
06:03:05 <blackh> They are exactly equivalent (except that your first one isn't quite right)
06:03:33 <blackh> Actually I tell a lie - those two are not exactly equivalent, because the seq happens in a different place...
06:03:36 <blackh> but the effect is about the same.
06:04:34 <kingping> :]
06:16:04 <Olathe> @hoogle ($<)
06:16:05 <lambdabot> No results found
06:30:53 * hackagebot clash 0.1.1.0 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.1.0 (ChristiaanBaaij)
06:36:44 <Xaphiosis> I have a little question about using the list monad. Currently I have do { r1 <- [1..4] ; r2 <- [1..4] ; return $ sum [r1,r2] }
06:37:13 <Xaphiosis> I'd like to remove the repetitiveness of the multiple rN <- blah, but I'm stuck
06:38:19 <blackh> How do you mean? Incidentally, you can write 'return $ r1 + r2' instead.
06:38:40 <Xaphiosis> well yeah, but this is abbreviated code for the question
06:38:49 <blackh> Oh... you want to write lots of rN ...
06:38:58 <Xaphiosis> the real problem has nine throws of a d4
06:39:19 <blackh> Well, you can use 'sequence' for that.
06:39:38 <blackh> Or better still, replicateM
06:39:40 <Xaphiosis> it's project euler problem 205. I've solved it, but I've got these ugly repetitions I want to clean up in the future
06:39:49 <Xaphiosis> ooh, I'll take a look
06:40:17 <blackh> replicateM 9 [1..4]
06:41:12 <blackh> Actually, you'll want to say do { rs <- replicateM 9 [1..4] ; return $ sum rs }
06:41:26 <kaol> > fmap sum $ replicateM 9 [1..4]
06:41:27 <lambdabot>   [9,10,11,12,10,11,12,13,11,12,13,14,12,13,14,15,10,11,12,13,11,12,13,14,12,...
06:42:04 <Xaphiosis> hmm, I had do { x <- replicate 9 d4 ; return $ sum x } but that gave the wrong result
06:42:22 <Xaphiosis> so it's replicateM ... who would've thought
06:42:28 <Xaphiosis> thanks guys
06:43:00 <Xaphiosis> I was even trying replicate 9 d4 >>= fmap sum, but that didn't type check
06:43:22 <Xaphiosis> long way to go with this haskell thing :)
06:43:28 <kaol> replicateM 9 d4 >>= return . sum
06:45:13 <blackh> Xaphiosis: You can do useful stuff in Haskell fairly quickly, but I've never heard of anyone actually mastering the language. :)
06:45:37 <Xaphiosis> dons maybe?
06:46:53 <Xaphiosis> and that guy who did an epic disarmanent on reddit by using category theory to write a version of the "du" command (he actually had a function called "zygo")
06:47:13 <kaol> > zipWith (\i -> length . filter (==i)) [9..36] $ repeat $ fmap sum $ replicateM 9 [1..4]
06:47:17 <lambdabot>   mueval-core: Time limit exceeded
06:47:29 <kaol> > zipWith (\i -> length . filter (==i)) [9..36] $ repeat $ fmap sum $ replicateM 5 [1..4]
06:47:30 <lambdabot>   [65,101,135,155,155,135,101,65,35,15,5,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
06:49:54 <frerich> zygo... sweet.
06:49:58 * hackagebot libmpd 0.5.0 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.5.0 (JoachimFasting)
06:50:27 <Xaphiosis> while I'm here, is there anything like map for Data.Array? I was too stupid to figure out that either
06:52:28 <blackh> amap
06:53:22 <Xaphiosis> right. I didn't think that Data.Array and Data.Array.IArray were the same thing
06:53:59 <blackh> Well, I usually do: import Data.Array (Array) ; import Data.Array.IArray
06:54:18 <Xaphiosis> I thought the former was the API and the latter was an "internal" implementation
06:54:30 <blackh> So apart from the type, everything else comes from IArray
06:54:44 <Xaphiosis> nice. thank you
06:54:52 <blackh> No, "I" is (probably) interface
06:55:01 <quicksilver> I is immutable
06:55:07 <Xaphiosis> I thought it was immutable
06:55:30 <quicksilver> but the IArray class is an abstraction with some useful functions on it
06:55:37 <quicksilver> whereas the Array type is a specific type
06:55:40 <quicksilver> (Which implements IArray)
06:55:51 <Xaphiosis> ah.
06:56:17 <Xaphiosis> so IArray works on other instances of Array too, or vice versa?
06:58:03 <blackh> You can do everything with IArray.  So if I'm using boxed and unboxed in the same module, I can import Data.Array (Array) ; import Data.Array.Unboxed (UArray); import Data.Array.IArray ... and I get away with unqualified names, mostly.
06:58:09 <quicksilver> IArray works for other types which are instances of IArray.
06:58:22 <quicksilver> nothing is an instance of Array
06:58:29 <quicksilver> Array is a type, IArray is a class
06:58:35 <quicksilver> so Array is an instance of IArray
06:58:37 <Xaphiosis> understood
06:59:33 <Xaphiosis> um. since you guys are being so helpful, can I ask something else?
06:59:48 <tab> Xaphiosis: there's no quota here :)
07:00:14 <ray> @faq has he used up his question allowance?
07:00:14 <lambdabot> The answer is: Yes! Haskell can do that.
07:00:16 <blackh> Xaphiosis: This is a quiet period.  Usually you get at least four answers for any question.
07:00:16 <Xaphiosis> well, there is a "you're being a noob why not go try think for yourself" quota everywhere
07:00:58 <deteego> Xaphiosis: haskell community is very nice, they are probably the least elitist out there
07:01:02 <ray> well you don't understand something until you can explain it to others
07:01:05 <blackh> Xaphiosis: Haskellers love talking about Haskell so much, so that doesn't happen very often.
07:01:12 <ray> so when someone understands something
07:01:27 <ray> they rush to #haskell to explain it at every opportunity
07:01:30 <deteego> oh yeah, and we think Haskell is so good and such an epic language
07:01:34 <Xaphiosis> hence the abundance of monad tutorials I guess
07:01:34 <deteego> that we love talking aboiut it
07:01:41 <ray> yes
07:01:42 <deteego> *about
07:01:55 <ray> reading monad tutorials is useless
07:02:01 <ray> but writing one might help
07:02:10 <Xaphiosis> ok then, this one is regarding a space leak
07:02:16 <deteego> I would argue, that you need the right monad tutorial for the right person
07:02:19 <Xaphiosis> in ghci I do the following
07:02:31 <Xaphiosis> let blah = [(10^9)..(10^9 + 5*(10^8))]
07:02:42 <Xaphiosis> and then: length blah
07:02:55 <Xaphiosis> result is my system running out of memory and going into swap
07:03:28 <Xaphiosis> which I don't expect, as it should just count the elements as it goes along and not leak, right?
07:03:28 <quicksilver> yes, you're forcing a very large list to exist in memory
07:03:48 <quicksilver> it can't throw away the early elements because you have kept 'blah' alive
07:03:51 <quicksilver> by naming it to the repl
07:04:00 <quicksilver> you could refer to 'blah' again in the next line if you chose to 
07:04:12 <Xaphiosis> d'oh *smacks forehead*
07:04:30 <quicksilver> if you don't name it - just type length [(10^9)..(10^9 + 5*(10^8))]
07:04:39 <quicksilver> then it should run in constant space, but take a while.
07:05:13 <deteego>  quicksilver | by naming it to the repl <- what is repl?
07:05:25 <Xaphiosis> read-evaluate-print loop
07:05:36 <quicksilver> deteego: ghci in this case
07:05:37 <Xaphiosis> what ghci provides, for example
07:05:58 <deteego> oh thats a new term I havent heard before
07:06:35 <deteego> well thats cool I learnt something new, even though I never asked anything
07:06:39 <ray> let...in should also work
07:06:43 <Olathe> Is there anything like Parsec that's always installed with GHC?
07:06:56 <ray> let blah=... in length blah
07:07:20 <benmachine> Olathe: I have a vague idea that ReadP is a bit similar
07:07:23 <Xaphiosis> thanks to you gentlemen, my solution to euler 205 is 27 lines long with spacing and comments and runs in about 4 seconds
07:07:34 <Olathe> benmachine: Ahh, OK. Thanks.
07:07:37 <Xaphiosis> so I consider it finished :)
07:07:48 <benmachine> Olathe: it's slower and clumsier and less general and etc. though :P
07:07:51 <ray> now you just have to golf it to 1 line
07:07:51 <deteego> Xaphiosis: glad we could help =D
07:08:04 <deteego> Xaphiosis: if you added parrelilsm to it, it would be even faster
07:08:11 <Xaphiosis> hahaha
07:08:29 <ray> do you want to be SO PARALLEL
07:08:31 <deteego> nested data parrelelism should work quite nicely with Euler, with minimal effort
07:08:43 <deteego> ray: its the way of Haskells future, DONT DENY IT
07:09:44 <deteego> Xaphiosis: no but seriously, implementing parralel strategies in Haskell is much more trivial then in other languages, it doesn't break abstraction/modularism
07:11:05 <Xaphiosis> I guess, but one step at a time
07:11:16 <co_dh> what's the meaning of covariant and contravariant in programming language theory ? or type theory? 
07:11:19 <Xaphiosis> I'm still puzzled by much simpler things
07:12:33 <Xaphiosis> like how to do basic string formatting better than "(" ++ show a ++ ", " ++ show b ++ ")"
07:12:57 <deteego> well strings are lists
07:12:59 <deteego> thats the first hint
07:13:03 <Olathe> benmachine: Ahh, OK. I think I'll use Parsec then.
07:13:33 <deteego> like you can do map on strings, or use string constructors (x:xs) or head and tail or use index (!!) etc etc
07:13:42 <deteego> strign is just a list of characters
07:13:45 <deteego> *string
07:13:52 <zygoloid> co_dh: covariant means 'varying the same' and contravariant means 'varying in opposite ways'
07:14:10 <deteego> Xaphiosis: have a look at prelude and Data.List for various functions that work with lists
07:14:30 <Xaphiosis> well yes, but coming from python's "(%d,%d)" % (a,b)   going to List.concat ["(", show a, ",", show b, ")"] doesn't seem much help
07:14:34 <zygoloid> co_dh: usually there's a canonical order which is being referred to. for types it's the subtype relation.
07:14:39 <benmachine> Olathe: parsec is very good at its job :)
07:14:47 <co_dh> zygoloid: thanks
07:14:50 <deteego> Xaphiosis: in haskell for example, the string "hello" is just syntactic sugare for ['h','e','l','l','o']
07:14:55 <Axman6> it ixzkn why not use printf?
07:15:06 <Axman6> wtf?
07:15:08 <Axman6> hmm
07:15:11 <Silvah> :t printf
07:15:11 <lambdabot> forall r. (PrintfType r) => String -> r
07:15:15 <Axman6> Xaphiosis: why not use printf*
07:15:18 <co_dh> zygoloid : so covariant is subtype relation?
07:15:26 <Xaphiosis> printf is built in?
07:15:29 <Axman6> > printf "(%d,%d)" 4 6
07:15:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:15:31 <lambdabot>    `Text.Printf.PrintfType ...
07:15:37 <Axman6> > printf "(%d,%d)" 4 6 :: String
07:15:38 <lambdabot>   "(4,6)"
07:15:52 <benmachine> Text.Printf
07:16:00 <Xaphiosis> oh, awesome
07:16:07 <benmachine> this is haskell, we don't have anything builtin if we can help it
07:16:32 <Xaphiosis> well, hoogle found it in base
07:16:50 <zygoloid> co_dh: covariant is varying the same way. so given: head :: [a] -> a, the argument and result are covariant in that, if you pick a more specific argument type you get a more specific result type and vice versa.
07:16:53 <mornfall> base is not the same as builtin :)
07:16:53 <Xaphiosis> so I'll definitely incorporate it into future hacking
07:17:51 <Xaphiosis> sorry, I meant built-in as in "comes with ghc", which doesn't really mean built-in
07:18:24 <co_dh> zygoloid: wikipedia says : covariant : converting from narrower ( float) to wider (double)
07:18:27 <Xaphiosis> also, speaking of parsec, do any of you know why it isn't an instance of applicative?
07:18:46 <Silvah> It is.
07:18:55 <Silvah> Well, version 3 is, AFAIR.
07:18:58 <Xaphiosis> in which version?
07:19:03 <Xaphiosis> oh
07:19:28 <Xaphiosis> I think I'm just using the default one, which would be parsec 2 I guess
07:19:42 <Xaphiosis> is it worth switching?
07:19:51 <deteego> probably
07:19:55 <deteego> anyways im off to bed
07:19:57 <deteego> gnight
07:20:01 <Xaphiosis> night
07:20:03 <Silvah> anyway*
07:20:11 <Silvah> gnight
07:21:04 <zygoloid> co_dh: that's a pretty terrible example. good old wikipedia
07:21:19 <benmachine> parsec3 is claimed to be as highly performing as parsec2 now, and has a lot of usability advantages
07:21:48 <Silvah> Highly performing...?
07:21:55 <Silvah> In what sense?
07:22:17 <Xaphiosis> cool, if it comes with something like a parsec2read function (the other thing I really miss in parsec), I'm sold
07:22:27 <mornfall> In the sense that's it only a factor 10 or so slower than attoparsec *hides*. ; - )
07:22:36 <benmachine> Xaphiosis: err, what would that do
07:22:48 <benmachine> mornfall: that's cheating, they do different things :P
07:22:52 <Silvah> Ah, as highly performing as version 2 was, i.e. unbearably slow.
07:23:09 <Xaphiosis> it would take a parser and give you a function you can use for a Read instance
07:23:10 <mornfall> benmachine: Only slightly.
07:23:24 <Xaphiosis> I have a version lying around somewhere
07:23:49 <Xaphiosis> parsec2read f x  = either (error . show) id (parse f' "" x)
07:23:50 <Xaphiosis>   where f' = do { a <- f; res <- getInput; return [(a,res)] }
07:24:38 <Xaphiosis> example usage is:
07:24:39 <benmachine> Xaphiosis: parsec2reads would be better!
07:24:43 <Xaphiosis> instance Read Note where
07:24:43 <Xaphiosis>     readsPrec _ = parsec2read noteParser
07:25:00 <Xaphiosis> well, I'm no expert, so I'm all ears
07:25:11 <benmachine> wait that gives you
07:25:24 <Xaphiosis> are you recommending I use a different (existing) function, or are you suggesting I rename mine?
07:25:36 <benmachine> I'm confused
07:25:47 <benmachine> oh
07:26:01 <benmachine> no I thought you were producing a read implementation instead of reads
07:26:03 <benmachine> but
07:26:23 <benmachine> I think a. you shouldn't ignore the precedence argument and b. you shouldn't error on error
07:26:27 <benmachine> that's the *point* of reads
07:26:33 <benmachine> it's supposed to be safe
07:26:47 <benmachine> so that'd be either [] id
07:27:04 <Silvah> "you shouldn't error on error" - this sounds funny.
07:29:37 <Xaphiosis> *Play> read "G-5" :: Note
07:29:38 <Xaphiosis> G-5
07:30:05 <Xaphiosis> *Play> read "moo" :: Note
07:30:05 <Xaphiosis> *** Exception: (line 1, column 1):
07:30:05 <Xaphiosis> unexpected "m"
07:30:09 <Xaphiosis> so this is bad
07:30:14 <Xaphiosis> but
07:30:27 <Olathe> Does attoparsec come with the latest GHC?
07:30:30 <Xaphiosis> *Play> read "moo" :: Integer
07:30:31 <Xaphiosis> *** Exception: Prelude.read: no parse
07:30:35 <Silvah> No.
07:30:56 <Xaphiosis> benmachine: so I don't follow exactly which safety you mean
07:31:01 <Olathe> Ahh.
07:31:12 <Xaphiosis> and I have zero idea what to do with the precedence argument
07:31:30 <Silvah> Hardly anything comes with the latest GHC.
07:32:28 <syntaxfree> fix is no longer in the prelude?
07:32:54 <syntaxfree> (in GHC 6.10.4 anyway. Dunno about Haskell 98 or Haskell Prime)
07:33:18 * hackagebot halipeto 2.3 - Haskell Static Web Page Generator  http://hackage.haskell.org/package/halipeto-2.3 (PeterSimons)
07:33:54 <benmachine> Xaphiosis: the idea is
07:34:02 <benmachine> syntaxfree: was it ever?
07:34:03 <benmachine> Xaphiosis: 
07:34:18 <benmachine> > reads "moo" :: [(Integer, String)]
07:34:19 <lambdabot>   []
07:34:22 <benmachine> ^ no crash woo
07:34:36 <benmachine> > reads "14banana" :: [(Integer, String)]
07:34:37 <lambdabot>   [(14,"banana")]
07:34:45 <syntaxfree> benmachine I remember playing with fix straight out of ghci, no importing of packages. but maybe it was lambdabot.
07:34:48 <benmachine> 'reads' is not supposed to call 'error'
07:34:57 <syntaxfree> @hoogle fix
07:34:57 <lambdabot> Data.Function fix :: (a -> a) -> a
07:34:57 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
07:34:57 <lambdabot> module Control.Monad.Fix
07:35:00 <Xaphiosis> ahh
07:35:30 <benmachine> Xaphiosis: the precedence argument is to do with context
07:35:35 <benmachine> for example, how do you parse
07:35:43 <benmachine> Just 4 :+ 3
07:35:49 <benmachine> hmm
07:36:01 <benmachine> that's not a great example because it's a parse error <_<
07:36:13 <ray> > reads "Truemagic" :: [(Bool,String)]
07:36:14 <lambdabot>   []
07:36:32 <benmachine> interesting
07:36:39 <benmachine> I suppose it's tokenised first
07:36:49 <ray> NOT ENOUGH MAGIC
07:36:54 <Xaphiosis> mind -> blown
07:37:07 <zygoloid> > reads "True magic" :: [(Bool, String)]
07:37:07 <lambdabot>   [(True," magic")]
07:37:12 <benmachine> actually that is kind of a good example
07:37:18 <benmachine> suppose you have "Just 4 :+ 3"
07:37:30 <benmachine> and then the parser says, read the Just and then read its contents
07:37:45 <benmachine> so you read Just and then you have "4 :+ 3" left in the input stream
07:38:09 <benmachine> but parsing it as Just (4 :+ 3) would be incorrect
07:38:15 <benmachine> because it's (Just 4) :+ 3
07:38:27 <benmachine> so the precedence argument tells you how to make that distinction
07:38:43 <benmachine> I'm not being very clear
07:38:47 <ray> ohnoes classic parser ambiguity
07:38:52 <Xaphiosis> sadly, I have to agree
07:39:11 <benmachine> maybe it's best to derive a Read instance and use -ddump-deriv with it
07:39:18 <Xaphiosis> I understand the idea of precendence-based parsing as appears, say, in SML or the Isabelle theorem prover
07:39:23 <benmachine> and see how the automatic derivation uses precedence
07:39:29 <ray> i don't know what the precedence argument actually *does*
07:39:32 <Xaphiosis> but I don't know what Haskell wants of me
07:39:40 <benmachine> basically I think it's a case of
07:40:04 <benmachine> if you have an infix application to parse, and the precedence argument is higher than the precedence of that application, you should demand brackets around it
07:40:27 <Xaphiosis> and I'm now left with the uncomfortable situation of knowing that my parsec2read function sucks, but I don't have a good idea for a decent replacement
07:40:41 <Xaphiosis> surely I can't be the first person who's tried to do this?
07:40:43 <syntaxfree> math-y question: when does iterating a function lead to a fixed point?
07:40:47 <ray> :t readsPrec
07:40:48 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
07:40:53 <benmachine> Xaphiosis: most people just derive Read
07:41:03 <benmachine> syntaxfree: a fixed point is the solution of x = f x
07:41:04 <syntaxfree> repeated applications of "cos" solve cos(x)=x, but not x^2-4=x
07:41:11 <ray> what relationship does the Int there have with the precedences of operators
07:41:15 <Xaphiosis> well, you can't really derive Read for a chord type
07:41:17 <ray> and with the result
07:41:23 <syntaxfree> @take 20 $ iterate cos 1
07:41:23 <lambdabot> Maybe you meant: time type
07:41:23 <Xaphiosis> or a musical note
07:41:28 <benmachine> syntaxfree: so if fix f = let x = f x in x produces a result, it must be a fixed point
07:41:37 <syntaxfree> :take 20 $ iterate cos 1
07:41:50 <syntaxfree> > take 20 $ iterate cos 1
07:41:51 <lambdabot>   [1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.79348035874...
07:42:02 <benmachine> oh that
07:42:06 <syntaxfree> see? it's getting there.
07:42:07 <benmachine> draw a picture for that
07:42:28 <ray> well
07:42:40 <syntaxfree> > take 20 $ iterate (\x->x^2-4) 1
07:42:41 <lambdabot>   [1,-3,5,21,437,190965,36467631221,1329888126870853950837,176860242999206853...
07:42:41 <ray> you don't want to use Read as a generic parser
07:42:42 <benmachine> draw cos x and the graph y = x
07:42:50 <benmachine> repeated iteration is like
07:42:58 <benmachine> starting on the x axis at some value
07:43:03 <benmachine> going up to meet the graph
07:43:09 <benmachine> and then going across the meet y = x
07:43:09 <syntaxfree> yes,  yes. http://www.wolframalpha.com/input/?i=cos(x)%3Dx
07:43:10 <ray> it is not a very good generic parser!
07:43:32 <benmachine> and then going back to meet the graph again
07:43:43 <zygoloid> co_dh: (sorry for the delay, got called away). an example of contravariance in haskell: the types (a -> b) and a are contravariant. if you pick a smaller a, say [a], you get a larger type ([a] -> b) (there are fewer expressions of type [a] than of type a, but more expressions of type [a] -> b than of type a -> b)
07:43:52 <syntaxfree> I'm interested in this because one of the desiderata in Cox's theorem is that a certain f(x)=f(f(x))
07:44:25 <benmachine> syntaxfree: is that for a particular x or for all x?
07:44:28 <syntaxfree> and I don't know jack about functional equations. I just came across the fixed point of cos in some weird blog using Mathematica.
07:44:36 <benmachine> in the latter case that's idempotence, not fixed points
07:44:44 <Xaphiosis> ray: agreed, but I found one guy using parsec for defining read, and that's where my parsec2read function came from
07:44:48 <syntaxfree> benmachine: in Cox's theorem it's for all x, but I'm starting slow.
07:44:53 <benmachine> Xaphiosis: he was doin it rong
07:44:56 <syntaxfree> benmachine: OH. You're right.
07:45:13 <Xaphiosis> well he's the only guy who I saw actually doing it :/
07:45:20 <syntaxfree> Much like projection matrices.
07:45:26 <benmachine> syntaxfree: right
07:45:37 <benmachine> Xaphiosis: why can't you derive Read for a chord type?
07:45:46 <syntaxfree> anyway, when is iteration an algorithm for f(x)=x?
07:45:57 <Xaphiosis> something simpler, here's an interval
07:46:06 <nlogax> is there a nice function that does filter (not . (`elem` list1)) list2 ?
07:46:18 * zygoloid sells ice-cream during the interval
07:46:21 <Xaphiosis> *Play> read "dim 5th" :: Interval.Interval
07:46:22 <Xaphiosis> dim 5th
07:46:34 <benmachine> nlogax: umm, (\\) doesn't do exactly that but it's close I think
07:46:35 <Xaphiosis> *Play> read "diminished 5th" :: Interval.Interval
07:46:35 <Xaphiosis> dim 5th
07:46:35 <Gilly> nlogax: list2 \\ list1 ?
07:46:42 <Xaphiosis> also
07:46:50 <benmachine> Xaphiosis: why must you use Read for this?
07:47:05 <nlogax> ahh, that one, i always forget it! thanks benmachine and Gilly 
07:47:07 <benmachine> Xaphiosis: just define your own parsing function, and let read be derived
07:47:22 <benmachine> Xaphiosis: same goes for show and prettyprinting, imo
07:47:29 <Xaphiosis> hmm
07:47:29 <Gilly> benmachine: what does (\\) do differently?
07:47:42 <Xaphiosis> but my read (show x) == x
07:47:42 <benmachine> Gilly: I think it handles duplicates differently
07:47:50 <benmachine> Xaphiosis: why is your show like that? :P
07:47:54 <zygoloid> @check \xs ys -> filter (`notElem` ys) xs == xs \\ (ys :: [Int])
07:47:55 <lambdabot>   "Falsifiable, after 25 tests:\n[14,-4,-4,-4,4,13,-14,12,-11]\n[13,-14,-4,-7...
07:48:03 <Gilly> > [1,2,3,3] \\ [2,3]
07:48:04 <benmachine> Xaphiosis: ok I'm asking the wrong questions, never mind
07:48:04 <lambdabot>   [1,3]
07:48:12 <Gilly> ah yea.
07:48:17 <benmachine> you're right that read (show x) == x is good
07:49:03 <benmachine> and you can do it with a parsec parser if you like
07:49:16 <benmachine> it's not really usual but it's fine
07:49:20 <Xaphiosis> well, it's so when I do stuff like this: *Play> noteRelativeChord (read "C" :: PartNote) "vii7"
07:49:20 <Xaphiosis> [B,D,F#,A]
07:49:30 <benmachine> well I say it's not usual, it's not like I've done a survey
07:49:35 <benmachine> yeah I guess that is convenient
07:50:01 <Xaphiosis> *Play> noteRelativeChord (read "C-5" :: Note) "vii7"
07:50:02 <Xaphiosis> [B-5,D-6,F#-6,A-6]
07:50:27 <BrianHV> that's very precise voicing you have there. ;)
07:51:10 <benmachine> syntaxfree: iteration for f(x) = x; it can depend on what your starting value of x is, but I think it also depends on the value of f' near the fixed points
07:51:20 <Xaphiosis> yeah, that's so I can play it via the alsa sequencer
07:51:31 <benmachine> syntaxfree: the best way to understand it is to draw pictures like I said
07:51:32 <BrianHV> aah, good stuff
07:51:56 <syntaxfree> cos(cos(x))=cos(x) leads to the same x as cos(x) = x
07:52:15 <copumpkin> syntaxfree: makes sense
07:52:27 <benmachine> syntaxfree: well if cos(x) = x then of course cos(cos(x)) = cos(x)
07:52:30 <syntaxfree> benmachine: I can visualize f(x) = x. I can't visualize repeated composition for an oddly shaped function.
07:52:40 <Xaphiosis> well, I guess I'm just strange :)
07:53:04 <syntaxfree> benmachine: I can't find a good reason, though.
07:53:13 <benmachine> syntaxfree: for what?
07:53:25 <benmachine> I'm trying to help people and I've forgotten everyone's actual problems
07:53:27 <copumpkin> syntaxfree: you just gave us one :P
07:53:31 <syntaxfree> oh, of course.  u= cos (x)
07:53:34 <benmachine> I am bad at this
07:53:36 <benmachine> syntaxfree: yup
07:53:38 <syntaxfree> then cos(u)=u
07:53:44 <zygoloid> syntaxfree: imagine the line x=y, and a sequence of points x_n = f^n(x), y_n = f(x).
07:54:02 <zygoloid> syntaxfree: then consider the behaviour of that sequence as it crosses the x=y line
07:54:15 <benmachine> zygoloid: y_n = f(x_n), right?
07:54:17 <syntaxfree> so by induction f^n(x)=f^(n-1)(x) has x such that f(x)=x as a root.
07:54:22 <zygoloid> execve: yeah
07:54:27 <Xaphiosis> heh, well, anyway, it seems someone here has an actual problem, so I'll go take my read/show freakshow offline
07:54:31 <zygoloid> whoa, tab completion epic fail
07:54:36 <zygoloid> s/execve/benmachine/
07:54:43 <syntaxfree> I have to run. Getting late.
07:54:49 <benmachine> Xaphiosis: nooo come back
07:55:10 <zygoloid> syntaxfree: thinking about f(x)-x makes things clearer
07:55:30 <Xaphiosis> benmachine: sarcasm? :)
07:55:53 <benmachine> Xaphiosis: nope!
07:55:59 <syntaxfree> why does this fail for x^2-4 = x?
07:56:03 <benmachine> Xaphiosis: I feel guilty for explaining things badly to you :P
07:56:08 <syntaxfree> it clearly has two solutions.
07:56:40 <benmachine> syntaxfree: if you do the drawing it makes sense; basically iteration of a function can either diverge or converge, and I think it depends on the gradient
07:57:00 <benmachine> syntaxfree: if it diverges that's no help; if it converges it must converge to a fixed point
07:57:20 <benmachine> I think it converges if |f'(x)| < 1
07:57:34 <syntaxfree> interestingly, if a probability distribution function has an analytical integral form, then this alone implies E(E(x))=E(x)
07:57:50 <syntaxfree> benmachine: man, I got to learn real analysis for real.
07:57:55 <syntaxfree> brb.
07:57:55 <benmachine> heh
07:58:25 <Xaphiosis> benmachine: no worries
07:58:46 <Xaphiosis> benmachine: I'm just surprised I'm the only person who thinks this way
07:58:59 <benmachine> Xaphiosis: you're probably not the *only* one
07:59:41 <Xaphiosis> deriving read would be a bad idea because:
07:59:50 <Xaphiosis> *Play> Notes.PartNote C 1
07:59:51 <Xaphiosis> C#
07:59:51 <Xaphiosis> *Play> Notes.Note (Notes.PartNote C 1) 5
07:59:51 <Xaphiosis> C#-5
08:00:02 <benmachine> because then you wouldn't have read (show x) == x, right
08:00:05 <Xaphiosis> that's the real structure, which makes no sense at a glance
08:00:15 <zygoloid> Xaphiosis: so you want custom read/show functions so you can get nice interactive behaviour in GHCi?
08:00:32 <Xaphiosis> pretty much, zygoloid
08:00:43 <benmachine> a lot of standard datatypes do that, sort of
08:00:49 <benmachine> so it can't be a terrible idea
08:00:54 <copumpkin> preflex: seen sfvisser_ 
08:00:54 <preflex>  Sorry, I haven't seen sfvisser_
08:00:55 <Xaphiosis> when I write: read "[C-5,E-5,G-5]" :: [Note]  I expect the obvious
08:01:16 <Xaphiosis> do any of these datatypes use parsec?
08:01:23 <zygoloid> Xaphiosis: the convention is that show produces a haskell expression which recreates the value, and read consumes the same format which show produces
08:01:25 <benmachine> I doubt it, they're mostly too simple
08:01:34 <zygoloid> but that expression need not be the derived call to the constructor
08:01:44 <benmachine> zygoloid: that's *a* convention
08:01:47 <zygoloid> i wonder if you can use that to produce a nicer read/show
08:01:54 <benmachine> but the time package ignores it completely
08:01:58 <benmachine> and I think it's not the only one
08:02:11 <benmachine> I think show for Ptr does something silly as well
08:02:28 <Xaphiosis> I think it gives the address
08:03:13 <Xaphiosis> but yeah, call me old-fashioned, but I just have this warm fuzzy feeling when notes look like notes
08:03:26 <zygoloid> fwiw i'm working on a REPL which uses a different prettyprinter if the type is an instance of the relevant class
08:03:37 <zygoloid> and uses Show if not
08:03:43 <Xaphiosis> zygoloid: a blessing upon you and your family
08:04:09 <benmachine> Xaphiosis: ok so I think what you're doing is fine
08:04:14 <Xaphiosis> however, there will still be the issue of shoehorning a parsec parser into your framework
08:04:31 <benmachine> and your parsec thing works, if you make sure that readsPrec returns an empty list instead of calling error
08:04:33 <Xaphiosis> so instead of parsec2read, I'll be wanting parsec2zygoloidclass
08:04:58 <benmachine> you just need to think about the precedence argument, but actually I think it's irrelevant to you
08:05:05 <zygoloid> Xaphiosis: i think that's actually the easier part, since i don't do any implicit 'read'ing; you can call your parse function something else
08:05:06 <benmachine> judging from what you've done so far
08:06:51 <Xaphiosis> fixed it, just for you: *Play> reads "moo" :: [(Note,String)]
08:06:51 <Xaphiosis> []
08:07:02 <benmachine> <3
08:07:30 <benmachine> yeah, it makes things much easier to have a parse function with which you can detect errors
08:08:04 <Xaphiosis> indeed, "*** Exception: Prelude.read: no parse" is wonderfully helpful
08:08:45 <Xaphiosis> I also had another crazy idea a while back, which might interest you, zygoloid
08:09:08 <Xaphiosis> when we write code that carries around state, we put it in the state monad
08:09:17 <Xaphiosis> or state IO monad, or whatever
08:09:25 * zygoloid is unusually keen on crazy ideas
08:09:39 * benmachine is usually keen on them
08:09:51 <Xaphiosis> but then if you want to "enter" that monad in ghci and just run code like you would in the state IO monad, you can't
08:10:16 <benmachine> ooh I think I like where this is going
08:10:18 <benmachine> :P
08:10:23 <Xaphiosis> for example, I keep track of some alsa state (handle, queue, etc), and I'd like to keep track of the key I'm in
08:10:25 <zygoloid> Xaphiosis: hah, i've been thinking about that myself a little :)
08:11:10 <Xaphiosis> but then I want to enter this monad in ghci, so when I say chord "vii7(sus4)" or whatever, it knows what the root note is
08:11:36 <Xaphiosis> currently, I do something like: "s <- start" and then pass s to everything :/
08:12:06 <zygoloid> if you could write something like: "ghci> runState start $ do" that could be awesome
08:12:31 <copumpkin> wow, these are some really helpful descriptions: http://snapplr.com/asws
08:12:45 <hpc> oh wow, zygoloid, that would be badass
08:12:52 <hpc> an interactive nested do
08:12:53 <Xaphiosis> that would be badass
08:13:02 <zygoloid> Xaphiosis: fwiw i /think/ i could add support for that to my REPL if the monad is a Typeable1
08:13:08 <Xaphiosis> and I wouldn't have to do this:
08:13:11 <Xaphiosis> *Play> s <- start False
08:13:18 <Xaphiosis> *Play> getInstrument s 0 20
08:13:27 <Xaphiosis> *Play> chords s $ nRC "D-4" ["i", "-bVII", "-v", "-bVI"]
08:13:39 <Xaphiosis> that s is obvious, it'll be everywhere in the session
08:14:16 <quicksilver> zygoloid: it's possible to write monads for which it doesn't really make any sense to execute "line by line" though, isn't it?
08:14:39 <Xaphiosis> quicksilver: definitely
08:15:02 <Xaphiosis> I'm mostly thinking of derivatives of the state monad
08:15:14 <Xaphiosis> although it might be possible to enter list as well
08:15:21 <Xaphiosis> and maybe
08:15:23 <zygoloid> quicksilver: yeah. if the run function can't work incrementally, then you won't get incremental execution
08:15:52 <zygoloid> actually i think i'd need the thing to be a monad transformer over an arbitrary monad (or at least to be an instance of GhcMonad)
08:16:09 <Xaphiosis> I like where this is going
08:16:11 <zygoloid> since i'm going to be marshalling code into my main loop and running it via the GHC API
08:16:19 <hpc> state monads would be easy
08:16:38 <Xaphiosis> and I wish I was skilled enough to help
08:16:57 <zygoloid> hmm, actually... maybe i can avoid that by running haskeline and the GHC API stuff on separate (forkIO'd) threads
08:17:23 <hpc> another idea would be to have another ghci command
08:17:28 <hpc> like :i or something
08:17:33 <hpc> that changes the interactive monad
08:17:49 <hpc> and have it call show at every step or something
08:18:03 <hpc> although that would break for infinite lists...
08:18:30 <Xaphiosis> well
08:18:42 <Xaphiosis> it's not like you can say "repeat 1" in ghci anyway
08:18:46 <hpc> true
08:18:52 <quicksilver> zygoloid: how would you characterise an incremental monad?
08:18:59 <quicksilver> zygoloid: is that a bit like my monadic tunnelling stuff?
08:19:07 <quicksilver> that talks about how you 'save' the monad-ness and 'put it back' later
08:19:15 <quicksilver> MonadInterleavable or similar
08:19:26 <zygoloid> quicksilver: possibly that (>>) isn't right-strict?
08:19:53 <quicksilver> zygoloid: well, I meant, would you need it to implement a special type class which implements an incremental-run method and what would that method look like
08:20:12 <kremsera> hi
08:20:24 <zygoloid> quicksilver: to be honest i was more thinking of requiring the monad to be MonadIO and just using liftIO . print =<< expr
08:20:39 <zygoloid> (and falling back to not printing if it's not a MonadIO)
08:21:23 <hpc> oh
08:21:25 <hpc> elegant
08:21:29 <kremsera> i try to use the TH`s runQ method within a Control.Monad.Trans.State monad - but get errors about missing instances  
08:21:39 <zygoloid> though obviously if the monad does "weird stuff" like running the computation more than once then you'll get the value printed out at the wrong/surprising times or repeatedly
08:21:47 <kremsera> most probably a simple error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29818#a29818
08:22:18 <hpc> zygoloid: perhaps implement first and see which ones are strange by experimentation? there shouldn't be very many anyway
08:22:27 <hpc> well, perhaps continuations
08:22:37 <zygoloid> hpc: well, ListT would be strange too, but i don't think it's too common :)
08:22:51 <kremsera> does anyone know how to fix this?
08:23:02 <hpc> :t runQ
08:23:04 <lambdabot> Not in scope: `runQ'
08:23:13 <kremsera> import Language.Haskell.TH
08:23:31 <hpc> runQ :: Quasi m => Q a -> m a
08:23:35 * hackagebot clash 0.1.1.1 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.1.1 (ChristiaanBaaij)
08:23:44 <Xaphiosis> wow, I think I'm the only one here who asks easy questions :P
08:23:45 <hpc> is your m an instance of Quasi?
08:24:03 <kremsera> i dont know ;)
08:24:06 <hpc> heh
08:24:08 <kremsera> most probably not^^
08:24:17 <hpc> @instances-importing Language.Haskell.TH Quasi
08:24:17 <lambdabot> Couldn't find class `Quasi'. Try @instances-importing
08:24:25 <benmachine> it's a state monad
08:24:34 <benmachine> only Q and IO are instances of Quasi iirc
08:24:36 <Olathe> > (f $ g $ h $ i $ j) x
08:24:37 <lambdabot>   Couldn't match expected type `a -> b'
08:24:37 <lambdabot>         against inferred type `Simple...
08:24:56 <benmachine> zygoloid: broken-ListT or actual-ListT? :P
08:25:09 <hpc> @unmtl ListT
08:25:09 <lambdabot> err: `ListT' is not applied to enough arguments, giving `/\A B. A [B]'
08:25:11 <quicksilver> zygoloid: how would "liftIO . print =<< expr" thread the state in StateT IO?
08:25:21 <applicative> kremsera, it is hard for me to imagine cornering the compiler into forming this idea:
08:25:25 <applicative> expected: runState (ssimplify b) []  (AppE (AppE (VarE GHC.Base.map) (InfixE (Just (VarE GHC.Float.sin)) (VarE GHC.Base..) (Just (VarE GHC.Float.cos)))) (ArithSeqE (FromToR (LitE (IntegerL 1)) (LitE (IntegerL 10)))),[SigD newname (AppT (AppT ArrowT (ConT GHC.Types.Int)) (ConT GHC.Types.Float)),FunD newname [Clause [VarP x] (NormalB (AppE (VarE f) (AppE (VarE g) (VarE x)))) []]]
08:25:52 <applicative> whatever happened to things like:  expected: a -> [a]
08:26:13 <syntaxfree> benmachine: well, |f'(x)|<1 makes sense as long as (function is well-defined on all points) => (derivative is well-defined at all points)
08:26:14 <hpc> good god
08:26:16 <hpc> IntegerL?
08:26:25 <hpc> i don't know what half that stuff means
08:26:37 <syntaxfree> in any case, consider the functions over the string 'A'..'Z' 
08:26:38 <benmachine> syntaxfree: if it's not differentiable I'm sure there's an analogous result
08:26:48 <applicative> hpc, it's the wages of Template Haskell!
08:26:55 <hpc> oh, no wonder
08:27:01 <benmachine> syntaxfree: it might be to do with f being a contraction (i.e. the difference between f(x) and f(y) being less than the difference of x and y)
08:27:11 <syntaxfree> (\\'A') is both a fixed point and obtainable by iteration.
08:27:18 <benmachine> IntegerL - integer literal
08:27:19 <quicksilver> applicative: the wages of Template Haskell is Death By Error Message?
08:27:32 <syntaxfree> I skipped/slept through much of real analysis.
08:27:39 <applicative> substituting 'are' for 'is'
08:27:52 <kremsera> well its a simple AST i want to return
08:28:03 <quicksilver> applicative: King James had "is"
08:28:05 <quicksilver> applicative: http://www.phrases.org.uk/meanings/373700.html
08:28:09 <benmachine> syntaxfree: (\\'A') is a function, how can it be a fixed point?
08:28:30 <benmachine> syntaxfree: shame, I liked analysis
08:28:32 <syntaxfree> I mean, 'B'..'Z'  is a fixed point of the function (\\'A')
08:28:37 <zygoloid> kremsera: what does ":t ssimplify" say?
08:29:03 <kremsera> in the working case its: ssimplify :: (Monad m) => Exp -> StateT [Dec] m Exp
08:29:23 <frerich> Is there a 'verbose, dry run' mode for ghci which I could use to see how some function would be evaluated? Wrapping my head around some clever uses of foldr is a bit tricky, it would be great if I could somehow see how ghci would call the functions recursively (and using what parameters).
08:29:41 <hpc> > foldr f x
08:29:42 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> SimpleReflect.Expr)
08:29:42 <lambdabot>    aris...
08:29:45 <kremsera> when i comment the line in -  i get 
08:29:45 <kremsera> ssimplify
08:29:45 <kremsera>   :: (Language.Haskell.TH.Syntax.Quasi (StateT [Dec] m), Monad m) =>
08:29:45 <kremsera>      Exp -> StateT [Dec] m Exp
08:29:49 <syntaxfree> anyway, as for the wages of haslkell, it's pretty easy to run into cases where type inference yields a constraint like (RealFrac a, Integral a) => etc
08:29:51 <hpc> > foldr [1..5] f x
08:29:52 <lambdabot>   Couldn't match expected type `a -> b -> b'
08:29:52 <lambdabot>         against inferred type `[...
08:29:57 <hpc> :t foldr
08:29:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:30:09 <zygoloid> quicksilver: it should thread the state correctly i think? it should be: \s -> let (v, s') = expr in (print v, s')
08:30:10 <hpc> > foldr f 1 [2..5]
08:30:11 <lambdabot>   Ambiguous type variable `b' in the constraints:
08:30:11 <lambdabot>    `GHC.Num.Num b'
08:30:11 <lambdabot>      ari...
08:30:17 <hpc> :(
08:30:32 <syntaxfree> :t (\x-> (round (100*x))/100)
08:30:33 <lambdabot> forall t b. (RealFrac t, Integral b, Fractional b) => t -> b
08:31:02 <syntaxfree> common idiom to round to two decimal figures. 
08:31:12 <syntaxfree> of course, it will fail at runtime.
08:31:21 <hpc> i was about to say
08:31:30 <hpc> that's a pretty tough constraint to meet on b
08:31:49 <hpc> you would use `div`
08:31:59 <syntaxfree> or fromIntegral.
08:32:13 <hpc> speaking of which, i just noticed that infix is technically postfix, thanks to currying
08:32:38 <hpc> > let (!) x = x+2 in 5!
08:32:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:32:48 <opqdonut> you need to section it :)
08:33:02 <hpc> > 5!
08:33:02 <opqdonut> > let (!) x = product [1..x] in (5!)
08:33:03 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:33:03 <lambdabot>   120
08:33:24 <hpc> > let x ! = x + 2 in 3!
08:33:25 <lambdabot>   <no location info>: parse error on input `='
08:33:27 <Xaphiosis> time to sleep
08:33:28 <hpc> argh
08:33:39 <Xaphiosis> thank you everyone for your help and great company
08:34:35 <hpc> but because functions "only take one argument and return a function", an infix function of two parameters is postfix of its "only" first parameter
08:34:42 <applicative> quicksilver, I see.  It seems to be an English vs. American problem, e.g. the Kronos Quartet are playing/ the Kronos Quartet is playing ...
08:34:47 <Xaphiosis> zygoloid: good luck on that alternative interactive shell!
08:34:55 <syntaxfree> ah. I see what you mean by drawing a graph. 
08:35:13 * benmachine sections opqdonut 
08:35:14 <applicative> quicksilver, but the good think to know is that Romans 6:23 can solve all problems ... capital punishment, Template Haskell, etc
08:35:17 <syntaxfree> It's like what we do to illustrate stability in dynamical systems.
08:35:40 <syntaxfree> then again, I'm talking about a dynamical system all along. d-oh.
08:35:51 <benmachine> hpc: the haskell98 report (and probably 2010 as well) defined an operator section (x !) as (\y -> x ! y)
08:36:02 <hpc> benmachine: D:
08:36:03 <benmachine> hpc: GHC I think defines them as (!) x
08:36:06 <benmachine> so it depends what you read
08:36:15 <hpc> interesting
08:36:22 <benmachine> syntaxfree: yep :)
08:36:33 <applicative> > map (`opqdonut` 3) [True, False, True]
08:36:33 <hpc> i think the report could use some polymorphism :P
08:36:34 <lambdabot>   Not in scope: `opqdonut'
08:37:04 <syntaxfree> and there's such a thing as a contraction map theorem. so your condition makes sense.
08:38:35 * applicative would like to affirm that this Hackage place is out of control. There used to be just a second or two between "cabal update" and "cabal install hfoo", now its forever.
08:39:09 * hpc always downloads the tarballs
08:39:48 <benmachine> syntaxfree: yeah, I did that in toplogy
08:39:49 * applicative always 'cabal unpack's
08:39:57 <dcoutts_> applicative: hmm? what's the problem?
08:39:59 <benmachine> I don't know if it's necessary but it sounds sufficient
08:40:14 <dcoutts_> hpc: why is that?
08:40:31 <applicative> dcoutts_, its not a problem, it's just surprising how long it is now.   
08:40:37 <hpc> cabal doesn't seem to work on any of my computers
08:40:40 <benmachine> how big is the package list anyways?
08:40:49 <benmachine> (16sec)
08:40:52 <applicative> dcoutts_. hackage is clearly much bigger than a year and a half ago when i first used it 
08:40:59 <hpc> and i can't be arsed to try and fix it when there's another way that's not much more time consuming
08:41:15 <dcoutts_> applicative: oh you mean "cabal update" itself just takes ages?
08:41:23 <applicative> yes,
08:41:31 <applicative> but this is all to the good, in view of the cause
08:41:36 <benmachine> woah
08:41:40 <dcoutts_> applicative: ok, yes we need a more incremental download approach
08:41:47 <benmachine> $ du -h 00-index.tar.gz 
08:41:47 <benmachine> 1.9M	00-index.tar.gz
08:41:48 <hpc> i thought the cause was to /avoid/ success :P
08:41:51 <benmachine> blink blink
08:42:04 <applicative> but i did used to follow the religion of precedining any cabal install / unpack etc. with cabal update
08:42:08 <dcoutts_> I've got some ideas about how to do it
08:43:00 <benmachine> oh wow
08:43:03 <benmachine> there's a new mtl
08:43:08 <benmachine> since the 4th
08:43:10 <applicative> dcoutts_, what all is cabal update downloading.  I guess i should just look at it
08:43:12 <dcoutts_> hpc: so you still use cabal install after using cabal unpack then?
08:43:26 <dcoutts_> applicative: it's all the .cabal files of all packages on hackage.
08:43:28 <hpc> dcoutts_: i don't use cabal at all
08:43:29 * benmachine wonders what changed
08:43:42 <dcoutts_> hpc: so you use runghc Setup then?
08:43:43 <geheimdienst> woah, the decompressed 00-index is 25 megs
08:43:48 <hpc> yeah
08:44:20 <hpc> i can save the tars on my own network so if one of the computers goes to shit i don't need to go hackaging
08:44:37 <applicative> dcoutts_, I see. at this point it needs something in the nature of version control, i guess.
08:44:49 <dcoutts_> hpc: I see, I'd appreciate knowing what is not working with cabal, since the long term plan is for runghc Setup is for it no longer to be a featureful human interface but be just a machine interface for package managers and other tools like cabal.
08:45:12 <dcoutts_> applicative: I was thinking of just downloading the tail of the index
08:45:21 <hpc> dcoutts_: ah, sure; i forget the details, but i will try it out again when i get home
08:45:26 <dcoutts_> applicative: and to append only most the time
08:46:12 <benmachine> oh, the index contains every version of everything
08:46:16 <dcoutts_> yes
08:46:35 <dcoutts_> 8k packages
08:46:49 <benmachine> maybe it could be compressed more effectively using the knowledge that probably most versions of cabal files are the same?
08:46:56 <benmachine> no that'd be a bit
08:47:01 <benmachine> complicated
08:47:02 <hpc> i wouldn't worry about file size
08:47:14 <dcoutts_> benmachine: I think it already is, since they're in order then we get excellent compression
08:47:21 <benmachine> mm
08:47:40 <benmachine> hpc: we're worrying about download time basically
08:47:54 <hpc> ah
08:47:58 <dcoutts_> benmachine: if you've got time to implement something then I can explain the scheme I was thinking of.
08:48:09 <benmachine> dcoutts_: I haven't at the moment really :P
08:48:21 <dcoutts_> ok, well if anyone else does then let me know
08:49:16 <hpc> it might be interesting to have cabal behave as a darcs-ish wrapper
08:49:16 <djahandarie> Time...
08:49:29 <dcoutts_> djahandarie: quite
08:49:35 <dcoutts_> hpc: hmm?
08:49:37 <djahandarie> I would complain about how I don't have any but I am wasting it right now so I should stay silent
08:49:44 <applicative> `time` says `cabal update` is taking 14 seconds.  I guess it just seems long because it used to be 2 seconds or something.
08:50:06 <hpc> it version-controls the source files, interfaces with a version control client to get the latest revision
08:50:10 <hpc> and compile
08:50:35 <hpc> behind the scenes on the server, you have an index of packages and a version control server
08:51:05 <dcoutts_> hpc: oh you mean installing development versions of packages from a source repo?
08:51:39 <hpc> essentially
08:52:04 <dcoutts_> I've thought about that a bit
08:52:07 <hpc> with cabal being just a wrapper that ties everything up in a package manager interface
08:52:11 <dcoutts_> the .cabal files can list source repos
08:52:12 <ajnsit> did anyone else notice the correspondence between darcs "theory of patches" and google wave's "operational transform"?
08:52:57 <hpc> it would put more strain on the server, CPU-wise
08:53:03 <hpc> not sure if that's a limited resource
08:53:13 <hpc> well, /how/ limited, rather
08:54:15 <dcoutts_> hpc: oh you'd not do it all via the server, since the .cabal files list the source repo then the clients just go there directly
08:54:29 <sm> ajnsit: yes. I think there was even some cross-discussion between #darcs and OT folk 
08:55:06 <hpc> i was thinking have hackage still store the files
08:55:11 <geheimdienst> ajnsit, now that you mention it, yeah :) i guess 50% of google wave is about letting multiple people edit the same thing without making a mess of things. same as darcs
08:55:54 <hpc> i suppose the load actually wouldn't be really heavy, actually
08:56:28 <hpc> when a new version of a package is uploaded, the server diffs it with previous versions and saves the patch
08:56:46 <hpc> then you download the right one to update
08:57:23 <hpc> or maybe i am talking out my ass
08:59:56 <ajnsit> so does that mean that atleast some of the work of creating a haskell based operational transform implementation is already done?
09:00:06 <ajnsit> very interesting!
09:01:08 * applicative only just discovered `cabal info`, by finally inferring its existence.
09:03:00 <benmachine> hpc: cabal unpack is near-instant, darcs get tends to take a little while
09:03:01 <tommd> Humm, cabal info gives bad information on my system.
09:03:16 <hpc> benmachine: ah, k
09:03:18 <dcoutts_> tommd: ?
09:03:25 <applicative> cabal unpack is great
09:03:32 <benmachine> hpc: I mean that's not the most terrible thing ever, but it's worth considering
09:03:44 <dcoutts_> applicative: cabal --help lists all the commands
09:03:45 <tommd> dcoutts_: For example, I have crypto-api 0.0.0.1 and 0.0.0.2 installed.  It knows that then tells me the build-deps used for 0.0.0.1 (not for the latest version)
09:04:00 <tommd> dcoutts_: I'm installing latest Cabal library, so we'll see if the problem persists
09:04:12 <applicative> dcoutts_ I know, but I think I only notice what I'm looking for, as just happened.
09:04:23 <hpc> the general idea is pretty good, i think
09:04:33 <dcoutts_> tommd: this is because it only knows about source packages on hackage, 0.0.0.2 is your installed one, it does not know where the source for 0.0.0.2 is, so cannot tell you about it.
09:04:35 <hpc> a speedy version control system though...
09:04:56 <tommd> dcoutts_: 0.0.0.2 is on hackage.
09:05:20 <tommd> oh, but not installed from hackage, nm
09:05:22 * applicative should start a blog "Obvious Haskell Facts" with posts like "look at all the cool stuff cabal can do", that's about his speed
09:05:49 <sm> cabal unpack *is* great
09:05:50 <dcoutts_> tommd: ok, so is what it's telling you consistent with the 0.0.0.2 version that is on hackage?
09:06:51 <tommd> dcoutts_: Ok, its all better now.  You were right - while .2 was on hackage I didn't install it from hackage thus cabal gave info for version .1
09:07:55 * benmachine wonders why crypto-api is good about all its dependencies except for criterion
09:08:05 <dcoutts_> tommd: hmm, it's still not quite clear to me. What info was it giving previously that only applied to .1 ?
09:08:50 <dcoutts_> tommd: and what could it do better to be less confusing?
09:09:57 <tommd> dcoutts_: "Latest version available: 0.0.0.1" and "latest version installed: 0.0.0.2"  -- it's gone from the terminal buffer now, so I can't reproduce the text in full, but that at least was odd to me.
09:10:25 <benmachine> both of those are in fact true though :P
09:10:36 <tommd> Then it gave flags and deps for version 0.0.0.1 (but I only knew they were for 0.0.0.1 because I know the package - had it been a new package to me I wouldn't have known which version the deps and flags were for)
09:11:13 <benmachine> tommd: yes but you'd only have version available > version installed if you'd installed it yourself, in which case presumably you'd know
09:11:16 <dcoutts_> tommd: ok and at that time, had you uploaded version .2 to hackage but not yet run "cabal update" so that cabal still thought version .1 was the latest available on hackage?
09:11:23 <benmachine> er installed > available
09:12:06 <tommd> yes, I do understand now, and didn't come into this conversation having any idea for an improvement, but it was confusing for a second.
09:12:50 <tommd> the definition of "available" being limited to "remotely available" or "publicly available"
09:13:06 <benmachine> you could argue for available being changed to on Hackage
09:13:10 <dcoutts_> tommd: ok, so you had .2 installed and cabal only knew about the .1 version on hackage. I suppose it'd be nice if it considered locally available versions too
09:13:13 <benmachine> but maybe that's unnecessary
09:13:39 <dcoutts_> benmachine: well it's any of the repos configured in the ~/.cabal file, it can be more than just the central hackage server
09:13:46 * applicative 's cabal info knows about more recent versions of crypto-api that tommd's
09:13:46 <dcoutts_> it can be multiple remote or local archives
09:14:16 <tommd> applicative: oh, what's your version?
09:14:20 <benmachine> oh, yes, I suppose so
09:14:34 <applicative> Latest version available: 0.0.0.2
09:15:01 <applicative> tommd, i did cabal update a little while ago...
09:15:15 <tommd> applicative: Yes, that is largely what this discussion is about.  I uploaded that yesterday but had it installed only from my local repo, so cabal doesn't consider that "available"
09:15:40 <applicative> yes i see that.  i don't think it should change, though.  
09:15:54 <applicative> latest available should mean: latest on hackage
09:16:21 <applicative> if you install from repositories you are often ahead of hackage of course, whether are not you are one of the developers.  
09:16:48 <dcoutts_> applicative: or perhaps available in local dir, or specific listed dirs?
09:17:05 <dcoutts_> applicative: e.g. what about if we could say: cabal info foobar  . ./libs
09:17:38 <applicative> yes, i guess it could be clearer.  I was thinking I get information from the way it is now, but i guess I had to learn to make the inference
09:18:15 <applicative> at present the user has to work through a possible stage of puzzlement
09:19:49 <dcoutts_> suggestions for better (less confusing) labelling welcome
09:24:04 * hackagebot bf-cata 1.0 -   http://hackage.haskell.org/package/bf-cata-1.0 (ArieMiddelkoop)
09:24:06 <applicative> dcoutts_ well, on this point, tommd is in the mental state to formulate the cabal info business
09:24:27 <benmachine> I think the labelling is fine
09:24:59 <benmachine> there's potential for confusion but that's not necessarily avoidable while preserving concision and information
09:25:17 <applicative> benmachine, if tommd was puzzled, however briefly, it cant be perfect, but no one would maintain it's a crisis
09:25:55 <benmachine> applicative: even if it's not perfect that doesn't necessarily mean there's a better option :)
09:26:46 <applicative> benmachine, I was thinking so too.  But it might be a question of adding a word or two. "latest hackage version available", say
09:27:12 <applicative> or "latest hackage version available the last time you did cabal update :)"
09:28:50 <dcoutts_> applicative: or "latest source version" ?
09:29:44 <geheimdienst> installed: 4.2 -- on hackage: 4.3 -- in source repo: 4.4-beta
09:29:53 <benmachine> dcoutts_: I think that's technically more correct but no more intuitive
09:30:09 <mathstuf> hi, im looking at T.PP.HughesPJ and found this:
09:30:11 <mathstuf> <n3>    nest k (x <> y)         = nest k z <> nest k y
09:30:16 <benmachine> or hey, that's an idea, you could give each repo a name and then list Latest in <foo>:
09:30:23 <mathstuf> where should this be reported?
09:30:33 <applicative> @type nest
09:30:34 <lambdabot> Int -> Doc -> Doc
09:30:43 <dcoutts_> benmachine: mm, I don't like labelling it as hackage when that just refers to one particular server
09:30:50 <mathstuf> applicative: the left side uses x, the right uses z
09:31:06 <applicative> oh, i see, that's no invariant!
09:31:09 <benmachine> heh
09:31:22 <benmachine> dcoutts_: yes I'd agree with that
09:32:11 <dcoutts_> mathstuf: ghc trac I guess
09:32:30 <mathstuf> looking on official haddock first; this may be an old webpage i got it from
09:32:31 <applicative> but there is the further complication that claims about hackage (or what's 'available') are relative to the most recent cabal update
09:33:00 <dcoutts_> yes, we could mention the "out-of-date"ness of the hackage index
09:33:26 <mornfall> Uh-oh.
09:33:27 <mornfall>       Expected type: [forall x1. (LTLAlike x1, Input x1 ~ a) => x1]
09:33:27 <mornfall>       Inferred type: [forall x1. (LTLAlike x1, Input x1 ~ a) => x1]
09:33:32 <applicative> cabal anything does tell us when we haven't updated for a while
09:33:36 <mathstuf> nope, its on the haddock for it
09:33:37 <mathstuf> http://hackage.haskell.org/packages/archive/pretty/1.0.1.1/doc/html/Text-PrettyPrint-HughesPJ.html
09:33:56 <mathstuf> ah, nice
09:34:04 <mathstuf> hackage has bugtracker links :)
09:34:08 <mornfall> Does that mean that I broke the type checker?
09:34:43 <dcoutts_> mornfall: yes, this means you're entitled to buy SPJ one beer :-)
09:35:10 <applicative> mornfall, awesome. 
09:35:49 <benmachine> mornfall: there are corner cases, especially with type families, in which you can't provide proper type signatures I think
09:35:49 <copumpkin> isn't that impredicative?
09:35:59 <mornfall> copumpkin: Good guess.
09:36:06 <copumpkin> well, I knew it was :P
09:36:13 <applicative> yes, the inferred type is actually in a higher universe
09:36:21 <applicative> or something
09:36:27 <benmachine> how spiritual
09:36:27 <copumpkin> but I thought the reason it was getting removed was that it was horrendously complex
09:36:34 <copumpkin> and might be fully of bugs :P
09:36:42 <copumpkin> mornfall: so don't use it! :P
09:36:43 <mornfall> I guess it doesn't like the ~ constraint.
09:37:16 <Philippa> applicative: the whole point of impredicative types is that there's still only one universe
09:37:21 <mornfall> I guess i'm too lazy to rewrite this with fundeps.
09:37:24 <Philippa> or at least, unless you know better for another reason
09:37:35 <copumpkin> mornfall: why not just make a wrapper type?
09:37:41 <applicative> Philippa, i was thinking we were seeing an objection to the idea
09:37:49 <mornfall> copumpkin: I guess I could. With proper instance and all.
09:37:50 <copumpkin> mornfall: that way you aren't relying on a feature which is getting dumped soon
09:38:59 <mornfall> Oh wait. I don't want a wrapper type.
09:39:19 <mornfall> But I could lift the forall out of the list without losing much.
09:40:09 <mathstuf> applicative dcoutts_: filed, thanks
09:40:26 <wjt> Does John Millikin hang out on here?
09:40:37 <mornfall> Inference with type families sucks. :(
09:41:01 * wjt has been playing with his D-Bus bindings, with some positive and some negative results
09:41:03 <applicative> Philippa, the predicative / impredicative distinction and irritation at the latter were first formulated by Poincare 
09:41:03 <copumpkin> use data families
09:41:22 <Philippa> applicative: yeah, but the thing is System F works
09:41:33 <copumpkin> just don't prove things with it :)
09:41:47 <Philippa> as does System Fc, which is GHC's intermediate lang. So it's impredicative under the hood anyway
09:42:25 <applicative> La logique n'est plus sterile! Elle engendre la contradiction!
09:43:16 <mornfall> Philippa: I imagine the catch is that you have annotations from outside, under the hood.
09:43:25 <applicative> To which Philippa replies, Yeah, but it works.
09:43:49 <applicative> to which Poincare replies, well maybe we're just lucky in this case?
09:44:29 <Philippa> we're not, in the case of System F. It's not set theory
09:44:46 <Philippa> mornfall: yes, System F(c)'s explicitly typed
09:45:05 <applicative> The difficulty with impredicativity is intelligibility
09:46:02 <Philippa> *nod*. It doesn't stop System F being well-studied. Whether you want impredicativity in something like Coq, I leave to those more knowledgeable than I
09:46:29 <Philippa> (the answer appears to be "not all the way to the top", as far as I can tell)
09:46:55 <copumpkin> I think coq has impredicativity on prop but not on sets, even though it collapses set universe levels syntactically unless you ask it not to?
09:47:02 * copumpkin has only read the book, and hasn't actually used it :P
09:47:04 <dcoutts_> wjt: what's new with the dbus bindings?
09:47:34 <wjt> dcoutts_: they're not as convenient to use as I would have hoped
09:47:41 <copumpkin> and if you get impredicativity on sets, you can prove false easily, so you probably don't want it there
09:48:27 <wjt> dcoutts_: in the context of round-trip benchmarks, i thought I'd compare a Haskell implementation to the C one. It's 2.5× shorter, but also 2.5× slower :o
09:48:32 <dcoutts_> wjt: I'm sure the maintainer would appreciate feedback if you're making serious use of them
09:48:40 <Philippa> yeah. Not so much an issue in a language with completely general recursion sans proof burdens
09:49:04 <wjt> dcoutts_: Yeah, he's been very responsive by email in the past; planning to distill this down into a -cafe post later
09:49:12 <dcoutts_> great
09:50:06 <bnery> hi guys
09:50:22 <bnery> do any of you know how to convert a [Char] to a SomeObject in CPython?
09:50:57 <applicative> > let f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char]); f (Just g) = Just (g [3], g "hello"); f Nothing = Nothing in f (Just reverse)
09:50:58 <lambdabot>   Just ([3],"olleh")
09:51:23 <applicative> lambdabot seems to have fancy types enabled.
09:53:50 <aristid> applicative: fancy types?
09:54:07 <geheimdienst> -XEnableFancyTypes
09:54:11 <applicative> i was thinking it needed -XImpredicativeTypes
09:54:22 <aristid> what's the effect?
09:54:39 <monochrom> -XTypeDirectedChoosingBetweenImpredicativeAndPredicativeTypes
09:54:41 <geheimdienst> -XFrickinAwesomeTypes
09:54:58 <geheimdienst> -XArtsyFartsyTypes
09:55:25 <applicative> -XDecadentTypes
09:55:30 <copumpkin> -XIDon'tCareIfTypeCheckingIsUndecidableSoPleaseDoEverythingAndI'llJustKillYouIfIGetTiredOfWaiting
09:55:49 <monochrom> -XDependentTypes
09:56:08 <aristid> -XYouSuck
09:56:16 <geheimdienst> -XOtherworldlyTypes
09:56:32 <monochrom> -XDynamicTypes
09:56:33 <copumpkin> -XSubstructuralTypesOfYourChoice
09:56:38 <geheimdienst> -XIAmSPJDoWhatISay
09:56:46 <monochrom> -XSudo
09:56:55 <monochrom> -XSudoMakeSandwich
09:57:38 <applicative> i think SPJ & co aren't going to give you the password for sudo in the typesystem
09:58:06 <Philippa> -XIAmSPJDoWhatIMean :p
09:58:32 <applicative> -XIAmSPJDoWhatIMean63833NM2321
09:58:41 <benmachine> -XHaltingOracle
09:59:25 <geheimdienst> -XOpenThePodBayDoor
10:02:12 <applicative> Is it nonsense to imagine something parallel to Show instances for types, to control error messages like:
10:02:13 <applicative> expected: runState (ssimplify b) [] (AppE (AppE (VarE GHC.Base.map) (InfixE (Just (VarE GHC.Float.sin)) (VarE GHC.Base..) (Just (VarE GHC.Float.cos)))) (ArithSeqE (FromToR (LitE (IntegerL 1)) (LitE (IntegerL 10)))),[SigD newname (AppT (AppT ArrowT (ConT GHC.Types.Int)) (ConT GHC.Types.Float)),FunD newname [Clause [VarP x] (NormalB (AppE (VarE f) (AppE (VarE g) (VarE x)))) []]]
10:02:51 <applicative> what this means could probably be clear to the programmer, if it didn't have to be arranged like that
10:03:00 <geheimdienst> a few newlines and indentation per day keeps the doctor away?
10:03:04 <benmachine> applicative: that isn't a type
10:03:07 <applicative> no
10:03:10 <applicative> right
10:03:15 <applicative> i was cutting and pasting
10:03:27 <benmachine> I'm confused
10:03:29 <earthy> HAL check: I cannot do that Dave.
10:03:46 <applicative> i apologize for the example, which is what is what caused this train of thought
10:03:48 <geheimdienst> ghc: I cannot let you jeopardize the mission
10:03:55 <applicative> but if one is led along by the typechecker
10:04:07 <applicative> many nice things like the symantics business 
10:04:42 <applicative> give you hideously arranged signatures, but the explanation is, basically that they can't use infix forms etc
10:05:22 * applicative is thinking how he can produce a good error of the type he was made to think of earlier
10:12:36 <bnery> is there an function similar to 'sleep' or 'delay'?
10:13:18 <Zao> System.Thread.threadSleep?
10:13:23 <Zao> Or so a simple search hints.
10:13:41 <zygoloid> applicative: maybe you could pretty-print the expression with something like this: http://blog.ezyang.com/2010/07/groom-human-readable-show-for-haskell/
10:14:05 <Zao> Erm, Control.Concurrent.threadDelay seems relevant.
10:14:13 <Zao> If you use GHC, that is.
10:16:14 <applicative> zygloid, yes, but this is more like standard pretty printing of show (blah :: Crazy) 
10:17:07 <applicative> zygloid, i was thinking of type errors, but I will pose my question when I have a clear case before me.  The trouble is of course that I avoid things that give insane type errors
10:17:52 <applicative> since i rely on the type checker to tell me what i'm doing....
10:27:49 <trinithis> If I want to use StateT, should I import Control.Monad.State or Control.Monad.Trans.State?
10:28:33 <ziman> @index StateT
10:28:34 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
10:29:04 <c_wraith> Personally, I'd usually use Control.Monad.State.Strict
10:29:19 <c_wraith> unless you have a good reason for not wanting strict state
10:29:25 <trinithis> na, I dont
10:34:03 <DanielDiaz> c_wraith: Can you give me a comparison between lazy and strict State? I want to learn more. :)
10:34:50 <DanielDiaz> c_wraith: if you have a preference, you should have a reason
10:35:20 <c_wraith> DanielDiaz, strict State is faster and less prone to accidental space leaks
10:35:29 <trinithis> http://blog.melding-monads.com/2009/12/30/fun-with-the-lazy-state-monad/
10:35:40 <c_wraith> The downside to it is that it does explicitly sequence the actions
10:35:58 <c_wraith> Lazy state lets you do fun things like that blog post mentions. :)
10:36:10 <c_wraith> But you have to be careful about space use.
10:36:22 <DanielDiaz> thanks to both ;)
10:37:44 <applicative> zygloid, here's and example of a type error of the sort I was imagining http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=29819
10:39:13 <applicative> my question was, is it unimaginable that the author of something like this sprintf sscanf library (from the 'fun with type functions' source)
10:40:13 <applicative> could have devices for pretty printing the types so to speak.  
10:42:41 <applicative> With this lib one will forever be dealing with a special zone of types that just attach to each other 
10:49:56 <mikeX> hi, importing Control.Monad.Error ghc 6.12 gives me:     Ambiguous interface for `Control.Monad.Error': it was found in multiple packages: mtl-1.1.0.2 monads-tf-0.1.0.0
10:50:20 <mikeX> what's the simplest way to work around this?
10:50:43 <Starfire> mikeX: ghc(i) -hide-package mtl
10:51:00 <Starfire> I think you can also :set -hide-package mtl from the ghci prompt.
10:51:08 <kmc> if you build with cabal
10:51:15 <kmc> it will handle this from your package dependencies
10:51:47 <applicative> mikeX, monads-tf is rarer, so you might just use ghc-pkg hide monads-tf-0.1.0.0 unless what you want needs that package
10:52:04 <mikeX> kmc: yeah I read about that but I'm not quite there yet (cabal)
10:52:08 <mikeX> thanks Starfire, applicative 
10:53:00 <JoeyA> In theory (GHC would probably need to be modified), is it possible to efficiently attach arbitrary context to a stable name (which is lost when it's garbage collected, but that's exactly what I want)?
10:53:11 <mikeX> so, say I had dependencies on both packages. Would a package-qualified import be the only solution then?
10:53:24 <kmc> mikeX, your code imports both?
10:53:29 <kmc> or just it depends on stuff importing both?
10:53:46 <mikeX> no, I'm fine with -hide-package, just wondering because I saw a relevant thread when looking for a solution
10:53:50 <kmc> JoeyA, StableName supports Eq and hashing
10:53:56 <kmc> JoeyA, so you can use them as map keys more or less
10:54:14 <JoeyA> I'm thinking about a simple Haskell database API that stores and retrieves values, using DB references when known stablenames are encountered.
10:54:14 <kmc> not sure about making that get GC'd
10:55:02 <JoeyA> So you can store a giant object in the database, retrieve it lazily, and store it back taking advantage of data already stored there.
10:55:43 <JoeyA> If a Data.Map implemented the right instances, indexes would be free, as the on-disk database would use Data.Map's sorting algorithm.
10:56:20 <JoeyA> It would be reasonably efficient for updating values, and it would integrate smoothly with Haskell's type system.
10:56:59 <JoeyA> Sure, I could make a Map of stablename hash -> DB pointers, but it wouldn't be garbage collected when the stablenames aren't used anywhere else
10:57:12 <JoeyA> (unless there's some trickery that can be done with finalizers)
10:57:52 <JoeyA> It would be more efficient if a context pointer could be attached directly to the internal stable name's structure
10:58:15 <JoeyA> (provided it doesn't require expanding the memory footprint of all Haskell data structures by 1 pointer)
10:58:22 <JoeyA> (elsewhere)
10:58:56 <JoeyA> Anyway, there's my idea.  I think it's pretty cool, but I don't feel like implementing it any time soon.
10:59:41 <JoeyA> To clarify, the API might be like:
10:59:49 <JoeyA> db <- open "foo.db"
10:59:56 <JoeyA> write db [1,2,3]
11:00:14 <JoeyA> close db
11:00:20 <JoeyA> db <- open "foo.db"
11:00:24 <JoeyA> (Just xs) <- read db
11:00:31 <JoeyA> -- xs contains [1,2,3]
11:01:03 <JoeyA> write db (0 : xs) -- does not rewrite the [1,2,3]; uses a reference to that in the DB instead
11:01:23 <JoeyA> write db [0,1,2,3] -- writes a fresh copy of the [1,2,3] because it's not the same pointer as we used before
11:01:43 <copumpkin> that would be difficult
11:02:03 <JoeyA> An ideal implementation would probably optimize these cases and always write fresh copies instead of using pointers, but it would still use references for large structures)
11:06:30 <applicative> JoeyA, how long have you been using haskell?
11:07:17 <JoeyA> 4 months
11:07:24 <applicative> :)
11:07:28 <mornfall> :)
11:07:33 <copumpkin> :)
11:07:40 <JoeyA> :)
11:07:48 <fryguybob> @botsnack
11:07:48 <lambdabot> :)
11:08:01 * applicative was thinking, God, I seem to remember giving this JoeyA dude helpful advice just a few weeks, now I'm completely lost
11:08:21 <applicative> just a few weeks ago, rather
11:08:31 <JoeyA> Y'all have given me helpful advice many times, thanks.
11:09:03 <geheimdienst> kids grow, ya wouldn't believe it
11:09:06 <applicative> These are the advantage of superior brainpower.  Maybe I can hope for something like superior wisdom or something....
11:09:46 * geheimdienst is shooting for superior expertise on the topic of lolcats
11:09:53 <applicative> well, anyway, I affirm that JoeyA is astounding. 
11:10:37 * JoeyA 's face turns red
11:10:39 * applicative is thinking, some of those lolcats were a little hard to interpret
11:10:52 <JoeyA> lolcats must be _compiled_
11:11:02 * applicative apologizes
11:11:05 <copumpkin> @quote lolcategory
11:11:06 <lambdabot> tensorpudding says: lolcategory demands moarphisms
11:11:06 <JoeyA> (then again, I know nothing in-depth about them)
11:11:14 <JoeyA> lol
11:11:35 <geheimdienst> @quote lolcat
11:11:35 <lambdabot> geheimdienst says:  i totally didn't realize that leksah = reverse haskel. i thought leksah was what the lolcats said for lexer
11:11:44 <geheimdienst> oh, a quote from myself
11:11:51 <geheimdienst> @quote lolcat
11:11:51 <lambdabot> tensorpudding says: lolcategory demands moarphisms
11:11:54 <benmachine> I thought that too!
11:11:58 <_linuxftw> What is the meaning of "<-" in haskell?
11:12:00 <JoeyA> How do you store quotes, by the way?
11:12:02 <geheimdienst> @quote lolcat
11:12:02 <lambdabot> tensorpudding says: lolcategory demands moarphisms
11:12:16 <geheimdienst> @help remember
11:12:16 <lambdabot> quote <nick>
11:12:16 <lambdabot> remember <nick> <quote>
11:12:16 <lambdabot> Quote somebody, a random person, or save a memorable quote
11:12:40 <JoeyA> linuxftw: in do notation, it performs an action and puts the result in a variable for use by actions below
11:13:06 <JoeyA> do {a <- getLine; putStrLn a} is equivalent to getLine >>= putStrLn
11:13:16 <_linuxftw> Right, I was trying to do: filename <- "someFile.txt", but I guess this doesn't work because "someFile.txt" isn't an action?
11:13:23 <JoeyA> right
11:13:25 <applicative> exactly
11:13:34 <applicative> in fact, you would be taking the Chars out
11:13:35 <JoeyA> actually, if you're in the List monad, it will work, but not the way you expect :-)
11:13:40 <JoeyA> (indeed)
11:14:05 <Nibble> @src Just
11:14:05 <lambdabot> Source not found. Wrong!  You cheating scum!
11:14:05 <JoeyA> filename <- readFile "someFile.txt" will make your codez work
11:14:12 <Nibble> uhmhum
11:14:19 <avenge> kell
11:14:22 <Nibble> @type Just
11:14:22 <copumpkin> Nibble: just is a constructor
11:14:23 <lambdabot> forall a. a -> Maybe a
11:14:34 <Nibble> that was rather obvious
11:14:38 <Jafet> Well, we already have a module for BASIC
11:14:45 <Nibble> @src Maybe
11:14:45 <lambdabot> data Maybe a = Nothing | Just a
11:14:50 <Nibble> well duh
11:15:01 <Jafet> This ISP is weird
11:15:03 <Nibble> About this typ,e comb :: Maybe a -> (a -> Maybe b) -> Maybe b
11:15:22 <JoeyA> "<Jafet> Well, we already have a module for BASIC" which?
11:15:32 <Nibble> Am I right if I say that I could do (Maybe a, Maybe b) => a -> (a -> b) -> ?
11:15:33 <Jafet> @hackage BASIC
11:15:34 <lambdabot> http://hackage.haskell.org/package/BASIC
11:15:47 <aristid> Nibble: no.
11:15:59 <JoeyA> hehe
11:16:09 <Nibble> aristid: then what is Maybe?
11:16:12 <Nibble> A type constructor?
11:16:22 <aristid> Maybe is an abstract data type
11:16:24 <aristid> not a class.
11:16:26 <Nibble> and the (Integer a) shit is for classes
11:16:26 <geheimdienst> nibble, on the left side of a "=>", you put typeclasses. Maybe is not a class
11:16:28 <Nibble> oh
11:16:30 <Nibble> I see
11:17:08 <geheimdienst> you could require something that is both an Integer and a Foo by saying (Integer a, Foo a) => a ...
11:17:24 <geheimdienst> for a Maybe, this wouldn't make sense
11:18:27 * JoeyA is trying to figure out how the BASIC package makes it possible to apply a value to a number like 100 END
11:18:50 <copumpkin> 100 is Num a => a
11:19:01 <copumpkin> if you make a function instance of Num
11:19:01 <kmc> Maybe is not an abstract data type
11:19:03 <copumpkin> you can do some evil that way
11:19:06 <kmc> it's concrete, because you can see its constructors
11:19:10 <copumpkin> it's an algebraic data type!
11:19:13 <ddarius> > 100 True
11:19:14 <copumpkin> damn overlap on ADT
11:19:14 <lambdabot>   100
11:19:17 <kmc> unfortunately both have the acronym ADT
11:19:21 <copumpkin> omg ddarius is back
11:19:26 <applicative> T + 1, very algebraic
11:19:37 <copumpkin> applicative: what's "only sort of algebraic"? 
11:19:42 <EvanCarroll> what is the fn that takes a [Char] and splits it on Char
11:19:50 <geheimdienst> ddarius, i think that only works because caleskell is funky
11:19:55 <geheimdienst> in ghci it wouldn't iirc
11:19:57 <copumpkin> it isn't caleskell
11:20:04 <ddarius> vector-spaces
11:20:06 <EvanCarroll> I want [Char] -> Char -> [[Char]]
11:20:09 <ddarius> @google "almost algebraic"
11:20:10 <lambdabot> http://arxiv.org/abs/1001.2371
11:20:13 <benmachine> :t break . (==)
11:20:14 <lambdabot> forall a. (Eq a) => a -> [a] -> ([a], [a])
11:20:22 <JoeyA> data Lol a = a | Moar a (Lol a)
11:20:36 <benmachine> @hackage split
11:20:36 <lambdabot> http://hackage.haskell.org/package/split
11:20:38 <geheimdienst> well i tried "100 True" in ghci and it throws an error
11:20:43 <copumpkin> JoeyA: need moar constructorz
11:20:47 <benmachine> geheimdienst: you don't have lambdabot's instances
11:20:54 <JoeyA> oh
11:20:54 <applicative> copumpkin, I was just thinking, types like 2 X*X*X + 3 Y *Y etc. to have Maybe types in my life....
11:20:54 <Nibble> is Maybe an instance of Monad(stupid question)
11:20:57 <JoeyA> oops
11:21:00 <byorgey> Nibble: yes.
11:21:06 <applicative> rather, i was thinking i wouldn't need them
11:21:11 <geheimdienst> yeah that's what i meant. isn't caleskell the language lambdabot speaks
11:21:27 <byorgey> Nibble: figuring out how to implement the Monad instance for Maybe is a great exercise.
11:21:28 <benmachine> Nibble: fun fact, you can check what is an instance of what using ghci
11:21:38 <applicative> whats a good lambdabot use of Maybe's monadness for Nibble
11:21:44 <EvanCarroll> are you serious, there is no Prelude function that splits a string on a single character into a list of strings?
11:21:45 <benmachine> Nibble: :info Maybe, for example
11:21:53 <mauke> EvanCarroll: indeed
11:21:57 <geheimdienst> > sequence [Just 3, Just 5]
11:21:57 <lambdabot>   Just [3,5]
11:22:08 <geheimdienst> > sequence [Just 3, Nothing]
11:22:09 <lambdabot>   Nothing
11:22:09 <EvanCarroll> mauke: well, at least that is a straightforward response
11:22:14 <EvanCarroll> mauke++ thanks.
11:22:18 <ddarius> geheimdienst: The function instance for Num comes from the vector-space package.
11:22:23 <benmachine> EvanCarroll: the Prelude is supposed to be kinda small :)
11:22:27 <benmachine> hackage to the rescue
11:22:49 <EvanCarroll> benmachine: I would call it huge but ok.
11:22:54 <byorgey> EvanCarroll: people have talked about adding such a thing for a long, long time.  The problem is no one can agree on the right design.
11:23:00 <byorgey> It's actually a rather tricky design space.
11:23:02 <benmachine> EvanCarroll: therein lies the "supposed"
11:23:11 <EvanCarroll> fair enough.
11:23:14 <geheimdienst> Data.List.Split, i think
11:23:32 <byorgey> EvanCarroll: The 'split' package on Hackage is supposed to collect up a bunch of different approaches, so you can have whichever kind of splitting you want
11:23:39 <JoeyA> Hmm, the BASIC package uses llvm
11:23:50 <ddarius> JoeyA: It's a BASIC compiler.
11:24:04 <geheimdienst> byorgey, but break is in Prelude. it's just inconvenient because it returns the separator
11:24:21 <mrsolo>  reading old post and came across this...
11:24:25 <mrsolo> ... The long-standing bug in GHC's garbage collector that makes writing a single
11:24:25 <mrsolo> boxed value into an array O(n) instead of O(1)
11:24:29 <mrsolo> is this still true?
11:24:32 <byorgey> geheimdienst: that's only inconvenient if you don't want the separator ;)
11:25:19 <mauke> mrsolo: http://hackage.haskell.org/trac/ghc/ticket/650
11:25:21 <byorgey> geheimdienst: besides, it only splits once, if you want to split everywhere you have to do it yourself with unfold or explicit recursion.
11:25:57 <_linuxftw> How would I write a line like this inside a "do" statement? result = lotsOfCalculations fileContents
11:26:03 <benmachine> :t \p -> unfoldr (\xs -> case xs of [] -> Nothing; _ -> Just . second (drop 1) $ break p xs)
11:26:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
11:26:10 <mrsolo> mauke: nice!
11:26:13 <kmc> _linuxftw, probably you mean result <- lotsOfCalculations fileContents
11:26:19 <geheimdienst> considering i just passed the separator into the function, i don't see why the function thinks it needs to inform me of this surprising new discovery of what the separator is
11:26:27 <_linuxftw> I tried that, i'll get the error
11:26:31 <kmc> _linuxftw, "let x = y" does not execute any actions; it just creates a local name for whatever x is
11:26:32 <JoeyA> _linuxftw: let result = lotsOfCalculations fileContents
11:26:37 <geheimdienst> and you're right, splitting only once is another problem with break
11:26:42 <kmc> _linuxftw, put another way: getChar is not a character; it's a recipe for how to get a character
11:26:45 <kmc> to execute a recipe you use <-
11:26:57 <kmc> _linuxftw, http://www.haskell.org/haskellwiki/Introduction_to_IO
11:27:07 <Nibble> yeah, linuxftw!
11:27:21 <_linuxftw> kmc, thanks for the link. It seems "let something=something" works perfectly, I just didn't know the "let" was required.
11:27:28 <byorgey> geheimdienst: but you also passed the whole string into the function, so by that logic it should return nothing at all =)
11:27:28 <benmachine> geheimdienst: break has the separator in there because e.g. break isUpper
11:27:48 <kmc> _linuxftw, oh, i see.  'fileContents' is some value you already retrieved from the file?
11:27:50 <benmachine> geheimdienst: and also because it distinguishes splitting " " on spaces and "" on spaces
11:27:51 <kmc> makes sense then
11:28:01 <_linuxftw> yeah
11:28:19 <kmc> so yeah, "let" will just make a local name for that expression
11:28:25 <kmc> it doesn't even evaluate the expression
11:28:27 <aristid> :t break
11:28:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:30:08 <aristid> :t (second.(.).(.)) tail break
11:30:09 <lambdabot>     Couldn't match expected type `(d, f (f1 [a]))'
11:30:09 <lambdabot>            against inferred type `(a1 -> Bool) -> [a1] -> ([a1], [a1])'
11:30:10 <lambdabot>     In the second argument of `(second . (.) . (.))', namely `break'
11:30:30 <aristid> :t (second.(.).(.)) tail
11:30:30 <lambdabot> forall d (f :: * -> *) (f1 :: * -> *) a. (Functor f, Functor f1) => (d, f (f1 [a])) -> (d, f (f1 [a]))
11:31:25 <aristid> :t ((.).(.).second) tail break
11:31:26 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:31:37 <geheimdienst> i'm not arguing that break is broken, i think break is all justifiable. still, i think there should be a Prelude.split such that «split ':' "/usr:/bin:/foo"» gives ["/usr", "/bin", "/foo"]
11:31:57 <geheimdienst> because for this use case, break is clunky
11:33:00 <bos> geheimdienst: then use the text package instead
11:33:50 <nlogax> i'm trying to write a @seen-ish thing for my irc bot, what would be a good data type to use? something set:y so i can just update it with ("nick", "last thing said"), and it would replace whatever "nick" said before that, if anything
11:34:06 <benmachine> nlogax: I'd think a Map
11:34:14 <mauke> nlogax: a database
11:34:54 <nlogax> benmachine: i'll check out Data.Map then, thanks!
11:35:03 <nlogax> mauke: i started out using mongodb, but it felt like overkill :)
11:35:24 <mauke> you can't have too much overkill
11:35:59 <notabel> the split package, upon inspection, is manifest proof of the breadth of the design space
11:36:27 <nlogax> mauke: i like the way you think
11:36:33 * tg_ curls his moustache. prrrroooof, I tell you!
11:36:52 <tg_> i love you guys
11:36:55 <mauke> perl works just fine with a single split()
11:37:06 <tg_> oh god
11:37:11 <tg_> did you? you didn't?
11:37:24 <tg_> question: anyone in here work on Junctions in Perl6 and/or something similar in Haskell?
11:37:59 <bos> what's a junction?
11:38:15 <tg_> it was a renamed version of a 'superposition'
11:38:24 <bos> wtf is a superposition?
11:38:26 <geheimdienst> O RLY
11:38:26 <tg_> http://en.wikipedia.org/wiki/Perl_6#Junctions
11:38:32 <tg_> like, quantum superpositiion
11:38:36 <bos> christ.
11:38:51 <tg_> i presume it was implemented in haskell first, at some point
11:39:20 <mauke> http://search.cpan.org/~lembark/Quantum-Superpositions-2.02/lib/Quantum/Superpositions.pm
11:39:24 <notabel> tg_: i'm not sure about that, i think Quantum::Superpositions was the initial proof-of-concept
11:39:38 <tg_> notabel: yes, which I used. I figured in P6 it was written in haskell for some reason
11:39:40 <tg_> I could be totally wrong
11:39:50 <tg_> it was added to P6 very early
11:40:00 * notabel pulls out his Pugs tree
11:40:03 <notabel> we'll see
11:40:09 <tg_> thanks broseph
11:40:11 <geheimdienst> junctions were implemented in haskell first, only that they were called surtransitoid monocombobuloids
11:40:28 <JoeyA> my $cat_alive = 0 | 1;
11:40:30 <mauke> did you mean: lists
11:40:36 <tg_> lolol
11:40:40 <tg_> not lists, clearly :O
11:40:43 <bos> god, perl6 is so full of half-baked underspecified regurgitations of something someone read in an algebra book while ill with dengue fever 20 eyars earlier.
11:40:51 <kmc> tg_, Pugs is an implementation of Perl6 in Haskell
11:40:56 <mauke> tg_: why not lists?
11:40:57 <tg_> kmc: this i know
11:41:06 <tg_> mauke: because lists don't collapse themselves
11:41:18 <mauke> collapse how?
11:41:33 <geheimdienst> import Data.ListThatCollapsesUnderItsOwnWeight
11:41:38 <tg_> they don't have operators in between the elements
11:42:04 <mauke> they do
11:42:04 <JoeyA> Is Pugs an interpreter or compiler?
11:42:05 <benmachine> :
11:42:07 <mauke> it's called (:)
11:42:16 <tg_> that's a function, not an operator
11:42:19 <tg_> yes?
11:42:20 <notabel> JoeyA: both, but it compiles to languages or VM code, not machine code
11:42:26 <JoeyA> ah
11:42:31 <mauke> tg_: it clearly is an operator
11:42:39 <JoeyA> no llvm then, I guess.
11:42:41 <mauke> it has infix syntax
11:43:24 <tg_> and you can make these lists store the boolean and/or operator in between them?
11:43:36 <tg_> or, presumably, more interesting ones :o
11:43:40 <mauke> yes, there's a handy combinator that replaces : with whatever you want
11:43:44 <mauke> it's called foldr
11:43:51 <aristid> mauke: CRAZY!
11:44:11 <tg_> still not the same in some sense
11:44:12 <mauke> @src and
11:44:13 <lambdabot> and   =  foldr (&&) True
11:44:15 <mauke> @src or
11:44:15 <lambdabot> or    =  foldr (||) False
11:44:24 <Nibble> A quick question
11:44:28 <Nibble> do m  <- mother s
11:44:30 <Nibble>                                   gf <- father m
11:44:32 <Nibble>                   father gf
11:44:34 <mauke> @src And
11:44:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:44:46 <Nibble> given that code, sorry for paste. I intended it to be on one line
11:44:57 * geheimdienst liked how they can make a sub foo ( RGB_Color | CMYK_Color c ) or sub bar ( This & That t )
11:45:21 <Nibble> would it be something like this? mother >>= father >>= mother
11:45:45 <kmc> mother >>= father >>= father
11:45:47 <kmc> right?
11:45:49 <Nibble> oh
11:45:50 <mauke> mother s >>= father >>= father
11:45:51 <Nibble> my fault,
11:45:52 <jmcarthur> hey, has anybody here gotten ghc 6.12 to work on an older version of ubuntu, circa 8.04?
11:46:04 <benmachine> or hey what about mother >=> father >=> father $ s
11:46:06 <tg_> mauke: is there really no difference here? There seems to be something missing from just using lists here.
11:46:06 <Nibble> mauke: well, that is just a snippet.
11:46:21 <Nibble> in the real one there is the Just s
11:46:22 <kmc> do { m <- mother s; e }   ===   mother s >>= \m -> e
11:46:30 <mauke> tg_: I don't know, I haven't used junctions
11:46:31 <tg_> obviously that would require you to investigate perl, which I presume you won't want to do :o
11:46:33 <kmc> and of course (\m -> father m) is equivalent to father
11:46:44 <mauke> tg_: no, I'd have to investigate perl6
11:46:47 <mauke> I already know perl
11:46:58 <tg_> sure, but not junctions
11:47:00 <notabel> mauke: think of junctions as lists tagged with one of {None|All|Any|One}
11:47:06 <tg_> i'm in the same boat
11:47:10 <jmcarthur> Nibble: father <=< father <=< mother $ s  -- my preferred way :)
11:47:10 <mauke> hah
11:47:11 <tg_> I haven't even touched p6 yet
11:47:30 <notabel> so it's a list that know a "satisfaction parameter" of sorts.  it knows both the alternatives and the relation desired between them
11:47:33 <tg_> i've read some of those long expositions by larry wall about what is good and bad
11:47:46 <tg_> notabel: something like that
11:47:52 <mauke> :t All
11:47:53 <lambdabot> Bool -> All
11:47:58 <mauke> :t Any
11:47:59 <lambdabot> Bool -> Any
11:48:14 <tg_> didn't know about those
11:48:18 <notabel> in Pugs junctions are implemented using tagged Sets
11:48:32 <tg_> notabel: thanks! link?
11:48:52 <notabel> src/Pugs/Junc.hs in the pugs tree
11:49:10 <notabel> the easiest way to get it is probably from hackage
11:49:12 * tg_ nods warmly
11:49:20 <geheimdienst> tg_, check out http://feather.perl6.nl/syn/S03.html#Junctive_operators
11:49:24 <tg_> notabel: that's a funny coincidence
11:49:46 <tg_> geheimdienst: thanks
11:49:51 <tg_> this looks like it's been updated a lot
11:49:51 <notabel> oh mauke, junctions also have some semantic differences from lists, like implicit parallelism
11:50:46 <mauke> that's just a mapM_ forkIO away
11:51:10 <notabel> well, that and ignoring the word implicit
11:51:48 <mauke> I don't think it's completely implicit
11:51:53 <mauke> if it was, it would be useless
11:51:57 <notabel> in perl6 all junction operations are potentially parallel
11:52:39 <notabel> there is obviously a lot of design debate about when to actually parallelize, but that's an implementation detail
11:53:08 <aristid> obviously so
11:53:12 <copumpkin> and an incredibly difficult one
11:53:16 <notabel> indeed
11:53:17 <copumpkin> as people found with haskell
11:53:28 <nlogax> benmachine: Data.Map is just what i needed, thanks :)
11:53:30 <copumpkin> "omg everything is pure, parallelism is super easy"
11:53:31 <copumpkin> :P
11:53:53 <geheimdienst> let me fork off an OS thread to evaluate 42+1
11:53:55 <tg_> you can do nothing, really fast
11:54:09 <notabel> well, it's true that parallelism is super-easy to get Correct.  but silly us, we want it to be faster too :-P
11:56:26 <Nibble> copumpkin: is it not easy(ier)
11:56:49 <tg_> sometimes it is, I suppose.
11:57:05 <tg_> i always love discussing embarassingly parallel things
11:58:18 <copumpkin> Nibble: it is easier, but it's not easy
12:00:39 <aristid> the docs on hackage look different! omg
12:01:06 <tg_> style: ocean
12:01:10 <tg_> style: classic
12:14:42 <Nibble> what does lcm do?
12:14:53 <benmachine> lowest common multiple
12:15:05 <Nibble> oh
12:15:08 <kmc> > lcm 7 5
12:15:09 <lambdabot>   35
12:15:32 <kmc> > lcm 12 15
12:15:33 <lambdabot>   60
12:15:56 <aristid> > foldr lcm 1 [1..10]
12:15:56 <lambdabot>   2520
12:16:11 <Nibble> how the hell does this work
12:16:14 <Nibble> problem_5 = foldr1 lcm [1..20]
12:16:21 <Nibble> Am I not only giving lcm one parameter?
12:16:27 <benmachine> nope
12:16:31 <kmc> :t foldr1
12:16:32 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:16:41 <benmachine> > foldr1 f [a, b, c, d, e]
12:16:42 <lambdabot>   f a (f b (f c (f d e)))
12:16:46 <Nibble> oh
12:17:25 <benmachine> so you're basically getting (1 `lcm` 2 `lcm` 3 `lcm` 4 `lcm` ...)
12:17:40 <Nibble> I see
12:17:56 <kmc> lcm is associative and commutative so it doesn't even matter the order or how you group them
12:18:25 <kmc> in fact you could easily parallelize the task of "find lcm of these n numbers" to many cores
12:18:33 <kmc> (though it's annoying if the input is a list)
12:18:37 * BrianHV is impressed with lambdabot 
12:19:21 <benmachine> I once wrote a thing to concatenate a monoid list in parallel
12:19:47 <kmc> yeah
12:20:39 <kmc> the integers are a monoid with respect to lcm and 1, aren't they?
12:21:18 <kmc> also wrt gcd at 0
12:21:23 <kmc> gcd and 0 *
12:21:50 <Nibble> kmc: if I understand this correctly, for [1..] 1 `lcm` 2 ... 19 `lcm` 20
12:22:16 <DanielDiaz> kmc: well, lcm is closed, associative, and it has '1' as neutral
12:22:18 <kmc> benmachine, how did you balance the input? did you have to get the list length first then recursively subdivide it?
12:24:09 <kmc> i'm wondering how to turn a list into a balanced binary tree with the minimum number of traversals
12:24:17 <kmc> preserving the list ordering, not using BST ordering
12:25:06 <doofer> what to do with errors like these? cabal: cannot configure QuickCheck-2.2. It requires ghc -any
12:25:06 <doofer> There is no available version of ghc that satisfies -any
12:25:47 <benmachine> kmc: probably badly, I didn't think too hard about it :P
12:25:48 <dcoutts_> doofer: see ghc-pkg check, you've likely broken your ghc package
12:25:55 <benmachine> kmc: the core of it was
12:25:55 <benmachine> parconcat xs = parconcat $ reduce xs
12:25:55 <benmachine>  where reduce (x:y:ys) = let r = mappend x y in r `par` r : reduce ys
12:25:55 <benmachine>        reduce xs = xs
12:26:10 <kmc> oh
12:26:46 <benmachine> how does balancing improve it?
12:26:49 <doofer> dcoutts_: this is actually an error from a hackage log
12:26:52 <aristid> :t a
12:26:53 <lambdabot> Expr
12:27:08 <benmachine> actually nevermind I'm going to eat
12:27:13 <kmc> benmachine, hmm, so each pass through "reduce" halves the element count?
12:27:17 <benmachine> kmc: yes
12:27:21 <kmc> that's clever
12:27:28 <dcoutts_> doofer: oh well don't worry about that, the hackage builder goes wrong for lots of reasons.
12:27:36 <kmc> it might be as good as anything else
12:27:37 <benmachine> is it? it seemed the simplest thing :P
12:27:57 * benmachine food
12:28:40 <doofer> dcoutts_: alright, so it's not preventing the documentation from being generated or something like that?
12:29:15 <dcoutts_> doofer: it'll probably prevent that too yes, there's not a lot you can do about it.
12:29:26 <dcoutts_> doofer: the new hackage server will not suffer from the same problems.
12:29:43 <doofer> dcoutts_: ah, okay. :/
12:31:32 <Saizan> c.h.o down?
12:32:53 <djahandarie> Saizan, flip a coin
12:45:32 <JoeyA> I'm tinkering with the Haskell LLVM bindings, and simpleFunction isn't working properly, it seems:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29820#a29820
12:45:41 <JoeyA> Running it says:  hello-llvm: user error (Interpreter has not been linked in.)
12:46:14 <JoeyA> simpleFunction is for getting an IO action from a CodeGenModule
12:47:30 <JoeyA> The "interpreter has not been linked in" breaks other examples, such as:  http://www.mail-archive.com/haskell-cafe@haskell.org/msg50425.html
12:47:55 <wli> JoeyA: Somehow failing to specify /lib/ld.so?
12:48:22 <JoeyA> Here's how you solve it if you're programming in C, it seems:  http://comments.gmane.org/gmane.comp.compilers.llvm.devel/33877
12:48:41 <JoeyA> InitializeNativeTarget();
12:51:48 <aristid> JoeyA: that's C++, not C.
12:53:07 <JoeyA> oh
12:53:19 <tolkad> if haskell data types are analogous to Java objects, does haskell have something similar to non-static inner classes?
12:54:00 <mathijs> Hi all, I have a list of Either String MyData. if all is well, all elements are Right, but I wanna log possible errors just in case. I'm using (errors, goods) = partitionEithers myList. then I "take 10 goods". It takes a very long time (input list is very big). is partitionEithers strict in some way?
12:54:08 <tolkad> a new type is created with each instance of the class
12:57:37 <zachk> mathijs: not sure but strict functions usually are func' for the strict version 
12:58:03 <zachk> and usually they are only strict in some sense and still sort of lazy 
12:59:29 <JoeyA> take 5 $ fst $ partitionEithers (replicate 1000000 (Left 'x'))
12:59:31 <JoeyA> > take 5 $ fst $ partitionEithers (replicate 1000000 (Left 'x'))
12:59:32 <lambdabot>   "*Exception: stack overflow
12:59:36 <mathijs> yeah, thought so too. but I only take 10 "goods" and don't do anything with "errors" yet. I found that changing the length of the input list has an effect, so it seems to me that partitionEithers is going through it all.
12:59:48 <JoeyA> indeed, partitionEithers isn't as lazy as it ought to be.
12:59:55 <mathijs> :(
12:59:58 <mathijs> is that a bug?
13:00:16 <JoeyA> dunno; I gtg, later.
13:00:43 <mathijs> ok, anyone else? is this a bug which I should report somewhere?
13:00:57 <notabel> mathijs: i think there'a already a bug for it actually
13:01:27 <mathijs> notabel: do you have a link for that? maybe there are workarounds?
13:01:40 <notabel> for now you should probably just use rights and lefts
13:01:44 <zachk> :t partitionEithers 
13:01:45 <lambdabot> forall a b. [Either a b] -> ([a], [b])
13:01:56 <notabel> google it, or look in the ghc trac (but its search is subpar)
13:02:40 <mathijs> notabel: that will go through the list twice, which is unacceptable (the list is from a 10G file). 
13:02:44 <aristid> :t zipWith (cycle [Left,Right])
13:02:45 <lambdabot>     Couldn't match expected type `a -> b -> c'
13:02:46 <lambdabot>            against inferred type `[a1 -> Either a1 a1]'
13:02:46 <lambdabot>     In the first argument of `zipWith', namely `(cycle [Left, Right])'
13:02:48 <siracusa> mathijs: See http://hackage.haskell.org/trac/ghc/ticket/3709
13:02:52 <zachk> so you want all the good values in a list and you want all the errors in a list? 
13:02:55 <aristid> :t zipWith id (cycle [Left,Right])
13:02:56 <lambdabot> forall b. [b] -> [Either b b]
13:03:00 <mathijs> siracusa: thanks
13:03:15 <aristid> :t partitionEithers . zipWith id (cycle [Left,Right])
13:03:16 <lambdabot> forall b. [b] -> ([b], [b])
13:03:35 <basvandijk> Hello, in my usb package I need to convert an array (Ptr CUChar) containing Utf16LE encoded characters to a String. Currently I first convert it to a ByteString and then use "unpack ∘ decodeUtf16LE" from the text package to convert it to a String. Is there a more efficient and hopefully also shorter way of doing this?
13:03:48 <basvandijk> This is the function in question: http://hackage.haskell.org/packages/archive/usb/0.5.0.1/doc/html/src/System-USB-Internal.html#getStrDesc
13:04:07 <mathijs> zachk: yes I would like that, without traversing the input twice
13:04:47 <mathijs> siracusa: it looks as if that bug was fixed 9 months ago. strange. but I'll try the workaround there
13:05:43 <zachk> do you care about the order? 
13:05:57 <siracusa> mathijs: Yeah strange, do you use GHC 6.12?
13:06:14 <tolkad> if haskell data types are analogous to Java objects, does haskell have something similar to non-static inner classes?
13:06:40 <tolkad> I want to create a new type with each instance of another type
13:06:48 <mathijs> zachk: preferably I do (input is ordered), but I can order it on-the fly myself using a heap probably.
13:07:00 <mathijs> siracusa: yeah, 6.12.3
13:08:38 <tolkad> nevermind
13:10:24 <tab> is there any way to catch a "error" statement outside an IO monad ?
13:10:59 <tolkad> yes
13:11:06 <tolkad> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html
13:11:24 <tolkad> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#t%3AErrorCall
13:12:15 <tolkad> you can also safely remap it to some other exception without IO
13:13:11 <zachk> mathijs, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29821#a29821
13:13:22 <zachk> i hope that is what you are looking for 
13:13:31 * zachk is still a haskell noob though 
13:14:19 <tab> tolkad: ok for errorCall, but i'm still confuse, every "try/catch" construct seems to be in the IO monad
13:14:28 <Blkt> good evening everyone
13:14:31 <zachk> :t catch
13:14:32 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
13:14:42 <zachk> cause of its type tab 
13:15:03 <zachk> good evening Blkt , though its still daylight where im at 
13:15:14 <tolkad> tab: You can't catch them without IO but you can change one type of exception into another:
13:15:14 <tolkad> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v%3AmapException
13:15:25 <benmachine> tab: it's... technically possible, but usually not what you want, why do you want to?
13:15:53 <tab> alright that's what i was afraid of
13:16:03 <Nibble> @hoogle biggest prime
13:16:03 <lambdabot> No results found
13:16:07 <Nibble> @hoogle prime
13:16:07 <lambdabot> Data.HashTable prime :: Int32
13:16:07 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
13:16:07 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
13:16:07 <lambdabot> a
13:16:16 <tolkad> tab: If you're trying to catch ErrorCall exceptions you are probably trying to catch them from some specific operation, in which case you should mapException it as quickly as possible to avoid catching other ErrorCall exceptions later
13:16:18 <zachk> IOerrors are usually not something you want to deal with, try Maybe or Either instead
13:16:29 <mathijs> zachk: thanks, gonna try that
13:16:37 <zachk> its lazy
13:16:37 <tab> tolkad: the place where i want to catch it unforunately isn't in the IO monad
13:16:43 <benmachine> tab: it's much preferred to use types which have error information explicit in the type
13:16:55 <tab> benmachine: it's not my choice unfortunately
13:16:57 <zachk> if you need it strict look at the definition for foldl and the definition for foldl' in Data.List 
13:17:02 <tab> benmachine: the RSA package is using error when there's an error
13:17:11 <notabel> basvandijk: is Foreign.C.String's wide character support sufficient for you?  it's pretty limited (to what the C library provides)
13:17:16 <benmachine> tab: ah, okay
13:17:23 <benmachine> @hackage spoon
13:17:23 <lambdabot> http://hackage.haskell.org/package/spoon
13:17:26 <tolkad> tab: ooh that's annoying
13:17:33 <tab> benmachine: short of basically forking the RSA package, not much i can do then :(
13:17:43 <tab> that's a big security issue for me unfortunately
13:17:43 <benmachine> tab: no you can use the package I linked
13:17:48 <tolkad> tab: well... you could mapException it like I said
13:18:01 <benmachine> tolkad: that turns one exception into another, what use is that?
13:18:13 <tolkad> benmachine: avoiding catching all ErrorCalls from everywhere
13:18:21 <tolkad> benmachine: and just catching them from that library
13:18:28 <benmachine> oh I see what you mean
13:18:39 <benmachine> but you still have to catch them in IO in that case
13:18:43 <tolkad> yeah
13:19:02 <tab> unfortunately mapping exception is not my problem here
13:19:17 <tab> i guess the spoon package is more
13:19:29 <benmachine> the spoon package turns exceptions into Maybe
13:19:33 <benmachine> but it's impure technically
13:19:36 <tab> that's a bit unforunate it's using unsafePerformIO (which is exactly the same thing i though doing)
13:19:39 <benmachine> yes
13:19:53 <tab> i think short term i'll fork rsa :\
13:19:55 <mathijs> zachk: it works, even on infinite lists, thank!  I don't see what your reverse trick does, but maybe I need to re-read "tying the knot" :)
13:19:57 <benmachine> catching exceptions is inherently an IO operation
13:20:02 <tolkad> is spoon safe?
13:20:04 <tab> and return an Either
13:20:06 <benmachine> you can use unsafePerformIO safely in this case
13:20:12 <tab> like i usually do for everything that might fail
13:20:18 <benmachine> depending on what you mean by safely
13:20:24 <benmachine> it won't crash or anything
13:20:35 <benmachine> tab: complain to the maintainer
13:20:54 <tolkad> benmachine: safe means the behavior is dictated by the haskell standard and guaranteed to work across all implementations
13:21:22 <zachk> mathijs, i use a helper function to add an accumulator argument, kinda tail recursive... 
13:21:29 <benmachine> tolkad: ah, that kind of safe
13:21:40 <benmachine> tolkad: saying "portable" would have been more specific
13:21:54 <benmachine> tolkad: spoon is portable to wherever it compiles
13:22:02 <zachk> and i use cons (:) to append to the front of the list because its O(1) where appending to the end of the list is O(n) 
13:22:09 <benmachine> not sure where that is exactly
13:22:15 <benmachine> who uses non-GHC anyway :P
13:22:33 <zachk> and those those two reverses put together will just be one operation of O(n) 
13:22:54 <djahandarie> Probably the folks at Utrecht
13:23:03 <zachk> or York 
13:23:12 <benmachine> or John
13:25:09 <mathijs> zachk: hmm... doesn't seem to work on infinite lists though, I mis-tested :)
13:25:28 <tab> would probably be nice if the error function is removed altogether in next version of haskell :D
13:25:42 <mathijs> zachk: wanna show you what I changed, but hpaste seems broken now
13:26:44 <Martty> > error "tab hates me"
13:26:45 <lambdabot>   *Exception: tab hates me
13:26:54 <mathijs> zachk: http://gist.github.com/570775
13:27:15 <McManiaC> hmhmhm
13:27:19 <McManiaC> viewpatterns are pretty cool
13:27:28 <djahandarie> tab, but how will we fix error?
13:27:30 <mathijs> zachk: but don't bother... it seems the fix for partitionEithers described in the bugreport works
13:27:45 <McManiaC> case second decode curlresult of (CurlOK, Ok (JSObject (toStory->Ok (toCount->Ok s)))) -> do ...
13:27:48 <McManiaC> :)
13:27:49 <djahandarie> > fix error
13:27:49 <tab> djahandarie: force everyone to use either or an error monad ?
13:27:50 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:28:12 <c_wraith> tab: that's not really good enough.  There are cases where having a total function adds nothing.
13:28:23 <benmachine> tab: sometimes you can't prove a function is total
13:28:29 <benmachine> and you need an undefined branch to plug the gap
13:28:31 <notabel> djahandarie: if we eliminated error, we'd have to introduce a new primitive with which to define undefined
13:28:38 <benmachine> if you don't have error you will have let x = x in x there instead
13:29:04 <c_wraith> really, I think the problem is the name "error" sounds too much like an error-handling mechanism
13:29:56 <Martty> define undefined what a paradox
13:29:56 <c_wraith> And it isn't part of an error-handling mechanism.  Instead, it's a signaling mechanism that runtime preconditions of the code weren't met.
13:31:09 <tab> the error function is not really the problem i guess here
13:31:36 <tab> it's more the library user that use it in pure code, for normal error handling
13:31:40 <benmachine> yeah
13:32:34 <kylet> test
13:32:42 <Zao> kylet: GREAT SUCCESS!
13:32:53 <kylet> This site is great
13:34:13 <tab> binary got the same problem actually
13:34:25 <benmachine> Martty: what's the use of defining anything else? :P
13:35:45 <zachk> kylet, what site? 
13:35:52 <djahandarie> tryhaskell I assume :)
13:36:05 <int80_h> good day everyone
13:36:08 <Martty> benmachine: none! its already defined
13:36:19 <byorgey> good day int80_h 
13:36:26 <benmachine> well quite
13:36:28 <int80_h> brb
13:36:39 * hackagebot darcs-monitor 0.4.0 - Darcs repository monitor (sends email)  http://hackage.haskell.org/package/darcs-monitor-0.4.0 (MarcoSilva)
13:38:04 <int80_h> well I just recieved a verbal offer of employment at a network applications company, as Systems Tools Guy. And there is lots of room for Haskell.
13:38:16 <benmachine> int80_h: neat!
13:38:24 <int80_h> I'm waiting on my hands for that formal offer letter.
13:38:25 <benmachine> I hope I, too, can one day get a job title ending in Guy
13:39:21 <djahandarie> benmachine, I'm offering you the position Manly Man Guy of #haskell.... will you accept?
13:39:28 <int80_h> I've been investigating what it takes to write program generators. I'll need to write alot of scripts, so I will be looking into writing an application that writes those scripts.
13:39:39 <basvandijk> notabel: thanks for reminding me of Foreign.C.String, I will look into it
13:40:09 <wli> Congratulations. Not like I'll ever see anything of the sort.
13:40:24 <benmachine> djahandarie: I'm not confident that I'm qualified for the part :P
13:40:30 <benmachine> I mean, man yes, manly notsomuch
13:40:30 <int80_h> nonsense, I'm a total newb. If I can do it anyone can.
13:40:39 <notabel> basvandijk: another option would be casting through bytestring to CompactString to String.  i don't think that would do any unnecessary work
13:42:27 <djahandarie> benmachine, well thankfully you're only competing with lambdabot and well... she isn't a man... or human
13:42:40 <benmachine> djahandarie: then I'll take it!
13:43:14 <djahandarie> Alright, your first task is to answer every question in the next 24 hours without burning out... for free!!!!!!!!!!
13:43:19 * djahandarie cackles and runs
13:44:25 * benmachine burns out
13:44:26 <benmachine> whoops!
13:44:42 <djahandarie> Well that was short-lived
13:44:46 <benmachine> @faq can haskell do my job instead?
13:44:46 <lambdabot> The answer is: Yes! Haskell can do that.
13:45:01 <zc00gii> uh, in ghci, is it possible to do something like foo :: (Integral a) => a -> String?
13:45:02 <benmachine> I appear to have lost a manly-man competition to an entity who is neither :(
13:45:27 <benmachine> zc00gii: erm, what do you mean
13:45:36 <djahandarie> @vixen You are pretty manly, aren't you
13:45:36 <lambdabot> hahaha.
13:45:43 <djahandarie> -_-
13:45:51 <zc00gii> benmachine: obviously it doesn't work without a let or with one
13:46:19 <benmachine> zc00gii: you want to define a function with a type signature in ghci?
13:46:20 <basvandijk> notabel: Whats a CompactString? (Hoogle doesn't know it and Hayoo seems to be down)
13:46:25 <zc00gii> Prelude> foo :: (Integral a) => a -> string
13:46:26 <zc00gii> <interactive>:1:0: Not in scope: `foo'
13:46:26 <zc00gii> Prelude> let foo :: (Integral a) => a -> string
13:46:28 <notabel> zc00gii: yeah, there are plenty of functions like that.  the show functions in Numeric for instance
13:46:30 <zc00gii> <interactive>:1:4: Not in scope: `foo'
13:46:35 <zc00gii> yeah
13:46:46 <benmachine> zc00gii: try, let foo :: type; foo args = val
13:46:59 <benmachine> zc00gii: you have to define the type and the function at the same time
13:47:21 <notabel> basvandijk: compactstrings are bytestrings in a given encoding.  unlike Data.Text, Data.CompactString works in the string's native encoding rather than converting to a canonical encoding
13:47:41 <benmachine> zc00gii: generally speaking it's easier to define stuff in a file and then load it; you can edit it at any time with :e and then reload it with :r
13:48:23 <basvandijk> notabel: thanks, from which package comes that module?
13:48:43 <wli> hbi-like functionality for defining types (and classes?) at the interpreter prompt would be nice. I tried at one point and failed.
13:49:03 <zc00gii> benmachine: is it possible to define another form of said function?
13:49:15 <benmachine> zc00gii: you mean, multiple equations?
13:49:19 <zc00gii> in ghci?
13:49:20 <zc00gii> yeah
13:49:26 <benmachine> all on the same line
13:49:35 <zc00gii> what about afterwards?
13:49:40 <benmachine> nope
13:49:42 <benmachine> well
13:49:46 <benmachine> you can redefine it
13:49:53 <benmachine> but you can't add equations to an existing function
13:49:55 * basvandijk back in 10 minutes
13:50:23 <zc00gii> mm, ok
13:50:51 <benmachine> woah, for a moment there I reread scrollback and thought "why did I say I'd be back in ten minutes"
13:50:56 <zc00gii> any emacs users use sml-mode?
13:51:04 <benmachine> I've done confusing people's names before but never with my own >_>
13:51:36 <zc00gii> benmachine: lol
13:53:35 <zc00gii> *Main> :e scratch
13:53:36 <zc00gii> Received SIGHUP or SIGTERM
13:53:36 <zc00gii>  
13:53:41 <zc00gii> having issues with :e :|
13:59:32 <Twey> benmachine: There's a guy in #jbopre called ‘Tene’.  I get us mixed up all the time.
14:04:35 <benmachine> zc00gii: try :set editor something?
14:04:36 <mathijs> I'm confused. will the next ghc be 7.0 ? no more 6.14 ?
14:04:36 <int80_h> lovely
14:04:36 <int80_h> infinite type error about to be posted
14:04:36 <int80_h> crap, hpaste is down again
14:04:36 <yrlnry> Is that ((infinite type) error) or (infinite (type error))?
14:04:36 <yrlnry> If the latter, please use the pastebin.
14:04:36 <int80_h> pastebin is taking long time to render
14:04:36 <int80_h> I'm trying to use pastebin.com, and it's failing. Any alternatives you guys like?
14:04:36 <dom96> gist it
14:05:58 <tab> mathijs: yes correct
14:06:49 <mathijs> tab: ok, so that sounds like a big milestone. any special reasons why the major version got increased? does it have to do with the haskell2010 standard?
14:07:52 <tab> mathijs: a new type system, llvm backend, new event system, .. seems to be the reason
14:08:02 <revenantphx> what's llvm backed now?
14:08:45 <int80_h> http://gist.github.com/570832
14:08:47 * revenantphx looks up hs2010 standard...
14:08:52 <mathijs> tab: where can I read about the new type and event systems? I did see some llvm stuff already
14:08:55 <revenantphx> oh thank god, n-plus-k is banned.
14:09:17 <pumpkin> I'd like n+k patterns on naturals, but there's no naturals
14:09:33 <revenantphx> whats new copumpkin?
14:09:34 <int80_h> if they ban it, the criminal underground will just figure out a way to profit.
14:09:39 <copumpkin> not much
14:10:24 <revenantphx> n+k confused me a bit
14:10:33 <revenantphx> so if you match "10" with (n+5), then n is 5?
14:10:55 <benmachine> yes
14:11:00 <tab> mathijs: i can't find the link anymore
14:11:14 <tab> mathijs: i think i found it on reddit haskell in the first place
14:12:15 <mathijs> tab: ok, I'll browse a bit then :)   any timeframe for 7.0?
14:14:52 <benmachine> mathijs: I heard a few weeks, but I'd consider that rumour
14:15:15 <mathijs> ah, just before duke nukem forever
14:16:08 <benmachine> nah, GHC is pretty version-mobile
14:16:12 <int80_h> http://gist.github.com/570832
14:16:48 <benmachine> in other news http://www.reddit.com/r/haskell/comments/dad6j/unless_theres_a_major_hiccup_itll_be_in_ghc_70/
14:16:54 <benmachine> that is to say
14:16:56 <benmachine> in the same news
14:17:15 <Heffalump> they usually target it for ICFP (which is in a few weeks) and miss by a month or two.
14:17:20 <benmachine> mathijs: "We'll produce a release candidate just before ICFP.
14:17:21 <benmachine> "
14:18:44 <mathijs> benmachine: ok, that's a nice commitment :)   
14:19:35 <int80_h> oh crap!
14:20:13 <benmachine> int80_h: oh!
14:20:15 <benmachine> what?
14:20:23 <Heffalump> I don't wish to be negative, and I might be misremembering, but I think they say that every year but often don't quite make it
14:20:32 <int80_h> benmachine: I forgot to include the actual error
14:20:41 <int80_h> http://gist.github.com/570832
14:20:47 <Heffalump> I certainly prefer them getting it right to working to a specific deadline, though.
14:21:46 <benmachine> int80_h: arguments of dealWithTable are backwards?
14:22:20 <mathijs> Heffalump: for a RC I don't mind that much.  And I don't mind some stuff not being included, as long as everything that is included just works as it should
14:22:49 <Heffalump> you mean you don't mind stuff that will be in the release not being included?
14:23:00 <Heffalump> or that you don't mind stuff being bumped to the next release?
14:23:12 <int80_h> benmachine: it's been about a week since I last looked at this code. And, when I last looked at it, I now remember I was suspicious of the argument order. Then, today, I forgot all about my initial suspicions.
14:23:22 <int80_h> but it compiles fine now
14:23:24 <benmachine> :)
14:23:26 <Igloo> Heffalump: In the past few years it's always been "RC before, release shortly after", although sometime it's shorter than others
14:23:58 <Igloo> The rationale being that making a release just before all the developers disappear for a couple of weeks isn't the best plan  :-)
14:24:20 <Heffalump> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-October/017800.html # really?
14:25:58 <Igloo> Heffalump: it == the plan  :-)
14:26:48 <saml> hey, how do you do Tree?
14:26:54 <saml> multi tree. not binary tree
14:27:11 <mauke> :t Tree
14:27:12 <lambdabot> Not in scope: data constructor `Tree'
14:27:15 <byorgey> saml: look in Data.Tree, in the containers package
14:27:16 <mauke> :t Node
14:27:16 <lambdabot> forall a. a -> Forest a -> Tree a
14:27:35 <mauke> > Node 42 []
14:27:35 <lambdabot>   Node {rootLabel = 42, subForest = []}
14:27:59 <saml> ah, so i keep branches as list
14:28:18 <Heffalump> Igloo: right. I was just saying that the announced plan should be treated with an appropriate degree of skepticism :-)
14:28:48 <Igloo> Ah, fair enough, then
14:28:51 <mauke> http://quotes.burntelectrons.org/591
14:28:55 <mm_freak> i've just written a CPS-based state monad, but the usual state monad isn't written in CPS…  is there a reason for that?
14:29:18 <aristid> mm_freak: maybe just that the usual state monad is simpler the way it is?
14:29:25 <Zao> I can't wrap my head around vector-space. Is there some simpler library for game-type linear algebra?
14:29:36 <Zao> Preferably with functions for constructing the usual set of matrices?
14:29:47 <mm_freak> aristid: the CPS stuff is opaque, so there is no difference for the user of the monad
14:30:27 <mm_freak> also personally i found the CPS-based state easier to write than the usual one
14:30:48 <benmachine> was there ever a 6.12.0?
14:30:51 <mm_freak> and it gives you one really handy function:  abort
14:30:54 <DanielDiaz> Hi, I have seen several SMTP clients in Hackage, what you recommend me?
14:31:06 <aristid> mm_freak: there's anything complex about the standard mtl State?
14:31:45 <mm_freak> aristid: no, but firstly i've read that CPS gives you a speedup, and secondly i often need to abort stateful computations
14:31:55 <benmachine> DanielDiaz: if all else fails, you could check which has the most reverse dependencies on http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
14:32:07 <mm_freak> so i often end up with transformer stacks including ContT and StateT
14:32:16 <roconnor> mm_freak: is CPS-state as lasy as the regulat state monad?
14:32:23 <roconnor> lazy
14:32:25 <mm_freak> roconnor: i'll try
14:32:34 <Heffalump> anyway, I'm always happy to have any GHC release at all :-)
14:33:22 <DanielDiaz> benmachine: the quality of a package is measured by the number of reverse dependencies?
14:33:38 <notabel> benmachine: the googles attest to a 6.12.0
14:33:52 <benmachine> DanielDiaz: no, hence if all else fails
14:34:16 <benmachine> DanielDiaz: but generally speaking, well-used packages will be well-supported, and vice versa
14:34:41 <benmachine> DanielDiaz: I just felt like giving you a last alternative in case no-one else here had done any SMTP work :)
14:34:52 <mm_freak> roconnor: do you have a code snippet to get it?
14:35:02 <benmachine> DanielDiaz: alternatively, you could email some of the people who use those packages
14:35:02 <mm_freak> get → test
14:35:12 <roconnor> mm_freak: let me think
14:35:14 <aristid> didn't somebody here talk about GF recently?
14:35:16 <benmachine> DanielDiaz: or just see some examples of the package being used, all of these are useful things
14:35:32 <roconnor> @type runState
14:35:33 <lambdabot> forall s a. State s a -> s -> (a, s)
14:35:42 <mm_freak> > let c = c >> modify (0:) in execState c []
14:35:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:35:53 <mm_freak> ok, that one doesn't work with CPS-state
14:36:09 <mm_freak> let me paste the code, maybe someone knows how to solve it
14:36:12 <roconnor> so there is one reason ... I guess
14:36:16 <roconnor> :)
14:36:17 <DanielDiaz> benmachine, thank you very much :)
14:36:41 <roconnor> mm_freak: CPS evaluation order confuses me.  I have no idea what laziness is or is not possible
14:36:49 <dmwit> > inits []
14:36:50 <lambdabot>   [[]]
14:36:52 <DanielDiaz> benmachine: I will test some packages
14:36:54 <mm_freak> http://codepad.org/gMI9XGVM
14:36:54 <dmwit> > inits undefined
14:36:55 <lambdabot>   *Exception: Prelude.undefined
14:37:19 <dmwit> > let inits xs = []:case xs of [] -> []; (y:ys) -> map (y:) (inits ys) in inits undefined
14:37:20 <lambdabot>   [[]*Exception: Prelude.undefined
14:37:30 <dmwit> Should this be fixed...?
14:37:38 <roconnor> dmwit: maybe
14:37:48 <benmachine> > inits [1]
14:37:49 <lambdabot>   [[],[1]]
14:37:50 <roconnor> dmwit: fix intersperse while you are at it
14:37:57 <roconnor> > fix intersperse
14:37:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a] -> [a]
14:38:04 <dmwit> I will put a bug on my tracker. =)
14:38:30 <dmwit> :t intersperse
14:38:31 <lambdabot> forall a. a -> [a] -> [a]
14:38:37 <dmwit> > fix (intersperse 'a')
14:38:41 <lambdabot>   mueval-core: Time limit exceeded
14:38:49 <roconnor> mm_freak: I'm not even convinced you have much of a choice when implementing those signatures
14:39:06 <aristid> :t fix . intersperse
14:39:07 <lambdabot> forall a. a -> [a]
14:39:12 <mm_freak> roconnor: well, i got an idea…  let me try it
14:39:43 <mm_freak> hmm, no
14:40:07 <dmwit> I don't see how fix (intersperse 'a') could become a real thing.
14:40:49 <copumpkin> > fix (interleave ['a'..]
14:40:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:40:52 <copumpkin> > fix (interleave ['a'..])
14:40:53 <lambdabot>   "aabacbdaecfbgdhaiejckflbmgndohpaqiresjtcukvfwlxbymzg{n|d}o~h\DELp\128a\129...
14:41:02 <dmwit> > intersperse 'a' '(b':undefined)
14:41:03 <lambdabot>   <no location info>:
14:41:03 <lambdabot>      lexical error in string/character literal at chara...
14:41:08 <dmwit> > intersperse 'a' ('b':undefined)
14:41:09 <lambdabot>   "*Exception: Prelude.undefined
14:41:15 <dmwit> whoops
14:41:18 <dmwit> That's no good.
14:41:29 <mm_freak> roconnor: but actually in most cases that additional strictness comes to my advantage
14:41:43 <roconnor> mm_freak: oh yes
14:41:46 <mm_freak> roconnor: i remember having memory leaks with StateT s IO
14:41:53 <roconnor> mm_freak: I'm not saying this is bad
14:42:05 <roconnor> mm_freak: just trying to give a reason why the default State monad is what it is
14:42:30 <mm_freak> yeah…  maybe i should write a CPS-based monad transformer library
14:42:31 <roconnor> mm_freak: most of the the CPS transformed monads are kick ass
14:42:42 <roconnor> mm_freak: edwardk has written one
14:42:47 <mm_freak> roconnor: where is it?
14:43:03 <roconnor> category-extras
14:43:14 <Saizan> monad-ran, actually
14:43:28 <roconnor> oh
14:43:28 <mm_freak> oh god…  category-extras makes my head explode
14:43:29 <roconnor> ok
14:43:32 <Saizan> category-extras has Codensity though
14:43:47 <roconnor> Saizan: I didn't realize it was in a separate package
14:43:57 <mm_freak> Saizan: does it have similar features to monadLib?
14:44:06 <roconnor> mm_freak: IIRC it uses type families to build an optmized CPS type
14:44:07 <mm_freak> like not having to lift too much, etc.
14:45:16 <mm_freak> hmm…  that one builds on the mtl
14:45:17 <mm_freak> =/
14:45:26 <roconnor> mm_freak: I don't recall if monad-ran was practical or simply theoretical
14:46:01 <mm_freak> roconnor: well, it looks complicated to someone with little CT experience
14:47:14 <mm_freak> in fact from the interface alone i have no idea how it works
14:49:53 <mm_freak> WOW…  GHC 6.12.3 is FAST
14:50:25 <mm_freak> i just compiled category-extras and couldn't follow the terminal output…  older versions were much slower
14:50:47 <benmachine> it might be that category-extras stopped optimising or something
14:52:26 <mm_freak> it's faster with other packages, too
14:52:43 <mm_freak> anyway…  where can i learn what Codensity is?
14:52:49 <zc00gii> ........................whoa
14:52:55 <zc00gii> haskell-mode is awesome in emacs
14:53:06 <zc00gii> it's got something comparable to slime ffs!
14:53:45 <zc00gii> sure, not nearly as powerful as slime...but slime is just that, slime, can't beat slime. Closest thing I've seen though
14:54:44 <lispy> zc00gii: what does it have that is comparable to slime?
14:55:00 <lispy> One thing I can't stand about emacs haskell mode is that indent is completely broken
14:55:01 <zc00gii> lispy: well, a slime-repl-ish thing
14:55:11 <zc00gii> lispy: oh! there are several indentation modes
14:55:24 <mm_freak> lispy: why?  i'm using haskell-mode and its indentation works fine for me
14:55:39 <zc00gii> lispy: it's got a click thing if it errors and it goes to that line
14:55:48 <lispy> I just want indent to mean 2 spaces, but none of the modes support that.  Instead they all have broken variants of trying (and failing) line things up
14:55:49 <zc00gii> C-c C-l is like C-c C-k
14:56:17 <mm_freak> lispy: i'm using two spaces, too, and it works well
14:56:34 <zc00gii> there is no C-c though, then again, haskell doesn't have sexps, and it'd be hard to make something that can interpret different bounds
14:56:39 <zc00gii> C-c C-c
14:56:41 <zc00gii> er
14:56:42 <lispy> mm_freak: what haskell indentation mode do you use?  I've tried them all at some point
14:56:47 <mm_freak> it has only one bug, which really sucks:  it uses the right-mode do, not the innermost one
14:56:56 <mm_freak> lispy: the default one…  let me look
14:57:18 <zc00gii> is it just me, or do you have funky looking periods?....
14:57:34 <zc00gii> … ahh it's a single character
14:57:42 <mm_freak> how do i show the indentation mode?
14:57:57 <zc00gii> mm_freak: no clue
14:57:58 <mm_freak> zc00gii: i'm using a real ellipsis
14:57:59 <lispy> mm_freak: search your .emacs for haskell-mode-hook?
14:58:10 <lispy> that's how I set it
14:58:18 <copumpkin> can I have an impredicative GADT with data Moo :: * -> * where Zomg :: Moo Int; WTF :: Moo (forall a. a) ?
14:58:21 <mm_freak> lispy: turn-on-haskell-indent
14:58:56 <monochrom> Example of emacs haskell-mode indent. Notice that it is "indent means 2 spaces" for the most part, in fact iff I want it to. http://pastebin.com/Q0mhWEid
14:59:28 <lispy> mm_freak: that does not indent 2 space
14:59:37 <aristid> copumpkin: is "impredicative" the new favorite word?
14:59:48 <copumpkin> aristid: not really
14:59:56 <copumpkin> just curious if it allowed that
14:59:57 <mm_freak> lispy: it does, unless you have a lambda, which is further indented or something
15:00:06 <monochrom> (Of course people will pretend they never see it because I don't mention their names.)
15:00:07 <mm_freak> if you have:  abc (\x y z ->
15:00:10 <lispy> mm_freak: yeah, it's totally broken :(
15:00:11 <zc00gii> give me code to indent
15:00:14 <aristid> copumpkin: just seen it a few times recently, and no idea what it means.
15:00:17 <zc00gii> I'm using indentation
15:00:20 <mm_freak> then it will indent to two spaces after the \
15:00:21 <zc00gii> there is also indent and simple-indent
15:00:28 <monochrom> (Thus, they will continue to spread 10-year-old myths despite reality has changed.)
15:00:33 <mm_freak> lispy: or one could say your layout is broken =)
15:00:40 <lispy> monochrom: how is that a haskell-mode?  look like a random snippet of haskell code
15:00:50 <copumpkin> aristid: it means you describe something in terms of itself, or in sets, that you can have a set of all sets
15:01:13 <mm_freak> the following is wrong IMO:
15:01:14 <Saizan> copumpkin: Illegal polymorphic or qualified type: forall a. a
15:01:18 <mm_freak> abc def (\x y ->
15:01:21 <mm_freak>   modeCode)
15:01:26 <aristid> copumpkin: ENOTUNDERSTOOD.
15:01:27 <monochrom> I am showing you the result of automatic indentation. Do you understand that?
15:01:27 <copumpkin> Saizan: damn :) thanks for trying
15:01:34 <copumpkin> aristid: you know russell's paradox?
15:01:40 <Cale> Use a $ before the lambda instead
15:01:46 <Cale> abc def $ \x y ->
15:01:49 <Cale>   moreCode x y
15:01:49 <aristid> copumpkin: is that the one that there can't be a set of sets?
15:02:03 <copumpkin> aristid: the set of sets that don't contain themselves
15:02:11 <lispy> monochrom: Showing me a random snippet of haskell isn't so useful
15:02:21 <lispy> monochrom: do you have an emacs haskell-mode that indents correctly?
15:02:27 <monochrom> Yes.
15:02:34 <lispy> monochrom: will you share it please
15:02:39 <mm_freak> Cale: it's not /wrong/, but it looks wrong to me…  you don't need the $
15:02:43 <aristid> copumpkin: and haskell allows you to do it anyways?
15:03:03 <copumpkin> aristid: well in haskell terms, it's polymorphic polymorphism :P
15:03:12 <copumpkin> aristid: that is, your polymorphic type variable gets instantiated to a polymorphic value
15:03:22 <copumpkin> like Maybe (forall a. a)
15:03:25 <revenantphx> copumpkin: want to see one of the most disturbing lines of code ever?
15:03:31 <revenantphx> class MyRubyClass < NSObject
15:03:40 <revenantphx> it's horrifying and beautiful, at the same time.
15:03:51 <copumpkin> aristid: you have `Maybe a` normally, and in the above definition, you're instantiating the `a` type variable to (forall a. a)
15:03:53 <revenantphx> *shivers*
15:04:01 <copumpkin> revenantphx: lol, macruby?
15:04:08 <monochrom> lispy: Do you agree that my paste is the kind of indentation result you agree with? And therefore when I tell you the URL of the emacs code that produces the indentation, you will stop calling it broken?
15:04:10 <lispy> I'm using version 2.7.0 BTW.  Maybe it's too old?
15:04:14 <revenantphx> rubycocoa, but yes
15:04:14 <revenantphx> its been very much simplified
15:04:27 <lispy> monochrom: it's closer to what I want
15:04:47 <lispy> But I won't know if its still broken until I try it
15:04:48 <aristid> copumpkin: ok that does sound a bit crazy.
15:05:24 <monochrom> Then it is http://projects.haskell.org/haskellmode-emacs/haskell-mode-2.8.0.tar.gz from http://projects.haskell.org/haskellmode-emacs/
15:05:48 <copumpkin> aristid: it's sort of analogous to rank-n types for non-functions
15:06:22 <monochrom> 2.7.0 would produce the exact same result AFAIK
15:06:34 <copumpkin> revenantphx: oh, I thought rubycocoa was being superseded by macruby
15:06:35 <monochrom> and neither is broken.
15:07:13 <jmcarthur> i just sat down and tried to seriously use she to simulate some dependent types, but it's still too annoying :\
15:07:15 <lispy> monochrom: what indent mode do you use?
15:07:18 <aristid> copumpkin: what kind of stuff can you do with that?
15:07:26 <monochrom> It is "2 spaces" exact where I want it, and "line up" exactly where I want it. Nothing broken.
15:07:49 <monochrom> (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
15:07:59 <mathijs> is there an easy trick to remember how "deep" rwhnf is? would rwhnf on a list of "Either x y" dive deep enough to resolve Left or Right?
15:08:52 <benmachine> rwhnf is basically as little evaluation as possible
15:08:58 <benmachine> so yes, Left or Right
15:09:03 <benmachine> or _|_!
15:09:24 <benmachine> err
15:09:25 <benmachine> wait
15:09:25 <copumpkin> aristid: I dunno, you could write a function f :: Maybe (forall a. Num a => a) -> Maybe (Double, Int); f (Just n) = Just (n, n); f Nothing = Nothing
15:09:26 <benmachine> a list
15:09:26 <benmachine> no
15:09:36 <mathijs> benmachine: but for a list of Eithers, it would just reduce till the list constructor?
15:09:36 <benmachine> rwhnf on a list gets you, is the list empty
15:09:39 <lispy> monochrom: oh, that indents reasonably but breaks the enter and backspace functionality.
15:09:45 <benmachine> or is it head : tail
15:09:45 <mathijs> benmachine: ok
15:09:53 <lispy> monochrom: it's actually more frustrating that just using spaces to get where you want.
15:09:55 <copumpkin> aristid: it's getting removed in the next version of GHC unless the new typechecker has somehow made it easier to implement
15:10:17 <aristid> copumpkin: sounds like it isn't used widely
15:10:31 <monochrom> I agree to disagree. The enter key and backspace keys saves me work 99% of the time.
15:10:32 <copumpkin> yeah, I've never had much of a need for it
15:10:48 <copumpkin> aristid: and unlike rank-n types you can always emulate it with a wrapper type
15:10:57 <lispy> monochrom: except that you press enter, the cursor is at the wrong column, you hit backspace and you're on the previous line.
15:11:02 <mathijs> benmachine: but using parListChunk it will work I guess, since it will apply the strategy to all elements
15:11:12 <lispy> monochrom: So then you have to hit C-a, got to begining of line, hit space a whole bunch
15:11:30 <benmachine> mathijs: sounds reasonable yes
15:11:35 <monochrom> I cannot reproduce your problem.
15:12:37 <monochrom> Yes, sometimes enter goes to a wrong column. But afterwards, backspace eventually goes to the right column if it's on the left, tab eventually goes to the right column if it's on the right.
15:13:04 <lispy> maybe that's something they fixed since 2.7 where I used that mode
15:13:38 <monochrom> alternatively, just hit tab more times, it will wrap around to the left again.
15:14:27 <monochrom> My paste is resulted from very little human intervention. Perhaps none.
15:15:38 <lispy> monochrom: when I use this indentation mode, hitting tab does nothing.  Hitting backspace moves to previous line.
15:15:53 <monochrom> I cannot reproduce your problem.
15:16:17 <lispy> foo =<RET><TAB>
15:16:19 <lispy> that tab does nothing
15:17:03 <lispy> data Foo = Bar { blah :: Baz<ENTER>
15:17:07 <monochrom> because it is a case of "indent means 2 spaces" which is what you enshrine so.
15:17:14 <lispy> now cursor is in the wrong place and tab does nothing.  Backspace is previous line
15:17:39 <lispy> cursor should be in same column as "{"
15:17:53 <monochrom> <,><tab>
15:18:16 <monochrom> the whole thing: data Foo = Bar { blah :: Baz<ENTER><,><TAB>  see what happens
15:19:21 <monochrom> without comma, God knows whether you just want to split the lengthy type signature "Baz State IO ContT r a" into several lines
15:19:57 <lispy> Okay, typing a comma can get me there, but why is backspace broken to begin with?
15:21:00 <monochrom> without seeing comma, there is no other correct cursor position
15:21:38 <Saizan> (so i guess there are still two indentation modes in haskell-mode? mine behaves quite differently)
15:21:42 <lispy> What does that have to do with backspace?
15:23:05 <mee> Saizan: there are 3, and they may have changed between versions, yeah
15:23:10 <monochrom> backspace eats enough spaces to get to other correct positions to the left. if there is none, eat more to go to the previous line. that's its semantics. eat chunks of spaces.
15:23:39 <lispy> monochrom: Another thing I don't get wrt to backspace.  Say I'm done defining a funciton.  I press enter to create a new function.  It keeps indenting.  backspace is previous line.
15:24:01 <lispy> that should be a different character like C-backspace
15:24:59 <monochrom> I cannot reproduce that problem for either top-level or where-block
15:25:29 <monochrom> in where-block, after enter, it indents yes. backspace brings me to column 1 correctly.
15:25:51 <lispy> foo = bar
15:25:51 <lispy>   where blah = baz
15:26:03 <monochrom> yes I have just exactly tested that.
15:26:04 <lispy> when I press enter after baz, it insists to put me alinged with blah
15:26:48 <lispy> What I'd like, is for tab = insert 2 spaces.
15:26:55 <lispy> backspace = deleted 1 character
15:26:59 <lispy> Problem solved.
15:27:39 <lispy> None of this stuff that breaks in every context
15:27:53 * lispy has to get back to work
15:28:42 <monochrom> Falsehood. Maybe breaks in some context I haven't run into. But demonstratably not every context.
15:29:51 <monochrom> It does the right thing in 99% of contexts. With typing some extra token like comma and tab again, 99.99%.
15:30:53 <lispy> I must be doing that  .01% for everything I do then
15:31:17 <monochrom> Your last reported problem cannot be reproduced.
15:31:22 <tab> monochrom: please don't hit me
15:31:45 <geheimdienst> tab, if you cause any more trouble, you'll be banned
15:31:49 * monochrom gently touches tab, is that better?
15:32:06 <tab> monochrom: yes
15:32:11 <lispy> monochrom: Heh.  By you.
15:32:18 <tab> geheimdienst: ahem ?
15:32:51 <geheimdienst> j/k ;-)
15:33:24 <monochrom> Seriously, when I press <backspace> there, it goes to column 1 not previous line.
15:34:18 <mathijs> how can I tell in my cabal package that I would like my executable built with --threaded ?
15:34:21 <tab> geheimdienst: don't ban the tab, the space bar might be seriously abused afterwards ;)
15:35:42 <monochrom> My understanding is most people customize their .emacs to change key bindings crazily and it may interfere with otherwise perfectly fine electric-backspace etc. I don't have any such craziness. My default theory is crazy customization.
15:36:09 <sproingie> one way to find out, rename .emacs and restart
15:37:20 * geheimdienst in his day had to use a backspace that was driven by a donkey. no fancy electric backspaces like what you whippersnappers have today.
15:38:26 <Saizan> mathijs: ghc-options: -threaded
15:40:11 <mathijs> Saizan: thanks. and is there a way to have the binaries use all cores automatically, without using +RTS -N on every invocation?
15:41:18 <monochrom> (yes. disable all cores except 1. end of mathematician's answer)
15:41:28 <mathijs> hehehe
15:41:41 <geheimdienst> @slap monochrom
15:41:41 * lambdabot moulds monochrom into a delicous cookie, and places it in her oven
15:41:53 <blackh> mathijs: char *ghc_rts_opts = "-N";   <-- add that to a c file and add it to your cabal project.
15:41:54 * monochrom is now in cooked mode
15:42:43 * hackagebot PrimitiveArray 0.0.2.2 - Unboxed, multidimensional arrays based on the primitive  package.  http://hackage.haskell.org/package/PrimitiveArray-0.0.2.2 (ChristianHoener)
15:43:03 <geheimdienst> SophisticatedArray
15:43:07 <geheimdienst> CivilizedArray
15:44:00 <monochrom> PreHistoricArray
15:45:21 <sproingie> SavageArray
15:45:56 <mathijs> blackh: compile with gcc first or will cabal handle that?
15:45:57 <bss03> SabertoothArray
15:46:19 <sproingie> WoolyArray
15:46:20 <geheimdienst> StoneAgeArray
15:46:35 <benmachine> man has been using iron since the stone age
15:46:38 <bss03> JurasicArray
15:47:08 <geheimdienst> benmachine, so it stands to reason that man has been using stones since the iron age
15:47:08 <blackh> mathijs: Cabal will compile it for you if you add it to c-sources:  Also ghc will compile it if you just pass it on the command line
15:47:15 <monochrom> 10000BCArray - oops, illegal identifier
15:47:23 <benmachine> geheimdienst: mm
15:47:23 <mathijs> blackh: nice, thanks
15:47:41 <sproingie> saw 2012 just the other day
15:47:47 <sproingie> man what a mountain of cheese
15:47:50 <blackh> mathijs: Also you can verify it works by hacking it to have an illegal RTS option, then you'll get an error when you run it. :)
15:48:01 <mathijs> nice trick
15:48:34 <bss03> YearOneArray
15:48:52 <geheimdienst> bss03, arrays are zero-based, not one-based
15:49:11 <monochrom> this one is one-based
15:49:15 * Zao pets Ix.
15:49:21 <sproingie> ThisArrayGoesUpToEleven
15:49:26 <monochrom> with haskell you can have 45-based too
15:49:40 <zc00gii> mm_freak: ping
15:50:07 <sproingie> staring at bright monitor in dark room + first time wearing glasses == ow my head
15:50:07 <geheimdienst> import Data.SpinalMap -- this map goes up to eleven
15:50:09 <zc00gii> mm_freak: you know the elisp function that evaluates stuff for haskell with inf-haskell?
15:50:22 <zc00gii> mm_freak: I want to make an erc binding
15:50:48 <monochrom> you are supposed to adjust room lighting to match monitor lighting, yes.
15:51:02 <bss03> > Data.Array.array (1, 11) [(x, concat $ replicate x "LOUD") | x <- [1..11])
15:51:03 <lambdabot>   <no location info>: parse error on input `)'
15:51:07 <sproingie> would be nice except my desk area is an ergonomic nightmare
15:51:10 <geheimdienst> sproingie, turn on the lights. at the very least, dial down the monitor brightness to around minimum
15:51:13 <bss03> > Data.Array.array (1, 11) [(x, concat $ replicate x "LOUD") | x <- [1..11]]
15:51:14 <sproingie> the only overhead light is worse than no light
15:51:14 <lambdabot>   array (1,11) [(1,"LOUD"),(2,"LOUDLOUD"),(3,"LOUDLOUDLOUD"),(4,"LOUDLOUDLOUD...
15:51:23 <sproingie> it's like this super-glaring spot
15:51:57 * bss03 is one-based and goes to eleven.
15:52:00 <monochrom> heh ok. improve lighting, take care of your eyes, lest you will wear more glasses in the future.
15:52:39 <monochrom> I thought bss03 suggested 3-based.
15:52:43 <sproingie> meh, its genetic, eyestrain doesnt cause it
15:52:57 <geheimdienst> sproingie, i did the monitor-in-dark-room thing some time, but it's loads better with a bright room. less strain on the eyes, no more dry eyes, less fatigue, less headache
15:53:06 <monochrom> yeah, I mean don't add non-genetic problems.
15:53:27 <geheimdienst> you really should look into it. get some desk light or something
15:53:31 <geheimdienst> or some candles for atmosphere + impressing babes
15:53:39 <sproingie> geheimdienst: bright room is how i prefer it too.  its just that turning on the flourescent overhead also turns on this ridiculous spot
15:53:50 <sproingie> thinking of getting someone to take it out
15:54:05 * geheimdienst hands sproingie a sledgehammer
15:54:17 <sproingie> bb gun would be more effective
15:54:31 <sproingie> candles that'd be great.  lots of black and red candles surrounding my cube
15:54:35 <sproingie> i could wear a black robe
15:55:20 <monochrom> "high sage Sproingie will now chant a haskell one-liner..."
15:55:41 <sproingie> > fix error
15:55:42 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:56:03 <monochrom> sage? mage? maybe mage is better
15:56:09 <geheimdienst> "brb guys, hair on fire" sproingie changed status to: away
15:56:09 <sproingie> i like sage
15:56:20 <monochrom> hahaha geheimdienst
15:56:22 <sproingie> one of my favorite herbs
15:56:31 <sproingie> legal ones
15:57:01 * monochrom is tempted to: @remember ... <geheimdienst> "brb guys, hair on fire" <sproingie> one of my favorite herbs
16:20:34 <zc00gii> mm_freak: 
16:20:40 <zc00gii> take fibs 5 --> 
16:20:43 <zc00gii> wait what?
16:20:48 <zc00gii> err
16:20:53 <zc00gii> take 5 fibs --> [0,1,1,2,3]
16:20:57 <zc00gii> is what I meant
16:21:04 <zc00gii> ERC> /hs take 5 fibs
16:21:05 <zc00gii> <zc00gii> take 5 fibs --> [0,1,1,2,3]
16:21:06 <zc00gii> nice, right?
16:21:36 <copumpkin> o.O
16:21:46 <zc00gii> copumpkin: it's a command in my IRC client :D
16:22:01 <zc00gii> I have a /l too that evaluates cl, and a /e that evaluases el
16:22:05 <copumpkin> ah
16:23:25 <Martty> /hs repeat 1
16:24:21 <zc00gii> will probably do nothing until I kill the thread
16:27:51 <copumpkin> preflex: seen edwardk
16:27:52 <preflex>  edwardk was last seen on #haskell 9 days, 9 hours, 34 minutes and 19 seconds ago, saying: ;)
16:34:52 <pao> hi all!
16:35:15 <pao> can anyone giveme some hints on how to debug overlapping instances? (mtl vs transformers)
16:36:13 <pao> is that correct that I should check only the imports on the failing module?
16:38:48 <benmachine> pao: where do mtl and transformers come into it? what exact problem are you having?
16:39:00 <pao> @paste
16:39:00 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:39:04 <benmachine> erm
16:39:07 <benmachine> try hpaste.org
16:39:12 * hackagebot iyql 0.0.5 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.5 (DiegoSouza)
16:39:19 <benmachine> oh
16:39:21 <benmachine> that's dead too
16:40:05 <pao> benmachine, http://paste.pocoo.org/show/259740/
16:40:34 <pao> benmachine, I've no idea of why mtl instances are in scope
16:40:53 <monochrom> hpaste has problems every so often
16:41:00 <benmachine> pao: something you import imports mtl instances
16:41:38 <geheimdienst> pao, does it help if you run "ghc-pkg hide monads-fd" and "monads-tf"?
16:41:54 <geheimdienst> seems like every few days somebody is in here with that exact problem
16:42:19 <pao> benmachine, that's what I thought... but I do not import anything suspecting in that module
16:42:55 <monochrom> just importing a module brings in instances unconditionally
16:43:27 <monochrom> two modules both saying "instance Monad Whee where" is bad news. Totally satisfies the definition of "overlapping instances"
16:43:37 <pao> http://paste.pocoo.org/show/259741/
16:43:42 <monochrom> of course, I mean bad news if you import both
16:44:00 <benmachine> pao: why packageimports?
16:44:24 <pao> benmachine, just to make sure that I import transformers and not mtl
16:44:29 <monochrom> here is the worst part. instances are imported transitivity. if X imports Y, Y imports Z, Z has instance, that instance is brought to X too
16:44:45 <benmachine> pao: it's easier to make sure of that by using -hide-package and -package
16:45:06 <pao> benmachine, in *.cabal?
16:45:11 <benmachine> oh
16:45:21 <pao> monochrom, argh
16:45:25 <benmachine> no in a cabal file you definitely get what you're looking for
16:45:36 <pao> monochrom, is there a way to discover who is bringing me mtl in?
16:45:40 <benmachine> because cabal hides everything except your build-deps
16:45:45 <monochrom> yes, so even if you don't use mtl directly, if you use a package that uses mtl...
16:45:55 <pao> benmachine, I've got HTTP that depends on mtl in cabal
16:46:18 <pao> benmachine, but in that module I do not import anything suggesting mtl
16:46:27 <geheimdienst> pao, i suggest you run "cabal init". it's short an painless, and then you have full control over dependencies because you only get what you explicitly list in the build-depends field
16:46:56 <pao> geheimdienst, that's what I did
16:47:05 <geheimdienst> oh i see
16:47:14 <monochrom> the moment you import a module from HTTP you're highly likely hosed
16:48:06 <benmachine> what in the heck does HTTP want with mtl I wonder
16:48:28 <pao> monochrom, so It's impossibile for my project to depend indirectly on both mtl and transformers, right?
16:48:58 <monochrom> HTTP has a browser monad. implementation is state or reader monad over IO
16:49:17 <pao> the strange thing I that I get an error on that module, and in that module there's nothing "strange"
16:49:41 <copumpkin> is there a haskell withTemporaryFile or something ?
16:49:43 <geheimdienst> you're doing the same in other modules and they compile?
16:49:51 <benmachine> monochrom: laaame
16:49:52 <copumpkin> withTemporaryFile :: (Handle -> IO a) -> IO a
16:50:02 <copumpkin> @hoogle (Handle -> IO a) -> IO a
16:50:02 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
16:50:02 <lambdabot> System.IO withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
16:50:02 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
16:50:12 <benmachine> @hoogle temporary
16:50:12 <lambdabot> System.Directory getTemporaryDirectory :: IO FilePath
16:50:18 <benmachine> close enough?
16:50:23 <benmachine> not really
16:50:24 <benmachine> but
16:50:25 <benmachine> whatevs
16:50:30 <benmachine> write it, hackage it
16:50:35 <copumpkin> lol
16:50:38 <pao> geheimdienst, I'm compiling via cabal build
16:50:51 <pao> geheimdienst, at that module the compilation stops
16:50:54 <monochrom> System.Posix.Temp if you can afford posix
16:52:13 <geheimdienst> copumpkin, might be related http://stackoverflow.com/questions/2978210/create-a-temporary-directory-in-haskell
16:52:15 * hackagebot iyql 0.0.5.1 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.5.1 (DiegoSouza)
16:54:38 <copumpkin> I wish windows would get rid of that fucking binary/text mode distinction
16:56:04 <monochrom> I wish windows would vanish.
16:56:07 <Gracenotes> bah you, windows
16:56:37 <benmachine> if wishes were
16:56:42 <benmachine> what is it that wishes are supposed to be?
16:56:45 <copumpkin> http://snapplr.com/6xx0
16:56:46 <copumpkin> there
16:56:50 <Gracenotes> oh btw happy holidays, channel jews
16:56:50 <copumpkin> not gonna make a package out of it :P
16:57:28 <copumpkin> oh wait
16:57:33 <copumpkin> need to kill the file too
16:57:50 <monochrom> good call not packaging it hee hee
16:58:11 <benmachine> copumpkin: see, worth packaging
16:58:15 <copumpkin> lol
16:58:32 <copumpkin> dammit, what's the delete/unlink file function?
16:58:39 <benmachine> @hoogle remove
16:58:39 <lambdabot> Data.Graph.Inductive.Monad.IOArray removeDel :: IOArray Node Bool -> Adj b -> IO (Adj b)
16:58:39 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
16:58:39 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
16:58:42 <benmachine> hmm
16:58:50 <geheimdienst> better package a temp file thing than the eighteenth contender for Control.Monad.Trans.Error
16:58:53 <benmachine> removeFile
16:58:56 <benmachine> System.Directory
16:59:02 <copumpkin> aha, thanks
16:59:04 <monochrom> hahaha
16:59:07 <execve> > (>0) == (>0)
16:59:08 <lambdabot>   *Exception: (==): No overloading for function
16:59:23 <execve> Any ideas how to fix it?
16:59:33 <monochrom> why not do both. package a Control.Monad.MonadTempFileIO
16:59:39 <Gracenotes> > 4 == 4 || (>0) == (<3)
16:59:40 <lambdabot>   True
16:59:55 <geheimdienst> > (>0) == (>3)
16:59:56 <lambdabot>   *Exception: (==): No overloading for function
17:00:06 <geheimdienst> that works only because the right part is not evaluated
17:00:16 <execve> Gracenotes: I need Eq for function
17:00:19 <monochrom> I don't want to write a theorem prover
17:00:22 <geheimdienst> > (>0) == (<3)
17:00:23 <lambdabot>   *Exception: (==): No overloading for function
17:00:37 <benmachine> instance Monad (Either e) -- Defined in Control.Monad.Error
17:00:42 <benmachine> ^ guys, no Error :O
17:01:02 <benmachine> mtl 1.1.1 seems to have dropped it
17:02:44 <geheimdienst> i grepped for Error in mtl-1.1.1.0, and there's a jigillion hits
17:02:51 <ddarius> copumpkin: Too good for tuples?
17:03:01 <geheimdienst> there's a file Control/Monad/Error.hs for starters
17:03:22 <copumpkin> ddarius: nah, using them now since I need the path and handle too :)
17:05:09 <monochrom> #if !(MIN_VERSION_base(4,2,1))
17:05:09 <monochrom> -- These instances are in base-4.3
17:05:09 <monochrom> instance Monad (Either e) where
17:05:27 <monochrom> looks like you don't need mtl to get it, if your ghc is futuristic
17:05:55 <benmachine> gasp
17:05:58 <benmachine> that's pretty cool
17:06:29 <monochrom> the world is getting better and better!
17:06:55 <geheimdienst> better? because of more clashes?
17:07:00 <monochrom> in base-6, everything is a monad
17:07:28 <aristid> in base-7, nothing is
17:07:37 <monochrom> why?
17:09:24 <monochrom> perhaps because by then "instances are global and sticky" goes away
17:10:39 * ddarius wonders if he can finagle a way to boot into an iso image.
17:10:43 <benmachine> instances should be global and sticky :(
17:11:08 <aristid> monochrom: because monads will be out of fashion
17:11:17 <geheimdienst> ddarius, install virtualbox, click button, select iso file?
17:11:19 <geheimdienst> ;)
17:12:07 <ddarius> geheimdienst: I've considered that, but I doubt it would work well in my case.
17:13:45 <geheimdienst> i guess then you'll have to burn it to dvd, right? although i hear kids these days use usb drives for booting
17:14:20 <benmachine> everything will be a comonad in base7
17:14:20 <copumpkin> hmm, the readProcess function seems to pass args in a way that's confusing the program I'm calling (objdump)
17:14:23 <benmachine> or possibly a contramonad
17:14:38 <copumpkin> any idea what to do, besides just sticking the args into the command path?
17:14:39 <monochrom> iso in usb drive requires work tailored to what's on the iso
17:15:07 <ddarius> geheimdienst: Yeah, I'm considering putting it on my external USB hard drive and seeing if I boot from that.
17:17:31 <copumpkin> http://pastie.org/1147140
17:17:32 <geheimdienst> copumpkin, i'm sure that sticking the args in the command path won't work. readProcess doesn't start a shell to interpret the string and split it into args
17:17:44 <copumpkin> geheimdienst: ah, so do you have any suggestions?
17:17:50 <copumpkin> not really sure why it isn't working
17:18:08 <benmachine> isn't that what the [String] is for?
17:18:11 <copumpkin> oh I guess I need to split up the args further
17:18:17 <benmachine> although I've no idea what the second String is for
17:18:18 <copumpkin> I'll try that
17:18:29 <geheimdienst> put 1 arg per string
17:18:34 <ddarius> "List of tools to create live USB system: dd"
17:18:35 <geheimdienst> not "-D blah" or something
17:18:39 <copumpkin> okay
17:18:57 <monochrom> copumpkin: clearly, ["-b", "binary", etc]
17:19:15 <geheimdienst> (that will pass one argument to objdump which contains a space. really, that's only useful when you're dealing with filenames which may contain spaces, or something)
17:19:33 <copumpkin> yeah, makes sense
17:19:51 <copumpkin> hmm, now it just "fails" :P
17:19:58 <copumpkin> *** Exception: readProcess: /Users/pumpkin/arm-none-eabi/bin/arm-none-eabi-objdump "-D" "/var/folders/cV/cVW7rvVqGDGhFxG2w5e4u++++TI/-Tmp-/tmp76917" "-b" "binary" "-m" "arm" (exit 1): failed
17:20:18 <monochrom> does the temp file exist?
17:20:28 <geheimdienst> what's exit status 1 mean for objdump? check the manpage
17:20:52 <monochrom> also much valuable information in the return value of readProcess which includes stderr
17:21:20 <geheimdienst> ... and try running that exact command in a shell and see what happens
17:21:26 <copumpkin> oh, readProcessWithExitCode
17:21:44 <copumpkin> geheimdienst: works fine
17:21:52 <copumpkin> just copied and pasted it
17:22:10 <geheimdienst> that's impossible. buy new computer
17:22:15 <copumpkin> lol
17:22:20 <monochrom> I concur
17:22:29 <monochrom> should have said that to lispy
17:22:42 <copumpkin> (ExitFailure 1,"","")
17:22:45 <copumpkin> nice
17:23:04 <monochrom> any typo in the program name?
17:23:24 <copumpkin> nope, I literally copied and pasted the string from that exception above
17:23:26 <copumpkin> to my shell
17:23:31 <copumpkin> and it shows the correct output
17:24:15 <monochrom> btw how did you get such a gorgeous filename as /var/folders/cV/cVW7rvVqGDGhFxG2w5e4u++++TI/-Tmp-/tmp76917 ?
17:24:39 <copumpkin> http://snapplr.com/6pm7
17:24:39 <copumpkin> :P
17:24:53 <monochrom> gorgeous
17:24:56 <copumpkin> beats me how System.Directory decided on that
17:24:59 <geheimdienst> remove all args temporarily. objdump on my system gives exit status 2 when run with no args. see if in haskell you get something like (ExitFailure 2, "", "Usage ...")
17:25:12 <Jafet> That looks like one of those wacky unicode domain names
17:25:23 <copumpkin> geheimdienst: yeah, exitfailure 2
17:25:27 <copumpkin> with usage in stderr
17:25:43 <geheimdienst> okay, so it finds the program and starts it correctly
17:25:55 <copumpkin> I'm sure I'm doing something stupid
17:26:12 <copumpkin> it's generally the answer
17:26:27 * hackagebot maid 2010.9.9 - A simple static web server  http://hackage.haskell.org/package/maid-2010.9.9 (JinjingWang)
17:28:38 <copumpkin> can't find an easy summary of what the exitcodes from objdump mean
17:30:21 <geheimdienst> copumpkin, if all else fails, use strace
17:30:29 <copumpkin> it's a mac :P
17:30:32 <copumpkin> I guess I could dtruss it
17:32:29 * hackagebot maid 2010.9.9.1 - A simple static web server  http://hackage.haskell.org/package/maid-2010.9.9.1 (JinjingWang)
17:33:06 <djahandarie> There sure are a lot of web server packages these days
17:34:08 <Jafet> Success is like cologne -- be damned if you wear it, be damned if you don't.
17:35:05 <monochrom> Either Damned Damned?
17:35:46 <copumpkin> (Bool, Damned)
17:36:17 <geheimdienst> i think having eleventy web server packages is harmless. having multiple packages competing for Control.Monad.Error and the Either instance and whatnot, that's doing real damage
17:38:15 <avenge> Is a do block left or right associative?  do a; b; c is equivalent to to a >> b >> c or a >> (b >> c)?
17:38:25 <monochrom> unless the eleventy web server packages compete for the executable name "httpd"
17:38:50 <monochrom> I guess a >> (b >> c)
17:39:01 <fizruk> hi all! what is the main difference between type classes and interfaces? I fail to imagine situation when interfaces are not sufficient and type classes are..
17:39:20 <copumpkin> @src Read
17:39:20 <lambdabot> class Read a where
17:39:20 <lambdabot>   readsPrec    :: Int -> ReadS a
17:39:20 <lambdabot>   readList     :: ReadS [a]
17:39:20 <lambdabot>   readPrec     :: ReadPrec a
17:39:20 <lambdabot>   readListPrec :: ReadPrec [a]
17:39:30 <avenge> monochrom: Thanks.  That's much better for what I want, but makes me wonder why >> and >>= are left associative.
17:39:30 <copumpkin> meh, 
17:39:38 <copumpkin> class Read a where read :: String -> a
17:39:46 <copumpkin> fizruk: how would you represent that as an interface?
17:40:09 <monochrom> I know type class. What is interface?
17:40:23 <copumpkin> I'm assuming java-like interfaces
17:40:32 <copumpkin> objective-c protocols?
17:40:38 <kdvh> java interfaces = type classes (sort of)
17:40:40 <copumpkin> abstract superclasses? that kind of thing
17:41:19 <copumpkin> I wonder if my problem is permissions-related
17:41:23 <copumpkin> seems unlikely
17:41:29 <monochrom> see, if it comes down to "interface" from other languages, it is just not in haskell, the question of "sufficient?" is moot.
17:41:45 <geheimdienst> copumpkin, i guess that typeclasses can take parameters is something orthogonal. a data can also take parameters ...
17:42:04 <copumpkin> well, in general I view typeclasses as relations on types
17:42:15 <copumpkin> by default unary
17:42:44 <geheimdienst> the definition "a bag of function signatures" fits both a java interface and a haskell typeclass, no?
17:42:55 <copumpkin> methods on them are just witnesses
17:42:55 <geheimdienst> i have no idea what a unary relation on types is, sorry :)
17:43:03 <fizruk> copumpkin: read can be represented within interface if language supports polymorphism for return value, it's not the property of interfaces, as I understand
17:43:28 <copumpkin> fizruk: okay, so let's define interfaces first :P if you make them as general as typeclasses, then sure, they're equivalent
17:43:29 <geheimdienst> fizruk, i agree
17:43:33 <copumpkin> but I don't know of languages that have that
17:44:06 <geheimdienst> :k Eq
17:44:07 <lambdabot> Class `Eq' used as a type
17:44:22 <fizruk> I met one example in "Practice of Functional Programming", but failed to understand what author meant )
17:45:59 <geheimdienst> fizruk, i think java's interfaces are very similar to typeclasses. i can't think of a clear difference really
17:46:27 <copumpkin> geheimdienst: they are only polymorphic in the "receiver"
17:46:35 <copumpkin> you couldn't write e.g., Read in it
17:46:42 <copumpkin> you also couldn't write Functor
17:47:00 <copumpkin> you also can't express additional type constraints such as Num has
17:47:10 <copumpkin> that the first and second parameter have equal type
17:47:37 <copumpkin> and taking it further, you definitely can't have multiparameter typeclass-like things in them, and unimaginably functional dependencies :P
17:48:02 <copumpkin> c++ templates approximate them better, if anything
17:48:24 <geheimdienst> i still think type parametricity is a separate issue. a data can have paramteres, too
17:48:34 <copumpkin> ?
17:48:48 <geheimdienst> :t Num
17:48:49 <lambdabot> Not in scope: data constructor `Num'
17:48:59 <geheimdienst> @src Num
17:48:59 <lambdabot> class  (Eq a, Show a) => Num a  where
17:48:59 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:48:59 <lambdabot>     negate, abs, signum     :: a -> a
17:48:59 <lambdabot>     fromInteger             :: Integer -> a
17:49:27 <copumpkin> a more practical difference is that you have to declare your interfaces up front
17:49:51 <copumpkin> and you also can't request that something respond to two separate interfaces at once, unless you make another interface that unifies them
17:49:52 <monochrom> (there is interface inheritance. interface Num extends Show...)
17:49:59 <geheimdienst> now suppose you have a java-ish or c++ish language which supports generic interfaces. what part of Num couldn't you port?
17:50:26 <copumpkin> geheimdienst: generic interfaces meaning?
17:50:44 <geheimdienst> interface Foobar<parameter>
17:51:16 <geheimdienst> copumpkin, yes, there's boilerplate involved for "something that implements interfaces X and Y"
17:51:18 <copumpkin> you still couldn't retroactively fit a class wit a Num interface
17:51:42 <copumpkin> geheimdienst: it's exponential boilerplate, though
17:52:22 <copumpkin> if my class implements interfaces A, B, and C, I need to declare all combinations of those three and specify that I implement all of them
17:52:24 <geheimdienst> i thought about that, and that looks like a difference. however, you can derive the class and add the interface, as far as i remember. so i guess it's more a difference in how verbose it gets
17:52:27 <copumpkin> in case some methods only need two
17:52:47 <fizruk> uff, i forgot where I saw that example...
17:53:05 <Axman6> possibly a stupid question, but why does Num require Eq?
17:53:18 <copumpkin> Axman6: for pattern matching on number literals
17:53:35 <Axman6> ah, fair enough
17:53:38 <geheimdienst> well, you need to say "implements A, B, C". could you elaborate on what you mean with declaring all combinations?
17:53:59 <copumpkin> geheimdienst: say I wanted to write a function (Show a, Read a) => a -> ...
17:54:11 <copumpkin> geheimdienst: your class implements Show and Read
17:54:20 <copumpkin> you could make a ShowRead interface
17:54:36 <copumpkin> but ShowNum, ShowReadNum, ReadNum, and so on
17:55:02 <copumpkin> you'd need to write that you support all subsets of the interfaces you support
17:56:22 <copumpkin> anyway, I guess my main point is that interfaces as I've seen them in all OO languages I've worked with are superficially like typeclasses but way less expressive
17:56:46 <copumpkin> if we define them to be as general as typeclasses, then they are equivalent to typeclasses :) but it seems silly if there are no existing implementations of such things out there
17:56:53 <geheimdienst> i agree that OO languages have way more boilerplate than haskell
17:59:11 <fizruk> copumpkin: by "less expressive" you mean "less beautiful" or "less powerfull"?
18:00:07 <geheimdienst> it's convenient that you can make an "ad-hoc typeclass" that includes anything which implements typeclass X *and* typeclass Y
18:00:08 <copumpkin> fizruk: I mean you can't express the same constraints on the types, or depend on anything but the "receiver" of the method. You definitely can't retroactively add them, and the multi-parameter stuff is out of the question
18:00:12 <copumpkin> so they're a lot less interesting to me
18:00:25 <copumpkin> geheimdienst: you can't really, though
18:00:39 <copumpkin> geheimdienst: writing f :: (T a,  S a) => isn't implemented as a union typeclass
18:00:51 <copumpkin> we're still waiting for typeclass synonyms :)
18:01:26 <copumpkin> and the current best option for typeclass synonyms forces you to turn on undecidable instances
18:03:10 <ddarius> copumpkin: OO interfaces have a notion of subtyping and existential quantification wound up in them that type classes do not have.
18:03:19 <copumpkin> oh, true
18:03:30 <commanace> hey... does anyone know a good reference about how haskell Integers are implemented (thus the arbitrary precision ones)?
18:03:39 <copumpkin> commanace: gmplib.org? :)
18:03:50 <copumpkin> unless you want the pure haskell version, which is slower
18:04:23 <copumpkin> http://darcs.haskell.org/libraries/integer-gmp/ and http://darcs.haskell.org/libraries/integer-simple/
18:05:07 <commanace> copumpkin: i'm not really interested in using it but more into conceptually understanding how it's done :)
18:05:29 <copumpkin> the integer math or how it interfaces with haskell?
18:05:34 <mm_freak> zc00gii: great =P
18:05:35 <Axman6> well until recently, it was just using GMP integers
18:06:28 <copumpkin> gah, why doesn't CreateProcess have a Show instance? :P
18:08:30 <commanace> copumpkin, Axman6: okay, thank you, didn't know that
18:09:52 <mm_freak> Axman6: what is it using now?
18:10:18 <Mitar> how can i fix this: http://pastebin.com/eAyhfr7L
18:10:18 <Mitar> it seems it is not right approach to make chan which can accept all values of some class
18:17:28 <copumpkin> dammit why do all the System.Process types not have Show instances
18:18:57 <mm_freak> Mitar: that means that the channel type is still specific for a specific chan
18:19:18 <mm_freak> i guess you want:  Chan (forall i. Impulse i => i)
18:19:28 <mm_freak> but i'm not sure whether that would work
18:19:34 <copumpkin> omg more impredicativity!
18:19:50 <copumpkin> (just make a wrapper type and pass that around)
18:19:53 <copumpkin> unless you mean existentials
18:20:07 <mm_freak> copumpkin: that's what i would o
18:20:08 <mm_freak> do
18:20:09 <copumpkin> in which case make a wrapper type anyway
18:20:18 <copumpkin> Chan (exists i. Impulse i => i)
18:21:04 <copumpkin> Mitar: but yeah, it is the right approach
18:21:07 <copumpkin> in your paste
18:21:34 <Mitar> i would like an open type
18:21:45 <copumpkin> open how?
18:22:15 <mm_freak> Mitar: i guess it should be valid to pass values of different types to a certain chan
18:22:21 <copumpkin> oh wait
18:22:26 <copumpkin> no it isn't the right approach
18:22:31 <mm_freak> ;)
18:22:44 <copumpkin> data Wrap = forall i. Impulse i => Wrap i
18:22:48 <Mitar> open in the sense that somebody else can make another instance
18:22:48 <Mitar> and fill it in the same channel
18:22:53 <copumpkin> type Mychan = Chan Wrap
18:23:12 <copumpkin> then writechan chan (Wrap <some value of a type that's an instance of Impulse>)
18:23:31 <copumpkin> sorry, I saw the existential wrapper and assumed you were doing the above
18:23:36 <mm_freak> i wonder why you need the wrapper type
18:23:49 <copumpkin> because GHC doesn't support first-class existentials
18:24:02 <mm_freak> type MyChan = Chan (forall i. Impulse i => i)  -- wouldn't that work?
18:24:03 <copumpkin> I think JHC does
18:24:08 <copumpkin> that's a different type
18:24:17 <copumpkin> Chan (exists i. Impulse i => i)
18:24:20 <copumpkin> is what you need
18:24:27 <ski>   Chan (exists i. Impulse i *> i)
18:25:05 <copumpkin> what's *> in your imaginary syntax? :)
18:25:42 <copumpkin> mm_freak: the forall version would be a Chan of polymorphic values that can be instantiated to any impulse type
18:25:53 <copumpkin> someting like 3, which is forall a. Num a => a
18:26:28 <ski> copumpkin : `(->)' : `(,)' :: `(=>)' : `(*>)'
18:26:33 <Mitar> hmm
18:26:33 <Mitar> i changed to rank2types ;-)
18:26:34 <Mitar> http://pastebin.com/kWWh3n01
18:26:34 <Mitar> this does compile
18:26:35 <Mitar> i am just not sure how to make a necessary chan ;-)
18:26:35 <mm_freak> copumpkin: but it works for me
18:26:42 <copumpkin> mm_freak: ?
18:26:47 <copumpkin> you need impredicative types, and it has a different meaning
18:27:19 <mm_freak> maybe i misunderstood what Mitar wants, but i can get OOP-like polymorphism that way
18:27:28 <copumpkin> mm_freak: o.O
18:27:39 <ski> mm_freak : i bet you haven't tried creating a value of that type, yet ..
18:28:07 <copumpkin> ski: I see, makes sense :)
18:28:22 * ski grins
18:28:29 <copumpkin> Mitar: your new type doesn't really make much sense
18:28:53 <copumpkin> Mitar: it wants a polymorphic chan
18:30:03 <mm_freak> ah, i see
18:30:04 * copumpkin is a convert to the *> syntax
18:30:12 * ski blames OO for talking about "polymorphism", when the value has existential type (and the context is polymorphic)
18:30:13 <mm_freak> the value passed must be as polymorphic
18:30:18 <Mitar> http://pastebin.com/uSgFpyjd
18:30:18 <copumpkin> yeah
18:30:30 <mm_freak> ok, i got it
18:30:38 <copumpkin> Mitar: I told you what to do :P
18:30:50 <copumpkin> [03:22:19 AM] ‹ copumpkin › data Wrap = forall i. Impulse i => Wrap i
18:30:58 <mm_freak> so in this case, if the channel type is polymorphic, the values passed to it must be polymorphic, too, right?
18:31:06 <copumpkin> data Nerve = Nerve (Chan Wrap) | NoNerve
18:31:10 <copumpkin> omg dolio's back!
18:31:12 <copumpkin> yay
18:31:33 <Mitar> i do not get anything ;-)
18:31:33 <Mitar> so how can i make a chan of proper type?
18:31:33 <mm_freak> copumpkin: not newtype?
18:31:35 <applicative> @type newChan
18:31:36 <lambdabot> Not in scope: `newChan'
18:31:41 <dolio> Yow!
18:31:43 <ski> greetings, dolio
18:31:46 <applicative> not surprising
18:31:47 <copumpkin> mm_freak: don't think you can newtype an existential
18:32:10 <ski> you can't
18:32:16 <mm_freak> copumpkin: yeah, you're right
18:32:23 <ski> it would make sense to be able to do it, *if* you had no class constraint
18:32:36 <ski> .. but in this case, there's `Impulse i'
18:32:37 <copumpkin> it'd be a pretty useless existential then though :)
18:32:41 <mm_freak> ski: even then it doesn't compile
18:32:45 <applicative> Mitar, since Impulse doesn't yet make a restriction, you want something that inhabits every Chan type like 'undefined', no?
18:32:48 <Mitar> :t Control.Concurrent.newChan
18:32:49 <lambdabot> forall a. IO (Control.Concurrent.Chan.Chan a)
18:33:09 <mm_freak> ah, but you can do:
18:33:12 <applicative> Mitar, I mean, thats what your Nerves are.
18:33:13 <mm_freak> data Wrap = forall i. Wrap !i
18:33:26 <ski> copumpkin : not necessarily .. `newtype Foo a = forall x. MkFoo (Ops a x) [x]' or something similar, e.g.
18:33:34 * applicative wonders, well, maybe the nerves do carry 'information' of any type
18:33:46 <copumpkin> ski: oh, okay, yeah
18:34:03 <Mitar> applicative: i am not sure i understand what are you asking?
18:34:17 <ski> (er, though i suppose i really meant a tuple there, not having `MkFoo' take two arguments ;)
18:34:22 <applicative> i was just trying to understand the new type error, from the one you just posted
18:34:25 <mm_freak> actually that code gives me an idea
18:34:34 <mm_freak> couldn't you write a neural network using concurrency?
18:34:44 <mm_freak> at least the running part, not the learning part
18:34:52 <copumpkin> going back to the old subject, I still haven't figured out this damn readProcess :P
18:34:57 <applicative> main = newChan >>= test . Nerve
18:35:18 <Mitar> i would just like to have one chan in which i can put different impulses
18:35:18 <Mitar> you see in my test function: i want to be able to put into same chan different types of values
18:35:21 <ski>   main = test . Nerve =<< newChan
18:35:36 <mm_freak> Mitar: yes, use the Wrap type
18:35:57 <applicative> main = join $ test . Nerve <$> newChan
18:36:08 <mm_freak> btw, when will the new haskell standard be implemented in GHC?
18:36:33 <Mitar> mm_freak: and what do you think i am doing? ;-)
18:36:33 <Mitar> but not really NN like they are defined this days
18:37:26 <mm_freak> Mitar: i assumed so, but i guess it will come with a performance hit
18:37:31 <copumpkin> okay, reduced it a bit more
18:37:35 <copumpkin> it has to do with the args :P
18:37:36 * ski is a little confused as to whether the problem is mm_freak's or Mitar's
18:37:48 <mm_freak> ski: Mitar's, but i was interested, too
18:37:48 <Mitar> and how can i unwrap values there? or i cannot? i can just use functions of Impulse class?
18:37:51 <copumpkin> mm_freak: probably 7?
18:37:55 <ski> mm_freak : "even then it doesn't compile", "it" being ?
18:38:01 <mm_freak> Mitar: yes, using class functions
18:38:21 <mm_freak> copumpkin: ?
18:38:34 <mm_freak> ski: newtype Wrap = forall i. Wrap i
18:38:53 <mm_freak> "even then" = with empty context
18:39:01 <copumpkin> mm_freak: probably GHC 7
18:39:03 <Mitar> let me see how to name this wrap type then
18:39:03 <Mitar> so that it would be in the neural terminology ;-)
18:39:06 <ski> mm_freak : yeah, for "existential datatypes", you need `data', not `newtype'
18:39:06 <mm_freak> copumpkin: ah, thanks
18:39:08 <Mitar> maybe i could rename instance to somethig more specific
18:39:16 <Mitar> and have wrap be impulse
18:39:34 <mm_freak> Mitar: maybe you shouldn't use polymorphism at all
18:39:41 <ski> mm_freak : i just said it would make sense, to allow it for `newtype' in that case .. i didn't say it was actually allowed by GHC
18:39:45 <mm_freak> data Impulse = SomeImpulse | SomeOtherImpulse
18:39:54 <mm_freak> then you can use your usual pattern matching and the like
18:40:09 <mm_freak> unless you want to give other developers the change to extend the set of possible impulses
18:40:18 <Mitar> s/instance/impulse/
18:40:23 <mm_freak> ski: oh, ok
18:40:29 <applicative> @type let a = 3 in a
18:40:29 <lambdabot> forall t. (Num t) => t
18:40:40 <applicative> @type let a = (3 :: Int) in a
18:40:41 <lambdabot> Int
18:41:04 <ski> mm_freak : basically, GHC is being conservative with this extension .. so, maybe they will allow that in the future
18:41:33 <Mitar> i wrote before, i want an open type
18:41:34 <Mitar> yes, so that it is easily extendable
18:41:53 <ski> ok, so existentials
18:42:21 <copumpkin> why the hell is this thing not working!grr
18:43:25 <dolio> ski: It's conceivable that there's some corner case where newtype isn't safe even without contexts. But maybe that's just GADTs.
18:43:47 <ski> hm .. i suppose that might be possible. i'm not sure
18:44:08 <ski> (for ordinary datatypes, i think it should be ok)
18:44:16 <geheimdienst> copumpkin: moar details?
18:44:43 <geheimdienst> last i know is you were messing with objdump
18:44:52 <copumpkin> geheimdienst: so I'm screwing with the readProcessWithExitCode definition now
18:45:03 <copumpkin> and it calls createProcess (proc cmd args)
18:45:23 <copumpkin> if I replace that with createProcess (shell "the whole command-line I'd write in the shell") it works fine
18:45:25 <dolio> ski: It's definitely unsafe to have newtype GADTs. I can't really think of a case where it's unsafe with mere existentials.
18:45:50 <applicative> Mitar, in main = newChan >>= test.Nerve, isn't the problem not with the type for Nerve etc., but with the type of newChan?  Not that I get it
18:47:07 <geheimdienst> copumpkin: have you tried taking the command and appending "| cat", then running it
18:47:14 <geheimdienst> (with all args and what have you)
18:48:01 <geheimdienst> some programs behave differently if their output is not attached to a shell (ls gives something different form ls | cat ...)
18:48:12 <mauke> output is never a shell
18:48:15 <jmcarthur> is there a way i can get the ThreadID of the main thread from a child thread?
18:48:39 <geheimdienst> mauke, you know what i mean ...
18:48:42 <copumpkin> geheimdienst: nope, no difference
18:49:13 <geheimdienst> so the command fails when forked but works when you paste it into a terminal?
18:49:19 <mauke> (the magic word is isatty())
18:49:22 <tolkad> hackage has a horizontal scrollbar for me : (
18:49:26 <copumpkin> geheimdienst: not even
18:49:32 <copumpkin> it works fine when I paste it into terminal
18:49:41 <copumpkin> it also works fine if I call createProcess with shell "full command"
18:49:48 <jmcarthur> i'm willing to resort to unsafe things to do this
18:49:48 <copumpkin> but fails if I call createProcess with proc cmd args
18:50:09 <jimmyjazz14> is anyone working on returning haskell.org to its original glory?
18:50:24 <applicative> what was its original glory, i can't remember
18:50:30 <tolkad> is anyone working on removing the horizontal scrollbar from hackage?
18:50:38 <jimmyjazz14> heh
18:50:47 <tolkad> I'll even try to figure out what's causing it
18:50:59 <applicative> oh, i see, you mean, to return it to its recent glory
18:51:00 <jimmyjazz14> if so I volunteer myself
18:51:04 <ski> @tell dolio oh, i thought you were thinking of cases like `data Foo a = forall x. MkFoo (Bar a x)', where `Bar' is a GADT
18:51:04 <lambdabot> Consider it noted.
18:51:30 <jimmyjazz14> applicative: yeah back when it had CSS and fancy stuff like that
18:52:02 <tolkad> well that was easy
18:52:07 <ski> dolio : re
18:52:20 <applicative> if css was haskell, haskell.org would look good, but as it isn't, it doesn't
18:52:22 <geheimdienst> copumpkin: try saying "/bin/echo" as the filepath and leave all the objdump args in place
18:52:35 <tolkad> hey, anyone have access to the hackage css?
18:52:44 <tolkad> change the body padding to a margin
18:52:55 <tolkad> to fix the horizontal scrollbar
18:53:06 <copumpkin> geheimdienst: (ExitSuccess,"-D /var/folders/cV/cVW7rvVqGDGhFxG2w5e4u++++TI/-Tmp-/tmp76919 -b binary -m arm\n","")
18:53:10 <ski> dolio : well, say something :)
18:53:10 <applicative> jimmyjazz14, there was a huge amount of labor a few months ago, neverending discussions on the list, etc.  I think the look of it at the moment is a server subtlety?
18:53:13 <tolkad> at least, I think that will fix it
18:53:29 <tolkad> yeah tested it
18:53:30 <dolio> ski: In response to "re"?
18:53:30 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
18:53:31 <tolkad> that works
18:53:34 <dolio> Oh.
18:53:54 * copumpkin is baffled
18:54:01 * geheimdienst too
18:54:36 <dolio> ski: I'd bet that isn't really a problem, either. But I'd have to think about it.
18:54:42 <ski> dolio : still, would e.g. `newtype Foo :: * -> * where X :: X -> Foo A; Y :: Y -> Foo B', where `A' and `B' are not overlapping, be problematic ?
18:55:05 <ski> hm
18:55:21 <geheimdienst> would it be possible that the shell finds objdump at (say) /usr/bin/objdump, whereas your program calls another objdump binary ...?
18:55:24 <ski> actually, on second thought .. i suppose that wouldn't be very useful .. even if semantically ok
18:55:43 <tolkad> haddock.css: remove line 190 "margin: 0 auto;". change line 191 "padding: 0 2em 6em;" to "margin: 0 2em 6em;"
18:55:50 <tolkad> horizontal scrollbar fixed
18:55:53 <dolio> ski: The problem GADTs introduce is that the matches have to be refutable to make sure you're not using a proof (and getting refinement) that you don't actually have.
18:56:02 <dolio> Like undefined as a proof of type equality.
18:56:19 <dolio> And newtype matches are irrefutable.
18:56:28 <ski> (since even if you have a value of type `Foo A', the "GADTness" is supposed to mean that you can only recover an `X' by matching on the data constructors ..)
18:56:30 <tolkad> who here is in charge of haddock on hackage anyway?
18:56:42 <ski> dolio : yes
18:57:01 <copumpkin> geheimdienst: nah, mac os doesn't even have objdump, and I'm passing in the entire path
18:57:02 <dolio> I'm not sure if irrefutable matches on existentials are similarly unsafe, but GHC doesn't like them.
18:57:14 <dolio> It causes the brain explosion message.
18:57:24 <tolkad> how did this problem even happen? it has a horizontal scrollbar in firefox and chrome
18:57:35 <tolkad> idk about IE but it should
18:57:41 <ski> dolio : btw, GADT records would be nice .. (each field saying explicitly what the parameters of the record type must be, to be able to project)
18:58:08 <ski> dolio : .. anyway, i have to leave
18:58:10 <copumpkin> you can have GADT records?
18:58:14 <copumpkin> I thought
18:58:15 <dolio> Later, then.
18:58:44 <dolio> They introduced syntax for them, I thought. I don't know how you specify the result type of the constructor.
18:58:46 <tolkad> does anyone have access to hackage haddock generation code?
18:59:02 <ski> copumpkin : i mean something like `data Foo :: * -> * where blah :: Foo Int -> Bool; bleh :: Foo String -> String -> IO ()', or something like that
18:59:03 <applicative> tolkad what page are you getting a horizontal scrollbar. 
18:59:03 <tolkad> please I can't stand the horizontal scrollbar any longer
18:59:09 <tolkad> applicative: like all of them
18:59:13 <applicative> what page are you getting it for?
18:59:15 * ski -> _|_
18:59:22 <tolkad> getting an example
18:59:33 <dolio> Oh.
18:59:33 <mcnster> hi.  does ghc do any mangling of the .o when compiling .c files?
18:59:42 <tolkad> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Control-Applicative.html
18:59:45 <copumpkin> mcnster: nope
18:59:49 <copumpkin> it shouldn't
19:00:08 <dolio> 'data Term :: * -> * where { Lit { val :: Int } :: Term Int ; Succ { num :: Term Int } :: Term Int ; ... }'
19:00:10 <copumpkin> tolkad: I see what you mean
19:00:15 <geheimdienst> copumpkin: okay, i now think something in the environment must be different. maybe PATH or whatever is set in the shell, but mysteriously absent when forked with readProcess. or it's being invoked as another user. or there is something going on with the signal handlers, which readProcess doesn't reset before exec'ing objdump (see http://factor-language.blogspot.com/2010/09/two-things-every-unix-developer-should.html )
19:00:20 <tolkad> haddock.css: remove line 190 "margin: 0 auto;". change line 191 "padding: 0 2em 6em;" to "margin: 0 2em 6em;"
19:00:21 <geheimdienst> but those are all wild guesses :-(
19:00:23 <tolkad> easy fix
19:00:37 <tolkad> those are properties for the body tag
19:00:38 <copumpkin> geheimdienst: might be the environment, I'll check
19:00:46 <geheimdienst> section 2 on that blog post, btw
19:01:37 <mcnster> copumpkin, does this code indicate a bug in gcc:  push %rbp, mov %rsp, %rbp; mov %rdi, -0x08(%rbp)?
19:01:45 <tolkad> > _|_
19:01:45 <lambdabot>   <no location info>: parse error on input `|'
19:01:52 <tolkad> what is that anyway
19:01:59 <tolkad> I keep seeing it used but I can't google for it
19:02:35 <geheimdienst> tolkad, it's called "bottom"
19:02:51 <applicative> tolkad, yes, i see it on control.applicative  ; the other new ones don't seem to be doing it.  could it be that the new css + old haddock processing are the problem,
19:03:33 <tolkad> applicative: the problem is that in the css file someone is setting things to 100% of body width and then giving body a padding
19:03:56 <applicative> do you get the effect with, e.g. http://hackage.haskell.org/packages/archive/game-probability/1.1/doc/html/Numeric-Probability-Game-Cards-Hand.html
19:04:07 <tolkad> hmm no
19:04:21 <tolkad> but most things I do
19:04:22 <tolkad> http://hackage.haskell.org/packages/archive/utility-ht/0.0.4/doc/html/Data-Maybe-HT.html
19:04:27 <geheimdienst> copumpkin: one last thing. in a shell, run your objdump command for me, but prefixed this way: «LC_TYPE="" /blah/objdump arg1 arg2»
19:04:34 <geheimdienst> that's the last thing i can think of
19:04:44 <mauke> useless use of "" :-)
19:04:53 * hackagebot iyql 0.0.5.2 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.5.2 (DiegoSouza)
19:05:15 <geheimdienst> mauke, sorry i had some " characters left over from lunch. just using them up
19:05:26 <copumpkin> geheimdienst: nothing
19:05:30 <geheimdienst> 'cause they'd go in the trash anyway
19:05:34 <copumpkin> env and stuff are the same, too
19:05:40 <applicative> tolkad, Data.Maybe.HT was uploaded	Wed Mar 4 21:20:49 UTC 2009
19:05:53 <geheimdienst> you mean it printed nothing or it printed the right thing?
19:05:59 <tolkad> applicative: it seems to happen on ones without that synopsis thing on the right
19:06:23 <tolkad> no scrollbar: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html
19:06:30 <tolkad> err wait that one has a scrollbar
19:06:35 <tolkad> this one doesn't: http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector.html
19:06:46 <applicative> tolkad, what about http://hackage.haskell.org/packages/archive/feldspar-compiler/0.3.2/doc/html/Feldspar-Compiler-Imperative-CodeGeneration.html
19:06:53 <copumpkin> geheimdienst: same thing
19:06:55 <applicative> no synopsis, looks ok
19:06:59 <copumpkin> printed the normal answer
19:07:18 <geheimdienst> dammit
19:07:31 <copumpkin> this is so frustrating :P
19:07:44 <tolkad> applicative: ok, new theory. pages using xhaddock.css are ok
19:07:51 <tolkad> applicative: pages with haddock.css are messed up
19:08:08 <applicative> tolkad, i get it. 
19:08:34 <geheimdienst> what about the fat binaries on the mac? if the binary contains (say) only 64-bit code, but whenever you run something through your haskell program, it somehow wants to force 32-bit, which it can't find in the binary ...?
19:08:54 <applicative> i'm thinking the newly haddocked ones are using xhaddock.css, i guess.  but its a question how the other got disturbed
19:09:11 <tolkad> > bototm
19:09:12 <lambdabot>   Not in scope: `bototm'
19:09:14 <tolkad> > bottom
19:09:15 <lambdabot>   Not in scope: `bottom'
19:09:20 <applicative> > undefined
19:09:21 <lambdabot>   *Exception: Prelude.undefined
19:09:30 <tolkad> oh
19:09:34 <applicative> > error "you hit bottom"
19:09:35 <lambdabot>   *Exception: you hit bottom
19:09:36 <geheimdienst> tolkad, check this http://www.haskell.org/haskellwiki/Bottom :-)
19:09:36 <tolkad> > ⊥
19:09:37 <lambdabot>   <no location info>: parse error on input `⊥'
19:10:13 <tolkad> @let ⊥ = undefined
19:10:14 <lambdabot>   Parse error: VarSym "\8869"
19:10:20 <tolkad> @let ⊥ = undefined
19:10:20 <lambdabot>   Parse error: VarSym "\8869"
19:10:22 <tolkad> @let ⊥ = undefined
19:10:22 <lambdabot>   Parse error: VarSym "\8869"
19:10:23 <tolkad> @let ⊥ = undefined
19:10:23 <lambdabot>   Parse error: VarSym "\8869"
19:10:29 <tolkad> still not working
19:10:31 <copumpkin> wtf
19:10:45 <copumpkin> doing something four times isn't going to make it work
19:11:02 <copumpkin> @let (⊥) = undefined
19:11:03 <lambdabot>  Defined.
19:11:08 <applicative> @let _i_ = undefined in const 3 _i_
19:11:08 <lambdabot>   Parse error: KW_In
19:11:10 <copumpkin> why not stop to think a moment
19:11:40 <tolkad> "if at first you don't succeed try again"
19:11:45 <applicative> copumpkin, i think the idea is that lambdabot will do the thinking 
19:11:50 <copumpkin> not the exact same thing
19:11:55 <geheimdienst> tolkad uses the proven method of wearing out lambdabot until she does what he wants
19:12:01 <copumpkin> or just pissing off the channel
19:12:08 <applicative> at some point she will say 'oh i get it'.  it seems not to happen
19:12:47 <geheimdienst> sometimes it works. when you want a certain @quote, but a few others come up the first few tries ...
19:13:20 <tolkad> sorry for pissing off the channel
19:13:30 <applicative> you didn't 
19:13:46 <applicative> copumkin is already irritated
19:14:23 <tolkad> uh also that "Produced by Haddock version 2.6.0" line is covering some of the content -_-
19:14:27 <copumpkin> yes, I get irritated at tolkad more easily than others, because he has a history of doing intentionally annoying stuff
19:14:29 <applicative> is there a Haskell rule stated somewhere, which unicode things are upper case lower case, which are letters which are operator-material?
19:14:29 <copumpkin> but anyway, whatever
19:14:39 <copumpkin> applicative: unicode spec
19:15:02 <mcnster> cale, are you around?
19:15:09 <applicative> it does it itself?  hmm.  so some lambas will be greek letters, others mathematical symbols?
19:15:22 <Cale> mcnster: yes
19:15:37 <geheimdienst> anyway, copumpkin: the multi-architecture fat binary causing trouble is the last thing i got. if that's not the cause, tell your computer he's confusing me and i hate him
19:15:50 <Cale> @undefine
19:16:00 <Cale> > 1
19:16:01 <lambdabot>   1
19:16:23 <geheimdienst> (this has gotta be the equivalent of a kung fu master cracking his knuckles)
19:16:24 <copumpkin> pumpkin:~ pumpkin$ file /Users/pumpkin/arm-none-eabi/bin/arm-none-eabi-objdump
19:16:29 <mcnster> cale, do you see anything wrong with this prolog code?  push %rbp; mov %rsp,%rbp; mov %rdi,-0x8(%rbp).  notice that a subsequent push will stomp the value at -0x8(%rbp)
19:16:31 <copumpkin>  /Users/pumpkin/arm-none-eabi/bin/arm-none-eabi-objdump: Mach-O 64-bit executable x86_64
19:16:35 <copumpkin> geheimdienst: :) nope
19:16:59 <geheimdienst> and your program is 64 also?
19:17:09 <copumpkin> no, but that shouldn't affect anything
19:17:22 <Cale> mcnster: ?
19:17:23 <copumpkin> especially since I can call it easily when I just use shell
19:17:36 <Cale> mcnster: Why are you asking me?
19:18:09 <geheimdienst> i was thinking of some kind of hidden problem when the 32-bit haskell runtime is trying to fork a 64-bit process ... which somehow a shell has facilities for dealing with ...
19:18:16 <geheimdienst> i'm grasping at straws really
19:18:26 <Cale> mcnster: What flavour of assembly code is that, and what are we doing here?
19:18:32 <copumpkin> nah, since we've already seen it succeed with the other approach
19:18:32 <mcnster> cale, sorry.  i assumed you were familiar with this kind of thing :(
19:19:27 <mcnster> cale, its x86_64/elf/linux.  its code generated by gcc under ghc and it seems strange to me that the %rsp is not being adjusted to make a stack frame
19:20:32 <tolkad> IntMap doesn't say whether negative keys are ok. Are they?
19:20:36 <Cale> Okay, I have very little familiarity with x86 assembly. (I've only ever dealt directly with DLX, MIPS, and PPC/Altivec)
19:20:38 <tolkad> Data.IntMap that is
19:20:40 <copumpkin> tolkad: I'd guess so
19:20:42 <mcnster> cale, long story short, it causes problems when used with interrupt service routines when i run the program on the bare metal
19:21:11 <copumpkin> mcnster: how are you dealing with the RTS?
19:21:27 <wli> x86(-64) is horrible. Among the worst ever.
19:21:34 <mcnster> copumpkin, the rts is part of the kernel
19:21:40 <copumpkin> ah
19:22:15 <copumpkin> mcnster: well, the gcc-generated assembly from -via-C gets passed through the mangler
19:22:31 <Cale> Right, I was just about to mention the mangler
19:22:50 <copumpkin> when you asked about the .o files getting mangled, I thought you meant if you explicitly used ghc to link in externally generated .o files
19:22:58 <Cale> After realising that you were examining output of -via-C code generation.
19:23:05 <mcnster> copumpkin, oh does it!  even when compiling a straight-.c file?
19:23:13 <copumpkin> oh, not that
19:23:43 <copumpkin> (as far as I know?)
19:23:53 <copumpkin> would seem weird to screw with pure c code
19:24:08 <mcnster> the code in question is part of the rts.  i've wasted the whole day tracking it down...
19:24:23 <copumpkin> it may be worth asking in #ghc
19:24:27 * Cale .oO( EVIL MANGLER ALL THE WAY... WHAT DOES THIS MEAN?!? )
19:24:29 <copumpkin> although most of the people in there are asleep right now
19:25:10 <Cale> (Somehow the double rainbow guy freaking out about the evil mangler just popped into my head)
19:25:23 <Eridius> haha
19:27:15 <mcnster> heh
19:27:51 * copumpkin is utterly baffled :(
19:29:28 <mm_freak> is there a good introduction into category theory, which focusses on its practical uses for haskell?  perhaps a category-extras tutorial?
19:30:09 <mm_freak> where stuff like whatevermorphisms, densities, codensities and others is introduced
19:33:36 <djahandarie> That definitely sounds like it should exist if it doesn't
19:33:38 <Cale> mm_freak: I can give you a good intro to category theory, but it doesn't talk about Haskell or half of the stuff in category-extras
19:34:04 <mm_freak> Cale: well, that's a start
19:34:16 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
19:34:29 <copumpkin> #cultofawodey
19:34:33 <copumpkin> :)
19:34:33 <adnap> Has anyone messed with Functional Reactive Programming?  If so, do you prefer either Elerea or Fran?
19:34:40 <mm_freak> Cale: thank you, i'll have a look
19:35:10 <mm_freak> adnap: i have messed with Elerea and Yampa…  the latter is more elegant, but the former is easier to understand
19:35:48 * Cale wonders how Elerea manages to be *less* elegant than Yampa :)
19:35:55 <mm_freak> i can't say much about the performance of yampa, but elerea easily handled tens of thousands of transformations in a second (which may still be too slow for your application)
19:36:24 <tolkad> uh how do you avoid deadlocks when using multiple mvars? just make sure to always take them in the same order?
19:36:44 <mm_freak> Cale: i don't know, but elerea felt less expressive to me
19:36:57 <Cale> mm_freak: Looking at it, I can see how that might be
19:37:07 <adnap> So, is Fran considered outdated?
19:37:12 <mm_freak> tolkad: a deadlock was always caused by a thread writing to itself for me…  in general switching to Chan helped
19:37:56 <mm_freak> wasn't Fran the first library to introduce FRP to haskell?
19:37:57 <Cale> adnap: Fran is old and it doesn't seem to be available on Hackage, but I'm not sure if it's outdated strictly speaking.
19:38:13 <djahandarie> Bit-rotted probably
19:38:19 <mm_freak> (or haskell to FRP)
19:38:33 <tolkad> mm_freak: like if you have mvar a, and mvar b and in one place you take a then b and in another place you take b then a. they switch context between the takes and end up in a deadlock
19:38:39 <adnap> So, FRP is still playing catch-up in terms of efficiency?
19:39:04 <Cale> tolkad: Well... if you're in danger of that, you might consider using TMVars instead.
19:39:13 <mm_freak> tolkad: well, sounds like you want more threads, or maybe you simply don't need concurrency at all
19:39:20 <mm_freak> tolkad: what's your application?
19:39:41 <tolkad> I'm just curious
19:39:46 <jmcarthur> is there a way to disable template haskell in the call to ghc?
19:39:51 <tolkad> if you are supposed to take care of that yourself
19:39:59 <tolkad> well I guess you would have to
19:40:09 <mm_freak> adnap: it feels slow compared to the imperative style
19:40:35 <tolkad> Cale: idk that STM thing looked complicated so I tried to avoid reading anything to do with it
19:40:47 <djahandarie> STM is definitely a good thing to read about
19:40:47 <Cale> tolkad: It's actually pretty simple to use
19:40:55 <mm_freak> tolkad: it really depends on the application…  generally you don't use inter-thread communication stuff, when you don't actually use multiple threads
19:41:19 <mm_freak> tolkad: there are state monads or even the usual recursion for this
19:42:02 <Cale> tolkad: Basically, you can compose actions which mutate variables of special sorts (TVars and other things built in terms of them), and have those actions occur as-if-atomically (transactionally) with respect to other such actions on that memory.
19:42:16 <mm_freak> tolkad: and i agree that STM is simple…  it basically just allows you to ask for a value on multiple variables simultaneously
19:42:31 <Cale> Oh, if you only have one thread, then MVars and STM are pointless.
19:42:52 <Cale> But I'm pretty sure that tolkad has more.
19:43:06 <mm_freak> i'm not, because there is no evidence =)
19:43:15 <adnap> mm_freak: What sort of programs were you writing?  Were you doing anything really demanding?
19:43:24 <Cale> mm_freak: Well, he mentioned deadlock.
19:43:41 <Cale> mm_freak: It would be impossible for the deadlock he mentioned to occur in only one thread.
19:43:44 <mm_freak> Cale: newEmptyMVar >>= takeMVar
19:43:46 <mm_freak> =)
19:43:57 <Cale> Yeah, that's not the sort of thing he's talking about
19:43:59 <jmcarthur> i need to be able to disable template haskell for an arbitrary-code environment. the binaries are sandboxed, but the compilation is not
19:44:48 <Cale> mm_freak: Consider the case where you have two MVars which both need to be updated, and the value you need to update them to depends on both of their present values.
19:45:01 <tolkad> mm_freak: -_- you don't need abstractions to stop yourself from doing that
19:45:02 <Cale> mm_freak: Now imagine that happening twice in the same program :)
19:45:23 <mm_freak> tolkad: the abstractions make it easier and less error-prone
19:45:34 <mm_freak> have a second look at STM, it's really simple
19:45:48 <tolkad> I'm reading what you guys just said
19:45:57 <Cale> If you take the MVars in the opposite order, there's a possibility that neither thread succeeds in getting both, and things get blocked indefinitely.
19:46:15 <Cale> But yeah, the solution to that problem is STM
19:46:19 <mm_freak> Cale: i don't get it…  the values in an MVar are pure
19:46:44 <tolkad> mm_freak: one second, composing example
19:46:54 <mm_freak> whenever both are filled, you can take them, even if their actual values were calculated dependently (unless you use unsafeInterleaveIO)
19:47:03 <Cale> thread1 = do x <- takeMVar a; y <- takeMVar b; putMVar b (f a b); putMVar a (g a b)
19:47:10 <tolkad> Cale is faster
19:47:11 <tolkad> :P
19:47:20 <Cale> thread2 = do x <- takeMVar b; y <- takeMVar a; putMVar a (f' a b); putMVar b (g' a b)
19:47:29 <adnap> This is cool: http://conal.net/fran/tutorial.htm
19:47:41 <Cale> mm_freak: Imagine thread1 and thread2 are running in parallel
19:47:51 <Cale> mm_freak: (or I should say, concurrently :)
19:47:52 <luite> takeMVar chopstick
19:48:00 <mm_freak> Cale: yes, in that case STM is the solution
19:48:02 <NemesisD> im creating a newtype to wrap Integer, it says that Num is not a derivable type, so is there no way for me to get +, -, * for free?
19:48:13 <Cale> mm_freak: thread1 takes a, and thread2 takes b, and then neither one can proceed
19:48:20 <mm_freak> NemesisD: use -XGeneralizedNewtypeDeriving
19:48:40 <Cale> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
19:48:41 <jmcarthur> meh, i'll just hide the template-haskell package
19:48:47 <tolkad> Cale: couldn't that happen with one thread with concurrency? doesn't GHC unpredictably switch between unbound threads?
19:49:05 <Cale> tolkad: threads refer to Haskell threads, not OS threads, usually :)
19:49:08 <tolkad> oh
19:49:24 <NemesisD> mm_freak: thats like a compiler flag though isn't it? id prefer to do this in as standard a way as possible if that makes any sense
19:49:28 <Cale> I actually don't really think about OS threads most of the time
19:50:39 <Axman6> NemesisD: that is the standard way. you can only do it in ghc
19:50:42 <copumpkin> NemesisD: then no :)
19:51:17 <tolkad> NemesisD: you can't derive Num
19:51:44 <Cale> Use the LANGUAGE pragma if you're going to turn on the flag
19:51:46 <tolkad> NemesisD: there are specific set of classes that can be derived according to the haskell standard
19:52:19 <Cale> I'm not sure anything but GHC supports that one yet, but the LANGUAGE pragma itself is standardised
19:53:56 <Cale> NemesisD: The newtype deriving extension was basically specially created for your case though :)
19:54:41 * ezyang has a kind of love-hate relationship with newtype deriving 
19:54:44 <tolkad> it's strange... if you are in #C and you ask a question like that everyone will be like "that's undefined behavior! you are a bad person!" but in here you are told to enable some extension
19:54:52 <Cale> ezyang: What's to hate about it?
19:55:10 <ezyang> Cale: It encourages exposing instances that might not be appropriate given the level of abstraction the newtype is trying to enforce. 
19:55:14 <applicative> ezyang is there supposed to be some danger in it?
19:55:30 <Cale> tolkad: Well, it's either a syntax error, or it's well-defined, depending on whether the extension is turned on :)
19:55:34 <adnap> Whoa, did anyone notice instant search on Google today?
19:55:47 <mm_freak> NemesisD: see Cale's example…  you can encode the extensions you need in the source file, and haskell isn't that much like other languages:  extensions aren't considered to be evil =)
19:56:05 <Cale> ezyang: Well, you wouldn't derive instances which the newtype is designed to hide :)
19:56:07 <mm_freak> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
19:56:25 <applicative> ezyang, so you don't object to NemesisD's newtyping Integer, and then deriving everything
19:56:31 <ezyang> Cale: Yeah. 
19:56:32 <applicative> ?
19:56:38 <ezyang> But you have to be careful about which instances you pick. 
19:58:31 <copumpkin> applicative: well, you can hide the constructor of your newtype normally
19:58:43 <copumpkin> which will prevent you from writing instances that look inside, from other modules
19:58:48 <mm_freak> ezyang: well, deriving all those stuff everytime by hand would be painful
19:58:51 <copumpkin> except GNTD
19:58:55 <copumpkin> can see through that
19:59:03 <ezyang> mm_freak: Yeah. 
19:59:41 <mm_freak> newtype MyAppT m a = MyAppT (SomeMonadT m a) deriving (Applicative, Alternative, Functor, Monad, …)
20:00:00 <mm_freak> … MonadPlus, …
20:00:21 <applicative> copumkin, ok, i wasn't remembering that aspect.
20:01:13 <tolkad> copumpkin: how evil
20:01:13 <copumpkin> I'm pretty sure it can, anyway
20:01:23 <copumpkin> StandaloneDeriving + GNTD, that is
20:02:11 <tolkad> > do {return ()}
20:02:12 <lambdabot>   No instance for (GHC.Show.Show (m ()))
20:02:13 <lambdabot>    arising from a use of `M241057981...
20:02:28 <NemesisD> Cale: thanks!
20:02:39 <tolkad> > do$do return ()
20:02:40 <lambdabot>   <no location info>: Empty 'do' construct
20:02:47 <tolkad> > do $ do return ()
20:02:48 <lambdabot>   <no location info>: Empty 'do' construct
20:03:04 <tolkad> > do $ do {return ()}
20:03:05 <copumpkin> do is syntax
20:03:05 <lambdabot>   <no location info>: Empty 'do' construct
20:03:15 <tolkad> > do {do {return ()}}
20:03:16 <lambdabot>   No instance for (GHC.Show.Show (m ()))
20:03:16 <lambdabot>    arising from a use of `M517244899...
20:03:21 <tolkad> oh yeah, forgot
20:03:34 <djahandarie> It also does nothing if you only have a single function within it
20:04:04 <sidek> Is there any way to define the squaring (x^2) function recursively so it doesn't fail on very small decimals? 
20:04:10 <tolkad> they could make {…; …;… } a type
20:04:33 <copumpkin> sidek: fail? it's already recursive
20:04:55 <copumpkin> oh, well ^ is recursive
20:05:00 <sidek> Well, the function itself is
20:05:07 <sidek> I'm trying to work it out 
20:05:10 <copumpkin> how do you mean fail?
20:05:19 <copumpkin> you sure it isn't just an issue with floating point limited precision?
20:05:26 <sidek> ..it might be
20:05:28 <copumpkin> > 0.000001 ** 2
20:05:29 <lambdabot>   1.0e-12
20:05:35 <copumpkin> > 0.0000000001 ** 2
20:05:36 <lambdabot>   1.0000000000000001e-20
20:05:41 <copumpkin> > 0.000000000000000000001 ** 2
20:05:42 <lambdabot>   9.999999999999999e-43
20:05:47 <sidek> I'm trying to make a copy of the function
20:05:48 <copumpkin> > 0.000000000000000000001  2
20:05:49 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:05:49 <lambdabot>    `GHC.Num.Num t' arising f...
20:05:51 <copumpkin> > 0.000000000000000000001 ^ 2
20:05:52 <lambdabot>   9.999999999999999e-43
20:06:01 <sidek> but it already fails at 0.1^2
20:06:06 <tolkad> > 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 ** 2
20:06:07 <sidek> well, it's horribly imprecise
20:06:07 <lambdabot>   9.999999999999997e-187
20:06:10 <copumpkin> > 0.1^2
20:06:11 <lambdabot>   1.0000000000000002e-2
20:06:22 <sidek> let me check what it gives
20:06:26 <copumpkin> sidek: floats aren't designed for decimal values :)
20:06:32 <tolkad> > 0.29830291803982103801928309182309182093810294789034709827304987230947209374092734089273409823740928734092837409237409237419208019283098101 ** 2
20:06:33 <lambdabot>   8.89846309110722e-2
20:06:43 <Draconx|Laptop> copumpkin, _binary_ floats aren't, anyway.
20:06:45 <sidek> copumpkin : I guess, sadly, you're right
20:06:46 <copumpkin> they can only represent binary fractions 
20:06:59 <djahandarie> > (sin^2 + cos^2) 10
20:06:59 <sbahra> Hey copumpkin 
20:07:00 <lambdabot>   1.0
20:07:06 <copumpkin> hey sbahra :)
20:07:09 <djahandarie> > (sin^2 * cos^2) 10
20:07:10 <lambdabot>   0.20836725770653272
20:07:14 <copumpkin> sbahra: sorry! I forgot about your thing :( is it too late?
20:07:14 <sidek> my copy worked out the same as lambda bot did
20:07:22 <sbahra> copumpkin, no, never too late. :-)
20:07:39 <sbahra> copumpkin, if you're too busy, it's all good. I'd like this to be useful to someone other than me, so feedback is always appreciated.
20:07:50 <sidek> thanks.
20:07:51 <tolkad> > 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000129830291803982103801928309182309182093810294789034709827304987230947209374092734089273409823740928734092837409237409237419208019283098101 ^ 2 :: Rational
20:07:52 <lambdabot>   168559046699071426371803407183289729127660660424926774035966431794314951193...
20:07:52 <sbahra> copumpkin, have a minute in PM?
20:07:56 <copumpkin> sure
20:08:06 <tolkad> sidek: see how precise that was!
20:08:27 <tolkad> sidek: just use Rational and ^ and it will work just fine
20:08:28 <sidek> O_O
20:08:35 <sidek> alright
20:08:39 <sidek> so use :: Rational
20:09:14 <sidek> thanks
20:09:40 <djahandarie> > "hi" 1
20:09:41 <lambdabot>   Couldn't match expected type `t1 -> t'
20:09:41 <lambdabot>         against inferred type `[GHC....
20:10:11 <applicative> > 1 "hi"
20:10:12 <lambdabot>   1
20:10:48 <tolkad> sidek: if you want it to be slow but precise
20:11:00 <djahandarie> Of course Rational can only represent rational numbers
20:11:03 <tolkad> sidek: Rational is arbitrary precision
20:11:12 <djahandarie> Try something like CReal if you have irrationals
20:11:18 <djahandarie> > pi :: CReal
20:11:19 <lambdabot>   3.1415926535897932384626433832795028841972
20:11:28 <tolkad> that's not pi
20:11:30 <applicative> > pi :: Double
20:11:31 <lambdabot>   3.141592653589793
20:11:39 <djahandarie> (It would keep going if it wasn't for the show instance only asking for so many digits)
20:11:42 <tolkad> oh
20:12:04 <Axman6> > showCReal 100 pi
20:12:05 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
20:12:17 <tolkad> > showCReal 999999999999999999999999999 pi
20:12:18 <lambdabot>   "*Exception: Negative exponent
20:12:26 <djahandarie> It would keep going if lambdabot didn't truncate output :P
20:12:26 <tolkad> what
20:12:31 <djahandarie> Not sure what that error is
20:12:51 <tolkad> ooh showCReal probably takes an Int for the first argument
20:12:54 <applicative> > take -1 [1]
20:12:54 <djahandarie> Probably showCReal takes an int
20:12:54 <djahandarie> lol
20:12:55 <lambdabot>   Overlapping instances for GHC.Show.Show
20:12:55 <lambdabot>                              (GHC.T...
20:12:55 <djahandarie> yeah
20:13:01 <djahandarie> :t showCReal
20:13:02 <lambdabot> Int -> CReal -> String
20:13:13 <tolkad> ?src showCReal
20:13:13 <lambdabot> Source not found. My mind is going. I can feel it.
20:13:19 <tolkad> heh
20:13:22 <djahandarie> > showCReal maxBound pi
20:13:23 <lambdabot>   "*Exception: Negative exponent
20:13:33 <djahandarie> > showCReal (pred maxBound) pi
20:13:33 <lambdabot>   "*Exception: Negative exponent
20:13:36 <djahandarie> Eh
20:13:46 <djahandarie> > showCReal (maxBound/2) pi
20:13:46 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
20:13:47 <lambdabot>    arising from a use o...
20:13:50 <tolkad> > showCReal (maxBound :: Int16) pi
20:13:50 <djahandarie> Gah
20:13:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:13:51 <lambdabot>         against inferred type ...
20:13:54 <tolkad> > showCReal (maxBound :: Int16) pi
20:13:55 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:13:55 <lambdabot>         against inferred type ...
20:14:08 <tolkad> > showCReal (fromIntegral $ maxBound :: Int16) pi
20:14:09 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:14:09 <lambdabot>         against inferred type ...
20:14:16 <tolkad> > showCReal (fromIntegral (maxBound :: Int16)) pi
20:14:20 <lambdabot>   mueval-core: Time limit exceeded
20:14:25 <applicative> what is the negative exponent error?  maybe I dont want to know
20:14:27 <tolkad> > showCReal (fromIntegral (maxBound :: Int32)) pi
20:14:30 <mm_freak> tolkad: 'do' constructs are just sugar for monadic computations, so they have a type
20:14:32 <lambdabot>   mueval: ExitFailure 1
20:14:35 <djahandarie> applicative, something bad
20:14:54 <mm_freak> :t do l <- read <$> getLine; print l; print (l+1)
20:14:55 <lambdabot> IO ()
20:14:56 <djahandarie> It looks like the Int16 one worked though
20:14:59 <tolkad> applicative: somehow it's trying to convert an Int64 to an INt32
20:15:10 <mm_freak> tolkad: fromIntegral
20:15:21 <tolkad> mm_freak: not there, I mean before
20:16:06 <tolkad> > showCReal maxBound pi
20:16:06 <lambdabot>   "*Exception: Negative exponent
20:16:12 <tolkad> maxBound is a native int
20:16:17 <tolkad> in this case 64 bits
20:16:25 <tolkad> somewhere it is being cast to 32 bits
20:16:32 <tolkad> is my guess
20:17:22 <mm_freak> > (/ 10^5) . sum . map (sin^2 + cos^2) $ [1..10^5]
20:17:23 <lambdabot>   1.0
20:17:54 <mm_freak> > (/ 10^5) . sum . map (sin^2 + cos^2) . take (10^5) $ [0, pi ..]
20:17:55 <lambdabot>   1.0
20:18:08 <djahandarie> > ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4 $ (maxBound :: Int)
20:18:09 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Types.Int -> b))
20:18:09 <lambdabot>    arising from a ...
20:18:42 <djahandarie> > let f :: Int -> Int; f = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4 in f (maxBound :: Int)
20:18:43 <lambdabot>   No instance for (GHC.Real.Integral
20:18:43 <lambdabot>                     (GHC.Types.Int -> GH...
20:19:15 <djahandarie> Oh haha
20:19:22 <djahandarie> > let f :: Int -> Int; f d = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4 in f (maxBound :: Int)
20:19:23 <lambdabot>   -6254109448592744444
20:19:30 <djahandarie> There is the problem, I think
20:19:41 <djahandarie> > let f :: Int -> Int; f d = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4 in f (fromIntegral $ maxBound :: Int16)
20:19:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:19:43 <lambdabot>         against inferred type ...
20:20:01 <djahandarie> > let f :: Int -> Int; f d = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4 in f (fromIntegral $ (maxBound :: Int16))
20:20:02 <lambdabot>   108854
20:20:07 <djahandarie> > let f :: Int -> Int; f d = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4 in f (fromIntegral $ (maxBound :: Int32))
20:20:08 <lambdabot>   7133786265
20:20:13 * djahandarie nods
20:21:15 <djahandarie> Maybe I'll shoot augustss an email
20:37:00 <sidek> Does haskell ever hang and "freeze" when it is computing very CPU-taxing things?
20:37:31 <sidek> I tried to bruteforce something in haskell, but it's been sitting there for about 20 minutes
20:38:22 <sidek> IIRC, perl did this same thing in about 7
20:38:31 <sidek> maybe I've just not optimised the code well
20:38:55 <sidek> Oh: should not I am using GHC
20:38:58 <sidek> note
20:40:00 <handonson> i think it should be quite useful if there's a data type that represents a value between 0 and 1. perfect for probability, color range, relative coordinate on a canvas, etc. is there any?
20:40:44 <copumpkin> handonson: nope, but I've wanted one too
20:41:07 <copumpkin> you could implement one efficiently by treating a Word32 as / maxBound
20:41:44 <handonson> yeah, i'm using WordN family now
20:41:58 <copumpkin> you should make a simple one and package it up :)
20:42:02 <copumpkin> it'd wrap around as expected though
20:42:08 <handonson> just thought maybe there's something better, done by someone smarter than me :)
20:42:24 <iFire> anyone tried Leksah?
20:45:57 <kmc> sidek, did you compile your code, or are you using ghci?
20:46:07 <sidek> compiled
20:46:10 <kmc> ok
20:46:11 <kmc> -O2?
20:46:15 <sidek> actually, I thought that that question had been ignored
20:46:19 <sidek> nvm, now
20:46:22 <kmc> ok
20:46:26 <sidek> it worked
20:46:29 <sidek> just took a lot of time
20:46:44 <kmc> did you profile it to find out why?
20:50:02 <lispy> monochrom: so, I'm looking at the source of the haskell-mode now.
20:50:08 <lispy> monochrom: it's  haskell-indentation-mode-map that's evil
20:50:18 <lispy> monochrom: do you know if there is a way to tell haskell-mode to not set it?
20:50:22 <sidek> kmc: profile it?
20:50:43 <kmc> sidek, http://book.realworldhaskell.org/read/profiling-and-optimization.html
20:50:47 <sidek> alright
20:50:48 <sidek> thanks
20:51:03 <kmc> sidek, if your code is smallish and self contained, you can put it on hpaste.org and i'll try to figure out why it's slow
20:51:13 <lispy> oh, seems to be this function turn-on-haskell-indentation
20:51:13 <kmc> grr, make that codepad.org
20:51:15 <sidek> well, it needed to run once
20:51:18 <lispy> I need to make sure I'm not calling that
20:51:21 <sidek> so I didn't optimise it fully
20:51:28 <sidek> hurt me, I guess
20:51:33 <sidek> also, don't have much experience
20:51:37 <lispy> oh, wait, n/m
20:52:32 <sidek> thanks for the offer,though
20:53:55 <kmc> performance optimization in Haskell is tricky
20:55:24 <sidek> Well, I did a horrible job of it. I can immediately see three things that I told it to check for that I could've put down as one thing to check for. 
21:00:01 <dolio> Oh, we're going to 7.0 now.
21:01:59 <c_wraith> no 6.14?
21:02:13 <c_wraith> "this one goes to 7"
21:02:14 <dolio> Apparently.
21:13:16 <copumpkin> is there an easy way to jump to an address in some sort of low-level haskell?
21:13:48 <ddarius> copumpkin: You can cast the crap out of IntPtr/FunPtr
21:15:16 <jmcarthur> hey, who run lambdabot? i'm just curious
21:15:18 <jmcarthur> *runs
21:15:25 <ddarius> Cale and lispy.
21:15:34 <jmcarthur> copumpkin: the ai challenge is starting a new contest this friday :o
21:15:36 <ddarius> Cale is the admin, lispy simply hosts it.
21:15:53 <copumpkin> jmcarthur: ooh, maybe I can get famous this time too
21:15:57 <wli> jmcarthur: What kind of AI challenge?
21:15:58 <jmcarthur> heh
21:16:14 <jmcarthur> wli: bots compete in a game based on galcon (google it)
21:16:18 <jmcarthur> wli: ai-contest.org
21:16:19 <copumpkin> (I got lots of publicity on reddit for writing the worst-performing bot on the entire contest)
21:16:21 <copumpkin> "writing"
21:16:36 <jmcarthur> doh
21:16:38 <jmcarthur> not .org
21:16:40 <jmcarthur> it's ai-contest.com
21:16:43 <jmcarthur> wli: ^^
21:17:25 <jmcarthur> the video on the front page is the old visualization. somebody made a new one that will be a lot nicer
21:28:06 <copumpkin> ddarius: I want a jumpWithNoReturnFunPtr :: FunPtr a -> IO b
21:28:08 <copumpkin> :P
21:30:07 <ddarius> You can get anything you want with a suitable amount of unsafeCoerce magic.
21:31:12 <bss03> jmcarthur: I don't see a starter kit for Haskell. :(
21:38:50 <ferret_0567> what could "parse error on input `deriving'" mean?
21:40:04 <bss03> ferret: layout added a semi-colon before your deriving?
21:40:12 <jmcarthur> @where haskell-starter
21:40:12 <lambdabot> http://github.com/jaspervdj/planet-wars-haskell
21:40:15 <jmcarthur> bss03: ^^
21:40:48 <bss03> jmcarther: What's the time limit per turn?  I didn't see one in the rules?
21:41:51 <bss03> Found it.  Sorry.
21:41:56 <bss03> 1 sec.  Cool.
21:41:57 <ferret_0567> bss03: no
21:42:41 <bss03> ferret: Trying to use deriving on a type alias?
21:43:04 <ferret_0567> uh...
21:43:14 <ferret_0567> no, I am using it on the type class Show
21:44:00 <ferret_0567> I am using GHC 6.10.4
21:44:53 <bss03> hpaste?
21:46:05 <ferret_0567> ok....well I don't think this is the correct fibonacci function
21:46:08 <ferret_0567> but ok
21:47:47 <ferret_0567> oh wait, hold on a bit
21:56:40 <ferret_0567> what is a working way to write thiis in haskell? It makes perfect sense to me, but in Haskell it doesn't work :(
21:57:02 <ferret_0567> [ fib | (fib `mod` 2) == 0 ]
21:57:20 <Heffalump> ferret_0567: what range of values is fib supposed to cover before the guard is applied?
21:57:50 <Heffalump> > [ x | x <- [0..10], x `mod` 2 == 0 ]
21:57:51 <lambdabot>   [0,2,4,6,8,10]
21:58:02 <Heffalump> that's valid, because x is given a range and then a guard is applied
21:58:22 <bss03> filter ((== 0) . (`mod` 2)) fib
21:58:33 <bss03> > let fib = [1..10] in filter ((== 0) . (`mod` 2)) fib
21:58:35 <lambdabot>   [2,4,6,8,10]
21:59:10 <ferret_0567> Heffalump: oh, I see
21:59:30 <bss03> > let { fib' = 1 : 1 : zipWith (+) fib' (tail fib'); fib = take 20 fib'; } in filter ((== 0) . (`mod` 2)) fib
21:59:31 <lambdabot>   [2,8,34,144,610,2584]
21:59:51 <Heffalump> it's possible you want something like [ x | x <- fib, x `mod` 2 == 0 ] which is similar to the examples bss03 is giving.
22:02:00 <ferret_0567> [ x | x <- fib, x `mod` 2 == 0, x <= 4000 ]
22:02:10 <ferret_0567> that is infinite recursion?!?!
22:02:32 <ferret_0567> oh
22:02:32 <Heffalump> ferret_0567: what is? Your expression on its own isn't.
22:02:44 <kmc> it doesn't know that 'fib' is ordered
22:02:49 <Heffalump> if you said fib = [ x | x <- fib, ... ] then it would be
22:03:01 <kmc> so it doesn't know that it will never hit another element <= 4000 after the first one > 4000
22:03:08 <Heffalump> and in that case it really would recurse infinitely without producing any results
22:03:21 <ferret_0567> Heffalump: this is: fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
22:03:27 <bss03> > let { fib' = 1 : 1 : zipWith (+) fib' (tail fib'); fib = takeUntil (> 4000) fib'; } in filter ((== 0) . (`mod` 2)) fib
22:03:27 <lambdabot>   Not in scope: `takeUntil'
22:03:29 <Heffalump> but Haskell in general can express infinite recursion while still producing useful results quite well
22:03:30 <kmc> ferret_0567, this is the difference between 'filter' and 'takeWhile'
22:03:35 <bss03> :t takeWhile
22:03:35 <ferret_0567> oh
22:03:36 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:03:43 <kmc> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
22:03:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:03:44 <bss03> > let { fib' = 1 : 1 : zipWith (+) fib' (tail fib'); fib = takeUntil (<= 4000) fib'; } in filter ((== 0) . (`mod` 2)) fib
22:03:45 <lambdabot>   Not in scope: `takeUntil'
22:03:57 <bss03> > let { fib' = 0 : 1 : zipWith (+) fib' (tail fib'); fib = takeWhile (<= 4000) fib'; } in filter ((== 0) . (`mod` 2)) fib
22:03:59 <lambdabot>   [0,2,8,34,144,610,2584]
22:04:01 <Heffalump> ferret_0567: agreed, but it produces results thanks to lazy evaluation
22:04:25 <kmc> oh, i really like that use of the @-pattern
22:04:42 <kmc> > let fib@(_:tfib) = 0 : 1 : zipWith fib tfib in fib
22:04:43 <lambdabot>   Couldn't match expected type `a -> b -> c'
22:04:43 <lambdabot>         against inferred type `[...
22:04:51 <kmc> > let fib@(_:tfib) = 0 : 1 : zipWith (+) fib tfib in fib
22:04:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:05:26 <bss03> > let { fib'@(_:fibs') = 0 : 1 : zipWith (+) fib' fibs'; fib = takeWhile (<= 4000) fib'; } in filter ((== 0) . (`mod` 2)) fib
22:05:27 <lambdabot>   [0,2,8,34,144,610,2584]
22:06:29 <ferret_0567> what does zipWith do? oh...it adds every two elements of a list together, right?
22:06:48 <bss03> zipWith (+) add elements of two list together.
22:06:49 <Axman6> > zipWith f [a,b,c] [x,y,z]
22:06:50 <lambdabot>   Ambiguous type variable `c' in the constraints:
22:06:50 <lambdabot>    `GHC.Show.Show c'
22:06:50 <lambdabot>      a...
22:06:56 <Axman6> > zipWith f [a,b,c] [x,y,z] :: [Expr]
22:06:57 <lambdabot>   [f a x,f b y,f c z]
22:07:10 <bss03> zipWith applies it's firat argument to pairs drawn from parallel lists.
22:07:10 <Axman6> > zipWith (+) [a,b,c] [x,y,z] :: [Expr]
22:07:11 <lambdabot>   [a + x,b + y,c + z]
22:07:16 <bss03> @type zipWith
22:07:17 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
22:07:20 <bss03> @type zipWith (+)
22:07:21 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
22:08:10 <tolkad> Why do hs-boot files need to be seperate from the .hs file?
22:08:28 <bss03> > let { fib'@(_:fibs') = 0 : 1 : zipWith (+) fib' fibs'; fib = takeWhile (<= 40000) fib'; } in filter ((== 0) . (`mod` 2)) fib
22:08:29 <lambdabot>   [0,2,8,34,144,610,2584,10946]
22:08:53 <tolkad> it seems like it could be implemented so you have to write the types of everything but you could just put them in the .hs file
22:13:26 <ferret_0567> wow
22:13:30 <ferret_0567> thanks guys!
22:13:39 <ferret_0567> I just solved problem 2 on Project Euler!
22:14:10 <ferret_0567> all in two liines of code :)
22:15:24 <atude>  you think knuth would have a chance getting a job at google or microsoft?
22:15:59 <Heffalump> I'm sure either would jump to hire him for the publicity alone.
22:16:11 <kmc> google in particular hires people for this reason
22:16:13 <atude> lol
22:16:50 <Heffalump> which is not to say that he couldn't do a useful job for them as well - that I don't really know
22:17:03 <atude> I think it'd be a waste of time at microsoft
22:17:14 <atude> their products are well, I don't think I need to explain
22:17:24 <Heffalump> I think that's a pretty simplistic attitude.
22:17:28 <atude> google, he could probably work wonders
22:17:36 <atude> it probably is simplistic, 
22:17:36 <atude>   
22:17:36 <atude>  
22:17:39 <notabel> atude: SimonPJ works for microsoft
22:17:43 <atude> me too
22:18:18 <copumpkin> atude: MSR is very different from MS
22:18:24 <tommd> atude: You seem biased.  At any rate, I think ... oh, you too... anyway, I think MS has great work that they fail to transfer into great products.  Its a shame.  Perhaps that is what you mean by a waste at MS.
22:18:42 <Heffalump> even the MS product groups do lots of good things. E.g. .NET, C#, F#.
22:18:44 <atude> copumpkin: yeah, very
22:18:50 <atude> copumpkin: I can understand that
22:19:18 <atude> but to what extent is any of their technologies beneficial for anyone and suit their needs as they should be?
22:19:27 <atude> that'd be a totally different direction for ms to head
22:19:52 <atude> tommd: I can agree with that completely
22:20:41 <Heffalump> given the number of people that actually use MS technologies, I'd say to quite a large extent. It's not just that they bullied their way to dominance, people generally found their stuff more usable than the alternatives.
22:20:54 <atude> thinking on the level of knuth, doesn't doesn't reasonable to put him in a position where the outcome is less valuable than him as an asset
22:21:41 <Heffalump> that's a different question to whether he'd be useful to them
22:21:55 * Heffalump disappears
22:22:05 <copumpkin> a disappearing heffalump!
22:22:20 <tommd> Yeah, he can't hang out long or mobs of people ask him about Ants and ICFP.
22:22:24 <tommd> ;-)
22:23:05 <atude> Heffalump: that's one reason I tried to avoid giving reason as I has presumed that in the big picture, it'd be obvious :(
22:23:16 <atude> or at least, that
22:23:22 <atude> thats my perspective atm
22:24:40 <JoeyA> In Data.ByteString.Lazy, it does (with a macro):  readChunks i | i `seq` False = undefined; readChunks i = do ...
22:24:56 <JoeyA> Is that equivalent to readChunks i = seq i $ do ... ?
22:25:19 <JoeyA> and also equivalent to readChunks !i = do ... (with bang patterns enabled)?
22:25:22 <kmc> think so
22:25:26 <JoeyA> http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/src/Data-ByteString-Lazy.html
22:25:32 <kmc> the seq / false guard trick predates bang patterns
22:30:29 <nejucomo> This is slightly off topic, but I'm it seems like a topic functional language designers should have covered already:  Is it possible to translate a let expression with mutually recursive values into a lambda application?
22:30:59 <nejucomo> I think it is, but I'm hunting for references.  (Maybe more appropriate for a lisp channel?)
22:32:10 <ddarius> nejucomo: Without types, yes.  With types, no.
22:32:20 <ddarius> (or at least not with Haskell's type system)
22:32:25 <nejucomo> I see.  Thanks.
22:32:25 <atude> What advantage does Haskell have over python of C in terms of system programming or small scale application development?
22:32:41 <Martty> chicks
22:32:42 <nejucomo> I'm focusing on a dynamically typed language.
22:34:01 <ddarius> It's usually better to directly implement recursive lets.
22:34:24 <nejucomo> atude: IMO haskell provides type safety, but python has easier to understand execution time/space analysis.
22:34:52 <nejucomo> ddarius: Why is that?  For efficiency or simplicity of the language implementation?
22:36:08 <carter> nejucomo: you don'tneed to use boxing if you implement them directly
22:36:27 <kmc> atude, Haskell provides for lots of compile-time checking.  if your code compilers, there is a good chance it works
22:36:30 <carter> if i'm following the convo thread directly
22:36:35 <carter> *correctly
22:36:43 <nejucomo> I see.  So boxing is where you wrap up the recursive bindings as hidden arguments in an inner function?
22:36:48 <carter> noope
22:36:53 <kmc> also GHC-compiled Haskell is typically much faster than typical Python interpreters
22:36:56 <carter> thats using the y combinator
22:37:10 <atude> kmc: how much faster?
22:37:13 <carter> boxing is when you do let var = ref  thing
22:37:25 <kmc> atude, depends on problem obviously
22:37:29 <kmc> atude, see http://shootout.alioth.debian.org/
22:37:29 <carter> then create the closure in the env with the ref
22:37:35 <nimred> hello all
22:37:38 <carter> and then set the var to be a ref to the closure
22:37:49 <nimred> why ld cannot find gmp.h : http://haskell.pastebin.com/PY2KiXnY ?
22:38:09 <carter> nejucomo: theres some really good scheme papers about the trade offs that hapepn
22:38:32 <carter> is the language you're playing with to have strict semantics?
22:38:35 <carter> or lazy?
22:38:51 <kmc> nejucomo, you can't write «fix :: (a → a) → a» in the simply typed lambda calculus
22:39:12 <kmc> one proof is to observe (by Curry-Howard) that STLC is equivalent to predicate logic
22:39:24 <kmc> and «(a → a) → a» is clearly not a theorem of predicate logic
22:39:32 <nejucomo> carter: dynamic, strict.
22:39:50 <kmc> actually s/predicate/propositional/ i think
22:39:56 <kmc> no quantifiers in STLC
22:40:04 <carter> nejucomo http://www.cs.indiana.edu/~dyb/pubs/letrec-reloaded.pdf
22:40:11 <carter> is the paper you should look at i htink
22:40:22 <nejucomo> You guys are way over my head.  I'm not well read on language design, so I'm unfamiliar with Y-Combinator, STLC, etc...
22:40:34 <carter> and http://www.cs.indiana.edu/~dyb/pubs/fixing-letrec.pdf
22:40:37 <nejucomo> carter: Looks perfect for me!  Thanks!
22:40:46 <carter> those are the two things that you care about
22:41:03 <carter> kent dyvbig's stuff is all good
22:41:07 <carter> so read it all!
22:41:22 <carter> i did some stuff in hs playing with these sorts of ideas
22:41:35 <dibblego> is there anything like FileManip which doesn't depend on unix?
22:41:51 <carter> nejucomo : you may want to play with how you define the stuff as macro in racket scheme first
22:41:56 <carter> to make sure you get the semantics you want
22:42:06 * hackagebot AttoJson 0.5.3 - Simple lightweight JSON parser, generator & manipulator based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.3 (HiromiIshii)
22:42:06 <carter> withouth dealing with the question of everything else at the same time
22:43:21 <carter> because http://racket-lang.org/ (formerly plt scheme) has very nice debugging facilities that would make life sane for playing with macro defs to explore different hcoices in semantics without getting bogged down by evernthing else
22:44:26 <nejucomo> So I stumbled upon this issue in my last iteration of invent-my-own-language while implementing in haskell:  I wanted to define scopes purely, but it seemed I had to require the scope to be mutable in order to implement mutual recursion.
22:44:46 <nejucomo> (as in, create function instances with a mutable reference to a scope which gets updated after their definition…)
22:45:11 <carter> nejucomo you don't need that
22:45:30 <carter> you can do the parameter passing trick
22:45:41 <carter> or 
22:45:48 <carter> well
22:45:49 <carter> hrmm
22:45:59 <carter> does your toy lang have mutable variables or no?
22:46:19 <nejucomo> At this point I'm leaning towards simple mutable references to scope, because I feel like the execution semantics are easy to understand.
22:46:43 <carter> i'm assuming that either way, you're writing an environment passing interpreter, right?
22:46:46 <nejucomo> carter: Actually I want to make a strict, dynamically typed language that also distinguishes between purity and side-effects.
22:47:05 <carter> distinguishes between them how?1
22:47:16 <carter> nejucomo: syntactially?
22:47:18 <carter> or?
22:47:46 <carter> kinda how python has statements vs expressions?
22:47:56 <nejucomo> carter: I'm not certain what env passing is, but my approach is to have a reference mapping as scope which delegates to scopes up the lexical chain.
22:48:10 <nejucomo> carter: Yes, by syntax distinctions.
22:48:44 <nejucomo> Although I'm also curious about how far I can push static analysis to "reclaim as pure" code that uses mutations internal to its execution frame.
22:49:06 <carter> nejucomo: thats hard
22:49:07 <nejucomo> Are there languages like this?
22:49:11 <carter> and that i mean, research level hard
22:49:16 <nejucomo> hehe...
22:49:52 <carter> and by research level hard, i mean the ninjas gods of plt who have beards older than you, they work on it
22:50:00 <carter> and think it hard
22:50:02 <carter> :p
22:50:25 <carter> new ideas are always welcome
22:50:27 <carter> hang on
22:50:31 <carter> let me dig up some refs
22:51:34 <carter> http://www.cs.cmu.edu/~jcr/
22:51:45 <carter> anything by john reynolds on separation logic
22:51:53 <carter> or hoar e logic
22:52:01 <carter> you can also just generally google
22:52:08 <carter> "hoare logic"
22:52:11 <carter> and "separation logic"
22:52:26 <carter> separation logic is the kind that can express your idea
22:52:26 <nimred> any idea ?
22:52:35 <carter> nimred  what idea?
22:52:38 <ddarius> You might be interested in http://lambda-the-ultimate.org/node/4019
22:53:03 <carter> ddarius  what does it actually do?
22:53:21 <carter> i'm looking at that
22:53:23 <nimred> carter about what i posted. See above
22:54:04 <carter> nimred  i'd say run it again with -v 
22:54:14 <carter> and add some of the stuff its complaining about like bytestring
22:54:21 <carter> to the cabal install --reinstall
22:54:35 <carter> so do 
22:54:36 <carter> eg
22:54:51 <carter> cabal install --reinstall zlib container array bytestring 
22:55:04 <carter> though.... why the old version of ghc?
22:55:26 <carter> nejucomo : did what I say make sense?
22:55:42 <nimred> carter cabal is not yet installed...
22:55:54 <nimred> carter because it is the one included in pkgsrc :)
22:56:01 <carter> .... nimred why don't you have a haskell platform install ?
22:56:07 <chemuduguntar> is it possible to do this: myfun x < 2 =... ?
22:56:37 <kmc> what would that mean?
22:56:41 <kmc> myfun x | x < 2 = ... ?
22:56:47 <nejucomo> carter: Which part?  All the references are appreciated.  I'm not familiar with the taxonomy of various logics or how exactly they relate to computation (had a slight intro to lambda calculus in college, that's about it).
22:56:50 <nimred> carter here is what pkgsrc includes : http://pkgsrc.se/search.php?so=haskell
22:57:02 <chemuduguntar> kmc, i am just trying to understand why guards are needed at all
22:57:04 <nimred> carter knowing wip is Work In Progress
22:57:13 <nejucomo> Thanks a lot for the feedback!
22:57:18 <kmc> chemuduguntar, pattern-matching can't evaluate arbitarry boolean expressions
22:57:19 <chemuduguntar> presumably pattern matching only goes are far as matching types
22:57:21 <kmc> it's structural only
22:57:24 <carter>  nejucomo : basically seperation logic lets your reason about parts of the heap
22:57:32 <kmc> no, it goes as far as matching constructors
22:57:39 <carter> so you can reason about only the parts of the heap you touch
22:57:57 <carter> and then at the end say "look, its back to the way it was at the begining of this block of code"
22:58:00 <chemuduguntar> ah ok
22:58:05 <nimred> carter add -v to what ?
22:58:20 <carter> nimred sorry, i forgot you dokn't have cabal isntall
22:58:20 <nejucomo> carter: Oh nice!  Exactly the kind of problem I was just beginning to wonder about.
22:58:33 <carter> nejucomo its HARD
22:58:47 <carter> nejucomo http://ynot.cs.harvard.edu/
22:59:02 <carter> i spent a summer struggling to do anything with that stuff
22:59:11 <nimred> carter the pastebin output is from running ./bootstrap.sh from cabal-install...
22:59:37 <carter> nimred ahh... well, i'm probably not the right person to aske for help
22:59:56 <carter> nimred i wimp out if i can't use one of the installers in http://hackage.haskell.org/platform/linux.html
23:00:47 <carter> nejucomo, 
23:00:55 <nimred> carter :
23:00:55 <nimred> [~/cabal-install-0.8.2]->> pkg_info | grep ghc
23:00:55 <nimred> ghc-6.8.3nb2        Compiler for the functional language Haskell
23:01:10 <nimred> GHC 6.12.3 is required for platform
23:01:16 <nimred> and i am running NetBSD
23:01:20 <carter> nimred why can't you use that?
23:01:52 <nimred> or perhaps from cabal
23:01:55 <carter> nimred  http://haskell.org/ghc/distribution_packages.html#netbsd
23:01:57 <nimred> but when installed...
23:02:03 <carter> tada!
23:02:08 <carter> if that hehlps
23:02:12 <nimred> sure it is
23:02:18 <nimred> GHC is installed
23:02:26 <nimred> but not cabal
23:02:29 <carter> nimred ok
23:02:37 <carter> but maybe you want to make sure you have a more current ghc first...
23:02:57 <nimred> once more the pastebin output is from cabal-install's ./bootstrap.sh 
23:03:12 <carter> nejucomo : the point i was saying
23:03:19 <nimred> so my problem is installing cabal
23:03:32 <nejucomo> So suppose I drop separation logic and just focus on syntactic quarantine of side-effects.  Are there already dynamically typed strict languages like that?
23:03:34 <carter> nimred your output says ghc 6.8.
23:03:50 <nimred> yes : ghc-6.8.3nb2
23:03:59 <nimred> shouldn't it be OK ?
23:04:04 <carter> nimred  you may want to have a 6.12 build 
23:04:12 <carter> idk
23:04:16 <nimred> not included in pkgsrc
23:04:21 <nimred> except WIP
23:04:29 <nimred> but not working yet
23:04:45 <nimred> http://pkgsrc.se/search.php?so=ghc
23:04:56 <carter> nimred  http://www.haskell.org/ghc/download_ghc_6_12_3.html may have hints?
23:04:58 <carter> nejucomo 
23:05:03 <carter> so basically
23:05:11 <carter> you want a dynamic version of monad?
23:05:30 <carter> you can do that
23:05:47 <kmc> "monad" has nothing to do with syntactic quarantine of side effects
23:05:54 <kmc> it barely has anything to do with side effects
23:06:19 <kmc> it's the name for a general API which is useful for manipulating, among many other things, first-class effect-descriptions
23:06:20 <nimred> carter getting GHC from http://www.haskell.org/ghc/download_ghc_6_12_3.html would mean i have to compile it by hand :(
23:07:13 <kmc> Haskell has a) effect-free evaluation, and b) execution of effects described by first-class values
23:07:29 <kmc> whether you use monads or some other API is secondary
23:07:29 <carter> kmc monad is an algebraic abstraction
23:07:36 <nejucomo> kmc, carter: Right, I didn't think of syntactic quarantine in a dynamic language as closely related to monads.
23:07:51 <carter> nejucomo : kmc they are related
23:08:05 <carter> the algebraic rules for monads are a good metaphor
23:08:07 <carter> eg
23:08:14 <carter> consider lower school "cooties"
23:08:24 <carter> once you have them, you can't remove em
23:08:34 <carter> unless theres a special rool
23:08:39 <carter> *rule
23:08:48 <carter> and everything that interacts with the "cooties"
23:08:49 <carter> gets them
23:08:57 <kmc> this property is often misunderstood though
23:09:04 <carter> yes
23:09:10 <carter> i don't care about the pedagogy 
23:09:11 <kmc> because while the monad api itself provides no way to remove the monadic type constructor, most individual monads do
23:09:17 <carter> kmc i know
23:09:32 <carter> i'm saying
23:09:36 <kulin> i hate cooties
23:09:42 <kmc> anyway this property is one of the things that makes Monad a useful API for manipulating IO actions
23:09:47 <carter> kmc
23:09:55 <carter> i think everyone here knows that
23:10:05 <carter> (ih ope)
23:10:09 <carter> i'm just saying
23:10:24 <carter> that nejucomo is asking about an information flow question
23:10:24 <kmc> well i'm not sure why you brought up monads in the first place
23:10:30 <carter> let me explain
23:11:04 <carter> nejucomo : you basically want a rule that tags the result of every calculation that depends on side effectfuls tuff?
23:11:36 <carter> and basically lets you do a query on values
23:11:54 <nejucomo> yes, where I envision that rule being syntactic distinction (ie: There's a "pure call" and an "impure call" and the former checks at runtime that the target must be pure.)
23:12:00 <carter> yes
23:12:06 <carter> hrmmm
23:12:15 * hackagebot hmatrix-static 0.3.0.1 - hmatrix with vector and matrix sizes encoded in types  http://hackage.haskell.org/package/hmatrix-static-0.3.0.1 (ReinerPope)
23:12:22 <carter> lets pretend that we have  type system in your lang for a sec
23:12:24 <carter> in that case
23:12:32 <carter> you'd be using a monad if it was haskell
23:12:33 <carter> yes?
23:12:39 <nejucomo> Yes.
23:12:42 <carter> ok
23:12:46 <carter> the reason being
23:12:54 <carter> once you put it into impure
23:13:00 <carter> you never want to think its pure
23:13:10 <kmc> as i said before, i think mentioning monads here is a distraction
23:13:11 <carter> monad laws let you put stuff in a box
23:13:16 <carter> kmc : shhhh
23:13:17 <kmc> you have values representing effects, and *some* API for manipulating them
23:13:22 <carter> kmc shhh
23:13:29 <carter> please
23:13:35 <carter> let me complete my thoughts
23:13:38 <nejucomo> I'm a bit confused on that point.  Can't I write haskell code in the ST Monad that performs state manipulations, but they are safely separated allowing the outside to call them purely?
23:13:48 <carter> nejucomo yes
23:13:56 <carter> nejucomo thats by doing the runST
23:13:58 <carter> bit
23:14:05 <carter> which isn't a monad law
23:14:13 <carter> the only two monad laws
23:14:18 <carter> are "you can put stuff in a box"
23:14:40 <nejucomo> Right, so the "hard problem" seems to be I want to "automagically determine" which parts of a dyn/strict program can be wrapped into the equivalent of runST.
23:14:42 <carter> and "if you promise to put what you make in a box, you can take the ingredients briefly out of this other box"
23:14:46 <carter> yes
23:14:58 <carter> so you can do it as follows
23:15:10 <carter> you can have  "ref" like tag
23:15:11 <kmc> those aren't monad laws
23:15:18 <kmc> those are the types of the monad functions
23:15:38 <kmc> the monad laws are that (<=<) and return form a category
23:15:48 <carter> kmc  : yes and the monad laws are the equations that hold on those functions
23:15:57 <carter> a bad choice in phrasing on my part
23:16:09 <carter> they're one and the same
23:16:10 <kulin> you know when they start teaching history, they teach that columbus discovered america
23:16:22 <carter> kulin : true, but the vikings are cooler
23:16:24 <carter> :)
23:16:25 <kmc> they're not the same at all, you can't derive identity/associativity from the type of return and (>>=)
23:16:45 <ddarius> kulin: The difference between Columbus and the others is that when he discovered it, it stayed discovered.
23:16:45 <carter> kmc: i'm sorry that my language is sloppy
23:17:09 <kulin> ddarius, well my point being that the whole truth is not usually a good starting point for sharing knowledge :)
23:17:23 <carter> kulin, thats a good koan
23:17:26 <carter> :)
23:17:53 <carter> i'd not state it nearly as elegantly at this hour
23:18:21 <carter> nejucomo : the you might implement it, is enrich your value type, eg Val
23:18:29 <carter> to have a case
23:18:37 <carter> like Impure Val
23:18:44 <carter> or something
23:19:02 <carter> or maybe have it be the Val is the underyling thing
23:19:14 <carter> and you can have one of Pure Val, Impure Val, or Ref Val
23:19:41 <carter> and have some in language primitive for asking if something is a ref
23:19:48 <carter> or if something is pure vs impure
23:19:55 <carter> nejucomo : does that clarify what I was trying to say?
23:21:15 * nejucomo rereads trying to pull out the thread.
23:22:00 <carter> and you have some rule that all the primitive things, if one of the imputs is a ref or impure val, then the result is an impure val>?
23:22:33 <carter> if i need to rephrase something coherently, let me know
23:22:43 <nejucomo> Ah, I wasn't imagining *values* being colored for impurity.  Instead the primitive types are all pure except there are two function types: pure and impure.
23:22:57 <nejucomo> So I guess there is a single impure value type: impure functions.
23:23:57 <carter> nejucomo: some prim ops have to give impure results, eg the io functions,  or anything involving setting refs
23:24:02 <carter> (and maybe reading refs?)
23:24:28 <roconnor> nejucomo: I haven't read back but your conclusion sounds incorrect
23:24:45 <nejucomo> Oh right, so there are builtin primitives of the type "impure function" including a mutable ref type and IO stuff.
23:25:04 <carter> yes
23:25:07 <roconnor> everything in Haskell is pure, even IO.
23:25:12 <nejucomo> roconnor: Which conclusion?
23:25:17 <carter> and then their results get tagged "impoure"
23:25:24 <kmc> roconnor, we're talking about a hypothetical language
23:25:27 <roconnor> oh
23:25:33 <roconnor> ok
23:25:37 <kmc> nejucomo, what is an "impure value"? a value whose evaluation causes effects?
23:25:51 <nejucomo> carter: No, the resulting values do not get tagged impure.  Instead the resulting values cannot be computed outside of an impure function.
23:26:13 <carter> nejucomo but then how do you know when a function is impure?
23:26:20 <nejucomo> I wonder if we're describing the same thing, but I'm just confused about the terms used.
23:26:27 <carter> nejucomo  the problem is that you wind up needing to a a static analysis
23:26:36 <nejucomo> carter: It is known statically because it uses the impure syntax.
23:26:37 <kmc> nejucomo, a function probably does not have effects when evaluated, only when applied
23:26:38 <carter> if you do it that way
23:26:54 <nejucomo> Right, there's "static analysis" in the parser.  It's incredibly simplistic.
23:26:59 <kmc> and so i think you'd want types for pure and impure functions, and syntactic constructs for pure and impure application respectively
23:27:09 <carter> how about try both ideas and see which works nicer for you?
23:27:16 <nejucomo> :-)
23:27:16 <NemesisD> is it possible to define a newtype with a default value if none is supplied?
23:27:21 <kmc> and the rule for impure application is the only rule in your language's semantics which causes effects
23:27:26 <kmc> NemesisD, what do you mean?
23:28:04 <kulin> is there even such a thing as a default value in haskell?
23:28:05 <NemesisD> kmc: i suppose in terms of haskell, a form of the constructor which takes no argument
23:28:29 <kmc> NemesisD, you can define that yourself as an ordinary value
23:28:31 <carter> nejucomo the problem with with the impure application would be that you can't even be like "yes, theres an effect inside, but its not externally observable"
23:28:32 <NemesisD> MyType nothing? = MyType 1
23:28:44 <kmc> newtype Foo = Foo Int; defaultFoo = Foo 0
23:28:52 <nejucomo> carter: So now that you mention "both" ideas, I'm aware I don't understand your proposal.  What kmc suggested sounds like what I imagined implementing.
23:29:00 <kmc> anyway no there's no special construct for it
23:29:05 <carter> nejucomo what I mean is:
23:29:12 <NemesisD> kmc: oh i see, but it cannot have the same name as the constructor then?
23:29:16 <kmc> right
23:29:18 <nejucomo> To me your proposal sounds like runtime painting of all values as to whether or not they are the result of side effects?  I don't follow.
23:29:21 <kmc> because otherwise what would its type be?
23:29:31 <carter> nejucomo yes
23:29:44 <carter> because that still lets you at run time check the things you want
23:29:59 <carter> and you can still do the static analysis if you like
23:30:17 <carter> but without needing to complicate eg the function application syntax 
23:31:00 <nejucomo> I'm curious if anyone has read this yet?  (I have not, but have some exposure to MarkM's ideas)  https://www.cypherpunks.to/erights/talks/thesis/markm-thesis.pdf
23:31:49 <nejucomo> carter: So the design goal with that approach is a simple imperative language, but clever runtime analysis to gain some of the benefits of purity?
23:31:59 <carter> nejucomo exactly
23:32:11 <carter> because you want your lang to be dynamicly typed
23:32:15 <carter> rather than static
23:32:37 <nejucomo> Huh…  Hadn't thought of that, but I suppose I just assumed that would be very hard and the syntactic separation trick might be a "simple hack"...
23:32:56 <carter> and the difficulty with your other approach is that it will  reject lots of valid programs
23:33:46 <carter> whereas what you might want to instead do is later go back and figure out clever static analyses that let you statically say a computation that would naively return an "impure" value, actually returns a value that acts "pure"
23:34:11 <carter> and have that not disturb the syntax
23:34:25 <nejucomo> Interesting.
23:34:53 <carter> because any predicates that do stuff with impure vs pure values,
23:35:00 <nejucomo> I'm curious how forcing side-effects quarantine into the syntax would affect API design and readability.
23:35:04 <carter> are like hints of saying "optimize me a way when you know more"
23:35:08 <carter> fair
23:35:23 <nejucomo> It seems like a bit of a middle ground between static typing + purity a la haskell versus dynamic imperative a la javascript or python.
23:35:33 <carter> you can do a simple propagation thing that lets you query if a function may return an impure value
23:35:45 <carter> like
23:35:49 <carter> before run time
23:36:02 <carter> have an analysis that just goes through ever branch
23:36:07 <carter> and sees if theres impure stuff
23:36:16 <carter> and tag the closure / function value appropriately
23:36:35 <carter> and then you can later add moreclever stuff
23:36:52 <nejucomo> Yes, I imagined going down that route...
23:37:15 <carter> awesome :)
23:37:33 <carter> i guess i'm just trying to argue for a simpler core language
23:37:49 <carter> to make your life easier and the experimenting funner
23:38:14 <carter> because syntax shouldn't be the part that gets you stuck figuring things out
23:38:15 <carter> :)
23:38:31 <nejucomo> :-)
23:39:06 <carter> because every language can be given scheme syntax
23:39:14 <carter> if need be :p
23:39:26 <carter> (at the cost of confusing syntax errors)
23:39:37 <carter> anywho
23:39:42 <carter> i think i've said my bit
23:40:14 <carter> any bit that need more clarification?
23:42:37 <carter> 'cause i'm bouncing out soon
23:42:52 <deteego> is this another language war?
23:44:50 <carter> deteego: nope, I just got very very into suggesting a simpler way to play with a toy language than one initially proprosed if you want to do some sort of effects tracing sans type system
23:45:12 <carter> I think...
23:46:12 * carter shrugs, 
23:47:31 <deteego> righteo then
23:47:50 <deteego> carry on
23:48:16 <carter> the last bit was must me asking nejucomo if he wanted me to further clarify the idea i was espousing
23:48:28 <carter> which would the work focus on stuff thats not related to syntax
23:48:33 <carter> *would let the work
23:49:01 <nejucomo> It's not a language war, it's a language arms race.
23:49:13 <carter> mwhahah
23:49:37 <carter> first one to using dependent types to get sub C  timings wins
23:50:16 <dolio> The race is over, then.
23:50:29 <carter> dolio you mean it got stuck on a proof goal? :p
23:50:42 <carter> sub c timings = faster than
23:50:44 <dolio> I mean ATS beats C on the language shootout some.
23:51:07 <dolio> And it doesn't even have 'real' dependent types.
23:51:12 <carter> ATS isn't full depenednet types
23:51:16 <carter> i was just about to say that :p
23:51:34 <carter> http://www.cs.bu.edu/~hwxi/ATS/ATS.html for those who dont' know
23:51:46 <carter> i mean http://www.ats-lang.org/
23:52:13 <carter> dolio does it use the info to optimize better?
23:52:46 <dolio> I haven't really looked into it much.
23:53:10 <carter> http://shootout.alioth.debian.org/u32/program.php?test=knucleotide&lang=ats&id=2
23:53:50 <carter> it seems to only win on the k nucleo tide
23:54:19 <dolio> People have been improving the C programs, I think.
23:54:23 <dolio> Not sure the same is true of the ATS.
23:54:28 <carter> and in several cases its more verbose
23:54:30 <dolio> ATS used to win more.
23:54:34 <carter> cool
23:54:47 <carter> was this just because there was more cleverness in the ATS code writer though?
23:54:48 <dolio> Of course, the ATS also uses lots of embedded C, last time I checked.
23:55:23 <carter> or is it because the compiler knows more invariants that it can use?
23:55:34 <dolio> No idea.
23:55:46 <carter> from the code, i want to say the former :/
23:58:23 <carter> whereas what would be awesome is you have a HL lang with dependent types
23:58:34 <carter> and to optimize code
23:58:46 <dolio> That's the dream.
23:58:46 <carter> you just prove more invariants
23:59:04 <carter> and if you really really want to optimize
23:59:28 <carter> you  prove invariants of the inside the compiler forms
