00:01:20 <kmc> ddarius, using only Prelude instances as well?
00:01:41 <ddarius> Not for the last.
00:01:48 <EliasAmaral> :t \x fs -> map ($ x) fs
00:01:49 <lambdabot> forall a b. a -> [a -> b] -> [b]
00:01:58 <etpace> :ty flip
00:02:02 <etpace> :t flip
00:02:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
00:02:20 <ddarius> :t Prelude.flip
00:02:21 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
00:02:27 <etpace> > flip [(+1),(+2),(*3)] 5
00:02:28 <lambdabot>   [6,7,15]
00:02:56 <EliasAmaral> not exactly a -> [a -> b] -> [b]..
00:02:57 <ddarius> That flip isn't in the Prelude.
00:02:58 <etpace> > flip flip 5 [(+1),(+2),(*3)]
00:02:59 <lambdabot>   [6,7,15]
00:03:11 <etpace> yeah, im not sure with prelude
00:03:12 <ddarius> or, in fact, in any library.
00:03:15 <EliasAmaral> :t (flip flip)
00:03:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
00:03:34 <EliasAmaral> o.o
00:03:47 <EliasAmaral> :t (Prelude.flip Prelude.flip)
00:03:48 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
00:03:54 <kmc> :t fmap fmap
00:03:55 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
00:04:10 <etpace> :t sequence
00:04:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:04:57 <etpace> well im stumped :)
00:05:15 <kmc> i know the answer to ddarius's first puzzle but not the last
00:05:59 <EliasAmaral> kmc, then share :>
00:06:58 <ddarius> kmc: I flipped the args and I did say you'd need non-standard instances.
00:07:12 <ddarius> Albeit, not instances that conflict with the standard.
00:07:27 <etpace> non-standard instances?
00:07:36 <ddarius> Instances not defined in the Report.
00:07:43 <kmc> instances not defined in Haskell Platform?
00:07:56 <ddarius> I'm fairly confident they are in the HP.
00:08:40 <ddarius> I've been using the word "standard" here to mean in the libraries defined by the Report.
00:10:51 <ddarius> data Map k v = MB k (Map k v) (Map k v) | MD k v | MT
00:12:31 * ddarius needs to check if a category object in the category of endofunctors is more or less equivalent to a lax functor.
00:19:23 <mm_freak> ok, the GHC from the latest haskell platform doesn't work in WINE
00:19:48 <mm_freak> % wine ghc -O2 --make test.hs
00:19:52 <mm_freak> spawnv failed: errno 2: No such file or directory
00:20:09 <mm_freak> and ghci doesn't work, tooâ€¦  it fails at hGetEcho
00:20:37 <mm_freak> % wine ghci
00:20:41 <mm_freak> <stdin>: hGetEcho: failed (failed to get echoing)
00:20:56 <mm_freak> does anyone know how to resolve these?
00:31:08 <ddarius> mm_freak: Don't use wine.
00:31:56 <mm_freak> using a VM is very inconvenient
00:32:06 <mm_freak> how do you people build your windows programs?
00:32:12 <mm_freak> (switching to windows doesn't count)
00:32:20 <ddarius> I built mine in Windows.
00:36:57 <mm_freak> well, older versions of GHC work well in WINE, so isn't this actually a GHC bug?
00:37:50 <ddarius> I'm pretty sure GHC HQ gives absolutely no guarantees in how GHC will behave under WINE.
00:37:56 <ddarius> So, no, it isn't a bug.
00:37:57 <aydeini> haskell was created to become an open standard for functional programming languages right?
00:38:10 <ddarius> aydeini: Something like that, yes.
00:38:33 <kmc> aydeini, for lazy, statically-typed functional programming in particular
00:38:35 <ddarius> mm_freak: You can probably finagle it to work if you explore the errors a bit more.
00:38:42 <kmc> Haskell is pretty unusual in the world of "classical" FP
00:39:51 <aydeini> what would be the big difference of haskell vs miranda? reading up on them they seem pretty much identical
00:40:02 <kmc> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/
00:40:23 <ddarius> aydeini: They are.  Originally, people wanted to just use Miranda but legal reasons stopped that among other reasons.
00:40:48 <aydeini> i see, thanks mate
00:40:49 <ddarius> But, yes, if you are interested in this stuff read the paper kmc linkde.
00:41:29 <kmc> aydeini, you'll see big differences if you look at "real world" stuff like compilers (and the languages they support), library availability, etc.
00:41:53 <aydeini> so haskell is just larger i suppose?
00:42:13 <kmc> by "languages" i should have written "extensions"; GHC supports many extensions beyond standard Haskell
00:42:32 <ddarius> Miranda is dead.
00:42:37 <kmc> i don't think many people use miranda today
00:43:02 <aydeini> i got this little school project to write very briefly about some functional programming languages
00:43:10 <aydeini> miranda was quite hard to find stuff about
00:43:26 <kmc> aydeini, start a controversy by claiming that Javascript is the world's most popular functional programming language
00:43:50 <koala_man> haha
00:43:58 <aydeini> javascript was the first language we were taught xD
00:44:21 <kmc> every so often there's a reddit post about how Javascript is so awesome because it has first class functions!
00:44:46 <ddarius> Javascript is so close to being a reasonable language.
00:45:09 <Adamant> it's close enough, especially if you're outputting to it.
00:46:34 <danderson> kmc: holy shit, first class functions? Stop the presses, this is huge!
00:46:40 <kmc> yup
00:46:49 <kmc> amazing new discovery
00:47:04 <kmc> but I hear Java and C++ have already committed to supporting it
00:47:07 <aydeini> ah, i see
00:47:09 <kmc> in the next versions
00:47:14 <aydeini> miranda only supported unix back the
00:47:15 <aydeini> n
00:47:16 <danderson> ah, so the future is nearly here
00:47:18 <danderson> excellent
00:47:30 <kmc> yes, the future, brought to you by ORACLE
00:49:02 <ddarius> The Future brought to you by The Hamiltonian: Get all your symplectic invariants at The Hamiltonian.
00:49:03 <aydeini> what would be the greatest use of haskell? what general area?
00:49:21 <vanadium> monad tutorials
00:49:32 <Adamant> aydeini: it's especially useful for work with languages (computer and natural)
00:49:36 <ddarius> Most often for programming, but occassionally for art or storytelling.
00:49:49 <Adamant> as BONUS shows
00:50:08 <kmc> aydeini http://www.haskell.org/haskellwiki/Haskell_in_industry
00:50:15 <aydeini> thanks guys
00:50:27 <ddarius> "Greatest use: lawn mowers"
00:50:31 <olsner> also, probably the most popular language for writing monad tutorials
00:50:34 <Adamant> aydeini: high assurance/stability stuff
00:50:42 <Adamant> is also where it is popular
00:50:49 <Adamant> kind of a latter day Ada
00:50:51 <ddarius> Adamant: I don't think that is true.
00:50:54 <kmc> aydeini, in addition to actual programs, Haskell syntax is the de facto standard notation for a whole subfield of computer science
00:51:04 <Adamant> ddarius: that's what Galois uses it for
00:51:13 <Adamant> IIR
00:51:14 <Adamant> C
00:51:28 <aydeini> what subfield would that be? i see its popular in AI
00:51:48 <Adamant> it definitely hasn't replaced Ada for deployed aircraft or anything
00:51:51 <kmc> aydeini, papers about the use or implementation of functional languages
00:51:57 * ddarius isn't aware of Haskell being used in any serious AI project.
00:52:07 <kmc> especially those which involve static typing and/or lazy evaluation
00:52:16 <kmc> quite often use Haskell syntax even when discussing theoretical or hypothetical systems
00:52:30 <aydeini> ddarius
00:52:30 <aydeini>     *  Aetion Technologies LLC Columbus, Ohio 
00:52:34 <aydeini> these guys used it
00:52:36 <kmc> and they won't mention this fact, any more than a maths paper says "we're going to use maths notation"
00:52:39 <aydeini> according to kmc's link
00:52:59 <ddarius> aydeini: I don't think I'd call what they did AI.
00:53:40 <EliasAmaral> kmc, I see scheme is, or was, popular for a similar reason
00:54:23 <EliasAmaral> like, implementing new paradigms
00:55:16 <Adamant> right; if you wanted to play with metasyntax, continuations, and such, Scheme used to the only real game in town
00:55:22 <Adamant> *to be
00:56:12 <ddarius> Adamant: What is there now?  A bunch of variants of (S)ML?
00:56:26 <EliasAmaral> there are two ocaml to javascript compilers. maybe some in haskell too
00:56:37 <Adamant> ddarius: Ocaml, SMLNJ, Haskell
00:56:43 <Adamant> basically
00:56:47 <ddarius> YHC could do that.
00:56:53 <kmc> Haskell isn't a great language for continuations and metasyntax
00:57:17 <Adamant> kmc: it's not, but you can do it
00:57:37 <Mitar> is there some workaround for http://hackage.haskell.org/trac/ghc/ticket/1036#comment:4 until it comes into stable?
00:57:39 <Adamant> via TH and call/cc
00:57:58 <kmc> sure
00:58:14 <kmc> but Haskell supports continuations only about as far as Java supports first-class functions
00:58:20 <Adamant> true
00:58:36 <kmc> no intrinsic support, but a standard way to encode it, and a little syntactic help
00:58:38 <Adamant> well, hyperbole, but truthy hyperbole :P
00:58:45 <ddarius> Haskell supports continuations less than Java supports first class functions.
00:58:47 <Mitar> i have problems that i want another thread to regularly interrupt my event thread (X11) but sometimes it interrupts in some unblocked function, somewhere deep in x11 lib
01:09:06 <Dazz> Can you make games with Haskell?
01:09:12 <ddarius> People have.
01:09:16 <ManateeIrcClient> Dazz: yes
01:09:20 <kmc> yes, it is a general-purpose programming language
01:09:20 <Dazz> cool
01:09:35 <kmc> Dazz, don't ask "can", ask "should" or better yet "why / why not"
01:09:36 <ManateeIrcClient> Dazz: Infact, have people develop game on IPhone
01:10:13 <Dazz> ok, thankyou
01:16:46 * hackagebot thimk 0.3.1 - Command-line spelling word suggestion tool  http://hackage.haskell.org/package/thimk-0.3.1 (BartonMassey)
01:18:02 <EliasAmaral> but, then, should people make games with haskell?
01:18:14 <EliasAmaral> or, better, why / why not develop games with haskell?
01:20:57 <chandru_in> How can I have multiple expressions in a function?  Like print a message and then compute a value.  I'm new to Haskell and this might be stupid
01:21:21 <Zao> chandru_in: Depends on what you mean by "function".
01:21:31 <Zao> Printing implies IO, so `do'.
01:21:40 <mm_freak> chandru_in: in general in haskell there is no "then", only in IO there is
01:21:43 <Zao> (or Debug.Trace.trace)
01:21:47 <Seryl> EliasAmaral: If you want a functional language for development, haskell isn't all that shabby (especially in terms of performance)
01:22:02 <Zao> mm_freak: Or any other sequencing monad, to some extent.
01:22:19 <chandru_in> Zao, I'm not getting what you're trying to say at all.  :(
01:22:24 <mm_freak> Zao: i know only one other:  Cont/ContT
01:22:49 <mm_freak> chandru_in: maybe you can give an example?
01:24:51 <chandru_in> Lets say I have a function, which when invoked prints Hi and then does pred of n.  I tried writing myFunc n = print "Hi" pred n.  And that didn't work
01:25:26 <mm_freak> myFunc n = print "Hi" >> return (pred n)
01:25:41 <mm_freak> but instead of print you would probably want putStrLn here
01:28:13 <frerich2> Anybody with a C++ or Java background here? I recently read a chapter about typeclasses and now wonder whether type classes are basically like 'mixin' implementations of interfaces which you can use to make existing functions work on new types. For instance, like 'Comparable' or 'Runnable' in Java.
01:28:52 <frerich2> Is it comparable or am I totally on the wrong track here?
01:29:17 <chandru_in> thanks mm_freak.  But when I pass an expression using this function as argument to another.  It leads to error.
01:29:30 <chandru_in> will provide complete code
01:29:32 <ManateeL`> frerich2: Yes, Haskell's typeclass like Java's interface, but nested typeclass not like Java's
01:29:36 <olsner> frerich2: it might be similar (I don't know), but it's probably best to treat typeclasses as a new thing than trying to apply analogies to something else
01:29:43 <mm_freak> chandru_in: check out myFunc's type
01:29:58 <mm_freak> myFunc :: Enum a => a -> IO a
01:30:21 <mm_freak> you're probably looking for a function with this type:
01:30:23 <EliasAmaral> chandru_in, haskell functions can't do anything but return a value. so they can't print something and then return a value. in haskell there is a type called IO that holds such actions. there is a value of this type named main. main is what gets executed
01:30:29 <mm_freak> betterMyFunc :: Enum a => a -> a
01:30:33 <mm_freak> but that function can't print anything
01:30:41 <frerich2> olsner: Definately, especially since typeclasses surely aren't 100% the same thing. I'm just trying to flatten the initial Haskell learning curve a bit by finding (appropriate!) analogies to other languages.
01:30:44 <EliasAmaral> so if you want to print something, you somehow needs to "embed" it at the main value
01:31:24 <chandru_in> guess my understanding to Haskell is still too poor
01:31:24 <mm_freak> frerich2: h98 classes are more or less comparable, but become more expressive, if you use type system extensions
01:31:26 <EliasAmaral> (I'm trying to describe in order to get a clue of it. I'm a newbie too)
01:31:36 <ManateeL`> frerich2: If you have Java background, and want to study Haskell easy, this is rule : forgot Java! :)
01:31:56 <mm_freak> chandru_in: always write the type signature of a function first
01:31:57 <ddarius> There are -many- ways in which even Haskell 98 type classes are not even remotely like Java interfaces.
01:31:59 <mm_freak> it helps a lot
01:32:16 <frerich2> ManteeL`: Oh, no, I don'\t know Java. Only tiny bits of it. I'm actually a C++ person - but I guess that's not much better ;-)
01:32:28 <frerich2> In fact, typeclasses reminded me of specializing C++ templates for particular types.
01:32:37 <ManateeL`> frerich2: Ok, forgot C++ . :)
01:32:46 <EliasAmaral> chandru_in, a >> b means "do the i/o action a, then pass it's value to b function". but it doesn't actually do anything (it's just a description of what to do), except in main. main = a >> b actually does a
01:32:52 <ddarius> frerich2: If you are aware of the C++ Concepts that the standards committee was considering, those are explicitly based on the idea of type classes.
01:33:00 <EliasAmaral> erm. that would be a >>= b
01:33:04 <frerich2> ddarius: You mean concepts? Yes.
01:33:08 <EliasAmaral> but anyway.
01:33:14 <mm_freak> EliasAmaral: in a >> b, b is not a function
01:33:17 <frerich2> ddarius: err, sorry, you wrote concepts - I overread that.
01:33:29 <EliasAmaral> (a >> b does a, discards the value of a, and then does b)
01:33:39 <mm_freak> EliasAmaral: and 'main' is a description, too
01:33:46 <mm_freak> don't confuse evaluation with execution
01:33:55 <ManateeL`> frerich2: You forgot C + + more, learn faster Haskell.  :)
01:33:57 <mm_freak> nothing gets 'run' in pure haskell
01:34:13 <chandru_in> mm_freak, Even specifying the type signature didn't help here.  This is the code I'm trying to load.  http://pastebin.com/4BziYH87
01:34:45 <mm_freak> chandru_in: that code doesn't look wrong to me
01:34:51 <mm_freak> it just may not do what you expect it to =)
01:35:54 <Peaker> frerich2, Type-classes allow for return-type polymorphism, higher-kinded polymorphism, conditional instantiation (e.g: If "a" is Showable, then "Maybe a" is Showable), and other things that "mixin interfaces" don't allow
01:36:02 <mm_freak> chandru_in: in haskell an IO action (an interaction with the world) is a value
01:36:10 <Peaker> frerich2, Type-classes are generally much nicer than "OO interfaces" :)
01:36:13 <chandru_in> When I load it in ghci and execute "myCheck True (myFunc 10)" it says " No instance for (Num (IO t))"
01:36:27 <mm_freak> chandru_in: yes, that makes sense
01:36:32 <mm_freak> write the type signature for myCheck, too
01:36:38 <mm_freak> then you'll see why that can't work
01:37:09 <ddarius> You could make a good case for having both type classes and OO interfaces in a single language.
01:37:35 <chandru_in> Just one doubt?  What does Enum a mean in the type signature of myFunc?
01:38:07 <mm_freak> chandru_in: it means that the type 'a' is an instance of the Enum class, which basically means that you can use 'succ' and 'pred' for it
01:38:21 <mm_freak> (among some other functions)
01:38:24 <chandru_in> oh ok
01:38:45 <mm_freak> otherwise you would get a missing instance error
01:38:50 <mm_freak> @botsnack
01:38:50 <lambdabot> :)
01:38:53 <chandru_in> Thanks for the help guys.
01:39:13 <mm_freak> > \(x :: a) -> succ x
01:39:14 <lambdabot>   A pattern type signature cannot bind scoped type variables `a'
01:39:14 <lambdabot>    unless th...
01:39:26 <mm_freak> > \x -> succ (x :: a)
01:39:27 <lambdabot>   Inferred type is less polymorphic than expected
01:39:27 <lambdabot>    Quantified type variable...
01:40:08 <mm_freak> let f :: a -> a; f = succ in f 15
01:40:10 <mm_freak> > let f :: a -> a; f = succ in f 15
01:40:11 <lambdabot>   Could not deduce (GHC.Enum.Enum a) from the context ()
01:40:11 <lambdabot>    arising from a us...
01:41:24 <mm_freak> ddarius: are you using some sort of VM for windows?
01:41:51 <mm_freak> i tried KVM, which works fine, but is quite slow with I/O
01:42:28 <ddarius> My laptop couldn't handle a VM.  I did my Windows Haskell development years ago, though I could boot into XP if I needed to.
01:43:38 <mm_freak> ok, thanks
01:45:49 <EliasAmaral> lambdabot doesn't reply to :t at pvt
01:46:50 <mm_freak> EliasAmaral: @type
01:47:20 <EliasAmaral> ah
01:48:57 <platzhirsch> The people are always so mean in the other channels, what is your secret?
01:49:15 <mm_freak> platzhirsch: we're open-minded =)
01:50:37 <Adamant> don't tolerate bad behavior; don't assume behavior is necessarily bad and not just odd until ample proof is given.
01:51:58 <Adamant> a lot of "trolling" isn't, it's people with different viewpoints; treating them with respect avoid them becoming actual trolls
01:52:21 <Adamant> for real trolling, not reacting in a overactive manner diminishes it
01:52:22 <EliasAmaral> I think the freenode guidelines helps a bit
01:52:55 <EliasAmaral> (I mean, a lot of channels don't follow things like "ops don't keep +o all the time" etc)
01:52:55 <ArkAnGiCIA> HellOlAloHallOhayo.. I HI..
01:53:09 <platzhirsch> Adamant: Oh, I was just fooling around a bit. This was just a strong subjective observation of mine :)
01:53:25 <Adamant> platzhirsch: it's something I've been thinking about a bit.
01:53:39 <geheimdienst> ... haskellers are strongly typed?
01:53:51 <Adamant> the mission statement for Hacker News provides some good guidelines as well
01:53:59 <platzhirsch> Adamant: These are good thoughts
01:54:26 <ManateeIrcClient> geheimdienst: yes
01:54:29 <Adamant> I agree that Freenode has learned a lot of lessons on this stuff as well
01:54:49 <mm_freak> geheimdienst: i'm of type 'a'
01:55:09 <mm_freak> i can do anything, but i never do anything
01:55:39 <Adamant> for tight-knit communities, certain approaches work very well
01:56:12 <Adamant> back in the MIT hacker days, instead of having contests to crash a machine, they had a command to automatically crash the system
01:56:37 <ManateeL`> mm_freak: Interesting, my irc client can't parse your message correctly... debugging....
01:56:38 <Adamant> after someone did that once and pissed people off, they tended not to do it intentionally again
01:57:35 <ManateeL`> mm_freak: Can you talk more ? Let me debugging ;p
01:58:28 <mm_freak> ;)
01:58:40 * mm_freak :: forall a. a
01:58:59 <ManateeL`> mm_freak: You irc client kill my irc client.... :)
02:23:12 <ArkAnGiCIA> sorry for french : LES FRANCAIS SE CROIENT SEULS AU MONDE PEUT ETRE ? mais ils sont mabouls dans leurs tetes ils  cherchent quoi encore comme merde ces batards ?
02:28:06 * hackagebot persistent 0.2.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.1 (MichaelSnoyman)
02:28:08 * hackagebot persistent-postgresql 0.2.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.2.1 (MichaelSnoyman)
02:29:06 * hackagebot persistent-sqlite 0.2.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.2.1 (MichaelSnoyman)
02:33:07 * hackagebot hamlet 0.5.0.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.5.0.1 (MichaelSnoyman)
02:33:47 <geheimdienst> after much head-scratching and rummaging in the dictionary, i can say that i have no clue what the man just said
02:34:13 <geheimdienst> "the french care only for the world maybe?"
02:34:30 <geheimdienst> "the french believe only in the world?"
02:44:34 <ManateeIrcClient> mm_freak: Can you talk to me please? I fix my *heart* just now....
02:46:26 <ManateeL`> dom96: Are you there? Another bug in your Messages.hs
02:56:02 <mm_freak> ManateeIrcClient: sorry, i'm busy ;)
02:56:32 <ManateeIrcClient> mm_freak: Thanks, i can see now. :)
02:56:39 <ManateeIrcClient> s/see/see you
02:57:14 <ManateeIrcClient> mm_freak: Problem is you hostname have many colon confuse my irc client. :)
03:03:19 <mm_freak> ManateeIrcClient: oh, you were serious
03:03:29 <mm_freak> ManateeIrcClient: you may want to use my fastirc library ;)
03:04:15 <mm_freak> ManateeIrcClient: http://hackage.haskell.org/package/fastirc
03:05:46 <ManateeIrcClient> mm_freak: I know your fastirc, but it's not suitable with my framework.
03:06:30 <mm_freak> ManateeIrcClient: you can use the parser onlyâ€¦  the session module isn't finished yet anyway
03:06:40 <Maxdamantus> Is a case thing meant to have overlaps, like in function guards?
03:07:40 <Maxdamantus> "Warning: Pattern match(es) are overlapped In a case alternative: _ -> ..." .. pstr q (h:t) = case h of q -> []; _ -> "foo"
03:07:51 <ManateeIrcClient> mm_freak: Thanks, i need parse irc data myself since i'm develop irc client.
03:08:06 <ManateeIrcClient> mm_freak: If have any problem, i can change code quickly. :)
03:09:51 <ziman> this is just weird; I have: binary :: Int -> [Bits]; binary = reverse . unfoldr phi where { phi 0  = Nothing ; phi !n = ... }. This gives an "unexhaustive pattern in phi" error but when I remove the bang, everything works okay.
03:10:15 <ziman> any idea why this might happen? I cannot think of anything.
03:13:34 <quicksilver> ziman: you haven't turned bang patterns on, and phi ! n = ... is defining an operator '!'
03:15:15 <ziman> oh, I see, thank you.
03:19:29 <mm_freak> Maxdamantus: function definition with multiple clauses is just syntactic sugar for 'case'
03:19:50 <mm_freak> > let f True = 1; f False = 0 in map f [True, False]
03:19:51 <lambdabot>   [1,0]
03:20:10 <mm_freak> > let f x = case x of True -> 1; False -> 0 in map f [True, False]
03:20:11 <lambdabot>   [1,0]
03:21:20 <Maxdamantus> Hmm.. Does that mean I can't use symbols from the argument list in a case?
03:21:54 <Maxdamantus> pstr p (p:t) = []; pstr p (_:t) = "foo"
03:22:36 <Maxdamantus> Hm no, can't mean that.
03:24:21 <mm_freak> Maxdamantus: i don'
03:24:27 <mm_freak> Maxdamantus: i don't understand
03:25:02 <mm_freak> you can use variables of the argument list in a case pattern, but they will override
03:25:29 <Maxdamantus> > (\q (h:t) = case h of q -> []; _ -> "foo") 'a' "abc"
03:25:30 <lambdabot>   <no location info>: parse error on input `='
03:25:37 <Maxdamantus> > (\q (h:t) -> case h of q -> []; _ -> "foo") 'a' "abc"
03:25:38 <lambdabot>   ""
03:25:43 <Maxdamantus> > (\q (h:t) -> case h of q -> []; _ -> "foo") 'a' "def"
03:25:44 <lambdabot>   ""
03:25:59 <Maxdamantus> Shouldn't I get "foo" for the latter?
03:26:10 <quicksilver> no.
03:26:25 <quicksilver> "case h of q" means "match h with any value, give that value the name 'q'"
03:26:26 <Maxdamantus> Why?
03:26:38 <quicksilver> the q there is unrelated to the earlier q in that line.
03:26:49 <Maxdamantus> Oh.
03:27:26 <quicksilver> if you want to compare for equality, you have to use == explicitly
03:27:30 <Maxdamantus> Only data constructor names are important there? anything else just gets interpreted as new bound variables (or whatever they're called)
03:27:35 <quicksilver> which will of course require EQ
03:27:37 <quicksilver> Eq
03:27:44 <quicksilver> yes.
03:28:20 <McManiaC> -Wall will warn you that q shadows the previous binding for q :)
03:28:55 <Maxdamantus> Wall? O_o
03:29:04 <McManiaC> ghc --make -Wall
03:29:08 <Maxdamantus> Oh.
03:29:10 <McManiaC> or ghci -Wall <file>
03:29:19 <Maxdamantus> Thought you were qouting a /wall or something
03:30:48 <ddarius> @quote lwall
03:30:49 <lambdabot> No quotes match. I am sorry.
03:31:24 <ddarius> @karma lwall
03:31:24 <lambdabot> lwall has a karma of 530
03:31:40 <McManiaC> lol
03:31:48 <ddarius> @quote LarryWall
03:31:48 <lambdabot> LarryWall says: ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
03:32:52 <ddarius> @karma dons
03:32:53 <lambdabot> dons has a karma of 13
03:33:23 <ddarius> It's ironic why this is the case.
03:33:29 <McManiaC> whats karma?
03:34:10 <ddarius> @karma McManiaC 
03:34:10 <lambdabot> McManiaC has a karma of 0
03:34:12 <Saizan> lwall's karma is due to the commits on pugs?
03:34:17 <ddarius> McManiaC++
03:34:18 <McManiaC> =(
03:34:21 <ddarius> @karma McManiaC 
03:34:21 <lambdabot> McManiaC has a karma of 1
03:34:26 <ddarius> @karma- McManiaC 
03:34:26 <lambdabot> McManiaC's karma lowered to 0.
03:34:28 <Maxdamantus> Maxdamantus++
03:34:31 <Maxdamantus> @karma
03:34:32 <lambdabot> You have a karma of 0
03:34:35 <ddarius> Saizan: Yes.
03:34:36 <Maxdamantus> :(
03:35:08 <Maxdamantus> @pl Maxdamantus++
03:35:08 <lambdabot> (line 1, column 14):
03:35:09 <lambdabot> unexpected end of input
03:35:09 <lambdabot> expecting white space or simple term
03:35:12 <ddarius> In fact, the whole ++ form of karma was due to #pugs.
03:37:01 <McManiaC> whatever pugs is... :)
03:38:40 <ddarius> @package Pugs
03:38:40 <lambdabot> http://hackage.haskell.org/package/Pugs
03:39:21 <ddarius> There is an old and strange twining of communities between Haskell and Perl.
03:39:53 <Peaker> Really strange, IMO, because Perl seems to be the starkest contrast to Haskell, except perhaps the tendency of some Haskellers to over-use "line noise"
03:40:35 <mm_freak> did larry wall actually say that?
03:40:44 <mm_freak> <lambdabot> LarryWall says: ..take Lisp. You know it's the most beautiful language in the world. At least up until  Haskell came along.
03:41:05 <ddarius> @quote LarryWall
03:41:06 <lambdabot> LarryWall says: ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
03:41:07 <ddarius> @quote LarryWall
03:41:08 <lambdabot> LarryWall says: We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.
03:41:14 <ddarius> @quote LarryWall
03:41:15 <lambdabot> LarryWall says: ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
03:41:17 <ddarius> Curses.
03:41:32 <ddarius> There's at least one more.
03:43:12 <ddarius> @where haskerl
03:43:12 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
03:43:39 <ddarius> The ironic thing about Haskerl is how much of it is in modern Haskell.
03:45:39 <Peaker> when is that from?
03:46:00 <Peaker> oh, I see
03:46:04 <Peaker> cool, they predicted the future
03:46:36 <Phyx-> they probably just used a flux capacitor
03:47:09 <Maxdamantus> @quote RobPike
03:47:09 <lambdabot> No quotes match. Just what do you think you're doing Dave?
03:47:14 <Maxdamantus> :(
03:47:55 <Peaker> http://www.dcs.gla.ac.uk/~partain/haskerl/hudak-1.html -- woah
03:49:15 <Peaker> April 1, oh
03:49:25 <nlogax> sounds like a great thing to "experiment" with :D
03:50:11 <Maxdamantus> lmao
03:57:07 * ManateeL` pasted "New version IRC parser library " at http://paste2.org/get/986193
03:57:29 <ManateeL`> @tell dom96 Look http://paste2.org/get/986193 , has fix a parse bug when have ':' in hostname. 
03:57:30 <lambdabot> Consider it noted.
03:57:56 <Maxdamantus> O_o
03:58:17 <ManateeL`> @tell dom96 look 'splitMsg' in http://paste2.org/get/986193 , now i search ByteString " :" instead ":" fix that bug.
03:58:18 <lambdabot> Consider it noted.
03:58:20 <McManiaC> http://www.dcs.gla.ac.uk/~partain/haskerl.html
03:58:25 <McManiaC> ups sorry
03:58:39 <McManiaC> wrong mouse button in putty :>
04:00:12 <ManateeL`> @tell dom96 like mm_freak's hostname is "2a01:198:2d4:0:dead:affe:dead:affe", when you break ByteString with ":", you will got wrong split position, so you need use function 'breakSubstring' break ByteString with " :", then you can split irc message from data correctly.
04:00:12 <lambdabot> Consider it noted.
04:00:46 <ManateeL`> @tell dom96 Cheers! ;-p
04:00:46 <lambdabot> Consider it noted.
04:02:36 <mm_freak> ManateeL`: i still recommend not reinventing the wheel
04:02:59 <mm_freak> i've carefully written a fast RFC-compliant IRC message parser using attoparsec
04:05:25 <Saizan> :O
04:05:39 <Saizan> is it on hackage?
04:06:03 <mm_freak> Saizan: http://hackage.haskell.org/package/fastirc
04:06:14 <ManateeIrcClient> mm_freak: Well, i need control my code, i haven't time wait push patches and release new version when something is wrong.
04:06:34 <mm_freak> ManateeIrcClient: the code is complete
04:06:42 <mm_freak> and if you're not happy, well, it's open source =)
04:06:50 <mm_freak> BSD-licensed ;)
04:07:27 <ManateeIrcClient> mm_freak: Thanks, the real reason i write it because i want to know the details of parser.
04:07:36 <McManiaC> hm I always used the irc package
04:07:41 <ManateeIrcClient> mm_freak: Your fastirc is cool, but less fun. ;-p
04:08:01 <mm_freak> ManateeIrcClient: that's sounds much more reasonable =)
04:08:38 <mm_freak> McManiaC: i wrote it in response to it, because 'irc' uses String and feels a bit less flexible
04:08:49 <mm_freak> also i wanted to write a session manager, but it's far from complete yet
04:09:05 <McManiaC> mm_freak: fastirc uses bytestring IO?
04:09:12 <ManateeL`> mm_freak: Yes, String not flexible
04:09:18 <ManateeL`> McManiaC: Yes.
04:09:24 <McManiaC> kk
04:09:37 * ddarius never fully appreciated the sardonic kicker at the end of the Haskerl note.
04:09:37 <mm_freak> ManateeL`: String is flexible, but 'irc' didn't feel like it
04:09:41 <McManiaC> might consider using it if I ever start hacking on irc again :)
04:09:53 <ManateeL`> McManiaC: Special when you receive variant encoding message, ByteString is better...
04:10:09 <McManiaC> true
04:10:30 <ManateeIrcClient> mm_freak: Now my irc client just can decode ASCII and UTF-8
04:10:44 <mm_freak> ManateeIrcClient: are you writing a GUI client?
04:10:58 <ManateeIrcClient> mm_freak: I will send patch to text-icu that support "automatic encoding detect"
04:11:27 <ivanm> ManateeIrcClient: I thought it wasn't possible in general to detect the encoding of arbitrary text...
04:11:28 <mm_freak> rename it to "automatic UTF-8 detection", because you can't really "detect" the other encodings
04:11:38 <ddarius> ivanm: Of course it isn't.
04:11:43 <ManateeL`> ivanm: Possible.
04:11:50 <mm_freak> ivanm: you can detect UTF-8, but not with 100% guarantee
04:11:54 <mm_freak> it could still be latin-1
04:12:01 <ivanm> yeah
04:12:19 <ManateeL`> ivanm: Infact, icu have "automatic detect" module, just haven't binding in package 'text-icu'
04:12:30 <ivanm> huh, probabilistic encoding detection: http://chardet.feedparser.org/
04:12:40 <ivanm> ManateeL`: oh, just using that; it just guesstimates IIRC
04:12:42 <ManateeL`> ivanm: My file-manager and irc client need this module to detect the encoding of unknown string.
04:13:02 <mm_freak> ivanm: UTF-8 detection is probabilistic and fails for a small percentage
04:13:05 <ManateeL`> mm_freak: http://www.flickr.com/photos/48809572@N02/4985793617/lightbox/
04:13:46 <McManiaC> nice
04:14:12 <ManateeL`> mm_freak: Infact, we can detect any encoding if it's not spurious string.
04:14:20 <McManiaC> is that gtk2hs?
04:14:22 <ManateeL`> mm_freak: Of course, not 100% . :)
04:14:28 <ManateeL`> McManiaC: http://www.flickr.com/photos/48809572@N02/
04:14:29 <mm_freak> ManateeL`: how can you tell latin-1 from latin-2?
04:14:39 <ManateeL`> McManiaC: Yes.
04:14:54 <ManateeL`> mm_freak: Google 'icu'.
04:15:34 <ManateeL`> ivanm: I guess 'icu' is better than chardet, 
04:15:55 <ManateeL`> ivanm: Just too busy haven't time binding "automatic encoding detect" module....
04:16:24 <ManateeL`> ivanm: If that module add in 'text-icu', then i can handle most unknown string in my file-manager and irc-client.
04:17:20 <mm_freak> ManateeL`: unless you're employing some language-trained neural network you can't tell latin-1 from latin-2 at all
04:17:57 <ManateeL`> mm_freak: If i can't detect, just insert ByteString in gtk+ widget.
04:18:11 <mm_freak> ManateeL`: most IRC clients have a fallback mode
04:18:18 <fasta> mm_freak, why would you need this automatic encoding detection (there is no such thing to begin with)?
04:18:20 <mm_freak> parse as UTF-8, if it's valid UTF-8
04:18:27 <mm_freak> otherwise use the encoding chosen by the user
04:18:45 <mm_freak> fasta: i don't, but apparently ManateeL` does =)
04:18:54 <ManateeL`> fasta: In 'icu' has this module, just haven't binding in 'text-icu' package.
04:19:02 <fasta> I don't know the details of IRC, but one might hope that a user tells in which language they are sending stuff. 
04:19:20 <fasta> So, this 'guessing' for stuff is basically useless. 
04:19:26 <mm_freak> fasta: yes, in fact you need to, because IRC is not encoding-aware
04:19:29 <mm_freak> it just deals with octets
04:19:30 <ManateeL`> fasta: No, irc message not include language information.
04:19:35 <mm_freak> i.e. bytes
04:19:51 <fasta> Then IRC needs a redesign. 
04:19:57 <ManateeL`> fasta: irc protocol don't care character-set, just octects.
04:20:10 <fasta> I suppose the newer protocols for chat do handle this in a sane way?
04:20:14 <ManateeL`> fasta: Yep, best send encoding information with data.
04:20:21 <benmachine> fasta: I wouldn't count on it :P
04:20:24 <mm_freak> fasta: redesigning IRC would be stupid, there are better protocols by now
04:20:28 <mm_freak> like XMPP (aka jabber)
04:20:33 <opqdonut> no, they're not better
04:20:34 <benmachine> I think IRC is de-facto UTF8 though
04:20:43 <opqdonut> I've yet to see proper "chatroom" support in them
04:20:47 <ManateeL`> mm_freak: I want develop XMPP client in i have more time.
04:20:50 <mm_freak> opqdonut: there is in XMPP
04:20:56 <ManateeL`> mm_freak: Now, just develop a irc client for play. :)
04:20:59 <Peaker> I never understood why IM and IRC were considered the same idea to be handled by the same protocol
04:21:10 <opqdonut> mm_freak: sure the protocol might have, but the support in all clients is horrible
04:21:15 <opqdonut> I've tried
04:21:20 <Peaker> The idea of large servers with large broadcast channels vs. tiny invite-only chats seem to be different enough to me
04:21:23 <ManateeL`> Peaker: Becuase most IM Inc. don't want you know the detail of protocol.
04:21:24 <Phyx-> is this a nice way to write xml? http://phyx.pastebin.com/2tspCM2L or would I be shot for doing it like that?
04:21:26 <mm_freak> Peaker: XMPP is generic, it doesn't focus on IM
04:21:30 <opqdonut> Peaker: mhmm
04:21:44 <mm_freak> opqdonut: that's not the protocol's fault
04:22:00 <ManateeL`> mm_freak: We can buld my own protocol base on XMPP. :)
04:22:05 <Peaker> ManateeL`, Yeah, but is chatting with your friend list the same as joining "broadcast lists" (channels) ?
04:22:07 <opqdonut> sorry, mm_freak, the protocol *is* the sum of its implementations
04:22:10 <opqdonut> for all practical purposes
04:22:12 <benmachine> Peaker: IRC was originally developed for basically IM-ish stuff I think
04:22:16 <mm_freak> ManateeL`: no need to, because XMPP is extensible
04:22:20 <benmachine> replacement for talk(1) or something
04:22:33 <ManateeL`> mm_freak: I mean special rule. :)
04:22:43 <ManateeL`> mm_freak: I know XMPP is base on XML.
04:23:12 <Phyx-> anyone, no comments?
04:23:39 <wjt> Phyx-: i think a lot of your tags could be attributes
04:23:44 <Peaker> XML is such a lousy metaformat
04:23:56 <wjt> but i guess that Microsoft are setting that schema, not you :)
04:24:05 <ManateeL`> ivanm: gio need raw string, i need build ByteString interface now, and do many dirty convert to ByteString in my file-manager, i hate variant encoding.
04:24:32 <benmachine> Phyx-: seems reasonable to me, I might indent less though
04:24:34 <Phyx-> wjt: indeed :)
04:24:34 <ManateeL`> I hope oneday all system use UTF-8.....
04:25:00 <benmachine> Phyx-: if you change the name of the "Project" tag for some reason, everything else has to shuffle horizontally
04:25:15 <ManateeL`> Peaker: But it's stop re-implement protocol, XML give a standard....
04:25:25 <Phyx-> benmachine: That's true. I should use another indentation scheme
04:25:40 <benmachine> Phyx-: well, it's hardly the most important thing
04:25:52 <McManiaC> even delphi supports utf8 now :D (that is, i dont use delphi at all, but a friend of mine complained to me about this a while ago since he had to rewrite all his strings :> )
04:26:17 <Phyx-> benmachine: true, aslong as it works right? :)
04:26:18 <McManiaC> "how stupid is utf8? why cant you just use the old string stuff and be happy with it?"
04:26:26 <Phyx-> I should have this finished by tonight and I
04:26:38 <Phyx-> I should have this finished by tonight and I'll probably put it on hackage to see you people squirm :P
04:26:54 <ville> utf-8 isn't that much fun if you're interested in performance and whatnot
04:26:58 <Peaker> McManiaC, Why would he have to rewrite his strings for utf8? Were they not ASCII?
04:27:27 <McManiaC> apparently not :>
04:27:28 <McManiaC> no idea
04:27:29 <McManiaC> ^^
04:27:50 <ManateeL`> McManiaC: Because utf-8 include all language's encoding.
04:27:53 <arw> delphi might be on windows which uses ucs2 or utf-16 in many places.
04:33:12 <Baughn> I can understand ucs-2, but what's the justification for using utf-16?
04:34:38 * Baughn would also like to usee an utf-8 variant that actually uses all 256 byte values
04:38:12 <koala_man> Baughn: utf-16 is to ucs-2 what utf-8 is to latin1
04:38:27 <Baughn> Right, I'm aware.
04:38:39 <Baughn> What I'm uncertain of is the technical justification for using utf-16 instead of utf-8.
04:39:09 <ddarius> Baughn: Because it covered more cases than utf-8 efficiently.
04:39:38 <Baughn> ddarius: That /would/ seem logical, but if efficiency was a consideration..
04:39:47 <ddarius> Nowadays it's mostly due to legacy.
04:40:02 <koala_man> just like utf-8
04:40:38 <Baughn> Why not make an utf-8 variant where 0-127 is ascii, and 128-255 provides the upper 7 bits of an extended code-point?
04:41:06 * hackagebot QuickCheck 1.2.0.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-1.2.0.1 (SimonMarlow)
04:41:08 <Baughn> As opposed to providing *no* bits in that case..
04:42:14 <koala_man> how would you get the rest of the code point?
04:42:20 <Baughn> The next byte.
04:42:34 <koala_man> how many of the next bytes?
04:42:36 <ddarius> I believe UTF-16 was more in response to existing systems such as Windows' and Java's.
04:42:40 <Baughn> I'd have to do some statistics on the internet to figure out the best way to do this, but how about this..
04:42:55 <Baughn> If byte 1 is 0-127, then it's a 1-byte ascii char
04:43:30 <koala_man> so far so good
04:44:05 <Baughn> If it's 128-192, then it's a 2-byte char, with the upper six bits provided by the first char and the lower eight by the second, which covers code-points 128 through 2^14+128
04:44:56 <Baughn> ..and so on, you get the drift. I'd really need to check actual character frequencies to figure out the best ranges.
04:45:59 <Baughn> In any case the first byte specifies the length of the entire encoded code-point, /and/ provides some of its bits.. as opposed to utf-8, where it does neither
04:46:11 <arw> Baughn: utf-16 was used because many systems introduced ucs2 first. they assumed that supporting the BMP would be enough, and when they were proven wrong they used utf-16 as the logical followup to ucs2
04:46:45 <hpc> doesn't ASCII use the last bit for parity on some old machines?
04:46:49 <Baughn> Er.. as opposed to utf-8, where it does only the latter. My bad.
04:47:05 <Baughn> hpc: I don't think we need to worry about non-8-bit-clean machines anymore.
04:47:11 <Baughn> Otherwise we'd be using UTF-7.
04:47:13 <hpc> heh
04:47:14 <arw> hpc: yes, but non-8bit-clean systems are very very legacy.
04:47:24 <arw> hpc: email still has some problems with those...
04:47:47 <Baughn> arw: Dear lord, they're still around?
04:48:16 <hpc> i didn't know /how/ old they were; one of my professors mentioned it in passing during an otherwise boring lecture
04:48:35 <arw> Baughn: everybody still sends email in utf-7, quoted-printable, uuencode or similar stuff to avoid the 8bit-problem with certain broken mailers...
04:48:49 <hpc> kinda funny that it breaks things
04:48:56 <Ytinasni> Baughn: utf-8 does both of those, afaik
04:49:05 <davean> there are still a lot of non 8bit clean mainframes
04:49:10 <Baughn> arw: And yet, MTAs provide an 8bit-clean property in their extension strings to avoid needing exactly that
04:49:28 <ddarius> No one will ever need EIGHT bits.
04:49:33 <Baughn> Ytinasni: http://en.wikipedia.org/wiki/Utf-8 <- No, the first byte in utf-8 can take on only 132 of 255 possible values
04:49:47 <arw> Baughn: yes, but that doesn't really matter. your mail client won't talk to every MTA in the delivery chain, only to the first one.
04:49:50 <Baughn> The second through fourth bytes aren't that much better, either. :P
04:50:03 <aristid> it still beats utf-32 tho.
04:50:33 <arw> Baughn: therefore all mail clients assume the worst and send mail like there always could be a non-8bit-clean MTA somewhere in the chain.
04:50:48 <Baughn> arw: True, so there should've been some standard that lets the mail (as opposed to the envelope) get uuencoded once the first non-8bit-clean MTA is encountered
04:51:05 <Ytinasni> Baughn: i meant "first byte specifies the length" and "provides some of its bits". utf-8 does both.
04:51:15 <Baughn> That would require MDA or email reader support, of course..
04:51:16 <ddarius> Those Martians must have a lot of characters.
04:52:10 <Baughn> Ytinasni: It only provides some of the bits for the first 128 code-points, but I doubt we actually disagree on the technical specifics, so..
04:52:19 <arw> Baughn: too complicated. for an MTA, the body of an email is just a stream of bytes. that extension would make MTAs far more complicated and it would require for every MTA to understand stuff like MIME encoding and whatever. won't ever happen.
04:52:27 <Baughn> Obviously, what I'd like is to use the space /efficiently/. Not that that's going to happen. :/
04:52:44 <Ytinasni> Baughn the page you liked to disagrees.
04:53:02 <koala_man> Baughn: one of the advantages of utf-8 is that non-ascii characters only use non-ascii bytes. and it's possible to tell if you're in the middle of a code point when parsing
04:53:06 <Baughn> arw: It wouldn't need to be that complicated. You add a header - Content-UUEncoded: <Bool>, which defaults to false.
04:53:29 <Baughn> arw: The rest of the message could be treated as opaque octets, never mind mime-type
04:53:43 <Ytinasni> ~you LINKED to.
04:54:11 * hackagebot kinds 0.0.1.2 - Emulation of subkinds and subkind polymorphism  http://hackage.haskell.org/package/kinds-0.0.1.2 (WolfgangJeltsch)
04:54:13 * hackagebot records 0.1.1.3 - A flexible record system  http://hackage.haskell.org/package/records-0.1.1.3 (WolfgangJeltsch)
04:55:13 <Baughn> Ytinasni: Using six bits.. ah, you're right. :/
04:55:22 <Baughn> Never mind me, then. :/
04:56:39 <Baughn> (Though there could still be improvements in space efficiency, at a loss of probably useful redundancy)
04:56:49 <Ytinasni> true.
05:05:13 <mm_freak> i don't like the new haddock stylesheet
05:05:20 <mm_freak> the old one was much easier to read
05:05:21 <McManiaC> i love it
05:05:22 <McManiaC> :>
05:05:34 <benmachine> mm_freak: they're toggleable now though, aren't they?
05:05:35 <mm_freak> and took less space for the same amount of info
05:05:44 <benmachine> you can select the original one I think
05:05:46 <mm_freak> benmachine: dunno, i just noticed it on hackage
05:05:47 <McManiaC> you can choose "Style -> Classic" on hackage now
05:05:51 <benmachine> yeah
05:06:05 <benmachine> easily-restylable haddock = good
05:06:10 <McManiaC> yup
05:06:12 <Baughn> I'd like the new one better if there were hotkeys. Mouse navigation = bad.
05:06:19 <Baughn> Maybe I'll fix that. :3
05:06:28 <McManiaC> haha
05:06:44 <benmachine> I always found that gmail's hotkeys interfered with vimperator's
05:06:51 <benmachine> which annoyed me deeply btyg
05:06:52 <McManiaC> guess you'll need a javascript browser plugin to make this work :P
05:07:07 <Baughn> McManiaC: Eh?
05:07:09 * Maxdamantus uses Conkeror on his netbook
05:07:21 <McManiaC> hotkeys in a browser = javascript
05:07:35 <Baughn> Yes, sure, but /plugin/?
05:07:38 <benmachine> McManiaC: using the internet nowadays = javascript, surely :P
05:07:42 <mm_freak> if i wrote a new stylesheet with my typography background, who would i need to send it to?
05:07:44 <McManiaC> and I doubt this will make it into the vanilla version of haddock
05:08:05 <benmachine> McManiaC: oh, so you mean a plugin that added some javascript to haddock?
05:08:08 <McManiaC> mm_freak: I'd try the haddock ML
05:08:13 <McManiaC> benmachine: yep
05:08:18 <benmachine> McManiaC: well, you could easily use it for your local docs
05:08:23 <Baughn> Oh. So, greasemonkey..
05:08:46 <Baughn> That's nice for prototyping, but I'd try to get the hotkeys into trunk
05:08:59 <Baughn> (Easy enough to make 'em togglable)
05:12:06 <ManateeL`> Hmm, qtHaskell release new version....
05:14:11 <mm_freak> did anyone succeed in getting wxHaskell to run on windows?
05:16:17 <ManateeIrcClient> mm_freak: Still failed? ;)
05:16:33 <mm_freak> ManateeIrcClient: yeah
05:17:21 <ManateeL`> Envy Qt have so many API. 
05:17:56 <ManateeIrcClient> mm_freak: Which you main OS?
05:18:25 <mm_freak> ManateeIrcClient: linux (arch)
05:19:14 <ManateeL`> mm_freak: I suggest you switch to gtk2hs. :)
05:19:32 <mm_freak> ManateeL`: i guess i'll try that
05:20:01 <ManateeL`> mm_freak: Just do "cabal install gtk2hs-buildtools gtk" ....
05:20:35 <mm_freak> ManateeL`: but i need to install GTK+ first, right?
05:20:49 <mm_freak> or is that included?
05:20:57 <McManiaC> its not
05:21:05 <ManateeL`> mm_freak: Yes, you need install develop file of gtk+
05:21:07 <Eduard_Munteanu> Most likely your distro has already installed GTK.
05:21:44 <benmachine> archlinux doesn't have separate dev packages either so if you have gtk then you also have the headers, iirc
05:22:00 <ManateeL`> mm_freak: sudo aptitude install automake libglade2-dev libgtksourceview-dev libgtksourceview2.0-dev libgconf2-dev librsvg2-dev libgstreamer-plugins-base0.10-dev libgstreamer0.10-dev libgtkglext1-dev libvte-dev libvte-common libwebkit-dev libcurl4-openssl-dev -y
05:22:04 <mm_freak> Eduard_Munteanu: my distro yes, but we're talking about compiling windows programs
05:22:13 <Eduard_Munteanu> Oh, right.
05:22:23 <ManateeL`> mm_freak: If you install all above depend package, all gtk2hs base package can install correctly.
05:22:40 <ManateeL`> mm_freak: Include 'webkit' 'vte' 'gstreamer''... etc.
05:22:40 <mm_freak> ManateeL`: on linux everything is working fine here
05:22:49 <mm_freak> i'm talking about windows
05:23:05 <benmachine> mm_freak: are you trying to cross-compile or using an actual windows?
05:23:15 <ManateeL`> mm_freak: Wait....
05:24:06 * ManateeL` pasted "gtk2hs install manual" at http://paste2.org/get/986256
05:24:08 <McManiaC> mm_freak: you basicly just need a couple of .dll files
05:24:08 <ManateeL`> mm_freak: ^^^^
05:24:13 <mm_freak> benmachine: crosscompiling failed miserably, so i'm using an actual windows (in a KVM) now
05:24:20 <ManateeL`> mm_freak: Look "Build on Windows" in manual.
05:24:24 <McManiaC> mm_freak: then everything works as expected
05:24:35 <mm_freak> McManiaC: at least for wx i also need a C compiler, header files, etc.
05:24:37 <McManiaC> I just couldnt get blade (correct name?) to work on windows :(
05:24:38 <mm_freak> and then i get linker errors
05:24:42 <mm_freak> unknown symbols
05:24:57 <mm_freak> anyway
05:25:01 <McManiaC> mm_freak: yeh, I couldnt get wx to compile either :)
05:25:01 <mm_freak> i'll try gtk2hs soon
05:25:06 <benmachine> mm_freak: ghc comes with a c compiler doesn't it?
05:25:19 <mm_freak> benmachine: yes, but not with all those GNU build tools
05:25:24 <mm_freak> so i installed mingw and msys
05:25:25 <benmachine> oh right
05:25:38 <ManateeL`> mm_freak: I haven't Windows, but i know many people install gtk2hs on Windows and works well...
05:25:49 <sshc> Is wxHaskell ghci friendly yet?
05:25:51 <sshc> What is wrong with gtk2hs also?
05:26:05 <Eduard_Munteanu> McManiaC: I found wxWidgets rather easy to cross-compile with MinGW.
05:26:15 <Eduard_Munteanu> A lot easier than GTK.
05:26:21 <McManiaC> really?
05:26:30 <siracusa> I tried to install wx on Windows several times with different code versions, different configurations -- no chance. :-(
05:26:43 <Eduard_Munteanu> McManiaC: yeah, basically it has no dependencies.
05:27:00 <mm_freak> sshc: yes, wx is GHCi-friendly
05:27:05 <ManateeL`> Eduard_Munteanu: We even don't need MinGW to install gtk2hs.
05:27:25 <ManateeL`> mm_freak: Well, we have finish many bugs, now gtk2hs can works with ghci well.
05:27:26 <mm_freak> sshc: the only thing that i don't like about gtk2hs is that it doesn't look native on some platforms, most notably windows
05:27:35 <mm_freak> sshc: GTK+ has its own look and feel
05:27:54 <McManiaC> hmmm
05:28:22 <ManateeL`> mm_freak: You can customize your own face, many windows application it's own face.
05:29:08 <mm_freak> ManateeL`: you can only adapt it to a certain windows version, and only to a certain theme (easily)
05:29:18 <mm_freak> for example it will look like a winxp-app in windows 7
05:29:22 <mm_freak> which would be quite odd and ugly
05:29:41 <ManateeL`> mm_freak: GTK+ has working on those work.
05:29:46 <ManateeL`> mm_freak: GTK+3
05:30:27 <ManateeL`> mm_freak: Well, if you want better face on Windows and Mac, i suggest wx, of course...
05:30:48 <ManateeL`> mm_freak: At least now, gtk+ looks ugly on Windows and Mac.
05:31:37 <ManateeL`> sshc: gtk2hs can works well on ghci, either windows, linux, mac.
05:31:59 <sshc> I thought wxHaskell had a problem with killing ghci or something?
05:32:00 <McManiaC> setup.exe: wx-config: does not exist
05:32:03 <McManiaC> where do I get wx-config?
05:32:21 <ManateeL`> sshc: Old gtk2hs have problem with ghci, but now have fix.....
05:32:36 <Nibble> ManateeL`: your the man!
05:33:44 <mm_freak> ManateeL`: it doesn't look uglyâ€¦  in fact i find GTK+ apps look nicer
05:33:54 <mm_freak> but it looks different, and more importantly it /feels/ different
05:33:57 <ManateeL`> mm_freak: I don't use Windows, i don't know.
05:34:00 <Nibble> The best looking ones are EFL apps
05:34:05 <Nibble> looks so fucking awesome
05:34:12 <McManiaC> efl?
05:34:21 <mm_freak> sshc: it didn't kill GHCi for me
05:34:28 <mm_freak> but i didn't use it seriously in GCHi
05:34:30 <ManateeL`> mm_freak: Infact, i just care APIs, and don't care face.
05:34:33 <mm_freak> i usually prefer to compile my stuff
05:34:41 <Nibble> McManiaC: Enlightenment foundation libraries.
05:34:46 <ManateeL`> mm_freak: If face is really ugly, i customised it.
05:35:16 <mm_freak> honestly i don't want to care about the faceâ€¦  it should work, and that's most important
05:35:25 <mm_freak> and it should look half-way pleasant to the eye
05:36:01 <ManateeL`> mm_freak: GTK + is now at the transitional period of the main version that from GTK+2 to GTK+3
05:36:27 <ManateeL`> mm_freak: I think GTK+3 is more beautiful....
05:37:04 <ManateeL`> mm_freak: I always fullscreen.... like this : http://www.flickr.com/photos/48809572@N02/
05:37:45 <McManiaC> my gtk is ugly
05:37:55 <McManiaC> I dont know how to choose a different design on windows
05:37:56 <McManiaC> :>
05:39:28 <ddarius> Ugh.  Unnecessary horizontal scrollbars.
05:39:57 <McManiaC> www.n-sch.de/whologin-win.png
05:40:00 <ManateeL`> ddarius: I have fix in newest version.
05:40:05 <siracusa> McManiaC: There should be a file .gtkrc-2.0 in your home directory where you can set the option `gtk-theme-name = ...'.
05:40:40 <McManiaC> yeh, it gets ignored :(
05:40:48 <ManateeL`> ddarius: Just too lazy haven't update new screenshot... :)
05:43:24 <McManiaC> I even tried to load the gtkrc-file by hand:
05:43:34 * ddarius tries to design user-interfaces that look pleasant to the thyroid.
05:43:37 <McManiaC>     -- Load gtkrc? TODO
05:43:37 <McManiaC>     rcAddDefaultFile ".gtkrc-2.0"
05:44:10 <ivanm> ddarius: I don't know about you, but my thyroid doesn't have eyes...
05:44:40 <fasta> ivanm, that was the point, I think. 
05:44:53 <ivanm> oh, right
05:44:57 <fasta> ivanm, not a very good joke, imho ;)
05:45:03 <ivanm> why the thyroid rather than any other part of the anatomy then?
05:45:15 <fasta> ivanm, that's why it is a bad joke :)
05:45:31 <ivanm> yup
05:45:43 * zygoloid liked it
05:46:05 * ManateeL` Coding time, bye all! :) 
05:47:26 <ivanm> zygoloid: no-one asked for your opinion! :p
05:47:46 <benmachine> zygoloid: what's your opinion? be aware that this question operates retroactively!
05:47:53 <zygoloid> \o/
05:48:27 <ivanm> benmachine: damn you and your twisty words!
05:48:32 * benmachine giggles
05:49:15 * ivanm retroactively bans benmachine from giggling
05:49:22 <benmachine> fffuuu-
05:49:23 * ivanm retroactively bans anyone from making any more retroactive statements
05:49:45 <zygoloid> what was that pop? did the universe just end?
05:49:53 <Eduard_Munteanu> I think so.
05:50:05 <Eduard_Munteanu> Contradictions are really bad.
05:50:16 <benmachine> no they're not! </obligatory>
05:50:20 <kamatsu> any good way to serialise data destined for JavaScript other than JSON?
05:50:46 <kamatsu> current haskell json libraries are a bit ugh
05:50:59 <ivanm> kamatsu: but, isn't one of them featured in RWH?
05:51:03 <ivanm> ergo, it can't be bad!!!
05:51:04 <ivanm> ;-)
05:51:07 <kamatsu> hmmm
05:51:08 <deteego> lols
05:51:12 <zygoloid> kamatsu: Show, plus a difficult javascript parser. oh wait, you said any *good* way :)
05:51:15 <benmachine> I'm curious, what's ugh about them?
05:51:16 <ivanm> kamatsu: you can always do the yet-another-bikeshed approach... ;-)
05:52:47 <poucet> protocol buffers?
05:53:12 <kamatsu> available to haskell? i used them at google with much happy
05:54:02 <fxr> > maxBound::Data.Word.Word64
05:54:03 <lambdabot>   18446744073709551615
05:54:15 <fxr> > 18446744073709551615 / 2
05:54:16 <lambdabot>   9.223372036854776e18
05:55:04 <Eduard_Munteanu> kamatsu: hm, do they do Haskell at Google?
05:55:16 <poucet> Eduard_Munteanu: yes
05:55:35 <Eduard_Munteanu> Interesting...
05:55:52 <fxr> kamatsu: see msgpack
05:56:03 <kamatsu> Eduard_Munteanu: sometimes
05:56:09 <poucet> kamatsu: yes, they are available to haskell, thanks to excellent work by Christopher Edward Kuklewicz
05:56:19 <poucet> http://hackage.haskell.org/package/hprotoc
05:56:19 <Eduard_Munteanu> kamatsu: better than never.
05:57:38 <kamatsu> poucet: looks like nice bindings, but msgpack looks even better -- especially seeing as protobufs might be a bit overkill for my current application
05:58:03 <poucet> kamatsu: Perfect :)
05:58:37 <poucet> Heh, nice graph o ntheir website :)
06:02:11 <sshc> Are wxHaskell interfaces typically created by code or by reading an XML file at runtime?
06:03:31 <fasta> sshc, I don't think anyone has numbers on that. 
06:04:01 <fasta> sshc, that said, it's quite common to write the static parts in a graphical editor. 
06:06:39 <kamatsu> fxr: msgpack only has a node-js decoder -- i want something i can deserialize in a browser
06:07:17 <kamatsu> on second thoughts, protobufs wouldn't help either..
06:08:54 <ManateeLazyCat> mm_freak: How to use your "Network.FastIRC.Messages" quickly? 
06:09:32 <ManateeLazyCat> mm_freak: I have a lot fun with parser, now i want use your fastirc as backend library...
06:09:49 <mm_freak> ManateeLazyCat: just use the parsers there
06:09:56 <mm_freak> the quickest way is to use readMessage
06:10:16 <mm_freak> but you can also incorporate the individual parsers into your own
06:10:27 <mm_freak> see the haddock docs
06:11:30 <ManateeLazyCat> mm_freak: Looks i just need readMessage and showCommand
06:11:55 <mm_freak> ManateeLazyCat: or showMessage
06:12:16 <mm_freak> a command is a message without an origin
06:12:21 <ManateeLazyCat> mm_freak: Why i need showMessage?
06:12:38 <mm_freak> because a message is more than just a commandâ€¦  it has an optional origin prefix
06:12:44 <mm_freak> :origin COMMAND arg arg arg
06:13:29 <ManateeLazyCat> mm_freak: Ah, UserSpec is "User NickName UserName HostName", i see.
06:13:48 <kamatsu> the reason i object to JSON is it isn't as simple as "read" and "show" on the haskell end and it really should be
06:14:42 <ManateeLazyCat> mm_freak: Have any bug in fastirc? 
06:15:11 <mm_freak> ManateeLazyCat: the session handler is in a useless state right now, otherwise i don't know of any
06:15:20 <mm_freak> but you said, you only need the parser anyway
06:15:33 <ManateeLazyCat> mm_freak: Yes, i only need parser. :)
06:15:38 <mm_freak> â€¦ which i've tested extensively
06:15:55 <ManateeLazyCat> mm_freak: Hmm, looks great.....
06:16:27 <ManateeLazyCat> mm_freak: I will use your fastirc, stop develop it myself since i have fun with parser... now i'm feeling boring....
06:37:46 * hackagebot sgrep 0.0 - Sgrep - grep Fasta files for sequences matching a regular expression  http://hackage.haskell.org/package/sgrep-0.0 (KetilMalde)
06:40:29 <mietek> Hm
06:45:00 <JHoglund> lambdabot: help!
06:45:08 <JHoglund> :t splitAt
06:45:09 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:51:37 <doofer> hey, does anyone have a resource on how haskell's pattern matching is desugared into case expressions? I'm especially looking for the case when there are several different patterns to match
06:53:10 <Botje> doofer: look at the book "implementation of functional programming languages"
06:53:15 <Botje> you can read it online for free
06:53:29 <Botje> doofer: it just picks the first one, i think
06:53:53 * hackagebot graphtype 0.2.0 - A simple tool to illustrate dependencies between Haskell types  http://hackage.haskell.org/package/graphtype-0.2.0 (DmitryAstapov)
06:53:58 <doofer> Botje: thanks for the pointer :)
06:54:56 <doofer> Botje: what's interesting to me is when you have for example f (C1 x) (C2 y) = ...; f (C1 z) (C3 _) = ...; because then you'd really want to merge the first cases even though x and z might not exactly be the same
06:56:00 <doofer> not exactly trivial... I'll have a look in the book!
06:56:07 <Botje> doofer: the algorithm in the book does indeed merge those cases, yes
06:56:20 <doofer> nice :)
07:08:06 <Vitka> @pl \x:y:z:_ -> (x,y,z)
07:08:07 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . (const .)) .) . (,,) . head) tail
07:08:16 <Vitka> omgwtfbbq
07:08:44 <doofer> readable, readable code
07:08:50 <fxr> kamatsu: I bet you can find an unpacker javascript for msgpack
07:10:59 <Vitka> Isn't flip flip f == f ?
07:11:48 <Olathe> @unpl flip flip
07:11:49 <lambdabot> (\ b c f -> c f b)
07:12:02 <Vitka> Hmm.
07:12:13 <doofer> @unpl flip . flip
07:12:13 <lambdabot> (\ i b c -> i b c)
07:13:36 <benmachine> :t flip flip
07:13:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
07:13:39 <Olathe> flip flip flips flip
07:13:47 <benmachine> yes, well put
07:14:12 <benmachine> a -> (c -> a -> b) -> c -> b
07:14:28 <siracusa> Is there a way to set a timeout to hGetContents or something similar? I just want to get the currently available content of a handle.
07:14:39 <benmachine> :t flip flip flip
07:14:40 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b
07:14:51 <benmachine> yeah then it gets a bit messy
07:14:58 <Vitka> Flip flip flips flip so it flips flipped args? :P
07:15:11 <benmachine> Vitka: possibly!
07:16:10 <benmachine> siracusa: the crude way to do it is m <- newEmptyMVar; forkIO . forever $ hGetChar h >>= putMVar m
07:16:28 <benmachine> siracusa: and then you can use tryTakeMVar on m
07:16:36 <Olathe> flip flip a b c = flip b a c = b c a
07:17:46 <siracusa> benmachine: And is there also a non-crude way? :-P
07:17:49 <Olathe> flip flip flip a b c = flip a flip b c = a b flip c
07:18:05 <benmachine> siracusa: well, my way isn't *that* crude, but yeah there might be
07:18:08 <Olathe> @unpl flip flip flip
07:18:08 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
07:18:24 * Vitka flips over.
07:19:00 <benmachine> siracusa: I have a vague idea that hGetLine and friends should return available data if there is any, even if it isn't a complete line, but that could be nonsense
07:19:10 <benmachine> siracusa: actually, I take that back
07:19:21 <benmachine> siracusa: is this like, a socket?
07:19:40 <siracusa> benmachine: It's the output of another process
07:19:45 <benmachine> ah
07:20:08 <benmachine> System.IO has an hGetBufNonBlocking, if that helps you
07:20:12 <benmachine> and an hGetBuf
07:20:18 <benmachine> you should experiment with those, I think
07:20:23 <benmachine> but the mvar solution is very flexible
07:23:48 <siracusa> benmachine: Yeah, I think I'll choose the MVar solution, thanks.
07:23:55 <NiXM> Hello all
07:25:13 <applicative> hello NIXM, welcome to #haskell, what are your expected and inferred types
07:25:35 <NiXM> I started not too long ago with Haskell and I'm running into some things I'm thinking it can be easier and more functional than I current do it
07:25:46 <NiXM> I made the problem a bit clearer in this picture: http://i53.tinypic.com/51oo5s.png
07:25:48 <dankna> lol
07:25:55 <NiXM> yeeah dankna :p
07:26:03 <NiXM> what I'm trying to achieve is not that complicated
07:26:05 <dankna> I was laughing at applicative's question
07:26:20 <dankna> question
07:26:25 <NiXM> I want to get a column (Eq "ID") and have the contents of that
07:26:28 <NiXM> but not ID
07:26:35 <dankna> why are you using [[String]] instead of [(Int, String)]
07:26:49 <NiXM> Ã­t's just an example, it can be of any type
07:26:52 <NiXM> like the other example
07:27:16 <NiXM> what I'm currently doing is with the single item [String] every time with an integer getting the single result
07:27:17 <Vitka> Take a look at Map and IntMap.
07:27:21 <NiXM> and adding that everytime
07:27:38 <NiXM> Let's say I want the contents of Country
07:27:57 <NiXM> and for Country as well in a list
07:28:24 <NiXM> so a string array containing ["Country", "USA", "USA", "USA"]
07:28:25 <dankna> it's not at all clear to me what you're trying to achieve
07:28:29 <dankna> what operations are you doing on this data?
07:28:37 <NiXM> at the moment not a lot yet
07:28:43 <dankna> and why are you including the header as part of the list
07:28:53 <dankna> it should be ("Country", ["USA", "USA", "USA"])
07:28:54 <NiXM> I already got this working with integers but this seems like a whole lot of trouble
07:29:00 <dankna> Haskell is about strong typing
07:29:10 <dankna> if you make everything polymorphic you might as well use another language
07:29:16 <fasta> dankna, in first year courses at UU they do the same thing, btw. 
07:29:27 <dankna> fasta: hah I see
07:29:33 <NiXM> yeah I know dankna  but this data is delivered like this
07:29:41 <NiXM> and I'm pretty sure this can be done better
07:29:43 <benmachine> NiXM: have you heard of the transpose function?
07:29:50 <dankna>  /what/ can be done better
07:29:51 <fasta> dankna, but you are right that it is better to distinguish them.
07:29:52 <benmachine> :t transpose
07:29:53 <lambdabot> forall a. [[a]] -> [[a]]
07:29:54 <NiXM> because this seems more like any regular function in another languages
07:29:55 <dankna> I see two tables of data
07:30:05 <dankna> I don't see any code or any idea what you're doing to the poor innocent data
07:30:05 <NiXM> benmachine: no, I have not
07:30:08 <dankna> sorry if that sounds harsh
07:30:24 <benmachine> > transpose [[a,b,c],[d,e,f],[g,h,i]]
07:30:25 <lambdabot>   [[a,d,g],[b,e,h],[c,f,i]]
07:30:30 <benmachine> ^ does that help?
07:30:34 <NiXM> no problem I can have that dankna 
07:31:06 <applicative> is there an underlying data Person = Person {name :: String, id :: Int , town :: String, country :: String} , for example?
07:31:27 <NiXM> applicative:  everything is a string
07:31:32 <NiXM> String
07:32:00 <doofer> quick! change it to something more meaningful!
07:32:07 <applicative> indeed
07:32:10 <NiXM> transpose comes in handy for sure, but what about retrieving all items from a cp;i,m
07:32:17 <Vitka> That's not the Haskell way at all.
07:32:41 <NiXM> alright, I have similar to this: Person{ id :: String, name :: String }
07:32:41 <benmachine> NiXM: transpose basically makes columns rows and rows columns
07:32:48 <doofer> NiXM maybe you'd like to use the filter function?
07:32:51 <Vitka> From my limited experience, what you should do it to express your problem domain in types.
07:33:20 <benmachine> personally I think it's a bad idea for this channel to tell people to rewrite everything :P
07:33:21 <applicative> NIXM, it's not so clear what the ultimate thing you want is.  Is it that you are given a long string of data, and must output the table?
07:33:41 <NiXM> applicative:  I made an example here http://i53.tinypic.com/51oo5s.png
07:33:52 <applicative> rewrite everything! 
07:33:57 <NiXM> what I want to achieve is to get the data from the [[string]] in one column
07:34:01 <applicative> even the linux kernel!
07:34:04 <Vitka> benmachine: There's not much to rewrite it seems. :)
07:34:06 <NiXM> lol :D
07:34:28 <benmachine> NiXM: if you want a column, use transpose to turn it into a row and then something like find to find it
07:34:34 <benmachine> :t find
07:34:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:34:44 <benmachine> I think find is in Data.List
07:34:44 <NiXM> so I want in an [String] these values when I do something like getColumnValues "Name". I want this than: ["Name", "Me", "You", "I"]
07:35:16 <NiXM> hm
07:35:39 <benmachine> find (\xs -> not (null xs) && head xs == "Name)
07:35:41 <benmachine> or something
07:35:48 <Vitka> filter (\(x:xs) -> x == "foo) . transpose
07:35:50 <Olathe> NiXM: Why are you using Strings rather than custom data types?
07:35:57 <Vitka> Something like that.
07:36:20 <applicative> Olathe, benmachine is suggesting that we take that for granted. 
07:36:21 <fasta> Olathe, likely because it is homework. 
07:36:31 <benmachine> applicative: you don't have to listen to me, of course
07:36:35 <NiXM> yes it is fasta 
07:36:42 <NiXM> like I said, I already have it working here
07:36:42 <applicative> Surely no one teaching haskell would have something so untypesensible
07:36:46 <applicative> oh maybe not...
07:36:49 <NiXM> but I'm not satisfied with how I did it
07:36:55 <NiXM> and I'm interested in how I can approve it
07:37:03 <NiXM> and Haskell is not the easiest language to step into 
07:37:13 <applicative> you can approve it, on condition of improving it.
07:37:22 <Vitka> 01> filter (\(x:xs) -> x == "foo1") . transpose [["foo1","foo2",[1,2],[3,4]]
07:37:31 <Vitka> 01oops
07:37:41 <fasta> applicative, it is like lesson 1 in the functional programming class at the UU. 
07:37:43 <Vitka> 01> filter (\(x:xs) -> x == "foo1") . transpose [["foo1","foo2"],[1,2],[3,4]]
07:37:53 <fasta> applicative, you are free to tell them that they are doing it wrong.
07:38:19 <Olathe> If they're this far off, it shows that they don't really care about doing it right.
07:38:26 <Vitka> 01lambdabot: Hello?
07:38:28 <applicative> fasta, I see, that makes sense, we aren't yet in a position to define data Person = Person {name :: String, id :: Int , town :: String, country :: String}  or whatever
07:38:40 <Olathe> It's like...here's this language we're not too interested in, but we're going to TEACH it!
07:38:50 <Olathe> And everyone's like "Yay!"
07:38:57 <benmachine> Olathe: UU have done a lot of good haskell work though
07:38:59 <applicative> i think UU is interested in Haskell
07:39:03 <fasta> applicative, for example. 
07:39:06 <NiXM> we just started the course here
07:39:10 <fasta> Tadaa
07:39:12 <NiXM> but the teacher is ill
07:39:22 <NiXM> and I'm curious to improve my code :)
07:39:28 <NiXM> and IRC is always the best way 
07:39:32 <applicative> right Applicative, that's from UU.  great place, I approve.
07:39:42 <luite> oh they might need an extra ta then, I should apply quickly ;)
07:39:51 <NiXM> i'm not at UU :)
07:39:53 <luite> oh
07:40:13 <applicative> NiXM, the path forward is to post the code.   of course people are homework wary ...
07:40:30 <applicative> hpaste.org can display it
07:40:49 <NiXM> sure, I'll upload my code what I have now
07:40:52 <NiXM> give me a second
07:41:13 * applicative apologizes for using the word "code", he thinks we should use "module" and "definition" only in connection with Haskell.
07:41:34 <NiXM> hehe
07:41:55 <Olathe> I think I must have a different definition of interest.
07:42:27 <applicative> Olathe?
07:43:03 <NiXM> hpaste didnt work but pastebin did :) http://pastebin.com/umqhvuDx
07:43:07 <Olathe> Like I said that they weren't interested in Haskell, but they taught it, and people said that they created Applicative, which is interest of a sort.
07:44:15 <applicative> Olathe, it turned out the mention of UU was irrelevant.  But doesn't everyone agree it's one of the several Haskell capitals?
07:44:58 <Olathe> Ahh, OK.
07:45:05 <Phyx-> applicative: nah, all the ta positions are taken :(
07:45:27 <NiXM> so this was mainly for project, where you could use like project ["Compiler"] compilers
07:45:37 <NiXM> and you just got the Compilers column
07:45:43 <NiXM> and this solution I made is kinda crap imo :)
07:45:49 <applicative> Well, my first objection to this problem is that the [[String]] called 'compilers' doesn't  mention the JHC 
07:46:55 <Phyx-> my second objection is that it also doesn't mention UHC
07:47:29 <NiXM> haha nice one :)
07:47:35 <NiXM> well I only got this data delivered :P
07:48:03 <Phyx-> lol
07:48:43 <NiXM> it's working like this now but I'm not satisfied with it as I just started learning Haskell a bit and I'm 1000% sure this code can be written in like 10% of what there is now :)
07:48:43 <applicative> Phyx-, I see, but it mentions Helium....
07:48:48 <Phyx-> NiXM: I missed your question, So since I want to stop trolling... what was your question? :)
07:49:07 <Phyx-> applicative: true, but Helium isn't maintained, and not even used in the courses there anymore, afaik
07:49:31 <NiXM> well the original question was how I could get the data from one column, eq "Name", with "Name" aswell in the [String]
07:49:45 <NiXM> and benmachine answered that, haven't tested it though
07:49:58 <Phyx-> aha
07:49:58 <NiXM> but I'm pretty sure there are lots of additional things that can be improved
07:50:13 <NiXM> so if you come across something I'd be interested to know :)
07:50:14 <applicative> NIXM, here's the hlint advice: http://pastebin.com/ZGtQEV9i
07:50:40 <applicative> NIXM, if you have  'cabal install` installed you should be able to do `cabal install hlint`
07:51:07 <applicative> NIXM, it doesn't speak to the more important questions you were posing and benmachine et all were answering. 
07:51:57 <benmachine> I wouldn't listen to everything hlint says
07:52:08 <NiXM> i use winhugs now
07:52:15 <NiXM> seems very outdated but does the job :p
07:52:48 <applicative> benmachine, of course not.  It is especially good for getting used to operator precedences, I found. 
07:53:20 * Phyx- regrets not properly documenting his ADT
07:53:56 * applicative wished hugs were still loved by haskellers
07:54:12 <wakeupsticky> hi all
07:54:14 <NiXM> yeah as I said its probably heavily outdated
07:54:20 <NiXM> since winhugs didnt update somewhere 2006 lol
07:54:21 <wakeupsticky> how do i verify that i have gtk2hs installed? 
07:54:36 <benmachine> wakeupsticky: ghc-pkg list shows you what packages you have installed
07:54:49 <applicative> NIXM its fine, it just lacks the latest swank type extensions
07:55:08 <NiXM> aha never heard of that so I probably dont require it :p
07:55:14 <NiXM> anyway, if someone finds something horrible I'd like to know, I'm going to look into the changes posted here and try them out, thanks all :)
07:55:49 <applicative> NIXM, no, but you will later, after the Haskell heroin takes possession of all the cells in your body....
07:56:01 <NiXM> haha
07:56:06 <wakeupsticky> ok, i have gtk, glib, gio, cairo, pango
07:56:12 <wakeupsticky> is that all there is to gtk2hs?
07:56:29 <applicative> wakeupsticky, I think thats right
07:56:38 <adept> am I right in assuming that haskell-src-exts does not do sources with CPP?
07:57:01 <wakeupsticky> ok, and i have gtk itself
07:57:23 <wakeupsticky> when i try to compile the first example in the gtk2hs tutorial i get a bunch of "undefined reference to ___" errors
07:57:52 <applicative> wakeupsticky how did you install ghk2hs?
07:58:14 <applicative> wakeupsticky, and what platform are you on?
07:58:17 <wakeupsticky> i used cabal (but am on windows)
07:58:57 <Phyx-> adept: that's correct
07:58:59 <benmachine> adept: I believe so
07:59:07 <benmachine> adept: it's hard to imagine how that would actually work
07:59:51 <benmachine> adept: it could just run cpp and give you the result, but that wouldn't be quite what you wanted from a parser, I think
07:59:59 <wakeupsticky> http://pastebin.com/JzV4N6G1
08:00:06 <wakeupsticky> that's the batch of error messages
08:00:08 <Phyx-> benmachine: I wish it would just parse them and return them in a list of annotation instead of crashing though
08:00:16 <wakeupsticky> http://www.muitovar.com/gtk2hs/chap2.html
08:00:21 <wakeupsticky> that's the example i'm trying
08:00:24 <adept> Phyx-: +1
08:01:08 <adept> yep, I would be perfectly happy with any outcome not involving crashing
08:01:11 <benmachine> Phyx-: just parse them? but what would it give you for the AST?
08:01:24 <benmachine> returning ParseFailed is not what I'd call a crash?
08:01:41 <benmachine> or does it actually *crash* because that sounds unpleasant
08:02:29 <Phyx-> benmachine: well, would extend the synrax somewhat, so that cpp statements are part of the AST. that way, atleast I can get some information out of it.
08:02:38 <Phyx-> no, it returns ParseFail
08:02:46 <Phyx-> but my usecase is for instance I want to parse datatypes
08:03:00 <Phyx-> most CPP stuff are around function definitions
08:03:08 <Phyx-> so I should still be able to get my datatypes
08:03:32 <benmachine> Phyx-: it's hard to get cpp statements as part of the AST though, because they can appear pretty much anywhere
08:04:07 <applicative> wakeupsticky sorry, I can't help you; I can't compile it either, but for a different reason, viz, the crossed iconv wires i have going at the moment. 
08:04:23 <Phyx-> benmachine: aren't haskell expressions always seperated by a newline? so isn't adding CPP statements as valid haskell expressions enough?
08:04:38 <Phyx-> I haven't seen inlined cpp 
08:04:41 <benmachine> wakeupsticky: are you using ghc --make?
08:04:56 <benmachine> Phyx-: haskell expressions can contain newlines
08:05:06 <wakeupsticky> no i just did ghc -o helloworld helloworld.hs
08:05:09 <wakeupsticky> is that my problem?
08:05:20 <applicative> it should be as the text says:  ghc --make GtkChap2.hs -o Chap2
08:05:29 <benmachine> wakeupsticky: ghc --make works out a lot of the nasty details for you
08:05:35 <wakeupsticky> ah
08:05:38 <wakeupsticky> <- noob 
08:05:40 <wakeupsticky> :)
08:05:42 <benmachine> you can do without it but you have to manually specify which packages you want I think
08:05:51 <benmachine> yeah, I don't know why it's not just default these days
08:05:54 <wakeupsticky> oh, and that would require a bunch of pointing to packages
08:05:58 <Phyx-> benmachine: sure, it might not be a trivial solution, but it should be possible. If I had the time, I would have written a proposal
08:06:25 <benmachine> Phyx-: I think the complication cost to benefit ratio would be bad
08:06:40 <benmachine> Phyx-: maybe I'm wrong, but no-one has the time to prove it :P
08:06:59 <wakeupsticky> ok, that worked
08:07:06 <wakeupsticky> i will remember to use --make instead 
08:07:12 <applicative> wakeupsticky you can find out the difference --make makes if you ask `ghc --help`, though it's not maximally informative
08:07:25 <benmachine> Phyx-: but keep in mind that no tool at the moment completely parses files using cpp - cpp doesn't parse the haskell, and ghc doesn't parse the preprocessor stuff
08:07:39 <wakeupsticky> if i understand correctly you want to use --make if you're not just trying to compile from a single source file...?
08:07:47 <wakeupsticky> but rather using other packages
08:08:02 <applicative> wakeupsticky, if you want standard optimizations -- not necessary here -- you type "ghc --make -O2 hello.hs -o hello"
08:08:10 <benmachine> wakeupsticky: you pretty much want to use --make all the time, I think
08:08:14 <Phyx-> benmachine: Can GHC return a preprocessed haskell file?
08:08:15 <wakeupsticky> ok, will do
08:08:21 <wakeupsticky> silly me for modifying the example >_>
08:08:23 <wakeupsticky> thanks guys
08:08:23 <benmachine> Phyx-: hm?
08:09:07 <chrisdone> beep
08:09:07 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
08:09:21 <chrisdone> @messages
08:09:22 <lambdabot> benmachine said 2h 51m 31s ago: it still bothers me that I annoyed you yesterday, it wasn't my intention but I could have been more conciliatory, so my apologies!
08:09:33 <ManateeIrcClient> Upgrade to fastirc .....
08:09:34 <ManateeIrcClient> ...
08:09:35 <ManateeIrcClient> ..
08:09:37 * chrisdone hugs benmachine
08:09:39 <ManateeIrcClient> upgrade finishe...
08:09:48 * benmachine hugs chrisdone
08:10:05 <ManateeIrcClient> mm_freak: I have replace my code with fastirc, looks works well.
08:10:29 <Phyx-> benmachine: well, what i mean is, instead of calling cpp with the proper values etc (especially for DEFs that GHC defines). can you pass a hs file to ghc, have it only preprocess and return a hs file
08:10:48 <benmachine> Phyx-: oh, I don't know to be honest
08:11:25 <benmachine> Phyx-: ghc -E might do it
08:11:35 <benmachine>     -E		stop after generating preprocessed, de-litted Haskell
08:11:36 <benmachine> 		     (used in conjunction with -cpp)
08:12:13 <Phyx-> benmachine: so that would be tha most logical course of action for haskell-src-exts to take i think
08:12:41 <Phyx-> preferably by calling the ghc executable and not the ghc api, to skip that major dependency
08:13:08 <benmachine> well, if it calls the ghc executable you need ghc installed where your executable is running
08:13:15 <benmachine> also you need IO
08:13:27 <benmachine> also, which macros do you define?
08:13:27 <Phyx-> you need IO to read the file anyway
08:13:40 <benmachine> also, this is no good for e.g. syntax highlighting, because you only ever get some of the file at a time
08:13:50 <benmachine> Phyx-: well yes, but suppose you're given the file in a string
08:14:00 <Phyx-> and he could use ghc-paths to find ghc
08:14:01 <ManateeIrcClient> dom96: I think you and me should stop develop IRC parser, use fastirc's module : Network.FastIRC.Messages.
08:15:12 <Phyx-> benmachine: well, unsafePerformIO? *hides*
08:15:34 <benmachine> eek.
08:16:24 <Phyx-> benmachine: you could make a new method, xxxWithPreprocess :: ... -> IO ParseResult
08:16:35 <Phyx-> so if you want the preprocessor to run, you'll always get IO
08:17:07 <benmachine> Phyx-: but you still end up not parsing the bits of the file that cpp excludes, so e.g. hlint would miss bits out
08:18:00 <dom96> ManateeIrcClient: meh, i think mine is far enough in development anyway.
08:18:00 <lambdabot> dom96: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:18:07 <dom96> wow
08:18:15 <Phyx-> benmachine: but the parts that cpp excludes would have been excluded by ghc aswell
08:18:57 <benmachine> Phyx-: presumably they'd be excluded by your ghc, but not others, otherwise what's the point of having them?
08:19:48 <Phyx-> benmachine: which is true, but the ghc won't be hardcoded, so it'll exclude the correct one on every user's pc
08:20:23 <benmachine> Phyx-: mm, except going back to the hlint example, I want to be told about things I've done wrong in every codepath, not just the ones I'd use
08:23:26 <Phyx-> benmachine: true, but it's a tradeoff, what if the code in every path doesn't typecheck. for instance say that hint to check the type of every function, hint i tied to the ghc version which
08:23:49 <Phyx-> or if you're using haskell-src-exts to generate code to be compiled by ghc, you would want it in a format that did compile first
08:24:19 <ManateeLazyCat> dom96: I have fix a bug of you Messages.hs
08:24:35 <ManateeLazyCat> dom96: When hostname have ':', your smartSplit will failed.
08:24:45 <ManateeLazyCat> dom96: type /whois mm_freak 
08:24:58 <benmachine> Phyx-: I failed to parse the message before your last
08:25:11 <ManateeLazyCat> dom96: Then you know what's wrong.
08:25:30 <monochrom> hehe
08:25:39 <Saizan> Phyx-: hlint /= hint
08:25:39 <dom96> ManateeLazyCat: yeah, that's what the messages were about.
08:26:04 <Phyx-> Saizan: yes I know, that's critical to my point
08:26:46 <Phyx-> benmachine: what i meant was, code/patterns/extensions get deprecated as time goes on, so if you're generating code based on what you parse, if you get all codepaths instead of only the ones you know to work for your current ghc version, you might generate bad code
08:26:47 <dom96> ManateeLazyCat: messages from lambdabot that is.
08:26:53 <ManateeLazyCat> dom96: FastIRC has a function that convert ByteString to Command, looks good.
08:27:13 <dom96> I think it uses parsec
08:27:21 <benmachine> Phyx-: ah. but that's always the problem with anything using cpp, pretty much
08:27:31 <Saizan> anyhow, to support both use cases you'd just have to parse the file into a tree structure with the conditions in the nodes, which you can then specialize if you want a single haskell source
08:27:42 <ManateeLazyCat> dom96: It use attoparsec
08:27:48 <ManateeLazyCat> @package attoparsec
08:27:48 <lambdabot> http://hackage.haskell.org/package/attoparsec
08:28:10 <benmachine> Phyx-: it all comes down to what you think haskell-src-exts is *for*, and I think most of the jobs it serves wouldn't work with CPP very well
08:28:18 <Phyx-> Saizan: we started with that, but benmachine mentioned it might be difficult to do, so we went ona  different path
08:28:22 <benmachine> Phyx-: which is part of the reason I dislike cpp in general
08:28:44 <benmachine> Saizan: the trouble being you can have condition branches in the middle of an expression
08:29:03 <benmachine> or a declaration, or anything else really
08:29:07 <Phyx-> benmachine: I have only used it to generate code based on haskell files. currently I can't do it for 80% of the GHC sources
08:29:23 <benmachine> Phyx-: ah, okay
08:29:33 <ManateeLazyCat> dom96: I need eat feed now,  back soon.
08:30:57 <Phyx-> benmachine: for instance, for visual haskell, i read my haskell sources to generate the proper marshalling instances for datatypes I want to export
08:31:06 <dom96> ManateeLazyCat: ok
08:31:18 <Phyx-> that currently fails on GHC sources and require me to manually edit the fils
08:31:23 <benmachine> hmm
08:31:31 <benmachine> what does exporting a datatype mean?
08:31:47 <Phyx-> in my case, creating Storable instances
08:31:51 <benmachine> oh right
08:31:59 <Phyx-> but I would need to know the definition of the datatype
08:32:07 <benmachine> mm
08:33:08 <benmachine> Phyx-: can't you just use cpphs-as-a-library yourself?
08:33:14 <benmachine> actually haskell-src-exts depends on cpphs
08:33:18 <osaunders> @hoogle a -> [a]
08:33:19 <lambdabot> Prelude repeat :: a -> [a]
08:33:19 <lambdabot> Data.List repeat :: a -> [a]
08:33:19 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
08:33:19 <benmachine> I never quite worked out why
08:34:06 <monochrom> > replicate 1 True
08:34:07 <lambdabot>   [True]
08:34:10 <monochrom> \o/
08:34:22 <chrisdone> /o/
08:34:26 <copumpkin> \o\
08:34:30 <Phyx-> benmachine: yeah, i plan on just calling cpp later myself, but it's not a priority atm, which is why I never did it
08:34:40 <monochrom> /o\
08:34:53 * chrisdone laughs
08:35:07 <Peaker> > map text $ sequence [['/', '\\'], "o", ['/', '\\']]
08:35:08 <lambdabot>   [/o/,/o\,\o/,\o\]
08:35:30 <monochrom> \âˆ©/  <-- the robot rejoices too
08:35:44 <BrianHV> :t text
08:35:45 <lambdabot> String -> Doc
08:35:51 <mm_freak> ManateeLazyCat: greatâ€¦  some time you'll get a complete session handler
08:35:54 <benmachine> weird, all the cpphs library functions are in IO
08:37:17 <benmachine> unlit is pure, though
08:37:22 <chrisdone> Peaker++
08:37:28 <chrisdone> monochrom: haha
08:38:10 <Peaker> > map text $ sequence ["/\\|", "onO", "/\\|"]
08:38:11 <lambdabot>   [/o/,/o\,/o|,/n/,/n\,/n|,/O/,/O\,/O|,\o/,\o\,\o|,\n/,\n\,\n|,\O/,\O\,\O|,|o...
08:38:24 <Peaker> ok, some of these don't look so great :)
08:43:51 <napping> Good Morning! Does GHC provide any fairness guarantees for IO? (especially network IO under the threaded runtime)
08:44:57 <Peaker> Up until a while ago (I think that was fixed), a non-allocating IO thread could starve all the rest
08:44:59 <Peaker> so I doubt it :)
08:47:16 <napping> Well, it claims to provide fairness in the eventual progress sort of sense (besides that allocation thing)
08:47:45 <napping> I'm wondering more about interleaving of IO
08:48:12 <ManateeLazyCat> mm_freak: No, i just need your Messages.hs, i have complete framework to handle event or serverSet.
08:48:29 * hackagebot graph-rewriting-gl 0.6.2 - OpenGL interface for interactive hypergraph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6.2 (JanRochel)
08:50:21 <napping> I have several sockets, and clients are supposed to send a message before a deadline. I imagine the non-threaded runtime would process threads with ready sockets in a round-robin order
08:56:00 <dom96> ManateeLazyCat: your solution to that bug is nice, i hope you don't mind if i use your code :P
08:56:36 <micahjohnston> I'm having trouble getting code using the haskell bindings of llvm to build
08:56:49 <ManateeLazyCat> dom96: My code under GPL-3
08:57:17 <dom96> well you borrowed my code so...
08:57:43 <ManateeLazyCat> dom96: Now i use FastIRC... .:)
08:57:51 * dom96 cries
08:58:57 <ManateeLazyCat> dom96: I understand, but fastirc looks complete and test widely.
08:59:57 <chrisdone> I wonder if people will still be writing irc clients when I'm 60
09:00:27 <chrisdone> BUT WE NEED BETTER WAYS TO SUBMIT ONE LINE MESSAGES!
09:00:28 <dom96> I think that IRC will be long dead by then.
09:00:37 <ManateeLazyCat> chrisdone: http://www.flickr.com/photos/48809572@N02/4985793617/lightbox/
09:01:46 <ManateeLazyCat> dom96: Infact, your SimpleIRC is good enough, just because fastirc more test, and i haven't so much time test every situation....
09:02:23 <ManateeLazyCat> dom96: I suggest you use my code replace your's. I optimize some code.....
09:02:28 <dom96> How do you know fastirc has been tested more?
09:02:43 <ManateeLazyCat> dom96: Author tell me. :)
09:03:04 <dom96> ManateeLazyCat: SimpleIRC has been tested LOT'S too! :P
09:03:17 <ManateeLazyCat> dom96: Yes.
09:03:41 <ManateeLazyCat> dom96: Infact, develop irc parser is fun, just i want "ByteString -> Command" function now.
09:03:49 <ManateeLazyCat> dom96: And i haven't so much time on those.
09:04:17 <dom96> What's Command meant to be?
09:04:40 <ManateeLazyCat> dom96: Example, when you get ByteString from socket, it will parse ByteString and return Comand.
09:04:52 <ManateeLazyCat> dom96: Command like : JoinCmd.... ModeCmd ....
09:05:06 <ManateeLazyCat> dom96: Now you have encodeCommand that convert Command to ByteString.
09:05:24 <dom96> I already have a function which does that in SimpleIRC
09:05:26 <ManateeLazyCat> dom96: But i need reverse function that convert ByteString to Command.
09:05:35 <ManateeLazyCat> dom96: parse?
09:06:01 <dom96> I don't need a function which turns a ByteString into a Command, IrcMessage is good enough for me.
09:06:35 <ManateeLazyCat> dom96: Yes, but i need parse IrcMessage again to detect which command.
09:07:25 <dom96> Well, see if you used SimpleIRC fully, you wouldn't need to.
09:07:41 <ManateeLazyCat> dom96: Well, i don't mean FastIrc is better than SimpleIRC, both are cool libraries, just i haven't so much time parse IrcMessage again.
09:08:13 <Phyx-> hmm that's odd
09:08:15 <Phyx-> I can do
09:08:22 <Phyx-> ghci Cabal.XML.Instances
09:08:32 <Phyx-> but I can't do :m +Cabal.XML.Instances
09:09:00 <monochrom> go to a different directory. then you'll get the opposite.
09:09:21 <Phyx-> but ghci is still running in the root
09:09:50 <monochrom> quit ghci. go to a different directory. start ghci.
09:10:12 <Phyx-> if I go to any other dir, i won't be able to load any of them :/
09:10:50 <monochrom> you can do :m +Cabal.XML.Instances
09:10:52 <Phyx-> if i pass them both to ghci on startup, then i can do :m +
09:11:16 <Phyx-> monochrom: in order to do that I need to be in the folder which contains the folder "Cabal"
09:11:24 <Phyx-> if i go anywhere else, the path won't work
09:11:26 <Phyx-> afaik
09:12:27 <chrisdone> Phyx-: add the source path with :set
09:15:19 <monochrom> :m X requires X to be in a library xor you did :load X
09:16:30 <Phyx-> I always thought ghci would look in your current path aswell and load that if found
09:17:54 <Saizan> Phyx-: "import X" will do that
09:21:25 <Phyx-> wee
09:21:33 <Phyx-> 5 hours of coding comes down to seeing what
09:21:34 <Phyx-> processPackage "../Cabal2MSBuild.cabal" >>= \a -> writeXML a "Test.proj"
09:21:35 <Phyx-> does
09:21:36 <Phyx-> :)
09:23:48 <Phyx-> epic fail
09:27:25 <ManateeIrcClient> Someone boring? Talk to me?
09:27:55 <jmcarthur> lol, a rubyist asked me my language of choice, and when i said "haskell" he said "ah yes, the language of wizards"
09:29:04 <monochrom> at least perl used to be the language of wizards.
09:29:17 <monochrom> and c before that
09:29:36 <monochrom> see? progress! \âˆ©/
09:30:02 <monochrom> now perl is the language of monks.
09:30:02 <napping> That sounds more like the sense in which lisp was the language of wizards
09:30:57 <ManateeIrcClient> napping: Now Haskell is language of nuts .... :)
09:35:27 <micahjohnston> has anyone gotten the llvm haskell bindings to work?
09:35:51 <Peaker> monochrom, do you like Perl?
09:36:07 <monochrom> No. I liked it a decade ago.
09:36:19 <Peaker> monochrom, What happened then?
09:36:40 <monochrom> As in, how could I even come to like Perl for a moment? XD
09:37:02 <monochrom> I liked perl for a while. SML displaced it.
09:38:44 <Peaker> I like Python. I used to like it a lot more
09:38:59 <Peaker> Then I found Haskell, and Python isn't so hot anymore...
09:39:12 <Peaker> But it still is much nicer to work with than the "mainstream" stuff
09:39:23 <Peaker> (well, Python became mainstream since..)
09:39:24 <monochrom> SML brought out my subconcious preference to strong static typing. Prior to meeting SML, I was already writing comments in lisp and perl like "this function takes a list of numbers and returns a bag of bools".
09:49:43 <rdeshpande> anyone here using  haskell in the workplace?
09:50:54 <sioraiocht> rdeshpande: I wish!
09:51:05 <sioraiocht> rdeshpande: I'm a researcher and use it for that
09:52:17 <rdeshpande> i would love to get a job writing haskell or any functinoal language for that matter
09:52:21 <rdeshpande> but options seem few and far between
09:58:49 <monochrom> write in javascript. functional enough.
10:00:47 * Phyx- just unlocked his "write a program using ByteString" achievement
10:01:47 <monochrom> haha
10:06:42 <Phyx-> actually
10:06:53 <Phyx-> why *should* have haskell achievements
10:06:53 <Phyx-> :P
10:11:41 <copumpkin> Phyx-: yeah, I proposed that a while ago, but nobody has done it yet :(
10:11:48 <copumpkin> I think it's cause I was supposed to
10:12:00 <cis194> hi everyone, say hello to my Haskell class =)
10:12:09 <cis194> (this is byorgey)
10:12:15 <copumpkin> omg it's byorgey
10:12:25 <copumpkin> hi byorgey's Haskell class!
10:12:31 <monochrom> hi haskell class. isn't haskell exciting?
10:12:40 <cis194> thanks =)
10:12:53 <c_wraith> Hello classroom!  remember everyone, fix is your favorite function! :)
10:12:54 <copumpkin> have they realized how exciting it is yet?
10:12:58 <monochrom> \âˆ©/  <--- the robot rejoices
10:13:03 <copumpkin> or are they still in the "wtf is this" stage?
10:13:18 <fryguybob> > text "Hi byorgey's class!"
10:13:19 <lambdabot>   Hi byorgey's class!
10:13:32 <Phyx-> copumpkin: lol
10:13:35 <aristid> > transpose cake
10:13:36 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
10:13:43 <Phyx-> what would we call them copumpkin ?
10:13:52 <copumpkin> Phyx-: hachievements!
10:13:56 <copumpkin> <_<
10:14:00 <micahjohnston> > text 3
10:14:01 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
10:14:01 <lambdabot>    arising from the literal `...
10:14:17 <aristid> > text (show 3)
10:14:18 <lambdabot>   3
10:14:22 <Phyx-> classroom, c_wraith means Data.Function.fix not me.. "phyx"
10:14:28 <aristid> :t show
10:14:29 <lambdabot> forall a. (Show a) => a -> String
10:14:30 <Phyx-> copumpkin: hahaha
10:14:32 <aristid> :t text
10:14:33 <lambdabot> String -> Doc
10:14:42 <micahjohnston> what's Doc
10:14:50 <c_wraith> > fix $ (0:) . scanl (+) 1
10:14:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:14:56 <monochrom> Doc is in Text.PrettyPrint.something
10:15:01 <c_wraith> Doc is part of one of the pretty-printing packages
10:15:19 * Phyx- uses type PP_Doc = Reader Int B.ByteString
10:15:38 <aristid> > fix f :: Expr
10:15:39 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
10:15:45 <aristid> \o/
10:16:25 <copumpkin> aristid: little do you know that there's an infinite string of u further down there
10:16:49 <micahjohnston> what's the function where f 3 a = [a, a, a]
10:16:49 <aristid> copumpkin: there's an infinite string of me in fix f?
10:17:11 <copumpkin> no, f (f ( f ( f( f (f (f ... (u (u (u (u (u ...
10:17:11 <aristid> micahjohnston: is that a question to the classroom or to #haskell? :P
10:17:17 <monochrom> > replicate 3 'a'
10:17:17 <lambdabot>   "aaa"
10:17:18 <micahjohnston> to #haskell
10:17:19 <micahjohnston> :P
10:17:22 <micahjohnston> thanks
10:17:38 <Phyx-_> grrr i really hate that stupid pause button
10:17:43 <Phyx-_> irssi never comes back
10:17:51 <micahjohnston> > zipWith replicate [1..] "whoa"
10:17:52 <lambdabot>   ["w","hh","ooo","aaaa"]
10:17:56 <Phyx-_> why do keyboards have a "pause" button anyway?
10:18:13 <monochrom> for games
10:18:14 <ski> Phyx-_ : did it disable flow control, or what ?
10:18:14 <micahjohnston> > (concat . zipWith replicate [1..]) "whoa"
10:18:15 <lambdabot>   "whhoooaaaa"
10:18:22 <aristid> Phyx-_: your keyboard has a pause button?
10:18:24 <micahjohnston> > text (concat . zipWith replicate [1..]) "whoa"
10:18:25 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:18:25 <lambdabot>         against inferred type...
10:18:31 <micahjohnston> > text $ (concat . zipWith replicate [1..]) "whoa"
10:18:32 <lambdabot>   whhoooaaaa
10:18:37 <Phyx-_> ski: it seems to have detached the process from rxvt
10:18:44 <Phyx-_> aristid: yes
10:18:58 <Raghs> how can i use IO Bool in filter?
10:19:00 <patch-tag> what does it mean when program runtime errors with <<<loop>>> ?
10:19:12 <ski> @type filterM  -- Raghs
10:19:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:19:13 <aristid> Raghs: with (=<<)
10:19:24 <Phyx-_> patch-tag: it means you have a recursive definition
10:19:29 <aristid> @src filterM
10:19:30 <lambdabot> Source not found. Just try something else.
10:19:36 <ski> @index filterM
10:19:36 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:19:36 <patch-tag> that's what I thought. k back to reading source...
10:19:40 <aristid> :t filterM
10:19:41 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:19:44 <patch-tag> Raghs: also liftM
10:20:11 * Phyx-_ wonders how to kill the other irssi without killing this one...
10:20:15 <Phyx-_> hmm process id...
10:20:46 <Phyx-_> dddddddddd
10:20:49 <Phyx-_> nope, not that one
10:20:55 <Phyx-_> eeee
10:20:56 <Phyx-_> yup
10:23:28 <patch-tag> Raghs: liftM (filter even) :: IO [Int] -> IO [Int] :: IO [Int] -> IO [Int]
10:24:03 <Raghs> patch-tag -> super, thanks. let me try that
10:24:51 <ski> Raghs : that only allows you to feed an `IO [Int]' to it .. if you wanted to use a predicate `Whatever -> IO Bool', then you need `filterM', as mentioned above
10:25:24 <Raghs> filterM is what i want as my predicate is IO Bool and list is [String]
10:25:41 <ski> *nod*
10:27:27 <roconnor> woah, someone is using filterM?
10:27:52 <micahjohnston> can anyone help me with haskell's llvm bindings?
10:28:20 <aristid> @pl \p l -> (\p' -> filter p' l) `fmap` p
10:28:20 <lambdabot> flip (fmap . flip filter)
10:28:31 <gwern> roconnor: why are you so surprised? I get quite a few hits locally for uses of filterM
10:28:40 <roconnor> really?
10:28:51 <roconnor> I don't recall seeing it used myself
10:29:01 <roconnor> I've always wondered where it gets used
10:29:02 <gwern> sure
10:29:04 <micahjohnston> I installed llvm, and I cabal install'd haskell llvm bindings, but when I try to actually use a function that calls the c code from ghci, I get
10:29:06 <micahjohnston> Loading package llvm-0.8.0.2 ... can't load .so/.DLL for: LLVMSystem (dlopen(libLLVMSystem.dylib, 9): image not found)
10:29:07 <gwern> here are some examples from find
10:29:08 <aristid> roconnor: does grep recall it?
10:29:09 <gwern>      filterM (runGhc1 GHC.isLoaded . GHC.ms_mod_name) all_mod_summ
10:29:10 <gwern>        not_interpreted <- filterM (liftM not . mod_is_interpr) ms_mods
10:29:10 <gwern>     filterM (fileIsDirectory . ((dir ++ "/") ++))
10:29:13 <micahjohnston> and with ghc, I get a bunch of linker errors
10:29:25 <gwern>        filterM (liftM isRealDirectory . getFileStatus . (dir </>))  c
10:29:26 <gwern>              filterM (\ f -> doesDirectoryExist f >>= return . not) [path] >>=
10:29:26 <gwern>                             filterM (doesFileExist . ((outsidePath root ++ "/") ++))
10:29:28 <gwern>                          (do paths' <- filterM doesFileExist paths
10:29:32 <aristid> :t (</>)
10:29:33 <lambdabot> Not in scope: `</>'
10:29:38 <gwern> I could go on but I think roconnor  gets the idea
10:29:42 <roconnor> :)
10:29:54 <aristid> gwern: maybe you want </> from wherever instead of  ((dir ++ "/") ++)?
10:29:58 <aristid> @hoogle (</>)
10:29:59 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
10:29:59 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
10:29:59 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
10:30:08 <gwern> aristid: I didn't write this code!
10:30:24 <aristid> gwern: i thought you were talking about you using it
10:30:39 <gwern> aristid: I am a packrat of code, so I can grep it all
10:31:12 <gwern> aristid: and make little comments like this. I enjoy the brief feeling of superiority over better coders like roconnor
10:31:28 <Raghs> okay- filterM works, now I have IO [TypeA] - how do I writeFile this?
10:31:43 <aristid> :t (>>=)
10:31:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:31:52 <aristid> :t writeFile
10:31:53 <lambdabot> FilePath -> String -> IO ()
10:32:06 <ski> Raghs : use `<-' or `=<<' or `>>=' to bind it to a result, passing that to `writeFile'
10:32:32 <aristid> :t \l -> l >>= \l' -> writeFile "/home/raghs/path.txt" l'
10:32:33 <lambdabot> IO String -> IO ()
10:32:45 <aristid> :t \l -> l >>= writeFile "/home/raghs/path.txt"
10:32:46 <lambdabot> IO String -> IO ()
10:33:02 <aristid> Raghs: there.
10:33:25 <copumpkin> >=>
10:33:40 <copumpkin> why would you want an IO as input?
10:33:59 <aristid> copumpkin: "now I have IO [TypeA] - how do I writeFile this?"
10:34:22 <copumpkin> I dunno, how do you make TypeA into a string? :P
10:34:24 <ski>   writeFile "/etc/shadow" . unlines =<< filterM isFoo strings  -- or whatever
10:34:35 <aristid> TypeA is Char, i suppose.
10:35:47 <micahjohnston> can anyone help me with llvm/haskell? :(
10:46:15 <mwc> Is there any subtle reason why we can't have data or (newtype) declarations inside a where clause?
10:46:44 <mwc> it seems to me to be a pretty straightforward extension to the language
10:47:05 <micahjohnston> unless you want the where clause to return something of that new type, and outside it nothing knows what it is
10:47:17 <c_wraith> But that's not a problem
10:47:24 <mwc> (I need a newtype to break a cyclic type inside a pair of birecursive functions written in CPS)
10:47:27 <c_wraith> It's just a standard "unknown symbol" error
10:47:32 <benmachine> yeah I'd think the data would have to not be in the type signature of the function
10:47:47 <c_wraith> "I don't know what this Foo type is, because it's not in scope here."
10:47:52 <mwc> micahjohnston: yeah, obviously that shouldn't work, but I'm thinking of types that are only used internally
10:48:05 <quicksilver> mwc: no reason as far as I know or that I can think of
10:48:12 <benmachine> mwc: I suppose it's just not that common a need?
10:48:18 <mwc> probably too late to get into Haskell' huh?
10:48:22 <quicksilver> I've wanted it quite often.
10:48:26 <copumpkin> make a prposal
10:48:37 <quicksilver> mwc: write it as a GHC extension, and then propose it.
10:49:05 <quicksilver> generally nothing gets into Haskell' which doesn't actually already exist as a working implementation.
10:49:09 <mwc> I thought I'd ask because when something obvious isn't in GHC yet, it's probably because there's some subtle flaw I haven't thought of
10:49:18 <Igloo> No hope for H2011, but H' is an ongoing process
10:49:34 <benmachine> but let's not make scoped instances, eh
10:49:36 <mwc> quicksilver: ahh, well, I'll look into implementing it sometime this fall
10:49:38 <benmachine> that could end in tears
10:49:52 <mwc> benmachine: oh yeah, though I could see how it could work ...
10:50:31 <mwc> mostly I want newtype Foo = Foo { unFoo :: a -> Either a Foo } and not to clutter up the top level of the module
10:50:37 <mwc> Foo a
10:51:32 <benmachine> mwc: well, you could use generic functor composition and recursive types
10:51:41 <benmachine> but that's a terrible idea so ignore me >_>
10:52:14 <mwc> I thought all recursive types had to go through a newtype or a data?
10:53:24 <benmachine> mwc: yes, but the idea is to define
10:53:30 <benmachine> newtype Mu f = f (Mu f)
10:53:36 <benmachine> and then you can use it anywhere you need a recursive type
10:53:49 <mwc> bwahaha
10:54:23 <mwc> then you just need to determine how to express the desired type as a fixed point.
10:54:26 <benmachine> yeah
10:54:28 <mwc> yeah, I might do that for now actually
10:54:39 <dom96> > "\x02BOLD!\x02"
10:54:40 <lambdabot>   "+OLD!\STX"
10:54:46 <mwc> I don't mind havingsomething general like that exposed to the top level of the module
10:54:48 <dom96> Why doesn't that work?
10:55:23 <benmachine> > '\x02B'
10:55:24 <lambdabot>   '+'
10:55:34 <sproingie> dom96: what are you expecting it to do?
10:55:48 <benmachine> > "\x02\^BOLD!\x02"
10:55:49 <lambdabot>   "\STX\STXOLD!\STX"
10:55:51 <dom96> bold
10:55:53 <benmachine> erm
10:56:02 <Raynes> He's expecting the ^B character.
10:56:06 <benmachine> oh whoops
10:56:23 <quicksilver> benmachine: I don't think it's a terrible idea at all. It's just a bit ugly to use.
10:56:26 <sproingie> ah.  i dont think \bot will ever print that raw
10:56:29 <Saizan> > text "\x02\^BOLD!\x02" -- they are stripped anyhow
10:56:30 <lambdabot>   OLD!
10:56:39 <quicksilver> it would be nice, in some ways, if it wasn't so ugly.
10:56:49 <benmachine> quicksilver: it's not intrinsically terrible, it'd just be really verbose, I think
10:57:01 <quicksilver> right
10:57:13 <dom96> Saizan: hrm? This channel isn't +c
10:57:19 <Raynes> The bot strips them.
10:57:25 <benmachine> lambdabot is clever
10:57:52 <benmachine> what's that thing you can use in string literals to say "stop this char here"?
10:58:01 <sproingie> "stop this char here"
10:58:08 <benmachine> there was something that began with \ but basically didn't represent a character
10:58:15 * benmachine looks up the report
10:58:28 <dom96> If anything, mueval strips it.
10:58:38 <Raynes> I was about to say that.
10:58:47 <benmachine> ah, \&
10:58:57 <Raynes> I don't think Elysiabot or the IRC library behind it strips that sort of thing, but the same thing happens there.
10:59:02 <benmachine> > "\x02\&BOLD!\x02"
10:59:03 <lambdabot>   "\STXBOLD!\STX"
10:59:08 <Raynes> Only common thing between them is mueval.
10:59:14 <sproingie> http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html
10:59:16 <gwern> roconnor: my find says that there are ~730 local uses of filterM; assuming half of them are doublecounts from _darcs and the occasional definition of it, that's a good 300 uses
10:59:33 <roconnor> :)
10:59:41 <benmachine> gwern: do you have any way of finding out how often that's in IO?
10:59:47 <Saizan> dom96: i'm pretty sure lambdabot postprocesses the output of mueval to keep only the printable chars
10:59:56 <gwern> benmachine: well, not easily
11:00:01 * fxr all I see is products and sums
11:00:12 <benmachine> gwern: oh, well, don't worry then :P but I reckon it's nearly all of them
11:00:12 <dom96> Saizan: my bot doesn't, and it still doesn't make the text bold.
11:00:13 <Saizan> or maybe it's "text"
11:00:21 <gwern> benmachine: I suppose one could pick a few dozen randomly and see whether they're in an IO function by hand
11:00:25 <Raynes> Saizan: That's likely, but his doesn't and the exact same thing happens.
11:00:31 <dom96> That's a possibility
11:00:50 <benmachine> gwern: just a passing curiousity, I wouldn't bother
11:01:46 <benmachine> Saizan: doing text "\^BBOLD!\^B" in ghci doesn't strip them, I can say that much
11:02:09 <benmachine> hmm, mueval seems tied to compiler version
11:02:14 <benmachine> I guess that's to be expected
11:02:17 * benmachine recompiles it
11:02:40 <dom96> > text "\02 test"
11:02:41 <lambdabot>    test
11:02:49 <benmachine> huh
11:02:52 <benmachine> cabal info mueval
11:02:52 <dom96> lambdabot strips it.
11:03:01 <benmachine> lists among the dependencies
11:03:14 <benmachine> base >=4 && <5, [...], base -any, base -any
11:04:14 <benmachine> oh it just lists those of the library and then those of each executable
11:05:15 <ski> mwc : i've wanted such a feature on several occasions
11:05:33 <ski> mwc : note that `newtype Foo = Foo { unFoo :: a -> Either a Foo }', with `a' as a free type variable (e.g. bound by `ScopedTypeVariables') would also make sense, and be useful, i think
11:06:11 <gwern> benmachine: I'm glad you approve
11:07:57 <benmachine> gwern: not complaining! :P just a curiousity
11:08:25 <benmachine> also: lol at SimpleReflect.hs warning about shadowing existing bindings
11:13:05 <EvanCarroll> is there better docs to the graphic magick library than those on hackage
11:13:17 <EvanCarroll> http://hackage.haskell.org/packages/archive/hsmagick/0.4/doc/html/Graphics-Transform-Magick-Images.html
11:14:24 <EvanCarroll> do I have to calculate the aspect ratio to use scaleImage
11:14:24 <benmachine> > x < y
11:14:25 <lambdabot>   True
11:21:04 <Rajjder> Hi! I've have a question if someone could help me?
11:21:40 <Botje> today's chance of getting help is 99.99%
11:21:42 <Botje> go for it!
11:23:04 <EvanCarroll> Botje: when did you join the chan?
11:23:39 <Botje> EvanCarroll: i've been here for a couple of years now
11:23:40 <EvanCarroll> I didn't know you were a haskell user
11:23:42 <Rajjder> Me and my buddy is currently coding a black jack card game. But we're stuck, our task is to define an operatorer were we like to add togheter two list of our own. Almost like the ++ functions already defined in haskell. 
11:23:43 <EvanCarroll> cool
11:23:51 <tolkad> What does this mean?
11:23:51 <tolkad> At least one of the forall'd type variables mentioned by the constraint
11:23:51 <tolkad> must be reachable from the type after the '=>'
11:23:54 <Botje> EvanCarroll: all the cool kids are here
11:23:58 <Rajjder> (<+) :: Hand -> Hand -> Hand
11:24:03 <Rajjder> (<+) h1 h2 = x : ( <+ h2)
11:24:17 <tolkad> it's rejecting my code
11:24:21 <tolkad> and I don't know why
11:24:25 <EvanCarroll> Botje: still hang in #perl?
11:24:43 <tolkad> do I have to use RankNTypes?
11:25:41 <tolkad> what does that error message mean?
11:26:35 <tolkad> :t read . show
11:26:36 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:26:39 <Rajjder> So my questions is, how do we add this two parameters togheter, we are thinking something recursive.
11:26:47 <Botje> EvanCarroll: yep
11:27:02 <tolkad> @let readshow = read . show
11:27:03 <lambdabot>  Defined.
11:27:08 <tolkad> > readshow 5
11:27:09 <lambdabot>   *Exception: Prelude.read: no parse
11:27:18 <Botje> Rajjder: so you have to redefine ++ ?
11:27:30 <Botje> Rajjder: how is the Hand type defined?
11:27:30 <tolkad> > readshow 5 :: Int
11:27:31 <lambdabot>   5
11:27:41 <tolkad> strange that that's a runtime error
11:27:50 <tolkad> anyway
11:28:16 <Rajjder> Botje, Yes we are going to redefine ++. This is the definition: data Hand = Empty | Some Card Hand
11:28:59 <EvanCarroll> Is there an event driven framework, that handles things like queues, limits, priorities, and exceptions for Haskell?
11:29:08 <Botje> Rajjder: okay. so your <+ function should take the two cases into account
11:29:17 <Botje> whats Empty <+ Some c h ?
11:30:21 <Rajjder> Botje, Yes, two hands should be taken
11:30:22 <benmachine> > readshow ()
11:30:23 <lambdabot>   ()
11:30:46 <Rajjder> Botje, (<+) Empty h2 = h2
11:31:13 <Botje> Rajjder: well, that's already one clause of the <+ function
11:31:26 <Botje> what would (Some c1 h2) <+ hand be, then ?
11:31:37 <benmachine> tolkad: at a guess, that error is because you have a signature like f :: (Show r) => a -> Bool, i.e. there's a constraint that isn't in the signature itself
11:31:50 <Botje> (h1 or h2, whatever :p)
11:32:51 <Rajjder> The function should add two hands together on top of each other.
11:33:03 <tolkad> benmachine: oh that was it! thanks
11:33:21 <Botje> Rajjder: yes, so ..
11:33:31 <tolkad> benmachine: when I googled it I got this which had me totally confused: http://hackage.haskell.org/trac/ghc/ticket/1897
11:33:32 <Botje> imagine you have Some card Empty <+ hand
11:33:35 <Botje> what's the result of that?
11:34:10 <Rajjder> hand, i guess?
11:34:36 <tolkad> btw does anyone know how to tell GHC to store more error information for runtime? like filename/line on undefined errors
11:34:42 <tolkad> or stack traces
11:35:27 <tolkad> I am getting an undefined error and I have no idea where it is coming from
11:35:50 <adept> tolkad: compile with -prof -auto-all, run with +RTS -c (or is it -xc?)
11:36:27 <benmachine> you can do that but it's not always helpful
11:36:46 <benmachine> tolkad: you could try replacing undefined in your code with error "hello!"
11:37:08 <benmachine> or if you use something like let Just x = Nothing in x, you might get source location information automatically
11:37:15 <adept> benmachine: I assume it is not coming from his code
11:37:16 <benmachine> > let Just x = Nothing in x
11:37:17 <lambdabot>   *Exception: <interactive>:1:137-152: Irrefutable pattern failed for pattern...
11:37:23 <tolkad> adept: that broke importing network package
11:37:38 <tolkad> benmachine: I could if I knew where it was :P
11:37:44 <tolkad> I'll just have to figure it out lol
11:38:06 <adept> tolkad: install profiling version of network package (if you are using your OS package manager), or cabal install --reinstall -p network-x.y.z
11:38:20 <benmachine> tolkad: sed -i 's/undefined/(let Just x = Nothing in x)/g' over your whole codebase :P
11:39:15 <tolkad> uh oh it wants another profiling library 0_o
11:39:48 <tolkad> am I about to enter dependancy hell? :P
11:40:06 <adept> tolkad: it is usually rather limited
11:40:58 <Botje> Rajjder: so adding one card to a hand does nothing?
11:41:06 <tolkad> Warning: 'ghc-options: -prof' is not necessary and will lead to problems when used on a library. Use the configure flag --enable-library-profiling and/or --enable-executable-profiling.
11:41:07 <adept> tolkad: afair pkggraph could show you a nice picture of packages you have to rebuild
11:41:26 <adept> tolkad: heed this warning
11:41:26 <tolkad> ok yeah it wants me to install the profiling version of tons of different modules
11:41:32 <tolkad> I think I'll just find the error
11:42:03 <adept> tolkad: so you bet there there is _one_ error? ok, good luck ;)
11:42:05 <Rajjder> Botje, Exactly, the whole function is just for adding two hands together
11:42:12 <Rajjder> but a empty hand is nothing
11:42:18 <tolkad> adept: it's actually a fromJust...
11:42:29 <Rajjder> it's just a base case
11:42:56 <tolkad> but I only use fromJust if it should be impossible for something to be nothing and there's not really anything to do in the case that it is because that doesn't make sense
11:42:59 <tolkad> obviously I was wrong :P
11:44:02 <Botje> Rajjder: yes, and a hand with one card is Some card Empty
11:44:10 <adept> tolkad: as an added bonus, -xc would also try to show you "stack trace" leading to error. But in the long run it is better to understand why you were wrong, of course :)
11:44:22 <Botje> Rajjder: so adding that hand to hand of (say) 5 cards should give a hand with 6 cards, no?
11:45:14 <Rajjder> Botje, Yes, thats correct.
11:45:32 <Rajjder> That's what the function is all about
11:46:08 * hackagebot xmms2-client 0.0.4.0 - An XMMS2 client library.  http://hackage.haskell.org/package/xmms2-client-0.0.4.0 (OlegBelozeorov)
11:46:10 * hackagebot xmms2-client-glib 0.0.4.0 - An XMMS2 client library  GLib integration.  http://hackage.haskell.org/package/xmms2-client-glib-0.0.4.0 (OlegBelozeorov)
11:47:07 <Botje> Rajjder: so, what would the result of (Some card Empty) <+ hand look like?
11:47:09 * hackagebot vision 0.0.2.4 - An XMMS2 client.  http://hackage.haskell.org/package/vision-0.0.2.4 (OlegBelozeorov)
11:47:51 <Rajjder> still hand, since the other hand is empty
11:48:17 <fryguybob> Rajjder: What does a hand with one card look like?
11:48:56 <Botje> Rajjder: but the left hand has one card in it
11:49:11 <Botje> so that card should be added to the hand on the right, no?
11:50:14 <tolkad> "Failed to load interface for `Language.Haskell.TH.Syntax':"
11:50:22 <tolkad> what's that... I didn't import that
11:50:45 <tolkad> I'm just trying to use Debug.Trace
11:51:04 <rdeshpande> quit
11:51:30 <tolkad> ok maybe I wont use Debug.Trace then lol
11:51:31 <Rajjder> Botje, (<+) :: Hand -> Hand -> Hand this is the definition, two hands should be a new
11:52:59 <Botje> Rajjder: okay. so what if i say (Some card Empty) <+ hand = Some card hand ?
11:55:41 <acowley> tolkad: what did you do to trigger that error?
11:55:43 <gwern> tolkad: just roll your own trace with unsafePerformIO!
11:56:22 <zygoloid> Botje: then you'd have done someone's homework for them? ;)
11:56:34 <Botje> zygoloid: only part of it!
11:58:22 * ski . o O ( `(>+) :: Foot -> Foot -> Pain' )
11:58:37 <zygoloid> ski: you teaching lambdabot to dance?
11:59:38 <ski> .. i suppose that could be an idea
12:01:48 <Rajjder> Botje, Yes, i think thats correct
12:02:22 <Rajjder> But the question still remains how I should add these two list together.
12:02:38 <Rajjder> I made an honest try here, it might help you understand.
12:02:42 <Rajjder> (<+) (x:h1) h2 = x : (h1 <+ h2)
12:03:41 <tolkad> acowley: uh I tried to use Debug.Trace in global scope
12:03:58 <tolkad> acowley: I just wrote a debug script with it's own main instead
12:04:20 <fryguybob> @type \(<+) (x:h1) h2 -> x : (h1 <+ h2)
12:04:21 <lambdabot> forall t t1. ([t] -> t1 -> [t]) -> [t] -> t1 -> [t]
12:04:41 <tolkad> acowley: I was just doing it for convenience because some things that I wanted to get the value of weren't exported
12:04:51 <acowley> tolkad: If you run GHCI and do ":m +Debug.Trace" do you get that error, too?
12:05:10 <tolkad> no
12:05:31 <fryguybob> Rajjder: Where you have ":"'s you need to be using "Some".
12:05:47 <tolkad> acowley: I did do a manual build of GHC after intalling the haskell platform
12:06:00 <tolkad> acowley: I'm on Mac OS X leopard (no snow leopard)
12:06:14 <tolkad> acowley: and there isn't a haskell platform build with the latest version of GHC
12:06:55 <tolkad> acowley: so you could just blame that I guess
12:07:12 <acowley> tolkad: which GHC are you trying to use?
12:07:24 <adnap> How do you set the display precision of floating point numbers in GHCI?
12:08:04 <Rajjder> fryguybob, I don't understand why 
12:08:13 <dolio> > showFFloat (Just 2) 1.2345678
12:08:14 <lambdabot>   Overlapping instances for GHC.Show.Show
12:08:15 <lambdabot>                              (GHC.B...
12:08:20 <dolio> > showFFloat (Just 2) 1.2345678 ""
12:08:21 <lambdabot>   "1.23"
12:08:34 <gwern> hm. I didn't know you could do that. I thought one would have to override the Show instance with a newtype
12:08:40 <Rajjder> franksh_, if I understood you right, ghci doesn't like the definition
12:08:58 <adnap> > showFFloat (Just 2) (1 :+ 0)
12:08:58 <lambdabot>   No instance for (GHC.Float.RealFloat (Data.Complex.Complex t))
12:08:59 <lambdabot>    arising f...
12:09:23 <fryguybob> Rajjder: ":" is the data constructor for the list.  For your data type Hand, you have the Some constructor.
12:09:43 <adnap> How 'bout for complex numbers?
12:09:55 <adnap> I guess Complex a isn't an instance of RealFloat.
12:10:10 <tolkad> acowley: 6.12.3
12:10:52 <acowley> tolkad: The HP has 6.12.3
12:11:04 <acowley> tolkad: Or you can download a binary of just GHC
12:11:18 <adnap> > (showFFloat (Just 2) (realPart (1 :+ 0))) :+ (showFFloat (Just 2) (imagPart (1 :+ 0)))
12:11:19 <lambdabot>   No instance for (GHC.Float.RealFloat
12:11:20 <lambdabot>                     (GHC.Base.String -...
12:11:26 <adnap> Oh, XD
12:11:37 <adnap> > read (showFFloat (Just 2) (realPart (1 :+ 0))) :+ read (showFFloat (Just 2) (imagPart (1 :+ 0)))
12:11:37 <lambdabot>   Couldn't match expected type `GHC.Base.String'
12:11:38 <lambdabot>         against inferred typ...
12:11:54 <adnap> Ahhh, this is so bad.
12:12:10 <Rajjder> fryguybob, I don't se how "Some" could help me add two hands together
12:12:39 <zygoloid> Rajjder: "Some" is your way of representing a hand containing more than zero cards.
12:12:55 <tolkad> acowley: not for my version of Mac OS X
12:13:05 <zygoloid> Rajjder: if you're joining two hands which contain more than zero cards, the result should be a hand containing more than zero cards, right?
12:13:24 <Rajjder> yes, thats logic
12:14:00 <fryguybob> @src []
12:14:01 <lambdabot> data [] a = [] | a : [a]
12:14:01 <Rajjder> But I don't see how i could implement that in my function: (<+) h1 h2 = {-Add the list together here-}(h1 <+ h2)
12:14:17 <EvanCarroll> does cabal have a mode like cpan that I can just give it the package?
12:14:28 <acowley> tolkad: You're looking at http://hackage.haskell.org/platform/mac.html, right?
12:14:41 <fryguybob> Rajjder: Can you see how the source for [] relates to the definition of hand that you gave?
12:14:43 <tolkad> acowley: yeah
12:15:05 <tolkad> acowley: oh I misunderstood it
12:15:11 <Rajjder> Yes fryguybob 
12:15:14 <tolkad> acowley: I saw "Snow Leopard and above"
12:15:15 <zygoloid> Rajjder: your "honest try" code is very close. you've got the right idea: take one card from one of the hands and move it to the other hand, until the first hand is empty.
12:15:19 <tolkad> acowley: and stopped reading
12:15:45 <acowley> tolkad: Yeah I've stumbled while reading that line, too.
12:16:00 <p_l> what's the state of GHC on SPARC64?
12:16:07 <Rajjder> zygoloid, Yes i want to do that recursive
12:16:32 <Rajjder> but I really don't know how to proceed :P
12:16:45 <Rajjder> That's why I'm asking for some support :)
12:16:55 <fryguybob> Rajjder: So the ":" in the source for [] isn't particularly special.  The places that you have : in your try need to be "Some".
12:17:37 <fryguybob> "Some card hand" is similar to "card : hand"
12:18:17 <sproingie> card `Some` hand
12:18:37 <EvanCarroll> ecarroll@x60s:~/code$ /home/ecarroll/.cabal/bin/cabal install Data.List.Split
12:18:37 <EvanCarroll> cabal: "Data.List.Split" is not valid syntax for a package name or package
12:18:37 <EvanCarroll> dependency.
12:18:41 <EvanCarroll> why doesn't that work?
12:18:52 <EvanCarroll> I'm trying to install http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
12:18:59 <EvanCarroll> http://haskell.org/haskellwiki/Cabal-Install
12:19:03 <acowley> EvanCarroll: It's just called split
12:19:11 <gwern> EvanCarroll: module names != package names
12:19:14 <adnap> > read (showFFloat (Just 2) (realPart (1 :+ 0)) "") :+ read (showFFloat (Just 2) (imagPart (1 :+ 0)) "")
12:19:15 <lambdabot>   1.0 :+ 0.0
12:19:23 <EvanCarroll> how do I find what the module name is?
12:19:27 <gwern> a package is a collection of modules; the same module name may be provided in multiple packages
12:19:35 <gwern> EvanCarroll: I usually google hackage
12:19:41 <gwern> or use its search engine
12:19:43 <wjt> it's amazing how much nicer haddock pages looks onw
12:19:57 <gwern> wjt: I'm still mixed. I had gotten used to the old style
12:20:07 <Botje> Rajjder: Empty <+ hand = hand
12:20:18 * wjt puts them side-by-side
12:20:29 <Botje> Rajjder: (Some card hand) <+ hand2 = Some card (hand <+ hand2)
12:21:46 <maltem> gwern, same here. I even got very used to the all-so-hated synopses
12:21:51 <wjt> gwern: maybe it's just the font rendering on this machine, but ... i dunno, they look a lot less spartan. and yet the only real changes are in colours and padding
12:23:21 <Botje> Rajjder: do you see how that works now?
12:23:41 <Rajjder> I'm trying to correct my code with your example
12:24:00 <Rajjder> but it returns a bool when a want a hand as result
12:24:11 <Rajjder> I want*
12:24:21 <Botje> with that snippet?
12:24:26 <Rajjder> yes
12:24:55 <maltem> Another little itch: More scrolling with the new layout ^^
12:25:17 <Botje> you haven't written < instead of <+ somewhere, have you?
12:25:28 <Rajjder> No
12:25:56 <Rajjder> Prolly I'm writing something wrong since I'm really new to haskell
12:26:21 <Rajjder> I as understood i should be looking something like: (<+)(Some card hand) h2 | (Some card hand) <+ h2 = Some card (hand <+ h2)
12:29:10 <fryguybob> Rajjder: The " | (Some card hand) <+ h2 " is getting interpreted as a pattern guard.  You want "(Some card hand) <+ h2 = Some card (hand <+ h2)".
12:30:52 <Botje> and "Empty <+ hand = hand"
12:31:48 <Rajjder> Then I get parse error =/
12:34:22 <fryguybob> Rajjder: Can you paste your code and error?
12:34:30 <tolkad> 0_o
12:34:30 <tolkad> http://www.zvon.org/other/haskell/Outputprelude/Integral_c.html
12:34:39 <fryguybob> @where paste
12:34:39 <lambdabot> http://hpaste.org/ http://codepad.org/
12:34:42 <tolkad> click on any of the links on that page under the class
12:34:52 <tolkad> err not any of them
12:34:58 <tolkad> "mod" for example
12:35:03 <tolkad> takes you to http://www.zvon.org/other/haskell/Outputprelude/mod_o.html
12:35:15 <tolkad> I think this site is broken
12:36:39 <Rajjder> fryguybob, http://codepad.org/UcB0hmjD
12:37:16 <deech> Hi all, how would you describe Haskell's (). Is it the same as bottom or undefined?
12:37:18 <fryguybob> Rajjder: Lines 9 and 10 should not begin with (<+)
12:37:25 <Rajjder> ok
12:37:56 <kmc> deech, it's not bottom or undefined
12:38:03 <kmc> () is the only value of type ()
12:38:07 <Rajjder> fryguybob, but how do we call for that operator in other parts of the code then?
12:38:18 <fryguybob> Haskell can handle functions defined by operators written infix on the left hand side of the equals.
12:38:22 <monochrom> () is neither bottom nor undefined. () is a type with just one value.
12:38:31 <kmc> deech, it's a legitimate value, not an exception-triggering thing like "undefined"
12:38:36 <kmc> you can pattern match on it just fine
12:38:41 <monochrom> you can say "singleton pattern" if you like
12:39:20 <copumpkin> simpleton pattern
12:39:25 <tolkad> client updated
12:39:28 <kmc> haha monochrom
12:39:34 <acowley> deech: () is a type inhabited by one value, also named ().
12:39:36 <tolkad> what?
12:39:46 <Rajjder> fryguybob, 
12:39:47 <kmc> deech, it's sometimes called "unit" or "the empty tuple"
12:39:52 <fryguybob> > let a +++ b = a + b in 1 +++ 2
12:39:53 <lambdabot>   3
12:39:56 <fryguybob> > let (+++) a b = a + b in 1 +++ 2
12:39:57 <lambdabot>   3
12:39:59 <Rajjder> It seems to work now, thank you very much for your time.
12:40:19 <fryguybob> Rajjder: \o/
12:40:41 <Rajjder> what? :P
12:41:21 <fryguybob> Rajjder: I'm glad it is working!
12:41:31 <Rajjder> :)'
12:42:07 <deech> So I'm a little confused on how to interpret something like the signature for the guard function :: Bool -> m (). I understand how to use guard, I just don' t get the type sig.
12:42:21 <kmc> ah, well Â«m ()Â» is a totally different type than ()
12:42:30 <kmc> Â«M tÂ» is the type of "actions" in the M monad
12:42:52 <kmc> Â«Maybe TÂ» is the type of "possibly-failed computations returning T"
12:43:02 <kmc> Â«IO TÂ» is the type of "recipes for doing IO which yield a result of type T"
12:43:03 <kmc> etc
12:43:05 <tolkad> deech: () is Â«data () = ()Â»
12:43:07 <deech> kmc: right, in the case of the list monad for example, guard something has sig :: [()]
12:43:21 <kmc> deech, yes
12:43:25 <kmc> > guard True :: [()]
12:43:26 <lambdabot>   [()]
12:43:29 <kmc> > guard False :: [()]
12:43:30 <lambdabot>   []
12:43:55 <kmc> deech, if you view list monad as nondeterminism, "guard True" continues this path with no branching, and "guard False" terminates it
12:44:08 <micahjohnston> :t concat
12:44:09 <lambdabot> forall a. [[a]] -> [a]
12:44:12 <deech> Ah I see now. I just always thought of () as the equivalent of null.
12:44:14 <kmc> you can't tell directly from the type, but "guard" will return a 0- or 1-element list
12:44:46 <acowley> deech: it is rather like void when used that way
12:44:50 <sepp2k> how ma
12:44:52 <acowley> deech: but that's very different from undefined
12:45:14 <deech> acowley : yes I see that now!
12:45:17 <kmc> you can sort of tell, from the fact that "guard" works on all MonadPlus, and so it can use stuff like "return" and "mzero", but not list-specific stuff like (:) or (++)
12:45:21 <sepp2k> Sorry about that...
12:45:31 <peldan> I would like to somehow define 64 values (e.g "a1", "a2", all the squares of a chess board). is there a smart way of doing this instead of writing out each one explicitly?
12:45:33 <kmc> i've said it before, but finding correspondences from Haskell to other languages is a fool's errand
12:45:43 <deech> kmc 
12:45:46 <kmc> peldan, what types are your values?
12:46:05 <deech> kmc : yes, but for bootstrapping a concept it can be helpful. In this case I was led astray
12:46:11 <maltem> peldan, an array, or map, or list?
12:46:14 <peldan> kmc: I have created my own datatype: ChessSquare, that takes a String eg "e4"
12:46:25 <acowley> kmc: that's far too sweeping a statement
12:46:28 <Twey> Ick
12:46:44 <kmc> i'm not saying any of us can learn without any analogies, but i think it's best to avoid when possible
12:46:56 <fryguybob> @where burrito
12:46:57 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
12:47:08 <maltem> peldan, or do you mean, you have something like data ChessSquare = A1 | … ?
12:47:26 <acowley> kmc: the connections between languages are very important. Connections between Haskell and mathematics are often a bit fuzzy, but of great use!
12:47:30 <peldan> malItem no I mean I don't feel like writing a1 = ChessSquare "a1" etc etc
12:47:40 <peldan> I want it to be done automatically for all 64 squares
12:47:48 <maltem> why then just write ChessSquare "a1" :p
12:48:01 <EvanCarroll> how do you write splitOn such that it reads Int,String
12:48:07 <kmc> acowley, i think most apparent similarities between Haskell and other languages are misleading when you are first learning
12:48:09 <peldan> malItem but it would be cooler to just be able to write a1. it is much shorter!
12:48:15 <kmc> once you know Haskell well, it is of course interesting to study how it compares
12:48:38 <maltem> peldan, I suppose you could to that with TH, but it wouldn't be worth the hassle to learn TH
12:48:42 <kmc> peldan, you could use Template Haskell to generate those 64 names
12:48:50 <acowley> kmc: I agree that it has to be done with care, but I think it can come off as dismissive and a bit unhelpful if you are too strict with the, "You don't know this" message.
12:48:53 <kmc> or write a tiny Haskell / Perl / Python / shell / COBOL script to output the Haskell code
12:49:08 <EvanCarroll> let keyValues = Prelude.map (splitOn ":") $ lines file
12:49:18 <EvanCarroll> I want keyValues to be (Int,String)
12:49:19 <maltem> kmc, why not a Haskell script!
12:49:30 <kmc> acowley, fair enough.  perhaps it's different if you explain the concept first ;)
12:49:33 <peldan> kmc: hmm Im struggling at the moment to just learn haskell. maybe it would be easier to just write out the 64 lines needed then
12:49:49 <Twey> peldan: I suggest writing â€˜data ChessSquare = ChessSquare Column Rowâ€™ instead
12:50:08 <acowley> peldan: Do you really want to identify each square by its own name?
12:50:11 <Twey> peldan: You can make an IsString instance to override string syntax so you can write e.g. "a4" and get a ChessSquare
12:50:15 <EvanCarroll> oh gah splitOn returns a listnot a tuple
12:50:24 <kmc> or just change the ChessSquare constructor to a single letter
12:50:29 <Twey> peldan: But please don't export it from your library by default ;)
12:50:37 <peldan> Twey: thanks, but what difference would it make if I still could convert between String and Row/column?
12:50:43 <peldan> acowley: yes
12:51:00 <benmachine> peldan: why are you giving every square a name?
12:51:10 <Twey> peldan: You wouldn't have to convert (in your static code): with overridden strings, "a4" can be directly of type ChessSquare
12:51:19 <peldan> benmachine: because I think it would be elegant :) at least chess-wise
12:51:33 <kmc> Twey, you mean you don't like modules with one type named T and one class named C ?
12:51:42 <Twey> >.> Heh.
12:51:44 <peldan> Twey: that sounds cool. Thats probably what I want.
12:51:54 <benmachine> peldan: but how often do you need to talk about some square? normally you're only interested in which squares are near to which others
12:52:10 <Twey> peldan: It's a bit of a hack, but I see nothing wrong with using it for convenience so long as you don't export it (or, if you do, put it in a separate module).
12:52:50 <peldan> benmachine: yes, maybe you are right. I just thought it would be cool to be able to write eg "diagonal a1 h8" and it would give me an array of squares
12:53:43 <benmachine> peldan: it would be almost as cool and much easier if you had diagonal (A, 1) (H, 8) for example
12:53:51 <benmachine> or diagonal "a1" "h8" if you like
12:54:05 <benmachine> or diagonal (Position 1 1) (Position 8 8) is how I'd do it :P
12:54:37 <mornfall> Hey, I haven't written a monad tutorial. Do I get a burrito? :D
12:54:53 * BCoppens gives mornfall a delicious burrito
12:55:02 <mornfall> Hey Bart!
12:55:05 <acowley> eating a burrito is rather like join
12:55:07 <BCoppens> Hey mornfall!
12:55:24 <peldan> benmachine: the problem I see with that is that I would have to have lots of similar functions, because squares can be denoted by either rows/columns or strings or by something else. If i use a separate datatype (ChessSquare) then I will only need funktions that work with that
12:55:54 <adnap> Is there a function already for something like zipWith (zipWith (*))?
12:55:57 <benmachine> peldan: if squares can be denoted by lots of things, you will need to convert between those things in any case
12:55:59 <mornfall> BCoppens: I had this idea that I should ask at uni, maybe they have some money they'd love to use to send me to BelHac... (well, not very likely, but who knows)?
12:56:06 <benmachine> :t zipWith (zipWith (*))
12:56:07 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
12:56:13 <BCoppens> mornfall: :D that would be superawesome :)
12:56:14 <mornfall> BCoppens: (But I need to get out of Italy first.)
12:56:19 <BCoppens> mornfall: Italy is fine too :p
12:56:28 <BCoppens> mornfall: north or south in italy?
12:56:31 <mornfall> Tuscany.
12:56:37 <mornfall> Pisa, to be exact.
12:56:41 <mornfall> So far so good.
12:56:43 <adnap> > zipWith (zipWith (*)) [[1,2],[3,4]] [[5,6],[7,8]]
12:56:44 <lambdabot>   [[5,12],[21,32]]
12:56:45 <BCoppens> ah :)
12:56:55 <mornfall> That reminds me...
12:57:05 <notabel> if I have a function of type (Integral a, Integral b, Bounded b) => a -> b how can I test minBound::b (ie, the bound of the return type)
12:57:09 <tromp> peldan: see the two approaches for Go squares on my page http::/www.cwi.nl/~tromp/go.html
12:57:22 <peldan> tromp: thanks
12:57:25 <benmachine> notabel: asTypeOf comes in handy here
12:57:50 <copumpkin> notabel: or ScopedTypeVariables
12:57:56 <BCoppens> mornfall: and people are finally starting to register for BelHac too, these days, which makes me happy in any case :P
12:57:58 <mornfall> I always use ScopedTypeVariables, actually.
12:58:04 <aristid> > (*) <$> ZipList [[1,2],[3,4]] <*> [[5,6],[7,8]]
12:58:05 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList [t]'
12:58:05 <lambdabot>         agai...
12:58:14 <aristid> > (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
12:58:15 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList [t]))
12:58:15 <lambdabot>    arisin...
12:58:18 <benmachine> notabel: you can do something like myfunc arg = r where r = div (maxBound `asTypeOf` r) 2
12:58:30 <benmachine> (okay it's actually unnecessary there, but you get the idea
12:58:32 <benmachine> )
12:58:44 <mornfall> BCoppens: I'll be in Twente later this month, but you probably know that already. (And I don't expect you are going to PDMC/HiBi...)
12:58:51 <benmachine> aristid: you have to getZipList for some reason
12:58:53 <mornfall> Even if it's close. :)
12:59:01 <aristid> benmachine: i always forget that :)
12:59:05 <BCoppens> mornfall: ah, yes I knew, but no I doubt I'll be there ;)
12:59:09 <aristid> > getZipList $ (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
12:59:10 <tromp> you can easily add a Read instance for your chess squares
12:59:10 <lambdabot>   No instance for (GHC.Num.Num [t])
12:59:11 <lambdabot>    arising from a use of `e_112345678' at...
12:59:14 <BCoppens> mornfall: but if you happen to pass through Belgium... :)
12:59:16 <mornfall> BCoppens: But maybe you could prod *your* institution to send you to learn something about systems biology. ;)
12:59:21 <BCoppens> haha :p
12:59:22 <aristid> :t (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
12:59:23 <lambdabot> forall t. (Num [t], Num t) => ZipList [t]
12:59:32 <benmachine> aristid: it's really annoying that there's not just a Show isntance for ZipLists, but there you go
12:59:46 <aristid> oh, there's a deeper problem with that.
12:59:49 <adnap> Ah
13:00:11 <adnap> ZipList is just so that [[a]] can be a monad?
13:00:31 <benmachine> ZipList makes [a] an Applicative
13:00:33 <kmc> [a] is already a monad, and an applicative
13:00:38 <benmachine> in a different way
13:00:54 <kmc> > (,) <$> [1,2] <*> [10,20]
13:00:55 <lambdabot>   [(1,10),(1,20),(2,10),(2,20)]
13:00:59 <kmc> > (,) <$> ZipList [1,2] <*> ZipList [10,20]
13:01:00 <lambdabot>   No instance for (GHC.Show.Show
13:01:01 <lambdabot>                     (Control.Applicative.Zip...
13:01:04 <aristid> kmc: :P
13:01:21 <kmc> > getZipList ((,) <$> ZipList [1,2] <*> ZipList [10,20])
13:01:22 <lambdabot>   [(1,10),(2,20)]
13:02:02 <acowley> getZipList $ zipWith (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
13:02:08 <acowley> maybe
13:02:16 <acowley> not so pretty though
13:02:41 <adnap> :t getZipList
13:02:42 <lambdabot> forall a. ZipList a -> [a]
13:02:52 <acowley> > getZipList $ zipWith (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
13:02:53 <lambdabot>   [[5,12],[21,32]]
13:03:35 <adnap> getZipList $ (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
13:03:38 <adnap> > getZipList $ (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
13:03:39 <lambdabot>   No instance for (GHC.Num.Num [t])
13:03:40 <lambdabot>    arising from a use of `e_112345678' at...
13:06:30 <byorgey> adnap: that code is trying to multiply lists
13:06:34 <byorgey> like [1,2] * [5,6]
13:06:50 <byorgey> > getZipList $ (*) <$> ZipList [1,2,3,4] <*> ZipList [5,6,7,8]
13:06:51 <lambdabot>   [5,12,21,32]
13:07:05 <patrickthomson> :t join
13:07:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:08:02 <adnap> byorgey: Right, I saw that.  I just didn't feel like fixing it since acowley already wrote the correct thing.
13:08:23 <adnap> > getZipList $ zipWith (*) <$> ZipList [[1,2],[3,4]] <*> ZipList [[5,6],[7,8]]
13:08:24 <lambdabot>   [[5,12],[21,32]]
13:08:25 <adnap> :)
13:08:31 <byorgey> ah, good =)
13:10:49 <fryguybob> byorgey: I see you survived class.
13:11:05 <byorgey> I did, thanks =)
13:11:17 <acowley> fryguybob: the class survived, too
13:11:21 <fryguybob> :D
13:11:32 <byorgey> it went pretty well, although I tried to squeeze too much into the first lecture, but I guess everyone does that
13:12:27 <gwern> did they really understand it?
13:12:34 <gwern> or do they just think they do?
13:14:01 <byorgey> gwern: I don't know.  We'll see when the first homework submissions start coming in.
13:14:09 <gwern> that's the spirit
13:14:51 <byorgey> gwern: but honestly they'll have to wait until next week to get their minds blown, today was all this is Int, this is Char, here's how you define a function on integers, etc.
13:15:01 <byorgey> next week we do polymorphism and higher-order functions.
13:15:18 <Botje> you should bring a roll of duct tape, just in case
13:15:18 <gwern> from my cs classes, I remember a significant fraction had difficulty even with the basics
13:15:43 <monochrom> haha
13:17:03 <EvanCarroll> How do I create a Map from a list of strings?
13:17:10 <mauke> :t M.fromList
13:17:11 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
13:17:21 <EvanCarroll> I want to do Map.fromList but they're not Ord,a
13:17:23 <monochrom> duct tape has the bonus rÃ´le of being an icon for duct typing.
13:17:36 <mauke> what are they and what map do you want?
13:18:00 <EvanCarroll> map (\x -> read x :: (Int,String)) splitEvery 2 $ ["1","foo","2","bar"]
13:18:01 <monochrom> strings are Ord.
13:18:16 <monochrom> (Int,String) is still Ord
13:18:19 <gwern> if you don't want Ord, you can hardly use a tree-based structure like Data.Map
13:18:26 <gwern> have to go use the hash tables or something
13:18:53 <EvanCarroll> keyValues = Prelude.map (splitOn ":") $ lines file
13:18:53 <EvanCarroll> chunksByTheHundred = splitEvery 100 keyValues
13:18:56 <EvanCarroll> that's the code.
13:19:06 <EvanCarroll> I want to create a map from chunksByTheHundred
13:19:37 <mauke> that's a weird data format
13:19:53 <mauke> can you have an arbitrary number of pieces per line?
13:20:20 <EvanCarroll> No, each line is k:v
13:20:28 <EvanCarroll> i want to do something like this: Prelude.map Data.Map.fromList chunksByTheHundred
13:20:44 <EvanCarroll> but thyen I get, Couldn't match expected type `[String]' against inferred type `Int -> [e] -> [[e]]'
13:20:51 <mauke> keyValues = map (fmap (drop 1) . break (':' ==)) . lines $ file
13:20:59 <mauke> I don't know how splitEvery works
13:21:19 <EvanCarroll> erg that's thew rong one
13:21:21 <EvanCarroll> Couldn't match expected type `(k, a)' against inferred type `[[Char]]
13:21:24 <EvanCarroll> thats the error i get
13:21:42 <EvanCarroll> so I need to get my list of strings, into tuples for Data.Map.fromList
13:21:44 <mauke> but my keyValues is fromListable
13:21:49 <EvanCarroll> and those tuples should be (Int,Char)
13:22:00 * monochrom compares online programming help with online relationship counselling
13:22:05 <byorgey> EvanCarroll: yes, fromList expects a list of (key,value) pairs.
13:22:21 <EvanCarroll> so how do i get a list of strings into a list of Int,Strings
13:22:22 <byorgey> EvanCarroll: what is the splitEvery 100 for?
13:22:34 <EvanCarroll> readVoodoo ... take 2 $ StringLigst
13:22:44 <EvanCarroll> byorgey: that's just what the questioner wanted.
13:22:48 <EvanCarroll> I'm trying a SO question
13:23:03 <byorgey> well, convert [k,v] = (read k, v)
13:23:08 <mauke> EvanCarroll: don't have a list of list of strings in the first place
13:23:14 <monochrom> SO = significant other?
13:23:18 <byorgey> will get you from a list of two Strings to an (Int, String) pair
13:23:30 * monochrom combines online programming help with online relationship counselling
13:23:47 <Martty> significant overflow
13:24:10 <Martty> is there a haskell tutorial for c++ programmers?
13:24:10 <Funktorsalat> special orthogonal
13:24:13 <EvanCarroll> byorgey: convert is a function?
13:24:24 <Martty> accelerated haskell
13:24:43 <monochrom> I heard there is a haskell tutorial for c programmers
13:24:53 <Martty> yea ive read it but its like 4 pages 
13:24:57 <Martty> just a short intro
13:24:59 <Nibble> Martty: nah
13:25:31 <monochrom> perhaps no one fully understands c++ and therefore a haskell tutorial for c++ programmers cannot be written
13:26:03 <Martty> i was gonna say maybe none of the few select individuals on earth that understand both languages fully cba to writting one
13:26:07 <EvanCarroll> anyone have a function that takes [String] -> [(Int,String)], assuming that is natively what [Stirng] is anyway
13:26:45 <gwern> EvanCarroll: map (\x -> (read x :: Int, x)) ?
13:27:34 <notabel> thanks, i always forget that for ScopedTypeVariables you have to use explicit foralls
13:29:34 <EvanCarroll> gwern: kind of, except positional
13:29:43 <gwern> ?
13:29:49 <EvanCarroll> ["1","foo","2","bar"]
13:30:22 <gwern> oh. foo x = zipWith show [1..] x, or something like that
13:31:07 <gwern> :t zipWith
13:31:08 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:31:16 <kmc> i'm not sure there are enough non-misleading correspondences between C++ and Haskell to warrant a special tutorial
13:31:18 <benmachine> :t concatMap reads
13:31:19 <lambdabot> forall a. (Read a) => [String] -> [(a, String)]
13:31:19 <benmachine> <_<
13:31:34 <gwern> > zipWith (\x y -> (show x, y)) [1..] ["foo", "bar", "quux"]
13:31:35 <lambdabot>   [("1","foo"),("2","bar"),("3","quux")]
13:31:40 <EvanCarroll> gwern: the list is already like that though. it is one list
13:31:49 <gwern> obvious solution. I think there's a golfed version that used monads
13:32:16 <EvanCarroll> let keyValues = Prelude.map (splitOn ":") $ lines file chunksByTheHundred = splitEvery 100 keyValues
13:32:21 <EvanCarroll> that's the codde.
13:32:32 <benmachine> :t zipWith ((,) . show)
13:32:33 <lambdabot> forall b a. (Show a) => [a] -> [b] -> [(String, b)]
13:32:39 <EvanCarroll> chinksByTheHundred is is a list 200 elements ["k","v","k","v"] etc.
13:33:07 <EvanCarroll> that still requires two seperate lists right?
13:33:11 <EvanCarroll> [a] [b]
13:33:23 <EvanCarroll> I have one, [a] :: [String]
13:33:51 <kmc> is there a fast associative container with Data.Text keys?
13:34:09 <copumpkin> I want one!
13:34:10 <kmc> i'm thinking something like bytestring-trie
13:34:22 <xplat> gwern: if you ever need to keep a queue of variable-sized items in a file, use one file to add things to and another reversed file to take things off of, you get amortized O(1).  either that or assume failure is rare and scan your recent work when you start after failure and bunch atomic queue updates at checkpoints
13:35:05 <xplat> argh, quit while i was typing :(
13:38:45 <EvanCarroll> This is what I want something liek this anyway
13:38:47 <EvanCarroll> let f :: [String] -> [(Int,String)]; f x:y:xs = (((read x :: Int),y),(f xs))
13:38:49 <EvanCarroll> except it doesn't work
13:38:51 <EvanCarroll> any idea?
13:39:01 <benmachine> why doesn't it work?
13:39:06 <benmachine> oh
13:39:09 <benmachine> because doin it rong
13:39:15 <benmachine> if you'll excuse a phrase :P
13:39:16 <EvanCarroll> ... right.
13:39:24 <benmachine> it's *almost* right
13:39:28 <benmachine> just a few syntactic issues
13:39:45 <benmachine> firstly, f x:y:xs parses as (f x):y:xs which doesn't make sense
13:39:50 <benmachine> you want f (x:y:xs)
13:40:05 <kmc> fuck it, i'll use a hashmap of String
13:40:34 <benmachine> secondly
13:40:56 <benmachine> (read x :: Int, y) is correct (you don't need the parentheses around the right-hand side I think
13:43:04 <EvanCarroll> >  let f :: [String] -> [(Int,String)]; f (x:y:xs) = ((read x :: Int,y) , f xs);
13:43:04 <lambdabot>   not an expression: `let f :: [String] -> [(Int,String)]; f (x:y:xs) = ((rea...
13:43:18 <EvanCarroll>     Couldn't match expected type `[(Int, String)]'
13:43:18 <EvanCarroll>            against inferred type `((Int, String), [(Int, String)])'
13:46:24 <EvanCarroll> ah
13:46:25 <EvanCarroll> got it
13:46:28 <EvanCarroll> : not ,
13:47:26 <EvanCarroll> now how do i do that as a fold
13:48:10 <EvanCarroll> can you fold over two elements rather than one?
13:48:39 <Twey> Not really
13:48:54 <Twey> It's better expressed as a zip, TBH
13:49:23 <yitz> > let f xs = zip (map read xs) (tail xs) in f ["1","2","3"]
13:49:23 <Twey> Hm, or not
13:49:24 <lambdabot>   [(*Exception: Prelude.read: no parse
13:49:48 <yitz> > let f :: [String] -> [(Int, String]; f xs = zip (map read xs) (tail xs) in f ["1","2","3"]
13:49:49 <lambdabot>   <no location info>: parse error on input `]'
13:49:56 <benmachine> oh yeah, I was going to keep on helping you and I got distracted, sorry
13:49:59 <yitz> > let f :: [String] -> [(Int, String)]; f xs = zip (map read xs) (tail xs) in f ["1","2","3"]
13:50:00 <lambdabot>   [(1,"2"),(2,"3")]
13:50:17 <benmachine> it's fine to just do it recursively
13:50:33 <benmachine> imo
13:50:41 <benmachine> you could possibly use a fold, but it would be a bit elaborate
13:50:55 <Twey> > takeWhile (not . null . snd) $ iterate (\(_, rest) -> splitAt 2 rest) [1 .. 10]
13:50:56 <lambdabot>   Couldn't match expected type `([a], [a])'
13:50:56 <lambdabot>         against inferred type `[a...
13:51:00 <devinus> what kind of new stuff is going on with GHC right now ?
13:51:05 <devinus> (new and exciting)
13:51:16 <Twey> > takeWhile (not . null . snd) . iterate (\(_, rest) -> splitAt 2 rest) . splitAt 2 $ [1 .. 10]
13:51:17 <lambdabot>   [([1,2],[3,4,5,6,7,8,9,10]),([3,4],[5,6,7,8,9,10]),([5,6],[7,8,9,10]),([7,8...
13:51:29 <yitz> @pl \ xs -> zip (map read xs) (tail xs)
13:51:29 <lambdabot> ap (zip . map read) tail
13:51:43 <Twey> > map (\[x, y] -> (x, y)) . takeWhile (not . null . snd) . iterate (\(_, rest) -> splitAt 2 rest) . splitAt 2 $ [1 .. 10]
13:51:44 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(a, b)'
13:51:50 <Twey> > map (\([x, y], _) -> (x, y)) . takeWhile (not . null . snd) . iterate (\(_, rest) -> splitAt 2 rest) . splitAt 2 $ [1 .. 10]
13:51:51 <lambdabot>   [(1,2),(3,4),(5,6),(7,8)]
13:52:07 <Twey> > map (\([x, y], _) -> (read x, y)) . takeWhile (not . null . snd) . iterate (\(_, rest) -> splitAt 2 rest) . splitAt 2 $ [1 .. 10]
13:52:08 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
13:52:09 <lambdabot>    arising from the literal `...
13:52:09 <yitz> > let f :: [String] -> [(Int, String)]; f = zip . map read <*> tail in f ["1","2","3"]
13:52:10 <lambdabot>   [(1,"2"),(2,"3")]
13:52:20 <Twey> > map (\([x, y], _) -> (read x, y)) . takeWhile (not . null . snd) . iterate (\(_, rest) -> splitAt 2 rest) . splitAt 2 $ ["1", "2", "3", "4"]
13:52:21 <lambdabot>   [(*Exception: Prelude.read: no parse
13:52:29 <Twey> Ah, type
13:52:32 <xplat> > foldl (either (\zs x -> (x, zs)) (\(x,zs) y -> (x, y):zs)) (Left []) [1..6]
13:52:33 <lambdabot>   Couldn't match expected type `(t, a)'
13:52:33 <lambdabot>         against inferred type `[(t1, ...
13:52:35 <Twey> > map (\([x, y], _) -> (read x :: Int, y)) . takeWhile (not . null . snd) . iterate (\(_, rest) -> splitAt 2 rest) . splitAt 2 $ ["1", "2", "3", "4"]
13:52:36 <lambdabot>   [(1,"2")]
13:53:23 <Twey> Hmm?  Oh
13:53:30 <Twey> Ick
13:54:46 <yitz> devinus: there are so many changes that they are bumping the major version number from 6 to 7
13:54:59 <devinus> oh wow
13:55:05 <devinus> yitz: like what kind of stuff?
13:55:07 <kmc> @pl \r (x,n) -> (r+n, (r,x))
13:55:07 <lambdabot> (`ap` snd) . (. fst) . ap ((.) . flip . ((,) .) . (+)) (,)
13:55:25 <yitz> benmachine, EvanCarroll: this is so clearly a zip that I wouldn't re-invent the zip wheel by using direct recursion
13:55:38 <kmc> devinus, new typechecker, new IO manager, LLVM backend
13:55:47 <devinus> oh nice
13:56:01 <devinus> kmc: wasn't there a lot of concurrency based work going into it as well?
13:56:06 <kmc> all of which works today in HEAD iirc
13:56:08 <devinus> that's what i'm most interested in...
13:56:21 <kmc> devinus, the new IO manager is all about concurrent IO
13:56:31 <benmachine> yitz: except you don't start with two lists, you start with one
13:56:32 <kmc> don't know what else is happening
13:56:46 <benmachine> I guess the trick would be writing a foldr than un-interleaved them or something
13:58:17 <yitz> devinus: http://www.reddit.com/r/haskell/comments/dad6j/unless_theres_a_major_hiccup_itll_be_in_ghc_70/
13:59:21 <yitz> benmachine: right - it's a zip of two different terms that are simply computed from the same parameter. so that's how it would be most clearly written.
13:59:54 <benmachine> yitz: so you would write a function that split the list into two lists and then zipped them?
13:59:57 <benmachine> that sounds sensible
14:00:26 <yitz> > let f :: [String] -> [(Int, String)]; f xs = zip (map read xs) (tail xs) in f ["1","2","3"] -- benmachine: this
14:00:27 <lambdabot>   [(1,"2"),(2,"3")]
14:00:47 <devinus> jeez
14:00:59 <devinus> every new GHC feature has some paper written on it
14:01:07 <benmachine> yitz: but I was under the impression that the list was ["1", "foo", "2", "bar"] etc.
14:01:13 <benmachine> yitz: so just using tail doesn't cut it
14:01:44 <benmachine> you need to do something odd
14:01:47 <yitz> benmachine: dunno. what i wrote matches what EvanCarroll originally specified, perhaps something else was meant
14:02:01 <benmachine> :t foldr (\x (xs, ys) -> (ys, x:xs)) ([], [])
14:02:02 <lambdabot> forall a. [a] -> ([a], [a])
14:02:33 <Twey> > unfoldr (\list -> case splitAt 2 list of ([], []) -> Nothing; ([a, b], rest) -> Just ((read a :: Int, b), rest)) [1 .. 10]
14:02:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
14:02:34 <lambdabot>    arising from the literal `...
14:02:48 <Twey> Hmph
14:03:32 <yitz> benmachine: ah, i see both terms get dropped in the suite
14:04:09 <yitz> benmachine: direct recursion is really confusing. it's the "goto" of haskell. should usually be avoided.
14:04:26 <xplat> > foldr (flip $ either (\zs x -> Right (x, zs)) (\(x,zs) y -> Left $ (y, x):zs)) (Left []) [1..6]
14:04:27 <lambdabot>   Left [(1,2),(3,4),(5,6)]
14:07:24 <Raghs> How do I print a [String, IO Bool]??
14:07:40 <kmc> you can't
14:07:47 <kmc> not directly
14:07:58 <kmc> "IO Bool" represents a "recipe" for how to do some IO and produce a Bool
14:07:58 <yitz> Raghs: that's not something you would usually see in haskell.
14:08:05 <kmc> it's nothing like a Bool
14:08:15 <Raghs> got it.
14:08:17 <kmc> however you can convert [String, IO Bool] to IO [String, Bool]
14:08:26 <xplat> well, it's a little bit like a bool
14:08:28 <kmc> and then sequence that onto "print" with (>>=)
14:08:40 <benmachine> [String, IO Bool] isn't a valid type, to be pedantic
14:08:47 <yitz> Raghs: if you have a [String, IO Bool] you probably made a mistake somewhere
14:08:50 <kmc> yeah, maybe you mean [(String, IO Bool)]
14:09:00 <xplat> similar to the way that the act of making soup is like soup
14:09:03 <Raghs> yep [(String,IO Bool)]
14:09:09 <benmachine> ah, okay
14:09:33 <acowley> xplat: is that a monad tutorial?
14:09:43 <kmc> :t \(x,y) -> fmap (\z -> (x,z)) y
14:09:44 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t, f a) -> f (t, a)
14:09:50 <kmc> :t mapM (\(x,y) -> fmap (\z -> (x,z)) y)
14:09:50 <lambdabot> forall t a (m :: * -> *). (Functor m, Monad m) => [(t, m a)] -> m [(t, a)]
14:09:56 <kmc> Raghs, ^^^^
14:10:00 * BrianHV was just messing around in ghci trying to produce a [String, Bool], thinking his understanding of haskell was deeply wrong
14:10:11 <Twey> Heh
14:10:15 <xplat> acowley: technically, but i wish you wouldn't ruin my fun by calling me out :P
14:10:32 <Twey> Monad tutorial?  Where?!  :Ã¾
14:10:42 <yitz> Raghs: how did you get that thing?
14:10:53 <acowley> hey, I'm the one who supports all analogies!
14:11:13 * kmc wonders if it's safe to use unsafeInterleaveIO to make a lazy infinite list of random numbers from System.Random.MWC
14:11:19 <Raghs> well i have a list of stock symbols and have a predicate. so using list comprehension i tuppled them up
14:11:24 <yitz> acowley: a monad is like a mixed metaphor
14:11:36 <acowley> yitz: that's a keeper
14:11:37 <kmc> @quote explanations
14:11:37 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
14:11:41 <kmc> @quote bad.explanations
14:11:41 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
14:12:27 <acowley> kmc: I think you just need to figure out what can go wrong if an element of the list is evaluated multiple times, for example
14:13:03 <kmc> what do you mean?
14:13:19 <yitz> Raghs: if it were a predicate, you would have [(String, Bool)]. It sounds like you want to do some IO operation on each of the stock symbols
14:13:26 <acowley> kmc: Try to verify that the usual reasones for proscribing unsafePerformIO won't hurt you
14:13:32 <acowley> reasons, too
14:13:32 <kmc> ah, right
14:13:43 <kmc> preflex, seen bos
14:13:43 <preflex>  bos was last seen on #haskell 15 hours, 22 minutes and 32 seconds ago, saying: i.e. it kills you much deader :-)
14:13:45 <Raghs> ytiz -> yes, my predicate gives IO Bool
14:14:07 <kmc> Raghs, then you should make a function of type String -> IO [(String, Bool)]
14:14:08 <bos> kmc: ?
14:14:09 <kmc> and use mapM on that
14:14:23 <kmc> bos, is it safe to use MWC to make an infinite lazy list of random values
14:14:32 <kmc> using unsafeInterleaveIO?
14:14:37 <bos> kmc: i 'spect so.
14:14:47 <kmc> bos, cool :)
14:14:50 <acowley> kmc: that is an interesting form of verification :)
14:14:56 <kmc> thanks :)
14:15:02 <acowley> verify :: IO Bool
14:15:08 <Raghs> can I use filterM using IO Bool
14:15:17 <kmc> :t filterM
14:15:18 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:15:19 <copumpkin> Raghs: sure
14:15:31 <kmc> (a -> IO Bool) -> [a] -> IO [a]
14:15:36 <copumpkin> Raghs: you could have the predicate ask the user wether he wants to keep each element
14:15:42 <yitz> Raghs: so then in some IO-valued function, you would do something like: do { bools <- mapM predOp syms; let pairs = zip syms bools; ... }
14:15:53 <copumpkin> *whether
14:16:15 <Raghs> how can I use forall?
14:16:57 <kmc> Raghs, you never need to write it yourself in vanilla Haskell 98
14:16:59 <kmc> in fact, you can't
14:17:07 <kmc> it's used by various GHC extensions
14:17:14 <kmc> RankNTypes, ExistentialQuantification, and ScopedTypeVariables
14:17:23 <kmc> does something slightly different in each case ;P
14:18:05 <yitz> Raghs: you mean the forall keyword in some extensions of Haskell, or a kind of loop?
14:18:45 <Raghs> ok. going back to my problem, i have a list of strings [String], a predicate of type IO Bool. How can I get the filtered list?
14:19:22 <yitz> Raghs: as kms pointed out - filterM does exactly that
14:20:02 <kmc> filterM :: (a -> IO Bool) -> [a] -> IO [a]
14:20:10 <kmc> mapM :: (a -> IO b) -> [a] -> IO [b]
14:20:10 <Raghs> that works in ghci.
14:20:14 <yitz> Raghs: it will give you something of type IO [String] -- an action which, when executed, gives you the filtered list
14:22:26 <ajnsit> Is there a library in haskell for cooperative multi threading?
14:22:57 <Raghs> ok. it works in ghci. but get a type error when using in main.. 
14:23:21 <kmc> ajnsit, in what way is the concurrency support built into GHC unsuitable?
14:23:28 <kmc> it's preemptive, but there's many ways to synchronize threads
14:24:19 <ajnsit> kmc, well I really only want lightweight support for sleep and wakeup
14:24:44 <ajnsit> kmc, something similar to http://ocsigen.org/lwt/doc/api/Lwt.html
14:25:13 <sproingie> GHC's threads are ridiculously lightweight
14:25:19 <sproingie> it beats erlang
14:26:07 <ajnsit> sproingie, actually the aim is not performance but easy way to switch computation say from one monad to other
14:26:18 <ajnsit> it's the semantics that I want
14:26:19 <sproingie> ajnsit: you could try CHP
14:26:20 <kmc> different monads?
14:26:28 <kmc> GHC concurrency is in IO monad for the most part
14:26:37 <ajnsit> kmc, sorry, monadic values
14:26:55 <kmc> ajnsit, you could use (ContT r IO)
14:27:10 <kmc> continuations can implement coroutines
14:27:24 <sproingie> continuations can implement anything
14:27:33 <sproingie> tho coroutines are a pretty common one
14:27:34 <kmc> ajnsit, you can also do things like send IO actions through a Chan to a single worker that executes them all
14:27:40 <kmc> and said actions can themselves write to that Chan
14:28:08 <sproingie> if you like channels then you'll really like CHP
14:29:52 <ajnsit> kmc, CHP looks great! thanks
14:30:25 <ajnsit> I actually was looking for channel oriented programming
14:30:37 <ajnsit> so from the examples, this looks like a good fit
14:35:09 <micahjohnston> in ghci, when I try to use the llvm haskell bindings, this happens:
14:35:11 <Cale> There's also cml, but the implementation of cml is weird.
14:35:11 <micahjohnston> Loading package llvm-0.8.0.2 ... linking ... <interactive>: 
14:35:11 <micahjohnston> /Users/micah/.cabal/lib/llvm-0.8.0.2/ghc-6.10.4/HSllvm-0.8.0.2.o: unknown symbol `_LLVMDisposeBuilder'
14:35:11 <micahjohnston> ghc: unable to load package `llvm-0.8.0.2'
14:35:44 <kmc> weird how Cale?
14:35:50 <Cale> kmc: Well, look at it :)
14:36:01 <kmc> ajnsit, there's a series of excellent blog posts about CHP from the author
14:37:09 <Cale> http://paste.lisp.org/display/114509 -- it has stuff like this :)
14:38:55 <kmc> oh dear
14:39:03 <Cale> Well: http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/src/Control-Concurrent-CML.html
14:40:07 <Cale> It was clearly written by someone more familiar with ML than Haskell, but I still don't think that's an excuse for how non-simple the implementation is.
14:41:52 <aristid> Cale: excuse for haskell or for the programmer?
14:42:06 <Cale> aristid: The programmer
14:43:09 <aristid> Cale: i think inexperienced programmers are allowed to write non-optimal code :)
14:43:14 <megajosh2> Wow that link is nasty looking
14:44:08 <Cale> There's a paper that goes along with this code, but it doesn't help much to read it.
14:44:42 <Cale> http://www.cs.umd.edu/~avik/projects/cmllch/paper.pdf
14:45:07 <kmc> is Seq Char likely to outperform String in a queue-like usage, where the maximum length is about 5?
14:45:12 <kmc> too lazy to benchmark
14:45:18 <ajnsit> what's with all the passing around of chans in CHP? Isn't such code supposed to be abstracted by monads?
14:46:09 <kmc> ajnsit, the arrangement of process connections is an integral part of specifying your algorithm
14:47:41 <ajnsit> kmc, yes but can't it be readChannel instead of (readChannel chan)?
14:48:02 <Cale> ajnsit: No, because there might be more than one channel you want to read from at any given point in the code.
14:48:46 <ajnsit> Cale, ah okay. I've been thinking of fudget like stream processors! This is clearly better
14:48:54 <ajnsit> no more weird loops
14:49:44 <micahjohnston> don't know what this is, but I like fudget like stream processors :P
14:57:29 <ajnsit> micahjohnston, well fudgets stream processors have only one input and output so you have to use convulated loops to create some streams
14:57:38 <micahjohnston> oh ok
14:57:49 <micahjohnston> I don't know fudgets specifically, just stream processors generally
15:08:52 <kmc> hmm, is an instance considered orphan if it's declared in Main?
15:12:32 <kmc> man, it's tricky how half the Seq API is in Data.Foldable
15:17:52 <monochrom> orthogonal to Main-or-not. instance is orphan iff class is in different module and data type is in different module
15:20:58 <mathijs> does anyone know of a library that can easily persist arbitrary data structures? I have an application that can easily hold all data in memory, but it would be nice if I can persist it for restarts and such.
15:21:26 <benmachine> mathijs: generally speaking, that's impossible
15:21:28 <Cale> mathijs: Storing functions and IO actions is hard.
15:21:46 <Cale> Not theoretically impossible, but impossible at present with GHC.
15:21:49 <benmachine> but substitute "arbitrary" with "nearly all" and you might be on to something
15:21:52 <osfameron> really?
15:21:54 <micahjohnston> could you use template haskell?
15:21:55 <sproingie> persisting the heap is one way to do it :)
15:22:13 <davean>   
15:22:19 <monochrom> run your program inside virtualbox. save.
15:22:23 <Cale> There's all kinds of problems you can get into with other resources which need to be reconnected.
15:22:31 <Cale> Like filehandles and sockets
15:22:35 <sproingie> ah yes persisting the whole machine
15:22:43 <mathijs> ok... let me rephrase that... :)  no functions and IO actions, just pure data, Maps, Lists, Sets and algebraic datatypes
15:22:46 <osfameron> persisting pure functions ought to be easier though, no?
15:23:03 <osfameron> all you need to do is to store references to all closed over data
15:23:12 <monochrom> "saved by virtualbox" :)
15:23:13 <Phyx-> :t (id &&& (+1))
15:23:14 <lambdabot> forall b. (Num b) => b -> (b, b)
15:23:19 <Phyx-> :t (id *** (+1))
15:23:20 <lambdabot> forall b b'. (Num b') => (b, b') -> (b, b')
15:23:38 <mathijs> to make it clearer: all data can be in real normal form, no thunks
15:24:00 <Cale> mathijs: If you don't care so much about performance, there's show and read
15:24:06 <kmc> mathijs, lots of libraries for serialization on Hackage
15:24:16 <Cale> mathijs: There's cereal for binary serialisation
15:24:48 <Cale> http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/Data-Serialize.html -- see instances here, of course you can extend it with your own
15:24:48 <bos> preflex: seen dcoutts
15:24:48 <preflex>  dcoutts was last seen on #ghc 9 hours, 14 minutes and 29 seconds ago, saying: that's ok then
15:25:29 <kmc> GHC can derive Show and Read for you, which is convenient
15:25:31 <mathijs> Cale: performance is not an issue, nor is "updateability". I just want to give my program a "save" option when I exit (which can take as long as it likes), and a load-option on startup (which is allowed to take long as well)
15:25:39 * Cale wonders again who is in charge of the haddock stylesheet
15:25:46 <kmc> mathijs, Show and Read is simplest then; it's how xmonad handles state restart
15:26:05 <kmc> if you need binary serialization, you might could define it in terms of Data, which GHC can also derive
15:26:11 <kmc> looks like "genericserialize" does so
15:26:28 <bos> Cale: you mean the one on haskell.org?
15:26:28 <bos> Cale: i believe that was ross trying to make it look like the new xhtml stuff
15:26:38 <bos> but not really succeeding
15:26:51 <Cale> bos: The one used on hackage
15:27:01 <Cale> bos: http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/Data-Serialize.html
15:27:04 <Cale> (like that)
15:27:22 <bos> oh, the it's-too-wide issue
15:27:24 <mathijs> kmc: that's nice. preferably I don't want to write instances for my custom datatypes
15:27:25 <Cale> I have a couple of recommendations for adjustments to the link colours which would improve readability
15:27:28 <bos> i think that might be mtnviewmarkl
15:27:35 <bos> uh, mtnviewmark
15:27:45 <bos> Cale: markl@glyphic.com
15:27:46 <Cale> The too-wide thing is another thing :)
15:27:51 <Cale> Thanks!
15:28:18 <bos> i'm sure he'd be happy to have an example of the too-wide problem in the wild, too, so he can fix it
15:30:02 <benmachine> what too-wide thing?
15:30:29 <benmachine> make your page narrower >_>
15:30:37 <benmachine> oh the thing where it goes off the right
15:30:49 <mathijs> I hate that, especially in lynx :P
15:32:24 <ajnsit> mathijs, with data.serialize as long as you can derive show and read instances for your datatype, you don't need to write code for to serialise / deserialise
15:33:00 <mathijs> ajnsit: ok. and I believe they are automatically derivable right?
15:33:16 <ajnsit> mathijs, yeah
15:33:33 <mathijs> so how does that compare to genericserialize?
15:34:04 <ajnsit> no idea never used it
15:38:27 <mathijs> how "stable" is the binary format? will I risk that it becomes unusable with later versions of GHC?  (for example did this happen when utf8 got implemented for strings)?
15:38:49 <Zao> mathijs: Strings have always been [Char].
15:38:59 <Zao> mathijs: However, the I/O layer changed to grok locales.
15:39:05 <mathijs> but Char itself changed right?
15:39:07 <Zao> mathijs: No.
15:39:17 <Zao> mathijs: Char is a type representing an Unicode code unit.
15:39:20 <Zao> Err, codepoint.
15:39:34 <Zao> What changed is handle-based IO.
15:39:34 <mathijs> ah, I thought Char was ascii in the old days (just an int < 256)
15:39:44 <mathijs> ah ok
15:39:56 <ddarius> The Report defines Char as being able to hold a Unicode code point.
15:40:29 <Zao> Thankfully not implicitly numeric like in silly languages.
15:40:44 <aavogt> > succ 'a'
15:40:45 <lambdabot>   'b'
15:41:17 <Zao> > '9' - '0' -- fail
15:41:18 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:41:18 <lambdabot>    arising from a use of `GHC....
15:41:25 <Zao> Explicit ord is good.
15:41:33 <mathijs> can someone explain the genericserialize package to me? as usual with most haskell packages it takes me a while to grok. I know it's close to / related to what I want, but without examples I'm always lost :P
15:43:20 <aavogt> when did hackage change haddock css?
15:43:30 <Zao> Week, two ago?
15:44:47 <ddarius> Even Forth programmers would write '2 weeks ago'
15:45:27 <monochrom> haha
15:45:49 <Cale> mathijs: Looking over the haddock, I don't understand some of the choices made by the programmer of that library, but it's fairly simple to use anyway.
15:46:37 <Cale> mathijs: You'd use  buildList . sexpSerialize  for converting things to String
15:47:12 <Cale> mathijs: and   withList sexpDeserialize  for converting back
15:47:45 <mathijs> Cale: well I found it's based arount Data.Typeable and Data.Data, which I marked as "don't use" in my notes, but that was related to stuff that can be done by using existential types, so not sure if it holds true for serialization as well. It just gives me a "kind of a hack" feeling.
15:48:14 <Cale> Why are those marked as "don't use"? :)
15:49:01 <ddarius> Cale: Because most uses are disgusting, hacky, and inefficient.
15:49:03 <Cale> There are reasons for those libraries to exist -- you might want to choose another library for generic programming instead, but the built-in GHC support is rather handy.
15:49:09 <ddarius> And by "most" I mean "all."
15:49:53 <mathijs> Cale: hmm, sounds quite easy. and with -XDeriveDataTypeable that means I don't need to have read/show instances for my datatypes but just automatically derive Data?
15:51:39 <mathijs> Cale: well I wrote that when comparing existential types to other stuff. To me it seemed that typeable and data were more like a hack that was created before there were existential types. So at least in that case I didn't like it, I'm sure there might be other uses for it
15:52:29 <aavogt> useful uses of Data involve Rank2 types, which encode existential types
15:53:21 <aavogt> actually, the definition of the class needs that extension
15:54:30 <mathijs> ok, so maybe I should change "don't use, kind of a hack" to "don't use till 2015, then see if you actually understand why it's useful" :P
15:55:11 <benmachine> I use generics all over my code >_>
15:56:27 <aristid> benmachine: sounds like bad design! :D
15:56:42 <benmachine> aristid: yeah, I'm a bad person
15:56:49 <aristid> baaad
15:56:52 <benmachine> but if I didn't use it I would need a metric fuckton of boilerplate
15:57:00 <benmachine> excuse my language!
15:57:19 <aristid> i'm ok with it
15:57:21 <mathijs> benmachine: maybe outsource that? :D
15:57:38 <benmachine> I'd basically just be reinventing Data anyway >_>
15:57:39 <mathijs> outsourcing boilerplate is cheap these days 
15:58:01 * Saizan prefers TH if he must
15:58:19 <aristid> benmachine: sounds like you don't need Data "all over your code", but only in a few specific places
15:58:35 <benmachine> aristid: well sure, but my code's not huge
15:58:45 <aristid> mathijs: the indian haskell outsourcing army?
15:58:48 <benmachine> so a few specific places is like 2 out of 10 functions or something
15:59:05 <benmachine> basically I'm manipulating a haskell AST
15:59:17 <mathijs> ajnsit: something like that yeah :)
15:59:21 <benmachine> and I use generics for: rename a free variable everywhere in this expression
15:59:27 <benmachine> find all free variables in this expression
15:59:41 <benmachine> remove all parentheses in this expression
15:59:42 <benmachine> etc. etc.
16:00:31 <benmachine> how much of a pain would it be to do those things without generics? I'd have to manually write the recurse-into-everything coce
16:00:34 <benmachine> code
16:00:50 <benmachine> and different functions for each of Decl, Exp, whatever
16:00:58 <kmc> benmachine, what generics lib do you use?
16:01:19 <benmachine> kmc: syb
16:01:25 <kmc> ah
16:01:27 <benmachine> seemed simplest
16:01:29 <kmc> have you looked at Uniplate?
16:01:31 <benmachine> nope
16:01:35 <kmc> it's real simple
16:01:38 <kmc> different set of capabilites
16:01:40 <benmachine> I've heard it's better in some ways
16:01:42 <benmachine> but
16:01:46 <kmc> but it doesn't rely on the clunky powerful machinery of SYB
16:01:52 <benmachine> it's not something I really have a problem with atm
16:02:32 <mathijs> few days ago there was a discussion here about why Set can't be a functor, basically the answer was "because fmap's type doesn't have any constraints". I have been thinking about this....
16:04:23 <mathijs> why does it matter so much? I mean why can't the compiler just "overload/upgrade" fmap to have some constraints in case of Set?
16:05:08 <aristid> mathijs: because that is a different type. there is a package which allows "fmap with constraints" on hackage, tho
16:05:13 <aristid> @hackage rmonad
16:05:14 <lambdabot> http://hackage.haskell.org/package/rmonad
16:05:32 <benmachine> mathijs: it's intrinsic to the idea of Functor that you can have whatever you like in the structure, because you can replace it with anything else
16:05:39 <benmachine> that generality is useful
16:05:42 <Saizan> mathijs: the most tricky problem comes out with complex expressions
16:05:58 <mathijs> then indeed any function that acts on functors will be "contaminated" as well once it gets used with the Set functor instance, but in the end that doesn't matter to all those "in between" functions I think.
16:07:07 <dmwit> mathijs: What is your proposed type for, e.g., fmap const ?
16:07:52 <Saizan> mathijs: e.g. \x -> fmap ($1) (fmap (+) x) :: (Functor f, Num a) => f a -> f a, externally you might think that when you take f = Set you'd only have to add Ord a, but in fact the implementation requires Ord (a -> a)
16:08:23 <mathijs> tricky indeed, but there are other cases where you explicitly need to specify a type, so if indeed strange cases (where a functor has constraints) need you to be more specific, so be it.
16:08:38 <Saizan> mathijs: so it's quite complicated to deal with what you're proposing since Functor doesn't keep track of such things
16:08:53 <dmwit> mathijs: The trick is that you don't know what constraints to write in the type until you know the constraints of the particular Functor instance involved.
16:08:58 <dmwit> mathijs: That seems icky to me.
16:09:14 <mathijs> indeed
16:09:50 <Saizan> you'd have to always know the exact functor when you apply fmap
16:09:52 <dmwit> It's perfectly legitimate to talk about functors on the subcategory of types that are Ord instances.
16:10:01 <dmwit> This would correspond to having another typeclass for Ord-Functors.
16:10:09 <Olathe> Does anyone know where the package that lets cabal on Windows build binaries is?
16:10:12 <dmwit> Which is exactly what you would do for Set anyway...
16:10:56 <Saizan> Olathe: uh? cabal can build binaries on windows by itself
16:11:02 <mathijs> dmwit: well, I think Set being Ord is more like an implementation choice, I think Sets just need Eq.
16:11:17 <dmwit> But coercing those Ord-Functors into plain old Functors seems like a dangerous downcast. =)
16:11:27 <mathijs> but I see your point
16:11:37 <aavogt> dmwit: how do you decide what is up and down?
16:11:40 <dmwit> um
16:11:44 <dmwit> I may have gotten it backwards.
16:11:55 <Olathe> Oh, I'm sorry, I'm confusing it with something else. Never mind.
16:12:01 <dmwit> It has been some time since I've really cared about getting the OO terminology right.
16:12:14 <ddarius> Upcasts are safe, downcasts are not.
16:12:19 <Saizan> when you know more about your types you're going down.
16:15:50 <mathijs> oh, 1 more thing about serializing with cereal vs genericserialize: If I decide to "upgrade" my app, and add an extra field to data, will any of them break when deserializing?
16:16:42 <Cale> mathijs: Yes, in either case I believe it would.
16:17:44 <mathijs> I can see that. there should be a way to give the new field a "default value" but it sounds like that's getting a bit dirty.
16:18:25 <mathijs> probably some migration scripts will do the trick
16:19:00 <Phyx-> !google open types simon peyton jones
16:19:05 <Phyx-> @google open types simon peyton jones
16:19:06 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/
16:19:07 <lambdabot> Title: Simon Peyton-Jones - Microsoft Research
16:20:10 <mathijs> busy guy, about a paper a month
16:20:28 <Phyx-> those things aren't papers
16:20:30 <Phyx-> they're books
16:20:41 <mathijs> damn
16:22:01 <Phyx-> the one i was looking for is http://research.microsoft.com/~simonpj/papers/constraints/jfp-outsidein.pdf
16:22:04 <Phyx-> 73 pages
16:22:07 <Phyx-> I don't call that a "paper"
16:22:53 <revenantphx> jesus christ thats long
16:23:02 <revenantphx> Could be a short book.
16:23:24 <mathijs> but quite readable, at least it doesn't scare me when quickly scrolling through
16:23:35 <revenantphx> It kind of scares me because I don't know the math
16:23:44 <revenantphx> But it doesn't look like it'd be too thick if you did.
16:23:53 <megajosh2> Hey, is there an option I can pass to ghc when I make a program to keep it from leaving over .o and .hi files?
16:23:54 <Saizan> it's logic!
16:24:02 <megajosh2> All I ever do afterwards is delete them
16:24:03 <Phyx-> mathijs: yeah, they tend to write papers about type systems in a tutorial style walkthrough
16:24:07 <revenantphx> Saizan: Sure but i dont know the symbols :P
16:24:10 <Axman6> SPJ's papers are usually very approachable
16:24:17 <ManateeIrcClient> megjosh2: Try cabal
16:24:21 <sm> megajosh2: it takes longer to rebuild if you keep deleting those..
16:24:28 <revenantphx> oh, is that Haskell I see in there?
16:24:41 <mathijs> ah... forget my last comment... when the figures start it gets scary.... I wish I payed more attention during egyptian classes :D
16:25:00 <Phyx-> revenantphx: ofcourse, it's SPJ :P
16:25:02 <Saizan> there's some haskell, since it's a paper about the new ghc typechecker
16:25:09 <revenantphx> I'm not familiar with SPJ :\
16:25:38 <revenantphx> oh, he works on haskell and stuff
16:25:45 <revenantphx> neat-o
16:25:50 * Phyx- is going through a phase of understanding the typesystem 
16:26:05 <syntaxglitch> SPJ is actually an infinite list of papers, if you read all he has so far it'll force the next thunk and he'll have a new one
16:26:15 * sm coughs.. hanging in here this long and not familiar with SPJ ?
16:26:24 <revenantphx> sm: surprising I suppose
16:26:30 <Saizan> most of the symbols are defined there tbh, but they follow a long naming convention
16:26:30 <sm> get thee to yon internets and watch his talks :)
16:26:41 * revenantphx is going through a phase of OpenGL ES, Haskell and discrete mathmatics.
16:26:45 <revenantphx> It's an interesting time.
16:26:56 <revenantphx> Much more so than boring school.
16:26:59 <mathijs> page 26 is especially scary. indeed the symbols are the main problem for me I think. aren't there any wiki/overview/cheatsheats for that?
16:27:00 <Saizan> the only prerequisite is knowing what ----------------------------- means :)
16:27:01 <revenantphx> Let's just hope I don't fail out.
16:27:03 <Phyx-> revenantphx: you must know Simon Marlow
16:27:09 <Phyx-> the two Simons
16:27:13 <revenantphx> Saizan: That's valid brainfuck?
16:27:32 <revenantphx> Saizan: Though if it's at the beginning of the program, it depends on the implementation if it'd crash or not.
16:27:45 <revenantphx> Depending on whether it uses a ring buffer or if it has bounds checking or if it just crashes...
16:28:06 <Saizan> that was just ascii art for "horizontal line"
16:28:11 <Phyx-> mathijs: page 26 isn't that horrid, pretty simple once you get used to it
16:28:12 <revenantphx> Saizan: oh darn.
16:28:22 <Phyx-> mathijs: those symbols tend to have a standard meaning in all type system literature
16:28:37 <revenantphx> Sounds like that stuff'd be interesting to get into some time.
16:28:40 * syntaxglitch is also baffled how someone could be in #haskell and not know SPJ, he's like the benevolent patriarch of the language
16:28:53 <revenantphx> I'm thinking of trying to get a grant on a research project with some mathematician at pitt or cmu.
16:28:56 <revenantphx> That could be pretty cool.
16:29:03 <revenantphx> My CV is slightly lacking though > >..
16:29:33 <Saizan> mathijs: most of the symbols are defined in figure 1
16:29:46 <mathijs> so does SPJ actually work for microsoft?
16:29:47 <aristid> syntaxglitch: he is not in #haskell tho
16:29:49 * Phyx- has no CV
16:29:52 <Phyx-> it's a blank page
16:29:59 <Phyx-> mathijs: microsoft research
16:30:06 <Phyx-> so does SM afaik
16:30:10 <syntaxglitch> yeah, MSR is not really the same as MS
16:30:43 <Phyx-> nope, they make no money, just eat lots of it
16:30:44 <Phyx-> :P
16:30:49 <mathijs> so is microsoft still interested in haskell? I mean they have f# now, and I don't think they have any means to go "more pure"?
16:31:05 <syntaxglitch> mathijs, C# is full of stuff borrowed from Haskell these days :D
16:31:12 <mathijs> Phyx-: or you could say your CV is still a thunk :)
16:31:23 <aristid> mathijs: i guess that's where the distinctness of microsoft and microsoft research starts to kick in
16:31:23 <Phyx-> mathijs: different teams, F# afaik id done by the languagues and compiler division, and the Haskell stuff are from MSR
16:31:34 <revenantphx> imo, microsoft won't get more pure than F#
16:31:36 * syntaxglitch has probably written more code using the list monad in C# than he has in Haskell
16:31:45 <revenantphx> remember, they aren't an educational instituion primarily, but a corporation
16:31:53 <revenantphx> they're stuff needs to be useable in the market, easily.
16:32:00 <revenantphx> and it has to interface with existing .NET
16:32:00 <aristid> syntaxglitch: because in haskell you use other monads? :P
16:32:06 <revenantphx> which is... about 99% mutable objects.
16:32:49 <mathijs> revenantphx: so why still research so much into haskell?
16:33:01 <revenantphx> Because they have cash to burn and it benefits them I suppose?
16:33:15 <revenantphx> I'm just saying while they may use SOME features, they wouldn't make a language for .NET use that is as pure as haskell
16:33:22 <Phyx-> mathijs: because it's interesting and parts of such research apply to languages as a whole
16:33:27 <revenantphx> it's not practical for commercial use.
16:33:34 <revenantphx> Phyx-: there you go.
16:33:54 <kmc> mathijs, Microsoft Research does lots of stuff not directly related to the MS bottom line.  it gets them prestige and clever people and some ideas trickle down
16:34:22 <kmc> mathijs, remember that almost everything MS does loses money.  they make incredible amounts of cash from Windows and Office and otherwise do what they want
16:34:22 <Cale> revenantphx: Well, it is practical for commercial use, but it would take most programmers too long to realise that.
16:34:25 <Phyx-> recently, alot of MSR stuff has been making their way into practicle MS products
16:34:28 <mathijs> so ms corporation doesn't expect MSR to produce something marketable every few years?
16:34:34 <revenantphx> Cale: which means it isn't practical for commercial use ;)
16:34:37 <kmc> i don't think they do mathijs
16:34:49 <Phyx-> mathijs: when doing research, you dont' expect a pay back, atleast not in short term
16:34:51 <revenantphx> Cale: If it's not easy to adopt and has a rapid development cycle and easy learning curve, it wont get adopted by businesses.
16:35:01 <Phyx-> HP also has a massive and i mean MASSIVE research budget
16:35:01 <revenantphx> This is coming from my discussions with my boss at work.
16:35:02 <danharaj_> People don't realize that Microsoft enjoys being a software company that turns ideas into products.
16:35:12 <revenantphx> danharaj_: quite true.
16:35:18 <revenantphx> The evil big brother thing is a bit overblown.
16:35:19 <revenantphx> Honestly.
16:35:30 <kmc> mathijs, likewise Google makes 99% of their revenue from ads.  everything else they do is just for shits, with the vague idea that if more people use the Internet for more things, they can sell more ads
16:35:38 <danharaj_> That's because neckbeards need someone to hate to make up for their insecurity </troll>
16:35:46 <revenantphx> kmc: but hey, we get free phone calls out of it!
16:35:58 <revenantphx> kmc: and free internet... if that ever happens
16:36:04 <aristid> danharaj_: you're stuck in the wrong decade, man.
16:36:16 <Cale> revenantphx: Well, it won't get adopted by *many* businesses. There are businesses using Haskell after all :)
16:36:20 <Phyx-> kmc: exactly, that's why they give everything away for "Free"
16:36:29 <Phyx-> that's why android is free and defaults to google services
16:36:33 <revenantphx> Cale: you could probably list them on your hands and toes
16:36:49 <revenantphx> Phyx-: It's not a bad business model.
16:37:03 <revenantphx> but, let it be known,
16:37:11 <revenantphx> the monopoly lawsuits will hit google eventually.
16:37:20 <revenantphx> For better or worse (more likely the latter imo)
16:37:26 <Phyx-> revenantphx: yes, BUT i wish people would see that it's not really free
16:37:35 <Phyx-> you pay for it, not with money, but mostly privacy
16:37:37 <revenantphx> Phyx-: Most people I know are aware of that.
16:37:39 <Phyx-> you get indexed to hell and back
16:38:17 <revenantphx> mm true.
16:38:23 <syntaxglitch> I hate to say it, but the "privacy is dead, get over it" people are probably right
16:38:32 <revenantphx> syntaxglitch: kind of, yeah.
16:38:35 <mathijs> well the company I work for at least is _open_ to haskell. They don't allow me to use it "from scratch", but if I - in my own time - come up with usefull stuff in haskell (proof-of-concept like), they do allow me te continue it in company time, as long as it's useful for them ofcourse
16:38:40 <Cale> revenantphx: and one has to admit there are significant advantages to adopting Haskell even at this point, even if it's not perfectly clear to outsiders yet, and I'd rather keep it that way ;)
16:38:49 <revenantphx> Cale: true.
16:38:52 <revenantphx> Here's my tidbit on privacy
16:39:06 <Phyx-> syntaxglitch: those people are eric, marc and larry
16:39:09 <revenantphx> More and more, the stuff you want to keep private is everything not related to your real life.
16:39:10 <Phyx-> and i say, they go to hell
16:39:19 <Phyx-> I should be able to decide what I want to make public
16:39:20 <Phyx-> not them
16:39:28 <revenantphx> Phyx-: You can really.
16:39:36 <Phyx-> revenantphx: yes *I* can
16:39:41 <revenantphx> To the "facebook is infringing my privacy" I say, quit facebook.
16:39:45 <Phyx-> but my mom doesn't know her info is being sold at all
16:39:52 <Phyx-> revenantphx: facebook is another beast
16:39:56 <revenantphx> The the people who are ignorant, I say
16:39:58 <Phyx-> they started with the promise of being closed
16:39:59 <revenantphx> go to hell (and learn)
16:40:01 <Phyx-> and changed mid way
16:40:14 <revenantphx> Ignorance is not really an excuse in the world we live in.
16:40:18 <Phyx-> you forget, 95% of the world is ignorant
16:40:20 <revenantphx> Any fact is about 5 seconds away.
16:40:27 <revenantphx> yeah, and I blame them for their ignorance > >
16:40:33 <benmachine> everything is awful
16:40:34 <revenantphx> Except people who are in bad conditions
16:40:36 <syntaxglitch> Cale, other people not using Haskell isn't a problem, it's a business opportunity, right?
16:40:38 <revenantphx> Them I don't.
16:40:40 <benmachine> let's all just lie down and wait for our deaths
16:40:49 <revenantphx> benmachine: i lost my ipod.
16:40:55 <revenantphx> benmachine: I think I'll kil myself.
16:40:59 <ddarius> I think I just had a phone call fail because the cell network was busy...
16:41:00 <benmachine> revenantphx: :(((
16:41:40 <revenantphx> bbs
16:43:03 <bss03> Has anyone else noticed how awesome the ((->) r) Applicative instance is?
16:43:08 <benmachine> yes
16:43:35 <Saizan> awesomest
16:43:49 <ddarius> Wonderful.  The cell network is FUBAR here.
16:44:14 <mathijs> bss03: well I did read the part about it in typeclassopedia and I understood what I read, but other than that, no. Didn't get any brialliant ideas because of it
16:44:35 <aavogt> it's a Monad too.. if you need a bit more power
16:44:50 <benmachine> aavogt: a bit more power? (>>=) is basically just flip ap isn't it?
16:44:52 <benmachine> or something
16:44:53 <darrint> I have a record that needs to be translated into some file writes in two different files. Do I just want to write two functions like writeThing :: Handle -> Thing -> IO () or something more elaborate?
16:45:31 <aavogt> benmachine: maybe
16:46:01 <bss03> I only use it for simple stuff: Like ((||) <$> pred <*> pred)
16:46:15 <bss03> But, I've been reaching for it more and more.
16:46:18 <benmachine> (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b), (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)
16:46:34 <benmachine> ok so it's basically ap but one of the function arguments is flipped
16:46:52 <benmachine> bss03: yeah, I like doing that
16:46:56 <aristid> also it'd be (=<<) and not (>>=)
16:47:02 <benmachine> I've also got a habit of doing things like
16:47:08 <ddarius> :t flip (((<*>) .) . flip)
16:47:09 <lambdabot> forall (f :: * -> *) a b a1. (Applicative f) => a1 -> f (a1 -> a -> b) -> f a -> f b
16:47:12 <benmachine> :t ap (<$) (nullPtr /=)
16:47:13 <lambdabot> Not in scope: `nullPtr'
16:47:18 <aavogt> benmachine: you have to compare symbol prettiness
16:47:18 <benmachine> :t ap (<$) (0 /=)
16:47:19 <lambdabot>     Couldn't match expected type `f b' against inferred type `Bool'
16:47:19 <lambdabot>     In the second argument of `ap', namely `(0 /=)'
16:47:20 <lambdabot>     In the expression: ap (<$) (0 /=)
16:47:27 <aristid> :t (<$)
16:47:28 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:47:30 <benmachine> err
16:47:43 <benmachine> :t ap (<$) (guard (0 /=))
16:47:44 <lambdabot>     Couldn't match expected type `Bool'
16:47:44 <lambdabot>            against inferred type `t -> Bool'
16:47:44 <lambdabot>     In the first argument of `guard', namely `(0 /=)'
16:47:46 <benmachine> fuck it
16:47:55 <benmachine> oh I am profane tonight
16:48:00 <aristid> :t ap (<$)
16:48:01 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a -> f b) -> a -> f a
16:48:08 <benmachine> :t ap (<$) (guard . (0 /=))
16:48:09 <lambdabot> forall a (f :: * -> *). (Functor f, MonadPlus f, Num a) => a -> f a
16:48:12 <benmachine> there we go
16:48:36 <benmachine> turns a particular value into Nothing
16:48:38 <aristid> :t (<$) <*> guard . (0 /=)
16:48:39 <lambdabot> forall a (f :: * -> *). (Functor f, MonadPlus f, Num a) => a -> f a
16:49:17 <aristid> :t \a -> (<$) <*> guard . (a /=)
16:49:18 <lambdabot> forall a (f :: * -> *). (Functor f, MonadPlus f, Eq a) => a -> a -> f a
16:49:19 <benmachine> > map (fmap . const <*> guard . even) [1,2,3,4,5]
16:49:20 <lambdabot>   No instance for (GHC.Show.Show (f a))
16:49:20 <lambdabot>    arising from a use of `M8444254713...
16:49:29 <benmachine> > map (fmap . const <*> guard . even) [1,2,3,4,5] :: [Maybe Integer]
16:49:30 <lambdabot>   [Nothing,Just 2,Nothing,Just 4,Nothing]
16:49:30 <revenantphx> I wonder, if in 10 years, 
16:49:34 <aavogt> unfortunately, pointfree isn't the end in programming
16:49:35 <revenantphx> we'll all think OO was silly
16:49:46 <revenantphx> or something like that.
16:49:49 <aristid> revenantphx: a lot of the people here think it right now.
16:49:55 <revenantphx> Heh.
16:50:00 <benmachine> yeah, I'm one :P
16:50:10 <benmachine> well, I don't know if OO is silly, but I do think it's overrated
16:50:22 <Phyx-> ^--- what he said
16:50:22 <revenantphx> benmachine: could you explain? I don't want to argue, i'm just curious.
16:50:55 <aavogt> first you need to give your definition of OO
16:51:23 <benmachine> revenantphx: I don't know if I'm in a great position to explain, admittedly I never really got "into" any OO language
16:51:23 * hackagebot svm 1.0.0 - A support vector machine written in Haskell  http://hackage.haskell.org/package/svm-1.0.0 (AndrewDougherty)
16:51:34 <revenantphx> benmachine: oh okay.
16:51:45 <benmachine> revenantphx: I just think it makes strange assumptions and everyone decides they're the bee's knees
16:51:56 <revenantphx> benmachine: like what?
16:52:01 <revenantphx> which assumptions specifically
16:52:15 <Phyx-> revenantphx: my problem with OO is that some people tend to over abstract, and introduce so many indirections that it's pointless to me
16:52:21 <benmachine> revenantphx: like, functions are usually tied to a single object?
16:52:28 <revenantphx> benmachine: that I find silly myself.
16:52:35 <revenantphx> One of the many reasons i don't like java.
16:52:36 <benmachine> I mean, that methods make any more sense than any other sort of function
16:52:56 <revenantphx> A function imo should not have to be tied to any given object.
16:53:04 <benmachine> 1.equals(2) is less natural than equals(1, 2) imo
16:53:09 <revenantphx> Saying you can only have methods is like saying you should only have intransitive verbs.
16:53:12 <revenantphx> Literally.
16:53:13 <mathijs> bss03: I don't see the use of ((||) <$> pred <*> pred) . All I can give it as input is True which outputs False, nothing else. so basically it gives the same result as pred itself on Bools
16:53:19 <dolio> I was boning up on my C++ a week or two ago, and skimmed an 'Effective C++' book of some sort...
16:53:23 <revenantphx> C++ is horribly.
16:53:31 <dolio> And some of the advice was essentially, "do functional programming."
16:53:39 <revenantphx> heh
16:53:39 <benmachine> mathijs: I think "pred" was short for "predicate"
16:53:40 <dolio> Like, "make as much stuff const as possible."
16:53:41 <bss03> mathijs: Sorry, I wasn't thinking about the "pred" fuction.
16:53:49 <mathijs> ah :P
16:53:50 <revenantphx> anyhow, I see functions like verbs
16:53:50 <Phyx-> I would take C++ over java any day though
16:53:54 <ddarius> dolio: Yes, that's common advice in all programming languages and has been for many decades.
16:53:55 <revenantphx> Phyx-: true
16:54:03 <bss03> mathijs: I was using "pred" to stand is for two different functions that are both each (r -> Bool).
16:54:12 <aristid> revenantphx: that means you're stuck in the object-oriented mindset! get out of your cave, primitive man!
16:54:23 <revenantphx> revenantphx: I mean when IN the OO paradigm
16:54:29 <ddarius> Admittedly most languages don't have any actual support for "const."
16:54:30 <revenantphx> I don't see them like that in Haskell for instance.
16:54:51 <revenantphx> In terms of OO languages, I like Objective-C the most.
16:55:04 <revenantphx> Mainly because it doesn't try to impose any irritating set of assumptions on you for the most part.
16:55:12 <revenantphx> And if it ever does you can just edit the runtime to your hearts content > >...
16:55:17 <mathijs> bss03: I see now, it's indeed nice
16:55:36 <revenantphx> Python and Ruby are fine too.
16:56:05 <Phyx-> I've always heard that Objective-C is satan's spawn
16:56:14 <benmachine> I heard that about
16:56:17 <dolio> Really?
16:56:22 <benmachine> well, quite a few things, at one time or another
16:56:24 <dolio> I thought it was all sweetness and light.
16:56:31 <benmachine> this channel's favourite is C++ or possibly PHP :P
16:56:37 <Cale> I don't know much Objective C, but it seemed like a better OO extension of C than C++.
16:56:38 <benmachine> well no
16:56:39 <Phyx-> WHAT???
16:56:41 <ddarius> benmachine: Satan is prolific.
16:56:44 <Phyx-> PHP?
16:56:54 <aristid> benmachine: C++ is the avoided subject.
16:56:56 <benmachine> heh
16:57:03 <mathijs> Phyx-: objective-PHP
16:57:05 <benmachine> except it isn't because we all like a good moan
16:57:46 <killown> haskell is a good option for those who want starts with a functional programming language?
16:57:56 <aristid> benmachine: well saying things like "Haskell is better than X" is pretty safe
16:57:56 <monochrom> yes
16:57:59 <Phyx-> yes
16:57:59 <ddarius> There are more than a few people here that like C++.
16:58:05 * Phyx- raises his hand
16:58:12 <aristid> benmachine: but stuff like "C is better than C++" should be avoided.
16:58:22 <benmachine> aristid: really?
16:58:30 <danharaj_> I like C++ because of templates but hate it for everything else.
16:58:32 <benmachine> well, apart from it being straight-up offtopic
16:59:07 <benmachine> I've mostly only read anti-C++ propaganda so I don't consider myself unbiased >_> but I don't have any truck with its general philosophy, if it even has one
16:59:12 <Phyx-> atleast c++ has lambdas
16:59:48 * aristid comes from the C++ corner, but is a bit disillusioned with its future. the next standard will be a ghost of what was promised once.
17:00:10 <benmachine> C++ was obviously not built to last >_>
17:00:12 <benmachine> if you ask me
17:00:50 <aristid> benmachine: of course i do still think that C++ is better than C.
17:00:50 <Cale> killown: It's a particularly good choice in that it strongly encourages you to adopt a functional programming style, rather than continuing to program procedurally (though you can do that if you really need/want to)
17:01:03 <aristid> benmachine: and better than Java.
17:01:10 <benmachine> aristid: I wouldn't say "of course", there are people who think C is better
17:01:17 <Cale> killown: Make sure to let us know if you have any questions while learning the language -- beginners are always welcome here.
17:01:20 <aristid> benmachine: i said _I_ think so.
17:01:30 <killown> Cale, thanks a lot
17:01:50 <benmachine> aristid: yeah, I'm just saying that some people doubt the implication of the ++ :P
17:02:05 <aristid> benmachine: you troll :P
17:02:10 <dolio> "Of course" doesn't always mean "of course".
17:02:15 <benmachine> aristid: :( I'll be good
17:02:21 <aristid> dolio: of course.
17:02:25 * benmachine giggles
17:02:29 <Cale> aristid: Depends on the manner in which you want to use it. I tend to think of any language without first class procedures as a target language for a compiler that I wouldn't normally write code in directly. C seems to make a better target language.
17:02:34 <monochrom> perhaps of course not
17:02:57 <aristid> Cale: well, in that light i agree. but when i have to manually write code..
17:03:05 <dolio> Cale: You're obviously a nutcase, though. :)
17:03:25 <aristid> dolio: as proved by his (.) = fmap
17:03:29 <benmachine> <_<
17:03:30 <monochrom> my supervisor uses c with goto as target language too
17:04:31 <Cale> We've known how to implement first class functions and procedures effectively for 30 or 40 years now. There's no excuse for programming directly in a language without support for them.
17:05:09 <mathijs> is there any library that provides something like MVars or STM between processes (possibly on different machines)? 
17:05:31 <kmc> mathijs, net-concurrent
17:05:38 <aristid> Cale: duh, I hate C and write code in it when I'm paid to. that is a valid excuse IMO.
17:05:38 <mathijs> thanks
17:06:08 <Cale> http://hackage.haskell.org/package/DSTM -- though I've never tried it
17:06:45 <monochrom> better off with message passing than locks and shared variables over different machines
17:07:00 <Cale> aristid: Well, it's not your fault if it's not your choice of language.
17:07:56 <ddarius> I still blame aristid.
17:08:11 <aristid> *hangs head in shame*
17:08:39 <monochrom> I saw numerous MSc theses of "yet another way to share variables over LAN". Do you know why there are numerous? Because all of them suck once you benchmark them, so there is always room for a new way to equally suck.
17:09:01 <mathijs> monochrom: yeah that might be more suitable. but what I need is a way to have different components of a system (separate processes) which can be upgraded / scaled (launch more of the same) separately and "plug in" to their inboxes on some message passing hub. Without explicitly serializing/deserializing messages
17:09:22 <Adamant> Cale: since LISP 1.5, IIRC
17:09:25 <acowley> monochrom: I don't think it's that they all suck in terms of performance
17:09:28 <Phyx-> monochrom: lol
17:09:51 <ddarius> Some of them suck in terms of correctness or usability.
17:09:58 <acowley> Right
17:10:05 <acowley> and most require some kind of fairly onerous setup
17:10:45 <mathijs> monochrom: ofcourse I can use something like activeMQ for it, but I would like something simpler and preferably pure haskell.
17:10:56 <acowley> I think they tend to go for correctness over performance, or performance over usability
17:11:49 <acowley> which is actually a pretty valid set of tradeoffs, and why there is no one-size-fits-all solution
17:12:52 <acowley> I think the ultimate kick in the teeth is that often you want to make different tradeoffs in different parts of the same application, but you end up wedded to one approach and experiencing its sweet spots and its not so sweet spots
17:18:04 <ddarius> Firefox is spazzing out in a very strange way.
17:20:48 <Cale> ddarius: I often had a strange problem with middle click scroll a few versions back where it would get stuck scrolling slowly to the top of the page (with all mouse and keyboard input grabbed) and then once it got to the top it would start over from where it had started, only scrolling twice as fast, and it would repeat this until it hit some limit and finally stopped.
17:24:02 <ddarius> Cale: This is UI and JPG rendering.  The JPG thing was unusual but not too odd, but all the tab titles turning orange with some garbled mislocated text was a little more wierd.
17:25:11 <Cale> heh
17:28:56 <kmc> (Char) Pick :: FreqTable Int -> Chain, runChain n index im of chain n t) -> FreqTable cf <- pickTable a = F.foldable (Train to PickTable = help "Number from (PickTable (Run     = F.foldl' (flip incr x
17:31:06 <Phyx-> Hey, mario turned 25
17:32:16 * ddarius would probably be mildly disturbed by how many people in this channel could not say they are older than Mario.
17:33:23 <dolio> Is Donkey Kong really only 25 years old?
17:40:21 <magicman> It's the game "Super Mario Bros" that's 25 years old.
17:40:29 <magicman> The arcade games are older than that.
17:40:42 <magicman> Still, though. That's quite something.
17:47:42 <revenantphx> Hello #haskell
17:50:11 <Saizan> hi
17:50:12 <megajosh2> hai
17:54:06 <etpace> does anyone know the url to dons type safe shell scripting hackage package?
18:00:37 <revenantphx> apparently not  > >
18:03:12 <kmc> etpace, maybe it's mentioned in http://donsbot.wordpress.com/2010/08/17/practical-haskell/ ?
18:15:29 <megajosh2> Hey, is there any way to use cabal to remove things it installed?
18:16:26 <ManateeLazyCat> megajosh2: ghc-pkg unregister
18:16:40 <megajosh2> Alright
18:16:57 <megajosh2> Looked like I had a lot of redundant installations of packages
18:17:17 <megajosh2> I think parsec's libraries are in like 3 places
18:17:41 <aavogt> that leaves basically all the files there
18:18:01 <ddarius> aavogt: It shouldn't delete anything at all.
18:22:16 <aavogt> ddarius: it might get rid of a file in ~/.ghc/x86_64-linux-6.12.3/package.conf.d
18:22:37 <aavogt> or whatever the equivalent is for global installs
18:23:32 <megajosh2> /usr/lib/ghc-<your ghc version>/package.conf.d
18:34:56 <itrekkie> Hi everyone, is the a channel for simple programming questions? or is this channel appropriate? I'm having a conceptual issue 
18:35:06 <hpc> we love conceptual issues
18:35:40 <Cale> itrekkie: This is a channel specifically about the programming language Haskell, but conceptual things are okay too -- just don't be surprised if we answer the question with a piece of Haskell code ;)
18:35:54 <itrekkie> alright, I'm not sure if I've understood quite correctly, but I want to feed in the output of one function to another, is composition right here? why not func1 func2 arg?
18:36:20 <itrekkie> I'm still very much working my head around pretty basic things, so thanks for bearing with me
18:36:24 <Cale> Function application in Haskell associates to the left
18:36:34 <Cale> So if you write  f x y z  it means ((f x) y) z
18:36:43 <Cale> Rather than f (x (y z))
18:36:50 <itrekkie> specifically, I want to apply head to the result of tail of a list, getting strange messages
18:36:57 <Cale> head (tail xs)
18:37:03 <Cale> or  head . tail $ xs
18:37:27 <Cale> However, rather than using head and tail, you're usually better off pattern matching
18:37:53 <itrekkie> so the parens are because of the left associativity? 
18:38:09 <itrekkie> I had tried simple head tail xs with no luck, for example
18:39:51 <Cale> right
18:39:56 <Cale> because that means (head tail) xs
18:40:13 <Cale> which means to apply the head function to the list 'tail', but tail isn't a list, so it's a type error
18:40:53 <itrekkie> my exact error, thank you for the clarification 
18:42:43 <dmwit> > let f1 xs = head (tail xs); f2 = head . tail; f3 xs = xs !! 1; f4 (_:x:_) = x in sequence [f1, f2, f3, f4] [0..]
18:42:45 <lambdabot>   [1,1,1,1]
18:43:37 <itrekkie> I also just found the !! operator? or function? â€” seems to fit here a lot better
18:43:43 <Cale> yeah
18:44:14 <Cale> itrekkie: You can also just pattern match the list:  f (x:y:xs) = ...
18:44:30 <Cale> and then y is the head of the tail of the matched list
18:44:47 <Cale> This also makes it obvious that the function isn't yet defined for lists of length 0 or 1
18:44:55 <dmwit> Generally speaking, though, (!!) is a code smell.
18:45:09 <itrekkie> just a hair ahead of me I think, but I'll google that up a bit
18:45:12 <Axman6> is there anything in haskell you would describe as an operator, instead of a function?
18:45:26 <aavogt> Axman6: anything infix function
18:45:29 <dmwit> What's the difference?
18:45:37 <aavogt> * that's an
18:45:45 <Axman6> so mod is a function, but `mod` is an operator?
18:46:23 <Cale> I propose we adopt the mathematical definition of operator as being a function from some Cartesian power of a set to itself. (Or, more appropriate to Haskell, the curried form of such a function)
18:47:32 <hpc> Cale: what does that mean in terms of types?
18:47:40 <Cale> (That is, if A is some set, then an n-ary operator on A is a function A^n -> A)
18:47:48 <hpc> ah
18:47:57 <hpc> like join, sorta?
18:48:06 <dmwit> or (+)
18:48:24 <Cale> (+) is a 2-ary operator on Integer, for instance
18:49:36 <hpc> so A -> ... -> A
18:49:40 <dmwit> I propose we take the absurdist definition of operator: any string of punctuation of length 3 or more.
18:49:40 <Cale> hpc: yeah
18:49:46 <hpc> i see
18:50:05 <Axman6> so (!!) isn;t an operator then
18:50:14 <Cale> Axman6: right
18:50:15 <dmwit> (><<><<)
18:50:28 <dmwit> Axman6: Right, it's too short.
18:50:51 <bss03> Is there a way to get lambdabot to tell me the fixity of an operator?
18:50:59 <dmwit> No, but try :i or :info in ghci.
18:51:10 <dmwit> Don't use parens.
18:51:12 <Axman6> that definition of operator seems somewhat odd for haskell to me
18:51:35 <bss03> dmwit: Thanks.  I was trying to use @info in lambdabot. :(
18:52:00 <dmwit> ?info do { x <- foo; y <- bar; liftM2 f x y }
18:52:00 <lambdabot> foo >>= \ x -> bar >>= \ y -> liftM2 f x y
18:52:13 <dmwit> These are not the bots you're looking for. =)
18:52:44 <dmwit> ?undo do { x <- foo; return x } -- for the confused
18:52:44 <lambdabot> foo >>= \ x -> return x
18:53:12 <dmwit> hm
18:53:17 <dmwit> ?undo do { Just x <- foo; return x }
18:53:17 <lambdabot> foo >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
18:53:22 <dmwit> oh right
18:53:33 <siracusa> ManateeLazyCat: I tried the socket/plug approach for the drawing area and it works now, even within a single process.
18:54:29 <bss03> When doing a fixity declaration, I can just stick it right before the type annotation, right?
18:54:46 <bss03> Inside the module like "infixl 7 divCeil" on a line by itself.?
18:55:09 <dmwit> Try it. =)
18:55:13 <bss03> I did.
18:55:20 <bss03> ghc is giving an error.
18:55:29 <lispy> bss03: you need backticks
18:55:38 <lispy> infixl 7 `divCeil`
18:55:58 <bss03> lispy: Thanks.  Perfect.
18:57:53 <ddarius> Cale: That restriction is only because mathematicians have traditionally mostly focussed on single sorted theories, in a multi-sorted theory you'd end up with operator == function.
18:58:34 <ddarius> At any rate, "operator" is at the syntax level, "function" is at the semantic level.
19:01:25 <monochrom> I use multi-fix operators.
19:02:59 <lispy> monochrom: not to be confused with mixfix?
19:02:59 <Adamant> "when I use an operator", monochrom said with a grin, "it implements precisely the fixity I want it to mean, and no other"
19:03:17 <monochrom> haha
19:03:33 <monochrom> it seems multi-fix = mix-fix
19:03:43 <ddarius> See also distfix.
19:04:47 <roconnor> @bot
19:04:47 <lambdabot> :)
19:05:07 * ddarius needs to buy tape.
19:05:25 <monochrom> multi-fix tape fixes many things
19:07:40 <Cale> ddarius: Well, even more commonly than referring to functions A^n -> A, is to use the term for referring to functions A -> A specifically, which is convenient. (esp. "linear operator")
19:08:20 <hpc> perhaps more importantly, operators can have a fixed point
19:08:37 <Cale> Indeed
19:08:55 * hpc wishes he could stay awake for this whole thing, but has class early tomorrow
19:08:57 <ddarius> :t fix fix
19:08:58 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
19:08:58 <lambdabot>     Probable cause: `fix' is applied to too many arguments
19:08:58 <lambdabot>     In the first argument of `fix', namely `fix'
19:09:47 <ddarius> I like that error message because the bottom two lines are mildly confusing and wrong.
19:16:58 * dmwit is quite proud of his latest hack.
19:18:00 <dmwit> It takes graphs produced by KGS, e.g. <http://www.gokgs.com/servlet/graph/dmwit-en_US.png>, and works out a player's most recent ranking.
19:19:20 <tolkad> Does fromIntegral get optimized in GHC? or does it always convert to arbitrary precision integers inbetween?
19:19:53 <tkahn6> best way to convert string representing hexadecimal value to Integer?
19:20:07 <dmwit> tkahn6: readIntAtBase
19:20:11 <tkahn6> nice
19:20:13 <tkahn6> :)
19:20:18 <Cale> Er, readInt, isn't it?
19:20:22 <dmwit> might be
19:20:25 <Cale> :t readInt
19:20:26 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
19:20:36 <tkahn6> k
19:20:41 <dmwit> tolkad: It likely goes via Integer every time.
19:20:56 <dmwit> tolkad: What two types in particular are you converting? There may be another trip you can take.
19:20:59 <Cale> Er, oh, there's readHex
19:21:01 <tolkad> dmwit: even for conversion that isn't even necessary because of word size?
19:21:02 <Cale> just use that :)
19:21:13 <tolkad> dmwit: for example Int32/Int on a 32 bit computer
19:21:24 <dolio> fromIntegral has some rewrite rules.
19:21:24 <dmwit> tolkad: Even then, probably.
19:21:32 <Cale> > readHex "deadbeef"
19:21:33 <lambdabot>   [(3735928559,"")]
19:21:40 <Cale> > readHex "deadbeef---extra stuff"
19:21:41 <lambdabot>   [(3735928559,"---extra stuff")]
19:21:48 <tkahn6> yeah that's what i'm looking for
19:21:49 <tkahn6> haha
19:22:10 <dmwit> tolkad: Note that the spec itself only guarantees 29 bits for Int or something like that...
19:22:15 <tkahn6> nice
19:22:23 <tolkad> dmwit: yeah I know
19:22:24 <monochrom> fromIntegral for library types are likely optimized.
19:23:02 <tolkad> dmwit: the portable way to check that is to use CPP and WORD_SIZE_IN_BITS right? :P
19:23:06 <tolkad> just kidding
19:23:20 <Cale> The portable way is to use maxBound and minBound
19:23:20 <roconnor> > fix bitsize
19:23:21 <lambdabot>   Not in scope: `bitsize'
19:23:24 <roconnor> > fix bitSize
19:23:25 <lambdabot>   64
19:23:35 <dmwit> =)
19:23:53 <tolkad> :t bitSize
19:23:54 <lambdabot> forall a. (Bits a) => a -> Int
19:24:17 <tolkad> :t fix
19:24:18 <lambdabot> forall a. (a -> a) -> a
19:24:36 <tolkad> ?src fix
19:24:36 <lambdabot> fix f = let x = f x in x
19:25:41 <tolkad> ?src bitSize
19:25:41 <lambdabot> Source not found. My brain just exploded
19:26:14 <roconnor> bitSize is a Bits class method
19:26:34 <roconnor> ?src bitSize Int
19:26:34 <lambdabot> Source not found. Maybe you made a typo?
19:26:39 <roconnor> ?src Int bitSize
19:26:40 <lambdabot> Source not found. There are some things that I just don't know.
19:26:43 <roconnor> bah
19:26:56 <tolkad> monochrom: oh that's nice
19:29:21 <ManateeLazyCat> siracusa: Sorry, i'm busy haven't seen your message.
19:29:31 <ManateeLazyCat> siracusa: So what's the issue?
19:30:21 <ManateeLazyCat> siracusa: In principle, single process with socket/plug should work.
19:30:33 <kmc> how should i choose between binary and cereal? seems like the major difference is lazy vs strict bytestrings
19:30:45 <monochrom> yes
19:30:49 <kmc> it's kind of sad that this involves two completely different libraries, rather than one with a generic interface
19:30:52 <ManateeLazyCat> siracusa: When you create Socket, it will create new Window that different with top-level window.
19:31:12 <siracusa> ManateeLazyCat: Yeah, it works. When the application quits there's still an error `Gtk-CRITICAL **: gtk_style_detach: assertion `style->attach_count > 0' failed', not sure wha it means.
19:31:50 <ManateeLazyCat> siracusa: So you add Drawing area in GtkSocket, then embedded mplayer in Drawing ?
19:32:01 <ManateeLazyCat> are
19:32:03 <ManateeLazyCat> a
19:32:39 <ManateeLazyCat> siracusa: I think "gtk_style_detach" not big problem, won't crash your application. :)
19:33:04 <siracusa> ManateeLazyCat: No, I create a socket an put it in the window, then create a plug and put toe drawing area in the plug.
19:33:14 <ManateeLazyCat> siracusa: Is mplayer?
19:33:27 <ManateeLazyCat> siracusa: Oh, i forgot plug.....
19:33:45 <kmc> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
19:33:45 <lambdabot> No results found
19:33:52 <siracusa> ManateeLazyCat: Yes, MPlayer gets the wid of the drawing area then.
19:34:09 <ManateeLazyCat> siracusa: Always work?
19:34:58 <siracusa> ManateeLazyCat: I think so
19:35:05 <ManateeLazyCat> siracusa: Great, 
19:35:55 <kmc> also, i tend to write Binary instances for product types by converting to/from tuples, e.g.
19:35:56 <kmc>   put (Chain n pri h) = Bin.put (n,pri,h)
19:35:56 <kmc>   get = (\(n,pri,h) -> Chain n pri h) <$> Bin.get
19:35:59 <kmc> is this reasonable?
19:36:11 <ManateeLazyCat> siracusa: Can you share your code? I think it's better demo than gtk2hs repository...
19:37:06 <dmwit> kmc: Definitely.
19:37:11 <ManateeLazyCat> siracusa: BTW, MPlayer.hs demo in gtk2hs repo can't works on Windows?
19:37:25 <dmwit> kmc: That's the whole reason for the tuple instances. =)
19:37:51 <siracusa> ManateeLazyCat: It works, but needs some modifications IIRC
19:38:04 <kmc> yay :)
19:38:30 <ManateeLazyCat> siracusa: IMO, if it work, then don't need socket/plug, socket/plug in single process is unnecessary...
19:38:44 <ManateeLazyCat> siracusa: Though socket/plug can work in single process.
19:40:04 <siracusa> ManateeLazyCat: Socket/plug are only necessary on Windows if there are other widgets than the drawing area.
19:40:39 <tkahn6> does there exist a function that will randomly reorder a list?
19:40:57 <siracusa> @hoogle shuffle
19:40:57 <lambdabot> No results found
19:41:11 <ManateeLazyCat> siracusa: So drawingArea just work when it's only child of top-level window? If you need add other widget in top-level window, you need the help of socket/plug?
19:41:30 <siracusa> ManateeLazyCat: Exactly
19:42:40 <ManateeLazyCat> siracusa: Hmm... can you build minimum mplayer demo? I want replace MPlayer.hs with your version, then it can works cross-platform.....
19:43:44 <siracusa> ManateeLazyCat: Maybe I can patch the current MPlayer.hs demo?
19:44:04 <ManateeLazyCat> siracusa: yes.
19:44:26 <dmwit> tkahn6: Oleg did it! Oleg did it!
19:44:39 <dmwit> ?go perfect shuffle oleg
19:44:40 <lambdabot> Maybe you meant: google googleit do
19:44:43 <dmwit> ?google perfect shuffle oleg
19:44:44 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
19:44:51 <tkahn6> yeah i found one
19:44:58 <tkahn6> http://www.refactory.org/s/randomly_shuffle_a_list/view/latest
19:45:00 <ManateeLazyCat> siracusa: Though, MPlayer.hs can work, but best to replace with socket/plug version, then other people don't need explore again when they want add other widget in top-level window.
19:50:18 <siracusa> ManateeLazyCat: Ok, I'll prepare a patch. But now it's time to got to bed ... :-)
19:50:37 <ManateeLazyCat> siracusa: Great, thanks for effort! :)
19:51:14 <ManateeLazyCat> siracusa: Good night! ;)
19:52:56 <ddarius> While it doesn't require two different packages, lazy v. eager is not just an implementation detail.
19:57:18 <kmc> yeah
19:57:54 <Adamant> I wonder if you could do a language with toggleable strict vs. non-strict and not have it be a pile of caca.
19:58:42 <Adamant> I don't mean in the current senses, but baked into the language
19:59:10 <ddarius> Haskell has demonstrated that what you want is a -mixture- of laziness and eagerness.
19:59:59 <Adamant> ddarius: I guess I want something more default eager with optional lazy, to facilitate program reasoning.
20:00:40 <ddarius> Laziness isn't what complicates reasoning (about space), the combination of laziness and eagerness does.
20:01:11 <ddarius> So the fact that your language had "optional laziness" means you would run into all the same problems.
20:01:19 <Adamant> I'm not sure that's actually true in a psychoprogrammable model.
20:01:31 <Adamant> i.e. how people actually think currently
20:02:02 <Adamant> eager seems to be much easier for most programmers to reason about
20:02:35 <Adamant> that may be the effect of prior experience or it may be something deeper
20:02:39 <ddarius> Adamant: Most programmers are familiar with it.  Most of the trouble people get into with Haskell is due to just blindly viewing it as an eager language.
20:03:22 <ddarius> People get in trouble with eager languages too, they just don't associate the problem with eagerness.
20:03:44 <Adamant> that's an interesting POV and might be true.
20:05:01 <ddarius> Adamant: When beginning Schemers have (define (map f xs) (if (null? xs) '() (cons (f (car xs)) (map f (cdr xs))))) stack overflow, people don't say "It's because Scheme is eager."
20:05:15 <monochrom> The hardest question is "when does deallocation happen".
20:05:22 <Adamant> true, ddarius.
20:05:47 <kmc> if my program takes 1/3 as much garbage collection time with +RTS -A800M... is this indicative of a problem? or is this just the way of things?
20:19:30 <kmc> hmm... even if i have no parallelism in my code, -threaded and +RTS -N2 could make garbage collection faster, yes?
20:25:34 <kmc> how is the chunk size of lazy ByteString, Text, etc. chosen
20:33:03 <c_wraith> kmc: for code that reads from a FD, it's a constant in the code.  For other sources, it's based on how it was created
20:33:04 <tommd> kmc: LazyByteString is automatically 32KB - 8 Bytes
20:33:18 <tommd> kmc: as c_wraith said, a constant.
20:33:40 <tommd> kmc: I've talked to don about exposing the "getN" function so you could choose the value, but haven't formally proposed it yet.
20:34:09 <tommd> It would help for anything that works on particularly sized blocks of  strict bytestrings (like encrypting or hashing)
20:34:25 <kdvh> tommd: I thought it was 64k, that is what it said in LYAH, iirc
20:34:28 <itrekkie> Could someone clue me into an idea on how to do something simple? I want to compare all elements of a list for equality. What approaches can I take with no variables?
20:35:25 <tommd> kdvh: defaultChunkSize = 32 * k - chunkOverhead where k = 1024
20:35:31 <tommd> kdvh: That's from the bytestring package source.
20:35:49 <sepp2k> itrekkie: Use all to check that all elements are equal to the first element.
20:36:02 <kdvh> tommd: i see.
20:36:12 <tommd> itrekkie: foldl1 (==)
20:36:21 <tommd> not exactly, but something close
20:36:25 <tommd> folds will do it.
20:36:38 <tommd> Is this a course practice exercise or just learning Haskell?
20:36:46 <kmc> tommd, c_wraith thanks for your info
20:36:55 <kmc> i am reading a file with Text and want to do some processing in parallel
20:37:06 <kmc> seems natural to parMap over the chunks
20:37:25 <tommd> kmc: Certainly, so long as that will get you what you want!
20:37:32 <itrekkie> just trying to learn; my mind is completely not setup for this yet
20:37:52 <sepp2k> tommd: I see no reason to use fold over all.
20:38:16 <tommd> sepp2k: I was giving one vague option until I heard it isn't course work.
20:38:17 <itrekkie> all seems to make sense to me so far, I'll give it a try
20:38:34 <tommd> itrekkie: what sepp2k is saying is basically "all (== val)"
20:38:42 <tommd> :t all
20:38:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:38:52 <itrekkie> and I can get val from head list?
20:39:03 <tommd> itrekkie: Only do that if you KNOW the list isn't empty
20:39:06 <sepp2k> itrekkie: Yes.
20:39:17 <tommd> otherwise pattern match via case or find another solution.
20:39:18 <itrekkie> I'm ignoring input checks for now :)
20:39:21 <tommd> ok
20:39:32 <sepp2k> tommd: If the list is empty the function given to val will not be evaluated.
20:39:45 <tommd> sepp2k: Right, how silly of me.
20:40:00 <sepp2k> > all (== (head [])) []
20:40:00 <tommd> > let x = [] in all (== head x) x
20:40:01 <lambdabot>   True
20:40:01 <lambdabot>   True
20:41:36 <itrekkie> okay, now that works as I expect it to 
20:42:07 <itrekkie> I suppose a better exercise would be to write my own all
20:42:51 <NemesisD> hmm, does ghci not load LANGUAGE pragmas from the source file?
20:43:30 <kmc> it does
20:43:38 <sepp2k> itrekkie: For that you'd fold as tommd suggested.
20:44:05 <sepp2k> Except you should go with foldr, not foldl
20:44:16 <NemesisD> oddest thing, my source has: {-# LANGUAGE OverlappingInstances, GeneralizedNewtypeDeriving #-}, ghci suggests Try -XGeneralizedNewtypeDeriving for GHC's newtype-deriving extension)
20:44:41 <itrekkie> I really like the guard syntax, it makes the cases really clear
20:44:43 <tommd> NemesisD: You're sure it isn't due to another module?
20:45:33 <tommd> itrekkie: Pattern matching (either via 'case' or top-level functions) and guards are great.  When they don't cut it the little-known extension "ViewPatterns" does very well.
20:46:01 <NemesisD> tommd: the 2 lines it points out are in the source file i'm loading because i'm trying to make an instance of Num
20:47:06 <kmc> itrekkie, tommd, i would check out PatternGuards before ViewPatterns
20:47:20 <kmc> they're not quite equivalent, but PatternGuards has a few advantages
20:48:58 <itrekkie> alright a syntax question, when filling in a function body, I'll write name params =, but with guards the '=' isn't allowedâ€”what's different here?
20:50:51 <tommd> itrekkie: Not clear on your question.  There are functions "func arg1 arg2 = expression"   and functions with guards "func a1 a2 | cond1 = expr1   \n  | cond2 = expr2"  so "=" is used in both those cases.
20:51:39 <itrekkie> ah your example makes a little more sense to me
20:51:49 <kmc> in fact neither the \n there nor any of the other space is necessary
20:51:54 <kmc> but it's pretty confusing without
20:51:54 <itrekkie> I was wondering why there wasn't an '=' before the conditional cases
20:53:11 <tommd> itrekkie: Yeah, I realized that now.  That's just the way it is, and makes sense to me that way.  fact x | x > 0 = x * (f (x - 1) | otherwise = 1.  Rather mathematically.
20:53:30 <tommd> Well, that code wasn't right, but so long as you understand the syntax.
20:53:43 <itrekkie> a function can only be assigned a single expression, I think?
20:53:55 <kmc> no, you can write multiple equations for a function
20:54:01 <kmc> f Nothing = 3; f (Just x) = 7
20:54:08 <kmc> this is often the nicest wya to pattern-match
20:54:25 <tommd> f Nothing _ = 3 ; f _ Nothing = 4 ; f (Just a) (Just b) = a + b
20:54:40 <tommd> the _ is a wild card, matches anything.
20:54:48 <tommd> and doesn't bind a name.
20:55:00 <dmwit> f x y = getSum (on mappend Sum x y)
20:55:11 <dmwit> But that's an advanced technique. =)
20:55:15 <tommd> dmwit: We're showing off pattern matching, that line does a bad job ;-)
20:55:21 * dmwit nods
20:55:58 * ddarius thinks he just had a tiny epiphany about CH and type erasure.
20:56:33 <itrekkie> ugh, I'm sticking the guards for the moment :) 
20:57:09 <itrekkie> the learning curve here is definitely higher than I'm used to, but it's going 
20:57:29 <tommd> They're for different things.  Guards allow boolean tests while pattern matching allows you to handle different cases of an ADT in a cleaner manner than huge nestings.
20:58:42 <ddarius> fact n = n * fact (n - 1), if n > 0; fact 0 = 1 -- I believe that is valid Miranda
20:59:29 <ddarius> View patterns arguably obsolete guards.
20:59:49 <ddarius> (Except I don't think 'where' scopes over the parameters.)
21:00:10 <itrekkie> oh by the way, does anyone use hugs on snow leopard?
21:00:20 <kmc> itrekkie, nobody uses hugs anywhere
21:00:23 <kmc> (to first approximation)
21:00:25 <itrekkie> I thought it would be a faster way to work iteratively, but it doesn't seem to be supported 
21:00:33 <itrekkie> ghc is working fine for me, though
21:00:38 <ddarius> Actually, they don't quite.  So nevermind about that.
21:00:56 <kmc> itrekkie, is ghci not interactive enough / not working for you?
21:01:06 <kmc> i don't know how i could have learned haskell without a working read-evaluate-print loop
21:01:11 <ddarius> Hugs starts up faster than GHCi.  That's about the only good thing about Hugs.
21:01:36 <itrekkie> oh, actually using ghci 
21:01:39 <kmc> ddarius, i really like the idea, in principle, of a portable interpreter in C plus a fancy self-hosting compiler
21:01:41 <kmc> like ocaml has
21:01:49 <kmc> but Hugs can't run GHC and hasn't been able to in some time
21:02:14 <kmc> iirc the way you bootstrap ocaml is to feed pre-compiled bytecode into their portable-C bytecode interpreter
21:02:18 <kmc> i guess YHC could do something similar
21:02:20 <itrekkie> as soon as I get something fun, I'll be sure to try the llvm backend too, but I've got nothing to run fast yet 
21:17:17 <co_dh> enn, this is what I get from one of haskell package.
21:17:26 <co_dh> -- FUUUUUUUUUCKKK Why doesn't glGenTextures work!!??
21:17:26 <co_dh> -- Anyway here is me hacking around it...
21:17:26 <co_dh> textureHack :: IORef [GL.GLuint]
21:17:27 <co_dh> textureHack = unsafePerformIO $ newIORef [1..]
21:17:34 <co_dh> http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/0.3/doc/html/src/Graphics-DrawingCombinators.html#Sprite
21:17:42 <co_dh> that's sound not professional enough
21:17:49 <kmc> yeah
21:17:54 <kmc> how will haskell ever catch on in the enterprise
21:18:30 <thoughtpolice> wowzers, GHC 6.12.3 on threadring from the shootout: 18s with a single core. GHC 6.14 (or 7.0) on threadring: 9s with a single core.
21:18:41 <kmc> nice
21:19:03 <kmc> co_dh, see http://www.jwz.org/doc/censorzilla.html
21:19:16 <thoughtpolice> unfortunately using '-N' is useless for me as I have a dual core laptop
21:19:16 <c_wraith> I wonder if the threaded runtime actually slows down that benchmark
21:19:23 <Axman6> thoughtpolice: compiled with or without -threaded?
21:19:30 <kmc> thoughtpolice, last core slowdown that bad?
21:19:33 <thoughtpolice> and 7.0 still has the dreaded last core slowdown
21:19:44 <thoughtpolice> kmc: runtime stays the same with -N2, no better or worse really
21:19:45 <thoughtpolice> Axman6: yes
21:19:50 <thoughtpolice> er, with -threaded
21:19:56 <Axman6> should run a lot faster without -threaded
21:19:58 <kmc> i have a dual core laptop and i've regularly achieved 170-190% on various programs
21:20:03 <kmc> but i guess it's no good with threadring?
21:20:05 <Axman6> (that program is my baby :P)
21:20:07 <c_wraith> that benchmark is not threaded, fundamentally
21:20:24 <Axman6> c_wraith: indeed, which is why i spawn all the threads on the same core
21:20:57 <kmc> anyone have a good guide to space usage profiling in GHC?
21:21:07 <thoughtpolice> kmc: linux?
21:21:11 <kmc> i can follow what's in the manual but it's hard to interpret these graphs
21:21:12 <c_wraith> the RWH chapter is a decent spot to start
21:21:13 <kmc> yeah thoughtpolice
21:21:19 <kmc> i'll re-read what RWH has to say on the subject
21:21:29 <co_dh> kmc: lol. I guess programmers are unhappy
21:22:32 <thoughtpolice> Axman6: GHC HEAD gets 6.7s without -threaded, and 6.12.3 gets a 6.2s
21:22:50 <c_wraith> hmm
21:23:17 <c_wraith> quite a lot faster, but why the slowdown in head?
21:24:30 <thoughtpolice> kmc: strange, I can never pull both my CPUs at once (I can maybe get like 108%) on linux although OS X does fine. apparently changes in recent kernels can also affect performance (I heard bos mention something about sched_yield becoming a nop recently)
21:24:32 <kmc> oh, nice. hp2ps can create color graphs
21:24:41 <kmc> that's much better than ten indistinguishable shades of grey
21:24:51 <kmc> odd
21:25:05 <iFire> thoughtpolice I kinda want to see language shootout on ghc 7
21:25:32 <thoughtpolice> and simon m. is still working on per-cpu GC so I don't think I'll get much parallel benefit out of 6.14 in terms of parallel performance :(
21:25:38 <Axman6> thoughtpolice: that is very odd, the non threaded runtime used to make that program insanely fast, like <2s
21:25:59 <thoughtpolice> although if I link with -threaded it still is apparently a lot faster if spawning threads than previous versions
21:26:56 <thoughtpolice> Axman6: yeah, I think I may email g-h-u or something since it seems strange that HEAD does worse than 6.12 without -threaded
21:27:03 <monochrom> heh, 10 shades of grey
21:27:33 <iFire> which benchmark?
21:27:35 <thoughtpolice> at least the new I/O manager is in, and the cool new type checker
21:27:51 <kmc> what are the user-observable consequences of the new type checker?
21:28:02 <thoughtpolice> http://shootout.alioth.debian.org/u64q/performance.php?test=threadring
21:28:20 <pumpkin> and new inliner too
21:28:28 <pumpkin> new everything!
21:28:29 <ddarius> I think most of the benefit for the new type checker is in maintainability.  It does fix some bugs or omissions from the current type checker.
21:28:46 <kmc> does the new inliner still choke on negative-position type recursion?
21:28:52 <copumpkin> ddarius: and the fact that the blocker for several new type family features is now done
21:28:58 <kmc> ooh ooh which ones copumpkin
21:29:03 <copumpkin> well, I think :P
21:29:07 <copumpkin> the ones that are missing, of course!
21:29:15 <monochrom> perhaps something about type equality?
21:29:18 <ddarius> Down the line, though, the new type checker should allow for more type features faster.
21:29:20 <copumpkin> superclass equality constraints, default associated types
21:29:22 <copumpkin> I'd hope
21:29:29 <kmc> the best day of the year is the day GHC comes out and i read chapter 7 of the manual
21:29:41 <thoughtpolice> OutsideIn is based on the JFP paper also solves the issue of type families with newtypes as well
21:29:41 <monochrom> heh
21:29:49 <iFire> thoughtpolice wait 6s isn't that faster than gcc?
21:29:52 <thoughtpolice> i believe at least
21:30:05 <thoughtpolice> iFire: this is without -threaded, all benchmarks on that list are compiled with -threaded for GHC
21:30:24 <thoughtpolice> I wonder how OutsideIn now handles the code in sorear's many moons old trac bug
21:30:25 <dolio> ddarius: Did you ever say what your epiphany was? Or just that you had one.
21:30:28 * thoughtpolice searches
21:30:33 <monochrom> scary awesome type system
21:31:12 <ddarius> dolio: I just said that I had one.
21:31:54 <ddarius> kmc: One user-visible difference with the new type checker is that I believe they have the let-does-not-generalize aspect so some currently valid Haskell programs could break.
21:31:59 <iFire> thoughtpolice although I don't see how a program with greenthreads can be considered threading :)
21:32:26 <kmc> ddarius, ah, tricky
21:32:38 <kmc> is there already a flag for that in 6.12?
21:33:24 <itrekkie> how do you go about accessing an element in a tuple?
21:33:35 <kmc> pattern matching
21:33:40 <kmc> > case (1,2,3) of (x,_,_) -> x
21:33:41 <lambdabot>   1
21:33:54 <iFire> thoughtpolice actually ignore that >.<
21:33:58 <kmc> for 2-tuples there are also functions "fst" and "snd"
21:33:59 <dmwit> > let f (x, y, z) = y in f (1, 2, 3)
21:33:59 <lambdabot>   2
21:35:02 <monochrom> yeah, sometimes threads are used to make the program more readable, not really interested in parallelism.
21:35:06 <itrekkie> oh fst and snd are exactly what I want :)
21:35:37 <monochrom> the old single-event-loop style is not very modularized
21:35:46 <kmc> yeah, concurrency is useful without parallelism
21:36:11 <kmc> you can write things equivalent to a select() loop without turning your program logic inside out
21:36:16 <ddarius> Indeed.  You can have (usefully) concurrent programs that have strictly sequential execution characteristics.
21:37:18 <kmc> a high-load webserver has a high degree of concurrency (1000+ threads) and a lower degree of parallelism (4-8 threads executing at once)
21:37:18 <monochrom> this is why the populace mob stoned some author to death when the author blogged to say "concurrency /= parallelism"
21:37:24 <Axman6> itrekkie: fst and snd only work on 2-tuples though
21:37:31 <Axman6> just so you kow
21:37:33 <Axman6> know*
21:37:37 <Axman6> > fst (1,2,3)
21:37:38 <lambdabot>   Couldn't match expected type `(a, b)'
21:37:39 <lambdabot>         against inferred type `(t, t1...
21:37:43 <kmc> 64 "at once" if you have UltraSPARC T2 :)
21:37:46 <itrekkie> I've got a 2-tuple :)
21:38:05 <itrekkie> and I just looked up !=, so  totally understood "cncurrency /= parallelism", which was awesome
21:38:22 <ddarius> @google "Squinting at Power Series"
21:38:24 <lambdabot> http://plan9.bell-labs.com/who/rsc/thread/squint.pdf
21:38:24 <lambdabot> Title: cache:http://plan9.bell-labs.com/who/rsc/thread/squint.pdf - Google Search
21:39:25 <itrekkie> alright imagine this, my two 2-tuple is two lists, and I want to add to these lists-- how can I go about this recursively? 
21:39:40 <itrekkie> I'm trying to create a sets of odd and even numbers 
21:39:57 <ManateeLazyCat> @zip
21:39:57 <lambdabot> Maybe you meant: bid id map
21:39:59 <ddarius> @google "Power series, power serious"
21:40:00 <lambdabot> http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
21:40:21 <monochrom> like f (x,y) = .... (e:x, o:y) ...?  
21:41:30 <mtnviewmark> > uncurry (zipWith (+)) ([1, 3, 5], [20, 30, 40])
21:41:30 <lambdabot>   [21,33,45]
21:41:33 <NemesisD> why is it that 1/3, 2 Ints works in ghci but elsewhere it fails to compile?
21:41:34 <mtnviewmark> you mean like that?
21:42:33 <ddarius> NemesisD: I suspect you are stating a falsehood and not your actual situation.
21:42:38 <kmc> NemesisD, 1 and 3 are not Ints
21:42:42 <kmc> they are (Num a) => a
21:42:49 <kmc> when you use them with (/), GHCi will default the type to Double
21:43:07 <kmc> but Haskell has no implicit type conversions, so if something is *actually* Int, you can't use (/) with it
21:43:13 <itrekkie> I want to add the member to the the fst of the tuple, but also return the whole tuple, which I don't seem to be doing: ([head xs] ++ (fst (evenOdds (tail xs))))
21:43:18 <NemesisD> kmc: i can't coerce it?
21:43:25 <kmc> NemesisD, you can call fromIntegral
21:43:28 <ddarius> You can convert explicitly.
21:43:40 <kmc> itrekkie, if you ever write an expression where both Â«head xsÂ» and Â«tail xsÂ» appear, it is a sign that you really should have pattern-matched xs instead
21:43:52 <kmc> case xs of (y:ys) -> [y] ++ (fst (evenOdds ys))
21:44:09 <kmc> of course you can probably push that match to wherever xs was defined, and get rid of the intermediate variable
21:44:15 <kmc> and you should also add a case for [] unless you know it's impossible
21:44:21 <mtnviewmark> itrekkie: where's the 2-tuple?
21:44:22 <dons> fun fun haskell.spreadshirt.com
21:44:47 <ddarius> You've been unusually quiet lately.
21:44:48 <ddarius> dons
21:44:56 <mtnviewmark> dons!
21:45:03 <dons> kinda got a busy job these days :} 
21:45:17 <dons> heya mtnviewmark 
21:45:35 <itrekkie> I think I'm creating it the base case of the guard? http://gist.github.com/578556
21:45:39 <itrekkie> I think I'm way off on this one
21:45:51 <mtnviewmark> see - I'm still in that "new guy at work" mode - and can claim I'm reading up on system docs... 
21:46:00 <mtnviewmark> ...while I'm really haskellin'
21:46:08 <mtnviewmark> (okay, not really, but it is a nice fantasy...)
21:46:19 <Cale> itrekkie: What do you want your function to do?
21:46:37 <ddarius> At any rate, finally killing of n + k patterns was a victory for all.
21:46:40 <dons> Cale: thoughts on other good slogans from #haskell for ICFP this year? 
21:46:41 <ddarius> s/of/off
21:46:59 <itrekkie> split up a list into its even and odd numbered items from the original list
21:47:04 <Cale> dons: Avoid success at all costs
21:47:18 <ddarius> That's not from #haskell though.
21:47:20 <kmc> how about the nubBy prime generator
21:47:24 <Cale> Right, it's not.
21:47:48 <caelan> itrekkie: evenOdds xs = (filter even xs, filter odd xs) where {even x = x `mod` 2 == 0; odd x = not . even}
21:47:51 <Cale> itrekkie: Computing the length of the list is quite excessive
21:47:57 <ddarius> :t even
21:47:58 <lambdabot> forall a. (Integral a) => a -> Bool
21:48:04 <ddarius> caelan: It's already there.
21:48:09 <caelan> figures :)
21:48:12 <mtnviewmark> > let evenOdds xs = zipWith ($) (cycle [fst, snd]) (zip xs (tail xs)) in evenOdds [0..10]
21:48:13 <lambdabot>   [0,2,2,4,4,6,6,8,8,10]
21:48:15 <monochrom> "GHC 7" is already a slogon in its own right. Think "Windows 7".
21:48:22 <mtnviewmark> nope
21:48:23 <dons> ooh yes.
21:48:52 <caelan> :t odd
21:48:52 <monochrom> what were the windows 7 slogans? we may steal some of them...
21:48:53 <lambdabot> forall a. (Integral a) => a -> Bool
21:48:57 <caelan> ooh
21:49:06 <Cale> itrekkie: Okay, so if we consider the head of the list to be the zeroth element, it goes in the even part, yeah?
21:49:07 <kmc> will forcing an IntMap to WHNF resolve all pending inserts?
21:49:23 <itrekkie> you're examples are so dense, scary haskell masters 
21:49:29 <dmwit> itrekkie: Well, there's two directions for advice. One is the incremental one, towards fixing what you have: ask yourself if the return type of (++) matches the return type of evenOdds (for example, check what you're doing in the second guard). The other is the good advice: you should definitely consider pattern-matching here.
21:49:37 <monochrom> "connect threads and check types with GHC 7"?
21:49:38 <ddarius> kmc: I highly suspect it will.
21:49:39 <caelan> itrekkie: evenOdds xs = (filter even xs, filter odd xs)
21:49:45 <Cale> itrekkie: What is the result of evenOdds [1,1,1,1,1] ?
21:49:46 <kmc> my heap seems to be filling up with objects of type "->IntMap" according to -hy
21:49:51 <dons> "GHC 7 was my idea"
21:50:03 <monochrom> heh
21:50:05 <Cale> I have the sense that everyone is misinterpreting what evenOdds is supposed to do.
21:50:14 <dmwit> caelan: partition is better for that, but that isn't what he's doing.
21:50:14 <mtnviewmark> dons: nooooooooooooooooooooooooooo
21:50:18 <dons> hehe
21:50:28 <mtnviewmark> iGHC & iHaskell
21:50:31 <itrekkie> Cale: ([1,1,1] [1,1])
21:50:37 <Cale> itrekkie: right, okay
21:50:38 <kmc> so, the unofficial Win7 motto was "we made vista less shitty", right?
21:50:45 <monochrom> perhaps steal from iPhone 4 too. "GHC 7. This changes everything. Again."
21:50:47 <kmc> maybe we don't want to copy that
21:50:47 <ddarius> If you want a particularly geeky one, you could go with "Let Should Not Be Generalized"
21:50:52 <itrekkie> I'd like to go toward fixing what I have, since I sorta understand the wizardry there
21:51:04 <mtnviewmark> "GHC 7. This recompiles everything. Again."
21:51:05 <Adamant> kmc: they basically put Vista on a diet
21:51:12 <ddarius> monochrom: That has some negative connotations in this case ... though it is very likely accurate.
21:51:23 <monochrom> yes! "recompiles" is better!
21:51:28 <itrekkie> I didn't think that ++ was a function though, what could it's return type be?
21:51:28 <Cale> itrekkie: So we already know that evenOdds [] = ([],[]) -- don't ever use the length function to try to decide if a list is empty, use pattern matching or 'null'
21:51:38 <Cale> (++) :: [a] -> [a] -> [a]
21:51:44 <thoughtpolice> i just need a more-core machine i can run GHC on with all its parallel coolness
21:51:56 <Adamant> kmc: Vista was quite nice in a lot of respects, it was just dog-slow and a resource hog.
21:52:04 <ManateeLazyCat> GHC 7 compatible GHC 6.xxx ?
21:52:05 <dmwit> itrekkie: Okay, in that case: the contract you've written by giving evenOdds that type is that it should return a pair. Are you returning after each guard?
21:52:09 <monochrom> "Avoid ABI stability at all costs."
21:52:11 <dons> GHC 7 ... for all your cores
21:52:23 <itrekkie> Cale: I can have a guard condition with just null? length is expensive? 
21:52:28 <ddarius> At least this time they can say it's a major version change.
21:52:31 <dmwit> s/Are you returning/Are you returning a pair/
21:52:32 <Cale> itrekkie: length xs takes O(length xs) time to compute
21:52:34 <Heffalump> what's the status of the LLVM backend?
21:52:40 <dons> Heffalump: in ghc 7
21:52:42 <ManateeLazyCat> dons: What's most cool features in GHC 7 ? 
21:52:44 <thoughtpolice> incidentally I am going to be gearing up with new hardware soon soon because of starcraft 2, I may as well get a CUDA capable nvidia card and write GPU haskell code too
21:52:45 <Heffalump> on by default?
21:52:47 <Cale> itrekkie: No need for guards here, just pattern match
21:52:52 <caelan> itrekkie: yes. length is o(n), and it doesn't work on infinite lists
21:52:56 <dons> ManateeLazyCat: llvm backend, epoll io manager, new type system impl., new inliner
21:52:59 <Adamant> thoughtpolice: go for OpenCL
21:53:02 <dons> Heffalump: no, only via -fllvm
21:53:05 <monochrom> w00t epoll!
21:53:05 <itrekkie> ooops, no length for me then
21:53:19 <ManateeLazyCat> dons: Just support llvm backend in GHC 7?
21:53:22 <Heffalump> will it work out of the box or require llvm to be installed too?
21:53:29 <thoughtpolice> ManateeLazyCat: new I/O manager (100k + file descriptors), LLVM backend, new inliner, better parallel performance, type checking improvements and general stability
21:53:31 <dons> Heffalump: i think we bundle llvm (?)
21:53:44 <thoughtpolice> Heffalump: I think david's backend actually just emits LLVM .bc files
21:53:45 <Cale> itrekkie: So break it down into two cases: the empty list case, [], and the nonempty list case: (x:xs)
21:53:50 <monochrom> (oooohhhh, don't get me started about bundling...)
21:53:51 <thoughtpolice> and the LLVM toolchain compiles them
21:53:59 <thoughtpolice> e.g. using llvm-as
21:54:01 <itrekkie> so I'm definitely not returning the pair, but I can't figure out how to add to fst of the pair and return it?
21:54:15 <Cale> itrekkie: evenOdds [] = ([], [])
21:54:18 <Heffalump> thoughtpolice: ok, but the question is really about whethe llvm-as etc will be bundled as dons suggests
21:54:19 <dmwit> itrekkie: Pairs are built using (a, b). =)
21:54:39 <ManateeLazyCat> thoughtpolice: When time release GHC 7?
21:54:41 <thoughtpolice> yeah, I'm not sure if it's a build option or it uses something in $PATH. I could check right fast actually
21:54:42 <Cale> and in the nonempty case...
21:54:46 <Cale> evenOdds (x:xs) = ...
21:54:56 <thoughtpolice> er, well, if the build gives GHC the path to a very specific LLVM-as to use
21:54:58 <Cale> We know that x should end up in the first part of the result
21:55:00 <caelan> yeah, i was wondering about the lack of a tuple ctor
21:55:04 <dons> ManateeLazyCat: in a few months
21:55:10 <ManateeLazyCat> dons: Cool.
21:55:13 <Cale> evenOdds (x:xs) = ... (x:..., ...)
21:55:41 <Cale> What should the rest of the first and second part of the result be, though? Let's give them a name, say, us and vs
21:55:44 <copumpkin> what are the odds of a number being even!
21:55:51 <Cale> evenOdds (x:xs) = (x:us, vs)
21:55:52 <dmwit> Cale: Don't you want evenOdds (x:y:xs) = ... or so? Or are you suggesting an oddEvens function, too?
21:55:55 <Cale>   where ...
21:56:36 <Cale> Well, we want us to be the odd-numbered elements of xs
21:56:45 <Cale> and vs to be the even numbered elements of xs
21:57:11 <Cale> Luckily, we already have a function to split a list into its odd and even part, the one we're writing
21:57:29 <Cale> So:  (vs,us) = evenOdds xs
21:58:06 <dmwit> > partition (even . fst) . zip [0..] $ [1, 1, 2, 3, 5, 8, 13, 21, 34] -- ignore me, I'm being annoying
21:58:07 <lambdabot>   ([(0,1),(2,2),(4,5),(6,13),(8,34)],[(1,1),(3,3),(5,8),(7,21)])
21:58:09 <ddarius> "I need to foobar x.  How can I foobar x?  I know!  I'll use the function I'm writing."  foobar x = foobar x
21:58:26 <copumpkin> ddarius: that's how the agsy proof finder works sometimes in agda :P
21:58:27 <dmwit> Oh, that's actually quite clever. Cale++
21:58:28 <Cale> ddarius: IT WORKS!
21:58:42 <copumpkin> I've been quite frustrated by it finding those proofs for me
21:59:08 <itrekkie>  I'm a tad confused, lemme reread the logs 
21:59:33 * mtnviewmark wonders if evenOdds is supposed to be just (partition even) or if it is supposed to split alternating elements...
21:59:45 <dmwit> mtnviewmark: the latter
21:59:56 <caelan> okay, i have a working function
22:00:05 <caelan> not sure how it holds up under the Test of Use
22:00:18 <etpace> @unpl \j (k,v) -> f k v h
22:00:18 <lambdabot> \ j (k, v) -> f k v h
22:00:45 <Cale> itrekkie: http://paste.lisp.org/display/114520
22:00:46 <etpace> @pl \j (k,v) -> f k v h
22:00:46 <lambdabot> const (uncurry (flip flip h . f))
22:00:55 <Cale> itrekkie: There it is all in one place
22:01:31 <Cale> itrekkie: The important thing to note is that the even elements of xs are the odd elements of (x:xs)
22:01:50 <Cale> itrekkie: and x along with the odd elements of xs are the even elements of (x:xs)
22:02:13 <Axman6> > let f [] = ([],[]); f (x:xs) = (x:us,vs) where (vs,us) = f xs in f [1,2,3]
22:02:14 <lambdabot>   ([1,3],[2])
22:02:18 <Axman6> > let f [] = ([],[]); f (x:xs) = (x:us,vs) where (vs,us) = f xs in f [1,2,3,4]
22:02:19 <lambdabot>   ([1,3],[2,4])
22:02:38 <itrekkie> that's quite an insight
22:02:47 <Axman6> > let f [] = ([],[]); f (x:xs) = (x:us,vs) where (vs,us) = f xs in f [1,2,3,4,5]
22:02:48 <lambdabot>   ([1,3,5],[2,4])
22:03:29 <mtnviewmark> > let evenOdds xs = (let exs = zipWith ($) (cycle [Left, Right]) xs in (lefts exs, rights exs)) in evenOdds [0..10]
22:03:30 <lambdabot>   ([0,2,4,6,8,10],[1,3,5,7,9])
22:03:51 <mtnviewmark> tada
22:04:06 <itrekkie> what's a non-exhaustive pattern exception?
22:04:09 <dmwit> :t partitionEithers
22:04:10 <lambdabot> forall a b. [Either a b] -> ([a], [b])
22:04:13 <dmwit> mtnviewmark: tada
22:04:17 <mtnviewmark> you win
22:04:21 <mtnviewmark> who knew?
22:04:23 <kmc> is it recommended to profile for heap consumption with or without -O2?
22:04:32 <c_wraith> > partition even [1..]
22:04:33 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
22:04:34 <caelan> itrekkie: it's the equivalent of not having a default case in a switch statement
22:04:41 <Cale> itrekkie: It means that the value which your function was applied to didn't match any of the patterns on which you defined that function
22:04:53 <dmwit> > let evenOdds = partitionEithers . zipWith ($) (cycle [Left, Right]) in evenOdds [1, 1, 2, 3, 5, 8, 13, 21, 34]
22:04:54 <lambdabot>   ([1,2,5,13,34],[1,3,8,21])
22:05:24 <Cale> itrekkie: For example, this will happen if you forget to define a function for the empty list, and somewhere in your program it is actually applied to an empty list.
22:05:29 <kdvh> itrekkie: you need a catch-all pattern :d
22:05:48 <Cale> (Or you just need to handle whatever case is missing)
22:06:21 <itrekkie> â€“how embarrassing, just forgot to re :load, now to just try to figure this out again :D
22:06:53 <Cale> itrekkie: http://paste.lisp.org/display/114520#1
22:06:54 <itrekkie> what's the name of the (x:xs) syntax? I need more background on that
22:07:03 <c_wraith> pattern mathing
22:07:06 <Cale> It's a pattern match
22:07:10 <c_wraith> err, matching
22:07:30 <Cale> Every list is either the empty list []
22:07:36 <dmwit> It's a pattern match if it's on the left of a function equation or case statement, or a constructor if it's on the right.
22:07:50 <Cale> or it is a nonempty list with a first element, or 'head' x, and a 'tail' xs, written (x:xs)
22:07:58 <mtnviewmark> itrekkie: even thought dmwit and I came up with a "clever" implementation - it would be well worth your wile to work out a more "direct" implementation of evenOdd on your own
22:08:35 <itrekkie> I'm still trying to make my original work here, this is a lot of magic 
22:08:38 <dmwit> Wow, giving me partial credit. That's big of you. =)
22:08:46 <dmwit> definitely undeserved
22:09:21 <Cale> > let evens xs = [(x | (k,x) <- zip [0..] xs, even k] in evens "hello there"
22:09:22 <lambdabot>   <no location info>: parse error on input `|'
22:09:28 <Cale> > let evens xs = [x | (k,x) <- zip [0..] xs, even k] in evens "hello there"
22:09:29 <lambdabot>   "hlotee"
22:10:16 <dmwit> > join (***) (map snd) . partition (even . fst) . zip [0..] $ "hello there"
22:10:17 <lambdabot>   ("hlotee","el hr")
22:10:27 <Cale> There's another way to define evens -- zip [0..] will tag the elements of a list with their indices
22:10:38 <Cale> and we can then select the elements which have even indices
22:11:06 <Cale> > zip [0..] "hello there"
22:11:07 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'t'),(7,'h'),(8,'e'),(9...
22:11:13 <dmwit> > join (***) (map snd) . partition fst . zip (cycle [True, False]) $ "hello there"
22:11:14 <lambdabot>   ("hlotee","el hr")
22:11:18 <kmc> @src ($!)
22:11:19 <lambdabot> f $! x = x `seq` f x
22:12:03 <Eduard_Munteanu> Hi.
22:12:47 <Cale> Hello
22:13:45 <itrekkie> ah ':' is an operator? 
22:14:00 <kdvh> (:) is the cons operator
22:14:03 <dmwit> (:) is a function.
22:14:04 <ezyang> yes. 
22:14:05 <Cale> itrekkie: It's a special sort of function called a data constructor
22:14:09 <ezyang> :t (:) 
22:14:10 <lambdabot> forall a. a -> [a] -> [a]
22:14:13 <dmwit> It's special, but it can also behave as a function.
22:14:17 <itrekkie> what's the difference between it and ++ ?
22:14:18 <Cale> Data constructors are the functions which you're allowed to pattern match against
22:14:32 <Cale> (++) concatenates two lists, (:) adds an element to the beginning of a list
22:14:49 <dmwit> (You are allowed to pattern match on them because they are injective and easily invertible.)
22:14:58 <kdvh> (:) adds an element to a head of list, (++) joins two lists together, i think.
22:15:06 <Cale> kdvh: That's right
22:15:17 <Cale> :t (:)
22:15:17 <lambdabot> forall a. a -> [a] -> [a]
22:15:21 <Cale> :t (++)
22:15:22 <lambdabot> forall m. (Monoid m) => m -> m -> m
22:15:25 <Cale> ;)
22:15:29 <Cale> :t (Prelude.++)
22:15:30 <lambdabot> forall a. [a] -> [a] -> [a]
22:15:40 <kdvh> forgot it was a monoid
22:15:49 <kdvh> identity will be [], then?
22:15:50 <Cale> (++) in lambdabot has been generalised
22:15:59 <dmwit> kdvh: yes
22:16:01 <Cale> yeah
22:16:15 <kdvh> thought so
22:16:42 <itrekkie> but in the case of the pattern match (x:xs), that colon has a different meaning?
22:17:16 <dmwit> (:) can be used to construct a list or to destruct it, yes.
22:18:09 <Cale> itrekkie: (x:xs) still refers to the list whose first element is x and where the rest is called xs
22:18:14 <geheimdienst> itrekkie, if you match on (x:xs), you'll get the first element of the list in x and the rest of the list in xs
22:18:19 <etpace> @hoogle Int -> [a] -> Maybe a
22:18:20 <lambdabot> Prelude (!!) :: [a] -> Int -> a
22:18:20 <lambdabot> Data.List (!!) :: [a] -> Int -> a
22:18:20 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
22:18:24 <etpace> no safe !!?
22:18:26 <geheimdienst> (also called "head" and "tail")
22:18:29 <Cale> itrekkie: Whether it's constructing that list, or deconstructing it by matching that pattern
22:18:34 <Eduard_Munteanu> It's a simple case of matching on ADTs.
22:18:34 <itrekkie> okay, so x is head x and xs is tail xs?
22:18:43 <Eduard_Munteanu> itrekkie: no
22:18:43 <kdvh> itrekkie: yes
22:18:44 <dmwit> etpace: yes, take 1 . drop n
22:18:47 <ddarius> etpace: You simply shouldn't be using !! at all, safe or not.
22:18:49 <dmwit> etpace: or listToMaybe . drop n
22:18:57 <Cale> > let f (x:xs) = (x,xs) in f [1,2,3]
22:18:58 <etpace> I have a list I'd like to get the nth item from
22:18:58 <lambdabot>   (1,[2,3])
22:19:03 <etpace> what's better than a safe !!?
22:19:03 <Eduard_Munteanu> itrekkie: it's head of the whole thing and "the rest"
22:19:16 <dmwit> > take 1 . drop 30 $ [1..]
22:19:17 <lambdabot>   [31]
22:19:23 <ddarius> etpace: Not using a list as a random access data structure.
22:19:24 <dmwit> > take 1 . drop 30 $ [1..29]
22:19:25 <lambdabot>   []
22:19:30 <Cale> let f x xs = (x:xs) in f 1 [2,3]
22:19:31 <itrekkie> okay, I think I've got that now 
22:19:35 <Cale> > let f x xs = (x:xs) in f 1 [2,3]
22:19:36 <lambdabot>   [1,2,3]
22:19:51 <etpace> what would you recommend for indexing int oa line of a csv file?
22:20:12 <mtnviewmark> itrekkie: you can think of   x:xs   as "create a value with the form    x : xs "  --- and so, in a pattern, it matches "a thing of the form    x : xs "
22:20:56 <itrekkie> okay, so where x would be (:) to the list xs
22:21:20 <kdvh> no, in this case, you are deconstructing
22:21:37 <mtnviewmark> whereas   xs ++ ys   means "apply the (++) function to xs and ys"   --- as such, it can't be directly pattern matched against, since it doesn't return a thing "of the form xs ++ ys"  -- indeed, it returns a thing "of the form z : zs"
22:21:57 <Cale> Let's define (++) in terms of (:)
22:22:04 <Cale> [] ++ ys = ys
22:22:12 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
22:22:50 <Cale> If the first parameter to ++ is empty, the result of the concatenation is just the second parameter
22:23:03 <kdvh> ++ is an associative binary function
22:23:26 <Cale> If the first parameter is a nonempty list whose first element is x, then the result is the list which starts with x, and whose tail is the result of concatenating the rest of that list with ys
22:23:35 <kmc> hmm, seems Data.IntMap.adjust will keep my alteration function thunked in the tree; Data.IntMap.alter lets me prevent this by (Just $! ...)
22:23:40 * kmc files it away in his bag o' tricks
22:23:57 <monochrom> > map ("c" ++) ["haskell", "phone", "lock"]
22:23:58 <lambdabot>   ["chaskell","cphone","clock"]
22:24:27 <Eduard_Munteanu> itrekkie: you might want to write the list using a normal 'data' definition, i.e. List and Cons.
22:24:37 <Eduard_Munteanu> You'll see (:) isn't that magic.
22:24:39 <mtnviewmark> > map ("hello " ++) ["world", "solar system", "universe"]
22:24:40 <lambdabot>   ["hello world","hello solar system","hello universe"]
22:25:00 <itrekkie> oh wow, it sort hits you hard when you figure things out :)
22:25:44 <mtnviewmark> folks - he's had his first brain explosion..... and as we've all experienced, many more and bigger ones to follow!!! :-)
22:26:25 <ddarius> @src []
22:26:25 <lambdabot> data [] a = [] | a : [a]
22:26:39 <mtnviewmark> itrekkie: after about the third or fourth such brain melt-down, you get addicted to it... and you have to code Hakell every couple of hours or you start going through withdrawal 
22:27:30 <dmwit> My first was in properly parsing through a type like (a -> b -> c) or so. Then I asked myself why all languages didn't do that... and never turned back.
22:27:50 <Eduard_Munteanu> Yeah, just like with cocaine, with prolonged use your reward circuits in the brain get fried. Then you never go C(lean).
22:28:14 <ddarius> Clean is pretty similar to Haskell.
22:28:42 <Eduard_Munteanu> ddarius: yeah, I wanted to avoid that, I meant the 1-letter imperative programming language
22:28:44 <mtnviewmark> itrekkie: you can contrast that @src [] with what it might be if we didn't have the nice syntax:    data List a = Nil | Cons a (List a)
22:29:29 <ddarius> x => { Console.Write("Cackle!"); return y => x; }
22:31:04 <kmc> f => { return (x => { return f(x(x)); })(x => { return f(x(x)); }); } // ?
22:36:01 <thoughtpolice> [=x]() -> (std::function<int()>) { std::cout<<"ohmygod"; return []() { return 4; }}
22:36:15 <thoughtpolice> i actually have no idea if that will compile, but i think that's doable
22:38:03 <kmc> yes let's return our closures by value and copy their free vars everywhere ;)
22:38:11 <kmc> (there aren't any here)
22:38:28 <kmc> is there a way to automatically give every function in a "let" or "where" its own cost center, similar to -auto-all for top level?
22:39:14 <duckinator> hi
22:40:47 <copumpkin> kmc: don't think so
22:40:58 <duckinator> mtnviewmark: designing your own programming languages and writing your own os in your free time are interesting alternative methods of providing those "brain meltdowns" you find so addictive ;)
22:41:07 <duckinator> not that i'm designing my own programming language or anything right now
22:41:09 <duckinator> *cough*
22:41:24 <dmwit> duckinator: do tell
22:41:25 <mtnviewmark> duckinator: been there... done that.... :-)
22:42:50 <duckinator> dmwit: i'm working on a language called TDL (i asked some people what to name "that damn language I've been working on since august", they suggested "That Damn Language" ;P), purely prototype-based/event-driven language: http://github.com/RockerMONO/TDL/blob/master/design.md
22:43:38 <ddarius> kmc: In C# you can simply write: f => (x => f(x(x)))(x => f(x(x)))
22:44:13 <ddarius> You can even get that to type check in C#.
22:44:31 <Cale> ddarius: As is, or do you need additional isomorphisms?
22:44:39 <duckinator> dmwit: the way i'm going about the design/implementation is all the built-ins are as simple as possible, and core.tdl builds on those to create the actual objects 99.999% of TDL code will use
22:44:54 <ddarius> Cale: You might have to make some types more explicit, but C# has equirecursive types in a few places.
22:45:38 <dmwit> duckinator: Have you ever played with Smalltalk?
22:45:41 <ddarius> Namely, delegate declarations can be recursive.
22:45:42 <thoughtpolice> ah, here we go: auto f = [&]() -> function<int()> { cout<<"ohmygod"; return ([&]() { return x; }); }; f()();
22:45:55 <thoughtpolice> well now, isn't that, uh, totally awful and verbose :(
22:46:10 <thoughtpolice> better than functors everywhere for callable objects, at least
22:46:42 <kmc> "C# has equirecursive types in a few places." -- wow...
22:46:52 <dmwit> Wow, really?
22:46:54 <kmc> on purpose? ;)
22:47:00 <dmwit> heh
22:48:00 <kmc> the C# designers certainly seem to follow PL theory
22:48:01 <ddarius> kmc: I suspect it wasn't intentional.
22:48:04 <kmc> which is more than can be said for a lot of languages
22:48:46 <ddarius> Well, it wasn't exactly intentional.
22:49:37 <copumpkin> is agda intentionally intensional?
22:49:43 <copumpkin> I'd suspect so
22:50:50 * ddarius was thinking earlier about an inadvertantly entertaining paper about type "erasue" for a type system with intensional type analysis.
22:50:51 <dolio> I've heard rumors that they're going to switch to observational equality as soon as the Epigram guys iron out the kinks.
22:51:17 <ddarius> +r
22:52:05 <copumpkin> dolio: yeah, I think pigworker mentioned that at some point
22:53:43 <Eduard_Munteanu> Hm, and I thought C# coders were generally codemonkeys.
22:54:10 <Eduard_Munteanu> Oh, C#'s designers.
22:54:11 <ddarius> I think it might have been this paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.4107&rep=rep1&type=pdf
22:54:44 <itrekkie> is there a function to turn a char into its ascii int?
22:55:33 <dmwit> :t chr
22:55:35 <lambdabot> Int -> Char
22:55:36 <dmwit> :t ord
22:55:37 <lambdabot> Char -> Int
22:55:54 <dmwit> itrekkie: Note that a Char may not necessarily be in the ASCII range.
22:55:55 <Eduard_Munteanu> Or the {from,to}Enum counterparts.
22:56:07 <itrekkie> ord looks like fun, thanks
22:56:16 <ddarius> Cale: http://blogs.msdn.com/b/wesdyer/archive/2007/02/02/anonymous-recursion-in-c.aspx
22:56:18 <atude> have any of you used sage?
22:56:27 <Eduard_Munteanu> Actually those are more general.
22:56:37 <Adamant> atude: barely. it's kinda funky.
22:56:48 <ddarius> > ord maxBound
22:56:49 <lambdabot>   1114111
22:56:51 <Adamant> assuming you mean the CAS/math system Sage
22:57:02 <atude> Adamant: do you use mathematica?
22:57:14 <Zao> Considering that ASCII has seven bits and an unicode codepoint is like 21, there's a fair bit of impedance mismatch.
22:57:16 <itrekkie> ord looks like it's in the prelude module, but do I have to import that?
22:57:20 <Zao> Data.Ord
22:57:26 <Adamant> atude: I use programming languages; I can't afford a Mathematica license
22:57:32 <mtnviewmark> itrekkie: those functions, like most of Haskell, work in terms of Unicode, not ASCII
22:57:52 <Zao> itrekkie: Maybe you're mistaking it for Ord?
22:57:54 <dmwit> itrekkie: It's in Data.Char.
22:58:04 <mtnviewmark> > char 0x2665
22:58:05 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
22:58:05 <lambdabot>    arising from the literal `9...
22:58:14 <Adamant> atude: in terms of polish, Sage doesn't compare to Mathematica the last time I used both
22:58:22 <dmwit> > chr 0x2665
22:58:23 <lambdabot>   '\9829'
22:58:23 <Zao> Oh, right :D
22:58:24 <Adamant> or Maple
22:58:34 <Zao> > chr 9001
22:58:35 <lambdabot>   '\9001'
22:58:42 <dmwit> > '\x2665'
22:58:43 <lambdabot>   '\9829'
22:58:50 <Eduard_Munteanu> Adamant: might try wxMaxima if you're interested in symbolic CAS.
22:58:54 <atude> Adamant: ah, okay.. I just hate mathematicas interface in linux and how slow it performs
22:58:56 <Eduard_Munteanu> um, Maxima.
22:58:56 <mtnviewmark> bother - i forgot that lambdabot won't reply with strings directly
22:59:04 <dmwit> > "\x266\&5"
22:59:05 <lambdabot>   "\614\&5"
22:59:08 <Adamant> Eduard_Munteanu: good advice, not doing a lot of that right now though
22:59:10 <atude> Adamant: and I cannot get sage to start, at all
22:59:12 <Adamant> thank you
22:59:16 <dmwit> > var "\x2665" -- mtnviewmark 
22:59:17 <lambdabot>   â™¥
22:59:18 <Adamant> is there a #sage?
22:59:30 <mtnviewmark> var?!?!?!?
22:59:31 <atude> Adamant: no
22:59:33 <mtnviewmark> :t var
22:59:34 <lambdabot> forall a. String -> Sym a
22:59:38 <dmwit> > "\x266&5"
22:59:39 <lambdabot>   "\614&5"
22:59:39 <ddarius> > text "\x2665"
22:59:40 <lambdabot>   â™¥
22:59:50 <mtnviewmark> :t text
22:59:51 <lambdabot> String -> Doc
22:59:58 <Eduard_Munteanu> Interestingly, it's written in Lisp, so who knows what magic is inside there.
23:00:08 <dmwit> > text "hey" `vcat` text "eh?"
23:00:09 <lambdabot>   Couldn't match expected type `[Text.PrettyPrint.HughesPJ.Doc]'
23:00:09 <lambdabot>         agai...
23:00:13 <dmwit> :t vcat
23:00:14 <lambdabot> [Doc] -> Doc
23:00:25 <dmwit> > vcat . map text $ ["hey", "eh?"]
23:00:26 <lambdabot>   hey
23:00:26 <lambdabot>  eh?
23:00:30 <ddarius> @hoogle Doc -> Doc -> Doc
23:00:31 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
23:00:31 <lambdabot> Text.PrettyPrint.HughesPJ ($+$) :: Doc -> Doc -> Doc
23:00:31 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
23:00:32 <dmwit> huh
23:01:48 <ddarius> > text "\x8\x8\x2665"
23:01:49 <lambdabot>   â™¥
23:02:49 <mtnviewmark> (mind you, itrekkie: you don't need Doc stuff to work with strings...it is just a text formatting system that lambdabot knows about, and so lets us print strings directly, rather than in their escaped form that the REPL normally does)
23:02:53 * ddarius considers making a quick bread.
23:03:14 <ashley_s> How do I convert the following imperial code into Haskell code: for elem in list: if some_function(elem): return elem
23:03:25 <dmwit> filter some_function
23:03:29 <ddarius> "imperial" ?
23:03:30 <dmwit> well
23:03:33 <dmwit> filter some_function list
23:03:35 <ashley_s> I am thinking of using a filter, but I want one element not a list with one element
23:03:42 <c_wraith> imperial code?  start the star wars march!
23:03:43 <ezyang> dmwit: And then head it. 
23:03:44 <copumpkin> dmwit: find?
23:03:52 <dmwit> listToMaybe . filter some_function
23:03:57 <dmwit> find
23:03:58 <dmwit> sure
23:04:03 <ezyang> listToMaybe is better tho :-) 
23:04:09 <copumpkin> why?
23:04:13 <copumpkin> find returns a Maybe too
23:04:14 <dmwit> I read "return" as the monadic return in the imperative code.
23:04:17 * dmwit slaps wrist
23:04:24 <ddarius> @hoogle Eq a => a -> [a] -> Maybe a
23:04:24 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
23:04:24 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
23:04:24 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
23:04:42 <dmwit> do { elem <- list; guard (some_function elem); return elem }
23:04:49 <dmwit> ^^ perfectly valid Haskell
23:04:50 <copumpkin> @hoogle (a -> Bool) -> [a] -> Maybe a
23:04:51 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
23:04:51 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
23:04:51 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
23:05:06 <ashley_s> find is perfect. Thanks guys.
23:05:49 <dmwit> I can't say I've had a lot of reason in the past for restricting such searches to returning only one value, though.
23:06:16 <dmwit> Laziness sort of makes that unnecessary.
23:10:38 <etpace> anything more idiomatic than maybe default return =<< maybeval"
23:11:30 <dmwit> Are you sure you meant that (=<<) there?
23:11:47 <etpace> yeah, maybeval :: m (Maybe a)
23:12:02 <dmwit> ah
23:12:10 <dmwit> fmap (fromMaybe default) maybeval
23:12:14 <ddarius> traverse
23:12:18 <ddarius> :t traverse
23:12:19 <lambdabot> Not in scope: `traverse'
23:12:20 <dmwit> s/fmap/liftM/ according to preference
23:12:23 <ddarius> @hoogle traverse
23:12:23 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:12:23 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
23:12:29 <ddarius> @hoogle sequence
23:12:29 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
23:12:29 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
23:12:29 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
23:12:31 <ddarius> That's the one I want.
23:13:12 <dmwit> or perhaps
23:13:16 <dmwit> :t (<$>)
23:13:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:13:24 <dmwit> fromMaybe default <$> maybeval
23:13:56 <ddarius> :t \default maybeval -> maybe default return =<< maybeval
23:13:57 <lambdabot> parse error on input `default'
23:14:06 <ddarius> :t \def maybeval -> maybe def return =<< maybeval
23:14:07 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m (Maybe a) -> m a
23:14:36 <dmwit> Oh, mine is the wrong type, eh?
23:14:39 <dmwit> Bummer.
23:15:03 * dmwit crosses his fingers and hopes "def" is actually "return def", in which case his example is even better
23:15:17 <etpace> it's not :(
23:15:40 <dmwit> ah
23:16:02 <etpace> :t \def maybeval -> join $ fromMaybe def <$> maybeval
23:16:03 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m a -> m (Maybe (m a)) -> m a
23:16:10 <etpace> bleh
23:24:27 <jbottoms> anybody home?
23:24:41 <Eduard_Munteanu> o/
23:25:05 <jbottoms> does anyone know something about cme11e9-evbu
23:25:30 <kmc> you're trying to run Haskell on this single-board computer?
23:25:37 <dmwit> Are you sure you're in nthe right place?
23:26:46 <tommd> yes
23:29:29 <kmc> can GHC tell me if i've specified an unnecessary LANGUAGE pragma?
23:30:47 <itrekkie> is there a way to create a string from a char? show is giving odd results
23:30:58 <ManateeLazyCat> itrekkie: [c]
23:31:08 <ManateeLazyCat> :t ['c']
23:31:09 <lambdabot> [Char]
23:31:29 <ManateeLazyCat> :t ['c'] :: String
23:31:30 <lambdabot> String
23:31:31 <itrekkie> thanks guys :)
23:31:39 <ManateeLazyCat> itrekkie: NP :)
23:31:49 <kmc> > ['c']
23:31:50 <lambdabot>   "c"
23:31:57 <tommd> > show error
23:31:58 <lambdabot>   Overlapping instances for GHC.Show.Show ([GHC.Types.Char] -> t)
23:31:58 <lambdabot>    arising ...
23:32:03 <tommd> damned
23:32:08 <kmc> itrekkie, "show" is supposed to turn its input into Haskell source code.  so Â«show 'c'Â» will produce the string "'c'"
23:32:20 <itrekkie> yea, that's exactly what I was seeing
23:32:33 <kmc> likewise Â«show "foo"> = "\"foo\""
23:32:39 <kmc> > show "foo"
23:32:40 <lambdabot>   "\"foo\""
23:32:40 <itrekkie> I didn't want the darned quotesâ€“what's the purpose of turning it into source?
23:32:44 <tommd> The under-used "Pretty" class is for human strings (function "pPrint")
23:32:58 <tommd> itrekkie: read . show = id
23:33:07 <tommd> (id is the identity function)
23:33:25 <kmc> itrekkie, the idea is that your dialogue with GHCi looks like Haskell source
23:33:37 <kmc> and GHCi uses Show to print values
23:33:52 <kmc> and furthermore it guarantees that Show representation can be parsed back in with Read
23:33:59 <kmc> except people write lots of instances that break this
23:34:01 <tommd> itrekkie: people of often "show" values while debugging then they can "read val" back into a haskell structure.
23:34:17 <kmc> show / read are not designed to be a comprehensive pretty printing / parsing system
23:34:21 <tommd> > show (fromList [(1,2), (4,5), (8,8)])
23:34:22 <lambdabot>   No instance for (GHC.Show.Show (m t))
23:34:22 <lambdabot>    arising from a use of `GHC.Show.sh...
23:34:28 <kmc> they're useful for quick hacks because the compiler will derive them for you
23:34:29 <ManateeLazyCat> kmc: groom is 
23:34:39 <ManateeLazyCat> @hoogle groom
23:34:39 <lambdabot> No results found
23:34:41 <kmc> i wouldn't say groom is 'comprehensive'
23:34:41 <itrekkie> oh that does seem kinda handy
23:34:48 <kmc> but it does make stuff prettier than plain old show
23:35:04 <ManateeLazyCat> better than nothing .. :)
23:35:12 <kmc> the point is, e.g., if you're writing a C compiler, you wouldn't want your Show and Read instances to be an actual C pretty printer and parser
23:35:20 <kmc> you probably keep them as a quick hack for inputting / showing AST expressions
23:35:30 <kmc> and write actual parser / printer elsewhere
23:35:44 <tommd> Or make kmc write one.
23:35:55 <kmc> ;P
23:36:21 <ManateeLazyCat> kmc: Give us better groomer....
23:38:19 <kmc> most languages have a concrete syntax that is not Haskell expressions
23:38:27 <kmc> groom is useless for printing those
23:38:33 <kmc> it is a special-purpose tool that does one thing well
23:41:31 <itrekkie> what is the type of an expression like == 1? I want to write my own version of all
23:41:40 <kmc> :t (== 1)
23:41:41 <lambdabot> forall a. (Num a) => a -> Bool
23:41:59 <kmc> itrekkie, (== x) is syntactic sugar for Â«\y -> y == xÂ»
23:42:07 <kmc> or if you like, Â«let f y = y == x in fÂ»
23:42:14 <itrekkie> :t (== head xs)
23:42:15 <lambdabot> Not in scope: `xs'
23:42:20 <itrekkie> oh well, I tried
23:42:38 <kmc> :t (=='x')
23:42:39 <lambdabot> Char -> Bool
23:42:45 <kmc> > map (=='x') "abcxyz"
23:42:46 <lambdabot>   [False,False,False,True,False,False]
