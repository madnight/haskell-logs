00:23:34 * hackagebot synthesizer-dimensional 0.5 - Audio signal processing with static physical dimensions  http://hackage.haskell.org/package/synthesizer-dimensional-0.5 (HenningThielemann)
00:25:34 * hackagebot synthesizer-alsa 0.3 - Control synthesizer effects via ALSA/MIDI  http://hackage.haskell.org/package/synthesizer-alsa-0.3 (HenningThielemann)
00:28:19 <tolkad> > take 10 [0+(1 * 1),0+(2 * 1)..]
00:28:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:28:37 <tolkad> is there any explanation on how exactly these work?
00:29:44 <c_wraith> what?  list comprehensions?
00:29:47 <tolkad> yeah
00:29:55 <c_wraith> They're implemented in terms of the Enum class
00:30:17 <c_wraith> @src Enum
00:30:17 <lambdabot> class  Enum a   where
00:30:18 <lambdabot>     succ                     :: a -> a
00:30:18 <lambdabot>     pred                     :: a -> a
00:30:18 <lambdabot>     toEnum                   :: Int -> a
00:30:18 <lambdabot>     fromEnum                 :: a -> Int
00:30:19 <lambdabot> [3 @more lines]
00:30:23 <c_wraith> @more
00:30:23 <lambdabot>     enumFrom                 :: a -> [a]
00:30:24 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
00:30:25 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
00:31:02 <c_wraith> those last 4 functions are what list expressions involving .. are translated into, directly
00:31:13 <Gracenotes> first/follow sets are a lot more confusing in haskell than in math-speak
00:31:15 <tolkad> so the first and second item in the list are fully evaluated then...
00:31:17 <c_wraith> [1..] becomes enumFrom 1
00:31:35 <Gracenotes> probably because lists don't work for strings so well
00:31:38 <tolkad> I see, they make much more sense now
00:32:53 <kmc> that's not a comprehension afaik
00:32:59 <kmc> just another syntactic special case
00:33:06 <c_wraith> yeah, I used the wrong word
00:33:19 <c_wraith> list literal would have been more accurate
00:33:29 <kmc> i'm not sure what the Report calls them
00:33:44 <kmc> also i'm not sure the relevance of when things are "fully evaluated"
00:33:53 <tolkad> it would be cool if there was a unicode character that automatically aligned stuff like in that class definition lambdabot just gave
00:34:18 <kmc> the lazy/strict behavior of enumFromThen will depend on the particular instance
00:34:19 <tolkad> I.E. if it appeared on consecutive lines it would automatically shift right until it was aligned
00:34:19 <ddarius> The Report calls them "arithmetic sequences."
00:34:20 <c_wraith> [1..] becomes enumFrom 1.  [1,3..] becomes enumFromThen 1 3.   [1..5] becomes enumFromTo 1 5.  [1,3..9] becomes enumFromThenTo 1 3 9
00:34:49 <Gracenotes> tolkad: just imagine when it started getting used in code and mixed with spaces
00:34:54 <Gracenotes> *starts
00:35:03 <tolkad> Gracenotes: should be no problems
00:37:09 <tolkad> Gracenotes: It would work perfectly, you could even have multiple on the same line, and it would match them up with the second one on the preceding and following lines
00:37:49 <Gracenotes> ah. how many spaces would an unmatched character take up?
00:38:12 <tolkad> Gracenotes: what do you mean unmatched character?
00:38:18 <tolkad> oh all alone I see
00:38:23 <tolkad> uh just one
00:38:50 <tolkad> or none
00:38:56 <tolkad> either standard word work
00:39:00 <tolkad> would work*
00:39:58 <kmc> it would have zero width in display
00:40:04 <kmc> as do some other unicode code points
00:40:25 <kmc> there are editors with these flexible alignment markers or whatever
00:40:35 <kmc> it's a nice idea
00:40:50 <kmc> actually solves the problem which tabs solve so, so poorly
00:40:56 <Gracenotes> I wonder if it could replace css columns
00:41:11 <Gracenotes> well er not free-flowing columns
00:41:17 <Gracenotes> but HTML tables, in some form
01:02:29 <mao_> Hello, I wanted to install hoogle, but I got a warning:
01:02:29 <mao_> src/Main.hs:1:0:
01:02:29 <mao_>     Warning: Module `Prelude' is deprecated:
01:02:30 <mao_>                You are using the old package `base' version 3.x.
01:02:30 <mao_>                Future GHC versions will not support base version 3.x. You
01:02:30 <mao_>                should update your code to use the new base version 4.x.
01:02:35 <mao_> what should I do about it?
01:02:51 <mao_> I have haskell-platform from debian squeeze repo
01:07:32 <tolkad> mao_: it's not because of anything in Main
01:07:40 <tolkad> mao_: it's because of the .cabal file
01:07:50 <mao_> ok, I understand this
01:07:50 <tolkad> mao_: it asks for an old version of the haskell standard library
01:08:01 <mao_> So how can I fix this?
01:08:12 <mao_> should I do `cabal install base'?
01:08:20 <tolkad> mao_: there's nothing to fix
01:08:27 <tolkad> mao_: it's just a deprecation notice
01:08:29 <kmc> Text.Printf.IsChar is a silly class
01:08:33 <mao_> Oh ok
01:08:35 <mao_> thanks
01:08:43 <kmc> mao_, never cabal install base
01:08:47 <kmc> base comes with GHC
01:08:50 <tolkad> he left
01:08:53 <kmc> it's an issue with hoogle, not your setup
01:08:54 <kmc> aww
01:09:01 <kmc> probably going off to cabal install base now
01:09:11 <tolkad> I told him there's nothing to fix
01:31:08 <kmc> HWN is dead right?
01:31:16 <Baughn> That is not dead which can eternal lie.
01:31:22 <Baughn> And with strange aeons, even death may die.
01:31:41 <Baughn> ..comatomse.
01:31:43 <Baughn> *comatose
01:32:33 <Baughn> Scanning haskell-cafe has become a full-time job, however. I can see why it'd be a bit much for him.
01:33:16 <kmc> yeah, cafe is way too high traffic for me to keep up
01:33:26 <kmc> i think /r/haskell is about right
01:33:45 <kmc> there's a thing where it's good to be visible answering questions on cafe but i much prefer irc for that
01:51:45 <glantern> Hi
01:51:57 <glantern> Anyone use learnyouahaskell.com to learn Haskell?
01:52:06 <glantern> I'm just starting out and it seems pretty nice
01:52:07 <kmc> many people :)
01:52:19 <kmc> the author hangs out here :)
01:52:27 <glantern> I'm on chapter 4: Syntax in Functions now
01:52:33 <glantern> That's interesting, kmc
01:52:37 <glantern> :)
01:53:30 <glantern> I am also using irssi which is new to me too
01:53:36 <glantern> Everything is new to me, people ^^
01:54:30 <basti_> ;)
01:54:32 <kmc> cool :)
01:54:36 <kmc> it is fun to learn new things
01:54:45 <glantern> yeah. I am also learning R.
01:54:49 <kmc> @arr
01:54:49 <lambdabot> Yeh scurvy dog...
01:54:52 <glantern> And I've been wondering how to compare R and Haskell
01:55:00 <glantern> :)
01:55:27 <Baughn> glantern: http://scripts.irssi.org/
01:55:35 <Baughn> glantern: You want splitlong.pl and, probably, screen_away.pl
01:56:13 <glantern> I'm getting my nerd on right now with irssi, 2 ssh windows, Firefox Beta 4, Youtube, learnyouahaskell, Filezilla, Komodo etc all open at the same time, and on Komodo I have a Perl script which generates R scripts in turn
01:56:36 <glantern> I must confess having Compiz helps a lot ;)
01:56:42 <glantern> Thanks Baughn, let me check them out!
01:56:47 <kmc> try xmonad ;)
01:56:54 <meiersi> @arr
01:56:54 <lambdabot> Drink up, me 'earties
01:56:54 <Baughn> Definitely try xmonad. :D
01:57:36 <kmc> xmonad is a very nice implementation of an idea that isn't *quite* what i want
01:57:40 <Cale> I feel so conflicted about xmonad. On the one hand, got to support Haskell projects, on the other hand, I don't actually like using it :P
01:57:45 <kmc> but it's close enough that i'm very happy using it on a daily basis
01:58:08 <Baughn> Cale: How do you feel about bluetile?
01:58:17 <Cale> I don't like tiling WMs
01:59:17 <Cale> bluetile seems to have sort of decent floating windows at least
01:59:50 <Cale> I just almost never want my windows to be tiled like that.
02:01:00 <Cale> and while I know I could write a layout manager to sort of approximate what I do with the mouse, it's easier just to do it than to work out with mathematical precision what I'm doing with my windows.
02:05:29 <glantern> Lol there's a script at scripts.irssi.org that translates German to Swabian ^^
02:05:33 <glantern> The things people come up with ;)
02:05:41 <kmc> haha
02:05:51 <glantern> It's really easy programming-wise
02:05:55 <glantern> But you have to be thorough
02:06:02 <kmc> ManateeLazyCat was earlier today using an IRC client that translates between English and Chinese
02:06:03 <glantern> In remembering all the words that can be substituted
02:06:20 <glantern> Not too different from writing a stemmer or lemmatizer for natural language processing
02:06:29 <glantern> I looked at the code right now
02:07:04 <earthy> fortunately the german and schwäbisch grammars do not differ too much.
02:07:15 <glantern> Yeah it's just some words/ expressions/ spellings
02:07:22 <glantern> How do you know, Earthy? Are you German?
02:07:30 <glantern> You did use the umlaut
02:07:34 <earthy> dutch.
02:07:38 <glantern> Ah I see
02:07:52 <earthy> but employed in a natural language parsing group. :)
02:08:01 <glantern> I do have at least two friends from the Netherlands
02:08:10 <glantern> And I work in NLP - at a research lab at a university 
02:08:22 <glantern> Never mind, one of them is from Belgium (Flemish)
02:08:38 <earthy> doing statistics, then? :P
02:08:59 <glantern> yeah - working with PageRank for now, and R is really good for that... Haskell is part of a class I am taking
02:10:37 <earthy> and you're using PageRank on the word-level? lemma-level? np-level? what? :)
02:11:27 <glantern> word level
02:11:41 <glantern> between words in a given context we have directed graphs
02:11:52 <glantern> how we built the directed graphs - is a long long story ;)
02:12:09 * earthy would imagine
02:12:31 <earthy> we do the simple 'proven wrong' thing: we actually run a parser :)
02:13:15 <glantern> I confess parsing is something I don't really do
02:13:25 <glantern> More into word sense disambiguation, translation, etc
02:13:34 <glantern> I know someone at the Utrecht university
02:13:36 <glantern> ;)
02:13:47 <meiersi> quit
02:13:52 <earthy> I used to be at UU
02:14:03 <glantern> aha - that's interesting 
02:14:15 <earthy> didn't do NLP there at all though
02:14:31 <glantern> was that very long ago? well okay - if you didn't do NLP then you probably don't know that person
02:15:04 <earthy> afair there's no NLP guys in the CS department at UU
02:16:38 <glantern> Linguistics then - Language and Speech Technology - is that not part of CS there?
02:17:07 <glantern> Maybe not - mostly it's under CS. Sometimes it may be under some other department
02:17:45 <earthy> Language and Speech Technology in Utrecht is with the humanities department
02:18:44 <glantern> makes sense... at our university it's under CS. Which is good or else I won't have joined it ;)
02:18:49 <glantern> I am a CS guy after all
02:19:47 <earthy> as am I :)
02:28:03 <glantern> I bet all of you must be Europeans... because it's pretty late in good ol country of Texas :p
02:28:46 <earthy> it's about 11:30 here ;)
02:29:01 <earthy> am. :)
02:29:03 <glantern> 7 hours yeah I know... I flew threw Amsterdam once
02:29:08 <glantern> through*
02:46:48 <ManateeLazyCat> juhp_: Are you there?
02:47:00 <juhp_> ManateeLazyCat: hi
02:47:31 <ManateeLazyCat> juhp_: Bad luck, i change some gio code to ByteString, manatee-anything dad sometimes.
02:47:42 <ManateeLazyCat> juhp_: I'm confuse now. :(
02:47:56 <juhp_> dead?
02:48:01 <juhp_> hmm
02:48:14 <ManateeLazyCat> juhp_: unsafeUseAsCString can't work somehow, but withCString works fine.
02:48:36 <mauke> even electronic brain pancake crystal elderly
02:49:04 <chrisdone> Twey: have you got a good JavaScript monad definition?
02:49:15 <ManateeLazyCat> juhp_: The strange thing is , i write some test code, test some path fine, but when i type path in manatee-anything, sometimes success, sometimes failed....
02:49:32 <juhp_> ManateeLazyCat: I don't really know gio well - does it use gstrings?
02:49:49 <juhp_> oh
02:50:12 <ManateeLazyCat> juhp_: It's use C string, so we need use ByteString as argument pass *raw string* that not include encoding information.
02:50:31 <juhp_> sorry I mean the C library
02:50:49 <ManateeLazyCat> juhp_: Because GTK+ input always UTF8, so i use Data.ByteString.UTF8.fromString convert UTF8 String to ByteString, then pass to gio APIs.
02:51:06 <juhp_> ok
02:51:14 <juhp_> ManateeLazyCat: all the paths are ascii?
02:51:30 <ManateeLazyCat> juhp_: It use 'const char *path'
02:51:34 <ManateeLazyCat> juhp_: Yes,
02:51:42 <ManateeLazyCat> juhp_: Maybe i do something wrong?
02:52:12 <juhp_> and debug output is ok?
02:52:51 <juhp_> dunno :)  just trying to ask some questions hoping it might help :)
02:53:14 <ManateeLazyCat> juhp_: Example, I type root directory "/", should display sub-directories/files under "/", strange is, sometimes can work, sometimes can't work.
02:53:16 <juhp_> I haven't pulled today...
02:53:26 <ManateeLazyCat> juhp_: I hope i can understand it deeply after talk those.
02:53:36 <ManateeLazyCat> juhp_: No, in my local repository, haven't push.
02:53:37 <juhp_> i see
02:54:12 <ManateeLazyCat> juhp_: When i use String and withCString in GIO bidning, works fine.
02:54:17 <juhp_> so unsafeUseAsCString is working differently?
02:54:35 <ManateeLazyCat> juhp_: unsafeUseAsCString convert ByteString to CString.
02:54:42 <juhp_> and what is wrong with withCString? :)
02:54:47 <juhp_> ah
02:55:28 <chrisdone> Gracenotes: hey man any change of doing something like this on the new Hackage? http://gist.github.com/raw/463423/f8458d83b1a7cc26cdbf812747188993e50cd8a2/The%20Haskell%20module%20landscape
02:55:32 <ManateeLazyCat> juhp_: When your locale is UTF8 everything is fine, but when you locale is ASCII or other encoding that different with your file, withCString  will *cut* filepath.
02:55:49 <chrisdone> er, chance
02:56:52 <juhp_> chrisdone: you mean for docs?
02:57:04 <chrisdone> for browsing the module list
02:57:19 <chrisdone> sometimes I'd prefer to browse by the module hierarchy than package names
02:57:58 <juhp_> chrisdone: they would link to ?
02:58:19 <chrisdone> the documentation page
02:58:24 <ManateeLazyCat> juhp_: Simple, withCString will convert from Haskell String (Unicode) to your current locate.
02:58:30 <juhp_> chrisdone: cool
02:58:37 <ManateeLazyCat> juhp_: When you locate is UTF8, everything is fine.
02:58:57 <juhp_> ManateeLazyCat: hmm
02:59:26 <EnglishGent> hello :)
02:59:27 <ManateeLazyCat> juhp_: So Axel suggest me use ByteString instead String, but ... you know... I'm crashing....
02:59:41 <ManateeLazyCat> EnglishGent: Hey, how do you do?
03:00:06 <juhp_> ManateeLazyCat: hm
03:00:47 <EnglishGent> hello ManateeLazyCat :)
03:00:53 <EnglishGent> not too bad - you? :)
03:01:05 <ManateeLazyCat> EnglishGent: Bad luck today. :(
03:01:28 <EnglishGent> oh, I'm sorry to hear that
03:01:31 <EnglishGent> how come? :|
03:01:44 <ManateeLazyCat> EnglishGent: Bad luck on gtk2hs developing. :(
03:02:05 <ManateeLazyCat> juhp_: If everyone use UTF8 locate, i don't need ByteString crap. :)
03:02:20 <juhp_> ManateeLazyCat: nearly everyone does
03:02:52 <ManateeLazyCat> juhp_: AFAIK, Windows Chinese version use GB2312
03:03:23 <juhp_> ManateeLazyCat: older windows?
03:03:37 <ManateeLazyCat> juhp_: Windows XP.
03:03:44 <juhp_> ok
03:03:45 <ManateeLazyCat> juhp_: Windows 7 use Unicode ?
03:03:56 <juhp_> I would think so
03:04:01 <juhp_> Vista too I should think
03:04:11 <juhp_> but i am not a windows user...
03:04:57 <ManateeLazyCat> juhp_: Most complicated situation is *mix encoding path*.....
03:05:02 <juhp_> ManateeLazyCat: honestly at this stage I don't feel it is worth worrying too much about non-utf8
03:05:02 <EnglishGent> what's the problem ManateeLazyCat? 
03:05:46 <juhp_> ManateeLazyCat: you mean file-names in different encoding?
03:06:02 <juhp_> yeah that is not good
03:06:19 <ManateeLazyCat> juhp_: Example, you have path "Foo/Bar.txt", Foo maybe Encoding A, and Bar.txt is Encoding B.
03:06:33 <juhp_> ManateeLazyCat: basically you lose :)
03:07:08 <juhp_> hmm never thought of multi-encoding strings
03:07:13 <ManateeLazyCat> juhp_: Best solution, is use *raw string* as low-level filepath, just decode those Jwhen you need displaying in UI>
03:07:53 <ManateeLazyCat> juhp_: So i want refactory manatee use ByteString as filepath and don't care encoding problem, just decode ByteString when i need display it.
03:07:57 <juhp_> I like my file and dirs in ascii... but maybe I am biased :)
03:08:10 <juhp_> ok
03:10:24 <jaspervdj> chrisdone: I'm porting formlets to blaze-html so you won't need both xhtml and blaze in the future
03:11:19 * ManateeLazyCat pasted "gio test code." at http://paste2.org/get/1004286
03:11:20 <ManateeLazyCat> juhp_: Example, i use above test code, always right, but when i running those code in manatee, failed.
03:11:56 <ManateeLazyCat> juhp_: Only different is above code is use 'let xx = "/"', and my string is get from GtkEntry....
03:13:20 <juhp_> ManateeLazyCat: and what do you get from GtkEntry?
03:13:51 <ManateeLazyCat> juhp_: String, 
03:16:12 <ManateeLazyCat> juhp_: The return of GtkEntry is Haskell String with UTF8 encoding.
03:16:50 <juhp_> ManateeLazyCat: but it doesn't work, right?
03:16:55 <wjt> ManateeLazyCat: i think there's a glib function to convert between UTF-8 and your filesystem's encoding
03:17:34 <ManateeLazyCat> wjt: But you need know the encoding of file first, right?
03:17:55 <wjt> i think glib assumes your filename encoding matches your locale
03:17:58 <ManateeLazyCat> juhp_: Strang is sometimes can work, sometimes can't work.... :(
03:18:04 <wjt> i can't find the conversion functions now though
03:18:46 <ManateeLazyCat> wjt: Example, your locate is UTF8, how do you handle file with non-UTF8 encoding?
03:19:10 <wjt> not the file's contents, the file names
03:19:28 <juhp_> yes
03:19:30 <ManateeLazyCat> wjt: Yes, i talk file name.
03:20:07 <juhp_> ManateeLazyCat: does debug output help to see when it is failing?
03:20:14 <wjt> i think the argument is basically that you're not meant to get filenames from gtkentries
03:20:19 <wjt> you should use a file chooser widget
03:20:40 <juhp_> true
03:20:52 <ManateeLazyCat> juhp_: Same input have different output.
03:21:01 <juhp_> ah
03:21:16 <ManateeLazyCat> juhp_: That's confuse me. :(
03:21:36 <juhp_> ManateeLazyCat: is it some pointer/length off-by-one issue?
03:21:49 <juhp_> ManateeLazyCat: how are they different?
03:21:58 <ManateeLazyCat> wjt: I think it't not care file chooser widget.
03:25:14 <ManateeLazyCat> juhp_: I dunno....
03:27:02 <ManateeLazyCat> juhp_: I give up now, and have a rest, hope i can find where the problem later. :)
03:27:15 <ManateeLazyCat> juhp_: Thanks for talk.... :)
03:28:37 <ManateeLazyCat> Dinner time.
03:42:11 <ManateeLazyCat> juhp_: What's plan after release first version?
03:42:25 <ManateeLazyCat> juhp_: I will focus on framework and editor.
03:48:55 <Nibble> In other news, fglrx works with xorg 1.9
04:24:21 <ManateeLazyCat> Any trick with unsafeUseAsCString? Same code logic, i got different result with different time.
04:30:43 <Ekenstein> Hi, could someone help me with a small typedefinition problem. Here is the code: http://pastebin.com/rca1vTRU and here's the error I get when I try to compile http://pastebin.com/byE3EbuX I have no idea how to solve the problem really
04:32:23 <twanvl> Ekenstein: your Square type is 'Maybe Stone'. You are forgeting about the Maybe part, and treating it as if it was just 'Stone'
04:34:37 <Ekenstein> Ye, that's the thing I've been thinking about. But I don't know how I should treat it as a Maybe Stone. I've tried to add Maybe, but then it complains the the Stone datatype doesn't have a Maybe constructor.
04:35:42 <twanvl> 'Maybe Stone' has two constructors, 'Nothing' and 'Just x', where x is some Stone value in this case
04:37:20 <Ekenstein> Ah, I think I've solved it. Just to add Maybe in front of Stone in the typedefinition of the function. Now I am one step further, thanks :]
04:38:02 <Lemmih> Ekenstein: That's not really the right fix.
04:38:11 <Ekenstein> oh :0
04:39:13 <Lemmih> Ekenstein: It would make the name of the function somewhat misleading. 'addStone' could also be used to remove a stone.
04:40:01 <Ekenstein> hehe, ye, you're right.
04:45:13 <kmc> add an un-stone
04:45:29 <Ekenstein> but let's say that I would want the function to just be able to add a stone to the board, what is the right fix? Cause there would obviously be problems when I check whether I place a stone on top of another stone and such
04:45:41 <Ekenstein> with the current solution
04:46:57 <Lemmih> Ekenstein: You could write '(c, Just i)' instead of '(c, i)'.
04:47:22 <Ekenstein> ah
04:49:31 <Ekenstein> Nice, it works :) Thanks
04:53:03 <ManateeLazyCat> juhp_: I fix it, do you want know why?
04:53:14 <juhp_> ManateeLazyCat: sure
04:53:49 <ManateeLazyCat> juhp_: Is unsafeUseAsCString
04:54:28 <ManateeLazyCat> juhp_: unsafeUseAsCString share *same pointer* between ByteString and low-level CString.
04:54:35 <juhp_> ah
04:54:54 <ManateeLazyCat> juhp_: Once you change ByteString or CString, them will change each other.
04:55:09 <juhp_> ok hm
04:55:28 <ManateeLazyCat> juhp_: Then result is, when referential break, my code can't work.
04:55:47 <juhp_> I see right
04:55:54 <ManateeLazyCat> juhp_: Use useAsCString re-implement gtk2hs, problem fix.
04:55:56 <juhp_> is it a bug
04:56:26 <ManateeLazyCat> juhp_: I plan to give up if this change can't work.
04:56:32 <juhp_> ok
04:56:55 <ManateeLazyCat> juhp_: Happy now, if all test pass, i will push new patches to gio and manatee.
04:57:03 <juhp_> :)
04:57:25 <ManateeLazyCat> juhp_: Then I won't change code of 'gio' and 'gtk', you will got solid base to develop manatee. :)
04:59:28 <juhp_> cool
05:00:21 <ManateeLazyCat> juhp_: After push new patches, i will add "interactive" (like Emacs's) for interactive input, and customize-system.
05:00:22 <ManateeLazyCat> juhp_: Then we release first version.
05:00:24 <juhp_> I spent yesterday working on adding ghc-pkg hash metadata to fedora haskell packages
05:00:36 <juhp_> aha wow
05:01:01 <ManateeLazyCat> juhp_: Hot-Swapping is cool, but i want test more.
05:01:17 <ManateeLazyCat> juhp_: I perhaps won't merge Hot-Swapping technology in manatee.
05:01:22 <ManateeLazyCat> in near future.
05:01:38 <juhp_> ManateeLazyCat: hotswap means plugin?
05:01:57 <ManateeLazyCat> @package pdynload
05:01:57 <lambdabot> http://hackage.haskell.org/package/pdynload
05:02:01 <ManateeLazyCat> juhp_: ^^^^
05:02:15 <juhp_> aha
05:02:38 <ManateeLazyCat> juhp_: Infact, i have try play some plugins framework before.
05:02:49 <ManateeLazyCat> juhp_: Like, running framework always,
05:02:50 <juhp_> I see
05:02:59 <juhp_> have you seen the new plugins package?
05:03:10 <juhp_> aha
05:03:12 <ManateeLazyCat> juhp_: When we update module's code, then new processes will apply new version.
05:03:24 <juhp_> nice
05:05:15 <ManateeLazyCat> juhp_: And existing process use old version.
05:05:15 <ManateeLazyCat> juhp_: Then we can update manatee when it running.
05:05:15 <ManateeLazyCat> juhp_: This technological maybe not most cool, but is safest solution.
05:05:15 <ManateeLazyCat> juhp_: I haven't see.
05:05:15 <ManateeLazyCat> juhp_: But i think my pdynload is enough for my need.
05:05:16 <ManateeLazyCat> juhp_: Just need improve some code.
05:05:17 <ManateeLazyCat> juhp_: Example, we use pdynload in entry Manatee/Manatee.hs .
05:05:23 <ManateeLazyCat> juhp_: But old code still running in old process.
05:05:45 <juhp_> ok
05:05:55 <ManateeLazyCat> juhp_: I have thinking update current process in runtime 
05:06:08 <ManateeLazyCat> juhp_: But this way maybe dangerous when some complicate update.
05:06:36 <ManateeLazyCat> juhp_: So i plan add simple plugins system in first version, add smarter one after test completely.
05:06:36 <juhp_> yeah
05:07:31 <ManateeLazyCat> juhp_: Then you change you option in customize-system, and see the result and don't need restart all modules.
05:07:34 <juhp_> ManateeLazyCat: plugin would be a manatee module or something else?
05:07:46 <ManateeLazyCat> juhp_: I think pdynload will.
05:07:59 <ManateeLazyCat> package pdynload use GHC API 
05:08:05 <dom96> hey ManateeLazyCat, how's your IRC Client coming along?
05:08:28 <ManateeLazyCat> dom96: Most features have finish.
05:08:40 <dom96> awesome
05:08:42 <ManateeLazyCat> juhp_: don's plugins not use GHC APIs, 
05:08:50 <ManateeLazyCat> dom96: http://www.flickr.com/photos/48809572@N02/
05:09:03 <juhp_> no?
05:09:25 <juhp_> well I haven't used either...
05:09:46 <ManateeLazyCat> juhp_: dons' plugins early than GHC APIs.
05:10:07 <juhp_> ManateeLazyCat: but it has been updated this week i think
05:10:16 <ManateeLazyCat> dom96: My irc client include "Multi-Language Chat system", you can type your mother language, and convert to English and send to IRC server.
05:10:18 <juhp_> by TacticalGrace
05:10:43 <juhp_> anyway I just mentioned it
05:10:44 <ManateeLazyCat> juhp_: Infact, i try to fix plugins before develop pdynload
05:10:52 <dom96> macool
05:11:08 <dom96> * ManateeLazyCat 
05:11:17 <ManateeLazyCat> dom96: Infact, you can type any language, automatic detect language.
05:11:24 <ManateeLazyCat> dom96: Wait.
05:12:06 <ManateeLazyCat> juhp_: Do you have any plan about manatee? After release first version?
05:12:38 <manateeUser> dom96: How are you? (Translate by Google)
05:12:46 <ManateeLazyCat> dom96: ^^^ Chinese translation
05:12:57 <dom96> awesome.
05:13:13 <manateeUser> 你好吗？
05:13:22 <ManateeLazyCat> dom96: ^^^ English translation
05:13:43 <ManateeLazyCat> dom96: Use my GoogleTranslate package.
05:13:47 <ManateeLazyCat> @package GoogleTranslate
05:13:47 <lambdabot> http://hackage.haskell.org/package/GoogleTranslate
05:13:50 <ManateeLazyCat> dom96: ^^^^
05:14:12 <dom96> ooh nice. I might include that in my IRC Bot :P
05:14:34 <ManateeLazyCat> dom96: Just use my GoogleTranslate, pretty simple APIs. :)
05:14:44 <dom96> indeed i will :)
05:14:48 <juhp_> juhp_: sure mostly "bug fixes" and improvements I guess :)
05:15:09 <ManateeLazyCat> juhp_: I will fix most bugs before release first version.
05:15:12 <dom96> i'm working on a cool Google Chrome-like plugin system.
05:15:29 <juhp_> ManateeLazyCat: well we see different bugs :)
05:15:29 <dom96> for my IRC Bot
05:15:30 <ManateeLazyCat> juhp_: I will focus my time on framework and editor.
05:15:37 <ManateeLazyCat> juhp_: Hehe :)
05:15:39 <jem777> is -XTypeSynonymInstances consided bad style?
05:15:56 <Heffalump> I think it is
05:15:56 <lambdabot> Heffalump: You have 1 new message. '/msg lambdabot @messages' to read it.
05:15:57 <ManateeLazyCat> dom96: Why not improve Haskell browser in my project?
05:16:37 <ManateeLazyCat> juhp_: In manatee-0.0.2, you will see "code completion" and "code snippets" in manatee-editor. :)
05:16:45 <juhp_> great
05:16:58 <ManateeLazyCat> juhp_: "Code completion" like Eclipse, "code snippets" like TextMate.
05:17:07 <dom96> ManateeLazyCat: I have way too many projects on my hands already. And school, so i don't really have enough time.
05:17:08 <juhp_> sounds nice :)
05:17:08 <ManateeLazyCat> juhp_: I perhaps just focus on C and Haskell first.
05:17:27 <ManateeLazyCat> juhp_: Then other people will support any language with my framework. :)
05:17:52 <ManateeLazyCat> dom96: Like juhp_, just write three lines when you boring. :)
05:17:53 <juhp_> Haskell will be good anyway :)
05:18:11 <dom96> ManateeLazyCat: heh, i'll think about it :P
05:18:19 <ManateeLazyCat> juhp_: I hope bring fascinating IDE for haskeller. :)
05:18:34 <ManateeLazyCat> juhp_: Use we own IDE that written by Haskell. :)
05:20:12 <ManateeLazyCat> juhp_: Most important is, after gtk2hs-0.12.0, i won't add new code in gtk2hs until GTK+ 3.0 release.
05:20:23 <ManateeLazyCat> juhp_: Then focus all my time on manatee. :)
05:20:47 <juhp_> ManateeLazyCat: great :-)
05:21:41 <ManateeLazyCat> juhp_: Do you old glib and gtk+?
05:22:09 <juhp_> ManateeLazyCat: sorry?
05:22:17 <juhp_> use?
05:22:27 <ManateeLazyCat> juhp_: We want someone help me test gtk2hs with glib-2.16 or older.
05:22:32 <juhp_> ah
05:22:44 <ManateeLazyCat> juhp_: Now gio just can compile from glib-2.18 to glib-2.24
05:22:57 <ManateeLazyCat> juhp_: It's okay if you haven't time, just ask. :)
05:23:40 <juhp_> Fedora 9, hmm
05:24:15 <ManateeLazyCat> juhp_: Most problem, lost #ifdef ... version ... #endif wrap new APIs.
05:24:49 <juhp_> can it build with ghc-6.8.3?
05:25:03 <ManateeLazyCat> juhp_: I dunno, perhaps can.
05:25:12 <ManateeLazyCat> juhp_: We have test from 6.10.xx to 6.12.xx
05:25:13 <juhp_> I could try sometime I guess
05:25:20 <juhp_> ok
05:25:22 <ManateeLazyCat> juhp_: Thanks a lots. :)
05:25:51 <ManateeLazyCat> juhp_: After Axel fix "IO Pixbuf" problem, we can release gtk2hs-0.12.0 since i have fix gio ByteString problem. :)
05:26:02 <juhp_> cool
05:26:30 <ManateeLazyCat> juhp_: Do you found manatee eat your memory when you use manatee-imageviewer? ;p
05:27:00 <ManateeLazyCat> juhp_: Any "IO Pixbuf" operation will cause memory leak, include next/previous image, rotate image.....
05:27:10 <juhp_> ah - I haven't used the imageviewer that much
05:27:16 <juhp_> oops
05:27:28 <juhp_> :)
05:27:49 <ManateeLazyCat> juhp_: manatee will free your memory after you close tab. :)
05:28:01 <ManateeLazyCat> juhp_: More tips see keymap of manatee-imageviewer. :)
05:28:09 <juhp_> :)
05:28:42 <ManateeLazyCat> juhp_: Maybe we can develop twitter client? :)
05:28:45 <juhp_> looking forward to doing some more hacking on it soon
05:28:57 <juhp_> ManateeLazyCat: yes!  was thinking that too
05:29:11 <juhp_> I think writing a twitter client is quite interesting
05:29:14 <ManateeLazyCat> juhp_: Then we can bla bla bla . :)
05:29:19 <juhp_> lol
05:29:39 <juhp_> yeah who needs irc when one can tweet ;o)
05:30:04 <ManateeLazyCat> juhp_: My irc client is cool too. :)
05:30:17 <juhp_> yeah
05:30:25 <juhp_> ManateeLazyCat: how about commands? :)
05:30:36 <ManateeLazyCat> juhp_: Maybe we can integrate GoogleTranslate in twitter client? :)
05:30:45 <juhp_> yes
05:32:09 <ManateeLazyCat> juhp_: I want add some "Google Instant" feature in manatee-anything.
05:32:19 <ManateeLazyCat> juhp_: Example, when you use manatee-anything search buffer list.
05:32:37 <ManateeLazyCat> juhp_: It will show buffer with current window when you dely 1 seconds.
05:32:49 <ManateeLazyCat> juhp_: Then you can search faster. :)
05:32:57 <juhp_> aha
05:33:15 <ManateeLazyCat> juhp_: Some more idea, like generic-package-system, cross Debian and Fedora.
05:33:19 <juhp_> direct websearch would be nice too
05:33:34 <ManateeLazyCat> juhp_: When you type package name, it will display package description and other information.
05:33:40 <juhp_> aha
05:33:53 <juhp_> yes
05:34:15 <ManateeLazyCat> juhp_: When you type RETURN, it install/uninstall in temrinal. :)
05:34:28 <juhp_> if we design it well manatee can be really useful and powerful :)
05:34:35 <ManateeLazyCat> juhp_: Yes.
05:34:54 <ManateeLazyCat> juhp_: My idea for manatee-anything let search everything for user.
05:35:01 <ManateeLazyCat> juhp_: And smart parse user's need.
05:35:24 <ManateeLazyCat> juhp_: Like type "Jens" will show your information, and type RETURN will send mail/twitter/irc  to you. :)
05:35:35 <juhp_> ManateeLazyCat: btw did you think about making modules into programs instead of libraries or you plan to use plugins for that?
05:35:39 <juhp_> ambitious
05:35:50 <juhp_> but yes
05:36:16 <ManateeLazyCat> juhp_: I plan build manatee-minimal that just need gtk2hs.
05:36:30 <ManateeLazyCat> juhp_: Then integrate pdynload with Manatee/Manatee.hs
05:36:46 <ManateeLazyCat> juhp_: After you install some package by Cabal, it will update Manatee.hs
05:37:04 <ManateeLazyCat> juhp_: Then you can type some keystroke to start new module and dnon't need restart manatee.
05:37:07 <juhp_> just thought nice if one can run say "manatee-edit mytext.file" to open a file
05:37:12 <ManateeLazyCat> juhp_: If new module crash, just close tab.
05:37:17 <juhp_> ok
05:37:21 <ManateeLazyCat> juhp_: It's easy.
05:37:32 <ManateeLazyCat> juhp_: I just need expose manatee's DBus interface.
05:37:38 <juhp_> right
05:37:57 <ManateeLazyCat> juhp_: If you research manatee's source code deeply, you will found all new module/process is starting by DBus message.
05:38:09 <juhp_> ok
05:38:26 <juhp_> I didn't get there yet :)
05:40:35 <ManateeLazyCat> juhp_: Example, when you press "M-m" on manatee-filemanager, it will send open file DBus message to daemon process.
05:40:55 <ManateeLazyCat> juhp_: Daemon process will call corresponding sub-module to open file
05:41:10 <ManateeLazyCat> juhp_: Such as, manatee-pdfviewer for pdf file, manatee-imageviewer for image....
05:41:47 <juhp_> right.  how about having editor process, irc process, pdf process, etc?
05:42:39 <ManateeLazyCat> juhp_: Look manate-core/Manatee/Core, have two files: FileOpenRule.hs and PageMode.hs
05:43:43 <ManateeLazyCat> juhp_: If your DBus message include speical PageType, it won't search in PageMode.pageModeList
05:43:57 <ManateeLazyCat> juhp_: Look PageMode.getPageMode
05:44:32 <ManateeLazyCat> juhp_: It will open corresponding sub-module with PageType you given
05:44:51 <ManateeLazyCat> juhp_: Otherwise, it will search in pageModeList
05:45:04 <ManateeLazyCat> juhp_: Like PageEditor not in rule of getPageMode
05:45:22 <ManateeLazyCat> juhp_: It will use regexp match *extension name*, like *.hs open in HaskellMode
05:45:26 <juhp_> right I see
05:45:29 <ManateeLazyCat> juhp_: *.c will open in CMode.
05:45:46 <juhp_> sourceview ok
05:45:59 <ManateeLazyCat> juhp_: And FileOpenRule is integrate manatee sub-module with external program.
05:46:43 <ManateeLazyCat> juhp_: Like you search pdf file, and type "M-/" will list manatee-pdfviewer and other pdf viewer found in your system.
05:46:48 <juhp_> ManateeLazyCat: guess I am saying one could run say manatee-editor instead of forking manatee
05:47:06 <ManateeLazyCat> juhp_: forking manatee?
05:48:11 <ManateeLazyCat> juhp_: I don't understand
05:48:15 <juhp_> I thought there was one process per view?
05:48:32 <ManateeLazyCat> juhp_: One process per buffer.
05:48:37 <juhp_> right
05:48:46 <ManateeLazyCat> juhp_: Different view in different window share same process.
05:48:52 <juhp_> ok yes
05:49:00 <juhp_> I meant buffer
05:49:01 <ManateeLazyCat> juhp_: So memory won't increase along with *split window* command.
05:49:13 <ManateeLazyCat> juhp_: Yes, one process per buffer.
05:49:25 <juhp_> so that is done by forking, no?
05:49:39 <ManateeLazyCat> juhp_: I use runCommand
05:49:39 <dobblego> ManateeLazyCat, your GoogleTranslate code can be improved with the Either monad
05:49:42 <ManateeLazyCat> @runCommand
05:49:42 <lambdabot> Unknown command, try @list
05:49:49 <juhp_> ok
05:50:04 <juhp_> I see
05:50:07 <ManateeLazyCat> dobblego: I try to avoid use too many monad in my code. :)
05:50:32 <dobblego> er right
05:50:33 <ManateeLazyCat> juhp_: manatee is *complete* asynchronous message processes framework.
05:50:55 <ManateeLazyCat> dobblego: Too many monad make newbie hard to learn.
05:51:01 <juhp_> ManateeLazyCat: but you run manatee anyway I think :)
05:51:06 <dobblego> ManateeLazyCat, that's not true
05:51:27 <ManateeLazyCat> dobblego: Unless monad can improve current code a lot. :)
05:51:45 <dobblego> right, it can
05:51:57 <ManateeLazyCat> juhp_: So any code in manatee don't know what happened in the future for other module.
05:52:14 <juhp_> dobblego: perhaps you can convince him with a patch :)
05:52:27 <juhp_> right
05:52:34 <ManateeLazyCat> dobblego: Yes, patch much help, i'm so busy recently. :)
05:52:56 <dobblego> I didn't think it would be this controversial :)
05:53:22 <juhp_> ManateeLazyCat: so you could run manatee-editor instead of linking manatee-editor to main program?
05:53:30 <juhp_> dobblego: nod
05:53:46 <ManateeLazyCat> Damn unsafeUseAsCString waste all day...
05:54:08 <ManateeLazyCat> juhp_: Yes, i have more plan about how to split sub-module out.
05:54:59 <juhp_> ManateeLazyCat: ok
05:55:16 <ManateeLazyCat> juhp_: Like you use mouse drop tab of editor-module outside of main program, then you can got two standalone problem.
05:55:42 <ManateeLazyCat> juhp_: So vi user can just use editor, emacs user can use all system. :)
05:56:41 <ManateeLazyCat> dobblego: Thanks for your suggestion, i will consider Either monad. :)
05:57:13 <dobblego> case e of Left x -> Left x; Right y -> f y is better written e >>= f
05:57:31 <dobblego> though I suspect the Either monad is baulked iirc
05:57:43 <ManateeLazyCat> dobblego: Cool, i will improve it, thanks! :)
05:57:57 <Eduard_Munteanu> Hi.
05:58:21 * Eduard_Munteanu was just looking on Wikipedia...
05:58:31 <juhp_> ManateeLazyCat: ok
05:58:41 <Eduard_Munteanu> ... and found this C++ thingy called "concepts" that looks an awful lot like typeclasses :))
05:58:52 <Twey> They are typeclasses.
05:59:02 <Eduard_Munteanu> Ah.
05:59:32 <Twey> They nicked 'em.  C++0x also has lambdas.  ☺
05:59:50 <Twey> And a new function-type signature syntax that looks an awful lot like Haskell, IIRC.
05:59:51 <ManateeLazyCat> juhp_: Maybe someday we can build gtk2hs client, binding gtk2hs code automatically. :)
05:59:51 <boegel> what's the best place to start learning/using QuickCheck?
06:00:03 <Twey> boegel: RWH has a good chapter on it, IIRC.
06:00:08 <Eduard_Munteanu> Do they (C++) currently stand on any theory with templates/concepts, say System F?
06:00:13 <boegel> Twey: ah, it has?
06:00:15 <Eduard_Munteanu> Twey: heh, I see.
06:00:18 * geheimdienst points out that he edited http://en.wikibooks.org/wiki/Haskell/Class_Declarations a while back to point out the similarity between typeclasses and c++ concepts
06:00:41 <Eduard_Munteanu> Or are they just implementing things along?
06:01:02 <Eduard_Munteanu> geheimdienst: ah, I missed that.
06:01:21 <juhp_> ManateeLazyCat: heh, manatee app generator :)
06:01:45 <boegel> Twey: thanks
06:01:53 <mreh> what are we discussing?
06:02:09 <Eduard_Munteanu> The Haskellness of C++ :P
06:02:12 <Eduard_Munteanu> 0x.
06:02:20 <mreh> what's manatee?
06:02:31 <Twey> Eduard_Munteanu: You're kidding, right?
06:02:35 <mreh> aide from the aquatic animal
06:02:44 <Eduard_Munteanu> Yes!
06:02:59 <ville> The next C++ standard won't have concepts and concept maps.
06:03:00 <Twey> Eduard_Munteanu: C++ has never thought stuff out before implementing it.  The design process is ‘This looks cool!  Let's stick it in!’
06:03:01 <Eduard_Munteanu> Twey: well, it's also a bit unexpected of them, it surprised me.
06:03:05 <osaunders> Can anybody suggest a nice way of applying a pair of values to a pair of functions?
06:03:12 <Eduard_Munteanu> Heh.
06:03:21 <mreh> :t (***)
06:03:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:03:30 <mreh> :t uncurry (***)
06:03:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
06:03:45 <mreh> tada!
06:03:47 <Twey> Hrmph
06:04:04 <osaunders> mreh: Thanks, I'll look into that
06:04:07 <ManateeLazyCat> mreh: http://www.flickr.com/photos/48809572@N02/
06:05:27 <osaunders> (,) isn't an arrow :-(
06:05:42 <geheimdienst> @instances Arrow
06:05:42 <lambdabot> (->), Kleisli m
06:05:54 <mreh> (a,) is
06:06:06 <mreh> if a is a monoid
06:06:16 <osaunders> OK, nevermind.
06:06:30 <geheimdienst> > ((+1), (*2)) (42, 37)
06:06:31 <lambdabot>   Couldn't match expected type `t1 -> t'
06:06:31 <lambdabot>         against inferred type `(a ->...
06:06:38 <geheimdienst>  > ((+1), (*2)) *** (42, 37)
06:07:07 <geheimdienst> > ((+1), (*2)) *** (42, 37)
06:07:08 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
06:07:09 <lambdabot>    arising from a use of `Control...
06:07:20 <geheimdienst> osaunders: i see what you mean
06:07:36 <mreh> (+1) *** (*2) $ (42,37)
06:07:39 <osaunders> Yeah, dw I'm just going to declare a function. That stuff is beyond me atm.
06:07:41 <mreh> > (+1) *** (*2) $ (42,37)
06:07:42 <lambdabot>   (43,74)
06:08:12 <mreh> they're just idiomatic shorthand
06:08:14 <osaunders> > uncurry (***) $ ((+1, (*2)) $ (10, 20)
06:08:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:08:21 <geheimdienst> mreh, but that applied the 1st function to each element, and the 2nd got somehow lost ...?
06:08:26 <Twey> > uncurry (***) ((+ 1), (* 2)) (42, 37)
06:08:27 <lambdabot>   (43,74)
06:08:42 <geheimdienst> no wait. my bad
06:09:04 <mreh> geheimdienst: :)
06:09:06 <osaunders> Damn.
06:09:09 <geheimdienst> i notice. 37 is not the same as 74. gotta write that down somewhere
06:11:23 <mreh> the implementation of (***) for (->) is very easy, you could at least learn it without getting bogged down in Arrows
06:11:40 <mreh> (->) is a pure arrow anyway
06:11:43 <mreh> :t arr
06:11:44 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
06:12:01 <mreh> arr is a.k.a. pure
06:12:34 <mreh> question, how did they get away with overloading that in the new source for Arrow?
06:12:49 <mreh> I definitely saw pure as a synonym for arr
06:13:48 <ManateeLazyCat> Bye all. :)
06:15:48 <mreh> I still don't know what it is that was he was making
06:15:55 <mreh> a tiling window manager?
06:16:09 <mreh> gah, english is hard
06:16:31 <geheimdienst> mreh, yes, from what i understand. it's a window manager with browser and editor and all kinds of things integrated
06:16:35 <geheimdienst> and an irc client
06:16:41 <geheimdienst> really, i have no idea
06:17:08 <geheimdienst> it sounds impressive an ambitious, but i don't know if anybody besides himself would need this thing
06:18:19 <mreh> written in haskell?
06:18:37 <geheimdienst> yes, with a lot of gtk and dbus and things
06:19:10 <mreh> I desperately want to try an AFRP gui
06:19:32 <mreh> why throw it all away
06:20:06 <mornfall> Hm, anyone know if Max Bolingbroke appears here?
06:20:18 <mornfall> ansi-terminal is, uh, terminally broken on windows
06:22:32 <ninechars> mreh: the A stands for... ?
06:22:45 <Twey> Asynchronous?
06:22:55 <geheimdienst> Arcane
06:23:00 <Twey> Heh
06:23:09 <geheimdienst> Arhythmic
06:23:12 <ninechars> Armadillo
06:23:16 <mreh> Arrowised
06:23:22 <ninechars> ah
06:23:23 <geheimdienst> Anbelievable
06:25:33 <Eduard_Munteanu> Now really, is there any usable/documented FRP GUI toolkit out there?
06:25:58 <Eduard_Munteanu> I looked at Grapefruit some time, but apart from a few examples, it wasn't documented.
06:26:44 <mornfall> *sigh* test-framework is a pile of junk
06:28:20 <dobblego> really why
06:28:21 <dobblego> ?
06:30:39 <Heffalump> NIH? :-)
06:31:21 <geheimdienst> Not Invented on #Haskell?
06:31:27 <geheimdienst> Not Invented by Hillbillies?
06:31:56 <geheimdienst> Not Invented by Heffalump
06:32:00 <maltem> In both iteratee and enumerator, an empty chunk (or list thereof) is used to indicate that there is “no currently available data”. Does this make any sense, except to explicitly allow empty chunks?
06:32:16 <Heffalump> geheimdienst: while the latter may be true, it's probably a positive thing :-)
06:33:12 <geheimdienst> sounds like a celebrity endorsement in reverse :)
06:33:28 <Lemmih> mornfall: It's not nice to besmirch other peoples software. Especially not when you might stumble into the authors here on #haskell.
06:34:01 <geheimdienst> lemmih, probably he has some clear reasons why he doesn't like it
06:34:10 <geheimdienst> mornfall, what is the trouble with test-framework?
06:35:32 <mornfall> geheimdienst: It has a hard dependency on ansi-terminal, which makes things either segfault on windows, or in cases where not, the runners just fail with darcs-test.exe: getConsoleCursorInfo: invalid argument (Neplatn� popisova
06:35:43 <Lemmih> geheimdienst: Then he should have started with that. Name calling is never accepted, imo.
06:36:20 <mornfall> And it turns out it's a lot of work to fix, since the color stuff is threaded through a lot of code.
06:38:47 <aristid> Lemmih: it's a piece of software. i don't think it has a lot of feelings
06:39:02 <Lemmih> Err, *acceptable. Geez, I type like a rhesus monkey.
06:39:49 <mornfall> What's worse is that it still fails if you disable the colour support with --plain, and that I have been told that a patch to fix that has been submitted a fairly long while back.
06:40:03 <mornfall> To no avail.
06:40:22 <Lemmih> aristid: Every piece of software has a creator. A newborn won't care that you call it ugly but its mother might.
06:40:29 <tomberek> what is shrinking in QuickCheck?
06:40:58 <mornfall> So we now can't test darcs on windows anymore, because we foolishly went for a "standard" and "endorsed" solution (i.e. test-framework) instead of going NIH an dall.
06:41:41 <aristid> going standard would mean using git :P
06:41:56 <mornfall> Yeah, so much for besmirching other people's software.
06:42:01 <mornfall> I get this all the time (about git).
06:42:22 <Lemmih> aristid: I'm sure I'd be insulted if someone called my code a pile of junk for not working on Windows. Especially since getting things to work on Windows is so darn hard.
06:42:26 <geheimdienst> aristid, git is an overcomplicated heap of a bazillion commands with 10 bazillion strange inconsistent switches and odd defaults
06:42:43 <Eduard_Munteanu> Hey... I like Git :)
06:42:48 <aristid> geheimdienst: it's the standard!
06:42:56 <Heffalump> Lemmih: my daughter looked like the Roswell alien when she was born (and my wife thought so too)
06:43:03 <mornfall> Lemmih: Not working on windows is not *the* reason for it being a pile of junk.
06:43:08 <aristid> Eduard_Munteanu: do you feel insulted by geheimdienst? :D
06:43:25 <mornfall> Lemmih: It's the reason I had to go as far as to discover it was one.
06:43:33 <Eduard_Munteanu> Mmm, damn, I didn't write Git so I couldn't be.
06:43:34 <geheimdienst> i think the darcs people do a good job because i can use it with only the built-in help, even features i don't use daily
06:43:39 <geheimdienst> for git, that's impossible
06:44:02 <aristid> geheimdienst: huh? i only use the git builtin help, too. it's been ages since i was last on #git
06:44:14 <Heffalump> mornfall: Max is the author, right?
06:44:22 <vanadium> git is fine.
06:44:22 <Eduard_Munteanu> For Git, help and a lot of lore :)
06:44:22 <Lemmih> Heffalump: Roswell aliens are totally cute, though. (:
06:44:29 <aristid> geheimdienst: the git man pages are pretty complete :)
06:44:51 <mornfall> Heffalump: I believe so, of both test-framework, ansi-terminal and ansi-wl-pprint (which are all tied together into a knot).
06:44:56 <Heffalump> my mother-in-law didn't like the description :-)
06:44:58 <mornfall> s/both/all/
06:44:59 <geheimdienst> mornfall, what is the job of test-framework? it's the thing that runs hunit tests and quickcheck stuff, right?
06:45:32 <Heffalump> mornfall: where did you find out about the existing patch?
06:45:35 <Lemmih> tomberek: QuickCheck tries to find the simplest input that triggers a failure. It does that by shrinking.
06:45:59 <mornfall> Heffalump: Over on #darcs. Not sure who was the author, maybe sm?
06:46:09 <tomberek> Lemmih, thank, i loaded it up and played with shrinkIntegral to get the gist, thanks
06:46:56 <mornfall> It doesn't fix the segfaults, but I can work around that locally I guess.
06:56:40 <Heffalump> mornfall: it doesn't really scale properly to not rely on standard things. We should just make noise to maintainers when things don't work.
06:57:05 <Jonno_FTW> I'm doing 99 haskell problems and got to the reverse one, why doesn't this work? myReverse xs = foldr1 (++) xs
06:57:15 <mornfall> Maybe I should install git on windows so I can get that patch.
06:57:38 <Olathe> > foldr1 (++) [1..10]
06:57:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:57:39 <lambdabot>    `GHC.Enum.Enum a'
06:57:40 <lambdabot>      a...
06:57:54 <Olathe> @type foldr1
06:57:55 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:58:00 <Olathe> @type (++)
06:58:01 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:58:08 <Olathe> Monoid? Bah!
06:58:16 <Jonno_FTW> @src foldr1
06:58:16 <lambdabot> foldr1 _ [x]    = x
06:58:16 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
06:58:16 <lambdabot> foldr1 _ []     = undefined
06:58:19 <Olathe> [a] -> [a] -> [a]
06:58:43 <Olathe> So, foldr1 (++) :: ([a] -> [a] -> [a]) -> [[a]] -> [a], right?
06:58:49 <Jonno_FTW> yep
06:58:59 <Olathe> But the list you put in is [a], not [[a]].
06:59:15 <Heffalump> foldr1 (++) :: [[a]] -> [a]
06:59:25 <Olathe> Ahh, right, sorry :)
06:59:31 <hpc> > foldr1 [[1,2],[3,4]]
06:59:32 <lambdabot>   Couldn't match expected type `a -> a -> a'
06:59:32 <lambdabot>         against inferred type `[...
06:59:36 <Olathe> So, you need a function that is (a -> a -> a)
06:59:39 <hpc> > foldr1 (++) [[1,2],[3,4]]
06:59:42 <lambdabot>   [1,2,3,4]
06:59:50 <hpc> > join [[1,2],[3,4]
06:59:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:59:52 <hpc> > join [[1,2],[3,4]]
06:59:53 <lambdabot>   [1,2,3,4]
07:00:27 <Olathe> Wait, that's not right.
07:00:33 <Jonno_FTW> i need to reverse
07:00:58 <Jonno_FTW> I just wanted to use the right fold 
07:01:12 <Olathe> If (++) :: ([a] -> [a] -> [a]), then foldr1 (++) :: [[a]] -> [a], which isn't what you want.
07:01:21 <Olathe> But, what do you want?
07:01:25 <Olathe> You want [a] -> [a]
07:01:32 <Jonno_FTW> yes
07:01:36 <Olathe> But foldr1 can't do that.
07:01:43 <Jonno_FTW> good point
07:01:44 <hpc> > let reverse' (x:xs) = reverse' xs ++ [x]; reverse' [] = [] in reverse' [1,2,3]
07:01:45 <lambdabot>   [3,2,1]
07:01:50 <Olathe> It always does [a] -> a
07:01:54 <Olathe> Bah
07:02:12 <mornfall> Oh well, let's forget testing on windows. I am not going to install git on that machine.
07:02:17 <Olathe> Yeah, that's right.
07:02:28 <Olathe> So, you can't have a list going to a list.
07:02:34 <Heffalump> mornfall: you _could_ copy around source trees..
07:02:40 <Olathe> So, foldr1 can't be used for reverse.
07:02:46 <Heffalump> but please, do actually email the maintainer to prod him about this..
07:02:55 <Jonno_FTW> there must be a way
07:03:10 <Olathe> Jonno_FTW: You can use foldr
07:03:16 <Olathe> @type foldr
07:03:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:03:23 <Heffalump> Jonno_FTW: foldr1 is a bad choice because it doesn't work on empty lists anyway
07:03:27 <Olathe> It can go [a] -> [a] if b is a
07:03:31 <Olathe> If b is [a]
07:03:40 <Jonno_FTW> :t foldr
07:03:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:04:37 <Jonno_FTW> @src foldr
07:04:37 <lambdabot> foldr f z []     = z
07:04:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:04:57 <Olathe> Sorry, my brain is a bit worn out right now :)
07:05:56 <boegel> does anyone know what sorting algorithm sortBy uses?
07:06:12 <Jonno_FTW> boegel: have you read the source?
07:06:16 <boegel> and if it's efficient at all for reasonable small lists (100s) that are semi-sorted already?
07:06:18 <Jonno_FTW> I recall it being merge sort
07:06:24 <boegel> Jonno_FTW: I have to admit, no
07:06:33 <Jonno_FTW> it says in the comments of the source
07:06:37 * boegel dives into the sourc
07:06:39 <boegel> *source
07:09:10 <boegel> it's mergesort, indeed, but it used to be quicksort
07:09:20 <boegel> I wonder what would be better for my particular case
07:09:52 <Jonno_FTW> how large will your data set be?
07:10:22 <Jonno_FTW> and to what degree is it already sorted?
07:10:47 <boegel> Jonno_FTW: typically, it consists of a part that's already sorted at the head, followed by new entries that need to be sorted in
07:11:03 <boegel> Jonno_FTW: typically, a couple of 100 items, up to maybe 1000 orso
07:11:46 <Jonno_FTW> I don't think algorithm choice will really play much of a roll in the speed
07:11:56 <Jonno_FTW> unless it is a bottleneck in your program
07:12:50 <boegel> Jonno_FTW: I think it is
07:13:05 <boegel> haven't profiled yet though, but I'm sorting these kinds of lists a lot
07:40:55 <applicative> Saizan, how do I over ride the ?   I want them to Foo_bindir variables in Paths_Foo
07:42:59 <applicative> its Foo_datadir thats the trouble.  The built executable itself looks to that path for templates so it can tell e.g. what latex header to use
07:49:16 <Saizan> applicative: if you know what directories to use at configure time you can also override datadir at that point
07:49:34 <Saizan> applicative: with --datadir=
07:53:38 <applicative> yeah, i'm trying to get it, the trouble is it needs to be a relative path, since the point is to distribute the binary 'app'
07:54:37 <applicative> cabal is using the data dir to figure out where to put things, but it is also getting written into the exectutable. 
07:55:50 <kaja> hello haskell people. is development time for a competent haskell programer more or less than for a python programmer?
07:56:09 <kaja> vague question, i know
07:56:22 <danharaj> development time is probably slightly longer
07:56:27 <danharaj> debug time is significantly shorter
07:56:45 <Saizan> applicative: i think the only way to get it to be relocatable is to use the getFooDir functionality, but dcoutts_ might know better
07:58:46 <applicative> Saizan, i see.  i noticed something that was doing the equivalent of what cabal-macosx does -- the tutorial wxhnotebook editor -- I think it uses "FindBin" or something, to inform the executable of its own location 
08:00:38 <applicative> there doesnt seem to be a lot of material around about making complete relocatable things for haskell.   leksah has downloadable binaries, but uses a different system.
08:00:42 <geheimdienst> kaja, i agree iwth danharaj. my feeling is that in haskell, it's hard to get anything to compile, but once it does, it rarely has much bugs in it anymore
08:01:23 * hackagebot functional-arrow 0.0 - Combinators that allow for a more functional/monadic style of Arrow programming  http://hackage.haskell.org/package/functional-arrow-0.0 (HenningThielemann)
08:08:30 <portnov> @src intercalate
08:08:30 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
08:08:44 <portnov> @src intersperse
08:08:44 <lambdabot> intersperse _   []     = []
08:08:44 <lambdabot> intersperse _   [x]    = [x]
08:08:44 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
08:09:00 <geheimdienst> > intercalate "x" "lolcat"
08:09:01 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:09:01 <lambdabot>         against inferred ty...
08:09:22 <Twey> > intersperse "x" "lolcat"
08:09:23 <geheimdienst> > intercalate 'x' "lolcat"
08:09:23 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:09:23 <lambdabot>         against inferred ty...
08:09:24 <lambdabot>   Couldn't match expected type `[a]'
08:09:24 <lambdabot>         against inferred type `GHC.Types...
08:09:27 <Twey> Eh
08:09:38 <Twey> I can never remember which way around all these go
08:09:48 <geheimdienst> lol. the god of haskell is not pleased with us today
08:09:57 <Twey> > intersperse 'x' "lolcat"
08:09:58 <lambdabot>   "lxoxlxcxaxt"
08:10:27 <Twey> intercalate = concat . intersperse, I think
08:10:51 <Twey> Well, fmap concat . intersperse
08:11:14 <geheimdienst> > intercalate " " ["lol", "cat"]
08:11:15 <lambdabot>   "lol cat"
08:11:18 <geheimdienst> there we go
08:11:48 <geheimdienst> it's for list-of-strings kind of situations
08:26:47 <nlogax> is patch-tag down?
08:27:15 <nlogax> > unwords ["lol", "cat"] -- too
08:27:16 <lambdabot>   "lol cat"
08:45:09 <Raghs> let's say i have a list [1..20] starting from 10, how can i get the average of the last 10 elements?
08:46:08 <mornfall> ragloublog: [1..20] starting from 10?
08:46:12 <mornfall> Hm.
08:46:16 <mornfall> Sorry mistab.
08:46:19 <mornfall> Raghs: ^
08:47:04 <Raghs> need a 10-element average
08:47:09 <geheimdienst> > drop 10 [40..60]
08:47:10 <lambdabot>   [50,51,52,53,54,55,56,57,58,59,60]
08:47:41 <twanvl> > let mean xs = realToFrac (sum xs) / realToFrac (length xs) in  (mean . drop 10) [1..20]
08:47:42 <lambdabot>   15.5
08:48:59 <Raghs> twanvl -> how about the averages of 11,12 etc.. need a sliding window or moving average over 10 elements
08:49:43 <twanvl> if you need a 10 element sliding window of averages I would do something like
08:50:18 <Heffalump> depends if you want fast or elegant :-)
08:51:44 <Raghs> Integer -> [Double] -> [(Double,Doube)]  where integer is the length of the sliding window  
08:52:11 <benmachine> Doubles suck
08:52:13 <benmachine> Rational ftw
08:54:05 <twanvl> why the pair output?
08:54:15 <twanvl> > let cumSums = scanl (+) 0; windowSums k xs = let ys = cumSums xs in zipWith (-) (drop k ys) ys; windowMeans k = map (\s -> realToFrac s / realToFrac k) . windowSums k  in windowMeans 10 [1..20]
08:54:16 <lambdabot>   [5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5]
08:56:18 <Raghs> twanvl -> need the pair, to keep track of the average for the element
08:56:41 <Raghs> will be using to plot a chart
08:57:06 <twanvl> but what do the elements of the pairs mean? One is the mean value in the window, but what is the other?
08:57:21 <ddarius> > let iir as bs xs = ys where ys = map (const 0) bs ++ zipWith (+) (map (sum . zipWith (*) as) (tails xs)) (map (sum . zipWith (*) bs) (tails ys)) in iir [1] [0.9] (1:repeat 0)
08:57:22 <lambdabot>   [0.0,1.0,0.9,0.81,0.7290000000000001,0.6561000000000001,0.5904900000000002,...
08:57:30 <Raghs> stock price and average is a good example
08:58:07 <Raghs> twanvl -> price of the stock on a day and it's 10-day moving average..
08:58:22 <benmachine> ah
08:59:19 <twanvl> you could use zip to combine the averages with the prices
09:03:55 <ddarius> > let iir as bs xs = ys where ys = map (const 0) bs ++ zipWith (+) (map (sum . zipWith (*) as) (tails xs)) (map (sum . zipWith (*) bs) (tails ys)) in iir [1] (replicate 9 0:[-1]) [1..20]
09:03:55 <lambdabot>   No instances for (GHC.Num.Num [t], GHC.Enum.Enum [t])
09:03:56 <lambdabot>    arising from a use...
09:04:21 <ddarius> > let iir as bs xs = ys where ys = map (const 0) bs ++ zipWith (+) (map (sum . zipWith (*) as) (tails xs)) (map (sum . zipWith (*) bs) (tails ys)) in iir [1] (replicate 9 0++[-1]) [1..20]
09:04:22 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,-10]
09:05:42 <ddarius> > let iir as bs xs = ys where ys = map (const 0) bs ++ zipWith (+) (map (sum . zipWith (*) as) (tails xs)) (map (sum . zipWith (*) bs) (tails ys)) in iir [1] (1:replicate 8 0++[-1]) [1..20]
09:05:44 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,1,1,2,2,3,3,4,4,5,5,7,6,9,7,11,8,13,9,15,10,-3]
09:06:26 <dom96> is there a way i can the PID of a process when i create a process using runInteractiveProcess ?
09:06:33 <dom96> *can get
09:07:52 <benmachine> dom96: what do you want it for? you can already kill processes using the ProcessHandle
09:08:12 <benmachine> dom96: I have a vague suspicion that PIDs are a posix idea and System.Process is supposed to work on non-posix
09:08:16 <benmachine> but that could be wrong
09:08:24 <dom96> get other info about the process like memory usage.
09:08:38 <benmachine> have you considered System.Posix.forkProcess?
09:08:39 <Gracenotes> chrisdone: hey
09:08:55 <dom96> benmachine: no
09:09:09 <Gracenotes> chrisdone: I've looked into it. it would be sorting out duplicate modules, but otherwise it's just a lot of information to serve at once
09:09:17 <Gracenotes> *useful for
09:17:37 <Blkt> good evening everyone
09:18:19 <EnglishGent> hi Blkt
09:18:31 <Blkt> hi
09:25:02 <jutaro> Anyone here who knows about new cabal test suites?
09:44:19 <pozic> code.haskell.org is down?
09:45:09 <benmachine> http://downforeveryoneorjustme.com/code.haskell.org
10:01:50 <Saizan> patch-tag is down too :(
10:05:05 <pozic> cabal: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
10:05:42 <pozic> What causes this? 
10:05:52 <pozic> I didn't remove libgmp.so.3 AFAIK. 
10:05:58 * hackagebot synthesizer-llvm 0.2 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.2 (HenningThielemann)
10:06:58 <Botje> pozic: forgot to run ldconfig?
10:07:58 <pozic> Botje: why would I need to do that? 
10:08:07 <Saizan> if it's reporting an error from a ghci run then it might be the linker scripts problem
10:08:23 <pozic> ghci itself runs fine.
10:08:29 <pozic> I will just reinstall cabal. 
10:08:44 <pozic> But it shouldn't happen in the first place. Maybe statically linking something like that would be better.
10:09:10 <geheimdienst> pozic, i remember seeing errors like this ... i think it was because the OS decided to update libgmp, whatever it is. iirc i solved it by reinstalling cabal
10:09:10 <pozic> cabal probably doesn't even need libgmp3 for anything in the first place.
10:09:22 <pozic> (yes, the GHC RTS needs it)
10:09:34 <pozic> But even that could be worked around. 
10:11:41 <pozic> It seems to work. 
10:12:13 <Saizan> i guess the path simply changed then?
10:12:37 <ddarius> geheimdienst: gmp is the GNU Multiprecision library used for Integer.
10:12:38 <Saizan> you can build your ghc so that it doesn't use libgmp for Integer
10:13:26 <Saizan> i don't think there's any reasonable way to not link to gmp otherwise
10:15:51 <aristid> Saizan: but then Integer would not be unbounded?
10:16:15 <ddarius> There's a pure Haskell implementation of Integer, it's just dog slow.
10:19:39 <aristid> ah.
10:22:47 <mwc> speaking of gmp and integer, did the plan to use the OpenSSL based bignum lib ever get off the ground?
10:23:24 <pozic> Where do I get evm/libevm.a?
10:23:36 <pozic> cabal install epic
10:24:01 <geheimdienst> bignum sounds deceptively similar to bignom and reminds me that i should get some dinner ...
10:24:47 <pozic> Hmm, it seems that it should be included it the package. So it is just EPIC FAIL on the author of the epic package. 
10:25:20 <Saizan> i get it installed in the standard datadir
10:25:36 <Saizan> ~/.cabal/share/epic-0.1.5/evm/libevm.a
10:25:58 <pozic> Saizan: so, the installation works for you?
10:26:08 <ddarius> cabal install epic makes me want to write an epic poem in compile errors.
10:26:44 <Saizan> pozic: "cabal install epic" completes fine and i can run the epic executable, i've not tried feeding it any source though :)
10:26:59 <pozic> Saizan: which gcc, which platform>
10:27:02 <pozic> ?
10:27:18 <pozic> Saizan: 4.4.3/Linux x86-64 here.
10:27:27 <pozic> (ghc 6.12)
10:27:49 <pozic> cabal 0.82
10:29:36 <dmwit> > 101^2 / 100^2 / 2
10:29:37 <lambdabot>   0.51005
10:29:56 <dmwit> 0.5 * 100^2
10:30:02 <dmwit> > 0.5 * 100^2
10:30:02 <lambdabot>   5000.0
10:30:05 <dmwit> > 0.5 * 101^2
10:30:06 <lambdabot>   5100.5
10:30:17 <Saizan> pozic: http://pastebin.com/SB3zaxUx
10:30:20 <dmwit> whoops
10:31:33 <plurSKI> Quick question if anyone has a chance to answer it
10:32:32 <pozic> Saizan: some versions are different, but kind of annoying that it matters in the first place.
10:32:40 <plurSKI> I'm trying to figure out how to lift strict IO functions into the lazy IO monad
10:32:58 <plurSKI> I have something like:
10:33:13 <plurSKI> file <- Srict.readFile "foo.txt"
10:33:17 <dmwit> > 101^2 - 2 * 100^2
10:33:18 <lambdabot>   -9799
10:33:57 <plurSKI> and need to return a type IO String
10:34:14 <dmwit> > (100^2 - 9799, 101^2 - 9799)
10:34:15 <lambdabot>   (201,402)
10:34:33 <Saizan> pozic: can you paste the error you get?
10:35:11 <Saizan> or maybe nvm, if it's something C related i'd have no clue
10:35:54 <pozic> Saizan: gcc cannot find the file I referenced earlier. 
10:36:20 <pozic> Saizan: I could probably change the CCFLAGS and get it to work, but that kind of defeats the point of Hackage.
10:36:39 <pozic> Saizan: and giving advice in that only suggests that people will even use broken crapware. 
10:37:00 <pozic> Saizan: there are other packages with similar features, I will just use/study those. 
10:43:04 <Saizan> pozic: i know your stance on things that don't build, it was more curiosity, since i can't see why gcc should look for that file from my log.
10:47:33 <ebyrob> I have a stupid question about IO monads if anyone has a minute...  can't unbox IO ExitCode
10:47:37 <pozic> Saizan: I also don't really see why cabal rebuilds lots of modules for nothing, but maybe that's because ghc has other issues. 
10:47:49 <pozic> Saizan: setup: evm/libevm.a: does not exist
10:47:51 <Twey> ebyrob: Don't try
10:48:02 <ebyrob> oh?  How do I run a list of string commands then?
10:48:04 <paper_cc> ebyrob: Most probably you don't need to
10:48:06 <pozic> Saizan: that's during the making of closure.o
10:48:19 <ebyrob> I have [String] that is a bunch of command lines I want to run...
10:48:26 <ebyrob> I can run one of them in main
10:48:29 <ebyrob> but I want to recurse over all
10:48:35 <cizra> ebyrob: mapM_?
10:48:37 <paper_cc> @ty sequenceM_
10:48:38 <lambdabot> Not in scope: `sequenceM_'
10:48:40 <paper_cc> oops
10:48:47 <ebyrob> ooh mapM_?
10:48:48 <paper_cc> @hoogle [IO a] -> IO [a]
10:48:48 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:48:48 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:48:49 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:49:09 <Twey> ebyrob: You don't extract the value from the IO mote, because the value doesn't exist yet.  A value of type ‘IO a’ is a ‘recipe’ for performing an action that, when performed, will yield a value of type ‘a’.  If you want to do something with that value after it's been produced, you append a new command to the recipe to tell it to do something else with the result.
10:49:22 <paper_cc> @hoogle (a -> m b) -> m [a] -> m [b]
10:49:22 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:49:22 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:49:23 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
10:49:26 <ebyrob> yes, doesn't:
10:49:33 <paper_cc> ebyrob: see Hoogles above
10:49:39 <ebyrob> do x <- IO ExitCode 
10:49:43 <ebyrob> run the command?
10:50:14 <ebyrob> it seems to in main, but not in another function
10:50:57 <dmwit> do x <- IO ExitCode doesn't look real to me. IO and ExitCode are in the type language, not the value language.
10:51:05 <ebyrob> well
10:51:08 <nejucomo> Why is this a syntax error?  http://codepad.org/xv4t2evt
10:51:11 <ebyrob> do x <- system "dir"
10:51:20 <dmwit> I just joined, sorry if you were being sloppy in a well-defined way. =P
10:51:22 <nejucomo> Can't I follow any expression with a "where" clause?
10:51:42 <dmwit> nejucomo: no
10:51:53 <Twey> ebyrob: It doesn't run anything.  It appends an instruction to the recipe to tell the runtime to execute the command.
10:52:23 <pozic> > [1 where _ = ""] -- wrong
10:52:24 <Twey> ebyrob: It's all pure.  When the runtime reads the value you've constructed, *it* will run the recipe.
10:52:24 <lambdabot>   <no location info>: parse error on input `where'
10:52:46 <pozic> > [let _ = "" in 1] -- OK
10:52:47 <lambdabot>   [1]
10:52:53 <dmwit> nejucomo: Just slip the where clause out of the list.
10:53:04 <megajosh2> Hmm...
10:53:10 <dmwit> > let f i = [undefined] where addOp = undefined in 3 -- also OK
10:53:11 <lambdabot>   3
10:53:12 <megajosh2> I didn't know you could use "let" in a list
10:53:29 <pozic> megajosh2: let constructs an expression
10:53:40 <megajosh2> Oh okay
10:57:43 <Saizan> pozic: ah, ok, it's the install phase that doesn't find libevm.a, because closure.o couldn't be built (with the git version that's because of #include <foo> instead of #include "foo", i can't reproduce with the hackage one), we get to the install phase presumably because the custom Setup.hs script is not failing properly but ignoring some error
11:00:51 <ebyrob> I'm still totally confused...
11:00:56 <ebyrob> say I have:
11:01:07 <ebyrob> x = ["dir", "dir"]
11:01:19 <ebyrob> then:
11:01:34 <ebyrob> results <- mapM_ system x
11:01:37 <ebyrob> in do of main
11:01:48 <ebyrob> is that even close to what you're saying would work?
11:02:07 <zachk> mapM_ returns () 
11:02:20 <zachk> use mapM for results 
11:02:43 <dmwit> ebyrob: Yes, that would simply run dir twice, if that's what you want to do.
11:02:51 <ebyrob> that's what I want to do
11:03:01 <ebyrob> where would the exitcodes wind up if i wanted to check them for success?
11:03:05 <dmwit> ebyrob: If you want to get the output they create, or the exitcode from them, or other things like that, you will have to be a little more clever.
11:03:09 <dmwit> ebyrob: But that's the starting point.
11:03:29 <dmwit> ebyrob: If you want only the exit codes, and not the output they create, then just change mapM_ to mapM.
11:03:47 <dmwit> ...I think
11:03:51 * dmwit checks the docs for system
11:04:02 <ebyrob> trying it
11:04:37 <ebyrob> cls
11:04:39 <ebyrob> oops
11:05:13 <ebyrob> yep it works
11:05:14 <ebyrob> cool
11:07:16 * hackagebot extcore 0.9.2 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-0.9.2 (TimChevalier)
11:08:01 <hvr> an incrementor is simply written (+1) but a decrement is not simply (-1) ... what's the concise way to write "(-1)"?
11:08:33 <ddarius> pred
11:09:18 <Twey> subtract 1, strictly
11:09:22 <Twey> pred is more general
11:09:34 <Twey> (but it's shorter and it'll work, so use it ;))
11:09:57 <Twey> (you can use succ for (+ 1) too)
11:10:12 <ddarius> It's not more or less general.
11:10:21 <Twey> :t subtract 1
11:10:22 <lambdabot> forall t. (Num t) => t -> t
11:10:24 <Twey> :t pred
11:10:25 <lambdabot> forall a. (Enum a) => a -> a
11:10:26 <pozic> succ and + 1 is the difference between writing in an academic mindset or as a practical programmer.
11:10:28 <Twey> Oh, wait
11:10:34 <Twey> Enum isn't a superclass of Num.
11:10:38 <Twey> Sorry.  Yes.
11:10:43 <ddarius> > (-1+) 3
11:10:44 <lambdabot>   2
11:10:48 * Twey shudders.
11:10:57 <Nibble> Isn't manatee here?
11:10:59 <hvr> ddarius: thx :)
11:11:22 <ebyrob> Is it okay if I paste my 5 lines of code?  it *almost* works...
11:11:28 <Nibble> What is the link to his source code repo
11:11:30 <Nibble> ebyrob: shoot
11:12:00 <ebyrob> main = do
11:12:00 <ebyrob>    let cmds = ["dir", "dir"]
11:12:00 <ebyrob>    results <- (mapM system cmds)
11:12:00 <ebyrob>    let successes = map (ExitSuccess ==) results
11:12:00 <ebyrob>    print (all successes)
11:12:07 <ebyrob> it fails on the all at the end
11:12:23 <paper_cc> @ty all
11:12:23 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:12:37 <paper_cc> ebyrob: replace "all successes" by "and successes"
11:12:48 <ebyrob> doh thanks
11:12:54 <benmachine> or by all (ExitSuccess ==) results
11:13:20 <paper_cc> yes, and the previous line would be unnecessary then.
11:13:35 <ebyrob> I'll try the all exitsuccess again, that's what I was trying to do first
11:14:03 <chrisdone> Twey: gimmie a JavaScript monad
11:14:34 <chrisdone> more specifically, an equivalent of the Monad type class
11:14:52 <chrisdone> but you can call it a 'prototype' or 'object' or whatever you like, darling
11:15:04 <ebyrob> joy:
11:15:04 <ddarius> chrisdone: Just do the dictionary passing yourself.
11:15:06 <ebyrob> main = do
11:15:06 <ebyrob>    let cmds = ["dir", "dir"]
11:15:06 <ebyrob>    results <- (mapM system cmds)
11:15:06 <ebyrob>    print (all (ExitSuccess ==) results)
11:16:32 <chrisdone> expert tip: you don't need parenthees around the mapM
11:17:17 <chrisdone> ddarius: what's the "dictionary"?
11:18:52 <tomberek> so 25% of my time is in GC
11:19:26 <tomberek> all i'm doing is making arbitrary graphs, filtering them for no loops and no parallel edges
11:19:32 <tomberek> does that sound right?
11:20:17 <tommd> chrisdone: If your function if generalized over one ore more type classes then the function looks up the needed instance in a dictionary (unless the function is specialized at compile time)
11:21:22 <nlogax> hmm, when pushing to patch-tag, my email shows up all over the place. can i make darcs use a name instead? i'm not googling right..
11:23:05 <pozic> @seen shapr
11:23:05 <lambdabot> Unknown command, try @list
11:23:06 <preflex>  shapr was last seen on #haskell 2 days, 3 hours, 5 minutes and 36 seconds ago, saying: @quote
11:25:00 <benmachine> chitragupt: basically a Monad dictionary for Maybe is a structure containing an a -> Maybe a and a Maybe a -> (a -> Maybe b) -> Maybe b
11:25:13 <benmachine> oh
11:25:18 <benmachine> I meant to tab chrisdone but he's gone
11:25:27 <benmachine> and that looked like the right number of characters :(
11:26:56 <ebyrob> so um... Is it possible to redirect sub-process stdin/out/err without using fork?  Or am I in for writing a very large control module to do that?
11:27:53 <benmachine> ebyrob: I think System.Process has some neat things for doing that
11:28:01 <benmachine> runInteractiveProcess or something
11:28:04 <ebyrob> on windows?
11:28:13 <benmachine> I think so
11:28:28 <benmachine> but I've never tried
11:29:48 <ebyrob> thanks
11:34:26 * hackagebot convertible-text 0.3.0.4 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.4 (MichaelSnoyman)
11:34:35 <pozic> ebyrob: all that stuff basically just works. 
11:34:47 <pozic> ebyrob: imho, a lot easier than how it works under C. 
11:35:06 <benmachine> the standard C library is actually awful
11:35:27 <pozic> benmachine: I am not sure whether this part is actually 'standard'. 
11:35:41 <pozic> benmachine: still, if it is widely available, that's good enough for me. 
11:36:16 <benmachine> pozic: well, some libraries are standardised by the Report
11:36:30 <benmachine> but I think they're pretty small and designed to be a basis rather than complete as it were
11:40:05 <pozic> benmachine: practically speaking, image based development is probably better.
11:40:25 <benmachine> image?
11:40:29 <pozic> benmachine: everytime a new machine has to be setup for Haskell development, you lose a few hours to get it working. 
11:40:53 <pozic> benmachine: some are Ubuntu dependencies, some are Foo dependencies, etc. Compilation time is non-zero, etc. 
11:41:08 <pozic> benmachine: yes, like Squeak and some Lisps do. 
11:41:36 <pozic> benmachine: if you then want to move an application to another machine it is one copy-paste and you are done. 
11:42:08 <pozic> benmachine: and development tools are also better, because there is no disconnect between source and program.
11:42:59 <benmachine> pozic: I don't know much about Squeak or Lisps, or what exactly image-based development is
11:44:51 <sm> pozic: I guess the nearest thing for haskell would be virtualbox/vmware-style images
11:45:03 <pozic> benmachine: instead of having files and a separate compiler, you just have one process. 
11:45:27 <pozic> benmachine: the fact that there are no files is also directly why a lot of people don't like it. 
11:45:37 <benmachine> pozic: one process? what form does it take?
11:45:40 <pozic> benmachine: one bug in the system and all your source code is gone. 
11:45:57 <pozic> benmachine: but of course, you can backup and write the source code to files.
11:45:59 * sm coughs
11:46:09 <pozic> sm: eh?
11:47:31 <benmachine> http://en.wikipedia.org/wiki/Smalltalk#Image-based_persistence <-- this sort of thing? how does this prevent startup times?
11:47:46 <monochrom> by never starting up
11:50:10 <pozic> benmachine: it stores the state of the whole system. 
11:50:59 <benmachine> ok but you need to setup that storage still, surely
11:51:28 <pozic> benmachine: except it is much faster to just load the state of the program than to load and setup datastructures.
11:51:53 <benmachine> hmm, if you say so
11:52:02 <pozic> benmachine: squeak starts here in about 1.2 seconds. 
11:52:17 <benmachine> pozic: ghci starts in less!
11:52:32 <pozic> benmachine: but squeak is a graphical environment, kind of like GTK is. 
11:52:37 <benmachine> ah
11:52:41 <pozic> benmachine: and... and...
11:52:46 <monochrom> it is analogous to: hibernate and wake up your computer vs rebooting
11:52:55 <pozic> benmachine: individual applications are likely faster in ghci. 
11:53:01 <benmachine> monochrom: oh, I see
11:54:19 <monochrom> even "suspend to disk" is faster than "boot, start emacs, start firefox, start photoshop"
11:54:44 <pozic> Yes, but suspend to disk is slower than boot. 
11:54:45 <benmachine> right
11:54:50 <pozic> (which is odd, imho)
11:55:25 <pozic> It seems that it is O(size of memory) and not O(size of actually used memory). 
11:55:31 <monochrom> boot (alone) is fast these days due to various reasons depending on OSes.
11:55:49 <pozic> I don't think boot is 'fast'. 
11:55:56 <pozic> I would say under 3 sec is 'fast'. 
11:56:08 <pozic> I am still at tenfold that, I suppose. 
11:56:21 <pozic> I also count the BIOS.
11:56:55 <monochrom> ubuntu: linux is already fast. ubuntu further goes out of their way to optimize booting, e.g., the upstart thing. OTOH suspend to disk on ubuntu is not all that optimized. once you optimize that too, you will have a fair comparison.
11:57:28 <pozic> Suspend to disk also randomly stopped working in an Ubuntu release for me.
11:57:34 <pozic> It does work again, though.
11:57:54 <pozic> The only thing a laptop now needs is wireless energy. 
11:58:18 <monochrom> windows and macos: they cheat. certain daemons are merely delayed. for example vista: you still have to wait 2-5 minutes after booting to get a usable computer, just because those delayed-start daemons are really annoying.
11:59:00 <pozic> monochrom: some processes could be delayed for me.
11:59:14 <pozic> monochrom: e.g. running them only when needed or when CPU/disk\ usage is low. 
11:59:38 <pozic> I mean, I cannot imagine it takes more than 2 seconds to load a GTK library and show a login screen. 
11:59:47 <monochrom> they are not delayed enough. they are delayed by one minute or something. exactly at the time they will interfere with me starting firefox or virtualbox
11:59:50 <pozic> In the time it takes me to type some stuff, it could already compute more stuff. 
11:59:56 <arw> pozic: yes, but those "some processes" are very different ones for different people.
12:00:06 <benmachine> I start a lot of my system daemons in the background
12:00:12 <benmachine> I like that I have that control
12:00:20 <pozic> arw: Ubuntu is a desktop system, it could delay a lot of them. 
12:00:25 <monochrom> if they are delayed half an hour or something, that's fine.
12:00:28 <pozic> arw: e.g. consider an smtp server.
12:01:08 <arw> pozic: many people won't need printing immediately after logging in, except if they just started their computers to quickly print something.
12:01:10 <pozic> arw: they could write a mini-smtp server that starts in a few ms that provides the service, but later on delegates to the real slow server. 
12:01:40 <pozic> There is an infinite amount of things you can do to make things faster. 
12:01:48 <pozic> Mostly it is giving the illusion that things are fast.
12:01:49 <arw> pozic: there is something like that. you just have to install it.
12:01:52 <pozic> Or avoiding work. 
12:01:56 <arw> pozic: nullmailer for example
12:02:20 <arw> pozic: yes, the point is, that kind of "beeing fast" is just an illusion.
12:02:21 <pozic> arw: never heard of it and I like to think of myself as quite an advanced user. 
12:02:40 <pozic> arw: Linux is only more useful if you an actual expert. 
12:03:10 <pozic> arw: that is, you can setup your machine to be like a tank, but you need to have used it for years to get to that point. 
12:03:25 <pozic> It would be much better if all those optimizations would already have been done.
12:04:07 <arw> pozic: its like that with almost all systems. the designers of windows, macos or ubuntu had a certain kind of users in mind when designing their systems.
12:04:38 <arw> pozic: if you are not the kind of user they had in mind, you are either out of luck or have to customize until it fits.
12:04:51 <pozic> arw: is there any OS aimed at developers?
12:05:16 <pozic> arw: that is developers that don't wish to waste their time ;)
12:05:21 <pozic> So, no Gentoo.
12:05:40 <pozic> I don't think there is anything like that. 
12:06:06 <pozic> I think you just have to write your own little utilities to perform whatever you want. 
12:06:17 <arw> pozic: try fedora. very recent packages but no time-wasting stuff like gentoo has and a usable desktop environment out of the box.
12:08:03 <pozic> arw: what makes it better than Ubuntu?
12:08:32 <pozic> arw: I know some Redhat people are quite good and I don't know anyone working for Canonical by coincidence, but that's it. 
12:09:01 <Ke> distro flamewars \o/
12:09:13 <pozic> Ke: it is not a flame war. 
12:09:23 <pozic> Ke: some distros are technically better than others. 
12:09:42 <pozic> Ke: or have certain properties making them superior in some areas. 
12:09:55 <pozic> Ke: if you don't discuss this, you keep having the same crap.
12:10:00 <arw> pozic: its not necessarily better but it is differnt. i like it better than ubuntu because it has more recent packages and the scope of the distribution is not as strictly desktop-centered as ubuntu is.
12:10:04 <ezyang> Oh man, GHC 7.0 RC! :-O 
12:10:19 <Ke> ezyang: really?
12:10:23 <ezyang> Yup! 
12:10:29 <Ke> awesome
12:10:30 <pozic> arw: can you give a concrete example of such a package?
12:10:34 <wli> What's so good about Red Hat?
12:11:07 <Ke> wli: it's one of the most relevan linux contributors, not that it's relevant to haskell
12:11:07 <pozic> wli: I read some stuff written by RedHat engineers and I thought it was fairly high-quality. 
12:11:09 <arw> wli: fedora, _not_ red hat. red hat is the old and stable variant.
12:11:44 <pozic> arw: RedHat engineers do work on Fedora, right?
12:11:47 <arw> pozic: the xserver for example. fedora was the first distribution with KMS
12:11:50 <wli> Not sure what RH is doing that's making it interesting to you guys in particular.
12:11:51 <arw> pozic: yes
12:12:06 <arw> pozic: fedora is the "unstable, testing" variant of redhat
12:12:43 <pozic> arw: have you used Ubuntu too in the past 2 years?
12:13:07 <arw> pozic: but they make regular releases of fedora, so it is more usable than most "unstable" variants like the ubuntu prereleases.
12:13:19 <pozic> arw: I mean, how can you otherwise compare?
12:13:37 <arw> pozic: yes, i have used ubuntu, debian and suse recently.
12:14:10 <arw> pozic: keep in mind, there is no absolute value of "better". there is only "better for a certain purpose"
12:14:10 <Philonous> pozic: I don't know what makes a distribution particularly suitable for development, but have you looked at arch? It's binary, is pretty quick with package updates and lightweight
12:14:52 <pozic> Philonous: I used arch, not enough packages. 
12:15:05 <pozic> Philonous: and QA was not as good as Debian, imho. 
12:15:12 <kdvh> pozic: even in AUR? o.o
12:15:21 <writer> nor the slowness is as good as Debian ;)
12:15:23 <sahazel> I'm trying to get the "parallel" package installed on ubuntu
12:15:24 <pozic> kdvh: Ubuntu is currently at 30000. 
12:15:40 <sahazel> this turns out to not be completely obvious.  how do I do this?
12:15:47 <pozic> Test
12:15:59 <sahazel> I can't find an ubuntu package that contains it
12:16:15 <pozic> I missed anything in the past 10 seconds. 
12:16:19 <sahazel> cabal says it can't install much of anything, because base ix 3.x and everything seems to depend on 4.x
12:16:41 <sahazel> s/ix/is/
12:16:43 <arw> pozic: no
12:16:58 <ClaudiusMaximus> sahazel: which ubuntu?  here i use ghc binary tarball, but i see this listed in the available packages: libghc6-parallel-dev
12:17:07 <ClaudiusMaximus> sahazel: i'm on lucid 10.04
12:17:42 <pozic> arw: no?
12:17:45 <sahazel> ClaudiusMaximus: this is an older ubuntu.  I always forget how to check which one.
12:17:54 <arw> pozic: you didn't miss anything relevant
12:17:57 <ClaudiusMaximus> sahazel: /etc/lsb-release or similar
12:17:57 <pozic> arw: ok
12:18:06 <sahazel> ah right
12:18:31 <sahazel> looks like it's hardy, 8.04
12:18:54 <sahazel> "$ aptitude search libghc | grep parallel" yields no output
12:18:56 <ClaudiusMaximus> sahazel: i tend to start from a ghc binary tarball, install in ~/opt/ , then bootstrap cabal and go from there...
12:19:17 <danharaj> hmmm. can you define the transfinite ordinals as an inductive type?
12:19:24 <dolio> Yes.
12:19:29 <danharaj> what is the signature?
12:19:42 <dolio> data O = Z | S O | L (Nat -> O)
12:20:14 <dmhouse> How does Nat -> O encode limit ordinals?
12:20:28 <danharaj> Is that really correct though? You need to constrain yourself to increasing sequences, no?
12:20:33 <ddarius> sahazel: You're worse than me.
12:20:40 <dolio> L f is the limit ordinal of f 0, f 1, f 2 ...
12:20:43 * ddarius recently upgraded from Jaunty to Maverick.
12:21:34 <dmhouse> Moreover many sequences may have the same sup
12:21:50 <dolio> Yes, it isn't adequate.
12:22:14 <sahazel> this machine is in a datacenter 300 miles from here
12:22:29 <sahazel> upgrades are Not Advisable right now
12:22:42 <dolio> You can of course get increasingly fancy.
12:22:45 <danharaj> I guess it makes sense that you can't do it in a completely adequate fashion. Transfinite recursion is a very strong induction principle.
12:23:01 <dmhouse> I guess there's no real better way of doing it as inductive things aren't very good at expressing uncountable tihngs
12:23:35 <dmhouse> Hrm, I suppose all you need is to define an initial segment
12:23:35 <danharaj> even if you constrained yourself to the countable ordinals it seems to be rather difficult.
12:24:26 <dolio> Once you have that, there's also 'data O2 = Z2 | S2 | L1 (Nat -> O2) | L2 (O -> O2)'
12:24:38 <dolio> Which allows you to write some ordinals that O can't.
12:24:43 <dolio> And so on.
12:25:28 <dmhouse> Yeah, I guess omega1 isn't in O
12:25:49 * hackagebot MemoTrie 0.4.9 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.4.9 (ConalElliott)
12:26:40 <danharaj> Anyway, thanks. Something to think about.
12:27:25 <dolio> No matter what representation you choose, you'll be unable to write down the Church-Kleene ordinal.
12:28:02 <dolio> Depending, of course, on what you mean by 'write down.'
12:28:50 * hackagebot vector-algorithms 0.3.4 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.3.4 (DanDoel)
12:32:31 <sahazel> hooray ghc binary package
12:32:45 <sahazel> that was easy
12:36:59 <ddarius> newtype H b a = H { unH :: H a b -> a };  type X = H N
12:58:57 <banisterfiend> what's false in haskell? (in a boolean context)
12:59:04 <mapreduce> False
12:59:09 <banisterfiend> what about nil ?
12:59:21 <mapreduce> 0
12:59:40 <Nibble> ()
12:59:50 <banisterfiend> so False, and 0, and nil, () ? that it? :)
12:59:56 <Nibble> not exactly
12:59:57 <pozic> banisterfiend: no. 
13:00:08 <Nibble> nil is 0, void is somewhat like ()
13:00:21 <pozic> banisterfiend: undefined::Bool, True::Bool, False::Bool and nothing else.
13:00:38 <mwc> pozic: while, there's also _|_ :: Bool ;)
13:00:41 <mwc> *well
13:00:42 <Cale> banisterfiend: Only False is False
13:00:50 <Cale> banisterfiend: Other values are other things :)
13:00:51 <pozic> mwc: undefined is bottom. 
13:01:01 <banisterfiend> ok thanks
13:01:03 <pozic> mwc: error "" is also bottom.
13:01:07 <banisterfiend> i think ill haskell out... hehehe
13:01:31 <pozic> banisterfiend: it cannot be much simpler. 
13:01:54 <pozic> banisterfiend: you can have a system in which True::Bool, False::Bool and nothing else, but then you cannot have general recursion. 
13:02:10 <Cale> banisterfiend: [] is the empty list, if that's what you were asking about nil
13:02:29 <mwc> Maybe by nil he means a null value?
13:02:56 <mwc> so Nothing then
13:06:06 * hackagebot tls 0.1.3 - TLS protocol for Server and Client sides  http://hackage.haskell.org/package/tls-0.1.3 (VincentHanquez)
13:06:55 <tomberek> anything faster than nubBy?
13:07:05 <c_wraith> for doing what?
13:07:20 <benmachine> tomberek: it depends, if you have an ordering as opposed to just equality then yes
13:07:24 <benmachine> otherwise I don't think so
13:08:27 <c_wraith> a fold with Data.Set isn't faster, in some (very rare) use cases. :)
13:08:31 <tomberek> hm.. i got [(Int,Int)]  trying to make sure any combo only occurs once
13:09:24 <c_wraith> You're probably best-off trying to be clever and generate each combo only once
13:10:49 <tomberek> c_wraith, yes, this is an after-the-fact filtering... the process also adds the 'clever" manipulators to the original structure, so henceforth this isn't a problem, but the initial load seems to take for EVER for 30,000 elements
13:11:25 <c_wraith> Hmm.  what are you loading from?
13:12:21 <tomberek> c_wraith : what do you mean? ATM i'm using Arbitrary
13:12:26 <dschoepe> Is the ordering important? If not you might be better off using Data.Set instead of a list in the first place
13:12:50 <c_wraith> Ah, so you're generating randomly.
13:13:18 <tomberek> dschoepe : no, order is not important
13:13:19 <c_wraith> Arbitrary easily goes exponential on recursive data structures, if you're not *very* careful what you're doing.
13:13:57 <tomberek> if order doesn't matter, would an insert into a set and then toList be faster?
13:14:30 <tomberek> i just don't know how nub works
13:14:35 <tomberek> @src nub
13:14:35 <lambdabot> nub = nubBy (==)
13:14:37 <nejucomo> I'm having a hell of a time learning how to use ghci as a debugger.
13:14:47 <tomberek> @src nubBy
13:14:48 <lambdabot> nubBy eq []             =  []
13:14:48 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:14:57 <nejucomo> I want to set a break point in function f inside A.B.C, then I want to run the main function inside module Main.
13:15:00 <nejucomo> How do I do this?
13:15:09 <dschoepe> tomberek: if you never actually need it to be a list, you can just keep the data as a Set
13:15:13 <nejucomo> What's the difference between :add, :load, and :module ?
13:15:36 <dschoepe> tomberek: but asymptotically inserting into a set and then using toList would still be faster than nub
13:15:47 <tomberek> oh! it does a traversal for every element
13:15:47 <nejucomo> It seems like if I :add *A.B.C then :break A.B.C <line> then any attempt to :load, :add, or :module Main deletes the breakpoint.
13:16:28 <tomberek> dschoepe: at first it has to be a list, afterward I might be able to store it as a set, but it needs to start as a list
13:16:48 <tomberek> i'll try the set style filtering
13:17:13 <tomberek> Data.Set ok?
13:23:35 <nejucomo> So is there no way to set a breakpoint in one module, then call into another module?!
13:26:18 <nejucomo> Hrm.  I guess I can just define a new module which imports the module I want to break in, and the module I want to call into.  Seems rather cumbersome.
13:30:42 <nejucomo> Defining module Annoying to import the module I want to set a break in and the module I want to call into fails, because the dependent modules are compiled, not interpreted.
13:31:03 <tomberek> wow, much faster,,, unless order matters!  nub  is far slower than (Data.Set.toList  .   Data.Set.fromList)
13:31:54 <nejucomo> Another for my list of haskell warts.  (Actually my list is mainly ghc warts.)
13:32:27 <c_wraith> tomberek, of course.  You're comparing O(n^2) to O(n log n)
13:33:33 <tomberek> yeah... i like this much better,, is there some built in Prelude function that does something like this?  or should I just use nubIt = (Data.Set.toList . Data.Set.fromList) ?
13:34:29 <dmhouse> map head . group . sort is O(n log n)
13:34:47 <dmhouse> Should be roughly equivalent to going to/from a set
13:36:06 <tomberek> looks even better, thanks dmhouse
13:36:25 <ddarius> There are ways of writing fast nubs on elements in Ord that preserve the ordering in the list.
13:36:43 <ddarius> There are also O(n) ways of writing nub if you can "hash" the elements.
13:36:55 <tomberek> i'm working with (Int,Int)
13:37:07 <tomberek> or at the very least Eq a => (a,a)
13:37:23 <tomberek> usually Ord a => (a,a)
13:37:53 <ddarius> If all you have is Eq, then nub is the best you can do.
13:38:23 <zearen> Is there a standard style guide for Haskell?
13:38:28 <tomberek> Ord can do better though, does Ix help any?
13:38:45 <Zao> zearen: There was a thread on haskell-cafe@ earlier this week on code conventions.
13:39:08 <ddarius> @src Ix
13:39:08 <lambdabot> class (Ord a) => Ix a where
13:39:08 <lambdabot>     range           :: (a,a) -> [a]
13:39:08 <lambdabot>     index           :: (a,a) -> a -> Int
13:39:08 <lambdabot>     inRange         :: (a,a) -> a -> Bool
13:39:08 <lambdabot>     rangeSize       :: (a,a) -> Int
13:39:27 <Olathe> It would be nice if Ix had a halfwayBetween function for making a binary sort.
13:40:12 <ddarius> If you have the bounds, index is effectively a hash function.
13:40:14 <Olathe> search
13:41:23 <zearen> Oh good, thank you Zao
13:41:28 <tomberek> hm...
13:41:46 <__name__> hey
13:42:00 <tomberek> arg! monomorphismRestriction!
13:42:08 <c_wraith> kill it with fire! :)
13:42:18 <monochrom> monochromism restriction
13:42:25 <tomberek> a very nice SIGnal fire!
13:42:26 <c_wraith> that one's ok
13:42:37 <dmhouse> Kill it with {-# LANGUAGE NoMonomorphismRestriction -}!
13:43:05 <monochrom> NomNommorphism
13:43:10 <tomberek> eh, i gave it Ord a => [a] -> [a]
13:45:16 <JoeyA> I wonder if anyone's made a parser framework with a focus on making existing parsers extensible.
13:46:46 <JoeyA> For instance, I'm interested in parsing a C-like language, but I can't just take the language-c package and add extra features without messing with the original code.
13:48:04 <JoeyA> I'm thinking of something where a user can override the productions of an existing grammar.
13:48:34 <Philippa> JoeyA: if you take something like Parsec and put all the productions in an extensible record and have them call each other /via/ the record...
13:48:35 <JoeyA> For instance, suppose you wanted to add a "\y" escape to string literals which produces UTF-8 encoded lambda symbols.
13:48:50 <Philippa> IOW, build an 'object' full of non-terminals calling each other, then do inheritance
13:49:02 <JoeyA> that makes sense.
13:49:16 <JoeyA> But doesn't a person extending it have to redefine the entire object, or no?
13:49:26 <JoeyA> for instance, if you wanted to add classes to C.
13:49:34 <ClaudiusMaximus> add an extra field to the object for "extend-me" perhaps
13:50:02 <Philippa> no, that's the cool bit: you make all the functions that call each other call 'via the object' - they take the record as a parm, take the appropriate field and call that
13:50:25 <Philippa> then when you overwrite one field, the rest're calling the new version
13:51:10 <ClaudiusMaximus> oh i missed the 'extensible' records bit, nevermindme
13:51:21 <Philippa> right :-)
13:51:21 <JoeyA> I guess additional rules could simply live in a separate record.
13:51:33 <Philippa> they can do that, but it's easier to get the recursion right if they don't have to
13:52:04 <c_wraith> You also need to be careful with your grammar design, to actually make things overrideable in useful spots
13:52:19 <JoeyA> Ideally, you should be able to extend someone else's parser while making your new parser itself extensible.
13:52:30 <JoeyA> But you really should be able to extend _anything_ in the original language.\
13:52:57 <JoeyA> Though maybe a more disciplined approach would be called for.
13:54:12 <c_wraith> JoeyA, careful, you'll be describing ruby soon.  (aaarg)
13:54:13 <JoeyA> If your language is vastly different than C, maybe you should just throw in a stick of dynamite and use the shrapnel (string literal parsing, for example)
13:54:26 <Philippa> JoeyA: you get that for free if you do my trick with extensible records
13:54:40 <JoeyA> like this?
13:54:55 <JoeyA> data CParser a = CParser {... myExtra :: a}
13:55:23 <Philippa> pretty much, yeah. Only it doesn't work with actual haskell records
13:55:25 <JoeyA> then whatever a is, should also leave a breadcrumb behind
13:55:40 <JoeyA> why not?
13:55:51 <Philippa> because haskell records aren't extensible
13:56:03 <JoeyA> Can't all the C parser code be polymorphic?
13:56:19 <ddarius> JoeyA: If you really want to do this, you may want to look at PEGs.
13:56:21 <JoeyA> Then to extend the record, put something in a and override everything else?
13:56:41 <Philippa> eh. Pick an encoding of extensible records yourself, I'll leave that to you
13:56:50 <JoeyA> Or is it because you'd be shoving less polymorphic code into C parsing slots?
13:57:12 <Philippa> well yeah, you need your int literal parser to spit out an int, no?
13:58:23 <JoeyA> It might be possible to work around those issues with existential types.
13:58:46 <Philippa> you're looking at entirely the wrong dimension of polymorphism :-)
13:58:54 <JoeyA> possibly
13:59:03 <Philippa> the individual non-terminals spit out the same thing they always did
13:59:16 <Philippa> you don't /want/ to mess with that
14:00:15 <Philippa> what you're looking at doing is getting a record setup that'll let you comfortably add more fields while letting you keep the same type for the record the non-terminals expect to get passed containing all the other functions they'll call
14:00:55 <sahazel> hm, getting "No instance for (Monad (Either String))"
14:01:26 <sahazel> where can I get that instance declaration?  I can see it exists in a module someone else wrote...
14:01:37 <JoeyA> import Control.Monad.Instances
14:02:26 <JoeyA> Here's one thought that crossed my mind: the grammar that CParser gives you is not a final parser, but an extensible one.  Perhaps this "unbuilt" parser could be extended by having the user define production rules by referring to them by String.
14:02:41 <JoeyA> However, that doesn't sound very type safe.
14:02:48 <Philippa> that's just trying to use a big Map as your record encoding
14:03:22 <mapreduce> From RWH: Side effects are essentially invisible inputs to, or outputs from, functions. In Haskell, the default is for functions to not have side effects.
14:03:42 <mapreduce> Isn't the environment an invisible input?
14:03:54 <aavogt> mapreduce: yes
14:03:59 <ddarius> mapreduce: See the Reader monad.
14:04:06 <c_wraith> yes.  and really, a side *effect* is an invisible *output*.
14:04:13 <JoeyA> Another thing to consider is that the AST also needs to be revised when extending a grammar.
14:04:30 <c_wraith> If it doesn't change something, it's not an effect.
14:04:31 <Philippa> c_wraith: depends - are you the effector or the effectee?
14:04:47 <mapreduce> I'm not talking about modifications to the environment (I guess that makes the Reader monad not related).
14:06:01 <JoeyA> For instance, if you add classes to C, you have to add another option to the CDecl type (or whatever it's called).
14:06:33 <ddarius> JoeyA: You will have to design a uniform representation.
14:06:46 <JoeyA> And if you decide to remove enums, you'll have a similar problem.
14:07:09 <JoeyA> Do you mean a representation that includes all necessary fields, even those that aren't applicable?
14:07:19 <Philippa> you can go a long way on providing overloaded constructors for the AST
14:07:25 <tolkad> I noticed something about concurrency in haskell, it seems like if you want to modify a data structure across multiple threads, you either have to only make one modification at a time (wrap the whole data structure in an MVar) or wrap each piece of the data structure in an MVar. Is there any way to have a seperation of concerns so the code written for operating on some data structure doesn't have to know whether or how it will be used concurrently?
14:07:30 <ddarius> JoeyA: Removing stuff isn't a problem.
14:07:38 <c_wraith> tolkad: stm
14:08:20 <c_wraith> tolkad: but it turns out that a shared structure in an MVar is generally the fastest approach, until you reach *really* high levels of concurrency
14:08:49 <tolkad> c_wraith: I don't like either of those solutions, I want it to be fast and have a SoC
14:09:54 <JoeyA> One cool thing about Haskell is that if you don't want a nightmare where 4 passes all use the same node type, a phantom type can be used to denote the current pass.
14:10:01 <monochrom> I have a binary search tree shared by threads. For the sake of atomicity and sanity, I use one MVar pointing to one immutable binary search tree. Zero programming effort for making sure the tree is uncorrupted at all times.
14:10:34 <c_wraith> tolkad, I don't think you *can* separate "this data structure is persistent" vs "this structure is non-persistent".
14:10:46 <JoeyA> that is, you can have such a setup, but it isn't a nightmare
14:10:52 <monochrom> And if someone asks me how fast is that, I answer: anything faster requires a PhD in distributed algorithms.
14:11:05 <tolkad> c_wraith: you could have STM that magically compiles to use MVars
14:11:10 <monochrom> (cf Intel's recent concurrent data structure libs)
14:11:10 <ddarius> monochrom: What do distributed algorithms have to do with this?
14:11:13 <JoeyA> The nightmare being, you look at a big pile of code transforming an AST, and you don't have a clue what state the AST is in when it's given to the function.
14:11:28 <c_wraith> tolkad: but that implies non-persistent data structures.  That's not separating concerns.
14:11:44 <sinelaw> Peaker, hey
14:11:47 <monochrom> lock-free shared data structures
14:11:50 <medfly> hi sinelaw 
14:12:04 <sahazel> "import Control.Monad.Instances ()" doesn't get me the instance declaration for (Monad (Either String))
14:12:13 <tolkad> c_wraith: implies NON-persistent? sorry I don't understand
14:12:17 <c_wraith> sahazel, I think that instance is in Control.Monad.Error
14:12:35 * hackagebot synthesizer-llvm 0.2.0.1 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.2.0.1 (HenningThielemann)
14:12:49 <JoeyA> > (++ "!") <$> Right "Hello" -- works for me
14:12:50 <lambdabot>   Right "Hello!"
14:13:11 <sahazel> c_wraith: there it is!  thank you.  is there some good way to find these?
14:13:32 <Heffalump> tolkad: overload the structure over MVar/Identity?#
14:14:07 <c_wraith> tolkad: a persistent data structure is one where no operations destroy its previous state.
14:14:38 <ddarius> Heffalump: The interface would still be totally different.  You could wrap the structure in an ADT, but the abstraction will almost certainly leak.
14:14:44 <JoeyA> err, that was an Either ... String
14:14:48 <benmachine> sahazel: that particular instance is a nasty one
14:15:04 <benmachine> sahazel: in most cases, instances should be in the same places as either the data type or the class
14:15:15 <benmachine> sahazel: there are a few obscure exceptions and you pretty much just have to learn those
14:15:29 <Heffalump> ddarius: not if you always access it in a monad
14:15:35 <sahazel> benmachine: ah, okay.
14:15:44 <c_wraith> tolkad: really, using a persistent data structure is the best you can do for separating concerns.  The data structure itself doesn't care how it's used.
14:15:48 <tolkad> c_wraith: GHC could also magically create new MVars when necessary based on an analysis of whether its possible for your code to attempt to access a previous state of the data structure
14:15:51 <ddarius> Heffalump: That would be wrapping it in an ADT and the abstraction will leak.
14:16:03 <ddarius> (Unless you completely defeat the point of it.)
14:16:07 <benmachine> sahazel: however, if you do somehow manage to get the instance in scope but you're not sure how, using :info in ghci will tell you what file it came from
14:16:11 <benmachine> or what module at least
14:16:17 <benmachine> :info Monad
14:16:19 <benmachine> for example
14:16:20 <JoeyA> @src fmap
14:16:20 <lambdabot> Source not found. You type like i drive.
14:16:24 <benmachine> or :info Int
14:16:28 <c_wraith> tolkad: and the part of your code that *does* care how concurrency is handled handles it the right way.
14:16:36 <sahazel> benmachine: that would have been handy here.  thanks!
14:16:53 <tolkad> c_wraith: well, I don't care about SoC between persistence and nonpersistence anyway
14:17:09 <Heffalump> ddarius: I don't see why
14:17:29 <tolkad> I guess what I was asking for just isn't possible
14:18:07 <ddarius> Heffalump: There's a difference in behavior between locking a whole tree and locking just parts of it.
14:18:07 <Heffalump> I'm proposing data Foo ref = Bar (Bar ref) | Blat (Blat ref) ...
14:18:29 <Heffalump> but that's the concern of the caller
14:20:51 <JoeyA> sahazel: after looking around, I found the instance in Control.Monad.Error .
14:21:40 <osfameron> how do you use randomRs?
14:22:08 <osfameron> the docs seem to suggest:  let list = randomRs (1,3) g   should work
14:22:14 <osfameron> (where g <- newStdGen)
14:22:42 <osfameron> but I get type errors asking me to add a type signature (but not sure to *what*)
14:22:48 <megajosh2> Hmm
14:22:49 <c_wraith> osfameron, sure, so long as it can figure out what type you mean
14:22:59 <megajosh2> I know I used that before but I can't remember HOW you use it
14:23:06 <c_wraith> osfameron, randomRs is polymorphic.  And you're not telling it what type you mean.
14:23:09 <megajosh2> @hoogle random
14:23:10 <lambdabot> package random
14:23:10 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
14:23:10 <lambdabot> module System.Random
14:23:14 <megajosh2> @hoogle randomR
14:23:15 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:23:15 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
14:23:15 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
14:23:33 <c_wraith> You might mean [Int] or [Integer] or [Word8] or...  anything else that's Num
14:23:34 <megajosh2> Oh
14:23:41 <osfameron> c_wraith: I'm telling it I want a range between (1,3) no?
14:23:50 <c_wraith> yes, but 1 and 3 are also polymorphic
14:24:02 <c_wraith> they can have any type, so long as that type is an instance of Num
14:24:11 <osfameron> oh
14:24:36 <JoeyA> http://codepad.org/d2ZepwXi -- Here's a trivial example of randomR, if it helps.
14:24:56 <JoeyA> Gosh, that looks so much like homework code :D
14:25:14 <JoeyA> meh, would have been better if I would have :: IO Int'ed the reads
14:25:18 <sahazel> hm, Control.Exception no longer exports ioErrors
14:25:29 <osfameron> where do I add the signature?
14:25:32 <JoeyA> But I don't know what Haskell homework tends to be like.
14:25:46 <c_wraith> osfameron, let list = randomRs (1,3) g :: [Int]
14:25:56 <c_wraith> for instance
14:26:02 <osfameron> ah... I was trying   let list :: [Int] ...
14:26:20 <c_wraith> you could also go with let list :: [Int] ; list = randomRs (1,3) g 
14:26:37 <benmachine> sahazel: what do you need it for?
14:26:44 <wjt> ~
14:26:44 <osfameron> can I get a random tuple?
14:27:17 <sahazel> benmachine: "catchJust ioErrors" in some socket-handling code
14:27:33 <osfameron> i.e. a pair of random numbers?
14:27:36 <aavogt> @instances Random
14:27:37 <lambdabot> Couldn't find class `Random'. Try @instances-importing
14:27:47 <osfameron> or do I have to split the random generator, and zip together 2x randomRs streams ?
14:27:49 <c_wraith> @instances-importing System.Random Random
14:27:49 <aavogt> @instances-importing System.Random Random
14:27:49 <lambdabot> Bool, Char, Double, Float, Int, Integer
14:27:50 <lambdabot> Bool, Char, Double, Float, Int, Integer
14:27:54 <c_wraith> hah
14:28:06 <c_wraith> looks like there's no instance for (a,b)
14:28:09 <osfameron> ok
14:28:19 <benmachine> sahazel: use Control.Exception.catch with a handler that accepts IOErrors, and the type magic will do the rest
14:28:26 <osfameron> so... split?  or chunk a stream?
14:28:27 <JoeyA> You could write one once you feel up to it :-)
14:28:39 <benmachine> sahazel: you might need an explicit type signature
14:29:36 <c_wraith> osfameron, whichever you like.  :)
14:29:39 <JoeyA> Well, if you're just using getStdRandom, you can simply use it twice, I think (right?).
14:29:50 <c_wraith> You could do that, too, yes
14:30:01 * osfameron tries with split and zip
14:30:58 <JoeyA> If you're dealing with the pseudorandom state purely (e.g. with randomR), can't you get the initial state of the generator and use randomR to get the first value and subsequent state?
14:31:24 <sahazel> benmachine: hm, not sure I understand how to do this transformation
14:31:28 <JoeyA> I am by no means an expert on using System.Random, so I'll be quiet now.
14:31:33 <osfameron> yeah, but I don't really want to be manually threading that stuff
14:31:42 <osfameron> I quite like the "stream of random numbers" idea
14:31:45 <aavogt> @hackage MonadRandom
14:31:46 <lambdabot> http://hackage.haskell.org/package/MonadRandom
14:31:54 <benmachine> sahazel: hpaste the code?
14:32:23 <sahazel> benmachine: the old code was http://codepad.org/tVXqcz7m
14:32:28 <EvanR> possible fix: add (Convertible SqlValue a) to the context of type signature for queryMaybe, so i did. error Non type-variable argument in the constraint Convertible SqlValue a
14:32:51 <EvanR> use -XFlexibleContexts to permit this
14:33:06 <EvanR> multiparameter type classes seems tricky
14:33:23 <benmachine> sahazel: I think this will do the trick: http://codepad.org/LXfqc79A
14:33:42 <Saizan> EvanR: if you use MPTCs you should have FelxibleContexts on
14:34:13 <Saizan> EvanR: anyhow, are you sure that you want to be that polymorphic?
14:34:33 <Saizan> oh, maybe for "queryMaybe" it'd be appropriate
14:34:58 <EvanR> queryMaybe :: SqlCode -> [SqlValue] -> DbAccess (Maybe a)
14:35:11 <EvanR> the idea is the query is supposed to find exactly one thing
14:35:14 <EvanR> or not
14:35:36 <EvanR> whatever the thing is it needs to be converted from SqlValue to whatever the caller wants
14:35:45 <EvanR> and its not liking that
14:36:04 <sahazel> benmachine: I think that did it, thanks
14:36:29 <Saizan> EvanR: queryMaybe :: Convertible SqlValue a => SqlCode -> [SqlValue] -> DbAccess (Maybe a), and add {-# LANGUAGE FlexibleContexts #-} at the top of your file
14:36:42 <EvanR> osfameron: if you are ok with writing your random algorithm with an imperative style Random monad is great
14:37:15 <EvanR> Saizan: funny i didnt have to do this until now, even though ive been using HDBC for a while 
14:37:28 <osfameron> EvanR: is that MonadRandom ?
14:37:36 <EvanR> i guess HDBC is using flexibleinstances so i guess its not a problem that i depend on it
14:37:50 * EvanR has never used extension flags before
14:37:51 <Saizan> EvanR: you could omit the type signature and not need the extension :)
14:37:55 <EvanR> lol
14:38:03 * EvanR comments out the sig
14:38:15 <Saizan> anyhow, FlexibleContexts is veery bland
14:38:15 <EvanR> now its still documenting but not screwing me up
14:38:41 <EvanR> osfameron: MonadRandom is a class so your monad can act like Random
14:38:42 <Saizan> i wouldn't even think about enabling it or not
14:38:50 <EvanR> you mean youd enable it 
14:39:09 <Saizan> yes
14:39:36 <EvanR> osfameron: ah, its also the name of a package
14:39:41 <EvanR> http://hackage.haskell.org/package/MonadRandom-0.1.3
14:51:56 <greap> Hey. Is there a way to parse just a number with Text.Parsec.Token, rather than a token then a space?
14:58:22 <greap> I'm trying to step away from using read
15:16:45 <monochrom> Text.Parsec.Token does not require a space. It just eats spaces if present.
15:17:09 <monochrom> "23+23" is parsed just fine.
15:18:01 <sahazel> ouch
15:18:20 <sahazel> my simple haskell web server has been completely busted by changes since Network.HTTP 2
15:18:22 <sahazel> er, 3
15:18:38 <sahazel> now I have to figure out what an HStream is and how to make one out of a Handle
15:18:52 <monochrom> eh? I thought HTTP is now at version 4000 :)
15:18:59 <sahazel> yeah I mean 3000
15:19:07 <monochrom> heh
15:19:14 <sahazel> in 3000, I just made Handle and instance of Stream
15:19:23 <sahazel> now I need this HStream thing that I don't understand
15:19:36 <sahazel> all I want is to read an HTTP request off a socket
15:21:06 <sahazel> it seems like maybe they already connected up TCP and their Streams in 4000, but I can't understand how from the docs
15:21:55 <sahazel> HandleStream sounds promising, but I can't find any examples of how to deal with this
15:21:57 <monochrom> Do you use simpleHTTP?
15:22:10 <sahazel> no, I'm writing a simple HTTP server, not a client
15:22:39 <monochrom> openSocketStream
15:22:52 <sahazel> I accept a connection with Network.accept, and then I want to read an HTTP request off of it
15:23:38 <sahazel> Network.accept gives me a Handle.  can I turn that into a Socket somehow?
15:23:38 <monochrom> and instantiate the type variable bufType to String or lazy ByteString
15:23:49 <benmachine> sahazel: use Network.Socket instead
15:24:30 <sahazel> hmmm
15:24:59 <benmachine> most of the functions are drop-in replacements I think
15:26:29 <monochrom> Network.Socket.accept :: Socket -> IO (Socket, SockAddr)
15:27:00 <sahazel> okay, so say I figure out how to get a Socket
15:27:12 <sahazel> how do I get ahold of something receiveHTTP can deal with?
15:27:34 <sahazel> I need to do something with openSocketStream that I don't understand
15:28:19 <monochrom> Network.TCP.openSocketStream :: String -> Socket -> IO (HandleStream bufType)   where bufType becomes String or lazy ByteString (up to you)
15:28:39 <monochrom> then give its answer to receiveHTTP
15:29:07 <monochrom> and use it again for respondHTTP when you send stuff to client
15:30:43 <monochrom> oh actually String or eager ByteString or lazy ByteString, they are all fine.
15:30:55 * hackagebot filestore 0.3.4.3 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.3.4.3 (JohnMacFarlane)
15:31:08 <sahazel> String, probably
15:33:24 <siracusa> Does GHCi automatically skip printing the result value for IO [X] if X doesn't have a Show instance?
15:33:55 <sahazel> monochrom: so, I'm not quite getting openSocketStream
15:33:57 <sahazel> I have a socket
15:34:00 <Saizan> siracusa: yes
15:34:00 <sahazel> er, a Socket
15:34:21 <sahazel> and openSocketStream seems to produce the type of thing that receiveHTTP needs
15:34:27 <sahazel> but where does the String come in?
15:34:44 <Saizan> siracusa: which follows from ghci skip printing the result valure for IO Y if  Y doesn't have a Show instance or Y is ()
15:35:32 <tolkad> if there is a version dependency conflict with a 3rd package between two packages is it possible for cabal to just split that package into two different modules?
15:36:01 <sahazel> seems like openSocketStream takes a String as its param?  but why?
15:37:33 <sahazel> I'm really not getting the idea here
15:37:42 <mreh> has anyone suceeded in install hmatrix?
15:38:03 <mreh> there's duplicated instances from QuickCheck
15:38:31 <sahazel> this type checks, but I have no idea what the String is for: wtf <- openSocketStream "" socket
15:38:32 <mreh> nothing stopping me removing them myself, I suppose
15:39:19 <benmachine> mreh: which version of QC is it trying to use?
15:39:43 <megajosh2> > head [1]
15:39:44 <lambdabot>   1
15:40:00 <mreh> benmacine: 2.1.1.1
15:40:08 <mreh> benmachine: ^^^^
15:40:46 <benmachine> mreh: maybe try with --constraint='QuickCheck<2'
15:41:15 <megajosh2> Hmm
15:41:25 <sahazel> wow, I got it to compile
15:42:35 <monochrom> normally the string parameter is the hostname of the other side. I don't think it is useful here.
15:43:05 <benmachine> sahazel: I think the string is for hostname
15:43:20 <benmachine> I'm not sure why you need it
15:43:36 <monochrom> for example if you are a client and you browse hpaste.org, you put "hpaste.org" there, but this is only because you're initiating a connection. if you're the server, you don't really care.
15:43:52 <benmachine> oh right monochrom said
15:43:59 <benmachine> sry I suck at reading
15:44:32 <monochrom> there is nothing to read actually. in the haddock anyway. I had to deduce it from meaningful identifiers in the source code. this is a shame, yes.
15:46:06 <benmachine> yes I suck at reading what you said :P
15:46:14 <benmachine> I looked in the source as well
15:47:13 <tolkad> does cabal support subpackages?
15:47:16 <sahazel> yeah, getting the idea now looking at the source + your comments
15:47:23 <sahazel> also, passing "" works fine
15:47:35 <benmachine> tolkad: exactly one library per package, I think
15:47:42 <benmachine> but as many executables as you like
15:47:54 <sahazel> monochrom, benmachine: thank you!
15:48:08 <sahazel> back to hacking things I understand better...
15:48:18 <monochrom> heh
15:48:48 <tolkad> benmachine: is it possible to tell cabal where to look for another package in your .cabal file?
15:49:16 <benmachine> tolkad: hackage? I don't know, but I don't think so
15:49:57 <tolkad> benmachine: what if I want to use a non-public package
15:50:08 <tolkad> one I just have in some directory
15:50:29 <benmachine> tolkad: you could run cabal install from inside its directory?
15:50:34 <benmachine> then depend on it like normal
15:50:53 <tolkad> benmachine: now how do I distribute these?
15:51:06 <benmachine> hmm
15:51:18 <benmachine> just as two tarballs?
15:51:25 <benmachine> with instructions to install one of them before the other
15:51:37 <benmachine> (or one tarball containing both directories)
15:52:08 <tolkad> benmachine: that's terrible
15:52:25 <benmachine> how?
15:52:35 <benmachine> include a script to install both if you like :P
15:52:42 <benmachine> hmm
15:52:49 <tolkad> benmachine: then I have to write a different script for each OS
15:53:00 <benmachine> write a haskell script, problem solved
15:53:05 <benmachine> um
15:53:17 <tolkad> benmachine: good idea, I'll put it in another package
15:53:33 <benmachine> no I just mean a tiny little thing you runhaskell
15:53:36 <benmachine> but anyway
15:54:30 <benmachine> tolkad: there's a local-repo setting in .cabal/config, I'm not sure what it does
15:54:33 <benmachine> maybe it's interesting
15:57:26 <benmachine> can't find the docs for it :/
16:14:31 <ologNation> Hello.  I am a graduate student in mathematics, taking courses in Topology and Algebra. 
16:14:37 <ologNation> Is there a channel where I can discuss these topics? 
16:14:39 <ologNation> Thanks. 
16:15:00 <flippo> Olathe, #math
16:15:11 <flippo> ologNation, rather:  #math
16:15:23 <djahandarie> Yeah, #math , though it's usually more questions there than discussion
16:15:53 <flippo> djahandarie, that's because lazy students are more numerous than people interested in math
16:17:11 <Cale> ologNation: You could also discuss them here, but the responses may drift into programming :)
16:17:53 <Cale> (The interactions between topology, algebra, and functional programming are pretty compelling :)
16:20:40 <djahandarie> Cale, have there been any neat applications of topology + FP?
16:21:00 <djahandarie> I vaguely remember someone talking about topology in here one time
16:21:32 <Cale> http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
16:21:40 <winxordie> I'd like to see some link between Pontryagin duality and FP.
16:22:10 <Cale> Or, more recent work by the same author: http://www.cs.bham.ac.uk/~mhe/papers/msfp2010/Escardo-Oliva-MSFP2010.pdf
16:28:25 <sinelaw> does anyone have a mirror download of SLPJ's book? the official link is really slow
16:28:58 <Saizan> L?
16:28:58 <avenge> What's the official link?
16:31:24 <avenge> I just downloaded the djvu version pretty quickly.
16:31:35 <avenge> You could download that and convert, or just read it in djvu format.
16:32:24 <ologNation> Cale, That's a very interesting idea.  Classes start tomorrow. 
16:32:53 <ologNation> If nothing else, I may find sympathy for my project, HomeworkMachine. 
16:33:17 <ologNation> This is a collection of haskell and elisp scripts which allow me to think of one assignment at time, 
16:33:29 <ologNation> and organize all of the masses of homework compositions that I have to do over this next year. 
16:41:35 <Axman6> dons: happy birthday! (according to reddit)
16:43:14 <djahandarie> :o
16:43:31 <djahandarie> dons, happy birthday (according to Axman6)!
16:43:38 <Axman6> heh
16:43:47 <monochrom> now every web site account of dons gets compromised because everyone knows his birth date!
16:44:20 <dolio> Doesn't it say "reddit birthday"?
16:44:31 <dolio> Meaning the anniversary of the day he subscribed?
16:44:46 <monochrom> hrm, that's bad
16:45:01 <monochrom> even facebook doesn't do a "facebook birthday" thing
16:45:17 <djahandarie> Ha
16:46:13 <kmc> yay --make is the default in ghc 7.0 rc
16:46:25 <djahandarie> Thank god
16:46:48 <djahandarie> What is the point of running it without --make anyways?
16:46:55 <djahandarie> I've never done it before, I don't think
16:46:57 <c_wraith> compiling libraries
16:47:03 <c_wraith> --make is only for executables
16:47:08 <kmc> or using a makefile if you're somehow forced to
16:47:08 <djahandarie> Oh
16:47:26 <djahandarie> I use cabal 100% these days anyways
16:48:15 <djahandarie> Were there plans for cabal to have better HPC integration? I remember something like that I think
17:00:11 <Maxdamantus> What does Haskell say about memoisation vs re-evaluation?
17:00:39 <Maxdamantus> When I try to evaluate last facs where facs = 1 : zipWith (*) facs, ghci eats lots of memory
17:00:54 <benmachine> Maxdamantus: the haskell language definition intentionally leaves the options open, as it were
17:01:35 <Lemmih> Maxdamantus: Not that surprising, is it?
17:01:38 <benmachine> Maxdamantus: the problem here is that the facs name still exists, so as ghci evaluates the list, it keeps the whole thing in memory
17:01:42 <Maxdamantus> Oh, maybe it's eating memory because the numbers are really big
17:01:45 <c_wraith> Maxdamantus, GHC tends not to GC things until there are no references to it.
17:02:08 <aristid> a top-level name in ghci is a reference
17:02:09 <c_wraith> Maxdamantus, nah, even factorials don't grow *that* fast.
17:02:14 <Maxdamantus> Yeah, that's what I was thinking first, since it will remember it like a linked list
17:02:34 <aristid> it IS  a linked lsit
17:02:48 <wli> Maxdamantus: facs = scanl1 (*) [1..]
17:02:53 <Zao> Singly linked, to boot.
17:03:03 <Maxdamantus> Maybe (last $ fix $ (1:) . zipWith (*) [1..]) will be better
17:03:21 <Maxdamantus> Er yeah, or that scanl stuff
17:03:30 <wli> Maxdamantus: Assuming you want factorials go with scanl1
17:03:34 <Maxdamantus> wli: but there's still the facs, which can be referenced
17:03:43 <Maxdamantus> So the list should still be stored, rightL
17:04:04 <Maxdamantus> Would need to put that expression directly into last I think
17:04:22 <wli> Maxdamantus: Not really much of an issue. Things are GC'd behind it normally.
17:04:29 <c_wraith> On a semi-related topic, I know that values computed by a CAF can be GC'd under some circumstances, but I don't know what those circumstances are.
17:05:02 <wli> Maxdamantus: c_wraith raises an important issue, which is, I guess, when CAF's get GC'd.
17:05:22 <mm_freak> c_wraith: factorials themselves don't grow that fast, but if you keep each factorial in memory, it grows fast indeed
17:05:31 <wli> Maxdamantus: One option is not to use a CAF; just use an anonymous value or bind the name to something not at the top level.
17:05:44 <Maxdamantus> Linearly exponentially
17:05:45 <c_wraith> mm_freak, that was my point.  Fast memory growth means you're holding the whole list.
17:05:55 <mm_freak> yeah
17:06:25 <kmc> yeah, there are a few libs that use types like «() → a» to avoid sharing
17:08:37 <Saizan> Maxdamantus: the simple fact that facs is defined circularly doesn't alone imply that there'll always be a reference to the head of the list
17:10:10 <Saizan> in fact "print (let facs = 1 : 1 : zipWith (*) facs (tail facs) in facs)" only ever needs to keep 2 consecutive elements in memory at once
17:11:12 <Saizan> nvm that it's wrong :P
17:12:36 <Maxdamantus> @hoogle fix
17:12:37 <lambdabot> Data.Function fix :: (a -> a) -> a
17:12:37 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
17:12:37 <lambdabot> module Control.Monad.Fix
17:12:44 <RichardBarrell> Saizan: you seem to be thinking of fibs? :)
17:13:05 <Saizan> RichardBarrell: i guess so :)
17:13:26 <ddarius> Factorial grows pretty damn fast.
17:14:31 <Maxdamantus> It's like a mix betwnee the two
17:14:31 <Maxdamantus> fibs would've dh[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[BWould've been fibs if (*) was (+)
17:14:31 <Maxdamantus> Bleh, damn uni internet lag.
17:15:01 <RichardBarrell> Maxdamantus: yes, and keep your left cursor key on a tighter leash from now on. ;)
17:15:09 <aristid> > map (length . permutations . enumFromTo 1) [1..]
17:15:11 <RichardBarrell> Maxdamantus: (irssi and a slow SSH connection? I've had that.)
17:15:13 <lambdabot>   mueval-core: Time limit exceeded
17:15:20 <aristid> > map (length . permutations . enumFromTo 1) [1..5]
17:15:21 <lambdabot>   [1,2,6,24,120]
17:16:29 * tibbe is at ICFP and is hungry!
17:17:15 * djahandarie grills some lambdacats for tibbe
17:18:06 <aristid> noooo, poor lambdacats
17:19:19 <kmc> ok so
17:19:26 <kmc> if my BSD3 library depends on an LGPL library
17:19:28 <kmc> is this terrible?
17:19:38 <djahandarie> Prepare to get sued
17:19:41 <mm_freak> ddarius: even though factorial grows very fast, it doesn't grow fast enough to blow your memory before you notice it
17:19:42 * djahandarie calls up his lawyer
17:19:44 * Maxdamantus wonders where the [Bs came from
17:19:58 <Maxdamantus> They were meant to be backspaces
17:20:25 <mm_freak> 100000000! takes 'only' 299 MiB of memory…  before that memory is used, you're likely to abort the calculation
17:20:26 <Zao> Maxdamantus: With some IRC clients, if you type something and hit enter before it has updated anything, it doesn't process any control characters.
17:20:27 <djahandarie> kmc, stack overflow says its okay
17:20:34 <Zao> Maxdamantus: Normally happens with extreme latency.
17:20:55 <medfly> Zao, so basically, if things are performing poorly, then some IRC clients make them even worse.
17:21:15 <Maxdamantus> But isn't esc-B left or something?
17:21:21 <kmc> i mean just publishing such a lib is obviously not breaking any law
17:21:25 <Zao> medfly: I guess it's some readline or similiar implementation issue.
17:21:26 <kmc> but does it make my lib much less useful?
17:21:34 <Zao> I expect they were designed to be used interactively.
17:21:47 <Maxdamantus> nvm, B is backspace
17:22:05 <djahandarie> kmc, if you distribute the library with your binary, then you need to distribute the library source as well, per LGPL
17:22:18 <djahandarie> kmc, and due to the BSD you will need to also write down any attribution
17:22:26 * hackagebot logict 0.4.1 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.4.1 (DanDoel)
17:28:26 <codolio> Bwahahaha. Superclass equality constraints.
17:28:35 <codolio> Now fundeps can die.
17:28:46 <codolio> And be replaced by syntactic sugar.
17:29:26 <djahandarie> Where?
17:29:28 <djahandarie> 7?
17:29:42 <Saizan> oooooh.
17:29:44 <codolio> Yes.
17:29:44 <Adamant> Madness? or Sparta?
17:30:00 <Saizan> codolio: datakinds there too?
17:31:46 <codolio> The only LANGUAGE with "kind" is KindSignatures
17:32:12 <codolio> --supported-languages now lists "NoFoo" in addition to "Foo" for some reason.
17:32:24 <codolio> Forall Foo.
17:32:29 <djahandarie> codolio, do you know what that superclass eq would look like? (in syntax)
17:33:15 <codolio> 'class C a b | a -> b, b -> a' ==> 'class (T1 a ~ b, T2 b ~ a) => C a b where type T1 a :: * ; type T2 b :: *'
17:33:27 <djahandarie> Nice
17:33:40 <codolio> I don't know about nice. It's ugly.
17:33:57 <codolio> But, you can do any fundep that way, and finally get them squared off with type families.
17:34:09 <codolio> Instead of having two extensions that do the same thing in different ways.
17:34:33 <codolio> With slightly incompatible behaviors.
17:34:45 <codolio> Although, that means that it's conceivable that old fundep code would break.
17:35:47 <djahandarie> It's nice that GHC returns memory
17:36:31 <djahandarie> Oh nice, there is void now also
17:36:46 <codolio> There's still an ImpredicativeTypes extension.
17:37:32 <aristid> codolio: the fundep syntax is much nicer than the TF syntax IMHO
17:38:07 <codolio> aristid: It's nicer for cases where you actually want all the parameters in the class.
17:38:53 <codolio> That's why I think it should still be available as sugar for type families.
17:39:24 <aristid> codolio: maybe if the tf syntax becomes better it might not be necessary
17:39:34 <aristid> but as it is, the tf syntax is a total pain in the ass IMO
17:39:37 <codolio> You can do stuff with the equality constraints that can't be done with fundeps, though, I think.
17:39:39 <Xorlev> In a list comprehension, is it possible to "or" conditions together?
17:39:50 <aristid> codolio: what?
17:39:53 <kmc> you mean boolean conditions?
17:39:57 <kmc> you can use (||), sure
17:40:10 <Saizan> codolio: would OverlappingInstances fit in that fundeps as sugar scenario?
17:40:22 <kmc> if you want like «x <- (xs or ys)» then your "or" operator is ++
17:40:50 <Xorlev> Oh cool :) Thank you
17:40:54 <codolio> Someone here a few weeks back wanted a way to have 'class C a b c' where it was ensured that c = (a, b), or something.
17:41:01 <codolio> You can use equality constraints to enforce that.
17:42:03 <TeachmeHaskell> Hello Folkz
17:43:23 <TeachmeHaskell> why when i type ceiling 3.3 i get 4
17:43:31 <TeachmeHaskell> what is ceiling do..
17:43:48 <TeachmeHaskell> and truncate pi gives me 3..
17:44:03 <codolio> Actually, I think what they specifically wanted was "class (t ~ (Fst t, Snd t)) => C t where type Fst t :: * ; type Snd t :: * ; ..."
17:44:24 <TeachmeHaskell> ?
17:44:46 <TeachmeHaskell> codolio talking to me?
17:44:48 <codolio> No.
17:44:52 <TeachmeHaskell> ok lol
17:45:03 <codolio> ceiling finds the least integer greater than or equal to a given number.
17:45:30 <TeachmeHaskell> great!
17:45:39 <TeachmeHaskell> what about truncate pi
17:45:45 <TeachmeHaskell> what does that do..
17:45:50 <ddarius> > ceiling (1/0)
17:45:51 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:46:01 <TeachmeHaskell> huh
17:46:02 <ddarius> > ceiling (0/0)
17:46:03 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
17:46:04 <TeachmeHaskell> smart bot
17:46:08 <dibblego> is TH suitable for Java code generation?
17:46:36 <Axman6> i thought TH was specifically for making GHC's AST of haskell
17:46:39 <ddarius> dibblego: You are going to have to elaborate.
17:46:43 <Axman6> could be wrong however
17:46:57 <dibblego> e.g. to write Tuple[N].java
17:47:17 <dons> Axman6: its not my birthday
17:47:30 <megajosh2> Eh?
17:47:30 <Axman6> well reddit says it is
17:47:36 <megajosh2> > ceiling $ 4/0
17:47:37 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:47:41 <megajosh2> Oh dear god
17:47:43 <ddarius> dibblego: You can do arbitrary IO at compile-time with TH.
17:47:51 <dibblego> interface Tuple2<A, B> { A a(); B b(); } interface Tuple3<A, B, C>{A a(); B b(); C c(); } and so on
17:48:02 <flippo> That looks like infinity to me.
17:48:11 <megajosh2> It looks terrifying
17:48:31 <ddarius> > length (show (ceiling (1/0)))
17:48:32 <lambdabot>   309
17:48:36 <megajosh2> > 1/0 -- the universe explodes?
17:48:37 <lambdabot>   Infinity
17:48:46 <TeachmeHaskell> megajosh what is "$"
17:48:49 <flippo> Close enough for our purposes.
17:48:51 <TeachmeHaskell> power?
17:48:57 <dibblego> ddarius, I'm not sure how that helps
17:48:58 <megajosh2> $ is function application
17:49:05 <megajosh2> Like f $ x == f x
17:49:06 <TeachmeHaskell> and what it does..
17:49:10 <TeachmeHaskell> i see
17:49:17 <megajosh2> It can help get rid of some parentheses
17:49:21 <ddarius> dibblego: I'm not sure what you think TH does then.
17:49:26 <TeachmeHaskell> i see
17:49:28 <TeachmeHaskell> thank you
17:49:28 <c_wraith> @src ($)
17:49:28 <lambdabot> f $ x = f x
17:49:42 <dibblego> ddarius, I've no idea actually; just wondering how to best solve the problem
17:50:01 <dibblego> ddarius, I'm leaning toward standard haskell actually
17:50:24 <TeachmeHaskell> what does trancute pi do?
17:50:32 <TeachmeHaskell> i get 3
17:50:37 <megajosh2> You mean truncate?
17:50:42 <dibblego> TH looks like it allows metaprogramming on haskell source itself
17:50:43 <TeachmeHaskell> yes
17:50:44 <TeachmeHaskell> sorry
17:50:50 <megajosh2> It just takes off everything under 1 off of a number
17:50:55 <ddarius> dibblego: Yes, TH is more or less the same thing as Common Lisp macros.
17:51:04 <TeachmeHaskell> i see
17:51:06 <TeachmeHaskell> thnx
17:51:54 <dibblego> ddarius, how would you solve this problem if not with TH? http://paste.pocoo.org/show/267806/
17:52:57 <ddarius> dibblego: That's not a problem that's just some code.  Furthermore I see no connection to Haskell.  I have no idea what "this problem" is.
17:53:11 <TeachmeHaskell> megajosh, im playing here with the book "real world haskell"
17:53:13 <dibblego> ddarius, I wish to be able to create TupleN for any value N
17:53:14 <TeachmeHaskell> lol
17:53:46 <Saizan> dibblego: i'd use a java AST library with a pretty printer
17:53:50 <TeachmeHaskell> New to the language..
17:54:15 <Saizan> in whatever language has one
17:54:17 <dibblego> Saizan, I'd prefer brute Haskell to that
17:54:41 <megajosh2> TeachmeHaskell: Same here
17:54:55 <megajosh2> Only now am I really trying to make a project in it
17:54:59 <ddarius> I'd just write a simple script that spits out strings.  I still don't see any connection to Haskell.
17:55:15 <TeachmeHaskell> megajossh, my friend i just started..
17:55:16 <TeachmeHaskell> lol
17:55:34 <dibblego> what would you write that script with?
17:55:56 <ddarius> dibblego: Probably the quickest, easiest thing would be a vim macro.
17:56:18 <ddarius> But it would also be about two lines of Haskell and I'm sure it can probably be done in about two lines of Perl.
17:56:52 <dibblego> my real case is more verbose
18:06:12 <co_dh> in type theory , I don't understand why a Functor uniquely define a datatype, 
18:06:40 <co_dh> take data Nat = in ( 1 + Nat ) as an example, let F z = 1 + z , 
18:07:10 <co_dh> so Nat = in ( F Nat ) , but it's not obviously for me the Nat is uniquely determined by F. 
18:07:20 <co_dh> any help ? 
18:07:25 <monochrom> implicit requirement of "least fixed point".
18:07:34 <dolio> Nat is defined to be the initial algebra of F.
18:07:41 <dolio> Which is unique up to isomorphism.
18:08:16 <co_dh> dolio, I still don't understand. 
18:08:44 <co_dh> I know a fixed point of F is  x where F x = x, 
18:08:47 <monochrom> the requirement of "initial" is also implicit
18:09:13 <co_dh> monochrom: do you mean initial object of category theory? 
18:09:19 <monochrom> yes.
18:09:41 <co_dh> but how comes Nat is the initial object ? 
18:09:53 <monochrom> there is a category of F-algebras. its initial objects are called initial algebras. they are isomorphic to each other.
18:09:55 <megajosh2> @src fix
18:09:55 <lambdabot> fix f = let x = f x in x
18:10:01 <monochrom> we decree it so
18:10:33 <monochrom> oh, misread. it can be proved.
18:11:12 <co_dh> so there is a prove that Nat is the initial object of  F-algebra category?
18:11:18 <monochrom> yes
18:11:38 <co_dh> or uF ( fixed point of F ) is the inital object of F-algebra ? 
18:11:45 <Saizan> yep
18:11:59 <co_dh> thanks, is that prove hard ? 
18:12:19 <Saizan> http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt <- with ascii art for diagrams :)
18:12:37 <Saizan> but that's about the church encoding
18:12:40 <dolio> I'd probably rather go the other way.
18:12:49 <dolio> Nat is by definition the initial algebra of F.
18:12:54 <TeachmeHaskell> @src women
18:12:54 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:12:59 <dolio> You can prove that initial algebras are fixed points of F in a certain sense.
18:13:00 <TeachmeHaskell> lol
18:14:04 <dolio> F Nat also has F-algebra structure, where map in :: F (F Nat) -> F Nat
18:14:12 <co_dh> Saizan: thanks for that link :)
18:15:07 <Saizan> a fairly concrete way is to frame the whole thing in set theory, taking 1 to be the singleton set and + disjoint union, then after Tarski's theorem you can ask what happens when you calculate "lim(n -> oo) F^n({})"
18:16:21 <Saizan> (where {} is the empty set there)
18:16:29 <TeachmeHaskell> that is John Hughes papper why functional programming matters..
18:16:41 <kmc> sigh, seems bytestring-csv does not actually implement the standard csv format
18:16:58 <co_dh> Saizan: so it's keep add 1 into the result set, and that's Nat ! 
18:17:08 <ddarius> co_dh: It's not particularly hard to show that the normal inductive construction gives the initial object.  However, one generic result is Lambek's lemma that shows that an initial algebra over any category is a fixed point.
18:17:12 <co_dh> Saizan: that works for me , thanks.
18:17:22 <QtPlatypus> kmc: There is no real standard csv format, just a family of verents.
18:17:55 <Saizan> co_dh: np, try to see what the greatest fixed point would be :)
18:18:09 <ddarius> I believe Fokkinga gives the proof that omega colimits (least fixed points) are initial algebras in "Category theory: a calculational approach"
18:18:53 <TeachmeHaskell> hello gigajosh
18:19:18 <megajosh2> > PRIVMSG #haskell It's me!
18:19:18 <gigajosh2> It's
18:19:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:19:21 <megajosh2> whoops
18:19:31 <TeachmeHaskell> lol
18:19:35 <megajosh2> > PRIVMSG #haskell :It's me!
18:19:36 <gigajosh2> It's me!
18:19:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:19:41 <megajosh2> I better not do that in here
18:19:58 <Saizan> co_dh: ah, btw, in set theory the empty set is "emptier" than the empty type in haskell, so that way you only get the set of finite natural numbers, haskell's Nat has infinity = Succ infinity, as well as bottom = bottom in it
18:20:05 <kmc> QtPlatypus, there is in fact an RFC: http://tools.ietf.org/html/rfc4180
18:20:52 <ddarius> "It's genesis was the fact that writing a binary encoder for the x86 is an unredeemably disgusting experience."
18:21:20 <kmc> QtPlatypus, furthermore the output of Excel serves as a de facto standard closely matching the RFC
18:21:30 <co_dh> :t infinity
18:21:31 <lambdabot> Not in scope: `infinity'
18:21:45 <kmc> bytestring-csv doesn't handle quoted fields, empty fields, or quote escaping
18:21:52 <kmc> all of which are very common in csv in the wild
18:21:58 <TeachmeHaskell> :t women
18:21:59 <lambdabot> Not in scope: `women'
18:22:02 <TeachmeHaskell> lol
18:22:03 <co_dh> Saizan:  how can I verify your sentence in ghci? 
18:22:06 <QtPlatypus> kmc: Fair enough.
18:23:05 <co_dh> Saizan: what be greatest fixed point in F-algebra?
18:23:29 <Saizan> co_dh: if you define "data Nat = Zero | Succ Nat deriving Show; infinity = Succ infinity" you can then get ghci to go on printing Succs when you ask to to evaluate infinity
18:23:52 <Saizan> co_dh: it's be the final F-coalgebra
18:24:07 <co_dh> stream ? 
18:24:47 <Saizan> in haskell the greatest and least fixed points of a functor are the same thing
18:25:03 <Saizan> so it'd just be data Nat = Zero | Succ Nat
18:25:03 <TeachmeHaskell> functor?
18:26:00 <sshc> How do I strictly read the entire contents of a file?
18:26:04 <Saizan> if you take only total functions for your morphisms then you get that the least is the set of finite naturals, while the greatest includes infinity
18:26:58 <TeachmeHaskell> :)
18:27:26 <Saizan> sshc: Data.ByteString.readFile? or force the length of the String
18:27:54 <TeachmeHaskell> :t fst
18:27:55 <lambdabot> forall a b. (a, b) -> a
18:27:56 <co_dh> Saizan: thanks. time to leave. have a nice day everybody
18:28:01 <TeachmeHaskell> great!
18:28:04 <TeachmeHaskell> i like this bot
18:30:10 <ddarius> codata CoNat = CoNat { next :: Maybe CoNat }; unfoldCoNat :: (a -> Maybe a) -> a -> CoNat; unfoldCoNat f s = case f s of Nothing -> CoNat Nothing; Just s' -> CoNat (Just (unfoldCoNat f s'))
18:33:49 <TeachmeHaskell> :t enum
18:33:50 <lambdabot> Not in scope: `enum'
18:33:54 <TeachmeHaskell> mmm
18:34:55 <TeachmeHaskell> :t eq
18:34:56 <lambdabot> Not in scope: `eq'
18:35:30 <TeachmeHaskell> :t xs
18:35:31 <lambdabot> Not in scope: `xs'
18:36:15 <EvanR> illegal instance declaration all types must be of the form (T t1 ... tn) where T is not a synonym, use -XTypeSynonymInstances if you want to disable this
18:36:27 <EvanR> is this just another 'just enable it then' situations
18:37:12 <TeachmeHaskell> i see
18:38:00 <TeachmeHaskell> tx
18:38:52 <Saizan> EvanR: some consider using that bad style
18:39:40 <EvanR> whats good style
18:39:47 * TeachmeHaskell smiles
18:39:58 <EvanR> newtype and declare all the existing instances?
18:39:58 <Saizan> using the actual type i guess
18:40:49 <Saizan> are you aware that when you make an instance for the synonyms it also applies to the the type the synonym is referring to?
18:41:01 <EvanR> thats what i wanted
18:41:14 <EvanR> its a ReaderT AppState IO
18:41:42 <Saizan> ok, so you could as well write instance YourClass (ReaderT AppState IO) where ..
18:42:11 <EvanR> ok but everywhere else it uses the synonym
18:42:31 <EvanR> whats the point of a synonym
18:42:49 <Saizan> i often wonder that myself
18:43:05 * hackagebot text-icu 0.6.0.1 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.0.1 (BryanOSullivan)
18:43:11 <EvanR> it also still complains
18:43:26 <EvanR> wants flexible instances
18:43:26 <Saizan> (btw, with NewtypeDeriving you can get the instances for the newtype by "deriving" them)
18:43:38 <EvanR> is *that* considered bad style?
18:43:57 <Saizan> no, unless you get to OverlappingInstances :)
18:44:12 <EvanR> do you recommend a new type then
18:45:43 <Saizan> depens, with a newtype the whole thing will be easier to change in the future, but if it's nothing very serious i'd probably go with TypeSynonymInstances + FlexibleInstances
18:46:09 <EvanR> it actually doesnt make me use flexible instances if i use type synonym instances
18:46:41 <Saizan> heh, the check is very shallow then
18:46:52 <EvanR> ghc is funny
18:47:07 <EvanR> it 'can' do millions of things and puts stuff in to stop you
18:47:18 <EvanR> for the sake of standards?
18:47:25 <Saizan> anyhow, things that start with Flexible are just "at the time of haskell 98 we didn't know if these things were safe, but actually there's no problem with them"
18:47:27 <kmc> the type system is there to stop you too
18:48:00 <EvanR> i dont want to stop, i want to goooo!
18:48:22 <Saizan> you could be evil and use {-# OPTIONS -fglasgow-exts #-}
18:48:25 <kmc> use PHP
18:48:29 <kmc> {-# LANGUAGE PHP #-}
18:48:40 <EvanR> yeah this isnt feeling much like web development yet
18:49:10 <EvanR> if i used php i wouldnt be able to sanely implement anything
18:49:32 <kmc> there's some stuff that's off by default because it's more likely to be invoked by mistake than actually needed
18:49:44 <EvanR> thats what im afraid of
18:49:53 <EvanR> maybe im doing it wrong
18:49:59 <EvanR> better way may exist
18:50:20 <kmc> some stuff is off because turning it on will break nice properties you expect to hold
18:50:29 <kmc> like inference always finding a most general type
18:50:52 <kmc> or like the typechecker terminating successfully on all well-typed programs
18:51:34 <kmc> some of it steals syntax that might be used by legit H98 programs
18:52:49 <Saizan> we should have a wiki page listing how dangerous each extension is :)
18:53:15 <kmc> danger danger
18:53:17 <kmc> high voltage
18:53:38 <EvanR> right
18:55:45 <EvanR> :t liftIO
18:55:46 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
18:56:28 <EvanR> convert an IO action to an equivalent action in a monad supporting IO
18:59:10 <EvanR> i have two ReaderT over IO types, and a third is being forced on me by direct-fastcgi, this is seeming to be too much for me
18:59:21 <EvanR> what do i do
19:01:34 <EvanR> too many transformers
19:01:42 <EvanR> must switch to power rangers
19:02:53 <Saizan> you just need one liftIO
19:03:32 <EvanR> one per action definition that does basic IO
19:04:21 <EvanR> or uses an IO lib
19:04:25 <EvanR> hdbc
19:04:44 <EvanR> and if you wrap everything in a liftIO you cant use the outter monad anymore
19:04:46 <EvanR> ask and asks
19:05:06 <EvanR> so im seeing ask then liftIO pattern forming
19:05:10 <EvanR> >_<
19:06:02 <EvanR> something tells me im doing it wrong
19:10:53 <EvanR> well the nice thing is, after wrestling with these errors and it finally compiles, i run it, and it completely works
19:11:11 <EvanR> accepts requests, prints hello world each time
19:12:24 <kmc> probably overkill but http://tomschrijvers.blogspot.com/2010/03/bruno-oliveira-and-i-are-working-on.html is a cool idea at least
19:12:35 <kmc> for EvanR's problem or worse versions thereof
19:13:26 <TeachmeHaskell> :t maybe
19:13:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:13:31 <TeachmeHaskell> i see
19:13:47 <EvanR> i guess no one liked my power rangers idea
19:14:11 <EvanR> monad zipper
19:29:10 <EvanR> and the weekend is over
19:29:13 <EvanR> god dammit
19:29:44 <Axman6> long weekend, whooo!
19:31:25 <kmc> part of the weekend never dies
19:38:22 * EvanR eliminates one monad transformer, screw that
19:40:45 <ddarius> XN is beautiful.
19:40:47 <kmc> hackage is slightly broken?
19:40:49 <kmc> or maybe i'm just unlucky
19:40:54 <kmc> i uploaded a package, it hung
19:40:57 <EvanR> XN?
19:41:02 <kmc> it seems to be there now, but doesn't show in http://hackage.haskell.org/packages/archive/recent.html
19:41:50 <Bubbleboy> `let x = 1:x` is it a function?
19:42:02 <kmc> no
19:42:18 <Bubbleboy> what is x then?
19:42:19 <kmc> a list
19:42:26 <kmc> > let x = 1:x in x
19:42:27 <ddarius> EvanR: Xok's file system (system.)
19:42:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:42:37 <kmc> :t let x = 1:x in x
19:42:38 <lambdabot> forall t. (Num t) => [t]
19:43:06 <EvanR> a constant applicative form
19:43:16 <Bubbleboy> ok
19:43:25 * hackagebot rowrecord 0.1 - Build records from lists of strings, as from CSV files.  http://hackage.haskell.org/package/rowrecord-0.1 (KeeganMcAllister)
19:46:02 <kmc> ok there it goes
19:47:47 <Maxdamantus> let x = x + 1 in x
19:47:50 <Maxdamantus> let x = x + 1 in x 
19:47:52 <Maxdamantus> Eh
19:47:56 <Maxdamantus> > let x = x + 1 in x 
19:47:59 <lambdabot>   mueval-core: Time limit exceeded
19:48:22 <EvanR> its not lazy enough
19:48:31 <Maxdamantus> Heh.
19:48:41 <Maxdamantus> > fix (1+)
19:48:44 <Maxdamantus> :(
19:48:45 <lambdabot>   mueval-core: Time limit exceeded
19:49:07 <EvanR> > [0..]
19:49:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:49:23 <EvanR> > iterate (+1) 0
19:49:24 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:49:33 <kmc> it would work if you used inductive natural numbers
19:49:39 <kmc> data Nat = Zero | Succ Nat; instance Num Nat where ...
19:49:45 <kmc> that gives you a nice lazy (+)
19:49:57 <kmc> also you can do things like (genericLength [1..] > 5)  ==> True
19:50:15 <siracusa> Can anyone give me a hint what the ?enc does here, it looks like a hidden parameter or so: http://hackage.haskell.org/packages/archive/encoding/0.6.3/doc/html/System-IO-Encoding.html
19:50:40 <aavogt> kmc: version constraints on template-haskell are questionable, since you can't install a version that didn't come with ghc
19:51:07 <aavogt> siracusa: -XImplicitParams
19:52:03 <TeachmeHaskell> [0!...]
19:52:08 <TeachmeHaskell> lol
19:52:49 <TeachmeHaskell> [2!..]
19:52:54 <TeachmeHaskell> mmm
19:53:14 <EvanR> > [2!..]
19:53:15 <lambdabot>   A section must be enclosed in parentheses thus: (2 !..)Not in scope: `!..'
19:53:23 <EvanR> oh
19:53:27 <EvanR> ! is not factorial
19:53:28 <aavogt> siracusa: it's described somewhere in this page http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html
19:53:28 <TeachmeHaskell> i see
19:53:42 <TeachmeHaskell> yes it´s
19:53:51 <TeachmeHaskell> i was trying to
19:53:57 <EvanR> :t (!)
19:53:58 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
19:53:59 <aavogt> > let (!) = \x -> product [1..x] in 10 !
19:54:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:54:18 <TeachmeHaskell> i see
19:54:56 <aavogt> > let (!) = \x -> product [1..x] in (10 !)
19:54:57 <lambdabot>   3628800
19:55:22 <TeachmeHaskell> do you have to write all that code
19:55:28 <TeachmeHaskell> to generate 10!?
19:56:01 <aavogt> what's 10!?
19:56:05 <TeachmeHaskell> (10!)
19:56:14 <EvanR> TeachmeHaskell: http://www.willamette.edu/~fruehr/haskell/evolution.html
19:56:18 <TeachmeHaskell> factorial
19:56:31 <TeachmeHaskell> thnx EvanR
19:56:34 <EvanR> > fac 10
19:56:34 <lambdabot>   Not in scope: `fac'
19:56:43 <Saizan> there's no built-in factorial function
19:56:43 <EvanR> left as an exercise to the reader ;)
19:57:02 <TeachmeHaskell> ok
19:57:15 <EvanR> scroll down to the ending ;)
19:57:21 <EvanR> tenured professor
19:57:39 <kmc> aavogt, ok.  then it's a version constraint on ghc
19:57:42 <kmc> that might be what i want
19:57:44 <kmc> but good point
19:57:51 <TeachmeHaskell> EvanR that is great site
19:57:53 <TeachmeHaskell> woow
19:57:57 <TeachmeHaskell> Thank you
19:58:59 <aavogt> kmc: I'm pointing it out because there were issues for quite a while relating to TH library version constraints (trying to support multiple versions) breaking cabal install data-accessor-template
19:59:06 <kmc> hmm ok
19:59:12 <kmc> the solution is to have no version constraint?
19:59:29 * hackagebot gtfs 0.1 - The General Transit Feed Specification format  http://hackage.haskell.org/package/gtfs-0.1 (KeeganMcAllister)
19:59:33 <aavogt> I dunno, you're probably not in the same situation
19:59:39 <kmc> ok
19:59:43 <kmc> i'm pretty reachable if anyone has an issue
19:59:44 <Saizan> i think the template-haskell dep is the best route
20:00:23 <Saizan> the second-best is to use if !impl(ghc >= ..) buildable: False
20:00:47 <kamatsu> jdh30 decides to give us (rather, simon marlow) some credit:
20:00:50 <Saizan> do not use "build-depends: ghc >= .." please
20:00:51 <kamatsu> "Simon Marlow has written several far more sophisticated multicore-friendly garbage collectors for the Glasgow Haskell Compiler by himself."
20:01:19 <Saizan> kamatsu: comparing to what?
20:01:30 <kamatsu> he's saying that it's easy to write a multi-core friendly gc
20:01:39 <kamatsu> ("Just stop the world!" he says)
20:01:45 <kamatsu> (not exactly a solution, but anyway...)
20:01:49 <ddarius> If you're Simon Marlow.
20:04:01 <ddarius> Actually, as far as making the collection itself parallel, the problem is almost trivial.
20:06:33 <dibblego> > let z = \k -> (replicate <$> [1..] <*> k) in take 10 $ z ['a'..'c'] -- is there a better way to write this?
20:06:34 <lambdabot>   ["a","b","c","aa","bb","cc","aaa","bbb","ccc","aaaa"]
20:06:56 <EvanR> if i have a type A -> B -> C -> m (), is there an simple expression to stand for a 'noop' for this type
20:07:05 <EvanR> id? thats got the wrong type
20:07:27 <kmc> \_ _ _ -> return ()
20:07:35 <ddarius> > inits [1..]
20:07:36 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
20:07:56 <EvanR> bah ok
20:08:11 <ddarius> > transpose . map (tail . inits . repeat) $ "abc"
20:08:12 <lambdabot>   [["a","b","c"],["aa","bb","cc"],["aaa","bbb","ccc"],["aaaa","bbbb","cccc"],...
20:08:18 <ddarius> > concat .transpose . map (tail . inits . repeat) $ "abc"
20:08:19 <lambdabot>   ["a","b","c","aa","bb","cc","aaa","bbb","ccc","aaaa","bbbb","cccc","aaaaa",...
20:08:54 <dolio> > take 10 $ liftA2 replicate [1..] ['a'..'c']
20:08:55 <lambdabot>   ["a","b","c","aa","bb","cc","aaa","bbb","ccc","aaaa"]
20:10:18 <dibblego> I'm more of a <$>/<*> guy than liftA2, except when partially applying
20:11:31 <Axman6> @src inits
20:11:31 <lambdabot> inits []     =  [[]]
20:11:31 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
20:13:25 <augur> are there some mutually recursive functions which are irreducibly mutual?
20:14:53 <kmc> you can always push your mutual recursion inside another function with "let"
20:15:16 <augur> kmc: ok, but thats sort of cheating :P
20:15:31 <ddarius> Someone (who is not me) should run vacuum on my concat/transpose expression.
20:15:40 <augur> i mean is there a way to define some third function that has no mutually recursive behavior at all, just self recursion
20:16:07 <ddarius> augur: Just tuple things together.
20:16:10 <kmc> so you mean, can you encode all recursion in a language with only a single-value fixed point
20:16:28 <augur> kmc: maybe! i dont really know
20:16:45 <zachk> is there a drop in replacement for the list monad
20:16:47 <kmc> yeah, the point of smart-ass cheating answers is to point out where you need to specify the question further
20:16:49 <zachk> i keep overflowing stack
20:16:55 <augur> kmc: im just curious if there are any functions which are inherently indirectly recursive
20:17:00 <kmc> zachk, maybe you need control-monad-omega
20:17:01 <zachk> though im searching through >4billion elements 
20:17:21 <ddarius> zachk: Unless you are going very deep, that shouldn't be a problem.
20:17:22 <kmc> or LogicT, so you can cut
20:17:34 <zachk> i applied some strictness 
20:17:43 <zachk> seems to take longer to overflow stack now 
20:17:45 <ddarius> It's more likely the problem is elsewhere.
20:17:58 <zachk> im culling magma space by filtering for monoid laws 
20:18:08 <zachk> its not a very good approach 
20:21:23 <kmc> «let f x = g (p x); g y = f (q y) in f»  ==>  «let f ~(x,y) = f (q y, p x) in \x → fst $ f (x,⊥)» like so?
20:21:27 <kmc> does that work augur?
20:22:20 <augur> kmc: im not sure. what is it suposed to show
20:22:47 <kmc> that you can turn a pair of mutually recursive functions into a single self-recursive function
20:22:58 <kmc> (i claim, without having proved  that they're equivalent)
20:28:15 <dolio> let f = e1 ; g = e2 in e3 ==> let (f, g) = fix (\ ~(f, g) -> (e1, e2)) in e3
20:28:48 <dolio> This translation is actually given in the report.
20:30:30 <augur> kmc: what is ~(x,y) supposed to be?
20:31:02 <kmc> that's Haskell code
20:31:05 <augur> also, kmc, so basically all indirectly recursive functions can be made directly recursive
20:31:14 <augur> kmc: maybe, but i dont know what ~ is! :P
20:31:30 <kmc> augur, not just functions, dolio's definition should work for all recursive definitions
20:31:40 <kmc> ~p is a "lazy" / "irrefutable" version of p
20:31:50 <kmc> it always succeeds, and forces nothing
20:31:59 <augur> im not sure i understand but ok
20:32:08 <kmc> if and when any variable bound by p is forced, it will perform the pattern match
20:32:26 <kmc> if there's a constructor mismatch, you get an exception
20:32:53 <kmc> > case Nothing of (Just _) -> ()
20:32:54 <lambdabot>   *Exception: <interactive>:1:133-162: Non-exhaustive patterns in case
20:32:55 <kmc> > case Nothing of ~(Just _) -> ()
20:32:55 <lambdabot>   ()
20:33:00 <kmc> > case Nothing of ~(Just p) -> p
20:33:01 <lambdabot>   *Exception: <interactive>:1:133-162: Irrefutable pattern failed for pattern...
20:33:22 <kmc> it's useful on tuples because there's only one constructor; you know it must match
20:33:40 <kmc> so it defers forcing the tuple to whnf until its components are used
20:34:22 <kmc> «fix (\(x,y) → e)» will diverge no matter what 'e' is
20:34:32 <kmc> because fix finds the least fixed point, and ⊥ is a fixed point of «\(x,y) → e»
20:35:01 <kmc> ⊥ is a fixed point of every strict function
20:35:07 <kmc> by definition of 'strict function'
20:35:44 <tomberek> kmc, should matching on ~(a,b) be faster than (a,b) ?
20:36:20 <kmc> matching on ~(a,b) has zero runtime cost, it defers the cost until you force a or b
20:37:09 <Axman6> > fix (\(x,y) -> 1)
20:37:13 <lambdabot>   mueval-core: Time limit exceeded
20:37:14 <kmc> whether it's faster in total, i'm not sure and it depends on your program
20:37:27 <Axman6> > fix (\~(x,y) -> 1)
20:37:28 <lambdabot>   <no location info>: parse error on input `->'
20:37:40 <kmc> > fix (\(~(x,y)) -> 1)
20:37:41 <lambdabot>   (1,1)
20:37:44 <kmc> hmm that's ugly
20:37:59 <Axman6> o.O
20:38:05 <dolio> > let x \~ y = (x, y) in 5 \~ 6
20:38:06 <lambdabot>   (5,6)
20:38:16 <kmc> also wait how does that typecheck
20:38:18 <kmc> > 1 :: (Int,Int)
20:38:19 <Axman6> what the
20:38:19 <lambdabot>   (1,1)
20:38:25 <kmc> tricky caleskell
20:38:25 <Axman6> o.O
20:38:26 <Axman6> bloody Cale
20:38:36 <tomberek> kmc: i'm going in and replacing some (a,b) with ~ (a,b) to check, doesn't seem to make much difference
20:38:39 <kmc> > fix (\(~(x,y)) -> (3,4))
20:38:40 <lambdabot>   (3,4)
20:38:44 <ddarius> That is, probably, also a vector-space instance.
20:39:19 <augur> hm.
20:39:28 <augur> kmc: i dont quite understand, but thats ok xp
20:39:41 <kmc> which part?
20:39:42 <ddarius> fix . const = id
20:40:13 <augur> kmc: most of it. :)
20:40:16 <kmc> :t fix . const
20:40:17 <lambdabot> forall a. a -> a
20:40:24 <kmc> ok, well if you want more explanation on any part, just ask
20:40:47 * bos makes grumpy FRP-related noises
20:40:47 <kmc> i glossed over lots of stuff, like the question of which order we mean when we talk about least fixed points
20:41:16 <tomberek> kmc: in fact, it seems for my case, the ~(a,b) is actually slower
20:44:12 <kmc> «case x of ~p → e»  ===>   «let p = x in e»  or such
20:45:58 <kmc> augur, you might like http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice/ and http://conal.net/blog/posts/merging-partial-values/
20:46:19 <augur> will read
20:49:10 <siracusa> Is there a GHCi command for triggering a garbage collection?
20:49:59 <kmc> System.Mem.performGC :: IO () "Triggers an immediate garbage collection"
20:50:04 <kmc> by which they mean a major gc
20:50:42 * hackagebot xss-sanitize 0.1 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.1 (GregWeber)
20:50:44 * hackagebot libtagc 0.11.1 - Binding to TagLib C library.  http://hackage.haskell.org/package/libtagc-0.11.1 (AndyStewart)
20:51:54 <ddarius> tomberek: That's to be expected.
20:54:31 <augur> kmc: do you have any book recommendations that discuss mutual recursion, continuations, etc etc in a unified sense? something i could read that would cover a bunch of these kinds of issues?
20:54:50 <augur> just so that i might have a starting point for understanding, rather than bugging you guys all the time :p
20:54:55 <kmc> hmm i'm not sure
20:55:05 <siracusa> kmc: Shouldn't this work in GHCi if I do `x <- loadHugeDataStructure' and then `let x = (); performGC' to release the memory for x?
20:55:05 <Konoe> There's nothing special about mutual recursion...
20:55:25 <kmc> siracusa, i'm not sure
20:55:35 <kmc> shadowing a variable might not be enough to make its value unreachable
20:55:37 <augur> Konoe: no, but there are conceptual things relating mutual recursion to non-mutual recursion etc.
20:55:59 <Konoe> Yes, you can do that by using a tag?
20:56:27 <kmc> btw ghc code never releases memory back to the OS
20:56:29 <kmc> though that's fixed in GHC 7
20:56:49 <EvanR> by using mmap?
20:56:58 <kmc> i don't know how they fixed it
20:56:58 <Konoe> foo x = bar (f x); bar x = foo (g x)  <--> foobar (Foo x) = foobar (Bar (f x)); foobar (Bar x) = foobar (Foo (g x))
20:57:34 <EvanR> ive never heard of 'fixing' not returning memory to the os ;)
20:57:46 <ddarius> augur: Shriram's PLAI might be close enough to what you want and is a good read anyway.
20:57:47 <siracusa> kmc: Okay, that's the already answer to my problem.
21:00:43 <augur> ddarius: thank you :D
21:00:46 * hackagebot xss-sanitize 0.1.1 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.1.1 (GregWeber)
21:00:54 <kburke> hey, i have a basic question
21:01:09 <kburke> let's say in my .hs file I have the line data UnionAB = TagA a | TagB b
21:01:39 <kburke> and i try to load the file into ghci, i get the error "Not in scope: type variable a" and "Not in scope: type variable b"
21:01:49 <kburke> why do I get that error?
21:02:00 <ddarius> Because the type variables a and b are not in scope.
21:02:02 <kmc> because those type variables aren't in scope
21:02:07 <kmc> what type would a be?
21:02:10 <kmc> what type would b be?
21:02:16 <kmc> it's as if you wrote «f x = x + y»
21:02:19 <kmc> except at the type level
21:02:38 <kmc> type variables are bound on the left of '=' in a "data" declaration
21:02:38 <EvanR> if i have a value of type ReaderT A IO B, when i 'use' it with <-, is the B totally computed even if it didnt use IO ?
21:02:49 <augur> ok im off
21:02:50 <augur> see yas
21:02:55 <kmc> EvanR, look at the source for (>>=) for ReaderT
21:03:04 <ddarius> EvanR: No.
21:03:21 <ddarius> kmc: (>>=) is irrelevant (unless the monad is broken)
21:03:44 <kmc> kburke, so you can do «data UnionAB a b = TagA a | TagB b» or «data UnionAB = TagA Char | TagB Int»
21:03:47 <kburke> So you would have to write a function for example that specified a and b?
21:03:54 <ddarius> :t (>>=)
21:03:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:03:57 <kmc> or even something silly like «data UnionAB b a = TagA a | TagB b»
21:04:10 <ddarius> Since b is polymorphic it can't be evaluated (modulo seq) due to (>>=) at all.
21:04:16 <kmc> hmm
21:04:25 <ddarius> Whether it is or not depends on the specific action that you are executing.
21:04:56 <kmc> kburke, i'm not sure what you mean about 'writing a function'
21:05:03 <kburke> kmc: earlier in the file I have data Tree a = Leaf a | Node (Tree a) (Tree a), and a function toList :: Tree a -> [a] and that compiles
21:05:08 <kmc> yeah
21:05:13 <kmc> because the type variable 'a' is bound on the left hand side
21:05:19 <kmc> data Tree a = .... you can use 'a' here ....
21:05:24 <kmc> but if you just said
21:05:29 <kmc> data Tree = Leaf a | Node (Tree a) (Tree a)
21:05:32 <kmc> that's an error
21:05:34 <kburke> oh
21:05:43 <kmc> you're listing what the 'arguments' to the type constructor Tree are
21:05:43 <EvanR> can i get the lazy evaluation of the B if i go through an MVar ?
21:05:52 <kmc> just like saying  f x y = x + y
21:05:56 <EvanR> or does the MVar force the evaluation
21:05:58 <kmc> you can only use x and y there because you bound them on the left side
21:06:00 <ddarius> EvanR: B is no less lazy than anything else.
21:06:10 <kburke> ok
21:06:23 <EvanR> im wondering about the various ways IO makes stuff strict
21:06:29 <kburke> thanks
21:06:38 <ddarius> Other than something in the specific action requiring it's evaluation before execution of that action completes, B is in no way otherwise evaluated.
21:06:47 <ddarius> EvanR: IO doesn't make stuff strict.
21:07:11 <EvanR> makes sense
21:07:18 <EvanR> otherwise you cant put infinite list in a IORef
21:08:25 <ddarius> All the *Refs and *Vars are lazy (which is arguably the wrong default...)
21:08:47 <EvanR> it is?
21:08:56 <ddarius> In that case.
21:09:26 <EvanR> the default should be to full evaluate whatever you put in the IORef?
21:09:37 <kmc> in concurrent settings it often means that work is not done in the  thread you expected
21:09:46 <EvanR> in the case that its an infinite list
21:09:48 <kmc> full evaluation is expensive
21:09:50 <ddarius> It's not too common that you want the data in an IORef/MVar/TVar/TMVar/Chan unevaluated, and when you do you can easily use the Box data type to block the evaluation.
21:10:04 <EvanR> i thought you meant lazy was the wrong default
21:10:21 <EvanR> oh i keep missing 'nots'
21:10:24 <EvanR> arg
21:10:25 <ddarius> EvanR: Even if IORefs (or whatever) were strict you would still be able to place infinite lists in them.
21:10:43 <kmc> ddarius, which is to say «data Box a = Box a» ?
21:10:50 <ddarius> kmc: Yes.
21:11:17 <ddarius> EvanR: Strict /= "fully evaluated"
21:11:45 <EvanR> makes sense to me to spread out the work of constructing the data until the last minute, when you write it out to the disk or socket
21:12:01 <EvanR> without having to explicitly do that
21:12:34 <EvanR> if memory is collected during the writing
21:12:43 <kmc> concurrency is kind of the wrong tool for distributing work anyway
21:12:48 <c_wraith> EvanR: depending on the lag time between construction and output, that could be seen as a space leak
21:12:50 <kmc> but sometimes it can't be helped
21:13:26 <EvanR> confusing
21:13:31 <ddarius> Finding an error in the output of a channel after you've written half a file is not fun.
21:14:04 <EvanR> building a large string first then writing to disk is less bad in memory than lazy evaluation of the string?
21:14:16 <EvanR> during writing?
21:14:25 <ddarius> EvanR: That's not the case being discussed.
21:14:32 <kmc> EvanR, suppose it's (IORef Int)
21:14:48 <kmc> do you want to store 23795 or (1 + (1 + (1 + (1 + (1 + (1 + ....
21:14:53 <EvanR> i switched to that after strict /= fully evaluatead
21:15:32 <EvanR> kmc: yes numbers generally have strictness either necessarily or by using ! constructors
21:15:35 <kmc> hmm what if we could instantiate types strictly
21:15:42 <kmc> like you could write «IORef !Int»
21:16:00 <ddarius> kmc: You can in Clean.
21:16:09 <kmc> EvanR, if you make an IORef Int and then use modifyIORef (+1) a bunch of times, it will build a thunk tree
21:16:10 <ddarius> Or something like that.
21:16:31 <ddarius> (more like a thunk list...)
21:16:34 <EvanR> ddarius: an error half way
21:16:49 <EvanR> but its a pure computation, there are no errors
21:17:03 <ddarius> > 1 `div` 0
21:17:04 <lambdabot>   *Exception: divide by zero
21:17:21 <EvanR> you mean bugs?
21:17:24 <kmc> clearly we should have div :: (Integral a) ⇒ a → a → Maybe a
21:17:48 <EvanR> there are no unavoidable errors
21:18:12 <ddarius> Don't write programs.  All programming errors are thereby avoided.
21:18:24 <kmc> write programs and prove them correct
21:18:28 <bos> anyone happen to know any prolog in here?
21:18:33 <ddarius> kmc: You'll still have errors.
21:18:38 <ddarius> bos: Of course.
21:18:47 <kmc> ddarius, right, it's *you* that has the error, not the program
21:18:55 <EvanR> in math you can forget the phrase 'except zero' but it doesnt make the theorem wrong
21:18:56 <bos> ddarius: is there a SEQ operator in prolog?
21:19:08 <EvanR> you have to fix the expression of it
21:19:22 <ddarius> kmc: Or the proof system, or the various assumptions the model makes, or in the CPU, or ...
21:19:33 <EvanR> this digression doesnt answer my question about space leaks
21:19:46 <EvanR> lazy evaluation of the result is considered a space leak?
21:19:55 <ddarius> bos: I'm not even sure what you are talking about, so I'm going to say not in "standard" Prolog.  But you can usually define your own operators in Prologs.
21:20:09 <ddarius> And of course implementations provide many extensions.
21:20:21 <kmc> EvanR, it depends on what behavior the programmer wanted
21:20:36 <EvanR> he wanted the output 
21:20:37 <bos> ddarius: i'm not sure what i'm talking about either. i'm trying to read a paper that contains a chunk of code that looks vaguely like prolog, where i've no idea what they're trying to express.
21:20:40 <kmc> when something is lazy and is consuming a lot of space, when you wanted it to be strict and consume little space, that's a space leak
21:20:47 <kmc> note that "lazy = lots of space" is not always the case
21:20:53 <kmc> sometimes the thunk is far smaller than the result
21:20:58 <bos> ddarius: fun, eh?
21:21:20 <ddarius> bos: If it is talking -about- Prolog, SEQ might represent the conjunction, e.g. p(X), q(Y) (the ,)
21:21:48 <kmc> are there any interesting connections between backtracking logic programming and SAT/SMT solving?
21:21:56 <bos> ddarius: no, it's talking about complex event processing.
21:22:13 <ManateeLazyCat> @tell juhp I have push new patches to gio and manatee. From now, except bug, I won't touch gtk2hs code.... enjoy! :)
21:22:13 <lambdabot> Consider it noted.
21:22:14 <ddarius> bos: Then I suspect SEQ is a "constructor" for a complex event.
21:22:32 * ddarius was actually considering reading up on some complex event processing very recently.
21:22:40 <EvanR> kmc: well if the output is the size of a webpage, is that a little space?
21:22:47 <EvanR> better to strictly evaluate it?
21:22:52 <ddarius> Probably won't really fit the use-case I have in mind though.
21:23:22 <kmc> EvanR, is an orange better than a pear?
21:23:28 <ddarius> If something consumes a lot of space when it needn't, that is usually considered a space leak.  Eager or lazy is irrelevant.
21:23:32 <EvanR> kmc: no
21:24:06 <bos> ddarius: it's kind of an awful little field.
21:24:06 <kmc> ddarius, but the property of "need to hold onto this" is of course undecidable, even at runtime
21:24:28 <kmc> so all of our programs have space leaks
21:24:31 <EvanR> in the basic case you need to output the contents of a file on the disk, that can take far less memory than the file contents
21:24:51 <EvanR> in more complex case you need to substitute into the content, that can also taken far less contents than the file
21:24:58 <kmc> at least sufficiently complicated ones will
21:24:59 <ddarius> kmc: Fine, insert a "provably" in the appropriate place if you like or (equivalently) a "demonstrably."
21:25:06 <EvanR> if i knew how the memory was being used
21:26:20 <c_wraith> EvanR: what's common is that an unevaluated thunk sits around for a while, holding on to many other data structures that it would release if it was evaluated.
21:26:42 <ddarius> @google lag drag void
21:26:43 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.30.1219&rep=rep1&type=ps
21:27:28 <EvanR> c_wraith: ah, and theres no way to know which to evaluate 'yet'
21:27:34 <EvanR> selective evaluation
21:27:46 <EvanR> theres strict constructors
21:28:02 * ddarius recommends the above paper.
21:29:26 <EvanR> mmmm ghost script
21:29:52 <ddarius> I highly suspect that changing the "type=ps" to "type=pdf" will produce a different result.
21:31:13 <EvanR> so basically, we should do whatever is most straightforward and memory profile to determine possible memory optimizations
21:31:51 <ddarius> No.  You should put a little thought into the operational behavior of your code as you write it so that you don't have memory leaks that you have to profile.
21:32:18 <EvanR> but now i dont know what 'leak' means
21:32:28 <EvanR> because its eventually collected
21:32:31 <kmc> <ddarius> If something consumes a lot of space when it needn't, that is usually considered a space leak.
21:32:38 <ddarius> EvanR: Did you read the paper?
21:32:46 <EvanR> trying to!
21:32:57 <EvanR> a leak usually doesnt run backwards
21:33:01 <EvanR> needs a different name
21:34:51 <kmc> http://www.leekspin.com/
21:35:21 <EvanR> ._.
21:46:37 <augur> kmc: do you know of any good books discussing non-deterministic algorithms, and what you might call "inherent" non-determinism?
21:47:07 <roconnor> [00:10] <ddarius> EvanR: Even if IORefs (or whatever) were strict you would still be able to place infinite lists in them.
21:47:13 <roconnor> [00:10] <ddarius> EvanR: Strict /= "fully evaluated"
21:47:27 <roconnor> by strict do we mean head normal form?
21:48:00 <EvanR> i was thinking of IO [Int]
21:48:53 <roconnor> [00:08] <ddarius> All the *Refs and *Vars are lazy (which is arguably the wrong default...)
21:49:26 <roconnor> if strict means head normal form, then making *Refs and *Vars stricts doesn't mean much when they hold Algebraic Data Types.
21:53:57 <kmc> you mean like http://en.wikipedia.org/wiki/Randomized_algorithm augur?
21:54:44 <kmc> it still does roconnor
21:54:57 <kmc> because many operations on algebraic data do not yield a constructor until a significant amount of work has been done
21:55:01 <augur> kmc: no no, just an algorithm which can either be written with actual nondeterminism, whereby the various possible paths to compute it are tried in parallel, or which when written deterministically, has a backtracking component to the algorithm
21:55:06 <roconnor> kmc: really?
21:55:19 <ezyang> "Consider, for instance, halts x = { True | False }" 
21:55:20 <kmc> sure
21:55:27 <ezyang> :-) 
21:55:41 <kmc> augur, ah
21:55:43 <augur> for instance, factorial is not inherently nondeterministic, but parsing general-case CFG recognizing is
21:56:01 <augur> s/parsing//
21:56:06 <kmc> it's still deterministic
21:56:09 <kmc> the input determines the output entirely
21:56:17 <augur> sure, but it implements a backtracking component
21:56:21 <augur> whereas factorial doesnt
21:56:44 <kmc> do you claim CFG recognizing can't be done without something that looks like backtracking?
21:57:22 <augur> i dont know if it can. im pretty certain it cant. i think anything that looks like it doesnt have backtracking ends up having something equivalent to backtracking
21:57:55 <kmc> so CFG-parsing is "backtracking-complete"?
21:58:00 <augur> but thats why im asking if you know of any books that discuss algorithms for non-determinacy
21:58:03 <kmc> can we phrase any backtracking problem as CFG parsing
21:58:11 <kmc> i don't know of a book on this, sorry
21:58:16 <kmc> maybe logic programming books
21:58:34 <kmc> roconnor, Int is algebraic in GHC, and (+) on Int does not produce the I# constructor until the machine-level addition is done
21:58:37 <augur> kmc: well, no, CFG recognition certainly isnt backtracking complete, since CSL recognition also requires backtracking
21:58:41 * ezyang wonders if the Sipser covers this. 
21:58:58 <roconnor> kmc: give me a break
21:59:35 <kmc> i can come up with a more complicated example, if that's too simple to be satisfying
21:59:59 <roconnor> You know by Algebraic I'm excluding Int
22:00:05 <kmc> i don't know that at all
22:00:08 <kmc> you didn't define your term
22:00:22 <kmc> anyway
22:00:34 <kmc> f n | isPrime n = Just () | otherwise = Nothing
22:00:41 <kmc> now the type is (Maybe ())
22:00:43 <kmc> that's algebraic, yes?
22:01:01 <roconnor> yes
22:01:59 <kmc> and if we «writeIORef r $ f (2^43112609 - 1)»
22:02:06 <kmc> and we have lazy IORefs
22:02:10 <kmc> then the action completes immediately
22:02:21 <kmc> but if we have head-strict IORefs then it will perform the primality test before continuing
22:03:21 <EvanR> what if it was not strict numbers
22:03:34 <EvanR> normal data
22:03:44 <kmc> this has nothing to do with numbers
22:04:02 <kmc> your numbers could be totally lazy inductively defined Peano naturals
22:04:08 <EvanR> well im confused because he said 'not Int' you said 'too bad' and also used an example about prime numbers
22:04:21 <kmc> but the type being pattern matched is (Maybe ()), not Int
22:04:42 <kmc> jeez you guys are picky ;P
22:04:55 <kmc> f xs | all (=='z') xs = Just () | otherwise = Nothing
22:05:23 <kmc> there's no numbers anywhere
22:05:52 <roconnor> kmc: it's okay with me if you use Bool as your example
22:05:55 <kmc> if we force (f xs) to whnf then we also end up forcing the spine of xs, and the chars inside it, and thus doing any amount of further work
22:05:57 <roconnor> it is an algebraic data type
22:06:15 <roconnor> kmc: anyhow, your point is somewhat well taken
22:06:16 <kmc> okay
22:06:22 <kmc> writeIORef r (all (=='z') xs)
22:06:28 <EvanR> does that not depends on the definition of all
22:06:32 <augur> kmc: i mean, for example, recognizing the LL(1) languages is possible without backtracking, right
22:06:52 <augur> but its nevertheless possible to implement a parser for an LL(1) language in a backtracking fashion
22:07:04 <kmc> well actually, if all is smart then we don't force the whole of xs if we find a non-'z' character
22:07:12 <EvanR> @src all
22:07:12 <lambdabot> all p =  and . map p
22:07:13 <kmc> we'd give up there
22:07:52 <kmc> anyway the point is that whnf evaluation of one value can force arbitrarily much evaluation elsewhere
22:08:06 <EvanR> @src and
22:08:07 <lambdabot> and   =  foldr (&&) True
22:09:14 <EvanR> @src foldr
22:09:14 <lambdabot> foldr f z []     = z
22:09:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:09:31 <EvanR> ok whnf got it
22:09:44 <kmc> the only reason that seq and !-fields and such have any effect at all
22:10:13 <EvanR> now none of this is relevant 
22:10:18 <kmc> is that they introduce "artificial" data dependencies
22:10:27 <EvanR> because who cares if you do the work to make the first element or not
22:10:32 <EvanR> if there are 1000 elements
22:11:00 <kmc> writeIORef r (reverse xs)
22:11:09 <kmc> now to get "the first element" you have to traverse the whole spine of xs
22:11:11 <kmc> that's a lot of work
22:11:22 <augur> is there any way to leave a delayed message for someone?
22:11:30 <EvanR> time delayed message ;)
22:11:43 <kmc> augur, lambdabot's tell command?
22:11:47 <kmc> @tell augur like so
22:11:47 <lambdabot> Consider it noted.
22:11:53 <EvanR> kmc: i never said it was universally applicable
22:11:55 <augur> i was about to say that but i decided i dont want it to be delayed a specific amount of time
22:11:55 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
22:11:56 <augur> ok.
22:12:25 <xiackok> there is any tutorial or description for !- fields
22:12:27 <xiackok> ??
22:12:32 <kmc> EvanR, maybe we're not talking about the same thing
22:12:39 <EvanR> im pretty sure were no
22:12:40 <EvanR> t
22:13:11 <EvanR> basically im thinking of the case where you put a list in a ref, and this list is made by basically nested concats
22:13:28 <EvanR> it seems useless to worry about the head evaluation
22:13:29 <kmc> okay
22:14:06 <kmc> right, the work done by evaluating (x1 ++ (x2 ++ (x3 ++ .... to whnf is O(1)
22:14:26 <kmc> and the work done by evaluating (((x1 ++ x2) ++ x3) ++ ... is O(k) where k is the number of (++)
22:14:39 <EvanR> @src concat
22:14:39 <lambdabot> concat = foldr (++) []
22:15:16 <kmc> in that situation a whnf-strict ref doesn't make much difference
22:15:27 <EvanR> which one is foldr :`(
22:15:33 <kmc> xiackok, http://www.haskell.org/onlinereport/decls.html#strictness-flags
22:15:40 <kmc> > foldr f z [a,b,c]
22:15:40 <lambdabot>   f a (f b (f c z))
22:15:56 <EvanR> ok O(1)
22:16:42 <EvanR> so in any case were not worried about it evaluating the entire list
22:16:49 <EvanR> IORef or not, strict or not
22:17:08 <EvanR> but in the case of certain IO actions it returns the entire list and not a bunch of ++
22:17:21 <kmc> xiackok, see http://www.haskell.org/tutorial/moretypes.html section 6.3
22:17:42 <ologNation> All 3-cycles are conjugate in A_5
22:17:46 <EvanR> im guessing its possible to write your own IO actions that do return a bunch of ++ (without interleaveIO)
22:18:05 <EvanR> is that true?
22:18:05 <kmc> «return ((a ++ b) ++ c)»
22:18:27 <EvanR> will >>= in IO force the whole thing? in case of (a ++ (b ++ c))
22:18:35 <xiackok> kmc, its about strictness?? so there is any details about strictness ? how can i use and when?? sorry about bad eng.
22:18:44 <kmc> nope EvanR,   return [1..] >>= print
22:18:46 <kmc> try it
22:19:01 <kmc> IO isn't about strict evaluation.  that's a misconception from the belief that execution = evaluation
22:19:06 <kmc> IO is about execution order, not evaluation order
22:19:18 <kmc> xiackok, i think the Gentle Introduction chapter probably has what you want
22:19:23 <EvanR> oh
22:19:26 <kmc> it might be in RWH too
22:19:28 <xiackok> kmc, thanks
22:19:53 <kmc> the basic idea is that if i write «data Foo = MkFoo !Bar»
22:19:58 <EvanR> my misconception was based on how readFile is IO String and strict and getContents was IO String and lazy but black magical
22:20:11 <kmc> then writing «MkFoo xyz» is actually like «xyz `seq` MkFoo xyz»
22:20:24 <EvanR> so i figured the norm was IO actions return full lists
22:20:28 <kmc> in other words, the MkFoo constructor is not produced until the !-field is in whnf
22:20:59 <EvanR> which makes sense since there exists no infinite lists in the real world to I (as in IO)
22:21:05 <kmc> the black magic of getContents is not that it returns a lazy list but that it returns a lazy list *whose future depends on execution*
22:21:26 <kmc> there's still lots of useful non-black-magic IO actions that produce lazy list
22:21:40 <EvanR> ok i got it
22:21:49 <kmc> since IO is contagious
22:22:01 <EvanR> and do like the default of lazy MVars and IORefs
22:22:03 <kmc> you might want to do a finite amount of input, then produce an infinite value based on that
22:22:17 <EvanR> if your thing needs to be forced, then force it. dont make it a global policy on something
22:22:24 <kmc> like getting an infinite list of pseudorandom numbers, using the clock as a seed
22:22:30 <kmc> yeah
22:22:41 <kmc> Haskell is lazy by default most places, so i think the default MVar etc. should be too
22:22:53 <kmc> however there is http://hackage.haskell.org/package/strict-concurrency
22:23:13 <EvanR> im thinking of turning a lazy webpage via an mvar to write to the fcgi channel
22:23:15 <EvanR> returning
22:24:15 <kmc> the strict-concurrency functions have NFData constraints on everything, but the code looks like it reduces to whnf only
22:24:23 <kmc> and reducing to nf would be a bit mad
22:24:29 <kmc> so what's with that
22:25:10 <EvanR> thats what i thought this package was for
22:25:11 <EvanR> nf
22:25:17 <kmc> me too until just now
22:25:23 <kmc> but the docs and code say whnf
22:26:03 <kmc> anyway i prefer making this explicit at the call site
22:26:08 <kmc> for example it's not hard to write
22:26:13 <kmc> writeChan ch $! x
22:26:17 <EvanR> would nf mean it tries to generate the entire infinite list
22:26:21 <kmc> yeah
22:26:37 <EvanR> that seems like a bigger spaceleak than whatever this package is talking about
22:26:43 <kmc> right
22:26:53 <kmc> don't try to reduce infinite lists to normal form
22:27:07 <kmc> i mean NFData is totally inappropriate for infinite structures
22:27:13 <kmc> i don't think that invalidates its usefulness in other situations
22:27:26 <kmc> and if you passed in a large finite list, it would walk the whole thing before convincing itself that the list was already evaluated
22:27:29 <kmc> so it's a good way to waste a lot of time
22:28:26 <EvanR> strict is tricky!
22:28:28 <kmc> [1..] `seq` ()  =  ()
22:28:41 <kmc> [1..] `deepseq` () = ⊥
22:29:12 <EvanR> btw what does = mean again :)
22:29:24 <kmc> depends who you ask ;P
22:29:35 <EvanR> its always used with bottom
22:29:42 <kmc> the equals sign?
22:29:42 <augur> kmc: is every CF language an LL(*) language?
22:29:47 <kmc> augur, i have no idea
22:29:50 <augur> bah :P
22:30:03 <EvanR> and on the face it, it looks like childish internet language like you = awesome
22:30:10 <ppavelV6> he-he :) told my brother who is haskell newbie about lazy IO and its dangerous :) He felt like he's betrayed :)
22:30:15 <kmc> haha
22:30:59 <kmc> i mean in haskell we use = to define values by specifying one or more equations
22:31:13 <EvanR> yeah like in algebra class
22:31:26 <EvanR> i guess its like in calculus class they throw a = infinity at you and expect you to be ok with it
22:31:33 <kmc> perhaps i should have written ==, but that's an actual function returning Bool, and you can't do decidable equality for ⊥
22:31:38 <kmc> probably i should have written ≡
22:32:15 <Funktorsalat> ppavelV6: by the language..?
22:32:39 <ppavelV6> Funktorsalat: by the language that claims to be safe :)
22:32:57 <EvanR> im tired, hungry, need to brush my teeth, and still havent devoted much time to this damned haskell website
22:33:05 <EvanR> and its 1230AM
22:33:09 <EvanR> and i have work in the morning
22:33:12 * EvanR goes insane
22:33:20 <Funktorsalat> :(
22:33:32 <EvanR> stupid distractions
22:33:34 <kmc> what's the site?
22:33:56 <ologNation> I just cabal installed HaskellForMaths. 
22:34:15 <ologNation> In the ~/.cabal directory, I find .hi files for each module, but no .hs files. 
22:34:15 <EvanR> it will be like a forum
22:34:21 <ologNation> Is there a way to cabal install the source for this package
22:34:21 <EvanR> to run rpgs on
22:34:22 <ppavelV6> Funktorsalat: we need to fork a library :) I'm ashamed to explain to people things like this and other like Num class, fail in Monad, why Monads aren't Applicative etc :) 
22:34:24 <ologNation> so that I can study it? 
22:34:46 <Funktorsalat> ologNation: cabal unpack
22:34:52 <ologNation> Funktorsalat, Thx!
22:40:15 <ologNation> Is there a way to do computations in this channel using HaskellForMaths? 
22:41:52 <augur> kmc: do you know of any work done on, shall we say, trans-computation optimality?
22:41:59 <mm_freak> what's a codensity?  what's the difference between 'Codensity m a' and 'm a'?
22:42:40 <mm_freak> the practical difference, that is…  i don't know much CT
22:43:34 <Maxdamantus> Could IO be implemented using a list, rather than the IO monad?
22:43:59 <mm_freak> ok, i think i see the difference
22:44:18 <mm_freak> Codensity means CPS =)
22:44:28 <Maxdamantus> So something like "an instruction" followed by a "list of instructions"
22:44:31 <Maxdamantus> Hm.
22:44:34 <mm_freak> Maxdamantus: isn't that even the way it used to look like before monads?
22:44:50 <EvanR> Maxdamantus: no
22:44:59 <mm_freak> main :: [Request] -> [Response]  -- something like that
22:45:32 <EvanR> Maxdamantus: not unless you added more structure
22:45:38 <EvanR> which is what monads do
22:45:56 <EvanR> Maxdamantus: example how do you make the control 'when' ?
22:46:17 <Funktorsalat> that doesn't cover alternating request/response sequences
22:46:47 <Maxdamantus> Mmm.. Can't think how would be simply done some sort of conditional thing.
22:47:14 <kmc> the "monad" part of "IO monad" is not essential though
22:47:23 <EvanR> if something then commands123 else commands23
22:47:28 <Funktorsalat> but even if you use a better type, forkIO tends to be a problem
22:47:32 <EvanR> something may depends on previous input
22:47:40 <EvanR> your list thing doesnt sound like you can get at that
22:47:48 <kmc> monads are not the 'special sauce' that allows IO in an otherwise pure language
22:47:50 <Maxdamantus> Yeah.
22:48:10 <kmc> burrito with special sauce
22:48:26 <EvanR> monadic burrito combinators
22:48:34 <EvanR> new at taco bell
22:48:59 <kmc> combination pizza hut and taco bell?
22:49:07 <Maxdamantus> curry burrito?
22:49:13 <EvanR> i was memed that in real life but i dont know where its from
22:49:18 <kmc> i think boloco makes one of those
22:49:37 <kmc> EvanR, http://www.youtube.com/watch?v=Vyfc10qDcR4
22:49:52 <EvanR> ignorance is bliss
22:50:14 <EvanR> we have several combination pizza hut taco bells, i prefer to be able to refer to them at will without invoking the internet
22:50:52 <kmc> http://www.youtube.com/watch?v=su0U37w2tws not musical
22:51:08 <EvanR> lol 'choose your meme'
22:51:14 * kmc has been to the particular CPH&TB named in the song
22:51:52 <EvanR> those rats are cute
22:52:15 <kmc> "i saw a pack of wild dogs take over and successfully run a Wendy's"
22:53:54 <EvanR> dammit sleepy time tea, cool off
22:54:15 <augur> kmc: yes? no? D:
22:54:24 <kmc> augur, i'm not sure what you meant
22:56:40 <EvanR> how do i generate a 'unique' sha1 hash?
22:56:50 <augur> kmc: ah. so like, imagine you have a function defined like so: f x = [y | y <- g x, all (\y' -> fitness y' <= fitness y) (g x)]
22:57:10 <kmc> EvanR, http://en.wikipedia.org/wiki/Guid
22:57:26 <siracusa> What is the appropriate method to convert a ByteString back to a String, use show?
22:57:37 <EvanR> siracusa: use a decoder
22:57:41 <kmc> siracusa, that is the problem of Unicode decoding
22:57:51 <kmc> ByteString doesn't represent text, it represents binary data
22:58:18 <siracusa> Hhm, I did fromString before.
22:58:26 <kmc> which package?
22:58:32 <EvanR> Database servers can use GUIDs to create unique row identifiers, solving the chicken and egg problem inherent with sequential row IDs.
22:58:39 <kmc> utf8-string provides fromString
22:58:45 <EvanR> the hell is this referring to
22:58:47 <kmc> which is useful if your ByteString has utf8-encoded unicode
22:58:57 <siracusa> kmc: It's in the base package, Data.String.
22:59:10 <bos> ah, doing it wrong.
22:59:39 <kmc> siracusa, that's not encoding.  it just truncates every character above 255
22:59:56 <kmc> does the data in your ByteString represent text, or binary data?
23:00:10 <siracusa> kmc: text
23:00:17 <kmc> in what character encoding?
23:00:32 <EvanR> 'ascii' ;)
23:00:35 <kmc> you might want to use the "text" package instead of ByteString
23:00:37 <siracusa> uft8 I think
23:00:56 <kmc> not if you used fromString
23:01:01 <kmc> from Data.String
23:01:11 <siracusa> I'm using the XML package which returns the text as String.
23:01:15 <kmc> ah
23:01:23 <kmc> you can use utf8-string to go between String and utf8-in-ByteString
23:01:47 <siracusa> okay
23:03:43 <EvanR> kmc: this wikipedia page is a joke
23:04:27 <kmc> which
23:04:33 <EvanR> Guid
23:04:47 <kmc> ok
23:04:53 <EvanR> it lists so many uses for microsoft guid that are absurd
23:05:06 <kmc> why?
23:05:10 <kmc> MS does like their GUIDs yes
23:05:11 <EvanR> i dont know why
23:05:21 <EvanR> ask the authors
23:07:08 <EvanR> check this nugget out, 'sequential guids' can be generated by generating one normally and replacing part of it with the datetime. 
23:07:35 <EvanR> 'while this means guids generated in the same fraction of a second may be duplicated random guy says this has little real world effect'
23:07:52 <EvanR> messing with the scheme like that effectively reduces its power
23:08:07 <kmc> haha
23:08:51 <EvanR> 'has the added benefit of being able to extract the date and time of generation later if necssary'
23:08:54 <EvanR> Dx
23:09:10 <lucca> ... that's asinine.  Just use version1 UUIDs if you need that
23:09:30 <EvanR> since it also uses mac address, 'a document can be tracked back to the computer that created it'
23:11:00 <EvanR> and what on earth is the chicken and egg problem of sequential numeric primary keys in databases?
23:11:06 <EvanR> that guis solve
23:11:09 <EvanR> d
23:12:50 <EvanR> weird this uuid package for haskell specifically omits version 4 (random)
23:32:00 <jamy> hi people!
23:32:10 * EvanR generates 20 bytes of randomIO data and hashes it then
23:32:39 <chrisdone> Twey: check this http://hpaste.org/40152/javascript_parser_monad
23:32:50 <jamy> EvanR: my respect!
23:36:24 <siracusa> EvanR: Is Data.Unique not sufficient for your problem, create a new Unique and then hash it?
23:36:44 <EvanR> how unique is Unique
23:37:04 <EvanR> what if the program crashes
23:38:01 <siracusa> EvanR: Yeah, program crash might be a problem.
23:38:23 <EvanR> grumble
23:39:15 <EvanR> i will render randomly generate characters to a string
23:39:32 <EvanR> its annoying that Word8 has no Random instance
23:55:14 <kamatsu> if i have module A that imports some type names *only* from module B
23:55:18 <kamatsu> does GHC still link them?
23:55:40 <kamatsu> seeing as the type is not preserved at runtime.
23:55:44 <kamatsu> i think it shouldn't.
23:57:21 <Ytinasni> kamatsu: if you mean "will any objects from B appear in the final binary", that's up to your linker. GNU ld won't include them.
23:58:26 <kamatsu> excellent
23:58:30 <kamatsu> thanks for the info 
