00:00:25 <copumpkin> kmc, dolio: here's another related one: http://hackage.haskell.org/trac/ghc/ticket/3651
00:03:21 <kmc> interesting
00:04:13 <kmc> calling it 'unsafe' is an overstatement, i think
00:05:07 <kmc> it's a function defined by incomplete pattern matching and furthermore the only cases given are actually impossible
00:06:51 <kmc> seems like expected behavior to me
00:07:33 <kmc> calling it with U U is a runtime pattern match failure
00:08:03 <kmc> calling it with B U is a type error, which it would be whether or not you wrote that case
00:12:54 <kmc> > let x :: (Int ~ Char) => a; x = undefined
00:12:55 <lambdabot>   not an expression: `let x :: (Int ~ Char) => a; x = undefined'
00:12:58 <kmc> > let x :: (Int ~ Char) => a; x = undefined in x
00:12:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:12:59 <lambdabot>         against inferred type...
00:13:11 <kmc> > let x :: (Int ~ Char) => a; x = undefined in ()
00:13:12 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:13:13 <lambdabot>         against inferred type...
00:19:41 <Axman6> what's ~ do?
00:19:55 <copumpkin> type equality
00:20:37 <copumpkin> > let x :: (Int ~ a, a ~ Char) => a; x = undefined in ()
00:20:38 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:20:38 <lambdabot>         against inferred type...
00:20:44 <Axman6> :\
00:26:15 <Cale> Axman6: It's most useful in conjunction with type families, where you could write constraints like Foo a ~ Bar b where Foo and Bar are type families 
00:27:02 <copumpkin> you can use it to write a closed typeclass, too (although you could also use a GADT for it)
00:31:38 * hackagebot checked 0.1.0.1 - Bounds-checking integer types.  http://hackage.haskell.org/package/checked-0.1.0.1 (AntoineLatter)
00:32:31 <copumpkin> has anyone brought up 
00:32:40 <copumpkin> using GADTs for closed typeclasses yet?
00:32:53 <copumpkin> unfortunately GHC still has no knowledge of the closed-ness
00:32:54 <copumpkin> :(
00:32:55 <lispy> copumpkin: I don't recall if I sent the emails but the idea occured to me a while back
00:33:06 <lispy> Circa 2007
00:33:15 <copumpkin> ah
00:33:25 <lispy> It made me wonder if GADT type checking was decidable
00:33:33 <lispy> I think there was a paper saying so recently
00:33:38 * copumpkin hadn't even heard of haskell at the time :P
00:33:52 <lispy> fast learner
00:34:09 <lispy> I started haskelling in about 2003
00:34:13 <lispy> ?quote skynet
00:34:13 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
00:34:28 <copumpkin> I wish I had. It would've made my early CS experience quite different
00:34:38 <lispy> That quote is based on some collaboration between dons, myself and someone else
00:34:58 <copumpkin> ah :)
00:45:16 <kmc> copumpkin, istr JHC whole-program-compiles each typeclass into a GADT with one term per instance
00:46:09 <dolio> I think it's more like there's an open GADT that keeps track of each type.
00:46:13 <kmc> which among other things would give it a safe implementation of Typeable
00:46:13 <kmc> ok
00:46:22 <dolio> Then type classes are compiled into functions that do case analysis on the type.
00:46:26 <kmc> i don't even remember if it supports GADT at source level
00:46:33 <dolio> I don't, either.
01:03:37 <rschnck> I feel like this code is ridiculous: http://pastebin.ca/1943353
01:03:46 <rschnck> There has to be a *much, much, much* more elegant way
01:04:25 <ivanm> list monad!
01:04:53 <ivanm> @type let cross xs ys = do { x <- xs; y <- ys; return (x,y) } in cross
01:04:54 <lambdabot> forall (m :: * -> *) t t1. (Monad m) => m t -> m t1 -> m (t, t1)
01:05:01 <rschnck> Oh, I can't use it
01:05:05 <ivanm> why not?
01:05:07 <rschnck> I'm only allowed basic list functions
01:05:13 <rschnck> head, tail, ++, :
01:05:13 <ivanm> ahhh
01:05:23 <dobblego> concatMap
01:05:25 <ivanm> rschnck: you're missing base cases...
01:05:34 <ivanm> dobblego: yeah
01:05:35 <rschnck> ivanm: I know :P
01:05:46 <rschnck> But is it "reasonable"
01:05:48 <rschnck> For my restrictions
01:05:49 <ivanm> rschnck: OK, for each x, get each y and make a pair
01:05:53 <rschnck> It just seems silly.
01:07:27 <rschnck> ivanm: Yes, but that's what I tried to do
01:07:34 <rschnck> WIth my not-so-elegant method
01:07:54 <ivanm> rschnck: never pull a list apart if you're just going to put it back together again
01:08:21 <ivanm> OK: cross (x:xs) ys = map ((,) x) ys ++ cross xs ys
01:08:29 <ivanm> and add the base case
01:08:31 <kmc> rschnck, you can't use list monad or list comprehensions?
01:08:38 <rschnck> kmc: Nope
01:08:43 <kmc> rschnck, how about using 'concatMap'?  it's the same as (flip (>>=)) for lists
01:08:45 <rschnck> I think map should be okay
01:08:49 <lispy> rschnck: become friends with concatMap
01:08:51 <kmc> and if not using it, implement it yourself
01:08:57 <rschnck> kmc: Yep
01:09:08 <rschnck> I need to implement map and concatmap
01:09:20 <rschnck> How would I use concat map, though?
01:09:29 <ivanm> you don't actually need concatMap for this though ^^
01:10:24 <kmc> true, since you can do this with Applicative only, not requiring Monad
01:10:56 <lispy> Oh, I thought of concatMap because of the list monad
01:10:57 <kmc> (<*>) :: [a -> b] -> [a] -> [b]
01:10:58 <ivanm> what applicative?
01:10:59 <kmc> me too
01:11:02 <ivanm> I did it just using map and ++ !
01:11:08 <lispy> Isn't (>>=) = concatMap ?
01:11:14 <kmc> lispy, flip concatMap
01:11:20 <ivanm> > let cross (x:xs) ys = map ((,) x) ys ++ cross xs ys in cross [1..3] "ab"
01:11:21 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')*Exception: <interactive>:1...
01:11:24 <lispy> (=<<) = concatMap ;)
01:11:25 <kmc> i'm sure you can do it without Applicative too
01:11:28 <ivanm> yeah, no empty list case
01:11:33 <kmc> i'm just saying cross = liftA2 (,)
01:11:47 <ivanm> kmc: only Prelude list functions allowed IIUC
01:11:52 <rschnck> What's ((,) x)?
01:12:07 <kmc> (,) is the pair-making function
01:12:08 <ivanm> @type \ x -> ((,) x)
01:12:08 <kmc> :t (,)
01:12:09 <lambdabot> forall a b. a -> b -> (a, b)
01:12:09 <lambdabot> forall a b. a -> b -> (a, b)
01:12:15 <ivanm> > ((,) 1) 'a'
01:12:16 <lambdabot>   (1,'a')
01:12:21 <kmc> so ((,) x) = \y -> (x,y)
01:12:24 <rschnck> Oh, neat
01:12:34 <kmc> :t (,,,,,,,,,,,,,,,,)
01:12:35 <lambdabot> forall a b c d e f g h i j k l m n o p q. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
01:12:41 <kmc> :t (,,,,,,,,,,,,,,,,,,,,,,,,,)
01:12:43 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (a, b, c,
01:12:43 <lambdabot>  d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
01:12:43 <rschnck> 0.o
01:13:09 <ivanm> kmc: OK, now you're just being silly
01:13:31 <rschnck> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
01:13:32 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56. a -> b -> c -> d -> e -
01:13:32 <lambdabot> > f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 ->
01:13:33 <lambdabot> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28,
01:13:33 <lambdabot> t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56)
01:13:52 <rschnck> ivanm: Seems like I trumphed the silliness.
01:14:13 <rschnck> trumped*
01:14:22 <ivanm> @slap rschnck 
01:14:22 * lambdabot locks up rschnck  in a Monad
01:14:27 <rschnck> Anyway, I'll try to make sense of that function, ivanm 
01:14:33 <rschnck> and implement it myself
01:15:05 <rschnck> Have to go to sleep now, thanks again--always always--#haskell.
01:15:12 <rschnck> as always*
01:15:26 <ddarius> > let cross xs = foldr ((++) . flip map xs . flip (,)) [] in cross [1..3] "ab"
01:15:27 <lambdabot>   [(1,'a'),(2,'a'),(3,'a'),(1,'b'),(2,'b'),(3,'b')]
01:34:04 <hvr> hello *; do I need Setup.hs? my cabal project seems to work fine without it...
01:34:22 <ivanm> hvr: I think you do
01:34:33 <ivanm> since a lot of builders, etc. explicitly run Setup.hs
01:34:39 <lispy> hmm
01:34:41 <ivanm> cabal-install might not, but not everyone uses cabal-install
01:34:42 <lispy> I usually delete it
01:34:51 <ivanm> lispy: we use it in Gentoo...
01:35:00 <lispy> ivanm: -funroll-loops!
01:35:09 <ivanm> *sigh*
01:35:18 <lispy> :P
01:35:30 <ivanm> look for cabal-bootstrap here: http://code.haskell.org/gentoo/gentoo-haskell/eclass/haskell-cabal.eclass
01:35:37 <hvr> so is Setup.hs some old legacy thing?
01:35:42 <geheimdienst> hvr, if your .cabal file says "build-type: Simple" and you use cabal to build your thing, you can skip Setup.lhs
01:35:50 <ivanm> hvr: not at all
01:35:58 <ivanm> geheimdienst: s/cabal/cabal-install/
01:36:00 <lispy> ivanm: what language is that?  bash?
01:36:04 <ivanm> yup
01:36:07 <kmc> hvr, Cabal is a library.  Setup.hs is a minimal program to invoke that library.  cabal-install is a much more sophisticated program
01:36:14 <hvr> ic
01:36:18 <kmc> but it's not traditionally assumed everyone has it
01:36:21 <ivanm> hvr: Setup.[l]hs is a Haskell script that uses the Cabal library to configure, build and install that package
01:36:24 <kmc> though it's part of Haskell Platform now
01:36:35 <ivanm> kmc: doesn't mean everyone uses it
01:36:36 <lispy> ivanm: can you guys really build a good tool chain in bash?  Haven't you craved to replace it with a typeful language?
01:36:38 <hvr> so Setup.hs is something like setup.py for python projects?
01:36:42 <ivanm> linux distro packagers don't use it
01:36:50 <ivanm> lispy: I didn't build it
01:36:52 <lispy> ivanm: http://donsbot.wordpress.com/2010/08/17/practical-haskell/
01:37:01 <ivanm> lispy: note: these are just the package files
01:37:29 <ivanm> (well, technically that file is a library of how to build cabalised packages...)
01:37:53 <ivanm> lispy: let's say that we decided to use an app written in Haskell to build all our Haskell packages... how do we install that app?
01:38:23 <lispy> ivanm: and this post: https://donsbot.wordpress.com/2007/03/10/practical-haskell-shell-scripting-with-error-handling-and-privilege-separation/
01:38:24 <geheimdienst> ivannm: why does gentoo use Setup instead of cabal-i? avoid the extra dependency?
01:38:41 <ivanm> geheimdienst: that, and then how would cabal-install be installed?
01:38:47 <ivanm> note that this stuff pre-dates cabal-install
01:39:01 <ivanm> also, we can do more customisations, etc. with just Setup.hs
01:39:14 <lispy> ivanm: let's suppose we want to write our C compiler in C, how do we bootstrap it?
01:39:16 <ivanm> and avoid the whole "let's just assume you meant parsec-3"
01:39:32 <ivanm> lispy: in Gentoo, you use a pre-done stage for the initial installation
01:39:51 <geheimdienst> i see. thanks
01:39:55 <ivanm> also, we _have_ to use bash for the package files
01:40:02 <ivanm> it's the whole definition of the ebuilds, etc.
01:40:19 <ivanm> a lot of stuff in there is cruft though
01:40:37 <ivanm> (having to cope with old versions of GHC, etc.)
01:41:01 <tensorpudding> you need bash for ebuilds?
01:41:26 <tensorpudding> i guess it's not a huge deal since gentoo has bash in the base install
01:41:32 <ivanm> yes
01:41:48 <tensorpudding> pretty odd though
01:41:49 <ivanm> because ebuilds are just specified bash libraries
01:41:55 <ivanm> tensorpudding: *shrug* they had to choose _something_
01:42:09 <ivanm> if not bash, next likely candidate was probably python, since the default package manager is written in python
01:42:29 <ivanm> don't forget, a large point of Gentoo is to automate all the "./configure && make && make install" stuff
01:42:33 <ivanm> so using bash makes sense
01:42:42 <ivanm> (could have been pure sh I suppose...)
01:42:44 <tensorpudding> maybe
01:42:51 <tensorpudding> freebsd does similar
01:42:56 <ivanm> right
01:43:00 <tensorpudding> but it uses make
01:43:02 <ivanm> portage is based heavily on ports
01:43:28 <tensorpudding> well, also patch, presumably, at some point
01:43:29 <kmc> choice of language matters a lot more for the happiness of your developers than it does for the quality of the finished product
01:43:43 <kmc> with time to develop somewhere between the two
01:43:45 <geheimdienst> arch linux by the way does it similar. a pkgbuild file is just a shell script
01:43:47 <tensorpudding> there is probably usage of sh in there to
01:43:49 <tensorpudding> too*
01:44:27 <kmc> in open source it might matter more to keep your developers happy, because they are probably volunteers
01:44:52 <ivanm> kmc: yup
01:45:13 <geheimdienst> keeping the developers happy is _always_ a huge concern
01:45:37 <hvr> maybe it's time for hentoo, a pure haskell based gentoo distro :-)
01:45:44 <ivanm> geheimdienst: whether you're making them happy in their work environment or making them happy with their renumerations for having to put up with a shitty work environment!
01:45:51 <ivanm> hvr: too much effort
01:45:58 <kmc> ivanm, or neither!
01:46:00 <ivanm> someone did try porting emerge to Haskell
01:46:05 <ivanm> kmc: then you don't keep them happy!
01:46:15 * ivanm is jumping ship to exherbo anyway
01:46:16 <geheimdienst> omg, if you run cabal init, it makes a Setup.hs _and_ a .cabal file that has build-type: Simple
01:46:22 <geheimdienst> this has gotta be a bug
01:46:24 <ivanm> geheimdienst: thank byorgey 
01:46:24 <kmc> make them happy by promising things you don't deliver
01:46:36 <ivanm> geheimdienst: why is it a bug?
01:46:40 <ivanm> you _should_ have a Setup.hs
01:46:55 <ivanm> just because cabal-install doesn't need one if it's build-type: Simple doesn't mean you shouldn't have it
01:46:59 <geheimdienst> but if you say b-t: Simple, cabal ignores the Setup.hs, doesn't it?
01:47:13 <kingping> Hello folks
01:47:22 * ivanm waves idly in kingping's general direction
01:47:28 <kmc> geheimdienst, you can build/install a package with "runhaskell Setup.hs build" etc
01:47:41 <geheimdienst> kmc: yes, and i like that
01:47:41 <kingping> Which ghc Haskell Platform 2010.2.0.0 comes with?
01:47:42 <kmc> cabal-install (the binary named 'cabal') is not required
01:47:53 <kmc> geheimdienst so... how wouldthat work if Setup.hs doesn't exist?
01:47:58 <ivanm> kingping: 2010.2.0.0 has come out? :o
01:48:10 <ivanm> huh, it has
01:48:13 <ivanm> kingping: 6.12.3
01:48:16 <kingping> ivanm http://hackage.haskell.org/platform/windows.html
01:48:23 <kingping> kewl
01:48:26 <kmc> geheimdienst, or do you mean that the build-type should be something else
01:48:28 <ivanm> that's what you get when you ignore the platform
01:48:35 <geheimdienst> kmc, i'm arguing that if you create a Setup.hs, you should have cabal use it, too. i.e. built-type: Custom
01:48:40 <kmc> mm
01:48:43 <ivanm> geheimdienst: why?
01:49:02 <ivanm> geheimdienst: how would Cabal work with build-type: Simple if there's no Setup.[l]hs?
01:49:16 <kmc> geheimdienst, there's a bug on the cabal trac about having cabal-install check that Setup.hs is the standard boilerplate if you have build-type simple
01:53:04 <geheimdienst> ivanm, i just checked, if i do rm Setup.hs; cabal configure; cabal build in a minimal project with build-type: Simple, it builds
01:53:19 <geheimdienst> cabal-install must be using some built-in default Setup.hs
01:53:51 <kmc> if you have build-type simple, cabal-install ignores Setup.hs
01:54:26 <geheimdienst> kmc, yeah that's what i seemed to recall and just verified
01:54:28 <kmc> it should ignore it *and* check that it's just invoking defaultMain
01:54:34 <kmc> but it doesn't
01:54:40 <kmc> because that would be hard
01:55:03 <geheimdienst> i guess it could also just print a warning that you have build-type: Simple and a Setup.hs exists
01:55:37 <kmc> but this is the case for almost every package
01:57:04 <geheimdienst> that's true. i guess that's an unfortunate historical fact
01:58:01 <kmc> well, like you said
01:58:06 <kmc> it's nice to be able to build stuff without cabal-install
01:58:56 <kmc> you could make the user copy this 2-line file, whatever
01:58:58 <geheimdienst> all i'm sayin' is, people are bound to be confused and frustrated if cabal init creates this Setup.hs and you edit it and nothing works (cf. making developers happy etc.)
01:59:21 <geheimdienst> i.e. imho cabal init should emit build-type: Custom, not Simple
01:59:32 <geheimdienst> my 2 cents
01:59:43 <kmc> i think that would have other consequences
02:00:23 <kmc> also if you edit Setup.hs you are an advanced user of Cabal and i hope every Cabal guide will say so
02:00:40 <kmc> how many packages use build-type custom?
02:01:02 <lispy> kmc: that tends to be only big legacy stuff
02:01:31 <geheimdienst> i think doing a strange thing and documenting it is not as good as being clear upfront
02:13:52 <Kaidelong> http://codepad.org/ItQMvKjA
02:13:58 <Kaidelong> this doesn't work and i have no idea why
02:16:51 <lispy> Kaidelong: codepad not loading here
02:16:53 <lispy> n/m
02:17:12 <Kaidelong> it's a logic error in soln' I'm pretty sure
02:17:14 <kmc> that's a lot of code
02:17:18 <Kaidelong> but I can't figure out what it is
02:17:26 <Kaidelong> the rest of it seems to work
02:17:32 <lispy> :t head :: [[a]] -> [a]
02:17:33 <lambdabot> forall a. [[a]] -> [a]
02:18:00 <lispy> I guess your head is different on empty input
02:18:05 <Kaidelong> yes
02:18:24 <Kaidelong> > head []
02:18:24 <lambdabot>   *Exception: Prelude.head: empty list
02:18:37 <kmc> Kaidelong, can you write quickcheck properties for your misbehaving function?
02:18:52 <Kaidelong> kmc: maybe. I wouldn't know how
02:19:20 <Kaidelong> one property would be that it should return a solution the same length as the puzzle
02:19:26 <Kaidelong> which right now it does not
02:20:05 <Kaidelong> err, so long as the puzzle doesn't have any duplicated pieces in it or conflicting ones
02:20:44 <Kaidelong> [(Rook,(3,3)),(Pawn,(3,3))] would not be a valid puzzle and I'd not expect much to come from such an input
02:23:25 <kmc> Kaidelong, perhaps one of your x should be an x' or vice versa
02:23:33 <kmc> i've made lots of mistakes like that
02:24:29 <Kaidelong> kmc: I tested all the (%?%) stuff
02:24:57 <Kaidelong> possibleMoves also appears to work but testing it exhaustively would be hard
02:25:09 <kmc> can you QuickCheck it?
02:25:23 <Kaidelong> Perhaps. I haven't used QuickCheck before. I'll go look it up
02:32:20 <kmc> :t \x -> case x of {}
02:32:21 <lambdabot> parse error on input `}'
02:36:25 <Maxdamantus> @ap \f g a -> f (g a) a
02:36:26 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
02:36:31 <Maxdamantus> @pl \f g a -> f (g a) a
02:36:32 <lambdabot> flip flip id . liftM2
02:37:50 <etpace> hmm, is there a way to "putArgs" which will then be retrived by getArgs?
02:38:40 <ToRA> slightly ot, but does anyone have a mirror / copy of SPJ's Implementation of Functional Languages pdf?  The link on his MS site is down
02:40:56 <Cale> I have "Implementing Functional Languages: a tutorial" by SPJ and David Lester
02:41:34 <ToRA> that might do
02:41:37 <ManateeLazyCat> @src words
02:41:37 <lambdabot> words s = case dropWhile isSpace s of
02:41:37 <lambdabot>     "" -> []
02:41:38 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
02:42:57 <Cale> http://cale.yi.org/share/Peyton%20Jones,%20Lester%20-%20Implementing%20Functional%20Languages:%20a%20tutorial.pdf
02:43:41 <ToRA> thank-you
02:43:51 <kmc> etpace, in GHCi you can ":set args"
02:44:06 <etpace> withArgs from System.Environment seems to do what I want
02:44:14 <ToRA> hmm, doesn't seem to have the bit about Turner's combinators that's apprantly in the full one
02:44:28 <ManateeLazyCat> Have a function return words of string? I mean word bound that match regular expression, not like 'words' implementation us isSpace.
02:44:49 <ToRA> (I'm doing a comparison of *Check testing tools and my own one, and found an infelicity in the Turner benchmark in the SmallCheck paper which apparantly comes from the book :s)
02:45:36 <ManateeLazyCat> BTW, I'm looking for regular expression search function, when i give it a string, it will return all match index in string.
02:47:50 <Cale> ManateeIrcClient: The confusing regex-base package can do that...
02:47:55 <Cale> RegexLike a b => RegexContext a b (AllMatches [] (MatchOffset, MatchLength))
02:49:36 <Cale> Prelude Text.Regex.Posix> getAllMatches $ "abracadabra" =~ "a." :: [(MatchOffset, MatchLength)]
02:49:37 <Cale> [(0,2),(3,2),(5,2),(7,2)]
02:50:04 <etpace> i think the way typeclasses are used with regex in haskell is pretty cool
02:50:20 <Cale> It might be a bit over the top
02:50:35 <ManateeLazyCat> Cale: Thanks, i will read itgetAllMatches.
02:51:16 <Cale> ManateeIrcClient: It's just the field extractor for a newtype which selects which instance to use
02:51:31 <Cale> ManateeIrcClient: There's also AllTextSubmatches and AllSubmatches
02:51:53 <Kaidelong> I found the error!
02:52:03 <Kaidelong> wrote down xs instead of (x:xs)
02:52:17 <ManateeLazyCat> Cale: I want return [(String, MatchStartOffset, MatchEndOffset)[
02:52:36 <ManateeLazyCat> Cale: Or [(ByteString, MatchStartOffset, MatchEndOffset)[
02:52:43 <shajen> how to write function in haskell that create cyclist from list?
02:52:56 <Zao> "cyclist"?
02:53:02 <ManateeLazyCat> Cale: Then i can compare all words with nick Map, if search match, highlight word with nick color. 
02:53:27 <Zao> let bicycle'repairman = ...
02:54:17 <Cale> shajen: Do you mean like:
02:54:20 <Cale> > cycle [1,2,3]
02:54:21 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
02:54:30 <shajen> i mean http://www.speedyshare.com/files/24300600/lista14.pdf excercise 1
02:54:54 * copumpkin wonders whether his MonadFix instance for the iteratee-alike he's been working with actually does anything useful
02:55:28 <Cale> shajen: okay...
02:55:29 <shajen> without wasteland in memory
02:56:07 <Kaidelong> http://codepad.org/gAUUgOm4
02:56:47 <ManateeLazyCat> Cale: I have test, getAllMatches is my need, thanks for help! :)
02:57:08 <shajen> Cale: i have http://codepad.org/DELZptWk but it's not working
02:57:20 <Cale> shajen: That's doable, but involves a bit of a trick. The key is in being able to refer to the overall result when you get to the end of the list.
02:58:52 <shajen> Cale: yea i know, you saw my code?
02:58:57 <ManateeLazyCat> Cale: How to return match text in getAllMatches?
02:59:12 <Cale> ManateeIrcClient: hmm
02:59:41 <ManateeLazyCat> Cale: I wonder have buildin type return match text.
03:00:12 <ManateeLazyCat> Cale: Don't need use MatchOffset and MatchLength pick match text *again* . :)
03:00:13 <Cale> ManateeLazyCat: I don't see an option to get both at the same time.
03:02:53 <ManateeLazyCat> Cale: Thanks, i think it's not a big problem since i have got offset and length. :)
03:03:01 <ManateeLazyCat> getAllMatches $ "<nick> otherNick: irc message, bla bla" =~ "\\w+" :: [(MatchOffset, MatchLength)]
03:03:20 <ManateeLazyCat> [(1,4),(7,9),(18,3),(22,7),(31,3),(35,3)]
03:03:28 <ManateeLazyCat> Works great....
03:04:21 <ManateeLazyCat> Before, i'm find some regex library like Emacs' regex library.
03:04:33 <ManateeLazyCat> I think Haskell regex library is better.
03:04:45 <ManateeLazyCat> I even don't need loop string, all is automatic. :)
03:05:28 <Cale> shajen: http://hpaste.org/30170/cyclic_list
03:05:32 <ManateeLazyCat> I need find some time research regex library, so awesome. :)
03:06:46 <shajen> Cale: thanks!
03:07:32 <Cale> shajen: To be honest, I still find that a bit hard to follow. If you think in terms of how you'd build the structure in an imperative language with pointers or references, it's quite similar though.
03:07:58 <Cale> So, you can always go about building cyclic structures thinking in that way.
03:08:31 <Cale> It's also much simpler to do with a fixed list
03:10:29 <Cale> shajen: http://hpaste.org/paste/30170/countfour#p30171
03:10:32 <Mitar> has anybody done a PID controller in haskell?
03:10:53 <Cale> shajen: That shows a fixed cyclic structure with only 4 nodes.
03:11:46 <shajen> Cale: ok, i think i understand how it works
03:14:32 <Cale> Mitar: I don't know, but it looks like maybe something the guys working on robots might have built at some point.
03:14:44 <Mitar> yes, i am working on robots ;-)
03:14:49 <Mitar> sewing machine ;-)
03:14:57 <Mitar> this is why i am asking, not to duplicate work
03:15:15 <Mitar> i do not see any lib
03:15:36 <Mitar> and PID has too many meanings in computers
03:17:03 <Cale> Mitar: I see PID controllers mentioned in some powerpoint lecture slides on Yampa, but it doesn't seem to have much useful code.
03:25:59 <Cale> 212.219.56.146/sites/www.haskell.org/yampa/AFPLectureNotes.pdf has some code for some specific proportionate and proportionate derivative controllers, but it's probably only useful to look at if you're using Yampa
03:26:28 <Cale> actually, why not go with http://www.haskell.org/yampa/AFPLectureNotes.pdf
03:27:13 <ivanm> Cale: do you know of any good way of representing plane graphs?
03:27:39 <ivanm> specifically, directed plane graphs
03:27:42 <Cale> ivan: I do... it's a bit involved
03:27:53 <ivanm> AFAICT, the only way to use pre-existing libraries would be to duplicate every edge in both ways, so that I can still find faces :s
03:27:56 <ivanm> Cale: :s
03:28:14 <Cale> You can specify a graph embedding using a pair of permutations of the set of edge ends.
03:28:28 <ivanm> come again?
03:28:41 <Cale> Let me just refresh myself on how it works
03:30:11 <ivanm> sure
03:30:52 <Cale> ivan: Okay, I think the way it works is this. Pick any graph, and number and orient the edges, so each edge n has two ends n+ and n-
03:31:21 <Cale> plane-embedded graph, sorry :)
03:31:58 <Cale> So, what we're going to do to encode the way that it's been embedded is to use two permutations: sigma will just consist of all the transpositions of the form (n+ n-) for each n
03:32:14 <Cale> So sigma takes you from one end of an edge to another
03:32:47 <ivanm> by n+ n-, do you mean from n+ to n- or something?
03:32:56 <Cale> yeah, the transposition which swaps n+ and n-
03:33:55 <ivanm> "which swaps"?
03:34:06 <Cale> Yeah, so sigma(n+) = n-
03:34:11 <ivanm> ahhh, right
03:34:11 <Cale> and sigma(n-) = n+
03:34:17 <ivanm> so you keep both directions?
03:34:40 <Cale> sigma is really just keeping track of which ends belong to the same edge for us
03:34:46 <ski> dolio : (re multiple incompatible refinements from GADT matching) if it should be allowed, then it should be treated a bit similarly to absurd patterns in Agda2, in the sense that you can and must omit the right-hand-side of the branch/equation
03:35:12 <Cale> So if we were to relabel them, we could recover that information by seeing which ends are being swapped by sigma.
03:36:04 <ivanm> OK
03:36:18 <Cale> and now rho is the other permutation, and it has for each vertex of the graph, a cycle which sends each edge end to the next one in counterclockwise order
03:36:39 <ski> (i suppose one could allow arbitrary right-hand-side expressions as well, but i don't know whether that's useful or improves symmetry .. in any case, not requiring type-correctness of such an expression would seem bad, even if it would never actually be evaluated)
03:37:26 <dolio> ski: I guess you could do that. It makes more sense to omit the case, I think, though.
03:37:50 <Cale> From rho and sigma, you can recover the faces of the graph, by starting somewhere and alternating back and forth between applying rho and sigma.
03:38:03 <ski> dolio : hence the "if it should be allowed" :)
03:39:05 <ivanm> Cale: right
03:40:10 <ski> dolio : there might be an issue that you want to make it clear to the pattern-match-checker that you're aware of this being an impossible case, as opposed to you just forgetting to mention it. (since matches doesn't need to be "uniform" : you can match on some constructors, and then either omit other cases, or have a default case (or both))
03:40:29 <dolio> For instance, if C :: T (), and you have f :: T Int -> () ; f C = (), GHC throws a type error.
03:40:30 * ski is not sure what is the right approach
03:40:47 <Kaidelong> there's still a bug in my code
03:40:57 <Kaidelong> bishops and rooks can jump over pieces right now
03:41:03 <Kaidelong> will fix it tomorrow, for now, sleep
03:41:07 <dolio> It just doesn't do it if the impossibility is based on two incompatible refinements.
03:41:09 <ski> yeah .. at least you would want to be able to express `f t = case t of {}', in such cases
03:41:41 <dolio> Well, you might have D :: T Int as well.
03:41:42 <ski> (i.e., when there is no valid case at all)
03:41:46 <ski> *nod*
03:42:54 * hackagebot cmdargs 0.6 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6 (NeilMitchell)
03:43:55 <dolio> It actually does notice that C isn't a possible case there.
03:44:17 <dolio> So I guess the completeness checker knows something about GADTs.
03:44:48 <ski> yeah .. but how to express that you're matching on every case (exhaustive matching), but that there is no valid case/branch ?
03:44:50 <Cale> ivanm: I'm not sure if that's what you're after though :)
03:45:00 <ivanm> no, not really
03:45:18 <ivanm> dammit, can't neil stop releasing new versions of cmdargs?
03:45:27 <Cale> ivanm: You could also encode a planar graph as simply a graph together with a function V -> R^2
03:45:36 * ski thinks GADT indices are sortof strange .. in that they are types, instead of values
03:45:46 <tensorpudding> the alternative being not releasing new versions?
03:46:21 <ivanm> Cale: my main thing was how to store the edges for each vertex so as to be able to find faces, etc.
03:46:46 <ivanm> since AFAICT you can't distinguish between incoming and outgoing edges if you want to do that
03:47:06 <ivanm> and since order is important, you have to be more careful where you place each edge
03:48:04 <ski> if you have a GADT, and you don't use its index variables as types as well, neither in the declaration (like `Foo :: [a] -> T a') or in operations (like `eval :: T a -> a'), then the indices might as well be values in a datatype ..
03:48:56 <ski> .. except that we never match directly on the indices in operations polymorphic in them, instead getting their values indirectly by matching on the GADT data constructors .. (iow, we treat the indices blindly)
03:49:15 <dolio> Yes, it's odd.
03:49:31 <dolio> You could do the same thing in Agda, but you'd have to be crazy.
03:50:21 <dolio> It does get you some things for free. You can erase all the indices, for instance.
03:50:38 <dolio> You don't have to do the Inductive Families Need Not Store Their Indices analysis.
03:50:44 <dolio> Because all types are erased.
03:51:17 <dolio> And if anything needs to not be erased, the users add it back in manually.
03:51:31 <ski> if you want to have several interpretations (like `eval :: forall a. T a -> a'), most of which can be thought of as "non-standard", it might be better to cast even the "standard" one as `eval :: forall i. T i -> V i', giving an explicit mapping from the "object-level types/properties" `i' into Haskell types `V i'
03:52:36 * ski is not familiar with "Inductive Families Need Not Store Their Indices analysis" (nor with type erasure in Agda2) .. any paper reference ?
03:52:50 <dolio> That's the name of the paper.
03:52:57 <ski> ok, that works :)
03:54:07 <dolio> Basically, it's that in "data Vec A : Nat -> Set where [] : Vec A 0 ; _::_ : {n : Nat} -> A -> Vec A n -> Vec A (suc n)", the cons constructor doesn't need to store n.
03:55:17 <ski> doesn't need to, in this specific case ? or never needs to ?
03:55:49 <dolio> Never needs to for indices, of which n is an example.
03:57:17 <ski> but if you have a value of type `Vec A n', where it is not known statically whether `n' is `0' or `suc m' for some `m', can you still match that value against the `[]' and `_::_' constructors, or do you *need* to resolve `n' more, first ?
03:57:23 <dolio> In Haskell, that'd be a type, which doesn't really get stored anyway.
03:57:59 <dolio> If it's an inductive family, you don't need to refine n first.
03:59:18 <ski> afaiu, you can get the behaviour of needing to resolve `n' statically first, by defining `Vec' as a function which inducts on the natural number, and returns different types in each case (each such type having a single constructor) .. iirc, this is what *Agda1* allows
03:59:58 <dolio> Yes, I probably wouldn't call that an inductive family.
04:00:09 * hackagebot simpleirc 0.2.0 - Simple IRC Library  http://hackage.haskell.org/package/simpleirc-0.2.0 (DominikPicheta)
04:00:22 <dolio> Some types can be defined both by recursion or with inductive families.
04:00:44 <dolio> And either method may have advantages.
04:01:52 <ski> (something like `Vec (A :: Set) (n :: Nat) :: Set = case n of {Zero -> data {Nil :: _ A Zero}; Succ n -> data {Cons A (Vec A n) :: _ A (Succ n)}}' in Agda1, iirc)
04:02:36 <dolio> Oh, well, I don't know how that would behave just by looking at it.
04:02:44 <ski> (maybe the ` :: _ ...' annotations are needless, and prohibited, i'm not sure)
04:03:58 <ski> when i played around with this a bit, a while ago, i remember noticing that with this style, it didn't allow matching on a value of type `Vec A n' before it knowed the shape of `n' so that it knew which actual type that resolved to (and hence which constructors were available)
04:04:15 <ivanm> preflex: seen Heffalump 
04:04:15 <preflex>  Heffalump was last seen on #darcs 2 hours, 6 minutes and 39 seconds ago, saying: and, for proper review, could people just grab any set of patches that build and pass the tests, to review?
04:04:20 <ski> (er, s/knowed/knew/)
04:04:24 <dolio> You can do something that looks similar in Agda2.
04:04:49 <dolio> Vec : Set -> Nat -> Set ; Vec A zero = \top ; Vec A (suc n) = A \x Vec A n
04:04:58 <ski> *nod*
04:05:13 <dolio> Data declarations aren't expressions like they may have been in Agda1, though.
04:05:56 * ski is not really sure how "`data' as expressions" were treated in Agda1 .. can only comment from my limited experience with it in Alfa
04:07:03 <ski> (anyway, i suspect there can be important lessons hiding in distinctions like these, related to whether quantifiers are "blind" or not)
04:07:27 <dolio> Anyhow, the idea behind inductive families is that you're defining the family 'Fam : I -> Set' by specifying the constructors that the family is closed under.
04:07:39 <ski> aye
04:08:59 <dolio> And thus you can match on the constructors without knowing what the index is, because it's the family that you're matching on.
04:09:04 <dolio> Or something like that.
04:09:37 <ski> (Agda1 also had an `idata' construction, which can be used as (something like) `Equal (A : Set) (a : A) : A -> Set = idata {Refl :: _ a}', which i believe is similar to the Agda2 `data Equal (A : Set) (a : A) : Set where Refl :: Equal a a')
04:10:47 <dolio> Yeah, I think it had something along the lines of inductive families.
04:11:10 <dolio> I seem to recall there's some kind of 'restricted' inductive family, or something like that. But I don't remember what the difference is.
04:11:24 <ski> dolio : yeah .. it only feels strange to me to be saying that we're actually matching on values of type `I -> Set' ..
04:11:26 <ManateeLazyCat> Cale: matchAllText (makeRegex "\\w+" :: Regex) (pack "<nick> otherNick: bla bla" :: ByteString)
04:11:35 <ManateeLazyCat> [array (0,0) [(0,("nick",(1,4)))],array (0,0) [(0,("otherNick",(7,9)))],array (0,0) [(0,("bla",(18,3)))],array (0,0) [(0,("bla",(22,3)))]]
04:11:51 <ski> er, values of a type with has `I -> Set' as type, rather
04:12:08 <ivanm> @tell andrewsw well, using the hpaste.el you pasted on hpaste, it doesn't seem to work at all: url-http-generic-filter(#<process hpaste.org> "HTTP/1.1 200 OK
04:12:08 <ivanm> \nServer: nginx/0.7.67
04:12:08 <lambdabot> Consider it noted.
04:12:08 <ivanm> \nDate: Sat, 18 Sep 2010 11:10:34 GMT
04:12:08 <ivanm> \nContent-Type: text/html; charset=UTF-8
04:12:08 <ivanm> \nTransfer-Encoding: chunked
04:12:10 <ivanm> \nConnection: keep-alive
04:12:13 <ivanm> \n
04:12:15 <ivanm> \n0
04:12:17 <ivanm> \n
04:12:19 <ivanm> \n")
04:12:22 <ivanm> gah, didn't think those newlines would be there :s
04:13:06 <ivanm> @tell andrewsw in case lambdabot didn't get the newlines recorded: url-http-generic-filter(#<process hpaste.org> "HTTP/1.1 200 OK\nServer: nginx/0.7.67\nDate: Sat, 18 Sep 2010 11:10:34 GMT\nContent-Type: text/html; charset=UTF-8\nTransfer-Encoding: chunked\nConnection: keep-alive\n\n0\n\n")
04:13:07 <lambdabot> Consider it noted.
04:13:12 * ski is probably confused ..
04:13:15 <dolio> ski: Well, it doesn't quite work like that.
04:13:51 <ivanm> have I gone TH mad? http://hpaste.org/30172/have_i_gone_th_mad
04:14:40 <dolio> I'm not sure how best to explain it, though.
04:15:43 * ski is trying to understand the similarities and differences between GADTs and data types (including inductive families) in Agda[12]
04:15:58 <ski> .. as well as their relation to "blindness"
04:16:18 <dolio> I mean, you're specifying values of 'Fam i'. But you're not specifying what constructors some fixed 'Fam i' (and fixed i) is closed under.
04:17:04 <dolio> Which is what normal inductive types are.
04:18:12 <ski> yeah .. for GADTs in Haskell, the indices, being types, are virtual anyway, so you only get them "blindly", while in Agda2, they may be non-virtual, so you can actually match on them, instead of on the constructors in the family they index
04:19:09 <dolio> Although, I forget what category the initial algebras are in. It may actually be an initial algebra in some (co)slice category.
04:19:23 <ski> i'm interested in expressing `exists i. T i' and `forall i. T i' when there is no run-time presence of `i', so that any information about it would have to come indirectly, from matching other constructors, like with GADTs
04:20:09 <dolio> Agda is actually getting some erasure stuff.
04:20:44 <dolio> I've been trying to help puzzle things out about it on the mailing list.
04:20:52 <ski> e.g. `forall n : Nat. P n -> Q n' would be a function that is not allowed to use induction on the "given" natural number, having to treat it parametrically, up to knowledge about it which it may uncover from scrutinizing the input of type `P n'
04:21:25 <ski> (s/would be/would be the type of/)
04:21:27 <dolio> Right.
04:24:53 <dolio> Well, I can't find a paper that says it clearly by skimming, but initial algebras in a slice category sounds right for inductive families.
04:24:55 <ski> otoh, i think it is safe to allow it to "use" induction on `n' in proving the blind `R n', if `Q n' is `exists r : R n. S n r' (or for proving the blind `R n s', if `Q n' is `{s : S n | R n s}')
04:26:36 * ski remembers something along these lines, but for `Prop' types, instead of for blind quantifiers, in "Programming in Martin-Löf Type Theory: An Introduction" by Nordström and Smith (iirc)
04:26:37 <dolio> The erasure pure type systems by Sheard and Mishra-Linger have a fair amount of that worked out.
04:26:57 <dolio> The latter did a thesis on it.
04:27:52 <dolio> And I think they'd allow both your cases there, if I'm reading correctly.
04:28:53 <dolio> I've also seen stuff by Pfenning that has both that sort of parametric/irrelevant quantification, and an extra-intensional quantification.
04:29:04 <dolio> Where not even beta reduction applies.
04:29:33 <dolio> Intensionality, Extensionality and Proof Irrelevance in Modal Type Theory
04:30:42 <ski> "Irrelevance, Polymorphism, and Erasure in Type Theory" at <http://www.cs.pdx.edu/pdfs/lingerphdthesis.pdf> by Nathan Mishra-Linger, 2008, thesis
04:30:48 <dolio> Yes.
04:31:12 <dolio> There's a couple shorter papers he co-authored with Tim Sheard. But I think the thesis covers both and more.
04:32:03 <ski> dolio : yeah, i want to allow both kinds of quantification in the same system, maybe encoding the blind ones in terms of the others and a `Forgotten' construction (which i've rambled on before)
04:32:42 <ryo_hazuki> hey peeps :)
04:32:48 <ski> (hrm, what do you mean by "extra-intensional quantification","Where not even beta reduction applies" ?)
04:32:54 <ryo_hazuki> :t mapM_
04:32:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:33:13 <ryo_hazuki> is there functions like mapM_ which takes m [a] as snd param?
04:33:53 <dolio> ski: I mean... He uses x :: T for the extra-intensional typing judgment, x : T for the normal one, and x % t for the irrelevant one...
04:33:54 <dafis> ryo_hazuki: mapM_ fun =<< mlist
04:33:59 <ivanm> ryo_hazuki: forM_ ?
04:34:04 <ivanm> oh, right
04:34:15 <ski> (when i said "both kinds", i meant both "blind" ones, and also the `(a : A) -> ' and `(a : A) * ' ones, in which you have an explicit argument resp. an explicit pair component)
04:34:15 <ivanm> ryo_hazuki: mapM_ foo =<< monadicList
04:34:24 <dolio> And x = y :: T is the intensional equality judgment, for instance.
04:34:26 <kmc> equivalently: mlist >>= mapM_ fun
04:34:31 <hpc> :t forM_
04:34:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
04:34:38 <kmc> equivalently: do { x <- mlist; mapM_ fun x }
04:34:49 <ryo_hazuki> ivanm, thx =), gonna try that
04:35:02 <dolio> ski: So, there, you wouldn't even have, say, '2 + 2 == 1 + 3 :: Nat'.
04:35:04 <ryo_hazuki> kmc, that would be the way i knew but ithought of something more elegant
04:35:19 * ivanm 's way is identical to kmc's...
04:35:41 <dolio> ski: The :: equality judgment means that you have two identical expressions, up to alpha renaming.
04:35:42 <ivanm> huh, and dafis beat me to it
04:35:51 <ivanm> dafis: sorry, didn't see your message before I wrote mine
04:36:09 <ski> dolio : hm, strange .. i would need to read more about rationale for wanting something like that
04:36:25 <dolio> Whereas '2 + 2 = 1 + 3 : Nat'. And '5 = 7 % Nat' for irrelevant equality.
04:36:54 <dolio> ski: Yeah, I don't actually remember why he wants it. Or even if he gives a reason.
04:38:19 <dafis> ivanm: No sweat
04:38:35 <dolio> And there's a certain kind of phase weakening, too.
04:39:05 <dolio> You can use a variable for an intensional expression where a regular term is expected, but not vice versa.
04:39:25 <dolio> And the same for regular terms and irrelevant/parametric 'proofs'.
04:40:36 <dolio> Because you can, for instance, use something that will be around at runtime in a spot that will ignore it. But you can't recall something that exists only statically at runtime.
04:41:09 <dolio> Anyhow, I need to head out.
04:41:13 <dolio> I'll catch you later.
04:42:23 <ski> dolio : yeah, such implicit inclusions makes sense
04:42:59 <ski> (to the same degree that it makes sense to discard values of a type, using them non-linearly)
04:45:54 <ski> ryo_hazuki : an alternative way would be to say something like `((mlist >>=) . mapM_) $ \a -> fun a' (in case `fun a' is actually a big expression depending on `a') .. i'm not sure whether that could be made to look more pretty
04:50:49 <ManateeL`> I was confuse, how to pick "(source, (MatchOffset, MatchLength))" from "Array Int (source, (MatchOffset, MatchLength))" ? First use Array.
04:51:24 <ivanm> what do you mean?
04:51:43 <ivanm> "Array i e" means you have an Array where the indices are of type i and the values are of type e
04:51:51 <dafis> :t (!)
04:51:52 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
04:51:58 <dafis> ManateeL`: ^^
04:52:18 <ManateeL`> dafis: I have try it, but don't know why can't work.
04:52:26 <ivanm> out of bounds?
04:52:30 <dafis> ManateeL`: what's the problem?
04:52:59 <ManateeL`> dafis: I try again, perhaps somewhere mismatch type.
04:53:38 <ryo_hazuki> more concrete question: i got a function foo :: [a] -> IO [a] and lets say now i want to call foo twice with different arguments and save both results in a list and then print the list to stdout - how can i achieve that?
04:54:13 <Botje> mapM foo [list1, list2]
04:54:19 <ski> .. hm .. it might maybe be interesting with an abstraction `forall a. c (f a) -> f (c a)', which allowed one to e.g. construct `(Monad c,Functor f) => c a -> (a -> f (c b)) -> f (c b)'
04:54:23 <Botje> will give you an IO [[a]]
04:54:29 <ivanm> well, mapM_ (print . foo) [list1, list2]
04:54:39 <ivanm> ^^ that will print them but not save the results
04:55:13 <dafis> ryo_hazuki: do { a1 <- foo l1; a2 <- foo l2; print (a1 ++ a2) }
04:55:16 <Botje> @pl \x -> print x >> return x
04:55:17 <lambdabot> liftM2 (>>) print return
04:55:42 <Botje> ryo_hazuki: as you see, "save both results in a list" is a bit vague :)
04:55:47 <ManateeL`> dafis: I got "Not in scope: data constructor `Array'", but i have import Data.Array ... I can't use (Array i e) match type Array?
04:55:48 <ManateeL`>  
04:56:32 * ManateeL` pasted "Array code." at http://paste2.org/get/992665
04:56:32 <dafis> ManateeL`: Data.Array doesn't export the data constructor
04:56:39 <Botje> ManateeL`: Array i e is the type.
04:56:53 <Botje> ManateeL`: you cannot pattern match on it, as the implementation is completely different
04:57:06 <ManateeL`> dafis: http://paste2.org/get/992665 is my code, MatchText define is "type MatchText source = Array Int (source, (MatchOffset, MatchLength))Source"
04:57:53 <ManateeL`> Botje: If you can use "(Array i e)" for pattern match, how to get 'i' for function (!) ?
04:57:58 <ManateeL`> s/can/can't
04:58:00 <Botje> ManateeL`: i is the type of the index
04:58:29 <Botje> ManateeL`: i'm not sure what's inside the array though.
04:58:44 <Botje> @hoogle Data.Array.toList
04:58:44 <lambdabot> No results found
04:58:47 <Botje> @hoogle Data.Array.assocs
04:58:48 <lambdabot> Data.Array.IArray assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
04:58:48 <lambdabot> Data.Array.MArray getAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]
04:58:58 <Botje> ManateeL`: you could use assocs to see what's in the array.
04:59:03 <ski> @type concatMap
04:59:04 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
04:59:04 <ski> @type \a_mbs mas -> liftM concat (mapM a_mbs =<< mas)
04:59:06 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> m [a1] -> m [a]
04:59:06 <dafis> ManateeL`: the thing in the list is a MatchText ByteString, what's matchText?
04:59:10 <ski> @hoogle concatMapM
04:59:10 <lambdabot> No results found
04:59:33 <dafis> ManateeL`: or elems if you don't need the indices
04:59:35 <ManateeL`> dafit: type MatchText source = Array Int (source, (MatchOffset, MatchLength))
04:59:41 <Botje> ManateeL`: at a guess i'd say x ! 0 is the full string matched
04:59:53 <Botje> and your array will only have one element, as you're not capturing anything.
05:00:05 <Botje> but please verify that yourself with assocs :)
05:00:10 <dafis> ManateeL`: I think Botje guessed right
05:00:20 <ski> (cf. `concatMap a_bs as = concat (map a_bs as)')
05:00:46 <ManateeL`> @hoogle (!!)
05:00:47 <lambdabot> Prelude (!!) :: [a] -> Int -> a
05:00:47 <lambdabot> Data.List (!!) :: [a] -> Int -> a
05:01:09 <Botje> ManateeL`: no, one !
05:01:12 <Botje> @hoogle (!)
05:01:12 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
05:01:12 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
05:01:13 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
05:01:31 <ManateeL`> Thanks all, i'm confuse completely now. :)
05:01:43 * ski str that that `concatMapM' fails a monad law .. hm
05:01:58 <ryo_hazuki> thats what i wanted: mapM_ (\xs -> print =<< foo xs) [[1,2,3],[4,5,6]]
05:02:06 <ryo_hazuki> at least the solution is there =D
05:02:41 <Botje> ryo_hazuki: yay!
05:03:03 <fablex> hello all! anyone willing to give a quick hint to a total beginner?
05:03:10 <dafis> ManateeL`: forM_ blah $ \ar -> let ((word, (matchOffset, matchLength)) : _) = elems ar in what you have
05:03:27 <dafis> fablex: sure
05:03:33 <ryo_hazuki> fablex, this channel is full of friendly ppl who are willing to help
05:03:35 <Botje> ManateeL`: maybe run matchAllText (makeRegex "\\w+" :: Regex) msg :: [MatchText B.ByteString] yourself and see what comes out
05:03:41 <dafis> fablex: use Haskell :D
05:03:47 <fablex> how do I tell ghci the search path for libs (-L did not work). I configured&maked the SDL bindings for haskell under a custom prefix
05:03:48 <ryo_hazuki> ^_^
05:04:24 <fablex> now I am trying to tell ghci (or even ghc) to also search that path. currently the import of the module always fails
05:05:00 <maltem> fablex, ghc maintains a package database, so there should be no need to specify a search path
05:05:16 <fablex> you mean by using cabal?
05:05:37 <tensorpudding> it will search for modules X.Y.Z in the directory X/Y/Z.hs relative to the current directory
05:05:44 <tensorpudding> err, file*
05:05:51 <maltem> fablex, yep. If you run ghc-pkg list sdl, will the package show up?
05:06:20 <fablex> no, there are no binary packages for haskell-sdl for ubuntu 9.10
05:06:37 <mauke> irrelevant
05:06:44 <fablex> and I wanted to keep the self compiled binary within my home dir
05:07:09 <kmc> fablex, typically you'd configure cabal-install to install to your prefix, then use that
05:07:16 <maltem> fablex, that shouldn't be related to whether the module can be found
05:07:48 <kmc> once it's configured just 'cabal install SDL' and it should work
05:08:10 <handonson> is there a function that tells whether a string is a valid haskell identifier or not?
05:08:13 <fablex> maltem: but how should ghci find the module? I've not found to specify the ~/some/path/to/lib directoy...
05:08:29 <ski> ryo_hazuki : (aside, you could write `\xs -> print =<< foo xs' as `(print =<<) . foo' if you wanted .. but you might judge that to be less readable, here)
05:08:36 <maltem> fablex, oh did you omit the install (or register) step when installing the sdl bindings? Then it's guaranteed that it won't be found
05:08:38 <fablex> I do not have cabal :(
05:08:57 <maltem> fablex, no need for cabal-install necessarily. How did you install the bindings?
05:09:23 <fablex> no, it's installed but not as root
05:09:38 <maltem> yes, how did you install?
05:09:53 <kmc> fablex, my ghc looks at ~/.ghc/x86_64-linux-6.12.1/package.conf.d
05:09:54 <fablex> the module or the ghc base?
05:10:16 <mauke> the module
05:10:22 <maltem> the sdl bindings (I presumed this was about them)
05:10:29 <ski> ryo_hazuki : but, note that in case `print =<< foo xs' actually is a larger expression, it can make sense to write your `mapM_ (\xs -> print =<< foo xs) [[1,2,3],[4,5,6]]' instead as `forM_ [[1,2,3],[4,5,6]] $ \xs -> do x <- foo xs; print x', where the part after `do' would actually be written on new lines, indented under the `forM_ ... $ \xs -> do' line
05:10:31 <fablex> for the moduel I downloaded the tar.gz for the SDL bindings and used the make&configure (kind of) steps in the readme
05:10:33 <ryo_hazuki> ski, thats cool and more elegant - thats "pointfree-notation", right?
05:10:37 <kmc> that dir is full of ".conf" files saying where cabal-install has installed various stuff
05:10:38 <ski> yes
05:10:45 <mauke> fablex: that's wrong
05:10:58 <mauke> you need to configure first
05:11:15 <kmc> just set up cabal-install with your prefix, then "cabal install SDL"
05:11:29 <kmc> that should write the package conf to a dir where ghc will read it
05:11:38 <maltem> fablex, the procedure would typically be  runghc Setup.hs configure --user; runghc Setup.hs build; runghc Setup.hs install
05:11:43 <ski> ryo_hazuki : that way, the `\xs -> do ...' part acts like a "loop body" in your code (like `for (..; xs = ...; ...) {..x..}' in C-like languages)
05:11:46 <fablex> interesting, ~/.ghc/i386-linux-6.10.4/package.conf shows the SDL module
05:11:59 <kmc> fablex, what's the actual error you get?
05:12:18 <kmc> it might be solved by ghc --make
05:12:20 <dafis> fablex: not having cabal-install, use $ runhaskell ./Setup.hs configure --prefix=$WHERE; runhaskell ./Setup.hs build; runhaskell ./Setup.hs install
05:12:45 <kmc> in fact if you're invoking ghc yourself, you should always use --make
05:12:49 <ski> ryo_hazuki : of course, an alternative approach would be to define the "loop body" under some (hopefully) sensible name in a `where' and `let' and then just say `mapM_ loop_body [[1,2,3],[4,5,6]]' to invoke it
05:12:53 <fablex> mauke: yeas I configured first, that was just quick typing here...
05:13:19 <ski> ryo_hazuki : this is a matter of style, and the different options may each make sense, in different circumstances
05:13:23 <fablex> dafis: thats exaclty what I did (was documented in the readme)
05:13:52 <fablex> the error I get is: Could not find module `Graphics.UI.SDL.TTF.Render':
05:14:03 <dafis> fablex: then it should be properly installed and automatically found by ghci
05:14:28 <ryo_hazuki> ski, thx for the point =)
05:14:28 <maltem> fablex, well, that module is not part of the sdl package :)
05:14:33 <dafis> That module isn't provided by SDL
05:14:36 <maltem> you'll need sdl-ttf
05:14:44 <fablex> dafis: one difference was, the I was told to also add "--user"...
05:14:47 <ManateeL`> Botje, dafis, ivanm: Thanks for help! My problem fix now. :)
05:14:54 <ivanm> cool
05:15:18 <fablex> oh, I thought it would all be in one package
05:15:47 <fablex> ok, sorry. than it is obvious...
05:15:54 <maltem> Lection learnt: Don't tell them anything before you've seen the error message ^^
05:15:59 <ManateeL`> ivanm: Wow, my irc client can highlight nick color now. :) 
05:16:09 <fablex> and thank you all for your help
05:16:20 <ivanm> ManateeL`: \o/
05:18:02 <Botje> ManateeL`: yay!
05:18:08 * maltem notices that hackage now omits the synopsis from the Haddocks for both styles
05:18:15 <ivanm> preflex: seen c_wraith
05:18:15 <preflex>  c_wraith was last seen on #haskell 11 hours, 46 minutes and 7 seconds ago, saying: I use HDBC.  It's pretty primitive, but that's fine.
05:18:40 <maltem> or does it? now I'm confused
05:18:43 <ManateeL`> ivanm: I will post beautiful screenshot later. :)
05:19:04 <dafis> maltem: I get the synopsis in classic
05:19:32 <ManateeL`> Looks color algorithm need improve, maltem invisible in my irc client . :)
05:19:39 <ski> ryo_hazuki : yw
05:20:32 <maltem> dafis, yeah I misinterpreted what I see, some modules have a synopsis and some don't
05:21:47 <maltem> e.g. Graphics.UI.SDL.Types vs Graphics.UI.SDL.Video
05:22:39 <dafis> maltem: yeah, you get an actual synopsis only if you in fact write haddock comments
05:23:04 <maltem> ah
05:24:04 <dafis> maltem: otherwise, it would be just the same stuff twice, basically
05:24:42 <maltem> yep I see
05:25:17 <ManateeL`> Ooops, I wonder why can't color c_wraith, last i found he not here. ;p
05:25:46 <ivanm> ManateeL`: heh
05:26:09 <ManateeL`> ivanm: I just can color people that join in channel...
05:26:21 <ivanm> yes, that's a reasonable restriction IMHO
05:26:47 <ManateeL`> ivanm: Because i use MD5 calculate color value, so nick's color won't change.
05:27:06 <ivanm> yeah, I think xchat does that as well
05:27:07 <ManateeL`> ivanm: In my irc client, your nick is color purple. :)
05:27:13 <ivanm> but it only has 9 colours or something...
05:27:18 <ivanm> ManateeL`: hmmm....
05:27:24 <ManateeL`> ivanm: I have 65535 color . :)
05:27:31 <ivanm> heh
05:27:41 <ManateeL`> ivanm: But i need filter some color too dark or too light... 
05:27:56 <ManateeL`> ivanm: Example, maltem is invisible now. :)
05:28:09 <ivanm> heh
05:28:15 <handonson> ManateeL`: why don't you make it show bgcolor as well
05:28:17 <ivanm> yeah, maybe pick some sensible colour ranges
05:28:29 <ivanm> handonson: whilst testing?
05:28:42 <ManateeL`> ivanm: If some color too dark or too light, i will invert color.
05:28:43 <handonson> maybe pick bgcolor by the contrast color of fgcolor
05:29:19 <handonson> this way you don't have to specify anything
05:29:36 <ManateeL`> handonson: Right, i calculate luminance of background, then i can got better algorithm...
05:29:51 <ManateeL`> Improving....
05:30:39 <fablex> nice, my problem is solved, it works in ghci!!
05:32:24 <fablex> now if I would want to use ghc, how would I specify the SDL libs there (without I get undefined references, and adding "-lGraphics.UI.SDL -lGraphcis.UI.SDL.Image -lGraphics.UI.SDL.TTF" gives cannot find)?
05:32:39 <dafis> fablex: --make
05:33:14 <fablex> wow, it works, amazing ;)
05:33:21 <dafis> fablex: ghc --make module will take care of finding the Haskell dependencies itself
05:33:38 <fablex> so a like ghci does?
05:33:46 <dafis> fablex: yes
05:34:16 <fablex> wow, and I already started writing ugly make files to take care of dependecies...
05:34:25 <fablex> I'm impressed
05:34:37 * kmc mentioned it somewhere up there
05:34:40 <dafis> fablex: makefiles are for lesser languages :)
05:34:55 <dafis> kmc: not loud enough
05:34:57 <fablex> definately
05:35:14 <kmc> let's not get too snobby ;)
05:35:23 <ManateeL`> Which character is not valid character for nick name? Except ' '
05:35:28 <kmc> Haskell has a real module system but so do a lot of other languages
05:35:28 <handonson> the topic format makes me ache so bad to change it to something i can lookup :: a -> [(a, b)] -> Maybe b
05:36:17 <kmc> anyway fablex for anything you want to distribute e.g. on hackage, you'll use cabal rather than ghc --make
05:36:21 <kmc> see http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
05:36:32 <ManateeL`> mm_freak: Which character is not valid character for nick name? Except ' '
05:36:46 <kmc> ghc --make is great for quick development and i've used it for deployed projects too but it's not as capable as cabal
05:37:04 <ManateeL`> mm_freak: Now i know ' ' '\t' '\n' is not valid character.
05:37:08 <fablex> yes, in the long run I will try to use cabal.
05:37:11 <kmc> in fact i wish --make were the default mode for ghc
05:37:11 <dom96> ManateeL`: all servers are different.
05:37:17 <dafis> ManateeL`: '@' seems illegal too
05:37:29 <ManateeL`> dafis: yes,
05:37:37 <fablex> kmc: yes, and it should be mentioned in the first page of the ghc users guide
05:37:43 <dafis> ManateeL`: and ':'
05:37:51 <ManateeL`> dafis: I try use regex "\\w+" match nick name, but it's filter ManateeL` to ManateeL
05:38:01 <dom96> ManateeL`: if you send 'NICK SomeNick' the IRC Server will tell you if it's illegal.
05:38:11 <ManateeL`> dom96: Too cast.
05:38:18 <ManateeL`> dom96: I need build a regex to search.
05:38:25 <fablex> I was skimming half an hour and did not find out that all that weird mkdepedHS stuff seems to be obsolete 
05:38:36 <ManateeL`> dom96: Now i use regex "[^<> \t\n@:]+" to match nick name.
05:39:00 <dom96> ManateeL`: i see
05:39:18 <ManateeL`> dom96: Have you seen any nick use character '<' and '>' ?
05:39:59 <dom96> ManateeL`: no, but as i said, each server is different, i think some servers even let you configure which nicks are allowed.
05:40:06 <dafis> ManateeL`: '\''
05:40:19 <mauke> have you read the rfc?
05:40:31 <ManateeL`> mauke: RFC havne't those rule.
05:40:48 <dom96> ManateeL`: why do you need to match nicks?
05:40:52 <ManateeL`> mauke: I have read RFC-2812 and RFC-1459
05:41:02 <ManateeL`> dom96: Give unique color to every nick.
05:41:09 <ManateeL`> dom96: I have finish it.
05:41:12 <ManateeL`> dom96: Now in test.
05:41:28 <dom96> but why do you need to match the nicknames? can you not color them when you output them?
05:41:29 <mauke> <nick> ::=
05:41:30 <mauke>     <letter> { <letter> | <number> | <special> }
05:41:30 <Twey> Unreal allows (almost?) full Unicode nicks.
05:41:40 <ManateeL`> dom96: I use MD5 give every color an unique color
05:41:43 <mauke> <special> ::=
05:41:44 <mauke>     '-' | '[' | ']' | '\' | '`' | '^' | '{' | '}'
05:42:02 <dom96> ManateeL`: Do you color the nicks in the message?
05:42:16 <ManateeL`> dom96: When you irc message include some nick name, my irc client will highlight it.
05:42:41 <dom96> oh
05:42:41 <ManateeL`> dafis: \' is invalid ? I doubt it.
05:42:53 <ManateeL`> dom96: Yes.
05:43:01 <dom96> ManateeL`: check the userlist ?
05:43:20 <ManateeL`> dom96: I have update nick list when first login channel or someone join channel.
05:43:22 <dafis> ManateeL`: well, I tried to change my nick to something including '\'' and it wouldn't let me
05:43:27 <ryo_hazuki> ski, how can i print the results of a function with the type foo :: Int -> Maybe [Int]? types with -> IO [Int] are no problem - i dont know how to handle the Maybe correctly as it seems
05:43:51 <dom96> If any of the nicks from the list of nicks in the channel exists in the message then color them
05:43:54 <mauke> ryo_hazuki: print (foo 42)
05:44:02 <ManateeL`> dom96: I use MD5 calculate unique color for every nick when they join channel, and store in (Map NickName Color) 
05:44:16 <dom96> ManateeL`: what do you need to regex match for ?
05:44:38 <ManateeL`> dom96: When i print message in irc client, i will search word in (Map NickName Color), if match NickName, then color it.
05:44:50 <ski> ryo_hazuki : `print' can print values of type `Maybe [Int]' no problem
05:44:52 <ManateeL`> dom96: Don't need check userlist.
05:44:58 <ManateeL`> dom96: Dynamic update.
05:45:26 <ManateeL`> dafis: Ok, thanks for your suggestion, i change my regex. :)
05:45:31 <dom96> ManateeL`: i still don't get why you need regex for.
05:45:53 <dom96> i'm sure there is a way to do what you are doing, without using regex.
05:47:04 <dafis> I think just checking every word in the colour map would work too
05:47:25 <dafis> but it might be slower than pre-filtering with a regex
05:48:34 <ManateeL`> dom96: Because i need use regex filter every words in irc message.
05:48:46 <ryo_hazuki> ok, then i should change my question to the following: i want a generic function that can handle both Maybe and IO, it should simply print the input it gets to stdout
05:48:47 <ManateeL`> dom96: Not just beginning nick need color.
05:48:58 <ManateeL`> dom96: Wait my screenshot, you will understand why i need regex.
05:49:03 <dom96> ManateeL`: loop through each word and check if it's in the Map?
05:49:10 <drhodes> looking @ 1.7GB of irclogs, all nicks contained only these chars: "#'(*+,-./0123456789:;<>ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
05:49:25 <ManateeL`> dom96: Yes.
05:49:46 <dom96> ManateeL`: you don't need regex for that, and you won't have to worry about which characters are allowed, and which are not.
05:49:50 <ManateeL`> dom96: But not use function 'words' of String.
05:50:14 <ManateeL`> dom96: Example, i format irc message with <nick>, so i just words can't work.
05:50:31 <dom96> huh?
05:51:08 <ManateeL`> dom96: Example, "dom96's" can color dom96, if you use 'words' split String, you got dom96's and not nick dom96
05:51:12 <ski> ryo_hazuki : you can't really print a value of type `IO a' .. what you *can* do is to execute that action of type `IO a', to get a value of type `a', and then print that (and executing the action several times could of course give different results)
05:51:12 <ManateeL`> dom96: See ?
05:51:14 <mauke> form single regex from all nicks. scan.
05:51:38 <ManateeL`> dom96: Regex is search nick from word, word /= nickname
05:51:54 <mauke> no need to search words
05:52:02 <ski> ryo_hazuki : one *could* make an overloaded function which would first execute `IO'-actions, before printing, and for various other types, would just print .. but i don
05:52:08 <ryo_hazuki> ski, i used (=<<) for printing the IO value 
05:52:10 <ski> 't see why one would want to do this
05:52:21 <mauke> ryo_hazuki: no, you didn't
05:52:21 <ryo_hazuki> ok
05:52:33 <dom96> ManateeL`: i see.
05:53:03 <dafis> ManateeL`: With your regex, what would happen with the word skip, regarding that ski is a nick?
05:53:08 <ski> imo it is clearer, with `IO'-actions', to, with `<-' or `(=<<)' (or other similar things like `liftM2', &c.) to clearly mark where in the code the action is executed, as opposed to where the result value is printed
05:53:10 <ryo_hazuki> mauke, i thought i did, by using: print =<< foo
05:53:39 <ManateeL`> dafis: Won't, skip is skip, not nick ski
05:54:03 * ski is indeed not skip
05:54:05 <mauke> ryo_hazuki: that's print doing the printing, not =<<. and it's not printing an IO value, it's printing the result of running an IO value
05:54:06 <ManateeL`> mauke: I need think your suggestion, and compare which have better performance.
05:54:07 <dafis> ManateeL`: yeah, noticed that right after sending
05:54:28 <ryo_hazuki> ski, my idea was to have a function that handles all io-Action, not depending on IO or Maybe, was just an idea =)
05:55:00 <mauke> ryo_hazuki: actually it's not printing anything, it's building a new IO value that when run first runs foo, then prints the result
05:55:17 <ManateeL`> Maybe build regexp for all nick, then use this regexp match irc message is better idea, anyway, i need compare those two solutions.
05:55:55 <ryo_hazuki> mauke, that explanation made my code work :)
05:56:39 <mauke> sweet
05:56:44 <ski> ryo_hazuki : it's no problem to have a function handling *only* `IO'-actions, both executing and printing as it sees fit. what i was objecting to was to have a function which would handle *both* `IO'-actions and other values, executing the former before printing (but obviously not executing the latter, since they would not be `IO'-actions)
05:56:53 <ManateeL`> All, wait post new screenshot, then you can see what's it . :)
05:57:00 <ManateeL`> s/wait/wait i 
05:57:34 <ski> ryo_hazuki : also, note that my opposition to such a thing would be just that. it would be possible to do it, but i think it's bad to do so
05:58:19 <ryo_hazuki> ski, noted that - thx for the hint
06:01:14 <ManateeL`> mauke: You're right, if i build regexp for all nicks, i don't need care the rule of irc server that which character is allowed.
06:01:23 <ski> (this is in some sense similar to when people want `show' applied to strings to yield the same string, instead of that string, quoted. in both cases, someone asks for a strange special-casing of an overloaded operation. in the `show' case, to handle strings specially, while values of other types are converted to strings which are valid Haskell expressions, strings would then not be converted so. in your case, to have somethi
06:01:23 <ski> ng like `print' handle `IO'-action specially, to first execute an `IO'-action, instead of using the generic implementation of first converting the value to a string with `show', and then using `putStrLn' to output that (so, in that case, the *only* `IO'-effect is the one done by `putStrLn' .. not so, in what you asked for))
06:02:29 <ryo_hazuki> true
06:03:42 <ski> ryo_hazuki : no worry. i'm just trying to explain why i think what you asked (/ appeared to be asking) for would not be a sensible thing to do
06:04:09 <kmc> instance (Show a) => Show (IO a) where show = show . unsafePerformIO
06:04:12 <kmc> it's so easy!
06:04:14 * kmc ducks
06:04:15 <ryo_hazuki> i think i understood what you actually wanted to say
06:04:30 <ryo_hazuki> haha - i read about that unsafePerformIO, kmc =D
06:04:45 <ryo_hazuki> the ppl on that thread weren't very happy about that suggestion
06:04:56 <kmc> hehe
06:05:19 <kmc> also that's an orphan instance
06:05:24 <kmc> but that's probably the least of your worries ;P
06:06:19 <ski> (generally, special cases should be avoided, unless they naturally fall out of the problem domain, because it's hard to remember what the special cases are, and it needlessly complicates code, often making designs less orthogonal, as well, commonly with unintended consequences)
06:06:22 <kmc> i should note that ghci's toploop does the sort of special-casing ski describes
06:06:33 <MasseR> http://www.haskell.org/all_about_monads/html/writermonad.html warns about using list as the monoid for writer as it's mappend is slow when data gets big and recommends using faster data structures. What are some faster data structures?
06:06:54 <kmc> MasseR, dlist, Data.Sequence, vectors maybe
06:06:57 <dafis> difference lists
06:07:08 <ski> (one can probably argue better against special cases .. that was just what appeared in my mind atm)
06:07:14 <kmc> MasseR, lists are singly-linked lists, so you have to walk along the entirety of what you've accumulated to stick something onto the end
06:07:23 <ivanm> kmc: would vectors really be efficient for appending?
06:07:26 <kmc> the beginning is not as bad
06:07:28 <MasseR> kmc: Wow fast answer. Thanks
06:07:33 <kmc> ivanm, if they resize up by powers of two
06:07:37 <kmc> i'm not sure how 'vector' is implemented
06:07:42 <ivanm> yeah
06:08:21 <kmc> ryo_hazuki, ghci does something different for a) IO t where Show t, b) IO t where not Show t, c) IO (), d) other types
06:08:29 <kmc> it can be confusing
06:09:41 <ryo_hazuki> very confusing - must be the reason why i ask so many questions ;))
06:10:15 <kmc> if you type "e" it will do execute either «e», «e >>= print», or «print e» depending on the type of e
06:10:51 * kmc afk
06:11:07 <ski> (nitpick : aiui s/where Show t/where Show t is known (in the current context)/,s/where not Show t/where Show t is not known (in the current context)/)
06:12:14 <dafis> other nitpick: s/e >>= print/e >>= \x -> print x >> return x/
06:12:44 <handonson> really?
06:13:21 <handonson> oh, probably because it becomes reference-able by 'it'. 
06:13:29 <dafis> handonson: yep
06:13:53 <mm_freak> ManateeL`: the delimiter characters
06:14:19 <mm_freak> ManateeL`: the standard defines a strict set of characters, but unfortunately the IRCds don't follow the standard here
06:14:38 <mm_freak> hence fastirc accepts any character other than the delimiters
06:16:05 <ManateeL`> mm_freak: I have perfect solution and don't care server's rule.
06:16:44 <ivanm> is there a pre-done version of "foldr (.) id" ?
06:16:54 <ryo_hazuki> sequence_ is a very cool function, too :]
06:17:41 <ManateeL`> mm_freak: Because i will collect nick name store in (Map NickName Color) when people join channel, then i can use regex "[<]?(nick1|nick2|nick3|...|nickN)[>]?" match all nicks in current channel, and don't care server's rule.
06:18:15 <ManateeL`> mm_freak: Maybe i need some "\\<" and "\\>" to improve, but that's basic idea.
06:18:30 <ManateeL`> mm_freak: Build regexp to match all nick then scan irc message.
06:18:47 <dafis> ivanm: I don't think so
06:18:48 <ManateeL`> mm_freak: *Not* build fixed server rule to match nick.
06:19:22 <ManateeL`> Testing new regexp... 
06:19:39 <dafis> @hoogle [a -> a] -> a -> a
06:19:39 <mm_freak> ManateeL`: i never use regexp for real applications
06:19:40 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
06:19:40 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
06:19:40 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:19:44 <mm_freak> only for quick-n-dirty code
06:19:50 <mm_freak> because regexps tend to break
06:20:00 <mm_freak> and they are not very composable
06:20:08 <ManateeL`> mm_freak: I think you misunderstand my point.
06:20:18 <ryo_hazuki> @hoogle [m a] -> m [a]
06:20:18 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:20:18 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:20:18 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
06:20:24 <ryo_hazuki> cool :)))
06:20:29 <ManateeL`> mm_freak: I use regexp search nick in irc messsage, then generate unique color for nick.
06:20:41 <ManateeL`> s/generate/display
06:20:42 <mm_freak> ManateeL`: why?
06:20:53 <ryo_hazuki> wheres the difference between Control.Monad sequence and Prelude sequence?!
06:21:07 <mm_freak> ryo_hazuki: they are the same
06:21:17 <dafis> ryo_hazuki: Prelude.sequence is a re-export
06:21:22 <ryo_hazuki> mm_freak, ok, ty =)
06:21:22 <mm_freak> Prelude just reexports Control.Monad's 'sequence
06:21:25 <ManateeL`> mm_freak: I have build (Map NickName Color) when people join, so any irc message include nick name, my irc client will highlight nick *in* irc message.  
06:21:43 <mm_freak> ManateeL`: then what do you need the regexp for?
06:21:52 <mm_freak> you get the nickname in a UserSpec
06:21:55 <mm_freak> generate a color from it
06:22:05 <handonson> mm_freak: to find nicknames in a message
06:22:18 <mm_freak> handonson: why?  he uses fastirc, which does that for you
06:22:27 <ivanm> dafis: yeah, didn't think so but figured I'd check
06:22:28 <mm_freak> without nasty regexps, but with a real parser
06:22:51 <handonson> mm_freak: no, nicknames in the *message* part
06:22:59 <ryo_hazuki> does emacs with haskell-mode support that @hoogle search ?! if so, how can i initiate such a search? 
06:23:00 <mm_freak> i see
06:23:05 <mm_freak> well, use list functions =)
06:23:16 <ManateeL`> mm_freak: Not parse *raw* irc data, is parse message i format in irc client. See ?
06:23:36 <hvr> ryo_hazuki: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Emacs_Integration_with_Hayoo 
06:23:54 <ManateeL`> mm_freak: I use regexp when i need *print* in gtk+ program. 
06:24:10 <mm_freak> ManateeL`: you mean the "text", because when you talk about a "message" when coding, that usually means an IRC message, not a PRIVMSG/NOTICE ;)
06:24:30 <ManateeL`> mm_freak: Well, my fault. :)
06:24:36 <ryo_hazuki> hvr, ty
06:24:46 <mm_freak> anyway, you don't really need regexps for that…  the usual ByteString functions should suffice
06:25:15 <ManateeL`> mm_freak: Better performance.
06:25:36 <mm_freak> i'd be especially careful about building a regexp from data sent by a remote program
06:26:04 <ManateeL`> mm_freak: Well, I think you misunderstand my regexp.
06:26:05 <mm_freak> ManateeL`: i'm pretty sure the usual ByteString functions are much faster than a regexp ;)
06:26:13 <mm_freak> especially since you rebuild the regexp all the time
06:27:40 <ManateeL`> mm_freak: I need highlight mm_freak in string : mm_freak's , if not use regexp, how do you handle it?
06:29:09 <Axman6> "mm_freak" `isInfixOf` str
06:29:33 <ManateeL`> Well, regexp logic is much simple.
06:29:51 <dafis> Axman6: that doesn't give the location
06:30:30 <dafis> and it wouldn't detect "mm_freak:" vs. "mm_freakish_stuff"
06:32:17 <Axman6> > let f s xss@(_:xs) | s `isPrefixOf` xss = 0 | otherwise = 1 + f s xs; f _ [] = maxBound :: Int in f "mm_freak" "will this find mm_freak? I hope so"
06:32:18 <lambdabot>   15
06:32:27 <Axman6> > let f s xss@(_:xs) | s `isPrefixOf` xss = 0 | otherwise = 1 + f s xs; f _ [] = maxBound :: Int in f "mm_freak" "will this find mm_freeak? I hope not"
06:32:29 <lambdabot>   -9223372036854775773
06:33:04 <mm_freak> ManateeL`: dunno, i might be writing a parser to do this
06:33:30 <ManateeL`> mm_freak: So, regexp logic is simple, just need write regexp string.
06:33:46 <mm_freak> ManateeL`: parser logic is simpler and doesn't have unwanted side effects
06:33:49 <dafis> > maxBound :: Int
06:33:50 <lambdabot>   9223372036854775807
06:33:57 <ManateeL`> I have play much regexp in Emacs, i think regexp is clearest way at some situation.
06:34:04 <dafis> > let f s xss@(_:xs) | s `isPrefixOf` xss = 0 | otherwise = 1 + f s xs; f _ [] = maxBound :: Int in f "mm_freak" "will this find mm_freeak? I hope not"
06:34:05 <lambdabot>   -9223372036854775773
06:34:13 <mm_freak> for example your regexp will fail for nicknames containing certain characters
06:34:18 <ManateeL`> mm_freak: Well, if you write regexp careful, won't *unwanted* string.
06:35:01 <ManateeL`> mm_freak: Above regexp is sub-regexp of *complete* regexp.
06:35:11 <ManateeL`> mm_freak: Real regexp haven't finish.... :)
06:35:22 <ManateeL`> Still in testing...
06:42:35 <ivanm> huh, doesn't ((,,) a b) have a Functor instance?
06:44:08 <dafis> ivanm: not in any library I know
06:45:13 <ivanm> yeah, I just figured it would
06:45:30 <ivanm> then again, over-usage of large tuples is frowned upon...
06:45:34 <dafis> ivanm: too rarely used, nobody needed it before ?
06:45:41 <ivanm> probably
06:45:47 <ManateeL`> mm_freak: Final regexp is "([<]?|\\<)(nick1|nick2|..|nickN)([>]?|\\>)"
06:45:48 <dafis> ivanm: three's not large
06:46:14 <ivanm> well, it's unlikely you would worry about fmap'ing a triple
06:47:11 <aristid> > fmap (+1) (1,1)
06:47:12 <lambdabot>   (1,2)
06:47:24 <aristid> would it change the last of the three elements?
06:47:25 <mm_freak> ManateeL`: http://hpaste.org/30174/word_highlighter
06:47:37 <dafis> > fmap (fmap (+1)) (1,(1,1))
06:47:38 <lambdabot>   (1,(1,2))
06:47:46 <aristid> dafis: that is not a triple.
06:47:47 <ddarius> ManateeL`: Why are you so set on using MD5 for hashing the names?
06:48:00 <ivanm> aristid: yeah
06:48:15 <dafis> aristid: sure, it's a weak work-around exploiting available instances
06:48:33 <aristid> dafis: it also requires two fmaps :)
06:48:35 <copumpkin> ddarius: gotta be an insecure cryptographic hash, says so in the spec
06:48:47 <ivanm> copumpkin: heh
06:48:50 <dafis> aristid: that's one of the reasons it's weak
06:48:52 <mm_freak> MD5 isn't insecure
06:49:02 <ivanm> ddarius: *shrug* I suppose he wants/needs _some_ String -> Int mapping
06:49:04 <mm_freak> it's not collision-resistant, which makes it insecure for certain applications
06:49:13 <mm_freak> but it's still good for, say, password hashing
06:49:15 <ivanm> and md5 was presumably fast enough to serve
06:49:20 <ManateeL`> ddarius: I have elisp version use MD5, use MD5 is easy to rewrite with Haskell. :)
06:49:38 <copumpkin> mm_freak: secure == completely opaque, in my book
06:49:40 <copumpkin> :P
06:49:45 <ivanm> mm_freak: huh? I thought SHA-2 or something was preferred for passwords to avoid brute-forcing via collisions...
06:49:52 <mm_freak> and you're not gonna construct collisions for nicknames, when using MD5 ;)
06:50:04 <ivanm> ManateeL`: are you using a pre-existing md5 implemention or rolling your own?
06:50:10 <mm_freak> ivanm: doesn't make sense to me
06:50:14 <ManateeL`> mm_freak: Yes, that's my point.
06:50:17 <dafis> but, people, for a nick -> colour map, md5 is certainly good enough?
06:50:21 <ivanm> mm_freak: what doesn't>
06:50:22 <ManateeL`> mm_freak: Avoid collision. :)
06:50:29 <copumpkin> lol
06:50:33 <mm_freak> ivanm: bruteforcing by constructing collisions?
06:50:38 <ManateeL`> dafis: Fast enough.
06:50:51 <mm_freak> dafis: yes, it is
06:51:02 <mm_freak> MD5 is a good hash function, just not a good cryptographic one =)
06:51:04 <ManateeL`> dafis: Just truncate 12-bit from MD5 restul for build color.
06:51:15 <mm_freak> and MD5 is also a good cryptographic hash for certain applications
06:51:18 <ManateeL`> mm_freak: I have test MD5, fast enough.
06:51:29 <ivanm> mm_freak: well, whatever; my understanding is that md5 is easier to brute force or to generate collisions such that systems could be broken into
06:51:45 <copumpkin> ManateeL`: you can handle 1000000 people talking simultaneously using 4% CPU for name hashing? :P
06:51:57 <mm_freak> ivanm: it's easy to generate collisions for MD5, so it's useless for applications like digital signatures
06:51:58 <handonson> for a nick -> color map, i'd rather use a simple modulo operation
06:52:07 <mm_freak> ivanm: but MD5 is still fine for password hashing
06:52:07 <ManateeL`> copumpkin: Which channel have 1000000 guys?
06:52:26 <mm_freak> ivanm: and it's, in fact, used for that…  look into your /etc/shadow for $1$ strings =)
06:52:31 <dafis> ManateeL`: #haskell, next december
06:52:36 <mm_freak> those indicate that MD5 was used for the hashing
06:52:41 <ManateeL`> dafis: Heh. :)
06:52:45 <ivanm> mm_freak: fair enough
06:53:36 <ManateeL`> Well, i need off to test code, talk too much. :)
06:54:40 <dark> I can't find documentation on haskelldb
06:54:54 <dark> http://trac.haskell.org/haskelldb/ has dead links, etc
06:55:51 <dark> maybe i'm not looking at the right place?
06:56:40 <dafis> dark: the haddocks aren't enough?
06:56:46 <fryguybob> ManateeL`: For what it's worth, I wanted colored nicks about a month ago and didn't want to spend much time on it and did this: http://hpaste.org/30175/hash_nick
06:56:49 <fryguybob> It worked good enough for me.
06:56:53 <dark> http://hackage.haskell.org/package/haskelldb i can't see inline docs here
06:56:54 <ManateeL`> Have any concatMap_ similar concatMap, but don't do last one?
06:57:26 <copumpkin> :t (concatMap .) . init
06:57:27 <lambdabot> forall a b. [a -> [b]] -> [[a] -> [b]]
06:57:32 <copumpkin> okay, maybe not
06:57:37 <copumpkin> :P
06:57:42 <ManateeL`> fryguybob: You can every nick have unique color?
06:57:54 <dafis> dark: for example: http://hackage.haskell.org/packages/archive/haskelldb/0.12/doc/html/Database-HaskellDB.html ?
06:58:02 <ManateeL`> fryguybob: s/can/can promise
06:58:22 <maltem> :t \f -> concatMap f . init
06:58:23 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:58:46 <dafis> :t \f -> concatMap f . init
06:58:47 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:59:14 <fryguybob> ManateeL`: That wasn't my goal, I just wanted them "different enough", but you could generate a different nickHashMap that for a given data set it would perfectly hash.
06:59:29 <dark> dafis, interesting
06:59:56 <dark> I was more looking for some beginner tutorial and whatnot
06:59:57 <ManateeL`> fryguybob: Thanks, My irc client need unique color for every nick.
07:00:20 <dafis> dark: 0.13 had a build failure on hackage, therefore no docs for that one. If you install, you should get docs locally
07:00:28 <dark> ah...
07:00:34 <ManateeL`> fryguybob: Example, purple is ivanm's color, always. :)
07:00:48 <dafis> dark: tutorial, heh, I've no idea whether there exists one
07:00:49 <dark> cabal wants to install 0.13
07:00:56 <dark> should I install 0.12 instead?
07:01:07 <dark> ghc 6.12.3 here
07:01:36 <dafis> dark: I think 0.13 should be okay, unless you have a specific reason to prefer the older version, go with the latest
07:02:35 <dark> maybe because it will fail here too? but i'm giving a try
07:03:44 <fryguybob> ManateeL`: Right, any given nick will have the same color, but two different nicks could also have the same color.
07:04:31 <dark> no, it installed..
07:04:40 <ManateeL`> fryguybob: That's why i choose MD5, it's *almost* impossible same color for different nick.
07:05:31 <ManateeL`> fryguybob: I will always use MD5, if someday #haskell have 1000000 nick,  CPU is damn fast enough.
07:05:43 <dafis> dark: on hackage, it failed because HsColour choked on an illegal byte sequence, I suspect latin1 encoding instead of utf-8, so it might be a problem globally
07:06:00 <fryguybob> ManateeL`: Well is it possible for the human eye to distinguish that many colors?  Or the brain to follow that many conversations?
07:06:12 <dark> where cabal installs it?
07:06:26 <dark> there is no /usr/lib/ghc-6.12.3/haskelldb-*
07:06:31 <aristid> ManateeL`: how do you deal with people having more than one nick?
07:06:41 <ManateeL`> aristid: Ignore.
07:06:47 <dafis> dark: cabal does user-installs by default
07:06:50 <ManateeL`> aristid: Different nick has different color.
07:07:05 <dafis> dark: ghc-pkg list should show it in the user-db
07:07:05 <dark> ... and how to install it globally?..
07:07:10 <ManateeL`> aristid: Since it's can't tracing user/host always correctly.
07:07:19 <co_dh> not just color, we could have different font , etc
07:07:25 <dafis> dark: cabal install --global haskelldb
07:07:42 <ManateeL`> co_dh: Well, if you want, you can build biggest font for yourself. :)
07:07:54 <ManateeL`> co_dh: I guess haven't so much font in this world. :)
07:08:09 <dark> ah, ok.. so ghc will use it automatically?
07:08:22 <dafis> dark: yes
07:08:33 <co_dh> ManteeL: not necessarily 1 nice vs 1 font. 
07:08:46 <dafis> dark: but if it's in the user-db, it's only available for you
07:08:55 <co_dh> I might add special font for a few friends.
07:09:08 <dark> may I uninstall the local cabal package by rm -rf ~/.cabal?
07:09:28 <dark> it's actually on ~/.ghc/i386-linux-6.12.3/package.conf.d
07:09:35 <dafis> dark: no, ghc-pkg unregister [--user] haskelldb
07:10:07 <dafis> dark: after that you can simply do the global install
07:10:36 <dark> but I suppose that ghc / cabal would do fine if ~/.cabal and ~/.ghc directories were suddently removed
07:10:41 <ManateeL`> co_dh: Yes, it's eay in gtk2hs code. :)
07:10:53 <ManateeL`> co_dh: I will add your suggestion in my todo list.
07:11:04 <dafis> dark: you can remove some package directories in ~/.cabal if your disk space is scarce
07:11:12 <co_dh> ManateeL: what are you working on?
07:11:36 <ManateeL`> co_dh: Haskell OS : http://www.flickr.com/photos/48809572@N02/
07:12:05 <dafis> dark: if ~/.cabal is removed, you'll possibly lose cabal-install, normally that's in ~/.cabal/bin
07:12:39 <dark> I have no cabal-install..
07:12:52 <dark> just cabal install (like, hmm, git)
07:13:00 <dafis> dark: the executable is called cabal
07:13:07 <co_dh> ManateeL`: weird,  the images are so slow
07:13:19 <dark> also no ~/.cabal/bin
07:13:24 <dafis> dark: $ which cabal
07:13:25 <ManateeL`> co_dh: It's your network problem. :)
07:13:35 <dark> /usr/bin/cabal
07:14:08 <dark> (from gentoo-haskell overlay)
07:14:23 <ryo_hazuki> is there a function that can count how many lists are in a list? just for sake of curiosity
07:14:23 <dafis> dark: okay, then removing ~/.cabal won't hose your setup, it might just remove stuff you'd like to reinstall afterwards, depends
07:14:25 <co_dh> ManateeL`: the government is filtering the images. as far as I know, wiki is filtered 
07:14:34 <mauke> ryo_hazuki: length
07:14:35 <dafis> ryo_hazuki: length
07:14:38 <aristid> ryo_hazuki: lists in a list??
07:14:56 <aristid> > length [[1,2],[3,4]]
07:14:58 <lambdabot>   2
07:14:58 <ManateeL`> co_dh: Chinese?
07:14:58 <co_dh> > length [ [1,2], [3,4]]
07:14:59 <lambdabot>   2
07:15:08 <co_dh> ManateeL`: yep
07:15:09 <aristid> co_dh: you evil mind-copier
07:15:13 <ManateeL`> co_dh: Me too. :)
07:15:32 <co_dh> aristid: lol
07:16:26 <ManateeL`> co_dh: You need some proxy tool.
07:16:56 <ManateeL`> co_dh: I'm test irc client now, can we talk later? Thanks! :)
07:17:19 <ryo_hazuki> hehe, thanks guys - i probably misformulated my problem, but it's solved anyway :)
07:17:47 <aristid> ryo_hazuki: what is the real problem?
07:18:02 * ManateeL` Damn hot #haskell make me work inefficient. :-(
07:19:55 <ryo_hazuki> aristid, i thought of a function that counts lists, lets say [[1],[[2],[3]]], and the function counts three lists 
07:20:21 <Axman6> ryo_hazuki: that's not a valid list
07:20:22 <aristid>  [[1],[[2],[3]]] <- this is not valid haskell (normally)
07:20:23 <co_dh> :t sum .  map length
07:20:24 <lambdabot> forall a. [[a]] -> Int
07:20:30 <dafis> ryo_hazuki: that doesn't type-check
07:20:33 <aristid> :t [[1],[[2],[3]]]
07:20:34 <lambdabot> forall t. (Num [t], Num t) => [[[t]]]
07:20:35 <Axman6> NO!
07:20:52 <ryo_hazuki> i thought it would, coz ghci said: [[1],[[2],[3]]] :: (Num [t], Num t) => [[[t]]]
07:21:09 <Axman6> but there is no instance for Num [t]
07:21:22 <dafis> ryo_hazuki: well, it will if you have such an instance in scope
07:21:30 <Axman6> > [[1],[[2],[3]]]
07:21:30 <dafis> ryo_hazuki: but please, don't
07:21:31 <lambdabot>   No instance for (GHC.Num.Num [t])
07:21:31 <lambdabot>    arising from a use of `e_1123' at <int...
07:22:03 <ryo_hazuki> dafis, can you explain why i shoudn't? just for the sake of curiosity again
07:22:12 <ryo_hazuki> Axman6, makes sense
07:22:33 <mauke> ryo_hazuki: how would you define such an instance?
07:22:42 <dafis> ryo_hazuki: because there are no clear semantics for an instance (Num t) => Num [t]
07:22:43 <ryo_hazuki> mauke, dunno yet :)
07:23:01 <mauke> dafis: (Num t) => is not required
07:23:09 <co_dh> ryo_hazuki: least surprise principle. Don't make us surprise. because we are not expecting Num t and Num [t]
07:23:12 <aristid> mauke: well, i suppose it would be possible to write a ZipList-like instance of Num for [t]
07:23:20 <ryo_hazuki> dafis, then my question would be if its possible anyway? =o
07:23:35 <dafis> mauke: right, but instance Num [Char] would be even weirder
07:23:37 <ryo_hazuki> or why it is possible THEN
07:23:39 <dark> is it possible to write a some code that can count the number of elements of a list, and the number of elements of a list of lists? like returning 3 for (something [1, 2, 3]) and 4 for (something [[1, 2], [3, 4]])
07:23:39 <mauke> ryo_hazuki: sure it is, everything is possible
07:23:58 <ryo_hazuki> mauke, hehe
07:24:05 <mauke> ryo_hazuki: it just might not make any sense
07:24:14 <aristid> > ['x', ['y', 'z']]
07:24:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:24:15 <lambdabot>         against inferred type...
07:24:19 <aristid> :t ['x', ['y', 'z']]
07:24:20 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
07:24:20 <lambdabot>     In the expression: ['y', 'z']
07:24:21 <lambdabot>     In the expression: ['x', ['y', 'z']]
07:24:28 <Axman6> one instance for Num [t] is treating them as polynomials
07:24:33 <ryo_hazuki> dark, as for my understand, your first sample would give 1 and the snd sample would give 2
07:24:38 <Axman6> [1,2,3] -> a + 2x + 3x^2
07:24:42 <Axman6> 1*
07:24:49 <Axman6> which can work quite well
07:24:53 <mauke> dark: your first example is wrong if there's an instance Num [t]
07:25:09 <aristid> Axman6: with inverted order of the coefficients?
07:25:23 <dark> isn't the list [1, 2, 3] a list with 3 elements?
07:25:26 <Axman6> yeah
07:25:34 <Axman6> because it makes (+) = sipWith (+)
07:25:40 <aristid> ryo_hazuki: this is important: ALL LIST ELEMENT MUST HAVE THE SAME TYPE
07:25:42 <Axman6> z*
07:25:49 <mauke> dark: yes, but 1 could be another list
07:25:53 <mauke> same for 2 and 3
07:26:01 <aristid> Axman6: is the polynomial instance of [t] identical to the ZipList-like instance?
07:26:08 <Axman6> no idea
07:26:10 <aristid> hmm probably not
07:26:15 <aristid> breaks down for (*)
07:27:16 <aristid> (*) = zipWith (*) does not hold for polynomials
07:27:18 <dark> mauke, I was thinking about this problem, in order to know if it's feasible to have this "something" applied to [a], [[a]], [[[a]]], .., and still have static typing. seems too much for haskell
07:27:23 <Axman6> there's an instance on the haskell wiki somewhere, someone's "mind blowing" examples of things
07:27:41 <mauke> dark: you don't know the type of 1
07:27:59 <dark> mauke, suppose it's something simpler, like 'a'
07:28:10 <mauke> 'a' is the most complicated type
07:28:13 <mauke> it can be anything at all
07:28:18 <ryo_hazuki> mind blowing examples rock :]
07:28:20 <dark> :t 'a'
07:28:21 <lambdabot> Char
07:28:27 <mreh>  (\a -> let (b,c) = (fdFun fd1) (a,c) in b)
07:28:29 <mauke> oh, you mean 「'a'」
07:29:01 <mreh> how is it possible to rewrite that with fix?
07:29:14 <mauke> @pl (\a -> let (b,c) = (fdFun fd1) (a,c) in b)
07:29:15 <lambdabot> (line 1, column 12):
07:29:15 <lambdabot> unexpected "("
07:29:15 <lambdabot> expecting "()", natural, identifier or "in"
07:29:21 <mauke> aw
07:29:49 <aristid> :t fdFun
07:29:50 <lambdabot> Not in scope: `fdFun'
07:30:05 <mreh> ignore the fdFun, I wanted to edit it, but I copied the newline
07:30:27 <aristid> @hoogle fdFun
07:30:27 <lambdabot> No results found
07:30:34 <mauke> aristid: ?
07:30:37 <mreh> this: let (b,c) = f (a,c) in b
07:30:54 <aristid> mauke: ?
07:31:01 <mauke> aristid: what are you doing?
07:31:12 <aristid> mauke: looking for the fdFun from mreh's example
07:31:19 <aristid> maybe it's a library function
07:31:19 <mauke> why?
07:31:23 <aristid> the name made me curious
07:31:35 <mreh> aristid: it's a Yampa internal
07:31:37 <ManateeL`> "user error (Text.Regex.Posix.ByteString died: (ReturnCode 11," regexp code crash, how possible?
07:31:42 <aristid> sounds like a function that creates a file descriptor from a function
07:31:42 <dafis> mreh: fst $ fix (\(_,c) -> f (a,c)) ?
07:32:09 <aristid> mreh: what is yampa?
07:32:26 <aristid> :t fix (\(_,c) -> f (a,c))
07:32:27 <lambdabot> forall t t1. (Show t1, SimpleReflect.FromExpr (t, t1)) => (t, t1)
07:32:27 <mreh> @google Haskell Yampa
07:32:28 <lambdabot> http://www.haskell.org/yampa/
07:32:28 <lambdabot> Title: Yampa
07:32:39 <aristid> :t \a -> fix (\(_,c) -> f (a,c))
07:32:40 <lambdabot> forall t t1 t2. (Show t2, Show t1, SimpleReflect.FromExpr (t, t1)) => t2 -> (t, t1)
07:32:46 <aristid> :t \f a -> fix (\(_,c) -> f (a,c))
07:32:47 <lambdabot> forall t t1 t2. ((t2, t1) -> (t, t1)) -> t2 -> (t, t1)
07:33:00 <aristid> :t \f a -> fst $ fix (\(_,c) -> f (a,c))
07:33:02 <lambdabot> forall a b t. ((t, b) -> (a, b)) -> t -> a
07:33:09 <ManateeL`> Possible too *big* 'Regex' crash regexp package?
07:33:22 <dark> but the simpler problem for cases [a] and [[a]]
07:33:25 <dark> ops
07:33:54 <dafis> ManateeL`: quite possible
07:34:08 <ManateeL`> dafis: My logic is right.
07:34:22 <dafis> ManateeL`: compiling a big regex would take a lot of memory, I think
07:34:41 <ManateeL`> dafis: Ok, switch regexp "[^<> \t\n\'@:]+"
07:34:51 <ManateeL`> dafis: I think it's good enough.
07:34:58 <dafis> ManateeL`: *how* big was the regex?
07:35:14 <ManateeL`> dafis: Same as nick number of #haskell.
07:35:25 <ManateeL`> dafis: "([<]?|\\<)(nick1|nick2|..|nickN)([>]?|\\>)"
07:35:40 <dafis> ManateeL`: and all `|'-ed?
07:35:47 <ManateeL`> dafis: Yes.
07:35:51 <mauke> dark: http://codepad.org/iijCoL0l
07:35:55 <ManateeL`> dafis: Better regexp?
07:36:01 <Axman6> what a horrible regex
07:36:17 <dafis> ManateeL`: what about a trie?
07:36:20 <ManateeL`> Axman6: Better one?
07:36:34 <Axman6> pretty much anything ;)
07:36:47 <dark> mauke, hmm @.@
07:37:21 <dark> mauke, but one needs to list all primitive types where it's valid? can't Foo Char be replaced by Foo <non-list>?
07:37:22 <ManateeL`> dafis: Well, i think it's *issue* of regexp package, since i have some elisp extension build so big regexp in Emacs, won't failed.
07:37:53 <mauke> dark: no
07:37:59 <dafis> ManateeL`: ask the maintainer
07:38:05 <dark> well .-. better than nothing .-.
07:38:07 <mauke> well, unless you're oleg, but I'm not
07:38:37 <dark> (better than other languages I heard of anyway)
07:38:59 <dark> (maybe agda can implement this in its full generality?)
07:40:11 <drhodes> [(a, [a], [[a]] ..)] 
07:42:23 <ManateeIrcClient> dafit: I'm testing, looks nick color regexp works well.
07:42:43 <ManateeIrcClient> Oops, is dafis. :)
07:42:56 <dafis> mauke: OverlappingInstances, FlexibleInstances: http://hpaste.org/30176/evil_overlappinginstances
07:46:51 <ManateeL`> @hoogle absolute
07:46:52 <lambdabot> System.IO AbsoluteSeek :: SeekMode
07:46:52 <lambdabot> Data.Time.Clock.TAI data AbsoluteTime
07:46:52 <lambdabot> Data.Time.Clock.TAI addAbsoluteTime :: DiffTime -> AbsoluteTime -> AbsoluteTime
07:47:18 <ManateeL`> Which function return "Absolute Value" ?
07:47:22 <mauke> abs
07:47:23 <aristid> :t abs
07:47:26 <lambdabot> forall a. (Num a) => a -> a
07:47:27 <ManateeL`> makmanalp: Thanks,
07:47:39 <mauke> maltem: you're welcome
07:47:42 <ManateeL`> > abs (1 - 10)
07:47:43 <lambdabot>   9
07:48:12 <aristid> > abs (-0.9)
07:48:13 <lambdabot>   0.9
07:48:30 <maltem> 
07:49:03 <dafis> > abs (exp $ 0 :+ pi)
07:49:04 <lambdabot>   1.0 :+ 0.0
07:49:14 <mauke> > abs (1 / negate 0)
07:49:15 <lambdabot>   Infinity
07:49:25 <dafis> > abs (0/0)
07:49:26 <lambdabot>   NaN
07:49:29 <aristid> TEH FUN
07:49:42 <aristid> > 1 / negate 0
07:49:43 <lambdabot>   -Infinity
07:50:05 <dafis> > 1 / negate 0 :: Rational
07:50:06 <lambdabot>   *Exception: Ratio.%: zero denominator
07:50:08 <co_dh> :t (:+)
07:50:09 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
07:50:10 <mauke> :t 1 / abs
07:50:11 <lambdabot> forall a. (Fractional a) => a -> a
07:50:25 <co_dh> > exp 0 
07:50:26 <lambdabot>   1.0
07:50:33 <mauke> > 1 / abs $ negate 0
07:50:34 <lambdabot>   -Infinity
07:50:35 <co_dh> > map exp [0, 1,2,3]
07:50:36 <lambdabot>   [1.0,2.718281828459045,7.38905609893065,20.085536923187668]
07:51:08 <mauke> wait, what
07:51:11 <dafis> > exp (0 :+ pi) + 1
07:51:12 <lambdabot>   0.0 :+ 1.2246467991473532e-16
07:51:16 <ManateeL`> co_dh: I suggest you download "yourfreedom" proxy tool, it written by Java, works fine on Windows and Linux.
07:51:53 <aristid> ManateeL`: are you in mainland china?
07:51:53 <Axman6> > (1 / abs) 3
07:51:55 <lambdabot>   0.3333333333333333
07:51:58 <Axman6> huh
07:52:03 <co_dh> ManateeL`: I'm lazy
07:52:03 <mauke> > (1 / abs) (-2)
07:52:04 <Axman6> how does that work
07:52:04 <lambdabot>   0.5
07:52:06 <ManateeL`> aristid: yes.
07:52:09 <mauke> > (1 / abs) (-0)
07:52:10 <lambdabot>   -Infinity
07:52:14 <mauke> I don't get it
07:52:20 <co_dh> ManateeL`: and I use a mac.
07:52:24 <mauke> > 1 (-0)
07:52:25 <ManateeL`> co_dh: Well, then you can't access internet free. 
07:52:26 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:52:26 <lambdabot>    `GHC.Num.Num a'
07:52:26 <lambdabot>      aris...
07:52:28 <mauke> > 1 (-0) :: Double
07:52:29 <lambdabot>   1.0
07:52:31 <Axman6> i think there's an odd instance for Num in lambdabot 
07:52:36 <aristid> ManateeL`: i guess in hong kong you could do without a proxy
07:52:52 <ManateeIrcClient> aristid: yes.
07:52:55 <co_dh> :t ( 1/ abs)
07:52:56 <lambdabot> forall a. (Fractional a) => a -> a
07:52:57 <dafis> mauke: what don't you get?
07:53:04 <mauke> dafis: why it's -Infinity and not Infinity
07:53:32 <dafis> @src abs
07:53:33 <lambdabot> Source not found.
07:53:40 <aristid> > 1 / abs (-0)
07:53:41 <lambdabot>   -Infinity
07:53:44 <aristid> oO
07:53:51 <dafis> mauke: abs x | x < 0 = negate x | otherwise = x
07:53:55 <aristid> mauke: good question
07:54:00 <dafis> > abs (-0.0) :: Double
07:54:01 <lambdabot>   -0.0
07:54:01 <aristid> > abs (-0)
07:54:02 <lambdabot>   0
07:54:13 <aristid> dafis: sounds like a bug in abs
07:54:18 <mauke> bug!
07:54:38 <co_dh> > 1 / 0 
07:54:39 <lambdabot>   Infinity
07:54:46 <dafis> > abs (-0.0) == (0 :: Double)
07:54:47 <lambdabot>   True
07:54:47 <co_dh> > 1/ (-0)
07:54:48 <lambdabot>   -Infinity
07:55:07 <aristid> in c++, fabs works correctly on -0.0
07:55:13 <dafis> > (-0) >= (0 :: Double)
07:55:14 <lambdabot>   True
07:55:28 <aristid> dafis: well it is ==
07:55:29 <dafis> aristid: but it's ultra hard to fix
07:55:35 <aristid> why?
07:55:47 <aristid> it only needs to use fabs
07:56:06 <dafis> aristid: because -0.0 == 0.0, so how do you find out whether to negate?
07:56:13 <mauke> dafis: how does show do it?
07:56:29 <Axman6> doesn't fabs just need to treat a number as an integer, and and it with 2^64-1?
07:56:40 <aristid> dafis: by looking at the bits!
07:56:40 <mauke> abs x | take 1 (show x) == "-" = -x | otherwise = x
07:56:54 <aristid> mauke: hahaha
07:57:15 <aristid> > signum (-0)
07:57:16 <lambdabot>   0
07:57:26 <mauke> > signum (-0.0)
07:57:27 <lambdabot>   0.0
07:57:33 <aristid> mauke: or by doing this:
07:57:50 <aristid> abs x = case signum x of 1 -> x; 0 -> 0; -1 -> -x
07:58:05 <aristid> wait i meant dafis
07:58:09 <aristid> or who do i mean?
07:59:06 <dafis> aristid: yes, that works, but it's slower, I suppose
07:59:57 <aristid> dafis: if you want speed, use the assembler instruction for that precise purpose
08:00:16 <aristid> is there a FFI for assembler? :D
08:00:30 <ManateeLazyCat> aristid: Why need that? ;p
08:00:39 <dafis> aristid: FFI to C, use inline assembly ;)
08:01:22 <mauke> why inline?
08:01:33 <ManateeLazyCat> Have any other hot channel like #haskell ? I can test my irc client.
08:01:35 <mauke> just FFI to C but write in asm
08:01:36 <dafis> mauke: for speed, of course
08:01:46 <aristid> ManateeLazyCat: why? just for fun.
08:01:48 <mauke> dafis: how is inline assembly faster than assembly?
08:01:53 <handonson> ManateeLazyCat: #ubuntu
08:02:10 <ManateeLazyCat> handonson: Damn #ubuntu stupid filter my irc bot.
08:02:20 <handonson> LOL
08:02:21 <dafis> mauke: I meant, asm code in your C code, often referred to as inline assembly
08:02:26 <hvr> ...is there an simple command that upgrades all my local ~/.cabal packages in order to fix "Warning: This package indirectly depends on multiple versions of the same
08:02:29 <hvr> package. This is highly likely to cause a compile failure."
08:02:32 <hvr> ?
08:02:32 <handonson> ManateeLazyCat: maybe #python then
08:02:32 <mauke> dafis: I know what inline assembly is
08:02:34 <ManateeLazyCat> handonson: Just because my irc bot named ManateeIrcClient.
08:02:39 <mauke> dafis: but why wrap it in C code?
08:02:44 <ManateeLazyCat> handonson: Cool, join #python 
08:02:59 <handonson> mauke: to use it via FFI?
08:03:00 <dafis> mauke: didn't see the ';)' ?
08:03:14 <mauke> handonson: that doesn't require C
08:03:26 <handonson> mauke: that's why ';)'
08:06:08 <ManateeLazyCat> Adjust finish : http://www.flickr.com/photos/48809572@N02/5001487318/lightbox/ maybe 'Black' background is better for irc client.
08:07:03 <dom96> ManateeLazyCat: make the colors customizable :P
08:07:17 <ManateeLazyCat> dom96: Yes, but not now.
08:07:34 <dom96> ManateeLazyCat: why the line numbers?
08:07:42 <ManateeLazyCat> dom96: Customised module need design systematically for my OS. :)
08:08:14 <ManateeLazyCat> dom96: Tell you how hot a channel, like #haskell. :)
08:08:20 <dom96> Also, if you could align the Nicks with the message, like xchat does, that would be awesome.
08:08:38 <ManateeLazyCat> dom96: No, i design for it.
08:08:55 <dom96> ManateeLazyCat: why not just write the number of messages in a channel in the status bar?
08:08:58 <ManateeLazyCat> dom96: If you align nick, if have *long* nick will waste screen space.
08:09:04 <dom96> Line numbers are a waste of space.
08:09:24 <ManateeLazyCat> dom96: It's customize option. :)
08:09:38 <Axman6> Xchat lets you say how far the alignment should be in from the left
08:09:45 <dom96> indeed
08:09:47 <Axman6> nicks longer than that overflow
08:10:31 <Axman6> also, any decent irc client is going to be run for months without being closed. line numbers are going to get more and more annoying as time goes on
08:10:31 <ManateeLazyCat> Axman6: Like my design, you easy to know which one talk which part.
08:10:53 <myAwfullyLongNic> so?
08:10:55 <ManateeLazyCat> Axman6: Because different nick has different align. :)
08:11:04 <Axman6> ManateeLazyCat: looks just like my irssi setup
08:11:07 <MamboJUmbo> hello folkz
08:11:21 <ManateeLazyCat> Axman6: Well, you can close line number if you don't like.
08:11:32 <ManateeLazyCat> Axman6: It's option. :)
08:11:35 <Axman6> good :)
08:12:56 <ManateeLazyCat> Well, my algorithm is not good enough, don't need calculate linuminance, should calculate contrast.
08:13:27 <ManateeLazyCat> Some color still not easy to read when background is white.
08:15:49 <ManateeLazyCat> Which notify program you use? 
08:16:07 <ManateeLazyCat> I want add notify popup window when someone call you in irc message. :)
08:16:13 <dankna> Growl on the Mac is a nice one
08:16:19 <dankna> off the Mac, I don't know
08:16:20 <ManateeLazyCat> dankna: LInux ?
08:16:25 <ski> (ManateeIrcClient : btw, *please* also make sure your client is usable, when the user prefers a black or dark background)
08:16:45 <ManateeLazyCat> ski: Yes.
08:16:50 <ManateeLazyCat> ski: I have add that option.
08:17:10 <ManateeLazyCat> ski: You can choose your own background, and nick color will adjust along with background's color.
08:17:21 <Axman6> Growl is the only notification system that gets it right
08:17:49 <ManateeLazyCat> Axman6: Growl can works on Linux ?
08:17:56 <Axman6> no
08:17:57 * ski hates applications which let you change e.g. one of background and text default color, directly, or inheriting from outer system, but refuses to change the other one .. making the color scheme more or less unreadable, unless you revert the color to a non-preferred one
08:18:07 <Axman6> nothing works on linux >_>
08:18:38 <Ke> !
08:19:03 <ManateeLazyCat> Axman6: I just focus on Linux now, and ignore Mac and Windows.
08:19:30 <dafis> ManateeLazyCat: That's the spirit!
08:19:54 <ski> ManateeIrcClient : thank you
08:20:10 <ManateeLazyCat> dafis: If user want play my program, okay, join Linux community! :)
08:20:19 <dafis> +1
08:20:31 <ManateeLazyCat> dafis: Maybe i will support Windows and Mac, but in principle, it's design for Linux.
08:20:58 <ski> (i hope you handle potential clashes between nick name colors, and background as well as selection (or any background marking) color)
08:21:23 <dafis> ManateeLazyCat: The important part is that it works on linux, if by chance it also works on Mac/Windows, nice ;)
08:21:38 <dankna> see, I would say just what Dafis said but with a different OS as the preferred one :D
08:21:40 <ManateeLazyCat> ski: Yes, i need improve nick color algorithm to avoid two nick's color too close. :)
08:21:49 <ski> *nod*
08:21:52 <dafis> dankna: BSD?
08:21:59 <dankna> lol no, but it's a BSD derivative
08:22:33 <ManateeLazyCat> Looks haskeller like irc client. :)
08:22:34 <Zao> Last I checked, OS X was certified UNIX.
08:22:36 <Zao> Thus not BSD.
08:22:42 <dankna> fair point
08:22:46 <ManateeLazyCat> Special written by Haskell. :)
08:23:01 <dankna> I actually advocate Jabber over IRC, but there's no good client for multi-user chat yet
08:23:13 <dankna> I have half of one written...  in a hybrid of Haskell and other stuff
08:23:31 <dankna> uses Haskell for the interesting bits and platform-specific language for the boring parts
08:23:50 <ManateeLazyCat> dankna: Because i haven't so much time write everything, now i just write irc client for play.
08:23:55 <dankna> understandable, of course
08:24:05 <ManateeLazyCat> dankna: If i have more time in the future, i will write XMPP client.
08:24:16 <dankna> cool cool :)
08:25:36 <ManateeLazyCat> I know why, light background not best color for application like irc client have so much color.
08:25:51 <ManateeLazyCat> Like my ERC use black background.
08:29:04 <ManateeLazyCat> Next step : add "multiple language discuss" module in irc client.
08:29:35 <ManateeLazyCat> Then we can write any language we speak, and translate by Google, then communication with English. :)
08:30:11 <dafis> ManateeLazyCat: have you actually tried google translate with two languages you know well?
08:30:50 <ManateeLazyCat> dafis: I know Google translate stupid sometimes, but it's useful if someone speak poor English. :)
08:30:58 <dafis> ManateeLazyCat: it does astonishingly well, but there are still a lot of mistranslations
08:31:27 <ManateeLazyCat> dafis: Yes, just help people can't speak English well.
08:32:11 <dafis> ManateeLazyCat: but in case of mistranslations, it'll screw up worse than ordinary bad english
08:32:46 <dafis> But of course, as an assistant for the cases where it works, it'd be cool
08:32:50 <aristid> i think everybody needs to learn english, if he wants to participate in global communications.
08:33:10 <ManateeLazyCat> aristid: Absolute.
08:33:16 <dafis> aristid: broken english is the latin of the 21st century
08:33:36 <aristid> dafis: but in the 21st century, more people than ever speak _decent_ english
08:34:43 <dafis> aristid: yes, but far more speak broken english, as long as it's understandable, correct grammar isn't so important for communication
08:35:03 <ManateeLazyCat> dafis: Like my bad English ? ;p
08:35:06 <hvr> dafis: like html vs strict xhtml? :)
08:35:09 <aristid> dafis: well, it is important, but better some understanding than none.
08:35:26 <dafis> ManateeLazyCat: it's not soo bad
08:35:41 <aristid> ManateeLazyCat: i sometimes have trouble understanding you, but it's probably much better than average
08:36:03 <ManateeLazyCat> aristid: Hehe .:)
08:36:04 <kaja> hello. How much memory do haskell programs tend to consume? Python programs drive me crazy because even simple ones require scores of megabytes
08:36:16 <kaja> compare haskell programs to, say, C
08:36:20 <dafis> kaja: that very much depends
08:36:24 <ManateeLazyCat> aristid: I can understanding u always. :)
08:36:47 <dafis> kaja: usually, C uses less memory, except if you can exploit Haskell's laziness
08:36:47 <kaja> dafis: i figured it would. if this eliminates the variables somewhat: i'm talking about ghc compiled haskell 
08:36:58 <aristid> ManateeLazyCat: thanks :)
08:37:18 <dafis> kaja: the algorithm is the biggest factor
08:37:25 <kaja> true
08:38:23 <kaja> in general i would say though that C programs (at least the ones that i run) tend to be about 10x lighter than python equivalent programs. very dodgy benchmarking but still
08:38:38 <ManateeLazyCat> aristid: I can write/understand English well, just can't explain complex idea accurately, sometimes.
08:38:47 <kaja> would haskell be closer to the C end or the python end there?
08:38:58 <dafis> kaja: you could look at the shootout for some pointers
08:39:04 <pikhq> kaja: It Depends™.
08:39:13 <aristid> ManateeLazyCat: yeah, that's where knowing the grammar well can help
08:39:34 <kaja> dafis: good idea
08:39:57 <pikhq> ManateeLazyCat: I suggest you read English extensively. :)
08:40:14 <ManateeLazyCat> pikhq: Yes,
08:40:21 <ManateeLazyCat> pikhq: Just haven't so much time.
08:40:30 <monochrom> No, I suggest formal logic for complex ideas.
08:40:31 <ManateeLazyCat> pikhq: I speed 99.999999% time on programming....
08:40:39 <pikhq> ManateeLazyCat: Aaaah.
08:40:51 <copumpkin> ManateeLazyCat: so lazy, you must spend 99.99999999999999999% of time on it
08:41:03 <copumpkin> I guess that's why you're ManateeLazyCat and not ManateeHardworkingCat
08:41:13 <kaja> dafis: isn't the shootout just process time and not ram consumption?
08:41:25 <copumpkin> :)
08:41:39 <monochrom> ManateeHardworkingCat is too long. Try ManateeStrictCat
08:41:39 <dafis> kaja: they also measure memory and you can compare by that
08:41:47 <copumpkin> ManateeLongCat
08:42:09 <ManateeLazyCat> copumpkin: Infact, ManateeLazyCat is not joke, I call my girl Mantee, and her call me LazyCat, in Chinese.
08:42:19 <TacticalLongcat> lol, this nick belongs to FunctorSalad
08:42:35 <copumpkin> ManateeLazyCat: ah nice :)
08:42:42 <ManateeLazyCat> So my nick name is *real*. :)
08:42:48 <kaja> well it seems that C beats haskell by a long way and haskell beats python by a long way also
08:43:04 <copumpkin> kaja: what do you consider a long way?
08:43:28 <ManateeLazyCat> infoe: Infact, i study most English from irc channel. :)
08:43:40 <kaja> copumpkin: i consider it like this: i have to squint to see the C bar in the graph, the haskell bar is about 2cm long and the python one is about 8 :P
08:43:44 <Axman6> C doesn't have a runtime, and i don't believe that haskell programs ever give ram back to the os
08:43:52 <Axman6> though, i think this was recently fixed
08:43:57 <copumpkin> hey, what's crt!
08:44:08 <kaja> copumpkin: cathode ray tube?
08:44:19 <copumpkin> c runtime! 
08:44:27 <monochrom> crt is chinese remainder theorem
08:44:31 <ManateeLazyCat> copumpkin: Funny. :)
08:44:36 <copumpkin> no, it is!
08:44:38 <Axman6> @google crt
08:44:38 <lambdabot> http://en.wikipedia.org/wiki/Cathode_ray_tube
08:44:39 <lambdabot> Title: Cathode ray tube - Wikipedia, the free encyclopedia
08:44:48 <dark> kaja, are you looking at benchmarks?
08:44:54 <kaja> dark: yeah
08:45:10 <copumpkin> pumpkin:~ pumpkin$ ls -ld /usr/lib/crt1.o
08:45:11 <copumpkin> -rw-r--r--  1 root  wheel  15768 Oct  2  2009 /usr/lib/crt1.o
08:45:23 <kaja> C runtime library, criterion-referenced test, charitable remainder trust, capillary refill time, corneal refractive therapy, cross river tram ...
08:45:35 <monochrom> but you could ask what is /usr/lib/crt1.o
08:45:52 <copumpkin> I can answer too
08:45:53 <copumpkin> http://snapplr.com/t4k4
08:46:00 <kaja> ciao guys. thanks.
08:46:09 <copumpkin> pretty solid runtime
08:46:22 <dark> "you can drop to C if you need to"
08:46:28 <dark> but he's gone
08:47:53 <kaja> oh wait, i forgot to ask. which learning material do you recommend? the wikibooks haskell textbook?
08:48:07 <dafis> @where lyah
08:48:08 <lambdabot> http://www.learnyouahaskell.com/
08:48:12 <dafis> @where rwh
08:48:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:48:53 <dafis> kaja: lyah for starting, rwh when you've gained a little ground plus of course the wikibook
08:49:14 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
08:49:14 <kaja> sweet
08:50:12 <next> If you have 'f x = foldl (g x) (k x)', then 'x' will update in foldl, correct? (I.e., it will not be a constant argument of 'g')?
08:50:40 <dafis> next: it will be constant in g
08:51:22 <dafis> @src foldl
08:51:23 <lambdabot> foldl f z []     = z
08:51:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:51:42 <next> Okay, so (f x = foldl (g x) (k x) where g = g' x') /will/ update, then.
08:51:46 * ddarius doesn't understand the logic behind next's question.
08:51:59 * dafis neither
08:52:15 <copumpkin> next: no
08:52:30 * monochrom has grown out of trying to understand humans
08:52:38 <kaja> do you people find you develop more quickly in python or ruby than in haskell?
08:52:48 <dafis> kaja: no
08:52:59 <kaja> hm, well, that's impressive, then!
08:53:02 <copumpkin> no, and ruby used to be my langauge of choice for everything
08:53:04 <copumpkin> now it feels clunky
08:53:06 <copumpkin> :(
08:53:10 <dafis> kaja: but then, I don't use ruby at all and Python only rarely
08:53:31 <kaja> hehe you sold me
08:53:44 <ManateeLazyCat> G'night all ! :)
08:53:46 <Axman6> you quite quickly begin thinking in haskell
08:53:57 <copumpkin> gnight ManateeLazyCat 
08:53:58 <dafis> 'night ManateeLazyCat 
08:54:04 <dark> next, there is no "update" (that is, mutable update) of any variable. if x is something, it will stay this something. foldl will instead return a new structure
08:54:15 <kaja> Axman6: so you reckon you became fluent in haskell more quickly than in other languages?
08:54:19 <Axman6> sitting in any lecture with some maths, and i always think about how to implement it in haskell
08:54:43 <Axman6> i put more effort into becomming fluent in haskell, because i enjoyed it so much
08:54:47 <Axman6> ruby pissed me off
08:55:05 <dafis> Axman6: what particularly?
08:55:11 <Axman6> i quite like C
08:55:14 <dafis> I found the syntax fugly
08:55:26 <kaja> ruby looks like it can do some pretty cool stuff with string manipulation
08:55:31 <dafis> Axman6: C is fine, with a few exceptions
08:55:32 <kaja> i don't really know anything about it though
08:55:44 <Axman6> i thought ruby had some pretty cool stuff in it, but it's dog slow
08:55:45 <ryo_hazuki> kaja, do you have an example of the cool stuff? maybe theres a equivalent in haskell
08:55:51 <next> Yes, I understand that about foldl. I was unclear, since in this example 'g' returns a value of type 'a' in foldl's (a -> b -> a), creating an 'update'. http://hpaste.org/30177/
08:55:56 <Axman6> and i don't think OOP works well for me
08:56:23 <kaja> ryo_hazuki: well if you go to ruby's page, there's a try ruby in 20 minutes interactive browser session
08:56:24 <Axman6> next: i don't think anyone u8nderstands what you're asking
08:56:26 <copumpkin> kaja: yeah, the inline regexes are convenient in it
08:56:44 <kaja> ryo_hazuki: that's a good start
08:56:51 <kaja> copumpkin: yeah that's an example
08:56:54 <Axman6> i thought stuff like 5.times do |x|  ... end was pretty cool
08:56:57 <dark> ryo_hazuki, string interpolation maybe?
08:57:07 <dafis> @where tryhaskell
08:57:08 <lambdabot> http://tryhaskell.org/
08:57:12 <dafis> kaja ^^
08:57:29 <kaja> awesome!
08:57:38 <next> I'm just a liberal arts major, but I could never understand a programming language until I found Haskell. Everything else looks like gibberish.
08:57:50 <dafis> kaja: but we have to admit, tryruby was first
08:58:02 <kaja> dafis: haha. it's a neat idea, though!
08:58:09 <kaja> i don't blame you for stealing it
08:58:40 <dafis> kaja: who stole? ruby still has it.
08:58:48 <ryo_hazuki> dark, i dont actually know whats so special about text = "Hello {#name}" ?!?
08:58:56 <kaol> Was there some idiom that allowed doing something like 1+2+3+4 by passing it [1,2,3,4] and (+)? Applicative or something?
08:59:23 <Saizan> > foldl' (+) 0 [1,2,3,4]
08:59:24 <lambdabot>   10
08:59:26 <dafis> > printf "Hello %s" "Mike" :: String
08:59:27 <lambdabot>   "Hello Mike"
08:59:31 <dark> ryo_hazuki, it's very convenient for some quick scripts, also some domains
08:59:54 <byorgey> http://www.cis.upenn.edu/~byorgey/haskell-alphabet/
08:59:55 <kaol> Doh, just plain fold. I've been languishing doing C, PHP and shell scripts too long.
08:59:56 <byorgey> enjoy =)
09:00:15 <mmmulani> > (\a -> do ln <- getLine ; let (x,y,t,lns) = map read (words ln) ; text <- mapM (\b -> getLine) [1..lns] ; return (x,y,t,unlines text))
09:00:16 <lambdabot>   <no location info>: parse error on input `<-'
09:00:21 <dark> ryo_hazuki, to be fair, haskell has type-safe printf, so maybe it isn't impossible to write something like this..
09:00:22 <copumpkin> byorgey: cute :)
09:00:26 <mmmulani> :/
09:00:28 <kaja> dafis: tryhaskell is crashing for me in both chromium and my usual vanilla webkit browser
09:00:40 <dafis> byorgey: nice
09:00:42 <dark> it crashed my chromium too
09:00:44 <kaja> dafis: when i type "5 + 7" in lesson1 it freezes
09:00:47 <dark> but i would blame chromium
09:00:55 <dark> crashed in exactly this place
09:01:05 <dark> but I followed the tutorial a time ago, at firefox I think
09:01:08 <kaja> oh well. i'll be content with the two other websites
09:01:19 <ryo_hazuki> dark, thats what i ment... i haven't seen any cool stuff in python or ruby where wasn't able to find/write a better or equivalent in haskell
09:01:23 <kaja> not gonna install firefox, that POS, just to run a little tutorial
09:01:24 <mmmulani> anyone know what's up with my do statement?
09:01:24 <dafis> kaja: iirc, it had some problems with chrom(e|ium), try FF?
09:01:30 <kaja> ^
09:01:45 <dark> sure
09:02:06 <mmmulani> kaja: what's wrong with FF?
09:02:15 <kaja> FF amazes me that it has such a loyal following in the FOSS / techie community despite being a beast
09:02:36 <dafis> mmmulani: without layout, you need explicit {} for let in do
09:02:55 <dark> i find firefox inconvenient right now, but i was a fanboy at time of 0.9
09:03:03 <kaja> bloated, silly interface that says "you're too stupid to customise so we're hiding everything and the only way to disable scroll bars is to write a javascript
09:03:09 <kaja> "
09:03:15 <mmmulani> dafis: like: do { .. ; .. ; let a = ... ; ... } ?
09:03:29 <dafis> mmmulani: it's parsed do { ln <- getLine; let {t (x,y,t,lns) = map read (words ln) ; text <- mapM (\b -> getLine) [1..lns] ; return (x,y,t,unlines text)) }}
09:03:40 <mmmulani> kaja: "you're too stupid"? the entire fx is customizable
09:03:46 <kaja> and did I mention bloated? why the hell does it use 100MB+ when i've only got 3 tabs open
09:03:55 <mmmulani> dafis: ohhhh
09:03:55 <dafis> mmmulani: do a; b; let { c = d; e = f }; g
09:03:59 <mmmulani> kaja: check about:memory
09:04:05 <mmmulani> perhaps you've never heard of undo close tab
09:04:14 <cads> hey, do you guys think it would be very hard to make a DSL for describing simple situations of agents acting various factors of free will and coercion?
09:04:17 <kaja> i know about it
09:04:42 <cads> I'd like to flesh out mcarthy's "free will even for robots" paper with some details for modeling other philosophical aspects
09:04:51 <jmcarthur> nice. i segfaulted gcc while building ghc head
09:05:03 <dark> ryo_hazuki, I once saw how for would be emulated in haskell, and it used the lambda construct \x -> .. for the free variable of the for block. without some sugar (I like ruby's), some constructs become too cumbersome..
09:05:18 <kaja> mmmulani: eh it doesn't matter what causes it. i'm content with jumanji now.
09:05:47 <dafis> jmcarthur: how?
09:05:50 <kaja> anyway, ciao
09:06:00 <jmcarthur> dafis: i dunno, it just happened by itself
09:06:03 <cads> hmm, this isn't really a haskell question so much as a question of what it's like to come up with a philosophical model :/
09:06:15 <jmcarthur> dafis: this after building it a few time immediately prior without the same result
09:06:18 <dafis> jmcarthur: what did it say as a goodbye message?
09:06:19 <dark> jmcarthur, http://gcc.gnu.org/bugs/ on how to isolate it, if you wanted to report
09:06:43 <jmcarthur> dark: i'll report if it happens again after i update and reboot
09:07:06 <jmcarthur> dafis: it just said gcc: Internal error: segmentation fault
09:07:20 <dafis> not very informative
09:07:26 <jmcarthur> segfaults rarely are
09:09:03 <dafis> jmcarthur: true
09:10:13 <dafis> jmcarthur: I've had a few internal gcc errors with 3.?, but it never died twice in a row
09:10:37 <jmcarthur> gcc is such a mess
09:10:47 <jmcarthur> to be fair, what optimizing compiler isn't a mess?
09:11:38 <aristid> is ghc a mess?
09:11:54 <Lemmih> Yes.
09:11:55 <monochrom> some versions of ghc are messes
09:12:36 <dafis> they're all messy in places, degree and extent vary
09:13:16 <PyroPeter> Is it ok to run "Setup copy" before "Setup (un)register --gen-script"?
09:13:20 <monochrom> once in a while the mess is tidied up
09:13:28 <PyroPeter> s/before/after/
09:13:36 <monochrom> I think yes
09:13:57 <PyroPeter> nice, thanks
09:19:55 <dark> :t const
09:19:56 <lambdabot> forall a b. a -> b -> a
09:20:23 <dark> o.o
09:20:24 <dark> @src const
09:20:24 <lambdabot> const x _ = x
09:20:47 <dark> ah
09:28:32 <trez> @src flip
09:28:32 <lambdabot> flip f x y = f y x
09:45:39 <trinithis> src flip -> flip = flip f
09:46:13 <dmwit> eh?
09:46:14 <ddarius> @free flip
09:46:15 <lambdabot> Expected variable or '.'
09:46:28 <trinithis> I meant flip f = flip f... should be defn
09:46:31 <dmwit> ?free (a -> b -> c) -> (b -> a -> c)
09:46:31 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
09:47:19 <dmwit> ?free (a -> b -> c) -> b -> a -> c
09:47:19 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
09:47:25 <dmwit> ?where lambdabot
09:47:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:47:56 <Saizan> ?free f :: (a -> b -> c) -> b -> a -> c
09:47:56 <lambdabot> (forall x. k . p x = q (g x) . h) => k . f p y = f q (h y) . g
09:48:35 <ddarius> @free reverse
09:48:36 <lambdabot> $map f . reverse = reverse . $map f
09:48:39 <ddarius> Hmm
09:49:06 * ddarius restarts to see if he broke his install.
09:53:04 <aristid> @free length
09:53:05 <lambdabot> length = length . $map f
09:53:16 <aristid> why $map and not map?
09:53:31 <aristid> :t fmap length . map
09:53:32 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> Int
09:53:53 <aristid> :t fmap length . fmap
09:53:54 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> Int
09:54:08 <aristid> :t fmap (fmap length) fmap
09:54:08 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> Int
09:55:28 <Leosirth> hi
09:56:14 <Leosirth> someone know a way to use auto-completing function in notepad++ ?
09:56:51 <dmwit> aristid: In case you ask for a free theorem about map, it doesn't want to have to deal with shadowing properly.
09:57:21 <aristid> @free map
09:57:22 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
09:57:35 <dmwit> For example, if you accidentally named reverse "map":
09:57:36 <kaol> So is this a case for Applicative? I have a function like foo :: a -> a -> a -> b and a list of three values of type a.
09:57:40 <dmwit> ?free map :: [a] -> [a]
09:57:40 <lambdabot> $map f . map = map . $map f
09:57:57 <aristid> ?free let map = reverse in map
09:57:57 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
09:58:19 <dmwit> kaol: Probably just a case for \[x,y,z] -> f x y z
09:58:25 <kaol> Probably yes.
09:58:26 <dmwit> kaol: no need for anything fancy
09:58:29 <kaol> Indeed.
09:59:15 <kaol> I'm still somewhat hazy about what Applicative is about and I'm looking for situations that could be expressed with it.
10:01:24 <Maxdamantus> @free id
10:01:25 <lambdabot> f . id = id . f
10:02:13 <Maxdamantus> @free curry
10:02:14 <lambdabot> h . k = p . $map_Pair f g => h . curry k x = curry p (f x) . g
10:02:27 <iron> hi. i bought  this book Haskell The Craft of Functional Programming Second Edition
10:02:45 <iron> now i tried the Pictures.hs example in Hugs but it does not work.
10:03:02 <iron> it sais: ERROR file:.\Pictures.hs:128 - Undefined variable "eqChar"
10:03:34 <iron> i guess eqChar is not declared or something, but as it is one of the first examples i do not know what to do
10:04:10 <iron> i got "the modified code" from http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
10:05:37 <iron> ah sorry. i guess i got the hellium package, whatever that means.
10:08:35 <iron> it works :)
10:11:52 <aristid> iron: complete with ugly book cover
10:12:01 <andrewsw> .
10:12:01 <lambdabot> andrewsw: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:48:49 <mmaruseacph2> .
10:49:04 <mmaruseacph2> wrong window, sorry
10:50:48 <aristid> .
10:52:09 <Entroacceptor> :
10:56:01 <geheimdienst> ...
11:00:38 <monochrom> ·
11:00:53 <chrisdone> is there a fast prolog implementation in haskell?
11:01:20 <monochrom> not sure LogicT counts as a prolog implementation
11:02:23 <chrisdone> I never noticed our nicks are the same length. we're length buddies!
11:02:54 <dark> not here..
11:03:00 <monochrom> I didn't notice either. I use a non-nerd font, i.e., not monospace
11:03:11 <dark> (with a sans serif font)
11:03:31 <byorgey> > zip "monochrom" "chrisdone"
11:03:32 <lambdabot>   [('m','c'),('o','h'),('n','r'),('o','i'),('c','s'),('h','d'),('r','o'),('o'...
11:03:41 <chrisdone> go back to hell variable width heathens
11:03:45 <monochrom> or should I say, I use a non-1970s-terminal font
11:04:16 <geheimdienst> > concat $ zipWith (++) "monochrom" "chrisdone"
11:04:17 <lambdabot>   Couldn't match expected type `[a]'
11:04:17 <lambdabot>         against inferred type `GHC.Types...
11:04:27 <geheimdienst>  > zipWith (++) "monochrom" "chrisdone"
11:04:38 <chrisdone> @slap geheimdienst 
11:04:38 <lambdabot> why on earth would I slap geheimdienst ?
11:04:42 <chrisdone> D:
11:04:51 <chrisdone> @vixen do it!
11:04:52 <lambdabot> nothing good is on TV
11:04:59 <geheimdienst> ... for confusing Chars with Strings of length 1
11:05:19 <monochrom> common perl mistake
11:05:22 <chrisdone> @faq Can Haskell forgive errors?
11:05:22 <lambdabot> The answer is: Yes! Haskell can do that.
11:05:25 <aristid> :t zipWith (++)
11:05:26 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
11:05:43 <aristid> > zipWith (++) "monochrom" "chrisdone"
11:05:44 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
11:05:45 <lambdabot>    arising from a use o...
11:05:47 <dark> @slap dark
11:05:47 <lambdabot> stop telling me what to do
11:05:54 <chrisdone> hahaha, dudes don't learn :p
11:05:56 <aristid> waaah
11:05:58 <chrisdone> aristid: beware the monoid
11:06:03 <monochrom> oh great, . is Functor, ++ is monoid
11:06:05 <aristid> chrisdone: yeah i missed that
11:06:11 <byorgey> > concat $ zipWith ((++) `on` pure) "monochrom" "chrisdone"
11:06:13 <lambdabot>   "mcohnroicshdroonme"
11:06:15 <chrisdone> I have (++) and (.) as Functor and Monoid too
11:06:25 <chrisdone> in my softawreses
11:06:34 <monochrom> is there also (++) `on` meth ?
11:06:35 <geheimdienst> > concat $ zipWith (\a b -> [a,b]) "monochrom" "chrisdone"
11:06:36 <lambdabot>   "mcohnroicshdroonme"
11:06:47 <chrisdone> unsafeCombineNicknames
11:06:49 <geheimdienst> mine is clearer :-P
11:06:55 <aristid> > zipWith (\a b -> [a,b]) "monochrom" "chrisdone"
11:06:56 <lambdabot>   ["mc","oh","nr","oi","cs","hd","ro","on","me"]
11:07:02 <byorgey> geheimdienst: I agree, but I wasn't trying to be clear ;)
11:07:05 <aristid> > transpose $ zipWith (\a b -> [a,b]) "monochrom" "chrisdone"
11:07:06 <lambdabot>   ["monochrom","chrisdone"]
11:07:10 <aristid> \o/
11:07:26 <chrisdone> who's experiencing semantic satiation with my name now?
11:07:28 * chrisdone raises hand
11:07:28 <aristid> > transpose ["monochrom", "chrisdone"]
11:07:29 <lambdabot>   ["mc","oh","nr","oi","cs","hd","ro","on","me"]
11:07:40 <aristid> > concat $ transpose ["monochrom", "chrisdone"]
11:07:41 <lambdabot>   "mcohnroicshdroonme"
11:07:47 <aristid> geheimdienst: mine is clearest :P
11:08:02 <monochrom> there is some kind of chromosome zipping here...
11:08:05 <chrisdone> mc oh nr oi cs hd ro on me sounds sorded
11:08:05 <aristid> i wish there were list sections
11:08:13 <aristid> :t [,]
11:08:14 <lambdabot> parse error on input `,'
11:08:24 <aristid> like [,] = \a b -> [a,b]
11:09:47 <chrisdone> that'd be nice
11:10:43 <aristid> :t let f a b = [a,b] in (liftA2 (,) (concat . transpose . f) (concat . zipWith f)) "monochrom" "chrisdone"
11:10:44 <lambdabot>     Couldn't match expected type `t1 -> t'
11:10:45 <lambdabot>            against inferred type `(a, b)'
11:10:45 <lambdabot>     In the first argument of `liftA2', namely `(,)'
11:10:46 <chrisdone> also record sections
11:10:46 <chrisdone> s {x=,y=}
11:11:02 <chrisdone> sections for everybody!
11:11:06 * chrisdone throws
11:12:09 <monochrom> exterminate all humans for everybody! \∩/
11:12:24 <chrisdone> ∩_∩
11:12:38 * hackagebot persistent 0.2.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.2 (MichaelSnoyman)
11:12:54 <chrisdone> excellent. now persistence is sorted we just need a prolog layer ontop
11:14:41 * monochrom trolls hackage, uploads "object-oriented persistence enterprise semantic applicative framework"
11:14:45 <McManiaC> http://hackage.haskell.org/packages/archive/happstack-auth/0.2/logs/failure/ghc-6.12 how can I get this to build? Crypto 4.* should be on hackage
11:14:51 <McManiaC> http://hackage.haskell.org/package/Crypto-4.2.1
11:15:15 <McManiaC> it definitly builds on my system :S
11:15:40 <aristid> > let (.:) = (.).(.); infixr 9 .:; f a b = [a,b]; v1 = concat .: transpose .: f; v2 = concat .: zipWith f; a v = v "monochrom" "chrisdone" in (a v1, a v2)
11:15:41 <lambdabot>   ("mcohnroicshdroonme","mcohnroicshdroonme")
11:16:22 <chrisdone> :t flip . any
11:16:23 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
11:16:24 <lambdabot>     Probable cause: `any' is applied to too many arguments
11:16:24 <lambdabot>     In the second argument of `(.)', namely `any'
11:16:27 <chrisdone> :t flip any
11:16:28 <lambdabot> forall a. [a] -> (a -> Bool) -> Bool
11:16:34 <chrisdone> @hoogle [a] -> (a -> Bool) -> Bool
11:16:35 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
11:16:35 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
11:16:35 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
11:18:17 <roconnor> ``Z is for Zygohistomorphic prepromorphism, which is a recursion scheme used when you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor.
11:18:21 <roconnor> best ending ever!
11:18:40 <monochrom> fun
11:18:57 <chrisdone> what does 'zygo' derive from?
11:19:27 <roconnor> @wn zygo
11:19:29 <lambdabot> No match for "zygo".
11:20:19 <roconnor> http://www.thefreedictionary.com/zygomorphism
11:21:00 <chrisdone> maybe someone made up 'zygo' because it sounds cool
11:21:07 <chrisdone> I will use it for the name of a project
11:21:08 <monochrom> \∩/ is a zygomorphism, it seems
11:21:17 <roconnor> Zygo implements semi-mutual recursion like a zygomorphism.
11:21:27 <chrisdone> Zygo comes
11:21:34 <monochrom> zygoplasm
11:22:00 <roconnor> http://www.yourdictionary.com/zygo-prefix
11:22:16 <chrisdone> oh nice
11:22:21 <roconnor> yoke or yoked; pair or paired: zygodactyl
11:22:33 <chrisdone> greek
11:22:38 <roconnor> Origin: New Latin, from Greek zugo-, from zugon, yoke; see  yeug- in Indo-European roots. 
11:23:06 <Adamant> ain't that some shit!
11:23:23 <chrisdone> I always forget about the `elem' function
11:23:50 <chrisdone> I write flip any xs . (==) and then get mad
11:24:47 * geheimdienst hands chrisdone a laminated card saying "elem" in nice cursive lettering
11:24:48 <monochrom> mad scientists write the best code
11:25:09 <chrisdone> I can't believe monochrom perfers geheimdienst's card to mine
11:25:10 <p_l> monochrom: I recommend you try reading through disassmbled snap4
11:25:35 <chrisdone> geheimdienst: oh my god, it even has a watermark
11:27:19 <monochrom> 𝔢𝔩𝔢𝔪
11:27:28 * chrisdone golf claps
11:28:08 * djahandarie yawns
11:28:24 <djahandarie> Someone should find a use for a Zygohistoprepromorphism
11:28:53 <aristid> does anybody use anything from category-extras?
11:29:32 <djahandarie> reactive does
11:29:34 <flippo> NoSAD, hey, what's with the join spam?
11:29:34 <rendagott> djahandarie: just include it in your facebook status... it'll promptly confuse everyone of your friends
11:30:14 <djahandarie> Join spam? Where
11:30:22 <djahandarie> rendagott, I don't have a facebook
11:30:29 <flippo> djahandarie, I got a PM of gibberish from NoSAD as soon as I joined.
11:30:33 <rendagott> haha, oh well, i tried
11:30:37 <djahandarie> Agh
11:31:07 * djahandarie pokes monochrom roconnor 
11:32:42 <djahandarie> Who both apparently managed to go idle
11:32:55 <monochrom> what join spam?
11:33:12 <monochrom> Can I have return spam and bind spam too? ap spam?
11:33:13 <flippo> monochrom, some gibberish in a non-utf8 encoding
11:33:30 <djahandarie> Hm, I didn't get it. Random maybe?
11:33:41 <flippo> He's also in #bash.  Might have been triggered from there.
11:33:42 --- mode: ChanServ set +o monochrom
11:34:03 --- mode: monochrom set +b *!*@188.247.74.24
11:34:03 --- kick: NoSAD was kicked by monochrom (NoSAD)
11:34:13 --- mode: monochrom set -o monochrom
11:37:10 <chrisdone> @let swapBy f as bs = (swap as bs,swap bs as) where swap xs ys = join $ zipWith (\i x -> if f x then (take 1 . drop i . cycle $ filter f ys) else [x]) [0..] xs
11:37:11 <lambdabot>  Defined.
11:37:15 <chrisdone> > swapBy (`elem` "aeiou") "monochrom" "chrisdone"
11:37:16 <lambdabot>   ("monichrom","chrosdono")
11:38:35 <chrisdone> > swapBy (`elem` "aeiou") "djahandarie" "geheimdienst"
11:38:36 <lambdabot>   ("djihendiree","gahiemdainst")
11:38:55 <chrisdone> homor sempsens
11:39:03 <mauke> chris-dono
11:39:40 <geheimdienst> homo sempsens
11:39:56 <chrisdone> > swapBy (not.(`elem` "aeiou")) "monochrom" "chrisdone"
11:39:57 <lambdabot>   ("corodncor","mncirmone")
11:40:27 <aristid> :t notElem
11:40:29 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:40:33 <chrisdone> <_<
11:40:41 <aristid> :>
11:43:36 <chrisdone> > length *** length $ ("fromMaybe x","maybe x id")
11:43:37 <lambdabot>   (11,10)
11:44:14 <chrisdone> \∩_∩/
11:46:55 <aristid> :t join (***) length
11:46:56 <lambdabot> forall a. ([a], [a]) -> (Int, Int)
11:47:11 <aristid> chrisdone: so you don't have to type length twice! :D
11:47:38 <chrisdone> > length *** length $ ("join (***) length","length *** length")
11:47:39 <lambdabot>   (17,17)
11:47:42 <mauke> :t length *** length
11:47:43 <lambdabot> forall a a1. ([a], [a1]) -> (Int, Int)
11:47:45 <mauke> spot the difference
11:47:47 <Taejo> I have on occasion found it useful to define both = join (***)
11:47:55 <aristid> mauke: meh, not a problem in chrisdone's case
11:48:09 <aristid> Taejo: i can imagine that
11:48:28 <aristid> i love how everybody abuses Control.Arrow for tuple manipulation
11:49:15 <geheimdienst> how can it be abuse if it works and and is succinct?
11:49:15 <Martty> Taejo: 님. 한국사람이에요?
11:49:20 <dark> :t join (***)
11:49:21 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:49:29 <aristid> geheimdienst: duh.
11:49:39 <geheimdienst> plus, nobody can figure out what to do with Control.Arrow except tuple manipulation
11:49:41 <geheimdienst> :-P
11:49:51 <aristid> heh.
11:49:59 <dark> :t join (***)
11:50:00 <chrisdone> well Hakyll uses it
11:50:00 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:50:03 <dark> ops
11:50:28 <Taejo> Martty: 아니오! 남아프리카사람이에요.
11:50:44 <dark> Taejo, @.@
11:50:47 <aristid> Taejo: funny looking characters
11:50:52 <Taejo> Korean
11:50:55 <Raynes> chrisdone: Add Clojure highlighting to hpaste.org, or we are no longer friends. :(
11:50:59 <dark> really? o.o
11:51:00 <Martty> Taejo: 한국말 할줄아는데요?
11:51:15 <aristid> what does it mean?
11:51:17 <chrisdone> > swapBy isUpper "님. 한국사람이에요" "아니오! 남아프리카사람이에요."
11:51:18 <lambdabot>   ("\45784. \54620\44397\49324\46988\51060\50640\50836","\50500\45768\50724! ...
11:51:25 <aristid> Martty: could you please speak english?
11:51:29 <Martty> oh ok
11:51:33 <dankna> @src swapBy
11:51:33 <lambdabot> Source not found. My brain just exploded
11:51:34 <Martty> i just asked him if he is korean
11:51:39 <Martty> and he said he is south african
11:51:45 <Martty> then i asked him if he knows korean
11:51:47 <mauke> ach, englisch ist überbewertet
11:51:58 <geheimdienst> überschätzt, mann
11:52:01 <Martty> Taejo looks like a korean nick :)
11:52:02 <Taejo> Martty: very little. I learned a bit from friends
11:52:03 <aristid> mauke: wir sollten die sprache der dichter und denker nutzen.
11:52:07 <dark> it looks like google could understand o.o
11:52:11 <dark> ._.
11:52:16 <chrisdone> german is just english with more accents and consonants
11:52:22 <Martty> angry english
11:52:25 <geheimdienst> sprache der dichter und denker, sie wären welche
11:52:27 <mauke> deutsch hat keine akzente
11:52:32 <Martty> with something stuck on your throat preferably
11:52:35 <aristid> chrisdone: and a different grammar.
11:53:06 <dark> and a different lexicon
11:53:42 <Taejo> btw, Martty, my nick is supposed to be 대조, not 태조
11:53:43 <dark> in fact, portuguese is just english with more accents, and a different grammar, and a different lexicon.. or spanish, or..
11:53:58 <aristid> geheimdienst: der begriff "dichter und denker" kommt wohl daher, dass es in deutschland enorm viele billige bücher gab, und daher eine sehr breite leserschicht, und auch viele schreiberlinge.
11:54:02 <dark> also different phonemes, and..
11:54:02 <Martty> DaeJo
11:54:26 <chrisdone> but the same vocab?
11:54:28 <mauke> Gutenberg, yo
11:54:33 <aristid> dark: it's the same, but everything different.
11:54:49 <Taejo> Martty: yeah. I used a dictionary with McCune-Reischauer transliteration and didn't realise my mistake until the nick was well-established
11:55:25 <Martty> any romanization sucks anyways :<
11:55:44 <Martty> 한글로 영어하는거 똑같아
11:56:22 <Taejo> 예스
11:56:45 * Taejo switches back to an alphabet more #haskellers can read
11:57:10 <chrisdone> needs more aip^hi:ei
11:57:16 <mauke> Γρεεκ
11:57:58 <chrisdone> Γo_oΓ he's hiding over there
11:58:20 <Adamant> you so crazy
11:59:12 <chrisdone> I was thinking of learning the IPA but does anyone else know it for it to be worth learning?
11:59:27 <chrisdone> I wonder if there are web sites which read out IPA for you
11:59:39 <Taejo> well it's not all that useful as a medium, but it's good for description
11:59:43 <Adamant> chrisdone: it's worth it if you learn a lot of other languages
11:59:46 <Adamant> right
11:59:55 <geheimdienst> you mean, learn to write it?
12:00:02 <dark> chrisdone, wikipedia uses it to mark pronounce of foreign names
12:00:17 <geheimdienst> not sure if that's worth it. reading however is worth it imho
12:00:17 <chrisdone> to write it yeah
12:00:29 <chrisdone> reading it is probably pointless if you can get a program to do it
12:00:30 <Taejo> needs more aip^hi:ei -- /lɑɪk ðɪs/?
12:00:44 <Taejo> it's really not hard to read
12:00:45 <chrisdone> I was trying to transliterate IPA
12:00:54 <Taejo> I know
12:00:56 <geheimdienst> hm?
12:01:05 <chrisdone> so, no
12:03:05 * geheimdienst thinks it's useful to know since pronunciation is often given in IPA (http://dictionary.com ...). i don't know why anybody other than linguists would want to learn writing it ...
12:03:22 <dark> the problem of phonetic representation is that some phonetic variations are meaningful on some languages but not on others
12:03:25 <chrisdone> I can only find voice charts. there must be *one* program where I can just paste some IPA in and hear the word
12:04:18 <Taejo> chrisdone: the problem is, like dark says, that one usually only writes the meaningful variations, so different languages are written slightly differently
12:04:20 <geheimdienst> chrisdone: speech synthesis is harder than you think :-)
12:04:29 <dankna> IPA doesn't give you prosody
12:04:32 <dark> IPA is supposed to reflect that (you can make many phonetic transcribing from the same word to IPA, with varying degrees of specificity)
12:04:34 <Taejo> for example, aspiration is often omitted in english
12:04:38 <dankna> which is like which syllable is emphasized and how fast it's said
12:04:50 <dankna> there is a notation for prosodic annotation
12:05:06 <dankna> and I personally think there would be a market for prosodically-annotated-pronunciation-to-speech
12:05:11 <dark> i think there are some extensions to IPA to account for meaningful variations not covered by it
12:05:11 <dankna> but I'm not aware of any software that does it
12:05:35 <Taejo> dark: I mean that, to make speech synthesis "easy" (and uniform over all languages), you need to be maximally specific
12:05:44 <Taejo> and it's rare to find maximally specific IPA
12:05:45 <dark> I think the ' symbol is used to mark syllabic emphasis on IPA
12:05:50 <geheimdienst> you can't take a .wav of somebody saying "a" and a wav of "n" and one of "d" and play them one after the other. you won't get speech that way
12:05:54 <Adamant> yeah, I had an idea for language to IPA to speech a while back
12:05:59 <ymasory_> so there's no way to tell just by looking at a function name whether it associates left or right, or whether it can be used infix with backticks, right?
12:06:12 <Adamant> but clearly I didn't look into it too deeply
12:06:19 <mauke> ymasory_: all functions can be used infix with backticks
12:06:26 <chrisdone> geheimdienst: will you get "speech" by reading it?
12:06:32 <ymasory_> mauke: but some can be used without backticks
12:06:39 <mauke> ymasory_: only operators
12:06:41 <geheimdienst> how do you mean?
12:06:48 <ymasory_> how is operator defined in Haskell?
12:07:00 <mauke> its name consists of symbols, not letters
12:07:02 <dankna> nonalphabetic symbol names, I believe
12:07:10 <ymasory_> ah, same as Haskell
12:07:13 <ymasory_> *Scala
12:07:14 <dark> how one defines operator precedence on haskell?
12:07:28 <mauke> dark: with infix declarations
12:08:01 <chrisdone> geheimdienst: you said you "won't get speech" by playing a sound for each phoneme. do you "get speech" by writing out phonemes?
12:08:03 <ymasory_> thanks mauke
12:08:04 <dark> http://www.haskell.org/haskellwiki/Keywords#infix.2C_infixl.2C_infixr ?
12:09:41 <dark> so, it looks like you use that to define left or right association to infix operators, ymasory
12:11:09 <chrisdone> I don't see the problem with voiced IPA over written IPA. the only difference I see is that I can just hear the first, whereas the second I have to learn the meanings of the symbols. what's the problem?
12:13:45 <dark> chrisdone, I can't make out an example (because I understand little of english phonetics) but sometimes you have a subtle difference of sound determining meaning on some situation, and this same difference being irrelevant on another situation
12:14:10 <dark> chrisdone, this is confusing when the language you are trying to learn is too different from yours
12:14:34 <chrisdone> oh nice I found one
12:14:35 <dark> IPA is supposed to help by stating what is relevant (but it isn't perfect)
12:14:45 <chrisdone> http://www2.research.att.com/~ttsweb/tts/demo.php
12:14:45 <chrisdone> put in: <phoneme alphabet="ipa" ph="kæt"> </phoneme>
12:15:10 <geheimdienst> chrisdone, i think a table like this http://dictionary.reference.com/help/luna/IPA_pron_key.html is part of any language course. it shouldn't be too hard to find a "learn french/german/elbonian" dvd that has a table with little sound files next to the example words ...
12:15:17 <chrisdone> dark: what's that got to do with voiced-vs-written?
12:15:56 <chrisdone> geheimdienst: I already said above I can find tables. who wants to click each letter to hear the sound? the one I linked lets you paste arbitrary IPA
12:16:24 <dark> chrisdone, the same IPA can have multiple pronunciations, and the same pronunciation can be encoded in many ways with IPA (one simpler, other more specific, etc)
12:16:44 <geheimdienst> i can see how that makes sense for vowels, but not so much for consonants
12:17:43 <dark> as Taejo said, you need a very specific IPA to fully automate the pronunciation (or else you have to specify the language, or sometimes regional variant o.o I could tell examples in portuguese)
12:17:48 <chrisdone> dark: the former point could be a problem, but the latter isn't
12:18:14 <chrisdone> yes, the link above specifies accent and region
12:19:16 <tolkad> How do you do function composition at the type level for the purpose of a class instance?
12:19:21 <chrisdone> it seems better than reading some symbols and imagining
12:19:21 <HNSZ> Hello, is "Haskell the craft of functional programming" a good book?
12:21:17 <chrisdone> dark: the specificness of the IPA is irrelevant to it being voiced. hearing some IPA and reading it gives me the same information. if you make your IPA more specific then the voiced output will be more accurate. buh, so what?
12:21:38 <tolkad> anyone? I have heard you can have "type functions" but I can't figure out how to do type function composition
12:21:51 <BONUS> well
12:21:52 <tolkad> like the "." operator
12:21:53 <chrisdone> what's a type function?
12:21:55 <tolkad> on the type level
12:22:06 <dmwit> newtype O f g a = O { unO :: f (g a) }
12:22:07 <tolkad> data TypeFunction x = TypeFunction x
12:22:17 <BONUS> what dmwit said
12:22:51 <dmwit> [] `O` Tree -- a type function forming lists of trees
12:23:37 <dmwit> This is probably in a module somewhere, and you should import that rather than rewriting it yourself.
12:24:34 <chrisdone> what's the difference between a type function and a type constructor?
12:24:38 <aristid> type O f g a = f (g a)
12:24:46 <aristid> any reason why this can't work?
12:25:03 <chrisdone> aristid: type aliases can't be partially applied without LiberalTypeSynonyms
12:25:27 <ddarius> What should f and g be in Maybe [[a]] ?
12:26:18 <aristid> ddarius: a type function need not be bijective, or am i missing something?
12:26:42 <chrisdone> dmwit: BONUS: what's the difference between a type function and a type constructor?
12:27:20 <ddarius> aristid: Well, type O f g a = f (g a) will work as long as you always fully apply it.
12:27:44 <tolkad> I would do «type Composition f1 f2 x = f1 (f2 x)»
12:27:54 <BONUS> chrisdone: i'd say that a type constructor *is* a type function?
12:27:58 <BONUS> :k Maybe
12:27:59 <lambdabot> * -> *
12:28:03 <tolkad> but you can't write class instances for type synonymns
12:28:48 <chrisdone> BONUS: oh ok. hadn't heard it referred to as 'type function'
12:29:16 <chrisdone> tolkad: even with LiberalTypeSynonyms?
12:29:28 <tolkad> chrisdone: what's that?
12:29:29 <chrisdone> wait
12:29:32 <chrisdone> yeah you can
12:29:39 <chrisdone> with FlexibleInstances, right?
12:29:44 <dmwit> ddarius: (Maybe `O` []) and [] or Maybe and ([] `O` [])?
12:29:48 <chrisdone> @google FlexibleInstances type synonym
12:29:49 <lambdabot> No Result Found.
12:29:54 <conal> aristid: you can define type composition as an alias in that way. you can't give Functor and Applicative instances for general composition unless you switch to a newtype or data.
12:29:59 <tolkad> @google google
12:29:59 <lambdabot> http://www.google.com/
12:30:00 <lambdabot> Title: Google
12:30:08 <tolkad> @google google test
12:30:09 <lambdabot> http://code.google.com/p/googletest/
12:30:09 <lambdabot> Title: googletest - Project Hosting on Google Code
12:30:17 <tolkad> hmm doesn't appear to be broken
12:31:16 <conal> aristid: or rather, we can but we get lots of overlap with competing instances.
12:31:42 <conal> just a mechanical issue.
12:31:46 <chrisdone> tolkad: LiberalTypeSynonyms lets you partially applied a type synonym among other bits http://hackage.haskell.org/trac/haskell-prime/wiki/LiberalTypeSynonyms
12:32:07 <mgsloan> Are there any haskell static analysis systems which have sets of semantics preserving transformations?
12:32:34 <chrisdone> BONUS: how's the book coming along, sailor?
12:33:04 <BONUS> chrisdone: all's goin as planned
12:33:18 <BONUS> should be on the shelves end of 2010/beginning of 2011
12:33:19 <chrisdone> excellent.jpg
12:33:23 <BONUS> B)
12:33:28 <chrisdone> yaay!
12:33:56 <aristid> conal: i suppose it depends on what you want to want to do with the type
12:33:59 <chrisdone> I'll buy it and give it to people at work
12:34:03 <dmwit> mgsloan: Well, there's the Haskell refactorer that was on haskit the other day.
12:34:05 <conal> aristid: yeah.
12:34:36 <mgsloan> dmwit: HaRe?
12:35:06 <dmwit> yes
12:35:16 <mauke> I don't know what you're talking about but Catch analyzes stuff
12:35:16 <conal> instance selection in GHC-Haskell is tauntingly close to higher-order logic programming (as in lambda-prolog).
12:35:39 <vanadium> BONUS: Oh man, christmas release?
12:36:24 <mgsloan> Something that would almost be good enough would be applying RULES pragmas to your representation of haskell
12:37:38 <dmwit> heh
12:37:54 <dmwit> "U is for (), the one-value type. ('Actually, two!' the curmudgeons will gripe.)"
12:39:07 <BONUS> vanadium: yeah could be!
12:39:26 <BONUS> i dont know the exact time though, im just the author
12:39:29 <hvr> BONUS: ...what's the book title btw?
12:39:39 <BONUS> hvr: learn you a haskell
12:39:43 <hvr> ah
12:39:57 <hvr> :)
12:40:03 <wavewave> hi, is there any way to print out a type of a certain symbol during the compile time?
12:41:02 <dmwit> wavewave: There's :t in ghci.
12:41:11 <dmwit> And there are definitely other tools if you want to automate it.
12:41:14 <lispy> wavewave: -Wall
12:41:30 <wavewave> dmwit: I know it, but it is hard for a big program..
12:41:45 <lispy> use a bigger ghci ;)
12:42:49 <lispy> dmwit: 2 because of _|_?
12:42:51 <wavewave> I just want to know the type of my concerned variable without showing all the other types
12:43:04 <dmwit> lispy: indeed
12:43:50 <wavewave> I guessed that there is some pragma to tell the compiler to show a warning message with the type 
12:44:40 <tolkad> chrisdone: LiberalTypeSynonyms does NOT allow you to partially apply type synonym
12:44:43 <tolkad> s
12:45:23 <tolkad> chrisdone: it only allows you to do it temporarily, the final type still has to fully apply all synonyms
12:46:15 <tolkad> it actually seems kind of useless
12:46:40 <Taejo> wavewave: you could define whattypeisthis = <whatever>, and compile with -fwarn-missing-signatures -- that will give you a warning which mentions the type of whatever
12:47:21 <dmwit> The GHC API will also let you query the types of bits of a source file.
12:47:23 <dmwit> ...I think.
12:48:10 <wavewave> Taejo: how about a symbol inside a definition of a function?
12:48:41 <Taejo> wavewave: yeah, that would work for that -- what can I say, it's a hack
12:50:31 <wavewave> Taejo: as I understand, that warning works only for top-level definition. 
12:51:15 <Taejo> right, I meant "wouldn't", sorry
12:51:15 <wavewave> Taejo: I would like to know a signature of a variable buried in the detail of a function. 
12:51:49 <wavewave> Taejo: any suggestion for this? only ghci?
12:52:30 <wavewave> ghci also has the same problem because I cannot refer to the variable which is not top-level. 
12:53:05 <monochrom> perhaps the eclipse plugin for haskell can do it. it uses the ghc api
12:53:57 <wavewave> monochrom: That's too big solution to me, though... I do not want to change my whole development environment...
12:55:34 <wavewave> how do you guys usually do? 
12:55:48 <monochrom> I usually don't need help with types.
12:56:22 <wavewave> especially this is needed for me to understand other people's code 
12:56:53 <wavewave> it compiles well, but I could not understand what the heck this type is...
13:05:27 <rothwell> lo. i'm wondering how i might cleanly express the following code: http://paste.lisp.org/display/114654
13:05:52 <rothwell> hopefully the meaning is clear... updates are applied to some state
13:06:15 <dmwit> Your types look a lot like the State monad.
13:06:20 <rothwell> they do, yeah...
13:06:51 <dmwit> I recommend making first-class modifiers for each field in your X data structure.
13:07:04 <dmwit> Then, for example, x_edit_name becomes something like.
13:08:02 <dmwit> x_edit_name [] = return Result_Name_Too_Short; x_edit_name name | length name < 32 = modify (set_name name) >> return Result_OK; x_edit_name _ = return Result_Name_Too_Long
13:08:20 <dmwit> ...which looks pretty clean to me
13:08:42 <rothwell> thanks. let me think on that one for a bit...
13:09:49 <dmwit> Let's see...
13:10:42 <aristid> :t modify
13:10:43 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
13:11:26 <dmwit> ?src Error
13:11:26 <lambdabot> class Error a where
13:11:26 <lambdabot>     noMsg  :: a
13:11:27 <lambdabot>     strMsg :: String -> a
13:11:30 <wavewave> Hmm, I found the easiest solution.. make a Dummy type and match Dummy type with the variable whose type I would like to know, then see the error message.. 
13:12:21 <aristid> :t guard
13:12:22 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:13:16 <illissius_> wavewave: or you could just use some existing type, like Int
13:15:03 <aristid> :t let guardOr t z = guard t `mplus` z in guardOr
13:15:04 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m () -> m ()
13:15:48 <aristid> :t let guardOr s t f = guard s >> t `mplus` f in guardOr
13:15:49 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b -> m b
13:16:13 <dafis> > let guardOr t z = guard t `mplus` z in guardOr False [(),(),()]
13:16:14 <lambdabot>   [(),(),()]
13:16:22 <dafis> > let guardOr t z = guard t `mplus` z in guardOr True [(),(),()]
13:16:23 <lambdabot>   [(),(),(),()]
13:16:32 <dafis> aristid: intended?
13:17:00 <aristid> dafis: no, that's why i wrote the second version
13:17:12 <aristid> well
13:17:17 <dafis> :t let guardOr s t f = (guard s >> t) `mplus` f in guardOr
13:17:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> m a -> m a -> m a
13:17:32 <dafis> aristid: I think you wanted that
13:17:50 <aristid> dafis: the type is the same, what is the difference?
13:17:59 <dafis> let guardOr s t f = guard s >> t `mplus` f in guardOr True [1] [2]
13:18:03 <dafis> > let guardOr s t f = guard s >> t `mplus` f in guardOr True [1] [2]
13:18:04 <lambdabot>   [1,2]
13:18:13 <dafis> > let guardOr s t f = (guard s >> t) `mplus` f in guardOr True [1] [2]
13:18:14 <lambdabot>   [1,2]
13:18:33 <aristid> >  let guardOr s t f = (guard s >> t) `mplus` f in guardOr False [1] [2]
13:18:34 <lambdabot>   [2]
13:18:42 <dafis> aristid: forgot how mplus worked :(
13:18:42 <aristid> > let guardOr s t f = guard s >> t `mplus` f in guardOr False [1] [2]
13:18:43 <lambdabot>   []
13:18:54 <aristid> dafis: you're right, the parens are necessary
13:19:13 <dafis> > let guardOr s t f = (guard s >> t) `mplus` f in guardOr False [1] [2]
13:19:14 <lambdabot>   [2]
13:19:46 <aristid> @src guard
13:19:46 <lambdabot> guard True  =  return ()
13:19:47 <lambdabot> guard False =  mzero
13:20:07 <aristid> :t if'
13:20:09 <lambdabot> Not in scope: `if''
13:20:29 <dafis> aristid: but is it intended that guardOr True a b gives both, a and b (if mplus is such)
13:21:12 <aristid> :t let guardOr True = const; guardOr False = flip const in guardOr
13:21:13 <lambdabot> forall b. Bool -> b -> b -> b
13:21:31 <aristid> dafis: it's not a problem in what i had in mind
13:21:46 <dafis> good
13:21:49 <aristid> dafis: but i wonder if the MonadPlus requirement is not unnecessary
13:22:14 <aristid> > let guardOr True = const; guardOr False = flip const in guardOr True [1] [2]
13:22:15 <dafis> aristid: without it, you can only if-then-else
13:22:15 <lambdabot>   [1]
13:22:40 <aristid> dafis: yes, which is, in a travesty of haskell 98, not a function
13:22:42 <dafis> aristid: that last one is if b then a else b
13:22:50 <aristid> i know:)
13:23:18 <dmwit> rothwell: still around?
13:23:21 <dmwit> rothwell: http://hpaste.org/30180/roll_your_own_monad
13:23:22 <rothwell> yep
13:23:34 <rothwell> ooh!
13:23:36 <rothwell> thanks
13:23:43 <dafis> aristid: people are more used to if condition [then] thing else otherThing than to ifte cond a b
13:23:50 * rothwell eyes it carefully
13:24:02 <aristid> dafis: i suppose we want to have both
13:24:12 <aristid> dafis: but not having if as a function is a HUGE omission
13:24:15 * chrisdone curses under his breath every time he has to write 'then' and 'else'
13:24:21 <dafis> aristid: that's the nice thing, you can write it :)
13:24:28 <aristid> dafis: yes but you have to
13:24:34 <aristid> it's nowhere in base
13:24:35 <kulin> if i have types A and B, B has a function toA :: B -> A, and A satisfies a typeclass classA, and i want B to implement classA as well, is template haskell the correct extension to use?
13:24:48 <dafis> aristid: library proposal?
13:25:16 <aristid> dafis: hah
13:25:24 <dafis> meaning what?
13:25:28 <aristid> wait i might want to flip argument order for my guardOr
13:25:39 <chrisdone> use bool
13:25:41 <chrisdone> http://hackage.haskell.org/packages/archive/higherorder/0.0/doc/html/Data-Bool-Higher.html
13:25:41 <aristid> > let guardOr True = flip const; guardOr False = const in guardOr True [1] [2]
13:25:42 <lambdabot>   [2]
13:26:49 <dafis> chrisdone: (thing1 ?? thing2) condition doesn't seem too convincing to me
13:27:30 <chrisdone> I'm not trying to convince you of anything about (??)
13:27:45 <aristid> guardOr (null name) (return Result_Name_To_Short) (guardOr (length name > 32) (return Result_Name_Too_Long) (modify (set_name name) >> return Result_OK))
13:30:19 <dmwit> rothwell: Whoops, I got StateT and ErrorT in the wrong order.
13:30:24 <dmwit> Let me annotate.
13:30:33 <rothwell> dmwit: hehe, i'm still picking through it
13:30:36 <rothwell> hadn't picked up on that yet
13:31:47 <rothwell> my local documentation doesn't seem to have Control.Monad.Error, for some reason
13:32:19 <dafis> rothwell: mtl not installed?
13:32:33 <dmwit> rothwell: http://hpaste.org/paste/30180/runaction#p30182
13:32:54 <rothwell> the library is... apparently the documentation isn't
13:33:24 <dmwit> You could check ~/.cabal/config, I believe it has a setting for installing documentation that defaults to off.
13:33:28 <dafis> rothwell: Documentation: True in ~/.cabal/config?
13:33:50 <rothwell> is installed now
13:33:55 <rothwell> no idea why it wasn't, previously
13:34:09 <rothwell> dmwit: patching...
13:34:12 <maltem> mtl tends to be already installed from a distribution package, and those don't typically bundle haddocks
13:34:51 <dafis> ah, distribution packages
13:35:03 * dafis always builds from source
13:41:31 <rothwell> Control.Monad.Error is pretty nice
13:41:36 <rothwell> wasn't aware of it previously
13:41:46 <dmwit> Yes, it's a common pattern.
13:55:02 * augur hugs everyone <3
13:55:07 <augur> conal: hey! :D
13:55:19 <conal> augur: hi :)
13:55:48 <augur> hows things, conal sir
13:56:02 <conal> augur: groovy.
13:56:18 <augur> awesome :D
13:56:24 <conal> i'm working on some fascinating stuff.  will be in upcoming blog posts.
13:57:01 <augur> how do you decide what to write about? :|
13:57:17 <augur> or is it like someone said, how do you decide what /not/ to write about?
13:57:55 <conal> augur: whatever inspires me most, i play with.  and my favorite bits i then write about.
13:58:01 <augur> hm.
13:58:06 <augur> well.
13:58:18 <augur> you and oleg are writing machines
13:58:55 <augur> so conal, have you ever looked at natural language? :T
13:59:20 <Gracenotes> augur: still working on semantics-modeling esolangs? :D
13:59:26 <augur> Gracenotes: what?
13:59:41 <Gracenotes> your own stuff. just wondering.
14:00:02 <conal> i like about blogging that it's easy to get into, compared with writing a workshop, conference, or journal paper.  and then when i have a series of posts on a topic, i can rework the material into coherent enough form for publication.
14:00:38 <augur> hmmmm
14:00:38 <conal> augur: hardly any natural language at all.  i liked definite clause grammars when i looked into that topic many years ago.
14:00:50 <augur> conal: well! language is fun. :D
14:00:58 <conal> and how!
14:01:07 <JoeyA> If you create a StableName to an object, can it still be garbage collected?  The answer I want is "yes" :-)
14:01:08 <conal> oops.  augur left.
14:01:31 <conal> augur: fun for me also.  i'm fascinated with language.
14:01:55 <Saizan> JoeyA: the documentation says so
14:01:57 <augur> conal: i can tell you all about language if you'd like :D
14:02:36 <JoeyA> What about:  "There is no deRefStableName operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected."
14:02:49 <conal> augur: do you study/research natural language?
14:02:59 <augur> i do indeed sir
14:03:13 <augur> im a grad student at UMD doing linguistics
14:03:23 <conal> augur: ah, neat.  UMD?
14:03:33 <augur> University of Maryland
14:04:02 <conal> augur: Oh.  cool.  do you have a web page with interests/projects/papers/whatever?
14:04:45 <augur> not really. my interests are kind of scattered and vague, i havent written any papers proper yet, and my projects meh. i dont know if i can say ive gotten anywhere with them.
14:04:55 <augur> tho its on my list to try and organize such a website
14:05:38 <conal> what sort of questions are you interested in pursuing?
14:06:31 <augur> conal: island effects, the semantics of natural language, as well as computational tools for doing theoretical linguistics
14:07:11 <conal> augur: what are island effects?
14:07:52 <augur> conal: ok, well, to explain that imma need to give you some examples that arent directly demonstrative, so
14:08:45 <aristid> augur: i guess you could point to some papers :D
14:09:09 <augur> conal: first lets think about queries. if we think of logical formula as expression true or false statements, quantificational operators like forall and exists do something special to propositions
14:09:38 <augur> forall cats (\x -> loves x Alpo)
14:10:09 <augur> more commonly represented as Ax in Cats [loves(x,Alpo)]
14:10:12 <augur> or something like that
14:10:30 <augur> but what about queries proper? select cats (\x -> loves x Alpo)
14:10:39 <augur> (obviously cats dont love alpo, dogs do, but thats half the fun :D)
14:11:31 <augur> so lets say that we have some query operator, call it WH, and this lets us make statements like this:
14:11:54 <geheimdienst> uh, cats don't love alpo? didn't you just say forall cats (\x -> x `loves` Alpo)?
14:12:08 <dafis> geheimdienst: he lied
14:12:11 <augur> geheimdienst: i didnt say it was a TRUE statement! its just a statement :D
14:12:38 <augur> pet John (WH \x -> loves x Alpo)
14:13:05 <augur> which we can think of as saying that John pet those things that love Alpo
14:13:11 <geheimdienst> WH is a lie!!!1!!one
14:13:40 <augur> or if we wanted: pet John (WH dog \x -> loves x Alpo)
14:13:48 <augur> John pet the dogs that love Alpo
14:14:10 <augur> conal: so this makes sense, right? its not like theres anything crazy or insane about this WH operator
14:14:58 <conal> augur: not yet.
14:15:04 <augur> :P
14:15:17 <augur> perhaps maybe in a more haskell-esque mode
14:15:29 <conal> augur: since you haven't said anything about its meaning.
14:15:48 <augur> well, lets say this:
14:16:28 <augur> wh f g = filter g [x | x <- everything, f x]
14:16:32 <augur> or whatever.
14:17:10 <augur> wh dog \x -> like x Alpo == filter (\x -> like x Alpo) [x | x <- everything, dog x]
14:18:34 <augur> and then, pet :: Thing -> Thing -> Bool
14:19:09 <copumpkin> preflex: seen glguy
14:19:09 <preflex>  glguy was last seen on #haskell 24 days, 3 hours, 57 minutes and 40 seconds ago, saying: :t let x = 5 ; y = 15 ; z = x / y in x :: (Fractional t) => t
14:20:18 <augur> pluralObject f :: (Thing -> Thing -> Bool) -> Thing -> [Thing] -> Bool
14:20:18 <augur> pluralObject f x ys = all (\y -> f x y) ys
14:21:14 <augur> conal: so basically what we have is some expression like   `pluralObject like John (wh dog \x -> like x Alpo)`
14:22:16 <augur> which evaluates to   `all (\y -> like John y) (filter (\x -> like x Alpo) [x | x <- everything, dog x])`
14:22:39 <conal> k
14:23:03 <augur> conal: now lets say i want to select those people that pet dogs that like alpo:
14:23:20 <augur> wh people (\x -> pluralObject pet x (wh dog \y -> like y Alpo))
14:23:53 <augur> this is surely a completely sensible thing to do
14:24:01 <augur> as is this:
14:24:17 <augur> wh brands (\x -> pluralObject pet John (wh dog \y -> like y x))
14:25:17 <augur> conal: its all trivially boring filtering crap, right? theres nothing incoherent or logically senseless about this
14:25:18 <Gracenotes> :o
14:25:24 <augur> its all perfectly sensible.
14:25:41 <augur> well, natural language lets you do things kind of like this too:
14:25:59 <augur> the dogs that like Alpo ~ wh dogs \x -> like x Alpo
14:26:05 <JoeyA> lol, I ran into a weird performance issue.  When I switched from using StableName to DynamicStableName, it took 10x londer to sum [1..300000000] .  It turned out, it defaulted to [Integer] because I removed the type annotation.
14:26:25 <conal> sure
14:26:40 <dafis> JoeyA: perfectly normal
14:26:42 <lispy> JoeyA: that'll learn ya ;)
14:26:50 <augur> similarly, the people who pet the dogs that like Alpo ~ wh people (\x -> pluralObject pet x (wh dogs \y -> like y Alpo))
14:27:00 <augur> conal: but what about    wh brands (\x -> pluralObject pet John (wh dog \y -> like y x))
14:27:12 <augur> the brands that John pet the dogs that like
14:27:24 <geheimdienst> http://images.cheezburger.com/completestore/2010/9/18/5020508c-e75c-4804-9036-a96118dcc2bf.jpg
14:27:25 <augur> pfft no this is horrible
14:27:29 <augur> horrible thing to say
14:27:45 <augur> geheimdienst: John iz cat?
14:27:57 <dafis> augur: why is it horrible to say?
14:28:07 <lispy> where do these John and Alpo examples keep coming from?  Is it just Bob and Alice's encrypted love afair?
14:28:08 <conal> augur: pluralObject and wh are pretty similar, aren't they?  can you simplify?  for instance, use sets (characteristic functions) instead of lists?
14:28:16 <augur> conal: i dont know! but it sounds pretty crap, doesnt it? "I saw the brands that John pet the dogs that love"
14:28:24 <lispy> er, I meant to say "just like"
14:29:10 <geheimdienst> lispy, the original source for john and alpo is http://images.cheezburger.com/completestore/2010/9/18/5020508c-e75c-4804-9036-a96118dcc2bf.jpg
14:29:12 <augur> conal: im just using pluralObject to avoid adding plural functions to Haskell :p  you can ignore it if you like. its not crucial. i just wanted to be consistent with haskell.
14:29:51 <augur> conal: the point is, tho, that kind of noun phrase _sounds_ horrible. it makes sense _logically_ but it just sounds like crap
14:29:57 <augur> geheimdienst: oh you cheeky liar you.
14:30:30 <geheimdienst> i made a statement. i didn't claim it's a true statement. it's all logic, you see.
14:30:31 <geheimdienst> :-P
14:30:38 <augur> conal: to make things worse, this isn't a fact about _english_ but a fact about all languages we've studied.
14:30:52 <lispy> I will assume this "John" and the dogs that like Alpo are the things that Bob and Alice have been trading encrypted/enciphered messages about for years
14:30:58 <augur> so we cant just say oh well thats just a peculiarity of English.
14:31:04 <conal> ah
14:31:20 <augur> conal: this is called an island.
14:31:28 <eps__> out of interest are there any computer architectures proposed for functional programming? instead of von neumann that is? I can't find anything relevant on google but I remember reading about some suggestions
14:31:35 <conal> augur: what is?
14:32:06 <augur> conal: this kind of thing. itll take some more explaining what PRECISELY "this kind of thing" denotes and why :p
14:32:45 <conal> augur: this what you mean? : http://en.wikipedia.org/wiki/Wh-movement#Wh-islands
14:32:47 <aristid> augur: well i suppose that is because you don't understand it well enough to phrase it succinctly :)
14:32:49 <augur> conal: yes
14:32:56 <conal> k
14:33:04 <augur> conal: so in the history of syntax, people thought that what happened to build relative clauses was the following: you have a normal declarative sentence, but with one "argument" replaced by an "operator" like wh:   wh likes Alpo
14:33:06 <Saizan> eps__: the reduceron, maybe?
14:33:27 <augur> and then the operator is moved to form a lambda abstraction that the operator operates on: wh (\x -> x likes Alpo)
14:33:39 <geheimdienst> so in this haskellish notation you used things can be stated that, when translated to english, take some more words?
14:33:44 <augur> this has some nice relations to continuations, as people have subsequently noted
14:33:46 <lispy> eps__: yeah, it's an active area again after a while of not being active
14:34:06 <lispy> eps__: that is, it's a research thread that comes up, goes away, comes up, etc
14:34:31 <augur> conal: the "island" here is the relative clause. it's an "island" because you're "stuck" in it like you're stuck on a island if you don't have a raft or bridge
14:34:34 <eps__> I'm just writing a paragraph on alternatives to von neumann and I thought I'd slip haskell in
14:34:48 <maltem> Looking at lingustic wikip. articles, I get a feeling for what other people think when they stumble upon math or CS articles
14:34:50 <eps__> thanks lispy Saizan, reduceron seems to be what I'm after
14:35:02 <augur> conal: so if i have a sentence with a relative clause that contains a wh operator: "John saw the dogs (that like WH)"
14:35:04 <lispy> eps__: People tend to focus on implementing Haskell's graph reduction as an abstract machine and then pushing that into hardware
14:35:25 <lispy> eps__: at IFL this year there was a paper about something more recent than reduceron
14:35:40 <conal> augur: are you looking for a precise & composable explanation of islands?
14:35:50 <augur> the WH cant "get out of" the relative clause to form the lambda abstraction: WH (\x -> John saw the dogs (that like x)) is bad
14:35:58 <conal> augur: that's consistent with natural language?
14:36:06 * geheimdienst wonders if one of those lisp machines they had when dinosaurs roamed the earth would count as a non-von-neumann machine
14:36:09 <augur> conal: well, the goal is to discover what sort of system has islands as a natural consequence.
14:36:11 <lispy> eps__: this is the conference page, but I don't think the papers have been published yet: http://www.cs.uu.nl/wiki/bin/view/IFL2010/WebHome
14:36:30 <conal> augur: ah.  interesting
14:36:35 <eps__> just need the name, and to be sure it's correct (since this will be in print for half a decade :S) 
14:36:59 <lispy> To be fair, modern processors are not true von neumann
14:37:25 <augur> conal: there are other islands too, right. for instance, subjects of sentences seem to be islands:   An article about Chomsky shocked academics   but not   Who did an article about shock academics
14:37:42 <lispy> geheimdienst: http://en.wikipedia.org/wiki/Von_Neumann_architecture
14:38:12 <augur> conal: and to make things worse, there are all sorts of fun cases where island-hood is "turned off"
14:38:13 <Tarrasch> Hello, just a small question: We call one viewpoint of lists as ZipLists, what would the other ("normal" lists) viewpoint be called? (where pure x = [x])
14:38:25 <geheimdienst> lispy, yeah i realized a moment later that my comment must have been bunk
14:38:27 <geheimdienst> :-/
14:38:56 <augur> conal: so basically the project is to discover why the islands are what they are. how they're a natural consequence of the computational system that is Natural Language
14:39:00 <eps__> lispy, found what I needed thanks, :)
14:39:01 <Saizan> Tarrasch: the corresponding monad is often referred to as the non-determinism one
14:39:09 <lispy> geheimdienst: I'm actually wondering now if reduceron is still von neumann
14:39:10 * geheimdienst assumes this might mean it is advantageous to think before speaking
14:39:19 <Tarrasch> Saizan, can ZipLists be made to monads?
14:39:21 <conal> eps__: if you're looking at alternatives to the sequential von neumann arch, check out von neumann's ideas on non-sequential computation.
14:40:24 <conal> Tarrasch: are you asking whether ZipList is a monad?
14:40:37 <copumpkin> Tarrasch: if they're type-sized, yep
14:41:02 <Saizan> Tarrasch: with some caveats, "ZipList n" which would be the type of ziplists of length n would be
14:41:17 <geheimdienst> "omg we wuldn't has buffer overflow without von neumann!!!1!"
14:41:21 <Saizan> Tarrasch: n can be "infinity"
14:42:10 <aristid> geheimdienst: uh.
14:42:26 <HNSZ> augur: One of the things that completely messes up the xbar model :p
14:42:36 <augur> HNSZ: what?
14:42:56 <Tarrasch> conal, yep, that was the question :)
14:43:10 <aristid> Saizan: how is join defined on them?
14:43:19 <Saizan> aristid: you take the diagonal
14:43:25 <Tarrasch> so bind is the same, assuming there is no other meaningful way to join but concat
14:43:26 <HNSZ> It's one of the issues that they have made ugly hacks for in teh xbar model, IMO
14:43:29 <Tarrasch> Saizan, o_O
14:43:42 <aristid> :t concat . transpose
14:43:42 <lambdabot> forall a. [[a]] -> [a]
14:43:43 <augur> HNSZ: in what way?
14:43:44 <Tarrasch> ok, I'm wrong, apperently
14:43:47 <aristid> Saizan: like this?
14:43:57 <Saizan> aristid: no
14:44:23 <HNSZ> I'm not an expert, I have just done a course on it. But it was a big turn off for me.
14:44:23 <copumpkin> aristid: it looks down the diagonal
14:44:29 <conal> without the size constraints, would a diagonalizing ZipList Monad instance violate a monad law?
14:44:40 <Saizan> ?type \xs -> zipWith (!!) xs [0..]
14:44:41 <lambdabot> forall a. [[a]] -> [a]
14:44:49 <augur> HNSZ: which part was a big turnoff?
14:44:57 <aristid> Saizan: hmm.
14:44:57 <dolio> conal: Yes, it fails associativity.
14:45:00 <Cale> Think of ZipList n a as being the same as functions n -> a, where n is an arbitrary set with n elements
14:45:01 <Saizan> more like that, module performance
14:45:05 <conal> dolio: ah.
14:45:12 <Cale> and functions from any fixed set form a monad
14:45:13 <HNSZ> The complementiser phrase is used to put the wh or which in which actually comes from a different place and leaves a trace right?
14:45:34 <HNSZ> which in, which*
14:45:40 <dolio> conal: I think there's a haskell-cafe mailing list post out there where I gave an example. It's hard to just come up with one, though.
14:45:42 <augur> HNSZ: yeah but thats not X-Bar theory, thats trace theory plus transformations
14:45:51 <Cale> (where join f x = f x x)
14:46:09 <HNSZ> Sure but it's what you do to make the x-bar tree
14:46:27 <augur> HNSZ: no, not at all. X-Bar and transformations are unrelated.
14:46:43 <HNSZ> and switch from the tree structure to the superficial structure
14:47:03 <augur> sentences have no superficial structure other than the string.
14:47:14 <Saizan> "join xs = [ (xs !! i) !! i | i <- [0..n] ]" vs. "join f = \x -> f x x"
14:48:04 <Tarrasch> And we all love (!!) :p
14:48:19 <HNSZ> But supposedly you have a syntactic structure, which has to be transformed to a structure that is an actual sentense right? Supurficial is the wrong word i guess.
14:49:26 <Saizan> Tarrasch: that's why a real implementation would use "join [] = []; join ((x:xs):xss) = x : join xss" :)
14:49:28 <aristid> Saizan: so ZipList l is roughly the same as (!!) l?
14:49:47 <dolio> http://www.haskell.org/pipermail/haskell-cafe/2009-April/059088.html
14:50:14 <Saizan> aristid: it's more like ($) ~ (!!) here
14:50:17 <augur> HNSZ: yes and no. keep in mind that theoretical syntax is trying to find tools for characterizing the good vs. bad sentences. transformational syntax does this by changing one structure into another etc. other theories, like HPSG, utilize complex collections of properties.
14:50:22 <Tarrasch> Cale, your description of ZipList n a seems very wierd to me, shouldnt it just be ZipList n a is a list with a's ([a]) with exactly n elements?
14:50:29 <copumpkin> Fin n -> a
14:50:32 <aristid> Saizan: is that a yes?
14:50:51 <Cale> Tarrasch: That's the same thing
14:51:08 <augur> HNSZ: even if you dont use transformations, you still have to use some sort of abstract object.
14:51:13 <Tarrasch> used sets and such :p
14:51:17 <Cale> Tarrasch: A list with exactly n elements is the same thing as a function from a totally ordered set of n elements
14:51:17 <Tarrasch> he used*
14:51:21 <aristid> > ((,) <$> ([1,2,3] !!) <*> ([1,2,3] !!)) [0..]
14:51:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:51:22 <lambdabot>         against inferred type ...
14:51:33 <aristid> :t (,) <$> ([1,2,3] !!) <*> ([1,2,3] !!)
14:51:34 <lambdabot> forall a a1. (Num a, Num a1) => Int -> (a, a1)
14:51:48 <Saizan> ah, in that sense yes
14:51:56 <aristid> :t map ((,) <$> ([1,2,3] !!) <*> ([1,2,3] !!)) [0..]
14:51:57 <lambdabot> forall a a1. (Num a, Num a1) => [(a, a1)]
14:52:01 <aristid> > map ((,) <$> ([1,2,3] !!) <*> ([1,2,3] !!)) [0..]
14:52:02 <lambdabot>   [(1,1),(2,2),(3,3),(*Exception: Prelude.(!!): index too large
14:52:07 <conal> Tarrasch: the list is the memoized version of the function
14:52:10 <Tarrasch> totally ordered set?
14:52:21 <Saizan> aristid: (!!) is one half of the isomorphism between vectors of size n and functions from [0..n]
14:52:43 <Cale> Tarrasch: Or if you prefer, a function from the specific set {0,1,...,n-1}
14:52:43 <Tarrasch> ah, you mean the index-number 0 ... n-1 ?
14:52:52 <Tarrasch> i c ...
14:53:02 <Cale> Often that set is itself referred to as n
14:53:12 <aristid> Saizan: i suppose that can be used by optimising compilers :)
14:53:15 <Cale> (This is how the natural numbers are built up in set theory)
14:53:15 <HNSZ> augur: Yes but at a certain poin the object are used inconsistently.
14:53:23 <augur> HNSZ: how so?
14:53:25 <Saizan> (s/[0..n]/[0..n-1]/ to be precise :)
14:54:07 <HNSZ> For instance the fact that, for convenience, the CP is used as a container for the whole sentence.
14:54:20 <augur> HNSZ: how is that inconsistent?
14:55:19 <HNSZ> Because that is not the original use for the CP, it's jsut convenient because there may be words that need to be moved to the beginning of the sentence.
14:55:34 <augur> er.. what was CP before it was the clause
14:55:37 <Tarrasch> Cale - (where join f x = f x x), that can also be written as:    (join f) x = (f x) x, right?
14:55:45 <HNSZ> It's basically because the head of the root of the tree is already full.
14:56:05 <Tarrasch> and x is 0..n-1
14:56:20 <HNSZ> It's a complementiser phrase, but there is no complementiser in the main sentense.
14:56:23 <Cale> Tarrasch: yes
14:56:31 <geheimdienst> basically because the head of the root of the tree is pet dogs john
14:56:42 <augur> HNSZ: actually there is! in english you cant hear it, but in irish it's there in plenty of main sentences.
14:57:05 <Tarrasch> Saizan, about your "join [] = []; join ((x:xs):xss) = x : join xss",  that doesn't work does it?
14:57:11 <Tarrasch> It always takes first element
14:57:52 <augur> HNSZ: in japanese it's there in questions, exclamations, etc. lots of languagesh have phonologically overt C for normal declarative sentences.
14:58:16 <Tarrasch> you would want something like: join ((x:xs):(_:xss)) = x : join xss, (of course that doesnt work but you know what i mean, relete first column)
14:58:31 <Saizan> Tarrasch: ah, i think i forgot a map tail
14:58:55 <Tarrasch> but wouldn't that be as (if not worse) then using !! even twice?
14:59:00 <HNSZ> augur: can you give an example?
14:59:26 <Saizan> > let join [] = []; join ((x:xs):xss) = x : join (map tail xss) in join (replicate 3 [1,2,3])
14:59:27 <lambdabot>   [1,2,3]
14:59:34 <HNSZ> I'm sure there is one in my book :(
15:00:07 <GilgaBook> hey guys, afternoon :)
15:00:17 <augur> in japanese, a question ends with ka: "sushi o taberu ka" ~ do you eat sushi?, exclamations end in yo: "sushi o taberu yo" ~ i eat sushi!, etc.
15:00:23 <augur> HNSZ: as for irish, i dont have examples off hand.
15:00:38 <GilgaBook> am learning haskell now, and was wondering if anyone could clarify to me what is the difference between using guards and a simple if statement
15:00:51 <Saizan> Tarrasch: i suspect they are both quadratic but the (!!) version has a larger constant factor
15:01:14 <Tarrasch> > let join xs = [ (xs !! i) !! i | i <- [0..length xs - 1] ] in join (replicate 3 [1,2,3])
15:01:14 <lambdabot>   [1,2,3]
15:01:19 <Tarrasch> that was way faster response :p
15:01:47 <HNSZ> augur: And that is a complementiser?
15:01:51 <dafis> GilgaBook: guards stay readable with multiple conditions
15:01:58 <Saizan> heh, yeah, let's all run our benchmarks over irc :)
15:02:00 <augur> HNSZ: that's how it's analyzed.
15:02:01 <Tarrasch> Saizan, yea, probably, but in the end. Will bind to be quadratic?
15:02:34 <GilgaBook> dafis: that is pretty much it?
15:02:45 <HNSZ> augur: There were other things that bugged me but I can't remember atm.
15:02:52 <GilgaBook> dafis: or is there anything else, like performance issues, or something like that?
15:02:58 <djahandarie> 日本語は素晴らしいですわ〜
15:02:59 <dafis> > let join xs = zipWith (!!) xs [0 .. ] in join (replicate 4 [1 .. 4])
15:03:00 <lambdabot>   [1,2,3,4]
15:03:27 <augur> HNSZ: lots of things bug people. you should take it as an opportunity to move the field forward, instead of rejecting it as simply absurd.
15:03:56 <dafis> GilgaBook: That's pretty much it, whatever you can do with guards, you can do with nested ifs and vice versa.
15:04:18 <GilgaBook> dafis: cool! thanks a lot for the clarification :D
15:04:23 <HNSZ> I like the analytical part, just not the fact that they need to cram it into a model.
15:04:27 <GilgaBook> back to reading
15:04:34 <dafis> GilgaBook: But if you nest ifs deeper than three, it's completely unreadable usually.
15:04:37 <augur> HNSZ: what do you mean cram it into a model?
15:04:50 <riboflavin> can I nest guards in haskell?
15:05:09 <GilgaBook> dafis: yeah... have that experience from other languages hehe
15:05:10 <dafis> riboflavin: nest guards?
15:05:23 <Tarrasch> riboflavin, don't you just want to use (&&) ? :)
15:05:30 <HNSZ> I mean that Natural language doesn't lend itself to such a simple model.
15:05:40 <riboflavin> Tarrasch: that wouldn't do what I want
15:06:03 <Tarrasch> riboflavin, what do you have in mind, how would it work?
15:06:04 <augur> HNSZ: maybe it does, maybe it doesnt. we just dont know. and we can only get closer to the truth by trying.
15:06:20 <riboflavin> Tarrasch: like a nested if statement, but with guards
15:06:23 <dafis> riboflavin: like, if a && b then _ else if a then _ else if b then _ else _ ?
15:06:42 <riboflavin> yes. Just a much nicer way to do a lot of if then else's
15:06:53 <riboflavin> like a nested switch statement in C
15:06:59 <Saizan> Tarrasch: yeah, but concat is also going to have a runtime that is in O(n^2) if you pass it (replicate n (replicate n ()))
15:07:36 <Tarrasch> Saizan, but you get a lots of more elements per money!
15:07:45 <Tarrasch> Saizan, I mean per time ;)
15:07:55 <dafis> riboflavin: No, you can do sequential gurds for these conditions, fun x | a && b = ... | a = ... | b = ... | otherwise = ...
15:07:56 <HNSZ> Sure but it's being portrayed as the one true model.
15:08:24 <dafis> s/gurds/guards/
15:08:30 <augur> HNSZ: only by anti-Chomskyans.
15:08:43 <Tarrasch> dafis, can you do that?
15:09:02 <dafis> Tarrasch: what?
15:09:13 <riboflavin> dafis: yes, but that would result in redundant comparisons. I think I will just stick to fun x |a = ... |b = ...|c = if d then ... else ...
15:09:22 <Tarrasch> dafis, nm, I thought you mean to have them on the same line someway
15:09:51 <dafis> Tarrasch: you can have them on one line - but I recommend strongly against that
15:09:51 <HNSZ> augur:What can I say to that?
15:10:11 <HNSZ> augur: I hate Noam Chomsky? 
15:10:34 <dafis> riboflavin: yes, a few redundant comparisons, but the conditions should be evaluated only once
15:10:46 <HNSZ> augur: I think Hitler was anti-chomski aswell...
15:10:49 <augur> HNSZ: i dont know what your experience in linguistics is. but what i meant by anti-chomskyan is against the framework, not against the person
15:10:59 <Saizan> > let f a b | a && b = "a & b" | a = "a" | otherwise = "otherwise" in f True False
15:11:00 <lambdabot>   "a"
15:11:06 <Saizan> Tarrasch: you can ^^^
15:11:24 <HNSZ> augur: Yes the framework looks pretty broken and unworkable to me.
15:11:59 <augur> HNSZ: its as workable as any of the other frameworks. in some ways more so, in some ways less so.
15:12:26 <HNSZ> Especially when I have to set up the structure and then look the original sentence to fix the tree. 
15:12:34 <augur> what
15:12:47 <HNSZ> It cannot generate a sentence. 
15:12:54 <riboflavin> I ended up just doing it like this http://pastebin.com/T0iw5JN5 (but nested guards would be so much nicer)
15:12:55 <augur> i dont follow
15:13:14 <geheimdienst> i maked u a sentense but i eated it :-(
15:13:33 <riboflavin> also, that is wrong
15:13:57 <dafis> riboflavin: wouldn't pairComp = compare be better?
15:14:12 <dafis> pairCMP
15:14:29 <Saizan> yeah, that'd be just compare
15:14:50 <Saizan> but also pairCMP (x,y) (s,r) = compare x s `mappend` compare y r
15:15:05 <riboflavin> yes. But this is for a homework assignemnt and we are supposed to write our own comparison functions
15:15:11 <steveklabnik> hey guys. I'm trying to brush up on my haskell again, and so I'm trying to write a basic game with a tail recursive main loop. simple stuff. problem is... it doesn't print as I loop, it prints at the end. can anyone point out to me why I'm a noob? http://gist.github.com/586098 thanks.
15:15:21 <steveklabnik> I know I did this before. I'm just doing something stupid.
15:15:29 <augur> HNSZ: how can it not generate sentences? the whole point is that it generates sentences
15:15:42 <dafis> riboflavin: pairCMP (x,y) (s,r) | x < s = LT | x > s = GT | y < r = LT | y > r = GT | otherwise = EQ
15:15:53 <augur> steveklabnik: why are you not in #ranarchism!
15:16:15 <steveklabnik> augur: :p. because I'm trying to do work.
15:16:18 <augur> :|
15:16:21 <riboflavin> dafis: oh, yea, actually, that is nicer than what I have. I didn't think about how the first oens would take precedence
15:16:24 <augur> work is for proles!
15:16:42 <steveklabnik> by work I mean "play with haskell for fun again"
15:16:56 <augur> fun is for proles!
15:16:56 <dafis> steveklabnik: shouldn't thatbe hFlush stdout?
15:17:09 <AmunRa> Hello, in ghci: is there any way to list all the functions that can be applied to a type?
15:17:09 <Saizan> riboflavin: why not http://pastebin.com/9VhWMCwc instead of the if?
15:17:17 <steveklabnik> dafis: oops! that shouldnt be in there
15:17:43 <riboflavin> Saizan: yea, dafis just pointed that out to me. I wasn't thinking about how the first entries would take precedence, which is dumb of me
15:17:44 <Saizan> riboflavin: ah, nvm, dafis was faster :)
15:17:46 <steveklabnik> dafis: i was trying that to see if it would work or not, and it didn't... but I forgot to remove it. would doing an hflush there solve my problem? or should I be doing it a different way?
15:18:23 <HNSZ> augur: I would be very pleased to see a program that does that.
15:18:49 <dafis> steveklabnik: as you putStrLn, it should print out during the loop anyway, because normally stdout is line-buffered
15:19:05 <augur> HNSZ: ill write one tomorrow or the day after for you, if you'd like. which mode would you prefer, GB or Minimalism?
15:19:08 <steveklabnik> dafis: okay. at least I'm not being stupid. But it's not. :/
15:19:13 <augur> or perhaps something older, like EST?
15:19:15 <augur> or ST?
15:19:32 <dmwit> steveklabnik: I can't reproduce. When I run it, it prints each iteration of the game loop.
15:19:35 <dafis> steveklabnik: which OS?
15:19:42 <HNSZ> augur: can you point me to one?
15:19:54 <Tarrasch> Good night everybody
15:19:55 <steveklabnik> dafis: dmwit: arch 64 bit
15:20:00 <dmwit> same
15:20:18 <dmwit> steveklabnik: Can you describe the behavior you're expecting, and the behavior you're getting, more precisely?
15:20:19 <steveklabnik> Linux deadreckoning 2.6.34-ARCH #1 SMP PREEMPT  is uname -a
15:20:26 <augur> HNSZ: most syntacticians dont write programs, so no. not really.
15:21:07 <augur> HNSZ: tho i _am_ writing a program that can be used to explore syntactic theories, one component of which will be the ability to generate sentences.
15:21:30 <dafis> steveklabnik: What happens if you `hSetBuffering stdout LineBuffering' at the beginning of main?
15:21:32 <HNSZ> augur: You are telling me that there is a model that can generate sentenses and nobody has ever taken it as a blueprint for a program to do so?
15:21:38 <steveklabnik> dmwit: dafis I got it. 
15:21:54 <dafis> steveklabnik: and?
15:22:04 <dafis> vot voz it
15:22:24 <wolfwood> dafis: dmwit: didn't work a a vim shell command
15:22:33 <wolfwood> works in a normal shel
15:22:39 <augur> HNSZ: plenty of people have tried to use portions of it for, say, parsing, etc. but most syntacticians aren't sufficiently computer nerdy to _do_ stuff computationally with it, no.
15:23:11 <augur> its unfortunate, but its not like you need a computer to generate sentences in GB.
15:23:12 <steveklabnik> dafis: dmwit : wolfwood is physically in the room with me, my stuff froze. yeah, it wasn't flushing the output because I was running it from within vim via :!. *sigh*
15:23:39 * dafis never liked vim
15:23:43 <steveklabnik> dafis: dmwit i had to type one (enter) two (enter) until ten, and then it printed everyhing. but all is good now. thank you!
15:23:50 <wolfwood> EMACS!
15:23:59 <dafis> wolfwood: no, kate
15:24:00 <dmwit> steveklabnik: Sounds like it was block-buffered for some reason.
15:24:22 <augur> HNSZ: tho some attempts have been made. they're few and far between, but. check out Larson's Syntactica: http://semlab5.sbs.sunysb.edu/~rlarson/Syntactica/syntactica.html
15:24:35 <wolfwood> isatty returned no because it was a pipe to vim
15:24:43 <wolfwood> ty, peace
15:25:00 <HNSZ> augur: Will check it out.
15:25:38 <HNSZ> Perhaps some day I will delf into it myself
15:26:07 <augur> ok im off to do some robotrippin'
15:26:08 <augur> see ya guys
15:26:14 <HNSZ> delve*
15:26:20 <HNSZ> bb
15:27:54 <augur> HNSZ: when im done with my little program, ill let you know. are you on a mac?
15:28:09 <HNSZ> linux
15:28:16 <augur> oh. well. nevermind then :)
15:28:38 <HNSZ> :)
15:28:53 <HNSZ> You wrote it in objective-c?
15:28:53 <augur> ill be sure to make some screencasts tho! :D
15:29:02 <augur> actually im using a ruby backend
15:29:29 <augur> i wish there were something more .. elegant? obj-c makes a lot of simple stuff hard
15:29:50 <HNSZ> SHould be fairly portable then?
15:30:05 <augur> the app will be highly Cocoa dependent tho, so..
15:30:11 <riboflavin> nobody has manged to port obj-c to linux? lame. C# was ported, which was neat
15:30:31 <augur> i mean, i can show you the ruby core, which does all the proof-related stuff. its the GUI stuff that will be cocoa
15:30:34 <augur> anyway, bye <3
15:30:54 <dafis> riboflavin: perhaps nobody saw a reason to port obj-c
15:31:38 <riboflavin> dafis: fair enough. I don't know much about it anyway, or if it's any good, other than that some mac fanatic friends of mine swear by it, but I think they are required to
15:32:19 <HNSZ> bye
15:32:22 <dmwit> I think Core Graphics are darn nice.
15:32:34 <dafis> riboflavin: I don't know it either, I've heard differing opinions about it though
15:33:00 <ologNation> What's the best way to find and read the source for a cabal package? 
15:33:08 <ologNation> (I'm thinking of haskellForMaths)
15:33:20 <dafis> ologNation: source links, or cabal unpack
15:33:22 <conal> ologNation: cabal install, then cabal unpack
15:34:34 <conal> oh, i see: "cabal unpack [PACKAGES]"
15:37:01 <ologNation> conal!
15:37:12 <chrisdone> @hoogle System.Time.ClockTime -> Data.Time.UTCTime
15:37:13 <lambdabot> Parse error:
15:37:13 <lambdabot>   --count=20 "System.Time.ClockTime -> Data.Time.UTCTime"
15:37:13 <lambdabot>                    ^
15:37:14 <conal> ologNation: hey there.
15:37:21 <chrisdone> anyone got it?
15:37:26 <ologNation> Last time I talked to you was at the *beginning* of the summer. 
15:37:58 <kmc> riboflavin, gcc supports objc, and GNUStep provides the various NS APIs
15:38:40 <riboflavin> kmc: oh, cool, good to know
15:40:26 <conal> ologNation: yeah?
15:42:32 <freedrull> i have this parser : choice (fmap string a), where a is a list of strings, but it only parses the first of the strings that start with a given letter, and fails on the rest that start with that letter (so "ant" works, but "apple" will fail, for instance)
15:42:58 <dafis> freedrull: parsec?
15:43:03 <freedrull> dafis: yes
15:43:16 <dafis> freedrull: fmap (try . string) a
15:43:50 <dafis> freedrull: if a parser fails *after* having consumed *any* input, parsec won't backtrack
15:44:15 <aristid> @src curry
15:44:15 <lambdabot> curry f x y = f (x, y)
15:44:23 <dafis> so you have to tell it to pretend not to have consumed any input if you want it to backtrack nevertheless
15:44:51 <freedrull> dafis: right, i couldnt figure out how to get try into this equation...
15:45:04 <freedrull>     Couldn't match expected type `[GenParser Char st String]'
15:45:04 <freedrull>            against inferred type `GenParser
15:45:04 <freedrull>                                     Char () (GenParser Char st String)'
15:45:54 <dafis> freedrull: that error from what code?
15:46:10 <freedrull> dafis: fmap (try . string) a
15:46:22 <freedrull> maybe: choice (fmap (try . string) a) ?
15:46:40 <dafis> freedrull: yes, I left out the choice part
15:47:11 <freedrull> yess it works now
15:47:13 <freedrull> thank you!
15:47:19 <dafis> welcome
15:56:45 <freedrull> in parsec, are there case insensitive char or string functions?
15:56:57 <dmwit> I don't think so.
15:57:00 <dafis> freedrull: no
15:57:07 <AmunRa> I'm reading the 13th issue of the monad reader where it's explained that "Either a b" is a functor... what am I getting wrong in the following? fmap toUpper $ Left 'x'
15:57:20 <dafis> freedrull: you have to roll your own via satisfy
15:57:33 <mauke> AmunRa: it can't be a functor; it has the wrong kind
15:57:41 <mauke> Either a is a functor
15:57:46 <dmwit> > fmap toUpper (Left 'x') -- seems fine to me AmunRa, but keep in mind that fmap will only affect "Right"s
15:57:47 <lambdabot>   Left 'x'
15:57:50 <dafis> AmunRa: correctly, (Either a) is a Functor
15:57:51 <dmwit> > fmap toUpper (Right 'x')
15:57:52 <lambdabot>   Right 'X'
15:58:00 <mauke> > fmap toUpper (Left 42)
15:58:01 <lambdabot>   Left 42
15:59:57 <AmunRa> gotcha.. so it's fine so long as both types are the same.. i.e. Either a a, i.e. Either Char Char .. thanks
16:00:16 <dafis> AmunRa: no
16:00:50 <dafis> AmunRa: for any gixed a, (Either a) is  a Functor
16:00:57 <dafis> *fixed
16:01:32 * AmunRa is confused.. Either takes to type parameters
16:01:45 <AmunRa> s/to/two/
16:01:46 <dmwit> AmunRa: Rather, what we're saying is that only the second type variable varies when applying fmap. fmap :: (b -> c) -> (Either a b -> Either a c)
16:01:47 <dafis> :t \f -> either (const "Left") show . fmap f
16:01:48 <lambdabot> forall a b a1. (Show b) => (a1 -> b) -> Either a a1 -> [Char]
16:02:17 <dmwit> > (fmap (+1) (Left "hey"), fmap (+1) (Right 3))
16:02:18 <lambdabot>   (Left "hey",Right 4)
16:02:48 <dafis> AmunRa: if there were type-level lambdas, \b -> Either a b were the Functor
16:03:08 <dafis> AmunRa: (Either a) is partially applied
16:03:14 <jmcarthur> AmunRa: functors have kind *->*. either has kind *->*->*. (either a) has kind *->*  :)
16:03:24 <kmc> AmunRa, functors include Maybe, IO, and (Either a).  note that they're all "missing" a type parameter
16:03:46 <dafis> And of course []
16:03:49 <AmunRa> yeah.. I didn't get around understanding what the * syntax means
16:03:52 <kmc> which is to say they have kind ∗ → ∗
16:03:59 <kmc> kinds classify types, as types classify values
16:04:09 <kmc> if you can create a value of type T, then T :: *
16:04:23 <kmc> otherwise, T is a type constructor which is still waiting for arguments
16:04:40 <kmc> in which case you have -> in the kind, telling you the kinds of those arguments
16:05:55 <kmc> :k Maybe
16:05:56 <lambdabot> * -> *
16:06:00 <kmc> :k Either
16:06:01 <lambdabot> * -> * -> *
16:06:03 <kmc> :k StateT
16:06:04 <lambdabot> * -> (* -> *) -> * -> *
16:06:29 <kmc> AmunRa, makes sense?
16:07:42 <bnery> hi guys! I started learning Haskell through the LYAH tutorial (I'm on the functors/monoids chapter now) and I was wondering...
16:07:43 <AmunRa> everything apart from the syntax.. I didn't realise there were "kinds" in haskell.. I'm off to read up on them
16:07:55 <bnery> what can I do to "practice my Haskell"?
16:08:12 <freedrull> ....write haskell?
16:08:29 <dafis> bnery: find some interesting but small enough task and get going
16:08:30 <bnery> freedrull that I know, but write what? :)
16:08:36 <AmunRa> bnery, project euler is fun
16:08:57 <bnery> AmunRa I was wondering if there was some kind of "real world" stuff to work on, beside project euler
16:09:07 <bnery> like an online Hackathon
16:09:22 <bnery> to get a taste of real things and interact with people
16:09:23 <dmwit> bnery: A raytracer, a lambda calculus interpreter, an IRC bot...
16:09:49 <bnery> dmwit something that would be used later, perhaps?
16:09:56 <dmwit> bnery: If you want to work on some existing code, check out Hackage.
16:10:07 <dmwit> There's a bunch of neat stuff there that could use some tweaking, bug-fixing, rewrite, etc.
16:10:09 <bnery> anyway, is there someone from Portugal hacking Haskell?
16:10:09 <AmunRa> I started doing all my unix scripts in Haskell.. if you want to do something more down to earth
16:10:10 <tensorpudding> bnery: write an interpreter for some small language
16:10:21 <dmwit> I personally hack on xmonad (well, xmonad-contrib) from time to time, which is quite fun.
16:10:40 <augur> conal: if i can elucidate any other stuff about language let me know :p
16:10:41 <bnery> AmunRa I like the idea of doing shell scripts :) I already did one in Haskell this weekend
16:10:49 <conal> augur: thx!
16:11:01 <AmunRa> BS.interact and there you go :-)
16:11:26 <bnery> tensorpudding being a guy from cognitive robotics, I don't see the point of writing an interpreter... the compilers I wrote in C++ were tiring enough in my MSc
16:11:34 <kmc> yeah well
16:11:39 <kmc> writing a compiler in C++ really sucks
16:11:58 <kmc> C++ is one of the worst languages you could pick for symbolic manipulation
16:11:59 <dafis> s/a compiler//
16:12:00 <bnery> kmc well, that was the base the prof had
16:12:00 <dmwit> bnery: There's also haskell_proposals.reddit.com, where you can find a bunch of ideas for fun projects.
16:12:14 <kmc> if you write, say, a minimal Scheme interpreter in Haskell, you will probably be amazed how short it is
16:12:29 <kmc> i think it's really fun to design new languages, implement them, and hack on them
16:12:50 <kmc> that's just me thoguh
16:12:53 <kmc> (me and half of this channel)
16:13:20 <AmunRa> kmc, just half?
16:13:30 <kmc> PL nerds are drawn to Haskell for tolerably obvious reasons
16:13:49 <bnery> AmunRa LOL
16:13:58 <augur> conal: 
16:14:23 <augur> there's a whole slew of interesting phenomena that chomskyan syntacticians explore, and a bunch that the non-chomskyans explore
16:14:24 <bnery> anyway, pinging again: do you know anyone in Portugal that is usually here?
16:14:31 <bnery> maybe... Spain or France?
16:14:43 <augur> they dont always overlap, in terms of popularity, but like.. non-constituent conjunction is a fun one
16:14:53 <dmwit> There are various #haskell- channels for other languages.
16:15:06 <dmwit> Perhaps you should start there (though they're much lower-traffic than this one).
16:15:38 <dafis> bnery: and maybe Portugal, Spain and France are mostly in bed now
16:16:08 <dafis> bnery: ask again during daylight
16:16:23 <bnery> dafis well, it's still midnigh here in Portugal. and I guess Haskell programmers are just regular programmers, being awake during the night
16:16:38 <bnery> dafis of course it's already 1am in spain, but...
16:17:06 <tensorpudding> maybe Haskell is less popular in those countries?
16:17:08 <dafis> bnery: maybe, maybe not, sleeping, hacking, drinking, who knows, it's weekend
16:17:22 <bnery> dafis :) maybe
16:17:36 <kmc> there are definitely some germans and italians here
16:17:40 <bnery> tensorpudding you have a point. Micro#oft stuff is more popular here
16:17:51 <bnery> and on the good side, ruby
16:17:51 <kmc> the main GHC developers work for Microsoft
16:17:53 <tensorpudding> ocaml might be more popular in france
16:17:54 <kmc> in the UK
16:18:06 <gwern> hm... what's a good synonym for 'fearful' that starts with a 'c'? cowardly comes to mind
16:18:09 <kmc> "regular programmers, being awake during the night" -- this works only if they don't have jobs
16:18:15 <bnery> ocaml is really popular in france, I had profs there who developed the language :)
16:18:29 <bnery> kmc well, it's a weekend
16:18:46 <gwern> kmc: no, even regular programmers chug enough caffeine to stay awake most of the time
16:18:50 <kmc> true, but a lot of people won't shift sleep schedule by 180° just at the weekend
16:18:52 <bnery> kmc working for Microsoft is diferent than developing a language called H#
16:18:56 <MoALTz> sometimes i wish there were more part-time programming jobs
16:18:58 <gwern> on a side note, I've been playing with refined caffeine. it's nice
16:19:02 <kmc> bnery, yeah
16:19:03 <tensorpudding> Microsoft has F#
16:19:18 <bnery> yeah, really.. I heard of that, tensorpudding
16:19:26 <bnery> why is it caled F#? anything to do with FOrtran?
16:19:31 <tensorpudding> no
16:19:35 <tensorpudding> F for functional
16:19:35 <kmc> f for functional probably
16:19:40 <Biggles> what *is* F#
16:19:41 <bnery> good poing kmc
16:19:45 <tensorpudding> and for correspondence with C#
16:19:48 <dafis> Focktothorpe
16:19:56 <kmc> F# is an OCaml-like language
16:20:06 <tensorpudding> it's an OCaml-like language that ties in to the CLR
16:20:11 <kmc> it's first-tier supported on .NET and can interoperate with the .NET libraries
16:20:17 <Biggles> the only 'functional programming' course at my uni teaches it using C# :|
16:20:20 <bnery> Biggles http://en.wikipedia.org/wiki/F_Sharp_(programming_language)
16:20:25 <kmc> Biggles, could be worse: C++ or Java
16:20:40 <kmc> C# has some cool FP features that look a lot like things Haskell or Lisp had decades ago
16:20:41 <tensorpudding> F# has monad in it
16:20:44 <tensorpudding> monads*
16:20:48 <bnery> kmc or x86 ASM
16:21:27 <bnery> tensorpudding "Sequence expressions are generalized as Computation Expressions which are equivalent to monads"
16:21:28 <jmcarthur> Biggles: beats what mine had... nothing
16:21:41 <tensorpudding> Yes, they use a messy name for it
16:21:53 <kmc> bnery, but "monad" is a scary word.  better to call it something vague so everyone comes in with a bunch of misconceptions
16:22:03 <kmc> FP in ASM isn't that bad -- building closures isn't particularly *harder* than doing anything else
16:22:08 <dafis> Warm Fuzzy Thing
16:22:09 <tensorpudding> kmc: like people don't have misconceptions using the name monad?
16:22:14 <jmcarthur> kmc: computations!
16:22:25 <Biggles> Friendad
16:22:31 <bnery> kmc I like monad, but I still don't get it quite right :) - I still have to have time (and a clear head) to study it
16:22:34 <jmcarthur> tubes!
16:22:41 <bnery> kmc I mean I like the name 'monad'
16:22:42 <Biggles> DudeChunk
16:22:48 <tensorpudding> tubes sounds more like concurrency
16:22:49 <dafis> KleisliTriples
16:23:03 <bnery> maybe pipes?
16:23:14 <bnery> or ford?
16:23:17 <tensorpudding> pipes sound like function composition
16:23:19 <dafis> fnord
16:23:32 <tensorpudding> quarks?
16:23:32 <kmc> tensorpudding, yeah, it's self-defeating... since Haskell uses the weird name, there's a bunch of uninformed blognoise about it, so people get misconceptions from that
16:23:34 <kmc> you can't win
16:23:44 <Biggles> maybe an animal name
16:23:49 <kmc> tachyons
16:23:51 <riboflavin> anyone know how I could make (length xs)/2 into an Int? Apaprently it returns a "Fractional Int" which won't be accepted as an int argument, and calling floor on it doesn't help, because that returns a 
16:23:58 <riboflavin> "ReaFrac Int"
16:24:04 <dafis> riboflavin: quot, div
16:24:13 <tensorpudding> the last thing we need haskell to sound like is treknobabble
16:24:14 <dafis> length xs `quot` 2
16:24:14 <dmwit> length xs `div` 2
16:24:17 <kmc> div is the function for integer division
16:24:24 <riboflavin> oh, ok, tahnks
16:24:27 <riboflavin> thanks*
16:25:22 <dafis> > ((-7) `quot` 2, (-7) `div` 2)
16:25:22 <lambdabot>   (-3,-4)
16:25:32 <Cale> riboflavin: Depending on what you're doing, it might be a good idea to try to avoid the length function altogether though.
16:25:55 <dmwit> > (-7 `quot` 2, -7 `div` 2) -- for ultimate newbie confusion
16:25:56 <lambdabot>   (-3,-3)
16:26:00 <Cale> heh
16:26:17 <dmwit> I've probably made that mistake three or four times by now.
16:26:29 <riboflavin> Cale: I am trying to split a list into 2 lists of equal (or 1 diffent) length, and I am using the take and drop functions to to the splitting
16:26:43 <Cale> (remember that quot and div have to do with multiplicative structure, and so they bind more tightly than negation, which is related to additive structure)
16:26:50 <aristid> i wonder if haskell code completion in emacs would be difficult to achieve
16:26:58 <dafis> riboflavin: splitAt
16:27:05 <dafis> :t splitAt
16:27:06 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:28:06 <jmcarthur> i guess somebody might be able to reasonably call monads "contexts"
16:28:10 <riboflavin> dafis: it is for a homework assignment (implementing mergesort) and I am pretty much told to use take and drop, so I don't think that will be accepted, even though it is exactly what I want
16:28:16 <bnery> what is the difference between div and quot?
16:28:34 <jmcarthur> but then comonads also fit that name in a different way i guess
16:28:35 <dafis> bnery: quot truncates and is faster, div floors
16:28:45 <Cale> truncates?
16:29:00 <Cale> Oh, I see, yes, you can think of it that way
16:29:02 <dafis> towards zero
16:29:11 <jmcarthur> one goes to zero, the other to negative infinity
16:29:16 <ClaudiusMaximus> > partitionEithers . zipWith ($) (cycle [Left, Right]) $ "one two three"
16:29:18 <lambdabot>   ("oetotre","n w he")
16:29:18 <jmcarthur> s/to/toward/
16:29:25 <bnery> dafis example of different result?
16:29:31 <Cale> Though there's really no fractional number representation
16:29:42 <dafis> bnery: divide a negative number by a positive
16:29:44 <jmcarthur> bah
16:29:51 <Cale> > (-1) `rem` 3
16:29:51 <lambdabot>   -1
16:29:54 <Cale> > (-1) `mod` 3
16:29:55 <lambdabot>   2
16:29:59 <dafis> > ((-7) `quot` 3, (-7) `div` 3)
16:30:00 <Cale> > (-1) `quot` 3
16:30:00 <lambdabot>   (-2,-3)
16:30:01 <lambdabot>   0
16:30:07 <Cale> > (-1) `div` 3
16:30:08 <lambdabot>   -1
16:30:26 <Cale> quot and rem go together
16:30:32 <Cale> and div and mod go together
16:31:00 <lispy> > (-1) `divMod` 3
16:31:01 <lambdabot>   (-1,2)
16:31:05 <bnery> with the () on the negative number I see :)
16:31:11 <lispy> > (-1) `quotRem` 3
16:31:12 <lambdabot>   (0,-1)
16:31:32 <Cale> bnery: Yeah, that's important because all these functions bind more tightly than negation
16:31:34 <bnery> quot = quotient, rem = remainder - what does mod stand for?
16:31:42 <Cale> modulus
16:31:46 <dafis> bnery: modulus
16:31:50 <Cale> (another name for remainder)
16:32:05 <bnery> dafis weird thing is that in portuguese 'módulo' stands for absolute value XD
16:32:40 <dafis> bnery: in english, there's 'absolute modulus', with absolute omitted sometimes
16:32:51 <bnery> dafis = http://en.wikipedia.org/wiki/Modular_arithmetic
16:33:25 <Cale> In English, when we say that some equation A = B holds "modulo 7" it means that A - B is a multiple of 7
16:33:49 <dmwit> :t chunk
16:33:50 <lambdabot> Not in scope: `chunk'
16:33:54 <dafis> In Romania, speech was free modulo Securitate
16:33:55 <dmwit> :t Data.List.chunk
16:33:56 <lambdabot> Not in scope: `Data.List.chunk'
16:34:03 <dmwit> :t Data.List.Split.chunk
16:34:04 <lambdabot> Couldn't find qualified module.
16:34:10 <dmwit> ah well
16:34:16 <Taejo> I've never heard "absolute modulus" but "modulus" for me means absolute value, especially of a complex number. In fact, I wouldn't use "absolute value" for a complex number, only "modulus"
16:34:25 <dafis> dmwit: what are you looking for?
16:34:46 <dmwit> ?let chunk n [] = []; chunk n xs = take n xs : chunk n (drop n xs)
16:34:47 <lambdabot>  Defined.
16:34:48 <Cale> Yeah, there's modulus of a complex number, which is another thing again :)
16:34:48 <dafis> Taejo: I've read it in a couple of books
16:35:05 <dafis> dmwit: Data.List.Split.splitEvery
16:35:06 <dmwit> > let f xs = zipWith const xs (chunk 2 xs) in f [1..30]
16:35:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
16:35:15 <dmwit> > let f xs = zipWith const xs (chunk 2 xs) in f [1..31]
16:35:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
16:35:23 <bnery> dmwit => http://www.haskell.org/haskellwiki/Data.List.Split <= go to the end
16:35:26 <dmwit> There we go, and properly lazy to boot.
16:36:13 <dmwit> dafis, bnery: It's also called... (wait for it...) chunk.
16:36:16 <dmwit> surprise!
16:36:30 * lispy waits for it
16:36:38 <dafis> dmwit: in that module?
16:36:42 <dmwit> yep
16:36:59 <freedrull> parseFromFile takes a SourceName as its second argument. How do I get a SourceName ?
16:37:00 <bnery> well guys gotta go
16:37:02 <bnery> GMT here
16:37:09 <bnery> c u
16:37:12 <dafis> freedrull: just give it any
16:37:19 <Cale> Anyway, div and mod usually have the behaviour you want. x `mod` n always lies between 0 and n-1 when n is positive, and between n+1 and 0 when n is negative
16:37:20 <dafis> freedrull: "" is fine
16:37:22 <Lemmih> freedrull: It's just a String.
16:37:38 <freedrull> Lemmih: dafis ah
16:38:30 <dafis> Cale: I'd want x `mod` n to be in [0 .. |n| -1] always
16:38:54 <lispy> dafis: there are times when -n/2 .. n/2 makes more sense
16:39:16 <lispy> (I'm being lazy with the +/- 1 there)
16:39:36 <dafis> lispy: is more convenient, makes the same amount of sense
16:39:49 <Cale> dafis: That's easily obtained by applying an absolute value to n beforehand
16:40:06 <lispy> they're all isomorphic if taht's what you mean by making the same amount of sense
16:40:33 <Cale> There are too many variations of integer division :)
16:41:07 <dafis> Proposal: the result of every integer division shall henceforth be 73
16:41:18 <lispy> dafis: that should optimize well
16:41:27 <dafis> yup
16:41:56 <lispy> > let _ `div` _ = 37 in undefined `div` undefined
16:41:57 <lambdabot>   37
16:42:21 <aristid> lispy: you made a cardinal implementation mistake.
16:42:39 <Cale> dafis: That is going to revolutionise the solution of Diophantine equations.
16:42:39 <lispy> hehe
16:42:43 <lispy> aristid: bad pun!
16:42:51 <lispy> aristid: or did you mean that it works for non-integers too?
16:42:57 <dafis> Cale: and makes finding primes much faster
16:43:05 <aristid> lispy: i mean that you used 37 instead of 73
16:43:10 <lispy> oh
16:43:25 <lispy> aristid: I'm a member of the DNA, National Dyslexics Association today :)
16:43:26 <aristid> lispy: but i guess the "cardinal" was a kind of pun
16:43:48 <aristid> lispy: that's the french association, right?
16:44:38 <lispy> Is it German where you say numbers like 123 as one-hundred 3 and twenty
16:44:52 <dafis> lispy: among other languages
16:45:35 <dafis> lispy: even in english, one *can* say one-hundred three and twenty, but it's pretty archaic
16:46:02 <Cale> "And you thought numbers in English were crazy"
16:46:36 <dafis> In all my thrre score and ten years not
16:46:43 <dafis> three
16:46:46 <conal> aristid: hah!
16:47:57 <Cale> three and twenty blackbirds
16:48:04 <aristid> lispy: 123 is einhundertdreiundzwanzig, "one hundred three and twenty"
16:48:17 <Cale> (which is one too few)
16:48:29 <dafis> I eated it
16:48:38 <aristid> dafis: you ated the birdie?
16:48:43 <Cale> 百二十三
16:48:48 <Cale> So much more sensible
16:48:51 <dafis> me hungry
16:51:01 <Cale> (hundred)(two)(ten)(three)
16:51:26 <Lemmih> Cale: How do you type chinese characters, OOI?
16:51:38 <aristid> Cale: 123 <- even more sensible
16:51:57 <Cale> aristid: Well, the pronunciation goes that way
16:52:09 <Cale> Lemmih: IBus + Anthy
16:52:41 <mtnviewmark> anyone here at SupperHappyDevHouse 40 right now?
16:53:00 <Cale> Lemmih: Basically, I turned on Japanese input support in Ubuntu
16:53:36 <Cale> Lemmih: and I type roumaji and it gets converted
16:56:32 <Lemmih> Do the Japanese use Chinese characters for their numbers?
16:56:41 <Cale> Yes
16:56:46 <p_l> Lemmih: not exactly Chinese, but yes
16:56:55 <p_l> ("old" chinese, you could say)
16:57:03 <Cale> When they don't use "Arabic" numerals like us.
16:57:36 <p_l> also they have logical, decimal system for counting, unlike some crazies you can encounter in the west
16:57:37 <tolkad> Can you write class instances for rank 2 types?
16:57:50 <p_l> (which resulted in further weirdness like imperial units)
16:58:04 * Lemmih doesn't read any Japanese but knew enough written Chinese to understand what Cale wrote.
16:58:56 <Lemmih> Hm, and now my English is deteriorating. Better go to sleep.
16:59:05 * p_l got mad from learning german. Japanese was easier
16:59:06 <tolkad> I want to write a class instance for a rank 2 type and I'm wondering if that is possible
16:59:19 <dolio> No.
16:59:42 <tolkad> not even with an extension?
16:59:47 <dolio> Nope.
17:00:01 <tolkad> why not?
17:00:03 <dolio> The only way I know how to do it is to wrap it in a datatype.
17:00:06 <dafis> p_l: learning German is easy, where I live, the small children have no problem learning it
17:00:07 <Cale> tolkad: Seems not, however, you can newtype wrap it and write an instance for the newtype
17:00:27 <tolkad> Cale: oh, thanks
17:00:45 <p_l> dafis: small children will learn any language, no matter how nonsensical
17:00:49 <ManateeIrcClient> Morning all ! :)
17:01:01 <dafis> p_l: True :)
17:01:18 <dafis> morning ManateeIrcClient 
17:01:20 <Cale> ManateeIrcClient: We were just talking about how numbers in Chinese and Japanese are pronounced so much more sensibly than numbers in English :)
17:01:59 <ManateeLazyCat> Cale: Hehe: 一 二 三 四 五 ..... one two three four five ....
17:02:11 <mtnviewmark> p_l: actually, true of programmers, too!
17:02:22 <dafis> yksi kaksi kolme
17:02:32 <Cale> ManateeIrcClient: The funny part is when you get up to eleven
17:02:48 <ManateeLazyCat> Cale: Yep, 十一
17:03:23 <ManateeLazyCat> Cale: 十 mean ten 一 mean one, then eleven is "ten + one" .:)
17:03:35 <Cale> 十一 is so much more modular and sensible, no matter which pronunciations you choose for each character, as long as they're consistant :)
17:03:52 <Cale> *cough* consistent
17:03:55 <ManateeLazyCat> Cale: Chinese and Japanese use modular design, never waste space. :)
17:03:55 <wolfwood> IXII
17:04:16 <dafis> wolfwood: not correct
17:04:29 <Lemmih> I find it really difficult to hear the difference between 10 and 11 in Mandarin.
17:04:30 <pikhq> ManateeLazyCat: Ah, Chinese/Japanese numerals.
17:04:37 <ManateeLazyCat> Cale:  101 mean 一百零一
17:05:04 <pikhq> ManateeLazyCat: In Japanese, just 百一.
17:05:16 <ManateeLazyCat> pikhq: Good to know . :)
17:05:35 <ManateeLazyCat> Lemmih: Not hard. :)
17:05:48 <pikhq> Not a *big* difference, but it's rather nice to omit things like that.
17:05:54 <ManateeLazyCat> Lemmih: Just add "Yi" after "Shi", then is "Shi Yi"
17:06:00 <tolkad> Cale: wait that wont work
17:06:08 <Cale> tolkad: oh?
17:06:24 <tolkad> Cale: I want to use a class to pattern match on rank 2 types
17:06:32 <tolkad> except pattern matching at the type level
17:07:27 <Cale> tolkad: Hmm, perhaps you could explain what your overall goal is?
17:07:46 <tolkad> Cale: I just wanted to do that to see if it was possible
17:08:00 <Lemmih> ManateeLazyCat: To me the two sounds are so similar that they merge easily.
17:08:32 <pikhq> Lemmih: You'd probably find the Japanese readings easier, then. "jū ichi".
17:08:40 <pikhq> Not that that helps you with Mandarin, but hey.
17:08:57 <tolkad> Cale: I guess not then. someone told me haskell doesn't have the equivalent of instanceof on types and I wanted to see if maybe it really did
17:09:13 <Cale> http://hpaste.org/30184/cale (lol, got the author and paste name fields backward)
17:09:41 <dmwit> instanceof isn't needed, since all types are known at compile time.
17:09:43 <Cale> What does instanceof do?
17:09:57 <dmwit> a instanceof C checks if the class that a instantiates is a subclass of C.
17:10:00 <Lemmih> pikhq: I lost all interest in learning Japanese after I read "Surely you're joking, Mr Feynman." (:
17:10:25 <pikhq> Lemmih: Which bit was that again?
17:10:29 <dmwit> The one exception to "all types are known at compile time" is existentials.
17:10:34 <dmwit> Have you been playing with them?
17:10:49 <tolkad> dwit: Rank 2 types can't be known at compile time
17:11:01 <tolkad> dmwit: yeah I wanted to use then to implement instanceof
17:11:16 <Lemmih> pikhq: Feynman tried to learn Japanese but got mad and gave up. Can't remember where in the book it was.
17:11:37 <pikhq> Lemmih: I don't recall that... Hrm.
17:11:46 <pikhq> Lemmih: BTW: Japanese is really not *that* hard.
17:12:19 <pikhq> The only obnoxiously hard bit is the many-to-many relationship between characters and readings.
17:12:29 <Cale> tolkad: It doesn't make sense in Haskell since Haskell has no subtyping
17:12:39 <ManateeLazyCat> Lemmih: Once you understand Chinese, it's hard to *forgot*, because Chinese character like Picture store in your mind, instead "character sequence" 
17:13:19 <luite> hmm, my picture store must not work very well then :(
17:13:19 <pikhq> ManateeLazyCat: 覚え易しい！
17:13:47 <ManateeLazyCat> pikhq: Yes.
17:15:11 <Cale> pikhq: Of course, English has a similar many to many relationship with respect to pronouncing words.
17:16:00 <dafis> pikhq: the thing that drove Feynman mad was that you have to use different words for the same thing, depending on who you talk to
17:16:20 <Cale> The way I tackle it is just to learn how words are pronounced and not worry too much about studying readings of individual characters for now.
17:16:26 <dmwit> That does sound rather contrary to Feynman's style, doesn't it?
17:17:51 <Lemmih> pikhq: http://blog.lucylou.info/post/966986488/richard-feynman-on-learning-japanese
17:18:29 <pikhq> Lemmih: Not as hard as you'd think, just a bit weird.
17:18:46 <pikhq> Cale: Yeah, I've just said "screw it, I'm learning words and letting my brain pick up on patterns."
17:19:07 <pikhq> I'm presuming I can unintentionally pattern match far better than I can intentionally. ;)
17:19:08 <kdridi> hi
17:19:17 <Cale> hi
17:19:29 <roconnor> hi
17:20:19 <dmwit> 'lo
17:20:49 <Cale> おっす
17:21:10 <dmwit> salom
17:21:23 <dafis> bienvenu welcome willkommen
17:21:33 <luite> welkom
17:21:49 <roconnor> 안녕안녕안녕안녕안녕안녕
17:21:55 <dmwit> hola
17:21:57 <Lemmih> Jamen, så goddag da.
17:22:05 <dmwit> moin
17:22:14 <Cale> שלום
17:22:15 <roconnor> hm
17:22:22 <Saizan> korean looks a lot more like an alien language
17:22:23 <roconnor> why did I just get a square
17:22:46 <Cale> roconnor: on which line?
17:23:06 <roconnor> [20:10] <roconnor> 안녕
17:23:13 <dafis> Hummel Hummel
17:23:18 <roconnor> I just see a square :(
17:23:34 * ManateeLazyCat I'm develop "multiple language discuss" module, i'm sure i can say any language later, maybe Mars language. :)
17:23:39 <Lemmih> roconnor: I see korean characters.
17:23:41 <Saizan> your font lacks the glyph, i presume
17:25:45 <mikeg> is there a better way to write this function? I'm sort of a haskell-noob and using the few tools i know (fmap, bind): unixTime = getClockTime >>= (fmap $ formatCalendarTime defaultTimeLocale "%s") . toCalendarTime
17:27:55 <Taejo> Saizan: does the alien impression come from those two syllables or Korean script in general?
17:28:05 <Saizan> formatCalendarTime defaultTimeLocale "%s" <$> (getClockTime >>= toCalendarTime)
17:28:32 <Saizan> Taejo: i think it's the frequency of circles
17:29:05 <dafis> Saizan: Ever tried burmese? (I think it was that)
17:29:13 <Taejo> So "김치 먹어요" is less alien?
17:29:35 <Cale> fmap (\(TOD x y) -> show x) getClockTime
17:29:36 <mikeg> awesome, thanks. i need to go read the lyahfgg guide on <$> and <*>
17:29:43 <Cale> Though I'm not sure how portabble that is
17:29:44 <dmwit> Taejo: looks like a circuit diagram
17:29:47 <Cale> portable*
17:29:52 <dmwit> Taejo: (still quite alien-looking to me)
17:30:10 <dmwit> Maybe the second character looks human.
17:30:38 <Peaker> I'm reading Beginners' Haskell books so I know what to use with a Syllabus.. A bit boring :)
17:30:45 <roconnor> mikeg: <$> is essentially fmap (infix)
17:30:51 <roconnor> mikeg: and <*> is ap
17:31:18 <mikeg> mhmm ok. how does Cale's work? what is "TOD" ?
17:31:18 <Taejo> dmwit: the "characters" are syllables made up of consonant letters like ㄱ, ㅁ, ㅎ, ㅊ and vowel letters like ㅜ, ㅔ, ㅑ
17:31:19 <Peaker> "Programming in Haskell" seems better than "School of Expression", though the latter has nicer examples
17:31:22 <Saizan> yeah, i'm with dmwit, but i guess the font could also be part of the reason
17:31:31 <Cale> mikeg: TOD is the data constructor for ClockTime values
17:32:03 <Cale> mikeg: I'm relying on the fact that the internal representation of a ClockTime consists of the unix time together with an additional number of picoseconds
17:32:34 <mikeg> oh, i see. Saizan's solution is probably a bit safer then :)
17:32:37 <Cale> In Haskell 98, the ClockTime type is abstract
17:32:44 <Cale> But GHC exposes the constructor
17:32:51 <Taejo> inconcievable! I need zettosecond accuracy
17:33:14 <roconnor> Cale: wouldn't it be better to use the 
17:33:15 <roconnor> Fields
17:33:17 <roconnor> utctDay
17:33:18 <roconnor> er
17:33:32 <roconnor> Cale: wouldn't it be better to use the utctDay projection function
17:33:42 <dmwit> Taejo: If your machine can measure zettoseconds, your values will have zettosecond accuracy... just not zettosecond precision. ;-)
17:33:45 <Cale> Let's just use the number of Planck times since the big bang.
17:33:52 <roconnor> Cale: oh you are use old-time ?
17:34:14 <Cale> roconnor: mikeg used the getClockTime function from System.Time
17:34:27 <Cale> Which I guess is in the old-time package
17:34:36 <roconnor> Cale: different parts of the universe are at different ages depending on how much gravity is around
17:34:53 <mikeg> yes, it is. should i be moving to new-time?
17:35:00 <roconnor> mikeg: ah, mike get with the times.  Data.Time.getCurrentTime :: IO UTCTime
17:35:05 <dafis> roconnor: I'm 43 in the morning and 56 in the evening :)
17:35:53 <mikeg> thanks again for the help :)
17:41:17 <ManateeIrcClient> Wait #haskell hot again, then i can post new irc client screenshot. :)
17:41:59 <ManateeLazyCat> Much readable when i change background to dark color. :)
17:46:01 <ManateeLazyCat> This is my style : http://www.flickr.com/photos/48809572@N02/5002943968/lightbox/ much readable . :)
17:46:26 <jbauman> @pl \a b -> (foldl id (.) a) b
17:46:27 <lambdabot> foldl id (.)
17:46:33 <jbauman> heh
17:53:35 <tolkad> http://haskell.org/haskellwiki/Bottom
17:53:35 <tolkad> Why does it say without undefined haskell would not be turing complete?
17:54:16 <Cale> tolkad: Because every computation would terminate
17:54:17 <dmwit> If you can't express an infinite loop, your language isn't Turing complete.
17:54:55 <tolkad> every computation wouldn't terminate, without undefined «f x = f x» still typechecks
17:55:32 <tolkad> I didn't use undefined anywhere in there
17:55:32 <tolkad> and
17:55:35 <Cale> tolkad: That is a definition for bottom for function types
17:55:36 <Saizan> that page is not saying you need Prelude.undefined
17:56:00 <Cale> tolkad: You can be more general about it and define x = x
17:56:22 <Cale> undefined = undefined -- the ability to make this definition is what they're talking about
17:57:37 <tolkad> Cale: if bottom was a member of any type you could just figure out whether an expression terminates by pattern matching for bottom
17:57:52 <tolkad> let's try it
17:57:53 <Cale> You can't pattern match for bottom
17:57:55 <tolkad> @let x = x
17:57:56 <lambdabot>  <local>:3:4:
17:57:56 <lambdabot>      Ambiguous occurrence `x'
17:57:56 <lambdabot>      It could refer to either `L....
17:58:27 <tolkad> Cale: ok I think I understand bottom now
17:58:29 <Cale> Because there's no pattern which successfully matches it.
17:58:46 <Cale> Except those which match anything
17:58:57 <djahandarie> Cale, what do you think about having another prefix (like # or something) for a vanilla mueval instance on lambdabot?
17:59:12 <tommd> Cale: Sure there are.  If you have bottom you will eventually see a programmer banging his head against the wall.  Its a very strong pattern.
17:59:12 <tolkad> hmm I am going to try something
17:59:14 <Cale> djahandarie: I wouldn't mind it
18:00:05 <Cale> tommd: But that pattern always matches ;)
18:01:35 <tolkad> uh how do I pattern match on functions?
18:01:56 <tolkad> wait nevermind
18:02:41 <tolkad> Cale: so you could do «uTerminates () = True; uTerminates _ = False»
18:02:53 <tolkad> @let uTerminates () = True
18:02:54 <lambdabot>  Defined.
18:02:57 <tolkad> @let uTerminates _ = False
18:02:58 <lambdabot>  <local>:3:0:
18:02:58 <lambdabot>      Warning: Pattern match(es) are overlapped
18:02:59 <lambdabot>               In...
18:03:03 <Cale> @undefine
18:03:14 <Cale> @let uTerminates () = True; uTerminates _ = False
18:03:15 <lambdabot>  <local>:1:0:
18:03:15 <lambdabot>      Warning: Pattern match(es) are overlapped
18:03:15 <lambdabot>               In...
18:03:37 <Cale> > uTerminates ()
18:03:39 <lambdabot>   Not in scope: `uTerminates'
18:03:49 <Cale> heh
18:04:02 <tolkad> if it let you do that you could solve the halting problem!
18:04:31 <Cale> I guess it doesn't like making definitions with warnings :P
18:04:42 <Cale> > let uTerminates () = True; uTerminates _ = False in uTerminates ()
18:04:43 <lambdabot>   True
18:04:43 <tolkad> Cale: all we have to do is implement pattern matching overlap checking
18:04:46 <Cale> > let uTerminates () = True; uTerminates _ = False in uTerminates undefined
18:04:47 <trinithis> Can anyone point me to a Text.PrettyPrint tutorial?
18:04:47 <lambdabot>   *Exception: Prelude.undefined
18:05:05 <Cale> tolkad: Matching _|_ against the pattern () yields _|_
18:05:17 <tolkad> Cale: well we would have to change that too
18:05:25 <tolkad> Cale: and we can solve the halting problem
18:05:45 <tolkad> just make it so matching against _|_ fails
18:06:09 <Cale> heh
18:06:29 <Cale> Just go on and try the next pattern after waiting potentially forever for termination ;)
18:06:30 <tolkad> I'm kidding :P
18:07:58 <Cale> http://cm.bell-labs.com/cm/cs/who/wadler/papers/prettier/prettier.ps
18:08:04 <Cale> errr
18:08:08 <Cale> sorry, that link is dead
18:08:09 <aristid> @src permutations
18:08:10 <lambdabot> Source not found. Do you think like you type?
18:08:15 <aristid> *grml*
18:08:25 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
18:09:21 <Cale> trinithis: ^^ that essentially documents the wl-pprint package on Hackage
18:09:28 <trinithis> ok
18:09:44 <Cale> http://hackage.haskell.org/packages/archive/wl-pprint/1.0/doc/html/Text-PrettyPrint-Leijen.html
18:16:11 <aristid> @oies 1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800
18:16:12 <lambdabot>  Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number ...
18:16:12 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
18:22:04 <Cale> We can define the cardinality of a groupoid (category all of whose arrows are invertible) to be the sum over isomorphism classes of objects of 1/(the number of automorphisms of an object in that class). This means that a discrete category gets the usual cardinality of its set of objects. Then e is the cardinality of the category of sets and bijections.
18:22:44 <djahandarie> That came out of nowhere...
18:23:03 <Cale> It was inspired by the oeis search :)
18:24:24 <Cale> The symmetric groups S_n are the automorphism groups of representatives of each of the isomorphism classes of the category of sets and bijections.
18:25:02 <Cale> and so by summing 1/|S_n|, which is 1/n! for each n, we obtain the cardinality of that category
18:25:04 <Cale> which is e
18:26:01 <FunctorSalad> I just stumbled in... why'd you want to do that?
18:26:05 <FunctorSalad> (sum these)
18:26:13 <Cale> <Cale> We can define the cardinality of a groupoid (category all of whose arrows are invertible) to be the sum over isomorphism classes of objects of 1/(the number of automorphisms of an object in that class). This means that a discrete category gets the usual cardinality of its set of objects. Then e is the cardinality of the category of sets and bijections.
18:26:31 <FunctorSalad> ah :)
18:27:49 <FunctorSalad> what's the motivation for that definition of 'cardinality'?
18:28:07 <Cale> If you think about it, this is a natural sort of definition to make if we want to define fractional cardinalities -- what is it that makes 1/3 of an apple what it is? It's that the piece belongs to a group of 3 symmetries of the apple.
18:29:00 <Cale> Err...
18:29:06 <Cale> That wasn't very nicely stated :)
18:32:24 <Cale> But the idea is basically that when we cut something into fractions, we're somehow counting a particular group of symmetries of that object. (Perhaps a subgroup of all the symmetries we'd normally consider)
18:33:29 <FunctorSalad> but why the reciprocal?
18:34:10 <FunctorSalad> (just curious what the deeper meaning of the 'e' here is :))
18:34:11 <Cale> Well, 1/3 for 3 symmetries that send our piece of apple to each of the places it fits in the whole apple
18:36:39 <Cale> I suppose it sort of measures how much unique "stuff" is there, after dividing out the symmetries
18:38:11 <Cale> Because {0,...,n-1} has n! symmetries with itself, we only count it as 1/n! toward the total. This even though it's hard to say exactly what 1/n! of that set really "is".
18:45:43 <Cale> FunctorSalad: Actually, a good way to look at it is shown on the third page of http://math.ucr.edu/home/baez/groupoidification.pdf
18:47:03 <Cale> The couple of diagrams there probably explain the concept better than most words could :)
18:47:52 <FunctorSalad> funny :)
18:51:22 <FunctorSalad> though (without being qualified to speak about it in any way) I'm slightly skeptical of this avoiding equality and avoiding decategorification stuff
18:52:01 <FunctorSalad> we made the abstraction from sheep herds cardinalities to natural numbers for a reason, didn't we? :o
18:52:28 <FunctorSalad> (simpler)
18:53:29 <FunctorSalad> I can see how it could give some theorems more intuitive meaning though
18:53:34 <Cale> Well, this is just revisiting how we made the abstractions in the first place in order to generalise to a new setting. After we've decided on what we'd like it to be, the cardinality of a groupoid can be defined by fiat :)
18:56:23 <FunctorSalad> fair enough (about the new setting)
19:02:32 <Cale> http://cale.yi.org/share/5over3.png
19:02:35 <Cale> ^^ another example
19:02:52 <Cale> An action of Z/3 on {1,2,3,4,5}
19:02:52 <luite> nice drawing
19:03:57 <Cale> My new mouse is more jittery than my old one :)
19:07:10 <ManateeLazyCat> Have any library for "Google Translate" ? :)
19:11:00 <FunctorSalad> wget? o_O
19:11:03 <djahandarie> 谷歌翻譯實在是不太好。
19:11:55 <ManateeLazyCat> djahandarie: Infact, ^^^ above translation is good.
19:12:04 <djahandarie> :P
19:12:56 <ManateeLazyCat> If noone do that, i will build a new package 'google-translate' :)
19:13:46 <tensorpudding> a library that links into google's translation service?
19:15:22 <ManateeLazyCat> tensorpudding: Yeah, when you give source-language dest-language, will give you result by Google translate. :)
19:15:35 <ManateeLazyCat> tensorpudding: Just ask here make sure not do duplicate work. :)
19:16:54 <rothwell> if their translation service is anything like their search service, it'll start rejecting requests after a few
19:17:24 <rothwell> think they demand you go through their published api for searches, not sure if there's anything comparable for translation
19:17:43 <ManateeLazyCat> rothwell: I just use it translate user's input, won't translate irc message from irc server. :)
19:18:22 <rothwell> ManateeLazyCat: hehe, yeah. what i mean, though, is you might find you can't do it much...
19:18:30 <rothwell> as in, four or five times will trip the limit
19:18:50 <rothwell> it's been a couple of years since i tried, maybe things are different these days
19:19:29 <ManateeLazyCat> rothwell: Google search reject rule is stupid, when i use vimum (keyboard extension) on Google page, google told me i use computer program search result..... damn it stupid bot...
19:19:44 <rothwell> yep
19:20:42 <ManateeLazyCat> rothwell: I doubt Google have code trace user's mouse action, when you don't use mouse and search fast, it consider you're bot.....
19:22:12 <jmr> hello
19:22:17 <Cale> hello
19:22:20 <ManateeLazyCat> jmr: Hello
19:22:55 <jmr> i am new to this haskell
19:23:14 <Cale> jmr: Feel free to ask any questions you might have. Beginners are always welcome here.
19:23:29 <jmr> i am in step 4 right now
19:23:34 <jmr> i am following directions
19:23:35 <ManateeLazyCat> jmr: This is most friendly channel in this world . :)
19:23:36 <jmr> i love this
19:23:55 <jmr> i was  a math major in college
19:23:57 <jmr> :)
19:24:06 <jmr> and CS courses were never this interactive
19:24:10 <moosefish> Is there any other 'canonical' int16,32,64 than the ones in Data.Int?
19:24:40 <moosefish> I've just rebuilt the thrift mappings for haskell, I just want to double check your average Haskell library would use Data.Int for fixed length types.
19:24:43 <roconnor> moosefish: there might be some larger word sizes in the crypto libs
19:25:07 <moosefish> those 3 are the only ones supported by thrift, so longer doesn't matter much here
19:25:17 <moosefish> (well, it also supports a byte type, which I mapped to Data.Word.Word8)
19:26:04 <roconnor> moosefish: yes, people use Data.Int for fixed size ints
19:26:51 <jmr> wow i like the let x =4 feature
19:26:57 <jmr> it's like i am writing a prof
19:27:00 <jmr> proof*
19:27:01 <jmr> hahahaha
19:27:02 <jmr> :)
19:27:07 <ManateeLazyCat> Maybe i can develop some program like Google Speak in Android, talk message in irc client, so lazy! :)
19:27:11 <Cale> Yeah, and 'where'
19:27:43 <Cale> f x y = sqrt d
19:27:45 <Cale>     where d = x^2 + y^2
19:27:45 <ManateeLazyCat> Maybe make become core module, talk everywhere, don't need type type type ... :)
19:27:50 <luite> jmr: are you using tryhaskell?
19:28:03 <jmr> yes luite
19:28:34 <jmr> this is sweet.
19:29:00 <jmr> i am not thinking like a computer
19:29:05 <jmr> i make the computer think
19:29:28 <jmr> i like the tutorial with the villain 28 named chirs...
19:30:49 <jmr> i was trying out F# and clojure as well 
19:30:55 <aristid> i wrote a very simple list shuffler: http://hpaste.org/30186/simple_shuffler
19:31:29 <jmr> clojure is like (* (double 2.0), (double 3.0)))
19:31:38 <jmr> (ha(ha(ha)))
19:31:47 <moosefish> roconnor: Ok, so now should I prefer Data.ByteString.Lazy or Data.ByteString?
19:32:55 <moosefish> and for my personal edification -- why are there two versions -- "merely" different performance profiles?
19:33:12 <lispy> moosefish: one is lazy and one is strict
19:33:15 * hackagebot HsOpenSSL 0.8.0.1 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.8.0.1 (MasatakeDaimon)
19:33:24 <Cale> moosefish: They're different semantically too... Lazy ByteStrings can be infinitely long
19:33:25 <lispy> moosefish: so one can be used as streams and the other not so much
19:34:40 <Cale> moosefish: A lazy bytestring is a bit like a unix pipe -- it can go on forever, and is internally built up from strict bytestring chunks
19:35:28 <moosefish> right, sure. Reading the docs for the lazy ones they imply the Lazy version has better complexity/performance or is within a negligible delta of the strict versions
19:35:47 <ClaudiusMaximus> anyone recommend any libraries for triangular mesh manipulation? some things i want to do include: recursive subdivision, cellular automata, OpenGL visualization
19:35:51 <Cale> Yeah, but sometimes when you want strictness, the strict version is nice to have too.
19:36:00 <jmr> hey i wrote this geek poetry using Java http://tla.blogspot.com/2008/01/todays-tla-is-acs-art-or-computer.html
19:36:03 <moosefish> Any example springs to mind?
19:36:18 <moosefish> And more to the point -- any major libraries or codebases needing stricts?
19:36:45 <Cale> Particularly when you want to avoid lazy IO because you're reading in a file just before you're going to blow it away. If the reading of the file is deferred until you look at the string, you may have to jump through hoops to make sure you use it all before deleting or replacing the file.
19:36:59 <lispy> moosefish: lazy bytestring needs strict bytestring
19:37:23 <ClaudiusMaximus> the strict version guarantees (afaik) that the memory is contiguous, which is necessary when interacting with foreign code
19:37:30 <Cale> Oh, that's a good point
19:39:08 <aristid> do you think that simple list shuffler has good performance? ( http://hpaste.org/30186/simple_shuffler )
19:39:24 <Cale> Strict bytestrings also have more efficient splitting and random access
19:39:56 <jmr> wow filter (>5) [63,3,25,7,19]
19:40:04 <jmr> that's outstanding
19:40:22 <Cale> jmr: Yeah, higher-order functions are awesome
19:40:31 <jmr> can i do haskell and erlang?
19:40:34 <djahandarie> jmr, there are a lot of math people who use Haskell so I'm sure you'll feel at home
19:41:06 <jmr> (thank(you))
19:41:35 <moosefish> The sad thing is, I can't think of an easy way to have a set of thrift bindings have both lazy and strict ByteStrings inside.
19:41:48 <jmr> i like this
19:41:52 <moosefish> So this might be moot, I might have to commit to one or the other.
19:41:57 <moosefish> (sounds like lazy is the way to go)
19:42:13 <Cale> moosefish: Yeah, it's a common problem.
19:42:29 <freedrull> can i run main and provide an argument of type IO () in ghci?
19:42:33 <Cale> moosefish: Some libraries go about repeating work, or building abstractions over sequence types.
19:42:36 <jmr> in the past i have to think about bytes and writing read ahead and doing while loops for char by char and doing low leve l stufuff just to get a crappy xml file
19:42:54 <Cale> moosefish: It would be nice if Haskell had a parametric module system
19:43:07 <ClaudiusMaximus> :t System.Environment.getArgs
19:43:08 <lambdabot> IO [String]
19:43:16 <jmr> can this do caluclations similar to PARI?
19:43:17 * hackagebot HsOpenSSL 0.8.0.2 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.8.0.2 (MasatakeDaimon)
19:43:29 <moosefish> Cale: It'd be nice if I could just get the thrift codebase to not drive me up the walls. I suspect my main issue with doing both will be that.
19:43:42 <jmr> do people still use PARI?
19:44:00 <jmr> for a simple modulo calculator?
19:44:03 <aristid> Cale: local imports would be nice too.
19:44:34 <freedrull> main args::IO [String]
19:44:37 <freedrull> ?
19:44:53 <jmr> i just remember in cryptography class we used PARI for modulo arithmetic and elliptic curve cryptography.
19:45:25 <Cale> jmr: There are people who have written number theory libraries. It's not terribly extensive so far from what I've seen, but there are some things.
19:46:05 <jmr> I mean PARI was just a calculator, the real math/thinking was done on paper
19:46:15 <jmr> but that's awesome that Haskell is math friendly
19:46:30 <dmwit> freedrull: getArgs?
19:46:32 <dmwit> :t getArgs
19:46:33 <lambdabot> Not in scope: `getArgs'
19:46:43 <dmwit> ?hoogle IO [String]
19:46:44 <lambdabot> System.Environment getArgs :: IO [String]
19:46:44 <lambdabot> System.FilePath.Posix getSearchPath :: IO [FilePath]
19:46:45 <lambdabot> System.FilePath.Windows getSearchPath :: IO [FilePath]
19:46:45 <ClaudiusMaximus> freedrull: 'main :: IO ()', which you can run from ghci (depending on libraries not acting weird), and from 'main' you can call 'getArgs' to get the command line arguments (which are strings)
19:46:51 <Cale> jmr: Yeah, Haskell makes a great calculator
19:46:57 <applicative> "The current version of PARI is 1.39 (Jan. 1995)" 
19:47:06 <ClaudiusMaximus> i think you can set the arguments in ghci somehow
19:47:08 <djahandarie> jmr, it's user's are math-friendly... the language itself has some things that aren't as nice as many mathematicians would like though
19:47:15 <td123> hello, I'm trying to follow http://en.wikibooks.org/wiki/Haskell/Variables_and_functions and it gives me the error     No instance for (Floating Integer)... for the step with pi * r^2
19:47:18 <Cale> http://pari.math.u-bordeaux.fr/download.html
19:47:30 <applicative> I love the name of the ancestral language, "Kent Recursive Calculator", KRC
19:47:31 <Cale> The current stable version of pari is 2.3.5
19:48:02 <jmr> is PARI now a GNU tool?
19:48:11 <applicative> hah, wrong page evidently. I blame Google, or society, if they're different
19:48:18 <jmr> i apologize I haven't used it since the late 90s
19:48:27 <Cale> It's under the GPL anyway
19:48:39 <ClaudiusMaximus> freedrull: yes, with   :set args a b c "1 2 3"
19:48:53 <Cale> td123: Ouch.
19:49:09 <freedrull> ClaudiusMaximus: ah...thanks
19:49:17 <td123> Cale: ?
19:49:17 <Cale> td123: The problem is something called the monomorphism restriction. I can't believe the author didn't check the code :)
19:49:19 <jmr> is there a Math.pi concept?
19:49:26 <Cale> > pi
19:49:27 <lambdabot>   3.141592653589793
19:49:33 <jmr> like Clojure had a Math.pi :)
19:49:35 <ClaudiusMaximus> > pi :: Float
19:49:36 <lambdabot>   3.1415927
19:49:36 <Cale> jmr: pi is in the Prelude :)
19:49:48 <jmr> coolness 
19:49:52 <jmr> is there an euler?
19:49:55 <Cale> td123: The problem is that r's type is being defaulted to Integer
19:50:02 <Cale> td123: and not being left polymorphic
19:50:03 <jmr> e^x stuff
19:50:09 <ClaudiusMaximus> > exp 1
19:50:10 <lambdabot>   2.718281828459045
19:50:14 <Cale> td123: There are two things you could do:
19:50:19 <Cale> Well, three :)
19:50:24 <applicative> > let r = 3 in pi * r ^ 2
19:50:25 <lambdabot>   28.274333882308138
19:50:26 <Cale> 1) Add a type signature for r
19:50:30 <Cale> r :: (Num a) => a
19:50:46 <jmr> man this is better than geeking out in Fry's
19:50:51 <Cale> This ensures that r is polymorphic (and will be recomputed on each use at whatever type is desired)
19:51:12 <Cale> 2) Add a conversion when using r:  pi * (fromIntegral r)^2
19:51:19 <lispy> jmr: where do you live?
19:51:30 <djahandarie> jmr, Haskell is really nice for math until you start thinking about abstract algebra and category theory, then it starts looking a little ugly
19:51:38 <td123> Cale: hmm, this is very similar to ocaml :)
19:51:42 <freedrull> ClaudiusMaximus: actually this way  is pretty easy. :main ["myargs"]
19:51:45 <Cale> 3) Turn off the monomorphism restriction by adding {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your code
19:51:46 <jmr> true then just use matlab
19:51:59 <Cale> td123: Yeah, it's similar to the value restriction, only a bit less restrictive
19:52:05 <jmr> or some other math centric tool 
19:52:06 <applicative> djahandarie, what is so ugly then? 
19:52:13 <jmr> i live in the bay area :) 
19:52:17 <td123> Cale: thank you
19:52:32 <lispy> jmr: ah, fry's must be a chain then
19:52:33 <Cale> td123: There are a lot of people who want to do away with the MR altogether
19:52:33 <djahandarie> applicative, Num for example... and the names lie sometimes and are sometimes not as general as they should be
19:52:54 <Cale> td123: Or really just turn it into a compiler warning, instead of an error
19:53:05 <td123> how?
19:53:10 <td123> by step #3?
19:53:12 <ClaudiusMaximus> freedrull: ah cool
19:53:25 <Cale> td123: Basically by building step 3 into the compiler as the default :)
19:53:38 <td123> oh.. that means rebuilding ghc.. nah :)
19:53:40 <applicative> djahandarie, I see, I thought you were thinking something like, Hask is a really ugly category ...
19:53:40 <jmr> Yes Fry's electronics is where all the Silicon Valley Engineers go to buy/consume electronics stuff :)
19:53:51 <Cale> td123: Well, I mean, it's a change to the language.
19:54:15 <td123> I'll just leave the default :) thanks
19:54:16 <Cale> (that people would like to make, but it hasn't been done)
19:55:27 <Cale> td123: The MR only applies to typeclass polymorphic definitions without type signatures that don't explicitly have function parameters (syntactically)
19:55:47 <Cale> td123: (Just to help you work out where it applies)
19:56:17 <td123> Cale: ok.. I'll probably forget that for now :)
19:56:24 <Cale> td123: Yeah, that's fine :)
19:56:36 <td123> Cale: oh, btw, I think the author meant r = 5.0
19:56:42 <td123> which doesn't produce that error
19:56:55 <jmr> (>5), (+1) are powerful  functions to apply on lists
19:56:59 <Cale> td123: Oh, that's another solution. It adds a Fractional constraint, and then the type will be defaulted to Double
19:57:15 <ClaudiusMaximus> anyone used http://hackage.haskell.org/package/QuadEdge and can recommend it or not?
19:59:06 <jmr> where are you from <lispy> and <Cale>?
19:59:20 <Cale> I'm from Brantford, Ontario, Canada
19:59:59 <djahandarie> jmr, it is possible to do really neat math stuff with Haskell though
20:00:25 <djahandarie> > (sin^2 + cos^2) 10 :: CReal
20:00:26 <lambdabot>   1.0
20:00:28 <jmr> yeah i can see it's power
20:00:48 <Cale> > showCReal 100 pi
20:00:49 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
20:01:13 <jmr> i have no problems with haskell doing cool math, it's just that we hired math people to do really stupid things like subprime mortgages
20:01:22 <Cale> CReal is a neat library, I just wish it were more practical for large computations.
20:01:24 <jmr> :-)
20:01:39 <Cale> > sum [k | k <- [1..1000]] :: CReal
20:01:41 * djahandarie nods in agreement with Cale
20:01:43 <lambdabot>   mueval-core: Time limit exceeded
20:01:47 <Cale> ^^ this is bad
20:02:16 <td123> 1000*1001/2
20:02:22 <aristid> Cale: why the list comprehension?
20:02:33 <aristid> > sum [1..1000] :: CReal
20:02:37 <lambdabot>   mueval-core: Time limit exceeded
20:02:37 <Cale> aristid: I was originally going to do something else and then decided against it
20:02:44 <aristid> Cale: ah.
20:02:51 <Cale> (and didn't think to simplify)
20:02:59 <applicative> why does it have this difficulty, CReal?
20:03:54 <djahandarie> Sharing is very hard with dynamic precision
20:04:04 <ManateeLazyCat> So many json package, which one is best?
20:04:35 <jmr> at manateelazycat do u even need one? can't you just "grep"
20:04:39 <jmr> pattern match?
20:04:59 <ManateeLazyCat> Google translate return Json data, i need parser and pick translation from json data.
20:05:02 <djahandarie> ManateeLazyCat, I think the galois one is pretty popular
20:05:15 <Cale> jmr: Well, if you want to actually parse json format text into Haskell datastructures...
20:05:29 <jmr> aah i see i see
20:05:44 <ManateeLazyCat> djahandarie: galosi one? Package name?
20:05:48 <djahandarie> ManateeLazyCat, json
20:05:54 <ManateeLazyCat> djahandarie: Thanks! 
20:05:56 <jmr> i would have grepped first to pipe what the google stuff returns
20:06:29 <ManateeLazyCat> jmr: Convert to haskell data structure is key.
20:06:47 <ManateeLazyCat> jmr: If have parser for json why need grep?
20:07:00 <ManateeLazyCat> @package json
20:07:00 <lambdabot> http://hackage.haskell.org/package/json
20:07:36 <Cale> I think my main gripe about the Hackage website now is that it's getting hard to access package pages when you know the exact name of the package that you want to look at.
20:07:54 <Cale> because so often it's also a substring of many other packages
20:08:01 <Cale> Like, try getting to the mtl documentation
20:08:21 <Cale> I guess I should use the google search at the top more
20:08:33 <djahandarie> Cale, the new hackage handles that better
20:08:48 <djahandarie> Cale, http://sparky.haskell.org:8080/ try out the search on there
20:09:22 <djahandarie> I'm hoping to maybe somehow work Hayoo or Hoogle results into there also
20:09:29 <jmr> let (_,(a :_)) = (10," abc") in a
20:09:35 <applicative> if you know the name of the package you just go to /package/mtl 
20:09:40 <Cale> djahandarie: Build that search into the package list page :)
20:09:41 <jmr> that's a cool pattern matching tutorial :)
20:10:04 <Veinor> > let (_,(a :_)) = (10," abc") in a
20:10:05 <lambdabot>   ' '
20:10:09 <Veinor> :D
20:10:45 <jmr> how do u do vectors and matrices
20:10:54 <jmr> is there a linpack for haskell?
20:10:56 <Cale> applicative: My usual impulse is to start from the package list page and type "/mtl" which does an in-page search, but that's ineffective now.
20:11:10 <Cale> jmr: There are a number of linear algebra packages...
20:11:26 <jmr> thanks Cale
20:11:29 <Cale> http://hackage.haskell.org/package/hmatrix
20:11:36 <Cale> http://hackage.haskell.org/package/vector-space
20:11:51 <jmr> LAPACK is awesome!
20:11:52 <jmr> :)
20:11:59 <applicative> I know, too many packages.  Similarly cabal update seems to take forever
20:12:22 <jmr> (thank(you))
20:13:24 <ymasory> hi. i'm looking at the type signatures of putStrLn and print and trying to figure out the difference. and failing.
20:13:25 <Cale> jmr: you can look around on http://hackage.haskell.org/packages/archive/pkg-list.html for things
20:13:45 <Cale> ymasory: print prints values of any type which has an instance of the Show class
20:13:55 <Cale> ymasory: putStrLn only prints strings
20:14:04 <moosefish> ymasory: putStrLn deals with String's. print deals with stuff that's easily convertible to a String.
20:14:15 <Cale> The connection between them is that  print = putStrLn . show
20:14:27 <ymasory> ah
20:14:37 <ymasory> and what's the "=>" in print's signature?
20:14:50 <Cale> That separates the class context from the rest of the type
20:14:53 <Cale> :t print
20:14:54 <lambdabot> forall a. (Show a) => a -> IO ()
20:15:13 <Cale> This says that the type a can't just be any type, it must be an instance of the typeclass Show
20:15:24 <Cale> class Show a where
20:15:27 <Cale>   show :: a -> String
20:15:32 <Cale>   ... some other stuff ...
20:16:17 <ymasory> oh okay, it's not a chained function. it's more like the declaration of a generic parameter a in a method signature in Scala
20:16:19 <applicative> ymasory, for example, you cant print a function, it's doesn't have a Show instance, unless you make one in some strange case
20:16:30 <ManateeLazyCat> Language.Translate.Google is good namespace?
20:16:39 <applicative> > show sqrt
20:16:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:16:40 <lambdabot>    arising from a use of `...
20:16:46 <Cale> You can read that type signature as saying that for any type a, so long as there is an instance Show a, the function takes a parameter of type a, and produces an IO action returning ().
20:16:54 <applicative> aaaargh
20:16:56 <ymasory> thanks Cale, moosefish, applicative
20:17:01 <jmr> WOW haskell has a CouchDB interface
20:17:05 <jmr> that's awesome!
20:17:17 <jmr> i started playing with couchDB and erlang 
20:17:25 <Axman6> haskell has everything
20:17:30 <Cale> http://hackage.haskell.org/package/erlang
20:17:43 <Cale> Haskell also has the ability to simulate Erlang nodes :)
20:17:48 <applicative> @faq can everything be done in haskell?
20:17:48 <lambdabot> The answer is: Yes! Haskell can do that.
20:17:48 * Axman6 puts this down to turing completeness, and watches the CS majors cringe
20:18:31 <Axman6> @faq Can haskell calculate the monetry worth of love?
20:18:32 <lambdabot> The answer is: Yes! Haskell can do that.
20:19:13 <ManateeLazyCat> @faq Can we close you, lambdabot?
20:19:14 <lambdabot> The answer is: Yes! Haskell can do that.
20:19:47 <jmr> ffmpeg in haskell (awe(some))
20:19:53 <applicative> what, Haskell close lambdabot, that's like asking whether God can make a rock he can't move, etc.
20:21:13 <lispy> what does it mean to close lambadbot?
20:21:25 * applicative wonders what Axman6 was putting down to turing completeness, in the hope of agreeing
20:21:35 <dmwit> "Haskell has everything"
20:21:38 <Axman6> the fact haskell has everything
20:22:03 <Cale> ^^ what it means to close lambdabot
20:23:27 <applicative> does, e.g. Agda have 'more' or 'less' than Haskell?
20:23:54 <jmr> can haskell do lego ?
20:24:08 <jmr> u know the lego mindtricks or programable lego bots?
20:24:24 <Cale> jmr: That's an interesting question. I don't think there's a library yet, but it would be a good project
20:24:45 <jmr> i remember java and c  people wrote one years ago  circa 2003
20:25:04 <jmr> i mean i think it would be a better language for kids to learn than java or c
20:25:37 <jmr> but this is me coming from the 80s and LOGO writer generation where RT 90 means something
20:26:07 <writer> REPEAT 4 (FD 100 RT 90)
20:26:14 <jmr> heck ya!!!
20:26:24 * writer also started with LOGO :)
20:26:25 <jmr> LOGO turtle was DOPE!!!
20:26:27 <lispy> boxes
20:26:32 <lucca> logo \m/
20:26:44 <writer> now I see it, it seems to be inspired from LISP :)
20:26:53 <jmr> Apple IIC
20:27:12 <lucca> no, not apple anything originally.
20:27:25 <jmr> and the teacher explained random access memory and read only memory  with 5 1/2 floppy
20:27:25 <lucca> there was an apple ][ release, yes, but that's unrelated.
20:27:35 <jmr> yeah i know it's an MIT thaaaaang
20:28:15 <jmr> MIT folks made LOGO 
20:28:49 <lucca> ...not really
20:29:03 <lucca> Papert was MIT related, apparently
20:29:11 <jmr> i just remembered everyone made "eye glasses" 
20:29:13 <jmr> hahahhaa
20:29:22 <jmr> (ha(ha(ha(ha)))) 
20:29:41 <lucca> Others were at BBN, etc.
20:29:51 <lucca> bleh.
20:30:30 <jmr> but LOGO was fun in the 80s
20:30:49 <jmr> you made the turtle move and you got to draw and get out of English class or Social Studies
20:38:00 <jmr> thanks haskell group this was fun :)
20:38:24 <jmr> (happy (coding))
20:38:42 <djahandarie> :)
20:39:26 <jmr> i like this tryhaskell and also chatting, far too many times i have felt no support for learning a new language
20:40:21 <jmr> like you have to go thru programming hazing first to learn something new or read an O'Reilly book, but this was fun. 
20:40:36 <djahandarie> Haha
20:41:16 <djahandarie> You can also come here with an IRC client if you tell it to connect to irc.freenode.net and join #haskell
20:53:05 <mightybyte> @pl (\c e -> return $ insert e h)
20:53:05 <lambdabot> const (return . flip insert h)
20:53:34 <mightybyte> @pl (\c e -> return $ insert e c)
20:53:34 <lambdabot> (return .) . flip insert
20:54:18 <mightybyte> Heh, that would be why I wasn't getting it right on my own.
20:56:50 <applicative> > let _Y = text . take 175 . fix in _Y ("Y is for " ++)
20:56:51 <lambdabot>   Y is for Y is for Y is for Y is for Y is for Y is for Y is for Y is for Y i...
20:57:46 <riboflavin> Is there a way to use the pattern (x:xs) when it expects the argument to be a list of Ints, or does that only work for generic arguments?
20:57:59 <ezyang> riboflavin: That works for any a for [a] 
20:58:18 <ezyang> x will have the type Int and xs will have type [Int] 
20:58:40 <riboflavin> ezyang: oh, wait, my problem was I didn't enclose the pattern in parentheses
20:58:42 <riboflavin> ezyang: thanks
20:59:24 <riboflavin> huh... or maybe not
20:59:37 <ezyang> pastie! 
20:59:50 <applicative> hpaste.org 
21:01:35 <riboflavin> thats cool... like pastebin, but for here. Anyway, its very short, I could have just pasted in in the chat, but the function is http://hpaste.org/30188/thing
21:01:52 <riboflavin> waitm nevermind
21:01:55 <riboflavin> I know what I did wrong
21:02:49 <djahandarie> siever?
21:02:57 <riboflavin> the "Int ->" in the type declaration shouldn't be there
21:03:03 <djahandarie> And yeah
21:03:05 <riboflavin> djahandarie: a different function
21:03:36 <riboflavin> that was a mistake because I just copied the declaration from siever, which did take an Int
21:04:58 <riboflavin> also I forgot to include a base case. All sorts of stupid problems
21:06:22 <riboflavin> the function just implements the sieve of Eratosthenes on a list. Now it work.
21:06:46 <djahandarie> Turner's or Euler's
21:07:09 <riboflavin> I don't know the difference.
21:07:48 <riboflavin> it also cheats because the list it takes as an argument has to be of the form [2..n] for it to work
21:08:03 <applicative> Euler?
21:09:12 <riboflavin> I don't know. If you want to figure it out, this is the whole thign: http://hpaste.org/30190/sieve
21:09:48 <kmc> recursion in Haskell doesn't always need a base case :D
21:09:56 <riboflavin> kmc: in this case it did though
21:10:26 <mightybyte> @pl (\h -> return . flip insert h <=< foo)
21:10:27 <lambdabot> (line 1, column 31):
21:10:27 <lambdabot> unexpected "=" or "<"
21:10:27 <lambdabot> expecting variable, "(", ".", space, operator or ")"
21:10:27 <lambdabot> ambiguous use of a left associative operator
21:10:49 <mightybyte> :(
21:11:11 <Axman6> of, the base case can be decided later, in another function
21:12:59 <applicative> djahanderie, I see.  It seems that Euler invented the Sieve of Eratosthenes while proving the Euler product formula for the Riemann zeta function.  It makes sense but the names and dates are a little confusing.
21:13:20 <riboflavin> yea, where does Eratosthenes come into it?
21:13:46 <siracusa> How do I use handle to catch an execption without caring what kind of exception it is, like `handle (const $ return ()) doSomeStuff'?
21:13:50 <riboflavin> maybe he came up with primes or something> I don't feel like looking it up
21:14:59 <applicative> riboflavin, the method is from greek antiquity.   I thought it might be in Euclid, like the proof of the infinity of primes, but it's in something else. 
21:16:36 <riboflavin> hmm... ok. It seems like whoever came up with the idea of primes probably would have come up with the algorithm, as it's the intuitive way to find them
21:19:01 <tommd> primes are a fact of life - numbers that have particular mathematical properties.  Either you really need to do some studying or you're trolling.
21:19:34 <kmc> seems to me the phrase "came up with" is general enough to include discovery as well as invention
21:19:53 <applicative> tommd, it seemed riboflavin was trying to get a version of the sieve to compile
21:21:24 <riboflavin> tommd: I meant whoever discovered it. I don't mean to say anyone invented primes, but like anything else someone had to see it
21:21:41 <danharaj> I don't know if it would have been that obvious to the greeks
21:22:10 <danharaj> nowadays we have so much mathematical knowledge that our intuitions are truly gargantuan compared to even say Archimedes
21:24:13 <applicative> The wikipedia article is saying that the Turner sieve is more akin to Euler's than to Eratosthenes'; so Turner's honor can be somewhat defended against O'Neill
21:24:55 <kmc> yeah, it is hard to see how some ideas from just a hundred years ago were not obvious, let alone thousands
21:27:59 <etpace> @hoogle Char -> String -> [String]
21:28:00 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
21:28:00 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
21:28:00 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
21:28:11 <freedrull> okay now i need to learn how to use the lexer in parsec
21:30:23 <kmc> freedrull, you mean Text.Parsec.Token?
21:30:40 <freedrull> kmc: yes
21:31:17 <kmc> GHC's NamedFieldPuns / RecordWildCards extensions are very useful for taking apart the GenLanguageDef record at top level
21:38:33 <etpace> > let split _ [] = []; split c xs = let (u,v) = break (==c) xs in u:split c (drop 1 v); in split ':' "01:03:05"
21:38:34 <lambdabot>   ["01","03","05"]
21:38:36 <rschnck> Can someone explain why ((,)) has the following type? ((,)) :: a -> b -> (a, b)
21:38:41 <rschnck> Does that mean it's a function itself?
21:38:47 <etpace> yes
21:38:47 <rschnck> Or some sort of operation?
21:38:53 <rschnck> Oh.
21:38:57 <etpace> How do you distinguish the two?
21:39:04 <rschnck> They're the same, I suppose.
21:39:09 <etpace> seems that way to me
21:39:15 <rschnck> SOmehow "+" seems like an operation to me but x^2 a function
21:39:22 <rschnck> But that's just because + is so fundamental
21:39:28 <kmc> > (,) 2 3
21:39:29 <lambdabot>   (2,3)
21:39:40 <rschnck> Neat :D
21:39:45 <rschnck> That makes the cross function absurdly easy.
21:39:50 <etpace> + could be defined just using succession, so it's not any more fundamental than x^2
21:39:56 <kmc> > liftA2 (,) "abc" "xy"
21:39:57 <lambdabot>   [('a','x'),('a','y'),('b','x'),('b','y'),('c','x'),('c','y')]
21:40:10 <kmc> yeah, the distinction between operators and functions in Haskell is purely syntactic
21:43:23 <rschnck> kmc: How is it that ((,) x) ys is able to go through ys and take each element of it?
21:43:58 <etpace> he used liftA2
21:44:11 <rschnck> crossNew (x:xs) ys = map ((,)x) ys ++ crossNew xs ys 
21:44:22 <etpace> that works
21:44:24 <rschnck> Successfully crosses a list of length 2 with a list of length x
21:44:38 <rschnck> Yes, so I'm asking how the function knows to go through ys and make a (,) for each?
21:44:43 <rschnck> for each element in y*
21:44:44 <etpace> map
21:44:54 <etpace> > map (+1) {1..5]
21:44:55 <lambdabot>   <no location info>: parse error on input `1'
21:45:08 <rschnck> etpace: Oh, of course
21:45:58 <rschnck> kmc: So how would I go about defining ((,)) myself?
21:46:16 <etpace> > (5,3)
21:46:16 <lambdabot>   (5,3)
21:46:22 <etpace> does that help
21:46:22 <rschnck> Would it literally be ((,)) :: a -> b -> (a,b)?
21:46:27 <etpace> yes
21:47:04 <rschnck> Isn't the type...almost enough?
21:47:06 <etpace> a function that takes two arguments, and puts them in a tuple
21:47:26 <etpace> well, not completely
21:47:32 <etpace> my function could do something to a and b before it tuples it
21:47:36 <rschnck> new((,)) :: a -> b -> (a,b)
21:47:38 <rschnck> new((,)) a b = (a,b)
21:47:46 <etpace> looks right
21:48:35 <etpace> makeTuple :: (a -> a) -> (b -> b) -> a -> b -> (a,b); makeTuple f g x y = (f x, g y) then makeTuple f g would have the same type
21:48:37 <kmc> rschnck, first of all it's named (,) not ((,))
21:48:40 <etpace> but not the same behaviour
21:48:44 <kmc> ((,)) is a valid expression just as ("foo") is
21:48:51 <applicative> @type (,,,,)
21:48:52 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
21:48:56 <kmc> also, you can't mix symbols and letters in a name
21:49:06 <kmc> > let mkTuple a b = (a,b) in mkTuple
21:49:07 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1 -> (t, t1))
21:49:07 <lambdabot>    arising fro...
21:49:09 <kmc> :t let mkTuple a b = (a,b) in mkTuple
21:49:10 <lambdabot> forall t t1. t -> t1 -> (t, t1)
21:49:17 <rschnck> kmc: ah
21:50:01 <kmc> «((,) x) ys» will not iterate over the elements in ys one by one
21:50:06 <kmc> it's liftA2 that's doing that
21:50:09 <applicative> > (,,,,) 1 () 'a' "Hahah" Nothing
21:50:10 <lambdabot>   (1,(),'a',"Hahah",Nothing)
21:50:17 <rschnck> kmc: But we have map too?
21:50:23 <kmc> yes
21:50:32 <kmc> map :: (a -> b) -> [a] -> [b]
21:50:54 <kmc> liftA2 :: (a -> b -> c) -> [a] -> [b] -> [c]
21:50:59 <kmc> note that liftA2 has the same type as zipWith
21:51:01 <kmc> but different behavior
21:51:13 <kmc> > zipWith (,) "foo" "bar"
21:51:13 <lambdabot>   [('f','b'),('o','a'),('o','r')]
21:51:15 <kmc> > liftA2 (,) "foo" "bar"
21:51:16 <lambdabot>   [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o'...
21:51:17 <rschnck> Wait wait
21:51:31 <rschnck> But crossNew (x:xs) ys = map ((,)x) ys ++ crossNew xs ys 
21:51:33 <rschnck> works
21:51:36 <rschnck> Sans liftA2?
21:51:51 <kmc> yeah
21:51:58 <kmc> i didn't claim liftA2 was required to solve your problem
21:52:02 <rschnck> Ah
21:52:03 <rschnck> Okay :P
21:52:06 <kmc> i just used it in my solution above
21:52:10 <rschnck> Yeah, yeah I saw
21:52:15 <rschnck> Sorry, was confused a bit
21:52:16 <kmc> that's a good solution
21:52:19 <rschnck> for a bit
21:52:38 <kmc> btw with the GHC extension TupleSections you can write (x,) instead of ((,) x)
21:52:46 <kmc> it's a bit frivolous but does look nice
21:52:51 <kmc> :t ('x',)
21:52:52 <lambdabot> parse error on input `)'
21:52:54 <kmc> aww
21:53:12 <rschnck> I can write ((,)) x ys too, right?
21:53:23 <rschnck> I a bit confused why ((,) x) even works
21:55:28 <kmc> (,) is the name of a function
21:55:33 <kmc> you're applying it to one argument, x
21:55:45 <kmc> no different from (show x)
21:55:55 <applicative> kmc, cool.   I had seen this extension, but it didn't occur to me what it was for.  
21:56:47 <kmc> you can define your own infix operators too, though not using commas in the name
21:56:57 <Colours> rschnck look up the definition of ,
21:56:59 <kmc> «map ((,)) x ys» would not do what you want
21:57:11 <kmc> that treats map as a 3-argument function
21:57:22 <kmc> the first argument to map needs to be the function ((,) x)
21:57:42 <kmc> you can write that same function as «\y -> (x,y)» or «let f y = (x,y) in f» or many other ways
21:57:51 <rschnck> kmc: I tried, but this happens:http://paste.ubuntu.com/496267/
21:58:17 <rschnck> There's a missing paranthesis on the end there, it's actually in the definition, thuogh.
21:58:24 <kmc> <kmc> that treats map as a 3-argument function
21:58:43 <rschnck> kmc: and ((,)x) ys doesn't?
21:58:55 <applicative> you need to group (elmtoTup x) , no?
21:59:17 <kmc> «foo x y z» is different from «foo (x y) z»
21:59:21 <applicative> same as you do ((,) x)
21:59:38 <kmc> in the first case, foo gets three arguments, in  the second case it gets two
21:59:51 <kmc> in the first case, x is not (necessarily) a function; in the second case it's a function applied to the argument y
22:00:12 <applicative> the way you write it, map is grabbing hold of elmtoTup alone, but you want it to get (elmtoTup x) both together
22:00:31 <rschnck> But elmtoTup needs two inputs
22:00:41 <rschnck> So doing (elmtoTup x) seems odd, as you're only giving it one.
22:00:41 <kmc> rschnck, yes
22:00:46 <kmc> map will give it the other one
22:00:47 <kmc> @src map
22:00:47 <lambdabot> map _ []     = []
22:00:48 <lambdabot> map f (x:xs) = f x : map f xs
22:00:59 <rschnck> Oh D:
22:01:01 <kmc> you're giving map a "partially applied" function
22:01:09 <kmc> you give map f, it calls (f x)
22:01:18 <rschnck> That's brilliant
22:01:21 <rschnck> Okay, that makes sense
22:01:36 <rschnck> So that's the same as
22:01:42 <rschnck> map (2+) [2,3,5]
22:01:45 <rschnck> + requires two inputs
22:01:53 <rschnck> And you're giving it one, to map to the list after.
22:02:01 <kmc> this is why we write the type of a two argument function «A -> B -> C».  that's actually «A -> (B -> C)»: when you apply the argument of type A, what you get back is another function
22:02:19 <kmc> yup
22:02:31 <rschnck> Alright, thanks.
22:02:53 <pheuter> question
22:03:16 <pheuter> why can i do pure (+) <*> [3] <*> pure 5, but not pure (+) <*> [3] <*> Just 5
22:03:32 <applicative> list and maybe are different functors
22:03:43 <pheuter> is pure a Maybe ?
22:04:07 <applicative> @type pure
22:04:07 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
22:04:30 <applicative> @type pure (+)
22:04:31 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a -> a)
22:04:33 <ray> pure lifts into any applicative functor, but it can only have one type at a time
22:04:50 <applicative> @type (<*>)
22:04:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:05:11 <applicative> ^^^ see pheuter, the f's have to match
22:05:20 <pheuter> I see, so <*> cannot operate on different kinds of functors ? only a homogeneous functor chain ?
22:05:28 <applicative> exactly
22:06:00 <applicative> it works with any functor, but only one at once
22:06:27 <pheuter> interesting, are there functions that deal with multiple functors ?
22:06:40 <pheuter> rather, functor type agnostic
22:06:53 <applicative> kind of like lists can be of any type of thing, but only one type of thing at once, to make a remote analogy.
22:07:13 <pheuter> hm
22:07:13 <applicative> well, aren't pure and <*> examples of that?
22:07:22 <pheuter> right, but one at a time
22:07:34 <kmc> pheuter, using the Functor and Applicative classes only, you have no way to mix values from two different functors
22:08:10 <pheuter> k
22:08:11 <kmc> given (F a) and (G b) and (a -> b -> c), there's not much you can do, even if you have Functor and Applicative for both F and G
22:08:39 <kmc> however given (F (G a)) and (a -> b) you can get (F (G b))
22:08:48 <kmc> that's just (fmap . fmap)
22:08:50 <kmc> :t fmap . fmap
22:08:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:09:07 <kmc> > (fmap . fmap) succ [Just 3, Nothing. Just 7)
22:09:08 <lambdabot>   <no location info>: parse error on input `)'
22:09:10 <kmc> > (fmap . fmap) succ [Just 3, Nothing. Just 7]
22:09:11 <lambdabot>   Couldn't match expected type `a -> b'
22:09:11 <lambdabot>         against inferred type `Data.M...
22:09:18 <applicative> I was going to say, you can have more fun if you pile up functors, like [Maybe Int] and Maybe [Int]
22:09:22 <kmc> hrm
22:09:35 <kmc> :t (fmap . fmap) succ
22:09:36 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, Enum a) => f (f1 a) -> f (f1 a)
22:09:39 <pheuter> is there  a way to go from (F a) (G b) to (F (G a) b) ?
22:09:53 <kmc> pheuter, that doesn't make sense, it's a kind error
22:10:06 <kmc> you want a type like «Maybe [a] b»
22:10:07 <pheuter> oh right
22:10:10 <kmc> that doesn't work; Maybe only takes one arg
22:10:16 <pheuter> hm
22:10:17 <pheuter> interesting
22:10:45 <applicative> Either takes two
22:11:23 <applicative> so something of the shape (F (G a) b)  would be like an Either [Char] Int
22:12:30 <pheuter> what is a constructor for Either ?
22:12:37 <applicative> Left and Right
22:12:42 <pheuter> ah
22:12:53 <applicative> @type Left "I'm on the Left"
22:12:54 <lambdabot> forall b. Either [Char] b
22:13:04 <applicative> @type Right "I'm on the Left"
22:13:05 <lambdabot> forall a. Either a [Char]
22:13:41 <applicative> @type [Left "I'm on the Left", Right "I'm on the Right now"]
22:13:41 <lambdabot> [Either [Char] [Char]]
22:13:48 <pheuter> @type Left $ Just 5
22:13:49 <lambdabot> forall b t. (Num t) => Either (Maybe t) b
22:18:42 <kmc> > (fmap . fmap) show [Just 'x', Nothing. Just 'y]
22:18:42 <lambdabot>   <no location info>:
22:18:43 <lambdabot>      lexical error in string/character literal at chara...
22:18:45 <kmc> > (fmap . fmap) show [Just 'x', Nothing. Just 'y']
22:18:46 <lambdabot>   Couldn't match expected type `a -> b'
22:18:46 <lambdabot>         against inferred type `Data.M...
22:18:50 <kmc> meh i fail at haskell today
22:19:00 <kmc> ah fucking can't read
22:19:03 <kmc> > (fmap . fmap) show [Just 'x', Nothing, Just 'y']
22:19:04 <lambdabot>   [Just "'x'",Nothing,Just "'y'"]
22:19:06 <kmc> sigh
22:19:10 <pheuter> [*] <*> pure 6 <*> pure 8
22:19:18 <pheuter> why doesn't that work ?
22:19:27 <kmc> [*] is not valid syntax
22:19:34 <kmc> did you mean [(*)] ?
22:19:49 <pheuter> yes i did, :/
22:19:51 <kmc> > [(*)] <*> pure 6 <*> pure 8
22:19:52 <lambdabot>   [48]
22:19:56 <kmc> > [(+),(*)] <*> pure 6 <*> pure 8
22:19:57 <lambdabot>   [14,48]
22:20:17 <Cale> > (*)  <$> [6] <*> [8]
22:20:18 <lambdabot>   [48]
22:20:30 <pheuter> interesting, so list comprehensions are syntactic sugar for <*> ?
22:20:41 <kmc> no, they can do more than Applicative
22:20:46 <Cale> List comprehensions are syntactic sugar for >>=
22:21:01 <kmc> list comprehension and "do" are two very similar syntactic sugars for monad operations
22:21:14 <andrewsw> another update to hpaste.el. should be working until chrisdone changes something again ;-P  http://www.haskell.org/haskellwiki/Hpaste.el 
22:21:23 <kmc> the syntax of list comprehensions is restricted to the list monad, but could in fact work for any monad, and did work that way in Haskell 1.4
22:21:45 <Cale> > do x <- [1,2,3]; y <- [4,5,6]; if even (x+y) then [()] else []; return (x,y)
22:21:46 <lambdabot>   [(1,5),(2,4),(2,6),(3,5)]
22:22:06 <pheuter> I should get into monads :P (and I thought Applicative Functors is it)
22:22:16 * applicative doubts that he wants a keybinding to accidentally post his syntactic disasters to hpaste
22:22:25 <Cale> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> (if even (x+y) then [()] else []) >>= \k -> return (x,y)
22:22:26 <lambdabot>   [(1,5),(2,4),(2,6),(3,5)]
22:22:50 <dmwit> > do x <- [1, 2, 3]; y <- [4, 5, 6]; guard (even (x+y)); return (x, y)
22:22:51 <lambdabot>   [(1,5),(2,4),(2,6),(3,5)]
22:23:01 <pheuter> > [1..5] >>= return . (\x -> x*x )
22:23:02 <lambdabot>   [1,4,9,16,25]
22:23:06 <Cale> and then in list comprehension syntax...
22:23:24 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5,6], even (x+y)]
22:23:25 <lambdabot>   [(1,5),(2,4),(2,6),(3,5)]
22:23:32 <pheuter> very nice
22:23:41 <pheuter> so monads = applicative functors + bind ?
22:23:43 <dmwit> pheuter: a >>= return . f === liftM f a === fmap f a
22:23:46 <Cale> pheuter: yeah
22:23:54 <Cale> return is the same as pure
22:24:10 <Axman6> @src Applicative
22:24:10 <lambdabot> class Functor f => Applicative f where
22:24:11 <lambdabot>     pure  :: a -> f a
22:24:11 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
22:24:16 <pheuter> right, hm, was it necessary to make a new typeclass ?
22:24:37 <Cale> Well, monads have been around longer
22:24:49 <dmwit> The classes were thought up in the wrong order, that's all.
22:24:59 <pheuter> ah, :)
22:25:03 <ManateeLazyCat> @hoogle urlEncode
22:25:03 <lambdabot> Network.CGI urlEncode :: String -> String
22:25:03 <lambdabot> Network.CGI.Protocol urlEncode :: String -> String
22:25:03 <lambdabot> Network.HTTP.Base urlEncode :: String -> String
22:25:21 <pheuter> damn it, running on reserve. Thanks for clarification!
22:25:28 <ManateeLazyCat> > urlEncode "中国"
22:25:28 <lambdabot>   Not in scope: `urlEncode'
22:25:40 <ManateeLazyCat> > Network.HTTP.Base.urlEncode "中国"
22:25:41 <lambdabot>   Not in scope: `Network.HTTP.Base.urlEncode'
22:27:24 <freebsc> what are the benefits of haskell over c, c++, php, javascript, python, java, freebasic?
22:28:41 <Axman6> they are enumerable
22:28:53 <kmc> over C and C++: it's a high level language, manages memory for you, allows you to program at a very high level in the problem domain while ignoring many irrelevant details
22:28:59 <Axman6> especially when you ask such difficult to answer questions
22:28:59 <kmc> that's true of many languages though
22:29:16 <Axman6> you can prove haskell programs correct
22:29:30 <Axman6> concurrency and parallelism is amazingly fun in haskell
22:29:35 <dmwit> over all of them: a powerful type system
22:29:36 <freebsc> I am just wondering why it is just a large group here
22:29:37 <kmc> over javascript and python: static types mean that if your program compiles, there's a good chance it works correctly.  much less chasing bugs after the fact, much more thinking and getting it right the first time
22:29:40 <Axman6> it can be damn fast, if you know what you're doing
22:29:47 <kmc> over Java: its static type system is actually good
22:29:59 <Axman6> and it has the most welcoming and helpful community i've ever met
22:30:03 <kmc> concurrency and parallelism, like Axman6 said
22:30:38 <kmc> referential transparency enables equational reasoning: both you and the compiler can  think and optimize by substituting "equals for equals".  in most languages this fails due to side effects
22:30:54 <dmwit> Is there really a dialect of Basic that can be considered a contender with the others you listed? I'm mildly surprised there.
22:31:39 <kmc> freebsc, a lot of people learn Haskell because it's fun, expands their mind, and enables them to write better code in every language they use.  i think that explains a lot of the size of this channel.  we aren't all using Haskell for practical stuff, though some of us are, and it is a reasonable choice for many problems
22:32:17 <kmc> if you are sick of learning language after language that slaps a fresh coat of syntax on top of the same tired concepts, Haskell is a great choice
22:32:33 <kmc> and it can be incredibly frustrating to learn, for the same reason
22:33:08 <Axman6> i think it might be because you need to learn two languages. haskell and the type system
22:33:15 <mafs> But to the point of it being incredibly frustrating to learn, as mentioned the community is absolutely fantastic, which is a generous offset to any learning curve.
22:33:31 <kmc> as a member of the Haskell community, i personally consider myself to be fantastic
22:33:32 <kmc> ;P
22:33:41 <kulin> its only frustrating to learn, because you have to learn to do things right, learning how to do things that work wont be enough
22:33:42 <mafs> we all consider you to be fantastic, kmc ;)
22:33:50 <kmc> seriously though, people here are great, all the self-congratulation is deserved ;)
22:34:13 <Axman6> go team!
22:34:23 <kulin> although until the day i die, i will hate the module system of haskell :)
22:34:34 <dmwit> Wow, really?
22:34:36 <dmwit> Hate?
22:34:49 <kmc> freebsc, one way to think of it is:  writing correct programs is hard in any language.  Haskell makes it also hard to write incorrect programs
22:34:59 <kulin> i really desire a sort of scoping for modules and i hate the problem with recusrive imports
22:35:11 <Axman6> haskell bitchslaps you when you do something really wrong
22:35:15 <dmwit> I get the feeling freebsc just sort of dropped the bomb and wandered off.
22:35:25 <dmwit> I am ashamed to have been caught in the blast.
22:35:29 <kmc> heh
22:35:29 <panopticon> kmc: that deserves to be quoted
22:35:37 <kmc> panopticon, i think it was, last time i said it
22:35:47 <kmc> or whoever else said it, if i stole it, i can't recall
22:35:48 <Axman6> @quote kmc 
22:35:48 <lambdabot> kmc says: C++ is at least interesting to learn.  it's a good esolang
22:35:53 <Axman6> @quote kmc 
22:35:53 <lambdabot> kmc says: I think C++ is best thought of as an esolang. It's fun to learn, fun to figure out how to do some trivial things in only 300 lines of code. Not fun to use for practical stuff.
22:35:55 <kulin> the problem with circular module references makes it so that you file structure is something you have to refactor, which in my mind is unacceptable
22:35:59 <kmc> haha
22:36:11 <Axman6> @quote kmc 
22:36:11 <lambdabot> kmc says: global warming is a conspiracy by Democrats, atheists, and The Weather Channel
22:36:19 <Axman6> @quote kmc 
22:36:19 <lambdabot> kmc says: the usual structure for a Haskell program is a crunchy IO shell with a  gooey chocolate pure function center
22:36:23 <dmwit> kulin: I thought the Haskell report requires support for recursive modules (and GHC, at least, provides it).
22:36:29 * Axman6 done
22:36:38 <kmc> it's not pretty though
22:36:39 <dmwit> I'm not sure I understand your complaint about module scoping, so I can't address that one.
22:36:40 <kmc> in GHC
22:36:43 <dmwit> It isn't.
22:36:45 <dmwit> That's true.
22:36:59 <kmc> i think Haskell's module system is pretty good for what it aspires to be: simple and conservative
22:37:06 <dmwit> agreed
22:37:24 <kmc> one little thing i like is that you can import qualified in a non-injective way
22:37:28 <kulin> i just dont like that when i realize i need a new type somewhere, i might have to move all my files around if i need to reference it somewhere unexpected
22:37:36 <kmc> so i can get both Data.Text and Data.Text.IO under Txt
22:37:46 <dmwit> kulin: You should not need to do that.
22:38:07 <dmwit> kmc: Yes, that is a trick that I only learned recently. I'm still not sure how I feel about it.
22:38:19 <kulin> then i must be doing something wrong, because it is nearly a daily problem
22:38:25 <dmwit> seems convenient, but... also kind of a maintenance nightmare, for all the reasons unqualified imports are?
22:38:56 <dmwit> kulin: Look up hs-boot files on the web. You can thank me later. =)
22:39:05 <kmc> i don't think it's such a maintenance nightmare, unless you like to import totally unrelated stuff into the same name
22:39:29 <kmc> it's legit that the author of 'text' wanted to separate out IO but maybe i don't want to remember a separate short prefix for it
22:39:52 <kmc> these days i lean towards doing all qualified imports except really core stuff like Control.Monad, Data.Maybe, etc
22:40:59 <dmwit> I still boggle from time to time at how long my import lists get.
22:41:12 <dmwit> anywhere from 20-40 lines just of imports
22:41:13 <kulin> also modules expose class implementations automatically, which is sort of odd
22:41:29 <dmwit> Yeah, a lot of people complain about that.
22:41:39 <tolkad> dmwit: you could write a module to import common imports
22:41:48 <dmwit> It's hard to say what would be better -- almost no other language has typeclasses.
22:42:11 <mightybyte> kulin: The recursive module thing was frustrating to me at first too, but I've pretty much gotten used to structuring code in a way that is likely to not need recursive modules.
22:42:28 <kmc> i was thinking recently of using h-s-e to write a little tool for managing import lists
22:42:30 <dmwit> tolkad: Yeah, sure, but then when I publish I either have to depend on the prelude-dmwit package, or duplicate that file in all my projects. =/
22:42:34 <kmc> i'm not sure exactly what it should do, though
22:42:58 <tolkad> dmwit: it would be better if all projects had a standard where you never write a class instance unless: the class is defined in your package OR the type is defined in your package
22:43:15 <dmwit> i.e. no orphan instances?
22:43:16 <dmwit> maybe so
22:43:24 <kmc> tolkad, if you restrict that further s/package/module/, you have the definition of non-orphan instances
22:43:27 <freebsc> dmwit no I am here, looking at Haskell tutorial does not look that scary
22:43:30 <kulin> is there something more descriptive i can google for hs-boot, i am getting a lot of garbage
22:43:37 <kmc> kulin, ghc manual
22:44:07 <mightybyte> kulin: I've never felt it was worth it to use hs-boot.
22:44:12 <tolkad> kmc: meh don't agree with that, you shouldn't have to implement all Monad instances in Control.Monad
22:44:22 <kmc> tolkad, no, you'd implement them where you implement your type
22:44:33 <tolkad> kmc: oh, nevermind that makes sense
22:44:34 <kmc> data MyAmazingMonad a = ...; instance Monad MyAmazingMonad where ...
22:44:37 <dmwit> kulin: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#mutual-recursion
22:45:13 <tolkad> kmc: is there any chance a non-orphan instance rule could make it into a haskell standard?
22:45:33 <dmwit> I'd actually be a bit sad if that rule made it into the standard.
22:45:44 <dmwit> I've written a few orphan instances myself. =P
22:46:37 <kmc> yeah
22:46:38 <tolkad> hmm, I guess it doesn't work for multi param type classes
22:46:48 <kulin> out of curiosity, why does ghc not use some preprocessor to auto create the hs-boot file?
22:46:57 <kmc> tolkad, in that case it suffices that any of the types mentioned is defined in the same file
22:47:13 <dmwit> kulin: The most likely explanation is lack of demand.
22:47:18 <kmc> tolkad, the idea is that an orphan instance is an instance which is not necessarily visible when it is looked for
22:47:28 <kmc> if it's in the same module as the type, or the class, then it's always going to be visible if needed
22:48:05 <dmwit> Actually, having just checked, I haven't written orphan instances.
22:48:13 <dmwit> I wrote instances for newtypes, which I guess is totally kosher.
22:48:15 <tolkad> kmc: oh
22:49:03 <kulin> are you using orphan instances to mean instances defined in a different module than the type?
22:49:09 <tolkad> although, orphan instances that aren't exported can be useful for undecideableinstances abuse
22:49:24 <kmc> an instance is orphan unless it's defined in the same module as the class, or as one of the types mentioned in the head
22:49:24 <tolkad> wait no, then you would just define the class locally
22:49:25 <tolkad> nevermind
22:49:38 <kmc> you can't not export an instance
22:49:43 <kmc> which is one of the flaws of Haskell's module system
22:49:45 <tolkad> kmc: you can not export the class
22:49:47 <kmc> but not easily fixed
22:49:49 <kmc> yeah
22:49:52 <kmc> but then it's not orphan
22:49:52 <kulin> i use orphan instances in ffi code
22:50:23 <tolkad> ffi?
22:50:43 <kulin> i have to declare all the pointers in an external module, and then the typeclasses in modules to model the c classes
22:50:43 <tolkad> ah, Fatal familial insomnia
22:50:55 <tolkad> oh foreign function interface
22:51:40 <kmc> c classes?
22:51:57 <kulin> well c++ classes wrapped in c
22:52:28 <kulin> wrapped to use c headers i should say?
22:53:13 <dmwit> Wait, you're using Haskell classes to model C++ classes?
22:53:13 <tolkad> as long as there are no cross-package orphan instances I don't think automatic instance exporting is a problem
22:53:27 <dmwit> Wouldn't using plain old Haskell data be a closer fit?
22:53:48 <tomberek> kmc: what's the term for various types of equality? two things may be equal, but have different internal representations
22:54:02 <dmwit> intensional vs. extensional?
22:54:24 <kulin> dmwit, i take c++ classes and create c style functions which expect a pointer to the class as the first parameter, and then use a typeclass in haskell for those functions where inheritence is used
22:54:46 <kmc> inheritance can be modeled simply by having one "constructor function" call another
22:54:54 <kulin> ya
22:55:16 <dmwit> Well, that seems sane enough.
22:55:30 <dmwit> Using type classes to model inheritance, that is.
22:55:32 <kmc> implementation inheritance is a bad idea anyway, but if you're wrapping C++ code you're probably stuck with it
22:56:15 <kulin> ya, i just try to keep as true to the c++ code as i can when i wrap it, i will create a layer between that and my app which will make more sense
22:56:23 <kulin> the goal is to not need to recreate any documentation with my current approach
22:56:36 <kmc> yeah
22:57:51 <co_dh> why inheritance is bad ? I don't like it , but I don't know why.
22:58:05 <co_dh> do you mean as compare to composition? 
22:59:31 <co_dh> kmc: any answer?
22:59:45 <dmwit> ?remember co_dh I don't like it, but I don't know why.
22:59:45 <lambdabot> It is forever etched in my memory.
23:00:18 <dmwit> ?quote
23:00:18 <lambdabot> pantsman says: I view code as a small troupe of squirrels who convey its meaning to me via interpretive dance
23:00:25 <dmwit> ?quote
23:00:25 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
23:00:49 <kulin> i'm not sure that inheritance is evil exactly, its more the baggage that comes with it in other languages
23:01:29 <kulin> it can be problematic in that the base class can change without your knowledge in some situations i suppose
23:02:12 <kulin> but that is really true for any other type you depend on
23:02:44 <co_dh> it seemed to be a hard question , lol. 
23:03:06 <co_dh> in the book of Design Pattern , the authors prefer composition to inheritance.
23:03:18 <kulin> the book of Design Pattern?
23:03:22 <kulin> is this some holy text? hah
23:03:37 <kmc> kulin, for some people yeah
23:03:40 <p_l> kulin: in certain circles...
23:03:48 <kmc> the problem is that C++ and Java have no simple way to delegate a bunch of methods to a object member
23:04:09 <co_dh> well, it's not a holy book for me , and I don't like it either. but it's famous, right?
23:04:12 <lispy> OO inheritance is like using Haskell type classes to solve problems.  When you need it, it's good, but you rarely need it.
23:04:26 <kulin> it might be, i am a very ignorant person, i just found the phrasing funny
23:04:30 <kmc> lispy, i'd argue you never need implementation inheritance.  composition is always nicer
23:04:36 <kulin> nothing against you co_dh
23:04:50 <kmc> as usual the big debates in "enterprise OOP" circles are about which way is better to work around some C++/Java flaw, and not about any kind of actual theory of OOP
23:04:58 <kmc> just like the Design Patterns text itself
23:05:47 <co_dh> kmc: I should take a note of what you said, and use for future . 
23:06:02 <lispy> kmc: I don't do enough implementation or design work in OOP languages to think of an example where inheritance is "Right" but I swear I've seen examples
23:06:43 <kmc> well implementation inheritance is sometimes the lesser-of-two-evils workaround for this Java/C++ flaw
23:06:52 <kmc> so if you judge OOP by those languages you may come to that conclusion
23:07:13 <lispy> I do agree that composition is sexy
23:07:23 <kmc> heh
23:07:27 <lispy> We do it all the time in Haskell and it's amazing.  laziness for the win.
23:08:02 <kulin> composition being (doSomething . makeDoable) ?
23:08:17 <lispy> kulin: that's one example of composition
23:08:21 <co_dh> what's the relationship between composition and algebra data type ? are they the same? 
23:08:25 <lispy> kulin: we also do it with out data types
23:08:47 <co_dh> with out or with our ? 
23:08:59 <lispy> kulin: Haskell is highly composable.  Purity and laziness make composability very natural.
23:09:12 <lispy> co_dh: good catch, with our
23:10:26 <kmc> co_dh, what relationship do you see between the two?
23:10:32 <kmc> they are pretty distinct ideas
23:10:51 <kulin> i think inheritance can be quite nice when it comes to things like Ord, I would hate to have to do fromIntegral
23:11:48 <co_dh> kmc: I think List a = [] |  cons a List[a] as a composition 
23:12:18 <co_dh> I think cons as composition, maybe I'm wrong. 
23:12:27 <lispy> data [a] = [] | a : [a]
23:13:01 <co_dh> can I say (:) is a compostion? 
23:13:11 <co_dh> lispy: thanks.
23:13:53 <kmc> co_dh, in the general sense of the word yes
23:13:54 <fizruk> hi all! I'm trying to install llvm package and get the following: http://hpaste.org/30194...
23:14:06 <kmc> in the sense of composition as "some stuff combined"
23:14:15 <kmc> however not in the sense of (.) as function composition
23:14:24 <lispy> co_dh: yes, I think you can.  It's what the OO pattern of composition can be about too.  You can either compose different objects together or objects that form an algebra
23:14:26 <co_dh> kmc: thanks.
23:15:49 <lispy> co_dh: in OO you can use composition for reuse or for what haskellers would call constructing terms
23:16:02 <lispy> the two uses are different
23:16:26 <lispy> So, if you made classes that correspond to parts of your abstract syntax you can compose them (that's the term style)
23:17:01 <lispy> Or you could make a generic Foo class and stick an object of that type inside another class.  For example, Foo is a cache and you use it inside a web browser class.
23:17:02 <kulin> i wish i understood why hs-boot exists at all, it doesn't provide any additional information to the compiler
23:17:19 <kulin> is it likely that it will eventually just be part of the standard ghc compile?
23:18:11 <co_dh> lispy: thanks. 
23:18:15 <kmc> kulin, i don't think it's likely, as the recursive-imports system is considered a dark corner
23:18:19 <lispy> kulin: What do you need hs-boot for?
23:18:30 <kmc> it's best not to need recursive imports in the first place
23:18:44 <kmc> it exists for a few tricky reasons regarding the building of 'base' and such
23:18:44 <lispy> You can (always?) fix recursive modules by introducing new modules that break the cycle
23:18:52 <co_dh> In fact, I think composition is a very abstract concept as in Category theory's composition. 
23:19:05 <kulin> ya but adding a new module is a significant ammount of work
23:19:06 <kmc> anyway i think you're right that a preprocessor / distinct parsing mode for GHC could eliminate the need for a separate file
23:19:08 <kulin> for no reason
23:19:42 <kulin> i guess it wont come up as much for me in the future though, im basically done with my ffi wrappings, and that is really the only place it matters
23:19:43 <lispy> kulin: I would argue that needing hs-boot files points to a poor design that should be corrected
23:20:37 <kulin> i dont know about that lispy, if two modules depend on each other, that doesnt say bad design to me
23:21:02 <kulin> i mean withen one module all your functions likely depend on each other
23:22:09 <kulin> perhaps the problem is that i view modules in multiple layers while haskell does not, i consider there to be a project module, above all the rest, and then file modules I create to seperate concerns
23:24:09 <kulin> oh well enough about that :)
23:32:02 <lispy> has anyone gotten haskell running on android phones yet?
23:35:41 <kmc> i'm working on it; have built various stuff using GHC as a cross compiler
23:38:06 <co_dh> kmc: are you compile to java byte code from hs source code ? or compile from HS to machine code and call from andriod? 
23:38:57 <kmc> the latter
23:39:08 <kmc> Haskell to C to machine code, loaded as a JNI library
23:39:27 <co_dh> kmc: thanks.
23:46:30 * hackagebot detrospector 0.1 - Markov chain text generator  http://hackage.haskell.org/package/detrospector-0.1 (KeeganMcAllister)
23:53:42 <djahandarie> I wonder if there are any Japanese Haskellers
23:54:24 <pikhq> There's one or two people here who join from a co.jp domain name.
23:54:34 <pikhq> And I know there's been a couple companies in Japan *hiring* Haskellers.
23:54:36 <djahandarie> There is the Japanese wikipedia page for Haskell... but I can't really find much about ハスケル on the internet aside from that
23:54:44 <pikhq> So I'm going with "yes".
23:54:57 <djahandarie> And yeah, I know of at least one of the companies, but none of them are Japanese
23:55:18 <djahandarie> (Thinking of tsuru)
23:55:36 <pikhq> Seems that the majority of the interest, though, is coming from Europe and North America.
23:55:40 <NtroP> There's the Tokyo Society for the Application of Currying, but AFAIK it's run by a western company
23:56:48 <pikhq> Actually. How many American Haskellers are there? Probably rather a lot, but I suspect there's more hailing from Europe for some reason.
23:57:41 <djahandarie> And there are only three people connecting from jp domains atm
23:57:58 <djahandarie> I think there are more americans... in here at least
23:58:09 <pikhq> *shrug*
23:58:42 <pikhq> Actually, now I'm really wondering... What languages are actually popular in Japan?
23:58:48 <djahandarie> Ruby? :P
23:58:57 <djahandarie> Dunno if that is true or not
23:59:09 <winxordie> you mean MatzLisp? :P
23:59:13 <kmc> Tsuru Capital is a Japanese options-market-maker using Haskell
