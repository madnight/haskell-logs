00:00:17 <zenzike> mm_freak: exactly
00:00:27 <ManateeLazyCat> deteego: Can you paste your code? 
00:00:42 <mm_freak> zenzike: a HakyllAction doesn't have a context
00:00:54 <mm_freak> a HakyllAction Context Context is a Context /transformer/
00:01:13 <deteego> ManateeLazyCat: I don't want to paste my code because Im doing an assignment, and some people from Haskell may be in this channel
00:01:28 <arunk> mm_freak: any luck getting a program compiled using wxHaskell on windows ?
00:01:49 <zenzike> mm_freak: agreed, I actually have an HakyllAction () Context, with which I can run runHakyllContext to give me a HakyllAction, which I can use runReaderT to get out a Context
00:01:53 <mm_freak> arunk: not yet, i'll tell you, when i'm there
00:02:09 <arunk> ok thanks
00:02:23 <mm_freak> zenzike: well, you can make a HakyllAction, which sorts by context
00:02:55 <zenzike> *to give me a Hakyll, wihch I can use runreaderT ...
00:03:02 <mm_freak> zenzike: just take a list of actions and sequence them (you'll need to write a little helper function for that)
00:03:23 <mm_freak> then sort the contexts
00:03:36 <mm_freak> are you trying to sort by date or something?
00:03:50 <zenzike> mm_freak: ultimately, yes!
00:04:03 <ManateeLazyCat> deteego: Well, we can't help you if you can't paste code.
00:04:18 <zenzike> mm_freak: maybe I'm going about this completely the wrong way :-)
00:04:24 <mm_freak> zenzike: the easiest way is to name your files accordingly, then use getRecursiveContents, then finally use createListing
00:04:32 <mm_freak> that's how i do it
00:04:37 <zenzike> mm_freak: yeah, I'm trying to avoid exactly that
00:04:38 <deteego> how does one force evaluation of an expression again
00:04:52 <zenzike> mm_freak: some of my posts use a $date tag in the actual body of the post
00:05:00 <zenzike> they're not always sorted by file date
00:05:18 <zenzike> or at least, not all files are named in the date format
00:06:28 <mm_freak> zenzike: i don't think there is an easy non-dirty way to do it…  for example to generate my main page listing, i render into a temporary file, then read it back
00:06:30 <zenzike> mm_freak: (currently I'm doing what you suggest, but I'd rather maintain post dates in the file itself, rather than in the file name)
00:07:13 <mm_freak> it's an ugly solution, but it works
00:07:27 <atude> I installed mathematica on linux
00:07:28 <mm_freak> deteego: seq
00:07:33 <atude> it looks really ugly
00:07:35 <ManateeLazyCat> arunk: gtk2hs install successful?
00:07:50 <zenzike> mm_freak: yeah, it does all feel a bit messy! Ultimately, I'd like it if paths could be generated easily from the context itself, so that the date in the Context can be placed at the beginning of the url for me
00:08:39 <zenzike> mm_freak: what's your website btw? I'd be interested to see what other have achieved with hakyll
00:10:00 <deteego> ok well that aint working
00:10:19 <mm_freak> zenzike: dates can be generated out of the context
00:10:27 <mm_freak> uhm
00:10:32 <mm_freak> URLs i mean
00:10:40 <mm_freak> zenzike: http://ertes.de/
00:11:14 <mm_freak> i have converted from static pages and a blogger.com blog to hakyll
00:11:20 <deteego> blewh
00:11:30 <deteego> I dont think using thunks for mutually recursive bindings is the solution
00:11:57 <mm_freak> deteego: why not?
00:12:17 <deteego> well its not working for me :(
00:12:30 <deteego> (exp is being evaluated before the thunks are)
00:12:32 <adnap> I'm having a problem with my function "negate" in this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29846#a29846
00:12:43 <deteego> or at least I think thats what is happening
00:12:48 <zenzike> mm_freak: nice site :-) I moved from blogger to hakyll too
00:12:53 <zenzike> it makes so much more sense
00:12:59 <adnap> Basically, I think the problem is that the vectors could be over different fields.
00:13:17 <adnap> GHCI gives a possible fix, but I don't understand it.
00:13:28 <mm_freak> zenzike: thanks =)
00:13:50 <deteego> mm_freak: is using thunks the normal practise for evaluating mutually recursive bindings?
00:14:01 <deteego> either that or its a dependancy graph
00:14:26 <zenzike> mm_freak: you should add commenting to your site, I've put a disqus feed into mine, and it works pretty well
00:14:34 <mm_freak> adnap: looks like a name clash to me
00:14:54 <adnap> mm_freak: It's not.
00:15:37 <adnap> mm_freak: You're referring to Prelude.negate, right?  I did a qualified import.
00:15:40 <mm_freak> adnap: try type families or functional dependencies
00:15:55 <mm_freak> because yes, it's ambiguous
00:15:58 <dmead> hey channel
00:16:16 <mm_freak> zenzike: i'm not sure i want comments on my site
00:16:22 <adnap> mm_freak: I may have misunderstood what you meant by a name clash.
00:16:26 <mm_freak> zenzike: because that makes it less visited =)
00:16:29 <dmead> if you're looking at ASTs generated by haskell-src-exts, is there a nice pretty printer that shows the ast and not the source?
00:16:37 <zenzike> mm_freak: lol :-)
00:16:50 <adnap> mm_freak: You're not referring to the fact that Prelude.negate and Vector.negate share the same name, right?
00:16:51 <mm_freak> adnap: no, but i didn't see the qualified import =)
00:16:57 <arunk> ManateeLazyCat: its installed on both ubuntu and windows. but strangely its working fine in windows but i'm having some truoble running the basic code in ubuntu
00:17:00 <adnap> mm_freak: Oh
00:17:07 <Cale> dmead: Does show do that?
00:17:24 <mm_freak> adnap: but what do you need the second type for anyway?  it's not used
00:17:28 <adnap> mm_freak: Basically, the problem is that the function negate doesn't deal with the Field b.
00:17:56 <dmead> Cale: it's not formatted, very unreadable
00:18:03 <dmead> i was just wondering if there were a nicer version
00:18:03 <adnap> mm_freak: GHCI complains because I guess the new Vector could be over a different Field.
00:18:14 <Cale> dmead: But you can pretty print it using haskell-src-exts itself then ;)
00:18:34 <mm_freak> adnap: a vector space should rather look like this:  class VectorSpace a where type Scalar; (+) :: a -> a -> a; (*) :: Scalar -> a -> a
00:18:43 <dmead> prettyprinting a parseresult just gives something that resembles the source
00:18:45 <dmead> not an ast
00:18:59 <Cale> dmead: I mean parseExp the result of show
00:19:02 <arunk> ManateeLazyCat: it says 'window' not in scope for the basic Hello World program. though the exact same thing compiles and runs fine on windows
00:19:09 <Cale> dmead: and then prettyprint the resulting expression
00:19:29 <dmead> ah
00:19:30 <dmead> k
00:20:14 <ManateeLazyCat> arunk: ? you mean demo/hello.hs ?
00:20:32 <adnap> mm_freak: The type is used for scalar multiplication.  It is more general because I could have a space over any field, such as the complex numbers or the reals.
00:20:45 <dmead> Cale: oh i'm reading it from a file with parseFile
00:20:48 <arunk> i just grabbed it from the web page - haskell.org/gtk2hs/documentation/#examples
00:21:01 <dmead> Cale: and i just want a nice version of the ast from that source file
00:21:03 <arunk> its the basic one with a window and a button that says Hello World
00:21:13 <adnap> mm_freak: Here is the error I get: http://pastebin.com/vjCtxgRC
00:21:43 <mm_freak> adnap: you still need type families or functional dependencies, but i think your concept is a bit flawed
00:22:30 <adnap> mm_freak: My concept, as in, the way I am using a muti-parameter type class?
00:22:43 <mm_freak> no, the way you structure your type classes
00:22:51 <mm_freak> the vector operations are incompatible with the field operations by concept
00:23:22 <adnap> mm_freak: I don't understand what you mean.
00:23:24 <mm_freak> you need a separate class for what you call (*), which is an outer product
00:23:41 <mm_freak> class OuterProduct a where (*) :: a -> a -> a
00:24:15 <mm_freak> or better call it (.*.) or something to keep it separate from vector multiplication
00:24:18 <adnap> mm_freak: Right
00:24:34 <adnap> mm_freak: Not all vectors define an outer product.
00:24:47 <mm_freak> exactly, but what matters is the type of (.*.)
00:24:56 <mm_freak> scalar multiplication has a different type
00:25:00 <ManateeLazyCat> arunk: Open gtk.tar.gz file, have many demo program under demo sub-directory.
00:25:05 <adnap> mm_freak: Right
00:25:16 <adnap> mm_freak: I'm not seeing the problem.
00:25:37 <mm_freak> adnap: let me write an example
00:26:32 <adnap> mm_freak: Okay, sorry for the trouble.  Also, today is my first day using muti-parameter type classes, and I still don't know about functional dependencies yet.
00:27:44 <arunk> ManateeLazyCat: sorry i think it might have been a problem with copy pasting it (tabs or something) i wrote a basic program, and it seems to work.
00:28:08 <arunk> ManateeLazyCat: ok going to get that. is it in cabal unpack gtk ?
00:28:52 <ManateeLazyCat> arunk: Oh, I have fix tab problem in darcs version. you can copy them from http://code.haskell.org/gtk2hs/gtk/demo/
00:29:31 <ManateeLazyCat> arunk: Best use "darcs get http://code.haskell.org/gtk2hs/" fetch darcs version, then you can copy any demo code and haven't tab problem.
00:29:33 <arunk> found the demos, and they are compiling and working fine
00:29:44 <ManateeLazyCat> arunk: Great.
00:29:46 <arunk> thanks ManateeLazyCat
00:30:15 <ManateeLazyCat> arunk: I'm test newest GIO/GTK APIs, you can use all GTK+ APIs in gio-0.12.0 and gtk-0.12.0 
00:31:22 <ManateeLazyCat> arunk: If you don't mind unly gtk+ look, i suggest you stick on gtk2hs, we have many developers, and release frequently.
00:31:54 <mm_freak> adnap: you don't actually need multi-param type classes for this
00:31:56 <aristid> ManateeLazyCat: ugly gtk+ look? gtk+ looks nice for me :)
00:32:10 <ManateeLazyCat> aristid: I mean windows look. :)
00:32:21 <arunk> ManateeLazyCat: thats great thanks :)
00:32:30 <aristid> ManateeLazyCat: oh, i don't know how it looks on windows, because i use linux :)
00:32:40 <ManateeLazyCat> aristid: Me too. :)
00:32:50 <adnap> mm_freak: Okay
00:32:53 <arunk> ManateeLazyCat: the one thing i like about wx is that it looks like a native Mac on Mac, and native win on win, and like umm whatever it looks like on linux :)
00:33:09 <ManateeLazyCat> arunk: Yes, Mac is problem indeed.
00:33:40 <aristid> Qt is good about that i think
00:33:44 <ManateeLazyCat> arunk: In linux, i suggest gtk2hs better performance since it call gtk+ code directly
00:33:47 <adnap> mm_freak: But I'm not sure how to do it otherwise.  Someone said I could use an associated type instead, but I haven't figured out what that means yet.  I guess it's personal preference which way you do it.
00:33:55 <aristid> but qthaskell seems not to be very good
00:33:56 <ManateeLazyCat> aristid: QtHaskell is not open enough.
00:33:58 <arunk> right now i'm prototyping, and i guess for now this will work. but i might switch to wx later. the libraries feel similar, though slight difference in nomenclature
00:34:15 <jeltsch> ManateeLazyCat: In what way is QtHaskell not open enough?
00:34:17 <arunk> Qt is not open, well its GPL'd
00:34:29 <aristid> arunk: Qt itself is LGPL now
00:35:18 <arunk> aristid: but i thought i read somewhere that if you are using Qt for anything commercial, then you must get the commercial license
00:35:27 <aristid> arunk: outdated.
00:35:29 <ManateeLazyCat> jeltsch: I ask how to send patch to QtHaskell, but Author don't response.
00:36:02 <ManateeLazyCat> aristid: Qt is LGPL now.
00:36:08 <aristid> ManateeLazyCat: as i said.
00:36:13 <ManateeLazyCat> aristid: Sorry, is arunk 
00:36:22 <ManateeLazyCat> aristid: Wrong name completion. :)
00:36:27 <arunk> ahh thats pretty interesting
00:36:51 <ManateeLazyCat> arunk: IMO, if you don't use Mac, gtk+ good enough.
00:37:00 <arunk> though its one heavy package, it does look quite good on most platforms
00:37:01 <ManateeLazyCat> arunk: Both on Windows and UNIX.
00:37:23 <arunk> ManateeLazyCat: i ultimately want to build something that is cross-platform. linux/mac/win
00:37:24 <ManateeLazyCat> arunk: http://www.flickr.com/photos/48809572@N02/ the thing that gtk2hs can do.
00:37:49 <ManateeLazyCat> arunk: yes, gtk2hs cross-platform, just ugly look on Mac.
00:37:58 <jeltsch> ManateeLazyCat: Have you had a look at HQK? At the moment, I’m looking for ways to improve that. And since it’s “my” project, I can make patches accepted. :-)  I’m looking for supporters at the moment.
00:37:59 <ManateeLazyCat> arunk: It's GTK+ problem.
00:38:33 <aristid> @hackage HQK
00:38:33 <lambdabot> http://hackage.haskell.org/package/HQK
00:38:35 <ManateeLazyCat> jeltsch: Are you author of QtHaskell?
00:38:54 <aristid> jeltsch: what's the package name of HQK?
00:38:56 <jeltsch> ManateeLazyCat: I’m the author of HQK. It’s different from QtHaskell.
00:39:14 <jeltsch> aristid: No release until now.
00:39:24 <aristid> jeltsch: website?
00:39:30 <ManateeLazyCat> jeltsch: Sorry, i can't open http://hackage.haskell.org/package/HQK
00:39:32 <arunk> jeltsch: is it bindings to Qt ?
00:39:33 <jeltsch> Actually, it’s a generator for Qt bindings that is written in C++ at the moment.
00:39:33 <mm_freak> adnap: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29847#a29847
00:39:40 <mm_freak> the Scalar type is an associated type
00:39:58 <mm_freak> and the extension you need for that is called TypeFamilies
00:40:13 <mm_freak> arunk: wx takes forever to compile under windows =/
00:40:13 <jeltsch> aristid: http://haskell.org/haskellwiki/HQK
00:41:05 <arunk> mm_freak: yes it does take forever
00:41:09 <ManateeLazyCat> jeltsch: Looks interest...
00:41:15 <aristid> jeltsch: you should make a public github repository :)
00:41:35 <jeltsch> aristid: I would like to make a darcs repository. Would this be okay for you?
00:41:59 <aristid> jeltsch: well, i think github is a superior platform because it allows people to easily fork and submit patches that way
00:42:13 <ManateeLazyCat> jeltsch: Use patch-tag.com. :)
00:42:19 <aristid> in the end it's your decision of course
00:42:39 <aristid> the fork button on github really is ingenious
00:42:45 <ManateeLazyCat> jeltsch: So HQK still in developing ?
00:42:54 <jeltsch> ManateeLazyCat: Yes.
00:43:02 <adnap> mm_freak: Wow, that's cool.  Some of the syntax I've never seen before though.  Also, I just started learning Algebra, so I don't know about Rings or Semigroups yet.
00:43:27 <adnap> mm_freak: I guess you just gave me some spoilers. :)
00:43:47 <mm_freak> adnap: you know about fields, but not of rings?  that's odd ;)
00:43:51 <mm_freak> because every field is a ring
00:43:55 <jeltsch> ManateeLazyCat, aristid: At the moment, I’m asking myself whether it would be good to reimplement this thing in Haskell. There is now the cgen package, which can generate Haskell–C++ bindings. Haven’t had a deeper look at it though.
00:44:04 <adnap> mm_freak: Spoiler alert!
00:44:06 <jeltsch> this thing → HQK
00:44:20 <mm_freak> adnap: hehe sorry
00:44:20 <adnap> mm_freak: I just know that a Field is a more general scalar.
00:44:26 <ManateeLazyCat> jeltsch: Looks great, but i perhaps won't port to Qt. I'm developer of gtk2hs, i has update 99% GTK+ APIs in gtk2hs darcs version, i'm happy with gtk2hs now. Though i think Qt's signal-slot is better framework....
00:44:36 <mm_freak> adnap: "scalar" is a term used for vector spaces
00:44:40 * hackagebot tls 0.1 - TLS protocol for Server and Client sides  http://hackage.haskell.org/package/tls-0.1 (VincentHanquez)
00:45:19 <mm_freak> adnap: in general functions over fields themselves form a field, but functions are vectors, too
00:45:32 <mm_freak> so is a function a scalar or a vector? =)
00:45:37 <ManateeLazyCat> jeltsch: When my project just starting, i want switch to Qt, but now looks too late.....
00:45:46 <jeltsch> ManateeLazyCat: :-(
00:45:57 <adnap> mm_freak: I've never seen this type inside a class thing.
00:46:02 <ManateeLazyCat> jeltsch: http://www.flickr.com/photos/48809572@N02/ my gtk2hs project
00:46:20 <mm_freak> adnap: types inside classes are called associated types…  it's an extension
00:46:57 <ManateeLazyCat> jeltsch: I have try QtHaskell before, binding is not complete and terrible compile time.
00:47:22 <tab> ManateeLazyCat: just curious, are you developing the webkit bindings too ?
00:47:28 <ManateeLazyCat> jeltsch: I think you can looks the code of QtHaskell, and find how QtHaskell work.
00:47:33 <ManateeLazyCat> tab: yes.
00:47:44 <adnap> mm_freak: Yeah, this is all new to me.  Someone just told me about this earlier.  I've only been programming in Haskell for a few months.  What's the best page to read for an introduction?
00:47:49 <tab> ManateeLazyCat: cool
00:47:53 <ManateeLazyCat> tab: I'm maintain many glib base package.
00:48:00 <adnap> mm_freak: An introduction to the extras, that is.
00:48:15 <tab> ManateeLazyCat: do you know if anyone is working on the soup binding below webkit ?
00:48:17 <mm_freak> adnap: don't worry about them too much…  you'll learn them as you go
00:48:29 <jeltsch> ManateeLazyCat: AFAIK, QtHaskell uses Smoke. I don’t like that since it means that library calls are resolved at runtime. I want a traditional compiletime solution. Smoke is more intended for scripting languages.
00:48:51 <ManateeLazyCat> tab: Well, soup binding need more work, but i think it's not hard.
00:48:52 <mm_freak> adnap: better write a real application…  that's the best way to learn, much better than reading too much =)
00:49:13 <adnap> mm_freak: Yeah, I'm trying, but I get addicted to learning the language.
00:49:19 <tab> ManateeLazyCat: i'll probably submit patches if no one is working on it
00:49:25 <ManateeLazyCat> tab: Answer is most APIs in WebkitGtk+ has finish, except Soup/JavascriptCore part.
00:49:37 <ManateeLazyCat> tab: Cool, go on.
00:49:41 <tab> ManateeLazyCat: got block by the lack of soup binding when trying to do a POF with webkit
00:49:47 <tab> POC not POF
00:49:53 <adnap> mm_freak: Also, I'm worried that I'll really hate using imperative languages once I learn too much.
00:49:58 <ManateeLazyCat> tab: You can send patch gtk2hs-devel list or my mail.
00:50:03 <mm_freak> adnap: trust me, you will ;)
00:50:08 <ManateeLazyCat> tab: My mail is lazycat.manatee@gmail.com
00:50:10 <mm_freak> (hate imperative languages)
00:50:15 <tab> ManateeLazyCat: thanks
00:50:29 <tab> ManateeLazyCat: i'm slowly working out my TODO list ..
00:50:37 <ManateeLazyCat> tab: I want binding soup too, just too busy on gtk2hs haven't time.
00:50:55 <tab> ManateeLazyCat: i raise a ticket on webkit btw, #1201
00:50:57 <adnap> mm_freak: I really want to program games in Haskell, and use FRP, but I feel like that's overzealous.
00:51:04 <tab> ManateeLazyCat: i'll probably send patch as well, if no one beat me to it
00:51:05 <ManateeLazyCat> tab: Even one line code improve is good. :)
00:51:10 <mm_freak> adnap: personally i learned haskell by reading "the haskell road to logic", but it's really dry
00:51:32 <adnap> mm_freak: I learned from "Gentle Intro..." and "Learn You a Haskell".
00:51:54 <ManateeLazyCat> jeltsch: So you aim is binding all KDE library?
00:51:56 <mm_freak> adnap: a lot of people recommend Real World Haskell
00:52:01 <adnap> mm_freak: I've also been reading "All About Monads", but I'm not done with it.
00:52:02 <mm_freak> but i haven't read it
00:52:57 <jeltsch> ManateeLazyCat: This would be ideal. I’d also like to bind to Qt, so that you can write pure Qt applications as well as KDE applications.
00:53:22 <ManateeLazyCat> tab: BTW, if you have, can you help me binding webDataSourceGetData in module WebDataSource?
00:53:28 <mm_freak> adnap: you may want to try my mine, too, but it focusses on monads
00:53:41 <ManateeLazyCat> tab: Then we can save web page for offline browse. :)
00:54:27 <adnap> mm_freak: "my mine"?
00:54:45 <mm_freak> s/my //
00:54:48 <mm_freak> adnap: http://ertes.de/articles/monads.html
00:55:17 <ManateeLazyCat> jeltsch: One my worried about Qt is C++'s ABI problem, 
00:55:32 <ManateeLazyCat> jeltsch: C and gtk2hs haven't ABI problem.
00:55:51 <jeltsch> ManateeLazyCat: What do you mean?
00:55:55 <mm_freak> (progress meter:  wxwidgets is still compiling under windows…  maybe i should switch back to VirtualBox)
00:56:00 <adnap> mm_freak: Thanks
00:56:31 <mm_freak> adnap: you're welcome
00:56:35 <jeltsch> ManateeLazyCat: You cannot bind to C++ directly. The portable way is to generate a layer around your C++ library that exports C functions and then bind to these. This is what HQK does.
00:56:57 <tab> ManateeLazyCat: I can try ;)
00:57:06 <ManateeLazyCat> jeltsch: So you need port to C then binding to C ?
00:57:14 <ManateeLazyCat> s/port/export
00:57:17 <co_dh> adnap: I want to program game in haskell too, with FRP, 
00:57:28 <co_dh> but I find FRP would be so hard to undrestand.
00:57:31 <mm_freak> ManateeLazyCat: what turned me away from Qt is the fact that it uses modified C++
00:57:43 <mm_freak> you need to pass your code through a transformation program, first
00:57:52 <ManateeLazyCat> tab: Thanks a lots.
00:57:55 <jeltsch> ManateeLazyCat: Basically, yes.
00:57:59 <mm_freak> (i didn't want to learn a new language)
00:58:12 <mm_freak> co_dh: try elerea, it's easy to understand
00:58:30 <mm_freak> and it's fast, probably fast enough for games
00:58:40 <ManateeLazyCat> tab: Infact, i have update webkit APIs to newest version, if you can finish webDataSourceGetData and soup part, webkit is perfect.
00:59:05 <ManateeLazyCat> tab: http://www.flickr.com/photos/48809572@N02/ have screenshot about Haskell/Webkit browser and feed-reader. :)
00:59:18 <kulin> anyone have experience with c2hs? i am having a tough time figuring out what I am doing with the binding of the header to the chs file, the #include "example.h" is throwing errors because any other headers it includes cannot be found, but if i dont use c2hs and just compile through cabal with manually written foreign imports, there are no errors
00:59:19 <jeltsch> ManateeLazyCat: My approach is to have three layers: One C++ layer that wraps method calls into ordinary functions and exports these as C functions. One Haskell layer with FFI declarations for the C functions. One Haskell layer that makes accessing the library nicer and restores type safety.
00:59:26 <co_dh> mm_freak: I tried, thanks. elerea used a lot of IORef, it's like programming in C++ 
00:59:49 <mm_freak> co_dh: huh?  i didn't need IORefs with elerea
01:00:08 <ManateeLazyCat> kulin: Looks the source code of gtk2hs.
01:00:10 <co_dh> mm_freak: elerea implemented with IORef , and I don't like it. 
01:00:24 <ManateeLazyCat> kulin: Many demo .chs file you can study.
01:00:34 <mm_freak> co_dh: elerea is meant to be fast, otherwise yampa is a good option
01:00:48 <kulin> it seems like a cabal issue to me, but i will look at gtk2hs
01:00:53 <mm_freak> but i found yampa harder to understand
01:01:06 <co_dh> apple changed their license, so we can use haskell to write ipphone game now, hahaha
01:01:33 <tab> ManateeLazyCat: sounds good
01:01:41 <tab> ManateeLazyCat: btw, the feed reader seems quite nice
01:01:52 <ManateeLazyCat> tab: Thanks. :)
01:01:54 <tab> ManateeLazyCat: i'm using liferea and i hate it, very dodgy
01:02:01 <tab> ManateeLazyCat: i might try use your feed reader :)
01:02:03 <adnap> mm_freak: Wow, it was really easy to figure out how all the algebraic structures are related.  Now I just need to figure out this associated type business.
01:02:10 <co_dh> mm_freak: in fact, I found elerea 's source code is harder to understand, due to I can't visualize the data with a debugger.
01:02:28 <ManateeLazyCat> tab: I think my reader is faster than liferea.
01:02:45 <ManateeLazyCat> tab: Haskell damn fast backend threads fetch feed. :)
01:02:52 <tab> ManateeLazyCat: what are you using for storage ?
01:03:13 <mm_freak> co_dh: well, the implementation is opaque…  as said, elerea is meant to be fast, so i guess it's acceptable that it uses imperative stuff under the hood
01:03:30 <ManateeLazyCat> tab: I haven't implement storage web page, it's need finish webDataSourceGetData first.
01:03:41 <tab> ManateeLazyCat: i see :)
01:03:43 <ManateeLazyCat> tab: Then i can write webpage data to disk.
01:04:05 <ManateeLazyCat> tab: Infact, just webDataSourceGetData haven't finish, others function in WebDataSource have finish.
01:04:26 <ManateeLazyCat> tab: Now, my feed reader need re-fetch page again.
01:04:28 <mm_freak> adnap: as an exercise try writing instances for Integer =)
01:04:48 <co_dh> mm_freak: I don't like opaque, because it's hard to understand the code, and if there are bugs, we have to read it's implementations. 
01:05:07 <ManateeLazyCat> tab: Since webkit use cache technology, it's not too slow, but i think best solution is save page when webkit first fetch it.
01:05:17 <tab> ManateeLazyCat: could you just fetch with some random library, and feed the data to webkit with a fromString ?
01:05:21 <mm_freak> co_dh: i haven't seen a single FRP implementation, which i understood =)
01:05:39 <co_dh> mm_freak: lol, me too. 
01:06:21 <adnap> mm_freak: It would basically be the same as for Double.
01:06:30 <tab> ManateeLazyCat: scrap that, you can do that for everything else linked on a page like images ..
01:06:35 <ManateeLazyCat> tab: Yes, i was consider use curl fetch page then feed webkit, but i think better use WebDataSource API since it design for save page.
01:06:48 <tab> ManateeLazyCat: yes
01:07:07 <dmead>   @hoogle UnQual
01:07:12 <dmead> @hoogle UnQual
01:07:13 <lambdabot> Language.Haskell.Syntax UnQual :: HsName -> HsQName
01:07:13 <lambdabot> Language.Haskell.ParseUtils checkUnQual :: HsQName -> P HsName
01:07:26 <ManateeLazyCat> jeltsch: I'm afraid your *first* layout, too many tweak work.
01:07:57 <jeltsch> ManateeLazyCat: I didn’t understand this. :-( 
01:08:52 <mm_freak> adnap: nope
01:08:55 <mm_freak> adnap: try it out
01:09:18 <ManateeLazyCat> jeltsch: If you just do FFI layout, it's easy to change if Qt change some APIs, but you build C layout wrap Qt function, that will speed so much time and buggly. 
01:09:50 * hackagebot text-icu 0.4.0.0 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.4.0.0 (BryanOSullivan)
01:09:51 <jeltsch> ManateeLazyCat: HQK is a binding *generator*. It does these things automatically!
01:09:53 <ManateeLazyCat> jeltsch: We even have some tools generate gtk2hs code automatic, though not "full automatic"
01:10:49 <ManateeLazyCat> Wow, text-icu release new version,
01:11:13 <jeltsch> ManateeLazyCat: AFAIK, in Gtk2Hs you edit the generated code by hand. We want to avoid that. If manual intervention is necessary, it should be done in the form of config files for the generator that state the exceptions to the rule.
01:11:15 <ManateeLazyCat> Hope it include "automatic encoding detect" part.....
01:11:31 <ManateeLazyCat> jeltsch: No, we generate gtk2hs from C header file.
01:11:54 <ManateeLazyCat> jeltsch: Just some complicate function need tweak by hand.
01:13:02 * ManateeLazyCat I have so many encode in environment.....
01:15:01 <ManateeLazyCat> jeltsch: Infact, 99% code is generate by APIs generator, we just need check document and tweak some complicated functions
01:16:39 <jeltsch> ManateeLazyCat: Okay, but it is also the goal for HQK to generate almost 100 % of the API automatically. And if we are successful with this, it’s not a big problem that we need an extra binding layer.
01:17:03 <ManateeLazyCat> jeltsch: Sound great.
01:17:22 <ManateeLazyCat> jeltsch: I want to try when you release it. :)
01:18:20 <adnap> mm_freak: Ah, well, the integers are not a field because there is no multiplicative inverse.
01:19:21 <mm_freak> adnap: right
01:20:01 <mm_freak> adnap: now try to implement:  instance Ring a => VectorSpace a
01:21:55 <adnap> mm_freak: I'm not sure if I can since I don't know what's going on syntactically with what you already have in that regard.
01:22:27 <adnap> mm_freak: I'm reading about it now.  I'm reading this page: http://www.haskell.org/haskellwiki/GHC/Type_families
01:24:51 <mm_freak> cool…  apparently i can cross-compiled wxwidgets for windows under linux
01:24:57 <mm_freak> that's going to be MUCH faster
01:25:12 <mm_freak> adnap: yeah, read that one first
01:26:11 <aruns> mm_freak: can you cross-compile Haskell ?
01:28:43 <mm_freak> aruns: not natively, but GHC works well under wine
01:28:56 <ManateeLazyCat> tab: My source code at https://patch-tag.com/r/AndyStewart that beginning with manatee-*
01:29:20 <ManateeLazyCat> tab: For compile it, you need download *newest* code from gtk2hs darcs.
01:29:39 <ManateeLazyCat> tab: Other depend package can found at hackage.
01:30:18 <aruns> mm_freak: ahh ok
01:30:36 <ManateeLazyCat> tab: Install manatee is pretty easy, put all manatee package under same directory, then switch 'manatee' package do "./repos.sh install", that's all.
01:30:38 <adnap> mm_freak: Well, shouldn't (.+.) just be (+) and (*.) be (*)?
01:31:40 <ManateeLazyCat> tab: There still some issue in gio darcs version, i will fix it soon.....
01:32:13 <mm_freak> adnap: no, that's the point i was trying to make
01:32:44 <mm_freak> adnap: vector addition and scalar multiplication are /not/ compatible with the corresponding semigroup/ring operations
01:33:26 <mm_freak> even though they are mostly the same, this cannot be said in general
01:33:27 <adnap> mm_freak: Oh, okay.
01:34:16 <adnap> mm_freak: So a 1-D vector has different properties from elements of a ring?
01:34:31 <mm_freak> adnap: not necessarily
01:34:51 <adnap> mm_freak: But it can, so it breaks the generalization.
01:34:56 <adnap> mm_freak: Is that right?
01:35:21 <mm_freak> yes
01:36:17 <mm_freak> a ring is a set together with two operations and some more properties…  a vector space is a ring, a set and two operations
01:36:37 <mm_freak> vector addition /can/ be the same as addition in the corresponding ring, but that's not required
01:37:21 <mm_freak> anyway, i'm giving you spoilers again =)
01:37:35 <adnap> mm_freak: Ha-ha...
01:37:43 <adnap> Okay, so I have a question about the associated type.
01:38:01 <ManateeLazyCat> mm_freak: Infact, i think Haskell + C is enough, not need other language. :)
01:38:24 <JHoglund> Good morning! I have a function, value:: Hand -> Integer, I'd like to give the "value" function the ability to accept either a hand or a card, and use pattern matching to select the proper valuing algorithm.
01:38:26 <adnap> mm_freak: So, the type parameter of the associated type needs to coincide with that of the type class, right?
01:38:37 <mm_freak> ManateeLazyCat: what about scheme?
01:38:45 <JHoglund> How do I do that, I haven't found any example syntax and this didn't work: value :: (Hand | Card) -> Integer
01:39:30 <ManateeLazyCat> mm_freak: scheme is good, but i prefer to Haskell. :)
01:39:46 <mm_freak> adnap: not necessarily…  i just used it in this case, so i don't need scoped type variables =)
01:39:49 <QtPlatypus> JHoglund: Thats not allowed.
01:40:20 <mm_freak> hmm, in fact it doesn't work with scoped type variables
01:40:24 <QtPlatypus> You can do something like that with typeclasses though.
01:40:44 <JHoglund> QtPlatypus: Oh, okay, there's no neat little trick to achieve the same effect? I need to implement valueHand :: and valueCard :: separately
01:40:50 <ManateeLazyCat> mm_freak: Since i love elisp, scheme is better, but now my favorites is Haskell, i use Haskell do everything ... :)
01:41:06 <mm_freak> ManateeLazyCat: what about unlambda?
01:41:22 <QtPlatypus> JHoglund: Or have a typeclass.
01:41:37 <JHoglund> QtPlatypus: Rocker science!
01:41:40 <JHoglund> Rocket*
01:42:02 <tab> ManateeLazyCat: are you reimplementing a full desktop suite ?
01:42:12 <QtPlatypus> There pritty sane in simple terms.
01:42:38 <ManateeLazyCat> tab: Aim is OS, but first step is "desktop", i call it "Integrated Live Environment". :)
01:42:51 <ManateeLazyCat> tab: Simple answer : yes. :)
01:43:07 <tab> ManateeLazyCat: impressive
01:43:49 <ManateeLazyCat> tab: Now have include : editor, file-manager, browser, image-viewer, irc-client, mplayer-client, pdf-viewer, process-manager, feed-reader.
01:44:17 <ManateeLazyCat> tab: I plan add mail-client and terminal after i relase gio-0.12.0 and gtk-0.12.0
01:44:45 <ManateeLazyCat> tab: Then next time send gtk2hs patches is after gtk+-3.0 release. :)
01:44:55 <mm_freak> @unlambda `r``.?``.m`. ``.o`.o`.p`. `.t`.u``.b`.a`. `.t`.a``.W.h.o.r.e.!i
01:44:55 <lambdabot>   What about poor me?!
01:45:11 <ManateeLazyCat> mm_freak: Unlambda like a secret language. :)
01:45:31 <mm_freak> yeah, look at the end of the source code =P
01:46:10 <ManateeLazyCat> mm_freak: It's explode my head....
01:46:35 <mm_freak> apparently Lazy K is more difficult
01:48:28 <ManateeLazyCat> tab: Too many glib-base libraries speed so much time, i need someone help me finish some binding..... unfortunately, i haven't found new developer at here.
01:48:56 <atude> is there any way to speed up mathematica on linux?
01:49:20 <ManateeLazyCat> tab: BTW, do you use emacs? I have elisp extension that convert C documentation to Haddock style. :)
01:49:35 <ManateeLazyCat> tab: http://www.emacswiki.org/emacs/gtk2hs.el
01:49:41 <tab> ManateeLazyCat: no, plain vim user :)
01:49:58 <adnap> mm_freak: What does it mean when you do this: type Scalar (a -> a) = a  Does it mean that you're taking the (a -> a) and reducing it to a for the Scalar?
01:49:59 <ManateeLazyCat> tab: Oh, never mind. :)
01:50:33 <adnap> mm_freak: Oh wait, I get it.
01:50:53 <adnap> mm_freak: You basically define what Scalar is given a certain type argument.
01:51:23 <adnap> mm_freak: So you could have Scalar Vector2 = Double
01:51:44 <ManateeLazyCat> tab: Do you want join gtk2hs team? More contribution. 
01:52:11 * ManateeLazyCat I'm find new developer join gtk2hs, help us perfect gtk2hs.
01:52:26 <adnap> mm_freak: I should probably have type Scalar Vector a = a.
01:53:12 <tab> ManateeLazyCat: i'm not quite there yet, but i'll probably help soonish
01:53:57 <ManateeLazyCat> tab: Great! 
01:54:10 <mm_freak> adnap: that type doesn't make sense
01:54:28 <ManateeLazyCat> tab: BTW, you want use webkit bulid an awesome haskell browser?
01:54:55 <tab> ManateeLazyCat: i'm trying to make a "app" browser
01:55:20 <tab> ManateeLazyCat: for example the facebook browser, the gmail browser, ...
01:55:24 <ManateeLazyCat> tab: Maybe you can join manatee team, manatee is multiple-process design like Google Chrome, any sub-module won't crash core.
01:55:27 <adnap> mm_freak: data Vector2 a = Vector2 a a, type Scalar Vector2 a = a
01:55:54 <tab> ManateeLazyCat: I want to make a task based desktop, but i'm lacking time
01:56:06 <mm_freak> adnap: associated types belong to classes, not types
01:56:51 <mm_freak> instance Ring a => VectorSpace (Vector2 a) where type Scalar (Vector2 a) = a
01:57:14 <ManateeLazyCat> tab: My project is complete distributed design, you can develop any application like normal gtk+ program, standalone with core developing.
01:58:04 <tab> ManateeLazyCat: i'll have a look at your project (although it seems there's a certificate problem on patchtag), but as i said i don't have that much time :)
01:58:26 <adnap> mm_freak: What you just wrote is exactly what I was saying.
02:00:48 <adnap> I have: data Vector2 a = Vector2 a a 
02:00:51 <adnap> instance Ring a => VectorSpace (Vector2 a) where type Scalar (Vector2 a) = a  (.+.) (Vector2 x1 y1) (Vector2 x2 y2) = Vector2 (x1 Algebra.+ x2) (y1 Algebra.+ y2)  (*.) c (Vector2 x y) = Vector2 (c Algebra.* x) (c Algebra.* y)
02:07:52 <adnap> mm_freak: If I have a type associated with a particular class, and then I make a more general class, can I access the associated type in the former class?
02:08:42 <adnap> mm_freak: Ah, I just answered my own question.  class VectorSpace a => NormedVectorSpace a where norm :: a -> Scalar a
02:12:55 <adnap> mm_freak: Oh wait, I guess I shouldn't assume that my scalar is of the same type as the components of my vector.  Likewise, I shouldn't assume that it's the same type as my norm.
02:14:39 <mm_freak> adnap: yes, associated types can't express that
02:15:01 <mm_freak> you could just as well have:  type Scalar Whatever = Bool
02:23:59 <adnap> mm_freak: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29847#a29850
02:24:36 <adnap> mm_freak: I need to define all the algebras for Vector2's now.
02:26:44 <Maxdamantus> Why is this apparently invalid? flip splitAt "" . curry snd
02:27:19 <adnap> mm_freak: Wait, I actually don't know if Vectors have all of those properties...
02:27:45 <Maxdamantus> :t flip splitAt "" . curry snd
02:27:46 <lambdabot>     Couldn't match expected type `Int' against inferred type `b -> b'
02:27:46 <lambdabot>     Probable cause: `curry' is applied to too few arguments
02:27:46 <lambdabot>     In the second argument of `(.)', namely `curry snd'
02:28:05 <Maxdamantus> Oh wait
02:28:19 <Maxdamantus> nvm :\
02:29:52 <aristid> :t splitAt
02:29:53 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:30:04 <aristid> :t flip splitAt ""
02:30:05 <lambdabot> Int -> ([Char], [Char])
02:30:17 <aristid> :t curry snd
02:30:18 <lambdabot> forall a b. a -> b -> b
02:30:50 <aristid> :t ((.).(.)) (flip splitAt "") (curry snd)
02:30:51 <lambdabot> forall a. a -> Int -> ([Char], [Char])
02:31:16 <aristid> Maxdamantus: http://conal.net/blog/posts/semantic-editor-combinators/
02:31:57 <Axman6> @pl \x y -> curry fst x y
02:31:57 <lambdabot> const
02:32:02 <Axman6> good lambdabot 
02:32:06 <Axman6> @pl \x y -> curry snd x y
02:32:06 <lambdabot> const id
02:33:21 <nlogax> if i have a module that talks to a database, is there a way to make the functions in that module share the same connection, and have the other modules be oblivious to what it does? 
02:33:26 <Maxdamantus> @pl \x y -> (curry snd) x y
02:33:26 <lambdabot> const id
02:34:06 <nlogax> my imperative mind wants to do `connection = blabla` at the top level and just have everything use that, i don't know how i should do it in haskell :)
02:34:22 <aristid> @pl curry snd
02:34:22 <lambdabot> const id
02:34:27 <aristid> simpler
02:34:40 <Axman6> wasn't sure if i'd just get curry snd back though
02:34:50 <Axman6> since it was already pointfree
02:36:39 <aristid> Axman6: yeah so i tried it out
02:39:02 <kremsera> monads are like beer
02:39:24 <kremsera> the cause ofo - and solution to - all of lifes problems
02:42:52 <adnap> mm_freak: Okay, now I have more! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29847#a29851
03:03:57 <JoeyA> Is there a way to have an exception thrown when a Haskell program uses more than, say, 75% of available RAM?
03:04:12 <JoeyA> rather than letting it simply OOM kill my system.
03:04:45 <merijn> JoeyA: I'm pretty sure Haskell throws an out of memory exception when it tries to allocate more memory but the OS says "No"
03:04:55 <opqdonut> linux never says no
03:04:58 <JoeyA> right
03:04:58 <opqdonut> by default
03:04:58 <koala_man> in that case you could use ulimit
03:05:05 <opqdonut> ulimit sounds good
03:05:12 <merijn> opqdonut: Are you sure?
03:05:23 <opqdonut> merijn: quite
03:05:25 <JoeyA> Does that cause an out-of-memory exception that can be handled?
03:05:44 <koala_man> never saying no isn't as terrible as it sounds
03:05:47 <JoeyA> Also, what if I need to allocate a little bit more memory to handle the problem?
03:06:10 <koala_man> well it is, but no apps ever check the return value of malloc anyways, and a lot of apps allocate memory they never use
03:06:11 <merijn> opqdonut: I just looked at the linux brk/sbrk man page and that says it returns ENOMEM when out of memory
03:06:14 <opqdonut> merijn: see e.g. http://www.mjmwired.net/kernel/Documentation/vm/overcommit-accounting
03:06:33 <opqdonut> the default in modern distros is 0, AFAIK
03:06:46 <merijn> Silly linux distro's...
03:07:00 <opqdonut> allowing overcommits allows modern software to work
03:07:10 <opqdonut> they often allocate huge slabs of memory
03:08:45 <merijn> opqdonut: That description says the default of 0 still returns "no" for obvious overcommits
03:09:42 <merijn> koala_man: The fact that most programmer's are idiots doesn't mean you should indulge them...
03:10:01 <merijn> People who don't check malloc return values should be hung anyway
03:11:13 <opqdonut> merijn: obvious overcommits are something like a single malloc for half of the RAM
03:11:17 <opqdonut> AFAIK, again
03:11:22 <opqdonut> read the code if you want certainty
03:11:42 <merijn> I don't use linux so it's more of an academic issue for me
03:14:41 <koala_man> merijn: I agree, but it would be easy if it was single apps and not every library ever made
03:18:43 <lysgaard> Is there any implementation of https in haskell?
03:20:06 <tab> lysgaard: https is http + tls, you can find http libraries and tls libraries on hackage and combine them
03:22:34 <Lemmih> lysgaard: It's usually simpler just to place your application behind another http-server that handles https.
03:24:30 <lysgaard> Lemmih: Hmm, what i want to do is the opposite, i want to communicate with a page that uses https, a bit like wget ;)
03:24:56 <deteego> bah
03:25:01 <deteego> I got this really annoying problem
03:26:26 <lysgaard> deteego: tell us
03:26:37 * hackagebot simpleargs 0.2.1 - Provides a more flexible getArgs function with better error reporting.  http://hackage.haskell.org/package/simpleargs-0.2.1 (KetilMalde)
03:32:48 <deteego> lysgaard: I have to search through a recursive data structure (that is an AST) and search for all occurances of a certain data type
03:33:48 <Saizan> deteego: sounds like you want to use Uniplate or SYB
03:34:00 <deteego> does haskell has any helper functions for traversel through recursive data structures?
03:34:06 <peterNovice> I was just wondering if it is normal to feel a bit of "mental resistance" or denial when trying to figure some of the boost c++ libraries, coming from a haskell, c and python experience? I am not bashing, but is it not cumbersome and awkward?
03:34:25 <Eelis> deteego: yes, look at Data.Generic
03:36:34 <deteego> is forall what I am looking for
03:37:32 <Saizan> deteego: there isn't a built-in construct for datatype-generic traversals, but there are libraries
03:38:12 <Saizan> deteego: http://community.haskell.org/~ndm/uniplate/ <- this one is quite easy to use
03:38:53 <deteego> Saizan: this is for an assignment, so I am probably stuck with Data.Generic
03:39:21 <deteego> @forall
03:39:21 <lambdabot> Unknown command, try @list
03:39:32 <Phyx-> oooh the new haddock is pwetty
03:40:07 <Saizan> deteego: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#universal-quantification
03:41:11 <Phyx-> veery pwetty, glad they decided not to center it and have fixed size columns :)
03:42:37 <deteego> Saizan: is there a definition for 'forall'
03:43:21 <deteego> Sainvm
03:43:25 <deteego> *nvm
03:43:48 <Phyx-> SainVM , runs SainOS which powers Saizan 
03:45:08 <deteego> lol
03:46:19 <deteego> ok this is confusing me even more
03:46:35 <deteego> lets say I have a data type Exp which is an AST for a recursive data type
03:46:45 <Saizan> it's fun that i'm the maintainer of syb-with-class while i quite dislike the whole concept (even if it's a quite clever and useful solution)
03:47:02 <deteego> all I want to do is to find all occurances of a certain Exp (in this case a Var Id)
03:47:10 <Phyx-> what do you dislike about it Saizan ?
03:47:35 <Phyx-> deteego: and do what? return them? sounds like listify
03:48:02 <deteego> Phyx-: well yes
03:48:05 <deteego> actually
03:48:16 <Phyx-> :t listify
03:48:17 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
03:48:29 <Phyx-> just write r -> bool then
03:48:39 <Saizan> > listify (const True) ([Just 1, Just 5, Nothing] :: [Maybe Int]) :: [Int]
03:48:40 <lambdabot>   [1,5]
03:48:50 <Phyx-> (Var Id) = True; _ = False
03:49:06 <Saizan> you'd have to derive Data and Typeable for your types
03:49:06 <Phyx-> Saizan: i miss the addition of a listifyBut :(
03:49:30 <Phyx-> which allows you to specify what not to traverse into
03:50:05 <Saizan> yeah, that'd be quite useful
03:50:22 <Phyx-> Saizan: I actually did write one
03:50:47 <dobblego> http://paste.pocoo.org/show/260258/ <-- WTF cabal?
03:50:48 <Phyx-> using a heterogeneuos list
03:51:00 <Saizan> Phyx-: btw, i don't like the untypedness/runtime checks
03:51:06 <deteego> ok I am still confused
03:51:17 <deteego> if I want to define a function to do this
03:51:21 <deteego> what would be the function arguments
03:51:40 <deteego> hmmm
03:51:48 <deteego> thats what Typeable is
03:51:55 <Phyx-> dobblego: I got that before, someone told me to unpack the package, bump up the version by 1 and rebuild
03:52:35 <dobblego> which package?
03:52:36 <Saizan> dobblego: see the first Cabal FAQ, you've the same version of some package installed in both the user and global dbs, and that confuses the current cabal
03:53:07 <Phyx-> Saizan: http://phyx.pastebin.com/S3vCNf0D btw
03:53:23 <Phyx-> something like that included in syb would be handy, lol
03:54:49 <Saizan> Phyx-: for syb you've to talk to someone else though :)
03:54:59 <deteego> btw http://www.cs.vu.nl/boilerplate/ is down
03:55:16 <Phyx-> Saizan: oh, i missed the -with-class
03:55:18 <Phyx-> lol
03:56:10 <Saizan> deteego: what should that be?
03:56:40 <deteego> Saizan: what should what bw
03:56:43 <deteego> *be
03:56:54 <Saizan> the link that is down
03:57:20 <Saizan> http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/ <- papers on Data.Generics (the first two)
03:57:35 <Phyx-> deteego: you derive Typable and Data, then you do listify f where f (Var Id) = True; f _ = False
03:57:51 <dobblego> ok, I had two containers-0.3.0.0 so I unregister the user one and xmonad breaks, so I install xmonad and it installs containers-0.3.0.0 back into --user
03:58:05 <Saizan> i think listify (const True) .. :: [Id] works better
03:58:11 <deteego> Phyx-: does this require another package, because Data.Generics doesn't appear to be working
03:58:25 <deteego> *import Data.Generic
03:58:40 <Saizan> deteego: that's because you've array-0.3.0.1 installed, so cabal will pick that and it'll have to install a new containers against it
03:58:49 <Saizan> dobblego: err, that was for you ^^^
03:59:10 <Phyx-> deteego: try Data.Generics
03:59:11 <Saizan> dobblego: you can add --constraint="array == 0.3.0.0" or remove your array-0.3.0.1
03:59:47 <Saizan> (syb still comes with ghc?)
03:59:53 <Phyx-> and does anyone see which case I've missed here? http://phyx.pastebin.com/1hUaVCHj I don't see why it says non-exaustive patterns
03:59:59 <Phyx-> Saizan: think so
04:00:20 <Phyx-> atleast up until my 6.13 it does
04:00:36 <harlekin> @pl (\(a,b) -> a * b)
04:00:37 <lambdabot> uncurry (*)
04:00:42 <harlekin> Ah, damn. -.-
04:00:56 <Phyx-> deteego: type ghc-pkg find-module Data.Generics
04:01:20 <dobblego> Saizan, thanks
04:01:47 <Saizan> Phyx-: is that haskell? i can't read the gadts syntax
04:03:15 <Saizan> i guess con introduces a record-style constructor
04:03:36 <deteego> ok I don't think this is the right way to go around it
04:03:44 <Phyx-> Saizan: no, the function is haskell, the types aren't. but it's close, con Quant in data TyScheme creates a constructor TyScheme_Quant with those fields
04:04:01 <deteego> our assignment definitly would have not required ghc extensions or syb
04:04:45 <Saizan> deteego: i think you're supposed to manually flesh out a fold for your datatype and use that
04:04:49 <Phyx-> deteego: then you could just write a fold with some algebra 
04:05:00 <Saizan> deteego: or go with direct recursion
04:05:19 * Phyx- wishes the non-exaustive pattern error would include what it couldn't match
04:05:26 <Phyx-> ooooh
04:05:28 <Phyx-> damn
04:05:30 <Phyx-> silly
04:05:33 <Saizan> it usually does..
04:05:39 <Phyx-> the last case is "simplift"
04:05:40 <Phyx-> typo
04:05:42 <Phyx-> grrr
04:05:47 <Saizan> heh
04:07:53 <Phyx-> yay works
04:08:00 <Phyx-> thought it needs a nub...
04:08:27 <Phyx-> "Cons:forall a a a. a -> (List a) -> List a"
04:08:28 <Phyx-> lol
04:08:56 <Saizan> that'd be quite confusing :)
04:10:03 <Phyx-> Saizan: lol, the "unsimplified" type is Cons:forall (a>=_|_). forall (a>=_|_). forall (a>=_|_). a -> (List a) -> List a
04:10:51 <Phyx-> actually.. why did it wrap tha tmany foralls..
04:10:54 * Phyx- finds out
04:12:30 <deteego> Saizan: im trying to implement mutually recursive bindings btw
04:12:36 <aristid> GF is cool
04:12:37 <deteego> in an evaluator
04:13:04 <Phyx-> aristid: Gardian Force? Girl Friend?
04:13:05 <Saizan> oh, nice, you should make use of lazyness there
04:13:35 <aristid> Phyx-: grammatical framework of course :P
04:13:44 <aristid> http://www.grammaticalframework.org/
04:13:52 <aristid> @hackage gf
04:13:53 <lambdabot> http://hackage.haskell.org/package/gf
04:13:55 <Phyx-> aristid: of course :)
04:14:09 <Phyx-> has @hackage started verifying the urls?
04:14:12 <aristid> Phyx-: in case of doubt, it's a hackage package name
04:14:14 <aristid> no:/
04:14:27 <aristid> but in this case it is correct
04:15:03 <Phyx-> hehee
04:15:06 <Phyx-> "Cons:forall a. a -> (List a) -> List a"
04:15:08 <Phyx-> better
04:16:30 <aristid> Phyx-: what is that?
04:17:01 <Phyx-> aristid: type of Cons that my typechecker spits out
04:17:05 <Phyx-> after simplification
04:17:29 <aristid> Phyx-: your typechecker? for which language?
04:17:37 <Phyx-> aristid: Haskell
04:18:03 <aristid> Phyx-: it could omit the parens
04:18:10 <aristid> and use :: instead of :
04:18:22 <aristid> "Cons :: forall a. a -> List a -> List a"
04:19:21 <Phyx-> aristid: try, I'm currently just printing whatever I get back from the parser, and it printed ":" because it was just printing the environment
04:19:26 <Phyx-> but yeah "::" might be better
04:20:17 <aristid> Phyx-: you have your own haskell parser?
04:20:18 <Phyx-> and simplify the Expr type
04:21:12 <Phyx-> aristid: it's part of my thesis, i'm among other implementing the HML typesystem using bits and pieces from UHC
04:21:36 <aristid> Phyx-: why didn't you know GF then? :P
04:21:59 * Phyx- looks at the site of gf
04:23:06 <Phyx-> aristid: never came across GF before
04:23:07 <Phyx-> lol
04:23:31 <aristid> Phyx-: i found it when browsing the hackage package list
04:24:08 * Phyx- hasn't been on haskell.org or any related page in months
04:24:14 <aristid> Lang> p -cat=Utt "not you"|l -lang=Ger
04:24:14 <aristid> nicht ihr
04:24:14 <aristid> nicht Sie
04:24:14 <aristid> nicht du
04:24:19 <aristid> the awesome :D
04:24:21 <Phyx-> infact, don't think i've even installed packages in a while
04:24:44 <aristid> it translates "not you" into all possible German meanings :D
04:26:17 <Phyx-> aristid: haha, awesome
04:26:24 <Phyx-> one could have fun with that
04:34:40 <kamatsu> if i have a 4-tuple of word32s
04:34:54 <kamatsu> how do i change that into a list of 16 word8s ?
04:35:13 <kamatsu> (or a 16-tuple of word8s)
04:37:29 <Martty> > let f (x,y) = x:y:[] in f (1,2)
04:37:30 <lambdabot>   [1,2]
04:38:54 <burp> kamatsu: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Bits.html does Data.Bits help?
04:39:13 <kremsera> not when converting with arbitrary tuples - then you need TH ;)
04:39:50 <kamatsu> burp: not really, but i think i'll go a different route anyway
04:42:58 * Phyx- just realised he hasn't had breakfast yet
04:43:10 <Phyx-> I wonder if all haskell programmers accidently starve themselves
04:43:25 <Ytinasni> what, we're too lazy to eat?
04:43:58 <hpc> no, you don't eat until you evaluate your stomach
04:44:27 <Ytinasni> good thing i'm multithreaded, then :D
04:44:30 <hpc> hehe
04:44:58 <Phyx-> walking around with a PAP all day doesn't sound like fun though
04:45:17 <Phyx-> Ytinasni: but you have a much larger overhead then :)
04:45:53 <hpc> fleeting thought: entangled particles == thunks?
04:49:19 <Phyx-> I hate my landlord.. grrr
04:51:55 <kremsera> is there a compact way to let different cases return the same result, like in c?
04:51:59 * hackagebot korfu 0.2 - The Korfu ORF Utility  http://hackage.haskell.org/package/korfu-0.2 (KetilMalde)
04:52:55 <kremsera> e.g. case (nr) of      1,2,5 -> 2;   _ -> 3)
04:54:55 <hpc> @hoogle a -> [a] -> Bool
04:54:55 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
04:54:56 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
04:54:56 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
04:55:21 <hpc> case (nr) of _ | nr `elem` [1,2,5] -> 2; _ -> 3
04:55:41 <kremsera> :)
04:55:43 <kremsera> thx!
04:55:48 <aristid> hpc: the parens around (nr) ar unnecessary:)
04:56:04 <hpc> meh, i rarely use case explicitly myself
04:59:57 <Maxdamantus> O_o silly hjs
05:00:06 <Maxdamantus> NaN == NaN == true
05:02:53 <aristid> Maxdamantus: wtf
05:04:23 <Maxdamantus> Oh, I guess it is still experimental.
05:06:01 <arnihermann> given a function , inBlock docs = ...
05:06:01 <arnihermann> c
05:06:01 <arnihermann> a
05:06:01 <arnihermann> n 
05:06:02 <arnihermann> I 
05:06:10 <arnihermann> can I force docs to be evaluated at call site?
05:06:32 <earthy> what do you mean by 'evaluated'
05:06:42 <earthy> reduced to weak head normal form? head normal form? normal form?
05:07:08 <arnihermann> normal form
05:07:23 <hpc> foo x = rnf x `seq` whatever
05:07:43 <hpc> :t rnf
05:07:44 <lambdabot> forall a. (NFData a) => a -> Done
05:07:56 <hpc> you have to write the instance yourself though
05:08:00 <arnihermann> ah
05:08:09 <arnihermann> thanks
05:12:29 <arnihermann> I'm also having minor issues with prettyprint (hughes)
05:12:39 <arnihermann> I have this fn, inBlock docs = lbrace $+$ nest 2 (vcat docs) $+$ rbrace
05:13:00 <arnihermann> if I do something like this: text "foo" <+> inBlock [text "1", text "2", text "3"]
05:13:22 <arnihermann> the indend of 1, 2, 3 is aligned not 2 spaces from "f" in "foo" but 2 spaces from the lbrace
05:14:08 <arnihermann> but if I do: text "foo" <+> brace $+$ nest 2 (vcat [text "1", text "2", text "3"]) $+$ rbrace
05:14:11 <arnihermann> it's correctly aligned
05:15:31 <arnihermann> any thoughts?
05:55:29 <atude> would the sum of i*i! from i=1->n == n^2+i*n-n?
05:57:13 <koala_man> how did you include i in the final expression?
05:58:32 * hackagebot lbfgs 0.0.2 - L-BFGS optimization  http://hackage.haskell.org/package/lbfgs-0.0.2 (DanielDeKok)
06:19:05 <deteego> I think my brain is about to expload since I have been doig haskell for like 10 hours so I am about to ask a stupid question
06:19:09 <deteego> *doing
06:19:33 <merijn> deteego: In that case the answer is "Go to bed and sleep first before asking questions" :p
06:19:48 <merijn> I find most of my questions disappear after a proper night's rest :p
06:20:03 <deteego> its just one stupid question
06:20:15 <deteego> whats the function that applies a function on every element on a list, one by one
06:20:30 <merijn> map?
06:20:52 <deteego> it doesn't return a list, it returns a where a is the element of the list
06:21:07 <deteego> hmm wait a second
06:21:12 <merijn> That makes no sense
06:21:18 <trez> @type map
06:21:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:21:57 <deteego> ye it doesn't make any sense
06:22:22 <deteego> map goes left to right, correct?
06:22:29 <merijn> yes
06:22:33 <trez> > map (+1) [1,2,3,4]
06:22:34 <lambdabot>   [2,3,4,5]
06:22:37 <deteego> it will always evaluate left to right?
06:23:05 <merijn> deteego: No, because map doesn't always get evaluated
06:23:06 <Kaidelong> well deteego, maybe not
06:23:48 <Kaidelong> > map (^2) [undefined, undefined, 4, undefined] !! 3
06:23:49 <lambdabot>   *Exception: Prelude.undefined
06:23:52 <Kaidelong> > map (^2) [undefined, undefined, 4, undefined] !! 2
06:23:53 <lambdabot>   16
06:25:28 <Saizan> the structure of the lists will be constructed in a left to right way, for the elements it depends on how you are using them
06:26:04 <Kaidelong> so long as you don't make haskell impure the order in which map is applied to stuff in the list should not matter, but it'll construct the thunks in order
06:26:31 <Kaidelong> @src map
06:26:31 <lambdabot> map _ []     = []
06:26:31 <lambdabot> map f (x:xs) = f x : map f xs
06:27:00 <deteego> this isn't making any sense
06:27:08 <deteego> does last fail on a list with just one element?
06:27:12 <Saizan> and, btw, it won't even look at the rest of the input list until the consumer is demanding the rest of the output list
06:27:21 <Kaidelong> > last [1]
06:27:22 <lambdabot>   1
06:27:27 <merijn> deteego: That's why you need to go sleep instead of continuing after 10 hours of programming...
06:27:28 <deteego> wth
06:28:22 <Kaidelong> @src last
06:28:22 <lambdabot> last [x]    = x
06:28:23 <lambdabot> last (_:xs) = last xs
06:28:23 <lambdabot> last []     = undefined
06:29:46 <Kaidelong> does lambdabot have something impure that can be used to demonstrate evaluation order?
06:29:57 <Kaidelong> like perhaps a trace?
06:30:43 <sshc> \la
06:30:49 <trez> > foldl (+) 0 [a,b,c,d]
06:30:50 <lambdabot>   0 + a + b + c + d
06:30:55 <deteego> this isn't making any sense, when I do last on a list it complains its empty
06:30:59 <trez> > foldr (+) 0 [a,b,c,d]
06:31:00 <lambdabot>   a + (b + (c + (d + 0)))
06:31:01 <deteego> but when I do length on it, it says its length 1
06:31:27 <Kaidelong> deteego: that isn't making any sense to me either
06:31:41 <burp> we have to assume it's your mistake :>
06:31:44 <Kaidelong> > length []
06:31:45 <lambdabot>   0
06:31:49 <Kaidelong> > last []
06:31:49 <lambdabot>   *Exception: Prelude.last: empty list
06:32:26 <deteego> yeh thats what it says
06:32:35 <deteego> empty list
06:32:40 <burp> if you paste the code we might help
06:32:45 <Kaidelong> yeah but it gave 0 as its length
06:33:14 <Kaidelong> > length [last []]
06:33:15 <lambdabot>   1
06:33:15 <deteego> I think it has to be with laziness
06:33:21 <Kaidelong> > last [last []]
06:33:22 <lambdabot>   *Exception: Prelude.last: empty list
06:33:30 <deteego> how do you force the strictness of a function
06:33:36 <Kaidelong> seq
06:33:48 <deteego> the other one, just a single function
06:33:57 <Saizan> lazyness won't change the length of a list
06:33:58 <deteego> not 2 expressions
06:34:06 <burp> please paste your code/problem
06:34:06 <nlogax> bang patterns?
06:34:21 <burp> if you ask for strictniss at this point you're probably doing something wrong ;)
06:34:27 <Saizan> unless that lists comef from hGetContents or readFile
06:35:14 <Kaidelong> deteego it'd probably be much easier to figure out what was going on if you show us what is going on
06:35:30 <Kaidelong> > let x = last [] in length [x]
06:35:30 <lambdabot>   1
06:35:40 <Kaidelong> > let x = x `seq` last [] in length [x]
06:35:41 <lambdabot>   1
06:35:46 <Kaidelong> > let x = x `pseq` last [] in length [x]
06:35:47 <lambdabot>   1
06:35:56 <Kaidelong> oh lol
06:36:07 <Kaidelong> > let x = last [] in x `seq` length [x]
06:36:08 <lambdabot>   *Exception: Prelude.last: empty list
06:36:13 <Kaidelong> there we go
06:36:17 <Kaidelong> that's how you make something strict
06:36:24 <Kaidelong> bang patterns work too
06:37:37 <deteego> Kaidelong: its for an assignment and other people in my class might be in this room doing it
06:38:10 <burp> don't speculate or ask further then
06:38:22 <burp> we can't help with something we have to guess ;)
06:40:26 <burp> and what is the problem with the other people? :D are they not allowed to see it?
06:41:07 <EvanR-wo1k> sorry we cant help you because deteego got here first
06:47:41 <Phyx-> 15:40:39 < EvanR-wo1k> sorry we cant help you because deteego got here first <-- lol
06:47:51 <Phyx-> EvanR-work: !help-queue-size
06:48:39 <Nibble> @instances Fractional
06:48:40 <lambdabot> Double, Float
06:48:40 <burp> LIFO ;P
06:48:41 <Saizan> i don't get what that is referring to
06:50:08 <EvanR-work> LOFI queue
06:50:32 <EvanR-work> HIFI queue
06:50:50 <Nibble> Last in first out
06:50:55 <Nibble> what is LOFI?
06:50:58 <Nibble> Last out first in?
06:51:15 <EvanR-work> yeah so seems like a stack
06:52:29 <Phyx-> lol
06:54:13 <izzie321> /who *
07:10:44 * Phyx- really likes the new clean looking haskell docs. Kudos to who ever made it :)
07:13:34 <Saizan> oh, they merged the synopsis back into the main page, nice
07:16:40 <Phyx-> yeah
07:19:30 <yrlnry> Saizan:  URL?
07:21:06 <deteego> you know what is the most annoying thing when programming
07:21:16 <deteego> when your code works correctly due to what you assumed was a bug
07:21:22 <deteego> (or is a bug)
07:21:26 <deteego> and you test against that
07:23:15 <Saizan> yrlnry: http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Graph.html
07:23:49 <aristid> deteego: that happens relatively rarely tho, many annoying things happen much more often
07:24:22 <sm> Saizan: that (synopsis) is just because you're looking at haddock 2.6.1 docs, with the 2.8 styles
07:24:34 <sm> the footer tells all
07:24:38 <deteego> aristid: I guess
07:24:51 <Saizan> sm: ah
07:25:15 <Phyx-> oh, there are multiple versions?
07:25:18 <kamatsu> oh, i have a question
07:25:23 <kamatsu> i'm using haskell's network library
07:25:24 <sm> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html <- the new one
07:25:27 <kamatsu> it's doing something wierd
07:25:29 <Phyx-> ah
07:25:30 <Phyx-> indeed
07:25:34 <Phyx-> they look different
07:25:47 <Saizan> i'm sad then.
07:25:47 <kamatsu> i have my server listening on a socket
07:25:56 <Phyx-> the new new one I meant looks great then
07:25:57 <Phyx-> hehe
07:26:21 <kamatsu> web browser sends a message to my port (wireshark says so), and my server even sends a TCP ACK back
07:26:34 <Saizan> kamatsu: you get an error involving getAddrInfo ?
07:26:37 <kamatsu> but no handle is created or connection accepted.
07:26:52 <kamatsu> Saizan: a while ago I did, but it went away
07:27:12 <kamatsu> and futhermore if the web browser tries to connect again then the whole thing crashes with broken pipe
07:27:17 <Phyx-> Saizan: why are you sad? lol
07:28:06 <Saizan> Phyx-: blurbs of texts where i expected an index confuse me.
07:29:25 <kamatsu> i am completely at a loss as to why this is happening
07:29:29 <ledian> kann mir jemand helfen bitte?
07:29:32 <Saizan> kamatsu: windows or linux?
07:29:43 <copumpkin> ledian: #haskell.de? 
07:29:54 <Phyx-> Saizan: Idk, I kinda like it, that the synopsis doesn't take space when not in use
07:30:03 <kamatsu> Saizan: linux
07:30:27 <kamatsu> Saizan: oh wait, the problem goes away if i don't do anything with the handle except print it.
07:30:45 <kamatsu> this might be my problem.
07:31:24 <Saizan> Phyx-: but i always use it!
07:32:45 <deteego> I am finally done
07:32:48 <deteego> rawr
07:33:25 <deteego> kamatsu: what are you doing anywyas
07:33:27 <deteego> *anyways
07:34:21 <kamatsu> deteego: new websocket server interface for haskell
07:34:27 <Phyx-> Saizan: lol, think of it this way, it scrolls with you now
07:34:34 <Phyx-> it's always there if needed
07:34:36 <kamatsu> the existing one was broken by the last spec revision, and it also uses slow Strings.
07:34:36 <deteego> kamatsu: oh nice
07:34:56 <deteego> kamatsu: I just finished mutually recursive bindings
07:35:00 <deteego> kamatsu: so I am happy
07:35:04 <kamatsu> deteego: nicely done
07:38:22 <yrlnry> Saizan:  thanks
08:08:54 <handonson> Can I specify the package name that you want to import modules from in GHCi?
08:09:22 <quicksilver> you can launch GHCi with only certain packages
08:09:28 <Phyx-> Think you can use -package when starting GHCi
08:09:29 <quicksilver> -hide-package and -package commandline options
08:09:39 <handonson> ah. thanks.
08:09:46 <handonson> can't it be done on the go?
08:09:48 <quicksilver> I don't think there is a varient of ":m" which lets you choose, though
08:09:55 <c_wraith> it can, use :set
08:10:27 <c_wraith> the only related flag you can't set with :set is -hide-all-packages
08:10:52 <Phyx-> I would love a variant of :m that allows you to rename modules
08:12:03 <c_wraith> the results of running "ghci -hide-all-packages" are kind of amusing.
08:13:10 <handonson> thank you very much.
08:15:35 * hackagebot cpsa 2.1.1 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.1.1 (JohnRamsdell)
08:18:42 <ksf> how do I properly line up -> with latex?
08:18:52 <ksf> I can only find stuff to line up =
08:18:58 <donald78> a
08:19:12 <ksf> ...and even amsmath's split doesn't seem to work for \rightarrow
08:20:45 <donald78> maybe use tabbing-enviroment in latex
08:20:48 <quicksilver> there are various equation environments to line stuff up around = signs which work equally well with any symbol.
08:21:13 <ksf> ...never mind, I'm an idiot
08:21:31 <ksf> not even capable of copy&paste or grokking tex errors
08:21:39 <Mitar> hi, i would like this code to GADTs so that i can teach compiler about dependencies between types: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29854
08:21:43 <ksf> ...shouldn't forget those linebreaks.
08:21:44 <quicksilver> align* seems to be one (that might be AMS math only?)
08:21:51 <Mitar> i am a bit lost how can i do that ...
08:21:55 <ksf> ...even if I already have the align points set.
08:23:58 <ksf> \[\begin{split}\forall n &. \log_2 n \le 64\\ &\rightarrow O( \log_2 n )\\ &\rightarrow O ( 1 )\end{split}\]
08:24:07 <ksf> there. the perfect t-shirt.
08:28:02 <merijn> :)
08:32:28 <ksf> (as a side note, I'd like all software that's labelled as "stable" to be as stable as the alpha luatex version I'm using)
08:35:13 <fphh> hello?
08:35:41 <Twey> ksf: How is it functionality-wise?  Is it a full LaTeX implementation?
08:35:41 <djahandarie> Hello
08:36:20 <fphh> i just wondered if there is anybody
08:36:57 <Twey> There are many people
08:37:07 <Twey> Approaching seven billion, I believe
08:37:13 <Twey> At least!
08:37:18 <quicksilver> actually, there are no people, not even you
08:37:24 <quicksilver> you're just a butterfly dreaming you're a person.
08:38:08 <Twey> Damn.
08:40:35 <Saizan> butterflies are known to have very detailed and realistic dreams.
08:40:40 <Saizan> in case you wondered
08:40:56 <aRcatan> i wonder what the preceding discussion was
08:41:00 <aristid> Saizan: how is that known?
08:41:26 <handonson> aristid: because you're having one.
08:42:00 <aristid> i have no butterfly, no :)
08:42:17 <tab> butterflies can't be dreaming and writing to disk (M-x butterfly)
08:44:51 <handonson> aristid: no, i meant the dream, not butterfly.
08:45:23 <handonson> i'm your unconscious reflection, here to tell you that you're on the brink of getting pecked by some pigeon
08:45:27 <aristid> handonson: but i'm no butterfly, so we know nothing about butterflies' dreams from my dreams
08:45:41 <aristid> damn these pigeons
08:46:03 <Saizan> aristid: that's exactly what a butterfly dreaming to be something else would say, face the truth
08:46:21 <merijn> Hmm, anyone here that can come up a nice and academical sounding synonym for "porting"? :p
08:46:42 <handonson> merijn: transplantation
08:46:52 <c_wraith> implementing on multiple platforms
08:47:01 * frerich chips in, reads the discussion about dreaming butterflies and double-checks that he didn't join #meth :-}
08:47:03 <c_wraith> I'm sorry that it's a simple phrase, and not 3 sentences.  which would sound more academic
08:47:07 <aristid> c_wraith: that sounds less academical, not more
08:47:38 <c_wraith> Just need some adjectives to spice it up.  "multiple disparate platforms" or something
08:47:39 <aristid> frerich: haskell expressions can have dangerous effects to one's mind
08:47:51 <merijn> I was thinking "experimental reimplementation" :>
08:48:12 <aristid> "multi-platform adaptation"?
08:48:32 <merijn> "reifying the concept on a new platform" :D
08:51:01 <aristid> merijn: lol
08:59:39 <handonson> % is not reserved?! awesome
09:00:16 * aRcatan reserves it
09:00:21 <djahandarie> > let (%) = mod in 10%3
09:00:22 <lambdabot>   1
09:00:46 <aRcatan> % is available for use for non-commercial purposes only
09:02:11 <ksf> ISO says: log_2 shall be written lb
09:02:24 <c_wraith> good work, ISO.
09:02:37 <djahandarie> > let (%) = (/100) in 10% undefined
09:02:38 <lambdabot>   0.1
09:02:39 <ksf> how to pronounce that?
09:02:47 <Zao> "pound"
09:02:47 <ksf> logarithmus bineralis?
09:02:49 <c_wraith> "pound"
09:02:50 <aRcatan> eelb
09:02:52 <Zao> :D
09:02:54 <ksf> mixing greek and latin doesn't work.
09:03:03 <Zao> How do you pronounce ln?
09:03:08 <ksf> naturalis.
09:03:09 <c_wraith> "log natural"
09:03:11 <ksf> ld is dualis.
09:03:31 <c_wraith> really, computer science already had a good way to write log base 2:  lg
09:03:45 <c_wraith> nicely distinct from ln and log
09:03:56 <Zao> I suggest "bog"
09:04:06 <ksf> ISO says lg is log_10
09:04:08 <c_wraith> for Binary lOG
09:04:16 <c_wraith> ISO is wrong, then :)
09:04:19 <tab> would be a shame to create a symbolic link when doing a logarithm
09:04:41 <djahandarie> :t lb
09:04:42 <lambdabot> Not in scope: `lb'
09:04:50 <djahandarie> @hoogle lb
09:04:50 <lambdabot> Data.Graph.Inductive.Query.BFS lbft :: Graph gr => Node -> gr a b -> LRTree b
09:04:51 <lambdabot> Text.PrettyPrint.HughesPJ lbrace :: Doc
09:04:51 <lambdabot> Language.Haskell.TH.PprLib lbrace :: Doc
09:08:56 <Mitar> i would like this code to GADTs so that i can teach compiler about dependencies between types: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29854
09:09:06 <Mitar> any suggestions?
09:11:19 <copumpkin> Mitar: can you summarize what is impossible and why? you have comments in there saying that it is, but it's easier to design the type guards if you have a good summary of their reasons
09:12:48 <Mitar> i would like that return value of the getFromFirstLine function be Maybe AnyPacket if TwoWay parameter containst LineAny and that return type is Maybe Packet i if the parameter is Line
09:13:05 <Mitar> in this way type of Line corresponds to return value of the function
09:13:41 <Mitar> currently I have to wrap return values in one type which covers all possibilities, but some of them are impossible (like parameter Line and return AnyPacket)
09:15:23 <copumpkin> so the NoPacket / NoLine is just a hack for not having Maybe?
09:15:34 <Mitar> no, it is not
09:15:42 <Mitar> MaybePacket is a hack
09:15:46 <Mitar> to combine all possibilities
09:16:04 <copumpkin> yeah, that's what I mean
09:16:13 <Mitar> NoLine is a valid value, there are three types of lines: LineAny, Line and NoLine
09:16:17 <copumpkin> you really want something that only has two constructors Packet i => JustPacket i | JustAnyPacket AnyPacket
09:16:19 <Mitar> reading from NoLine should not be possible
09:16:27 <copumpkin> ah
09:16:38 <Mitar> it should fail at compile time
09:16:40 <Mitar> currently it does not
09:16:51 <Mitar> reading from Line should produce Packet i
09:17:03 <Mitar> (or Nothing if there is nothing in the Line)
09:17:21 <Mitar> reading from LineAny should produce AnyPacket (or Nothing if there is nothing in LineAny)
09:17:59 * hackagebot text-icu 0.4.0.1 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.4.0.1 (BryanOSullivan)
09:18:24 <reorg> is there a haskell parser for sql ?
09:18:31 <copumpkin> I'm not sure I understand the Packet i => JustPacket i | JustAnyPacket AnyPacket
09:18:41 <copumpkin> you don't want JustPacket to be existential?
09:18:59 <Mitar> JustPacket is not existential
09:19:02 <Mitar> there is no forall
09:19:12 <copumpkin> yeah, I'm just not sure why you have a single type for both
09:19:14 <Mitar> AnyPacket
09:19:14 <Mitar>  is
09:19:29 <Mitar> because i do not know how to do it ;-)
09:19:29 <copumpkin> what would the i parameter to MaybePacket mean in the existential case?
09:19:40 <reorg> or how to build a parser for sql? using happy? 
09:19:42 <Mitar> nothing
09:19:49 <Mitar> i would like to get rid of MaybePacket
09:19:54 <Mitar> remove MaybePacket
09:19:56 <Mitar> no more MaybePacket
09:19:59 <Mitar> MaybePacket is ugly ;-)
09:20:04 <copumpkin> okay
09:21:08 <Mitar> i would like to define type of getFromFirstLine like: getFromFirstLine :: (TwoWay Line a) -> IO (Maybe (Packet i)), getFromFirstLine :: (TwoWay LineAny a) -> IO (Maybe (AnyPacket))
09:21:39 <copumpkin> oh so you want to break up Line too
09:21:40 <Twey> Which one?
09:21:56 <copumpkin> Mitar: and how about NoLine?
09:22:07 <Mitar> noline is a valid value
09:22:18 <Mitar> but should not be possible to use getFromFirstLine on NoLine ;-)
09:22:57 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29856
09:23:27 <Mitar> so TwoWay can contain three types of values for first argument
09:23:34 <Mitar> a Line, LineAny or NoLine
09:23:48 <Mitar> reading is allowed only from Line and LineAny
09:23:48 <copumpkin> looks like you'll need type families and GADTs for this
09:23:57 <copumpkin> why don't you start with a simpler example
09:24:13 <copumpkin> and play with GADTs and type families without the distraction of having to deal with existing code?
09:24:26 <Mitar> this is a simple example ;-)
09:24:31 <Mitar> i removed other things ;-)
09:24:46 <copumpkin> yeah, but I still don't understand the basic motivation
09:24:59 <Mitar> motivation for what?
09:25:03 <copumpkin> for the whole thing
09:25:18 <Mitar> hmm
09:25:26 <Mitar> sending data over Chan?
09:25:42 <Mitar> it is a more complex type of Chan used in my program
09:25:52 <Mitar> the point is that I can define TwoWay with different types of Lines
09:26:01 <Mitar> and I would like that compiler type checks things
09:26:18 <Mitar> like prevent reading from TwoWay which does not have a defined Line
09:26:28 <copumpkin> what is TwoWay?
09:26:39 <Mitar> TwoWay is two Lines combined
09:26:51 <Mitar> it is how two threads will communicate
09:26:56 <Lal`C> Okay, how do I get Network.HTTP to send POST variables
09:27:05 <Mitar> one sending packets to from thread A to thread B
09:27:12 <Mitar> and the other to send packets from trehad B to thread A
09:27:14 <Lal`C> it just refuses to send the HTTP body!
09:27:37 <Mitar> but some thread could be defined so that they do not read anything, or write anything
09:27:44 <Lal`C> also if I (show request) the headers show up but not the post vars...
09:27:52 <Saizan> Lal`C: seen the Form type? have you made the method POST?
09:27:52 <Mitar> or they write/read any type
09:28:03 <Mitar> this is why there are three types of lines
09:28:19 <Saizan> Lal`C: that sounds like you are constructing a Request without them
09:28:30 <Lal`C> Saizan: Form type eh
09:28:34 <Mitar> now i just want to tell compiler about this
09:28:42 <Lal`C> I made it POST yeah, but will look into that
09:31:49 <copumpkin> Mitar: do you understand how you'd use GADTs in a simpler setting?
09:32:26 <copumpkin> GADTs in a way that isn't equivalent to regular ADTs, that is :P
09:32:57 <Lal`C> Saizan: pinged out, sorry. Can't find this Form type
09:33:48 <Mitar> i am yet trying to understand this
09:34:02 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29857
09:34:04 <Mitar> like that ;-)
09:34:34 <cwb> Is it common/sensible practice to put types in a module separate from consuming code in order to avoid circular imports (e.g. when consuming code is in a "top-level" monad that contains types from different modules)?
09:35:16 <cwb> I've tried to search for application structure but not found anything suitable on haskell.org or any other place..
09:35:19 <Twey> My usual structure is to have a type or set of related types in a module with functions on them, then functions combining types in another module
09:36:07 <Saizan> Lal`C: http://hackage.haskell.org/packages/archive/HTTP/4000.0.9/doc/html/Network-Browser.html#t:Form
09:36:41 <Lal`C> Oh, Network.Browser
09:36:42 <Lal`C> hmm
09:36:56 <cwb> Twey: Ok, that sounds like a plan. Thanks!
09:37:09 <Lal`C> I'll give it a shot, thanks :)
09:37:12 <copumpkin> Mitar: yeah, but something simple where you actually ensure a property you care about :P and I don't think your example is particularly simple :P even if you do understand it and the motivation for it, which I don't really
09:37:45 <cwb> Twey: By the way, do you have any standard naming convention for that? ModuleName/Types.hs?
09:37:58 <Twey> cwb: Not *all* the types in *one* module
09:39:11 <Mitar> copumpkin: this small example shows what I would like, like function f which returns different types based on input type
09:39:30 <Mitar> but yes, i do not understand GADTs enough to be able to do something more
09:39:38 <Mitar> this is why i am asking for help ;-)
09:40:07 <copumpkin> the issue is that they're both sort of existential, even the non-existential form
09:40:11 <cwb> Twey: No, I've got a bunch of submodules so something like ProgramName/SubmoduleName/Types.hs and so on; just not sure whether to then use ProgramName/Types.hs for simple types that all submodules use, or to use that for combining types from submodules (e.g. environment types for monads)... Any thoughts?
09:40:19 <copumpkin> and I don't understand why you want/need it
09:41:34 <Mitar> maybe i am doing something wrong
09:42:18 <Mitar> the point is that I would like to have to types of Lines, one where I can use just type class functions, but can multiple producers/thread write to it
09:42:41 <Mitar> and one where i have a line where just one thread (with specific type) can write to it
09:42:42 <copumpkin> yeah, but why unify them into a single type?
09:42:54 <copumpkin> why do you need a type that an either remember the type of its elements or forget it?
09:43:15 <Mitar> please forget about MaybePacket
09:43:19 <Twey> cwb: I'd do something like ProgramName/TypeName.hs with TypeName and functions only on TypeName (or possibly with stdlib types), ProgramName/OtherTypeName.hs with OtherTypeName, then ProgramName.hs contains functions combining TypeNames and OtherTypeNames
09:43:26 <copumpkin> I have
09:43:28 <Mitar> ok
09:43:30 <copumpkin> I'm talking about Line now :P
09:43:33 <Mitar> ok
09:44:02 <Mitar> i have three kinds of Lines: one which remembers the type, one which does not and one which marks that there is no line
09:44:28 <copumpkin> why is there a kind of line that is no line?
09:44:37 <copumpkin> (why not a Maybe?)
09:44:48 <Mitar> yes, i could wrap it into maybe
09:44:59 <copumpkin> and why do you need to use the lines that remember the type and those that don't in the same place, is my main question
09:45:17 <Mitar> but if I already have two types (Line and LineAny) it seemed to me as an easy way to add also NoLine
09:45:18 <cwb> Twey: Ok, thanks!
09:45:29 <djahandarie> cwb, you need to stop using that control character :P
09:45:32 <copumpkin> I'm arguing they should be separate types
09:45:46 <Mitar> it is because I cannot put everything into class functions
09:46:07 <Mitar> for example, some Packet instances could have special functions
09:46:14 <cwb> djahandarie: Aaargh.. I think I need another client. Any suggestions for terminal-based ones (on OS X)?
09:46:31 <Mitar> (not directly, but could operate on their data values)
09:46:33 <djahandarie> I think irssi can run in OS X
09:46:49 <djahandarie> If it can't, just run it on some remote linux box and SSH in :)
09:46:56 <Nibble> djahandarie: it can.
09:47:03 <Mitar> like i would like to have also function: doSuperPower :: FooBar -> IO ()
09:47:18 <Mitar> and if I have only AnyPacket and class instances I cannot do that
09:47:53 <Mitar> so I would like to have connections between threads which are generic: consumer can use just class functions
09:48:20 <Mitar> and other which are not: consumer gets value of exact type and can run functions on that
09:48:21 <cwb> djahandarie: Yeah, maybe I should.. I'm overdue scripting a standard tmux config anyway.. :)
09:49:17 <Mitar> and I would like to write a function, where producer does not need to think about which line it is there, it just writes to it
09:49:28 <Mitar> using sendFromFirstLine
09:49:30 <copumpkin> so to reduce your problem to a simpler one
09:49:40 <tolkad> Uh I thought that to fix a module import loop you just have to make a .hs-boot file that breaks the cycle at any point. that doesn't seem to be working
09:49:53 <tolkad> and GHCs error message is terrible
09:50:00 <copumpkin> try to write a type that can either remember or forget the type of a value it carries
09:50:19 <copumpkin> ;)
09:50:26 <Mitar> ehm
09:51:26 <copumpkin> (I'm pretty sure it's not possible)
09:51:34 <Mitar> me too
09:51:52 <Mitar> this is why i have a wrapper type, AnyPAcket
09:52:08 <copumpkin> that's the same thing, you could roll the existential into the GADT
09:52:16 <Mitar> yes, i had
09:52:17 <copumpkin> you can write an existential trivially in a GADT
09:52:37 <Mitar> what I would like is to remove MaybePacket
09:52:38 <copumpkin> so ideally you'd have something like
09:52:40 <Mitar> everything else is OK
09:52:43 <copumpkin> data NoInfo
09:52:52 <copumpkin> data Info i
09:53:07 <copumpkin> data Container a where Any :: i -> Container NoInfo; Something :: i -> Container (Info i)
09:54:24 <copumpkin> Mitar: you see?
09:54:34 <copumpkin> in fact, I think that approach works for your problem
09:54:38 <tolkad> GHC is showing me the import loop
09:54:45 <jbapple> in GHCi, I'm getting: withFile "/usr/share/dict/words" ReadMode hGetContents returning ""
09:54:46 <tolkad> but it even says [boot] in it!
09:55:00 <jbapple> but less /usr/share/dict/words in a terminal shows that it is not empty
09:55:03 <tolkad> there is a booted file in the import loop, I thought that should fix it
09:55:08 <jbapple> Am I using withFile incorrectly?
09:55:19 <execve> Is it possible to pass `f2 :: a -> IO b' into `f1 :: (a -> b) -> a -> b' or combine them somehow?
09:55:39 <jbapple> is this something having to do with lazy IO, perhaps?
09:55:45 <Mitar> hmm
09:55:54 <Mitar> copumpkin, thanks
09:56:04 <copumpkin> Mitar: throwing together a simple example
09:56:08 <jbapple> I also tried printing the length, but that gave 0 as well
09:56:50 <copumpkin> Mitar: almost done :P
09:57:58 <tolkad> gaaah why isn't this working
09:58:00 <notabel> execve: yeah, you can do that, but you'll end up with an IO b. your f1 has the same type as ($), notice
09:58:23 <execve> notabel: IO b is ok
09:58:31 <jbapple> OTOH, 'openFile "/usr/share/dict/words" ReadMode >>= hGetContents' works just fine
09:59:05 <tolkad> I'll try just adding more boot files
10:01:22 <copumpkin> Mitar: I think I have it working, just making sure it makes sense now
10:01:39 <jbapple> ok, I definitely think it's a strictness thing
10:01:46 <jbapple>  withFile "/usr/share/dict/words" ReadMode (\x -> hGetContents x >>= (print . length))
10:01:46 <Mitar> thanks
10:01:57 <jbapple> works, but withFile "/usr/share/dict/words" ReadMode (\x -> hGetContents x >>= (return . length)) does not
10:02:09 <jbapple> I think lazy IO tripped me up again
10:02:24 <tolkad> uh wait what does this mean? "Up to version 6.10 it is not possible to create mutually recursive class definitions across modules, e.g. "
10:02:38 <tolkad> does that mean even WITH hs-boot files?
10:03:37 <tolkad> haskell.org is down...
10:03:44 <tolkad> or really slow
10:03:49 <djahandarie> Fine for me
10:04:00 <djahandarie> They will be moving to a new server soon anyways
10:05:39 <tolkad> http://hackage.haskell.org/platform/mac.html
10:05:53 <tolkad> this says the latest version requires snow leopard
10:05:58 <bss03> > sum []
10:05:59 <lambdabot>   0
10:06:25 <tolkad> if I build from source with ordinary leopard will it still work?
10:06:54 <tolkad> in other words, does it use snow leopard specific features? or was that just the version the binary was compiled for?
10:07:14 <notabel> tolkad: i think it will work, if you have problems it will be linkage
10:07:38 <notabel> but the previous release had nasty issues on Snow Leopard, so this one is notable in supporting it cleanly
10:08:05 <tolkad> it's like $30 to upgrade or something
10:08:07 <copumpkin> Mitar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29858
10:08:20 <notabel> but you should upgrade to snow leopard, it's worth it :-)  (especially if you're a student, etc)
10:08:47 <tolkad> notabel: really? why?
10:09:18 <Zao> It's newer! Of course it's better!
10:09:23 <copumpkin> duh
10:09:26 <lispy> I used snow leopard 2 months when it came out at work and I couldn't tell the difference over leopard
10:09:40 <lispy> So at home I didn't bother upgrading
10:09:43 <copumpkin> lispy: very few user-level differences
10:09:50 <notabel> the speed boost is noticeable.  better handling of RAM over long-running sessions.  useability improvements in Spaces and Expose
10:09:56 <copumpkin> they even said so
10:09:57 <fryguybob> It's like leopard, but snowier.
10:10:08 <notabel> copumpkin: there are actually a lot of UI tweaks, just nothing fundamentally new
10:10:32 <tolkad> notabel: the RAM would be nice... after 20+ days of uptime I start seeing system processes using tons of RAM
10:10:36 <notabel> but they changed, e.g., Spaces+Expose significantly, just keeping the feature set the same
10:10:36 <copumpkin> yeah, but I don't consider UI tweaks significant enough to mention
10:11:05 * copumpkin spent a few hours the other day finding a way to query what space is currently selected
10:11:09 <notabel> copumpkin: one of the expose changes was fantastic for me, so i noticed.  processes with many windows got much better
10:11:27 <copumpkin> after a few hours of reverse engineering it, I googled the function I'd found
10:11:28 <Mitar> but TwoWay could have also Empty channel?
10:11:32 <copumpkin> and found someone else had it in a header
10:11:37 <notabel> tolkad: yeah, i have 4gb in my laptop, which i reboot about twice a year.  so i care about ram staying clean :-)
10:11:45 <copumpkin> Mitar: on both sides?
10:12:03 <copumpkin> Mitar: you said you didn't want NoChannel to be an option in one of your pattern matches
10:12:11 <copumpkin> sendFromFirstLine (TwoWay NoLine _) _ = return () -- I would also like that this combination is not allowed at compile time
10:12:41 <Mitar> yes, for sending it should not be allowed
10:12:45 <copumpkin> so I assumed you didn't want one-way TwoWay  or no-way TwoWay :)
10:13:03 <Mitar> i want one-way or two-way
10:13:15 <Mitar> but it should be be possible to read if there is no-way ;-)
10:13:17 <copumpkin> okay, but not NoWay
10:13:37 <copumpkin> ugh :P
10:13:54 <copumpkin> but you just said you wanted one and two way channels
10:14:03 <copumpkin> how can you read from no-way channels if they're impossible to build?
10:14:20 <Mitar> you should not be allowed to read, at compile time
10:14:33 <copumpkin> oh, you meant impossible above?
10:14:36 <copumpkin> Apocalisp: I'm listening to icelandic music!
10:14:54 <Mitar> hm, i am not really sure for writing
10:15:05 <Mitar> probably it would be smart to allow writing to noline and just discard
10:15:12 <Twey> cwb: Obviously if you've got lots of functions in one or more of those modules, it makes sense to break them down further
10:15:19 <ketil> Anybody here on windows, and willing to do me a small favor?
10:15:19 <Twey> (and re-export)
10:15:19 <Mitar> (so that same producer can be used on any channel)
10:15:32 <Mitar> but reading from something which is no-line should not be possible
10:15:34 <tolkad> ugh why is this download so slow? it's not my connection
10:15:59 <tolkad> meh
10:16:28 <copumpkin> Mitar: http://snapplr.com/15pm
10:16:28 <copumpkin> Mitar: that prevents noway TwoWays from even existing
10:17:25 <copumpkin> you could also do it with only two cases, but then you'd be able to construct bidirectional ones in two different ways, which isn't as elegant
10:18:29 <Mitar> but then now getFromFirst (TwoWay Nochannel _)  is possible on type level?
10:18:50 <copumpkin> no?
10:19:01 <copumpkin>   TwoWay  :: Channel a NotEmtpy -> Channel b NotEmpty -> TwoWay a b
10:19:10 <copumpkin> Chanel a NotEmpty can't be constructed by NoChannel
10:19:55 <copumpkin> oh, but getFromFirst (OneWayR NoChannel _) is possible
10:20:03 <copumpkin> so you need to reflect the direction in the type of TwoWay, too
10:20:26 <cwb> Twey: Yep, I'll play around with a few different splits and see what turns out best.
10:20:33 <copumpkin> Mitar: see what I mean?
10:21:16 <Mitar> yes
10:21:29 <Mitar> you now have to extend getFromFirst also to OneWay types
10:21:34 <Mitar> and there are not enforced
10:21:46 <Mitar> s/there/there they/
10:22:07 <copumpkin> but do you see how to fix it?
10:22:26 <copumpkin> the type of TwoWay needs to include the whether it's a OneWay and in what direction
10:22:52 <Mitar> i would remove OneWayL and OneWayR
10:23:05 <copumpkin> yeah
10:23:13 <Mitar> and change NotEmpty and Empty to something like Emtpy, OneDirection, OtherDirection
10:23:37 <copumpkin> data TwoWay a b c d where
10:23:38 <copumpkin>   TwoWay  :: Channel a c -> Channel b d -> TwoWay a b c d
10:23:41 <copumpkin> sendFromFirst :: TwoWay a b NotEmpty d -> a -> IO ()
10:23:43 <copumpkin> that's my ugly hack
10:23:50 <tolkad> why doesn't the compiler enforce the monad rules at compile time?
10:24:05 <copumpkin> tolkad: how would it do that?
10:24:14 <Mitar> ok, you added another d
10:24:31 <tolkad> copumpkin: code analysis
10:24:31 <Mitar> but it would be easier to change Emtpy/NotEmpty?
10:24:44 <JoeyA> Maybe Haskell needs a {-# LANGUAGE UndecidableAnalysis #-}
10:25:13 <copumpkin> Mitar: yeah, probably :) I'm not claiming my code is clean or is what you want in your program :) it's just to explore the possibilities
10:25:14 <JoeyA> hmm, probably shouldn't be enabled with a hard-coded pragma, though.
10:25:16 <copumpkin> without the nasty IO to deal with
10:25:24 <JoeyA> Hype-othesis: any IO-intensive Haskell program can be put on a purer footing without substantial memory/time performance loss while making it easier to understand.  Is this true?
10:25:35 <copumpkin> tolkad: code analysis that isn't possible?
10:26:07 <copumpkin> tolkad: even languages that do allow you to express the monad laws in the types (haskell isn't one of them) require extensive formal proofs (in the language itself) to show that something is indeed a monad
10:26:24 <copumpkin> nobody's come up with an automatic procedure for doing so
10:26:24 <Mitar> copumpkin: thanks, and I am learning new things
10:26:38 <copumpkin> Mitar: I'm glad! sorry it took me so long to figure out what you wanted :P
10:27:23 <tolkad> copumpkin: nothing's impossible if you use your imagination
10:27:55 * copumpkin imagines a dependently typed language with inference (meaning type inference, and by extension, proof/function inference)
10:27:57 <JoeyA> False. ∴ Anything is possible :-)
10:28:06 <copumpkin> and substructural types
10:28:06 <int80_h> defying the laws of physics is impossible, even with imagination.
10:28:13 <JoeyA> err:
10:28:24 <JoeyA> Imagination. ∴ Nothing is impossible.
10:28:38 <JoeyA> False. ∴ Anything is possible (equal to "Nothing is impossible")
10:28:39 <tolkad> copumpkin: well it could attempt to infer a formal proof for you and if it fails it would let you finish
10:29:13 <copumpkin> tolkad: the issue is that it might have gone down the wrong path and left you with something impossible to prove, and that's why it couldn't figure it out
10:29:15 <JoeyA> ∴ Imagination == False.  QED
10:29:44 <copumpkin> tolkad: finding proofs is as hard as finding programs, because they're the same thing
10:29:54 <copumpkin> so the problem is as hard as saying "write me a program that does this"
10:30:08 <tolkad> woot I upgraded GHC and my circular import problem seems to be gone
10:30:13 <copumpkin> yay :)
10:31:42 <conal> i'm updating a library (TV) and getting haddock parse errors for the doc strings attached to GADT constructors.  is there a way to haddock-document GADT constructors any more?  i've tried both "-- | ..." before and "-- ^ ... " after.
10:31:42 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
10:32:09 <notabel> copumpkin: well, people have come up with lots of automatic procedures for doing those proofs, it's just that those procedures have only gotten to the point of helping with the proof (a la Coq) and solving subgoals, not actually doing it for you
10:32:12 <tolkad> copumpkin: well if a human with a brain much smaller than a computer that's mostly dedicated to things other than general reasoning can do it, why not a computer?
10:32:48 <Mitar> copumpkin: maybe it would be better to move Empty/NotEmpty to a class type
10:33:00 <copumpkin> Mitar: maybe
10:33:08 <Mitar> and then requrire Channel to be an instance of that
10:33:09 <copumpkin> notabel: oh yeah, definitely
10:33:21 <notabel> tolkad: because that brain, despite its limited explicit computation capacity, is preternaturally good at recognizing patterns and finding paths.  computers can't match that yet
10:33:38 <notabel> copumpkin: i know you know, i just wanted to rep it for the proof assistants :-)
10:33:55 <copumpkin> tolkad: a computer could do it given infinite time, or very good heuristics (which is what we use)
10:34:12 <rschnck> I need to write a function that takes a list and returns the max occurence of an element in that list (i.e. [1,3,3,2] would return 2)
10:34:38 <copumpkin> rschnck: didn't two people (including me) answer that yesterday?
10:34:51 <JoeyA> last element?
10:34:51 <rschnck> copumpkin: That was removeDuplicates :P
10:34:56 <JoeyA> > last [1,3,3,2]
10:34:57 <lambdabot>   2
10:35:04 <JoeyA> > maximum [1,3,3,2]
10:35:05 <lambdabot>   3
10:35:06 <copumpkin> > maximum . map length . sort . group $ [1,3,3,3,3,2,3,2]
10:35:07 <lambdabot>   4
10:35:10 <rschnck> JoeyA: It's not the last element. 
10:35:14 <notabel> rschnck: i don't understand your function.  which element are you looking for?  i can't think of any way 2 is "maximal" in [1,3,3,2]
10:35:17 <tolkad> copumpkin: so disregarding supertasks for the moment, we just need to use machine learning algorithms to get some good heuristics
10:35:23 <copumpkin> > maximum . map length . group . sort  $ [1,3,3,3,3,2,3,2]
10:35:24 <lambdabot>   5
10:35:24 <rschnck> JoeyA: maxOccurences [1,3,3,3,3,5] = 4
10:35:31 <JoeyA> oh
10:35:35 <copumpkin> rschnck: I'm pretty sure we answered that yesterday, too :P
10:35:44 <rschnck> Well, I didn't pick up on it then :P
10:35:44 <JoeyA> what is maxOccurrences [1,3,5,3,3,3] ?
10:35:46 * copumpkin sulked cause Cale came up with the above elegant solution
10:35:47 <JoeyA> 4 or 3?
10:35:47 <rschnck> I don't want an "answer"
10:35:51 <rschnck> Just soething to get me started
10:35:54 <conal> hm.  could it be that no one documents GADT constructors?
10:35:55 <rschnck> copumpkin: OH, that
10:35:55 <copumpkin> oh
10:35:58 <rschnck> But those are all functions 
10:36:01 <JoeyA> > group [1,3,3,3,5,3]
10:36:02 <lambdabot>   [[1],[3,3,3],[5],[3]]
10:36:03 <rschnck> Like gruop, etc
10:36:05 <notabel> tolkad: so far we've had better luck explicitly encoding things like induction and such as tactics than by using machine learning
10:36:05 <rschnck> I can't use that
10:36:09 <copumpkin> rschnck: ah okay
10:36:13 <JoeyA> why can't you use group?
10:36:14 <centrinia> group . sort $ [1,3,3,3,5,3]
10:36:16 <rschnck> I'm restricted to head, (:), tail, null
10:36:17 <centrinia> > group . sort $ [1,3,3,3,5,3]
10:36:18 <lambdabot>   [[1],[3,3,3,3],[5]]
10:36:20 <JoeyA> ah
10:36:29 <rschnck> and I don't know how group works
10:36:30 <copumpkin> conal: yeah, the refined types document themselves!! ;) 
10:36:33 <rschnck> so I'd rather not use it
10:36:41 <JoeyA> Can you use any pattern matching?
10:36:43 <notabel> we know enough about the solution space that we can explicitly code things far more effectively and parsimoniously than we can train an algorithm
10:37:03 <Vulpyne> rschnck: You'll still want to do the same sort of operations.
10:37:05 <JoeyA> Another question: can you implement group manually?
10:37:12 <Vulpyne> rschnck: So you could start by writing your own group, sort, etc.
10:37:42 <tolkad> notabel: well then you need better machine learning algorithms
10:37:45 <rschnck> JoeyA: Yes to pattern matching
10:38:01 <tolkad> notabel: uh btw how long is this going to take?
10:38:29 <rschnck> So I thought i could maybe use some function that removesAll of a certain element
10:38:33 <rschnck> And counts how many times it removes it
10:38:40 <rschnck> and then outputs a list with each number of removal for each integer
10:38:47 <rschnck> and then you could just find the greatest number in that list?
10:38:51 <JoeyA> sweet, I finally found a case where join is easy to understand:
10:38:56 <JoeyA> > map (join (*)) [1..10]
10:38:57 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:39:01 <centrinia> You can implement your own sort, group, length, and maximum.
10:39:10 <rschnck> I don't know what any of those functions are :<
10:39:26 <copumpkin> group just collects adjacent equal elements into lists
10:39:30 <copumpkin> sort sorts the list :P
10:39:31 <Mitar> hmm, but i am not sure how
10:39:37 <copumpkin> and maximum picks the largest element in a list and returns it
10:39:40 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29859 this is current code
10:39:41 <centrinia> length gives the length of the list :p
10:39:52 <JoeyA> New Haskell programmers instantly pick up stuff like mapM over the list monad.  So be concerned that you haven't figured it out yet.
10:39:53 <centrinia> Oh, you will also need to implement map. :p
10:39:54 <JoeyA> (jk)
10:40:11 <notabel> tolkad: not really.  it's just that machine learning algos, almost by definition, start from nothing.  they have to be trained down from the whole haystack, even though we already know pretty much where the needle is.  it's better to just tell it explicitly than try to train away all the extraneous hay
10:40:12 <copumpkin> mapM over lists is easy peasy
10:40:20 <copumpkin> it just does a bunch of shit at once, almost literally :P
10:40:30 <rschnck> Is group i the prelude?
10:40:32 <rschnck> in*
10:40:34 <notabel> (sorry for the delay, my network connection is flakey, have to restart ssh occasionally)
10:40:54 <copumpkin> rschnck: Data.List I think
10:41:04 <copumpkin> which is still part of standard library and haskell report :)
10:41:29 <copumpkin> anyway, even if you can't use those functions
10:41:39 <copumpkin> seeing how they work and how they're implemented should give you an idea of how to write it
10:41:46 <rschnck> Wait, so I what I could do is 1. sort the list in increasing order, 2. group the list, 3. write a function that outputs the elements contained in the largest list?
10:42:01 <rschnck> The number of elements in the largest list*
10:42:37 <copumpkin> yeah, the sort makes sure you get equal elements next to each other
10:42:38 <centrinia> You can split number 3. into two parts: you would compute the number of elements in each group and then find the maximum of those numbers.
10:42:42 <copumpkin> so group can see continuous runs
10:43:07 <rschnck> Okay, I'll do that :D
10:43:13 <rschnck> Thanks for your help, sorry for my nagging.
10:43:21 <Mitar> i do not like this sollution because information is duplicated, both a and c tells if channel is Empty or NotEmpty
10:43:26 <copumpkin> no problem, let us know if you have any additional information
10:43:58 <copumpkin> Mitar: yeah, it can be done more elegantly, but not much. Often that's how you do type-level stuff in haskell, you duplicate value-level information to the type level
10:44:27 <JoeyA> > do {let xs = [0..10]; print xs}
10:44:28 <lambdabot>   <no location info>: parse error on input `}'
10:44:32 <copumpkin> if you want to experiment, learn agda, see what's possible, and then come back to haskell and use the clear mind agda has given you to implement it as beautifully as possible in haksell
10:44:33 <JoeyA> what's the syntax error here?
10:44:44 <Nibble> I have noticed that GHC gives very bad error messages when I have missed a closing )
10:45:28 <notabel> @let thefn l = maximum (map length (group (sort l)))
10:45:30 <lambdabot>  Defined.
10:45:31 <Mitar> is is possible to define a type-level function, which would return some type? like TwoWay a b -> ReadFromFirstIsPossible a (on type level) if it is possible?
10:45:32 <kmc> > do { let xs = [0..10]; print xs }
10:45:32 <lambdabot>   <no location info>: parse error on input `}'
10:45:45 <kmc> > do let xs = [0..10]; print xs
10:45:45 <notabel> > thefn [1,3,3,2]
10:45:46 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:45:46 <lambdabot>   2
10:46:01 <geheimdienst> > do { let xs = [0..10]; print xs; }
10:46:02 <lambdabot>   <no location info>: parse error on input `;'
10:46:04 <copumpkin> Mitar: only sort of
10:46:17 <copumpkin> Mitar: so you effectively want a proof that reading is possible from it? you can use another GADT in that case
10:46:26 <copumpkin> Mitar: but you can also write pure type-level functions
10:46:31 <copumpkin> using type families
10:46:37 <tolkad> uh when you try to build a cabal project and it fails with dependencies
10:46:40 <copumpkin> they didn't seem necessary to me in your case though
10:46:47 <tolkad> how do you get it to resolve those dependencies automatically
10:46:55 <copumpkin> tolkad: because the person making the .cabal file messed up maybe?
10:47:07 <copumpkin> cabal-install should get them for you
10:47:19 <Mitar> how it would be possible to do that with type families?
10:47:50 <Mitar> or GADT, i am open for any ;-)
10:47:55 <zygoloid> > do {let {xs = [0..10]}; print xs }
10:47:56 <lambdabot>   <IO ()>
10:48:13 <copumpkin> or even GA data families! :P
10:48:13 <tolkad> uh I wrote it
10:48:19 <JoeyA> > do {let xs = [0..10]; squares = map (\x -> x*x) xs; cubes = map (\x -> x*x*x) xs in putStr ("No.\tSquare\tCube\n" ++ concat (zipWith3 (printf "%d\t%d\t%d\n") xs squares cubes))}
10:48:20 <lambdabot>   <IO ()>
10:48:20 <tolkad> it tells me to run cabal configure first
10:48:29 <tolkad> and then it fails with dependencies
10:48:31 <tolkad> that I put there
10:48:32 <Mitar> ok, this will be too much for one day ;-))
10:48:37 <tolkad> how do I make it try to resolve them?
10:48:40 <copumpkin> Mitar: it's fascinating stuff
10:48:47 <copumpkin> tolkad: just type cabal install
10:48:51 <copumpkin> in your project dir
10:48:55 <Mitar> links?
10:49:18 <copumpkin> not sure there's any nice single introduction to everything you can do
10:49:21 <Mitar> i know about type families
10:49:24 <copumpkin> maybe http://www.haskell.org/haskellwiki/Category:Type-level_programming ?
10:49:28 <Mitar> i am using that elsewhere
10:49:42 <copumpkin> do you understand the curry-howard correspondence?
10:49:52 <copumpkin> that's pretty eye-opening and helps a lot
10:50:00 <JoeyA> So do type families basically let you do full-fledged lambda calculus over types (with limitations unless UndecidableInstances is enabled)
10:50:02 <JoeyA> ?
10:50:08 <tommd> tolkad: cabal install should auto-install deps.
10:50:51 <Mitar> ok, i do not know it, yet ;-)
10:50:54 <tolkad> oh that's great something failed to install
10:50:59 <tolkad> lol
10:51:02 <Mitar> will put it on the have-to-read-and-understand stack
10:51:03 <centrinia> @let countFilter p (c,[]) = c; countFilter p (c,x:xs) = let (c',xs') = countFilter p xs in if p x then (c',x:xs') else (c'+1,xs')
10:51:03 <lambdabot>  <local>:4:66:
10:51:04 <lambdabot>      Couldn't match expected type `[t]'
10:51:04 <lambdabot>             against in...
10:51:08 <copumpkin> Mitar: very simple idea, very powerful
10:51:28 <copumpkin> Mitar: @djinn in this channel is a simple way to play with it
10:51:34 <tolkad> judy-0.2.2 failed during the building phase. The exception was:
10:51:35 <tolkad> exit: ExitFailure 1
10:51:44 <tolkad> descriptive, I like it
10:52:07 <tolkad> I guess it breaks in newest version of GHC?
10:52:33 <c_wraith> @djinn (s -> (s, a)) -> (a -> s -> (s, b)) -> (s -> (s, b))
10:52:33 <lambdabot> f a b c =
10:52:33 <lambdabot>     case a c of
10:52:33 <lambdabot>     (d, e) -> b e d
10:53:05 <c_wraith> That's probably a homework assignment in some classes.  and djinn just does it.
10:53:07 <kmc> tolkad, try -v
10:53:18 <copumpkin> Mitar: the most basic idea is that types are logical statements, and values of a given type are proofs of the equivalent statement
10:53:33 <Mitar> i know a little bit abouth type families, but i am not sure how can this be of helping reading of that additional type argument
10:53:36 <copumpkin> Mitar: (,) is and, Either is or, (->) is implication
10:54:00 <tolkad> ghc could not execute ghc-6.12.3/ghc-asm?
10:54:03 <tolkad> 0_o
10:54:15 <tolkad> what's that mean
10:54:38 <tolkad> I'll check permissions I guess
10:54:58 <tolkad> it has full execute permissions
10:55:22 <tolkad> I have no idea what to do. that's an internal GHC file
10:55:30 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29860#a29860
10:55:39 <copumpkin> maybe ask in #ghc? or find us a full log of what it tried to do?
10:56:11 <tolkad> ooh someone else had the same problem
10:56:38 <Lal`C> Ugh. Network.HTTP doesn't support HTTPS, does it...
10:56:40 <tolkad> which linked to this ticket: http://hackage.haskell.org/trac/ghc/ticket/4183
10:56:58 <centrinia> @let countFilter p (c,[]) = (c,[]); countFilter p (c,x:xs) = let (c',xs') = countFilter p (c,xs) in if p x then (c',x:xs') else (c'+1,xs'); foo [] = 0; foo (x:xs) = let (c',xs') = countFilter (x/=) (0,xs); c'' = foo xs' in max (c'+1) c''
10:57:00 <lambdabot>  Defined.
10:57:02 <Mitar> seems data families are not the same as type families
10:57:04 <centrinia> Okay.
10:57:11 <tolkad> woot fixed it
10:57:21 <Guest24157> is there a logical comparator for haskell, like && for C++?
10:57:27 <kmc> :t (&&)
10:57:28 <lambdabot> Bool -> Bool -> Bool
10:57:32 <copumpkin> Mitar: they are type families + data declarations, giving you injectivity along the way
10:57:43 <Guest24157> Well then :)
10:57:49 <kmc> Mitar, yeah. to be unambiguous we talk about "data families" versus "type synonym families"
10:57:58 <Lal`C> Guest24157: also all
10:57:59 <centrinia> :t (++) -- There is no operator for Haskell like ++ for C++ though.
10:58:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:58:00 <Lal`C> :t all
10:58:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:58:07 <Lal`C> oh wait
10:58:07 <Lal`C> haha.
10:58:09 <Mitar> i read fun with types article
10:58:13 <Lal`C> nevermind.
10:58:25 <Nibble> Is there any plan for next GTK2HS release?
10:58:28 <centrinia> :t and
10:58:29 <lambdabot> [Bool] -> Bool
10:58:32 <Mitar> it tals about type families?
10:58:37 <Lal`C> aha.
10:58:52 <centrinia> > foo [1,3,3,3,5,3]
10:58:53 <lambdabot>   4
10:58:59 <int80_h> kmc: you have time to peek at me code on hpaste?
10:59:18 <Lal`C> Saizan: any idea if Network.* supports HTTPS?
10:59:31 <kmc> yeah int80_h
10:59:50 <Guest24157> non-programming question: is the empty set equal to the empty set?
10:59:54 <kmc> yes
11:00:06 <Guest24157> Roger that :)
11:00:10 <Guest24157> Thanks guys!
11:00:13 <kmc> {} = {} because ∀ x ∈ {}, x ∈ {}
11:00:19 <Mitar> but i do not understand how can this help us get rid of Empty and NotEmpty
11:00:21 <kmc> heh
11:00:26 <Saizan> Lal`C: i think it doesn't, but i never checked
11:00:27 <tolkad> uh what? it's telling me it can't find Data.Map now
11:00:30 <kmc> what kind of mathematician accepts "yes" for an answer
11:00:36 <tolkad> I'm never upgrading GHC again this is terrible
11:00:36 <int80_h> kmc: cool, want me to repost the url?
11:00:39 <Nibble> kmc: a great one.
11:00:42 <Lal`C> Saizan: doesn't seem to as far as I can tell :(
11:00:46 <kmc> ah, found it
11:01:15 <tolkad> if I try cabal install containers it says it's already installed. I'll try reinstall
11:01:30 <Mitar> we would have to split Channel into different types
11:01:45 <tolkad> on that didn't work
11:01:47 <Mitar> but then how can we get allow them as an argument
11:01:48 <copumpkin> Mitar: yeah, you can't get rid of that
11:01:54 <copumpkin> Mitar: unless you have dependent types
11:02:04 <Mitar> and does haskell has that?
11:02:07 <copumpkin> no
11:02:08 <Mitar> hm
11:02:17 <kmc> int80_h, what's the question?
11:02:20 <Mitar> and data families and gadt cannot help there
11:02:21 <Mitar> ?
11:02:31 <copumpkin> Mitar: they definitely can help, but you have to have some sort of dupliation
11:02:39 <Mitar> like we have?
11:02:39 <int80_h> kmc: oh dear, I thought I specified the question
11:02:43 <copumpkin> yes
11:02:50 <kmc> well
11:02:50 <copumpkin> because what you want in the end is for the type of something to reflect its value
11:02:57 <int80_h> kmc: I'm wondering what the syntax would be for what I am trying to accomplish. 
11:02:57 <kmc> is your question just "how do i write dealWithTable"?
11:03:10 <kmc> int80_h, did you try to write it?
11:03:13 <int80_h> kmc: well, I want to know if my approach is right
11:03:24 <tolkad> I'm asking in #ghc
11:03:30 <kmc> int80_h, what problem are you trying to solve, and why does it need this heavy machinery?
11:03:54 <tolkad> they aren't answering... anyone know how I can make them answer?
11:04:23 <ddarius> tolkad: Pay them.
11:04:59 <kmc> tolkad, you realize that the channel #ghc is not a way to talk to the program GHC itself?
11:05:05 <kmc> <tolkad> so stop telling me it's not installed
11:05:20 <int80_h> kmc: a file will be processed in one of three different ways. I distinguish these ways with types. But I cann't write a function that can accept one of three different kinds of type without using typeclasses, or a GADT. I chose to use a GADT because they are new to me. I could have used the typeclass approach.
11:05:23 <tolkad> kmc: well if GHC tells me something it's basically the developers telling me
11:05:36 <mauke> ghc is not cabal
11:05:41 <tolkad> oh
11:05:56 <tolkad> they came together when I installed the haskell platform
11:06:26 <kmc> int80_h, "I distinguish these ways with types." why?
11:06:33 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29861
11:07:00 <Mitar> why this says that patterns are not exhaustive?
11:07:10 <int80_h> kmc: because the data in the files will be of different types, which means I will have to treate them in slightly different ways even though the operations will be the same in all three cases.
11:07:28 <tolkad> ooh maybe someone else had the problem before and talked about it on the internet
11:07:30 <kmc> Mitar, because GHC doesn't check that the remaining cases are impossible by types
11:07:34 <tolkad> if so, google might have indexed it
11:07:41 <tolkad> in which case I could find it through google
11:08:08 <Mitar> but if I do not use ( , ) around types, then it works
11:08:58 <Mitar> (previous version)
11:09:54 <kmc> int80_h, do you gain any static checking this way?
11:10:14 <int80_h> kmc: I don't know.
11:10:21 <kmc> compare: data SomeTable = TStudents Students | TActivityCosts ActivityCosts | TStudentActivities StudentActivities
11:10:23 <int80_h> I'm in new territory here.
11:11:55 <int80_h> kmc: I wanted a generic way of passing data too a function without knowing it's type ahead of time
11:12:07 <kmc> yeah
11:12:20 <kmc> that sounds like the opposite of a use case for GADTs
11:12:31 <kmc> int80_h, did you consider a simple variant type like i described?
11:13:27 <kmc> int80_h, the point of GADTs is to push some knowledge about your problem domain into the type system, so it can be statically checked.  if you then wrap away the GADT type parameter in an existential, and work in those terms, you've defeated that purpose
11:13:29 <int80_h> kmc: but what would the type signatue of dealWithTable look like?
11:13:56 <int80_h> kmc: so I *should* be using typeclasses
11:14:08 <kmc> int80_h, i didn't say anything about type classes
11:14:34 <int80_h> kmc: because what I've got are the same operations that will be done in three different cases. Which seems like what typeclasses should be used for. Plus I can wrap my head around that concept alot easier anway
11:15:26 <tolkad> int80_h: you could also do both
11:15:30 <kmc> int80_h, what do the two parameters to dealWithTable mean?
11:15:36 <tolkad> int80_h: SomeTable, and a type class
11:15:59 <kmc> i am suspicious of code which uses lots of fancy type trickery to solve a simple problem, and even type classes count as some amount of type trickery
11:16:01 <kmc> there's often a simpler solution
11:16:16 <c_wraith> wait, are type classes more trickery than GADTs?
11:16:41 <c_wraith> And where do phantom types rate? :)
11:17:57 <int80_h> kmc: pname is one of three possible types, Loader PNStudentsm Loader PNCosts, or Loader PNActivities. tbl is troubling me, I didn't write this code. I flucuate between thinking I know what it means and thinking I don't. I really don't.
11:18:39 <int80_h> kmc: I wish I could use ghci to print out tbl, but I can't.
11:19:22 <int80_h> kmc: I had another question I was saving, but I htink it would help to be able to use Show to see tbl.
11:19:45 <kmc> wait' you didn't write this code?
11:20:00 <int80_h> kmc: No, someone in the channel did
11:20:15 <int80_h> kmc: I mean, main.lhs. I did the other file
11:20:22 <kmc> what is dealWithTable supposed to do anyway
11:20:29 <kmc> oh, i'm ignoring main.lhs for now
11:20:34 <kmc> "deal with" is a pretty vague verb
11:21:17 <int80_h> kmc: well, I want it to be able to pass the [string] in tbl to the appropriate function. That function will then parse the [string]. dealwithTable will then populate a database with the parsed data.
11:21:34 <kmc> ok
11:21:42 <kmc> and the database is something external accessed via IO?
11:22:21 <int80_h> kmc: well that's going to be another problem. I'm not convinced IO is right but I can hold off on that for now.
11:22:28 <kmc> is the hope in separating it like this that the database populator can be generic for all types?
11:23:25 <int80_h> kmc: no, just generic for the types I need for this toy code. There will only be one of three possibilities
11:23:38 <kmc> yeah
11:23:44 <kmc> since you have this closed world of three types
11:23:48 <int80_h> I won't need to expand
11:23:52 <kmc> it seems like a variant is the simple solution
11:24:01 <int80_h> variant?
11:24:11 <kmc> data SomeTable = TStudents Students | TActivityCosts ActivityCosts | TStudentActivities StudentActivities
11:24:13 <kmc> or the like
11:24:36 <int80_h> how will I know what function to pass to?
11:24:42 <kmc> pattern matching?
11:25:09 <int80_h> I can pattern match based on types?
11:25:13 <kmc> no
11:25:22 <kmc> you can pattern-match on the constructors TStudents, TActivityCosts, etc.
11:26:19 <int80_h> kmc: okay I am going to try your suggestion. 
11:26:31 <int80_h> I was hoping to get to play with GADTs
11:26:38 <int80_h> but simpler is better
11:26:54 <kmc> int80_h, then choose a problem where GADTs are appropriate, and solve that instead :)
11:27:26 <kmc> btw, i think you might want a type class here
11:27:33 <kmc> to marshall data into the database
11:27:35 <int80_h> kmc: bah I was saying that before!
11:27:52 <int80_h> I figured either a GADt or a type class was the way to go
11:28:08 <kmc> int80_h, i don't see how they're alternatives at all
11:28:15 <kmc> and i'm not sure the type class i'm proposing is the one you had in mind
11:28:38 <int80_h> kmc: well, what did you have in mind then?
11:28:45 <kmc> but somewhere you need to define how the types ID, Student, Activity, and Cost map into your database's API
11:28:51 <kmc> let me just code it, hold on
11:31:27 <kmc> int80_h, you want a function of type «Table k v → IO ()» right?
11:31:32 <kmc> which takes any table and loads it into your database
11:32:21 <kmc> but most databases won't be able to store all Haskell types
11:32:45 <kmc> so you can use a class to constrain k and v (probably separately, but maybe together) and provide the marshalling functions
11:32:46 <kmc> makes sense?
11:32:58 <kmc> you've an instance for each column type in the database.  not an instance for each table
11:33:48 <int80_h> kmc: well the database will either be storing a String or an Int
11:35:08 <int80_h> kmc: I do not understand your notation ?Table k v ? IO ()?
11:35:20 <kmc> your client doesn't understand Unicode?
11:35:29 <Gracenotes> 'Table k v -> IO ()'
11:35:33 <kmc> "Table k v -> IO ()"
11:35:34 <int80_h> irssi? I guess it doesn't
11:35:45 <Gracenotes> the infamous question mark type operator
11:36:47 <int80_h> kmc: okay I got it, yeah that is what I want. When I confront that IO () may not be the right return type I'll look into what I need to be doing. But that is right enough for now
11:37:25 <int80_h> mr of arc!
11:43:20 <kmc> int80_h, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29865#a29865
11:44:17 <kmc> int80_h, does this do what you want?
11:44:19 <int80_h> kmc: thanks, reading...
11:44:31 <kmc> the functions starting with "dbapi" i assume are provided for you by the database API
11:44:42 <kmc> it's not a very reasonable API, but you can adapt it
11:46:07 <yaru1022> hey guys, I have a question on Control.Applicative.
11:46:20 <yaru1022> Supposed I have data Person = Person { name :: String, age :: Int} deriving (Show)
11:46:39 <yaru1022> I wonder how the type inference work on "Person <$> name"
11:46:52 <yaru1022> :t (<$>)
11:46:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:47:03 <kmc> well, name :: Person -> String
11:47:21 <c_wraith> kmc, that's not right at all
11:47:36 <kmc> which?
11:47:49 <yaru1022> type of "(<$>) Person" is: f String -> f (Int -> Person)
11:47:55 <c_wraith> name :: Functor f => f String
11:48:15 <kmc> c_wraith, ? it's defined as a record accessor
11:48:19 <yaru1022> c_wraith: how is it so..?
11:48:23 <int80_h> kmc: no this doesn't do what I want. But you've given me something to work with. I can at least write something that breaks, and we can talk about that.
11:48:23 <c_wraith> Oh.
11:48:27 <c_wraith> hah.
11:48:29 <c_wraith> right.
11:48:32 <kmc> int80_h, how does it fail?
11:48:40 <kmc> yaru1022, so we have to unify the second arg of (<$>), which is «f a», with «Person -> String»
11:49:06 <kmc> yaru1022, giving us «f = (->) Person», «a = String»
11:49:28 <yaru1022> hm... let me process for a sec =)
11:49:30 <int80_h> kmc: well, I think I need instances for ID, Student and Activity. Not String. That seems to have defeated the purpose of me making those newtypes.
11:49:45 <kmc> int80_h, indeed, i'm not sure why you made the newtypes
11:50:22 <int80_h> kmc: someone told me it was good style to name my types based on what they were used for, and that made sense.
11:51:10 <int80_h> kmc: also that way I couldn't confuse a Student for an Activity
11:51:17 <kmc> int80_h, i agree with that advice generally
11:51:22 <yaru1022> kmc, so (->) Person is a functor...?
11:51:28 <kmc> but in this case you're just wrapping them and then unwrapping them
11:51:32 <kmc> yaru1022, yes
11:51:34 <kmc> @src (->) fmap
11:51:34 <lambdabot> fmap = (.)
11:52:09 <int80_h> kmc: let me think a minute about what I'm trying to do again...
11:52:13 <yaru1022> kmc, hm ; I'm somewhat confused lol
11:52:16 <kmc> int80_h, you're interfacing two data representations that don't know about your types (String and database)
11:52:36 <yaru1022> how come ghci says parse error when I try to infer type of (->)?
11:52:39 <yaru1022> like :t (->)
11:52:42 <kmc> because (->) isn't an expression
11:52:45 <kmc> it's a type constructor
11:52:49 <kmc> it doesn't have a type, it has a kind
11:53:03 <kmc> you can't say ":t Maybe" either
11:53:12 <yaru1022> ah... i see
11:53:29 <geheimdienst> note that «(->) String Int» is another way to write «String -> Int»
11:53:51 <geheimdienst> (kmc, right?)
11:53:55 <kmc> yes
11:54:16 <int80_h> kmc: well, if nothing else, making those newtypes should make my code more readable right?
11:54:27 <kmc> and we write the partial application like «(->) A», though you might wish that «(A ->)» were valid syntax
11:54:40 <kmc> int80_h, not if it introduces more noise of wrapping/unwrapping constructors
11:54:55 <kmc> int80_h, the amount of code that could be "type safe" here is tiny
11:55:02 <kmc> since you're connecting two type-naive systems
11:55:10 <int80_h> kmc: okay, I will re-evaluate what you wrote
11:55:19 <kmc> int80_h, you could just use type synonyms rather than newtype
11:55:40 <yaru1022> kmc, thanks for the explanation. It makes sense.
11:55:43 <kmc> :)
11:56:35 <int80_h> kmc: I just thought of something
11:57:36 <int80_h> kmc: the tables I will populate in the database will be different depending on whether I am using a Cost or an ID, a Student or an Activity. How will I distinguish without using newtype?
11:58:12 * hackagebot TV 0.4.7 - Tangible Values -- composable interfaces  http://hackage.haskell.org/package/TV-0.4.7 (ConalElliott)
11:58:57 <kmc> how will they differ?
11:59:04 <kmc> if your database only knows String and Int
12:00:03 <int80_h> kmc, but what value goes in what column will depend on Cost or ID, Student or Activty. the database only knows String or Int, but I know the difference. And I will populate a different table depending on those differences.
12:00:28 <tkahn6> anyone know of a good Mechanize-like Haskell library? I found Shpider but it dies during install from cabal.
12:00:37 <kmc> well you know what table to populate from the "tableName" field of Table
12:01:01 <kmc> perhaps you need to keep the newtypes, and augment writeValueToDB
12:01:19 <kmc> or perhaps there's a simpler solution, like adding a field to Table:  tableCols :: (String, String)
12:02:13 * hackagebot GtkTV 0.1.7 - Gtk-based GUIs for Tangible Values  http://hackage.haskell.org/package/GtkTV-0.1.7 (ConalElliott)
12:03:07 <int80_h> kmc: yes you have given me useful things to think about. I am unstuck enough to move forward.
12:03:12 <kmc> yay :)
12:03:59 <int80_h> kmc: So I'm going to go do that and come back later with something that is probably broken somehow ;)
12:06:10 <tkahn6> so ah, any advice on finding a good Mechanize-like library for haskell? 
12:11:16 * hackagebot GtkTV 0.1.8 - Gtk-based GUIs for Tangible Values  http://hackage.haskell.org/package/GtkTV-0.1.8 (ConalElliott)
12:11:32 <notabel> tkahn6: is the build failure on shpider caused by parsec?  it needs parsec2, which you may not have
12:12:18 <Taejo> bos: are there docs for text-icu somewhere, since it doesn't build on hackage?
12:12:27 <tkahn6> nah it's three type-checker errors in the form of "Network/Shpider/Forms.hs:59:17:    `Tag' is not applied to enough type arguments    Expected kind `*', but `Tag' has kind `* -> *'"
12:13:23 <tkahn6> which is a bummer because i'd rather do this part in haskell than in python
12:16:03 <ferret_0567> Hello
12:16:18 <ferret_0567> I am making a program to solve Project Euler Problem 3
12:16:34 <ferret_0567> the only problem is, I get a parse error on input = on line 15 :(
12:18:35 <ferret_0567> here is the program: http://tinyurl.com/29jw7bu
12:19:18 <kmc> your "t = f x" is not inside a "let"
12:19:25 <ferret_0567> oh
12:19:56 <kmc> also why do you have lots of variables equal to 1 and 2?
12:20:08 <kmc> rather than using 1 and 2 where they occur
12:20:39 <kmc> "let x = 2; y = 2 ... in gcd(abs(x - y), n)"
12:20:51 <kmc> that'd just be gcd(0,n) yes?
12:20:58 <kmc> also that's not the right syntax for calling functions in haskell
12:21:13 <kmc> we write f x y z, and you only need parentheses for grouping
12:21:15 <copumpkin> it can be :(
12:21:35 <kmc> yes, it's the right syntax (though bad formatting imo) for calling a function with one argument which is a tuple
12:21:43 <kmc> which is probably not what you want
12:22:16 <Tarrasch> Hello! I've been learning haskell and I like it! I must ask though, on a global perspective, which are it's greatest applications? Are their any big programs (OpenSource or commercial) that is used, like say, The Gimp or similar?
12:22:34 <kmc> Tarrasch, the biggest applications are internal to various companies
12:22:58 <kmc> Galois (galois.com) does a bunch of government / defense contracting in Haskell
12:23:18 <copumpkin> http://xmonad.org/ http://darcs.net/ are two commonly cited applications
12:23:25 <kmc> Tarrasch, http://www.haskell.org/haskellwiki/Haskell_in_industry
12:23:34 <sm> and http:/haskell.org/ghc
12:23:39 <copumpkin> a bunch of compilers and language implementations are also in haskell
12:23:43 <copumpkin> including GHC itself :)
12:24:11 <bos> Taejo: not handy, no :-(
12:24:25 <Tarrasch> about darcs, I've heard it's commonly used among haskellers, but does it have users outside of the community too? Are their many who thinks it's better than say git?
12:24:26 <bos> preflex: seen andyjgill
12:24:26 <preflex>  andyjgill was last seen on #haskell 2 days, 14 hours, 15 minutes and 52 seconds ago, saying: bos: are you getting good results, or getting annoyed?
12:24:31 <bos> preflex: seen dons
12:24:31 <preflex>  dons was last seen on #haskell 18 hours, 41 minutes and 10 seconds ago, saying: tommd: heading over now.
12:24:49 <Tarrasch> I'm more looking for gossip rather than factual probeable opinions. :)
12:24:49 <tommd> bad preflex
12:25:03 <tommd> no botsnack
12:25:33 <kmc> Tarrasch, I'm a big fan of Haskell and I think git is better than darcs
12:25:37 <kmc> but i haven't used darcs all that much
12:25:59 <copumpkin> I like both, but I think they solve different problems and prefer the git workflow
12:26:10 <kmc> git doesn't really have a single workflow
12:26:15 <copumpkin> well
12:26:16 <geheimdienst> tarrasch, the thing that made me move away from git was the horrible, convoluted user interface
12:26:22 <copumpkin> prefer the workflow that git lets me have, then ;)
12:26:26 <kmc> heh
12:26:41 <copumpkin> I really like cheap local branches
12:26:46 <Tarrasch> oh ok, very grateful for you opinions :)
12:27:25 <kmc> at any rate i wouldn't judge Haskell by darcs
12:27:32 <kmc> any more than i'd judge C by Linux
12:27:43 <geheimdienst> i recall when i went on the #git channel and asked something involving "git ls-files --cached", and they said basically "oh, you thought that would list the cached files? haha, of course not. you must be stupid or something"
12:27:58 <copumpkin> well, most IRC communities are unfriendly
12:28:05 <Tarrasch> Haskell is not
12:28:23 <kmc> Tarrasch, there's a talk on "The Design and Implementation of XMonad" which you might like
12:28:27 <Tarrasch> it's a very, very good irc channel out of those I've seen
12:28:54 <kmc> since xmonad is fairly popular, outside the haskell community even, and the talk goes into details of how using Haskell was helpful
12:29:01 <Tarrasch> kmc, on the haskell-caf? Or where is the talk? :s
12:29:04 <kmc> google
12:29:13 <Tarrasch> t
12:29:39 <kmc> there are other experience reports from using haskell in the real world, e.g. Starling Software's paper about automated financial trading: http://www.starling-software.com/misc/icfp-2009-cjs.pdf
12:29:57 <kmc> and various other talks from different years of the CUFP workshop
12:30:36 <tkahn6> does bloomberg do haskell programming?
12:30:41 <tkahn6> they're coming to my school
12:31:00 <tkahn6> it says Unix C/C++ for their internships, but i was just curious
12:31:09 <kmc> tkahn6, i worked with some ex-bloombergers and they never said anything about it
12:31:12 <kmc> but it's a big company
12:31:25 <tkahn6> ah ok. i'll ask them when they come
12:31:30 <tkahn6> that would be awesome
12:31:41 <kmc> Haskell is sometimes used internally to small groups, in roles where upper management doesn't know or care what language is used
12:31:59 <tkahn6> right yeah, i've heard that before
12:32:26 <kmc> if you're on a team of hundreds of developers writing a library for thousands of users, it's not likely you could get away with it
12:33:24 <Raghs> I am running throught he Hitchhikers tutorial and am running into a compile error with dirAndSize function - with the many1 digit  function call
12:33:39 <Raghs> No instance for (Text.Parsec.Prim.Stream s m Char
12:33:52 <Raghs> is there a way to fix this error
12:35:12 <Raghs> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29867#a29867
12:36:34 <ajnsit> can someone point me to a good document on the difference between gadt witness types and phantom types in Haskell? I'm afraid I'm getting quite confused reading up various pages on the net
12:36:43 <edon> what do i have to pass to ghc to compile when using Data.Set seems like the linker is complaining?
12:36:50 <kmc> edon, --make
12:36:59 <kmc> if you invoke ghc yourself, you should pretty much always pass --make
12:37:18 <edon> kmc: thanks
12:37:28 <kmc> i wish it were the default in fact
12:37:32 <kmc> overridden by -c etc
12:39:21 <Tarrasch> ajnsit, http://en.wikibooks.org/wiki/Haskell/GADT
12:39:38 <yaru1022> kmc, hey, continuing from what I was doing before, I tried to determine the type of (<*>) (Person <$> name) expression and finally figured it out. It took me so long even just to figure out the type of an expression. I'm wondering how Haskell programmers can figure out types and use certain expressions so quickly... How can I train myself to become one? Or am I just spending too much time on a useless thing?
12:39:45 <Tarrasch> ajnsit, It explains what the problem is, partially half-solves it with phantom types then moves on to gadt with good usage.
12:40:27 <ajnsit> Tarrasch, that page doesn't explain witness types
12:40:42 <ajnsit> do you have any suggestions for witnesses?
12:40:46 <Tarrasch> ajnsit, oh sorry, thought you were confused about gadts, sorry
12:41:00 <Tarrasch> ajnsit, sorry, don't even know what that is ^^
12:41:43 <ajnsit> I found this and was intrigued - http://www.haskell.org/haskellwiki/Type_witness
12:41:49 <ajnsit> but could not understand how they worked
12:42:06 <ajnsit> and especially how they differ from phantom types
12:43:09 <Tarrasch> yaru1022, I liked the typeclassopedia. I think it's a good start. It's probably for those who don't feel comfortable with Applicative, Monads etc.
12:43:20 <dolio> The types on that page allow matching to refine the types.
12:43:33 <dolio> So if you have 'foo :: Witness a -> ...'
12:43:42 <yaru1022> Tarrasch, you mean typeclassopedia from The Monad.Reader?
12:43:50 <Tarrasch> yaru1022, yea
12:43:51 <aristid> yaru1022: yeah
12:44:02 <dolio> Then when you write 'foo IntWitness ...' you know that a = Int.
12:44:06 <yaru1022> ok, I'll go and read it now =)
12:44:12 <dolio> In that branch.
12:44:48 <ferret_0567> ok...wtf? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29868
12:45:44 <aristid> ferret_0567: is that your code?
12:46:24 <ferret_0567> yes
12:46:30 <ferret_0567> why? is it horrible?
12:46:56 <tkahn6> what you could do is generate a lazy list of primes up to the sqrt of the number and then filter map modulo
12:47:00 <aristid> ferret_0567: your functions take no parameters, but use them anyways
12:47:10 <ferret_0567> what?
12:47:14 <ferret_0567> that makes no sense
12:47:24 <tkahn6> you're trying to find the prime factors correct?
12:47:25 <Kaidelong> I think what he means is
12:47:27 <aristid> ferret_0567: yeah.
12:47:32 <Kaidelong> > const 2 undefined
12:47:33 <lambdabot>   2
12:47:37 <aristid> ferret_0567: it makes no sense because it's a mistake on your part
12:47:45 <aristid> factorPt2 :: n -> d -> (f -> b) -> a          
12:47:58 <aristid> this is not the line where you declare the parameter types
12:48:02 <Kaidelong> @djinn n -> d -> (f -> b) -> a
12:48:02 <lambdabot> -- f cannot be realized.
12:48:05 <aristid> *parameter names
12:48:13 <ferret_0567> err...then what line is it?
12:48:30 <aristid> factorPt2 n d f a =
12:48:37 <ferret_0567> oh!
12:48:44 <ferret_0567> Ha
12:48:55 <JoeyA> quick questions about pronunciation:  I've been saying Hask-ELL and tUples.  Do people usually pronounce them Haskl and tooples?
12:49:05 <tkahn6> i've heard tooples
12:49:06 <cads> can someone suggest a good tutorial on using the ST monad?
12:49:07 <Tarrasch> These type-witnesses seem cool, not to hard to understand it seems, or at least not hard to trick the brain that it thinks it understands ;)
12:49:08 <ferret_0567> So, factorPt2 :: would be the line where I declare the types of the parameters
12:49:12 <Kaidelong> Joey: not me personally
12:49:31 <cads> JoeyA, basicall
12:49:32 <cads> y
12:49:36 <JoeyA> Phillip Wadler says Haskl
12:49:47 <cads> I say haskl
12:49:49 <aristid> ferret_0567: yes, and only the types, not the names.
12:49:59 <cads> otherwise people think you're saying pascal
12:49:59 <aristid> i say häskel
12:50:00 <JoeyA> haskl is nice and shorter
12:50:04 <ddarius> JoeyA: I say Haskell like Pascal, but I think most say Haskell like rascal.
12:50:26 <ddarius> Similarly, I say tooples, but a lot of people say tuples like couples.
12:50:44 <Kaidelong> I have trouble talking to people where I tell them I wrote it in Haskell already and they say "oh Pascal right, I remember that"
12:50:49 * djahandarie says things like the second half of ddarius' sentences
12:50:52 <Kaidelong> usually older people
12:51:01 <aristid> ddarius: english's non-phonetic script makes these things harder to describe :P
12:51:24 <kdvh> >:t (<=<)
12:51:28 * hackagebot continued-fractions 0.9.1.0 - Continued fractions.  http://hackage.haskell.org/package/continued-fractions-0.9.1.0 (JamesCook)
12:51:34 <aristid> Kaidelong: i'm always struggling when older programmers ask me what language Haskell is similar to
12:51:47 <aristid> last time i said "it's relatively similar to Lisp, but not quite"
12:52:00 <ddarius> There are phonetic things like IPA but heck if I'd be able to find how to type in the IPA stuff.  The more English centric pronunciation guides are easier to type in, but I don't have them memorized.
12:52:10 <Kaidelong> aristid: I can see how that'd be a problem
12:52:22 <ddarius> aristid: Just say it is a more practical, typed version of ISWIM.
12:52:34 <Kaidelong> there are precedents for Haskell but none of them seem to have been particularly well known
12:52:42 <aristid> ddarius: German has a phonetic script, with the only problem that it lacks many sounds
12:52:53 <aristid> what is "ISWIM"?
12:53:03 <ddarius> @google "if you see what I mean"
12:53:03 <lambdabot> http://en.wikipedia.org/wiki/ISWIM
12:53:04 <lambdabot> Title: ISWIM - Wikipedia, the free encyclopedia
12:53:18 <Colours> hi! I am following http://www.haskell.org/haskellwiki/Using_Haskell_in_an_Xcode_Cocoa_project , can anyone help me with some errors I am getting with it?
12:53:29 * hackagebot gamma 0.7 - Gamma function and related functions.  http://hackage.haskell.org/package/gamma-0.7 (JamesCook)
12:53:33 <Colours> (they are Xcode errors
12:53:40 <djahandarie> If the person knows ML it is certainly similar to that
12:53:59 <aristid> ddarius: heh that might work if they were more academically inclined than they are :)
12:54:00 <Kaidelong> haskell is also quite fundamentally different from most MLs
12:54:09 <Kaidelong> but it's a better analogy than LISP, I guess
12:54:16 <aristid> Kaidelong: i think saying "Haskell is like Lisp" is a total lie
12:54:16 <Kaidelong> and ML is pretty well known now
12:54:22 <aristid> but they don't know ML
12:54:29 <djahandarie> aristid, do they know F#
12:54:29 <ketil> Any idea what this means?  "cabal: fromFlag NoFlag. Use fromFlagOrDefault"
12:54:35 <ddarius> "Haskell is like F#"
12:54:37 <aristid> djahandarie: i don't know
12:54:39 <Kaidelong> well I don't know, the first language I learned in a CS course was SML
12:54:44 <aristid> djahandarie: i guess not tho
12:54:44 <Kaidelong> of course, I was programming long before
12:54:46 <Kaidelong> but still
12:54:50 <aristid> these people prefer C over C++
12:54:52 <aristid> nuff said :P
12:55:10 <Kaidelong> F# is probably the closest thing to Haskell that's relatively mainstream
12:55:15 <ddarius> "Haskell is like C"
12:55:17 <ferret_0567> :(
12:55:19 <Kaidelong> figures since I think some of the same people were involved
12:55:22 <aristid> ddarius: LOL
12:55:27 <ferret_0567> How am I supposed to pass state between functions
12:55:39 <Zao> ferret_0567: Cumbersomely.
12:55:40 <Mitar> mitar
12:55:47 <Zao> ferret_0567: Depends on what types you talk about.
12:55:48 <aristid> ferret_0567: explicitly
12:55:54 <ferret_0567> Zao: all integers
12:56:03 <Zao> ferret_0567: I mean your "functions".
12:56:16 <medfly> aristid, I think Haskell is like Lisp not in terms of language features
12:56:22 <medfly> aristid, but in other senses
12:56:29 <Kaidelong> ferret_0567: what do you need to pass state around for. Could you do it with a finite state machine? Those are easy to write in Haskell
12:56:45 <ferret_0567> Kaidelong: I've never written a finite state machine before
12:56:55 <aristid> medfly: compared to C or Pascal, Lisp is certainly closer to Haskell
12:57:12 <Kaidelong> just where you have functions making tail calls to other "states" which are also functions and they keep calling each other until one returns
12:57:15 <Zao> ferret_0567: I hear that you can do much by passing in arguments and returning values.
12:58:34 <ferret_0567> err...I double that when you have a nice let block that declares the variable you are trying to pass
12:59:18 <ferret_0567> nvm
12:59:23 <ferret_0567> I think I've got it
13:00:32 * hackagebot roots 0.1 - Root-finding algorithms (1-dimensional)  http://hackage.haskell.org/package/roots-0.1 (JamesCook)
13:00:50 <medfly> @hoogle [a] -> [a]
13:00:51 <lambdabot> Prelude cycle :: [a] -> [a]
13:00:51 <lambdabot> Prelude init :: [a] -> [a]
13:00:51 <lambdabot> Prelude reverse :: [a] -> [a]
13:02:29 <Kaidelong> @hoogle [b] -> [b]
13:02:30 <lambdabot> Prelude cycle :: [a] -> [a]
13:02:30 <lambdabot> Prelude init :: [a] -> [a]
13:02:30 <lambdabot> Prelude reverse :: [a] -> [a]
13:02:40 <Kaidelong> yay
13:03:09 <aRcatan> why rationalists think you should be rational?
13:03:14 <aristid> @hoogle [kaidelong] -> [kaidelong]
13:03:14 <lambdabot> Prelude cycle :: [a] -> [a]
13:03:14 <lambdabot> Prelude init :: [a] -> [a]
13:03:14 <lambdabot> Prelude reverse :: [a] -> [a]
13:03:20 <aristid> :D
13:03:33 <copumpkin> how many total functions forall n a. Vec (suc n) a -> Vec n a are there?
13:03:48 <Tarrasch> @hoogle a -> b
13:03:49 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:03:49 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:03:49 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
13:04:28 <aristid> @hoogle a -> b -> c
13:04:29 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
13:04:29 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
13:04:29 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
13:04:30 <copumpkin> :t ($) `asTypeIn` (\($) -> (runST $))
13:04:31 <lambdabot>     Cannot match a monotype with `forall s. ST s a'
13:04:31 <lambdabot>       Expected type: a1
13:04:31 <lambdabot>       Inferred type: forall s. ST s a
13:04:38 <codolio> (n+1)!?
13:04:40 <Tarrasch> is there any in-built hayoo searching?
13:04:44 <aristid> i don't know how the @hoogle search works
13:04:53 <tkahn6> you can cabal install hoogle
13:04:55 <codolio> Actually, it's more than that.
13:05:04 <copumpkin> yeah
13:05:15 <codolio> And I don't feel like figuring out how many others there are.
13:05:49 <copumpkin> I wonder if it'd be possible to build a universe of inductive families in agda and have counting functions on the types
13:06:01 <kdvh> @hoogle (b -> m c) -> (a -> m b) -> a -> m c
13:06:01 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:06:01 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:06:01 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:06:24 <aristid> it feels like it isn't respectable to have a nickname that doesn't begin with co- :D
13:06:42 <copumpkin> opposites are the rage these days
13:06:59 <aristid> they are the new black
13:07:02 <notabel> aristid: some of us have no dual
13:07:15 <aristid> notabel: yeah, the commoners
13:07:24 <copumpkin> notabel: wouldn't you be abel?
13:07:50 <notabel> copumpkin: indeed.  irony :-)
13:08:10 <copumpkin> andreas? :o
13:08:11 <notabel> (my name is cain; my nick is logically equivalent over a certain universe ;-)
13:08:30 <sanduz2> so why do you guys prefer haskell over lisp? asking because i want to learn a functional language
13:08:39 <aristid> notabel: a universe comprising only of you and your dual?
13:08:48 <ferret_0567> argh! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29869#a29869
13:09:11 <ddarius> copumpkin: (n+1)^n
13:09:30 <ferret_0567> try loading that in ghci
13:09:33 <djahandarie> sanduz2, a reason that I'm particularly fond of is that Haskell provides much more of a guarantee that your program will not break when you compile it
13:09:33 <aristid> ferret_0567: i think [a]  should be [Integer]
13:09:38 <ferret_0567> oh
13:09:38 <ddarius> For each of the n elements of the result vector you can choose any of the n+1 elements of the argument vector.
13:09:46 <aristid> ferret_0567: and just show us the error messages
13:09:55 <codolio> Ah, yeah.
13:09:58 <codolio> That's easy.
13:10:00 <aristid> or better yet, try to understand them
13:10:00 <tkahn6> noob question: how does one 'stop' a list comprehension on an infinite generator when a certain condition is met?
13:10:28 <shachaf> @ty takeWhile
13:10:28 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:10:29 <notabel> tkahn6: takeWhile (not predicate) [list comp]
13:10:31 * copumpkin is curious about automating counting like that :)
13:10:34 <tkahn6> gotcha
13:10:43 <djahandarie> sanduz2, that was a little gramatically vague... At compile time, Haskell gives you a bigger guarantee that your program will not break at runtime than Lisp. Or at least you have the tools to do so
13:10:58 <mercury^> Can one have a look at the preamble for the twocolumn layout that seems to be used by so many haskell related papers somewhere?
13:11:22 <patch-tag> where is the monad instance for ether defined? ghci claims to see one in Control.Monad.Error but I don't see it in the source.
13:11:26 <patch-tag> http://hackage.haskell.org/packages/archive/mtl/1.1.1.0/doc/html/Control-Monad-Error.html
13:11:58 <notabel> mercury^: are you talking about a particular journal's house style?  example?
13:12:12 <ferret_0567> ok, the program compiles now
13:12:33 <copumpkin> the problem I see with the presentation of inductive family universes like the one in morris' thesis is that they involve language-level functions :(
13:12:51 <ddarius> Multiple column layouts are evil
13:12:51 <mercury^> notabel: http://www.cse.unsw.edu.au/~chak/papers/singleton.pdf is an example
13:12:55 <copumpkin> patch-tag: it's right in there
13:13:02 <copumpkin> http://hackage.haskell.org/packages/archive/mtl/1.1.1.0/doc/html/src/Control-Monad-Error.html
13:13:12 <sanduz2> thanks djahandarie 
13:13:55 <Saizan> copumpkin: type-level you mean?
13:14:14 <djahandarie> sanduz2, also, I think Haskell allows you to be more 'denotational' than Lisp... that is to say, it allows you to think more about defining the problem itself rather than the exact steps a computer will take to solve it
13:14:39 <sanduz2> i see :)
13:14:47 <copumpkin> Saizan: I mean that if you make an inductive family in agda representing the universe of inductive families, you have agda-level functions as parameters to your constructors, which are opaque to analysis
13:14:52 <aristid> ddarius: we need to overcome the tyranny of the PDF :>
13:15:05 <copumpkin> Saizan: not sure if that's inherent, seems like it might be
13:17:04 <notabel> so mercury^ i can't tell exactly which documentclass that pdf uses, but it's easy to get layouts like that in LaTeX (which is how that paper is typeset)
13:18:31 <patch-tag> copumpkin: looks like it gets skipped in the html docs because there's a compiler directive, or pragma, or what have you.
13:18:43 * hackagebot ks-test 0.1 - Kolmogorov distribution and Kolmogorov-Smirnov test.  http://hackage.haskell.org/package/ks-test-0.1 (JamesCook)
13:19:16 <dmwit> There are Hackage analysis tools, yeah? Is there one that shows reverse dependencies?
13:19:47 <djahandarie> dmwit, the new Hackage server does
13:19:55 <djahandarie> I don't know if there is a specific tool for it
13:20:04 <djahandarie> But it has all the data loaded in it so you could just take a look
13:20:21 <djahandarie> dmwit, http://sparky.haskell.org:8080/
13:20:53 <dmwit> yeeee!
13:20:53 <Saizan> copumpkin: afaiu, "Outrageous but Meaningful Coincidences
13:21:13 <Saizan> copumpkin: afaiu, "Outrageous but Meaningful Coincidences" uses a two-level representation to solve that
13:21:25 <dmwit> Wow, that loads slowly.
13:22:22 <copumpkin> Saizan: oh, hadn't come across that one, will check it out :)
13:22:51 <copumpkin> not sure why I'm so interested in counting elements of sets
13:22:55 <djahandarie> dmwit, what, are you looking at the reverse dependencies of base or something? :P
13:23:18 <dmwit> djahandarie: nah, just loading the page with a list of packages
13:23:49 <djahandarie> Oh, I think the server has some bandwidth issues or something in that respect, I have no idea where it is hosted
13:24:17 <copumpkin> Saizan: wow, this paper is something I'd been hoping for for a while!
13:24:37 <copumpkin> Saizan: have any more along those lines? I'm greedy :P
13:25:59 <Saizan> copumpkin: i was browsing some about NBE but none felt particularly clear :)
13:26:37 <copumpkin> yeah, I've read a couple of NBE ones
13:32:00 <ferret_0567> what is a good list of computer prime factorization algorithms?
13:34:38 <c_wraith> I can factor any prime number in time proportional to how long it takes to say the number.
13:35:00 <tkahn6> lol
13:35:16 <c_wraith> ferret_0567, I'd start by looking up the general number field sieve, and seeing what references you can find on it.
13:35:53 <dmwit> Wow!
13:35:56 <tkahn6> Sieve of Eratosthenes
13:36:00 <dmwit> O(log n) factorization, that's pretty good, isn't it?
13:36:13 <dmwit> errr, no, O(n) factorization, I guess.
13:36:29 <dmwit> depends on what n is
13:36:41 <c_wraith> number of bits, traditionally
13:36:50 <McManiaC> is there any nice wiki/blog/pdf/... on how to use HJScript?
13:37:11 <dmwit> Anyway, O(number of bits) would be a huge breakthrough.
13:37:42 <c_wraith> factoring non-prime numbers in O(number of bits) would break RSA
13:37:44 <c_wraith> :)
13:37:47 <notabel> c_wraith: ferret_0567 i wouldn't start with the NFS, it's damned complex, and not always worth it.  determine what kind of numbers you need to handle, then find the most appropriate algorithm.  might be a sieve, might not be
13:37:49 <dmwit> right
13:37:57 <copumpkin> it would break lots of secure site authentication :P
13:38:59 <c_wraith> I didn't mean implement NFS, I just meant look at the list of related topics.  It's built on top of many simpler approaches. :)
13:39:11 <notabel> indeed :-)
13:41:19 <reorg> is there a sql parser in haskell? 
13:41:24 <dmwit> Is Hackage's documentation much less complete recently, or did I just not notice how incomplete it was before?
13:42:18 <dmwit> reorg: I'm not sure I've heard of a library for parsing, though there are lots of libraries for generating and for executing.
13:43:22 <reorg> dmwit: yes, i'm specifically looking for a parser, in lieu of that, is using happy the best way to write my own parser?
13:44:03 <dmwit> Alex/Happy, or Parsec, or Attoparsec, I think, are generally considered good.
13:46:32 <reorg> dmwit: which one is a good fit for this? or anyone would do?
13:46:57 <dmwit> I'm not sure.
13:47:14 <Lemmih> reorg: I'd go with parsec.
13:47:17 <new-lisper> reorg: I think there must be a parser, if there is a generator
13:47:22 <dmwit> If Parsec's Language module fits, that would almost certainly be the quickest (in terms of developer time, maybe not CPU time).
13:47:54 <copumpkin> it'd be nice to see bidirectional libraries for this kind of stuff
13:48:01 <copumpkin> too many parsers but not generators and vice versa
13:48:17 <copumpkin> the pickler combinators paper had some simple ideas
13:48:28 <reorg> new-lisper, all: i'm surprised to not find an existing parser
13:48:48 <copumpkin> reorg: most of the time, we don't need to parse it, I guess
13:49:08 <reorg> so parsec seems to be a good choice then? 
13:49:13 <dmwit> Whatcha working on?
13:49:17 <dmwit> Parsec would be a fine choice, yes.
13:49:52 <reorg> i'm trying to do some query re-write before sending it the backend
13:50:02 <reorg> so i need to parse it first, before re-writing
13:50:08 <dmwit> mmm, an evil mangler
13:50:26 <reorg> y
13:51:10 <reorg> what's a good intro on parsec? i read alex/happy, which is very similar to lex/yacc, is it not good because it's hard to debug generated parser code?
13:51:55 <dmwit> This is still the best intro to Parsec: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
13:53:33 <reorg> dmwit: thx
14:12:14 * hackagebot GtkTV 0.1.9 - Gtk-based GUIs for Tangible Values  http://hackage.haskell.org/package/GtkTV-0.1.9 (ConalElliott)
14:15:30 <Mitar> copumpkin here?
14:15:53 <Mitar> !help
14:16:21 <Mitar> seen copumpkin
14:16:29 <Mitar> preflex: seen copumpkin
14:16:30 <preflex>  copumpkin was last seen on #haskell-blah 0 seconds ago, saying: I'm always ambivalent about including it
14:16:38 <conal> dons: thx for the GtkTV bug report!  was a removed export going from OpenGL 2.2.3.0 to 2.4.0.1 .  GtkTV 0.1.9 works with both.
14:16:48 <copumpkin> Mitar: hey
14:16:52 <Mitar> hey
14:16:58 <Mitar> now i was playing more :-)
14:17:06 <Mitar> and have seen that the main problem is still there
14:18:52 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29871#a29871
14:19:18 <Mitar> sorry to bother you, but I really to put a final nail into this cofin ;-)
14:22:12 <Mitar> the point of sendFromFirst and getFromFirst being impossible is a nice goody, but the main  thing is to get rid of Container type because it makes problems visible at runtime and not compile time (like if process would have semantic meaning only for Any and not for Something, then it would be great if compiler would prevent reading from SomeChannel and passing the value there)
14:34:45 <bos> oh, Network.HTTP is so bad
14:34:54 <aristid> why?
14:36:53 <copumpkin> Mitar: I don't think that's a problem? can you give me an example of something you can do that you don't want to be able to do?
14:37:03 <copumpkin> in code
14:38:35 <dom96> can i have guards inside a body of a function?
14:38:48 <dom96> in a do expression?
14:39:24 <kmc> not directly
14:39:37 <kmc> you can attach guards to the alternatives of a "case"
14:39:44 <kmc> or you can define a helper inside "let" and put guards on it
14:40:11 <dom96> hrm, i have a functions which returns (IO Something)
14:40:21 <tommd> @hoogle guard
14:40:21 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
14:40:21 <lambdabot> Language.Haskell.TH data Guard
14:40:21 <lambdabot> Language.Haskell.TH.Syntax data Guard
14:40:32 <dom96> and i need to use (<-), which i have to put before the guards.
14:40:57 <dom96> how do guards with a "case" work?
14:41:15 <aristid> dom96: no you don't need to use <- with guards in a do block
14:41:28 <kmc> > case 3 of n | n > 2 -> "foo"; _ -> "bar"
14:41:29 <lambdabot>   "foo"
14:41:49 <aristid> > do x <- [1..10]; y <- [1..10]; guard $ x /= y; return (x, y)
14:41:50 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,3),(2,4),(...
14:41:51 <dmead> :t parse
14:41:52 <lambdabot> Not in scope: `parse'
14:42:01 <dmead> ?hoogle ParseResult
14:42:01 <lambdabot> Language.Haskell.ParseMonad data ParseResult a
14:42:01 <lambdabot> Language.Haskell.Parser data ParseResult a
14:42:05 <kmc> yaru1022, to answer your earlier question, i'm not sure what advice to give other than "practice"
14:42:08 <dmead> ?hoogle Module
14:42:08 <lambdabot> Language.Haskell.Syntax newtype Module
14:42:08 <lambdabot> Language.Haskell.Syntax Module :: String -> Module
14:42:08 <lambdabot> Language.Haskell.Syntax HsEModuleContents :: Module -> HsExportSpec
14:42:24 <kmc> if you hang around here long enough, you'll see lots of tricks
14:42:45 <dom96> hrm
14:42:47 <kmc> i also think your example of determining the type of «(<*>) (Person <$> name)» is a particularly tricky one
14:43:08 <aristid> :t \a b -> (a <$> b <*>)
14:43:09 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
14:43:25 <aristid> kmc: i think i'd use the section syntax for that
14:43:36 <benmachine> dnolen: what are you looking for?
14:44:31 <benmachine> eeer
14:44:33 <benmachine> dmead: 
14:44:47 <dmead> what?
14:44:48 <benmachine> dnolen: ignore me, sorry
14:44:55 <dmead> that stuff xD
14:45:00 <benmachine> dmead: try haskell-src-exts
14:45:05 <dmead> yep
14:45:23 <dmead> i'd rather have an easy way for ghc to give an ast
14:45:31 <dmead> but src-exts is just easier
14:46:46 <Phyx-> dmead: what kind of AST?
14:47:08 <dom96> Using a let works, but it looks very messy.
14:47:24 <dmead> Phyx-, the ast of some haskell code
14:47:34 <dmead> parsed. desugared, etc
14:47:46 <Phyx-> dmead: you can use the ghc api for that
14:47:50 <Phyx-> haskell-src-exts only does parsing
14:48:06 <dmead> ah
14:48:19 <dmead> yea, i don't really want to have to implement my own type inference
14:48:39 <dmead> i'm trying to write a translator to do haskell -> clojure 
14:48:49 <Phyx-> dmead: http://www.haskell.org/haskellwiki/GHC/As_a_library
14:48:52 <Mitar> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29854#a29874
14:48:56 <dmead> yea i've seen that
14:49:00 <new-lisper> dmead: why don't you just write clojure code
14:49:18 <dmead> bececause of all the nice haskell parsing stuff in haskell
14:49:28 <dmead> i'm probably going to have to write lots of clojure
14:49:34 <dmead> to do stuff like pattern matching, etc
14:49:39 <dmead> and simulate lazy evaluation
14:50:02 <Phyx-> dmead: the ghc api should do fine then, you can get any information out of it
14:50:17 <new-lisper> dmead: I think that will be a little complicated...
14:50:34 <dmead> yea, it should
14:50:40 <dmead> i'm doing research for a thesis
14:50:43 <Phyx-> only down side is the lack of Data and Typeable instances for some things, but think ghc-syb has them
14:50:46 <dmead> so, it should be complicated
14:50:53 <new-lisper> oh, in this case :)
14:51:01 <Mitar> copumpkin: so if the TwoWay would get from somewhere far away it would be useful that compiler makes an error if you expect Info but was given TwoWay which can give you only NoInfo
14:51:17 <Mitar> currently you find this at runtime
14:51:20 <kmc> dmead, what about Template Haskell?
14:51:34 <dmead> kmc i probably will use that for some things
14:51:40 <dmead> but it's probably not really nessicary 
14:52:13 <dmead> and it's really supposed to output haskell
14:52:18 <dmead> i'm trying to output s-exps
14:52:19 <copumpkin> Mitar: the way you wrote getSomething, the case you claim is impossible isn't impossible
14:52:50 <copumpkin> Mitar: maybe you wanted getSomething :: Container (Info i) -> i ?
14:52:56 <copumpkin> in which case you wouldn't need the second case
14:53:28 <copumpkin> Mitar: your empty case could be getSomething (Any _) = NoInfo
14:53:34 <copumpkin> in fact, that's what it has to be
14:57:33 <tmo_> wxHaskell question: suppose I were to implement a custom widget that had some features from text-controll, but had a different behaviour. How exactly does inheritance work in haskell, especially for highly object-oriented tasks like GUIs?
14:57:39 <tmo_> *control
14:58:48 <Mitar> copumpkin: it doesn't matter what is my empty case
14:59:01 <copumpkin> Mitar: my point is that the type you wrote does allow that case
14:59:02 <Mitar> the point is that SomeChannel can return only Info
14:59:12 <Mitar> sure it does allow
14:59:20 <copumpkin> so use the type I gave you :)
14:59:20 <Mitar> but getFromFirst will never return it
14:59:48 <Mitar> the point that i want compiler to set return value from getFromFirst based on type of TwoWay
15:00:57 <Mitar> and i am not sure if your suggestion getSomething really works, at least i cannot make it to work
15:01:32 * hackagebot tls 0.1.1 - TLS protocol for Server and Client sides  http://hackage.haskell.org/package/tls-0.1.1 (VincentHanquez)
15:03:41 <Mitar> or maybe i understand something wrong?
15:04:31 <copumpkin> well the issue is that you can't just pull out an existential type
15:04:38 <copumpkin> because you don't know what it is
15:04:56 <copumpkin> so you could pass in a function that works on the inside like a continuation
15:05:10 <Mitar> but we do not have existential type?
15:05:54 <copumpkin>   Any       :: Show i => i -> Container NoInfo
15:05:56 <copumpkin> that's existential
15:06:11 <Mitar> true, but I am not using NoInfo there?
15:06:35 <Mitar> and I am not trying to take NoInfo apart
15:06:39 <Mitar> just Container ;-)
15:07:43 <copumpkin> well, you'd probably need some sort of
15:08:02 <copumpkin> type family MagicCont :: * -> *
15:08:27 <Mitar> hmm
15:08:35 <copumpkin> type instance MagicCont NoInfo = (forall i. Show i => i -> r) -> r -- or a wrapped type if type families don't allow this
15:08:48 <copumpkin> type instance MagicCont (Info i) = (i -> r) -> r
15:08:59 * copumpkin shrugs
15:09:02 <Mitar> hmm
15:09:10 <copumpkin> and then
15:09:24 <copumpkin> zomg :: Container a -> MagicCont a
15:09:43 <Mitar> but it is too late
15:09:53 <Mitar> once we have Container we are too far, we lost information of getFromFirst
15:09:59 <Mitar> and TwoWay
15:10:05 <copumpkin> ?
15:10:15 <Mitar> the point is that TwoWay signifies a return type of getFromFirst
15:11:36 * hackagebot transformers 0.2.2.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.2.2.0 (RossPaterson)
15:11:38 * hackagebot monads-fd 0.1.0.2 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/monads-fd-0.1.0.2 (RossPaterson)
15:16:31 <McManiaC> how do you reexport a module?
15:16:52 <McManiaC> module Foo (module(?) Bla) where import Bla ...
15:17:39 <McManiaC> oh nevermind
15:17:55 <McManiaC> shouldnt start with a ','
15:17:56 <McManiaC> ^^
15:18:54 <BrianHV> anyone know of a getpass binding or equivalent for haskell?
15:21:45 <BrianHV> actually... nm.  looks like the lack of a mature mechanize replacement is the bigger issue for me here...
15:22:47 <tolkad> I found a GHC bug, it's a situation in which you can make something compile by adding a type annotation
15:22:47 <lambdabot> tolkad: You have 1 new message. '/msg lambdabot @messages' to read it.
15:22:48 <kmc> BrianHV, getpass is a single C function right?
15:23:01 <kmc> tolkad, can i see?
15:23:05 * benmachine does man getpass and is immediately greeted with This function is obsolete.  Do not use it.
15:23:27 <benmachine> wait, aren't there loads of situations you can make things compile by adding type annotations?
15:23:48 <tolkad> > let a = 1 in (show (a :: Int), show (a :: Integer))
15:23:49 <lambdabot>   ("1","1")
15:23:53 <tolkad> uh wait
15:23:57 <benmachine> I vaguely recall some/all rank-N types are hard to infer
15:24:10 <benmachine> tolkad: monomorphism restriction?
15:24:18 <tolkad> I had something like that
15:24:33 <tolkad> and then I added «a :: Integral t => t»
15:24:35 <tolkad> and it worked
15:24:38 <kmc> tolkad, at top level of a file?
15:24:42 <tolkad> yeah
15:24:43 <kmc> tolkad, that'd be the monomorphism restriction
15:24:48 <kmc> arguably a bug in the *language spec*
15:24:53 <kmc> but GHC is faithful to what is specified
15:25:01 <kmc> you can turn on -XNoMonomorphismRestriction
15:25:04 <Phyx-> heh, the monomorphism restriction sure pops up alot
15:25:16 <kmc> tolkad, please don't assume that everything you don't understand is someone else's fault
15:25:26 <McManiaC> how do I get cabal to use the latest haddock? :)
15:25:58 <tolkad> kmc: uh just fix the language spec then
15:26:04 <tolkad> let's see... where is it
15:26:18 <kmc> tolkad, dropping the MMR is under consideration for a future version of Haskell
15:26:25 <tolkad> ok here it is: http://www.haskell.org/onlinereport/
15:26:26 <BrianHV> kmc: well.. when you put it that way, that does make it sound pretty simple to wrap. ;)
15:26:31 <kmc> it is in Haskell 98 deliberately though
15:26:42 <aristid> what IS the Monomorphism Restriction, actually? RWH refused to explain it
15:26:44 <kmc> it's generally agreed to have been a bad idea, but it is what they originally intended
15:26:57 <aristid> and why did they put it in?
15:27:11 <djahandarie> Because it sounded like a good idea at the time of making the spec
15:27:19 <mauke> aristid: to make constant looking things constants
15:27:43 <djahandarie> There is a good wiki article on it
15:27:45 <mauke> e.g. pie = 3.14
15:27:47 <tolkad> well if everyone agrees it's a bad idea
15:27:51 <tolkad> go here http://www.haskell.org/onlinereport/
15:27:53 <tolkad> edit the page
15:27:55 <tolkad> and fix it
15:27:59 <djahandarie> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:28:05 <kmc> tolkad, do you understand how language specifications work?
15:28:09 <mauke> that's actually a function if you consider typeclass internals
15:28:13 <aristid> mauke: hmm ok
15:28:15 <aristid> :t pi
15:28:16 <lambdabot> forall a. (Floating a) => a
15:28:17 <tolkad> kmc: they say how the language works
15:28:22 <kmc> tolkad, right, and they have versions
15:28:22 <Olathe> pie = 8.53973422
15:28:34 <tolkad> kmc: so change it and increment the version number
15:28:35 <mauke> the MR pins it down to a single type
15:28:36 <aristid> mauke: many constants seem to evade it anyways ;)
15:28:39 <kmc> tolkad, there are plans to do so
15:28:54 <kmc> tolkad, it's not something we can just go do on a whim; there's a committee that decides what goes in the next version
15:29:04 <kmc> there are many implications to each change
15:29:15 <mauke> aristid: pi is a member of Floating
15:29:25 <mauke> aristid: it's a class method (class constant?)
15:29:25 <kmc> if you want a language where semantics change unexpectedly with a minor version bump in the interpreter, there's plenty of those
15:29:54 <aristid> mauke: yeah, in that case. but i guess there are some derived constants that are not in a typeclass
15:29:54 <FunctorSalad> > log (-1 :+ 0)
15:29:55 <lambdabot>   Precedence parsing error
15:29:55 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
15:30:03 <FunctorSalad> > log ((negate 1) :+ 0)
15:30:04 <lambdabot>   0.0 :+ 3.141592653589793
15:30:13 <FunctorSalad> hrhr derived member
15:30:17 <djahandarie> You didn't need to write negate there... :P
15:30:18 <Olathe> > log ((-1) :+ 0)
15:30:19 <lambdabot>   0.0 :+ 3.141592653589793
15:30:27 <mauke> tolkad: why don't you just paste in the C standard and thus turn Haskell into C?
15:30:28 <tolkad> kmc: in PHP the developers change stuff whenever they like and if the status of PHP is any indicator of the effectiveness of this method then it seems to work very well
15:30:36 <mauke> it'll magically turn ghc into a C compiler
15:30:38 <FunctorSalad> djahandarie: uh depends on the choise of complex logarithm
15:30:42 <kmc> by "status" you mean popularity tolkad?
15:30:48 <FunctorSalad> if you mean that 1 :+ 0 would do
15:30:50 <tolkad> @quote tolkad
15:30:51 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
15:31:01 <kmc> popularity is not particularly a goal for Haskell
15:31:06 <djahandarie> FunctorSalad, I only meant you could have wrote (-1) instead of (negate 1)
15:31:12 <kmc> we want it to be good
15:31:13 <FunctorSalad> ahh :)
15:31:17 <tolkad> @quote tolkad
15:31:17 <lambdabot> tolkad says: Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
15:31:18 <FunctorSalad> *choice
15:31:25 <kmc> yeah we get it, you're a troll
15:31:34 <tolkad> I'm not a troll
15:31:53 <tolkad> but anyway, I guess I'll just wait for the comittee to fix it
15:31:59 <Adamant> you may not be a troll, but in that case you have very odd opinions
15:32:06 <kmc> or you can disable it today with a GHC extension
15:32:09 --- mode: ChanServ set +o mauke
15:32:10 --- mode: mauke set +q *!*@unaffiliated/tolkad
15:32:14 <kmc> or write the type signature, which is probably a good idea anyway
15:32:17 <benmachine> didn't 2010 include NoMonomorphismRestriction
15:32:35 <kmc> benmachine, no
15:32:35 <FunctorSalad> by default?
15:32:40 <kmc> http://www.haskell.org/pipermail/haskell/2009-November/021750.html
15:33:11 <kmc> BrianHV, getpass is deprecated; in particular it's not reentrant
15:33:15 <kmc> it returns a pointer to a static buffer
15:33:31 <benmachine> oh I was thinking of n+k patterns
15:33:54 <FunctorSalad> isn't is the monomorphism obsoleted by automatic SPECIALIZE anyway? random thought
15:34:10 --- mode: mauke set -o mauke
15:34:20 <FunctorSalad> -ddump-simpl-stats often seems to mention these automatic SPECs
15:34:46 <FunctorSalad> *the monomorphism _restriction_ ;)
15:37:54 <BrianHV> kmc: interesting.  and I can't find anything about a replacement.
15:38:56 <copumpkin> automatic specializations? haven't heard of that
15:39:48 <kmc> BrianHV, you can take extra pains to make a thread-safe wrapper, or just specify that your library is not thread-safe
15:39:57 <kmc> but unlike C, the default with Haskell is usually to assume thread-safety
15:40:25 <BrianHV> right
15:40:28 <FunctorSalad> copumpkin: my term. I mean something equivalent to the SPECIALIZE (*yell*) pragma being applied automatically
15:40:42 <FunctorSalad> copumpkin: (as can sometimes be observed if you use -ddump-simpl-stats)
15:41:20 <copumpkin> hmm
15:45:19 <kmc> something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29877#a29877 BrianHV
15:45:23 <kmc> suggestions welcome on making this nicer
15:45:39 <BrianHV> thanks!
15:45:40 * kmc wishes GHC had JHC's top-level IO <-
15:45:58 <FunctorSalad> woha?
15:46:12 <kmc> woha!
15:46:34 <FunctorSalad> as a static initializer-like thing?
15:46:37 <kmc> yeah
15:46:45 <FunctorSalad> how does it order the modules?
15:47:04 <Phyx-> huhm when did I come on irc...
15:47:22 <kmc> FunctorSalad, it's not IO monad but a variant which is order-independent
15:47:30 * applicative wonders what 'top level IO ' is
15:47:31 <kmc> e.g. allocating IORefs is allowed
15:47:44 <FunctorSalad> ah
15:47:45 <kmc> applicative, you can put "x <- newIORef 3" at the top level of a module
15:48:22 <tommd> So, you don't need an ugly unsafePerformIO hack? hummm
15:48:23 <applicative> kmc, and then 'x' is one of the expressions I can e.g. export?
15:48:32 <applicative> or use in ghci
15:48:34 <kmc> i'm not sure if you can export them
15:49:04 <applicative> kmc, but anyway, it's as if I'd define a = 2 + 3 and then use all over the module?
15:49:09 <kmc> right
15:49:19 <kmc> it lets you make global MVars and such
15:49:23 <applicative> wow
15:49:25 <kmc> without resorting to unsafePerformIO
15:49:41 <tommd> Or use:
15:49:41 <tommd> extremelySafePerformIO :: IO a -> IO a
15:49:41 <tommd> evenSaferDon'tPerformIO :: IO a -> ()
15:49:52 <kmc> haha
15:50:05 <kmc> and there's some way to embed actual IO actions in it too
15:50:13 <kmc> but i'm having a hard time finding the docs on this
15:50:15 <kmc> i know i saw it once
15:51:27 <applicative> some jhc user should write a few more tutorial docs.  I managed to install it again a while back, but the interpreter completely defeated me.
15:51:40 <FunctorSalad> kmc: the proposal was once called 'affine central io'... don't know if that's the term in jhc
15:51:59 <FunctorSalad> ('central' for 'commutes with everything'.... 'affine', no idea in this context)
15:52:14 <mauke> good, mathy words
15:52:25 <FunctorSalad> appendoid!
15:52:27 <mauke> GORN
15:52:32 <FunctorSalad> gorn?
15:52:42 <kmc> the relevant module in JHC is JHC.ACIO
15:52:44 <kmc> Jhc.ACIO rather
15:52:52 <applicative> workflowoid
15:53:02 <applicative> i'm baffled that it's theoretically possible, this affine central io or whatever
15:53:05 <FunctorSalad> ok, that's 'affine central io' with pretty high probability
15:53:11 <kmc> yes
15:53:14 <applicative> have I been hoodwinked by monad ideology>
15:53:15 <kmc> the module says it is :)
15:53:23 <mauke> FunctorSalad: http://www.youtube.com/watch?v=-gwXJsWHupg
15:53:31 <kmc> and you have runOnce :: IO a -> ACIO (IO a)
15:54:21 <kmc> i think it's easy to implement applicative
15:54:27 <kmc> it's just a matter of convincing yourself it's "safe"
15:54:58 <kmc> here we are http://repetae.net/computer/jhc/manual2.html#top-level-actions
15:56:52 <applicative> Funny, i remember in my mind, while ago thinking things like IORefs were unique strange deep and mysterious, since you couldn't name them
15:57:13 <Olathe> @type uncurry
15:57:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:57:30 <kmc> you can name them
15:57:42 <kmc> you can make a function with a named argument that takes an IORef
15:57:42 <applicative> ref <- newIORefAC 0 is just an odd way of naming
15:58:18 <applicative> oh? or maybe I'm not expressing what I was thinking. 
15:58:40 <kmc> sure
15:58:48 <kmc> foo x = modifyIORef x succ
15:58:50 <applicative> usually we have (newIORef >>= \ref -> .... ref ....ref....ref)
15:58:52 <kmc> x is a named IORef
15:59:58 <Olathe> Is there a short way of saying (>> return ()) ?
16:00:05 <applicative> well, the function is foo = \x -> modifyIORef x succ)
16:00:11 <benmachine> Olathe: (()<$) is a little shorter
16:00:13 <applicative> but maybe thats not to my would-be point
16:00:17 <Olathe> Ahh, thanks.
16:00:32 <benmachine> Olathe: if it's for IO there's some function somewhere that does it
16:00:36 <benmachine> @hoogle IO a -> IO ()
16:00:36 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
16:00:37 <lambdabot> Network withSocketsDo :: IO a -> IO a
16:00:37 <lambdabot> Control.Exception block :: IO a -> IO a
16:00:52 <applicative> Olathe, I dimly remember hlint having somethings sensible to substitute when it found that
16:00:58 <benmachine> there's a libraries proposal to get that generalised and moved somewhere sensible
16:00:58 <kmc> :t fmap (const ())
16:00:59 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
16:01:05 <benmachine> :t (() <$)
16:01:06 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
16:02:18 <Raghs> I am using cabal on windows 7. and when I do ghc-pkg I see two package.conf.d lists..
16:02:27 <Raghs> how can I consolidate this into one?
16:02:58 <applicative> Olathe, I withdraw claim about hlint.
16:03:43 <kmc> why does System.Mem.Weak have this idea of "keys" and "values"? most weak-reference libraries in most languages don't
16:03:45 <Olathe> Ahh, OK.
16:04:36 * applicative wishes he knew how to load these example bits from the mysterious affine io module into the jhc interpreter
16:05:09 <kmc> also that module lets you attach finalizers to any value :O
16:05:22 <benmachine> ooh that sounds devious
16:06:05 <kmc> man that's all kinds of fun
16:06:08 <applicative> uh, what's a finalizer? -- while I play the idiot as usual
16:06:18 <Phyx-> Raghs: you don't. One is system packager other user
16:06:21 <kmc> an IO action that runs once that value is garbage collected
16:06:31 <kmc> more or less
16:06:42 <Phyx-> System packages*
16:07:04 <applicative> oh, why would I wan't that.  I can't say I envisage the moment of garbage collection too often :)
16:07:09 <mietek> Is it possible for a quasiquotation to look at its context?
16:07:10 <Phyx-> Raghs: it reads from both anyway, so
16:07:31 <applicative> \me apologizes for bad typing.  he was improperly brought up
16:07:42 * applicative too
16:07:48 <Raghs> Phyx -> I am getting all sorts of recursive dependecies 
16:08:04 <Phyx-> Raghs: like?
16:08:22 <Phyx-> Raghs: do you have some packages both as user and system?
16:08:28 <Phyx-> system/global
16:08:30 <Raghs> yes
16:08:32 <Phyx-> ah
16:08:36 <Phyx-> unregister one
16:09:01 <dpratt71> hey Phyx-, I was just curious if you were still working on the VS/Haskell stuff?
16:09:04 <Phyx-> does ghc-pkg unregister <package>
16:09:06 <applicative> Wait, why does Raghs want one list?
16:09:21 <Raghs> that didn't help
16:09:30 <Phyx-> dpratt71: yes I am, But my thesis takes precedence
16:09:42 <applicative> I always have the global one (haskell package) and my local one ... is this a windows thing?
16:09:51 <mietek> For example, I'd like to use quasiquotation to rewrite "f qq" to "f x | qg x", where "x" is a new variable and "qg" is a guard written from the quasiquotation.
16:09:54 <mietek> But I'd also like "f qq y | g y" to be rewritten as "f x y | qg x, g y", in effect adding the quasiquotation guard to the list of existing guards.
16:10:04 <dpratt71> Phyx-: thesis schmesis! priorities, man! ;-)
16:10:32 <Phyx-> applicative: no it's not. atleast afaik
16:10:42 <Phyx-> dpratt71: hey I want to eventually graduate :)
16:10:53 <Phyx-> dpratt71: I work on it in the weekends, when I'm not to wasted
16:10:59 <kmc> applicative, a common user for finalizers is ForeignPtr.  you wrap some C library that wants explicit allocate / free calls; you use the GHC garbage collector to decide when to call free
16:11:04 <dpratt71> Phyx-: graduating is overrated; I never did
16:11:16 <Phyx-> Raghs: have you removed all the duplicated packages?
16:11:27 <applicative> do other people oppose having two pkgconf things for ghc?  
16:11:30 <Raghs> Phyx -> I did cabal install QuickCheck and go into ghci :m +Test.QuickCheck and I get message "Couldnotfind module"
16:11:56 <Phyx-> dpratt71: lol, My parents don't agree
16:12:01 <dpratt71> :)
16:12:13 <applicative> kmc, I see, of course.  Needless to say, I don't make explicit use of ForeignPtr.... But I suppose it is happening via libraries, often?
16:12:19 <Raghs> Phyx -> when I do the ghc-pkg list, I see that QuickCheck is listed
16:12:20 <kmc> yeah
16:12:32 <Phyx-> Raghs: which version did it install?
16:12:34 <kmc> applicative, for example ByteString uses ForeignPtr
16:12:43 <Raghs> Phyx -> 2.3
16:13:22 <Raghs> Actually I see one in the global (2.1.1.1) and one in user (2.3)
16:13:37 <Phyx-> Raghs: what do you get when you type ghc-pkg find-module "Test.QuickCheck"
16:13:56 <applicative> kmc, yes, that's an example I thought of.  I take it that with finalizer capacity, a lib writer might be able to manage the unpleasantness for we 'users'
16:14:30 <kmc> right
16:14:37 <applicative> Raghs, what trouble is that giving you though?  There will be a defaulting to 2.3, other things being equal
16:14:47 <Phyx-> dpratt71: I'm not missing alot, I just need to strap myself down a weekend or two and I'd finish a Beta, then I would need to do some performance tweaking and that should be it
16:15:03 <applicative> kmc, have you managed to use the jhc much?
16:15:08 <kmc> no i haven't used it
16:15:08 <Raghs> Phyx -> I see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29878#a29878
16:15:35 <dpratt71> Phyx-: really? that's good news as far as I'm concerned
16:16:06 <Olathe> I'm trying to make a monad where I can get a game state, put moves, and signal the end of turn (without return, so that one do block can handle the entire several-move game).
16:16:25 <Phyx-> Raghs: yeah, so it's there. try ghc-pkg hide QuickCheck-2.1.1.1
16:16:30 <applicative> kmc, i periodically try, i'm not sure why.  this time i had a good install, but the docs were too obscure to actually get anything done. 
16:16:34 <Phyx-> and then try loading it again
16:16:56 <Phyx-> dpratt71: and stay off the xbox.... :)
16:17:10 <Olathe> If I want to be able to pass an instance of this game monad into a test suite or an IO monad, how can I get the putted moves from the monad?
16:17:16 <Phyx-> gaming... a coder's worst nightmare in terms of productivity
16:17:38 <applicative> @ faq can you write games in Haskell?
16:17:42 <applicative> No, it's wrong!
16:17:44 <Raghs> Phyx -> still the same error - couldnot find module
16:17:51 <Phyx-> odd
16:18:18 <Raghs> yep, and that's the reason why I wnat  to combine the global and user
16:18:31 <applicative> @ faq can you write 4-D multi-shooter porn games in Haskell?
16:18:39 <applicative> No, they don't compile!
16:19:01 <Phyx-> Raghs: try starting ghci like, ghci -package QuickCheck
16:19:07 <Phyx-> see if it loads the package
16:19:23 <applicative> Raghs, it's the new one that can't be found?
16:20:06 * applicative needs to get a windows machine again, he's tired of not being able to figure out peoples' cabal problems, for one thing
16:20:23 <dpratt71> Phyx-: what's your XBOX vice, if you don't mind tellin?
16:20:38 <Raghs> Phyx -> This is the message  I get http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29879#a29879
16:20:39 <Phyx-> dpratt71: MW2, atleast until Medal of Honor comes out
16:20:46 <dpratt71> :)
16:21:08 <Phyx-> oh, they're broken
16:21:19 <applicative> Yeah, broken.  
16:21:22 <FunctorSalad> applicative: virtualbox
16:21:26 <dpratt71> the family has co-opted my XBOX for NetFlix; I need to get another one :)
16:21:31 <Phyx-> Raghs: unregister both and reinstall
16:21:34 <applicative> Raghs, did you just install GHC?
16:21:42 <Raghs> Phyx -> ok
16:21:58 <Raghs> applicative -> No its been a while
16:22:25 <Raghs> Phyx -> can't really uninstall QuickCheck as HaskellPlatform uses it
16:22:30 <Phyx-> dpratt71: I was on vacation when I was working alot of VSH, now that I'm back, after two months, I tend to want to shoot people alot :/ make up for lost time
16:22:33 <FunctorSalad> (then install cygwin on it *rolls eyes*)
16:22:39 <applicative> oh, i see. I was going to recommend chucking everything and starting over.  I'm always defeated by the kind of error you just posted ... but then I enjoy installing ghc
16:22:49 <dpratt71> Phyx-: :)
16:23:09 <applicative> FunctorSalad, you have a Windows/ghc with virtualbox?
16:23:59 <FunctorSalad> applicative: for a different purpose (I did also install ghc though, but haven't used it :))
16:24:09 <applicative> i was thinking of getting a netbookish thing and dual booting arch + windows; i fried my old dell
16:24:16 <Phyx-> Raghs: what does "ghc-pkg field ghc id" give?
16:24:39 <applicative> Raghs, this Phyx- is good...
16:24:54 <Phyx-> hm?
16:24:56 <Raghs> i am reinstalling ghc
16:25:11 <Raghs> Phyx is the man
16:25:18 <Phyx-> Raghs: that's one way, lol. I usually just edit the package database and insert the right hash
16:25:27 <applicative> phyx, i was admiring the last subtle ghc-pkg wisdom
16:25:32 <Phyx-> aslong as the versions match it should be safe
16:26:03 <Olathe> I think I figured out my earlier question.
16:26:08 <Phyx-> applicative: ah, yeah I've spend way to much time with ghc-pkg and fixing my packages
16:26:42 <applicative> If you don't have a pile of packages installed and a complicated bunch of things, I recommend reinstalling myself, but, again , I have no boredom threshold when it comes to installing ghc
16:26:58 <applicative> it makes me so happy
16:27:14 <Phyx-> yeah, reinstalling for VSH == recompiling GHC
16:27:17 <Phyx-> takes ages :/
16:27:22 <Phyx-> so I just edit the package files
16:27:23 <Phyx-> lol
16:27:36 <applicative> make sure to ask for --verbose !!!
16:27:48 <applicative> Stage 1 .... launching....
16:27:48 <Raghs> Phyx-> now that i am reinstalling, any suggestions on just having one global package.conf.d
16:28:29 <Phyx-> Raghs: the problem is, you won't get around having a global package db, sinve that's where ghc puts things
16:28:49 <FunctorSalad> hmm even if you do have lots of packages installed, you can just ghc-pkg list --sim > /tmp/foo and then xargs -n1 cabal install </tmp/foo
16:28:57 <Phyx-> Raghs: and cabal now defaults on windows to user install, since if not you would need an elevated prompt to install and use packages.
16:29:04 <applicative> Raghs, you're using the Haskell Platform installers, right?
16:29:23 <Raghs> yes applicative
16:29:26 <Phyx-> you can potentially move the global packages to user
16:29:30 <Phyx-> but not sure
16:29:30 * new-lisper thinks this channel is way much active
16:29:35 <FunctorSalad> (or probably an failure-ignoring for loop, since the cabal install will fail on ghc-prim etc)
16:30:16 <applicative> hmm.  isn't the default behavior of `cabal install hfoo` to put things in a local place?  This works for me, but I'm stuck on a mac at the moment
16:30:16 <Raghs> how do i change the cabal default?
16:30:27 <applicative> there's a conf file
16:30:28 * Zao thinks that Phyx- should hack on VHs :D
16:30:40 <Olathe> I have a getFunc that gives an element of a list to code in a monad, which processes it, and then uses a putFunc. I want to do something like map this way, but I can't think of any way to have the output list not be reversed other than to use ++ [putted]. Is there a way to do that?
16:30:41 <benmachine> cabal --help tells you where the config is
16:30:49 * new-lisper agrees with Zao
16:31:04 <FunctorSalad> (or just make a wrapper script...)
16:31:07 <applicative> here it's in the directory .cabal with .cabal/bin for example
16:31:25 <FunctorSalad> (while you're at that you can also make it invoke cabal haddock with --hyper...)
16:31:34 <Phyx-> Zao: most likely tomorow, gonna either do haddock or cabal support this week. But right now i'm trying to fix my typesystem
16:31:53 <Phyx-> FunctorSalad: what does Hyper do?
16:32:03 <FunctorSalad> Phyx-: abbrev for hyperlink-sources
16:32:07 <Phyx-> aha
16:32:08 <applicative> sounds like it links the docs with your ghc docs
16:32:19 <Phyx-> FunctorSalad: I thought it gave cabal sugar and Cola
16:32:27 <new-lisper> Oh, I almost asked if you had a Space Cadet keyboard
16:32:29 <FunctorSalad> it gives you the 'source' links in the haddock, like on the hackage
16:32:35 <FunctorSalad> Phyx-: =)
16:32:37 <applicative> i was thinking of a geometrical metaphor
16:33:30 <Phyx-> new-lisper: when tryhaskell went on reddit, THEN this channel was too active
16:33:34 <Phyx-> this is normal
16:33:35 <FunctorSalad> I should probably have added that functionality to cabal-install instead of fooling with that script though
16:33:44 <applicative> FunctorSalad, I guess I want a micro windows to help my friends install pandoc and stuff.  Its such a trial even on the satanic OS X
16:33:57 <Phyx-> is it just me, or do packages get corrupted easily
16:34:07 <FunctorSalad> corrupted?
16:34:14 <new-lisper> Phyx-: maybe I have got used to quiet channels
16:34:16 <Phyx-> well, dependencies screwed up
16:34:30 <applicative> I only get that when I install GHC head.  a
16:34:48 <FunctorSalad> Phyx-: yes
16:34:52 <Phyx-> i've had it happen on a stable too
16:35:05 <Phyx-> new-lisper: -blah is usually quieter :)
16:35:22 <applicative> and that's I frequently overwrite the old 'global' ones with the new 'local' ones, since theyre all in ~/ghchead/something/something
16:35:22 <Raghs> Phyx -> just installed haskell - where is the cabal exe? and config file?
16:35:59 <applicative> new-lisper, but at the moment there's foul language on -blah.  
16:36:07 <Phyx-> Raghs: I have no idea where the HaskellPlatform puts the cabal file, but the config file is at %AppData%\cabal\
16:36:16 <applicative> maybe there should be #haskell-#$@%^$#!!
16:36:35 <applicative> i can think of a number of uses for it...
16:36:35 <Phyx-> i don't see any
16:37:05 <int80_h> @seen chrisdone
16:37:06 <preflex>  chrisdone was last seen on #haskell-blah 3 days, 3 hours, 58 minutes and 50 seconds ago, saying: http://fungi.yuggoth.org/vsp4s/
16:37:06 <lambdabot> Unknown command, try @list
16:37:16 <int80_h> oh that is swell
16:37:31 <applicative> Raghs, going by unix analogy, your cabal.exe will be where your ghc and ghci are
16:37:53 <applicative> your cabal config will be where cabal install does local installs
16:37:59 <Raghs> applicative -> don't see it there
16:38:15 <Phyx-> applicative: that should be %AppData%\cabal\ there
16:38:18 <Phyx-> then*
16:38:38 <applicative> i see, but he doesn't see it there?
16:39:49 <Phyx-> Raghs: does that folder exists?
16:39:53 <Phyx-> exist*
16:40:11 <Raghs> no. i just did cabal update and it is creating one
16:40:16 <Phyx-> ah
16:40:58 * Phyx- wonders what the "world" file is
16:41:10 <Phyx-> I used to know, but forgotten
16:41:27 <Raghs> Phyx -> see two install-dirs user and global
16:41:33 <Raghs> can I delete the user section
16:42:26 <applicative> Man, I'm still not convinced by this plan.  Is your installation in other ways unusual?
16:42:54 <Phyx-> Raghs: just comment in "user-install"
16:43:00 <Phyx-> or set it to False
16:43:08 <Phyx-> it should never use the user pkg then
16:43:50 <Raghs> I have installed ghc to c:\haskell
16:44:06 <Phyx-> Raghs: you have to understand though, if you're on windows vista or 7 with UAC enabled, you can no longer install packages or run ghc/ghci on those packages without an elevated prompt
16:44:15 <Raghs> but why do I see install-dirs global to have a prefix of "C:\\Program Files (x86)\\Haskell"
16:44:33 <Phyx-> Raghs: that's the default of cabal-install
16:44:54 <applicative> Raghs, here's my unaltered mac .cabal/config http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29881#a29881
16:44:58 <Raghs> but there is no folder "C:\\Program Files (x86)\\Haskell"
16:45:18 <applicative> ... hmmm....
16:45:44 <Phyx-> Raghs: it'll create it when you install something. the problem is C:\\Program Files* is a folder that only allows admins to write to it
16:46:04 <Phyx-> Raghs: and since the default of cabal is to use user, that folder was never created
16:46:08 <Phyx-> never needed
16:46:11 <Raghs> i am always an admim
16:46:17 <Raghs> and only one that uses this pc
16:46:24 <Phyx-> Raghs: so you have UAC disabled?
16:46:28 <Raghs> yes
16:46:31 <Phyx-> ah ok
16:47:00 <Raghs> when I do ghc-pkg i just have C:/haskell\lib\package.conf.d
16:47:06 <Phyx-> well yes, if you change the flag of user-install to false (and uncomment it) it should write there
16:47:10 <Raghs> how do I edit the config to just look here
16:47:36 <applicative> Raghs, maybe that makes sense, then, but like i said, I've had trouble with overwriting Haskell Platform installed things when there wasnt a distinction, as with (ineptly organized) builds of ghc-HEAD
16:47:51 <applicative> then I get just the error you posted. 
16:49:36 <Raghs> ok. I changed the user-install to False and prefix to c:\haskell\lib..
16:49:37 <applicative> Raghs, if Phyx and you still have trouble there is of course the expedient of harrassing the absolute master, dcoutts, expert on all platforms, frequently here. 
16:50:23 <Phyx-> well, I've never used HP, so I don't really know much about it's defaults
17:00:14 <Phyx-> sure got quiet all of a sudden
17:00:59 <Zao> I'm trying to decide on which file format will be least painful for importing 2D line art.
17:01:15 <Phyx-> svg?
17:01:34 <Zao> Probably a bit too rich for me, but possibly.
17:01:50 <Zao> All I need for now is a pile of line segments with arbitrary attributes.
17:02:50 <Phyx-> well, It depends, do you want your own format or use an existing one? I don't know of any formats for lines only
17:03:10 <Zao> I'm unsure about what to author the content in too, so it's all rather vague.
17:03:10 <syntaxglitch> Zao, just use an appropriate format that there's already a library to read
17:03:27 <Zao> Considering things like AutoCAD, Inkscape, suchlike.
17:03:46 <Phyx-> oh, aren't CAD files quite complicated?
17:04:03 <Zao> I was hoping that there existed some simpler export or interop format.
17:04:24 <Zao> (this is for level editing for a top-down 2D game, so nothing CAD specific)
17:04:36 <Zao> The set of tools is basically "stuff I know how to use somewhat".
17:04:45 <Phyx-> I think they all load svg no? and I wouldn't think hackage has an svg entry
17:05:24 <Olathe> Are there any monads that have get :: m a, put :: m b, next :: m () and it produces [a -> b]?
17:05:25 <Phyx-> Zao: you could check the docs of AutoCAD and InkScape to see what they support
17:05:46 <Zao> Phyx-: I guess.
17:06:23 <FunctorSalad> @unmtl RWST a b () [] p
17:06:24 <lambdabot> a -> () -> [(p, (), b)]
17:06:26 <FunctorSalad> ;o
17:07:56 <syntaxglitch> Hey, FunctorSalad, did that crazy dictionary-passing thing you were doing in C# ever work out for you? Assuming you're the same "FunctorSalad" as on StackOverflow
17:08:01 <benmachine> Olathe: monads tend to be polymorphic in what they produce
17:08:12 <Olathe> Ahh.
17:08:18 <Olathe> Well, not so much with return.
17:08:18 <Phyx-> dictionaries in C#?
17:08:23 <benmachine> Olathe: ...what does "produce" mean anyway?
17:08:44 <kmc> Olathe, define it yourself :)
17:09:00 <kmc> produce when you "run" the action?
17:09:05 <Olathe> Yeah.
17:09:12 <kmc> what are the semantics?
17:09:38 <syntaxglitch> Phyx-, yeah, faking type classes in C# by passing explicit function dictionaries around
17:10:04 <Olathe> So, you'd be able to f = do { a <- get; put (a + 5); next; a <- get; put (a - 6); next; f } and get, essentially, cycle [(+5), (+6)]
17:10:14 <Olathe> Maybe with convert f or something.
17:10:45 <kmc> i think that should be possible
17:10:48 <kmc> kind of bizarre though
17:10:52 <aristid> :t let f = do { a <- get; put (a + 5); next; a <- get; put (a - 6); next; f } in f
17:10:53 <lambdabot> forall s g b. (MonadState s ((->) g), RandomGen g, Num s) => g -> b
17:11:00 <aristid> :t let f = do { a <- get; put (a + 5); next; a <- get; put (a - 6); next; return f } in f
17:11:01 <lambdabot>     Occurs check: cannot construct the infinite type: b = g -> b
17:11:01 <kmc> what if you put more than once between calls to "next"?
17:11:01 <lambdabot>     Probable cause: `f' is applied to too few arguments
17:11:01 <lambdabot>     In the first argument of `return', namely `f'
17:11:22 <aristid> :t next
17:11:23 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
17:11:27 <Olathe> I'm trying to, essentially, make a "mapping" sort of monad.
17:12:09 <Olathe> I need to be able to take a list of inputs and produce a list of outputs from them in the same order (not reversed). I need to provide a nice monad for it.
17:12:24 <kmc> why not use "map"
17:12:30 <Olathe> So, if I can essentially make it give a list of functions, I can zipWith id.
17:12:38 <Olathe> Well, the function can differ each time.
17:12:49 <Olathe> It's for a game.
17:13:02 <kmc> then why not generate that list of functions by more straightforward means
17:13:24 <Olathe> So, do { gameState <- get; put (firstTurnStuff gameState); next; ... } to do different things on different turns.
17:13:32 <FunctorSalad> syntaxglitch: I decided on a compromise... I put the single-occurence contravariant methods into an abstract class and the rest into the dictionary
17:14:05 <kmc> Olathe, i can see some benefit to this approach
17:14:05 <FunctorSalad> syntaxglitch: maybe overkill for what I'm doing, but I don't see yet why it shouldn't work in general ;)
17:14:13 <Olathe> Oh, because I want to make a monad so that people can write things in an imperative style.
17:14:14 <zeiris> Are there any pages that go over the different monadic parsers, and their differences/strengths/weaknesses? I'm looking at it now, and am lost at sea.
17:14:26 <kmc> Olathe, maybe you could code it using MonadPrompt
17:14:31 <Olathe> Hmm.
17:14:45 <kmc> Olathe, but i still wonder if a simpler solution would be just as good
17:15:01 <kmc> "Monad" just one API; you could use another API or define your own
17:15:27 <djahandarie> Except Monad gets special treatment with the do syntax
17:15:44 <syntaxglitch> FunctorSalad, it came to mind when I was writing some code at work recently that would have been much easier with more expressive ad-hoc polymorphism :(
17:15:48 <FunctorSalad> djahandarie: unless you -XNoImplicitPrelude =)
17:16:12 <benmachine> Olathe: "do" promotes an imperative style, but isn't the only way to get it; I think a list of lambdas which are then just executed in order is kinda imperative
17:17:47 <Olathe> Hmm, alright.
17:18:21 <bss03> @hoogle [(a, b)] -> ([a], [b])
17:18:21 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
17:18:22 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
17:18:28 <FunctorSalad> syntaxglitch: the type parameter is a bit more annoying to propagate in C# syntax so maybe it's not so good for something you use everywhere
17:18:34 <syntaxglitch> FunctorSalad, also I still felt guilty about being a little too snarky in my answer to your question :P
17:18:59 <Phyx-> as you should
17:19:01 <Phyx-> :)
17:19:18 <FunctorSalad> syntaxglitch: was yours the "the next maintainer will know where you live" one? that was kinda funny ;)
17:19:37 <Phyx-> loool
17:19:40 <syntaxglitch> FunctorSalad, I made a couple attempts at doing something like what you had, but I only needed it in a few widely-separated places and it didn't really improve the structure much :(
17:22:26 <syntaxglitch> FunctorSalad, and no, mine was the (accepted) top-scoring answer that started by being snide about how many hoops you were jumping through to make it work in C#
17:22:55 <FunctorSalad> syntaxglitch: right, maybe I should really just have used a downcast ;)
17:23:28 <benmachine> the wikipedia article on static versus dynamic type checking explains it in terms of runtime and compile-time, isn't there more to it than that?
17:23:44 <benmachine> (in particular, does that really sit with languages that aren't typically compiled?)
17:24:18 <FunctorSalad> you might have to generalize 'compilation' to 'whatever static analysis is done'?
17:25:38 <kmc> isn't that begging the question
17:25:49 <FunctorSalad> it depends ;)
17:26:05 <kmc> static type checking is type checking done as part of static analysis ;)
17:26:06 <FunctorSalad> maybe 'static analysis' is easier to define than static typchecking in particular? o_o
17:26:20 <benmachine> kmc: that's not entirely unreasonable
17:26:34 <kmc> sure but it doesn't answer very much
17:26:40 <kmc> if you want to define static analysis
17:26:51 <kmc> one important property is that it doesn't diverge, even with input programs that do diverge
17:26:53 <benmachine> it's basically the wikipedia approach only with a more generalised concept of compile time
17:27:11 <kmc> and this limits what can be done, due to the halting theorem
17:27:25 <FunctorSalad> another one is that it proves properties over infinite sets of possible inputs...
17:27:31 <kmc> also typically static analysis does not require a perfect model of the outside world a program interacts with, but rather uses a conservative model
17:27:31 <kmc> yeah
17:27:34 <FunctorSalad> which delimits it from testing, doesn't it?
17:27:54 <benmachine> and static analysis should ideally not launch any missiles >_>
17:28:11 <FunctorSalad> well, there's L.H.TH.runIO
17:28:15 <FunctorSalad> :)
17:28:36 <benmachine> I have to admit the prospect of the compilation process running arbitrary IO is a tiny bit eek
17:28:43 <benmachine> I wonder how often it's actually used
17:28:49 <kmc> the prospect of Haddock running arbitrary IO is a large bit eek
17:28:52 <benmachine> hah
17:29:00 <FunctorSalad> can it?
17:29:19 <FunctorSalad> (IO specified by the hadockee)
17:29:32 <copumpkin> I wouldn't mind it just being able to read external files
17:29:34 <copumpkin> and that's it
17:29:35 <benmachine> I think haddock has to run TH in order to correctly document e.g. instances
17:29:38 <kmc> it executes TH splices doesn't it
17:29:42 <syntaxglitch> pf, the prospect of any program running arbitrary IO is a bit eek
17:29:47 <FunctorSalad> benmachine: but you can use it to do funny stuff like making a "built on <date>" constant ;)
17:29:48 <copumpkin> maybe an IORead monad? :P
17:29:54 <copumpkin> that only allows you to read files
17:30:11 <copumpkin> no reason TH should ever have to write to the outside world, interface with the network, or any of that shit
17:30:23 <benmachine> copumpkin: mm, that'd be nice in general too possibly
17:30:54 * benmachine wonders if there would be any point in IOWrite
17:31:01 <syntaxglitch> benmachine, logging?
17:31:08 <FunctorSalad> then someone will figure out how to run arbitrary code through "read" type actions, lol
17:31:17 <benmachine> syntaxglitch: I mean, is there any reason you'd want to guarantee a program woudl not read
17:31:20 <benmachine> but woudl write
17:31:20 <FunctorSalad> (crash the kernel file caching thing somehow)
17:31:20 <copumpkin> syntaxglitch: you can do a lot worse than logging through with writes
17:31:34 <benmachine> FunctorSalad: then someone will figure out how to stop them doing that
17:31:51 <copumpkin> I think only read is a fairly natural behavior
17:31:54 <benmachine> yes
17:32:02 <copumpkin> you may want to generate your code from external specs
17:32:04 <benmachine> and something that you would be interested in guaranteeing
17:32:10 <copumpkin> yeah
17:32:22 <benmachine> what form would it take though?
17:32:33 <benmachine> I mean, phantom type, newtype, type class etc.
17:33:01 <copumpkin> a newtype around IO that only has one function defined on it :P
17:33:14 <syntaxglitch> benmachine, write-only preserves more isolation--you can keep some guarantees about, say, order of execution being irrelevant
17:33:31 <benmachine> syntaxglitch: order of execution isn't irrelevant to what gets written!
17:33:53 <benmachine> it is to what the final result is, but that's not terribly exciting
17:33:57 <syntaxglitch> whereas if it's possible to read the log, parts of the program could react differently based on earlier logs
17:34:19 <benmachine> also, I wonder if IOWrite could be fully emulated with Writer
17:34:32 <benmachine> given that IO a is a monoid
17:34:40 <syntaxglitch> benmachine, sure it is--things get written in the order they're executed. Isn't that what you usually care about with logging, anyway?
17:34:50 <FunctorSalad> hmm, IO () is
17:34:59 <FunctorSalad> (for s/IO/any monad/)
17:35:07 <FunctorSalad> but IO a?
17:35:12 <benmachine> FunctorSalad: true
17:35:22 <benmachine> well I don't know how far you'd get with return undefined
17:35:25 <benmachine> it might be okay
17:35:28 <FunctorSalad> oh wait, it does work for any a
17:35:42 <benmachine> any applicative!
17:35:57 <kyagrd_> @type (return undefined)
17:35:57 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
17:35:58 <FunctorSalad> hmm, a semigroup for any a I guess
17:36:12 <FunctorSalad> (unless you resort to return undefined)
17:36:22 <FunctorSalad> but with undefined anything is anything anyway
17:36:27 <benmachine> FunctorSalad: nah
17:36:33 <benmachine> because you've got to satisfy the laws
17:36:46 <benmachine> I think pure undefined is required to be well-behaved
17:36:59 <benmachine> i.e. pure undefined *> m = m for all m
17:37:27 <FunctorSalad> hmm
17:37:47 <benmachine> I mean it's true you can set mempty = undefined and mappend = undefined and that'll work for most things
17:37:50 <benmachine> but it's not useful :P
17:38:03 <FunctorSalad> > [1,2] >> return undefined
17:38:04 <lambdabot>   [*Exception: Prelude.undefined
17:38:12 <xplat> you can set everything to undefined
17:38:25 <xplat> including undefined
17:38:40 <benmachine> hmm
17:38:46 <benmachine> okay
17:38:49 <aristid> benmachine: useful, not useful... if everybody thought like that, we'd have no category-extras at all!
17:38:54 <benmachine> I'll settle for the IO () monoid
17:39:01 <benmachine> aristid: >_>
17:39:12 <benmachine> well, the Applicative f => f () monoid
17:39:39 <aristid> where empty = pure () and mappend = (<*>)?
17:39:45 <benmachine> mappend = (*>)
17:39:52 <aristid> :t (*>)
17:39:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
17:40:03 <benmachine> (*>) is basically (>>) on applicatives
17:40:12 <aristid> yeah
17:40:14 <benmachine> flip const <$> a <*> b
17:40:23 <aristid> yeah i do get it :P
17:40:41 <syntaxglitch> more like (>>) is (*>) with a spurious and unnecessary Monad constraint
17:40:46 <benmachine> heh
17:40:47 <aristid> @check flip const == const id
17:40:48 <lambdabot>   No instance for (GHC.Classes.Eq (b -> a -> a))
17:40:48 <lambdabot>    arising from a use of `GH...
17:40:53 <benmachine> that too
17:41:29 <benmachine> there's probably a free theorem about that
17:41:38 * benmachine wishes he knew more about those
17:42:12 <benmachine> well I guess there aren't loads of total, non-seq-using functions of type b -> a -> a
17:42:39 <FunctorSalad> hmm no, but F b -> F a -> F a for fixed F
17:42:40 <syntaxglitch> pretty sure there's exactly one total function with that type
17:42:54 <aristid> benmachine: flip const . X for any X?
17:43:01 <aristid> :t flip const . (+1)
17:43:02 <lambdabot> forall b a. (Num a) => a -> b -> b
17:43:11 <benmachine> aristid: that's a more specific type
17:43:28 <aristid> @hoogle a->a
17:43:28 <lambdabot> Prelude id :: a -> a
17:43:28 <lambdabot> Data.Function id :: a -> a
17:43:28 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
17:43:36 <benmachine> that third one is evil
17:43:40 <benmachine> well not really
17:43:50 <benmachine> but it's... untidy
17:43:53 * syntaxglitch assumed benmachine meant forall a b. b -> a -> a
17:43:58 <benmachine> syntaxglitch: yeah
17:44:55 <dolio> benmachine: mempty = undefined ; mappend = undefined doesn't define a monoid.
17:45:19 <FunctorSalad> haha didn't know mapException
17:45:38 <benmachine> dolio: oh yeah, oops
17:45:42 <FunctorSalad> it was probably more useful before SomeException?
17:45:50 <FunctorSalad> hmm or maybe not
17:46:00 <benmachine> I got confused because it does on empty types
17:46:04 <benmachine> (or does it?)
17:46:15 <dolio> Empty types, yes.
17:46:21 <benmachine> mm
17:46:53 <benmachine> I remember wondering whether it was useful to define typeclass instances for an empty type
17:47:16 <benmachine> since a lot of them have laws that are trivially satisfied when your only element is bottom
17:47:56 <syntaxglitch> benmachine, some people do that in type-level metaprogramming
17:48:39 * syntaxglitch usually prefers non-empty singleton types, to avoid writing (undefined :: Foobar) all the time
18:07:31 <Phyx-> is there an easier way to write
18:07:33 <Phyx-> > zipWith (\a b->a:show b) (cycle ['a'..'b']) (concatMap (replicate 26) [1..])
18:07:34 <lambdabot>   ["a1","b1","a1","b1","a1","b1","a1","b1","a1","b1","a1","b1","a1","b1","a1"...
18:07:46 <Mathnerd314> how does memoization work? if I call foo x y, then later call foo x y, is the second just a lookup?
18:08:03 <Veinor> Phyx-: what are you trying to do?
18:08:26 <Veinor> Mathnerd314: no, functions don't cache like that
18:08:50 <Phyx-> > zipWith (\a b->a:show b) (cycle ['a'..'z']) (concatMap (replicate 26) [1..])
18:08:51 <lambdabot>   ["a1","b1","c1","d1","e1","f1","g1","h1","i1","j1","k1","l1","m1","n1","o1"...
18:09:17 <Veinor> because a: you can't necessarily memoize every function and b: it would be hugely memory-inefficient
18:09:19 <Phyx-> Veinor: that, generate a list of labels, starting with a-z
18:10:04 <Phyx-> so
18:10:20 <Phyx-> a1...z1,a2..z2,a3..z3
18:10:21 <Phyx-> etc
18:10:32 <Veinor> oh, hm
18:10:47 <syntaxglitch> pfff, memory is cheap, just memoize everything
18:10:48 <Mathnerd314> Veinor: ok, what about data structures? (like fib = 1 : 1 : zip fib (tail fib) memoizes, I think)
18:11:03 <syntaxglitch> in fact, might as well just pre-memoize everything at compile-time
18:11:09 <Veinor> > liftM (\a b -> a : show b) ['a' .. 'z'] [1..26]
18:11:10 <lambdabot>   Couldn't match expected type `[t1] -> t'
18:11:10 <lambdabot>         against inferred type `[a ...
18:11:15 <Veinor> > liftM2 (\a b -> a : show b) ['a' .. 'z'] [1..26]
18:11:16 <lambdabot>   ["a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","a11","a12","a13","a14"...
18:11:19 <syntaxglitch> in fact, just do everything at compile time
18:11:23 <syntaxglitch> it's easier that way
18:11:28 <Veinor> you get the idea
18:11:37 <Veinor> or did you want the sequence to be guaranteed infinite?
18:11:49 <Mathnerd314> syntaxglitch: wth are you saying? :p
18:12:03 <Veinor> Mathnerd314: when you evaluate, say, the 100th element in the list
18:12:10 <Phyx-> Veinor: wrong sequencing
18:12:11 <syntaxglitch> actually, forget running it at all--if it type-checks that's good enough
18:12:32 <Veinor> Phyx-: reverse? ;)
18:12:43 <Veinor> Mathnerd314: it won't evaluate the 100th element multiple times
18:12:46 <Mathnerd314> syntaxglitch: you sound like an Agda user :p
18:13:06 <Veinor> (I think)
18:13:15 <Phyx-> Veinor: that won't matter, that generates a list of 1 letter consecutively untill they run out and then picks the next letter
18:13:21 <Phyx-> that's not the original sequence I had
18:13:23 <syntaxglitch> I'll get around to learning Agda one of these days
18:13:33 <NemesisD> anyone ever try test-framework?
18:13:34 <Veinor> hm
18:13:44 <Veinor> > liftM2 (\b a -> a : show b) ['a' .. 'z'] [1..26]
18:13:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:13:45 <lambdabot>    arising from the literal `1...
18:13:58 <NemesisD> im able to get a test suite ive made to compile but it fails during linking
18:14:12 <Veinor> > liftM2 (\a b -> show b : a) ['a' .. 'z'] [1..26]
18:14:13 <lambdabot>   Couldn't match expected type `[GHC.Base.String]'
18:14:13 <lambdabot>         against inferred t...
18:14:17 <aavogt> > do b <- [1.. ]; a <- ['a' .. 'z']; return (a : show b)
18:14:17 <Veinor> argh
18:14:18 <lambdabot>   ["a1","b1","c1","d1","e1","f1","g1","h1","i1","j1","k1","l1","m1","n1","o1"...
18:14:21 <Veinor> yeah, that
18:15:23 <Phyx-> > liftM2 (\b a -> a : show b) [1..26] ['a'..'z']
18:15:24 <lambdabot>   ["a1","b1","c1","d1","e1","f1","g1","h1","i1","j1","k1","l1","m1","n1","o1"...
18:15:30 <Phyx-> yup, that's shorter
18:15:42 <Phyx-> > liftM2 (\b a -> a : show b) [1..] ['a'..'z']
18:15:43 <lambdabot>   ["a1","b1","c1","d1","e1","f1","g1","h1","i1","j1","k1","l1","m1","n1","o1"...
18:16:01 <medfly> > ['1'..]
18:16:02 <lambdabot>   "123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxy...
18:16:04 <benmachine> @pl \a b -> a : show b
18:16:04 <lambdabot> (. show) . (:)
18:16:10 <benmachine> @pl \b a -> a : show b
18:16:10 <lambdabot> flip (:) . show
18:23:19 <NemesisD> could anyone take a look at this linking error? I'm stumped http://pastie.org/1151329
18:24:52 <NemesisD> linker errors area always so user friendly
18:25:19 <copumpkin> (probably mising --make on ghc?)
18:25:27 <copumpkin> (I haven't looked at the paste)
18:25:39 <tommd> Looks like it
18:25:41 <nejucomo> Um…  How do I write what I meant when I wrote this?
18:25:42 <nejucomo> fail :: Show b => forall a. String -> b -> TranslationResult a
18:25:43 <aristid> (.text+0x587): undefined reference to `__stginit_QuickCheckzm2zi2_TestziQuickCheck_'
18:25:50 <aristid> that's his error
18:26:11 <nejucomo> Maybe I can just drop the "forall a." ?
18:26:42 <aristid> nejucomo: what's the relation between a and b?
18:26:44 <NemesisD> hmm the example didn't have a make
18:26:46 <nejucomo> Oh, and that's a bad name for a function.
18:27:13 <Veinor> NemesisD: you almost always want ghc --make
18:27:17 <nejucomo> aristid: type TranslationResult a = Either String a
18:27:20 <Phyx-> @hoogle replace
18:27:20 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
18:27:20 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
18:27:20 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
18:27:24 <NemesisD> i ran it with runhaskell and it thrashes my computer something awful but i guess thats probably more related to my failure at quickcheck
18:27:29 <benmachine> nejucomo: what extensions are you using that involve forall?
18:27:32 <aristid> nejucomo: i asked for the relation between b and a
18:27:33 <nejucomo> aristid: This function returns (Left ...)
18:27:38 <nejucomo> There is none.
18:27:43 <Phyx-> @hoogle "[a] -> a -> [a]"
18:27:44 <lambdabot> Parse error:
18:27:44 <lambdabot>   --count=20 ""[a] -> a -> [a]""
18:27:44 <lambdabot>              ^
18:27:48 <nejucomo> That's why I say "forall a."
18:27:48 <Phyx-> @hoogle [a] -> a -> [a]
18:27:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:27:49 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
18:27:49 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:27:56 <Phyx-> hrm
18:27:58 <Phyx-> no replace?
18:28:08 <aristid> nejucomo: the forall is implicitly there anyways. there is also a forall on b
18:28:12 <aristid> *on a
18:28:19 <aristid> *on a and b
18:28:37 <nejucomo> Yeah, perhaps I don't get forall.  Anyway, by dropping it, it now compiles (minus the name collision with Prelude.fail).
18:28:39 <tommd> NemesisD: What's with this "types" variable?  Why not just give the prop_ function a signature?
18:28:48 <benmachine> nejucomo: are you using RankNTypes, or ScopedTypeVariables?
18:28:49 <megajosh2> nejucomo: It helped when I looked up first-order logic
18:29:05 <megajosh2> That might be going a little too far to just get Haskell's type signatures though
18:29:31 <nejucomo> benmachine: Not as far as I know.
18:29:56 <benmachine> nejucomo: I wouldn't use forall at all, then, ever
18:29:58 <nejucomo> So that type could be written as:  Show b => String -> b -> Either String a
18:29:59 <NemesisD> tommd: im using test-framework and that was how their example looked: http://github.com/batterseapower/test-framework/blob/master/example/Test/Framework/Example.lhs
18:30:08 <nejucomo> benmachine: Ok.  Good to know.
18:30:16 <megajosh2> benmachine: You're able to explicitly use forall without those extensions on?
18:30:30 <benmachine> megajosh2: erm, no, there is an ExplicitForall extension though I think
18:30:38 <nejucomo> For some reason I thought I would need to tell the type system I don't care about the type a because it does not appear in the function definition.
18:30:40 <benmachine> which doesn't do anything with it
18:30:50 <megajosh2> :/
18:31:08 <benmachine> nejucomo: basically, a type like show :: (Show a) => a -> String, implicitly means show :: forall a. (Show a) => a -> String
18:31:22 <tommd> NemesisD: Ahh ,the "blame dons" defense ;-).  Well, I don't like it because it seems lazy and fails to communicate as much as a proper function type signature.
18:31:27 <benmachine> nejucomo: every type variable already means "for all me"
18:32:06 <nejucomo> Ok.  I clearly do not understand forall in that case.
18:32:12 <megajosh2> Only on the most outer scope though
18:32:18 <nejucomo> Oh wait, maybe I'm confusing it from GADTs?
18:32:26 <benmachine> nejucomo: I wouldn't worry about it :) you can get quite far in haskell without using forall
18:32:34 <NemesisD> tommd: put the type sig in ayways. im not lazy i just don't know what the hell im doing
18:32:35 <nejucomo> data Foo = forall a. Foo a Banana
18:32:48 <megajosh2> Hmm...
18:32:55 <benmachine> nejucomo: that's not a GADT, that's different
18:33:03 <NemesisD> tommd: case in point: you guys were right about the --make, but quickcheck still instantly eats up all my memory
18:33:07 <nejucomo> Yeah, anyway I have yet to need very esoteric extensions (except for some which make instance declarations more flexible).
18:33:23 <tommd> NemesisD: Are you sure that's not a problem with your get/setInt routines?
18:33:37 <megajosh2> Wouldn't forall a. being there be existential type quantification?
18:34:22 <megajosh2> Seems like you always have to use "where" if you're using GADTs
18:34:40 <Cale> Yes, 
18:34:55 <Cale> 'where' introduces GADT syntax in a data declaration
18:35:17 <megajosh2> Alright, just making sure; haven't used GADTs for anything yet
18:35:26 <nejucomo> hehe…  I just said I don't need extensions, but it appears I use -XTypeSynonymInstances.
18:35:47 <Cale> You can encode any existential type using GADT notation, and I'd actually recommend it unless you care about your library being usable in Hugs
18:36:11 <NemesisD> tommd: could be i suppose, im not sure how they handle negative numbers but i've tested it in ghci a bit and it worked ok,i'd like to figure out a way for quickcheck to go easy on it so i can at least get an idea of whats gone wrong before my system starts thrashing for 10 mins
18:36:35 <Cale> (It's more readable)
18:36:41 <Cale> data Foo where
18:36:48 <Cale>   Foo :: a -> Banana -> Foo
18:36:54 <tommd> NemesisD: You could run fewer checks at once
18:37:00 <nejucomo> Um.  I'm confused.  I have: type TranslationResult a = ...
18:37:11 <nejucomo> -then later: instance Monad TranslationResult where ...
18:37:14 <nejucomo> This fails.
18:37:20 <megajosh2> Hmm...
18:37:23 <nejucomo> Is it because I use "type"?
18:37:33 <megajosh2> If you don't have that language extension enabled, then you can't do that
18:37:58 <megajosh2> Would newtype be enough?
18:38:09 <NemesisD> tommd: i could? how
18:38:37 <nejucomo> Shouldn't this do the trick?  {-# OPTIONS_GHC -XTypeSynonymInstances #-}
18:38:42 <benmachine> nejucomo: TypeSynonymInstances is very basic, I think, a convenience rather than actually increasing expressivity
18:38:48 <bss03> @type foldr
18:38:49 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:39:04 <benmachine> nejucomo: first of all, use LANGUAGE pragmas rather than OPTIONS_GHC, they can be recognised by more diverse tools
18:39:23 * nejucomo gtfms
18:39:48 <benmachine> nejucomo: it's just {-# LANGUAGE TypeSynonymInstances #-}
18:40:13 <nejucomo> Thanks.
18:40:54 <benmachine> nejucomo: secondly, it seems type synonym instances require the type synonym to be fully applied
18:40:58 <tommd> NemesisD: That depends on the version of QC used.  see quickCheckWith in the QC2 docs: http://hackage.haskell.org/packages/archive/QuickCheck/2.3/doc/html/Test-QuickCheck-Test.html
18:41:04 <nejucomo> However, this still fails: Type synonym `TranslationResult' should have 1 argument, but has been given 0
18:41:14 <nejucomo> So should I use newtype?
18:41:35 <benmachine> nejucomo: it depends, what is TranslationResult?
18:41:50 <benmachine> oh wait
18:41:52 <nejucomo> type TranslationResult a = Either String a
18:41:53 <benmachine> Either String a right?
18:41:55 <benmachine> yes
18:41:56 <benmachine> um
18:41:59 <dolio> Type synonyms must always be fully applied.
18:42:06 <benmachine> you don't need a newtype for that
18:42:23 <nejucomo> Huh…  So you can't define a class instance for a parameterized type synonym?
18:42:33 <NemesisD> tommd: test-framework has a test-framework-quickcheck and test-framework-quickcheck2 so it would appear that i was not using 2
18:42:42 <benmachine> nejucomo: what happens if you declare
18:42:48 <benmachine> type TranslationResult = Either String
18:43:00 <benmachine> (anyone else: is that valid? I forget)
18:43:02 <tommd> So you should look at the QC1 docs, which uses the "Config" data structure and the "check" function
18:43:04 <dolio> The only exception is with the liberal type synonyms (I think that's what they're called), where you can give partially applied synonyms as arguments to other synonyms, as long as the latter expands into something that fully applies the former.
18:43:25 <nejucomo> benmachine: Crazy.  That works.
18:43:25 * tommd runs away
18:43:39 <Phyx-> weee alpha renaming
18:43:48 <Phyx-> and a simplifier
18:43:51 <Phyx-> do wonders
18:44:57 <tommd> NemesisD: You seem new, so FYI the haddock docs can be found on hackage:  hackage.haskell.org --> Packages --> select a package (ex: QuickCheck) --> Click on Version you want (ex: 1.2.0.0) --> Module names link to the documentation
18:45:13 <nejucomo> Hrmph.  I think I'll find it more readable to do something like "data TRes a = Success a | Failure String" then "instance Monad TRes where ..."
18:46:37 <Veinor> oh yeah
18:46:43 <Veinor> if haskell.org is moving servers
18:46:46 <Veinor> is hackage moving with it?
18:46:59 <benmachine> no, hackage is a separate server I think
18:47:22 <Veinor> ah
18:47:28 <Veinor> I ask because of the e-mail that got sent out
18:47:40 <benmachine> hackage is on 69.30.63.204 and haskell.org is on 128.36.229.215
18:47:41 <djahandarie> Yes it is a seperate server
18:47:50 <djahandarie> (Not the community server either obv)
18:56:55 <Olathe> @type let f a = (a:) f (a + 1) in f
18:56:56 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[a]'
18:56:56 <lambdabot>     In the expression: (a :) f (a + 1)
18:56:56 <lambdabot>     In the definition of `f': f a = (a :) f (a + 1)
18:57:04 <Olathe> @type let f a = (a:) . f (a + 1) in f
18:57:05 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => a -> f [a]
18:57:32 <Veinor> is that caleskell?
18:57:44 <benmachine> yes
18:57:54 <benmachine> @type let f a = (a:) Prelude.. f (a + 1) in f
18:57:55 <Veinor> yep
18:57:55 <lambdabot> forall a a1. (Num a) => a -> a1 -> [a]
18:57:58 <Olathe> If you mean mine, it works in ghci.
18:58:05 <Olathe> Ahh.
18:58:11 <Olathe> Why is it a1 instead of [a]?
18:58:21 <Veinor> Olathe: because in caleskell . is fmap
18:58:31 <Olathe> I mean with benmachine's.
18:58:57 <Veinor> Lambdabot uses Caleskell, which is Haskell with a few extra weird things
18:59:04 <benmachine> this is not to do with caleskell
18:59:05 <Veinor> like (.) being fmap instead of function composition
18:59:12 <Olathe> Plain ghci gives f :: (Num a) => a -> a1 -> [a]
18:59:15 <Veinor> ?
18:59:18 <benmachine> this is more to do with f recursing unconditionally
18:59:23 <kmc> technically, it's GHC Haskell with a bunch of extensions enabled and some non-standard set of imports
18:59:31 <Veinor> benmachine: I meant the a1 -> [a] as opposed to f [a]
18:59:32 <kmc> also Cale has disowned the name
18:59:33 <kmc> ;P
18:59:38 <Veinor> that's because of caleskell
18:59:41 <Veinor> kmc: what? why?
18:59:45 <benmachine> Veinor: oh sure but we don't care about that
18:59:48 <kmc> don't ask me
19:00:01 <aristid> kmc: it isn't his to decide how people call it
19:00:06 <Veinor> weird
19:00:12 * kmc would rather have the (.) from Category, for prettyness, but admits that fmap is more useful
19:00:30 <benmachine> Olathe: f (a + 1) is inferred to have a function type because it is used in a composition
19:00:40 <benmachine> so f (a + 1) :: a1 -> b
19:00:49 <Cale> My problem with Control.Category is that it doesn't seem to me to be a very faithful intepretation of what categories are, and there are not many great examples of its use.
19:00:50 <benmachine> then the (a:) . forces b to be a list type
19:01:07 <benmachine> so f (a + 1) :: a1 -> [a]
19:01:19 <NemesisD> turns out the code i was testing explodes when you give it a negative number
19:01:21 <benmachine> where a is the type of the value (a + 1)
19:01:25 <NemesisD> thanks quickcheck
19:01:29 <Veinor> Cale: why'd you disown Caleskell?
19:01:47 <Cale> Veinor: Because that name makes it sound like it's a variant of Haskell.
19:01:52 <benmachine> so f :: a -> a1 -> [a]
19:02:05 <Veinor> so what should we call it?
19:02:07 <Cale> When really all I've done is to make a handful of definitions in local scope :P
19:02:10 <Veinor> also, why's it have all the weird imports?
19:02:13 <benmachine> Olathe: does that make sense? the second parameter is completely discarded
19:02:17 <benmachine> Veinor: for convenience?
19:02:29 <kmc> well, and it has a bunch of GHC extensions enabled, which *does* make a variant of Haskell, but a rather common one
19:02:32 <Veinor> how the hell are num instances for (a -> b) convenient? :P
19:02:33 <benmachine> Cale: is it your hope that one day the standard will adopt the same definitions?
19:02:34 <Cale> Call it L.hs
19:02:35 <Olathe> Not yet :)
19:02:43 <Veinor> yeah, the GHC extensions are nice
19:02:44 <kmc> i thought L was the stuff set by @let
19:02:45 <Olathe> (a:) :: [a] -> [a]
19:02:47 <benmachine> Veinor: they're cute
19:03:00 <benmachine> Veinor: e.g.
19:03:05 <Cale> benmachine: Some of them would be nice, though I think I might actually prefer destandardisation of the Prelude.
19:03:08 <Veinor> > (sin^2 + cos^2) [0.0, 0.1..0.5]
19:03:09 <lambdabot>   No instance for (GHC.Float.Floating [t])
19:03:09 <lambdabot>    arising from a use of `e_122000...
19:03:15 <Veinor> > map (sin^2 + cos^2) [0.0, 0.1..0.5]
19:03:16 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0]
19:03:17 <benmachine> > sin^2 + cos^2 $ 3
19:03:17 <lambdabot>   0.9999999999999999
19:03:20 <Veinor> yeah :D
19:03:21 <benmachine> oh
19:03:22 <benmachine> yes
19:03:24 <benmachine> right
19:03:25 * benmachine slow
19:03:56 <benmachine> Cale: so everything would come from the packages you imported?
19:04:10 <benmachine> or the modules you imported, rather
19:04:12 <megajosh2> wtf?
19:04:26 <Cale> benmachine: Well, presumably there would still be a Prelude, it just wouldn't be standardised what was in it.
19:04:27 <megajosh2> > (+1) . [1..]
19:04:29 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:04:38 <benmachine> Cale: that sounds like it would be hard to write portable code
19:04:49 <Cale> benmachine: There would be a base package, and various versions of that base package, just as there are now.
19:04:51 <aristid> > 1 . [1..]
19:04:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:04:56 <megajosh2> That's... odd
19:05:14 <megajosh2> > ((*2) . (+3)) 5
19:05:15 <lambdabot>   16
19:05:25 <Veinor> megajosh2: I think fromInteger = const
19:05:36 <Veinor> > 5 3
19:05:37 <lambdabot>   Ambiguous type variable `t' in the constraint:
19:05:37 <lambdabot>    `GHC.Num.Num t' arising f...
19:05:41 <Veinor> > 5 3 :: Integer
19:05:41 <lambdabot>   5
19:05:48 <benmachine> Cale: hmm, so there sort of would be a standard, it just wouldn't be in the language as it were
19:05:58 <aristid> > 1 2 3 4 5 6 7 8 9 :: Integer
19:05:59 <lambdabot>   1
19:06:05 <Veinor> :D
19:06:14 <Cale> benmachine: Essentially, yeah.
19:06:21 <megajosh2> That is really weird...
19:06:37 <aristid> megajosh2: it's just a Num instance for (e ->)
19:06:38 <megajosh2> @src (->) fmap
19:06:38 <lambdabot> fmap = (.)
19:06:39 <benmachine> Cale: would the implicit Prelude import still be in the language?
19:06:49 <kmc> "Warning: Module `Prelude' is deprecated:"
19:06:50 <megajosh2> Oh right...
19:06:50 <Cale> benmachine: Or just shrink the standardised portion of the Prelude to a bare minimum, and say that it can contain more, where the base package probably will provide more.
19:06:51 <kmc> makes me chuckle every time
19:07:07 <Colours> hey who owns foldl.com and foldr.com
19:07:13 <Cale> benmachine: I like the implicit Prelude import, but I really dislike the fact that the Prelude is so resistant to change.
19:07:18 <Olathe> benmachine: Ahh, OK, it makes sense. Thanks.
19:07:31 <benmachine> Olathe: oh, neat, okay
19:07:34 <Cale> Really, the whole base package is *really* hard to change. It took us years to put a permutations function in Data.List
19:07:43 <benmachine> mm
19:08:03 <megajosh2> Carnegie Melon thinks that foldl is a scam?
19:08:09 <megajosh2> *Mellon
19:08:13 <kmc> Cale, do you have any "alternative Prelude" modules you'd recommend?
19:08:14 <Cale> It's too hard to move forward, and it really shouldn't be this hard when we have nice versioning systems and all.
19:08:14 <benmachine> it's hard to talk about portability in haskell code since one implementation is so far ahead of the rest >_>
19:08:35 <Veinor> megajosh2: apparently
19:08:39 <kmc> benmachine, ahead, but not strictly so.  UHC, Hugs, and JHC all have useful extensions GHC lacks
19:08:57 <kmc> i suspect the first step to a major overhaul of Prelude (as opposed to incremental changes) would be widespread adoption of some third-party alternative Prelude
19:09:24 <Cale> kmc: No, because replacing the Prelude typically means that you have to rebuild everything against it, and so it's hard to be motivated to write a module which you can't actually use.
19:09:59 <kmc> everything?
19:10:02 <kmc> i don't see why
19:10:15 <Cale> Well, let's suppose we want to remove fail from the Monad class.
19:10:27 <benmachine> classes and instances are tricky
19:10:38 <benmachine> functions and operators and so forth are less so, I'd've thought
19:10:39 <Cale> Just defining a different class named Monad isn't the same thing
19:10:48 <kmc> yeah, there's some stuff you have a hard time changing
19:10:51 <Cale> All the packages which use the Monad class have to be rebuilt
19:10:57 <kmc> but e.g. we can eliminate Int and make length return (Num a) => a
19:11:01 * benmachine wonders vaguely why . is infixr
19:11:08 <Cale> benmachine: efficiency
19:11:10 <kmc> and keep compatibility -- things importing the old Prelude.Int will still work
19:11:28 <Cale> (.) is associative, but f . (g . h) is more efficient than (f . g) . h by a constant factor
19:11:34 <benmachine> oh
19:11:42 <benmachine> that vaguely surprises me, but okay
19:12:03 <Cale> (f . (g . h)) x --> f ((g . h) x) --> control passes to f
19:12:10 <benmachine> ah
19:12:14 <benmachine> of course, right
19:12:24 * benmachine still doesn't think outermost-first sometimes
19:12:54 <Cale> ((f . g) . h) x --> (f . g) (h x) --> f (g (h x)) --> control passes to f
19:13:05 <Cale> (you already got it, but I'll just put that there for completeness :)
19:14:07 <Cale> The cool thing about outermost first evaluation is that f . g . h is actually evaluated left to right :)
19:14:12 <sshc> Where is rnf exported?
19:14:32 <ddarius> @hoogle rn
19:14:32 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
19:14:32 <lambdabot> Control.Applicative class Applicative f => Alternative f
19:14:32 <lambdabot> Language.Haskell.ParseMonad alternative :: Lex a v -> Lex a (Lex a v)
19:14:34 <ddarius> @hoogle rnf
19:14:34 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
19:14:34 <sshc> GHC complains that "Module `Control.Parallel.Strategies' does not export `rnf'", but the documentation says otherwise
19:14:40 <sshc> s/documentation/hoogle/
19:14:53 <Cale> hoogle is out of date
19:14:54 <ddarius> sshc: The new C.P.Strategies uses a different system
19:14:57 <benmachine> sshc: the parallel module is on something like its third major version
19:15:09 <Cale> rnf is in Control.DeepSeq
19:15:11 <benmachine> it moves quite fast, as APIs go
19:15:22 <sshc> What's the new way?
19:15:35 <Cale> It just moved to a new module
19:15:54 <sshc> rdeepseq apparently
19:16:13 <Cale> http://hackage.haskell.org/packages/archive/parallel/3.1.0.0/doc/html/Control-Parallel-Strategies.html#12
19:16:39 <Cale> Ah, yeah, there's also rdeepseq, which is the Strategy version
19:17:10 <Cale> while rnf in Control.DeepSeq has the same type as the old rnf
19:19:09 <Cale> I think we might actually want to fork all of hackage into a contemporary and future version, based on the changes we want to make to base packages.
19:19:58 <benmachine> all of hackage?
19:20:52 <Cale> Well, produce new versions of the base packages, and then start the process of building packages against the new versions until we reach a critical mass, and then we can shift things down.
19:21:36 <Cale> We already sort of do this anyway, in that each new GHC version has a new base library.
19:21:44 <Cale> But it's less structured.
19:31:38 <alise> Anyone have any bright ideas on how to write this function? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29886
19:31:54 <sm> nice.. even haddock 2.4 gets a facelift http://hackage.haskell.org/packages/archive/template-haskell/2.3.0.1/doc/html/Language-Haskell-TH-Quote.html#v:QuasiQuoter
19:31:55 <alise> Hopefully its de-flattening purpose should be obvious from the types and the comment; if not, I can elaborate.
19:32:54 <alise> sorry, that's wrong
19:32:55 <alise> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29886#a29887
19:32:56 <alise> this is correct
19:35:36 <monochrom> @seen copumpkin
19:35:37 <lambdabot> Unknown command, try @list
19:35:37 <preflex>  copumpkin was last seen on #haskell 1 hour, 10 minutes and 10 seconds ago, saying: (I haven't looked at the paste)
19:36:13 <xplat> alise: not really finding it obvious, no
19:36:35 <alise> come to think of it, the function is basically "turn a nested list into a bunch of pointers"
19:36:46 <alise> that sounds similar to something i think does that, but i've forgotten the name
19:38:08 <xplat> also, 'Nested' is not defined
19:39:05 <xplat> offhand, this sounds like one of those cases where when you figure out how to explain the function to somebody you will also figure out how to write it
19:39:58 <alise> xplat: quite
19:40:06 <alise> xplat: I have written it before, in Scheme, and ages ago in ugly Haskell
19:40:12 <alise> it has never been pretty, but I feel the concept is a simple one
19:40:14 <alise> turn nesting into pointers
19:40:29 <alise> s/Nested/NestedList/, anyway.
19:42:33 <xplat> maybe an example?  nested lists as s-exprs and blimped as dotlists are fine ...
19:43:02 <xplat> easier to read anyway
19:44:25 <xplat> i'm just completely not getting what the pointers are supposed to be pointing to
19:45:08 <kmc> Blimped is a strange type
19:45:17 <kmc> like Mu but with this side thing
19:46:28 <kmc> alise, sounds like you want to turn a tree into a flat list of "nodes", where each node is either a leaf with data, or the index of two child nodes
19:46:57 <alise> kmc: two child nodes? no, just one
19:47:08 <alise> it's basically turning a nested list into a list of lists
19:47:11 <kmc> how is it a tree then
19:47:18 <alise> where the first list is the original tree you passed it
19:47:29 <alise> and wherever a nested list would go, a reference to an index in the list-of-lists is there instead
19:47:36 <alise> thus having flattened the structure into pointers
19:47:50 <xplat> hm, blimped will only let you put an index at the end
19:47:52 <alise> also, Mu-with-this-side-thing is something I quite often use and I think others do too
19:47:59 <alise> at least, I recall augustss or someone making posts using it
19:48:03 <kmc> can you provide some sample input / output pairs?
19:48:05 <alise> xplat: hmm right
19:48:55 <alise> kmc: using fake syntax for the nested list: [a,b,[c,d,[e],f],[g,h,i],j] -> [[a,b,<1>,<2>,j], [c,d,<3>,f], [g,h,i], [e]]
19:49:00 <xplat> it sounds like you want to adapt that functional pearl on breadth-first tree labelling
19:49:20 <kmc> ok
19:49:47 <kmc> so the input is a leaf-labeled rose tree
19:50:05 <kmc> data Tree a = Leaf a | Node [Tree a]
19:50:56 <kmc> and the output is [[Item a]] where data Item a = Value a | Ref Integer
19:51:04 <kmc> so how does this compare to your Blimped type
19:51:35 <alise> kmc: it does not really
19:51:38 <alise> i wasn't thinking properly
19:51:44 <alise> approaching the problem for the first time in quite a while
19:52:04 <kmc> ok
19:52:28 <kmc> btw this sounds a little like an "observable sharing" problem
19:52:38 <kmc> turn a tree into a list of all its subtrees, then recover sharing
19:52:48 <kmc> that's probably not a good implementation strategy though
19:53:03 <alise> oh, i don't care if you say [a,b] twice and you get two [a,b] elements
19:53:16 <alise> that is unimportant (although nice if it only generates one, of course)
19:54:25 <kmc> but i mean if i "dereference" each <n> in the above, i get [[a,b,[c,d,[e],f],[g,h,i],j], [c,d,[e],f], [g,h,i], [e]]
19:54:34 <kmc> which is the list of all non-leaf subtrees
19:54:46 <xplat> i think this is the one i mean: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.342
19:55:49 <alise> kmc: ah
19:55:59 <alise> interesting
20:05:07 <xplat> this sounds like a lot of annoying manual tupling would be involved but basically it would just be a redressed version of okasaki's numbering algorithm in the paper i linked
20:05:38 * sm discovers that CPP breaks haskell multiline strings
20:06:01 <kmc> sm, sounds like you need a prepreprocessor
20:06:38 <sm> what, another one ?
20:06:42 <xplat> CPPP?
20:06:53 <kmc> C pre processor and pretty printer?
20:07:23 <xplat> C pre-pre-processor.  or maybe CPPPP, CPP pre-processor
20:07:37 <kmc> no i think CPPPPP
20:07:54 <xplat> but that doesn't sound quite as much vaguely like russia as CPPP
20:07:58 <kmc> ☭
20:08:43 <Veinor> haha
20:09:26 <sm> what I'd really like to do is bake in arbitrary files into my haskell source code, and access their content at runtime
20:09:45 <kmc> could use TH
20:09:57 <benmachine> trouble with using TH is dependency analysis breaks a little
20:10:09 <benmachine> in that you don't get a recompile when the data file changes
20:10:48 <ClaudiusMaximus> sm: i wrote a tool for that, not used it much myself yet so it might need improvement: http://claudiusmaximus.goto10.org/cm/2010-08-09_binembed-0.1_released.html
20:10:58 <sm> I'm partly in retreat from TH already. yesod uses it, but it makes compilation fragile (you have to build from the right dir)
20:11:14 <sm> but it seems like it should handle this alright
20:11:27 <sm> ClaudiusMaximus:  yay! thanks I'll try it
20:11:38 <shamera> hi
20:11:40 <xplat> TH has its uses, but it's no metaml ...
20:12:36 <xplat> nor is it ocamlp4.  somewhere in the middle, kind of
20:12:51 <kmc> camlp4 lets you change concrete syntax right?
20:13:40 <xplat> yeah, it's ... pretty versatile that way
20:14:00 <xplat> for better or worse
20:14:27 <sm> it would be great if cabal could unpack from the source repo, and you could immediately start committing changes
20:16:23 <xplat> meanwhile in metaml-land they'd be like 'TH lets you generate ill-typed Haskell, right?  *pinches uvula*'
20:17:50 <kmc> my keyboard lets me generate ill-typed haskell
20:17:53 <kmc> it must be destroyed
20:19:44 <sm> ClaudiusMaximus: binembed-example fails here, I think on the c example. How do I run just the haskell one ? 
20:20:34 <sm> or is c always involved ?
20:22:25 <ClaudiusMaximus> sm: hm - how it works is generating assembler source code that includes binary files and defines some symbols
20:23:06 <ClaudiusMaximus> sm: cabal verbose build log would be handy (i've only tested it on linux x86_64)
20:24:18 <sm> I'll get that for you, one sec
20:24:33 <sm> a few issues here but this may be super-useful
20:25:23 <kmc> alise, maybe something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29889#a29889
20:26:07 <sm> ClaudiusMaximus: http://gist.github.com/574748
20:26:11 <alise> kmc: nice, but I'm not sure how that works with lists
20:26:19 <alise> right now every element is its own key, right? that can't work for this
20:26:21 <sm> this is mac osx
20:26:25 <kmc> yeah, me either
20:26:42 <kmc> well that part is not a  big deal
20:26:49 <kmc> you're flattening all but the last layer
20:26:52 <kmc> i'm flattening all of them
20:27:00 <kmc> it seemed more natural this way
20:27:16 <kmc> but i thought you meant, how to make it work with [Item] instead of [Map Key Item
20:27:45 <kmc> you could process the Map into that, but it seems less than ideal
20:27:45 <sm> ClaudiusMaximus: also http://gist.github.com/574751
20:27:48 <ClaudiusMaximus> sm: ahh, looks like the assembler you have there seems to want a completely different syntax
20:28:00 <dark> my hello world haskell script -  http://paste.pocoo.org/show/260510/ - takes a long time to exec.. ghc needs much time to start up? (is there a way to get a faster one-line script?
20:28:11 <dark> doesn't work for, say, creating a shell command (it takes ~ 0.7s to start up), but might work for batch processing..
20:28:16 <kmc> dark, compile it
20:28:17 <sm> as --version
20:28:17 <sm> FATAL:/usr/bin/../libexec/gcc/darwin/i386/as: I don't understand '-' flag!
20:28:17 <ClaudiusMaximus> sm: at around line 127
20:28:20 <sm> ook..
20:28:42 <kmc> you can make programs that transparently recompile themselves when the source changes
20:28:44 <kmc> see: xmonad, dyre
20:28:49 <dark> kmc, sounds reasonable
20:28:53 <dark> hm
20:29:02 <dark> like python's .pyc?
20:29:15 <kmc> that's something provided by the CPython interpreter
20:29:26 <dark> yes, cpython's
20:29:27 <kmc> what i describe is a feature of your program, not of GHC
20:29:57 <mjrosenb> kmc: hasn't dons not touched the dynamic loading stuff in like 4 years?
20:30:12 <kmc> mjrosenb, you mean in xmonad?
20:30:15 <kmc> or do you mean hs-plugins?
20:30:19 <mjrosenb> kmc: hs-plugins
20:30:28 <kmc> hs-plugins is deprecated, but it's not relevant to what i describe
20:30:44 <ClaudiusMaximus> sm: that's where i assume something is a file or a directory, never both or neither - so maybe symlinks screw it up?
20:30:51 <kmc> xmonad and dyre use a simpler approach which restarts the entire app
20:30:57 <kmc> there's no dynamic code loading
20:30:59 <ClaudiusMaximus> sm: not sure..
20:31:19 <mjrosenb> kmc: has there been a replacement for hs-plugins?
20:31:20 <kmc> though if you do need dynamic code loading for something, look at hint, mueval, direct-plugins, and of course the GHC API itself
20:31:22 <dark> how it's usually implemented? makefiles? (I'm reading here, it seems that the preferred way for building is using 'cabal'; i though it were just a package manager)
20:31:26 <mjrosenb> it *seems* useful
20:31:42 <kmc> dark, for small programs you can just do «ghc --make foo.hs»
20:31:50 <kmc> --make will chase the dependencies of foo and compile them
20:32:00 <kmc> if you invoke ghc manually, you should almost always pass --make
20:32:10 <mjrosenb> dark: cabal-install is a package manager, the main program is called "cabal".
20:32:11 <kmc> Makefiles are not much used with Haskell
20:32:15 <kmc> the big exception is GHC itself
20:32:23 * sm loves his Makefiles
20:32:27 <mjrosenb> kmc: and darcs, the last time i checked
20:32:29 <kmc> mjrosenb, it's more confusing than that
20:32:58 <kmc> cabal-install is a Haskell package providing a binary named "cabal".  that binary acts both as a package manager and as a make system
20:33:04 <mjrosenb> sm: i wish make were a bit more standardized
20:33:19 <sm> stick with gnu make ?
20:33:31 <mjrosenb> kmc: err, right, but you can build programs using the cabal system without cabal-install
20:33:40 <mjrosenb> sm: not useful on freebsd.
20:33:40 <kmc> Cabal is a different Haskell package providing only a Haskell library.  a package which wants to be buildable with Cabal includes a trivial Setup.[l]hs which invokes that library
20:33:42 <kmc> yeah
20:33:44 <sshc> Which module should I use to modify arrays in an ST monad?
20:33:54 <dark> it look likes ghc --make is a lot faster when calling again with the file already built..
20:34:14 <sshc> I can only find thawSTArray in GHC.Arr, which I'm not sure if I should import
20:34:16 <kmc> sshc, Data.Array.ST provides the concrete types.  Data.Array.MArray provides the overloaded API
20:34:23 <mjrosenb> dark: it does dependency checking, and doesn't rebuild things that haven't been modified
20:34:26 <dark> but a shell script will do it faster
20:34:34 <sshc> kmc: I'm looking for thawSTArray
20:34:41 <dark> (for the trivial case anyway)
20:34:41 <kmc> ah
20:34:56 <kmc> ghc --make figures out various linker shit for you
20:35:10 <sshc> Ah, freeze
20:35:14 <kmc> otherwise you need explicit -package args and maybe other stuff
20:35:46 <kmc> even with a single-file project
20:36:16 <dark> kmc, I can do something like test hm.hs -nt hm && ghc --make hm.hs
20:36:28 <kmc> ah, good idea
20:37:02 <dark> I currently have a bunch of ruby scripts that start up fast, but doesn't scale
20:38:35 <mjrosenb> kmc: doesn't runhaskell compile a source file + cache the results?
20:38:46 <dark> hmm.. really?
20:39:33 <kmc> mjrosenb, don't know.  i wasn't aware of that, but it's possible
20:40:04 <dark> no, with runhaskell, I still have ~ 0.7, 0.8s
20:41:12 <kmc> i think runhaskell uses the same bytecode interpreter as ghci and ghc -e
20:41:31 <dark> running 10 times with runhaskell gives 7.7s
20:41:34 <kmc> (assuming ghc... there's some vague idea that runhaskell is cross platform, e.g. might link to hugs)
20:41:58 <dark> what's the difference between runhaskell and runghc?
20:42:04 <dark> ah
20:42:08 <dark> hm
20:42:22 <Veinor> compilers that aren't ghc exist?
20:42:23 <Veinor> how crazy!
20:42:42 <kmc> ;P
20:42:58 <dark> actually, I don't know a compiler other than ghc
20:44:03 <kmc> ghc, uhc, jhc, yhc, lhc
20:44:08 <sm> ClaudiusMaximus: I just figured out the .binembed file is a list of files, and successfully embedded stuff into a .hs
20:44:17 <sm> awesome, thank you!
20:44:31 <kmc> old: nhc98, hbc
20:45:37 <adnap> Has anyone ever used DevIL for images?  Apparently it's not portable because it uses Data.Array.IArray.  What is the best library to use that's portable?
20:46:03 <kmc> adnap, "not portable" meaning "not guaranteed to work on implementations other than GHC"
20:46:04 <kmc> most likely
20:46:14 <kmc> do you care about that?
20:46:43 <adnap> Oh, no.
20:47:40 <adnap> However, I have a problem.  DevIL reads images into UArray, which is supposed to be in Data.Array.Unboxed, but when I import it, it still says the data constructor is not in scope.
20:49:18 <kmc> you can't get at the data constructor, only the type constructor
20:49:21 <kmc> it's an abstract type
20:50:36 <Olathe> Is there a way to create a lazy, infinite list if I can only add to the part that's come so far (before ++ [x] or something) rather than adding to the end (this:after)?
20:51:23 <kmc> not sure what you mean, (:) adds an element to the beginning
20:54:40 <xplat> Olathe: you always have to build a lazy list from the left, if you built it from the right you could never reach any elements
20:54:53 <xplat> (a lazy infinite list anyway)
20:55:37 <Olathe> I'm trying to get http://codepad.org/72eNoszn to work.
20:56:16 <Olathe> I don't know how to build it from the left with that.
21:00:18 <xplat> Olathe: what is it for?
21:00:49 <dark> can ghc receive code from stdin?
21:01:32 <sm> or did I speak too soon. I did, I spoke too soon.
21:02:15 <Olathe> I'm trying to get a game monad going where I take an input list of game states and I must produce an output list of moves in the same order (first move to last) as the input list.
21:02:56 <Olathe> I can't use reverse because I can only get the next game state when I produce the previous move.
21:03:10 <Olathe> So, I need it to work essentially like map.
21:05:55 <xplat> it just sounds like a left fold
21:06:28 <xplat> well, sort of
21:07:34 <Olathe> It seems like that's all I can get with a monad.
21:09:03 <xplat> i'm trying to figure out where you got that monad structure of a state monad with the state being (Maybe [a], [b]).  is there a special significance to that choice?
21:10:39 <Olathe> Yeah, [a] is input, [b] is output, and Maybe is there because I terminate early on reading from an empty list.
21:10:51 <sm> ClaudiusMaximus: I imagined base64-encoding file contents into a hs file. You're using assembler for cross-language support, is that right ?
21:11:51 <Olathe> So, if I have [] remaining, that's great until I try to read from it. But >>= needs to know when to terminate, so I can't use [].
21:12:31 <Olathe> When I try to read from [], I change it to Nothing to signify to >>= that it can quit.
21:15:25 <xplat> Olathe: have you tried using the shows trick on the output?
21:15:34 <Olathe> Yeah.
21:15:49 <Olathe> I think, though, that it can't work.
21:16:02 <Olathe> I mean what I'm trying, not ShowS.
21:16:10 <xplat> still breaks when it's a [b] -> [b]?
21:16:19 <Olathe> Yeah, that's what I had before.
21:16:49 <Olathe> It will go (((((((((earliest) next) ... last)
21:17:10 <xplat> hm, yeah, that can't work
21:19:55 <ferret_0567_> hello
21:20:08 <ferret_0567_> How do I define a new variable mid-function?
21:20:33 <ferret_0567_> I need the ability to not have to declare all variables at the beginning of my function
21:21:06 <ferret_0567_> or, at least add one to a preexisting variable
21:21:34 <kmc> ferret_0567_, maybe what you want is "let"
21:22:21 <ferret_0567_> err...so if ... then let bx = ...?
21:22:24 <xplat> Olathe: there's got to be some way to tie the knot there, perhaps supporting 'put' directly in bind somehow, but i am too tired to draw that many diagrams at the moment
21:22:48 <Olathe> xplat: Ahh, that might work.
21:22:53 <Olathe> Let's see.
21:28:02 <xplat> and of course it's often less ... 'eventful' to test these things using something like take 10 $ mmap f $ 1:2:3:4:undefined 
21:29:22 <xplat> if it's properly lazy it will never touch the undefined at the tail of the list before producing the 10 elements, otherwise it will
21:30:55 <xplat> rather than a bunch of runtime options to make it blow up more quietly in the infinite case
21:35:32 <Olathe> Ahh, that's true.
21:38:42 <Olathe> > take 5 . foldr (++) "" . repeat $ "a"
21:38:43 <lambdabot>   "aaaaa"
21:39:53 <dark> to whoever it may concern: in the env I got two approaches: http://paste.pocoo.org/show/260516/ and http://paste.pocoo.org/show/260517/ together with http://paste.pocoo.org/show/260518/
21:41:03 <ferret_0567_> I sure hope this is valid: factorPt2 a b c =
21:41:04 <ferret_0567_> if....
21:41:11 <ferret_0567_> <more code>
21:42:43 <dark> ferret_0567_, maybe you got some indentation problem?
21:43:04 <dark> I don't quite understand the layout rules of haskell
21:47:06 <dark> http://en.wikibooks.org/wiki/Haskell/Indentation
21:49:13 <ferret_0567_> how does this look dark? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29890#a29890
21:50:35 <dark> the 'then' needs to be in another level.. i think
21:50:48 <dark> actually not
21:51:12 <ferret_0567_> do you like it?
21:51:37 <dark> :t aminusb
21:51:38 <lambdabot> Not in scope: `aminusb'
21:51:58 <ferret_0567_> dark, that is a variable
21:52:22 <ferret_0567_> dark: or a function that acts like a variable, depending on how you look at it
21:52:25 <ddarius> ferret_0567_: You are missing an 'in'
21:53:32 <ferret_0567_> fixed
21:53:38 <ferret_0567_> thank you ddarius
21:53:48 <dark> ferret_0567_, I don't know haskell. But it does not feel, err.. "elegant", if you ask me
21:54:14 <Veinor> yeah, that doesn't look good
21:55:48 <dark> (it's actually 'familiar' to me, since it's almost a 1-1 translation from the corresponding ocaml code. but reading lyah, i'm trying to see if eg. it would be better to put that constraint in a where clause, etc)
22:04:39 <megajosh2> Is (->) actually defined somewhere in a way that you could manipulate it in your own Haskell code?
22:04:49 <megajosh2> Like add it to some class you made?
22:05:22 <dark> :t (->)
22:05:23 <lambdabot> parse error on input `->'
22:05:24 <Cale> You can write an instance of a typeclass for it
22:05:31 <Cale> It's built in though
22:05:33 <megajosh2> Oh, okay
22:05:35 <dark> -> looks like part of syntax
22:05:40 <Cale> But otherwise it's like any other type constructor
22:05:51 <djahandarie> :k (->)
22:05:52 <lambdabot> ?? -> ? -> *
22:06:09 <dark> :help k
22:06:09 <djahandarie> :k Either
22:06:10 <lambdabot> * -> * -> *
22:07:16 <dark> it's not the -> at \x -> a, right?
22:07:18 <Cale> :k Integer
22:07:19 <lambdabot> *
22:07:22 <Cale> :k Maybe
22:07:22 <lambdabot> * -> *
22:07:27 <Cale> :k Maybe Integer
22:07:28 <lambdabot> *
22:07:35 <Cale> :k Either Integer
22:07:36 <lambdabot> * -> *
22:07:38 <Cale> :k Either Integer Bool
22:07:38 <lambdabot> *
22:07:42 <augur> heyo
22:07:51 <dark> I saw something like an -> at monad code
22:08:48 <Cale> There's the -> in lambdas, it's also part of the syntax of case expressions, but at the type level, it's an infix type constructor
22:09:29 <dolio> Also view patterns.
22:09:30 <dark> so the type a -> b is (->) a b..?
22:09:32 <ddarius> :k (->) Int
22:09:33 <lambdabot> ? -> *
22:09:49 <ddarius> dark: Yes.
22:09:59 <dark> illuminating
22:10:44 <ddarius> The syntactic rules of the type level are pretty much identical to the syntactic rules of the value level (modulo a few omissions some of which are added back by extensions.)
22:11:10 <dark> so there is the type a + b that is (+) a b for some type class (+)?
22:11:29 <megajosh2> Hmm... what do ?s mean in a kind signature?
22:11:29 <dark> or type constructor. (I'm a bit confused)
22:11:39 <dolio> + isn't a type constructor.
22:11:47 <ddarius> megajosh2: It some GHC magic relating to unboxed types.
22:11:48 <dark> could the user define it?
22:11:56 <dolio> It's a variable.
22:12:22 <Cale> Yeah, it would have to be a type variable at the type level. You could define :+ as a type constructor though
22:13:28 <dark> Illegal operator `+' in type `Int + Int' Use -XTypeOperators to allow operators in types
22:13:28 <Cale> -> gets special treatment as a built-in, ordinarily infix type and data constructors have to start with :
22:13:45 <dolio> Yes, it requires that extension.
22:14:32 <dark> super cool
22:15:20 <ddarius> Kids are so easy to impress nowadays.
22:15:46 <dark> haha :)
22:29:45 <ddarius> "Agda fails to forbid them but that does not mean that they make sense."
22:30:21 <dolio> That sounds familiar.
22:31:16 <tkahn6> how would I parse something like "2010-08-24T16:07:01+0000" into some sort of time format in Haskell?
22:31:38 <kmc> :t x :: Int + Int; x = undefined
22:31:39 <lambdabot> parse error on input `;'
22:31:44 <kmc> :t let x :: Int + Int; x = undefined in x
22:31:44 <dolio> It's conceivable that something in Data.Time can do that.
22:31:44 <lambdabot> forall (+ :: * -> * -> *). (+) Int Int
22:31:48 <tkahn6> i tried read "2010-08-24T16:07:01+0000" :: UTCTime but i get a parse error
22:32:16 <dolio> Realistically, you probably have to parse it yourself.
22:32:33 <kmc> http://hackage.haskell.org/package/strptime ?
22:32:46 <tkahn6> kmc: i'll check that out
22:33:22 <kmc> also http://hackage.haskell.org/package/datetime
22:33:32 <kmc> date/time handling is one area where the std lib is lacking
22:35:09 <poly> Is there any way that I can input key I typed from stdin to my program without pushing enter?
22:35:28 <dolio> Turn off buffering.
22:35:58 <poly> I tried "hSetBuffering stdin NoBuffering"
22:36:10 <poly> but it does not work
22:36:20 <kmc> poly, requires a system-dependent hack
22:36:22 <kmc> poly, are you on unix?
22:36:28 <poly> windows
22:36:35 <kmc> don't know then
22:36:57 <kmc> anyway maybe you can use hscurses or vty
22:37:12 <kmc> or terminfo
22:37:34 <poly> ok, I will check that
22:37:53 <kmc> the simple hack on unix is to run the command "stty raw" first
22:38:37 <tkahn6> thanks kmc
22:38:39 <tkahn6> strptime "%Y-%m-%dT%T%z" "2010-08-24T16:07:01+0000"
22:38:48 <tkahn6> very simple
22:38:49 <tkahn6> :)
22:39:03 <dark> :t strptime
22:39:04 <lambdabot> Not in scope: `strptime'
22:39:12 <tkahn6> it's in Data.Time.Parse
22:39:20 <tkahn6> which is in the cabal package, strptime
22:39:30 <dark> nice:)
22:39:38 <dark> :t Data.Time.Parse.strptime
22:39:39 <lambdabot> Couldn't find qualified module.
22:39:54 <Mitar> is there a way to name some complex type shorter?
22:40:03 <Zao> type Asdf = ...
22:40:23 <Mitar> complex like in complex type ...
22:40:24 <Zao> @src String
22:40:24 <lambdabot> type String = [Char]
22:40:31 <Mitar> data Foo :: * -> * -> * -> * -> * -> * -> * where
22:40:57 <Mitar> and now i have to write everywhere Foo a b c d e f
22:41:04 <Mitar> which is not really nice ;-)
22:42:02 <kmc> you've made a 6-parameter GADT?
22:42:09 <dark> GADT?
22:42:25 <dark> g. abstract data type
22:42:40 <kmc> generalized algebraic data type
22:43:03 <dark> reading http://en.wikibooks.org/wiki/Haskell/GADT
22:43:26 <Mitar> yes ;-)
22:43:44 <Mitar> and it is ugly to use that as a type in functions
22:44:22 <kmc> why do you need 6 parameters?
22:44:38 <Mitar> http://www.haskell.org/pipermail/haskell-cafe/2010-September/083518.html
22:44:43 <Mitar> i send to haskell caffe
22:44:57 <Mitar> if you can make it with less, i would be more then glad to hear about that ;-)
22:46:29 <Mitar> so one stores type of values in a channel, the other if channel exists, then channel type itself, and all this twice
22:46:41 <Mitar> the result is this ugliness
22:49:47 <dark> in the original question: "so I am turning to infinite (lazy) wisdom of Haskell Cafe.", :)
22:51:12 <ddarius> Quick!  Give the full dependent type of composition.
22:51:29 <atude> mx+b^2!
22:51:30 <dark> what?
22:51:45 <dark> :t (.)
22:51:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:53:31 <dolio> (A : Set) (B : A -> Set) (C : (x : A) -> B x -> Set) (g : {x : A} -> (w : B x) -> C x w) (f : (x : A) -> B x) (x : A) -> C x (f x)
22:53:39 <dolio> I think that's right.
22:53:54 <dark> "composition"?
22:54:19 <kmc> dark, function composition, in a dependently-typed language
22:55:47 <kmc> on an unrelated note, pattern guards are the shit
22:55:50 <dark> now it's something i don't understand. what's the problem of haskell's type? it's too broad, i.e. there are other functions with the same type which aren't the composition?
22:56:04 <kmc> i'm implementing some operational semantics
22:56:20 <dolio> You mean the type lambdabot gave?
22:56:23 <kmc> and pattern guards let me express all the "side conditions" really nicely
22:56:29 <dolio> In lambdabot, (.) = fmap.
22:56:38 <dark> < the other thing i don't understand is this operational vs. denational vs. something else semantics >
22:56:40 <kmc> dark, in Haskell's type system, the type returned by a function can't depend on the *value* passed in
22:56:43 <dolio> > succ . [1,2,3] -- so you can write this
22:56:44 <lambdabot>   [2,3,4]
22:56:46 <kmc> dark, so composition is rather simple
22:57:09 <kmc> dark, in dependently typed languages, i can make, say a function that takes an int n and returns a n-tuple
22:57:19 <kmc> thus the result type depends on the value input
22:57:33 <kmc> and the type dolio gave is the one you want for composing such functions with full generality
22:58:10 <dark> hmm
22:58:13 <kmc> dark, www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf is a great introduction
22:58:20 <kmc> if you know Haskell, Agda should feel familiar
22:58:28 <kmc> like Haskell with super powers
22:58:39 <dark> I don't know haskell
22:58:55 <dark> and I read about agda before, but this doesn't mean I understood..
22:59:13 <kmc> dark, as to your other question, it's actually really hard to write a function of type (b → c) → (a → b) → (a → c) which *isn't* function composition
22:59:14 <dark> actually, this same paper :)
22:59:31 <kmc> other than by cheating and using "undefined" or similar
22:59:34 <dolio> It isn't hard in Haskell.
22:59:38 <dolio> Yeah.
22:59:43 <kmc> because your function must work on *all* types a,b,c
22:59:47 <kmc> so you can't inspect or make up values of those types
23:00:16 <kmc> @djinn (b -> c) -> (a -> b) -> (a -> c)
23:00:16 <lambdabot> f a b c = a (b c)
23:02:00 <kmc> dark, wikipedia has decent definitions of denotational vs. operational semantics
23:02:23 <kmc> basically, the former involves describing how bits of your program "stand for" (denote) mathematical objects
23:02:32 <kmc> like the code «λx. x» stands for the mathematical identity function
23:02:48 <kmc> operational semantics involves describing how bits of your program change the state of an abstract machine
23:06:12 <dolio> There's lots of other types of semantics, which may or may not be special cases of one another.
23:06:19 <dolio> Axiomatic, algebraic, categorical...
23:06:36 <dark> the thing I associate with adga is having a type with some constraints so that I can't build an invalid value of it. if my constraint is actually the specification, then any implementation is correct
23:13:58 <dolio> Type checking is like proving things about your program. Dependent types allow the types (propositions) to mention the value level, so it's like having adding in first-order predicate logic.
23:16:57 <copumpkin> dark: that's a big part of it, but you sort of get that in haskell too with GADTs, in a much less powerful way
23:17:03 <copumpkin> dark: there's a lot more to it though :)
23:17:43 <dark> (.. for some reason, this is what I associate with monads, type classes, phantom types, etc. too. I think it was some tutorial I read with a lock mechanism where the lock function received a "free" lock and returned a "busy" lock, and it had something to do with monads)
23:18:24 <dark> it was an ocaml tutorial, but i suppose that's what you refer
23:19:29 <dark> dolio, why do you say 'first order'? to have 'second order', one would need to have a more general type-2 as type of the more familiar type-1?
23:20:03 <dolio> In first-order logic, you get to quantify over particulars.
23:20:10 <tkahn6> not sets
23:20:16 <dolio> So, like, forall x : Natural. ...
23:20:19 <tkahn6> (by which he means particulars)
23:20:42 <dolio> Second-order is quantification over sets of particulars, and so on, I believe.
23:21:06 <copumpkin> does haskell not propagate type information from one pattern to another in the same matc?
23:21:08 <dolio> Haskell already has higher-than-first-order quantification via quantification over types.
23:21:20 <tkahn6> yeah and to avoid Russel's paradox, higher orders can only refer to lower orders, not their own orders
23:21:22 <copumpkin> (for GADTs)
23:22:01 <tkahn6> so in third order logic you can have a set of all second order sets
23:22:18 <tkahn6> but not the set of all third order sets which do not contain themselves as members
23:22:23 <copumpkin> so what would agda with universe polymorphism count as?
23:24:01 <tkahn6> sorry, it would make more sense to say:
23:24:18 <dolio> As far as something Haskell-like goes, quantification over * is second-order, over * -> * is third-order, (* -> *) -> * is fourth-order, etc.
23:24:28 <tkahn6> so in third order logic you can have a set of all second order sets which do not contain themselves as members but not the set of all third order sets which do not contain themselves as members
23:24:39 <ddarius> "A mistake becomes deliberate when you decide to keep it in your paper."
23:25:03 <dolio> Universe polymorphism is kind of a different animal.
23:25:04 <dark> s/paper/code/ too
23:25:28 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29896#a29896
23:25:47 <copumpkin> I guess the pattern is possible if someone passes bottom in
23:26:02 <copumpkin> but in that case I wouldn't be able to match with Fz anyway
23:26:54 <ddarius> I suspect GHC's exhaustiveness checking is far from perfect for these GADT cases.
23:27:17 <dolio> I don't think it makes any effort to deal with GADTs.
23:27:39 <copumpkin> well, I only say it because I noticed yesterday that it prevents impossible GADT patterns based on the original type
23:27:45 <copumpkin> not sure when that was added
23:27:53 <copumpkin> but I guess it's not based on refined types from other matches
23:28:00 <dolio> Oh, I guess it does make effort.
23:28:19 <dark> newtype Ns n = Ns n?
23:28:56 <copumpkin> for example
23:28:56 <copumpkin> test :: Fin Nz -> a
23:28:56 <copumpkin> test Fz = undefined
23:29:03 <copumpkin> it won't let me even write that 
23:29:19 <copumpkin>     Couldn't match expected type `Ns n' against inferred type `Nz'
23:30:01 <dolio> Oh, I see what you're saying.
23:30:14 <dolio> Yes, that one case is weird.
23:30:40 <dolio> It should refine n to two incompatible constructors.
23:30:47 <copumpkin> yeah
23:30:55 <copumpkin> I'm sure they're already aware that the coverage checker is a little sketchy
23:31:02 <copumpkin> I wonder if it's worth submitting this case
23:31:23 <dark> what about index (Cons x xs) (Fz n)?
23:31:32 <copumpkin> Fz takes no parameters
23:31:37 <dark> i mean index (Cons x xs) Fz
23:31:42 <dark> ah
23:31:45 <copumpkin> that's a legitimate case
23:31:55 <dark> it's covered by the previous entry
23:32:01 <ddarius> "Comprehension of de Bruijn syntax is often proposed as a reverse Turing test.  I sometimes find this worrying."
23:32:28 <Veinor> 0ahaha
23:33:00 <tkahn6> http://xkcd.com/329/
23:33:31 <dark> well Nil is a Vec n a for all n and a. Fz is a Fin n for some n. right copumpkin?
23:34:00 <copumpkin> Nil is a Vec n a for n = Nz and that's it
23:34:17 <copumpkin> Fz is a Fin n for all n > 0
23:35:19 <dark> ah
23:36:40 <dolio> Looks like the second argument overrides the first.
23:38:14 <copumpkin> how so?
23:38:27 <dolio> foo :: Vec n a -> Fin n -> (Vec n a, Fin n) ; foo Nil Fz = (Nil, Fz)
23:38:36 <dolio> That gives a type error on Nil, I think.
23:38:54 <copumpkin> oh, interesting
23:39:01 <dolio> It has to pick one.
23:39:46 <dolio> The thing is, even if you report it, they're rewriting the whole type checker for the next version.
23:40:00 <copumpkin> yeah
23:40:12 <copumpkin> I asked in GHC whether they think it's worthwhile
23:40:35 <dolio> I guess it'd be a decent test for the new checker.
23:41:53 <copumpkin> oh
23:41:56 <copumpkin> he already has a ticket for it
23:41:57 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3927
23:43:00 <dark> copumpkin, so provide a comment with your test case too =)
23:43:32 <copumpkin> pretty sure my case is covered by the f1 there, but I'll add myself to the cc list :)
23:43:50 <copumpkin> and maybe attach some code for fun, in case they want a more tangible case :P
23:44:29 <dolio> I'm not surprised the coverage checker doesn't catch it, but it's weird that both those matches are allowed.
23:44:45 <dolio> Or, exhaustiveness checker, that is.
23:46:41 <dolio> I'd expect that case to generate a type error, even if the compiler still complains about non-exhaustive cases.
23:47:06 <copumpkin> yeah
23:50:20 <adnap> Is there a better way to do this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29898#a29898
23:54:11 <dark> adnap, is it the discrete convolution?
23:55:02 <adnap> dark: Yes, a 1-D discrete convolution.
23:56:33 <dark> it seems that the 3th equation at http://en.wikipedia.org/wiki/Convolution#Discrete_convolution describes a simpler approach
23:57:06 <dark> but one would need to know the length of the (smallest?) list
23:57:50 <dark> actually, no, ..
23:58:46 <adnap> I think I assume that the second list is smaller or of equal size in relation to the first.
23:59:09 <dark> I'm impressed that code isn't calculating such sum explicitly..
23:59:15 <dark> such length
23:59:40 <adnap> dark: zip takes care of it.
