00:00:03 <mm_freak> ski: mine is the sieve of eratosthenes
00:03:30 <Jafet> Is there an atkin sieve?
00:04:28 * hackagebot cryptohash 0.5.3 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.5.3 (VincentHanquez)
00:07:10 <kmc> "fast, pure, practical" sounds like one of those "pick 2" things
00:07:16 <kmc> with "pure" corresponding to "good" and "practical" to "cheap
00:08:07 <Jafet> Cheap and fast?
00:11:13 <mjrosenb> C++ is cheap and fast just like the girls on the corner in the seedy part of town.
00:11:48 <xscroll> wow, I never thought of it that way.  haskell is like my wife
00:12:12 <xscroll> something you want to stick with a long time, but hard to get through at times
00:12:33 <cizra> C++ ain't cheap, C might be
00:12:50 <cizra> C++ is more like a runaway from an insane asylum
00:13:01 <mjrosenb> cizra: C++ programmers are a dime a dozen.
00:13:24 <cizra> mjrosenb: Oh, that. O'er here where I am, that description fits Java programmers better.
00:13:25 <mjrosenb> cizra: C programmers actually need to know what they're doing
00:13:26 <kmc> C++ can be cheap and fast, or it can be a language where "x = y;" involves network I/O and XML serialization
00:13:40 <kmc> C++ programmers *really* need to know what they're doing, but so few do
00:13:59 <cizra> *nod*
00:14:04 <kmc> it makes C look just enough like Java to make you think you can fake it
00:14:19 <kmc> then it punches you in the balls, repeatedly
00:15:41 <mjrosenb> kmc: well keep in mind that most C++ programmers are C programmers that use vectors instead of arrays and references instead of pointers.
00:16:01 <kmc> nah they'll use vectors on the even-numbered code lines and arrays on the odd-numbered lines
00:16:18 <mjrosenb> kmc: you ever find a solution to that path problem?
00:16:28 <kmc> i still maintain that C++ is a brilliant esolang and the joke is lost on almost everyone
00:16:40 <kmc> mjrosenb, yeah, it's called the "chinese postman problem" and i found some references
00:16:53 <kmc> weirdly enough a friend of mine learned about it just today in combinatorics class
00:18:50 <kmc> from an undirected graph G: make an auxiliary graph H whose vertices are the odd-degree vertices of G, whose edges are weighted by the shortest path distance between those vertices
00:19:12 <kmc> (we assume G is connected, so H is complete)
00:19:45 <kmc> then find a minimum weight matching in H
00:20:04 <kmc> the corresponding paths in G are precisely those you duplicate
00:33:04 <Kaidelong> hey
00:33:19 <Kaidelong> does Haskell have any standard library equivalents to F#'s "pairwise" and "window"?
00:34:20 <Kaidelong> pairwise would be pairwise x = x -> case x of {(x:y:xs) -> (x,y) : pairwise xs; _ -> []}
00:34:36 <Kaidelong> pairwise would be pairwise x = case x of {(x:y:xs) -> (x,y) : pairwise xs; _ -> []}
00:34:40 <Kaidelong> (sorry)
00:34:43 <ddarius> No.
00:34:54 <Kaidelong> ok
00:35:10 <Kaidelong> well I guess I'll write them down myself then, shame they aren't standard
00:36:27 <Maxdamantus> It retuns a tuple or a list?
00:36:36 <Maxdamantus> Oh, nvm
00:37:18 <retronym_> hoogle isn't helping me, so perhaps someone here can. I'm looking for: Tree a -> ([b] -> a -> b) -> Tree b
00:37:21 <Kaidelong> > let pairwise x = case x of {(x:y:xs) -> (x,y) : pairwise xs; _ -> []} in pairwise [1..10]
00:37:23 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
00:37:29 <Kaidelong> err that's wrong
00:37:38 <Kaidelong> > let pairwise x = case x of {(x:y:xs) -> (x,y) : pairwise (y:xs); _ -> []} in pairwise [1..10]
00:37:39 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
00:42:45 <koninkje> > let pairwise xs = zip xs (tail xs) in pairwise [1..10]
00:42:45 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
00:45:32 <Maxdamantus> > let pairwise = ap zip tail in pairwise [1..10]
00:45:33 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
00:46:05 * koninkje keeps forgetting that the S combinator has a common name
00:47:19 <kmc> :t ap (==) reverse
00:47:20 <lambdabot> forall a. (Eq a) => [a] -> Bool
00:49:00 <Maxdamantus> > (ap (==) reverse) "rats live on no evil star"
00:49:01 <lambdabot>   True
01:21:03 <cch> :t (=)
01:21:04 <lambdabot> parse error on input `='
01:21:11 <cch> :t (==)
01:21:12 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:49:33 <kowey> is there a GHC policy page on supported platforms?
01:50:47 <kowey> for example, the Tahoe-LAFS team have one which basically consists of "iff we have a buildslave with green lights, we support it"
01:51:41 <siracusa> kowey: You mean this? http://hackage.haskell.org/trac/ghc/wiki/Platforms
01:53:02 <kowey> yes! thanks! (lack of Darcs support on *BSD/sparc64 due to lack of GHC support enough of a problem for the Tahoe-LAFS team for them to contemplate switching)
01:53:27 <kowey> I've been scratching my head on how to get this problem unstuck
02:01:09 * hackagebot uu-parsinglib 2.5.5.1 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.5.1 (DoaitseSwierstra)
02:07:33 <kowey> does Ben Lippmeier hang out on IRC?
02:09:37 <tab> kmc: i welcome better suggestion :)
02:09:50 <tab> kmc: for the description you were talking about
03:03:30 * hackagebot pointless-haskell 0.0.5 - Pointless Haskell library  http://hackage.haskell.org/package/pointless-haskell-0.0.5 (HugoPacheco)
03:10:32 * hackagebot pointless-lenses 0.0.6 - Pointless Lenses library  http://hackage.haskell.org/package/pointless-lenses-0.0.6 (HugoPacheco)
03:12:20 <ivanm> @. elite protontorpedo
03:12:20 <lambdabot> W|-|era r3 7hE 3ND Uzer app5?
03:16:29 <tomberek> ivanm: hello
03:17:24 <ivanm> hey tomberek 
03:18:20 <tomberek> ivanm: i know you still want basic class-work hashed out, but I've been playing with and got some interesting newtype extentions and bfs/dfs
03:18:34 <ivanm> fair enough
03:18:50 <tomberek> just to see what was easy and what's not
03:19:03 <tomberek> ivanm: but what else do you want to hash out with the basic classes?
03:21:13 <tomberek> atm i've got Graph (with EdgeIndex,EdgeLabel,NodeIndex,NodeLabel) , InGraph with things like labEdgesIn and source, OutGraph with labEdgesOut and target.  UndirectedGraph with associatedNodes :: g -> NodeIndex -> [Node g].... MutableGraph with all the insert and remove, Inductive which has many Context based functions, and mappable, which uses context style mapping
03:22:14 <ivanm> *sigh* seriously, now is not a good time ;-)
03:22:21 <tomberek> arg
03:23:49 <ivanm> but my plans were something like: GraphLike(edges, nodes); GraphLike => DecomposableGraph(delEdge, delNode); GraphLike => ComposableGraph(addEdge, addNode); Decomposable/ComposableGraph => Graph(empty, mkGraph)
03:24:21 <ivanm> possibly with some more splits (how about graphs that only _might_ accept edges or nodes? or ones that will delete edges but not nodes?)
03:26:05 <tomberek> ivanm:  ok, that looks like it's just splitting my MutableGraph into two
03:26:20 <ivanm> right, since some graphs might easily decompose but not compose
03:26:24 <ivanm> or vice versa
03:26:52 <ivanm> you can then have extra things on top of that: Graph => OrientedGraph(isDirected, makeUndirected), etc.
03:28:22 <tomberek> ivanm: ok, I'll add that distinction of de/composable.         Oriented I have already (the InGraph/OutGraph split) and makeUndirected is UndirectedGraph (it's a way to look at any graph as undirected)
03:28:51 <ivanm> no, oriented is whether or not you can tell if a graph is directed or undirected
03:29:11 <ivanm> and makeUndirected should double up edges _that aren't already doubled_ for such graphs
03:29:18 <ivanm> so you'd probably need constraints on labels
03:29:25 <ivanm> (Eq at the very least)
03:29:35 <ivanm> (though that's a per-instance thing)
03:29:54 <tomberek> ivanm: is that important? a graph being a part of InGraph/OutGraph is directed, and both directed and undirected graphs are part of UndirectedGraph
03:30:10 <ivanm> my current preference is to have as few restrictions as possible on the class, so if a default definition needs a restriction then split that out into a separate function that people can use for their instances
03:30:25 <ivanm> tomberek: yes; I'd like to be able to detect if a graph is directed or not
03:30:30 <ivanm> and what's In/Out Graph?
03:30:44 <ivanm> "get me all the out edges" kind of thing?
03:31:16 <tomberek> ivanm: InGraph (source, labEdgesIn,  things like FGL's pre)  OutGraph (target,labEdgesOut, things like FGL's suc)
03:31:42 <ivanm> I think that's an arbitrary and useless distinction tbh
03:31:48 <ivanm> unless you want to be able to cater to infinite graphs
03:31:55 <ivanm> (which I don't really see the point of)
03:31:57 <tomberek> because usually one is easier than the other... and bfs only needs one
03:32:31 <ivanm> if you can do one, you can do the other
03:32:40 <ivanm> admittedly probably not efficiently, but still...
03:32:48 <tomberek> that's the point
03:32:52 <tomberek> because usually one is easier than the other... and bfs only needs one
03:32:59 <tomberek> same with dfs and others
03:33:41 <tomberek> it splits the idea of traversing a graph into upstream/downstream,,, both imply half of "directed graph"
03:34:44 <tomberek> it makes transposing the graph easy with a newtype Transpose
03:36:14 <ivanm> so what, for bfs you arbitrarily pick one?
03:38:13 <tomberek> i actually really like splitting Directed into In/OutGraph, And if something is an instance of both, and undirected view of the graph is easy... associatedNodes g n = labNodesOut g n ++ labNodesIn g n
03:38:30 <ivanm> well, we can do that as the per-node lookup stuff
03:38:45 <ivanm> and associatedNodes is a little trickier (hint: loops)
03:38:55 <ivanm> In/Out are poor name choices IMHO though ;-)
03:43:03 <tomberek> dang, got disconnected
03:45:06 <tomberek> ivanm: i'm ok with different names.... yes, I thought about the loop issue.  I couldn't solve that at the type level.  So either we leave that to implementor, or provide a NoLoops newtype that adds the required checks (i have one already)
03:45:46 <ivanm> tomberek: if you have defaults, you can test for that
03:45:58 <ivanm> another reason why default implementations should not be part of the class proper
03:47:24 <tomberek> ivam: i thought I'd leave those additional checks as seperate, same with the NoParallel.     As to the usage of defaults, I don't know what is the proper thing, I think I use them so much as a carryover from OO inheritance.
03:48:02 <tomberek> ivanm: they are nice to cut down on boilerplate code though
03:49:44 <tomberek> i currently provide defaults like:   edgesOut = map index . labEdgesOut
03:49:57 <tomberek> edgesOut = map index ... labEdgesOut
03:50:17 <tomberek> er.. the first one
03:51:48 <ivanm> I mean for things like isDirected: I have an implementation for arbitrary FGL graphs that should be portable to _any_ graph... if the edge label is an instance of Ord
03:52:01 <ivanm> however, some graph types might be able to tell (by construction) if a graph is directed or not
03:52:13 <ivanm> so forcing that restriction for all graph types is wasteful
03:53:41 <tomberek> ivanm: i just don't see the point of isDirected, reminds me of Java.  It's like asking an object about itself.  I agree that Eq (NodeIndex g) and Eq (EdgeIndex g) is enough
03:56:46 <ivanm> *sigh*
03:57:24 <ivanm> how do you think this works? http://hackage.haskell.org/packages/archive/graphviz/2999.10.0.1/doc/html/Data-GraphViz.html#v:setDirectedness
03:57:49 <ivanm> and wtf is this "EdgeIndex" stuff?
03:59:15 <tomberek> ivanm: i'm not saying we shouldn't have it, but it seems like the typclass should be able to handle it.   I mean, do we have functions like    isNum? or isOrd?
03:59:28 <lucca> heh, I've only used Text.Dot.
03:59:50 <ivanm> the whole point of OrientedGraph _is_ isDirected, which returns whether or not a particular graph is directed or undirected!
04:00:07 * ski idly wonders why `setDirectedness' is in CPS
04:00:30 <ivanm> lucca: I've actually considered copying that interface into graphviz... ;-)
04:00:47 <ivanm> ski: CPS?
04:00:50 <lucca> it works...
04:00:56 <lucca> anyway, good night~
04:01:06 <ski>   setDirectedness :: (Ord el, Graph gr) => (GraphvizParams nl el cl l -> gr nl el -> a) -> GraphvizParams nl el cl l -> gr nl el -> a
04:01:19 <quicksilver> tomberek: you don't have a function 'isNum' because you don't expect to take a variable which might or might not be a number.
04:01:25 <tomberek> ivanm: Edge g = (EdgeIndex g,EdgeLabel g)  same as Node g = (NodeIndex g,NodeLabel g)              ok, we can include a "isDirected", it won't be hard
04:01:29 <ivanm> ski: what's wrong with that?
04:01:30 <quicksilver> but it's perfectly reasonable to take a graph which might or might not be directed.
04:01:36 <ski> the first argument is a continuation, returning a result of type `a', which is what the whole operation also returns
04:01:53 <ivanm> tomberek: why not just have Edge = (Node g, Node g) ?
04:01:57 <ski> ivanm : there's not necessarily anything wrong with it. i was just wondering why
04:02:01 <tomberek> quicksilver: not if you are being typesafe instead... if you have a typeclass DirectedGraph,, then the types won't check
04:02:08 <ivanm> and I prefer LNode or LabelledNode g = (Node g, NodeLabel g)
04:02:24 <ivanm> ski: so I can do something like: setDirectedness params graph
04:02:29 <quicksilver> tomberek: but you might want them to check!
04:02:43 <quicksilver> tomberek: it's perfectly valid to have a function which takes a graph (Which might or might not be directed)
04:02:48 <quicksilver> and then check if it is, or not.
04:02:49 <ivanm> no, wait, that's wrong
04:02:50 <tomberek> ivanm:  that's fine too.. it doesn't matter, i just renamed LabelledNode -> Node and Node -> NodeIndex,,  that's not a problem
04:03:03 <ivanm> setDirectedness dotizeGraph params graph
04:03:22 <ivanm> ski: ^^ the alternative would have been: dotizeGraph (setDirectedness params graph) graph
04:03:27 <tomberek> well, i'm not against including an isDirected
04:03:30 <ivanm> and I find it nicer to only specify graph once
04:04:04 <ivanm> tomberek: once again: I think it makes a lot more sense to split up classes based upon "what can we do with this type, and what information can we get from it?"
04:05:18 <tomberek> ok, I like the de/composable split.   do you like the In/OutGraph split?  because those seem to be subsets of Directed
04:05:23 <ski> ivan : the latter makes it clear that the same graph is passed to both operations
04:05:34 <ivanm> tomberek: we can do that
04:06:03 <ivanm> ski: *shrug* I just happen to like that function composition/transformation style
04:06:08 <ski> ok
04:06:19 <ivanm> to avoid having to pass the graph twice
04:06:37 <ivanm> since the whole point is that I can build up what I want to do to a graph as one overall graph -> a function
04:06:48 * ski wonders whether one could sensibly make an environment applicative or something ..
04:06:52 * ivanm has done better examples than that
04:08:55 <tomberek> ivanm: is there any other typeclass level splits or additions you want?
04:09:29 <ivanm> the only other things I can think of is if we should split the ComposableGraph (and DecomposableGraph) into "maybe" variants
04:09:52 <ivanm> this way, rather than silently fail, if a graph doesn't allow a duplicate edge it can explicitly say so by returning a Nothing
04:10:28 <ivanm> you might also have graph types that don't let you un-connect them (e.g. cabal's PkgIndex), so a Maybe variant of delEdge makes sense there
04:10:49 <tomberek> ok, that's not hard, a 'MonadicComposableGraph' ?
04:11:37 <tomberek> MaybeComposableGraph
04:11:42 <ivanm> the latter I think
04:12:07 <ivanm> however, what is the distinction between them?
04:12:32 <ivanm> is it OK for a graph-type that disallows multiple edges to be an instance of ComposableGraph ?
04:12:50 <ivanm> or should we have a "SpecialisedGraph" or something?
04:13:30 <ivanm> we could also just have them part of the same class, make the non-monadic silently fail (i.e. return the original graph)
04:13:36 <ivanm> and recommend people use the monadic variants
04:13:38 <ski> does it make sense in your system to have an operation that takes a directed graph, checks whether it is actually undirected, and in that case returns an graph which is type-wise known to be undirected ?
04:13:42 <ivanm> that might actually be better
04:13:57 <ivanm> ski: probably not
04:14:22 <ivanm> ski: I'd like to avoid edwardk's preference for multiple newtype applications to indicate what something is via its type :p
04:14:59 <tomberek> ski: ATM, i have UndirectedGraph as a typeclass,, but I can't see a way to have NoLoops, or NotAMultiGraph, or anything like that
04:15:08 * ski would think of directed graphs as one category, and undirected graphs in another, with an underlying functor going from the latter to the former
04:15:28 <ski> s/in another/as another/
04:15:52 <ivanm> tomberek: I don't think having a class to specify "UndirectedGraph" makes much sense
04:16:15 <ivanm> since when would you state that an FGL graph is undirected?
04:16:16 <ski> ivanm : yeah .. ideally, if one does such a think with `newtypes', then one'd like some `newtype's to commute with each other .. which can't currently happen
04:16:24 <ivanm> ski: exactly
04:17:05 <ski> (i.e. one'd like to be able to view the same type as being of several different (but compatible) `newtype's)
04:17:29 <tomberek> ski,ivanm: i did a quick implementation with newtypes for Oriented (no multiple edges) and NoLoops, where Simple what just the combination of the two
04:17:41 <ivanm> if you could do that, then I wouldn't have a problem using newtypes to state properties
04:17:44 <tomberek> but you are right, that is too rigid
04:18:25 * ivanm doesn't have as much of a "use the tyep system to prove everything" fetish as other haskellers
04:18:34 <ski> (ivanm : though, tbh, i was thinking of something more like `checkDirected :: DirectedGraph dg => dg n e -> Maybe (exists ug. UndirectedGraph ug *> ug n e)')
04:18:48 <ivanm> what does the *> mean?
04:18:56 <ivanm> and the exists
04:19:04 <ski> (so that is not exactly "do things with `newtype's")
04:19:23 <ski> `(->)' : `(,)' :: `(=>)' : `(*>)'
04:19:35 <tomberek> ski: why can't we just say that any DirectedGraph is an UndirectedGraph.. isn't it just the idea of turning a tuple into an unordered pair?
04:20:16 <ski> tomberek : any directed graph *generates* a free undirected graph, yes. but not every directed graph *is* an undirected graph
04:20:17 <ivanm> ski: hmmm....
04:20:50 <ski> ivanm : obviously, this would be a whole lot more pleasant if GHC already supported `exists' and `*>' :D
04:21:10 <tomberek> ski: well, if it generates one, isn't that enough?
04:21:22 <ivanm> ski: heh
04:21:31 <ski> tomberek : enough for what ?
04:22:01 <ivanm> I think it just makes much more sense that if you want an undirected graph, we have a specialised newtype wrapper over a normal graph (of your choice) that just does everything both ways
04:22:12 <ivanm> rather than bothering with an actual UndirectedGraph class
04:22:23 <ski> oh
04:22:41 <tomberek> ivanm: that's also a possibility
04:22:51 <ski> so you'd rather want `checkDirected :: Graph g => g n e -> Maybe (Undirected g n e)' ?
04:23:01 * ski is simplifying
04:23:28 <tomberek> ski: our Graph is *,, so Graph g => g -> Maybe (Undirected g)
04:24:06 * ski was probably fooled by `GraphvizParams nl el cl l -> gr nl el -> ...', then
04:24:18 <ski> (where `gr :: * -> * -> *')
04:24:31 <tomberek> ah
04:24:48 <ivanm> ski: having to use FGL :s
04:25:01 * ski does not know FGL
04:26:31 <ivanm> ski: FGL is kind * -> * -> *; we're wanting to make ours kind * (but somehow allowing kind * -> * -> * graphs as well for mapping purposes)
04:26:48 <ivanm> byorgey is workign on kind polymorphism; interesting to see if we could somehow use that...
04:26:53 <ski> ok. rationale ?
04:27:17 <donri> How does "(Integral a) => a -> String" differ from "Integral -> String"?
04:27:31 <ski> donri : `Integral' is not a type
04:27:35 <ivanm> donri: the latter doesn't make sense
04:27:37 <tomberek> ski, many times it will be something like Graph (IntMapGraph nl el)
04:27:46 <ivanm> the former allows Integer, Int, Word, etc. to be used
04:27:46 <ski> donri : maybe the latter was intended to be `Integer -> String' ?
04:27:59 <ivanm> ski: using kind * lets you treat the Cabal pkg db as a graph
04:28:07 <donri> No, the latter was made up by me thinking it was the same thing :)
04:28:10 <ivanm> using kind * -> * -> * is requried if you want to do real mapping
04:28:15 <ivanm> donri: heh
04:28:18 <donri> So Integer/Int are types and Integral is a ... class?
04:28:23 <zygoloid> donri: that's correct.
04:28:35 <ski> a *type* clasas
04:28:38 <ski> class
04:28:40 <donri> And can't typematch a class eh
04:28:51 <zygoloid> donri: type classes are basically collections of types which have some common interface / properties
04:29:04 <ski> donri : class constraints belong to the left of `=>', in type signatures
04:29:23 <donri> What's the benefit of having to do that?
04:29:50 <donri> Clarity that Integral is not a type?
04:29:57 <tomberek> ivanm: i didn't understand what was wrong with how I made the Cabal pkg db a graph
04:30:08 <ski> ivanm : hm .. i suppose `* -> * -> *' invited mapping over the labels ..
04:30:10 <zygoloid> donri: the reason we don't want to use the "Integral -> String" notation for typeclasses is that (1) we want to be able to specify multiple typeclasses for one type, and (2) we want to be able to specify that two Integral types are the same
04:30:36 <donri> Ah.
04:30:40 <donri> Thanks :)
04:30:43 <ski> donri : consider `foo :: (Show n,Integral n) => [n] -> String', e.g.
04:30:57 <donri> That doesn't seem to apply to that simple case, but I guess consistency is good.
04:31:17 <zygoloid> or consider "(+) :: Num a => a -> a -> a". if that were just "Num -> Num -> Num", we couldn't specify they had to be the /same/ type
04:31:31 <ski> yes. there's no need to make the system more complicated that it is
04:31:59 <donri> I was merely curious if there was a technical reason
04:32:07 <tomberek> ski: edwardk's Bifunctor covers it
04:33:01 <ski> donri : there's also more advanced things like `set :: MonadState s m => s -> m ()', where `MonadState' here is actually not a property, but a *relation* between types
04:33:22 <zygoloid> donri: it's a reasonable question, especially since OO languages usually go the other way and say interfaces are supertypes of their implementations
04:33:37 <donri> But there is no technical reason why "Integral -> String" couldn't be allowed? I'm not suggesting it should be, just curious.
04:33:44 <ivanm> tomberek: because IIRC you did functions to convert it to a graph, rather than making that type an instance of the graph classes itself
04:34:05 <zygoloid> donri: no. typeclasses and types live in the same namespace, so that would be unambiguous (apart from the Num -> Num -> Num problem)
04:34:20 <donri> Yea but this specific case is a single Integral :)
04:34:28 <tomberek> ivanm: ah,, ok, I'll give that a shot tonight
04:34:52 <ski> donri : `(exists i. Integral i *> i) -> String' could be allowed .. which might be allowed to be shortened as `Some Integral -> String', i suppose
04:35:10 <tomberek> ivanm: that's what I like about the "Graph is a composition of smaller typeclasses" approach.  It is easier to make new instances and experiment
04:35:16 <ivanm> yup
04:35:45 <ivanm> see, the pkg index would be an instance of GraphLike, and if we do split up the composition/decomposition stuff it would be an instance of the Maybe variants
04:36:17 <ivanm> actually, should the Maybe variants just be methods of GraphLike (defaulting to const Nothing) ?
04:36:20 <ivanm> afk
04:36:42 <zygoloid> types parameterized on classes in that way would seem to add second-order logic powers to the type system, which would possibly render it undecidable ;(
04:36:45 <ManateeLazyCat> Crypto-4.2.1 failed during the building phase.   hmmm....
04:36:54 * ski dislikes (actual) defaults which are not to be treated as laws
04:38:50 <donri> Coming from Python I find it quite confusing that Haskell's import is by default Python's import *; is it frowned upon to import Foo (member…)?
04:38:58 * ManateeLazyCat pasted "Crypto compile failed." at http://paste2.org/get/1010725
04:38:59 <ManateeLazyCat> Any idea about above error? Maybe need some LANGUAGE option to fix?
04:39:15 <ski> donri : not at all, i think
04:39:21 * ManateeLazyCat pasted "QuickTest.hs in Crypto package" at http://paste2.org/get/1010727
04:39:27 <donri> ski: Why isn't it used more? Laziness? :)
04:39:39 * ski usually uses it
04:39:40 <tomberek> ski: do you mean defaults in a typeclass?
04:39:52 <ski> tomberek : yes (hence the "actual")
04:40:19 <tab> ManateeLazyCat: newer quickcheck have instances for w8 and w64
04:40:31 <tomberek> ski: what about something like   edgesOut = map index ... labEdgesOut ?
04:40:39 <ManateeLazyCat> tab: Ah, how to fix? Install older QuickCheck?
04:40:39 <tab> ManateeLazyCat: they didn't use to be there, hence why it's probably defined twice
04:41:03 <tab> ManateeLazyCat: in my case, i pinned quickcheck between 2.0 and 2.1
04:41:11 <tab> IIRC it's 2.3 that has the new instances
04:41:21 <ski> tomberek : as long as any "overrides" are to be expected to give the same results, i'm satisfied
04:41:21 <zygoloid> donri: qualified imports and import lists are recommended by various style guides. see http://www.haskell.org/haskellwiki/Import_modules_properly for instance
04:42:13 <tomberek> ski,, ah, ok, I just use them to provide a default, meaning that implementors don't need to write code for EVERY function, but they can override for efficiency
04:42:24 <donri> Good. It's really helpful for reading others sources. 
04:42:27 <ski> donri : .. right, as zygoloid mentioned, qualified imports is the other way to keep track of imports, sanely
04:42:49 <donri> Is there a PEP 8 of Haskell? Coding style standard
04:43:03 <ski> tomberek : "override for efficiency" is ok in my book, "override for differing behaviour" is not
04:43:05 <zygoloid> donri: when i don't use import lists it's usually "i'll do it later, i'm prototyping right now"-mode; it's on my todo list for a project i intend to upload to hackage
04:43:15 <jedai> donri: Serious library or programs use qualified imports and specific import () 
04:43:20 <tab> donri: nope
04:43:23 <tomberek> ski: i would assume that's taken for granted.. perhaps i was wrong
04:43:29 <ManateeLazyCat> tab: Maybe i need report bug to Crypto author.
04:43:29 <ManateeLazyCat> tab: When QuickCheck >= 2.3, remove instance define.
04:43:44 <zygoloid> donri: there are various style guides; none that i'm completely happy with, though, and none that are very widely adopted.
04:43:48 <tab> ManateeLazyCat: that would be the right thing i guess
04:43:55 <tomberek> I like import lists because I can keep track of everything I need.  I can also reduce dependencies that way
04:43:55 <donri> Hokah
04:43:56 <ski> tomberek : ivanm's "defaulting to const Nothing" suggested the latter alternative
04:44:02 <ManateeLazyCat> tab: Ok, thanks for help! :)
04:44:02 <jedai> donri: There's always HLint
04:44:24 * zygoloid has been meaning to write down his own guidelines but hasn't got around to it yet ;0
04:44:47 <jedai> donri: it's lint for Haskell so it gives some guidance as to what is considered good style (though it is configurable too)
04:44:52 <donri> tomberek: +1, and very helpful for reading others sources
04:45:11 <tomberek> ski: huh? I don't follow. are you refering to insertEdge :: Edge g -> g -> g?
04:45:21 <tomberek> or the monadic version
04:45:22 <zygoloid> donri: the impression i get is that a lot of haskell programmers consider the layout of their code to be art rather than science, so don't like overly-restrictive rules
04:45:36 <donri> jedai: Python has pylint though it doesn't really check the formatting of the code I think. more like the design of APIs etc.
04:45:39 <ski> <ivanm> actually, should the Maybe variants just be methods of GraphLike (defaulting to const Nothing) ?
04:45:55 <ski> tomberek : i'm not sure exactly which method ivanm had in mind there ^
04:46:05 <jedai> zygoloid: Right, though there are some habits that are considered bad style by most everyone
04:46:50 <zygoloid> jedai: layout habits? do you have any examples? (i think you're right but can't think of any off the top of my head)
04:47:04 <tomberek> oh,, i see, he was thinking of putting insertEdgeM :: Edge g -> g -> m g      into the main pseudo-graph class, but defaulting to const Nothing until implemented.... yeah,,, i don't like that either.   I'd rather have a MutableGraph and something like MaybeMutableGraph or MonadicMutableGraph
04:47:08 <zygoloid> i guess using braces rather than layout would be one
04:47:14 <jedai> zygoloid: Well if any there's the use of layout
04:47:17 <jedai> Right
04:47:40 <ski> either don't use tabs for layout, alternatively *only* layout with tabs, breaking lines after all layout-introducing keywords
04:48:13 <jedai> ski: True though that's more of a requirement for sane coding
04:48:22 * zygoloid also likes to avoid the use of let, case and if...
04:48:35 <ski> zygoloid : where reasonable, yes
04:49:12 <zygoloid> yeah. there are some cases where expression-level thinking is more appropriate than definition-level thinking
04:49:16 <tab> zygoloid: how do you avoid ifs ?
04:49:18 <jedai> zygoloid: case is pretty useful from time to time but generally you're right than most use are best done with a function
04:49:27 <zygoloid> tab: guards
04:49:42 <tab> zygoloid: right, that make sense
04:49:46 <ski> (reasonability goes down everytime you have to introduce a new definition, and can't quickly think of a sane name)
04:49:51 <tomberek> has there been any major progress in a nice IDE? leskah or an eclipse version?
04:50:01 <zygoloid> jedai: well, this isn't by any means a univeral view; the GHC coding style guidelines say pretty much the opposite
04:50:59 <jedai> tomberek: leksah seems to be pretty good now from what I heard
04:51:27 <tomberek> ok, last time I looked into it, I was not very pleased and went back to ghci and editor
04:51:55 <mightybyte> Anyone here at ICFP?
04:54:18 <tomberek> jedai: arg, I can't get to leksah.org behind this firewall... how is it different now?
04:56:24 <hvr> if I have the choice, is it better to have a 'Map ByteString a' or 'Map String a'?
04:57:03 <hvr> (the strings I have are UUIDs, so they're 7bit clean)
04:57:48 <ManateeLazyCat> tomberek: I will focus my time on Haskell IDE after busy moment....
04:58:44 <ManateeLazyCat> tomberek: Include "code completion" and "code snippets"....
04:59:01 <ski> > length (repeat "busy moment")
04:59:06 <lambdabot>   mueval: ExitFailure 1
05:05:38 <quicksilver> hvr: probably ByteString will take less memory but String will be faster
05:06:08 <quicksilver> so, if it's not a huge number of keys, I'd got for String. Test it if you want to be sure.
05:06:47 <tab> quicksilver: are you sure it would be faster ?
05:06:55 <tab> quicksilver: bytestring comparaison is usually faster than string
05:07:22 <mux> a Map ByteString a would be better replaced with a Trie a from the bytestring-trie package, fwiw
05:08:37 <Saizan> tab: for small strings it's not
05:11:07 <tab> Saizan: ok
05:11:39 <tomberek> ski : do you have any other thoughts / inputs on the graph subject?  (or anyone else? saizan? quicksilver?)
05:12:35 <ski> tomberek : i'm not really that familiar with either FGL or the ones that you and ivanm are coding on
05:13:09 <quicksilver> tab: I don't think that's true, no.
05:13:17 <quicksilver> Saizan: it's not just small strings :)
05:13:17 <tomberek> ski,, well, how about any feature you think would be nice the next time you use a graph-like structure?
05:13:34 <quicksilver> Saizan: String comparison is faster if you find the different in the first few characters.
05:13:34 <ski> tomberek : it seemed natural to me to both have some kind of `isUndirected' operation as well as a type or type class for graphs statically known to be undirected
05:13:41 <quicksilver> Saizan: that's quite likely to happen even with long strings.
05:14:01 <quicksilver> Saizan: it's only if you know your workload consists of many long strings with very long initial equal segments.
05:14:07 <quicksilver> (that bytestring is definitely fasteR)
05:14:35 <tomberek> ski:  ok, I currently have the Undirected typeclass, and can add the isUndircected into the main Graph class
05:14:56 <quicksilver> on the other hand if you have very long equal initial segments you *really* want a Trie, as mux suggests.
05:14:57 <ski> tomberek : well .. it would be nice to be able to express some graph algorithms such as liveness analysis in a natural way
05:15:37 <tomberek> ski: i'll look into it, i'm unfamiliar with liveness analysis
05:15:46 <ski> tomberek : i.e. `isUndirected' could return a `Bool', while `checkUndirected' would also return the same graph, but now statically known to be undirected
05:16:50 <tomberek> ski: hm.... something like checkUndirected :: (Undirected g', Graph g) => g -> Maybe ( g' )    ?
05:16:53 <ski> tomberek : though, i suppose the graphs there are not traditional single edge-in, single edge-out graphs
05:17:21 <tomberek> ski: yeah, atm i support a much wider array
05:17:30 <ski> tomberek : more like `checkUndirected :: Graph dg => dg -> Maybe (exists ug. Undirected ug *> ug)' ..
05:17:48 <manateeUser> Cool, google.com/complete/search?&q=keyword return suggestion list....
05:17:50 <tomberek> ah yes
05:18:19 <pumpkin> to be honest, I'm not sure typeclasses are the right choice for all those graphish operations
05:18:25 <tomberek> ski: IF those are implemented... what's a good substitute?
05:18:39 <tomberek> pumpkin: what do you propose?  (i'm fishing for opinions)
05:18:47 <Ekenstein> Hi. I am wondering how to make a instance Arbitrary of a type synonym. Anyone who knows that?
05:19:29 <tomberek> Ekenstein: I worked on similar stuff a few days ago, i might be able to help
05:19:35 <tomberek> what's the type synonym
05:19:37 <pumpkin> Ekenstein: if making an instance of the type the synonym is equivalent to isn't what you want, you're using synonyms wrong
05:19:42 <ski> tomberek : the traditional existential wrapping, `chechUndirected :: Graph dg => dg -> Maybe SomeUndirected' with `data SomeUndirected = forall ug. Undirected ug => WrapUndirected ug'
05:19:43 <pumpkin> Ekenstein: in that case you want a newtype
05:19:54 <pumpkin> Ekenstein: otherwise, you can -XTypeSynonymInstances
05:20:13 <ski> tomberek : an alternative is to use CPS : `checkUndirected :: Graph dg => (Undirected ug => ug -> o) -> o'
05:20:33 <pumpkin> you'd want a forall in there
05:20:43 <ski> er, right
05:20:46 <Ekenstein> well. I am trying to make a quickcheck function which uses a generated tuple. I have made a generator which does that, but I need quickcheck to understand that, so I am trying to make a instance for the type synonym. The type synonym is Pos = (Int,Int)
05:20:47 <cobra> I am catching an exception of type SomeException. How can I find out what type it actually is? (This is for debugging)
05:20:49 <pumpkin> tomberek: the way I envision it is to have some sort of a data family
05:21:00 <ski> s/Undirected/forall ug. Undirected/
05:21:03 <pumpkin> parametrized on the main axes of what you care about representing
05:21:48 <quicksilver> Ekenstein: what's wrong with the existing Arbitrary instance for (Int,Int) ?
05:22:15 <tomberek> pumpkin,,,hm... atm my type family in the main Graph typeclass is NodeIndex,EdgeIndex,NodeLabel,EdgeLabel... but you are talking about something more complex.. like NodeSet,EdgeRelation, etc.
05:22:41 <Ekenstein> quicksilver: I want a certain variation of ints
05:22:42 <tomberek> Ekenstein... the Arbitrary instance for that already exists
05:22:52 <pumpkin> tomberek: yeah, I'm talking about writing an actual set of data structures that represent graphs, rather than specifying a common interface
05:23:08 <quicksilver> Ekenstein: you can use a custom 'Gen' instead of the Abitrary instance
05:23:08 <tomberek> pumpkin: ok, that
05:23:20 <quicksilver> or, you can use ==> to restrict choice
05:23:21 <ski> cobra : `fromException' can be used, if guessing the exception type suffices
05:23:27 <pumpkin> I dunno, maybe a common interface is useful, but we really don't have that many graph libraries to begin with
05:23:56 <ski> cobra : there's also a `Show' instance, if you just want to print the exception
05:24:18 <ski> (and i suppose one could convert to a `TypeRep', as well)
05:24:28 <tomberek> pumpkin: ok, that's an idea I want to use, but first is the common interface, right?    I'd love to be able to parameterize things like how the different things are stored, but for that we need a common interface over containers
05:25:07 <McManiaC> where do you get "wx-config" for wxHaskell?
05:25:08 <Ekenstein> Well, how do I make the property to understand to use that generator without writing an instance for the type?
05:25:13 <pumpkin> yeah, but in that sense I think you're making it a little _too_ general. I think good library design also involves not trying to do everything you can imagine
05:25:15 <cobra> ski: I'd prefer not to guess, since i have no idea what type it is. I am already using show, and the output is not helpful. how would converting to a TypeRep work?
05:25:21 <pumpkin> and making some decisions about what belongs and what doesn't
05:25:29 <pumpkin> but that's obviously controversial 
05:25:34 <quicksilver> Ekenstein: there is a combinator "forall" which lets you choose a different Gen.
05:25:42 <tomberek> pumpkin: i was thinking of using EdisonAPI, because it's very regular, but I don't think it's really widespread, there is some other work on containers being done noe
05:26:03 <tomberek> pumpkin: you are right, sometimes I try to make things too general
05:26:28 <ski> cobra : what is it you want to do, here ?
05:26:37 <pumpkin> tomberek: having said that, I'm not sure what I'd do :)
05:26:43 <pumpkin> it's a tough design space
05:26:46 <tomberek> pumpkin: for example, I fought to have Edge g be a type family rather than (Node g,Node g) type synonym because I want to allow hypergraphs
05:26:47 <Ekenstein> quicksilver: will look it up. I am quite new to the concept of quickcheck, or quite new to haskell in general, so atm I feel quite thick
05:27:05 <quicksilver> Ekenstein: you're not being thick; it's not very well documented.
05:27:11 <tomberek> Ekenstein: you have the code for your generator? can you post it?
05:27:25 <cobra> ski: A function from a library throwing an exception that should be an IOException, but I can only catch it with SomeException. I want to see what type of exception it actually is
05:27:54 <quicksilver> cobra: if that's all you want to know, I believe "show"ing it will tell you
05:27:57 <Ekenstein> tomborek: sec
05:28:01 <ski> well, `fromException' should be able to convert to `Maybe IOException'
05:28:01 <tomberek> ski: the wrapped version isn't hard, but like you talked about, too many wrappers with no commuting sucks
05:28:25 <ski> tomberek : wrapped version being `Undirected g' ?
05:28:27 <Ekenstein> tomberek: http://pastebin.com/ZyR29rZ5
05:28:37 <ski> tomberek : .. or the existential wrapping ?
05:28:41 <tomberek> ski: yes.    though I think there are some frameworks hidden in edwardk's category-extras
05:28:48 <Saizan> cobra: you can print the TypeRep, which you can access with typeOf, catch ... (\(SomeException e) -> print (typeOf e))
05:28:59 <tomberek> ski: data SomeUndirected existential
05:29:20 <tomberek> ekenstein: looking
05:29:26 <cobra> quicksilver: when I show it, it looks like a normal IOException
05:29:33 <ski> tomberek : the intention behind `SomeUndirected' would be that you unwrap it immediately, instead of passing it around wrapped
05:29:52 <cobra> Saizan: thanks i'll try that
05:30:09 <ski> (so i'm not sure what isses there would be with commutation, in this case)
05:30:17 <tomberek> ski: ah, i think i see
05:30:45 <quicksilver> Ekenstein: which version of quickcheck are you using?
05:30:55 <ski> tomberek : the wrapping and unwrapping only being done because we don't have first-class existentials (and output constraints)
05:31:14 <tomberek> Ekenstein: that is not a type synonym
05:31:14 <ski> tomberek : also, there's the CPS alternative
05:31:14 <Ekenstein> I have no idea, probably the latest. I downloaded it yesterday from the apt repository
05:31:58 <tomberek> ekenstein: and (a,b) is already an instance of Arbitrary, so you will overlap with that.. how about newtype MyPair = My Pair (Int,Int)  ?
05:32:14 <tomberek> ski:  CPS?
05:32:17 <quicksilver> Ekenstein: you want forall from http://hackage.haskell.org/packages/archive/QuickCheck/2.3.0.2/doc/html/Test-QuickCheck-Property.html#v:forAll
05:32:20 <quicksilver> tomberek: no.
05:32:23 <Ekenstein> ah I see
05:32:35 <quicksilver> tomberek: there is no need for a newtyp and no need for an instance of Arbtirary.
05:32:44 <quicksilver> that will just waste time wrapping + unwrapping.
05:32:52 <tomberek> ok... 
05:33:00 <quicksilver> this is what forAll is for.
05:33:27 <ski> tomberek : `checkUndirected :: Graph dg => (forall ug. Undirected ug => ug -> o) -> o'
05:33:30 <quicksilver> forAll position (\p -> .... some property here ... )
05:33:39 <quicksilver> will use your Gen 'position' that you pasted.
05:33:45 <cobra> My brain just exploded
05:33:49 <Ekenstein> aaaah
05:33:51 <Ekenstein> nice
05:34:19 <pumpkin> cobra: get used to it :)
05:34:43 <cobra> pumpkin: This is what ghc told me
05:34:50 <tomberek> quicksilver,, that would work
05:35:08 <pumpkin> maybe GHCi should have a warning
05:35:30 <ski> cobra : paste your code ?
05:35:31 <pumpkin> "Disclaimer: Temporary brain injury may result from excessive beginner use of Haskell. Proceed at your own risk"
05:35:32 <ManateeLazyCat> @hoogle String -> ByteString
05:35:32 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
05:35:32 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
05:35:32 <lambdabot> Prelude read :: Read a => String -> a
05:35:45 <tomberek> ski: i'm not 100% with forall and existentials yet
05:36:04 <ManateeLazyCat> > read "Can work?" :: ByteString
05:36:05 <lambdabot>   Not in scope: type constructor or class `ByteString'
05:36:11 <cobra> ski: It's not a ghc bug. It continues on to say, "I can't handle pattern bindings for existential or GADT data constructors. [...]"
05:36:48 <zygoloid> > read "\"Hello ManateeLazyCat\"" :: BS.ByteString
05:36:49 <lambdabot>   "Hello ManateeLazyCat"
05:37:04 <Saizan> cobra: you should still paste the code if you want us to help :)
05:37:04 <ManateeLazyCat> zygoloid: Cool. :)
05:37:46 <hpc> > pack "Hello ManateeLazyCat"
05:37:47 <lambdabot>   Not in scope: `pack'
05:37:50 <cobra> Saizan: I basicly tried doing what you said.   let (SomeException e) = ex in ...
05:37:51 <ski> cobra : try replacing `\(SomeException e) ->' with `\se -> case se of SomeException e ->' (silly yes)
05:37:54 <hpc> > BS.pack "Hello ManateeLazyCat"
05:37:55 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
05:37:55 <lambdabot>         against inferred type...
05:38:02 <Saizan> cobra: you can't do with a let
05:38:03 <quicksilver> cobra: you have to use 'case' not 'let' with existentials
05:38:09 <quicksilver> case ex of SomeException e -> ....
05:38:23 <zygoloid> > BSC.pack "lambdabot has funny imports"
05:38:24 <lambdabot>   "lambdabot has funny imports"
05:38:29 <ManateeLazyCat> > BS.pack "测试中文"
05:38:30 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
05:38:30 <lambdabot>         against inferred type...
05:38:36 <Saizan> cobra: the lambda was fine because it works a lot like case
05:38:40 <quicksilver> BSC.pack "Bytestring has a harmful Show instance"
05:39:00 <hpc> quicksilver: orly?
05:39:21 <ivanm> hpc: IIRC, it uses the Char8 module for its show instance
05:39:29 <ivanm> which assumes you're using Latin1 as your encoding
05:39:31 <ivanm> hey hamishmack 
05:39:34 <hpc> ah
05:39:34 <ManateeLazyCat> > read "中文不行" :: BS.ByteString
05:39:35 <lambdabot>   "*Exception: Prelude.read: no parse
05:39:43 <zygoloid> ManateeLazyCat: need moar quotes
05:39:47 <ski> > read "    " :: String
05:39:48 <lambdabot>   "*Exception: Prelude.read: no parse
05:39:53 <hpc> haha
05:39:53 <Saizan> > BSC.pack "测试中文"
05:39:55 <lambdabot>   "K\213-\135"
05:40:09 <ManateeLazyCat> > BS.pack "\"测试中文\"" 
05:40:10 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
05:40:10 <lambdabot>         against inferred type...
05:40:31 <ManateeLazyCat> Saizan: I think BSC cut unicode.
05:40:35 <quicksilver> hpc: it doesn't produce haskell syntax which evaluates to the expression.
05:40:41 <Saizan> ManateeLazyCat: yeah, it does
05:40:43 <quicksilver> unless, perhaps, you're using OverloadedStrings.
05:41:01 <ManateeLazyCat> Hmm, use Text, then covnert to [Word8] then convert to String.
05:41:37 <ManateeLazyCat> Text ==> [Word8] ==> Codec.Binary.Url.encode ==> String ==> URL
05:42:02 <ManateeLazyCat> Haha, i forgot utf8-string
05:42:11 <tomberek> ski: can't checkUndirected be much simpler?  it is instance dependent right? so for those instances which are directed,,, Maybe g   if not.  Nothing
05:42:57 <tomberek> so any instance merely defines isUndirected or checkUndirected
05:43:05 <ManateeLazyCat> > Codec.Binary.Url.encode $ Codec.Binary.UTF8.String.encode "中国" 
05:43:06 <lambdabot>   Not in scope: `Codec.Binary.Url.encode'Not in scope: `Codec.Binary.UTF8.Str...
05:43:16 <ski> tomberek : i was considering `checkUndirected' only for graphs of those types which describe possible directed graphs
05:43:43 <ski> tomberek : i.e., for graphs statically known to be undirected, it would be a type error to apply `checkUndirected'
05:44:10 <pumpkin> or it could just be Just . id
05:44:24 <cobra> thanks guys! I got it. the mystery exception is GHC.Exception.ErrorCall
05:44:52 <tomberek> ski: hm... it seems this is adding too much complication, there is a simple solution using the static style... is it really often the case that we don't know at compile time if a graph is undirected or not?
05:47:28 <sshc> \\la
05:50:17 <tomberek> .
05:50:45 <ivanm> ..
05:51:22 <ivanm> tomberek: why are you so insistent that there is an UndirectedGraph class?
05:51:22 <pumpkin> mm_freak: no MaybeT in your library?
05:51:41 <ivanm> I was planning on just using isDirected (or whatever I've called it) that I wrote for graphviz as a sample default
05:52:41 <ski> tomberek : i don't know
05:54:56 <tomberek> ivanm: it just seems simpler... if i see something that makes it simpler to have it the other way, i have no problem with switching
05:55:30 <ivanm> how does it make it simpler?
05:55:46 <ivanm> (having such a type class)
05:56:31 <tomberek> ivanm: as I was telling ski, the only time an actual function for this is needed is when it is not known statically if a graph is directed or not.  In my (rather sparse) experience, that is rare.  Otherwise the class is good to have because it provides a few functions that allows one to manipulate an instance of it as an undirected graph
05:57:07 <tomberek> though I could be wrong 
05:57:46 <ivanm> methinks you are ;-)
05:58:11 * ski would like *both* an `isDirected' operation *and* some kind of static construction for handling known undirected graphs ..
05:58:35 <ivanm> tomberek: unless the graph type is smart enough to have a parameter to indicate whether it is representing an undirected graph or not (for directed graph structures), then how do you know without running a function to check?
05:58:48 <ivanm> ski: sure, have an UndirectedGraph newtype wrapper
05:58:50 <medfly> @index comparing
05:58:51 <lambdabot> bzzt
05:58:56 <medfly> @hoogle comparing
05:58:56 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:59:04 <ivanm> admittedly, there might be other types which are strictly undirected
05:59:06 * quicksilver thinks this is typical of discussions on graph libraries - it's tricky to progress because nobody seems to agree what a 'typical' client of a graph library looks like.
05:59:17 <ivanm> I'm not sure how much such a class would give us though
05:59:19 <tomberek> hehe, but as I'm sure you are aware, it's a pain in the neck to convince me         ivanm: will that wrapper have to be on ALL undirected graphs?
05:59:26 <ivanm> does it really give us any extra information on how to use it?
05:59:51 <tomberek> quicksilver: that's why I'm trying to stir up discussion
05:59:54 <ivanm> tomberek: I'm suggesting it as one way someone could "transparently" enforce that they want to use a graph as being undirected
06:00:02 <ivanm> such that it will duplicate edges, etc. for you
06:00:41 <tomberek> ivanm: oh, sure, that's not hard to do with a newtype and associated instances...   but we also have the static option that doesn't use the newtype... is that OK?
06:01:04 <ivanm> *shrug* it's OK to implement
06:01:11 <ivanm> I'm not sure what it gives us though
06:01:35 <ivanm> I mean, apart from being able to say "(UndirectedGraph g) => g -> g", does it give us anything?
06:01:38 <ivanm> any extra functions?
06:01:42 <tomberek> ivanm:  it gives us   g -> Node g -> [Node g]  
06:02:05 <tomberek> otherwise what function gives you all the neighbors of a node?
06:02:10 <ivanm> tomberek: _all_ graphs give us that
06:02:21 <ivanm> the neighbours function!
06:02:55 <pumpkin> as far as I could tell, he's trying to express that some graph structures can't do that
06:02:58 <pumpkin> efficiently, at least
06:03:04 <ivanm> yes
06:03:08 <tomberek> yes, what pumpkin said
06:03:12 <ivanm> but that has nothing to do with whether it's directed or not
06:03:18 <pumpkin> something like hasEdge :: a -> a -> Bool
06:04:01 <ivanm> I'm not sure if "implementing" efficiency for certain operations in the type system makes sense
06:04:27 <pumpkin> well, in the above case it simply isn't possible
06:04:35 <pumpkin> you can query if an edge exists, but you can't enumerate them
06:04:49 <ivanm> pumpkin: I don't particularly care about infinite graphs
06:04:51 <pumpkin> you might imagine some sort of implicit graph structure arising from something else
06:04:52 <ivanm> since they're boring :p
06:04:59 <pumpkin> it's not even necessarily infinite
06:05:18 <pumpkin> but yeah, I'm not sure it's worth handling it as acase
06:05:20 * pumpkin shrugs
06:05:28 <ivanm> e.g. "(Eq a) => a -> [a]" is a really boring graph type
06:05:31 <tomberek> pumpkin: i implemented a graph a few days ago where data MyEdge = MyPair Int Int | MyRule (Int -> Int -> Bool)
06:05:41 <ivanm> tomberek: why would you do soemthing like that?
06:06:04 <pumpkin> tomberek: presumably if you can specify the rule as a function, you can also specify an enumeration of neighbors as a function
06:06:30 <tomberek> ivanm: I did it just out of curiosity to see if my framework could support it.  But I can imagine a graph where rules define what is connected vs explicitly
06:06:45 <ivanm> tomberek: I can imagine a lot of things
06:06:53 <ivanm> doesn't mean they're likely or that we should bother catering to them
06:07:08 <tomberek> pumpkin : i fogot if it was (Graph g => g -> Node g -> Node g -> Bool) but you get the idea
06:07:26 <ivanm> e.g. I can imagine the earth being a cube; so what?
06:07:37 <tomberek> ivanm: i didn't really cater to it, I just tried to see if the framework can do it, and was pleased that it could
06:07:55 <ivanm> tomberek: the only way we could cover every single possible graph type is to have the library so disjointed and horrible to use that no-one would use it
06:08:23 <pumpkin> ivanm: that's a bold statement :)
06:08:31 <pumpkin> conal would have something to say about that
06:08:32 <tomberek> ivanm: agreed, for example, I like EdisonAPI, but I can see why it isn't used more often
06:08:38 <ivanm> pumpkin: which part?
06:08:47 <ivanm> tomberek: I think the API is horrible
06:08:48 <pumpkin> "the only way we could do X is by making X horrible"
06:08:52 <ivanm> (for EdisonAPI)
06:09:07 <ivanm> pumpkin: well, sure, we could have a graph type that covered (a -> [a]) as a graph
06:09:10 <pumpkin> @get-conal
06:09:10 <lambdabot> Unknown command, try @list
06:09:11 <ivanm> wouldn't give us much though
06:09:21 <ivanm> all we could do is tell if an edge existed
06:09:37 <ivanm> and depending on what a result of [] means if a node exists
06:09:37 <pumpkin> I'm just saying, he's talked about similar statements in terms of "I can't imagine a way in which doing X without making the result ugly is possible"
06:09:41 <pumpkin> :P
06:09:47 <ivanm> heh, fair enough
06:09:53 <ivanm> but I'm saying let's be reasonable here
06:09:59 <pumpkin> oh, I agree :)
06:10:01 <ivanm> let's ignore infinite or semi-infinite graphs
06:10:23 <pumpkin> well, the way I see it that kind of thing arises from implicit graphs
06:10:29 <tomberek> ok, so what does that imply for the undirected discussion?
06:10:32 <pumpkin> a graph that results from an existing structure that isn't easily queryable
06:10:32 <ivanm> the way I see it, classes represent "what can we do with or find out about this type?"
06:10:46 <ivanm> tomberek: you can have an UndirectedGraph class if you want; I just don't see the point
06:10:52 <ivanm> since what extra methods does it give you?
06:11:16 <luite> what's a semi-infinite graph?
06:11:26 <ivanm> pumpkin: right, but too many of those won't fit in to any overall framework that is sophisticated enough to deal with 'real' graph types as well
06:11:27 <tomberek> ivanm: that was why I put neighbors into UndirectedGraph..   maybe it should be   "CanBeSeenAsAnUndirectedGraph"  maye the names are bad, but that was the idea
06:11:34 <ivanm> luite: infinite nodes, finite edges per node
06:11:47 <ivanm> tomberek: no, because neighbours makes sense for _all_ graphs
06:12:06 <ivanm> neighbours = successors + predecesors - duplication of loops
06:12:07 <ski> (tomberek : imo, `UndirectedGraph' is clearly better than `CanBeSeenAsAnUndirectedGraph')
06:12:08 <tomberek> ivanm: and all graphs can be seen as undirected..... (maybe? maybe?)
06:12:16 <luite> ivanm: oh I only know that as a locally finite graph
06:12:19 <tomberek> ski: lol, yes
06:12:28 <ivanm> tomberek: yes
06:12:29 <tomberek> ivanm: we can filter it
06:12:41 <ski> (tomberek : .. and i don't mean wrt the length of the name)
06:12:54 <ivanm> tomberek: but neighbours makes sense for all graphs, even if they're not undirected
06:13:22 <ivanm> so, you can state "UndirectedGraph" is a separate class, but only specialised types can be used for it
06:13:40 <ManateeLazyCat> Haha, http://google.com/complete/search?output=firefox&q=haskell return [String, [String]]
06:14:17 <tomberek> ivanm: i guess I'm using undirected wrong, the idea was that the class X defines graphs where all neighbors (and hence edges and degree) can be defined
06:16:07 <grandiose> So. I did you all a favour by opening WinGHCi. How do I create a new haskell source file from within it, now?
06:17:10 <tomberek> as opposed to graphs where only successors can be defined
06:17:16 <ivanm> grandiose: how is that a favour to us?
06:17:29 <ivanm> and you don't, you create a file elsewhere and load it (by using :load or :l) into ghci
06:17:40 <tomberek> ivanm: he is being grandiose, hardy har har
06:17:55 <ivanm> tomberek: oh, right, my humour gland is currently inoperative
06:18:12 <tomberek> ivanm: is that from dealing with me?
06:18:32 <ivanm> nope, it's from my new computer refusing to boot
06:19:11 <tomberek> ivanm: ok, i gotta go
06:19:24 <tomberek> be back in half hour or so
06:22:03 <ivanm> ManateeLazyCat: waddaya think, they're using Haskell under the hood? :p
06:22:26 <ivanm> (it's probably javascript)
06:22:40 <ManateeLazyCat> ivanm: I don't know, but when i add 'output=firefox', it's looks like [String,[String]]
06:22:48 <ManateeLazyCat> ivanm: Much simple than JSON.
06:23:10 <ManateeLazyCat> ivanm: I don't understand why Google Suggest not return JSON result...
06:23:23 <ivanm> yeah, but without it it has window.google.ac.h(...)
06:23:24 <tab> [String,[String]] is JSON actually
06:23:29 <ManateeLazyCat> ivanm: But never mind, works well. I will release GoogleSuggest soon. :)
06:24:09 <ManateeLazyCat> ivanm: I don't understand, why add window.google.ac.h
06:24:39 <ivanm> ManateeLazyCat: that's the json function that does the window stuff?
06:24:48 <ivanm> tab: yeah, can't be Haskell: no parens!
06:24:54 <ivanm> (for the tuples)
06:25:30 <ManateeLazyCat> ivanm: I'm using other way.....
06:25:43 <ManateeLazyCat> ivanm: read :: [String].... :)
06:29:03 <ManateeLazyCat> ivanm: Have any code parse window stuff?
06:29:27 <ivanm> nope
06:30:05 <ManateeLazyCat> ivanm: Ok, best use 'output=firefox' option, then no window stuff in return string...
06:30:44 <ivanm> ManateeLazyCat: I wouldn't rely on that though
06:31:11 <ivanm> ManateeLazyCat: you could to a "drop 1 . dropWhile (/= '(')"
06:31:23 <ivanm> and then check about how to deal with the closing parens
06:31:26 <ManateeLazyCat> ivanm: Yep,   read (init $ drop (length ("[\"" ++ keyword ++ "\",")) (toString string)) :: [String]
06:31:27 <ManateeLazyCat>  
06:31:34 <ivanm> possibly even forget about the drop 1
06:31:39 <ivanm> > read "(1)" :: Int
06:31:40 <lambdabot>   1
06:31:42 <ivanm> hooray!
06:31:50 <ivanm> > read "(Maybe '3')" :: Int
06:31:51 <lambdabot>   *Exception: Prelude.read: no parse
06:32:01 <ivanm> > read "(Just '3')" :: Maybe Char
06:32:02 <lambdabot>   Just '3'
06:32:05 <ivanm> that's better
06:32:13 <ivanm> ManateeLazyCat: ^^ there you are, don't need to worry about the parens
06:32:27 <ivanm> (probably better off using a proper parser though)
06:35:42 * ManateeLazyCat pasted "GoogleSuggest" at http://paste2.org/get/1010887
06:35:44 <ManateeLazyCat> ivanm: ^^^^^
06:35:59 <ManateeLazyCat> ivanm: Fastest way....
06:36:00 <ManateeLazyCat> :)
06:36:48 <ivanm> ManateeLazyCat: which will break very, very easily :p
06:37:22 <ManateeLazyCat> ivanm: Google will return ["keyword",[]] if no suggestion for 'keyword'
06:37:35 <ManateeLazyCat> ivanm: So it won't break, except Google change protocol....
06:37:37 <ManateeLazyCat> :)
06:37:54 <ivanm> ManateeLazyCat: or there are square brackets in the result....
06:38:49 <ManateeLazyCat> ivanm: I guess noone do Google Suggest?
06:39:17 <ManateeLazyCat> I like GoogleSB, download hash list automatically...
06:39:22 <ManateeLazyCat> @package GoogleSB.
06:39:22 <lambdabot> http://hackage.haskell.org/package/GoogleSB.
06:39:23 <ManateeLazyCat> @package GoogleSB
06:39:24 <lambdabot> http://hackage.haskell.org/package/GoogleSB
06:40:10 <Silkjc> If I have a list of tuples like so: [("p",AND (OUT "q") (IN "x")),("q",OR (IN "y") (OUT "p"))] what is the easiest way to create a list of all strings that follow IN...ie in this case create ["x","y"] ...obviously I want to map some search function?
06:40:23 <ManateeLazyCat> ps: Use Chinese Translate 'GoogleSB' is 'Google Idiot" . :)  
06:40:32 <EvanR-work> > read "[\"[]\",\"\"]" :: [String]
06:40:33 <lambdabot>   ["[]",""]
06:40:35 <ivanm> Silkjc: how is the data type for the second pair defined?
06:41:06 * ManateeLazyCat SB in Chinese is dirty word for GFW ... :)
06:41:25 <Silkjc> ivanm: The second item in the tuple?
06:41:38 <EvanR-work> > read . head  (read "[\"[]\",\"\"]") :: [Integer]
06:41:39 <lambdabot>   *Exception: Prelude.read: no parse
06:41:53 <ivanm> Silkjc: yup
06:41:55 <EvanR-work> > read . head  (read "[\"[]\",\"\"]") :: Integer
06:41:56 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
06:41:57 <lambdabot>         agains...
06:41:57 <EvanR-work> gah
06:42:43 <Silkjc> its data Exp = NOT Ident Ident     <-- where NOT can be AND/NOT, NAND etc
06:42:54 <Silkjc> Ident is IN STRING or OUT STRING
06:43:49 <ivanm> OK, that makes it a little more complicated
06:44:00 <ivanm> Silkjc: can you change the data definition of Exp?
06:44:16 <Silkjc> no, depends on a function calling it
06:44:58 <quicksilver> Silkjc: first, define a traversal which grabs all the Idents out of an Exp
06:45:36 <quicksilver> and then filter that for INs.
06:45:54 <Silkjc> ok, gunna have to look up traversal xD
06:45:54 <quicksilver> Are you sure you don't mean data Exp = AND Exp Exp ? is the type not recursive?
06:46:07 <quicksilver> it's not a particularly technial term.
06:46:14 <quicksilver> just an english word which suited me.
06:46:31 <quicksilver> is it data Exp = AND Exp Exp or data Exp = And Ident Ident ?
06:46:48 <Silkjc> Exp is like so..hope this doesn't spam,
06:46:57 <Silkjc> data Exp    = NOT Ident |     AND Ident Ident |      OR Ident Ident |      NAND Ident Ident |      NOR Ident Ident |      XOR Ident Ident
06:47:10 <quicksilver> ok, so it's not recursive.
06:47:39 <quicksilver> getIdents (Not a) = [a]; getIdents (And a b) = [a,b]; getIdents (OR a b) = [a,b]; .... etc ....
06:47:40 <Silkjc> and we have ident like so: data Ident = IN String | OUT String
06:48:19 <quicksilver> and then getINs xs = [x | IN x <- xs]
06:48:27 <quicksilver> using list comps for funky syntax :)
06:48:36 <Silkjc> ok give me a sec i'll try write it up
06:51:16 <Silkjc> quicksilver: can you explain getIns?
06:51:40 <Silkjc> takes a list of Ident's
06:51:55 <Silkjc> and returns a list of identifiers which are IN?
06:51:57 <ivanm> Silkjc: it says: for every value in xs, if it pattern matches to "IN x" then keep the x
06:59:46 <gwern> hm, so the google icfp is out
06:59:46 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
07:00:12 <gwern> take that Harrop! you accused us of lying about google, and once again you are exposed as a pathetic troll
07:00:19 <ivanm> heh
07:00:23 <gwern> @messages
07:00:23 <lambdabot> kowey said 5h 27m 48s ago: I haven't seen Daniel on IRC... I'll bet email is the best way to reach him
07:00:25 <ivanm> gwern: I thought he accused kamatsu of lying!
07:00:26 <cjs> Google ICFP?
07:00:36 <gwern> ivanm: who is one of us
07:00:38 <gwern> one of us
07:00:38 <ivanm> cjs: google had a paper at the haskell symposium or something
07:00:39 <gwern> one of us
07:00:50 <EvanR-work> youre either with us, or against us
07:00:57 * ski is reminded of Heriditary Harrop as well as Rasiowa-Harrop formulae ..
07:00:59 <ivanm> gwern: oh, I read your message as "you accused _me_ .." (emphasis added)
07:00:59 <cjs> Umm....it hasn't been presented yet, then....
07:01:07 <cjs> (We're currently just finishing the second talk.)
07:01:10 <gwern> ivanm: well, he basically accused me too
07:01:13 <ski> EvanR-work : no excluded middle, please ! ;)
07:01:33 <ivanm> cjs: well, the paper is out on the haskell reddit! ;-)
07:01:35 <EvanR-work> false dichotomy?
07:01:41 <ivanm> dons must have been over-anxious to post
07:01:47 <cjs> Is this the Scalable I/O Event Handling for GHC paper?
07:02:07 * ski . o O ( J'Accuse ! )
07:02:14 <ivanm> cjs: http://www.reddit.com/r/haskell/comments/dkpdj/haskell_at_google_for_the_hard_problems_in_the/
07:03:43 <Silkjc> quicksilver: /ivanm: This is what I got: http://pastebin.com/SVQBRMa1    I have a type error, Exp against inferred type [String] in getInputs second arg, is this the right way to structure it with map?
07:04:04 <cjs> Ah, yesterday's reagent talk. I don't see what that had to do with Harrop.
07:04:21 <ivanm> cjs: harrop said (a few times) that google doesn't use haskell, but rather ocaml
07:04:27 <cjs> Basically, they couldn't do some slightly more complex stuff as nicely or as quickly in Python, so they used some Haskell in that system instead.
07:04:39 <ivanm> Silkjc: your mapping line is the wrong way
07:04:51 <ivanm> remember, with . the application order is right-to-left
07:04:52 <cjs> Could well be, elsewhere. This is just one small part of Google's internal sysadmin stuff. It's used for small clusters that run, e.g., internal authentication servers.
07:05:17 <ivanm> Silkjc: did you want the first value from the tuple still?
07:05:20 <Silkjc> ah thank you, that seems to please the types
07:05:30 <gwern> yes, but harrop was claiming haskell wasn't used at all, and even modest qualified claims were lies and propaganda
07:05:38 <Silkjc> the first value is going into 'outputs' with map fst circ
07:05:43 <ivanm> gwern: yeah, kamatsu was only an intern, what would he know!
07:05:59 <ivanm> Silkjc: yes, but it gets _all_ of them, not just the ones with an "IN" output
07:06:07 <ivanm> s/output/Ident/
07:06:15 <tab> raaaa harrop again ..
07:06:20 <Silkjc> yea thats okay, if they are on the left then they MUST be an output
07:06:21 <ManateeLazyCat> ivanm: Here, integrate "Google Suggest" in Haskell browser : http://www.flickr.com/photos/48809572@N02/5038565741/lightbox/
07:06:41 <ski> (*ahem* : "Definition. The class `RH' of <em>Rasiowa-Harrop formulas</em> is defined as the class of those formulas which have no `exists' or `\/' as a s.p.p. (strictly positive part, cf. 2.3.23).")
07:07:01 <ivanm> Silkjc: oh, I thought you wanted ("foo", NOT (IN "a")) --> ("foo", "a") and ("bar", NOT (OUT "b")) to not return anything
07:07:16 <ivanm> ski: wrong harrop :p
07:07:33 <ski> ivanm : the one you're talking about is the wrong one, yes :)
07:07:37 <Silkjc> nah, tuple structure is (Outputs, Inputs OR outputs) so outputs are easy
07:08:06 <Silkjc> basically saying, this output, is a function of inputs and possibly outputs as well (feedback loop)
07:08:09 <ski> (MORE logic !)
07:10:51 <Silkjc> is there an easy way to debug print where clauses when the function is called?
07:11:08 <EvanR-work> Debut.Trace
07:11:08 <ivanm> @hoogle trace
07:11:08 <lambdabot> Debug.Trace trace :: String -> a -> a
07:11:08 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
07:11:08 <lambdabot> module Debug.Trace
07:11:10 <ivanm> Silkjc: ^^
07:11:10 <Silkjc> (i'm very new to haskell as you can see :P)
07:11:17 <ivanm> EvanR-work: the Debut of Trace? :p
07:11:26 <EvanR-work> bah
07:11:46 <EvanR-work> wheres that debug.trace oasis quote
07:11:47 <Silkjc> I like this room, you ask a question and you all pounce to get the answer first
07:12:02 <Silkjc> channel even
07:12:33 <ivanm> @quote trace
07:12:33 <lambdabot> Peaker says: It depends how much of the door you want to model. In a ray tracer, it would be quite different than in an alarm system
07:12:37 <ivanm> @quote trace
07:12:37 <lambdabot> Babelfish says: And there you travel: a beam tracer! Naturally, there are many things that ought to be amend.
07:12:39 <ivanm> @quote trace
07:12:39 <lambdabot> Peaker says: It depends how much of the door you want to model. In a ray tracer, it would be quite different than in an alarm system
07:12:41 <ivanm> bah
07:12:44 <EvanR-work> @quote debug.trace
07:12:45 <lambdabot> No quotes match. Are you on drugs?
07:12:47 <ivanm> @quote debug
07:12:47 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to
07:12:47 <lambdabot> fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
07:12:50 <ivanm> @quote debug
07:12:50 <lambdabot> djahandarie says: In Glasgow Scotland, GHC debugs YOU
07:12:51 <ivanm> @quote debug
07:12:52 <lambdabot> djahandarie says: In Glasgow Scotland, GHC debugs YOU
07:12:53 <EvanR-work> @quote oasis
07:12:53 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:13:02 <ManateeLazyCat> @quote gtk2hs
07:13:02 <lambdabot> roconnor says: if you click your heels and say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
07:13:06 <EvanR-work> ^
07:13:19 <ManateeLazyCat> @quote gtk2hs
07:13:19 <lambdabot> osfameron says: <ImInYourMonad> can I store gtk2hs-Buttons in a datastructure? <osfameron> ImInYourMonad: I think you have to sew them on with gtk2hs-Thread
07:13:30 <ManateeLazyCat> Hah
07:13:33 <ManateeLazyCat> @quote gtk2hs
07:13:33 <lambdabot> roconnor says: if you click your heels and say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
07:13:37 <ManateeLazyCat> @quote gtk2hs
07:13:37 <lambdabot> osfameron says: <ImInYourMonad> can I store gtk2hs-Buttons in a datastructure? <osfameron> ImInYourMonad: I think you have to sew them on with gtk2hs-Thread
07:13:41 <ManateeLazyCat> Just last two?
07:14:10 <ManateeLazyCat> @quote gtk2hs
07:14:10 <lambdabot> osfameron says: <ImInYourMonad> can I store gtk2hs-Buttons in a datastructure? <osfameron> ImInYourMonad: I think you have to sew them on with gtk2hs-Thread
07:14:35 <osfameron> the joke is much funnier the third time
07:14:45 <EvanR-work> it never gets old!
07:15:08 <ManateeLazyCat> osfameron: Answer is yes!
07:15:26 <ManateeLazyCat> @package gtk-serialized-event
07:15:26 <lambdabot> http://hackage.haskell.org/package/gtk-serialized-event
07:16:04 <ManateeLazyCat> I build some code serialized GTK Event (Just EventKey and EventButton) ^^^^
07:16:35 <ManateeLazyCat> osfameron: http://hackage.haskell.org/packages/archive/gtk-serialized-event/0.11.0/doc/html/Graphics-UI-Gtk-Gdk-SerializedEvent.html
07:17:18 <ManateeLazyCat> osfameron: If you just want use current process, don't need that, just reference GtkButton is enough.
07:17:43 <ManateeLazyCat> @quote ManateeLazyCat
07:17:44 <lambdabot> No quotes match. Maybe you made a typo?
07:17:53 <ManateeLazyCat> @quote ivanm
07:17:53 <lambdabot> ivanm says: Axman6: the premature optimisation quote is misquothed
07:18:03 <ManateeLazyCat> @quote dcoutts
07:18:03 <lambdabot> dcoutts says: (:[]) looks like a monster
07:18:12 <ManateeLazyCat> @quote dcoutts
07:18:12 <lambdabot> dcoutts says: jcreigh: you mentioned Haskell, so dons found you. He can smell that kind of thing.
07:18:45 <ManateeLazyCat> @quote dons
07:18:45 <lambdabot> dons says:  its like you can really see the guy's brain melting
07:18:47 <ManateeLazyCat> @quote dons
07:18:47 <lambdabot> dons says: devils are angry, noisy mini-Russel Crowes. Who wouldn't want those roamin the bush?
07:18:59 <EvanR-work> (:[]) "om nom nom nom"
07:19:37 <ManateeLazyCat> @quote juhp
07:19:38 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
07:19:39 <ManateeLazyCat> @quote juhp_
07:19:40 <lambdabot> No quotes match. Just try something else.
07:19:57 <ManateeLazyCat> @quote lambdabot
07:19:58 <lambdabot> lambdabot says: * lambdabot is overcome by a sudden desire to hurt everyone
07:20:01 <ManateeLazyCat> @quote lambdabot
07:20:01 <lambdabot> lambdabot says: tERmIN473d
07:20:03 <ManateeLazyCat> @quote lambdabot
07:20:04 <lambdabot> lambdabot says: lambdabot says:  lambdabot hasn't said anything memorable
07:20:10 <ManateeLazyCat> @quote lambdabot
07:20:10 <lambdabot> lambdabot says: Done.
07:20:14 <ManateeLazyCat> @quote lambdabot
07:20:14 <lambdabot> lambdabot says: mUEv4L-CORE: Tim3 li/\/\IT 3xcE3dEd
07:20:34 <cobra> hello
07:20:46 <ManateeLazyCat> lambdabot: Why you can undo un-limit?
07:21:15 <Axman6> hello cobra 
07:21:52 <ManateeLazyCat> > show "/"
07:21:53 <lambdabot>   "\"/\""
07:22:28 <Axman6> > iterate show "/"
07:22:29 <lambdabot>   ["/","\"/\"","\"\\\"/\\\"\"","\"\\\"\\\\\\\"/\\\\\\\"\\\"\"","\"\\\"\\\\\\\...
07:23:12 <ManateeLazyCat> ivanm: My code can break when i search '/'
07:23:52 <gwern> '    All challengers to Schaefer’s authority—real or imagined—were rooted out and destroyed. No one inspired greater love and admiration among the children of the Colonia than Santa Claus. It is said that in the days shortly before Christmas one year in the mid-1970s, Schaefer gathered the Colonia’s children, loaded them onto a bus, and drove them out to a nearby river, where, he told them, Santa was coming to visit. The boys and girls stood ...
07:23:58 <gwern> ... excitedly along the riverbank, while an older colono in a fake beard and a red and white suit floated towards them on a raft. Schaefer pulled a pistol from his belt and fired, seeming to wound Santa, who tumbled into the water, where he thrashed about before disappearing below the surface. It was a charade, but Schaefer turned to the children assembled before him and said that Santa was dead. From that day forward, Schaefer’s birthday was the ...
07:24:04 <gwern> ... only holiday celebrated inside Colonia Dignidad.
07:24:07 <gwern> ooops. mischan
07:24:24 <gwern> meant that for #wikipedia :)
07:24:29 <Axman6> is it spam #haskell day today? first ManateeLazyCat, now gwern 
07:25:27 <Silkjc> having no luck with debug trace:       outputs =  trace (show (map fst circ) ++ "\n\n") map fst circ   <--that totally wrong? lol
07:25:54 <ManateeLazyCat> brb
07:26:00 <quicksilver> if that produces no visible output then I presume outputs is never being evaluated
07:26:01 <Axman6> need to wrap map fst circ in brackets
07:26:13 <quicksilver> oh yes
07:26:13 <quicksilver> duh
07:26:15 <quicksilver> Axman6++
07:26:21 <EvanR-work> Silkjc: easier to 'store it in a variable'
07:26:37 <EvanR-work> trace x (random expression that is certain to be evaluated)
07:26:42 <Axman6> woah, out did quicksilver, this is a first :P
07:26:51 <Silkjc> Do I need to use show?
07:26:54 <EvanR-work> yes
07:26:57 <Silkjc> hmm ok
07:26:59 <cobra> Is MVar performance similar to pthread_mutex, or is it much more lightweight?
07:27:44 <Axman6> cobra: it's very lightweight, much faster than mutexes, because the RTS has a much better, oracle like view of the interactions between them
07:28:15 <EvanR-work> has an oracle like view doesnt mean you capitalize on your oracle ;)
07:28:25 <EvanR-work> is the assertion that ghc utilizes that info
07:28:53 <cobra> ok, because I am trying to figure out if I should try to go with a lockless design, or just use MVar
07:28:57 <Axman6> well, it sort of does, it already knows which thread is going to be woken when something is written to an empty MVar
07:29:10 <EvanR-work> lockless design in haskell?
07:29:19 <EvanR-work> software transactional memory?
07:29:27 <Axman6> i'd describe using MVars as lockless personally
07:29:29 <cobra> Axman6: in my usage, it will be very rare for a thread to wait on an MVar
07:29:39 <gwern> oy gevalt http://www.reddit.com/r/programming/comments/bm1u8/safe_robust_programming_practices_in_haskell_via/c0nrmzw
07:29:40 <EvanR-work> then theres no problem
07:30:56 <cobra> ok thanks hopefully this will be fast
07:32:02 <EvanR-work> how can you guarantee waiting on an mvar is rare?
07:32:20 <kamatsu> EvanR-work: it doesn't necessarily need to be guaranteed but intuitionistic
07:32:32 <EvanR-work> how can you intuition it?
07:32:38 <kamatsu> depends on the problem
07:33:08 <kamatsu> but as an example, if you already know that threads are mutually exclusive when they access the mvar, you can assume they won't wait on it.
07:33:15 <cobra> in my usage, a thread takes the MVar, does quick action, then releases the MVar. There shouldn't be much collision between different threads
07:33:19 <ManateeLazyCat> @hoogle "(~=)"
07:33:19 <lambdabot> Parse error:
07:33:19 <lambdabot>   --count=20 "(~=)"
07:33:19 <lambdabot>              ^
07:33:28 <Axman6> cobra: releases?
07:33:35 <ManateeLazyCat> Upps, is =~
07:33:40 <kamatsu> Axman6: he means puts
07:33:41 <cobra> Axman6: puts
07:33:46 <EvanR-work> the semantics of mvar are different from mutex locks
07:34:01 <Axman6> so, basically lots of modifyMVar?
07:34:06 <cobra> EvanR-work: I only need mutex lock. should i be using something else?
07:34:13 <EvanR-work> no you can use it as a mutex lock
07:34:26 <EvanR-work> or other ways
07:34:29 <kamatsu> cobra: what you can do is try it with an MVar, and also try it with an STM TMVar
07:34:36 <cobra> Axman6: takeMVar m >> foo >> putMVar ()
07:34:37 <kamatsu> cobra: benchmark, see which works better
07:34:52 <Axman6> so you're using it for mutual exclusion?
07:34:56 <kamatsu> changing between one and the other is trivial
07:34:57 <cobra> Axman6: yes
07:35:28 <Axman6> kamatsu: i'm not sure how a TMVar would provide any benefit for this situation, and would involve more overhead
07:35:29 <EvanR-work> isnt there a withMVar do thing
07:35:39 <EvanR-work> so it puts the () back in the event of an exception
07:36:18 <kamatsu> Axman6: it really depends on the exact scenario. I was just suggesting that he try things rather than try and reason about delay too much.
07:36:35 <Axman6> fair enough
07:37:16 <cobra> i just know that locking a pthread_mutex is pretty heavy operation, and i am wondering just how light weight the above MVar usage is
07:37:39 <EvanR-work> locking is heavy, or hitting and waiting for a lock is heavy
07:37:40 <kamatsu> so you have lots of little locks and then releases?
07:37:53 <cobra> kamatsu: yeah
07:37:59 <kamatsu> how many processes are we talking?
07:38:20 <kamatsu> s/threads
07:38:39 <cobra> kamatsu: around 200. but collisions between them should be rare. they mostly shouldn't have to wait on the MVar
07:38:55 <kamatsu> so the mvar guarantees mutual exclusion for an unusual case?
07:39:04 <kamatsu> i.e when something goes wrong or something?
07:39:26 <kamatsu> if all of them have repeated critical sections you'll have alot of contention
07:39:30 <kamatsu> (obviously)
07:40:39 <cobra> kamatsu: it's not for when something goes wrong. it's just for the case when 2 events happen to happen at the same time, which should be pretty rare
07:40:46 <kamatsu> hm
07:40:53 <kamatsu> for 200 processes all sharing the one mvar
07:40:57 <kamatsu> that doesn't sound entirely rare
07:41:09 <kamatsu> how large and complicated is this critical section?
07:41:22 <kamatsu> extremely quick?
07:41:33 <cobra> the events themselves are relatively rare. the critical section does a small amount of file IO
07:41:42 <EvanR-work> foo looks like a system call, IO
07:41:57 <EvanR-work> relatively time consuming (for real time applications)
07:42:11 <kamatsu> hm
07:42:23 <EvanR-work> though the gc probably demolishes real time anything
07:42:33 <benmachine> if you want to acquire the lock, do some IO, and then release it, I don't think STM would help at all
07:42:36 <kamatsu> EvanR-work: yeah, i don't think we're too concerned about realtime behavior
07:42:44 <kamatsu> i agree
07:42:48 <kamatsu> (with benmachine)
07:43:06 <kamatsu> locking is probably the best case when you just want to ensure mutex on some external resource
07:43:13 <kamatsu> *best solution
07:43:46 <EvanR-work> how about a thread for the external resource
07:44:01 <EvanR-work> it waits on its mvar and writes to the file
07:44:15 <EvanR-work> sounds about the same to me but less pthreads ;)
07:44:31 <kamatsu> or, even better, use a channel and then there is no cost to any thread to write to the file
07:44:35 <kamatsu> they continue on their merry way
07:44:43 <kamatsu> (very tiny cost, rather)
07:44:57 <benmachine> mm
07:44:59 <kamatsu> and then you have one thread that does all your file IO, which is easy to think about conceptually
07:45:09 <cobra> kamatsu: but would the internal synchronization costs of the channel really be cheaper then just using an MVar as a lock?
07:45:22 <EvanR-work> my way is equivalent
07:45:24 <EvanR-work> to that
07:45:27 <EvanR-work> but nicer
07:45:39 <kamatsu> well, if you have an asynchronous channel
07:45:42 <benmachine> both these alternatives allow threads to continue without their work necessarily having been done
07:45:46 <EvanR-work> kamatsu is right about Chan though
07:46:04 <Saizan> cobra: the time spent inside the lock will be smaller, so synchronization costs should get cheaper
07:46:39 <kamatsu> conceptually the thread just adds some more file IO to a TODO list..
07:46:51 <kamatsu> seems like a far less expensive operation than actually doing said IO
07:47:12 <kamatsu> however if the thread depends on that IO being completed at some point
07:47:18 <kamatsu> then you'll have to lock for the entire IO 
07:47:31 <EvanR-work> sounds like a log file
07:47:35 <kamatsu> but using a channel is great for a logging scenario, as an example.
07:47:39 <kamatsu> yeah
07:48:05 <EvanR-work> if thats all it is, just pass the handle around
07:48:12 <EvanR-work> and write to it arbitrarily ;)
07:48:26 <benmachine> what could possibly go wrong?
07:48:29 <kamatsu> hehe
07:48:39 <EvanR-work> nothing, ghc is magic right
07:49:10 <ManateeLazyCat> ivanm: I found new way, make Google suggest return XML data, then won't break...
07:49:20 <cobra> it actually would be nice if ghc had atomic file IO operations
07:50:03 <kamatsu> cobra: it's not difficult to ensure atomicity yourself though
07:50:12 <kamatsu> and it really depends on the IO operation as to how you should ensure said atomicity
07:50:17 <EvanR-work> even if files werent 'atomic', it doesnt make sense to build atomicity into every primitive if its as easy as slapping a forkIO MVar on the problem
07:50:20 <kamatsu> some methods are better than others.
07:50:21 <cobra> but from a quick look at the source, hPutStr and friends do internal buffering and other weird stuff
07:50:29 <EvanR-work> collect easy to combine tools and combine them
07:50:42 <kamatsu> internal buffering?
07:50:43 <roconnor> It would be nice if unix had atomic file IO operations
07:50:48 <kamatsu> i thought it was just standard UNIX buffering
07:51:05 <kamatsu> but i may be wrong, i'm not familiar with GHC IO internals, but it really feels like simple POSIX buffering to me
07:51:09 <kamatsu> *POSIX IOI
07:51:11 <kamatsu> *IO
07:51:22 <cobra> roconnor: it does. fprintf for example is threadsafe, even for the same file handle
07:51:36 <cjs> Yes, the new IO stuff in Haskell does indeed do internal buffering
07:51:41 <EvanR-work> we probably need to define threadsafe
07:51:43 <benmachine> isn't that just because stdio does locking?\
07:52:05 <EvanR-work> segfaulting and getting AAAABBABABABABBBBBBBB are different
07:52:47 <sjoerd_visscher> Is there a known GHC 7 bug regarding type families and (->)?
07:53:14 <kamatsu> cobra: is fprintf and other such c things included in posix? I was referring more to the lower level system calls.
07:53:37 <sjoerd_visscher> i.e. this doesn't compile anymore: type family T t :: * -> * -> *; type instance T Bool = (->); f :: T Bool Bool Bool; f = not
07:53:46 <sjoerd_visscher> Couldn't match type `T Bool' with `(->)'
07:56:14 <cobra> kamatsu: not sure, but it's nice that the higher level stuff is thread safe when useful
08:07:53 <mm_freak> pumpkin: what's wrong with ChoiceT and findFirst/maybeChoiceT?
08:08:07 <copumpkin> more complicated :)
08:08:19 <mm_freak> in what way?
08:08:28 <copumpkin> well, why do we have Maybe and []?
08:09:30 <mm_freak> yes, but who uses MaybeT?  seriously i mean
08:09:44 <copumpkin> I quite like it
08:09:51 * copumpkin shrugs
08:10:00 <mm_freak> well, what about EitherT?
08:10:09 <copumpkin> I don't use that much
08:10:16 <Silkjc> this is going to sound horrible in haskell..but I think I need the equivalent of a typecast..I have a type "Formula" = [String], I also have a function which takes a "Formula". I have another function which is producing [String], how can I pass its result into the one that takes Formula?
08:11:03 <mm_freak> copumpkin: EitherT is just like MaybeT, but with an actual error result
08:11:07 <mm_freak> not just Nothing
08:11:14 <roconnor> Silkjc: you said type Formula = [String] ?
08:11:15 <copumpkin> I know what it is :P
08:11:18 <copumpkin> I don't like it
08:11:25 <Silkjc> roconnor: correct
08:11:37 <mm_freak> i don't see how you can like MaybeT, but not like EitherT =)
08:11:37 <roconnor> Silkjc: that is a type synonom so they can be used interchangably
08:11:49 <copumpkin> mm_freak: I think the monad instance for Either is bad
08:11:49 <roconnor> Silkjc: you don't have to do anything, just pass your argument in
08:11:50 <mm_freak> especially since my EitherT has real exception handling functions attached to it
08:11:53 <Silkjc> ghci is kicking upa  stink..
08:12:06 <roconnor> Silkjc: then it is some other error
08:12:09 <Silkjc> hmm
08:13:34 <ski> copumpkin : the `Error e =>' constraint is bad, yes. anything else is bad ?
08:14:21 <mm_freak> copumpkin: i don't know what's wrong with the Monad instance in other transformer libraries, but my EitherT is implemented like ContT with two continuations…  you can easily derive MaybeT from this:  type MaybeT r m a = EitherT r () m a
08:15:00 <copumpkin> I'd want Either to not be a monad (or a more general one), and an Error monad that resembles Maybe to be in its place
08:15:03 <mm_freak> nothing = EitherT $ \k err -> err ()
08:15:04 <copumpkin> and no fail :)
08:15:23 <mm_freak> just = return
08:15:31 <copumpkin> yeah yeah :P
08:15:35 <mm_freak> ;)
08:15:35 <copumpkin> I know how to do it
08:15:59 <copumpkin> it just feels inelegant to treat a general sum as an error-carrying thing when looking at it as a monad
08:16:23 <dankna> yes, I agree, of course
08:16:53 <dankna> I dunno that it would be appropriate to reorganize the language now though - too much existing code
08:17:11 <Saizan> copumpkin: the new base has "instance Monad (Either e)" in Control.Monad.Instances
08:17:27 <copumpkin> data Option a = forall e. Error e => Error e  | Value a
08:17:36 <copumpkin> I'd be a lot more comfortable with that being a Monad instance
08:17:51 <copumpkin> Saizan: yay
08:17:52 <mm_freak> well, it's not that bad in contstuff…  it's just that the 'right' continuation is the default continuation and the 'left' continuation is for exceptions (not "errors")
08:18:02 <mm_freak> and none of the monads define 'fail'
08:18:28 <mm_freak> originally i wanted to call EitherT ExceptionT, but found that too long
08:18:36 <mm_freak> so i went with EitherT
08:19:06 <mm_freak> it's also quite compatible with how Either is used in practice most of the time
08:19:18 <copumpkin> yeah, I object to that too :)
08:19:26 <ski> copumpkin : well .. you need to generalize your notion of "error" .. e.g. i have used an `Either [Integer]' monad :)
08:19:48 <tomh> mm where can I find the documentation for haskell-src-exts?
08:19:52 <copumpkin> oh, I'm fine with a general Monad instance for Either, let's say
08:20:11 <copumpkin> I just object to it binding fail to Left and forcing Left to contain errors
08:20:22 <copumpkin> maybe it's because I'm left-handed and am easily offended ;)
08:20:34 <copumpkin> DAMN PREJUDICE AGAINST LEFTIES
08:20:46 <ski> but `Left' *does* contain errors .. but that need have nothing to do with the `Error' class
08:21:04 <ski> in my case, the errors was the actual final result that was desired ! :)
08:21:38 <copumpkin> lol okay
08:22:14 <mm_freak> well, EitherT is an unfortunate name, but ExceptionT was too long and ErrorT too restrictive (exceptions don't need to be errors)
08:22:22 <quicksilver> You can call it 'Exit'
08:22:23 <siracusa> @hackage haskell-src-exts
08:22:24 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
08:22:26 <mm_freak> if you have a good alternative, i'll rename it
08:22:33 <siracusa> tomh: ^^^^
08:22:34 <quicksilver> if the intention is for the final result is the left part.
08:22:42 <Saizan> SumT
08:22:51 <quicksilver> data Exit a b = Finished a | StillWorking b
08:22:52 <Saizan> i guess that's just worse than EitherT
08:23:09 <tomh> siracusa, no documentation there, like a userguide I mean :)
08:23:13 <mm_freak> quicksilver: not appropriate, because exceptions can be caught and (because of the CPS stuff) the computation can even be resumed (i might add support functions for that in the future)
08:23:13 <quicksilver> is the type of computations which continue with an intermediate result of type 'b' before finally finishing with an 'a'
08:23:37 <quicksilver> mm_freak: sure, I was just naming (or giving a name) to ski's version
08:23:44 <mm_freak> ah, alright
08:23:48 <siracusa> tomh: Oh, I don't know then.
08:24:21 <tomh> ok thanks 
08:24:32 <tomh> I guess its not documented then :(
08:24:45 <mm_freak> i guess i'll leave it at EitherT =)
08:25:09 <quicksilver> then there is the Applicative but not monad version
08:25:16 <quicksilver> which sums the monoid on the left bits
08:25:36 <quicksilver> quite useful sometimes.
08:25:37 <siracusa> tomh: The parser functions at least are. Docs for what functions are you looking for?
08:26:11 <ski> mm_freak : i've used `ExnT' in the past
08:26:19 <quicksilver> ski: bless you!
08:26:28 <tomh> siracusa, just a reference guide, user manual
08:26:30 <mm_freak> copumpkin: anyway, the proper method to encode lack of a value (as opposed to errors in computation) is ChoiceT
08:26:33 <tomh> not just function documentation
08:26:34 <ski> quicksilver : .. for what ? :)
08:26:41 <mm_freak> copumpkin: or in some cases you can use Maybe as the base monad
08:26:54 <quicksilver> ski: the way I mentally vocalised that, 'ExnT' sounded like a sneeze.
08:26:59 <copumpkin> mm_freak: so what's improper about MaybeT?
08:27:07 <ski> quicksilver : hehe
08:27:13 <mm_freak> copumpkin: nothing, it's just not there =)
08:29:02 <copumpkin> :P ok
08:29:39 <ski> @hoogle (s -> Either e s) -> (s -> e)
08:29:40 <lambdabot> No results found
08:31:30 <siracusa> tomh: I don't think there's a manual, haskell-src-exts is just an AST with a bunch of parser and printer functions.
08:32:17 <tomh> yeah, well would be nice if there was documentation for it
08:32:40 <tomh> decreases the learning curve
08:32:55 <sioraiocht> aha, it's YOU 
08:32:59 <sioraiocht> who stole my desired username
08:33:28 <tomh> sorry man, its mine
08:33:33 <sioraiocht> I know
08:33:33 <sioraiocht> lol
08:33:47 <sioraiocht> although I find it funny that you also participate in #haskell
08:34:22 <tomh> hehe
08:34:32 <tomh> I guess there are a lot of tomh's :)
08:34:41 <tomh> I'm the official one though :P
08:35:41 <tomh> im willing to trade my nick here for the nick tomh at hackernews though :P
08:35:43 <tomh> if you have it
08:35:48 <sioraiocht> hahah 
08:35:56 <sioraiocht> 'fraid not
08:36:01 <tomh> damn
08:36:11 <sioraiocht> I used this name on IRC before I entered the haskell community, now I wish I had a more pronounceable one.
08:36:37 <dankna> yeah, changing nicknames isn't as easy as you'd think
08:36:41 <pumpkin> sioraiocht: I've tried pronouncing it!
08:36:43 <dankna> I've been using this one for like twelve years
08:36:45 <pumpkin> and have almost succeeded
08:36:58 <dankna> silly question... are pumpkin and copumpkin the same person?
08:37:01 <tomh> well gone for dinner
08:37:07 <pumpkin> dankna: for some values of the same person
08:37:19 <gwern> hm. at a guess, I'd pronounce it see-or-ree-och
08:37:21 <gwern> right?
08:37:23 <dankna> ... what, you share the nick with your wife who's also into Haskell, or something?
08:37:46 <dankna> everybody always pronounces my nick like the German word "danke", which is not what I intended
08:37:57 <dankna> I've been putting up with it for the entire time I've had it
08:38:03 <pumpkin> dankna: nah, just two different computers of mine that are often online at the same time
08:38:17 <dankna> gotcha.  that was my original suspicion.
08:40:48 * quicksilver didn't realise nicknames were things you pronounced.
08:40:59 <quicksilver> sioraiocht is just sioraiocht. You don't have to say it!
08:41:02 <dankna> some of us read things aloud in our heads when we read silently
08:41:04 <sioraiocht> haha
08:41:21 <dankna> encountering words we don't know actually slows down our reading comprehension
08:41:39 <dankna> I'm not saying it's the best way to be, but it's not the sort of thinking pattern one can change - it's too low-level a thing
08:41:50 <Silkjc> if I have a list L, how can I make a List of Tuples the same length as it?
08:42:00 <dankna> what should the content of the tuples be?
08:42:13 <Silkjc> lets say strings
08:42:22 <dankna> and where should their values come from?
08:42:25 <Silkjc> (that in no way reflect the values of the other list)
08:42:33 <Silkjc> initially they will all be the same const
08:42:35 <kamatsu> pumpkin: however a co-x in category theory can have very different implications, although similar structure.
08:42:47 <quicksilver> > map (const (1,1)) ["a","bv","def"]
08:42:47 <dankna> map (id "string") originalList
08:42:47 <lambdabot>   [(1,1),(1,1),(1,1)]
08:42:50 <ddarius> dankna: It's definitely a thinking pattern one can change.
08:42:55 <dankna> oh, what quicksilver said, rather
08:43:01 <kamatsu> pumpkin: do you act differently when on different accounts?
08:43:06 <Silkjc> awesome, thanks
08:43:13 <pumpkin> kamatsu: very
08:43:13 <dankna> ddarius: really?  you think?
08:43:26 <dankna> yeah - when he's copumpkin he uses the passive voice a lot more!
08:43:37 <dankna> when he's pumpkin the passive voice is not used by him
08:43:48 <ddarius> dankna: It's usually a necessary step to change that for speed reading and few people have trouble learning speed reading.
08:44:14 <dankna> hmm, my reading speed is fairly high, although I wouldn't call it speed reading, which as I understand it involves actually skimming content
08:44:21 <dankna> s/mm/pp/
08:44:42 <ddarius> Speed reading definitely doesn't involve skipping content.
08:44:44 <dankna> oh
08:44:51 <dankna> okay.  I guess I don't know what it is then.
08:45:30 <gwern> speed reading is eliminating subvocalization, faster wider saccades, and no backtracking
08:45:34 <gwern> in a nutshell
08:45:37 <dankna> I see
08:45:46 <gwern> photographic reading is the one with skimming etc
08:45:51 <gwern> and that's the scam
08:46:12 <dankna> well, I guess from what you're saying that it is indeed possible to break the thinking pattern
08:46:27 <dankna> I can't imagine how though.  I mean ALL my thoughts are in words (unless they're in code)
08:46:38 <dankna> (or pictures, I guess, but that's rare for me)
08:46:54 * hackagebot GoogleSuggest 0.0.1 - Interface to Google Suggest API  http://hackage.haskell.org/package/GoogleSuggest-0.0.1 (AndyStewart)
08:47:15 <ManateeLazyCat> Enjoy! :)
08:47:36 <dankna> nice
08:48:32 <ManateeLazyCat> It will return [(Suggestion, QueryNumber)].... :)
08:50:32 <ManateeLazyCat> Code is pretty simple (26 lines) at : https://patch-tag.com/r/AndyStewart/GoogleSuggest/snapshot/current/content/pretty/Google/Suggest.hs
08:57:31 <chrisdone> has there been any interest in getting generic deriving for ghc?
08:58:32 <ddarius> There was an old approach partially implemented quite a while ago.
08:59:21 <ddarius> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/generic-classes.html
08:59:48 <chrisdone> hm, thanks :)
09:06:06 <kdvh> how would I turn IO a into just a?
09:07:05 <pumpkin> kdvh: you can't
09:07:05 <chrisdone> that question seems to demonstrate a kind of confusion about the IO monad -- what do you mean by "turn into"?
09:07:05 <lpeterse> kdvh: unsafePerformIO
09:07:13 * pumpkin slaps lpeterse 
09:07:21 <lpeterse> *duck* i know
09:07:35 <Botje> lambdabot: slap lpeterse 
09:07:40 <Botje> boo
09:07:46 <Botje> @slap lpeterse
09:07:47 <lambdabot> stop telling me what to do
09:07:54 <Botje> pfrt.
09:07:57 <pumpkin> @slap lambdabot
09:07:57 * lambdabot jabs lambdabot with a C pointer
09:08:04 <Botje> what has the world come to if you can't even get lambdabot to slap people around
09:08:47 <poucet> @slap Botje 
09:08:47 * lambdabot beats up Botje
09:09:21 <kdvh> chrisdone: got a function that returns IO [FilePath], I want [FilePath] for use in another function
09:10:02 <monochrom> call the another function from inside IO
09:10:27 <pumpkin> kdvh: the general approach is to lift your other function into IO instead of pulling the value out of IO
09:10:41 <monochrom> do { x <- this_gives_io_[filepath]; let y = another_function x; now you can use y here }
09:11:13 <kdvh> alright, ill give that a try, thanks guys
09:12:35 <chrisdone> point is there's no IO a -> a function (ostensibly)
09:12:44 <ski> kdvh : often the `let' there isn't really needed/wanted, of course
09:13:17 <monochrom> do { x <- this_gives_io_[filepath]; now you can use (another_function x) here }
09:13:36 <tomberek> hey ski
09:14:31 <ski> yeh tomberek
09:14:38 <ManateeLazyCat> Looks many people search "haskell ide" . :) http://www.flickr.com/photos/48809572@N02/5038855165/lightbox/ 
09:14:53 <tomberek> yep
09:15:10 <monochrom> many people search "ufo exists" too
09:15:16 <imc> ghgh
09:15:31 <ManateeLazyCat> monochrom: http://www.flickr.com/photos/48809572@N02/5038855165/lightbox/ I have add Google Suggest in my browser. :)
09:15:36 <ManateeLazyCat> @package GoogleSuggest
09:15:36 <lambdabot> http://hackage.haskell.org/package/GoogleSuggest
09:15:41 <ManateeLazyCat> monochrom: ^%^^^
09:16:07 <ManateeLazyCat> monochrom: I have read that UFO news... :)
09:16:11 <chrisdone> using template haskell to connect to a database and read its schema and generate record types from it, doomed to failure, been done before?
09:17:13 <monochrom> I think it can be done and haven't been done.
09:17:34 <Silkjc> quicksilver: before when you suggested: map (const ("1","1")) outputs   , can you explain how exactly that works? is (const ("1","1")) considered a 'create tuple' function in this case?
09:17:34 <ManateeLazyCat> Have any exist code do this ? "splitNumber :: Int -> String", splitNumber 1000000 => "1,000,000"  ?
09:17:45 <monochrom> template haskell is fully capable of IO. you can talk to a database before deciding what code to generate.
09:17:55 <chrisdone> yeah
09:18:31 <chrisdone> runIO :: IO a -> Q a
09:18:34 <quicksilver> Silkjc: Would (\x -> (1,1)) be clearer to you?
09:18:49 <quicksilver> Silkjc: It's the function which, given any argument, returns (1,1)
09:18:53 <Entroacceptor> yay, I managed to produce kind errors and occurs check errors...
09:19:16 <Silkjc> ah okay, was just playing with it then and realised after I asked!
09:21:21 <quicksilver> Silkjc: I wouldn't say "create tuple" because that suggests waste of memory
09:21:31 <quicksilver> Silkjc: actually it will consistently return a pointer to the *same* tuple
09:21:37 <quicksilver> which is possible because of immutability
09:22:25 <ManateeLazyCat> > Data.List.splitEvery 3 (show 1000000)
09:22:27 <lambdabot>   Not in scope: `Data.List.splitEvery'
09:22:34 <ski> chrisdone : what about cross-compilation ?
09:24:12 <quicksilver> ski: he's not here :)
09:24:40 <quicksilver> it's obviously possible but I"m not sure it's wise. I'm not sure you want a database connection every time you compile.
09:24:52 <quicksilver> I'd rather make the database connection/schema file generation an explicit choice.
09:25:04 <ski> quicksilver : oh .. i didn't notice
09:25:07 <quicksilver> runhaskell genschema.hs
09:26:51 <ManateeLazyCat> > let splitInt xx = init $ concatMap (++ ",") $ reverse $ splitEvery 3 (reverse $ show xx)
09:26:52 <lambdabot>   not an expression: `let splitInt xx = init $ concatMap (++ ",") $ reverse $...
09:27:14 <ManateeLazyCat> > init $ concatMap (++ ",") $ reverse $ splitEvery 3 (reverse $ show 10000000000) 
09:27:15 <lambdabot>   Not in scope: `splitEvery'
09:27:24 <ManateeLazyCat> Stupid .
09:27:49 <ManateeLazyCat> splitInt 1000000 => "1,000,000"
09:31:15 <ddarius> Trusting trusting trusting trust
09:32:04 <ManateeLazyCat> Data.List.Split is good library....
09:32:31 <ManateeLazyCat> Every handy.....
09:37:18 <SleptInMathClass> http://www.haskell.org/haskellwiki/Haskell_and_
09:37:20 <SleptInMathClass> mathematics
09:37:47 <ManateeLazyCat> Hmmmm, QuickCheck break build other package....
09:39:53 <ski> ddarius : .. who ?
10:07:48 <dsouza> hey, question about cabal files
10:07:56 <dsouza> how you guys set the minimum dependency version in cabal files? I usually use the version I have available in my machine, but surely isn't the right minimum. Is there a way to find out, without brute force [=testing version by version]?
10:08:26 <rschnck> What exactly does this error mean? http://paste.ubuntu.com/503398/
10:08:53 <c_wraith> rschnck, how much do you know about type classes?
10:09:06 <rschnck> c_wraith: Null.
10:09:17 <dsouza> heh :-)
10:09:24 <Ke> it means that ghci doesn't know how to display the result
10:09:34 <rschnck> Oh?
10:09:35 <c_wraith> rschnck, ok.  A typeclass is a description of certain... interfaces, for lack of a better word, that a type implements.
10:09:40 <Ke> it's all ones and zeros without proper context
10:09:55 <c_wraith> rschnck, the Show typeclass contains the "show" function.
10:10:17 <rschnck> So unless I define StateOddEven for the show typeclass, I'll be unable to show the result?
10:10:20 <c_wraith> rschnck, In order for the "show" function to work on a type, it must be an instance of the type class.  And your type isn't an instance of Show.
10:10:40 <c_wraith> however, Show is special, in that you can have the compiler automatically derive it for you
10:10:53 <c_wraith> Just add "deriving Show" at the end of your data declaration
10:11:10 <rschnck> c_wraith: Okay :3
10:11:28 <c_wraith> There are several classes the compiler can automatically derive.  You might want to add Eq, also, with the syntax "deriving (Show, Eq)"
10:11:45 <c_wraith> Eq is the type class for things that support == and /=
10:12:52 <c_wraith> So, what that error message was telling you is that you called show on something that wasn't an instance of Show.  It was suggesting you add an instance of Show for your type.
10:13:12 <Ke> or ghci called
10:13:19 * hackagebot GoogleSuggest 0.0.2 - Interface to Google Suggest API  http://hackage.haskell.org/package/GoogleSuggest-0.0.2 (AndyStewart)
10:13:31 <c_wraith> err, yes.  I guess it is ghci that called show, that ime.
10:13:34 <c_wraith> *time
10:14:39 <c_wraith> Remember, if you type a pure expression in ghci, it implicitly puts a print in front of it.  and print is (putStrLn . show)
10:14:50 <rschnck> c_wraith: Yeah, my prof just told me to derive Eq tool.
10:14:53 <rschnck> too*
10:16:20 <rschnck> I'm the only one with these problems since everyone else uses...I forgot what the problem is called. I think a university in the Netherland makes it?
10:16:23 <rschnck> For learning Haskell?
10:16:26 <rschnck> GCHI alternative.
10:16:29 <rschnck> GHCI*
10:16:33 <c_wraith> uhc
10:16:38 <c_wraith> probably
10:16:41 <rschnck> No, something else.
10:16:53 <c_wraith> helium?
10:16:57 <rschnck> Yep
10:17:10 <c_wraith> Ah yes.  A slightly friendlier to newbies haskell.
10:17:29 <c_wraith> But it skips most of the advanced stuff. :)
10:17:30 <rschnck> I would use it, but it doesn't run on x64 bit Linux and there aren't any Helium packages for my distro
10:17:34 <rschnck> So screw that :<
10:17:59 <bremner> I don't get helium. You could just not tell people about scary things.
10:18:23 <bremner> does it add some things that make it easier?
10:18:31 <c_wraith> bremner: well, as you've seen just now, using helium allows you to skip teaching about type classes a bit longer
10:20:49 <Cale> I find that you basically just have to talk about typeclasses straight away.
10:21:12 <c_wraith> At least in enough depth to cover Show
10:21:20 <c_wraith> And probably Eq and Ord
10:21:32 <cobra> why does getProgName mess around with argv[0] instead of just returning it as is?
10:21:37 <c_wraith> And then once you start doing subtraction, Num.
10:21:51 <c_wraith> Even if you're doing subtraction accidently :)
10:21:59 <c_wraith> > f -1
10:22:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:22:01 <lambdabot>    `GHC.Num.Num a'
10:22:01 <lambdabot>      ari...
10:22:05 <pumpkin> cobra: different platforms do different things in it, iirc
10:23:06 <cobra> pumpkin: it strips out all the path information and returns the basename of the file
10:23:27 <cobra> kind of annoying
10:24:34 <benmachine> cobra: I remember some discussion about this basically concluding that people misuse argv[0] and it's not in general possible to work out where your executable is
10:24:40 <benmachine> but there are ways around it via FFI possibly
10:26:38 <cobra> benmachine: the fathers of unix decided to design argv[0] to be the way that it is. it's weird that ghc decides that it must mess around with it
10:28:34 <zygoloid> benmachine: working out where your executable is isn't necessarily the point
10:28:54 <pumpkin> cobra: the issue is that on windows, iirc, it's something else
10:29:00 <pumpkin> so it tries to be consistent
10:29:26 <zygoloid> there's a hole in the side of this abstraction and platform-specific details are leaking out!
10:32:00 <cobra> maybe the "real" function should be additionally exposed somewhere in System.Posix
10:33:16 <zygoloid> maybe it already is? ;)
10:33:58 <cobra> zygoloid: I poked around a bit and couldn't find it
10:36:00 <zygoloid> cobra: looks to me like getProgName is mangled, but (!!0) <$> getArgs is not
10:36:17 <benmachine> isn't that just the first arg though
10:36:28 <zygoloid> oh bums it drops the first one ;(
10:36:29 <c_wraith> yeah, getArgs chops off argv[0]
10:40:27 * hackagebot GoogleSuggest 0.0.3 - Interface to Google Suggest API  http://hackage.haskell.org/package/GoogleSuggest-0.0.3 (AndyStewart)
10:40:51 <Entroacceptor> how can I output some kind of Tree with HStringTemplate?
10:41:16 <Entroacceptor> err, tree structure
10:42:01 <zygoloid> cobra: something like this might work: http://hpaste.org/40242/getting_the_unmangled_argv0
10:42:07 <Entroacceptor> I tried to make it an instance of foldable, but failed miserably
10:44:04 <cobra> zygoloid: yeah, that function should be stuck somewhere in System.Posix
10:44:20 <benmachine> cobra: what *do* you want argv[0] for anyways?
10:45:44 <shapr> Are there any composable marshalling combinator frameworks? I'd like to have something like scapy in Haskell.
10:46:16 <zygoloid> shapr: no, but i have a marshal-anything library in the works ;)
10:46:32 <shapr> zygoloid: Got any code online?
10:47:05 <zygoloid> shapr: the library i'm going to build it out of is up at http://control.monad.st/repos/hades
10:47:17 <zygoloid> shapr: it's a ghc heap introspection library
10:47:49 <cobra> benmachine: printing usage information to the user. try for example running (cp -x) vs. (/bin/cp -x)
10:48:28 <benmachine> cobra: I'd just use getProgName for that but I guess it's up to you
10:50:54 <ManateeLazyCat> GoogleSuggest support local language now, example, you can use "suggest "haskell" (Just Chinese)" get suggestions that optimize for Chinese.
10:51:02 <ManateeLazyCat> Default is English behaviour...
10:51:04 <ManateeLazyCat> Enjoy! :)
10:51:27 <ManateeLazyCat> G'night, all! :)
10:52:15 <gwern> benmachine: isn't argv[0] the name of the binary it has been called as?
10:52:32 <gwern> that's quite useful if you are building a busybox clone
10:52:50 <benmachine> gwern: nah, getProgName is that
10:52:53 <benmachine> argv[0] is the path of the binary
10:52:57 <benmachine> ...I think
10:53:06 <zygoloid> not even that. argv[0] is whatever the person doing exec provides
10:53:09 <lodi> Hello cafe.  Anyone know how I can write f :: (a -> b) -> (a,a) -> (b,b) in point-free style?  I remember seeing this implemented really elegantly using arrow combinators earlier, but I can't figure it out.
10:53:11 * gwern is unsure where getPrgoName is getting the info from if not argv[0]
10:53:20 <benmachine> gwern: it's basically basename argv[0] I think
10:53:41 <pumpkin> :t join (***)
10:53:42 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
10:53:51 <monochrom> why don't you do a few simple tests to find out what argv[0] does
10:53:52 <zygoloid> it's exactly basename argv[0], for some locally-defined basename
10:54:11 <zygoloid> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/System-Environment.html
10:54:17 <pumpkin> :t join (***) :: (a -> b) -> (a,a) -> (b,b)
10:54:17 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
10:56:19 <centrinia> > join (***) id (1,2)
10:56:20 <lambdabot>   (1,2)
10:56:37 <c_wraith> > join (***) id (1, "two")
10:56:39 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
10:56:39 <lambdabot>    arising from the literal ...
10:56:45 <c_wraith> that's what I thought
10:57:03 <c_wraith> *** isn't polymorphic enough!
10:57:16 <c_wraith> Err, wait, the problem is join, not ***
10:57:27 <c_wraith> nevermind
10:58:49 <kstt> hi
10:58:56 <Cale> hi
10:59:57 <ray> > join #haskell
10:59:58 <lambdabot>   Not in scope: `haskell'Not in scope: `#'
11:00:13 <kstt> Is it me or is the String offering becoming a bit too wide
11:00:41 <benmachine> it's just you :O
11:00:42 <zygoloid> kstt: can you clarify?
11:00:56 <lodi> hmm... that 'join (***)' works, but I don't understand how the two type signatures combine...
11:01:20 <benmachine> lodi: which type signatures?
11:01:27 <centrinia> :t join
11:01:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:01:30 <centrinia> :t (***)
11:01:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:01:47 <pikhq> lodi: Function monad.
11:01:47 <ray> @let haskell = "excellent"
11:01:50 <lambdabot>  Defined.
11:01:53 <kstt> I had a tiny, tiny project to do. I am in love with Strings-as-lists so I used them for the business logic. Then I wanted a web interface, so I used a library, that would never use String anywhere, but ByteStrings. I needed an other library as well, for which author decided Data.Text was better :)
11:02:24 <ezyang> kstt: The libraries should provide appropriate marshalling functions. 
11:02:26 <benmachine> lodi: we use the fact that ((->) r) is a Monad, and that (->) is an Arrow
11:02:28 <pikhq> lodi: join on a function basically passes the next argument to the original function twice. That is, join f x = f x x
11:02:48 <ezyang> But I'm curious what the first library is, because Bytestrings are pretty far away from strings emantically. 
11:02:48 <Zao> kstt: The only odd one there is the bytestring one, as you can't reason at all about what encodings things want from their types.
11:02:49 <pikhq> Oh, and then it can simplify further because (->) is an arrow.
11:02:52 <kstt> ezyang : they do indeed, but my code is becoming a bit littered of marshalling functions ...
11:02:52 <ray> @let a # b = "an " ++ b ++ " idea!"
11:02:53 <lambdabot>  Defined.
11:02:54 <ezyang> (one is binary, and one is Unicode) 
11:02:57 <zygoloid> kstt: yeah, the lack of a single standardized way of representing human-readable text is unfortunate
11:03:04 <ray> >join #haskell
11:03:15 <ray> > join #haskell
11:03:15 <lambdabot>   Ambiguous type variable `m' in the constraint:
11:03:16 <lambdabot>    `GHC.Base.Monad m'
11:03:16 <lambdabot>      a...
11:03:18 <Zao> If they even want text at all.
11:03:24 <Zao> Or like, chunks of bytes.
11:03:30 <ray> nooooo bind tighter
11:03:38 <Cale> kstt: Yeah, it can be a bit much at times. Text is awesome, but not much uses it yet. ByteString is inappropriate for text, but is the appropriate datatype for text that has been encoded for transfer in a particular format. String is usually nice for small programs, but it's quite slow compared with the others.
11:03:39 <zygoloid> @undef
11:03:52 <zygoloid> @let a # b = a ["an ", b, " idea!"]
11:03:53 <lambdabot>  Defined.
11:03:59 <zygoloid> > join #haskell
11:04:01 <lambdabot>   Not in scope: `haskell'
11:04:09 <zygoloid> @let haskell = "excellent"
11:04:11 <lambdabot>  Defined.
11:04:11 <zygoloid> > join #haskell
11:04:13 <lambdabot>   "an excellent idea!"
11:04:19 <benmachine> wooooo
11:04:19 <zygoloid> ray: ftfy
11:04:21 <ray> oh right that
11:04:25 <ray> duh
11:04:47 <lodi> pkhq, benmcahine: ahh... okay, so it passes 'f' twice to (***) which tuples up the function, I think I get it
11:04:51 <ray> i should probably be asleep
11:04:52 <kstt> ezyang: Snap uses BS
11:04:56 * cizra ponders
11:05:13 <ezyang> kstt: Curious. 
11:05:16 <cizra> I want to teach a newb programming. What would be a better choice, Haskell or Lisp? Perhaps Python?
11:05:26 <shapr> cizra: Depends on what you want to teach them, and where they want to go.
11:05:29 <ezyang> cizra: Quite frankly, none of them. 
11:05:31 <cizra> (heh, #haskell is the stupidest place to ask this (; )
11:05:38 <shapr> cizra: Python is good for getting started quickly, and making money soon...
11:05:46 <benmachine> cizra: haskellhaskellhaskellhaskell
11:05:49 <ray> scheme is the classic answer
11:05:51 <shapr> cizra: Haskell is better for becoming a wizardly programmer over the long term.
11:05:55 <bremner> ezyang: I'm curious, what is better than all of them?
11:06:35 <kstt> bremner: ezyang just wanted to discourage anyone from teaching programming to any still pure saoul
11:06:40 <ezyang> bremner: I kind of like the idea of stratified languages, that you can add feature onto. 
11:06:43 <ray> c is the unixbeard answer, scheme is the mit answer, haskell is the #haskell answer
11:06:45 <ezyang> *features. 
11:06:56 <monochrom> python or haskell is good for beginners. (I would add scheme if it had real algebraic data structures and pattern matching.)
11:07:14 <pumpkin> monochrom: python doesn't either though :o
11:07:14 <ezyang> It matches how we try to teach languages, and prevents people from cheating and circumventing pedagogical exercises... 
11:07:15 <zygoloid> cizra: just give 'em SICP ;)
11:07:15 <Cale> cizra: Haskell is a decent answer to that question. Scheme has the advantage of SICP.
11:07:17 <cizra> shapr: My goal is to teach general principles of programming (look ma, I added these numbers!) with simple data-processing applications (look ma, I solved my homework with a program!)
11:07:29 <ray> if we perform the rare triple synthesis, a dangerous act that hegel died in a disastrous attempt at
11:07:37 <kstt> Well, I'd argue against python because of the lack of Object consistency
11:07:42 <Cale> cizra: But if you're going to teach directly, then Haskell should do fine :)
11:07:49 <kstt> Ruby does a bit better on that front at least
11:07:49 <monochrom> python has OO which makes up for lack of algebraic data structures.
11:07:51 <ray> the answer is to implement scheme in haskell in C
11:07:58 <bremner> scheme has better pattern matching options than python fwiw 
11:08:07 <cizra> zygoloid: SICP is sometimes way over my head, and I have lotsa experience. For a newb, it's a certain death
11:08:14 <kstt> CL has deconstructive-bind
11:08:16 <ezyang> bremner: Pattern matching in scheme is still kinda clunky. 
11:08:20 <kstt> but it sucks
11:08:21 <Cale> ray: I think it might make more sense to implement Haskell in Scheme in C.
11:08:22 <zygoloid> ray: #haskell may be the only prog language channel on freenode where you won't be told "use our language!"
11:08:29 <zygoloid> (at least not by everyone)
11:08:44 <benmachine> I saw someone implement pattern matching in java by throwing and catching exceptions
11:08:46 <bremner> ezyang: sure, but in python, it doesn't exist
11:08:50 <benmachine> it was giggleworthy
11:08:53 <Cale> zygoloid: Except in #lisp where you'll be told to use Haskell.
11:08:58 <Cale> ;)
11:08:59 <lodi> pkhq, benmachine: ok thanks guys
11:09:02 <ezyang> I mean, a compilers class that is about "let's bootstrap a compiler from assembly to C to <something> to Haskell" would be really cool. 
11:09:11 <zygoloid> cizra: i had good experiences teaching a newb python. he's now a c++ programmer so i clearly failed as a teacher... ;)
11:09:12 <cizra> zygoloid: heh, that's very good
11:09:14 <ezyang> bremner: Yeah. I think Scheme-like languages have this scheme. 
11:09:14 <bremner> or in #c++, where you'll be told to fuck off
11:09:33 <ray> cale: to be more traditional, haskell in scheme in scheme in c
11:09:43 <ezyang> If you want to instill an appreciation of the power of automation, PHP might even be a good answer. 
11:09:51 <centrinia> There is even a #brainfuck.
11:09:53 <ray> no, #c is the fuck off channel, silly
11:09:56 <ezyang> It is fantastically easy to get started in (and not much else) 
11:10:06 <zygoloid> ray: or haskell (fix (in scheme))
11:10:06 <benmachine> the fuck off response is not actually very rare on IRC >_>
11:10:36 <monochrom> in #haskell, we tell you to fuck on
11:10:36 <ray> if one channel is *the* fuck off channel it is #c
11:10:42 <benmachine> hah
11:10:51 <zygoloid> ezyang: i can't rightly comprehend anyone forming a clear understanding of /anything/ by using PHP
11:10:54 * Cale plays guess-the-coordinate-system with a 10 minute build time *whistle*
11:11:01 <rothwell> you might be threatened with violence just for calling it #c and not ##c
11:11:08 <shapr> cizra: I like Haskell because mutable variables don't make any sense from a math perspective.
11:11:38 <zygoloid> the sheer volume of confusion which has been pumped into PHP has to leak out somewhere
11:11:41 <ezyang> zygoloid: I teethed on PHP. Must 've done something "right" :-) 
11:11:59 <shapr> I teethed on BASIC and Visual Basic, and still survived... sort of.
11:12:02 * shapr twitches
11:12:03 <monochrom> I have a friend who testified that when he learned BASIC he couldn't stand "X = X + 1"
11:12:05 <zygoloid> ezyang: oops, sorry. tell you what, i'll buy you a pint when you get to cambridge ;)
11:12:11 <Cale> shapr: Same here.
11:12:16 <ezyang> zygoloid: I'm at Cambridge right now :-) 
11:12:27 <centrinia> Cale: Same here.
11:12:31 <benmachine> I'll be at cambridge by the end of the weekend :o
11:12:33 <cizra> My path was QBASIC -> C -> C++ -> Ruby -
11:12:46 <cizra> -> Python -> Scheme -> whatever else I've sniffed
11:12:48 <zygoloid> ezyang: then i'm LATE! ;)
11:12:50 <ray> at least in calculator basic it's x+1->x
11:13:20 <centrinia> @let x=x+1
11:13:21 <lambdabot>  <local>:3:2:
11:13:21 <lambdabot>      Ambiguous occurrence `x'
11:13:21 <lambdabot>      It could refer to either `L....
11:13:36 <centrinia> @let foobar=foobar+1
11:13:37 <lambdabot>  Defined.
11:13:40 <benmachine> > let x = x + 1 in x
11:13:43 <lambdabot>   mueval-core: Time limit exceeded
11:13:45 <zygoloid> benmachine, ezyang: time for a cambridge haskell user group of some sort? by which i mean a curry... ;)
11:13:50 <benmachine> zygoloid: woooo
11:14:18 * zygoloid ponders inviting the simons ;)
11:14:19 <ezyang> mmmmmm 
11:14:36 <Veinor> I'm in cambridge!
11:14:40 <Veinor> but the wrong one
11:14:45 <zygoloid> ;(
11:15:27 <ray> > let (+) = const in let x = 1 + x in x
11:15:28 <lambdabot>   1
11:16:23 <benmachine> :t undefined :: Natural
11:16:24 <lambdabot>     Not in scope: type constructor or class `Natural'
11:16:31 <benmachine> wish we still had that around, it was fun
11:20:04 <monochrom> I started with basic too. I just couldn't stand gosub. I wanted to use it but it's cumbersome to use. Then at university I met pascal and I saw how to articulate gosub's problem: it lacks parameters and return values. (And now shameless plug.) With parameters and return values, I could finally use recursion, and that's when I reached enlightenment (as opposed to other people's getting confused by recursion).
11:24:20 * ddarius started with QBASIC.
11:27:47 <Cale> Yeah, QBasic and QuickBasic had functions with parameters and results.
11:27:48 <kaol> Someone write a Haskell port of Gorillas.
11:28:19 <cobra> Cale: what is your website?
11:28:25 <Cale> cale.yi.org
11:28:33 <Cale> (hopefully it's up)
11:28:34 <cobra> thanks
11:28:53 <jystic> @pl git repo op = (runReaderT $ runErrorT $ runGit op) repo
11:28:53 <lambdabot> git = flip (runReaderT . runErrorT . runGit)
11:29:26 <monochrom> heh
11:29:41 <monochrom> this is why I don't like $
11:30:29 <Martty> oh boy Cale 
11:30:37 <Martty> that fold wiki article is biased!
11:30:56 <Martty> whats that bit on "Universality" doing there!?
11:31:01 <monochrom> every fold picture is biased
11:31:31 <cobra> Cale: Is "How To Use Monad Transformers" still relevant today, or are there new techniques?
11:33:04 <Cale> cobra: I think it's still relevant. I recommend using monad transformers sparingly.
11:35:25 <Cale> cobra: In fact, one of the things that I don't like about that article is that I built the monad over IO, which is something that I basically never do.
11:35:31 <cobra> Cale: I have some functions in IO monad, and now I need to modify all of the functions so they have read only access to a configuration string. I could pass it as a parameter to every function, but I was thinking it would be better to use a special monad with a "getConfigString" action
11:35:34 <Cale> (I don't transform IO)
11:36:19 <cobra> Cale: I'm pretty much stuck with IO right now
11:36:24 <Cale> Well, that's a valid approach. Usually I actually prefer just passing a parameter, but bundling parameters together in an appropriate way.
11:37:01 <Cale> So if you have a bunch of related configuration information, don't pass it all as separate parameters, define a new datatype and just pass it as a single parameter where it needs to go.
11:37:24 <cobra> Cale: the thing is, only a few functions need access, but they are called from a long chain of outer functions, so I would have to thread this parameter everywhere
11:37:40 <cobra> Cale: apart from this single string, there is no other configuration information
11:38:38 <Cale> Well, feel free to try ReaderT, but in my experience if you put it side by side with the plain parameter passing code, it's usually not any better.
11:38:51 <Cale> Since you end up with lots of liftIO
11:39:22 <cobra> yeah, but you can lift whole chunks of code with liftIO
11:40:04 <ddarius> Global single assignment var, mwuahaha!
11:40:10 <Cale> You can pass a parameter to whole chunks of code too.
11:43:07 <cobra> Cale: Is the littering of code with calls to liftIO the only downside to the approach?
11:43:11 <monochrom> putStrLn :: (MonadIO m) => String -> m ()
11:45:40 <ddarius> io = const
11:46:04 <ddarius> s/liftIO/return for extra confusion
11:48:05 <chrisdone> hai
11:49:06 <tg_> don't show Q'x or Q'y
11:49:19 * tg_ retracts that
11:49:37 <tg_> tune measurments for the LHC
11:49:56 <dmwit> ?djinn [(a -> r) -> a] -> ([a] -> r) -> [a]
11:49:56 <lambdabot> Error: Undefined type []
11:50:02 <monochrom> do { n <- readLn; mapM_ print (do { x<-[1..n]; y<-[1..n]; return (x,y,x*y) }) }
11:50:11 <monochrom> you can say I'm in deep do-do
11:50:16 <dmwit> ?djinn List ((a -> r) -> a) -> (List a -> r) -> List a
11:50:16 <lambdabot> Error: Undefined type List
11:51:20 <monochrom> LHC = large haskell compiler?
11:52:41 <dmwit> ?djinn f a -> f a
11:52:41 <lambdabot> f a = a
11:53:02 <monochrom> "we will build a haskell compiler 3 times larger than GHC. it will need cooling to near absolute zero to work. it will find God's type error."
11:53:31 <Cale> cobra: For the most part. There's also the bit of overhead in the fact that you're using ReaderT in the first place (so you have runReaderT and the module imports and the dependency on mtl)
11:54:42 <Cale> and if you want to do it right, a newtype
11:55:13 <Cale> (Otherwise, a good bit of elaboration in all your type signatures)
11:55:36 <Cale> cobra: It also makes it difficult to use IO-specific higher order functions.
11:56:31 <Cale> Obviously, those which work over any monad are fine.
12:00:02 <cobra> hm...
12:02:04 <Cale> It's not something which is going to make or break the entire design of your program in any case.
12:02:37 <Cale> But I usually find that passing the parameter explicitly isn't so bad, and at the very least, it makes it a little clearer which parts of the program actually need it.
12:04:17 <astor> How can I install cabal packages that depend on base 3 when I only have base 4 (ghc 7.1)?
12:05:08 <roconnor> astor: persumably you can't 
12:05:09 <Cale> astor: I guess you can't.
12:05:27 <Cale> You could update them to work with the new version of base, which shouldn't be too much work.
12:05:30 <roconnor> astor: well, you could install an earlier ghc 
12:05:46 <roconnor> Cale and I have differing opinions :D
12:06:14 <astor> ok. thanks!
12:06:21 <Cale> (Well, it might be too much work!)
12:06:40 <roconnor> (your distro might not like having two copies of ghc)
12:07:57 <monochrom> perhaps the package doesn't absolutely require base-3
12:08:10 <astor> my distro has ghc 6.8.  cabal didn't compile, darcs didn't compile.  darcs was 1.x.  darcs couldn't get the ghc repo.  lots of circular dependencies :-)
12:09:12 <roconnor> astor: time to switch to nixos
12:09:27 <roconnor> (actually I'm not sure how well cabal install plays with nixos)
12:09:49 <Cale> I've never relied on my distribution to provide good Haskell-related packages.
12:09:57 <Cale> The linux binary GHC is good enough for me :)
12:10:09 <imc> I ~do, haskell gentoo overlay :P
12:10:27 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
12:10:33 <roconnor> imc: can you have two versions of GHC installed at once?
12:10:42 <imc> roconnor: i tell you in 1 minute
12:10:52 * ddarius can't find furniture that he can get into his apartment.
12:10:54 * roconnor starts the clock
12:11:04 <roconnor> ddarius: ikea?
12:11:27 <monochrom> "serialize"
12:11:47 <chrisdone> in soviet russia, furniture can't find apartments it can get into YOU
12:11:48 <imc> roconnor: nope
12:11:53 <monochrom> use the binary or cereal package to move furniture
12:11:56 <imc> maybe two major different version...
12:11:58 <roconnor> imc: time to switch to nixos
12:12:00 <roconnor> :)
12:12:04 <HugoDaniel> hi
12:12:10 <cobra> how do you join a thread?
12:12:11 <HugoDaniel> im trying to create a cabal package
12:12:17 <ddarius> roconnor: Looked there.  The few pieces of furniture that weren't hideous wouldn't fit other than a desk and a coffee table.  The real problem is chairs and a couch.
12:12:19 <chrisdone> hey daniel
12:12:24 <HugoDaniel> but it breaks when i try to runhaskell Setup.hs build, saying it can't find maybe module :/
12:12:31 <HugoDaniel> but i have it on the dependencies
12:12:42 <roconnor> ddarius: the problem is fitting into the room, rather than fitting into the door?
12:12:49 <HugoDaniel> is this normal ?
12:12:50 <imc> roconnor: reading about it right now...
12:12:56 <chrisdone> HugoDaniel: http://hpaste.org/
12:12:56 <monochrom> you have to write your own code to join a thread. use an MVar. the child writes to the MVar when done. the parent waits on that.
12:13:02 <ddarius> roconnor: Door.
12:13:04 <HugoDaniel> :D
12:13:05 <HugoDaniel> yes
12:13:07 <HugoDaniel> sorry
12:13:27 <roconnor> ddarius: ikea furnature wouldn't fit through your door?
12:13:40 <imc> roconnor: "purely functional package management" :D
12:13:45 <monochrom> most ikea furnitures are serialized.
12:13:54 <imc> monochrom: :)
12:13:55 <astor> for example leksah has a dependency on base < 4.3 .. why do packages have that sort of dependency?  Is it known that 4.3 breaks backwards compatibility (a minor release)?
12:13:59 <cobra> monochrom: I'm not sure I can do that, since I am actually killing the thread, and I want to wait for it to die
12:14:06 <ddarius> roconnor: One of the chairs I was looking at comes in a 35" cube box.  My doorway is ~31".
12:14:23 <roconnor> astor: it is required to put an upperbound on base, and suggested to put an upperbound on everything
12:14:29 <imc> ddarius: unpackage the box before your door
12:14:32 <roconnor> ddarius: ouch
12:14:39 <ddarius> imc: The chair is 34" wide.
12:14:44 <monochrom> the child "try { do its thing } finally { write to MVar }"
12:14:47 <imc> ddarius: a chair is not a cube
12:15:06 <roconnor> ddarius: I thought all the ikea furnature was boxed in flat rectanguals
12:15:25 <chrisdone> sometimes you have to have the window temporarily taken out to get furnature in
12:15:29 <astor> roconnor: so it's better to refuse to install than to get a compile error?  can I force cabal to try?
12:15:31 <ddarius> roconnor: A lot of it is.
12:15:37 <cobra> monochrom: but what if killThread is called just as the child enters the finally block, but before it writes to the MVar?
12:15:42 <HugoDaniel> http://hpaste.org/40243/cabal_error  help plz
12:15:43 <HugoDaniel> :)
12:15:45 <ddarius> chrisdone: That wouldn't be worth the effort.
12:15:57 <chrisdone> ddarius: sounds like a crappy couch :p
12:16:12 <roconnor> astor: maybe I'm not sure
12:16:25 <chrisdone> ddarius: think how amazing it would be to sit on a couch worth taking your window out for
12:16:30 <imc> roconnor: i really *LIKE* nixos!
12:16:39 <roconnor> imc: most people do
12:16:49 <roconnor> join #nixos
12:17:03 <imc> roconnor: the most important thing is the name... "what distro are you using?" "Nix!"
12:17:09 <Cobra__> HugoDaniel: use import Data.Maybe instead of import Maybe
12:17:11 <monochrom> cobra: the finally part actually is protected from being killed.
12:17:19 <roconnor> imc: sadly nixos is the distro
12:17:26 <roconnor> imc: nix is the package manager
12:17:29 <Cobra__> or add haskell98 to build-depends
12:17:32 <Cale> HugoDaniel: Rather than importing Maybe, import Data.Maybe
12:17:33 <roconnor> imc: and nixpkgs is the package collection
12:17:40 <HugoDaniel> ah ok
12:17:41 <HugoDaniel> thanks
12:17:47 <imc> roconnor: yeah, is a nix-ish thing anyway
12:17:56 <cobra> monochrom: hm...
12:18:17 <astor> anyone heard of a paxos library for haskell?
12:19:38 <HugoDaniel> now its saying: Could not find module `Data.Vector.Unboxed' :( let me hpaste it
12:22:25 <hape_> what is linq in haskell, is there a static type checked "sql" like thing?
12:22:35 <HugoDaniel> http://hpaste.org/40244/caba_error  help plz :)
12:24:05 <Cale> HugoDaniel: Well, that's odd. That should be in the vector package.
12:24:05 <pumpkin> oh nice, noise
12:24:39 <Cale> hape_: There's HaskellDB
12:24:43 <chrisdone> yeah, hugo hacks on some pretty programs :P
12:24:53 <hape_> @Cale: Thanks
12:24:53 <lambdabot> Unknown command, try @list
12:25:00 <hape_> Cale: Thanks
12:25:37 <HugoDaniel> chrisdone:  :) im not a "tryhaskell" grade programmer yet, but i hope i can get there soon 
12:25:56 <dmwit> > [x | y <- [1..], let x = y^2, let s = show x, s == reverse s, even (length s)]
12:25:59 <lambdabot>   mueval-core: Time limit exceeded
12:26:05 <dmwit> > take 3 [x | y <- [1..], let x = y^2, let s = show x, s == reverse s, even (length s)]
12:26:09 <lambdabot>   mueval-core: Time limit exceeded
12:26:37 <dmwit> The third one is largish.
12:26:40 <dmwit> > take 2 [x | y <- [1..], let x = y^2, let s = show x, s == reverse s, even (length s)]
12:26:44 <lambdabot>   [698896,637832238736]
12:27:01 <Cale> hape_: If you're new to Haskell, you might find it pretty daunting, especially as there are not so many good tutorials on how to use it.
12:27:29 <hape_> Cale: Yes that was my first thought - the Homepage is quite "little" ...
12:28:38 <HugoDaniel> Setup.hs: At least the following dependencies are missing: vector -any
12:28:40 <HugoDaniel> but i have it
12:28:41 <HugoDaniel> :/
12:28:50 <dmwit> Is it installed both locally and globally? ;-)
12:28:56 <HugoDaniel> locally only
12:29:05 <dmwit> Are you compiling your thing using your local package database?
12:29:15 <HugoDaniel> i dunno :/
12:29:19 <dmwit> e.g. with --user?
12:29:22 <HugoDaniel> no
12:29:28 <dmwit> Perhaps you should do so.
12:29:32 <Cale> User *should* be the default
12:29:42 <Cale> But maybe by accident global is.
12:29:45 <dmwit> User is the default for cabal-install, but not for cabal itself.
12:29:58 <Cale> oh
12:30:06 <HugoDaniel> so ghc-options: --user ? :P
12:30:07 <dmwit> HugoDaniel: Anyway, the way to do it is Setup configure --user.
12:30:21 <HugoDaniel> how do i make it default ?
12:30:31 <Cale> Wait, why are you running Setup.hs directly? Why not use cabal-install to do it?
12:30:35 <dmwit> You use cabal-install. ;-)
12:30:48 <HugoDaniel> runhaskell Setup.hs configure --user
12:30:50 <HugoDaniel> it worked
12:30:51 <HugoDaniel> hmm
12:30:56 <dmwit> Try just running "cabal build", for example.
12:30:57 <Cale> Don't do that
12:30:58 <HugoDaniel> Cale: im trying to write a cabal package for this
12:31:14 <Cale> cabal install  from a directory with a .cabal package in it will install the package
12:31:47 <Cale> (and as dmwit points out,  cabal build  to just build the package)
12:32:57 <HugoDaniel> "Warning: Module `Prelude' is deprecated"
12:33:05 <HugoDaniel> why is this ?
12:33:17 <Cale> Prelude from the old base package is deprecated
12:33:17 <dmwit> Change your dependency on "base" to include, e.g., >=4
12:33:22 <monochrom> the default of using base-3 when you just say base
12:33:34 <HugoDaniel> ah ok
12:33:50 <dmwit> ...the warning should also say this.
12:33:53 <dmwit> So RTFE. ;-)
12:33:59 <HugoDaniel> :D
12:34:03 <HugoDaniel> sorry for that one
12:34:05 <HugoDaniel> :)
12:34:08 <HugoDaniel> Registering Noise-0.0.1...
12:34:08 <monochrom> funny thing is if you say "base >=1" you will get base-4 in this special case
12:34:10 <HugoDaniel> allright
12:34:12 <chrisdone> E = ?
12:34:25 <dmwit> error
12:35:16 <HugoDaniel> very nice good
12:35:17 <HugoDaniel> :)
12:35:21 <HugoDaniel> i did a cabal package
12:35:26 <HugoDaniel> now im going to litter hackage
12:36:00 <hape_> Cale: Why there is so few strongly typed Database Tools for Haskell?
12:36:06 <hape_> Cale: I cant understand....
12:36:33 <Cale> hape_: Have you looked through http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
12:36:33 <Cale> ?
12:36:39 <monochrom> don't try to understand demand-supply phenomena like this
12:37:47 <dmwit> > 64030648^2
12:37:48 <lambdabot>   4099923883299904
12:38:17 <hape_> Cale: is there an active one beside HaskellDB which is Strongly typed?
12:39:06 <dmwit> ?index pmap
12:39:07 <lambdabot> bzzt
12:39:11 <dmwit> ?hoogle pmap
12:39:11 <lambdabot> No results found
12:40:51 <Cale> hape_: The tricky thing about doing statically typed database interactions is that the database is a thing which is separate from the program and has its own type system. To determine the type of the rows of some table, you have to access the database at compile time.
12:41:04 <astor> when implementing a DSL in haskell, is there a way to control the resources used by executing a program in the DSL, such as memory or cpu time?
12:41:36 <Cale> hape_: Or rely on the programmer to write out the database schema by hand, or use a code-generating tool of some sort.
12:41:42 <astor> (I see lambdabot timing out for example, but it might use a separate process model)
12:42:06 <Cale> astor: It uses separate processes.
12:42:41 <hape_> I use static typed/checked database integration in the language itself since 10 years running Abap from sap ag. But now I would like to move to Haskell...
12:42:54 <hape_> ... and that seems difficult ...
12:43:48 <Cale> hape_: Somehow there's not a *huge* interest in traditional SQL database interaction still. A lot of projects seem to use other means of persisting data.
12:44:57 <hape_> Cale: yes I agree with you. Happstack e..g uses an RAM cloud database with transactions, that is intersting too.
12:46:44 <Cale> There's apparently Takusen, which I don't know much about
12:47:12 <Cale> There's HDBC, but it doesn't provide all that much type safety.
12:47:58 <Cale> Oh, there's Michael Snoyman's new persistent library.
12:48:08 <Cale> It has a postgresql backent.
12:48:10 <Cale> d*
12:48:25 <Cale> (along with a sqlite one)
12:48:27 <chrisdone> Cale: yeah, I'm thinking of maybe using TH to talk to postgresql at compile time to gather the schema types
12:49:33 <Cale> Michael seems to love quasiquoters.
12:49:41 <chrisdone> hehe
12:50:04 <Zol> Why should you use Fsharp over Haskell?
12:50:06 <Cale> I find they make his demos a bit mysterious
12:50:07 <chrisdone> hape_: haskelldb is pretty neat
12:50:14 <Cale> Zol: Because you want to run on .net
12:50:26 <Cale> (and not on anything else)
12:50:30 <bremner> or you run a company that makes money from F#
12:50:37 <Cale> lol
12:50:46 <dolio> Cale: So, Peaker (inadvertently, I think) discovered a case in which 'f . g $ x' is not really interchangeable with 'f $ g $ x'.
12:50:57 <Cale> dolio: oh?
12:51:06 <Cale> dolio: Does it involve other infix operators?
12:51:13 <dmwit> no, rank-2 types =)
12:51:13 <dolio> No. Higher-rank types.
12:51:15 <chrisdone> I discovered that with rankn types
12:51:19 <chrisdone> hahha, yeah
12:51:20 <Cale> oh, weird
12:51:30 <Zol> thanks!
12:51:31 <dolio> runST $ forever $ do ... works with left-to-right instantiation.
12:51:36 <dolio> runST . forever $ do does not.
12:51:41 <Cale> Oh, that awful hack thing they included.
12:51:46 <chrisdone> I had the same thing with takusen and my own existential types
12:51:53 <dolio> The latter would require type-level lambdas, effectively.
12:52:04 <Cale> That's probably not permanent anyway. I wouldn't want to rely on it working.
12:52:14 <dolio> Cale: They seem to have re-introduced it in GHC 7.
12:52:44 <dolio> It was out for a while.
12:53:29 <dmwit> hum
12:53:35 <dmwit> What do I have to know to use parMap correctly?
12:53:48 <dmwit> I've written a program with parMap, but it still seems to use only one core.
12:54:05 <Cale> dmwit: Run the program with +RTS -N4
12:54:11 <dmwit> herp derp
12:54:12 <Cale> dmwit: Or however many cores.
12:54:39 <chrisdone> I like that I can write concurrent programs, compile and run it, and it will do nothing
12:54:49 <chrisdone> ``You forgot -threaded!''
12:54:54 <dmwit> yeah =/
12:55:32 <edwardk> chrisdone: hah. i think that has happened to a lot of us at different points
12:55:36 <sm> chrisdone: you like that ?
12:55:49 <Twey> chrisdone: Haha :-D
12:56:02 <dmwit> Ah, there we go.
12:56:19 * ddarius has only one core so he never uses -threaded.
12:56:25 <dmwit> Now we're maxing out all four cores... but it seems to be going slower in fact. =P
12:56:45 <gwern> last-core slowdown/
12:57:19 <dmwit> Still way slower even with -N3 instead of -N4.
12:57:34 <gwern> when I wish to frighten children at night, I whisper to them: space leak... last-core slowdown... type error
12:57:38 <ddarius> dolio: It possible that they implemented impredicativity properly in 7.
12:57:42 <ddarius> That's what I hope at least.
12:58:02 <dmwit> 50s for the single-threaded implementation, 150s and counting for -N3
12:58:11 <Cale> I thought that impredicative types were out for 7.
12:58:17 <ddarius> dmwit: Sounds like you did something wrong.
12:58:21 <dmwit> no doubt
12:58:30 <chrisdone> ddarius: what's a good paper on impredicativity that I will understand? GHC suggested it once or twice when I was making mistakes with existential types
12:58:40 <Cale> dmwit: Be careful about starting too many tiny sparks.
12:59:06 <Cale> dmwit: par is cheap, but it's not free
12:59:31 <Cale> Also, be sure that you're actually using the results computed by the sparks.
12:59:45 <dmwit> Well, I'm printing them.
12:59:46 <benmachine> I thought impredicative types were being dropped
12:59:51 <Cale> Well, with parMap, that should work out okay
12:59:56 <Cale> yeah
13:00:05 <ddarius> chrisdone: All impredicativity means (in this context) is that you can instantiate polymorphic types with polymorphic types.  However, with the way the were half implemented in GHC, I wouldn't recommend using them.
13:00:41 <Cale> chrisdone: Things like  Maybe (forall a. [a] -> [a])
13:03:06 <Cale> dmwit: Maybe try parListChunk
13:04:03 <chrisdone> Cale: how does this one differ to a rank-2 type?
13:04:17 <dolio> ddarius: Well, not perfectly yet.
13:04:32 <dolio> If you try: id :: (forall a. a) -> (forall b. b) you get a type error.
13:04:41 <dolio> Cannot match rigid b against (forall a. a).
13:04:47 <chrisdone> Cale: because, as ddarius says, of the use of the polymorphic type constructor []?
13:04:56 <dolio> I've got a bug report in on that one.
13:05:09 <Cale> chrisdone: Yeah
13:05:24 <chrisdone> ah, neat
13:05:29 * hackagebot hoauth 0.3.2 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.3.2 (DiegoSouza)
13:05:39 <Cale> chrisdone: Well, actually Maybe
13:05:44 * dolio has to skedaddle.
13:05:48 <Cale> Maybe is being applied to a polytype, not a monotype
13:05:59 <chrisdone> ah, true
13:06:07 <chrisdone> Maybe (forall a. a) would be rank-2
13:06:13 <chrisdone> (right?)
13:06:18 <dmwit> oy
13:06:34 <Cale> impredicative
13:06:36 <dmwit> Is parMap sparking every single element of the list? Not just the ones that get demanded?
13:06:41 <dmwit> Yes, of course it must.
13:06:42 <dmwit> duh
13:07:09 <Cale> Though, I guess you might call it that. It's just a different definition of rank that you'd need.
13:07:38 <chrisdone> I see. my understanding of rank-n types is kind of wishy washy
13:08:36 <ddarius> chrisdone: Consider dolio's id example.
13:08:45 <Cale> The rank n types extension specifically works with functions. So, rank 2 types let you have functions which have polymorphic parameters.
13:10:31 <gwern> man wget sucks. why does it suck so much? it must really suck if I can specify --exclude and it interprets --exclude as 'download that page for no reason whatsoever and *then* delete it so I can pretend I followed the spirit of the option'
13:10:51 <gwern> hopefully curl doesn't suck quite so much suck
13:10:52 <Cale> (And it lets you do this with data constructors which of course are a special sort of function)
13:11:05 <Botje> gwern: my wget doesn't even have an exclude :'(
13:11:15 <Botje> trade? :)
13:11:22 <gwern> Botje: that'd be better than the --exclude I have, which IS A LIE
13:11:24 <gwern> the exclude is a lie!
13:11:29 <ddarius> gwern: Write the five lines of tagsoup code...
13:12:00 <monochrom> dear gwern: perhaps --exclude still downloads the thing if you are chasing all hyperlinks
13:12:03 <gwern> ddarius: yeah, and also write all the convert-html-files-to.html-suffix, and all the -make-all-links-local, and...
13:12:11 <gwern> wget is not trivial
13:12:32 <gwern> monochrom: well, I haven't bothered to see whether dropping --mirror fixes --exclude's brain-damage
13:12:34 <chrisdone> Cale: ah, that elucidates it
13:12:47 <Botje> gwern: okay, let's call it an even 100 lines :P
13:12:49 <monochrom> --mirror explains it.
13:13:03 <Cale> I've done that. I wrote a program using tagsoup to find and download the latest versions of my city's bus schedule PDFs because the site they're hosted on is slow.
13:13:09 <gwern> Botje: the best 100 lines is the one you didn't have to write
13:13:18 <chrisdone> tagsoup++
13:13:20 <ddarius> Botje: 100 seems high.
13:13:28 <FunctorSalad> gwern: are you sure it didn't download it for some other explanation than --exclude behaving like this..?
13:13:38 <Botje> ddarius: i wrote a webserver in 100 lines!
13:13:47 <gwern> FunctorSalad: no. nor am I sure there isn't a little AI in my computer laughing at me and screwing everything up
13:14:15 <FunctorSalad> gwern: "`--exclude-domains DOMAIN-LIST' Specify the domains that are _not_ to be followed."
13:14:18 <gwern> I guess I will try httrack. curl doesn't do any recursive downloading or mirroring, apparently
13:14:28 <ddarius> Botje: I wrote a Prolog interpreter, parser and all about 80 wc -l lines.  I wrote a web server in less than 100 lines of Java.
13:14:40 <FunctorSalad> I think "--exclude" doesn't exist as Botje said, and you abbreviated --exclude-domains
13:14:41 <ddarius> (Admittedly, a -very- simple web server.)
13:14:47 <gwern> FunctorSalad: where is the domain in a filename-to-be-ignored like "*?revision=*"?
13:14:58 <Botje> mine even supported a stupid version of CGI :p
13:15:13 <ddarius> Botje: How do you make CGI stupider?
13:15:17 <FunctorSalad> gwern: GNU programs generally support unique prefix abbreviaton for long options
13:15:48 <Botje> it launched the program pointed to, without setting any variabels
13:15:51 <FunctorSalad> and since I can't find --exclude, it must have abbreviated --exclude-domains
13:15:51 <Botje> *variables
13:16:04 <chrisdone> ddarius: "reddit clone in 100 lines"
13:16:52 <FunctorSalad> gwern: oh, I'm wrong. The 'info' doc does have exclude
13:17:19 <programble> dom96 told me to tell you this
13:17:19 <FunctorSalad> it's an alias for "--exclude-directories" though
13:17:22 <chrisdone> (read: the rudiments of an incomplete prototype of a mock skeleton, shadow of the aforementioned ``cloned'' program)
13:17:29 <programble> *ing * in Haskell is a pain in the ass
13:17:36 <programble> that is all
13:18:01 <chrisdone> programble: something about kinds?
13:18:20 <dom96> someone please convince him otherwise :P
13:18:26 <programble> chrisdone: he said "Parsing JSON in Haskell is a pain in the ass"
13:18:40 <programble> chrisdone: i responded with "*ing * in Haskell is a pain in the ass"
13:19:11 <chrisdone> O _ O
13:19:15 <gwern> alright, troll scores everyone
13:19:18 <gwern> 8.4 from me
13:19:26 <chrisdone> @karma chrisdone
13:19:26 <lambdabot> You have a karma of 2
13:19:27 <Botje> 3.2
13:19:36 <dom96> Parsing JSON is quite repetitive... and boring :P
13:19:45 <programble> then he responded with "Tell that to #haskell"
13:19:48 <ddarius> dom96: That's why we have libraries to do that.
13:19:48 <programble> so i did
13:19:50 <gwern> Botje: come now with the * it's 'kind' of clever
13:19:51 <programble> anyway
13:19:58 * programble goes back to idle
13:20:01 <chrisdone> dom96: why are you parsing json? it's like, one function
13:20:18 <FunctorSalad> programble: did he refer to the 'json' package? 'jsonb' is simpler
13:20:22 <dom96> chrisdone: yes, but i want to parse it into a nice data type.
13:20:29 <chrisdone> dom96: again, it's one function
13:20:33 <programble> FunctorSalad: he just said parsing json was hard
13:20:39 <Botje> gwern: why not take it one step further? "*in * in * is a pain in the ass"
13:20:43 <FunctorSalad> and maybe faster due to using bullshit tries for json objects rather than assoc lists
13:20:44 <gwern> hm. gitit doesn't like serving PDFs to httrack
13:20:44 <Botje> missed opportunity, there :)
13:20:58 <FunctorSalad> (depending on what you do with the result)
13:21:00 <dom96> chrisdone: what function is that?
13:21:01 <gwern> Botje: hold on, you don't want to blow your phd thesis on your masters
13:21:13 <dom96> FunctorSalad: i'll check that out.
13:21:15 <programble> Botje: "*ing * in * is *"
13:21:16 <programble> i win
13:21:22 <Botje> .. fun?
13:21:24 <FunctorSalad> (as in "bytestring tries")
13:21:37 <chrisdone> dom96: decodeJSON :: Data a => String -> a
13:21:40 <chrisdone> http://hackage.haskell.org/packages/archive/json/0.4.4/doc/html/Text-JSON-Generic.html
13:21:52 <chrisdone> but you should use: fromJSON :: Data a => JSValue -> Result a
13:22:22 <chrisdone> uh, not that one. where is it..
13:22:39 <chrisdone> okay, I guess it'll have to be that one 
13:23:00 <dom96> chrisdone: yes, but i need an instance of JSON WhateverDataTypeImUsing
13:23:24 <chrisdone> dom96: no no, look it uses the Data instance, which you can derive
13:24:24 <chrisdone> data Splerge = Splerge { sausages :: Integer } deriving (Typeable,Data)
13:24:24 <chrisdone> decodeJSON :: Data a => String -> a
13:24:24 <chrisdone> (decodeJSON "{sausages:1}" :: Splerge) => Splerge { sausages = 1 }
13:24:42 <chrisdone> (well, with double-quotes around the "sausages", of course)
13:25:00 <dmwit> Even if you don't have access to the data declaration, you can do "deriving instance Data Splerge" in another module.
13:25:07 <dom96> What if the data type is defined in a different module? (One that i don't have access to?)
13:25:12 <dmwit> BAM
13:25:12 <chrisdone> hahaha
13:25:17 <chrisdone> pre-empted by the godly one
13:25:25 <dom96> oh wow
13:25:26 <dom96> lol
13:25:35 <dom96> i see
13:25:36 <chrisdone> @faq Can Haskell make you psychic?
13:25:37 <lambdabot> The answer is: Yes! Haskell can do that.
13:26:04 <dom96> well most of the work i've done today was very pointless then :P
13:26:40 <chrisdone> dom96: I did the same thing. the Text.JSON.Generic module is a breath of fresh air
13:27:34 <dom96> Awesome. Thanks for the help.
13:33:44 * hackagebot hoauth 0.3.2.1 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.3.2.1 (DiegoSouza)
13:39:10 <sm> gwern: are you trying to make gitit work like hakyll ?
13:41:13 <gwern> sm: I'm not sure. what is hakyll?
13:41:43 <sm> gosh.. worth a look, for you.. it's a static web page generator
13:41:59 <sm> a good one
13:42:43 <gwern> sm: but does it work seamlessly with gitit and my gitit plugins?
13:43:27 <sm> no, but it seems feasible to point it at your gitit page sources
13:43:56 <sm> well I don't know what plugins you're using. I didn't know gitit had those
13:44:23 <gwern> my dream is basically to run a single command pointed at my local gitit server, and then rsync the results
13:44:26 <sm> I thought gitit was still more-or-less in the too-heavy-for-prime-time basket
13:44:38 <gwern> well, that's why I'm not running it *there*
13:44:48 * sm nods
13:45:07 <gwern> especially since my odds of there being a major security hole in gitit is ~100%
13:45:45 <sm> well, now you know about hakyll. I build joyful.com and hledger.org with it, and would rsync, except it's so easy to run in-situ I prefer that
13:45:55 <gwern> I also know about yst
13:46:38 <gwern> I don't quite know what to make of httrack yet
13:46:42 <gwern> some of its output is weird
13:47:03 <gwern> tmp2/127.0.0.1_5001/fiction/Cloud Nine.html
13:47:08 <gwern> tmp2/127.0.0.1_5001/fiction/Cloud Nineab.html
13:47:34 <gwern>  eg: tmp2/127.0.0.1_5001/fiction/Cloud Nine2acb.html
13:48:27 <gwern> seems to have something to do with ?printable
13:49:59 <gwern> sm: I dunno, it looks like I would basically have to convert my wiki to hakyll
13:50:52 <sm> yeah.. which would lose easy inter-page links, for example
13:50:56 <gwern> include a hakyll.hs, copy gitit css, manually run my interwiki plugin...
13:51:07 <gwern> yst is just as bad
13:51:13 <sm> I'd love some best-of combination of gitit and hakyll
13:52:00 <JHoglund> I get this type mismtach error when compiling my recursive function which uses find (/=Nothing) on results from the recursion. Anyone who can have a quick look at it? http://pastebin.com/rpH7YCGu
13:52:13 <sm> you could always throw up your hands and use ikiwiki..
13:52:55 <benmachine> :t find
13:52:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:53:15 <benmachine> JHoglund: there you have a = Maybe Sudoku, so your result is Maybe (Maybe Sudoku)
13:53:17 <gwern> sm: hush your mouth
13:53:21 <gwern> I eat our dogfood
13:53:33 <JHoglund> benmachine: Yeah, I've been fiddling around with find on lists with numbers, and Maybe numbers, it works like I expect it to there
13:53:37 * sm is suitably chastened
13:54:22 <JHoglund> benmachine: So, my "recursions" list is really a list of Maybe (Maybe Sudoku)?
13:54:45 <benmachine> JHoglund: no, it's a list of Maybe Sudoku
13:54:56 <benmachine> JHoglund: but find takes a list of a and returns a Maybe a
13:55:33 <benmachine> > find (== Nothing) [Just 2, Just 3, Nothing]
13:55:34 <lambdabot>   Just Nothing
13:55:40 <benmachine> :t find (== Nothing) [Just 2, Just 3, Nothing]
13:55:41 <lambdabot> forall a. (Num a) => Maybe (Maybe a)
13:55:45 <benmachine> :t find (/= Nothing) [Just 2, Just 3, Nothing]
13:55:45 <lambdabot> forall a. (Num a) => Maybe (Maybe a)
13:55:48 <benmachine> > find (/= Nothing) [Just 2, Just 3, Nothing]
13:55:49 <lambdabot>   Just (Just 2)
13:55:54 <benmachine> do u c
13:56:04 <JHoglund> benmachine: Uhm, not really. This works: find (/=Nothing) [Nothing, Nothing, Just 5, Just 3]
13:56:14 <benmachine> JHoglund: define "works"
13:56:31 <JHoglund> benmachine: It gives me the first element which isn't Nothing
13:56:32 <sm> gwern: well what's harder.. figuring out a reliable web-mirroring script or adding a simple wiki-linking step to your hakyll.hs
13:56:49 <JHoglund> Oh, I just saw I got a Just (Just 5), which I hadn't noticed before
13:56:55 <benmachine> mmhm
13:57:13 <c_wraith> isn't this like...  msum?
13:57:16 <benmachine> yes
13:57:17 <gwern> sm: well, I just discovered that a garbage page httrack generated was due to a broken link
13:57:23 <benmachine> Control.Monad (msum)
13:57:23 <gwern> so it may be that httrack is easier
13:57:27 <c_wraith> > msum [Nothing, Nothing, Just 5, Nothing, Just 1]
13:57:29 <lambdabot>   Just 5
13:57:29 <benmachine> is probably what you want
13:57:41 <benmachine> getFirst . foldMap First
13:57:43 <benmachine> also works
13:58:04 <benmachine> or, join . find (/= Nothing)
13:58:09 <JHoglund> I'll try with msum. It works with fromJust as long as you knwo you get something :)
13:58:25 <c_wraith> join is better than fromJust there
13:58:33 <c_wraith> but msum is the cleanest
13:59:21 <benmachine> fmap fromJust doesn't require you to have gotten something
13:59:31 <benmachine> but why not just use msum :P
14:00:46 <JHoglund> Thanks for helping me out benmachine, c_wraith. I don't really get what msum does just yet, but I'll spend a few minutes on Google and head back if I dont manage :)
14:02:22 <benmachine> JHoglund: p.s. has anyone pointed out that your algorithm is hugely massively exponentially explodey inefficient? >_>
14:02:54 <JHoglund> benmachine: Yep, actually, it's not mine, it's the teachers guide. There's room for improvement once we get it to work :)
14:03:03 <benmachine> heh okay
14:03:20 <benmachine> msum = foldr mplus mzero, btw
14:04:03 <JHoglund> benmachine: Although the teacher was a bit more, uhm, softer in his description "very basic, and in some sense naive"
14:04:10 <benmachine> mplus (Just x) _ = Just x; mplus _ (Just x) = Just x; mplus Nothing Nothing = Nothing
14:04:13 <benmachine> heh okay
14:04:17 <kmc> @yarr
14:04:18 <lambdabot> Splice the Mainbrace!
14:04:19 <benmachine> mzero = Nothing
14:04:41 <benmachine> (these are for Maybe; mplus and mzero have other implementations in other types)
14:06:13 <gwern> wow, I have quite a few broken links in my wiki :(
14:06:47 <gwern> this has been educational
14:07:46 <cads_> @hoogle [a]->bool
14:07:47 <lambdabot> Did you mean: [a] -> Bool /count=20
14:07:47 <lambdabot> Prelude head :: [a] -> a
14:07:47 <lambdabot> Prelude last :: [a] -> a
14:08:32 <cads_> @hoogle (a->Bool)->[a]->Bool
14:08:33 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
14:08:33 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
14:08:33 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
14:14:47 <vishnix> Greetings all, complete n00b here. Been learning Haskell for about a week now. Worked my way through Gentle Introduction. And yes, I believe I have grokked Monads! 
14:14:58 <sm> huzzah!
14:15:11 <cads_> wootrix!
14:15:33 <vishnix> Can you suggest further readings, exercises and interesting code to study?
14:15:44 <cads_> yes!
14:15:56 <cads_> read  brent yorgey's typeclassopedia
14:17:24 <cads_> that's got a good intro to a lot of the type classes like functor, applicative, pointed, arrow, monad
14:17:33 <kmc> yet you capitalize the word 'monads'
14:18:06 <Cale> vishnix: That's doing rather well for only a week! If you're interested in concurrency, maybe try reading the paper on STM, called "Composable Memory Transactions". (Or, at least the first few sections of it.)
14:18:12 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
14:18:55 <Cale> There are lots of fun and useful libraries. Parsec was what actually got me to understand what the monad abstraction was for.
14:19:04 <cads_> If you're interested about a very theoretical discussion of monads, you can try eugenio moggi's "notions of computation and monads"
14:20:00 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html is an old tutorial on Parsec -- the modules have moved around a bit and some details have become more elaborate in the new versions, but it's still a decent tutorial.
14:20:32 <Cale> QuickCheck is another library which is worth checking out (not much of a connection with monads, though there is a Gen monad there)
14:21:00 <vishnix> Thanks much. That's some pretty advanced material. Should keep me busy for a month at least, I'm guessing :)
14:21:20 <cads_> I'm not sure if you should expect moggi's paper to be accessible right away
14:21:34 <ddarius> Quite a bit of it can be ignored.
14:21:34 <cads_> but the references in it are great
14:21:42 <cads_> right
14:22:15 <cads_> and you can get a flavor of things just by reading the definitions from some of the references
14:22:30 <cads_> ddarius, but what do you mean?
14:22:43 <vishnix> I have heard of parsec and quickcheck. I think I'll start with that so that I can get my hands dirty right away
14:23:41 <cads_> ddarius, maybe actually I shouldn't be so eager to recommend the paper :)
14:23:50 <vishnix> And it looks like I'm having a bad Capitalization day :)
14:25:40 <telephone> When trying to write a FFI library with cabal, I get error: Warning: library.cabal: Unknown fields: include-dirs (line 14), includes (line
14:25:42 <telephone> 15),
14:26:19 <telephone> This option seems old, so how should I tell where cabal find *.h *.c files?
14:30:09 <Functastic> Hello, I have a simple question about a function. If I have this, take' :: (Num i, Ord i) => i -> [a] -> [a], take' is the function name, (Num i, Ord i) => are the class constraints. Are "i -> [a]" the parameters and "-> [a]" the type of list returned?
14:31:03 <cizra> @src Tree
14:31:04 <lambdabot> Source not found. Sorry.
14:31:44 <telephone> Functastic: i is the only parameter, giving a function [a] -> [a]
14:32:11 <Functastic> oh!
14:32:36 <telephone> Functastic: hence f :: [a] -- constant function, function of 0 variables
14:33:16 <Functastic> telephone: Thanks. It's a little confusing on how it flows.
14:33:42 <telephone> Functastic: g :: [a] -> [a] -- function of 1 variable, returning function of 0 variable, hence returning an object of type [a]
14:35:27 <telephone> Functastic: I think this way of seeing function is called "currying" after "Haskell Curry"
14:35:45 <benmachine> f :: [a] isn't a function
14:36:04 <voluhar> hello I am new and I am new to haskell can somebody eplain me why this code take for ever, but in python same principe runs like instant
14:36:21 <voluhar> orderf 1 a b  =  foldr (\c d-> c + d ) a (rep 1 b)
14:36:26 <c_wraith> It would be very sad if the language named Haskell didn't support currying functions. :)
14:36:32 <voluhar> orderf c a b  =  foldr (orderf (c-1) ) a (rep a (b-1))
14:36:39 <voluhar> r = orderf 3 10 10
14:36:41 <Functastic> c_wraith: lol
14:36:49 <voluhar> what is actualy 10 on power 10
14:36:55 <Functastic> telephone: Thanks for explaining.
14:37:01 <telephone> I solved my question above: the field include-dirs, includes was not in "Library" section of cabal file.
14:37:33 <ddarius> c_wraith: You can't fail to support currying functions if you support higher order functions.
14:37:44 <benmachine> voluhar: rep is replicate?
14:37:50 <c_wraith> ddarius, well, you can make the syntax for it exceptionally ugly.
14:37:56 <benmachine> voluhar: or, well, what's rep?
14:38:00 <voluhar> yup
14:38:17 <voluhar> rep _ 0 = []
14:38:23 <voluhar> rep x n = x:(rep x (n-1))
14:38:31 <benmachine> oh, flip replicate
14:38:44 <voluhar> It might be something whit rep
14:38:46 <voluhar> repete
14:38:49 <ddarius> cads_: Moggi changed his mind about some of his requirements and also some of the technical work is overkill particularly if you are just interested in how monads are applied
14:39:34 <benmachine> voluhar: what does the python look like?
14:39:54 <voluhar> When i tryed functional programming I tkook less then sec to run in python
14:40:00 <voluhar> wait a min
14:41:02 <voluhar> have to rewrite :)
14:45:35 <cads_> ddarius, should I still reference some of his later work if I'm interested in seeing how category theory is used as a framework?
14:45:41 <kmc> i think this "function of 0 variables" is a contradiction in terms
14:45:49 <kmc> a function is something whose type has the form (a -> b)
14:46:10 <kmc> see also http://conal.net/blog/posts/everything-is-a-function-in-haskell/
14:47:17 <EvanR-work> constant function
14:47:31 <EvanR-work> also known as a constant
14:48:22 <EvanR-work> everything is an object, using object calculus you can implement functions, therefore everything is a function
14:49:22 <conal> everything is matter, and using matter you can implement cucumbers, therefore everything is a cucumber.
14:50:07 <Functastic> kmc: Was that in reponse to a reponse of what I asked?
14:51:57 <benmachine> constant function is not a constant
14:52:01 <benmachine> it's \_ -> a constant
14:52:33 <bremner> can you have a zero arity lambda that just captures the surrounding env?
14:52:33 * kmc is a cucumber
14:52:48 <bremner> you can in lisp, I'm pretty sure
14:52:59 <kmc> not in Haskell bremner
14:53:05 <kmc> but you can take a useless argument like ()
14:53:06 <conal> What's this notion of "constant"?  In pure functional programming, everything is immutable, i.e., constant.
14:53:09 <Functastic> I think I am over analyzing. sortMe :: (Ord a) => [a] -> [a]    wouldn't [a] -> [a] be the params?
14:53:11 <benmachine> \ -> -- syntax error
14:53:34 <kmc> Functastic, in (A -> B), A is the parameter type, B is the return type
14:53:34 <benmachine> conal: the output of the function is constant as the input varies, I guess
14:53:55 <kmc> my point is, there's no such thing as a "0-argument function"
14:54:00 <kmc> every function has exactly one argument
14:54:07 <Functastic> oh!
14:54:09 <kmc> because every function has type (A -> B) for some A and B
14:54:12 <conal> benmachine: and the function itself is constant (immutable / unvarying)
14:54:29 <kmc> however, informally we would say "2-argument function" for a type like (A -> (B -> C)), and furthermore we'd probably write (A -> B -> C)
14:54:41 <Functastic> so [a] is the param and -> [a] is the return type?
14:54:50 <kmc> in (A -> B), A is the parameter type, B is the return type
14:55:04 <kmc> sortMe takes an argument of type [a] and returns a result of type [a]
14:55:22 <Functastic> ahh okay.. thanks for clearing it up for me
14:55:25 <McManiaC> any wxhaskell-experts here? my windows are always "behind" my terminal at the start, how can I raise a window?
14:56:21 <conal> bremner: a lambda is not needed to capture the surrounding env.
14:56:30 <dschoepe> McManiaC: Isn't that rather something that the WM should handle?
14:56:43 <dschoepe> instead of the application always wanting focus on creation
14:57:19 <Functastic> A -> B -> C makes sense also... I think once I started looking at two args I got confused.
14:57:21 <voluhar> ok here is python code
14:57:26 <voluhar> summ = lambda a,b: a + b
14:57:26 <voluhar> prodd = lambda a,b: reduce (summ, (a for i in xrange(b)) )
14:57:26 <voluhar> poww  = lambda a,b: reduce (prodd, (a for i in xrange(b)) )
14:57:26 <voluhar> print poww(10,10)
14:57:37 <voluhar> damt let me try again
14:57:39 <voluhar> summ = lambda a,b: a + b
14:57:44 <McManiaC> dschoepe: every other application I use gets focus on start :)
14:57:48 <voluhar> prodd = lambda a,b: reduce (summ, (a for i in xrange(b)) )
14:57:56 <voluhar> poww  = lambda a,b: reduce (prodd, (a for i in xrange(b)) )
14:58:04 <voluhar> print poww(10,10)
14:58:05 <monochrom> > error "too verbose python syntax"
14:58:06 <lambdabot>   *Exception: too verbose python syntax
14:58:29 <dschoepe> McManiaC: nevermind then :)
14:58:29 <voluhar> this works for 2.7
14:58:50 <voluhar> and it even calculates poww(999,999)
14:58:55 <megajosh2> ewww functional programming in Python
14:59:33 <McManiaC> voluhar: pastebin next time :P
14:59:38 <voluhar> ok
14:59:51 <McManiaC> :)
15:00:53 <voluhar> http://pastebin.com/e7ja18W5
15:00:55 <voluhar> here it is
15:05:23 <monochrom> heh the paste bin uses the first line as title? then every haskell paste will have the title "import Control.Monad"
15:05:35 <voluhar> is haskel to lazy for this what is wrong whit haskel implementaion
15:06:04 <monochrom> use foldl'
15:06:16 <benmachine> foldl' helps but I think those algorithms are doing different things
15:08:10 <benmachine> yeah
15:09:23 <benmachine> voluhar: here's the direct translation: http://pastebin.com/StXiig8b
15:09:32 <benmachine> poww 10 10 there is virtually instant
15:09:38 <benmachine> foldl' is in Data.List
15:09:57 <benmachine> poww 999 999 takes 0.43 seconds
15:10:04 <voluhar> thaks
15:10:53 <monochrom> @check
15:10:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:10:58 <monochrom> @help check
15:10:59 <lambdabot> check <expr>
15:10:59 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
15:11:00 <voluhar> i was trying whit 999 999 too lol
15:11:02 <voluhar> :D
15:11:30 <monochrom> @check (\a b -> foldl1' (+) (replicate b a) == foldl1' (+) (replicate a b))
15:11:31 <lambdabot>   "*Exception: Prelude.foldl1': empty list
15:11:46 <conal> i also wince when i hear "function of one variable", since functions are semantics while variables are syntax.
15:12:11 <monochrom> @check (\a b -> foldl1' (+) (replicate (b+1) (a+1)) == foldl1' (+) (replicate (a+1) (b+1)))
15:12:12 <lambdabot>   "*Exception: Prelude.foldl1': empty list
15:12:37 <ddarius> conal: There is certainly a semantic notion of unary function.
15:12:41 <monochrom> @check (\a b -> (a/=0 && b/=0) <= (foldl1' (+) (replicate b a) == foldl1' (+) (replicate a b)))
15:12:42 <lambdabot>   "*Exception: Prelude.foldl1': empty list
15:13:17 <conal> ddarius: i'm fine with "unary function"
15:13:29 <conal> just not function of one *variable*.
15:13:48 <monochrom> @check (\a b -> foldl' (+) 0 (replicate b a) == foldl' (+) 0 (replicate a b))
15:13:49 <lambdabot>   "Falsifiable, after 3 tests:\n2\n-1\n"
15:14:32 <monochrom> @check (\a b -> (a>=0 && b>=0) <= (foldl' (+) 0 (replicate b a) == foldl' (+) 0 (replicate a b)))
15:14:34 <lambdabot>   "OK, passed 500 tests."
15:15:16 <monochrom> @check (\a b -> (a>0 && b>0) <= (foldl1' (+) (replicate b a) == foldl1' (+) (replicate a b)))
15:15:17 <lambdabot>   "*Exception: Prelude.foldl1': empty list
15:15:48 <monochrom> > False <= undefined
15:15:49 <lambdabot>   *Exception: Prelude.undefined
15:16:04 <monochrom> I guess <= is strict.
15:17:17 <benmachine> :t (==>)
15:17:18 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
15:17:23 <monochrom> (\x y -> x+y+z) is function with one variable, i.e., one free variable. :)
15:17:43 <benmachine> @check (\a b -> (a>0 && b>0) ==> (foldl1' (+) (replicate b a) == foldl1' (+) (replicate a b)))
15:17:44 <lambdabot>   No instance for (Test.QuickCheck.Testable
15:17:44 <lambdabot>                     (Test.QuickCh...
15:17:47 <benmachine> :(
15:26:22 <voluhar> <benmachine> thaks again, 
15:34:45 <Quadrescence> FUCK THE MONOMORPHISM RESTRICTION
15:38:50 <zygoloid> this message brought to you by {-# LANGUAGE NoMonomorphismRestriction #-}
15:41:04 <monochrom> hahahaha
15:42:12 <zygoloid> @remember conal everything is matter, and using matter you can implement cucumbers, therefore everything is a cucumber.
15:42:13 <lambdabot> I will never forget.
15:42:13 <Mathnerd314> it should never have been invented in the first place! there are some things that man is not meant to know...
15:43:06 <zygoloid> in any case, it's actually more of a polymorphism restriction :)
15:45:17 <alexsuraci> would anyone know what's going on here?: http://hpaste.org/40248/atomo_haddock_error
15:46:09 <alexsuraci> http://darcsden.com/alex/atomo/browse/src/Atomo/Haskell.hs module in question (I think)
15:46:19 <alexsuraci> I can load it in ghci just fine, not sure what haddock's doing
15:52:26 <ari> Hi. How would I go about generating a list of unique integers for an instance of Arbitrary with minimal hassle?
15:52:42 <ari> I guess I could just generate a list and nub it...
15:52:46 <dibblego> what's wrong with the included one?
15:53:47 <ari> The fact that I didn't find it when I read through the documentation quickly. What's it called?
15:54:07 <dibblego> instance Arbitrary Int
15:54:57 <ari> Yeah, nothing wrong with that instance. (I went with nub `fmap` listOf arbitrary)
15:58:47 * hackagebot zeromq-haskell 0.4.1 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.4.1 (ToralfWittner)
16:01:02 * FunctorSalad needs real ultimate unbuffered hGetChar... it seems to have no effect sometimes
16:01:54 <Honeyman> Hi all. Being a total newb in Haskell, trying to install Decimal with cabal, and getting this: http://dpaste.com/251206/
16:02:55 <Honeyman> Can someone give me a hint how to deal with it, or whom to ask? It seems the problem is not on my side...
16:03:08 <c_wraith> Honeyman, it depends on an older version of QuickCheck than it installed.  The dependency in Decimal's cabal file isn't restrictive enough
16:03:10 <FunctorSalad> Honeyman: maybe try cabal install --constraint="QuickCheck<2"
16:03:20 <c_wraith> and FunctorSalad gave you the correct solution :)
16:03:23 <FunctorSalad> (no, it's not on your side :))
16:05:18 <Honeyman> FunctorSalad, c_wraith: thanks, much better now :)
16:07:05 <Honeyman> Is Decimal still supported "enough" (such a dependency makes me worried it is not), or maybe is there any other option if I want the controlled-precision numbers?
16:08:08 <benmachine> Honeyman: the build failure suggests the maintainer has forgotten about it, you can try emailing them to poke them into fixing it
16:08:20 <c_wraith> It probably just hasn't been updated in a long time.  If it works, though, it still works. :)
16:08:30 <benmachine> Honeyman: if they don't reply for long enough someone else could take up maintainership
16:08:42 <benmachine> we don't really have a concrete policy about that though
16:09:33 <Honeyman> I see... thanks!
16:10:37 <c_wraith> ...  Really, I consider it to be bad form to let a quickcheck dependency leak out of your cabal file, unless your package is a test framework that works with it.
16:11:01 <sm> Decimal seems to be a package that not a lot of people use
16:13:47 <ddarius> Skip lists: an underused solution
16:19:27 <Veinor> c_wraith: yeah
16:20:18 <copumpkin> ddarius: not very pleasant to use in a purely functional setting are they?
16:22:46 <ddarius> copumpkin: Who cares about purely functional settings?  And when are you going to kill copumpki-?
16:23:32 <copumpkin> kept forgetting :) there
16:25:25 <Cale> Do skip lists have any advantages over finger trees?
16:29:40 <ddarius> Cale: They are -much- simpler for starters, and likely much more memory efficient.
16:43:32 <gwern> argh. is there no census or study about what percent of files online are JPG, gif, png, etc?
16:43:46 <gwern> there must be, someone must have studied this at some point
16:44:20 <benmachine> gwern: your life calling :O
16:44:38 <gwern> no I'm sure I saw a blog post/essay on this a few years ago
16:45:59 <gwern> google really sucks about this. one of the top hits is http://www.mit.edu/~mkgray/net/web-growth-data.html which was updated in 1996 with the author saying he'll get around to it eventually >.<
16:46:17 <tmo_> Suppose I have a dynamic data structure that 1) Operates with IO 2) Maps integers to strings. If I want to be able to modify this data structure and extract data from said structure, do I need to use mutable variables?
16:46:17 <lambdabot> tmo_: You have 4 new messages. '/msg lambdabot @messages' to read them.
16:47:28 <Cale> tmo_: I am not certain that I properly understand your question.
16:48:29 <cobra> Why does haskell have 7 different libraries for reading command line arguments, and which one is the best?
16:48:51 <Cale> tmo_: When I do a lookup in this datastructure, does it do arbitrary IO in order to determine which string is associated to each integer? Could the association be different for example depending on the time at which the lookup is done?
16:49:19 <Cale> tmo_: It sounds like you *might* just be talking about a Map Integer (IO String)?
16:49:37 <Cale> I don't really understand what "operates with IO" means.
16:49:47 <tmo_> Suppose I have a list of windows opened, and I have a reference number associated with those windows. Now suppose I have a directory associated with each window. Since windows can be dynamically closed and created, how can I append/remove the appropriate data to it depending on the update, and how can I make it so that I can retrieve this data again?
16:50:09 <tmo_> Or what would be the best solution?
16:50:21 <magicman> gwern: http://news.cnet.com/8301-30685_3-20018146-264.html states that 90% is jpeg, but nothing on the other formats. It is from today, though, so I doubt you saw this one a few years ago <_<
16:50:21 <Cale> tmo_: Just use a Map Integer String
16:50:29 <Cale> tmo_: Or an IntMap String
16:50:42 <gwern> magicman: man, I'd be happy just with jpeg data
16:51:00 <Cale> tmo_: If you need a mutable reference to that, you could make it an IORef (Map Integer String)
16:51:05 <tmo_> I see
16:51:16 <gwern> magicman: although really what I wnat is jpeg popularity now and in ten years
16:51:26 <magicman> (also, that's 90% of images, not of all files)
16:52:03 <Cale> tmo_: Map values are immutable, but when you perform various operations like adding keys, the new datastructure created shares most of its structure with the old one, so the operations to insert and delete elements are fast.
16:52:19 <gwern> magicman: imo, webp will be a miserable failure
16:52:35 <gwern> kind of like google's tcp/ip replacement whatever the heck that was
16:53:25 <Cale> tmo_: They are internally binary balanced trees (or in the case of IntMap, something called patricia tries), and only the path from the modified element to the root of the tree (and a bounded amount around that for balancing) needs to be reconstructed. All other subtrees are shared.
16:54:17 <tmo_> Also, I wasn't awayre of the IORef module, but it appears to be exactly what I need :)
16:54:30 <gwern> magicman: where miserable failure is defined in http://predictionbook.com/predictions/1819
16:54:41 <Adamant> gwern: WebM will likely succeed though
16:54:58 <gwern> I dunno. OGG has hardly killed MP3
16:55:19 <Adamant> gwern: it's a big corporate-backed standard for the free/open types
16:55:37 <Adamant> it will probably mostly kill Theodora and be a real competitor
16:56:02 * magicman kinda wonders what happened to the Go language...
16:56:16 <magicman> Haven't heard much about it since its inception.
16:56:18 <Adamant> I don't know why Go was written
16:56:31 <Adamant> not trying to be mean, I just don't see the point of it
16:56:58 <Adamant> everything it tries to do other languages have done better
16:56:59 <Cale> Adamant: I totally agree with you. It's quite boring.
16:57:11 <gwern> I looked at DarkShikari's postings analyzing webm
16:57:11 <dancor> i thought it was interesting that it wanted a fast compiler
16:57:28 <gwern> I had the definite impression that webm is seriously vulnerable to patent issues
16:58:08 <Adamant> Cale: it's not even boring in the sense Java was in the early years, where it wasn't anything new but it at least kicked the average state of new languages up to a higher bar for admission.
16:58:27 <Adamant> the 'halfway to Lisp' argument Steele made, which was right at the time
16:59:57 <Cale> Yeah, okay, the one cool thing about Go is how fast the compiler itself is.
17:00:36 <Zao> Cale: I still can't accept that MS's C# compiler compiles my code in no-time.
17:00:47 <Zao> I have to check the output window to actually see if it worked :D
17:00:55 <Adamant> gwern: Google is big enough to be someone you don't take on lightly in a patent war, unless you are a patent troll
17:01:17 <gwern> Adamant: you don't have to sue google
17:01:19 <djahandarie> What is the slowest part of GHC?
17:01:29 <Adamant> gwern: suing users?
17:01:45 <gwern> sure, that'd hurt
17:01:57 <Cale> Right now what I am feeling the need for is a faster linker and iPhone simulator though :P
17:02:06 <Adamant> gwern: I don't know what legal options are available for them
17:02:23 <Adamant> but they can at least file lots and lots of amicus curiea stuff
17:02:23 <gwern> Cale: still working on that diablo clone/
17:02:25 <Cale> GHC compiles things fast enough, it's the linking and installing stuff to the simulator which takes 10 minutes inside my VM
17:02:35 <gwern> Adamant: oooh that's such a comfort to the defendent
17:02:41 <Cale> 10 minutes might be an exaggeration...
17:02:44 <Adamant> gwern: and they may be able to countersue
17:02:46 <Cale> More like 5.
17:02:59 <Cale> gwern: Yeah
17:03:13 <Adamant> which I would be surprised if they didn't do if it was an option
17:04:21 <tommc> Is there an easy way to generate haskell docs of all pre-installed cabal packages?
17:04:42 <benmachine> tommc: you can make it so cabal generates docs for packages it installs
17:04:48 <benmachine> but I don't know about doing that retroactively
17:05:00 <tommc> benmachine: yeah, that's the part I was having a hard time figuring out.
17:05:52 <gwern> tommc: I don't think so. to get docs you basically have to build the package
17:06:58 <ddarius> Phew.  Having if be a combinator taking quotations ("lambdas") in a concatenative language Does The Right Thing even if your quotation mechanism isn't strong enough to implement curry.
17:08:38 <monochrom> to build docs retrospectively: cabal unpack the package, cabal configure, cabal haddock, cabal copy. add command line parameters as necessary, e.g., --user or --global, --prefix=/dev/null
17:08:54 <monochrom> and of course I forgot cd
17:10:47 <dancor> i have a large data file.  i sometimes add data to the end, which is fast.  but i also sometimes remove a piece from the middle, which involves slowly copying the remaining portion of the large file.  what should i do so that removing-from-the-middle is fast?  store the file in chunks each of a limited size?
17:11:18 <monochrom> perhaps store as sqlite
17:11:50 <monochrom> or re-invent something similar
17:11:52 <tommc> Thanks for the help. Interestingly, installing the docs for one package has generated a listing for all other packages...
17:11:59 <tommc> which is what I wanted ;-)
17:12:45 <dancor> monochrom: the data file is ~100G and i might be removing 1M-10G
17:13:31 <Cale> dancor: There are various mechanisms you can use, but eventually, you will reinvent the filesystem.
17:13:35 <monochrom> this needs a PhD thesis
17:13:41 <dancor> i want to escape the 50G copy if i remove 1M from the middle.  sqlite is reasonable for those sizes?
17:13:51 <gwern> I don't think it is
17:13:53 <gwern> 50GB?
17:13:57 <dancor> ya
17:14:13 <gwern> dancor: I think at that file size I would look at storing it as chunks, yeah
17:14:19 <dancor> ok
17:14:56 <dancor> Cale: are you saying that a filesystem like ext2 already supports rapidly removing 1M from the middle of a 100G file?
17:14:59 <gwern> google file system stores files in 50MB chunks incidentally
17:15:09 <monochrom> ask the oracle sales representatives if they can handle this.
17:15:18 <IceDane> dancor: files aren't nearly always stored sequentially
17:15:23 <IceDane> the middle might just be a few sectors
17:15:27 <gwern> monochrom: I'm sure it can, at the modest cost of a few first-born
17:15:30 <IceDane> removing them from the records is all it would take
17:15:33 <IceDane> (in theory)
17:16:25 <benmachine> gwern: hmm, when you pay one first-born, does your second-born become first? or do you have to find another couple?
17:16:49 <gwern> benmachine: legally, oracle can neither confirm nor deny the blood sacrifice, so it remains the second
17:16:50 <xiackok> hello everyone
17:17:10 <gwern> benmachine: oracle only caters to large corporations which have many employees and thus many couples, so it's not a big deal
17:17:11 <monochrom> that is why people dispute over mutable variables and immutable function programming
17:17:29 <benmachine> corporations screwing over the little guy again >:|
17:17:35 <benmachine> uh, so to speak
17:17:46 <gwern> benmachine: the employees freely contract with the corps!
17:17:56 <gwern> remember, satan always keeps his deals
17:18:04 * benmachine remembers
17:18:06 <gwern> because as an immortal, the opportunity cost is too high :)
17:18:37 <monochrom> I still don't understand opportunity cost.
17:19:37 <gwern> monochrom: what's not to understand?
17:19:46 <monochrom> I don't know.
17:19:59 <monochrom> I'll just ask wikipedia
17:20:07 <gwern> did you read https://secure.wikimedia.org/wikipedia/en/wiki/Opportunity_cost ?
17:20:21 <benmachine> gwern reads encrypted wikipedia?
17:20:39 <gwern> benmachine: it is a long story. tl;dr: it's all dons fault
17:21:06 * benmachine accepts this
17:22:16 <monochrom> I see, it refers to the cost of the not-taken alternative.
17:22:43 <monochrom> why would breaking a deal cost too much for an immortal?
17:23:07 <gwern> monochrom: in this case, the devil welshing on 1 deal gets 1 extra soul, but by losing his reputation for hoensty, he forfeits an indefinitely large number of future deals over eternity
17:23:30 <gwern> and hence an indefinitely large number of souls
17:24:40 <monochrom> I guess.
17:25:41 <monochrom> the package "contstuff" sounds cool
17:25:57 <dmwit> I wonder what the devil's discounting rate is.
17:26:18 <monochrom> the guy's email tagline/sig is even more funny. "nightmare = unsafePerformIO (getWrongWife >>= sex)"
17:26:44 <copumpkin> he's in here
17:26:46 <copumpkin> probably asleep though
17:26:53 <Adamant> gwern: he always screws his clients. how does he have a reputation for honesty? consistency, perhaps.
17:26:59 <benmachine> I was never terribly amused by that
17:27:15 <gwern> dmwit: that is a very interesting question
17:27:19 <benmachine> it's more or less like every other unsafePerformIO joke ever
17:27:26 <benmachine> @quote unsafePerformIO
17:27:26 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
17:27:38 <gwern> dmwit: it can't be 0% because natural disasters, Armageddon, etc.
17:27:44 <gwern> but 5% seems much too high
17:27:57 <copumpkin> lol
17:28:00 <Adamant> lol
17:28:04 --- mode: ChanServ set +o copumpkin
17:28:04 <benmachine> lol
17:28:16 --- mode: copumpkin set +b *!*@drb81.neoplus.adsl.tpnet.pl
17:28:34 --- mode: copumpkin set -o copumpkin
17:28:40 <Adamant> that's a hell of a PART message.
17:28:56 <copumpkin> proof : (IO a -> a) -> Void
17:29:01 <gwern> ah, quit spam. haven't seen that in a while
17:29:05 <copumpkin> you can actually write that!
17:29:13 <copumpkin> therefore IO a -> a is a lie
17:29:22 <Adamant> much like cake
17:29:24 <Adamant> and politics
17:29:42 <cobra> is readTVar lazy?
17:30:01 <benmachine> copumpkin: proof = const undefined? >_>
17:30:10 <copumpkin> benmachine: nope!
17:30:26 <copumpkin> you can do it without using obvious bottoms
17:30:36 <benmachine> related to the unsafeCoerce using iorefs?
17:30:39 <copumpkin> yeah
17:31:25 <Saizan> cobra: what do you mean in particular?
17:31:38 <Adamant> if unsafePerformIO :: IO a -> Madness, which unknown unsafe function leads to IO a -> SPARTAAA!!!!!!!!!!!!!!
17:32:06 <Adamant> that was horrible but I had to do it
17:32:37 <benmachine> it was your solemn duty
17:32:38 <monochrom> what is "SPARTAAA"?
17:32:38 <cobra> Saizan: my understanding is that under the covers, readTVar marks the var as read, and then if an external transaction writes to the same var, then the current var will restart...
17:32:40 <benmachine> and we thank you for it
17:32:42 <maurer_1> Adamant: It was only bad because you told it wrong.
17:33:06 <maurer_1> Could not match inferred type IO a -> SPARTAAAAAAA!!!!!!!!!! against expected type IO a -> Madness
17:33:06 <cobra> Saizan: but what if my transaction calls readTVar, but doesn't actually use the result. will it still be "marked" and potentially cause the transaction to be retried?
17:33:22 <Saizan> cobra: yes
17:33:42 <dancor> well i'm going try to index bounded-length actual-files to comprise my large virtual-file.  it does seem like fs reinvention.  lolfs was born
17:33:46 <Adamant> monochrom: a Greek city-state that had conflicts with ATHENSSSSSSS!!!!! and THEBESSSSSSS!!!!
17:33:49 <cobra> Saizan: So I should restructure my code so that it doesn't unnecessarily call readTVar?
17:34:18 <monochrom> then perhaps the function sought is unsafePerform300
17:34:35 <Saizan> cobra: yeah
17:34:43 <benmachine> unsafeDineInHell
17:34:49 <Adamant> monochrom: that sounds about right
17:35:17 <cobra> Saizan: I have something like, do { condition1 <- readTVar x; condition2 <- readTVar y; when (x || y) ... }
17:35:49 <cobra> Saizan: If condition1 is True, then there is no need to check condition2, and the second call to readTVar was actually a waste
17:36:26 <monochrom> Whenever I call readTVar it is necessary. Perhaps I don't evaluate the value inside the transaction, but I do outside. do { map <- atomically (readTVar v); print (lookup key map) }
17:36:42 <cobra> monochrom: that's a good point
17:37:17 <cobra> monochrom: but you see in my example above, the code must be made more ugly to avoid the unnecessary readTVar
17:37:30 <benmachine> cobra: I think ordering in STM has to be preserved, otherwise behaviour would be very odd indeed
17:37:44 <monochrom> if you don't definitely know that it will be too slow, don't worry about it.
17:38:13 <Saizan> unsafeInterleaveSTM anyone?
17:38:44 <monochrom> if you do worry about it, write a general monadic short-circuit-or, and it is no longer ugly.
17:39:14 <ddarius> I'm pretty sure there's one on hackage.
17:39:23 <monochrom> yeah, that too
17:40:18 <cobra> cool. that reminds me: is there something like mapM_ that runs on all of the keys of a Data.Map ?
17:41:11 <benmachine> cobra: I'm not sure what you mean, but you might be interested in Data.Traversable
17:41:16 <dancor> cobra: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Traversable.html
17:41:19 <monochrom> haskell code is un-ugly because we refactor so much. every function contains only a small dose of ugly. then you compose them to do what an ugly mess could do. only the generated code with much inlining will actually look ugly.
17:41:34 <Cale> Yes, the one in Data.Traversable is probably just what you want, or else you want the keys function.
17:41:52 <monochrom> as an example, >>= of most monads people use are ugly internally.
17:43:22 <ddarius> monochrom: That's how Forth programs work.
17:43:46 <monochrom> perhaps haskell is the fifth forth
17:43:49 <ddarius> Incidentally, the package with the monadic or and co. is IfElse, but the Haddock is jacked up so you need to view the source.
17:43:53 <ddarius> @hackage IfElse
17:43:53 <lambdabot> http://hackage.haskell.org/package/IfElse
17:44:52 <dancor> cobra: actually i think you want Data.Foldable.mapM_
17:45:14 <dancor> > Data.Foldable.mapM_ print (Data.Map.fromList [(4, 'i'), (2, 'h')])
17:45:15 <lambdabot>   Not in scope: `Data.Map.fromList'
17:45:35 <dancor> @botsmack
17:45:35 <lambdabot> :)
17:45:57 <Cale> Actually, probably just normal mapM_ and Data.Map.keys 
17:46:18 <dancor> right..
17:46:39 <benmachine> IfElse is weird
17:47:15 <cobra> dancor: that one seems to run on the values, not the keys
17:47:48 <ddarius> benmachine: Agreed.
17:47:56 <monochrom> mapM_ print (keys mymap)
17:48:33 <ddarius> > Data.Foldable.mapM_ print (fromList [(4, 'i'), (2, 'h')])
17:48:34 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio
17:48:34 <lambdabot>                               ...
17:48:59 <ddarius> How did Ratio come into this?
17:49:14 <ddarius> :t fromList
17:49:15 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
17:49:18 <ddarius> Ah.
17:49:23 <ddarius> > Data.Foldable.mapM_ print (M.fromList [(4, 'i'), (2, 'h')])
17:49:24 <lambdabot>   <IO ()>
17:50:30 <benmachine> > Data.Traversable.mapM return (M.fromList [(4, 'i'), (2, 'h')]) :: String
17:50:31 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:50:31 <lambdabot>         against inferred type...
17:50:35 <benmachine> > Data.Traversable.mapM return (M.fromList [(4, 'i'), (2, 'h')]) :: [String]
17:50:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:50:36 <lambdabot>         against inferred ty...
17:50:39 <benmachine> blah
17:51:33 <dolio> ddarius: Incidentally, earlier I didn't have time to clarify, but the thing I was saying they added back in was left-to-right impredicative instantiation.
17:51:34 <cobra> lambdabot needs a minimal simulated IO system that allows running "print" and other basic functions
17:51:58 <ddarius> dolio: I was hoping that they didn't.
17:51:59 <dolio> ddarius: Where 'runST $ do ...' works, but for a flipped combinator '(do ...) $$ runST' doesn't.
17:52:09 <dolio> And I've tested it, and it works that way.
17:52:25 <pumpkin> ugh
17:52:26 <ddarius> cobra: Write it.
17:52:34 <ddarius> @hackage lambdabot
17:52:35 <lambdabot> http://hackage.haskell.org/package/lambdabot
17:52:52 <pumpkin> cobra: why? the print basic functions aren't particularly interesting
17:52:55 <ddarius> @hackage IOSpec
17:52:55 <lambdabot> http://hackage.haskell.org/package/IOSpec
17:53:50 <co_dh> @pl \x -> (x,x)
17:53:51 <lambdabot> join (,)
17:55:00 <Veinor> @unpl join f
17:55:00 <lambdabot> (f >>= \ a -> a)
17:55:13 <Veinor> @pl \x -> f x x
17:55:13 <cobra> pumpkin: hm...
17:55:14 <lambdabot> join f
17:56:19 <ddarius> Cale: Is the IOSpec package loaded into lambdabot, and if not, it might be nice.
17:56:45 <Cale> It's not
17:58:08 <Cale> It would mean that :t would report weird types for things like putStrLn
17:58:19 <Cale> Though I guess that's not such a big deal :)
17:59:03 <monochrom> @pl (\x -> (x # haskell) x)
17:59:04 <lambdabot> join (# haskell)
18:01:56 <thoughtpolice> woot, i got hoopl to do some stuff :)
18:02:16 <copumpkin> thoughtpolice: oh nice, what are you making it do?
18:02:25 <thoughtpolice> copumpkin: i'm just playing around with it and re-reading the paper
18:02:42 <copumpkin> ah
18:02:48 <thoughtpolice> it seems to make a surprising amount of sense once you just transliterate the code from the paper to an example, then look at the debugging output
18:02:50 <copumpkin> there's a fairly extensive example in the source tree too
18:02:51 <ddarius> Cale: Just have it qualified.
18:02:54 <thoughtpolice> yeah
18:03:10 <ddarius> I wouldn't mind writing, IOSpec.readIORef
18:03:14 <thoughtpolice> they have nice macros that will print out all the transfer, joining and rewrites too
18:03:23 <thoughtpolice> that helps a lot in just following the flow of how it works
18:03:40 <thoughtpolice> er, macros, blah - nice *functions*
18:03:59 * thoughtpolice has been looking at/writing far too much C++ lately
18:04:07 <copumpkin> :)
18:04:51 <thoughtpolice> copumpkin: however I don't ever dread writing these sorts of analysis in an imperative manner and by hand, hoopl does a lot of the nice heavy lifting
18:05:00 <Veinor> monochrom: :D
18:05:06 <copumpkin> yeah
18:05:08 <Cale> @undefine
18:05:17 <Cale> > IOSpec.putStrLn "hello"
18:05:18 <thoughtpolice> as if i needed any more proof that haskell is the ultimate language for compilers, at the very least
18:05:19 <lambdabot>   No instance for (GHC.Show.Show (Test.IOSpec.Types.IOSpec f ()))
18:05:20 <lambdabot>    arising ...
18:05:28 <thoughtpolice> well, ultimate as far as i'm concerned :P
18:06:06 <copumpkin> thoughtpolice: yeah!
18:06:24 <copumpkin> I'd be curious to see your code if you want to put it up somewhere sometime
18:06:36 <Cale> > IOSpec.runIOSpec (IOSpec.putStrLn "hello") IOSpec.singleThreaded
18:06:37 <lambdabot>   No instance for (Test.IOSpec.Teletype.Teletype
18:06:37 <lambdabot>                   Test.IOSpe...
18:06:41 <Cale> mmm
18:07:51 <Cale> Well, there it is anyway.
18:08:03 <thoughtpolice> copumpkin: yeah, i have a book or two sitting around, was thinking of trying to write the example passes etc using hoopl
18:08:11 <copumpkin> cool
18:09:06 <Cale> Not much appears to have an instance of Show in it.
18:09:13 <Cale> So, I'm not sure how useful it will be
18:10:11 <ddarius> Cale: You should be able to actually run it.  Import runIOSpec unqualified might be nice and/or a simplified helper.
18:16:00 <aristid> :t IOSpec.runIOSpec
18:16:01 <lambdabot> forall (f :: * -> *) a. (IOSpec.Executable f) => IOSpec.IOSpec f a -> IOSpec.Scheduler -> IOSpec.Effect (a, IOSpec.Store)
18:16:44 <copumpkin> nice
18:18:27 <byorgey> given a vector v in an inner product space, how might I go about computing a basis for the hyperplane orthogonal to v?
18:18:45 <Veinor> ask #math? :D
18:19:09 * byorgey shudders
18:19:11 <ddarius> byorgey: for all basis vectors b, keep b if b ^ v /= 0
18:20:01 <byorgey> ddarius: ^ is inner product?
18:20:10 <Cale> byorgey: Well, pick random vectors and subtract off the orthogonal projection onto the subspace spanned by v
18:20:11 <benmachine> isn't ^ usually used for cross product
18:20:11 <ddarius> byorgey: Wedge product.
18:20:13 <benmachine> or is that v
18:20:24 * benmachine always just used, you know, cross
18:20:30 <ddarius> Of course, the dual of v will be a blade that represents the hyperplane orthogonal to it already...
18:20:50 <aristid> so google found IOSpec for me http://www.cse.chalmers.se/~wouter/repos/IOSpec/index.html
18:20:53 <ddarius> b ^ v = b . dual(v)
18:21:08 <byorgey> ddarius: where can I read about this?
18:21:28 <Veinor> byorgey: for each basis vector b, compute b - proj_v b
18:21:36 <byorgey> can I apply affine transformations to such duals?
18:21:47 <Veinor> (I don't know anything about vector spaces besides R^n)
18:22:42 <ddarius> http://geocalc.clas.asu.edu/  (mathematical/physics), http://www.mrao.cam.ac.uk/~clifford/ (physics), http://www.science.uva.nl/ga/ (computer science)
18:22:47 <ddarius> byorgey: ^
18:23:36 <benmachine> haskell-src-exts' fixity resolution is super-brokwn
18:23:39 <benmachine> *broken
18:23:45 <benmachine> well, fairly broken anyway
18:24:12 <ddarius> byorgey: I recommend starting here: http://geocalc.clas.asu.edu/html/Intro.html and here: http://www.science.uva.nl/ga/publications/index.html
18:25:14 <ddarius> byorgey: This deceptively named paper is rather useful a bit later on: http://www.science.uva.nl/ga/publications/content_publications.html#leo_inner
18:26:50 * ddarius lost the code he was writing in his IRC buffer.
18:27:40 <dmwit> byorgey: How did your talk go?
18:28:11 <byorgey> thanks ddarius
18:28:15 <byorgey> and thanks all
18:28:25 <byorgey> I'll study the scrollback and hopefully figure it out =)
18:29:35 <ddarius> byorgey: If you are at all interested in physics (particularly entropy, statistical mechanics, and/or quantum mechanics) I have some more must read links.
18:30:29 <byorgey> ddarius: not particularly.  just interested in computational geometry as far as I need it to implement diagram combinators.
18:30:41 <benmachine> preflex: seen ezyang
18:30:42 <preflex>  ezyang was last seen on #haskell 7 hours, 16 minutes and 23 seconds ago, saying: mmmmmm 
18:30:43 <byorgey> dmwit: it went pretty well, I think, thanks!
18:30:46 <benmachine> mmmmm.
18:31:15 <dmwit> yay!
18:31:47 <mightybyte> dmwit: It was really good.  Very thought provoking.
18:32:12 <ddarius> @let interpretEffect (IOSpec.Done a) _ = ("", Right a); interpretEffect (IOSpec.Fail s) _ = ("", Left s); interpretEffect (IOSpec.Print c eff) inp = let (s',ea) = interpretEffect eff inp in (c:s', ea); interpretEffect (IOSpec.ReadChar f) (c:inp) = interpretEffect (f c) inp
18:32:13 <lambdabot>  Defined.
18:33:24 <ddarius> @let runIOSpec m = interpretEffect (IOSpec.evalIOSpec m IOSpec.roundRobin)
18:33:25 <lambdabot>  Defined.
18:33:28 <ddarius> :t runIOSpec
18:33:30 <lambdabot> forall (f :: * -> *) b. (IOSpec.Executable f) => IOSpec.IOSpec f b -> [Char] -> ([Char], Either String b)
18:33:50 <ddarius> > runIOSpec (IOSpec.putStrLn "fragglerock") ""
18:33:51 <lambdabot>   No instance for (Test.IOSpec.Teletype.Teletype
18:33:51 <lambdabot>                   Test.IOSpe...
18:34:56 <ddarius> :t IOSpec.putStrLn ""
18:34:57 <lambdabot> forall (f :: * -> *). (IOSpec.Teletype IOSpec.:<: f) => IOSpec.IOSpec f ()
18:35:15 <ddarius> Lord that's ugly.
18:37:46 <ddarius> > runIOSpec (IOSpec.putStrLn "fragglerock" :: IOSpec.IOSpec IOSpec.Teletype ()) ""
18:37:48 <lambdabot>   ("fragglerock\n",Right ())
18:38:35 <benmachine> yaaaay
18:42:59 <ddarius> @let runIOSpec' m inp = runIOSpec (inject m :: IOSpec.IOSpec (IOSpec.Teletype IOSpec.:+ IOSpec.ForkS IOSpec.:+ IOSpec.IORefS IOSpec.:+ IOSpec.MVarS IOSpec.:+ IOSpec.STMS) inp
18:42:59 <lambdabot>   TypeOperators is not enabled
18:43:09 <ddarius> *sigh*
18:43:19 <tehgeek> mull :: (Num a) => [a] -> a -> [a]
18:43:19 <tehgeek> mull xs m = map (m*) [xs]
18:43:38 <dmwit> mull xs m = map (m*) xs
18:43:46 <tehgeek> oh god
18:43:48 <tehgeek> I'm retarded
18:43:54 <tehgeek> thanks so much, and sorry to bug with dumb question :\
18:44:04 <tehgeek> school has got my brain operating at 2% efficiency
18:44:06 <dmwit> But, preferred would be mull :: Num a => a -> [a] -> [a]; mull m = map (m*)
18:44:15 <dmwit> or even mull = map . (*) if you feel clever. =)
18:44:16 <benmachine> map . (*) -- :>
18:44:20 <benmachine> yes
18:44:22 <benmachine> that >_>
18:44:34 <tehgeek> I don't feel clever, I feel like getting my assignment doing what it's supposed to do, by hook or by crook
18:44:34 <tehgeek> lol
18:44:39 <tehgeek> thanks again
18:45:16 <dmwit> (I would probably even manually inline a function that simple.)
18:45:19 <ddarius> @let runIOSpec' m inp = runIOSpec (inject m :: IOSpec.IOSpec ((IOSpec.:+:) IOSpec.Teletype ((IOSpec.:+:) IOSpec.ForkS ((IOSpec.:+:) IOSpec.IORefS ((IOSpec.:+:) IOSpec.MVarS IOSpec.STMS)))) inp
18:45:19 <lambdabot>   TypeOperators is not enabled
18:45:36 * ddarius is just SOL.
18:46:03 <dmwit> TypeOperators?
18:46:04 <ddarius> :t IOSpec.Inl
18:46:05 <lambdabot> forall (f :: * -> *) x (g :: * -> *). f x -> (IOSpec.:+:) f g x
18:46:07 <dmwit> What does that even do?
18:46:20 <pumpkin> it's like Left
18:46:21 <dmwit> Oh, type constructors with a name that starts with :?
18:46:38 <byorgey> yep
18:46:41 <ddarius> dmwit: It allows operator syntax for type constructors.
18:47:07 <ddarius> dmwit: It's more than that.  It allows (Arrow (~>)) => (a ~> b) -> c
18:47:16 <dmwit> ah
18:47:21 <dmwit> Still, that seems pretty uncontroversial.
18:47:26 <ddarius> dmwit: It is.
18:51:38 <benmachine> @tell ezyang hey, remind me to talk to you about the SRCF (although I might not be around for a few days)
18:51:38 <lambdabot> Consider it noted.
18:51:46 * ddarius could do something with asTypeOf, but he doesn't feel like it.
18:54:40 <djahandarie> What would be the space complexity of     and . (\xs -> zipWith (<=) xs (tail xs)) . traverse   where traverse is an in-order traversal of a binary tree (BinaryTree a -> [a]) ? Would it be possible to get this to perform in O(1) space (exploiting laziness, I imagine)?
18:55:08 <djahandarie> That was my naive way of checking if a given binary search tree is valid, but now I'm not sure it'd be the best way in terms of space efficiency
18:55:43 <ddarius> djahandarie: It should be constant time assuming you don't count in bringing in the tree (i.e. assuming the tree is already fully in memory.)
18:55:55 <ddarius> s/time/space
18:56:35 <djahandarie> That wouldn't be the case in a strict language though, right?
18:56:46 <ddarius> There will be stack space used by the traversal that is theoretically able to be eliminated.  It will take O(log (size tree))
18:56:51 <ddarius> djahandarie: Of course not.
18:56:53 <tommc> I'm trying to work out what makes NoSQL databases appealing? Is it that people hate SQL, or does the support come from people favouring dynamically typed languages. As a haskeller, I don't see how you can lose having type constrains over your data... am I missing something?
18:57:03 <djahandarie> Hmmm
18:57:33 <ddarius> But, essentially, only one or so cons cell of any of the intermediate lists need be live at any point.
18:57:40 <ddarius> Deforestation may even eliminate those.
18:57:45 <djahandarie> Right
18:58:07 <ddarius> (Though probably not the one produced by traverse.)
19:02:32 <djahandarie> ddarius, hm, so would I need to do something explicit to avoid using that stack space?
19:04:04 <ddarius> Actually, depending on how you implemented traverse the "stack" would probably actually be stored on the heap (much like how CPS moves stack frames to the heap).
19:05:20 <djahandarie> It isn't immediately clear to me what would make the difference in traverse
19:05:35 <ddarius> djahandarie: What's your definition of traverse?
19:05:45 <djahandarie> I don't have one
19:06:44 <djahandarie> I imagine I'd do explicit recursion using pattern matching on the node
19:07:24 <ddarius> Okay, well if it looks like traverse (Leaf a) = (a:); traverse (Branch l x r) = traverse l . (x:) . traverse r then the stack is represented in the "list" of (x:) . traverse r as you traverse down the left side.
19:08:11 <ddarius> djahandarie: If you eta expand that definition you'll see that it is rather obvious, though it is very pretty and intuitive in this form.
19:09:21 <djahandarie> What do you mean by 'represented in the list'?
19:09:39 <ddarius> djahandarie: Anyway, the only way I think I know of getting rid of the "stack" usage (and not just moving it around) is through pointer reversal, which ain't happening in Haskell (and is pretty undesirable in many cases anyway.)
19:11:04 <djahandarie> Wouldn't O(1) space usage be fairly simple in an imperative language?
19:11:06 <ddarius> djahandarie: traverse (Branch (Branch (Leaf 1) 2 (Leaf 3)) 4 (Leaf 5)) reduces to traverse (Leaf 1) ((2:) . traverse (Leaf 3) . (4:) . traverse (Leaf 5))
19:12:08 <ddarius> djahandarie: It wouldn't be hard but it is easy to screw and would require a mutable tree type (and possibly some interesting typing) and would be a very bad idea in a parallel/concurrent setting.
19:12:21 <ddarius> See the paper "Recycling Continuations"
19:12:22 <djahandarie> Hmm
19:12:33 <djahandarie> Okay, thanks for all that
19:13:40 <ddarius> If you did want to purely model the pointer reversal approach, you could potentially use a zipper and get the right effect.
19:20:59 <djahandarie> ddarius, a pointer reversal would be considered a mutation, right?
19:22:11 <ddarius> Yes.
19:22:49 * hackagebot hsignal 0.1.3 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.1.3 (VivianMcPhail)
19:32:08 <cobra> (\p -> foo (snd p) == y)
19:32:14 <cobra> how do i convert that to point free?
19:33:12 <Veinor> I think it's (==y) . foo . snd
19:33:17 <Veinor> @pl \p -> foo (snd p) == y
19:33:17 <lambdabot> (y ==) . foo . snd
19:36:01 <monochrom> @faq can haskell read my brain?
19:36:01 <lambdabot> The answer is: Yes! Haskell can do that.
19:43:43 <ISF_ec09> hi, how do you guys make a flowchart for describing functional programs?
19:44:33 <aavogt> ISF_ec09: http://hackage.haskell.org/package/SourceGraph
19:44:34 <Adamant> we mostly don't use flowcharts.
19:44:50 <aavogt> visualizations are good
19:45:14 <Adamant> sure, but flowcharts aren't a really great visualization
19:45:22 <aavogt> also this  http://hackage.haskell.org/package/graphmod
19:45:40 <aavogt> Adamant: what do you do?
19:45:50 <Adamant> aavogt: UML :P
19:46:09 <Adamant> aavogt: mostly I don't use flowchart kind of visualizations.
19:46:15 <aavogt> why isn't that a flowchart to you?
19:46:38 <Adamant> aavogt: it's the OO version of a flowchart
19:46:48 <Adamant> also I'm not serious
19:47:43 <ISF_ec09> Adamant: aavogt: many thanks!
19:52:39 <Philippa> I'd be more likely to make a call graph based on an AST-ish representation of code, I guess
19:54:20 <Adamant> Philippa: I do like CFG-type graphs of code
19:55:04 <Adamant> for the stuff a flowchart usually does, I'd probably prefer a FSM visualization if it would work
19:55:30 <Adamant> but for a lot of folks, the flowchart might be clearer
19:56:04 <aavogt> Adamant: do you know examples of such things?
19:56:14 <Rotaerk> I prefer infinite state machines
19:56:27 <Adamant> aavogt: of CFG-type stuff? a lot of reverse engineering tools use that now
19:56:40 <Adamant> which is kind of where I picked up that preference
19:57:08 <Adamant> aavogt: the SourceGraph package can probably be used to produce essentially similar stuff
19:57:51 <Adamant> aavogt: I'm not saying that's truly better or whatever; that's really just the first time I kind of saw the benefits of code visualization and it may just be personal preference
19:57:54 <jahnke> Hi. I' trying to solve this <http://programmingpraxis.com/2009/02/19/sieve-of-eratosthenes/> problem, but i can't implement one of the sugested optimizations. Can someone help me? This is my code: http://hpaste.org/40261/sieve_of_eratosthenes
19:58:49 <jahnke> The problem is in primes''. This function runs really slow compared to primes''.
19:59:00 <Adamant> aavogt: for FSM-type stuff, I think Ragel does visualizations
19:59:01 <jahnke> (Sorry if my english it too bad)
20:01:57 <Adamant> aavogt: I picked the FSM habit up from looking at Zed Shaw's use of explicit FSM's in his server code to make code that he was doing that was basically a implicit FSM easier to reason about and less error-prone/more secure.
20:04:44 <aavogt> how do you visualize your code that's not a regular language as a FSM?
20:05:00 <cobra> anyone familiar with this error: epollControl: does not exist (No such file or directory)
20:05:09 <Adamant> aavogt: that's when you would use a flowchart :P
20:06:44 <Adamant> aavogt: I qualified the FSM stuff with "if it would work" because I know not everything can work as a FSM due to not being a regular language
20:06:51 <ivanm> Adamant: FSM = Flying Spaghetti Monster?
20:07:03 <Adamant> ivanm: Finite State Machine
20:07:06 <ivanm> ahhh
20:07:18 * ivanm was wondering what the noodly one had to do with programming
20:07:20 <Adamant> common in EE stuff and CS Theory
20:08:53 <Philippa> you can make a lot of haskell code look like FSM-on-a-monad and things like that, which can be helpful
20:09:36 <gwern> anyone here familiar with hakyll?
20:09:56 * aavogt knows what it is
20:10:03 <gwern> not good enough :)
20:11:03 * hackagebot xilinx-lava 5.0.0.8 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.8 (SatnamSingh)
20:13:28 <sm> gwern: yes sir!
20:13:40 <gwern> well, that makes sense
20:13:58 <gwern> sm: I've been trying to rewrite the Hakyll site into my own wiki
20:14:30 <gwern> and I have the odd problem that hakyll build results in a 'tail' error
20:15:05 <gwern> sm: so I think I must be doing something wrong, but am not sure what
20:15:24 <sm> tail ? like a runtime error ? sounds like a bug
20:16:25 <gwern> sm: current hakyll.hs: http://hpaste.org/40262/hakyllhs files: http://hpaste.org/40263/file_list
20:16:29 <gwern> sm: this is with HEAD hakyll
20:17:18 <gwern> sm: and here's the run output: http://hpaste.org/40264/hakyll_error
20:18:06 <sm> I have to ask, is pages an empty list ?
20:18:08 * gwern is reinstalling hakyll right now since I added table-of-contents to the pandoc options
20:18:31 <gwern> sm: I have no idea. I tried to print it out but it's a monad and stuff
20:19:23 <sm> pshh.. well I'd try commenting the lot and uncommenting one line at a time to narrow it down
20:20:05 <gwern> comment out what? the mapM is the only thing that does anything beside the directory commands which run without issue
20:20:38 <sm> ok.. and how about if you assign pages to ["somefile"]
20:20:50 <sm> I think you can do IO with just a liftIO $ 
20:20:53 <gwern> sm: interesting, if I change the liftM to 'take 10', it works fine
20:21:19 <gwern> sm: no, if I do 'liftIO $ print pages' it's still a type error
20:21:38 <aavogt> ghci debugger?
20:21:43 <gwern> note that 'print "generating files..."' is passing print a String not a Hakyll [String]
20:21:47 <sm> strange, well I use an older released hakyll, as in http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/site/hakyll.hs 
20:23:25 <gwern> hm. if it's liftM (reverse . drop 1 .reverse), I get an error on a PNG
20:23:31 <gwern> the find must be picking up too many files
20:23:56 <kriomant> hello all. newbie question: say I have function "getLine :: IO String" and "process :: [String] -> [String]", how to make interactive program out of them, i.e. it should print next result item as soon as enough input was fed to "process"?
20:24:08 <gwern> throw in a havingExtension ".markdown"...
20:24:21 <gwern> @hoogle interfact
20:24:21 <lambdabot> No results found
20:24:24 <gwern> @hoogle interact
20:24:24 <lambdabot> Prelude interact :: (String -> String) -> IO ()
20:24:25 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
20:24:25 <lambdabot> System.IO interact :: (String -> String) -> IO ()
20:24:38 <kriomant> no, no. I have [String] -> [String], not String -> String
20:24:51 <aristid> :t lines <$> getContents
20:24:52 <lambdabot> IO [String]
20:25:08 <aristid> this might do: process . lines <$> getContents
20:25:20 <sm> gwern: your script, only slightly localised, seems to run to completion here
20:25:22 <kriomant> then is reads all input, and then prints all output
20:25:58 <aristid> kriomant: of course
20:26:09 <aristid> kriomant: do you want to read only a limited number of lines?
20:27:05 <kriomant> example: process [] = []; process [a] = [a]; process (a:b:rest) = (a++b) : (process rest); I want to input "bla", "foo" and get "blafoo" immediately
20:27:08 <aristid> kriomant: if you want to print each output line as it is generated, i'm afraid you can't use process as it is.
20:28:10 <aristid> at least not without evil tricks
20:28:22 <Cale> er, won't getContents do just fine?
20:28:42 <aristid> Cale: he has a process :: [String] -> [String]
20:29:24 <aristid> wait
20:29:29 <aristid> maybe i am very confused
20:29:35 <Cale> main = do xs <- fmap lines getContents; mapM_ putStrLn (process xs)
20:29:41 <kriomant> Cale, I tried "getContents >>= putStrLn . show . func . lines"
20:29:48 <kriomant> Cale, it waits for all input
20:29:57 <kriomant> ooops...
20:30:09 <kriomant> show is perhaps the issue...
20:30:36 <Cale> Well, show shouldn't make too much of a difference...
20:30:42 <kriomant> ok, it works with mapM
20:30:45 <Cale> It's pretty lazy too
20:31:19 <kriomant> This works: getContents >>= mapM putStrLn . func . lines
20:31:24 <Cale> You might just want to adjust the output buffering
20:31:27 <kriomant> however, I don't have getContents, but only getLine
20:31:37 <Cale> hSetBuffering stdout NoBuffering
20:31:45 <Cale> (and import System.IO)
20:31:57 <kriomant> Cale, buffering affects show, but not putStrLn? not likely
20:32:29 <kriomant> is putStrLn calls flush every time?..
20:32:30 <Cale> The show of a list of strings contains no newlines.
20:32:40 <gwern> sm: testing it on just the haskell/ subdirectory, it crashes on the very last .markdown, ZZZ.markdown
20:32:58 <Cale> So if you have line buffering, nothing will be printed until the end.
20:33:09 <kriomant> Cale, ok, how to do it with just getLine
20:33:15 <sm> gwern: based on the content ? a pandoc crash ?
20:33:29 <Cale> kriomant: You can't.
20:34:07 <kriomant> Cale, hm... why?
20:34:18 <Cale> (at least, not without knowing something about the function being applied to the lines)
20:34:25 <gwern> sm: I'm not sure. if I toss in a 'reverse . drop 1 . reverse', this apparently eliminates the RLE.markdown from being generated, and prevents a tail crash, even though RLE.markdown generates without a problem
20:34:27 <Cale> because you can't know how many lines you'll need ahead of time
20:34:32 <gwern> sm: I'll try dropping 2
20:35:07 <sm> maybe list files explicitly, and comment out problem ones, to see
20:35:08 <gwern> no, reverse . drop 2 . reverse doesn't crash
20:35:11 <gwern> reverse . reverse does
20:36:24 <kriomant> Cale, full story: I have pure function processing sequence of keyboard events into actions and I want to use events got from Xlib (using nextEvent)
20:36:58 <gwern> sm: even specifying let pages = ["haskell/Run Length Encoding.markdown" ,  "haskell/Wikipedia Archive Bot.markdown" , "haskell/Wikipedia RSS Archive Bot.markdown", "haskell/ZZZZ.markdown"] leads to a crash!
20:37:37 <sm> great, you are homing in :) is there any file that works ?
20:37:37 <Cale> kriomant: Okay, so we can make a magical action like getContents if you'd like to structure things like that. It'll require unsafeInterleaveIO.
20:38:05 <gwern> sm: everything except the lsat file seems to work...
20:38:24 <gwern> [] works
20:38:38 <sm> you mean, the last file no matter what it is ? or ZZZZ ?
20:38:55 <gwern> ["haskell/Run Length Encoding.markdown"] works too
20:39:14 <kriomant> Cale, tnx, I'll read about it
20:39:35 <sm> so if it's ZZZZ, then try removing that file's content progressively
20:40:09 <gwern> ZZZ is empty
20:40:12 <gwern> I made it with touch
20:40:20 <Cale> kriomant: Though, unless your program is particularly simple, that's probably not really the right thing.
20:40:28 <gwern> ah, it crashes with let pages = ["haskell/Run Length Encoding.markdown",  "haskell/Wikipedia Archive Bot.markdown" , "haskell/Wikipedia RSS Archive Bot.markdown"] 
20:40:40 <gwern> sm: that must be it - it is triggered if >=3
20:40:56 <sm> that doesn't sound right
20:41:09 <kriomant> Cale, and what's the right one?
20:41:14 <sm> hakyll isn't that flaky
20:41:15 <gwern> or not?
20:41:17 <gwern> what the heck
20:41:26 <gwern> replacing the RSS one with ZZZZ doesn't crash
20:42:34 <Cale> kriomant: Another thing you could do is to get events and collect them into a list, and repeatedly apply your parser to see if there's any output. But ideally, you'd have a parser which could reply with a response like "I'm not finished after this input, use <this parser> to continue when you get more"
20:43:08 <gwern> sm: if it goes RLE.markdown, WP RSS Arbot.markdown, and ZZZZ.markdown, it crashes
20:43:33 <gwern> yes, it is the RSS bot page that kills it
20:44:05 <gwern> maybe the metadata is killing hakyll
20:44:06 <gwern>  
20:44:32 <gwern> sm: you see any problems with http://community.haskell.org/~gwern/wiki/haskell/Wikipedia%20RSS%20Archive%20Bot.page
20:44:35 <gwern> ?
20:44:56 <gwern> gitit never seemed to complain
20:45:02 <kriomant> Cale, like "data Result i o = Done o | Partial (i -> Result); process :: i -> Result i o" ?
20:45:29 <Cale> kriomant: Yeah, something like that
20:46:19 <sm> gwern: it's the mismatched title-block delimiters
20:46:27 <sm> poor error handling there
20:46:40 <kriomant> Cale, it turns simple pure function based on patterns into something more complex... I'll have to expand complex patterns into sequence of simple ones
20:46:41 * gwern has a sad
20:46:51 <gwern> I spent an hour on this error so far
20:47:07 <sm> good debugging practice :)
20:47:18 <gwern> so they need to be both ---?
20:47:25 <sm> yes
20:48:05 <gwern> ...I'm not sure I made a copy of the half-working version of hakyll.hs that I tore apart trying to fix this issue
20:48:11 <gwern> oops
20:48:34 <Cale> kriomant: The next thing to do would be to build up some functions for composing those, I guess.
20:48:50 <commanace> hey guys... quick question: is it normal that ghc 6.12.3 needs 2 GB of diskspace to compile??
20:48:56 <Zao> Probably.
20:49:13 <gwern> yay hakyll build finished!
20:49:28 <gwern> now I can ask questions like 'why the heck aren't the markdown pages linking to each other?'
20:49:37 <Cale> commanace: Are you hacking on it?
20:49:55 <Cale> commanace: If not, I don't recommend compiling it yourself.
20:50:12 <sm> yay
20:50:17 <sm> ask away
20:50:17 <kriomant> Cale, seems like this transformation can be fully automated, so I'm wondered it isn't possible in Haskell... and why isn't this approach used everywhere instead of getContents?
20:50:19 <Cale> (There are binaries, and you need a GHC to compile GHC anyway)
20:51:29 <gwern> sm: by which I mean http://community.haskell.org/~gwern/wiki/Front%20Page.page is linked by gitit to the other pages in the same directory, but those links are just broken in hakyll. I'm reading the docs but in the example sites this seems to work
20:51:44 <commanace> Cale: no, i'm not hacking on it... it's just gentoos standard way to install things :P
20:52:16 <commanace> Cale: but maybe there's a bin version... i'll check
20:52:26 <Cale> commanace: There must be.
20:52:31 <gwern> for example, hakyll/reference.markdown:[find it here](reference/index.html). <-- looks like a gitit link
20:52:37 <Cale> commanace: GHC is written in GHC Haskell :)
20:53:04 <Cale> (Though I suppose it needn't be an up to date binary, it would be a shame not to have one)
20:53:18 <sm> looks like a markdown hyperlink, which hakyll should render.. where's the rendered url btw ?
20:53:41 <commanace> Cale: yes, there is :) thanks
20:54:03 <gwern> sm: or do I have to repeat myself? I see 'hakyll/index.markdown:have written a few [tutorials](tutorials.html), and reading them is highly'
20:54:26 <kmc> hi everybody
20:55:01 <sm> that's just another markdown link. [link text](url)
20:56:14 <gwern> hm, in front Page, if I replace '[Chernoff Faces]()' with '[Chernoff Faces](Chernoff Faces.html)' and rebuild, then that link will work
20:56:25 <Cale> kriomant: Well, getContents is intended as a fairly lightweight solution, mainly for small unixy programs. If you have any more complicated interleaving of I/O with your processing, it's probably better to take charge of the order in which things happen properly.
20:56:30 <gwern> sm: you think it'd be possible to make () a shortcut as in gitit?
20:57:11 <Cale> kriomant: Same goes for interact, which is written in terms of getContents
20:57:32 <Cale> kriomant: Pure Haskell functions don't specify an order in which things are computed.
20:57:46 <Cale> (they only specify what is computed)
20:57:55 <sm> that's a gitit modification to standard markdown ? It sounds like a matter of copying that code to hakyll, but also adding some awareness of sibling pages
20:58:15 <kmc> Adamant, i don't agree with your earlier statement about Go
20:58:26 <sm> perhaps for now you could emacs-macro-fix those links.. your filenames seem regular
20:58:30 <Cale> So any transformation which somehow elaborated a pure function into something sequential would have to make some arbitrary choices, that might not match up with what the compiler does.
20:58:30 <kmc> the point of any new mainstream language is to drag some particular subset of programmers kicking and screaming into the 1970's
20:58:42 <gwern> sm: it seems to be a gitit-ism
20:58:45 <gwern> 'Gitit interprets links with empty URLs as wikilinks. Thus, in markdown
20:58:45 <gwern> pages, `[Front Page]()` creates an internal wikilink to the page `Front
20:58:45 <gwern> Page`. In reStructuredText pages, `` `Front Page <>`_ `` has the same
20:58:46 <gwern> effect.
20:59:04 <Adamant> kmc: yeah, but there are a bunch of better attempts at doing that currently that drag us further along
20:59:15 <kevinburke> hey how would you parse an IO Bool to get the boolean condition?
20:59:25 <Adamant> C# 3.0, F#, Clojure, Scala, etc.
20:59:38 <kmc> Go has a little type inference for the static-type-backlash Ruby crowd.  a little safety and convenience for the C crowd.  a little lightweight OOP and first class functions for the AbstractFactoryPatternManagerIteratorFactory crowd
20:59:39 <ivanm> kevinburke: within the IO monad, extract it, use it, return another IO value
20:59:42 <kevinburke> like the input is return 3 < 4
20:59:49 <Cale> kevinburke: What?
20:59:50 <ivanm> kevinburke: you can never (safely) get out of IO
21:00:07 <kmc> Adamant, i'm not sure those strictly dominate Go.  for example, is there a good native-code compiler for any of them?
21:00:08 <Cale> kevinburke: You want to run the IO action to get its result?
21:00:16 <ivanm> kevinburke: note that return in Haskell is different from return in C-like languages
21:00:19 <Adamant> kmc: for all of them
21:00:19 <Cale> kevinburke: b <- myAction
21:00:20 <kmc> C# doesn't have a performant open-source implementation
21:00:21 <b4taylor> So I'm writing some client/server stuff and I have a slight issue. I serve up the data I fetch to the client imediately with bytestrings but closing the handle takes forever.
21:00:23 <kmc> really?
21:00:24 <kevinburke> Cale: i'm not sure what you mean
21:00:25 <Cale> kevinburke: Inside a do-block
21:00:28 <kevinburke> ok
21:00:31 <b4taylor> I've never had this problem before.
21:00:37 <b4taylor> I flush before I try to close too.
21:00:45 <Adamant> kmc: um yes, decent native-code compilers are the price of admission these days
21:00:48 <kmc> last i heard Mono was still a factor of 2-3 slower than MS's .NET stuff, but i haven't kept up-to-date in that world
21:00:59 <Adamant> kmc: yeah, I don't care about Mono
21:01:02 <Adamant> not that it's not important
21:01:03 <kmc> certainly most Clojure and Scala users are running on JVM
21:01:08 <Cale> kevinburke: A value of type IO Bool isn't like a Boolean value. Instead, it's an action, which when executed, will do arbitrary stuff before producing a Boolean result.
21:01:13 <kmc> admittedly you might count a JVM JIT as a native code compiler
21:01:19 <dibblego> Scala only runs on the JVM
21:01:23 <ivanm> kmc: is there really a viable alternate to oracle's JVM?
21:01:25 <Adamant> but I don't use it, and if I did I would use the MS variant
21:01:34 <kevinburke> Cale: there's no like getBool method though
21:01:38 <kmc> ivanm, there's an experimental Clojure .NET project i think
21:01:43 <ivanm> kevinburke: what do you want getBool for?
21:01:52 <b4taylor> ivanm: It's linked to on the clojure page too I think.
21:01:55 <Cale> kevinburke: Well, the Boolean result might depend on user input.
21:01:57 <ivanm> kevinburke: what are you trying to do?
21:01:58 <kevinburke> ivanm: to figure out whether the action evaluates to true or to false
21:01:59 <kmc> anyway so Adamant, how do i compile C# or F# to native code using a free, Free toolchain?
21:02:06 <Adamant> the JVM with JIT is close enough to a optimized true native code compiler it mostly doesn't matter
21:02:06 <Cale> kevinburke: and might be different each time the action is executed
21:02:18 <Adamant> kmc: you don't, you use the MS one, which will do that just fine
21:02:19 <ivanm> kevinburke: the _result_ of the action might, but is there any reason it is in IO?
21:02:23 <kmc> Adamant, on Linux too?
21:02:33 <ivanm> Adamant: some of us prefer FLOSS...
21:02:40 <b4taylor> http://github.com/richhickey/clojure-clr
21:02:47 <Cale> kevinburke: You can compose IO actions together into more elaborate IO actions using do-notation, and eventually the main action of your program is an IO action too.
21:02:55 <Adamant> ivanm: then using C# is not a good idea. I don't use it personally either.
21:02:57 <kmc> Linux is not just some hacker nerd circlejerk anymore, it's the production OS of a great many companies
21:03:19 <Adamant> kmc: right, I'm not suggesting Linux support is not important
21:03:19 <ivanm> kmc: it isn't? damn!
21:03:20 <ivanm> ;-)
21:03:29 <Cale> kevinburke: Inside a do-block for IO, when you write  v <- x  it means to run the IO action x and to name the result of that action v.
21:03:46 <Cale> If x :: IO Bool, then v :: Bool
21:03:57 <kmc> everyone credible player in high-frequency finance uses Linux or FreeBSD except the London Stock Exchange, and their Windows-based system had (in addition to consistently terrible performance) downtime amounting to an entire lost day of trading, causing them to fire their CTO and switch to a UNIX solution
21:03:58 <kevinburke> Ok that makes sense thanks
21:04:04 <Adamant> I'm just saying, you can have Linux support for C# and F#, or a really nice infrastructure for it. pick one. I don't use either personally because I am not their market
21:04:12 <Cale> You can then use v in the remainder of the do-block as you would use any Bool value.
21:04:24 <sm> gwern: it could probably be done in your hakyll.hs, without changing hakyll itself, using createCustomPage instead of createPage. Me, I'd fix up the links and let the hakyll list do the coding
21:04:28 <Cale> and the do-block as a whole is another IO action
21:04:43 <ivanm> kevinburke: note that what Cale is describing is syntactic sugar around IO's >>= (aka bind) function; this is the thing (or one of; also see join) that defines a Monad (as opposed to an Applicative Functor)
21:04:44 <gwern> sm: heh. does the hakyll list implement such requests quickly?
21:04:46 <ivanm> @type (>>=)
21:04:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:04:51 <kmc> Adamant, ok, but i started out claiming that Go is better than C#/F# in certain ways, and i seem to have sustained that claim
21:04:56 <Adamant> kmc: it's kind of horrifying that stock exchanges are depending on either Linux or FBSD
21:04:59 <sm> I think they might, this is a tasty feature request
21:05:06 <kevinburke> ivanm: i don't understand what you just wrote
21:05:10 <kmc> "Go is better than C# if you need to use Linux"
21:05:12 <kmc> seems pretty legit to me
21:05:13 <ivanm> kevinburke: ^^ >>= let's you "extract" a result from a monad and then run a function that returns a monad from it
21:05:15 <sm> @seen jaspervdj
21:05:15 <lambdabot> Unknown command, try @list
21:05:15 <preflex>  jaspervdj was last seen on #haskell 1 day, 13 hours, 27 minutes and 58 seconds ago, saying: copumpkin: hmm, I see
21:05:19 <kmc> Adamant, what would you have them use?
21:05:20 <Adamant> kmc: maybe for a certain subset that wouldn't just use Scala or Clojure
21:05:25 <ivanm> Adamant: why?
21:05:44 <ivanm> Adamant: IIRC, the london stock exhcange tried switching to windows; MS made a whole song and dance about it
21:05:51 <Adamant> ivanm: because it's important and Linux and FBSD are not exactly high-reliability OS'es
21:05:55 <ivanm> within about 6 mths, they switched back
21:06:10 <ivanm> Adamant: ..... so what would you class as a "high reliability OS" ?
21:06:10 <Adamant> ivanm: the alternative is not Windows
21:06:11 <ivanm> Minix?
21:06:15 <kmc> Adamant, it's not actually as important as keeping airplanes flying or nuclear reactors from melting down
21:06:17 <Adamant> ivanm: OpenVMS
21:06:25 <Adamant> kmc: true, but it's still important
21:06:25 <ivanm> that's still around? :o
21:06:34 <kmc> Adamant, high-assurance software is *really* expensive
21:06:47 <kmc> if you want something more reliable than well-configured well-administered Linux then you pay *out the ass*
21:07:06 <Adamant> ivanm: amazingly, despite HP's intentional and unintentional attempts at destroying it, yes
21:07:07 <ivanm> kmc: for experience with said platform as well probably
21:07:14 <Adamant> and with 15-year uptimes no less
21:07:19 <Adamant> kmc: that is definitely true.
21:07:47 <Adamant> Minix 3 could be a high-reliability OS, but not as currently constituted
21:07:49 <ivanm> Adamant: IIRC, long uptimes like that are bad in the case of "when you do have to reboot, what happens if your system is fubared?" case
21:07:58 <kmc> Adamant, so feel free to start an ECN which runs on IBM mainframes, or a bespoke high-reliability formally proved hard realtime Haskell EDSL from Galois
21:08:02 <kmc> and charge the fees you need to charge
21:08:05 <kmc> and see if anyone trades with you
21:08:10 <ivanm> which is why I've seen some reports saying that ksplice is a bad idea
21:08:28 <Adamant> ivanm: OpenVMS used and pioneered cluster stuff to get around that.
21:08:45 <sm> gwern: got to go soon.. do you have the recipe for running hakyll on commit ?
21:08:54 <gwern> no
21:08:58 <Adamant> kmc: I don't want to do finance, dude, I just want the stock market not to melt down again, this time for technical reason
21:09:07 <Adamant> *reasons
21:09:26 <arw> no stock market will melt down because there is no trading
21:09:26 <ivanm> Adamant: I find it highly unlikely that when it next fails it will be due to purely technical reasons
21:09:27 <b4taylor> ivanm: I am having an issue with hClose.
21:09:41 <kmc> and especially due to technical reasons at the exchange
21:09:47 <Adamant> that still tends to make life miserable for the rest of us that don't care about it
21:09:48 <sm> I used http://joyful.com/repos/hledger/_darcs/prefs/defaults, and then http://joyful.com/repos/hledger/Makefile -> "site:"  (builds hakyll then does hakyll build, plus some irrelevant bits)
21:09:48 <kmc> there are frequently technical glitches at exchanges
21:09:49 <ivanm> someone stuffing up, deliberate sabotage (terrorists, etc.) or someone gaming the system are much more likely IMHO
21:09:56 <ivanm> b4taylor: how so?
21:09:58 <b4taylor> Wait maybe I should concoct a smaller example.
21:09:59 <kmc> usually nothing to do with OS, more likely communications links going down
21:10:01 <Adamant> good deal
21:10:12 <kmc> some people make money, some lose money, but the long-term consequences are marginal
21:10:20 <b4taylor> ivanm: Oh I do a transfer and the data gets moved really quickly and when I close the handle it takes forever.
21:10:21 <arw> Adamant: usually trading is stopped when there are signs of meltdown, so i guess trading computers beeing unavailable shouldn't make that much of a dent.
21:10:33 <ivanm> b4taylor: *shrug*
21:10:36 <Adamant> cool
21:10:39 <ivanm> I'm not an expert on IO ;-)
21:10:48 <kmc> anyway there's a lot of fearmongering about the technical side of finance
21:10:50 <b4taylor> lol
21:10:52 <kmc> by people who don't know much about it
21:10:56 <sm> Adamant: jeez, maybe the stock exchange machines should melt down more often and we'd be in less trouble ?
21:10:58 <b4taylor> I'm going to try to break it with a smaller example.
21:11:11 <sm> slow them down, y'know
21:11:23 <ivanm> sm: hmmm, good idea
21:11:37 <arw> one should really worry more about embedded systems in planes, cars or nuclear power plants imho.
21:11:41 * ivanm still finds it amazing that "financial experts" get paid so much money to play with other people's money
21:12:01 <kmc> ivanm, if you can make someone's money double in a year, they're right to pay you a lot
21:12:09 <kmc> what's amazing is that they get paid so much *without* delivering anything
21:12:30 <Adamant> sm: ironically, if people expect shit to break due to the fact it breaks all the time, that can be less catastrophic than if people expect shit to never break and now and then in a blue moon, it does
21:12:56 <Adamant> they plan differently and have different expectations
21:13:00 <ivanm> kmc: except they're doubling your money by gaming the system IMHO
21:13:10 <kmc> what does "gaming the system" mean
21:13:17 <kmc> they're playing a game yes
21:13:20 <ddarius> kmc: That's only true if, without their advice, you would have performed better or at least equally well.
21:13:28 <ivanm> I have never understood how it makes sense that just because people want to buy shares in your company its value can go up, and so more people want to buy shares, etc.
21:13:52 <kmc> ivanm, it seems you just explains how it makes sense
21:14:00 <sw17ch> financial systems aside, does any one know the 'right way' to do Regex in haskell? it's something i havent done yet
21:14:17 <sw17ch> hackage is bursting with 'regex' stuff
21:14:31 <kmc> sw17ch, look at haskell platform for starters
21:14:36 <ivanm> kmc: why does it make sense? your physical worth hasn't increased, your not increasing any sales, etc.
21:14:45 <ivanm> sw17ch: RWH has a chapter on it
21:14:46 <Adamant> sw17ch: don't use regex's unless you truly have a regex problem, if you're coming from a regex-heavy background
21:14:49 <ivanm> using the regex-* libraries
21:14:58 <Adamant> like a Perl/Python/Ruby user
21:15:00 <kevinburke> so i tried 
21:15:08 <kevinburke> where a is an IOBool in the function definition
21:15:14 <sw17ch> no, like, this has to be regex
21:15:20 <kevinburke> do { d <- a; if d then b else c}
21:15:21 <sw17ch> i'm using parsec for some other parts, but i need to embed a regex into a string
21:15:23 <ivanm> Adamant: yeah, what was that quote regarding regexes and problems?
21:15:28 <kevinburke> and i'm getting Couldn't match expected type `IO Bool'
21:15:28 <kevinburke>            against inferred type `IO a -> Bool'
21:15:36 <ivanm> kevinburke: what is your a ?
21:15:43 <sw17ch> which library does Platform ship with?
21:15:48 <ivanm> and where are you getting it from that it has to be a "IO Bool"
21:15:50 * sw17ch could go look...
21:15:59 <ivanm> sw17ch: IIRC, regex-base, -posix, and a couple of others
21:16:02 <ivanm> none of the dfa ones
21:16:04 <Adamant> ivanm: full regexs, not just regular expressions, are basically a EDSL for string processing, and I'm not sure they are a particularly great one generally
21:16:06 <kevinburke> ivanm: it's an input to the function
21:16:17 <kevinburke> ivanm: it's a part of the problem
21:16:39 <sw17ch> i just need very basic regex...
21:16:46 <sw17ch> like the style supported by jQuery selectors
21:17:00 <sw17ch> $("['id^=start_']")
21:17:01 <sw17ch> and such
21:17:08 <ivanm> kevinburke: OK, try pasting your entire attempt somewhere
21:17:11 <ivanm> @paste
21:17:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:17:25 <ivanm> Cale: ^^ fix that please? chrisdone has a new hpaste up!
21:17:28 <ivanm> @where hpaste
21:17:29 <lambdabot> http://hpaste.org/
21:17:31 <ivanm> kevinburke: ^^
21:18:19 * hackagebot contstuff 0.4.1 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.4.1 (ErtugrulSoeylemez)
21:18:55 <sm> night all
21:18:59 <kevinburke> @paste
21:19:00 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:19:12 <kevinburke> how do i paste the code i just loaded?
21:19:28 <ivanm> kevinburke: don't use moonpatio
21:19:28 <kevinburke> @paste #40265
21:19:28 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:19:36 <ivanm> kevinburke: just paste us the link ;-)
21:19:39 <kevinburke> OH
21:19:44 <kevinburke> http://hpaste.org/40265/io_bool
21:20:02 <ivanm> (hpastebot isn't back up and running yet)
21:20:09 <Cale> kevinburke: You have one too many IO a's in your type signature
21:20:18 <ivanm> yeah, I was about to say that
21:20:35 <ivanm> Cale: care to fix the @paste link?
21:20:47 <kevinburke> oh
21:20:58 <kevinburke> man i feel stupid now
21:22:15 <ivanm> kevinburke: http://hpaste.org/paste/40265/better_layout#p40266
21:22:22 <ivanm> a better layout of your code
21:22:26 <ivanm> (there are other variations)
21:22:38 <kevinburke> ivanm: Cale: why was I getting the error Couldn't match expected type 'IO Bool' against inferred type 'IO a -> Bool'? isn't a the first argument in both cases?
21:22:43 <ivanm> note especially that the indentation of the type sig is something I picked up from somewhere; not everyone does it
21:23:43 <ivanm> kevinburke: not quite sure tbh; I wouldn't have expected that error
21:23:44 <kevinburke> ivanm: ok
21:24:00 <ivanm> something more to do with how (IO a -> IO a) doesn't match IO a
21:24:25 <Cale> ivanm: It'll require recompiling lambdabot, and the build fails at the moment
21:24:31 <ivanm> Cale: :(
21:24:34 <Cale> ivanm: (no libreadline)
21:24:50 <ivanm> ugh
21:24:52 <kevinburke> ivanm: shouldn't it be http://hpaste.org/paste/40265/better_layout_fix#p40267
21:25:05 <ivanm> Cale: really old ghc that it still wants libreadline?
21:25:23 <Cale> lambdabot itself depends on it, I think
21:25:28 <ivanm> kevinburke: oh, right
21:25:29 <ivanm> yeah
21:25:42 <ivanm> I normally wouldn't call the input var bl, but couldn't think of a better name
21:25:48 <kevinburke> ok
21:26:03 <ivanm> (since I'm more likely to not pass around "IO Bool" values in the first place, but use/consume them when I get them)
21:26:10 <kevinburke> Yeah
21:26:26 <kevinburke> i think the goal of the exercise is to learn how to wrap things inside do statemnets
21:27:34 <Cale> and I guess, to learn that you can implement your own control structures if you need them
21:29:16 <augur> kevinburke: any relation to james burke?
21:29:21 <kevinburke> No, sorry
21:29:25 <augur> shame!
21:30:17 <kmc> what about william burke
21:30:34 <augur> him too
21:30:37 <kevinburke> No haha
21:30:38 <kmc> http://www.harkavagrant.com/index.php?id=222
21:30:55 <kevinburke> the grave robber?
21:31:00 <kmc> and murderer
21:31:42 <ivanm> augur: are you an ancient roman priest?
21:31:45 <ivanm> ;-)
21:31:49 <augur> yes.
21:32:41 <ivanm> read any good intestines lately?
21:33:25 <augur> augurs do not read intestines
21:33:30 <augur> we read bird flight patterns.
21:34:32 <ivanm> oh, right
21:34:33 <ivanm> silly me
21:34:54 <Adamant> en la Francais, nous namez les augurs de 'guts' 'entraileurs'
21:35:01 <gwern> haruspexs do the guts
21:35:23 <gwern> fearful jealous of their professional prerogatives those haruspexs and hepatoscopists
21:35:31 <ivanm> eh, I'll stick to something more reliable
21:35:34 <ivanm> like magic eight balls ;-)
21:35:35 <augur> gwern: as it happens, the quote for when people mistakenly say "like a drill?" involves haruspexeses
21:35:43 <gwern> ?
21:35:46 <Adamant> ivanm: weather modelling?
21:36:04 <ivanm> Adamant: see the next statement I made ;-)
21:36:09 <Adamant> :P
21:36:28 <ivanm> IIRC, weather modelling has around 70% prob for 7 day forecasts nowadays...
21:36:37 <Adamant> yeah, they have improved a lot
21:37:18 <augur> Lili Marquett: Interesting name, "augur". Like the drill?
21:37:18 <augur> Augur: That's "auger" with an "e", I'm "augur" with a "u". Two "u"s actually... An auspex.. a haruspex.. a seer! a prophet! an AUGUR.
21:37:28 <Adamant> climate modeling, on the other hand... no matter what your opinion on global warming, as a science it's still a total goat-fuck.
21:37:40 <gwern> augur: that is terrible
21:37:54 <augur> its awesome shut up :|
21:37:55 <ivanm> Adamant: oh, they can do general trends reasonably well IIRC
21:38:00 <ivanm> gwern: agreed
21:38:29 <sw17ch> quick poll: does any one here actually _enjoy_ the way haskell does JSON?
21:38:56 <augur> no
21:39:01 <roconnor> what's JSON?
21:39:01 <ivanm> I don't use JSON, so shmeh
21:39:07 <ivanm> @google wikipedia json
21:39:08 <lambdabot> http://en.wikipedia.org/wiki/JSON
21:39:08 <lambdabot> Title: JSON - Wikipedia, the free encyclopedia
21:39:12 <sw17ch> roconnor, JavaScript Object Notation
21:39:15 <ivanm> roconnor: you obviously never read RWH!
21:39:24 <sw17ch> looks like this: {"a" : [1,2,3,4]}
21:39:27 <Adamant> ivanm: I have no idea whether global warming is real or not, so I'll accept the opinions of experts that given current data and knowledge it probably is. but the computer modelling I've seen done on climate research makes me want to cry.
21:39:44 <sw17ch> does any one have ideas that would make it easier? better? less painful?
21:39:45 <ivanm> sw17ch: though when you say "the way Haskell does JSON", you of course mean "the API of the JSON library for Haskell that I'm currently using/looking at", don't you?
21:39:54 <sw17ch> ivanm: Text.JSON?
21:39:54 <ivanm> since Haskell-the-language has no concept of "JSON"
21:39:55 <sw17ch> then yes
21:40:11 <kmc> sw17ch, there's a lot of JSON libraries
21:40:18 <sw17ch> kmc: i think i hate them all
21:40:21 <kmc> i like http://hackage.haskell.org/package/JSONb
21:40:22 <roconnor> sw17ch: looks kinda like the nix language
21:40:24 <ivanm> sw17ch: even attojson? :o
21:40:25 <kmc> i wrote a little utility to help with them
21:40:32 <kmc> my utility is http://hackage.haskell.org/package/jspath
21:40:37 <sw17ch> roconnor: it's what the internet runs on since it rose up and fired XML
21:40:37 <roconnor> well the data types found in nix
21:40:41 <ivanm> it has "Atto" in it, it _must_ be good! ;p
21:40:44 <sw17ch> at least, that's what the rails guys use now :)
21:40:54 <ivanm> roconnor: probably due to the opposite influence
21:41:02 <ivanm> (in that nix is based upon JSON)
21:41:03 <kmc> roconnor, there's a thousand and one ways to encode nested dictionaries of strings and numbers
21:41:06 <ddarius> Adamant: You don't need computer modeling to measure and compare, only to extrapolate that the climate will keep warming.
21:41:09 <sw17ch> well, i had an idea... i think it pulls it closer to being able to use it like Python does
21:41:33 <ivanm> damn there's a lot of libraries oh hackage with json either in the title or description...
21:41:40 <sw17ch> ivanm: hence why i get so frustrated
21:41:47 <Adamant> sw17ch: s/internet/web 2.71828
21:41:49 <sw17ch> they all do basically the same thing, just slightly differently
21:41:54 <ivanm> sw17ch: and you really tried them all?
21:41:59 <sw17ch> no, not really
21:41:59 <sw17ch> :)
21:42:07 <roconnor> sw17ch: how does "haskell" handle json?
21:42:27 <sw17ch> roconnor, it handles it by serialization
21:42:32 <Adamant> ddarius: right, except that's the several trillion dollar question.
21:42:39 <sw17ch> for the most part, all the libraries convert to or from haskell objects
21:42:48 <ddarius> Adamant: http://www.ted.com/talks/rob_dunbar.html
21:43:01 <ivanm> roconnor: I already asked clarification on that ;-)
21:43:23 <ivanm> roconnor: <ivanm> sw17ch: though when you say "the way Haskell does JSON", you of course mean "the API of the JSON library for Haskell that I'm currently using/looking at", don't you?
21:43:24 <roconnor> sw17ch: JSON is a recursive data type with string, number, attribute set constructors?
21:43:34 <ivanm> roconnor: something like that, yes
21:43:50 <sw17ch> yes, pretty much. it's value is that it's simple, human readable, and JavaScript can parse it with eval()
21:44:03 <sw17ch> so it's used very heavily in AJAX and various other web 2000.0
21:44:05 <sw17ch> things
21:44:07 <roconnor> ivanm: that is the obvious encoding
21:44:11 <ivanm> sw17ch: where "human readable" is taken with a grain of salt ;-)
21:44:16 <ddarius> (which of course is a horrible idea, eval'ing JSON that is.)
21:44:17 <sw17ch> ivanm: yes, in that it's not binary
21:44:21 <sw17ch> ddarius, quite
21:44:21 <ivanm> roconnor: well, IIRC it's string, number, dictionaries and lists
21:44:28 <roconnor> and null
21:44:28 <ivanm> sw17ch: neither is XML
21:44:34 <Adamant> ddarius: honestly, I don't have the physical science chops to have a truly informed opinion on it, so I'm going to punt. I just know enough about CS, statistics, and drawing extrapolations from data points to think that at a minimum, a lot of the original research was to some degree pretty questionable.
21:44:42 <roconnor> sw17ch: so what's the problem
21:44:54 <sw17ch> roconnor, i don't want to make it into a haskell data type before i can use it
21:45:10 <sw17ch> and using the json data types aren't really an option
21:45:12 <ivanm> roconnor: methinks sw17ch is going to write Yet Another JSON library
21:45:26 <sw17ch> ivanm: i'm wrapping Text.JSON actually...
21:45:27 <ivanm> sw17ch: ummm, so what, you want to treat it as raw strings?
21:45:36 <sw17ch> ivanm: hah, we're getting closer
21:45:40 <ivanm> what's wrong with converting it to Haskellian data types?
21:46:06 <ivanm> sw17ch: which library is "Text.JSON" ? json from galois?
21:46:17 <sw17ch> ivanm: sometimes i do'nt want to. sometimes the format i'm dealing with isn't conducive to haskell types. sometimes i just want to pick a single piece out of the tree.
21:46:21 <sw17ch> yes, the galois library
21:46:27 <c_wraith> ech.  I don't like the polymorphism in that library
21:46:29 <ddarius> Adamant: At this point there is quite a bit of evidence that correlates what we think are causes of global warming to high global temperatures and also plenty of proof that global temperature (and a variety of other things) are significantly higher than they have been for a very long time, none of which requires extensive computer modelling.
21:46:41 <sw17ch> c_wraith, Text.JSON?
21:46:49 <c_wraith> sw17ch, yes
21:47:01 <sw17ch> c_wraith, i'm more upset that i'm kinda forced to use String
21:47:07 <sw17ch> i was hoping it would use OverloadedStrings
21:47:07 <manateeUser> I use AttoJSON
21:47:14 * sw17ch goes to look at AttoJSON quick...
21:47:17 <manateeUser> Support ByteString
21:47:21 <roconnor> sw17ch: you don't want to make your jason data type into a haskell data type before you use it?  How can you use it in Haskell without turning it into data for some data type?
21:47:22 <ivanm> ddarius: also, even if global warming per se isn't actually happening, I fail to see what's wrong with limiting the amount of crap that gets vented into the air for us to eventually breathe...
21:47:26 <manateeUser> @package AttoJSON
21:47:26 <lambdabot> http://hackage.haskell.org/package/AttoJSON
21:47:31 <ivanm> roconnor: that's my confusion as well
21:47:50 <Adamant> ddarius: yeah, but are we causing it, can altering our behavior change it, and if we aren't causing it significantly, can we alter it or adapt to it?
21:48:12 <ddarius> ivanm: Carbon dioxide isn't that dangerous to breathe.  We're not anywhere close to making the atmosphere unsafe in that regard.
21:48:31 <ivanm> ddarius: it's everything else that gets vented with the CO_2
21:48:54 <cobra> what's the best package for reading from a config file?
21:49:04 <ivanm> cobra: what kind of syntax?
21:49:06 <sw17ch> how would people feel about a dsl or just ... interpreted string for querying a json object?
21:49:10 <ddarius> Adamant: Watch that talk.  That we're causing it is reasonably evident from the fact that many things suddenly take exponentially rise starting around the mid-50's.
21:49:10 <Adamant> ivanm: for developed countries, yeah. but the ICE is nice and cheap for the developing world and can make a real impact in their lives. if it's not causing global warming, banning it would probably cause more net human harm than not banning it
21:49:12 <ivanm> cobra: in general, you're better off writing your own parser
21:49:14 <aavogt> climate in -blah, no?
21:49:20 <sw17ch> someObject `q` "'a'[0].'b'"
21:49:24 <Adamant> true on -blah
21:49:26 <cobra> ivan: something really simple, and not xml
21:49:38 <manateeUser> Some crazy guy send me 7 patches when i'm open my mail client.....
21:49:51 <kmc> sw17ch, jspath is a DSL for querying a json object
21:49:51 <ddarius> manateeUser: Stop opening your mail client.
21:49:53 <kmc> i feel pretty good about it
21:49:59 <kmc> that's why i wrote it :)
21:50:14 <sw17ch> manateeUser, attojson is much more what i'd like to use for this. thanks!
21:50:18 <roconnor> sw17ch: what's wrong with (a!!0)!!!"b" ?
21:50:19 <kmc> i'm happy to explain its design, or to add features as desired
21:50:26 <ivanm> cobra: there's dyre
21:50:33 <manateeUser> ddarius: :)
21:50:37 <ivanm> and I'm pretty sure there's an INI-style parser
21:50:45 <sw17ch> kmc: ah, that sounds like whati 'm looking for. is that a hackage libarary, or a spec elsewhere?
21:50:46 <roconnor> sw17ch: oh wait, I guess that doesn't quite work
21:50:51 <kmc> sw17ch, http://hackage.haskell.org/package/jspath
21:50:54 <kmc> i linked it just up there
21:51:03 <roconnor> sw17ch: I guess I see
21:51:24 <ivanm> @hackage ConfigFile
21:51:24 <lambdabot> http://hackage.haskell.org/package/ConfigFile
21:51:26 <ivanm> cobra: ^^
21:51:45 <kmc> cool
21:51:59 <roconnor> sw17ch: I would expect in a haskell program the JSON type not to surivive long.  Presumably it should be immediately parsed into your real data type. ... granted this can be difficult to do in a lazy way.
21:52:00 <sw17ch> jspath, that is
21:52:02 <cobra> ivan: yeah, that one looks good but it seems very heavyweight and complicated
21:52:14 <sw17ch> roconnor, sometimes you don't want to. :\
21:52:28 <manateeUser> sw17ch: How about AttoJSON?
21:53:02 <ivanm> cobra: *shrug*
21:53:11 <ivanm> everything else is geared at haskell-style configs
21:53:23 <ivanm> you're usually better off writing a custom parser for the config language you want to use
21:53:57 <sw17ch> manateeUser, i'm at least happy that AttoJSON uses bytestring as a foundational type
21:54:01 <cobra> ivanm: only in the haskell world would you expect such an answer :)
21:54:10 <ivanm> cobra: why?
21:54:11 <sw17ch> are there any that use the text library?
21:54:26 <ivanm> sw17ch: it's taking a while to convince people to stop using bytestrings for textual stuff
21:54:47 <ivanm> cobra: if you have a specific configuration format, why wouldn't you write a parser specifically for that format?
21:54:52 <ivanm> unless you're just using xml or something
21:54:57 <sw17ch> kmc: what do selectors look like?
21:55:03 <kmc> key "foo"
21:55:04 <kmc> idx 3
21:55:17 <cobra> ivanm: in any other language people would try to any type of existing solution before rolling there own parser
21:55:43 <kmc> cobra, in any other language rolling your own parser is a pain in the ass
21:55:49 <cobra> kmc: exactly :)
21:55:55 <kmc> sw17ch, so basically you can do «get (key "foo" :=> key "bar" :=> All Yield) myJsonObject»
21:56:07 <kmc> that will parse something like {'foo': {'bar': [1,2,3]}}
21:56:17 <sw17ch> so if i have a structure like this: {"a": [{"b":1,"c":2}]}, and wanted the 2, i'd have to do something like:  (key "c" $ idx 2 $ key "a" object)
21:56:20 <sw17ch> kmc^^
21:56:20 <kmc> and yield the three objects [Number 1, Number 2, number 3]
21:56:34 <kmc> selectors are not functions you apply with ($)
21:56:38 <kmc> you chain them with (:=>)
21:57:11 <sw17ch> kmc: i'd thought about that, but it's still more verbose than i was hoping... here's the syntax i was considering, or something like it
21:57:14 <kmc> key "a" :=> idx 0 :=> key "c" :=> Yield
21:57:21 <ivanm> cobra: sure, you can use a pre-existing XML library or whatever
21:57:29 <ivanm> and if you're using an XML config file you probably should
21:57:35 <sw17ch> obj `q` "'a'[1].'c'"
21:57:50 <sw17ch> hand it a string, parse it into tokens, walk down the object 
21:57:55 <sw17ch> toss errors if you have problems
21:58:06 <kmc> sw17ch, sure. you could even implement that as a quasiquoter to expand the string at compile time
21:58:19 <sw17ch> kmc: i was looking at json-qq
21:58:23 <cobra> ivanm: the ideal library would be integrated with a command line parser, so that command line options override config file options.
21:58:31 <ivanm> sw17ch: so you're proposing to do run-time parsing each time you want to find something else about the chunk of JSON you're looking at?
21:58:31 <sw17ch> http://hackage.haskell.org/package/text-json-qq
21:58:37 <cobra> ivanm: I actually counted 7 different command line parsers on hackage :O
21:58:40 <sw17ch> ivanm: yes, actually
21:58:41 <ivanm> cobra: we have a few of those actually
21:58:53 <sw17ch> i'm copying jQuery selectors
21:58:56 <ivanm> sw17ch: rather than do a once-off parse + conversion and then doing lookups on that?
21:59:13 <sw17ch> ivanm: once-off parse being the compile time parse?
21:59:34 <ivanm> sw17ch: well, in the sense of "read the JSON in, parse it and convert it to Haskell data types"
21:59:47 <ivanm> and then passing around and using your JSONValue types, etc.
21:59:54 <ivanm> rather than the String holding the JSON
21:59:58 <sw17ch> ivanm: i was planning on converting the json object to the Text.JSON backend represntation (or any of the JSValue implementations)
22:00:05 <ivanm> oh, right
22:00:11 <ivanm> I misunderstood your meaning then
22:00:11 <sw17ch> and then just parsing the query 
22:00:18 <sw17ch> and yanking stuff out with that
22:00:38 <sw17ch> because then i could do something like open this link http://www.reddit.com/r/haskell/.json
22:00:41 <sw17ch> and dig for stuff
22:01:15 <sw17ch> it would easily be expanded to do a regex match on a key (like jQuery can) or other small language features
22:01:35 <sw17ch> well, 'easily'
22:03:25 <sw17ch> (jsonq "{\"name\": \"sw17ch\", \"randomProperty\":\"prop_45_whatever\"}") `q` "'[^random]'"
22:03:30 <sw17ch> or various other witchery
22:03:39 <sw17ch> i haven't thought it out too well yet
22:03:45 <sw17ch> (at least, not the regex integration)
22:04:59 <gwern> do you realize you are living IN THE FUTURE?
22:05:12 <gwern> you can buy 1.5TB of space for 70$! http://forre.st/storage#sata
22:05:18 <ivanm> gwern: go on...
22:05:30 <sw17ch> gwern, damn, i spent $80 on 1TB a week ago. :C
22:05:46 <ddarius> sw17ch: Wait another week.
22:06:01 <ivanm> I spent about $150 on 1TB a couple of weeks ago
22:06:12 <ivanm> but that's AUD, not USD, and it was a WD Cav Black
22:06:16 <ivanm> which are meant to be really good
22:06:45 <gwern> well, if you really are getting quality... but I've not heard that western digital drives are immune to brocking
22:06:48 <gwern> *bricking
22:07:09 <ivanm> good as in fast and reasonably good build quality
22:07:38 <ivanm> I was going to get a 2TB Cav Green as my second HDD, but heard a few weird things with them in servers so I paid an extra AUD$130 to upgrade that to a black as well
22:07:40 <sw17ch> ivanm: mine was a WD Cav Black too
22:07:47 <sw17ch> in USD
22:08:02 <ivanm> sw17ch: yeah, there's currency conversion, + all tech stuff being more expensive here
22:08:09 <ivanm> due to lower throughput, etc.
22:08:09 <sw17ch> ivanm: poor aussies
22:08:15 <ivanm> yeah :(
22:08:37 <ivanm> a lot of people end up buying tech stuff from the USA as it ends up being cheaper, even if they then have no warranties
22:08:42 <sw17ch> can't get violent video games and you pay more for tech toys
22:09:03 <ivanm> oh, we can get the games
22:09:08 <ivanm> well, most of them
22:09:13 <ivanm> they're usually slightly toned down though
22:09:22 <sw17ch> ivanm: L4D2 as an example
22:09:27 <ivanm> yeah
22:09:31 <sw17ch> thuogh, we did get -sillygibs out of the deal
22:09:41 <ivanm> *shrug* I don't play that many games though
22:09:50 * ivanm is going to wait for SC2 to go down and then get that though
22:10:00 <Axman6> you need to learn to go to the computer fairs ivanm 
22:10:10 <ivanm> Axman6: couldn't be arsed
22:10:14 <ivanm> since then there are warranty issues
22:10:35 <sw17ch> Is any one thinking: 'sw17ch, your query string idea sucks. here's why'?
22:10:47 <ivanm> sw17ch: yes to the former, not that much to the latter
22:11:08 <ivanm> except that it looks like you'd have to parse&convert the String each time if you're actually going to be using Strings throughout
22:11:25 <gwern> sw17ch: every day, I think 5 impossible things before breakfast, including your code sucking
22:11:42 <ivanm> gwern: have you had breakfast yet today though?
22:11:42 <sw17ch> ivanm: i'd have to parse the the query once i believe
22:11:55 <ivanm> sw17ch: not the query, the JSON
22:12:03 <sw17ch> oh, i was planning on only parsing the json once
22:12:17 <gwern> ivanm: I suppose the question becomes what is 'today'? is it merely the last 24 hours? then I have. or is it the calendar day? then I have not
22:12:22 <ivanm> and unless you force users to convert the JSON and then run the query on the Text.JSON types, you'd have to keep converting it
22:12:54 <sw17ch> ivanm: my thoght was to convert the input JSON to a Haskell type, then run the parsed queries against the haskell data type
22:12:55 <ivanm> gwern: well, if it's after say 5AM then count it as that calendar day, otherwise the previous calendar day
22:13:01 <ivanm> sw17ch: right, that makes sense
22:13:10 <ivanm> sw17ch: you're examples seemed to have been pure Strings though ;-)
22:13:13 <gwern> ivanm: then I suppose I have
22:13:36 <sw17ch> i'm more worried about using strings as more than strings
22:13:38 * hackagebot plot 0.1.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.1 (VivianMcPhail)
22:13:39 <sw17ch> that rubs me the wrong way
22:13:44 <ivanm> so then you haven't said anything about thinking of impossible things _after_ breakfast!
22:13:47 <sw17ch> ivanm: they were
22:13:59 <ivanm> what's the point of plot as opposed to chart?
22:14:01 <sw17ch> i was hoping the implict conversion to a parsed type was obvious... me stops with the assumptions
22:14:07 <ivanm> or did Vivian not know about Chart?
22:15:13 <gwern> ivanm: truly, you fill a much-needed void with your observations
22:15:27 <ivanm> why thank you my good man for your old fashioned compliment!
22:15:49 <gwern> that wasn't a compliment
22:16:00 <ivanm> that wasn't serious
22:16:25 * gwern likes the multiple parsings of that statement and makes a point of using it
22:17:00 * ivanm tries to remember which tripod song/sketch used the phrase "why thank you for that old fashioned compliment"
22:23:05 <sw17ch> alright, 'im going to give this a shot
22:23:15 <sw17ch> simplistic first, then i'll find a way to make more complex selectors
22:27:41 * hackagebot GoogleSuggest 0.0.4 - Interface to Google Suggest API  http://hackage.haskell.org/package/GoogleSuggest-0.0.4 (AndyStewart)
22:28:43 * hackagebot GoogleTranslate 0.0.5 - Interface to Google Translate API  http://hackage.haskell.org/package/GoogleTranslate-0.0.5 (AndyStewart)
22:37:44 * hackagebot plot 0.1.1.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.1.1 (VivianMcPhail)
23:01:40 <kmc> are there any tools for board-level (as opposed to chip-level) electronic design automation that use Haskell?
23:02:33 <dancor> why isn't there an instance for (Random Word)
23:03:11 <c_wraith> > fromIntegral (-1 :: Int64) :: Word64
23:03:13 <lambdabot>   18446744073709551615
23:03:25 <c_wraith> Don't know, but it looks like it's trivial to implement
23:05:50 <dancor> what's the easiest way to produce a random [Word8]
23:05:56 <dancor> of a given length
23:07:29 <dancor> maybe i should just use System.Random.Mersenne
23:08:36 <aleator> dancor: I also recommend System.Random.MWC. It is fast.
23:09:06 <aleator> Does also have a func to give you vectors of Word8.
23:09:36 <dancor> aleator: looks great, thanks
23:14:47 <mm_freak> copumpkin: i've implemented MaybeT now, will be included in the next release =)
23:14:56 <copumpkin> yay
23:15:05 <mm_freak> newtype MaybeT r m a = MaybeT { getMaybeT :: (a -> m r) -> m r -> m r }
23:15:37 <mm_freak> the reason is:  it has a different Alternative and MonadPlus instance
23:16:00 <ivanm> mm_freak: what are you doing?
23:16:13 <mm_freak> 'empty' corresponds to Nothing, while in EitherT it corresponds to 'empty' from the underlying monad, if any
23:16:23 <mm_freak> ivanm: writing the contstuff library =)
23:16:30 <mm_freak> a library of CPS-based monad transformers
23:16:50 <ivanm> mm_freak == Ertugrul ?
23:16:55 <mm_freak> ivanm: yeah
23:17:22 <ivanm> huh, what ethnic background are you (and hence your name) from?
23:18:10 <mm_freak> ivanm: it's a turkish name
23:18:15 <ivanm> ahhh
23:18:15 <mm_freak> a rare one though
23:18:28 <ivanm> yeah, I was trying to guess which part of europe it comes from
23:18:33 <ivanm> I was obviously off the mark ;-)
23:18:57 <mm_freak> well, part of turkey lies in europe, but honestly i don't know much about my country =)
23:19:04 <ivanm> heh
23:21:49 <mm_freak> i think the most important monad transformers are there now
23:25:23 <Funktorsalat> took me a while to realize you probably don't mean 'in Turkey'
23:25:56 * hackagebot contstuff 0.5.0 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.5.0 (ErtugrulSoeylemez)
23:26:06 <mm_freak> copumpkin: have fun =)
23:26:17 * mjrosenb had a turkish roommate named "ege"
23:26:27 <copumpkin> right now I'm trying to construct a comma category
23:26:32 <mjrosenb> it probably had an accent, but damned if i remember where it was
23:26:33 <copumpkin> it's 8:30 am
23:26:37 <copumpkin> dammit
23:26:41 <mjrosenb> copumpkin: comma is in a -> b -> (a,b)?
23:26:58 <copumpkin> not really
23:27:00 <Funktorsalat> ↓
23:27:14 <mm_freak> mjrosenb: probably the 'g'
23:27:16 <copumpkin> apparently an obsolete notation used a comma between the two functors
23:27:25 <copumpkin> but most people use the down arrow now
23:27:38 <Funktorsalat> copumpkin: in haskell? sounds rather impossible
23:27:46 <Funktorsalat> the thing, not the notation :p
23:27:47 <copumpkin> Funktorsalat: lol no, in agda
23:28:04 <copumpkin> it takes several minutes to typecheck :P
23:28:12 <mjrosenb> copumpkin: is this functor in the category theory sense or in the sml sense
23:28:12 <copumpkin> really annoying
23:28:20 <copumpkin> category theory sense
23:28:22 <mjrosenb> copumpkin: from what i have heard, they are not actually the same.
23:28:50 <Funktorsalat> the ml ones aren't a special case at least?
23:29:01 <copumpkin> I thought they were
23:29:45 <mm_freak> we're approaching languages, where the type system needs more CPU power than the code optimizer
23:30:06 <copumpkin> :D
23:30:07 <mjrosenb> the ml ones are part of the module system, and don't feel very much like values.
23:30:30 <mjrosenb> mm_freak: as long as it doesn't need the power at run time
23:30:45 <mm_freak> mjrosenb: dynamically typed agda?
23:30:50 <mjrosenb> although it does detract from the 'rapid development' advantages
23:30:51 <Funktorsalat> is it doing something intrinsically hard or is it just some inefficieny?
23:30:55 <Funktorsalat> (@ copumpkin )
23:31:39 <copumpkin> a bit of both, I think there are pretty large proof terms behind the scenes, and I get the feeling agda isn't as efficient as it could be :)
23:31:47 <copumpkin> it'd also be nice if it could keep track of what changed in the file
23:31:53 <copumpkin> and only retypecheck the parts that have
23:32:04 <copumpkin> but currently agda has 1GB of my RAM
23:32:11 <copumpkin> and would probably take more if I had more to give
23:32:33 <mm_freak> i could imagine an operating system in agda, which needs several hours to start up, because it tries to prove that the computer won't run forever
23:33:09 <kmc> that's why we need type erasure on installation ;)
23:33:44 <copumpkin> mm_freak: yeah, ideally you'd prove it once during compilation and then at runtime you'd have no slowdown :)
23:35:04 <mm_freak> i have a simpler solution:
23:35:10 <mm_freak> write operating systems in haskell instead =)
23:35:53 <kmc> ugh, haskell is so low level and unsafe
23:35:55 <kmc> you might as well use C
23:36:19 <ivanm> kmc: :o
23:36:26 <jystic> lol
23:36:34 <copumpkin> yeah, I feel that way after using agda for too long
23:36:36 <ivanm> mm_freak: what's wrong with having your computer run forever?
23:36:37 <kmc> when people ask me about Agda I tell them that Agda's interface to the grungy, low-level practical world is that it can call Haskell code
23:36:40 <copumpkin> but then I don't
23:37:03 <jystic> @pl parseGit p args repo = parse' =<< gitCmd args repo
23:37:04 <lambdabot> parseGit = const (((parse' =<<) .) . gitCmd)
23:37:17 <jystic> @pl parseGit p args repo = gitCmd args repo >>= parse'
23:37:18 <lambdabot> parseGit = const (flip flip parse' . ((>>=) .) . gitCmd)
23:37:35 <mm_freak> ivanm: an agda program must be proven to terminate
23:37:36 <Axman6> ouch
23:37:54 <copumpkin> except when it doesn't
23:37:56 <mm_freak> ivanm: if it doesn't terminate, it needs to consume something, codata
23:37:59 <ivanm> mm_freak: huh
23:38:30 <thoughtpolice> i keep wanting to look at theorem provers for real and agda appeals because it's so haskell-like and can in fact call haskell code
23:38:52 <thoughtpolice> maybe i should actually give it a real shot sometime soon
23:38:55 <copumpkin> you should
23:39:26 <mm_freak> as a non-user i like agda, but i'd probably hate it, when i'd actually need to use it
23:39:33 <mm_freak> for real application development that is
23:39:46 <mm_freak> not for writing comma categories =)
23:40:14 <copumpkin> mmm
23:41:08 <mjrosenb> yeah, i haven't found anything that i've thought "this would be awesome to do in agda/coq/twelf"
23:41:24 <mjrosenb> so i have not actually bothered to learn how to use them
23:41:33 <mm_freak> ditto
23:41:46 <mm_freak> though apparently someone wrote a web framework in agda
23:42:23 <copumpkin> mjrosenb: you just haven't gotten addicted to being able to prevent people from constructing bad data
23:42:36 * mjrosenb is not horribly turned on by web frameworks
23:43:09 <mm_freak> http://github.com/larrytheliquid/Lemmachine
23:43:32 <mjrosenb> copumpkin: i wish you had been there when i told my TA "your type system should never allow you to construct a value that isn't meaningful"
23:43:38 <mm_freak> copumpkin: compared to most languages haskell does a great job at that already
23:43:51 <copumpkin> :)
23:43:56 <jystic> copumpkin: what is the quality of the error messages like when you get a compile error?
23:44:08 <kmc> oh yeah oh web frameworks
23:44:14 <copumpkin> jystic: pretty bad, but it depends on why it failed
23:44:18 <copumpkin> some of them aren't too bad
23:44:29 <copumpkin> it's still a very experimental language
23:44:33 <jystic> yeah
23:44:43 <kmc> mjrosenb, what class was it?
23:45:59 <mjrosenb> kmc: principles of programming, better know as feel the warm buzz of being beaten over the head with sml
23:46:06 <mm_freak> i think, GHC isn't that good with error messages either…  compiler errors about "expected/inferred types" make most beginners jump
23:46:19 <kmc> hehe
23:46:21 <kmc> bzzzzzz
23:46:27 <mjrosenb> mm_freak: look at sml/nj's error messages.
23:46:30 <kmc> is that an intro CS class?
23:46:44 <mm_freak> "why the hell can't i add an Int to an Integer?!"
23:46:45 <kmc> i enjoy GHC's error messages for the hilariously bad advice
23:46:55 <kmc> "Probable fix: add an instance for Num (Char -> Int)"
23:47:08 <copumpkin> "just turn on UndecidableInstances"
23:47:09 <jystic> when i was first learning c++ i used to have lots of fun when leaving off a semi-colon would generate 1000s of compiler errors
23:47:11 <copumpkin> said the snake to eve
23:47:47 <mm_freak> jystic: same can happen in haskell, when you forget a 'do'
23:47:54 <mm_freak> print 3 print 4
23:47:58 <jystic> i learnt it in visual studio and it didn't show errors in the order that the compiler reported them so the first error in the list wasn't even close to where the problem was
23:48:10 <Funktorsalat> it says "expected/actual" type in ghc 7 now
23:48:14 <mm_freak> but then it's usually just one very weird type error, not thousands of errors
23:48:26 <copumpkin> template errors are the best
23:48:28 <copumpkin> mmm
23:48:37 <jystic> does agda have the concept of bottom? or is one of the advantages that you don't have bottom
23:48:47 <copumpkin> no bottom
23:48:55 <mm_freak> Funktorsalat: oh, i got so used to 'inferred' =/
23:49:17 <mm_freak> jystic: bottom wouldn't typecheck
23:49:23 <Funktorsalat> mm_freak: I prefer 'actual'
23:49:39 <Funktorsalat> the expected type is 'inferred' too 
23:49:55 <mm_freak> Funktorsalat: yeah, i didn't say it's bad
23:50:02 <wouter__> I want to profile a program with ghc that contains Data.Map ... but i get all kinds of errors... how to solve that?
23:50:03 <jystic> that's really nice
23:50:20 <wouter__> undefined reference to `containerszm0zi3zi0zi0_DataziMap_filter_closure'
23:50:28 <Funktorsalat> having bottom would make it kinda useless as a prover
23:50:29 <Axman6> i love those ones
23:50:29 <mm_freak> but type inference makes me feel great, especially when the compiler complains in terms of it
23:50:37 <Funktorsalat> hehe
23:51:01 <Funktorsalat> "Catastropic failure of the type inference machinery:"
23:51:07 <Funktorsalat> +h
23:51:46 <mm_freak> or when a haskell program crashes:  "The impossible just happened!"
23:51:52 <kmc> wouter__, are you building with ghc --make ?
23:52:03 <wouter__> euhm no ...
23:52:05 <wouter__> ill try
23:52:11 <Axman6> i thought only GHC crashed with the impossible happened error
23:52:13 <Funktorsalat> mm_freak: ah. mine isn't an actual error, I mean prefixing errors with it would keep the 'inference' bit
23:52:14 <kmc> if you invoke ghc by hand you should always use --make
23:52:19 <kmc> it will be the default in ghc 7
23:52:23 <jystic> Funktorsalat: yeah, I haven't played much at all with provers, I'm still trying to get a feel for where I can use them, what they're good for
23:52:24 <wouter__> oke ... thanks
23:52:26 <wouter__> it worked
23:52:28 <kmc> :)
23:52:29 <copumpkin> omg I finished my comma category
23:52:51 <copumpkin> it only ate up 1.2 gigs of RAM to typecheck
23:52:59 <mm_freak> jystic: they are like category theory…  if you don't understand it, you don't need it =)
23:53:01 <Funktorsalat> the object part?
23:53:15 <copumpkin> the slice category was way cheaper
23:54:04 <Funktorsalat> jystic: it's just that propositions are types, and proofs are values... so bottom proves anything
23:54:50 <copumpkin> jystic: they're good for anything you can think of proving within the particular logical system
23:55:12 <mjrosenb> so if anyone has a project euler type thing that agda/coq/twelf is awesome for, let me know
23:55:13 <Funktorsalat> "make me a sammich"
23:55:20 <Funktorsalat> oh no, not a proposition ;)
23:56:23 <kmc> mjrosenb, have you used coq at all?
23:58:01 <mjrosenb> kmc: no, but i have used twelf; briefly
23:58:38 <kmc> i really enjoyed http://www.cis.upenn.edu/~bcpierce/sf/
23:58:47 <sw17ch> woo, it's working
23:59:55 <mjrosenb> kmc: evidently appel's son is now a sophmore/junior at cmu.
