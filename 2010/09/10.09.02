00:00:18 <ksf_> ...note that you have to fix the style parameter in some way to get sane inferred types, but that's not a real problem as I won't be using the default methods, anyway, but stuff specialised for my domain.
00:00:40 <ski> (.. but i only indent two spaces .. and i try to keep each line no more than 80 characters)
00:08:32 <ksf_> hmmm why didn't oleg write a theorem prover on the type level, yet?
00:17:35 <dmead> hey channel
00:17:38 <dmead> whaaaaats happening
00:17:49 <Veinor> not much
00:17:53 <dmead> excellent
00:22:54 <enigmus> Any idea why both my SPARKS are pruned? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29666#a29666
00:23:52 <enigmus> If I replace f' by fac 0 = 1
00:23:52 <enigmus> fac n = n * fac (n-1)
00:24:05 <enigmus> then one spark is converted.
00:25:18 <ksf_> enigmus, because you don't have enough cpus, or the bandwidth, to process that many sparks parallelly.
00:27:06 <enigmus> I have 4 core, so I should (and I run with -N2, -N4 is identical). And why would a dummer function fac "work"?
00:27:20 <enigmus> The whole thing takes 3-4s
00:27:47 <kmc>   SPARKS: 2 (2 converted, 0 pruned)
00:27:48 <kmc> for me
00:28:18 <kmc> GHC 6.12.1, same RTS options you gave
00:28:27 <kmc> did you try ThreadScope?
00:28:59 <ksf_> ...your cores could also be too fast.
00:29:32 <enigmus> I'm using GHC HEAD (Fedora GHC fails to link with -threaded), and no I didn't try ThreadScope, that's a very good point.
00:30:18 <kmc> if you can build 6.12.1, i wonder if you get the result i do
00:30:34 <enigmus> Ok, I will try other versions of GHC tomorrow, plus ThreadScope, and see what comes out of that.
00:30:45 <nlogax> i'm using Mueval in a program, the first "serious" one i write in Haskell. if i feed it an expression like `[1..]`, all is good, i can `take someOf output`. but if i do something like `length [1..]` it never finishes. 
00:30:47 <enigmus> Thanks for the pointers, and good night.
00:31:14 <nlogax> Mueval has a time limit and resource limiting already, but it's not happening in Mueval. do i have to build my own time limit?
00:31:33 <ksf_> iirc setting up time limits is a bit dodgy
00:31:58 <nlogax> i'm using Language.Haskell.Interpreter.runInterpreter to run it, so that's where it blows up i think
00:32:13 <ksf_> ...and probably needs -threaded.
00:32:26 <kmc> nlogax, that's part of hint, not mueval, i thought
00:32:32 <kmc> but maybe mueval is supposed to impose limits on hint?
00:32:41 <ksf_> yep, it is.
00:32:59 <kmc> compiling with -threaded is a good suggestion
00:33:55 <ksf_> also, don't call hint directly, that just won't work.
00:34:17 <ksf_> pass your expression in the Options record you give to Mueval.Interpreter.Interpreter
00:34:41 <nlogax> yes, that's what i'm doing. I.runInterpreter . interpreter $ muOptions { expression = expr }
00:35:14 <nlogax> but i'll try with -threaded, not sure if i did that already
00:35:20 <nlogax> thanks
00:36:05 <ksf_> did you try setning rLimits to true? 
00:36:11 <ksf_> timeLimit might require that
00:37:26 <nlogax> i didn't, i think rlimits is broken on OS X, or at least i read that somewhere
00:37:35 <nlogax> no harm in trying though
00:37:46 * nlogax 's computer blows up
00:40:16 <Maxdamantus> Hmm.. why exactly is ++ considered "bad" when there's an almost-as-simple alternative use of :?
00:40:38 <ksf_> ++ can lead to exponential blowup
00:41:01 <kmc> quadratic i thought
00:41:07 <kmc> what do you mean by "alternative"?
00:41:11 <ksf_> as in "foo" ++ "bar" ++ "baz" will traverse first foo to append bar, then foobar to append baz
00:41:15 <ksf_> kmc, yes.
00:41:22 <Maxdamantus> Hm, will it?
00:41:24 <kmc> (:) has a different type than (++) and if you use it to implement (++) then, well, you've implemented (++)
00:41:38 <Veinor> ksf_: why isn't ++ right-associative?
00:41:42 <Maxdamantus> Why can't it be optimised as in: "foo" with "bar" ++ "baz" appended
00:41:46 <Veinor> or... yeah
00:41:54 <Maxdamantus> s/optimised/thought of/
00:42:07 <ksf_> :info (++)
00:42:12 <ksf_> :i (++)
00:42:18 <Maxdamantus> @src (++)
00:42:19 <lambdabot> []     ++ ys = ys
00:42:19 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
00:42:19 <lambdabot> -- OR
00:42:19 <lambdabot> xs ++ ys = foldr (:) ys xs
00:42:26 <ksf_> infixr 5
00:42:44 <ksf_> anyway, you still get the blowup when stuff is bracketed wrong.
00:42:49 <Veinor> true
00:42:55 <ksf_> ...thus, ShowS and stuff.
00:43:05 <kmc> it's common to keep wanting to add stuff to the end of a list
00:43:13 <kmc> and every time you do that, you re-traverse the whole list
00:43:17 <ksf_> well, we've got a special string type for that.
00:43:28 <kmc> there's a similar problem with null-terminated C strings
00:43:52 <kmc> joel spolsky wrote about it as part of his series on "the people i try to hire are really dumb"
00:43:58 <Maxdamantus> But you don't need to traverse until you actually iterate through.
00:44:10 <Maxdamantus> right?
00:44:14 <ksf_> http://hackage.haskell.org/package/dlist-0.5
00:45:13 <ksf_> Maxdamantus, yes, due to laziness. laziness won't help reducing the runtime when the data dependencies are quadratic, though.
00:45:28 <Maxdamantus> Ah.
00:45:36 <kmc> Maxdamantus, when you ask for the first character of ((a ++ b) ++ c) you ask for the first character of (a ++ b) and thus ask for the first character of a
00:45:53 <kmc> so you can imagine that if there's a lot of left-associated (++), you have a lot of nested forcing like that
00:46:14 <Maxdamantus> Right.
00:46:19 <Veinor> darn immutability
00:46:22 <kmc> and i think that's the source of the quadratic blowup
00:46:31 <kmc> it's amortized over every element you ask for
00:46:35 <kmc> another problem with (++)
00:46:40 <ksf_> newtype DList a = DL { unDL :: [a] -> [a] }
00:46:42 <kmc> is that (xs ++ ys) will share memory with ys, but not with xs
00:47:00 <Veinor> yeah.
00:47:22 <kmc> so when you start forcing (xs ++ ys), the spine of xs gets copied
00:47:34 <kmc> (incrementally)
00:47:56 <kmc> now maybe it doesn't, if (xs ++ ys) fuses with its consumer
00:48:02 <kmc> then you've just pasted together two loops, and all is well
00:48:24 <kmc> anyway, if you want to concat stuff, a tree is a great structure
00:48:29 <kmc> build the tree, flatten it in one pass
00:48:39 <ksf_> did I already mention http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html ?
00:48:55 <kmc> concat with DList is building a tree whose internal nodes are (.)
00:49:21 <ksf_> Data.Sequence has O(min m n) concat.
00:49:51 <kmc> err, the log of that
00:49:56 <ksf_> yes.
00:50:19 <kmc> O(32) ;)
00:51:26 <nlogax> whoops, now i crash as soon as i try to eval anythign at all. will try with -threaded and without rLimits :)
00:52:00 <kmc> and Seq should share well on concat too, right?
00:52:26 * ksf_ wants a tshirt with "∀ n . log n < 64 -> O(log n) -> O(1)" on it.
00:52:47 <Veinor> haha
00:54:50 <kremsera> is there a way to overload the arithmetic sequence syntax [1,3..] - so that i dont get a list?
00:55:52 <Veinor> kremsera: no, you have to call fromList on it
00:56:07 <Veinor> (or whatever your container type uses as a constructor)
00:56:43 <kremsera> hmm
00:57:35 <ksf_> :t enumFromTo
00:57:36 <lambdabot> forall a. (Enum a) => a -> a -> [a]
00:57:48 <ksf_> maybe -XNoImplicitPrelude helps?
00:59:40 <ski> kremsera : what do you want to get, instead of a list ?
01:00:16 <kremsera> i want to create a "lenient" version of a list - a list of storableArrays, 
01:01:14 <ksf_> http://hackage.haskell.org/package/Data-Rope ?
01:01:50 <ksf_> http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Sequence.html ?
01:02:43 <ksf_> well, sequence doesn't use arrays but buckets of size one to four, but it's the same spirit.
01:03:04 <kmc> the GHC manual does not mention Enum overriding in the section on NoImplicitPrelude
01:03:11 <kmc> it seems hardwired to the members of GHC.Enum.Enum
01:03:26 <kremsera> sequences look quite strict
01:03:51 <ksf_> as in finite, yes.
01:04:01 <kmc> this is just a syntactic question, yes?
01:04:39 <ksf_> vanilla lazy bytestrings are just lists, too.
01:04:45 <ksf_> (lists of strict bytestrings)
01:04:57 <kremsera> ok
01:05:23 <ksf_> other areas of interest might include iteratees + stream fusion
01:06:23 <kremsera> lazy bytestrings look nice :)
01:06:23 <kremsera> thx
01:06:27 <ksf_> also, the vector package, but I don't think it comes with lazy ones.
01:07:17 <ksf_> (more generally, virtually every library dons ever wrote)
01:07:35 <ksf_> (or siblings in spirit of those)
02:16:39 <BorisL> @pl \ a b -> let m = f a in g m b
02:16:39 <lambdabot> g . fix . const . f
02:17:12 <BorisL> @pl \ a b -> g (f a) b
02:17:12 <lambdabot> g . f
02:22:22 <BorisL> @pl \ a b -> f1 $ f2 $ f3 (f a) b
02:22:22 <lambdabot> ((f1 . f2) .) . f3 . f
02:25:20 <BorisL> \rest w -> fmap (map simpleCompletion) $ fmap sort $ fun (f rest) w
02:25:28 <BorisL> @ pl \rest w -> fmap (map simpleCompletion) $ fmap sort $ fun (f rest) w
02:25:32 <BorisL> @pl \rest w -> fmap (map simpleCompletion) $ fmap sort $ fun (f rest) w
02:25:32 <lambdabot> (fmap (map simpleCompletion . sort) .) . fun . f
02:26:33 <BorisL> @pl \rest w -> fmap1 (map simpleCompletion) $ fmap2 sort $ fun (f rest) w
02:26:33 <lambdabot> ((fmap1 (map simpleCompletion) . fmap2 sort) .) . fun . f
02:36:17 <Maxdamantus> http://dpaste.com/237786/ <- can anyone explain what's going on here? O_o
02:37:17 <Veinor> Maxdamantus: post the source of encodeNum?
02:37:31 <Maxdamantus> Hm. Why does that matter?
02:37:42 <Veinor> I want to see if I can replicate it
02:37:42 <Maxdamantus> I'm passing it the same argument both uses.
02:38:01 <Maxdamantus> Okay, it's kind of messy though.
02:39:02 <Maxdamantus> http://codepad.org/RA5bKWoZ
02:40:23 <Veinor> hm
02:40:36 <Veinor> I get something entirely different for map (toEnum . (+33)) $ encodeNum 23472138231461237167843242874612873687324653874765345 :: [Char]
02:40:52 <Maxdamantus> o_O
02:40:58 <Maxdamantus> What did you get?
02:41:21 <Veinor> "\\|v0b;"
02:41:50 <Maxdamantus> But you got the same thing for encodeNum 23472138231461237167843242874612873687324653874765345 ?
02:42:13 <Veinor> yeah
02:42:15 <Veinor> that's really weird
02:42:20 <Maxdamantus> Indeed.
02:43:07 <Maxdamantus> 91 + 33 = 124
02:43:20 <Maxdamantus> so shouldn't have any issues with character encoding.
02:44:02 <Veinor> it's the toEnum that's messing it up though
02:44:15 <Veinor> because without it they produce the same result
02:44:17 <kmc> forces it to Int?
02:44:27 <kmc> :t toEnum
02:44:28 <lambdabot> forall a. (Enum a) => Int -> a
02:44:32 <Maxdamantus> Ah.
02:44:36 <kmc> > log 23472138231461237167843242874612873687324653874765345 / log 2
02:44:38 <lambdabot>   173.97121020657116
02:44:54 <Veinor> ah, that'd be it
02:45:14 <kmc> Maxdamantus, you should put type signatures on your top-level bindings
02:45:18 <kmc> what's the type of encodeNum?
02:45:45 <kmc> looks like:  encodeNum :: (Integral a) => a -> [a]
02:45:52 <Maxdamantus> Yeah, will be that.
02:46:21 <kmc> a confusing (and powerful) aspect of type inference is that static information about types flows "both directions" with respect to the dynamic flow of data
02:46:41 <Veinor> this is a sign I need sleep
02:46:43 <Veinor> g'night!
02:46:51 <kmc> the fact that later you pass a value to toEnum can fix its type to Int at an earlier part of the computation
02:46:55 <kmc> 'night Veinor
02:50:44 <Maxdamantus> The type signature wouldn't actually change the *results* right, just whether or not I can do something?
02:50:49 <ManateeLazyCat> When time GC can't release memory correctly? I'm investigate memory leak of pixbuf (gtk2hs).
02:50:53 <Maxdamantus> I'd need to use uhh.. fromIntegral or something
02:52:06 <Maxdamantus> Yeah, that works.
02:52:12 <Maxdamantus> map (toEnum . (+33) . fromIntegral) $ encodeNum 23472138231461237167843242874612873687324653874765345 :: String
02:53:36 <ManateeLazyCat> Maxdamantus: Enum -> Int : (fromIntegral . fromEnum), Int -> Enum : (toEnum . fromIntegral)
02:54:23 <Maxdamantus> O_o I don't know what that means
02:56:22 <BorisL> sorry for sending garbage to channel. I opened it to use lambdabot in private, but used the wrong window
02:58:12 <kmc> Maxdamantus, if you write a more specific type than the inferred type, it can change results
02:58:13 * hackagebot wai-extra 0.2.2.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.2.2 (MichaelSnoyman)
02:59:30 <Maxdamantus> but.. toEnum takes an Int?
02:59:36 <kmc> :t toEnum
02:59:37 <lambdabot> forall a. (Enum a) => Int -> a
02:59:39 <Maxdamantus> or are there multiple instances of it?
03:00:08 <kmc> there's one definition of toEnum for each member of the Enum type class, but they all take an Int argument
03:00:11 <Maxdamantus> :t div
03:00:12 <lambdabot> forall a. (Integral a) => a -> a -> a
03:00:27 <kmc> (in Haskell you can overload by only the return type, which is kind of unusual)
03:00:47 <Maxdamantus> I think that the only valid usage of my encodeNum would be (a -> [a])
03:01:15 <cch> text-icu can be used to convert encoding within IO, is there other "pure" method to do so?
03:02:02 <Maxdamantus> So where it expects an [Int] it will have to be (Int -> [Int])
03:02:39 <kmc> (in fact you can have overloaded values that aren't functions, even ones where the whole type is the type class parameter)
03:02:50 <Maxdamantus> so afaics type stuff would only restrict how I can use it, and not its behaviour, given it works with or without the type stuff
03:03:39 <kmc> the point of putting in the signature is a) machine-checkable documentation b) better error messages
03:03:45 <Maxdamantus> Mmm yeah.
03:03:56 <kmc> less commonly c) catching more errors
03:04:00 <Maxdamantus> So far I've tried to avoid putting in type signatures.
03:04:11 <kmc> occasionally a program will type-check but have the wrong type
03:04:31 <kmc> a notable example is that "main" can be any «IO a», does not have to be «IO ()»
03:04:43 <kmc> so you can make an error which results in «main :: IO (IO ())» or some such
03:05:52 <kmc> another reason for sigs is that you might want less polymorphism in order to get more speed
03:06:06 <Maxdamantus> Hm.
03:06:17 <kmc> but probably not worth bothering until you profile your program
03:06:19 <Maxdamantus> Speed compiling?
03:06:20 <kmc> GHC will specialize things anyway
03:06:25 <kmc> speed of execution, i meant
03:06:26 * ksf_ doesn't want that. he wants whole-program optimisation.
03:06:36 <kmc> JHC for you ksf_ :)
03:06:38 <Maxdamantus> That seems odd.
03:06:56 <fasta> kmc, I think he also wants it to be done compiling before the heath death of the universe.
03:07:13 <kmc> yeah, i suppose signatures can speed up type inference
03:07:30 <Maxdamantus> I'd think that the compiled version will do something like duplicate a function for all differently typed uses.
03:07:45 <kmc> Maxdamantus, and every function which calls any typeclass function?
03:07:57 <Maxdamantus> Meh, dunno. Much to learn.
03:08:02 * Maxdamantus eats
03:08:03 <kmc> typical Haskell implementations use a "dictionary-passing" implementation
03:08:32 <fasta> This is a good argument against overloading: http://people.imendio.com/richard/screencasts/devhelp-assistant.ogg
03:08:53 <kmc> meaning that «class Eq a where { (==) :: a → a → Bool }» becomes «data EqDict a = EqDict (a → a → Bool)»
03:09:26 <kmc> and a class constraint «(Eq a) ⇒ a → b» becomes an extra argument «EqDict a → a → b»
03:09:48 <kmc> and then any use of (==) within that function has to call through the "dictionary" value passed in
03:10:19 <kmc> but if we know the type statically, we can constant-fold the dictionary, and inline accessing it
03:10:38 <kmc> and that potentially exposes much more optimization, for example strictness analysis and unboxing of numeric types
03:10:57 <ManateeLazyCat> cch: tex-icu can detect encoding now?
03:14:21 <kmc> Maxdamantus, in the best case, (==) on Ints will be a single machine operation.  in the worst case it will be a bunch of nested indirect jumps
03:18:12 <ksf_> ManateeLazyCat, you know, you could just grab its source and bind the missing functions.
03:18:43 <ManateeLazyCat> ksf_: I'm pretty busy now. :) 
03:19:11 <ManateeLazyCat> ksf_: I have send mail to author of text-icu about csdect module.
03:20:02 <ManateeLazyCat> ksf_: I got memory leak when i call any "IO Pixbuf" function.....
03:20:27 <ManateeLazyCat> ksf_: 
03:20:29 <ManateeLazyCat> http://www.flickr.com/photos/48809572@N02/4947462492/lightbox/
03:21:40 <ManateeLazyCat> ksf_: I guess pixbuf's counter not decrease correctly or somewhere block GC make pixbuf's memory can't release.
03:22:50 <ksf_> finalisers not running properly, making haskell's gc fail to tell gtk to decrease the counter?
03:23:10 <ksf_> the first thing i'd do would be to add debug output to the finaliser.
03:23:56 <ManateeLazyCat> ksf_: I dunno, now i'm writing C version to test whether is bug of gtk+, if not, then i investigate gtk2hs.
03:25:31 * hackagebot stringsearch 0.3.1 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.1 (DanielFischer)
03:39:38 <ksf_> when will we get contexts for [data|type]families?
03:40:44 <copumpkin> never
03:46:14 * ksf_ wonders whether he should just switch to <insert dependetly typed language>
03:46:48 <ksf_> ...or whether uhc is better for type hackery than ghc.
03:47:23 <copumpkin> unless you go to coq, you won't get typeclasses anyway
03:47:52 <ksf_> I'm not particularily fond of classes.
03:48:20 <copumpkin> have you used a DT language before?
03:49:19 <ksf_> a bit.
03:49:21 <Starfire> Is it true that dependent types sacrifice a lot of handy type inference?
03:49:26 <copumpkin> yeah
03:49:28 <ksf_> they do.
03:49:43 <ksf_> ...which is the reason I didn't make the switch yet.
03:49:46 <copumpkin> I felt bad, cause Mathnerd314 seemed pretty disappointed when I pointed out the limitations yesterday :(
03:49:54 <copumpkin> but it's not really that bad
03:50:00 <copumpkin> I write top-level type signatures anyway
03:50:05 <copumpkin> and most of the time that's all you need
03:50:14 <copumpkin> in agda, anyway
03:50:37 <ksf_> and you don't get those page-long contexts when you don't need to use ugly tricks to get the type system to do what you want.
03:50:53 <copumpkin> Starfire: not only that, but they tend to not be turing-complete either :) which many people seem to care about, for some incomprehensible reason
03:50:56 <ksf_> agda, though, is out of the question because I won't switch to emacs.
03:51:03 <copumpkin> lol
03:51:10 * copumpkin loves good profound reasons for not using a language
03:51:24 * copumpkin doesn't like emacs and uses it only for agda, because it's so awesome
03:51:41 <Starfire> Turing-completeness is overrated!
03:52:00 <copumpkin> indeed!
03:52:05 <ksf_> yo mama is so turing-complete, she doesn't fit into the univers.
03:52:13 <copumpkin> :P
03:52:27 <Starfire> On the topic of emacs, I wish that there was a better Haskell completion system for vim.
03:52:47 <copumpkin> I find myself wanting features from agda-mode in haskell all the time
03:53:25 <Starfire> I sort of envy the completion available to users of Visual Studio or SLIME.
03:53:48 <copumpkin> phyx was working on an updated visual studio thing for haskell
03:53:48 <kw317> Hi
03:53:52 <copumpkin> that looked pretty awesome
03:54:03 <Starfire> I tried googling for it earlier this week, but couldn't find it.
03:54:19 <kw317> What would be the best way to parse a binary message read from a socket?
03:54:30 <copumpkin> Data.Binary probably
03:54:58 <Starfire> I think there was also a project called 'scion' that intended to provide centralized completion etc. features for Haskell.
03:55:04 <kw317> thanks, I'll have a look
03:55:06 <copumpkin> yeah, it's on github
03:55:11 <copumpkin> but not sure what it's used in
03:55:32 <Starfire> But the last time I tried, I couldn't get it working in either Linux or Windows.
03:55:47 <Starfire> And the project doesn't seem to be very active.
03:55:58 <copumpkin> the github says it was last updated in june
03:56:00 <copumpkin> which isn't too bad
03:56:27 <copumpkin> http://github.com/nominolo/scion
03:57:01 <Starfire> Apparently, it still doesn't work with GHC 6.12.3
03:57:08 <fasta> There is no need to look. There is nothing. 
03:57:41 <copumpkin> nothing?
03:57:52 <fasta> There are broken attempts by people, but nothing useful, beyond haskell-mode. 
03:58:16 <copumpkin> it would be nice if you could try to be less unpleasant, even if what you say is technically true
03:58:25 <copumpkin> it really isn't that hard
03:58:27 <fasta> Hayoo is fairly useful, though. 
03:58:28 <Starfire> I installed haskellmode-vim, but I don't really use it much because it's a bit flaky.
03:58:46 <fasta> copumpkin, I like the truth. 
03:58:46 <Starfire> Mostly, I just use ghci, Hoogle and Hayoo.
03:58:54 <Kaidelong> I didn't manage to get it doing much more than syntax highlighting on windows
03:58:58 <fasta> Starfire, probably everyone does that. 
03:59:02 <Kaidelong> and I figured that I didn't care enough to try fixing it
03:59:08 <fasta> Starfire, because the rest has no utility. 
03:59:28 <copumpkin> fasta: do you tell your friends they're ugly just because it's true?
03:59:45 <fasta> copumpkin, the topic doesn't come up often. 
03:59:53 <copumpkin> would you?
03:59:57 <fasta> copumpkin, and I have no interest in saying that. 
04:00:04 <Starfire> I wonder if some sort of smart completion would increase productivity.
04:00:15 <fasta> copumpkin, pointing out that tools are broken such that other people might actually develop some, has.
04:00:31 <copumpkin> all I'm saying is that this is a fairly friendly community in general, and disparaging the work of many of its members as "nothing" is not productive
04:00:32 <fasta> copumpkin, I never did. 
04:00:34 <Kaidelong> well Starfire part of what helps with that is using fully qualified names with a namespace delimiter
04:00:44 <Kaidelong> and that's not normal for haskell as far as I know
04:00:49 <Kaidelong> but it'd be nice, yes
04:01:05 <Starfire> In theory you could do stuff like type-sensitive completion.
04:01:18 <Starfire> But I guess it would be hard, because it would require incremental parsing.
04:01:25 <Kaidelong> but part of the appeal of autocompletion is helping people discover functionality
04:01:41 <Kaidelong> IE in F# if you type in List. you see everything you can do with a list
04:01:42 <fasta> copumpkin, I don't think it is many. I think when people announce a tool that doesn't work, they are wasting my time. 
04:01:51 <Starfire> I guess it's less of an issue with Haskell, because most of my time seems to go into thinking rather than typing.
04:01:58 <copumpkin> then bring it up with e.g., nominolo
04:02:02 <Kaidelong> it is a different style
04:02:07 <Kaidelong> although tool support is always nice
04:02:11 <fasta> copumpkin, I was a test-user for some time. 
04:02:21 <fasta> copumpkin, that is, I contributed more than most people.
04:02:48 <fasta> copumpkin, after 2 tests, it still didn't work. It simply means it is a waste of time. 
04:03:01 <Kaidelong> I do think that the lack of using qualified names as a consistent discipline in haskell may have been a mistake though
04:03:12 <fasta> copumpkin, I don't see what there is so hard to see about that.
04:03:12 <Kaidelong> not that that'd be a language change
04:03:28 <copumpkin> I'm not questioning that. Just saying that writing it off as "nothing" is unpleasant to people who have poured their time into it. Saying "not ready yet" or "could do with more contributors" has the same basic meaning while not being offensive
04:03:53 <fasta> copumpkin, either something is useful or not, imho. 
04:04:02 * copumpkin shrugs
04:04:17 <fasta> scion might be used as a starting point of something. 
04:04:27 <Starfire> Also, stuff like context-sensitive completion for patterns might be nice.
04:04:39 <fasta> But that's it, not something, it is a potential something. 
04:05:25 <fasta> I think the only way these tools get developed is within extremely large companies, since they understand efficiency. 
04:05:56 <Starfire> Type a part of a constructor, press something, editor inserts the parenthesized pattern with holes, like "(Constructor _ _ _)"
04:06:00 <Kaidelong> Starfire: how'd you go about it? Automatically putting in variables in the pattern if you push tab or something?
04:06:03 <Kaidelong> oh
04:06:11 <Kaidelong> well why not (Constructor x y z)
04:06:17 <Kaidelong> since that matches the exact same pattern
04:06:19 <Starfire> Well, you could to that also.
04:07:03 <Kaidelong> haskell would probably lend itself well to something more ambitious than autocompletion anyway
04:07:08 <Kaidelong> like perhaps a graphical editor
04:07:09 <Starfire> It's easy to imagine all sorts of magic functionality that would automatically insert exhaustive dummy cases for some type.
04:07:52 * hackagebot authenticate 0.6.3.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.3.1 (MichaelSnoyman)
04:08:34 <Starfire> Another thing I would really like is :t for where clauses and lets.
04:08:49 <Starfire> But I understand you can't access that information with the GHC API.
04:08:58 <Kaidelong> :t let f n = 1 + f n in f 0
04:08:59 <lambdabot> forall t. (Num t) => t
04:09:24 <Kaidelong> what do you mean?
04:09:51 <Starfire> Kaidelong: What I mean is that if you have a function with a (possibly large) where clause, you could do something to check the inferred type of something.
04:10:09 <Kaidelong> like cursorover types in the F# IDE?
04:10:10 <fasta> Kaidelong, everyone who tried that failed commercially, though. 
04:10:17 <Starfire> E.g. function x y z = blah blah blah where intermediate = durr
04:10:29 <Starfire> And I could do something to find out the inferred type of intermediate.
04:10:29 <Kaidelong> Is haskell a huge commercial success?
04:10:42 <Starfire> And yeah, F# does that, I gather.
04:11:34 <Starfire> If intermediate can be lifted to the top-level, it's usually easy enough to do just that, but that won't do if the definition uses local values.
04:12:20 <Kaidelong> hmm, I'd say that would be a worthwhile extension to GHCi
04:12:22 <ksf_> hmmm I could offer myself as an implementation of aunt tilly to the epigram devs.
04:12:29 <Starfire> Usually I just resort to typing in the type signatures myself until GHC no longer complains.
04:13:28 <Kaidelong> Is there any ML like language that still does full type inference? OCaml?
04:13:30 <ksf_> Kaidelong, we're trying to _avoid_ success, here.
04:13:31 <fasta> Kaidelong, in terms of the money it generates for certain companies, yes. 
04:13:33 <Starfire> I investigated this a while ago, but it seemed to me that you can't access local symbols using the GHC API, so it'd probably require a non-trivial extension.
04:14:01 <fasta> Kaidelong, in terms of COTS products, no. 
04:14:42 <Kaidelong> Starfire: I think it'd be worthwhile though to make a haskell IDE
04:14:51 <Starfire> Kaidelong: I agree.
04:14:52 <Kaidelong> so that's a good extension to put in
04:14:59 <Kaidelong> even if it is non-trivial
04:15:12 <Starfire> Perhaps the Leksah guys will do something about it. :)
04:15:28 <Kaidelong> I'm not holding my breath
04:15:33 <Kaidelong> but considering what they've started with
04:15:36 <Kaidelong> they've done a good job
04:16:18 <Kaidelong> if leksah doesn't get abandoned then they might be on to something
04:16:30 <ksf_> spj uses vim to edit, make to compile and trace and print to debug afaik.
04:16:58 <ksf_> ...so it might not be wise to wait for him to extend the ghc api.
04:17:03 <Starfire> He uses vim?! A fine man, indeed!
04:17:26 <Starfire> I still don't understand at all how :trace works.
04:17:34 <ksf_> leksah badly needs yi integration. and yi badly needs leksah integration.
04:17:55 <ksf_> ...both taken together would attract a lot of hackery.
04:18:03 <Starfire> Yi intends to support vim keybindings, no?
04:18:10 <fasta> Starfire, it already does. 
04:18:10 <ksf_> it already does.
04:18:10 <Kaidelong> it doesn't already?
04:18:18 <ksf_> the ex mode is a bad joke, though.
04:18:46 <Starfire> I guess I could live without ex mode, as long as the core stuff is well done.
04:19:13 <ksf_> well, try it.
04:19:23 <Starfire> Let's see.
04:19:33 <ksf_> it's definitely useable for basic editing
04:20:07 <Starfire> Let's see if 'cabal install yi' works.
04:20:13 <ksf_> and I think e.g. nano emulation is complete, if not more.
04:20:31 <ksf_> you might need to set some flags to specify the backend etc.
04:20:58 <ksf_> implementing a vi, though, should start with implementing ed.
04:20:58 <Starfire> I guess the nice thing about yi is that if the vim mode is inadequate to my liking, it's written in a language I might be comfortable with hacking myself. :)
04:21:03 <ksf_> ...not the other way round.
04:21:48 * ksf_ fondly recalls solaris' vi dropping to ed mode as it couldn't make sense of my terminal type.
04:22:02 <Starfire> I tried Qt Creator the other day, which has a vim mode, but it was pretty incomplete. I constantly found myself typing no-op commands and wondering why stuff didn't work like it should.
04:22:25 <jutaro> ksf_: It has been done some work to integrate yi in leksah, but it seems to be very complicated 
04:23:08 <jutaro> yi seems to have problems to run in gtk mode
04:23:09 <ksf_> the next thing to integrate should be xmonad, then.
04:23:30 <Starfire> Do you know if I have to do some black magic to install yi on Windows, in case I try to install it on my laptop?
04:23:30 <jutaro> why xmonad?
04:23:34 <ksf_> layouts.
04:24:11 <jutaro> I think xmonad is not really what leksah needs
04:24:52 <jutaro> we can quite easy add layouts in the current scheme
04:25:53 <jutaro> but what I would like to have is yi seperated in a core editor component (which leksah would integrate) and all other stuff, which we don't need.
04:26:50 <jutaro> So when I will start working on yi integration, their is a certain danger that I do a yi fork :(
04:27:04 <ksf_> it already is, more or less.
04:27:13 <ksf_> that is, the ui backend is completely separate.
04:28:10 <jutaro> ok, but editor component is not seperated from "we do all the other stuff you ever wanted". This is what we need
04:28:25 <ksf_> like buffers?
04:28:32 <jutaro> right
04:28:43 <Starfire> Does anyone here actually use yi frequently?
04:28:52 <ksf_> I guess it would make sense if leksah would provide them, yes.
04:28:52 <nlogax> i use it a little bit
04:29:51 <jutaro> At least we have to define what leksah does and what yi does. This is not clear currently, and this may be a source for endless problems if not solved clearly
04:31:08 <ksf_> well, yi-core imo would consist of YiM + a basic editor mode, minus buffers and ui.
04:31:41 <Starfire> Apparently, glib is not cabal-installable.
04:31:51 <jutaro> Yes
04:31:53 <Starfire> Or rather, the build fails.
04:31:55 <ksf_> yi-vi, yi-emacs etc would then provide editor modes, yi-files a buffer backend, and yi-<uilib> the frontend.
04:32:30 <ksf_> leksah could then provide its own backend + frontend, reusing the middleware.
04:33:12 <ksf_> another, not really orthogonal issue is that of clashing keybindings.
04:33:35 <jutaro> I agree with editor modes and even the backend, but 
04:33:44 <jutaro> not the frontend
04:34:20 <ksf_> ideally, leksah should use a key binding scheme as powerful as yi's, that is, just use an extended yi editor.
04:34:25 <jutaro> Yes, keybindings are done differently, leksah uses gtk mechanism + extension
04:34:44 <Mitar> is this a bug that NominalDiffTime cannot be "read" from what "show" outputs?
04:35:03 <Mitar> (NominalDiffTime "show" adds an "s" (for seconds) at the end)
04:35:12 <ksf_> maybe it'd be better to dissect leksah and look what can be integrated into yi.
04:35:49 <Mitar> > getPOSIXTime
04:35:50 <lambdabot>   Not in scope: `getPOSIXTime'
04:36:01 <Mitar> > Data.Time.Clock.POSIX.getPOSIXTime
04:36:02 <lambdabot>   Not in scope: `Data.Time.Clock.POSIX.getPOSIXTime'
04:37:01 <jutaro> ksf_: mmmhhh, try it out yourself
04:37:31 <ksf_> another worthwile task might be a haskell console emulator.
04:38:16 <ksf_> ...or at least the ui backend emulators can use, it probably doesn't make sense to speak those insane protocols.
04:38:32 <jutaro> Indeed, it seems not an easy hack to emulate a console, but would be very useful for leksah (and yi probably)
04:38:57 <ksf_> in general, a whole haskell ui framework.
04:39:18 <Starfire> Would it be easier to just link to some C console emulation library?
04:39:20 <jutaro> Eg. we have complaints that ansii escape sequences are not displayed corretly in the leksah log
04:39:25 <Starfire> Or does that defeat the point?
04:40:40 <jutaro> I don't know of any good C-library, I remember that I didn't even find a Console plugin for Eclipse
04:42:30 <Starfire> I wonder if something like gnome-terminal is embeddable. However, that might be more difficult than just writing a simple one with Haskell. :)
04:43:28 <ksf_> most terminal emulators are slow and memory-hungry.
04:43:54 <ksf_> ...I was quite surprised that konsole ranked at the top if not best, though.
04:44:03 <jutaro> gnome terminal only runs under Linux, and not on Windows and Mac
04:44:10 <Starfire> That, too.
04:44:10 <ksf_> while it's got a non-trivial footprint, it's actually fast.
04:44:37 <Starfire> Also, both gnome-terminal and konsole probably need a ton of dependencies.
04:44:55 <ksf_> but arguably an X terminal doesn't have any sensible excuse to be slower than the vga console.
04:45:29 <Maxdamantus> Hmm.. Does anyone know of any interesting self-terminating variable-length integer encoding systems, for outputting to printable ASCII?
04:45:37 <Maxdamantus> (Not a Haskell question)
04:45:40 <Starfire> "Software gets slower faster than computers get faster."
04:46:09 <ksf_> Maxdamantus, try bencoding.
04:46:13 <Jafet> Maxdamantus: any prefix-free code.
04:46:15 <ksf_> that'd be i12345e
04:46:37 <ksf_> a list being li123ei123ee
04:46:49 <koala_man> vga consoles are freakishly fast (4x faster than xterm), but fbcon in linux is incredibly slow (over 10x slower than xterm)
04:47:09 <koala_man> you can almost read stuff as it scrolls
04:47:14 <Maxdamantus> Hm. According to Wiki numbers are just in base 10.. boring.
04:47:19 <Maxdamantus> (bencode)
04:47:19 <bss03> Maxdamantus: Punycode?
04:47:35 <ksf_> I can't use any fb mode anyway, as I use the nvidia drivers.
04:48:31 <ksf_> Maxdamantus, if you want self-terminating binary, pack your bits into chunks of 7 and use the first bit to signify "another septet following" or "this is the last"
04:49:23 <ksf_> there's also a base83 or something encoding proposed tongue-in-cheek for ipv6 addresses.
04:49:31 <Maxdamantus> Hmm.. I made one where the integer is encoded to a 92-character character set (a few fewer than printable ASCII)
04:50:01 <Jafet> (What is the point of this? What's wrong with decimal?)
04:50:03 * hackagebot haddock 2.8.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.8.0 (DavidWaern)
04:50:14 <ksf_> Jafet, 10 < 256
04:50:48 <ksf_> Maxdamantus, what about a binary encoding and converting it to base64?
04:50:52 <Jafet> Well if you're going for efficiency, use a universal code such as elias gamma.
04:50:57 <ksf_> ...or even gzip/base64
04:51:37 <ksf_> does anyone have pointers to type hackery done with uhc?
04:51:52 <Maxdamantus> For each digit, you mod by 2 to check if it's a terminator, and if it's the first digit in a sequence mod4 < 2 means it's negative.. then if it's the first digit, divide by 4 to get the 1s
04:53:00 <Maxdamantus> if it's not the first, divide by 2 to get the 23*^n's where n is the amount of digits away from the second
04:53:11 <Maxdamantus> er
04:53:17 <Maxdamantus> 23*46^n's
04:54:29 * Maxdamantus was suprised to see that his logic seems to work
04:54:39 <Maxdamantus> Variable base system :\
04:55:31 <Jafet> Must be the spartans' numeral system
05:02:06 * hackagebot iproute 1.1.0 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.1.0 (KazuYamamoto)
05:04:50 <kmc> bencode is all right
05:06:06 <Maxdamantus> Hm yeah, it looks like it could be a decent alternative to where everyone uses JSON :\
05:06:35 <kmc> there's so many different ways to encode nested dictionaries and lists of numbers and strings
05:06:46 <kmc> i wonder if there's a many-to-many conversion library for that data model
05:07:14 <Starfire> Apparently, yi is cabal-installable.
05:07:17 * Maxdamantus dislikes it when people use languages designed for humans to transfer data
05:07:22 <Maxdamantus> SQL, JSON, etc
05:07:35 <kmc> there are some advantages
05:07:42 <Maxdamantus> XML/HTML could be easily optimised to something bencodish
05:07:55 <kmc> yeah
05:08:01 <kmc> there are plenty of alternate syntaxes for XML too
05:08:10 <kmc> it's basically a decent data model with a terrible default serialization
05:08:18 <Maxdamantus> Mmm..
05:08:26 <kmc> SQL is an egregious example, though.  it has ugly English-like syntax as a misguided attempt to appeal to non-technical users
05:08:29 <ksf_> and horrible schemata
05:08:47 <Botje> binary xml is pretty okay in my boko
05:08:49 <Botje> *book
05:08:54 <ksf_> ebml
05:08:56 <Maxdamantus> and it means that when you look at website source code you have to look at someone else's horrible indenting.
05:09:03 <kmc> as if the manager at burger king can actually be arsed to write "SELECT * FROM burgers ORDER BY profit DESC"
05:09:13 <ksf_> binary xml-like encodings are a dime a dozen.
05:09:13 <kmc> no of course not, he will pay some guy in india to do that for him
05:09:15 <Maxdamantus> Well, obviouly you could get a tool to fix that, but it's not default
05:10:02 <ksf_> writing [x]html by hand is just wrong.
05:10:31 <kmc> in the old days of the web, writing html by hand was what distinguished sophisticated users
05:10:32 <ksf_> it's just not a humanly readable, much less editable, format.
05:10:37 <Maxdamantus> Do you mean because of the syntax for it?
05:10:42 <ksf_> yep
05:10:47 <kmc> a good editor would help a lot
05:10:57 <kmc> for example remove all the closing-tag noise
05:11:02 <Maxdamantus> So you'd rather write something where you create the same data structures, but with a different syntax than HTML/XML?
05:11:06 <kmc> there's a fancy S-expression mode for emacs
05:11:09 <Maxdamantus> /SGML
05:11:14 <ksf_> even the most simple html combinator libraries for haskell do a better job at syntax.
05:11:18 <kmc> and XML is nearly the enterprise-friendly reinvention of sexprs
05:11:25 <ksf_> ...not to mention static semantic correctness.
05:11:37 <Maxdamantus> I think there was some sort of format that's meant to be easier to type than HTML
05:11:42 <Maxdamantus> can't remember what it's called
05:12:08 <ksf_> to we have an xhtml validator on the type level, by now?
05:12:36 <Maxdamantus> Cutting out many of those things will also mean much fewer forgot-to-escape securily holes.
05:13:00 <kmc> apparently there's "binary JSON" too
05:13:22 <kmc> there's a continuous churn of reinventing these things
05:13:29 <ksf_> is there binary markdown, yet?
05:13:34 <Maxdamantus> Basically all the XSS exploits are because people generate HTML/JSON directly
05:13:42 <Maxdamantus> and obviously SQL exploits ..
05:14:01 <ksf_> that's due to lacking sql edsls.
05:14:24 <ksf_> won't happen with a proper library because you can't get escaping wrong because the library just doesn't take strings.
05:15:10 <Maxdamantus> edsl refers to a generic wrapper library, or those things I've seen in PHP where you "bind" a value to a variable or something?
05:15:25 <ksf_> embedded domain specific language.
05:15:32 <Maxdamantus> Ah.
05:15:52 <Jafet> If you think about it, SQL, HTML or pretty much anything else with strings is like having eval, except with a different target language.
05:15:58 <Maxdamantus> Hmm.. Haskell's pretty good at that isn't it?
05:16:05 <ksf_> it is.
05:16:22 <kmc> if you squint hard enough, any library interface looks like an embedded domain-specific language
05:16:30 <ksf_> ...just have a look at all those parser combinators.
05:16:30 <medfly> @hoogle Fractional a => Integer -> a
05:16:32 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
05:16:32 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
05:16:32 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
05:16:34 <Maxdamantus> I think I saw with that web framework (with the integrated HTTP server iirc) the source code just had HTML/XML/something directly
05:16:47 <ksf_> that's a preprocessor.
05:16:58 <ksf_> ...which yields an abstract syntax tree.
05:16:59 <kmc> you can use Lisp to implement a very compact EDSL whose syntax is s-expressions, or you can use Java to implement a very verbose EDSL whose syntax is calls to nonsense classes
05:17:04 <ksf_> not plain strings.
05:17:12 <Maxdamantus> Ah.
05:17:17 <ksf_> it just _looks_ like php, but is actually sane.
05:17:21 <Starfire> Hmm, yi seems to support advanced motion commands, but not registers or macros.
05:17:45 <Starfire> I guess the next step is to see how I can hack it.
05:18:11 <ksf_> the yi edsl to describe editors is really nice.
05:18:28 <Starfire> VISUAL BLOCK works, but 'A' does not work in it.
05:18:57 <ksf_> block insert was broken last time I tried
05:18:59 <Starfire> And neither does 'I'.
05:19:20 <ksf_> ex mode can't even do ranges.
05:19:26 <Starfire> However, unlike vim itself, I expect yi to have a sane scripting language.
05:19:38 <ksf_> it indeed has.
05:19:40 <ksf_> it's called haskell.
05:21:16 <Starfire> Amusingly, ':help' produces '[""]'
05:24:43 <hpc> well that's no help
05:24:45 <hpc> (harr harr)
05:24:58 <copumpkin> mmmmm new haddock
05:25:07 <kmc> om nom nom
05:25:42 <fasta> leksah-0.8.0.6 depends on leksah-server-0.8.0.6 which failed to install.  
05:26:11 <jutaro> fasta: why does leksah-server fail?
05:26:14 <fasta> Leksah seemed to have improved, but they still cannot release one command that builds the thing reliably. 
05:26:30 <fasta> jutaro, ExitFailure 1, I can look. 
05:26:51 <jutaro> fasta: that would be good to know
05:27:37 <fasta> jutaro,  http://paste.debian.net/87297/
05:28:00 <fasta> jutaro, if you make a release, I suggest you hardcode the dependencies and test it in a clean environment. 
05:28:36 <fasta> jutaro, the screenshots look fairly nice, though. 
05:28:43 <jutaro> fasta: You use the latest version from hackage?
05:28:48 <fasta> jutaro, yes
05:28:55 <jutaro> strange
05:29:17 <jutaro> which ghc version? 
05:29:32 <fasta> jutaro, 6.12.1
05:31:30 <jutaro> fasta: a leksah release is not so easy. We have Linux, Mac, Windows and different compiler versions. I will look what happened in your case, but it may take some time.
05:31:53 <fasta> jutaro, if you cannot support multiple platforms, don't make a release. 
05:32:08 <fasta> jutaro, that is, either support Windows or Linux or Mac. 
05:32:10 <jutaro> fasta: great solution! 
05:32:16 <fasta> jutaro, it is what Debian does.
05:32:28 <Starfire> yi doesn't seem to support accented characters, which pretty much makes it unusable with my keyboard layout.
05:32:35 <fasta> jutaro, package X has a bug, nobody is interested in fixing it, so they drop support for package X. 
05:32:55 <jutaro> yes, but it has an advantage to be multi platform. E.g. on my work I use Leksah on windows and at home on Linux ...
05:33:12 <fasta> jutaro, and supporting multiple compiler versions can be a goal, but saying that the release works with compiler version X is better.
05:33:33 <fasta> jutaro, the site seems to suggest I can use any GHC compiler version which is not 6.12.2.
05:33:40 <fasta> jutaro, which obviously is not true. 
05:33:54 <fasta> E.g. I am sure 6.4 would not work. 
05:34:05 <jutaro> fasta: Sorry we are not perfect
05:34:51 <hamishmack> fasta: I suspect you have upgraded cabal
05:35:00 <fasta> hamishmack, true. 
05:35:09 <hamishmack> fasta: to a version newer than leksah 0.8.0.6
05:35:46 <hamishmack> fasta: unregister that new version and it should work
05:35:46 <copumpkin> it's recommended to put upper bounds on dependencies
05:35:57 <copumpkin> I see a lot of unbounded dependencies on leksah
05:36:09 <copumpkin> might be good to just stick minor bounds on them
05:36:24 <copumpkin> since haskell library APIs seem to change a lot :)
05:36:37 <jutaro> fasta: Which version of hackage do you have installed, it may be as well a problem with this.
05:38:10 <Mitar> :t readsPrec
05:38:11 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
05:38:30 <Mitar> i read that readsPrec returns a list, but why i see in source code lines like: (t, s) <- readsPrec ... ?
05:39:03 <copumpkin> must be in the list monad :)
05:39:24 <copumpkin> not that I've ever seen more than one result come out of it
05:39:27 <Starfire> In what case does 'reads' return a list with several elements?
05:39:51 <copumpkin> you can write your own instances of Read and in that case, might want to return multiple ones
05:39:52 <medfly> so... what Haskellers prefer over regular expressions is parsec?
05:40:00 <copumpkin> but I don't think any of the standard ones do
05:40:02 <Starfire> I.e. is there a reason why it returns a list instead of a Maybe?
05:40:10 <hamishmack> copumpkin: If memory serves Cabal-1.8.0.2 works with leksah 0.8.0.6 but Cabal-1.8.0.6 does not
05:40:51 <copumpkin> hamishmack: yeah, all I'm saying is that you should just specify that in the .cabal files, in general. And the recommended policy is to always specify an upper bound on all your dependencies, just to avoid issues like this (of libraries that get upgraded after your release)
05:41:03 <Mitar> hmm, where can i read more about this syntax in list monad?
05:41:25 <bss03> Starfire: Non-derminstic reads.
05:41:46 <Mitar> http://www.haskell.org/all_about_monads/html/listmonad.html
05:41:50 <bss03> Strafire: Or at least, cases where you introduce local non-determinism.
05:42:40 <bss03> Starfire: like in the regex "abb?ba"
05:42:45 <Jafet> medfly: parsec implements at least LL(k) grammars, so that isn't an enlightening comparison
05:42:45 <hamishmack> copumpkin: That makes it hard to support multiple versions of ghc
05:42:51 <Mitar> hm, how can i see that this is an instance of list monad?
05:43:10 <Jafet> Maybe, if you compared them to perl's irregular expressions...
05:43:41 <copumpkin> hamishmack: an upper bound will let you support all past versions, and there's no way you can predict whether you support future versions of any library, so it seems silly to try (and implicitly claim that you do by not putting upper bounds on dependencies)
05:43:43 <hpc> "the only language capable of parsing perl code is perl"?
05:44:03 <medfly> Jafet: i have no iodea what that means
05:44:22 <hamishmack> copumpkin: But we would then need to provide different upper bounds for each ghc version
05:44:22 <bss03> Jafet: Yeah, when perl introdeced the "match this regex recursively as an element" I think perl's regexes because LL(k).
05:44:24 <ksf_> there are no perl parsers. you can't parse perl syntax. you can only interpret it.
05:44:29 <copumpkin> hamishmack: why?
05:44:30 <Starfire> hpc: You can't parse perl without being able to execute perl.
05:44:32 <bss03> s/becaue/became/ -- Need slepp.
05:44:40 <Jafet> medfly: it means parsec can recognize a much larger class of languages than regular expressions
05:44:57 <osfameron> ksf_: um, the perl parser is a perl parser (and compiler)
05:44:58 <hamishmack> copumpkin: Because for ghc 6.12.3 we need the newer cabal
05:45:15 <medfly> okay...
05:45:17 <medfly> parsec ok
05:45:19 <medfly> thx
05:45:24 <Mitar> how can i see that something is in list monad?
05:45:24 <hamishmack> copumpkin: used by leksah needs to match that in ghc
05:45:30 <copumpkin> hamishmack: you seem to be talking about lower bounds?
05:45:37 <Botje> ksf_: there's a pure-perl module on cpan that parses Perl
05:45:41 <ksf_> osfameron, nope, that's a syntax transformation. bytecode isn't really parsed.
05:45:53 <Botje> and it doesn't rely on evaluation to parse
05:45:58 <ksf_> ...you need to be able to run perl to parse perl.
05:46:01 <Starfire> Does it parse the whole perl?
05:46:27 <Jafet> Insert steinback reference here
05:46:29 <Starfire> I thought it was actually mathematically proven that you can't parse perl statically.
05:46:34 <bss03> ksf_: What part of the perl syntax requires evaluation to be deterministic?
05:46:34 <Botje> http://search.cpan.org/~adamk/PPI-1.213/lib/PPI.pm
05:46:38 <hamishmack> copumpkin: We actually need a Cabal == ghc version of cabal
05:46:47 <copumpkin> why?
05:46:50 <osfameron> ksf_: it doesn't emit bytecode anyway, but trees.  But it still parses them.  The fact that it's not possible to do it *statically* doesn't mean it isn't done.
05:46:55 <bss03> ksf_: I'm pretty sure perl can be parsed without be interpreted...
05:46:59 <ksf_> hell if I know. I only know that the perl grammar is turing-complete.
05:47:01 <Starfire> http://www.perlmonks.org/?node_id=663393
05:47:09 <osfameron> Botje: PPI doesn't really parse Perl.  It parses "Perl documents" which is a subset of Perl
05:47:30 <medfly> looks like parsec might be overkill :-/
05:47:31 <Starfire> "It's well known that the Halting Problem cannot be solved. Kennedy's Lemma establishes that if we can parse Perl 5, we can solve the Halting Problem. Therefore we cannot parse Perl 5."
05:47:54 <Botje> myeah, fair enough
05:48:03 <copumpkin> hamishmack: all I'm saying is that by writing Cabal (≥1.6.0.1) in your dependencies, you're suggesting that you'll work with cabal version 17, which is clearly not the case. 1.6.0.8 doesn't work, so just put cabal >= 1.6.0.1 && <= (the latest version you've tested on)
05:48:42 <ksf_> the whole thing is a really fun fact. perlists take pride in the fact that perl can't be parsed, the rest of the programmer community redicules them for it.
05:48:45 <hamishmack> copumpkin: If you are using ghc 6.10.1 it probably does need that
05:49:10 * copumpkin is utterly confused
05:49:14 <hamishmack> copumpkin: To access you cabal files correctly
05:50:04 <copumpkin> http://www.haskell.org/haskellwiki/Package_versioning_policy#Dependencies_in_Cabal
05:50:11 <copumpkin> hamishmack: I fail to see how that is a problem at all
05:50:26 <copumpkin> hamishmack: would your users suffer if you wrote cabal >= 1.6.0.1 && <= 17 ?
05:50:49 <copumpkin> or even cabal >= 1.6.0.1 && < 1.6.0.8, since we've established that 1.6.0.8 doesn't actually work
05:50:58 <osfameron> ksf_: that's not entirely true.  I think many people would like Perl to be more parseable, and Perl 6 for example *does* have multiple parsers targeting it (yet still isn't statically parseable)
05:51:00 <bss03> Starfire/ksf_: Okay, part that requires evaluation is the interpretation of "/".  In some cases it has to be division, in others it has to be part of a match, and that is determined by the *value* of the previous syntax.
05:51:49 <Starfire> I guess that's the idea.
05:51:55 <hamishmack> copumpkin: It does work though on newer versions of ghc
05:52:08 <hamishmack> 6.12.3
05:52:19 <hamishmack> fasta has 6.12.1
05:52:38 <copumpkin> then just write a set of optional subdependencies between ghc and cabal, up to the version's you've tested
05:53:02 <copumpkin> ghc == 6.12.1 && cabal == 1.6.0.1  or ghc == 6.12.2 && cabal == ...
05:55:38 <copumpkin> hamishmack: anyway, my point is that the whole point of the packaging system is so end users don't have to deal with dependency issues like that. Putting an upper bound on dependencies, whether or not it will fix this particular issue, is the official word and may eventually become mandatory for hackage, and it just makes basic sense
05:55:56 <copumpkin> package APIs change a lot
05:56:12 <copumpkin> so it just seems silly to claim you work with all future versions of them
05:57:10 <Saizan> it doesn't work with 1.6.0.8 because of the api or simply because the ghc package depends on 1.6.0.1 on that version of ghc?
05:57:26 <Saizan> s/the api/api changes/
05:57:44 <copumpkin> I'm guessing the former, since it was a compilation error and not a cabal complaint
05:57:54 <fasta> I think the whole concept of versions is a mistake to begin with. Feature detection, while slower, is more robust. 
05:58:08 <fasta> But I discussed that before already. 
05:58:11 <copumpkin> fasta: I agree but the latter is a lot harder :/
06:00:53 <jutaro> copumpkin: I agree that we should specify upper bounds. Anyhow I've not been able to understand how Cabal picks versions, and it seems generally like a dark art to write a cabal file which doesn't produce: "version x is exluded because version x is used..."
06:02:03 <copumpkin> yeah, it can be tricky, and I can definitely see it being more so for something the size of leksah, which I've never had to deal with myself :)
06:02:43 <Saizan> jutaro: if i understand what you're referring to then that's not something you can solve from the .cabal file
06:03:18 <Saizan> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
06:03:19 <Saizan> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
06:03:27 <Saizan> something like that? ^^^
06:03:35 <jutaro> yes
06:03:39 <jutaro> exactly
06:03:56 <fasta> jutaro, what I expect from software that wants users on Linux is simply one command I can paste into a shell and then press enter and once it is done, the application is either installed completely with a message saying how I can start it or it starts automatically with a message saying how I can start it next time. 
06:04:36 <fasta> jutaro, and you can do that with cabal probably, but most people write shell scripts to automate that, I suppose. 
06:05:52 <fasta> jutaro, there is also no shame in not using cabal, for the simple reason that cabal is not perfect. 
06:05:52 <Saizan> jutaro: the cause for that is explained in http://www.haskell.org/cabal/FAQ.html#dependencies-conflict 
06:06:20 <jutaro> fasta: situation has much improved since gtk2hs is cabal installable. For the next version I plan to implement runtime checks, is the ghc version still the version leksah needs, the cabal version ...
06:06:51 <fasta> A combination of cabal and manual tweaking for your own application is probably the easiest you can do today. 
06:07:01 <fasta> jutaro, that sounds like a good plan.
06:07:38 <fasta> jutaro, if you really want to care about beginners, you could even automate installing the Haskell platform on Windows. 
06:07:42 <jutaro> fasta: and we have debian packages on the way
06:42:18 <monoidal> Difference between algorithms and functions: http://monoidal.blogspot.com/2010/09/algorithms-and-functions.html. I'm sure this is well-known, but I haven't seen put it explicitly. Comments welcome.
06:43:39 <ksf> functions aren't algorithms in the same sense that dreaming of girls doesn't make them pregnant.
06:44:39 <ksf> er, reorder that.
06:44:42 <monoidal> ksf: i don't understand this analogy :)
06:45:46 <ksf> well, I once heard of a guy who opened a file in notepad, wrote "do something cool with the screen" into it, renamed the file to .exe and then complained that his program didn't work.
06:46:20 <ksf> thing is: he gave a sufficiently high-level description of an algorithm so that it could be understood, but failed to write a function that implements it.
06:46:30 <tehgeekmeister> what library will let me do globbing while listing directories?  i just want a simple wildcard, nothing fancy.
06:47:01 <tehgeekmeister> err, listing contents of a directory
06:47:02 <tehgeekmeister> sorry
06:47:02 <ksf> in the same sense, girls that you only dream about but don't actually exist can't produce new humans.
06:47:21 <ksf> you can very well dream about them producing humans, but they still won't.
06:47:39 <monoidal> ksf: I wouldn't say he failed to write a function that implements it. Maybe he failed to write *an algorithm* that was implementation of the function.
06:47:58 <monoidal> assuming "do something cool" is well-defined
06:48:24 <ksf> of course it is. it's as well defined as "find the optimum path from x to y in bounded time".
06:49:13 <ksf> hmmm I think my terminology differs from the one the rest of the world uses, yet again.
06:49:41 <monoidal> "optimum path" is rather objective. "cool" is subjective.
06:54:37 * hackagebot hexpat 0.19.1 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.1 (StephenBlackheath)
06:55:03 <Saizan> function = set theoretical concept; computable function = you also have an algorithm to compute the output from the input; i'm not sure if "having an algorithm implemented in some readily runnable code" has a specific name
06:56:39 <ManateeLazyCat> What's your favorites offline RSS-reader?
06:56:42 <monoidal> I'm naming the last concept simply as "algorithm". Or "source code".
06:57:20 <zygoloid> Saizan: i'm not sure i agree with that. an algorithm comes with an implementation and has performance characteristics (time, space, etc). a computable function need not.
06:58:51 <zygoloid> euclid's method for finding a gcd is an algorithm for computing the value of the (computable) gcd function.
06:59:01 <Saizan> zygoloid: i guess in classical logic you could prove a function is computable without providing an algorithm in your proof?
06:59:35 <Saizan> i'm not saying that the computable function specifies an algorithm
06:59:45 <ManateeLazyCat> I want to do an investigate for Feed-Reader, then i can use gtk2hs build better one. :)
06:59:51 <Saizan> just that an algorithm has to exist for a function to be computable
07:00:30 <copumpkin> pics or it didn't happen is a constructivist attitude
07:01:15 <monoidal> there's a map from algorithms to functions. The image is computable functions.
07:02:41 <zygoloid> Saizan: yeah, i can certainly imagine it being possible to prove a function is computable without actually finding an algorithm for it explicitly.
07:03:32 <monoidal> For example, f(n) = 0 or 1, when P=NP and P/=NP, respectively
07:04:13 <Saizan> is that f computable?
07:04:15 <zygoloid> and f(n) = 2 if P=NP is independent? :)
07:04:24 <monoidal> Saizan: yes, constant functions are computable
07:05:21 <jmcarthur> is there an existing data type anywhere for lists not containing duplicates, like an ordered set?
07:05:46 <jmcarthur> @remember copumpkin pics or it didn't happen is a constructivist attitude
07:05:46 <lambdabot> I will never forget.
07:05:47 <ski> monoidal : that is defined on the domain `{n | P = NP \/ P =/= NP}'
07:06:08 <monoidal> ski: yes :)
07:06:35 <Saizan> ah, ok, f _ (Left _) = 0; f _ (Right _) = 1 
07:06:46 <Saizan> not really constant :)
07:07:04 <ski> it need not necessarily be defined on the naturals (or whatever the type of `n' there was supposed to be)
07:07:57 <jmcarthur> hmm... a bimap might work for me, now that i think about it
07:08:14 <ski> Saizan : well, it's constant iff `P = NP \/ P =/= NP' holds, no ?
07:08:25 <jmcarthur> between my element type and something like the naturals, maybe
07:09:21 <medfly> if I do map <some IO thing> on a list, is it not evaluated until I do something with it?
07:09:38 <quicksilver> medfly: probably you don't mean evaluated.
07:09:38 <copumpkin> yeah, you'd need to sequence the result
07:09:47 <medfly> what
07:09:49 <ski> medfly : nothing is evaluated until you do something with it
07:10:01 <Saizan> ski: in the sense that you won't be able to call it with both arguments and so you'll only see one result?
07:10:01 <Axman6> :t sequence . map print
07:10:01 <medfly> well that looks like "doing something with it" to me -.-;;
07:10:02 <lambdabot> forall a. (Show a) => [a] -> IO [()]
07:10:12 <quicksilver> whilst it's true - even about evaluation - I expect you're talking about execution
07:10:18 <medfly> execution, whatever
07:10:20 <quicksilver> the IO action actually being performed.
07:10:25 <quicksilver> > map print [1,2,3]
07:10:28 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>]
07:10:33 <medfly> so this is not being executed?
07:10:36 <quicksilver> that's fully evaluated
07:10:38 <ski> Saizan : yeah, in the sense that the type/set `A + 0' is isomorphic with `A'
07:10:41 <quicksilver> but not at all executed
07:10:44 <quicksilver> because LB doesn't do IO.
07:10:49 <fasta> zygoloid, it depends on what you count as being admittable in complexity proofs, no?  
07:10:55 <medfly> ok. thx
07:11:13 <quicksilver> > sequence $ map print [1,2,3]
07:11:14 <lambdabot>   <IO [()]>
07:11:16 <ski> medfly : possibly you want to use `mapM_'
07:11:17 <fasta> zygoloid, e.g. for the Busy Beaver we cannot bound it in any other way but using Busy Beaver. 
07:11:19 <quicksilver> ^^ that's not executed either :)
07:11:22 <ski> @src mapM_
07:11:22 <lambdabot> mapM_ f as = sequence_ (map f as)
07:11:24 <ski> @src mapM
07:11:24 <lambdabot> mapM f as = sequence (map f as)
07:11:26 <medfly> ski: what's the difference?
07:11:29 <quicksilver> but it is an IO action ready for execution.
07:11:31 <medfly> ski: I actually don't want them executed
07:11:36 <ski> medfly : between what ?
07:11:56 <medfly> ........ never mind, nothing good ever comes out of asking this chan for help
07:12:11 <ski> maybe you should tell us what you want to do ?
07:12:22 <medfly> too lengthy
07:12:33 * ski wouldn't mind
07:12:57 <quicksilver> apologies if you find my pedantry annoying; to my mind, the difference between evaluation and execution was pretty central to any answer to your question, which is why I brought it up.
07:13:18 <medfly> I am re-writing wc (the command) in Haskell. I was thinking "Haskell has laziness, maybe I can just perform all the possible lookups on the entire list of files and execute if needed"
07:13:59 <fasta> medfly: Haskell is lazy, but the OS is not.
07:14:07 <medfly> so this is a bad idea.
07:14:26 <ski> i'm not sure i understand. `wc' would always count lines,words,characters, no ?
07:14:33 <ski> so why "if needed" ?
07:14:46 <medfly> no, you can specify to only do 1 thing
07:15:10 <ski> ok, that should be fine, i think
07:15:19 * medfly shrugs
07:15:22 <medfly> ok. thx
07:16:18 <ski> only when you decide to write out the number of lines/words/characters from a file read by lazy I/O, would that count actually be computed
07:16:22 <medfly> err, I dunno, nvm
07:16:25 <medfly> I give up
07:17:14 <koala_man> wouldn't that potentially require several passes?
07:17:29 <ski> .. however, it might be a problem on large files to compute lines/words/characters successively, instead of in one pass
07:17:54 <koala_man> and on stdin
07:17:55 * ski idly wonders what made medfly give up
07:19:13 <jmcarthur> medfly-: http://www.haskell.org/pipermail/haskell/2009-March/021064.html
07:19:27 <jmcarthur> ^^ that's a little controversial though, i think
07:23:30 <jmcarthur> in fact if you read the replies you see some good rebuttals
07:23:53 <jmcarthur> nonetheless, unsafeInterleaveIO can make things confusing
07:24:30 <quicksilver> and I'm not sure how helpful it is to call that stuff 'lazy'
07:24:36 <quicksilver> because it's quite different from the normal laziness
07:24:44 <quicksilver> interleaving IO execution with normal evaluation, that is.
07:25:23 <fasta> unsafeInterleaveIO simply buts a lazy layer around whatever it is called on a la lazy libraries in languages that are not lazy by default.
07:25:31 <jmcarthur> tying execution to evaluation where evaluation happens to be lazy
07:25:53 <fasta> There is nothing particularly hard about its semantics. 
07:26:11 <jmcarthur> "nothing good ever comes out of asking this chan for help"  <-- unfortunate that some people see complete explanations as a bad thing, IMO
07:26:32 <fasta> jmcarthur, there is no need to say that.
07:26:51 <fasta> Not that I care. 
07:27:07 <xiackok> hi everyone
07:27:13 <jmcarthur> i feel the need to say it because i don't want remarks like that to discourage good answers
07:27:13 <earthy> hi
07:27:51 <Philippa> to be fair it's worth bearing in mind that sometimes people want quick answers, and sometimes it hurts to find out there can't be one because you need to understand something properly
07:28:02 <earthy> medfly obviously had little hope he would be helped with his immediate issue rather than be enlightened... :)
07:28:31 <Philippa> I've got in serious pissing contests before explaining to n00bs elsewhere that their code was fundamentally screwed up and they needed to learn something. Generally I've been appreciated for having won said contests, but still
07:29:08 <earthy> what was it again? 'pull back the foreskin of ignorance and apply the wire brush of enlightenment'?
07:29:31 * copumpkin cringes
07:29:38 <luite> but often the quick answer would actually be much more helpful to a beginner than a complete / correct one... of course it's very problem-dependent
07:29:48 <earthy> luite: true, true.
07:29:49 <jmcarthur> sure, it's a philosophical difference that some people have from others. i can't really say it makes much sense for people to be using haskell if they aren't willing to understand their code on a deeper level, though
07:30:10 <Philippa> yeah, knowing when to say "and there's a pile of info here if you want it/have time now" is important
07:30:13 <earthy> jmcarthur: I don't agree. that would kinda shoot holes in the whole appeal of EDSL's.
07:30:17 <copumpkin> luite: gave the first answer and attempted to answer what I thought medfly was asking, despite the terms being unusual
07:30:52 <luite> copumpkin: oh I must admit that I haven't seen your particular answer
07:30:56 <jmcarthur> earthy: i don't understand why you say that
07:31:14 <jmcarthur> i never said you need to understand an implementation behind an abstraction, if that's what you mean
07:31:22 <Philippa> sometimes nothing good ever comes of asking the wrong questions, of course. Helping people refine the question is a good thing
07:31:56 <earthy> jmcarthur: then what do you mean with 'understanding on a deeper level'?
07:32:16 <earthy> (as functions themselves are an abstraction, implemented by the compiler...)
07:32:43 <earthy> (as is IO)
07:32:43 <jmcarthur> earthy: "deeper level" as distinct from "lower level"
07:33:43 <jmcarthur> earthy: i'm talking about a willingness to understand some of the theoretical foundations of computation
07:34:10 <fasta> jmcarthur, what are _the_ foundations according to you? 
07:34:14 <earthy> ah, understood. however, I still don't agree.
07:34:21 <jmcarthur> fasta: that is a trap
07:34:30 <fasta> jmcarthur, yes
07:34:46 <jmcarthur> it's not something i intended to imply having a good answer to
07:35:08 <tommd> Lambda Calculus!
07:35:20 <earthy> for exactly the same reason, as EDSL's tend to be written to allow people to specify computations whilst having less understanding of the foundations of the underlying theory...
07:36:03 <earthy> look at e.g. parsec. I'd wager not many people understand the underlying parsing theory...
07:36:05 <jmcarthur> earthy: perhaps it would be better for me to replace my use of the word "foundations" with "semantics"
07:36:29 <fasta> earthy, which theory would that be? 
07:36:30 <earthy> ah! now we're getting somewhere that I can agree to.
07:36:31 <jmcarthur> earthy: i'm complaining about people who want an answer to their immediate problem rather than an understanding of why it's an answer to their problem
07:36:36 <fasta> Abstraction is achieved when you do not have to understand what happens on another level. 
07:37:04 <jmcarthur> earthy: either way, i disagree that "foundations" are unnecessary to use a DSL
07:37:25 <jmcarthur> the way i see it, some foundational concepts are necessary just to understand the semantics
07:38:05 <earthy> people not having a willingness to understand the semantics of the formalism they're trying to use to express an answer to a problem they are having in are not necessarily best served in a venue like this.
07:38:22 <jmcarthur> okay we're definitely on the same page now
07:39:14 <Heffalump> you'd hope that semantics would generally be intuitive though, otherwise Haskell is less suitable as a general purpose language.
07:39:16 <fasta> jmcarthur, probably every regular is on the same page.
07:39:39 <earthy> hef: ofcourse, there's the issue that the semantics of haskell constructs is so far beyond what people are used to that it does take getting used to
07:40:15 <earthy> (although it's not quite as bad as with Schrödinger equations, of which I've heard 'you don't get to understand them, you get used to them'
07:40:18 <earthy> )
07:40:41 <fasta> earthy, I think Von Neumann said that about mathematics. 
07:41:08 <earthy> and in fact so far beyond what people tend to expect that the simple fact that there are specific semantics can be non-obvious
07:41:30 <earthy> (take e.g. the 'sequencing' of >>= that can stand in for ; as used in e.g. C)
07:43:21 <jmcarthur> i don't think it's important for semantics to be intuitive as long as they are at least simple
07:44:28 <Philippa> so you'll happily write all your code in the SK calculus?
07:44:54 <earthy> simple semantics does not preclude syntactic flexibility
07:45:10 <jmcarthur> Philippa: with the syntactic treatment of a mature language, sure why not?
07:45:36 <jmcarthur> Philippa: it would be unfair to make the comparison without also talking about writing your code in the lambda calculus
07:46:10 <ManateeLazyCat> If there have Haskell RSS/Atom-Reader, what features do you want to have?
07:46:27 <dons> ?bug
07:46:27 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:46:31 <earthy> manateelazycat: lib or app?
07:46:40 <ManateeLazyCat> earthy: GTK application
07:46:47 <Philippa> I'm not sure what such a syntactic treatment for SK would look like: it would have to introduce an awful lot more semantic constructs than the lambda calculus I tend to think of as being the heart of haskell
07:46:52 <earthy> (app I wouldn't care about, I have Vienna RSS)
07:47:07 <Philippa> (w/letrec and pattern-matching, and not much else extra)
07:47:18 <ManateeLazyCat> earthy: It's implement by Haskell. :)
07:47:20 <Philippa> (and pattern-matching only has to be 'simple' patterns)
07:48:13 <Philippa> but untyped lambda calculus + library is a lot more semantically sensible than SK + library
07:48:14 <earthy> manateelazycat: cool! go for it! look at vienna rss, newsfire, and google reader for inspiration! :)
07:48:38 <tehgeekmeister> can one not use withFile like this:
07:48:43 <Philippa> hell, it's unclear how you define a library for SK
07:48:58 <tehgeekmeister> inputContents <- withFile name ReadMode L.hGetContents
07:48:58 <tehgeekmeister> actionThatUsesContents inputContents
07:49:03 <tehgeekmeister> (inside a do, of course)
07:49:09 <Philippa> for lambda calculus, it's just a (part of a) context
07:49:12 <copumpkin> tehgeekmeister: no
07:49:20 <tehgeekmeister> copumpkin: that explains my code not working, then!
07:49:33 <ManateeLazyCat> earthy: Good to know, i'm search most popular RSS reader for inspiration. :)
07:51:05 <quicksilver> tehgeekmeister: it would work with strict bytestring
07:51:18 <quicksilver> tehgeekmeister: the bug with that is that lazy hGetContents uses interleaved IO
07:51:24 <quicksilver> which breaks if the file has already been closed.
07:51:48 <quicksilver> strict bytestring hGetContents is better behaved, although at the cost of reading the whole file into memory
07:51:51 <Philippa> (justification for letrec and case is more or less that if you're about to tell me to implement fix and an eliminator encoding for ADTs in plain lambda calculus, you're picking a specific model for something rather than the minimal bits of haskell necessary to sugar the rest)
07:51:54 <quicksilver> for moderate sized files that may be fine.
07:52:04 <Philippa> anyway, I need to head off shortly, but I hope I made my point?
07:52:54 <ManateeLazyCat> earthy: What's your favorites in those reader, vienna?
07:53:00 <revenantphx> can I get a copy of lambdabot somewhere?
07:53:09 <revenantphx> a relatively easy to install one preferably?
07:53:25 <revenantphx> > who are you?
07:53:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:53:29 <revenantphx> @who
07:53:30 <lambdabot> Maybe you meant: do echo ghc show thx what wn
07:53:30 <tehgeekmeister> quicksilver: my code dies a horrible death with strict bytestrings
07:53:43 <revenantphx> > do echo ghc show thx what wn
07:53:44 <lambdabot>   Not in scope: `echo'Not in scope: `ghc'Not in scope: `thx'Not in scope: `wh...
07:53:48 <jmcarthur> Philippa: i'm not sure what would be required regarding syntax to make it viable, but that's kind of orthogonal to my point
07:53:50 <revenantphx> YOU LIED
07:53:55 <tehgeekmeister> i guess i'll just use openfile
07:54:45 <Philippa> jmcarthur: it's not if the syntax has to introduce significant new semantic concepts as well. Which is very much mine: the semantics of SK suck for programming purposes in a way that those of the lambda calculus - with or without letrec and case - don't
07:54:54 * ManateeLazyCat Hate interleavedIO that confuse haskeller....
07:54:54 <Philippa> SK doesn't know what an abstraction is in any sense whatsoever
07:54:54 <tehgeekmeister> quicksilver:  withFile name ReadMode L.hGetContents >>= action should work, right?
07:55:02 <quicksilver> tehgeekmeister: nope.
07:55:06 <tehgeekmeister> fuuuuuuu
07:55:06 <tehgeekmeister> okay
07:55:08 <quicksilver> that's exactly the same as you pasted before
07:55:12 <Philippa> anything you introduce to try to manage that involves introducing meta concepts around SK
07:55:16 <tehgeekmeister> oh, right
07:55:27 <tehgeekmeister> so withfile just doesn't work with lazy bytestrings?
07:55:28 <tehgeekmeister> good to know.
07:55:39 <quicksilver> (do a <- b; c a;) is the same as (b >>= c)
07:55:41 <jmcarthur> Philippa: couldn't an identifier just be syntactic, like macro expansion?
07:55:46 <jmcarthur> if that's what you are talking about
07:55:52 <Philippa> jmcarthur: that's a significant meta concept!
07:55:57 <quicksilver> tehgeekmeister: it's not lazy bytestrings at fault
07:56:03 <quicksilver> tehgeekmeister: it's hGetContents
07:56:06 <quicksilver> which is broken.
07:56:14 <jmcarthur> but it's not really semantics
07:56:14 <quicksilver> or "lazy IO" as some people like to pronounce the word broken.
07:56:18 <Philippa> haskell doesn't (TH aside) let you build your own sugar
07:56:20 <quicksilver> ;)
07:56:45 <tehgeekmeister> quicksilver: ah.  so it's broken for the foreseeable future, okay.  that works.
07:56:48 <ManateeLazyCat> quicksilver: Tell tehgeekmeister : don't use any functions that base on interleavedIO. :)
07:56:59 <Philippa> That depends: it's a major thing regarding the semantics people actually program with, even if it has little to do with the mathematical structure people call semantics
07:57:05 <tehgeekmeister> ManateeLazyCat: how do i know if they are!
07:57:10 <quicksilver> revenantphx: I think you can cabal install lambdabot
07:57:16 <jmcarthur> i'm not sure i agree with how major it is
07:57:17 <revenantphx> awesome
07:57:24 <ManateeLazyCat> tehgeekmeister: I like you before, until quicksilver tell me don't use it. :)
07:57:32 <revenantphx> cabal: There is no package named lambdabot.a
07:57:33 <Philippa> well, look at how long the lisp community's spent studying macros...
07:57:33 <revenantphx> awwww
07:58:07 <monochrom> lambdabot.a? what's that?
07:58:29 <Philippa> and personally I call it major for one very simple reason: you'll scream if you have to do without it and it does require an additional structure. What we're quibbling about is whether it's semantic: I contend that it is with regard to the semantics people actually think with
07:59:19 <tehgeekmeister> quicksilver: is it *necessary* to explicitly close files, or will they be closed automatically when garbage collected?
07:59:46 <revenantphx> oh forgot to update
07:59:48 <ManateeLazyCat> tehgeekmeister: You best close file explicitly. :)
07:59:49 <revenantphx> awesome installing it :D
07:59:50 <quicksilver> tehgeekmeister: they will be closed when GCed but the timeliness of that is not guaranteed.
08:00:17 <tehgeekmeister> quicksilver: so if i'm not using that file ever again... =P
08:00:25 <quicksilver> hmm. Do *all* handles get closed on GC, or only hidden inside getContents?
08:00:28 <earthy> tehgeekmeister: you're still bleeding file descriptors.
08:00:41 <earthy> quicksilver: only those that are in partially closed status
08:00:48 <tehgeekmeister> earthy: fiiiiiine.
08:00:48 <Philippa> if you want to state that it holds so long as you're allowed to use syntactic abstraction then sure - at least, until I can be bothered to find an esolang that's strongly resistant to it, anyway. To be fair that might be quite difficult given that they've reached that point with the Game of Life
08:01:14 <Philippa> but lambda calculus /is/ syntactic abstraction. So personally I think that's cheating :-)
08:01:25 * quicksilver nods
08:01:32 <earthy> quicksilver: otherwise you wouldn't be able to do I/O with deterministic guarantees at all...
08:02:12 <revenantphx> > let m = [ x : x <- [1,2,3,4,5]] in print m
08:02:13 <lambdabot>   <no location info>: parse error on input `<-'
08:02:35 <siracusa> > let m = [ x | x <- [1,2,3,4,5]] in print m
08:02:36 <lambdabot>   <IO ()>
08:03:02 <revenantphx> let m = [ x | x <- [1,2,3,4,5]] in map $ print m
08:03:17 <earthy> > let m = [ x | x <- [1,2,3,4,5]] in m
08:03:18 <lambdabot>   [1,2,3,4,5]
08:03:26 <revenantphx> > let m = [ x | x <- [1,2,3,4,5]] in map $ print m
08:03:27 <lambdabot>   Couldn't match expected type `a -> b'
08:03:27 <lambdabot>         against inferred type `GHC.IO...
08:03:49 <quicksilver> earthy: well the finaliser wouldn't matter if you hClosed specifcally
08:04:01 <quicksilver> earthy: so it would be a safety net you could ignore if you wanted to be deterministic.
08:04:24 <ski> (Philippa : how is lambda calculus *syntactic* abstraction (in the sense of macros in lisps, i assume you refer to) ?)
08:05:12 <earthy> quicksilver: not really. how would you know you're not going to be reading from the handle after the hClose? :)
08:05:40 <earthy> do a <- getContents; hClose stdin; print a
08:05:42 <earthy> e.g. :)
08:06:29 <Philippa> ski: take a lambda calculus, give it a syntactic representation in the context, force the type of your outermost expression and what do you get?
08:06:50 <Philippa> lambda calculus very specifically doesn't give a damn what it's actually operating on
08:06:58 <earthy> (I've been bitten by code quite like it... works like a charm if you have buffered I/O and small input.... breaks when input exceeds buffer size)
08:07:33 <quicksilver> earthy: the GC would know.
08:07:35 <adel777> Haskell can be a rascal! So hard to code!!!!!!!!!!!!!!!
08:07:47 <earthy> quicksilver: and the GC is nondeterministic...
08:07:49 <quicksilver> earthy: my point is that it would do no harm to close-on-GC all Handles.
08:07:52 <quicksilver> earthy: I know.
08:08:02 <quicksilver> I know all the reasons you shouldn't rely on it.
08:08:04 <ManateeLazyCat> adel777: That not true, haskell pretty easy to code.
08:08:08 <Philippa> it's just that the boundaries look a bit wobbly when you realise that sufficiently powerful syntactic abstraction does computation and thus has something that can meaningfully be called semantics
08:08:09 <quicksilver> I was asking would it do any harm to do it anyway?
08:08:23 <copumpkin> adel777: it can be hard to get used to if you aren't :)
08:08:24 <adel777> Well, not for newbs like meh :|
08:08:44 <adel777> yeah that's it... I do appreciate it's mathematical rigor though
08:09:11 <ski> Philippa : well, is what you mean that macros can be interpreted as a lambda calculus operating on syntactic objects as data ?
08:09:17 <ManateeLazyCat> adel777: Haskell hard to OOP guys, because they handle everything with OOP .... :)
08:09:45 <Philippa> ski: roughly speaking, yeah. Especially in the limit as you let yourself abstract over macros as well
08:09:51 <adel777> Yep, I'm used 2 Java so ...... it's like switching from bicycles to parasailing
08:10:15 <Philippa> yeah, it helps to forget Java entirely for now
08:10:19 <monochrom> (it's so easy to draw attention)
08:10:21 <ManateeLazyCat> adel777: Yeah, that's tru.e
08:10:38 <Philippa> you'll find the learning curve works a bit differently to Java's though - the amount of power per thing you get the hang of is bigger
08:10:45 <adel777> :) I'll be patient til I get it
08:10:52 <ManateeLazyCat> adel777: You just some time re-think everything with Haskell style. :)
08:11:03 <Philippa> ski: really I've gtg though, so if you want to talk more/tell me off, grab me later?
08:11:17 <adel777> Yeah I see what you guys mean, thanks a bunch
08:11:17 <ski> Philippa : sure, if it remember :)
08:11:23 <ski> s/it/i/
08:11:25 <ManateeLazyCat> adel777: Haskell make your life easier once you know she how to work. :)
08:11:40 <adel777> oooh sounds nice
08:12:00 <adel777> well, I'll focus on it
08:12:24 <adel777> because of 2 big reasons - to pass PL structures,
08:12:26 <ManateeLazyCat> adel777: And haskell have hot community -- #haskell. :)
08:12:37 <adel777> Yep so true
08:12:51 <adel777> I think Haskell is the best kept secret
08:13:05 <adel777> def'ly best community
08:13:25 <adel777> a lot of super-geeks
08:13:29 <ManateeLazyCat> adel777: Trust me, haskell make me like stupid when i first study it.
08:13:47 <adel777> lol, yeah I see what you mean'
08:13:48 <copumpkin> :t flip
08:13:49 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:14:02 <adel777> wow
08:14:19 <dafis> :t Prelude.flip
08:14:20 <ManateeLazyCat> :t foldr
08:14:20 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:14:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:14:24 <adel777> I bet aliens can communicate in Haskell
08:14:47 <Entroacceptor> adel777: have patience with yourself, that will start to make sense :)
08:15:10 <adel777> alright, I will 
08:15:17 <adel777> thanks a lot :)
08:15:46 <adel777> OK I'll start swimming in Haskell now.. goodbye , toodles!
08:16:02 <adel777> thanks again everyone
08:16:42 * ManateeLazyCat Start to write RSS/Atom reader.... :)
08:19:25 <dons> ManateeLazyCat: go!
08:19:30 <dons> i need a good one.
08:19:34 <dons> i use lots of RSS feeds.
08:20:44 <ManateeLazyCat> dons: Look http://www.flickr.com/photos/48809572@N02/
08:21:23 <ManateeLazyCat> dons: editor, file-manager, pdf-viewer, browser, image-viewer, irc-client, multimedia-client, process-manager.
08:21:25 <dons> wow
08:21:39 <copumpkin> :O
08:21:42 <dons> will you announce all these? 
08:21:43 <ManateeLazyCat> dons: Now, i'm writing Rss/Atom reader and terminal.
08:21:47 <ManateeLazyCat> dons: Yes.
08:22:00 <dons> you need your own website for this great project
08:22:21 <ManateeLazyCat> dons: And have many sub-modules need to finish, i can finish faster if some haskeller help me. :)
08:22:38 <dons> building a complete graphical desktop in Haskell? :)
08:22:45 <ManateeLazyCat> dons: OS. :)
08:22:46 <dons> yes, you have to announce the project and the plan
08:22:56 <ManateeLazyCat> dons: Desktop environment just first step.
08:23:01 <dons> and show people where the code is, how to help you. then you'll get lots of help.
08:23:06 <dons> github ? or code.haskell.org?
08:23:15 <dons> but you will need to write down your plan
08:23:16 <ManateeLazyCat> dons: patch-tag.com
08:23:21 <dons> oh very good
08:23:30 <ManateeLazyCat> dons: Because i have some patches need push to gtk2hs main repository.
08:23:39 <ManateeLazyCat> dons: Otherwise, it's hard to install now.
08:23:52 <luite> I'd be interested in the code, haven't written much haskell gui code yet, and I'd like to see some good examples
08:23:56 <ManateeLazyCat> dons: I will release first review version after i release gio-0.12.0 and gtk-0.12.0
08:24:22 <dons> yes, work with the gtk2hs team to get what you need in. then launch like snap-framework.org did
08:24:33 <dons> http://snapframework.com/ i mean
08:24:33 <Nibble> Lets say I have  a Player, and that he could possibly get hurth
08:24:40 <Nibble> how would I best resolve this in haskell?
08:24:42 <ManateeLazyCat> dons: https://patch-tag.com/r/AndyStewart
08:24:46 <dons> a nice website, and a clear vision for what the goal of the project is, and how to contribute.
08:24:47 <ManateeLazyCat> dons: All beginning with manatee-*
08:25:00 <dons> good!
08:25:21 <Starfire> Nibble: Subtract hitpoints?
08:25:37 <Nibble> Starfire: well, that wouldn't affect the players hitpoints
08:25:40 <ManateeLazyCat> dons: Now only challenge is hot-swapping with gtk2hs code then update those module in runtime.
08:25:43 <Nibble> or?
08:26:32 <ManateeLazyCat> dons: But i have write 'pdynload' package, only problem 'pdynload' can't reload package after user install new version in cabal database.
08:26:39 <sioraiocht> so what precisely is it tha tyou re writing ManateeLazyCat
08:26:50 <sioraiocht> Not a window manager but a...?
08:27:10 <ManateeLazyCat> siracusa: Aim is OS, but now looks like desktop environment....
08:27:52 <sioraiocht> ManateeLazyCat: aha! cool
08:29:07 <ManateeLazyCat> dons: IMO, so little developer work for gtk2hs.
08:29:09 <Starfire> Nibble: Rather: Return a new Player with the hitpoints subtracted.
08:29:57 <Nibble> Starfire: I see, well
08:30:12 <Nibble> The player would be passed around in the code a lot
08:30:25 <Starfire> Nibble: Usually, you would use a Monad to pass the Player around for you.
08:30:38 <Nibble> Starfire: I see
08:30:53 <Nibble> Starfire: could you link me a code example of this?
08:31:11 <ManateeLazyCat> We hope more and more people join gtk2hs team, and not just write back-end library. Don't afraid gtk2hs code, we can tell you every detail that how to binding gtk+ code.
08:32:12 <Starfire> Nibble: http://book.realworldhaskell.org/read/monads.html
08:32:37 <siracusa> ManateeLazyCat: What kind of work needs to be done for gtk2hs?
08:33:24 <ManateeLazyCat> siracusa: Test APIs, binding rest API in gtk+ 2.18 and gtk+2.20 (I have binding some APIs in 2.18 ~ 2.20, but not all).
08:33:26 <krey_> hello, my parser doesn't terminate on any input :(
08:33:27 <ManateeLazyCat> siracusa: Fix doc.
08:33:32 <krey_> could someone please help?
08:33:35 <krey_> http://github.com/krey/Parsers-and-Interpreters/blob/master/Counter.hs
08:33:45 <Nibble> Starfire: I fail to see how that would help me
08:33:53 <krey_> (it's a very simple language)
08:34:09 <ManateeLazyCat> siracusa: Now just Axel and me works on binding work, unfortunately, we haven't so much time....
08:34:15 <dons> ManateeLazyCat: when will you announce your project to the world?
08:34:34 <ManateeLazyCat> dons: After i relase gio-0.12.0 and gtk-0.12.0
08:35:13 <ManateeLazyCat> dons: Infact, any gtk2hs user can install manatee with gtk2hs darcs version, but not easy like "cabal install manatee". :)
08:36:34 <ManateeLazyCat> dons: I'm write many different modules to test framework, many details haven't finish, still long way to perfect....
08:36:46 <dafis> krey_: parseTerm = do { s <- parseTerm; ... } `mplus` ... can't work
08:36:50 <dons> you should get a project web page, for such a big project. manatee.org or something :) with lots of pictures
08:37:09 <ManateeLazyCat> dons: My English is too bad... :-(
08:37:22 <dons> you need help! 
08:37:23 <krey_> dafis: why? could you explain?
08:37:27 <ManateeLazyCat> dons: Yes.
08:37:50 <dons> well, when you announce, i can help with the writing, and how to help get more contributors.
08:37:55 <ManateeLazyCat> dons: I even haven't time bulid website.... too many work need to finish.
08:38:06 <ManateeLazyCat> dons: Cool, thanks! :)
08:38:10 <dafis> krey_: parseTerm is calling itself without any modification to the input, infinite loop
08:38:27 <monochrom> heh
08:38:55 <fasta> ManateeLazyCat, Linux still has a shitty website and it also manages fine. 
08:39:13 <krey_> dafis: good point :)
08:39:22 <ManateeLazyCat> fasta: Now just me develop it, i really haven't so much time.
08:39:25 <krey_> dafis: any ideas on resolving this?
08:39:39 <krey_> dafis: the parser worked fine when it had brackets
08:39:55 <ManateeLazyCat> fasta: Even haven't time build a shitty website. :-(
08:40:09 <monochrom> perhaps parseTerm = ... `mplus` do { s <- parseTerm; ... }
08:40:18 <dafis> krey_: parseAtom = fmap Val parseValue `mplus` fmap Var parseVariable `mplus` parens parseTerm
08:40:20 <fasta> ManateeLazyCat, it's fine developing by yourself. Adding people to a project only delays completion time unless there are easy specifications. 
08:41:49 <krey_> dafis: but the expressions *shouldn't* contain parens
08:41:54 <dafis> krey_: then parseTerm = do { a <- parseAtom; lit '+'; b <- parseTerm; return Plus a b } `mplus` parseAtom
08:41:59 <Starfire> Nibble: You can put your game world in a State monad, which then passes it around for you.
08:42:07 <dafis> krey_: then leave that out :)
08:42:13 <krey_> krey_: :D
08:42:29 <jonrafkind> im having problems with cabal: http://pastebin.com/JzVcR1Bx
08:42:52 <ManateeLazyCat> fasta: Yes, i have found many problem when i write sub-module, core and framework still not stable now.
08:42:54 <Nibble> Starfire: ok
08:43:09 <monochrom> there is a redundancy problem with do { a <- parseAtom; ... } `mplus` parseAtom
08:43:14 <dafis> jonrafkind: ~/.cabal/bin in your PATH and happy installed?
08:43:16 <ManateeLazyCat> fasta: I mean API not stable....
08:43:40 <jonrafkind> my PATH is right, I guesshappy is not there. shouldnt cabal just install happy for me?
08:44:10 <min> If I have nested records such as 'G a = {f :: a}', 'H a = {g :: G a, I}', with some values 'n :: H a' and 'm :: G a', is there any way to write a function like 'k x = n {g = m {f = x}}'. I.e., can I nest record updates, because this doesn't seem to be working?
08:44:25 <Starfire> Nibble: If you don't understand how the State monad works, I suggest reading Real World Haskell and/or http://learnyouahaskell.com/
08:44:29 <min> (err, put constructors before the records).
08:44:33 <dafis> monochrom: yeah, better do { a <- parseAtom; cont a }; cont a = do { lit '+'; ... } `mplus` return a
08:44:41 <ManateeLazyCat> G'night all, i need coding now... :)
08:45:02 <dafis> jonrafkind: happy is an executable, cabal automatically only installs libraries
08:45:32 <jonrafkind> somehow i dont see the point of having a dependancy manager if I still have to manually install things
08:45:38 <dafis> jonrafkind: so cabal install happy, then it should work
08:45:48 <jonrafkind> oh, i just used my package system (gentoo) to install happy
08:46:08 <dafis> jonrafkind: cabal grew beyond what it was originally intended to be
08:46:13 <jonrafkind> wait, so 'cabal install happy' will install happy?
08:46:19 <jonrafkind> then.. why cant it automatically do it?
08:46:40 <dafis> jonrafkind: yes, it will, but if you have it from Gentoo, it's not necessary anymore
08:47:07 <fasta> dafis, you first said it didn't. 
08:47:09 * hackagebot HTF 0.4.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.4.0.0 (StefanWehr)
08:47:10 <monochrom> this is why I refrained from answering
08:47:14 <dafis> jonrafkind: because cabal doesn't have a means to find out whether executables are installed
08:47:28 <jonrafkind> ok another one.. cabal install alex..
08:47:30 <fasta> dafis, uh, what? 
08:47:51 <fasta> dafis, you mean nobody bothered to add that feature?
08:48:07 <dafis> fasta: it wiill not install happy as a dependency of another package, if you explicitly say install happy, it will
08:48:10 <Nibble> Starfire: I have read most parts, but I have come to the conclusion that I need to write code to understand it fully.
08:48:29 <monochrom> it is not clear whether people's goal is complaining or getting things done
08:48:30 <krey_> dafis: thank you, it works now, trying to understand why :)
08:48:44 <dafis> krey_: welcome :)
08:49:26 <dafis> fasta: that feature may not be so easy to implement correctly
08:50:09 <fasta> dafis, if it is in the PATH it is installed, and otherwise it is not seems something that works in 99.9% of the cases.
08:50:13 <dafis> monochrom: complain so others get things done?
08:51:03 <enigmus> Can people build Control.Parallel programs with ghc 6.12.3?
08:51:10 <fasta> dafis, anyway, I think it is better to let the machine do a bit more work than to bother a human. 
08:51:27 <enigmus> I get a linking error both with fedora build and a custom build from tarball
08:51:33 <monochrom> sounds very productive. you know, 5 seconds of "cabal install happy" can be saved by 5 months of arguing until cabal-install is enhanced. sounds like very efficient to me.
08:51:43 <Saizan> enigmus: are you using --make?
08:52:46 <enigmus> Saizan: darn, I wasn't. 
08:52:53 <ski> min : `k x = n {g = m {f = x}}' should work .. but maybe you actually wanted `k x = n {g = (g n) {f = x}}' ?
08:53:36 <krey_> dafis: I applied the changes and noticed that the parsing is right recursive
08:53:39 <enigmus> Saizan: would you know why ghc HEAD can do without --make?
08:53:47 <krey_> dafis: what would I have to do to make it left?
08:54:02 <Saizan> enigmus: no
08:54:55 <fasta> dafis, so why doesn't that work? 
08:55:26 <dafis> krey_: dunno, would have to think about that
08:55:38 <Nibble> Starfire: so basically, I need to define a state monad that helps me pass around computations? Or am I understanding this wrong?
08:56:01 <monochrom> that helps you pass around state
08:56:06 <min> Thanks ski. Perhaps it was bad syntax; interesting that it's legal. I only need to update particular nested values, so I don't think (g n) is what I need, unless I misunderstand what it's doing.
08:56:46 <dafis> fasta: when cabal doesn't find an executable, it would have to find out whether it's built from Haskell and it's on Hackage before it could install it, also, what if it's installed but not in the PATH?
08:57:36 <ski> min : if you want to update the `f' field of the record in the `g' field of `n', then the latter is what you want
08:58:18 <ski> min : if you want to *replace* the `g' field of `n' with a new record, which is the record `m', except with the `f' field replaced by `x', then you want the former
08:58:24 <fasta> dafis, deciding whether it is built from Haskell takes about 1ms for a machine. Compiling the application again takes at most 1 minute for something like alex. A user figuring out "why it doesn't work" is much slower. 
08:58:38 <fasta> dafis, it's simply not taking into account any measure of efficiency. 
08:59:01 <Saizan> dafis, fasta: there is one ugly corner case where cabal will install it in the default path but that path is not in $PATH so it won't find it later
08:59:17 <ski> min : it is unfortunate that updating of nested record fields is so clunky with the current record notation .. one might use functional references / accessors / lenses to get a somewhat nicer notation for this
08:59:58 <fasta> Saizan, so it adds it to the $PATH. 
09:00:00 <dafis> Saizan: yes, I know, that would lead to infinite recursion if the code isn't very careful
09:00:15 <dafis> fasta: cabal can't change your PATH
09:00:22 <fasta> dafis, yes, it can. 
09:00:32 <monochrom> this "debate" is stupid
09:00:37 <Saizan> it could change PATH for that run, since it's an environment
09:00:41 <fasta> monochrom, yes, most discussions are.
09:01:01 <Saizan> i'm personally not debating wheter it's implementable
09:01:10 <dafis> fasta: it can, technically, but if it futzed around with such things, it shouldn't be installed
09:01:13 <Saizan> just how it should be done
09:01:31 <fasta> dafis, maybe we disagree on the goal of cabal install. 
09:01:37 <dafis> Saizan: yes, that's the question
09:01:49 <fasta> dafis, for most people it is that it should install the asked application in a state that it can be used.
09:02:00 <min> ski: In this case, the latter is what I needed (since 'update' means 'replace'). And you're certainly right that often a custom accessor would be the most appropriate solution, since nesting brackets looks awkward. But it's good to know how the distinction you drew works. Thanks :)
09:02:01 <fasta> dafis, it is for me at least. 
09:02:19 <fasta> dafis, if it doesn't do that for <insert excuse>, it is an excuse, a bug. 
09:02:25 <dafis> fasta: but adding ~/.cabal/bin to the PATH should be left to the user
09:02:38 <fasta> Now, you can argue that it has some other purpose, and that would be fine. 
09:03:17 <fasta> But if the goal is as I described, you have to accept the technical consequences.
09:03:54 <ski> min : yeah, the point of "*replace* the `g' field of `n' with a new record" was to emphasize that in this case, not only the `f' field of the `g' field of `n' is changed .. but (possibly) all the other fields of the record in the `g' field of `n'
09:04:42 <dafis> fasta: It was originally planned with lesser intentions, so these things haven't been taken into account in the original design. Adding them isn't trivial, it requires well founded design decisions. And there's not enough manpower to implement all desirable features pronto.
09:05:03 <fasta> dafis, there is enough manpower, just not enough money ;)
09:05:10 <dafis> fasta: You can however, always offer a patch.
09:05:28 <Saizan> or a clear design on the trac :)
09:05:46 <fasta> dafis, I wrote these features on top of cabal, which doesn't require arguing. 
09:05:52 <dafis> fasta: there are some three people working at most quarter time on cabal, that's not enough manpower.
09:06:30 <fasta> dafis, believe me; it is a money problem, like almost everything.  
09:06:58 <dafis> fasta: Yes, if you have the money to employ enough people to work on it full time ...
09:07:35 <fasta> dafis, so, you could have said that it was just that nobody bothered to do so at the beginning. 
09:08:44 <dafis> fasta: nobody thought it was required, because people thought it would only be used to build distro packages
09:09:20 <Nibble> :: StateTrans ImpState Int
09:09:29 <Nibble> What does the Imp in ImpState stand for
09:09:32 <Nibble> implied state?
09:10:03 <fasta> Nibble, imperative?
09:10:21 <fasta> (wild guess)
09:10:48 <monochrom> perhaps you could ask the author
09:11:09 <min> Ah, okay. Your explanation makes sense. I'll have to play around with this, in a few test cases, because I don't understand how more than the 'f field of g' could be changed. But I'm dense, and should figure it out myself, now that you've explained it.
09:11:35 <Nibble> monochrom: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm under "An example", but how would you define a get function when dealing with state monads?
09:12:00 <monochrom> type ImpState = (Int, Int)
09:12:16 <ski>   data ImpState = Lazy | Mischievous | Nasty
09:12:16 <monochrom> that's what ImpState stand for. (Int,Int).
09:12:18 <Nibble> oh
09:12:19 <Nibble> lol
09:12:22 <Nibble> :(
09:12:24 <rschnck> Can anyone recommend a text editor for Haskell, on linux, for people with zero programming experience?
09:12:33 <Nibble> rschnck: vim
09:12:34 <dafis> rschnck: kate
09:12:35 <Nibble> with haskell mode
09:12:54 <Nibble> Kdevelop would work too
09:12:55 <monochrom> gedit
09:12:59 <Nibble> Emacs
09:13:06 <rschnck> I've been using gedit.
09:13:24 <monochrom> gedit knows enough haskell to add colours
09:13:45 <Kaidelong> I use scintilla for what it's worth
09:13:59 <Kaidelong> via SciTE
09:14:27 <Kaidelong> no debugging features or anything though, just syntax highlighting
09:24:04 <Nibble> I need some help
09:24:40 <Nibble> http://pastebin.com/SqmkG5en
09:25:47 <ski> help with what ?
09:26:18 <Nibble> Other than that the code does not compile, what things would I need to be able to use getCoordinates on a Object
09:26:39 <kripton> hola
09:26:43 <BONUS> first of all, you say getCoordinates :: StateTrans but then do getCoordinates = 0
09:27:02 <ski> presumably s/0/undefined/
09:27:07 <BONUS> also line 8 is incomplete
09:27:16 <ski> (and line 23)
09:27:38 <monochrom> getCoordinates = ST (\x -> (x,x))
09:28:07 <BONUS> is there a point to having ST (State s a) at all?
09:28:18 <monochrom> setCoordinates new = ST (\_ -> (new,()))
09:28:33 <ski> BONUS : where do you see that ?
09:28:33 <monochrom> It is not ST (State s a)
09:28:37 <BONUS> oh wait
09:28:41 <BONUS> sorry got mixed up
09:28:49 <alecbenzer> is there a ghci command to check what typeclasses a type belongs to?
09:28:56 <BONUS> :info
09:29:01 <monochrom> And the point of ST (s -> (s,a)) instead of State is pedagogical
09:29:15 <ski> possibly, Nibble wants to use `StateTrans Object' .. or maybe not
09:29:20 <alecbenzer> BONUS, thx
09:29:42 <monochrom> I hate Object
09:30:06 <kripton> haskell some spanish  channel??
09:30:27 <ski> monochrom : you prefer "Subject" ?
09:30:42 <monochrom> I prefer "Type"
09:31:28 <ski> kripton : #haskell.es ?
09:31:53 <aristid> that exists?
09:32:08 <kripton> ok thanks
09:32:17 <ski> aristid : appears to, yes
09:32:28 <ski> (i have no idea whether it is populated, though)
09:32:41 <aristid> woah #haskell.de exists too
09:32:54 <aristid> seems like there's a TON of #haskell* channels
09:33:03 <ski> yeah
09:33:06 <min> Wow, I'm dense. Your distinction just set in, ski, now that I went back and actually implemented something using the 'g n' form. Thanks :)
09:33:24 <ski> min : np
09:37:10 <ski> min : the functional reference / &c. idea is more or less to implement functions like `modifyH_g :: (G a -> G b) -> (H a -> H b)' and `modifyG_f :: (a -> b) -> (G a -> G b)', and then compose those, to avoid stuff like `foo {x = (x foo) {y = (y (x foo)) {z = frob (z (y (x foo)))}}}', which gets tedious after awhile
09:38:02 <ski> (except that functional references / &c. are a *bit* more principled that just defining a bunch of separate modification functions)
09:43:01 <min> I'll have to do more research. My problem is updating large fields inside a (buried) state monad, and the functionality you'
09:43:10 <min> 're describign sounds very useful.
09:45:09 <ski> min : check out <http://hackage.haskell.org/package/fclabels> and <http://hackage.haskell.org/package/data-accessor>, at least
09:49:16 <krey_> ghc dies when linking (trying to compile executable) does anyone know why?
09:49:46 <krey_> collect2: ld returned 1 exit status
09:51:20 <Saizan> krey_: how much ram do you have?
09:51:34 <Saizan> krey_: it could be the OOM killer
09:52:09 <krey_> Saizan: 4gb :D
09:52:21 <krey_> Saizan: on 64bit
09:53:07 <Saizan> ah, ok :)
09:54:17 <jmcarthur> that still doesn't rule out memory
09:54:25 <jmcarthur> i've seen a module take > 4 GB to compile
09:54:49 <Saizan> wow
09:54:57 <jmcarthur> something in language-python, iirc
09:56:15 <jmcarthur> well, actually, i should clarify. i haven't actually *seen* it take that much, but it runs out of memory on my 4GB box
09:57:06 <jmcarthur> playing with GC settings helps a little, and using lower optimization settings is enough to make it build successfully
09:57:11 <jmcarthur> but i can't do it with -O2
09:58:10 <c_wraith> does turning off split objs help?
09:58:31 <krey_> any ideas? http://pastebin.com/Xa7MXq4m
09:59:29 <vanadium> ghc --make is usually a good plan
10:00:55 <jmcarthur> c_wraith: dunno. this is from a while ago
10:01:09 <jmcarthur> split objs isn't enabled by default is it?
10:01:31 <c_wraith> yes,  it is
10:02:11 <Saizan> krey_: ah, you just like --make there
10:02:16 <Saizan> *lack
10:02:21 <jmcarthur> my .cabal/config has "-- split-objs: False", which i thought meant that the default was False
10:02:23 <krey_> vanadium: wow that did it!
10:02:36 <krey_> Saizan: yes, compiled, very happy now
10:02:41 <krey_> but how do I run it?
10:03:06 <vanadium> There is an executable that has the same base name as your source file now, I think
10:03:15 <jmcarthur> *that the default was False even if i leave that line commented
10:03:25 <vanadium> So ./Counter I guess
10:03:58 <krey_> vanadium: wow, I'm an idiot :D
10:04:08 <krey_> vanadium: thanks a lot, it works now
10:04:15 <c_wraith> jmcarthur, hmm, that is convincing :)
10:04:15 <vanadium> No problem. Have fun :)
10:05:36 <Saizan> jmcarthur: those 4+GB were from ghc itself, not ld, right?
10:05:45 <jmcarthur> Saizan: it didn't even get to the linking step
10:05:51 <jmcarthur> it was one of the modules
10:06:02 <Saizan> so split-objs shouldn't matter
10:06:04 * int80_h sobs
10:06:12 <int80_h> my server seems to be down
10:06:22 * jmcarthur didn't do it
10:06:34 <int80_h> I have an interview tomorrow, this is baaad timing
10:06:35 <Saizan> anyway, the ones built with splitted objects are the packages shipped with ghc
10:10:17 <sm> g'day all
10:10:37 <sm> at http://haskell.org/haskellwiki/FFI_cook_book#Working_with_structs ,  return (MyStruct a, b, c) should be  return (MyStruct a b c), right ?
10:11:21 <carter> jmcarthur: silly question, but do you have swap space on? because I've had the problem of builds failing due to lack thereof
10:12:13 <carter> or was it just that this is 32bit ghc and its trying to get more than 4gb of mem?
10:13:42 <jmcarthur> carter: well, actually, whenever something starts hitting my swap i just kill it anyway because it's going to take forever and make me almost completely unproductive in the meantime. i only have swap at all because i don't trust the OOM killer to do what i want
10:14:05 <jmcarthur> either way, it took > 4 GB
10:14:18 <carter> just the ghc process?
10:14:43 <jmcarthur> well, plus my other processes, which were very small at the time. i wasn't even running X
10:15:07 <carter> so was it that you killed it at 4gb
10:15:16 <carter> or that it failed with an out of memory error?
10:15:21 <jmcarthur> when i killed it it was already taking more than 4 GB of virtual memory
10:15:28 <carter> ok
10:15:44 <carter> what were the build / compile flags you were using?
10:15:51 <jmcarthur> and when i set RTS flags to limit the memory it used it crashed with out of heap
10:15:59 <jmcarthur> it was whatever the cabal file set
10:16:09 <jmcarthur> and my default cabal settings
10:16:20 <carter> so this was for cabal install ________ 
10:16:23 <carter> style stuff/
10:16:23 <carter> ?
10:16:25 <jmcarthur> yeah
10:16:29 <jmcarthur> cabal install language-python
10:16:37 <jmcarthur> you can try it yourself, although it may have been fixed by now
10:16:43 <jmcarthur> i believe it was with ghc 6.12
10:16:49 <jmcarthur> 6.10 may have succeeded
10:16:55 <alecbenzer> is Map.fromList non-lazy? ie, it always evaluates the snd element of the pairs?
10:17:05 <jmcarthur> i was able to get 6.12 to work with lower optimization settings, like i said earlier
10:17:22 <carter> http://hackage.haskell.org/packages/archive/language-python/0.3.2/language-python.cabal mentions a memory usage bug in 6.12.x
10:17:44 <jmcarthur> ah, that wasn't there before
10:17:56 <dons> new one builds fine.
10:18:21 <carter> dons:  you mean the language-python module?
10:18:30 <dons> yeah. use the package.
10:18:36 <carter> gotcah
10:18:40 <carter> *gotcha
10:18:50 <carter> well, thats cool
10:20:02 <jmcarthur> nice it's only taking 2 GB now :P
10:21:01 <Mitar> how can i do something like this:
10:21:02 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29674#a29674
10:21:09 <Mitar> (it does not really work ;-( )
10:21:42 <jmcarthur> Mitar: define impulse as part of the type class
10:21:46 <hamishmack> copumpkin: You were completely correct. Leksah build was broke today due to lack of haddock < 2.8
10:21:52 <jmcarthur> er
10:22:01 <jmcarthur> Mitar: define *test* as part of the type class, i mean
10:22:52 <Mitar> but then i will have to define it per-instance?
10:22:58 <Mitar> not as one function
10:23:00 <jmcarthur> Mitar: yes
10:23:30 <Mitar> how can i then use it in one function?
10:23:34 <jmcarthur> Mitar: the only way i know to be able to do it in a single function like that is by using Typeable, but that's not necessarily a great idea
10:23:39 <notabel> yes, Mitar.  you're trying to use typeclasses to do subtyping, but they don't work that way.  typeclasses overload only the methods in the class
10:23:39 <jmcarthur> you just use it
10:23:57 <jmcarthur> i'll demonstrate with your paste
10:24:00 <jmcarthur> h/o
10:24:12 <Mitar> i now that they do not work like this, i am trying to do so that it would work
10:24:18 <Mitar> i would like to have a class type (or whatever)
10:24:35 <Mitar> which would limit what users can push into the Chan (this is not in the code i pasted)
10:24:44 <jmcarthur> Mitar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29674#a29675
10:25:05 <Mitar> and later on one function would read from Chan and process all this (possibilty combining different functionalities and such)
10:25:12 <jmcarthur> Mitar: a Chan can only accept values of a single type
10:25:26 <Mitar> yes, this is why i am asking how to go around that
10:25:27 <jmcarthur> Mitar: if you want to allow different "types" in the Chan you have to use an ADT, not a type class
10:25:44 <Mitar> but it would like that "types" are extendable
10:25:51 <Mitar> so that users can add their own types to it
10:25:58 <Mitar> by writing another type
10:25:58 <jmcarthur> ah
10:26:09 <jmcarthur> then you are looking for existential quantification
10:26:17 <jmcarthur> i'll show you
10:26:20 <jmcarthur> h/o again
10:26:21 <Mitar> and then i would like that compiler checks that in case ... of i go over all possibilities
10:26:39 <Mitar> (of all *known* possibilities at that time)
10:26:48 <Mitar> (so based on what user has in another module imported)
10:27:44 <Mitar> i would like to decopule defintion of data/type/instance with defintion of how to process them (especially in combination)
10:28:03 <Mitar> but i would still like to type check all this (so not use Dynamic or something)
10:28:15 <jmcarthur> Mitar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29674#a29676
10:29:22 <Cale> Should just make ImpulseType an instance of Impulse
10:29:26 <jmcarthur> Mitar: existential quantification basically allows you to put a value of *some arbitrary type* under the data constructor. since we also place the Impulse constraint on it, we know how we can use it later (namely, anything in the Impulse type class can be used with it)
10:29:35 <jmcarthur> Cale: ah, yeah
10:29:40 <jmcarthur> that would be better
10:29:45 <jmcarthur> i'll add one more paste
10:30:12 <Mitar> hmm, and can i the do something like case ... of over that?
10:30:24 <Mitar> and not call isntance-functions?
10:30:25 <Philippa> Mitar: the how to process will have to be another instance
10:30:39 <Philippa> you can't do case analysis on what's in an existential quantification
10:30:47 <jmcarthur> Mitar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29674#a29677
10:30:59 <Philippa> (technically you /can/ work with Data.Dynamic, but that's got its own issues)
10:31:13 <jmcarthur> Mitar: yeah you still can't case match on it. in order to do that you would have to know all the possible types in advance, which is precisely what you are trying to avoid
10:31:34 <Mitar> no
10:32:03 <Mitar> it is ok that i know all possible types in advance at this given module: so all instances the user imports - i would like that all this is checked
10:32:36 <Mitar> i would like just that later on (seperate from my set of predefined instances) somebody can make another instance for his own data type
10:32:47 <jmcarthur> exactly. so you don't know the type in advance
10:33:08 <Mitar> and then write another processing function which would check for all those types which are known at the moment of defininig that one function
10:33:48 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29678#a29678
10:33:56 <Cale> ^^
10:34:15 <chrisdone> hye
10:34:39 <Cale> You can of course just use typeclasses moar
10:34:56 <Cale> Typeclasses are the main way that we select operations based on type.
10:36:00 <Mitar> hmm
10:36:18 <Cale> I'm not certain what the Impulse class represents here exactly. It might be that you want to simplify things just by pulling the test method into it instead.
10:36:31 <jmcarthur> Mitar: the trick is you have to give up distinguishing types with case analysis. that's just not something you can do (ignoring Typeable which as i said earlier is not the right way to go about this)
10:36:54 <Cale> If you don't have to discriminate on type at runtime, it's easy though.
10:37:06 <Philippa> Mitar: you have another typeclass for the operation that you want separated from Impulse instances, with each type having its own instance of that, basically
10:37:15 <Mitar> Impulse class was made only to limit parameters which could be passed to test funciton so that I would show why I would not like Dynamic
10:37:16 <Cale> You could use Typeable if you do need to do that.
10:38:14 <Cale> Mitar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29678#a29680
10:38:19 <Cale> Why not just that?
10:39:18 <jmcarthur> Mitar: another way without type classes at all http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29674#a29681
10:39:22 <Cale> (There are ways in which this way is inflexible to begin with, but we can solve those issues if we come to them)
10:39:44 <copumpkin> hamishmack: glad you figured it out :)
10:41:11 <Mitar> hmm
10:41:20 <Mitar> i will have to think about all this ;-)
10:41:20 <Cale> If you're trying to solve the problem of having extensible data and extensible operations on that data at the same time, then using typeclasses in the way that I first suggested is probably a decent approach.
10:41:40 <Mitar> yes, both data and operations on it
10:41:47 <Mitar> currently i use records for data
10:41:57 <Mitar> and now i started thinking about how to operate on that
10:42:14 <Cale> http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes/
10:42:21 <jmcarthur> Mitar: to adapt my last example to a record, you would basically store the operations you can do on that record within the record itself :)
10:42:34 <Mitar> the reason why i initially wanted to have one function to process this data was so that i could easier combine data
10:42:48 <jmcarthur> Mitar: you can even go ahead and partially apply them. then you get something that starts to look a lot like a common model for OOP
10:42:54 <Mitar> jmcarthur: yes, like getters ;-)
10:43:10 <jmcarthur> but beyond just getters
10:43:11 <Mitar> yes, i figured that out
10:44:03 <Mitar> beyond?
10:44:05 <Mitar> like?
10:44:24 <jmcarthur> like your test function
10:44:35 <Mitar> yes, ok
10:44:38 <jmcarthur> in my last hpaste, test can be seen as a "method" on Impulse
10:44:46 <Mitar> yes, i agree
10:44:49 <jmcarthur> you can also add other methods too
10:45:22 <Mitar> but like what i wanted is to allow also for somebody to define: foo :: Impulse -> Impulse -> IO () and then see if first one is of type Foo and second is of type Bar, then do this and this
10:45:24 <jmcarthur> it can also be a lot like "prototype-oriented" programming
10:45:50 <jmcarthur> yeah that wouldn't be possible with this unless you encode the types as data, which is essentially dynamic typing
10:46:43 <Mitar> yes
10:47:01 <Mitar> i wanted, as i described, that type system would check if the user has tested all combinations
10:47:11 <Mitar> (of known instances)
10:47:35 <Mitar> like case (foo, bar) of (Foo, Bar) -> ...
10:48:09 <jmcarthur> but what about *unknown* instances?
10:48:19 <Mitar> unknown to the module?
10:48:23 <jmcarthur> the point of type classes is this extensibility
10:48:52 <Mitar> so the point is that if it is imported to the module, functions should take account of satifsying all combinations
10:49:04 <Mitar> if there is some instance defined somewhere else on the web, this does not matter ;-)
10:49:30 <jmcarthur> but the discipline of type classes requires you to account for all *possible* combinations, not just all *known* combinations
10:49:43 <jmcarthur> if you only care about known combinations then you would be using an ADT rather than a type class
10:50:09 <jmcarthur> i see what you are wanting, but it's more ad hoc than haskell is designed for
10:50:11 <Mitar> but ADT is not extendable?
10:50:28 <Mitar> of course, it is somewhere between dynamic and static ;-)
10:50:38 <jmcarthur> and ADT is "extendable" if you implement objects in the manner we discussed earlier, of course
10:50:45 <jmcarthur> as a record, i mean
10:51:05 <jmcarthur> but you still can't just sit down to pattern match its type
10:51:10 <monoidal> as an ugly solution, you can put predicates IsFoo and IsBar in the type class
10:51:23 <jmcarthur> monoidal: still wouldn't work. what about new instances?
10:51:23 <Mitar> yes, i was thining about such solution
10:51:29 <Mitar> or getType which would return string
10:51:36 <jmcarthur> Mitar: Typeable is basically getType
10:51:36 <Mitar> and then i would be able to compare those strings
10:51:49 <jmcarthur> > typeOf (undefined :: Int)
10:51:50 <lambdabot>   Int
10:52:13 <jmcarthur> Mitar: once you are using Typeable and existential quantification, you're use Dynamic ;)
10:52:19 <Cale> Mitar: The video I linked up there talks all about one way to solve the expression problem (this extensibility problem) using typeclasses.
10:52:41 <Cale> (I got distracted for a bit there)
10:52:49 <jmcarthur> there are a few approaches to solving the expression problem. i haven't seen any very satisfying ones yet though
10:52:53 <medfly> hi Cale
10:53:00 <Mitar> and ADT is "extendable" if you implement objects in the manner we discussed earlier, of course << hm, how can i define then additional data? like i define function getData in basic record, which returns then some type classes record?
10:53:13 <Cale> hello
10:53:18 <Mitar> expression problem?
10:53:40 <Mitar> (ehm, i need silverlight for that  video?)
10:54:02 <jmcarthur> Mitar: i don't understand "returns then some type classes record"
10:54:22 <jmcarthur> or what you mean by "additional data"
10:54:23 <Mitar> like getData :: (DataClass a) => a IO
10:54:38 <jmcarthur> why do you need a type class?
10:55:13 <Mitar> in your last suggestion you defined a record with "test" function/method
10:55:55 <Mitar> now, if I would like to for this record also to carry custom data (custom in a sense of not predefined by type), how could i do it?
10:56:28 <Mitar> probably by defining a "getter" in that main record, which would return this data and/or define some standard functions to access it
10:57:07 <jmcarthur> in what sense do you mean custom data? if we are defining objects in a coalgebraic sense, the data could be hidden in closures, and in fact *must* be if we want to object to expose a particular interface
10:57:14 <noteventime> Can't you store the data in a closure?
10:57:17 <jmcarthur> *if we want the object to
10:57:22 <noteventime> opps, sorry (too late :))
10:57:54 <jmcarthur> data Player = Player { position :: (Int, Int), moveLeft :: Player, moveRight :: Player, moveUp :: Player, moveDown :: Player, draw :: IO () }    -- in this, we expose position data, but everything else is just actions, and additional data can be stored in the actions' closures
10:58:26 <Mitar> or i could just use hashmap ;-)
10:58:40 <jmcarthur> yeah now you're getting even more dynamic
10:58:43 <Mitar> yes ;-)
10:59:23 <Mitar> Cale: sorry, that video is inaccessible to me
10:59:38 <noteventime> Mitar: The channel9 one?
10:59:44 <noteventime> I'm watching it without silverlight :o
10:59:44 <Mitar> oh, no, there is download option
11:00:03 <jmcarthur> unfortunately, you can't have really unrestricted dynamic typing while retaining static safety in haskell. there's always something you have to tradeoff ;)
11:00:11 <noteventime> I guess my browser just ignored the whole silverlight thing :p
11:00:26 <Cale> Yeah, the download options are a little sneaky
11:00:56 <Mitar> hmm
11:01:07 <Mitar> yes, but what about my idea of "known" instances at the time?
11:01:09 <jmcarthur> Mitar: actually, i don't think a hashmap would work. my example relies pretty crucially on laziness :)
11:01:27 <jmcarthur> well, i guess you could have lazy values and strict keys
11:01:29 <jmcarthur> so nevermind
11:01:44 <jmcarthur> i was foolishly thinking about hashset instead
11:02:04 <Mitar> but still, what would be the type of returning value from hashmap
11:02:08 <jmcarthur> Mitar: your idea as presented doesn't make much sense in haskell
11:02:32 <jmcarthur> Mitar: if you have a HashMap k a, then the keys are of type k and the values are of type a ;)
11:02:39 <Mitar> yes
11:02:49 <Mitar> and  by that I limit what users can extend
11:02:52 <jmcarthur> Mitar: and btw, we don't typically use hash tables in haskell
11:03:00 <jmcarthur> i don't understand
11:03:03 <Mitar> i know, i have not seen any ;-)
11:03:23 <Mitar> i limit them so that they can store in hashmap only values of type a
11:03:40 <Mitar> ok
11:03:54 <Mitar> what will i probably do it to use instances to define operators
11:04:16 <Mitar> and also how to combine different Impulses into one new Impulse
11:04:19 <Mitar> like a + b
11:05:09 <Mitar> or maybe some other operator so that people will not get grey hair because things will not be really addition
11:08:24 <Mitar> if I want to define a Chan which would accept all this and also other future types, than I have to go for ExistentialQuantification or record solution, don't i?
11:08:59 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29678#a29680 << this one for example will not work?
11:11:52 <shapr> Hm, cabal update && cabal install clash is heating up my laptop in a big way.
11:12:25 <lispy> shapr: what is clash?
11:12:42 <lispy> oh, n/m
11:13:00 <dankna> So.  I need to know the fd in a Handle, under GHC.  Has anyone done this before?
11:13:22 <dankna> The catch is that the functionality in System.Posix.IO to get at it also takes ownership of it
11:13:29 <Mitar> i was yesterday and i discovered that you do not want that ;-)
11:13:36 <dankna> yeah, but I think I really do
11:13:44 <Mitar> for which operation?
11:13:46 <dankna> my use-case is that I am running as a daemon and want to force-close all file descriptors
11:13:58 <dankna> but I want to exclude the certain descriptors that I have carefully opened myself
11:14:06 <jmcarthur> i've heard there are a lot of problems daemonizing in haskell
11:14:17 <dankna> no doubt.  I'll make a nice library of it if I have time.
11:14:21 <jmcarthur> but i think there was also an announcement a while back for a library for daemonizing
11:14:24 <dankna> oooh
11:14:25 <lispy> jmcarthur: have you tried angelicizing instead?
11:14:26 <Zao> Isn't there several already?
11:14:26 <dankna> that would be perfect
11:14:34 * dankna checks hackage
11:14:51 <dankna> ah, http://hackage.haskell.org/package/hdaemonize
11:15:26 <dankna> hmm
11:15:32 <dankna> "Briefly, daemonize sets the file creation mask to 0, forks twice, changed the working directory to /, closes stdin, stdout, and stderr, blocks sigHUP, and runs its argument. Strictly, it should close all open file descriptors, but this is not possible in a sensible way in Haskell."
11:16:02 <dankna> a) I've read that it's best to block a large set of signals than just SIGHUP, but if that were the only thing I would just submit a change to the author of that library
11:16:19 <dankna> b) I apparently have a different definition of sensible :) as I'm able to do the closing all FDs part just fine
11:16:33 <dankna> it's the not closing the ones I want to leave open that's causing me trouble
11:16:34 <dankna> hmm
11:16:45 <jmcarthur> you can't just open them *after* daemonizing?
11:17:06 <dankna> well, that may be what I do, but in that case I have no way of reporting an error in opening the logfile.
11:17:06 <jmcarthur> you could even close them and reopen them, maybe?
11:17:13 <jmcarthur> ah
11:17:23 <dankna> it may be the least evil though
11:17:29 <monochrom> heh, angelize
11:19:29 <dankna> so back to my original problem statement :) if I could compare a handle to an fd somehow, ... and I even poked in the source of the unix package and found how to do that, but it looks fragile and likely to break with new GHCs
11:19:52 <kmc> 666 users again
11:20:00 <dankna> heh, I see
11:20:06 <jmcarthur> dangit we need to kick somebody now
11:20:50 <monochrom> /ban *!*@*web*
11:20:55 <dankna> ha
11:22:00 <jmcarthur> Runar: is user 666 now
11:22:15 <aristid> dankna: why isn't closing all file descriptors possible in haskell?
11:23:05 * shapr hugs dons 
11:23:16 <shapr> dons++ -- for sheer awesomeness!
11:23:17 <roconnor> what? someone wrote a web framework in Agda?
11:23:18 <monochrom> kinky
11:23:23 <shapr> roconnor: Isn't that sexy?
11:23:49 <monochrom> someone should write a porn framework in agda, then it will be really sexy
11:23:50 <dankna> aristid: I believe that it is, actually, I was quoting the hdaemonize library's docs
11:24:14 <jmcarthur> yeah i still haven't checked out the agda web framework
11:24:16 <aristid> dankna: hmmmmmmm
11:24:19 <jmcarthur> i'm curious
11:24:51 <jmcarthur> roconnor: and it's by a guy who talked about agda at a *ruby* conference!
11:25:03 <monochrom> ok, next best thing: an agda framework in agda
11:25:21 <roconnor> jmcarthur: :O
11:25:43 <jmcarthur> roconnor: and they actually clapped at the end
11:25:59 <monochrom> clapped? for "good riddance"?
11:26:06 <Kaidelong> can agda implement agda?
11:26:16 <jmcarthur> followed by a question about whether they can turn safety features off
11:26:22 <Kaidelong> err
11:26:23 <monochrom> hahahaha
11:26:30 <jmcarthur> i'm not even joking
11:26:30 <Kaidelong> and prove that the implementation is correct
11:26:39 <kmc> Kaidelong, you'd have to prove that the type checker terminates...
11:26:43 <monochrom> right, but it's funny :)
11:26:52 <kmc> Kaidelong, there is a "Coq in Coq" project though
11:26:53 <monochrom> the whole event is funny :)
11:26:59 <jmcarthur> it's funnier because i'm *not* joking :)
11:27:06 <Kaidelong> so agda is total then?
11:27:13 <kmc> mostly?
11:27:13 <Kaidelong> and coq isn't?
11:27:17 <kmc> you can disable the totality checker i think
11:27:18 <jmcarthur> agda is optionally nonterminating
11:27:18 <monochrom> real life is funny like that. so sad. hahahaha
11:27:21 <jmcarthur> but it has a termination checker
11:27:21 <lispy> Kaidelong: you can turn off the termination checker in Agda
11:27:24 <kmc> i'm not sure how coq-in-coq gets around it
11:27:25 <Kaidelong> okay
11:27:32 <copumpkin> jmcarthur: yeah, the question at the end was hilarious
11:27:46 <Kaidelong> so you could implement agda in agda but you couldn't prove that the implementation will terminate?
11:27:50 <jmcarthur> copumpkin: i liked his face. "wtf have you even been paying attention?!"
11:27:56 <copumpkin> Kaidelong: sure you could
11:28:13 <copumpkin> I'm sure it would be a nightmare though :P
11:28:26 <kmc> if you don't prove termination of a proof term, it's not a sound proof ;P
11:28:32 <Kaidelong> does Goedel's Incompleteness Theorem get in the way somewhere here?
11:28:33 <monochrom> termination is so easy to prove...
11:28:41 <kmc> «let x = x in x» is a proof of anything
11:28:45 <copumpkin> it really is
11:29:08 <lispy> fix is absurd!
11:29:17 <roconnor> kmc: The Coq in Coq doesn't have a infinite heirarchy of universes
11:29:25 <roconnor> it only has infinity - 1 levels :P
11:29:29 <kmc> haha
11:29:36 <jmcarthur> copumpkin: i didn't even understand the question. the guy wanted to manipulate types as first class values but at the same time disable some of the coolest things about them
11:29:58 <roconnor> actually I think it might only have 1 universe level
11:30:03 <roconnor> I don't really know
11:31:51 <jmcarthur> he must have been a troll
11:31:59 <dankna> hmm, I think I solved my problem by accepting a slightly less general solution.
11:32:58 <copumpkin> jmcarthur: I mean, this is the ruby crowd... the vast majority of them still has nightmares about writing that c module for ruby and having actual compile-time type errors and to write out types
11:32:58 <enigmus> Any clue why slower? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29682#a29683
11:33:10 <copumpkin> jmcarthur: first thing that guy thinks when he hears type system is "omg shackles!!"
11:33:18 <copumpkin> "I MUST FREE MYSELF"
11:33:32 <copumpkin> "(BUT THIS OTHER STUFF SOUNDS KIND OF COOL, I WANT IT ANYWAY)"
11:34:16 <copumpkin> I'm not sure I'd have presented a lot of the material in the presentation the same way larrytheliquid did
11:34:21 <kmc> enigmus, +RTS -s ?
11:34:23 <jmcarthur> me either
11:34:31 <jmcarthur> i would have at the least done some comparison slides
11:34:40 * shapr boings cheerfully
11:34:48 <shapr> Yay Real World Haskell!
11:34:58 <jmcarthur> when do we get Real World Agda?
11:35:07 <copumpkin> I think he also rather conveniently skipped over the downsides of actually having to prove things :P the spec says that you can exclude all division by zero errors, but that just means you have to show that you aren't passing in a 0
11:35:11 <shapr> I gotta get dons and CosmicRay to autograph my copy of RWH.. I've only got bos to sign it so far.
11:35:22 <enigmus> kmc: yeah I looked at that. The spark gets converted, and GC is reasonnable. I can;t see anything explaining that. (There is a lot of allocation in this code, but the overall GC time is ~5%)
11:35:27 <copumpkin> but overall I think it was good for people to be exposed to it
11:35:37 <jmcarthur> copumpkin: yeah, that bugged me a lot. he didn't talking about the burden of proof at all
11:35:41 <wli> Let's get Real World everything. Real World Cayenne, Real World Mercury, etc. etc.
11:35:51 <jmcarthur> copumpkin: i was surprised he wasn't asked more questions about dynamic data
11:35:51 <copumpkin> real world malbolge
11:35:55 <copumpkin> yeah
11:36:16 <jmcarthur> the one question i can think of that was asked along those lines he kind of sidestepped
11:36:19 <bos> when you don't know anything about a field, how can you know what questions to ask?
11:36:27 <CosmicRay> shapr: bet yourself to kansas and it'll happen
11:36:28 <copumpkin> yeah, that's what I figured
11:36:34 <Martty> you start with "what is this field about"
11:36:36 <Martty> and move from there
11:36:44 <jmcarthur> bos: true, but at the least he could have been a little more up front
11:36:55 <bos> CosmicRay: did you see that tweet about our sales numbers? we rulez teh wavez!
11:37:05 <CosmicRay> bos: not yet.  must go look now
11:37:07 <monochrom> perhaps he finds the proof-burden part trivial. like I do.
11:37:08 <copumpkin> it's a difficult position, because I agree with his fundamental point that rubyists _should_ be interested in this stuff
11:37:15 <copumpkin> but they're also horribly opposed to type systems :P
11:37:19 <CosmicRay> bos: oh sweet!
11:37:22 <bos> CosmicRay: RWH is in the top 20% of books that O'Reilly has launched
11:37:26 <copumpkin> so you really don't want to show the negatives if you can possibly avoid it ;)
11:37:28 <copumpkin> or everyone will walk out
11:37:33 <bos> dons: ^^^
11:37:40 <copumpkin> oh nice!
11:37:43 <jmcarthur> copumpkin: i think their culture of testing is a direct result of having no other way to verify programs
11:38:01 <copumpkin> jmcarthur: yeah, I agree
11:38:11 <copumpkin> but massaging their ego by telling them it's something unique
11:38:13 <copumpkin> is a good move :P
11:38:16 <jmcarthur> heh
11:38:22 <copumpkin> if it converts even a few to our strongly typed ways
11:38:23 <CosmicRay> bos: what I did notice was that dons has been very excited about LYAH recently ;-)
11:38:30 <jmcarthur> yeah let's ignore that python programmers tend to be pretty good about testing too
11:38:40 <copumpkin> sssh
11:38:44 <copumpkin> :)
11:39:02 <copumpkin> hell, I actually enjoy writing tests in haskell
11:39:17 <copumpkin> and haskell has a type system a thousand times better than most languages
11:39:22 <jmcarthur> hell, quickspec will write your tests for you!
11:39:26 <CosmicRay> bos: also we are in the "books to read after being laid off" list http://www.amazon.com/Books-read-after-laid-off/lm/R1WGFXBWAHTB16/ref=cm_lmt_DYNA_f_2_russss1?pf_rd_p=496997231&pf_rd_s=listmania-center&pf_rd_t=201&pf_rd_i=1593272839&pf_rd_m=ATVPDKIKX0DER&pf_rd_r=0HV13TT69VAN7YS6T6XP
11:39:26 <copumpkin> lol
11:39:42 <jmcarthur> (not really, of course)
11:39:43 <CosmicRay> copumpkin: what test infrastructure are you using?
11:39:47 <monochrom> haha read after laid off
11:40:05 <copumpkin> CosmicRay: test-framework + quickcheck2 right now
11:40:11 <copumpkin> enjoying it, but am open to suggestions :)
11:40:27 <CosmicRay> copumpkin: not familiar with t-f.  what does it do for impure functions?
11:40:29 <jmcarthur> i like to use a combination of quickcheck, smallcheck, and lazysmallcheck, at least when i actually do proper testing. i've not really found a "framework" for testing that i immensely enjoy yet
11:40:48 <CosmicRay> jmcarthur: me neither.  I am not particularly fond of my own either.  (testpack)
11:40:49 <copumpkin> CosmicRay: not sure actually :) I tend not to write runnable apps :P
11:40:59 <copumpkin> CosmicRay: just (externally) pure libraries
11:41:11 <jmcarthur> i mostly just use a bunch of flags for cabal and some CPP #defines to control my testing
11:41:12 <CosmicRay> copumpkin: oh I see.   one of THOSE guys... ;-)
11:41:15 <copumpkin> lol
11:41:23 <copumpkin> yeah, very much not a real-worlder :P
11:41:26 <bos> CosmicRay: it's cool with me if LYAH sells well :-)
11:41:31 <CosmicRay> bos: yeah me too
11:41:35 <BONUS> me too
11:41:38 <copumpkin> except what I'm writing now is a disassembler and static analysis toolkit in haskell
11:41:38 <CosmicRay> bos: I just found it amusing
11:41:41 <copumpkin> so that's kind of real-worldy
11:41:51 <sm> CosmicRay: t-f provides a nicer (eg parallel) test runner and a facade over hunit, quickcheck, or other kinds of test
11:42:02 <CosmicRay> sm: ah.  nice.
11:42:09 <sm> I was using your testpack (thanks!) and switched to test-framework
11:42:14 <CosmicRay> sm: perhaps I can switch to it and deprecate testpack
11:42:32 <CosmicRay> sm: I derive ironically large amounts of happiness over being able to stop using my own code.
11:42:36 <BONUS> i hope amazon does that combo discount with lyah+rwh
11:42:37 <sm> heh
11:42:54 <c_wraith> how long is LYAH, on paper?
11:43:01 <jmcarthur> the thing i don't like about most of the testing frameworks i'm aware of is that they are specially coded for certain testing libraries, and usually don't have a good way to use more then one (like quickcheck, smallcheck, and lazysmallcheck)
11:43:08 <BONUS> im expecting it to be around 360 pages
11:43:25 <ezyang> jmcarthur: I feel like it would be good for test-framework to add support for smallcheck 
11:43:26 <CosmicRay> sm: I've never been happy with testpack.  I mean, it works and does what it was meant to do, but it was an astonishingly large amount of code for something that should be simpler
11:43:32 <CosmicRay> though qc 2.3 should make it much easier now
11:43:34 <jmcarthur> dang BONUS. that's longer than i thought it was
11:43:37 <ezyang> but test-framework is pretty good at making hunit and qc play together 
11:43:37 <Kaidelong> I'd get zippers in there before doing a hardcopy BONUS
11:43:49 <jmcarthur> but i love (lazy)smallcheck!
11:43:53 <Kaidelong> I've found zippers invaluable
11:43:54 <BONUS> i will. not sure about monad transformers though
11:43:59 <ezyang> As I said, it would be a good addition. :-) 
11:44:16 <ezyang> Smallcheck is definitely a Good Idea(TM) 
11:44:30 <itsmonktastic> I really need to get more into testing
11:44:35 <itsmonktastic> well, automated testing I mean
11:44:44 <jmcarthur> it might also be nice if somebody would experiment with using a faster random num generator for Arbitrary, although i don't know how much of a speedup there would be in practice
11:44:45 * sm needs to check out smallcheck
11:44:46 <Kaidelong> also would cover zippers much earlier
11:44:54 <jmcarthur> built-in parallelism in quickcheck would also be awesome
11:45:02 <CosmicRay> bos: incidentally bos my coworker has been giving me heck about the convex hull problem in ch3
11:45:04 <copumpkin> jmcarthur: test-framework does that for you
11:45:11 <jmcarthur> running each test in parallel (instead of test-framework running each *property* in parallel)
11:45:13 <copumpkin> and gives you progress bars and counts and stuff
11:45:14 <BONUS> i might stick it in earlier yeah
11:45:17 <copumpkin> oh I see
11:45:20 <CosmicRay> bos: and then was quite pleased when he solved it using only concepts introduced in chapters 1-3
11:45:25 <lispy> ezyang: I like that you're following a good process for open source collaboration with your ghc patches (I tried to add a comment to your blog, but it ended up being anonymous)
11:45:37 <sm> and while we're talking testing, let me plug shelltestrunner, which aims to make writing shell command tests easy
11:45:38 <jmcarthur> copumpkin: running tests in parallel would mean i get to see ordered results faster
11:45:45 <CosmicRay> sm: shelltestrunner?!
11:45:48 <ezyang> lispy: Ah, that was your comment! Thanks! 
11:45:49 <CosmicRay> sm: that sounds AWESOME
11:45:55 <CosmicRay> sm: can it produce hunit cases?
11:46:09 <sm> CosmicRay: eh.. yes it can
11:46:13 <lispy> ezyang: you're setting a good example :)
11:46:32 <McManiaC> http://npaste.de/i4/ <- what haddock/cabal error is that? O.o
11:46:39 <bos> CosmicRay: neat
11:48:06 <CosmicRay> bos: I recently sent Mike Loukides patches for a Java program he'd written.  This stunned both of us for multiple reasons.
11:48:57 <bos> Ha!
11:49:08 <bos> CosmicRay: are you going to ICFP?
11:49:36 <CosmicRay> bos: it's a logging program for people that participate in amateur radio contests.  I recently got my amateur radio license.  And didn't realize that he wrote it until I had been using it for a bit.  And didn't realize how fast I could remember Java from 10 years ago once I got into it.
11:49:38 <CosmicRay> bos: sadly no
11:49:57 <bos> CosmicRay: my dad used to be a ham. and another friend recently got his license too. small world!
11:50:08 <CosmicRay> however I was not stunned at all by the craptastic Java standard libraries.  they have gotten worse and worse over the years I think
11:50:10 <Kaidelong> one of the really big ways in which java wins is how you get most of what you need through the docs
11:50:13 <CosmicRay> bos: ah nice!
11:50:37 <daniwbie> hey guys, (^^) doesn't belong to any class, right?
11:50:51 <lispy> :t (^^)
11:50:51 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
11:50:59 <kmc> Prelude> :i (^^)
11:50:59 <kmc> (^^) :: (Fractional a, Integral b) => a -> b -> a
11:50:59 <kmc>         -- Defined in GHC.Real
11:51:05 <kmc> so, no it doesn't
11:51:12 <daniwbie> damn
11:51:22 <daniwbie> so i can't overwrite it, right?
11:51:33 <CosmicRay> Kaidelong: I'm not so sure.  I had a frustrating time figuring out an array, a vector, a container, a String, an ArrayList, etc.
11:51:34 <kmc> you can override the stuff it uses from Fractional and Integral
11:51:41 <kmc> or you can simply hide it and reuse the name for your own unrelated thing
11:51:43 <CosmicRay> Kaidelong: also good luck trying to read from stdin without google
11:51:57 <vanadium> Haha
11:52:17 <daniwbie> i'm already doing that, but i would like to specifically overwrite this one...
11:52:20 <daniwbie> anyway
11:52:27 <kmc> override?
11:52:53 <CosmicRay> pardon me, I meant a String[] and an ArrayList<String>
11:52:57 <kmc> why do you want to override (^^) specifically?
11:53:16 <Phyx-> oh, i thought i joined the wrong channel when i saw "String[] and an ArrayList<String>"
11:53:27 * kmc can never remember between (**), (^), and (^^) anyway
11:53:56 <CosmicRay> Phyx-: rants about Java insanity are always on-topic here ;-)
11:54:02 <medfly> can you stop having stupid flame wars in this channel? 
11:54:16 <medfly> what langauge do you think would win if you went and did this argument in #java ?
11:54:20 <Phyx-> I have a question about the HI files. :browse in ghc shows that there are 2 functions exposed by a package, but the mi_decls of the ModIface is empty.. what gives?
11:54:30 <CosmicRay> medfly: I wasn't aware there was an argument?
11:54:48 <medfly> someone was pointing the pros of java, and another was pointing the cons
11:55:11 <daniwbie> kmc: sorry, phone
11:55:36 <daniwbie> it's just that i have some code that is independent of the type of the numbers used
11:56:19 <Phyx-> anyone have any ideas?
11:56:26 <burp> > BSC.pack "ü ö ä"
11:56:28 <lambdabot>   "\252 \246 \228"
11:56:31 <daniwbie> because i have some type for probabilities encoded with logarithms
11:56:43 <burp> why does it print \252, \246, \228, my umlauts should be utf-8
11:56:53 <daniwbie> and would like to use multiplication for exponentiation
11:56:57 <burp> I expected it to print "\195\188 \195\182 \195\164"
11:57:12 <aristid> :t BSC.pack
11:57:13 <lambdabot> String -> BSC.ByteString
11:57:13 <c_wraith> burp, it's using the Char8 pacakge
11:57:22 <kmc> ByteString.Char8 is not utf-8
11:57:32 <c_wraith> That truncates all character values to the 0-255 range
11:57:34 <kmc> it just truncates (or wraps?) each codepoint to [0,255]
11:57:37 <c_wraith> it's not unicode
11:58:03 <kmc> Char holds a unicode codepoint, not an encoding.  so saying your umlauts are utf-8 is a nonsense statement
11:58:16 <kmc> there are packages for utf-8 encoding/decoding
11:58:37 <burp> kmc: well I send them utf-8 encoded ;)
11:58:43 <dafis> burp: also, the Show instance for Char escapes all characters beyond '\DEL'
11:58:57 <c_wraith> burp, in memory, Char is not utf-8.  it's UCS-32
11:59:20 <monochrom> (for most conceivable compilers)
11:59:21 <kmc> and that's an implementation detail
11:59:30 <kmc> you can't observe the encoding of a Char without deep hacks
11:59:42 <kmc> medfly-, doesn't seem like a flamewar -- not angry enough
11:59:58 <monochrom> I hook up an oscilloscope to my cpu to observe ghc
12:00:55 <kmc> medfly-, and i don't agree about the symmetry -- Haskell community is fairly unusual in having people with a personal interest in convincing you Haskell is good
12:01:02 <kmc> most Java programmers don't care if you think Java is good
12:01:14 <CosmicRay> kmc: they care if their boss thinks Java is good?
12:01:21 <kmc> everyone's boss thinks Java is good
12:01:24 <CosmicRay> heh
12:01:52 <CosmicRay> kmc: I can see I need to set you up with a chat with the people on my team ;-)
12:01:54 <kmc> this is part because Haskell has a lot of starry-eyed beginners who are still at the stage of "omg that quicksort is so short"
12:02:09 <vanadium> but it is <:(
12:02:14 <kmc> who haven't used it enough to see that, like every other programming language, Haskell sucks
12:02:23 <CosmicRay> heh
12:02:23 <kmc> granted, not as much
12:02:28 <vanadium> only takes trying to use if-then-else in a do-block to find that out
12:02:32 <kmc> hehe
12:02:32 <CosmicRay> I had no idea this approach was so common.
12:02:36 <kmc> nah that's supported in H2010 ;)
12:02:51 <CosmicRay> 10+ yrs ago I worked for an ISP and our informal slogan was "we suck less"
12:02:54 <CosmicRay> and it was true.
12:03:06 <monochrom> there was no flame wars. there were just a few fine jokes.
12:03:14 <kmc> it's also because FP is systematically ignored until it makes its way into mainstream languages under a new name
12:03:14 <vanadium> kmc: Oh, cool
12:03:18 <vanadium> I should check their feature list again
12:03:21 <Cale> @quote #lisp
12:03:22 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
12:03:35 <kmc> so some people (including myself) feel obliged to yell about this publicly
12:03:40 <kmc> haha do they really?
12:03:47 <Cale> Apparently they did
12:05:14 <kmc> hehe
12:06:29 <Kaidelong> that sounds unusual for LISP people
12:07:00 <kmc> the enemy of my enemy is my friend ;)
12:07:47 <iota__> hi
12:07:53 <Kaidelong> well as far as I can determine haskell is a decent language that is holding the place until something better takes over
12:07:54 <Makoryu> Kaidelong: These days they're claiming that Lisp isn't a functional language
12:08:04 <Makoryu> Even Scheme
12:08:13 <Kaidelong> LISP is the only language you'll ever need why'd you even think of another
12:08:19 <jmcarthur> bears are enemies of my enemies, but i don't think that makes bears my friends
12:08:25 <Makoryu> Please. It's obviously "L.I.S.P.™"
12:08:25 <Kaidelong> those seem to be the respective attitudes
12:08:30 <Kaidelong> at least as far as blogs go
12:08:36 <monochrom> ♥ bears
12:08:36 <copumpkin> jmcarthur: the big hairy men?
12:08:53 <kmc> hi iota__
12:08:57 <monochrom> winnie the pooh is my friend
12:08:57 <Kaidelong> well, LISP are the only languages, I suppose
12:09:06 <Kaidelong> or the only syntax
12:09:11 <iota__> a possibly stupid question: is an alphanumeric-tuple a different type than numeric-tuple? in other words, why does [("b",1),(­1,1)] generate an error while [("b","b"),("b","b")] nor [(1,1),(1,1)] don't?
12:09:14 <copumpkin> monochrom: how about heffalumps?
12:09:19 <kmc> it is iota__ 
12:09:22 <monochrom> dunno
12:09:32 <kmc> tuple types are built out of their components' types
12:09:35 <kmc> :t ('x', True)
12:09:36 <lambdabot> (Char, Bool)
12:09:40 <kmc> :t (1, "seven")
12:09:41 <lambdabot> forall t. (Num t) => (t, [Char])
12:09:47 <Makoryu> iota__: All the elements of a list must have exactly the same type
12:10:30 <Makoryu> iota__: Whereas the elements of a tuple may have different types, but the type of the tuple will depend on what those are, and how many, and in what order
12:10:50 <Makoryu> iota__: So ("foo", 12) and (13, "bar") have different types
12:10:52 <iota__> kmt, Makoryu: thanks!
12:11:33 <iota__> Makoryu: interesting... just out of curiosity, is there an "unordered" tuple, i.e, a tuple such that the order would not matter for its type?
12:11:50 <kmc> not very easily
12:11:58 <kmc> how would you access its values?
12:12:07 <kmc> how do you know at compile time what type you get back
12:12:33 <jmcarthur> i suppose you could have something like this:  (Has Int a, Has String a, Has Double a) => a
12:12:37 <kmc> tuples aren't really containers, they're more like structs
12:12:54 <jmcarthur> assuming   class Has t a where get :: a -> t
12:12:57 <iota__> suppose i would like to model "a set" (in math sense) and i'm only interested whether an element belongs to it (then, i guess, i might've answered the question -- use sth else than tuple?)
12:13:01 <kmc> yeah, you could do type-indexed lookup.  it'd be ugly though, not a typical thing to do
12:13:05 <kmc> iota__, use Data.Set
12:13:25 <kmc> or a higher-order representation
12:13:26 <iota__> i see, thanks
12:13:26 <kmc> e.g.
12:13:35 <kmc> data Set = Set (Set → Bool)
12:13:46 <kmc> for naive sets
12:13:57 <kmc> identifying a set with its own characteristic function
12:14:04 <iota__> jmcarthur: that's over my head right now, but will try to remember that it's possible and look it up :)
12:15:17 <iota__> kmc: thanks for the struct analogy, i see it now :)
12:16:33 <roconnor> there are two general models for sets in type theory
12:16:51 <roconnor> predicates are most common and are arguably what sets were modeled on
12:18:02 <roconnor> other is "index-sets" where a set of a's is represented by (exists i. i -> a) and the set is identfied as the range of the function
12:19:16 <Makoryu> iota__: You know, you can always create a union type that can contain any of the types you're interested in using
12:19:40 <Makoryu> iota__: data Union = B Bool | S String | I Int
12:20:05 <Makoryu> iota__: And then you could make a list like this: [B True, S "Cthulhu", I 17]
12:20:26 <roconnor> of course there is now (a -> Bool) -> a for representing non-empty sets with choice.
12:20:50 <roconnor> er
12:20:55 <roconnor> maybe no
12:21:09 * roconnor tries to remember what search monads have to do with sets
12:21:26 <Makoryu> Whoops, I was scrolled up too far
12:21:49 <sm> how come in wine, system "SOMECMD" always gives  just "CMD Version 1.2" as output ?
12:22:11 <Zao> sm: How come Haskell?
12:22:12 <monochrom> red wine or white wine or ice wine?
12:22:18 <roconnor> sm: wrong chan ;)
12:22:50 <monochrom> perhaps "somecmd" is an existential type
12:22:56 <jmcarthur> roconnor: do you mean just (a -> Bool)?
12:23:25 <jmcarthur> oh you mentione predicates earlier
12:23:27 <jmcarthur> *mentioned
12:23:30 <roconnor> I did
12:23:41 <roconnor> The search monad must still confuse me
12:24:40 <iota__> Makoryu: i've got it (the Union), thanks; was trying to understand above that ;)
12:24:54 <sm> Zao, roconnor: I'm talking about System.Process etc, it does not seem to work in a wine CMD shell
12:27:35 <monochrom> could you try a side-effecting command, e.g., one that deletes a file?
12:28:24 <vanadium> Or creates a file
12:28:26 <vanadium> that seems safer.
12:28:53 <roconnor> sm: I assume you are aware of the issues of exec running or not running a shell to do things?
12:29:16 <sm> monochrom: the effect does not happen
12:29:39 <monochrom> how about a command that executes an executable?
12:29:45 <monochrom> system "ghci"
12:29:53 <burp> "Prelude.read: no parse" ← why can't it print a line there :/
12:30:07 <sm> no difference
12:30:28 <sm> it works on real windows, but it sure would be nice to be able to test things in wine
12:30:52 <monochrom> I would use vmware or virtualbox or ...
12:30:56 <sm> roconnor: not really
12:31:24 <sm> wine means I don't have to own windows 
12:31:29 <sm> or install it
12:31:31 <monochrom> oh, oops
12:32:12 <roconnor> sm: there was something about exec not running shell commands and you need to run something like CMD.EXE with parameters to do what you want ... or not.  I don't know the issues either :P
12:32:18 <monochrom> perhaps wine's cmd.exe is different
12:32:51 <sm> it feels like a dos prompt, but yes I think it must be...
12:33:16 <roconnor> burp: where?
12:33:34 <burp> roconnor: where the "read no parse" error happened
12:33:35 <roconnor> burp: oh, you mean put a line number of who called read?
12:33:36 <sm> I'll raise it on list or ghc tracker I guess
12:33:58 <sm> thanks all
12:34:04 <roconnor> burp: It is hard to begin with, made harder by laziness
12:34:26 <acowley> anyone think they might be able to help with an inlining + rewrite rules issue I'm having?
12:34:40 <bos> acowley: maybe
12:34:54 <roconnor> burp: still, ghci's debugger may be helpful here
12:34:57 <dafis> roconnor: it could however, print out the beginning of the string it failed to read, that would help sometimes
12:35:12 <roconnor> dafis: good idea
12:35:37 <dafis> roconnor: good enough for a proposal?
12:35:43 <burp> dafis: for sure ;)
12:35:52 <acowley> I have a pair of rules that wrap a function with another. So, say my function is called "foo", I have a rule with phase control [~1] that rewrites a specifically saturated application of, say, "foo x" to "wrap (foo x)". I have another rule in phases [1] that undoes that wrapping.
12:36:20 <acowley> Unfortunately, for this whole thing to work properly, I need my client code that calls foo to be annotated INLINE [2]
12:36:36 <acowley> In the Core output, the first rewrite to wrap works fine
12:36:52 <acowley> But in the Core, the call site of "wrap" does not have "foo" inlined
12:37:07 <acowley> So the second rewrite rule isn't picking it up *unless* the user code is inlined as I mentioned.
12:37:30 <acowley> That is, The core will have something like "blah = foo x" and later will have "wrap @ t1 blah"
12:37:41 <acowley> which seems to be stopping my unwrap rewrite
12:37:55 <acowley> I'd just rather not have this requirement of INLINE [2] on my client code.
12:39:35 <acowley> bos: any advice, general or specific?
12:41:56 <illissius`> I can't remember who was around, but I think I figured out one of the reasons I had a suspicion that 'algorithm' might be pronounced as 'algorhyme' rather than 'algorhythm'
12:42:02 <illissius`> the word 'indict'
12:42:18 <illissius`> I mean, who ever heard of a silent th, right, but who ever heard of a silent c?
12:42:54 <bos> acowley: that's pretty usual, unfortunately.
12:43:01 <monochrom> there is no c there, where is the silent c?
12:43:04 <bos> acowley: reasoning about the rewrite rule phases is hard.
12:43:11 <monochrom> oh, in "indict".
12:43:29 <acowley> bos: The Core is so close though. It's just that one extra indirection.
12:44:21 <vanadium> sup
12:44:34 <monochrom> terrible netsplit
12:44:53 <monochrom> wait, terrible end of netsplit
12:44:54 <acowley> bos: I guess my concrete hope is to figure out when GHC decides to bind foo to a separate identifier and why the application of "wrap blah" is so opaque to the optimizer when there's a handy rewrite waiting just around the corner.
12:45:11 <lispy> netsplit?  I don't think I've seen one of those in years.  But then I hide parts/joins.
12:45:29 <illissius`> that seems like a fairly direct cause and effect.
12:45:43 <acowley> bos: I just want to do something to specialize or more finely control inlining so that the "wrap foo" application is visible.
12:46:12 <illissius`> anyone know how split-objs interacts with ffi imports?
12:46:28 <tam1138> hi
12:48:16 <monochrom> and now the netsplit
12:48:20 <b52> hey
12:48:22 <tam1138> i'm storing data in a berkeley db.  it goes in with ByteString.getContents, but I'd like to extract it to a String.  i've poked around Data.Binary, but i'm not sure if that's the right direction, or even how to use it for my needs.  any ideas?
12:48:39 * jmcarthur finally looks up how to hide join/part
12:48:47 <illissius`> someone should organize a mass simultaneous channel joining once
12:48:52 <monochrom> wait, that is not a netsplit. that is a server disconnecting everything
12:48:59 <illissius`> so people go "wait, there was a netsplit?"
12:49:07 <illissius`> and be like "yeah, it happened months ago"
12:49:08 <jmcarthur> lol
12:49:18 <b52> im currently reading the book programming in haskell by graham hutton i could need a little advice on solving onve of his exercises
12:50:02 <acowley> tam1138: I don't really understand your question. Can you read a ByteString back from the DB?
12:50:26 <monochrom> you could always "unpack" if you want a String.
12:50:47 <b52> its the task 3 in chapter 5 which i solved like this: pyths n = [(a, b, c) | a <- [1..n], b <- [1..n], c <- [1..n], a^2 * b^2 == c^2]
12:50:50 <tam1138> acowley: yes.  my question is how to do ByteString -> String
12:51:02 <jmcarthur> nice. weechat has "smart filters" that hide join/part/quit information if the user hasn't been active for some amount of time
12:51:04 <acowley> tam1138: ah, well monochrom just provided that answer
12:51:06 <b52> but the result doesnt look like the printed one for pyths 10
12:51:23 <tam1138> unpack goes to [Char8] though
12:51:23 <dafis> tam1138: Data.ByteString.Char8.unpack
12:51:47 <monochrom> at least I didn't suggest "const []" this time
12:52:03 <dafis> b52: you used (*) where you should've used (+)
12:52:17 <b52> dafis: oh damn it
12:52:21 <b52> your rigfht, thanks
12:52:26 <copumpkin> tam1138: you want a null-terminated c string (as a haskell String) from the ByteString?
12:52:31 <copumpkin> (hi by the way :P)
12:52:34 <tam1138> yo
12:52:55 <tam1138> i want a haskell String (doesn't have to be null-terminated; i dont' know how Haskell stores strings internally) from a ByteString
12:52:59 <b52> thanks dude, now it works propably :=
12:53:17 <dafis> tam1138: Haskell Strings are [Char]
12:53:38 <b52> *properly
12:53:39 <tam1138> are Char and Char8 equivalent?
12:53:41 <acowley> tam1138: did dafis' earlier suggestion not work?
12:53:44 <copumpkin> tam1138: but I mean, how do you detect how long you want the string from the bytestring? on the bdb side, is it null-terminated as part of another struct? or do you maintain length explicitly?
12:53:50 <copumpkin> or is it just the entire string?
12:54:35 <tam1138> acowley: i've yet to try it; i'm poking around my code to see where it belongs
12:54:40 <tam1138> copumpkin: the entire string
12:55:12 <acowley> tam1138: The only other thing to watch out for is if your text is not UTF8. In that case, you can checkout Text.
12:55:30 <kmc> Char8 isn't a type
12:55:33 <kmc> Char and Word8 are not equivalent
12:55:34 <dafis> tam1138: if it's latin1, Data.ByteString.Char8.unpack, if it's utf8, use the utf8-string package
12:55:39 <kmc> Char stores a Unicode codepoint
12:55:41 <kmc> Word8 stores a byte
12:55:51 <kmc> the details of how Char encodes that Unicode codepoint in memory are irrelevant
12:56:21 <burp> charsets are made by evil ;)
12:56:21 <tam1138> ahhhhh, yes, dafis' suggestion did work
12:56:32 <tam1138> huh.  i thought i'd tried that before.  weird.
12:56:34 <tam1138> thanks
12:56:43 <monochrom> http://www.joelonsoftware.com/articles/Unicode.html
12:59:35 <revenantphx> mmmrgh
12:59:42 <revenantphx> > :t (<*>*
12:59:43 <lambdabot>   <no location info>: parse error on input `:'
12:59:49 <revenantphx> :t (<*>)
12:59:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:59:59 * revenantphx trying to understand this bettee.
13:00:00 <notabel> dom96: with your SimpleIRC library, is there any way to get the IrcServer that is actually in effect in the listen loop?  the one returned from connect doesn't match the one inside the loop, but it's the only one you can actually get ahold of
13:00:07 <revenantphx> :t fmap
13:00:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:00:48 <monochrom> example: fmap (:) (getChar <*> getLine)
13:01:00 <monochrom> err, that is wrong
13:01:16 <monochrom> example: (fmap (:) getChar) <*> getLine
13:01:30 <aristid> :t (:) <$> getChar <*> getLine
13:01:31 <lambdabot> IO [Char]
13:01:33 <dom96> notabel: hrm, what do you need it for?
13:01:45 <monochrom> <$> is fmap
13:02:01 <aristid> :t getLine
13:02:02 <lambdabot> IO String
13:02:21 <aristid> :t let getLine' = (:) <$> getChar <*> getLine in getLine'
13:02:22 <lambdabot> IO [Char]
13:02:33 <kmc> revenantphx, «f <$> x <*> y <*> z» is «liftA3 f x y z»
13:02:34 <aristid> yay Applicative.
13:02:38 <kmc> (and similar for other arity)
13:02:40 <kmc> :t liftA3
13:02:41 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
13:02:58 <kmc> > liftA2 (+) (Just 3) (Just 5)
13:02:59 <lambdabot>   Just 8
13:03:02 <kmc> > liftA2 (+) (Just 3) Nothing
13:03:03 <lambdabot>   Nothing
13:03:13 <kmc> > (+) <$> Just 3 <*> Just 5
13:03:14 <lambdabot>   Just 8
13:03:22 <monochrom> short way to write: do { x<-getChar; y<-getLine; return (x:y) }
13:03:25 <kmc> > [pred, succ] <*> [10, 20]
13:03:25 <notabel> dom96: well, i'm using it interactively right now, but the problem is that lots of functions take the IrcServer as an argument, but you can't actually get the IrcServer that's in effect in the listen thread.  connect returns a non-equal one, and any of the functions manipulating the sCmdChan change the IrcServer value in the listen thread, but don't return the new one
13:03:26 <lambdabot>   [9,19,11,21]
13:03:27 <revenantphx> too many people at once...
13:03:29 <revenantphx> > <
13:03:30 <lambdabot>   <no location info>: parse error on input `<'
13:03:40 <revenantphx> I'm just trying to understand how applicatives are different than functors I guess.
13:03:45 <dafis> > (+) <$> [3,4] <*> [5,12]
13:03:46 <lambdabot>   [8,15,9,16]
13:03:47 <aristid> revenantphx: you need more input bandwidth
13:03:48 <revenantphx> I mean, I get that they are, but not the nitty gritty of how.
13:03:52 <monochrom> use your scroll buffer. you have 4GB of RAM. use it.
13:04:03 <revenantphx> I'm reading through it....
13:04:17 <revenantphx> I have 8GB actually.
13:04:26 <monochrom> oh, functor just promises fmap aka <$>, applicative adds <*>
13:04:27 <kmc> revenantphx, did you read Typeclassopedia?
13:04:41 <tommd> @seen bos
13:04:41 <lambdabot> Unknown command, try @list
13:04:44 <tommd> grrr
13:04:46 <kmc> applicative also adds «pure :: a → f a»
13:04:51 <kmc> though that could be a separate class Pointed
13:04:51 <c_wraith> tommd: he was around earlier
13:05:04 <copumpkin> Pointy sounds cuter
13:05:15 <kmc> Pointable
13:05:17 <copumpkin> class Functor f => Pointy f where ouch :: a -> f a
13:05:25 <fryguybob> @where Typeclassopedia
13:05:25 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:05:27 <tommd> @tell bos if you have time, I'd appreciate your input http://tommd.wordpress.com/2010/09/02/a-better-foundation-for-random-values-in-haskell/
13:05:27 <lambdabot> Consider it noted.
13:05:50 <dom96> notabel: oh, i think this is a bug. Sorry. I don't see a reason why you would actually need it though. Normally you should just use the events, which take an IrcServer as an argument.
13:06:34 <notabel> dom96: in the context of a bot, where everything is running from within the listener thread, you're right, the problem wouldn't arise
13:06:54 <notabel> but connect's return type is kind of a lie as it is
13:07:20 <notabel> because the IrcServer you get back isn't the same as (and will not track changes to) the one running in the listener
13:07:26 <dom96> indeed, i will fix this over the weekend hopefully.
13:07:34 <revenantphx> :t (***)
13:07:35 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:07:41 * revenantphx is scared.
13:07:55 <kmc> haha
13:08:02 <monochrom> don't worry about Arrow for now
13:08:17 <kmc> let's say for now:  (***) :: (b → c) → (b' → c') → (b, b') → (c, c')
13:08:17 <revenantphx> I'm not, just saw it mentioned and wanted to see what it was.
13:08:27 <revenantphx> kmc: you and your unicode >: (
13:08:32 <kmc> what's wrong with it?
13:08:34 <revenantphx> is -> not good enough?
13:08:36 <kmc> nope
13:08:37 <monochrom> ♥ unicode
13:08:44 <revenantphx> heh
13:08:48 <monochrom> and <3 is not good enough
13:08:56 <revenantphx> I thought so.
13:09:06 <revenantphx> what does this looks like to you: 
13:09:08 <monochrom> @quote 1970s
13:09:08 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
13:09:19 <dafis> > filter (<3) [0 .. 10]
13:09:20 <lambdabot>   [0,1,2]
13:09:25 <kmc> revenantphx, euro sign
13:09:30 <revenantphx> kmc: what the crap
13:09:36 <dafis> > filter (♥) [0 .. 10]
13:09:36 <lambdabot>   Not in scope: `♥'
13:09:43 <c_wraith> kmc: you must not be using utf-8 :)
13:09:49 <dafis> monochrom: ASCII beats unicode ^^
13:09:53 <kmc> i am
13:09:54 <revenantphx> c_wraith: what is it to you?
13:10:05 <aristid> :t let (♥) = (<3) in filter (♥) [0 .. 10]
13:10:06 <lambdabot> forall a. (Num a, Ord a, Enum a) => [a]
13:10:06 <c_wraith> the apple with a bite out of symbol
13:10:10 <aristid> > let (♥) = (<3) in filter (♥) [0 .. 10]
13:10:11 <lambdabot>   [0,1,2]
13:10:18 <revenantphx> c_wraith: so apple actually got their logo into unicode?
13:10:21 <revenantphx> how'd they manage that?
13:10:32 <monochrom> http://www.vex.net/~trebla/symbols/refute-anti-unicode.html
13:10:44 <c_wraith> ah, there it is
13:10:49 <revenantphx> I'm not against unicode :\
13:10:50 <kmc> (Arrow (⇝)) ⇒ (b ⇝ c) → (b' ⇝ c') → (b, b') ⇝ (c, c')  -- revenantphx if you rewrite the 'a' parameter infix it makes a lot more sense
13:10:59 <c_wraith> that sequence in utf 8 actually maps to the private range
13:11:01 <revenantphx> It's fine. It's just small and hard to read in this font.
13:11:10 <c_wraith> So it's euro on some systems, and apparently the apple logo on apple systems
13:11:17 <iota__> gotta go, cu all
13:11:27 <aristid> monochrom: ascii? you can't express umlauts in ascii, so it's NOT ACCEPTABLE
13:11:30 <kmc> (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
13:11:30 <aristid> 
13:12:01 <dafis> aristid: wofuer benoetigt man denn Umlaute?
13:12:13 <aristid> dafis: you evil person!
13:12:18 <dafis> :D
13:12:37 <revenantphx> How much would it cost to have my name inserted as a unicode glyph?
13:12:46 * hackagebot NumberSieves 0.1.1 - Number Theoretic Sieves: primes, factorization, and Euler's Totient  http://hackage.haskell.org/package/NumberSieves-0.1.1 (LeonSmith)
13:12:49 <rschnck> This is my second day with Haskell. I'm trying to create a function that can evaluate x^n using repeated squaring (and it has to be recursive). So if n is odd: x * (x^(n-1)/2)^2, and if it is even (x^n/2)^2
13:12:50 <revenantphx> like as a single glyph, all glued together.
13:13:05 <Ferdirand> revenantphx: it would be easier to change your name to some existing glyph !
13:13:05 <revenantphx> rschnck: sounds like a job for recursion.
13:13:10 <rschnck> Say I did that for n = 6, so we'd have (X^3)^2
13:13:12 <revenantphx> Ferdirand: good point!
13:13:20 <rschnck> revenantphx: Right...but how would I plug my result into the function again?
13:13:25 <rschnck> Which is the recursion bit
13:13:33 <dafis> rschnck: (^) already uses repeated squaring
13:13:46 <dafis> @src (^)
13:13:46 <lambdabot> x ^ 0            =  1
13:13:46 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:13:46 <lambdabot>   where f _ 0 y = y
13:13:46 <lambdabot>         f x n y = g x n
13:13:46 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:13:48 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:13:50 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:13:52 <c_wraith> dafis, you're not thinking "homework"
13:13:53 <rschnck> dafis: I don't care--I want to see if I can do it
13:14:00 <rschnck> c_wraith: That too, although it's noncredit.
13:14:02 <copumpkin> that @src is too big to print in channel
13:14:08 <dafis> c_wraith: no, I'm too naive
13:14:30 <revenantphx> @who are you
13:14:31 <lambdabot> Maybe you meant: do echo ghc show thx what wn
13:14:34 <copumpkin> I hate all the error "Negative argument because we insist on using Int instead of Word"
13:14:36 <c_wraith> rschnck, no worries.  homework questions are fine here, but if you say that's what you're doing, answers can be more appropriate for helping you learn what you need to. :)
13:14:39 <revenantphx> @who do
13:14:39 <lambdabot> Maybe you meant: do echo ghc show thx what wn
13:14:45 <revenantphx> @voodoo
13:14:45 <lambdabot> Unknown command, try @list
13:14:47 <revenantphx> @list
13:14:48 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:14:57 <revenantphx> @karma
13:14:57 <lambdabot> You have a karma of 0
13:14:59 <revenantphx> :O
13:15:10 <revenantphx> @karma+ revenantphx
13:15:10 <lambdabot> You can't change your own karma, silly.
13:15:16 <revenantphx> blasphemy
13:15:19 <rschnck> so if I said repsquare x n | n `mod` 2 == 0 = (x^(n/2))^2...I have the firstbit
13:15:24 <rschnck> But it's clearly not recursive in anyway
13:15:30 <rschnck> and I'm having trouble getting my head around it :<
13:15:32 <revenantphx> @vixen
13:15:32 <mauke> did you mean: even n
13:15:33 <lambdabot> there are a lot of weirdos on here
13:15:43 <revenantphx> what...?
13:15:49 <revenantphx> @vixen parameter
13:15:50 <lambdabot> why do you keep repeating yourself?
13:15:53 <revenantphx> @vixen 
13:15:54 <lambdabot> yes
13:15:58 <revenantphx> @vixen
13:15:58 <lambdabot> how's the weather over there?
13:16:01 <revenantphx> good.
13:16:03 <dafis> @botsnack
13:16:03 <lambdabot> :)
13:16:06 <rschnck> c_wraith: Good to know. 
13:16:07 <mauke> @vixen a/s/l?
13:16:08 <lambdabot> 19/f/California
13:16:10 <revenantphx> @snackbot
13:16:11 <lambdabot> Unknown command, try @list
13:16:12 <copumpkin> tommd: you mention that splitting is now a separate class... you think that's even warranted for the basic library given that nobody seems to know how to make something that does that? :) 
13:16:15 <revenantphx> @vixen a/s/l
13:16:15 <lambdabot> 19/f/California
13:16:20 <revenantphx> @vixen s/a/l
13:16:21 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
13:16:40 <tommd> copumpkin: What do you mean?  I can split all my generators (not safely, but its doable)
13:16:42 <revenantphx> @vixen 1 + 1
13:16:42 <lambdabot> have you ever made it with a man?
13:16:46 <revenantphx> @vixen 1 + 1
13:16:46 <lambdabot> why do you look like ham?
13:16:51 <revenantphx> @vixen 1 + 1
13:16:52 <lambdabot> blah
13:16:55 <copumpkin> hmm
13:17:00 <revenantphx> this thing isn't to smart.
13:17:02 <copumpkin> I thought there was no real theoretical work done on it
13:17:06 <copumpkin> revenantphx: can you quit it :P
13:17:09 <jmcarthur> wow i only saw the text and was wondering if i needed to ban somebody
13:17:09 <revenantphx> sorry
13:17:15 <Ferdirand> revenantphx: lambdabot answers in private if you want to play around
13:17:17 <jmcarthur> but apparently it was lambdabot
13:17:18 <revenantphx> oh ok
13:17:22 <c_wraith> rschnck, remove ^ from your definition entirely.  Replace the ^2 with multiplying the expression by itself.  replace the ^(anything other than 2) with a recursive call
13:17:25 <copumpkin> we should introduce a rate limiter to lambdabot
13:17:38 <jmcarthur> copumpkin: or at least a per-person rate limiter
13:17:43 <revenantphx> :P
13:17:44 <copumpkin> yeah
13:17:50 <c_wraith> rschnck, you can use let ... in ... to make the multiplication by itself efficient
13:18:00 <c_wraith> > let x = 4 + 3 in x * x
13:18:01 <lambdabot>   49
13:18:26 <c_wraith> Formulating it like that means that the value of x is only calculated once, not twice.
13:18:37 <copumpkin> brb
13:18:46 <tommd> copumpkin: Are we talking about different concepts?  The old RandomGen had 'split :: g -> (g,g)' and plenty of instances.  Clearly not theoretical.
13:18:47 <bremner> almost as cool as parantheses
13:18:53 <rschnck> c_wraith: Okay, I'll need a sec to think about that :P
13:19:00 <revenantphx> :t (<*>)
13:19:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:19:02 <c_wraith> tommd: most of the instances were pretty bad. :)
13:19:07 <tommd> yes!
13:19:12 <revenantphx> :t fmap
13:19:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:19:18 <tommd> Hence it isn't in our new fangled "RandomGenerator" class
13:19:19 <revenantphx> hm
13:19:52 <revenantphx> ugh, applicatives have me confused.
13:20:17 <revenantphx> I need to work on sharepoint stuff for a bit anyhow *sigh*
13:21:18 <acowley> revenantphx: if a Functor is a box whose contents you can work with via fmap, what can you do with a function in a box? Functor's fmap would let you apply another function to it, but that's it.
13:21:33 <revenantphx> right...
13:21:39 <acowley> revenantphx: Of course the obvious thing to want to do with a function is apply it to other things
13:21:44 <revenantphx> sure.
13:21:46 <acowley> revenantphx: which is just what Applicative does for you
13:22:06 <revenantphx> so what IS an applicative in this case.
13:22:09 <acowley> revenantphx: If you have a function in a box, and an argument for that function in the same kind of box, then you can apply the function to the argument and get the result in the same kind of box again
13:22:22 <acowley> It's very much like a Functor
13:22:24 <revenantphx> Right.
13:22:37 <revenantphx> What's the conceptual difference though.
13:23:32 <c_wraith> the different is that functor lets you transform the contents of a single container.
13:23:34 <acowley> The objects "boxed" by a functor can be used as arguments to regular functions, while the objects "boxed" by an Applicative can be used as arguments *or* as functions in an application.
13:23:45 <c_wraith> applicative lets you apply a function in one container to values in another container
13:23:56 <acowley> It's really helpful to think about something like "Just (+ 1)"
13:23:59 <revenantphx> c_wraith: so an applicative is a functor that can be applied to another functor
13:24:03 <revenantphx> (or applicative)
13:24:08 <Ferdirand> it would be good to give an example of Functor that cannot be made into Applicative
13:24:20 <revenantphx> I think I'm starting to get it.
13:24:38 <chrisdone> http://82.54.108.76:9000/
13:24:40 <revenantphx> All applicatives are functors, but only functors which can be applied to other functors are applicatives?
13:24:44 <monochrom> it's hard to find such an example and not feel pathological
13:24:54 <chrisdone> what do you think of the positioning, the expanding text box, and the extra paste button?
13:25:10 <acowley> revenantphx: I found that just thinking about examples like "Just (+ 1)" makes you think about what you might hope to do with such a thing, and the intuitive thing is just what Applicative buys you.
13:25:33 <benmachine> oh awesome, the haddock people listened to my (among others') whining about maximum page width
13:25:37 * benmachine happy inside
13:25:51 <revenantphx> acowley: elaborate a bit I guess?
13:25:54 <c_wraith> It's easy to find examples of functors for which you can't really write pure.  But finding cases where you can't write <*> is tough
13:26:09 <revenantphx> :t pure
13:26:10 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
13:26:12 <revenantphx> :t fmap
13:26:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:26:18 * monochrom tries to think of a pathological language to suggest to chrisdone, like, "why isn't VDM there?" :)
13:26:19 <Veinor> c_wraith: such as?
13:26:39 <monochrom> (oh well, VDM is not pathological at all.)
13:26:43 <acowley> revenantphx: if you were given "Just (+ 1)" and "Just 2", what is a natural thing to do with them?
13:26:49 <Mitar> Cale: great video
13:26:54 <c_wraith> Veinor: My favorite easy example is the ((,) a) functor.  You can't write pure for it without using undefined.
13:27:01 <Veinor> true
13:27:01 <jaspervdj> chrisdone: looks nice, a few comments though
13:27:03 <chrisdone> monochrom: hehe
13:27:05 <revenantphx> apply "Just (+ 1)" to "Just 2"?
13:27:11 <acowley> revenantphx: Exactly
13:27:15 <chrisdone> jaspervdj: I'm requesting comments! go!
13:27:25 <jmcarthur> c_wraith: well, not without a designated element in a, anyway
13:27:28 <acowley> revenantphx: and what would the result be?
13:27:34 <monochrom> chrisdone: when viewing a particular paste, is there a way to get the code alone?
13:27:35 <jaspervdj> chrisdone: perhaps try to make the header (title/author/language/channel) input a bit more condense
13:27:38 <revenantphx> Just 3?
13:27:42 <chrisdone> monochrom: there will be, sure
13:27:44 <revenantphx> I'm a bit shaky there, but I suppose it'd be.
13:27:45 <jmcarthur> c_wraith: (,) a is a perfectly good writer monad if you have a monoid constraint on a ;)
13:27:45 <acowley> revenantphx: You just invented Applicative!
13:27:51 <jaspervdj> chrisdone: it's kind of all on the left side
13:27:53 <c_wraith> jmcarthur, right, I meant for the generic case of "forall a"
13:27:57 <rschnck> c_wraith: how does repsquare x n | n `mod` 2 == 0 = (repsquare x (n `div` 2)) * (repsquare x (n `div` 2)) look?
13:28:02 <djahandarie> What are some types that are only instances of Pointed and not Functor?
13:28:05 <revenantphx> I'm not quite sure how the "Just" ties in.
13:28:09 <rschnck> c_wraith: and repsquare x 1 = 1
13:28:12 <revenantphx> why does it being a Maybe type matter here.
13:28:15 <jmcarthur> it's a shame we don't have that instance in the standard libraries
13:28:16 <rschnck> c_wraith: oops, repsquare x 1 = x
13:28:17 <Veinor> c_wraith: what's a value in the functor ((,) a) Integer
13:28:21 <Veinor> ?
13:28:24 <jaspervdj> chrisdone: also, I'm no javascript expert, but is it possible to have a button “insert clipboard contents”? would be really handy
13:28:29 <Veinor> er, not in the functor...
13:28:38 <c_wraith> rschnck, it looks correct, but inefficient because you're making the recursive call twice. :)
13:28:40 <monochrom> all positioning and ui things on the main page are fine with me.
13:28:41 <acowley> revenantphx: It is a Functor, and allows you to easily figure out how to evaluate "(Just (+ 1)) Nothing"
13:28:49 <Ferdirand> > [(+1),(*2)] <*> [5,10]
13:28:50 <lambdabot>   [6,11,10,20]
13:28:58 <rschnck> c_wraith: So I should do the let thing, right?
13:29:01 <chrisdone> jaspervdj: yeah, that's generally possible
13:29:03 <c_wraith> rschnck, correct
13:29:19 <rschnck> c_wraith: That hurt my mind for quite a while, but it's brilliant how elegant it ends up
13:29:28 <chrisdone> jaspervdj: well, kinda. I'll look into it, if it is, I'll do it
13:29:37 <monochrom> IIRC "insert clipboard content" only works for IE
13:29:44 <chrisdone> yeah, I was thinking the same
13:29:50 <chrisdone> kind of a security issue
13:29:52 <jaspervdj> ah, that's a pitty
13:29:54 <acowley> revenantphx: Similar to how you the Maybe or Either monads are often motivated by failable computations (e.g. division by zero). The Functor packaging is the structure you want for such constructions.
13:30:00 <jaspervdj> Yeah I understand the security issue
13:30:00 <monochrom> then again add it anyway.
13:30:03 <jmcarthur> i wish it wasn't supported in any browser
13:30:09 <revenantphx> acowley: I see I suppose.
13:30:13 <revenantphx> so something like...
13:30:29 <revenantphx> well, lemme try something
13:30:46 <revenantphx> > [(+ 1), (+ 2), (+ 3)] <*> [1,2,3]
13:30:47 <lambdabot>   [2,3,4,3,4,5,4,5,6]
13:30:49 <monochrom> just add a remark "only works for IE" beside the button so people are ashamed for complaining
13:30:51 * hackagebot wumpus-core 0.30.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.30.0 (StephenTetley)
13:30:52 <chrisdone> I don't have a windows install here so I'm just vaguely hoping it works alright on ie8. 
13:30:54 * hackagebot wumpus-basic 0.5.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.5.0 (StephenTetley)
13:31:01 <rschnck> c_wraith: Wait,h ow would I format that?
13:31:04 <chrisdone> (only vaugely)
13:31:10 <revenantphx> > [(+ 1), (+ 2), (+ 3)] fmap [1,2,3]
13:31:13 <revenantphx> er
13:31:20 <revenantphx> > fmap [(+ 1), (+ 2), (+ 3)] [1,2,3]
13:31:21 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
13:31:32 <acowley> revenantphx: good example
13:31:37 <jaspervdj> chrisdone: anyway, I like it, it's simple and nice
13:31:51 <c_wraith> rschnck, repsquare x n | n `mod` 2 == 0 = let sub = (repsquare x (n `div` 2)) in sub * sub
13:31:57 <revenantphx> so in this case fmap fails since it wants a function and a functor
13:32:07 <chrisdone> jaspervdj: sweet :-)
13:32:07 <revenantphx> <*> is fine since it wants an applicative and a functor
13:32:19 <rschnck> c_wraith: Thanks!
13:32:20 <Kaidelong> > (map fmap) [(+1), (+2), (+3)] [1,2,3]
13:32:21 <lambdabot>   Couldn't match expected type `t1 -> t'
13:32:21 <lambdabot>         against inferred type `[f a ...
13:32:27 <revenantphx> So the gist of what I'm seeing is...
13:32:30 <Ferdirand> > (+1) <$> [1,2,3]
13:32:30 <jaspervdj> chrisdone: using snap behind nginx?
13:32:31 <lambdabot>   [2,3,4]
13:32:32 <chrisdone> regarding the actual highlighted paste box, I'm going to add a little js to make it expand to the size of the paste's content
13:32:42 <Ferdirand> > [(+1)] <*> [1,2,3]
13:32:43 <lambdabot>   [2,3,4]
13:32:52 * hackagebot wumpus-microprint 0.5.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.5.0 (StephenTetley)
13:32:54 * hackagebot wumpus-tree 0.4.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.4.0 (StephenTetley)
13:33:00 <revenantphx> lists are an easier example of a functor than Maybe for me
13:33:01 <revenantphx> idk
13:33:03 <chrisdone> jaspervdj: actually just fastcgi behind nginx. I'm still somewhat fond of the CGI monad
13:33:05 <acowley> The <*> function makes an Applicative value as useful as a function: it can be applied to things.
13:33:10 <kmc> @src Maybe fmap
13:33:10 <lambdabot> fmap _ Nothing       = Nothing
13:33:11 <lambdabot> fmap f (Just a)      = Just (f a)
13:33:18 <revenantphx> So it seems an Applicative is a Functor which can be applied to Functor types.
13:33:21 <benmachine> you could technically make Data.Set Pointed but not Functor
13:33:26 <revenantphx> acowley, is that close at all?
13:33:29 <acowley> revenantphx: The types have to match
13:33:32 <benmachine> bit pedantic, because the point would usually be useless
13:33:33 <acowley> :t (<*>)
13:33:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:33:37 <revenantphx> right.
13:33:39 <acowley> There's only one f
13:33:42 <Kaidelong> > fmap (flip fmap [1,2,3])  [(+1), (+2), (+3)]
13:33:43 <lambdabot>   [[2,3,4],[3,4,5],[4,5,6]]
13:33:46 <c_wraith> rschnck, Just make sure you double-check that it's working properly.  That looks right, but I didn't test it. :)
13:33:48 <Kaidelong> yay
13:33:52 <revenantphx> acowley: hm, not sue I totally follow here.
13:33:53 <benmachine> :t S.singleton id
13:33:54 <lambdabot> forall a. S.Set (a -> a)
13:34:10 <monochrom> chrisdone: if (window.clipboardData != null) { blah = window.clipboardData.getData('Text'); }
13:34:15 <chrisdone> jaspervdj: I did the whole site in one file as a kind of gitcast by recording every relevant emacs buffer change to a git repo: http://github.com/chrisdone/amelie-emacs-cast I'm working on some javascript code to render it like etherpad
13:34:24 <revenantphx> :t pure
13:34:25 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
13:34:32 <benmachine> monochrom: what else could 'Text' be, ooi?
13:34:33 <acowley> revenantphx: I'm just pushing back a little on you wording that an Applicative can be applied to Functor types. That suggests there are two Functors in play.
13:34:34 <chrisdone> monochrom: cheers :-)
13:34:34 <revenantphx> pure (+ 1)
13:34:42 <revenantphx> > pure (+ 1)
13:34:43 <lambdabot>   No instance for (GHC.Show.Show (f (a -> a)))
13:34:43 <lambdabot>    arising from a use of `M538...
13:34:49 <c_wraith> :t pure (+ 1)
13:34:49 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a)
13:34:52 <monochrom> 'URL' is the other alternative. http://msdn.microsoft.com/en-us/library/ms536436%28v=VS.85%29.aspx
13:35:14 * benmachine blink
13:35:15 <Ferdirand> observe that fmap cannot change the 'structure' of its argument
13:35:15 <revenantphx> > pure [(+1)] 10
13:35:16 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:35:16 <lambdabot>    arising from a use of `...
13:35:19 <jaspervdj> chrisdone: awesome... perhaps record it, speak in voice and have yourself an awesome haskell webapp tutorial/screencast?
13:35:26 <revenantphx> Well, I have to do some work.
13:35:27 <aristid> > pure (+1) [10]
13:35:28 <revenantphx> I'll come back later.
13:35:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:35:28 <lambdabot>    arising from a use of `...
13:35:38 <aristid> > pure (+1) <*> [10]
13:35:38 <lambdabot>   [11]
13:36:01 <revenantphx> so pure makes a function into an applicative...?
13:36:04 <revenantphx> :t pure
13:36:05 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
13:36:11 <revenantphx> :t pure (+1) 
13:36:12 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a)
13:36:17 <acowley> revenantphx: That's a common use of it, yes
13:36:21 <revenantphx> right.
13:36:28 <acowley> revenantphx: It lifts the function into the Functor
13:36:39 <chrisdone> jaspervdj: I might do! :-) it uses decent libraries so it's a good chance to talk about them (including blazehtml)
13:36:41 <revenantphx> okay...
13:36:50 <acowley> revenantphx: or you could say it puts it in the box
13:36:51 <Ferdirand> > pure 1 :: [Int]
13:36:52 <lambdabot>   [1]
13:37:00 <Ferdirand> > pure 1 :: Maybe Int
13:37:00 <revenantphx> pure 1 :: Maybe Int
13:37:01 <lambdabot>   Just 1
13:37:14 <revenantphx> > pure 1 :: Either Int
13:37:15 <lambdabot>   `Data.Either.Either GHC.Types.Int' is not applied to enough type arguments
13:37:15 <lambdabot> ...
13:37:24 <revenantphx> > pure 1 :: Either Int Num
13:37:25 <lambdabot>   Class `GHC.Num.Num' used as a type
13:37:30 <revenantphx> orite
13:37:33 <revenantphx> > pure 1 :: Either Int [Char]
13:37:34 <lambdabot>   No instance for (Control.Applicative.Applicative
13:37:34 <lambdabot>                     (Data....
13:37:37 <revenantphx> ........
13:37:42 * revenantphx fails
13:37:44 <revenantphx> I'll be back.
13:37:48 <burp> > pure 1 :: Either String Int
13:37:49 <lambdabot>   No instance for (Control.Applicative.Applicative
13:37:49 <lambdabot>                     (Data....
13:37:56 <acowley> the joys of Either
13:37:56 <burp> whatever ;D
13:38:13 <monochrom> not sure you want to play with Either
13:38:17 <acowley> We as a community take pride in our personal instances for Either
13:38:23 <monochrom> play with Maybe and [] first
13:38:28 <kmc> unfortunately not all Monads are Applicative even though mathematically this should be the case
13:38:53 <acowley> monochrom: Either is great for thinking about operations that can fail with an error message
13:38:56 <monochrom> lambdabot probably doesn't even make Either String a monad.
13:39:15 * kmc thinks that using Either for errors is one of the most un-Haskelly parts of the std lib
13:39:23 <c_wraith> > (+1) `liftM` (Right 5)
13:39:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:39:24 <lambdabot>    `Control.Monad.Error.Cla...
13:39:40 <c_wraith> lambdabot apparently has the Control.Monad.Error class loaded
13:39:42 <benmachine> kmc: what part of the stdlib uses Either for errors?
13:39:50 <c_wraith> > (+1) `liftM` (Right 5) :: Either String Int
13:39:50 <lambdabot>   Right 6
13:39:58 <kmc> benmachine, the Monad instance for Either has an Error constraint
13:39:59 <monochrom> ok, it has it.
13:40:11 <benmachine> kmc: ah, that depends what you mean by stdlib then :P
13:40:12 <acowley> kmc: Why do you think it is un-Haskelly? It's a straightforward implementation of the essesnce of the idea.
13:40:35 <jaspervdj> chrisdone: Layout issue: http://jaspervdj.be/tmp/hpaste.png
13:40:53 <acowley> kmc: Oh, well if you're just talking about the Error constraint...
13:41:02 <kmc> acowley, because "Either" has a perfectly symmetric feel to it.  If you want to introduce something asymmetric and domain-specific, make a new type
13:41:13 <jaspervdj> chrisdone: basically, expand the paste box more to the right?
13:41:23 <kmc> i'd complain if "compare" returned an Int -1, 0, 1 instead of Ordering
13:41:31 <kmc> this is a similar (albeit less bad) situation
13:41:34 <acowley> kmc: Sorry, I only use Either and (,). :P
13:41:35 <kmc> types are less descriptive than they could be
13:41:37 <kmc> ;P
13:41:51 <revenantphx> <sarcasm> It's not like Haskell has a learning curve or anything </sarcasm>
13:41:56 <benmachine> kmc: Either isn't quite asymmetric, in that there's no type-level flip
13:42:01 <kmc> unfortunately so
13:42:06 <acowley> kmc: You're right, but understanding the fundamental nature of Either is instructive
13:42:13 <benmachine> so if Either is to be partially applied, it has to be in the left type
13:42:26 <benmachine> err
13:42:29 <benmachine> *isn't quite symmetric
13:42:32 <acowley> kmc: And reusing algebraic structure is a Haskelly thing to do.
13:42:38 <kmc> the fundamental nature of Either has nothing to do with strMsg
13:42:54 <benmachine> the Error constraint is annoying yes
13:43:02 <benmachine> but that's just people doing silly things with fail
13:43:03 <acowley> kmc: This is just a case where the algebra isn't as descriptive as you'd like
13:43:11 <benmachine> bin fail and the whole problem goes away :P
13:43:12 <acowley> but you could say the same about Maybe
13:44:49 <chrisdone> jaspervdj: hey, thanks. didn't notice that (I'm working split with emacs/chrome so they line up with a thinner window)
13:45:00 <acowley> kmc: I meant fundamental in the sense that your carefully named data type is isomorphic to Either, and I'm not going to get hung up on the fail business
13:46:49 <revenantphx> that was odd.
13:47:09 <kmc> yeah, i'm arguing that isomorphic-but-differently-named data types are an important part of type safety and self documenting APIs
13:47:09 <monochrom> because the computer wanted to get even.
13:47:32 <kmc> isomorphic-but-carefully-named that is
13:47:39 <kmc> anyway, ∗shrug∗
13:47:52 * acowley *shrugs*, too
13:47:55 <acowley> :P
13:49:39 <chrisdone> jaspervdj: hehe, a rogue max-width was in there!
13:49:43 <chrisdone> cheeky
13:49:56 <monochrom> "you must prove your css correct"...
13:50:07 <monochrom> (actually, I kind of did)
13:50:23 <chrisdone> :D
13:50:29 <jaspervdj> actually, you must prove your css is beautiful, I suppose
13:51:17 <monochrom> ha! do agda web frameworks prove my css correct?
13:51:22 <revenantphx> ugh
13:51:46 <chrisdone> in Ur, CSS makes YOU beautiful!
13:51:49 <revenantphx> its annoying, all of the few tutorials for sharepoint assume you know all the microsoft/business lingo.
13:52:10 <revenantphx> Then again, considering the cost of developing all of microsoft's stuff, it makes sense > >.
13:52:16 <monochrom> haha, and people complain about the word "monad"
13:52:27 <revenantphx> monad at least has a mathmatical backing.
13:52:40 <revenantphx> Better than "business intelligence"
13:52:45 <revenantphx> most. vague. term. ever.
13:52:53 <revenantphx> every consultancy defines it differently.
13:53:06 <chrisdone> @quote Cale category
13:53:06 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
13:53:06 <lambdabot> object in the category of religions and theomorphisms.
13:53:26 <revenantphx> @quote revenantphx
13:53:27 <lambdabot> No quotes match. :(
13:53:29 <revenantphx> D:
13:53:35 <revenantphx> I@quote
13:53:41 <revenantphx> anyhow... off we go.
13:54:30 <revenantphx> too bad F# isn't more widespread, it'd be fun to play with WHILE working.
13:54:32 <monochrom> tutorial is a perpetual problem by nature of programming
13:54:48 <revenantphx> monochrom: by tutorial I mean a walkthrough of how to solve a problem
13:55:01 <kmc> revenantphx, if you're working at a .NET shop, maybe you can work some F# in where nobody notices
13:55:02 <monochrom> yes. still a perpetual problem.
13:55:02 <revenantphx> monochrom: something to give you an idea of the process of using an API
13:55:11 <revenantphx> kmc: they do a LOT of dynamics GP work
13:55:21 <kmc> revenantphx, you can also do fancy FP stuff in C#, or most other languages really
13:55:23 <revenantphx> kmc: If I help in that dept, there's plenty of F# ^_^
13:55:34 <monochrom> programming repels people who prefer to explain things to fellow humans.
13:55:39 <kmc> LINQ is slowly converging on a functional language
13:57:05 <chrisdone> gnome's workspace switcher behaves confusingly with the default nvidia twinview monitor setup
13:57:08 <kmc> "New default CSS based on the color scheme chosen for the new Haskell    wiki, with a pull-out tab for the synopsis." -- haddock release notes
13:57:14 <kmc> does that mean the wiki is getting a facelift?
13:57:17 <revenantphx> monochrom: I'm just weird then. I love explaining things to fellow humans.
13:57:20 <kmc> it still has the old logo ;P
13:57:24 <revenantphx> monochrom: even if they dont understand :P
13:57:28 <benmachine> kmc: I believe one is in progress
13:57:29 <chrisdone> kmc: nominolo is lifting its face as we speak
13:57:37 <kmc> nice!
13:57:39 <monochrom> no, the wiki is not changed. haddock-generated html is changed.
13:58:31 <monochrom> and the quoted sentence says it clearly IMO
13:58:49 <pumpkin> the wiki is getting a facelift, yeah
13:58:52 <pumpkin> but not finished yet
13:59:16 <monochrom> oh, I see, yes, the wiki is getting changed too
13:59:22 <kmc> monochrom, "color scheme chosen for the new Haskell    wiki"
13:59:29 <chrisdone> (yes, I am just re-using the style from tryhaskell for hpaste.)
13:59:37 <pumpkin> http://lambda-haskell.galois.com/haskellwiki/Haskell_in_5_steps
13:59:58 <pumpkin> I like it better, but I think the typography could do with some improvement
14:00:32 <monochrom> crazy idea for chrisdone: copy the funky style of lyah and/or bonus's blog - "paste you a haskell for great good"...
14:00:33 <kmc> huge margins
14:00:35 <pumpkin> http://lambda-haskell.galois.com/haskellwiki/Haskell
14:00:37 * chrisdone will keep his trap shut about that wiki design
14:00:37 <kmc> i guess that's the style these days
14:00:40 <pumpkin> the front page in particular
14:02:17 <chrisdone> monochrom: I could take some pictures from BONUS's book (if that's legal) and show them when you make a paste, before redirecting :p
14:02:40 <chrisdone> "Great paste! http://s3.amazonaws.com/lyah/fx.png "
14:02:51 <revenantphx> we can have huge margins because we have plenty of screen space it seems
14:03:06 <chrisdone> hey LYAH has a nice syntax highlighting theme
14:03:13 * chrisdone takes it
14:03:54 <monochrom> both programmers and web designers should be confined to 10" netbooks
14:04:17 <dons> chrisdone: the templates aren't closed. anyone is free to develop new ones!
14:04:25 <monochrom> their quad-head 42" widescreens just keep them detached from what the rest of us see.
14:04:44 <dons> i want them in a darcs repo though, so we can keep refreshing them
14:04:45 <aristid> and people who want to buy air fresheners need to get an air freshener purchasing license
14:04:55 <chrisdone> dons: agreed!!
14:06:00 * hackagebot ldif 0.0.9 - The LDAP Data Interchange Format (LDIF) parser  http://hackage.haskell.org/package/ldif-0.0.9 (RadoslavDorcik)
14:07:07 <jmcarthur> nice
14:07:10 <chrisdone> actually that wiki theme has a really nice code color theme
14:09:41 <bla123> has anyone done interactive socket io with ghc on windows?
14:10:30 <monochrom> I haven't, but don't forget withSocketsDo
14:10:51 <bla123> i haven't ... hGetBufNonBlocking and the like is the problem
14:11:09 <bla123> the only way seems to be to fetch the data one char at a time
14:11:46 <bla123> i can't find a working function that just returns all available data
14:11:50 <chrisdone> monochrom: well I work in xmonad with split view, so I get about 500-600 pixels to work in :p http://img411.imageshack.us/img411/263/devc.png
14:12:42 <bla123> there is a ghc ticket for hGetBufNonBlocking or basically the whole windows io part, i just wanted to know if someone found a work-around until that is fixed
14:12:46 <kmc> you're wasting all that space at the bottom :O
14:13:12 <dons> bla123: i'm sure people have done interactive socket programming on windows
14:13:15 <vanadium> is gtk2hs still the state of the art for making shiny UIs
14:13:23 <dons> wasn't the ticket fixed a while ago?
14:13:34 <dons> vanadium: gtk, wx.
14:14:45 <bla123> dons: the milestone is _|_: http://hackage.haskell.org/trac/ghc/ticket/806
14:15:36 <bla123> chrisdone: what's in the upper left-hand corner of your screenshot?
14:15:49 <chrisdone> bla123: Lexx!
14:16:10 <monochrom> lexx was nice
14:16:16 <vanadium> Woah
14:16:18 <bla123> ok, i was just curious ;)
14:16:26 <monochrom> err, I mixed up. rexx was nice. dunno lexx
14:16:28 * chrisdone puts on his beehive wig and codes haskell happily
14:17:57 <tibbe_> dons: you have time to scan my blog post about the optimizations we performed?
14:18:42 <Veinor> does dons talk in here at all?
14:19:02 <dons> bla123: well, looks like async stuff doesn't work on windows. someone on windows will need  to work onn it. you can register your support by adding to the CC list.
14:19:02 <pumpkin> preflex: xseen dons
14:19:03 <preflex>  dons was last seen on freenode/#haskell 1 second ago, saying: bla123: well, looks like async stuff doesn't work on windows. someone on windows will need  to work onn it. you can register your support by adding to the CC list.
14:19:07 <monochrom> hehehe
14:19:21 <monochrom> "speaking of the dons"
14:19:23 <Veinor> :|
14:19:30 <dons> tibbe_: bed time. it looked good last i checked
14:20:28 <tibbe_> dons: alright, gnight
14:32:45 <revenantphx> >:(
14:32:46 <revenantphx> gr
14:36:27 <rschnck> I'm trying to write a function that will reverse the digits of an integer of any length. I understand how you'd do it for something of finite length, say 12: 
14:36:32 <rschnck> combinedWith :: Int -> Int -> Int
14:36:32 <rschnck> d1 `combinedWith` d2 = 10 * d1 + d2
14:36:32 <rschnck> reverse2digits :: Int -> Int
14:36:34 <rschnck> reverse2digits n = (n `mod` 10) `combinedWith` (n `div` 10)
14:36:38 <rschnck> Ah, sorry for all those enters.
14:37:10 <kmc> :t read . reverse . show
14:37:11 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
14:37:23 <kmc> > (read . reverse . show) 1234 :: Int
14:37:24 <lambdabot>   4321
14:37:54 <rschnck> This is a homework assignment...for day 2 of Haskell
14:38:01 <kmc> ok
14:38:05 <rschnck> Can't really use that strange read. reverse. show thing
14:38:13 <kmc> it's just applying three functions
14:38:19 <kmc> \x -> read (reverse (show x))
14:38:21 <kmc> but anyway
14:38:29 <rschnck> Okay, but let's take 4321
14:38:29 <kpreid_> Does this function have a common name, or a point-free implementation? ltm xs = case xs of (x:xs') -> Just (x,xs'); [] -> Nothing
14:38:46 <kmc> "uncons"?
14:39:08 <kmc> rschnck, maybe you can write a function «digits :: Int -> [Int]» recursively
14:39:14 <kpreid_> kmc: Is it available in any library
14:39:24 <kmc> kpreid_, don't know.  i have needed it, and have defined it myself
14:39:33 <kmc> rschnck, you've a base case for numbers less than 10, and a recursive case
14:39:46 <rschnck> Well I can see that, in the case of 4321
14:39:48 <rschnck> We could do something like
14:39:56 <SecondOrderSalad> I've had need for something related as kpreid_ said...
14:40:18 <rschnck> 4321 div 1000 = 4, then (4321 - 4 (4321 div 1000)) div 100 = 3, and so on
14:40:25 <kmc> rschnck, hint: it'll be easier to get the digits in least-significant-first order
14:40:26 <rschnck> and that way you can get all your digits
14:40:36 <kpreid_> the problem in question was to get the diagonal of a list-of-lists in a point-free fashion:
14:40:42 <SecondOrderSalad> elimList k2 k0 [] = k0 ; elimList k2 k0 (x:xs) = k2 x xs
14:40:48 <kpreid_> @let uncons xs = case xs of (x:xs') -> Just (x,xs'); [] -> Nothing
14:40:51 <lambdabot>  Defined.
14:40:55 <SecondOrderSalad> i.e. nonrecursive fold
14:40:59 <kpreid_> @let let diag = unfoldr (fmap (head *** (map tail)) . uncons)
14:40:59 <lambdabot>   Parse error: KW_Let
14:41:00 <kpreid_> @let diag = unfoldr (fmap (head *** (map tail)) . uncons)
14:41:02 <lambdabot>  Defined.
14:41:23 <kpreid_> uncons is kind of the opposite of unfoldr
14:41:45 <aristid> :t fmap (head *** (map tail)) . uncons
14:41:46 <lambdabot> forall a. [[a]] -> Maybe (a, [[a]])
14:41:57 <SecondOrderSalad> it's the coalgebra colaw for lists isn't it ;)
14:41:58 <aristid> :t uncons
14:41:59 <lambdabot> forall t. [t] -> Maybe (t, [t])
14:42:15 <kmc> rschnck, let me know if you get stuck
14:42:44 <SecondOrderSalad> F_A X = 1 + A * X
14:42:46 <kpreid_> aristid: uncons pulls one thing off the list, fmap threads through Maybe, (head *** map tail) gets the diagonal element (head-of-head) and the tails-of-tail for the next
14:42:56 <SecondOrderSalad> uncons :: [A] -> F_A [A]
14:43:12 <rschnck> kmc: I'm working on it :P
14:43:31 <rschnck> kmc: Had a mini-epiphany of recursion.
14:43:41 <SecondOrderSalad> unfoldr :: (S -> F_A S) -> S -> [A]
14:44:12 <aristid> :t head *** map tail
14:44:12 <lambdabot> forall c a. ([c], [[a]]) -> (c, [[a]])
14:44:13 <SecondOrderSalad> (unfoldr implements the finality of the list coalgebra among F_A-coalgebras blah blah...)
14:44:36 <SecondOrderSalad> unfoldr uncons = id I guess
14:45:08 <kpreid_> experimentally, yes
14:45:23 <kpreid_> the key being what you can compose in the middle of that
14:47:08 <SecondOrderSalad> (F_A is the functor for which [A] is the initial algebra and final coalgebra)
14:58:30 <Saizan> how do you define the category of "monoids over generators" or "F-algebras over generators" ?
15:01:48 <SecondOrderSalad> Saizan: in the sense in which a free monoid is generated by a set?
15:03:28 <SecondOrderSalad> fix a set G, object := { (M,f) | M : Monoid, f : G -> U M }
15:03:46 <monoidal> Saizan: maybe that would be pairs (X,~) where X is a set, ~ congurence and the monoids were FX/~?
15:04:16 <revenantphx> hm
15:04:19 <monoidal> oh, SecondOrderSalad's solution is better
15:04:26 <revenantphx> I'm thinking oh having ruby do my vocab for me.
15:04:33 <revenantphx> Then again, then I won't learn the words :P
15:04:58 <SecondOrderSalad> hom((M1,f1),(M2,f2)) := { g : Monoid(M1,M2) | f2 = U g   .    f1 }
15:05:03 <SecondOrderSalad> ^^^^^ @ Saizan 
15:05:25 <SecondOrderSalad> if you wish, you can make G variable too ;)
15:05:26 <monoidal> also known as slice category (G|U)
15:05:46 <SecondOrderSalad> yes =)
15:06:06 <SecondOrderSalad> and the free monoid over G is the initial object of this cat
15:07:11 <Saizan> SecondOrderSalad: where U is the forgetful functor?
15:07:15 <SecondOrderSalad> yes
15:08:39 <Saizan> makes sense
15:09:47 <SecondOrderSalad> now what are F-algebras generated by? =)
15:10:23 <SecondOrderSalad> probably just the objects of the domain category too (domain of F)
15:12:07 <Saizan> another way could be having a pointed functor M : Set -> Mon 
15:12:37 <Saizan> and then you can switch something else in place of Set
15:13:45 <SecondOrderSalad> what's a pointed functor between different categories?
15:14:11 <SecondOrderSalad> (but you could just replace the U if you want to replace Set)
15:14:40 <rschnck> kmc: I'm still fairly confused and unsure how to approach the problem.
15:14:54 <rschnck> I can see how it's recursive...but have no idea how to formulate a function for it
15:14:59 <Saizan> heh, the identity functor doesn't work between different categories, i guess?:)
15:15:00 <SecondOrderSalad> this is done to define monoid rings for example... there you use U : Ring -> Mon (forget the addition)
15:15:58 <SecondOrderSalad> (then just do the same thing as above to get the 'monoid ring over a monoid' (though usually it's done for groups))
15:16:51 <rschnck> I'm trying to write a function that reverses the order of digits of any positive integer. I can see how it can be easily done for an integer of known length
15:17:20 <kmc> rschnck, try starting like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29688#a29688
15:17:23 <rschnck> i.e. d1 `combinedWith` d2 = 10 * d1 + d2, and reverse2digits n = (n 'mod' 10) `combinedWith` (n `div` 10) would work for two digits
15:17:43 <kmc> the second equation will recursively call "digits"; the first will not
15:18:25 <Saizan> SecondOrderSalad: the initial goal was to define a category of "F-algebras with variables" such that the free F monad would be the initial object
15:18:56 <rschnck> kmc: Well then n < 10 simply = n.
15:19:04 <SecondOrderSalad> Saizan: seems like these should be free over a type
15:19:24 <rschnck> kmc: but I have no idea how to approach the second recursive bit :<
15:19:40 <SecondOrderSalad> (I think you can reduce it to the 'initial algebra' case by just adding a constructor: Var A to F)
15:19:50 <SecondOrderSalad> (but haven't proved it ;))
15:20:04 <copumpkin> rschnck: anamorphism to a list, reverse, catamorphism to a number :)
15:20:13 <copumpkin> fold . reverse . unfold 
15:20:13 <copumpkin> :P
15:20:25 <copumpkin> or you want to work entirely numerically?
15:20:54 <SecondOrderSalad> Saizan: the forgetful functor here would just take the  X of an F-algebra (F X -> X)
15:20:59 <SecondOrderSalad> then it should work just like with monoids
15:21:04 <rschnck> copumpkin: I have no idea what that means. This is my second day with Haskell.
15:21:13 <rschnck> and programming, for that matter.
15:21:16 <Veinor> copumpkin: isn't that a hylomorphism
15:21:18 <Veinor> ?
15:21:20 <djahandarie> Could a monad transformer be an adjoint functor?
15:21:59 <dafis> :t divMod
15:21:59 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
15:22:05 <dafis> rschnck:  ^^
15:22:10 <Saizan> djahandarie: a specific one could, but that's not a general characterization
15:22:46 <dafis> rschnck: that might help to produce the list of digits, from last to first
15:23:03 <dafis> > 123 `divMod` 10
15:23:04 <lambdabot>   (12,3)
15:23:07 <dafis> rschnck: ^^^
15:23:16 <Kaidelong> > (read :: [Char
15:23:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:23:28 <dafis> rschnck: recur until your number is 0
15:23:47 <Kaidelong> > (read :: [Char] -> Integer) . reverse . show $ 123
15:23:48 <djahandarie> Saizan, do you know what the general characterization would be?
15:23:48 <lambdabot>   321
15:24:01 <copumpkin> :t unfoldr (pure . (`divMod` 10)) 
15:24:02 <lambdabot> forall b. (Integral b) => b -> [b]
15:24:07 <SecondOrderSalad> (the universal property for the free F-alg generated by G being: for every F-algebra (F Y -> Y) and every function (G -> Y), there's a F-morphism (F Free -> Free) -> (F Y -> Y) such that the usual diagram commutes ;))
15:24:13 <copumpkin> (that will be infinite though
15:24:48 <dafis> copumpkin: second day, I think that's too early for unfoldr
15:25:01 <Saizan> djahandarie: no :\
15:25:18 <djahandarie> I've been trying to figure it out, and have had no luck
15:25:28 <djahandarie> But I'm not very good at this :P
15:25:29 <SecondOrderSalad> the diagram with sides (G -> U(F Free->Free) -> U(G Y -> Y))  and (G -> U(G Y -> Y))
15:25:46 <SecondOrderSalad> s/G Y/F Y/g
15:27:12 <Kaidelong> > let f x a = case x of {0 -> a; n -> f (n `div` 10) (a * 10 + (n `mod` 10))} in f 321
15:27:13 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
15:27:13 <lambdabot>    arising from a use of `...
15:27:34 <Kaidelong> lambdabot can show functions?
15:27:40 <Kaidelong> > let f x a = case x of {0 -> a; n -> f (n `div` 10) (a * 10 + (n `mod` 10))} in f 321 0
15:27:41 <lambdabot>   123
15:28:59 <Kaidelong> > map
15:28:59 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
15:29:00 <lambdabot>    arising...
15:29:26 <Kaidelong> complains of overlapping instance, not no instance
15:32:02 <Saizan> SecondOrderSalad: ok, i like the forgetful functor for algebras, but i also need each one to work for multiple Gs, but i guess that's only a problem of moving a quantifier
15:33:29 <SecondOrderSalad> Saizan: yes, and having morphisms consist of a pair of a function G -> G' and an F-algebra morphism (as in a general comma category)
15:34:12 <SecondOrderSalad> (this would be the comma category (Hask ↓ (U: F-Alg -> Hask)), indeed)
15:47:12 <maksut> yo, dear Haskellers, how can I get selector names (list of Strings) of my 'Data' definitions?
15:48:14 <maksut> please, any idea keywords to google?
15:48:45 <kmc> not so easy
15:48:50 <kmc> Haskell isn't designed for that kind of reflection
15:48:54 <kmc> but i think Data.Data can do it
15:49:15 <maksut> according to this, it seems possible :) http://blog.typlab.com/2009/09/haskell-data-types-and-xml/
15:49:33 <kmc> :t constrFields . toConstr
15:49:35 <lambdabot> forall a. (Data a) => a -> [String]
15:49:53 <kmc> > constrFields . toConstr (Endo id)
15:49:54 <lambdabot>   Couldn't match expected type `f Data.Data.Constr'
15:49:55 <lambdabot>         against inferred ...
15:50:02 <kmc> > constrFields . toConstr $ (Endo id)
15:50:03 <lambdabot>   No instance for (Data.Data.Data (Data.Monoid.Endo a))
15:50:03 <lambdabot>    arising from a use...
15:50:13 <kmc> grr what's a good record with Data
15:50:26 <kmc> anyway maksut you can use something like that, if you derive the Data typeclass
15:50:32 <kmc> which you can do with the DeriveDataTypeable extension
15:50:48 <kmc> for more reading see the Data.Data documentation and the Scrap Your Boilerplate papers
15:51:17 <maksut> ok, thanks. That's more than enough for me to go on :)
15:51:26 <kmc> no problem :)
15:51:35 <kmc> maksut, another route would be Template Haskell
15:52:11 <maksut> I tried to use Template Haskell way, but I guess I'm too novice to understande/use it.
15:52:26 <kmc> yeah, TH is a beast
15:53:01 <kmc> looks like the typlab guys are using TH
15:53:14 <McManiaC> IL2\Koppeln.hs:20:10: lexical error (UTF-8 decoding error) <- I'm using "äöü" in my code and get this error - is it possible to allow UTF8 in names/variables etc?
15:53:30 <kmc> it should work, did you check that your file is actually UTF-8?
15:53:42 <McManiaC>  hm not sure
15:53:51 <arw> McManiaC: hexdump -C it and look wether its really more than one byte per umlaut
15:53:53 <McManiaC> do you know how to do that with vim? :)
15:55:00 <arw> McManiaC: i don't really know in vim. there is 'bvi' which is binary vi.
15:55:13 <arw> McManiaC: but thats basically the same as editing a hexdump
15:55:22 <dstcruz> I feel like an arrow... a broken arrow
15:55:29 <McManiaC> well I'm on windows atm :S
15:55:52 <dmwit> Is there something corresponding to the package versioning policy, but for executable packages?
15:56:50 <dstcruz> can arrows have side-effects? are they like monads in that respect?
15:57:04 <arw> McManiaC: put the cursor on the umlaut, press 'qa'
15:57:25 <McManiaC> qa?
15:57:31 <arw> McManiaC: sorry, ga
15:57:58 <McManiaC> <ö> <|v> <M-v> 246, Hex f6, Oktal 366
15:58:22 <dmwit> dstcruz: sure
15:58:31 <arw> McManiaC: ok, now try 'g8'
15:58:38 <McManiaC> f6
15:58:45 <arw> McManiaC: then its not unicode
15:58:46 <dmwit> dstcruz: In fact, if m is a monad, then (a -> m b) is an arrow, where a and b are the type parameters that may vary.
15:58:51 <McManiaC> ok
15:58:55 <Cale> dstcruz: Yes, though I feel that the "right" axioms for arrows allow for fewer (or at least different) side effects than some monads allow. Presently every monad can be turned into an arrow though.
15:59:31 <kmc> dstcruz, monads don't have side effects.  some particular monads *describe* side effects
15:59:37 <kmc> some strings describe side effects too
15:59:43 <chrisdone> dmwit: interesting question re executable version policy
15:59:46 <kmc> "make me a sandwich" :: String
15:59:47 <arw> McManiaC: F6 is an ö in iso8859-1, windows-1252 and some others iirc.
15:59:48 <McManiaC> :set encoding=UTF-8
15:59:49 <McManiaC> :)
15:59:55 <kmc> that's a description of an action
15:59:58 <kmc> just an ordinary value
16:00:00 <McManiaC> now it works
16:00:04 <Cale> If you want the diagrams that everyone draws to make proper sense, you really want this law: (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
16:00:07 <kmc> IO values are no different, except the machine can interpret them
16:00:13 <dmwit> chrisdone: I couldn't find one. =/
16:00:19 <Cale> But that law doesn't hold in arbitrary Kleisli arrows
16:00:20 <kmc> and IO being a monad is not central to this -- it's just a convenient API for manipulating such values
16:00:24 <kmc> dstcruz, makes sense?
16:00:27 <arw> McManiaC: you can also set a standard encoding for a certain filetype like .hs
16:00:41 <chrisdone> dmwit: I suppose it'd be based on command line arguments and config file format?
16:00:43 <arw> McManiaC: should be in the normal vim tips documentation
16:00:57 <chrisdone> among god knows what else...
16:01:08 <McManiaC> arw: jup thanks
16:01:54 <dmwit> chrisdone: I was interested to notice that the current versioning policy for libraries doesn't seem to mention "behavior" as part of its criteria.
16:02:53 <chrisdone> dmwit: I thought the same, but of course that's less straight-forward to check than types and exports. I guess the target is to get that covered first
16:03:00 <kmc> dstcruz, Functor, Applicative, Monad, and Arrow are all useful APIs for manipulating some kinds of side-effect-descriptions
16:03:23 <kmc> dstcruz, but they don't confer some magical "can have side effects" property
16:03:29 <kmc> they just manipulate data
16:10:45 <copumpkin> maybe I'll make a SparseByteString before making a SparseVector
16:11:06 <copumpkin> since it matches my needs more closely for now and I can experiment more easily without having to parametrize it by the contained type
16:15:11 <chrisdone> Baughn: "Svein Ove Aas wants to share their location with you on Google Latitude" -- intentional?
16:16:08 <Baughn> chrisdone: Oops. No.
16:16:17 <copumpkin> lol
16:17:09 <chrisdone> "You too can share your location with your friends with Latitude using your mobile phone, computer, or both." -- creepy
16:17:42 <Baughn> Don't forget sharing it with advertisers.
16:17:44 <chrisdone> "oh look, chris is sat at the computer again."
16:17:54 <Baughn> "Let's sell him pizza!"
16:18:29 <chrisdone> lol
16:21:05 * copumpkin trembles
16:22:03 <jyper_noscreen> having gotten back to a non compiling project, its suddenly telling me all my functions and data types aren't in scope, are there any common problems which seem to cause something like this
16:22:10 <dstcruz> kmc: I'm trying to wrap my mind around it
16:22:24 <jyper_noscreen> having gotten back to a non compiling project after a long time
16:22:38 <dstcruz> so, an IO monad is *not* a side effect, but is a tag that side-effects might happen?
16:23:12 <kmc> no
16:23:19 <kmc> a value of type (IO a) is just a description of some effects
16:23:45 <kmc> just like the string "make me a sandwich"
16:23:49 <p_l> Baughn: the advertisers have quite advanced data about you already
16:23:53 <kmc> you can manipulate such strings in Haskell, without any sandwiches being made
16:24:21 <kmc> and you don't need to use monads to do so
16:24:36 <kmc> then, eventually, you hand the description off to another part of the system which will actually execute it
16:24:44 <kmc> that part is not coded in Haskell; it's provided by the compiler
16:24:55 <kmc> whatever effect-description you name "main" is the one which actually gets run
16:25:02 <kmc> or any effect-description you type at ghci
16:25:08 <dstcruz> ic
16:25:18 <kmc> it's *more* accurate to say that the IO value *is* a side effect, than that it *has* side effects
16:25:29 <dstcruz> so, Arrows are another way of "describing" side-effects as well?
16:25:39 <kmc> Arrow is the name of a generic API that works with lots of types
16:25:42 <kmc> Monad is the name of another generic API
16:25:44 <copumpkin> dstcruz: you could think (approximately) of IO as a string builder, where putStrLn str = "printf(\"" ++ str ++ "\");" and IO takes care of stringing the things together
16:25:49 * copumpkin shudders
16:25:51 <kmc> it happens that both of them are useful for building effect values
16:25:55 <kmc> they're useful for lots of other stuff too
16:26:00 <copumpkin> maybe I should avoid format string vulnerabilities there ;)
16:26:29 <Baughn> I think those are the least of your problem. ^^;
16:26:30 <dstcruz> copumpkin: heh
16:26:34 <kmc> dstcruz, there's no deep connection between monads and side effects.  it's just that the monad API is a good fit for the types of manipulations you need to do on effect-descriptions
16:26:55 <kmc> this is one of the most misunderstood aspects of Haskell
16:27:14 <itsmonkt1stic> that tends to be how I think of it
16:27:36 <dstcruz> so, monads can be used for more than side-effects, and they are not the only ones used to define side-effects... does that sound right?
16:27:36 <kmc> you could easily replace the Monad instance for IO with a library of IO-specific functions
16:28:13 <kmc> yeah
16:28:18 <dmwit> dstcruz: Boiling the semantic fluff out of your sentence leaves "monads are", which seems pretty accurate to me.
16:28:33 <kmc> monads are not the "special sauce" that lets you have effects in a pure functional language
16:28:47 <kmc> that special sauce is just primitive values of type (IO t)
16:28:50 <kmc> getChar and such
16:28:57 <Veinor> monads are the special sauce that makes haskell webscale!
16:28:59 <copumpkin> how would people feel about yet another ByteString type?
16:29:03 * copumpkin feels icky
16:29:13 <kmc> and a way to combine them, (>>=) :: IO a → (a → IO b) → IO b
16:29:24 <copumpkin> oh man, look at those arrows
16:29:24 * Baughn readies fork and arrows in copumpkin's general direction
16:29:28 <dmwit> copumpkin: Well, what do you want that ByteString and Text don't offer?
16:29:33 <copumpkin> dmwit: sparsity
16:29:39 <dmwit> aha
16:29:43 <kmc> and if you're just doing IO, it's irrelevant that this (>>=) function works not just on IO, but on any type M in a whole class of types
16:29:47 <dstcruz> I guess I better go read the getChar definition
16:29:54 <kmc> dstcruz, perhaps you'd like http://haskell.org/haskellwiki/Introduction_to_IO
16:29:56 <dstcruz> (I mean, the source code)
16:30:00 <copumpkin> dmwit: it's a fingertree-based interval map of strict bytestrings
16:30:05 <dmwit> copumpkin: I feel like that is a perfectly valid reason to define a new type.
16:30:07 <copumpkin> but SparseByteString is ugly
16:30:11 <Baughn> dstcruz: It won't really help.
16:30:22 <Baughn> dstcruz: For one thing, getChar is /not/ a primitive.
16:30:25 <copumpkin> I have it under Data.ByteString.Sparse
16:30:28 <kmc> dstcruz, if you do that in GHC's source, you will end up wading through ugly implementation details that have nothing to do with how to think about IO conceptually
16:30:33 <dmwit> If you can provide the same interface as ByteString, what about Data.ByteString.Sparse?
16:30:36 <dmwit> yeah
16:30:36 <Baughn> dstcruz: (It is in the haskell standard, it isn"t in reality)
16:30:47 <kmc> the IO type is an abstract type; its implementation is meant to be hidden
16:30:51 <dmwit> Why use a different type name?
16:31:03 <roconnor> @wiki IO_Semantics
16:31:03 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
16:31:07 <kmc> you are of course encouraged to peek under the hood out of curiosity, but it won't give you some insight into how to *use* the damn thing
16:31:08 <roconnor> dstcruz: ^^
16:31:10 <copumpkin> dmwit: I mostly plan on providing the same interface, but some operations make less sense and/or need different signatures (having your indexing return a Maybe is almost necessary in this case)
16:31:15 <roconnor> dstcruz: you might also enjoy that link :)
16:31:21 <dmwit> Just demand that people who want both will import them qualified (...as the current BS libraries already do).
16:31:25 <dstcruz> roconnor: thanks
16:31:30 <copumpkin> yeah
16:31:45 <dmwit> Well, I guess it's not required that they be imported qualified. Only that they be *used* qualified. ;-)
16:31:50 <copumpkin> I wonder if there's some etiquette involved in entering someone else's module space and making another type
16:31:53 <copumpkin> :P
16:31:58 <dmwit> =)
16:32:10 <copumpkin> but my main issue is that it won't be 100% interchangeable with existing ones
16:32:17 <kmc> copumpkin, yell "surprise"
16:32:20 <copumpkin> lol
16:32:32 <dstcruz> is it possible to have a ReadOnlyIO type, and a WriteOnlyIO type?
16:32:50 <dstcruz> would the compiler be able to impose the restrictions?
16:32:53 <kmc> yes
16:33:00 <kmc> what you probably want is classes
16:33:14 <copumpkin> there's a more modular way of doing that, too, explained in data types à la carte
16:33:16 <dmwit> Hm. ByteString doesn't seem like the right name if the sparse bits aren't inhabited by a default byte.
16:33:18 <kmc> class ReadIO m where { getChar :: m Char }; instance ReadIO IO where ...; instance ReadIO ReadOnlyIO where ...
16:33:25 <kmc> that way you can use the same name either in IO or in ReadOnlyIO
16:33:27 <copumpkin> dmwit: yeah, that's what I was worried about
16:33:49 <copumpkin> dmwit: I have a SparseVector currently, but my main use of it will be SparseVector Word8 and I want to call Data.Binary stuff on it
16:34:00 <copumpkin> so it seemed better to experiment with a sparse bytestring first
16:34:27 <dmwit> It feels more like a Map than a ByteString.
16:34:43 <copumpkin> yeah
16:34:44 <copumpkin> hmm
16:34:59 <dmwit> (Without quite knowing what "interval map" means, I could very well be wrong there.)
16:35:02 <copumpkin> I guess the fact that it's represented internally as arrays of contiguous keys doesn't change that fact
16:35:06 <copumpkin> no, you're right
16:35:17 <copumpkin> hmm, naming is the worst
16:35:24 <dmwit> 100% agreement
16:35:28 <copumpkin> I just want to write it and put a wildcard name in there until I figure it out
16:35:40 <copumpkin> data Foo = ...
16:35:50 * dstcruz goes back to reading more about Arrows and HXT. Thank you _SO_ much for your insights!
16:35:52 <dmwit> Byte+1Strings
16:35:58 <copumpkin> lol
16:36:04 * roconnor hasn't got Arrows yet
16:36:24 * copumpkin confiscates roconnor's haskeller card
16:36:28 <roconnor> :O
16:36:40 <dstcruz> roconnor: at some very high level, they seem to be like the (.) operator
16:36:43 <dstcruz> they allow composition
16:36:44 <roconnor> copumpkin: name one arrow that isn't a monad or a comonad
16:36:49 <dstcruz> but, I'm pretty lost still
16:37:06 <copumpkin> roconnor: kind mismatch ;)
16:37:12 <kmc> dstcruz, start with Category: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Category.html#t%3ACategory
16:37:12 <copumpkin> but yeah, I can't think of much
16:37:21 <kmc> Category alone gives you identities and composition
16:37:26 <roconnor> copumpkin: name one arrow that isn't the Kleisli arrow of a monad or a comonad
16:37:33 <kmc> basically generalizing those from the (->) type to an arbitrary 2-ary type constructor
16:37:53 <kmc> id :: (Category (~>)) => a ~> a
16:37:53 <revenantphx> one quick question
16:38:05 <roconnor> copumpkin: actually I think I can come up with some, but I'm curious if you can ;)
16:38:05 <kmc> (.) :: (Category (~>)) => (b ~> c) -> (a ~> b) -> (a ~> c)
16:38:06 <revenantphx> Do you guys have any recommendations on programming/math related books
16:38:06 <copumpkin> roconnor: would those stream processor arrows fall under a comonadic action on a stream?
16:38:09 <dmwit> kmc: The Paterson paper has several examples. Time-indexed automata spring to mind.
16:38:17 <revenantphx> I have extra money, so it's some that time again, and I'm buying new books.
16:38:23 <kmc> revenantphx, TaPL
16:38:25 <djahandarie> Why isn't category-extras in lambdabot again?
16:38:26 <kmc> @where TaPL
16:38:26 <roconnor> copumpkin: sounds likely.  I'd need something concrete to be sure.
16:38:26 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
16:38:50 <revenantphx> hm, looks interesting
16:38:54 <revenantphx> expensive though ;)
16:38:58 <dmwit> Oh, actually, I didn't know about comonads when I read the paper, so it may very well form a comonad.
16:38:58 <roconnor> revenantphx: Jaynes's book on probability theory.
16:39:00 <revenantphx> there go half my funds :D
16:39:03 <copumpkin> roconnor: http://www.haskell.org/haskellwiki/Arrow_tutorial
16:39:08 <copumpkin> that describes it I think
16:39:23 <dmwit> But the original inspiration (parsers with static-analysis information) aren't monadic, and seem unlikely to be comonadic.
16:39:36 <roconnor> copumpkin: oh I know what it is
16:39:36 <revenantphx> only only: Types and Programming Languages 
16:39:37 <revenantphx> damn
16:39:43 <roconnor> copumpkin: I don't know how or when I'd want to use it
16:39:50 <copumpkin> roconnor: oh, yeah :P
16:39:52 <copumpkin> beats me :)
16:40:08 <kmc> revenantphx, text books are expensive :/
16:40:12 <revenantphx> Oh yeah.
16:40:16 <roconnor> an Arrow is a Catagory that is also an appicative functor :D
16:40:29 <kmc> but this is pretty much *the* text for learning type theory as applied to programming languages
16:40:37 <revenantphx> right now i'm on the last of my previous set of books
16:40:40 <copumpkin> there are a few freely available ones too
16:40:40 <revenantphx> Intro to Algorithms
16:40:40 <kmc> revenantphx, of course, there are ways to get books without paying
16:40:47 <copumpkin> but they cover different sets of stuff
16:40:48 <revenantphx> kmc: yes, but I like having BOOKS
16:40:53 <revenantphx> I don't like ebooks for this kind of stuff.
16:40:54 <dstcruz> roconnor: there goes chinesse for me...
16:41:17 <kmc> i won't explicitly condone piracy because people do work hard on them.  at the same time, i think learning should trump IP rights, especially if you wouldn't have bought it anyway
16:41:30 <revenantphx> kmc: true
16:41:32 <roconnor> dstcruz: :) sorry
16:41:35 <copumpkin> dmwit: SparseMap? it would take an ordered set of keys and store adjacent keys contiguously
16:41:37 <revenantphx> I could pirate them easily in any case.
16:41:39 * copumpkin dies
16:41:40 * kmc owned a copy of TaPL, it was stolen by hippies
16:41:45 <revenantphx> I have the money though, and I like having paper copies.
16:41:51 <dstcruz> roconnor: just means I have lots to learn!
16:41:55 <roconnor> dstcruz: if it helps I didn't understand what I said either
16:41:57 <revenantphx> That was I can read them when the powers out, next to my computer, on the train
16:41:59 <revenantphx> and so on
16:42:00 <copumpkin> Maps are already easily sparse though
16:42:05 <copumpkin> meh
16:42:13 <copumpkin> I'll stop prematurely generalizing
16:42:25 <copumpkin> how about ByteMap :P
16:42:32 <revenantphx> so then, final call for book recommendations:
16:42:32 <dmwit> copumpkin: I like this.
16:42:43 <revenantphx> I'm writing down the final list (from this channel) now.
16:42:44 <roconnor> revenantphx: Jaynes's book on probability theory.
16:42:45 * Telastyn owns TaPL
16:42:47 <copumpkin> Data.ByteMap?
16:42:56 <copumpkin> that way I don't have to butt into someone else's module either
16:43:06 <roconnor> revenantphx: oh and A course in Constructive Mathematics!
16:43:21 <roconnor> revenantphx: I recommend that one first
16:43:26 <kmc> revenantphx, do you live somewhere where the power goes out often?
16:43:35 <revenantphx> kmc: no not really.
16:43:38 <revenantphx> im in pittsburgh
16:43:41 <revenantphx> we're 90% hospitals
16:43:54 <revenantphx> the redundancy in the power grid here is incredible.
16:44:08 <revenantphx> power goes out 5 min a year probably, and always comes back on quick.
16:44:28 <revenantphx> roconnor: I don't see a book with that name?
16:44:33 <revenantphx> who's the author?
16:44:39 <roconnor> revenantphx: which book?
16:44:46 <revenantphx> the constructive algebra one
16:44:50 <roconnor> oh right
16:44:51 <revenantphx> also, is this the jayne one?
16:44:51 <revenantphx> http://www.amazon.com/Probability-Theory-Logic-Science-Vol/dp/0521592712/ref=ntt_at_ep_dpi_1#reader_0521592712
16:45:02 <revenantphx> I see A course in constructive ALGEBRA
16:45:04 <revenantphx> btu I dont see math
16:45:15 <roconnor> revenantphx: 1) http://books.google.ca/books?id=fMsdixbW4NoC&printsec=frontcover&dq=a+course+in+constructive+algebra&source=bl&ots=lpafw9xkXT&sig=542F1qi2jy9FqGPoj1bdf5ta4cg&hl=en&ei=5zaATPLoOYKOnwe9-KjxDg&sa=X&oi=book_result&ct=result&resnum=1&ved=0CBMQ6AEwAA#v=onepage&q&f=false
16:45:17 <roconnor> gah
16:45:18 <McManiaC> http://npaste.de/i5/ <- what is wrong here?
16:45:23 <revenantphx> yeah, thats what I see.
16:45:28 <revenantphx> a slick 100 bucks XD
16:45:36 <revenantphx> text books are VERY expensive :P
16:45:51 <revenantphx> but hey, i'm 16. Reading these now gives me a bit of a leg up.
16:45:55 <revenantphx> Besides, I enjoy them.
16:45:58 <roconnor> revenantphx: 2) http://books.google.ca/books?id=tTN4HuUNXjgC&dq=probability+theory+the+logic+of+science&printsec=frontcover&source=bn&hl=en&ei=CzeATPuhNsGjnAfK7r2RAQ&sa=X&oi=book_result&ct=result&resnum=4&ved=0CCUQ6AEwAw#v=onepage&q&f=false
16:46:04 <revenantphx> I'm the masochist who LIKES pointer arithmetic...
16:46:08 <benmachine> McManiaC: I'm not sure exactly what you intend to do with that result
16:46:11 <roconnor> revenantphx: oh you are 16?!
16:46:12 <Telastyn> bah. you're 16, go learn to be socially well adjusted :P
16:46:20 <kmc> i think 5 min per year is rather bad by first-world standards
16:46:21 <revenantphx> Telastyn: I'm perfectly fine socially.
16:46:21 <roconnor> revenantphx: don't buy these books!
16:46:28 <roconnor> yet
16:46:28 <dmwit> McManiaC: Num doesn't support div, does it?
16:46:30 <Telastyn> .me looks around.
16:46:31 <roconnor> :)
16:46:34 <kmc> 5 nines
16:46:41 <revenantphx> I'm just making a list :P
16:46:41 <benmachine> McManiaC: I don't think that works anyway, though, because according to that signature the argument/result types can all be different Nums, I think?
16:46:55 <benmachine> oh no I'm wrong
16:46:57 <benmachine> but anyway
16:46:58 <McManiaC> dmwit: doesnt get any better if I add "Integral a =>" to the type
16:47:15 <dmwit> Yeah, that was a stupid objection. You'd get a different error if that were it.
16:47:16 <revenantphx> roconnor: my dependency system for math is like haskell...
16:47:16 <benmachine> McManiaC: what do you intend to do with the result?
16:47:25 <revenantphx> I only read the basics required once I know I need them.
16:47:27 <revenantphx> (usually)
16:47:34 <revenantphx> XD
16:47:35 <McManiaC> I just wanna make "Beer" to be any number ^^
16:47:39 <roconnor> :)
16:47:49 <benmachine> McManiaC: but how can you do anything with it if you don't know what sort of number it is?
16:47:59 <roconnor> revenantphx: the course in constructive algebra is a graduate level math textbook
16:48:11 <revenantphx> heh, might be a bit over my head ;)
16:48:13 <roconnor> revenantphx: the probability book might be undergradute level
16:48:31 <McManiaC> benmachine: everything works fine as long as I dont put it together into one touple
16:48:32 <revenantphx> I'm also not a moron, I don't buy books without looking through samples.
16:48:42 <roconnor> :)
16:48:47 <revenantphx> If something is way out of my league, i'm going ot put it on tjhe list for later.
16:49:10 <benmachine> McManiaC: well, you could just use the ImpredicativeTypes extension, but I bet it doesn't work fine
16:49:20 <benmachine> "compiles" isn't "works fine" :P
16:49:26 <benmachine> not even in haskell!
16:49:27 <tolkad> Is there any way to get http://www.haskell.org/haskellwiki/New_monads as an RSS feed?
16:49:27 <tolkad> So I can get new monads when they're still fresh
16:49:29 <benmachine> it's just much closer :P
16:49:36 <revenantphx> roconnor: have any recommendations for someone who's in Calculus BC at the moment?
16:49:41 <McManiaC> benmachine: it doesnt even compile with that ;)
16:49:52 <benmachine> McManiaC: what does it say then?
16:49:55 <McManiaC> and ImpredicativeTypes seems to be depreciated
16:49:56 <revenantphx> Introduction to (math field here) type stuff?
16:50:06 <McManiaC> meh, I'll just use float or sth :S
16:50:24 <revenantphx> I'm going to borrow a bunch of books on calculus III topics from my friend anyhow.
16:50:29 <benmachine> McManiaC: no
16:50:38 <benmachine> McManiaC: much better idea
16:50:42 <McManiaC> benmachine: about beeing less polymorphic than expected or something like that
16:50:48 <benmachine> bar :: (Num a) => a -> a -> (a, a)
16:51:06 <McManiaC> benmachine: I wanna keep the function type as simple as possible tho
16:51:07 <McManiaC> :D
16:51:15 <benmachine> McManiaC: I'm not an expert at higher-rank types, but I think what you have at the moment says
16:51:21 <benmachine> Foo can be any kind of Num
16:51:30 <benmachine> so it can be, e.g. Int, Integer, Float, whatever
16:51:35 <McManiaC> yeh
16:51:39 <revenantphx> you too kmc?
16:51:45 <benmachine> so bar can easily be Int -> Float -> (Integer, Double)
16:51:45 <tolkad> you can enable RankNTypes
16:51:48 <benmachine> but that doesn't make any sense
16:51:56 <revenantphx> any recommendations for early stuff?
16:51:59 <revenantphx> fundamentals and such
16:52:05 <benmachine> all the types have got to be the same
16:52:17 <tolkad> <tolkad> Is there any way to get http://www.haskell.org/haskellwiki/New_monads as an RSS feed?
16:52:17 <tolkad>  <tolkad> So I can get new monads when they're still fresh
16:52:20 <benmachine> McManiaC: one class constraint is pretty simple
16:52:34 <revenantphx> kmc: I'm looking at the preview of TaPL... The chapter dependency chart is pretty amusing.
16:52:38 <McManiaC> tolkad: already did that ;)
16:52:40 <tolkad> I'm tired about hearing about new monads weeks after everyone else is using them
16:52:45 <benmachine> tolkad: subscribe to the hackage feed?
16:52:57 <benmachine> if it's not on hackage, it doesn't exist
16:52:58 <tolkad> tired of*
16:53:30 <tolkad> you know, like everyone is laughing at me for using old monads
16:53:35 <tolkad> thanks guys
16:54:06 <revenantphx> roconnor: stuff at the level of ItA is good.
16:54:12 <benmachine> tolkad: ContT, the original & still the best
16:54:24 <kmc> tolkad, ;P
16:54:53 <kmc> me too what revenantphx?
16:55:04 <roconnor> ItA?
16:55:13 <EvanR> this monad is so stale its like its been sitting under a heatlamp for days
16:55:18 <revenantphx> kmc: since these (except TaPL) seem a bit over my head, do you have any fundamentals recommendations
16:55:22 <revenantphx> roconnor: Introduction to Algorithms
16:55:28 <kmc> CLRS?
16:55:38 <EvanR> like a burrito
16:55:38 <revenantphx> it's a textbook on data structures and algorithm design
16:55:48 <kmc> yeah, it's usually called CLRS after the four authors
16:55:50 <revenantphx> kmc: yes.
16:55:51 <kmc> if it's the one i mean
16:55:53 <pickles> uhm... i've just run into something very interesting
16:55:55 <kmc> anyway that book is all right
16:55:55 <revenantphx> its CLRS
16:56:00 <roconnor> revenantphx: is wha'ts his name's functional data structure's book on your list?
16:56:02 <kmc> probably you won't read the whole thing through, it's kind of a cookbook
16:56:05 <kmc> okasaki
16:56:06 <pickles> in ghc
16:56:15 <revenantphx> kmc: Of course
16:56:16 <roconnor> revenantphx: is okasaki's functional data structure's book on your list?
16:56:19 <pickles> a fn wasn't compiling b/c of a type mismatch
16:56:23 <revenantphx> roconnor: No it is not.
16:56:27 <kmc> revenantphx, i think computability/complexity theory is pretty cool.  _Introduction to the Theory of Computation_ by Sipser is a good intro
16:56:28 <revenantphx> I will go look it up
16:56:30 <pickles> the line before it i put: fnName ::
16:56:33 <roconnor> kmc: what level is that book at?
16:56:33 <pickles> and it worked
16:56:38 <roconnor> revenantphx: I haven't read it myself
16:56:38 <pickles> didn't even do a type spec
16:56:52 <kmc> Sipser is 2nd year undergrad at Caltech
16:56:55 <kmc> mandatory for CS majors
16:57:04 <kmc> it's a 3rd/4th year elective at MIT where Sipser teaches
16:57:17 <revenantphx> kmc: then it'd definitely be a good idea to read up a bit.
16:57:23 <kmc> _Computational Complexity_ by Papadimitriou is good either as a second text or just a more advanced intro -- it is self contained
16:57:24 <pickles> anyone have an explanation?
16:57:26 <kmc> has some good intro to logic too
16:57:31 <revenantphx> kmc: heh, I've been taking a look at some of MIT's opencourseware actually.
16:57:42 <kmc> revenantphx, of course there's SICP, practically required reading
16:57:44 <kmc> http://mitpress.mit.edu/sicp/
16:57:59 <revenantphx> is it entirely online?
16:58:01 <kmc> yes
16:58:05 <revenantphx> wonderful
16:58:15 <kmc> that's used in the first CS-for-CS-majors class at a lot of good schools
16:58:38 <kmc> it's amazing and intense
16:58:51 <revenantphx> cool, I'll take a look
16:58:56 <pickles> nm, misread an error
16:59:01 * pickles is an idiot
16:59:02 <revenantphx> I'm _definitely_ going into a CS major.
16:59:11 <revenantphx> I pretty much decided that 9th grade.
16:59:12 <kmc> by the end of it you've implemented Scheme in Scheme, implemented several Scheme variants in Scheme, then implemented a register machine emulator, a Scheme compiler targeting that machine, and a runtime system for the machine
16:59:14 <djahandarie> Except it uses Scheme
16:59:50 <kmc> revenantphx, i'm not much for pure math, but i did enjoy _A Course in Combinatorics_ by van Lint and Wilson
17:00:20 <revenantphx> okay, so the things added to the list are
17:00:21 <revenantphx> Purely Functional Data Structures - Okasaki
17:00:21 <revenantphx> Introduction to the Theory of Computation - Sipser
17:00:22 <revenantphx> Computational Complexity - Papadimitrou
17:00:22 <revenantphx> A Course in Combinatorics - van Lint, Wilson
17:00:27 <revenantphx> which are the most basic and recommended I read first
17:00:35 <kmc> SICP, free online
17:00:38 <revenantphx> well of course
17:00:45 <revenantphx> I mean of the others, I'll need more money anyhow
17:00:47 <kmc> Sipser
17:00:49 <revenantphx> so it'll be a month or so
17:00:51 <djahandarie> Those cover like entierly different hings
17:00:54 <djahandarie> I'd say Sipser as well
17:01:02 <tolkad> As I learn more haskell it seems to keep getting harder to keep code portable
17:01:03 <djahandarie> Leave Okasaki for last, it's hard
17:01:09 <kmc> it's a partial order only
17:01:15 <kmc> but Sipser then Papadimitriou is part of that order
17:01:25 <kmc> unless you really want to jump in
17:01:26 <tolkad> Many libraries seem to use GHC-specific features
17:01:43 <revenantphx> great, I got a lot of good books
17:01:48 <kmc> revenantphx, http://www.cs.caltech.edu/~umans/cs21/index.html
17:01:49 <revenantphx> I like the recommendations in this room a lot.
17:01:54 <revenantphx> much more math and concept related
17:02:04 <tolkad> and monad transformers are really annoying to use without undecideable instances
17:02:05 <revenantphx> Haskell seems to attract smart people :P
17:02:15 <tolkad> any advice?
17:02:20 <djahandarie> Don't forget to grab a copy of 'How to learn Java in 2 seconds'
17:02:23 <djahandarie> I wrote it
17:02:29 <djahandarie> Here it is: 'You don't.'
17:02:34 <roconnor> revenantphx: only morons use other languages :P
17:02:36 <kmc> revenantphx, that course has some good exercises.  those are really important, you have to prove stuff to absorb the knowledge
17:02:44 <revenantphx> I'll put that second then.
17:02:53 <kmc> it's a course using Sipser
17:03:00 <kmc> i'm sure theres similar at MIT OCW
17:03:06 <tolkad> revenantphx: are you going to BUY your books?
17:03:16 <revenantphx> tolkad: if they're free online no
17:03:20 <revenantphx> if they're not, I can get the money
17:03:25 <revenantphx> What else would I be spending it on.
17:03:30 <revenantphx> I'm in high school, I don't have to pay rent.
17:03:38 <kmc> tolkad, yeah it's hard to write real world Haskell code without at least a few extensions.  that said most of the really necessary ones are supported outside GHC
17:03:40 <djahandarie> Your girlfriend or something
17:03:51 <revenantphx> That's the other advantage, if I get these books now over the course of years, I don't pay a crap ton all at once later.
17:04:04 <tolkad> revenantphx: oh, well always try to pirate books before buying them
17:04:06 <djahandarie> Except you'll have outdated editions and such
17:04:19 <djahandarie> tolkad, that's awful advice lol, the author won't get any commission
17:04:29 <revenantphx> djahandarie: 2 -4 years for most of these topics... isn't going to outdate them
17:04:46 <kmc> yeah
17:04:47 <revenantphx> the Red Book's 4th or 5th edition is relevant to OpenGL 2.1
17:04:50 <revenantphx> and is all you really need
17:04:54 <revenantphx> but we're u pto the 7th now.
17:05:27 <kmc> theory changes much more slowly than Teach Yourself Visual XML .NET 4.0 In Five Hours
17:05:36 <revenantphx> kmc: exactly :P
17:05:41 <kmc> not as much trend of the day hype
17:05:42 <revenantphx> Visual XML .NET?
17:05:44 <revenantphx> I LOVE THAT LANGUAGE
17:05:48 <revenantphx> anyhow i g2g
17:05:50 <revenantphx> i'll be back later
17:05:51 <revenantphx> thanks
17:05:51 <kmc> ttyl
17:05:53 <tolkad> revenantphx: don't even have to pirate this one: http://www.google.com/search?q=Purely+Functional+Data+Structures+Okasaki
17:05:58 <djahandarie> But often courses use the latest version of the book which has different exercises and page numbers and such
17:06:05 <djahandarie> tolkad, the book is different from the paper
17:06:05 <revenantphx> djahandarie: true
17:06:12 <tolkad> oh
17:06:35 <djahandarie> I haven't read the book but that is my understanding :P
17:07:16 <djahandarie> Why isn't more of abstract algebra implemented as type classes in Haskell?
17:07:38 <tolkad> djahandarie: example?
17:07:49 <djahandarie> Ableian groups, rings, vector spaces, lie algebras, etc etc
17:08:10 <djahandarie> We can't exactly enforce the axioms but we can at least differentiate them and leave it up to the programmer
17:08:13 <tolkad> djahandarie: just went over my head
17:08:15 <tolkad> :P
17:08:39 <tolkad> don't have much of a CS education yet
17:08:49 <djahandarie> tolkad, that isn't CS, it's math
17:09:12 <tolkad> djahandarie: math education being a part of CS education
17:09:27 <tolkad> djahandarie: but not necessarily so I guess, my mistake
17:09:29 <McManiaC>  is there a function to get the "0.5" from "2.5" without something like "\i -> i - floor i" ?
17:09:32 <djahandarie> I guess. You normally wouldn't take abstract algebra as a CS undergrad though, I don't think
17:10:07 <jmcarthur> djahandarie:  there are a few libraries that attempt to satisfy that
17:10:13 <tolkad> It's actually really boring atm being forced to take these classes on basic programming
17:10:14 <jmcarthur> djahandarie: they have some flaws though
17:10:15 <arw> djahandarie: usually you will hear about (abelian) groups, rings and vector spaces, but algebras probably not.
17:10:18 <kmc> oh hmm
17:10:30 <jmcarthur> there's numericprelude, for one
17:10:33 <arw> djahandarie: and most will try to forget all that rather sooner than later.
17:10:36 <kmc> someone should recommend to revenantphx a book from an intro combinatorics course for CS people
17:11:22 <kmc> yeah. at some schools the CS degree is a vocational program to get you a job pounding out Java
17:11:35 <djahandarie> Monoids have proved to be useful as an abstraction in Haskell, I don't see why we can't utilize other things as well
17:12:00 <roconnor> djahandarie: otoh comonoids have proved to be a useless abstraction in Haskell.
17:12:16 <djahandarie> How about bimonoids? :P
17:12:21 <jyper_noscreen> I hate asking a second time but what are common problems leading to ghc seeing all your functions/adts as Not in scope:
17:12:35 <ezyang> jyper_noscreen: ghci? 
17:12:40 <jyper_noscreen> yes
17:12:42 <ezyang> if you see Prelude Main> that is the case. 
17:12:47 <ezyang> rm Main.o and try again. 
17:12:59 <ezyang> And use Cabal so this doesn't happen again ;-) 
17:13:29 <c_wraith> You could also use :load *Main
17:13:31 <McManiaC> is it possible to redefine instance definitions?
17:13:39 <ezyang> c_wraith: Oh, handy! 
17:13:45 <c_wraith> The * forces ghci to interpret the module, even if there's compiled code
17:13:59 <jyper_noscreen> no Main.o , removed other .o .hi programs in dir
17:14:00 <djahandarie> Why doesn't someone redo base and do it properly?
17:14:07 <Cygnet> hewwoes
17:14:49 <roconnor> djahandarie: because of network effects
17:15:21 <djahandarie> roconnor, huh?
17:15:25 <jmcarthur> roconnor: what does a comonoid even look like?
17:15:36 <roconnor> jmcarthur: I forget, it was really stupid
17:15:50 <jmcarthur> djahandarie: i started such a project once, but reality took over and it's been somewhat abandoned now
17:16:07 <Cygnet> it's probably a slightly newbie-ish question.. can anyone tell me how to set up the RTS in a way, so it won't open a shell window unless i do console I/O? i'm using ghc on windows
17:16:18 <roconnor> djahandarie: everyone shares monad and num classes as part of a universally shared interface
17:16:28 <roconnor> djahandarie: so no one can switch
17:16:39 <roconnor> djahandarie: the Haskell Platform will make this problem worse
17:16:55 <jmcarthur> yeah let's not get started on the platform
17:17:06 <roconnor> jmcarthur: I like griping 
17:17:26 <jmcarthur> well, i'm with you on the platform, for the record
17:17:34 <djahandarie> I think the platform is definitely a good thing in terms of making haskell easier to get into...
17:17:47 <roconnor> jmcarthur: :O
17:17:51 <roconnor> I thought I was alone
17:18:00 <djahandarie> Would there be some way to tackle it that doesn't have side effects?
17:18:04 <jmcarthur> djahandarie: i didn't find it hard to get into before the platform
17:18:06 <roconnor> Haskell should be avoid success at all costs
17:18:31 <jmcarthur> in fact, every time i've tried to use the platform i end up with frustration due to wanting to upgrade the preinstalled packages and thus breaking all kinds of things
17:18:47 <jmcarthur> mostly package manager woes, to be fair
17:19:02 <jmcarthur> but the problem didn't really exist before the platform
17:19:17 <djahandarie> jmcarthur, isn't that the same problem with distro provided packages?
17:19:39 <jmcarthur> partly
17:19:51 <ezyang> I've had reasonable success using distro packages to bootstrap cabal, and then making my own constellation of packages locally. 
17:19:52 <jmcarthur> but the problem wasn't so in my face before
17:20:05 <jmcarthur> ezyang: yeah that's what i have to do
17:20:40 <sm> HP seeems like a good starting point usually
17:20:51 <jmcarthur> in my opinion, we have enough problems getting innovations in base. the platform just restricts even more common packages from innovating
17:21:04 <djahandarie> By the way, I think comonoids would just be the analog of comonad but in Set?
17:21:16 <jmcarthur> err
17:21:22 <djahandarie> While comonad would be in C^C
17:21:33 <sm> jmcarthur: I don't see that, it just overlays a six-month stabilising step on the innovation that's happening
17:21:43 <sm> that actually frees up innovators to go wild
17:22:18 <jmcarthur> sm: that's not what i have observed based on e.g. fgl
17:22:23 <roconnor> IIRC wikipedia had a good explaination of why comonoids are useless (in Set)
17:22:33 <sm> I'm sure there's exceptions, but in general ?
17:22:46 <jmcarthur> sm: the new fgl maintainer has all these ideas but has been discouraged from changing too many things
17:23:04 <jmcarthur> no, i don't think even in general innovation is encouraged by the platform
17:23:06 <roconnor> sm: networks effects will now prevent us from ever leaving the mtl
17:23:23 <sm> I don't think HP is to blame
17:23:34 <roconnor> sm: the language is to blame, but HP makes it worse
17:23:37 <jmcarthur> HP swipes up the best packages and freezes them
17:23:43 <sm> for six months!
17:23:47 <jmcarthur> for longer
17:23:51 <roconnor> HP swipse up the most popular packages and freezes them
17:24:04 <revenantphx> (what's the topic here?)
17:24:05 <jmcarthur> roconnor: true
17:24:07 <roconnor> typically inferior packages
17:24:17 <jmcarthur> revenantphx: the haskell platform
17:24:19 <jmcarthur> we're complaining
17:24:28 <jmcarthur> and whining and bitching and moaning
17:24:33 <revenantphx> oh I see.
17:24:49 <djahandarie> I appriciate it because I've been able to get a number of friends into haskell by saying 'Click here' then 'install' then 'type'
17:24:59 <revenantphx> By "swipes up and freezes" do you mean they integrate them into the standard package, but freeze them so it's harder to use newer version?
17:25:07 <djahandarie> No elaborating bootstraping crap to get a perfect environment
17:25:09 <jmcarthur> i also don't like that haskell prime is so slow to adopt language features
17:25:24 <djahandarie> jmcarthur, imo I think they were just slow for the first revision
17:25:29 <wli> djahandarie: Install what?
17:25:30 <djahandarie> Hopefully we'll see more later
17:25:33 <jmcarthur> revenantphx: no, i mean that once a package in the the platform it's discouraged from innovating
17:25:40 <djahandarie> wli, HP
17:25:44 <roconnor> revenantphx: more or less
17:25:46 <revenantphx> okay, that'd be the result of what I said.
17:26:02 <wli> djahandarie: Hewlett Packard?
17:26:13 <revenantphx> ...
17:26:17 <djahandarie> wli, Haskell Platform :P
17:26:18 <revenantphx> I'll bet you the H is for Haskell
17:26:44 <djahandarie> For some reason that acronym was used 3 times before me but no one questioned it then? :P
17:27:00 <wli> djahandarie: Thanks. 
17:27:02 <roconnor> I guess if I wanted to stop griping and do something to stop the HP I'd have to fix cabal
17:27:05 <roconnor> but that is really hard
17:27:21 <djahandarie> Whatever happened to that GSoC involving cabal?
17:28:48 <jmcarthur> roconnor: fix cabal in what way?
17:29:18 <roconnor> jmcarthur: make it as easy to install random packages as it is to install HP
17:29:24 <roconnor> preferablly easier
17:29:40 <jmcarthur> that is not the case already?
17:29:57 <djahandarie> jmcarthur, cabal doesn't come with GHC namely
17:30:20 <jmcarthur> huh?
17:30:22 <djahandarie> I can't imagine installing a random package to be easy if you have to deal with setting up GHC
17:30:22 <jmcarthur> yes it does
17:30:29 <jmcarthur> unless you mean cabal-install
17:30:33 <roconnor> jmcarthur: I don't know.  monochrom says it is
17:30:46 <roconnor> jmcarthur: others say that you get a mess of conflicts
17:30:53 <roconnor> oh yes
17:30:54 <djahandarie> jmcarthur, I mean you don't get GHC when you get cabal-install
17:30:57 <roconnor> I mean cabal-install
17:31:04 <SecondOrderSalad> ghc has an apparently internal 'ghc-cabal'
17:31:10 <roconnor> I can't remember if monochrom was talking about cabal or cabal-install
17:31:11 <jmcarthur> roconnor: i think it would be more important to get some quality control on hackage. ratings or something at least
17:31:23 <jmcarthur> roconnor: at least then if a build fails it's obvious that it's because the package sucks
17:31:25 <SecondOrderSalad> in the binaries dir after you've compiled ghc
17:31:32 <djahandarie> jmcarthur, I can't imagine ratings doing much unless we have downvotes
17:31:42 <roconnor> jmcarthur: that might be true.  I find it unclear how important that is
17:31:45 <djahandarie> But a bunch of downvotes can be really demotivating
17:32:04 <jmcarthur> i don't think downvotes are necessary. just a 1-5 star rating is fine
17:32:11 <SecondOrderSalad> o_o
17:32:18 <Veinor> well, a bunch of 1-star ratings is also demotivating
17:32:27 <ezyang> I mostly ignore downvotes... 
17:32:28 <jmcarthur> i would find it motivating to do better
17:32:31 <SecondOrderSalad> how about what vim does
17:32:46 <roconnor> jmcarthur: I wonder if a list of lenght of reverse dependencies would be good enough
17:32:55 <SecondOrderSalad> the three judgments you can give yield +4,+1,-1 points respectively
17:32:55 <jmcarthur> maybe
17:32:57 <djahandarie> jmcarthur, you put out a package and you get a ton of downvotes, not really motivating after all the work you did
17:33:01 <roconnor> jmcarthur: it is only useful for libraries, but a rating system is most important for libraries
17:33:08 <SecondOrderSalad> so a package will have positive score unless it really sucks
17:33:19 <jmcarthur> djahandarie: not really the same for me as for you i guess
17:33:24 <jmcarthur> i prefer good feedback
17:33:32 <jmcarthur> if i do something sucky i want to know
17:33:39 <geheimdienst> what could we do about solving conflicts? cause it seems like every 3 days somebody is in here saying "ghc yells at me because monads-fd conflicts with mtl. what is this stuff even" and we mostly tell them to just ghc-pkg hide monads-fd
17:33:45 <djahandarie> Normally I want the reason it sucks if someone tells me it sucks
17:33:46 <SecondOrderSalad> (vim.org displays the sum of these ratings, and the total number of votes)
17:34:08 <ezyang> geheimdienst: The solution is to know what packages you want. 
17:34:16 <ezyang> but for many people, they don't. 
17:34:17 <revenantphx> MIT ocw has a course by Leiserson that follows CLRS
17:34:22 <revenantphx> might be worth downloading that I think.
17:34:24 <jmcarthur> djahandarie: ratings don't preclude that
17:34:51 <roconnor> geheimdienst: I kinda hope a nix-like system would help
17:34:53 <djahandarie> jmcarthur, imo it'd make it feel like a bunch of people are hating on me
17:35:02 <sm_> geheimdienst: better reporting and visualisation of the dependency network, and issues, on hackage, to increase awareness and encourage resolution
17:35:06 <roconnor> geheimdienst: but I'm not sure.  It turned out that Cabal actually works quite well for that
17:35:14 <revenantphx> only 3.7GB over 32 hours :P
17:35:18 <jmcarthur> djahandarie: would you be happier with the ability to disable ratings on your packages?
17:35:25 <revenantphx> then again I have plenty of boring bus time I coudl still stuff on my ipod for
17:35:36 <djahandarie> That'd make it look like I don't want feedback
17:35:41 <djahandarie> I think upvote systems are very good
17:35:44 <jmcarthur> djahandarie: that's what it sounds like anyway
17:35:51 <geheimdienst> i agree, i usually don't ghc-pkg hide, i just build the thing with "cabal build"
17:35:51 <roconnor> geheimdienst: possible would to *STOP TRAMPLING ON EACH OTHERS NAMESPACES*!
17:36:05 <jmcarthur> djahandarie: upvote-only ratings are the most useless kind, IMO
17:36:10 <geheimdienst> roconnor, absolutely :) that should be a policy
17:36:13 <djahandarie> Except they wouldn't that be too useful in the case of Haskell packages since most people would like the package if they were using it
17:36:22 <roconnor> and get rid of that stupid Data. prefix
17:36:33 <jmcarthur> get rid of a *lot* of prefixes
17:36:36 <revenantphx> that seems a bit contrived to me.
17:36:40 <revenantphx> the Data. prefix I mean
17:36:52 <djahandarie> jmcarthur, they are useful when trying to find something liked. They aren't useful when trying to judge the quality of a single package.
17:36:53 <SecondOrderSalad> or an irc bot that says 'ghc-pkg hide monads-fd monads-tf transformers' whenever there's a critical amount of trigger words in the last few sentences
17:36:55 <jmcarthur> personally i'd rather packages use a PackageName.* namespace
17:36:56 <SecondOrderSalad> problem solved
17:37:04 <jmcarthur> ha
17:37:24 <roconnor> jmcarthur: I agree!
17:37:37 <jmcarthur> djahandarie: a download count is as useful as upvotes, honestly
17:37:42 <jmcarthur> and easier to do
17:38:01 <djahandarie> jmcarthur, that'd only find something popular, not something liked
17:38:10 <jmcarthur> those are largely the same
17:38:17 <SecondOrderSalad> hey what about the vim.org solution? seems like the best of both worlds
17:38:25 <geheimdienst> we could hook into "ghc-pkg hide" to report to hackage where the troublemaker packages are
17:38:26 <jmcarthur> SecondOrderSalad: it doesn't sound bad
17:38:34 <roconnor> jmcarthur: well, at least there is a one direction implication
17:38:37 * djahandarie isn't familiar with that solution
17:38:38 <copumpkin> jmcarthur: how many people use mtl and how many people like it?
17:38:44 <roconnor> jmcarthur: I'm not sure well liked pacakges are always popular
17:38:44 <jmcarthur> copumpkin: point
17:38:59 <jmcarthur> same for base ;)
17:39:02 <copumpkin> :P
17:39:11 <SecondOrderSalad> djahandarie: great/good/sucks give +4/+1/-1 point, displayed rating is sum,vote count
17:39:37 <djahandarie> Hmmm
17:39:41 <geheimdienst> "error: the package you're trying to upload has module names that conflict with with the following modules already on hackage: ... rename your stuff or re-upload with --force if you know whatcha doin"
17:39:44 <roconnor> still I agree that downloading would be a great passive proxy for measruing quality
17:40:09 <SecondOrderSalad> well, and quality * age
17:40:18 <SecondOrderSalad> (not '*' but ...)
17:40:20 <jmcarthur> something else i would like to see is a good answer for orphan instances on hackage
17:40:27 <djahandarie> roconnor, it's hard, HTTP was the #1 package
17:40:32 * copumpkin is using an MPTC with type families :O
17:40:39 <djahandarie> binary network and utf8-string were also on there
17:40:47 <jmcarthur> copumpkin: been there done that :P
17:40:49 <roconnor> djahandarie: what's wrong with that?
17:41:01 <SecondOrderSalad> jmcarthur: how about something that just spiders all the source for instance decls...
17:41:15 <djahandarie> roconnor, because a single popular package also pulls all its dependencies up
17:41:25 <jmcarthur> SecondOrderSalad: in order to achieve what result?
17:41:30 <djahandarie> roconnor, and downloads just becomes another counter for # of reverse-dependencies
17:41:33 <roconnor> djahandarie: I think that is fair
17:41:35 <SecondOrderSalad> jmcarthur: "good answer for orphan instances"?
17:41:44 <SecondOrderSalad> unless you have something else than finding them in mind
17:42:03 <jmcarthur> SecondOrderSalad: i'm talking about where to put them if you have type class X and data type Y in two separate packages that you do not maintain
17:42:09 <sm> has anyone made a pandoc write for the cabal description field, by any chance ?
17:42:12 <djahandarie> roconnor, not an accurate gauge of quality really. A package which has another package as a dependency may have literally nothing to do with it
17:42:14 <sm> writer
17:42:20 <roconnor> djahandarie: if popular packages are good packages then they are picking good dependecies
17:42:35 <jmcarthur> SecondOrderSalad: the typical solution is to make yet another package, but then you can break everything later
17:42:37 <roconnor> djahandarie: they have something to do with it.  They chose that dependecy
17:42:51 <jmcarthur> it's more of a module/package issue than a cabal issue
17:42:57 <djahandarie> roconnor, I mean the people who get package A may want nothing at all from package B but are still downloading it
17:43:10 <djahandarie> roconnor, it simply feels like it wouldn't be a uniform gauge
17:43:12 <roconnor> djahandarie: I still think it counts for something quite relevent
17:43:16 <SecondOrderSalad> jmcarthur: *nod* that situation is bad... try to send in a patch and/or just work around needing an instance
17:43:26 <SecondOrderSalad> (sortBy myComparer instead of sort etc)
17:43:33 <djahandarie> roconnor, it does but I don't think it will translate into numbers well
17:43:49 <jmcarthur> SecondOrderSalad: it's even worse if you look at base.... where is my instance Monoid o => Monad ((,) o)?
17:43:51 <roconnor> djahandarie: a popular package also uses this package I think is relevent input when choosing amoung possible libraries to use
17:44:00 <roconnor> djahandarie: perhaps
17:44:54 <SecondOrderSalad> jmcarthur: well, where is it? ;)
17:44:58 <SecondOrderSalad> (or is there none)
17:45:03 <jmcarthur> SecondOrderSalad: sending in a patch is also not always the best because the maintainers of both packages might be trying to reduce their dependencies
17:45:16 <jmcarthur> SecondOrderSalad: there are a few in various packages
17:45:16 <SecondOrderSalad> hmm :(
17:48:24 <SecondOrderSalad> jmcarthur: how about an 'external instance Foo x in Control.Monad.Blah' decl? ;)
17:48:42 <SecondOrderSalad> this would go into one of the two modules where a nonorphan instance belongs
17:48:58 <SecondOrderSalad> declaring an instance elsewhere would be an error
17:49:08 <SecondOrderSalad> (elsewhere than Control.Monad.Blah)
17:49:57 <SecondOrderSalad> but it'd be fine for Control.Monad.Blah to not exist when the 'external instance' stmt is compiled
17:50:14 <jmcarthur> i don't understand that proposal. you mean "optional instances" depending on what's installed?
17:50:59 <dstcruz> all the examples at http://www.haskell.org/haskellwiki/HXT/Practical use a function called "proc", which does not seem to exist, does anyone know where to find such function?
17:51:11 <copumpkin> -XArrows
17:51:12 <SecondOrderSalad> jmcarthur: the only effect of the declaration would be to make instances in any module other than Control.Monad.Blah illegal
17:51:12 <jmcarthur> dstcruz: it's not a function. it's syntax. using arrow notation
17:51:13 <copumpkin> it's syntax
17:51:25 <jmcarthur> SecondOrderSalad: yuck!
17:51:30 <SecondOrderSalad> jmcarthur: there'd be no ambiguity depending on what's installed
17:51:49 <SecondOrderSalad> just a failure if Control.Monad.Blah isn't installed
17:52:01 <SecondOrderSalad> why yuck?
17:52:21 <jmcarthur> doesn't that defeat the purpose of type classes?
17:53:39 <dstcruz> jmcarthur: hmmm... thanks
17:53:42 <SecondOrderSalad> jmcarthur: I mean "external instance Monoid o => Monad ((,)o)" would make any instances that are compareable to it in specialization order illegal elsewhere
17:53:48 <SecondOrderSalad> not *any* monad instances
17:54:15 <SecondOrderSalad> (so 'Monad (o,Int)' or 'Monad a' would be illegal except in the given module)
17:54:21 <SecondOrderSalad> but nothing else
17:54:48 <SecondOrderSalad> * I mean 'Monad ((,)Int)' there
17:54:56 <jmcarthur> it still doesn't address data type in package A and type class in package B, neither of which depend on the other
17:55:52 <SecondOrderSalad> true, but that's a different issue isn't it
17:55:56 <jmcarthur> anyway, duplicate instances are already pretty much illegal
17:56:11 <SecondOrderSalad> but only if you actually try to load both
17:56:13 <monochrom> I still haven't tried instances.
17:56:41 <SecondOrderSalad> jmcarthur: my system would catch them earlier, since the 'external instance' is in one of the two 'primary' modules
17:56:49 <SecondOrderSalad> (class def or type def)
17:57:17 <jmcarthur> your system also requires a language change for a packaging issue, which i'm a little skeptical about
17:58:22 <SecondOrderSalad> isn't the whole typeclass system a packaging issue in that sense? ;)
17:58:53 <jmcarthur> it has packaging issues, but i'm pretty sure the design is package-unaware
17:59:07 <jmcarthur> (possible the reason for said packaging issues, of course)
17:59:08 <dstcruz> ah! got to do {-# LANGUAGE Arrows #-}
17:59:12 <jmcarthur> *possibly
17:59:22 <jmcarthur> dstcruz: yeah that's one of a few ways
18:02:29 <SecondOrderSalad> jmcarthur: well, I was package-unaware there too, just module-aware (and the typeclass system *is* module-aware)
18:02:54 <SecondOrderSalad> at least in the sense that just importing a module that has a conflicting instance will make your program fail
18:36:20 * hackagebot shelltestrunner 0.9 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-0.9 (SimonMichael)
18:43:28 <revenantphx> I think I'll try to write Kadane's algorithm in Haskell with no cheating
18:43:40 <revenantphx> as a little self test to see if the concepts are actually sticking > <
18:44:23 <dataangel> I'm a haskell newb, can someone explain my compile errors? It doesn't like lines 272 and 292. I think my syntax for passing two parameters to a function must be wrong: http://pastebin.com/AGi6fGfJ
18:45:55 <revenantphx> If my teeny tiny budding intuition for haskell is to be trusted, it sounds like a job for left fold.
18:46:13 <revenantphx> eh, I'll try stuff and figure it out > <
18:46:59 <djahandarie> dataangel, the errors will definitely be neccessary for anyone to help
18:48:03 <dataangel> djahandarie: updated with errors: http://pastebin.com/UgnR6V7k
18:52:57 <dataangel> It worked fine when I just passed the 'browser' parameter
18:53:03 <djahandarie> dataangel, well, xmonad $ (defaults $ browser (editor)) should probably just be xmonad $ defaults browser editor
18:53:04 <dataangel> but as soon as i tried to add the second parameter it blew up
18:53:13 <dataangel> djahandarie: I tried that first
18:53:30 <djahandarie> What is currently there doesn't make much sense
18:54:02 <benmachine> djahandarie: xmonad . defaults $ browser editor -- I think
18:54:45 <dataangel> djahandarie: Updated with the error I get when trying that way: http://pastebin.com/i74KAwD0
18:54:47 <djahandarie> No, that would called browser with the editor parameter, which wouldn't make much sense
18:55:17 <geheimdienst> dataangel, i'm still reading your code, but try to remove the "$" from the line "keys = myKeys $ browser editor"
18:55:21 <djahandarie> Wow I cannot type right now
18:55:29 <djahandarie> And yeah what geheimdienst said also
18:55:45 <dataangel> That worked O_o
18:56:00 <dataangel> why was the fix many lines away from where the compiler said the error was?
18:56:08 <djahandarie> That was the second error
18:56:23 <djahandarie> And I think there is some odd instance imported that is giving you strange errors
18:56:38 <dataangel> djahandarie: In the C++ world, you fix earlier errors first because the later ones are likely spurious errors caused by the earlier one
18:57:13 <dataangel> djahandarie: so it's odd to me to do the opposite O_o
18:57:24 <djahandarie> Normally Haskell is nice (well, kinda) about errors but it can get weird(er) due to how flexible it can be
18:57:44 <djahandarie> And I think it just shows the errors in order by position in the file
18:58:30 <geheimdienst> i don't know, it did say "Error ... in the 'keys' field of a record". that's exactly the right place isn't it
18:58:54 <djahandarie> In the right place, but it didn't say anything about trying to call browser with editor
18:59:03 <revenantphx> It's kind of fun, figuring out kadane's in haskell.
18:59:11 <revenantphx> You have to think about it differently.
18:59:27 <revenantphx> I think I have it worked out though, I just need to make sure I know the write syntax.
18:59:30 <revenantphx> > <
18:59:32 <lambdabot>   <no location info>: parse error on input `<'
18:59:39 <djahandarie> revenantphx, note that not algorithms translate into Haskell well
18:59:50 <revenantphx> not algorithms?
18:59:52 <dataangel> geheimdienst: yeah but I expected to be able to fix each error independently
18:59:55 <kmc> hi everybody
18:59:57 <djahandarie> not all*
18:59:58 <revenantphx> not all*
19:00:00 <revenantphx> thought so ;)
19:00:02 <djahandarie> 'lo kmc
19:00:12 <revenantphx> well I think it could be expressed in a fold pretty well actually... we'll see.
19:00:37 <djahandarie> dataangel, the source of both of your errors was that $ made the right side get run as a function rather than passed as parameters to the function on the left
19:04:05 <sshc> Would anybody recommend using data-accessor over fclabels?
19:04:19 <sshc> s/over/instead of/
19:04:19 <djahandarie> That doesn't sound like a fun time, but I haven't done it before so I couldn't say
19:04:24 <djahandarie> Oh lol
19:04:35 <dataangel> thx for the help all
19:04:41 <revenantphx> the only isue Im having djahandarie 
19:04:58 <revenantphx> is I have no way of keeping track of some integer telling me where I am in a fold.
19:05:09 <revenantphx> if I had an index, i'd be good.
19:05:22 <dataangel> foldAccum or something like that isn't there
19:05:45 <revenantphx> no, just a fold that keeps a counter
19:05:48 <revenantphx> thats all
19:06:00 <revenantphx> oh well I think I can work around it actually...
19:08:09 <kmc> fold f z . zip [0..]
19:09:27 <revenantphx> kmc.....
19:09:40 <revenantphx> thanks, thats a good idea.
19:10:17 <djahandarie> kmc++
19:10:23 <revenantphx> ++kmc
19:10:26 <djahandarie> Although I don't know if that'll solve your problem with Kadane's
19:10:45 <revenantphx> eh, I can think of a few ways to do it
19:10:50 <revenantphx> I just want to find an ELEGANT way
19:10:55 <revenantphx> AND KMC DONT GIVE ME ANY HINTS >:(
19:11:07 <revenantphx> I want to work this out on my own with no spoilers 
19:13:29 * hackagebot yeganesh 2.2 - small dmenu wrapper  http://hackage.haskell.org/package/yeganesh-2.2 (DanielWagner)
19:14:09 <sshc> Would anybody recommend using data-accessor or fclabels?
19:17:44 <applicative> sshc, there was a recent post by ezyang on the topic. I take it you saw it?
19:19:16 <sshc> applicative: I have not seen it.  Can you link it?
19:19:19 <applicative> http://blog.ezyang.com/2010/04/inessential-guide-to-fclabels/
19:19:35 <applicative> it links a previous one
19:19:46 <sshc> I'm actually reading that right now
19:19:53 <sshc> Which library would you suggest?
19:20:12 <sshc> The author likes fclabels
19:20:28 <sshc> I'm not familiar enough with either or with template haskell to know
19:21:03 <applicative> I'm not either, I was mentioning as an overview, I dimly remember a battle of the packages maybe on reddit in connection with these posts
19:25:30 <roconnor> sshc: I've use data-accessor and haven't used fclabels
19:26:03 <applicative> it does have the advantage of not using template haskell, so there's the hope of properly figuring it out :)
19:26:12 <Martty> can functions be scoped or are they always global
19:26:30 <copumpkin> template haskell a) isn't that bad b) you don't have to "understand it" to use it :)
19:26:38 <Martty> what the crap wrong channel
19:26:53 <applicative> oh, i was going to try to answer Martty
19:27:39 <roconnor> mattam:
19:27:46 <roconnor> Martty: they can be scoped
19:27:48 <roconnor> :)
19:28:20 <applicative> Dear Template Haskell, I shouldn't have dissed you. I apologize
19:29:21 <dataangel> I know that ! usually means strict, but what does it mean in the type declaration of a member of a record?
19:29:34 <dataangel> i've only seen it on function parameters before
19:30:10 <applicative> strict
19:30:20 <roconnor> 4. What abstract models of computation correspond to algorithms and functions?  Turing machines and lambda calculus, respectively.
19:30:22 <roconnor> Bzzzt!
19:30:24 <roconnor> incorrect
19:30:29 <applicative> haha
19:30:43 <applicative> what's the right answer then?
19:30:44 <dmwit> Yeah, I didn't understand what he was going for there, either.
19:30:45 <copumpkin> that's where h98 lets you put it :)
19:30:51 <copumpkin> the other one you've seen is the extension
19:30:52 <dataangel> ?
19:30:59 <copumpkin> dataangel: same thing, though
19:30:59 <roconnor> applicative: I don't know
19:31:12 <copumpkin> it forces the member if you force the record constructor
19:31:24 <roconnor> applicative: I don't think there is a abstract model of computation corresponding to functions
19:31:27 <dmwit> roconnor: bit of domain theory, maybe?
19:31:28 <dataangel> so is it like it's saying that the type of the function that it generates for setting that specific record member should take its parameter strict?
19:31:40 <roconnor> applicative: I think that doesn't even make sense
19:31:45 <roconnor> the question is wrong
19:31:55 <dataangel> :p
19:32:15 <applicative> dataangel, they will correct my jargon, but the record constructors are just prebuilt functions like fst and snd for pairs.  
19:32:21 <roconnor> dmwit: right, "turing machines/lambda caculus and domain theory respectively" should be the answer
19:32:26 <roconnor> dmwit: I'm not sure what the question is
19:32:45 <tg_> roconnor: How about Mu. ( http://en.wikipedia.org/wiki/Mu_(negative) )
19:33:11 <roconnor> tg_: perhaps
19:33:25 <dataangel> applicative: yeah that's what I mean, an 'assignment' of a record member is just going to construct a new record, and the exclamation is saying the constructors generated for replacing that element in the record will take the argument corresponding to that element strictly
19:33:26 <applicative> the algorithm concept escapes me.  why not say that in the lambda calculus there is only one algorithm, viz reduction?  
19:33:31 <roconnor> tg_: well this isn't really a yes/no question
19:33:52 <roconnor> applicative: there are multiple reduction strategies :D
19:34:07 <tg_> roconnor: true. it's more about unasking the question, and finding a better one :o
19:34:09 <dmwit> applicative: I believe the program itself is the algorithm.
19:34:21 <dmwit> applicative: evaluation is running the algorithm
19:34:42 <dataangel> it makes sense to me, a turing machine decides what to do based on a rule set that's given as input (an algorithm) whereas lambda calculus lets you write computation purely in terms of functions
19:34:55 <dataangel> but i'm the haskell newb ;p
19:35:20 <roconnor> there is a famous theorem that lambda calculus and turing machines are equivalent
19:35:33 <roconnor> so clearly the answer is wrong
19:35:44 <applicative> roconnor, I was assuming we'd  adopted a particular strategy. 
19:35:46 <tg_> damn. I didn't even hear the question, so what do I know
19:35:53 <roconnor> applicative: ok
19:35:59 <SecondOrderSalad> 'Last' should be a monad no?
19:36:01 <roconnor> tg_: 4. What abstract models of computation correspond to algorithms and functions?  Turing machines and lambda calculus, respectively.
19:36:08 <SecondOrderSalad> Data.Monoid.Last
19:36:38 <tg_> i thought turing machines were something a little different
19:36:39 <roconnor> tg_: I guess a bit of context is also needed: http://monoidal.blogspot.com/2010/09/algorithms-and-functions.html
19:36:54 <roconnor> tg_: they are different
19:36:57 <roconnor> they are not the same
19:37:01 <roconnor> only equivalent in some sense
19:37:01 <applicative> Obviously saying 'there's only one algorithm in (e.g. lazily evaluated) lambda calculus' is absurd, but makes the seem kind of fuzzy
19:37:08 <tg_> well, i mean, I think functions and lambda calculus are close
19:37:10 <SecondOrderSalad> how do I add stuff to base? send in a patch to the ghc repo?
19:37:13 <dataangel> rconnor: i think the question is talking about human perspective, not strict mathematical equivalence
19:37:18 <tg_> but turing machines vs. algorithms seems quite a bit far off
19:37:36 <roconnor> dataangel: the answer is still wrong
19:37:38 <dmwit> SecondOrderSalad: I guess write to libraries@. I think there's a protocol, take a look on the wiki.
19:37:40 <dataangel> ;p
19:37:58 <SecondOrderSalad> dmwit: hmm ok
19:38:00 <tg_> Human or machine, you're still dooooooomed!
19:38:17 <dmwit> SecondOrderSalad: http://www.haskell.org/haskellwiki/Library_submissions
19:38:28 <SecondOrderSalad> I can see no reason against making 'Last' a monad ;)
19:38:50 <dmwit> SecondOrderSalad: Yes, the monad instance can probably just be (GeneralizedNewtype-) derived.
19:39:33 <applicative> turing machines are for the birds; the lambda calculus, by contrast, is something divine; it is for the Gods
19:39:59 <applicative> I was reading some snotty expert discussing the opinion of Gdel on the sublimity of Turing's machines by contrast with the doltishness of Church's nonsenser
19:40:06 <SecondOrderSalad> glad that 'base' has its own repo ;)
19:40:09 <applicative> He was of course siding with  Gdel 
19:40:35 * hackagebot ncurses 0.1 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.1 (JohnMillikin)
19:40:45 <tg_> reading the Turing machine wikipedia page, and a book about the persecution of Turing...
19:41:10 <roconnor> applicative: what about combinator birds
19:41:12 <tg_> Something tells me that his brilliance would have overcome the standard age-related degeneration normally associated with scientists
19:41:29 <blackh> tg_: Wasn't he murdered? (If I recall correctly.)
19:41:39 <tg_> conspiracy theorists think so
19:41:40 <SecondOrderSalad> suicide
19:41:42 <tg_> but the evidence says no
19:41:50 <tg_> suicide by cyanide in an apple, no note.
19:41:54 <tg_> no indication to anyone
19:42:15 <blackh> Interesting - thanks!
19:43:45 <tg_> he is probably the single most important human being (if there is one) in the Allies winning WWII
19:44:41 <lispy> tg_: Who is, Alan Turing?
19:44:50 <lispy> tg_: we're playing jeopardy right?
19:44:52 <applicative> I was looking into the origin of the use of the work 'recursive' and so on.  Its popularization was due to Gdel, but he repented of this, and later wanted to speak of computable not recursive functions. He dissed Rosza Peters for studying 'recursion schemes' and similar nonsense....
19:45:02 <tg_> lispy: What is, yes?
19:45:39 <dmwit> I just discovered a python-based clone of one of my creations! I feel flattered. =D
19:45:51 <lispy> dmwit: oh yeah?
19:45:53 <lispy> dmwit: what is it?
19:46:00 <dmwit> http://www.codercpf.be/102/pydmenu-python-yeganesh-clone/
19:46:02 <applicative> that is flattering dmwit
19:46:52 <applicative> uh oh he "didn?t want to have the haskell overhead in  [his] system"
19:47:02 <dmwit> Yeah, that part is a little discouraging.
19:47:03 <lispy> dmwit++
19:47:13 <blackh> But the python overhead is OK?
19:47:21 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29690#a29690
19:47:28 <applicative> i.e. he didn't want a rational system, just a system of very tiny wires hooked up in pleasing ways....
19:47:34 <tg_> blackh: words out of my mouth and onto your keyboard
19:47:43 <tg_> python is installed in most linux distros by default, though
19:47:45 <dmwit> The python overhead was already in place, seems to be his view.
19:47:51 <jaredj> applicative: you laugh, but have you seen Max or Pure Data?
19:48:47 <Cale> I think he might be talking about disk space.
19:48:51 <applicative> jaredj, one quick look turns out to be enough. 
19:49:36 <roconnor> presumably he is refering to the haskell overhead of installing haskell?
19:49:42 <Cale> Yeah
19:49:46 <dmwit> I believe so, yeah.
19:49:51 <applicative> we need to stage some complex protest or terroristic threat so that the ghc is included in os x, windows and all linux distibutions.
19:49:52 <roconnor> that isn't so unreasonable
19:50:00 <roconnor> a little, but not so
19:50:30 <roconnor> well
19:50:34 <roconnor> I guess if it isn't packaged
19:50:46 <roconnor> dmwit: you need to make a .deb
19:50:48 <roconnor> :)
19:50:50 <jaredj> i'd say the haskell platform is quite a complex protest ;)
19:50:57 <dmwit> =)
19:51:12 <dmwit> I suppose I could, but I'd hate to have the Debian overhead... ;-)
19:51:23 <jaredj> bahahaha
19:52:51 <roconnor> :D
19:54:45 <tg_> hm. I think I've found someone even more boring than all of you serious folks - Charles Babbage
19:55:01 <tg_> Babbage once contacted the poet Alfred Tennyson in response to his poem "The Vision of Sin". Babbage wrote, "In your otherwise beautiful poem, one verse reads,
19:55:05 <tg_> Every moment dies a man,
19:55:05 <tg_> Every moment one is born.
19:55:09 <applicative> moreover, we should make the demand that when a new version of ghc is released, there has to be a new version of Windows, Ubuntu and OS X have to find new animals, etc.
19:55:09 <applicative> ...or else ...
19:55:13 <tg_> ... If this were true, the population of the world would be at a standstill. In truth, the rate of birth is slightly in excess of that of death. I would suggest [that the next version of your poem should read]:
19:55:17 <tg_> Every moment dies a man,
19:55:17 <tg_> Every moment 1 1/16 is born.
19:55:17 <tg_> Strictly speaking, the actual figure is so long I cannot get it into a line, but I believe the figure 1 1/16 will be sufficiently accurate for poetry."
19:55:20 <kmc> http://www.harkavagrant.com/index.php?id=5
19:55:36 <tg_> lol.
19:55:41 <tg_> No wonder there were only 3 men at his funeral.
19:55:55 <kmc> http://books.google.com/books?id=b7_Lz0QMBdwC&lpg=PA349&dq=babbage%20musicians&pg=PA337
19:56:32 <kmc> "The means at my command for producing the most hideously discordant noises are ample, having a considerable collection of shrill organ pipes with appropriate bellows and an indefatigable steam engine ever ready to work them whilst I might be 'taking a walk in the Park'."
19:56:42 <applicative> only three men?  but was Ada there?
19:56:42 <kmc> fight fire with fire, eh mister babbage?
19:56:49 <Makoryu> Babbage had eight kids? o_o
19:56:55 <tg_> applicative: She was a woman. I don't think they counted them, at that time.
19:57:10 <tg_> kmc: what a grumpy old bastard.
19:57:14 <SecondOrderSalad> dmwit: hmm do you know whether using GeneralizedNewtypeDeriving is okay in base?
19:57:16 <geheimdienst> would we today count a woman as a man?
19:57:22 <Makoryu> NB. "Man" once meant "human" rather than "adult male"
19:57:26 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29690#a29690
19:57:39 <dmwit> SecondOrderSalad: I do not know.
19:57:42 <SecondOrderSalad> dmwit: maybe they want to keep it extension-free for bootstrapping ghc or something...
19:57:58 <dmwit> SecondOrderSalad: If you're worried about it, it's not as if the non-derived instance is that long.
19:58:11 <dmwit> Just dispatch out to the Maybe instance.
19:58:21 <Makoryu> SecondOrderSalad: IIRC, the rule is to keep it compatible with the previous two point releases
19:58:30 <SecondOrderSalad> hurr I just deleted the handwritten one to avoid code duplication (since First wants an instance too)
19:58:43 <SecondOrderSalad> ;)
20:00:35 <SecondOrderSalad> (and actually one might want to derive almost anything for Last and First, but I guess at some point of typeclass obscurity the extra binary size outweighs the utility ;))
20:00:38 <dmwit> int80_h: Data.List seems like a good place to look.
20:01:06 <dmwit> int80_h: Also, pattern matching is a more idiomatic way to destruct tuples than fst and snd.
20:01:33 <int80_h> dmwit: thanks :)
20:02:02 <int80_h> I need work on pattern matching
20:02:06 <dmwit> int80_h: Data.List.Split will probably help a bit, too.
20:02:49 <applicative> Data.List.Split rules!
20:03:06 <dmwit> As a more minor point, I find this "[x] ++ [y] ++ [z] ++ filterPoint (zs)" stuff a little weird. It's fine, but most people would probably write this as either [x, y, z] ++ filterPoint zs or as x : y : z : filterPoint zs.
20:03:10 <SecondOrderSalad> dmwit: turns out the flag is in base.cabal, guarded by impl(ghc)
20:03:19 <SecondOrderSalad> so I should be fine if I #ifdef it for ghc
20:03:29 <dmwit> I call this minor because you're going to replace it with a concatMap and a chunk 3 anyway. =)
20:03:58 <int80_h> dmwit: yeah I appreciate feedback like that because I wrote that before I had looked at any serious code.
20:04:30 <applicative> dmwit, I was going to say the same.  In this case it looks harmless, I think, but it's a familiar point that too many ++'s can be bad.
20:04:58 <SecondOrderSalad> heck I could add the derivation for all the types in there except Endo
20:05:59 <dmwit> > let subs3 = takeWhile ((3==) . length) . map (take 3) . tails in subs3 [a, b, c, d, e] -- int80_h 
20:06:13 <dmwit> um
20:06:16 <dmwit> > "poke"
20:07:16 <roconnor>  [[a,b,c],[b,c,d],[c,d,e]]
20:07:20 <roconnor>  "poke"
20:07:40 <dmwit> thanks roconnorbot =)
20:08:27 <applicative> int80_h, you don't need the second embedded where in the definition of sortListByCoTangent
20:08:27 <applicative> how's that for deep advice
20:08:29 <lambdabot>   [[a,b,c],[b,c,d],[c,d,e]]
20:08:29 <lambdabot>   "poke"
20:08:40 <dmwit> laaaag
20:09:06 <revenantphx> when I see "binary function" does that mean a function that isn't implemented in haskell itself
20:09:10 <revenantphx> like +, -, and so on?
20:09:19 <kmc> no
20:09:20 <dmwit> Depends on the context.
20:09:24 <dmwit> It probably means an arity-2 function.
20:09:27 <kmc> "binary" meaning "two arguments"
20:09:29 <dmwit> (i.e. one that takes two arguments)
20:09:44 <int80_h> applicative: what should I do instead then?
20:09:53 <kmc> also, in GHC, (+) is implemented in Haskell for all types
20:09:55 <int80_h> applicative: make that a seperate function?
20:09:58 <dmwit> int80_h: where blocks can define many variables. =)
20:10:03 <int80_h> oooh
20:10:18 <int80_h> this channel is so useful :)
20:10:20 <revenantphx> dmwit: okay, that'd make sense
20:10:22 <kmc> you can make pure-Haskell numeric types; for example «data Natural = Zero | Successor Natural; instance Num Natural where ...»
20:11:07 <dmwit> int80_h: I basically use where blocks for only two things: local definitions that don't need a top-level name, and local definitions that need access to variables that are currently in scope but wouldn't be at the top level.
20:11:36 <dmwit> So, a nested where could make sense if it needs to access variables local to a definition within the first where block... but otherwise probably just using one block is enough.
20:11:49 <revenantphx> in any case, kadane's seems like it's just going to be ugly to implement any way I think of it with my current knowledge
20:12:23 <revenantphx> I guess at this point I'll look it up and see how it could be done.
20:13:26 <int80_h> revenantphx: I'm a n00b too, but it seems to me that implementing then refactoring is the way to go. Even if it's ugly, you'll get lot's more help.
20:13:28 <SecondOrderSalad> while we're at it, is there any good reason why Sum and Product oughtn't be Nums?
20:13:36 <revenantphx> int80_h: usually
20:14:00 <int80_h> the people who can help you, can help you better when you give them code to look at.
20:14:25 <revenantphx> hm
20:14:36 <revenantphx> I see a one line function that does it with some functions i dont know
20:14:48 <dmwit> int80_h, revenantphx: I, at least, will take you more seriously if you link to a paste.
20:15:06 <revenantphx> dmwit: ?
20:15:22 <revenantphx> I don't have a paste to link too.
20:15:30 <int80_h> I paste daily!
20:15:47 <revenantphx> I lack knowledge of the standard modules it seems
20:15:56 <revenantphx> a lot of these functions could help... (reads a bit)
20:16:43 <revenantphx> what the....
20:16:53 <kmc> revenantphx, have you used Hoogle and Hayoo?
20:16:58 <kmc> good way to search the standard modules
20:17:04 <revenantphx> hoogle, yes
20:17:47 <dmwit> :t maybe id
20:17:47 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
20:18:08 <djahandarie> :t maybe
20:18:09 <revenantphx> concatMap is convenient > >
20:18:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:18:40 <djahandarie> What happens there?
20:19:01 <djahandarie> Oh nevermind lol
20:19:04 * djahandarie sighs
20:19:13 <revenantphx> tails is also convenient..
20:19:14 <dmwit> :t maybe (id :: b -> b)
20:19:15 <lambdabot> forall b a. (a -> b -> b) -> Maybe a -> b -> b
20:19:24 <dmwit> djahandarie: Does that help?
20:19:35 <djahandarie> Yeah I got it already
20:19:41 * dmwit nods
20:19:41 <djahandarie> Just a slow day
20:20:37 <revenantphx> djahandarie: In the end I gave up TT_TT
20:20:57 <revenantphx> I looked up a solution though and I realized "wow, I don't know nearly enough of the standard modules"
20:21:53 <int80_h> @where LYAH
20:21:53 <lambdabot> http://www.learnyouahaskell.com/
20:22:14 <int80_h> revenantphx, have you checked out LYAH yet?
20:22:26 <tg_> LYAH is improving steadily
20:22:31 <revenantphx> Yes, I'm reading it at the moment, I'm on Monoids.
20:22:37 <int80_h> I can't wait to buy it
20:25:16 <SecondOrderSalad> how do I make a linebreak part of the expansion of a CPP macro?
20:25:27 <SecondOrderSalad> it's not trailing \ ;)
20:25:44 <monochrom> must you use linebreak?
20:25:47 <SecondOrderSalad> which just splits the *definition* over multiple lines
20:26:03 <SecondOrderSalad> monochrom: I could use ; but I don't know whether haddock will like that
20:26:18 <monochrom> oh, inside comments?
20:26:39 <SecondOrderSalad> no, I'm deriving functor and monad instances for identity newtypes
20:27:00 <SecondOrderSalad> (and I'd prefer haddock to see them)
20:27:09 <revenantphx> this is one way to do it I suppose
20:27:13 <revenantphx> though it's very inneficient
20:27:13 <revenantphx> http://blog.tty.nl/2009/08/30/ruby-quiz-haskell-solution-maximum-sub-array/
20:27:25 <revenantphx> That's the prettiest bruteforcing I've seen in a while though
20:27:40 <SecondOrderSalad> (GND doesn't work for identity newtypes like Sum, only for newtypes that wrap something that's already a functor/monad)
20:27:46 <SecondOrderSalad> (like Last)
20:27:59 <revenantphx> also seems like my lfold idea was the closest
20:28:11 <revenantphx> g2g
20:28:55 <monochrom> I'm sure haddock understands instance Functor Haha where { fmap = undefined; }
20:30:39 <SecondOrderSalad> but 'instance Functor Haha ... ; instance Monad Haha ...'?
20:30:59 <SecondOrderSalad> oh well, not that important I guess
20:31:21 <monochrom> instance Functor Haha where { fmap = undefined } instance Monad Haha where { return = undefined; (>>=) = undefined }
20:33:02 <jaredj> i've made a datatype with some functions that apply to it. now i want to quickcheck it. where should i write the properties and how should i cause the quickcheck to be run?
20:34:31 <applicative> int80_h, I linked some totally brainless edits earlier, but just realized I was cut off, or I think so http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29690#a29691
20:35:47 <kmc> SecondOrderSalad, your nick just gets longer and longer
20:35:49 <blackh> jaredj: If it's a real project, then I'd recommend test-framework, but if it's just a test program, then just run 'quickCheck' from ghci.
20:35:54 <kmc> and consuming more and more of my screen ;P
20:35:56 <dmwit> :t sortBy
20:35:57 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
20:36:08 <dmwit> :t sortBy . comparing
20:36:08 <blackh> jaredj: Put your properties next to the functions your testing unless you are concerned about executable bloat.
20:36:08 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
20:36:15 <SecondOrderSalad> kmc: I didn't think freenode would allow it either
20:36:21 <dmwit> :t sortBy (comparing snd) -- for example
20:36:21 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
20:36:24 <monochrom> NineteenEightFourthOrderSalad
20:36:27 <jaredj> blackh: then just don't export them?
20:37:02 <monochrom> supportsMetadataOperationsAndDataOperationsOrderSalad
20:37:09 <jaredj> blackh: ah, this test-framework appears to be what i was looking for!
20:37:30 <djahandarie> By the way, what's the deal with QuickSpec? I skimmed the paper and it looked damn cool
20:37:31 <blackh> jaredj: You could make a test suite in each module, and export that, then do them all at the top level.  test-framework is great!
20:37:34 <monochrom> SecondUncountableOrdinalSalad
20:37:58 <int80_h> applicative: they don't look brainless to me, should they?
20:38:02 <jaredj> monochrom: i think that's a bit too much dressing
20:38:08 <monochrom> haha
20:38:21 <jaredj> blackh: eeexcellent. thanks :)
20:38:31 <dmwit> int80_h: I think he means "local" rather than "brainless".
20:38:46 <tommd> blackh: any recent ARM work?
20:39:00 <dmwit> int80_h: i.e. he didn't try to understand what the program was doing and restructure it.
20:39:04 <12WABM3C2> int80_h, i just meant I'm not in a position to think through the content; it'
20:39:08 <12WABM3C2> like dmwit said
20:39:11 <jaredj> ARM work? *eyebrow*
20:39:32 <regulate> \:-\
20:39:45 * 12WABM3C2 is applicative, i'm not sure what freenode is doing to me.
20:39:46 <blackh> tommd: The only thing that's happened recently in the world of GHC for ARM is that we've had a brief chat with Simon Marlow that just amounted to "Yes, we'd like some patches."
20:40:30 <int80_h> applicative: well if you are so inclined, you can find the problem spec from RWH chpater 3 exercises.
20:40:34 <blackh> tommd: That's not quite true - IPwn has someone porting ghc-6.12.2 to embedded platforms. So when that's finished we can start sending patches to GHC.
20:40:43 <blackh> Or it might be HEAD - I forget which.
20:40:52 <jaredj> coool
20:40:54 <tommd> Either way, that would be neat
20:41:13 <int80_h> blackh: any plans for gumstick?
20:41:14 <tommd> Once the patches are public I'll play around with them.
20:41:15 <12WABM3C2> int80-h, uh oh, i'm revealing that i didn't do all the exercises in RWH; don't tell our dear teachers!
20:41:41 <int80_h> 12WABM3C2 : oh you don't need to, but it tells you what the code is supposed to be doing.
20:42:03 <blackh> int80_h: None, except that it's possible to take the current iPhone version and hack it to work on embedded Linux.
20:42:07 <blackh> If you want to do it, I can tell you how.
20:42:24 <int80_h> blackh: sure, I can tilt at windmills. Tell me how.
20:43:22 <blackh> int80_h: http://projects.haskell.org/ghc-iphone/ <-- patches are here
20:43:34 <kmc> blackh, did you mean me or someone else?
20:43:49 <kmc> i've got ghc 6.12.1 kinda-sorta targetting Android
20:44:03 <kmc> in that simple programs work and most of the libraries iPwn needs at least build
20:44:44 <blackh> kmc: Oh, yes, it's you.  I only remembered your name, not your handle.
20:45:22 <blackh> int80_h: So you just take these patches, throw out anything iPhone-specific - apply them to ghc-6.10.4.
20:46:08 <int80_h> blackh, that is effing cool.
20:46:26 <kmc> cool :)
20:46:36 <int80_h> could the embedded market be the killer app for haskell?
20:46:36 <blackh> int80_h: Then you need to get your toolchain working in qemu so hsc2hs can use it.
20:46:41 <blackh> int80_h: Then you should be away.
20:46:46 <kmc> int80_h, Debian ARM already has ghc 6.12.1 packages
20:46:56 <jaredj> :d where can i find the whole hierarchy of package names used by hackage packages?
20:46:57 <kmc> so you can compile on the device or in emulation easily
20:47:02 <int80_h> backh: you make it sound so easy, I'm zee newb. But I don't mind trying the impossible.
20:47:04 <kmc> (and slowly)
20:47:27 <blackh> int80_h: If you want ghc-6.12, talk to kmc.
20:47:39 <monochrom> "cabal init" lets you choose from a large part of the hierarchy
20:47:40 <int80_h> kmc: if DEBIAN ARM already has it, it should be ready for gumstic then right?
20:47:51 <blackh> int80_h: Actually kmc is right. Get your OS running in qemu, and build there, then just push the executables over onto your real system.
20:47:54 <kmc> int80_h, sure.  difficulty is just if you want a cross compiler
20:47:57 <blackh> Much easier
20:48:28 <kmc> i recommend building in an ARM Linux virtual machine if you can tolerate slow build times
20:48:36 <kmc> or you could get a real, fast ARM Linux device
20:48:49 <int80_h> I would be tickled pink to see it compile at all
20:49:31 <blackh> int80_h: http://blacksapphire.com/antispam/   <-- this web app is written in Haskell and running on Debian ARM on a NSLU2
20:49:41 <int80_h> hah1
20:49:43 <int80_h> !
20:50:14 <blackh> I just used the ghc that comes with Debian, but multi-threading requires extra patching which is all to be found in the iPhone patches.
20:51:06 <blackh> int80_h: I mean, the threaded RTS doesn't work on an unpatched GHC on ARM.
20:51:35 <blackh> int80_h: Also currently there is no ARM back end for GHC so it compiles via C.
20:52:45 <kmc> via-C would be quite acceptable except that it's not registerised either
20:53:11 <kmc> meaning it produces quasi-portable C, rather than the more efficient hacked up C that relies on GCC extensions and assembly post-processing by the Evil Mangler
20:53:42 <SecondOrderSalad> hmm so does the 'add a trac ticket' step on http://www.haskell.org/haskellwiki/Library_submissions apply even to trivial changes as I did?
20:53:56 <SecondOrderSalad> (adding Functor,Monad and Num instances for the stuff in Data.Monoid)
20:54:39 <lispy> SecondOrderSalad: that's an API change, so I would assume it's at least controversial even if the source code changes are tiny
20:54:50 <SecondOrderSalad> is it?
20:55:04 <SecondOrderSalad> 'addition' counts as 'change' here I guess
20:55:15 <lispy> SecondOrderSalad: Yes, only because instances are automatically imported
20:56:57 <lispy> SecondOrderSalad: I'd also say that, my assumption of controversial is a conservative assumption.  I'm sure most people will be like, "Yay, sensible instances!"
20:58:26 <lispy> SecondOrderSalad: actually, what does the Num instance look like?
20:58:27 <SecondOrderSalad> lispy: I doubt there are any other sensible instances, but I guess there might be other reasons against it (breaks libraries with orphan instances...)
20:58:36 <SecondOrderSalad> lispy: deriving(Num) ;)
20:58:57 <lispy> I didn't know Num was derivable
20:59:00 <SecondOrderSalad> (GND is already in the base.cabal file, so I'm not introducing new compiler depends)
20:59:10 <SecondOrderSalad> newtypederiving
21:00:23 <lispy> Orphan instances....yeah, I half wish we could selectively import instances
21:00:32 <lispy> But, at the same time, I see that feature as evil too
21:00:48 <SecondOrderSalad> yes
21:03:30 <SecondOrderSalad> I suggested a new declaration above that would ban, everywhere except in a specified module, orphan instantiation of a specified class or type defined in the current module
21:04:21 <SecondOrderSalad> ('external instance Error e => Monad (Either e) in Control.Monad.Error' to take a well-known orphan)
21:04:37 <SecondOrderSalad> this could be in Control.Monad and/or whatever module defined Either ;)
21:04:42 <SecondOrderSalad> *defines
21:05:38 <SecondOrderSalad> I mean it's a compromise to keep an instance orphaned, but keep someone from accidentally making a duplicate orphan
21:05:48 <SecondOrderSalad> just a random idea, don't know it it's any good -_-
21:06:05 <SecondOrderSalad> hmm or maybe ^_^
21:06:17 <SecondOrderSalad> that's not quite right either
21:10:46 <benmachine> SecondOrderSalad: wait, so the module with the orphan instance is specified in the current module? why not just, you know, put the instance there?
21:11:04 <benmachine> orphan instances tend to be used when you can't edit the original module
21:11:35 <SecondOrderSalad> benmachine: yeah, it's as a compromise for when you should just 'put the instance there' but can't for some reason ;)
21:12:07 <SecondOrderSalad> maybe the *implementation* of the instance is using a package that you don't want to depend on
21:12:14 <benmachine> maybe
21:12:21 <benmachine> I think it still wouldn't solve the problem anyway
21:12:33 <benmachine> couldn't two separate packages have internal modules with the same name?
21:12:42 <benmachine> then you could conceivably still import two distinct instances
21:12:50 <benmachine> that both satisfied the rule
21:13:27 <kmc> only with PackageQualifiedImports or separate-compilation trickery
21:13:30 <SecondOrderSalad> hmm, add the package name? but that'd get somewhat ugly
21:13:31 <kmc> PackageImports is it?
21:13:35 <SecondOrderSalad> yes
21:14:01 <benmachine> kmc: no, because instances propagate like mad
21:14:13 <benmachine> you don't need to import the modules where those instances are defined
21:14:24 <benmachine> well I guess, separate compilation trickery
21:14:40 <benmachine> personally not keen on package names in source files
21:15:03 <SecondOrderSalad> not really
21:15:31 <SecondOrderSalad> (I'm not really keen either, that is)
21:17:11 <SecondOrderSalad> maybe orphans are just a bad idea altogether ;)
21:17:34 <SecondOrderSalad> I was just trying to reduce the harm
21:17:35 <SecondOrderSalad> ;)
21:17:53 <kmc> harm reduction?
21:17:58 <kmc> sounds like some bleeding heart liberal bullshit
21:18:02 <kmc> what we need is aggressive enforcement
21:18:07 <kmc> zero tolerance policy
21:18:12 <kmc> ;)
21:18:13 <SecondOrderSalad> ^^
21:19:52 <SecondOrderSalad> benmachine: it might also be easier to get the maintainer of the file you don't have access to to add an 'external instance' declaration than add some complicated instance and be responsible for it
21:21:20 <benmachine> SecondOrderSalad: but to add the external instance declaration he has to have your names in scope
21:21:38 <benmachine> so you get all the silly dependencies anyway
21:22:18 <SecondOrderSalad> hmm, the 'Error e' in my example (generally, the whole context) could be omitted
21:22:32 <SecondOrderSalad> since the Context isn't used for overlap detection anyway
21:22:42 <benmachine> ok but what about the type itself
21:22:49 <benmachine> can't really omit that
21:22:56 <SecondOrderSalad> so it'd just be 'external instance Monad (Either e)', which would be in scope in Monad
21:24:15 <SecondOrderSalad> the type isn't defined in your module, by definition :) though 'Either' could be some third-party type, I admit
21:24:23 <SecondOrderSalad> (definition of 'orphan')
21:35:12 <nniro> >(read "a") :: Int
21:35:22 <nniro> how could I catch this?
21:35:25 <kmc> use reads
21:35:27 <kmc> :t reads
21:35:27 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:35:41 <nniro> kmc: ok thanks
21:35:48 <kmc> :t \x -> case reads x of [(v,"")] -> Just v; _ -> Nothing
21:35:49 <lambdabot> forall a. (Read a) => String -> Maybe a
21:35:50 <nniro> kmc: btw I'm using HUnit :)
21:35:56 <kmc> nniro, ^^^^ should probably be a standard library function somewhere
21:35:59 <kmc> but i don't think it is :/
21:36:01 <kmc> nniro, cool :)
21:36:50 <nniro> kmc: yeah, exchanging readability for code compression ;P
21:38:55 <nniro> kmc: I still can't imagine I did this huge brain fart when you told me to use a tuple in a case ahah
21:42:23 <nniro> kmc: are you sure there could be a String -> Maybe a    function? cause I can't find any in Text.Read
21:43:00 <copumpkin> fmap fst . listToMaybe . reads
21:43:06 <copumpkin> :t fmap fst . listToMaybe . reads
21:43:07 <lambdabot> forall a. (Read a) => String -> Maybe a
21:43:10 <kmc> copumpkin, won't reject leftover string though
21:43:14 <copumpkin> oh
21:43:22 <kmc> nniro, i gave the code for it above.  i don't think it's in the standard library, sorry to say
21:43:31 <kmc> "read" and "reads" are a dumb set of defaults
21:44:04 <SecondOrderSalad> @google readMay safe
21:44:05 <lambdabot> No Result Found.
21:44:54 <SecondOrderSalad> add double quotes around the "readMay"...
21:52:51 <ramb0> hey
21:53:35 <ramb0> I've a question, is there a way to avoid using if then else in lambda expressions without defining a new function ?
21:53:47 <kmc> sure, you can use "case" instead
21:53:59 <kmc> case x of True -> ...; False -> ...
21:53:59 <ramb0> case?
21:54:20 <ramb0> Is it a "good practice" to use if then else?
21:54:21 <kmc> this is just a tiny silly use of "case"; it's much more powerful than conditionals
21:54:22 <ulfdoz> That thingy, which fills screeens in my java.
21:54:53 <kmc> ramb0, if you're a beginner you should try to avoid "if".  usually there is a better way, using pattern matching
21:55:01 <kmc> we can help if you pastebin some code
21:55:35 <ramb0> I was answering a Stack Overflow's question, trying to write filter only using HoF 
21:55:48 <ramb0> and i wrote something like this:
21:56:14 <ramb0> filter' p xs = foldr (\x y -> if p x then (x:y) else y) [] xs
21:56:22 <kmc> yeah
21:56:29 <kmc> btw you can drop the "xs" off both sides of the equation
21:56:31 <kmc> cancels out ;)
21:57:00 <SecondOrderSalad> reads:                 _ -> Left ("Failing because this isn't really a natural number: "++x) 
21:57:03 <ramb0> yeah, I know, but it is for an answer and I try to be clear (im a noob with haskell too)
21:57:06 <SecondOrderSalad> ;)
21:57:27 <ulfdoz> I think, that is a use case for an if.
21:57:42 <kmc> yeah
21:57:48 <kmc> i'm down with "if" here
21:57:55 <ulfdoz> @src filter
21:57:55 <lambdabot> filter _ []     = []
21:57:55 <lambdabot> filter p (x:xs)
21:57:55 <lambdabot>     | p x       = x : filter p xs
21:57:55 <lambdabot>     | otherwise = filter p xs
21:58:25 <ramb0> No recursion nor comprehension lists where allowed in that question
21:58:35 <int80_h> Report: Use Of "if" Considered Harmful.
21:58:53 <c_wraith> I don't like "if" in haskell.
21:59:04 <ramb0> Can someone explain me what does this code means? (this is another implementation of filter)
21:59:06 <ramb0> filter = (\f -> (>>= (\x -> if (f x) then return x else [])))
21:59:09 <SecondOrderSalad> yeah, use a view pattern
21:59:12 <SecondOrderSalad> j/k
21:59:42 <SecondOrderSalad> foo x@(predicate -> True) = .... ;)
22:00:03 <kmc> ramb0, first of all, (>>= stuff) is an operator section, equivalent to \x -> x >>= stuff
22:00:04 <Maxdamantus> How do you usually go about building a tree or something with depth from a list input (eg, a string)? Do you make your recursive function take a list then return a tuple consisting of a tree and the rest of the list, or..?
22:00:21 <ramb0> yeah I know that, but I don't know what >>= means
22:00:22 <kmc> Maxdamantus, why return a tuple, just build the whole tree recursively and return it
22:00:31 <kmc> ramb0, (>>=) is an operator defined in the type class named "Monad"
22:00:42 <kmc> it does fairly different things depending on which particular type you use it for
22:00:52 <ramb0> Oh monads, that think That I must learn about haskell :P
22:00:58 <Maxdamantus> kmc: unless you do some complex lookahead, I can't see how to do it without the tuple
22:01:01 <kmc> e.g. sequencing IO, gluing together parsers, propagating errors, or branching nondeterminism
22:01:06 <kmc> Maxdamantus, can you elaborate on your problem?
22:01:20 <kmc> ramb0, monads aren't actually that big a deal.  they're overhyped; they're not that important in Haskell
22:01:25 <int80_h> just remember, Monads are like Burritos. You should only eat them once a week unless you want to turn into a chubby boy.
22:01:30 <kmc> just a nice API shared by a bunch of different types
22:01:52 <kmc> ramb0, in this case, you're using (>>=) with the list instance
22:01:54 <kmc> @src [] (>>=)
22:01:55 <lambdabot> xs >>= f     = concatMap f xs
22:02:15 <ramb0> oh
22:02:24 <kmc> now, explaining *why* it makes sense to set «(>>=) = flip concatMap» is a long story
22:02:27 <ramb0> why don't use concatMap instead?
22:02:30 <kmc> you could
22:02:43 <kmc> (>>=) is fewer characters ;P
22:03:00 <ramb0> In my first answer I used concatMap :P. 
22:03:08 <kmc> so it just boils down to:  filter f = concatMap (\x -> if (f x) then return x else [])
22:03:11 <ramb0> But it is weird and unclear :S
22:03:26 <kmc> there's other things you can do along those lines
22:03:28 <ramb0> wow wow, whats return x?
22:03:39 <kmc> return is another function defined in the "Monad" type class
22:03:52 <kmc> in fact the only other "important" function apart from (>>=)
22:03:52 <ramb0> Oh :P i guess it makes [x] 
22:03:55 <kmc> yes
22:03:57 <kmc> @src [] return
22:03:58 <lambdabot> return x    = [x]
22:04:05 <ramb0> That was exactly my first answer xD
22:04:16 <kmc> someone is showing off that they understand the list monad :)
22:04:36 <ramb0> hahaha
22:05:03 <ramb0> Well, thanks for all KMC, im going to sleep right now :)
22:05:12 <kmc> :t let filter p = catMaybes . map (\x -> guard (p x) >> Just x) in filter
22:05:13 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:05:24 <kmc> @pl \p -> catMaybes . map (\x -> guard (p x) >> Just x)
22:05:24 <lambdabot> (catMaybes .) . map . (`ap` Just) . (((>>) . guard) .)
22:05:28 <kmc> there's your solution
22:05:32 <kmc> filter = (catMaybes .) . map . (`ap` Just) . (((>>) . guard) .)
22:05:34 <kmc> cherish it
22:05:41 <joeytwiddle> Maxdamantus: rather than past the rest of the string back, perhaps you can call a function to handle the rest
22:05:47 <kmc> no λ at all
22:06:11 <Maxdamantus> "bbv1v2v3" .. build (h:t) = case h of 'b' -> let (a,b) = build t; (c,d) = build b in (Branch a c, d); 'v' -> (Leaf $ head t, tail t)
22:06:14 <nniro> can we use guards or such in an instance declaration? I can't recall
22:06:35 <Maxdamantus> Dunno if that code makes sense, but in there it uses tuples of the tree, and the "rest"
22:06:42 <Maxdamantus> which seems somewhat messy
22:06:48 <kmc> nniro, sure.  the body of "instance" is a list of bindings like any other
22:06:49 * Maxdamantus tests
22:07:01 <kmc> hmm the use of head / tail there is fishy Maxdamantus
22:07:17 <kmc> perhaps 'v' -> case t of (t':ts) -> (Leaf t', ts)
22:07:32 <kmc> at least then the missing case is explicit
22:07:50 <kmc> anyway yeah it is useful to return a tuple of (value so far, remaining string) when parsing
22:07:57 <kmc> or you can call a continuation function with the same two values
22:08:25 <ramb0> You are crazy kmc, your solution is very hard to read >.<
22:08:30 <SecondOrderSalad> isn't there a dependently typed Data.Map? using a GADT as parameter
22:08:46 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29692#a29692 versus http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29693#a29693
22:09:01 <SecondOrderSalad> insert :: MyKey a -> a -> Map MyKey -> Map MyKey
22:09:06 <SecondOrderSalad> o_O
22:09:14 <kmc> Maxdamantus, those are two parsers for Lisp-style s-expressions
22:09:28 <kmc> «(foo (bar baz))» kind of stuff
22:09:33 <SecondOrderSalad> equivalent to an assoclist [exists a. (MyKey a, a)]
22:09:44 <SecondOrderSalad> but faster :p
22:09:50 <Maxdamantus> http://codepad.org/Oq9z88cS
22:10:04 <Maxdamantus> So apparently it does make sense.
22:10:07 <ski> @type let filter p = concatMap (\x -> guard (p x) >> return x) in filter
22:10:07 <kmc> is MyKey here supposed to be a type family?
22:10:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:10:10 <Maxdamantus> But seems odd.
22:10:11 <nniro> kmc: ahhh I didn't know we could overload functions inside an instance declaration
22:10:11 <ski> @type let filter p xs = [x | x <- xs , p x] in filter
22:10:12 <lambdabot> forall t. (t -> Bool) -> [t] -> [t]
22:10:15 <SecondOrderSalad> kmc: a GADT
22:10:19 <kmc> nniro, what else are they for?
22:10:33 <SecondOrderSalad> so you can actually extract the values too ;)
22:10:42 <SecondOrderSalad> (by a pattern match)
22:10:49 <nniro> kmc: well I thought I could overload only once
22:10:49 <kmc> nniro, an "instance" definition gives values for each of the names declared in a corresponding "class" definition
22:11:09 <kmc> (those values are usually but not always functions)
22:11:15 <kmc> nniro, i'm not sure what you mean
22:11:19 <ski> SecondOrderSalad : heh, you're also looking for `[exists i. (k i,v i)]' ? 
22:11:19 <nniro> kmc: yeah, makes sense... but documentation doesn't really make this super clear ;)
22:11:21 <ski> :)
22:11:31 <kmc> using guards and multiple equations isn't overloading
22:11:41 <kmc> it's just a way of defining a function
22:11:43 <SecondOrderSalad> MyKey :: (* -> *) where { Columns :: MyKey Int, InputFile :: MyKey FilePath }
22:11:43 <kmc> one function
22:12:01 <SecondOrderSalad> ski: :D
22:12:10 <kmc> what's the point of this SecondOrderSalad?
22:12:24 <SecondOrderSalad> ski: yes, but with linear-logarithmic lookup etc
22:12:33 <SecondOrderSalad> err, logarithmic lookup, in fact ;)
22:12:44 <ski> SecondOrderSalad : a month ago, cocon was looking for this, and a few days ago, it appeared int80_h wanted something like this .. and now you
22:12:48 <SecondOrderSalad> kmc: the overengineering of commandline options parsing
22:13:30 <ski> SecondOrderSalad : (re complexity) yeah, obviously
22:13:40 <SecondOrderSalad> ski: ah, I only noticed the 'k' and 'v' now ;)
22:14:15 <SecondOrderSalad> (the suggestive names I mean)
22:14:17 <ski> SecondOrderSalad : i defined `lookup1 :: Eq1 k => Map1 k v -> (k i -> Maybe (v i))' yesteryesterday
22:14:30 <SecondOrderSalad> don't you need Ord?
22:14:41 <SecondOrderSalad> (Ord1)
22:14:43 <ski> with `Map1 k v' being `[exists i. (k i,v i)]'
22:14:48 <SecondOrderSalad> ah
22:14:57 <ski> yeah, for a tree, one would probably need that
22:15:24 <ski>   class Eq1 f
22:15:26 <ski>     where
22:15:27 <ski>     eq1 :: f i0 -> f i1 -> Maybe (Equal i0 i1)
22:15:30 <ski> was the idea
22:15:54 <SecondOrderSalad> guess one can reduce it to Data.Map with unsafeCoerce ;)
22:16:03 <SecondOrderSalad> (I don't want to rewrite the whole tree logic)
22:16:23 <ski> for `Ord1' i suppose we'd have `compare1 :: Ord1 f => f i0 -> f i1 -> Either Bool (Equal i0 i1)'
22:18:03 <Maxdamantus> Actually, when I think about it, the C standard library sometimes does that sort of tuple thing.
22:18:05 <SecondOrderSalad> (not sure if it can be done without a typeable constraint even with unsafeCoerce internally)
22:18:54 <SecondOrderSalad> (the reusing of Data.Map, that is -- no unsafeCoerce would be needed if you rewrote it from scratch)
22:19:47 <ski> Maxdamantus : that code looks like it is screaming "state monad"
22:20:14 <Maxdamantus> ski: ah.
22:20:17 * Maxdamantus searches
22:20:20 <SecondOrderSalad> ski: why the 'v' btw?
22:20:41 <ski> SecondOrderSalad : why not ?
22:20:42 <SecondOrderSalad> rather than just [exists i. (k i, i)]
22:21:18 <SecondOrderSalad> I think you can always relocate the v into the definition of the gadt, or maybe not
22:23:00 <ski> SecondOrderSalad : e.g. in <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29614>, i suggested `loaders :: Map1 ProgramName ((->) [String])', where `data ProgramName :: * -> * where PNStudents :: ProgramName Students; PNCosts :: ProgramName ActivityCosts; PNActivities :: ProgramName StudentActivities'
22:23:20 <ski> SecondOrderSalad : probably you can do that, but it isn't always convenient to do so
22:23:36 <SecondOrderSalad> yeah, I don't have a good reason why not
22:23:54 <ski> (say e.g. you want to use keys in several maps, with different types of things associated with them)
22:25:08 <ski> so i think the "obvious generalization" `Map1 (k :: * -> *) (v :: * -> *) :: *' from `Map (k :: *) (v :: *) :: *' is reasonable
22:25:42 <rschnck> If I can reverse the order of the digits of a two-digit integer like so: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29694#a29694
22:25:54 <rschnck> How would I go about doing that for any number of digits?
22:26:11 <kmc> rschnck, you were asking about this a while ago
22:26:14 <rschnck> (sorry that I've asked this before today, haven't gotten a chance to work on it)
22:26:21 <rschnck> kmc: ...and you beat me to it :P
22:26:23 <kmc> i suggested, as a first step, writing a function «digits :: Int -> [Int]»
22:26:31 <SecondOrderSalad> (k i, v i) == (k,v)(i) == (v^T k, id)(i) == (v^T k i, i)
22:26:32 <kmc> did you make any progress on that?
22:26:34 <SecondOrderSalad> ;))
22:26:35 <rschnck> Why would I be outputting a set?
22:26:40 <kmc> ?
22:26:48 <rschnck> [Int] vs. [Int]
22:26:49 <Heffalump> [Int] is a list, not a set
22:26:56 <sdeboy1> anyone interested in trying out an open source log analysis UI?  Much better than viewing the logs in a text editor or console.  Screenshot here (along w/tarball & Mac DMG in that same folder): http://people.apache.org/~sdeboy/chainsaw-screenshot.png
22:26:57 <kmc> [Int] is a list of Int
22:26:59 <ski> (SecondOrderSalad : in a dependently typed language like Agda2, we'd probably have `Map1 : {A : Set} -> (K : A -> Set) -> (V : A -> Set) -> Set')
22:27:06 <SecondOrderSalad> ski: ISTR something about this actually making sense with left kan extensions ;)
22:27:22 <kmc> rschnck, the digits of an integer are a list of integers between 0 and 9
22:27:22 <rschnck> So I'd output some list, and then use that list to get the final integer?
22:27:22 <SecondOrderSalad> (not sure if it really was this)
22:27:23 <kmc> e.g.
22:27:28 <ski> (SecondOrderSalad : so, it makes sense, i think, not to couple the index type too closely with the value type)
22:27:29 <kmc> digits 1234 = [4,3,2,1]
22:27:37 <kmc> (in reverse order because it's easier to code that way)
22:27:48 <kmc> rschnck, i gave you a skeleton for writing this recursive function, did you try it out?
22:27:56 <ski> SecondOrderSalad : could be, i don't know. .. we should ask edwardk :)
22:28:05 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29688
22:28:07 <Heffalump> sdeboy1: does that have anything to do with Haskell?
22:28:09 <rschnck> kmc: I couldn't get too far :P
22:28:14 <kmc> ok
22:28:23 <kmc> well let's break it down
22:28:25 <sdeboy1> not really, just thought you might find it helpful..
22:28:27 <kmc> if n < 10, what are the digits of n?
22:28:33 <kmc> (assume n >= 0)
22:28:41 <rschnck> Well then there's no modification necessary since we have a single-digit integer.
22:28:44 <rschnck> So that makes sense.
22:28:44 <kmc> no
22:28:48 <rschnck> Oh :<
22:28:49 <kmc> because an integer is not a list of integers
22:28:53 <kmc> you have to return a list
22:29:05 <kmc> and don't think in terms of modification; think in terms of input / output pairs
22:29:07 <rschnck> n < 10 = [n]?
22:29:10 <kmc> yes
22:29:17 <kmc> digits n | n < 10 = [n]
22:29:28 <kmc> okay, now what about the "otherwise" part?
22:29:32 <Heffalump> sdeboy1: some off-topic chatter from regular participants is generally ok, but to me it looks like you're just spamming.
22:29:50 <rschnck> kmc: We need to define some general case that works with an integer of any length
22:29:55 <rschnck> Which I have no idea how to do 
22:30:00 <kmc> rschnck, but you can use "digits" recursively
22:30:06 <kmc> how would you get just the *last* digit of the number n?
22:30:53 <int80_h> q
22:31:10 <int80_h> ski: I partially got what you just said. Are you saying my code should be using a State Monad?
22:31:14 <SecondOrderSalad> (the ^T was playing on the jokular origin of the word 'adjoint functors' here... since their definining property syntactically resembles that of adjoint matrices/adjoint operators)
22:31:20 <rschnck> kmc: Erm....using mod and div?
22:31:29 <ski> int80_h : no, that was a comment to Maxdamantus
22:31:33 <int80_h> damn
22:31:41 <int80_h> oh well.
22:31:52 <int80_h> one day
22:32:21 * ski hasn't seen any more code from int80_h whan the <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29580#a29614> one
22:32:27 <ski> s/whan/than/
22:32:28 <kmc> rschnck, sure
22:32:34 <kmc> well you only need mod for the last digit
22:32:36 <SecondOrderSalad> ( <Ax,By> = <B^T A x, y>)
22:32:37 <rschnck> kmc: But doesn't that get ferociously complicated?
22:32:46 <kmc> rschnck, no
22:32:50 <kmc> > 12345 `mod` 10
22:32:50 <lambdabot>   5
22:32:54 <kmc> ^^^^ the last digit
22:32:55 <kmc> > 12345 `div` 10
22:32:56 <lambdabot>   1234
22:32:59 <rschnck> Oh, right
22:33:01 <kmc> ^^^^ an int with the rest of the digits
22:33:04 <rschnck> We're going right to left
22:33:07 <rschnck> I was doing left to right
22:33:08 <kmc> now, can you put that together with a recursive call to "digits"
22:33:27 <rschnck> Okay, that makes sense
22:33:29 <rschnck> Let me try.
22:33:30 <rschnck> Thanks!
22:33:33 <kmc> no problem :)
22:34:00 <sdeboy1> does Haskell have a log analysis tool that's open source & free?  Do Haskell developers use logging to track down problems in their programs?  Well, I'll move along..not selling anything, but yeah, advertising
22:34:35 <ski> > 12345 `divMod` 10
22:34:36 <lambdabot>   (1234,5)
22:36:02 <mm_freak> sdeboy1: interestingly haskell programs, which pass the compiler, seldomly fail
22:36:21 <mm_freak> but to answer your question, i do log, but i don't have any log analyzers
22:37:06 * SecondOrderSalad uses ccze ... it's meant to highlight syslogs but will highlight almost anything you throw at it :D
22:37:33 <rschnck> kmc: Okay, but how do I output it to a list..if that makes sense? I have n `mod` 10 reverseDigits (n `div` 10) 
22:37:39 <kmc> Haskell programs which pass the compiler seldom fail except by attempting to consume all your RAM ;P
22:37:45 <SecondOrderSalad> (it still highlights important words like 'fail', 'error', 'unable' etc) 
22:37:51 <rschnck> So if n = 12345 and I do n `mod` 10, I get 5. how do I "store" that 5?
22:38:20 <kmc> rschnck, you need to build a list whose first element is from one function call, and whose tail (rest of the elements) is from another call
22:38:24 <kmc> do you know the operator to do that?
22:38:42 <rschnck> I think there was something about tails/heads in the litle haskell primer I got
22:38:43 <rschnck> Let me check
22:39:15 <rschnck> Nevermind.
22:39:24 <rschnck> I should probably buy a Haskell book. Is the O'Reilly one good?
22:39:39 <ski> Maxdamantus : btw, `putStrLn . show = print'
22:39:42 <kmc> Real World Haskell is good
22:39:44 <kmc> also free onine
22:39:46 <kmc> online*
22:39:52 <kmc> LYAH is also free online, and coming out in print soon
22:40:11 <rschnck> Oh, brilliant
22:40:15 <ski> rschnck : store `5' where ?
22:40:32 <kmc> at the head of a list
22:40:44 <rschnck> Yes, and with the others following
22:40:52 <ski> just use cons ?
22:40:53 <rschnck> so there's a head/tail function?
22:41:01 <kmc> rschnck, the opposite
22:41:02 <ski> > 5 : [4,3,2,1]
22:41:03 <lambdabot>   [5,4,3,2,1]
22:41:15 <kmc> we were getting there ;)
22:41:19 <kmc> this operator (:)
22:41:22 <kmc> has type a -> [a] -> [a]
22:41:33 <kmc> and builds a list out of a head and a tail
22:41:34 <kmc> makes sense?
22:41:47 <rschnck> so it takes 5 --> [5] --> [5,4,3,2,1]?
22:42:02 <kmc> it's important to know how the types fit together
22:42:06 <kmc> no, like ski demonstrated
22:42:18 <kmc> it will take arguments 5 and [4,3,2,1] and return [5,4,3,2,1]
22:42:19 <rschnck> What's the penultimate [a] for?
22:42:19 <kmc> or e.g.
22:42:24 <rschnck> oh
22:42:27 <rschnck> Okay, that makes sense
22:42:28 <rschnck> So it's
22:42:31 <kmc> > "foo" : ["bar", "baz"]
22:42:32 <lambdabot>   ["foo","bar","baz"]
22:42:35 <kmc> in fact
22:42:36 <rschnck> 5 --> [4,3,2,1] -> [5,4,3,2,1]?
22:42:43 <kmc> this syntax [a,b,c] is just sugar for a : b : c : []
22:42:48 * ski . o O ( `let head foo = 5; tail foo = [4,3,2,1] in foo' )
22:42:55 <kmc> ski, :O
22:43:07 <ski> (obviously that doesn't "work" :)
22:43:12 <kmc> view patterns done right :D
22:43:23 <kmc> rschnck, so you see how (:) works?
22:43:30 <rschnck> kmc: Did I get it right?
22:43:32 <rschnck> With the last bit?
22:43:40 <kmc> well i'm not sure what your syntax is with the --> and -> and so forth
22:43:46 <rschnck> Oh, sorry
22:43:46 <kmc> but the idea is it's a function of two arguments
22:43:48 <rschnck> --> = ->
22:43:48 <kmc> call them x and xs
22:43:52 <ski> rschnck : it is unclear what you really mean by 5 --> [4,3,2,1] -> [5,4,3,2,1]'
22:44:05 <kmc> and it returns the list whose head is x and whose tail is xs
22:44:08 <rschnck> Well, wait
22:44:12 <rschnck> What does a : b do?
22:44:20 <kmc> returns the list whose head is a and whose tail is b
22:44:33 <kmc> actually, in Haskell we don't ask so much what things *do*.  we ask what they *are*
22:44:41 <kmc> (a:b) *is* the list whose head is a and whose tail is b
22:44:54 <kmc> the sequence of steps by which that is accomplished is usually irrelevant
22:44:58 <rschnck> Okay. Then [a,b,c] is a list whose head is a and whose tail is b, c
22:44:59 <ski> > let x :: Int; x = 5; xs :: [Int]; xs = [4,3,2,1]  in  (x : xs) :: [Int]
22:44:59 <rschnck> Right?
22:45:00 <lambdabot>   [5,4,3,2,1]
22:45:02 <kmc> the idea being to program by describing the result you want, rather than how to get there
22:45:09 <kmc> rschnck, correct
22:45:18 <kmc> [a,b,c] = a : b : c : []
22:45:22 <rschnck> Then why do we need a : b : c : [] instead of a : b : c?
22:45:26 <kmc> the [,,] notation is just syntactic sugar
22:45:34 <kmc> rschnck, look at the type of (:)
22:45:35 <kmc> :t (:)
22:45:36 <lambdabot> forall a. a -> [a] -> [a]
22:45:39 <kmc> a -> [a] -> [a]
22:45:43 <ski> rschnck : `a : b : c : []' really means `a : (b : (c : []))'
22:45:46 <kmc> the right hand side has to be another list, not a single element
22:45:51 <kmc> [x] = x : []
22:45:53 <ski> rschnck : the right argument to every `:' has to be a list
22:46:02 <kmc> if you had just [x] = x then you would have an infinite type
22:46:16 <ski> > False : True
22:46:17 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
22:46:18 <lambdabot>         against inferred typ...
22:46:22 <ski> > False : True : []
22:46:23 <lambdabot>   [False,True]
22:46:45 <rschnck> Wait, if the right side has to be antoher list
22:46:52 <rschnck> Then how does a : b work
22:46:56 <rschnck> Jesus I feel like an idiot
22:46:58 <kmc> if you write (a : b) then b is a list
22:47:01 <ski> rschnck : you can think of every list as built up, starting from the empty list, adding elements at the front with `:'
22:47:02 <kmc> by definition
22:47:12 <rschnck> Then if you write a : b : c then c is a list.
22:47:19 <kmc> rschnck, yes
22:47:22 <ski> (rschnck : though, because of laziness, the computation will happen in the opposite order .. which even allows infinite lists)
22:47:23 <rschnck> So if c is a list
22:47:25 <kmc> c has type [t] where a and b have type t
22:47:29 <rschnck> why do we need []?
22:47:41 <kmc> rschnck, i mean if you want a list of three things specifically
22:47:43 <kmc> how do you write it
22:47:47 <rschnck> ski: That makes a ltitle more sense.
22:47:50 <kmc> without using the [,,,] notation
22:48:09 <rschnck> Ah.
22:48:11 <kmc> call your things x,y,z (since we haven't used them before)
22:48:18 <rschnck> So we're considering a, b, c to sort of be elements of some list
22:48:21 <kmc> if you wrote (x : y : z) then z has a different type from a,b
22:48:23 <rschnck> And thus they need some list to go into
22:48:37 <kmc> and it's not necessarily a list of three elements -- it's a list of two elements plus however many are in z
22:48:44 <rschnck> Okay
22:48:52 <kmc> if you want to build a list of exactly the elements x, y, z, you have to build it starting on the empty list
22:48:59 <rschnck> So if I had a : b : [] I'm saying a,b are some elements of a list, right?
22:49:14 <rschnck> and if I have a : b I'm saying a is an element of the list b?
22:49:17 <kmc> no
22:49:20 <rschnck> Damnit :<
22:49:27 <kmc> "a is an element of the list b" is like a property you're saying is true
22:49:30 <kmc> (a : b) doesn't stand for a property
22:49:32 <kmc> it's an expression
22:49:34 <kmc> it stands for a value
22:49:41 <kmc> (a : b) is a list
22:49:46 <ski> rschnck : if you're saying `a : b', you're saying that the *type* of `a' is the same as the type of the elements of the list `b'
22:49:46 <kmc> the first element of that list is a
22:49:53 <kmc> the rest of its elements are the elements of b
22:50:04 <ski> > let x = "foo"; y = "bar"; z = ["hello","there"] in  x : y : z
22:50:04 <lambdabot>   ["foo","bar","hello","there"]
22:50:07 <rschnck> ski: kmc Ahhh
22:50:12 <rschnck> Okay.
22:50:17 <kmc> rschnck, it's a bit of a detour, but SICP (http://mitpress.mit.edu/sicp/) is a fantastic intro CS book using Scheme.  these sorts of linked lists made of "cons cells" are the bread and butter of scheme
22:50:40 <rschnck> So then if x = 1; y = "bar"; z =["hello","there"] in x : y :z wouldn't work.
22:50:41 <kmc> and by "intro CS" i mean suitable for college freshman yet will teach you more actual computer science than four years at a generic JavaSchool
22:50:43 <ski> (SICP even has videos !)
22:50:46 <rschnck> Because 1 is not the same type a bar?
22:50:53 <kmc> right
22:50:57 <kmc> all the elements of a list must have the same type
22:51:02 <kmc> because the list type is just written [t]
22:51:12 <kmc> there's no room to specify [s sometimes, t other times]
22:51:22 <rschnck> kmc: I'll look into it, time-allowing.
22:52:46 <rschnck> So in the case of a : b : c : [] we're saying that the type of the elements in list a is the same as that of b is the same as that of c, is the same of that as []?
22:52:54 <rschnck> Which is sort of confusing and sounds wrong
22:53:24 <ski> no, the type of `a' is the same as the type of `b' is the same as the type of `c' is the same as the type of the *elements* of the list `[]'
22:53:26 <kmc> the elements of [] have any type you want
22:53:35 <rschnck> Oh!
22:53:44 <kmc> rschnck, remember that «a : b : c : []» is «a : (b : (c : []))»
22:53:54 <kmc> a has the same type as the elements of «b : (c : [])»
22:53:58 <rschnck> So by saying that c is the same type as the elements of []
22:54:01 <kmc> b has the same type as the elements of «c : []»
22:54:06 <kmc> c has the same type as the elements of []
22:54:06 <rschnck> We establish that a, b, c can exist as elements of some list?
22:54:14 <kmc> the elements of [] have any type you want
22:54:19 <kmc> (because there aren't any of them)
22:54:46 <rschnck> Right, but a, b, c can only be grouped into the list of they're all of the same type
22:54:49 <rschnck> Right?
22:54:50 <kmc> yeah
22:54:53 <evant_> Indeed, my empty list of strings is equal to my empty list of ints
22:54:56 <kmc> the elements of a list must all have the same type
22:55:00 <evant_> Pretty cool!
22:55:04 <kmc> evant_, not by (==) they aren't
22:55:06 <rschnck> Okay.
22:55:12 <kmc> > ([] :: [Int]) == ([] :: [String])
22:55:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
22:55:14 <lambdabot>         against inferred type ...
22:55:16 <evant_> By pattern match they are ;D
22:55:45 <rschnck> So how would I go about applying that to this digits thing
22:55:51 <kmc> rschnck, well, you need to build a list
22:55:55 <ski> evant_(,kmc) : actually, the question is ill-typed, since the two expressions have different types, you can't form the question of whehter they yield the same value or not
22:55:56 <kmc> you know what the first element of that list is
22:56:03 <kmc> and you know what the list of the rest of the elements are
22:56:04 <rschnck> [n]
22:56:09 <rschnck> Well, [n] is a list
22:56:13 <rschnck> Can a list be an element?
22:56:19 <rschnck> Yes, right?
22:56:23 <evant_> As in, can you have a list of lists?
22:56:23 <kmc> sure, you can have lists of lists, but you're getting sidetracked
22:56:29 <kmc> we are in the case n >= 10
22:56:40 <kmc> what's the last digit of n?
22:56:48 <ski> you want a list of digits, not a list of lists of whatever
22:57:02 <rschnck> n 'mod' 10?
22:57:05 <kmc> right
22:57:10 <kmc> and that's the first element of our list-of-digits
22:57:15 <rschnck> Right.
22:57:16 <kmc> because we're going in reverse order
22:57:24 <kmc> now, how do we get the list of the *rest* of the digits of n?
22:57:35 <kmc> if only we had a function to get the digits of a number ;)
22:57:44 <rschnck> We apply it recursively to n `div` 10?
22:57:48 <kmc> yes
22:57:57 <rschnck> Okay, so I have that
22:57:57 <kmc> and now you need to build a list out of these two pieces
22:58:01 <rschnck> But I'm still confused how to build a list
22:58:02 <Jafet> > let f :: String -> Int; f [] = 0; f _ = 1 in f ([]::[Int]) -- evant
22:58:03 <rschnck> Right.
22:58:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
22:58:03 <lambdabot>         against inferred type...
22:58:07 <kmc> rschnck, by using (:)
22:58:11 <kmc> x : y
22:58:12 <kmc> builds a list
22:58:14 <kmc> whose first element is x
22:58:20 <kmc> and whose rest of elements are y
22:58:30 <kmc> what's your first element?
22:58:44 <rschnck> So I'll have n `mod` 10 : reverseDigits ( `div` 10) : []?
22:58:53 <rschnck> Oops, not sure : [] is necessary
22:59:15 <rschnck> And...it's still wrong regardless
22:59:16 <ski> actually, adding that is wrong :)
22:59:29 <rschnck> kmc: first element is n`mod` 10
22:59:29 <ski>   n `mod` 10  will be a single digit
22:59:40 <rschnck> Needs brackets?
22:59:44 <rschnck> Well, parens.
22:59:58 <ski>   reverseDigits (n `div` 10)  will be a list of digits
23:00:00 <mm_freak> kmc: that's not a problem
23:00:07 <mm_freak> you just need an infinite amount of RAM
23:00:11 <mm_freak> lazy RAM or something =)
23:00:15 <kmc> assume a spherical computer of infinite density
23:00:27 <kmc> well you can run a VM that has a trust fund
23:00:31 <kmc> and if it runs out of RAM
23:00:37 <kmc> it waits until it's accrued enough interest
23:00:40 <kmc> to buy another EC2 instance
23:00:56 <rschnck> ski: So if it's a list of digits, I need to somehow have it add to a list as it goes through its recursive course?
23:01:06 <kfish> trustedVM :: Interest -> Instance
23:01:06 <Jafet> That gives a whole new meaning to "blocking on I/O"
23:01:15 <kmc> rschnck, you've said everything you need to solve this problem
23:01:18 <ski> rschnck : take the specific case where  n  is  12345
23:01:24 <kmc> (x : xs) is a list specified in terms of head and tail
23:01:28 <ski> rschnck : what is  n `mod` 10  then ?
23:01:32 <kmc> you said what the head of the list you're producing is
23:01:35 <rschnck> ski: 5
23:01:35 <kmc> you said what its tail is
23:01:49 <rschnck> kmc: Can't quite get over that last hurdle :P
23:02:00 <rschnck> Let me try considering 12345
23:02:01 <kmc> the head is (n `mod` 10)
23:02:02 <ski> rschnck : and what is  reverseDigits (n `div` 10)  *meant* to become ?
23:02:07 <kmc> the tail is (reverseDigits (n `div` 10))
23:02:10 <kmc> you had that a second ago
23:02:16 <rschnck> ski: [4, 3, 2, 1]
23:03:08 <ski> rschnck : yea, so then you've got `5' and `[4,3,2,1]' .. what is the answer you want to return for the current `reverseDigits 12345' call .. and how to you compute that answer, by combining the things you've got ?
23:03:54 <kmc> rschnck, out of curiosity, what sort of programming background do you have?
23:04:03 <rschnck> kmc: Oh, zero
23:04:09 <kmc> ah
23:04:10 <rschnck> kmc: Literally my second day using any language
23:04:12 <ski> good :)
23:04:16 <kmc> that's probably better
23:04:25 <kmc> people with heavy background in a mainstream language tend to stumble a lot
23:04:35 <kmc> because Haskell is so different
23:05:09 <rschnck> kmc: I'm stumbling without a background. How ominous.
23:05:10 <kmc> rschnck, what kind of learning materials do you have?
23:05:17 <rschnck> kmc: a 10-page PDF :P
23:05:21 <ski> rschnck : anyway, maybe it would be good to review what code you have, atm
23:05:30 <ski>   reverseDigits n
23:05:30 <rschnck> The course isn't a Haskell course, our prof just wants us to know it to get through some theory
23:05:40 <ski>     | n < 10    = [n]
23:05:42 <kmc> yeah, it's good for that :)
23:05:52 <rschnck> I really like it though, so I thought I might just persue it
23:05:57 <rschnck> Anyway, back to the problem
23:05:58 <ski>     | otherwise = ..(n `mod` 10)..(reverseDigits (n `div` 10))..
23:06:28 <rschnck> ski: It works
23:06:34 <rschnck> ski: I forgot the "=" after otherwise =/
23:06:41 <ski> rschnck : which code works ? :)
23:06:56 <rschnck> ski: it reverses my digits D:
23:07:09 <ski> "it" being exactly which code ?
23:07:22 <rschnck> reverseDigits :: Int -> [Int]
23:07:23 <rschnck> reverseDigits n | n < 10 = [n] | otherwise= (n `mod` 10) : (reverseDigits (n `div` 10))
23:07:35 <ski> yeah, that looks good
23:07:40 <kmc> rschnck, note that i wasn't proposing that this is the solution to your problem
23:07:44 <kmc> your problem has type Int -> Int right?
23:07:46 <rschnck> Yes
23:07:48 <kmc> this is one building block you need
23:07:50 <rschnck> So can't I just merge it?
23:07:53 <kmc> (at least the way i propose)
23:08:19 <kmc> rschnck, how about next you write a function which does the inverse of the one you just wrote
23:08:20 <kmc> that is
23:08:29 <kmc> [4,3,2,1] ---> 1234
23:08:40 <rschnck> Okay, let me try
23:08:53 <ski>   digitsReverse :: [Int] -> Int  -- :)
23:09:01 <rschnck> You stole my function name :<
23:09:06 <rschnck> I totally wrote that xD
23:09:14 * ski grins
23:09:20 <kmc> haha
23:09:50 <kmc> rschnck, once you have the two pieces, you can verify that they're inverses
23:10:27 <rschnck> Wait, do I treat my input like so: digitsReverse [n] or like digitsReverse n?
23:10:39 <kmc> in fact, you can import Test.QuickCheck, and then type "quickCheck (\n -> n == digitsReverse (reverseDigits n))", and it will do some automated testing for you
23:10:52 <kmc> rschnck, [n] is a pattern which matches only lists with one element
23:10:57 <kmc> i think you want two cases:
23:11:00 <kmc> digitsReverse [] = ...
23:11:04 <kmc> digitsReverse (x:xs) = ...
23:11:07 <ski> rschnck : well, the input to `digitsReverse' is going to be a list of digits
23:11:30 <rschnck> kmc: The first one confuses me a bit
23:11:32 <kmc> remember how, above, we built lists using [] and (:)?  it turns out that *every* list can be decomposed this way
23:11:48 <kmc> rschnck, because it has no digits?
23:11:51 <rschnck> Yep
23:12:04 <rschnck> How would an input into the first one look?
23:12:09 <kmc> digitsReverse []
23:12:23 <kmc> to call the function "f" with the argument "[]" you write "f []"
23:12:53 <rschnck> So in the case of digitsReverse [] you're asking it to take an empty set and turn it into an integer, which isn't possible
23:12:58 <rschnck> So you'd want a blank output?
23:13:01 <rschnck> or a False output?
23:13:04 <kmc> not a set
23:13:05 <kmc> a list
23:13:07 <rschnck> Sorry
23:13:08 <rschnck> A list
23:13:11 <kmc> and why isn't it possible?
23:13:12 <kmc> you're the boss
23:13:14 <kmc> you're writing the code
23:13:22 <kmc> you get to say which integer corresponds to the empty list
23:13:26 <kmc> if you write
23:13:29 <rschnck> Oh.
23:13:29 <kmc> digitsReverse [] = 7
23:13:33 <kmc> then so it is
23:13:33 <rschnck> Neat!
23:13:42 <kmc> yeah
23:13:45 <shachaf> @faq Can Haskell make you the boss?
23:13:45 <kmc> programming is pretty cool :)
23:13:45 <lambdabot> The answer is: Yes! Haskell can do that.
23:13:46 <rschnck> So I could say = no_integer?
23:13:51 <kmc> what is "no_integer"?
23:13:51 <ski> however .. some choices of numbers to return can be more natural than others
23:14:03 <rschnck> Some string?
23:14:08 <kmc> you can't return a string
23:14:10 <kmc> you have to return an Int
23:14:11 <rschnck> Oh
23:14:12 <rschnck> IOnly int
23:14:13 <kmc> the type signature says so
23:14:15 <kmc> [Int] -> Int
23:14:18 <rschnck> Right.
23:14:23 <kmc> as you might guess, the other case is going to be recursive
23:14:29 <kmc> maybe if you write that one first
23:14:31 <rschnck> Yeah : (
23:14:35 <kmc> then you will see which is the natural value for the "base case"
23:14:37 * hackagebot haddock 2.8.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.8.1 (DavidWaern)
23:14:41 <kmc> it's not 7 ;)
23:14:45 <rschnck> It's 0/
23:14:46 <rschnck> ?
23:14:48 <kmc> yes
23:14:49 <kmc> why?
23:15:46 <rschnck> Bleh, not sure. Because in reverseDigits if n = 0, you'd get [0]
23:16:19 <kmc> true
23:16:27 <kmc> that's something of an anomaly
23:16:51 <kmc> but note that
23:16:52 <ski> it would be more consistent if `reverseDigits 0 = []'
23:17:01 <kmc> digitsReverse [] == 0
23:17:02 <kmc> digitsReverse [0] == 0
23:17:05 <kmc> digitsReverse [0,0,0,0,0,0] == 0
23:17:16 <kmc> this is just the idea that leading zeros are irrelevant
23:17:19 <rschnck> I'll add it in
23:17:21 <kmc> it'll basically fall out of the math
23:17:23 <rschnck> Right
23:17:26 <ski> but, typically, one treats `0' as a special case, writing it with one digit, instead of zero digits
23:18:48 <rschnck> So in order for this to be recursive, I need to define some special case..that's probably horrible wording
23:18:51 <rschnck> but like n<10 = [n]
23:19:09 <rschnck> So in this case, can't we just use that x = x?
23:19:20 <ski> yeah, you need some base case to make the recursion stop
23:19:25 <ski> yes, you *could* say
23:19:34 <rschnck> is there a *better* thing to say?
23:19:35 <ski>   digitsReverse [d] = d
23:20:07 <ski> but, typically, it's better to reduce one's base case(s) to the minimal possible one
23:20:25 <ski> and the empty list is a simpler base case than a singleton list `[d]'
23:20:37 <rschnck> Oh
23:20:50 <rschnck> I'm still unsure
23:20:50 <ski> but if you want, you can do a version with `digitsReverse [d] = ...' first .. changing it afterwards
23:20:55 <rschnck> how to approach taking something out of a set
23:21:01 <ski> s/set/list/
23:21:05 <rschnck> list
23:21:05 <rschnck> Sorry
23:21:06 <rschnck> Jesus
23:21:09 <ski> :)
23:21:28 <rschnck> how to approach taking something out of a *list* :)
23:21:39 <ski> well, a list is created by either `[]' (empty list), or by `blah : foo' (non-empty list)
23:21:55 <ski> so, to take apart a list, you define your function by those two possible cases
23:22:05 <rschnck> Oh
23:22:07 <rschnck> So we have [] = 0
23:22:09 <ski> what should the function return if the list is empty ?
23:22:30 <ski> what should the function return if the list is non-empty, i.e. has a first element, followed by a list of (possibly zero) more elements
23:22:34 <ski> ?
23:22:38 <kmc> rschnck, you're still thinking in terms of verbs.  "take out", "build".  in the best case, Haskell programs are not about "do this, do that".  they're just lists of equations, facts about how some expressions relate
23:22:55 <rschnck> well, the elements reversed...and as an int...so I'm antcipating some multiplication by factors of 10
23:23:14 <ski> rschnck : yeah, that sounds that it probably will turn up, here
23:23:16 <kmc> so when we say "digitsReverse (x:xs) = ..."
23:23:21 <kmc> don't think about taking elements out
23:23:25 <rschnck> kmc: So they *are* things, so to say
23:23:36 <rschnck> kmc: Like how...er... 5-2 *is* 3?
23:23:39 <kmc> just think about defining what the function returns, when the input list looks like (x:xs)
23:23:54 <rschnck> Oh
23:23:55 <rschnck> Okay
23:23:57 <kmc> yeah, that's the idea
23:24:09 <rschnck> So haskell = math. 
23:24:12 <kmc> heh
23:24:16 <ski> in a sense, yes
23:24:20 <kmc> kind of
23:24:24 <rschnck> Good, because the course for which this is for is math 121. x
23:24:31 <rschnck> Seems appropriate.
23:24:32 <kmc> a lot of the people saying "haskell = math" are misinformed about one or both subjects
23:24:37 <kmc> but there's also a lot of truth to it
23:24:40 <rschnck> I'd be in the latter category.
23:24:57 <rschnck> So we want the function to return an integer
23:25:04 <rschnck> whose first value is x
23:25:10 <rschnck> Well, wait
23:25:12 <kmc> integers don't have a "first value"
23:25:13 <rschnck> x can be a list, right?
23:25:16 <kmc> they're just numbers
23:25:21 <kmc> in (x:xs)?
23:25:31 <rschnck> Like (x:xs) = ([2,1]:[1,23,4,]), right?
23:25:32 <kmc> if x from (x:xs) were a list, then you'd have a list of lists
23:25:33 <kmc> no
23:25:36 <rschnck> Oh :(
23:25:39 <rschnck> Then what is xs?
23:25:44 <kmc> the rest of the elements
23:25:47 <kmc> x is the first element, xs is the rest
23:25:48 <rschnck> So xs is alist.
23:25:51 <kmc> yes
23:25:56 <kmc> if your input were [1,2,3,4]
23:25:58 <kmc> you'd have x=1
23:26:00 <kmc> and xs = [2,3,4]
23:26:01 <rschnck> Since : operates a -> [a] -> [a]?
23:26:03 <kmc> yes
23:26:14 <ski> `xs' is a mnemonic for "many `x's", so the "s" in "xs" is to be thought of as a plural "s" of "x"
23:26:27 <rschnck> Well want I want to do right now is
23:26:40 <rschnck> something along the lines of 1 + 4* 10 + 3
23:26:41 <rschnck> oops
23:27:08 <rschnck> Sorry, let me try that again... 1 + 2 *10 + 3*100 + 4*1000
23:27:17 <rschnck> Is that sort of inching at the correct approach?
23:27:52 <kmc> yes
23:27:52 <shachaf> rschnck: Probably. Factoring it a bit might make it clearer.
23:28:11 <kmc> so suppose the input is [1,2,3,4]
23:28:17 <kmc> we want to produce the integer 4321
23:28:25 <kmc> and we have x = 1, and xs = [2,3,4]
23:28:38 <kmc> we can make a recursive call on xs, what does that give us?
23:28:47 <rschnck> so 1 + 10 (2 + 10 ( 3+ 10 (4)))
23:28:56 <rschnck> And it seems recursion is appropriate.
23:29:16 <ski> also note that `4 = 4 + 10 * 0'
23:29:37 <rschnck> But...see how 2 is just an element of the list?
23:29:45 <rschnck> How would I "call" upon *that* element of the list?
23:29:56 <rschnck> That's sort of where I'm getting stuck
23:29:59 <ski> the recursive call will worry about that
23:30:00 <rschnck> xs is this list of numbers
23:30:07 <rschnck> but I'm applying idnividual operations to each number withint that list
23:30:15 <ski> you should only focus on the *current* element of the list
23:30:33 <ski> trust in that the recursive call will do the correct thing on the rest of the list
23:30:39 <rschnck> OH, wait
23:30:40 <rschnck> Think I got it
23:30:43 <ski> (the "recursive leap of faith", so to speak)
23:30:52 <rschnck> ski: Scary :3
23:31:56 <ski> if you do your job in the base case, and in the recursive case (and make sure every call eventually reaches the base case(s)), then it will turn out that the recursive calls will all work as you want them to
23:31:58 <rschnck> Nope, it gets stuck.
23:32:03 <kmc> rschnck, so
23:32:06 <kmc> xs = [2,3,4] yes?
23:32:13 <rschnck> Yep
23:32:22 <ski> rschnck : what's your current code ?
23:32:28 <kmc> so what's (digitsReverse xs)?
23:32:53 <rschnck> for 4,3,2?
23:32:55 <rschnck> Oops
23:32:56 <rschnck> Sorry
23:33:11 <kmc> digitsReverse xs = digitsReverse [2,3,4]
23:33:12 <ski> (i.e. what *should* `digitsReverse xs' return ? .. don't think about what it actually will do, at the moment)
23:33:13 <kmc> right?
23:33:24 <kmc> yes, by the specification of what the function should return
23:33:51 <rschnck> Oh, it should return 4,3,2?
23:33:54 <rschnck> 432*
23:33:55 <kmc> no
23:33:56 <kmc> yes
23:33:57 <kmc> 432
23:34:06 <kmc> so, now back to the problem we were actually solving
23:34:18 <kmc> x = 1, xs = [2,3,4], digitsReverse xs = 432
23:34:22 <kmc> we need to return 4321
23:34:31 <kmc> how do you do it?
23:34:46 <rschnck> Well
23:34:49 <rschnck> Like I did with the 1
23:34:54 <rschnck> I want to do the same with the 432, right?
23:34:56 <rschnck> So get that 2 out of there?
23:35:06 <ski> don't worry about that
23:35:07 <rschnck> Sorry for my horrific programming descriptions
23:35:21 <rschnck> Recursive leap o' faith?
23:35:31 <ski> the recursive call has already computed `digitsReverse xs' (where `xs' is `[2,3,4]') to be `432' for you
23:35:55 <kmc> rschnck, it's just arithmetic now
23:36:01 <kmc> how do you take 432 and 1 and make 4321
23:36:09 <ski> your job now is to combine `x' (which is `1' here), `xs' (which is `[2,3,4]') and `digitsReverse xs' (which is `432') to get the result `4321'
23:36:25 <rschnck> Multiply by 10...
23:36:38 <ski> .. and ?
23:36:53 <rschnck> Wait, one sec
23:36:56 <shachaf> Recursion is pretty magical.
23:37:02 <rschnck> Let me get my head around why digitsreverse (xs) = 432
23:37:13 <shachaf> rschnck: No, you don't need to worry about why.
23:37:28 <shachaf> rschnck: It has been Decided. Your job is just to worry about this one step.
23:37:37 <ski> rschnck : when `xs' is `[4,3,2]', then we *want* `digitsReverse xs' to become `432' .. that is enough for us
23:37:38 <kmc> rschnck, "why" is that's what the specification says
23:37:42 <kmc> there's a comment before the function that says
23:37:59 <kmc> -- takes a list of digits and returns the integer composed of those digits, in reverse order 
23:38:04 <rschnck> if digitsReverse (xs) = 432, then (digitsReverse (xs))*10 = 4320 +1 = 4321
23:38:12 <kmc> rschnck, when you are using a function someone else wrote, you read their documentation and don't necessarily care about the guts
23:38:16 <rschnck> Which works for an integer of any length due to the head/tail distintion
23:38:25 <kmc> rschnck, the trick here is that you're the user *and* the author
23:38:28 <rschnck> kmc: Guts & entrails are interesting.
23:38:28 <ski> rschnck : `(digitsReverse (xs))*10' is `4320', not `4320 +1'
23:38:31 <kmc> but you have to wear both hats
23:38:38 <kmc> you see what i mean?
23:38:39 <rschnck> ski: + x, thuogh
23:38:46 <ski> rschnck : yes, exactly
23:38:54 <rschnck> But I did that. It doesn't work.
23:39:00 <kmc> you're defining the function, but it calls itself as if it can blindly rely on itself to have stated behavior
23:39:03 <ski> exactly what did you try ?
23:39:09 <rschnck> digitsReverse [] = 0
23:39:10 <rschnck> digitsReverse (x:xs) = x + (digitsReverse (xs))*10
23:39:22 <kmc> rschnck, instead of saying "it doesn't work" could you pastebin a) what "it" is, i.e. the code, and b) the error message or unexpected behavior?
23:39:26 <rschnck> Oh wait
23:39:27 <rschnck> It does
23:39:31 <rschnck> Had to left-over syntax
23:39:32 <kmc> yes that's correct :)
23:39:36 <ski> > let digitsReverse [] = 0; digitsReverse (x:xs) = x + (digitsReverse (xs))*10  in  digitsReverse [5,4,3,2,1]
23:39:37 <lambdabot>   12345
23:39:38 <rschnck> Neat :D
23:39:44 <ski> seems to work just fine
23:39:47 <rschnck> Yep
23:39:47 <kmc> though you'd write «x + (digitsReverse xs)*10» typically
23:39:54 <kmc> no use putting parens around a single name
23:40:10 <kmc> parens are only for grouping, they don't denote function calls like in some other laguages
23:40:11 <ski> or even
23:40:19 <ski>   digitsReverse (x:xs) = x + digitsReverse xs * 10
23:40:51 <rschnck> So now I need to go reverseDigits Int -> Int
23:40:55 <rschnck> So I'll try that without help
23:41:00 <dibblego> is there a break :: ([a] -> Bool) -> [a] -> ([a], [a]) that searches for a match on a prefix of the tails instead of each list element?
23:41:17 <ski> rschnck : yeah, that should be easy now, if you apply a certain standard list function
23:41:35 <shachaf> dibblego: It would have to construct each prefix.
23:41:41 <dibblego> this is true
23:41:46 <shachaf> I don't think there's anything like that in the standard library.
23:41:53 <dibblego> didn't think so
23:41:55 <Cale> dibblego: Maybe just apply tails first?
23:42:09 <dibblego> yeah I'll just write it with tails and break
23:42:33 <ski> > let digitsReverse [] = 0; digitsReverse (x:xs) = x + (digitsReverse (xs))*10  in  digitsReverse [4,3,2,1] :: Expr
23:42:33 <lambdabot>   4 + (3 + (2 + (1 + 0 * 10) * 10) * 10) * 10
23:42:42 <ski> rschnck : ^ that's what your function is doing, now
23:42:43 <shachaf> That won't give you the prefixes, though.
23:43:01 <shachaf> Huh, I didn't know lambdabot could do that.
23:43:03 <shachaf> Expr++
23:43:09 <rschnck> ski: But I shouldn't use that, right? I want int -> int
23:43:19 <ski> > let digitsReverse [] = 0; digitsReverse (x:xs) = x + 10 * digitsReverse xs  in  digitsReverse [4,3,2,1] :: Expr  -- somewhat more readable
23:43:20 <lambdabot>   4 + 10 * (3 + 10 * (2 + 10 * (1 + 10 * 0)))
23:43:38 <ski> rschnck : you shouldn't use what ?
23:43:48 <rschnck> ski: Nevermind :P
23:44:11 <Botje> > let digitsReverse [] = 0; digitsReverse (x:xs) = x + 10 * digitsReverse xs  in  digitsReverse [4,3,2,1] :: Int
23:44:12 <lambdabot>   1234
23:44:47 <lispy> :t foldr
23:44:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:45:18 <lispy> > foldr (\x xs -> x + 10 * xs) 0 [4,3,2,1]
23:45:18 <lambdabot>   1234
23:45:34 <rschnck> Should I use foldr?
23:45:43 <kmc> eventually
23:45:46 <rschnck> Because it seems that if I do it similar to how I did reverseDigits
23:46:00 <kmc> it may be easier to see why the explicit recursion works
23:46:01 <shachaf> rschnck: foldr is just a way of abstracting the explicit recursion your function does.
23:46:28 <shachaf> kmc: An imperative programmer might find it easier to see why a fold(l) works. :-)
23:46:37 <kmc> yeah
23:47:08 <lispy> rschnck: some people prefer the higher-order stuff (foldr) and others think the direct recursion is nicer.
23:47:08 <rschnck> I get stuck in this situation where I have to take something like 4321, do 4321 `mod` 10 to get 1. Then, to get the next digit I can't do just 4321 `mod` 100. I also have to do get rid of that 1, right? Otherwise I get 21.
23:47:16 <dibblego> I have found that it's per individual and found no pattern (imperative or not)
23:47:24 <kmc> rschnck, err
23:47:29 <kmc> didn't you already solve this problem
23:47:36 <kmc> rschnck, i was proposing that you could use the two functions you already wrote
23:47:39 <rschnck> Maybe to you, but stupidity prevails
23:47:42 <kmc> in order to write the overall Int -> Int
23:47:51 <rschnck> But that's inefficient, isn't it?
23:47:58 <kmc> why are you worrying about efficiency?
23:48:26 <kmc> the most important thing in writing software is to make well defined building blocks
23:48:32 <kmc> and build larger blocks out of smaller blocks
23:48:47 <rschnck> so what I want to do
23:48:48 <kmc> and you've already defined two very useful functions
23:48:52 <rschnck> is take reverseDigits
23:48:56 <kmc> one which will turn 1234 into [1,2,3,4]
23:48:59 <kmc> err
23:49:00 <rschnck> and then apply digitReverse, but without it reversing them again
23:49:04 <kmc> one which will turn 1234 into [4,3,2,1]
23:49:12 <rschnck> Or that
23:49:12 <rschnck> Okay
23:49:13 <kmc> and one which will turn [1,2,3,4] into 4321
23:49:17 <rschnck> Yep
23:49:21 <kmc> and so you've turned 1234 into 4321 which is the end goal
23:49:26 <kmc> and the only remaining step is how to reverse a list
23:49:31 <kmc> but lucky for you, there's a standard function for it
23:49:35 <kmc> > reverse "hello world"
23:49:36 <lambdabot>   "dlrow olleh"
23:49:38 <shachaf> kmc: Why not have one that turns [1,2,3,4], one that turns [1,2,3,4] into [4,3,2,1], and one that turns [4,3,2,1] into 4321?
23:49:44 <rschnck> kmc: Well that's cheating :P
23:49:51 <shachaf> Oh, you are doing it in three parts. Never mind.
23:49:54 <ski> > reverse [5,4,3,2,1]
23:49:54 <lambdabot>   [1,2,3,4,5]
23:50:03 <kmc> rschnck, you can define it yourself too
23:50:08 <rschnck> I shall
23:50:11 <kmc> cool :)
23:50:12 <lispy> shachaf: looks like you made it back home?
23:50:14 <ski>   myReverse [    ] = ...
23:50:16 <kmc> you may need this guy:
23:50:18 <kmc> :t (++)
23:50:18 <lambdabot> forall m. (Monoid m) => m -> m -> m
23:50:24 <kmc> > [1,2,3] ++ [6,7,8]
23:50:25 <lambdabot>   [1,2,3,6,7,8]
23:50:26 <lispy> shachaf: were you able to check out powells?
23:50:26 <shachaf> lispy: Oh, hello!
23:50:27 <ski>   myReverse (a:as) = ..a..(myReverse as)..
23:50:30 <kmc> err, ignore the type lambdabot gave
23:50:33 <kmc> (++) :: [a] -> [a] -> [a]
23:50:39 <kmc> glues together two lists
23:50:49 <ski> @type (Prelude.++)
23:50:50 <lambdabot> forall a. [a] -> [a] -> [a]
23:52:57 <rschnck> Ah
23:53:22 * lispy >>= bed
23:55:15 <lispy> wait, why did lambdabot give that type??
23:55:17 <lispy> That's not right at all
23:55:26 <lispy> That's mappend, IIRC
23:55:29 <lispy> :t mappend
23:55:29 <lambdabot> forall a. (Monoid a) => a -> a -> a
23:55:42 <lispy> Caleskell?
23:55:46 <ski> yes
23:55:50 * lispy sighs
23:55:54 <ski> (and Haskell 1.4, i think)
23:56:20 <lispy> I wouldn't mind, except it doesn't match H98 or H2010
23:56:25 <lispy> Or anything between
23:56:37 * lispy really goes to bed this time
23:56:43 <shachaf> lispy: What would you prefer?
23:56:45 <rschnck> kmc: and [3,4] ++ [2,9] = [3,4,2,9], in that order?
23:56:48 <shachaf> (++) being mappend makes perfect sense.
23:56:54 <ski> rschnck : yes
23:57:01 <rschnck> Then I believe I have an idea.
23:57:07 <bremner> rschnck: ghci can answer those questions very quicklu
23:57:12 <bremner> also quickly
23:57:16 <lispy> shachaf: It's just that lambdabot as a way to teach people Haskell is now teaching people some variant of Haskell.
23:57:16 <ski> > [3,4] ++ [2,9]
23:57:17 <rschnck> bremner: I like IRC banter.
23:57:17 <lambdabot>   [3,4,2,9]
23:57:35 <lispy> shachaf: I like for (++) to be on Monoid too, but that's not what's in the Prelude
23:57:58 <shachaf> lispy: Hmm, I suppose that's true. We need some way to have multiple Preludes in lambdabot for different uses.
23:58:08 <lispy> > Just 1 ++ Just 2
23:58:09 <lambdabot>   Ambiguous type variable `t' in the constraints:
23:58:09 <lambdabot>    `Data.Monoid.Monoid t'
23:58:09 <lambdabot>  ...
23:58:18 <lispy> > Just 1 ++ Just 2 :: Monoid Int
23:58:19 <lambdabot>   Class `Data.Monoid.Monoid' used as a type
23:58:32 <ski> yes, being able to switch between different modules in scope, would be useful
23:58:32 <lispy> > Just 1 ++ Just 2 :: Monoid m => m Int
23:58:33 <lambdabot>   Kind error: `m' is applied to too many type arguments
23:58:39 * shachaf is slightly envious of :: Expr and wishes ghci has built-in support for it.
23:58:53 <ski> (especially on a per-user, or per-small-group-of-users basis)
23:59:17 <shachaf> lispy: (Num a) => a is... Oh.
23:59:26 <shachaf> > Just (Sum 1) ++ Just (Sum 2)
23:59:27 <lambdabot>   Ambiguous occurrence `Sum'
23:59:27 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
23:59:36 <shachaf> > Just (Data.Monoid.Sum 1) ++ Just (Data.Monoid.Sum 2)
23:59:37 <lambdabot>   Just (Sum {getSum = 3})
