00:13:23 <Mitar> http://www.haskell.org/haskellwiki/Default_values_in_records
00:29:35 * hackagebot storablevector 0.2.7 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.7 (HenningThielemann)
00:34:37 <tehgeekmeister> does hdbc protect against sql injection?
00:36:37 <jamy> who use House os?
00:38:59 <nlogax> hugh laurie
00:39:24 <jamy> what?
00:43:53 <kmc> is there a library for parallel fold with an associative operator?
00:44:21 <chrisdone> tehgeekmeister: it protects by using toSql and fromSql methods of the SqlValue to ensure type safety
00:44:21 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
00:44:27 <chrisdone> @messages
00:44:27 <lambdabot> FunctorSalad said 10h 12m 5s ago: hmm no, I used pana (amarok 1.4 maintenance fork) for a brief time but then it stopped working... have been using mpd since which is kinda ok... but no dynamic
00:44:27 <lambdabot> playlists sadly
00:44:42 <tehgeekmeister> chrisdone: do those methods do the necessary escaping?
00:44:48 <chrisdone> tehgeekmeister: of course
00:45:03 <tehgeekmeister> chrisdone: okay, just wanted to make sure i didn't need to do that
00:45:22 <chrisdone> hm the new haddock documentation sucks
00:45:30 <chrisdone> where's the overview section?
00:45:53 <chrisdone> I was going to give you a link to the class which explains this but there's no overview so I can't get a link to the particular heading
00:46:01 <chrisdone> http://hackage.haskell.org/packages/archive/HDBC/2.2.6.1/doc/html/Database-HDBC-Statement.html
00:46:05 <chrisdone> scroll down... ~_~
01:23:51 * hackagebot synthesizer-core 0.4.0.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.4.0.1 (HenningThielemann)
01:57:16 <boegel> is there a way to enforce garbage collection from within a Haskell program?
01:57:51 <bss03-AFK> boegel: ISTR there's a GHC-specific call to request a major GC.
01:58:07 <bss03> @hoogle gc
01:58:08 <lambdabot> Data.Typeable gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
01:58:08 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
01:58:08 <lambdabot> Data.Typeable gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))
01:58:16 <bss03> @hoogle garbage
01:58:16 <lambdabot> No results found
01:58:23 <bss03> @hoogle collection
01:58:23 <lambdabot> No results found
01:58:25 <geheimdienst> no garbage on hoogle
01:58:30 <geheimdienst> @hoogle collect
01:58:30 <lambdabot> Test.QuickCheck collect :: (Show a, Testable b) => a -> b -> Property
01:58:30 <lambdabot> Data.Graph.Inductive.Internal.Thread type Collect r c = (r -> c -> c, c)
01:58:39 <bss03> @hoogle majorG
01:58:39 <lambdabot> No results found
01:58:42 <bss03> @hoogle major
01:58:42 <lambdabot> No results found
01:59:40 <boegel> bss03: :)
01:59:48 <JoeyA> Is it possible to install documentation with haddock?
02:00:11 <JoeyA> I get this warning:  "Warning: The documentation for the following packages are not installed. No
02:00:11 <JoeyA> links will be generated to these packages: attoparsec-0.8.1.0, base-3.0.3.2,
02:00:12 <JoeyA> binary-0.5.0.2, rts-1.0, bytestring-show-0.3.3, mtl-1.1.1.0, utf8-string-0.3.6"
02:01:34 <kmc> set «documentation: True» in ~/.cabal/config
02:03:35 <JoeyA> ah, thanks
02:04:32 <JoeyA> What do people do these days when they want to add testcases to their cabal packages?
02:05:56 <bss03> JoeyA: QuickCheck still, right?
02:06:11 * bss03 has not used cabal for my own programs, yet.
02:06:36 <JoeyA> I mean, I already have a test program, and I want to integrate it in an existing cabal project.
02:06:44 * JoeyA hasn't used cabal for his own project, either.
02:07:48 <geheimdienst> JoeyA: i did something like this recently for some unit tests and i'm happy with it: http://gbacon.blogspot.com/2009/06/setting-up-simple-test-with-cabal.html
02:08:36 <geheimdienst> (i guess you don't need the .cabal stuff about the "testing" flag and so on. the Setup.hs is where it's at)
02:09:28 <JoeyA> thanks
02:09:38 <dmwit> I thought the normal thing was to make darcs (or git, or whatever) do the tests, not cabal.
02:10:10 <kmc> Data.IntMap doesn't have a strict unionWith does it :/
02:10:45 <boegel> bss03: I'm trying to find that GHC specific call, but not much luck so far...
02:10:59 <bss03> kmc: I don't think so.
02:11:10 <geheimdienst> dmwit: woah didn't know that. any links on how to set that up?
02:11:21 <bss03> boegel: I've been looking too, and no luck so far.
02:11:53 <dmwit> darcs setpref test "the program to run that does all the tests"
02:12:03 <bss03> boegel: I've never used it, but I saw it discussed here before.  It might not be "exported" into haskell, it might just be part of the internal GHC C API.
02:12:20 <bss03> boegel: If that's the case, it might still be callable via FFI.
02:12:33 <boegel> bss03: hmm, right, thx
02:13:38 <dmwit> http://darcs.net/manual/Darcs_commands.html#SECTION00782000000000000000 has all the info
02:14:28 <geheimdienst> dmwit: ok i see. guess that would mean cabal's gotta build the test binary all the time, not just when some -testing flag is set
02:14:39 <dmwit> Why?
02:15:06 <dmwit> darcs setpref test "ghc --make tests/quickcheck.hs && tests/quickcheck" # for example?
02:15:40 <dmwit> Or if you prefer cabal, "cabal build -ftesting && dist/build/test/test" or whatever.
02:15:44 <geheimdienst> i see. good idea
02:16:35 <geheimdienst> i think i'll keep it in Setup.hs. i like that i can run "cabal test" without doing a darcs record
02:16:47 <dmwit> sure
02:16:58 <dmwit> Different strokes for different folks. =)
02:18:03 <geheimdienst> also, i hear there's a summer of code thing underway to make cabal better at testing. one more stroke for different folks ... er ...
02:19:35 <geheimdienst> boegel: "The main entry point into the GC is the GarbageCollect() function defined in GC.c" sez http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
02:19:57 <boegel> geheimdienst: so, that's the one to call through FFI?
02:21:02 <bss03> @hoogle performGC
02:21:02 <lambdabot> System.Mem performGC :: IO ()
02:21:06 <geheimdienst> what do i know, i'm just googling stuff to maybe learn something myself :-)
02:21:09 <bss03> boegel ^^
02:21:15 <geheimdienst> @hoogle gc
02:21:15 <lambdabot> Data.Typeable gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
02:21:16 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
02:21:16 <lambdabot> Data.Typeable gcast2 :: (Typeable2 t, Typeable2 t') => c (t a b) -> Maybe (c (t' a b))
02:21:32 <boegel> bss03: ah! :) thx
02:21:58 <boegel> bss03: thanks a bunch!
02:22:03 <boegel> damn, that was hard to find
02:22:07 <bss03> boegel: No prob.
02:22:38 <bss03> I found it in some out-of-date document about the pre-standard FFI.
02:23:33 <geheimdienst> hoogle does find it for "gc", but it's result #14 or some such
02:24:12 <bss03> I looked for majorG, but no luck.
02:24:35 <bss03> The C function is performMajorGC, which would be a little easier to hoogle. :P
02:24:52 <geheimdienst> performHugeAssGC
02:25:15 * bss03 thinks buntfalke just got GC'd.
02:35:57 <bss03> Is it possible to export "ghc_rts_opts" via the FFI in a way that It will get picked up correctly?
02:36:15 <bss03> Just so I don't have to use an C file that only contains that variable?
02:38:17 <sinelaw> preflex, seen Peaker
02:38:17 <preflex>  Peaker was last seen on #haskell 4 days, 10 hours, 54 minutes and 33 seconds ago, saying: FunctorSalad: Just debugged a little script I had for 10 min (What? Why is it creating a file slightly shorter than...)
02:38:23 <sinelaw> preflex, seen PeakerWork
02:38:23 <preflex>  PeakerWork was last seen on #haskell 30 days, 15 hours, 59 minutes and 23 seconds ago, saying: ManateeLazyCat: I think git is much better than darcs
02:45:10 <hvr> is it possible to depend on certain ghc versions in .cabal files?
02:45:39 <hvr> the only thing I found so far restricting compilers was 'tested-with'
02:47:03 <dcoutts> hvr: in what sense do you depend on the ghc version?
02:47:04 <geheimdienst> hvr, xmonad-contrib.cabal has things like: if impl (ghc == 6.10.1) && arch (x86_64) ...
02:47:55 <hvr> dcoutts: let's say I wanted to avoid a specific ghc version, since I know it has some issues
02:48:11 <hvr> dcoutts: or I'd like to make sure no ghc older than 6.12 is used
02:48:20 <dcoutts> hvr: cabal makes it easy to depend on versions of packages, or on language extensions, but not on compilers, since generally compilers are supposed to be implementations of language standards + extensions
02:49:19 <dcoutts> though it's of course possible to do different things for different compilers or compiler versions
02:49:44 <dcoutts> and you could in principle simply declare the package to be unbuildable for some compilers or versions
02:49:52 <dcoutts> though that's not really encouraged
02:50:02 <dcoutts> (and not handled especially well)
02:50:04 <hvr> it's just for an inhouse project :)
02:50:33 <hvr> so, how would I declare it unbuildable for certain versions?
02:50:55 <dcoutts> if ! ghc >= x.y then buildable: False
02:51:13 <mm_freak> mfix f = mfix f >>= f
02:51:16 <mm_freak> is this sensible?
02:51:27 <dcoutts> hvr: that might need brackets, I don't quite remember
02:51:38 <hvr> dcoutts: thx, I get the idea :)
02:52:05 <dcoutts> hvr: users will not get a good error message though, it'll just say that it's not buildable
02:52:20 <geheimdienst> in cabal, what's the difference between "if ghc == 6.12" and "if impl (ghc == 6.12)"?
02:53:05 <dcoutts> geheimdienst: oh, that's my fault, I told hvr the wrong syntax...
02:53:11 <hvr> dcoutts: I was thinking of making a fake-package-depedancy conditional on impl(ghc ...), which would be named something like 'you_need_ghc_6.12_or_later'
02:53:18 <hvr> that should give the user a hint
02:53:26 <dcoutts> hvr: erm :-)  if ! impl(ghc >= x.y)
02:53:53 <dcoutts> hvr: you might find it's simpler to pretend you depend on the latest version of the base library
02:54:57 <hvr> well.. yes, I already do
02:55:23 <hvr> but then the colleague didn't understand the error message
02:55:35 <hvr> and didn't get it, that it was it's compiler being to old
02:55:47 <hvr> his'
02:56:24 <dcoutts> hvr: right, so my suggestion will not be any better in terms of error message
02:58:49 <dcoutts> hvr: you see for public distribution (e.g. on hackage) we deliberately want to discourage packages forcing a particular compiler or compiler version and rather to say what they need in terms of language extensions, since the point is that the user should choose.
02:58:52 <dcoutts> hvr:  This obviously does not work so well for the in-house case where you really do want to force decisions on your users.
02:59:27 <dcoutts> hvr: you might like to file a ticket in the Cabal trac describing your use case
03:00:41 <dcoutts> hvr: e.g. we might add some way to explicitly depend on a compiler, but as a policy measure discourage that on the public hackage server.
03:07:25 <kmc> mm_freak, i think that diverges for most monads
03:07:41 <kmc> any monad where (>>=) pattern-matches on its left argument
03:07:44 <kmc> "strict monads"
03:09:07 <kmc> the implementation of fix for IO involves creating a MVar and using unsafeInterleaveIO
03:11:50 <ppavelV6> unsafeInterleaveIO is indeed abused :( People got bitten by hGetContents for example. The usage of unsafePerformIO and unsafeInterleaveIO goes contra the idea of haskell. I'd vote for transitive warning for using it. Usage of any function that uses it should give compile-time warning
03:12:05 <kmc> yup
03:12:11 <kmc> iow we should track effects in the type system
03:12:15 <kmc> (on an advisory basis)
03:12:22 <kmc> you know, that thing everyone says haskell does that it completely does not ;)
03:12:38 <ppavelV6> kmc:  indeed!
03:14:05 <ppavelV6> kmc: something should be done with it before good boys all escape to Agda :)
03:15:18 <kmc> hehe
03:15:24 <kmc> i hear Agda is still regularly proving ⊥
03:15:34 <kmc> plus you can turn off the termination checker and the only consequence is your code turns pink ;P
03:16:00 <ppavelV6> sigh.... wait, i know! I need my own language! :)
03:16:13 <kmc> i should start trolling Reddit about how the Agda guys need to stop playing with math and write some practical code
03:16:33 * hackagebot FTPLine 1.1.0 - A command-line FTP client.  http://hackage.haskell.org/package/FTPLine-1.1.0 (DanielDiaz)
03:16:47 <hvr> dcoutts: in general I fully understand your motivation, being grown up with autotools, which depend on features not implementations
03:16:59 <ppavelV6> kmc: "get real!" :) 
03:19:56 <zygoloid> kmc: let's all use Disciple
03:20:43 <kmc> yeah
03:20:46 <kmc> must be frustrating
03:20:52 <kmc> if you work on a language with actual effect typing
03:21:07 <kmc> to have Haskell become well known for that, when it's not at all accurate
03:22:02 <ppavelV6> lazyIO was the gate to the Dark Side i suppose.
03:25:05 <ppavelV6> we neeed a fork of standard library :) with things like numeric-prelude, iteratee, return=pure and Applicative=>Monad, ListLike etc :)
03:26:34 <ppavelV6> "lessons learned" kind of things. no lazy IO, no Show => Num...
03:27:14 <ppavelV6> does Haskell' effort address this kind of things?
03:27:22 <kmc> i think so
03:27:49 <kmc> i'd like to see a well thought-out alternate prelude achieve widespread usage
03:28:30 <ppavelV6> kmc: one day we need to drop back compatibility. Or just provide an alternative
03:29:58 <kmc> yeah
03:30:14 <kmc> well today anyone can write an alternative and upload it to hackage
03:30:19 <ppavelV6> something can be found in 'none' section, but haskell' mostly concentrates on core language. http://hackage.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&group=section
03:30:52 <kmc> there's a few; none of them are all that popular
03:31:01 <mikhael_for_u> hii
03:31:05 <mikhael_for_u> any ne here
03:31:09 <ppavelV6> kmc: anyone is a bit of exaggeration. And even if anyone can not anyone dare o care
03:31:14 <mikhael_for_u> any pro in clanguge here?
03:31:29 <mikhael_for_u> c language
03:31:31 <mikhael_for_u> ??
03:31:38 <mikhael_for_u> any pros in C
03:31:40 <mikhael_for_u> ??
03:31:44 <kmc> mikhael_for_u, you're in the wrong place
03:31:45 <kmc> go to ##c
03:31:50 <mikhael_for_u> okkk
03:31:56 <ppavelV6> mikhael_for_u: what? you mean C can pay the bills now?!
03:32:07 <mikhael_for_u> but its not connecting to that
03:32:23 <mikhael_for_u> it isnt conecting to ##c channel
03:32:30 <kmc> mikhael_for_u, http://webchat.freenode.net/
03:32:38 <kmc> where it says "Channels" put in ##c
03:32:42 <mikhael_for_u> whats that link?
03:32:49 <mikhael_for_u> ok
03:35:54 <tensorpudding> it might be good to google the question before asking also
03:37:44 <ppavelV6> tensorpudding: http://lmgtfy.com/ is my favorite tool to insult people who are lazy enough to not use google :)
03:38:17 <kmc> eh i'll let the ##c people explain the finer points of IRC etiquette if necessary
03:38:24 <kmc> they're so much better at it than we are
03:38:54 <rothwell> at the very least he'll learn a few new insults
03:38:56 <mikhael_for_u> ssssshhhhhhhhhhhh
03:39:08 <mikhael_for_u> its not connecting to ##c
03:39:21 <mikhael_for_u> its showing that it cannot be connected
03:39:27 <mikhael_for_u> any c pros here
03:39:45 <kmc> ##c:  "This channel requires NickServ registration in order to speak"
03:39:52 <kmc> so, you should register your nickname
03:39:52 <tensorpudding> oh noes
03:39:55 <mikhael_for_u> if i want soem questions in C to be solved can i give them here
03:39:58 <kmc> no
03:40:02 <tensorpudding> try joining #haskell-blah
03:40:04 <mikhael_for_u> how to register my nick??
03:40:10 <mikhael_for_u> i am new to this
03:40:12 <kmc> the freenode website will explain how to register your nick
03:40:27 <mikhael_for_u> just 30 min back i ahve installed this xchat 2
03:40:40 <mikhael_for_u> okk thanxx
03:41:09 <ppavelV6> mikhael_for_u: just wondering, why you choose this particular channel for asking C questions? :)
03:41:19 <kmc> it's big and it has the word "programming" in the topic
03:41:45 <ppavelV6> kmc: oh, haskell is big these days :) 
03:41:49 <kmc> 8th biggest channel
03:41:53 <tensorpudding> C, Haskell, both programming
03:42:03 <kmc> second biggest language channel
03:42:09 * ppavelV6 isnt' it time for agda after all :)
03:42:24 <kmc> biggest ratio of IRC users to language users
03:42:24 <geheimdienst> omg we is big and importent! totilly new feelin fur teh haskells!
03:42:58 <geheimdienst> ^^ i can feel a lolcat coming up. a big fat cat, with a caption something like that
03:43:01 <ppavelV6> geheimdienst: uncomfortable :) 
03:43:21 <tensorpudding> lolcats are boring now
03:43:33 <tensorpudding> not even if they have fancy lambdas
03:43:39 <rothwell> always preferred them without the text...
03:44:20 <geheimdienst> lolcats never will be boring. that's like saying the gutenberg bible is "boring"
03:44:25 <kmc> hahaha
03:44:49 <geheimdienst> you might not care much for its content, but it still has its place in history
03:45:05 <geheimdienst> lolcats : interweb :: gutenberg bible : movable type
03:45:17 <tensorpudding> blasphemy
03:45:36 <kmc> http://upload.wikimedia.org/wikipedia/commons/b/b6/Gutenberg_Bible,_Lenox_Copy,_New_York_Public_Library,_2009._Pic_01.jpg shiny
03:46:02 <tensorpudding> Look at those fat margins
03:46:18 <geheimdienst> they set it with tex
03:46:21 <rothwell> wonder if some civilization will look back on the wreckage of this one in a few hundred years and say "all these tedious people ever did was annotate cats"
03:46:25 <tensorpudding> and unreadable blackletter
03:46:39 <HugoDaniel> http://www.haskell.org/ still shows the old school logo :)
03:47:19 <geheimdienst> rothwell: which is nothing to be ashamed of. cat worship is an important part of ancient egyptian culture for example
03:47:46 <geheimdienst> ancient egyptian cat worship is the context i'd see lolcats in
03:48:35 <rothwell> hm
03:49:27 <rothwell> feel as if some researcher in egypt just found a new interpretation for a set of ancient writings...
03:50:53 * hackagebot sequor 0.1 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.1 (GrzegorzChrupala)
03:51:00 <kmc> so i have a function of type «Int → IO (IO a → IO a)»
03:51:27 <kmc> if you give it 'n', it returns a function f, such that of all IO actions wrapped by f, at most n will be in progress at once
03:51:33 <kmc> makes sense?
03:51:40 <kmc> it's a small wrapper on QSem
03:51:46 <kmc> anyway, i wonder what is a good name for it
03:52:23 <mbuf> why does, sequence (map print [1, 2, 3, 4, 5]) print [(), (), (), (), ()] at the end?
03:53:38 <dobblego> mbuf, you want sequence_
03:54:04 <mbuf> dobblego: yes, but, I want to know what that () stands for?
03:54:11 <kmc> it's the value produced by print
03:54:15 <kmc> print 3 :: IO ()
03:54:17 <dobblego> it's the value of the type for which there is only one value
03:54:22 <pozic> mbuf: it doesn't.
03:54:26 <dobblego> often pronounced "unit"
03:54:29 <pozic> mbuf: ghci does that.
03:54:29 <kmc> data () = ()
03:54:35 <ketil> dobblego, or two values.
03:54:40 <ppavelV6> dobblego: not counting _|_ 
03:54:45 <ketil> :-)
03:55:08 <ppavelV6> haskellers are so picky :)
03:55:08 <mbuf> thanks
03:55:28 <zachk> its the computers that are so picky 
03:56:38 * frerich wonders why so many haskell functions have odd names. For instance, foldl' vs. fold. It's hard to tell the diffrence just by looking at the name :-} Or sequence vs. sequence_
03:56:50 <frerich> Or foo vs. foo2
03:56:57 <ppavelV6> frerich: just go talk with lispers :)
03:57:16 <frerich> I can imagine it's hard to come up with good names but well, yeah...
03:57:35 <ppavelV6> frerich: actually ' and _ are kind of idioms already. ' meaning some strictness and _ meaning not using the result.
03:57:49 <geheimdienst> i think the loose convention is that foo' is like foo, but has a strictness difference
03:57:58 <frerich> ppavelv6: Oh! That's good to know, I didn't realize there's some sort of convention
03:58:00 <kmc> Control.Monad has a specific convention about M and _ suffixes
03:58:01 <mm_freak> kmc: yeah, that's what i thought, too
03:58:09 <kmc> the ' suffix is not always for strictness
03:58:22 <mm_freak> kmc: i'm really failing to figure out how to write mfix for ContT, but let me try
03:58:27 <ppavelV6> kmc: it's often for updated version of something :)
03:58:34 <kmc> yeah
03:58:38 <frerich> So far I had the impression That "foo'" means "behaves like foo, except for the stupidity"
03:58:46 <kmc> and you get the worst bugs when you write x instead of x' within a big "let" and can't find it
03:58:52 <geheimdienst> yeah, foo' also can mean "a function similar to foo", "a variant"
03:58:53 <kmc> because x' and x probably have the same type
03:59:11 * rothwell shadows the hell out of everything
03:59:26 <ppavelV6> kmc: the best bugs are when you shadow the definition :) at least GHC can warn about it
03:59:58 <frerich> Maybe I'm lame and I'll make fun of my own code in a few years, but at the moment I'm using "verbose" names for e.g. type variables; So I don't say "a" and "b" but "symbolType" and "resultType" or so.
04:00:20 <ppavelV6> frerich: very reasonable thing to do
04:00:25 <rothwell> frerich: i do the same if they have some meaning
04:00:25 <zachk> i do verbose and then alias to one or two letters 
04:00:33 <rothwell> sometimes they really don't mean much...
04:01:15 <ppavelV6> i keep telling myself that being unable to come out with meaningful name probably means that i use a value in a wrong place
04:01:48 <ppavelV6> but the level of abstraction haskell provides to you many things are just err... things ;)
04:02:03 <rothwell> hehe, yeah
04:02:54 <ppavelV6> monoidalSomething :)
04:02:57 <zachk> i wonder if my calc 1 teacher will be pleased i answered a question about limit combinations by defining Maybe and fmap over it for binary operators :) 
04:03:18 <frerich> Many haskelel tutorials read a bit like a mathematical proof. As un: when I do a proof, it's a rather 'chaotic' process and only in the end I have something very generic and concise. And then I basically write it out in reverse order. Same in haskell: I usually start with concrete types "like f :: String -> Bool" and only later realize that instead of "String" I could say "[a]" and 'a' must be a member of Eq.
04:03:19 <frerich>  However, most Haskell articles I saw start with the super generic version straight away :-}
04:03:47 <frerich> It makes me feel stupid ;-)
04:04:31 <koala_man> there might be several previous revisions of that article with less general functions :P
04:04:43 <ppavelV6> frerich: yep and reading things like this leads you to a bad habit by starting too generic from the very beginning so you can nothing about everything. This leads to frustration and prolonged depression :)
04:05:36 <ppavelV6> koala_man:  :))) probably in author's private repository only even if she cares even to keep them :)
04:06:16 <ppavelV6> frerich: "tell nothing about everything"
04:06:59 * hackagebot redis-simple 0.1 - Simple redis bindings for Haskell  http://hackage.haskell.org/package/redis-simple-0.1 (JasperVanDerJeugt)
04:07:12 <mm_freak> frerich: you get used to it, and then you'll find it useful =)
04:07:27 <mm_freak> though too much generalization can hurt sometimes
04:07:30 <mm_freak> like (.) = fmap
04:07:31 <mm_freak> ;)
04:08:37 <ppavelV6> (.)(.)(.) is rather common idiom :) and fmap fmap fmap in general :) poor man's composed Applicative :)
04:09:07 <mm_freak> hmm…  now i might be missing something, but it seems to be impossible to write mfix for ContT
04:09:24 <mm_freak> ContT is too strict
04:11:00 * hackagebot redis-simple 0.1.1 - Simple redis bindings for Haskell  http://hackage.haskell.org/package/redis-simple-0.1.1 (JasperVanDerJeugt)
04:14:19 <hvr> dcoutts: is it possible to share common dependancies between multiple executables in the same .cabal package? 
04:15:46 <hvr> dcoutts: or in general, I have a few executables, and everythings the same, except for different entry-point Main.hs modules
04:16:36 <Botje> you could use the trick busybox uses
04:16:48 <dcoutts> hvr: if you mean common modules then yes, you can make a lib and have exes in the same package depend on that lib (though currently lib will get installed too)
04:16:56 <Botje> put everything in one executable with a couple of symlinks to it and dispatch on the name of the binary
04:16:56 <hvr> Botje: no, argv0 dispatching is not what I want ;)
04:17:00 <Botje> boo :P
04:18:26 <dcoutts> hvr: if you mean something like a common section that gets added to every other exe section in the package then no (not yet)
04:18:31 <pozic> Watch and cry: http://hackage.haskell.org/packages/archive/symbol/0.1/doc/html/src/Data-Symbol.html#Symbol
04:18:59 <hvr> dcoutts: ic... I thought I had read somewhere, that intra-.cabal lib-dependancies wouldn't work too good
04:19:09 <ppavelV6> pozic: i feel your pain
04:19:29 <dcoutts> hvr: currently running haddock on them is borked, that bug will be fixed eventually.
04:20:29 <Botje> what's so bad about it?
04:22:37 <pozic> Botje: there is only one symbol environment for example.
04:22:49 <ppavelV6> Botje: unsafe operations considered harmful
04:23:17 <pozic> Botje: so, if you have two libs using it, the union of those two libs doesn't work, right?
04:23:23 <ppavelV6> this is exactly the case monads were introduced for
04:23:39 <hvr> is there some ghc compiler switch or something to transform unsafe-io into an compile error?
04:23:44 <Botje> don't we have dynamic linking yet?
04:23:54 <Botje> or rather, ghc
04:24:03 <pozic> Botje: that's unrelated.
04:24:12 <hpc> GHC does have dynamic linking
04:24:15 <hpc> iirc
04:24:38 <Botje> so if the two libs share the copy of symbol it doesn't break, i guess?
04:26:50 <pozic> Botje: if they share it no, but it is also slower, btw. 
04:41:10 * hackagebot spawn 0.2 - Tiny library for joinable computations / threads with results.  http://hackage.haskell.org/package/spawn-0.2 (KeeganMcAllister)
04:41:47 <hpc> i wish the function 'on' was defined in Prelude
04:57:25 <mreh> > pure 1 :: ZipList Int
04:57:26 <lambdabot>   No instance for (GHC.Show.Show
04:57:26 <lambdabot>                     (Control.Applicative.Zip...
04:57:47 <mreh> > getZipList . pure $ 1 :: ZipList Int
04:57:48 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
04:57:48 <lambdabot>                  ...
04:58:21 <mreh> > getZipList $ (pure $ 1 :: ZipList Int)
04:58:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:04:18 * hackagebot ecu 0.0.1 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.1 (TomHawkins)
05:30:54 <illissius_> hmm, with higher-rank constraints a la http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html maybe you could unify the various-rank Monoid classes (would be even nicer with class aliases ofc)
05:31:16 <illissius_> `class (Monad m, forall a. Monoid (m a)) => MonadPlus m` e.g.
05:37:30 * hackagebot AttoJson 0.5.8 - Simple lightweight JSON parser, generator & manipulator based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.8 (HiromiIshii)
05:45:07 <tomh> whats that forall notation called again in type definitions? Higher-Rank Polymorphism?
05:47:18 <Saizan> yep
05:47:32 <tomh> ok cool
05:47:49 <Saizan> well, in the sense that the forall keyword is only useful with higher-rank polymorphism
05:48:19 <Saizan> which describes those types which have the forall (== universal quantification) on the left of a (->)
05:48:46 <kmc> the forall keyword in GHC is also useful for an unrelated thing
05:48:53 <kmc> which is bringing type variables into scope
05:48:56 <kmc> with ScopedTypeVariables
05:49:02 <tomh> thats an extension right
05:49:07 <kmc> yeah
05:49:11 <tomh> ok
05:49:15 <kmc> forall itself is not in the syntax of Haskell 98
05:49:17 <kmc> (or 2010)
05:49:21 <tomh> then im just looking for Higher-Rank Polymorphism
05:49:55 <kmc> illissius_, reminds me of http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
05:50:05 <Saizan> higher rank polymorphism is an extension too, RankNTypes
05:50:40 <tomh> ok
05:52:31 <tomh> do you know by any chance a good article which explains it to a non-haskell programmer? :>
05:53:25 <kmc> no
05:53:27 <kmc> i can give it a shot though
05:53:53 <tomh> cool, im listening
05:54:25 <kmc> do you know any haskell syntax?
05:54:33 <tomh> yeah Im a haskell programmer :>
05:54:44 <kmc> oh, but you need to explain it to a third party
05:55:11 <tomh> no, its just that I understand haskell concepts easier if they are presented for a non-haskell audience :)
05:55:16 <kmc> ok
05:55:31 <tomh> just like monads, took me ages to know why one would use that 
05:55:49 <kmc> so do you want a use case for higher-rank polymorphism?
05:55:57 <kmc> or do you want an explanation of what it is?
05:56:01 <kmc> (or both, and if so in which order)
05:56:12 <tomh> yeah ideally a minimal use case why its usefull, and a minimal case when it doesn't work
05:57:14 <kmc> let's say i'm implementing an interpreter for a dynamically typed language
05:57:33 <kmc> whose values are represented in Haskell by the type Value
05:58:09 <kmc> and i want to convert a Haskell arithmetic function into a function on Values, which works no matter whether the value is an int, double, etc.
05:58:21 <kmc> you might come up with a type like this:
05:58:45 <kmc> mkArith :: (Num a) => (a -> a -> a) -> Value -> Value -> Value
05:58:51 <kmc> and use it like «mkArith (+)»
05:59:02 <kmc> but this doesn't work
05:59:05 <kmc> can you see why?
05:59:10 <tomh> let me see
05:59:35 <tomh> value can be both int and double?
06:00:13 <dcoutts_> tomh: when is 'a' chosen?
06:00:39 <tomh> when it its applied I assume
06:00:57 <tomh> when the (+) get's its first arguments
06:01:29 <zygoloid> mkArith :: forall a. Num a => ...  is like  mkArith :: (a :: Type) -> NumDict a -> ...; the caller provides the type 'a'.
06:02:11 <dcoutts_> tomh: and what if you use the operator within mkArith at multiple different types?
06:02:34 <tomh> at the same time?
06:02:47 <dcoutts_> tomh: no, in different places within the function
06:03:01 <dcoutts_> use it in one place at Int and one place at Double
06:03:37 <dcoutts_> a System F translation might help, that's the most precise
06:03:38 <tomh> you mean for instance, first you apply it to 1.0+1.0, convert that to an int and then apply (+) to that and 1
06:03:48 <dcoutts_> since then you can see where the type application is happening
06:04:25 <dcoutts_> tomh: when you're using Value you'll have something like case v of ValInt n -> ...; ValDouble n -> ...
06:04:51 <dcoutts_> and you'll be using the (+) parameter in each branch with n of different types
06:04:53 <tomh> yeah
06:06:23 <tomh> I thought the type was inferred at the last possible moment
06:07:00 <tomh> the forall makes that possible?
06:07:10 <benmachine> tomh: but the signature (a -> a -> a) -> Value -> Value -> Value says, you can pass an Int -> Int -> Int to this function, or a Double -> Double -> Double
06:07:42 <benmachine> you could pass (**) to that function, which doesn't work on Ints at all
06:07:55 <hpc> :t (**)
06:07:56 <lambdabot> forall a. (Floating a) => a -> a -> a
06:08:29 <tomh> so what should I do to resolve it?
06:08:39 <tomh> forall a.a -> a -> a?
06:09:05 <benmachine> something a bit like that
06:09:09 <kmc> mkArith :: (forall a. (Num a) => (a -> a -> a)) -> Value -> Value -> Value
06:09:11 <Botje> but then you have to write a function that works for all a's
06:09:15 <kmc> which is a rank-2 type
06:09:23 <tomh> ok
06:09:32 <Botje> (so it's either f a b = a, f a b = b, or f a b = undefined)
06:09:47 <Botje> (or variants involving seq, i guess)
06:09:59 <benmachine> for that signature, you can only pass functions that work on *all* Num
06:10:03 <kmc> the idea here is that «∀x. (S x → T)» is a type which *promises* flexibility to its *caller*, whereas «(∀x. S x) → T» is a type which *demands* flexibility from its *argument*
06:10:38 <zenzike> is there still a problem if we can assume a function mkA :: Num a => Value -> a ?
06:11:15 <hpc> could you write mkA?
06:11:15 <benmachine> zenzike: such a function assumes you can get any kind of Num out of a Value
06:11:25 <hpc> you couldn't get a Double into an Int context
06:11:31 <tomh> so the (+) function needs an implementation with Num a -> Num a -> Num a?
06:11:50 <hpc> you mean Num a => a -> a -> a?
06:11:57 <tomh> eh yeah
06:12:44 <kmc> for that matter i'm free to write an «instance Num ()» and then mkA would convert every number to ()
06:13:40 <kmc> the issue here is that it's not good enough for the caller of mkArith to pick some particular A, and provide a function of type (A -> A -> A)
06:13:58 <zenzike> hpc: I'm just wondering if this problem goes away if, say, the language we're using has isomorphic values, but of different types
06:14:12 <kmc> the caller of mkArith needs to provide a function which has type (a -> a -> a) for *any* Num a chosen by mkArith
06:14:23 <zenzike> (not that this is the case in general, I'm just begin curious :-) )
06:14:26 <kmc> nested quantifiers are all about who chooses what
06:14:36 <tomh> kmc: that seems quite hard to provide such function
06:14:44 <kmc> tomh, (+) is such a function
06:14:54 <kmc> but not (for example) (/)
06:15:09 <tomh> ok
06:15:18 <kmc> both of them work as «Double -> Double -> Double»,  but (/) doesn't generalize to all Num
06:15:19 <kmc> but (+) does
06:16:08 <tomh> so when I see a forall, it means I have to provide a function that works for the type parameters regardless of how they are infered?
06:20:05 <kmc> well, if «f :: S → T», and you want to call f, you have to provide S
06:20:18 <kmc> now if S = «∀x. R x»
06:20:26 <kmc> S is "things which, for all x, have type R x"
06:20:30 <kmc> so you have to provide such a thing
06:20:51 <tomh> whats that char? my encoding is a bit weird here
06:20:57 <tomh> the forall character?
06:21:01 <kmc> yeah
06:21:04 <kmc> sorry, i'll use ASCII
06:21:10 <kmc> you should set your client to UTF-8 if possible
06:21:15 <tomh> lemme check
06:21:52 <kmc> above says "if f :: S -> T, and you want to call f, you have to provide S.  if S = forall x. R x, ..."
06:22:44 <tomh> my client crashed after trying to change it :(
06:22:46 <kmc> as dcoutts_ said, it might help to read about System F
06:22:58 <kmc> which is a typed lambda calculus with polymorphism
06:23:06 <tomh> yeah I read about it a long time ago in compiler class 
06:23:13 <kmc> unlike Haskell, type application is explicit
06:23:40 <kmc> so you'd write things like:   map Int Char chr [1,2,3]
06:24:31 <zygoloid> in this particular case, mkA might be possible, if you can a priori convert every Value value to an Integer ;)
06:24:52 <tomh> ok
06:24:54 <kmc> possible, but not useful
06:25:05 <kmc> the Num instance for Int or Word8 or () is going to lose precision still ;P
06:25:22 <zenzike> zygoloid: thanks, I was wondering about that :-)
06:26:13 <zygoloid> it's more likely that what you /want/ is mkA :: exists a. Num a => Value -> a. but we can't type that in GHC, since it doesn't support 'exists'
06:26:30 <zygoloid> we can fake it with: mkA :: Value -> (forall a. Num a => a -> r) -> r
06:26:51 <tomh> I just stick to working with forall for now :)
06:26:55 <zygoloid> or with an existential wrapper type (which is really the same thing)
06:26:58 <tomh> well thanks all for the help
06:28:47 <zenzike> zygoloid: so might there be a theoretical "mother of all a", maybe call it a', such that forall a . Num a => a' ?
06:29:19 <zenzike> I meant forall a. Num a => a -> a'
06:30:37 <Cale> zenzike: As it happens, there isn't, but there's the opposite of that.
06:30:58 <zenzike> as in _|_ ?
06:31:38 <Cale> As in, there's a type T with a function (Num a) => T -> a
06:31:42 <Cale> Specifically, Integer
06:32:02 <Cale> :t fromInteger
06:32:02 <lambdabot> forall a. (Num a) => Integer -> a
06:33:06 <Cale> (Obviously, there's a function of every type, but the presumption here is that we want one which can be expected to respect the properties expected of the methods of Num)
06:33:06 <int-e> @type ((join .) .) . liftM2
06:33:07 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
06:35:35 <zygoloid> zenzike: data A' = forall a. Num a => A' a. then A' :: forall a. Num a => a -> A'.
06:35:52 <zygoloid> zenzike: this is a GHC extension: existential quantification.
06:36:38 <zygoloid> alternatively, type A' = (forall a. Num a => a -> r) -> r
06:37:03 <zygoloid> then f :: forall a. Num a => a -> A'; f a k = k a
06:37:28 <zygoloid> the latter form requires Rank2Types (and FlexibleSynonyms i think)
06:38:04 <zenzike> zygoloid: thanks :-)
06:38:45 <benmachine> f :: forall a. Num a => a -> A'; f a k = k a -- wait, what?
06:38:55 <benmachine> oh
06:38:56 <benmachine> right
06:38:57 <benmachine> yes
06:39:06 <benmachine> because A' is a type synonym now, sorry
06:39:19 <zygoloid> yeah. that's the church-encoding of the old A'
07:01:44 <illissius_> afaict, you can't write robust RULES for typeclass methods (only the instances) because you have no control over dictionary inlining; anyone know if the same is also true of typeclass-polymorphic functions which aren't methods?
07:10:37 <ezyang> Hey #haskell, what have you noticed tends to make outsiders excited about type systems? For example, I find Curry-Howard always inspires the imagination of people who know logic but not programming. 
07:13:30 <kmc> that's not my experience
07:13:49 * geheimdienst has no idea what curry-howard is
07:13:52 <kmc> i think C-H works better in the other direction
07:13:57 <medfly> curry howard isomorphism
07:14:19 <alej> ezyang good question. i was definitely *not* excited about type systems until i tried haskell
07:14:19 <quicksilver> ezyang: how can you possibly logic without knowing about C-H ?
07:14:31 <geheimdienst> what i love about damn strong typing is that it's hard to get anything to compile, but once it does, it rarely has any bugs left
07:14:41 <medfly> quicksilver, you can know really basic logic and be inspired when you hear about it?
07:14:46 <quicksilver> perhaps.
07:14:49 <kmc> mostly pure maths people don't care that programmers have found applications of their stuff
07:14:59 <ezyang> quicksilver: I guess people who are non-programmers are more likely to know what "modus ponens" is. Not practicing logicians. 
07:15:00 <medfly> pure maths people don't care
07:15:03 <kmc> and sometimes will gripe that they made it all ugly ;P
07:15:19 <medfly> http://imgur.com/gallery/f5kzo <- pure mathematicians
07:15:38 <kmc> i agree that the main excitement about good static typing is that you have some idea what your code might do before you run it
07:15:43 <kmc> and some idea that it's close to your intent
07:15:50 <geheimdienst> when you haskelled a little and then go back to, say, javascript, you get outraged by how the interpreter is so incredibly unhelpful. it catches none of your mistakes at all
07:15:58 <geheimdienst> </my-2-cents>
07:16:07 <alej> geheimdienst yeah it's hard for me to do python now or even scheme :(
07:16:11 <alej> and i used to love scheme
07:16:17 <kmc> it seems clearly good to know what your code does before you run it
07:16:30 <kmc> yet there's whole communities that are aggressively opposed to this idea
07:17:47 <frerich> I believe large parts of those communities aren't annoyed about strong typing but about the lack of type inference.
07:18:20 <geheimdienst> kmc, probably they're more opposed to javaish languages. java's type system is a little helpful and very very verbose. (haskell's type system is very helpful and very concise. almost everything is inferred.)
07:18:25 <kmc> yup
07:18:48 <kmc> but they've taken it beyond "Java's types annoy me" to an ideological willful ignorance about static properties of code
07:19:24 <ezyang> I mean, I think there is certainly something to analyzing the runtime properties of code. 
07:19:52 <geheimdienst> i think the trend towards very dynamic languages criticises javaish type systems. that's understandable, but the solution is not to move all type stuff to as late as possible. that throws out the baby with the bathwater
07:20:32 <ManateeLazyCat> @hoogle String -> ByteString
07:20:33 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
07:20:33 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
07:20:33 <lambdabot> Prelude read :: Read a => String -> a
07:20:57 <applicative> does anyone know about these Foo_paths modules cabal produces?  I am trying to make a portable executable with associated resources, but am ineptly baking in my ~/.cabal instead of a relative path. 
07:20:58 <geheimdienst> (that remark is not one of my stylistically most cromulent)
07:21:06 <alej> haha
07:21:39 <kmc> i'm not just talking about people who use ruby because they hate java.  i'm talking about the people who see writing code as entirely subservient to writing and running tests
07:21:46 <frerich> geheimdienst: I'm not even sure whether that saying exists in english at all (I only recognize it from german)
07:22:07 <kmc> it does exist
07:22:14 <alej> what saying?
07:22:19 <geheimdienst> the baby bathwater? yeah that works in both languages
07:22:28 <ManateeLazyCat> @hoogle Data.Text.pack 
07:22:28 <lambdabot> No results found
07:24:15 <geheimdienst> kmc, yeah, 2/3 of all unit tests are testing things a cool type checker could test
07:24:17 <ManateeLazyCat> > let safeUTFStringToByteString = Data.Text.Encoding.encodeUtf8 . Data.Text.pack
07:24:18 <lambdabot>   not an expression: `let safeUTFStringToByteString = Data.Text.Encoding.enco...
07:25:12 <kmc> the irony is that static types help with testing too
07:25:25 <geheimdienst> you could view haskell's type system as thing that formalizes and concises the majority of your unit tests
07:26:04 * geheimdienst iz in ur lenguage, verbin ur word concise
07:26:08 <ManateeLazyCat> Have function do "UTF8StringToByteString = Data.Text.Encoding.encodeUtf8 . Data.Text.pack" ?
07:26:16 <quicksilver> people who love tests tend to believe they make static types obsolete
07:26:25 <quicksilver> people who love static types tend to believe they make tests obsolete
07:26:28 <quicksilver> they're both wrong, of course.
07:26:50 <kmc> yeah
07:26:59 <kmc> the strawman in any argument tends to be wrong
07:27:05 <quicksilver> :)
07:27:07 <geheimdienst> quicksilver, i would say static types obsolete maybe a half or three quarters of all unit tests
07:27:12 <ManateeLazyCat> @hoogle fromString
07:27:12 <lambdabot> Data.String fromString :: IsString a => String -> a
07:27:26 <ManateeLazyCat> Is Data.ByteString.UTF8.fromString
07:27:27 <quicksilver> geheimdienst: I would say maybe a half to three quarters of all vague hand waving statistics are wrong.
07:27:45 <wli> Um, nobody believes tests are obsolete. Static types eliminate the need for certain kinds of tests. That is, various invariants are provided by the type system or otherwise are provable a priori.
07:27:56 <kmc> Haskell programmers all think testing is obsolete, it's not like Haskel Platform includes two different testing frameworks ;)
07:28:03 <geheimdienst> @slap quicksilver
07:28:04 * lambdabot submits quicksilver's email address to a dozen spam lists
07:28:25 <wli> Essentially they eliminate the need for hand-coded runtime type checks.
07:29:46 <geheimdienst> imho unit tests make static types obsolete in the same way that 37 variables person1, person2, ... makes an array of 37 persons obsolete
07:29:52 <EvanR-work> if it compiles, its good. if it runs, its perfect
07:29:54 <geheimdienst> (or list for that matter)
07:29:59 <wli> Where the type system is powerful enough to encode invariants such are eliminated. Where it's not, you still need them.
07:31:25 <ski> mm_freak : no `mfix f = mfix f >>= f' is not sensible; it'll perform the effects from `f' more than once
07:31:25 <wli> I think Eiffel actually had a good idea on this front, where there was language support for invariant assertions.
07:31:37 <tg_> geheimdienst: except for one has ordering and the other doesn't?
07:31:46 <ski> mm_freak : afaik, `mfix' is not possible for `Cont' or `ContT' .. iirc, there' some paper by Magnus Carlsson about this
07:31:55 <frerich> In a sense, a (strong) type system *is* a unit tests which can detect a certain class of issues (and it can detect such issues very early).
07:33:17 <EvanR-work> is there are haskell project for post-sql relational database
07:33:27 <EvanR-work> sql is kind of klunky
07:34:15 <tg_> EvanR-work: CouchDB?
07:34:18 <tg_> NoSQL
07:34:34 <bastl> hi.
07:34:40 <tg_> EvanR-work: http://github.com/arjunguha/haskell-couchdb/
07:34:41 <geheimdienst> what's with that one thing i keep hearing about ... shinkansen ... takusen? was that the name?
07:34:48 <kmc> in a sense, a hammer is a kind of gun, since both can be used to cut down trees
07:35:13 <tg_> kmc: what kind of ham... you know what, nevermind.
07:35:23 <kmc> you just gotta swing hard enough
07:35:33 <tg_> you must be a World's Strongest Man (tm)
07:35:35 <geheimdienst> when all you have is a hammer, all your problems begin to look tree-shaped
07:35:41 <EvanR-work> you cant shoot yourself in the foor with a hammer
07:35:42 <tg_> geheimdienst: that's the one
07:35:48 <EvanR-work> foot*
07:36:00 <EvanR-work> tg_: is that a relational database?
07:36:06 <geheimdienst> you swing a gun to cut down trees?
07:36:18 <zygoloid> geheimdienst: it works if you swing the gun hard enough
07:36:18 <tg_> EvanR-work: nope
07:36:22 <kmc> is there an interesting / useful sense in which static types are like testing? to me 'testing' implies random or manual search for counterexamples
07:36:28 <bastl> I compiled a package on a machine with far mor RAM than mine, and would like to install it on my machine. Can I make binary builds with cabal ?
07:36:28 <EvanR-work> in predator, jesse venture cut down trees with his gun
07:36:32 <EvanR-work> ventura
07:36:38 <tg_> EvanR-work: http://en.wikipedia.org/wiki/CouchDB
07:36:46 <EvanR-work> yes
07:36:54 <geheimdienst> a gun is like an axe because both can be used to cut down trees?
07:36:56 <EvanR-work> so yeah, how about a relational db ;)
07:36:58 <tg_> I don't recommend it, though.
07:37:07 <tg_> You want a non-SQL relational DB
07:37:15 <EvanR-work> yes
07:37:20 <EvanR-work> for haskell ;)
07:37:25 <EvanR-work> or in haskell
07:37:30 <quicksilver> kmc: I'm not suggest they're like it; I'm suggesting that (some) TDD advocates use testing for the kind of invariants we encode in the type system
07:37:35 <tg_> You're asking for something which you know doesn't exist, aren't you?
07:37:40 <tg_> at least, the haskell part :O
07:37:44 <applicative> ManateeLazyCat, does " encodeUtf8.pack " give you a type error?
07:37:47 <EvanR-work> no idea
07:37:55 <quicksilver> kmc: ...and conversely that some strict type advocates don't bother with testing
07:38:06 <quicksilver> kmc: I'm overstating the case obviously, but there is a *tendency* in those directions
07:38:24 <EvanR-work> seems like it wouldnt be that 'hard' to throw one together since haskell has nice data structures and nice parsers
07:38:36 <EvanR-work> and relational query stuff is functional
07:38:37 <quicksilver> there are non-SQL relational libraries for haskell, I'm sure
07:39:05 <geheimdienst> you can't swing a cat without cutting down a tree. which proves the hammerishitude of cats. and guns! they're also like guns a lot
07:39:40 <tg_> It seems kind of strange to want to keep the relational property but throw away SQL
07:39:49 <tg_> since you may not even have to express queries using SQL anyway
07:39:56 <EvanR-work> sql is to relational as c++ is to OOP
07:40:05 <geheimdienst> Abraham Lincoln: "If I was given three hours to cut down a tree, I would spend two of them sharpening the gun."
07:40:13 <vanadium> EvanR-work: "better/more than"?
07:40:15 <bnery> hi guys!
07:40:23 <tg_> right, but most of the relational databases I will search for which are actually used (supported), will support SQL (among other query languages)
07:40:23 <bnery> how do I execute a bunch of [IO]
07:40:23 <quicksilver> EvanR-work: http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces/CoddFish
07:40:28 <bnery> ?
07:40:36 <quicksilver> EvanR-work: I'm pretty sure that's not the only such effort either
07:40:40 <tg_> quicksilver: that's old, evidently
07:40:42 <EvanR-work> tg_: yeah but the same operations will be slow is current sql implementations
07:40:43 <quicksilver> bnery: sequence_
07:40:46 <EvanR-work> quicksilver: going to check this out
07:40:53 <bnery> thanks quicksilver!
07:40:53 <EvanR-work> tg_: s/same/sane/'
07:41:04 <tg_> 1.3 Discontinued
07:41:04 <tg_> CoddFish
07:41:05 <tg_> PURe See a separate Haskell Wiki page on it. It is another type safe and declarative approach to database managament in Haskell. (Development discontinued in 2006)
07:41:19 <tg_> 2006 is an eternity ago in Haskell
07:41:48 <geheimdienst> what about this? http://hackage.haskell.org/package/Takusen anyone have any experience?
07:41:48 <bnery> what about when I have [IO Int]?
07:42:01 <Zao> @type sequence
07:42:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:42:25 <Zao> @src sequence
07:42:25 <lambdabot> sequence []     = return []
07:42:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:42:26 <lambdabot> --OR
07:42:26 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:42:42 <Zao> Line 2 of the source there should be rather self-explaining.
07:42:43 <EvanR-work> k development discontinued
07:42:55 <Zao> bnery: Perform then one at a time, gathering the results.
07:42:58 <kmc> :t foldr (liftA2 (:)) (pure [])
07:42:59 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
07:43:13 <kmc> @. hoogle type foldr (liftA2 (:)) (pure [])
07:43:14 <lambdabot> Parse error:
07:43:14 <lambdabot>   --count=20 "forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
07:43:15 <lambdabot> "
07:43:21 <kmc> @hoogle  (Applicative f) => [f a] -> f [a]
07:43:21 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:43:21 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:43:21 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:43:26 <ski> @type Data.Traversable.sequenceA
07:43:27 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
07:43:45 <EvanR-work> takusen needs some marketting material
07:44:14 <zygoloid> takusen: because beautiful women think databases are sexy
07:44:23 <EvanR-work> lol
07:44:41 <EvanR-work> make it more IT marketting
07:44:50 <geheimdienst> Takusen: Because babes depend on databases.
07:45:16 <tg_> Takusen: Because they will steal your Swingline at the drop of a hat.
07:45:18 <geheimdienst> don't believe it? check babes.cabal, it says build-depends: takusen
07:45:22 <EvanR-work> hipster buzzwords negotiate downtime sexier
07:45:26 <bnery> Zao tnx
07:46:07 <EvanR-work> looks like ill be developing it myself
07:46:14 <Zao> bnery: An [IO t] is a list of IO actions, each of which when performed yields a value of type t.
07:46:25 <ski> (.. takusen needs more Yoneda's lemma)
07:46:31 * EvanR-work builds a database from raw silicon ground out of the dirt with his fingernails
07:46:48 <Zao> bnery: You can juggle it around like a list of anything, the actions do not have any real meaning until they're performed.
07:46:49 <trinithis> Is it possible to create a "higher kinded" function? What I mean is this, say I have "type Test a = Int -> Maybe a". I want to use "Test", not "Test a"
07:47:12 <EvanR-work> Zao: they do have some meaning
07:47:13 <Zao> (is there a better term for "running" an IO action than "perform"? bind? run? sequence?)
07:47:16 <ski> trinithis : what should the type signature be ?
07:47:17 <Zao> EvanR-work: Sure.
07:47:17 <zygoloid> trinithis: ... use it for wyat?
07:47:27 <trinithis> I want to create an instance
07:47:28 <EvanR-work> 'when executed will have effects and produce a value of type ___'
07:47:28 <Zao> EvanR-work: The meaning of representing the IO action :D
07:47:38 <EvanR-work> the effects are ill defined
07:47:38 <trinithis> and the return type should be poly
07:47:44 <Zao> EvanR-work: You can't pattern match, you can compare for equality, etc.
07:47:45 <ski> Zao : "run" or "execute" is what i use
07:47:57 <trinithis> I'll create an example and put it on hpaste
07:48:00 <Zao> *can't
07:48:03 <zygoloid> trinithis: you can create an instance for that, with FlexibleInstances and TypeSynonymInstances enabled. but i'm not sure it'll do what you want.
07:48:24 <ski> (Zao : well, "perform" sometimes as well)
07:48:26 <EvanR-work> Zao: lots of values be pattern matched or compared
07:48:30 <EvanR-work> cannot be
07:48:44 <EvanR-work> still have meaning
07:48:53 <zygoloid> trinithis: that is, you can create an 'instance Foo (Test a)'. you can't have an 'instance Monad Test' because Test isn't a type constructor.
07:49:04 <trinithis> dang
07:49:17 <zygoloid> you can wrap it in a newtype, and then create an instance
07:49:24 <ski> zygoloid : well `Test' does have type `* -> *', though
07:49:29 <trinithis> Won't work for what I want
07:49:32 <ski> s/type/kind/
07:50:10 <ezyang> trinithis: No. 
07:50:28 <ezyang> type synonyms want their rhs to be kinded *. 
07:50:56 <trinithis> What I'm trying to do is create a function that optionally accepts one argument (like varargs)
07:51:07 <Zao> @type Maybe
07:51:08 <lambdabot> Not in scope: data constructor `Maybe'
07:51:10 <ezyang> trinithis: Have you seen the prior art for this? 
07:51:13 <Zao> Mehbe.
07:51:15 <zygoloid> trinithis: suppose you could do what you want, and you wrote: x >>= f, with x :: Test Bool. that would then be ambiguous: should it be the ((->) Int) monad, or the (\a -> Int -> Maybe a) monad?
07:51:21 <ezyang> Also, if it's just one argument, it's not really worth it. 
07:51:24 <tg_> ezyang: thanks again for your articles. Keep up the good work.
07:51:25 <ski> ezyang : not necessarily .. `type Foo = Either Int' works fine
07:51:26 <zygoloid> trinithis: /that/ you can do.
07:51:38 <sioraiocht> has the lhs2TeX + GHC 6.12 problem been solved/worked around yet?
07:51:53 <ski> @kind Maybe
07:51:54 <lambdabot> * -> *
07:51:59 <trinithis> ok
07:52:15 <ezyang> ski: Oh, really! Huh. 
07:52:20 <ezyang> tg_: \o/ 
07:52:24 <zygoloid> trinithis: suppose you want 'f' to have types Int -> String and also Double. then you can write: class F t where f :: t; instance F (Int -> String); instance F Double
07:52:41 <ski> ezyang : maybe it requires an extension .. but i don't recall which, if so
07:52:52 <zygoloid> trinithis: now that's a bit rubbish, since if GHC sees 'f (4 :: Int)', it can't actually figure out that the result has type String
07:53:04 <zygoloid> that's because there could be another instance F (Int -> Bool) defined elsewhere
07:53:16 <trinithis> I could do that, but I want the ultimate return type to be the same regardless. I could get it to work, but I have to explicitly type my functions
07:53:35 <trinithis> Which defeats my purpose
07:53:37 <zygoloid> what types do you want the function to have?
07:53:45 * ski wonders what trinithis *really* want to do
07:53:47 <trinithis> sec
07:54:09 <zygoloid> if there're only finitely many, can you give them different names?
07:54:10 <trinithis> "String -> GenJen a JVar" or "GenJen a JVar"
07:54:34 <ski> one option is to use `Maybe String'
07:55:01 <tg_> Does anyone feel like conal is advancing faster and faster away from your level of Haskell-ing?
07:55:10 <tg_> oh, there he is!
07:55:13 <tg_> ;)
07:55:43 <conal> :)
07:55:52 <zygoloid> tg_: more that conal has a certain disrespect for operational semantics :)
07:56:25 <tg_> zygoloid: all I know is that sometimes I accidentially think of the word 'denotational' instead of his name.
07:56:38 <conal> if i liked operational semantics, i'd be more into imperative programming.  denotational semantis & functional programming have the same spirit.
07:56:47 <conal> tg_: hah
07:56:52 <tg_> conal: good to see you again. Hope you've had a good, productive summer.
07:57:03 <ski> @type let f (fromMaybe "foo" -> x) = x ++ x in f
07:57:04 <lambdabot>     Illegal view pattern:  (fromMaybe "foo" -> x)
07:57:04 <lambdabot>     Use -XViewPatterns to enable view patterns
07:57:07 <zygoloid> i've found operational semantics inescapable. i do not believe in the sufficiently smart compiler
07:57:08 <ski> bah!
07:57:08 <geheimdienst> denotational, conotational, conational, conalitional
07:57:32 <tg_> gah: that's a mouthful
07:57:43 <zygoloid> i like the idea of connotational semantics
07:57:49 <conal> tg_: thx.  i've had a fun summer.  how about you?
07:58:23 <tg_> conal: Fun, productive in some aspects (health) but not others (employment, projects)
07:59:00 <bnery> do any of you guys play on SPOJ?
07:59:09 <zygoloid> conal: how's reactive going these days?
07:59:14 <conal> tg_: i'm glad to hear about the health part!  hopefully the other parts will follow.
07:59:27 <bnery> I can't get the FCTRL to run on the 6s time limit :( - my C solution runs in 0.27
07:59:41 <conal> zygoloid: while i was in tokyo last month i started noodling about reactive again.  that's about it.
08:00:51 <bnery> can anyone tell me why this is slow?
08:00:52 <bnery> http://hpaste.org/40089/spoj__fctrl
08:01:50 <tg_> conal: ipad-dev? how's that?
08:01:53 <bastl> i try to install gtk2hs and get this error msg. Can someone say whats wrong here ?
08:02:08 <conal> zygloloid: there is one part of the reactive implementation that i hadn't managed to get elegant, so i don't trust it.  needs revisiting.  and some operationally very subtle issues with termination.  the inescapable operational aspect you mentioned.  i haven't managed to escape it yet.
08:02:12 <bastl> http://hpaste.org/40090/installing_gtk2hs
08:03:18 <conal> tg_: i'm giving iOS dev a rest.  i learned a lot and got some nice support code together for more elegant graphics/gpu programming.  but i still don't know what i'm aiming at.
08:03:35 <tg_> conal: did you release all of it?
08:04:29 <conal> tg_: no, i haven't.  i don't know what i want to do with it.  i'd like to find some creative collaborations.
08:05:02 <conal> and there's still one sticking point of the haskell-embedded gpu compiler, which is solid CSE.  tricky to do in my GADT rep.
08:05:07 <conal> s/in/on/
08:05:21 <conal> which is what got me interested in memoizing polymorphic functions.
08:05:25 <ManateeLazyCat> Saizan: Can i request new feature add in hbuild?
08:05:50 <ManateeLazyCat> preflex: seen Saizan
08:05:50 <preflex>  Saizan was last seen on #haskell 2 hours, 15 minutes and 45 seconds ago, saying: higher rank polymorphism is an extension too, RankNTypes
08:06:20 <ezyang> conal: Memoization is a pretty interesting problem. 
08:06:36 <Saizan> ManateeLazyCat: asking is free :)
08:06:40 <conal> ezyang: way more interesting than i'd expected.
08:07:55 <tg_> to be honest, I didn't think it was interesting until I read your blog entries
08:07:59 <tg_> and now I don't know what to think
08:08:10 <ManateeLazyCat> Saizan: I always use your hbuild scan source code and generate *unnecessary* package list for 'build-tool' in foo.cabal, can hbuild also scan 'build-tool' content and output *unnecessary* package list automatically?
08:08:53 <conal> i thought the story of type-driven, purely functional memoizating (from Ralf Hinze) was very compelling.  now i realize that it's missing non-strictness, higher-orderness, and polymorphism.  three key aspects of what makes haskell-like languages wonderful.
08:09:35 <pequalsnp> hi, typing "(zip`ap`tail)" and then some list e.g. [1..] gives me an error in ghci, (and yes, i did :m + Control.Monad), why?
08:09:36 <ManateeLazyCat> Saizan: Best clean user's foo.cabal automatically. :)
08:09:43 <zygoloid> bnery: do you really need to operate over Double rather than Integer (or indeed Integer rather than Int)?
08:10:02 <tg_> conal: was your first interest in the subject the problem of (something akin to) depth culling graphics... I remember you talking about this a few months ago
08:10:08 <ezyang> conal: I have you done any thinking about the memory leak problem, that is, once you save a result, you can't forget abuot it? 
08:10:55 <conal> ezyang: yes!  that issue comes up for graphics and elsewhere.  i suspect it's a very important overlooked issue in functional programming in general.
08:11:15 <kremsera> and how did you solve it?
08:11:16 * zygoloid sometimes thinks the GC should be able to revert thunks if they resulted in a lot of allocation
08:11:46 <conal> zygoloid: exactly!  i'm with you there.
08:12:05 <ezyang> Well, Oleg and co solved it by not using Haskell :^) 
08:12:15 <tg_> cheat!
08:12:28 <foolcraft> I want to form all the increasing subsequences of a list
08:12:30 <Saizan> ManateeLazyCat: was the first build-tool meant to be build-depends ?
08:12:53 <zygoloid> it'd be nice if one could just annotate expressions with something saying "don't update this thunk on evaluation"
08:13:07 <ManateeLazyCat> Saizan: Oh, yes, is build-depends
08:13:07 <zygoloid> but specifying the operational semantics of that is a little tricky i think
08:13:08 <conal> tg_: yeah.  i did a lazy bi-infinite quad-tree zipper for infinite continuous images for the iPad.  quad-trees are fairly simple, but i wanted to write the zipper in haskell.
08:13:13 <ddarius> pequalsnp: You don't have the function instance in scope.  This would be even more obvious if you had provided the error message rather than saying that there was an error.
08:13:38 <ManateeLazyCat> Saizan: I want hbuild clean *unused* package from 'build-depends'. :)
08:13:44 <ezyang> zygoloid: Actually, from how I understand the STG, it shouldn't be impossible. 
08:14:01 <foolcraft> actually all k-sized increasing sequences that take their numbers from a set of different numbers
08:14:03 <conal> tg_: once in haskell, i started seeing lovely patterns, which led me to the alternative zipper interface i wrote about and to pattern functors, which then reminded me of memoization.
08:14:07 <ezyang> Since GHC is already taglessly representing data, so that when you evaluate a closure, you just jump to that code block, it'd be a matter of emitting different code. 
08:14:10 <pequalsnp> ddarius: sorry, how do i put the function instance into scope?
08:14:31 <ddarius> pequalsnp: Importing Control.Monad.Instances should work.
08:14:36 <ddarius> :t Prelude.ap
08:14:37 <lambdabot> Not in scope: `Prelude.ap'
08:14:47 <Saizan> ManateeLazyCat: ah, rather than just printing the used packages you'd like it to read the .cabal file and tell you the difference with what you have in build-depends?
08:14:51 <zygoloid> ezyang: the trouble is twofold: 1) you probably want to do it recursively, and 2) you probably don't want to do it recursively ;)
08:15:03 <ezyang> zygoloid: Hmmmm. 
08:15:13 <pequalsnp> ddarius: thank you!
08:15:15 <ManateeLazyCat> Saizan: Yes,
08:15:29 <siracusa> ManateeLazyCat: Hi! What version of Gtk+ is necessary to compile the latest gtk2hs version?
08:15:30 <ezyang> zygoloid: Yeah, whether or not this is any benefit is an open question :-) 
08:15:32 <zygoloid> in essence i think you want to copy exactly those subexpressions which aren't reachable from outside
08:15:47 <ezyang> Well, hopefully GHC can fuse those away. 
08:15:50 <ManateeLazyCat> Saizan: It's better if hbuild can clean "unused" package from 'build-depends' for me. :)
08:16:10 <ManateeLazyCat> siracusa: Any GTK+ version >= 2.8
08:16:37 <ManateeLazyCat> siracusa: I have add version macro make sure gtk2hs can compile any version above 2.8
08:17:23 <foolcraft> @sort
08:17:23 <lambdabot> Maybe you meant: more part src
08:17:29 <shapr> @quote
08:17:30 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
08:17:35 <zygoloid> ezyang: given: fib = ((fix((0:)scanl(+)1) !!), you might want the list of fibs to be copied rather than retained.
08:17:36 <foolcraft> sortingness!
08:17:38 <siracusa> ManateeLazyCat: I have 2.18 installed and gio doesn't compile because g_mount_get_default_location is missing.
08:17:49 <zygoloid> ezyang: but you probably don't want the Num Integer dict to be copied
08:17:54 <ManateeLazyCat> siracusa: Oh, gio need bigger. :)
08:18:04 <ManateeLazyCat> siracusa: Wait, i check.
08:18:17 <Saizan> ManateeLazyCat: that'd be harder because i'm pretty sure the Cabal's parser for .cabal files throws away the formatting, but if there's a prettyprinter and you'd be fine with its output..
08:19:27 <ezyang> Num Integer dict? 
08:19:38 <geheimdienst> Nom Integer dict
08:20:34 <ManateeLazyCat> siracusa: g_mount_get_default_location, and i missing version macro.
08:20:42 <ManateeLazyCat> siracusa: Need 2.24
08:20:48 <ManateeLazyCat> siracusa: Wait, i push new patches.
08:21:16 <ManateeLazyCat> siracusa: I saw some people complain gio compile problem on gtk2hs list too...
08:21:49 <ManateeLazyCat> siracusa: Wait me 10 minutes, i'm test gio ByteString APIs, i will push new patch fix version problem later. :)
08:21:58 <Saizan> ManateeLazyCat: also, how should it deal with flags and if/then/else?
08:22:31 <siracusa> ManateeLazyCat: Okay, thanks!
08:23:43 <ManateeLazyCat> Saizan: I don't know, maybe print *unused* is best solution, then i delete *unused* packages manually.
08:24:00 <ManateeLazyCat> Saizan: I guess print *unused* packages is pretty easy to you. :)
08:24:03 <ManateeLazyCat> ?
08:25:38 <ManateeLazyCat> siracusa: I use my elisp code binding gtk2hs, it's easy to missing version information if GIO/GTK+ manual is poor. :)
08:26:35 <Saizan> ManateeLazyCat: yeah, it shouldn't be hard
08:27:02 <ManateeLazyCat> Saizan: Can you add this feature? Thanks! :)
08:28:22 <ManateeLazyCat> siracusa: But it's easy to fix.... :)
08:29:46 <pokoko222> what a hell is difference between multitasking and multiprogramming?
08:33:11 <Saizan> ManateeLazyCat: i'll let you know when to pull :)
08:33:26 <ManateeLazyCat> Saizan: Thanks! :)
08:34:25 <tg_> pokoko222: multitasking is multiprogramming by a smart supervisor (operating system scheduler)
08:34:44 <ManateeLazyCat> siracusa: I'm scaning all new symbol above 2.18, I will notify you when i finish patches. :)
08:34:50 <pokoko222> tg_ oh so multitasking is a specific case of multiprogramming?
08:35:12 <tg_> pokoko222: yes, if you'd like. I'm sure the terms have been used confusingly in the past.
08:35:50 <siracusa> ManateeLazyCat: The needed Gtk+ version should be mentioned somewhere or even better checked before the installation of gtk2hs. Not sure if this is possible.
08:37:06 <tg_> pokoko222: multiporgramming is akin to older computing models (like time sharing) where you rely more on the individual programs to give up control on their own accord, rather than having execution control taken from them by the OS
08:37:19 <ManateeLazyCat> siracusa: We use "version macro" in gtk2hs code, if you just have old gio/gtk, gtk2hs won't compile new APIs. :)
08:37:40 <ManateeLazyCat> siracusa: Like you problem is i missing some "version macro" to wrap new APIs.
08:38:35 <siracusa> ManateeLazyCat: Ah, I see.
08:42:06 <conal> ooh.  i like luqui's latest blog post: http://lukepalmer.wordpress.com/2010/09/24/programs-are-made-of-ideas/
08:42:10 <mreh> question, what is `f`ing the function f called, and which way does it associate?
08:42:27 <mreh> that's two questions really
08:42:39 <benmachine> mreh: you can provide an infix declaration
08:42:47 <benmachine> infixr 0 `seq` -- for example
08:42:56 <benmachine> default is infixl 9
08:43:01 <benmachine> as with other operators
08:43:14 <benmachine> don't know what it's called though, I'd look it up in the report
08:43:19 <mreh> benmachine: thanks
08:43:32 <mreh> I didn't know where to look, so I thought it quicker to ask :*)
08:56:03 <mm_freak> ski: yeah, i thought so
08:59:23 <UNIX107> Hi all world , i wants some tutorial about Haskell and his use to analysis /var/log/mailog :) thanks a lot , i need it so much
08:59:59 <Lemmih> ?where lyah
09:00:00 <lambdabot> http://www.learnyouahaskell.com/
09:00:21 <Lemmih> UNIX107: ^^ lyah is pretty good.
09:00:48 <UNIX107> thanks :)
09:01:37 <UNIX107> i can use haskell to analys maillog in real time?
09:01:41 <UNIX107> i t s possible?.
09:01:45 <Lemmih> UNIX107: Yes.
09:01:50 <UNIX107> Cool :)
09:02:04 <Botje> haskell is exactly as powerful as every other language there is
09:02:13 <Botje> it's just a whole lot more expressive
09:02:52 <pozic> It's just less complete.
09:03:17 <Saizan> but it's almost as cool as bayes' theorem
09:05:15 <ski> what do people think about special-casing shortcuts like `foo ... [] = whatever' when that case will be handled correctly anyway, but where not doing that special case ends up having to traverse (and possibly copy) some other structure ?
09:05:19 <mm_freak> pozic: no, it's equally complete, because it's more complete in other areas
09:05:54 <benmachine> ski: more laziness = more better
09:06:20 <mm_freak> benmachine: not always
09:06:24 <benmachine> ski: a comment that "we have this case to avoid traversing x even though we'd get whatever anyway" would go a long way
09:06:34 <benmachine> mm_freak: no, but often
09:06:43 <mm_freak> also in general a pattern match against a case, which is the only one left, often isn't any lazier
09:07:01 <mm_freak> if (x:xs) doesn't match, then matching against [] isn't any more eager than _
09:07:13 <benmachine> mm_freak: if it avoids traversing some structure I was assuming it would also avoid evaluating that structure
09:07:32 <Saizan> in most cases where ski's question would apply you're not pattern matching at all
09:07:37 <Saizan> or maybe all cases?
09:07:56 <Nibble> !top10
09:08:01 <Nibble> no statserv
09:08:03 <benmachine> of course, if in ski's case matching [] forces the list that's interesting
09:08:27 <ski>   intersect _ [] = []
09:08:31 <ski>   intersect [] _ = []
09:08:32 <ski>   intersect (x:xs) ys = (if x `elem` ys then (x :) else id) (intersect xs ys)
09:08:50 <ski> (e.g.)
09:09:04 <benmachine> ah
09:09:07 <benmachine> hmm
09:09:22 <Saizan> intersec [] _|_ = _|_ there, but could be []
09:09:47 <benmachine> Saizan: well sure but one of intersect [] _|_ and intersect _|_ [] has got to be _|_
09:09:50 <megajosh2> > intersect [] undefined
09:09:51 <lambdabot>   []
09:09:57 <Saizan> though it'd be hard to exploit that, so maybe it's better to symmetric
09:10:13 <benmachine> ski: I'm inclined to leave that case out so that it's lazy in the second argument
09:10:22 <benmachine> like, would you define xs ++ [] = xs
09:10:32 <megajosh2> > intersect [] $ error "failed to aim nuclear missles at commies"
09:10:32 <lambdabot>   []
09:10:37 <benmachine> you wouldn't, even though it's a similar case, because that would break cycle xs = xs ++ cycle xs
09:10:42 <ski> benmachine : ok .. and if strictness properties aren't affected ?
09:10:47 <aristid> > flip intersect [] $ error "failed to aim nuclear missles at commies"
09:10:48 <lambdabot>   *Exception: failed to aim nuclear missles at commies
09:11:07 <megajosh2> Hmm...
09:11:50 <bos> interestingly, zip is stricter than it needs to be.
09:12:02 <benmachine> ski: it sounds like an optimisation, then, and whether I'd put it in probably depends on how likely I thought the function was to need optimising
09:12:13 <ski> benmachine : the `fix' thing is a good point
09:12:17 <bnery> tnx zygoloid! :)
09:12:21 <megajosh2> > let f n = \n' -> n + n' in f 5 6
09:12:22 <lambdabot>   11
09:13:35 <mm_freak> ski: you said it's impossible to write (a non-diverging) mfix for ContT…  is this true for CPS-based monads in general?
09:13:47 <conal> there's a laxer zip in the lub package.
09:13:51 <mm_freak> because my ChoiceT is also implemented by using CPS, but it's not quite like ContT
09:14:10 <djahandarie> What are some applications you guys think you would need to use a dependent-typed language like Agda rather than Haskell? 
09:14:23 <benmachine> djahandarie: proving x + y == y + x
09:14:29 <benmachine> that is pretty much the only thing I can do in agda
09:14:32 <djahandarie> I mean something real-world
09:14:33 <mm_freak> djahandarie: something using modular arithmetic
09:14:34 <benmachine> and I can't do it in haskell
09:14:50 <mm_freak> (+) :: Mod 101 -> Mod 101 -> Mod 101
09:14:57 <ski> mm_freak : i'm not sure .. possibly specific properties of such cases will not violate the laws that are expected to hold
09:15:27 <djahandarie> I.e., you are handed a spec at your job and you decide you need to write that program in Agda -- what would that spec look like that made you reach that decision?
09:15:46 <bos> conal: is your laxer zip non-strict in one or both arguments?
09:16:01 <ski> mm_freak : iirc, some of Magnus Carlsson's papers enumerate some law candidates for `mfix'
09:16:03 <conal> bos: both
09:16:09 <conal> bos: that's the tricky bit
09:16:19 <mm_freak> ski: thanks
09:16:34 <bos> conal: i figured :-)
09:16:42 <bos> conal: are you using unamb magic in there somewhere?
09:16:50 <conal> bos: definitely!
09:17:27 <ski> "parallel or" ftw !
09:17:29 <bos> yay magic :-)
09:17:46 <conal> yay denotationally simple & precise magic
09:18:10 <benmachine> the magic's still slow though isn't it?
09:18:22 <conal> here it is: http://hackage.haskell.org/packages/archive/lub/0.1.2/doc/html/src/Data-Lub.html
09:19:39 <conal> benmachine: probably.  i don't have benchmarks.  i don't know how much perf improvement can come from outside of the RTS.  haven't given up trying.
09:20:08 <conal> my guess is that, like laziness, as more uses of lub show up, there will be more motivation to improve performance.
09:21:07 <conal> i also added laxer if-then-else (due to luke palmer) and either: http://hackage.haskell.org/packages/archive/lub/0.1.2/doc/html/src/Data-Laxer.html
09:21:24 <conal> hm.  forgot to ack luke there.  will fix.
09:21:39 <chrisdone> why and how does cabal install always install parsec 2.1.0.1 instead of the latest version 3? it drives me bonkers
09:21:57 <dcoutts_> chrisdone: version 2 is the default/preferred version
09:22:08 <dcoutts_> you can ask for version 3 if you want it
09:22:20 <chrisdone> I know I can do that
09:22:33 <chrisdone> .. every time I install a package that uses parsec
09:22:47 <chrisdone> when will 3 become preferred?
09:22:53 <dcoutts_> packages that use parsec should indicate if they need version 2 or 3
09:22:58 <dcoutts_> or that they work with both
09:23:14 <chrisdone> can I specify for my own packages that X version is preferred or does Hackage do something special for parsec?
09:23:14 <dcoutts_> chrisdone: when the package maintainers propose it for the Haskell Platform
09:23:40 <chrisdone> I see
09:23:49 <dcoutts_> chrisdone: there's a command line flag --preferred and an equivalent persistent version in the ~/.cabal/config and a set of globals from hackage.
09:24:25 <dcoutts_> the globals are set (on behalf of) the package maintainers
09:24:25 <chrisdone> `preference`?
09:24:32 <dcoutts_> erm, yes, sorry
09:24:47 <dcoutts_> the new hackage server makes it much easier for the maintainer to set the preferred version
09:24:47 <chrisdone> cool, I'll add parsec>=3
09:24:54 <conal> i think there's a nice use of lub (generalized unamb) for lazy arithmethic.
09:25:04 <dcoutts_> chrisdone: it makes it easy for them to release new experimental versions without breaking everything
09:25:16 <conal> if it works out, i'll blog-post
09:25:21 <chrisdone> dcoutts_: sure
09:25:27 <dcoutts_> chrisdone: but we accept that cabal ought to make it clearer to users when it's picking not-the-latest and why
09:27:06 <chrisdone> sure, it confused me 'orribly. cabal install parsec doesn't actually say anything about it. it just downloads 2.1.0.1
09:27:37 <conal> i've been using gitit lately for my personal thought-journalling.  what a delightful piece of software!
09:27:54 <chrisdone> I suppose this was in the release notes on one of those days I did a cabal update; cabal install cabal-install and it's my fault for not reading them
09:28:03 <chrisdone> conal: cool!
09:28:04 * hackagebot lub 0.1.3 - information operators: least upper bound (lub) and greatest lower bound (glb)  http://hackage.haskell.org/package/lub-0.1.3 (ConalElliott)
09:28:28 <dcoutts_> chrisdone: na, we don't expect people to read release notes, we're happy to change cabal to meet expectations
09:28:45 <dcoutts_> and it's become clear that this in particular is confusing behaviour
09:28:58 <dcoutts_> partly because hackage always shows you the latest version, not the preferred version
09:29:06 <chrisdone> yeah
09:29:48 <chrisdone> I suppose the new hackage will solve issues like this
09:30:08 * chrisdone excited
09:31:46 <dcoutts_> chrisdone: yeah, it's much better about showing that, see:
09:31:47 <dcoutts_> http://sparky.haskell.org:8080/package/parsec
09:32:04 <dcoutts_> see the info link about the preferred versions
09:32:32 <dcoutts_> and how it shows the latest 2.x version by default, with the later version numbers in a different colour
09:32:53 <chrisdone> I should really read more about cabal and cabal-install. one day last week I logged on and ran my usual build script and a bunch of packages were broken, I cried inside. somewhere some time the day earlier I must've installed some packages that somehow broke my existing ones but yeah I get baffled by Cabal and do a complete fresh install fairly often, I might spend this evening just reading about it and the whole diamond dependency
09:32:53 <chrisdone> issues and PVP
09:33:06 <chrisdone> oh nice I didn't see there was a beta one running
09:33:09 <Igloo> What's the status of the new hackage? The SoC project is done now, right?
09:33:15 <dcoutts_> Igloo: right
09:33:28 <chrisdone> dcoutts_: yeah, that's cool
09:33:39 <dcoutts_> Igloo: GraceNotes will be presenting at the HIW next week
09:33:50 <Igloo> dcoutts_: But when will the switch be flipped?
09:33:52 <dcoutts_> and we'll discuss the changeover plan then
09:34:22 <dcoutts_> he's already been working on changeover issues, including getting live mirroring working so we can run the two in parallel for a while
09:34:38 <chrisdone> excellent
09:34:41 <dcoutts_> and it can import the old hackage data ok
09:35:44 <Igloo> OK, good stuff
09:36:03 <dcoutts_> chrisdone: when you say a bunch of packages were broken, do you mean that existing installed packages were broken, or that compiling packages from source now broke because of changed deps?
09:37:42 <benmachine> conal: btw, the hackage comment for 'glbs' is wrong, and the glbBottom message for the Either instance is "glb: bottom (glb: bottom (Left/Right mismatch))" which is kinda redundant
09:37:54 <benmachine> eeer, *haddock comment
09:37:59 <chrisdone> dcoutts_: existing packages were broken, so my cabal configure couldn't get past 'X is broken because it depends on broken or nonexistant package X-a8s7d6f8s7d' or something like this. I should've studied it more but I was supposed to be working on the project so I wiped everything and reinstalled. I think sometimes installing a package again changes the hash or something of the already existing package, and ones that depend on it
09:37:59 <chrisdone> break, no?
09:38:04 <conal> benmachine: thanks!  will fix pronto.
09:38:27 <dcoutts_> chrisdone: right
09:38:34 <dcoutts_> chrisdone: thanks, just checking
09:38:52 <benmachine> dcoutts_: is it easy or sensible to configure cabal to "never touch these packages ever"
09:38:58 <conal> oh, oops!  a more serious problem.  bottom is a bogus identity element for glbs.
09:39:15 <dcoutts_> benmachine: no and maybe.
09:39:22 <chrisdone> dcoutts_: yeah it was probably that, but somehow a fundamental package like time or haskell98 or something broke and I just couldn't recover from it and had to reinstall GHC. as a kind-of-solution I've started doing a ghc-pkg check after a cabal install
09:39:28 <conal> i'd need a top.  hm.
09:40:16 <benmachine> yeah I was thinking, there are packages that stuff depends on and can't be reinstalled, so those packages must not be changed
09:40:23 <dcoutts_> benmachine: what you'd what are "installed" constraints. That is always pick an installed version of this package. That's not currently supported (though it should not be too hard). It might be sensible in some cases.
09:41:00 <benmachine> dcoutts_: so you'd always pick an installed version, even if that meant that you couldn't satisfy the dependencies as a result?
09:41:01 <dcoutts_> benmachine: In the general case cabal needs to be able to rebuild packages, so by telling it not to then sometimes you will find you simply cannot install something (because it needs a package to be rebuilt against different versions of its deps).
09:42:04 <dcoutts_> benmachine: suppose your package depends on package A, and A depend on parsec. If A got built against parsec 2 but your package needs parsec 3 then we have to rebuild A against parsec 3.
09:42:35 <benmachine> dcoutts_: so with the installed constraint, you'd be unable to install your package that depended on A at all?
09:42:38 <dcoutts_> benmachine: so if you constraint cabal to pick an installed version of A then we would fail to find an install plan.
09:42:43 <benmachine> right
09:42:46 <benmachine> yes, that sounds sensible
09:42:50 <dcoutts_> benmachine: right, if your package needs parsec 3
09:42:58 <chrisdone> why can't a library or program be built against two packages that depend on two versions of the same library? is this a limitation of GHC's build system?
09:43:11 <dcoutts_> chrisdone: no, it's a limitation of information.
09:43:32 <dcoutts_> chrisdone: if it compiles then it'll link ok, the problem is we don't know if it'll compile.
09:44:07 <ManateeLazyCat> siracusa: Still there?
09:44:09 <benmachine> chrisdone: if those packages expose the types in the underlying library in their API, your package couldn't plug the output of one into the input of the other
09:44:24 <dcoutts_> chrisdone: with parsec you typically use it in a "private" way, that is you do not export things from your package that mention types from the parsec package. So in that case it'd work to use parsec 3 here and 2 there, because they are never unified.
09:44:25 <siracusa> ManateeLazyCat: Yes
09:44:32 <chrisdone> dcoutts_: I thought that sometimes linking fails too?
09:44:59 <dcoutts_> chrisdone: no, linking is fine. You can link multiple versions of a package (but not multiple instances of the same version of a package)
09:45:10 * hackagebot lub 0.1.5 - information operators: least upper bound (lub) and greatest lower bound (glb)  http://hackage.haskell.org/package/lub-0.1.5 (ConalElliott)
09:45:24 <chrisdone> ahh
09:45:24 <conal> oops.  one more lub fix to go.
09:45:27 <dcoutts_> chrisdone: but if you swap the example to be say bytestring then you'll likely find that it does not compile because bytestring does get used in interfaces, so the versions must match.
09:45:54 <chrisdone> oh, so in general I can't assume that I can ignore the "build may fail" warning
09:45:58 <dcoutts_> chrisdone: and cabal cannot tell which scenario we've actually got, so it makes a conservative assumption.
09:46:03 <conal> thanks goodness for cabal-make ("make release")
09:46:07 <chrisdone> dcoutts_: sure
09:46:09 <dcoutts_> chrisdone: right
09:46:30 <dcoutts_> chrisdone: that's why the warning it there :-)
09:46:49 <chrisdone> seems fair enough
09:47:11 * hackagebot lub 0.1.6 - information operators: least upper bound (lub) and greatest lower bound (glb)  http://hackage.haskell.org/package/lub-0.1.6 (ConalElliott)
09:47:16 <conal> okay.  maybe i'm done hackage-spamming for now.
09:47:33 <ManateeLazyCat> siracusa: Can you pull gtk2hs darcs again? I have push new patch to fix compile problem.
09:48:16 <ManateeLazyCat> siracusa: Please let me know if you have other problem.
09:48:27 <chrisdone> dcoutts_: has there been a command proposed to automatically update the versions of my dependencies so that all references to a package refer to the same one? it just seems I have to do this manually when I encounter a package which users a newer version of a library X, oh I have to recompile everything that uses X in order to use these two libraries together
09:48:55 <chrisdone> i.e. after installing the latest ByteString, cabal update-dependent-upon bytestring?
09:48:56 <dcoutts_> chrisdone: that's exactly what cabal install does.
09:49:12 * hackagebot download-curl 0.1.3 - High-level file download based on URLs  http://hackage.haskell.org/package/download-curl-0.1.3 (DonaldStewart)
09:49:13 <chrisdone> O_o
09:49:15 <tommd> I think he wants it for _all_ installed packages.
09:49:44 <tommd> so he doesn't have to run: mapM_ (cabal install) [p | p <- packages, p `dependsOn` bytestring]
09:49:57 <chrisdone> right
09:50:01 <dcoutts_> tommd: oh I thought he wanted it just for all the (indirect) deps of his package
09:50:10 <dcoutts_> not the reverse deps of a package
09:50:30 <siracusa> ManateeLazyCat: So can I keep 2.18 or do I have to update?
09:50:46 <ManateeLazyCat> siracusa: Keep 2.18.
09:51:17 <ManateeLazyCat> siracusa: That's function that missing in gio manual, and gtk2hs.el haven't scan correctly.
09:51:30 <c_wraith> dons: what's new in the new version of download-curl?
09:51:45 <chrisdone> dcoutts_: well, anyway, ignore my complaints, I should check what I'm doing properly and check the trac for tickets. you're very gracious in listening to problems :-)
09:51:59 <dcoutts_> chrisdone: so you want to take all currently installed packages that depend on some version of foo, and if necessary rebuild them to use the latest (or a specific version) of foo ?
09:52:06 <ManateeLazyCat> siracusa:  g_mount_get_default_location in gio-2.24, i have add necessary macro make you can compile gio on 2.18
09:52:34 <geheimdienst> @hackage old-locale
09:52:35 <lambdabot> http://hackage.haskell.org/package/old-locale
09:52:49 <dcoutts_> tommd: btw, that'll work in the next version, you can do: cabal install world foo-1.0
09:53:08 <geheimdienst> ^^ so what's the story on this package? description says "This package provides the old locale library. For new code, the new locale library is recommended." but i can't find any new locale thing anywhere
09:53:12 <tommd> ahh, cool.  I think that will solve your problem, chrisdone?
09:53:35 <dcoutts_> tommd: that'll ask to install all the "world" packages simultaneously (and thus consistently) with foo-1.0
09:54:10 <conal> benmachine: please let me know if you spot any other goofs.
09:54:53 <tommd> dcoutts_: Great, this will come in handy.
09:55:01 <benmachine> conal: sure, it's interesting stuff :)
09:55:07 <conal> :)
09:55:15 <tommd> esp with me having a larger and larger out-of-hackage library collection.
09:55:27 <conal> i suspect a lot of lazy functional programming is stricter (and thus less modular) than need be.
09:55:30 <dcoutts_> tommd: the tricky thing is that consistently installing the world packages is often impossible.
09:56:11 <tommd> dcoutts_: Could you define "the world packages" and clarify that last?
09:57:47 <siracusa> ManateeLazyCat: Great, gio now builds fine. :-)
09:57:58 <ManateeLazyCat> siracusa: Thanks for your report! :)
09:58:40 <dcoutts_> tommd: those packages that you explicitly installed (as opposed to deps they pulled in that you don't really care about)
09:58:45 <siracusa> ManateeLazyCat: I'll try to install the other packages also now.
09:59:36 <dcoutts_> tommd: when you ask cabal to install a bunch of packages the implicit assumption is that you want to be able to use those together and so their deps need to be consistent (ie use the same versions)
09:59:40 <ManateeLazyCat> siracusa: I have fix gio bugs on my local repository, and still in testing, after then just "IO Pixbuf" need fix, then gtk2hs-0.12.0.
10:00:05 <dcoutts_> tommd: that degree of consistency gets increasingly difficult the more packages you've got.
10:00:53 <dcoutts_> tommd: for world you might be happy with a lower degree of consistency where each package is internally consistent but you're not guaranteed to be able to use arbitrary pairs of installed packages together
10:03:27 <tommd> So world is everything installed locally?
10:04:04 <dcoutts_> tommd: to a first approximation, yes
10:04:49 <dcoutts_> tommd: if you cabal install B and it depend on A, then we only add B to the world set. It's the "interesting" ones you care about.
10:05:11 <dcoutts_> and if you upgrade ghc then nothing is installed, but the world set persists, so you can restore your packages by cabal install world.
10:06:28 <benmachine> dcoutts_: so cabal is finally tracking installations separately from using ghc-pkg?
10:07:02 <dcoutts_> benmachine: no, it still does not track what is installed
10:07:32 <benmachine> but it tracks the world set?
10:07:47 <dcoutts_> benmachine: right, just what you asked it to install, not what is installed.
10:08:52 <benmachine> has cabal-install not been modified since may, or am I looking at the wrong darcs
10:08:59 <ManateeLazyCat> siracusa: I need off now, please let me know if you have any problem with gtk2hs darcs. :)
10:09:38 <dcoutts_> benmachine: http://darcs.haskell.org/cabal-install
10:10:10 <dcoutts_> benmachine: so yes, May.
10:10:17 <benmachine> oh right, okay
10:10:46 * dcoutts_ has been a little busy finishing his thesis
10:11:08 <benmachine> sure, it just surprised me because all these things have happened that I haven't heard about :P
10:11:14 <benmachine> I assumed they were recent developments
10:11:40 <dcoutts_> the 'world' stuff is new in the 0.9.x dev series
10:16:03 <dstcruz> is there anyway to make ghci garbage collect something?  I have "file <- readFile largeFile", and would like to get ghci to garbage collect file.
10:16:36 <Botje> it can only be garbage collected if nothing else references it
10:17:30 <wjt> Does anyone know if any code at all was written for the gobject-introspection summer of code project?
10:17:41 <Jafet> let file = (), depending on whether ghci is smart enough to know the previous file is inaccessible
10:17:59 <djahandarie> readFile is lazy so there won't even be anything in file until you request it
10:21:08 <tommd> dstcruz: You're real problem is ghci taking too much memory I take it?
10:21:12 <tommd> ghci doesn't free memory.
10:21:14 <tommd> fyi
10:21:23 <Botje> it LIBERATES it!
10:21:34 <tommd> so it might have GCed 'file' but the memory is now part of the ghci nursery
10:21:52 <glguy> dstcruz: You can't use readFile if you care if or when the file will ever be closed
10:21:57 <tommd> That is, if you unbound 'file', however that's done I don't recall.
10:22:00 <vanadium> nothing frees memory
10:22:14 <c_wraith> Doesn't GHC 7 support freeing memory?
10:22:26 <dstcruz> how can I "unbind" a variable in ghci?
10:22:34 <tommd> GHC 7 supports a new type checker.  I haven't heard anything about freeing memory.
10:22:46 <c_wraith> dstcruz :reload should do it
10:22:47 <dstcruz> let file = (), I guess
10:22:59 <c_wraith> oh, if you want to unbind only one variable?
10:23:16 <dstcruz> c_wraith: problem is that :reload throws away all the other stuff I have set up.
10:23:24 <glguy> dstcruz: shadowing [file] won't necessarily close the file descriptor
10:23:47 <c_wraith> if you want to close the file descriptor of something you read lazily, you'll have to read to the end of input
10:23:48 <dstcruz> I thought readFile close the descriptor
10:24:10 <glguy> dstcruz: it might at some point
10:25:39 <c_wraith> tommd, http://hackage.haskell.org/trac/ghc/ticket/698  looks like it was actually in 6.12
10:30:54 <tommd> c_wraith: Thanks ,that was a good read.
10:31:05 <mreh> what's the other way of commuting a tree of lists to a list of trees
10:31:17 <mreh> I can think of one obvious one, one not so obvious
10:31:30 <mreh> but I can't see how it could be done with traversable
10:33:27 <tehgeekmeister> what's a good haskell-friendly datastructure for doing efficient approximate matching on strings (based on some edit distance metric, for example)?  or where would be better to look for that?
10:35:15 <ski> mreh : a kind of zipping ?
10:35:36 <easy4> is there an analogue to a zipper for sequences, i.e. just left and right movement?
10:35:48 <ghulette> looking for an explanation of how the "-- |" style comments work.  some kind of javadoc-ish thing?  googling for "haskelldoc" directs me to a mailing list
10:36:03 <ddarius> @where haddock
10:36:03 <lambdabot> http://www.haskell.org/haddock/
10:36:17 <ghulette> cool, thanks ddarius
10:37:42 <tehgeekmeister> oh, is that how haddock works?
10:37:46 <tehgeekmeister> good to know.
10:38:09 <mreh> ski: tree zipping?
10:38:44 <mreh> like transposing the lists and placing them in trees
10:39:30 <ski> mreh : `forall a. Tree [a] -> [Tree a]' seems to me to be somehow `zip'-like
10:40:13 <ddarius> :t Data.Traversable.sequence
10:40:14 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
10:41:09 <ski> mreh : also see ddarius' suggestion
10:41:31 <mreh> I'm trying to implement sequenceA infact
10:41:58 <mreh> maybe I'm confused about the capability of Applicative 
10:42:30 <megajosh2> dfd
10:42:33 <megajosh2> Wtf?
10:42:40 <ski> @type Data.Traversable.sequenceA
10:42:41 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
10:42:59 <ski> mreh : what is your `Tree' ?
10:43:54 <mreh> ski: a binary tree with an Empty constructor
10:44:03 <mreh> leaf contructors seem redundant to me
10:45:07 <ddarius> So data Tree a = Empty | Branch (Tree a) a (Tree a) ?
10:45:14 <mreh> aye
10:45:26 <Capadocia> Hi, friends.
10:45:55 <Capadocia> I'm trying to learn Haskeel. It'd not difficulty.
10:46:14 <mreh> this is a good place to come
10:46:38 <Capadocia> Yeah, I see.
10:48:29 * hackagebot xilinx-lava 5.0.0.4 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.4 (SatnamSingh)
10:51:54 <chrisdone> hot diggidy
10:52:18 <sproingie> leaf constructor is for when you want to enforce data only being in leafs
10:52:50 <sproingie> data LeafyTree a = Leaf a | Branch (LeafyTree a) (LeafyTree a)
10:53:13 <sproingie> also enforces two leafs
10:53:33 * hackagebot secrm 0.0 - Example of writing "secure" file removal in Haskell rather than C.  http://hackage.haskell.org/package/secrm-0.0 (JonSlenk)
10:54:01 * ski usually calls the non-empty constructor `Node', in the non-leafy-tree case
10:54:25 <sproingie> yah, i wouldnt call it "LeafyTree" either :)
10:55:07 * chrisdone cohugs copumpki-
10:57:58 <djahandarie> Watch out, copumpki- has some sharp line sticking out of him
10:58:10 * chrisdone looks down at the gash in shock
10:58:36 <ski> mreh : i think `sequenceA :: forall a i. Applicative i => Tree (i a) -> i (Tree a)' should be quite simple, using `pure' and `liftA3'
10:59:10 <ski> (or `(<*>)' (and possibly `<$>') instead of `liftA3' if you prefer)
11:05:50 <ddarius> "Et tu, pumpkin?"
11:06:39 <chrisdone> :P
11:06:42 <heatsink> Is there an overview of how Haddock is designed?  I'm annoyed by the lack of type family instance support and I want to evaluate what it'd take to fix it.
11:17:45 <EvanR-work> html templating for a haskell webapp, how
11:18:10 <chrisdone> EvanR-work: xhtml library, blaze-html library, htemplate library, template library, etc.
11:18:10 <Zao> With one of the templating libraries, I'd expect.
11:18:15 <EvanR-work> ah there you are
11:18:18 <Zao> <- helpful
11:18:18 <EvanR-work> been looking for you
11:18:26 <djahandarie> EvanR-work, with a combinator
11:18:33 <djahandarie> A bunch of which were just listed
11:18:37 <EvanR-work> right
11:19:21 <EvanR-work> what if i wanted more a erb style where html files have expressions which evaluate to a string or strings?
11:19:41 <EvanR-work> chrisdone: have you used, know about, etc, direct-fastcgi?
11:19:56 <sm> heatsink: I just looked at the code, it's not too bad. It uses GHC
11:20:21 <megajosh2> Hmm
11:20:28 <megajosh2> Something isn't working right
11:20:29 <djahandarie> EvanR-work, for example in blaze, you get renderHtml :: Html -> ByteString
11:20:31 <chrisdone> EvanR-work: I know about it, haven't used it
11:20:46 <EvanR-work> the latest version is inoperable
11:20:53 <sm> EvanR-work: there's also hamlet
11:20:56 <EvanR-work> simply does nothing but immediately exit
11:20:59 <djahandarie> EvanR-work, there are different renderHtmls depending on how you want it to be rendered for example
11:21:09 <chrisdone> just use the fastcgi library
11:21:32 <EvanR-work> i changed one of the functions and rebuilt it, now it works great
11:21:35 <chrisdone> direct-fastcgi completely disregards the good work done by the CGI library and implements its own 
11:21:53 <EvanR-work> his blog says he hates it and his is better
11:22:15 <heatsink> sm: I'll go to the source then.  Do you mean it uses GHC for parsing?
11:22:18 <EvanR-work> djahandarie: i see
11:22:29 <EvanR-work> renderHtml would substitute values or something?
11:22:44 <EvanR-work> or you could use more complex expressions
11:22:50 <EvanR-work> map fold etc
11:23:11 <EvanR-work> chrisdone: his opinions may be outdated
11:23:23 <EvanR-work> as far as the 'not working' part goes
11:24:34 <djahandarie> EvanR-work, hm? Basically you take a bunch of functions like 'a' and 'em' which have types Html -> Html (inner html of the tag and the resulting html)
11:24:51 <djahandarie> EvanR-work, and then you finally render your Html-typed value to a ByteString with renderHtml
11:24:53 <EvanR-work> ah so youd write it in haskell
11:24:57 <djahandarie> Yes
11:25:18 <djahandarie> There is a library to convert html to blaze if you have html already written
11:25:37 <EvanR-work> im struggling with the merits and web-emotional reasoning behind all the different approaches
11:25:40 <EvanR-work> hamlet?
11:25:59 <vanadium> if you do not construct xhtml by using an xml library and putting together the dom by hand you are doing it wrong!!
11:26:25 <EvanR-work> theres no way im using xhtml or anything xml related
11:28:32 <chrisdone> blaze-html is nice to write in, it exploits the do notation
11:28:39 <ddarius> EvanR-work: You should use XSLT.
11:28:39 <EvanR-work> whats the most popular one, blaze?
11:28:47 <EvanR-work> ddarius: Dx
11:29:00 <chrisdone> like this:
11:29:00 <chrisdone> html $ do head $ title "Woo!"
11:29:01 <chrisdone>           body $ p "Yahoo!"
11:29:01 * heatsink is downloading abt 1 patch per second 
11:29:29 <chrisdone> EvanR-work: html is probably the most used but that's because it's old. blaze-html is nice to write and fast
11:29:29 <EvanR-work> yeah ive been doing stuff like that in javascript
11:29:34 <mee> chrisdone: reminds of me CGI.pm (and that's not a flattering comparison)
11:29:58 <chrisdone> mee: go to hell Perl vermin!
11:29:59 <EvanR-work> do looks like a way to make a list
11:30:08 <EvanR-work> and concat it
11:30:53 <mornfall> Is there a blaze-pandoc?
11:32:10 <mee> chrisdone: :) Template Toolkit on the other hand is quite nice.
11:33:46 <EvanR-work> what about this idea, load templates which look like html but have expressions to be evaluated, which is basically a lambda calculus on strings. when provided with 'inputs' you concat a copy of the parse tree together and send it out lazilly
11:34:37 <EvanR-work> then designer doesnt need to learn a new markup language
11:35:08 <EvanR-work> yet he is faced with the undeniable applicability of functional programming ;)
11:35:47 <chrisdone> let the designer write his precious HTML with his crappy dreamweaver
11:36:06 <Zao> The last time I had to emit HTML, I just used the template package.
11:36:06 <chrisdone> make it into a template and embed your perfect haskell-EDSL-generated code into it
11:36:24 <chrisdone> Zao: yeah I'm going to update hpaste to use it
11:36:29 <EvanR-work> sounds like a high effort turn around time
11:36:40 <chrisdone> I avoided it because I didn't want to have to convert all my strings to Data.Text, but then had to do that anyway
11:36:56 <EvanR-work> template package eh
11:37:45 <megajosh2> hmm
11:37:56 <EvanR-work> megajosh2: stop shrinking!
11:38:01 <dmwit> I find category theorists' laxness about identity somewhat confusing at times.
11:38:17 <chrisdone> dmwit: why?
11:38:38 <megajosh2> I'll just stick to this prefix
11:38:51 <EvanR-work> chrisdone: whats your take on database stuff, hdbc?
11:39:03 <dmwit> For example, I'm reading an article that just defined a property "free". i.e. it has a definition of the form, "A category is called 'free' if ..."
11:39:16 <dmwit> Then it goes on to talk about _the_ free category.
11:39:47 <dmwit> To my mind, there ought to be a proof somewhere that there is only one category satisfying the property "free" to warrant that kind of language, but to a category theorist it's fine because all categories that are free are isomorphic...
11:40:32 <ezyang> dmwit: Are you a categorist?! :-P 
11:40:41 <dmwit> Apparently not.
11:41:39 <azaq23> Do I see this right that I can define either sequenceA or traverse when I instantiate a new Traversable? Since they are defined in teams of each other in the class source (didn't knew you could do that there)
11:41:54 <dmwit> Yes, that's right.
11:42:04 <azaq23> ok ty
11:45:07 <chrisdone> EvanR-work: it's okay. it's kind of like hsql and takusen. Takusen has one up on the previous in that it uses Data and Typeable to automatically serialize queries of fields x,y,z and pass them to your function foo x y z :: Int -> String -> Maybe UTCTime -> ..., whereas in hsql and HDBC you have to manually convert each field with fromSql or similar
11:45:48 <Cale> dmwit: uhh, what?
11:46:07 <Cale> dmwit: There are many free categories, one for every directed graph.
11:46:13 * glguy remembered Takusen using typeclasses rather than typeable and data for that
11:46:20 <EvanR-work> chrisdone: oh nice
11:46:24 <dmwit> Cale: Yes, I was being ever so slightly sloppy in my explanation of the kind of thing that confused me.
11:46:33 <dmwit> Cale: That is my fault, not the article's. But my complaint stands.
11:46:57 <chrisdone> EvanR-work: you also have the problem of constructing queries using strings which (1) fails because it has no compile time checking and WILL cause bugs, (2) is just cumbersome, (3) relational databases aren't supposed to be used with strings
11:46:58 <dmwit> Cale: Category theorists totally conflate things whenever they're isomorphic.
11:46:58 <Cale> Well, if there's only one of something up to isomorphism, it's usually okay to ignore the distinction.
11:47:02 <Cale> Yep.
11:47:19 <Cale> Because isomorphic things can't be distinguished by categorical properties.
11:47:32 <EvanR-work> chrisdone: i was asking earlier about a relational db for haskell thats not sql, or at least has a better than sql language
11:47:33 <dmwit> so egotistical
11:47:41 <dmwit> As if categorical properties are the only things that matter. =D
11:47:43 <glguy> chrisdone: "Typeable constraint is to prevent the leakage of Session and other
11:47:43 <glguy> marked objects."
11:47:55 <EvanR-work> chrisdone: you are interested in this area? or know stuff?
11:48:02 <chrisdone> EvanR-work: haskelldb is nicer for compile time checking and writing queries because you specify the exact type of your tables and their mappings to the database, so all field types are checked, and provides a nice query monad
11:49:06 <chrisdone> EvanR-work: well imo it would be better to forget SQL and go straight to the database's direct API, you can still use the relational database which *is* a good idea
11:49:32 <Cale> dmwit: In set theory, you can say "the product of sets" and, provided you've fixed a particular definition, mean a single distinguishable set. But the categorical property that product satisfies, the thing which really makes it a product, only defines the set up to isomorphism.
11:49:32 <EvanR-work> hah.
11:49:36 <EvanR-work> chrisdone: what directapi ;)
11:49:40 <medfly> hi
11:50:17 <dmwit> Yep, and I'd prefer if they used phrases like "a product" rather than "the product", for exactly that reason.
11:50:41 * geheimdienst meows softly, rolls over, and looks sleepily at medfly from his place on the window sill
11:51:06 <medfly> you are not a cat
11:52:15 <Xaphiosis> I wonder if you could nudge me in the right direction... I'm trying for a state monad containing an IntMap Int
11:52:19 <chrisdone> glguy: yeah I remember the query function's behaviour itself is derived with classes. it'd be nice to use data/typeable to query a whole row into a data value, matching fields up
11:52:23 <ddarius> medfly: How do you know?
11:52:36 <Xaphiosis> and I can't seem to write the type of that state monad
11:52:45 <EvanR-work> chrisdone: a whole row is oftentimes not what i want
11:52:54 <medfly> cats are dumb
11:53:00 <dmwit> Xaphiosis: State (IntMap Int) a -- ?
11:53:14 <Xaphiosis> let me check that
11:53:25 <EvanR-work> i want like A B C D where A=expr B=f g a b C=... etc
11:53:54 <dmwit> Xaphiosis: "check that"? Maybe you'd better give a few more details about your high-level goals and the low-level details of how you're trying to achieve that.
11:53:58 <Xaphiosis> dmwit: yes, I forgot the last 'a' ... I was getting kind errors
11:54:02 <EvanR-work> join, union, intersect, project, extend
11:54:04 * geheimdienst ceases to be insulted at his catitude being questioned, now that medfly has suggested that geheimdienst is smart
11:54:04 <dmwit> hokay
11:54:05 <jpcooper> hello
11:54:07 <chrisdone> EvanR-work: ah, so you could use lenses on your types
11:54:16 <jpcooper> what's the best way to handle an array that may be too big to fit in memory?
11:54:17 <c_wraith> medfly: I mistook a friend of mine for her cat in another channel last night.  Turns out she was typing stuff that looked like nonsense intentionallly.
11:54:19 <EvanR-work> so process the raw data in haskell?
11:54:25 <chrisdone> EvanR-work: anyway, union, join, project, intersect, etc. are easy with haskelldb
11:54:49 <EvanR-work> haskelldb is sounding good, i have only heard its unusable
11:55:00 <geheimdienst> c_wraith: what did you say to her in the period when you thought she was the cat?
11:55:07 <Xaphiosis> dmwit: I had "State (IntMap.IntMap Int)" and got a "Expecting an ordinary type, but found a type of kind * -> *" and so was confused. problem solved!
11:55:14 <chrisdone> EvanR-work: the problem is mostly getting from entity(s) to types automatically which is where typeable and lenses come in. I have a paper on it but I can't share it atm
11:55:20 <c_wraith> geheimdienst, I just greeted her cat.
11:55:27 <Xaphiosis> dmwit: thank you
11:55:40 <geheimdienst> that's polite
11:55:44 <EvanR-work> chrisdone: entity?
11:55:49 <chrisdone> EvanR-work: it's totally usable, I'm using it at work, but it *is* in a state of disrepair, definitely. I can help you get it working if you come across issues
11:56:03 <chrisdone> EvanR-work: well, table/view
11:56:13 <EvanR-work> like, 'result set' ?
11:56:51 <chrisdone> sure, I guess
11:57:01 <EvanR-work> hm i dont see any docs
11:57:05 <EvanR-work> or marketting info
11:57:13 <ddarius> dmwit: As Cale said, people say "the product" all the time when talking about sets and rarely pick out a particular construction to use, and you can tell the difference in set theory.
11:57:45 <chrisdone> EvanR-work: yeah, I think it's mostly dead. the paper is *kind* of helpful, but not really because it's mostly using hugs's brilliant t-rex records extension. hold up
11:58:26 <Cale> Though there is one construction for pairs which is probably more common in books on it than most others.
11:59:04 <Cale> (I'm thinking (a,b) = {{a},{a,b}})
11:59:08 <EvanR-work> is the basic idea to construct a query in haskell using combinators, which is type safe and returns a list of 'type of result'
11:59:10 <dmwit> yes, exactly
11:59:14 <chrisdone> EvanR-work: if you download and build this, you can install with documentation: http://hackage.haskell.org/package/haskelldb that's useful to have and this page is kind of reliable but not so much http://haskelldb.sourceforge.net/archive/ it's useful for examples, though
12:00:22 <EvanR-work> ill have to check that after work, im already using unknown and apparently unsupported fgci lib, might as well go all out ;)
12:00:24 <Cale> But it doesn't really matter which construction you choose. When you say "the product", unless you then use some abstraction-breaking property of that construction, everyone is free to choose whichever construction they want.
12:00:39 <dmwit> ddarius: I don't think Cale said that. But I agree that it is somewhat unclear to talk about "the product" in set theory without choosing a particular representative and projections.
12:01:10 <chrisdone> EvanR-work: sure. e.g.:
12:01:10 <chrisdone> do p <- table person
12:01:10 <chrisdone>    restrict $ p!age .==. 20
12:01:10 <chrisdone>    project $ p!something << p!age -- or just return p
12:01:42 <chrisdone> haven't actually used project in any of my code yet but I think that's the correct usage
12:02:01 <EvanR-work> interesting
12:02:08 <EvanR-work> monadic query language
12:02:17 <chrisdone> yeah it's nice
12:02:20 <roconnor> <dmwit> Cale: Category theorists totally conflate things whenever they're isomorphic.
12:02:28 <roconnor> dmwit: they only conflate naturally isomorphic things
12:02:29 <roconnor> :)
12:02:38 <chrisdone> I haven't made a single mistake (that I'm aware of) in writing queries with this library
12:02:44 <ddarius> dMazz: Cale didn't say all of that, no.
12:02:51 <dmwit> roconnor: um, really?
12:02:57 <roconnor> dmwit: actually it was a big thing for me.
12:03:03 <dmwit> roconnor: What does naturally isomorphic mean, then?
12:03:08 <Cale> All mathematicians conflate things whenever it is convenient and reasonable to do so.
12:03:19 <EvanR-work> chrisdone: what are the prospects for this project to get back on its feet?
12:03:21 <roconnor> dmwit: when I realized that for fin dim. vector spaces only the double dual is naturally isomorphic.
12:03:25 <ddarius> Cale: Yeah, I was going to mention that this is common behavior for mathematicians in general.
12:03:29 <roconnor> dmwit: and the dual, is isomorphic, but not naturally.
12:03:45 <ddarius> Also, category theory does have terminology and constructions in cases where exact equality is required.
12:03:47 <Cale> Well, more specifically, whenever the differences between those things is being considered irrelevant for the discussion at hand.
12:04:03 <roconnor> dmwit: naturally isomorphic has something to do with functors ... I don't really know the definition :P
12:04:04 <Cale> (i.e. it would break an abstraction barrier to discuss it)
12:04:12 <chrisdone> EvanR-work: it just depends if anyone can be bothered picking it up. I *might* pick it up if I can sprinkle some typeable or template haskell onto it to make deriving the entity types automatic, because using dbdirect sucks and composing them manually sucks too
12:04:24 <ddarius> roconnor: A natural isomorphism is just an isomorphism of functors.
12:05:04 <roconnor> ddarius: oh okay, so the key is that taking the dual of a fin. dim. vector space is more than just a function, it is a functor!
12:05:08 <Cale> Just like in Haskell when using the library Data.Set, it's uncommon to discuss the different possible Set a values which give rise to a set having a specific set of elements.
12:05:24 <Cale> (different underlying tree structures)
12:05:24 <EvanR-work> chrisdone: yes ive been wondering about that
12:05:33 <EvanR-work> impedance mismatch
12:05:47 <dmwit> I haven't understood this yet.
12:06:11 <dmwit> Can we say any two products of A and B are naturally isomorphic?
12:06:22 <dmwit> What are the functors that are isomorphic to each other?
12:06:48 <ddarius> roconnor: Categorists usually identify any isomorphic thing, they just aren't usually interested in individual objects of a category.  For example, you can have AxB without having AxC, but it's rare for categorists to consider such cases.
12:06:48 <dmwit> oh
12:06:51 <chrisdone> EvanR-work: I can't really paste the whole code (we'll be open sourcing it sometime anyway), but here's a sample of my use of it to give you an idea: http://hpaste.org/paste/40094/composing_fields
12:06:58 <dmwit> I guess the functors are between cone categories or something like that, huh?
12:07:17 * dmwit ponders a bit more
12:07:31 <roconnor> ddarius: I don't know.  For me it was a big deal to understand the difference between dual spaces and double dual spaces
12:07:48 <ski> (.. traditional set theory ought to be deprecated)
12:07:54 <roconnor> I don't think I would have gotten the difference without category theory.
12:08:07 <Cale> Better still than naturally isomorphic is uniquely isomorphic
12:08:19 <ddarius> dmwit: The full use of "objects are naturally isomorphic" is: two functorial expressions are naturally isomorphic in these given variables which means the functors got by lambda abstracting those variables are isomorphic.
12:08:25 <chrisdone> EvanR-work: looking at it, it looks maybe possible to automatize
12:08:45 <EvanR-work> chrisdone: almost the api i was thinking of using, except for the monad thing
12:08:54 <roconnor> ski: how about SEAR or ETCS?
12:09:05 <EvanR-work> query returns results, insert delete etc return integer
12:09:07 * ski has no idea what those are
12:09:20 <EvanR-work> would have used SQL except now im not like sql as much
12:09:24 <EvanR-work> need a better language
12:09:25 <ddarius> dmwit: In a nutshell, it doesn't make sense to say two objects are naturally isomorphic.
12:09:30 <EvanR-work> and better implementations
12:09:32 <Cale> dmwit: There's a unique arrow between any two products of the same objects which makes the obvious diagram ocmmute.
12:09:34 <Cale> commute*
12:09:51 <dmwit> ddarius: Okay, good. I was furrowing my brow quite a bit after your last claim there for exactly that reason.
12:09:59 <ski> Cale : or at least uniquely naturally isomorphic
12:10:04 <roconnor> ski: ah, "Structural Set Theory" is what I'm looking for
12:10:13 <roconnor> http://ncatlab.org/nlab/show/structural+set+theory
12:10:24 <dmwit> Wait, so, if there were a category that didn't have products, but for which there was *a* product of A and B, category theorists wouldn't call that product *the* product?
12:10:46 <Cale> dmwit: Uh, no, they would.
12:10:50 <ski> if it's something similar to e.g. Taylor's Zermelo Type Theory, then it is ok, i think
12:11:01 <dmwit> But those two products wouldn't be naturally isomorphic.
12:11:04 <ddarius> dmwit: They would, they probably wouldn't talk about it though unless A and B were particularly interesting objects.
12:11:14 <Cale> dmwit: Did you ignore my last few lines?
12:11:27 <dmwit> Well, your last two lines don't seem to mesh with ddarius'.
12:11:32 <dmwit> That is where my confusion lies.
12:11:47 <chrisdone> EvanR-work: this is actually quite a low-level part of the application. I have several databases, the other is using Takusen. the actual 'business logic' is using my own simple query language which just pattern matches on terms, e.g. give me AuthorSubmissions 9 [], returns AuthorSubmissions 9 [Submission ...]. I'm thinking of promoting it to a simple prolog-like language with rules etc :p I'd prefer to use a logic language to query my
12:11:48 <chrisdone> database than a kind of dumb relational query
12:12:11 <ddarius> I don't see any contradiction between what I said and what Cale said.  In fact, we aren't even talking about the same aspects.
12:12:29 <dmwit> No, I see now that you aren't.
12:12:53 <EvanR-work> chrisdone: ah higher level than relational algebra
12:12:57 <Cale> I'm just pointing out that natural isomorphism is weaker than unique isomorphism, and here we have unique isomorphism.
12:13:10 <dmwit> uh
12:13:25 <dmwit> really weaker?
12:13:30 <ddarius> dmwit: A common definition of categorical product uses adjunctions, but that only defines a product making functor and will fail if you don't have every product in the category.
12:14:00 <dmwit> Natural isomorphism just seems different, not weaker or stronger.
12:14:03 <ddarius> Representability provides a(n elegant) way of defining a particular product object without requiring all products.
12:15:13 <Cale> dmwit: Suppose we're in a setting where natural isomorphism makes sense to talk about, so we have some functors and a natural isomorphism between them. If we have a unique isomorphism between the corresponding images of objects under those functors, then we'll be forced to choose those unique maps for the components of a natural isomorphism
12:15:32 <Cale> Otherwise, there might be more than one natural isomorphism.
12:15:38 <dmwit> I'm not supposing the same things you are.
12:15:48 <dmwit> =P
12:15:57 <ddarius> Cale: You can have a unique isomorphism between objects with no functors around.
12:16:02 <dmwit> right
12:16:04 <Cale> ddarius: Right.
12:16:08 <roconnor> if you have two products of A and B that are not naturally isomorphic, then there could be (would be?) and external way of distingishing between those two products.  i.e. they could be related differently to the surrounding object by arrows is a fundamentally noticable way?
12:16:26 <roconnor> *in a fundamentally
12:16:29 <Cale> roconnor: err...
12:16:39 * roconnor is probably way off here
12:16:50 <ddarius> roconnor: Again, product forming functors are or are not naturally isomorphic.  The products themselves would only be isomorphic or not.
12:16:56 <Cale> Any two products of the same objects are uniquely isomorphic to each other (in a way that makes the obvious diagram commute)
12:17:24 <roconnor> ddarius: oh right
12:17:24 <ddarius> Any isomorphic objects are not distinguishable categorically within the category.
12:17:30 <chrisdone> EvanR-work: anyhoo, I might actually update haskelldb so that it builds on Hackage and add some documentation in the haddock docks themselves with examples, sounds like a better idea than making some random web page and letting it become dead again
12:17:45 <dmwit> Okay, I think I have a handle on what you're trying to tell me now, at least: isomorphism is good, but strong language is even more appropriate when you have something like natural isomorphism or unique isomorphism.
12:17:53 <roconnor> ddarius: oh right
12:17:59 <EvanR-work> chrisdone: yeah
12:18:02 <Cale> dmwit: Yeah
12:18:21 <ddarius> dmwit: Unique isomorphism in particular, which is what universal constructions give you.
12:18:26 <dmwit> ...and generally with products, or in my case, with free categories over an algebraic signature, you will have such a thing.
12:18:39 <roconnor> ddarius: because if A and B are isomorphic, and there is an arrow f : A -> C, then there is an "equivalent" arrow B -> C defined by iso1;f.
12:19:15 <Cale> dmwit: right
12:19:27 <chrisdone> EvanR-work: let me know how you get on. I'm outta here
12:20:34 <Cale> dmwit: In fact, it's easy enough to go with a canonical construction of the free category anyway, so even if you're unhappy with many categories being isomorphic to it, you can just pick the canonically constructed one.
12:21:29 <Cale> (the one whose arrows are the paths of the original digraph)
12:24:03 <dmwit> Cale: Actually, I think they're talking about a slightly different free category than the usual one over graphs. But yes, I understand your point.
12:24:33 <Cale> But yeah, it comes down to the same thing when someone says "the natural numbers", and doesn't expect to be accosted by people asking whether they mean the natural numbers where the successor function sends x to x union {x}, or the natural numbers where the successor function sends x to {x}, or some other construction :)
12:24:55 <ddarius> roconnor: It takes more than that, but more or less yes.  More to the point, for any commutative diagram written using one object we can write an equivalent commutative diagram using isomorphic objects.
12:25:59 <Cale> Sometimes it matters, but use of the word "the" sets the expectation that it doesn't.
13:05:07 <mietek> http://jpmoresmau.blogspot.com/2010/09/haskell-neural-network-plugging-space.html
13:05:41 <mietek> This kind of conclusion makes me wonder, why do we even bother with laziness.
13:08:18 <roconnor> mietek: I find the problem is that usualy people don't make their code lazy enough
13:09:20 <McManiaC> how can you convert a ascii string to utf8?
13:09:28 <vanadium> id
13:09:34 <McManiaC> iso/latin1 not ascii
13:09:38 <vanadium> encode package
13:09:52 <vanadium> err, encoding, sorry
13:09:53 <EvanR-work> id is the coolest encoder
13:10:21 <EvanR-work> one is oneself's encoding
13:10:27 <geheimdienst> it encodes anything as anything, as long as the input format is the same as the output
13:10:35 <vanadium> geheimdienst: Or a subset of
13:10:42 <vanadium> McManiaC: What do you have right now? A file or something?
13:10:44 <mietek> McManiaC: ISO Latin 1 is UTF8.
13:10:52 <vanadium> mietek: That sounds wrong
13:10:54 <roconnor> mornfall: no it isn't
13:10:56 <roconnor> er
13:10:59 <roconnor> mietek: no it isn't
13:11:09 <EvanR-work> no it aint
13:11:18 <vanadium> ä is a single byte in latin1 and multiple ones in utf-8
13:11:53 <mietek> Right.  My bad, I was thinking about the codepoints themselves.
13:12:05 <EvanR-work> again with the id
13:12:08 <chrisdone> hmm. DeriveDataTypeable doesn't derive for parameterized types, yes?
13:12:31 <roconnor> EvanR-work: and some people think id is useless and shouldn't be defined ...
13:12:32 <roconnor> bah
13:12:37 <EvanR-work> lol
13:12:45 <JoeyA> McManiaC> how can you convert a ascii string to utf8? : just wondering, why do you want to do that?
13:12:53 <chrisdone> wait, no. DeriveDataTypeable doesn't derive for data types with fields of kinds other than *, right?
13:12:58 <EvanR-work> we should also disallow the integer zero
13:13:23 <JoeyA> If you're working with AttoJSON, its showJSON function produces UTF8 now, not ascii/latin1
13:13:29 <JoeyA> (as of today)
13:13:32 <EvanR-work> if youre trying to add zero to something, youre doing it wrong
13:13:34 <chrisdone> JoeyA: noice
13:13:36 <McManiaC> I have "lÃ¸ve you! â¥" and want "løve you! ♥" - which looks to me like some wrong iso/utf8 mistake
13:13:41 <vanadium> why does its showJSON functionnot produce a String?
13:13:46 <McManiaC> *encoding
13:14:02 <JoeyA> AttoJSON's showJSON produces a ByteString
13:14:05 <vanadium> Right
13:14:09 <vanadium> Atto! I get it!
13:14:10 <JoeyA> oh
13:14:11 <JoeyA> not
13:14:25 <JoeyA> because readJSON takes a ByteString
13:14:47 <vanadium> McManiaC: If you have broken text in a String, you already read it wrong I guess
13:15:03 <vanadium> String is a list of unicode codepoints, so it is kinda decoded, and not either utf8 or latin1
13:15:07 <JoeyA> By the way, why doesn't hackage have documentation for new packages?  Does it get generated automatically at some interval or something?
13:15:32 <EvanR-work> vanadium: on the other hand there is String -> String 'utf8 encode/decode' in Codecs
13:15:38 <McManiaC> vanadium: my string comes from the "parse" function in Codec.MIME.String.Parse: http://hackage.haskell.org/package/mime-string
13:15:55 <EvanR-work> have fun figuring out the semantics of that one ;)
13:16:16 <vanadium> Codec.MIME.String.Parse has a convertAsciiToUtf8 :: String -> String function, I wonder what that does
13:16:23 <JoeyA> import Data.ByteString.UTF8 ; import Data.ByteString.Char8; fromString . unpack
13:16:37 <roconnor> vanadium: oh the wrongness
13:16:43 <vanadium> BS.unpack $ convertFuzzy Transliterate "US-ASCII" "utf8" $ BS.pack xs
13:16:45 <JoeyA> (ascii/latin1 -> UTF-8 bytestring conversion)
13:16:49 <benmachine> huh, this is weird: if you have multiple Executable sections in a cabal file, they share build-deps
13:16:52 <EvanR-work> vanadium: wasnt thinking of that one
13:17:00 <vanadium> JoeyA: Yeah, that sounds about right
13:17:05 <McManiaC> vanadium: using convertAsciiToUtf8 will result in "lve you! e"
13:17:18 <vanadium> Try what JoeyA said
13:17:44 <vanadium> Except is that not the wrong way around
13:19:20 <McManiaC>   lÃÂ ¸ve you! Ã¢ÂÂ ¥
13:19:25 <McManiaC> not exactly :S
13:19:46 <chrisdone> n/m I'll ask on haskell-cafe
13:20:05 <vanadium> > putStrLn (Data.ByteString.UTF8.toString (Data.ByteString.Char8.pack "lÃ¸ve you! â¥"))
13:20:06 <lambdabot>   Not in scope: `Data.ByteString.UTF8.toString'Not in scope: `Data.ByteString...
13:20:14 <vanadium> prints "løve you! �"
13:20:20 <vanadium> Sorry about your heart :'(
13:20:22 <mreh> how do you get by the overloading of sequence and mapM in Traversable
13:20:34 <mreh> you either use one or the other and import the list instance
13:20:36 <JoeyA> unpack the bytestring to get a list of truncated chars, then fromString it to get UTF-8.  Right?
13:20:46 <mreh> explicitly
13:20:48 <vanadium> JoeyA: I figured we started with a String
13:20:50 <maurer_> mreh: Look up the "hiding" keyword
13:20:52 <McManiaC> ah! vanadium, JoeyA - love you guys ;D
13:20:52 <JoeyA> oh
13:21:00 <roconnor> mreh: import Prelude hiding (sequence)  or
13:21:13 <roconnor> import qualifed Traversable  as T
13:21:20 <JoeyA> then fromString will turn it into a UTF-8 bytestring.
13:21:47 <McManiaC> but gread idea, JoeyA 
13:21:50 <JoeyA> unpack will just get you a list of truncated chars
13:21:53 <McManiaC> gotta remember that :)
13:21:56 <JoeyA> (which represent the Unicode)
13:23:44 <EvanR-work> utf8-string package, Codec.Binary.UTF8.String, encodeString :: String -> String ;)
13:24:18 <EvanR-work> decodeString works great with urlDecode after getting %codes 
13:24:28 <EvanR-work> to get unicode back from the url
13:24:31 <EvanR-work> IRI
13:26:27 <mreh> traverse pure . replicate 3 $ [1,2,3] 
13:26:32 <mreh> > traverse pure . replicate 3 $ [1,2,3] 
13:26:33 <lambdabot>   Not in scope: `traverse'
13:26:44 <mreh> silly cow
13:26:52 <mreh> > Data.Traverse.traverse pure . replicate 3 $ [1,2,3] 
13:26:53 <lambdabot>   Not in scope: `Data.Traverse.traverse'
13:28:33 <mreh> > Data.Traversable.traverse pure . replicate 3 $ [1,2,3] 
13:28:34 <lambdabot>   No instance for (GHC.Show.Show (f [[t]]))
13:28:34 <lambdabot>    arising from a use of `M755856...
13:29:01 <mreh> > Data.Traversable.traverse pure $ [[1,2,3],[1,2,3]] 
13:29:02 <lambdabot>   No instance for (GHC.Show.Show (f [[t]]))
13:29:02 <lambdabot>    arising from a use of `M643076...
13:29:13 <mreh> hmm
13:29:47 <mreh> works in ghci
13:30:03 <monochrom> ♥ haskell
13:30:26 <EvanR-work> then why dont you marry him
13:30:40 <McManiaC> monochrom: :D
13:30:46 <mreh> _
13:30:50 <monochrom> because he is married
13:31:17 <EvanR-work> polyandrous marriage then\
13:31:48 <mreh> civil partnership?
13:31:59 <EvanR-work> whatever you wanna call it
13:32:02 <mreh> it would be bigamistic, but shh
13:32:11 <EvanR-work> south park suggests 'butt buddies'
13:32:45 <mreh> bum chums
13:33:05 <monochrom> the monomorphism restriction applies
13:33:47 <mreh> why doesn't traversing [[1,2,3],[1,2,3]] give [[1,1],[1,2],[2,1]....
13:35:26 <Deewiant> > Data.Traversable.traverse pure $ [[1,2,3],[1,2,3]] :: [[[Int]]]
13:35:27 <lambdabot>   [[[1,2,3],[1,2,3]]]
13:37:42 <Cadynum> hi. this is strictly more a vim than haskell question, but someone here ought to have wondered the same. With the vim haskell plugin ( http://projects.haskell.org/haskellmode-vim ), is it possible to have the _t functionality always show in an additional statusline, changing depending on the cursor position
13:38:35 <geheimdienst> ... the monochromism restriction applies ...
13:39:07 <mreh> we want our freedom
14:05:03 * dstcruz finds hxt a bit hard to understand
14:06:00 <c_wraith> dstcruz, there's a reason why i use xml light instead :)
14:06:12 <mightybyte> There's a reason why Snap uses hexpat instead.
14:06:42 <mightybyte> Heist was originally written with hxt.
14:06:44 <kmc> ah arrows :)
14:07:34 <mightybyte> Without proc do, arrows are unwieldy.
14:11:50 <ddarius> So use the arrow notation.
14:12:12 <c_wraith> @src Arrow
14:12:12 <lambdabot> class Arrow a where
14:12:13 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:12:13 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:12:13 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:12:13 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:12:14 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:12:16 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:17:54 <osaunders> (Reading about newtype). Why is newtype necessary, couldn't GHC automatically treat data declarations with single type constructor and field as a newtype?
14:18:05 <ddarius> osaunders: No.
14:18:25 <osaunders> ddarius: Please continue...
14:18:50 <ddarius> newtype, data, and strict data all have different semantics.
14:19:00 <ddarius> The Report has an excellent section on this.
14:24:50 <osaunders> ... which I can't find.
14:24:55 <osaunders> 98 or 2010?
14:25:28 <ddarius> I'm sure it's the sections are identical in each.
14:26:41 <wbruce> Looking to define a function that 'take's the first n elements from a list that match a check, lazily; http://gist.github.com/596064 ideas?
14:26:48 <sm> hey all.. how do I get GHC to use the gold liniker ?
14:27:02 <sm> linker
14:27:28 <tommd> can it use gold successfully?  Have you tried just replacing your 'ld' with the gold binary?
14:27:46 <kmc> there was a wiki article on it too
14:28:01 <sm> well I'd prefer to leave ld where it is and just.. ok looking
14:28:04 <tommd> sm: -pgml
14:28:18 <tommd> that's the flag according to man.  Man is your friend.  Man is inherently good.
14:28:23 <kmc> :t catMaybes
14:28:24 <lambdabot> forall a. [Maybe a] -> [a]
14:28:28 <kmc> :t isJust
14:28:29 <lambdabot> forall a. Maybe a -> Bool
14:28:31 <kmc> wbruce, ^^^^
14:28:34 <kmc> from Data.Maybe
14:28:50 <kmc> take n . catMaybes
14:29:28 <scree_> wbruce: the version kmc gives is neater, but your given version actually works fine
14:29:33 <sm> not finding it on the net. tommd: thanks, uh man what ?
14:30:05 <sm> ah, go it
14:30:13 <wbruce> scree_: well, if the list is lazy, I don't want to try to call ownerOfPet on every element
14:30:34 <wbruce> I only need n Justs
14:30:37 <scree_> wbruce: it won't
14:31:00 <wbruce> ah, take handles it I guess
14:31:31 <scree_> > take 100 . catMaybes . fmap (\x -> if x > 100 then Just (x-100) else Nothing) $ [1..]
14:31:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:31:32 <wbruce> I'm still thinking imperatively I guess, thinking everything to the right is already evaluated in full
14:32:45 <EvanR-work> you could think of it like that, just infinite in that case
14:32:49 <kmc> that's not imperative vs. functional
14:33:05 <kmc> Haskell is *unusual* among functional languages for being lazy
14:33:12 <wbruce> kmc: point taken
14:33:40 <kmc> anyway what you have is basically «take n $ map fromJust $ filter isJust $ map ownerOfPet pets»
14:33:50 <osaunders> wbruce: Might be slightly cleaner if you had a hasOwner :: Pet -> Bool function, then you could just take n $ filter hasOwner pets
14:34:08 <ddarius> Haskell is unusual among languages for being lazy.
14:34:17 <EvanR-work> haskell is unusual
14:34:28 <ddarius> Haskell is.
14:34:30 <kmc> and this is the pattern of using a boolean test function followed by an "extraction" function that can crash at runtime
14:34:33 <kmc> and that's generally to be avoided
14:34:33 <EvanR-work> H
14:34:36 <scree_> :t mapMaybe
14:34:37 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
14:34:43 <wbruce> osaunders: yeah, true
14:34:55 <aristid> > take 100 . (>>= (\x -> guard (x > 100) >> return $ x - 100)) $ [1..]
14:34:56 <lambdabot>   No instance for (Control.Monad.MonadPlus ((->) a))
14:34:56 <lambdabot>    arising from a use of...
14:35:09 <aristid> > take 100 . (>>= (\x -> guard (x > 100) >> return (x - 100))) $ [1..]
14:35:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:35:12 <kmc> wbruce, you could also use list comprehension:   take n [ o | OwnedPet o <- pets ]
14:35:32 <kmc> pattern match failure in a "case" is a runtime error, but pattern match failure in a list comprehension just ignores that element
14:35:37 <kmc> that's one of their most useful properties
14:35:54 <scree_> (should have said ^^^ wbruce on :t mapMaybe)
14:35:56 <ddarius> catMaybes xs = [x | Just x <- xs]
14:36:17 <EvanR-work> :t (^^^)
14:36:18 <lambdabot> Not in scope: `^^^'
14:36:21 <kmc> @src catMaybes
14:36:21 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:36:25 <kmc> hehe
14:36:38 <scree_> @src mapMaybe
14:36:38 <lambdabot> Source not found. Maybe you made a typo?
14:38:20 <kmc> mapMaybe f xs = [x | (f -> Just x) <- xs]
14:38:24 <kmc> probably not ;)
14:39:02 <wbruce> kmc: nice point on failures in case vs list comprehension; thanks
14:39:07 <ddarius> > let mapMaybe f xs = [x | f -> Just x <- xs] in mapMaybe Just [1..3]
14:39:08 <lambdabot>   <no location info>: parse error on input `->'
14:39:16 <ddarius> > let mapMaybe f xs = [x | (f -> Just x) <- xs] in mapMaybe Just [1..3]
14:39:16 <lambdabot>   [1,2,3]
14:39:44 <ddarius> > let mapMaybe f xs = [x | (f -> Just x) <- xs] in mapMaybe (const Nothing) [1..3]
14:39:45 <lambdabot>   []
14:41:38 <scree_> > let mapMaybe = fmap catMaybes . fmap in mapMaybe Just [1..3]
14:41:39 <lambdabot>   [1,2,3]
14:49:55 <ddarius> > (0xA0 - 0x7C) `div` 2
14:49:56 <lambdabot>   18
14:50:06 <ddarius> > (0xA0 - 0x7C) * 2
14:50:07 <lambdabot>   72
14:58:09 <writer> Mathematicians rock!! http://www.wired.com/threatlevel/2010/09/intel-threatens-consumers/
15:01:02 <c_wraith> Heh.  It's *very* simple linear algebra to derive the master key, with enough HDCP devices cracked.  Anyone who's done any linear algebra should be able to manage it.
15:02:45 <medfly> I read an article today asking why in restaurants you don't put people in cages when giving them knives - after all, they've been used to attack people before... why risk it?
15:07:37 <Saizan> is there some standard syntax to specify on which subexpression you should apply the given equality when writing proofs in the "<expression> = { <why> } <other expression> ..." style?
15:09:06 <ddarius> Saizan: In a formal situation, it is almost always the top-level.  Complementary to that, you could have congruence laws to say where to apply the why.
15:10:01 <ddarius> E.g. Hom(FX,Y) ~ { hom-cong fx-is-gx refl } Hom(GX,Y)
15:10:41 <ddarius> In informal cases, you usually leave that to the reader.
15:11:53 <Saizan> yeah, i'm using congruence laws, but they are quite annoying because you've to duplicate the structure of the term
15:12:11 <ddarius> Indeed.
15:12:20 <roconnor> medfly: wait until someone in a restaurant uses a knife to chop off some patron's head
15:12:47 <roconnor> medfly: these sorts are security measures are always only reactive, not proactive
15:12:51 <ddarius> roconnor: I'm sure that's happened.
15:13:10 <roconnor> ddarius: really, someone's head cut off?
15:13:12 <ddarius> (Well, maybe not completely off.)
15:13:32 <ddarius> Let me tell you, cutting someone's head entirely off is pretty hard to do.
15:14:09 <roconnor> ya, I guess even with a steak knief it would be hard
15:14:36 <roconnor> okay, I'll accept stabbed to death.  I guess that may have happend.
15:55:25 <sm> all: I'm trying to fix haskell-mode's hoogle integration, when it runs command-line hoogle the output is always scrolled off-screen
15:55:34 <sm> has anyone out there done it ?
15:56:44 <zachk> @src iterate
15:56:44 <lambdabot> iterate f x =  x : iterate f (f x)
16:02:02 <kmc> i'm gonna cut your whole body off!
16:15:28 <siracusa> Is there a way to make GHC not compile the local version of a library, but to use the installed package instead?
16:17:25 <cadabra> One thing that's been on my mind lately is that it often feels like we write code backwards, e.g. f g h x should perhaps be x h g f. A lot of the time I catch myself writing h x, then moving left and adding g, and then again f. Does anyone else feel this way?
16:17:40 <ezyang> siracusa: Under what circumstance? 
16:17:41 <Martty> only asm programmers
16:18:05 <ezyang> cadabra: Write in CPS! 
16:18:55 <siracusa> ezyang: I have Test.hs in a directory with library modules and GHC seems to use these instead of the version installed as a package.
16:19:41 <ezyang> Try giving GHC -package module-3.2 ? 
16:19:45 <ezyang> also, are you using Cabal? 
16:19:56 <chrisdone> anyone got a function to take two Haskell ASTs and return whether they are exactly the same module renamed variables?
16:20:41 <applicative> cadabra, for f g h x, would you write 'the father of the guru of the husband of x' is backward, preferring 'x's husband's guru's father.'?
16:20:54 <applicative> rather, would you feel that it was backward...
16:21:22 <applicative> cadabra, but the other is the right way around.
16:21:41 <benmachine> siracusa: just... move the file? :P
16:21:46 <cadabra> I'd say I prefer the second.
16:22:13 <siracusa> ezyang: This doesn't help and Im not using cabal.
16:22:48 <siracusa> benmachine: Yeah, but it's a darcs file so 'm looking for a cleaner solution :-)
16:22:55 <ddarius> You can be like some crazies and redefine (.) to be flip ($) and write, x.h.g.f.  This has the benefit of matching with OOP and with a particular relational style.  (NOTE: Please, please don't do this, at least not with (.))
16:22:55 <siracusa> * I'm
16:23:00 <applicative> cadabra, it is a bit better I think, as English, but it doesn't seem to go too deep; the other doesn't seem backward, exactly
16:23:26 <benmachine> siracusa: go to a different directory, and ghc ../File.hs?
16:23:42 <chrisdone> ddarius: jinjing does this. reading his code was like reading ruby
16:23:52 <chrisdone> what has been seen cannot be unseen O_O
16:23:56 <cadabra> If you're using verbs, it does: eat . cook . get from fridge . egg --- vs --- egg . get from fridge . cook . eat
16:24:02 <ddarius> chrisdone: That was the (his) goal.
16:24:13 <applicative> ddarius, it's strange that people sneer at that sort of thing (I'd certainly oppose redefining (.)!); but eg with >>= we do it the other way
16:24:14 <chrisdone> ddarius: yeah
16:24:20 <cadabra> I suppose it's a question of declarative vs imperative.
16:24:29 <siracusa> benmachine: Ah, that's it, thanks
16:24:33 <ddarius> applicative: A lot of people prefer (=<<)
16:25:01 <applicative> ddarius, I would too, but it's obvious that it has direction too, though.  the thing on the right is 'coming first'.
16:25:24 <chrisdone> I like the a (b (c $ d)) to a . b . c $ d correspondance
16:25:52 <benmachine> >>= translates more smoothly into do-notation
16:26:00 <benmachine> which is probably why it's in the class
16:26:03 <benmachine> rather than =<<
16:26:08 <benmachine> (at a guess)
16:26:38 <applicative> cadabra, the declarative v. imperative element was what I was thinking was at the bottom of it.  youre thinking of the function names as like 'do this, then this', so they should be in that order (taking the left as 'first', in accordance with european languages)
16:26:48 * hackagebot hylolib 1.3.0 - Tools for hybrid logics related programs  http://hackage.haskell.org/package/hylolib-1.3.0 (GuillaumeHoffmann)
16:26:52 <ddarius> If you don't have do-notation (>>=) gets you much closer than (=<<).  In fact, other than refutable patterns, do-notation isn't much better than the explicit binds.
16:27:51 <HugoDaniel> :P
16:28:05 <applicative> ddarius, is it different in that respect from =<<, apart from maybe some interference of precedence
16:28:07 <HugoDaniel> i only use >>= for quick stuff
16:28:14 <ddarius> "hylolib" is perhaps not the most fortuitous naming...
16:28:19 <benmachine> ddarius: thing that annoys me about using it explicitly is parentheses, because $ tends to break things
16:28:30 <benmachine> hi, lol
16:28:37 <chrisdone> y hylo thar
16:29:04 * ddarius was more referring to the fact that it could be easily confused with a library of hylomorphism combinators.
16:29:06 <applicative> hylolib, short for hybrid logic.... really a bad idea.  
16:29:27 <applicative> ddarius, yes, its really unsound, in fact.
16:29:44 <applicative> ... for example, its name made it seem like it might be really interesting ....
16:30:05 <ddarius> "Hybrid logics" doesn't sound interesting?
16:30:44 <applicative> ddarius, I just don't know what it is, could mean anything.  Is there a familiar topic with that title?
16:31:10 <applicative> hmmm, HyLo.Model.Herbrand
16:31:13 <chrisdone> no one's got any code equivalence functions then
16:31:34 <benmachine> ddarius: oh, I assumed that was what it was
16:31:41 <benmachine> oh because I don't read
16:31:44 <benmachine> oh I am silly.
16:32:10 <ddarius> applicative: There is a specific notion of "Hybrid Logic" which, I assume, is what is being referred to.
16:32:43 <applicative> ddarius, thats what I was asking, it seemed plain there must be; I just wasn't familiar with one. 
16:33:22 <applicative> hpaste is back up, i see. 
16:37:58 <ddarius> @hackage strict
16:37:58 <lambdabot> http://hackage.haskell.org/package/strict
16:46:20 <benmachine> data Identity' a = Identity' !a is apparently not a functor
16:46:58 <benmachine> fmap (const () . undefined) $ Identity' () = Identity' ()
16:47:10 <benmachine> fmap (const ()) . fmap undefined $ Identity' () = undefined
17:04:27 <aavogt> benmachine: even with this as your instance:   fmap f ~(Identity' x) = Identity' (f x)
17:04:51 <benmachine> oh I hadn't thought of that
17:04:59 <benmachine> yeah that works
17:05:03 <benmachine> hmm
17:05:11 <benmachine> but strict maybe would therefore not be a functor, I guess
17:05:18 <c_wraith> my co-worker just discovered: forever $ print "\BEL"
17:05:25 <benmachine> haha
17:05:31 <benmachine> putStrLn surely >_>
17:05:35 <c_wraith> oh, right
17:05:39 <c_wraith> must have been
17:05:42 <Twey> Or just putStr
17:06:42 <benmachine> putStr . repeat $ "\BEL" -- more functional and ergo more better
17:07:05 <aavogt> type error there :)
17:07:06 <HugoDaniel> :D
17:07:25 <c_wraith> change the repeat to cycle
17:07:34 <aavogt> change the " to '
17:07:45 <c_wraith> my approach shaves bytes!
17:07:50 <c_wraith> bytes of source code matter! :)
17:08:02 <aavogt> hairy bytes
17:08:06 <c_wraith> err, shaves *byte*.. singular :)
17:44:35 <vanadium> So what is the hippest in light-duty parser combinators
17:46:28 <gwern> vanadium: 'take', 'drop', and pattermatching
17:46:33 <gwern> fo shizzle
17:47:42 <vanadium> There ought to be syntax sugar for 'a':'b':'c':'d':x
17:48:07 <aavogt> view patterns
17:48:24 <vanadium> Should be fine I guess
17:49:21 <aavogt> case "abcdefg" of (stripPrefix "abcdlol" -> Just xs) -> "z"; (stripPrefix "abc" -> Just xs) -> xs
17:49:26 <aavogt> > case "abcdefg" of (stripPrefix "abcdlol" -> Just xs) -> "z"; (stripPrefix "abc" -> Just xs) -> xs
17:49:27 <lambdabot>   "defg"
17:50:29 <aavogt> I don't trust myself to write   case splitAt 4 str of ("abc",rest)
17:55:28 <benmachine> vanadium: like, ("abcd" ++ x) as a pattern? worse than n+k :P
17:55:45 <ddarius> Curry has that.
17:56:58 <vanadium> benmachine: yeah
18:07:04 <vanadium> @pl \a -> b (c:a)
18:07:04 <lambdabot> b . (c :)
18:16:39 <Peaker> http://www.reddit.com/r/haskell/comments/did8l/list_leads_off_with_the_letter_lambda_%CE%BB/c10g7l6 <-- want review about accuracy of my explanation
18:19:01 <aavogt> function is data
18:22:30 <ddarius> Peaker: There is no "sort of."  foldr is the list catamorphism.
18:24:04 <Peaker> ddarius, I say sort of because I'd think that   foldr :: [a] -> (a -> b -> b) -> b -> b    would take a list and return its catamorphism, but the [a] arg doesn't seem to be part of the catamorphism
18:24:25 <Peaker> (and being stuck in the middle makes it "sort of")
18:25:26 <ddarius> foldr (modulo argument) doesn't return a catamorphism, it is the catamorphism.  You could say it returns the Church encoding.
18:26:06 <Peaker> Ah, I thought everybody's just being lax with terminology and that the Church encoding is the catamorphism, I'll correct it then
18:32:37 <augur> sup peep
18:32:37 <augur> s
18:38:22 <siracusa> I'm getting linker errors with bzlib-0.5.0.0 and I'm completely lost how to solve them: http://hpaste.org/40103/bzlib_linker_error
18:38:36 <ddarius> inf { p | ∀p'∈peeps. p > p' }
18:54:01 <empt> is here a bot? can it answer what the date today is?
18:54:14 <dons> your irc client should be able to.
18:54:17 <dons> ?tme
18:54:20 <lambdabot> Local time for dons is Fri Sep 24 18:53:54 2010
18:54:21 <dons> ?time
18:54:24 <lambdabot> Local time for dons is Fri Sep 24 18:53:57 2010
18:54:35 <empt> thanks I want the haskell
18:54:45 <empt> now I know :)
18:55:13 <empt> ?time
18:55:25 <medfly> lambdabot is a package no? :-/
18:57:22 <benmachine> lambdabot is a package on hackage yes
18:58:17 <dmwit> > 60000000 * 100 / 1024 / 1024
18:58:18 <lambdabot>   5722.0458984375
18:59:09 <djahandarie> Hackage package
19:02:08 <medfly> hackage package
19:02:10 <medfly> :o
19:02:35 <benmachine> wow, it's almost like the two names share an origin
19:03:08 <medfly> NO WAY
19:09:57 <dmwit> > length "There are fourty nine characters in this comment."
19:09:58 <lambdabot>   49
19:10:22 <Martty> > length "my penis"
19:10:23 <lambdabot>   8
19:10:28 <Martty> excellent
19:10:40 <dmwit> 8cm is rather short, no?
19:11:00 <monochrom> ...
19:11:12 <benmachine> dmwit: fourty?
19:11:33 <tensorpudding> it didn't say centimeters did it?
19:11:45 <ddarius> fjordy
19:11:54 <monochrom> 8mm
19:11:56 <benmachine> let's use natural units
19:11:58 <benmachine> so planck lengths
19:12:04 <Martty> > (length "of my own penis.") ++ "cm"
19:12:05 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:12:05 <lambdabot>         against inferred type ...
19:12:14 <Martty> sigh
19:12:20 <dmwit> Wow, you guys are really taking this insult to the next level.
19:12:27 <Martty> i almost append .to_s to it
19:12:29 <Martty> almost
19:12:56 <medfly> needs show.
19:12:58 <dmwit> > iterate (\x -> length $ "There are " ++ show x ++ " characters in this comment.") 0
19:12:59 <lambdabot>   [0,39,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,...
19:13:33 <medfly> Martty, needs moar haskell.
19:14:47 <Martty> filter (not . usefulLanguages) langsList = ["Haskell"]
19:17:20 <dmwit> > let tens = (["lol", "lol", "twenty ", "thirty ", "fourty ", "fifty ", "sixty ", "seventy ", "eighty ", "ninety "]!!); ones = (["", "one ", "two ", "three ", "four ", "five ", "six ", "seven ", "eight ", "nine "]!!); english n = tens (n `div` 10) ++ ones (n `mod` 10) in iterate (\s -> "There are " ++ english (length s) ++ "characters in this comment.") ""
19:17:21 <lambdabot>   ["","There are lolcharacters in this comment.","There are fourty characters...
19:17:37 <dmwit> > let tens = (["lol", "lol", "twenty ", "thirty ", "fourty ", "fifty ", "sixty ", "seventy ", "eighty ", "ninety "]!!); ones = (["", "one ", "two ", "three ", "four ", "five ", "six ", "seven ", "eight ", "nine "]!!); english n = tens (n `div` 10) ++ ones (n `mod` 10) in drop 30 $ iterate (\s -> "There are " ++ english (length s) ++ "characters in this comment.") ""
19:17:38 <lambdabot>   ["There are fourty nine characters in this comment.","There are fourty nine...
19:17:52 <benmachine> lolcharacters, eh
19:17:57 <benmachine> also, *forty :x
19:18:14 <dmwit> English is too irregular below twenty to really do that function properly in a one-off.
19:18:25 <dmwit> > let tens = (["lol", "lol", "twenty ", "thirty ", "forty ", "fifty ", "sixty ", "seventy ", "eighty ", "ninety "]!!); ones = (["", "one ", "two ", "three ", "four ", "five ", "six ", "seven ", "eight ", "nine "]!!); english n = tens (n `div` 10) ++ ones (n `mod` 10) in drop 30 $ iterate (\s -> "There are " ++ english (length s) ++ "characters in this comment.") ""
19:18:26 <lambdabot>   ["There are forty nine characters in this comment.","There are forty eight ...
19:18:42 <dmwit> hah, it cycles
19:19:23 <dmwit> > let tens = (["lol", "lol", "twenty ", "thirty ", "forty ", "fifty ", "sixty ", "seventy ", "eighty ", "ninety "]!!); ones = (["", "one ", "two ", "three ", "four ", "five ", "six ", "seven ", "eight ", "nine "]!!); english n = tens (n `div` 10) ++ ones (n `mod` 10) in drop 30 $ iterate (\s -> "This comment has " ++ english (length s) ++ "characters.") ""
19:19:24 <lambdabot>   ["This comment has forty characters.","This comment has thirty four charact...
19:19:47 <benmachine> ok now drop 2 :P
19:19:55 <dmwit> > let tens = (["lol", "lol", "twenty ", "thirty ", "forty ", "fifty ", "sixty ", "seventy ", "eighty ", "ninety "]!!); ones = (["", "one ", "two ", "three ", "four ", "five ", "six ", "seven ", "eight ", "nine "]!!); english n = tens (n `div` 10) ++ ones (n `mod` 10) in drop 30 $ iterate (\s -> "This comment has " ++ english (length s) ++ "characters.") "This comment has forty five characters."
19:19:56 <lambdabot>   ["This comment has forty characters.","This comment has thirty four charact...
19:20:17 <dmwit> I think I'm done playing around with this.
19:24:13 <tommd> preflex: seen catamorphism
19:24:14 <preflex>  Sorry, I haven't seen catamorphism
19:24:22 <tommd> sucks to  be you.
19:25:09 <zachk> preflex: seen preflex
19:25:10 <preflex>  what
19:25:18 <dmwit> haha
19:45:16 <napping> I want to "accept" on a socket, with a timeout. Is there a better way than arranging to throw myself an asyncrhonous exception?
19:46:10 <napping> timeout 1000000 $ block $ replicateM_ nclients $ accept sock >>= modifyIORef clients . (:) . fst
19:52:29 <Steve__> Hey everyone, I am curious to see what people use for datetime libraries
19:52:56 <Steve__> UTCTime seems to lack a lot of functionality like being about to convert to milliseconds
19:53:28 <Steve__> So since time is important I am sure that there is something out there that I should be using
19:54:14 <monochrom> UTCTime is more than milliseconds
19:54:30 <Steve__> right
19:54:52 <Steve__> but I need some form to be able to interop with other systems
19:55:15 <Steve__> i could go with something smaller but I don't need to
19:57:28 <monochrom> or rather, the NominalDiffTime component of UTCTime.
19:58:11 <monochrom> it is a Num instance. mutiplying by 10^blah and truncating is easy. choosing the right blah gives you milliseconds
20:07:15 <JoeyA> When people use iteratees, do they usually do it manually, or do they use a helper library?
20:07:30 <JoeyA> (if there really is much manual labor involved)
20:43:34 <dobblego> @src (++)
20:43:34 <lambdabot> []     ++ ys = ys
20:43:35 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:43:35 <lambdabot> -- OR
20:43:35 <lambdabot> xs ++ ys = foldr (:) ys xs
20:44:26 <jbauman> Choose your own implementation?
20:44:53 <dobblego> I prefer flip (foldr (:))
20:45:01 <dobblego> so do my students
20:48:22 <Ishpeck> Aren't students always obligated to prefer what the professor likes?
20:48:50 <dobblego> I'm not as professor, I teach voluntarily after conceding to the tertiary institution
20:49:09 <dobblego> I used to "teach" at universities fsvo teach
20:49:20 <Ishpeck> Oh, cool.  But the question still stands. :P  You're the teacher.  They have to like what you do. 
20:49:38 <dobblego> I make them derive their own answer; they often derive all of the above and prefer their own
20:49:54 <Ishpeck> That really is the best way to teach.  I commend you.
20:50:13 <medfly> fsvo?
20:50:25 <dobblego> for some version of
20:51:15 <medfly> http://www.wastedtalent.ca/comic/crazy-physics-dude ? :D
20:52:08 <napping> is haskell.org down now?
20:53:24 <napping> I was hoping to look up the new recursive do syntax
20:53:36 <napping> except now I think it won't do what I need anyway
20:57:52 * ddarius switched the segment and the offset.
21:26:47 <EvanR> 'communication with a forkOS thread is expensive' how expensive?
21:28:40 <djahandarie> EvanR, 'many times more expensive'
21:30:25 <roconnor> if ghc compiled to the iphone would threading work?
21:32:14 <EvanR> djahandarie: i just read that ;)
21:32:32 <EvanR> some people would call 2x more expensive 'many more' or 'very' expensive
21:33:18 <djahandarie> EvanR, PSOIX threads claim 20microsec per thread creation/exit, while GHC's user-level threads can do 1.3microsec per thread creation/exit
21:33:26 <djahandarie> POSIX*
21:33:29 <EvanR> also, im confused about the difference between forkOS and forkIO. i know ghc file and network operations work great in forkIO, but if i use 'any' foreign library it will block all forkIO threads?
21:34:54 <EvanR> and if i have one forkOS for that foreign library, my forkIOs will still run? 
21:35:01 <djahandarie> If you have a safe FFI  declaration then it will create its own thread
21:35:24 <EvanR> what kind of thread
21:35:49 <EvanR> generally, is forkOS only for dealing with thread local state?
21:35:49 <djahandarie> An OS thread... though I'm not sure it does that all the time
21:36:30 <djahandarie> I think so
21:37:33 <ezyang> GHC will spawn worker threads to ensure foreign calls don't block the rest of Haskell. 
21:37:37 <ezyang> there's no need for forkOS. 
21:37:55 <EvanR> as long as the bindings say 'safe' ?
21:38:05 <EvanR> or all the time
21:38:28 <ezyang> You're better off if you say safe. 
21:38:56 * EvanR checks the source
21:39:26 <djahandarie> Better safe than sorry!
21:39:37 <djahandarie> Practice safe FFI calls!
21:39:56 <EvanR> im not writing the ffi
21:40:06 <ezyang> Having been working on the RTS for the past month or so, I think there are certain conditions in which unsafe FFI calls won't cause /all/ of Haskell to stop running. 
21:40:28 <ezyang> But experimentally it does. 
21:40:37 <EvanR> but if i were, whats the difference between safe and unsafe
21:40:46 <ezyang> unsafe calls don't suspend the Haskell runtime: they just do the C call. 
21:40:51 <ezyang> erm, the Haskell thread. 
21:41:18 <EvanR> er
21:41:29 <EvanR> i thought that was safe
21:43:43 <EvanR> well im confused enough to say screw it and use forkIO for everything
21:44:03 <EvanR> and not worry about performance
21:47:43 <ddarius> Please read the documentation: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Concurrent.html#v%3AforkOS
21:47:55 <EvanR> i did
21:48:33 <EvanR> it doesnt say what unsafe does and there were two conflicting accounts above
21:48:37 <EvanR> or murky
21:48:51 <ddarius> The only difference between forkIO and forkOS is that the thread made by forkOS is bound which means it won't be migrated to another operating system thread.  That's it.
21:49:28 <ddarius> @where ffi
21:49:28 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:49:29 <EvanR> then my question retroactively mutates into one about ffi calls
21:49:53 <dmwit> > 0.9^3
21:49:54 <lambdabot>   0.7290000000000001
21:50:05 <EvanR> when and how it doesnt block all of haskell
21:50:19 <EvanR> or does it ever
21:50:40 <ddarius> The difference between safe and unsafe is unsafe FFI calls can't call back into the Haskell runtime.
21:51:06 <EvanR> does that have any effect on blockingness
21:51:38 <ddarius> I'm pretty sure it does not.
21:51:42 <EvanR> great
21:51:51 <EvanR> so ill just use -threaded and forkIO
21:52:06 <kmc> forkIO everything all the time
21:52:08 <ddarius> If you don't need to worry about thread local state, then use forkIO.
21:52:13 <kmc> better yet use my "spawn" library
21:52:19 <kmc> because i wrote it therefore it is awesome
21:52:24 <djahandarie> kmc, nice blog posts recently btw
21:52:30 <kmc> thanx
21:52:40 <ddarius> kmc: Have you syndicated it onto Planet Haskell?
21:52:51 <avenge> @where spawn
21:52:51 <lambdabot> I know nothing about spawn.
21:52:56 <kmc> ddarius, how do i do that?
21:53:07 <dmwit> avenge: Perhaps you're looking for #xmonad!
21:53:11 <djahandarie> kmc, chant to the lambdagods
21:53:29 <ddarius> kmc: Fourth question: http://planet.haskell.org/faq.html
21:54:14 <kmc> i see
21:54:26 <kmc> preflex, seen copumpkin
21:54:26 <preflex>  copumpkin was last seen on #haskell-blah 2 days, 17 hours, 44 minutes and 58 seconds ago, saying: geheimdienst: double tap home button, swipe the list of apps
21:59:04 <napping> EvanR: what sort of blocking are you worried about?
21:59:39 <EvanR> mysql
22:00:01 <kmc> you're ffi-ing to mysql?
22:00:04 <kmc> perhaps http://www.serpentine.com/blog/2010/09/04/dealing-with-fragile-c-libraries-e-g-mysql-from-haskell/ is relevant
22:00:08 <EvanR> hdbc
22:00:19 <EvanR> which uses mysql c library
22:00:23 <EvanR> which is complete trash
22:00:57 <kmc> "is forkOS only for dealing with thread local state?"  <-- yes, it only matters if an FFI lib cares about what OS thread something uses
22:01:04 <kmc> it's irrelevant to whether calls block or don't
22:01:12 <EvanR> ok
22:01:48 <kmc> did you see http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
22:02:01 <EvanR> still reading the first link
22:03:37 <kmc> avenge, i was referring to http://hackage.haskell.org/package/spawn
22:04:48 <EvanR> EINTR
22:05:17 <EvanR> damn, *thinks about the number of connect calls he did, and makes sure he checked for errors correctly*
22:06:26 <EvanR> if even one more 'gotcha' appears in writing correct C code, i think im going to switch to programming abaci exclusively
22:06:42 <kmc> yeah, computers are hard
22:08:00 <kmc> C doesn't have much artificial / accidental complexity; it just doesn't hide much of the complexity of the machine
22:08:30 <kmc> EINTR is an artifact of how POSIX decided to handle system calls and you can argue against that design decision
22:09:07 <EvanR> alternatively it could simply not fail if interrupted by a signal?
22:10:17 <dmwit> > 0.9^4
22:10:18 <lambdabot>   0.6561000000000001
22:10:35 <EvanR> after reading countless useless manpages on pthreads, it seems like multithreading was invented 40 years after the design of unix was solidified
22:10:42 <kmc> yeah
22:10:45 <kmc> pthreads is a mess
22:11:03 <EvanR> they used to fork processes instead and use IPC
22:11:21 <EvanR> why cant the OS just make *that* be effectively multithreading
22:11:36 <avenge> Any snap framework users here?  I'm looking for a multipart/form-data example...
22:11:56 <kmc> "DESCRIPTION
22:11:57 <kmc>        The  siginterrupt() function changes the restart behavior when a system call is interrupted by the signal sig.  If the flag argument is false (0), then system calls will be restarted if interrupted by the specified signal sig.
22:11:57 <kmc>        This is the default behavior in Linux.  However, when a new signal handler is specified with the signal(2) function, the system call is interrupted by default.
22:11:57 <kmc> "
22:12:41 <kmc> EvanR, on Linux they are pretty close -- there's a single system call to start a new thread/process, and you get to choose what stuff it shares with the parent
22:12:47 <kmc> i'm not sure if you're talking about semantics or implementation
22:13:07 <EvanR> so either mysql or ghc is not changing from the default behavior after installing a handler
22:13:27 <EvanR> kmc: 'user interface'
22:13:32 <kmc> ok
22:13:40 <EvanR> half of man pages could be eliminated by not ever speaking of threads
22:13:48 <napping> EvanR: the main blocking thing that comes to mind is that you can't garbage collect inside an unsafe call
22:14:01 <kmc> ezyang's link discusses that
22:14:23 <kmc> your Haskell program can't garbage collect at all if at least one of its threads is stuck in an unsafe FFI call
22:14:24 <avenge> Kind of joining in the middle of this, but it's probably better to use the POSIX sigaction() than signal(), as all that stuff is a lot more explicit.  (e.g., SA_RESTART)
22:14:37 <EvanR> are unsafe calls common?
22:14:49 <kmc> EvanR, is unsafePerformIO common?
22:15:00 <kmc> yes, in certain kinds of libraries with specific needs
22:15:01 <EvanR> is that auto unsafe?
22:15:08 <kmc> and after careful consideration of the implications
22:15:11 <kmc> i just meant by analogy
22:15:15 <EvanR> oh
22:15:43 <EvanR> the user of libs dont necessarily know whats safe and unsafe then
22:15:59 <EvanR> and a good rule of thumb is dont make calls you dont intend to return from
22:16:30 <kmc> i think you should always be safe unless profiling results indicate a bottleneck in the FFI context switch
22:16:40 <kmc> and then you'd consider carefully whether to use unsafe
22:17:28 <kmc> basically "unsafe" is intended for short quick functions that don't do very much
22:17:35 <kmc> like it's probably okay to make an unsafe call to sqrtf()
22:17:56 <EvanR> http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/ k this claims about half way through that unsafe calls back by preempted and has a test. im guessing this is only a problem without -threaded
22:18:18 <kmc> "back by preempted"
22:18:19 <kmc> ?
22:18:19 <EvanR> revising my english
22:18:28 <EvanR> unsafe calls cant be preempted
22:18:32 <kmc> unsafe calls cannot be preempted, regardless of -threaded or not
22:18:41 <kmc> "ghc -threaded --make UnsafeFFITest.hs cbit.o"
22:18:52 <EvanR> but thats not important if ghc runs the rest of the threads in another thread
22:19:01 <EvanR> barring gc
22:19:01 <kmc> it's important for garbage collection
22:19:05 <kmc> right
22:19:20 <EvanR> blog doesnt hit on that
22:19:26 <kmc> but if you are doing unsafe FFI calls then i'm not sure forkOS has any effect
22:19:31 <kmc> i mean i don't know what the guarantees are
22:19:39 <kmc> forkOS does not guarantee that Haskell eval happens in its own OS thread
22:19:57 <kmc> it's allowed to implement forkOS by bouncing those FFI calls to a dedicated FFI thread that is asleep most of the time
22:20:02 <kmc> but i don't think that'll happen for an unsafe call
22:20:11 <EvanR> forkOS sounds like its lower performance and guarantees immobile thread state
22:20:37 <kmc> forkOS guarantees that several FFI calls from that thread will be in the same OS thread
22:20:38 <kmc> that is all
22:20:44 <kmc> and i'm not sure that guarantee extends to unsafe
22:20:51 <kmc> i think you're getting into "does it happen to work on this particular version of GHC on this particular OS" territory
22:21:03 <kmc> anyway are you seriously considering unsafe?
22:21:11 <EvanR> lol
22:21:12 <kmc> or is this academic
22:22:02 <EvanR> 'i am not writing the ffi' 'but if i were...' 'user of lib may not know...' 'safe/unsafe not necessary advertised'
22:22:20 <EvanR> my question was whether to use forkIO or forkOS with mysql
22:22:46 <kmc> by "safe/unsafe not necessary advertised" you mean that i might publish a lib which makes an unsafe FFI call internally and not tell the user?
22:22:56 <EvanR> and i just wanted to know what safe/unsafe meant in that context if i happened to know what the bindings used
22:23:05 <EvanR> kmc: right
22:23:26 <EvanR> im saying im using libs and bindings not writing them
22:23:32 <EvanR> at the moment
22:23:43 <EvanR> but its been very educational
22:23:51 <kmc> well, it's like unsafeCoerce, if i write such a lib I have a responsibility to make damn sure it's really okay, and/or to document that my lib has this weird gotcha
22:24:24 <kmc> like if i unsafe ffi call sqrtf() i will say to myself "no sane platform will make a blocking system call from sqrtf()" and proceed in confidence
22:24:42 <EvanR> yes good reasoning
22:24:49 <EvanR> i use that one all the time
22:24:49 <kmc> but if i unsafe ffi call read() i will put a big warning in my documentation "don't use this on a fd that might block"
22:24:57 <EvanR> even when i know there exist non sane systems
22:25:03 <EvanR> i proceed in denial
22:25:04 <kmc> it's true
22:25:17 <kmc> i bet some jackass has implemented sqrtf() with a blocking system call
22:25:42 <kmc> by making a RESTful AJAX SOAP query to a square root service running in the cloud
22:26:08 <EvanR> when windows crashes and burns inexplicably i cant bring myself to really care
22:27:52 <EvanR> > let (+,) = (*) in 4 +, 2
22:27:53 <lambdabot>   <no location info>: parse error on input `,'
22:28:00 <EvanR> dammit cant use comma
22:29:37 <kmc> yup
22:29:53 <EvanR> so much for 'programmable comma'
22:30:00 <kmc> heh
22:30:01 <kmc> use C++
22:53:44 <wbruce> Any tips on organizing functions in an application -- right now my modules tend to be big bags of chaotic functions strewn all over the place.  Do people generally alphabetize them, categorize them in chunks, or yank them out to deeper modules, etc? Seeking style tips...
22:54:49 <EvanR> make them methods of a manager class
22:54:57 <EvanR> like everyone else does
22:55:02 <kmc> you mean an abstract manager class factory iterator
22:55:04 <kmc> ;P
22:55:05 <EvanR> lol
22:55:38 <wbruce> please tell me I just walked into an inside joke ;-)
22:55:40 <kmc> yes
22:55:45 <kmc> we're making fun of enterprisey OOP
22:55:47 <EvanR> (hopefully the obvious irony is that doesnt solve anything AND is usually not why people do that)
22:55:54 * ddarius has no idea why someone would alphabetize functions.
22:56:10 <shachaf> wbruce: Inside of something that I understand that it is good to be outside of.
22:56:23 <kmc> wbruce, i group related definitions, and try to order things such that reading the implementation from top to bottom makes the most sense
22:56:29 <kmc> i.e. try to define and explain things before using them, as possibl
22:56:30 <shachaf> ddarius: Easy lookup.
22:56:44 <kmc> then i order the export list (and hence haddock output) such that reading the interface from top to bottom makes the most sense
22:56:48 <kmc> note that these two orders are not always the same
22:56:50 <EvanR> if your source file is as long as letter chapter in the dictionary you are in trouble
22:57:11 <kmc> if you think your module is too big then it probably is and should be broken up
22:57:23 <EvanR> that being said text editors often have a search feature
22:57:27 <ddarius> shachaf: Yep, when I'm looking through the code print outs.
22:57:36 <kmc> but something like a parser might be quite big, yet quite interconnected and only exporting one thing
22:58:19 <kmc> i tend to have a) modules mostly defining types and small general utilities (e.g. folds over those types); exporting almost everything
22:58:23 <shachaf> ddarius: Precisely.
22:58:34 <kmc> b) modules providing a single functionality, usually a small export list with lots of internal helpers
22:58:44 <kmc> i prefer to scope helpers by module rather than "let" or "where"
22:59:04 <kmc> or rather i do both at different scales
23:00:01 <jamy> One question. Its possible to write application and him work over internet on linux with CGI?
23:00:35 <kmc> yes
23:02:14 <EvanR> ssh might be easier to use than cgi
23:03:39 <jamy> ssh? for what ssh?
23:03:41 <ddarius> cgish, an amazing idea
23:03:49 <EvanR> lol
23:04:10 <jamy> i want writes web aplication on haskel
23:04:41 <EvanR> there are fastcgi packages
23:05:09 <jamy> wrealy? o_0
23:05:14 <EvanR> there are also web frameworks which give you more than just fastcgi
23:05:38 <kmc> CGI is a pain
23:05:43 <kmc> setting up apache is a pain
23:05:54 <EvanR> direct-fastcgi and lighttpd was painless
23:05:54 <jamy> kmc: -1
23:05:58 <kmc> i would start with a framework that has an embedded web server
23:06:50 <jamy> write personal webserver its foul idea!
23:06:58 <jamy> *fool
23:07:13 <ddarius> Web servers are stupid easy to write.
23:07:48 <jamy> and has many bugs for first time
23:08:22 <EvanR> where can i find the latest viral image of the grid consisting of what C Ruby PHP Java Lisp and Haskell see each other as?
23:10:55 <kmc> jamy, i don't mean that you should write a webserver.  just use a webserver that's written in Haskell, that your app uses as a library
23:10:58 <kmc> for easy development
23:11:09 <kmc> this is how most web frameworks in most languages work out of the box
23:11:15 <kmc> then you can plug them into fastcgi or whatever you want for production
23:11:45 <kmc> or it might be fast enough -- remember that a lot of production sites run on PHP and Ruby
23:11:58 <kmc> you'd want to reverse-proxy and serve static content from elsewhere, though
23:14:28 <jamy> you dont nead tell me about php and ruby. I am working web developer, and know what is it! :p
23:15:15 <kmc> great
23:18:10 <jamy> anybody know house os?
23:18:42 <jamy> os named "HOUSE"
23:18:46 <kmc> i've read about it, run it in a VM
23:19:32 <jamy> and what you sing about she?
23:20:04 <kmc> hmm?
23:20:05 <jamy> *think
23:20:20 <kmc> i don't have much of an opinion
23:20:39 <Cale> The Strathclyde Haskell Enhancement?
23:21:08 <Cale> (that's not related to the House project except that they're both related to Haskell)
23:21:35 <djahandarie> I thought House was put off until Habit was ironed out?
23:21:44 <djahandarie> I mean... it's late and I'm going to bed, good night.
23:21:45 <djahandarie> :P
23:21:56 <Cale> House is a neat project. It's probably interesting to look at if you're interested in OS design.
23:22:07 <Cale> But it's not really usable.
23:22:07 <kmc> 'night djahandarie
23:24:17 <jamy> usable? and we can use house for server
23:25:09 <jamy> PLAN9 no much usable, but google use him for servers
23:25:20 <empt> > length "this is a test"
23:25:21 <lambdabot>   14
23:25:35 <kmc> google uses plan9 for servers?
23:26:19 <kmc> i'd be quite surprised if they did
23:26:34 <Cale> jamy: Probably less usable than plan9 is though.
23:26:49 <kmc> some of the plan9 developers work at Google now.  they are paid to be famous and to do whatever they want
23:27:13 <jamy> you dont know? You behind the time!
23:30:50 <jamy> house equal posix than him can replace for example linux on router or file servers in small companies
23:31:04 <kmc> what would be the point?
23:31:21 <kmc> the interesting part of using a language like Haskell would be to provide high-level, typed system services
23:31:39 <jamy> for innovations
23:31:43 <kmc> that was my disappointment with House
23:31:55 <kmc> they use a fancy high level language to implement the same old semantics
23:32:20 <kmc> or they were going in that direction anyway
23:32:39 <jamy> ok! leave house alone 
23:33:13 <kmc> i'd be interested in a new OS design with new semantics, that can run alongside Linux in the same microkernel or hypervisor
23:33:43 <kmc> at one point i thought about porting YHC's bytecode interpreter to run on top of L4
23:33:49 <jamy> i am to! :)
23:35:03 <jamy> finelly i find you! :) i am wery intresting that idea to!
23:35:57 <jamy> kmc: you know sel4?
23:37:57 <kmc> heard of it
23:38:04 <kmc> it's either implemented in or verified by Haskell code?
23:38:54 <jamy> i heard this to. But i cant find the sources
23:40:43 <jamy> the information very little :(
23:45:00 * jamy collect sollution which be develop new os based on l4:hazelnut and to be have beos structure and bsd-like license. Who want join?
23:46:52 <jamy> kmc: what you answer?
23:50:37 <kmc> what are your goals?
23:50:50 <mornfall> World domination, what else.
23:51:11 <jamy> no.
23:52:19 <jamy> bsd-like license!!! I am want create, create and create
23:53:48 <jamy> and of course to write about me in wikipedia :)
23:54:29 <Ke> !
23:55:54 <jamy> Ke: ?
23:58:43 <jamy> what? no one else wanted?
