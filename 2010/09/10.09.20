00:35:59 <etpace> :ty group
00:36:04 <etpace> :t group
00:36:05 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
00:36:06 <etpace> :t groupBy
00:36:07 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
01:48:03 * hackagebot ghc-paths 0.1.0.8 - Knowledge of GHC's installation directories  http://hackage.haskell.org/package/ghc-paths-0.1.0.8 (SimonMarlow)
02:24:41 <merijn> I'm guessing that if I want to store (as in, on disk/database) continuations I'd be better off using something Lispy rather then Haskell?
02:32:14 <fxr> merijn: scheme or ocaml has first class continuations, otherwise you need to walk and serialize forms.
02:34:13 <merijn> fxr: OCaml has them too? That's interesting. But I've been meaning to force myself into learning a Lisp anyway, so I might as well go with Scheme in this case then.
02:37:28 * geheimdienst points out everyone has been saying good things about clojure
02:37:46 <geheimdienst> ... although i have no idea where clojure stands on the topic of continuations
02:38:37 <merijn> Yeah Clojure seems interesting, especially with their focus on immutable data. But I figure the switch from any Lisp to Clojure should be relatively easy.
02:39:09 <geheimdienst> well yeah, clojure _is_ a lisp
02:39:25 <merijn> I think Racket/PLT Scheme is gonna be my language of choice, though. Read some interesting stuff about it on lambda-the-ultimate
02:40:14 <fxr> if you need to be fast, you better look at gambit
02:41:16 <merijn> The main advantage Racket seems to have over Clojure is a better body of documentation/introduction material
02:41:41 * geheimdienst mumbles something about premature optimization
02:45:06 <fxr> merijn: http://www.lispniks.com/faq/faq.html#s6q1
02:45:57 <merijn> fxr: Thanks
03:00:30 <co_dh> how can I make an instance of Typeable of data Salary = S Float ? 
03:02:07 <fxr> co_dh: S (3.14::Float) ?
03:02:52 <co_dh> I need to write : instance Typeable Salary where typeOf (S float) = ????
03:03:12 <co_dh> because I don't know how to construct a TypeRep for Salary
03:03:14 <ivanm> derive it?
03:04:04 <co_dh> it need -XDeriveDataTypeable 
03:04:14 <co_dh> how can I derive it myself?
03:04:57 <ivanm> why not derive it?
03:05:13 <ivanm> shove this up the top of your file: {-# LANGUAGE DeriveDataTypeable #-}
03:05:17 <FunctorSalad> use -ddump-deriv on a program that does ues deriving
03:05:46 <co_dh> ok, thanks. just curious how can I derive it myself. 
03:05:47 <ivanm> or get derive or drift off of hackage
03:10:35 <co_dh> mkTyConApp ( mkTyCon "Main.Salary") [] 
03:10:46 <co_dh> the document is real unprofessional
03:11:31 <co_dh> mkTyConApp :Applies a type constructor to a sequence of types . this really says nothing
03:12:06 <geheimdienst> co_dh: welcome to the sad world of haskell api documentation ...
03:12:17 <FunctorSalad> what? it seems accurate to me
03:12:26 <co_dh> how can I help to improve the doc?
03:12:27 <geheimdienst> there's much to be improved
03:12:41 <co_dh> FunctorSalad: maybe you already know it. 
03:13:08 <FunctorSalad> it's not as tautological as it may seem 
03:13:31 <FunctorSalad> it's talking about reflection
03:13:59 <FunctorSalad> ("Applies the representation of a tycon to a sequence of representations of types")
03:14:12 <geheimdienst> functorsalad: "getFoo -- Gets the foo" is accurate, but not informative in the least
03:14:22 <FunctorSalad> Makes a representation of the type application, actually
03:14:33 <FunctorSalad> geheimdienst: as I just said, that's not what this is
03:14:51 <co_dh> it's actually a TypeRep constructor. 
03:15:06 <co_dh> but it calculate the key for you . 
03:16:18 <FunctorSalad> hmm using unsafe io I presume
03:17:06 <FunctorSalad> that'd mean that it's crucial to have the typerep as a separate definition as in the autogenerated code...
03:17:22 <FunctorSalad> rather than just putting it on the RHS of "typeOf _ = ..."
03:17:28 <FunctorSalad> or am I missing something?
03:17:31 <ManateeLazyCat> wjt: Are you there?
03:18:34 <co_dh> FunctorSalad: I can't follow u
03:19:00 <co_dh> can I contribute to the document of base ? 
03:19:14 <geheimdienst> co_dh, the doc is generated from the source code (which you can view by clicking the link in the top right corner). if you want to improve documentation, kudos! here's how to get the ghc source: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources . then, edit the file libraries/base/Data/Typeable.hs and submit a patch
03:19:22 <geheimdienst> (i guess that's how you'd approach it)
03:19:33 <ManateeLazyCat> @tell wjt I notice you interest on how to binding GooCanvas, it's really interested project worth to binding. 
03:19:33 <lambdabot> Consider it noted.
03:20:18 <co_dh> geheimdienst: thanks. will they refuse my patch ? 
03:20:23 <FunctorSalad> co_dh: if you're using unsafePerformIO you're relying on the expression only getting evaluated once, if you want the effect to only be executed once
03:21:32 <quicksilver> FunctorSalad: I think it uses a hashtable and dirty tricks
03:21:52 <ManateeLazyCat> @tell wjt I can tell you basic rule how to binding GObject library : In any gtk-base package (e.g. gtksourceview, gtkimageview) have below files at toplevel : Gtk2HsSetup.hs, hierarchy.list, marshal.list, Setup.hs. You need copy it to your GooCanvas, those file are basic template for binding GObject library.
03:21:52 <lambdabot> Consider it noted.
03:21:58 <FunctorSalad> to only conjure a key once even when called twice? ok
03:22:01 <co_dh> FunctorSalad: TyCon use an unsafePerformIO
03:22:34 <quicksilver> FunctorSalad: http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Data-Typeable.html
03:22:44 <quicksilver> FunctorSalad: skip down about 80% of the way down that file, search for 'Internals'
03:23:19 <Maxdamantus> @pl \a b -> not (a == b)
03:23:19 <lambdabot> (/=)
03:23:22 <mietek> What's a good way to determine the current resolution of the main display?
03:23:31 <ManateeLazyCat> @tell wjt Gtk2HsSetup.hs is gtk2hs tool help you generate GObject type and signal. hierarchy.list include rule how to generate GooCanvas hierarchy, marshal.list include rule how to generate signal you need in GooCanvas, Setup.hs just copy don't need change.
03:23:32 <lambdabot> Consider it noted.
03:23:44 <Maxdamantus> @pl \a b -> not (f a b)
03:23:45 <lambdabot> (not .) . f
03:24:06 <mietek> I thought GLUT.GameMode would be able to help, but it appears only to support the setting of the resolution, unless I missed something.
03:24:22 <FunctorSalad> makes sense, sort of :)
03:24:24 <ManateeLazyCat> @tell wjt Those template are very simple, i suggest you read the source code of other GObject-base library, like gtksourceview, gtkimageview, webkit.
03:24:24 <lambdabot> Consider it noted.
03:24:29 <dankna> even the notion of which display is the main one is OS-dependent
03:24:30 <FunctorSalad> (the key generation)
03:24:58 <mietek> dankna: is the notion of the main display OS-dependent?
03:25:23 <FunctorSalad> quicksilver: not tooo dirty or is it?
03:25:32 <merijn> Maybe not OS-dependent, but certainly display system dependent...
03:25:59 <ManateeLazyCat> @tell wjt After then you add many *.chs file for binding C function (don't forgot add {-# LANGUAGE CPP #-}
03:25:59 <lambdabot> Consider it noted.
03:25:59 <ManateeLazyCat>  at beginning). Then you can simple do "cabal install", Gtk2HsSetup.hs will generate Signal.chs and Types.chs in your GooCanvas directory.
03:26:06 <dankna> I'd argue that it is - Linux for example doesn't really have a "main" display, although some window managers might
03:26:29 <ManateeLazyCat> @tell Ok, that's all template you need notice, if you have any problem, please ask in gtk2hs list. Good luck!
03:26:29 <lambdabot> Consider it noted.
03:27:43 <mietek> I imagine GLUT already deals with this due to the fact that it provides a way to change the resolution of a display.
03:28:06 <merijn> dankna: Hence why I said not OS but display system dependent as any linux issue is inherently specific to X11 and thus the same on any other OS using X
03:28:10 <mietek> I don't see a way to enumerate and/or choose displays using the GLUT bindings, though.
03:28:41 <dankna> fair
03:29:07 <dankna> I actually wrote my own GLUT/SDL replacement but it isn't really complete
03:29:51 <quicksilver> mietek: you vastly overestimate GLUT
03:30:01 <quicksilver> it is a simple library for demos which hasn't been updated in years
03:30:21 <quicksilver> when it was written there were only 600 computer monitors in the world, certainly there weren't two connected to the same comptuer.
03:30:33 <merijn> I agree, I did some class work in GLUT for a course in computer graphics and GLUT is severely lacking into usefull functions
03:30:44 <merijn> s/into/in
03:30:56 <mietek> Do you mean GLUT in general, or the Haskell GLUT bindings?
03:31:06 <co_dh> :t mkT
03:31:07 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
03:31:18 <merijn> I did GLUT in C/C++, so in general
03:32:08 <quicksilver> I'm pretty sure you'll need a real GUI library for something like that. Perhaps SDL or GTK or wxWidgets
03:32:13 <quicksilver> mietek: I meant GLUT in general.
03:32:18 <mietek> It appears that it should be possible to call glutGet(GLUT_SCREEN_WIDTH)
03:32:28 <quicksilver> oh, you didn't mean resolution?
03:32:35 <quicksilver> you just meant width + height?
03:32:39 <quicksilver> yes, you can probably get that.
03:33:41 <mietek> The GLUT documentation refers to these values as resolution.
03:33:48 <mietek> "Width of the screen resolution in pixels"
03:34:19 <mietek> quicksilver: do you know if there's a function equivalent to glutGet in the Haskell bindings?  I can't locate it.
03:34:19 <ToRA> get screenSize  and get screenSizeMM ("The size of the screen in millimeters")
03:34:39 <ToRA> 'get' comes from Data.StateVar
03:34:53 <mietek> ToRA: thank you!
03:35:03 <mietek> Perfect.
03:35:04 <ToRA> screenSize :: GettableStateVar Size
03:35:13 <mietek> Which module is that in?
03:35:26 <ToRA> GLUT.State
03:35:40 <ToRA> http://hackage.haskell.org/packages/archive/GLUT/2.2.2.0/doc/html/Graphics-UI-GLUT-State.html#v:screenSizeMM
03:35:43 <mietek> Thanks.
03:36:04 <ToRA> note 'fullScreenMode' is a StateVar so you can set it too
03:36:19 <ToRA> (fullScreenMode $= True)
03:37:49 <co_dh> I like the GLUT.State
03:38:28 <Blkt> good day everyone
03:38:40 * ivanm waves idly in Blkt's general direction
03:39:33 * geheimdienst looks up from his spot on the window sill, meows, and looks sleepily in blkt's direction
03:39:33 <Blkt> :)
03:44:21 <mietek> "Contains Just the number of buttons of the attached Spaceball or Nothing if there is none."
04:00:03 <co_dh> :t gmapT
04:00:04 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
04:00:10 <co_dh> @where gmapT
04:00:10 <lambdabot> I know nothing about gmapt.
04:00:17 <co_dh> @where money
04:00:17 <lambdabot> I know nothing about money.
04:00:23 <co_dh> lambdabot: bank
04:00:30 <geheimdienst> @where lolcats
04:00:30 <lambdabot> I know nothing about lolcats.
04:00:36 <geheimdienst> @where lambdacats
04:00:36 <lambdabot> http://arcanux.org/lambdacats.html
04:00:43 <ivanm> that site is no more
04:00:48 <co_dh> @src gmapT
04:00:48 <lambdabot> Source not found.
04:00:58 <co_dh> @hoogle gmapT
04:00:58 <lambdabot> Data.Data gmapT :: Data a => (b -> b) -> a -> a
04:01:04 <merijn> I'm sadly disappointed by the lack of site there :<
04:01:26 <geheimdienst> merijn: http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46
04:01:33 <m3ga> merijn: someone on the -cafe mailing list was collecting the images
04:01:33 <lambdabot> m3ga: You have 1 new message. '/msg lambdabot @messages' to read it.
04:01:42 <geheimdienst> ivanm, true. somebody should tell lambdabot about the smugmug gallery ...
04:01:52 <ivanm> geheimdienst: @where+ ....
04:02:01 <geheimdienst> woah! thanks
04:02:04 <merijn> Fortunately, what happens on the internet stays in google's caches and other websites :p
04:02:12 <geheimdienst> @where+ lambdacats http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46
04:02:12 <lambdabot> I will never forget.
04:02:18 <geheimdienst> @where lambdacats
04:02:18 <lambdabot> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46
04:02:36 <geheimdienst> @where+ lolcats http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46
04:02:36 <lambdabot> Good to know.
04:02:40 <geheimdienst> @where cats
04:02:40 <lambdabot> I know nothing about cats.
04:02:51 <geheimdienst> @where+ cats http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46
04:02:51 <lambdabot> It is forever etched in my memory.
04:03:43 <merijn> I should grab a better URL and mirror that...
04:03:50 <merijn> Too bad I killed my webserver...
04:04:08 <merijn> If anyone has a server, lambdacats.org is apparently still free :>
04:07:48 <geheimdienst> merijn, i made http://tinyurl.com/lambdacats ... that would be the 5-minute alternative to getting a domain
04:08:17 <co_dh> http://www.cs.vu.nl/boilerplate/ 
04:08:30 <co_dh> am I the only one that can not access above link? 
04:08:52 <merijn> Nope
04:09:07 <merijn> Where is it linked from?
04:09:18 <co_dh> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Data.html#v:gmapT
04:09:50 <merijn> Wow, that must be an old link
04:09:52 <Cale> It's also easier and cheaper to get a subdomain than a proper domain name.
04:10:00 <merijn> Cale: But less cool
04:10:15 <merijn> I'm not sure we even still have any Haskell projects at the VU...
04:10:36 * geheimdienst thinks http://lambda.cat is quite un-toppable in terms of awesomitude
04:10:36 <co_dh> I miss python's document .
04:10:51 <geheimdienst> before you ask, .cat is some spanish thing and really exists
04:10:53 <merijn> There's is a .cat TLD?
04:10:58 <merijn> Oh, makes sense
04:11:00 <wjt> not spanish! catalan!
04:11:01 <lambdabot> wjt: You have 5 new messages. '/msg lambdabot @messages' to read them.
04:11:01 <merijn> Catalonia
04:12:19 <geheimdienst> i guess the only remarkable thing about it is that it has 3 letters. all the other language/country tlds have 2
04:12:37 <Cale> co_dh: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.6.466&rep=rep1&type=pdf
04:12:44 <medfly> I guess they ran out.
04:12:47 <Cale> co_dh: If that happens to be the paper you're after...
04:12:51 <medfly> too many countries and fake countries
04:13:08 <wjt> @tell ManateeLazyCat Thanks for the pointers! I'll let you know how I get on :)
04:13:08 <lambdabot> Consider it noted.
04:13:09 <geheimdienst> > 26*26
04:13:10 <lambdabot>   676
04:13:27 <co_dh> Cale: thanks. I'm reading it. the pdf is a little bit old as compare to Data.Data
04:13:35 <geheimdienst> i think there's around 190 countries ... should be plenty of room left with 676 possible 2-letter codes
04:14:02 <Cale> Perhaps not if you want the codes to relate in some way to the country names
04:14:49 * geheimdienst leans to the explanation that they took .cat because of the superior inherent awesomeness
04:16:04 <fxr> halex looks wonderful
04:27:55 <co_dh> :t gmapT
04:27:56 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
04:28:49 <co_dh> > data Salary = S Float
04:28:49 <lambdabot>   <no location info>: parse error on input `data'
04:28:59 <co_dh> can I use data with lambdabot?
04:30:07 <oteren> ([a] -> [a],Char) <-- can someone explain to me what that is? I first thought it was the same as [a] -> ([a], Char), but no
04:30:36 <co_dh> a pair of a function and a char
04:31:08 <co_dh> :t ( tail, 'a')
04:31:09 <lambdabot> forall a. ([a] -> [a], Char)
04:31:33 <Botje> oteren: it's a tuple, with the first part a function from [Char] to [Char] and the second part just a Char
04:31:43 <oteren> aaah
04:31:52 <oteren> thanks guys :)
04:32:21 <byorgey> co_dh: no, you can't wite data declarations in lambdabot
04:32:35 <co_dh> byorgey: thanks.
04:38:53 <Veinor> hm
04:38:59 <Veinor> is the haskell platform a good idea for OS X right now?
04:39:10 <Veinor> by which I mean, should I use it to set up haskell
04:40:47 <co_dh> Veinor: it's good, I'm using it now 
04:40:56 <merijn> Veinor: Works fine for me on Snow Leopard
04:41:10 <Veinor> cool
04:41:52 <co_dh> I can't persuade myself to finish Scrap your boilerplate, because I believe the example they use in the paper are wrong, it should be a database problem.  
04:42:22 <co_dh> I feel like syb is solve database problem with the wrong tool. puting data into code . 
04:43:19 <co_dh> am I wrong?
04:43:30 <Botje> that's just the example
04:43:44 <Botje> co_dh: read the uniplate paper
04:43:55 <co_dh> uniplate?
04:44:01 <co_dh> @where uniplate
04:44:02 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
04:44:06 <Botje> it's similar, but at least they use decent examples :)
04:44:37 <Botje> and maybe you'll understand why something like SYB is necessary
04:47:50 <co_dh> Botje: thank, AST is a good example, because it's hard to express them in database.
04:48:30 <co_dh> sql can not define recursive datatype , am I right? 
04:49:08 <Veinor> co_dh: does it still have the thing where there are two cabal binaries?
04:49:42 <co_dh> Veinor: I don't know what are you talking about. I have no problem with cabal
04:49:51 <Veinor> hm
04:50:00 <Botje> co_dh: correct
04:50:25 <Botje> there are hacks to make trees in sql, but they rely on string prefixes and *urgh*
04:51:09 <co_dh> even find a closure of a relation in sql is so hard , lol
04:51:42 <Botje> yup
04:51:51 <co_dh> Botje: are you the Neil Mitchell?
04:51:59 <Botje> no, i'm not
04:52:01 <Botje> ndm is
04:52:03 <Botje> @seen ndm
04:52:03 <lambdabot> Unknown command, try @list
04:52:03 <preflex>  ndm was last seen on #haskell 1 year, 134 days, 1 hour, 33 minutes and 23 seconds ago, saying: plus with current compiler technology, it would be slower
05:00:38 <Veinor> hm
05:00:57 <Veinor> if I'm writing a replacement for hs-twitter, which exports a Web.Twitter module, would it be okay for my version to also export Web.Twitter?
05:01:50 <Botje> are you going to offer a similar interface?
05:02:01 <Veinor> probably
05:02:14 <geheimdienst> many of the best modules do that ... like mtl and monads-tf fighting over Control.Monad.Stuff
05:02:15 <Veinor> not drop-in-replacement compatible, but hs-twitter doesn't work right now anyway
05:02:19 <Botje> then it's probably alright
05:02:44 <geheimdienst> if you ask me, it's all a secret conspiracy to frighten newbies with strange compiler messages
05:04:11 <geheimdienst> i think Web.Twitter2 would be clearer, is what i'm sayin'
05:04:30 <Veinor> maybe
05:04:38 <Veinor> or TwitterOauth
05:05:08 <Veinor> on the other hand, like I said, hs-twitter is completely broken
05:07:38 <geheimdienst> and to counter my own point, twitter is much higher in the stack. mtl and monads-tf are much more basic. so it's likely for packages to depend on both of them, but it's very unlikely any package would depend on both the broken twitter and your twitter thing
05:20:18 * hackagebot ieee754 0.7.1 - Utilities for dealing with IEEE floating point numbers  http://hackage.haskell.org/package/ieee754-0.7.1 (PatrickPerry)
05:34:10 <rtaycher> I'm trying to do figure out how to multiple dispatch via multi-parameter type classes+ existential types(all this is a bit over my head), here is the code http://haskell.pastebin.com/Fk4d04Cv , currently it says Not in scope: data constructor `Testable'
05:34:14 <rtaycher> any ideas?
05:34:42 <rtaycher> note I'm using -XMultiParamTypeClasses -fglasgow-exts 
05:35:16 <Saizan> your data constructor is called Testable_
05:37:02 <rtaycher> don't know how I missed that thanks
05:38:08 <Saizan> anyhow, that's not going to work because the Testable_ typeclass takes 2 parameters
05:38:43 <Saizan> while you are applying it to only one in the definition of Testable (the datatype)
05:40:48 <Saizan> i'm not sure what'd be the role of an existential type here though..
05:42:14 <rtaycher> I thought it was meant to do something like dynamic dispatch
05:42:36 <mietek> Is there a Hoogle which indexes HOpenGL?
05:42:43 <rtaycher> I was trying to do http://c2.com/cgi/wiki?MultipleDispatch
05:43:56 <mietek> $whereis hayoo
05:46:09 <ivanm> @where hayoo
05:46:09 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:46:15 <ivanm> mietek: ^^
05:47:07 <mietek> Thanks.  It wasn't working for me a second earlier.
05:47:33 <ivanm> because $whereis doesn't make sense ;-)
05:47:44 <mietek> No, the URL itself.
05:47:59 <mietek> Never mind, all is good.
05:51:26 * hackagebot stringsearch 0.3.2 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.2 (DanielFischer)
05:53:48 <Saizan> rtaycher: maybe like this http://haskell.pastebin.com/gQQ8vvvG
05:54:46 <Saizan> rtaycher: the description of the problem on c2.com is fundamentally tied to subtyping, so in haskell it feels weird
05:54:56 <Saizan> to me, at least
06:00:30 <zygoloid> multiple dispatch is actually really easy in haskell if you want to do it based on static types. for a dynamic, extensible pair types i'm not really sure how you'd do it...
06:00:41 <zygoloid> *pair of types
06:00:57 <ClaudiusMaximus> mietek: you can use +opengl in the hoogle web interface, too:  http://www.haskell.org/hoogle/?hoogle=%2Bopengl%20vertexarray
06:01:08 <ClaudiusMaximus> mietek: or +packagename in general
06:01:21 <mietek> Ah!
06:01:23 <mietek> Good to know, thanks.
06:32:02 <ManateeLazyCat> Sometimes, really feeling lonely, where is my world? Maybe only code can find my true self ....
06:32:03 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
06:41:49 <ManateeLazyCat> @tell wjt In principle, we don't need any other library to build model/view split design GUI program. Add TVar in pure BUFFER, then make multiple VIEW reference same buffer will implementation MVC gtk2hs code. If you want write your own widget, you just need Cairo, don't need any other library, perhaps GooCanvas bulid many higher APIs make you easier to build... :)
06:41:49 <lambdabot> Consider it noted.
06:42:51 <ManateeLazyCat> @tell wjt https://patch-tag.com/r/AndyStewart looking repository beginning with manatee-* , have many example code how to build you own MVC gtk2hs program....
06:42:51 <lambdabot> Consider it noted.
06:52:03 <ddarius> There's too much traditional/folk music.
06:55:21 <silver> yeah... all those years
06:58:26 <co_dh> Mantee: do some workout . Use your brain too much will cause depression.
06:58:48 <silver> oh that's why...
07:01:48 <Cale> ddarius: and history is too long. They should make a shorter version.
07:08:50 * hackagebot graph-rewriting 0.4.9 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.4.9 (JanRochel)
07:15:34 <ManateeLazyCat> co_dh: Sorry, busy here, what you mean?
07:16:12 <ManateeLazyCat> co_dh: I just have a bit tired recently.
07:17:26 <co_dh> Mantee: too many brain work will cause depression, unhappiness, etc 
07:17:38 <co_dh> we are animals, we need move, right
07:17:54 <wjt> ManateeLazyCat: The existing version of my application does use Cairo directly, but I keep wanting things that GooCanvas has already implemented
07:17:54 <lambdabot> wjt: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:18:54 <ManateeLazyCat> wjt: Good, from quick read, i think GooCanvas APIs is good.
07:19:04 <ManateeLazyCat> co_dh: Haven't time.
07:19:21 <co_dh> no time.
07:19:39 <ManateeLazyCat> co_dh: 我只是感觉有点孤独....
07:19:53 <co_dh> then find a girl friend
07:20:02 <wjt> ManateeLazyCat: from a quick (ahem) python prototype it should do the trick
07:20:05 <ManateeLazyCat> co_dh: I have, it's manatee.
07:20:27 <ManateeLazyCat> wjt: I suggest you read gtk2hs code.
07:20:38 <ManateeLazyCat> wjt: Special many gtk-base library.
07:20:39 <co_dh> who is manatee?
07:20:45 <ManateeLazyCat> co_dh: My girl.
07:20:55 <co_dh> a real girl?
07:21:00 <ManateeLazyCat> co_dh: Yea.
07:21:15 <ManateeLazyCat> co_dh: 我说的孤独是技术上的孤独， 不是人生中的孤独
07:21:27 <co_dh> you programmed too much.
07:21:42 <ManateeLazyCat> co_dh: Still not enough...
07:22:22 <co_dh> 90% of programmer only program for money . 
07:22:42 <ManateeLazyCat> wjt: Like i said, you copy some file from gtksourceview, gtkimageview, webkit, then gtk2hs-buildtools can do most work for you.
07:22:52 <ManateeLazyCat> co_dh: I programming for dream.
07:22:58 <ManateeLazyCat> co_dh: A pure dream.
07:23:21 <co_dh> what's that dream?
07:23:25 <ManateeLazyCat> co_dh: So i won't write program i dislike.
07:23:36 <ManateeLazyCat> co_dh: Efficient Haskell OS.
07:23:59 <ManateeLazyCat> co_dh: Efficient like Emacs, but can do everything in it, and much safe and fast than Emacs.
07:24:12 <co_dh> sounds cool, find more people join it.
07:24:29 <ManateeLazyCat> co_dh: Yes, have some people send patch to me.
07:24:36 <co_dh> is that your irc client that you talk about? 
07:24:58 <ManateeLazyCat> co_dh: You can track my project at here : http://www.flickr.com/photos/48809572@N02/
07:25:08 <wjt> ManateeLazyCat: yep. i'm at work at the moment, so... later :)
07:25:10 <ManateeLazyCat> co_dh: I will post new screenshot after i finish new module.
07:25:30 <ManateeLazyCat> wjt: Good luck! Feel frea ask here or gtk2hs list. :)
07:25:41 <ManateeLazyCat> s/frea/free
07:26:23 <co_dh> Mantee: obviously, you are too ambitious
07:26:32 <ManateeLazyCat> wjt: When you don't how to binding some type (e.g. Cairo type), do a grep in 'gtk' package will helpful.
07:27:10 <ManateeLazyCat> wjt: Most simple code can copy from 'gtk' or 'cairo' package.
07:27:46 <ManateeLazyCat> wjt: And don't forgot add documentation for binding, if you use Emacs, here have elisp extension convert C documentation to haddock style : http://www.emacswiki.org/emacs/gtk2hs.el
07:28:11 <ManateeLazyCat> wjt: Convert documentation is automatic in Emacs.
07:29:19 <ManateeLazyCat> co_dh: Can you talk Chinese privately?
07:30:01 <co_dh> I feel not polite to talk chinese here. 
07:30:08 <co_dh> also I'm skype with my gf :)
07:30:18 <ManateeLazyCat> co_dh: I mean /query
07:31:42 <ManateeLazyCat> co_dh: If have time, i hope i can some Chinese haskeller to build China-Haskell community. :)
07:33:04 <tab> maybe have ICFP in china next year ;)
07:33:24 <ManateeLazyCat> tab: Really ?
07:33:35 <tab> ManateeLazyCat: probably not, but that would be cool ;)
07:33:53 <ManateeLazyCat> tab: Most Chinese programmer are Java/C++ programmer. 
07:34:06 <tab> it can change though :)
07:34:33 <ManateeLazyCat> tab: I think hard to change, since most Chinese programmer write program for money.
07:34:49 <tab> yeah, although someday people will write haskell for money as well ;)
07:34:58 * hackagebot atom 1.0.5 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.5 (TomHawkins)
07:35:24 <ManateeLazyCat> tab: We need more GUI programs, IMO. :)
07:35:32 * tab has a secret plan to move to china and open a consultancy there :P
07:35:38 <tab> ManateeLazyCat: definitely
07:35:42 * ddarius knows Swallowtail Jig under another name.
07:35:51 <ManateeLazyCat> tab: Then many newbie can join haskell like Xmonad do.
07:36:02 <ManateeLazyCat> tab: But just xmonad still not enough...
07:36:14 <tab> yep need more mainstream programs
07:36:25 <ManateeLazyCat> tab: like this : http://www.flickr.com/photos/48809572@N02/
07:36:31 <ManateeLazyCat> tab: My project.
07:36:40 <Entroacceptor> that's hardly mainstream
07:36:44 <Entroacceptor> although it is  cool
07:37:17 <ManateeLazyCat> Entroacceptor: My todo list have "split" feature.
07:37:48 <ManateeLazyCat> Entroacceptor: That mean you can drop any tab split out, then you can just have individual program.
07:38:39 <ManateeLazyCat> Entroacceptor: Example, you can drop current editor module outside, then you can split editor from environment, of cousre, you can drop editor into environment.
07:39:08 <ManateeLazyCat> Entroacceptor: Have you build it success? You can try irc client, new add.
07:39:21 <ManateeLazyCat> Entroacceptor: And i have fix manatee-mplayer bug, i think it can play any directory now.
07:40:17 <Entroacceptor> haven't gotten it to build since the first time
07:40:39 <ManateeLazyCat> Entroacceptor: Download gtk2hs darcs, and do "./repos.sh install" that's all.
07:40:59 <ManateeLazyCat> Entroacceptor: Except gtk2hs darcs, other package can install by cabal.
07:41:00 <Entroacceptor> yeah, it failed for some reason, but I think I somehow managed to break my packages
07:41:11 <Entroacceptor> so I deleted them all
07:41:17 <Entroacceptor> I ´have yet to try again
07:41:32 <ManateeLazyCat> Entroacceptor: Maybe you can try again when i release next gtk version.
07:42:58 <DukeDave> Hey guys, I'm getting "Could not find module `Graphics.UI.SDL`" when running a make under Ubuntu.
07:42:59 <DukeDave> What is the preferred way of getting dependencies now? 
07:43:02 <DukeDave> I've added the PPA as per here: https://launchpad.net/~justinbogner/+archive/haskell-platform, and installed haskell-platform
07:43:42 <ManateeLazyCat> DukeDave: "cabal install SDL"
07:44:16 <ManateeLazyCat> @package SDL
07:44:16 <lambdabot> http://hackage.haskell.org/package/SDL
07:44:21 <ManateeLazyCat> DukeDave: ^^^^^^
07:44:23 <DukeDave> ManateeLazyCat: Wow, well things have become easier since I last played with GHC :)
07:44:48 <ManateeLazyCat> DukeDave: Yeah, GHC is awesome. :)
07:55:21 <manateeUser> Hmm, looks juhp not take my manateeUser. :)
08:00:38 <ddarius> Hmm.  It's allegedly 11AM but the quality of light looks like it is 8AM.  Perhaps I'm not used to being this far north.
08:07:25 <ddarius> This is a great name and logo: http://javawockyuu.com/
08:12:51 <aristid> any comments on the interface / documentation / algorithms of my first hackage package (phackage)? http://hackage.haskell.org/packages/archive/random-extras/0.3/doc/html/Control-Monad-Random-Extras.html
08:23:48 <aristid> is it possible to tell ghci to do garbage compression more aggressively?
08:23:54 <aristid> *garbage collection
08:24:24 <Tomsik> aristid: in what sense?
08:24:42 <Tomsik> more often have only one generation or ?
08:24:44 <aristid> well, for example while it shows the prompt
08:26:02 <Tomsik> Hmm, this I do not know
08:26:29 <Lemmih> aristid: You can use System.Mem.performGC but I don't think it'll get you want you want.
08:27:09 <aristid> Lemmih: why not?
08:27:27 <Lemmih> aristid: What do you want?
08:29:12 <aristid> Lemmih: well i'm doing stuff that sometimes uses tons of memory (testing algorithms with huge lists, for example), and sometimes it leaves so much memory that i have to wait 20 seconds when running a command that normally only takes 0.01 seconds
08:29:26 <aristid> i suppose it runs garbage collection in these 20 seconds
08:29:34 <aristid> but why can't it garbage collect that earlier?
08:30:04 <roconnor> huge lists?
08:30:44 <aristid> well the list itself isn't that huge ([1..800000]), but the algorithms seem to take a significant amount of memory
08:31:42 <roconnor> aristid: I hope only a constant amount of that list is in memory at once?
08:31:54 <roconnor> aristid: Ie you are not doing random access.
08:32:30 <aristid> roconnor: well i'm changing the list into a Data.Sequence first, and then doing some things
08:32:50 <aristid>  > length `liftM` shuffle [1..800000]
08:32:50 <aristid> 800000
08:32:50 <aristid> (5.70 secs, 435108008 bytes)
08:33:42 <roconnor> aristid: that's good
08:34:12 <aristid> 414 megabytes of memory used to shuffle a list of 800k elements, no idea if that is good
08:34:16 <Entroacceptor> I hope you do optimizing....
08:34:54 <copumpkin> it's running in ghci
08:34:58 <copumpkin> can't be that good
08:34:59 <copumpkin> :P
08:36:00 <aristid> but why doesn't it do garbage colleciton afterwards?
08:36:04 <roconnor> I mean that is is good to use seq
08:36:10 <roconnor> or at least it is better than using list
08:36:39 <aristid> roconnor: yeah nobody wanted to actually look at the algorithm so far, so i'm not sure if it is good
08:36:57 <benmachine> aristid: re: your interface, 1. it's not always immediately obvious what e.g. m and n are in O(n + m * log n), also it would be nice if the docs stated which functions were total and which weren't
08:37:29 <aristid> benmachine: thank you :)
08:37:35 <benmachine> umm, the second part was 2.
08:38:11 <aristid> benmachine: is it ok if i only state the functions that are partial?
08:38:16 <aristid> because most functions are total
08:38:21 <benmachine> sure
08:39:28 <benmachine> just something like, "error if list is empty"
08:40:26 <benmachine> or, you could just make your partial functions total :P
08:41:28 <roconnor> benmachine: in general that is only possible when the domain of the function is decidable.
08:41:38 <aristid> benmachine: i'll add total functions :)
08:41:51 <aristid> but i want to keep the partial functions because they're usually much more convenient
08:41:56 <benmachine> oh, sure
08:42:12 <benmachine> you don't have to add total functions if you don't think they'd be useful
08:42:36 <benmachine> it's just an idea
08:42:49 <benmachine> I've been keen recently on the idea of
08:43:05 <benmachine> if your function requires e.g. a non-empty list, or always returns a non-empty list
08:43:28 <benmachine> then basically you're saying, this list is (x:xs) for some x and xs
08:43:45 <benmachine> so you can just edit the type signature so that you actually provide an x and xs
08:44:02 <aristid> adding safe functions really isn't a lot of hassle
08:44:15 <aristid> i perfectly know which conditions lead to errors, and only need to catch them
08:44:19 <benmachine> mm
08:44:34 <benmachine> there's safety and there's safety, though, imo
08:44:50 <benmachine> you're probably ok giving an error if it's a condition the programmer can easily avoid
08:44:57 <benmachine> "just don't do that, then"
08:45:47 <aristid> people often enough complain that there is no safe version of head
08:46:08 <benmachine> pfft
08:46:15 <benmachine> when have I ever needed head
08:46:25 <roconnor> there is a safe version of head.  It is called listToMaybe
08:46:26 <benmachine> ok there's a lot of useful things I don't need but still
08:46:35 <Saizan> about head, you're more likely find people that complain about it being in the prelude
08:46:35 <roconnor> the name is a bit unwieldy
08:46:43 <benmachine> mm
08:46:56 <Saizan> read is another story
08:47:05 <benmachine> I'd like uncons in Data.List personally
08:47:15 <benmachine> I don't really why
08:47:18 <benmachine> it's just kinda neat
08:47:22 <benmachine> +know
08:47:26 <roconnor> a readMaybe is definitely warrented.
08:47:32 <benmachine> mm, and simple
08:47:33 <roconnor> useing reads is a pain
08:48:08 <roconnor> @type fmap fst . listToMaybe . read
08:48:09 <lambdabot>     Ambiguous type variable `b' in the constraint:
08:48:09 <lambdabot>       `Read b' arising from a use of `read' at <interactive>:1:25-28
08:48:10 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
08:48:10 <roconnor> @type fmap fst . listToMaybe . reads
08:48:11 <lambdabot> forall a. (Read a) => String -> Maybe a
08:48:31 <benmachine> that's one way of doing it
08:48:48 <roconnor> @type listToMaybe . fmap fst . reads
08:48:49 <lambdabot> forall a. (Read a) => String -> Maybe a
08:49:06 <benmachine> I think to more closely mirror read, we'd want the snd to be entirely whitespace
08:49:14 <benmachine> > read "123   " :: Int
08:49:15 <lambdabot>   123
08:49:15 <roconnor> oh right
08:49:19 <benmachine> > read "123()" :: Int
08:49:20 <lambdabot>   *Exception: Prelude.read: no parse
08:49:20 <aristid> benmachine: hmm, how should a safe version of choices (which returns an infinite stream of random choices from a list) behave when the input stream is empty.. should it return an empty list, or wrap everything in a Nothing?
08:49:21 <roconnor> damn it
08:49:30 <roconnor> that's why it is so hard to write
08:49:56 <benmachine> case reads of [(a, s)] | all isSpace s -> Just a; _ -> Nothing
08:50:00 <benmachine> aristid: hmm, not sure
08:50:15 <aristid> i'm biased towards the Nothing
08:50:19 <benmachine> aristid: what happens at the moment? getRandomRs errors because its bounds are empty?
08:50:28 <roconnor> @type \s -> do {[(a,"")] <- s; return s} -- this is what I often write
08:50:29 <lambdabot> forall (m :: * -> *) t. (Monad m) => m [(t, [Char])] -> m (m [(t, [Char])])
08:50:37 <roconnor> @type \s -> do {[(a,"")] <- reads s; return s} -- this is what I often write
08:50:38 <lambdabot>     Couldn't match expected type `(a, String)'
08:50:38 <lambdabot>            against inferred type `[a1]'
08:50:38 <lambdabot>     In the pattern: [(a, "")]
08:50:40 <benmachine> aristid: maybe in this case a total version wouldn't be very helpful
08:50:41 <aristid> benmachine: at the moment i catch it and use error "bla"
08:50:46 <roconnor> @type \s -> do {[(a,"")] <- reads s; return a} -- this is what I often write
08:50:47 <lambdabot>     Couldn't match expected type `(a, String)'
08:50:47 <lambdabot>            against inferred type `[a1]'
08:50:47 <lambdabot>     In the pattern: [(a, "")]
08:51:00 <benmachine> aristid: oh, you've changed it since 0.3? or am I looking at the wrong code
08:51:11 <aristid> choices []  = error "Control.Monad.Random.Extras.choices: empty list"
08:51:15 <aristid> i have not changed it
08:51:48 <benmachine> huh, I just see choices xs = choicesArray $ Data.Array.listArray (1, length xs) xs
08:51:52 <benmachine> http://hackage.haskell.org/packages/archive/random-extras/0.3/doc/html/src/Control-Monad-Random-Extras.html#choices
08:52:22 <benmachine> aristid: btw, have you considered submitting any of these for inclusion in MonadRandom?
08:52:27 <aristid> benmachine: ooh, right. well, what failed is the array construction
08:52:35 <aristid> no i haven't
08:52:48 <benmachine> k
08:53:17 <benmachine> > listArray (1, 0) [0]
08:53:18 <lambdabot>   array (1,0) []
08:53:18 <aristid> i'm not sure if it belongs directly in MonadRandom
08:53:26 <benmachine> mm, maybe it doesn't
08:53:45 <benmachine> I just thought the module name was a bit... I dunno
08:54:01 <benmachine> it *sounds* like, we wanted to go in Control.Monad.Random but couldn't fit
08:54:02 <aristid> i'm slightly biased because i take pride in having my own package :D
08:54:08 <benmachine> heh no I know that feeling
08:54:24 <aristid> i was not sure where to put the module
08:54:32 <benmachine> well, I'm just saying things
08:54:37 <benmachine> feel free to ignore
08:54:59 <aristid> i was considering Data.Random.Extras or so
08:55:23 <aristid> but because it uses Control.Monad.Random as a base, i thought putting it in the same space might be a good idea
08:55:31 <benmachine> yeah, that makes sense
08:55:45 <benmachine> it's just that .Extras doesn't really sound very informative
08:56:05 <aristid> i could split it into more concrete modules
08:56:07 <benmachine> so I was thinking about .Shuffle or .Sample or .Choice or something but none of those are quite right
08:56:11 <benmachine> you could do
08:56:18 <benmachine> or you could stick with what you have
08:56:20 <aristid> but it seems like there is a bias in the community against having too many modules
08:56:37 <benmachine> the module hierarchy is hardly rigorous as it is
08:56:46 <EvanR-work> anyone know of haskell http stress test suite? or tools to make such a suite?
08:56:51 <benmachine> I don't mind lots of modules but you may well be right
08:57:00 <benmachine> EvanR-work: does it have to be haskell?
08:57:08 <aristid> benmachine: if my module gets bigger, i might split it :)
08:57:09 <benmachine> I mean
08:57:13 <EvanCarroll> does haskell have something like Number::Format?
08:57:15 <benmachine> silly question, everything should be haskell of course
08:57:23 <EvanCarroll> that can format numbers with , and the like
08:57:27 <aristid> haha
08:57:30 <EvanR-work> i have been using other tools, but haskell seems like an ideal setting for this sort of thing
08:57:53 <EvanR-work> concurrency, parsing, etc
08:58:04 <benmachine> EvanR-work: well then, I don't know of one, but I probably wouldn't be the guy to ask
08:58:15 <EvanR-work> thanks for nothing! :)
08:58:46 <EvanR-work> http package looks nice
09:01:45 <benmachine> aristid: btw, there's a neat trick that'll let you do 'choice' in a single traversal of the list, albeit with O(n) random numbers instead of just one
09:03:11 <benmachine> erk, I've gotta go do an errand
09:03:17 <TPJ> Hello. Is there anyone who uses wai?
09:03:28 <aristid> benmachine: huh? do tell
09:03:39 <benmachine> aristid: basically, choose the first element of the list with probability 1, then replace it with the second with probability 0.5
09:03:53 <benmachine> at this stage obviously the chances of getting each element of the list is 0.5
09:04:09 <benmachine> replace your element with the third with probability 1/3
09:04:42 <aristid> benmachine: well while this does save a traversal, it doesn't sound like it would speed things up
09:04:59 <aristid> also if i'm not very careful the distribution might become non-uniform
09:05:04 <benmachine> aristid: if the list is generated lazily, it could let it be garbage-collected as you went along
09:05:18 <benmachine> and if you choose the nth item with probability 1/n it will stay uniform
09:05:19 <benmachine> do the maths!
09:05:23 <benmachine> it works
09:05:43 <benmachine> I'd write you some demo code but I've gotta go do some paperwork
09:05:57 <benmachine> might be back in, say, half an hour or so
09:06:11 <aristid> yeah i'll think about it in the meantime :D
09:10:26 <IceDane> I really, *really* need to develop a consistent style for my haskell code formatting
09:10:34 <chrisdone> IceDane: 
09:10:39 <chrisdone> @google tibbe haskell style guide
09:10:41 <lambdabot> http://github.com/tibbe/haskell-style-guide
09:10:41 <lambdabot> Title: tibbe's haskell-style-guide at master - GitHub
09:10:59 <tolkad> I've been looking at the Control.Concurrent.Chan code and it seems to have a pretty serious memory leak if you use dupChan and don't read from both channels
09:11:00 <chrisdone> mornfall: I noticed that you and kowey had small conversation going on in the annotation hpaste paste. do you think adding comment support would be a good idea?
09:11:16 <tolkad> Will haskell optimize and remove this memory leak?
09:11:27 <EvanR-work> tolkad: the same will happen for one chan
09:11:30 <EvanR-work> if you dont read from it
09:11:35 <IceDane> chrisdone: Ah, sweet, thanks
09:11:46 <chrisdone> IceDane: do you use emacs?
09:11:54 <tolkad> EvanR-work: yes but the documentation suggests you can use dupChan to create "broadcast channels"
09:12:17 <EvanR-work> tolkad: and?
09:12:22 <tolkad> EvanR-work: implying you would write to one, and read from others duped from it
09:12:27 <EvanR-work> yes
09:12:37 <tolkad> EvanR-work: but if you do that you will have a memory leak
09:12:53 <EvanR-work> when using a fifo, you must be prepared to continually read from it
09:13:13 <IceDane> chrisdone: No. I use vim preferably, but I really do like the emacs haskell support
09:13:29 <IceDane> but I really can't get myself to use emacs for haskell and vim for everything else
09:13:36 <zygoloid> hmm. tibbe's style guide has examples which don't follow the style guide :(
09:13:49 <tibbe> zygoloid, that's bad :) which ones?
09:14:04 * tibbe is the only one allowed to violated tibbe's style guide
09:14:14 <zygoloid> in "Hanging Lambdas", there are indents of 10 spaces and 6 spaces
09:14:32 <zygoloid> these seem inconsistent with the 'indent 4 spaces, or 2 spaces for "where"' rule
09:14:51 <chrisdone> tibbe: haha
09:15:07 <zygoloid> tibbe: fwiw your style guide is very similar to the one i use :)
09:15:34 <chrisdone> tibbe: are you using my haskell-mode-exts? :o
09:15:40 <tolkad> programmers are obsessive compulsive about style
09:15:47 <tolkad> as long as it's readable, it's ok
09:16:02 <zygoloid> tolkad: you seem to be assuming that the obsession/compulsion is without merit
09:16:17 <zygoloid> consistency aids readability and means there's one fewer thing to think about
09:16:18 <tibbe> chrisdone, haven't had time to look at it yet, I'm snowed under with CUFP preparations
09:16:22 <vanadium> tolkad: Programming is already hard enough without hunting lost closing braces
09:16:29 <chrisdone> reading jinjing's code is like listening to jazz
09:16:36 <tolkad> vanadium: hence "readable"
09:16:40 <tibbe> zygoloid, I think it's the style me, Bryan, Duncan, and Don have settled upon
09:16:51 <tolkad> but 3 spaces vs 2 spaces vs 4 spaces is silly
09:16:53 <tibbe> zygoloid, thanks
09:17:01 <vanadium> Yeah. 3 spaces especially so.
09:17:40 <tibbe> zygoloid, That's on purpose, expressions are allowed to span multiple lines and inlined under itself
09:17:50 <chrisdone> out of not-really-thinking-about-it and being exposed to existing code I adopted a certain style that just happens to be exactly the same as tibbe's
09:17:52 <tibbe> zygoloid, didn't explain that though :)/
09:18:22 <zygoloid> tibbe: indeed not :)
09:18:59 <tomberek> hello
09:19:24 <chrisdone> tibbe: it'd be nice if this was on haskell.org as a kind of de facto/semi-official guide. once nominolo's finished updated to the latest site we can think about that stuff anyway
09:19:27 <zygoloid> tibbe: so it looks like the 4-space indent in the first "Hanging Lambda" example is from the start of 'forM_' not from the start of the line?
09:20:08 <zygoloid> not sure why, but i find it ugly to have indents which aren't k*(indent width)
09:20:31 <tomberek> can someone explain something about explicit quantification?
09:20:36 <zygoloid> (with k never increasing by more than 1)
09:20:58 <zygoloid> tomberek: explicit quantification allows you to put the quantifier in places other than where it would otherwise be inferred
09:21:06 <tomberek> http://hackage.haskell.org/packages/archive/QuickCheck/2.3/doc/html/src/Test-QuickCheck-Modifiers.html  what is the other method they mention in the comments?
09:21:06 <tibbe> zygoloid, right, it's from the preceding expression
09:21:13 <zygoloid> tibbe: which one?
09:21:27 <zygoloid> (which /bit/ of the preceding expression?)
09:21:28 <tibbe> zygoloid, from the expression with the lambda on it
09:21:34 <chrisdone> tibbe: wait when was the max line length *70* characters? do you adhere to this in your own projects?
09:21:39 <tibbe> formM
09:21:41 <tibbe> forM
09:21:47 <zygoloid> tibbe: the /smallest/ enclosing expression?
09:21:50 <tibbe> chrisdone, for comments yes
09:22:08 <Jonno_FTW> did I answer this question properly? http://stackoverflow.com/questions/3752898/haskell-format-number-with-commas/3753207#3753207
09:22:08 <tibbe> zygoloid, functions are only one expression, so that expression :)
09:22:12 <chrisdone> tibbe: ah, sorry, I just did a search in a tine xmonad window
09:22:14 <tibbe> zygoloid, it's intuitive to me
09:22:24 <tomberek> zygoloid: that much I got, but I'm trying to understand the other method the quickCheck authors meant, as opposed to using newtypes as modifiers.
09:22:41 <tibbe> zygoloid, I should make a note to that effect
09:22:44 <tibbe> really busy now though
09:23:49 <chrisdone> tibbe: coming to belhac?
09:23:52 <tomberek> zygoloid: or rather, what is the "explicit quantification" style of implementing Positive?
09:24:36 <zygoloid> tibbe: given f x = g <%> h <%> do ..., where <%> is infixr, where does the line continue?
09:24:39 <tibbe> chrisdone, I'd like to, haven't decided yet
09:25:01 <tibbe> chrisdone, every weekend the last 3 months has been booked with something and it doesn't seem to clear up until xmas
09:25:11 <zygoloid> (the smallest expression properly containing the 'do' starts with h <%> ...)
09:25:19 <tomberek> zygoloid: this confuses me "This is a stylistic alternative to using explicit quantification"
09:25:24 <tibbe> zygoloid, 4 spaces in from g
09:25:30 <chrisdone> tibbe: righteo
09:25:35 <tibbe> zygoloid, I did leave it up to the author in this case
09:25:56 <zygoloid> tibbe: if <%> is infixl, is it still up to the author?
09:27:14 <tomberek> ?
09:27:19 <malware> hi
09:27:23 <tomberek> hi
09:27:28 <malware> i couldnt install leksah
09:27:37 <zygoloid> tibbe: i think the issue i have is that i'd like for a style guide to be implementable as a program i can pass my code through, and get a pretty-printed version out.
09:27:46 <tibbe> zygoloid, I'm sorry but I don't have time to think about this at the moment :(
09:27:47 <malware> any alternative ide choice for haskell
09:27:50 <tomberek> malware, yeah, dependencies?
09:27:57 <tibbe> zygoloid, that's a good goal
09:27:58 <malware> no
09:27:59 <zygoloid> tibbe: ok, sorry for bugging you :)
09:28:09 <tibbe> zygoloid, no worries, I should have more time after ICFP
09:28:10 <chrisdone> zygoloid: indeed sounds like a good goal
09:28:11 <tibbe> take care
09:28:14 <tomberek> malware: not really, that is a persistent complaint
09:28:31 <tomberek> zygoloid: this confuses me "This is a stylistic alternative to using explicit quantification", from that quickCheck code
09:28:36 <IceDane> I tried leksah; I found it really strange
09:28:48 <IceDane> And I didn't like how it decided to replace stuff with symbols
09:28:50 <zygoloid> tomberek: what is being referred to there? i don't have the quickcheck code committed to memory ;)
09:28:57 <IceDane> like lambdas with the lambda character and all that
09:29:05 <tomberek> zygoloid: http://hackage.haskell.org/packages/archive/QuickCheck/2.3/doc/html/src/Test-QuickCheck-Modifiers.html#Positive
09:29:21 <tomberek> the block about arbitrary modifiers
09:29:32 <malware> usually which editor do you use?
09:30:02 <tomberek> zygoloid: they use newtypes to add conditions to the generators,, ie. Positive makes a generator only generate positive values
09:30:05 <malware> or how to quckly compile haskell code
09:30:12 <zygoloid> tomberek: i /think/ that's talking to quickcheck quantifiers of some kind, rather than haskell type quantifiers
09:30:25 <tomberek> oh,,
09:30:38 <IceDane> malware: I personally use vim(gvim) and almost always work in ghci until my code is ready
09:30:49 <IceDane> then it's often just a matter of doing :r after modifying your code
09:31:09 <malware> IceDane: ok but how are you sure about your code indent etc. is correct
09:31:10 <malware> ?
09:31:17 <tomberek> zygoloid: is using their newtype technique normally an acceptable way to add restrictions?
09:31:32 <IceDane> malware: I just said above that I have yet to develop a consistent style. I just read tibbe's guide, however, and I like it
09:31:56 <IceDane> and I am literally in the process of converting some code that I'm working on to use that style, as what I used before was an inconsistent mess at best
09:32:14 <zygoloid> tomberek: not really, since the restrictions aren't enforced in any way. usually, if you want to add restrictions to a type, you wouldn't export the newtype constructor
09:34:47 <tomberek> zygoloid: well, i'm trying to apply this to a graph. To allow something like.    myGraph = NoParallelEdges $ NoLoops myGraph :: NoParallelEdges NoLoops IntMapGraph  
09:35:07 <tomberek> or should that be done with typeclasses?
09:35:50 <zygoloid> if you export the constructors, then anyone can make a NoLoops graph which, in fact, has loops
09:36:14 <zygoloid> so one thing you can do is to make a separate module containing the NoLoops type, which doesn't export the constructor
09:36:19 <tomberek> zygoloid: well, should I do it that way and hide the contsructors and have things like stripLoops : Graph g => g -> NoLoops g
09:37:17 <tomberek> and then have an instance Graph g => Graph (NoLoops g)  that can preserve the noloopness
09:37:25 <zygoloid> yeah, that's a reasonable design, assuming you also have instance Graph g => g -> NoLoops g, and the Graph typeclass doesn't allow arbitrary graph mutations
09:37:39 <zygoloid> :D yeah, what you said :)
09:38:38 <tomberek> zygoloid: thanks, i just wanted to run my idea by someone with a bit more knowledge.  I didn't know if that newtyping method was the right way to do that
09:40:06 <zygoloid> well, having a custom datatype to represent some data with an invariant is a common pattern, and good design. using a newtype rather than data is then mostly just an implementation detail :)
09:40:35 <pyf> hi. i have a list that is expensive to generate. i want to pass it to several functions... e.g. h = f (g l) (j l) where l = makelist... in this example will the calculation of l be performed once or twice? thanks :)
09:42:06 <tomberek> zygoloid,, thanks
09:42:07 <zygoloid> pyf: once (assuming you use any normal haskell compiler/interpreter)
09:42:20 <zygoloid> pyf: though this is something which the language itself doesn't guarantee
09:42:52 <Cale> Also, assuming that the type of l is not typeclass polymorphic.
09:42:55 <pyf> zygoloid: ok thanks
09:43:18 <zygoloid> Cale: wouldn't the monomorphism restriction apply in that case?
09:43:29 <Cale> Well, yes
09:45:38 <moosefish> Is String able to represent all Unicode strings, or do I need to go with the text or utf8-string packages for that?
09:46:02 <pyf> that's what i expected, but when i replaced the second line with "where l = map trace "generatingElem" makeList" i got twice the output i was expecting, suggesting that each element is created twice?
09:49:51 <aristid> @src find
09:49:51 <lambdabot> find p          = listToMaybe . filter p
09:49:53 <Cale> pyf: Is your program short enough to put on hpaste or something?
09:51:30 <ddarius> moosefish: String has always been able to represent all Unicode strings.
09:53:44 <ddarius> moosefish: However, you probably want to use text anyway if you care about performance.
09:54:41 <moosefish> Actually, I'm looking at the thrift haskell bindings. I have a patch that fixes the integral types (they all mapped to Int; now they map to Word8, Int16, Int32 and Int64 as appropriate) and was wondering what I should map "string" to.
09:55:20 <moosefish> Seems there's Data.ByteString.Lazy.UTF8, String and Data.Text as obvious places to start with.
09:55:36 <malware> on mac 10.5.8 libproxy have an error
09:55:44 <malware> cant compile
09:55:46 <malware> pfff
09:56:01 <aristid> is there a lazier equivalent to mapM?
09:56:15 <aristid> @hoogle zipM
09:56:16 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
09:56:52 <ddarius> aristid: Lazier how?
09:57:04 <aristid> well, one that works on infinite input lists
09:57:07 <zygoloid> pyf: if you use l = trace "generating list" makeList, do you get one line of output or two?
09:57:23 <zygoloid> (no map)
09:57:44 <aristid> hmm i suppose that is not really possible
09:58:00 <pyf> one. i'll cut this to it's minimum and then put it on hpaste
09:58:13 <ddarius> aristid: Indeed, though mapM does work on infinite lists, you'll just never see the result.
09:58:30 <zygoloid> pyf: that suggests the elements of the list are being computed twice but the list is being created only once. that's weird!
09:58:40 <ddarius> @hackage thrift
09:58:40 <lambdabot> http://hackage.haskell.org/package/thrift
09:58:51 <aristid> ddarius: i have something like this: zip x `liftM` mapM f [0..]
09:59:30 <aristid> zip x `liftM` mapM f [0..length x] would work, but that would completely defeat the purpose of traversing x only once
10:00:03 <zygoloid> @hackage Thrift
10:00:03 <lambdabot> http://hackage.haskell.org/package/Thrift
10:02:39 <ddarius> aristid: Check out Foldable/Traversable perhaps.
10:11:01 * hackagebot haskeline 0.6.3.1 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.3.1 (JudahJacobson)
10:22:30 <por> I'm working through a book using OCaml. The syntax looks close to Haskell. Are the semantics of OCaml and Haskell close enough that I could just translate OCaml into Haskell, or are there 'features' of OCaml which would not translate?
10:23:25 <ccasin> por: there are a few key differences.  The ocaml module system is much more expressive than haskell's, and ocaml has objects (though they aren't used very much)
10:23:36 <bremner> and strictness
10:23:42 <ccasin> por: additionally, ocaml is "eager" while haskell is "lazy"
10:23:55 <Botje> por: and ocaml has float-versions of + and *
10:24:00 <ccasin> this is more likely to be a problem in the other direction, though
10:24:20 <zygoloid> well, technically haskell is non-strict rather than lazy ;)
10:24:36 <Twey> Doesn't OCaml have typeclasses?
10:24:41 <ccasin> no
10:24:55 <Twey> I always thought the OCaml module system was powerful enough to supersede our typeclasses
10:24:55 <ccasin> one uses functors instead
10:24:58 <aristid> it has functors
10:25:15 <Heffalump> Twey: typeclasses are implicit
10:25:18 <ccasin> Twey: in fact, they are equally powerful (in the sense we can translate in either direction), but they are different
10:25:21 <Twey> Hm, but they don't allow one to express addition of integers vs. floats without separate operators?
10:25:43 <ccasin> Twey: well, one could.  That just isn't how it is done in ocaml
10:25:47 <Twey> Oh
10:25:50 <Twey> That seems odd
10:26:30 <ccasin> modules can encode type class like things, but they aren't as convenient for that sort of overloading
10:27:03 <ddarius> While they are equally powerful, while it would be conceivable to encode modules by hand using type classes, the other way would be very unusable.
10:27:42 <Tomsik> There's no overloading in ocaml
10:27:49 <Tomsik> that's why there's + and +. for floats
10:28:09 <Tomsik> every and I mean every symbol has just one type and stuff
10:28:21 <Tomsik> which is pretty annoying, but I can see why
10:28:22 <ccasin> ddarius: it would be unusable directly in ocaml (just as ml-style functors would be very inconvenient to encode in haskell).  However, a simple pre-processing phase to do the dictionary passing would be simple to implement (I think karl crary has done this)
10:28:39 <Tomsik> I mean, you've got X.Y.Z and you know for sure what it is, you don't have to write type signatures anywhere
10:28:46 <Tomsik> unlike haskell's read
10:29:04 <Tomsik> where you often have to do (read x :: y)
10:29:27 <ddarius> ccasin: I'm saying the translation the other way is not -that- unusable directly.
10:30:22 <Tomsik> Long live modules and first-class records!
10:30:48 <sproingie> i find ocaml has even less usable introductory material than haskell
10:33:17 <ddarius> sproingie: Do you speak French?
10:33:24 <sproingie> ddarius: non
10:33:59 <sproingie> tho i did recently decide itd be fun to learn arabic
10:34:15 <sproingie> always liked the calligraphy
10:34:29 <Tomsik> I thought that Russian would be fun about a year ago, I don't anymore
10:34:49 <sproingie> i've heard it's a very terse language
10:35:03 <applicative> por, for what it's worth,  i remember a recent 'ocaml for haskellers' discussion on the haskell-cafe list, in among these http://www.haskell.org/pipermail/haskell-cafe/2010-April/thread.html  It's a bit disappointing, from looking now, I remember this was the one that said most: http://www.haskell.org/pipermail/haskell-cafe/2010-April/076402.html
10:35:04 <Tomsik> I mean, I just have bad connotations about Russian lessons and having to get up early on Mondays.
10:35:17 <sproingie> ah yes
10:35:40 <sproingie> chinese might be more useful to learn but thats even harder
10:36:06 <sproingie> plenty more speakers of it in the bay area tho
10:41:10 <benmachine> aristid: http://hpaste.org/30246/singletraversal_choice not sure how effective this is
10:43:44 <benmachine> aristid: should probably be a foldl'
10:44:13 <benmachine> or something.
10:46:54 <_linuxftw> Hi I want to load a bitmap image with haskell, so I found something called "Data.Bitmap" on code.haskell.org, but I don't know how to use/install it. Any pointers?
10:47:13 <benmachine> _linuxftw: where did you find it?
10:47:53 <_linuxftw> code.haskell.org/~bkomuves/projects/bitmap/dist/doc/html/bitmap/Data-Bitmap.html
10:49:41 <benmachine> _linuxftw: http://hackage.haskell.org/package/bitmap
10:49:54 <benmachine> _linuxftw: if you have cabal-install, try cabal update; cabal install bitmap
10:50:15 <_linuxftw> I don't think I have cabal, where can I get it?
10:50:20 <roconnor> c\_/
10:50:40 <aristid> benmachine: i've written my own version, but it's very ineffective so far :)
10:50:53 <benmachine> _linuxftw: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:51:00 <benmachine> aristid: how so?
10:51:08 <aristid> benmachine: btw. you don't need runRand
10:51:15 <aristid> IO is MonadRandom
10:51:18 <benmachine> oh right
10:51:43 <benmachine> pure rngs are better though :P
10:51:57 <aristid> iterativeChoice xs = (fst . last . filter ((== 0) . snd)) `liftM` zipWithM step xs [(0 :: Int) ..]
10:51:57 <aristid>     where step x i = do 
10:51:57 <aristid>             r <- getRandomR (0, i)
10:51:57 <aristid>             return (x, r)
10:52:12 <aristid> i'm not sure, but i somehow think this is not optimal
10:52:56 <aristid> benmachine: i also use Int because Integer seems like ridiculous when the algorithm will never finish on lists of that size anyways
10:53:07 <benmachine> won't work for choosing from lists longer than 2^32 :O
10:53:17 <benmachine> :P
10:53:19 <aristid> yes, i've also added that to the docs
10:53:30 <aristid> so if you read the docs you know it's only safe for "small" lists
10:54:51 <benmachine> it's not necessarily impossible that it'll finish on lists that size
10:55:04 <benmachine> ghci> length . replicate maxBound $ ()
10:55:04 <benmachine> 2147483647
10:55:04 <benmachine> (27.88 secs, 60246585868 bytes)
10:55:22 <aristid> benmachine: well generating random numbers is non-trivial
10:55:28 <benmachine> nah
10:55:35 <benmachine> generating *good* random numbers is nontrivial :D
10:55:52 <aristid> i'm sure haskell generates decent ones :)
10:56:21 <gwern> well, we're all in a state of sin where it comes to random numbers. who's to say who is better or worse?
10:56:24 <benmachine> well, I don't think the choice of numeric type is the most important thing in the world
10:56:24 <aristid> benmachine: i think i'll go for a foldl'-based solution, but trying to make it simpler than yours
10:56:31 <Tomsik> generating decent random number takes time 
10:56:34 <zygoloid> aristid: well, you could certainly make it generate fewer random numbers, with some added complexity
10:56:34 <benmachine> what could possibly be simpler :O
10:56:41 <benmachine> also I think the $! in return $! is redundant
10:56:44 <benmachine> (in mine)
10:57:03 <aristid> zygoloid: oh? that sounds interesting
10:57:06 <Tomsik> usually system-wide prngs are pretty awful, because they're not for cryptographic use and that's okay
10:57:25 <aristid> Tomsik: well i mainly just care that the distribution is uniform
10:57:27 <benmachine> Tomsik: yeah, it's a question of what properties you want from your "random" numbers
10:58:05 <aristid> but the nice thing is: MonadRandom is extensible
10:58:09 <benmachine> mm
10:58:09 <mornfall> [1..] is a very well distributed ... random ... sequence
10:58:16 <aristid> you can always plug in your more advanced PRNG
10:58:23 <mornfall> But, I should sleep. Night.
10:58:44 <aristid> ok you can also use this with RandomGen, but that's not as nice to use
10:58:45 <por> @ccasin, bremner: Thanks - it looks like the major difference (if objects aren't used much) is the difference in evaluation. Having gotten used to Haskell, that would be something to watch out for.
10:58:45 <lambdabot> Unknown command, try @list
10:59:18 <gwern> por: this isn't twitter
10:59:41 <zygoloid> aristid: you can keep track of how many bits of the previous random number you've used, and only ask for a new one when there aren't enough left (or better, simulate a stream of random bits by requesting more bits when it becomes near-empty)
10:59:53 <zygoloid> this relies on your PRNG giving good entropy on all bits
11:00:15 <benmachine> zygoloid: that sounds like it would demand more from the interface than MonadRandom supplies
11:00:27 <benmachine> and/or be horribly complicated
11:00:27 <aristid> zygoloid: ah, thereby avoiding the problem of requesting small-range random numbers and throwing away bits?
11:00:31 <zygoloid> benmachine: you can implement that on top of MonadRandom
11:00:37 <zygoloid> aristid: yeah
11:00:39 <aristid> zygoloid: but i think that can be done by an instance of MonadRandom
11:00:40 <benmachine> ok, so you don't need it in the algorithm then?
11:01:00 <benmachine> my algorithm is explicit about exactly the amount of randomness it requires :P
11:01:01 <zygoloid> that sounds like a nice approach
11:01:26 <Tomsik> btw
11:01:30 <zygoloid> depending on your underlying RNG it might not make any difference, but if generating a random number is expensive i could imagine that helping
11:01:40 <sproingie> "a little bit random"?
11:01:43 <Tomsik> random_number `mod` 10 won't give you uniform distribution
11:01:51 <Tomsik> even if random_number has it
11:02:01 <sproingie> Tomsik: how is that?
11:02:11 <benmachine> Tomsik: that's for the implementer of the PRNG to worry about
11:02:17 <Tomsik> look at bits, for example last four and see what happens
11:02:27 <benmachine> whoever writes the instance
11:02:31 <sproingie> doesnt that imply nonuniform distribution?
11:03:00 <Tomsik> 0 -> 0 ... 9 -> 9, A -> 0 ... F -> 6, but what about 7,8 and 9? they have smaller chance than 0 to 6 ;)
11:03:33 <benmachine> that's a fair point, but you can write RNGs that work around it
11:03:52 <monochrom> random_number `mod` 10 will give you uniform distribution if random_number is uniformly distributed over {1..100}
11:04:41 <benmachine> it'll be pretty dang close to uniform if random_number is distributed over {0 .. maxBound}
11:05:15 <_linuxftw> If 10 is a factor of maxBound would it be uniform?
11:05:16 <aristid> @pl \x y -> liftM (f y) x
11:05:16 <lambdabot> flip (fmap . f)
11:05:22 <monochrom> yes
11:05:23 <dafis> and if random_number is uniformly distributed over [0 .. maxBound :: Int], random_number `mod` 10 will be close enough to uniformly distributed for all but very special purposes
11:05:43 <dafis> slower than benmachine once again :(
11:05:43 <monochrom> and perhaps 10 is hexadecimal 10 to begin with
11:06:10 <Tomsik> heh
11:06:27 <aristid> benmachine: if everything goes right, you'll be amazed by the elegance of my solution :)
11:06:38 <benmachine> aristid: I'm preparing myself to make this face :O
11:07:35 <roconnor> :o
11:08:14 <roconnor> 10 is 10 in base 10
11:08:35 <benmachine> uhm
11:08:37 <benmachine> yes
11:09:56 <monochrom> 1 is 1 is all bases
11:10:06 <Tomsik> 0 is 0 in all bases too
11:10:06 <monochrom> err, 1 is 1 in all bases
11:10:17 <monochrom> today is tautology day
11:10:22 <aristid> 10 is 10 in all bases except base 1
11:10:23 <monochrom> I am at where I am
11:10:23 <_linuxftw> What about base 0?
11:10:27 * hackagebot ieee754 0.7.2 - Utilities for dealing with IEEE floating point numbers  http://hackage.haskell.org/package/ieee754-0.7.2 (PatrickPerry)
11:10:30 <Tomsik> no, you're doing it wrong monochrom 
11:10:32 <aristid> _linuxftw: base 0 is invalid
11:10:32 <benmachine> 1 is the only number expressible in base 0 I think >_>
11:10:44 <Tomsik> if today's a tautology day then today it's a tautology day
11:10:49 <benmachine> ok aristid's explanation makes more sense
11:10:49 <monochrom> hahaha
11:10:51 <_linuxftw> 1: 00, 5: 000000?
11:10:52 <aristid> benmachine: isn't 0 the only number expressible in it?
11:11:12 <geheimdienst> since when is 10 in base 16 the same as 10 in base 7?
11:11:15 <Tomsik> well, there's this system
11:11:22 <Tomsik> sometimes called improperly base 0
11:11:24 <geheimdienst> and the only number in base 0 is 0 i think
11:11:28 <Tomsik> where you have 1111 -> 4 etc.
11:11:37 <benmachine> Tomsik: that's base 1
11:11:39 <Tomsik> eg. 10 is 1111111111
11:11:39 <benmachine> more or less
11:11:59 <Tomsik> well, I've heard of this as of base 0
11:12:03 <Tomsik> which seems bogus to me
11:12:06 <benmachine> base 0 probably depends on what value you give to 0^0
11:12:15 <benmachine> which is more or less up to you :P
11:12:23 <monochrom> great
11:12:27 <roconnor> > 0^0
11:12:28 <lambdabot>   1
11:12:28 <geheimdienst> anything ^ 0 = 1
11:12:33 <Tomsik> I think we can call it "system where you just sum damn ones"
11:12:41 <geheimdienst> so how about base -1
11:12:42 <benmachine> 0 ^ anything = 0
11:12:48 <roconnor> > 0_0
11:12:48 <lambdabot>   Not in scope: `_0'
11:12:53 <benmachine> although that's actually less concrete because 0 ^ -1 = death
11:12:54 <Tomsik> there was this fibonacci system
11:12:55 <_linuxftw> ben, not true for negative numbers
11:21:31 <Twey> > 0 ** negate 1
11:21:31 <lambdabot>   Infinity
11:22:01 <Twey> benmachine: No number can be expressed in base 0
11:22:07 <Twey> _linuxftw: That's base 1
11:22:17 <Twey> (sort of, but it's not the same as other bases)
11:22:18 <benmachine> Twey: not even zero?
11:22:21 <Twey> benmachine: No
11:22:30 <Twey> benmachine: Base 0 is expressing numbers with no symbols
11:22:34 <Twey> Hm
11:22:35 <Twey> Wait
11:22:36 <benmachine> heh
11:22:45 <benmachine> maybe "" expresses zero then
11:22:46 <Twey> I guess not necessarily
11:22:49 <Twey> Heh
11:23:00 <Twey> I guess if you consider it a standard positional system
11:23:01 <benmachine> besides, base e isn't expressing numbers with two symbols >_>
11:23:08 <benmachine> er
11:23:10 <benmachine> *is*
11:23:21 <Twey> It doesn't necessarily relate to the number of symbols
11:23:21 <benmachine> I meant to say, isn't expressing numbers with e symbols
11:23:35 <monochrom> nice, the ieee package gives you infinity and nan
11:23:35 <Twey> I guess you can have a symbol, but all the places are powers of zero (i.e. 0)
11:23:49 <Twey> So you probably can express zero
11:23:52 <Twey> And base-1 works too
11:24:02 <Twey> (no fractions, though)
11:24:19 <_linuxftw> Anyway, I've got some Haskell troubles. I've cabal installed bitmap now, but ghc is producing a link error, main.o:fake:(.text+0x79d): undefined reference to '__stginit_bitmapzm0zi0zi1_DataziBitmap_'.
11:24:27 <Twey> _linuxftw: Are you using --make?
11:24:39 <_linuxftw> Umm, no
11:24:47 <Twey> --make is the panacea for all link errors. :þ
11:25:10 <_linuxftw> oh very nice
11:25:13 <_linuxftw> It works now
11:25:15 <tommd> I think we get 1 question a day on that, be it on IRC, ML, reddit, or somewhere else.
11:25:51 <Twey> Heh
11:25:53 <tommd> GHC should probably say "did you use '--make'?" in the event of linker errors.
11:26:03 <Twey> Maybe we should just make --make the default?
11:26:06 <Twey> Why isn't it?
11:26:11 <aristid> benmachine: hmm ok i'm not completely happy with my version yet
11:26:14 <monochrom> neat, ieee is renamed to ieee754
11:26:22 <tommd> Makes sense.
11:26:29 <benmachine> aristid: perfectionism is a plague that afflicts us all :P
11:26:42 <aristid> benmachine: heh, wait, let me show what i have so far
11:26:46 <benmachine> Twey: inertia, I guess?
11:26:48 <tommd> But its a bit sad to have packages named after standards numbers (even extremely well known once).  I mean, what if I released haskell package rfc4303?
11:26:55 <Twey> Maybe
11:26:56 <geheimdienst> ghc should print a message suggesting to run it with --make
11:27:03 <benmachine> tommd: what then?
11:27:10 <benmachine> I personally would feel violated
11:27:13 <benmachine> and/or not care
11:27:13 <Twey> I guess it slows the build process a little over specifying packages manually
11:27:15 <benmachine> not sure which
11:27:33 * hackagebot bits-extras 0.1.3 - Efficient high-level bit operations not found in Data.Bits  http://hackage.haskell.org/package/bits-extras-0.1.3 (GabrielWicke)
11:27:44 <tommd> You probably wouldn't care until haskell packages rfcX for X `elem` [1..6000] are released.
11:27:55 <Twey> Heh.
11:28:04 <benmachine> tommd: how is that a problem?
11:28:04 <aristid> benmachine: http://hpaste.org/paste/30246/my_preliminary_version_of_sing#p30248
11:28:18 <Twey> > map (("rfc" ++) . show) [1 .. 6000]
11:28:19 <lambdabot>   ["rfc1","rfc2","rfc3","rfc4","rfc5","rfc6","rfc7","rfc8","rfc9","rfc10","rf...
11:28:53 <tommd> benmachine: It lacks description.  If you can call a package IPSec-Encap  instead of "rfc4303" or "MobileIP" instead of "RFC4232" or whatever then thats certainly an improvement.
11:29:05 * monochrom uploads package "rfc". it implements all rfc standards. exposed-modules: RFC1, RFC2, RFC3 ...
11:29:12 <tommd> lol
11:29:47 <benmachine> tommd: oh, sure, more descriptive is more better, but if you are specifically looking for implementation of some feature that has a well-known standard...
11:29:55 <fxr> wow, I need 2822
11:30:05 <geheimdienst> fxr, mail?
11:30:09 <fxr> yep
11:30:11 <tommd> benmachine: Then you can search and the package should have that in the synopsis.
11:30:20 <monochrom> "754" is probably imprinted into many students' memory
11:30:25 <fxr> also 2616
11:30:35 <aristid> benmachine: hah, i don't find a way to make it nicer. but should i make it stricter?
11:30:41 <benmachine> tommd: good point
11:30:54 <c_wraith> 754 is an important one.  But lots of people don't understand its consequences.
11:30:58 <benmachine> aristid: yeah I think a thunk will build up in the first part of the tuple
11:31:00 <fxr> and 2388,2045, 2046, 2109 and also 2821,2822, 3501
11:31:02 <benmachine> it's not forced until the end
11:31:18 <benmachine> return $ seq new (new, n + 1)
11:31:21 <aristid> benmachine: might a thunk of returns also build up?
11:31:22 <c_wraith> don't forget 1394
11:31:25 <tommd> monochrom: yeah, and I noted that at the start of this rant, but in general it should be avoided / left to the synopsis.
11:31:25 <benmachine> I'm not sure if that's all you need but I think that would help
11:31:28 <monochrom> and nicknames here should be md5 hashes anyway
11:31:37 <c_wraith> Though both 754 and 1394 are IEEE, not RFC
11:31:37 <benmachine> aristid: I don't *think* so because I think it's used in the next iteration, but shrug
11:32:19 * monochrom had a modem supporting CCITT v.24
11:32:26 <benmachine> aristid: these kind of issues are subtle and difficult to pin down, you should either profile or just ignore it and wait for your users to whine >_>
11:32:28 <aristid> so return $! new `seq` (new, n + 1)
11:32:29 <aristid> ?
11:32:40 <aristid> benmachine: how to profile? :)
11:32:46 <benmachine> aristid: but in the version I did, the new `seq` tuple showed a significant speedup
11:32:52 <aristid> profiling is something i should learn anyways
11:32:54 <benmachine> I don't think $! on the return made a huge difference
11:33:09 <benmachine> aristid: I'm not an expert, I'm afraid
11:33:14 <benmachine> I've heard good things about criterion
11:33:31 <benmachine> but you really want memory more than speed (although lots of memory generally results in slow)
11:33:43 <benmachine> I don't remember if criterion does heap profiles
11:33:45 <benmachine> but
11:33:47 <benmachine> the easy way
11:34:06 <benmachine> is just compile with -prof (possibly -auto-all)
11:34:14 <benmachine> and run prog +RTS -p
11:34:23 <benmachine> it'll generate a Main.prof or some such
11:34:38 <benmachine> which will have stuff like maximum residency
11:34:49 <benmachine> anyway
11:34:57 <benmachine> the *really* easy way is ghci and :set +s
11:35:08 <aristid> yeah i guess that's actually sufficient for this :D
11:35:09 <benmachine> but that way you might not be using optimisations, so it's kind of silly
11:35:16 <aristid> that's also true
11:35:25 <benmachine> compile to object code with -O or -O2 and then load in ghci, I guess that'd be fine
11:35:28 <aristid> maybe i should compile the module and then test it in ghci? :D
11:35:35 <benmachine> mm
11:35:40 <aristid> ok!
11:35:55 <benmachine> the trouble with ghci is I think its memory is total allocation rather than maximum residency
11:36:06 <benmachine> but maybe that's not important
11:37:47 <aristid> ok there is still no effect between $ and $!
11:38:59 <benmachine> mm
11:40:51 <aristid> benmachine: for lists like [1..100000], choice is faster than iterativeChoice
11:41:34 <aristid> for [1..10000000] too
11:42:14 <benmachine> aristid: you mean your original choice? hmm
11:42:20 <aristid> yes
11:42:22 <aristid> i keep both
11:42:30 <benmachine> try a list that needs computation
11:42:34 <benmachine> like, a list of primes or something
11:42:39 <benmachine> maybe
11:42:52 <aristid> benmachine: but every element needs to be computed anyways
11:43:00 <benmachine> aristid: hmmmm
11:43:03 <benmachine> good point
11:43:03 <aristid> difference is just, iterativeChoice doesn't need to store them
11:43:17 <benmachine> so you want a list of big things, or a very long list
11:43:29 <aristid> benmachine: the problem is the random number generator i think
11:43:33 <aristid> it seems to be VERY slow
11:43:36 <benmachine> oh ok
11:43:43 <mokrzu> hello, it's second time when i try to learn haskell, last time i stuck on "modules" chapter in LYAH (learning all this functions came to be boring), now i want back to haskell and be able to write some usefull code. should i back to LYAH or start with Real World Haskell ?
11:44:13 <sproingie> i'd finish up with LYAH
11:44:22 <dafis> aristid: which PRNG are you using?
11:44:34 <aristid> dafis: wait a second
11:46:00 <aristid> dafis: randomRIO
11:46:20 <benmachine> wow, runRand seems to take much longer than the IO version
11:47:10 <dafis> aristid: randomRIO is a method of class Random, are you using StdGen?
11:47:19 <dafis> i.e. System.Random
11:47:23 <aristid> dafis: i suppose i am.
11:47:46 <dafis> aristid: that *is* very slow. Try to use mersenne or mwc
11:48:00 <aristid> dafis: randomRIO is in class Random only and does not depend on RandomGen
11:48:10 <aristid> but it is System.Random
11:48:21 <aristid> dafis: which package would that be?
11:48:51 <xplat> the problem with the one-pass chooser is you can cut the number of random bits it uses but you cannot cut it down nearly as much as the 2-pass version
11:48:59 <tommd> @hackage random
11:48:59 <lambdabot> http://hackage.haskell.org/package/random
11:49:04 <tommd> aristid: ^^
11:49:06 <tommd> that package
11:49:15 <aristid> tommd: i mean the mersenne,...
11:49:23 <tommd> oh, there are several
11:50:02 <dafis> aristid: mersenne-random resp. mwc-random
11:50:12 <xplat> but you can cut it a lot more than just pulling log i bits out each step
11:51:26 <xplat> the ideal way to do one-pass choice is to treat it like a fractional codec and just pull enough bits to know whether the next symbol is 0 or not
11:51:45 <aristid> is it possible that hoogle now indexes many more packages?
11:52:03 <dafis> aristid: it might be nontrivial to get them to work with MonadRandom, I haven't tried yet
11:52:19 <aristid> dafis: should be no problem, as long as they provide a RandomGen
11:52:33 <tommd> They don't.
11:53:00 <xplat> if you do that i THINK you can get away with O(n) expected random bits
11:53:26 <dafis> aristid: AFAIR, the don't provide a RandomGen instance, if you don't need split, you should be able to fake one
11:53:31 <xplat> if you actually generate all the random numbers you need ~ n lg n random bits
11:53:41 <tommd> I've made proposals to l@h.o that would make mersenne twister and the RandomGen class more agreeable with each other, but there is resistance to changing the RandomGen class at all, so I'm not sure if the proposals will all go thought.
11:53:46 <tommd> s/throught/ through.
11:53:57 <xplat> and if you use 2-pass, you just need lg n
11:54:03 <aristid> dafis: no RandomGen? :(
11:54:40 <dafis> aristid: no split, hence no RandomGen
11:54:47 <xplat> a better way to speed it up while staying with a single pass is chunking
11:55:10 <aristid> dafis: why no split?
11:55:15 <tommd> The new RandomGen might not have split - that is the more likely of the two proposals to go through.
11:55:49 <dafis> aristid: I suppose there's no decent way to split them
11:56:17 <tommd> split has very poor theoretic basis.  You don't have any more entropy, the two new generators will be correlated.
11:56:25 <xplat> for each, say, 1024 random numbers, take a random sample to decide to latch something in that 1024, and choose one at random uniformly if so
11:56:34 <aristid> Due to the current SFMT library being vastly impure, currently only a single generator is allowed per-program. Attempts to reinitialise it will fail. 
11:56:55 <geheimdienst> :t getArgs
11:56:56 <lambdabot> Not in scope: `getArgs'
11:57:02 <geheimdienst> @hoogle getArgs
11:57:02 <lambdabot> System.Environment getArgs :: IO [String]
11:57:10 <tommd> xplat: 'split' only takes a generator as an argument, so that "something" has to come from somewhere.
11:57:32 <geheimdienst> any reason why that is in IO? i can't imagine any sane scenario where the args would change during the program's lifetime
11:57:53 <benmachine> geheimdienst: see: withArgs
11:58:06 <benmachine> also, it would change invocation to invocation
11:58:07 <xplat> tommd: you can have a nice split if you're willing to make each child take twice as long ... but i was talking about iterativeChoice, not split
11:58:22 <benmachine> it really depends on what you mean by pure, or referentially transparent
11:59:15 <Tomsik> :t withArgs
11:59:16 <lambdabot> Not in scope: `withArgs'
11:59:31 <dafis> @hoogle withArgs
11:59:31 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
11:59:33 <xplat> tommd: (the 'nice' split is to split into odd and even samples of the parent ... nice theoretically, but only works for pure generators and is slow as hell)
11:59:41 <geheimdienst> okay i see, didn't know about withArgs. what a strange function
12:00:01 <aristid> dafis: mersenne-random looks like randomR is also missing
12:00:11 <tommd> xplat: Right, so in practice people don't exactly halve the period and instead hope things work out
12:00:19 <dafis> geheimdienst: very handy if you want to do some preparation before the real main
12:00:47 <Lemmih> geheimdienst: ghci finds it very useful.
12:00:57 <dafis> aristid: yes, the API is sparse, but it's much faster than StdGen
12:01:03 <tommd> xplat: b.o.s. suggested an ever decreasing "entropy" value be returned on each split.  I liked the idea but think he and I were the only ones.
12:01:06 <geheimdienst> dafis, what would be an example for this preparation?
12:01:13 <aristid> generally mersenne-random has a broken API
12:01:22 <aristid> i mean, they could do away with MTGen completely
12:01:40 <aristid> random !_ = ...
12:01:50 <aristid> where !_ matches the MTGen, haha
12:01:56 <xplat> tommd: that could be pretty sensible if you could do things like replenish the entropy pool from IO and split entropy unequally
12:02:28 <aristid> oh, i guess the reason is to check that it has actually been initialised
12:02:42 <dafis> geheimdienst: for example, if you use criterion to do some benchmarks, you can set up some stuf with do { args <- getArgs; let { something }; withArgs [] defaultMain benchmarks }
12:03:12 <tommd> xplat: Yes.  Sadly 'RandomGen' doesn't have a generalized routine to add entropy (unlike CryptoRandomGen).
12:05:06 <aristid> dafis: mwc-random looks MUCH better than mersenne-random
12:05:27 <dafis> aristid: so see whether you can use that
12:07:20 <aristid> well, i would need to write wrappers for it to work with MonadRandom, and then it should work
12:07:28 <EvanR-work> mwc type generators are also much simpler
12:07:37 <EvanR-work> than mt brand generators
12:07:50 <aristid> i also like how mwc works in ST
12:07:52 <EvanR-work> 'worse is better' for some reason
12:08:30 <aristid> hmm
12:08:37 <aristid> no, i don't like how mwc works in ST
12:08:40 <aristid> that one is evil
12:09:29 <roconnor> tommd: RandomGen hardly has an entropy pool to begin with
12:09:52 <tommd> RandomGen is just a class, so to claim anything about it having data does not compute to me.
12:09:53 <roconnor> tommd: if you want to "add entropy" to RandomGen you might as well call mkRandomGen
12:10:03 <roconnor> tommd: ah oops
12:10:14 <roconnor> @hoogle stdGen
12:10:15 <lambdabot> System.Random data StdGen
12:10:15 <benmachine> ok I clearly don't understand reddit at all
12:10:15 <lambdabot> System.Random getStdGen :: IO StdGen
12:10:15 <lambdabot> System.Random mkStdGen :: Int -> StdGen
12:10:24 <roconnor> tommd: sorry, my bad
12:10:34 <tommd> Yeah, I don't talk about StdGen - it doesn't exist to me (much like Matrix 2 and 3)
12:10:39 <benmachine> it told me, lines starting with four spaces are code, this seems to be a lie
12:11:01 <benmachine> I discovered by sheer luck that enclosing things in backticks seems to monospace it, but then I want code with backticks in
12:11:13 * benmachine rages slightly
12:11:57 <benmachine> ok possibly I just can't count spaces
12:12:22 <benmachine> also yay I'm on reddit now
12:12:37 <tommd> bernmachine: welcome to hell, in that case.
12:12:47 <benmachine> thx
12:15:15 <aristid> benmachine: if i want to write an instance of MonadRandom for mwc, should i put that into a different package because it introduces a new dependency?
12:15:46 <benmachine> aristid: ideally you'd get MonadRandom or mwc to add it to their packages, to avoid it becoming orphan
12:16:10 <benmachine> other than that, well, it's up to you
12:16:11 <zc00gii> how can I change a '4' for example to 4?
12:16:18 <zc00gii> like, char to int
12:16:23 <benmachine> sometimes people make foo-instances packages
12:16:27 <benmachine> always seemed a bit silly to me
12:16:36 <aristid> benmachine: no, it would not be orphan because i'd add a newtype.
12:16:37 <benmachine> @hoogle Char -> Int
12:16:37 <lambdabot> Data.Char digitToInt :: Char -> Int
12:16:37 <lambdabot> Data.Char ord :: Char -> Int
12:16:37 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
12:16:38 <mauke> > digitToInt '4'
12:16:39 <lambdabot>   4
12:16:45 <benmachine> aristid: ah, sharp
12:17:06 <aristid> benmachine: i know it's up to me, but i'd like to hear your advice:)
12:17:14 <benmachine> I would say, add the dependency and don't worry about it, unless mwc is a particularly big package, or depends on C libraries or something
12:17:24 <benmachine> (in the latter case because it might make you less portable)
12:17:39 <benmachine> in general I don't think more dependencies is a terrible thing
12:17:45 <benmachine> more library usage is good
12:17:54 <zc00gii> mauke: ty
12:18:14 <aristid> benmachine: ok :)
12:19:36 <benmachine> aristid: I know you know it's up to me, it just makes me nervous when people treat me like I know anything >_>
12:19:40 <benmachine> eeer
12:19:41 <benmachine> *you
12:19:45 <benmachine> see >_<
12:21:54 <xplat> benmachine: are you afraid they might be right?
12:22:36 <benmachine> that would be terrible
12:23:01 * ddarius is reminded of "We Can Remember It For You Wholesale"
12:24:57 <aristid> benmachine: well, if your advice is terrible, other people will hopefully tell me and then i drop you into a lake of battery acid
12:25:32 <benmachine> oh, that's reassuring :)
12:25:40 * benmachine giggles
12:25:49 <benmachine> yeah, don't mind my insecurities
12:27:39 <aristid> @src (->) Monad
12:27:40 <lambdabot> Source not found. Wrong!  You cheating scum!
12:27:43 <zc00gii> ok, with euler #8, not a haskell question, can someone please help me remove all of the damned whitespace?
12:27:52 <aristid> lambdabot: no, YOU cheating scum
12:27:53 <zc00gii> with sed or something? I have it copied into a file
12:28:18 <zc00gii> http://projecteuler.net/index.php?section=problems&id=8 see? :|
12:28:22 <xplat> you know, i was just doing some of the exercises in Real World Haskell, and it occurred to me i don't know how to combine two comparators for sortBy
12:29:23 <Botje> zc00gii: just remove the newlines with vim or something?
12:29:34 <Saizan> zc00gii: ghc -e "interact (filter (not . (==' ')))"
12:29:44 <xplat> like, if i have f: a -> b -> Ordering and g: a -> b -> Ordering, to get a function f `orBy` g which is f unless f returns EQ otherwise it is g
12:29:53 <benmachine> (not . isSpace)
12:29:53 * hackagebot monte-carlo 0.3.1 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.3.1 (PatrickPerry)
12:29:56 <Saizan> repeat for newlines
12:29:58 <benmachine> filter isDigit, even
12:30:00 <xplat> er, imagine those were double colons
12:30:05 <Gracenotes> > 0x5767
12:30:06 <lambdabot>   22375
12:30:09 <Gracenotes> \o/
12:30:10 <zc00gii> Saizan: not quite sure I want to do that.
12:30:16 <benmachine> xplat: Ordering is a monoid!
12:30:22 <Saizan> benmachine: you need to import Data.Char though :°
12:30:32 <benmachine> xplat: better still, a -> Ordering is a monoid
12:30:40 <benmachine> Saizan: yes, true
12:31:10 <benmachine> xplat: a -> b is a monoid whenever b is a monoid, so a -> b -> Ordering is... yeah.
12:31:33 <Twey> @src (->) mplus
12:31:34 <lambdabot> Source not found. You untyped fool!
12:32:01 <xplat> benmachine: excellent.
12:32:06 <benmachine> > sortBy (comparing length `mappend` flip compare) [[1,2,3],[1,2,4],[1,2],[1,2,3,4]]
12:32:07 <lambdabot>   [[1,2],[1,2,4],[1,2,3],[1,2,3,4]]
12:32:19 <tommd> Saizan: No, you can be explicit (Data.Char.isSpace)
12:32:27 <xplat> @hoogle comparing
12:32:28 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:32:32 <Saizan> tommd: ah, true
12:33:13 <xplat> i learn something new twice an hour here :)
12:33:40 <ddarius> > let cmp xs ys = mconcat (zipWith compare xs ys) in (cmp [1,2,3] [1,2,4], cmp [2,1] [1,2])
12:33:41 <lambdabot>   (LT,GT)
12:34:34 <ddarius> Unfortunately that doesn't work when the lists aren't the same size.
12:35:37 <xplat> @pl \xs ys -> mconcat $ zipWith compare xs ys
12:35:37 <lambdabot> (mconcat .) . zipWith compare
12:41:04 <ddarius> Ordering is the smallest non-commutative monoid.  Are any of the other 3-element monoids non-commutative?
12:42:40 <xplat> no; there's only one other 3-element monoid up to renaming
12:43:16 <aristid> i have x = m a and want m [a], containing an infinite list of the results of x
12:43:19 <aristid> is that possible?
12:43:21 <xplat> wait, i'm wrong.  for some reason i was assuming them to be 'balanced'.
12:43:51 <Twey> aristid: It's certainly possible, but with a strict monad it won't terminate
12:43:56 <Zao> unsafeinterleavekittens?
12:44:20 <Twey> :t repeatM
12:44:21 <ddarius> What's unsafe about interleaving kittens?
12:44:21 <lambdabot> Not in scope: `repeatM'
12:44:24 <aristid> Twey: it's based around IO
12:44:26 <ddarius> @hoogle repeatM
12:44:26 <lambdabot> No results found
12:44:41 <Twey> Hmph
12:44:42 <xplat> 3-element monoid = 2-argument boolean function, so there are 16/2 = 8
12:44:45 <tibbe> nominolo: there?
12:44:46 <Twey> aristid: Then it won't terminate, of course
12:44:52 <Zao> ddarius: Cats are pointful. Blood may be let from the caller.
12:45:23 <Twey> repeatM = sequence . repeat
12:45:24 <aristid> getChanContents :: Chan a -> IO [a]
12:45:27 <Twey> :t sequence . repeat
12:45:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
12:45:31 <aristid> Twey: i think i can use forkIO :D
12:45:32 <xplat> hm, maybe more than 8 since some may be symmetric under renaming
12:46:19 <Twey> aristid: The list in getChanContents is not infinite
12:46:46 <Twey> (I'm pretty sure)
12:46:58 <mwc> This is the first non-trivial enumeratee I've written, can I get some comments from the iteratee-io gurus letting me know if this is idiomatic or what I should improve? http://hpaste.org/30249/enumeratorbased_enumeratee (uses the enumerator library)
12:47:15 <aristid> Twey: Return a lazy list representing the contents of the supplied Chan, much like System.IO.hGetContents. 
12:47:23 <aristid> Twey: lazy sounds like it should wokr
12:47:26 <Twey> Oh, okay
12:47:29 <Twey> Then yes
12:47:33 <Twey> That'll work
12:47:38 <aristid> \o/
12:47:41 <Twey> Though it might be a bad idea
12:47:50 <Twey> It's not the same as what you were asking for, though
12:47:52 <aristid> why? i want to generate random numbers
12:48:08 <Twey> Because lazy IO is generally a bad idea
12:48:14 <Twey> No error-handling, &c.
12:48:17 <aristid> Twey: it's not IO
12:48:20 <aristid> it's mwc-random
12:48:27 <Twey> Huh?
12:48:31 <aristid> well it's in IO, but it's not I/O
12:48:32 <Twey> getChanContents is IO
12:48:54 <Twey> There are things that can go wrong in the performance of its duties
12:49:02 <Twey> Which can't be handled when using lazy IO
12:49:30 <xplat> lazy IO is evil and wrong
12:49:41 <aristid> well i want to define getRandoms from MonadRandom, no matter how stupid it is
12:51:13 <xplat> well, your approach is probably as good as any then, if mwc is impure.
12:51:53 <aristid> xplat: i can get an IO a from mwc, but not an IO [a]
12:52:02 <xplat> at least it's better than using unsafePerformIO directly
12:52:27 <aristid> xplat: heh, using unsafePerformIO inside IO would be weird
12:53:12 <xplat> probably even safer than unsafeInterleaveIO directly on mwc for locking/reentrancy reasons
12:54:04 <aristid> @hoogle unsafeInterleaveIO
12:54:05 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
12:55:00 * hackagebot alsa-core 0.5 - Binding to the ALSA Library API (Exceptions).  http://hackage.haskell.org/package/alsa-core-0.5 (HenningThielemann)
12:56:27 <aristid> ouch! mwc uses a class distinct from Random for its randomness :(
12:56:55 * ddarius just got spammed with physical email.
12:57:00 * hackagebot alsa-pcm 0.5 - Binding to the ALSA Library API (PCM audio).  http://hackage.haskell.org/package/alsa-pcm-0.5 (HenningThielemann)
12:57:02 * hackagebot alsa-midi 0.4.0.1 - Bindings for the ALSA sequencer API (MIDI stuff)  http://hackage.haskell.org/package/alsa-midi-0.4.0.1 (HenningThielemann)
12:57:50 <aristid> ok, looks like i should switch from package MonadRandom to another monad for random values
12:57:52 <aristid> hmmhmm
12:59:36 <taktoa> hey
12:59:49 <taktoa> I'm trying to make a function
13:00:01 * hackagebot alsa-seq 0.5 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.5 (HenningThielemann)
13:00:05 <taktoa> like map, but it takes a function of type a -> Int -> b
13:00:19 <kmc> aristid, i asked bos about using unsafeInterleaveIO to make a lazy infinite list of random numbers from mwc-random, and he said it was probably ok
13:00:23 <kmc> then i implemented it and it worked
13:00:24 <Twey> taktoa: With the key?
13:00:26 <taktoa> so you can pass an index for each item in the list
13:00:27 <kmc> but i didn't end up using it
13:00:31 <taktoa> yep
13:00:39 <taktoa> here's my code
13:00:40 <taktoa> http://pastebin.com/YVwYL9yx
13:00:43 <taktoa> it fails
13:00:49 <kmc> :t \f -> zipWith f [0..]
13:00:50 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
13:01:06 <Twey> :t flip zipWith [0 ..]
13:01:07 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
13:01:23 <kmc> :t flip zipWith [0..] . flip
13:01:24 <lambdabot> forall a b c. (Num a, Enum a) => (b -> a -> c) -> [b] -> [c]
13:01:46 <Twey> If you prefer it the other way around.
13:01:48 <taktoa> ah, it seems that would work
13:01:54 <taktoa> lemme test it out
13:02:04 <aristid> kmc: yeah, i've got the problem that the MonadRandom package which i currently use is stupid.
13:02:29 <taktoa> cool, it compiles
13:02:38 <taktoa> thanks
13:03:11 <kmc> uniforms = liftA2 (:) uniform (unsafeInterleaveIO uniforms)
13:03:35 <xplat> ok, there are essentially 3 noncommutative monoids with 3 elements.  one is Ordering, one is boolean implication with an extra identity element, one is 'choose the opposite of what's on the left' for nonidentities
13:04:45 <chrisdone> aw, hell yeahh
13:04:59 <chrisdone> importing all the old pastes from old hpaste, concurrently
13:05:00 <chrisdone> myess
13:05:12 <chrisdone> I love that extremly fast scrolling down the screen
13:05:13 <FunctorSalad> concurrently?
13:05:23 <chrisdone> well, I split the job into four for each of my cores
13:05:31 <FunctorSalad> seems like an activity you wouldn't too all that often ;)
13:05:41 <FunctorSalad> (but you still made it concurrent?)
13:05:46 <FunctorSalad> s/too/do/
13:05:54 <chrisdone> yeah because I have 30k to import and it was doing like 2 a second
13:06:13 <chrisdone> it's easier to write some forkIO here and there than to optimise string parsing functions
13:06:13 <sinelaw> i'm still stuck with the auto-implementation of instances problem
13:06:20 <geheimdienst> > 15000 / 60 / 60
13:06:20 <lambdabot>   4.166666666666667
13:06:24 <sinelaw> I have: class C where ....
13:06:32 <geheimdienst> 4 hours ...
13:06:38 <_linuxftw> Does the !! function take linear time to return?
13:06:40 <sinelaw> and I want to specify that every (c a) is an Eq  instance
13:06:47 <ddarius> You have a nullary class?  That's impressive.
13:06:47 <FunctorSalad> _linuxftw: yes
13:07:07 <_linuxftw> That's a problem.. how can I work with a list containing 4 million entries without it being too slow?
13:07:08 <sinelaw> last night someone suggested using a newtype, newtype EqC  c = EqC { unEqC :: c }
13:07:12 <sinelaw> i can't see how that helps
13:07:15 <kmc> _linuxftw, don't use a list
13:07:21 <kmc> lists are singly-linked lists
13:07:25 <sinelaw> any hints?
13:07:38 <sinelaw> Saizan, you there?
13:07:43 <kmc> _linuxftw, consider Data.Sequence, Data.Map, Data.IntMap, Data.Array, etc.
13:07:44 <_linuxftw> The list currently represents an image, the !! is used to get pixels from coordinates. What should I use instead then kmc?
13:07:49 <_linuxftw> Ahh ok
13:07:51 <_linuxftw> thanks
13:07:59 <kmc> if you have no updating, Array will be fast
13:08:01 <kmc> but its updates are slow
13:08:07 * hackagebot suitable 0.1 - Abstract over the constraints on the parameters to type constructors  http://hackage.haskell.org/package/suitable-0.1 (GaneshSittampalam)
13:08:09 * hackagebot rmonad 0.6 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.6 (GaneshSittampalam)
13:08:17 <xplat> _linuxftw: if you need random access anything is better than lists.  but sometimes you only think you need random access...
13:08:17 <FunctorSalad> unless you use ST arrays
13:08:19 <kmc> maps have nice sharing between versions, so fast update
13:08:22 <chrisdone> FunctorSalad: man concurrency is so easy in haskell http://hpaste.org/30250/importing_old_hpaste_pastes
13:08:53 <_linuxftw> xplat: I might be able to implement my algorithm without random access.. but it would be harder
13:09:00 <kmc> chrisdone, is segmenting it like that faster than forking a thread for every paste? :D
13:09:01 <xplat> on Oleg's site somewhere is something about an array package in iteratee style, that approach might be handy for images too
13:09:02 <chrisdone> (could speed it up by pooling db connections too)
13:09:21 <FunctorSalad> chrisdone: *nod*
13:09:21 <chrisdone> kmc: haha, good question
13:09:22 <xplat> he was using it for matrix algorithms
13:09:29 <kmc> _linuxftw, see also enummap, hashmap, and vector packages on hackage
13:09:44 <_linuxftw> What about a bytestring, is that good for random access?
13:09:51 <kmc> chrisdone, i assume they have to lock a database or something, so it could be a problem
13:10:03 <kmc> _linuxftw, yeah, strict bytestring indexing is O(1) (it's a flaw array in memory)
13:10:07 <kmc> but updates are more expensive
13:10:23 <_linuxftw> I don't need to update so it's no problem
13:10:28 <kmc> cool
13:10:28 <chrisdone> kmc: also postgresql has a limited number of connections
13:10:34 <kmc> Array (Int,Int) Color
13:10:52 <chrisdone> around 5000 I suppose
13:11:05 <kmc> chrisdone, bah
13:11:23 <kmc> i think with the new GHC IO manager we now get to make fun of programs that only support 5000 concurrent connections
13:11:31 <Twey> Heheh
13:11:49 <FunctorSalad> new IO manager?
13:11:50 <xplat> i bet postgresql starts to drag well before 5000 connections with all of them update-heavy unless you've done serious optimizing
13:11:53 <chrisdone> also possible is to make one massive transaction with a load of inserts and apparently that is really fast in psql
13:12:21 <kmc> yup FunctorSalad, it's on bos's blog
13:12:34 <aristid> hmm
13:12:41 <kmc> www.galois.com/~dons/slides/a-scalable-io-manager-for-ghc.pdf
13:12:44 <aristid> random-fu looks like a better base than MonadRandom
13:12:49 <kmc> www.serpentine.com/bos/files/ghc-event-manager.pdf
13:13:16 <chrisdone> nearly done
13:13:30 <bblum> is there a version of foldl that *doesn't* have its arguments flipped? every time i use foldl i find myself "flip"ing the first argument
13:13:53 <aristid> :t foldl . flip
13:13:54 <ddarius> :t foldl' . flip
13:13:54 <lambdabot> forall a b. (b -> a -> a) -> a -> [b] -> a
13:13:54 <lambdabot> forall a b. (b -> a -> a) -> a -> [b] -> a
13:14:09 <kmc> > foldr f z [a,b,c]
13:14:10 <lambdabot>   f a (f b (f c z))
13:14:13 <kmc> > foldl f z [a,b,c]
13:14:14 <lambdabot>   f (f (f z a) b) c
13:14:25 <kmc> the flipped args do make sense in this context
13:14:27 <chrisdone> I think he means the f
13:14:32 <chrisdone> foldl (flip f)
13:14:34 <aristid> bblum: or you can use foldr on the reversed list.
13:14:41 <kmc> but yes, practically speaking it's a thing
13:14:59 <bblum> kmc, so, i'm aware it makes it easier to "visualize" the operation that is happening
13:15:16 <bblum> chrisdone is right
13:15:18 <chrisdone> aw damn, the other three threads finished way earlier than the first thread
13:15:23 <chrisdone> I should've parellized it MORE!!
13:15:27 <kmc> yes
13:15:33 <kmc> one thread for every character of every paste
13:16:31 <gwern> no, give it one thread for each bit
13:16:38 <gwern> that's REAL ULTIMATE PARALLELISM
13:16:45 <Tomsik> make threads to make threads
13:16:48 * gwern loves it with every bit of myself, even my pee-pee
13:17:10 <chrisdone> even your nose-nose?
13:17:20 <gwern> well, that goes without saying
13:17:22 <ddarius> Making threads to make threads is quite useful.
13:17:26 <chrisdone> import: thread blocked indefinitely in an MVar operation
13:17:28 <chrisdone> clever girl
13:17:31 <kmc> sup dog
13:17:39 <gwern> yo dawg
13:17:55 <kmc> right that one
13:17:59 <chrisdone> it knew there were no other threads running and threw that. nice
13:18:13 <chrisdone> concurrenthaskell++
13:18:35 <kmc> chrisdone, i think it's a consequence of the gc computing reachability for the mvar
13:19:50 <Veinor> so... how does one go about writing a decent interface for an authentication-based web service?
13:20:23 <tensorpudding> there's an oauth library isn't there?
13:20:36 <Saizan> sinelaw: it helps because the instance will look like "instance C a => Eq (EqC a) where" and "EqC a" doesn't unify with everything like "a" alone would
13:21:03 <Veinor> tensorpudding: it was more a question of, say, api design
13:21:13 * hackagebot random-extras 0.4 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.4 (AristidBreitkreuz)
13:21:17 <kmc> chrisdone, alternately instead of spawning four threads with four fixed ranges, you could have spawned four workers to read from a chan of [1001..28000]
13:21:19 <aristid> benmachine: i have implemented most of your suggestions in random-extras 0.4 :)
13:21:29 <sinelaw> Saizan, can you translate the contrsaints in that line to words?
13:21:39 <aristid> now i only need to switch from MonadRandom to random-fu oO
13:21:42 <benmachine> awesome
13:21:53 <kmc> assuming order doesn't matter
13:22:43 <chrisdone> kmc: aye
13:22:46 <geheimdienst> login :: User -> Password -> IO Twitter ; data Twitter = { tweet :: ... ; deleteTweet :: ... ; follow :: ... }
13:22:54 <Veinor> makes sense
13:22:56 <geheimdienst> (hope that makes any kind of sense ... :)  )
13:23:04 <chrisdone> kmc: another really simple but awesome solution
13:23:15 <kmc> chans all the way down :)
13:23:25 <kmc> implement your mvars as chans
13:23:28 <kmc> and your chans as mvars
13:23:29 <chrisdone> I was talking to my colleague about using chans to do something, he was all "that's a bit overkill, using channels!"
13:23:43 <chrisdone> in haskell, it's nothing
13:23:53 <sinelaw> Saizan, I mean, what does the "C a =>" part mean in this case? 
13:23:56 <Veinor> where, say, postTweet :: Twitter -> String -> IO () and getTweet :: Twitter -> Integer -> IO String
13:23:58 <sinelaw> what is it constraining 
13:23:59 <Saizan> sinelaw: "EqC a" is an instance of Eq, assuming a is an instance of C
13:24:05 <aristid> chrisdone: would he have said the same if you had said "message queue"?
13:24:25 <kmc> chrisdone, yeah, we get a lot of people here who are like "threads are overkill for my app, so i want to turn my entire control flow inside out and use select()"
13:24:39 <Saizan> sinelaw: where C is your class from the other day that provides enough functionality to write an (==)
13:24:47 <kmc> everyone's always worried about overkill.  seems to me underkill is a much bigger problem.
13:25:05 <chrisdone> kmc: haha, yeah
13:25:12 <Veinor> you need just the right amount of kill
13:25:14 <aristid> Veinor: how about postTweet :: String -> TwitterT IO? :D
13:25:31 <Veinor> aristid: wut
13:25:35 <kmc> i think you should abbreviate that name as TwiT
13:25:40 <sinelaw> Saizan, but don't we need 'a' to be applied to more type arguments there? on the rhs
13:25:41 <chrisdone> uberkill
13:26:35 <Saizan> sinelaw: that depends on the definition of C, i assumed it took a type variable of kind *
13:27:05 <geheimdienst> übërkïłł
13:27:14 <sinelaw> Saizan, you mean "class C where" rather than "class C a where"
13:27:15 <sinelaw> ?
13:27:21 <Saizan> no.
13:27:32 <sinelaw> ah oops 
13:27:32 <sinelaw> :)
13:27:44 <sinelaw> doesn't make much sense
13:27:47 <c_wraith> "class C where" doesn't even make any sense :)
13:27:50 <sinelaw> yeah
13:28:06 <c_wraith> "class C a where" doesn't actually say anything about the kind of a
13:28:13 <ddarius> c_wraith: GHC unfortunately does not allow the nullary case with MultiParamTypeClasses.
13:28:38 <c_wraith> ddarius, what would it even do?  You've defined a class that can't have instances.
13:29:36 <Saizan> sinelaw: i mean that if C a then (a :: *)
13:29:38 <Heffalump> it can have one instance
13:29:41 <Heffalump> or not have that instance
13:29:55 <sinelaw> Saizan, how does ghc determine the kind of a in this case?
13:30:02 <Heffalump> class C where ... ; instance C where ... -- or not
13:30:15 <ddarius> c_wraith: A type class corresponds to (the declaration of) a set of types which is equivalent to a boolean valued function.  The nullary case is thus equivalent to a bool: it is either instanced or not.
13:30:19 * hackagebot resumable-exceptions 0.0.0.20100920 - A monad transformer for resumable exceptions  http://hackage.haskell.org/package/resumable-exceptions-0.0.0.20100920 (NicolasFrisby)
13:30:36 <sinelaw> from the definition of the typeclass' operations?
13:30:41 <sinelaw> the types thereof
13:30:44 <Saizan> sinelaw: from the type signatures of the methods of C, e.g. if a is applied to type parameters it'll infer a kind that's not *
13:30:49 <sinelaw> yeah ok
13:31:05 <luite> hmm, resumable exceptions, sounds like ON ERROR RESUME NEXT
13:31:36 <ddarius> Holy crap, I may even be able to think of uses of such a class.
13:32:34 <Taejo> ddarius: surely it's either True or don't-know-yet, because typeclasses are open
13:32:35 <ddarius> In fact... class Unsafe; unsafePerformIO :: Unsafe => IO a -> a
13:33:07 <vanadium> idgi
13:33:16 <sinelaw> luite, BASIC?
13:33:25 <Taejo> also, will GHC allow classes with no arguments to appear in contexts?
13:33:29 <vanadium> Are you just tagging anything that uses unsafePerformIO with the Unsafe type class?
13:33:42 <geheimdienst> so that's like a marker interface in java? has no methods and compiler don't care, but it tells the programmer something?
13:33:51 <luite> sinelaw: yes, although I'm not sure which flavour
13:33:56 <sinelaw> gw
13:34:23 * geheimdienst thinks "on error resume next" is a visual-basic-ism
13:34:35 <ddarius> vanadium: Yes and you will get a compile error if there is no instance in the final program.
13:34:36 <Taejo> geheimdienst: not really... since the class can only have at most one instance
13:34:41 <c_wraith> well, it's older than visual basic.  but yes, it's from basic
13:34:58 <vanadium> ddarius: I... I am not sure if understanding how that works will make me happier
13:35:16 <magicman> Unsafe typeclass... while neat in theory, you need a way to make it safe again.
13:35:51 <magicman> Otherwise everything that uses unsafePerformIO'd FFI-functions just gets infected for nothing :-/
13:36:10 <geheimdienst> ddarius, you mean, i want to use unsafeSomething in my program, i first need to say "instance Unsafe" ...?
13:36:18 <ddarius> There are quite a few problems with that scheme, though it does roughly basically work.  It nevertheless demonstrates that nullary type classes aren't completely trivial.
13:36:26 <ddarius> geheimdienst: Correct.
13:36:55 <geheimdienst> that sounds like a {-# LANGUAGE: AllowUnsafe #-}
13:37:26 <geheimdienst> maybe some language extensions could also be implemented as those nullary thingies you invented
13:37:47 <Taejo> geheimdienst: besides allowing unsafe selectively, it marks all functions that use unsafe functions
13:38:32 <geheimdienst> taejo, how do you mean using it "selectively"? one module of my program has Unsafe defined, the other hasn't ...?
13:38:52 <ddarius> geheimdienst: Yeah, that won't work because instances are global.
13:38:53 <Taejo> geheimdienst: yes
13:38:59 <Taejo> oops, no
13:39:12 <Taejo> I mean in some programs you can use unsafe ops and in others not
13:39:21 <geheimdienst> okay
13:39:28 <sinelaw> Saizan, what do i need to do if the kind is * -> *? the compiler cries 
13:39:28 <Taejo> it's more than an AllowUnsafe switch
13:39:48 <chrisdone> kmc: so I made a mistake in the import I realised afterwards. rewrote it to have four threads reading from a chan, it's going 100/s :-) actually I'm tempted to pool the connections just to see how much faster that makes it. /me stops 
13:40:00 <sinelaw> Saizan, and suggests turning on flexible instances
13:40:29 <geheimdienst> what would be nice is if Unsafe functions could only be used in functions themselves tagged Unsafe
13:40:50 <ddarius> Perhaps interestingly, with eager context reduction, adding the instance should make Unsafe context disappear.  Whether this is a good thing or a bad thing, I'm not sure.
13:41:01 <ddarius> geheimdienst: That's what would happen.
13:41:36 <ddarius> Or would it ...
13:42:42 <geheimdienst> oh right! i've seen that sometimes ... i said foo :: a -> ... and ghc yelled at me about something could not be deduced from something, then i had to add foo :: (Eq a) => a -> ...
13:43:15 <geheimdienst> question is, does that apply to nullary dudes as well
13:44:24 <ddarius> geheimdienst: It's iffy.  There are cases in GHC where you can have types like Show Int => ..., but GHC can reduce them.
13:44:25 <geheimdienst> btw i move that the hypothetical AllowUnsafe option should rather be named CeilingCatWatching
13:44:34 <sinelaw> when I do: instance C a => Eq (myEq (c a)), ghc says "Illegal instance declaration...All instance type must be of the form....."
13:44:53 <sinelaw> oops, instance C c => ...
13:45:06 <Taejo> masturbate :: CeilingCatWatching => You -> a
13:45:19 <ddarius> However, I think the instance has to be in scope for GHC to perform such reductions.
13:45:30 <geheimdienst> @where lambdacats
13:45:30 <lambdabot> http://tinyurl.com/lambdacats
13:45:35 <geheimdienst> taejo, ^^
13:46:03 <Taejo> yeah, seen it
13:46:41 <ddarius> So, with FlexibleContexts, f :: Num Int => Int; f = 3; g :: a -> a; g x = f `seq` x is not a type error and f :: Int, but with f :: Num (Int -> Int) => ... you do have a type error and f :: Num (Int -> Int) => Int
13:47:01 <ddarius> geheimdienst: So, yeah, it should actually Do The Right Thing as far as that's concerned.
13:48:11 <geheimdienst> you mean, it's a type error because there is no Num instance for (Int -> Int)
13:48:17 <ddarius> geheimdienst: Correct.
13:48:21 <geheimdienst> cool
13:53:33 <jmcarthur> > (+1) + (*2) $ 4
13:53:34 <lambdabot>   13
13:53:41 <jmcarthur> :P
13:55:33 <Saizan> sinelaw: FlexibleInstances is fine
13:56:13 <Saizan> sinelaw: btw, you mean MyEq there, right? i.e. a type constructor, not a variable
13:56:33 <sinelaw> yeah
13:57:08 <sinelaw> Saizan, ok, and what exactly is the problem with using instance C c => Eq (c a) ?
13:58:15 <ddarius> class Modulus where modulus :: Int
13:58:40 <benmachine> sinelaw: would overlap with e.g. [a] or Maybe a or whatever else
13:59:38 <ddarius> class NetworkConfig where port :: Int; ipAddr :: IpAddr
14:00:16 <Saizan> you'd really want scoped instances with those
14:00:39 <chrisdone> excellent, old pastes imported
14:00:44 <chrisdone> now I can delete all the damn spam
14:00:57 <Saizan> chrisdone: with the same url?
14:01:39 <chrisdone> Saizan: I'll setup a redirect in a second, it's the same IDs
14:02:01 <chrisdone> Saizan: got an old paste url?
14:02:37 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9102#a9103
14:03:08 <chrisdone> oki
14:10:54 <aristid> benmachine: the naive algorithm is faster than the single-traversal one even with MWC
14:11:02 <c_wraith> @hoogle comparing
14:11:03 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:11:12 <sinelaw> benmachine, but i'm constraining it to C
14:11:18 <aristid> benmachine: oh wait, that's an invalid conclusion given that i haven't compiled yet :D
14:11:54 <benmachine> sinelaw: but only instance heads count for overlap, since it's possible someone would later declare instance C []
14:12:17 <c_wraith> :t map (fst . head &&& map snd). groupBy ((==) `on` fst) . sortBy (comparing fst) -- sometimes I wonder if I'm doing something wrong.
14:12:18 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, [b])]
14:12:55 <benmachine> weird, hpaste.org/hpaste.png is served as text/plain
14:13:14 <benmachine> or maybe it depends on your headers
14:14:10 <chrisdone> nginx's regex rules make me rage
14:15:23 <Twey> benmachine: WFM
14:15:35 <monoidal> am I understanding correctly: suppose I have a list [x,x]. Then forcing first element performs the computation, and it's preserved for the second element
14:16:00 <monoidal> effectively the second element is forced. now, in [f (), f ()], forcing the whole list does the computation two times?
14:16:04 <benmachine> Twey: what did you do
14:16:12 <chrisdone> okay that'll do for now rewrite ^/fastcgi/hpaste.fcgi/view /paste/$arg_id;
14:16:25 <Botje> monoidal: yes. unless the compiler chose to share the two expressions
14:16:25 <chrisdone> uh \.
14:17:27 <Botje> monoidal: which it won't, at least in current GHCs
14:17:43 <monoidal> Botje: I'd have to write let y = f () in [y,y]?
14:17:47 <Botje> yes
14:23:35 <Twey> benmachine: Just accessed it directly
14:24:33 <benmachine> oh ok
14:24:58 <benmachine> never mind then I guess
14:25:57 <IceDane> http://haskell.org/sitewiki/images/a/aa/Screen-triplehead-galois.jpg
14:25:59 <nominolo> preflex: seen tibbe
14:26:00 <preflex>  tibbe was last seen on #haskell 1 hour, 41 minutes and 14 seconds ago, saying: nominolo: there?
14:26:02 <IceDane> what a retardedly awesome setup.
14:26:04 <IceDane> What a fucking dream.
14:30:32 <aristid> *waiting for hackagebot announcement*
14:30:45 * hackagebot random-extras 0.10 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.10 (AristidBreitkreuz)
14:30:47 * hackagebot vector-algorithms 0.3.3 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.3.3 (DanDoel)
14:30:48 <sinelaw> heh
14:31:01 <benmachine> 0.10 :O
14:31:03 <aristid> IceDane: wtf is that keyboard?
14:31:15 <benmachine> that moved fast
14:31:18 <aristid> benmachine: yes, it jumped because it went from MonadRandom to random-fu
14:31:19 <Jon> hi folks. I'm writing a program using two libraries, HFuse (which uses Data.ByteString.Char8) and GZip (which use Data.ByteString.Lazy). I need to mix and match. How can I convert between the two?
14:31:21 <IceDane> aristid: Ergonomical
14:31:25 <IceDane> that's not mine, though, fyi
14:31:42 <IceDane> Btw -- does anyone here use xmonad?
14:32:00 <aristid> IceDane: it seems to be missing keys
14:32:44 <Philonous> IceDane: You may want to try #xmonad
14:32:45 <zenzike> IceDane: I do
14:33:55 <aristid> *head vs table*
14:34:05 <aristid> benmachine: i forgot to rename the module :)
14:34:07 <IceDane> win 4
14:34:10 <IceDane> eh, sorry.
14:34:13 <benmachine> hah
14:34:17 <c_wraith> Jon: look at the functions toChunks and fromChunks in Data.ByteString.Lazy
14:36:43 <Jon> c_wraith: thanks
14:37:51 <useoftoaster> gaahh!!! Anyone know why 'cabal install' would rebuild all of my package's dependencies on every run?
14:38:46 <Saizan> look at the output of --dry-run -v
14:39:25 <Saizan> anyhow the most common source of confusion for cabal is when you have the same version of some package in both the global and used package dbs
14:39:46 <Saizan> which in turn is likely caused by the upgrade of one of the packages that ship with ghc
14:40:31 <useoftoaster> ok, i'll check ghc-pkg...
14:40:35 <useoftoaster> thanks
14:40:59 <hellidunno> hey guys, how do you maintain haskell code of other people?
14:41:05 <hellidunno> Isn't it incredible hard to read?
14:41:31 <centrinia> It depends on the person.
14:41:31 <Saizan> no, i've always found haskell code to be much easier to follow
14:41:33 <zachk> abstraction, comments, idioms, and ghci i would imagine 
14:41:35 <moosefish> hellidunno: Not any more than perl or c++ code I've seen "professionals" write.
14:41:44 <medfly> moosefish, :-D
14:41:52 * zachk couldnt read his own commented perl code most of the time 
14:42:25 <moosefish> I'm just going through the thrift bindings and c++ libraries right now, and I have to give you an unqualified: no, not at _all_.
14:42:31 <moosefish> :P
14:42:47 <hellidunno> is there a simple 2D graphics library fpr the new ghc version?
14:42:55 <hellidunno> sdl doesn't work properly
14:42:59 <hellidunno> without hax
14:43:41 <dschoepe> hellidunno: If you don't really care about efficiency: http://hackage.haskell.org/package/HGL
14:43:50 * hackagebot random-extras 0.11 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.11 (AristidBreitkreuz)
14:44:31 <Saizan> soegtk?
14:44:46 <hellidunno> ty
14:46:52 <Jon> c_wraith: yup, thanks, that works :)
14:47:00 <c_wraith> Jon: you're welcome
14:51:55 <RyanT5000> when a thread dies because it's waiting on the only reference to an empty channel, do 'bracket' cleanup routines get run?
14:52:45 <Saizan> i'd think so
14:53:09 <kevinburke> what's the site to use for pasting code snippets?
14:53:11 <RyanT5000> Saizan: i'd also think so, i'm just not sure
14:53:23 <RyanT5000> i guess i'll just have to test it
14:53:30 <aristid> @where hpaste
14:53:30 <lambdabot> http://hpaste.org/
14:53:35 <aristid> ^ kevinburke
14:55:27 <kevinburke> getting this error message 500 Internal Server Error
14:55:27 <kevinburke> DBError ("23","505") 7 "ERROR:  23505: duplicate key value violates unique constraint \"paste_pkey\"\nLOCATION:  _bt_check_unique, nbtinsert.c:298\n"
14:55:41 <kevinburke> i pasted line numberstoo
14:55:44 <kevinburke> and it doesn't compile
14:59:06 <kevinburke> http://pastebin.com/Cs3Ysnrq
14:59:58 <kevinburke> getting a  Could not deduce (Num int) from the context () error on the 2nd line
15:00:14 <mauke> you misspelt Int
15:00:23 <kevinburke> a Could not deduce (Eq a) error on the fourth line
15:00:47 <mauke> yes
15:01:11 <mauke> :t find
15:01:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:01:17 <mauke> :t findIndex
15:01:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
15:01:18 <kevinburke>  oh fail
15:01:36 <mauke> @index find
15:01:36 <lambdabot> Data.List
15:01:47 <kevinburke> sorry i'm trying to write a new function for homework
15:01:51 <mauke> is there any particular reason you're passing your arguments as tuples?
15:02:18 <mauke> anyway, you need to add an (Eq a) constraint to your type signature
15:02:26 <mauke> otherwise == won't be available
15:02:59 <kevinburke> i'd want  findhelp :: (a, [a]) -> Int -> Int to be instead  findhelp :: ((Eq a), [(Eq a)]) -> Int -> Int ?
15:03:45 <benmachine> no
15:04:01 <benmachine> :t lookup
15:04:02 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:04:17 <benmachine> this is not the signature you want but it's useful
15:04:27 <benmachine> do you understand the => and the bit before it?
15:04:40 <mauke> kevinburke: findhelp :: (Eq a) => a -> [a] -> Int -> Int
15:04:42 <mauke> or something
15:04:44 <kevinburke> EQ a is the class
15:05:07 <benmachine> right
15:05:13 <benmachine> classes appear to the left of =>
15:09:52 <kevinburke> ok got it, thanks
15:10:47 <kevinburke> is there any way you could do it without specifying the (Eq a) class? in other words without testing for equality between the query and the list
15:11:41 <kevinburke> i'm not fishing for an answer to my hw, just curious...
15:11:55 <benmachine> kevinburke: what is the specification for the function exactly?
15:12:28 <kevinburke> Write a function find that takes a pair of an element and a list and returns the location of the first occurence of the element in the list, returns -1 if not found
15:12:40 <kevinburke> so find(3, [1,2,3,4]) returns 2
15:12:47 <benmachine> right
15:12:51 <benmachine> if you have things which can't be equal
15:13:09 <benmachine> then...
15:13:17 <benmachine> it doesn't really make sense for the element to occur in the list
15:13:21 <kevinburke> Ok
15:13:26 <kevinburke> Thats what i was thinking
15:15:15 <dafis> kevinburke: There is a way without specifying the Eq constraint: leave out the type signatures - then the compiler/interpreter infers the type
15:15:26 <Cale> Well, it makes sense, but it might not be computable.
15:15:47 <kevinburke> Ok. I figure its good practice though to do the type signatures
15:16:10 <dafis> kevinburke: yes, leaving them out is bad
15:16:19 <dafis> well, not *really* bad
15:16:27 <kevinburke> Im finding that the hard part is always getting the type signatures right though
15:16:36 <dafis> but it's better to give type signatures
15:16:37 <kevinburke> and once you get it to compile you nearly always have the correct program
15:16:56 <kevinburke> but i haven't really tried difficult problems
15:17:01 <Cale> If you design your types carefully, this is often the case
15:18:17 <chrisdon`> encoding invariants at compile type, with an exhaustive type proving system, instead of runtime with a flawed single human
15:26:43 <ddarius> chrisdon`: Stop using flawed humans.
15:26:52 <chrisdon`> ddarius: but they're so cheap!
15:27:01 <tommd> ddarius: Do you have a source of non-flawed humans I could use?
15:27:15 <chrisdon`> oh my god amarok2 is hideous
15:27:22 * chrisdon` recoils in genuine horror
15:28:20 <smorg> chrisdon`: Know what's cool about non-amarok music players? Sound comes out of them.
15:28:44 <chrisdon`> uh, ok
15:28:51 <megajosh2> smorg: Whaaaaaaaaaaat?
15:29:20 <smorg> (more specifically, those which don't use phonon and cause all sorts of alsa conflicts)
15:29:33 <megajosh2> @hoogle unsafePerformIO
15:29:33 <lambdabot> Foreign unsafePerformIO :: IO a -> a
15:29:33 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
15:29:52 <megajosh2> Need to do a little testing in GHCi... it's such a pain without unsafePerformIO
15:30:10 <tommd> Really?  I don't think I've ever used unsafePerformIO in GHCi.
15:30:23 <megajosh2> I want to use a socket fd
15:30:25 <kyagrd> megajosh2: what are you doing?
15:30:26 <ddarius> megajosh2: Do you know that you can write: x <- readFile "foo" and such at the GHCi command line?
15:30:27 <smorg> use python :)
15:30:49 <kyagrd> GHCi session is like a monadic do body
15:30:57 <megajosh2> Hmm..
15:31:06 <kyagrd> So, don't think you'd need unsafePerformIO just to do IO
15:31:25 <glguy> even if it wasn't you could still do all the IO on one line
15:31:50 <megajosh2> I just wanted to put a socket fd in a function to refer to it later
15:32:15 <smorg> not quite "read, eval, print" in the lisp sense.
15:32:42 <kyagrd> smorg: it is when you stick to pure expressions
15:32:42 <Saizan> s <- openSocketWhatever ..
15:33:37 <megajosh2> Ah, there we go
15:33:43 <IceDane> Some of you guys did some nifty stuff that looked something like this: all $ map ($ ch) [isAscii, isBlah, isFoo] yesteryday.. I happen to need exactly that now, but I can't remember what it looked like
15:33:51 <megajosh2> Didn't know you could use do block-ish syntax in GHCi
15:33:52 <IceDane> anyone have an idea what I'm talking about?
15:34:17 <kyagrd> megajosh2: GHCi session is like a IO do block body you can even use let :)
15:34:23 <mauke> :t all
15:34:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:34:25 <ddarius> IceDane: Just get rid of the $ map
15:35:02 <IceDane> ddarius: I know I can just do (I need any): any (== True) $ map ($ ch) [isFoo, isBar]etc
15:35:17 <mauke> == True is pointless
15:35:18 <IceDane> But I seem to recall that they didn't have to pass the condition because they did something really nifty
15:35:40 <mauke> any ($ ch) [isFoo
15:35:47 <IceDane> OH
15:35:53 <IceDane> that's what they did
15:36:01 <IceDane> thanks!
15:36:04 <Saizan> ?src any
15:36:04 <lambdabot> any p =  or . map p
15:36:05 <ddarius> As I said, just get rid of the $ map
15:36:06 <mauke> removing the $ map part
15:36:06 <Saizan> ?src all
15:36:07 <lambdabot> all p =  and . map p
15:36:30 <ddarius> Thus any id = or . map id = or and (== True) = id
15:36:57 <mauke> too much or or and
15:37:03 <chrisdon`> mauke: it's funny how often you see the == true everywhere
15:37:07 <ddarius> Alternatively, all ($ c) [f, g, h] === and (sequence [f, g, h] c)
15:37:49 <IceDane> This is exactly why I know I'm a newbie. There are things you can do in Haskell that are obvious once you see them done, but I'll never come up with them on my own
15:38:08 * hackagebot CSPM-cspm 0.4.0.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.4.0.0 (MarcFontaine)
15:38:19 <chrisdon`> after writing one or two projects it comes naturally
15:39:00 <IceDane> Aye -- it doesn't help that I keep doing haskell in spurts. Do it a lot for a while, then stop, maybe go back to C++ for whatever I'm doing, then return to haskell and and have become rusty
15:39:29 <chrisdon`> ah, C++ is like water
15:39:47 <ddarius> It expands when it is frozen?
15:40:29 <IceDane> It runs and runs and runs.. ?
15:40:31 <IceDane> I have no idea
15:40:33 <IceDane> Do elaborate
15:40:35 <chrisdon`> one fun thing about Haskell is when you're working late the lateness is proportional to the number of compiler errors that start appearing. in other languages you just start getting weird behaviour, or think everything works
15:40:43 <IceDane> Haha
15:40:53 <mauke> preflex: quote . c++
15:41:02 <preflex>  no quotes found
15:41:10 <mauke> preflex: quote . C++
15:41:12 <preflex>  <mauke> C++ is very efficient in that a single typo can cause several KB of errors
15:41:17 <mauke> gee
15:41:23 <IceDane> I can positively say that I am a haskell fanboy, even though I am rather new at it
15:41:39 <IceDane> I try to pitch it to everyone that is wondering what programming language to explore next
15:41:52 <chrisdon`> ^_^
15:41:56 <megajosh2> gigajosh2: Wooh!
15:43:42 <mauke> preflex: quote . C++
15:43:44 <preflex>  <kmc> i think "do the opposite of C++" is a decent design guideline
15:43:44 <IceDane> Hmm -- is this possible with some flip magic without using lambdas? Just out of curiosity: all (\ch -> ($ ch) [isFoo, isBar]) "string"
15:43:57 <mauke> @pl all (\ch -> ($ ch) [isFoo, isBar]) "string"
15:43:57 <lambdabot> all [isFoo, isBar] "string"
15:44:25 <IceDane> wat.
15:44:37 <mauke> don't blame me, it's your code
15:45:12 <monoidal> @pl \ch -> ($ ch)
15:45:12 <lambdabot> flip id
15:45:14 <ddarius> You (IceDane) didn't close parenthesis correctly.
15:45:21 <IceDane> ah.
15:45:27 <IceDane> oh
15:45:31 <IceDane> I also wrote wrong code, sec
15:45:58 <IceDane> all (\ch -> any ($ ch) [isAlpha, isDigit]) "1234string"
15:46:32 <IceDane> E.g. making sure that all characters in the string are either alpha or digits
15:46:43 <IceDane> Is that possible to do with some flip magic?
15:46:45 <IceDane> without the lambda
15:46:54 <monoidal> @pl all (\ch -> any ($ ch) [isAlpha, isDigit]) "1234string"
15:46:54 <lambdabot> all (flip any [isAlpha, isDigit] . flip id) "1234string"
15:47:06 <monoidal> ugly, I'm sure can be done better
15:47:18 <IceDane> I *really* don't understand flip id
15:47:20 <IceDane> I'll have to google it
15:47:25 <monoidal> @type id
15:47:26 <lambdabot> forall a. a -> a
15:47:30 <monoidal> @type flip id
15:47:31 <lambdabot> forall a b. a -> (a -> b) -> b
15:47:31 <mauke> IceDane: you can't google understanding
15:47:40 <megajosh2> @google understanding
15:47:40 <ddarius> @google understanding
15:47:40 <lambdabot> http://en.wikipedia.org/wiki/Understanding
15:47:40 <lambdabot> Title: Understanding - Wikipedia, the free encyclopedia
15:47:41 <lambdabot> http://en.wikipedia.org/wiki/Understanding
15:47:41 <lambdabot> Title: Understanding - Wikipedia, the free encyclopedia
15:47:45 <mauke> IceDane: step 1 is understanding why ($) = id
15:47:47 <megajosh2> Well, it isn't very effective
15:47:54 <IceDane> Hmm
15:48:12 <IceDane> mauke: I meant google flip, google id and, you know, grok stuff
15:48:17 <IceDane> Like, try *really* hard and stuff.
15:48:23 <monoidal> IceDane: first step is all (\ch -> flip any [isAlpha, isDigit] ($ ch))
15:48:40 <mauke> @src id
15:48:41 <lambdabot> id x = x
15:48:43 <mauke> @src flip
15:48:43 <lambdabot> flip f x y = f y x
15:48:46 <mauke> :-)
15:48:55 <IceDane> @src ($)
15:48:55 <lambdabot> f $ x = f x
15:49:02 <monoidal> IceDane: second step is all (\ch -> (flip any [IsAlpha, isDigit]) . (\ch -> ($ ch))
15:49:23 <monoidal> IceDane: third step is to simplify \ch -> ($ ch) to flip id, and this is lambdabot's version
15:49:34 <IceDane> I see
15:49:54 <IceDane> So, ($) is really id but because you apply it, it forces the order of evaluation? or something like that
15:49:57 <mauke> well, \ch -> ($ ch) ==> \ch -> flip ($) ch ==> flip ($) ==> flip id
15:50:03 <IceDane> (as opposed to when you don't apply it)
15:50:12 <dibblego> @type (<?>)
15:50:13 <lambdabot> Not in scope: `<?>'
15:50:14 <monoidal> IceDane: it is id restricted to functions. (a -> b) -> a -> b
15:50:21 <ddarius> @hoogle (a -> b) -> (b -> a) -> (b -> b) -> a -> a
15:50:22 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
15:50:22 <lambdabot> Control.Parallel.Strategies (.||) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
15:50:22 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
15:50:30 <aristid> @hoogle iterateM
15:50:30 <lambdabot> No results found
15:50:31 <monoidal> IceDane: you can read that two ways - first, you get a function and then it gives you the same function back
15:50:40 <dibblego> what is the purpose of Text.ParserCombinators.Parsec.(<?>) :: GenParser tok st a -> String -> GenParser tok st a ?
15:50:41 <IceDane> monoidal: Yeah
15:50:43 <monoidal> IceDane: second, you give a function and an argument, and it gives you result
15:50:52 <ddarius> Haskell needs the under functional, or just a library of isomorphisms and utility functions on them.
15:50:53 <monoidal> IceDane: so ($) is special case of id
15:51:04 <mauke> IceDane: ($) f x = f x;  ($) f = \x -> f x;  ($) f = f
15:51:13 <ddarius> dibblego: It "names" a parser for error messages.
15:51:20 <dibblego> oh right thanks
15:51:21 <mauke> ($) = id
15:51:35 <IceDane> I do understand now
15:51:47 <ddarius> dibblego: Also you placed the parenthesis incorrectly.
15:52:06 <monoidal> IceDane: since flip is only for functions, flip id == flip ($), since id for functions is ($)
15:52:20 <IceDane> monoidal: Aah
15:52:21 <dibblego> yes I did cheers
15:52:35 <monoidal> IceDane: id has more general type than ($), but flip id has the same type as flip ($)
15:52:41 <ddarius> Actually, id and ($) are observably different...
15:53:30 <benmachine> ddarius: oh yes?
15:53:58 <Philonous> mauke: If ($) = id then those should be exchangeable in all contexts, shouldn't they? But show (id (5 ::Int)) /= show (($) (5 :: Int)), in fact, the latter doesn't even type check.
15:54:04 <ddarius> id is strict, ($) is not.
15:54:23 <mauke> Philonous: ($) has a more restrictive type signature
15:55:23 <arw> $ is a function? isn't it only a fancy syntax for ()?
15:55:32 <mauke> arw: no
15:55:56 <useoftoaster> arw: yes, it's a function. no, it's not only a fancy syntax.
15:56:17 <IceDane> arw: The cool thing about haskell that I've come to discover is that stuff usually isn't built-in magic
15:56:20 <ddarius> If you were going to build syntax into the compiler for that, you could do a much nicer job than ($).
15:56:22 <aristid> i want something like this: x <=< x <=< x
15:56:24 <benmachine> ddarius: as in, ($) undefined = const undefined, rather than undefined?
15:56:31 <aristid> but with a configurable number of x :)
15:56:34 * benmachine plays with this
15:56:34 <ddarius> benmachine: Yes
15:56:40 <monoidal> > seq (($) undefined) ()
15:56:41 <lambdabot>   ()
15:56:46 <monoidal> > seq (id undefined) ()
15:56:47 <lambdabot>   *Exception: Prelude.undefined
15:56:57 <benmachine> oh hey
15:57:05 <benmachine> > (undefined `id`) `seq` ()
15:57:06 <lambdabot>   *Exception: Prelude.undefined
15:57:18 * benmachine thinks that's an infelicity on the part of GHC
15:57:24 <benmachine> possibly a documented one though, I forget
15:57:25 <ddarius> benmachine: Nope.
15:57:28 <monoidal> it's the same difference as between f and \x -> f x
15:57:32 <benmachine> ddarius: aren't sections supposed to be lambdas?
15:58:18 <ddarius> Nevermind, you are correct.
15:58:52 <ddarius> However, lambdabot does have PostfixOperators (or whatever it was) enabled, I'm pretty sure.
15:59:06 <megajosh2> @src hPrintf
15:59:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:59:08 <benmachine> ddarius: my ghci does the same, though
15:59:08 <ddarius> > let (!) n = n in (3 !)
15:59:09 <lambdabot>   3
15:59:23 <benmachine> I think there was a note in the GHC users' guide
15:59:31 <benmachine> it's not like anyone actually cares, after all >_>
16:00:14 <megajosh2> @hoogle recv
16:00:14 <lambdabot> Network.Socket recv :: Socket -> Int -> IO String
16:00:14 <lambdabot> Network.Socket recvAncillary :: Socket -> Int -> Int -> IO (Int, Int, Ptr a, Int)
16:00:14 <lambdabot> Network.Socket RecvBuffer :: SocketOption
16:00:34 <ddarius> benmachine: It matters.
16:01:16 <benmachine> ddarius: given that everywhere there's a section you can easily use either a lambda or prefix to explicitly get the behaviour you need, I'm not terribly convinced
16:01:18 <aristid> @hoogle Int -> (a -> m a) -> (a -> m a)
16:01:18 <lambdabot> No results found
16:03:40 <monoidal> aristid: something like (foldr (>=>) return .) . replicate?
16:03:47 <monoidal> *aristid
16:04:24 <ddarius> benmachine: That would be fine if everyone considered the ramifications of using a section for every use.
16:04:31 <byorgey> @type (foldr (<=<) return .) . replicate
16:04:32 <lambdabot> forall (m :: * -> *) c. (Monad m) => Int -> (c -> m c) -> c -> m c
16:05:18 <byorgey> I guess that's the same as the version with (>=>), because of the monad laws
16:05:41 <monoidal> it's the same: a >=> a >=> ... >=> a == a <=< a <=< ... <=< a
16:05:59 <byorgey> monoidal: right, those are the same because >=> is associative
16:06:05 <byorgey> which is one of the monad laws
16:06:10 <monoidal> yes
16:06:55 <byorgey> one might be more efficient than the other, though, I'm not sure
16:07:28 <monoidal> @hoogle Int -> (a -> a) -> a -> a
16:07:28 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
16:07:28 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
16:07:28 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
16:08:42 <byorgey> maybe we ought to have  Monoid m => Int -> m -> m
16:09:01 <byorgey> = (mconcat .) . replicate
16:09:12 <monoidal> could be done in O(log n) for some monoids
16:09:14 <ddarius> Nah, you generalize (^) to monoids.
16:09:25 <byorgey> ddarius: ah, right
16:10:04 <byorgey> monoidal: really? like what?
16:10:11 <monoidal> byorgey: binary exponentiation
16:10:22 <ddarius> byorgey: Like numbers...
16:10:28 <byorgey> oh, indeed. =)
16:10:34 <byorgey> doesn't that apply to all monoids though?
16:10:46 <ddarius> Yes.
16:11:09 <ddarius> Presumably we could generalize (^^) to groups.
16:11:45 <byorgey> right. and (**) to... ?
16:14:21 <monoidal> I don't think there's any good generalization - reals, symbolic reals, floating points
16:14:38 <monoidal> other structures rarely have "internal" exponentation
16:15:11 <ddarius> monoidal: There are quite a few things with a good notion of exp.
16:15:21 <ddarius> Matrices for example.
16:15:25 <monoidal> or power series
16:17:27 <monoidal> or, exponential-logarithmic functions
16:18:09 <vanadium> or roleplaying games
16:18:17 <monoidal> it seems the generalization works for http://en.wikipedia.org/wiki/Exponential_field
16:20:12 <ddarius> A field is way too strong.
16:21:32 <ddarius> On a probably unrelated note, what do you call a thing that's like a Banach space but over a module rather than a linear space?
16:22:05 * ddarius probably needs to (re)look at some of the stuff he has on non-commutative geometry.
16:32:31 <mm_freak> something wrong with haskell.org?
16:32:41 <mm_freak> i'm unable to connect
16:33:42 <hellidunno> works for me
16:34:31 <mm_freak> ah, it's back
16:34:44 <hellidunno> k k
16:40:20 <dibblego> is Text.ParserCombinators.Parsec.Combinator.count equal to replicateM?
16:44:43 <ddarius> @hoogle count
16:44:43 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
16:44:43 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
16:44:44 <lambdabot> Data.ByteString.Lazy count :: Word8 -> ByteString -> Int64
16:44:52 <ddarius> @hoogle Text.Parsec.count
16:44:52 <lambdabot> Text.Parsec.Combinator count :: Stream s m t => Int -> ParsecT s u m a -> ParsecT s u m [a]
16:46:07 <ddarius> > replicateM (-4) (return 3)
16:46:07 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
16:46:07 <lambdabot>    arising from a use of `M40873662...
16:46:18 <ddarius> > replicateM (-4) (return 3) :: Maybe Int
16:46:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:46:19 <lambdabot>         against inferred type ...
16:46:32 <ddarius> :t replicateM
16:46:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
16:46:37 <monochrom> I think they do the same thing.
16:46:45 <ddarius> Yeah.  
16:47:15 <monochrom> replicateM probably didn't exist back then
16:47:15 <ddarius> The source is essentially sequence . replicate n which is the definition of replicateM.
16:47:21 <ddarius> It definitely didn't.
16:47:43 <monochrom> parsec is older than me
16:49:16 <tommd> monochrom: So is my burrito, but it doesn't really matter.
16:51:50 <megajosh2> @hoogle hPrintF
16:51:50 <lambdabot> Text.Printf hPrintf :: HPrintfType r => Handle -> String -> r
16:51:50 <lambdabot> Text.Printf class HPrintfType t
16:55:42 <megajosh2> @pl (\n -> doSomething n >>= (flip hPrintf) "")
16:55:42 <lambdabot> (flip hPrintf [] =<<) . doSomething
16:55:54 <megajosh2> @pl (\n -> doSomething n >>= (flip hPrintf) " ")
16:55:54 <lambdabot> (flip hPrintf " " =<<) . doSomething
16:56:05 <megajosh2> Hmm...
17:14:05 <benmachine> megajosh2: considered (>=>)?
17:14:18 <benmachine> @ty (>=>)
17:14:19 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:14:29 <megajosh2> benmachine: I don't need to bind anything anymore in that expression
17:14:36 <megajosh2> I misread something...
17:14:42 <benmachine> oh ok
17:45:44 <ManateeLazyCat> I'm looking for temrinal widget with model/view split design, silimar TextBuffer
17:45:44 <ManateeLazyCat> for TextView, i can keep terminal data even terminal widget destroy. Have any exist
17:45:44 <ManateeLazyCat> terminal library do this? 
17:58:34 * hackagebot copilot 0.21 - A lazy-list language for generating constant-time and constant-space C programs. Uses Atom as a backend.  http://hackage.haskell.org/package/copilot-0.21 (LeePike)
18:00:24 <por> Given a recursive data type, e.g., W a = V a | U (W a) (W a), shouldn't I be able to define a fold with functions of type v -> a, v -> v -> a? declaring a Foldable instance seems to permit only one function, f, in the definition of fold.
18:00:56 <Cale> por: Yes, Foldable should probably be called Listable
18:01:12 <Cale> por: Since it doesn't really have much to do with proper folds.
18:01:41 <Cale> (only with the folds on common representations of sequences)
18:02:15 <por> I like the name Listable. But that's good, because I was afraid I wasn't understanding something important.
18:02:36 * hackagebot contstuff 0.2.2 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.2.2 (ErtugrulSoeylemez)
18:03:42 <monoidal> is Foldable f simply a natural transformation f -> []?
18:03:43 <aristid> mm_freak: what did you change?
18:03:55 <aristid> hmm, does cabal support a changelog or something like that?
18:03:56 <mm_freak> aristid: fixed a bug in the Alternative instance for ContT
18:04:49 <mm_freak> since 0.2.0 there is also ChoiceT, but i'm not sure it's a proper monad transformer yet
18:05:00 <mm_freak> it's implemented as a CPS-based left fold function
18:05:41 <Cale> monoidal: More or less.
18:05:46 <mm_freak> aristid: i'm writing a contstuff tutorial on haskellwiki
18:05:51 <mm_freak> http://haskell.org/haskellwiki/Contstuff
18:06:00 <mm_freak> but it's not finished yet
18:06:08 <aristid> man, i have like 20 open haskell tabs
18:06:11 <Cale> monoidal: It allows for more efficient implementations of a bunch of list functions too, but axiomatically, it's equivalent to that.
18:07:38 <monoidal> Cale: are all nonpathological Foldables functors?
18:07:51 <mm_freak> aristid: btw, i also added labelCC and goto (inspired by monadLib)
18:07:54 <codolio> @type fmapDefault
18:07:55 <lambdabot> Not in scope: `fmapDefault'
18:08:07 <codolio> @hoogle fmapDefault
18:08:07 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
18:08:32 <aristid> goto :: Applicative m => Label m a -> a -> m b
18:08:32 <aristid> goto lk@(Label k) x = k x lk *> pure undefined
18:08:38 * hackagebot copilot 0.22 - A stream DSL for writing embedded C.  http://hackage.haskell.org/package/copilot-0.22 (LeePike)
18:08:38 <aristid> mm_freak: this is a crazy function
18:08:38 <benmachine> wow, haskell-cafe went on a lot about taking the last n elements of a list
18:08:45 <aristid> :t (*>)
18:08:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
18:08:49 <Cale> monoidal: Basically, yes.
18:09:01 <monoidal> thanks. So, it's equivalent
18:09:09 <mm_freak> aristid: (*>) is just a more general (>>)
18:09:16 <monoidal> Maybe there should be a class Natural f g where h :: f x -> g x
18:09:23 <benmachine> monoidal: Set is foldable, but not a functor
18:09:36 <benmachine> I *think* you could make something like ByteString a foldable
18:09:41 <mm_freak> goto never returns, so its result is undefined
18:09:50 <mm_freak> hence (*> undefined)
18:10:00 <Cale> monoidal: I don't think there's generically a way to implement fmap given Foldable, but any sane instance of Foldable would have one.
18:10:16 <monoidal> benmachine: I think Set's fold breaks set abstraction (requires commutative monoid)
18:10:27 <Cale> monoidal: The gofer prelude at one time had that
18:10:33 <mm_freak> aristid: http://haskell.org/haskellwiki/Contstuff#Resumption_and_branches
18:10:34 <aristid> mm_freak: ok, but why the equivalent of (>> return undefined)?
18:10:49 <mm_freak> because (*>) and 'pure' are more general
18:10:53 <benmachine> monoidal: only as much as Set.toList does, I think
18:11:01 <aristid> mm_freak: the type of goto should just be m ()
18:11:02 <monoidal> agreed
18:11:12 <ddarius> monoidal: Why would you have a "Natural" class?
18:11:27 <aristid> mm_freak: no i know the rationale for Applicative, i don't know the rationale for (*> pure undefined)
18:11:48 <mm_freak> aristid: because there is no reason to restrict it to ()
18:11:52 <aristid> goto lk@(Label k) x = k x lk
18:11:56 <Saizan> mm_freak: what's the definition of Label?
18:11:57 <aristid> that would be a lot simpler.
18:12:01 <benmachine> monoidal: that is to say, the Set abstraction isn't really broken because it just decides to fold in ascending order
18:12:08 <aristid> newtype Label m a = Label (a -> Label m a -> m ())
18:12:22 <mm_freak> Saizan: newtype Label m a = Label (a -> Label m a -> m ())
18:12:24 <Saizan> then we're not guarenteed that k won't return
18:12:25 <benmachine> it could do that regardless of how it "really works"
18:12:33 <monoidal> ddarius: I don't see any use except simplification. Foldable is Nat x [], Pointed is Nat Id x
18:12:48 <aristid> mm_freak: and it would be EVEN MORE GENERAL, because now, goto would not even have the Applicative constraint :>
18:12:51 <Saizan> that might be true for the labels you construct with your methods
18:13:06 <dmwit> So, it looks like tagsoup and variants are the only things on Hackage for parsing HTML?
18:13:11 <Saizan> but not in general, if you expose the Label constructor
18:13:14 <mm_freak> Saizan: hmm, indeed
18:13:21 <dmwit> (tagsoup, tagsoup-parsec, and tagchup?)
18:13:24 <Cale> hmm, perhaps I'm remembering incorrectly...
18:13:35 <Saizan> mm_freak: "newtype Label m a = Label (forall r. a -> Label m a -> m r)" would be ideal
18:13:56 <Saizan> mm_freak: if you want to enforce that k shouldn't return
18:14:06 <mm_freak> Saizan: i'm not sure i want that
18:14:26 <ddarius> monoidal: There are a lot of natural transformations from any one of most of the common functors to lists, for example, const [].  Foldable isn't just any natural transformation.
18:14:50 <mm_freak> Saizan: one point of writing this library is to expose much more than other libraries
18:15:13 <Cale> Heh, it's supposed to be the *natural* natural transformation ;)
18:16:48 <monoidal> ddarius: isn't const [] is a good implementation of Foldable? (good=satisfying laws)
18:17:10 <Saizan> mm_freak: in either case *> pure undefined should go, either because you don't know if it's safe or because it's useless :)
18:17:56 <mm_freak> Saizan: good point
18:18:03 <mm_freak> it'll be gone in the next release =)
18:18:10 <ddarius> monoidal: Probably, but it's probably not the one you want.  Whereas there is no criterion in your "Natural" class at all to choose the -distinguished- natural transformation that gets to instantiate the class.
18:19:34 * Saizan has been proving too many lemmas with types like Either A B -> .. lately
18:19:52 <Cale> But to some extent, Foldable doesn't really tell us either. It just suggests it a bit more strongly.
18:20:22 <ddarius> Saizan: Change it up into (A -> ...) /\ (B -> ...) (with the ...'s being the same in each subformula.
18:20:38 <sshc> Where is ErrorT defined an instance of MonadPlus?
18:20:51 <ddarius> Cale: Agreed, because Foldable has no way other than toList to get or state anything about the supplied functor.
18:20:58 <sshc> http://hackage.haskell.org/packages/archive/monads-tf/latest/doc/html/Control-Monad-Error.html#v:ErrorT doesn't have a source link in the instances area
18:21:49 <Saizan> ddarius: i need less code if i keep it bundled up, the two cases are pretty symmetrical
18:23:17 <ddarius> Cale: We can still put some constraints on Foldable's intended behavior for large classes of functors though.
18:24:09 <ddarius> Saizan: That's typically the case as is fairly evident by my formula.
18:24:11 <Saizan> sshc: in the transformers package, probably, since monads-tf depends on it
18:24:53 <monoidal> sshc: it is imported at the beginning: import Control.Monad.Trans.Error (ErrorT(..), mapErrorT)
18:25:46 <Saizan> anyhow i guess you meant i could change the type just for the sake of diversity :)
18:26:13 <monoidal> sshc: http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Error.html#ErrorT
18:26:22 <jmcarthur> copilot looks cool
18:26:37 <moosefish> I'm writing a fairly large parser with Parsec where sometimes right in the middle of a file there can be a huge chunk of a data (gigabytes is not unheard of). Think like SQL "VALUES (...)" or a string constant that ends up being a CSV file. The inner format is dumb and easy to parse (think line-based). Is there any way I can dump that to a side file without resorting to unsafePerformIO inside my outer parser?
18:27:16 <moosefish> (so my outer parser would see the enormous constant as a reference to a file, and not its content)
18:28:38 <ddarius> moosefish: If you are using Parsec 3, you can just use ParsecT over IO.
18:29:05 <moosefish> how can I tell?
18:29:06 <Cale> Does anyone else find it strange that almost every programming contest problem ever has an input format with at least one redundant number in it? (usually at least the number of testcases is put at the beginning)
18:29:09 <sshc> Sorry, I meant MmonadState
18:29:17 <sshc> @src ErrorT local
18:29:17 <lambdabot> local f m = ErrorT $ local f (runErrorT m)
18:29:23 <sshc> That's what I was looking for
18:29:31 <sshc> Where could I find it outside lambdabot?
18:29:57 <aristid> Cale: that probably just shows that the organizers have a specific solution in mind when devising the problem
18:30:03 <etpace>     http://donsbot.wordpress.com/2010/08/17/practical-haskell/
18:30:12 <etpace> am i being blind? I cant find a link to the package
18:30:42 <monoidal> sshc: isn't local for Reader?
18:30:42 <ddarius> moosefish: ghc-pkg latest parsec should tell you.
18:30:54 <ddarius> Or you can check if you can import the module Text.Parsec.
18:31:02 <sshc> monoidal: Ah, yes MonadState
18:31:04 <moosefish> Thanks. And crap, I'm using 2.1.0.1
18:31:23 <sshc> or rather MonadReader
18:31:47 <dankna> Cale: it's for the benefit of youth who haven't learned dynamic allocation all the way yet
18:31:58 <sshc> I can't find the source for that or which module declares that on hackage
18:32:10 <sshc> lambdabot somehow knows about it
18:34:07 <monoidal> sshc: http://hackage.haskell.org/packages/archive/monads-tf/latest/doc/html/src/Control-Monad-Reader-Class.html#MonadReader
18:34:14 <monoidal> sshc: MonadReader class
18:34:45 <sshc> Ah, I think I somehow was reading Writer
18:35:01 <monoidal> although it's not the same, maybe lambdabot has other version
18:35:28 <Cale> etpace: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cpuperf-0.1
18:36:05 <Cale> also: http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
18:39:24 <jmcarthur> Cale: yes, contests always have silly redundancy :\
18:39:41 <jmcarthur> i think they think it somehow makes it easier...
18:39:46 * hackagebot crypto-api 0.1.0.0 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.1.0.0 (ThomasDuBuisson)
18:40:02 <jmcarthur> what bugs me more is when they have irrelevant information
18:40:04 <Cale> I always end up parsing those things just to discard them.
18:40:39 <Cale> (and usually don't bother checking that the number of testcases presented is actually the number given, though that would be a particularly cruel thing to do ;)
18:41:29 <Cale> Provide an input to the contest program which has extra testcases at the end that should be ignored because the number is lower :)
18:41:45 <dankna> that WOULD be a cruel trick hahaha
18:41:48 <dankna> I like the way you think
18:53:49 * hackagebot random-extras 0.15 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.15 (AristidBreitkreuz)
18:54:56 <lispy> heh, random-extras is a cute package name
19:00:55 <dankna> hah
19:00:57 <dankna> yes it is
19:02:54 <aristid> lispy: heh you mean because it can be read in two ways?
19:04:11 <megajosh2> There we go...
19:04:59 <dankna> yes, because of that :D
19:17:33 <Mitar> if i have two different types of records which have exactly the same types of fields in it - is there an easy way to map from one to another without having to enlist all fields by names?
19:20:00 <ddarius> Mitar: You don't need to use record notation just because you are using a record.
19:20:19 <ddarius> f (RecordA x y z) = RecordB x y z
19:20:42 <Mitar> ok, but i have to count the fields ;-)
19:20:49 <kfish> Mitar, or do you mean you want to unsafeCoerce (ie. cast)?
19:20:55 <Mitar> no, not cast
19:21:16 <Mitar> i want it that it is type checked
19:21:16 <kfish> what do you want to write?
19:21:25 <Mitar> huh ;-)
19:21:41 <ddarius> kfish: He wants safeCoerce.
19:21:45 <Mitar> yes ;-)
19:22:04 <Mitar> so that if i change RecordA it will say it cannot do that
19:22:22 <Mitar> but i want to change it so that at different parts of the program different type is used
19:22:32 <Mitar> so that change is made only at one place in the program
19:22:39 <Mitar> so that i can easier reason about it
19:23:01 <Mitar> (some kind of information/access scope i would like to do, i would say)
19:23:12 <c_wraith> Mitar is this a case where something like phantom types might be useful?  Same internal representation, distinct types?
19:23:34 <Mitar> yes, i also use them ;-)
19:23:45 <Mitar> have a type with 6 type arguments ;-)
19:23:52 <Mitar> but this is the second part of that
19:24:05 <Mitar> where i want to translate values now from one type to another
19:24:17 <Mitar> so with types and phantom types i make functions play nice
19:24:23 <Mitar> now i want to make also values play nice
19:24:31 <Mitar> so that they can be "composed" ;-)
19:25:21 <Cale> It sounds like you want RecordA to be a newtype of RecordB, or vice-versa (or both be newtypes of something else)
19:25:36 <Mitar> hmm, good idea
19:26:16 <Mitar> the problem is that my original record type is a sum of multiple possible types (ehm, i do not know you say that, like Foo = Foo {...} | Bar {...})
19:26:28 <Mitar> and resulting type would be only from one of those
19:26:56 <Cale> Multiple data constructors, okay
19:27:14 <Mitar> so in fact this is the problem
19:27:24 <Mitar> that i have a type which can have too many different values
19:27:24 <Cale> Is it the data constructors Foo and Bar which have the same types of fields?
19:27:36 <Mitar> and i would like to make a function, which gets only one data constructor out
19:27:52 <Cale> It might be worth factoring out the difference, so that you have something like...
19:28:03 <Cale> data FooType = Foo | Bar
19:28:25 <Cale> data Foo = F { fooType :: FooType, ... other fields ... }
19:28:35 <Cale> (so you only have one constructor then)
19:29:05 <Cale> (This would probably make more sense with a real example...)
19:29:25 <Mitar> hmm, it is more like data FooBar = Foo {...} | Bar {..} and I would like to have data OnlyFoo = OnlyFoo {...}, where Foo has the same fields as OnlyFoo
19:29:52 <Cale> data FooBar = Foo OnlyFoo | Bar OnlyBar
19:30:42 <Mitar> (the real example is that i have a data type which represents different possible events and i would like to make a projection of only one event to special data type so that i can give that to functions which work only on that)
19:32:00 <Cale> Is extensibility important?
19:32:06 <Cale> (In terms of types of events)
19:32:18 <Mitar> not in this case
19:32:22 <Cale> okay
19:32:52 <Cale> So, probably the way that you want to do it is to have a bunch of datatypes, one per event, and then a sum type with all of those.
19:32:58 <Cale> (One field per constructor)
19:33:34 <Cale> Another way is to do something like...
19:33:59 <Mitar> yes, but then i get one additional layer in types
19:34:12 <Mitar> so Foo (FooRecord {})
19:35:03 <Cale> okay, so I'll show the other way on hpaste, one sec
19:35:39 <Mitar> thanks
19:38:18 <Mitar> does compiler checks which of data constructors is used when you use projection function on the record value? or it just throws an execption at runtime if that function cannot operate on a given value?
19:38:28 <dmwit> exception
19:39:15 <Cale> grr, internal server error while pasting :P
19:39:28 <rothwell> hm... is there a pure haskell+opengl gui toolkit out there?
19:39:44 <rothwell> really don't want to depend on gtk or a pile of c++
19:39:51 <Cale> http://paste.lisp.org/display/114741
19:40:32 <Cale> Mitar: You could go with something like that, which lets you cast back and forth between SomeEvent and specific types of event
19:40:52 <Mitar> (paste has some problems)
19:40:53 <Mitar> now that i think of it would be even better if record could be changed to another record if it had he same or more fields than target record
19:41:26 <Cale> Mitar: It just throws a (difficult to catch!) exception if you use a field extractor which doesn't exist for the given case.
19:41:55 <Cale> It's better to use Maybe for such cases.
19:41:55 <Mitar> i cannot resolve paste.lisp.org
19:42:04 <Cale> oh, really?
19:42:27 <Cale> http://codepad.org/AM1o9Qst
19:42:55 <Cale> This is really just mimicking the new Exception library, almost exactly.
19:43:21 <Cale> You can also do this without Typeable, but it's not quite as convenient like that.
19:43:39 <Mitar> but cast uses unsafecast, no?
19:43:50 <Cale> cast is typesafe cast
19:43:57 <Cale> But it internally uses an unsafe cast
19:44:14 <Cale> It's safe as long as you never write your own instances of Typeable
19:44:24 <Cale> (let the compiler do it for you)
19:45:41 <Mitar> ok, but this is in fact the same thing dynamic is doing, no?
19:45:52 <Cale> More or less, yes.
19:45:53 <Mitar> putting everything into existential and then cast out
19:46:12 <Cale> Together with a typeclass which lets you express which types are event types
19:46:19 <Mitar> yes
19:46:24 <Mitar> subset of dynamic ;-)
19:46:39 <Mitar> what is better ;-)
19:46:46 <Mitar> because you can limit garbage in ;-)
19:47:31 <Cale> You could also, if there's some common set of operations all events ought to support, add some additional methods to the Event class.
19:48:09 <Cale> But it would mean more work in writing the instances. This way you get to write the nice empty instance declarations :)
19:48:56 <Mitar> yes
19:48:57 <Mitar> thanks
19:49:13 <Mitar> you could also do some default then
19:49:20 <Cale> Yeah
19:49:25 <Mitar> for those additional operations
19:49:31 <Mitar> like foo = undefined ;-)
19:49:33 <Cale> Sometimes that's possible, yeah
19:49:48 <Mitar> so that you get even more errors at runtime ;-)
19:50:01 <Mitar> that's always fun ;-)
19:50:16 <Cale> Well, the default if you leave definitions out is similar to defining it as undefined, only you'll get a nicer error message.
19:50:32 <Cale> (and compile time warnings)
19:51:33 <nkpart> I'm looking for a directory 'globbing' function, that works something like this: http://gist.github.com/589113
19:51:42 <nkpart> any suggestions?
19:51:50 <nkpart> I'd prefer not to be shelling out to ruby :)
19:53:03 <Mitar> yes, i was being more or less sarcastic that you can hide those errors of missing instance functions if you really want ;-)
19:53:17 <Mitar> thanks for help
19:54:01 <aavogt> @hoogle getDir
19:54:01 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
19:55:04 <aavogt> nkpart: though doing a regex on that isn't going to do any recursive contents getting
19:55:50 <tommd> Combine that with a regex package or just use the [take,drop][Extension,Filename,Path] functions along with is[Prefix,Suffix,Infix][Of] along with the filter function.
19:56:07 <tommd> Oh, I missed the second example
19:56:21 <tommd> Well the function would have to be slightly more complex, but nothing horrible.
19:56:45 <aavogt> the implementation as-is is shorter
19:56:51 <Cale> there is http://hackage.haskell.org/package/Glob
19:57:35 <tommd> How about that.  And it's on the seventh release.
19:57:40 <ajnsit> I just noticed that factorcss does not parse css properties that start with '-'
19:58:06 <ajnsit> that means it cannot process properties specific to mozilla and webkit
19:58:30 <dmwit> FIX IT
19:58:35 <dmwit> QUICK!
19:58:52 <manateeUser> Cale: Glob looks cool. :)
19:59:42 <Mitar> ajnsit: it would be even better if you could feed him real HTML pages you use and it would find out which declarations are obsolete because you do not use them anymore ;-)
19:59:58 <nkpart> Cale: that looks good! thanks
20:00:31 <ajnsit> Mitar, well you would need to parse js too for that to work
20:01:02 <Cale> It's still not quite the same as asking bash to do filename expansion (the ruby glob isn't either).
20:02:06 <Cale> In particular neither one does ~ expansion
20:02:18 <manateeUser> Cale: Do you know any library can help developing terminal emulator? I don't want do duplicate work like GoogleTranslate package.
20:02:28 <manateeUser> Cale: So i think i should ask before do it. :)
20:02:48 <dmwit> Doesn't gtk+ have a widget specifically for this?
20:03:13 <manateeUser> dmwit: I know vte, i have binding it to haskell, but not MVC design.
20:03:29 <manateeUser> dmwit: You can't hold terminal data after you destory widget.
20:03:55 <manateeUser> dmwit: And two terminal widget can't share same terminal buffer to support multiple view.
20:04:03 <dmwit> That's annoying.
20:04:20 <manateeUser> dmwit: I love Mutl
20:04:26 <manateeUser> Multi-Term in Emacs
20:04:41 <dmwit> Who wins size requests, etc.?
20:04:47 <manateeUser> dmwit: So i want build some terminal like that, support multiple view.
20:05:13 <dmwit> There are a few VT packages on Hackage, I think.
20:05:17 <manateeUser> dmwit: I plan to use Cairo and Pango render temrinal graphics.
20:05:22 <manateeUser> @package vte
20:05:22 <lambdabot> http://hackage.haskell.org/package/vte
20:05:27 <manateeUser> dmwit: ^^^^^^
20:05:37 <manateeUser> dmwit: That's gtk+ widget.
20:05:51 <Mitar> http://pastebin.com/6fqbRVAE << why oh why
20:06:27 <dmwit> ?hackage vty
20:06:27 <lambdabot> http://hackage.haskell.org/package/vty
20:06:30 <ajnsit> Fixed FactorCSS http://pastebin.com/PszDeeQv
20:06:30 <Cale> Mitar: There's specifically an extension for that
20:06:31 <dmwit> manateeUser: ^^
20:06:38 <ajnsit> now where do I put up that patch
20:07:01 <Cale> Mitar: DisambiguateRecordFields
20:07:11 <ManateeLazyCat> dmwit: Thanks.
20:07:35 <dmwit> ajnsit: Mail it to the author, I guess.
20:07:46 <dmwit> The Factor CSS website has an email address on it.
20:07:49 <Cale> Mitar: Though personally I try not to have overlapping names between modules as much as possible
20:08:18 <Cale> (I prefer that module disambiguation of names is a last resort)
20:09:27 <ManateeLazyCat> dmwit: Have other VT package for reference?
20:09:52 <monochrom> TypeDirectedDeadCodeRemoval
20:10:21 <Mitar> TypeDirectedDeadCodeRemoval?
20:10:34 <dmwit> ManateeLazyCat: I don't know any others.
20:10:39 <monochrom> it means type-erring code is deleted
20:10:51 <ManateeLazyCat> dmwit: Oh, thanks for vty. :)
20:11:04 <monochrom> keep deleting code until there is no more type error
20:11:26 <Cale> Heh, I was like "Why is my browser scrolling down automatically all of a sudden?", and then I noticed there was a kitten pressing the down key on my keyboard with his paw. :)
20:11:26 <dmwit> ManateeLazyCat: Your productivity is scary. I envy you. =)
20:11:29 * hackagebot data-binary-ieee754 0.4.2 - Parser/Serialiser for IEEE-754 floating-point values  http://hackage.haskell.org/package/data-binary-ieee754-0.4.2 (JohnMillikin)
20:14:06 <ManateeLazyCat> dmwit: I have ask author of vte, he won't add model/view split in short time, and he let me hacking vte code, and i'm not familiar with vte code, so i think why not use Haskell write new one? Much clear and let other people can study terminal how to work....
20:14:30 <dmwit> sounds like a fun project
20:14:42 <dmwit> I started doing that, too, almost a year ago.
20:14:44 <Mitar> ManateeLazyCat: i missed a link to your code?
20:14:57 <dmwit> But I only made it a little way into the VT-100 documentation before I got thoroughly fed up. ^_^
20:15:12 <ManateeLazyCat> Mitar: https://patch-tag.com/r/AndyStewart
20:15:37 <ManateeLazyCat> dmwit: Ah, can you share your code?
20:15:51 <dmwit> um
20:16:09 <ManateeLazyCat> dmwit: Even demo code can help me develop it quicker. :)
20:16:23 <dmwit> I'm looking for it. =)
20:16:25 <ManateeLazyCat> dmwit: If vte support model/view split, i won't do that.
20:16:34 <ManateeLazyCat> dmwit: Thanks a lot! :)
20:18:08 <ManateeLazyCat> Mitar: My mail is lazycat.manatee@gmail.com, if you interested my project, welcome to join! :)
20:18:41 <Mitar> i do not know yet what exactly you are doing ;-)
20:19:03 <ManateeLazyCat> Mitar: Here is : http://www.flickr.com/photos/48809572@N02/
20:20:18 * ManateeLazyCat Terminal emulator is last *important* module i want add in my projeh...
20:20:27 <dmwit> ManateeLazyCat: It is lost. =/
20:20:55 <ManateeLazyCat> dmwit: Nevermind, i explore it myself, more fun. :)
20:21:17 <ManateeLazyCat> dmwit: Do you know any temrinal documentation i can reference?
20:21:31 <ManateeLazyCat> dmwit: I just know http://vt100.net/
20:21:54 <dmwit> That's exactly what I used.
20:22:08 <magusapollo> I only started learning Haskell a few months ago, so typing is still a bit arcane to me.
20:22:14 <dmwit> Specifically the VT102 docs.
20:22:19 <magusapollo> and I'm not entirely sure that's what my problem is.
20:22:51 <magusapollo> but evidently, I'm passing two Ints to a function with type (Integral a) -> a -> a -> a and it doesn't like it.
20:23:04 <magusapollo> er, that first one's =>
20:23:04 <ManateeLazyCat> dmwit: How do you get data from interactive shell process?
20:23:10 <monochrom> like "1+1"?
20:23:22 <ManateeLazyCat> dmwit: Because getContents use lazy IO, it can't work.
20:24:00 <Mitar> ManateeLazyCat: still do not follow? what is the name of your project?
20:24:03 <dmwit> hGetChar seems simplest, though something out of Data.ByteString might be safer.
20:24:10 <ManateeLazyCat> Mitar: manatee
20:24:26 <ManateeLazyCat> dmwit: Decode yourself? ;p
20:24:33 <magusapollo> @monochrom: I'm getting a couple of numbers from each line of an input file and attempting to convert them into actual numbers instead of just text representations
20:24:33 <lambdabot> Unknown command, try @list
20:24:45 <ManateeLazyCat> Mitar: I build my project for my girl.
20:24:55 <Mitar> ?
20:25:04 <ManateeLazyCat> Mitar: My girl is manatee. :)
20:25:05 <dmwit> ManateeLazyCat: Indeed, to handle locales yourself.
20:25:10 <Mitar> now i am really completely list ;-)
20:25:14 <Mitar> lost
20:25:46 <ManateeLazyCat> dmwit: Hmm, thanks for help. :)
20:26:19 <ManateeLazyCat> dmwit: vty looks like temrinal GUI toolkit, and not a terminal package. 
20:26:33 <monochrom> > map read (words "20 13 14")
20:26:33 <Mitar> aaa
20:26:34 <lambdabot>   [*Exception: Prelude.read: no parse
20:26:34 <Mitar> The Haskell/Gtk+ Integrated Live Environment
20:26:39 <ManateeLazyCat> dmwit: But i think perhaps some code will help me..
20:26:42 <ManateeLazyCat> Mitar: yes.
20:26:46 <Mitar> ;-)
20:26:51 <Hunner> :t (<+>)
20:26:52 <lambdabot>     Ambiguous occurrence `<+>'
20:26:53 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
20:26:53 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
20:27:05 <ManateeLazyCat> Mitar: I called it "ILE"
20:27:24 <monochrom> > map read (words "20 13 14") :: [Int]
20:27:25 <lambdabot>   [20,13,14]
20:27:34 <monochrom> that way at least you get a list of ints
20:27:49 <magusapollo> monochrom: yeah, I've got that as part of my transformation
20:28:01 <Cale> http://hackage.haskell.org/package/process
20:28:18 <Cale> ManateeLazyCat: ^^ that's the standard library for creating and talking to processes
20:28:38 <magusapollo> but so far I have to go through a couple utility functions to avoid the IO silliness
20:28:49 <ManateeLazyCat> Cale: Thanks, reading....
20:28:57 <magusapollo> http://pastebin.com/TUE1ks5q if you want to see the actual code
20:29:19 <bss03-AFK> http://ai-contest.com <-- Haskellers Unite!  We are no longer in the Top 100!
20:29:19 <Cale> ManateeLazyCat: You can use createProcess in System.Process to do it
20:29:26 <bss03-AFK> ^^ Code faster and better!
20:29:45 <ManateeLazyCat> Cale: Oh i know that package, infact i use runInteractiveProcess to create bash process.
20:29:52 <ManateeLazyCat> Cale: As daemon process.
20:30:38 <Mitar> ManateeLazyCat: that is too close to IE for me ;-)
20:30:38 <ManateeLazyCat> Cale: And i need hGetChar instead hGetContents for get output strictly.
20:30:52 <ManateeLazyCat> Mitar: IE ?
20:31:05 <Cale> magicman: Rather than nested if/then/else, consider using guards
20:31:08 <co_dh> does anybody know where I can find Richard Bird's theory of list ? It seemed to be too old to be googled.
20:31:12 <Cale> er, magusapollo rather
20:31:42 <Mitar> internet explorer ;-)
20:31:48 <ManateeLazyCat> Mitar: Why?
20:31:53 <Mitar> ILE = IE ;-)
20:31:58 <ManateeLazyCat> Mitar: :)
20:32:08 <ManateeLazyCat> Mitar: So just call it manatee :)
20:33:06 <ManateeLazyCat> dmwit: Cale Thanks for help! Start to develop temrinal emulator now. :)
20:33:09 <dmwit> Oh, you'll probably want to hSetBuffering as well. You probably already knew that.
20:33:11 <magusapollo> Cale: interesting.
20:33:34 <magusapollo> Cale: one does learn something new everyday.
20:33:58 <Cale> magusapollo: Which of these function are designed to get around IO silliness?
20:34:27 <Cale> oh, you mean parsing numbers?
20:34:31 <magusapollo> mhm
20:34:42 <ManateeLazyCat> dmwit: Because hGetContents use stupid lazy IO function, "hSetBuffering handle NoBuffering" can't work.
20:35:17 <Cale> magusapollo: I would rework that a bit... give me a moment to show how :)
20:35:25 <magusapollo> Cale: heh, okey dokies
20:36:46 * hackagebot hmatrix-gsl-stats 0.1.2.5 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.5 (VivianMcPhail)
20:38:52 <Cale> magusapollo: http://codepad.org/SvMJLmaB
20:39:27 <Cale> magusapollo: The behaviour is a little different from your program
20:39:41 <Seryl> Any suggestions for a web framework? HAppS vs Snap?
20:39:48 * hackagebot hstatistics 0.2.2.4 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.4 (VivianMcPhail)
20:39:49 <Cale> magusapollo: It stops on the first line which doesn't contain exactly two numbers
20:40:30 <Cale> magusapollo: But regardless of how you make it behave, pattern matching is a lot more elegant.
20:40:36 <magusapollo> Cale: indeed.
20:40:51 <magusapollo> and that's basically awesome.
20:40:58 <magusapollo> thankee say
20:41:00 <magusapollo> sai*
20:41:00 <Cale> Another option would be to handle the [0,0] -> ... case separately, and print an error message for the rest
20:41:08 <magusapollo> makes sense.
20:41:42 <Cale> Note that you don't have to specify the type of data being read explicitly
20:41:49 * hackagebot hsignal 0.1.2.4 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.1.2.4 (VivianMcPhail)
20:41:53 <Cale> So long as the type of surjections is clear enough
20:42:10 <Cale> (If it takes Integer values, then Integer values will be parsed)
20:42:15 <magusapollo> mmmmmkay
20:42:40 <magusapollo> there're definitely still a lot of things I'm still getting used to in functional programming.
20:43:04 <magusapollo> or in Haskell, specifically.
20:43:09 <Cale> yeah
20:43:09 <monochrom> you can add a line "[0,0] -> return ()" to quit on "0 0"
20:44:15 <ManateeLazyCat> Thanks all for help! Bye. :)
20:44:41 <Cale> nThingsI n i = product [n - i + 1 .. n] `div` product [1 .. i]
20:46:00 <Cale> Or even: nThingsI n i = factorial n `div` (factorial i * factorial (n-i))
20:46:57 <magusapollo> huh.
20:46:59 <magusapollo> cool
20:47:29 <magicman> Binomial coefficient ftw \o/
20:47:44 <Cale> Yeah, I was debating renaming it to binomial ;)
20:47:45 * dons met shachaf today!
20:47:45 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
20:47:49 <magusapollo> haha
20:48:33 <monochrom> of course the factorial version is silly
20:48:37 <kulin> i wish i could be as popular as dons
20:48:41 <tehgeek> Hey.  Can anyone help me with this?  I'm a n00b at Haskell, and I'm trying to write a function to remove adjacent duplicates from a list (example: [1, 2, 3, 3, 3, 2] becomes [1, 2, 3, 2]).  This is my code:
20:48:49 <tehgeek> remDups :: [a] -> [a]
20:48:49 <tehgeek> remDups xs | (length(xs) <= 1) = xs
20:48:49 <tehgeek>            | (head(xs) == head(tail(xs))) = remDups(tail(xs))
20:48:49 <tehgeek>            | otherwise = (head(xs) : remDups(tail(xs)))
20:48:52 <tehgeek> And I get this error:
20:49:02 <tehgeek> ERROR "assign2.hs":92 - Cannot justify constraints in explicitly typed binding
20:49:02 <tehgeek> *** Expression    : remDups
20:49:02 <tehgeek> *** Type          : [a] -> [a]
20:49:02 <tehgeek> *** Given context : ()
20:49:02 <tehgeek> *** Constraints   : Eq a
20:49:11 <tehgeek> What's going on?  I can't even understand what it's trying to tell me.  TIA
20:50:57 <JoeyA> The type signature remDups :: [a] -> [a] says remDups will work on _any_ list of items.
20:51:18 <JoeyA> However, equality is only allowed for types in the type class Eq
20:51:36 <JoeyA> That's what it means.
20:51:47 <tehgeek> JoeyA: The type class Eq?  Is that basically just a category of types that are able to have equality?
20:51:52 <JoeyA> yes
20:51:58 <JoeyA> :i Eq
20:52:02 <tehgeek> JoeyA: Okay, so is there a way of saying I want this to work on any list that can do that?
20:52:05 <JoeyA> (dang, no bot for me)
20:52:10 <JoeyA> @i eq
20:52:11 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
20:52:22 <tehgeek> JoeyA: I looked at the list on my hugs
20:52:23 <tehgeek> :3
20:52:40 <JoeyA> tehgeek: Yes:  remDups :: (Eq a) => [a] -> [a]
20:53:25 <tehgeek> Oh, excellent, thanks :)
20:54:55 <kulin> also, i might suggest using a case statement so you can use a lot of the list pattern matching
20:55:32 <Cale> or just a definition for each of the cases
20:56:05 <bss03> @src nub
20:56:05 <lambdabot> nub = nubBy (==)
20:56:11 <bss03> @src nubBy
20:56:11 <lambdabot> nubBy eq []             =  []
20:56:11 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:56:19 <JoeyA> nub isn't for consecutives
20:56:26 <bss03> remDups <-> nub ?
20:56:26 <JoeyA> > nub [1,2,3,1]
20:56:27 <lambdabot>   [1,2,3]
20:56:31 <Cale> remDups [] = []; remDups [x] = [x]; remDups (x:y:xs) | x == y = ... | otherwise = ...
20:56:43 <bss03> A.
20:56:45 <bss03> Ah.
20:56:48 <Cale> (that's flattened onto one line, but obviously you'd want to write it nicely)
20:56:49 <JoeyA> The recipe you're looking for is map head . group
20:56:58 <JoeyA> > (map head . group) [1,1,2,3,3,4,5]
20:56:59 <lambdabot>   [1,2,3,4,5]
20:57:03 <JoeyA> > (map head . group) [1,1,2,3,3,4,5,1,2]
20:57:04 <bss03> So, something like head =<< group
20:57:04 <lambdabot>   [1,2,3,4,5,1,2]
20:57:06 <bss03> ?
20:57:32 <aristid> :t head =<< group
20:57:33 <lambdabot>     Couldn't match expected type `[a] -> b' against inferred type `[a]'
20:57:33 <lambdabot>       Expected type: [a] -> [[a] -> b]
20:57:33 <lambdabot>       Inferred type: [a] -> [[a]]
20:57:41 <aristid> bss03: more like head <$> group
20:57:55 <Cale> (head =<< group) xs = head xs (group xs)
20:58:02 <Cale> er, no
20:58:16 <Cale> (head =<< group) xs = head (group xs) xs
20:58:23 <bss03> :t head <$> group
20:58:24 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:58:29 <Cale> either way, it's problematic ;)
20:58:36 <aristid> Cale: it would be if head =<< group would type check
20:59:14 <aristid> :t head . group
20:59:15 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:59:30 <JoeyA> That gets you the first group.
20:59:46 <JoeyA> map head . group . Won't anyone listen to me!!!
21:00:10 <JoeyA> tehgeek is likely doing this for learning or homework, so will probably not want to use this recipe right now anyway.  It's good to know for future reference, though :-)
21:00:47 <Cale> map head . group is a bit different
21:01:02 <Cale> er, no, that's right :)
21:01:15 <JoeyA> "I'm trying to write a function to remove adjacent duplicates from a list (example: [1, 2, 3, 3, 3, 2] becomes [1, 2, 3, 2])."
21:01:26 <Cale> Right, map head . group :)
21:01:42 <JoeyA> Use nub to remove all duplicates and introduce an O(n^2) algorithm into your code.
21:01:44 <Cale> I was thinking it was nub, but it's not
21:02:03 <Cale> nub is O(n^2), but it's as fast as it can be given its type.
21:02:13 <JoeyA> right
21:02:25 <JoeyA> Use map head . group . sort to do it in O(n log n), but not lazily.
21:02:57 <Cale> (and you need an additional Ord constraint, and the results are sorted)
21:03:26 <JoeyA> right
21:03:39 <JoeyA> Here's how I like nub done, by using a set:  http://codepad.org/KOLuhV8U
21:03:55 <Cale> yeah
21:07:29 <JoeyA> and I've said it once, but I'll say it again:  the nub in Data.List.Ordered has different semantics than the one in Prelude.
21:07:40 <JoeyA> (unless the input list is sorted)
21:09:55 <tehgeek> Yeah, thanks kulin, aristid, and whoever...this is just homework assignment and I just want to make it work and be done :P
21:11:32 <magicman> Aww, man. I need UndecidableInstances to nest type families :(
21:11:48 * JoeyA wishes Haskell was my homework.
21:12:05 <JoeyA> Instead, me have english to does.
21:14:03 <JoeyA> tehgeek: We helped you a little, then proceeded to carry on about stuff we care about :-)
21:14:43 <JoeyA> But kulin's suggestion about using a case statement is probably the most useful one to you.
21:16:17 <tehgeek> JoeyA: :3
21:16:29 <tehgeek> JoeyA: Haskell isn't all of my homework...I also have an evil GenEd (even though I'm a senior) and physics lab :\
21:16:43 <tehgeek> I also have abstract algebra, which is awesome.  I could go to that class all day, do homework for it all night, and still be having fun
21:17:51 <JoeyA> cool
21:21:18 <djahandarie> Abstract algebra is fun
21:21:25 <djahandarie> I haven't had a course in it but I enjoy it
21:24:23 <augur> i just want everyone to know that this channel consumes hundreds of megabytes of diskspace for logs per year.
21:24:43 <JoeyA> per person?
21:24:51 <augur> well, for me anyway
21:27:43 <monochrom> just hundreds of megabytes?
21:27:46 <augur> :P
21:28:27 <monochrom> annual new disk inflation surpasses
21:28:38 <monochrom> err, annual new disk inflation surpasses that
21:34:24 <Adamant> monochrom: it might not keep doing that, at least for SSD's.
21:34:46 <Adamant> monochrom: HD's should be fine, of course.
21:35:19 <monochrom> In case they stop inflating, there is always tape.
21:36:39 <winxordie> lol, disk inflation?
21:36:45 <winxordie> are disks a currency now?
21:37:21 <tommd> welcome back the doubespace / drivespace tools from the dos days.
21:37:38 <monochrom> perhaps you lolled too when Guth talked about universe inflation
21:38:21 <Mitar> http://pastebin.com/uSHE9FxY << why oh why?
21:38:38 <monochrom> because it's good for you
21:38:57 <Mitar> no warnings are good for me?
21:39:11 <monochrom> "unknown paste ID"
21:39:14 <tommd> It teaches you to use hpaste.
21:39:22 <Mitar> which does not work ;-)
21:39:30 <winxordie> I think it's a bit on the unknown side whether we're suffering universe inflation. Stupid cosmological constant.
21:39:39 <Mitar> or it does now ;-)
21:39:40 <tommd> what is your definition of "work"?
21:39:45 <tommd> yeah
21:40:25 <blbrown_win3> I am still new to haskell.  But should the Fractional type be used for working with currency?  Say, currency in America
21:40:26 <Mitar> 500 Internal Server Error
21:40:26 <Mitar> DBError ("23","505") 7 "ERROR:  23505: duplicate key value violates unique constraint \"paste_pkey\"\nLOCATION:  _bt_check_unique, nbtinsert.c:298\n"
21:40:31 <Mitar> this is my defintion of not work ;-)
21:40:57 <Mitar> (not full definition, of course)
21:41:14 <monochrom> check DNS. 208.77.100.126
21:41:28 <Mitar> who?
21:41:45 <monochrom> meanwhile, it's equivalent to http://paste.tryhaskell.org/
21:42:20 <Mitar> the same error
21:42:37 <Mitar> pastebin does not work for you?
21:43:00 <Mitar> http://pastebin.com/uSHE9FxY << it opens for me just fine
21:43:09 <monochrom> the name "hpaste.org" gets its IP address changed 5 days ago. changed to new, working site.
21:43:35 <monochrom> some DNS servers may be still lagging behind.
21:44:12 <Mitar> but this is bug in code
21:44:32 <Mitar> i get 208.77.100.126 as an ip when i resolve
21:45:04 <Mitar> the last thing is http://paste.tryhaskell.org/30250/importing_old_hpaste_pastes
21:45:19 <Mitar> so maybe this made some duplicated key
21:45:21 <monochrom> that is correct
21:46:11 <Mitar> http://pastebin.com/uSHE9FxY << so does this work for you?
21:46:18 <monochrom> yes
21:46:46 <monochrom> I see, errs when create new paste
21:47:13 <MasseR> Is there a way to simplify this: "do a <- doesFileExist fp; if fp then fp else "/dev/stdin""
21:47:27 <MasseR> Err
21:47:31 <MasseR> *if a then fp
21:50:33 <monochrom> perhaps lambda expressions are meant to be non-exhaustive to begin with
21:50:56 <monochrom> @tell chrisdone hpaste errs when trying to create new paste
21:50:57 <lambdabot> Consider it noted.
21:51:23 <Mitar> monochrom: but this makes a runtime error
21:51:43 <monochrom> anyway "does not work" should be declared completely informationless
21:51:44 <Mitar> i would not say they anything in haskell should be meant to cause that
21:51:58 <Mitar> no, i has one bit of information ;-)
21:52:05 <Mitar> *it
21:52:28 <monochrom> do you know how cheap 1 bit is?
21:52:40 <Mitar> depends which one ;-)
21:52:48 <monochrom> my ram has 40G bits or something
21:53:29 <monochrom> I don't know if -Wall gives you the warning you want.
21:53:37 <Mitar> no it does not
21:53:50 <Mitar> yes, but you average all bits as same
21:53:52 <Mitar> this is not true
21:53:52 <monochrom> then I am very sorry to hear that
21:54:12 <Mitar> a bit on space shuttle controller is more "expensive" than the bit in your ram
21:54:39 <monochrom> and a bit in my ram is yet more expensive than your "doesn't work"
21:54:58 <monochrom> or perhaps more valuable
21:55:57 <monochrom> I have a bit in my ram. It is just a bit, but its meaning is so precise and well-defined, I can rely on it to decide whether it is sleep time or not.
21:57:00 <monochrom> because I know the bit's exact meaning is "the clock time is larger than 1am"
21:57:51 <monochrom> not a subjective "late", "early", "works", "not work". but an objective "after 1am", "before 1am".
21:58:07 <monochrom> objective, measurable, observable, reproducible
22:00:34 <Mitar> one bit is always objective
22:00:42 <Mitar> your interpretation of it is subjective
22:00:49 <Mitar> and bit can still lie ;-)
22:00:56 <Mitar> has information which is not true
22:09:10 <JoeyA> Is there a type class or something that would be able to eliminate tuple boilerplate as is found here?  http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/src/Data-Binary.html
22:10:52 <JoeyA> I'm thinking of a type class that produces and consumes a set of items with given producers/consumers along with a deriving extension that automatically produces them.
22:19:54 <JoeyA> I guess Foldable would do for the thing -> pieces operation, except it doesn't have an instance for tuples.
22:23:51 <copumpkin> and you can't write one
22:25:43 <etpace> How can I do a simple string replace (possibly via regex) in haskell
22:26:52 <Mitar> is there a simple way to invert Ordering?
22:27:03 <copumpkin> flip compare
22:27:20 <copumpkin> will usually do what you need without inverting the datatype itself
22:27:25 * copumpkin goes back to sleep
22:28:48 <Mitar> good one
22:28:49 <Mitar> thanks
22:42:34 <nejucomo> I have a parsec parser which is failing on an input.  I understand why the input fails, but the error message confuses me.  Are there any tips for "tracing" a parsec parser?
22:43:26 <nejucomo> I consider a bad parse error to be a bug in my parser.
22:43:48 <lucca> are you using <?> to help improve expecting errors?
22:43:55 <nejucomo> Yes.
22:44:08 <nejucomo> The expectation string is part of what confuses me, along with the location of the error.
22:44:31 <lucca> isn't that string the one you put in quotes?
22:44:41 <lucca> i.e. if your own message is confusing, change it?
22:44:49 <nejucomo> I've tried ghci's :break and :step (new to me), but I end up breaking into my grammar production monads, not the actual parsing process.
22:45:31 <nejucomo> hehe…  I use alternatives all over the place with (<|>), so the expectation string lists a bunch of expectations which seem wrong.
22:48:50 <nejucomo> I guess when I said a "parsec tracer", I wish I could turn on a debugging mode that would show me the error messages for all failed alternatives.
22:49:44 <nejucomo> I suspect it has something to do with the way I've tried to improve error messages in the face of alternatives.
22:50:58 <nejucomo> Suppose I have: "expression = (try letExpr) <|> reference" and "letExpr = do { string "let " ; bindings }"
22:51:33 <nejucomo> Now let's say the input begins "let " followed by incorrect binding syntax.
22:52:27 <nejucomo> That branch will fail, and expression is tried, and "let" will match a reference (for the sake of argument), but the following stuff fails to be a properly formed expression.
22:52:52 <nejucomo> Sorry, I meant the rest of the stuff won't be a valid _reference_.
22:53:12 <nejucomo> So now the error message will say something about a malformed *reference* when in reality it is a malformed *let expression*.
22:53:30 <nejucomo> Is there a good way to solve this problem?
22:53:37 <kmc> Mitar, (EQ `compare`)
22:53:41 <kmc> :t (EQ `compare`)
22:53:42 <lambdabot> Ordering -> Ordering
22:54:09 <nejucomo> Is anyone familiar with this problem?
23:01:15 <kmc> seems we have a boatload of json libraries
23:01:21 <kmc> anyone done a comparison of them?
23:02:54 <dibblego> heh, we're writing two at work at the moment
23:04:29 <kmc> haha
23:04:37 <dibblego> one in Scala
23:04:41 <kmc> what's wrong with the 53 libraries that currently exist
23:04:43 <dibblego> one in Haskell, as an exercise
23:04:45 <kmc> ah
23:05:11 <kmc> hpaste does HLint now? :O
23:05:13 <dibblego> the Scala parser library is complete crap, making it a challenge
23:07:01 <kmc> heh
23:07:37 <dibblego> I run a weekly haskell course, so I'm going to get us to write a JSON parser using a parser library we recently wrote
23:07:53 <kmc> cool
23:08:01 <kmc> what's the inspiration for the parser library?
23:08:07 <kmc> is it based on the uuparsing tutorial?
23:08:15 <dibblego> it's similar to Programming in Haskell
23:08:43 <dibblego> newtype Parser a = P (String -> Either Error (String, a))
23:09:11 <kmc> ok
23:09:21 <kmc> so it's not multivalue
23:09:26 <dibblego> no
23:09:56 <chrisdone> yeah
23:09:56 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
23:09:59 <chrisdone> @messages
23:09:59 <lambdabot> monochrom said 1h 19m 2s ago: hpaste errs when trying to create new paste
23:10:13 <kmc> what's the etiquette about module namespaces? if i'm making a package designed to compliment JSONb, can i name my module Text.JSONb.<something currently not used in the JSONb package>?
23:10:13 <chrisdone> uh huh, damn old pastes import had this line:
23:10:13 <chrisdone> SELECT pg_catalog.setval('paste_id_seq', 30199, true);
23:10:27 <nejucomo> Ooohhh…  Ok, looking at my input more closely, I see that the *expectation string* is correct, but the location is wrong.  Is this related to try?
23:10:27 <kmc> solidsnack, around?
23:10:34 <chrisdone> cheeky export script
23:12:03 <nejucomo> -or could it be a parsec bug?!
23:13:08 <chrisdone> @tell monochrom unintentionally reset the primary key sequence when importing the old pastes. no biggie
23:13:08 <lambdabot> Consider it noted.
23:16:39 <nejucomo> Ok, I've boiled down the problem I see to the simplest case: http://codepad.org/UcuxDpOb
23:16:57 <nejucomo> Is this the expected behavior of try or is this a parsec bug?
23:17:36 <nejucomo> Oh, it's not related to try.
23:17:45 * nejucomo gtfms about parsec and locations.
23:18:57 <augur> anyone familiar enough with scheme's call/cc to answer some questions?
23:19:14 <dolio> Does it have to be Scheme's?
23:19:33 <augur> well, it has to be equivalent :D
23:20:09 <dolio> I know about call/cc in general. If you're going to ask how it interacts with, say, mutable variables in Scheme, or something like that, I might not know the answer, though.
23:20:21 <augur> no no
23:20:34 <augur> dolio: ok so assume (define (f return) (return 2) 3)
23:20:49 <augur> now wikipedia says   (display (call/cc f)) ; displays 2
23:21:12 <augur> now, is this an appropriate way of describing whats going on:
23:24:11 <nejucomo> Ok, so I *think* I fixed the problem without fully understanding how locations and rejected characters are selected, but my "fix" may be case-specific...
23:24:16 <nejucomo> Time for a unit test.
23:25:43 <kmc> chrisdone, i see hpaste does hlint now
23:25:55 <kmc> that's effing brilliant
23:27:54 <chrisdone> :D
23:28:31 * kmc could guess how call/cc interacts with mutable vars based on TAing a class where the students had to draw those effing environment diagrams
23:28:45 <augur> dolio: sorry, my client apparently died. did i say anything after you mentioned call/cc in general?
23:28:52 <chrisdone> filed some hlint bugs and tickets while doing it, neil's great
23:28:54 <kmc> i got <augur> now, is this an appropriate way of describing whats going on:
23:29:04 <augur> kmc: and that was it?
23:29:05 <kmc> chrisdone, yeah, i filed a cmdargs bug a couple days ago, got it fixed promptly
23:29:09 <kmc> yeah augur
23:29:21 <augur> bugger.
23:30:14 <augur> kmc, dolio: http://pastebin.org/1016674
23:30:27 <chrisdone> <augur> now, is this an appropriate way of describing whats going on:
23:30:27 <chrisdone> <augur> dolio: sorry, my client apparently died. did i say anything after you
23:30:27 <chrisdone>         mentioned call/cc in general?
23:30:27 <chrisdone> that kind of is what happens with call/cc
23:30:38 <augur> chrisdone: :P
23:31:50 <kulin> when a type implements a typeclass, do you always need to define at least one function?
23:32:05 <dolio> augur: Not exactly.
23:32:08 <augur> dolio: ok
23:32:22 <kulin> or can i just do something like 'instance Identity a'
23:32:38 <augur> dolio: is it roughly like that, give or take some modifications?
23:32:51 <Axman6> kulin: you can have classes without functions at all, so sure
23:33:23 <Axman6> i have a feeling instance Eq a works for anything, since (==) and (/=) are by default defined in terms of each other
23:33:41 <dolio> augur: It's more like, it evaluates 'f k', where k is something special, which when called as 'k x' will jump to evaluating 'x' in the context where call/cc was originally being evaluated.
23:34:14 <augur> dolio: slightly more concrete?
23:35:28 <kmc> hehe 'works' Axman6
23:35:39 <chrisdone> augur: you understand CPS right?
23:36:11 <augur> chrisdone: fullon explicit CPS, sure.
23:36:11 <Axman6> i'm a little drunk, my definition of works is somewhat more lax
23:36:35 <dolio> Well, if you understand CPS...
23:37:12 <augur> dolio: but only explicitly, i think. like, where you hard-code the continuationness
23:37:17 <dolio> call/cc f k = f (\x _ -> k x) k, I believe.
23:37:21 <chrisdone> haha I love how drunk people love announcing that they are drunk, it's like some ancient inclination. when the person who discovered alcohol first invented it, everyone knew straight away
23:37:35 <dolio> _ throwing away the continuation.
23:38:37 <ski> augur : do you understand the CPS-transform(s) ?
23:39:08 <augur> ski: god only knows. probably not.
23:39:38 <augur> im not up on my continuation terminology :)
23:39:52 <dolio> augur: To get a little more specific about the original example, I guess, you started with (display (call/cc f)). Then display got pushed on the stack for (call/cc f) to be evaluated...
23:40:02 <augur> dolio: well, lets try with something more interesting
23:40:09 <augur> (+ 1 (* 2 (call/cc f)))
23:40:23 <augur> just to make it potentially ambiguous
23:40:26 <chrisdone> every single expression `foo bar' is implicitly (\f -> f (foo bar)), (call/cc zot) lets you avoid this wrapping, and so implements its own, resulting in dolio's definition
23:41:02 <dolio> That causes f k to be evaluated, which is (begin (k 2) 3) or something. That starts by calling k with 2.
23:41:03 <ski> dolio,augur : `f' being ?
23:41:24 <augur> ski: f return = return 2; 3
23:41:26 <dolio> Doing that jumps to 2 being evaluated in a context where display is on the stack.
23:41:30 <augur> where ; is chaining of some sort
23:41:37 <dolio> Which then prints 2.
23:42:15 <augur> right
23:42:17 <augur> ok
23:42:32 <dolio> call/cc captures up the evaluation context, and when you call the function passed to f, you jump to that context with whatever argument it was passed.
23:43:02 <augur> aha, so you run your eval down until you hit the call/cc application
23:43:47 <augur> call everything till then K
23:43:49 <ski> augur : if you understand explicit Continuation-Passing Style itself, then i think it would be illuminating to study the CPS-transform(s) which transforms a program in direct style, possibly using continuation side-effects, into a corresponding program written in Continuation-Passing Style
23:44:00 <augur> you drop off to figure out whatever's going on inside the argument of call/cc, and when you hit (return 2), you continue evaluating (K 2)
23:44:19 <augur> then pop back out and evaluate the rest of the argument of call/cc?
23:45:47 <dolio> augur: No, the evaluation context just gets replaced with K.
23:45:55 <dolio> So you effectively never return to the point you jumped from.
23:46:02 <augur> dolio: aha ok
23:46:07 <ski>   [| x |]_cbv = \k. k x
23:46:43 <kmc> call/cc :: ((∀b. a → b) → a) → a
23:46:46 <ski>   [| \x0. e1 |] = \k. k (\x0. [| e1 |]_cbv)
23:47:34 <augur> dolio: would it be safe to say that any program k (call/cc f) k' ~ (f (lambda (x) k x k'))?
23:47:38 <ski>   [| e e0 |] = \k. [| e |]_cbv (\x. [| e0 |]_cbv (\x1. x x0 k))
23:47:43 <kmc> if «call/cc f» then «f :: (∀ b. a → b) → a»,  «f = λk → ...», «k :: ∀b. a → b»
23:47:51 <kmc> k can never return, as its type indicates
23:48:12 <kmc> in fact another typing for call/cc would be ((a → ⊥) → a) → a, yes?
23:48:31 <kmc> the type of call/cc is Peirce's Law, hence the resemblance to negation
23:48:45 <dolio> Yes, potentially.
23:48:47 <kmc> call/cc :: (¬a → a) → a
23:48:55 <ski>   [| call/cc e |]_cbv = \k. [| e |]_cbv (\x. x (\x0. \_. k x0) k)
23:48:55 <dolio> Or if you want to be more opaque, you use 'not.
23:49:02 <kmc> which is some kind of law-of-explosion
23:49:07 <dolio> That's how SMLNJ does it, I think.
23:49:18 <augur> dolio: 'not?
23:49:22 <ski> augur : those are the basic rules of the call-by-value CPS-transform
23:49:31 <dolio> callcc : (not a -> a) -> a
23:49:32 <kmc> it's a really fun exercise to prove (p ∨ ¬p) using call/cc
23:49:35 <kmc> the proof is so cheeky
23:49:37 <Axman6> can i get some help with implementing something with weird types? bloody STUArrays, they make no sense >_< http://hpaste.org/40002/unboxed_heapsort
23:49:39 <augur> ski: thats not helping
23:49:41 <Axman6> error is down below
23:49:50 <dolio> And then there's a 'throw : not a -> a -> b'.
23:49:52 <Axman6> i havce never been able to figure out how to use STUArrays
23:49:56 <dolio> Or something like that.
23:50:27 <dolio> It may not be called 'not,' either, I can't recall.
23:50:41 <augur> this is so not helping me understand :\
23:50:43 <kmc> Axman6, since they're unboxed, they only work for certain types.  the MArray class constraint should convey that, but is getting lost somehow
23:50:56 <Axman6> indeed
23:51:08 <kmc> Axman6, perhaps bring a and s into scope with ∀, then put a sig on your newArr application
23:51:17 <kmc> it may not fix the problem but it might make the error more enlightening
23:51:43 <Axman6> how would i do that?
23:52:07 <kmc> heapsort :: forall a s. (Ord a, MArray (STUArray s) a (ST s)) => [a] -> [a]
23:52:35 <Axman6> same error :\
23:52:39 <kmc> arr <- newArr (1, len) xs :: ST (STUArray s Int a)
23:52:47 <kmc> assuming you mean your keys to be Int
23:53:10 <Axman6> yep
23:53:19 <ski> augur : i'm not fully sure what it is you want to understand here. but if you want to understand `call/cc', then learning CPS, and then the CPS-transform would, i think, be a good start
23:53:30 <augur> ski: not for me.
23:53:41 <kmc> no luck Axman6?
23:53:46 <Axman6> nope :(
23:53:49 <dolio> augur: Have you ever heard of how 'A or Not A' can be interpreted computationally? Where 'Not A' might be interpreted as A -> Empty?
23:53:50 <ski> augur : why ? how do you know ?
23:53:53 <kmc> does the error still reference s1 rather than s?
23:53:58 <augur> dolio: no :P
23:53:59 <Axman6> yep
23:54:12 <Axman6>       Expected type: ST s (STUArray s Int a1)
23:54:12 <Axman6>       Inferred type: ST s1 (STUArray s Int a1)
23:54:15 <kmc> and you for sure put the signature on newArr, and brought s and a into scope in the sig for heapsort?
23:54:21 <kmc> oh, that's closer
23:54:22 <augur> ski: because i think im actually 90% to understanding call/cc from a different perspective
23:54:27 <kmc> before it was ST s1 (STUArray s1 Int a1)
23:54:35 <dolio> augur: When you first look at it, it gives 'Right k', k : A -> Empty, which is ostensibly a proof that A is false.
23:54:36 <ski> augur : ok. which perspective ?
23:54:54 * hackagebot websockets 0.1.1.2 - Implements the WebSocket protocol.  http://hackage.haskell.org/package/websockets-0.1.1.2 (SinisaBidin)
23:55:00 <augur> ski: you dont want to know the answer to that ;)
23:55:09 <kmc> Axman6, ok, don't laugh... try replacing «runST $ do ...» with «runST (do ...)»
23:55:12 <dolio> augur: If you ever use k, though, by supplying it with an A, producing a contradiction, it jumps back to when you first looked at it, and provides whatever you passed to k instead.
23:55:13 * ski is not convinced of that :)
23:55:18 <kmc> i've occasionally had this problem
23:55:19 <augur> dolio: seriously, thats not telling me whats going on
23:55:31 <kmc> ($) doesn't always play nice with the rank-2 type of runST
23:55:39 <augur> dolio: ok let me try to phrase what i got out of a convo with lament
23:55:50 <Axman6> doesn't seem to help 
23:55:58 <kmc> :/
23:56:26 <kmc> what if it's just do { arr <- newArr (1, len) xs; return [] }
23:56:31 <kmc> iow is that line alone enough to be problematic
23:56:49 <ski> dolio : it is called `cont' in SML/NJ and MLton
23:57:09 <dolio> Ah. That's what I would have guessed.
23:57:15 <dufflebunk> I have a function I want to run for no more than 1 second. I'm thinking I can fork two threads, one doing the work and the other sleeping for 1s, but I'm not sure how to wait for the first one to finish. Anyone have any suggestions?
23:57:27 <kmc> dufflebunk, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Timeout.html
23:57:44 <ski>   val callCC : ('a cont -> 'a) -> 'a
23:57:46 <augur> dolio: evalling (+ 1 (* 2 (call/cc f))) ferrets down through the outer applications, builds up some call stack, and when it hits (call/cc f) it treats that callstack as the relevant call stack for return, when evaluating (return 2) prior to the application of the proc to the arg, but after evalling the proc
23:57:47 <kmc> that is indeed how System.Timeout works, and you may enjoy reading it source, but it should also be usable as-is
23:57:53 <ski>   val throw : 'a cont -> 'a -> 'b
23:58:00 <dufflebunk> Cool, thanks kmc
23:58:03 <kmc> :)
23:58:07 <dufflebunk> that looks to be exactly what I need
23:58:25 <kmc> dufflebunk, careful of laziness... if your IO computation is just (return e) then it will probably "take no time"
23:58:35 <kmc> "evaluate" from Control.Exception is useful
23:58:38 <Axman6> kmc: http://hpaste.org/paste/40002/sekfj#p40005
23:59:00 <kmc> Axman6, err, you didn't put the signature on the newArr line
23:59:07 <kmc> does that change it?
23:59:32 <dufflebunk> kmc: thanks for the hint
23:59:33 <ski> augur : i'm not sure what you mean by "when evaluating (return 2) prior to the application of the proc to the arg, but after evalling the proc"
23:59:35 <Axman6> what needs changing? the forall s a.?
23:59:43 <Axman6> which doesn't fix it
23:59:51 <kmc> hmm
23:59:57 <kmc> it's beginning to gel why this is broken
