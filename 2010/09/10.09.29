00:23:58 <co_dh> @djinn a -> ( 1 -> a)
00:23:59 <lambdabot> Cannot parse command
00:24:24 <co_dh> @djinn a->b->a
00:24:24 <lambdabot> f a _ = a
00:24:41 <co_dh> @djinn a -> ( b -> a )
00:24:42 <lambdabot> f a _ = a
00:25:02 <co_dh> what is the theory background of djinn? 
00:26:03 <ddarius> It uses a modified proof theory of intuitionistic propositional logic.
00:26:44 <co_dh> @djinn a->a
00:26:45 <lambdabot> f a = a
00:26:59 <co_dh> it's only find one instance , right ? 
00:27:40 <shachaf> co_dh: One instance is as good as another.
00:28:40 <ddarius> The command line tool will give more solutions (assuming there is more than one)
00:31:30 * ddarius needs to buy a dirt-cheap, relatively small PC.
00:47:13 <rschnck> For the set of binary strings that have at least two 0s and no more than one 1, does this look like the correct regular expression?
00:47:54 <rschnck> 0*((00(0)*1(0)*) | (100(0)*) | (010(0)*))
00:48:57 <Zao> Needs more 2s.
00:49:12 <rschnck> What?
00:49:18 <rschnck> The alphabet is {0,1}
00:49:22 <Zao> :D
00:49:25 <rschnck> :<
00:49:27 <rschnck> HMPH.
00:49:33 <rschnck> But seriously, does it look okay?
00:50:01 <rschnck> I asked #math and they told me it was a mistake to go to college, which wreaked havok on my already-crumbling-emotional-security.
00:50:16 <zenzike> it looks good to me
00:50:19 <rschnck> Yay!
00:50:42 <co_dh> for a given type , are the solution of djinn unique ? if the type has type variable only ?   for example, are const is the only solution of  a -> b -> a ?
00:50:44 <zenzike> though your first expresion could be shortened
00:51:32 <zenzike> erm. and when you said "no mor than one 1", you meant "exactly one 1" right?
00:51:36 <Zao> rschnck: I may be tired, but I can't see how a string with no ones would match.
00:51:50 <rschnck> zenzike: No, shoot.
00:52:01 <zenzike> rschnck: then you're missing an expression  :-)
00:52:03 <rschnck> I'll fix it. One second.
00:52:04 <rschnck> Yeah
00:52:37 <rschnck> 0*((00(0)*1(0)*) | (100(0)*) | (010(0)* | 00(0)*)
00:52:40 <rschnck> There?
00:52:56 <zenzike> rschnck: that works, but there's a bit of redundancy
00:53:08 <rschnck> That's because I figured it out using a DFA
00:53:26 <rschnck> How do you recommend truncating it?
00:54:16 <zenzike> well there are only 4 cases
00:54:34 <rschnck> What do you mean by class?
00:54:58 <zenzike> I mean that there are only 4 different ways where a 1 may or may not appear
00:55:13 <rschnck> Right.
00:56:39 <zenzike> I suggest you go through each one, and you'll probably come up with somethign shorter
00:56:40 <lucca> why so many parens?
00:56:42 <QtPlatypus> rschnck: Your third term is missing a closing parenthis.
00:56:56 <rschnck> QtPlatypus: it is, thanks
00:57:20 <rschnck> lucca: I know they're unnecessary...it just helps me visaulize it
00:57:52 <QtPlatypus> rschnck: All the leading 0's are redundent within the inner terms.
00:58:15 <opqdonut> not really, he wants to ensure there are at least two zeros
00:58:24 <QtPlatypus> Ag
00:58:27 <QtPlatypus> Ah
00:58:27 <opqdonut> but it is possible to write that regex without the starting 0*
00:58:30 <zenzike> it's still redundant
00:58:43 <opqdonut> yes
00:59:10 <siracusa> rschnck: And 00(0)*1(0)* | 00(0)* can be reduced to 00(0)*(1(0)*)?
00:59:12 <QtPlatypus> You can factor out the trailing (0)*
00:59:15 <lucca> 000*|000*10*|0100*|1000* or 00+1?0*|0100+|100+ with extensions.
00:59:19 <rschnck> I don't really see how to shorten it :(
00:59:27 <opqdonut> something like (000*10* | 0010* | 0100* | 1000*)
00:59:33 <opqdonut> ah, lucca beat me to it
00:59:45 <lucca> opqdonut: gotta catch the no 1 case
00:59:46 <zenzike> oh come on guys. let him come up with it himself :-)
00:59:47 <opqdonut> and I have one redundant case
00:59:58 <opqdonut> lucca: I thought it was exactly one 1
01:00:04 <rschnck> I still have others to work on, zenzike :P
01:00:21 <lucca> hmm, well we're all matching different things then
01:00:22 <lucca> heh
01:00:24 <opqdonut> zenzike: i'm not in a teaching mood
01:00:27 <QtPlatypus> 0*(001|010|100|00)0*
01:00:50 <opqdonut> QtPlatypus's is kinda neat but inefficient
01:01:10 <opqdonut> I prefer the approach in mine/luccas
01:01:15 <opqdonut> bounded backtracking
01:01:23 <ksf> regexen don't backtrack.
01:01:24 <zenzike> I was going for 000*|1000*|0100*|0010*
01:01:30 <zenzike> oops
01:01:32 <rschnck> Right.
01:01:33 <opqdonut> ksf: sure
01:01:35 <rschnck> Well, it makes sense.
01:01:36 <zenzike> I was going for 000*|1000*|0100*|0*0010*
01:01:36 <ksf> regexen get minimised.
01:01:52 <ksf> unless they're perl turexen.
01:02:04 <QtPlatypus> They are regular expressions they are mathatical objects, there not efficent or in-efficent.
01:02:18 <opqdonut> sure, I'm just funny that way
01:02:19 <QtPlatypus> regexes on the other hand.
01:02:28 <zenzike> then that's the same as (00|100|010|0*001)0*
01:02:39 <rschnck> Then 0(0|1)*0(0|1) | 1(0|1)*1(0|1) for The set of strings whose first and penultimate symbols are the same.
01:02:52 <lucca> zenzike: nope
01:03:18 <zenzike> lucco. oh?
01:03:34 <lucca> or, ah, your fourth term.  Nevermind
01:03:42 <zenzike> lucca: phew
01:03:43 <lucca> 0*00 is odd to me
01:04:01 <lucca> As many zeros as you like, then two more"
01:04:24 <lucca> o/~ I matched two 0's in the morning o/~
01:04:26 <zenzike> I like QtPlatypus' answer the most
01:05:19 <rschnck> QtPlatypus: Your answer makes the most intuitive sense
01:05:23 <zenzike> rschnck: that one isn't right
01:05:47 <rschnck> zenzike: Why not?
01:05:50 <zenzike> oh sorry. it is right!
01:05:53 <QtPlatypus> rschnck: Thankyou.
01:05:54 <rschnck> : D
01:05:55 <zenzike> I misread the expression :$
01:07:57 <QtPlatypus> If implemented correctly my one would require backtracking two steps.  Or a number of extra stages in a DFA
01:09:32 <zenzike> QtPlatypus: I think that's why I favour yours. even in my answer you need to backtrack two steps
01:14:30 <lucca> you don't need any backtracking.... heh
01:15:52 * hackagebot yesod-examples 0.5.1 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.5.1 (MichaelSnoyman)
01:17:16 <zenzike> lucca: are you sure?
01:18:18 <lucca> okay
01:18:25 <lucca> *I* don't need any backtracking.
01:18:31 <lucca> heh
01:20:37 <rschnck> For The set of strings that contain 01 as a substring an odd number of
01:20:37 <rschnck> times.
01:20:57 <rschnck> I have ((100*11*)^2)*(00*11*)
01:21:17 <rschnck> But it needs to have something prepended/appended so that it can have stuff afterwards...just not 01
01:21:23 <rschnck> Not sure how to go about doing that
01:25:16 <zenzike> rschnck: have you thought of a way of making 01 be a substring an even number of times yet?
01:25:44 <rschnck> And then make an expression that is the opposite of that?
01:25:56 <rschnck> Oh
01:26:04 <rschnck> Because you still ahve to ensure the beginning/end don't have 01s.
01:26:11 <zenzike> I was thinking more that an odd number is just an even number plus one :-)
01:26:21 <zenzike> rschnck: exactly
01:27:02 <zenzike> rschnck: or if they do, then it better be an even number of times
01:28:21 <rschnck> So for the non beginning/end I have ((0*11*0)^2)* Can you confirm that's right?
01:29:37 <rschnck> Ah, crap
01:30:01 <rschnck> I meant ((00*11*)^2)*
01:33:14 <zenzike> rschnck: what is it that you want that expression to do?
01:36:12 <rschnck> zenzike: I'm thinking verify an even # of 01s in the middle...and then on each end have a bit that ensures no 01s?
01:37:10 <rschnck> Not sure if that is what you were asking.
01:37:21 <zenzike> rschnck: oh i see. I was thinking of even + 1 + even = odd
01:38:21 <zenzike> rschnck: in other words, make sure there's an even number on either side, and make sure there's a 01 in the middle. I don't know which solution would be easiest
01:38:22 <rschnck> Right, so then ((00*11*)^2)*(00*11*) is definitely odd.
01:39:53 <rschnck> Bleh. I'm too tired. I'll finish the problem in the morning.
01:39:56 <rschnck> zenzike: Thanks for all your help.
01:40:11 <zenzike> rschnck: no probs. good luck
01:40:22 <zenzike> rschnck: and ignore what those boys at #math said
01:40:29 <rschnck> zenzike: : )
01:40:39 <rschnck> G'night.
02:14:12 * hackagebot FTPLine 1.2.0 - A command-line FTP client.  http://hackage.haskell.org/package/FTPLine-1.2.0 (DanielDiaz)
03:07:17 <donri> What corresponds to inheritance in Haskell?
03:07:41 <Jafet> What's inheritance?
03:08:21 <donri> In OOP, deriving a class inherits everything from it that you don't override.
03:08:35 <donri> Maybe it doesn't make sense in Haskell, just curious.
03:08:47 <frerich> donri: In OOP, inheritance is a mechanism for interface reuse. This is one of the many things you can do with type classes in Haskell.
03:09:07 <Starfire> Type classes can have superclasses, but it isn't the same thing.
03:09:46 <frerich> Well as usual somebody comes around and points out it's not the same thing. :-}
03:09:49 <frerich> Of course it's not.
03:09:59 <donri> Is it similar, though?
03:10:08 <frerich> Not even that. There's just a bit of overlap.
03:10:15 <dblhelix> type classes having superclasses is a bit like interface inheritance in, say, Java
03:11:06 <donri> So if you want to make a class similar to an existing class, how would you go about it?
03:11:32 <dblhelix> donri: define similar
03:11:42 <donri> dblhelix: Sounds like it is similar then? I get that Haskell classes are more like interfaces. Though admittedly I don't know Java and by extension, interface inheritance in Java.
03:12:21 <donri> dblhelix: Similar as in, adding/modifying a few capabilities but keeping most of them the same as the original?
03:12:45 <dblhelix> donri: adding isn't a problem, modifying is
03:12:56 <DrSyzygy> donri: You won't be able to override things when you declare superclasses.
03:13:16 <donri> And if you need that somehow, is there a way without copypasta the code for the original?
03:13:45 <donri> Or, is this just something you don't do in Haskell? *inexperienced*
03:13:50 <DrSyzygy> A typeclass declares that any type that wants to belong to it needs to have a certain bunch of functions implemented. Having a superclass means that you also declare that in addition to the interface you define, any type that adhers to the interface also needs to adher to that other interface over there.
03:14:31 <Jafet> I suggest you take a seat over http://paulgraham.com/reesoo.html
03:14:45 <DrSyzygy> Having different behaviours for some type in some typeclass is possible in Haskell, but it's usually done by wrapping the type in some kind of marker to show what the behaviour should be, and implementing different instances of the relevant typeclasses.
03:15:20 <DrSyzygy> Monoid has a bunch of this going on. Look at the type class wrappers All, Any, Sum, Product, First and Last.
03:17:14 <donri> Cool, easy way to look at that? In say GHCi?
03:17:29 <DrSyzygy> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Monoid.html
03:17:50 <DrSyzygy> Click one of the »source« links there and you'll see the actual implementation. 
03:19:13 <donri> Thanks
03:26:26 <ManateeLazyCat> > parseURI "http://www.google.com"
03:26:28 <lambdabot>   Not in scope: `parseURI'
03:26:41 <ManateeLazyCat> @hoogle parseURI
03:26:42 <lambdabot> Network.URI parseURI :: String -> Maybe URI
03:26:42 <lambdabot> Network.HTTP.Base parseURIAuthority :: String -> Maybe URIAuthority
03:26:42 <lambdabot> Network.URI parseURIReference :: String -> Maybe URI
03:27:31 <ManateeLazyCat> @hoogle URI -> String
03:27:31 <lambdabot> Network.URI authority :: URI -> String
03:27:32 <lambdabot> Network.URI fragment :: URI -> String
03:27:32 <lambdabot> Network.URI path :: URI -> String
03:30:03 <peterNovice> What are likely cases that a type synonym is not recognised? For me sample:: Unboxed vector double (from statistics.Sample) is not matched against a signature with unboxes vector double(Data.Vector.Unboxed).
03:32:53 <Cale> peterNovice: Could you paste the actual error message on http://hpaste.org/new ?
03:36:19 <peterNovice> Cale: it has worked before, but I upgraded with cabal and then the problems started. http://hpaste.org/40206/type_synomym_not_matched
03:37:15 <quicksilver> cabal upgrade # the command you must never use.
03:39:17 <peterNovice> quicksilver: thanks for the reply, is there a way to restore order? Do I remove and install again?
03:40:38 <Cale> peterNovice: If you've installed everything as your local user, removing .cabal and .ghc and reinstalling things is not so bad. (Just make sure to hang on to your cabal-install binary.)
03:41:07 <ivanm> Cale: just removing ~/.ghc/ should do it IIRC
03:41:08 <Cale> peterNovice: I'm just trying to work out how you got this message in the first place. It *might* be that you're using two different versions of the vector package at once.
03:41:31 <Cale> ivanm: Actually, yeah, you're probably right about that.
03:42:03 <ivanm> actually, deleting ~/.cabal/share would probably be a good thing to do as well
03:42:06 <Cale> peterNovice: Normally when there are version conflicts like that, GHC will explicitly put the name and version of the packages involved into the names of the types.
03:42:08 <peterNovice> cale: I installed it with --global, otherwise the libraries are not found
03:42:17 <ivanm> and ~/.cabal/lib
03:42:24 <ivanm> peterNovice: why are you using --global ?
03:42:28 <Cale> peterNovice: Oh, that's not really a good idea. Installing locally is supposed to work.
03:42:36 <quicksilver> Cale: my guess is that version Y of statistics.sample only works with precise versions (X1,X2 or X3) of the vector package
03:42:45 <quicksilver> Cale: ...but the cabal dependency is insufficiently precise.
03:43:16 <ivanm> peterNovice: unless you have two different users wanting the same library, etc. and want to save space, don't use --global
03:43:17 <quicksilver> (exercise for the reader is to solve for Y, X1, X2 and X3 and thus advise peterNovice on which package versions to install)
03:43:22 <ivanm> quicksilver: heh
03:44:01 <Cale> In this case though, Sample is just a type synonym: type Sample = U.Vector Double
03:44:14 <Cale> Where there's an  import qualified Data.Vector.Unboxed as U (Vector)
03:44:41 <ivanm> could be that statistics is using one version of vector and peterNovice's code is using another
03:44:46 <ivanm> but the errors for that looks rather different IIRC
03:45:02 <Cale> Yeah, hmm.
03:45:12 <ivanm> peterNovice: does "ghc-pkg check" complain about anything?
03:45:31 <ivanm> how many versions of vector does "ghc-pkg list vector" report?
03:45:49 * hackagebot data-object-yaml 0.3.2 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.2 (MichaelSnoyman)
03:45:51 * hackagebot yaml 0.4.0 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.4.0 (MichaelSnoyman)
03:46:05 <peterNovice> ivanm, nothing
03:46:44 <peterNovice> ivanm, and vector 0602 and 07
03:46:51 <ivanm> there's your problem
03:47:04 <ivanm> peterNovice: "cabal install statistics --reinstall"
03:47:12 <ivanm> (well, it _might_ be  your problem)
03:51:21 <ivanm> hmmm, bird's new book apparently comes out tomorrow...
03:51:46 <cizra> Gah! Why does this work? It shouldn't!
03:51:47 <cizra>         treeGetValue :: TreeView -> ListStore String -> String
03:51:47 <cizra>         treeGetValue v m = return 'b'
03:52:03 <cizra> ohh. hm. hey
03:52:12 <cizra> It's lifting 'b' into the List monad. I should have written IO String.
03:52:44 <ivanm> heh
03:52:46 <cizra> Thanks for the inspiration (=
03:52:54 <geheimdienst> also, 'b' is a Char, not a String ...
03:53:08 <dblhelix> cizra: yeah, ad-hoc polymorphism sometimes can be, ... well, ... pretty ad-hoc ;-)
03:53:41 <ivanm> geheimdienst: I think that was his complaint ;-)
03:53:52 <cizra> yeah
03:55:20 <peterNovice> ivanm: sorry to bother you again, which directory should I use with ghic -i<dir> so that my locally installed modules are found. I think it was this problem that once lead me to utilize the --global switch with cabal.
03:55:44 <ivanm> you shouldn't have to
03:55:50 <ivanm> if you're using ghci under the same user
03:56:12 <quicksilver> ghci -i is used for non-installed modules, things which are not packages.
03:56:24 <quicksilver> properly installed packages are found automatically because there is a package database
03:57:14 <geheimdienst> (... which you can view with "ghc-pkg list")
03:57:20 <quicksilver> you should never use ghci -i with stuff you installed with cabal.
03:58:00 <quicksilver> ghci autoloads all packages; when compiling you need "ghc --make" which automatically loads those packages your source code needs.
03:58:33 <peterNovice> quicksilver: the modules are not found :), and I use ghci
03:58:42 <ivanm> I only use ghci -i to load the Paths_*.hs module Cabal creates
03:58:52 <ivanm> peterNovice: how do you know they are not found?
03:59:01 <ivanm> does "ghc-pkg list" show the libraries?
03:59:56 <peterNovice> ivanm, heh ghc-pkg list shows the libraries but in ghci I get "Could not find module `Statistics.Sample'"
04:00:33 <peterNovice> perhaps some environment variable is not  set
04:00:53 <ivanm> no environment variables
04:01:27 <quicksilver> peterNovice: what are you typing to get that output "Could not find module `Statistics.Sample" ?
04:01:45 <ivanm> peterNovice: "ghc-pkg field statistics exposed-modules"
04:04:18 <peterNovice> Wow all this help is ovewhelming, thanks. quicksilver for instance :m Statistics.Sample or :l the program I wrote. ivanm Statistics.Sample is exposed
04:05:11 <ivanm> I wonder if statistics is hidden...
04:05:24 <ivanm> peterNovice: when you do "ghc-pkg list statistics", is it in braces or something?
04:06:39 <peterNovice> ivanm,no braces. For me it has always been this way with all installed modules. That was why I started using --global
04:06:49 <ivanm> what architecture are you using?
04:06:56 <ivanm> do you have a ~/.ghci file with weird stuff in it?
04:07:06 <ivanm> how about doing something like ":module +Data.List" ?
04:07:09 <peterNovice> ivanm: fedora 13 x64
04:07:35 <peterNovice> ivanm: global modules work without problems
04:07:59 <ivanm> might be something weird with your config then
04:08:12 <ivanm> have you heavily customised your ~/.cabal/config ?
04:08:12 <peterNovice> ivanm: no ~/.ghci
04:08:52 <peterNovice> perhaps the missing ~/.ghci is the culprit
04:09:13 <ivanm> no, that's not a problem
04:09:19 <ivanm> it just means you don't ahve anything funky there
04:11:15 <peterNovice> ivanm: could I try and set some path explicitly with ghic -i<dir>
04:11:33 <ivanm> probably not
04:12:52 <peterNovice> Well thank you all! That was why I was using --global. Perhaps I should try cabal reinstall --global statistics
04:13:19 <quicksilver> two versions of GHC perhaps?
04:13:31 <quicksilver> "ghci" is finding one but "cabal" is finding a different one?
04:15:08 <peterNovice> quicksilver, not that I know of, and nothing double in usr/bin or with which ghci/ghc
04:32:15 <Maxdamantus> Hm. Is tail recursion optimisation actually something important to have in Haskell? It seems like it would be perfectly functional without it.
04:32:28 <Maxdamantus> other than for say.. foldr
04:32:43 <Maxdamantus> afaics you'd need to use seq/whatever in most cases of it
04:32:49 <Cale> Maxdamantus: It's sort of meaningless
04:32:50 <Maxdamantus> useful cases*
04:33:23 <quicksilver> Cale: well, it's still meaningful for foldl'-type loops
04:33:23 <Cale> The mechanism for evaluating Haskell in GHC is totally different from the mechanism used to evaluate strict languages.
04:33:26 <quicksilver> and still useful.
04:33:44 <Cale> The stack isn't used for the same thing at all.
04:34:18 <Maxdamantus> Mmm.. But I think you can still think about TCO in Haskell, not just in GHC
04:34:27 <Cale> (so it's not really "the" stack as it were)
04:34:30 <Maxdamantus> f x = f x
04:34:51 <Cale> Maxdamantus: Lazy evaluation works outermost-first
04:35:13 <Cale> So, here's what normally happens when you evaluate something like foldl (+) 0 [1,2,3]
04:35:20 <Cale> foldl (+) 0 [1,2,3]
04:35:27 <Cale> -> foldl (+) (0+1) [2,3]
04:35:33 <Cale> -> foldl (+) ((0+1)+2) [3]
04:35:36 <Maxdamantus> Yeah, I know.
04:35:39 <Cale> -> foldl (+) (((0+1)+2)+3) []
04:35:42 <Cale> -> ((0+1)+2)+3
04:35:48 <Maxdamantus> Which is why foldr is more useful for that
04:35:57 <Cale> Not really for this example
04:36:02 <Cale> Up to this point, no stack has been used.
04:36:16 <Maxdamantus> > foldl (+) 0 [1..]
04:36:24 <lambdabot>  Terminated
04:36:26 <Maxdamantus> Ah.
04:36:44 <donri> Is Haddock docs on Hackage built by the uploader or the system?
04:36:45 <Cale> It's evaluating the expression ((0+1)+2)+3 which requires use of GHC's stack.
04:36:48 <Maxdamantus> > foldr (+) 0 [1..]
04:36:53 <lambdabot>   mueval: ExitFailure 1
04:37:10 <Cale> donri: Both, working together? :)
04:37:23 <Maxdamantus> But it's using seq to avoid depending on the stack
04:37:38 <Jafet> That's foldl'.
04:37:39 <Cale> donri: The haddock docs are built by the system based on comments in the code placed there by the programmer who uploaded the package.
04:37:48 <Jafet> > foldl' (+) 0 [1..]
04:37:52 <lambdabot>   mueval-core: Time limit exceeded
04:38:01 <Cale> Maxdamantus: seq just helps avoid building up a large expression which will later require stack
04:38:03 <donri> Cale: Because e.g. base is built with the older and less beautiful 2.6 but stemmer with 2.8, although the latter itself has not been touched in a long time
04:38:31 <donri> Cale: I mean is the docs built by Hackage or by the uploader (uploading the HTML as well)
04:38:35 <Cale> Maxdamantus: The evaluation of the foldl doesn't use any stack to begin with, just space on the heap to hold the expressions which are being constructed.
04:38:46 <Cale> donri: Built by Hackage.
04:38:56 <donri> So howcome base is built with an old version?
04:39:03 <Maxdamantus> > let f n = n + f (n + 1) in f 1
04:39:04 <lambdabot>   *Exception: stack overflow
04:39:16 <Cale> donri: It depends on the order in which it builds things, I guess. I'm not sure.
04:39:46 <Cale> donri: Check that the latest version of the involved packages successfully built on Hackage. There will be a build log if there was a failure.
04:39:56 <geheimdienst> donri, the new look came out maybe one or two weeks ago. it's just changing over now
04:40:12 <Maxdamantus> Oh, so it is wasting space, just not on the stack?
04:40:34 <Maxdamantus> (For the foldl)
04:40:51 <donri> Cale: http://hackage.haskell.org/packages/archive/base/4.2.0.2/logs/failure/ghc-6.12 relevant?
04:40:52 <Cale> Maxdamantus: Yeah. The stack represents case expressions and other pattern matches which are waiting for their scrutinee to be sufficiently evaluated to match.
04:41:17 <Cale> Maxdamantus: You can think of (+) as needing to pattern match both of its arguments to be able to evaluate to a result.
04:41:31 <Cale> (like a huge doubly-nested case expression)
04:41:47 <Maxdamantus> Okay, right, yeah, GHC doesn't use the stack like most implementations of imperative languages do.
04:41:49 <donri> How can latest base fail to build on latest ghc o_O
04:42:05 <Cale> donri: Oh, the choice of base package is just dependent on which version of GHC is installed.
04:42:21 <Cale> donri: Each version of base is tied to a specific GHC.
04:43:02 <Cale> (Actually, perhaps the story is a little more complicated than that, but that's pretty much true)
04:43:24 <donri> So http://hackage.haskell.org/package/base-4.2.0.1 has not failed but also is built with an old haddock?
04:44:07 <Cale> donri: Well, I don't really know, but perhaps, yes.
04:44:33 <Cale> Wow, it's odd to see an empty dependencies field on Hackage ;)
04:44:36 <donri> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Prelude.html "Produced by Haddock version 2.6.1"
04:44:57 <donri> Cale: Nah you need base to install base. OMG RECURSION
04:47:37 <Cale> donri: base-4.2.0.2 at least is the right version for ghc 6.12.3
04:48:08 <Cale> I think the build log is ignorable in this case, as the haddock did get built successfully.
04:48:48 <donri> So this is a mystery?
04:49:11 <donri> Why can't all package docs be built with the same Haddock though?
04:49:25 <Cale> Because they're not all built at the same time?
04:49:51 <donri> But the docs for stemmer is built with a Haddock released long after stemmer was released last time.
04:50:00 <Cale> hmm
04:51:36 <geheimdienst> donri, the new look just came out a short time ago ... 2 weeks or something. they didn't re-run haddock on bazillions of packages, clogging the servers, just for cosmetic reasons
04:51:38 <Cale> I think base is a special case, since its construction is part of the construction of ghc. I think perhaps what's happening is that whatever automatic process updates the package documentation isn't being applied to base, or is failing on base.
04:52:03 <geheimdienst> it will all smooth out over the next couple of weeks. don't worry too much about the look
04:52:04 <Cale> Both of those would be totally unsurprising to me.
04:52:25 <donri> geheimdienst: So why is this old stemmer package built with the new Haddock?
04:52:31 <Cale> If we look at the build log for base, it gets stuck pretty early on:
04:52:45 <Cale> GHC/Constants.hs:7:0:
04:52:45 <Cale>      error: ../../../compiler/stage1/ghc_boot_platform.h: No such file or directory
04:52:45 <Cale> GHC/Constants.hs:9:0:
04:52:45 <Cale>      error: ../../../includes/HaskellConstants.hs: No such file or directory
04:54:01 <Cale> So I think what's happening is that whatever automatic process is rebuilding packages won't be able to rebuild base on its own. That will require reinstalling GHC.
04:54:02 <geheimdienst> i don't know. maybe the haddock is being rebuilt from oldest package to newest
04:55:30 <donri> Ah.
04:55:59 <donri> So they are running Haddock on the bazillion packages? :)
04:56:22 <Cale> They're probably just installing them all with documentation turned on.
04:56:45 <Cale> and if installation fails for whatever reason, then the docs don't get built
04:57:05 <geheimdienst> possibly they decided against hogging the servers for days, but that a background job consuming 20% of the cpu is fine ... i don't know
04:57:28 <Cale> geheimdienst: The base package is a special case
04:57:33 <donri> You both make sense, thanks
04:57:47 <Cale> I think they really do compile everything.
04:59:38 <donri> But other old but newer than stemmer packages are also still built with an old Haddock
04:59:53 <donri> So I think geheimdienst is on to something.
05:01:21 <donri> Hackage should match the new Haddock look (itself based on the wiki?)!
05:02:09 * hackagebot HTab 1.5.4 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/HTab-1.5.4 (GuillaumeHoffmann)
05:07:30 <om-foxy> how is it possible to get: 
05:07:32 <om-foxy> lib/Numeric/Signal.hs:56:39:
05:07:34 <om-foxy>     Not in scope: type constructor or class `Νum'
05:07:47 <om-foxy> isn't that part of the Prelude?
05:09:47 <sepp2k> om-foxy: It is. You can get that error if you only included part of Prelude or you included it qualified.
05:10:41 <om-foxy> import Prelude hiding(filter)   -- ???
05:12:52 <zygoloid> om-foxy: that should certainly bring in Num :o
05:13:27 <zygoloid> om-foxy: can you paste the code (at hpaste.org or similar)?
05:21:31 <donri> What's an easy and efficient way to persist values?
05:21:57 <Jafet> hPutStr
05:21:59 <adu> donri: you mean accross reboots?
05:22:07 <adu> ya, files
05:22:13 <donri> Across program exit and restart
05:22:35 <donri> Is there no module for serializing values efficiently?
05:22:44 <zygoloid> there's Data.Binary
05:23:15 <Absolute0> Whats the best algorithm to find the median of 5 integers?
05:23:17 <maurer_> http://hackage.haskell.org/package/cereal
05:23:21 <zygoloid> what properties do you want the serialization to have? (human-readable? human-writable? backwards-compatible across changes to your code?)
05:23:34 <maurer_> Absolute0: Look up the "select" family of algorithms
05:23:46 <adu> i dunno about you, but my favorite is JSON
05:23:51 <Jafet> (!!3) . sort
05:23:59 <donri> zygoloid: Easy and efficient writing/reading
05:24:14 <zygoloid> Absolute0: how are you going to judge which is best? fastest? most readable?
05:24:14 <Absolute0> maurer_: i know about the median of medians, all the articles briefly explain the sorting aspect
05:24:24 <Absolute0> zygoloid: fastest
05:24:45 <Absolute0> i think its just selection sort and then A[i]
05:24:51 <Absolute0> A[3]
05:25:01 <ivanm> Absolute0: that's the best I can think of
05:25:06 <zygoloid> donri: well, the easiest thing is probably derived Read and Show, but that's not particularly efficient
05:25:12 <Absolute0> so selection sort is best for 5 integers?
05:25:28 <ivanm> Absolute0: for 5 integers, does it really matter?
05:25:33 <maurer_> Absolute0: Not selection sort, but select. Also, for 5 integers, it doesn't really matter
05:25:36 <ivanm> it's going to be O(n log n)
05:25:39 <Absolute0> 5^2 > 5*log2(5)
05:25:41 <ivanm> > 5 * log 5
05:25:41 <maurer_> Using selection sort then selecting the middle is n log n
05:25:43 <lambdabot>   8.047189562170502
05:25:45 <zygoloid> for 5 integers you could hard-code the exact decision tree; that should be pretty much optimal
05:25:45 <maurer_> Using select is log n
05:26:31 <zygoloid> maurer_: only if you force the whole thing. selection sort then selecting the middle should be O(n) if done lazily enough.
05:26:45 <Jafet> You just need custom pipelined sorting hardware and it's amortized O(1)
05:26:52 <maurer_> err, my bad, O(n), not O(log(n))
05:26:54 <zygoloid> (not that O-notation matters if the list is exactly 5 elements long)
05:26:58 <maurer_> O(log(n)) is expected with some
05:27:01 <donri> zygoloid: Data.Binary looks good, thanks
05:27:10 <adu> zygoloid: hehe
05:27:21 <maurer_> zygoloid: Yes, but I assume he's not stating the whole problem, as if there are 5 numbers, you can just write down a compact decision tree
05:27:31 <zygoloid> donri: i think there are packages which do derivation of the instances using th, that might make it easier
05:27:41 <donri> Oh, cool
05:28:06 <maurer_> zygoloid: Ah, that makes sense. Haskell's laziness would turn ((!! n) . sort) into O(n)
05:28:19 <maurer_> (which is really cool)
05:28:40 <zygoloid> maurer_: that's a common claim, and needs some qualification. it depends on the implementation of sort, but the Prelude sort has that behaviour.
05:28:53 <zygoloid> (at least, iirc...)
05:29:20 <maurer_> zygoloid: Thinking about it, for _most_ sorts I'd expect this behavior.
05:29:42 <zygoloid> i vaguely recall that (rnf . take k . sort) is O(n + k log n)
05:29:56 <Jafet> Where O is a large, unspecified number
05:30:15 * hackagebot moe 2010.9.29 - html with style  http://hackage.haskell.org/package/moe-2010.9.29 (JinjingWang)
05:30:47 <zygoloid> maurer_: a "correct" quicksort (which works via an intermediate array) probably won't have that behaviour
05:31:21 <Jafet> Squicksort
05:31:49 <zygoloid> in fact i think the naive "quicksort" doesn't give you O(n) for (!!n) . sort, because building the spine isn't independent of the sorting
05:32:14 <co_dh> @djinn a -> ( a-> ())
05:32:15 <lambdabot> f _ _ = ()
05:33:13 <donri> zygoloid: http://hackage.haskell.org/package/binary-generic ?
05:33:29 <co_dh> what's the terminal object of Category Fun(type as object, function as arrow )  in haskell ? 
05:33:48 <co_dh> I know it's a set of one element 
05:34:23 <co_dh> does that means [1] is a terminal object , so does [2]?
05:35:03 <co_dh> but undefined belongs to all set , ... so I'm confused , 
05:35:17 * hackagebot moe 2010.9.29.1 - html with style  http://hackage.haskell.org/package/moe-2010.9.29.1 (JinjingWang)
05:35:21 <Saizan> what are [1] and [2] there?
05:35:42 <co_dh> :t [1]
05:35:53 <lambdabot> forall t. (Num t) => [t]
05:35:55 <Saizan> singleton lists?
05:35:59 <co_dh> yes.
05:36:13 <Saizan> then they can't be the terminal object, they are not objects in that category
05:36:33 <maurer_> Is there any way to make a faster version of Data.Graph's buildG if I allow use of the IO or ST monad?
05:36:49 <co_dh> so data T = T is a terminal object .
05:36:52 <co_dh> right ? 
05:36:56 <Saizan> type are objects, e.g. Char, (), Bool, Either () Bool
05:36:58 <zygoloid> sort [] = []; sort [a] = [a]; sort (a:as) = withLengthOf as (sort [b | b <- as, b < a] ++ [a] ++ [b | b <- as, b >= a]); withLengthOf (a:as) ~(b:bs) = b:withLengthOf as bs; withLengthOf [] _ = []
05:37:05 <zygoloid> ^^ this should give O(n) for (!!n) . sort
05:37:14 <zygoloid> (!!k) . sort rather
05:38:17 <Saizan> co_dh: seq messes things up, but other than that i'd think so
05:38:37 <ivanm> maurer_: I highly doubt it
05:38:42 <zygoloid> donri: that's unlikely to be as fast as TH-derived instances, but is probably fine in practice
05:38:42 <co_dh> ok, thanks.
05:38:47 <ivanm> maurer_: I don't remember buildG being slow though...
05:38:49 <ivanm> @hoogle buildG
05:38:50 <lambdabot> Data.Graph buildG :: Bounds -> [Edge] -> Graph
05:38:51 <lambdabot> Data.Graph.Inductive.Graph buildGr :: DynGraph gr => [Context a b] -> gr a b
05:39:06 <donri> zygoloid: I don't find a package using TH
05:39:26 <ivanm> maurer_: but you'd have to create your own fork of Data.Graph if you wanted to use a different underlying Array
05:39:30 <zygoloid> donri: http://community.haskell.org/~ndm/darcs/derive/derive.htm
05:39:36 <ivanm> maurer_: any particular reason for not using FGL?
05:40:23 <maurer_> Nevermind, buildG is going fast, I was misprofiling
05:40:29 <ivanm> heh
05:40:43 <maurer_> ivanm: I'm not using FGL because I'm running my own algorithms, and noticed my hand equivalent of buildG was a bottleneck
05:40:59 <ivanm> I used my own algorithms with FGL as well...
05:41:15 <ivanm> if you're changing the size of the graph at all, then Data.Graph is extremely inefficient
05:41:16 <maurer_> I swapped in buildG, and turned on profiling. It was still taking too long, but it turns out that was just profiling overhead
05:41:25 <ivanm> heh
05:41:28 <maurer_> ivanm: The graph size does not change. It's a register allocator
05:41:34 <ivanm> yes, look at the profiling statistics ;-)
05:41:38 <ivanm> maurer_: *shrug*
05:41:41 <maurer_> I did :) Now I'm happy.
05:42:02 <ivanm> I suppose Data.Graph gives you O(1) lookup, whereas the inbuilt FGL graphs have O(log n)
05:42:07 <maurer_> Now the main cost center is my coloring algorithm, as it should be.
05:42:30 <maurer_> ivanm: Let's put it this way--n is big enough that I needed to build a heap in IO that supported increase key.
05:42:38 <maurer_> (for one aspect of the algorithm)
05:42:43 <maurer_> I should really port that back to ST though.
05:42:44 <ivanm> what do you mean?
05:42:51 <Twey> Hmm… the highlighting on the HaskellWiki is broken (thinks --> is a comment)
05:42:59 <co_dh> you can use 1 in type declaration as   f :: Int -> 1 
05:43:00 <maurer_> Data.Heap and all the other heaps I can find do not support increaseKey
05:43:05 <co_dh> what's the element in 1 ? undefined ? 
05:43:13 <ivanm> Twey: someone is working on a new one
05:43:18 <ivanm> can't recall who though...
05:43:27 <ivanm> they just pasted a link here yesterday
05:43:38 <ivanm> maurer_: I mean what are you doing that you need IO/ST
05:43:41 <maurer_> ivanm: It's not clean, but http://hpaste.org/40208/io_heap
05:44:01 <ivanm> what is that for?
05:44:25 <maurer_> I wanted the increaseKey operation. Functional heaps don't seem to support that, and I'm guessing with good reason.
05:44:40 <maurer_> (I thought about it a while myself and couldn't figure out how to get increaseKey into a functional heap)
05:44:46 <ivanm> so what does this have to do with Data.Graph ?
05:45:16 <maurer_> Nothing. It's used in a graph coloring algorithm that operates on the graph produced by Data.Graph's buildG
05:45:39 <maurer_> I also used buildG because my code already used Array Int [Int] to hold the interference graph so it was an instant optimization
05:45:57 <ivanm> why do you need an external heap though?
05:46:19 <ivanm> and why did you start with Array for a graph?
05:47:31 <maurer_> ivanm: The algorithm is to generate a simplicial elimination ordering. Basically, I have weights corresponding to each node. I extract the node with maximum weight. Then, I increment the weights of all its neighbors, and recurse until there are no more nodes.
05:48:06 <maurer_> ivanm: I previously tried both an Array and a Map there, and the updates on those were too slow. I tried an STArray next, but the Max operation was too slow.
05:48:30 <ivanm> how were you using the Array and Map that it was slow?
05:48:41 <maurer_> The same way that STArray would be slow.
05:48:47 <ivanm> well, I suppose the only efficient way of doing it would be to have a Map Weight Node
05:48:58 <ivanm> make that "Map Weight (Set Node)" or something
05:49:14 <ivanm> otherwise you'd have to do something like maximum . Map.elems
05:49:19 <maurer_> ivanm: How would you efficintly "increment all neighboring nodes weights" ?
05:49:32 <maurer_> ivanm: (I was doing something similar to that, which was the slow part)
05:50:19 <ivanm> maurer_: you need an efficient neighbours function
05:52:18 <maurer_> ivanm: That's what the interference graph was for (the Array Int [Int])
05:52:31 <maurer_> The problem is that doesn't let me do a backwards indexing on the map.
05:52:40 <ivanm> *cough* FGL *cough*
05:52:45 <ivanm> "backwards indexing" ?
05:52:51 <ivanm> Data.Graph has no concept of weights!
05:52:58 <maurer_> I didn't use Data.Graph anywhere
05:53:02 <maurer_> Other than for buildG
05:53:24 <maurer_> bacwards indexing meaning you suggested Map Weight (Set Node) instead of a heap
05:53:46 <maurer_> Say I have a set of nodes whose weights I'd like to increase--how will I find theM/
05:53:51 <maurer_> *them
05:54:01 <maurer_> It's possible fgl would make this much easier, and I'll read up on it.
05:54:08 <ivanm> maurer_: except your Array has no concept of the weight in the graph
05:54:16 <ivanm> FGL has node and edge labels
05:54:45 <ivanm> the NodeMap stuff apparently gives you the backwards map, but I believe it assumes a 1-1 mapping between node and weight
05:54:48 <ivanm> which wont' be the case for you
05:55:04 <ivanm> so if you want that extra efficiency, you'd need to take care of that yourself
05:55:45 <maurer_> Yeah, and since the _only_ operations that I do are simplicial elimination ordering and coloring, and the extra efficiency in simplicial is the only place I broke into Heapland...
05:55:52 <maurer_> Whatever, does not much matter. It works now.
05:55:59 <maurer_> Code cleaning pass is next :P
06:14:44 * cizra is taking immense pleasure in building a GTK app with Haskell.
06:24:44 <jkff> Hi all. What has happened to the Extra-Source-Files field of Cabal? (1.8.0.2) I need to include a .h file into my sdist, but Extra-Source-Files seems non-existent anymore and listing it under Include-Dirs or Includes doesn't help (it doesn't appear in sdist)
06:24:52 <jkff> What should I use instead?
06:25:16 <benmachine> pretty sure extra-source-files still exists
06:25:43 <benmachine> doublecheck you're not mistyping it or something :)
06:26:09 <jkff> Oh
06:26:16 <jkff> I put it into the wrong place in the .cabal file
06:28:23 <jkff> As a side question: if I included a modified source from a GNU program into my package, does the package also have to use the GNU license?
06:28:36 <jkff> And does everyone who uses it also have to use GNU?
06:28:52 <jkff> I mean, who uses my package unmodified
06:29:25 <benmachine> jkff: I think the GPL is infectious
06:29:34 <quicksilver> if your package is a derived work of a GPL program then it has to be distributed under the GPL
06:29:37 <zygoloid> jkff: it depends what you do with it in your package.
06:29:44 <PeakerWork> benmachine: Like a spider flower :)
06:30:02 <quicksilver> that's not quite the same as saying you have to have that license on all your source code, but you have to have some license compatible with it.
06:31:43 <jkff> Actually that's code from the GNU C library, modified in GNU R and now modified again in my library.
06:32:27 <jkff> Is there a way to not force anyone who uses my library to open-source his program? (my library is open-source though)
06:32:51 <Vanadium> Do not license your library under the GPL
06:33:05 <Ke> GPL is awesome
06:33:24 <Vanadium> glibc is LGPL, is it not.
06:33:29 <Vanadium> That is a bit different from GPL
06:33:30 <Ke> but depending on your goals not suitable for everything
06:33:36 <jkff> I might just publish it and wait until someone complains, but that doesn't seem the right way :)
06:33:47 <zenzike> my company is considering migrating from SVN to something distributed: is darcs stable enough to consider as a candidate, and is there a gui interface (lots of our developers can't live without tortioise svn, or similar)?
06:34:05 <cizra> zenzike: I would suggest Mercurial with TortoiseHg
06:34:20 <cizra> zenzike: Note that I don't know almost anything about Darcs, so I'm biased.
06:34:46 <zenzike> cizra: hehe, I'm asking here because i assumed that there'd be some darcs advocates hanging around :-)
06:35:10 <copumpkin> jaspervdj: you around?
06:35:25 <Ke> to my experience darcs is a bit buggy, but might be better now
06:35:38 <Ke> it's slow too, but quite easy to use even on cli
06:35:40 <ManateeLazyCat> Ke: buggy?
06:36:36 <Ke> mostly problems with haskell overlay, but not entirely due to the crashing apache
06:36:38 * hackagebot strptime 0.1.5 - Efficient parsing of LocalTime using a binding to C's strptime  http://hackage.haskell.org/package/strptime-0.1.5 (EugeneKirpichov)
06:36:40 * hackagebot instant-generics 0.2.1 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.2.1 (JosePedroMagalhaes)
06:37:34 <Ke> overlay as in gentoo overlay
06:38:56 <Entroacceptor> isn't there a standard function List.unique??
06:39:23 <ari> Entroacceptor: Do you mean nub?
06:39:38 <Entroacceptor> yes...
06:39:39 <ari> > nub [1, 2, 3, 2]
06:39:41 <lambdabot>   [1,2,3]
06:39:42 <Entroacceptor> silly, silly name
06:39:53 <Entroacceptor> thank you
06:40:36 <rothwell> any way to get a better error than "Maybe.fromJust: Nothing"? apparently made an assumption i shouldn't have, somewhere...
06:41:02 <quicksilver> well, one way is never to use fromJust...
06:41:16 <quicksilver> (for this reason)
06:41:27 <benmachine> even doing basically the same thing with let Just x = m in x is slightly better
06:41:41 <quicksilver> I think you might be able to use some CPP trick to turn fromJust into an error with line number
06:41:42 <rothwell> benmachine: good point...
06:41:49 * ManateeLazyCat pasted "maybeError" at http://paste2.org/get/1009323
06:41:50 <ManateeLazyCat> rothwell: If you want one, ^^^^
06:42:02 <rothwell> ManateeLazyCat: thanks
06:42:03 <ManateeLazyCat> rothwell: You can add some string to track error.
06:42:12 <cizra> ManateeLazyCat: <3
06:42:24 <ManateeLazyCat> rothwell: My suggestion, don't use fromJust or my paste. :)
06:43:02 <copumpkin> preflex: xseen jaspervdj 
06:43:02 <preflex>  jaspervdj was last seen on freenode/#haskell 3 days, 3 hours, 32 minutes and 38 seconds ago, saying: chrisdone: I'm porting formlets to blaze-html so you won't need both xhtml and blaze in the future
06:46:35 <ManateeLazyCat> preflex: xseen juhp
06:46:35 <preflex>  juhp was last seen on freenode/#ghc 7 days, 4 hours, 25 minutes and 49 seconds ago, saying: JaffaCake: thanks - seems better now
06:46:53 <ManateeLazyCat> preflex: xseen juhp_
06:46:53 <preflex>  juhp_ was last seen on freenode/#haskell 3 days, 45 minutes and 32 seconds ago, saying: ManateeLazyCat: heh, manatee app generator :)
06:52:37 <peterNovice> When you run "ghc-pkg field XXX exposed modules" does it just check the conf files in .ghc/<version>/package.conf.d or does it also check the files referred to, say  .cabal/lib/<library>/<version>/?
06:53:24 <Saizan> just the conf files
06:54:47 <peterNovice> Saizan: sorry I have bothered lots of people with questions about why ghc and ghci cannot find some exposed modules
06:54:51 <JoeyA> is it possible to overload function application? (so if I wanted to, I could make (Just 5) 3 work)
06:55:08 <ManateeLazyCat> Saizan: Have you push "print unused package" patch? :) I use hbuild remove unused packages manually yesterday. :-(
06:55:58 <Saizan> ManateeLazyCat: no
06:56:18 <benmachine> JoeyA: no
06:56:36 <JoeyA> thanks, that's what I thought.
06:56:38 <benmachine> JoeyA: you could overload e.g. $ though
06:56:47 * hackagebot sequor 0.2 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.2 (GrzegorzChrupala)
07:00:11 <cizra> ManateeLazyCat: gtk widget set state function is missing
07:00:22 <cizra> ManateeLazyCat: (or at least I didn't find any way to enbale/disable a button)
07:01:01 <cizra> ManateeLazyCat: ohh! Sensitivity is what I wanted! Never mind then.
07:01:10 <ManateeLazyCat> cizra: :)
07:04:15 <manateeUser> 看了很多比较darcs和git的文章， 还是用
07:04:26 <ManateeLazyCat> Sorry, wrong type. :)
07:10:04 <Ke> why is this syntax error foreign import ccall "m" "sin" sin :: Double -> IO Double
07:10:48 <Lemmih> Ke: -XForeignFunctionInterface?
07:11:19 <Ke> {-# LANGUAGE ForeignFunctionInterface #-} is not sufficient?
07:11:46 <Ke> nope, did not help
07:12:02 <Ke> the syntax error is at "sin"
07:12:32 <Ke> http://users.tkk.fi/~jkarlson/codes/testi.hs
07:12:34 <Lemmih> Ke: Are you sure the "m" thing is allowed?
07:12:50 <benmachine> I don't think the "m" thing is allowed
07:13:11 <Lemmih> Ke: Shouldn't it be "m sin"?
07:13:13 <Ke> Lemmih: well I am reading the "spec", so it would seem to ve
07:13:28 <Ke> http://www.haskell.org/hdirect/ffi-4.html
07:13:40 <Ke> ext_fun with 2 strings
07:14:00 <Ke> it even has an example
07:14:35 <Lemmih> Ke: Use this instead: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
07:14:50 <Ke> =o(
07:15:02 <Ke> my spec is easier =o(
07:15:06 <Ke> !
07:15:53 * hackagebot collada-output 0.1 - Generate animated 3d objects in COLLADA  http://hackage.haskell.org/package/collada-output-0.1 (TillmannVogt)
07:15:54 <Ke> I would really need better spec browser
07:19:57 <Ke> apparently you can't include linking info in the source
07:22:39 <byorgey> good morning #haskell!
07:22:49 * byorgey makes blueberry-lambda pancakes for everyone
07:23:07 <atude> gross
07:23:25 <atude> I do want food however
07:23:26 <copumpkin> I'd eat them
07:23:36 <geheimdienst> pancakes are okay as breakfast
07:23:44 <atude> not really
07:23:52 <byorgey> well, YOU don't have to eat any ;)
07:23:54 <atude> that's like having chocolate cake for breakfast :(
07:24:00 <geheimdienst> just give me your pancake and quit bitching :)
07:24:05 <atude> fuck you
07:24:09 <jaspervdj> copumpkin: ping!
07:24:38 <zygoloid> byorgey: morning! i assume this salutation means you're no longer in the UK? ;(
07:24:45 <copumpkin> jaspervdj: did my message get through to the hakyll mailing list?
07:24:48 <byorgey> atude: let's tone down the language, please
07:24:52 <Entroacceptor> good morning
07:24:59 <Entroacceptor> byorgey
07:24:59 <benmachine> morning is a relative term
07:25:02 <copumpkin> oh wow
07:25:05 <copumpkin> atude: yeah, please
07:25:07 <Entroacceptor> well, it's late afternoon here
07:25:13 <atude> byorgey: what about geheimdienst ? I was just playing along D:
07:25:13 <byorgey> hi zygoloid! yes, I'm back in the US
07:25:17 <dblhelix> Entroacceptor: good afternoon then :)
07:25:22 <Ke> yay
07:25:23 <geheimdienst> atude, no offense taken
07:25:27 <byorgey> geheimdienst: you too
07:25:32 <atude> all set :)
07:25:48 <zygoloid> byorgey: apologies for the confusion yesterday! how's the datakinds stuff going?
07:25:50 * copumpkin eats some (water) buffalo mozzarella
07:26:06 <benmachine> mozarella <3
07:26:07 <jaspervdj> copumpkin: Yes, I haven't had time to reply though
07:26:08 <atude> copumpkin: o_o
07:26:11 <byorgey> zygoloid: no worries.  It will theoretically be going great once I get back to working on it.
07:26:23 <jaspervdj> copumpkin: I'm not sure if this would happen best on Hakyll or Pandoc level
07:26:30 <zygoloid> haha, yeah, i'm right there on my "top priority" spare-time project
07:26:51 <copumpkin> jaspervdj: my issue with pandoc is that it seems hardcoded to take the kate highlighters, and there's not a chance in hell of getting kate to parse agda
07:26:53 <byorgey> zygoloid: things have been insane for the past few weeks starting up this haskell course I'm teaching and writing two talks for the Haskell Symposium and Haskell Implementors' workshop
07:28:18 <copumpkin> jaspervdj: I guess I could just lie and pretend agda is haskell, since superficially the syntax is pretty similar
07:28:27 <jaspervdj> copumpkin: Well use can arrows in hakyll to perform an arbitrary transformation on the body
07:28:49 <jaspervdj> copumpkin: But you'd have to write some sort of highlightAgda :: String -> String
07:29:18 <jaspervdj> which applies agda highlighting on all lines starting with >
07:29:30 <copumpkin> hm
07:29:41 <jaspervdj> then you'd have something like, erm, transform = renderMarkdown . highlightAgda
07:30:07 <copumpkin> well, the matter is further complicated by the fact that you can only highlight agda once it's typechecked, so the information lives within agda's typechecking monad
07:30:36 <copumpkin> but I could unsafePerformIO it I guess :)
07:30:43 <copumpkin> since it's a wrapper around IO as far as I can see
07:31:09 <copumpkin> I'd expect syntax highlighting to be fairly referentially transparent
07:31:51 <ray> unless it's C++
07:31:52 <copumpkin> is there a way I can haev highlightAgda spit out html directly? since they have a function for that
07:32:08 <jaspervdj> copumpkin: yeah, the String can contain HTML
07:32:12 <copumpkin> ah okay
07:32:23 <jaspervdj> copumpkin: and you can use IO in hakyll arrows, so that's no problem
07:32:29 <copumpkin> ah cool
07:33:17 <copumpkin> the other question is how to give highlightAgda the entire >-delimited source, since it's actually typechecking it, I can't just give it lines in isolation
07:35:04 <peterNovice> Is it safe to install a specific newer version of a package as --user, than what is in the global libraries. How does the priorities for import go global<user older<newer? Or are older automatically unregistered?
07:36:18 <benmachine> peterNovice: local libraries take precedence over global libraries always
07:37:17 <jaspervdj> copumpkin: hmm, I see
07:38:01 <copumpkin> seems kind of hard, really, since once I get the highlighted stuff back, I need to stick all the non-code text back in between
07:38:56 <benmachine> typeInformation = typeCheck (drop 2 . filter ("> " `isPrefixOf`)) lines?
07:39:14 <benmachine> then highlight with the type information
07:40:07 * hackagebot moe 2010.9.29.2 - html with style  http://hackage.haskell.org/package/moe-2010.9.29.2 (JinjingWang)
07:40:13 <benmachine> add a concat . in there
07:40:37 <copumpkin> the issue is retaining the mapping from the typechecker/highlighter to the original lines it came from
07:41:57 <benmachine> do you have to typecheck and highlight simultaneously? can't you just gather all the information from the typecheck you need, and then highlight with it afterwards?
07:42:39 <benmachine> you pretty much have to do two passes anyway, right?
07:42:51 <copumpkin> well, they have a simple interface to the highlighting
07:42:58 <copumpkin> which saves me from doing much :P
07:45:03 <benmachine> aavogt: if it interests you, I merged a few of my patches into my haskell-src-meta github (it even recognised your account as the author :O) http://github.com/benmachine/haskell-src-meta
07:47:09 * hackagebot maid 2010.9.29 - A simple static web server  http://hackage.haskell.org/package/maid-2010.9.29 (JinjingWang)
07:47:44 <benmachine> aavogt: do you know where mmorrow's original darcs repository is, btw?
07:47:53 <copumpkin> it was on his site, which went offline
07:47:56 <copumpkin> :(
07:48:02 <benmachine> ohh yes he said
07:48:11 * benmachine silly
07:48:13 <benmachine> oh well
07:48:13 <copumpkin> there was a lot of good stuff on there
07:48:18 <benmachine> mm
07:49:03 <benmachine> no-one's called him yet?
07:49:11 <copumpkin> feel free to :)
07:49:25 * benmachine claims exemption on the grounds of international call rates
07:49:33 <copumpkin> same here
07:49:57 <Entroacceptor> with skype it's actually okay
07:52:13 <Entroacceptor> but it's darcs... noone got a copy?
07:53:06 <benmachine> well, aavogt got a copy
07:53:20 <benmachine> it's possible it might not have been up to date
07:53:23 <benmachine> but we don't know
07:56:20 <roconnor> yep
07:57:10 <gwern> a copy of what?
07:57:50 <pumpkin> mmorrow's repositories
07:58:31 <gwern> I probably have a couple
07:58:39 <benmachine> oh, I just meant haskell-src-meta repository
07:58:42 <gwern> let's see, for haskell-src-meta-th, my last patch is 'Fri Oct 30 01:18:21 EDT 2009  Matt Morrow <morrow@moonpatio.com>
07:59:14 <gwern> since my cron jobs pull every repo weekly, this shouldn't be missing very much
07:59:17 <benmachine> yeah, that's the last mmorrow patch I have
08:00:12 <rschnck> I'm trying write an expression that uses only standard languageoperations (union, cat, *) that describes the set of binary stringsthat contain 01 as a substring an odd number of times.
08:00:28 <rschnck> I have ((00*11*)^2)*(00*11*) so far which guarantees the "middle" ofthe string to have an odd # of 01s
08:00:36 <rschnck> But I'm unsure how to gurantee that anything ni front of or behind that  has no 01s.
08:00:53 <rschnck> Should I just create a DFA that guarantees no 01s and append that to the begnning and front of it?
08:00:59 <rschnck> oops, to the front and end*
08:01:05 <rschnck> So prepend/append.
08:01:57 <gwern> [10:59 AM] 0Mb$ find . -name "repos" -exec grep moonpatio.com {} \;;
08:01:58 <gwern> http://moonpatio.com/repos/luna
08:01:59 <gwern> http://moonpatio.com/repos/haskell-src-meta_NEW_TH
08:02:05 <gwern> I had less than I thought I did
08:06:32 * fryguybob is headed to Baltimore...
08:06:53 <pumpkin> say hi to Omar for me
08:11:18 * hackagebot hack-contrib 2010.9.28 - Hack contrib  http://hackage.haskell.org/package/hack-contrib-2010.9.28 (JinjingWang)
08:12:26 <Psychotix> hello ppl i'm interested in haskell developing, where to start?
08:13:02 <Saizan> @where lyah
08:13:02 <lambdabot> http://www.learnyouahaskell.com/
08:13:13 <Saizan> @where rwh
08:13:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:14:35 <rothwell> omar comin'!
08:14:42 <Psychotix> 10x
08:17:06 <sproingie> i would highly recommend reading lyah before rwh
08:17:28 <mreh> and the typeclassopedia
08:17:34 <pumpkin> no
08:17:40 <sproingie> in fact i would recommend knowing a good deal of haskell before rwh because it gets very confusing
08:17:42 <mreh> after
08:17:47 <Ke> why does not ghc know calling convention cplusplus
08:18:07 <pumpkin> Ke: there are a bunch of different ones, mangling schemes, and so on
08:18:09 <sproingie> "C++ convention" is an oxymoron
08:18:29 <Ke> but it's listed here http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-100003
08:18:49 <pumpkin> I guess whoever wrote that assumed c++ had a single convention
08:19:35 <dolio> It doesn't have dotnet or jvm, either, I think.
08:19:36 <Ke> so what do I use on my GNU/linux system with g++-4.5.1
08:19:46 <pumpkin> http://en.wikipedia.org/wiki/Name_mangling#Standardised_name_mangling_in_C.2B.2B
08:20:16 <pumpkin> Ke: you either hardcode your mangled c++ names, or write a wrapper that exports extern "C" symbols
08:20:42 <mreh> in State's instance of MonadFix, are the semantics "take the old state and pass it to the next iteration etc."
08:21:19 <Saizan> MonadFix is not about iterations
08:21:20 * hackagebot timeplot 0.1.7 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.1.7 (EugeneKirpichov)
08:21:27 <mreh> it's value recursion
08:22:45 <Saizan> mfix f = State $ \s -> let (a, s') = runState (f a) s in (a, s') -- it doesn't do anything special with the state
08:22:47 <mreh> I'm trying to decompose it into usage with fix, but I end up discarding the state
08:24:30 <Saizan> mfix f = State $ \s -> fix (\ (~(a,_)) -> runState (f a) s)
08:26:16 <aristid> @src State mfix
08:26:16 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:27:20 <mreh> it's right
08:27:34 <mreh> just working through the decompositionn though
08:31:34 <pumpkin> kmc: omg
08:31:52 <mreh> Saizan: the use of fix doesn't type check in my head
08:32:24 <pumpkin> kmc: thanks for the binding!
08:32:49 <pumpkin> kmc: btw, you should get on twitter ;)
08:33:04 <Saizan> mreh: (\ (~(a,_)) -> runState (f a) s) :: (a,s) -> (a,s)
08:33:17 <mreh> oh yes
08:34:22 <mreh> that rather mucks things up, I wanted to derive MonadFix from State for Rand
08:34:34 <mreh> infact that's how it is defined in MonadRandom
08:39:03 <cobra> hello
08:43:45 <Ke> pumpkin: doesn't seem to help though
08:44:20 <Ke> pumpkin: used http://developers.sun.com/solaris/articles/mixing.html with the ifdef-trick and c++-code links fine
08:45:00 <Ke> pumpkin: nvm, forgot to commit
08:47:48 <Ke> still not working
08:49:43 <Ke> http://users.tkk.fi/~jkarlson/files/fdsclientlib.h and http://users.tkk.fi/~jkarlson/codes/testi.hs
08:50:06 <Ke> (.text+0x5b): undefined reference to `FDS_connect'
08:50:39 <quicksilver> how did you link it?
08:51:05 <Ke> ghc --make -lm -lfdsclient testi.hs
08:54:42 <quicksilver> did the c_sin experiment work?
08:55:29 <Ke> quicksilver: yes
08:58:13 <ManateeLazyCat> Have a haskell library extract meta-data from image? Such as size, orientation....
08:59:01 <ManateeLazyCat> Have some C library do that, i just wonder have haskell library do that. :)
08:59:16 <Ke> apparently it doesn't compile with c code either, so that header trick didn't cut it
08:59:20 <Ke> hmm
09:01:01 <quicksilver> Ke: you just invented that header?
09:01:04 <quicksilver> well that doesn't work.
09:01:13 <quicksilver> you have to actually *write* the functions.
09:02:45 <Ke> quicksilver: I just modified the header and not the actual source ;o)
09:02:54 <Ke> thanks, seems to compile now
09:04:05 <Ke> it even works \o/
09:04:21 <Ke> thanks for all, I suck
09:05:29 <Ke> actually the library is 99% C99, but it has some silly features that didn't compile with -std=c99
09:07:03 <Ke> like  int aa[4]={non constant expressions}
09:11:50 <quicksilver> what's silly about that is that anybody ever considered a language which doesn't permit that.
09:12:16 <quicksilver> it's actually one of the things that most annoys me about C, the inability to write expressions of complex type
09:13:48 <tommd> ManateeLazyCat: There are a number of image libraries on Hackage that probably can do that.
09:14:02 <ManateeLazyCat> tommd: Name?
09:15:08 <tommd> ManateeLazyCat: Look at Devil, hsmagik, and ImLib
09:15:16 <tommd> One of those should suit.
09:15:25 <tommd> Devil is the most complete.
09:15:45 <monochrom> remember that they were the same people who considered a language to cognitive-dissonantly permit user-defined functions with alphanumeric names but not user-defined functions with symbolic names.
09:16:21 <ManateeLazyCat> tommd: I need get "size (pixel)" and "orientation" from image file, not just extract information from exif/iptc, also support raw image....  
09:16:51 <zygoloid> monochrom: wow, it took me three runs at that before i got a successful parse ;)
09:17:37 <monochrom> this is why english needs scoping
09:17:46 <benmachine> I kind of think haskell's operator definitions have the worst cost-benefit of any of its features, though
09:18:10 <benmachine> I was thinking about this in relation to haskell-src-exts' fixity parsing, and how much of a giant mess it was >_>
09:18:24 <zygoloid> huh, i kind of think they're the best operator overloading mechanism in any language i've experienced
09:18:31 <benmachine> oh, perhaps
09:18:42 <benmachine> but just because every other language is even more awful... :P
09:18:55 <zygoloid> which is to say, if we're both right, then the rest of haskell is /awesome/
09:18:59 <benmachine> :D
09:19:01 <benmachine> natch
09:19:03 <zygoloid> i'm not seeing a contradiction with this line of reasoning :)
09:19:08 <benmachine> yeah
09:19:09 <ManateeLazyCat> tommd: Your paste libraries can't do that, but thanks anyway. :)
09:19:13 <benmachine> I wasn't necessarily saying they were bad
09:19:34 <benmachine> just a bit headachey sometimes
09:19:44 <ManateeLazyCat> tommd: Infact, libextractor is cool, just have too many depend package need install...
09:20:24 <tommd> ManateeLazyCat: 1) That was a fast rejection for looking at three libraries worth of Haddock docs.  2) What's the problem with build deps?  That's what cabal-install is for.
09:20:43 <tommd> ManateeLazyCat: Does magick not have what you need?  Even the partial bindings seem to have lots of image info (http://hackage.haskell.org/packages/archive/hsmagick/0.4/doc/html/Graphics-Transform-Magick-Types.html#t:HImageInfo)
09:22:05 <donri> LYAH: “That apostrophe doesn't have any special meaning in Haskell's syntax.” Uh, Char?
09:22:40 <donri> Ah I read “That” as “The”.
09:23:30 <monochrom> > let oleg'case'example = 'x' in oleg'case'example:'y':"z"
09:23:31 <lambdabot>   "xyz"
09:24:49 <gwern> benmachine: one thing I dislike is being 1+1 being the same as 1 + 1
09:25:11 <gwern> benmachine: it means haskell is that much further away from sh; 'c++' no longer works as a identifier
09:25:39 <ManateeLazyCat> tommd: Yep, you're right, hsmagick looks can pick meta-data i need, try to test.... thanks for link... :)
09:26:15 <donri> gwern: Same is true for - right?
09:26:16 <benmachine> gwern: why is being far away from sh a problem :P
09:26:28 <gwern> benmachine: because it makes a haskell shell that much harder
09:26:32 <benmachine> ah
09:26:36 <gwern> heck, forget sh. just binarie names
09:26:39 <Twey> gwern: Agree (though not with the motivation)
09:26:50 <benmachine> I want a haskell-based shell
09:26:50 <donri> My favourite naming convention is - between words, but few languages support it.
09:26:55 <benmachine> but it wouldn't be haskell exactly
09:27:13 <benmachine> agda demands whitespace everywhere
09:27:22 <donri> Twey: (No, not between Lojban particles!)
09:27:22 <benmachine> and then lets you call things ==-commutativity
09:27:26 <Twey> Requiring spaced operators makes code clearer and also drastically increases the namespaces for operator and value identifiers alike
09:27:27 <monochrom> there are shells which consider "c+d" an identifier?
09:27:32 <Twey> donri: :þ
09:27:48 <donri> u'i+nai
09:28:01 <monochrom> I guess there are. but remember they are the same shell which don't support "c + d" as an expression.
09:28:38 <benmachine> p.s. commutativity : commutes :: transitivity : ?
09:28:38 <sproingie> COMMON-LISP-NAMING-CONVENTIONS-ARE-THE-BEST-AND-NOT-AT-ALL-VERBOSE
09:29:07 <donri> monochrom: Bash considers prefix* either a literal string or a sequence of matching files, depending on whether there are matching files.
09:29:08 <monochrom> JavaIsBetterException
09:29:29 <benmachine> bash is ugh
09:29:29 <sproingie> javaNamesAreGood
09:29:34 <sproingie> CeeSharpNamesLessSo
09:29:43 <gwern> monochrom: sure. try ls /usr/bin/|grep '+'
09:29:45 <donri> i'd-like-identifiers-like-this-one
09:29:56 <gwern> c++filt
09:29:56 <gwern> dvd+rw-booktype
09:29:56 <gwern> dvd+rw-format
09:29:56 <gwern> dvd+rw-mediainfo
09:29:59 <sproingie> #|or like this one|
09:30:04 <gwern> g++-4.1
09:30:04 <gwern> g++-4.4
09:30:10 <gwern> man, haskell would hate that
09:30:16 <zygoloid> (Haskell's_naming_system.It_lets_you_combine_the_'best'_bits_from_other_languages.!)
09:30:24 <gwern> I mean, that's three different infix operators there
09:30:27 <sproingie> zygoloid: just-not-this-bit
09:30:48 <donri> how—about—some—unicode?
09:30:56 <sproingie> the explosion of infix operators in haskell can also be pretty horrifying
09:31:03 <sproingie> because you cant have anything alphanumeric in them
09:31:08 <zygoloid> sproingie: i like being able to write sin (x-pi)
09:31:08 <donri> (Talk about messing with the reader.)
09:31:09 <sproingie> unless you use `foo`
09:31:09 <gwern> make-memtest86+-boot-floppy
09:31:13 <gwern> is pretty vbad too
09:31:21 <geheimdienst> so in a haskell shell, the characters that must be escaped are a little different from those in regular shells. big deal?
09:31:22 <sproingie> zygoloid: i suppose there is that
09:31:31 <benmachine> a lot of the common symbols are reserved, too
09:31:36 <benmachine> like ,[]{}
09:32:01 <sproingie> what scala does is neat, any method taking one arg can be written infix.  wouldn't work for haskell of course
09:32:18 <monochrom> notice how nicely in «grep '+'» you have to quote the +, confessing that it is a string not operator for the shell. (it is only an operator for grep, not shell)
09:32:19 <donri> When people realize they like a programming language, they tend to get the idea to use it for a system shell. It is almost always a bad idea.
09:32:32 <geheimdienst> one arg infix?
09:32:37 <donri> Existing shells are optimized for their purpose.
09:32:50 <sproingie> geheimdienst: "foo bar baz" parses as "foo.bar(baz)"
09:32:50 <benmachine> donri: yes but badly :P
09:33:23 <sproingie> geheimdienst: makes sense for a top-to-bottom OO thing like scala which runs on the JVM.  i guess with haskell we have to live with backticks
09:33:25 <geheimdienst> sproingie: i see. so the object on which it's called is like another argument
09:33:35 <donri> benmachine: Agreed; fish is a nice shell that tried to change that. Sadly it's far from perfect.
09:33:38 <gwern> donri: I think scsh and the baroque features of zsh show that there is advantage to a 'real' shell
09:33:46 <gwern> donri: the same argument could've been made against xmonad
09:34:00 <sproingie> geheimdienst: well in OO that's theoretically the case, but in single-dispatch languages like java, not really
09:35:07 * ManateeLazyCat cn99.com down .... switch source....
09:35:10 <sproingie> not sure how scala parses "foo bar baz mumble frotz".  i suspect it doesn't at all
09:35:29 <donri> gwern: Programs like xmonad tend to need to be scriptable; it's not really wrong to do it the way it does. A shell however is something you enter commands in daily, it's not a source file you maintain like a config.
09:35:55 <gwern> donri: you punch commands into a tiling wm daily too
09:36:02 <sproingie> i just wish the shell weren't so stupid that "foo = bar" doesn't work
09:36:18 <donri> gwern: Hm, example? I don't use xmonad.
09:36:21 <sproingie> (has to be foo=bar)
09:36:31 <gwern> donri: what do you think each keybinding is/
09:36:43 <donri> Yea that's a binding. That's not entering Haskell code in some prompt.
09:36:49 <benmachine> are we suggesting here a shell written in haskell, or a shell that *is* haskell?
09:36:58 <monochrom> bourne shell and c are very old things
09:36:59 <benmachine> ignore the first one
09:37:03 <donri> I'm not arguing against implementing a shell *with* Haskell. I'm arguing against implementing a shell *as* Haskell.
09:37:12 <benmachine> a shell *inspired* by haskell, or a shell that *is* haskell, maybe
09:37:25 <benmachine> because who cares what your shell is written with >_>
09:37:40 <monochrom> "haskell doesn't convey the shell. haskell is the shell" :)
09:37:50 <benmachine> one thing that could be a drawback with a haskell shell though is that the bash interpreter is probably more lightweight that the haskell runtime
09:38:03 <donri> benmachine: If you want to hack on it, or maybe it'd be extendable in Haskell which might be more efficient/powerful than a shell script of that shell.
09:38:29 <benmachine> donri: those are relatively minor concerns in my view
09:38:46 <donri> Agreed.
09:39:14 <donri> How about a shell with... no side effects!
09:39:18 <donri> Every command is a noop!
09:40:26 <gwern> benmachine: trying to take bash's niche is futile. the target would be zsh
09:40:34 <gwern> which isn't lightweight, I don't think
09:40:49 <benmachine> gwern: it depends what you think of as bash's niche
09:40:56 <gwern> 12M if I'm interpreting apt-cache right
09:41:34 <gwern> benmachine: I think of it as the default universal shell good for most people; zsh being the serious shell scripters and powerusers
09:41:40 <benmachine> gwern: I meant how ghc -e 'return ()' takes 0.2 seconds to finish
09:42:14 <gwern> benmachine: presumably any serious script in a haskell shell is easily turned into a regular compiled program
09:42:21 <benmachine> mmm probably
09:42:30 <gwern> at least, I'd want it designed that way
09:42:33 <benmachine> I thought that was RTS startup time but it isn't
09:42:35 <gwern> kind of like xmonad
09:42:36 <benmachine> it's GHC startup time
09:42:45 <benmachine> which is allowed to be big :P
09:42:56 <benmachine> but yeah runhaskell is slow too I think
09:43:00 <gwern> you can compile a static binary and thenceforth be independent of xmonad/xmonadcontrib/ghc
09:43:24 <benmachine> having to compile your scripts might be seen as a downside in a scripting language
09:43:42 <gwern> never said you *had* to compile them. xmonad can be run interpreted
09:43:58 <benmachine> well, you don't mind xmonad's startup time so much
09:44:07 <mee> emacs lisp sets a precedent for this, you can optionally compile for speed
09:44:11 <benmachine> but during my system startup it seems to execute about a billion shell scripts
09:44:25 <benmachine> if each of those takes 0.2 seconds minimum my startup time balloons
09:44:58 <gwern> no one uses zsh for their startup
09:45:11 <gwern> and at least one project tries to replace them with python scripts
09:45:16 <benmachine> mm
09:45:27 <benmachine> I'd like to replace them with haskell scripts!
09:45:36 <benmachine> so I think we're talking about different aims
09:45:40 <benmachine> your aim is good too :P
09:46:05 <gwern> my point being that python isn't famous for speed, yet it was still an improvement
09:46:14 <gwern> hence it seems more likely that haskell could be an improvement too
09:46:33 <benmachine> python is a simpler language with a smaller runtime, I'd hazard
09:46:35 * benmachine tests something
09:46:35 <gwern> hence even though a haskell shell wouldn't be aimed at startup, startup is not an objection
09:47:16 <benmachine> ok so maybe my objection is specifically with runhaskell being slower than it needs to be
09:48:03 <gwern> a mere constant factor
09:48:35 <benmachine> when the constant factor is greater than the entire runtime of your actual script, then... :P
09:48:44 <gwern> still a constant!
09:48:55 <benmachine> true
09:49:01 <gwern> I would suggest profiling GHC, but I'm not sure runhaskell or ghci are profilable
09:49:03 <geheimdienst> that reminds me. i gotta "script" that starts with #!/usr/bin/runhaskell. will that be compiled and cached somewhere, or compiled everytime i run it?
09:49:25 <benmachine> using runhaskell basically loads your file into ghci and runs it
09:49:33 <gwern> so no cache
09:49:46 <benmachine> maybe if you had a .o file nearby...
09:49:51 <benmachine> but no no cache
09:50:02 <geheimdienst> i see. thanks
09:50:36 <maurer_> gwern: You can either have compilation, which is per machine, in which case you might as well drop a binary there, or have a bytecode compilation (what other scripting languages with caches like you're talking about) via yhc or similar
09:50:58 <maurer_> s/about/"about do"/
09:51:34 <benmachine> I wonder if you could compile to core, and if that'd be significantly faster to execute
09:51:55 <benmachine> I mean, if you could do that without any significant hacking on anything
09:52:04 <maurer_> benmachine: Does ghc have an option for ignoring its core translation phase?
09:52:13 <maurer_> If so, this is easy. Otherwise it's potentially hard.
09:52:15 <benmachine> I dunno
09:53:18 <maurer_> I can't find one.
09:53:41 <maurer_> The awkward thing here is that while I'm not sure, GHC likely has a separate data structure for "Haskell" and "Core Haskell", and the latter may not have a parser
09:54:01 <benmachine> mm, true
09:54:37 <maurer_> benmachine: Also, why wouldn't yhc bytecoding be what we want here?
09:55:15 <benmachine> maurer_: umm, because I've never worked with yhc >_>
09:55:16 <maurer_> The only purpose to not compiling Haskell code seems to be portability and bootstrapping. This isn't bootstrapping so...
09:55:46 <benmachine> so it probably would, in other words
09:55:47 <maurer_> benmachine: Slower than ghc, more cleanly written for the most part, has the ability to compile to bytecode which it executes in a VM
09:56:14 <benmachine> oh good
09:56:24 <benmachine> sounds like fun
09:56:37 <maurer_> The bad part is it doesn't support the full suite of language extensions ghc does
09:57:12 <benmachine> well, who does? :P
09:57:19 <maurer_> Amusingly, it can also target javascript.
09:57:31 <fizruk_> hi all! does anybody know some papers about using GADTs for representing structure of an imperative program? Particularly, I have problems with representing types.
09:57:33 <benmachine> hah, awesome
09:58:12 <fizruk_> s/Particularly/Also/
09:58:13 <maurer_> fizruk_: Be more specific?
09:58:40 * maurer_ is confused as to why a GADT would be required or even useful in this case.
09:58:47 <maurer_> Though I'm quite possibly missing something.
09:59:19 <dstcruz> What is the use of the Reader monad? how is it different from just passing a value?
09:59:46 <dstcruz> I thought a value cannot be changed, kinda like the env in a Reader monad cannot be changed?
10:00:10 <benmachine> maurer_: this is what google has to say on yhc: http://www.haskell.org/pipermail/yhc/2010-April/001246.html
10:00:20 <benmachine> (not strictly speaking google but google and a few links)
10:01:13 <fizruk_> maurer_: hm.. the first problem is in representing compound statements. wait... I'll be back with some code :)
10:01:54 <pumpkin> fizruk_: what would you use the GADT for there? in typical syntax representations of functional languages your index is the type of the expression, but imperative languages don't have a single expression
10:02:29 <maurer_> dstcruz: You want sequential reads is an example. One sec while I whip up some code that may help
10:03:10 <maurer_> benmachine: Awkward. Last time I used it was about a year ago, but it worked (for haskell98) then
10:05:21 <maurer_> dstcruz: Nevermind. Rather than using code, instead just think of it as a case where you have n functions that all need to be able to access the same, non-mutating structure
10:05:34 <maurer_> You don't want to add an additional parameter to EVERY function.
10:05:52 <maurer_> You also don't want to have to pass the variable manually
10:05:53 <dstcruz> so, they all need access to some env
10:05:59 <maurer_> For example, yes.
10:05:59 <fizruk__> pumpkin: imperative languages have expressions too, and I need to typecheck them
10:06:06 <dstcruz> wouldn't I need to pass the env to each of them?
10:06:24 <maurer_> dstcruz: That's the whole point, you wouldn't need to
10:06:28 <benmachine> dstcruz: if it helps, Reader r a is basically the same as r -> a
10:06:28 <pumpkin> fizruk__: sure, but then it behaves the same was as an expression in a regular functional language, ignoring effects
10:06:32 <pumpkin> fizruk__: what's different?
10:07:05 <fizruk__> pumpkin: also, I want to typecheck "returns" in function body
10:07:40 <dstcruz> so, how do these functions see the env, if it was not passed to them? by using "ask"?
10:08:03 <benmachine> yes
10:08:19 <benmachine> it was passed to them, but it was done so implicitly by the Monad machinery
10:08:29 <benmachine> and by runReader, eventually
10:09:02 <maurer_> http://hpaste.org/40216/reader_example
10:09:13 <dstcruz> so, I don't have to pass the value to them, but if I need the value, I need to "ask" for it.
10:09:19 <maurer_> In that case it wouldn't be too terribly useful, but you can imagine many more foo and bar
10:09:45 <benmachine> maurer_: you meant bar a, right?
10:09:59 * dstcruz wow, hpaste has changed looks!
10:10:02 <maurer_> benmachine: Yeah, sorry, just typed some stuff for structure
10:10:17 <benmachine> dstcruz: yes, basically - but it's important to understand the value is still being passed, it's just that the Reader monad does it for you
10:10:24 <maurer_> dstcruz: Intention is that you only put ask in a few functions, and make accessing functions (for good form)
10:10:45 <rschnck> For the set of binary strings that contain 01 as a substring an odd number oftimes, does this regular expression correct?(00*|1*0*)*((00*11*)^2)*(00*11*)(00*|1*0*)*
10:10:55 <rschnck> is this regular expression correct*
10:11:13 <Zao> rschnck: If only there were an off topic channel for everything not Haskell.
10:11:20 <Zao> rschnck: Like say, #haskell-blah :D/win 30
10:11:24 * Zao fails at IRC :D
10:11:53 <rschnck> Zao: It's SORT-OF related. And I got loads of help here yesterday.
10:11:57 <rschnck> Figured I'd try my luck again.
10:12:02 <maurer_> rschnck: Why do you want to use a regex?
10:12:11 <benmachine> rschnck: (00*|1*0*)* matches everything
10:12:13 <rschnck> maurer_: It's just a intro to comp assignment.
10:12:30 <dstcruz> maurer_, benmachine: thanks for the help.  Back to seeing how I can put this to use.
10:12:33 <Zao> benmachine: I hear that zero-width matches are cool.
10:12:37 <rschnck> benmachine: Huh?
10:12:49 <maurer_> So you're asking a language channel for assistance with your homework, and claiming it's on topic?
10:12:55 <benmachine> rschnck: it matches everything that (0|1)* would match
10:12:57 <Zao> 1*0* is zero-width. Kleening a zero-width pattern always succeeds, forever.
10:12:59 <benmachine> i.e. everything :)
10:13:19 <benmachine> ooh wait
10:13:24 <benmachine> Zao's right
10:13:28 <benmachine> one or more nothings match
10:13:31 <benmachine> er
10:13:33 <benmachine> zero or more
10:13:33 <rschnck> maurer_: No one disputed this yesterday.
10:13:46 <maurer_> In any case, you likely mean + in may places you wrote *
10:13:49 <Zao> Assuming your language is just {0,1} though, it'll always consume something until eos.
10:13:55 <benmachine> rschnck: strictly speaking this is not the place to ask, but usually people won't complain because we've got nothing better to do
10:14:02 <rschnck> benmachine: There we go. :D
10:14:23 <benmachine> rschnck: if the channel was busy we'd be more picky
10:14:43 <benmachine> rschnck: also, it *is* generally speaking a good idea to tell people if you're doing something for homework purposes
10:14:45 <maurer_> Yeah, sorry about that. Just a little bit of old anger from hanging out in some other channels where people would constantly come in essentially asking us to help them with homework.
10:15:13 <rschnck> Wait. I wrote the function so that (00*|1*0*) is all binary strings that don't contain 01, and ((00*11*)^2)*(00*11*) is simply an odd # of 01s
10:15:16 <benmachine> maurer_: it's understandable, but #haskell has a reputation for low anger quotient and I like to keep it that way :)
10:15:24 <rschnck> Expression, not function*
10:15:31 <rschnck> I'm mixing up all my words today =/
10:15:44 <benmachine> rschnck: you're being careless with your *s I think
10:15:44 <maurer_> rschnck: So, let's reduce this.
10:16:00 <maurer_> First note that we will match a strictly smaller set of strings if I remove an or clause
10:16:09 <maurer_> We now look at
10:16:13 <maurer_> (1*0*)*
10:16:23 <maurer_> Now note that 1*0* matches 1
10:16:27 <maurer_> And matches 0
10:16:29 <rschnck> and 10
10:16:33 <maurer_> So we can reduce to
10:16:38 <maurer_> (1|0)*
10:16:44 <rschnck> Oh
10:16:45 <rschnck> Neat :D
10:16:46 <maurer_> So the first term will consume all input
10:16:58 <maurer_> The later terms, being *'d terms, will accept the empty input
10:17:08 <rschnck> Wait
10:17:13 <rschnck> What do you mean by the first term will consume all input
10:17:16 <benmachine> actually there's one non-* term
10:17:26 <benmachine> rschnck: it will match any string
10:17:50 <maurer_> benmachine: No, there are no other starred terms
10:17:53 <maurer_> err, non-starred
10:17:54 <rschnck> Erm. What do you mean by that?
10:18:15 <maurer_> There's another parenthesized thing that isn't starred, but the interior terms are starred
10:18:20 <rschnck> "match any string"?
10:18:34 <pumpkin> write an enumerator for your regex
10:18:36 <rschnck> How does the first term alone match any string.
10:18:37 <maurer_> A regex is said to match a string iff the state machine which represents it would accept
10:18:40 <pumpkin> and check if it looks good :P
10:18:40 <maurer_> Oh
10:18:45 <maurer_> That's what you were asking
10:19:06 <maurer_> Let's walk through this slowly
10:19:10 <rschnck> Okay.
10:19:20 <maurer_> (00*|1*0*)*((00*11*)^2)*(00*11*)(00*|1*0*)*
10:19:35 <rschnck> Right. My silly, presumably incorrect attempt.
10:19:41 <maurer_> Now, do you agree that if I remove all the terms other than the first one, we will only accept strings you would have accepted before?
10:19:52 <rschnck> Yes.
10:19:57 <maurer_> OK, now we are at
10:19:59 <rschnck> But the set of accepted strings is now smaller.
10:20:02 <maurer_> (00*|1*0*)
10:20:07 <maurer_> Yes, but I will show it is the set of all strings
10:20:08 <zygoloid> rschnck: you're using a valid approach, and it's reasonably close to being right
10:20:23 <rschnck> zygoloid: Thanks for the reassurance.
10:20:29 <maurer_> And if the set of all strings is potentially smaller than what you accept, you accept all strings
10:20:43 <rschnck> Yes.
10:20:56 <maurer_> Now, do you agree that we will only accept strings in the original language if I remove the 00*| ?
10:21:29 <rschnck> As in, you'll accept all binaries?
10:21:33 <rschnck> Oh wait
10:21:34 <rschnck> Nevermind.
10:21:38 <maurer_> Also, just a note, I missed a star earlier
10:21:39 <rschnck> I'm unsure what you're asking.
10:21:43 <maurer_> (00*|1*0*)*
10:21:45 <zygoloid> rschnck: you're right that (00*|1*0*) is all binary strings that don't contain 01. but you don't want to apply * to that, since that will match 00 followed by 11000, which does contain 01
10:21:45 <maurer_> was what I meant
10:22:07 <rschnck> zygoloid: Oh, right. =[
10:22:25 <rschnck> maurer_: So if you removed 00*| you'd have (1*0*)*?
10:22:30 <maurer_> Yeah
10:22:37 <maurer_> Which is all binary strings
10:22:59 <rschnck> It's hard for me to see that (1*0*)* is all binaries.
10:22:59 <maurer_> So since your current regex accepts everything this does, it accepts all binary strings
10:23:06 <maurer_> Umm, OK, we'll step through this
10:23:16 <maurer_> Does 1*0* match 1?
10:23:20 <rschnck> Yes.
10:23:21 <maurer_> Does 1*0* match 0?
10:23:23 <rschnck> Yes.
10:23:25 <rschnck> Oh
10:23:28 <rschnck> Okay nevermind xD
10:23:28 <benmachine> :P
10:23:43 <rschnck> Then you can get (0|1)* = all binaries
10:23:45 <rschnck> Right-o.
10:23:49 <benmachine> maurer_: what about the (00*11*) term? the one that isn't squared
10:23:56 <rschnck> So my machine accepts just a *tad* too much.
10:24:17 <maurer_> benmachine: Oh, I misread that as (00)*(11)*
10:24:23 <benmachine> mm
10:24:33 <benmachine> use of + would be nice here if it's allowed
10:24:41 <rschnck> Only standard operations.
10:24:44 <rschnck> Concat, union, *
10:24:59 <benmachine> yeah but + is just sugar anyway :P
10:25:02 <benmachine> x+ = xx*
10:25:23 <rschnck> We haven't gone over it yet, I'd rather not for now
10:25:27 <benmachine> k
10:25:35 <rschnck> Especially since I want to see how to solve this using the most basic operations possible
10:25:38 <rschnck> To see if I even understand.
10:25:41 <benmachine> mm
10:29:16 <rschnck> Hey, sorry. Wifi died.
10:29:24 <benmachine> you didn't miss anything
10:29:36 <rschnck> So (00*|1*0*) is indeed all binaries that don't contain 01. How do I go *ing that..without getting all binaries?
10:29:49 <benmachine> why would you want to * it?
10:29:55 <rschnck> Oh
10:30:12 <rschnck> Well I'm describing 000000000 and 111110000
10:30:15 <rschnck> Oh wait
10:30:16 <rschnck> Right.
10:30:16 <benmachine> yep
10:30:20 <rschnck> Silly me.
10:30:23 <benmachine> your internal stars take care of that fine
10:30:24 <benmachine> but
10:30:30 <benmachine> there's a simpler solution, even
10:30:45 <benmachine> I mean think of the first regex that matches the two examples you just gave :P
10:30:53 <benmachine> the first that comes into your head
10:31:05 <rschnck> 1*0*?
10:31:26 <benmachine> first of all, can that contain 01?
10:31:33 <rschnck> No.
10:31:37 <benmachine> second of all, can any string that doesn't contain 01 fail that match?
10:31:46 <rschnck> Nope.
10:31:50 <rschnck> I don't think...
10:32:02 <benmachine> well then!
10:32:07 <rschnck> Lovely!
10:32:10 <benmachine> :P
10:32:21 <rschnck> So now for the odd 01 bit.
10:32:24 <rschnck> Is what I have totally wrong?
10:32:27 <benmachine> no
10:33:01 <Jonno_FTW> @check x^2 + y^2 == z^2
10:33:03 <lambdabot>   "Falsifiable, after 0 tests:\n"
10:33:07 <benmachine> I don't in fact know if it's wrong at all now we've fixed the first bit
10:33:22 <rschnck> (1*0*)((00*11*)^2)*(00*11*)(1*0*)...?
10:33:51 <benmachine> there's stuff that you don't need to bracket in there
10:34:06 <benmachine> otherwise I think it's right, but I'm no expert
10:34:39 <rschnck> I'll get confirmation from my prof prior to handing it in
10:34:43 <rschnck> But thanks for all the help
10:34:56 <rschnck> And um, one more question.
10:35:06 <maurer_> Oh man, I didn't know lambdabot had quickcheck
10:35:23 <rschnck> This is an unrequired "challenge" question...so I thought it'd be much more difficult, but it was easy with aDFA...which leads me to think I mucked it up
10:35:41 <shapr> lambdabot has many toys!
10:35:48 <rschnck> The set of strings over the alphabet {a, b, c} that don’t con-tain ab as a substring. I got epsilon | (b | c)* | a* | aa*c(b|c)*
10:36:03 <maurer_> rschnck: If it gets too messy, you can just be lazy and grab an algorithm for converting DFAs to regexes (as they recognize the same languages)
10:36:36 <rschnck> maurer_: How exactly would you goa botu doing that?
10:36:41 <rschnck> I've been using DFA for the other problems
10:36:48 <rschnck> But I just go through them and write them out step by step to get the regex
10:36:56 <benmachine> rschnck: ba isn't accepted by that regex, is it?
10:37:33 <maurer_> http://lmgtfy.com/?q=convert+dfa+to+regular+expression
10:37:53 <rschnck> maurer_: Thanks ;_;
10:38:00 <rschnck> benmachine: Shoot. 
10:38:10 <rschnck> So the fact that it's wrong results from an error in my DFA, right?
10:38:15 <rschnck> Or an error of me transcribing it
10:38:27 <maurer_> Most likely.
10:38:52 <maurer_> > "011001" ~= "(1*0*)((00*11*)^2)*(00*11*)(1*0*)" :: Bool
10:38:54 <lambdabot>   Not in scope: `~='
10:38:57 <maurer_> :(
10:39:02 <rschnck> : (
10:39:11 <rschnck> I'm going to try and figure it out...I have class now.
10:39:13 <rschnck> But thanks everyone.
10:39:24 <maurer_> Evidently lambdabot does not have Text.Regex.Posix as a default import
10:42:53 * maurer_ scratches head in response to hpaste "run this code"
10:43:17 <maurer_> They must have some VMing going on, or people have just not been dicks on the internet.
10:43:22 <maurer_> However, the latter seems implausible.
10:44:24 <zygoloid> maurer_: it's very sandboxed, i believe
10:44:38 <zygoloid> mrs done didn't raise no fool
10:46:11 <Cale> hmm "Codepad output"
10:46:59 <maurer_> Well, marginal inspection suggests they did some things right (fopen appears blocked)
10:47:02 <Cale> It would be pretty funny if it was just pasting the code on codepad.org and asking it to run the thing :)
10:47:59 <maurer_> Even better if they managed to run it in javascript, and just offloaded it to your browser.
10:48:26 <Cale> There was some work on a javascript backend for Yhc.
10:48:37 <maurer_> Cale: Yeah, I was a fan of Yhc
10:48:43 <maurer_> (not for that reason though)
11:10:19 <chrisdone> Cale: http://github.com/chrisdone/amelie/blob/master/src/Web/Codepad.hs ;)
11:20:05 <Cale> chrisdone: haha, awesome
11:23:55 <maurer_> What does it mean if the machine isn't out of memory, I run a haskell binary, and it simply prints "Killed" and terminates?
11:25:38 <maurer_> (No, I didn't kill the process, nor is it on a shared machine where someone else might)
11:25:53 <pumpkin> it means something killed it :)
11:26:02 <rothwell> maurer_: check dmesg
11:26:30 <rothwell> might've exceeded some resource, if not memory
11:26:38 <rothwell> *limit
11:26:57 <Zao> File handles is a fun resource to run out of.
11:27:10 <Zao> Particularly if you're sufficiently lazy in IO.
11:27:17 <maurer_> Zao: Only opens one file
11:27:28 <zygoloid> maurer_: run ulimit -a, see if any limit looks pertinent
11:27:30 <maurer_> I'm tailing /var/log/syslog and running it again now
11:29:06 <maurer_> The only thing I can see in ulimit that's limited and potentially relevant is stack size, but the runtime manages a separate stack, right?
11:29:11 <kmc> strace might be useful too
11:29:32 <kmc> yeah, GHC code should never run out of C stack except in FFI
11:29:34 <maurer_> Evidently the oomkiller is in fact triggered
11:29:41 <mightybyte> Anyone know how to fix a "Fodule 'Distribution.Simple.PackageIndex' does not export 'lookupPackageId'" error when installing glib.
11:29:56 <maurer_> Though watch free throughout the process doesn't display it getting anywhere close to using all memory
11:30:02 <zygoloid> maurer_: yeah, s/F/M/ ;)
11:30:10 <zygoloid> s/maurer_/mightybyte/
11:30:35 <mightybyte> lol
11:30:40 <chrisdone> mightybyte: sounds like a cabal version mismatch. what version of cabal are you using?
11:30:46 <mightybyte> Consider my question so filtered.
11:31:00 <mightybyte> Cabal 1.8.0.6
11:31:24 <chrisdone> check the Setup.hs file
11:31:40 <mightybyte> For glib?
11:31:44 <chrisdone> I presume there is one, glib probably has a nontrivial (Custom) installation
11:31:45 <chrisdone> yeah
11:31:58 <chrisdone> it'll import that module and symbol, I think
11:32:41 <maurer_> Well, the code clearly has a space leak anyways. I guess I'll try to find it and solve from there
11:33:00 <chrisdone> mightybyte: which glib library is it?
11:33:44 <mightybyte> latest one...0.11.2
11:35:13 <mightybyte> There is a Setup.hs.  It imports one function from Distribution.Simple, but changing that to import everything doesn't fix the problem.
11:35:48 <maurer_> kmc: Hardest part of building a compiler so far has been getting the register allocator to run efficiently.
11:36:04 <zygoloid> mightybyte: is there a Distribution/Simple.hs in your current directory which might be confusing ghc?
11:36:07 <kmc> maurer_, use a SAT solver! http://mainisusuallyafunction.blogspot.com/2010/09/yices-easy-simple-sat-smt-solving-for.html
11:36:10 <chrisdone> mightybyte: well, more just to identify the problem before solving it
11:36:24 <mightybyte> zygoloid: No.
11:36:40 <llambda> How would you write a delete for a Binary Search Tree in Haskell?
11:36:50 <Saizan> mightybyte: iirc the Setup.hs is doing something very hacky to guess what it should import
11:37:02 <Saizan> mightybyte: it's quite probably the hack is failing for your setup
11:37:03 <llambda> The case where node p is external or only has one child, it is easy
11:37:11 <maurer_> kmc: I am tempted to try it. My current implementation is hacky, has a space leak, and is not fast enough (possibly due to said space leak)
11:37:16 <llambda> But when p has two children I'm not sure how to do it purely/recursively
11:37:51 <kmc> llambda, the key you want to delete is either less than, equal to, or greater than the key at p
11:37:53 <kmc> right?
11:38:04 <mightybyte> Saizan: Try removing it?
11:38:26 <mightybyte> Here's the full build message: http://hpaste.org/40221/glib_install_error
11:38:40 <llambda> kmc, I want to delete p, and it has two children.
11:38:45 <kmc> ok
11:38:50 <kmc> then you need to merge those two subtrees
11:38:53 <kmc> make one a child of the other
11:38:57 <Saizan> mightybyte: try the thing suggested in the warning.
11:39:02 <kmc> doesn't the same problem occur in an in-place deletion?
11:39:35 <kmc> http://en.wikipedia.org/wiki/Binary_search_tree#Deletion
11:40:07 <llambda> Yeah, but that says "replace the value of N with the value of R, then delete R"
11:40:21 <llambda> Which feels like it wouldn't really translate at all
11:40:29 <kmc> but you're at N
11:40:34 <kmc> whatever your function returns is the new N
11:40:40 <mightybyte> Saizan: Aha, that worked.  Should have paid more attention to that warning.
11:41:53 <mightybyte> Grrr, now cairo won't build.
11:41:58 <kmc> deleteAt (Node x a@(Node y _ _) b) = Node y (deleteAt a) b
11:41:59 <kmc> like so?
11:42:02 <mightybyte> cairo-version.h: No such file or directory
11:42:03 <kmc> i think that's right
11:42:45 <llambda> Hmmm
11:44:41 <maurer_> kmc: Does yices brute force, or do something intelligent?
11:44:47 <kmc> intelligent
11:45:05 <kmc> sat solvers are fancy technology
11:45:27 <maurer_> Yeah, I'm mostly wondering because my operation method seems like it _should_ be fast
11:45:35 <kmc> the idea is that even though these problems are NP-complete in the worst case, real world examples tend to have structure you can recognize and exploit
11:45:42 <kmc> and that this is preserved even by reduction to SAT
11:45:54 <maurer_> i.e. it seems like it should be n^2 on graph creation (no getting around that) and O(n) on coloring because of restrictions on the ASM used to create the graph
11:46:13 <maurer_> Well, nlogn rather
11:46:49 <pumpkin> kmc: what's the license on yices itself? can't seem to find it on their site
11:47:02 <kmc> http://yices.csl.sri.com/yices-newlicense.shtml
11:47:11 <pumpkin> oh
11:47:21 <pumpkin> thanks
11:48:35 <Carneus> hi, has anyone used haskell for game development? is there necessary libraries (sdl, opengl) available?
11:49:10 <mee> wow, very restrictive. In fact, I'm not even sure how you'd download it and untar it w/o creating two copies and violating that license
11:49:31 <kmc> Carneus, yes http://hackage.haskell.org/packages/archive/pkg-list.html
11:50:00 <Carneus> have you used them? i'd like to know how mature/stable they are
11:51:46 <kmc> i've used OpenGL extensively
11:51:48 <kmc> it works well
11:54:14 <Carneus> nice to hear. i'd like to know what are the pros and cons developing (game) in haskell? eg. is it feasible to code whole game in haskell or use the c++ with it
11:54:37 <twanvl_> This cabal error doesn't make any sense:
11:54:38 <medfly> it is feasible to develop a whole game in Haskell. why would you think it isn't?
11:54:39 <twanvl_> cabal: dependencies conflict: ghc-6.12.1 requires filepath ==1.1.0.3 however
11:54:39 <twanvl_> filepath-1.1.0.3 was excluded because ghc-6.12.1 requires filepath ==1.1.0.4 
11:55:01 <kmc> iPwn Studios is writing an iPhone / Android game with realtime graphics/sound in C++ and everything else (scripting, AI, UI, etc) in Haskell
11:55:35 <kmc> one issue with realtime stuff in Haskell (and more of an issue on those mobile devices) is garbage-collection latency
11:55:45 <Carneus> well, i thought that the interaction with outside world would make the haskell code use a lot of io stuff, so easier to write those parts in c++
11:56:00 <kmc> Carneus, it's a stupid myth that "if you use IO you might as well not use Haskell"
11:56:06 <kmc> Haskell is a fine imperative language too
11:56:15 <kmc> certainly worlds ahead of C++
11:56:32 <Carneus> yeah, i have used c++ over 10 years and quite fed up with it
11:56:44 <maurer_> If you are doing lots of IO however, you do need to be careful about IO creep
11:56:48 <kmc> Carneus, do you know Haskell, or are you considering learning it?
11:56:50 <Carneus> i like python but it is slow
11:57:15 <Carneus> i have studied it a lot recently, and it seems to be a nice language
11:57:31 <kmc> Python isn't slow (it's a language; it has no speed)
11:57:35 <kmc> the CPython interpreter is terribly slow
11:57:38 <kmc> and just kind of awful
11:57:46 <kmc> but there are other much faster Python implementations
11:57:50 <kmc> in various states of workingness
11:57:56 <Carneus> well, python is interpreted language so by design it is slow
11:58:01 <kmc> that's not true
11:58:07 <kmc> there is no such thing as "interpreted language"
11:58:11 <Carneus> psycho and other stuff helps somewhat but it always loses to c/c++
11:58:26 <kmc> you can write a compiler for any language
11:58:38 <Carneus> okay, the current implementations of the python compilers are interpreters
11:58:44 <kmc> the popular ones, yes
11:59:03 <kmc> a lot of people would call Lua an "interpreted language" but LuaJIT is one of the fanciest compilers around
11:59:15 <kmc> berp compiles Python 3 to native machine code via Haskell
11:59:15 <Carneus> but anyway, i found myself using a lot of lambda expressions with python, so might as well try proper functional language
11:59:21 <kmc> yeah, i agree
11:59:37 <kmc> you should also look at Scheme and Clojure
11:59:51 <Saizan> twanvl_: see the Cabal FAQ
11:59:54 <kmc> if you like the dynamic typing / other dynamic features of Python, but you want proper support for FP
12:00:29 <monochrom> I only miss algebraic data types and pattern matching in scheme.
12:00:45 <Carneus> i am not a big fan of the duck typing / dynamic typing
12:00:46 <monochrom> I suppose they are macro-able.
12:00:54 <twanvl_> Saizan: thanks
12:01:20 <twanvl_> the message is still horribly confusing, though
12:01:51 <Saizan> not surprising, since the algorithm itself is kind of confused there
12:02:35 <Carneus> can you give some tips what kind of stuff i should learn? i mean there are tons of books of traditional oop-patterns but is there any information how to structure functional program?
12:03:04 <Carneus> i know already that my first big programs will be a huge mess probably
12:03:07 <monochrom> perhaps SICP is about that
12:03:55 <Carneus> i can read source code too, if you know some games that have "good haskell style and architecture"
12:04:12 <kdvh> Hi, I wish for my haskell program to run an external command (e.g. ls -a ~/), any way to achieve this?
12:04:33 <maurer_> System.Process
12:04:47 <maurer_> monochrom: :(@SICP
12:05:05 <kmc> Carneus, most of those "OOP patterns" have nothing to do with OOP itself; they are codified workarounds for flaws in Java and C++ specifically
12:05:11 <kmc> i bet you've noticed much less need for them in Python
12:05:22 <Cobra_> Carneus: i don't know about good haskell style, but you can check out freekick2 in hackage
12:05:54 <Cobra_> it's a game i wrote which i tried to write in a better style than my previous games
12:06:09 <monochrom> xmonad has good structure
12:06:16 <kmc> Carneus, xmonad is a good example of a real-world app (used by people who don't know Haskell) with lots of interactive IO (it talks to X) and a clean design
12:06:33 <kmc> for example, the core data structure for window management is pure and has automated pure tests
12:06:38 <Carneus> thanks, i'll look at that
12:06:39 <kmc> so you can look at how they separated that from the IO code
12:06:49 <Carneus> sounds good
12:06:56 <kmc> Carneus, http://xmonad.wordpress.com/2009/09/09/the-design-and-implementation-of-xmonad/
12:07:36 <Cobra_> Carneus: there's also a good summary at http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell
12:07:59 <Carneus> thanks, just the kind of texts i was looking for
12:12:09 <maltem> Heh, xmonad under the caption "large scale design"
12:13:44 <maurer_> So, I know how to invoke GHC profiler, but if I've got an input that makes the program space leak (and then crash), and making the input smaller causes the program to run normally (<100M memory usage), how do I get profiling on what is causing the heap explosion?
12:14:05 <kmc> maurer_, i think it writes the profiling file as it goes
12:14:08 <maurer_> Simply, profiling reports aren't written until the end, I have an input which crashes for efficiency reasons, how do I figure out what to do?
12:14:15 <maurer_> kmc: No, I get an empty foo.prof
12:14:26 <kmc> oh, i was thinking of the .hp file
12:14:28 <kmc> for heap profiling
12:15:02 <maurer_> kmc: Ah, that's a good idea
12:15:07 * maurer_ looks for that
12:18:04 <dolio> @seen dons
12:18:05 <preflex>  dons was last seen on #haskell 13 hours, 52 minutes and 7 seconds ago, saying: full functional verification of cryptographic/dataflow programs
12:18:05 <lambdabot> Unknown command, try @list
12:18:59 <kdvh> maurer_: Thanks, system works.
12:19:38 <lysgaard> What does the "Ambiguous type variable" error mean exactly?
12:20:04 <cizra> "exactly"? Haha
12:20:21 <kmc> that you provided insufficient information to determine the type of that variable
12:20:22 <maurer_> kmc: It does, but h2ps doesn't seem to want to work with a half output file. Guess I'l lhave to hand fix it?
12:20:24 <cizra> I don't know the answer, but the question is humorous.
12:20:28 <kmc> yeah maurer_
12:20:33 <kmc> try chopping off some of the end
12:20:51 <kmc> :t show . read
12:20:53 <lambdabot> String -> String
12:21:16 <chrisdone> hehe, constraint defaulting?
12:21:20 <kmc> probably :/
12:21:40 <maurer_> kmc: Chopping off the obvious yields "hp2ps:  Disaster! (bucket out of range)
12:21:56 <itrekkie> Can someone help me understand function composition? I'm trying to understand why I would want to use it as opposed to what I already have, just passing the result of a function to another. e.g.: (map timesTwo (filter ifEven xs))
12:21:57 <chrisdone> > let x = return () in 10
12:21:59 <lambdabot>   10
12:22:10 <itrekkie> is function composition even permitted in that kind of a case?
12:22:18 <chrisdone> intresting. ghci shows ambiguous type variable
12:23:07 <chrisdone> lysgaard: it's basically when the particular instance of the class is not inferrable because there are more than one reasonable types that would fit its place
12:23:24 <ClaudiusMaximus> maurer_: you could try hp2pretty (on hackage) instead of hp2ps, maybe it accepts incomplete input more gracefully (although i think out-of-order time stamps still behave weirdly)
12:23:25 <kmc> itrekkie, that would be (map timesTwo . filter ifEven)
12:23:46 <kmc> itrekkie, composition is often preferred because it avoids a proliferation of useless local names
12:23:48 <kmc> it's more direct
12:24:09 <kmc> more direct to say "f of g" than to say "for any xs, f of (g of xs)"
12:24:12 <itrekkie> kmc: in that example, how do you pass the list xs into that?
12:24:21 <kmc> itrekkie, syntactically?
12:24:25 <Blkt> good evening everyone
12:24:27 <chrisdone> > show undefined
12:24:28 <lambdabot>   "*Exception: Prelude.undefined
12:24:29 <kmc> (map timesTwo . filter ifEven) is a function value like any other
12:24:32 <kmc> so you can do
12:24:33 <chrisdone> O_o
12:24:34 <kmc> (map timesTwo . filter ifEven) xs
12:24:40 <lysgaard> chrisdone: Ah, that made more sense
12:24:43 <kmc> or:  let f = map timesTwo . filter ifEven in f xs
12:24:46 <kmc> or whatever else you like
12:24:50 <itrekkie> kmc: ah that makes so much more sense
12:24:53 <itrekkie> thank you!
12:24:56 <kmc> quite often:
12:25:00 <kmc> map timesTwo . filter ifEven $ xs
12:25:45 <itrekkie> what does the $ mean?
12:25:58 <erisco> after much, much work I think I have finally made all reasonable optimizations to the naive function to calculate the nth value of the fibonacci series
12:26:02 <kmc> f $ x = f x
12:26:08 <kmc> but it has low parsing precedence
12:26:14 <kmc> so it's useful for eliminating parentheses
12:26:18 <djahandarie> f (g x) = f $ g x
12:26:28 <itrekkie> interesting, though I definitely take the parens for now
12:26:29 <chrisdone> it's a right-associative apply; apply everything on the right to the expression in the left
12:26:29 <kmc> also useful in an operator section
12:26:33 <kmc> > map ($ 3) [succ, pred]
12:26:34 <lambdabot>   [4,2]
12:26:43 <erisco> not only have I uncovered other useful functional patterns (yay functional programming!) but I've reduced the algorithm from exponential space and time to constant space and linear time
12:26:57 <chrisdone> erisco: great success!
12:26:57 <erisco> and my solution is here: http://pastebin.com/yG6YZA48
12:27:02 <djahandarie> > map ((flip id) 3) [succ,pred]
12:27:04 <lambdabot>   [4,2]
12:27:15 <erisco> without spoiling any further optimizations, is that the most efficient I can make it?
12:27:17 <lysgaard> chrisdone: So I want to add types to "something" to make it understand what instance to use?
12:27:20 <djahandarie> @type flip id
12:27:21 <lambdabot> forall a b. a -> (a -> b) -> b
12:27:30 <djahandarie> @type ($)
12:27:32 <lambdabot> forall a b. (a -> b) -> a -> b
12:27:46 <erisco> chrisdone: thanks :-) been a long time since I solved a tough problem - tough for me anyways.
12:27:47 <djahandarie> @type (\x -> ($ x))
12:27:49 <lambdabot> forall a b. a -> (a -> b) -> b
12:27:51 <chrisdone> lysgaard: yeah, an explicit type signature or combining the ambiguous expression in question with an unambiguous (that will provide the type) one will work
12:27:51 <djahandarie> \o/
12:27:58 <benmachine> chrisdone: ambiguous type variables are resolved in some contexts by defaulting, which I guess is why you can't trigger the error in lambdabot
12:28:18 <itrekkie> oh, actually used more function composition and $, thanks guys 
12:28:31 <chrisdone> benmachine: yeah, it's weird how in ghci I can trigger it just fine but lambdabot is... difficult to predict
12:28:46 <erisco> also, this form     walk step init = init:(walk step (step init))    already exists as a standard in Haskell no?
12:28:54 <benmachine> chrisdone: your two examples work fine for me, maybe your .ghci disables defaulting or something?
12:29:06 <erisco> for example, walk (+1) 1    is  [1, 2, 3, 4 ...
12:29:07 <mauke> @src iterate
12:29:08 <lambdabot> iterate f x =  x : iterate f (f x)
12:29:33 <chrisdone> benmachine: sounds weird... try this: main = putStrLn $ show undefined
12:29:34 <ddarius> erisco: You can calculate fib in a logarithmic number of arithmetic operations.
12:29:51 <chrisdone> benmachine: that should not compile
12:30:07 <erisco> ddarius: I guess I am far from done then :(
12:30:07 <maurer_> chrisdone: Why not?
12:30:15 <benmachine> chrisdone: yeah it doesn't, but ghci does super-defaulting
12:30:17 <chrisdone> maurer_: what instances of `show' is it?
12:30:21 <maurer_> chrisdone: undefined is a member of all types...
12:30:26 <maurer_> Oh, I see.
12:30:32 <maurer_> It can't decide which one it is.
12:30:38 <erisco> oh, wait a minute, why did I accumulate fibStep in a list? that doesn't make any sense
12:30:39 * maurer_ is an idiot sometimes.
12:30:51 <djahandarie> conal, I like your recent memoizing post, lots of cool little examples and such
12:31:02 <erisco> ddarius: does it require optimization from the mathematical standpoint?
12:31:14 <chrisdone> benmachine: haha, yeah, seems so. ah, show undefined throws an exception, didn't try that one in GHCi. but let x = return undefined in 10 gives me a compile error
12:31:46 <chrisdone> maurer_: yeah, exactly
12:31:48 <benmachine> chrisdone: http://darcs.haskell.org/download/docs/6.12.3/html/users_guide/interactive-evaluation.html#extended-default-rules gives more details
12:32:08 <chrisdone> benmachine: does the let x = ... work for you?
12:32:09 <ddarius> erisco: I'm not sure what that would mean, but I'll say yes, you'd probably need to consider some of the mathematical properties of fib.
12:32:41 <chrisdone> benmachine: ahh, that explains it
12:32:44 <benmachine> chrisdone: let x = return undefined in 10 works for me in ghci, but I admit I'm surprised it does
12:33:17 <erisco> ddarius: well, the optimizations I took came purely from looking at the naive fib n = fin (n-1) + fib (n-2) and asking how I could not recompute so many answers I've already found
12:33:31 <erisco> ddarius: but I wasn't able to just look at the mathematical definition and manipulate it
12:33:54 <maurer_> erisco: Using that you'll only get O(n). Look at Idenity 3 on the wikipedia page for fibonacci numbers if you want to go logarithmic
12:34:04 * chrisdone dines on delicious rice and lisp programmer entrails
12:34:14 <bla123> benmachine: why are you surpised that it does?
12:34:51 <erisco> thanks maurer_
12:34:53 <benmachine> bla123: x :: (Monad m) => m a, but we don't know which monad, so I'm not sure how x is supposed to behave
12:35:09 <maurer_> erisco: You also need some other stuff, but that's the start, plus some thought
12:35:20 <benmachine> I suppose it defaults to IO
12:35:30 <benmachine> just like return 10 at the prompt works fine
12:35:49 <kmc> the GHCi prompt is an IO-specific "do"
12:35:54 <maurer_> benmachine: That's partially because of ghci's special IO handling
12:35:57 <kmc> this is not the same as other type defaulting
12:35:59 <ddarius> benmachine: There is no reason for it to "default" to anything.
12:36:04 <maurer_> If you give it something pure typed, it prepends it with print
12:36:11 <bla123> benmachine: i see, and it doesn't work in my ghci. so i'm surprised too that it does at yours ;)
12:36:15 <ddarius> x :: (Monad m) => m a is a perfectly fine type.
12:36:28 <kmc> :t return undefined
12:36:29 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
12:36:33 <benmachine> ok the prompt is a bad example because that is forced to be IO
12:36:51 <benmachine> ddarius: oh, yes I suppose so
12:36:57 <chrisdone> λ> let x = return undefined in 10
12:36:57 <chrisdone> <interactive>:1:8:
12:36:57 <chrisdone>     Ambiguous type variable `m' in the constraint:
12:36:58 <chrisdone>       `Monad m' arising from a use of `return' at <interactive>:1:8-23
12:37:00 <chrisdone>     Probable fix: add a type signature that fixes these type variable(s)
12:37:09 <bla123> btw, why does ghci behave differently at all?
12:37:16 <kmc> chrisdone, did you disable MMR
12:37:30 <chrisdone> I'm on GHC 6.12.3
12:37:44 <chrisdone> I do have :set -Wall
12:37:45 <benmachine> bla123: convenience, mainly
12:37:47 <chrisdone> maybe that affects it?
12:37:54 <benmachine> I doubt it
12:37:56 <kmc> chrisdone, set -XNoMonomorphismRestriction
12:38:03 <benmachine> oh but *I* have nomonomorphismrestriction I think
12:38:05 <kmc> or try to put a signature on x with the general type
12:38:06 <chrisdone> ah, so it's you guys
12:38:07 <kmc> oh
12:38:12 <chrisdone> you cheeky buggers :p
12:38:12 <benmachine> yeah, whoops
12:38:19 <bla123> benmachine: i meant it in a more general sense as in: why can't i define data types, etc
12:38:20 <benmachine> sry
12:38:25 <chrisdone> well that explains it
12:38:29 <lysgaard> chrisdone: Hm, i tried to constrain the function to the type i want it in ghci, but thet i get that i can't use the class as a type, wich seems logical, but doesn't help me much
12:38:49 <benmachine> bla123: oh right, because you want to be able to execute IO incrementally
12:39:02 <benmachine> well
12:39:08 <lysgaard> The function i have has this :t genNet :: (Graph gr) => Double -> (Double -> Double) -> [Node] -> IO (gr Body Double)
12:39:09 <benmachine> it just tends to be more often what you want, anyways
12:39:32 <bla123> benmachine: why can't i have both?
12:39:46 <chrisdone> lysgaard: what're Node and Body?
12:39:54 <lysgaard> chrisdone: I don't get what's wrong, isn't gr confined enough?
12:39:56 <bla123> benmachine: or is it possible, but would require a lot of work to implement?
12:39:57 <benmachine> bla123: I don't know, maybe the implementation details of GHC makes it awkward
12:40:08 <benmachine> I know little about how ghci works inside
12:40:44 <lysgaard> chrisdone: :t Node :: (Int, a)    :t Body :: Body {t :: Double, f :: (Double -> Double)}
12:40:45 <chrisdone> defining data types in GHCi is a bit hard, I think
12:40:53 <chrisdone> I thought about it for tryhaskell and gave up
12:41:31 <ddarius> benmachine: Which version of GHCi are you running?
12:42:10 <chrisdone> lysgaard: I mean in your type signature, what are Node and Body? types or classes?
12:43:53 <lysgaard> chrisdone: types
12:44:24 <erisco> there, this is what I meant to write - before a list somehow got thrown into the algorithm: http://pastebin.com/kRjFbcKN
12:44:38 <erisco> that one is actually constant space like I meant it to be :P
12:45:01 <chrisdone> bla123: for example, suppose you define data A = A Integer, and data B = B A. and then you redefine data A = A Char Integer, now what of B?
12:46:10 <chrisdone> bla123: do you keep the old version of A for B, or update B with the new A? if you keep the old version, how do you differentiate between the two types A and A?
12:47:12 <lysgaard> !hpaste
12:47:17 <chrisdone> so you have to write a type dependency analyser
12:47:27 <chrisdone> @paste
12:47:27 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:47:31 <chrisdone> uh
12:47:33 <chrisdone> ignore that
12:47:36 <chrisdone> http://hpaste.org
12:47:49 <chrisdone> how do we unset the @paste variable and reset it?
12:48:05 <bla123> chrisdone: i'd say it was natural to keep the old version of A and that there's no way to access the old A, just like with any other redefined binding on the prompt
12:48:24 <erisco> maurer_: are you sure I should use the third identity? it requires that I know fib (2*n) to compute fib n which won't converge
12:48:53 <ddarius> Anyway, it is just the monomorphism restriction: see section 4.5.5 of the Report http://haskell.org/onlinereport/decls.html#dependencyanalysis
12:49:27 <itrekkie> could someone get my mind pointed in the right direction? I want to check a list for duplicates, along the line of the set functions in Data.List
12:49:43 <mauke> define "check"
12:50:13 <itrekkie> e.g., True if a list contains a duplicate element?
12:50:17 <ddarius> itrekkie: What do you intend to do once you know that the list has duplicates?
12:50:27 <erisco> maurer_: sorry, not to compute fib n, but the sum of numbers from fib 1 to fib (n-1)... even if that helped me can I really still use that identity?
12:50:27 <lysgaard> chrisdone: I made you a paste if that helps. I feel that I'm really close to understanding what the problem is, but that I'm missing i tiny bit of information to get the whole picture. http://hpaste.org/paste/pid/40223/run/true
12:50:44 <itrekkie> ddarius: just bail out with a Bool either way
12:50:49 <erisco> maurer_: I just want to confirm that I am looking at the right one
12:51:01 <maurer_> You can use that in the opposite order
12:51:13 <yrlnry> itrekkie:  first try writing a function that checks to see if a list contains a certain element.
12:51:24 <ddarius> What, if hasDuplicates list then error "List has duplicates!" else error "List does not have duplicates!" ?
12:51:26 <maurer_> That will only halve the time though unfortunately.
12:51:31 <maurer_> You need more math to get logarithmic
12:51:33 <mauke> :t any (\xs -> case xs of [] -> False; x : xs' -> x `elem` xs') . tails
12:51:34 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:52:01 <chrisdone> :t \xs -> xs /= nub xs
12:52:02 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:52:06 <chrisdone> :P
12:52:17 <yrlnry> chrisdone:  is nub guaranteed to return the elements in the same order? 
12:52:25 <ddarius> yrlnry: I believe it is.
12:52:25 <mauke> :t ap (/=) nub
12:52:26 <itrekkie> yrlnry: won't we be traversing the list a lot? I wanted to sort, and check elements sitting next to each other
12:52:26 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:52:30 <itrekkie> though I like using nub
12:52:32 <erisco> maurer_: ah, yes, I can see how you'd use that now
12:52:32 <erisco> well, I'll try implementing that one anyhow
12:52:33 <chrisdone> mauke: nice :D
12:52:39 <itrekkie> I didn't know you could compare lists like that
12:53:04 <mauke> :t any (not . null . drop 1) . group . sort
12:53:05 <lambdabot> forall a. (Ord a) => [a] -> Bool
12:53:20 <yrlnry> itrekkie:  divide and conquer.  Check the first two elements to see if they are the same.   If so, you have your answer.  If not, throw away the first element and proceed with the rest of the list.
12:53:25 <yrlnry> itrekkie:  when the list is short, you are done.
12:53:48 <maurer_> kmc: Well, now have a profile.
12:53:57 <maurer_> I am neither surprised, nor happy by what it said.
12:54:02 <chrisdone> @check \xs -> length (nub xs) == length xs || nub xs == xs
12:54:04 <lambdabot>   "Falsifiable, after 5 tests:\n[(),()]\n"
12:54:11 <itrekkie> yrlnry: thank you that'll work :) 
12:54:21 <maurer_> kmc: It says that all my alloc is either being done by buildG or explode.
12:54:30 <maurer_> (explode is the n^2 expansion step)
12:54:35 <mauke> I think my last version is reasonably efficient
12:54:56 <chrisdone> @check \xs -> length (nub xs) /= length xs || nub xs == xs -- I meant
12:54:57 <lambdabot>   "OK, passed 500 tests."
12:55:22 <chrisdone> 'spose that still doesn't prove ordering
12:55:45 <rschnck> ..and I'm back. With *hopefully) the correct answer.So, for: The set of strings over the alphabet {a, b, c} that don’t con-
12:55:45 <lysgaard> chrisdone: Yay, i got it, i needed to bind the return value to a data type, not just a class =)
12:55:47 <djahandarie> quicksort doesn't prove anything :P
12:55:48 <rschnck> tain ab as a substring.
12:55:56 <djahandarie> Uh what
12:56:01 <djahandarie> quickcheck doesn't prove anything*
12:56:02 <chrisdone> lysgaard: heheh
12:56:19 <rschnck> Is this the correct answer: epsilon | (aa*c(b|c)*)* | a* | (b|c)* | (b|c)*a*?
12:56:24 <maurer_> erisco: "Identity for doubling n" is probably simpler as a starting point
12:56:25 <ddarius> djahandarie: You can prove refutations with quick check.
12:57:07 <chrisdone> proof by contradiction?
12:57:26 <dolio> Proof by counterexample.
12:58:02 <mauke> rschnck: a*|(b|c)* ⊂ (b|c)*a*
12:58:03 <ddarius> A particular Dijkstra quote is relevant.
12:58:10 <chrisdone> those two words seem the same, but I guess their use has some extra meaning
12:58:10 <mauke> also, epsilon
12:58:25 <rschnck> mauke: How'd you solve it so fast ;_;
12:58:30 <mauke> what
12:58:33 <mauke> I didn't solve anything
12:58:45 <rschnck> Okay, how did you get that?
12:58:50 <erisco> maurer_: yes, that sounds promising
12:58:53 <mauke> by trying to understand your code
12:59:02 <rschnck> So I was correct?
12:59:03 <rschnck> Just verbose?
12:59:10 <mauke> and noticing that three of your five alternatives are redundant
12:59:20 <mauke> I'm not at the correctness stage yet
12:59:26 <itrekkie> is there something in standard prelude that does something like all but for just some/one element? 
12:59:28 <rschnck> Oh.
12:59:29 <mauke> I'm still trying to understand what's going on
12:59:39 <rschnck> I figured it out using a DFA.
12:59:41 <kmc> :t any
12:59:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:59:48 <kmc> itrekkie, ^^^^
12:59:50 <djahandarie> ddarius, I don't follow. How would quickcheck do any of the logic to do a proof by contradiction?
13:00:01 <itrekkie> any, thank you :)
13:00:12 <ddarius> djahandarie: Proving a refutation is not proof by contradiction.
13:00:46 <kmc> quickcheck can prove statements with existential quantification only
13:01:01 <kmc> it won't *always* prove such a statement, but when it claims to, it's never lying
13:01:12 <mauke> rschnck: I think your set doesn't contain 'bac'
13:01:35 <rschnck> Yeah, you're right.
13:02:18 <rschnck> Fixed it
13:03:01 <itrekkie> can you pass a lambda into any?
13:03:09 <kmc> of course
13:03:14 <mauke> (a+c|[bc])*a*
13:03:24 <kmc> lambda is just syntax, syntax for creating a function value, and one function's as good as another
13:03:26 <djahandarie> kmc, hm, do you mean universal quantification?
13:03:34 <kmc> djahandarie, no
13:03:48 <kmc> when quickcheck finds a counterexample, it has proved an existential
13:03:49 <maurer_> kmc: In the case of universal, it can say a statement is false.
13:03:51 <maurer_> err
13:03:53 <kmc> right
13:03:58 <maurer_> djahandarie, ^
13:04:08 <kmc> when it finds no counterexample, it's given you evidence towards a universal, but no proof
13:04:10 <maurer_> It does this by giving an example for which it doesn't hold true
13:04:17 <itrekkie> the examples for any (here: http://zvon.org/other/haskell/Outputprelude/any_f.html) use a weird syntax. e.g. any (1==). Could you also: any (\ x -> 1 == x) [..] ?
13:04:22 <kmc> yes
13:04:23 <maurer_> If you state there exists, then an example for which it holds true constitutes a proof
13:04:29 <kmc> (1==) is precisely syntactic sugar for (\x -> 1 == x)
13:04:39 <kmc> the same holds for any infix operator in place of (==)
13:04:50 <kmc> and on the other side, e.g. (==1) ==> (\x -> x == 1)
13:05:07 <djahandarie> Ah, okay, I see now
13:05:27 <itrekkie> ah, that's kinda nifty
13:05:30 <erisco> maurer_: when wikipedia talks about F sub j, what is j? Is it refering to the sum of fibonacci numbers?
13:06:01 <maurer_> itrekkie: Operator sections are super convenient, especially for filter and map
13:06:27 <maurer_> erisco: F_j is the jth fibonacci number
13:06:36 <kmc> itrekkie, yeah, it's convenient.  there is this association of "functional programming = lambda" but really, Haskell tries to be "post-lambda" as much as possible
13:06:56 <mauke> post-lambda? SKI?
13:07:03 <kmc> that's the idea of "points-free" (or "pointless") style: as much as possible, avoid naming arguments, just glue existing things together in a higher order way
13:07:06 <kmc> hehe
13:07:08 <opqdonut> SKI is kinda un-lambda
13:07:13 <erisco> maurer_: then I really don't understand how F sub j fits into the identity
13:07:15 <opqdonut> (heh heh)
13:07:19 <itrekkie> okay, how about a crazy question, with map, can you refer to the new list it's building?
13:07:30 <mauke> sort of
13:07:34 <kmc> you want to refer back to previous elements?
13:07:45 <kmc> map doesn't let you do that
13:07:52 * hackagebot cgen 0.0.2 - generates Haskell bindings and C wrappers for C++ libraries  http://hackage.haskell.org/package/cgen-0.0.2 (AnttiSalonen)
13:07:57 <kmc> nice!
13:08:05 <itrekkie> I want to build a list of unique elements, I was thinking about only adding it with map if it doesn't already exist in the new list?
13:08:17 <kmc> you can't do that directly with map
13:08:18 <itrekkie> basically what nub does
13:08:18 <mauke> itrekkie: why not just use a set?
13:08:24 <kmc> my advice is to write the recursion explicitly first
13:08:33 <kmc> and then you will probably recognize it as an instance of 'foldr'
13:08:37 <kmc> map is a special case of foldr
13:08:39 <erisco> maurer_: what I understand is that, for the (2n)th fibonacci number, you take the sum of the first (n-1) fibonacci numbers
13:08:46 <kmc> map f = foldr ((:) . f) []
13:08:50 <mauke> > fix (\xs -> 1 : map (1 +) xs)
13:08:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:09:00 <erisco> maurer_: so when they talk about F sub j I am entirely confused
13:09:18 <erisco> maurer_: and by the way, my understanding doens't actually work either
13:10:20 <erisco> maurer_: maybe they are assigning j = n - 1?
13:10:35 <chrisdone> > cycle "developers "
13:10:37 <lambdabot>   "developers developers developers developers developers developers develope...
13:13:23 <maurer_> enrisco: Rather than continue discussing it (I don't really feel like fibonacci numbers right now, sorry) here's the paper where Dijkstra figured it out, n years ago: http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF
13:20:40 <maurer_> So, intelligent use of laziness question: Say I have a number of cliques I want to overlay on one another to form a graph (i.e. my input is [Set Int]) and I want to produce Array Int [Int] or similar. How might I go about not having things explode due to many duplicate edges from the input?
13:21:19 <maurer_> (I can survive n^2 node coomplexity, but n^3 will kill me, and the duplicate edges all going into memory at the same time gives n^3
13:22:37 <maurer_> Right now I'm doing "buildG . (concatMap explode)" on the input, where explode is toList, and then the list comprehension [(x, y) | x <- xs, y <- xs]
13:22:52 <djahandarie> > (mappend . (toUpper .) . take 1) <*> tail $ cycle "buffalo "
13:22:54 <lambdabot>   "Buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo bu...
13:23:23 * djahandarie feels like there should be a nicer way to do that
13:23:38 <djahandarie> Besides the cons variant with head
13:24:21 <opqdonut> maurer_: how about something like [(x,elems map) | x <- nodes, map <- maps, x `elem` map]
13:24:26 <opqdonut> forgive my pseudo-syntax
13:25:03 <opqdonut> that should get you the neighbor lists of all nodes in about linear time, depending on the map stuff
13:25:10 <benmachine> :t uncurry (:) . first toUpper . (head &&& tail)
13:25:11 <lambdabot> [Char] -> [Char]
13:25:11 <opqdonut> err, and read "set" instead of "map" :)
13:25:24 <benmachine> wouldn't necessarily call that nicer, mind >_>
13:26:31 <kmc> [(x,y) | x <- xs, y <- xs]  =  liftA2 (,) xs xs
13:26:33 <djahandarie> benmachine, I was just typing that out
13:26:38 <djahandarie> Heh
13:27:30 <itrekkie> alright guys, bit lost. if map f = foldr ((:) . f) [], how can you only append the item to list if f yields true? and how can you reference the list being built in that condition?
13:27:51 <kmc> itrekkie, you can't, with that definition of map
13:28:01 <maurer_> opqdonut: I'm not sure I follow. That won't build the final graph structure, and the postprocessing steps I'd have to apply to get it there look identical to what I'm already doing.
13:28:08 <kmc> my point was that map is a special case of foldr, and you can probably write "optional map with back reference" as a different use of foldr
13:28:10 <kmc> :t mapMaybe
13:28:12 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
13:28:15 <kmc> @src mapMaybe
13:28:15 <lambdabot> Source not found. Just try something else.
13:28:16 <Heffalump> itrekkie: map has to produce one output value for each input value
13:28:32 <opqdonut> maurer_: you want to build an Array Int [Int]? neighbour list representation?
13:28:46 <kmc> actually you can reference the list being built with ordinary map
13:28:48 <maurer_> opqdonut: Yes.
13:28:48 <kmc> due to laziness
13:28:53 <Botje> itrekkie: foldr (\el rest -> if f el then f:rest else rest)
13:28:55 <itrekkie> well, how is nub working?
13:28:56 <kmc> mauke had an example earlier
13:28:59 <kmc> > fix (\xs -> 1 : map (1 +) xs)
13:29:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:29:02 <opqdonut> maurer_: then for each node you just look through all the sets and collect the neighbours
13:29:08 <kmc> which is the same as
13:29:14 <kmc> > let xs = 1 : map (1 +) xs in xs
13:29:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:29:17 <opqdonut> maurer_: that's under n^2 since testing for membership in the sets is fast
13:29:30 <maurer_> Lemme try that. It's a little different structure, so it might work.
13:29:48 <opqdonut> (if you have k maps of size (n/k) then it's n (log n - log k)
13:29:57 <kmc> so maybe lazy recursion + mapMaybe does what you want?
13:30:29 <itrekkie> Botje: that's basically what I have, but f has to have an argument that is the list being build, is that rest?
13:31:38 <Botje> itrekkie: from your text i read it as "f is a predicate over elements" ?
13:31:46 <opqdonut> (sorry, that was a lie, it's O(n k (log n - log k), or something like that)
13:32:16 <itrekkie> f is a function that checks if an element is present in a list
13:33:06 <itrekkie> does this look at all sane: foldr (\el rest -> if member cmp el rest then el:rest else rest) [] xs 
13:33:23 <lysgaard> Anyone know this problem. I've imported a module wich clearly contain a Type, but when i use the type i get "Not in scope"
13:33:58 <kmc> guesses: a) module does not export the type b) you're trying to use it as a value not a type
13:34:26 <itrekkie> oops, appending to the wrong list, but it works :)
13:34:42 <itrekkie> that's probably the craziest code I've ever written
13:34:56 <lysgaard> kmc: Hm, Context in http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Graph.html#t:Context is a Type right?
13:35:20 <nomemory> Hi, I am trying to implement a Binary Tree : http://hpaste.org/40224/binarytree . What am I doing wrong: ../tree.hs:11:0: Invalid type signature
13:35:22 <Botje> itrekkie: that only checks if el is a member of the elements after it, though.
13:35:30 <benmachine> itrekkie: that's entirely sane
13:35:34 <kmc> yes
13:36:01 * hackagebot freekick2 0.1.1 - A soccer game  http://hackage.haskell.org/package/freekick2-0.1.1 (AnttiSalonen)
13:36:03 <mauke> nomemory: trying to define an uppercase variable
13:36:03 * hackagebot starrover2 0.1.1 - Space simulation game  http://hackage.haskell.org/package/starrover2-0.1.1 (AnttiSalonen)
13:36:21 <lysgaard> kmc: But when i define "test (Context a b) = a" i get "Not in scope: Context"
13:36:25 <benmachine> nomemory: functions must start with a lowercase letter
13:36:30 <kmc> ") you're trying to use it as a value not a type"
13:36:38 <itrekkie> Botje: I'm not clear on that, what do you mean?
13:36:40 <kmc> that's a pattern
13:36:42 <kmc> a pattern for values
13:36:55 <kmc> you'd pattern-match Context simply as (x,y,z)
13:37:01 <kmc> because it's just a synonym for a tuple
13:37:06 <kmc> it doesn't introduce any data constructor
13:37:12 <nomemory> benmachine, mauke  didn't know that... :( thanks!
13:37:17 <lysgaard> kmc: Ah, dumb me, that would only worked if it was a data Context = ...., right?
13:37:22 <Botje> itrekkie: your test does not check if the element belongs to the /whole/ list, just the portion processed so far
13:37:41 <kmc> err (x,y,z,w)
13:37:47 <kmc> if you wrote "data Context a b = MkContext (Adj b) Node a (Adj b)"
13:37:54 <kmc> then a valid pattern would be (MkContext x y z w)
13:37:58 <kmc> still not (Context a b)
13:38:10 <kmc> sometimes the type constructor and data constructor have the same name, which confuses the distinction
13:38:12 <itrekkie> but doesn't it produce the same thing? I only want to add an element if it isn't in the list created so far
13:38:23 <kmc> but the arguments are still what's on the right hand side, not the left
13:38:50 <hinkes> Hey #haskell, quick newbie question:
13:39:25 <benmachine> itrekkie: depends what you mean by created so far
13:39:29 <hinkes> Say I want a haskell function to retrieve an element from a list.
13:39:42 <hinkes> extract :: Int -> [a] -> a
13:39:46 <djahandarie> @type (!!)
13:39:47 <lambdabot> forall a. [a] -> Int -> a
13:39:58 <Botje> itrekkie: oh, okay. your test is wrong, then :p
13:40:01 <mjrosenb> kmc: i've never seena  good argument as to why all patterns need to have the same number of curried arguments
13:40:30 <itrekkie> Botje: the test is wrong?
13:40:34 <hinkes> I can make extract recursive ... but does that imply that it runs in O(n) time !?!?!
13:40:37 <kmc> yeah mjrosenb
13:40:41 <kmc> you mean in function definitions?
13:40:47 <mjrosenb> yes.
13:40:49 <Botje> 22:32 < itrekkie> does this look at all sane: foldr (\el rest -> if member cmp el rest then el:rest else rest) [] xs 
13:40:58 <kmc> one time i was trying to program Haskell while tripping and that really confused me
13:41:01 <Botje> so you add the element if member cmp el rest is true
13:41:14 <djahandarie> hinkes, if you'd like to implement it yourself, it's just a matter of recursion. Just make sure the list gets smaller every recursive call.
13:41:16 <Botje> hinkes: yup. lists suck for random access.
13:41:18 <itrekkie> oh yea, I recognized that, just need to add if it's false
13:41:29 <Botje> itrekkie: okay then, nvm :)
13:41:33 <mjrosenb> like swap True _ = id; swap False x _ = x
13:41:47 <djahandarie> hinkes, and yeah
13:41:49 <itrekkie> Botje: thanks for being patient with me, main is pudding after all this haskel
13:41:54 <lysgaard> kmc: Ah, thanks =)
13:42:02 <Botje> itrekkie: no problem :)
13:42:02 <hinkes> djahandarie, Botje: Thanks.  Interesting.
13:42:20 <Botje> hinkes: as for your follow-up question: haskell has arrays and maps too
13:42:26 <kmc> mjrosenb, yeah, seems like a compiler could automatically η-expand the "short" equations
13:43:12 <hinkes> Botje: you were two seconds ahead of me!  I suppose List is a linked list, and O(1) access it not supported.
13:43:23 <maurer_> opqdonut: Your trick has worked to lower storage space. Now maybe the program will complete and I'll get a profile dump so I can figure out execution time problems.
13:43:27 <benmachine> kmc: I wonder if it would make overlap checking (for example) more complicated
13:43:41 <benmachine> oh no I guess it would be a purely syntactic thing
13:43:44 <benmachine> so, whatever
13:43:52 <mjrosenb> oh right
13:44:00 * mjrosenb forgot how the desugarer works
13:44:08 <djahandarie> hinkes, note that also applies for length in Haskell
13:44:18 <djahandarie> length on a [] is O(n)
13:44:26 * mjrosenb thought that you wouldn't need to \eta expant it
13:44:34 <Botje> hinkes: correct again :)
13:45:59 <ddarius> It is not, in general, semantically correct to eta expand.
13:46:24 <kmc> there are other places where automatic eta expansion is done in typical Haskell implementations
13:46:30 <kmc> like partially saturated constructor application
13:46:39 <kmc> i'm so glad that's done for us, unlike in ML
13:47:11 <Feuerbach> ddarius: could you please explain why not?
13:47:27 <benmachine> because undefined is distinct from const undefined
13:47:31 <mjrosenb> kmc: sml has that, just it doesn't have curried constructors
13:47:38 <ddarius> > ((\x -> undefined x) `seq` (), undefined `seq` ())
13:47:39 <lambdabot>   ((),*Exception: Prelude.undefined
13:47:44 <kmc> right
13:47:53 <kmc> so every constructor is saturated because it takes a single tuple ;P
13:48:06 <mjrosenb> kmc: if you have datatype F = Foo of int; you can use Foo as a (int -> F)
13:48:48 <kmc> ddarius, but it should always be safe to eta-expand a lambda term
13:49:00 <kmc> because a lambda is never ⊥
13:49:13 <kmc> mjrosenb, that's good.  i think OCaml doesn't even have that
13:49:18 <kmc> not certain though
13:52:20 <FunctorSalad_> > (undefined `seq` (), (\x -> undefined x) `seq` ())
13:52:21 <lambdabot>   (*Exception: Prelude.undefined
13:52:28 <mjrosenb> kmc: you should go into #sml and talk to j4cbo about call/cc
13:52:31 <FunctorSalad_> it's not teh symmetric :D
13:52:32 <kmc> hehe
13:52:35 <kmc> probably
13:53:25 <FunctorSalad_> hmm, actually it's the show instance's fault, not (,)'s :)
13:54:32 <mjrosenb> one thing that I have *really* missed from sml is multiple patterns in an anonymous lambda
13:54:49 <kmc> oh, sml has that?
13:54:50 <kmc> sweet
13:55:21 <mjrosenb> yeah, they use | to denote separate cases everywhere, so it sort of fits naturally.
13:56:08 <mjrosenb> it also doesn't have curried anonymous lambdas, which is kindof annoying
13:56:41 <mjrosenb> but it lets "fn T x => foo" be unambiguous
13:56:57 <kmc> yeah
13:57:05 <dever> hey all, what's the status of ghc reading back in external core (.hcr) files?
13:58:19 <ddarius> f () y = y; f x = undefined
13:58:56 <itrekkie> why am I building a list of [Bool] instead of just a Bool in this: oldr (\el ret -> if member cmp el ys then ret else False) True xs
13:59:24 <benmachine> itrekkie: it doesn't look like you are?
13:59:36 <itrekkie> I get: Couldn't match expected type `[Bool]' against inferred type `Bool'
13:59:43 <Botje> itrekkie: are you using the result correctly?
13:59:45 <itrekkie> oh oops, backwards
13:59:52 <pumpkin> data Void; isBottom :: Void -> Bool; isBottom _ = True
13:59:53 <Botje> itrekkie: because the inferred type is correct.
13:59:53 <pumpkin> magic!
13:59:55 <itrekkie> method signature was wrong :/
14:00:14 <pumpkin> :P
14:00:21 <itrekkie> well regardless, does that look haskelly? is there a better idiom for it?
14:00:23 <benmachine> pumpkin: brilliant.
14:00:37 * pumpkin bows
14:01:00 <benmachine> itrekkie: it's not bad but I think you might be able to eliminate that if
14:01:17 <benmachine> itrekkie: ok so you have "member cmp el ys" and "ret" both of which are type Bool
14:01:37 <itrekkie> yea, I don't like if then else, I'm always trying to get rid of them
14:02:18 <kmc> got to go, ttyl all
14:02:38 <benmachine> itrekkie: if either of those things are False then the result is False
14:02:41 <maurer_> So, evidently I spend all my time (>90%) in these two functions: http://hpaste.org/40225/cost_centers
14:02:54 <benmachine> itrekkie: if both of them are True then the result is True -- does this sound familiar?
14:03:09 <Botje> itrekkie: i'd write it as any (\x -> member cmp x ys)
14:03:12 <maurer_> n is only 10,000, but it still takes over 3 minutes to compute.
14:03:23 <maurer_> (n being the number of nodes)
14:03:56 <benmachine> maurer_: is insertAll doing a union?
14:04:04 <maurer_> No, it should be.
14:04:06 * maurer_ fixes
14:05:55 <itrekkie> okay, got rid of that :)
14:08:41 <maurer_> Shaved off a good amount of time. Now it takes about 2 minutes :/
14:09:08 <maurer_> Now all time is being spent in extract (same as before, but s/insertAll/union/)
14:10:28 <Ke> is there a way to explicitly load all dynamically  linked libraries
14:11:05 <benmachine> maurer_: I think there's a "unions" function as well, not sure how much use it'd be
14:11:34 * maurer_ looks
14:11:53 <benmachine> maurer_: the docs say bigset union smallset is more efficient than vice versa, I think
14:13:00 <benmachine> that's probably already what you're doing but anyway
14:14:23 <maurer_> I believe that to be what I'm doing
14:22:44 <pokoko222> it has been a while since i did haskell, how do u translate this  in haskell {(a,b,c) | a,b,c elements of {2,4,5,7,9}, c<a+b} 
14:23:35 <pumpkin> > let xs = [2,4,5,7,9] in [(a,b,c) | a <- xs, b <- xs, c <- xs, c < a + b]
14:23:36 <lambdabot>   [(2,2,2),(2,4,2),(2,4,4),(2,4,5),(2,5,2),(2,5,4),(2,5,5),(2,7,2),(2,7,4),(2...
14:23:42 <pumpkin> (inefficient as hell though)
14:23:56 <maurer_> unions gave another HUGE boost. We're down to 40 seconds :)
14:23:59 <pokoko222> pumpkin without repetitions
14:24:03 <maurer_> I'm almost there (20 seconds is my performance goal)
14:24:09 <pumpkin> > let xs = nub [2,4,5,7,9] in [(a,b,c) | a <- xs, b <- xs, c <- xs, c < a + b]
14:24:09 <lambdabot>   [(2,2,2),(2,4,2),(2,4,4),(2,4,5),(2,5,2),(2,5,4),(2,5,5),(2,7,2),(2,7,4),(2...
14:24:18 <pumpkin> > let xs = [2,4,5,7,9] in nub [(a,b,c) | a <- xs, b <- xs, c <- xs, c < a + b]
14:24:19 <lambdabot>   [(2,2,2),(2,4,2),(2,4,4),(2,4,5),(2,5,2),(2,5,4),(2,5,5),(2,7,2),(2,7,4),(2...
14:24:27 <pumpkin> :)
14:24:34 <pokoko222> ah no repetitions 
14:25:08 <pokoko222> hah why does it give (2,4,5) as answer
14:25:21 <pokoko222> ah ok ok
14:25:58 <pokoko222> pumpkin remove the repetitions and give me answer please 
14:25:59 <pokoko222> pls
14:26:20 <pumpkin> I did remove repetitions
14:26:30 <pokoko222> well why does 2,2,2 show up
14:26:34 <pokoko222> and 2,4,4 and others
14:26:40 <mauke> they only show up once
14:26:51 <pokoko222> ah no they show up twice
14:27:02 <pokoko222> 2,4,4, see two 4`s
14:27:04 <mornfall> You want a /= b, b /= c, a /= c in the comprehension maybe?
14:27:05 <pumpkin> lol
14:27:22 <pumpkin> > let xs = [2,4,5,7,9] in nub [(a,b,c) | a <- xs, b <- xs, c <- xs, c < a + b, a /= b, b /= c, a /= c]
14:27:23 <lambdabot>   [(2,4,5),(2,5,4),(2,7,4),(2,7,5),(2,9,4),(2,9,5),(2,9,7),(4,2,5),(4,5,2),(4...
14:27:26 <benmachine> maurer_: you compiling with relevant optimisations?
14:27:27 <pumpkin> HAPPY NOW?
14:27:33 <hpc> lol
14:27:41 <pokoko222> pumpkin still not happy
14:27:42 <maurer_> benmachine: -O4 -fvia-C, also trying without -fvia-C
14:27:47 <benmachine> er
14:27:48 <gwern> -O4?
14:27:52 <benmachine> pretty sure it doesn't go up to 4
14:27:59 <gwern> I thought it didn't even go to 3
14:28:00 <mornfall> -O11
14:28:05 <pokoko222> pumpkin i need combinations not permutations like 4,2,5 and 4,5,2
14:28:12 <pokoko222> can u fix that last thingy
14:28:16 <pumpkin> NO
14:28:19 <pumpkin> okay fine
14:28:21 <pokoko222> i will love you forever
14:28:23 <Zao> pokoko222: Should be trivial to do.
14:28:35 <pokoko222> Zao yeah but i did haskell in january last time
14:28:50 <benmachine> -O2 is the biggest yeah
14:28:56 <maurer_> benmachine: Old habit from gcc. It goes up to -O3, usually, a few devel releases have -O4, and if it doesn't it defaults down to -O3
14:28:57 <benmachine> although it doesn't enable everything
14:28:59 <pumpkin> > let xs = [2,4,5,7,9] in map head . group . sort . map sort $ [[a,b,c] | a <- xs, b <- xs, c <- xs, c < a + b]
14:29:00 <lambdabot>   [[2,2,2],[2,2,4],[2,2,5],[2,2,7],[2,2,9],[2,4,4],[2,4,5],[2,4,7],[2,4,9],[2...
14:29:01 <maurer_> I assume haskell works the same way?
14:29:15 <pumpkin> > let xs = [2,4,5,7,9] in map head . group . sort . map sort $ [[a,b,c] | a <- xs, b <- xs, c <- xs, c < a + b, a /= b, b /= c, c /= a]
14:29:16 <lambdabot>   [[2,4,5],[2,4,7],[2,4,9],[2,5,7],[2,5,9],[2,7,9],[4,5,7],[4,5,9],[4,7,9],[5...
14:29:19 <benmachine> I assume so too, but it's best to be sure :)
14:29:22 <pumpkin> HAPPY NOW?
14:29:27 <pokoko222> pumpkin no
14:29:45 <benmachine> -O2 is the most optimisation
14:29:48 <mauke> maurer_: ghc only goes to -O2, and old versions of it treated -O3 as something between -O0 and -O1
14:29:58 <benmachine> no
14:30:03 <benmachine> -O2 is the most -On
14:30:03 <maurer_> mauke: :( Why doesn't it follow gcc convention?
14:30:05 <pumpkin> pokoko222: okay, figure it out yourself
14:30:07 <benmachine> but there's more stuff
14:31:13 <maurer_> Performance Goal Met. Fuck Yeah.
14:31:22 <benmachine> :)
14:31:23 <maurer_> Thank you much benmachine, you were really helpful.
14:31:27 <benmachine> np
14:31:27 <hpc> ghc defaults to -O1, right?
14:31:31 <pokoko222> pumpkin ah guess those are the answers, hmm... thanks, my teacher seems made a huge screw up in the problems
14:31:36 <benmachine> no ghc defaults to no optimisation
14:31:41 <hpc> ah
14:33:05 <EvanR-work> !07/11 PDP a ni deppart m'I  !pleH
14:33:12 <EvanR-work> --fortune
14:33:36 <EvanR-work> i dont get it ;)
14:33:40 <benmachine> maurer_: so ooi, -O2 was faster than -O4?
14:34:08 <monochrom> perhaps look into how PDP 11 used to store strings
14:34:26 <EvanR-work> guessing completely backwards
14:34:38 <mauke> I think it's someone writing on the inside of the monitor
14:34:42 <pokoko222> pumpkin how is it baby havent been here for a while, u do haskell every day?
14:34:45 <maurer_> benmachine: No. I added -optc -march=native
14:34:48 <EvanR-work> lol
14:34:53 <Zao> Same arch that had NUXI ordering, or was that another PDP?
14:34:54 <maurer_> a.k.a. Rice this shit for my processor.
14:34:59 <benmachine> maurer_: oh right :)
14:35:00 <pumpkin> pokoko222: yes, religiously
14:35:25 <maurer_> pumpkin: Are you copumpkin?
14:35:42 <copumpkin> I AM COPUMPKIN
14:35:50 <FunctorSalad_> self-dual
14:35:52 * pumpkin glares at copumpkin 
14:35:54 <pokoko222> oh oh you insulted him, watch out now
14:35:58 <EvanR-work> what happens when pumpkin and copumpkin collide
14:36:03 <pokoko222> shit happens
14:36:16 <benmachine> pumpkin becomes copumpkin and vice versa
14:36:17 <monochrom> they duelize each other
14:36:30 <gwern> it's a beautiful cycle
14:36:32 <EvanR-work> they play dual monsters
14:36:39 <Saizan> that's the time of the year we call halloween
14:37:12 <EvanR-work> ls
14:37:17 <EvanR-work> dammit
14:37:22 <hpc> [sudo password for EvanR]
14:37:47 <pokoko222> ok then i meant to ask copumpkin how is he doing, that guy helped me a lot 
14:37:53 <FunctorSalad_> btw is it just me or are reader and writer streams like that? you can create a virtual pair out of nothing (a writer that will write to the reader), and you can have two annihilate by copying the whole reader to the writer...
14:38:09 <FunctorSalad_> (like "that" = like a pumpkin and a copumpkin)
14:38:39 <monochrom> I think it's 50% of it is just you and 50% of what you said.
14:38:53 <FunctorSalad_> hmm.
14:39:48 <pokoko222> anyways my professor liked my enthusiasm about euler problems and he now wants me to work with him in image processing, how cool is that? :D
14:40:00 <pokoko222> thanks to all who helped me before on the chanel
14:40:26 <pokoko222> and i am just second year, but still he thinks i can manage it
14:40:45 <gwern> > 52*24*7*7*60*500
14:40:46 <lambdabot>   1834560000
14:40:58 <gwern> > 1834560000 / 1000000000
14:40:59 <lambdabot>   1.83456
14:41:29 <pumpkin> pokoko222: cool :)
14:44:25 <EvanR-work> > 183456000000000000 / 1000000000000000000
14:44:26 <lambdabot>   0.183456
14:44:28 <EvanR-work> > 183456000000000000 / 100000000000000000
14:44:29 <lambdabot>   1.83456
15:04:42 <FunctorSalad_> gwern: so what *are* you doing 500 times/min, 7 hours a day..?
15:05:06 <gwern> FunctorSalad_: oh, this was a question about wheter you could serialize your long term memory given estimates for LTM around a gig
15:05:18 <FunctorSalad_> ah
15:05:33 <gwern> FunctorSalad_: turns out plausible estimates of the time involved are something like 80 years, so typing it out is infeasible
15:06:51 <FunctorSalad_> is this for the next social website? ^^
15:07:01 <FunctorSalad_> now with even lower snr
15:07:34 <gwern> FunctorSalad_: no no just general discussion about uploading minds and what you need
15:08:09 <FunctorSalad_> gwern: ah, I somehow thought "serializing all sensory input" instead
15:08:13 <gwern> is text enough, would video of their life be better, etc.
15:08:14 <benmachine> you probably don't need *all* of your long term memory
15:08:17 <benmachine> just the interesting bits
15:08:33 <gwern> FunctorSalad_: oh, all input is absurdly expensive. I forget what the lifetime estimates are - terabytes probably at a minimum
15:09:28 <gwern> benmachine: sure, but the 1gig only applies to declarative memory, so one would expect the useless-bits-of-LTM to be offset by the other stuff you need
15:09:49 <benmachine> hm, okay
15:10:24 <gwern> 1gig is, I think, definitely a lower bound
15:11:52 <FunctorSalad_> you'll eventually die anyway
15:11:57 <FunctorSalad_> :F
15:12:11 <benmachine> wooooo inevitability of death
15:12:27 <gwern> FunctorSalad_: as the quip goes, I'm not sure I want to be immortal - ask me again in a thousand years
15:13:37 <gwern> I also like 'I have always heard about the profound issues raised by life extension, and my attitude is, I am willing to wrestle with them for as many centuries as it takes.'
15:13:41 <FunctorSalad_> gwern: not saying I don't want to be immortal, just that we still won't be, and when it's all over what's the matter of whether it was 100 years or 1E15 ones? :D
15:13:58 <benmachine> what's the point of anything :OOO
15:13:59 <FunctorSalad_> it'll still suck just as much
15:14:07 <gwern> yes, let's all kill ourselves
15:14:20 <EvanR-work> nothing matters
15:14:25 <FunctorSalad_> gwern: not saying that either
15:14:44 * ddarius doesn't see any issues with life extension that don't already exist.
15:14:49 <EvanR-work> minimize total suffering now by eliminating life on earth
15:14:51 <FunctorSalad_> apathy, sigh
15:15:05 <benmachine> apathy isn't worth bothering with
15:15:12 <ddarius> EvanR-work: I like your style.
15:15:12 <benmachine> ha ha ha
15:15:18 <gwern> EvanR-work: diogenes laertius records an apocryphal story where Thales says that there is no difference between life and death; when asked why he remained alive, he repeated himself: there is no difference
15:16:50 <FunctorSalad_> isn't that exactly the conversation we've just had..
15:17:02 <FunctorSalad_> except not literally exactly
15:17:17 <gwern> FunctorSalad_: well, that's why I brought it up...
15:17:17 <pumpkin> figuratively exactly?
15:17:18 <EvanR-work> gwern is modern day socrates
15:17:22 <gwern> there is nothing new under the sun
15:18:52 <FunctorSalad_> EvanR-work: I think that's one of the challenges sometime brought against negative utilitarianism..
15:19:23 <FunctorSalad_> you could argue that there'd be suffering while setting it all up, but I'm not a negative utilitarian
15:19:44 <FunctorSalad_> *sometimes
15:20:49 <Adamant> utilitarianism, like every other political and philosophical doctrine, can be made to look absurd by picking the right example to hit it with
15:21:07 <gwern> if it couldn't, no one would discuss it because we'd all just believe it
15:21:14 <benmachine> that, like every other generalisation, is unhelpful if not downright false :)
15:21:19 <Adamant> excellent point
15:21:27 <benmachine> *overgeneralisation
15:21:31 <Adamant> benmachine: can you name a counterexample?
15:21:31 <EvanR-work> all generalizations are wrong
15:21:39 <benmachine> Adamant: nooope
15:21:42 <Adamant> all generalizations are generalizations
15:21:53 <EvanR-work> fix "all generalizations are"
15:22:03 <Adamant> no
15:22:03 <FunctorSalad_> that's painting it with a pretty broad brush
15:22:43 <FunctorSalad_> you always have to differentiate generalizations ;)
15:23:14 <Adamant> FunctorSalad_: I insist that generalizations are generalizations (a generalization)
15:23:51 <benmachine> how meta we are.
15:24:35 <benmachine> a-anyway. I'm curious about something that is also off-topic but less so
15:24:43 <FunctorSalad_> yeah let's examine the texture of this wall in detail instead
15:24:56 <EvanR-work> this discussion discusses everything that isnt self referential
15:25:15 <benmachine> we know that simply-typed lambda calculus is not turing-complete, but what can we say about what can and can't be computed with it?
15:25:26 <Adamant> FunctorSalad_: hey, that works in Chinese philosophy
15:25:41 <FunctorSalad_> oh? didn't know it has anything to do with it
15:25:47 <EvanR-work> FunctorSalad_: no, i dont believe the channel has physical form
15:26:06 <Adamant> FunctorSalad_: it sounds like an exercise both Taoists and Ch'an/Zen types would enjoy
15:26:24 <Adamant> although they would probably do it while meditating on the nature of wall
15:27:30 <PirateUnderwear> What is the bounded class used for?
15:28:05 <FunctorSalad_> making haskell the shortest language to print a character table in? ;)
15:28:13 <FunctorSalad_> > [minBound..maxBound] :: String
15:28:14 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
15:28:22 <benmachine> enumFrom minBound is a kinda handy way to enumerate a type
15:28:27 <PirateUnderwear> ohh
15:28:37 <FunctorSalad_> oh right, the maxBound is superfluous even
15:28:38 <benmachine> it's not a very widely used class though
15:28:48 <benmachine> yes
15:28:54 <PirateUnderwear> benmachine: I'm just beginning to learn. :)
15:28:55 <benmachine> > [maxBound ..] :: String
15:28:56 <lambdabot>   "\1114111"
15:29:00 <gwern> PirateUnderwear: it's also useful for overflow, I think. with Int you can check that your numbers are, say, less than maxBound/greater than minbound
15:29:25 <PirateUnderwear> Thanks guys, you all are great. :)
15:29:29 <EvanR-work> > maxBound :: Char
15:29:30 <lambdabot>   '\1114111'
15:30:02 <FunctorSalad_> you need to putStrLn it in ghci to not have it escaped...
15:30:17 <FunctorSalad_> or putChar if it exists, don't remember
15:30:27 <FunctorSalad_> does
15:30:31 <PirateUnderwear> EvanR-work: When you do maxBound :: Char .... what is that number that is outputed?
15:30:56 <FunctorSalad_> oh, it actually prints
15:31:11 <EvanR-work> PirateUnderwear: the code point for the last unicode character
15:31:18 <FunctorSalad_> not in xchat /exec though
15:31:25 <PirateUnderwear> EvanR-work: Oh, makes sense.
15:31:28 <PirateUnderwear> thanks
15:32:46 <PirateUnderwear> EvanR-work: What about if it's... minBound :: Int
15:32:56 <EvanR-work> > minBound :: Int
15:32:57 <lambdabot>   -9223372036854775808
15:33:09 <PirateUnderwear> that number comes from where?
15:33:17 <EvanR-work> > 0x10ffff
15:33:18 <lambdabot>   1114111
15:33:27 <FunctorSalad_> -2^31 or something
15:33:29 <PirateUnderwear> hmm
15:33:33 <EvanR-work> PirateUnderwear: -2^64
15:33:37 <FunctorSalad_> > 2^31 :: Integer
15:33:38 <lambdabot>   2147483648
15:33:39 <EvanR-work> 63
15:33:42 <FunctorSalad_> > 2^63 :: Integer
15:33:43 <lambdabot>   9223372036854775808
15:33:49 <PirateUnderwear> sweet..
15:34:15 <FunctorSalad_> is that because 'bot is running on a 64bit system?
15:34:21 <EvanR-work> yes
15:34:29 <IceDanelol> About that
15:34:32 <IceDanelol> I am running 64-bit
15:34:39 <PirateUnderwear> so am I
15:34:42 <IceDanelol> should I have downloaded a special version of ghc to support 64-bit like lambdabot
15:34:45 <FunctorSalad_> I'm not :(
15:34:45 <IceDanelol> ?
15:34:47 <EvanR-work> not me and proud of it
15:34:54 <ddarius> benmachine: It likely depends on the base types and associated delta rules.
15:35:02 <FunctorSalad_> IceDanelol: binary yes, source presumably not
15:35:07 <IceDanelol> 'cause minBound :: Int is -2^31
15:35:11 <IceDanelol> (for me)
15:35:15 <PirateUnderwear> So the min/maxBounds are dependent on your system?
15:35:19 <ddarius> benmachine: Short answer, very little.
15:35:20 <EvanR-work> Int is
15:35:23 <EvanR-work> system dependent
15:35:30 <PirateUnderwear> okay
15:35:32 <FunctorSalad_> PirateUnderwear: you have fixed-size ints in Data.Int though
15:35:37 <FunctorSalad_> Int32, Int64 etc
15:35:45 <EvanR-work> Data.Int has Int32 Int64, Data.Word has Word32 and Word64
15:35:50 <IceDanelol> Hmm
15:35:53 <benmachine> ddarius: can we exhibit an algorithm that we can prove isn't computable in STLC?
15:35:55 <PirateUnderwear> good to know, thanks
15:36:02 <EvanR-work> > maxBound :: Word
15:36:03 <lambdabot>   18446744073709551615
15:36:05 <benmachine> (but presumably is in a more powerful system)
15:36:21 <IceDanelol> I downloaded the haskell platform which doesn't seem to give you separate downloads for 64/32.. Would cabal break horribly if I uninstalled ghc and installed a newer version with 64 bit?
15:36:30 <benmachine> ddarius: and by we, I mean, people other than me >_>
15:36:32 <ddarius> benmachine: Tell me what the base types are.
15:37:04 <benmachine> ddarius: I thought STLC was all about church encodings
15:37:07 <ddarius> For example, I'm pretty sure if you add natural numbers and their eliminator, you get all of primitive recursion.
15:37:09 <FunctorSalad_> IceDanelol: you'd just start with an new package database containing just the ghc-included packages
15:37:11 <ddarius> benmachine: No.
15:37:17 <benmachine> k
15:37:28 <ddarius> benmachine: STLC has no types and no values without some base types being specified.
15:37:33 <IceDanelol> FunctorSalad_: I see
15:37:46 <IceDanelol> meh, I don't need 64 bit support really. I'll live
15:37:57 <ddarius> benmachine: System F doesn't need base types and can encode a lot of things via Church-encoding.
15:38:05 <IceDanelol> Oh, and no x86_64 for windows anyway
15:38:05 <benmachine> ddarius: mm, okay
15:44:24 <co_dh> is there a programming language that implement allegory of relation ? 
15:44:44 <co_dh> I remember I read from a paper, but forget which papaer
15:44:49 <co_dh> @where allegory
15:44:50 <lambdabot> I know nothing about allegory.
15:45:11 <PirateUnderwear> @where polymorphic
15:45:12 <lambdabot> I know nothing about polymorphic.
15:45:13 <PirateUnderwear> >..<
15:48:42 <IceDanelol> I asked a question how I could keep my little irc bot from terminating itself when it receives (some?) unicode characters, and got a few answers that didn't answer the question directly and then forgot about it and went afk. I was wondering if anyone had any suggestions tonight?
15:53:36 <tomh> hey guys, just checking, a newtype has an advantage over a data that you can partially apply it right?
15:53:57 <monochrom> no.
15:54:10 <tomh> then whats the advantage?
15:55:00 <c_wraith> no runtime representation
15:55:18 <c_wraith> newtypes are entirely handled at compile time.
15:55:36 <tomh> ah 
15:56:05 <tomh> they do seem to have a constructor
15:56:09 <c_wraith> Yes.
15:56:15 <c_wraith> You can pattern-match on it
15:56:18 <monochrom> the constructor is compiled away
15:56:37 <tomh> ok
15:56:45 <tomh> so whats the advantage? 
15:57:35 <monochrom> http://www.haskell.org/haskellwiki/Newtype and http://www.haskell.org/haskellwiki/NewType
15:58:13 <Entroacceptor> two pages??
15:58:45 <monochrom> because someone thought "NewType" was a cool name
15:59:28 <tomh> ive seen it yes, but practically, is there any advantage to add the whole new feature?
16:01:58 <kyagrd> newtype is a gundam pilot class
16:03:13 <benmachine> tomh: a newtype is more efficient where it can be used
16:03:31 <tomh> I see
16:03:45 <benmachine> tomh: one might ask whether any data types that are used where newtype is used could be automatically compiled into newtypes
16:03:48 <benmachine> but
16:03:56 <michie1> hmmm, can I ask a stupid newbie question?
16:04:00 <benmachine> they have subtly different semantics, because of the efficiency
16:04:06 <copumpkin> michie1: you just did! :)
16:04:07 <copumpkin> just kidding
16:04:08 <copumpkin> ask away
16:04:08 <kyagrd> benmachine: if id doesn't rely on some lazyness feature that could make difference
16:04:14 <michie1> say I have a Monad SomethingOrOther, and I have a function that takes a SomethingOrOther?
16:04:21 <michie1> how do I get the SomethingOrOther out of the Monad?
16:04:22 <IceDanelol> So, no good tidbits on unicode support? I just tried replacing all functions in the prelude and system.IO with their system.io.utf8 counterparts
16:04:23 <tomh> for example you cannot write newtype Bla = Bla deriving Show right?
16:04:25 <IceDanelol> still crashes
16:04:29 <monochrom> cannot
16:04:38 <copumpkin> michie1: hmm, you seem confused :), but you probably can't, in general
16:04:39 <benmachine> tomh: that constructor has zero fields
16:04:45 <kyagrd> tomh: you can with GHC extension called newtypederiving
16:04:50 <tomh> ok
16:04:51 <michie1> copumpkin: no, that actually confirms my expectations
16:04:55 <benmachine> and you can derive show for newtypes always
16:05:02 <FunctorSalad_> seems like SomethingOrOther *is* your monad
16:05:04 <monochrom> call your function from inside the monad
16:05:14 <benmachine> if their underlying type is showable
16:05:18 <copumpkin> FunctorSalad_: I think (s)he meant Monad m => m SomethingOrOther
16:05:20 <tomh> ah I see
16:05:29 <tomh> but it doesn't show "as expected"
16:05:30 <tomh> right
16:05:31 <FunctorSalad_> hmm
16:05:35 <monochrom> do { r <- getLine; let x = length r; now you can use x }
16:05:42 <benmachine> tomh: it doesn't show the same as the underlying type, because of the constructor
16:05:47 <michie1> ah, good point, upper case denotes a class, doesn't it?
16:05:50 <tomh> yeah ok
16:06:02 <copumpkin> michie1: classes and types
16:06:04 <michie1> copumpkin: no, he's made a pretty interesting point, it's an IMAPConnection Handle
16:06:12 <michie1> and I'd assumed Handle to be the variable
16:06:31 <copumpkin> well, if SomethingOrOther had been a monad, there's not much meaning to getting it out
16:06:32 <kyagrd> FunctorSalad_: by the way how did you ran testing real input files from TPTP? is there a more deatiled document?
16:06:35 <copumpkin> since it's a type constructor and not a base type
16:06:56 <monochrom> @quote monochrom sperm
16:06:56 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
16:07:06 <monochrom> preflex: @quote monochrom sperm
16:07:06 <preflex>  no quotes found for monochrom
16:07:34 <kyagrd> FunctorSalad_: I figured out how to do randomized testing with QuickCheck stuff but I haven't yet tried running the TPTP examples
16:07:39 <michie1> say, with this type signature: connectIMAP :: String -> IO (IMAPConnection Handle)
16:07:51 <michie1> that returns a handle inside the IMAPConnection monad inside the IO monad, right?
16:08:02 <michie1> unless IMAPConnection is a type constructor
16:08:04 <FunctorSalad_> kyagrd: hmm I do seem to remember testing "parse . print . parse == parse" against the tptp example package, and "parse . print == id" against random quickcheck formulae
16:08:17 <copumpkin> michie1: I wouldn't talk about "The IMAPConnection Monad"
16:08:45 <michie1> copumpkin: I've no idea what it is
16:08:53 <monochrom> The meaningful name "IMAPConnection" does not tell us anything.
16:08:54 * copumpkin believes in eradicating "The X Monad" from most usage
16:09:10 <michie1> resists easy understanding => must be a monad!
16:09:15 <copumpkin> :)
16:09:27 <benmachine> monads are easy
16:09:32 <benmachine> if I say it enough times it will become true
16:09:38 <monochrom> "is it a type constructor" and "is it a monad" are independent.
16:09:39 <gwern> copumpkin: but the X monad is a shining example of a useful monad transformer!
16:09:45 <gwern> dons has made so much hay with it
16:09:46 <michie1> monochrom: hmm, thanks
16:09:51 <PirateUnderwear> :)
16:09:53 <monochrom> or rather, are not mutually exclusive.
16:10:00 <FunctorSalad_> kyagrd: it should be in testing/TestImportExportImportFile.hs
16:10:26 <michie1> monochrom: I sometimes believe it's Haskell syntax that has me stumped more than the conceptual aspects.
16:10:28 <kyagrd> FunctorSalad_: okay.  I was able to build the binary and run one of them for random testing and trying to run the other one for real inputs.
16:10:33 <kyagrd> I'll take a look
16:10:42 <copumpkin> michie1: the syntax is pretty spartan :P
16:10:46 <michie1> exactly
16:10:50 <IceDanelol> So I've got a parser that returns Either String :r
16:10:50 <llambda> A tree traversal would obviously be O(n) where n is the number of nodes in the tree, right?
16:10:54 <IceDanelol> eh, ignore that for a sec
16:11:00 <monochrom> (I do not believe in "concept" "semantics" free of syntax.)
16:11:31 <IceDanelol> So yeah, i've got a parser that returns Either ParseError a, and I'd like to basically do nothing on ParseError
16:11:35 <IceDanelol> e.g. return () or some such
16:11:41 <FunctorSalad_> why wouldn't IMAPConnection be a monad..?
16:11:47 <IceDanelol> I'm in a monad
16:11:52 <copumpkin> FunctorSalad_: never said it wouldn't be, but we have no evidence that it is
16:11:57 <copumpkin> so, why would it be? :)
16:12:00 <Olathe> IceDanelol: I think either can be used for that.
16:12:03 <Olathe> @type either
16:12:03 <IceDanelol> using either (somethingHereThatDoesNothing) (parseHandler)
16:12:04 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:12:04 <FunctorSalad_> I'd expect it to be something like ReaderT SomeSessionData IO
16:12:05 <kyagrd> FunctorSalad_: and, I am now trying to implement the parser to handle "system comments", which will be a more major change.  The recent one I made was just ignoring all the comments between the tokens in the formulae
16:12:06 <monochrom> It's a meaningful identifier.
16:12:19 <IceDanelol> Olathe: I'm already using either, but I'm really not sure what to do to make it just .. do nothing, heh
16:12:30 <FunctorSalad_> (SomeSessionData containing IORefs if it has to change)
16:12:32 <IceDanelol> It won't compile
16:12:34 <monochrom> (And yes I'm being sarcastic about meaningful identifiers.)
16:12:37 <Olathe> IceDanelol: Oh, what type is the parseHandler?
16:12:52 <IceDanelol> oh, of course
16:12:53 <IceDanelol> that's it
16:12:55 <IceDanelol> thanks!
16:13:01 <Olathe> IceDanelol: You're welcome.
16:13:15 * ddarius doesn't understand why people want to make monads so often.
16:13:35 <monochrom> AFAIK it may as well be called EnterpriseBusinessModelSynergism
16:13:35 * gwern resists the 'play' joke
16:13:38 <FunctorSalad_> kyagrd: are you saying "system comments" aren't comments after all and are semantically important or..?
16:14:24 <FunctorSalad_> a ReaderT or StateT for session data actually seems like a decent monad to me
16:14:51 <monochrom> If you don't like to use the reader monad, you can use the reader applicative instead.
16:14:54 <kyagrd> FunctorSalad_: well in TPTP syntax spec there are system comments that the implementation can use (it's up to implementation) and it has a syntax of starting with %$$ or something like that
16:15:23 <FunctorSalad_> heh
16:15:31 <michie1> monochrom: so, you're saying, unless there's a library provided function that gets Handle out of IMAPConnection (whatever it may be), the contents of IMAPConnection are encapsulated and inaccessible, even though the type of the contents is known?
16:15:35 <kyagrd> In contrast to normal comments which is for human reading only 
16:15:43 <FunctorSalad_> that's creative :) (%$$)
16:15:51 <michie1> (no, you weren't saying that, I'm trying to draw conclusions from what people have said in general)
16:15:56 <monochrom> perhaps
16:16:25 <FunctorSalad_> michie1: an example of a monad where it's clearly impossible is the trivial monad: data Trivial a = Trivial
16:16:31 <benmachine> michie1: well, the fact that IMAPConnection Handle has 'Handle' in the type does not in fact guarantee that the type contains a Handle
16:16:32 <monochrom> It's really wonderful we can discuss the nature EnterpriseBusinessModelSynergism uninformed.
16:16:37 <kyagrd> FunctorSalad_: And, I actually need that kind of feature since I am trying to automate testing and it is very useful if you can put system comments hinting which logic variable corresponds to which type in a model (such as Integer, Boolean, etc) 
16:16:42 <monochrom> Sorry, I mean IMAPConnection
16:16:43 <benmachine> michie1: uhh, that the value contains a Handle
16:16:53 <benmachine> certainly not that it contains only one Handle
16:16:58 <FunctorSalad_> (impossible to get, say an Int out of Trivial Int)
16:17:10 <michie1> benmachine: uh, okay.
16:17:17 <michie1> monochrom: it's in HaskellNet.IMAP
16:17:30 <benmachine> michie1: it's like, if you have a type [Handle], it might be []
16:17:47 <michie1> benmachine: hmm, I see.
16:17:51 <benmachine> or if you have Maybe Handle it might be Nothing
16:18:00 <IceDanelol> hmm, Olathe, actually, the types match fine
16:18:21 <IceDanelol> For the sake of not having to get into details, either returns IO ()
16:18:23 <michie1> benmachine: that's a good counterexample, thanks
16:18:35 <IceDanelol> I just want to 'do nothing' instead of ,say, printing the parser error
16:19:48 <benmachine> IceDanelol: what was wrong with return ()?
16:20:14 <IceDanelol> benmachine: It doesn't seem to want to work, heh
16:20:25 <benmachine> IceDanelol: tiny tiny bit more specific?
16:20:47 <IceDanelol> Well, "Couldn't match expected type '()' against inferred type 'Net ()'"
16:20:57 <IceDanelol> I tried explictly specifying type, etc
16:21:20 <benmachine> IceDanelol: can you paste the code in question?
16:21:36 <IceDanelol> benmachine: It's a bit of code, but I'll try to whip up an example
16:21:58 <benmachine> IceDanelol: well, just that function, or just that bit of it
16:22:15 <benmachine> IceDanelol: what happens in the second argument of the either?
16:23:25 <IceDanelol> benmachine: this is basically what it looks like, at its current state: either print handler $ parse someParser  "foo" "par"
16:23:30 <copumpkin> while I like the idea of monad transformers, in practice the approaches I've seen make me feel a little icky
16:23:32 <copumpkin> is it just me?
16:23:52 <IceDanelol> so on parser error, it is just printed, and I'd like to avoid doing that
16:23:54 <benmachine> IceDanelol: ohh, how about either (const $ return ()) handler
16:24:22 <benmachine> or, for added entertainment value, either (liftM return return ())
16:24:32 <IceDanelol> o.o
16:24:35 <IceDanelol> benmachine: const worked
16:24:38 <IceDanelol> but what's going on here?
16:24:38 <benmachine> yeah
16:24:41 <benmachine> either expects a function!
16:24:42 <IceDanelol> I'm really not following
16:24:45 <benmachine> in each argument
16:24:46 <IceDanelol> I see
16:24:47 <benmachine> return () is a value
16:24:55 <IceDanelol> Yes, well
16:24:58 <IceDanelol> I thought about that before
16:25:08 <IceDanelol> And then I did: either (\a -> return ()) effectively ignoring the parameter
16:25:12 <IceDanelol> but that didn't work either
16:25:16 <benmachine> yes it did
16:25:18 <benmachine> <_<
16:25:20 <IceDanelol> o.o
16:25:20 <benmachine> it's equivalent
16:25:20 <IceDanelol> sec
16:25:28 <benmachine> it'll give you warning: unused a
16:25:31 <benmachine> but apart from that
16:25:38 <IceDanelol> wat.
16:25:39 <IceDanelol> now it works
16:26:14 <IceDanelol> well, thanks!
16:28:52 <benmachine> :P
16:30:14 <IceDanelol> see, that's why I need to write more haskell
16:30:19 <IceDanelol> I would never have thought of const
16:31:24 <gwern> I think hlint would tell you
16:31:30 <IceDanelol> ah, yes, I need to get that
16:31:33 <IceDanelol> forgot about that
16:32:38 <IceDanelol> hlint is what hpaste uses, right?
16:32:59 <kmc> yeah
16:33:15 <IceDanelol> I definitely need that then
16:33:34 <gwern> it's a very new feature in hpaste
16:33:42 <IceDanelol> It's a very cool feature
16:34:42 <kmc> hlint and ghc -Wall
16:34:46 <kmc> my friends forever
16:35:02 <IceDanelol> Yep, I put ghc -Wall on a while ago
16:35:23 <gwern> those #haskellers see me rolling, be tryin' catch me writing dirty
16:35:51 <kmc> they hatin
16:35:58 <kmc> tryin to catch me writing qwerty
16:36:12 <copumpkin> :o
16:36:17 <copumpkin> omar comin yo
16:36:48 * kmc ♥ omar
16:37:29 <omarlittle> kmc: don't love me too hard, might get yourself killed
16:37:35 <kmc> :O
16:38:45 <aristid> copumpkin: how did you predict that omarlittle was coming?
16:38:54 <pumpkin> I heard the whistling
16:38:58 <pumpkin> you didn't?
16:39:19 <aristid> um
16:39:25 <kmc> the farmer in the dell
16:39:26 <gwern> pumpkin: humans can't hear it. only dawgs
16:39:32 * benmachine lols
16:39:39 * kmc gets out his hair-on and honey nut cheerios as a peace offering
16:41:10 <michie1> just another stupid line of reasoning, but say I have a library that implements a network protocol by wrapping functions around low-level IO functions (hPut, hGet, etc.).  Say I want to coerce this library into using something like, GnuTLS.hGet instead of bog standard hGet.  Am I correct in understanding that the library, as compiled, is linked to the standard hGet, and it's not possible to trick it by wrapping an IO handle around it and faking the interf
16:41:38 <benmachine> michie1: your line got cut off at "faking the interf"
16:41:42 <michie1> (this can be done in lisp, or javascript, the latter of which I've been programming in rather extensively recently, but both are very dynamic languages)
16:41:53 <michie1> benmachine: you missed "ace?"
16:42:00 <benmachine> michie1: yes :P
16:42:09 <benmachine> but I didn't know I hadn't missed more
16:42:19 <benmachine> you're right though, the library is linked to a function and you can't link it to a different one
16:42:22 <kmc> michie1, it's not possible in standard GHC Haskell
16:42:23 <michie1> benmachine: that's why I told you what you missed
16:42:30 <gwern> > 50000 / 0.05
16:42:31 <lambdabot>   1000000.0
16:42:45 <kmc> you might could do it by modifying GHC, or by munging the binary code of that library
16:42:48 <kmc> or other linker tricks
16:42:52 <kmc> but it won't be pretty
16:42:56 <michie1> kmc: thanks, okay.  That's not a problem, it's just interesting to know.  And it seems so many things *are* possible that it's often hard to tell what is and what isn't.
16:42:58 <benmachine> michie1: yes but then I felt silly because honestly I could have guessed those four characters so I went on a campaign to clear my name
16:43:02 <kmc> yeah
16:43:15 <benmachine> michie1: if the library wanted to co-operate, it could parametrise over those functions somehow
16:43:21 <kmc> perhaps it would be easier if the other library were loaded as GHCi bytecode rather than native code
16:43:29 <kmc> might could use ghc api then
16:43:40 <benmachine> michie1: it could, for example, use a class MyOperations where hGet :: IO Stuff;
16:43:44 <benmachine> etc. etc.
16:43:48 <benmachine> with an instance for IO
16:43:49 <kmc> eh, class overuse ;P
16:43:49 <benmachine> er
16:43:55 <kmc> i would first just pass a record of functions
16:43:55 <megajosh2> Couldn't you just
16:44:01 <megajosh2> import System.IO hiding (hGet)
16:44:03 <megajosh2> ?
16:44:04 <benmachine> record of functions works too
16:44:06 <benmachine> slash better
16:44:11 <kmc> megajosh2, that doesn't affect an already compiled library
16:44:17 <megajosh2> OH okay
16:44:25 <kmc> (or anything outside this module)
16:44:33 <kmc> the class might be better depending, but not having seen the library my "default" choice is to pass a record of functions / operations
16:45:24 <michie1> and there probably should be a high level IO class to allow people to implement their own tcp-ip-via-carrier pidgeon functionality and whatnot.
16:45:36 <michie1> (I mean, such a thing probably exists already, right?)
16:47:44 <benmachine> that's kernel-level stuff, your application shouldn't care about what particular avian communication system was used
16:48:11 <michie1> tsk, lots of Operating systems don't implement tcp/ip in kernelspace
16:48:15 <michie1> like, uh, BSD 2.11
16:48:16 <djahandarie> Is there another ASCII symbol for (.) if I'm using that for other purposes?
16:48:27 <djahandarie> (Function composition I mean)
16:49:04 <kmc> michie1, they may not implement it in kernel space, but they should provide a way to transparently plug in new stacks
16:49:19 <kmc> e.g. linux TUN/TAP, which lets you do userspace implementation of IP and Ethernet and provide it as an ordinary interface
16:49:29 <IceDane> Wow. hlint just beat the living shit out of my code
16:49:30 <kmc> ascii :/
16:49:30 <IceDane> ouch.
16:49:33 <kmc> maybe (@) djahandarie?
16:49:38 <kmc> i don't know of another "conventional" one
16:49:41 <djahandarie> Hm
16:49:42 <kmc> perhaps (<<<)
16:49:48 <aavogt> @ isn't legal by itself
16:49:50 <kmc> :t (Control.Arrow.<<<)
16:49:51 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:49:52 <gwern> IceDane: you'll come to like it
16:49:54 <djahandarie> This isn't Haskell by the way
16:49:58 <djahandarie> Just a text file
16:50:01 <kmc> ah
16:50:05 <gwern> except for a few hints like eta reduction abd brackets
16:50:08 <kmc> why isn't it haskell
16:50:12 <kmc> ;P
16:50:17 <IceDane> gwern: I do like it
16:50:17 <djahandarie> Because this is some dumb assignment for my CS class
16:50:28 <djahandarie> I don't want to encode it in UTF-8 because I don't know if that'll blow up the TA's computer or not
16:50:41 <Jafet> You don't get extra marks for doing that?
16:50:42 <djahandarie> I guess I could e-mail him
16:50:56 <djahandarie> Haha
16:51:28 <aavogt> o is function composition
16:51:30 <gwern> do it in ASCII. then it'll be UTF-8 whether you like it or nae
16:52:01 <djahandarie> I suppose o works
16:52:10 <aavogt> it's done in a real language too I think
16:52:10 <robogeoff> newbie question: how do i link a library using GHC?
16:52:24 <robogeoff> i am trying to hack on a cabal package
16:52:31 <gwern> --make?
16:52:41 <robogeoff> hmm
16:53:07 <benmachine> `o`
16:53:24 <Olathe> # link three .o files into an executable called "test":
16:53:24 <Olathe> % ghc -o test Foo.o Bar.o Baz.o
16:53:41 <djahandarie> benmachine, I don't know if a Haskellism would make things clear
16:53:52 <benmachine> djahandarie: oh yeah, sorry
16:53:59 * benmachine thinking of something else
16:54:08 <djahandarie> I think I'll just do    F o G
16:54:13 <djahandarie> Fog. :P
16:54:14 <kmc> robogeoff, if you are invoking ghc manually, you should almost certainly use --make
16:54:19 <kmc> in fact it will be the default in GHC 7.0
16:54:34 <monochrom> f ∘ g
16:54:36 <robogeoff> http://hpaste.org/40229/x
16:54:37 <benmachine> if you had iso-8859-1 you could use ·
16:54:38 <Olathe> kmc: Oh, cool.
16:54:41 <robogeoff> i am getting that kind of thing
16:54:48 <monochrom> f · g
16:55:04 <djahandarie> I'll just e-mail him about UTF-8
16:55:53 <monochrom> send UTF-8. and include this link http://www.vex.net/~trebla/symbols/refute-anti-unicode.html :)
16:56:20 <kmc> take a screenshot and send a jpg
16:56:30 <djahandarie> LaTeX it and put it in a PDF?
16:56:41 <monochrom> if he doesn't use 1970s email software, chances are his email just handle it transparently
16:57:01 <djahandarie> It isn't e-mail, it is through some shite online system thing-a-ma-bomber
16:57:28 <monochrom> the problem with latex-pdf is it is not exactly copy-and-pastable. if you copy-and-paste, you get garbled symbols
16:57:39 <pikhq> monochrom: It'll be MIME encoded, so it'll either be transparently handled or be pretty obviously base64.
16:58:08 <pikhq> (UTF-8 is not 7-bit clean, and hence must be base64'd)
16:58:12 <monochrom> not necessarily base64. quote-printable exists. in fact thunderbird prefers it
16:58:20 <djahandarie> Oh man, but if I have UTF-8 now I can use all sorts of sweet symbols
16:58:25 <pikhq> Ah, yeah, that's also possible.
16:58:28 <djahandarie> This is a dangerous path...
16:58:31 <pikhq> Still, it'll be pretty obviously MIME'd.
16:58:32 <pikhq> :)
16:58:35 <monochrom> yes
16:59:17 <monochrom> all the infrastructures are in place to handle it. we are not talking about ebcdic.
16:59:59 <djahandarie> gwern, where is your neat little utf-8 searching thing at?
17:00:08 <gwern> my what?
17:00:26 <monochrom> perhaps he means unicode searching thing
17:00:27 <djahandarie> Didn't you have something to look up UTF-8 characters by their name? Or was that someone else...
17:00:30 <djahandarie> Oh
17:00:32 <djahandarie> mauke
17:00:33 <IceDane> Hmm
17:00:48 <monochrom> you can always try unicode.org
17:01:05 <djahandarie> I don't want to figure out how the hell to navigate their site
17:01:08 <IceDane> Isn't it a bit strange of hlint to recommend that I use the evil fromJust instead of if something /= Nothing then do stuff else return () ?
17:01:11 <IceDane> that's dangerous stuff
17:01:18 <monochrom> heh ok
17:01:27 <kmc> it really recommends fromJust there?
17:01:31 <IceDane> oh, nevermind
17:01:34 <kmc> it should recommend pattern-matching, fromMaybe, or maybe
17:01:35 <IceDane> it's recommending when
17:01:36 <IceDane> lol.
17:01:41 <IceDane> didn't scroll up 
17:02:30 <IceDane> e.g. when (something /= Nothing) do stuff
17:05:16 <IceDane> wow, hlint is seriously awesome
17:05:37 <robogeoff> hmm, --make doesn't help
17:05:39 <robogeoff> http://hpaste.org/40230/foo
17:05:42 <robogeoff> that has -v turned on
17:05:52 <IceDane> Is it analyzing the code and functions' types to see how it can find equivalents or something like that or is it just perusing a massive database of common errors?
17:06:12 <gwern> IceDane: database
17:06:15 <IceDane> gwern: ah
17:06:20 <gwern> for example, IIRC I suggested the when match
17:06:20 <kmc> robogeoff, do you have the language-c package installed?
17:06:22 <kmc> cabal install language-cr
17:06:23 <kmc> err
17:06:24 <kmc> cabal install language-c
17:06:39 <robogeoff> yeah, i don't want to install it :) i am hacking it
17:06:41 <kmc> or is that what you're trying to build?
17:06:42 <kmc> ah
17:06:45 <kmc> then can you use its cabal file?
17:06:47 <kmc> cabal build
17:06:49 <gwern> IceDane: it might be interesting to see what Hoogle could do, but I would expect it to turn up too many false positives to be useful
17:06:53 <robogeoff> how do i do that?
17:07:01 <robogeoff> i mean, i am building it
17:07:04 <kmc> $ cabal build
17:07:06 <robogeoff> i get a .a and .o file
17:07:15 <kmc> then you want to test it?
17:07:21 <robogeoff> but now i want to link those files to a test harness
17:07:22 <robogeoff> yes
17:07:24 <robogeoff> exactly
17:07:24 <kmc> http://mainisusuallyafunction.blogspot.com/2010/09/ghci-and-cabal.html
17:08:18 <IceDane> gwern: Yeah
17:08:26 <robogeoff> ah, that looks good!
17:08:30 <robogeoff> let me try it
17:08:36 <robogeoff> kmc thanks!
17:09:44 <robogeoff> that works!  almost...
17:09:55 <robogeoff> it is saying my new module is hidden
17:10:01 <robogeoff> how do i make it unhidden?
17:10:30 <IceDane> Heh: found: [take n l] ++ groupInto n (drop n l) why not: (take n l) ... then found: (take n l) : groupInto .. why not: take n l : groupInto .. 
17:10:38 <robogeoff> i really should rtf cabal m
17:10:39 <robogeoff> heh
17:12:59 <robogeoff> ok i got it, had to move the module from under Other-Modules: to Exposed-Modules
17:13:07 <robogeoff> thanks kmc!
17:18:27 <pumpkin> kmc: how did you fetch all the logs for your #haskell logs post?
17:18:54 <pumpkin> kmc: and have you considered sticking them in a database or at least putting a fulltext index on them?
17:19:14 <gwern> pumpkin: I imagine he just downloaded them from tunes
17:19:17 <gwern> maybe with wget
17:19:47 <pumpkin> last time I tried I had some trouble doing that cause none of the files have an extension and it seems tough to convince wget to recursively grab extensionless files
17:19:52 <pumpkin> but maybe I'm just dumb :)
17:20:06 <pumpkin> not that it'd be hard to write a custom fetcher
17:21:03 * hackagebot xilinx-lava 5.0.0.7 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.7 (SatnamSingh)
17:27:14 <kmc> pumpkin, i fetched them with a dumb wget / shell script
17:27:17 <kmc> i might clean that up and publish it
17:27:30 <kmc> wget -q -O- http://tunes.org/~nef/logs/haskell/ | grep '/icons/unknown.gif' | cut -d'=' -f5 | cut -d'"' -f2 | egrep '^10\.09' | (while read x; do echo "http://tunes.org/~nef/logs/haskell/"$x; done) | xargs wget -c
17:27:43 <kmc> tune the grep to get stuff you haven't fetched yet
17:27:51 <pumpkin> ah cool :)
17:27:53 <kmc> pumpkin, i considered making a webapp to search them
17:28:14 <kmc> i was kind of hoping that someone else (*cough* chrisdone *cough*) would do it, after i'd made it easy to access the data
17:28:19 <pumpkin> lol
17:32:49 <ddarius> pumpkin: Why didn't you just write a Haskell program to do it?
17:33:26 <copumpkin> it would've taken longer than the one minute I'd hoped for :)
17:33:28 <copumpkin> maybe even two
17:34:33 <benmachine> @djinn Host -> IO [IRCLog]
17:34:33 <lambdabot> Error: Undefined type Host
17:34:35 <benmachine> :(
17:34:48 <gwern> djinn doesn't do listz
17:35:23 <benmachine> about the only thing I had there it *does* do is ->
17:35:40 <benmachine> but one can dream
17:35:41 <aavogt> franz, ze liszt!
17:36:02 <ddarius> copumpkin: How long did you spend failing to do it with wget?
17:36:13 <copumpkin> about one and a half
17:37:19 * gwern feels embarassed on copumpkin's behalf
17:37:23 <copumpkin> :P
17:39:08 * hackagebot atomo 0.1 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.1 (AlexSuraci)
17:39:42 <alexsuraci> sweet, first hackage upload. :)
17:40:00 * alexsuraci still needs to put darcsden on there
17:40:34 <benmachine> very fun, eh
17:40:39 <benmachine> are there pretty colours?
17:41:07 <alexsuraci> the site had some but it's down atm ;)
17:41:18 <benmachine> aw
17:41:21 * benmachine no longer interested
17:41:22 * ddarius is an idiot.
17:42:05 <benmachine> ddarius: no you're not
17:42:12 <alexsuraci> hm, there's a Repository field for cabal right?
17:42:22 * benmachine lacks an imaginative way of paying a compliment and so goes with direct
17:42:32 <benmachine> alexsuraci: Source-Repository section
17:42:34 * alexsuraci checks the docs
17:42:52 <benmachine> alexsuraci: http://hackage.haskell.org/packages/archive/th-lift/0.5.2/th-lift.cabal for example
17:42:52 <alexsuraci> ah. oh well, i'll fix that in the next upload. right now I just use the homepage field.
17:42:58 <benmachine> well
17:42:58 <alexsuraci> thanks
17:42:59 <ddarius> > 0x2000 * 1024
17:43:00 <lambdabot>   8388608
17:43:15 <benmachine> if you do include one, you need to do Cabal-Version: >= 1.6
17:43:21 <benmachine> but
17:43:42 <benmachine> you can install 1.6 on GHC 6.8 so unless you're super-compatibility-inclined that's probably not a problem
17:43:50 <alexsuraci> no biggie
17:45:12 <ddarius> > 2^32
17:45:13 <lambdabot>   4294967296
17:47:33 <dibblego> can anyone recommend a resource to introduce someone to do-notation?
17:47:59 <benmachine> dibblego: in general, or specifically for IO?
17:48:03 <dibblego> general
17:48:22 <dibblego> I've been teaching haskell weekly for 5 months and we still haven't seen IO :)
17:48:29 <benmachine> heh
17:48:30 <ddarius> The Report.
17:48:35 <benmachine> do you *need* do?
17:48:51 <dibblego> we will be using do-notation for a monadic parser
17:50:02 <dibblego> I really wish my company would let me open source all this material -- I really think it's the winning formula for teaching
17:51:20 <ddarius> dibblego: Why don't they?  What's the value proposition for them?
17:52:20 <dibblego> our project manager is fighting fiercely for open source in general; I'm not clear on the value proposition for them, but I may still wish :)
17:53:01 <ddarius> dibblego: Have you asked yet?
17:53:32 <dibblego> I know there is a serious aversion to open source in general and many people are fighting hard for it, so I'm waiting for that to be resolved, but I've mentioned it in passing
17:55:29 <ddarius> I would imagine you would be releasing instruction materials not code.
17:55:46 <gwern> dibblego: what makes the material so good?
17:56:02 * ddarius suspects the secret ingredient is the 20 days rather than 20 minutes.
17:56:37 <dibblego> it's incomplete code with exercises
17:57:15 <djahandarie> Directing logic people to -blah to answer my question :P
17:57:40 <dibblego> I think the material is good because of the way the progression works; nobody is left behind, we are writing monad libraries and what-not without the usual strong aversion
17:58:36 <dibblego> I have eschewed the common question, "but how do I actually get anything done?" (i.e. where is IO?)
17:58:47 <dibblego> I have successfully delayed that question
17:59:45 <aavogt> 20 days is enough to follow a good portion of the tutorials / books out there
17:59:56 <kmc> what's the value proposition to *not* opening it?
18:00:27 <dibblego> it's code that any haskell programmer can write, so I really do not know
18:00:51 <itrekkie> how would you guys go about merging an array of arrays into a single array?
18:01:01 <dibblego> join?
18:01:11 <itrekkie> sounds promising, I'll look it up
18:01:28 <dibblego> I rarely use arrays, but at least that answers applies to m (m a) -> m a for some values of m
18:01:55 <BrianHV> :t concat
18:01:56 <lambdabot> forall a. [[a]] -> [a]
18:02:13 <dibblego> concat = join -- specialised to []
18:02:17 <aavogt> arrays have bounds which probably stops you from having a Monad instance
18:02:31 <dibblego> right
18:02:46 <BrianHV> :t join
18:02:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:04:02 <copumpkin> aavogt: the bounds would make me think you actually could have one
18:04:14 <copumpkin> assuming the bounds are equal 
18:04:28 <itrekkie> concat works beautifully, I couldn't find the docs on join 
18:04:33 <dibblego> ddarius, I can only see 3.14 in the report which I don't think I'd use
18:04:44 <dibblego> itrekkie, concat won't work for arrays (do you have a list?)
18:05:20 <itrekkie> dibblego: haha yes I do, can you tell I'm coming from C and friends?
18:05:36 <itrekkie> I actually wasn't aware there were arrays in Haskell, dunno what I was thinking
18:05:46 <dibblego> itrekkie, ah right, you'll find join in Control.Monad but concat will work too
18:06:19 <dibblego> the difference is that join will work for more than just lists, while concat is list-specific
18:06:41 <BrianHV> why is the specialization needed?
18:06:42 <gwern> kmc: general business paranoia? no one was ever fired for not open-sourcing stuff
18:06:48 <kmc> > join (Just (Just 3))
18:06:49 <lambdabot>   Just 3
18:06:49 <BrianHV> or did the specialization come first?
18:07:29 <dibblego> BrianHV, sometimes having a specialised function with a different name can help, but I think the only reason is historical
18:07:46 <aavogt> specialized types are easier to understand
18:07:50 <aavogt> and debug too
18:08:13 <aristid> BrianHV: consider having to teach somebody the monad laws as soon as he wants to concatenate lists
18:08:38 <BrianHV> aristid: good point.
18:08:50 <aavogt> aristid: you don't since that doesn't require anybody to write any instance
18:08:53 <dibblego> I have a library in Scala where there is no concat or join, but there is μ
18:09:23 <ddarius> µ is join
18:09:53 <dibblego> prexactly :)
18:11:31 <aavogt> making a language/library easier to learn is not a historical reason
18:12:18 <benmachine> I thought μ was something to do with fixed points
18:13:00 <dolio> It's that, too.
18:13:05 * aavogt is deprived of non-ascii
18:14:11 <itrekkie> okay, so today here I learned about $ and how I can avoid the parens and still get the right associativity, is this a normal thing to use quite often?  
18:14:43 <dibblego> yes it's quite common
18:15:18 <itrekkie> I thought it would look odd, but it saves me from counting the parens, and I like it 
18:15:40 <Jafet> `dwiw`
18:22:35 <mjrosenb> itrekkie: sort of.  i've heard that you should avoid using $ more than once
18:22:42 <mjrosenb> replacing other uses of it with .
18:23:00 <Veinor> yeah
18:23:09 <Veinor> don't use f $ g $ x, use f . g $ x
18:23:14 <mjrosenb> so a ( b ( c ( d e ) ) ) => a . b . c . d $ e
18:23:49 <ooooPsss> hey. when it comes to running speed, how does Haskell compares with others?
18:24:02 <mjrosenb> ooooPsss: "depends on the workload"
18:24:23 <aavogt> @faq can haskell run around the block faster than you?
18:24:23 <lambdabot> The answer is: Yes! Haskell can do that.
18:24:58 <ooooPsss> mjrosenb: any benchmark?
18:25:08 <ooooPsss> aavogt: ty
18:25:13 <aavogt> @where shootout
18:25:14 <lambdabot> http://shootout.alioth.debian.org/
18:26:03 <mjrosenb> @faq can haskell run faster than haskell?
18:26:03 <lambdabot> The answer is: Yes! Haskell can do that.
18:26:08 <Jafet> My haskell broke a record, but they disqualified it for using monoids.
18:26:09 <mjrosenb> <3 faq
18:26:26 <mjrosenb> Jafet: wait what now?
18:26:27 <aristid> @hoogle a -> (a -> b) -> b
18:26:27 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:26:27 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:26:27 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:26:40 <aristid> lambdabot: no, i want it with the argument flipped
18:26:50 <ooooPsss> can I compare haskell with node.js or that doesn't make any sense? 
18:27:00 <aristid> ooooPsss: it doesn't make any sense :D
18:27:09 <ooooPsss> ok, thought so :p
18:27:15 <benmachine> Jafet: wat
18:27:34 <benmachine> aristid: flip it then >_>
18:27:44 <aristid> benmachine: yeah i was just wondering if it had a name
18:27:45 <Jafet> @pl flip ($)
18:27:45 <lambdabot> flip id
18:27:59 <byorgey> ooooPsss: Haskell, the language, has no inherent speed.  GHC, the most mature Haskell compiler, compiles Haskell to native code which is generally quite fast.
18:28:27 <benmachine> JHC can be faster sometimes, allegedly!
18:28:27 <ooooPsss> ty. what are the best use cases for Haskell? I'd like to give it a try
18:28:36 <kmc> ooooPsss, http://shootout.alioth.debian.org/
18:28:39 <aristid> :t flip
18:28:40 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:28:53 <kmc> you can compare the two, not on speed, but on programming style
18:29:03 <kmc> my understanding is that node.js encourages a totally callback / event-driven style
18:29:06 <kmc> which you can certainly do in Haskell
18:29:09 <benmachine> ooooPsss: it's a general-purpose language so it should be able to do most things, but in my opinion it's particularly good at constructing parsers
18:29:10 <byorgey> ooooPsss: it's a general purpose language that can be used productively for a wide variety of things.
18:29:16 <kmc> but you can also spawn threads easily and cheaply in GHC Haskell
18:29:18 <byorgey> @lyah
18:29:18 <lambdabot> Unknown command, try @list
18:29:21 <byorgey> @where lyah
18:29:21 <lambdabot> http://www.learnyouahaskell.com/
18:29:23 <byorgey> @where rwh
18:29:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:29:27 <kmc> so you don't *need* to invert control flow for performance reasons, if you'd rather have concurrency
18:29:29 <byorgey> ooooPsss: ^^^^ check out those to start.
18:29:43 <ooooPsss> ok, I will. ty
18:30:18 <byorgey> Haskell Symposium tomorrow, woo!
18:30:22 <ooooPsss> is Haskell used for Web apps? 
18:30:25 <benmachine> yes
18:30:35 <kmc> ooooPsss, sometimes.  there's quite a few frameworks
18:30:38 <aristid> ooooPsss: that you don't need to invert control flow can be a stab at node.js btw
18:30:41 <byorgey> @where snap
18:30:50 <aristid> http://www.snapframework.com
18:30:57 <tg_> not as adopted-ly and mature as some of the "major" frameworks, but in many cases much more clever and interesting
18:30:58 <kmc> snap, happstack, yesod
18:31:00 <byorgey> @where yesod
18:31:00 <lambdabot> I know nothing about yesod.
18:31:02 <kmc> others too
18:31:08 <kmc> ooooPsss, http://hackage.haskell.org/packages/archive/pkg-list.html
18:31:12 <kmc> if you look at that list of libraries and programs
18:31:17 <kmc> you can see the variety of what people use Haskell for
18:31:25 <ooooPsss> is snap the most famous one? I remember reading about other framework
18:31:31 * fryguybob is excited about the Haskell Symposium.
18:31:33 <kmc> snap is newer
18:31:35 <ooooPsss> kmc: yx
18:31:41 <ooooPsss> what's the older?
18:31:45 <kmc> happstack is older
18:31:49 <kmc> don't know about yesod
18:31:51 <aavogt> wash
18:32:55 <kmc> Haskell is a good language for a variety of things
18:33:03 <kmc> it is probably easier to answer what it's *not* good for
18:33:20 <c_wraith> It's really not very good for GUI apps at the moment.
18:33:26 <dark> kmc, what is not good for?:)
18:33:31 <dark> it is
18:33:32 <c_wraith> Mostly library issues with that.
18:33:37 <kmc> not good for extremely latency-sensitive applications -- something that needs to talk to the stock market with a lag of 10 microseconds
18:33:54 <c_wraith> kmc: amusingly, it's used for that purpose quite a lot
18:33:57 <kmc> similarly realtime audio / video (but the latency requirements are much looser there)
18:33:59 <kmc> c_wraith, oh?
18:34:09 <c_wraith> a LOT of automated trading software is written in haskell
18:34:12 <kmc> i remember the tsuru capital guys talked about caring about milliseconds, not microseconds
18:34:18 <kmc> c_wraith, link?
18:34:25 <kmc> i know about tsuru and i know that allston is looking
18:34:32 <c_wraith> It's been talked about on -cafe a lot
18:34:36 <kmc> in my time in HFT i never heard of any shops using Haskell
18:34:49 <tg_> well get with the times!
18:34:51 <kmc> anyway I think it would be good for things like code generation in those domains
18:34:58 <kmc> i would, if anyone would give me a link
18:35:01 <aristid> damn jrockway is not online :D
18:35:09 <kmc> instead of just saying "my brother's dog totally wrote a stock thingamijigger in Haskell"
18:35:15 <dark> kmc, I think it is easier to write correct and fast code with some inner core in C or asm if needed and the rest on a more powerful language, than write everything on low level
18:35:20 <kmc> yeah dark
18:35:26 <kmc> and it's good to generate that C / asm from a Haskell EDSL
18:35:30 <kmc> which is then not in the critical path
18:35:35 <kmc> http://hackage.haskell.org/package/atom works that way
18:35:55 <kmc> ooooPsss, Haskell is also not a good choice if you want to hire armies of Java programmers to write / maintain your app
18:35:56 <ooooPsss> it doesn't seem to be very used in production
18:36:03 <aristid> kmc: shouldn't it be possible to get the ghc runtime to provide some guarantees with the gc?
18:36:09 <kmc> it's really best suited for small-group projects
18:36:16 <kmc> aristid, i don't know
18:36:52 <dark> it is said that you can't write some kinds of code in haskell [ when you need to care about cache misses, heap-allocated memory, .. ]
18:37:10 <kmc> yeah
18:37:15 <kmc> you can write that code in C and call it from Haskell
18:37:17 <kmc> to some degree
18:37:40 <tg_> haskell is great if you want to understand your <code>
18:37:41 <mjrosenb> hire armies of type theory grad students.  you'll have a compiler for 20 languages and bits of your project written in every one of them!
18:37:47 <kmc> hahaha
18:37:55 <kmc> got to go, ttyl all
18:38:20 <tg_> night k
18:39:27 <dark> i sometimes struggle a lot to choose the right function name when i'm writing functional code. or even the right name for parameters..
18:40:00 <aavogt> dark: f x y z ...
18:40:01 <dark> for some reason this isn't an issue on most languages
18:40:07 <Jafet> Use unpl
18:40:51 <tg_> i suggest using the same techniques that IUPAC uses for assigning names of elements
18:41:17 <dark> [ I found out that "closure" would be more or less the right term for some kind of operation I was doing. and then I could just see I was doing a kind of union between sets. Solvable in literally one line ]
18:41:34 <aavogt> tg_: the ones not named after people?
18:42:02 <dark> tg_, I thought about "oohh this function is smart, it will be named einsteinium or something"
18:42:06 <aavogt>  -ium is hungarian notation
18:42:14 <tg_> aavogt: the full procedure. name then according to number, then reassign them (several years later) to something totally arbitrary
18:43:07 <tg_> but only according to the concensus of a open body.
18:43:13 <tg_> actually, put that way, it doesn't sound completely insane
18:45:55 <dark> Jafet, can it pick meaningful function names?
18:46:39 <aavogt> write your whole program using @pl
18:46:43 <aavogt> @where unlambda
18:46:43 <lambdabot> http://www.madore.org/~david/programs/unlambda/
18:46:55 <tg_> Unlambda: Your Functional Programming Language Nightmares Come True
18:46:57 <tg_> that's a great start
18:47:01 <benmachine> name all your functions after famous computer scientists
18:47:16 <aristid> aavogt: sometimes @pl doesn't find the shortest point-free version, so you should not always use only @pl
18:47:28 <benmachine> and parameters after greek letters
18:47:35 <aavogt> no, you need to fix @pl first
18:47:44 <aristid> benmachine: phoenician letters!
18:48:00 <aavogt> provably optimal pointlessness
18:48:54 <benmachine> > let dijkstra α β γ = shows γ " considered harmful" in fix (dijkstra "goto" "losers")
18:48:55 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:48:59 <benmachine> whoops
18:49:01 <benmachine> oh well
18:49:12 <benmachine> close enough right
18:50:14 <dark> [ it is very hard to me to come up with a meaningful mathematical solution when i previously had a bunch of stateful code ]
18:51:08 <tg_> is there a meaning to putting your text inside [ brackets ] or is that arbitrary?
18:51:28 <dibblego> why don't I see foldr empty (<|>) in Control.Applicative?
18:53:54 <benmachine> dibblego: try Data.Foldable
18:54:12 <dibblego> there it is! Iknew I'd seen it
18:54:13 <dibblego> cheers
18:54:18 <aristid> @hoogle asum
18:54:18 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
18:54:28 <benmachine> does the concept of "lifted" and "unlifted" constructors only apply to single-constructor types?
18:55:37 <dolio> No.
18:56:29 * benmachine is reading
18:59:55 <benmachine> do we say that data types in Haskell are lifted, or that constructors in Haskell are lifted, or <other>
19:00:01 <benmachine> (apart from newtypes)
19:00:22 <dolio> Types are lifted or unlifted.
19:00:44 <benmachine> a lifted type is one that contains its own bottom?
19:00:46 <pnicholson> Hey everyone, what does this mean? <file descriptor: 4>: commitAndReleaseBuffer: resource vanished (Broken pipe)
19:01:24 <dolio> Yes. Bottom is distinct from the other values.
19:01:31 <benmachine> okay
19:01:54 <aristid> benmachine: how can a type contain its own bottom? *confused*
19:02:00 <benmachine> so if Maybe was unlifted we'd have Just ⊥ and Nothing but no distinct ⊥ :: Maybe a
19:02:08 <benmachine> is that right?
19:02:45 * benmachine is trying to improve the haskellwiki article on newtypes and wants to get the full pedantic explanation correct
19:02:51 <benmachine> and by improve, I mean rewrite
19:02:52 <megajosh2> ⊥?
19:03:03 <megajosh2> Am I just unable to see what that is with my font?
19:03:07 <benmachine> ⊥.
19:03:08 <aristid> megajosh2: bottom
19:03:12 <megajosh2> Oh
19:03:16 <benmachine> it looks a bit like an upside-down T
19:03:37 <aristid> benmachine: does that mean that haskell only has lifted types?
19:03:38 <megajosh2> Yeah, I just noticed my XCompose entry for bottom makes that same box
19:03:48 <benmachine> if it doesn't look like that to you, configure your IRC client to use UTF-8 :>
19:03:50 <megajosh2> ⊤
19:04:12 <benmachine> aristid: newtypes are unlifted, e.g. State ⊥ is equivalent to ⊥
19:04:31 <benmachine> aristid: hence, liftedness/unliftedness is relevant to use of newtypes, hence, me asking about it
19:04:46 <benmachine> aristid: 'data' makes a lifted type, as I understand it
19:04:47 <aavogt> does it apply to unboxed values?
19:04:55 <megajosh2> ⊤
19:04:59 <megajosh2> Maybe it's my terminal...
19:05:19 <megajosh2> But I'm using rxvt-unicode :/
19:05:43 <benmachine> aavogt: unboxed values are strict, right? so they don't have a bottom, so I'm not sure
19:06:06 <benmachine> megajosh2: do you see gibberish, or a box/
19:06:09 <aristid> benmachine: then they are unlifted, right?
19:06:09 <benmachine> box?
19:06:15 <megajosh2> A box
19:06:17 <benmachine> aristid: I guess so
19:06:25 <megajosh2> Just did /set term_charset utf-8 in irssi
19:06:29 <megajosh2> Same old thing
19:06:32 <aavogt> you can have an infinite loop that should produce unboxed values....
19:06:35 <benmachine> megajosh2: most likely explanation, your encoding is right but your font doesn't have the glyph for it
19:06:41 <megajosh2> Probably...
19:06:50 <benmachine> aavogt: hmm
19:06:59 <benmachine> I'm getting something confused here
19:07:00 <megajosh2> I think I'm using BitVera Monospace or something like that
19:07:03 <megajosh2> meh
19:07:19 <aristid> megajosh2: deja vu sans mono is a nice monospace font
19:07:37 <benmachine> yeah I have that
19:07:38 <benmachine> Rxvt.font: xft:Dejavu Sans Mono:size=10pt
19:07:52 <megajosh2> URxvt*font: xft:Bitstream Vera Sans Mono:pixelsize=10:antialias=true:hinting=true
19:07:57 <pnicholson> I'm using the sendmail function in the MissingH package and passing the contents of stdin to it and getting <file descriptor: 4>: commitAndReleaseBuffer: resource vanished (Broken pipe)
19:08:07 <megajosh2> I thought DejaVu Sans Mono was too tall
19:08:20 <megajosh2> Might as well just switch to it and lower the font size
19:11:58 <pnicholson> any thoughts?
19:12:23 <megajosh2> Eh, never used it before so I don't know what's happening. I'd help if I could :)
19:13:00 <megajosh2> xrdb -load ~/.Xdefaults isn't enough to get this new font to load
19:13:14 <megajosh2> I'll just kill X. I don't have much open...
19:14:08 <benmachine> ooor he could just open a new terminal?
19:14:53 <megajosh2> I think the font might still be the same. This is odd...
19:15:16 <megajosh2> Better stop by #archlinux or something..
19:16:10 <aristid> megajosh2: you could try gnome-terminal as a reference
19:16:37 <Jafet> Setting just one font never sounds correct
19:16:59 <Jafet> rxvt, at least, uses fontsets
19:17:38 <kmc> suppose I have an edge-weighted graph, and I want a path of minimum weight-sum which visits every edge *at least* once (hence, it needn't be an Eulerian path)
19:17:42 <copumpkin> Jafet: whoever it is, isn't here?
19:17:50 <kmc> anyone know an algorithm to solve this problem?
19:18:02 <Jafet> Sorry, I knocked.
19:18:13 <megajosh2> I set URxvt*{font,boldFont,italicFont,bolditalicFont} to Dejavu Sans Mono
19:18:20 <megajosh2> I know I have that font... :/
19:18:44 <Jafet> kmc: a sort of dual to TSP?
19:18:52 <Jafet> Well no, but similar
19:19:22 <megajosh2> I'll try setting it to something ridiculous and see if there's any difference...
19:20:41 <mjrosenb> kmc: no, but it sounds like a fun problem.
19:20:59 <Jafet> It's called chinese postman, apparently.
19:22:12 <kmc> it looks like this neglects edge weights
19:23:19 <kmc> anyway thanks for references
19:24:54 <Jafet> If you're evil, you can split edges to fake it
19:25:05 <kmc> yeah
19:25:06 <kmc> true
19:41:05 <JoeyA> I'm having a type dilemma.  I'm trying to make a little DB abstraction library.  DB a represents a query yielding a.  DB (a -> Bool) represents a predicate on the DB (you'd get an error if you tried to query it).  DB [a] represents a set selected from the DB.
19:41:29 <JoeyA> I have a function (well, just a type signature) for filtering a set-returning query that looks like this (type class constraints may be needed later):
19:41:30 <JoeyA> filter :: DB (a -> Bool) -> DB [a] -> DB [a]
19:41:48 <JoeyA> as well as a function for building an equality test:
19:41:50 <JoeyA> (.==.) :: DB a -> DB a -> DB Bool
19:42:48 <JoeyA> The problem is, the API really can't be used.  If I say (.==. lift 5), I get type DB a -> DB Bool rather than DB (a -> Bool)
19:43:20 <JoeyA> Note that in DB (a -> Bool), the -> constructor is being used as a sort of phantom type, and I'm not even sure it's possible to do things like that.
19:44:10 <aristid> :t liftM (==)
19:44:11 <lambdabot> forall a1 (m :: * -> *). (Eq a1, Monad m) => m a1 -> m (a1 -> Bool)
19:44:29 <aristid> JoeyA: DB looks like a Monad
19:44:55 <JoeyA> Well, here's the problem with making it a monad: a monad involves pure computations that only Haskell knows how to do.
19:45:46 <JoeyA> I really can't make something like filter :: (a -> Bool) -> DB [a] -> DB [a] because then I'd have to feed all the rows through my program (well, I could, but it would kill efficiency).
19:45:59 <JoeyA> Especially when an index could be used.
19:46:02 <pumpkin> JoeyA: sounds to me like you'd want some sort of a GADT
19:46:23 <pumpkin> where your constructors refine the index
19:46:30 <benmachine> JoeyA: why did you decide that DB (a -> Bool) is a predicate on the DB?
19:47:03 <JoeyA> It really doesn't have to be; it could be something like DB (Predicate a) or just Predicate a.
19:47:14 <aavogt> you've seen haskelldb?
19:47:17 <JoeyA> yes
19:47:24 <pumpkin> have you tried GADTs?
19:48:42 <JoeyA> I've learned about them (and played around with them a bit, IIRC), but I'm having trouble seeing how they apply to my situation (not that I don't think they do).  I currently see GADTs as a good thing to know when I want to do something really zany with the type system, but Haskell won't have any of it.
19:49:06 <benmachine> I think DB (a -> Bool) is a bad type for predicates
19:49:23 <aavogt> you encode the functions you can write for the database efficiently in the GADT
19:49:23 <JoeyA> benmachine: I was hoping that using -> as a phantom type constructor would allow me to build a really nice, intuitive framework for any types of "functions" in the database.
19:49:25 <benmachine> but what do I know :P
19:49:32 <JoeyA> but what do I know :P
19:49:42 <kmc> the function is a stark datastructure
19:49:58 <aavogt> though you could really just use a regular ADT if type safety isn't important, pumpkin?
19:50:10 <pumpkin> I thought type safety tended to be important :)
19:50:13 <pumpkin> but yeah, sure
19:50:33 <aavogt> so you wouldn't encode anything equivalent to -XExistentialQuantification
19:50:49 <pumpkin> well I was thinking more along the lines of the other aspect of GADTs
19:50:52 <pumpkin> the index refining
19:52:12 <JoeyA> Well, the reason I brought up indexes is because the predicate needs to be computed on the database (otherwise, a bunch of unneeded rows get sent over the connection, and a SQL index can't be used)
19:53:07 <JoeyA> so when I build predicate computations, they can't have pure computations interspersed.
19:53:33 <pumpkin> yeah, that's why I think a GADT is your best options
19:53:35 <pumpkin> -s
19:53:52 <pumpkin> represent your terms in a typed manner in GADT constructors
19:54:43 <JoeyA> Now, I was thinking about how to make my abstract API more closely represent DB operations, but one thing I'm wondering about is: what's a good way to encode variables?
19:55:06 <pumpkin> SPJ the blogger! http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
19:55:11 <JoeyA> A simpler problem: what's a good way to represent lambda expressions in Haskell (if I'm strictly interpreting)
19:55:24 <JoeyA> s/strictly //
19:55:35 <pumpkin> JoeyA: a typical and fairly simple way is something called de bruijn indices
19:56:15 <benmachine> data Exp = Var Name | App Exp Exp | Lambda Name Exp -- sorted
19:56:17 <JoeyA> thanks, I'll take a look at that
19:56:31 <pumpkin> benmachine: that doesn't carry any type information though
19:56:42 <benmachine> type information, schmype information
19:56:47 <pumpkin> and isn't a de bruijn index representation :)
19:57:07 <benmachine> de bruijn index representation, schme... you get the idea
19:57:11 <kmc> JoeyA, representing terms with binders nicely is still an open problem :/
19:57:21 <kmc> especially if you want to do mechanized proofs of their transformations
19:57:28 <kmc> de Bruijn is simple
19:57:31 <kmc> HOAS or PHOAS may be nicer
19:57:36 <kmc> (parametric) higher-order abstract syntax
19:57:37 <pumpkin> JoeyA: I think de bruijn should be fine for you, but it's not user-friendly
19:57:42 <kmc> read oleg's "finally tagless" paper too
19:58:00 <pumpkin> "I am not a number, I am a free variable" has another (related) approach
19:58:13 <JoeyA> in the context of SQL, you have column names (a Record type class might indicate what those column names are).
19:58:29 <JoeyA> Knowing what columns are available in what scopes, and preventing collisions, may become an issue.
19:59:13 <pumpkin> I'd suggest prototyping in agda, then trying to cut down on agda-only features as much as possible, then translating the result to haskell
19:59:14 <pumpkin> :P
19:59:25 <pumpkin> but then again, I'm an agda zealot
19:59:32 <benmachine> heh heh
20:01:53 <JoeyA> so I guess De Bruijn indexes are, briefly, the number of scopes you have to go before reaching the lambda whose variable you're interested in?
20:02:06 <pumpkin> yeah
20:02:07 <kmc> exactly
20:02:21 <pumpkin> JoeyA: you can actually retain types on them, too
20:02:29 <JoeyA> (assuming you count \x y ->  as \x -> \y -> )
20:02:54 <pumpkin> I started writing a haskell syntax for an STLC that preserved types on the varaibles
20:03:06 * pumpkin wonders where that went
20:04:47 <kmc> any general thoughts on the FGL library?
20:04:49 <aristid> JoeyA: if you don't use (a -> Bool) and use Predicate a instead, you can really make DB a monad :)
20:05:10 <pumpkin> kmc: I'm not a huge fan, but can't really put my finger on why
20:05:21 <JoeyA> Would doing that involve siphoning tuples through the Haskell program?
20:05:36 <JoeyA> (in cases where necessary)
20:06:19 <JoeyA> I think the best idea I've come up with in this is:
20:06:21 <JoeyA> newtype ID a = ID {unID :: Int64}
20:06:24 <kmc> pumpkin, do you have a preferred alternative?
20:06:29 <pumpkin> nope
20:06:30 <JoeyA> notice how ID is parameterized with the type of record.
20:06:42 <pumpkin> I've been known to reimplement graph structures when I need them
20:06:51 <pumpkin> which I don't like either
20:07:02 <pumpkin> it's a tough design space
20:07:25 <JoeyA> I think it'd be cool to have a programming language + database that allows you to store closures.
20:07:54 <kmc> you should use MUMPS
20:08:49 <JoeyA> I read somewhere that variables in MUMPS are persistent, but I've also heard that MUMPS is a horrible language.
20:09:14 <JoeyA> (not that persistent variables are bad, but other aspects of the language)
20:10:23 <JoeyA> module DB where
20:10:25 <JoeyA> okay, what now?
20:10:38 <JoeyA> plz send me teh codez
20:10:58 <pumpkin> lol
20:11:58 <JoeyA> of course, I'll probably need {-# UndecidableInstances, IncoherentInstances, IncoherentProgrammer #-}
20:12:05 <pumpkin> :P
20:13:16 <kmc> incoherent instances are bad news
20:13:27 <kmc> i'm fine with undecidable though
20:13:50 <pumpkin> lucky for you, you can get incoherent instances without asking for them
20:14:03 <kmc> @quote incoherent
20:14:04 <lambdabot> sproingie says: * enables IncoherentInstances and ends up with Sarah Palin in his living room
20:14:04 <pumpkin> http://www.haskell.org/pipermail/glasgow-haskell-users/2010-February/018417.html
20:14:14 <benmachine> @quote incoherent
20:14:14 <lambdabot> sproingie says: * enables IncoherentInstances and ends up with Sarah Palin in his living room
20:14:17 <benmachine> hmph
20:14:24 <benmachine> I wanted the other one
20:14:27 <benmachine> also guys I rewrote http://www.haskell.org/haskellwiki/Newtype
20:14:34 <JoeyA> Does UndecidableInstances mean that the type checker could have an infinite loop?
20:14:36 <benmachine> tell me what you think
20:14:44 <benmachine> JoeyA: yes, compiling might not terminate
20:14:50 <benmachine> but if it does you're probably fine
20:15:00 <kmc> yeah
20:15:09 <kmc> actually it will always terminate, because GHC has a fixed stack depth
20:15:13 <benmachine> or wait, there might be the context stack that kills excessive recursion
20:15:17 <kmc> (which you can increase on the command line)
20:15:17 <benmachine> yes
20:15:25 <kmc> but it might fail to terminate *successfully* for a well-typed program
20:15:36 <dancor> http://haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#undecidable-instances
20:15:44 <kmc> a lot of extensions boil down to "the type checker might die" and/or "type inference might not find the most general type"
20:15:46 <dancor> "Termination is ensured by having a fixed-depth recursion stack. If you exceed the stack depth you get a sort of backtrace, and the opportunity to increase the stack depth with -fcontext-stack=N."
20:15:53 <kmc> neither of which is a huge problem
20:15:56 * hackagebot contstuff 0.4.0 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.4.0 (ErtugrulSoeylemez)
20:16:44 <aavogt> overlapping and incoherent instances affect sanity
20:17:08 <benmachine> @quote quicksilver.*overlapping
20:17:08 <lambdabot> No quotes match.
20:17:14 <benmachine> @quote quicksilver overlapping
20:17:14 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
20:17:14 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
20:17:22 <benmachine> @quote quicksilver incoherent
20:17:22 <lambdabot> quicksilver says: overlapping actually shatters the language into tiny inconsistent pieces, and incoherent files off the edges of the pieces so they don't even fit together any more.
20:17:26 <benmachine> I probably overdo those.
20:25:50 <JoeyA> What's a good name for a type class whose type can be converted to/from [SqlValue] ?
20:26:16 <JoeyA> I want to say Tuple, but I might want to make Tuple a type.
20:26:25 <dancor> tuple is too general
20:26:40 <JoeyA> why so?
20:26:55 <dancor> SqlTuple would already be better than Tuple
20:27:11 <dancor> idk tuples are everywhere..
20:27:27 <JoeyA> well, there's import qualified
20:30:57 <dancor> i think it's usually called a "value list" in sql parlance
20:31:07 <dancor> idk haskell class naming standards
20:31:32 <dancor> a lot of them seem to have -able but ValueListAble is a stretch
20:32:17 <JoeyA> Valuable :-)
20:32:31 <dancor> it wouldn't be the first class name lol
20:32:44 <dancor> s/lol/joke/
20:32:49 <JoeyA> I could call it Record, but I already want to use that for something more specific
20:32:50 <dibblego> SqlValueListExponentialFunctor
20:33:03 <JoeyA> (namely, a type corresponding to a row in a table)
20:33:14 <JoeyA> not just a selection of rows
20:33:36 <dibblego> newtype SqlFunctor a = SqlFunctor ([SqlValue] -> a)
20:33:49 <dibblego> newtype SqlContraFunctor a = SqlContraFunctor (a -> [SqlValue])
20:34:00 <mm_freak> HasValueList
20:34:03 <JoeyA> Well, the getter has to be:
20:34:04 <JoeyA> [SqlValue] -> (a, [SqlValue])
20:34:04 <mm_freak> ValueListLike
20:34:07 <mm_freak> etc.
20:34:11 <JoeyA> That way, I can join them together.
20:34:23 <dibblego> State [SqlValue]
20:34:40 <JoeyA> (similar to Data.Binary)
20:36:34 <kmc> http://www.classnamer.com/
20:37:36 <JoeyA> SerializableColumnFrame -- close
20:37:49 <JoeyA> lol
20:37:49 <JoeyA> StatefulGirlfriendPreference
20:41:07 <mm_freak> VirtualMemoryRandomizer lol
20:42:26 <Ke> !
20:42:50 <Ke> has anyone been able to create haskell daemons
20:43:04 <ray> no, you are the daemons
20:43:46 <Ke> detachDaemon just seems to exit the program entirely
20:48:28 <aavogt> Ke: yes
20:50:10 <Ke> aavogt: yes, it doesn't work, or yes...?
20:50:49 <aavogt> Ke: you tried  serviced  here http://hackage.haskell.org/packages/archive/hdaemonize/0.2/doc/html/System-Posix-Daemonize.html ?
20:51:44 * aavogt appears to have some code that used with success
20:51:58 <Ke> nope detachDaemon in System.Daemon
20:52:09 <Ke> aavogt: I'll that later, thanks
20:58:05 <itrekkie> if I run map on a String, the first argument of a the function it runs should be Char, right?
20:58:46 <Ke> @type map
20:58:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:59:13 <Ke> no Char parameter there
20:59:24 <Ke> gah
20:59:26 <Ke> yes
20:59:48 <Ke> since String is [Char]
21:00:00 <itrekkie> that's what I was hoping for, but no luck :(
21:01:01 <itrekkie> (map (\ x -> if True then highlightChar x else x) line), x is  string 
21:02:41 <aristid> :t concatMap
21:02:42 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
21:03:08 <aristid> itrekkie: map only allows one character to map to EXACTLY one element
21:03:37 <itrekkie> oh, I forgot the two return types can be different
21:04:42 <aristid> :t map
21:04:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:05:09 <aristid> itrekkie: a and b are different, that's the clue
21:05:38 <aristid> :t map :: (a -> a) -> [a] -> [a]
21:05:39 <lambdabot> forall a. (a -> a) -> [a] -> [a]
21:05:54 <itrekkie> yea, I see they are different now
21:08:24 <itrekkie> is there a way to track down exactly where a pattern isn't exhaustive?
21:09:08 <andresj> how do you define functions in tryhaskellorg?
21:10:12 <aristid> andresj: let f x = x +2 in f 4
21:10:43 <aristid> andresj: tryhaskell.org does not allow you to define functions that last for more than one line, for this you need to install GHC
21:30:37 <JoeyA> It seems funky to me that I can do this:
21:30:41 <JoeyA> get = Foo <$> get
21:30:47 <JoeyA> where each get has a completely different type
21:31:00 <ddarius> It shouldn't.
21:31:47 <JoeyA> I know what it means, but I thought there was some weird type inference algorithm issue making this type of thing hard. What do I know, I'm just a snail.
21:53:19 <augur> hey peeps!
21:53:20 <augur> :D
21:53:36 <augur> hey Gracenotes :D
21:53:40 * augur pounces gracenotes
21:54:58 <Gracenotes> hellooo
21:55:28 * Gracenotes meticulously plans counterattack, sees shiny thing, gets distracted
21:57:04 <augur> ^.^
21:57:08 <augur> v*v
21:57:13 <augur> ^o^
21:57:15 <augur> vOv
21:57:21 <augur> ^()^
21:58:01 <augur> thats a japanese smiley tumbling end over end as it's consumed by a growing black hole, obviously
21:59:32 <itrekkie> hi everyone, is there way to get the index of an element in a list?
22:00:16 <Gracenotes> findIndex/findIndices. using Eq.
22:00:18 <Gracenotes> in Data.List
22:00:28 <kmc> probably a bad idea
22:00:29 <itrekkie> what's elemIndex?
22:00:36 <kmc> as lists are not made for random access or searching
22:00:37 <itrekkie> oh it's a terribly hacky idea 
22:01:10 <Gracenotes> that's the 'how to do it' component of the question, 'why would you want to' can be worth looking at...
22:01:32 <Gracenotes> random access seems to work well for IntMaps and Arrays, but lists aren't shabby necessarily
22:02:26 <itrekkie> how do you deal with Maybe?
22:02:36 <itrekkie> I expect type Int but I'm getting Maybe Int
22:02:47 <Gracenotes> what happens when the element isn't in the list?
22:02:57 <itrekkie> it has to be ;)
22:03:18 <Ivo> hey guys
22:03:27 <Ivo> is it allowed to bounce a non-haskell related idea off you?
22:03:29 <itrekkie> I'm iterating through a string with map, but also need the index of the character, so map probably isn't right
22:03:53 <Gracenotes> then use the dreaded 'error' function
22:04:10 <Gracenotes> it failing to find the index means to STOP THE PRESSES in your program
22:04:26 <koninkje> itrekkie: try mapAccumR, or similar
22:04:59 <koninkje> also map f . zip [1..]
22:05:19 <itrekkie> okay, I could put the counter in the acculmating state 
22:05:48 <koninkje> Since the "accumulation" is so simple, the map.zip approach may be more efficient
22:06:12 <itrekkie> the map zip is a bit confusing still
22:06:46 <koninkje> > map (:[]) (zip [1..] "hello")
22:06:47 <lambdabot>   [[(1,'h')],[(2,'e')],[(3,'l')],[(4,'l')],[(5,'o')]]
22:07:22 <koninkje> hmm, probably not the most insightful choice of f
22:07:44 <Veinor> the monkey combinator
22:07:45 <itrekkie> but I need that first index in the lambda that goes to map
22:08:15 <koninkje> \f i xs -> map f (zip [i..] xs)
22:09:34 <itrekkie> so… map (\f i xs -> map f (zip [i..] xs)) (zip [1..] "hello")
22:11:27 <koninkje> > (\f i xs -> map f (zip [i..] xs)) (:[]) 1 "hello"
22:11:28 <itrekkie> ha, nope, type mismatch
22:11:28 <lambdabot>   [[(1,'h')],[(2,'e')],[(3,'l')],[(4,'l')],[(5,'o')]]
22:16:14 <itrekkie> why would haskell infer type a?
22:16:43 <itrekkie> it's saying it's getting [[(a,Char)]] but I want [(Int,Char)]
22:17:12 <PatrickRobotham> cast it to int
22:17:47 <koninkje> is it saying Num a => [[(a,Char)]] ?
22:17:55 <freiksenet> #join lisp
22:18:01 <freiksenet> oops, sorry
22:18:10 <koninkje> :t 1
22:18:10 <shachaf> freiksenet: One would expect (join lisp), no?
22:18:11 <lambdabot> forall t. (Num t) => t
22:18:21 <koninkje> :t (1::Int)
22:18:22 <lambdabot> Int
22:18:27 <freiksenet> (join 'lisp) prolly
22:19:19 <siracusa> > let lisp = ["l", "i", "s", "p"] in join lisp
22:19:20 <lambdabot>   "lisp"
22:19:34 <kmc> liþp
22:21:17 <itrekkie> can anyone see if they can figure out this weird type error? http://gist.github.com/604068
22:21:54 <itrekkie> I just want to build [[Char]]
22:22:17 <kmc> you didn't provide the error
22:22:34 <kmc> why map (\x -> snd x)? why not just "map snd"
22:23:06 <itrekkie> http://gist.github.com/604072
22:23:08 <itrekkie> that's the error
22:23:23 <itrekkie> no reason I guess, I like the full lambda
22:23:45 <kmc> then you're strongly against the community consensus
22:23:51 <kmc> but that's ok, we have one guy who names all his types T
22:23:57 <kmc> anyway
22:24:03 <itrekkie> plus I'm going to be doing more with the tuple eventually
22:24:09 <itrekkie> I'll need the first bit soon
22:24:17 <kmc> does it typecheck if you comment out the (++) and one of its arguments?
22:24:20 <shachaf> itrekkie: Full lambdas can be much clearer in some cases, but in this particular one it makes no sense.
22:24:31 <kmc> also did you try giving a type signature to "tups"?
22:24:36 <shachaf> The function "\x -> snd x" is already defined for you in the standard library.
22:24:37 <kmc> that might make the error clearer
22:25:10 <kmc> i think you should write it as "\x -> (\y -> snd y) x" ;P
22:25:13 <itrekkie> I didn't know you could give signatures to local functions
22:25:17 <kmc> yup
22:25:35 <itrekkie> let me look up that syntax and give it a try
22:25:43 <kmc> same syntax as top level
22:25:48 <kmc> where tups :: ....
22:25:52 <kmc>       tups l = ...
22:25:58 <kmc> or however else you want to indent it
22:26:34 <itrekkie> tups :: [Char] -> [(Int,Char)]
22:27:15 <kmc> so «tups line :: [(Int,Char)]» so «map snd $ tups line :: [Char]» which is good
22:27:41 <kmc> you can actually, through different syntax, attach a signature to any expression
22:28:00 <itrekkie> just new errors now :/
22:28:01 <itrekkie> http://gist.github.com/604078
22:28:06 <kmc> > (map :: (Int -> String) -> [Int] -> [String]) (show :: Int -> String) ([2 :: Int, 3 :: Int] :: [Int])
22:28:07 <lambdabot>   ["2","3"]
22:28:22 <kmc> yes, the point of adding signatures was to get a new, hopefully more comprehensible error
22:28:34 <kmc> adding signatures will never (?) fix a type error in Haskell 98
22:28:36 <kmc> maybe an ambiguity error
22:28:41 <kmc> but those are obviously such
22:29:02 <Veinor> kmc: monomorphism?
22:29:16 <itrekkie> so it saying the return type in the definition is wrong?
22:29:18 <kmc> itrekkie, (\f i xs -> map f (zip [i..] xs)) (:[]) 0 l
22:29:31 <kmc> you're trying to apply the function «(\f i xs -> map f (zip [i..] xs))» to those arguments (:[]) and 0 and l?
22:29:54 <kmc> why not just write «map (:[]) (zip [0..] l)»
22:30:13 <kmc> anyway i think the problem becomes clear now
22:30:37 <kmc> (zip [0..] l) is going to return a list of tuples
22:30:45 <kmc> map will  turn it into a list of singleton lists of tuples
22:30:47 <kmc> is that what you wanted?
22:30:54 <itrekkie> oh yea, I guess so
22:31:07 <itrekkie> I want the index associated with its value from the string
22:31:33 <kmc> how would this  give you that?
22:32:00 <itrekkie> to tell you the truth, I'm a bit lost, it came from quite a bit earlier in irc
22:32:46 <itrekkie> map (:[]) (zip [0..] l) -- what's the purpose of map here, isn't zip enough?
22:33:19 <itrekkie> > let l = "hi" in map (:[]) (zip [0..] l)
22:33:19 <lambdabot>   [[(0,'h')],[(1,'i')]]
22:33:25 <itrekkie> that seems to work right?
22:33:55 <dibblego> itrekkie, you might like to look at zipWith
22:34:03 <itrekkie> then again, so does this
22:34:08 <itrekkie> > let l = "hi" in (zip [0..] l)
22:34:09 <lambdabot>   [(0,'h'),(1,'i')]
22:34:35 <kmc> those are two different values
22:34:42 <kmc> one is a list of tuples, the other is a list of singleton lists of tuples
22:34:44 <kmc> which do you need?
22:34:53 <kmc> > map (:[]) "foobar"
22:34:55 <lambdabot>   ["f","o","o","b","a","r"]
22:35:02 <kmc> > map (:[]) [1,2,3]
22:35:03 <lambdabot>   [[1],[2],[3]]
22:35:05 <itrekkie> the latter
22:35:07 <kmc> ok
22:35:21 <kmc> so that's the purpose of map (:[])
22:40:35 <adnap> kmc: Whoa
22:42:35 <itrekkie> I was making that a lot harder than it was
22:42:45 <itrekkie> thank you everyone for helping me figure that out
22:43:31 <kmc> whoa?
22:43:40 <kmc> adnap, do you know kung fu now
22:47:58 <kamatsu> problem
22:48:16 <kmc> solution / irrelevant smartass remark
22:48:31 <kamatsu> how to make cabal build a haskell library, without qualifying the name of the exported symbols with a packagename?
22:48:59 <kmc> possibly by setting ghc flags manually
22:49:03 <kmc> -package-name ""
22:49:09 <kmc> half serious suggestion, it probably won't work though
22:49:09 <kamatsu> tried that
22:49:11 <kmc> ok
22:49:21 <kamatsu> instead of "package_Module_name" it gave "_Module_name"
22:49:28 <kamatsu> i want "Module_name"
22:49:34 <kamatsu> cos that's what hs-plugins expects
22:49:50 <kamatsu> if i compile with ghc --make it works
22:49:59 <kamatsu> cabal always adds a package file.
22:50:07 <kamatsu> *package  name
22:50:52 <adnap> kmc: lol
22:51:05 <adnap> kmc: I want to know more.
22:51:08 <kmc> about?
22:51:24 <adnap> I don't know.  I was just saying what I thought Neo said.
22:51:32 <kmc> :)
22:51:35 <adnap> How do I dodge bullets?
22:51:39 <kmc> how do i shot web
22:51:48 <adnap> lol
22:51:58 <adnap> Look what I learned:
22:52:04 <adnap> Oh wait...
22:52:10 <adnap> Is profanity allowed in #haskell>
22:52:16 <kmc> fuck yes
22:52:20 <adnap> okay
22:53:07 <adnap> > let swears = ["fuck", "shit", "ass", "bitch"] in (++) <$> swears <*> swears
22:53:08 <lambdabot>   ["fuckfuck","fuckshit","fuckass","fuckbitch","shitfuck","shitshit","shitass...
22:53:32 <kmc> well done
22:53:35 <adnap> Yay, applicative functors.
22:53:43 <adnap> I learned me a Haskell.
22:53:46 <kmc> :t liftA2 (++)
22:53:48 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
22:53:53 <Jafet> That was more like a Fucktor
22:53:55 <kmc> :t liftA2 mappend
22:53:56 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
22:54:00 <kmc> oh right Caleskell
22:54:15 <adnap> Whaaa?
22:54:26 <adnap> kmc: Use it on something.
22:54:28 <kamatsu> ah
22:54:33 <kamatsu> kmc: -package-name main
22:55:23 <kmc> clever
22:55:30 <adnap> liftA2 (++) ["some"] ["thing"]
22:55:34 <adnap> > liftA2 (++) ["some"] ["thing"]
22:55:35 <lambdabot>   ["something"]
22:55:37 <adnap> Ah
22:55:40 <kmc> logs]$ grep -ri fuck * | wc -l
22:55:40 <kmc> 3833
22:55:52 <kmc> kinda low actually
22:56:09 <adnap> Whoa, cool.
22:56:22 <kmc> > join (liftA2 (++)) $ words "learn you a haskell"
22:56:23 <lambdabot>   ["learnlearn","learnyou","learna","learnhaskell","youlearn","youyou","youa"...
22:56:39 <kmc> > unwords $ join (liftA2 (++)) $ words "learn you a haskell"
22:56:40 <lambdabot>   "learnlearn learnyou learna learnhaskell youlearn youyou youa youhaskell al...
22:57:05 <adnap> kmc: How 'bout verbing some nouns?
22:57:45 <kmc> > unwords $ join (liftA2 (++)) $ words "verb you a noun"
22:57:47 <lambdabot>   "verbverb verbyou verba verbnoun youverb youyou youa younoun averb ayou aa ...
22:58:01 <adnap> > liftA3 (++) ["some"] ["thing"] ["buhhhhhh"]
22:58:02 <lambdabot>   Couldn't match expected type `c -> d'
22:58:02 <lambdabot>         against inferred type `[GHC.T...
22:58:18 <kmc> not much point with singleton lists
22:58:25 <adnap> I guess I don't see how that would work anyay...
22:58:30 <kmc> liftA2 f (pure x) (pure y) = pure (f x y)
22:58:37 <kmc> pure x = [x] -- in this case
22:58:43 <adnap> Right
22:59:15 <adnap> Hey, wait, instead of map (:[])...
22:59:21 <adnap> > map pure [1,2,3]
22:59:22 <lambdabot>   No instance for (GHC.Show.Show (f a))
22:59:23 <lambdabot>    arising from a use of `M2744686587...
22:59:27 <kmc> yeah
22:59:28 <kmc> that works
22:59:31 <kmc> as does «map return»
22:59:36 <kmc> > map pure [1,2,3] :: [[Int]]
22:59:37 <lambdabot>   [[1],[2],[3]]
23:00:01 <kmc> hmm, earlier i said that ambiguity errors are obviously such, but this one wasn't
23:00:08 <kmc> i blame caleskell but maybe i'm missing something
23:00:15 <adnap> >:t map
23:00:23 <adnap> How do you do types with lambdabot?
23:00:31 <adnap> That is, check types.
23:00:38 <alexbobP> how do I get item n out of a list
23:00:43 <adnap> !!
23:00:48 <ski> @ask JoeyA would `Applicative DB', together with things like `(.==.) :: DB (a -> a -> Bool)' be any more sensible ?
23:00:49 <lambdabot> Consider it noted.
23:00:50 <Veinor> > [0,1,2,3,4] !! 2
23:00:51 <lambdabot>   2
23:01:10 <adnap> it's O(a billion)
23:01:21 <alexbobP> > map (\x->  "`-." !! ((+1) $ round $ sin x)) [0..31]
23:01:22 <ski> alexbobP : *why* do you want to get item indexed by `n' out of a list ?
23:01:23 <lambdabot>   "-..-``-..-```-..-``-..-``-..-``-"
23:01:33 <kmc> :t ()  -- adnap
23:01:34 <lambdabot> ()
23:01:37 <kmc> @type () -- or like so
23:01:38 <lambdabot> ()
23:01:39 <ski> @type map -- adnap
23:01:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:01:41 <adnap> ty
23:01:44 <adnap> alexbobP: Whoooaaa
23:01:51 <alexbobP> I just cooked that up
23:01:53 <alexbobP> I hope you liekz it
23:02:08 <kmc> alexbobP, !
23:02:10 <kmc> win
23:02:31 <alexbobP> > map (\x->  ".oO" !! ((+1) $ round $ sin x)) [0..31]
23:02:32 <lambdabot>   "oOOo..oOOo...oOOo..oOOo..oOOo..o"
23:02:45 <adnap> pretty clever
23:02:50 <alexbobP> thanks
23:02:50 <ski> > (cycle . join (++) reverse) "`-."
23:02:52 <lambdabot>   ".-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-`.-...
23:03:08 <kmc> @. elite nixon
23:03:11 <lambdabot> 7HIz0rz i$ 4 gR3a7 dAy ph0R frANc3!
23:03:22 <alexbobP> but can your way do this...
23:03:30 <alexbobP> > map (\x->  "`-." !! ((+1) $ round $ sin (.6 * x))) [0..31]
23:03:31 <lambdabot>   The operator `L..' [infixr 9] of a section
23:03:31 <lambdabot>      must have lower precedence ...
23:03:39 <alexbobP> > map (\x->  "`-." !! ((+1) $ round $ sin (0.6 * x))) [0..31]
23:03:41 <lambdabot>   "-....--```--...--````-....--```-"
23:03:51 <alexbobP> > map (\x->  "`-," !! ((+1) $ round $ sin (0.6 * x))) [0..63]
23:03:52 <lambdabot>   "-,,,,--```--,,,--````-,,,,--```--,,,--````-,,,,-````--,,,--```--"
23:06:57 <kmc> > fix error
23:06:59 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
23:07:09 <alexbobP> > map (\x->  " ░▒▓█" !! ((+2) $ round $ 2 * (sin (0.6 * x)))) [0..63]
23:07:10 <lambdabot>   "\9618\9619\9608\9608\9619\9618\9617   \9617\9619\9608\9608\9608\9619\9618\...
23:07:14 <alexbobP> fail :(
23:07:15 <ski> > (cycle . ap (++) reverse) "`-."
23:07:17 <lambdabot>   "`-..-``-..-``-..-``-..-``-..-``-..-``-..-``-..-``-..-``-..-``-..-``-..-``-...
23:07:19 <adnap> > map (\x -> "`-." !! ((+1) . round . sin . (0.6*) $ x))] [0..10]
23:07:20 <lambdabot>   <no location info>: parse error on input `]'
23:07:21 <kmc> > text $ map (\x->  " ░▒▓█" !! ((+2) $ round $ 2 * (sin (0.6 * x)))) [0..63]
23:07:22 <lambdabot>   ▒▓██▓▒░   ░▓███▓▒░  ░▒▓██▓▒░ ...
23:07:29 <alexbobP> :D
23:07:30 <adnap> > map (\x -> "`-." !! ((+1) . round . sin . (0.6*) $ x)) [0..10]
23:07:31 <lambdabot>   "-....--```-"
23:07:32 <alexbobP> thanks kmc!
23:07:43 * ski wonders why it was so hard to distinguish between `join' and `ap' ..
23:07:43 <Veinor> quick, someone use this to make a text-based plotting library
23:08:49 <kmc> > text (map (\x->  " ░▒▓█" !! ((+2) $ round $ 2 * (sin (0.6 * x)))) [0..15] ++ map pred "QsFtT!:::!GPS!\956!XbSf[")
23:08:50 <lambdabot>   ▒▓██▓▒░   ░▓███▓PrEsS 999 FOR λ WaReZ
23:08:51 <cizra> alexbobP: :-D
23:09:07 <Veinor> kmc: i don't get  it
23:09:29 <kmc> you never tried to get warez by DCC apparently
23:09:32 <adnap> Me either.  What are lambda warez?
23:09:53 <cizra> written in Haskell, obvly
23:11:40 <Veinor> a lambda keygen would be kind of bad, since it'd always give you the same key
23:11:53 <adnap> > map (\x -> "-_" !! (x + 1)) (concat . repeat $ [0,1])
23:11:55 <lambdabot>   "_*Exception: Prelude.(!!): index too large
23:12:10 <Ytinasni> Veinor: keygens are unsafe, haven't you ever used one?
23:12:27 <Veinor> unsafePerformPiracy
23:12:34 <adnap> > map (\x -> "_-" !! x) (concat . repeat $ [0,1])
23:12:35 <lambdabot>   "_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-...
23:12:37 <Jafet> @arrr
23:12:37 <lambdabot> Har de har har!
23:13:37 <adnap> > map (\x -> ".^" !! x) (concat . repeat $ [0,1])
23:13:38 <lambdabot>   ".^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^.^...
23:14:37 <kmc> what's a pirate's favorite function of type ((Arrow a) => (b -> c) -> a b c) ?
23:14:45 <c_wraith> :t arr
23:14:47 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
23:15:02 <adnap> Man... haven't learned arrows yet.  Are those useful?
23:15:10 <kmc> adnap, i don't think so
23:15:22 <kmc> but, you can never see the usefulness of something you've not used
23:15:30 <kmc> they're certainly not nearly as common as monads
23:15:30 <c_wraith> &&& and *** are kind of useful.  But Arrows in general?  who knows!
23:15:40 <jamy> hi all!
23:15:41 <adnap> 'Kay
23:15:46 <kmc> hi jamy
23:16:00 <adnap> I've been learning how to use GPipe as of late.  It's pretty cool.  I like it better than OpenGL.
23:16:20 <alexbobP> does 3gpipe0 use opengl?
23:16:28 <adnap> alexbobP: It's built on top of it.
23:16:33 <alexbobP> okay
23:16:47 <alexbobP> > reverse "adnap"
23:16:49 <lambdabot>   "panda"
23:16:50 <adnap> alexbobP: But it's highly abstracted.
23:16:52 <alexbobP> zomg
23:16:54 <adnap> :O
23:17:23 <alexbobP> > reverse "tacos"
23:17:25 <lambdabot>   "socat"
23:17:41 <adnap> One cool thing is that you don't have to write shaders in a separate language.  You can do it all with GPipe.  It gives you full control of the pipeline.
23:18:02 <adnap> socat...
23:18:03 * ski . o O ( <http://web.archive.org/web/20070206073041/http://www.cs.chalmers.se/Cs/Research/Functional/Pictures/logo.gif> )
23:18:07 <adnap> Why does that sound familiar?
23:18:17 <adnap> Is that a game or something?
23:19:15 <adnap> alexbobP: Oh wait.  That's what you used to send me stuff before, right?
23:19:38 <adnap> > reverse "racecar"
23:19:39 <lambdabot>   "racecar"
23:19:40 <jamy> kmc: i planning build linux kernel on haskell. Joining to me
23:19:42 <adnap> omg
23:19:42 <alexbobP> adnap: it's a better nc
23:20:20 <adnap> What is the longest palindrome that's a real word?
23:20:22 <mm_freak> > repeat [0,1] >>= map ("-_" !!)
23:20:23 <lambdabot>   "-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_...
23:20:43 <adnap> mm_freak: sexy
23:21:12 <adnap> mm_freak: Why ya gotta bring monads into this?
23:21:27 <alexbobP> mm_freak: mine is still sexier
23:21:30 <mm_freak> adnap: i don't bring them into this, they're already there, and i'm using them =)
23:21:45 <adnap> mm_freak: lol... you know what I mean!
23:21:46 <mm_freak> alexbobP: i haven't seen yours
23:21:53 <adnap> mm_freak: The sine wave.
23:21:57 <alexbobP> > map (\x->  "^-_" !! ((+1) $ round $ sin (0.7 * x))) [0..63]
23:21:58 <mm_freak> adnap: because i see no reason not to
23:21:58 <lambdabot>   "-___--^^^-___--^^^-___--^^^-___--^^^-___--^^^-___--^^^-___--^^^-"
23:22:14 <adnap> mm_freak: Aw, I'm just messing with you.
23:22:27 <adnap> alexbobP: That's not as good.
23:22:37 <adnap> alexbobP: Do "`-."
23:22:52 <adnap>  > map (\x->  "`-." !! ((+1) $ round $ sin (0.7 * x))) [0..63
23:22:52 <kmc> last . sortBy (comparing length) . filter (join ((==) . reverse)) . lines <$> readFile "/usr/share/dict/words" -- adnap
23:22:58 <adnap>  > map (\x->  "`-." !! ((+1) $ round $ sin (0.7 * x))) [0..63]
23:23:25 <alexbobP> > map (\x->  "`-." !! ((+1) $ round $ sin (1.2 * x))) [0..63]
23:23:26 <lambdabot>   "-..-`-..-``..-``-.-``-..``-..-`-..-``-.-``-..``-..-`-..-``-.-``-"
23:23:27 <jamy> kmc: !!!
23:23:32 <adnap> kmc: Ooh, cool.  I didn't know a dictionary came with linux.
23:23:41 <kmc> jamy, ‽‽‽
23:23:44 <kmc> yup
23:23:58 <mm_freak> > map ((".-^" !!) . floor . (*2) . sin) [0, pi/16 ..]
23:23:59 <lambdabot>   "...-----^-----...*Exception: Prelude.(!!): negative index
23:24:03 <mm_freak> uh
23:24:18 <mm_freak> > map ((repeat ".-^-" !!) . floor . (*2) . sin) [0, pi/16 ..]
23:24:19 <lambdabot>   [".-^-",".-^-",".-^-",".-^-",".-^-",".-^-",".-^-",".-^-",".-^-",".-^-",".-^...
23:24:27 <mm_freak> uh
23:24:30 <mm_freak> > map ((cycle ".-^-" !!) . floor . (*2) . sin) [0, pi/16 ..]
23:24:30 <alexbobP> lol
23:24:30 <lambdabot>   "...-----^-----...*Exception: Prelude.(!!): negative index
23:24:33 <alexbobP> mine's way more better
23:24:38 <jamy> kmc: see my first messege for you
23:24:42 <kmc> which?
23:24:44 <mm_freak> oh, of course lol
23:24:53 <jamy> about linux
23:25:04 <alexbobP> but yeah... probably not as sexily haskelled as it could be
23:25:43 <kmc> jamy, i've got a lot of other projects right now, but if yours takes off i'd love to contribute
23:25:45 <ski> adnap : dunno about longest, but `saippuakauppias' is somewhat long
23:25:48 <alexbobP> text $ map (\x->  " ░▒▓█" !! ((+2) $ round $ 2 * (sin (0.75 * x)))) [0..63]
23:25:52 <mm_freak> > map ((".-^" !!) . floor . (*1) . (+1) . sin) [0, pi/4 ..]
23:25:53 <adnap> kmc: It gives me "deified", but that's no better than "racecar".
23:25:53 <lambdabot>   "--^--....-^--....-^--....-^--....-^-....--^--....-^--....-^--....-^--....-...
23:25:56 <mm_freak> there you go
23:25:57 <kmc> yeah
23:25:59 <alexbobP> >text $ map (\x->  " ░▒▓█" !! ((+2) $ round $ 2 * (sin (0.75 * x)))) [0..63]
23:26:09 <alexbobP> > text $ map (\x->  " ░▒▓█" !! ((+2) $ round $ 2 * (sin (0.75 * x)))) [0..63]
23:26:10 <lambdabot>   ▒▓██▒░  ░▓██▓░  ░▒██▓▒░  ▒▓██...
23:26:16 <alexbobP> sheezuz shis bot is picky!
23:27:23 <adnap> Kernels, how do they work?
23:28:03 <ski> mm_freak : `(* 1) = id', no ?
23:28:05 <alexbobP> adnap: they have magnets in them
23:28:07 <jamy> kmc: takes of i'd?
23:28:09 <alexbobP> also, I need to go to sleep
23:28:16 <adnap> alexbobP: lol
23:28:36 <adnap> alexbobP: laser
23:28:41 <adnap> alexbobP: spider
23:28:49 <adnap> alexbobP: peow peow
23:28:54 <kmc> jamy, i don't understand
23:29:34 <adnap> jamy: Have you written that kernel yet?  It has been, like, 5 minutes already.
23:29:52 <adnap> jamy: I wanna run my xmonad on my Haskell kernel.
23:30:31 <jamy> adnap: no. its just a planning!
23:30:35 <mm_freak> ski: historic reasons
23:30:50 <kmc> hysterical raisins?
23:31:16 <ski> (well, a little history revision can be helpful, sometimes ..)
23:31:40 <jamy> kmc: you wanna what we integrate you projects in our? then you contribute as?
23:32:06 <mm_freak> i wonder when hackage documentation will be regenerated
23:32:06 <adnap> > reverse . sort . (drop 42) . (take 70) . concat . repeat $ "historical raisins"
23:32:08 <lambdabot>   "tssssrrronlliiiiiiihccaaaa  "
23:32:12 <adnap> Whooooaaaa
23:32:26 <mm_freak> adnap: concat . repeat = cycle
23:32:38 <adnap> > cycle "some shit"
23:32:39 <lambdabot>   "some shitsome shitsome shitsome shitsome shitsome shitsome shitsome shitso...
23:32:42 <ski> jamy : that is incomprehensible
23:32:51 <adnap> mm_freak: ty
23:32:57 <mm_freak> you're welcome
23:33:06 <kmc> jamy, i do not have time to help with planning at the start
23:33:19 <kmc> jamy, but if you start writing code successfully, i would like to help
23:34:14 <jamy> ok!
23:34:22 <adnap> mm_freak: Here's something useless: cycle . cycle
23:34:48 <adnap> Can someone show me some magic?
23:35:16 <adnap> Blow my mind with your obscure Haskell knowledge.
23:36:03 <mm_freak> adnap: not useless, but i'd say: cycle . cycle = cycle
23:36:14 <kmc> > cycle []
23:36:15 <lambdabot>   *Exception: Prelude.cycle: empty list
23:36:27 <kmc> that should totally be the other kind of ⊥
23:36:27 <mm_freak> bottom doesn't seem to change that
23:36:57 <Axman6> @src cycle
23:36:58 <lambdabot> cycle [] = undefined
23:36:58 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
23:37:21 <kmc> > nubBy(((>1).).gcd)[2..] -- adnap
23:37:23 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:37:27 <ski>   ys@(cycle xs) = xs ++ ys  -- would be nice if we could write it like this ..
23:37:38 <kmc> ski, smells like a view pattern
23:37:50 <ski> where is the view pattern ?
23:38:09 <kmc> hmm, it isn't though
23:38:22 <adnap> kmc: Is that the sieve?
23:38:36 <mm_freak> adnap: it's not a sieve, it uses trial GCD
23:39:05 <kmc> adnap, take one number from every equivalence class under the "equivalence relation" a ≡ b = gcd a b > 1
23:39:11 <kmc> which isn't an equivalence relation at all but oh well
23:40:16 <Axman6> > let f xs = xs' where xs' = xs ++ xs' in f []
23:40:21 <lambdabot>   mueval-core: Time limit exceeded
23:41:11 <kmc> > fix (In . Just)
23:41:13 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
23:41:14 <mm_freak> > let isPrime n = all (mod n x /= 0) . takeWhile (\x -> x*x < n) $ primes; primes = 2 : filter isPrime [3..] in primes
23:41:15 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
23:41:15 <lambdabot>         against inferred ...
23:41:25 <mm_freak> > let isPrime n = all (\x -> mod n x /= 0) . takeWhile (\x -> x*x < n) $ primes; primes = 2 : filter isPrime [3..] in primes
23:41:26 <lambdabot>   [2,3,4,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83...
23:41:33 <mm_freak> > let isPrime n = all (\x -> mod n x /= 0) . takeWhile (\x -> x*x <= n) $ primes; primes = 2 : filter isPrime [3..] in primes
23:41:34 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:41:42 <mm_freak> my favorite non-sieve
23:42:37 <adnap> > let sieve (p:xs) = p : sieve [x|x <- xs, x `mod` p > 0] in sieve [2..]
23:42:38 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:43:07 <mm_freak> adnap: don't call this "sieve"
23:43:48 <Axman6> :t In
23:43:49 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
23:43:51 <mm_freak> a sieve doesn't need division/modulo
23:46:22 <kmc> > iterate((>>=uncurry(++).(show.length&&&pure.head)).group) "1"
23:46:24 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
23:47:14 <mm_freak> > let soe (x:xs) = x : soe (concatMap (take (x-1)) . iterate (drop x) $ xs) in soe [2..]
23:47:15 <lambdabot>   [2,3,5,7,11,13,17,23,25,29,37,41,43,47,53,61,67,71,77,83,89,91,97,107,115,1...
23:47:18 <mm_freak> this is a real sieve
23:47:33 <mm_freak> but it doesn't work…
23:47:42 <kmc> is there an idiom for (uncurry f . (g&&&h)) ?
23:47:46 <Axman6> 25 is totally prime
23:48:09 <kmc> it's like (f `on` g) but with two different g's
23:48:15 <mm_freak> gimme a second…
23:48:29 <kmc> @pl \f g h x -> f (g x) (h x)
23:48:30 <lambdabot> liftM2
23:48:32 <kmc> :O
23:49:02 <Axman6> :t (&&&)
23:49:04 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
23:49:11 <Jafet> Now which skell is that from?
23:49:26 <kmc> > iterate((>>=liftA2(++)(show.length)(pure.head)).group)"1"
23:49:27 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
23:49:35 <kmc> (&&&) is in Control.Arrow
23:50:04 <kmc> it's a good deal clearer if you read (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
23:50:16 <Jafet> @src LiftM2
23:50:17 <lambdabot> Source not found. Where did you learn to type?
23:50:20 <Jafet> @src liftM2
23:50:21 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:50:26 <kmc> @src liftA2
23:50:27 <lambdabot> liftA2 f a b = f <$> a <*> b
23:51:21 <ddarius> kmc: It's symmetric at least, and the reflexive case never comes up in that example.
23:51:37 <kmc> > map length $ iterate((>>=liftA2(++)(show.length)(pure.head)).group)"1"
23:51:41 <lambdabot>   mueval-core: Time limit exceeded
23:52:06 <kmc> @oeis 1,2,2,4,6,6,8,10
23:52:07 <lambdabot>  Length of n-th term in Look and Say sequence A005150.
23:52:07 <lambdabot>  [1,2,2,4,6,6,8,10,14,20,26,34,46,62,78,102,134,176,226,302,408,528,678,904,1...
23:52:37 <Axman6> > iterate((>>=liftA2(++)(show.length)(pure.head)).group)"1" !! 200]
23:52:38 <Axman6> > iterate((>>=liftA2(++)(show.length)(pure.head)).group)"1" !! 200
23:52:39 <lambdabot>   <no location info>: parse error on input `]'
23:52:40 <lambdabot>   "31131122211311123113321112131221123113111231121113311211131221121321131211...
23:53:12 <Axman6> > iterate((>>=liftA2(++)(show.length)(pure.head)).group)"1" !! 2000
23:53:14 <lambdabot>   "31131122211311123113321112131221123113111231121113311211131221121321131211...
23:56:23 <mm_freak> let soe (cx:xs) = maybe (soe xs) (\x -> x : soe (concatMap ((++[Nothing]) . take (x-1)) . iterate (drop x) $ xs)) cx in soe . map Just $ [2..]
23:56:26 <mm_freak> > let soe (cx:xs) = maybe (soe xs) (\x -> x : soe (concatMap ((++[Nothing]) . take (x-1)) . iterate (drop x) $ xs)) cx in soe . map Just $ [2..]
23:56:27 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:56:39 <mm_freak> ugly, but works, and is a sieve
23:59:29 <ski> "Re: Genuine Eratosthenes sieve [Was: Optimization fun]" at <http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html> by Melissa O'Neill
