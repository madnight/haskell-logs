00:18:19 <lpsmith> I'm not familiar with Text.Regex.Posix,  but if \\d doesn't work,  I dunno.
00:18:26 <lpsmith> etpace, &
00:18:31 <lpsmith> err ^^
00:20:19 <Saizan> [0-9] ?
00:20:23 <lpsmith> aristid, well, after thinking about it a bit,  I'm thinking that it's probably impossible in general to make that work without some kind of special value to pass to the partial continuation to signify there is no more input
00:21:04 <aristid> lpsmith: why? when you pass "\n", it is clear that "\r\n" is not possible
00:21:15 <lpsmith> in this case, yes :)
00:21:28 <lpsmith> but I'm guessing in general, no
00:21:55 <lpsmith> that there is some situation where you must know that there is no more input before you can proceed
00:22:36 <aristid> lpsmith: can't it find out that in this generation that is futile?
00:23:00 <lpsmith> But yeah,  I could refactor my optNewLine = (string "\r" >> string "\n") <|> string "\n" <|> string ""
00:23:23 <lpsmith> aristid, what do you mean?  :)
00:24:17 <mlh> etpace: \d and the others special chars are not posix, they derive from perl and java etc borrowed them from there
00:24:45 <aristid> lpsmith: once you use >>, it works? oO
00:24:47 <lpsmith> there is pcre-light
00:24:49 <mlh> so Text.Regex.PCRE (perl compatible RE) is what you want
00:24:55 <aristid> lpsmith: then use >> :)
00:25:14 <lpsmith> aristid, yes,  but I'm think I should really fix the way I use the parser to pass [] in an the end
00:25:46 <lpsmith> the only issue is that doesn't groove well with the way I'm currently doing things,  I'll have to refactor a bit before it's pretty again
00:26:00 <aristid> lpsmith: yeah, do both things. but for the sake of incrementalness, you should get the parser to be happy as early as possible
00:26:14 <lpsmith> My current code,  it's awkward to handle the result of  (k "")
00:26:59 <lpsmith> aristid, you have a point =)
00:28:35 <lpsmith> actually, maybe it isn't awkward at all
00:51:57 <copumpkin> @tell dolio SPJ shot me down again! seems his mind is made up
00:51:58 <lambdabot> Consider it noted.
00:52:02 <copumpkin> @tell ddarius SPJ shot me down again! seems his mind is made up
00:52:02 <lambdabot> Consider it noted.
00:52:14 <Saizan> copumpkin: on what?
00:52:30 <copumpkin> my GADT matching warning vs. error objection
00:52:40 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3927#comment:8
00:53:11 * Saizan waits for the page to load
00:53:35 <copumpkin> yeah, not loading here either
00:56:51 <copumpkin> for some reason chrome tries to redownload the page if I ask it to save it to disk, so I made a PDF of it: http://dl.dropbox.com/u/361503/zomg.pdf
00:57:24 <Saizan> it loaded now
00:57:27 <copumpkin> ah ok
00:58:09 <Mark___> Hi guys
00:58:11 <Saizan> maybe SPJ needs to be introduced to absurd patterns?:)
00:58:22 <Mark___> I'm new to haskell and I'm trying it out in the online version
00:58:32 <Mark___> I have a quick easy question
00:58:42 <Saizan> anyhow, it seems agda and GHC implementations of pattern matching are really coming at it from opposite angles
00:58:46 <copumpkin> Saizan: I dunno, maybe GADTs are subtly different from non-dependent inductive families, which is what I've always assumed they were
00:58:47 <Mark___> if the following is true
00:59:06 <Mark___> ['a', 'b', 'c'] == "abc"
00:59:24 <Mark___> does this mean all strings are in fact lists of characters that form the string?
00:59:29 <sm> when running cabal haddock on haddock, I get "cabal: The program alex is required but it could not be found" (despite alex being in path). How do I track down the code giving this warning ?
00:59:29 <Mark___> something like C
00:59:29 <copumpkin> yeah :)
00:59:33 <deteego> Mark___: yes
00:59:43 <Mark___> ah ic.  thanks
00:59:45 <copumpkin> "abc" is just syntactic sugar for the other form
00:59:46 <deteego> but you dont have to worry about end of string character
00:59:53 <deteego> since lists terminate
00:59:54 <copumpkin> which is itself syntactic sugar for manual construction of lists
01:00:08 <Mark___> Thank you
01:00:15 <deteego> well at least string lists terminate
01:00:24 <copumpkin> Saizan: he does say that in GADT papers the cases I say are bad are not considered bad
01:00:28 <copumpkin> > cycle "abc"
01:00:29 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
01:00:59 <copumpkin> or don't! but you don't have to worry about running off the end of a string like you do in C :)
01:01:09 <deteego> well yeah
01:01:10 <deteego> thats what I meant
01:01:20 <copumpkin> > "\0"
01:01:21 <lambdabot>   "\NUL"
01:01:29 <Mark___> ok
01:01:30 <copumpkin> (you also can stick null characters in your strings, of course)
01:02:16 <copumpkin> Mark___: another thing to be aware of is that Haskell Chars cover an entire unicode code point
01:02:52 <Mark___> oh...okok......i'm just running through the tutorial now......don't scare me
01:03:06 <Mark___> but thank you everyone for the help
01:03:09 <Mark___> appreciate it
01:03:34 <Mark___> Out of curiosity.....what kind of applications use Haskell?
01:03:54 <Mark___> or why would I want to use haskell over something else, like C++ or Python
01:04:16 <deteego> Mark___: honestly in my opinion haskell is much better in design compared to those other languages
01:04:28 <deteego> its just Haskell doesn't have the tools required to 'flourish'
01:05:05 <Axman6> Mark___: haskell is used for all sorts of applications, from compilers, to web servers, to high performance apps, to applications that produce code for enbedded devices
01:05:10 <Axman6> embedded*
01:05:21 <deteego> Haskell has much better abstraction then those languages and 'error' checking (through proving symantics of your program)
01:05:45 <Saizan> copumpkin: maybe dependent pattern matching has to be more careful about such things to ensure normalization, but i wouldn't know precisely why
01:05:47 <deteego> its also one of the most productive languages out there
01:07:04 <Saizan> it always felt a bit odd that it insisted on typechecking my patterns, coming from GHC's GADTs
01:08:51 <zenzike> :t const
01:08:52 <lambdabot> forall a b. a -> b -> a
01:09:05 <deteego> Mark___: haskell is also much faster then python, especially when LLVM gets intergrated
01:09:44 <Axman6> the LLVM backend doesn't make much difference in general, but it makes a huge difference for numericly intensive code with nice tight loops
01:09:54 <deteego> python is run in a VM, but their bytecode generator aint that great
01:10:02 <cncl_> hackage is down?
01:10:09 <deteego> Axman6: for some odd reason on windows its making quite a big difference in other cases
01:10:17 <deteego> its unknown why
01:10:46 <deteego> teiri talked about it in a mailing list somewhere
01:11:04 <deteego> *tieri
01:11:54 <Baughn> Where is Haskell on the lambda cube, anyway?
01:12:03 <Axman6> where isn't it
01:12:14 <Baughn> Outside it?
01:12:24 * Axman6 has no idea
01:12:28 <Baughn> I'm sure haskell'98 has some reasonably well-defined location at least
01:12:58 <deteego> what is a lambda cube?
01:13:05 <Baughn> http://en.wikipedia.org/wiki/Lambda_cube
01:13:16 <deteego> nvm
01:14:09 <Baughn> Maybe it doesn't. Polymorphism supposedly yields system f, but I *know* haskell'98 doesn't implement that (not that you /can/), and it does include some polymorphism, so..
01:14:31 <fizruk_> are empty data types supported in ghc?
01:14:51 <deteego> fizruk_: what exactly do you mean by empty
01:15:17 <fizruk_> deteego: data type without constructor
01:15:22 <Baughn> Yes
01:15:44 <fizruk_> what is the name of extension?
01:15:48 <Baughn> EmptyDataDecls
01:15:54 <fizruk_> thanks =)
01:16:07 <Baughn> But in general (and in this case), attempting to use it without that extension loaded will make GHC spit out an error
01:16:11 <Baughn> That names the extension.
01:16:35 <Baughn> It parses mostly the same language regardless of language pragmas, the pragmas just shut off some assertions
01:18:08 <fizruk_> Baughn: are you trying to say me to use {-# LANGUAGE EmptyDataDecls #-} ? )
01:18:14 <Baughn> Er, yeah?
01:18:30 <Baughn> You normally want your files to be conveniently loadable in GHCi.. that's your choice, though
01:18:48 <Baughn> fizruk_: Hm. Also, to be pedantic, GHC doesn't /really/ support empty types. You can always construct a value of any type via undefined.
01:20:02 <Saizan> it's just that in haskell "empty" is fuller than you'd expect :P
01:21:11 <fizruk_> Baughn: I'm not sure, I actually need them, I'm now playing with semantic represantation of functions/expressions )
01:21:50 <fizruk_> Saizan: what do you mean? :)
01:21:54 <tensorpudding> You can construct bottom in other typed languages that don't have undefined, right?
01:22:32 <Baughn> f :: EmptyType; f = f
01:22:40 <Baughn> Perfectly valid haskell
01:25:22 <pantski> 09 - Johnny Nash - We're All Alike.mp3
01:25:22 <pantski> 10 - Johnny Nash - How Good It Is.mp3
01:25:27 <pantski> oops
01:25:32 <pantski> accidental paste :P
01:26:14 <fizruk_> Baughn: nothing strange, as I see. what did you want to show? :)
01:26:49 <Baughn> fizruk_: Only that you can have bottom without undefined, quite easily. It was directed at tensorpudding.
01:27:09 <copumpkin> fizruk_: just as long as you keep in mind that your empty type isn't really empty
01:27:18 <copumpkin> if you want truly empty types, look for a total language
01:27:37 <Baughn> But there are bottoms and bottoms
01:27:47 <copumpkin> Baughn is a connoisseur of bottoms
01:27:53 <Baughn> I love bottoms.
01:27:59 <fizruk_> :)
01:28:00 <Baughn> It would be nice to have empty types that don't take up memory.
01:28:26 <Baughn> Although, we might already have those..
01:28:54 <Baughn> You can get a value of one via undefined, yes, but then what do you /do/ with it? You can't pattern-match against it, so how could you ever tell that it's a bottom?
01:29:07 * Baughn wonders how GHC actually implements this
01:29:11 <copumpkin> newtype Bottom = Bottom Bottom
01:29:29 <Baughn> That's ugly. ^^;
01:29:33 <copumpkin> f (Bottom b) = "allo"
01:29:52 <Saizan> .. deriving Show
01:30:18 <Saizan> show (undefined :: Bottom) == "Bottom (Bottom (Bottom ......"
01:30:30 <mjk> It's too difficult to understand the State monad, can anyone give me a simple code?
01:31:12 <Baughn> mjk: do put 3; modify (+42); get
01:31:27 <Baughn> mjk: Think like imperative programming, but with only a single variable
01:31:49 <copumpkin> mjk: Baughn's code is roughly equivalent to (int x;) x = 3; x += 42; return x
01:32:00 <Baughn> *nodnod*
01:32:20 <Baughn> mjk: Since you naturally want multiple variables, you'd normally use a data-type for the "single" variable
01:33:24 <mjk> the lecture example is using tree, it's difficuly to understand too
01:33:52 <mjk> what to do use the state monad?
01:34:34 <mjk> does recode a state of a value?
01:34:43 <Saizan> mjk: http://www.haskell.org/all_about_monads/html/statemonad.html <- might help
01:35:45 <mjk> Saizan: ramkrsna: copumpkin: thanks
01:35:57 <Heffalump> has the cabalised gtk2hs been released yet?
01:36:00 * fizruk_ would be happy if somebody was reading him lectures on haskell...
01:36:38 * Dae has this fetish too
01:36:41 <kfish> Heffalump, yup, it's on hackage and everything
01:38:03 <kfish> http://www.haskell.org/gtk2hs/
01:38:12 <kfish> you need gtk2hs-buildtools before you install gtk2hs tho
01:38:38 <rothwell> does this mean reasonably painless haskell guis?
01:39:01 <Zao> rothwell: No GUI is ever remotely painless.
01:39:02 <rothwell> had a very poor experience last time i tried... poor as in "nothing in the gui category would build"
01:39:17 <rothwell> Zao: yeah...
01:39:29 <luite> installing gtk2hs should be easy on linux now
01:39:47 <rothwell> i'll give it a go at some point this week
01:39:52 <luite> on windows you need to download a few libraries, and add a directory to your path
01:40:10 <luite> but it's not too bad
01:40:22 <rothwell> righto
01:40:30 <Dae> luite, you no longer need to build ghc yourself?
01:40:40 <Dae> on windows that is
01:40:48 <luite> ghc?
01:41:06 <luite> why would you need to build that yourself?
01:41:48 <Heffalump> kermit: oh. It's called gtk on hackage. How confusing.
01:41:51 <Dae> I seem to remember gtk2hs relying on a version on ghc that was only available as source for windows
01:42:02 <Heffalump> s/kermit/kfish/ # sorry kermit
01:42:33 <luite> oh maybe the binary installer of gtk2hs for windows
01:42:40 <luite> you could also build it from source
01:42:49 <luite> but it was quite tedious
01:43:11 <luite> but at least it would work with your ghc :)
01:43:38 <Dae> Hopefully now :) Never did manage to get it to work before, but this was quite some time ago
01:44:18 <Baughn> GTK2HS has a history of being slowly updated for new releases, but surely it works on 6.12 by now?
01:44:34 <luite> Baughn: yes, you can install it with cabal-install
01:45:02 <luite> Baughn: you only need to download the gtk libraries binary package, extract it somewhere and add the bin directory to your path
01:45:02 <Baughn> On windows? Without msys or anything?
01:45:15 <luite> and you don't need msys
01:45:21 <zenzike> ugh hackage is down again
01:45:35 <Baughn> ..this is /not/ good PR.
01:46:13 <luite> how is the new server / site coming along?
01:47:37 <mjk> to install gtk2hs, first cabal install gtk2hs_buildtools, and then execute cabal instal gtk2hs
01:47:43 <rothwell> zenzike: phew, thought it was just me
01:47:49 <luite> gtk2hs-buildtools
01:47:53 <luite> not an underscore
01:48:02 <mjk> yes,hehe
01:48:16 <zenzike> rothwell: there's a good site to know when it's just you: downforeveryoneorjustme.com
01:48:43 <rothwell> zenzike: actually had a few false negatives there before
01:48:57 <rothwell> zenzike: for some reason, routing seems really damaged between europe and quebec, for example
01:49:02 <mjk> but the habit program in gtk2hs is different with gtk+
01:49:06 * Baughn wonders why the first million (hex) values of e equal the 64 quadrillionth million (hex) values of Pi
01:49:08 <zenzike> rothwell: oh really? that's interesting.
01:49:55 <rothwell> my old friend at hypertriton often has complaints from france about connectivity... all he can ever say is "it's not my fault!"
01:50:40 <Dae> Baughn, that would eventually happen, no? At some point in pi the first million hex values of e will appear
01:51:34 <Baughn> Dae: Shouldn't be that soon.
01:52:15 <Dae> Baughn, that's just probability. But I find it surprising too
01:55:53 <Heffalump> Baughn: in order?
01:56:05 <Baughn> Heffalump: Naturally.
01:56:13 <Heffalump> that's seems amazingly unlikely
01:56:27 <Baughn> Trust my mind. I calculated the digits myself.
01:57:01 <Dae> Heffalump, assuming that both the digits of pi and e are randomly distributed, it's just as likely as anywhere else
01:57:55 <Baughn> Amusing as this clear misunderstanding of probability is - I made it up.
01:58:05 <Heffalump> ah :-)
01:58:05 * Baughn was hoping for a bitmore of a reaction. Oh well.
01:58:23 <Baughn> http://samy.pl/evercookie/ <- Here, have a cookie.
01:58:42 <Dae> ghee, thanks
02:00:51 <Dae> Baughn, feel free to clarify my "clear misunderstanding of probability"
02:01:34 <Baughn> Dae: Well, you failed to call shenanigans. :P
02:02:46 * Dae had to google shenanigans
02:03:04 <Baughn> The actual probability of a given million-digit sequence of pi being the same as some sequence of e (or any other number) is 16^10000000 against, which means you will /not/ find it, well, ever.
02:03:39 <Baughn> Unless you look at pi to get the sequence, I suppose. :P
02:05:05 <Dae> Baughn, heh ok. So we agree that it's there somewhere, just presumably outside what we can reasonably calculate :p
02:05:22 <Baughn> Oh sure, everything is out there *somewhere*.
02:05:31 <Dae> Kept the truth
02:05:45 <koala_man> is that proven for both e and pi?
02:05:46 <Baughn> It's just that it'll be so far beyond what can be calculated in this universe, it's not even funny. :P
02:06:21 <Dae> koala_man, not sure to be honest
02:06:38 <Baughn> koala_man: It's assumed, but..
02:13:28 <lpsmith> ok,  what the heck happened to the euclidean algorithm?   Americans seem to have basically forgotten about it.
02:15:16 <lpsmith> I saw a math entrance exam for British Grammar school from the 19th century,  it asked to find the gcd of two numbers that would have required the euclidean algorithm.   Their is no way you could have gotten the answer by factoring each number
02:15:56 <lpsmith> high school math teachers not infrequently know knothing of the euclidean algorithm
02:16:12 <lpsmith> it's almost never taught,  except maybe in a computer science course somewhere
02:22:20 <aristid> lpsmith: the difference is that back then, computing was a career
02:23:25 <lpsmith> I just got done watching video from both the Khan Academy and PatrickJMT on the GCD,  and no mention of the euclidean algorithm
02:23:39 <lpsmith> Computing is more of a career today!
02:23:43 <lpsmith> Jevon's Paradox!
02:24:09 <lpsmith> We have a better appreciation for the speed of two different algorithms,  sort of
02:24:28 <lpsmith> Euclidean algorithm is much faster than factoring two numbers to find the GCD!
02:24:39 <lpsmith> often even when you are doing things by hand!
02:27:57 <aristid> lpsmith: no, computing is not a career today, not in the same sense :)
02:28:07 <lpsmith> oh, ok =)
02:31:07 <lpsmith> But I think we should be teaching elementary computer programming and science in elementary school.
02:31:21 <zachk> yes
02:31:42 <zachk> i got taught both of those a bit in lower grades, but i was in a really good school at the time
02:31:51 <lpsmith> I find it incredibly funny Americans are spending all their time in elementary school on reading and arithmetic,  and going backwards in terms of curriculum
02:32:30 <lpsmith> of course, that's hardly suprising for reading,  I mean,  we can't read about civics or science or health anymore
02:32:45 <Dae> lpsmith, would probably be more funny if it was only happening in America....
02:32:49 <lpsmith> big shocker that reading itself takes a hit
02:33:30 <lpsmith> Dae, where are you from? =)
02:34:25 <Dae> lpsmith, Denmark
02:34:25 <zachk> ive showed basic haskell to a highschool dropout i was tutoring in math, she liked it, then i should her the same things in maths notation and she got wigged out and didnt understand it 
02:34:34 <zachk> showed*
02:34:38 <lpsmith> hehe
02:35:07 <lpsmith> I had a big advantage in elementary math that it never really scared me because I knew a bit of BASIC programming
02:35:26 <Dae> zachk, well using fancy math notation IS part of haskell's "avoid success at all costs" philosophy 
02:35:33 <zachk> lpsmith: same 
02:35:44 <lpsmith> I would have eaten up Algebra 4 or 5 years earlier than it was offered to me
02:35:45 <zachk> sum [1..10] isnt fancy math notation 
02:36:11 <lpsmith> Algebra also helped me become a better programmer,  by leaps and bounds
02:36:11 <Dae> lpsmith, no programming below university over here. Intro course on programming in CS was java.....
02:36:27 <zachk> i passed algebra 1 in the 5th grade with an 89 on the final, no studying because i knew what a variable was from programming in basic 
02:36:31 <lpsmith> Well,  my father taught CS at a liberal arts college
02:36:50 <lpsmith> And my parents somewhat inadvertently taught me to program
02:36:53 <Dae> zachk, but talking about lambda notation is ;) 
02:36:58 <zachk> my father fixed portable nukes for the us army 
02:37:04 <lpsmith> sweet
02:37:21 <zachk> i was already comfortable with lambda's from heavy use of scheme 
02:37:25 <Saizan> the problem with mathematicians is that they can count on other mathematicians to figure out what they mean
02:37:39 <copumpkin> oh!
02:37:44 <copumpkin> I see the difference between haskell and agda now :)
02:37:46 <Saizan> a compiler is much less forgiving, so you need a better notation
02:38:05 <Saizan> copumpkin: :O
02:38:09 <lpsmith> zachk:  I went from Algebra I as a freshman in High School and finished second year calculus,  probability,  discrete math, and linear algebra by the time I was a senior
02:38:15 <copumpkin> Saizan: with respect to that bug report :P
02:38:31 <Dae> Yeah, we need a compiler that you just sort of wave at, and then it produces your program
02:38:34 <zachk> lpsmith nice 
02:39:08 <Saizan> Dae: i rather think we need more pedant mathematicians :)
02:39:09 <lpsmith> yeah, I probably should have slowed it down a little bit,  it may have avoided burnout a bit =D
02:39:26 <zachk> i burntout hard 
02:39:43 <zachk> im back in calc1 because i forgot all the stuff
02:39:50 <zachk> and im thinking of just going for maths now 
02:40:00 <lpsmith> heh
02:40:04 <zachk> because of haskell i cant stand to code in java anymore 
02:40:07 <Dae> Saizan, heh yeah maybe.
02:40:15 <Saizan> copumpkin: the deep mystical understanding is for another day?:)
02:40:25 <lpsmith> I'm still very comfortable with Calc I, though I haven't really used it much for over a decade
02:40:34 <Dae> zachk, same feeling. Only, I have to do fortran
02:40:35 <copumpkin> Saizan: oh, well, matching on a constructor introduces a type equality constraint, it doesn't actually refine the type
02:40:39 <copumpkin> Saizan: as far as I can see
02:40:52 <zachk> at least you can get some real speed out of fortran ;) 
02:40:54 <lpsmith> DiffEQ on the other hand...
02:41:04 <copumpkin> Saizan: just posting to the ticket page with my clarification for other people :)
02:41:06 <zachk> yea
02:41:17 <Dae> zachk, only if you skip gfortran and use intel's compiler :p
02:41:22 <zachk> i worked my tail off in diff eq and i got a c+ , thats not good enough for me 
02:42:29 <lpsmith> I worked mildly hard at DiffEq and got a B, but mostly because I had too many other things to do that semester.   I could have definitely got an A had I had a more sane schedule my senior year
02:42:50 <zachk> senior year of high school? 
02:42:53 <lpsmith> yeah
02:42:57 <zachk> jeezum 
02:43:16 <zachk> i got to retake algebra 1 in new york in like 8th grade
02:43:52 <Saizan> copumpkin: yeah, and then you've to hope the solver figures out where you want it to coerce with that equality (though it's quite good)
02:44:25 <lpsmith> Well, I definitely would have been much better off had I started my high school math binge in like,  5th grade,  and finished it my senior year.   Take it a bit more slowly,  cover more nooks and crannies,  and take it nice steady pace
02:45:00 <lpsmith> anyway
02:45:13 <zachk> wanna take this to blah?
02:45:20 <lpsmith> sure
02:45:24 <zachk> alright
02:45:47 <copumpkin> Saizan: http://hackage.haskell.org/trac/ghc/ticket/3927#comment:9 :)
02:45:47 <copumpkin> but yeah
02:47:53 <Saizan> makes sense
02:48:41 <Saizan> so test :: Fin Nz -> a; test Fz = undefined is a type error?
02:51:00 <Saizan> it is
02:51:08 <copumpkin> yeah
02:51:25 <copumpkin> and I thought that pattern matching on the Nil would make the second parameter an Fz
02:51:29 <copumpkin> a Fin Nz that is
02:54:49 <Saizan> ah nice, with the new typechecker "(n ~ Nz) => Fin n -> a" and "Fin Nz -> a" give the same error
02:56:01 <copumpkin> oh really? :O
02:56:14 <copumpkin> so does my example fail on new typechecker?
02:56:49 <copumpkin> my other test was http://snapplr.com/xs5y
02:58:20 <Saizan> the one in the ticket fails too
02:58:27 <copumpkin> oh nice
02:58:34 <copumpkin> so why is he arguing with me? lol
02:58:59 <copumpkin> maybe he intends to "fix" the new behavior
02:59:02 <mreh> Ross Paterson seems to use a definition of Functor I am unaware of
02:59:36 <copumpkin> ?
02:59:59 <mreh> he's refered to a HOF as Functor
03:00:06 <Twey> o.@
03:00:07 <Saizan> copumpkin: what SPJ calls a warning here http://hackage.haskell.org/trac/ghc/ticket/3927#comment:6 is actually an error in my ghci..
03:00:24 <dolio> People in the C++ and Java arenas use "functor" like that.
03:00:24 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
03:00:40 <mreh> in the category of functions, he's calling (***) a Functor
03:01:27 <dolio> What's the category of functions?
03:01:28 <mreh> I'm paraphrasing, I don't entirely understand that
03:01:30 <Saizan> copumpkin: and the test with the "case i of .." gives a similar error
03:02:23 <mreh> heh, I love the fast show
03:02:45 <copumpkin> Saizan: okay, so now I'm just really confused :P
03:03:09 <dolio> (***) is the action of a functor.
03:03:15 <dolio> C x C -> C
03:03:20 <Saizan> copumpkin: maybe i need to pull some patch that turns that into a warning :)
03:03:20 <nomemory> http://hpaste.org/40026/intercalate - can somebody give me a hint why my implementation of intercalate is not working ?
03:03:47 <copumpkin> Saizan: would you mind posting to the ticket and mentioning that? I don't want him to think I'm annoying :P
03:03:54 <dolio> Taking pairs of C-objects to their product, and taking pairs of functions (f, g) to (f *** g).
03:04:04 <dolio> Assuming C has all binary products.
03:04:14 <mreh> :t intercalate
03:04:15 <lambdabot> forall a. [a] -> [[a]] -> [a]
03:04:35 <Zao> nomemory: Does ++ and : have the right precedence, or do you need parens?
03:05:09 <mreh> nomemory: change the : in line 5 to a ++
03:05:38 <nomemory> a++ ?
03:05:47 <mreh> :t (++)
03:05:48 <lambdabot> forall m. (Monoid m) => m -> m -> m
03:06:55 <mreh> :t (++) []
03:06:55 <lambdabot> forall a. [a] -> [a]
03:07:09 <mreh> hah, I didn't mean that
03:07:19 <mreh> :t [] (++)
03:07:20 <lambdabot>     Couldn't match expected type `(m -> m -> m) -> t'
03:07:20 <lambdabot>            against inferred type `[a]'
03:07:20 <lambdabot>     In the expression: [] (++)
03:07:25 <nomemory> mreh working 
03:07:29 <nomemory> but another error
03:07:41 <aristid> mreh: ??
03:07:46 <nomemory> Non-exhaustive patterns in function intercalate'
03:07:54 <Saizan> copumpkin: ok, if it's still like this after the rebuild :)
03:08:03 <mreh> aristid: displaying the List implementation of (++)
03:08:04 <nomemory> after i use intercalate' nt (x:xs) = x ++ nt ++ intercalate' nt xs (line 5)
03:08:08 <aristid> :r intercalate
03:08:53 <aristid> :t \a b -> let _ = head a in a ++ b
03:08:54 <lambdabot> forall a. [a] -> [a] -> [a]
03:09:04 <mreh> nomemory: it's more usual to use empty lists rather than the singleton case as your base case
03:09:19 <aristid> :t (Prelude.++)
03:09:20 <lambdabot> forall a. [a] -> [a] -> [a]
03:09:27 <mreh> you get the singleton for free the
03:09:56 <mreh> intercalate _ [] = []
03:10:30 <mreh> and now you no longer have a partial function
03:10:41 <nomemory> mreh, tried that
03:10:44 <nomemory> the results are the same
03:11:23 <mreh> nomemory: paste
03:12:02 <nomemory> http://hpaste.org/40027/intercalate2
03:12:30 <nomemory> (85, 86 -> 4,5)
03:12:45 <mreh> nomemory: you missed a ' off intercalate in ln4
03:13:05 <mreh> drop line 5, it's good practice
03:13:20 <mreh> it's also redundant
03:13:45 <nomemory> mreh, thanks
03:13:55 <mreh> did that fix it?
03:14:01 <nomemory> It's working now, you are right is redundant
03:14:35 <nomemory> "it's more usual to use empty lists rather than the singleton case as your base case" - what do you meant by that ?
03:14:36 <nomemory> :)
03:30:39 * hackagebot persistent 0.2.2.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.2.1 (MichaelSnoyman)
03:38:50 <Pika-Index> Hi Jonno_FTW 
03:42:46 * hackagebot hstzaar 0.4 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.4 (PedroVasconcelos)
03:55:06 <atude> When a one-dimensional Potential U(x) is continuous, finite and infinitively differentiable, and has the local minimal value and x=b, show that the potential U(x) can be approximated by a one-dimensional harmonic-osciallator potential near x=b.
03:57:13 <geheimdienst> mah 1dimenshunal armonnic-osiclator potenshial naer x=b. let me show u it.
03:58:38 <arw> atude: calculate the taylor-series and throw away higher-order parts of the series until only the harmonic-oscillator potential remains.
03:59:30 <quicksilver> I think it's also important to show that the parts you throw away are genuinely locally negligible
04:02:34 <arw> quicksilver: you can get that from "near x=b". for small deviations h from b, the higher powers in the taylor polynomial are smaller than the lower powers, at least in the limit for h -> 0 (thats what they mean by "near")
04:03:15 <atude> arw: how long did you study math?
04:03:31 <arw> atude: not a minute. i studied physics :)
04:03:37 <atude> :p
04:03:43 <atude> how long?
04:04:00 <arw> about 6 years, got my diploma this summer
04:04:08 <atude> excellent
04:04:14 <atude> taylor series in math though
04:04:23 <atude> how does it work in physics?
04:05:23 <arw> well. you use it mostly for the purpose of showing that in small areas around a certain point, you can approximate your very complex potential by something simple like a HO potential.
04:05:43 <atude> yes
04:06:43 <arw> so almost any theoretical physics homework starts with "blabla interaction is described by the potential <complicated>. show that this can be simplified to a HO around <interesting location>"
04:08:23 <arw> bbl, mealtime.
04:10:07 <atude> arw: I will study fundemenatls of physics and applied physics at my university soon
04:10:50 <tensorpudding> physics in #haskell today, hey
04:23:02 * hackagebot streamed 0.1 - Programmatically edit MIDI event streams via ALSA  http://hackage.haskell.org/package/streamed-0.1 (HenningThielemann)
04:24:17 <atude> what do you know, haskell is what is being displayed on my screen via defrag :p
04:25:35 <atude> I feel ashamed of myself.. I haven't actually been studying haskell as much as I should have
04:28:29 <quicksilver> arw: sure, but you probably still need to say that. Depending on context and assumed level of knowledge.
04:34:07 * hackagebot AttoJson 0.5.6 - Simple lightweight JSON parser, generator & manipulator based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.6 (HiromiIshii)
04:45:58 <aristid> why does darcs pull ask me if i want to apply patches? sure i want to, i want to get the latest and greatest stuff!
04:46:30 <Saizan> aristid: -a
04:47:00 <aristid> why can't everybody use git? :D
04:47:14 <atude> why use git?
04:47:44 <Saizan> because darcs is much better. and no i won't consider any argument that argues the contrary
04:47:51 <m3ga> why can't everyone use $my_prefered_vcs
04:47:53 <geheimdienst> aristid, because not everybody can be bothered with a metric boatload of different commands with strange defaults and inconsistent switches and incomprehensible documentation
04:47:56 <geheimdienst> ;)
04:48:03 <Cale> darcs is more fun
04:48:06 <aristid> geheimdienst: yeah, you're describing darcs :)
04:48:07 <rks> .
04:48:12 <Entroacceptor> darcs didn't want to push over ssh
04:48:34 <Cale> Entroacceptor: Do you have keys set up properly?
04:48:55 <Cale> (It pushes fine for me)
04:48:56 <Entroacceptor> of course I did
04:49:06 <Entroacceptor> I got some really weird error messages
04:49:13 <Entroacceptor> and even #darcs couldn't help me
04:49:18 <atude> Don't be silly
04:49:22 * geheimdienst was liking git just fine until he wanted to do something slightly advanced, went on #git, asked about "git ls-files --cached" and got told something along the lines of "oh you thought that would list the cached files? haha of course not"
04:49:24 <Cale> That's interesting
04:49:27 <Saizan> darcs push user@yout.server.com:path/to/repo
04:50:32 <Entroacceptor> yes, yes, I know, but it didn't work
04:50:42 <atude> Cale: Hey, mathematica has been running much better lately :)
04:50:50 <Cale> atude: great :)
04:57:52 <Cale> atude: Oh, apparently there's a fix for the Java issue too, but the only link I found to it so far is dead :/
04:58:06 <Cale> atude: Just looking through the rest of this forum to find it
05:01:38 <Cale> atude: Oh, also apparently Mathematica 7.0.2 doesn't have the problem
05:06:38 <Cale> Ah, okay, apparently it's a prerelease version which the Mathematica tech support guys sent to some users.
06:06:05 <ManateeLazyCat> Hi all. :)
06:06:23 <jandem> hello. I have a function that i want to call x times. Like this: :: Int -> (a -> b) -> [b]
06:06:32 <jandem> is there a builtin function for that? i can't find it
06:06:39 <ManateeLazyCat> @hoogle replicate
06:06:40 <lambdabot> Prelude replicate :: Int -> a -> [a]
06:06:40 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
06:06:40 <lambdabot> Data.List replicate :: Int -> a -> [a]
06:07:11 <writer> jandem: how is your function going to be invoked ?
06:07:24 <Lemmih> ?type iterate
06:07:25 <lambdabot> forall a. (a -> a) -> a -> [a]
06:08:10 <jandem> the issue is that i generate some random data, genRandom
06:08:24 <jandem> i want to create a list with x random items,
06:08:37 <jandem> iterate calls the function on the previous result, isn't it?
06:09:13 <ManateeLazyCat> @hoogle for
06:09:13 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
06:09:14 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
06:09:14 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
06:09:58 <jandem> thanks guys, i will look at these functions
06:22:58 <Axman6> jandem: the type of the function you gave doesn't make much sense at all
06:48:57 <mreh> when we say something is a Monad we are implying the Monad laws hold as well aren't we?
06:49:17 <mreh> the context is important I suppose
06:49:33 <mreh> haskell Monads aren't the same as a CT monad
06:54:56 <kingping> Hello
06:57:17 <kingping> Is `zip` bijective and thus isomorphism ?
06:57:42 <kingping> a,an
06:58:20 <moosefish> So, 3 years ago there was some discussion about many ways to handle errors were available: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors -- 3 years later, are the main libraries converging on a way to do it within the IO monad?
06:58:56 <moosefish> Specifically, if I want to handle errors in the thrift bindings, what would people feel is the 'correct' way to do it, from 'my' users' perspective?
07:03:13 * hackagebot hakyll 2.3.1 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.3.1 (JasperVanDerJeugt)
07:05:29 <begemot2718> Hi guys, what is the proper way to debug Parsec? 
07:06:41 <Lemmih> begemot2718: Divide and conquer.
07:16:37 <Axman6> > 2^64
07:16:38 <lambdabot>   18446744073709551616
07:16:43 <Axman6> > 2^128
07:16:44 <lambdabot>   340282366920938463463374607431768211456
07:30:59 <kingping> > :t const
07:30:59 <lambdabot>   <no location info>: parse error on input `:'
07:31:05 <kingping> > :type const
07:31:06 <lambdabot>   <no location info>: parse error on input `:'
07:31:12 <kingping> :t const
07:31:13 <lambdabot> forall a b. a -> b -> a
07:31:30 <kingping> :type const
07:32:02 <kingping> forall :-/
07:45:03 <waterlaz|work> can I have parallel execution in ST monad?
07:46:55 <Axman6> waterlaz|work: not really. how would that work?
07:47:28 <Saizan> you can use par
07:47:48 <waterlaz|work> well.. the same way it does in IO but without any sort of input/output
07:48:06 <Saizan> but that won't make read/writes of STVars run in parallel, unless you use unsafeInterleaveST
07:48:19 <waterlaz|work> lets say I have a STUArray
07:48:40 <waterlaz|work> I make some manipulations to this array that I want to do in parallel
07:48:58 <Axman6> hmm, i wonder if unsafeThaw would work ok if it were executed in parallel from various sparks
07:52:18 <waterlaz|work> par won't do well here
07:57:35 <Cale> waterlaz: Since par never changes the semantics of a computation, and concurrent reads and writes to an array would produce nondeterministic results, it certainly won't.
07:58:09 <EvanR-work> is it true that multiply by any odd number mod 2^n is a bijection?
07:58:16 <Cale> waterlaz: The point of the ST monad is to provide a way to do imperative computation with mutation locally while keeping the computation as a whole referentially transparent from the outside.
07:58:40 <Cale> EvanR-work: Yes.
07:58:43 <EvanR-work> why?
07:59:18 <Cale> EvanR: More generally, if a number a is coprime to n (has no common factors), then it is invertible mod n
08:00:00 <Cale> To see this, recall that whenever gcd(n,m) = d, it implies there are constants a and b for which a*n + b*m = d
08:00:16 <EvanR-work> the euclidean algorithm
08:00:29 <Cale> So, if gcd(a,n) = 1, then there are some constants u and v for which u*a + v*n = 1
08:00:52 <Cale> which means that there is a number u for which u*a = 1 (mod n)
08:01:38 <EvanR-work> invertible
08:01:42 <Cale> right
08:01:56 <Cale> and by associativity, this implies that multiplication by a will be invertible
08:02:20 <EvanR-work> i have tried several experiments and they check out, and now this proof. why do i still not feel comfortable putting it into production ;)
08:03:40 <Cale> Since if we have the map x |-> a*x, then the map x |-> u*x will be its inverse, as one composite will send the element x to u*(a*x) = (u*a)*x = 1*x = x, and the other is similar.
08:04:29 <EvanR-work> i was basically looking for a way to 'scramble' a number without collision, like a block cipher
08:05:13 <EvanR-work> basically this operation defines a permutation of the numbers 0..2^n-1
08:05:20 <Cale> right
08:06:01 <EvanR-work> if the element count was not power of two, would it still be doable?
08:06:21 <Cale> You'd need to find a unit of the ring in a different way, but yes.
08:06:56 <Cale> You'd search for a number which has no factor in common with your modulus, and use that.
08:07:12 <EvanR-work> and if the modulus was prime any number would work
08:07:19 <Cale> yes
08:07:22 <EvanR-work> amazing
08:07:35 <Cale> (Which is the same as saying that Z/pZ is a field)
08:07:51 <Cale> Well, any number except 0 of course.
08:12:05 <kmc> ↦
08:12:16 <Zao> Nice glyph-not-found.
08:12:55 <kmc> > ord '↦'
08:12:56 <lambdabot>   8614
08:13:04 <kmc> 'RIGHTWARDS ARROW FROM BAR' (U+21A6)
08:13:25 <Zao> Something pub-related, eh?
08:19:18 * hackagebot alex-meta 0.1.1 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.1.1 (JonasDuregard)
08:20:19 * hackagebot happy-meta 0.1.1 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.1.1 (JonasDuregard)
08:32:54 <Jirda> nejaky cech?
08:33:25 * hackagebot BNFC-meta 0.1 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.1 (JonasDuregard)
08:33:37 <aristid> Jirda: i don't know what language that is, but most people speak english here
08:34:21 <Jirda> Ok..sry...I'm from Czech and I have tried it in native language
08:34:24 <Twey> I'm going to guess Czech.
08:34:51 <Jirda> I would like to ask you about something
08:35:25 <ski> mreh : yes, we assume the laws. also monads in haskell falls under the more general CT concept
08:35:46 <blackh> Jirda: ask!
08:36:06 <ski> Baughn : imo, `EmptyDataDecls' should also enable syntax something like `case <expr> of {}'
08:36:24 <sm> Entroacceptor: #darcs couldn't help you ? :/ When did you last try ?
08:36:47 <Baughn> ski: Why?
08:36:51 <Twey> ski: Why?  What would the return value of such an expression be?
08:37:07 <Twey> Much less the point :þ
08:37:08 <Jirda> So...why is not the same 2^3^3 and  (2^3^3)<
08:37:11 <ski> (Baughn : btw, i think something more akin to a type whose values take up no memory, i.e. zero bits, would be a value of an unboxed nullary tuple type .. i.e. a type with one value, not zero values)
08:37:32 <ski> Baughn,Twey : it would never return
08:37:32 <Jirda> none <
08:37:55 <Baughn> ski: One or zero, doesn't really matter to me..
08:38:00 <ski> it would force `<expr>', having type `Void', which can't be a total value (since `Void' has no total values)
08:38:13 <Jirda> correct > So...why is not the same 2^3^3 and  (2^3)^3
08:38:13 <ski> Baughn : it's a world of difference :D
08:39:29 <Twey> ski: So it's non-terminating?
08:39:44 <trin_cz> Jirda: Cau
08:39:50 <ski> Baughn,Twey : just as an exhaustive, non-overlapping matching on a value of type `Either a b' (or any `data' type with two constructors) would be matched with `case <expr> of {Left <pat-0> -> <expr-0>; Right <par-1> -> <expr-1>}' ..
08:39:55 <Twey> But isn't it equivalent to just <expr>?
08:40:00 <dolio> case t of {} is a nicer way to write an error.
08:40:16 <Jirda> ahoj, da se tu nejak sesptat nebo nromalne na yed<
08:40:18 <Jirda> tohle moc neynam
08:40:27 <dolio> emptyElim e = case e of {}, versus emptyElim e = error "empty elim"
08:40:36 <blackh> Jirda: ^ is right-associative.  If you type :info ^ into ghci, it says "infixr"
08:40:49 <ski> Baughn,Twey : .. so an exhaustive, non-overlapping matching on a value of type `Void' would be matched on by `case <expr> of {}' (requiring no branches, since there can't be any real total value)
08:41:00 <ski> Twey : no, the type is different
08:41:04 <ski> @type either
08:41:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:41:07 <ski> @src either
08:41:07 <lambdabot> either f _ (Left x)     =  f x
08:41:07 <lambdabot> either _ g (Right y)    =  g y
08:41:10 <trin_cz> Jirda: da se jit i na #haskell.cz
08:41:15 <ski>   void :: forall a. Void -> a
08:41:18 <Jirda> aha, zkusim prejit
08:41:22 <ski>   void v = case v of {}
08:41:49 <Twey> Then, ‘void = const undefined’?
08:41:57 <Twey> Oh, but the forcing
08:42:01 <ski> Twey : also, `case <expr> of {}' by itself wouldn't be nonterminating .. `<expr>' itself, if it has type `Void', would not be a total expression
08:42:03 <Twey> Okay
08:43:00 * ddarius agrees with ski.
08:43:00 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
08:43:16 <ski> (of course, one could imagine using `case <expr> of {}' on expressions of types not having zero constructors .. then it's merely a non-exhaustive matching)
08:44:56 <ozataman> Hey all. I'm having a very annoying problem with encodings on a Linux box. When I scrape a web page with Network.Curl and try to save the page with writeFile, I keep getting "hClose: invalid argument (Invalid or incomplete multibyte or wide character)" errors. When I do the same thing on my Mac, I don't get any of these errors. Any ideas on how I can solve this?
08:45:50 <Baughn> ozataman: What's your locale setting?
08:45:59 <ozataman> Baughn: How can I check that?
08:46:02 <Baughn> ..though getting that error on /hClose/ of all things.. :/
08:46:05 <Baughn> ozataman: locale -a
08:46:14 <Baughn> ozataman: Er, wait. Just locale.
08:46:25 <ozataman> Baughn: I get: 
08:46:28 <ozataman> LANG=
08:46:28 <ozataman> LC_CTYPE="POSIX"
08:46:29 <ozataman> LC_NUMERIC="POSIX"
08:46:29 <ozataman> LC_TIME="POSIX"
08:46:29 <ozataman> LC_COLLATE="POSIX"
08:46:30 <ozataman> LC_MONETARY="POSIX"
08:46:30 <ozataman> LC_MESSAGES="POSIX"
08:46:31 <ozataman> LC_PAPER="POSIX"
08:46:31 <ozataman> LC_NAME="POSIX"
08:46:31 <ozataman> LC_ADDRESS="POSIX"
08:46:31 <ozataman> LC_TELEPHONE="POSIX"
08:46:32 <ozataman> LC_MEASUREMENT="POSIX"
08:46:32 <ozataman> LC_IDENTIFICATION="POSIX"
08:46:32 <ozataman> LC_ALL=
08:46:36 * ddarius thinks Haskell + extensions should get rid of which edge cases they have.
08:46:39 <Baughn> ..waah
08:46:45 <ozataman> Ah, OK. I get on my mac: 
08:46:46 <ozataman> LANG="en_US.UTF-8"
08:46:47 <ozataman> LC_COLLATE="en_US.UTF-8"
08:46:47 <ozataman> LC_CTYPE="en_US.UTF-8"
08:46:47 <ozataman> LC_MESSAGES="en_US.UTF-8"
08:46:48 <ozataman> LC_MONETARY="en_US.UTF-8"
08:46:48 <ozataman> LC_NUMERIC="en_US.UTF-8"
08:46:48 <ozataman> LC_TIME="en_US.UTF-8"
08:46:48 <ozataman> LC_ALL=
08:46:51 <Baughn> ..STOP!
08:46:57 <ozataman> Baughn: Sorry :)
08:46:59 <Zao> ozataman: You know, pastesites are nice.
08:47:07 <Baughn> ozataman: I was about to say I only wanted LC_CTYPE, but you should under no circumstances paste such huge amounts of data
08:47:09 <ozataman> Zao: Sorry about that guys
08:47:10 <ski> Twey,Baughn : btw, another use for this syntax, i think, would be to use it in cases like you have a GADT `data T :: * -> * of Foo :: T Bool; Bar :: T Int' and then you are defining `f :: T Char -> Whatever' by `f t = case t of {}'
08:47:36 <Zao> ozataman: Set LANG to something decent, preferably UTF-8?
08:47:38 * Twey doesn't understand GADTs yet.
08:47:41 <Baughn> ozataman: Anyway, you need to set your locale properly. THat *should* have been set on login; what distro and window manager do you use?
08:47:58 <Cale> ozataman: In any case, you can use hSetEncoding to set the text encoding of a handle
08:48:04 <Baughn> ozataman: As it is now, nothing but ASCII will work properly (writeFile only works on text)
08:48:10 <ski> (ddarius : indeed)
08:48:14 <Zao> Or if you're on recent Ubuntus, "utf8", as they're idiots.
08:48:17 <ozataman> Baughn: The linux box is actually on a cloud service, so don't have any window managers.
08:48:20 <Cale> If you rely on a particular encoding being used in your program, it's a good idea to set it.
08:48:22 <runiq> I got a little problem, see: http://hpaste.org/40034/fibonacci_list – I don’t know how to get rid of that error…
08:48:28 <Baughn> ozataman: Though I should mention, you probably want a Data.ByteString.writeFile, not plain String-based writeFile
08:48:51 <ozataman> Baughn: I thought about using ByteString, but Curl outputs String
08:48:53 <Baughn> ozataman: Okay. In that case, 'export LANG=en_US.UTF-8' in your login script or so.
08:49:02 <ddarius> The only thing that GADTs do that's new is they allow you to have localized contexts (either type classes or type equalities) that are revealed upon pattern matching.
08:49:11 <ozataman> Baughn: OK, let me try that.
08:49:12 <Baughn> ozataman: I figured it would. Let me see..
08:49:13 <zygoloid> runiq: change fiblist _ [1,0] to fiblist limit [1,0]
08:49:14 <Cale> runiq: In the first line of your definition of fiblist, you're not binding the variable limit on the left hand side of the = sign
08:49:18 <blackh> ozataman: Curl is old-fashioned.
08:49:23 <ski> (my main point being that *at*least* `EmptyDataDecls' should enable the `case <expr> of {}' syntax .. one could also consider some kind of absurd patterns, like Agda2 has)
08:49:32 <ozataman> blackh: yeah :) any ideas what I could use instead?
08:49:45 <ozataman> blackh: I get the page with curl and parse with hxt
08:49:57 <zygoloid> runiq: your next error is on line 9, where you probably meant (x:y:rest) not [x:y:rest]
08:50:05 <Cale> Baughn: Note that in recent GHCs, writeFile will write proper unicode.
08:50:18 <blackh> ozataman: hxt is also old-fashioned.  Just convert it to a ByteString.
08:50:29 <Cale> (More specifically, it will follow the system's choice of encoding by default, and can be made to write utf8)
08:50:30 <ozataman> Cale: Right, I started seeing this after I upgraded to 12.3
08:50:35 <runiq> Thanks, both of you!
08:50:48 <Baughn> Cale: Yeah, that's the problem..
08:51:04 <Baughn> curl assumes String is latin-1 or something
08:51:09 <Baughn> It needs a rewrite.
08:51:31 <Baughn> ozataman: Can you use the HTTP package instead?
08:51:40 <ozataman> Baughn: I can certainly try
08:51:49 <blackh> ozataman: And use hexpat instead of hxt.  I should know because I wrote it.
08:52:11 <ozataman> blackh: Nice, let me check that out
08:52:27 <vanadium> blackh: which one
08:52:31 <blackh> ozataman: I'd be grateful for any feedback you can give me.
08:52:37 <blackh> vanadium: I wrote hexpat
08:53:01 <ozataman> blackh: Sure thing. I do a lot of html parsing and I will give hexpat a try next time.
08:53:42 <blackh> ozataman: hexpat only does XML, so you might need to use tagsoup
08:53:48 <ozataman> Baughn: So curl assumes latin1 even when the site returns utf8. I'm not sure how to do a re-write like you mentioned
08:54:00 <Baughn> ozataman: Don't. Use the HTTP package instead.
08:54:21 <Baughn> ozataman: http://hackage.haskell.org/package/HTTP
08:55:29 <runiq> zygoloid: Hm, the next error occurs on l. 8 actually… I changed the [x:y:rest] on that line to [x,y,rest], since this is supposed to be the function’s return value and not a pattern
08:55:32 <ozataman> Baughn: OK will do. BTW, setting LANG= at least allows the scraper to run without crashing. 
08:55:46 <ddarius> Twey: If you have data Foo a where NumProof :: Num a => Foo a and then you write f :: Maybe (Foo a) -> a -> a; f (Just NumProof) x = x+1; f Nothing x = x we have a Num context in the first branch when pattern matching on NumProof and thus can use it.  You can think of NumProof :: Num a => Foo a as being NumProof :: NumDict a -> Foo a.
08:55:46 <Baughn> ozataman: Sure, until you hit some webpage that isn't itself in utf-8.
08:55:59 <runiq> Error:   Couldn't match expected type `Int' against inferred type `[Int]' In the expression: rest
08:56:00 <ozataman> Baughn: I think it is because the website returns utf8, and when the env is set to utf8, at least writeFile does not complain when it sees UTF8 encoding bytes
08:56:01 <zygoloid> runiq: i think the line numbers in the paste are off by one from the line numbers in the file
08:56:11 <ddarius> Twey: When you write data Foo a where Foo :: Foo Int, that means data Foo a where Foo :: (a ~ Int) => Foo a.
08:56:21 <zygoloid> runiq: (x:y:rest) isn't just a pattern. pretty much all patterns are also expressions
08:56:30 <Baughn> ozataman: HTTP lets you get the raw bytes instead, which is much (much) faster if all you want to do is save them
08:56:32 <zygoloid> (expressions for the same value the pattern would match)
08:56:34 <runiq> Agh, you’re right - I’ll refer to the pastebin numbers from now on :/
08:57:13 <Starfire> Is there some difference between Foo Int and (a ~ Int) => Foo a ?
08:57:22 <Baughn> ozataman: For robust parsing, of course, you need to interpret the encoding header, the HTML meta command and all the other possibilities.. bit of work.
08:57:26 <zygoloid> runiq: so x:y:rest is a list which contains (length rest) + 2 elements: x, then y, then the contents of rest
08:57:30 <ddarius> Twey: (And if you'd like to consider what a witness for (a ~ Int) would be, you could use (a -> Int, Int -> a).
08:57:31 <Baughn> (Hopefully something already does that)
08:57:51 <zygoloid> runiq: [x,y,rest] would be a list containing exactly three elements, and only makes sense if x, y and rest are the same type (which they aren't)
08:58:28 <Baughn> [toDynamic x, toDynamic y, toDynamic rest] ^_^
08:58:31 <runiq> zygoloid: Ah, right, of course
08:58:32 <ddarius> Indeed, if we didn't have GADTs or type equalities we could get the same effect, albeit much more noisily, by passing such witnesses around explicitly.
08:58:33 <Baughn> (Ignore that)
08:58:58 <ddarius> GADTs also provide a different syntax for existential quantification.
09:00:05 <Twey> ddarius: Is ~ read ‘is isomorphic to’?
09:00:10 <blackh> Starfire: I don't think there's any difference between those two, but I think there are some situations where things don't work as expected
09:00:14 <ski> it is read "equals"
09:00:15 <ddarius> Twey: No, "is equal to".
09:00:18 <Twey> Oh
09:00:21 <ddarius> Twey: It just delays unification.
09:00:36 <Twey> O…kay
09:00:40 <ski> (imo, then should have used the `=' symbol .. grmbl)
09:01:09 <ddarius> In fact, if you look at papers like "A Lightweight Encoding of Generics and Dynamics" which were related to papers on "first class phantom types" which were a simplified form of GADTs, you see an encoding very much like I described.
09:02:48 <runiq> zygoloid: Thank you very much, it works now - I had some other errors that I didn’t see before. Having kind of a hard time with patterns and where I’m allowed to put them :)
09:02:57 <ddarius> Though "A Lightweight Encoding of Generics and Dynamics" uses the extra flexibility to use isomorphisms rather than equalities.
09:03:40 <ddarius> Twey: The key thing that GADTs are doing, though, is providing those localized, data dependent contexts.  Type equalities are orthogonal.
09:04:36 * hackagebot hoauth 0.3.1 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.3.1 (DiegoSouza)
09:20:46 <ozataman> is there a good way to marshall haskell data structures to and from a file on disk?
09:21:38 <ozataman> Baughn: Thank you for your help. The scraper works for now and I will migrate the crawling bits over to HTTP.
09:22:02 <tab> ozataman: depends how you define good
09:22:13 <ozataman> tab: easy, practical :)
09:22:16 <cizra> ozataman: show / read for simple things?
09:22:16 <lambdabot> cizra: You have 4 new messages. '/msg lambdabot @messages' to read them.
09:22:16 <tab> ozataman: the easiest is probably to derive read and show
09:22:35 <ozataman> tab: just want to save a Map (Double, Double) (String, String, String) somewhere on disk to be used later
09:22:51 <Baughn> ozataman: For better efficiency, use Data.Binary/Data.Serialize
09:23:09 <quicksilver> that type already has a built-in Show/Read instance
09:23:14 <Baughn> You can use the Derive package to autogenerate the instances
09:23:20 <quicksilver> so if it's fairly small, using that would be the simplest possible solution
09:23:28 <quicksilver> probably OK for, I dunno, less than 10,000 entries?
09:24:06 <quicksilver> after that, yes, derive Binary or Serialize.
09:24:22 <Baughn> Or perhaps use a database of some kind
09:24:23 <tab> ozataman: you can probably try read/show in less than 5min and see if the performance are OK for your case
09:25:33 <ozataman> Thanks guys
09:29:44 * hackagebot graph-rewriting-layout 0.4.3 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.4.3 (JanRochel)
09:30:46 * hackagebot graph-rewriting-lambdascope 0.4.7 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.7 (JanRochel)
09:32:31 <gwern> unix file permissions foil me again; what's the incantation to make a folder in ~/public_html/ publicly readable?
09:32:53 <edwardk> 755
09:33:01 <mornfall> a+rwX -R
09:33:03 <zygoloid> a+r
09:33:10 <mornfall> Sorry.
09:33:15 <mornfall> Without w obviously. :)
09:33:17 <mornfall> a+rX -R
09:33:19 <edwardk> Or chmod go+rx
09:33:34 <zygoloid> not rX not rx, if you're doing it recursively
09:33:40 <zygoloid> s/^not //
09:34:01 <gwern> before I think I was trying 'chmod -R a+r archiver/'
09:34:19 <gwern> looks like 'chmod -R 755 archiver/' did the trick
09:34:29 <gwern> anyoen able to darcs get http://community.haskell.org/~gwern/archiver/ ?
09:34:35 <zygoloid> gwern: all the files in archiver/ will be executable now :/
09:34:36 <mornfall> It also screwed your file permissions, though.
09:34:40 <edwardk> I was just making thr folder readable. He didnt ask for the contents. ;)
09:34:57 <gwern> ~-~ a pox upon your beard, kernighan and ritchie
09:35:00 <edwardk> And only the folder should be executable
09:35:46 * hackagebot iyql 0.0.7 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.7 (DiegoSouza)
09:36:36 <gwern> this would be a lot easier if c.h.o weren't slow as a pig right now
09:36:54 <edwardk> find . -type d -print | xargs -irpl chmod go+rx rpl.  # much simpler
09:37:55 <gwern> don't include things like periods in liens that are apparently literal :)
09:38:00 <zygoloid> edwardk: what's wrong with a+X?
09:40:27 <edwardk> That I never remember it exists ;)
09:41:18 <zygoloid> hmm, i would have sworn we were in -blah :o
09:41:42 <edwardk> Sorry
09:42:52 <zygoloid> no-one's complained, i think we got away with it
09:44:36 <zygoloid> > fix(scanl(+)1)
09:44:37 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:44:43 <zygoloid> > fix((0:).scanl(+)1)
09:44:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:45:19 <edwardk> Nice cover
09:45:37 <zygoloid> :)
09:46:23 <EvanR-work> is coprime the same thing as relatively prime
09:46:57 <edwardk> Yes
09:48:31 <PatrickRobotham> two numbers are coprime if their greatest common divisor is 1
09:49:09 <zygoloid> two numbers are relatively prime if they're both pretty close to being prime ;)
09:52:15 <PatrickRobotham> lol
10:12:25 <c_wraith> aaaaaargh.  Can we abolish String now?
10:13:26 <c_wraith> I don't care in the slightest how "elegant" is appears at first glance.  In the end, it's a pain in the ass to write instances sanely because of string.  I guess I'm off to copy the Show hack.
10:13:55 <c_wraith> Seriously, the fact that the Show hack was necessary *should* have been a hint that the definition of String was wrong.
10:15:26 <aristid> c_wraith: you mean it should at least have been a newtype?
10:15:39 <c_wraith> yes.
10:15:49 <tehgeekmeister> are maps (like data.map) algebraic datatypes?  friend asked and i had no clue what the answer would be.
10:16:22 <aristid> c_wraith: the advantage is that all list algorithms work on string unmodified
10:16:55 <c_wraith> aristid, most of the list algorithms are either string algorithms, or wrong on strings
10:17:09 <aristid> c_wraith: like.. take?
10:17:16 <conal> c_wraith: good point about the Show hack as clue.  that connection had never occurred to me.
10:17:40 <gwern> hm. has anyone used hinotify? after I've added a watch, then what?
10:17:51 <gwern> can I just do a big threadDelay?
10:20:58 <c_wraith> aristid, there are a few things that make sense to be common.  But not most operations.  And the existing definition is just hell if you want sane instances.
10:21:54 <aristid> c_wraith: maybe there should be typeclasses for these operations
10:21:59 <zygoloid> tehgeekmeister: sure. you could represent them with "data Map k v = Node k v (Map k v) (Map k v) | Leaf", for instance.
10:22:23 <EvanR-work> gwern: reading from the watch fd blocks until something happens
10:22:59 <gwern> EvanR-work: but what is reading? http://hackage.haskell.org/packages/archive/hinotify/0.3.1/doc/html/System-INotify.html#t:WatchDescriptor says it's basically empty
10:24:02 <gwern> EvanR-work: my current version is http://hpaste.org/40035/archiver
10:24:19 <c_wraith> Well, show hack copied successfully.  That's not actually so bad to implement, but it's really kind of ugly. :(
10:24:54 <EvanR-work> gwern: i only know about C inotify and the amazing shell script inotifywait
10:25:12 <ski> tehgeekmeister : `Map' is an abstract datatype, so the question has no meaning, wrt the published interface of the type
10:25:31 <Cale> gwern: Well, if the type of addWatch is to be interpreted in the obvious way, the callback that is passed to addWatch will be called whenever an event you're waiting for happens. So you just go on with your program and let the event happen when it happens. If you have nothing to do, then just block forever, I suppose.
10:25:42 <tehgeekmeister> ski: abstract datatype?  and i wasn't talking about the implementation, but rather the general datatype
10:25:53 <gwern> Cale: that's what I was thinking, where block forever = threadDelay
10:25:57 <ski> tehgeekmeister : the *implementation* could be an algebraic datatype, yes, but that's then an implementation detail, and it could possibly be defined in different ways
10:26:03 <zygoloid> tehgeekmeister: being an algebraic type is a property of the implementation
10:27:19 <ski> tehgeekmeister : some types are "published" as being implemented as an algebraic datatype, like `data Maybe a = Nothing | Just a', e.g., i.e. that they are algebraic datatypes, and what their data constructors are, are a part of their specified interface
10:28:01 <ski> tehgeekmeister : for other types, such as `IO' and `Map' and `(->)', there is no specific implementation specific, apart from that it must behave in certain ways
10:30:01 <Cale> gwern: You could also do something like atomically retry
10:30:34 <Cale> (That uses STM, but it's a handy way to block)
10:31:06 <c_wraith> Heh.  I never thought of that as a handy block forever technique
10:31:19 <gwern> atomically retry?
10:31:29 <EvanR-work> seems like a haskell binding would make it easy to have a thread block until something happens
10:32:35 <Cale> retry is an STM transaction which temporarily aborts the transaction without committing changes made, and waits for one of the variables read so far in the transaction to change before retrying.
10:32:57 <Cale> atomically :: STM a -> IO a
10:33:14 <Cale> will execute an STM transaction
10:33:35 <Cale> So this is a transaction which will never successfully complete, and will never be rescheduled.
10:33:50 <edwardk> Just use bytestrings, ropes, vectors or whatever is most appropriate, c_wraith, string isn't all that special
10:34:05 <gwern> Cale: that sounds like a bad way to block forever...
10:34:23 <Cale> It's a fine way to do it, because it uses no CPU.
10:34:36 <edwardk> Woops i got disconnected, that was probably ancient
10:34:39 <c_wraith> edwardk, doesn't work in this case.  I'm using it almost entirely with literals.  And using OverloadedStrings would require an explicit type signature on every single literal.  Several thousand of them.
10:34:51 <Cale> and, at least for now, GHC doesn't catch it and throw an exception
10:35:28 <c_wraith> This is code in a framework for creating test scripts.  They have lots of literal expected values in them.
10:35:32 * hackagebot tls 0.1.2 - TLS protocol for Server and Client sides  http://hackage.haskell.org/package/tls-0.1.2 (VincentHanquez)
10:35:33 <nullkuhl> is this the same haskell as ghc 6.8 haskell ?
10:35:46 <Cale> nullkuhl: yes?
10:35:47 <c_wraith> nullkuhl, that's an old version, but yes
10:35:55 <edwardk> Or a sufficiently unambiguous type on the surrounding combinators
10:36:38 <nullkuhl> am trying to learn that version of haskell, am not sure how much different is the new one
10:36:58 <c_wraith> edwardk, the whole point is that the surrounding combinators are polymorphic in types of values that might be tested.  lists of values are valid things to test...  Hence, problems
10:37:00 <nullkuhl> any good books / links suggestions ? i code c/c++, java already
10:37:08 <Cale> nullkuhl: Well, the language itself is basically the same. The new version of GHC produces better code and has a few new extensions.
10:37:16 <Cale> Sure.
10:37:24 <xplat> what are the advantages and disadvantages of using OverloadedStrings
10:37:28 <Cale> @where lyah
10:37:28 <lambdabot> http://www.learnyouahaskell.com/
10:37:31 <Cale> @where rwh
10:37:32 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:37:34 <gwern> Cale: but threadDelay ought to be just as efficeint and a lot more understandable, I thought
10:37:35 <Cale> @where yaht
10:37:35 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:37:38 <Cale> @where wikibook
10:37:38 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:37:54 <edwardk> x :: MyOverloadedString -> MyOverloadedString
10:37:59 <Cale> gwern: You can't threadDelay forever, eventually you have to wake up again.
10:38:01 <xplat> does it work basically as well as overloading on numerics?
10:38:12 <edwardk> foo (x "and?")
10:38:13 <gwern> Cale: threadDelay maxBound works well enough
10:38:19 <gwern> I don't have infinite uptime anyway
10:38:34 <c_wraith> gwern, check your math.  threadDelay is microseconds
10:39:05 <c_wraith> gwern, if you're on a 32 bit system, you can hit that pretty quickly
10:39:19 <gwern> c_wraith: I am; so what does that sleep for?
10:39:23 <Cale> threadDelay maxBound is about 35 minutes
10:39:41 <Cale> Which, granted, is large enough
10:39:50 <c_wraith> > (maxBound :: Int32) / (1000 * 1000 * 60)
10:39:51 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Int.Int32)
10:39:51 <lambdabot>    arising from a use o...
10:40:04 <c_wraith> > (maxBound :: Int32) `div` (1000 * 1000 * 60)
10:40:04 <lambdabot>   35
10:40:10 <edwardk> or: (<%>) :: (S -> a) -> S -> a 
10:40:14 <gwern> hm. 35 minutes is not enough
10:40:20 <gwern> @hoogle threadDelay
10:40:20 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
10:40:29 <Cale> It's enough if you wrap it in forever
10:40:33 <edwardk> foo <%> "not a problem"
10:40:36 <Cale> Not to kill the CPU
10:40:49 <Cale> Waking up once every 35 minutes isn't *so* bad
10:40:52 <Cale> it's not ideal though
10:41:31 <xplat> i wouldn't want to do that on laptops or phones
10:41:53 <c_wraith> eh.  waking up once every 35 minutes isn't going to kill anything's battery
10:41:56 <xplat> people on laptops would want to kick my ass for spinning up their hard drive or something
10:42:40 <c_wraith> How smart is MVar infinite wait detection, again?
10:42:51 <gwern> eh. people on laptops would already be annoyed by it waking up every 40 seconds or so to archive URLs when it's actually active
10:43:05 <c_wraith> there's always things like newEmptyMVar >>= takeMVar
10:43:20 <c_wraith> Except I think the runtime might detect that and signal an exception
10:43:28 <xplat> what are you writing?
10:44:53 <xplat> 6.8.2 doesn't detect newEmptyMVar >>= takeMVar, although it might if something else was alive to trigger a gc
10:45:01 <gwern> version with sleep: http://hpaste.org/paste/40035/archiver_with_sleep#p40036
10:46:04 <conal> i tried "newEmptyMVar >>= takeMVar" for unamb.  ghc was too smart.  generated a run-time warning about a deadlocked thread.
10:46:34 <conal> fooled me at first, as the warning didn't show up with ghci.
10:46:48 <gwern> a sufficiently smart compiler eh
10:46:54 <conal> :)
10:47:05 <ski> (Cale : heh, first though you were talking about you taking short naps :)
10:47:07 <conal> an insufficiently stupid compiler.
10:48:14 <conal> i think i used "forever (delayThread maxBound)", as suggested by spencer janssen.
10:48:23 <zygoloid> gwern: you could open a handle then read on it
10:48:39 <conal> before switching to another approach altogether.
10:48:48 <nullkuhl> hello, does haskell has a base n log function in it's standard library ?
10:48:53 <gwern> zygoloid: this isn't about golfing a sleep >.<
10:48:58 <gwern> @hoogle log
10:48:58 <lambdabot> Prelude log :: Floating a => a -> a
10:48:58 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
10:48:58 <lambdabot> Network.CGI logCGI :: MonadIO m => String -> m ()
10:48:58 <conal> :t logBase
10:48:59 <lambdabot> forall a. (Floating a) => a -> a -> a
10:49:15 <gwern> > logBase 10 2
10:49:15 <lambdabot>   0.30102999566398114
10:49:46 <xplat> is there a good iteratee-style HTTP client library?
10:50:06 <conal> xplat: what qualities do you want?
10:50:39 <edwardk> Xplat: good idea but i dont know of one
10:50:43 <conal> xplat: (ie good at what?)
10:51:41 <conal> saw this one yesterday: http://hackage.haskell.org/package/http-enumerator
10:51:44 <xplat> good quality HTTP 1.1 implementation (persistent connections, etc)
10:52:04 <nullkuhl> can i create constant numbers in haskell to be used globaly in several functions ?
10:52:15 <zygoloid> gwern: you don't /want/ a sleep, though. you want to set your thread into a not-runnable state permanently.
10:52:31 <edwardk> The existing http library is frustrating becase it grossly inefficient appending bytestring after bytestring. Even lazy the asymptotics are wrong for large results
10:52:32 <ski> nullkuhl : like `fortyTwo = 42' ?
10:52:39 <edwardk> Er it is
10:52:58 <gwern> zygoloid: perhaps. I am practical though, and sleep is easy
10:52:59 <xplat> 0.0.0 is a pretty scary version number, even for haskell
10:53:06 <zygoloid> threadDelay is one hack to return the RTS' select loop, read is another.
10:53:12 <nullkuhl> ski: yes
10:53:20 <edwardk> And it gives you ALMOST enough of an exposed api to fix that. ;)
10:53:43 <nullkuhl> ski: actually it's the golden ratio
10:53:58 <xplat> @src pi
10:53:59 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:54:08 <mreh> > phi 
10:54:09 <lambdabot>   Not in scope: `phi'
10:54:09 <zygoloid> nullkuhl: sure, just define it at the top level in some module.
10:54:13 <nullkuhl> ski: am not sure if i should recalculate it in haskell then store it, or just grab the first n decimal digits from web and store it
10:54:33 <xplat> @src Double pi
10:54:33 <lambdabot> Source not found.
10:54:35 <ski> nullkuhl : if you want to use it for other number types than `Integer', you'll want to give a type signature (or use `NoMonomorphismRestriction')
10:54:47 <zygoloid> > let phi = (1 + sqrt 5)/2 in (phi, phi^2 - 1)
10:54:48 <lambdabot>   (1.618033988749895,1.618033988749895)
10:54:58 <ski> nullkuhl : .. what zygoloid said
10:55:01 <mreh> I was going to ask how you do it
10:55:05 <mreh> but there you go
10:55:23 <zygoloid> > let phi = (1 + sqrt 5)/2 in phi :: CReal
10:55:24 <lambdabot>   1.6180339887498948482045868343656381177203
10:55:26 <ski> nullkuhl : don't write the digits yourself. write the formula for it, as zygoloid showed
10:55:30 <mreh> I would have done it by Newton
10:56:10 <xplat> no need to use Newton for a mere square root
10:56:12 <zygoloid> probably best to not use CReal in a real program, it's not very fast.
10:57:03 <mreh> are we solving a / b = (a + b) / a?
10:57:19 <xplat> :t ShowCReal
10:57:20 <lambdabot> Not in scope: data constructor `ShowCReal'
10:57:25 <xplat> :t showCReal
10:57:26 <lambdabot> Int -> CReal -> String
10:57:42 <xplat> showCReal n pi is not linear in n, i've noticed
10:58:08 <xplat> which makes sense in retrospect, but i wonder if it would be in hex
10:58:49 * hackagebot ref-tf 0.1 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-tf-0.1 (GeoffreyMainland)
10:58:51 * hackagebot ref-fd 0.1 - A type class for monads with references using functional  dependencies.  http://hackage.haskell.org/package/ref-fd-0.1 (GeoffreyMainland)
10:59:14 <nickela> @unpl fix ((0 :) . (1 :) . (zipWith (+) <*> tail))
10:59:15 <lambdabot> fix (\ e -> 0 : (1 : (((zipWith (+)) <*> tail) e)))
10:59:39 <zygoloid> > let search f x | abs (y - x) < 0.00000001 = y | otherwise = search f ((x+y)/2) where y = f x in 1 - search (\phi -> phi^2 - 1) 1
10:59:40 <lambdabot>   1.6180339909527763
10:59:59 <xplat> maybe it would be better to have the existing http library just download things to tempfiles and then process the tempfiles with iteratees
11:01:10 <xplat> or i wonder if it exposes enough to hack something together with threads and channels
11:02:37 <mreh> can anyone in York deliver Nilson a message?
11:03:04 <sioraiocht> shapr: kommer du från Sverige? Eller är du bara svensk?
11:03:23 <zygoloid> mreh: which York?
11:03:29 <ski> (sioraiocht : ingetdera ..)
11:03:34 <mreh> zygoloid: I think I meant Nottingham
11:03:42 <mreh> UK
11:03:56 <nickela> @pl \x->x*x
11:03:57 <lambdabot> join (*)
11:04:38 <shapr> sioraiocht: Jag kommer från Alabama! Den del av Alabama som talar Svenska!
11:07:59 <nickela> :t join
11:08:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:08:25 <applicative> > join ["hahah", "hoho"]
11:08:26 <lambdabot>   "hahahhoho"
11:08:43 <nickela> :t join (*)
11:08:44 <lambdabot> forall a. (Num a) => a -> a
11:08:46 <zygoloid> > join (++) "haha"
11:08:48 <lambdabot>   "hahahaha"
11:09:37 <nickela> hm, join is surprising like filterM :-)
11:09:39 <applicative> > join [Just (Just 'a')), Just Nothing]
11:09:40 <lambdabot>   <no location info>: parse error on input `)'
11:09:45 <applicative> oh no
11:10:07 <applicative> > join (Just (Just 'a')), Just Nothing)
11:10:08 <lambdabot>   <no location info>: parse error on input `,'
11:10:21 <nickela> > join [Just (Just 'a'), Just Nothing]
11:10:22 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe GHC.Types.Char]'
11:10:22 <lambdabot>         ag...
11:10:23 <applicative> oh well. supposed to be a pair of joined.  
11:10:25 <zygoloid> > join (Just (Just "Hello"))
11:10:26 <lambdabot>   Just "Hello"
11:10:31 <zygoloid> > join (Just Nothing)
11:10:32 <lambdabot>   Nothing
11:11:11 <Ferdirand> > join Nothing
11:11:12 <lambdabot>   Nothing
11:11:29 <applicative> > (join (Just (Just 'a')), join (Just Nothing) ) -- Thanks, zygloid, I was trying to economize....
11:11:30 <lambdabot>   (Just 'a',Nothing)
11:11:36 <monoidal> > join (,) 5
11:11:37 <lambdabot>   (5,5)
11:11:57 <applicative> @type join (,)
11:11:58 <lambdabot> forall a. a -> (a, a)
11:12:07 <zygoloid> > join (Left (Right (Left (Right (Left (Right "Atten-TION!"))))))
11:12:08 <lambdabot>   No instance for (Control.Monad.Error.Class.Error
11:12:08 <lambdabot>                     (Data....
11:12:12 <zygoloid> ;(
11:12:26 <monoidal> > join (Right (Left (Right (Left (Right (Left (Right "Atten-TION!")))))))
11:12:27 <lambdabot>   No instance for (Control.Monad.Error.Class.Error
11:12:27 <lambdabot>                     (Data....
11:12:31 <nickela> I'm confusing in join with functions, why ' join (\x y-> x*y)' transformed to x->x*x ?
11:12:47 <zygoloid> nickela: it's the Monad ((->) r) instance.
11:12:57 <monoidal> it's (r->) monad: r->r->a is converted to r->a
11:13:03 <applicative> @type (,)
11:13:04 <lambdabot> forall a b. a -> b -> (a, b)
11:13:18 <nickela> Ahh, it is like for Applicative fmap?
11:13:32 <applicative> @type (\x y-> x*y)
11:13:33 <lambdabot> forall a. (Num a) => a -> a -> a
11:13:35 <zygoloid> nickela: it's collapsing two levels of functor down to one
11:13:39 <nickela> > (*) <*> 5
11:13:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:13:40 <lambdabot>    arising from a use of `...
11:15:25 <kmc> fmap is Applicative's fmap
11:15:31 <kmc> every Applicative is a Functor
11:15:39 <nickela> > (*) <*
11:15:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:15:51 <kmc> @src (->) (>>=)
11:15:51 <lambdabot> f >>= k = \ r -> k (f r) r
11:15:58 <kmc> nickela, ^^^^ monad instance for functions
11:16:25 <moosefish> Is there a mapping of 'ghc version' to 'perl version the evil mangler is known to work with' ?
11:16:33 <nickela> aha, now understand :)
11:16:42 <moosefish> (that is, if I want to compile GHC $FOO, which versions of perl do I need?)
11:17:04 <applicative> moosefish, I was wondering about that on macs, the macports portfile insists on one in particular
11:17:05 <monoidal> can I convert STRef s (a,b) into STRef s a?
11:17:09 <kmc> join f = (f >>= id) = (\r -> id (f r) r) = (\r -> f r r)
11:17:14 <bos> moosefish: "a modern perl" should be good enough
11:17:17 <monoidal> or, join STRef s a and STRef s b into STRef s (a,b)?
11:17:25 <moosefish> applicative: Yeah, that's exactly the mess I'm in
11:17:42 <moosefish> (as a bonus, it's not even my installation, but some upstream maintainer's)
11:18:18 <nickela> > ((*) <*> (+1)) 5
11:18:18 <moosefish> applicative: You aware of a ghc bug number or some other note I can point upstream too?
11:18:19 <lambdabot>   30
11:18:31 <moosefish> *to
11:18:53 <kmc> monoidal, no, but you can use something like fclabels / lenses / data-accessor to update parts of a structure within the whole
11:19:27 <applicative> what's the most up to date perl 5?
11:20:26 <moosefish> depends. Apple-provided is still 5.8
11:20:31 <moosefish> 5.12 is out upstream, I'm fairly sure
11:20:42 <moosefish> I think you get 5.10 in macports and/or fink, depending on phase of the moon
11:21:27 <gwern> oh, did anyone notice marlow's patch to make quickcheck work with ghc 7
11:21:34 <gwern> threw me for a loop for a while
11:21:39 <gwern> since I read it as ghc 6.7
11:21:47 <gwern> 'why would he be working on such an old ghc?'
11:21:49 <moosefish> next version is not 6.14?
11:22:31 <Zao> 7.0, because of the fancy new type checker and all.
11:22:34 <applicative> I have 5.10 in /usr/bin in 'snow leopard'
11:22:40 <monoidal> 6.14 == 7.0, floating point inaccuracies
11:22:46 <Zao> Judging by a recent post to the lists, RCs are likely out very soon.
11:22:49 <applicative> maybe the portfile is taking account of earlier os's
11:22:50 <mauke> preflex: calc '2 6.14
11:22:51 <preflex>  110.00100011110101110000101000111101011100001010001
11:23:05 <moosefish> Are we lucky enough to get a working llvm backend too?
11:24:38 <Zao> http://www.haskell.org/pipermail/cvs-ghc/2010-September/056134.html
11:25:11 <nickela> > ((+1) >>= (*)) 5 == ((*) <*> (+1)) 5
11:25:12 <lambdabot>   True
11:25:19 <nickela> wow :)
11:25:52 <d-snp> > (+1)
11:25:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:25:53 <lambdabot>    arising from a use of `...
11:25:59 <d-snp> > (+1) 1
11:25:59 <lambdabot>   2
11:26:05 <applicative> moosefish, i meant to point out the curiosity that the binary installer for OS X secretly presupposes a macports perl for the evil mangling
11:26:29 <c_wraith> does evil mangling happen if you don't use the -fvia-c flag?
11:26:40 <dolio> No.
11:26:43 <applicative> no
11:26:46 <kmc> don't think so, NCG should do the right thing in the first place
11:26:49 <d-snp> > (*)
11:26:49 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
11:26:50 <lambdabot>    arising from a use...
11:26:56 <kmc> iirc LLVM has its own much smaller mangler
11:27:13 <applicative> oh really, does it require perl 3?
11:27:37 <kmc> i hope it requires perl 6
11:27:57 <applicative> but only whatever pugs can manage of it...
11:28:18 <nickela> @unpl (+1) >>= (*)
11:28:18 <lambdabot> ((\ a -> a + 1) >>= (*))
11:28:41 <nickela> @unpl (*) <*> (+1)
11:28:41 <lambdabot> ((*) <*> \ a -> a + 1)
11:29:16 <nickela> @pl \x -> x * (x+1)
11:29:16 <lambdabot> ap (*) (1 +)
11:29:50 * applicative watches another attempt to build ghc '7' fall to the curse of libiconv
11:30:14 <kmc> do ghc darcs snapshots now call themselves ghc7?
11:30:35 <kmc> it would have to be like 7.-1.20100922
11:31:06 <applicative> kmc, one was put up, a repository.  i had been trying to build 6.13-4747474
11:31:08 <dolio> Does cabal handle negative numbers in versions?
11:31:15 <dolio> I suspect not.
11:32:35 <raichoo> Hi, I'm writing a little proof of concept chat server in haskell and want to use applicative functors for it, but "main = waitForChatters <$> (listenOn (PortNumber (fromIntegral 6666))) <*> (newTVarIO [])" exits without being evaluated. What am i doing wrong?
11:32:40 <applicative> kmc http://darcs.haskell.org/ghc-7.0/ not sure what the purpose is
11:32:51 <kmc> raichoo, do you mean "executed" instead of "evaluated"?
11:33:16 <kmc> since you're using (<$>) with waitForChatters i'm guessing it doesn't return an IO value?
11:33:26 <kmc> what's the type of waitForChatters
11:33:40 <kmc> also did you write a type signature for main and waitForChatters?
11:33:47 <kmc> it is sometimes possible to make a mistake such that main :: IO (IO ()) or such
11:33:57 <kmc> main = return (print "hello world")
11:34:00 <dolio> Yeah, I bet that's what's happening.
11:34:02 <kmc> will do nothing, and pass the compiler
11:34:18 <ezyang> kmc: Really?! 
11:34:24 <ezyang> That's pretty surprising. 
11:34:31 <kmc> yup, main is allowed to be IO t for any t
11:34:32 <applicative> in which case, since join is under discussion, just write ... join $ waitForChatters <$> (listenOn (PortNumber (fromIntegral 6666))) <*> (newTVarIO [])
11:34:37 <kmc> hehe
11:34:57 <applicative> ezyang, you never make mistakes, clearly, otherwise you'd know
11:35:10 <raichoo> kmc: waitForChatters :: Socket -> TVar [(String, Handle)] -> IO b
11:35:32 <kmc> (<$>) :: (a -> b) -> IO a -> IO b
11:35:55 <applicative> so you are getting an IO (IO b), raichoo
11:36:04 <raichoo> ah ok
11:36:09 <raichoo> Thanks :)
11:36:14 * dstcruz Wonders if some users in #haskell are bots.  They are _always_ here, and they even sound human!
11:36:32 <sioraiocht> dstcruz: When one has Haskell, who needs sleep?
11:36:39 * kmc slept for 14 hours last night
11:36:59 <sioraiocht> Although
11:37:00 <sioraiocht> no dcoutts
11:37:03 <sioraiocht> bizarre...
11:37:15 <applicative> it's the same with eg.  (writeFile "bca.txt" . reverse) <$> readFile "abc.txt"  , it'd be IO (IO ())
11:37:17 <sioraiocht> Oh, it's okay, at least dons is here...
11:37:51 <hirsch> what's the best(TM) way to modify an entry of a list of lists by indices?
11:37:58 <dstcruz> I must admit to have my sleep be more troubled since starting with Haskell.  Seems like my head won't stop!
11:38:47 <sioraiocht> hirsch: don't?
11:39:10 <hirsch> sioraiocht: i have to, the indices are coordinates
11:39:13 <sioraiocht> hirsch: there's the (!!) operator
11:39:19 <IceDane> dstcruz: It's awesome, isn't it?
11:39:27 <kmc> hirsch, why are you using lists if you want random access?
11:39:37 <sioraiocht> hirsch: use Data.Vector ;)
11:39:38 <hirsch> but how can I modify the lists
11:39:56 <kmc> use Data.Sequence or Data.IntMap
11:40:15 <sioraiocht> or those
11:40:15 <dstcruz> IceDane: it sure is.  It even makes you search for jobs within the community!
11:40:16 <hirsch> I tried to use std-containers
11:40:31 <kmc> linked lists are not good for random access (in any language)
11:40:46 <hirsch> just for teaching purpose
11:41:05 <hirsch> I know that, but it's possible in other langs
11:41:43 <hirsch> zipping and list comprehension?
11:42:20 <Cale> hirsch: Split the list at the given index, and replace the element. That way you can at least share the tails.
11:43:05 <hirsch> yes, good idea, thanks
11:43:36 <Cale> @let applyAt n f xs = let (us,vs) = splitAt n xs in case vs of [] -> xs; (v:vs') -> us ++ f v : vs'
11:43:38 <lambdabot>  Defined.
11:43:53 <dstcruz> This has me scratching my head, a bit.  Care to comment? https://docs.google.com/View?id=dcsvntt2_25wpjvbbhk
11:44:10 <Cale> > applyAt 7 toUpper "Hello, world!"
11:44:11 <lambdabot>   "Hello, World!"
11:44:27 <Cale> > applyAt 7 (const 'm') "Hello, world!"
11:44:28 <lambdabot>   "Hello, morld!"
11:44:35 <dstcruz> his argument seems to be that you'll need unit tests anyway, so why bash your head against the static typing wall?
11:44:54 <kmc> dstcruz, because you need 1/10 as many unit tests
11:45:04 <kmc> "That is to say, if a program compiles in a strong, statically typed language, it just means that it has passed some tests."
11:45:04 <Cale> dstcruz: You don't need tests for things that the compiler proves for you.
11:45:09 <kmc> this is just a fundamentally incorrect statement
11:45:48 <kmc> dstcruz, it's another article which assumes that "static typing" = C++ and Java
11:45:58 <kmc> those are pretty much the strawman argument of statically typed language
11:46:04 <dstcruz> I guess a different part of his argument is that, yes, you might need less tests (as in 1/10th of them), but you'll have to work *10 times to be able to write the code.
11:46:39 <conal> dstcruz: which might be true at first.
11:46:45 <ezyang> I had an interesting conversation with one of the devs of Go. They put in a really, really simple form of type inference into their language, but they were really unhappy with the compiler requirements needed for generics. 
11:46:54 <dstcruz> I have had similar arguments with other programmers, and have been trying to understand my possition a bit better.
11:47:06 <kmc> i will not take any article seriously which pontificates about the uselessness of static types but does not mention Haskell, SML, OCaml, or Scala
11:47:39 <kmc> "C++ and Java suck, therefore every principle they follow is fundamentally bankrupt"
11:47:42 <dstcruz> It seems to be that dynamic typic is just a techie word for "sloppy polymorphism"
11:47:49 <applicative> maybe a different word is needed, not 'static types'
11:47:50 <kmc> yup
11:48:02 <applicative> 'modern types'
11:48:12 <ezyang> 'Hindley-Milner types' ? 
11:48:19 <applicative> well, yes
11:48:21 * hackagebot logic-TPTP 0.2.0.3 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.2.0.3 (KiYungAhn)
11:48:41 <kmc> anyway the correct response to such an article is http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html
11:49:02 <nullkuhl> how to read N lines of console input that each has an integer in it ?
11:49:08 <dstcruz> I guess one of the things that I like about Haskell types, and which I think Go has too, is the fact that you can implement an interface (a typeclass) _after_ the fact.  Seems that that goes a long ways in making some polymorphic things a bit easier.
11:49:18 <kmc> this author doesn't even understand the difference between "static types" and "strong typing"
11:49:34 <kmc> nullkuhl, forM readIO [1..N]
11:49:40 <kmc> replicateM N readIO
11:49:51 <kmc> yes the second thing i said
11:49:57 <dstcruz> kmc: sadly, the author is someone that I was very impressed with when reading up on OOP.  I really like his book.
11:50:03 <kmc> no not that either sorry
11:50:14 <kmc> replicateM N readLn
11:50:31 <monoidal> @src readLn
11:50:31 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
11:51:14 <kmc> dstcruz, yes, people should write about things they understand
11:51:53 <applicative> @type replicateM
11:51:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:53:11 <applicative> @type (`replicateM` readLn :: IO Int)
11:53:12 <lambdabot> parse error on input `::'
11:53:30 <dstcruz> kmc: thanks for the link ref
11:53:40 <applicative> @type (`replicateM` (readLn :: IO Int))
11:53:41 <lambdabot> Int -> IO [Int]
11:55:35 <nullkuhl> am really lost now, this psuedocode is what am trying to do in haskell http://dpaste.com/247477/
11:56:20 <nullkuhl> kmc: ^^
11:56:41 <monoidal> nullkuhl: can you do one iteration of the loop?
11:56:51 <monoidal> nullkuhl: a program that reads a,b and prints f(a,b)?
11:56:56 <Cale> nullkuhl: Want an idiomatic version or a direct translation?
11:57:28 <nullkuhl> Cale: direct translation
11:58:07 <nullkuhl> monoidal: yes
11:58:09 <monoidal> nullkuhl: the loop itself would be do n <- readLn; replicateM_ n c, where c :: IO () is a single iteration
11:59:01 <monoidal> nullkuhl: for example c = do a <- readLn; b <- readLn; print (a + b)
11:59:45 <Cale> http://paste.lisp.org/display/114786
12:00:42 <nullkuhl> thanks monoidal, and Cale i understood the whole thing from your paste thanks
12:01:02 <philed> Hey all. I'm having problems with the latest OpenGL library, telling me that there is no instance for Color (GL.Color3 GLfloat). It doesn't complain in GHCi if I import the package at the toplevel, only when I load the file or compile it. Any ideas?
12:01:53 <Cale> nullkuhl: http://paste.lisp.org/display/114786#1
12:01:54 <mightybyte> Is there a function more efficient than map to change a single character in a ByteStrinG?
12:02:05 <Cale> nullkuhl: That's probably how I'd write it though.
12:02:17 <Cale> There's also another option.
12:02:22 <mightybyte> I'm guessing no, but I thought I'd check.
12:02:45 <nullkuhl> Cale: which is ?
12:04:30 <monoidal> nullkuhl: If you have a list of IO actions, you can execute them in parallel by using "sequence". For example, main = sequence [getLine, getLine]. If you have an action a, then you can execute it n times writing sequence (replicate n a). The shortcut to that is replicateM n a.
12:04:38 <monoidal> *in sequence, not in parallel
12:04:55 <jutaro> nullkuhl: replicateM n (a <- read, ...)
12:05:27 <nullkuhl> you mean that instead of writing a loop, i write 1 iteration of the loop and replicate it N times ?
12:05:28 <Cale> nullkuhl: We can make use of various functions from Control.Monad and Control.Applicative to clean up the repetition a bit.
12:05:52 <jutaro> nullkuhl: @'Control.Monad.replicateM' n act@ performs the action @n@ times,
12:05:53 <Cale> print =<< liftM2 f readLn readLn
12:06:26 <nullkuhl> is this supported in haskell 6.8 ?
12:06:44 <Cale> yes
12:06:55 <Cale> GHC 6.8, you mean
12:06:59 <nullkuhl> yea
12:07:03 <monoidal> nullkuhl: yes, replicateM 3 [putStrLn "hello"] == sequence (replicate 3 [putStrLn "hello"]) = sequence [putStrLn "hello", putStrLn "hello", putStrLn "hello"] = do putStrLn "hello"; putStrLn "hello"; putStrLn "hello"
12:07:43 <nullkuhl> monoidal: but the problem with replicateM 3 [putStrLn "hello"]  , is that we are executing 1 function only 
12:08:18 <monoidal> oh, I made a mistake above
12:08:32 <monoidal> replicateM 3 (putStrLn "hello") == sequence (replicate 3 (putStrLn "hello")) = sequence [putStrLn "hello", putStrLn "hello", putStrLn "hello"] = do putStrLn "hello"; putStrLn "hello"; putStrLn "hello"
12:08:38 <nullkuhl> monoidal: oh this function would be mainly the 1 iternation i wrote of the loop ?
12:08:40 <monoidal> correct version is above
12:08:47 <monoidal> yes
12:08:58 <nullkuhl> i see
12:09:19 <monoidal> nullkuhl: IO actions are normal values, you can replicate them, store in datastructures etc. They are "first-class statements"
12:09:41 <Cale> nullkuhl: liftM2 is a handy function which is defined as  liftM2 f x y = do v <- x; w <- y; return (f x y)
12:10:02 <nullkuhl> so replicateM n<-readLn (func a<-readLn b<-readLn)   would execute  func(a,b), n times ?
12:10:14 <Cale> nullkuhl: Normally, if you use IO actions as parameters to functions, they aren't run automatically, like is common in C, for instance.
12:10:43 <Cale> nullkuhl: This has plenty of advantages -- it means that the function you pass them to gets to decide when or if or how many times the action gets run.
12:11:26 <monoidal> nullkuhl: argument to replicateM must be an integer, "n <- readLn" is an "action" that executes readLn and binds value to n
12:11:32 <Cale> nullkuhl: But often you want to run some actions to get the parameters to a function, which is what liftM2 is for. Control.Applicative defines some infix functions that accomplish the same thing for arbitrary numbers of arguments.
12:12:02 <monoidal> nullkuhl: so it's do n <- readLn; replicateM n (do a <- readLn; b <- readLn; f a b)
12:12:04 <djahandarie> Is there an Java interface similar to the Monoid typeclass?
12:12:19 <Cale> djahandarie: I don't even think it's possible.
12:12:55 <Cale> hmm
12:13:01 <Twey> I think it is.
12:13:05 <Twey> Horrifically clumsy, but possible.
12:13:06 <djahandarie> Why not? You'd just need to enforce an mempty of type T and mappend of (T,T) -> T
12:13:15 <djahandarie> Where T is a generic
12:13:18 <djahandarie> (Stupid Java)
12:13:28 <djahandarie> I hate doing this damn homework
12:13:30 <monoidal> djahandarie: how would you write mempty?
12:13:45 <Twey> Identity comparison, woo
12:13:54 <nullkuhl> monoidal: i can replace ; with new line ?
12:13:58 <Twey> mempty is a singleton instance
12:13:58 <monoidal> nullkuhl: yes
12:14:19 <Cale> nullkuhl: Yeah, braces and semicolons are optional, and can be determined by the code layout.
12:14:32 <djahandarie> monoidal, however is appropriate...
12:15:16 <monoidal> djahandarie: mappend(x) can be written as a method joining self and x. mempty shouldn't take any parameters, even self, so it should be static. however, static methods cannot be overriden
12:15:21 <nullkuhl> any difference between readLn and readLine ?
12:15:55 <Twey> :t readLn
12:15:56 <lambdabot> forall a. (Read a) => IO a
12:15:56 <monoidal> nullkuhl: getLine reads a string. readLn reads a string, and then parses it, giving type depending on context
12:15:57 <Twey> :t readLine
12:15:57 <Cale> nullkuhl: readLine isn't part of the Prelude, if it's defined somewhere...
12:15:58 <lambdabot> Not in scope: `readLine'
12:16:04 * djahandarie shrugs
12:16:16 <Cale> getLine will get a String without parsing it into a value of appropriate type
12:16:30 <vanadium> Why is it not getLn?
12:16:33 <vanadium> or getStrLn?
12:16:36 <djahandarie> I guess I'll just write something that only works on Numbers
12:16:50 <Cale> vanadium: I agree, the conventions seem inconsistent.
12:17:19 <djahandarie> I hope my grade doesn't go down for being way to abstract
12:17:23 <nullkuhl> hSetBuffering stdin LineBuffering  does this mean that input will be buffered ?
12:17:24 <Cale> djahandarie: One can imagine an extension of java which allows static methods inside interfaces...
12:17:38 <nullkuhl> in java usually buffered IO is faster than non buffered ones
12:17:54 <djahandarie> At least I didn't generalize my folds into different morphisms
12:17:54 <Cale> nullkuhl: yes
12:18:48 <nullkuhl> ok i wrote it but failed to load module http://dpaste.com/247506/
12:19:45 <vanadium> Your indentation is kind of crazy
12:20:27 <monoidal> nullkuhl: all lines in do-block need to be indented the same level
12:20:59 <nullkuhl> yes i wrote another do there then removed it and forgot to unindent
12:21:10 <monoidal> nullkuhl: you need to import Control.Monad
12:22:38 <JoeyA> What's wrong with this multi-parameter type class?  http://codepad.org/7HeTwvcz
12:23:19 <JoeyA> In particular, the type class has two type variables and two methods.  Each method uses only one variable.  Why doesn't it work?
12:23:31 * hackagebot numeric-prelude 0.2 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.2 (HenningThielemann)
12:23:41 <JoeyA> ^ cool
12:23:43 <nullkuhl> monoidal: still more errors http://dpaste.com/247511/
12:23:43 <monoidal> JoeyA: the type class has three type variables
12:23:50 <JoeyA> oh
12:24:02 <JoeyA> well, notice how each method omits a type variable.
12:24:14 <JoeyA> This could be split into two type classes (e.g. Get, Put)
12:24:30 <JoeyA> But it'd be nice if I could just make them one.
12:24:33 <monoidal> nullkuhl: print (gcd a b) in the last line
12:24:46 <JoeyA> (similar to how Data.Binary uses one type class for Binary rather than two)
12:25:11 <JoeyA> This is actually a generalization of Binary.
12:25:55 <nullkuhl> monoidal: i get a wierd trailing line at output: [(),()]
12:26:07 <JoeyA> (also, put could just be a monoid, but I'm going the way of Data.Binary and making it a monad for convenience.
12:26:17 <JoeyA> err, put could just use a monoid
12:26:34 <monoidal> nullkuhl: should disappear if you use replicateM_ instead of replicateM.
12:27:07 <monoidal> nullkuhl: the "underscore" functions return IO () instead of IO a. Try in GHCi: sequence [getLine, getLine] and compare with sequence_ [getLine, getLine]
12:28:00 <vanadium> Both hang for me <:)
12:28:15 <Twey> Ha, ha :þ
12:28:43 <nullkuhl> monoidal: since am using hSetBuffering stdout LineBuffering, should i use something else other than print() for output ?
12:28:58 <monoidal> @src print
12:28:58 <lambdabot> print x = putStrLn (show x)
12:29:24 <monoidal> nullkuhl: print gives newline (and flushes output when you use LineBuffering)
12:30:58 <nullkuhl> readLn parses input to the type it belongs to ? like integers ? also what if input has a trailing space or DOS new lines like /r/n
12:32:48 <applicative> @src readLn
12:32:48 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
12:33:48 <applicative> > read "1001   " :: Int
12:33:49 <lambdabot>   1001
12:34:17 <applicative> nullkuhl, read already  omits the trailing space
12:34:27 <conal> urg.  habitual "do" leads to verbose formulations, like that readLn def
12:34:34 * hackagebot unamb 0.2.4 - Unambiguous choice  http://hackage.haskell.org/package/unamb-0.2.4 (ConalElliott)
12:35:03 <ddarius> readLn = getLine >>= readIO
12:35:31 <applicative> why not read <$> getLine ? 
12:35:52 <conal> edwardk: for now, i'm deactivating the incorrect unamb optimization that uses tag-bits .
12:36:28 <solidsnack> lambdabot: @tell kmc Sorry to miss you.
12:36:28 <lambdabot> Consider it noted.
12:36:35 * hackagebot lub 0.1.1 - information operators: least upper bound (lub) and greatest lower bound (glb)  http://hackage.haskell.org/package/lub-0.1.1 (ConalElliott)
12:36:52 <nullkuhl> monoidal: ok final question what would be the translation of this psuedo code in haskell ? http://dpaste.com/247519/
12:37:07 <applicative> > read "1223 \r\n\r\n" :: Int  -- nullkuhl, the underlying read omits line endings too, but readLn should stop before then...
12:37:07 <lambdabot>   1223
12:37:35 <monoidal> nullkuhl: you can use if-then-else as normal: if (a < 100) then print "A" else print "B"
12:38:03 <monoidal> nullkuhl: the condition has to be Bool, not IO Bool. If checking the condition requires side effects, you have to use <- first.
12:39:14 <monoidal> nullkuhl: also, you can write that as print (if a+b < 100 then "A" else "B")
12:41:42 <nullkuhl> monoidal: what about indentation, this is what i have now, it doesn't load though http://dpaste.com/247522/
12:43:21 <monoidal> nullkuhl: "else" has to be more indented than "if". This might be strange, but in do-block every single action is indented the same level, and it is read as "if a+b>1000 then print (...); else ..."
12:43:27 <bos> conal: i was just reading a nice paper that makes reference to unamb
12:43:40 <monoidal> nullkuhl: in newest language standard, this was changed, and the syntax is allowed
12:43:49 <conal> bos: oh?  what is it??
12:44:11 <bos> conal: not yet published. it's about a new strictness checking tool.
12:44:24 <conal> bos: sweet!
12:44:39 <monoidal> nullkuhl: in other words, starting new line in do-block with same indentation joins them with ";" which separates actions. But "if ... then print ... else print ..." is a single action, and semicolon before else is not legal
12:44:46 <bos> conal: yes, very nice paper, fun to see your work crop up in it too.
12:45:39 <nullkuhl> monoidal: what about what comes after else, does it has to be indented as well 
12:46:00 <conal> i expect that lub & glb will turn out to be terrifically useful tools for pure denotational/functional programming.
12:46:30 <nullkuhl> monoidal: is there an IDE for Haskell that offers auto indentation or quick code fixing or so ?
12:46:30 <bos> infinimum and supremum, as the mathematicians calls 'em
12:46:34 <monoidal> nullkuhl: what belongs to "else" clause needs to be indended more than the main do-block. What doesn't belong to "else" and is the next action, needs to be indended as the do-block. Have I written that clearly?
12:46:35 <conal> might take a while to get over our sequential functional habits.
12:47:11 <bos> frankly, infinimum sounds more like a mother who always brings you breakfast in bed
12:47:12 <conal> bos: inf & sup when over sets rather than pairs, iirc
12:47:23 <bos> conal: right
12:47:32 <monoidal> nullkuhl: don't know about auto indentation. I think you'll get quickly used to the indentation, it's natural after some time
12:47:53 <monoidal> nullkuhl: for code sugestions, you can use "hlint".
12:48:05 <roconnor> > 6*35
12:48:06 <lambdabot>   210
12:48:13 <nullkuhl> monoidal: i didnt get what you said at the end, can you indent this code  http://dpaste.com/247522/ then it would be easier for me to get it ?
12:48:32 <nickela> @src read
12:48:32 <lambdabot> read s = either error id (readEither s)
12:48:42 <nickela> @src readEither
12:48:42 <lambdabot> Source not found. Sorry.
12:48:59 <jnj> Could someone help me understand http://hpaste.org/40039/real_world_haskell_chap14_b Thanks.
12:49:04 <roconnor> wow
12:49:10 <roconnor> I want readEither!!
12:49:54 <Twey> Yeah… that would be more useful…
12:50:20 <roconnor> @hoogle readEither
12:50:20 <lambdabot> No results found
12:50:50 <monoidal> nullkuhl: the code is missing final ) after "print (gcd a b)". indent else as much as print (4 spaces more)
12:50:58 <nickela> jnj: execLogger is access function to Logger internals
12:51:11 <nullkuhl> is this correct monoidal: http://dpaste.com/247525/
12:51:25 <jnj> nickela: But why is runLogger not? They are identical yes?
12:51:35 <nickela> jnj: runLogger is public visible function, just in this example is equals
12:52:18 <monoidal> nullkuhl: Yes. To avoid the "long distance parenthesis", you can use $
12:52:22 <jnj> nickela: ok, so they do it this way, because normally runLogger would be different?
12:52:26 <nickela> jnj: suppose runLogger is more complex than just alias for execLoggeg
12:52:38 <nickela> jnj: yes
12:52:47 <monoidal> nullkuhl: which is the same as using brackets. For example, sqrt 1 + 3 = 1 + 3 = 4, but sqrt $ 1 + 3 = sqrt $ 4 = sqrt 4 = 2
12:52:58 <jnj> nickela: ok, thank you. It's pretty confusing when they don't mention that, at least for me :)
12:53:09 <nullkuhl> monoidal: for the code i pasted above i get the following error : http://dpaste.com/247526/
12:54:29 <monoidal> nullkuhl: ah, give me some time
12:57:15 <roconnor> > (sqrt 1 + 3, sqrt $ 1 + 3)
12:57:16 <lambdabot>   (4.0,2.0)
12:57:44 <monoidal> nullkuhl: do you want a,b to be integers, or floats?
12:58:08 <monoidal> nullkuhl: integer version: http://dpaste.com/247528/
12:59:04 <nullkuhl> monoidal: a, b are integers, infact huge integers (up to 10^12540)
12:59:10 <roconnor> that looks like a google code jam problem
12:59:39 <monoidal> nullkuhl: you can get rid of signatures in readLn :: IO Integer, if you declare revfib :: Integer -> Integer
13:00:10 <monoidal> nullkuhl: however, multiplying a large integer by a floating point will give you extreme loss of precision
13:00:18 <nullkuhl> roconnor: just got the tshirt today, it's not a codejam problem though :)
13:00:37 <roconnor> nullkuhl: you won a shirt!!
13:00:41 <roconnor> wow, you must be good
13:01:01 <monoidal> nullkuhl: I used "fromIntegral" to convert integer to float, but you'd need arbitrary precision reals
13:01:14 <roconnor> fortuantely we have those
13:01:21 <roconnor> > showCReal 1000 pi
13:01:22 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
13:01:23 <nullkuhl> monoidal: you are concerned with revfib function yeah ?
13:01:32 <monoidal> nullkuhl: yes
13:01:54 <monoidal> nullkuhl: you can use CReal library to get them
13:02:00 <mreh> how do I get the source of an instance again?
13:02:07 <mreh> with lambdabot
13:02:08 <roconnor> @src (>>=) []
13:02:08 <lambdabot> Source not found. I feel much better now.
13:02:09 <nullkuhl> i think it may not matter since an approximated answer might work fine,  a and b are supposed to be large fibonnaci numbers and i am trying to get their index in the fibonacci sequence
13:02:11 <roconnor> @src [] (>>=)
13:02:12 <lambdabot> xs >>= f     = concatMap f xs
13:02:18 <mreh> kewel
13:02:25 <mreh> if only hoogle had the same interface
13:02:25 <monoidal> nullkuhl: ah, ok
13:03:13 <monoidal> nullkuhl: the code I pasted should work; observe I used $ to get rid of the last bracket
13:05:29 <mreh> @src Control.Arrow.Kleisli (***)
13:05:29 <lambdabot> Source not found. stty: unknown mode: doofus
13:05:35 <mreh> wat
13:06:01 <monoidal> @src Kleisli (***)
13:06:01 <lambdabot> Source not found. My pet ferret can type better than you!
13:06:13 <monoidal> @src (Kleisli m) (***)
13:06:13 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:06:38 <mreh> @src (Kleisli IO) (***)
13:06:38 <lambdabot> Source not found. It can only be attributed to human error.
13:07:04 <mreh> naw, all Monads are instances of Kleisli
13:07:14 <monoidal> @src (Kleisli IO) first
13:07:15 <lambdabot> Source not found. Do you think like you type?
13:07:44 <monoidal> @src first
13:07:45 <lambdabot> Source not found. That's something I cannot allow to happen.
13:09:24 <Fisherman> @src 1+1
13:09:25 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:09:35 <Fisherman> sorry
13:10:34 <itrekkie> hi everyone– is it possible to use guards in one of the guard conditions?
13:10:40 <mreh> oh guilded anus, I'll have to do it myself
13:10:46 <Zao> itrekkie: You could use a case.
13:10:56 <itrekkie> thanks, I'll google that up :)
13:11:13 <Zao> Although that's probably not what you asked for.
13:12:32 <nullkuhl> monoidal: ok code works but i have a problem now, IO is slow , am reading about 2000 line from console, is there a faster way to read / output text from/to console ? 
13:12:42 <itrekkie> I think it might be. I have three conditions for different sized lists, and want to use guards in each of those. Just trying to get a handle on the haskell dna, as it were
13:13:08 <vanadium> nullkuhl: Try doing something that does not involve Strings
13:13:15 <vanadium> and maybe ByteStrings
13:13:20 <monoidal> nullkuhl: set buffering to BlockBuffering Nothing, or don't use strings
13:13:57 <nullkuhl> monoidal: am not using strings, and i read input as readLn which should cast input directly to integers
13:14:13 <monoidal> nullkuhl: it uses strings internally, and parses them
13:14:37 <taktoa> Hello.
13:14:48 <nullkuhl> monoidal: yes but there is nothing to do about that is there ? i mean console input is already coming as text i guess
13:15:05 <taktoa> I'm working on an artillery simulator (just for fun) in haskell, and I'm having trouble with I/O
13:15:14 <monoidal> nullkuhl: strings are quite inefficient, since they are not stored as, say, char* in C
13:15:25 <taktoa> If you allow me one second, I can paste it up
13:15:35 <applicative> taktoa, good idea
13:15:45 <monoidal> nullkuhl: but as a Cons 'a' (Const 'b' ...) where 'a', 'b' are closures giving characters
13:15:53 <monoidal> (thunks)
13:16:09 <taktoa> http://hpaste.org/40040
13:16:21 <applicative> nullkuhl, do you want to read a file full of Ints?
13:16:29 <nullkuhl> applicative: it's console input
13:16:32 <taktoa> it fails with the following error:
13:16:38 <nullkuhl> its about 2000 line of large integers
13:17:14 <monoidal> nullkuhl: buffering didn't help? will write a bytestring version
13:17:24 <taktoa> http://pastebin.com/hg35VVCM
13:17:31 <taktoa> ^ that's the error message
13:17:48 * hackagebot lub 0.1.2 - information operators: least upper bound (lub) and greatest lower bound (glb)  http://hackage.haskell.org/package/lub-0.1.2 (ConalElliott)
13:18:19 <nullkuhl> monoidal: for buffering i have   hSetBuffering stdin LineBuffering    hSetBuffering stdout LineBuffering
13:18:32 <nullkuhl> monoidal: you mentioned i should set Blockbuffering to nothing ?
13:18:39 <monoidal> nullkuhl: try hSetBuffering ... (BlockBuffering Nothing)
13:19:24 <nullkuhl> what does ... mean ?
13:19:26 <applicative> taktoa, what csv library are you using?  
13:19:30 <monoidal> nullkuhl: stdin/out
13:19:39 <taktoa> I'm using text.csv
13:19:40 <mreh> since when did Category make it into Haskell?
13:19:53 <nullkuhl> monoidal: like replace the linebuffering i have ?
13:19:57 <monoidal> nullkuhl: yes
13:20:17 <monoidal> @src BufferMode
13:20:18 <taktoa> http://hackage.haskell.org/package/csv-0.1.1
13:20:18 <lambdabot> Source not found. :(
13:20:27 <monoidal> @hoogle BufferMode
13:20:28 <lambdabot> System.IO data BufferMode
13:21:21 <edwardk> conal: fair enough. I'll get you an isbottom check and/or tweak tag-bits to never return unsafeIsEvaluated bottom = true
13:21:51 <applicative> taktoa, i see. let me study.  there are more recent csv libraries about
13:22:21 <taktoa> thanks, applicative
13:22:24 <mreh> @hoogle (>>>)
13:22:24 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
13:22:25 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
13:22:25 <conal> edwardk: thx :)  i noticed the bug only when testing my laxer if-then-else & either.
13:22:52 <edwardk> Good catch. I never expected any bottom to get flagged as ealuated
13:22:59 <edwardk> Er evaluated
13:24:01 <applicative> taktoa, if you replace the offending line with "let dists = (lst4 (unzip4 iodistlist))" does it work?
13:24:35 <taktoa> yeah, but I need to convert that list of IO Double to Double
13:24:40 <nullkuhl> monoidal: would using readNum be any faster than readLn ?
13:24:49 <taktoa> otherwise I can't use my quicksort function
13:25:01 <monoidal> nullkuhl: don't know readNum, probably yes
13:25:02 <applicative> taktoa, I see, i'm looking at the commented out bit
13:25:24 <nullkuhl> monoidal: well with block buffering it is still slow, even without applying any function to input
13:25:48 <nullkuhl> as i told you am reading 2000 lines each of them has a max value of 10^12540
13:27:51 <sm> taktoa: I think you want the sequence function
13:28:10 <taktoa> where, and how?
13:28:32 <sm> maybe dists <- sequence (lst4 (unzip4 iodistlist))  
13:29:20 <taktoa> @hoogle sequence
13:29:20 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:29:20 <sm> http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/Monad.html#v:sequence
13:29:21 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:29:21 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
13:29:34 <taktoa> hmm
13:29:45 <taktoa> well, when I put in sequence
13:29:54 <taktoa> and comment out the other lines
13:30:14 <taktoa> it gives me this error
13:30:41 <taktoa> http://pastebin.com/zGKMt57F
13:30:52 <taktoa> err.. uncomment
13:30:55 <taktoa> not comment
13:31:26 <sm> break it into smaller steps, maybe adding type signatures, until you can see the problem
13:32:26 <monoidal> nullkuhl: I admit I didn't use ByteStrings for long time, so might be wrong: http://hpaste.org/40044/
13:32:53 <monoidal> nullkuhl: ByteStrings have many functions similar to strings, like getContents, getLine etc.
13:36:07 <applicative> taktoa, it's a little hard to follow, but I think the trouble begins with these zip4_ type functions at the top, are you sure they are doing what you want
13:36:49 <taktoa> hrmm....
13:37:00 <applicative> taktoa, the definition: zip4_ ([a], [b], [c], [d]) = [(a, b, c, d)] only applies to a list of singletons, and yields such a list, it doesn't zip
13:37:21 <taktoa> ok,
13:37:43 <taktoa> lemme take a look at zip3 at modify the code for a 4-tuple
13:38:42 <applicative> I think you want to go from a 4tuple of lists to a list of 4tuples? It's a little different from zip3 or zip4 (from Data.List)
13:39:49 <taktoa> ok, so here's the new code
13:40:17 <taktoa> http://hpaste.org/40046/artillerysim
13:40:32 <roconnor> uncurry4 zip4 ?
13:41:12 <nullkuhl> monoidal: can i view the src of gcd function in haskell ?
13:41:15 <taktoa> it gives me the same error as before
13:41:17 <monoidal> @src gcd
13:41:17 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
13:41:17 <lambdabot> gcd x y = gcd' (abs x) (abs y)
13:41:18 <lambdabot>    where gcd' a 0  =  a
13:41:18 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
13:41:22 <monoidal> nullkuhl: ^
13:41:27 <taktoa> but if I comment out the quicksort
13:41:30 <taktoa> it compiles
13:41:34 <taktoa> however
13:41:37 <taktoa> when I run it
13:41:42 <taktoa> it says:
13:41:44 <nullkuhl> a 'rem' b ?
13:41:45 <monoidal> nullkuhl: be aware this is Report implementation, not neccesarily the one used
13:41:58 <chrisdone> haha, look at all those hlint warnings: http://hpaste.org/40045/artillerysim
13:42:08 <taktoa> nonexaustive patterns in makedistlist
13:42:08 * chrisdone considers making them collapsed by default
13:42:12 <taktoa> yeah, I know
13:42:18 <monoidal> nullkuhl: you can google for "prelude source" and get some fun gems like data Bool = False | True, and lazy definition of (&&)
13:42:24 <taktoa> I go overkill on parens
13:42:26 <monoidal> nullkuhl: a `rem` b == rem a b
13:42:32 <nullkuhl> what is rem ? :)
13:42:33 <chrisdone> woops
13:42:39 <monoidal> nullkuhl: remainder
13:42:45 <monoidal> > rem (-5) 2
13:42:46 <lambdabot>   -1
13:42:47 <monoidal> > mod (-5) 2
13:42:48 <lambdabot>   1
13:42:50 <nullkuhl> oh like a % b
13:42:51 <nullkuhl> ?
13:43:00 <applicative> chrisdone, the hlint is great.  I just noticed it with taktoa's paste
13:43:20 <monoidal> nullkuhl: yes, it is different than mod for negative numbers
13:43:51 <chrisdone> applicative: :D
13:44:31 <applicative> taktoa, heres the Data.List zip4, and what I think should be your zip4_ http://hpaste.org/40047/zip4
13:44:57 * hackagebot ref-tf 0.2 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-tf-0.2 (GeoffreyMainland)
13:44:59 * hackagebot ref-fd 0.2 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-fd-0.2 (GeoffreyMainland)
13:45:01 * hackagebot plugins 1.5.1 - Dynamic linking for Haskell and C objects  http://hackage.haskell.org/package/plugins-1.5.1 (DonaldStewart)
13:45:12 <applicative> you zip4_ is 'uncurried', or is it the other way around ...
13:45:18 <dons> hell yeah.
13:45:33 <lispy|dagit> dons: woot!
13:45:35 <taktoa> did you look at the new paste?
13:45:53 <taktoa> I changed the zip4 statement
13:46:07 <lispy|dagit> dons: I expect a release announcement :)
13:46:17 <dons> heh
13:46:49 <monoidal> shouldn't ref-fd use fundeps?
13:46:58 <monoidal> or is there an error in announcement above?
13:47:57 * hackagebot network-data 0.2.0 - Library for network data structures (ex: ip/udp/tcp headers and helper functions)  http://hackage.haskell.org/package/network-data-0.2.0 (ThomasDuBuisson)
13:48:09 <nullkuhl> monoidal: i edited your last paste, to make the code work without executing the function on input, and it's now faster a little, however when un comment the functions' lines it's again slow, but still faster than before, do think that there is anything to speed it up a little more ?
13:48:32 <roconnor> nullkuhl: since the gcd 0 0 should be 0, I rarely use Prelude's version of gcd.
13:48:42 <Twey> > gcd 0 0
13:48:43 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
13:48:54 <monoidal> gcd 0 0 isn't 0? Blasphemy!
13:49:03 <taktoa> why is my makeDistList function nonexhaustive?
13:49:11 <roconnor> monoidal: not only that, but mod n 0 is also undefined instead of n!
13:49:19 <taktoa> it /should/ terminate
13:49:50 <monoidal> nullkuhl: where can I find the paste?
13:51:12 <monoidal> ah, you didn't put it. I don't know, you'd better ask someone else :)
13:52:33 <monoidal> nullkuhl: does it use Doubles or Floats? I think doubles might be faster
13:53:53 <taktoa> http://hpaste.org/40049/artillerysim
13:54:09 <nullkuhl> monoidal: where in revfib ? http://hpaste.org/40048/fib_gcd?pid=40048&lang_40048=Haskell#24
13:54:09 <taktoa> I fixed everything except the error listed at the end
13:54:29 <Olathe> monoidal: Yeah, I hate gcd 0 0 /= 0, too.
13:54:59 * hackagebot ref-mtl 0.2 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-mtl-0.2 (GeoffreyMainland)
13:55:36 <monoidal> nullkuhl: Do you use bytestrings?
13:56:17 <nullkuhl> monoidal: that's the code am using and it's the latest one you sent me  http://hpaste.org/40048/fib_gcd?pid=40048&lang_40048=Haskell#24
13:56:40 <roconnor> conal: you around?
13:56:51 <monoidal> nullkuhl: bytestring version: http://hpaste.org/40044/
13:57:02 <conal> roconnor: yeah.  hi.
13:57:10 <monoidal> nullkuhl: don't know if it reads properly the integers, but should be faster
13:57:29 <roconnor> conal: can I dredge up a question from long ago regarding: http://www.haskell.org/haskellwiki/Talk:IO_Semantics ?
13:57:47 <conal> roconnor: sure.
13:58:07 <roconnor> conal:  you say: ``I think I'd want a lot more equalities than the representation by itself provides, especially involving SysCallName''
13:58:20 <roconnor> conal: which I admit sounds plausible, but
13:58:40 <conal> roconnor: maybe not plausible, but desirable.
13:59:00 <roconnor> conal: given my IO Tree of system calls / responses ...
13:59:25 <roconnor> conal: can you think of a simple example of two different IO Trees that should be considered as equivalent?
13:59:45 <roconnor> conal: let's stay single threaded for this discussion if we may
14:00:10 <conal> roconnor: okay.  take any two distinct system calls or combos of system calls that always yield the same results.
14:00:23 <roconnor> conal: what do you have in mind?
14:00:34 <conal> as a trivial example, consider a program foo and a symlink to it but called bar
14:01:01 <conal> as another example: "cat a b" vs "cat a; cat b"
14:01:53 <roconnor> so the syscall is "Exec" and the input to the syscall is a string, "foo" in one case and "bar" in other?
14:02:02 * hackagebot symbol 0.1 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.1 (GeoffreyMainland)
14:02:35 <Olathe> zomg...Ruby symbols...in Haskell!
14:02:38 <conal> roconnor: is exec the thingy that executes an OS/shell command?
14:02:50 <roconnor> conal: let us say so
14:02:56 <conal> then yeah.
14:03:05 <roconnor> conal: we can work in an imaginary OS that has such syscalls, that is fine
14:03:17 <roconnor> conal: I'd argue here that these two IO programs are different
14:03:41 <roconnor> conal because there are differnet envirnoments that they can be run in that produce different results
14:04:08 <roconnor> conal: some environements will have foo symlinked to bar, but others won't
14:04:14 <roconnor> so they are distinguishable.
14:04:24 <conal> roconnor: make the symlinking be part of the IO action
14:04:37 <taktoa> here's the new code
14:04:39 <taktoa> http://hpaste.org/40051/artillerysim
14:04:44 <conal> roconnor: and unsymlinking afterward
14:04:45 <taktoa> cleaned up
14:05:06 <roconnor> conal: so the IO code symlinks the files , runs foo in one example and bar in the other, and unsymlinks them.
14:05:19 <conal> roconnor: yeah.
14:05:32 <conal> roconnor: here's another possible, simpler example: (putStr "hey " >> putStr "you") vs (putStr "hey you")
14:06:05 <conal> roconnor: i say "possible" because you might define putStr via putChar, which would break my example.
14:06:39 <roconnor> okay, I'd still argue that they are different, but I have to stretch a little bit here.  I know that I said we'd stay single threaded, but I still say it is possible for another process to get interleved in there, so we can distingish between the two.   That being said, perhaps you can refine your example to fix this issue.
14:07:08 <roconnor> conal: ya, since putstr is defined in terms of putchar, the IO trees are in fact the same in that case.
14:07:40 <conal> roconnor: so then i'd look for more ideas in your set of IO primitives.
14:08:35 <conal> roconnor: or flip the question around to how you might prove that your primitives do not admit such an example.
14:08:41 <applicative> taktoa, here's a somewhat silly attempt to repair the zip4_ fst4_ things, which were all wrong in thee same way http://hpaste.org/40052/artillery 
14:08:44 <roconnor> conal: most of the example of IO programs that should be the same that I can think of, usually another process running in parallel can interput and make a distinction between them.
14:08:50 <itrekkie> is there a way to time functions, to benchmark them?
14:09:46 <conal> roconnor: though that wouldn't be the case if putStr were a prim
14:09:48 <itrekkie> I should mention I'm using ghci
14:10:08 <roconnor> conal: I would have to show that given any two different syscalls (or the same syscall with two different inputs) there is always an environment which distinguishes them.
14:10:10 <conal> roconnor: i mean there'd be an easy example that couldn't be distinguished by a concurrent observer
14:10:24 <taktoa> applicative: I've fixed that problem; thanks for the code though I think your code is a bit unnecessarily complicated
14:10:37 <gwern> roconnor: perhaps I'm missing the point, but it seems to me that crypto's sidechannel attacks are good eamples, like stealing a private key just based on cache misses
14:10:46 <conal> roconnor: in other words, that their denotations are unequal, where the domain is as a function from environments.
14:10:51 <taktoa> applicative: this is my new code: http://hpaste.org/40052/artillery
14:11:07 <roconnor> conal: Ya, I don't like putStr as a primitive because it seems like syscalls shoud all have finite number of inputs that are really word32s or some such thing.
14:11:12 <conal> roconnor: i think you're going for full abstraction there.
14:11:52 <roconnor> gwern: that's intersting. It is unclear to me if that is cheating or not.
14:12:33 <taktoa> I'm going to be afk for a bit
14:12:51 <gwern> roconnor: yeah. the crypto program will return the exact same results and whatnot - but a more intangible 'privacy' property will be lost
14:13:05 <roconnor> gwern: Maybe we can look at the problem as follows, would it be wrong for a compiler to change the IO tree result of a program during optimisation?
14:13:35 <conal> roconnor: i like that framing.
14:13:46 <roconnor> this, of course, really depends on the deatils of what the syscalls are
14:13:55 <roconnor> so the question isn't really well posed
14:14:21 <roconnor> but to answer we can give examples of plausible syscall sets, and find the answer for these example syscall sets
14:14:24 <gwern> roconnor: hm. there's anotehr sidechannel attack where optimized crypto code shortcuts execution, and this timing lets one deduce bits in a key; the solution is to write the code is such a way that it takes a constant amount of time for all inputs of a certain length. wasteful but more secure
14:14:52 <roconnor> gwern: heh, intresting point.
14:15:24 <roconnor> gwern: in that case one would be likely be upset if the optimiser started messing with your IOtree result
14:15:35 <gwern> roconnor: very much so!
14:15:48 <roconnor> gwern: but let us be more generous to conal and ingore such concerns.  At least for the sake of argument
14:15:49 <gwern> 'oh, let me factor away that wasteful loop, since I can proe the output doesn't differ'
14:16:30 <roconnor> after all, we don't really have full control of what is being monitored
14:16:44 <gwern> roconnor: for the sake of argument... but remember that these attacks have been demonstrated all the way up the abstraction stack - I think timing attacks on keys have been written for browser javascript
14:16:57 <roconnor> because the IOtree doesn't contain the information of the non-syscall instructions that the compiler is generating in order to compute what the next syscall should be.
14:16:57 <conal> gwern's example is a tricky one.  ghc *will* optimize away some loops in the non-IO part of a haskell program.
14:17:02 <conal> or other expensive computation.
14:17:39 <gwern> (I sometimes think the only thing I've learned from reading computer security/crypto papers and Phrack has been to despair)
14:17:56 <roconnor> gwern: so let us ignore those issues for the sake of this arguement
14:19:02 <gwern> huh. dons just announced a new release of plugins
14:20:10 <tolkad> Is the only cost of inlining large functions large binary size?
14:20:14 <roconnor> conal: if syscalls take some tuple of Word32, it seems quite likely there are some inputs that are simply redudent.
14:20:23 <roconnor> conal: so clearly those should be identified.
14:20:38 <conal> roconnor: redundant?
14:20:48 <roconnor> conal: some syscall is expecting a bool
14:20:49 <gwern> tolkad: you say that like it's not important
14:21:09 <roconnor> conal: but we pass it a word32 because our OS requires all syscalls to take word32s
14:21:21 <roconnor> conal: so it treads all non-zero numbers as equivalent.
14:21:24 <tolkad> gwern: the importance of it varys from application to application
14:21:45 <gwern> tolkad: I suppose there are also issues with reaching a fixed point
14:21:47 <conal> roconnor: oh!  so foo 1 == foo 2, but the tree view says otherwise
14:21:51 <gwern> an issue for partial evaluation, I think
14:21:58 <roconnor> conal: yes
14:22:16 <conal> ah.  nice example.  that's the sort of thing i had in mind.
14:22:31 <tolkad> gwern: if it's not distributed and only launched when there are new versions, you don't care as much about binary size
14:23:00 <gwern> tolkad: well, unless you're losing orders of magnitude of performance to cache misses and similar issues with bloated binaries...
14:23:05 <conal> roconnor: nice example as it uses only a single syscall and a rather arbitrary reason for denotational equality
14:23:05 <roconnor> conal: but in an attempt to get around that, let us assume that we create a nice abstraction of the the inputs of the syscalls via finite ADTs that exactly match the differing inputs to syscalls.
14:23:20 <kyagrd> @seen FunctorSalad
14:23:21 <preflex>  FunctorSalad was last seen on #haskell-blah 1 day, 5 hours and 19 seconds ago, saying: concerningly I find it hilarious anyway
14:23:21 <lambdabot> Unknown command, try @list
14:23:28 <roconnor> conal: I think this is reasonable, but feel free to argue that this isn't reasonable.
14:23:36 <conal> roconnor: do you mean forcing all syscalls to be injective??
14:23:42 <roconnor> conal: yes
14:23:56 <tolkad> gwern: I'm running my programamers on a processor from 2150, it has cache that's over a GB in size
14:24:01 <tolkad> programs*
14:24:05 <roconnor> conal: I can probably be convinced this isn't reasonable.
14:24:24 <kyagrd> @note FunctorSalad I've made changes and uploaded a new version on Hackgae
14:24:24 <lambdabot> usage: @vote <poll> <choice>
14:24:41 <conal> roconnor: sounds pretty onerous.  but even so, we have to go further and require that all syscalls have disjoint codomains.
14:24:46 <gwern> tolkad: only a gb? clearly moore's law broke down long ago for you, and it's a grim boring future you live in
14:24:52 <gwern> probably no singularity either
14:25:02 <kyagrd> @tell FunctorSalad I've made changes and uploaded a new version on Hackgae
14:25:02 <lambdabot> Consider it noted.
14:25:30 <roconnor> conal: you mean we have to make sure that you cannot do the same thing with two different syscalls?
14:25:37 <conal> roconnor: yeah.
14:25:38 <IceDane> You guys have any ideas for ways to test the correctness of a infix to postfix converter? I can't imagine generating test data that has to follow such specific rules with quickcheck can be easy
14:25:51 <conal> roconnor: which i guess is like saying that syscall *itself* is injective
14:25:53 <roconnor> conal: ya, this does seem to becoming quite rediculous.
14:26:04 <tolkad> gwern: yeah, there is a huge reliance on parallel algorithms run in hundreds of different universes at the same time
14:26:19 <conal> roconnor: and someone would have to do the proving about this injectivity.
14:26:34 <roconnor> conal: it would be the sign of a "good abstraction" of the OS.
14:26:40 <gwern> IceDane: write a postfix to infix converter, and then do 'test x = do . undo x'?
14:27:00 <IceDane> gwern: Hehe, true
14:27:02 <IceDane> I could do that
14:27:08 <conal> roconnor: would it??  plus isn't injective
14:27:20 <gwern> er, that'd be '(do . undo) x == x'
14:27:25 <conal> roconnor: example: the programs "bc" & "dc" in *nix
14:27:28 <gwern> with legal function names :)
14:27:39 <roconnor> conal: you mean that there are probably commutative syscalls?
14:28:10 <conal> roconnor: no.  rather than good abstraction doesn't imply injectivity
14:28:16 <roconnor> oh
14:28:23 <conal> for instance uncurry (+)
14:28:30 <roconnor> conal: indeed
14:28:40 <IceDane> Hmm.. why was it that Either wasn't a monad, again? 
14:28:47 <conal> and consider the bc & dc example, which map math expression strings to numbers
14:28:50 <roconnor> IceDane: it will be soon
14:28:51 <tolkad> gwern: and lol @ singularity "look I can fit an exponential curve on this cherry picked data"
14:28:51 <conal> iirc
14:28:58 <IceDane> roconnor: In the standard library?
14:29:03 <roconnor> IceDane: yes
14:29:19 <conal> roconnor: oh!  or invoking ghc via syscall :)
14:29:20 <IceDane> I seem to recall reading that there was something 'difficult' with making it an instance. 
14:29:27 <IceDane> But I also recall it being possible
14:29:36 <gwern> tolkad: for most singulitarians, kurzweil is the crazy uncle making a mess at the restaurant
14:29:41 <bonii> Hello, I am new to learning Haskell and I was learning about Monads, suppose I have the following "newtype Foo a = Foo (Int -> Maybe (a, Int))" now I am trying to define >>= amd return for an instance of Monad type class for Foo, what I am trying to understand is what is "Int -> Maybe (a, Int)"
14:29:46 <roconnor> conal: again, ghc could be bound to an arbitray program in the environment
14:29:56 <roconnor> conal: same with dc and bc
14:30:05 <tolkad> gwern: just look at it, it's linear except for a few data points he found before 1940 http://en.wikipedia.org/wiki/File:PPTMooresLawai.jpg
14:30:20 <tolkad> the graph even looks linear!
14:30:24 <conal> roconnor: right.  and we'd have to require that every possible binding is itself injective
14:30:34 <conal> roconnor: even including the bindings we're used to.
14:30:43 <roconnor> tolkad: you mean it looks linear on a log scale??
14:30:46 <gwern> tolkad: correct me if I'm wrong, but that's a log graph and on log graphs, exponents look linear
14:30:57 <tolkad> roconnor: oh didn't realize it was a log scale
14:31:00 <gwern> -_-
14:31:17 <tolkad> and that's not the graph I meant to link
14:31:20 <tolkad> -_- fail
14:31:20 <gwern> don't worry tolkad, you'll find a knock-down argument against the singularity!
14:31:32 <conal> roconnor: oh, hm.  i see your point there.
14:31:34 <tolkad> sorry, linked the wrong graph
14:31:34 <ddarius> gwern: No singularity if we're all dead.
14:31:35 <tolkad> one sec
14:31:39 <revenantphx> @quote fugue
14:31:39 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:31:54 <conal> roconnor: we cannot call bc or dc or ghc.  we can only ask for whatever happens to be called "bc" or "dc" or "ghc".
14:31:56 <tolkad> ah, here's his plot: http://en.wikipedia.org/wiki/File:ParadigmShiftsFrr15Events.svg
14:31:56 * roconnor puruses linux syscalls
14:32:00 <tolkad> it looks right
14:32:01 <gwern> ddarius: no singularity if I'm actually a brain in a vat being fooled by a mad daemon
14:32:09 <tolkad> but it's cherrypicked data
14:32:13 <conal> roconnor: which could be a program that echos its input.
14:32:21 <roconnor> yep
14:32:33 <gwern> tolkad: how does linking to a cherrypicked dataset convince us that it is cherrypicked/
14:33:24 <conal> roconnor: which then means that an IO program cannot be reasoned about if it uses syscalls.
14:33:31 <gwern> tolkad: besides, even if kurzweil's law of accelerating returns or whatever bombast he named it turns out to be wrong, kurzweil is only one flavor of the singularity. vingean singularity for example doesn't care in the least about kurzweil's graphs
14:33:53 <conal> roconnor: without some more assumptions.  and those assumptions would equate distinct trees.
14:34:05 <roconnor> conal: more or less
14:34:17 <roconnor> however, I really do think you are right
14:34:31 <roconnor> that there are more assumptions and those do equate distinct trees
14:34:35 <conal> roconnor: so i'm saying that if imperative programming can be at all reliable, then these trees do not capture imperative programming.
14:34:37 <tolkad> gwern: wait why is the x-axis over 10^10 years...
14:34:38 <roconnor> I just want to find a clear example
14:34:56 <conal> roconnor: yeah.  me too.  and i appreciate your help.
14:35:06 <gwern> tolkad: why not?
14:35:12 <mietek> Why is UHC an interesting project?
14:35:29 <tolkad> gwern: humans haven't even had technology for a fraction of that time!
14:35:34 <ddarius> mietek: Why do you think UHC is consider an interesting project?
14:35:37 <kyagrd> mietek: because it tries targets multiple backends
14:35:40 <roconnor> conal: the exit sycall followed by anything is the same as the exit syscall followed by anything else.
14:35:41 <conal> roconnor: since i want to put to rest the persistent idea that IO has useful semantics.
14:35:51 <gwern> tolkad: you don't have to be human to have tech or development
14:35:58 <conal> roconnor: hm.  yeah.
14:36:17 <mietek> ddarius: just an assumption, following that accomplished programmers spend time on it.
14:36:19 <conal> roconnor: which you could probably patch by normalizing tres.
14:36:19 <tolkad> gwern: but then how are the data points related?
14:36:25 <kyagrd> And they are trying to make it a more componentized compiler
14:36:25 <roconnor> conal: though I guess I could build an IO tree where exit is a leaf
14:36:36 <mietek> kyagrd: thanks, that's exactly what I was looking for.
14:36:57 <gwern> tolkad: ask the dozens of chroniclers. I would guess that the first 2 datapoints are key innovations like 'life' or 'multicellular life'
14:37:01 <gwern> kind of important
14:37:20 <tolkad> gwern: but not related to human technological development in such a manner
14:37:38 <tolkad> gwern: and no they aren't
14:37:50 <tolkad> gwern: life has been around for much longer than 10 million years
14:37:55 <gwern> multicelluar life wasn't an important breakthrough? ok...
14:38:13 <tolkad> gwern: multicellular life has been around for much longer than 10 million years
14:38:37 <gwern> 10^10 is 10 million?
14:38:44 <gwern> > 10^10
14:38:45 <lambdabot>   10000000000
14:39:01 <Twey> A.K.A.
14:39:01 <gwern> looks like 10 billion to me:10,000,000,000
14:39:03 <Twey> > 1e10
14:39:04 <lambdabot>   1.0e10
14:39:06 <tolkad> gah I fail again
14:39:12 <ddarius> gwern: Several things should have tipped you off to stop the conversation ere now.
14:39:18 * gwern is starting to feel sorry for tolkad
14:39:19 <Twey> gwern: Ten thousand million!
14:39:23 <conal> roconnor: oh, so that one cannot follow exit with another action
14:39:29 <tolkad> gwern: that doesn't make sense anyway
14:39:37 <gwern> ddarius: I can't! someone on the internet is *wrong*!
14:39:39 <tolkad> gwern: how can he have data points before life even existed
14:39:46 <roconnor> conal: mlock sounds like it is idemponent
14:39:59 <conal> roconnor: what's mlock?
14:40:01 <tolkad> gwern: and think they are some how related to the rate of human technological development
14:40:06 <roconnor> http://linux.die.net/man/2/mlock
14:40:40 <gwern> tolkad: maybe you should go read the works in question. as alan perlis told us, a picture is worth a thousand words, but it is a rare thousands words adequately summarized by a picture
14:41:51 <ddarius> That, and 1000 words is about one or two pages of writing.
14:42:06 <roconnor> conal: well, it might not be in all enviroments
14:42:14 <IceDane> @src foldM
14:42:14 <lambdabot> foldM _ a []     = return a
14:42:14 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:42:16 <mornfall> ddarius: Hush, don't tell anyone.
14:42:32 <roconnor> conal: it might fail because the process doesn't have permission, then another process gives it permission, so the second mlock succeeds.
14:42:35 <tolkad> gwern: at least plot the development of the AI field
14:42:36 <IceDane> @src foldM_
14:42:36 <lambdabot> foldM_ f a xs = foldM f a xs >> return ()
14:42:46 <tolkad> gwern: instead of plotting EVERYTHING
14:43:38 <gwern> tolkad: AI isn't doing too bad for something barely 60 years old. 60 years after the earliest alienists and psychologists, james was still arguing against 'souls' being useful psychological explanations
14:44:01 <roconnor> conal: I keep having this problem. It seems I can always find some way of distinguishing between two different IO trees.
14:44:22 * gwern goes back to http://terrytao.wordpress.com/2010/03/19/a-computational-perspective-on-set-theory/
14:46:35 <conal> roconnor: let's try another angle: for a given IO tree type, what programs can be proved to accomplish their purpose.
14:47:32 <conal> roconnor: i expect this exercise will raise the tension between making claims about syscalls (for purposefulness) and about making no such claims (for full abstraction).
14:48:10 <roconnor> conal: ideally you would say that in any environment E1 you end up in an environment E2 satifying a predicate Q after running the syscalls.
14:48:33 <roconnor> conal: but less ideally you would say that in any enviroment E1 satifying a predicate P you end up in an environment E2 satifying Q.
14:48:39 <roconnor> that is probably more realistic
14:48:46 <conal> roconnor: ok
14:49:14 <roconnor> ... I'm not entirely sure what an environment is...
14:49:19 <roconnor> I have a vauge idea though
14:49:21 <Olathe> > commafy (10^10)
14:49:22 <lambdabot>   "10,000,000,000"
14:53:34 <wlangstroth> hi guys - I'm not sure how to approach this: let's say I have a monadic function that returns either a single arrow head or a list of arrow tails each time it fires. The function will iterate over input, and I want to collect the arrow heads in one list, and the tails in another. Any ideas?
14:54:27 <mornfall> wlangstroth: Can you give the type of the function?
14:54:33 <mornfall> It would be much clearer that way, I guess.
14:55:44 <mornfall> I guess you mean you get ... -> m (Either a [b])
14:56:02 <mornfall> So you'd go
14:56:13 <wlangstroth> mornfall: that's what I see as the problem. yes, it would be ->  m (Either a [b])
14:56:28 <mornfall> stuff <- mapM fun [...]
14:56:42 <mornfall> let as = lefts stuff
14:56:46 <mornfall>     bs = concat $ rights stuff
14:57:13 <monoidal> :type fmap partitionEithers . sequence --wlangstroth
14:57:20 <wlangstroth> right, so how do I structure "stuff" so that a and b are separated?
14:57:25 <monoidal> @type fmap partitionEithers . sequence
14:57:26 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => [f (Either a b)] -> f ([a], [b])
14:57:46 <mornfall> monoidal: You still need the concat in there, so I don't think you can make it much better with partitionEithers.
14:58:08 <monoidal> ah, a list of tails. yes
14:58:19 <wlangstroth> fantastic! I knew I was overthinking it! Thanks.
14:58:52 <monoidal> mornfall: I think adding (fmap . second) concat would help
14:59:08 <mornfall> monoidal: Yeah, but at that point, it's at the expense of clarity. :)
14:59:12 <monoidal> depending on what is needed
14:59:51 <mornfall> Pointfree is not the goal, it's just means.
15:01:01 <monoidal> @type fmap (second concat . partitionEithers) . sequence 
15:01:02 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => [f (Either a1 [a])] -> f ([a1], [a])
15:04:37 <ddarius> GetViewPortIsFullOfLies: False
15:07:22 * hackagebot xilinx-lava 5.0.0.2 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.2 (SatnamSingh)
15:13:18 <osaunders> I'm declaring an instance (instance (Num n) => Htmlable n) is this a bad idea? I seem to need to enable lots of extensions to make it compile.
15:13:38 <ddarius> Yes.
15:13:53 <osaunders> ddarius: Why?
15:14:24 * hackagebot ParsecTools 0.0.2.0 - Parsec combinators for more complex objects.  http://hackage.haskell.org/package/ParsecTools-0.0.2.0 (ChristianHoener)
15:16:09 <ddarius> osaunders: It doesn't mean what you think it means.
15:16:38 <bonii> Hello, I am new to learning Haskell and I was learning about Monads, suppose I have the following "newtype Foo a = Foo (Int -> (a, Int))" now I am trying to define >>= amd return for an instance of Monad type class for Foo, the return works out to "return a = (\x -> (a,x))", how do I extract a to write the bind(>>=), any suggestions ?
15:17:00 <kmc> Boney, pattern matching?
15:17:00 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
15:17:04 <kmc> (Foo f) >>= g = ...
15:17:25 * hackagebot Biobase 0.0.2.1 - Base library for bioinformatics  http://hackage.haskell.org/package/Biobase-0.0.2.1 (ChristianHoener)
15:17:27 * hackagebot BiobaseTypes 0.0.2.1 - Ring class, with several instances.  http://hackage.haskell.org/package/BiobaseTypes-0.0.2.1 (ChristianHoener)
15:17:31 <osaunders> ddarius: What does it mean?
15:18:27 <ddarius> "Here is an instance for all types but a Num instance is required to use it."
15:18:29 <jmcarthur> osaunders: it means you are defining an instance of Htmlable for all types
15:19:25 * hackagebot BiobaseTurner 0.0.2.1 - RNA folding data structures.  http://hackage.haskell.org/package/BiobaseTurner-0.0.2.1 (ChristianHoener)
15:19:27 * hackagebot BiobaseVienna 0.0.2.1 - ViennaRNA parameter library  http://hackage.haskell.org/package/BiobaseVienna-0.0.2.1 (ChristianHoener)
15:20:25 * hackagebot RNAFold 0.0.2.1 - RNA secondary structure prediction  http://hackage.haskell.org/package/RNAFold-0.0.2.1 (ChristianHoener)
15:21:11 <osaunders> Hm.
15:23:26 * hackagebot RNAFoldProgs 0.0.0.1 - RNA secondary structure folding  http://hackage.haskell.org/package/RNAFoldProgs-0.0.0.1 (ChristianHoener)
15:24:57 <bonii> kmc: So it will be (Foo f) >>= g = g f ?
15:26:14 <sheikra> Hey, I'm trying to figure out how modular Haskell's compilers are. Will anybody tell me what files need to be recompiled when one new instance of a type class is created?
15:27:10 <bonii> kmc: If I do this then it gives me error "Occurs check: cannot construct the infinite type:"
15:27:21 <bonii> kmc: What does this error refer to ?
15:29:06 <monoidal> booni: (Foo f) >>= g = Foo (\s -> let (a, s') = f s in g a s')
15:30:20 <monoidal> booni: Have you read http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html?
15:30:31 * hackagebot RNAFoldProgs 0.0.0.2 - RNA secondary structure folding  http://hackage.haskell.org/package/RNAFoldProgs-0.0.0.2 (ChristianHoener)
15:31:22 <monoidal> *bonii ^
15:34:13 <bonii> monoidal: Thanks for the link, I am checking it
15:43:38 <bonii> monoidal: But this gives me error Couldn't match expected type `Int -> (b, Int)' against inferred type `Foo b'
15:45:11 <monoidal> oh, I forgot some newtype
15:45:44 <monoidal> bonii: (Foo f) >>= g = Foo (\s -> let Foo (a, s') = f s in g a s')
15:45:57 <Olathe> What do you call a sort of "timeline" data structure, where it stores the time between actions? Example: 5s remain, action1, 25s between, action2, 0s between, action3, ...
15:45:57 <monoidal> ah, still wrong
15:46:56 <ddarius> I call it a timeline.
15:47:09 <Olathe> OK
15:47:20 <ddarius> Though there may be a term from event based physics simulations that better fits.
15:48:13 <monoidal> bonii: (Foo f) >>= g = Foo (\s -> let (a, s') = f s; Foo x = g a in x s')
15:48:33 <monoidal> bonii: it's the same as previously, only I forgot to convert Foo b into Int -> (b, Int)
15:48:35 <Olathe> Ahh, OK, I'll look there. Thanks.
15:49:24 <bonii> monoidal: Oh, right, thanks a lot. I am reading the link you gave me 
15:49:50 <monoidal> bonii: that >>= is an exercise there, only without the Foo wrapper
16:04:30 <conal> New blog post: "Fixing broken isomorphisms -- details for non-strict memoization, part 2", http://bit.ly/a1dN0f
16:14:51 <nullkuhl> hello ppl, any idea about fast console IO in haskell ? ( am reading 2000 lines from console each as an integer of value around 10^12540) 
16:15:02 <dons> from stdin?
16:15:16 <dons> the fastest way to do IO would be to mmap the integer from a file.
16:15:26 <dons> doing bytestring io from stdin would be ok, though not as good as file io.
16:15:32 <dons> reading char-by-char will be slower still
16:15:57 <PirateUnderwear> Hello, I have a question about Haskell on a server. Is it possible to run the Snap framework along side of a Rails framework without them conflicting?
16:16:18 <c_wraith> PirateUnderwear, sure.  Just run them on different ports.  possibly using a reverse proxy to route to each
16:16:30 <c_wraith> PirateUnderwear, and they run on different ports by default
16:16:36 <PirateUnderwear> c_wraith: Thanks. Would I configure that in apache?
16:16:51 <c_wraith> PirateUnderwear, apache would be one example of a reverse proxy, sure
16:17:34 <PirateUnderwear> c_wraith: Thanks! What would another example be?
16:18:11 <c_wraith> PirateUnderwear, I tend to use nginx for that purpose, because I think it's a bit simpler to configure than apache
16:19:11 <utgarda> Hi folks! My question is not exactly about Haskell. What if I use GHC packaged for my system ( OpenSuse ) to build and install the latest version of GHC. Then, when I update or remove that package with my package manager, will that break GHC I installed from source?
16:19:30 <PirateUnderwear> c_wraith: Nginx seems to be a popular choice in rails also. I will have to check it out. What is the most popular framework for Haskell? I've only managed to find Snap.
16:20:08 <c_wraith> PirateUnderwear, other options include happstack,  yesod, and a few other things.
16:20:38 <PirateUnderwear> c_wraith: Thanks, I really appreciate it. :)
16:21:40 <kfish>    1.  cabal install hoogle
16:21:41 <kfish>    2. echo >> ~/.ghci ':def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\""' 
16:26:25 <ezyang> Hey guys, I'm trying to cook up a CPS version of a zipper for a traditional tree (e.g. data Tree a = Empty | Node a (Tree a) (Tree a)) 
16:27:10 <ezyang> But I'm not sure if I can "modify" data structures using continuations. 
16:27:36 <ddarius> ezyang: Why are you trying to do this?
16:28:04 <ezyang> ddarius: For fun! 
16:28:24 <ezyang> Also because I heard CPS is a magical wand you wave at data structures to make them tagless. 
16:30:02 <notabel> ezyang: how did you make the diagrams for your coBurger King article?
16:30:20 <ezyang> notabel: Tablet with Xournal. 
16:30:39 <notabel> ah, alas.  it did require Art :-)
16:31:00 <ezyang> notabel: It's true. :-) 
16:38:56 <ezyang> Maybe I should do this with a simpler zipper first. 
16:52:08 <Veinor> ezyang: things that could either be a CS or leather fetish statement
16:52:19 <ezyang> ^_^ 
16:57:27 <taktoa> hello?
16:57:32 <taktoa> anyone home?
16:58:08 <taktoa> I'm making an artillery simulator in haskell (just for fun)
16:58:14 <taktoa> here's my code: http://hpaste.org/40054/
16:58:34 <taktoa> why am I getting the error stated at the bottom (commented out)
16:58:55 <taktoa> makeDistList /should/ terminate
16:59:14 <Lemmih> taktoa: You don't have a base case for makeDistList.
16:59:25 <taktoa> a base case?
16:59:32 <ezyang> [] 
16:59:36 <taktoa> oh
17:00:05 <Lemmih> taktoa: What should happen when it gets to the end of the CVS list?
17:00:45 <Lemmih> taktoa: makeDistList [] lat lon = [] ?
17:01:11 <Lemmih> taktoa: makeDistList looks very similar to map, btw.
17:01:22 <taktoa> ok
17:01:32 <taktoa> one minute, I'm making the requisite changes
17:02:31 <sshc_> What should I use instead of old-locale?  I particularily want a TimeLocale so that I can use time's Data.Time.FormatTime.formatTime, which :: FormatTime t => TimeLocale -> String -> t -> String
17:04:00 <kyagrd> what is the standard jargon for non-parametrized types? concrete type?
17:04:21 <kyagrd> Or simple type?
17:04:31 <ddarius> Monomorphic would probably closest.
17:04:45 <kyagrd> ah yes
17:05:23 <kyagrd> But um what words do you use when you explain two differnt forms of instance declaration?
17:05:49 <ddarius> There's only one form of instance declaration.
17:06:39 <kyagrd> Well let's say that ones that do not need constraint: instance Eq Integer  where vs instance (Eq a) => Eq [a] where
17:07:11 <kyagrd> Integer is a XXXX type vs [a] is a parametrized type.
17:08:08 <c_wraith> it still seems like monomorphic and polymorphic are the best pair of adjectives
17:08:18 <vanadium> concrete?
17:08:29 <aristid> i suppose the latter could also be said to be constrained
17:09:47 <kyagrd> c_wraith: but in Haskell 98 it is more restrictive than monomorphic cause it doesn't let you declare   instance [Int] where ... (you can do it with GHC extensions of course)
17:13:40 <Cale> kyagrd: hm?
17:13:53 <Cale> kyagrd: [Int] is a monomorphic type, no matter how you slice it
17:14:12 <Cale> Even if values of type [Int] can be constructed using typeclass polymorphic functions.
17:16:08 <kyagrd> Cale, I mean "monomorphic" types are more than the types that can appear in the Haskell 98 type class instance declaration without contexts.
17:16:14 <c_wraith> kyagrd, there's actually only one type of instance declaration, from the viewpoint you're at.
17:16:28 <benmachine> kyagrd: an h98 instance can only contain one constructor, I think
17:16:39 <benmachine> applied to as many type variables as necessary
17:16:39 <c_wraith> You can only specify one type constructor concretely
17:16:44 <ddarius> Specifically, it must be of the form: T a b c
17:16:56 <benmachine> (i.e. zero or more)
17:17:49 <kyagrd> Oh, manby type with nullary type constructor might have been the description I was looking for.
17:18:00 <c_wraith> benmachine, also, each type variable must be independent
17:18:35 <c_wraith> H98 doesn't allow instances for (a, a), for instance
17:19:14 <kyagrd> c_wraith: in some extensions you can now for (a,a)?
17:19:25 <kyagrd> didn't know that
17:19:33 <c_wraith> -XFlexibleInstances, I think
17:20:01 <aristid> usually ghc says which flags you need to add
17:20:34 <c_wraith> If it tells you to add IncoherentInstances, it's time to change your approach
17:20:40 <c_wraith> It told me that this morning :(
17:23:28 <djahandarie> Hm, would 'coin changing' be a knapsack problem?
17:25:02 <c_wraith> For arbitrary coin denominations, yes.  But for certain properties that almost all real-world coin denomination distributions, it's just greedy.
17:25:15 <c_wraith> err, distributions fit
17:25:27 <djahandarie> Ah okay
17:29:20 <kmc> djahandarie, there's a problem about that in CLRS
17:30:13 <djahandarie> My problem actually isn't coin changing, it's something similar to it, I just noticed the similarity
17:40:45 <trinithis> @let uncurry0 x = \() -> x
17:40:46 <lambdabot>  Defined.
17:42:24 <hpc> why not use const?
17:44:10 <kmc> its type is too general
17:46:10 <trinithis> People are crowding from all around the world to have their first peek at the uncurry0 function. Simply breathtaking!!!!
17:51:53 <tmo_> When applying a the notebookAppendPage function in Gtk2Hs EventM monad, it returns an IO (Int) type when it needs to return IO () to work. How can I get around this issue?
17:52:39 <monochrom> dons++
17:52:55 <monochrom> new plugins
17:53:23 <Axman6> tmo_: add return () to the end of notebookAppendPage?
17:53:40 <Axman6> preflex: seen bos
17:53:40 <preflex>  bos was last seen on #haskell 5 hours, 6 minutes and 17 seconds ago, saying: conal: right
17:54:04 <tmo_> Axman6: I'll try that.
17:54:29 <Axman6> i really wish there was a standard name for return () defined somewhere
17:54:36 <Axman6> like done
17:54:45 <Axman6> done = return ()
17:56:53 <Axman6> so, i'm pretty proud, managed to speed up the pidigits benchmark slightly
17:59:16 <wavewave> hi, what is ghc option for choosing specific version of a certain package?
17:59:53 <Saizan> -package 
18:00:06 <Saizan> or -package-id if you want to specify an ABI
18:00:25 <ezyang> Ok, I think I've concluded that I can't modify data structures encoded as continuations. 
18:00:33 <wavewave> Saizan : what is ABI?
18:01:46 <wavewave> Saizan: anyway, this solves my problem. Thank you!
18:12:08 <mjk> i am use c/c++/perl/haskell, platform is windows/linux, current use vim as my editor, which does good vim or emacs?
18:12:21 <tmo_> Both are excellent choices
18:12:44 <mjk> i have not used emacs
18:15:34 <IceDane> mjk: I use vim because I write both C++ and haskell regularly
18:15:59 <IceDane> But if I could get used to using emacs for everything(or rather, give up the awesomeness of vim) I would use emacs because it has much better support for haskell indentation and so on
18:16:08 <IceDane> though vim doesn't give me any problems with haskell.
18:16:34 <tmo_> I tried to create a custom notebookAppendPage function, which returns an IO () instead of an IO (Int), however, the type system is still rather unfriendly towards me adding a widget. Here's the code:
18:16:48 <tmo_> http://pastebin.com/RBmaEsvV
18:17:12 <mjk> emacs can as a IDE
18:18:25 <Axman6> tmo_: are you getting any errors? you haven't specified the problem
18:18:46 <tmo_> Yes, it's returning the following error:
18:19:01 <tmo_> Could not deduce (WidgetClass child)
18:19:01 <tmo_>       from the context (NotebookClass self,
18:19:01 <tmo_>                         WidgetClass (Maybe TextTagTable -> IO TextBuffer))
18:19:01 <tmo_>       arising from a use of `notebookAppendPage' at interface.hs:66:4-38
18:19:04 <tmo_>  
18:20:33 <mjk> IceDane: tmo_: thanks
18:21:58 <tmo_> As for the problem, I'm try to program the interface such that whenever I press Ctrl-t, it appends a page to the notebook with a SourceView widget.
18:22:27 <tmo_> However, I'm not entirely sure on how to work with the EventM monad.
18:23:35 <wbruce> Any ideas on the implementation of a function (:: String -> [String]), that splits a string into chunks of [some] max length?  I'm sure I'm just missing some obvious function to use in Prelude
18:25:26 <magicman> tmo_: textBufferNew is not a new textbuffer, you need to give it a "Maybe TextTagTable" (which might as well be Nothing, unless you have specific ideas), and then it's still in wrapped in IO where you have to get it out of.
18:26:38 <magicman> wbruce: It's not in the prelude, sadly. I used to redefine it for nearly any project I work on, until someone here (I forgot who it was) pointed me at the split package.
18:26:42 <tmo_> magicman: I see.
18:27:20 <IceDane> wbruce: Something like: groupsOf n l = take n l : groupsOf n (drop n l)
18:27:26 <magicman> wbruce: http://hackage.haskell.org/package/split , specifically: splitEvery in Data.List.Split (in that package)
18:27:33 <IceDane> just add a pattern for groupsOf _ [] = []
18:27:45 <wbruce> ah, thanks (both)
18:32:56 <tmo_> magicman: I tried passing (unsafePerformIO $ textBufferNew Nothing) as opposed to textBufferNew into the function, and even though I gave it a valid textbuffer object, it still refused to treat it as a child widget.
18:33:51 <magicman> Eh, don't do the unsafePerformIO thing.
18:33:56 <magicman> Best to do something like:
18:34:02 <magicman>   tb <- textBufferNew Nothing
18:34:28 <tmo_> Okay, I'll try that
18:34:30 <magicman> and then use "tb" as argument to cNotebookAppendPage
18:35:04 <magicman> Was this a run-time or a compile-time error?
18:35:10 <tmo_> Compile
18:35:12 <magicman> (the one you got with the unsafePerformIO version)
18:35:37 <magicman> Same error message?
18:36:12 <tmo_> Actually, with your recommendation, I instead get the following:
18:36:13 <tmo_>     Couldn't match expected type `IO TextBuffer'
18:36:14 <tmo_>            against inferred type `mtl-1.1.0.2:Control.Monad.Reader.ReaderT
18:36:14 <tmo_>                                     (GHC.Ptr.Ptr EKey) IO TextBuffer'
18:36:17 <tmo_>     In a stmt of a 'do' expression: tb <- textBufferNew Nothing
18:36:20 <tmo_>  
18:36:48 <magicman> Oh, right. You're working in a wrapper around IO.
18:37:01 <magicman> Then add a liftIO to that :)
18:37:27 <magicman> Or wrap that one and the call to cNotebookAppendPage in one liftIO, whichever has your fancy.
18:38:04 <tmo_> liftIO did simplify the problem, however, I still get the following error message:
18:38:05 <tmo_>     No instance for (WidgetClass TextBuffer)
18:38:05 <tmo_>       arising from a use of `cNotebookAppendPage'
18:38:05 <tmo_>                    at interface.hs:50:17-58
18:38:08 <tmo_>  
18:38:24 <magicman> Riiiight.
18:39:09 <magicman> Ah! I don't think a TextBuffer is what you think it is.
18:40:04 <magicman> A TextView is the widget itself, the TextBuffer is the underlying data.
18:40:56 <tmo_> I'll try passing a TextView widget instead. :P
18:41:26 <magicman> Good luck :)
18:43:22 <tmo_> Well the good news is that it now compiles. The bad news is that it still doesn't append anything to the notebook. :P
18:43:52 <magicman> D'oh >_<
18:45:36 <magicman> Good luck with that. I haven't set up key shortcuts like that myself in gtk2hs.
18:45:55 <magicman> But try to see if the notebook-append-code works if not inside the event.
18:46:05 <tmo_> Very well.
18:46:20 <tmo_> I've never done GUI programming myself, let alone monadic GUI programming :P
18:52:38 <freedrull> does it make sense to write a typeclass with only one operation
18:53:00 <benmachine> freedrull: sure, see Functor
18:53:11 <dobie_gillis> freedrull: NEVER
18:53:12 <zachk> are you gonna have more then one instance of said typeclass? 
18:53:16 <benmachine> and, well, Eq has only one real operation
18:53:26 <benmachine> the other one's an elaborate hoax
18:53:48 <freedrull> zachk: yes
18:55:15 <freedrull> benmachine: uhhhhh well i guess   x /= y                =  not (x == y)
18:55:20 <freedrull> thats the only one?
18:56:20 <benmachine> freedrull: basically everyone defining an Eq instance only defines (==), yeah
19:35:34 <wbruce> the best implementation I can think of to get a String of A-Z is: take 26 $ iterate succ 'A' -- better ideas?
19:35:56 <Axman6> > ['A'..'Z']
19:35:57 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
19:36:23 <benmachine> > enumFromTo 'A' 'Z' -- explicit version
19:36:24 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
19:37:18 <wbruce> Axman6: ah, I was trying to use 'range' before (which I know is totally wrong); that is simpler ;-)
19:38:16 <Axman6> > ['A'..]
19:38:16 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
19:42:02 <roconnor> > tail []
19:42:03 <lambdabot>   *Exception: Prelude.tail: empty list
19:42:12 <roconnor> @quote zip`ap`tail
19:42:12 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:50:57 <megajosh2> :t ap zip tail
19:50:58 <lambdabot> forall b. [b] -> [(b, b)]
19:53:33 <megajosh2> @src ([]) ap
19:53:33 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:53:38 <megajosh2> :(
19:54:03 <megajosh2> Oh it's not part of a class...
19:54:10 <Axman6> :t ap
19:54:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:54:50 <Axman6> ap x y = do { f <- x; a <- x; return (f a)}
19:58:13 <benmachine> Axman6: you mean a <- y
19:58:20 * benmachine pedant
19:59:17 <megajosh2> > zip <*> tail $ [1..4]
19:59:18 <lambdabot>   [(1,2),(2,3),(3,4)]
19:59:35 <Axman6> yeah
20:00:37 <megajosh2> @src ([]) <*>
20:00:38 <lambdabot> Source not found. Do you think like you type?
20:00:40 <megajosh2> Meh
20:03:51 <megajosh2> > zip [1..4] (tail [1..4])
20:03:52 <lambdabot>   [(1,2),(2,3),(3,4)]
20:04:54 <llambda> i can't figure out how to recursively define a coin problem... given a target a, find all combinations of quarters, dimes, nickels, and pennies that give you a. does anyone have any pointers for me?
20:06:25 <Axman6> sounds like a dynamic programming problem... though not quite
20:06:40 <llambda> i just want to do it naively
20:06:44 <llambda> i can't even figure that out
20:07:53 <djahandarie> SICP details a nice way to count how many combinations there are, but not a way to actually make them
20:08:14 <Axman6> well, i'd start by first finding out how many of the highest denomination coin you need to be less than n, then take the remainder, and do the same thing with the next smaller denomination, until you've done all denominations
20:09:13 <llambda> take the remainder?
20:09:34 <Axman6> then you just need to remove one from each denomination, making the remainder larger until there's only the smallest denomination left
20:10:02 <Axman6> yeah, say you have $4.15, you'd take $4, then find out how to create $0.15 from the other denominations
20:10:17 <Axman6> then you'd take $3, and try and find how to make $1.15 from the others
20:10:21 <llambda> ah, okay
20:10:30 <llambda> i tried something like that, but i must have just done it wrong
20:17:10 <JoeyA> Does Cereal's MonadPlus instance of get mean if the first getter fails, try the second?
20:19:25 <ManateeLazyCat> Hi all.
20:19:46 <Axman6> JoeyA: i believe so
20:19:56 <ManateeLazyCat> Have any cabal function can search binary file in PATH?
20:19:57 <Axman6> i think it tries from where the first one tried
20:20:10 <Axman6> JoeyA: actually, i think you may want to use the Alternative instance
20:22:31 <JoeyA> They're equivalent in Cereal Get's case
20:22:49 <Axman6> Alternative has nicer syntax though :)
20:22:54 <JoeyA> (except for the error message being "empty" instead of "mzero")
20:23:08 <ManateeLazyCat> I want search gtk2hs-buildtools in user PATH before do "cabal intall gtk", then print understandable error notify user install package gtk2hs-buildtools first.
20:24:15 <Axman6> isn't gtk2hs-buildtools something you install with cabal, and as such should be a dependency of your app?
20:25:01 <ManateeLazyCat> Axman6: Because we have some hook use gtk2hs-buildtools before check depend, so add dependency information in gtk.cabal can't work.
20:25:11 <Saizan> ManateeLazyCat: it'd be more productive to fix cabal's bug of not installing build-tools automatically
20:25:31 <ManateeLazyCat> Saizan: That's need more time read the source code of cabal.
20:26:12 <ManateeLazyCat> Saizan: I just want some "cabal search path" function to fix this problem quickest.
20:26:30 <benmachine> ManateeLazyCat: just use System.Process and try to run it?
20:26:32 <llambda> Axman6, do you think this would be possible in a single recusive method or would you have the recusion alternate between functions?
20:26:48 <Saizan> Distribution.Simple.Program is how Cabal deals with external programs
20:26:55 <ManateeLazyCat> benmachine: Yep, i know how to search PATH in linux, but i'm not sure it can work on Windows too.
20:27:02 <Axman6> llambda: whatever is easier for you to figure out
20:27:08 <ManateeLazyCat> Saizan: Thanks
20:27:58 <llambda> Axman6, well ive been sitting at this for hours now lol... its sad but it's really twisting my brain
20:28:16 <benmachine> ManateeLazyCat: isn't something like rawSystem available on all platforms?
20:28:42 <benmachine> llambda: single recursive function, imo
20:29:51 <llambda> this assignment is in java, maybe that is the reason i'm struggling so much with it
20:30:01 <ManateeLazyCat> benmachine: rawSystem?
20:30:07 <ManateeLazyCat> @hoogle rawSystem
20:30:08 <lambdabot> No results found
20:30:18 <benmachine> ManateeLazyCat: System.Process
20:30:40 <benmachine> hmm rawSystem probably isn't what you want
20:30:42 <benmachine> exactly
20:30:55 <benmachine> it might dump things on your stdout or whatever
20:31:13 <benmachine> but you can do something suitable with createProcess I'm sure
20:31:16 <ManateeLazyCat> benmachine: Best not use Cabal function.
20:32:19 <ManateeLazyCat> benmachine: Because package 'gtk' will use gtk2hs-buildtools generate some file before check dependency of package gtk, so i need do "gtk2hsC2hs search" in PATH, if not found, notify user install gtk2hs-buildtools first.
20:32:29 <ManateeLazyCat> benmachine: I don't understand why i need create new process.
20:33:10 <benmachine> ManateeLazyCat: you don't *need* to create a new process, but it seems like the simplest way
20:33:18 <llambda> so would this be a reasonable type signature? change :: Int -> [(Int, Int, Int, Int)]
20:33:21 <benmachine> this way you also check if the tools are executable and working
20:33:56 <benmachine> ManateeLazyCat: so you just try to run, gtk2hsC2hs --help
20:34:11 <benmachine> and if it exits successfully you know it's fine
20:34:48 <ManateeLazyCat> benmachine: Oh, i see.
20:35:10 <benmachine> you could do it without a process but I think running a process is the simplest way
20:35:24 <benmachine> won't be the fastest but there you go
20:35:32 <ManateeLazyCat> benmachine: Thanks for your suggestion, i will consider it. :)
20:41:34 <sbahra> copumpki-, ping?
20:58:56 <JoeyA> Is it possible to attach default methods to existing classes (that is, without having to modify the module in which the class is defined)?
20:59:34 <monochrom> can't
20:59:38 <JoeyA> thanks
21:06:11 <leimy`> This seems to mess up tryhaskell.org, but I don't know why
21:06:20 <leimy`> (++ "age") <$> (Nothing :: Maybe String)
21:07:53 <monochrom> > (++ "age") <$> (Nothing :: Maybe String)
21:07:54 <lambdabot>   Nothing
21:08:03 <leimy`> yeah
21:08:07 <leimy`> that's what I'd expect
21:08:19 <monochrom> perhaps <>'s mess up web programming.
21:08:23 <leimy`> I do that tryhaskell.org, and I get a spinny wheel.
21:08:28 <leimy`> nah <$> works for other stuff too
21:08:40 <leimy`> > (+1) <$> [1..100] 
21:08:40 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
21:08:42 <monochrom> my guess fails
21:08:44 <leimy`> works fine :-)
21:15:52 <Mathnerd314> maybe it's the embedded type?
21:16:02 <leimy`> Nope works fine with Just
21:16:05 <leimy`> just not with Nothing :-)
21:16:34 <leimy`> > (+) <$> (+3) <*> (*100)
21:16:35 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:16:35 <lambdabot>    arising from a use of `...
21:17:06 <leimy`> > (+) <$> (+3) <*> (*100) $ 5
21:17:07 <lambdabot>   508
21:17:27 <Mathnerd314> leimy`: (++ "age"­) <$> (Noth­ing)  works for me
21:17:58 <Mathnerd314> though your original example does too :-/
21:18:04 <leimy`> huh weird
21:18:08 <leimy`> maybe it was just a connection issue?
21:18:56 <ManateeLazyCat> @hoogle getSearchPath
21:18:56 <lambdabot> System.FilePath.Posix getSearchPath :: IO [FilePath]
21:18:56 <lambdabot> System.FilePath.Windows getSearchPath :: IO [FilePath]
21:19:16 <leimy`> I'm wondering if the Applicative instance for ((->) r) is an interesting case for parallel execution.
21:19:54 <leimy`> I'm sure someone's already thought of that.
21:27:18 <leimy`> > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
21:27:19 <lambdabot>   [8.0,10.0,2.5]
21:34:18 <IceDane> leimy`: What the.. 
21:34:22 <IceDane> how the hell does that work?
21:34:50 <leimy`> http://learnyouahaskell.com/functors-applicative-functors-and-monoids  <-- made me think about some stuff :-)
21:35:06 <leimy`> and explains the Applicative instance for ((->) r)
21:35:07 <IceDane> I guess I don't know my functors
21:35:37 <JoeyA> Functor means: you have a magic box that contains something, in a sense, and you can tack on a function to change what's in the box (without taking it out)
21:35:43 <leimy`> You kind of have to think about a function as a sort of container that doesn't tell you what it's holding until you give it all the parameters it needs :-)
21:35:53 <leimy`> in that sense a function is a functor.
21:36:16 <IceDane> oh, wait
21:36:30 <JoeyA> the box could literally be a list of somethings (e.g. [a])
21:36:34 <leimy`> I believe the magic behind the Text.Printf scariness depends on that.
21:36:44 <IceDane> JoeyA: I know the basics of functors
21:36:48 <JoeyA> okay
21:36:56 <IceDane> anyway, it's very late
21:37:12 <IceDane> thanks for the explanations; I'll definitely have to read over functors again
21:37:15 <JoeyA> that's the kind of explaining I was looking for when I was learning about that stuff a few months ago.
21:37:27 <IceDane> I might be missing out on some good haskell magic in my code
21:37:38 <leimy`> yeah I think functors are overlooked, and perhaps more powerful than people may think... Applicative certainly lets you do "weird stuff" if you think about it.
21:37:41 <IceDane> JoeyA: Ahh. Functors always made much more sense to me than monads
21:37:48 <JoeyA> But <$> <*> <*> ... is a neat pattern.
21:38:09 <leimy`> JoeyA: that's from LearnYouAHaskell!
21:38:19 <JoeyA> Applicative means you have two boxes.  You take the function out of the first box, apply it to what's in the second box, and get a new box as the result.
21:38:20 <leimy`> well it was for me anyway.
21:38:41 <JoeyA> This introduces the notion of sequence.
21:38:43 <megajosh2> (\n d -> "You got "++n++" in "++d++"!") <$> ("your "++) <*> ("my "++) $ "chocolate" <*> "peanut butter"
21:38:51 <megajosh2> > (\n d -> "You got "++n++" in "++d++"!") <$> ("your "++) <*> ("my "++) $ "chocolate" <*> "peanut butter"
21:38:52 <lambdabot>   Couldn't match expected type `a -> GHC.Types.Char'
21:38:52 <lambdabot>         against inferred...
21:38:55 <megajosh2> Boom?
21:38:55 <JoeyA> However, the function can't influence what the box actually "does" if it is, say, an IO action.
21:39:08 <megajosh2> > (\n d -> "You got "++n++" in "++d++"!") <$> ("your "++) <*> ("my "++) $ "chocolate"
21:39:09 <lambdabot>   "You got your chocolate in my chocolate!"
21:39:19 <JoeyA> Monad lets you influence it.  Someone here said that's why monad is considered "promiscuous"
21:39:22 <megajosh2> No peanut butter :(
21:39:36 <IceDane> Hahaha, I love this channel
21:39:44 <IceDane> Hands down the best channel I've been on, on freenode
21:39:47 <leimy`> lol
21:39:51 <leimy`> megajosh2: nice :-)
21:40:04 <megajosh2> I guess it just wasn't meant to be
21:40:36 <leimy`> I was re-reading Hugh's Arrow paper.  It's interesting to note that some arrow combinators allow one thing to depend on another, or to compute both in parallel.
21:40:53 <leimy`> Then I started thinking about Applicative on ((->) r)
21:41:36 <leimy`> That's not to say the runtime must compute things in parallel, that's really an optimization.
21:41:55 <leimy`> but if you can, why don't you?  We got more cores than we know what to do with these days :-)
21:42:21 * applicative wishes he had more cores than he knew what to do with.
21:42:27 <leimy`> anyway, these feel like half baked thoughts.
21:43:04 <JoeyA> Someone needs to write a whatIf :: IO a -> IO a package.
21:43:27 <JoeyA> -- | Does not perform an action, but returns the result if it did.
21:43:29 <leimy`> parallel worlds? :-)
21:43:33 <JoeyA> right
21:43:36 <leimy`> lol
21:43:46 <leimy`> now we're bending time and space... GREAT!
21:43:49 <JoeyA> or perhaps a combinator library for manipulating the World
21:44:03 <JoeyA> getWorld :: IO World
21:44:10 <JoeyA> setWorld :: World -> IO ()
21:44:47 <JoeyA> That's enough to write whatIf
21:44:49 <IceDane> JoeyA: Alter your perception and alter the world
21:44:56 <IceDane> :P
21:45:40 <JoeyA> Actually, it might make sense in a restricted state monad.
21:45:43 <JoeyA> would*
21:45:49 <JoeyA> e.g. State
21:46:20 <IceDane> JoeyA: Haha, I like your whatIf
21:46:45 <IceDane> I would write a program to simulate my life and then go nuts
21:47:06 <ClaudiusMaximus> @hoogle local
21:47:06 <lambdabot> Control.Monad.Reader.Class local :: MonadReader r m => (r -> r) -> m a -> m a
21:47:06 <lambdabot> Trace.Hpc.Mix LocalBox :: [String] -> BoxLabel
21:47:06 <lambdabot> Data.Time.LocalTime localDay :: LocalTime -> Day
21:48:09 <ClaudiusMaximus> IceDane: the program would write a program and then go nuts...
21:48:21 <IceDane> ClaudiusMaximus: Hahahaha
21:49:25 <leimy`> ugh... what if reality is just us writing programs for our lives and having something else run them in parallel with everything else's program.  What if reality's runtime has a bug in it?  :-)
21:49:45 <leimy`> You know what thoughts like that lead to?  
21:49:47 <leimy`> Beer.
21:49:57 <IceDane> leimy`: You mean "stem from"?
21:50:03 <ClaudiusMaximus> sounds like a Greg Egan novel
21:50:12 <leimy`> Yes... Beer is the cause and solution to all of life's problems.
21:50:13 <IceDane> As for beer; Guinnes helped me grok monads initially
21:50:15 <JoeyA> whatIf action = do {backup <- get; result <- action; put backup; return result}
21:50:16 <leimy`> - Homer Simpson
21:50:32 <JoeyA> This requires a sufficiently powerful MonadState instance
21:51:05 <leimy`> Beer only helps you understand monads until you get to the point where you're saying "Monads, don't you mean GONADS", and then start high fiving strangers.
21:51:26 <leimy`> then the beer is a hindrance.
21:51:26 <IceDane> leimy`: Either way, what it would mean is that the end of your life would be determined by how much CPU time you were allocated at creation.
21:51:47 <leimy`> stupid quotas
21:52:06 <ClaudiusMaximus> better get into the sysadmin's Good Book then
21:52:23 <leimy`> alias smite=kill
21:52:29 <leimy`> oh wait...
21:52:29 <JoeyA> I think it'd be a rather fascinating to study what you could do if there were getWorld and putWorld IO actions.
21:52:30 <IceDane> ClaudiusMaximus: So you're implying that there is an omnipotent master? :P
21:52:31 <IceDane> god
21:52:42 <IceDane> this is turning into a discussion about religion
21:53:10 <leimy`> doesn't everything?
21:53:24 <leimy`> God, no god.. Emacs, vi. etc
21:53:59 <IceDane> JoeyA: Some bastard wuold lock the mutex for getWorld and keep it that way
21:54:23 <JoeyA> lol
21:55:18 <leimy`> Monad comes from "Monoidal Triad"?
21:55:58 <JoeyA> One thing to consider is that, if you operate in a monad that only works with files that can be reverted, you literally could write what-if code.
21:56:23 <leimy`> Sure, and you could do the same with lists with backtracking
21:56:35 <JoeyA> Right
21:56:41 <JoeyA> But I'm talking about filesystem support.
21:56:59 <JoeyA> So you could test rm -rf / and see what it would look like without it actually being committed.
21:56:59 <IceDane> JoeyA: oh, you mean snapshots and such?
21:57:02 <JoeyA> right
21:57:03 <IceDane> Like ZFS(I think?)
21:57:12 * ClaudiusMaximus still not sure how to pronounce monad - i pronounce it (in my head, don't have many local haskellers..) to rhyme with "on add"
21:57:14 <Axman6> preflex: seen bos
21:57:14 <preflex>  bos was last seen on #haskell 9 hours, 9 minutes and 51 seconds ago, saying: conal: right
21:57:29 <leimy`> ClaudiusMaximus: I say "Moe" "Nad"
21:57:32 <JoeyA> me too
21:57:33 <IceDane> ^
21:57:42 <ClaudiusMaximus> so i'm wrong! hooray!
21:57:47 <IceDane> haha
21:58:16 <IceDane> You can decidedly be different and pronounce it "Mo naaad."
21:58:36 <JoeyA> Just so y'all know, I squatted the name "monad" in Battle.net West (StarCraft Brood War (not 2))
21:58:45 <Ishpeck> It's comforting to my newbieness that, at the very least, I can pronounce Monad correctishly. :P
21:58:47 <JoeyA> So far, nobody's correctly identified it.
21:59:11 <JoeyA> One person said it was clever, but thought I simply transposed letters in "nomad"
21:59:17 <IceDane> JoeyA: Haha.
21:59:32 <IceDane> JoeyA: I've only met a few people online outside of this channel that had any idea what a monad was
21:59:42 <IceDane> And even then, those people were "Oh.. A monad from liek haskell?"
21:59:47 <IceDane> and that was the extent of their understanding.
22:00:07 <IceDane> Like one kid who argued that haskell was too hard to be used practically
22:00:17 <leimy`> I'd only heard of Liebniz Monadology before Haskell's monads.
22:00:17 <Axman6> a
22:00:20 <Axman6> ha*
22:00:53 <IceDane> I finally met that kid on irc and asked him about about haskell. Turned out he barely knew the basics because he had stopped because the paradigm was so unfamiliar
22:02:08 <ClaudiusMaximus> i think the way javascript apis force you to use continuation passing style is interesting
22:02:46 <leimy`> CPS can be used to model a lot of different interesting ideas.
22:04:24 <ManateeLazyCat> Why cabal still continue execute even i throw an error, how to make cabal stop immediately?
22:04:58 <ClaudiusMaximus> @hoogle exitFailure
22:04:58 <lambdabot> System.Exit exitFailure :: IO a
22:04:58 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
22:05:15 <ClaudiusMaximus> ^^ might work, bit "brute force" though
22:05:57 <ClaudiusMaximus> there's probably a better way more in tune with cabal
22:06:55 <ManateeLazyCat> ClaudiusMaximus: exitFailure can't work.
22:07:26 * ManateeLazyCat pasted "cabal output" at http://paste2.org/get/999633
22:07:27 <ManateeLazyCat> ClaudiusMaximus: My cabal output like above. 
22:08:06 <ManateeLazyCat> ClaudiusMaximus: I want cabal stop immediately when first time got error "setup: Can't found gtk2hsC2h ... " 
22:12:25 <ClaudiusMaximus> ManateeLazyCat: are you using 'requireProgram' - but i think it doesn't abort at once because (in my experience) it's better to get a lot of errors that you can fix all at once, rather than just one and have to rerun setup / configure many times
22:12:50 <ClaudiusMaximus> ManateeLazyCat: imagine if GHC aborted on the first error...
22:14:18 * ManateeLazyCat pasted "Setup.hs" at http://paste2.org/get/999637
22:14:37 * ManateeLazyCat pasted "Gtk2HsSetup.hs" at http://paste2.org/get/999638
22:14:45 <ManateeLazyCat> ClaudiusMaximus: Yes, i customize Setup.hs like above.
22:15:57 <ManateeLazyCat> ClaudiusMaximus: Infact, it's okay print a lot errors, but i think it's unnecessary print error many times.
22:16:18 <ManateeLazyCat> ClaudiusMaximus: I wonder have a way to abort cabal immediately. :)
22:19:28 <ClaudiusMaximus> ManateeLazyCat: you're importing requireProgram but not using it anywhere, afaict
22:19:56 <ManateeLazyCat> ClaudiusMaximus: Code need clean later. :)
22:20:36 <ClaudiusMaximus> ManateeLazyCat: ok, let me try something (i have a project with custom hooks...)
22:22:05 <ManateeLazyCat> ClaudiusMaximus: Thanks.
22:24:37 <ClaudiusMaximus> ManateeLazyCat: http://hpaste.org/40057/cabal_requireprogram_error_mes
22:25:41 <ClaudiusMaximus> ManateeLazyCat: maybe requireProgram would fix the problem, maybe not, but something to look at?
22:25:52 <ManateeLazyCat> ClaudiusMaximus: Ah, it's not fix my problem.
22:26:09 <ManateeLazyCat> ClaudiusMaximus: Infact, i want print some understandable error when can't found some program in PATH.
22:26:35 <ClaudiusMaximus> hm
22:26:52 <ManateeLazyCat> ClaudiusMaximus: My checkGtk2hsBuildtools will check 'gtk2hs-buildtools' whether install correctly before run cabal check.
22:27:24 <ManateeLazyCat> ClaudiusMaximus: Current, if user don't install 'gtk2hs-buildtools' before 'cabal install gtk', cabal will got error like your style. :)
22:27:25 <ClaudiusMaximus> well, in my case the same package provides the 'binembed' tool and the 'BinEmbed' module that the tool's output requires
22:27:39 <ClaudiusMaximus> so it's rare for them not be found together
22:28:04 <ClaudiusMaximus> ok, i see now
22:28:18 <ManateeLazyCat> ClaudiusMaximus: Thanks for your help, i guess my code is best solution. :)
22:28:41 <ClaudiusMaximus> you could manually check with an IORef perhaps?
22:29:02 <ClaudiusMaximus> with a "iShallSayThisOnlyOnce" function
22:31:27 <ManateeLazyCat> ClaudiusMaximus: Thanks, current solution is good enough for me. :)
22:33:15 <ClaudiusMaximus> ManateeLazyCat: since you're here - is there any recommended replacement for the Internal cairo modules that have been removed? (specifically, getting a Cairo Surface into a bytestring to save as a ppm image and/or do other processing)
22:33:16 <ManateeLazyCat> I print error "Please install package `gtk2hs-buildtools` first ..." explicitly now, i think all gtk2hs should know how to do when they not install package gtk2hs-buildtools.
22:34:13 <ClaudiusMaximus> no worries if you don't know the answer :)  i don't need it urgently either, just curious
22:34:35 <dmwit> Aren't there image surfaces to render to?
22:34:51 <ManateeLazyCat> ClaudiusMaximus: Cairo module have been removed?
22:35:03 <dmwit> That would be the answer with vanilla (non-Haskell) Cairo, I think.
22:35:10 <ManateeLazyCat> ClaudiusMaximus: Are you guy that develop image-viewer with gtk2hs?
22:35:45 <ManateeLazyCat> ClaudiusMaximus: IIRC, we talk this problem in gtk2hs list. :)
22:36:06 <ClaudiusMaximus> ManateeLazyCat: this module has been removed i think: import Graphics.Rendering.Cairo.Internal.Surfaces.Image
22:36:42 <ClaudiusMaximus> ManateeLazyCat: no, i'm some other guy
22:37:04 <ManateeLazyCat> caligula__: Graphics.Rendering.Cairo.Internal.Surfaces.Image at package 'cario'.
22:37:59 <ManateeLazyCat> ClaudiusMaximus: Oh, code is not there.
22:38:17 <ManateeLazyCat> ClaudiusMaximus: Wait, i search my mail, i remember some guy have same problem with you.
22:38:34 <dmwit> By the way, somebody should really update the gtk2hs API search. It's currently searching through the 0.9 API, which is very different from the 0.11 API.
22:38:54 <ClaudiusMaximus> dmwit: on hoogle? or hayoo? or someplace else?
22:39:10 <dmwit> on the gtk2hs website
22:39:24 <dmwit> There's a "Search API docs" button that goes to an 0.9 API search
22:39:46 <ClaudiusMaximus> i see, suboptimal
22:39:56 <ManateeLazyCat> ClaudiusMaximus: Graphics.Rendering.Cairo.Internal.Surfaces.Image module in cairo-0.11.x
22:41:07 <ManateeLazyCat> ClaudiusMaximus: Can you tell me which function missing? I can search for you.
22:41:16 <dmwit> I don't have that module here.
22:41:24 <ManateeLazyCat> ClaudiusMaximus: We move some cairo code in cairo-0.11.x
22:41:26 <dmwit> Oh, I need to update.
22:41:49 <dmwit> Anyway, it's not in the docs here: http://www.haskell.org/gtk2hs/docs/cairo-docs-0.11.0/ ...?
22:42:12 <ClaudiusMaximus> ManateeLazyCat: i was looking for imageSurfaceGetData
22:42:20 <ClaudiusMaximus> ManateeLazyCat: the module is there, but not exposed
22:42:24 <dmwit> nor here http://hackage.haskell.org/package/cairo
22:43:15 <ManateeLazyCat> ClaudiusMaximus: http://code.haskell.org/gtk2hs/cairo/Graphics/Rendering/Cairo.hs
22:43:16 <dmwit> ClaudiusMaximus: That function seems to be exposed in G.R.Cairo, though.
22:44:48 <ClaudiusMaximus> i see, cool
22:44:58 <ClaudiusMaximus> thanks ManateeLazyCat + dmwit
22:45:08 <JoeyA> Woot, I found a gem that comes from implementing an Alternative instance for unserialization.
22:45:17 <JoeyA> Instead of making my getItem function return a Maybe
22:45:23 <JoeyA> I can just be lazy and throw a fail inside it.
22:45:35 <JoeyA> But for better error handling, a user can do something like this:
22:45:36 <JoeyA> getWord = read <$> (getItem <|> fail "getWord: no more words left")
22:45:39 <ManateeLazyCat> ClaudiusMaximus: You're welcome! :)
22:46:50 <JoeyA> The idea is: Alternative sounds like it's just for backtracking.  However, it also lets you do exception handling like this.
23:00:03 * hackagebot pureMD5 2.1.0.0 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  http://hackage.haskell.org/package/pureMD5-2.1.0.0 (ThomasDuBuisson)
23:08:27 <sciolizer_> Somebody wrote a raytracer in Haskell by elegantly formulating the scene as Point -> Double, that is, mapping from each point to the distance to the nearest surface.
23:08:46 <sciolizer_> It's elegant because the union of shapes is just minimum.
23:08:48 <sciolizer_> But now I can't find it.
23:08:51 <sciolizer_> Anybody know where it is?
23:12:13 <sciolizer_> Found it: http://sebastiansylvan.spaces.live.com/blog/cns!4469F26E93033B8C!173.entry
23:26:11 * hackagebot network 2.2.1.8 - Networking-related facilities  http://hackage.haskell.org/package/network-2.2.1.8 (JohanTibell)
