00:00:04 <pantsd_home> Is there an isSpace equiv for ByteString?
00:01:02 <kmc> :t isSpace
00:01:03 <lambdabot> Char -> Bool
00:01:12 <kmc> that will work with ByteString.Char8
00:01:21 <kmc> regular ByteString is a string of bytes, not characters
00:01:24 <kmc> so isSpace makes no sense
00:04:45 <mm_freak> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29800
00:05:35 <copumpkin> yeah
00:05:44 <copumpkin> that's basically a phantom type
00:06:44 <mm_freak> copumpkin: well, yeahâ€¦  i didn't disagree about that =)
00:06:49 <copumpkin> :)
00:08:13 <mm_freak> so sortedness can be checked statically, but only in an ugly manner =)
00:08:17 <copumpkin> I used generalized abstract data families today btw!
00:08:35 <copumpkin> well, there's nothing stopping you from messing up the x < y check in there
00:08:52 <mm_freak> exactly
00:08:59 <mm_freak> hence "in an ugly manner" =)
00:09:30 <pantsd_home> :t splitWith
00:09:31 <lambdabot> Not in scope: `splitWith'
00:10:12 <mm_freak> splitWith?
00:10:44 <pantsd_home> splitWith is in Data.ByteString
00:10:55 <mm_freak> :t BS.splitWith
00:10:56 <lambdabot> (Word8 -> Bool) -> BSC.ByteString -> [BSC.ByteString]
00:11:13 <copumpkin> preflex: seen edward
00:11:13 <preflex>  Sorry, I haven't seen edward
00:11:14 <copumpkin> preflex: seen edwardk
00:11:14 <preflex>  edwardk was last seen on #haskell 7 days, 17 hours, 17 minutes and 42 seconds ago, saying: ;)
00:11:32 <mm_freak> > BS.splitWith even (BS.pack [1..10])
00:11:34 <lambdabot>   ["\SOH","\ETX","\ENQ","\a","\t",""]
00:11:43 <mm_freak> > BS.unpack $ BS.splitWith even (BS.pack [1..10])
00:11:44 <lambdabot>   Couldn't match expected type `Data.ByteString.Internal.ByteString'
00:11:44 <lambdabot>         ...
00:11:52 <mm_freak> > map BS.unpack $ BS.splitWith even (BS.pack [1..10])
00:11:53 <lambdabot>   [[1],[3],[5],[7],[9],[]]
00:12:07 <mm_freak> ah, i get it
00:16:30 <copumpkin> SPJ's so bubbly
00:21:43 <kmc> wiggly pointers everywhere, like snakes
00:27:29 <copumpkin> this talk is making me smile
00:27:44 <copumpkin> http://www.youtube.com/watch?v=NWSZ4c9yqW8
00:27:50 <copumpkin> I see edwardk was there
00:28:03 <copumpkin> trying to figure out what the angry-looking man was angry at at around minute 49
00:28:07 <copumpkin> can anyone hear him?
01:46:14 <iFire> what primers do you guys recommend on learning to optimise haskell
01:46:31 <iFire> as in code in haskell and not haskell core
02:08:41 <Nibble> @hoogle forever
02:08:41 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
02:19:12 <Twey> iFire: There's a profiling introduction in RWH
02:19:13 <augur> regarding http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/18866
02:19:42 <augur> i presume the expression e :: a -> a is intended, in the "gotcha" case, to mean that it's the same a as the whole op function?
02:20:00 <augur> that is, op is forall a. a -> a, but for any given a, say, Int, then e would be Int -> Int
02:20:02 <augur> ??
02:20:13 <dsssr> For benchmarking purposes I'd like to repeat a calculation in my code N times. Does anybody know of a convenient IO function for doing this?
02:21:09 <earthy> sequence_ . take n . repeat  ?
02:21:39 <earthy> given that your 'calculation' is of type  IO a
02:22:00 <Twey> take n . repeat = replicate n
02:22:02 <earthy> that should do what you want.
02:22:08 <earthy> twey: point.
02:22:17 <Twey> sequence . replicate = replicateM_
02:22:19 * earthy is still waking up. ;)
02:22:21 <Twey> Er, sequence_
02:22:31 <dsssr> thanks
02:22:44 <earthy> twey: however, replicateM_ is not in the Prelude.
02:22:56 <Twey> If it's not of IO a, you should use the â€˜evalâ€™ function
02:23:01 <Twey> @index eval
02:23:01 <lambdabot> bzzt
02:23:09 <Twey> Hmphâ€¦ where did that go
02:23:15 <iFire> dsssr criterion?
02:23:18 <iFire> http://www.scribd.com/doc/27352065/Modern-Benchmarking-in-Haskell
02:23:25 <Twey> @hoogle a -> IO a
02:23:26 <lambdabot> Control.Exception evaluate :: a -> IO a
02:23:26 <lambdabot> Control.OldException evaluate :: a -> IO a
02:23:26 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
02:23:27 <dsssr> I can make it of type IO
02:23:29 <Twey> Oh, that's the one
02:23:31 <Twey> evaluate
02:23:32 <fasta> dsssr, yes, you want criterion. 
02:23:45 <Twey> dsssr: If you don't use evaluate, it might not be evaluated
02:24:16 <Twey> So, fmap evaluate <$> replicateM_ n
02:24:28 <Twey> (some value)
02:38:14 * hackagebot msgpack 0.3.1 - A Haskell binding to MessagePack  http://hackage.haskell.org/package/msgpack-0.3.1 (HideyukiTanaka)
02:40:15 * hackagebot msgpack-rpc 0.3.1 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.3.1 (HideyukiTanaka)
02:48:30 <chrisdone> Twey: have you got a generic Eq a => a -> a -> Ordering (-1,0,1) compare function for javascript? I started with an Enum class but can't be bothered implementing instances for it. strings/integers/lists will do
02:48:39 <Twey> chrisdone: function cmp(a, b) { return a < b ? -1 : a > b ? 1 : 0; }
02:49:23 <chrisdone> oh, < works for strings and arrays
02:49:34 <Twey> Mm
02:49:35 <chrisdone> I'm guessing it's not part of a class though
02:49:39 <Twey> Nope
02:49:42 <Twey> No classes in JS
02:49:43 <chrisdone> swell
02:49:54 <chrisdone> well, whatever
02:49:56 <Twey> v8: [1, 2, 3] > [1, 2, 1]
02:50:04 <Twey> Oh, right, wrong channel
02:50:28 <chrisdone> closure compiler calls them classes and interfaces
02:50:31 <chrisdone> what do you call them?
02:51:32 <Twey> Magic.  :Ã¾
02:51:57 <Twey> You can use them on anything, though you may not get a sensible result.
02:51:59 * chrisdone drinks more coffee to avoid falling asleep over terminology discussion
02:52:20 <chrisdone> yeah I know
02:53:12 <chrisdone> closure makes the distinction that a class's methods have been implemented, and an for an interface they shouldn't be implemented
02:54:12 <chrisdone> (in the definition of the interface)
02:55:04 <chrisdone> you can call it magic and apply methods to arbitrary objects but who will cry at your funeral?
02:55:07 <Twey> chrisdone: Yeah, that's a Java thing
02:55:26 <Twey> chrisdone: JS doesn't have classes, so the comparison doesn't make much sense
02:57:44 <chrisdone> it's not a comparison, it's agreeing on ways to use javascript's objects, and it names them "class" and "interface"
03:01:14 <chrisdone> it's like saying "Haskell doesn't have objects" in react to me calling makeCake a constructor, Cake an object that is constructed by makeCake, and getDeliciousFilling an accessor
03:02:00 <chrisdone> or "C doesn't have classes"
03:08:02 <Twey> chrisdone: Umm no
03:08:37 <Twey> chrisdone: There are fundamental conceptual differences between JS's object model and a class-based one like Java's
03:08:55 <earthy> !sigh
03:08:57 <Twey> In JS, for example, it makes no sense to â€˜inherit a classâ€™ â€” there's simply no equivalent
03:09:04 <earthy> twey: nore is there in C
03:09:26 <Twey> Sure, you can pretend a constructor function is a class right up until you try to inherit from it, but then the analogy just breaks down
03:09:31 <Twey> earthy: Sure.
03:09:44 <rizlah> Anyone want to help me with an off-topic programming problem?
03:10:00 <iFire> just give a summary >.<
03:10:00 <earthy> rizlah: how far off topic? is it haskell? :P
03:10:13 <rizlah> It is not haskell, it is C++
03:10:19 <earthy> templates?
03:10:33 <rizlah> I need someone who understands UML to validate my interpretation of a UML diagram
03:10:50 <earthy> that's not C++...
03:10:57 <rizlah> My interpretation is
03:11:00 <earthy> ah
03:11:34 <rizlah> Its quite simple
03:11:36 <rizlah> Interpretation: http://codepad.org/zgVBBwmm Diagram: http://www.yaml.org/spec/1.2/spec.html#tag// <------ Section 3.2.2
03:11:41 <rizlah> Have a look if you feel like helping
03:13:39 <earthy> rizlah: assuming 'type' == 'kind'
03:13:50 <rizlah> Yeah
03:14:01 <rizlah> I'm not sure if the multiplicity is correct
03:15:43 <chrisdone> Twey: exactly where in the inheritence model of closure's programming style does break down occur?
03:15:57 <Twey> Do you mean Clojure?  I was talking about JSâ€¦
03:16:11 <chrisdone> no, the google closure compiler and associated libraries...
03:16:25 <Twey> No idea.  Never used it.
03:16:46 <chrisdone> ok
03:17:03 <Twey> Ah
03:17:07 <Twey> Hence the confusion.
03:17:25 <Twey> No, Closure probably builds a Java OO model on top of the JS one
03:17:35 <chrisdone> uh huh
03:17:45 <chrisdone> what did you think I meant?
03:17:52 <Twey> Clojure, the language
03:17:55 <chrisdone> lol
03:17:59 <Twey> Sorry
03:18:06 <Twey> I haven't had my Weetabix yet :Ã¾
03:18:33 <chrisdone> I dunno how clojure does objects if at all. it's got abstractions which are like generic functions or some kind of dynamic type class methods, iirc?
03:19:00 <chrisdone> I saw the talk ages ago
03:19:06 <Twey> I don't think it does objects, does it?
03:19:14 <Twey> Beyond accessing the Java object system
03:20:17 <Vq> oh, a new smalltalk vs simula discussion
03:20:21 <Vq> how interesting
03:20:31 <chrisdone> @slap vq
03:20:32 * lambdabot moulds vq into a delicous cookie, and places it in her oven
03:21:42 <earthy> rizlah: your interpretation looks right, although the UML dialect used in the diagram looks somewhat odd to me
03:21:44 <chrisdone> Twey: IIRC it can define "abstractions" on the fly which is essentially a generic function that dispatches on the particular type of its arguments. like generic functions in CLOS, I think. or typeclass methods in Haskell, but not tied to a specific set of methods
03:22:37 <rizlah> earthy: I see. Someone said that I should have many nodes to one tag, does that seem correct?
03:22:57 <earthy> sounds odd
03:23:02 <rizlah> Yeah, I thought so too
03:23:06 <Vq> :(
03:23:12 <earthy> the association betwee nodes and tags is directed from nodes to tags
03:23:14 <chrisdone> Twey: i.e. it has the `conj' abstraction which is an abstraction of CONS, it constructs vectors, lists, strings, whatever. map(j?)/fold, etc are defined like this. I quite like it
03:23:20 <earthy> and each node has exactly 1 tag associated with it
03:23:38 <earthy> (even though 1 tag may be associated with many nodes, this is not something you need to explicitly store)
03:23:42 <rizlah> I mean, I could always store a tag pointer and point at a tag rather than having a copy, which would cut down on memory usage, but it doesn't seem correct imo
03:24:11 <earthy> well, that would also be an acceptable interpretation
03:24:30 <rizlah> ¬.¬, I can see that being fun to code.
03:24:41 <rizlah> So apart from the tag issue, everything else is correct?
03:24:53 <earthy> well, including the tag issue everything seems correct
03:24:54 <rizlah> One thing I found strange was the pair and mapped parts
03:25:04 <Blkt> good day everyone
03:25:10 <earthy> note that I'm assuming the closed triangle head to be the association direction specifier
03:25:21 <earthy> as I said, this is not a dialect of UML directly familiar to me. :)
03:25:41 <rizlah> The coloured triangle is Composition, the white one is inheritance.
03:26:01 <earthy> I was afraid you might say that. :)
03:26:15 <rizlah> With the pair and mapped, I interpret that as one Mapped node may have many pairs?
03:26:17 <earthy> so 'a tag is composed of many nodes'? :)
03:26:31 <Twey> chrisdone: I thought it was just loosely typed
03:27:23 <earthy> rizlah: don't worry too much, your code looks to adequately interpret the diagram
03:29:01 <rizlah> I see. Thanks for the help.
03:38:41 <rizlah> earthy: If you still have some time, I have a few questions
03:38:51 <yitz> hello Blkt
03:39:51 <earthy> rizlah: sorry, unfortunately not
03:40:19 <Nibble> Most haskellers are bussy with their job. Their job often involves haskell
03:40:21 <Nibble> NOT
03:40:49 <rizlah> Ok, no worries.
03:41:56 <medfly> hehe
03:43:25 <yitz> Nibble: their job often involves haskell-influenced thinking processes while writing code in some other language
03:44:08 <rizlah> A haskell programmer's job occasionally involves things related to Haskell.
03:44:12 <medfly> there are people who work with Haskell.
03:44:18 <medfly> a select few
03:44:19 <yitz> yes, more and more.
03:44:33 <earthy> actually, my job *does* involve haskell...
03:45:04 <rizlah> earthy: No one said it didn't, we just said it was rare. :)
03:45:42 * earthy nods
03:46:30 <earthy> it just also involves C, Java, Perl, Shell scripts, custom languages...
04:24:16 <FunctorSalad_> sounds fun actually
04:25:05 <Saizan> so, you're working on a JVM backend for ghc?
04:26:21 <FunctorSalad_> (it feeds on java code)
04:35:19 <FunctorSalad_> is it an oversight that Data.Sequence doesn't have insertAt and deleteAt or would it be slow?
04:36:25 <FunctorSalad_> "split, cons/tail, join" should have log complexity according to the docs, but I don't know about the constant
04:40:14 <FunctorSalad_> sorry, go to go :)
04:40:18 <FunctorSalad_> *got
04:40:38 * hackagebot redis 0.8 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.8 (AlexanderBogdanov)
04:58:59 <fryguybob> @botsnack
04:58:59 <lambdabot> :)
05:02:01 <kamatsu> i have need of an Ord instance for Handles
05:02:17 <kamatsu> for I wish to have a set of them
05:02:35 <kamatsu> ideas?
05:02:42 <aristid> kamatsu: why not just use a list of them?
05:02:57 <kamatsu> i want faster than O(n) insert/delete
05:03:31 <aristid> do you need it? because if it's only 5 handles or so, the Set might be overhead
05:04:00 <kamatsu> it will be larger than that
05:04:02 <aristid> otherwise, you could try creating a newtype around the Handle with an Ord instance.
05:04:18 <kamatsu> but what information could i use for such an instance?
05:04:21 <Twey> How would you order them?
05:04:42 <Twey> I'd probably use a Map FilePath Handle
05:04:51 <kamatsu> these are actually socket handles
05:04:56 <Twey> Hm
05:05:04 <kamatsu> but i could just assign to them some numeric id
05:05:06 <Twey> By client port, then, maybe
05:05:09 <kamatsu> but that introduces a little more overhead.
05:05:23 <Twey> Are they server sockets or client sockets?
05:05:25 <kamatsu> i was of the impression that posix handles had numeric id's already.
05:05:38 <kamatsu> these are client sockets.
05:05:38 <Twey> Hm, yes
05:06:29 <aristid> yeah posix file descriptors are numbers
05:06:55 <kamatsu> but to get the Fd from the Handle in haskell, it has the side effect of flushing/closing the handle..
05:07:07 <Twey> I don't know if you can get the FD without deep magic
05:07:38 <Twey> The new IO models in 6.12 means that the handle may not even be backed by an FD
05:07:43 <Twey> s/models/model/
05:07:49 <kamatsu> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-IO.html
05:08:45 <Twey> I don't know what handleToFd would do with a handle that doesn't have an FD
05:08:50 <kamatsu> crash?
05:08:51 <Twey> I don't think I want to know :Ã¾
05:09:01 <Twey> Probably throw some sort of exception
05:09:04 <aristid> kamatsu: maybe easiest to assign a numeric ID to the handles yourself
05:09:20 <kamatsu> yeah, i guess i'll have to live with the marginal overhead of doing so
05:09:23 <kamatsu> ok, thanks all
05:09:39 <aristid> Twey: what kind of handles have no FD?
05:09:48 <Twey> Ah, here we are
05:10:07 <Twey> case cast haDevice of Nothing -> ioError (ioeSetErrorString (mkIOError IllegalOperation "handleToFd" (Just h) Nothing) "handle is not a file descriptor")
05:10:44 <Twey> aristid: 6.12 allows you to make a Handle out of anything you can back with some sort of stream-like interface
05:10:53 <Twey> A handle is basically a collection of get and put functions
05:11:11 <Nibble> Could someone give an example of forkIO? The ones I can find does not compile
05:11:32 <Twey> Nibble: main = forkIO $ print "hi"
05:11:35 <aristid> Twey: you can make a Handle from a list? (read-only then)
05:11:40 <Nibble> Twey: danke
05:11:42 <Twey> aristid: Sure, theoretically
05:12:21 <Twey> aristid: There's not much mystery to it: you pass it an IO action and it executes it (possibly) in parallel, with the forkIO returning a ThreadID you can use with throwTo and the like
05:12:35 <Twey> Sorry, Nibble ^
05:13:07 <Nibble> I see.
05:26:03 <nostrand> hi, does anyone have a simple complete example for the package monadic cp?
05:28:38 <Nibble> nostrand: simple does not go well with complete
05:34:59 <nostrand> Nibble: i just meant a program which will compile
05:36:47 <Nibble> Haskell is having a hard time getting children I heard
05:36:54 <Nibble>   main =
05:36:56 <Nibble>        later waitForChildren $
05:45:50 <Jonno_FTW> > "test"
05:45:51 <lambdabot>   "test"
05:54:47 <jrockway> if someone on SO wants to clean this up, i would appreciate it: http://stackoverflow.com/questions/3655329/how-does-one-sort-with-data-vector-generic-mutable/3658823#3658823
05:54:53 <jrockway> i have to disappear for a bit :)
05:59:24 <Nibble> what is the "best" haskell framework.
06:00:08 <deteego> what do you mean by framework
06:00:32 <Nibble> Ioh shit
06:00:34 <chrisdone> what's the "best" haskell function?
06:00:34 <Nibble> oh*
06:00:37 <Nibble> web framework
06:00:40 <Nibble> lol
06:00:41 <Nibble> :P
06:00:54 <chrisdone> ;D
06:00:58 <aristid> chrisdone: nub
06:01:05 <deteego> chrisdone: I would have to say that map is the best haskell function
06:01:08 <chrisdone> Nibble: there isn't a de facto standard
06:01:17 <Nibble> chrisdone: well, if you were to choose
06:01:18 <chrisdone> Nibble: nor a particularly preferred one either
06:01:20 <Nibble> what one would you use
06:01:26 <chrisdone> I use CGI/FastCGI
06:01:27 <Nibble> Lets put it this way then.
06:01:32 <Nibble> What one would be the easiest.
06:01:33 <medfly> chrisdone, the best Haskell f unction is fix.
06:01:35 <Nibble> Happstack
06:01:39 <Nibble> medfly: indeed
06:01:40 <chrisdone> some use happstack
06:01:44 <Nibble> > fix error
06:01:45 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:01:46 <chrisdone> Snap is quite nice and will get nicer
06:01:49 <Axman6> fmap > map
06:01:54 <osfameron> id is the best haskell function!
06:02:03 <Nibble> I am the best haskell function
06:02:08 <tab> foldl is better
06:02:28 <Nibble> foldr is better
06:02:29 <aristid> osfameron: id sucks!
06:02:50 <aristid> ap is cool too
06:02:51 <tab> oh yeah, typo :)
06:03:07 <chrisdone> that's the type of question you see on StackOverflow. what's the "best" haskell function? THIS QUESTION HAS BEEN DISABLED BECAUSE IT IS AMBIGUOUS OR NONTECHNICAL. ** Locked ** Mark as community wiki by Jeff Atwood  3,421 upvotes, 312 comments
06:04:12 <chrisdone> followed by comments arguing why it's a technical question
06:05:05 <chrisdone> Nibble: I personally used fastcgi because I like the MonadCGI monad
06:05:28 <chrisdone> I'll switch to Snap once it gets file uploads and such, or if I write those features myself
06:06:05 <chrisdone> some guy implemented a purely haskell fastcgi library
06:06:15 <aristid> snap also has the best-looking website of all haskell web libraries
06:06:21 <chrisdone> and completely disregarded the CGI monad from the CGI library. what a douche
06:06:23 <Nibble> aristid: what a merit
06:06:28 <chrisdone> if you're in here, I hate you
06:06:32 <aristid> Nibble: yes, it is very important
06:06:38 <Nibble> as the saying goes.
06:06:40 <Nibble> DIY
06:06:46 <Nibble> or, DUI.
06:06:51 <Nibble> Depens on situation
06:07:06 <aristid> nothing is respectable without a TLA
06:07:20 <Nibble> what the hell is the cabal package for snap? name of it that is
06:07:22 <Nibble> @hoogle snap
06:07:23 <lambdabot> No results found
06:07:25 <Nibble> :(
06:07:31 <earthy> snap-core and snap-server
06:07:46 <Nibble> I want both?
06:07:51 <dcoutts_> Nibble: "cabal list snap" does a substring search
06:07:54 <Nibble> ah
06:07:56 <Nibble> thanks
06:07:57 <earthy> snap-server pulls in snap-core
06:08:08 <earthy> (and some other stuff as well)
06:08:15 <sshc> Where should SCC pragmas be placed?
06:08:20 <chrisdone> Nibble: the web site very clearly explains this
06:08:21 <sshc> I can't find any documentation on it
06:09:41 <earthy> sshc: at the start of any expession that you would like profiled
06:12:19 <earthy> but, see section 5.1.1., Inserting cost centres by hand, of the GHC manual, paragraph 2.
06:16:32 <aristid> @pl \x -> map (subtract (head x)) x
06:16:32 <lambdabot> map =<< subtract . head
06:25:19 <Nibble> Lets say I accidentaly made a dir named snap
06:25:23 <Nibble> ran snap init in it
06:25:27 <Nibble> then did cabal install
06:25:28 <mmmulani> oh snap
06:25:32 <Nibble> mmmulani: indeed.
06:25:36 <Nibble> why would happen?
06:25:52 <Nibble> oh nvm
06:25:55 <Nibble> it got fixed
06:27:28 <Nibble> woho
06:27:32 <Nibble> I found a bug in cabal
06:27:36 <Nibble> cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda
06:27:57 <Nibble> Do I get a medal?
06:27:58 <dcoutts_> Nibble: don't try running cabal install base
06:28:06 <Nibble> dcoutts_: oh
06:28:15 <dcoutts_> Nibble: that's what you did right? to get that error?
06:28:19 <Nibble> dcoutts_: indeed
06:28:48 <Nibble> cabal install
06:28:50 <Nibble> Resolving dependencies...
06:28:52 <Nibble> cabal: There is no installed version of base
06:30:01 <dcoutts_> Nibble: base is special
06:30:06 <dcoutts_> you cannot cabal install it
06:30:17 <dcoutts_> so we don't worry too much about the bad error message
06:30:51 <Nibble> dcoutts_: why shouldn't I be able to do that?it is a cabal package
06:31:00 <Nibble> and that is what the tut says
06:31:06 <dcoutts_> Nibble: it cannot be compiled with ghc --make anyway
06:31:11 <Nibble> dcoutts_: what?
06:31:18 <Nibble> I am following the snap api tutorial
06:31:30 <dcoutts_> Nibble: what? it does not say to install base, I don't believe it
06:31:32 <Nibble> or wait, the name was, snap quick start guide
06:31:40 <Nibble> dcoutts_: I am not trying to install base when getting that error.
06:31:41 <dcoutts_> Nibble: you've got base installed already, always
06:31:51 <dcoutts_> what command did you run?
06:31:55 <Nibble> dcoutts_: cabal install
06:31:59 <dcoutts_> in what directory?
06:32:09 <Nibble> dcoutts_: a dir where I did snap init
06:32:21 <dcoutts_> ok, what .cabal file
06:32:26 <Nibble> dcoutts_: my own.
06:32:27 <dcoutts_> perhaps you can paste it somewhere
06:32:39 <Nibble> wait, I am going to try one thing first
06:32:43 <Nibble> cleaning out my cabal dir
06:32:47 <Nibble> I have so much shit.
07:02:19 <orbital_fox> @type Silence
07:02:20 <lambdabot> Not in scope: data constructor `Silence'
07:03:08 <orbital_fox> clearly lambdabot is wrong.. Silence is in the scope of this channel
07:03:46 <Nibble> HAR HAR HAR
07:04:30 <orbital_fox> :)
07:07:35 * hackagebot instant-generics 0.2 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.2 (JosePedroMagalhaes)
07:09:02 <orbital_fox> hackagebot, what are u on about?
07:11:51 <Nibble> lets say I have this (x:xs) as a argument, and I want to do this (xs:x) with it
07:12:00 <ski> type error
07:12:02 <Nibble> But I get this error
07:12:04 <Nibble> Occurs check: cannot construct the infinite type: t = [[t]]
07:12:10 <ski> maybe you wanted `xs ++ [x]' ?
07:12:18 <Nibble> ski: most likely yes
07:12:19 <zygoloid> Nibble: what do you expect (xs:x) to do?
07:12:28 <Twey> x :: a, xs :: [a], (:) :: a -> [a] -> [a]
07:12:34 <Nibble> zygoloid: well, since : is list constructor..
07:12:39 <zygoloid> that would be a list with xs as its first element, and x as the remaining elements
07:12:49 <Nibble> zygoloid: yeah
07:13:14 <Nibble> ski: that doesn't work either.
07:13:18 <Twey> (xs :: [a]) : (x :: a) only makes sense if a = [[a]] = [[[[a]]]] = [[[[[[a]]]]]]â€¦ et cetera
07:13:24 <zygoloid> Nibble: think that through. what does that mean the type of x would be?
07:13:31 <ski> as Twey said, `x:xs' means that `xs' is a list whose elements have the same type as `x'
07:13:44 <ski> Nibble : what exactly did you try ?
07:14:01 <Nibble> wai
07:14:04 <Nibble> t
07:14:10 <ski> Nibble : and what does "doesn't work" mean ? type error ? run-time error ? logic error ?
07:14:21 <Nibble> I ended up doing this
07:14:29 <Nibble> ski: I was about to tell you that, but I came up with a solution
07:14:31 <Nibble> (xs ++ x:[])
07:14:33 <Nibble> :P
07:14:46 <ski> Nibble : that's the same as `xs ++ [x]'
07:14:50 <Nibble> doesn't work either, exception empty list.
07:14:56 <Nibble> ski: is it? cool
07:15:00 <zygoloid> Nibble: (x:xs) is [x, <all elements of list xs>]. so (xs:x) = [xs, <all elements of list x>].
07:15:04 <Nibble> zygoloid: I know
07:15:21 <Nibble> zygoloid: you have been saying that for the last five minutes.
07:15:22 <zygoloid> Nibble: in order for that to make sense, x must be a list of elements of the same type as xs.
07:15:26 <ski> Nibble : i still haven't seen what code you have tried
07:15:27 <Nibble> yes.
07:15:33 <zygoloid> and xs must be a list of elements of the same type as x
07:15:40 <ski> (i.e. a whole definition, at least)
07:15:47 <zygoloid> so x is a list of lists of elements of the same type as x
07:16:03 <zygoloid> which is exactly what the error message is telling you. x is type t, where t = [[t]]
07:16:35 * ski really should leave now, so hopefully others can continue helping ..
07:16:52 <Nibble> ski: look, I suppreciate you tring to help me
07:16:55 <zygoloid> such types are called 'infinite types' and are not allowed in haskell.
07:16:57 <Nibble> but I am getting flooded with stuff.
07:17:02 <Nibble> zygoloid: I don't need a lecture.
07:18:37 <zygoloid> ok, sorry :) didn't intend to lecture
07:21:19 <deteego> whats the difference between let and where in regards to scoping in case statements?
07:23:04 <chrisdone> let is an expression, where isn't
07:23:40 <chrisdone> where is tied to a binding
07:24:14 <chrisdone> so in case x of foo -> 3; k -> x where x = 1
07:24:35 <chrisdone> the AST is case x of (foo -> 3); (k -> x where x = 1)
07:25:06 <chrisdone> alright?
07:25:10 <deteego> yes
07:25:14 <deteego> I understand that
07:25:24 <deteego> im more from the viewpoint of nested case statements
07:25:25 <chrisdone> :-)
07:25:39 <chrisdone> the same applies
07:25:51 <deteego> ok
07:26:31 <yitz> > concat . intersperse "==" . fix $ ("a" :) . map (('[' :) . (++ "]"))
07:26:32 <chrisdone> case () of () -> (case x of () -> ()) where x = ()
07:26:32 <chrisdone> differs to
07:26:32 <chrisdone> case () of () -> case x of () -> () where x = () 
07:26:32 <lambdabot>   "a==[a]==[[a]]==[[[a]]]==[[[[a]]]]==[[[[[a]]]]]==[[[[[[a]]]]]]==[[[[[[[a]]]...
07:27:01 <chrisdone> (in the second, x is bound to () within the second case, so it's out of scope and a compile error)
07:27:16 <chrisdone> you see?
07:27:17 <luite> if I have a Word64 wrapped in a newtype, is it possible to automatically derive the instance for Unbox, so that it can be used in a Data.Vector.Unboxed?
07:27:33 <deteego> chrisdone: yes thanks
07:27:42 <aristid> yitz: haha, stealth lambdabot attack. i wondered where that strange output came from
07:27:55 <yitz> :)
07:28:15 <aristid> :t map (('[' :) . (++ "]"))
07:28:16 <lambdabot> [[Char]] -> [[Char]]
07:28:28 <deteego> chrisdone: anyways thanks, good night
07:28:38 <chrisdone> yitz: the growth of a lion's mane over time
07:28:55 <jmcarthur> alright haskellers. represent! http://ai-contest.com/ http://github.com/jaspervdj/planet-wars-haskell
07:29:18 <yitz> chrisdone: :)
07:29:58 <luite> oh I got it, I think I made a typo in the GeneralizedNewtypeDeriving pragma
07:30:20 <chrisdone> @slap luite
07:30:20 * lambdabot hits luite with an assortment of kitchen utensils
07:34:06 <chrisdone> man I am SO adding type completion to emacs when I get home tonight
07:34:41 <chrisdone> and function completion
07:35:00 <chrisdone> Baughn: where's my semantic Haskell editing?
07:38:16 <chrisdone> @tell Baughn where's my semantic haskell editing?
07:38:16 <chrisdone> @tell Baughn where's my semantic haskell editing?
07:38:16 <lambdabot> Consider it noted.
07:38:16 <lambdabot> Consider it noted.
07:40:16 <orbital_fox> chrisdone, is that an existing addon or are you making it?
07:41:39 <aristid> chrisdone: this means we'll get awesomely better emacs haskell editing soonish?
07:42:28 <Nibble> what?
07:42:38 <Nibble> I want a better vim mode for haskell
07:42:45 <Nibble> haskell mode for vim
07:43:48 <orbital_fox> haskell mode for vim + 1 :)
07:43:56 <orbital_fox> is he writing it from scratch?
07:44:19 <aristid> Nibble: chrisdone uses emacs :)
07:44:57 <BrianHV> what would semantic haskell editing in vim look like?
07:45:17 <orbital_fox> aristid, no one is perfect.. but they can try to be.. so there is time for him to save him self :P
07:46:47 <BrianHV> ...and what was that library that was supposed to be plugged into editors to provide haskell editing features?
07:50:17 <BrianHV> scion.
07:54:26 <Baughn> chrisdone: I've found the need to /understand/ how to parse haskell, to do that.
07:54:26 <lambdabot> Baughn: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:54:33 <Baughn> chrisdone: It's boring. And therefore slow going.
07:54:34 <Baughn> @clear
07:54:35 <lambdabot> Messages cleared.
07:57:38 <Baughn> chrisdone: ..so, "eventually".
08:02:12 <chrisdone> Baughn: booo!
08:02:20 * chrisdone throws popcorn packet
08:02:42 <chrisdone> aristid: do you already use some of these? http://github.com/chrisdone/haskell-mode-exts
08:03:03 <aristid> chrisdone: not yet :)
08:03:20 <itsmonktastic> > let x = 1 in case x of (True -> _) -> ""
08:03:21 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:03:21 <lambdabot>         against inferred type ...
08:03:32 <itsmonktastic> against inferred type 't -> t1'
08:03:35 <chrisdone> Baughn: why not do it incrementally? do little workable bits at a time
08:03:40 <itsmonktastic> does anyone else find that error message kind of backwards?
08:03:54 <itsmonktastic> (needs -XViewPatterns)
08:04:07 <Baughn> chrisdone: I don't think a parser that parses only haskell'98 is useful to /anyone/.
08:04:20 <tehgeekmeister> this is not a haskell question, but i figure this is the best place to ask: does anyone know of tools/extensions to other languages (ruby or python preferably) that allow you to check if your code is total?  i am tired of simple errors based on not considering some case accidentally.  would be nice if i could programmatically check for these problems.  and i can't switch to haskell since it's for work.
08:04:29 <chrisdone> Baughn: aren't you using haskell-mode-exts?
08:04:32 <Baughn> chrisdone: Beyond that, I can do it incrementally, but the parser is the hard bit and it's also only feasible when whole
08:04:41 <Baughn> chrisdone: I'm /rewriting/ haskell-src-exts.
08:04:45 <chrisdone> pffft!!!
08:04:59 <chrisdone> Baughn: you could restrict it to the current expression/definition
08:05:03 <Baughn> The original was only capable of parsing valid code
08:05:33 <chrisdone> why don't you make it impossible to write invalid code?
08:05:41 * chrisdone looks at paredit
08:06:03 <Baughn> That would clash horribly with my own editing style. ;)
08:06:15 <chrisdone> booo!
08:06:16 <Baughn> I never liked paredit
08:06:28 <chrisdone> paredit is the pinnacle of code editing
08:06:30 <Baughn> Certainly, adding that as an /option/ would be good - later on.
08:10:16 <aristid> chrisdone: i have a very lame problem... i don't know how to best install your stuff, because all of my other emacs stuff was installed by apt-get
08:10:39 <chrisdone> aristid: pretty sure I put examples in how to install the files in each .el
08:10:45 <chrisdone> which do you want to install?
08:11:03 <Nibble> How would I make this sort algortithm to evaluate to the sorted list
08:11:05 <Nibble> http://pastebin.com/EJVGFjnE
08:11:09 <aristid> chrisdone: all of them?
08:11:28 <Nibble> I have tried adding a separate argument as a container for it but had little success
08:16:45 <chrisdone> aristid: put the .el file in question in your emacs load path. do you know what a load path is?
08:17:15 <chrisdone> personally I have the directory ~/Emacs/haskell-mode-exts
08:17:34 <copumpkin> preflex: seen edwardk
08:17:34 <preflex>  edwardk was last seen on #haskell 8 days, 1 hour, 24 minutes and 2 seconds ago, saying: ;)
08:17:40 <chrisdone> then in my .emacs
08:17:41 <chrisdone> (add-to-list 'load-path "~/Emacs/haskell-mode-exts")
08:17:55 <chrisdone> then
08:17:55 <chrisdone> (require 'haskell-align-imports)
08:17:55 <chrisdone> (define-key haskell-mode-map (kbd "C-c .") 'haskell-align-imports)
08:17:56 <chrisdone> done
08:21:40 <ezyang> let foo | cond1 = ... | cond2 = ... | otherwise ... --> why was I not informed! :o) 
08:22:00 <aristid> chrisdone: ok, adding a haskell section to my .emacs :)
08:23:25 <aristid> chrisdone: wait, do i need a very recent version of haskell-mode for this to work?
08:24:59 <itsmonktastic> Nibble: you almost have it, you just need to change it to: if x <= (head xs) then x:sort xs else ...
08:26:37 <copumpkin> I'd avoid using head
08:26:44 <copumpkin> just pattern match a level deeper
08:27:09 <bnery> hi guys
08:27:17 <bnery> do any of you know cpython?
08:27:38 <bnery> cpython: http://hackage.haskell.org/package/cpython
08:29:44 <chrisdone> aristid: it's separate to haskell-mode. the inf-haskell-send-cmd is dependent on haskell-mode but it shouldn't have any version issues
08:31:46 <ski> Nibble : did you resolve the problem ?
08:32:17 <co_dh> bnery: it's a binding for libpython, 
08:32:41 <bnery> co_dh that I know off :), I'm trying to find an usage example to get me started
08:32:44 <co_dh> bnery: so I guess you can start a python interpreter in Haskel.
08:33:39 <aristid> chrisdone: i installed 2.8.0 anyway
08:34:09 <aristid> which of the three haskell-mode indentation modules is best? :D
08:34:26 <bnery> co_dh ah, ok
08:34:48 <bnery> co_dh do you know how I can get "text-0.8.0.0:Data.Text.Internal.Text" instantiated?
08:34:58 <buntfalke> (Why) is there no feasible method of compiling Haskell code to run on bare metal, as with "gcc -fno-hosted"?
08:35:12 <co_dh> bnery: what is a text-0.8.0.0?
08:35:17 <co_dh> I don't know. 
08:35:35 <bnery> I think the text-version is the library
08:35:40 <ezyang> buntfalke: It's an open research problem, but you might look at House. 
08:35:49 <revenantphx> morning folks
08:36:16 <buntfalke> ezyang: Well, I had a look at some of the existing projects, but they're all dead, it seems.
08:36:41 <bnery> does anyone know how I can get an instance of a "Data.Text.Text"?
08:36:51 <buntfalke> or rather s/some/all I could find/
08:37:55 <co_dh> is www.python.org down?
08:38:33 <medfly> http://downforeveryoneorjustme.com/
08:38:42 <co_dh> bnery: pack "abc" ? 
08:39:13 <revenantphx> It's up for me.
08:39:35 <ezyang> buntfalke: See also, "Open research problem." :-) 
08:39:58 <buntfalke> Well...yeah... :-)
08:40:37 <co_dh> I can't cabal install text 
08:40:49 <bnery> co_dh thanks!
08:41:17 <dcoutts_> co_dh: what goes wrong?
08:41:51 <co_dh> Data/Text/IO.hs:123:13: Not in scope: `hGetBuffering'
08:41:52 <co_dh> Data/Text/IO.hs:125:4:
08:41:52 <co_dh>     Not in scope: data constructor `BlockBuffering'
08:42:05 <co_dh> I guess some version problem. 
08:42:12 <bnery> co_dh it works, but the module I try to load with cpython gives me segmentation fault :P
08:42:44 <co_dh> does your module use dll ?
08:43:02 <co_dh> s/does/do
08:43:34 <co_dh> bnery: did you call initialize?
08:43:35 <dcoutts_> co_dh: what version of ghc are you using?
08:43:52 <co_dh> 6.10.4
08:43:54 <dcoutts_> tibbe: ^^ text-0.8 package compilation problems
08:44:35 <co_dh> dcoutts_: I'm using Mac OS X 10.5.8
08:45:07 <co_dh> do we have built bot for hackage ? 
08:45:21 <tibbe> dcoutts_: GHC version?
08:45:27 <revenantphx> OS X has GHCi, version 6.12.3
08:45:32 <dcoutts_> tibbe: 6.10
08:45:42 <revenantphx> At least, the most recent version on 10.6.4 is 6.12.3
08:46:00 <co_dh> bnery: how do you run your module with cpython? 
08:46:27 <tibbe> dcoutts_: builds for me on GHC 6.12.3 at least
08:46:34 <tibbe> dcoutts_: on snow leopard
08:47:43 <tibbe> dcoutts_: I don't have 6.10 installed atm
08:47:45 <dcoutts_> tibbe: right, co_dh above reports problem with 6.10, Data/Text/IO.hs:123:13: Not in scope: `hGetBuffering'
08:48:19 <dcoutts_> tibbe: you should be able to reproduce it if you build using base 3 with 6.12
08:48:50 <dcoutts_> tibbe: it's for things like this that I have 5 versions of ghc installed :-) 6.4 and upwards
08:49:57 <tibbe> dcoutts_: I used to have more version before my little iconv problem
08:50:16 <dcoutts_> nuke macports! ;-)
08:50:22 <tibbe> dcoutts_: I did!
08:50:23 <aristid> dcoutts_: 6.4?  do you really need that anymore?
08:50:31 <tibbe> dcoutts_: I'll try to hack the .cabal file to use old base
08:50:35 <dcoutts_> aristid: only for testing purposes
08:50:46 <aristid> dcoutts_: isn't that a waste of time?
08:51:36 <dcoutts_> aristid: one more version is not hard: for ghc in ghc-6.4.2 ghc-6.6.1 ....; do cabal configure --compiler=${ghc}; etc; done
08:51:44 <yitz> jmcarthur: http://www.reddit.com/r/haskell/comments/danim/jaspervdjs_unofficial_haskell_starter_package_for/
08:52:16 <tibbe> dcoutts_: text should use base4 or later with 6.10 and upwards
08:52:51 <dcoutts_> tibbe: sure, but it should either work with base 3 or have a dependency on base >= 4
08:53:04 * hackagebot local-search 0.0.1 - AA first attempt at generalised local search within Haskell, for applications in combinatorial optimisation.  http://hackage.haskell.org/package/local-search-0.0.1 (RichardSenington)
08:53:36 <tibbe>   build-depends:
08:53:36 <tibbe>     base       < 5,
08:53:36 <tibbe>     bytestring >= 0.9 && < 1.0
08:53:37 <tibbe>   if impl(ghc >= 6.10)
08:53:37 <tibbe>     build-depends:
08:53:37 <tibbe>       ghc-prim, base >= 4, deepseq >= 1.1.0.0
08:53:47 <tibbe> dcoutts_: so I guess that should be changed
08:54:14 <dcoutts_> tibbe: interesting, I don't know why it fails with 6.10 then, someone will have to test it
08:54:33 <tibbe> dcoutts_: I'm kinda swamped at the moment
08:54:40 <tibbe> dcoutts_: I'll start downloading 6.10 and try later
08:54:51 <dcoutts_> tibbe: ask someone else to do it :-)
08:55:07 <tibbe> dcoutts_: 6.10.4 right?
08:55:23 <dcoutts_> tibbe: that's what co_dh says
08:55:43 <co_dh> yes, 6.10.4
08:56:18 <tibbe> co_dh: I'll try to build 6.10.4 and try it
08:56:43 <bnery> co_dh it's not really for running, it's for loading and calling from inside Haskell
08:56:55 <bnery> co_dh I'm still trying to realize how to do it
08:57:20 <co_dh> bnery: can you eval a python string in cpython ? 
08:58:39 <bnery> co_dh no idea yet ;) just started
08:59:01 <yitz> co_dh: yes
08:59:13 <tibbe> dcoutts_: gah, I can't bootstrap 6.10.4 with 6.12.3
08:59:14 <tibbe> sigh
08:59:24 <dcoutts_> tibbe: you'll need a binary
08:59:24 <co_dh> yitz: I mean in haskell's cpython package. 
08:59:33 <yitz> co_dh: oh. :)
09:00:05 <tibbe> co_dh: could you send an email to Bryan O'Sullivan with your problem? Let me know if you need his email (it's on hackage as he's the maintainer)
09:00:18 <yitz> co_dh: well i'm sure you can in MissingPy
09:00:19 <dcoutts_> tibbe: compiling old versions is never supported
09:00:29 <tibbe> dcoutts_: right, I just remember
09:00:30 <co_dh> tibbe: ok.
09:00:32 <dcoutts_> tibbe: I mean compiling old versions of ghc using newer ones
09:00:43 <tibbe> dcoutts_: binary versions don't coexist well on OS X I believe
09:01:08 <dcoutts_> ah yes the .pkg versions don't co-exist
09:01:14 <dcoutts_> you'd need unix-style installs
09:01:22 <dcoutts_> like /usr/local
09:01:42 <tibbe> dcoutts_: that's what I tried
09:01:56 <co_dh> yitz: missingPy seemed not maintained anymore
09:01:58 <tibbe> dcoutts_: by building from source
09:02:24 <yitz> co_dh: are you sure? John Goerzen does still seem to be around...
09:02:42 <co_dh> yitz: build failure on 6.10 & 6.12
09:03:35 <yitz> co_dh: anyway, if cpython is anything like MissingPy, you could grab the __builtins__ module object and get the eval function from there
09:04:24 <co_dh> yitz: you are right :), bnery: I think that's the way you want. getObject "__builtin__" or somehting 
09:04:36 <co_dh> bnery: getObject "eval"
09:04:52 <yitz> co_dh: that would be a shame. MissingPy always worked great for me, and cpython is GPL so it has limited usefulness
09:05:16 <bnery> co_dh nice
09:05:29 <bnery> co_dh i'm trying to call a method from a object now
09:06:37 <Olathe> I'm making a custom state monad, and I want to be able to do 'putWhatsit x' in the do block to slightly change the state of the monad. How do I do that without losing the rest of the state?
09:06:54 <co_dh> I don't have python 31 installed now, so I can't test myself.
09:07:33 <co_dh> tibbe: I've send the mail to bos 
09:07:36 <yitz> Olathe: it depends on the type of the state
09:07:57 <Olathe> Let's say the state type is (a, b, c) and putC changes only the c part.
09:08:24 <yitz> Olathe: modify . putC
09:08:42 <Olathe> Ahh, thanks :)
09:08:58 <mun> hi
09:09:08 <Olathe> @src modify
09:09:08 <lambdabot> Source not found. Where did you learn to type?
09:09:25 <yitz> Olathe: where putC :: c -> (a, b, c) -> (a, b, c)
09:10:02 <Olathe> Hmm, alright.
09:10:08 <yitz> Olathe: modify :: (s -> s) -> State s ()
09:10:35 <yitz> or same thing for StateT, or whichever monads package you're using
09:10:46 <mun> can a logical theory contain statements about its provability or consistency? say, a theory T, in which "EX x. x = 0" is provable?
09:11:29 <yitz> @hoogle modify
09:11:30 <lambdabot> Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
09:11:30 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
09:11:30 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
09:14:01 <Olathe> I'm guessing modify f = do { a <- get; put (f a) }
09:15:12 * hackagebot haskeline 0.6.2.4 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.2.4 (JudahJacobson)
09:15:27 <kamatsu> why does atomicModifyIORef take a function (a->(a,b)) whereas the normal modifyIORef takes the more sensible (a->a)?
09:18:21 <copumpkin> kamatsu: so you can do something with the original value
09:18:31 <copumpkin> kamatsu: without reading it separately, which would break the atomicity
09:18:53 <copumpkin> (it doesn't just take that function, but also returns an IO b instead of IO ())
09:19:27 <Nibble> is there any library I can use to get information about a image (width, height)
09:20:56 <kamatsu> copumpkin: okay, so it's okay if i just make a function that goes "\f -> (doSomething f, ())"
09:21:01 <kamatsu> ?
09:21:09 <copumpkin> kamatsu: oh, sure, if you don't care about the original value
09:21:33 <kamatsu> so, is modifyIORef not atomic?
09:21:57 <Vulpyne> Nibble: imlib seems to have a function like that.
09:22:31 <kamatsu> ah, it wouldn't be atomic between the read and write
09:22:32 <kamatsu> i see
09:22:37 <yitz> jaspervdj: i linked your starter kit on reddit, becaus jmcarthur linked it here on #haskell. guess i should have asked you first - hope it's ok.
09:22:59 <jaspervdj> yitz: No, it's no problem :-)
09:23:22 <yitz> jaspervdj: good luck. you did great last time!
09:23:35 <yitz> jaspervdj: hope others will also join in
09:24:35 <yitz> Nibble: ImageMagick will also do it for you
09:25:08 <yitz> Nibble: if the image is in a fixed format known in advance, use the lib for that format of course.
09:25:31 <Nibble> imma gunna try both
09:26:09 <yitz> @hackage hsmagick
09:26:09 <lambdabot> http://hackage.haskell.org/package/hsmagick
09:30:09 <Nibble> uh hu, wtf
09:34:28 <Nibble> @hoogle liftIO
09:34:28 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
09:34:47 <Nibble> hu
09:34:51 <Nibble> that is not what I were after
09:37:01 <Nibble> I have something of type IO Int
09:37:04 <Nibble> I want it to be Int
09:37:42 <nooooob> noobs
09:37:49 <Zao> nooooob: So say we all.
09:37:57 <nooooob> :)
09:38:15 <Vulpyne> Nibble: You can only do that from inside a function that returns "IO whatever".
09:38:20 <Nibble> Vulpyne: ok
09:38:23 <Nibble> but I fixed it I think
09:38:29 <Nibble> imWidth <- imageGetWidth
09:38:31 <Vulpyne> Nibble: For example, in main you could do: thingy <- thingthatreturnsIOInt
09:38:37 <Vulpyne> And then you can treat thingy as an Int.
09:38:48 <Nibble> Vulpyne: I am way ahead of you :P
09:38:53 <Vulpyne> So it seems. :)
09:39:12 <Nibble> Oh shit
09:39:15 <Nibble> I have mah image viewer
09:39:17 <Nibble> awesome
09:39:25 <Vulpyne> Sweet.
09:39:35 <Nibble> Vulpyne: not really, but still.
09:39:45 <Nibble> I worked on it before but wanted it to automagically scale the window
09:40:02 <Nibble> wasn't capable of doing it back then due to not understanding enough haskell
09:53:05 <mun> I'm reading a tutorial on higher-order logic, but what does the following sentence mean: "The truth of a statement in HOL cannot depend on the syntax of a term or formula."
09:54:08 <mun> how can a statement talk about the syntax of a logic?
09:59:36 <roconnor> mun: I don't understand that statement either without its context
09:59:42 <tolkad> I'm a bit confused by seq. How would you define it in haskell?
09:59:57 <roconnor> tolkad: it is a primitive
10:01:16 <revenantphx> hm, correct me if i'm wrong
10:01:27 <revenantphx> in C the increment size for a void pointer is 1 byte?
10:01:30 <kmc> tolkad, you can define it for specific types
10:01:30 <revenantphx> (this is related to haskell)
10:01:33 <kmc> seq False x = x
10:01:35 <kmc> seq True x = x
10:01:36 <RyanT5000> revenantphx: i believe that's true
10:01:57 <Ke> revenantphx: stop, voids have no increments!
10:02:09 <revenantphx> Ke: except myVoidPtr++ is valid.
10:02:15 <revenantphx> (and yes Ke, thats what I usually think too)
10:02:19 <Ke> revenantphx: in gnu extension, the increment is 1 byte
10:02:21 <tolkad> kmc: oh! that makes sense. thanks
10:02:26 <revenantphx> Ke: yeah, as it is in LLVM
10:02:30 <copumpkin> revenantphx: no
10:02:34 <Ke> revenantphx: but it is not allowed in C
10:02:40 <sm> re making tests optional in packages: what's the big deal about QuickCheck 1 vs QuickCheck 2 ? Can't I just depend on QC2 and be happy ?
10:02:42 <tolkad> kmc: I guess you could implement it as a class magically derived by all types
10:02:47 <revenantphx> Ke: That's what I'm used too.
10:02:50 <copumpkin> rule of thumb is
10:02:50 <revenantphx> But right here It's working
10:02:55 <copumpkin> don't inrement void pointers
10:02:56 <kmc> tolkad, yeah, it was in a type class in pre-98 versions of Haskell
10:02:58 <copumpkin> cause it won't always work
10:02:58 <revenantphx> I prefer to cast to a char anyhow
10:03:01 <revenantphx> copumpkin: yeah.
10:03:06 <roconnor> tolkad: nope, because it works for functions too, but you can't write the case for functions by hand.
10:03:16 <revenantphx> I know this stuff, i'm just curious because all of a sudden its working.
10:03:19 <revenantphx> which is ... weird
10:03:23 <kmc> tolkad, there is some advantage to that; it's obvious in the type if you're using seq
10:03:24 <revenantphx> usually the compiler freaks out on me.
10:03:29 <pikhq> Ke: Arguably, it's allowed in C, but undefined behavior.
10:03:32 <Ke> revenantphx: just because you have a broken compiler, does not make ~ valid code
10:03:40 <Ke> pikhq: =D
10:03:43 <revenantphx> Ke: Oh I know, and it's not broken anyhow
10:03:44 <pikhq> (and thus it would be permissible for the compiler to launch the missiles)
10:03:58 <revenantphx> it's not ANSI C, but it's a common extension
10:04:04 <revenantphx> I'll cast to char anyhow, tyvm
10:04:10 <Ke> yes
10:04:46 <tolkad> revenantphx: why would you want to increment a NULL pointer?
10:04:54 <revenantphx> it's not a null pointer tolkad.
10:04:59 <revenantphx> It's a void pointer.
10:05:13 <revenantphx> Null pointer is just a pointer to 0x00000000
10:05:20 <revenantphx> Void* is a typeless pointer.
10:05:34 <revenantphx> kinda.
10:06:30 <tolkad> it doesn't make sense for the increment to be one byte... I thought it would be sizeof(size_t)
10:06:37 <tolkad> err wait
10:06:38 <tolkad> no
10:06:42 <tolkad> that's not what I meant
10:06:54 <tolkad> uh sizeof(void)! yeah that's it
10:06:55 <kmc> revenantphx, this question has something to do with Haskell?
10:06:57 <copumpkin> lol
10:07:11 <revenantphx> kmc: believe it or not yes.
10:07:25 <revenantphx> this is part of my mad science experiment to splice haskell C into Apple's block extension.
10:07:47 <tab> tolkad: just consider sizeof(void) = sizeof(char) then ;)
10:08:26 <copumpkin> omg SPJ responded to me
10:08:26 <notabel> revenantphx: awesome!  some bastard child of GCD and GHC eventually?
10:08:36 <copumpkin> I am now officially a real person
10:08:37 <revenantphx> notabel: that'd be the goal, yes.
10:08:57 <copumpkin> preflex: seen dolilo
10:08:57 <preflex>  Sorry, I haven't seen dolilo
10:08:59 <copumpkin> preflex: seen dolio
10:09:00 <revenantphx> no promises though, i'm notorious for not finishing things.
10:09:00 <preflex>  dolio was last seen on #haskell 6 days, 9 hours, 49 minutes and 29 seconds ago, saying: Or Voldemort.
10:09:04 <tolkad> ugh why would you increment a void pointer. They should have made it illegal. it's a terrible thing to do
10:09:10 <revenantphx> preflex: seen revenant
10:09:11 <preflex>  Sorry, I haven't seen revenant
10:09:17 <tolkad> just cast it and then increment
10:09:17 <revenantphx> member:preflex: seen revenantphx
10:09:17 <copumpkin> tolkad: I agree :P
10:09:29 <p_l> tolkad: ... it actually is useful sometimes, as void pointer might be a valid one
10:09:57 <tolkad> p_l: it's not like it will compile to anything different if you just cast it first
10:10:10 <copumpkin> p_l: it just doesn't have a defined size
10:10:13 <copumpkin> so incrementing it makes no sense
10:10:36 <tolkad> v_ptr = (void*)(((char*) v_ptr)++)
10:10:53 <copumpkin> (granted, the syntax is fugly)
10:10:54 <revenantphx> that's madness tolkad, no need to do that
10:10:58 <p_l> wasn't sizeof(void*) == sizeof(char*)?
10:11:04 <revenantphx> blptr = (uint64_t*)blptr + 1;
10:11:06 <revenantphx> thats sufficient
10:11:09 <copumpkin> p_l: yes, but the underlying type has no size
10:11:23 <copumpkin> p_l: an increment increments the pointer by sizeof(underlying type)
10:11:26 <revenantphx> you can't do casts nicely on prefix or postfix incrementors
10:11:35 <revenantphx> since a++ is equivalent to a += 1
10:11:42 <revenantphx> so if you cast a... you're casting an lvar
10:11:45 <p_l> copumpkin: I recall some part of the standard specifying equivalence of void* and char*
10:11:47 <revenantphx> which is not valid.
10:11:56 <copumpkin> p_l: again, the size of the pointers is the same
10:11:59 <revenantphx> GUYS
10:12:01 <tolkad> p_l: by pointer increment we mean x in sizeof(x) * sizeof(x*)
10:12:02 <revenantphx> THIS IS #HASKELL
10:12:03 <revenantphx>  > >
10:12:18 <tolkad> err wait
10:12:32 <tolkad> whatever I don't care let's stop talking about C
10:13:02 <p_l> copumpkin: it was specifically for pointer arithmethic, because on some platforms a proper void* would be of different size, but sizeof(char*) got fixed to 1 and hilarity ensued
10:13:16 <copumpkin> huh
10:13:34 <aristid> revenantphx: also a++ is NOT equivalent to a+=1
10:13:40 <tolkad> p_l: how could sizeof(char*) be 1? you can only have 256 chars in memory?
10:13:47 <copumpkin> let's get off this topic
10:13:51 <kmc> surely sizeof(char*) /= 1, even if sizeof(char) = 1
10:14:00 <copumpkin> much misunderstanding going on in here, but this isn't the place to correct it
10:14:03 <p_l> tolkad: right, sizeof(char). My bad, lack of sleep and coffee
10:15:06 <tolkad> what's the default haskell heap size limit and can you access within haskell/GHC haskell?
10:15:13 <tolkad> what's the default ghc heap size limit and can you access within haskell/GHC haskell?*
10:15:24 <tolkad> what's the default ghc RTS heap size limit and can you access within haskell/GHC haskell?*
10:15:42 <tolkad> please don't kill me if I got that wrong
10:16:15 <revenantphx> aristid: it's not, but its a nice analogy
10:16:24 <revenantphx> as to why ++(char*)myvoidptr is invlaid
10:16:58 <aristid> revenantphx: how about saying "++a is equivalent to a+=1", which would be a lot more correct?
10:17:07 <revenantphx> yeah
10:17:19 <tolkad> aristid: how are theye different?
10:17:23 <tolkad> they*
10:17:32 <revenantphx> a++ copies a, and applies the increment AFTER the statements usage
10:17:44 <aristid> @src ZipList ap
10:17:45 <revenantphx> so printf("%d", 9++) will print 9
10:17:45 <lambdabot> Source not found.
10:17:47 <copumpkin> okay, we all know our c and c++ 
10:17:48 <aristid> @src ZipList (<*>)
10:17:48 <lambdabot> Source not found. stty: unknown mode: doofus
10:17:51 <revenantphx> but ++9 will print 10
10:19:14 <tolkad> oh, I thought you meant on a line by itself. I understand the difference inline
10:19:39 <tolkad> ok sorry haskell now
10:19:44 <tolkad> what's the default ghc RTS heap size limit and can you access within haskell/GHC haskell?
10:19:52 <aristid> > intercalate ", " $ zipWith id (cycle [id,("co"++)]) (repeat "pumpkin")
10:19:53 <lambdabot>   "pumpkin, copumpkin, pumpkin, copumpkin, pumpkin, copumpkin, pumpkin, copum...
10:19:54 <kmc> the default is no limit
10:20:03 <aristid> copumpkin: i made this just for you.
10:20:07 <copumpkin> aristid: aww
10:20:10 <copumpkin> thanks
10:20:13 <kmc> you can access the limits by foreign importing parts of the RTS code
10:20:22 <kmc> don't know a nicer way
10:21:46 <tolkad> kmc: would be nice if GHC did that and made it a library
10:22:18 <tolkad> do you know of an example of this being done?
10:22:28 <kmc> no
10:22:42 <tolkad> ok thanks guess I'll figure it out myself
10:38:59 <sm> can anyone point me to the recent blog post on how to make your executable depend on your lib in one package, avoiding double compilation ?
10:40:01 <sm> hmm, looks easy enough. cabal 1.8, I guess that's fine
10:40:35 <dcoutts_> sm: note there's still a bug about using this feature with haddock
10:41:06 <aristid> :t ZipList . cycle
10:41:07 <lambdabot> forall a. [a] -> ZipList a
10:41:14 <sm> thanks dcoutts_. A serious one ? like, preventing haddock docs ?
10:41:33 * sm tries
10:41:45 <dcoutts_> sm: I think so yes
10:42:15 <sm> is it this "setup: Can't find transitive deps for haddock", or is that some local breakage ?
10:42:40 <aristid> is there a nicer way to do this?  (current, next) <- zip bases (map Just (tail bases) ++ [Nothing])
10:43:12 * sm finds http://hackage.haskell.org/trac/hackage/ticket/656
10:45:19 <aristid> mmh, maybe foldr ((:) . Just) [Nothing]
10:45:29 <kmc> foldr ((:) . f) = map f
10:45:38 <aristid> kmc: no
10:45:42 <kmc> no?
10:45:47 <aristid> foldr ((:) . f) [] = map f
10:45:47 <zygoloid> kmc: foldr ((:) . f) [] = map f
10:45:52 <kmc> ah right
10:46:14 <aristid> kmc: changing the [] to [Nothing] to append that
10:46:16 <kmc> foldr ((:) . f) = \x -> map f ++ xs
10:46:18 <kmc> yeah
10:46:22 <kmc> err xs
10:46:36 <aristid> but i'm not sure which of those is nicer
10:46:47 <zygoloid> manual fusion of map {foldr ((:) . f) []} and (++) {foldr (:) xs}
10:47:13 <zygoloid> aristid: what do you do in the Just/Nothing cases? much the same stuff?
10:47:24 <aristid> zygoloid: (current, next) <- zip bases (map Just (tail bases) ++ [Nothing])
10:47:38 <zygoloid> aristid: sure, but what does the /rest/ of the code do?
10:48:28 <aristid> zygoloid: it checks if some values are between current and next
10:48:51 <aristid> actually just if they are less than next
10:49:01 <aristid> and if next is Nothing, the check is omitted
10:52:40 <zygoloid> (Just current, next) <- (zip`ap`tail) (map listToMaybe $ tails bases)
10:52:41 <zygoloid> :D
10:53:21 <aristid> zygoloid: heh
10:53:40 <aristid> it took me a minute to understand that
10:53:49 <zygoloid> @quote aztec
10:53:50 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
10:54:30 <zygoloid> aristid: you could try: current:nexts <- tails bases
10:54:57 <zygoloid> maybe: current:(listToMaybe -> next) <- tails bases
10:55:02 <zygoloid> if you like view patterns
10:55:07 <aristid> zygoloid: let me see if i can ...
10:55:29 <aristid> zygoloid: it would make the code shorter, i think
10:55:34 <zygoloid> \o/
10:55:39 <aristid> i could use all instead of maybe True, too
10:55:55 <aristid> but... that would be slower :D
10:55:58 <zygoloid> that'd be slower though (assuming it's still correct)
10:56:07 <zygoloid> slam a (take 1) in there
10:56:30 <aristid> current:(take 1 -> next)?
10:57:14 <aristid> or current:next <- take 2 <$> tails bases
10:57:50 <zygoloid> i think i'd put the take 1 into the all
10:58:10 <zygoloid> "current:rest <- tails bases; guard (all foo (take 1 rest))" looks ok to me
10:58:23 <zygoloid> not sure it's as obvious as the zip you started with though
10:58:23 <aristid> nah, no guard
10:58:51 <aristid> i just want to omit the check if it's got no next element
10:58:56 <aristid> guard does the opposite ;)
10:59:30 <zygoloid> that check alwasy passes for the last element.
10:59:40 <aristid> zygoloid: semantically speaking, next is the "end of time" in that case
10:59:48 <aristid> oh
11:00:35 <aristid> zygoloid: ah right. i used to use guard but replaced it with takeWhile because i have the requirement to have sorted lists
11:01:59 <aristid> and yeah, the "Improved" version is probably less readable
11:03:50 <HugoDaniel> i have a xml schema, is there anyway to automatically generate haskell data types based on it ?
11:04:10 <HugoDaniel> that would definetly improve my workflow
11:09:50 <luite> 4
11:09:53 <luite> err oops
11:10:12 <Olathe> > 4 --test
11:10:13 <lambdabot>   4
11:10:18 <Olathe> > 4 --==
11:10:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:10:49 * hackagebot FTPLine 1.0.1 - A command-line FTP client.  http://hackage.haskell.org/package/FTPLine-1.0.1 (DanielDiaz)
11:13:15 <sm> how do I stop all the "Interface file is of wrong version: /Users/simon/.cabal/share/doc/transformers-0.2.1.0/html/transformers.haddock" warnings when generating docs ?
11:13:38 <dcoutts_> sm: by regenerating those docs
11:13:54 <sm> thanks
11:19:09 <sm> I guess I'll remove all those old .haddocks
11:52:17 <Nibble> @src map
11:52:18 <lambdabot> map _ []     = []
11:52:18 <lambdabot> map f (x:xs) = f x : map f xs
11:52:30 <Nibble> ah
11:52:32 <Nibble> I see
11:52:38 <Nibble> numbers1 = 1 : map (+1) numbers1
11:53:16 <Nibble> so that roughly translates to numbers1 = 1 : 1 + 1 : 1 + the previous one?
11:53:19 <Nibble> or is it 1+1+1?
11:54:19 <kmc> would you like an explanation of how that expression is evaluated?
11:55:56 <Cale> > let numbers = 1 : map (+1) numbers in numbers
11:55:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:56:13 <Nibble> kmc: indeed
11:56:38 <Cale> Nibble: Yeah, it'll compute each successive element in terms of the previous element
11:56:40 <kmc> well, due to laziness, nothing is evaluated until we pattern-match on the result
11:56:45 <Cale> Nibble: computation will be shared between them
11:56:51 <kmc> and when that does happen, we update the value in-place
11:56:54 <Nibble> Cale: ah
11:56:58 <Nibble> that was what I wanted, thanks
11:57:11 <kmc> so let's say we match numbers1 against (x0:xs0)
11:57:31 <kmc> case 1 : map (+1) numbers1 of (x0 : xs0) -> ...
11:57:36 <kmc> right away, you can see that x0 = 1
11:57:50 <Feuerbach> is there a package for portable and safe directory traversal? (safe -- I mean with respect to possible symlink cycles. E.g. directory-tree does not look safe.)
11:58:08 <kmc> now if we match xs0 against (x1:xs1)
11:58:19 <kmc> then we need to evaluate Â«map (+1) numbers1Â» until it gives us a (:) constructor
11:58:34 <Nibble> I see
11:58:45 <kmc> and from the definition of map you retrieved above, you can see that Â«map f numbers1Â» will itself pattern-match numbers1
11:59:33 <kmc> map (+1) (1 : map (+1) numbers1) = ((+1) 1) : map (+1) (map (+1) numbers1)
11:59:52 <kmc> i'm just inlining f and x:xs in the definition of map
12:00:15 <kmc> and of course ((+1) 1) reduces to 2 (though not until you, say, print it)
12:00:49 <kmc> so now we've reduced numbers1 to Â«1 : 2 : map (+1) (map (+1) numbers1)Â»
12:01:11 <kmc> and so on ad infinitum
12:02:00 <Nibble> To VN: Impressive, most people try to sum the infinite list. VN: That is what I did.
12:04:08 <Cale> (Who is VN?)
12:04:22 <roconnor> :D
12:04:36 <Nibble> Von Neumann
12:05:08 <Nibble> or was it Alan turing..
12:05:12 <Nibble> it probably was.
12:05:18 * geheimdienst didn't know these dudes lurked here
12:05:19 <Nibble> Long time since I talked to him
12:05:23 <mauke> I vote von Neumann
12:05:27 <Nibble> mauke: so do I
12:05:33 <Nibble> but I am not sure,
12:05:47 <Nibble> I am going to ask him
12:06:05 <benmachine> Feuerbach: I was looking for something like that recently and didn't find it, although I didn't look terribly hard
12:06:29 <benmachine> Feuerbach: I'm vaguely interested in writing such a thing, I guess it would drag around a Set of visited inodes
12:07:41 <byorgey> that quote is von Neumann.
12:08:38 <chrisdone> the whole quote is what?
12:09:04 <Nibble> @hoogle splitBy
12:09:05 <lambdabot> No results found
12:09:22 <chrisdone> @google Data.List.Split hackage
12:09:23 <lambdabot> No Result Found.
12:09:25 <Feuerbach> benmachine: inodes? that already doesn't sound portable. Is Windows comfortable with inodes?
12:09:31 * chrisdone spanks lambdabot
12:09:43 <byorgey> chrisdone: http://stepanov.lk.net/mnemo/legende.html
12:09:55 <byorgey> chrisdone: search for "fly puzzle" on that page
12:11:18 * geheimdienst points out that many system calls can return errno ELOOP, which means the function had to follow too many symlinks
12:12:17 <geheimdienst> i'm pretty sure they just count up and then bail at some large threshold. they don't schlep around lists of previously seen symlinks or something
12:12:19 <benmachine> Feuerbach: to be honest I have no idea :P
12:12:49 <geheimdienst> iow, see if that behavior you're looking for is not already built in, cause i suspect it is
12:12:51 <benmachine> by sheer coincidence I've just posted an email to haskell-cafe asking about handling system-specific configurations :O
12:13:32 <Nibble> does haskell have some kind of regex?
12:13:38 <Feuerbach> okay, the biggest problem here really is portable detection and reading of symbolic links
12:13:59 <chrisdone> wow that page is really fanatic
12:14:18 <Nibble> chrisdone: what page
12:14:26 <Nibble> oh
12:14:39 <byorgey> fanatic or fantastic?
12:15:21 <Nibble> " by 8 he had mastered the calculus"
12:15:28 <Nibble> I wonder how much of that is true
12:17:06 <Feuerbach> Nibble: doesn't sound extraordinary to me
12:17:31 <Nibble> Feuerbach: what doesn't?
12:18:10 <Feuerbach> oh, it's 8 years, not 8th grade :)
12:18:23 <Nibble> :P
12:22:18 <jedai> Nibble: Yes, Haskell has regex
12:22:43 <jedai> Nibble: Maybe a little too much even... it has several libraries
12:23:00 <jedai> Nibble: which to choose may depends on your needs
12:24:19 <Nibble> about that link
12:24:47 <Nibble> find the first power of the whose decimal digit fourth from hte right is 7
12:25:13 <Nibble> In C I would probably split it into an array
12:25:16 <Nibble> and check
12:25:25 <Nibble> how would I do it in haskell?
12:26:14 <hpc> i would do filter g . map f $ [1..]
12:26:14 <mauke> parse error
12:26:22 <hpc> for certain values of f and g
12:26:39 <hpc> then the first element is your answer
12:27:08 <Nibble> hpc: what?
12:27:08 <roconnor> > find (\x -> show (2^x)!!4 == '7') [0..]
12:27:09 <lambdabot>   *Exception: Prelude.(!!): index too large
12:27:10 <Feuerbach> hpc: first element of filter is find
12:27:14 <Nibble> oh
12:27:16 <Nibble> ah
12:27:20 <Nibble> roconnor: brilliant
12:27:31 <hpc> haha
12:27:38 <roconnor> :/
12:27:38 <Nibble> hpc: I don't understand your tho
12:27:48 * hackagebot vty 4.4.0.0 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.4.0.0 (CoreyOConnor)
12:28:00 <maurer_> Does anyone know if it's possible to build a binary version of a cabal package?
12:28:03 <roconnor> > find (\x -> let s = show (2^x) in length s >= 4 && x!!4 == '7') [0..]
12:28:04 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
12:28:04 <lambdabot>    arising from a use ...
12:28:14 <hpc> map f $ [1..] makes a list of things that have a certain property (being a power of three)
12:28:14 <Veinor> > find (\x -> reverse (show (2^x)) !! 3 == '7') [10..]
12:28:15 <lambdabot>   Just 21
12:28:18 <roconnor> > find (\x -> let s = show (2^x) in length s >= 4 && s!!4 == '7') [0..]
12:28:18 <lambdabot>   *Exception: Prelude.(!!): index too large
12:28:26 <hpc> filter g removes elements that don't have a certain property
12:28:50 <Nibble> hpc: I know what filter does
12:28:50 <chrisdone> I think of it as "keeps the ones that do"
12:28:52 <maurer_> I have a target machine where due to a bunch of nonsense, it's near impossible for me to get LLVM, and I would like to build cabal package llvm locally, producing a static library, then ship it to the other machine.
12:28:56 <chrisdone> double negatives are confusing :p
12:28:59 <Veinor> roconnor: odd, that should short-circuit
12:29:01 <Nibble> hpc: I meant more like, you didn't define g
12:29:18 <dcoutts_> maurer_: of course, you just build and then do copy --destdir=image, then tar up the image directory. That's a binary.
12:29:28 <Veinor> :t \x -> reverse (show (2^x)) !! 3 == '7'
12:29:29 <lambdabot> forall b. (Integral b) => b -> Bool
12:29:33 <Veinor> @pl \x -> reverse (show (2^x)) !! 3 == '7'
12:29:33 <lambdabot> ('7' ==) . (!! 3) . reverse . show . (2 ^)
12:29:47 <dcoutts_> maurer_: I mean: cabal copy --destdir= 
12:29:51 <Feuerbach> find (\x -> (2^x) `div` 1000 `mod` 10 == 7) [0..]
12:29:56 <maurer_> dcoutts_: Ah. Didn't know about cabal copy
12:29:57 <Feuerbach> > find (\x -> (2^x) `div` 1000 `mod` 10 == 7) [0..]
12:29:58 <lambdabot>   Just 21
12:30:02 <Nibble> what package is find in?
12:30:09 <roconnor> which side is right?
12:30:13 <chrisdone> Prelude/Data.List
12:30:20 <chrisdone> might not be in Prelude, can't remember
12:30:25 <Veinor> @info find
12:30:25 <lambdabot> find
12:30:26 <chrisdone> no, it's not
12:30:29 <dcoutts_> maurer_: note that will not help you with the llvm problem though
12:30:32 <chrisdone> @hoogle find
12:30:32 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
12:30:32 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
12:30:32 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
12:30:41 <geheimdienst> @help info
12:30:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:30:44 <maurer_> dcoutts_: Why not? Shouldn't it statically link in my llvm library?
12:30:47 <dcoutts_> maurer_: because the Haskell llvm package still needs to be linked with the llvm C libs.
12:31:06 <maurer_> dcoutts_: That was the idea--I wanted to compile them, link them, then send it over.
12:31:19 <dcoutts_> maurer_: if you make an executable that is statically linked then that's a different matter, but libs themselves do not contain all the other things they depend on
12:31:43 <maurer_> Unfortunate.
12:32:13 <maurer_> I guess it's back to trying to figure out how I can make an fc3 machine build llvm  :/
12:32:36 <dcoutts_> maurer_: it'd be pretty much equivalent to just copying over the llvm .a libs anyway
12:33:08 <maurer_> dcoutts_: Minus the trouble of managing to trick the llvm(haskell) configure scripts into finding it, and finding the headers
12:33:36 <dcoutts_> maurer_: well I mean it'd be equivalent to copying both the build llvm Haskell lib and the C lib
12:33:46 <maurer_> Sure.
12:33:48 <dcoutts_> built
12:36:56 <Nibble> dumb question incoming
12:37:06 <Nibble> what is the difference between div and /?
12:37:12 <ezyang> :t (/) 
12:37:13 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:37:15 <ezyang> :t div 
12:37:16 <lambdabot> forall a. (Integral a) => a -> a -> a
12:37:17 <Nibble> oh
12:37:39 <ezyang> "Yay types!" 
12:37:41 <Zao> @instances Fractional
12:37:42 <Zao> @instances Integral
12:37:43 <lambdabot> Double, Float
12:37:44 <lambdabot> Int, Integer
12:39:01 <kmc> div truncates
12:39:06 <kmc> > 7 `div` 2
12:39:07 <lambdabot>   3
12:39:10 <kmc> > 7 `quot` 2
12:39:11 <lambdabot>   3
12:39:16 <kmc> > (-7) `div` 2
12:39:17 <lambdabot>   -4
12:39:18 <kmc> > (-7) `quot` 2
12:39:19 <lambdabot>   -3
12:49:14 <edon> what's the neatest way to write a function that has 5 patterns that could match and the right side of all is the same ?
12:51:43 <byorgey> edon: do the patterns bind any variables?
12:51:47 <Feuerbach> edon: I'd deconstruct it into an "extractor" and "consumer"
12:51:59 <edon> byorgey: yes
12:52:06 <Feuerbach> where consumer is the "same right hand side"
12:52:21 <byorgey> hrm, I'd have to see the code
12:52:54 <Feuerbach> and extractor looks like case e of { Add x y -> (x,y); Mul x y -> (x,y) } etc.
12:53:39 <Feuerbach> or maybe just implement a fold over your data type
12:53:39 <edon> something like a "where" clause for all the function definition lines
12:54:05 <Feuerbach> nope, I don't think this is possible
12:54:45 <notabel> edon: if you toss the code up on hpaste or something, we can look at it and help more effectively
12:54:49 <Feuerbach> rather, I'm quite sure this is impossible :)
13:00:26 <benmachine> edon: function a b c d e = case (a, b, c, d, e) of blah -> rhs vars; blee -> rhs vars; where rhs vars = bloop
13:00:29 <benmachine> is a crude way
13:04:59 * hackagebot crypto-api 0.0.0.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.0.0.1 (ThomasDuBuisson)
13:16:02 * hackagebot asn1-data 0.1 - ASN1 data reader/writer in RAW/BER/DER/CER forms  http://hackage.haskell.org/package/asn1-data-0.1 (VincentHanquez)
13:22:04 * hackagebot cryptocipher 0.1 - Symmetrical Block and Stream Ciphers  http://hackage.haskell.org/package/cryptocipher-0.1 (VincentHanquez)
13:22:06 * hackagebot sqlite 0.5.1 - Haskell binding to sqlite3  http://hackage.haskell.org/package/sqlite-0.5.1 (AdamWick)
13:27:41 <telephone> How do I write module headers to use by haddock? I found no doc for that.
13:28:57 <blueonyx> -- |my module header \nmodule Foobar where, seems to work for me
13:31:27 <tehgeekmeister> i'mma re ask a question i asked earlier, maybe someone in here now knows: this is not a haskell question, but i figure this is the best place to ask: does anyone know of tools/extensions to other languages (ruby or python preferably) that allow you to check if your code is total?  i am tired of simple errors based on not considering some case accidentally.  would be nice if i could programmatically check for these problems.  and i can't switch t
13:31:28 <tehgeekmeister> haskell since it's for work.
13:32:46 <danderson> formulated like that, you want a solver for a superset of the halting problem (infinite loops being a class of errors)
13:33:20 <telephone> If I read source code for xmonad, I see fields like 'Module : ...', 'Copyright : ...', which seems to be recognized by haddock. I found no doc for such headers
13:33:30 <danderson> if you specify a language, you may be able to find tools for said language
13:33:52 <danderson> but unless it's at least as careful as haskell with handling side-effects, it'll be very difficult to prove anything
13:33:59 <tehgeekmeister> figured.
13:35:06 <tehgeekmeister> i find about half of the bugs i'm dealing with at work are things that couldn't have happened at all in haskell
13:35:12 <tehgeekmeister> actually, probably more
13:35:25 <tehgeekmeister> makes me wish i had the choice to switch languages
13:35:32 <Feuerbach> tehgeekmeister: that's what we love it for
13:36:30 <tehgeekmeister> like referencing a parameter in an http request that wasn't set?  in haskell web frameworks you get a maybe when you look up from the params, so you're nearly forced to handle both cases.  (of course, you could use fromJust or somesuch, but...)
13:37:17 <tehgeekmeister> in ruby it throws an exception at runtime
13:37:45 <sm> which makes it obvious.. fromJust is one of those on the "bad" list
13:38:18 <Feuerbach> sm: no, it has its applications
13:38:34 <sm> sure, but in general it should make you think
13:38:37 <tommd> Just like "fromRight" has its applications, though they are few enough that it doesn't exist.
13:38:57 <tehgeekmeister> i can't think of an application where pattern matching wouldn't solve it just as well
13:39:03 <notabel> tommd: i find myself defining fromLeft and fromRight in ghci all the time
13:39:18 <sm> often enough I use it where it's safe, but I can see that when someone refactors that code, it may be easy for them to miss and they'll break the safey
13:39:21 <sm> safety
13:39:30 <tehgeekmeister> notabel: for what purpose?
13:39:30 <c_wraith> notabel: in ghci, why not just use patterns in your name bindings?
13:39:31 <sm> and by someone I mean me
13:39:43 <notabel> usually when dealing with things returning IO (Either IOError a) for some a
13:40:03 * tehgeekmeister wishes every language strongly encouraged total functions.  (or made them necessary.)
13:40:04 <c_wraith> so...  Right blah <- expression
13:40:12 <tommd> notabel: So if you're ok with an exception... yeah, what c_wraith just said.
13:40:12 <Feuerbach> > fromJust $ find (\x -> x^2+1 > 1000) [1..] -- I know you exist!
13:40:13 <lambdabot>   32
13:40:17 <tehgeekmeister> (even if you throw an error in some case, handle every case.)
13:41:26 <notabel> c_wraith: so, the reason i don't do that is frequently i can tell whether i got the error value after running the action, but before stripping the either.  that is, i don't know before i run the action whether i got the error, but due to side-effects, i can tell whether the action returned an error before i actually unwrap the either
13:41:27 <tehgeekmeister> notabel: that's a reasonable usage, you already have an exception, makes sense to let it go to the top level, depending on context.
13:42:59 <tehgeekmeister> anyone know if much has been happening with epigram (or similar languages) lately?
13:43:05 <tehgeekmeister> it seemed to be a dead project when i looked last
13:44:16 * hackagebot certificate 0.1 - Certificate and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.1 (VincentHanquez)
13:45:33 <robogeoff> class Neighbor n where
13:45:33 <robogeoff>   neighbors :: n -> [n]
13:45:34 <robogeoff>   
13:45:35 <robogeoff> instance Enum a => Neighbor a where
13:45:35 <robogeoff>   neighbors x = [pred x,succ x]
13:45:38 <robogeoff> why doesn't that work?
13:46:01 <copumpkin> tell us the error and we'll tell you what it means
13:46:11 <mauke> the head is too big
13:46:16 <robogeoff>    Illegal instance declaration for `Neighbor a'
13:46:16 <robogeoff>         (All instance types must be of the form (T a1 ... an)
13:46:17 <robogeoff>          where a1 ... an are type *variables*,
13:46:17 <robogeoff>          and each type variable appears at most once in the instance head.
13:46:17 <robogeoff>          Use -XFlexibleInstances if you want to disable this.)
13:46:18 <robogeoff>     In the instance declaration for `Neighbor a'
13:46:32 <copumpkin> it's what mauke said
13:46:39 <copumpkin> it's an undecidable instance
13:46:48 <mauke> robogeoff: uh, it tells you why that doesn't work AND how to fix it
13:47:02 <robogeoff> right
13:47:03 <notabel> tehgeekmeister: it looks pretty live to me: http://www.e-pig.org/epilogue/
13:47:05 <copumpkin> robogeoff: also, please don't paste straight into the channel
13:47:06 <c_wraith> I really wish ghc did whole-program analysis to determine when those instances were sane and when they aren't.
13:47:17 <copumpkin> tehgeekmeister: epigram is very active
13:47:22 <robogeoff> oh sure, sorry
13:47:26 <robogeoff> how do i paste code?
13:47:42 <c_wraith> @where hpaste
13:47:42 <lambdabot> http://hpaste.org/
13:47:46 <bss03> haste.org?
13:47:49 <robogeoff> so, i guess i don't understand why it doesn't work without flexible instances
13:48:04 <bss03> Me neither.
13:48:13 <tehgeekmeister> wheeeeeeee.  guess i might start playing with it soon.
13:48:14 <c_wraith> robogeoff, because you're declaring the instance for all types a.  It doesn't consider the Enum constraint at that point.
13:48:26 <robogeoff> oh
13:48:27 <robogeoff> hmm
13:48:33 <c_wraith> Because, after all, any type might be given an enum constraint in some other file
13:48:37 <robogeoff> how do i tell it to do that?
13:48:47 <robogeoff> but it will always have pred and succ
13:48:49 <robogeoff> right?
13:48:51 <c_wraith> yes
13:48:51 <robogeoff> and that is all i am using
13:49:09 <c_wraith> Just turn on the option it suggests.
13:49:10 <sm> how could it be that I cabal install a particular package, named hledger-web; it succeeds, the binary is installed in ~/.cabal/bin, but the package does not show up in ghc-pkg list ?
13:49:29 <c_wraith> sm: if it's a binary only, no libs, ghc-pkg knows nothing about it
13:49:41 <sm> ahh! indeed, thanks
13:50:53 <tommd> @hackage crypto-api
13:50:53 <lambdabot> http://hackage.haskell.org/package/crypto-api
13:52:00 <Olathe> @hoogle unsafePerformIO
13:52:00 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:52:00 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:52:29 <dcoutts__> sm: ghc-pkg records libraries, presumably hledger is a program and not a library.
13:52:33 <copumpkin> dons: is it possible to ban people from haskell-cafe?
13:52:45 <dcoutts__> sm: oh sorry, I see c_wraith answered already
13:52:50 <copumpkin> jeff rubard occasionally posts nonsense on there and has never contributed anything meaningful
13:53:09 <c_wraith> dcoutts__, no worries, always nice to have word from the authority on the topic, too. :)
13:53:10 <dcoutts__> copumpkin: usual protocol is to talk to them privately first
13:53:25 <sm> yup that was it.. splitting up packages here
13:53:45 <copumpkin> dcoutts__: have you seen what he's been writing? :P
13:54:02 <copumpkin> http://snapplr.com/zjfk
13:54:12 <c_wraith> oh, hmm.  That is pretty bad
13:54:26 <copumpkin> http://snapplr.com/mjd8
13:54:29 <copumpkin> there are four emails from him
13:54:29 <dcoutts__> copumpkin: heh
13:54:34 <copumpkin> none of them make any sense whatsoever
13:54:38 <monochrom> the zjfk one is funny, not bad.
13:54:49 <c_wraith> "Do U like combinatory logic - or lambda calculus? It still matters, or something."
13:54:54 <dons> copumpkin: yes. 
13:55:00 <monochrom> oh, "whussup" is completely redundant.
13:55:07 <copumpkin> http://snapplr.com/n5ns
13:55:13 * copumpkin shrugs
13:55:22 <copumpkin> just looks like a weak troll attempt to me
13:55:32 <copumpkin> mocking what he considers our technical language
13:55:37 <copumpkin> but who knows
13:55:51 <monochrom> 4 emails is not enough to ban
13:55:58 <copumpkin> fair enough
13:56:20 <robogeoff> so i am trying to say that if a is an instance of Enum, then it is also an instance of Neighbor
13:56:37 <roconnor> robogeoff: that can't be done in Haskell 98
13:56:58 <robogeoff> really?  that is so weird
13:57:13 <robogeoff> what does => mean in Haskell 98>
13:57:15 <roconnor> robogeoff: I think there is a reason for it
13:57:20 <Olathe> How would I ensure that Debug.Trace's trace flushes stderr if the program can be terminated suddenly?
13:57:39 <mauke> Olathe: I'm pretty sure stderr is unbuffered by default
13:57:50 <roconnor> robogeoff: It prevents having overlapping instances
13:57:57 <monochrom> if stderr goes to some tty, line-buffered initially
13:58:09 <mauke> monochrom: really?
13:58:13 <monochrom> I forgot what happens otherwise.
13:58:18 <mauke> that sounds very broken
13:58:19 <robogeoff> hmm, ok thanks
13:58:19 <monochrom> yes, really
13:58:22 <Olathe> I've manually set it to NoBuffering, but it still only gets two characters out.
13:58:38 <Olathe> That's with it being killed one second after trace runs.
13:59:32 <mauke> monochrom: you're wrong
13:59:32 <roconnor> robogeoff: suppose you have Enum a => Neighbor a.   Then you make Neighbour Foo.  where Foo isn't an instance of Enum.  This is fine
13:59:43 <mauke> it's NoBuffering in both cases
13:59:49 <monochrom> alright
13:59:51 <roconnor> robogeoff: then suddenly someone adds an Enum instance for Foo, now you have two (different) instances of Neighbor Foo
14:01:36 <monochrom> I can't spell cabal. I type cabel or cable.
14:02:45 <BONUS> robogeoff: thing is, you don't actually gain anything by doing this
14:03:34 <BONUS> its best to just write the functions you'd have in Neighbor as normal functions
14:03:54 <BONUS> and in them you have an Enum type class constraint, e.g. Enum a => ...
14:04:20 <monochrom> > let x |-| y = x++y in "hi" |-| " you"
14:04:21 <lambdabot>   "hi you"
14:04:29 <EvanR-work> is there a 'standard' -- operator, oh wait, thats comments
14:04:30 <aristid> the H operator.
14:04:35 <monochrom> > let x --- y = x++y in "hi" --- " you"
14:04:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:04:44 <revenantphx> copumpkin: ATTN
14:04:46 <monochrom> hrm!
14:04:46 <EvanR-work> lam
14:04:46 <EvanR-work> e
14:04:54 <revenantphx> I spliced new function into a block... phase 1 is complete.
14:04:57 <revenantphx> So I have that working :D
14:05:00 <medfly> > let x
14:05:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:05:01 <robogeoff> oh, i see
14:05:03 <robogeoff> i think
14:05:07 <robogeoff> hmm let me try it
14:05:10 <Olathe> You know, it's weird that --== isn't a comment.
14:05:16 <Olathe> Does anyone know why?
14:05:24 <mauke> because it's an operator
14:05:27 <robogeoff> thanks roconnor and BONUS, i appreciate the help!
14:05:36 <Olathe> > test --++
14:05:37 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:05:40 <Olathe> Ahh, OK.
14:05:46 <c_wraith> --anyoperatorcharacter isn't a comment
14:05:47 <monochrom> "An ordinary comment begins with a sequence of two or more consecutive dashes" yikes, --- is comment
14:05:58 <c_wraith> oh.
14:06:06 <Olathe> Thanks :)
14:06:08 <EvanR-work> so -- cant appear anywhere in an operator
14:06:11 <c_wraith> wow, ok, I was wrong and am now horrified
14:06:17 <c_wraith> EvanR-work, sure it can.
14:06:23 <monochrom> I'm horrified too. :)
14:06:30 <monochrom> I want my --- back!!!11!!!
14:06:38 <c_wraith> > let x --& y = x + y in 5 --& 7
14:06:39 <lambdabot>   12
14:06:45 <EvanR-work> but, but
14:07:06 <Veinor> > let x &-- y = x + y in 2 &-- 3
14:07:07 <lambdabot>   5
14:07:11 <maurer_> Is there a way to add a custom directory similar to the per-user .ghc folderto a compile?
14:07:14 <Veinor> > let x --- y = x + y in 2 --- 3
14:07:14 <roconnor> --o  -- lolipop operator
14:07:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:07:15 <monochrom> EvanR-work: the next sentence is "The sequence of dashes must not form part of a legal lexeme."
14:07:29 <Veinor> wat
14:07:32 <Olathe> @hoogle Int -> a -> [a]
14:07:32 <lambdabot> Prelude replicate :: Int -> a -> [a]
14:07:33 <lambdabot> Data.List replicate :: Int -> a -> [a]
14:07:33 <lambdabot> Prelude drop :: Int -> [a] -> [a]
14:07:36 <aristid> :t let (--o)=undefined in undefined
14:07:37 <lambdabot> parse error (possibly incorrect indentation)
14:07:39 <monochrom> And the sentence after next has examples.
14:08:44 <monochrom> > let x â€“ y = x++y in "hi" â€“ " there"
14:08:45 <lambdabot>   "hi there"
14:09:03 <monochrom> > let x â€“ y = x++y in ("hi" â€“ " there", 3-1)
14:09:04 <lambdabot>   ("hi there",2)
14:09:07 <monochrom> hehe!
14:09:26 <c_wraith> fortunately, my font renders those *slightly* differently :)
14:09:32 <bss03> My font does too.
14:09:49 <bss03> en-dash v. hypen-minus.
14:15:57 <monochrom> > let n -. v = n ++ "-" ++ v in "base" -. "4.2.0.0"
14:15:58 <lambdabot>   "base-4.2.0.0"
14:16:06 <monochrom> is what I want
14:16:12 <jeltsch> > let a â€¢ b = a ++ b in "abc" â€¢ "def"
14:16:13 <lambdabot>   "abcdef"
14:16:17 <jeltsch> Nice.
14:16:40 <jeltsch> let Ï€ = pi in Ï€
14:16:52 <jeltsch> > let Ï€ = pi in Ï€
14:16:53 <lambdabot>   3.141592653589793
14:16:58 <jeltsch> dto. :-) 
14:17:24 <jeltsch> let âˆž = fix succ in âˆž
14:17:31 <jeltsch> > let âˆž = fix succ in âˆž
14:17:32 <lambdabot>   <no location info>: parse error on input `âˆž'
14:17:32 <aristid> :t fix succ
14:17:33 <lambdabot> forall a. (Enum a) => a
14:17:36 <jeltsch> Ok.
14:17:42 <aristid> :t fix (+1)
14:17:43 <lambdabot> forall a. (Num a) => a
14:17:52 <c_wraith> > 1 :: Natural
14:17:52 <lambdabot>   Not in scope: type constructor or class `Natural'
14:18:00 <aristid> jeltsch: lazy naturals to the rescue!
14:18:12 <jeltsch> In Agda, âˆž could be used for ordinary values â€¦
14:18:13 <c_wraith> Too bad they aren't in \bot anymore
14:18:42 <jeltsch> aristid: This was only to check that âˆž cannot be treated as an identifier.
14:19:16 <aristid> jeltsch: still :P
14:19:35 <aristid> :et let (âˆž) = 1 in (âˆž)
14:19:40 <aristid> :t let (âˆž) = 1 in (âˆž)
14:19:41 <lambdabot> forall t. (Num t) => t
14:19:55 <aristid> lol, treating âˆž as an operator is weird
14:20:31 <jeltsch> > let ð¤’ = "This is a phoenician letter." in ð¤’
14:20:32 <lambdabot>   "This is a phoenician letter."
14:20:37 <jeltsch> Cool. :-) 
14:20:55 <jeltsch> So ð¤’ is definitely a small letter. :-D 
14:21:06 <revenantphx> huh, that letter isnt even in UTF8
14:21:15 <aristid> revenantphx: yes it is.
14:21:17 <copumpkin> UTF8 is an encoding
14:21:18 <aristid> i can read it
14:21:20 <revenantphx> unless it's a box.
14:21:27 <aristid> revenantphx: you just are missing fonts.
14:21:30 <revenantphx> yeah
14:21:30 <copumpkin> revenantphx: it just means you don't have a font with the glyph for it
14:21:32 <revenantphx> I see now
14:21:43 <revenantphx> ð¤’this is it? 
14:21:47 <monochrom> you should say "isn't in unicode"
14:21:47 <c_wraith> yes
14:21:51 <revenantphx> It looks like a little thing inside a box?
14:21:55 <revenantphx> brb
14:21:56 <aristid> no.
14:22:02 <aristid> it looks like a beautiful letter
14:22:05 <revenantphx> > >
14:22:06 <lambdabot>   <no location info>: parse error on input `>'
14:22:07 <revenantphx> image?
14:22:30 <monochrom> look for U+10912
14:23:22 <monochrom> current ubuntu has its font out of the box.
14:23:55 <revenantphx> I don't know what font you're using though
14:24:14 <revenantphx> this?
14:24:28 <revenantphx> er, it looks like a merged P and S?
14:24:31 <revenantphx> it's very pretty
14:24:50 <adnap> Can someone point me toward a useful tutorial that describes how to write a simple program using hscurses?
14:24:54 <jeltsch> revenantphx: http://www.unicode.org/charts/PDF/U10900.pdf
14:25:37 * hackagebot dephd 0.1.4 - Analyze quality of nucleotide sequences.  http://hackage.haskell.org/package/dephd-0.1.4 (KetilMalde)
14:26:09 <medfly> pdf?
14:27:10 <aristid> medfly: yes, pdf.
14:28:58 <medfly> YES. PDF.
14:29:01 <medfly> okay, g'night
14:30:20 <monochrom> I'm using the font called "Serif"
14:30:38 <monochrom> sometimes I use "Sans" or "Monospace"
14:31:43 <tommd> Wow, todays the day for crypto + haskell it seems.  ASN1, CryptoCipher, Crypto-API, Certificate...
14:35:57 <Olathe> @hoogle exit
14:35:59 <lambdabot> module System.Exit
14:36:01 <lambdabot> System.Exit data ExitCode
14:36:01 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
14:38:56 <benmachine> @hoogle exitWith
14:38:58 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
14:48:26 <ezyang> Are there existing implementations of data subtyping? 
14:49:02 <ezyang> For example, I have data Foo = Foo { foo :: Int } and Bar = Bar { foo :: Int, bar :: Int }, letting me use foo on Foo and Bar. 
14:49:09 <ezyang> (obviously that's invalid syntax) 
14:49:35 <dobblego> ezyang, see type-classes
14:49:54 <monochrom> usually we type-class foo.
14:50:29 <monochrom> there is also: data FooBar = Foo{foo::Int} | Bar{foo::Int, bar::whatever|
14:50:34 <monochrom> s/|/}
14:51:01 <ezyang> Hmm, ok. 
14:52:44 <copumpkin> -XDisambiguateRecordFields
14:53:38 <copumpkin> and put them in different modules :P
14:53:45 <ezyang> Huh. 
14:54:07 <monochrom> -XTypeDirectedTypeInference
14:54:15 <copumpkin> With -XDisambiguateRecordFields you can use unqualifed field names even if the correponding selector is only in scope qualified 
14:54:47 <fffej> currently I have two types data Foo = A | B | C and data Bar = D | E | F.  I've got a function that takes a foo and bar, but it's only applicable for some instances of bar.  Is there a cunning way to express this constraint without writing hundreds of little functions?
14:54:59 <ezyang> That's so weird :-) 
14:55:35 <monochrom> there are too many foos and bars
14:55:40 <notabel> monochrom: did you meant TypeDirectedNameResolution (which unfortunately doesn't exist)?  or is TypeDirectedTypeInference a real thing?
14:55:47 <monochrom> -XTypeDirectedFooBarResolution
14:55:59 <monochrom> it is a joke
14:56:19 <notabel> kk
14:56:34 <monochrom> "to infer types, first infer types for direction"
14:56:34 <maurer_> If I "fail" in the IO monad, can I catch that and handle it somewhere, or will it just take the program down hard?
14:57:19 <monochrom> I mock -XTypeDirectedWhatever
14:58:03 <monochrom> there is a way to catch that as an exception
14:58:21 <benmachine> it throws an IOError I think
14:58:29 <telephone> How do I uninstall a installed cabal package?
14:58:48 <telephone> The package is locally installed
14:58:59 <Zao> telephone: Judicious use of rm, ghc-pkg unregister.
14:59:15 <byorgey> telephone: ghc-pkg unregister --user packagename
14:59:18 <monochrom> yes, it's the "userError" case of IOError or IOException
15:00:08 <monochrom> main = do { fail "success!"; putStrLn "fail" }
15:00:28 <maurer_> monochrom: OK, I'll go look at the exception stuff. (Unless there's a better way for me to encapsulate a computation in IO that can fail that I should be using instead.)
15:01:31 <telephone> byorgey, Zao: My package is just an executable, so there is just to use 'rm' in '~/.cabal/bin' and '~/.cabal/share'?
15:02:34 <monochrom> System.IO.Error sufficies
15:13:33 <chemuduguntar> why doesn't this work
15:13:35 <chemuduguntar> a = 1
15:13:44 <kmc> at the top level of a file?
15:13:46 <kmc> or in ghci?
15:13:54 <kmc> a better question is: why do you think it should work?
15:13:55 <chemuduguntar> ghci and helium :(
15:14:06 <kmc> you probably want: let a = 1
15:14:19 <chemuduguntar> cool
15:14:22 <kmc> statements you type into GHCi are interpreted in the context of an IO "do" block
15:14:25 <kmc> not a top-level file
15:14:31 <kmc> for example, you can't define new types with "data" in GHCi
15:14:50 <chemuduguntar> ah ok
15:15:40 <chemuduguntar> i have no idea what a do block is ... so i think i
15:15:46 <chemuduguntar> 'll use files
15:15:55 <kmc> that might be best
15:16:05 <kmc> but also, you can just use "let a = 1" style in GHCi for now
15:16:18 <kmc> and worry later about what exactly is going on
15:16:31 <kmc> when you want to learn about how IO works, see: http://haskell.org/haskellwiki/Introduction_to_IO
15:16:44 <kyagrd> What would be a proper citation for Indirect composite? http://haskell.org/haskellwiki/Indirect_composite other than this wiki page? 
15:17:14 <kmc> kyagrd, ISTR a mailing list post by SPJ (?) with that trick
15:17:19 <kmc> sorry i don't have more details
15:17:31 <chemuduguntar> cool
15:17:50 <yitz> kyagrd: top hit on google is http://www.dentalblogs.com/archives/karl/direct-vs-indirect-composite-resins/
15:19:03 <yitz> nothing like google as a replacement for the semantic web
15:26:57 <kyagrd> When writing articles or papers targeted to non-functional community there are idioms needing explaination or citation, which is so obvious in functional community since it has been around long time ...
15:27:16 <aristid> kyagrd: for example?
15:27:28 <kyagrd> Indirect composite I just mentioned
15:28:16 <kmc> i don't think that one is terribly obvious
15:28:44 <kyagrd> kmc, I know but it doesn't have a functional peral paper either :)
15:28:54 <kyagrd> I mean pearl
15:30:13 <revenantphx> perl?
15:30:19 <Veinor> > fix error
15:30:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:30:39 <c_wraith> no, "functional pearls" is a series of papers on solving interesting problems in functional ways
15:30:44 <revenantphx> oh I see.
15:31:25 <kmc> there are papers on functional perl ;)
15:32:35 <revenantphx> hm
15:32:50 <revenantphx> i'm having trouble getting ghc to compile exported functions
15:33:15 <revenantphx> like foreign export and such
15:34:39 <kmc> what's the trouble?
15:34:46 <revenantphx> lemme try it again here....
15:35:16 <revenantphx> exported.hs:3:0: Invalid type signature
15:35:19 <revenantphx> for this
15:35:20 <revenantphx> foreign export ccall foo :: Int -> IO Int
15:35:34 <revenantphx> thats straight from here
15:35:34 <revenantphx> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ffi-ghc.html
15:35:39 <kmc> hpaste the file?
15:35:46 <revenantphx> its identical to the one on that link
15:35:47 <revenantphx> the first file
15:35:59 <kmc> did you enable the ForeignFunctionInterface extension?
15:36:08 <revenantphx> no... how do I do that?
15:36:25 <revenantphx> some -X flag?
15:36:29 <kmc> there are several ways to enable extensions
15:36:34 <kmc> -XFoo on  the command line
15:36:42 <kmc> {-# LANGUAGE Foo #-} at the top of your file
15:36:43 <revenantphx> I just found "-XForeignFunctionInterface"
15:36:44 <kmc> or cabal
15:37:04 <mauke> ghc -ï¬ƒ
15:37:09 <kmc> haha
15:37:28 <revenantphx> where can I find the definitions for HSInt?
15:38:21 <revenantphx> in other words, where is HsFFI found?
15:42:02 <ezyang> What is the earliest version of Windows GHC supports? 
15:42:38 <ezyang> looks like 2000... 
15:43:15 <kyagrd> ezyang: including cygwin it goes back quite early
15:43:23 <kyagrd> http://www.haskell.org/ghc/download_ghc_210.html
15:44:36 <kyagrd> My first try on GHC was 4.x which did have windows 9x/NT support
15:44:52 <aristid> ghc 2.10?!?!
15:45:12 <ezyang> Heh. I'm hacking on 6.13 so I don't really care about 2.10 :-) 
15:46:12 <Igloo> Yes, 2000, XP and Vista are supported. And I guess 7 now too.
15:47:34 <revenantphx> kmc: It's complaining for lack of HsFFI.h
15:47:39 <revenantphx> and I don't know where to find it
15:47:44 <revenantphx> i've been looking fruitlessly.
15:48:21 <revenantphx> it also wants Rts.h and Stg.h and such...
15:48:29 <revenantphx> though those are in the compiled object.
15:49:02 <kmc> mine's at /usr/lib/ghc-6.12.1/include/HsFFI.h
15:49:12 <kmc> revenantphx, ghc can be invoked as a c compiler
15:49:20 <kmc> and it will pass the right flags to gcc or whatever
15:49:46 <revenantphx> well, I'm not compiling with ghc
15:49:55 <revenantphx> this is me splicing haskell stubs into apple blocks, remember?
15:50:03 <kmc> then you will have to pass whatever -I flag
15:50:08 <revenantphx> I'll just add the proper flag
15:50:10 <revenantphx> thanks
16:02:18 <cwb> Anyone has experience using the state monad to cache values of a computation? I'm getting stack overflows and I feel I must be missing something obvious..?
16:02:43 <benmachine> cwb: first thing to try is changing your import to Control.Monad.State.Strict
16:03:17 <benmachine> see if that helps
16:03:18 <cwb> benmachine: Done that -- it helps in that it gets me to the stack overflow quicker..
16:03:22 <benmachine> hah
16:03:45 <dons> some kind of logical error   then
16:03:47 <benmachine> cwb: well, can we see the code?
16:05:53 <Cale> cwb: Are you making frequent use of the values that you're collecting up?
16:05:54 <cwb> benmachine: Sorry, can't boil it down to a simple example..
16:06:02 <cwb> I'm threading the state through a lot of function calls, so I can kind of see that there's a lot of stack-space required, but I would have thought there's some way around that.
16:06:18 <benmachine> cwb: haskell uses stack in a strange way
16:06:43 <cwb> Cale: Not using it at all -- just wanted to try it so am simply printing the initial state after running the computation.
16:06:46 <Cale> cwb: It's important that contrary to what the stack usually represents in a strict evaluator, the GHC stack effectively represents case expressions (or other pattern matches) which are waiting for their scrutinee to be sufficiently evaluated that they can match.
16:08:04 <Cale> cwb: This usually happens when you build up a large unevaluated expression composed of strict functions and then try to evaluate it all at once.
16:08:06 <cwb> Any ideas about what kind of things should I be looking at "fixing" / learning about to maybe solve this?
16:08:32 <kmc> the strict state monad only forces to weak head-normal form
16:08:36 <kmc> cwb, what is the type of your state?
16:08:52 <kmc> cwb, http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
16:08:52 <Cale> The strict state monad doesn't even force the state into WHNF
16:08:56 <kmc> oh?
16:09:02 <kmc> does it just force the LHS action?
16:09:12 <cwb> kmc: String while I'm trying things out..
16:09:13 <Cale> It only pattern matches the (state,value) pairs strictly
16:09:18 <Cale> inside of bind
16:09:26 <kmc> right i remember someone saying the only difference between Lazy and Strict was a ~ pattern
16:09:41 <kmc> cwb, and how are you building that String?
16:10:17 <Cale> cwb: So possibly the problem is that you need to ensure that the state is evaluated when you update it
16:10:17 <cwb> kmc: I'm not doing anything to it at the moment. Just putting it in at the start of the computation and taking it out at the end.
16:10:24 <kmc> odd
16:10:33 <Cale> cwb: So you're not just adding more onto an already complicated expression.
16:10:33 <kmc> you're not updating the state at all?
16:10:36 <Cale> hmm
16:10:52 <cwb> kmc: That's right. Just threading it through.
16:11:03 <kmc> strange
16:11:06 <kmc> can you hpaste your code?
16:12:17 <cwb> kmc: sorry.. can't boil it down to something manageable, but can hpaste the monad definitions in case I'm doing something stupid there (I'm new to this stuff).. Hold on.
16:13:27 <revenantphx> kmc: I have success!
16:13:36 <kmc> yay
16:13:43 <_linuxftw> Hi, I'm trying to map every other element in a list, and I've got this so far: "mapEveryOther f = zipWith ($) (intersperse id [(f:)])", but, it won't compile and I think it's because of my use of [f:], how else can I get an infinite list containing only f?
16:14:00 <kmc> _linuxftw, repeat f
16:14:12 <_linuxftw> perfect, that's what I was looking for, thanks
16:14:15 <kmc> [(f:)] is a list of only one element, not an infinite list
16:14:21 <mauke> cycle [f, id]
16:14:35 <_linuxftw> kmc: But if you do [1:] that makes an infinite list does't it?
16:14:36 <Cale> _linuxftw: zipWith id (cycle [f,id])
16:14:37 <_linuxftw> doesn't*
16:14:41 <kmc> :t \f -> zipWith ($) (cycle [f, id])
16:14:42 <lambdabot> forall b. (b -> b) -> [b] -> [b]
16:14:49 <kmc> _linuxftw, no
16:14:51 <kmc> [1..] does
16:14:54 <kmc> that's special syntax
16:14:59 <_linuxftw> oh.. yeah 
16:15:03 <kmc> [a..] is sugar for Â«enumFrom aÂ»
16:15:04 <_linuxftw> I'm new at this
16:15:04 <kmc> > enumFrom 3
16:15:05 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
16:15:07 <Cale> > cycle [1,2]
16:15:08 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
16:15:21 <Cale> > zipWith id (cycle [id, (*2)]) [1..]
16:15:21 <lambdabot>   [1,4,3,8,5,12,7,16,9,20,11,24,13,28,15,32,17,36,19,40,21,44,23,48,25,52,27,...
16:15:26 <Cale> > zipWith id (cycle [id, (*10)]) [1..]
16:15:27 <lambdabot>   [1,20,3,40,5,60,7,80,9,100,11,120,13,140,15,160,17,180,19,200,21,220,23,240...
16:16:47 <cwb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29804#a29804
16:17:58 <kmc> oh, you've got a ReaderT too?
16:18:25 <kmc> btw your definitions of runComp and return Comp are redundant; you can more cleanly define one in terms of the other
16:18:28 <cwb> kmc: Yes.. Sorry, maybe that's the problem?
16:18:30 <svk_> Ooh, "zipWith id" is clever
16:18:34 <kmc> cwb, i'm not sure
16:18:39 <kmc> :t zipWith id
16:18:40 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
16:18:48 <kmc> :t zipWith ($)
16:18:49 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
16:18:57 <kmc> after all ($) is just id with a restricted type
16:19:15 <kmc> (and low-precedence infix syntax)
16:19:20 <megajosh2> > take 10 $ zipWith id [1..] [2,4..]
16:19:21 <lambdabot>   No instance for (GHC.Enum.Enum (b -> a))
16:19:21 <lambdabot>    arising from a use of `e_110124...
16:19:37 <megajosh2> > take 10 $ zipWith id [1,2,3] [2,4,6]
16:19:37 <lambdabot>   [1,2,3]
16:19:42 <megajosh2> lol
16:19:52 <Cale> heh, numeric overloading :)
16:19:56 <Cale> > 1 5
16:19:56 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:19:57 <lambdabot>    `GHC.Num.Num t' arising f...
16:20:00 <Cale> > 1 5 :: Integer
16:20:00 <lambdabot>   1
16:20:08 <megajosh2> ..wait what?
16:20:22 <megajosh2> Two seperate integers became one?
16:20:30 <Cale> There's a Num instance for functions which makes numeric constants into constant functions
16:20:36 <megajosh2> Ah...
16:20:36 <cwb> kmc: could the nesting order matter? (Might StateT around a reader be better?)
16:20:43 <Cale> Imported from Data.NumInstances in the vector-space library
16:20:54 <Cale> > (cos + 1) 5
16:20:56 <lambdabot>   1.2836621854632262
16:21:09 <kmc> @unmtl ReaderT e (State s) a
16:21:09 <lambdabot> e -> s -> (a, s)
16:21:15 <kmc> @unmtl StateT s (Reater e) a
16:21:16 <lambdabot> s -> Reater e (a, s)
16:21:19 <kmc> durr
16:21:21 <kmc> @unmtl StateT s (Reader e) a
16:21:21 <lambdabot> s -> e -> (a, s)
16:21:28 <Cale> > (cos^2 + sin^2) 5
16:21:29 <lambdabot>   0.9999999999999999
16:21:37 * hackagebot crypto-api 0.0.0.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.0.0.2 (ThomasDuBuisson)
16:21:38 <aristid> @unmtl ReaderT a (ReaderT b) c
16:21:38 <lambdabot> err: `ReaderT b c' is not applied to enough arguments, giving `/\A. b -> c A'
16:21:39 <kmc> in general, monads don't commute, but Reader/ReaderT commutes with everything
16:21:47 <aristid> @unmtl ReaderT a (Reader b) c
16:21:47 <lambdabot> a -> b -> c
16:21:48 <yitz> > let onHead f (x:xs) = f x : xs; onEvens f = concatMap (onHead f . take 2) . takeWhile (not . null) . iterate (drop 2) in onEvens (*100) [1..9]
16:21:49 <lambdabot>   [100,2,300,4,500,6,700,8,900]
16:22:08 <megajosh2>  What's with the /\?
16:22:10 <cwb> kmc: So that shouldn't be the problem then..
16:22:15 <copumpkin> megajosh2: where?
16:22:18 <megajosh2> Is that a âˆ€?
16:22:23 <mauke> megajosh2: Î›
16:22:23 <copumpkin> no, it's a type-level lambda
16:22:28 <megajosh2> Oh, okay
16:22:29 <copumpkin> which is sort of forall
16:22:31 <megajosh2> Hmm...
16:22:36 <megajosh2> Never seen one before
16:22:40 <kmc> Î›
16:22:46 <kmc> it's not Haskell
16:22:47 <djahandarie> That's because they don't exist in Haskell
16:23:01 <megajosh2> Oh god
16:23:08 <megajosh2> Am I in the Twighlight Zone?
16:23:10 <wlangstroth> Is there such a thing as idiomatic Parsec usage, or are all these disparate examples I'm finding the norm?
16:23:10 <copumpkin> never seen that error before :)
16:23:15 <copumpkin> [01:21:14 AM] â€¹ lambdabot â€º err: `ReaderT b c' is not applied to enough arguments, giving `/\A. b -> c A'
16:23:44 <megajosh2> And then the compiler gave an error message about a NONEXISTANT FEATURE! *BOO*
16:23:56 <mauke> what compiler?
16:24:03 <mauke> also, existent
16:24:05 <djahandarie> unmtl has nothing to do with the GHC compiler, it's just some lambdabot plugin
16:24:29 <dmwit> ?seen conal
16:24:29 <lambdabot> Unknown command, try @list
16:24:35 <dmwit> preflex: seen conal
16:24:35 <preflex>  conal was last seen on #haskell 20 hours, 23 minutes and 9 seconds ago, saying: dmwit: cool.  catch you later.
16:25:17 <dmwit> ?ask conal Can you comment briefly on how Clock fits into the whole scheme? I'm still trying to wrap my brain around the IO - non-IO barrier of reactive-glut.
16:25:18 <lambdabot> Consider it noted.
16:25:37 <Cale> megajosh2: unmtl isn't a Haskell compiler
16:26:23 <Cale> megajosh2: It's just a device which unravels the Monad Transformer Library types and gives their underlying function representations.
16:26:43 <Cale> @unmtl State s a
16:26:43 <lambdabot> s -> (a, s)
16:26:48 <Cale> @unmtl State s
16:26:49 <lambdabot> err: `State s' is not applied to enough arguments, giving `/\A. s -> (A, s)'
16:26:56 <cwb> kmc, Cale: I'm going to try to restrict the state monad to a smaller part of the computation and see if that helps.. Thanks for the help though!
16:27:13 <dmwit> ack
16:27:17 <djahandarie> IRC fail
16:27:23 <megajosh2> Yuck
16:27:29 <Cale> cwb: Yeah, it's hard enough to diagnose stack overflows when you have the whole code in front of you :)
16:27:33 <Cale> What?
16:27:40 <Cale> IRC fail?
16:27:41 <kmc> is profiling any help for stack overflows?
16:27:49 <megajosh2> You don't see his text flashing?
16:27:50 <kmc> ISTR a RTS option to give you a profiling cost center trace on exceptions
16:27:52 <Cale> megajosh2: no
16:27:52 <djahandarie> cwb had some weird control character in that line
16:27:55 <kmc> megajosh2, i see a \006
16:27:58 <megajosh2> Hmm...
16:28:08 <Cale> yeah, that's what I see too, a block with 0006 in it
16:28:16 <djahandarie> My client inverted the text
16:28:24 <Cale> heh
16:28:35 <cwb> djahandarie: Sorry.. not sure why that happens -- Colloquy is playing tricks on my..
16:28:46 <djahandarie> cwb, nah, it's all good :P
16:28:54 <Cale> Oh, there is -xc
16:29:36 <Cale> You could try that, but it's better just to inspect the code and try to see where there are values which are being built up by strict functions but not evaluated until much later.
16:29:44 <cwb> Cale: Sorry, is there some profiling I should try?
16:30:13 <Cale> cwb: If you have no idea where an exception is occurring, you can try compiling with -prof -auto-all, and running the program with +RTS -xc
16:30:30 <cwb> Could the implicit state passing itself, the monad bindings I guess, cause the stack overflow?
16:30:32 <Cale> *sometimes* this will give a useful cost-centre trace (not a stack trace, and sometimes stupid)
16:30:56 <Cale> Not if you're using the strict state monad.
16:31:48 <cwb> Ok.
16:32:43 <megajosh2> > (read "const") 5
16:32:44 <lambdabot>   No instance for (GHC.Read.Read (t -> a))
16:32:44 <lambdabot>    arising from a use of `e_15' at...
16:32:56 <megajosh2> > (read "const") 5 5
16:32:57 <lambdabot>   No instance for (GHC.Read.Read (t -> t1 -> a))
16:32:58 <lambdabot>    arising from a use of `e_...
16:32:59 <cwb> Cale: +RTS -xc gives me a long list of functions; how should I interpret that?
16:33:01 <megajosh2> Meh
16:33:58 <Cale> cwb: Those are the functions to which the profiler was attributing time and memory usage at the time that the exception occurred.
16:34:14 <Cale> (what was running, essentially)
16:36:42 <cwb> Cale: Ok, that's actually helpful -- the innermost function is a somewhat odd recursive monad so looking at that sounds like a very sensible first step. That'll keep me busy tomorrow... Many thanks Cale!
16:37:22 <djahandarie> I swear MIT has the strangest hosts
16:37:32 <cwb> (or monadic function rather)
16:37:34 <kmc> probably they let any student register any domain
16:37:38 <kmc> Caltech does
16:38:13 <Veinor> yeah, you can get any domain you want iirc
16:38:30 <Veinor> "brain and cog" in this context stnads for "brain and cognitive sciences" I think though
16:38:31 <djahandarie> In that case MIT sure has a lot of strange students :P
16:38:41 <kmc> you don't say ;P
16:39:06 <Veinor> someone has fuck-the-skull-of-jesus
16:39:21 <djahandarie> Hahahaha
16:39:21 <kmc> we had student-run subdomains too
16:39:24 <kmc> so there was really no oversight
16:40:09 <Veinor> djahandarie: you know how I found that out? one of my computers used sin for a hostname, and when I did certain things they would come up as being from fuck-the-skull-of-jesus.mit.edu
16:40:34 <djahandarie> lol
16:40:53 <Veinor> because I guess sin and ftsoj are the same domain
16:41:48 <djahandarie> It seems to have existed since '98 so I imagine they know about it and just don't care
16:41:56 <megajosh2> Good god, pun intended
16:42:01 <kmc> saccade is a good nick for a brain-and-cog researcher ;)
16:42:21 <kmc> bad god, no biscuit
16:42:42 <Veinor> yeah
16:43:00 <dmwit> > 22500 / 12
16:43:01 <lambdabot>   1875.0
16:45:36 <tommd> Since 1998?  Either he's a PhD student or someone hid a laptop under a floor board and has enjoyed free hosting ever since.
16:45:52 <kmc> tommd, i know more than a few people who've done that at Caltech
16:46:10 <tommd> kmc: I was intentionally picking a real example.
16:46:16 <kmc> :)
16:46:19 <Veinor> tommd: certain people get permanent accounts
16:46:32 <kmc> there's a great benefit to keeping the academic IP for journal access, etc.
16:46:42 <tommd> And certain organizations don't expire MAC registrations... ever.
16:46:54 <kmc> MIT doesn't do MAC registration for wired network iirc
16:47:08 <Veinor> or wireless in certain places
16:47:17 <kmc> these days i'd go for a tiny solid-state machine, maybe a small router running OpenWRT, or beagleboard or gumstix or something
16:47:25 <kmc> you can hide that pretty much anywhere
16:48:04 <tommd> kmc: See you and raise you a Teensy ;-)
16:48:23 <kmc> hmm
16:48:32 <tommd> Why go for an ARM when you can pick a device with orders of magnitude less memory.
16:49:17 <kmc> you'll need Ethernet, and enough RAM for a decent buffer if you want to do port-forwarding efficiently
16:49:26 <wlangstroth> Jesus is a PhD student at MIT?
16:49:36 <wlangstroth> you're blowing my mind
16:49:42 <kmc> also the cheapest ARMs are quite cheap
16:52:15 <wlangstroth> So seriously, is there no love for Parsec 3?
16:53:46 * hackagebot HsTools 0.0.1.1 - Haskell helper functions  http://hackage.haskell.org/package/HsTools-0.0.1.1 (ChristianHoener)
16:55:09 <wlangstroth> man - here I thought I could only clear a room in real life.
16:56:47 * hackagebot Biobase 0.0.2.0 - Base library for bioinformatics  http://hackage.haskell.org/package/Biobase-0.0.2.0 (ChristianHoener)
16:57:48 * hackagebot BiobaseInfernal 0.0.2.0 - Infernal CM manipulation  http://hackage.haskell.org/package/BiobaseInfernal-0.0.2.0 (ChristianHoener)
17:01:49 * hackagebot CMCompare 0.0.1.1 - Infernal covariance model comparison  http://hackage.haskell.org/package/CMCompare-0.0.1.1 (ChristianHoener)
17:03:16 <copumpkin> wow, that package sounds like hell
17:04:31 * kmc rimshot
17:10:24 <Cale> computational biology
17:12:36 <tommd> Next years CUFP: Infernal uses of Haskell
17:13:40 <Cale> infeRNAl
17:14:07 <Olathe> Is there a reason why, if another program uses popen3 or something on a Haskell program, it won't output anything?
17:14:11 <Cale> (apparently)
17:14:44 <Cale> Ah: INFERence of RNA ALignment
17:15:02 <tommd> INFERRNAAL?
17:15:05 <Cale> Olathe: can't think of why that would be
17:15:24 <QtPlatypus> When I read in a CS text about "The fixed point theorem" which one are they talking about?
17:15:31 <kmc> Demonic Users of Functional Programming
17:15:40 <mornfall> QtPlatypus: Kleene/Tarski
17:15:42 <kmc> QtPlatypus, maybe Kleene's recursion theorem
17:15:45 <tommd> Blame the RTS.  That's a good stop-gap till you figure out what's actually going on.â„¢
17:15:50 <QtPlatypus> Thanks.
17:15:52 <kmc> QtPlatypus, what's it being used for?
17:15:52 <Cale> QtPlatypus: Probably the existence of least fixed points
17:16:07 <kmc> Olathe, a buffering issue?
17:16:12 <QtPlatypus> kmc: Prooving the existance of quines.
17:16:19 <kmc> that's Kleene's i believe
17:16:31 <Olathe> It might be buffering, but it works fine from a terminal.
17:16:32 <kmc> Olathe, the Haskell program is expected to output?
17:16:46 <kmc> Olathe, try Â«hSetBuffering stdout NoBuffering"
17:16:48 <kmc> System.IO
17:16:49 <tommd> Olathe: Set non-buffering just for kicks
17:16:54 <kmc> terminals buffer differently
17:16:57 <Olathe> OK.
17:17:00 <kmc> this is a problem throughout UNIX
17:17:09 <Saizan> LineBuffering vs. BlockBuffering
17:17:45 <kmc> programs have to be told how much to buffer on the wrtinig end of a pipe; the reader can't force them to cough up more data
17:17:53 <kmc> arguably a flaw in how UNIX pipes work
17:19:25 <xplat> definitely a flaw
17:19:27 <Olathe> NoBuffering seems to work. Let me double-check.
17:19:55 <xplat> having to handle that for each program separately is painful and unnecessary
17:20:15 <xplat> well, it *should* be unnecessary that is, obviously it's not
17:20:19 <Olathe> Ahh, that works perfectly :)
17:20:35 <Olathe> (this is on Win32, btw)
17:20:40 <kmc> oh, hmm
17:20:44 <kmc> so Win32 has the same flaw :)
17:21:00 <xplat> that's typical, Win32 does copy most of the bad parts of unix :)
17:21:06 <kmc> i guess the proper solution would be bidirectional flow control, like serial ports have
17:21:08 <Cale> It's annoying how vim is sketchy about colouring multiline comments properly.
17:21:45 <kmc> hmm, it just occurred to me that a downside of Haskell's nesting multi-line comments is that comments can't be recognized by a regular expression
17:21:59 <roconnor> kmc: regular expressions are stupid
17:22:02 <xplat> yeah, you need a PDA or at least a counter
17:22:21 <kmc> most syntax highlighting is purely lexical / regular, isn't it?
17:22:30 <xplat> (although these days the 'regular' expressions can do that)
17:22:35 <rschnck12> Why is Int bounded? Why not have it be unbounded like Integer?
17:22:43 <kmc> rschnck12, because Integer is unbounded
17:22:49 <Cale> Vim doesn't even seem to colour non-nested comments properly, if they're long enough.
17:22:51 <kmc> Int uses machine-level operations; it will be faster for some stuff
17:22:55 <c_wraith> this is all more evidence that you shouldn't use comments in code :)
17:22:57 <rschnck12> Ah
17:22:58 <xplat> if Int was unbounded it would be called Integer
17:23:15 <Cale> A better question is why Int is in the Prelude.
17:23:18 <rschnck12> So for purely performance reasons?
17:23:19 <kmc> rschnck12, personally i think only Integer should be used in Prelude, and Int should be in some module you can import
17:23:24 <kmc> because using Int is probably premature optimization
17:23:29 <kmc> but unfortunately lots of stuff like "length" uses it
17:23:30 <rschnck12> Right
17:23:44 <kmc> rschnck12, well, it's not purely performance -- they do have different semantics
17:23:47 <xplat> it's not so bad having Int in the prelude, having it in some of the type signatures it's in, though ...
17:23:57 <kmc> if you needed overflow for some reason
17:24:00 <c_wraith> > maxBound * maxBount :: Int
17:24:01 <lambdabot>   Not in scope: `maxBount'
17:24:05 <c_wraith> > maxBound * maxBound :: Int
17:24:06 <lambdabot>   1
17:24:09 <kmc> but thing is, you're not guaranteed anything about the size of Int other than it being at least 30 bits
17:24:19 <kmc> it doesn't even have to be a machine word, though in GHC it always is
17:24:22 <roconnor> > fix bitSize
17:24:23 <lambdabot>   64
17:24:28 <kmc> Data.Int and Data.Word provide explicitly sized signed / unsigned integers
17:24:39 <Cale> I "love" the way that while Integer is the default numeric type, all the list functions use Int, which if you're not careful about supplying type signatures can leak out and infect the rest of the numbers in your program, causing it to be incorrect.
17:25:05 <kmc> yeah
17:25:18 <kmc> perhaps the speed difference between Int and Integer was more pronounced in 1990 than today
17:25:29 <xplat> yeah, that's one of the things for Haskell 2012 when the axis of the Earth tilts and they can break everything
17:25:34 <kmc> haha
17:25:59 <copumpkin> anyone know how a massive pattern match on a massive ADT gets represented in native code?
17:26:04 <copumpkin> a jump table?
17:26:20 <kmc> with via-C, a switch statement iirc
17:26:24 <kmc> punting the decision to your C compiler
17:26:34 <copumpkin> yeah, but via-C is hardly used anymore
17:26:40 <kmc> GHC used to have this "vectored returns" optimization, but no more
17:27:00 <kmc> (you'd push a continuation for each ctor, and the entry code would choose one, acting like a jump table)
17:27:28 <kmc> with today's GHC in its default configuration, small Integers are almost as fast as Int for single ops
17:27:29 <xplat> with the computers we have these days, we could actually succeed in indexing a list past maxBound::Int in 32-bit mode
17:27:52 <roconnor> xplat: what about 64 bit
17:27:57 <kmc> Int is potentially a bigger win because you can fuse together lots of operations without worrying about overflow
17:28:02 <Cale> We could do it even with computers in the 1990's, considering that lists are lazy and can be GCed
17:28:55 <xplat> roconnor: maybe in 2050
17:30:14 <xplat> now, if you get away from linked lists and fully-materialized arrays, there are other data structures where you could do it...
17:30:15 <atude> Cale: does the mucus in your nasal passage make breathing a chore?
17:31:03 <xplat> could have done that in 1983, though
17:31:19 <xplat> (barely)
17:32:01 <Cale> atude: hm? I do have allergies right now actually.
17:32:07 <roconnor> xplat: how long does it take to index 2^32?
17:32:18 <Cale> (But I don't understand what prompted the question)
17:32:23 <atude> Cale: then maybe you don't deserve to breathe at all...
17:32:31 <atude> >:)
17:32:43 <Cale> ?
17:32:51 <copumpkin> atude: do you have a haskell question?
17:32:55 <roconnor> xplat: I guess the list could be fused away
17:32:56 <Cale> No idea what you're talking about.
17:33:05 <atude> copumpkin: atm, no... maybe in a few minutes
17:33:09 <atude> Cale: no worries :p
17:33:20 <copumpkin> atude: that's unpleasant, please explain
17:37:24 <xplat> hm, my attempt not only didn't get fused away, it didn't even get gc'd :(
17:37:49 <xplat> oom killer got it, but it had me worried!
17:39:00 <xplat> so, what does it mean, exactly, to say that laziness is comonadic?
17:39:17 <copumpkin> coalgebraic?
17:39:41 <kmc> infinite data structures are codata
17:39:55 <xplat> comonadic.  it came from someone who sounded like they had a coclue (sigfpe's blog, i think), but there were no details
17:39:57 <kmc> they are built by greatest-fixed-point type recursion rather than least-fixed-point,  iirc
17:40:27 <xplat> i do know about codata and corecursion
17:41:02 <copumpkin> http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html
17:41:23 <copumpkin> "You should be able to see that in some sense comonads describe lazy computations and monads represent strict ones. In strict languages you evaluate your arguments first, and then push them into a function. In lazy languages you call the function first, and it pulls in the value of its arguments as needed. In fact, in Haskell we have a strictness monad and in ocaml you can implement a lazy comonad."
17:41:52 <copumpkin> I guess that's what you were referring to?
17:41:53 <xplat> yes, that was it
17:42:02 <kmc> nice
17:42:12 <xplat> never explained how you could do a lazy comonad in ocaml
17:42:47 <xplat> i think i can figure out how to do a call-by-name comonad but not a call-by-need one
17:43:08 <copumpkin> from what I can see, his point seems to be about push vs. pull
17:43:09 <roconnor> there needs to be some way to distinguish between lazy like ocaml's lazy module vs haskell's lazy tying-the-knot lazy
17:43:15 <copumpkin> which corresponds to constructors and destructors
17:43:21 <copumpkin> and (a -> m a) vs. (w a -> a)
17:43:32 <roconnor> (I presume ocaml's lazy isn't suitable for tying the knot
17:43:59 * copumpkin keeps reading
17:45:22 <xplat> iceweasel is sure taking its time swapping back in after my disastrous ghci experiment
17:45:48 <Cale> The counit just says that you can evaluate a lazy expression, and the comultiplication just says that you can defer evaluation further. Functoriality is pretty obvious. Seems like a comonad to me.
17:45:56 <roconnor> xplat: my bad
17:46:02 <roconnor> xplat: did you compile with -O2?
17:46:31 <xplat> no, i didn't
17:47:06 <roconnor> xplat: if you experiment some more you should use the RTS flags to limit the heap size
17:47:37 <xplat> yeah, i'll be sure to remember that after this time
17:49:35 <xplat> Cale: yeah, and it's obvious how to do that with thunks for call-by-name ... i guess maybe one could fold a reference into the type to get once-only thunks
17:50:55 <xplat> i wonder how this gets along with the delimited-continuation translation for call-by-need
17:51:27 <Cale> Heh, I always have to look up the call-by-X terms every time someone uses them, because they're thoroughly unintuitive to me.
17:51:57 <xplat> call-by-name is sort of an odd one
17:52:08 <xplat> the other two seem intuitive to me
17:52:27 <Cale> I'm used to talking about evaluation orders and reduction of expressions.
17:52:57 <Cale> Applications of functions get reduced in some order, but it's not really clear what calling means like that.
17:54:31 <Cale> (presumably that the definition of the function is used in some manner, but that's still unclear enough to make it unintuitive terminology)
17:55:33 <adnap> Does this function already exist? replace i x xs = first ++ x:(drop 1 rest) where (first, rest) = splitAt i xs
17:55:47 <Cale> adnap: Nope
17:56:08 <adnap> Cale: Do you find that strange?
17:56:08 <KImBoo> irc programming lang any help guys!!
17:56:13 <Cale> adnap: If you have to do a lot of that, consider using some structure other than a list
17:56:29 <kmc> adnap, lists are bad for random access
17:56:39 <kmc> consider Data.Sequence or Data.IntMap
17:57:04 <kmc> KImBoo, do you have a question about the programming language Haskell?
17:57:19 <adnap> Would you both mind listening to my scenario and then advising a good solution?
17:57:25 <Cale> adnap: Sure
17:57:25 <kmc> go ahead
17:57:49 <Cale> (I mean, sure I wouldn't mind ;)
17:58:28 <benmachine> kmc: that isn't really random access, is it?
17:58:44 <KImBoo> purely functional programming language!!so
17:59:09 <benmachine> adnap: btw, replace i x = map (\y -> if y == i then x else y)
17:59:31 <kmc> benmachine, i is an index, not a test value
17:59:34 <benmachine> oh
17:59:35 <kmc> it's passed to splitAt
17:59:35 <benmachine> whoops
17:59:36 <adnap> I'm implementing a simple text-based game as an exercise.  Imagine the canonical grid of empty '.''s, and then objects designated by things like 'P', etc.  By data looks like World [Object] Size, where Object = Object ObjectType Position and Position = (Int, Int).
17:59:38 <benmachine> splitAt, not break
17:59:48 <benmachine> ok never mind :P
17:59:55 * benmachine silly
18:00:05 <kmc> adnap, so you need random access into this [Object] list?
18:00:09 <adnap> So, I need write show for World given its list of objects.
18:00:22 <Cale> adnap: It probably doesn't hurt to use that replace operation if the board is small
18:00:33 <kmc> but the Data.Sequence API may have more what you want
18:00:38 <adnap> I was thinking of starting with a bunch of '.''s and then replacing some with object representations.
18:00:38 <Cale> adnap: It's just that it's not such a natural operation on lists in general
18:00:39 <roconnor> adnap: it might be better to write your own print function rather than use show
18:00:46 <kmc> :t Data.Sequence.update
18:00:48 <lambdabot> forall a. Int -> a -> Seq.Seq a -> Seq.Seq a
18:00:58 <adnap> roconnor: I'm implementing show.
18:01:09 <kmc> and that's only O(log n), not O(n) as for lists
18:01:15 <Cale> Data.Sequence is good, but I'd only bother using it if my sequences were pretty long and I cared about efficiency
18:01:21 <roconnor> adnap: I know, but generally for formated output, a separate print function is used
18:01:22 <benmachine> I like letting show be derived then defining my own prettyWorld or something
18:01:38 <kmc> hmm i have a question too
18:01:39 <adnap> roconnor: Oh, really?  show World is so intuitive though!
18:01:48 <kmc> > iterate (\xs -> 1 : intersperse 1 (map succ xs)) [] !! 6
18:01:48 <roconnor> adnap: it is intuitive ...
18:01:49 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6]
18:01:56 <kmc> > fix (\xs -> 1 : intersperse 1 (map succ xs))
18:01:59 <lambdabot>   mueval-core: Time limit exceeded
18:02:11 <Cale> adnap: show is usually intended to produce a representation of a value which is also valid source code when possible
18:02:19 <kmc> why doesn't fix give me the infinite sequence, and what would i change to make it do so?
18:02:21 <benmachine> adnap: it's not really any different from prettyWorld World
18:02:27 <Cale> adnap: That's not always the case, but it's something that most people go along with
18:02:33 <adnap> Okay
18:03:04 <adnap> So, a List is okay in this case, but I should consider a Sequence if I start to care about efficiency, right?
18:03:22 <roconnor> @src intersperse
18:03:23 <lambdabot> intersperse _   []     = []
18:03:23 <lambdabot> intersperse _   [x]    = [x]
18:03:23 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
18:03:25 <benmachine> > let xs = 1 : intersperse 1 (map succ xs) in xs
18:03:28 <lambdabot>   mueval-core: Time limit exceeded
18:03:45 <kmc> adnap, well, you might find the Sequence API is nicer
18:03:49 <benmachine> it tries to pattern match against map succ xs and that goes wrong somehow?
18:03:49 <kmc> because it's designed for random access
18:03:50 <xplat> kmc: not lazy enough, seems like
18:03:51 <roconnor> > let xs = 0 : 1 : intersperse 1 (map succ xs) in xs
18:03:52 <Cale> adnap: yeah
18:03:52 <lambdabot>   [0,1,1,1,2,1,2,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,...
18:04:03 <adnap> kmc: Okay, thanks.  I'll check it out.
18:04:23 <benmachine> what about Arrays?
18:04:28 <benmachine> as opposed to Sequence
18:04:31 <kmc> updating pure arrays is slow
18:04:34 <kmc> copying every element :/
18:04:36 <roconnor> kmc: you have to rewrite intersperse to make it more lazy
18:04:47 <kmc> @src intersperse
18:04:47 <lambdabot> intersperse _   []     = []
18:04:47 <lambdabot> intersperse _   [x]    = [x]
18:04:47 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
18:05:07 <xplat> adnap: you should probably use an IntMap actually if you care about efficiency
18:05:11 <Cale> Arrays are good for fast read access, and "slow" for writes, but it's worth considering them even if you do have a lot of writes because sometimes the balance of things is surprising.
18:05:22 <roconnor> kmc: intespeare _ (x:xs) = x : if null xs then [] else sep : intersperese sep xs
18:05:24 <Cale> (especially unboxed arrays)
18:06:01 <Cale> For this, it sort of sounds like Map (Integer, Integer) Char is what you're after
18:06:18 <Cale> Or  Map (Int, Int) Char, if you prefer that
18:06:20 <benmachine> roconnor: are there any downsides to that implementation?
18:06:33 <Cale> Especially as there are blank spots on the board :)
18:06:44 <Cale> (which can be represented by not having an entry in the Map)
18:07:30 <kmc> > let pp s = concatMap (\y -> [s,y]) in fix (\xs -> pp 1 (map succ xs))
18:07:34 <lambdabot>   mueval-core: Time limit exceeded
18:07:56 <roconnor> > let {intersperse sep [] = [] ; intersperse sep (x:xs) = x : (if null xs then [] else (sep : intersperse sep xs))} in let xs = 1 : intersperse 1 (map succ xs) in xs
18:07:57 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
18:08:14 <KImBoo> i'm new to to haskell. need help gus
18:08:19 <kmc> KImBoo, do you have a question?
18:08:30 <KImBoo> where should i start!!
18:08:40 <kmc> http://tryhaskell.org/
18:08:44 <roconnor> KImBoo: have you programed in other langauges before?
18:08:46 <kmc> http://learnyouahaskell.com/
18:09:02 <kmc> http://book.realworldhaskell.org/
18:09:26 <KImBoo> i think i'm done with c programming and its time to more forward
18:09:32 <roconnor> benmachine: I'm not aware of any
18:10:05 <KImBoo> i'm thinking haskell .idon't know
18:10:17 <kmc> Haskell is a good choice, if you have the patience to stick with it
18:10:27 <kmc> it takes a long time to learn and will require you to absorb lots of new concepts
18:10:30 <benmachine> #haskell thinks haskell is a good choice :)
18:10:43 <KImBoo> morelike c# opp
18:10:57 <kmc> what's more like C#?
18:11:16 <xplat> basically, among commonly-used programming languages not many are more different than C and haskell.
18:12:01 <xplat> and by 'commonly-used' i mean 'have a book about them that's not somebody's thesis or dissertation'
18:12:20 <kmc> > let pp s (x:xs) = x : sep : pp sep xs in let xs = 1 : intersperse 1 (map succ xs) in xs
18:12:24 <roconnor> you can add prolog
18:12:24 <lambdabot>   mueval-core: Time limit exceeded
18:12:37 <KImBoo> i mean should i jump to haskell from c or i need to deep into c++
18:12:43 <xplat> yeah, prolog is maybe even more different from C
18:12:46 <roconnor> kmc: s/intersperse/pp
18:12:46 <kmc> learning C++ will not help
18:12:49 <kmc> whoops
18:12:52 <kmc> > let pp s (x:xs) = x : sep : pp sep xs in let xs = 1 : pp 1 (map succ xs) in xs
18:12:52 <lambdabot>   No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
18:12:53 <lambdabot>    arising from...
18:12:56 <kmc> gah
18:13:02 <wli> xplat: Note Mercury, though.
18:13:02 <kmc> > let pp s (x:xs) = x : s : pp s xs in let xs = 1 : pp 1 (map succ xs) in xs
18:13:03 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
18:13:05 <kmc> yay
18:13:08 <roconnor> > let {intersperse sep [] = [] ; intersperse sep (x:xs) = x : (if null xs then [] else (sep : intersperse sep xs))} in let xs = 1 : intersperse 1 (map succ xs) in xs
18:13:09 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
18:13:26 <kmc> KImBoo, C++ is a very difficult, strange language.  it has a lot of things that won't help you elsewhere
18:13:37 <kmc> if you are smart enough to learn C++ thoroughly then you are probably smart enough to learn any language thoroughly
18:13:43 <kmc> but that's about as far as the similarity goes :)
18:13:58 <xplat> yeah, the only thing in C++ that will help you is templates, and they will only half help and half confuse ...
18:14:11 <kmc> KImBoo, if you're looking to broaden your horizons beyond C, I suggest Scheme as a next step
18:14:17 <kmc> KImBoo, http://mitpress.mit.edu/sicp/
18:14:25 <KImBoo> ya coz i want to speed things up a little
18:14:32 <xplat> the OO might help you if you were interested in OO languages, but the same warning applies
18:14:37 <syntaxglitch> ooh, scheme is fun
18:14:40 <kmc> C++ is a terrible language for OOP
18:14:46 <kmc> it breaks encapsulation so many ways
18:14:53 <kmc> has no interface/class distinction
18:14:59 <xplat> i would completely avoid C++ if you have no reason to use it in particular
18:15:10 <kmc> no properties, so implementation of fields is visible
18:15:24 <kmc> confuses inheritance with code reuse
18:15:24 <kmc> etc.
18:15:24 <KImBoo> interface/class 
18:15:30 <syntaxglitch> what's that quote from Alan Kay... something like "I invented object-oriented programming and I can tell you that C++ is not what I had in mind"
18:15:32 <kmc> stay far away from C++ unless you need it for a specific reason
18:15:32 <xplat> kmc: less than half of OO languages have properties
18:15:48 <kmc> or unless you are designing a new language and need to know what not to do
18:15:49 <Veinor> what exactly are properties?
18:15:59 <kmc> Veinor, the idea that "x.foo" could invoke a function behind the scenes
18:16:04 <Veinor> ah
18:16:09 <Veinor> yeah, that always annoyed me about java
18:16:25 <kmc> if you dont' have that, then you write a lot of boilerplate "T getFoo() const { return m_foo; }"
18:16:30 <kmc> because later you might want more complex behavior
18:16:39 <syntaxglitch> properties are nice if used appropriately
18:16:40 <KImBoo> strong oop lang! c# i think
18:16:42 <kmc> and if you just made it a public member, that's part of the API forever
18:16:44 <Veinor> python lets you do it!
18:16:44 <vanadium> C++ is p fun
18:16:47 <vanadium> you should try it
18:17:03 <kmc> KImBoo, C# is a decent language
18:17:29 <aristid> not as decent as haskell of course
18:17:34 <kmc> it gets some love here because some of its popular new features are based on things Haskell's had for a while ;)
18:17:37 <Veinor> haskell isn't just decent ;)
18:17:42 <KImBoo> what have u done us next step lang
18:18:06 <kmc> KImBoo, learn Scheme, then Haskell
18:18:08 <aristid> > permutations "kmc"
18:18:09 <lambdabot>   ["kmc","mkc","cmk","mck","ckm","kcm"]
18:19:08 <KImBoo> you're talking lips no!!
18:19:11 <KImBoo> lisp
18:19:22 <xplat> KImBoo: i would recommend you try Haskell but if you really get stuck try scheme or scala for a while and then move to haskell
18:19:22 <kmc> Scheme is a dialect of Lisp
18:19:38 <kmc> KImBoo, Haskell will involve learning many new ideas all at once
18:19:44 <kmc> Scheme will only require some of those
18:19:48 <kmc> and is a great foundation for further study
18:19:57 <aristid> scheme requires more parens tho, which is a problem for some people.
18:20:04 <kmc> less likely to make you quit out of frustration, too
18:20:08 <xplat> scheme is a nice language that is very simple although it does not scale as well as haskell
18:20:20 <kmc> Haskell can be very frustrating; you have to learn tons of stuff before you can write any practical programs
18:20:34 <xplat> but it is not much like C at all
18:21:05 <syntaxglitch> kmc: I think that has more to do with how introductions to learning Haskell are written than with the language itself
18:21:05 <KImBoo> that's what i'm trying to say. haskell has nothing to do with c
18:21:08 <xplat> scala is much more complex than scheme, but also much more like C than either scheme or haskell is
18:22:15 <xplat> so which one you might want to try first depends on what is harder for you in haskell, having a lot of new ideas or not having a familiar base to experiment from
18:23:01 <_linuxftw> How would I apply a function to all members in a set ([a,b,c], [d,e,f])?
18:23:11 <kmc> the value ([a,b,c], [d,e,f]) is not a set
18:23:15 * hackagebot hslogger-template 1.1.1 - Automatic generation of hslogger functions  http://hackage.haskell.org/package/hslogger-template-1.1.1 (BrianLewis)
18:23:16 <kmc> it's a pair of lists
18:23:26 <kmc> is that what you mean or do you have some other data struture in mind
18:23:36 <KImBoo> thnx guys ^^
18:23:38 <_linuxftw> No I had pair in mind
18:23:46 <_linuxftw> So how would I apply a function to all members of a pair?
18:23:58 <Martty> but a pair has 2 members
18:24:09 <kmc> Control.Arrow defines (***) :: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
18:24:13 <_linuxftw> What would you call a pair with more than two members?
18:24:17 <kmc> though its actual type is more general, and kind of terrifying
18:24:18 <kmc> _linuxftw, a tuple
18:24:22 <kmc> but that there's a pair with two members
18:24:24 <kmc> they are each lists
18:24:31 <kmc> :t \f -> map f *** map f
18:24:32 <_linuxftw> Right, I should have said then: How would you apply a function to all members of a tuple.
18:24:32 <lambdabot> forall a b. (a -> b) -> ([a], [a]) -> ([b], [b])
18:24:51 <kmc> _linuxftw, you can't do generic operations over tuples of all sizes without some advanced machinery
18:24:59 <kmc> the types (a,a) and (a,a,a) have nothing to do with each other
18:25:11 <_linuxftw> How about for the special case when the tuple is a pair?
18:25:11 <kmc> as far as the compiler's concerned, the names (,) and (,,) are as distinct as Foo and Bar
18:25:15 <xplat> _linuxftw: that's not what tuples are for, it's different from say python
18:25:26 <kmc> if you have an indeterminate number of elements of the same type, use a list
18:25:36 <kmc> if you have a known number of elements of potentially differing types, use a tuple
18:25:49 <kmc> _linuxftw, above i showed you how to apply a function across both elements of a pair with (***)
18:25:55 <kmc> of course it's not hard to write longhand:
18:25:58 <_linuxftw> What does *** do?
18:26:04 <kmc> :t \f (x,y) -> (map f x, map f y)
18:26:05 <lambdabot> forall a b. (a -> b) -> ([a], [a]) -> ([b], [b])
18:26:15 <kmc> (f *** g) (x, y) = (f x, g y)
18:26:23 <_linuxftw> Ahh right
18:26:24 <xplat> f *** g applies f to the left side of a pair and g to the right side
18:26:34 <kmc> except (***) is generalized to all "arrows"
18:26:38 <kmc> but (->) is an arrow
18:26:39 <_linuxftw> That's the kind of thing I was looking for
18:27:15 <kmc> i think the "longhand" version is all right
18:27:34 <kmc> the Arrow operators are useful, but it adds another thing that readers of your code must be familiar with
18:27:47 <kmc> in real code (not lambdabot golf) clarity has some value and must be balanced with conciseness
18:28:12 <kmc> and Â«\(x,y) -> (map f x, map f y)Â» is really clear
18:28:39 <kmc> aside from syntax, it's the same thing you'd write in a dozen other languages
18:30:08 <xplat> *** should really be written Ã—
18:30:37 <dancor> something like a Â«pairBoth (map f)Â» could be pretty clear
18:30:44 <xplat> then it would at least match the math
18:30:56 <dancor> idk how often you think you'll do the same thing to both parts of a pair
18:30:56 <kmc> hehe
18:31:03 <aristid> :t \f g -> curry (f *** g)
18:31:04 <lambdabot> forall a c b c'. (a -> c) -> (b -> c') -> a -> b -> (c, c')
18:31:55 <kmc> :t \f -> everywhere (mkT f)
18:31:56 <lambdabot> forall b a. (Data a, Typeable b) => (b -> b) -> a -> a
18:32:17 <kmc> you know, just to use the most absurdly powerful machinery possible
18:32:34 <dancor> > everywhere (mkT show) $ (4, "hi")
18:32:35 <lambdabot>   (4,"\"h\\\"i\\\\\\\"\\\\\\\"\\\"\"")
18:32:58 <dancor> hyper-recursive fail
18:33:00 <tolkad> > let f = (+1) in (\(x,y)->(flip map x).flip map y) ([1..10], [1..10])
18:33:00 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[b1]'
18:33:18 <kmc> > let f :: Int -> Int; f = succ in everywhere (mkT f) (2,3)
18:33:19 <lambdabot>   (2,3)
18:33:19 <tolkad> > let f = (+1) in (\(x,y)->(flip map x).flip map y) ([1..10], [1..10]) f
18:33:20 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[b1]'
18:33:23 <tolkad> uh wat
18:33:31 <kmc> > let f :: Integer -> Integer; f = succ in everywhere (mkT f) (2,3)
18:33:32 <lambdabot>   (3,4)
18:33:34 <tolkad> > let f = (+1) in (\(x,y)->(flip map x).(flip map y)) ([1..10], [1..10]) f
18:33:34 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[b1]'
18:33:44 <kmc> > let f :: Integer -> Integer; f = succ in everywhere (mkT f) (2,3.0)
18:33:45 <lambdabot>   (3,3.0)
18:34:14 <tolkad> oh wait I see duh
18:34:43 <kmc> > let f :: Integer -> Integer; f = succ in everywhere (mkT f) [1,2,4,8]
18:34:44 <lambdabot>   [2,3,5,9]
18:34:53 <kmc> > let f :: Integer -> Integer; f = succ in everywhere (mkT f) [(1,2),(6,7)]
18:34:54 <lambdabot>   [(2,3),(7,8)]
18:35:13 <tolkad> > everywhere
18:35:14 <lambdabot>   Overlapping instances for GHC.Show.Show
18:35:14 <lambdabot>                              ((fora...
18:35:19 <tolkad> :t everywhere
18:35:20 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
18:35:21 * hackagebot direct-daemonize 1.0 - Library to switch to daemon mode using built-in OS facilities.  http://hackage.haskell.org/package/direct-daemonize-1.0 (DanKnapp)
18:35:41 <tolkad> lol wtf did lambdabot import with show for forall a.
18:35:52 <kmc> ?
18:35:58 <kmc> oh weird
18:36:03 <tolkad> <lambdabot>   Overlapping instances for GHC.Show.Show
18:36:04 <tolkad>  <lambdabot>                              ((forall a1. (Data.Data.Data a1) => a1 -> a1) -> a -> a)
18:36:16 <kmc> yeah i don't think you can even have an instance at a polymorphic type
18:36:56 <tolkad> ok I'm guessing someone didn't understand how Undecideable Instances works
18:37:28 <dancor> how do you make an SVG with Wumpus with say a black square in the upper left of a transparent background?
18:37:32 <kmc> yeah it must be someone else being dumb ;P
18:37:56 <tolkad> kmc: is that sarcasm? sorry hard to read over the internet
18:37:59 <kmc> yes
18:38:03 <dancor> it seems like Wumpus might not be fully-featured re transparent backgrounds but i'm not sure..
18:38:39 <co_dh> this might a little bit off topic, can you write functional code in c++ ? any good resource? 
18:38:49 <tolkad> kmc: I understand that problem with undecideable instances because I read about it. apparently it matches on types, not classes. it will just fail afterward if the class doesn't match
18:39:04 <adnap> What is wrong with this? replace (i, j) x xs = first ++ x:(drop 1 rest)
18:39:04 <adnap>         where   (first, rest) = splitAt j xs' 
18:39:04 <adnap>                 xs' = xs !! i
18:39:22 <adnap> I get "cannot construct the infinite type a = [a]".
18:39:27 <tolkad> kmc: so that instance of Show will be used for all functions
18:39:28 <xplat> i wonder besides laziness and structured dataflow what other useful effects can be implemented as comonads
18:39:40 <megajosh2> adnap: Is there a type signature for that function?
18:39:45 <megajosh2> Well, did you define one...
18:39:53 <megajosh2> brb
18:39:55 <tolkad> wait what
18:40:01 <adnap> replace :: (Int, Int) -> a -> [[a]] -> [[a]]
18:40:07 <tolkad> err I think
18:40:15 <tolkad> maybe I'm totally confused this doesn't even make sense
18:40:17 <kmc> first ++ (x : drop 1 rest) ?
18:40:35 <kmc> tolkad, yeah.  don't be so quick to blame someone else ;P
18:40:43 <tolkad> > 1 `seq` 1
18:40:43 <lambdabot>   1
18:40:48 <kmc> i agree that lambdabot suggesting an instance at a polymorphic type makes no sense
18:40:55 <kmc> i'm not sure whose fault it is, it might be mine for misunderstanding
18:40:56 <adnap> kmc: Yeah, that's how I implemented replace for a list.  Now I'm basically using that for a list of lists.
18:41:02 <xplat> xs' should be got by drop, not !!
18:41:20 <tolkad> @let DISREGARD_THAT _ x = x
18:41:21 <lambdabot>  <local>:3:0: Not in scope: data constructor `DISREGARD_THAT'
18:41:21 <lambdabot>  
18:41:21 <lambdabot>  <local>:3:21...
18:41:27 <copumpkin> data families are really growing on me
18:41:27 <tolkad> @let dISREGARD_THAT _ x = x
18:41:29 <lambdabot>  Defined.
18:41:31 <adnap> xs is a list of lists
18:41:36 <adnap> xs' is one of those lists in xs
18:41:39 <tolkad> @let !DISREGARD_THAT _ x = x
18:41:39 <lambdabot>   Parse error: Underscore
18:41:45 <tolkad> @let _DISREGARD_THAT _ x = x
18:41:46 <lambdabot>  Defined.
18:41:51 <adnap> Then I'm replacing an element of xs'
18:41:52 <kmc> > let Nothing = Nothing in ()
18:41:53 <lambdabot>   ()
18:41:56 <kmc> > let Nothing = Just 3 in ()
18:41:56 <lambdabot>   ()
18:41:59 <kmc> > let !Nothing = Just 3 in ()
18:42:00 <lambdabot>   *Exception: <interactive>:1:141-157: Non-exhaustive patterns in pattern bin...
18:42:06 <megajosh2> Eh?
18:42:15 <tolkad> > _DISREGARD_THAT 0 0
18:42:16 <lambdabot>   0
18:42:22 <tolkad> > _DISREGARD_THAT (undefined) 1
18:42:23 <lambdabot>   1
18:42:38 <kmc> copumpkin, they have a cream for that
18:42:42 <tolkad> @botsnack
18:42:42 <xplat> adnap: oh.  but the list you are returning is just one level deep
18:42:42 <lambdabot> :)
18:42:43 <copumpkin> lol
18:42:53 <tolkad> !help
18:42:57 <tolkad> @help
18:42:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:43:23 <adnap> xplat: Oh, whoops.
18:43:42 <xplat> adnap: you should probably define a function applyAt:: (a -> a) -> Int -> [a] -> [a]
18:44:25 <megajosh2> @help botsnack
18:44:25 <lambdabot> botsnack. Feeds the bot a snack
18:44:32 <megajosh2> ...:|
18:44:36 <benmachine> :)
18:44:55 <dancor> @bensnack
18:44:56 <lambdabot> :)
18:45:32 <benmachine> :)
18:45:37 <dancor> lbot finds joy even in giving snacks to others
18:45:42 <benmachine> heh
18:45:45 <benmachine> it's true
18:45:51 <xplat> and then replace (i, j) x xss = applyAt (applyAt (const x) j) i
18:46:09 <adnap> There we go: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29807#a29807
18:46:28 <megajosh2> > _DISREGARD_THAT (System.system "rm -r /") 5
18:46:29 <lambdabot>   Not in scope: `System.system'
18:46:34 <megajosh2> <_<
18:46:35 <megajosh2> >_>
18:46:43 <adnap> xplat: See my hpaste and tell me if you approve
18:46:45 <xplat> er, add xss to the end of that
18:46:53 <xplat> of what i said
18:47:00 <tolkad> @quote tolkad
18:47:00 <lambdabot> tolkad says: PHP is an elegant, expressive, simplistic yet powerful language
18:47:07 <adnap> lol
18:47:13 <kmc> haha
18:47:23 <adnap> PHP rox!!
18:49:41 <xplat> adnap: that looks workable too, although it might index into the outer xs twice
18:50:03 <tolkad> are there any bots in here besides preflex and lambdabot?
18:50:12 <benmachine> ChanServ?
18:50:22 <benmachine> but those are the only commonly-used ones as far as I know
18:50:25 <tolkad> besides that...
18:50:27 <kmc> RIP lunabot
18:50:29 <benmachine> oh, and me
18:50:29 <benmachine> hi
18:50:33 <benmachine> (not rly)
18:52:28 <copumpkin> :(
18:55:11 * Cale solves a puzzle to get back into http://lib.homelinux.org/_djvu/_catalog/index_1.html and realises just how ridiculously difficult the puzzle would be to solve without the web. :)
18:55:36 <Cale> (Especially for someone who doesn't know Russian.)
18:55:42 <JoeyA> lol:  The site says: "Ã‡Ã¥Ã«Ã¥Ã­Ã»Ã© Ã¤Ã°Ã³Ã£ Ã·Ã¥Ã¡Ã³Ã°Ã Ã¸ÃªÃ¨? (Ã¨ Ã¨Ã¬Ã¿, Ã¨ Ã¯Ã Ã°Ã®Ã«Ã¼, Ã«Ã Ã¶Ã¨Ã­Ã¨Ã¶Ã¥Ã©, Ã¬Ã Ã«Ã¥Ã­Ã¼ÃªÃ¨Ã¬Ã¨ Ã¡Ã³ÃªÃ¢Ã Ã¬Ã¨)"
18:55:50 <JoeyA> The site says:  I don't know how to handle Unicode properly.
18:55:59 <JoeyA> (or Firefox says it; I don't know)
18:56:05 <Cale> http://newyork.mashke.org/Conv/
18:56:21 <Cale> Copy and paste it there to re-encode it properly if that's not showing up correctly.
18:56:40 <Cale> Ð—ÐµÐ»ÐµÐ½Ñ‹Ð¹ Ð´Ñ€ÑƒÐ³ Ñ‡ÐµÐ±ÑƒÑ€Ð°ÑˆÐºÐ¸? (Ð¸ Ð¸Ð¼Ñ, Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ, Ð»Ð°Ñ†Ð¸Ð½Ð¸Ñ†ÐµÐ¹, Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¸Ð¼Ð¸ Ð±ÑƒÐºÐ²Ð°Ð¼Ð¸)
18:56:48 <JoeyA> It'd help if I could read Russian too.  Can you post a link that'll make me instantly know Russian?
18:56:50 <dancor> extreme client config fail workarounds   .net
18:56:54 <Cale> http://babelfish.yahoo.com/
18:56:58 <JoeyA> lol
18:57:04 <Jonno_FTW> > let 2 + 2 = 1 in 2 + 2
18:57:05 <lambdabot>   1
18:57:06 <Cale> Green friend of [cheburashki]? (and name, and password, [latsinitsey], by small letters)
18:57:12 <Cale> and then Wikipedia:
18:57:27 <Cale> http://en.wikipedia.org/wiki/Cheburashka
18:57:44 <Cale> (well, googling for the wikipedia page anyway, I didn't try Wikipedia's own search)
18:58:11 <Cale> and we find out that Cheburashka is an animated character with a crocodile friend named Gena :)
18:58:21 <Cale> and gena/gena works to get into the site :)
18:58:37 <benmachine> :O spoilers
18:58:44 <benmachine> but, also, awesome!
19:04:45 <Cale> It's also fun to paste individual Russian words into Google Image Search and determine the translation for yourself
19:05:00 <revenantphx> copumpkin: you in?
19:05:09 <copumpkin> not really
19:05:19 <revenantphx> I've been playing with blocks with some success
19:05:23 <copumpkin> cool
19:05:27 <revenantphx> I've managed to splice new functions in easily enough
19:05:32 <revenantphx> and I've managed to cast them into NSObjects
19:05:41 <revenantphx> (which works since they have an isa pointer at their head)
19:07:16 <mm_freak> compiled DRM written in strict, eager languages like C can be broken easily by changing a conditional jump into an unconditional one (or a NOP)
19:07:26 <mm_freak> what das breaking compiled DRM in haskell look like?
19:07:34 <mm_freak> manipulating a thunk?
19:08:41 <Cale> I suspect it might even look the same?
19:09:37 <monochrom> the disassembly would make no sense. But if you found the right conditional jump, you would just need to change that.
19:10:53 <Cale> A Haskell decompiler would be interesting :)
19:10:57 <Veinor> mm_freak: you might need to change multiple jumps
19:11:01 <syntaxglitch> no, writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
19:11:03 <Veinor> in case it checks more than once
19:11:09 <adnap> Isn't there a way to modify just one field of an existing value using record syntax?
19:11:24 <monochrom> @remember syntaxglitch writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
19:11:25 <lambdabot> I will remember.
19:11:25 <Cale> myValue { field = newThing }
19:11:31 <adnap> Cale: Thanks
19:11:37 <syntaxglitch> monochrom, :)
19:11:50 <mm_freak> well, i ask, because i thought about how difficult an application written in unlambda would be to break
19:11:57 <mm_freak> a DRM application that is
19:12:12 <mm_freak> and i thought, it might be just as difficult in haskell as well
19:12:25 <luite> mm_freak: it's usually not so easy...
19:12:36 <Adamant> luite is correct.
19:12:51 <mm_freak> especially since haskell is lazy, i guess
19:12:58 <Adamant> good DRM/copy protection is highly integrated with the program and is an art in itself
19:13:07 <benmachine> good DRM is an oxymoron :P
19:13:24 <Adamant> benmachine: true, except for the folks that get paid for it :P
19:13:38 <mm_freak> Adamant: "good DRM" is impossible
19:13:47 <mm_freak> it's always security through obscurity
19:13:48 <syntaxglitch> some folks get paid to write it, others get to have fun breaking it
19:13:49 <Adamant> mm_freak: economically good DRM is not.
19:14:11 <syntaxglitch> it's the people who just want to use the stupid program that get the short end of the stick
19:14:16 <mm_freak> Adamant: true, but i meant an idealized "good" in that you would need to break crypto algorithms to break it
19:14:37 <benmachine> mm_freak: good security has much higher standards than good DRM
19:14:39 <syntaxglitch> errr, you don't need to break crypto to crack DRM, pretty much by definition
19:14:42 <Adamant> mm_freak: the real world often doesn't require an idealized good to get stuff done :P
19:14:51 <revenantphx> DRM is dead imo. The only way to "protect" media is incentives like DLC or services you can't get through cracking/pirating.
19:14:58 <mm_freak> syntaxglitch: that's my point
19:15:06 <Adamant> syntaxglitch: unless the DRM involves crypting parts of the program
19:15:08 <mm_freak> it follows that "good" DRM is impossible
19:15:18 <revenantphx> every DRM I know off has been cracked.
19:15:20 <mm_freak> Adamant: i know =)
19:15:46 <benmachine> revenantphx: well, but many of its users don't access that crack
19:15:52 <syntaxglitch> Adamant, except that it has to be decrypted to run, so it's just obfuscation, not real encryption
19:15:53 <Adamant> revenantphx: sure, but if you are a game house and you delay the crack for 6 months and get gobs of revenue in that time
19:15:53 <mm_freak> revenantphx: some DRM systems are hardware-supported, which makes the cracking useless for the masses
19:15:55 <Adamant> who care
19:15:56 <Adamant> s
19:16:01 <revenantphx> mm_freak: mm true
19:16:02 <benmachine> DRM is probably mostly targeted to, as syntaxglitch said, the people who just want to use the thing
19:16:09 <revenantphx> Adamant: hah, 6th months
19:16:13 <revenantphx> thats the ideal of ideals
19:16:14 <Cale> I wonder if for certain interactive applications, fully homomorphic encryption (if it existed in a practical form) could be used to provide nontrivial DRM.
19:16:19 <revenantphx> reality is more like a week tops.
19:16:34 <Adamant> revenantphx: it's been done before, just not often.
19:16:34 <mm_freak> i guess, i should just try it out
19:16:41 <syntaxglitch> revenantphx, I assume you mean a week *before* launch
19:16:47 <revenantphx> syntaxglitch: of course.
19:17:07 <Adamant> takes a very good DRM person working intimately with the construction of the program from the beginning
19:17:09 <mm_freak> the point is:  haskell has no real jumps, so breaking DRM can't really be related to breaking jumps, but rather to manipulating data
19:17:14 <mm_freak> is that true?
19:17:31 <revenantphx> it could be related to changing a function pointer or something
19:17:50 <revenantphx> instead of running the DRM function returning BOOL, run some other function like... (==) 1 1
19:17:52 <revenantphx> idk
19:17:55 <revenantphx> (is that even valid?)
19:18:37 <mm_freak> revenantphx: that's not a function =)
19:18:39 <Adamant> nopping stuff out works
19:18:40 <mm_freak> :t (==) 1 1
19:18:41 <lambdabot> Bool
19:19:14 <mm_freak> :t const True
19:19:14 <lambdabot> forall b. b -> Bool
19:19:36 <monochrom> mm_freak: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29808#a29808
19:20:31 <lispy> hey party people
19:20:40 <revenantphx> mm_freak: that'd work
19:20:40 <lispy> how's are the lambdas?
19:21:07 <mm_freak> lispy: they're goneâ€¦  i transformed into SKI =/
19:21:28 <lispy> mm_freak: you're ski?
19:21:34 <mm_freak> monochrom: the code is quite messy for humansâ€¦  could you point me to the relevant line?
19:21:35 <lispy> I thought he was someone else...
19:21:39 * lispy gets confused
19:21:48 <monochrom> I can't yet. I don't know what's happening either. :)
19:21:49 <mm_freak> lispy: SKI, not ski
19:22:05 * benmachine converts all mm_freak's I to SKK
19:22:11 <mm_freak> monochrom: that's good to know =)
19:22:16 <lispy> mm_freak: are you familiar with ghc-core?
19:22:27 <mm_freak> lispy: i know that it exists =)
19:22:42 <lispy> mm_freak: I don't know what problem you're solving but if you like looking at the asm that ghc generates, you should get familiar with ghc-core.
19:22:51 <monochrom> I can read core, but assembly is another level away from core.
19:23:04 <lispy> monochrom: ghc-core displays both
19:23:17 <lispy> (not the best name)
19:23:37 <monochrom> oh, the question is: how hard is it to hack DRM if DRM were implemented in haskell
19:23:52 <monochrom> (and let's say compiled by ghc)
19:24:14 <lispy> oh, you should talk to Iavor Diatchki
19:24:26 <lispy> I don't think he comes on here much, but he reads haskell-cafe
19:24:42 <lispy> his nick on here is "yav" I think
19:24:52 <mm_freak> lispy: it's just a theoretical question, i'm not solving any actual problem
19:24:55 <monochrom> I think there is no difference in strictness because DRM is in IO to begin with.
19:25:18 <mm_freak> monochrom: the actual DRM code can be pure
19:25:37 <lispy> mm_freak: yes, but Iavor was interested in maliciously modified haskell binaries at one point.  Like inserting your own closures into a running program and such
19:25:41 <monochrom> Yes, the "acceptable" function is pure. The branching code has to be in IO.
19:25:55 <mm_freak> like:  if the test passes, result in a computation, which is the actual program, otherwise result in a computation, which just displays an error
19:26:10 <lispy> So he's thought about this before...I think
19:26:34 <monochrom> The branching code (or some crucial branching code) has to be in IO because the branch is about "play music" vs "show dialog box".
19:26:56 <luite> mm_freak: many real DRM implementations already do something like that, they calculate jump addresses from the drm code, or decrypt parts of the program
19:27:07 <revenantphx> night folks
19:27:13 <mm_freak> g'night revenantphx 
19:27:14 <duckinator> hi
19:27:45 <mm_freak> monochrom: at least it's not necessarily a conditional jump, but a function pointer, which you need to manipulate
19:28:07 <JoeyA> I want to group a list of files by size, then inode.  How do I avoid confusing types like [[[FileNode]]] ?
19:28:11 <monochrom> OTOH I'm not married to how my paste does its job. Suppose we use two continuations...
19:28:53 <JoeyA> Obviously a "list of list of lists" isn't confusing by itself, but each layer of list has a different semantic meaning.
19:29:19 <lispy> JoeyA: simplest way is newtype
19:29:27 <JoeyA> One thing I'm trying is using newtype Group a = Group {unGroup :: [a]}
19:29:40 <JoeyA> and using type aliases
19:29:55 <lispy> forget about type aliases
19:29:57 <JoeyA> so a group of files by st_dev / st_ino is called a "DIG"
19:30:03 <JoeyA> so I can say [Group DIG]
19:30:10 <lispy> use actual types, then you can use the type checker to know when you're doing it right
19:30:19 <JoeyA> Good point.
19:30:52 <benmachine> JoeyA: are all the files in the group the same size, inode, etc?
19:31:04 * hackagebot vty-ui 0.4 - A user interface composition library for Vty  http://hackage.haskell.org/package/vty-ui-0.4 (JonathanDaugherty)
19:31:09 <JoeyA> The inner groups are by inode.
19:31:12 <JoeyA> The outer groups are by size.
19:31:27 <JoeyA> And this is just a small part of a seemingly simple file deduplication task.
19:31:29 <benmachine> JoeyA: was just thinking you could use a Data.Map Map FileSize (Map Inode FilePath), or something
19:31:37 <lispy> JoeyA; if you want to write less boiler plate, you can use a type like Group but with a phantom type.  Then use smart constructors to control the setting of the phantom type.  Then use empty types as tags and place them in the phantom type slot.
19:31:43 <benmachine> to make that more obvious
19:32:04 * lispy agrees with benmachine's suggestion.  You *really* want good indexes here
19:32:41 <JoeyA> Well, ultimately I'll probably be storing the file nodes on-disk, so the maps would be on-disk (I heard there's a library for that)
19:32:45 <JoeyA> or maybe in a SQLite database.
19:33:17 <JoeyA> But right now, I'm trying to figure out how to do massive file tree operations with reasonably simple code.
19:33:48 <JoeyA> Another example of a file tree operation is:  find large directories that are identical or nearly identical.
19:33:59 <JoeyA> (as opposed to individual files)
19:34:10 <JoeyA> brb
19:34:20 <lispy> JoeyA: I don't know if a Haskell library for storing a map on disk, but that sounds like what a database would provide you with
19:34:55 <JoeyA> (and I'm doing it in memory for now so I can more quickly come up with ways to simplify my work)
19:35:30 <JoeyA> I'll have accomplished my goal if I have a snazzy combinator library for querying file trees that uses on-disk storage in the background.
19:35:55 <JoeyA> And yes, it's required to be snazzy.
19:37:04 * JoeyA reads about phantom types
19:38:29 <xplat> JoeyA: you can give your phantom types a type class and associate constants, functions, and other types with them
19:38:52 <kmc> if you're using phantom types, you may also want to read about GADTs
19:38:55 <kmc> if you're not already familiar
19:40:18 <xplat> so you could have like a ByInode phantom type with an associated groupEm function
19:41:50 <xplat> then you only have to write stuffGroupedByInode :: Grouped ByInode FileNode = groupEm stuff
19:42:24 <JoeyA> So nothing there actually has the type "Grouped ByInode"
19:42:30 <JoeyA> but the type is used to figure out the function to use?
19:43:00 <xplat> actually stuffGroupedByInode has the type Grouped ByInode Filenode, but nothing has type ByInode
19:43:13 <lispy> JoeyA: Oh, well you should know about hashed-storage then (on hackage) it's a library that darcs uses for indexing a file system by cryptographic quality hashes.
19:43:16 <JoeyA> Making ByInode the phantom type, right?
19:43:24 <xplat> right
19:44:23 <lispy> JoeyA: alternately, whatever library you come up with likely be of interest to darcs.  You might want to join the darcs-users mailing list and get involved :) http://lists.osuosl.org/mailman/listinfo/darcs-users
19:44:54 <JoeyA> My main goal is to get a grip on my massive pile of files.
19:50:45 <JoeyA> When you say data Expr a = ... in a world in a non-GADT setting, does that mean a is required to be for every a?
19:50:56 <JoeyA> Not just a set of a's you're interested in, like Int and Bool
19:51:53 <Cale> JoeyA: right
19:52:16 <kmc> JoeyA, if you write a non-GADT using GADT syntax, every constructor's type will end with (T a b c ...)
19:52:24 <kmc> that is, the type you're defining, applied to the right number of variables
19:52:24 <JoeyA> By the way, how did people come up with this stuff, anyway?
19:52:32 <kmc> never something like (T a Int (Maybe b))
19:52:43 <kmc> btw i do like to write non-GADTs with GADT syntax sometimes
19:52:52 <Cale> JoeyA: Mostly inspiration from category theory
19:53:29 <JoeyA> makes sense
19:53:56 <kmc> JoeyA, have you read TaPL?
19:54:06 <JoeyA> I guess monads in category theory and Monads in Haskell aren't quite identical, but they have the same "shape", if you will.
19:54:17 <kmc> it doesn't cover GADTs iirc, but it should have a lot of references into the theoretical foundations of types
19:54:31 <Cale> JoeyA: Haskell monads are monads in the category of Haskell types and functions
19:54:43 <JoeyA> As in, the laws for category theory monads (I'm thinking of the picture with arrows drawn in a square) happen to work for Haskell Monads
19:54:45 <Philippa> hrmm, has anyone ever suggested Cons parm parm :: T a a .. | as a way of retaining the old ADT syntax?
19:54:54 <Cale> There are other sorts of monads, like monads in the category of sets, or topological spaces
19:55:17 <lispy_> JoeyA: you might find this article helpful: http://blog.codersbase.com/2008/11/phantom-types-existentials-and.html
19:55:24 <kmc> JoeyA, for GADTs you could read the papers like "Simple Unification-based Type Inference for GADTs" and "Complete and Decidable Type Inference for GADTs"
19:55:51 <kmc> and chase references from there
19:55:57 <kmc> most recent-ish papers relevant to Haskell are free online :)
19:56:40 <JoeyA> When you say "category of Haskell types and functions", are "types" and "functions" two separate parameters to "category"?  It's hard to tell rigorous terminology I don't fully understand is.
19:56:52 <kmc> JoeyA, a category has objects and morphisms
19:56:58 <kmc> it is useful to think of objects as types
19:57:01 <JoeyA> I guess the objects are types
19:57:04 <JoeyA> and the morphisms are functions
19:57:04 <kmc> and morphisms as a generalization of "functions"
19:57:08 <kmc> right
19:57:10 <JoeyA> ah
19:57:59 <kmc> to understand the conceptual foundations of Haskell, you do need to read papers.  this is invoked as a point against, but other languages are the same way
19:58:00 <JoeyA> thanks for clearing that up
19:58:30 <JoeyA> But, but, the papers don't make sense! (then again, I read Wikipedia more often than papers)
19:58:41 <lispy> It's true, the OO concepts have been in numerous books and are just assumed background.  But. they too have lots of technical definitions.
19:58:54 <kmc> it's just that nobody thinks they need to read papers on Smalltalk or axiomatic typing of Featherweight Java in order to write Java programs
19:59:01 <JoeyA> It seems like it's easier to understand the foundations by actually programming in Haskell.
19:59:08 <JoeyA> Or do you mean learn Haskell, _then_ read the papers?
19:59:17 <lispy> JoeyA: read as you learn :)
19:59:26 <kmc> JoeyA, read the papers to understand precisely what the machine is doing for you
19:59:27 <JoeyA> Haskell is something that you can tinker with and actually works.
19:59:33 <kmc> JoeyA, which may or may not be required to get shit done
19:59:37 <monochrom> mm_freak: in my paste, lines 153 and 169. Here are two blocks of code doing identical thing but I don't know why it's duplicated. Anyway, each block does: if 3==esi then call putStrLn else call hPutStrLn. "call" becomes jmp because this whole code is in CPS: presumably some register already has pointer to "what to do next after putStrLn/hPutStrLn is done".
19:59:50 <JoeyA> "morphisms  in the category of small categories" don't print "hello world"
20:00:08 <kmc> again, same as other languages.  would-be Haskell users might be scared off by the STG machine paper, but most C users haven't read the Dragon Book
20:00:33 <lispy> JoeyA: No, but papers like scrap your boiler plate will be accessible even though they are actually fairly deep
20:00:45 <JoeyA> I thought the Dragon Book was mainly about compiler writing.  Am I write?
20:00:50 <kmc> yes
20:00:51 <mm_freak> monochrom: ok, so it's really a conditional jump
20:00:59 <JoeyA> right*
20:01:12 <kmc> JoeyA, if a paper doesn't make sense, try to learn its prerequisites by following references.  if you can't find the right reference, ask here
20:01:12 <Cale> If you want to learn category theory, I recommend http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
20:01:30 * lispy downloads to save for a rainy day
20:01:34 <lispy> cale: thank!
20:01:38 <kmc> CT is cool stuff, but not a prerequisite for most papers which use Haskell
20:01:42 <JoeyA> Cool, thanks.
20:01:43 <monochrom> at least for the way I check the checksum. if you have another way of control-flow, I can still try to dissasmble. I think I get the hang of it now. :)
20:02:10 <JoeyA> By the way, to me, it's kind of annoying (I guess) when papers use math italics on Haskell code.
20:02:15 <kmc> (i say "use Haskell" rather than "about Haskell" because Haskell has become de facto standard notation for a whole branch of CS)
20:02:23 <kmc> JoeyA, but lhs2TeX is so pretty!
20:02:24 <JoeyA> As in, making Haskell look like "math"
20:02:29 <kmc> who doesn't want â†’ and operators like âŠ—
20:02:48 <lispy_> JoeyA: I have the same problem even though I've done a lot of latex and a lot of haskell.
20:03:22 <Saizan> Philippa: existentials would still look weird
20:03:24 <lispy_> kmc: to me it represents a departure from the conventional (meaning haskell source code) notation
20:03:53 <JoeyA> yeah.  Italics should represent an idea of something.
20:03:57 <JoeyA> Haskell is real and kicking.
20:04:09 <JoeyA> Haskell is something you can program in _now_
20:04:30 <JoeyA> Then again, can't you program in "math" with Mathematica to an extent?  I don't know.
20:04:42 <Cale> Well, in the sense that you can program mathematicians' minds with it, mathematics is something you can program in now too :)
20:05:13 <Saizan> or monks which write on parchment
20:05:39 <kmc> JoeyA, if you turn on GHC's UnicodeSyntax extension you can use â†’, âˆ€, etc.
20:05:51 <kmc> and unicode in variable / operator / type names is supported out of the box
20:06:06 <lispy_> Cale: do you have any books to help me learn dependent type theory and/or intuitionistic logic?
20:06:15 <kmc> see http://hackage.haskell.org/package/base-unicode-symbols and http://hackage.haskell.org/package/containers-unicode-symbols
20:06:17 <JoeyA> leksah also shows them.
20:06:27 <Cale> lispy_: Not particularly
20:06:46 <Cale> I don't know dependent type theory all that well myself, apart from the basic idea.
20:07:04 <JoeyA> I'm not even talking about that.  I'm talking about things like head :: [a] -> a in italics
20:07:18 <JoeyA> (not that specifically, but I've seen that type of code in mathy italics)
20:08:30 <Cale> JoeyA: I don't find that too weird. It can be a little bit of a burden if you want to actually write it out into a file and the author hasn't done that for you.
20:08:34 <etpace> @hoogle (a -> b) -> a -> a -> (b,b)
20:08:34 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
20:08:42 <Cale> But for reading, it's okay, as long as they lined things up all right.
20:08:57 <kmc> lispy_, people.cs.uu.nl/andres/LambdaPi/LambdaPi.pdf perhaps
20:09:10 <kmc> err that pdf looks a bit broken
20:09:44 <kmc> http://people.cs.uu.nl/andres/LambdaPi/index.html
20:09:47 <kmc> that's the paper anyway
20:09:51 <Saizan> TTFP is one that i've seen recommended
20:11:21 <kmc> what's TTFP?
20:13:13 <Cale> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf -- perhaps this?
20:13:53 <Cale> Uh oh, by downloading this I reproduced it, and the first page says "Not to be reproduced"!
20:13:57 <Cale> heh
20:14:12 <copumpkin> I liked that book
20:14:37 <copumpkin> felt like an overview of what's behind agda without being about agda :P
20:15:52 <Veinor> Cale: oh no!
20:16:34 <Cale> THIS SENTENCE IS NOT TO BE READ
20:16:55 * copumpkin washes his eyes out with soap
20:17:13 <xplat> dependent types are pretty interesting
20:17:30 <copumpkin> anyway, ttfp is very accessible
20:19:09 <xplat> among other things, they sort of take the connection in arithmetic that goes like sum --(iterate)-> product --(iterate)-> power  and take it into the type world as variant --(indexed)-> tuple --(indexed)-> function
20:20:01 <copumpkin> yeah, well tuples are often called dependent sums
20:20:08 <copumpkin> and dependent functions are often dependent products
20:20:19 <copumpkin> even though the terminology is horribly ambiguous, I think
20:20:58 <xplat> the conventional pair is a dependent sum with trivial dependence and the conventional function is a dependent product with trivial dependence
20:21:20 <copumpkin> or the conventional pair is a dependent product from 2 :)
20:21:45 <xplat> yeah, that's how you complete the analogy :)
20:22:16 <xplat> conventional binary variant is dependent sum over 2
20:22:37 <xplat> (Either, for example)
20:24:05 <xplat> there's no 'dependent power' where you can do that to get a functionspace though
20:24:12 <Cale> I'm not sure what purpose the word 'dependent' serves there.
20:24:14 <copumpkin> how is Text.PrettyPrint to work with?
20:24:20 <Philippa> Saizan: you could just handle existentials the same way the GADT syntax does it
20:24:22 <copumpkin> Cale: where?
20:24:41 <Cale> Actually, in most places it was used in the last 10 lines or so :)
20:24:58 <Philippa> Saizan: oh, uh, wait. Sorry, late here, ignore that :-)
20:25:06 <copumpkin> Cale: dependent sum = a tuple where the type of the snd depends on the value of the fst
20:25:22 <copumpkin> Cale: dependent product = a function where the output type depends on the input value
20:25:49 <xplat> Cale: Either a b is the sum over {Left, Right} of T :: {Left, Right} -> * | T Left = a | T Right = b
20:25:53 <Cale> Yeah, but if you think of them like that, you're ignoring the sum/product nature.
20:26:05 <Cale> But I guess so
20:26:07 <copumpkin> Cale: oh, sure
20:26:33 <copumpkin> but that's the easiest way to describe them, I think
20:27:13 <Cale> You could just describe them as the usual sum and product.
20:27:23 <Cale> (In an appropriate category of types)
20:27:40 <copumpkin> how so? indexed?
20:27:52 <xplat> dependent sum = a variant where the constructors are indexed by a value from a type, dependent product = a tuple where you have an element for each value of a type
20:28:17 <xplat> they never end up being the usual sum and product
20:28:56 <Cale> Oh I see, there's a bit of extra information there.
20:29:20 <xplat> they are related to universal and existential quantification.  those are adjoints (each side) to a functor that acts as substitution
20:29:25 <Cale> In that you have a function from the values of some type to the objects of your category.
20:29:38 <Cale> (which indexes the terms of your sum)
20:29:39 <xplat> yes, that is the extra information
20:29:56 <xplat> and it requires extra structure in the category to build it
20:30:36 <xplat> essentially you have to be able to represent families of objects as objects so you have somewhere for the arrow to point to
20:31:42 <xplat> iirc one form of that structure is called a 'fibration'
20:32:46 <copumpkin> you should both join the category theory in agda project :P
20:32:46 <xplat> back before i got really interested in dependent types i messed around with fibrations a bit as part of a semantic model for relational DBs
20:35:04 <xplat> one can use them to express the fact that tuples are indexed by a set of columns
20:36:02 <copumpkin> does anyone here have a favorite pretty-printing library?
20:36:44 <xplat> and projections and joins and such become the fibration-ized versions of all the basic category-theoretic operations you already know and love
20:37:44 <sshc> Is anybody aware of an optical character recognition library in Haskell?
20:38:11 <kmc> copumpkin, Text.PrettyPrint works all right for me
20:42:10 <xplat> dependent type theories seem like they'd make a really productive place to study gÃ¶del incompleteness too, don't know why i've never read much on that
20:42:30 <copumpkin> I think roconnor_ did some work on that didn't he? in coq?
20:42:34 * copumpkin can't remember
20:42:50 <sshc> Which languages does the FFI currently support?
20:43:07 <copumpkin> it doesn't really deal with languages as much as calling conventions
20:43:22 <xplat> in the conventional semantics you don't even have to do any encoding since you can have variables for propositions and proofs literally as sorts in the logic
20:44:45 <notabel> sshc: i don't know of anything for OCR in haskell; your best bet would be binding one of the good free OCR libraries like tesseract or gocr.  they are both C-based, so the FFI should work with them on that level
20:47:39 <kmc> the straightforward way to call any language is through C
20:47:45 <kmc> since most other languages have C FFI as well
20:48:23 <kmc> there are packages on Hackage for Python, Ruby, Erlang, and .NET interop, with various strategies and states of working-ness
20:49:07 <kmc> for C++ i would wrap the API in C first; calling C++ from any other language (including C++ using a different compiler or compiler version) is a world of pain
20:50:51 <kmc> the other straightforward way to call any language is in a separate process
21:04:37 <roconnor_> copumpkin: I did
21:22:40 <copumpkin> I have a bit of an unconventional testing situation
21:23:02 <copumpkin> I was wondering if people can suggest something that can deal with it nicely (although writing my own test runner for this particular case might not be so bad)
21:23:43 <copumpkin> I generate a random Word32 and call an external program with it, grab the output of the external program, process it a bit, and compare it with my function's output on the same Word32
21:24:28 <copumpkin> and ideally, since the program has some overhead, generate a crapload of Word32s, pass them as a block to the external program, and then compare each generated result with the result from my function
21:28:53 <bos> fun
21:29:25 <copumpkin> I basically have my own disassembler and want to compare it against objdump :P
21:29:34 <copumpkin> (the objdump with no obj :P)
21:29:50 <monochrom> objdump without obj is dumb? XD
21:30:01 <copumpkin> lol
21:30:10 <bos> eeeee
21:30:21 <copumpkin> arm-none-eabi/bin/arm-none-eabi-objdump
21:30:22 <copumpkin> :P
21:30:33 <copumpkin> lets me pass raw binary chunks and disassemble those
21:30:42 <copumpkin> without having to put some silly object format around it
21:30:46 <copumpkin> convenient for testing
21:30:59 <copumpkin> but a real pain for distribution of my testsuite, so I'll think of something better eventually
21:31:29 <copumpkin> will probably just settle for hardcoding in some large real programs that have a good sample of common instructions in them, into the test tree
21:38:34 <roconnor_> xplat: do you want to read my thesis?
21:41:43 * hackagebot msgpack 0.3.1.1 - A Haskell binding to MessagePack  http://hackage.haskell.org/package/msgpack-0.3.1.1 (HideyukiTanaka)
21:42:44 * hackagebot msgpack-rpc 0.3.1.1 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.3.1.1 (HideyukiTanaka)
21:42:58 <monochrom> TLDI: 1. noun, Types in Language Design and Implementation, a SIGPLAN workshop. 2. adjective, Too Long, Didn't Implement. :)
21:53:51 <iFire> Learn you a kitten for great good
21:56:02 <lispy> too long, didn't implement.  That's great.
21:56:10 <monochrom> hehe
21:56:30 * bos runs yet another hpc coverage check of text
21:58:01 <monochrom> haskell program coverage coverage check? automatic teller machine machine? glasgow haskell compiler compiler?
22:00:26 <dancor> or, high-performance computing
22:01:45 * monochrom uses static analysis, theorem proving, SAT-solver, and parallelism to achieve: hphpc: high-performance haskell program coverage
22:02:37 <tam1138> hi
22:03:59 <tam1138> i'm writing a haskell program to interact with a berkeley db.  the interface to the latter returns strict bytestrings (as far as i can tell).  is there any benefit to fromChunk'ing them?
22:05:04 <NemesisD> anyone have any suggestion for creating haskell records without the namespace pollution? i'm rather new
22:07:16 <andyjgill> bos: gill hits the link button
22:07:53 <kmc> tam1138, do you need lazy bytestrings for some reason?
22:07:55 <bos> andyjgill: hm?
22:08:29 <kmc> NemesisD, you can prefix each field name with an abbreviation of the type name
22:08:32 <copumpkin> @ask sfvisser_ have you considered giving fclabels users the opportunity to provide their own update function, as well as the getters and setters? I have a situation in which I can perform an update more efficiently than a set + get
22:08:32 <lambdabot> Consider it noted.
22:08:34 <andyjgill> bos: are you getting good results, or getting annoyed?
22:09:11 <kmc> NemesisD, or you can define each record in its own module, and let users the import qualifier if any
22:09:19 <kmc> i think that solution is nicer, but more work for the programmer
22:09:26 <bos> andyjgill: it's working just fine :-)
22:09:26 <kmc> it also lets you take advantage of http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#disambiguate-fields
22:10:14 <tam1138> hmc: not specifically, no, except for the potential efficiency gains over strict.  but because db returns strict, i thought there probably wouldn't be any benefit.
22:10:17 <tam1138> er, kmc
22:10:32 <kmc> right
22:10:43 <kmc> are you looking for a particular efficiency gain?
22:11:06 <tam1138> not yet
22:11:52 <tam1138> except that the lazy side has readInt, which would be quite handy :)
22:11:57 <kmc> heh
22:12:37 <kmc> the lazy type will be better if you want to subsequently append bytestrings, etc
22:14:27 <tam1138> i don't know how to say what i want to do in haskell terms, but in C-ish terms, i'd like to chop up the bytestring and cast each portion to a datatype
22:14:45 <tam1138> that is, the bytestring is storing opaque binary data, and i want to parse it and return a useful data structure
22:15:16 <copumpkin> Data.Binary.Get is probably best, which means you'll need a lazy bytestring
22:15:21 <handonson> has anyone successfully create and show a dialog box with Graphics.Win32?
22:15:21 <Cale> tam1138: You might try using the binary or cereal package
22:15:24 <copumpkin> not that chunking it is particularly expensive
22:15:36 <copumpkin> since it shouldn't need to reallocate the underlying representation
22:15:39 <Cale> cereal is nicer if there might be errors in the data
22:15:41 <handonson> the default one provided by Graphics.Win32.Dialogue doesn't seem to work at all
22:15:48 <kmc> copumpkin, "is not expensive", right?
22:15:54 <Cale> http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/Data-Serialize-Get.html
22:16:01 <kmc> tam1138, slicing a strict bytestring to a subset of its bytes is cheap
22:16:06 <kmc> because it's stored as (array pointer, offset, length)
22:16:07 <copumpkin> kmc: there was a not prefixing the sentence :)
22:16:13 <kmc> oh
22:16:18 <kmc> i read that as a typo for "note"
22:16:21 <kmc> heh
22:16:24 <copumpkin> oh :)
22:16:48 * copumpkin wonders how inefficient it would be to have fclabel lenses generated on the fly
22:16:51 * copumpkin kind of wants them
22:17:01 <tam1138> hmm.  my monad mojo isn't sufficient to figure out how to use Data.Binary.Get.  back to the book!  =)
22:17:04 <NemesisD> kmc: i have no ideas for practicing haskell so i'm going over old C++ homework problems and doing them in haskell. i'm implementing a Weight type (int pounds and int ounces), i would want to make it an instance of Numeric to handle mathematical ops right?
22:17:05 <tam1138> thanks for the pointer
22:17:24 <kmc> NemesisD, yes, if you wanted to overload (+) etc. you would
22:17:31 <kmc> make it an instance of Num
22:18:10 * copumpkin goes with it for now
22:18:14 <copumpkin> optimize later, right? ;)
22:18:17 * copumpkin trembles
22:18:20 <Nereid> so when is Haskell's typeclass hierarchy going to get fixed?
22:18:24 <Nereid> :<
22:18:34 <copumpkin> Nereid: when someone comes up with a good fix :)
22:18:40 <copumpkin> nobody's agreed on what one would look like
22:18:50 <Cale> tam1138: Basically, you can compose Get actions using do-notation, like do x <- getWord16be; y <- getWord8; return (makeMyThing x y)
22:19:00 <Nereid> it would be nice if we could just forget backwards compatibility.
22:19:09 <Cale> tam1138: and then run it on your ByteString using runGet
22:19:40 <copumpkin> Nereid: indeed
22:20:02 <lucca> applicative functors are more concise for that setup
22:20:18 <tam1138> Cale: thanks
22:20:35 <kmc> Nereid, you can do so yourself. you can hide Prelude and build from the  ground up
22:20:39 <kmc> there are alternative preludes on Hackage even
22:20:40 <Nereid> makeMyThing <$> getWord16be <*> getWord8
22:20:41 <copumpkin> idiom brackets are wonderful for that
22:20:43 <lucca> makeMyThing <$> getWord16be <*> getWord8 or something
22:20:44 <lucca> yeah
22:20:45 <Nereid> kmc: I know I can do that.
22:20:46 <Cale> tam1138: cereal is nicer here because it can handle parse failure cleanly
22:20:50 <kmc> it's just that none of them has widespread support
22:21:00 <Nereid> but that doesn't work when I want my Num class to work with the one other packages use.
22:21:03 <tam1138> whoa
22:21:06 <kmc> right
22:21:06 <tam1138> stop talking greek!
22:21:08 <tam1138> =p
22:21:27 <Cale> (http://hackage.haskell.org/package/cereal)
22:21:31 <lucca> and then you can <?> "But I really wanted a ..." to catch errors
22:21:58 <lucca> hm, cereal is new (to me)
22:22:06 <lucca> What does it do over just using Parsec?
22:22:48 <Cale> lucca: It's more for parsing binary data in typically pretty flat formats.
22:23:01 <Cale> It's very similar to the binary library, if you know that
22:23:11 <lucca> parsec can do that fine... is that faster?
22:23:44 <Nereid> parsec is probably slower
22:24:34 <lucca> does binary or cereal have try?  Controllable backtracking is very useful...
22:25:01 <Cale> It has lookahead, but no backtracking at all.
22:25:35 <tam1138> how does one pronounce ">>=" and ">>" ?
22:25:49 <kmc> "bind" and ... not sure
22:25:56 <Nereid> tam1138: you don't. :(
22:26:24 <Nereid> well, I don't
22:26:47 <ski> "bind" and "then"
22:26:47 <Cale> tam1138: >>= is called "bind", you might read >> as "then"
22:26:47 <tam1138> thanks
22:27:08 <Cale> Yeah, they sort of become punctuation
22:27:39 <Nereid> ooh, haddock is shiny now
22:28:45 <Cale> Yeah, I like the new style. The link colours could use some tweaking.
22:28:58 <Cale> There's some annoyingly low contrast text.
22:29:59 <handonson> has anyone successfully created and shown a dialog box with Graphics.Win32?
22:30:17 * kmc has not
22:31:34 <Nereid> oh good
22:31:43 <Nereid> someone got haskell's sdl package working on win32
22:32:39 * ski idly wonders whether it is supposed to look like "isolate :: Int -> Get a -> Get aSource"
22:33:36 <Cale> ski: It's not, but it did for a while.
22:33:52 <Cale> ski: Which page are you looking at?
22:34:47 <Cale> Actually, both cereal and binary are fine now
22:34:49 <ski> <http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/Data-Serialize-Get.html>
22:35:02 <Cale> Yeah, maybe the old .css file is cached in your browser.
22:35:05 <ski> (and every other type signature looks like that, as well)
22:35:21 <ski> hm, maybe .. but i don't recall ever seeing this page before
22:35:28 <Cale> The source links are off to the right now
22:35:46 <Cale> Hold shift and refresh maybe
22:35:46 <Nereid> looks fine to me
22:35:51 <Nereid> ctrl-f5 in firefox
22:36:04 <ski> (however, "data Get a Source" looks fine, with a separating space)
22:36:23 <Nereid> I better go
22:37:03 <JoeyA> I'm toying with using phantom types to type-check sort order, and this is what I came up with:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29809#a29809
22:37:34 <kmc> JoeyA, i would put the 'o' parameter first
22:37:38 <JoeyA> I wonder if it can be improved, or if there's a reason I should be afraid of MultiParamTypeClasses
22:37:47 <kmc> MPTC are very standard by now
22:37:48 <JoeyA> kmc: why?
22:37:52 <kmc> they're used throughout the stdlib
22:37:56 <JoeyA> why first
22:37:59 <kmc> JoeyA, because some classes like Functor will only work that way
22:38:05 <JoeyA> hmm
22:38:12 <JoeyA> ahh
22:38:21 <kmc> instance Functor (OrderedList o) ...
22:38:26 <JoeyA> I read up on GADTs, by the way.
22:38:33 <kmc> (also, OrderedList can be a "newtype" rather  than "data", but this is mostly just a performance optimization)
22:39:17 <ski> (semantics as well, if you care about partially defined (as well as cyclically defined) values)
22:39:24 <kmc> right
22:39:31 <kmc> JoeyA, any reason you didn't derive Show for OrderedList?
22:39:47 <ski> JoeyA : btw, you should not write an instance for `Show' like that
22:40:09 <ski> `Show' is meant to generate a Haskell code representation of values
22:40:13 <JoeyA> I was originally using GADT syntax, and I didn't want to experiment with too much at the same time.
22:40:21 <JoeyA> and forgot to set it back
22:40:22 <ski> (so that `Read' can read it back)
22:40:24 <Cale> ski: http://cale.yi.org/share/Screenshot%20-%20Haddock.png -- here's what it looks like for me
22:40:42 <JoeyA> (can deriving be used with GADT data declarations?)
22:42:05 <kmc> JoeyA, StandaloneDeriving can
22:42:42 <Cale> Oh really?
22:42:51 <JoeyA> extension?
22:43:01 <Cale> Neat, I didn't know that any sort of deriving worked with GADTs at all.
22:43:22 <Cale> JoeyA: Yeah, yet another extension
22:44:10 <kmc> StandaloneDeriving lets you write the context for the derived instance yourselfy
22:45:13 <kmc> for example: deriving instance (Show (f (Mu f))) => Show (Mu f)
22:45:18 <kmc> i was quite surprised to find that works
22:46:13 <copumpkin> it's wonderful!
22:46:17 * copumpkin hugs that instance
22:46:23 <kmc> fun how UndecidableInstances lets you build mutually-recursive dictionaries
22:47:05 <Nereid> ah, StandaloneDeriving looks handy.
22:47:12 <Nereid> I'll keep it in mind for the future.
22:47:14 <kmc> indeed
22:47:23 <kmc> the usual caveats about orphan instances apply for derived orphans too
22:49:12 <Olathe> Are there any synonyms for flip id?
22:49:26 <c_wraith> flip ($)
22:49:27 <kmc> :t flip id
22:49:28 <lambdabot> forall a b. a -> (a -> b) -> b
22:49:32 <c_wraith> which doesn't help you :)
22:49:33 <kmc> flip ($) is probably clearer
22:49:41 <Olathe> Ahh, thanks.
22:49:57 <copumpkin> why not ($ x)
22:50:06 <copumpkin> since I'm assuming that's what you want it for?
22:50:18 <Olathe> @unpl ($ x)
22:50:18 <lambdabot> (\ a -> a x)
22:50:33 <Olathe> Ahh, that's better :)
22:52:06 <Olathe> I'm doing a case to select which function to use on an argument.
22:53:32 <Olathe> Unless it's better to just do 1 -> f xs; 2 -> g xs or something.
22:54:26 <kmc> let c 1 = f; c 2 = g in c n xs
22:54:28 <kmc> maybe?
22:54:51 <Olathe> Hmm...
22:54:52 <bss03> > (case 1 of { 1 -> id; 2 -> const 42; }) 3
22:54:53 <lambdabot>   3
22:54:58 <bss03> > (case 2 of { 1 -> id; 2 -> const 42; }) 3
22:54:59 <lambdabot>   42
22:55:40 <Olathe> I like the function idea.
22:57:23 <kmc> but i think Â«($ x) $ case n of ...Â» might be ok too
22:57:26 <kmc> slightly convoluted, yes
22:57:30 <kmc> it depends on what you want to emphasize
23:01:05 * ski prefers `(case .. of ...) ...'
23:01:08 <ski> (Cale : fwiw .. <http://imagepaste.nullnetwork.net/img/1283925454foo.png>)
23:01:38 <JoeyA> Is it possible to convert the name of a type (given a type variable) to a String?
23:01:52 <roconnor_> JoeyA: I hope not
23:02:00 <opqdonut> with template haskell maybe
23:02:24 <roconnor_> @hoogle a -> String
23:02:25 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
23:02:25 <lambdabot> Prelude show :: Show a => a -> String
23:02:25 <lambdabot> Text.Show show :: Show a => a -> String
23:02:33 <ski> should `String' be converted to `"String"' or to `"[Char]"' ?
23:02:44 <roconnor_> ski: [Char]
23:02:52 <ski> @type show . typeOf
23:02:52 <roconnor_> @hoogle+
23:02:53 <lambdabot> forall a. (Typeable a) => a -> String
23:02:53 <lambdabot> Language.Haskell.Pretty prettyPrint :: Pretty a => a -> String
23:02:54 <lambdabot> Language.Haskell.TH pprint :: Ppr a => a -> String
23:02:54 <lambdabot> Language.Haskell.TH.Ppr pprint :: Ppr a => a -> String
23:03:02 <ski> > (show . typeOf) "String"
23:03:03 <kmc> JoeyA, with Typeable
23:03:03 <lambdabot>   "[Char]"
23:04:11 <roconnor_> > (show . typeOf) id
23:04:12 <lambdabot>   Ambiguous type variable `a' in the constraint:
23:04:12 <lambdabot>    `Data.Typeable.Typeable a...
23:04:16 <Nereid> :t id
23:04:17 <lambdabot> forall a. a -> a
23:04:23 <roconnor_> that's fair
23:04:37 <kmc> > (show . typeOf) (id :: Char -> Char)
23:04:38 <lambdabot>   "Char -> Char"
23:05:11 <kmc> show on Dynamic does something similar
23:05:18 <kmc> > toDyn 7
23:05:19 <lambdabot>   <<Integer>>
23:05:31 <ski> > (show . toDyn) "String"
23:05:32 <lambdabot>   "<<[Char]>>"
23:06:39 <kmc> JoeyA, what do you want this for?
23:07:32 <Nereid> :t toDyn
23:07:33 <lambdabot> forall a. (Typeable a) => a -> Dynamic
23:07:40 <Nereid> pfft
23:09:29 <ski> > fix ((`fromDyn` 42) . toDyn)
23:09:33 <lambdabot>   mueval-core: Time limit exceeded
23:10:32 <bss03> @type fromDyn
23:10:33 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
23:10:42 <ski> @type fromDynamic
23:10:43 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
23:11:55 <Starfire> Does fromDyn use both of its arguments?
23:12:18 <Starfire> Or is it like asTypeOf?
23:12:40 <Veinor> it does use both of its arguments
23:12:54 <ski> > "foo" ++ fromDyn (toDyn "bar") (error "baz")
23:12:55 <lambdabot>   "foobar"
23:13:30 <Nereid> > "foo" ++ fromDyn (toDyn ()) (error "baz")
23:13:31 <lambdabot>   "foo*Exception: baz
23:13:52 <Starfire> Ahh, so it's a fallback value?
23:13:55 <Nereid> yes
23:14:05 <ski> @type fromMaybe
23:14:06 <lambdabot> forall a. a -> Maybe a -> a
23:14:08 <ski> @type maybe
23:14:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:14:12 <Nereid> I was about to mention that
23:14:15 <Nereid> fromMaybe
23:15:08 <ski> hm .. `dynamic :: forall b. (forall a. Typable a => a -> b) -> (Dynamic -> b)' ?
23:16:26 <ski> .. maybe there should be such an operation ?
23:16:27 <Nereid> @type flip fromMaybe . fromDynamic
23:16:28 <lambdabot> forall b. (Typeable b) => Dynamic -> b -> b
23:17:12 <Olathe> @hoogle Ord a => a -> a -> a -> Bool
23:17:12 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
23:17:12 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
23:17:12 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
23:17:22 <Nereid> lol
23:17:27 <Nereid> what are you looking for Olathe?
23:17:38 <ski> @slap hoogle
23:17:38 * lambdabot loves hoogle, so no slapping
23:17:47 <Olathe> I'm looking for between.
23:18:28 <Nereid> so like \x y z -> x <= y && y <= z
23:18:29 <Nereid> ?
23:18:34 <Olathe> Yes.
23:19:02 * ski idly wonders whether one could build some kind of "order theory", based on a `between' operation ..
23:19:07 <Nereid> can't you just write that?
23:19:19 <Veinor> @pl \x y z -> x <= y && y <= z
23:19:19 <lambdabot> (`ap` (<=)) . (((.) . (&&)) .) . (<=)
23:19:22 <Veinor> :D
23:19:23 <ski> (it would be nicer to use a standard name)
23:19:33 <Olathe> Heh
23:19:36 <Nereid> ski: http://en.wikipedia.org/wiki/Ordered_geometry exists
23:19:59 <Nereid> lol Veinor.
23:21:28 <ski> Nereid : ok .. i was thinking on something generalizing preorders or partial orders .. but this seems interesting as well, ty
23:21:32 <Nereid> well
23:22:15 <Nereid> if you had some notion of between, could you derive the axioms for a preorder or whatever?
23:22:46 <Nereid> maybe not
23:23:29 <Nereid> depends on what you mean by between, perhaps.
23:25:24 <ski> i suppose i've been pondering several distinct ideas .. one would be to just take `(x,y,z) |-> x =< y /\ y =< z' in a preorder (or partial order), and try to see what properties hold, and what would be needed to rederive the original operations and laws, and then consider loosening of that
23:25:59 <JoeyA> Thanks for the help, y'all.  This turned out quite nicely:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29811#a29811
23:26:30 <ski> another was some loose idea of trying to have a theory for the relationship between points on a circle .. there is no global ordering, but it seems like one might be able to define some kind of local ordering
23:26:50 <JoeyA> (using types so you can say group people :: [Group ByFirstName Person])
23:27:29 <robertmassaioli> Are all Haskell compilers supposed to support the forall. language extension? Or does Haskell Prime make it standard?
23:27:44 <kmc> Haskell Prime is a process, not a language
23:27:51 <kmc> Haskell 2010 is the first language produced by that process
23:27:55 <kmc> and does not include 'forall'
23:28:03 <kmc> http://www.haskell.org/pipermail/haskell/2009-November/021750.html
23:28:26 <kmc> i presume *some* iteration of Haskell Prime will introduce it
23:28:31 <robertmassaioli> kmc: Ah, my mistake and ah well, I was hopeful. Thankyou, I'll take a read.
23:28:40 <kmc> for now, it is supported by a number of compilers
23:29:00 <kmc> but also, that syntax is used for more than one type-system purpose
23:29:26 <ski> JoeyA : i would avoid using `Show' at all, instead using just separate function, or maybe (if it's warranted) introduce another class
23:29:33 <robertmassaioli> kmc: Well in that case I feel reasonably safe using it. But what do you mean by more that one type-system purpose?
23:30:17 <kmc> in GHC it introduces lexically scoped type variables, describes higher-rank types, instantiates polymorphic types in an impredicative way, and (confusingly) performs existential quantification for constructors
23:30:29 <kmc> it does any of those, depending on how you use it
23:31:15 <ski> ("instantiates polymorphic types in an impredicative way" meaning ?)
23:31:27 <JoeyA> ski: Hmm, why?  Because show-ing something typically shouldn't pretty-print with newlines?
23:31:29 <kmc> instantiate a polymorphic type at a polymorphic type argument
23:31:33 <robertmassaioli> kmc: ah right, that makes sense. I read through a wiki page that explained the existential quantification use.
23:31:35 <kmc> which requires ImpredicativeTypes
23:31:40 <kmc> [forall a. a] and the like
23:31:52 <ski> JoeyA : `Show' is meant to generate valid Haskell code
23:31:57 <JoeyA> ah
23:32:00 <kmc> ImpredicativeTypes is becoming deprecated too
23:32:04 <JoeyA> like ByteString's show... :-)
23:32:28 <robertmassaioli> kmc: thanks :)
23:32:29 <Nereid> ski> another was some loose idea of trying to have a theory for the relationship between points on a circle .. there is no global ordering, but it seems like one might be able to define some kind of local ordering
23:32:35 <kmc> robertmassaioli, other compilers (UHC, others?) have an explicit "exists" quantifier for existentials, making them first-class in a way GHC lacks
23:32:39 <Nereid> yes, by covering the circle with the real line
23:32:44 <ski> JoeyA : if you really need a class (which i doubt), you could always introduce `class Portray a where ...' or something
23:32:46 <Nereid> for instance
23:33:51 <ski> Nereid : but there is no continuous section to that covering ..
23:34:01 <Nereid> so?
23:34:24 <ski> i wanted to speak in terms of elements of the circle
23:34:26 <NemesisD> what do you guys use to unit test (if there is such a thing as unit testing in functional languages)
23:34:30 <NemesisD> hunit?
23:34:31 <JoeyA> hmm, I wonder if prettyclass is any good.
23:34:38 <ski> (or really, more abstractly .. using that as an example)
23:34:50 <Nereid> ski: like how?
23:35:09 <ski> Nereid : i don't know :)
23:35:16 <Nereid> (I can't see a way you would do that in a way that's preserved under topological automorphisms of the circle)
23:35:27 <Cale> ski: ah, hehe, text web browser :)
23:35:28 <JoeyA> I guess it is, but it's a little more fully-featured than what I'm thinking.
23:35:36 <c_wraith> NemesisD, There are a bunch of options.  if the tests are pure, quickcheck, typically.
23:35:37 <ski> Cale : w3m, yes
23:35:41 <JoeyA> renderStyle  :: Style  -> Doc  -> String -- the you have to specify a style.
23:35:46 <Cale> ski: It'd probably be a good idea to tell someone about that
23:35:57 <c_wraith> NemesisD, if the tests involve IO, something like HUnit
23:36:02 <SpawN6> Sup guys, anyone here?
23:36:03 <JoeyA> I just want a variant of Show that's good for printing things to the command-line for debugging purposes.
23:36:10 <Cale> (but I'm not sure who)
23:36:19 <JoeyA> No, all the Haskell coders flocked to F#, last I heard.
23:36:26 <JoeyA> (jk)
23:36:26 <Nereid> lol
23:36:33 <ski> (Cale : me neither ..)
23:37:00 <SpawN6> anyone wants to help me? I have a python code which is messed up
23:37:00 <SpawN6> http://codepad.org/ZSJGV2l4
23:37:07 <ski> JoeyA : are you going to use it on lots of types ?
23:37:08 <SpawN6> anyone care to help me, please?
23:37:12 <NemesisD> c_wraith: do the two play together? I think there will be a minimal IO component to this module
23:37:18 <Nereid> SpawN6: this isn't ##python
23:37:19 <ski> JoeyA : .. polymorphically ?
23:37:30 <Nereid> or #python, I'm not sure which is the right one
23:37:46 <JoeyA> ski: Not a whole lot, but it'd be nice to be able to pretty-print structures with more than one dimension.
23:37:46 <c_wraith> NemesisD, There are frameworks that integrate both nicely.  I can't recall the names of them, but check hackage
23:37:51 <JoeyA> (when testing things)
23:38:05 <ski> JoeyA : what do you mean by "more than one dimension" ?
23:38:13 <Nereid> ski: arrays
23:38:20 <JoeyA> like a list
23:38:20 <Nereid> maybe
23:38:25 <NemesisD> c_wraith: ok. different question. is there a smarter way to implement the arithmetic operators for this trivial data type? http://pastie.org/1145234
23:38:26 <JoeyA> (more like, a list of lists or somesuch)
23:38:51 <JoeyA> Where it's hard to read [[1,2,3],[4,5,6,7],[8,9]] for large values of that.
23:38:52 <Cale> SpawN6: At a glance, your indentation is really messed up there.
23:38:56 <Nereid> NemesisD: is that really how you want to implement (*)?
23:39:10 <ski> JoeyA : so you want to pretty-print both `Foo', `[Foo]' and `[[Foo]]', e.g. ?
23:39:14 <Nereid> wait, does it even make sense to implement (*)?
23:39:23 <JoeyA> It'd be a class, I suppose.
23:39:32 <c_wraith> NemesisD, at the very least, you could make a helper function out of "fixWeight . Weight"
23:39:35 <NemesisD> i could convert it to an integer of ounces first i guess?
23:39:44 <JoeyA> (again, mainly for debugging and playing with Haskell)
23:40:08 <Nereid> NemesisD: what you have there is fine imo.
23:40:10 <c_wraith> err, well, actually, (fixWeight .) . Weight
23:40:15 <JoeyA> So it would probably have to use plenty of undecidable, incoherent, etc. instances to show everything nicely.
23:40:33 <c_wraith> Which basically works out to a custom version of fixWeight that doesn't take a weight.
23:40:41 <ski> NemesisD : how do you intend to implement `fromInteger' ?
23:40:41 <c_wraith> but instead takes the two sub-values
23:41:08 <Nereid> ski: this is part of the problem with the existing number class hierarchy. :(
23:41:22 <ski> Nereid : yeah, it sucks :(
23:41:24 <Nereid> fromInteger really only makes sense in rings.
23:41:27 <NemesisD> ski: fixWeight $ Weight 0 i
23:41:48 <ski> (the initial ring)
23:41:53 <Nereid> indeed
23:42:29 <c_wraith> NemesisD, I might suggest a slightly different overall approach:
23:42:40 <c_wraith> Have the Weight type store only ounces internally
23:42:49 <c_wraith> And only convert when explicitly requested
23:42:51 <ski> however, it appears (barring `(*)') that NemesisD only wants a different representation of `Integer'
23:42:56 <Nereid> indeed.
23:43:11 <Nereid> so you could pretty much newtype it.
23:43:18 <Nereid> or something
23:43:42 <c_wraith> Yeah, my approach would let you newtype and derive Num.  You just would want a custom Show instance
23:43:47 <ski> NemesisD : also, i would use `divMod', rather than `div' and `mod' separatedly (with the same denominator)
23:44:27 <Nereid> that would also prevent any problems arising from forgetting to use fixWeight
23:45:25 <ski> (hm .. OCaml has a thing where you can export from a module the constructors of a datatype, such that you can only use them for pattern-matching, not for constructing)
23:45:46 <Nereid> weird
23:45:59 <c_wraith> ski: you can approximate that with view patterns, I guess.  slightly uglier
23:47:03 <NemesisD> ski: alright i think at this point im going to figure out a decent test suite so i can be sure i don't bork the newtype approach
23:47:32 <ski> JoeyA : hm .. i'm not sure i see why it would need "plenty of undecidable, incoherent, etc. instances to show everything nicely"
23:47:39 <Nereid> quickcheck?
23:48:26 <NemesisD> Nereid: me? yeah i suppose so
23:48:34 <Nereid> yes you
23:48:36 <Nereid> :P
23:50:49 <JoeyA> ski: You might want to display a [Thing] differently than a normal [a].
23:51:41 <NemesisD> how do you guys typically lay out a project directory with tests, or do you have examples of libs that use quickcheck. my main language is ruby but i don't know how the haskell community organizes things
23:52:05 <JoeyA> Though maybe it'd be better for the instance PrettyShow [a] to look at show string lengths to decide how to organize things.
23:52:06 <ski> JoeyA : i suppose so. btw, it would be possible to pretty-print both `Foo', `[Foo]' and `[[Foo]]', &c., also allowing for "display a `[Thing]' differently than a normal `[a]'", just using combinators, i think
23:52:45 <JoeyA> good point
23:53:16 <ski> JoeyA : consider `fooPrinter :: Printer Foo', `listPrinter :: Printer a -> Printer [a]', `thingListPrinter :: Printer [Thing]', where `type Printer a = Style -> a -> String' (or whatever)
23:54:04 <ski> (probably you'd want to pass in an indentation level somewhere too, at least)
23:54:57 <iFire> poll: what editor do you guys use to edit haskell code
23:55:01 <ski> JoeyA : hm .. "look at show string lengths to decide how to organize things" ?
23:55:09 <ski> iFire : mostly Emacs
23:55:35 <ski> @poll-list
23:55:35 <lambdabot> ["\"blah\"","doesButtbotSuckQuestionMark","logoVotingMethod","naming","remove@src"]
23:55:40 <ski> @help poll
23:55:40 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
23:55:48 <Veinor> ... buttbot?
23:55:52 <Veinor> we had a buttbot instance?
23:56:00 <NemesisD> im using vim right now but its not really well configured yet for haskell :/
23:56:09 * ski has no idea ..
23:57:48 <Cale> NemesisD: The main thing you need to do is set expandtab
23:58:15 <Cale> Veinor: I don't think so...
23:58:56 <Cale> (I would have banned it immediately)
23:59:48 <Veinor> haha
