00:09:55 <ivanm> preflex: seen Heffalump
00:09:55 <preflex>  Heffalump was last seen on #darcs 20 hours, 18 minutes and 22 seconds ago, saying: etarasov: if you mention specific functions that need docs, I can have a go, too
00:10:25 <ski> Axman6 : i'm in favour of `done' (iirc Thompson's book uses that as well)
00:10:37 <Axman6> :)
00:10:43 <Axman6> heh, i said that hours ago
00:11:00 * pumpkin yawns
00:11:24 <ivanm> pumpkin: did you lose your co ?
00:11:33 <pumpkin> yeah, that's on the other computer
00:14:35 <kmc> hi pumpkin
00:14:42 <pumpkin> omg hi!
00:14:45 <pumpkin> long time no see
00:14:52 <kmc> indeed
00:16:21 <kmc> holy crap new version of plugins
00:16:38 <ivanm> yeah
00:16:45 <ddarius> pumpkin: I see you survived.
00:16:48 <ivanm> I guess ManateeLazyCat prodded dons enough
00:17:08 <ivanm> huh, looks like we have another kiwi to join hamishmack and blackh
00:17:11 <pumpkin> ddarius: twas a miracle, but the taxi driver didn't murder me for waking him up
00:18:13 <lexande> apparently the category of sets of NF is not cartesian closed
00:18:40 <Axman6> ivanm: who?
00:18:46 <Axman6> ah, Biggles 
00:19:02 <ivanm> yup
00:22:32 <Biggles> hello i am Biggles
00:22:48 <Axman6> welcome
00:22:52 <Biggles> i can programming a computer but it is built from sticks
00:23:07 <kfish> sticks is good lambda
00:23:10 <Biggles> now the entire population of new zealand programs haskell by consensus
00:24:23 <cncl_> where does the haskell platform for os x install the packages?
00:30:30 <ivanm> Axman6: you use the platform on osx, don't you?
00:30:43 <Axman6> sure, i have no idea what the answer is though
00:31:19 <cncl_> :/
00:31:23 <cncl_> does the uninstaller remove them?
00:32:09 <cncl_> ah
00:32:44 <cncl_> it's /Library/Frameworks/HaskellPlatform.framework
00:43:19 <hinkes> I'm reading "Real World Haskell"  Do people like that book?
00:43:43 <ivanm> yes
00:44:06 <ivanm> it's probably the only non-beginners book on Haskell
00:44:41 <ivanm> wait, I lie; the various algebra of programming, etc. might not be aimed exactly at beginners
00:44:53 <kmc> hinkes, i do
00:45:04 <deteego> I don't think those are specifically aimed at Haskell
00:45:06 <ivanm> let's say that RWH is the only non-beginners Haskell book written specifically about learning Haskell rather than using Haskell to learn FP, etc.
00:45:13 <ivanm> deteego: right
00:45:20 <ivanm> hence my new qualified statement ;)
00:46:04 * ivanm 's first counter-thought was "Computationally-Oriented Matroids", which would possibly only be a beginners book from the POV of a Haskell beginner
00:46:06 <kfish> RWH is awesome!
00:46:35 <kfish> hinkes, so is http://nostarch.com/lyah.htm
00:46:59 <Axman6> anyone know why the second version of c here causes an error, when the first version works perfectly: http://hpaste.org/40059/int_to_char
00:47:03 <hinkes> Good to know,  As a beginner reading a non-beginner book, I'll report in.
00:47:20 <ivanm> hinkes: have you programmed before?
00:47:35 <ivanm> Axman6: what error?
00:47:43 <Axman6> ivanm: it's there
00:47:48 <Axman6> i think there's problems with RWH, but in general it's good
00:47:51 <ivanm> gah, missed that
00:48:03 <ivanm> Axman6: because the array doesn't have a value with an index of -1 ?
00:48:16 <ivanm> > ord '0' + fromIntegral (-1)
00:48:17 <lambdabot>   47
00:48:18 <Axman6> it should never be given a value of -1
00:48:26 <ivanm> Axman6: well, it is
00:48:30 <Axman6> it's not
00:48:38 <Axman6> or i'd be getting weird results
00:48:39 <ivanm> GHC thinks it is!
00:48:44 <Axman6> > chr (ord '0' + fromIntegral (-1))
00:48:45 <lambdabot>   '/'
00:48:53 <Axman6> i'd be getting lots of those
00:49:13 <hinkes> Yeah, I'm a software engineer (not that that mean anything really).  I just wanted to learn something different and interesting.  Haskell has been on my TODO list for a while.
00:49:21 <ivanm> > let cs = listArray (0,9) "0123456789" in cs ! (-1)
00:49:21 <lambdabot>   *Exception: Error in array index
00:49:48 <ivanm> hinkes: well, RWH is kinda also suitable for Haskell beginners that have done a fair amount of programming in C, Java, etc. before as well
00:50:26 <ivanm> > let cs = listArray (0,9) "0123456789" in map ((!) cs) [0..9]
00:50:27 <lambdabot>   "0123456789"
00:50:32 <kfish> if you like programming you will love haskell
00:50:32 <hinkes> ivanm: thanks, good to know.
00:50:44 <kfish> yay haskell!
00:50:56 <ivanm> Axman6: wrap it in a trace statement that prints the value of x
00:50:58 <Ozgur> exit
00:51:48 <ivanm> @hoogle UArray
00:51:48 <lambdabot> Data.Array.Unboxed data UArray i e
00:51:48 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
00:51:48 <lambdabot> Data.Array.IO.Internals castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
00:52:13 <hinkes> I've played with some simple "hello world apps" (qsort, et al).  I like it!
00:52:25 <ivanm> Axman6: just tried it here explicitly with UArray; works fine
00:52:41 <ivanm> but that error pops up if I use -1
00:52:51 <Axman6> how very odd, it should never get a negative number
00:53:05 <Axman6> and it doesn't get it when i use the other version
00:53:28 <ivanm> Axman6: maybe a strictness thing?
00:53:31 <Axman6> something is very fucked
00:53:34 <Axman6> no
00:53:39 <ivanm> try adding a strictness bang to the x in the second version
00:53:48 <ivanm> or removing the bang from the first version
00:53:48 <Axman6> because if i debug the original version, it never gets a -1
00:53:57 <Axman6> c !x = traceShow x $ chr (ord '0' + fromIntegral x)
00:54:03 <Axman6> gives the right results
00:54:19 <ivanm> *shrug*
00:54:30 <Axman6> it should be a 5, not a -1
00:54:38 <ivanm> what's the type of c ?
00:54:40 <Axman6> hmm, i wonder if that's it...
00:54:46 <olsner> Axman6: the result *changes* when you add strictness?
00:54:52 <Axman6> might be that the number actually needs to be an Integer
00:55:23 <Axman6> ah ha! that does it
00:56:10 <ivanm> what type was it using?
00:56:21 <Axman6> Int
00:56:26 <Axman6> like the type said
00:56:28 <ivanm> ... wtf?
00:56:42 <ivanm> how does changing the type make a difference for something like that?
00:56:44 <Axman6> it shoud have been Integer, the calculations use very big numbers
00:56:51 <ivanm> Axman6: but 5 vs -1 ?
00:57:03 <Axman6> the numbers are > 2^32
00:57:14 <Axman6> it's the pidigits shootout program
00:57:17 <ivanm> ahhh
00:57:24 <ivanm> so you're not actually doing any real work then... ?
00:57:25 <ivanm> :p
00:57:32 <Axman6> i've made i very slightly faster
00:57:58 <ivanm> how can you make sqrt (-1) faster?
00:58:00 <ivanm> :p
00:58:46 <Axman6> huh?
00:59:10 <ivanm> re-read what you wrote...
00:59:21 <Axman6> it*
01:03:06 <vanadium> I wish RWH had gone into more effort about architecturing an application instead of going, hey, look at these monad transformers
01:03:08 <ivanm> Axman6: I'm guessing that your c was a contrived, cut-down example that was too cut-down to be able to tell the problem?
01:11:14 * ManateeLazyCat pasted "search exe program " at http://paste2.org/get/999766
01:11:14 <ManateeLazyCat> Hello cabal people, above code can replace with Cabal style?
01:11:31 <ivanm> ManateeLazyCat: in case you didn't see, dons made a new release of plugins
01:11:47 <ManateeLazyCat> ivanm: Yep, i have notice it. :)
01:12:00 <ivanm> as for your question.... where were you wanting to put that?
01:12:10 <ManateeLazyCat> ivanm: Too busy on gtk2hs-0.12.0, haven't time try.
01:12:23 <ManateeLazyCat> ivanm: ???
01:12:30 <ivanm> the checking bit shouldn't be necessary as you list buildtools for Cabal, but then again it doesn't specify the package name
01:12:47 <ivanm> what is the point of checkGtk2hsBuildtools and getAllExecuteFiles ?
01:13:13 <ivanm> ManateeLazyCat: I think there are better ways of checking if a certain program is in the search path though
01:13:20 <ivanm> check directory and FilePath
01:13:58 <ManateeLazyCat> ivanm: Current, when user not install gtk2hs-buildtools correctly, it will notify you "can't found gtk2hsChs", but user don't know gtk2hsC2hs is come from package 'gtk2hs-buildtools', so i print better error....
01:14:24 <ManateeLazyCat> ivanm: check directory and FilePath?
01:14:31 <ivanm> those libraries
01:14:54 <ManateeLazyCat> ivanm: If have some cabal function do same work, i glad to switch...
01:15:07 <ivanm> yeah, I would say that that is an error with Cabal not being able to tell which packages contain build tools
01:15:13 <ManateeLazyCat> ivanm: Can you more detail? I'm confuse.
01:15:24 <ivanm> ManateeLazyCat: one possibility is to split gtk2hs-buildtools up into gtk2hsChs, etc.
01:15:52 <ManateeLazyCat> ivanm: Well, i don't want do those change.
01:16:02 <ManateeLazyCat> ivanm: Axel don't like my solution.
01:16:06 <ivanm> which is?
01:16:15 <ManateeLazyCat> ivanm: But i think getAllExecuteFiles can works well on Windows and Linux.
01:16:23 <ManateeLazyCat> ivanm: He don't like getAllExecuteFiles
01:16:36 <ivanm> ManateeLazyCat: you _might_ be able to use that with a Build-Type: Custom and put it into Setup.hs
01:18:05 <ManateeLazyCat> ivanm: Build-Tyep?
01:18:21 <ivanm> you can specify a Build-Type in your .cabal file
01:19:00 <ManateeLazyCat> ivanm: What's Build-Type use for, I mean?
01:19:29 <ivanm> if it's Simple, then Setup.hs just contains the two lines of #!/usr/bin/runhaskell main = defaultMain (or whatever it is)
01:19:40 <ivanm> if your Build-Type is Custom, then your Setup.hs can do more fancy stuff
01:20:15 <ManateeLazyCat> ivanm: It has 'Custom' now.
01:20:33 <ivanm> I'm not sure how to use/write a custom Setup.hs though
01:21:05 <ManateeLazyCat> ivanm: Do you know any cabal function can search program in PATH?
01:21:20 <ManateeLazyCat> ivanm: Axel want buildin cabal function, but i haven't found one.
01:21:29 <ivanm> in Setup.hs, you can use other libraries
01:21:39 <ivanm> but you should be careful and stick to the ones that come with GHC
01:21:45 <PirateUnderwear> Hello, what would be the easiest way to install Haskell?
01:22:05 <ivanm> (even then, there was a situation where texmath used a version of process for Setup.hs that came with 6.10, but claimed to work with base-3)
01:22:11 <ivanm> @where platform
01:22:11 <lambdabot> http://hackage.haskell.org/platform/
01:22:14 <ivanm> PirateUnderwear: ^^
01:22:18 <ivanm> if you're on Windows or OSX
01:22:24 <ivanm> if you're on Linux, check your package manager
01:23:23 <PirateUnderwear> ivan, I am using Ubuntu. I tried to compile it from source because I wanted to try the snap framework but it wasn't working correctly. 
01:23:58 <ivanm> PirateUnderwear: OK, if you want to compile from source:
01:24:07 <ivanm> 1) get a generic Unix GHC binary
01:24:09 <ivanm> @where ghc
01:24:09 <lambdabot> http://haskell.org/ghc
01:24:22 <ivanm> 2) get the source tarball for the Haskell Platform
01:24:32 <ivanm> 3) Unpack that tarball, go into it and build it
01:24:50 <ivanm> alternatively to 2) and 3), install cabal-install via the bootstrap script and then install what you want
01:25:15 <PirateUnderwear> ivan, Thanks! I'll try it out now.
01:25:17 <pozic> How is an Int (lazy) stored internally? 
01:25:44 <pozic> Something like int ** x?
01:26:37 <ManateeLazyCat> ivanm: Cabal-1.6 have different with Cabal-1.8? Axel let me test cabal-1.6 with getAllExecuteFiles.
01:28:45 <atude> I know I keep asking this but I really need a fast way to learn as much as possible and haskell seems to be the most effiecient at doing such. Is there a website where I can view many mathematical concepts and implement them with haskell? (as in examples etc)
01:29:23 <ivanm> ManateeLazyCat: the .cabal files are the same for the most part
01:29:47 <ivanm> the only change is that 1.8 allows you to have executables using the internal libraries, but that prevents you from using Haddock
01:30:03 <ivanm> the API is probably different if you're trying to do stuff in Setup.hs though
01:30:07 <ivanm> preflex: seen dcoutts
01:30:08 <preflex>  dcoutts was last seen on #ghc 18 hours, 16 minutes and 35 seconds ago, saying: * dcoutts disappears for a while
01:30:36 <ManateeLazyCat> ivanm: I see, i download cabal-1.6 test, question is why need cabal-1.6 since cabal-1.8 have release?
01:30:48 <ivanm> no reason
01:31:00 <ManateeLazyCat> @hoogle exitFailure
01:31:01 <lambdabot> System.Exit exitFailure :: IO a
01:31:01 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
01:31:04 <pozic> atude: mathematics and Haskell are two completely different topics.
01:31:29 <ivanm> except that if you have both an executable and a library in the same .cabal file, you don't want to specify "Cabal-Version: >= 1.8" (or whatever the syntax is)
01:31:38 <ivanm> well, not and use the new syntax, etc.
01:31:48 <atude> pozic: please note what I'm asking
01:32:13 <Baughn> atude: It's probably a bad idea to try learning two things at the same time. You won't necessarily be able to tell whether your understanding of math or of haskell is at fault.
01:32:14 <ManateeLazyCat> atude: Real World Haskell.
01:32:22 <pozic> atude: what do you want to learn? 
01:32:27 <pozic> atude: Haskell or mathematics?
01:32:28 <atude> Baughn: no..
01:32:35 <atude> pozic: both.. c
01:32:44 <pozic> atude: I agree with Baughn.
01:32:50 <atude> I don't... at all
01:33:08 <atude> but that's not what we're talking about
01:33:09 * Baughn is on the other hand attempting to learn python while reverse-engineering an unknown file format, so... eh.
01:33:24 <pozic> Baughn: I also did that once ;)
01:33:47 <Baughn> pozic: Did I mention it looks to be inspired by x86 assembly, but targets a cut-down virtual machine?
01:33:50 <pozic> But learning Python after Haskell is like riding a tricycle after having flown the Spaceshuttle. 
01:34:05 <Baughn> Yeah, I noticed. :P
01:34:22 <Baughn> ..I think I'll switch back to haskell for this one. >_>
01:34:32 <pozic> Baughn: what is 'it'?
01:34:57 <Baughn> pozic: A reimplementation of the engine for a visual novel.
01:35:20 <Baughn> pozic: Other people have done a lot of the reverse-engineering work already, thankfully.
01:35:43 <pozic> Baughn: a visual novel? For what company do you work? And why are you reverse-engineering that?
01:36:22 <Baughn> pozic: Google, but they're not involved. Mainly I just like the novel (Ever17), think it should be accessible to more people, and want to do a case study of Haskell vs. Java/Android.
01:37:07 <pozic> Baughn: do you program in Haskell for Google projects?
01:37:30 <Baughn> pozic: I doubt it, but we'll see. I don't actually start working there until.. monday.
01:37:40 <ManateeLazyCat> ivanm: Suggestion for my project on Google Code?
01:37:50 <ivanm> *shrug*
01:37:53 <ManateeLazyCat> ivanm: Damn Google, i can't use manatee.
01:38:01 <ivanm> oh, project name?
01:38:09 <ivanm> nope; I'm hopeless at picking names
01:38:11 <Baughn> ManateeLazyCat: manatshirt
01:38:26 <ManateeLazyCat> ivanm: http://code.google.com/p/manatee-ile/source/checkout
01:38:29 <ivanm> I mean, look at the names of my packages: SourceGraph, Graphalyze, haskell-updater, etc.
01:38:44 * Baughn goes for allegorical. Hermes, skynet, etc.
01:38:47 <ManateeLazyCat> ivanm: But manatee-ile is bit hard to read/understand?
01:38:54 <Baughn> ManateeLazyCat: What's it do?
01:39:11 <ivanm> Baughn: IIUC, it's a cross between an IDE and a DE
01:39:12 <Baughn> Oh, I see..
01:39:16 <ManateeLazyCat> Baughn: The Haskell/Gtk+ Integrated Live Environment
01:39:24 <Baughn> ManateeLazyCat: Is "Mother" free?
01:39:28 <ivanm> ManateeLazyCat: "Hile" ?
01:39:40 <ManateeLazyCat> Baughn: Mix gnome and emacs style.
01:40:25 <ManateeLazyCat> Baughn: http://www.flickr.com/photos/48809572@N02/ Then you know what's it.
01:41:12 <Baughn> ManateeLazyCat: I don't know, I think I prefer xmonad..
01:41:22 <Baughn> ManateeLazyCat: Okay. How about 'Hephaestus'?
01:41:22 <ManateeLazyCat> Baughn: It's not WM. :)
01:41:43 <ManateeLazyCat> Baughn: Name must use manatee.
01:41:56 <ManateeLazyCat> Baughn: Or relative to manatee.
01:41:58 <Baughn> Hm
01:42:01 <pumpkin> dugong?
01:42:06 <Razz_> Could someone explain to me how 'runMSM' and 'interp' work together? I need to access the state from either interp or interpInst:   http://hpaste.org/40060/vm
01:42:17 <Baughn> ManateeLazyCat: Siren
01:42:32 <Razz_> 'interp' however was given as part of the assignment
01:42:33 <pumpkin> Baughn: that's a bit obscure :)
01:43:01 <pumpkin> I guess dugong isn't much more obvious
01:44:14 <Baughn> pumpkin: Not much more obscure than a middleware library called "hermes". :P
01:44:57 <Botje> Razz_: interp defines a function run :: MSM ()
01:45:01 <ManateeLazyCat> Conclusion: Damn google.
01:45:21 <Botje> runMSM runs that function, with the program you give it as the prog field in the initial state.
01:45:57 <Razz_> Botje: yeah, but how does interp have access / get access to the state? initial p creates a state right?
01:46:31 <Botje> how is MSM defined?
01:46:40 <Razz_> Botje: I want to update the state after each instruction, using interpInst to execute that.
01:46:51 <Razz_> Botje: Like this newtype MSM a = MSM ( State -> Maybe (a, State) )
01:46:58 <Botje> ah.
01:47:08 <Botje> so the f in runMSM has type State -> Maybe (a, State)
01:47:25 <ManateeLazyCat> ivanm: Which is best mail-list server?
01:47:32 <ivanm> for what?
01:47:33 <Botje> initial p is the State here, and that's used to start the execution
01:47:37 <ivanm> and how do you expect me to know? :p
01:47:41 <Botje> Razz_: did you receive any other functions of type MSM a ?
01:48:35 <Razz_> Botje: I had to implement get, set and modify functions to manipulate the state, let me paste the code, 2 sec
01:48:40 <ManateeLazyCat> ivanm: You don't know everything? ;)
01:48:47 <ivanm> nope
01:48:56 <atude> why not?
01:49:13 <Razz_> Botje: http://hpaste.org/paste/40060/vm_full#p40061
01:49:43 <ivanm> atude: couldn't be bothered :p
01:50:42 <Botje> Razz_: that looks like a weird definition for getInst
01:51:22 <Razz_> Botje: True, just stubbed it out for now so the whole thing compiles
01:51:24 <Botje> Razz_: however, it looks like you defined get and set already
01:51:46 <Razz_> Botje: yeah, but how can I use them in interp / interpInst?
01:52:02 <Botje> in a do block
01:52:09 <Razz_> Botje: I need a MSM for that but I only have a state right?
01:52:26 <Botje> interpInst foo = do state <- get
01:52:34 <Botje> and then do stuff with state.
01:53:20 <Razz_> Botje: thx very much, I've been stuck on that for a while now!
01:53:52 <Botje> it takes a while for monads to 'click' in your brain, don't worry
01:54:02 <Botje> we all have the scars and ducttape to prove it :)
01:54:30 * ivanm heads off
01:54:53 <Razz_> Botje: lol :P
01:55:18 <Botje> @quote explo
01:55:18 <lambdabot> ghc says: My brain just exploded.
01:55:27 <atude> I have a problem...
01:56:15 <atude> My Mathematical usages seems to be limited to that of discrete math, not so much continuous math
02:05:19 <Botje> so jump on #math and ask for some material?
02:07:08 <atude> no offense but those guys are way to difficult to talk to
02:07:39 <atude> I find it that programmers are much easier to talk to since they can relate to most of these types of problems in one way or another
02:07:47 <Cale> atude: What do you need?
02:08:18 <PirateUnderwear> I am a math major. :)
02:08:30 <atude> Cale: a unified approach to haskell, mathematics and differentiating abstractness in continuous mathematics and discrete mathematics
02:09:17 <atude> It seems I'm able to use discrete mathematics to solve problems instead of classical algebraic ways to do so as taught in school
02:09:29 <Razz_> Botje: I got the state now, but interpInst should return a MSM bool, and set / modify return MSM (), so how would one alter the state and still return MSM bool?
02:09:35 <atude> it's bothersome to me because there shouldn't be only one way to do something
02:09:49 <Botje> Razz_: that's what a do block is for
02:10:55 <Botje> do state <- get \n ... set state' \n return True
02:11:01 <PirateUnderwear> ivan, Thanks a lot for the short install instructions. I got Haskell & Snap to install and work properly. :)
02:11:36 <Razz_> Botje: a, now i get it :-)
02:11:37 <ivan> PirateUnderwear: make your tab complete prefer the person who last spoke :)
02:11:37 <lambdabot> ivan: You have 1 new message. '/msg lambdabot @messages' to read it.
02:11:46 <ivan> whoo, a private message destinated for ivanm
02:11:58 <Botje> hah :P
02:12:12 <PirateUnderwear> ivan, oh sorry lol... when I try to do ivanm it doesnt direct to him lol
02:13:01 <ivan> in the spirit of openness, <lambdabot> m3ga said 2m 3d 11h 12m 37s ago: yeah, whats up?
02:14:07 <ManateeLazyCat> @tell siracusa I have push some patch to fix Gtk2hsHsSteup.hs, can you fetch gtk2hs darcs and install it on Windows? If install success, that patch is good. Thanks!
02:14:07 <lambdabot> Consider it noted.
02:15:21 <ManateeLazyCat> preflex: seen siracusa 
02:15:22 <preflex>  siracusa was last seen on #haskell 1 day, 16 hours, 4 minutes and 56 seconds ago, saying: @pl \(a,b) (x,y) -> ((a,x),(b,y))
02:15:48 <siracusa> ManateeLazyCat: Hi! I'm here :-)
02:15:48 <lambdabot> siracusa: You have 1 new message. '/msg lambdabot @messages' to read it.
02:16:17 <ManateeLazyCat> siracusa: Can you help me test gtk2hs darcs on Windows, just install it is okay.
02:16:35 <mishrak> preflex
02:16:42 <mishrak> preflex:
02:16:51 <atude> this place is like a zoo without keepers
02:17:09 <siracusa> ManateeLazyCat: Okay
02:17:28 <ManateeLazyCat> siracusa: Thanks! :)
02:18:31 <siracusa> ManateeLazyCat: Is it only gtk or all packages?
02:19:18 <ManateeLazyCat> siracusa: Just gtk
02:24:32 <siracusa> ManateeLazyCat: It tells me `Can't found gtk2hsC2hs' which is wrong, gtk2hsC2hs.exe does exist and is on the path.
02:26:47 <ManateeLazyCat> siracusa: Can you open gtk/Gtk2HsSetup.hs and change 'let c2hsName = programName c2hsLocal' to 'let c2hsName = "gtk2hsC2hs.ext" and test again?
02:27:18 <ManateeLazyCat> siracusa: Is : c2hsName = "gtk2hsC2hs.exe"
02:31:18 <ManateeLazyCat> siracusa: In Gtk2HsSetup.hs have functoin named checkGtk2hsBuildtools
02:31:45 <ManateeLazyCat> siracusa: In checkGtk2hsBuildtools have three name under 'let' : c2hsName typeProgramName signalProgramName
02:32:11 <ManateeLazyCat> siracusa: I think it can work after we need add ".exe" at end of those name, 
02:35:20 <ManateeLazyCat> siracusa: Wait, i push new pathes, and you try again.
02:36:41 <siracusa> ManateeLazyCat: This doesn't help, the same error. I printed allExecuteFiles and gtk2hsC2hs.exe *is* in the list.
02:37:35 <ManateeLazyCat> siracusa: I guess have another error report "Can't found gtk2hsTypeGen" ?
02:38:33 <siracusa> ManateeLazyCat: Oh, yes you're right, it's another file!
02:38:46 <ManateeLazyCat> siracusa: If so, my fix is work, just i need add ".exe" after *three* name : c2hsName, typeProgramName, signalProgramName
02:40:49 <PirateUnderwear> hello, does any body use snap framework?
02:42:28 <siracusa> ManateeLazyCat: Okay, now my depending packages are too old. I can compile the complete gtk2hs today afternoon if you want.
02:42:57 <ManateeLazyCat> siracusa: I have push new patch, can you test again?
02:43:46 <siracusa> ManateeLazyCat: No changes in the repo
02:44:49 <ManateeLazyCat> siracusa: Don't need install all modules in gtk package, if no "Cannot found ..." error occur, my patch is right.
02:44:59 <ManateeLazyCat> siracusa: Please pull again. ... :)
02:45:38 * ManateeLazyCat pasted "search exe program " at http://paste2.org/get/999849
02:45:39 <ManateeLazyCat> dcoutts: Do you know any cabal function can replace code at above?
02:45:49 <ManateeLazyCat> dcoutts: I'm build new patch for Gtk2HsSteup.hs
02:47:14 <siracusa> ManateeLazyCat: Works fine now.
02:47:25 <ManateeLazyCat> siracusa: Thank you very much! :)
02:47:41 <siracusa> ManateeLazyCat: No problem
02:47:48 <ManateeLazyCat> siracusa: Just two issues need fix now, after then release gio-0.12.0 and gtk-0.12.0
02:48:02 <PirateUnderwear> ughhh can't get Snap Framework to make a project >..<
02:48:27 <ManateeLazyCat> siracusa: In gtk-0.12.0 you can use all APIs from gtk+2.8 ~ gtk+2.20
02:48:55 <ManateeLazyCat> siracusa: Of course, except some useless functions for haskeller.
02:53:55 <tomberek> hey, does anyone use type families?
02:55:11 <kmc> yes
02:55:18 <IceDane> Is the compiler hpaste uses that gives you pretty smart errors suggesting changes in your code when you're basically replicating functionality of a built in functions something special, or just some other compiler than ghc?
02:55:46 <kmc> it has a compiler?
02:55:49 <tomberek> I find myself changing functions from F a -> a  into a -> F a -> a, just to get the types fixed, because if I use data families, i can't get the contexts to come out right
02:55:50 <kmc> i think it just has HLint
02:55:53 <IceDane> kmc: ah
02:55:54 <IceDane> or that
02:55:55 <IceDane> yeah
02:56:02 <IceDane> so that's what it uses, thanks
02:56:20 <kmc> tomberek, do you have an example?
02:57:08 <tomberek> kmc: i can try to cut what i have into the bare bones, give me a few
03:02:44 <ManateeLazyCat> siracusa: You can find many new APIs in gtk2hs darcs, feel free to use it, please let me know if you have any problem, we can fix as soon as possible.
03:04:12 <tomberek> kmc: i find myself having to add the " a->" like in here: http://codepad.org/A6s8pekk
03:04:59 <kmc> on 'switch'?
03:05:15 <quicksilver> tomberek: that would be a reason to use data families not type families.
03:05:25 <quicksilver> but for your example that would be a lot of newtyping
03:05:29 <quicksilver> possibly not what you want.
03:05:30 <tomberek> quicksilver: yes, because type Fs are not injective
03:05:34 <quicksilver> tomberek: exactly.
03:06:12 <quicksilver> it's not specifically a type family problem I don't think; you get similar problems with GADTs and phantom types
03:06:16 <tomberek> quicksilver, I tried putting things into newtype, but contexts messed up everything
03:06:46 <quicksilver> I'm afraid I"ve not played with it enough to have a good solution for you.
03:06:50 <quicksilver> I just agree that I recognise the problem :)
03:07:15 <tomberek> quicksilver, : well, i've found that adding the "a->" and then ignoring it, seems to work
03:07:30 <kmc> the return type on make should be enough, if called right
03:07:53 <quicksilver> kmc: but there is nothing to help 'switch'
03:07:54 <tomberek> that tells the compiler, for THIS a, use its X a and Y a to make another a
03:08:03 <quicksilver> unless switch is only ever used in make
03:08:11 <quicksilver> well, even then
03:08:17 <tomberek> exactly, if I want to use switch inside of make, I HAVE to give it something
03:08:27 <quicksilver> tomberek: well you can annotate 
03:08:48 <tomberek> quicksilver: how would I do that?
03:08:49 <quicksilver> (switch :: Y Int -> X Int) a 
03:09:07 <tomberek> huh?
03:09:32 <quicksilver> in the instance for Int (and supposing we remove the 'dummy' parameter from switch)
03:09:39 <tomberek> ok
03:09:45 <quicksilver> make g a b = (switch :: Y Int -> X Int) a + b
03:09:50 <kmc> i recommend data families instead of type families here
03:09:54 <quicksilver> other way around, rather
03:09:58 <quicksilver> X Int -> Y Int
03:09:59 <quicksilver> sorry ;)
03:10:45 <quicksilver> kmc: but then he'll new two newtype'd Ints for X Int and Y Int
03:10:48 <tomberek> kmc: that's what I thought of at first, but I ran into tons of context issues
03:10:54 <sioraiocht> What's the best lib for a two dimensional matrix these days?
03:11:26 <kmc> quicksilver, sure, i still think it fits the problem better from this admittedly small example
03:11:35 <kmc> tomberek, what do you mean by 'context issues'?
03:13:04 <tomberek> kmc: because the data family is a newtype, it carries none of the contexts that it needs, I try adding them in, but it seems to require undecidableinstances, overlapping, flexiblecontexts,... basically, it explodes
03:13:18 <kmc> type class contexts?
03:13:26 <tomberek> yeah
03:13:38 <tomberek> should I just show you my actual example?
03:13:43 <kmc> this is in code which is generic over F?
03:14:06 <tomberek> yes
03:14:25 <kmc> http://hpaste.org/40063/foo here's me using newtype
03:14:52 <kmc> yeah the actual example may be helpful
03:15:52 <tomberek> in your example, what happens if you try to add a Eq (X a) into the class declaration?
03:16:08 <quicksilver> kmc: gratuitous view pattern :P
03:16:18 <kmc> you know it quicksilver 
03:16:32 <kmc> tomberek, i need -XFlexibleContexts
03:16:39 <kmc> (not surprisingly)
03:16:52 <kmc> then i need to derive Eq for X
03:16:55 <kmc> err X Int
03:16:55 <tomberek> and then? 
03:16:59 <kmc> then it compiles
03:17:39 <kmc> i don't think FlexibleContexts is an extension to avoid
03:17:41 <tomberek> can that be derived?
03:17:51 <kmc> UndecidableInstances is pretty reasonable too
03:18:03 <kmc> OverlappingInstances is a red flag
03:18:11 <kmc> but i'm not seeing where those would come in here
03:18:25 <kmc> yeah
03:18:29 <mreh> is it good practice to give my nested monad transformers a type synonym, rather than a new wrapper?
03:18:34 <kmc> instance F where { newtype X Int = XI Int deriving Eq; ... }
03:18:49 <quicksilver> mreh: newtype wrappers IMO.
03:18:51 <kmc> mreh, depends how much you want to expose to the user
03:18:58 <quicksilver> mreh: you want to choose which instances to expose.
03:19:06 <kmc> i like to use newtype and then provide only some domain-specific functions
03:19:16 * quicksilver agrees with kmc.
03:19:28 <kmc> probably your user doesn't want to think in terms of get and set and tell and whatever
03:19:52 <mreh> well it wont be seen by the user
03:20:00 <kmc> it has *a* user
03:20:04 <kmc> or you wouldn't be writing it
03:20:08 <mreh> :)
03:20:16 <kmc> the user might be you, that's *extra* reason to be nice to him
03:20:43 <tomberek> kmc: hm,, I'll look into using data families, the problem is, I'm not really looking for it to be injective, I want different instances of F a to be able to use identical X a or Y a
03:20:59 <kmc> why?
03:21:36 <tomberek> my X a and Y a are indexes,, usually something simple like Int
03:22:02 <tomberek> so should I newtype a different one for every instance of F a
03:22:07 <kmc> it's very strange that i should write ten different functions, all named "switch" and all of type "Int -> Int"
03:22:07 <mreh> the boiler plate of a monad transformed is often longer than the definition would be...
03:22:40 <tomberek> kmc: well, that's way simplified, it's usually going to be (Int,Int) -> Int     either fst or snd
03:22:51 <tomberek> but can be [Int] -> Int
03:22:55 <kmc> it's very strange that i should write ten different functions, all named "switch" and all of type "(Int,Int) -> Int"
03:23:21 <kmc> "indices into S" and "indices into T" are semantically two different types of data, yes?
03:23:30 <kmc> sure, they might be represented the same way in memory
03:23:31 <tomberek> Y a is usually a collection or set of X a
03:23:40 <kmc> but if we let representation drive types exclusively then we'd be programming in C
03:23:52 <kmc> it's easier for you, and the compiler, to keep things straight if you newtype these indices
03:24:20 <tomberek> hm.....  i'll try
03:24:23 <mreh> @hoogle Identity
03:24:23 <lambdabot> module Control.Monad.Identity
03:24:24 <lambdabot> Control.Monad.Identity newtype Identity a
03:24:24 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
03:24:26 <kmc> anyway what are you trying to do with these collections
03:24:30 <kmc> that requires this fancy machinery
03:24:56 <tomberek> kmc:   graphs,, X a is the node type, Y a is the edge type
03:26:32 <tomberek> It would be ideal to be able to say that Y a can only be polymorphic on X a
03:27:11 <kmc> what do you mean?
03:27:54 <tomberek> kmc:  well, if Node g = Int, Edge g = (Int,Int)  but more correct would be Edge g = ( Node g, Node g)
03:28:17 <tomberek> or even Edge g :: * > *.-> *  and Edge g = (,)
03:29:08 <tomberek> but even that's not right because I want an edge to be able to be a set as well, as in Edge g = Data.Set (Node g)
03:30:11 <kmc> i really think these should all have constructors on them
03:30:23 <kmc> in which case it gets a lot nicer
03:30:25 <tomberek> kmc: ok, i'll try with data families
03:30:39 <tomberek> thanks for bearing with me
03:30:41 <kmc> newtype Edge G n = EG (n,n)
03:30:52 <kmc> newtype Edge G n = EG (Data.Set n)
03:30:59 <tomberek> kmc: but not Node?
03:31:07 <kmc> probably node too
03:31:13 <tomberek> ouch
03:31:16 <tomberek> ok
03:31:42 <kmc> i'm just taking your idea of making (Edge G) a type constructor that gets the node type
03:32:18 <kmc> i'm not sure about this type vs. data family issue; you've been thinking about this problem longer than i have
03:32:38 <tomberek> i'll work on it a bit
03:39:06 <pozic> tomberek: the edge type should only depend on the type of the index of nodes and it should have an additional edge label type. 
03:39:15 <pozic> tomberek: I don't see why you would need anything else.
03:39:39 <pozic> tomberek: assuming you are not doing hypergraphs. 
03:39:43 <cheater> hi
03:40:40 <cheater> what's better: bzr or git?
03:40:49 <cheater> or hg?
03:41:07 <pozic> cheater: I doubt anyone knows. 
03:41:19 <cheater> i'm looking for personal opinions and experiences
03:41:24 <pozic> cheater: you forgot monotone, btw. 
03:41:27 <mreh> I've never consciously seen a type context derived before... is that always possible
03:41:32 <cheater> i also forgot RCS
03:41:32 <Adamant> cheater: git, hg, and darcs are all good
03:41:56 <pozic> I think hg has given me the least amount of issues. 
03:42:02 <Adamant> they may have different speeds or be easier or not to use
03:42:16 <pozic> If you are paranoid, monotone is quite nice.
03:42:21 <cheater> why?
03:42:59 <pozic> cheater: via monotone you can do distributed development using cryptographic pseudonyms, IIRC. 
03:43:46 <tomberek> pozic: I am doing other exotic graphs, so a simple type Edge g = (Node g, Node g) is not good
03:43:59 <tomberek> pozic: and i'll keep type EdgeLabel g
03:44:50 <cheater> pozic: and what does that mean?
03:45:11 <pozic> tomberek: I said: newtype Edge a b = Edge (Node a, Node a,b)
03:45:20 <Adamant> if you don't know, you probably don't need it. :P
03:45:25 <quicksilver> cheater: bzr has a better data model; git is faster.
03:45:27 <kmc> i've used git a lot and like it.  i've used darcs a little and it pissed me off
03:45:36 <cheater> quicksilver: i heard git internals were ugly
03:45:42 <pozic> cheater: from wikipedia for example: Signing of revisions using RSA certificates
03:45:43 <cheater> quicksilver: what about hg? have you used it?
03:45:47 <quicksilver> no. ironically.
03:45:48 <cheater> pozic: ok
03:45:50 <tomberek> pozic: that could work ,,, 
03:45:59 <cheater> pozic: how is that better than using ssh?
03:46:12 <atude> o_O
03:46:27 <quicksilver> git is based on hashes; a file is really just the hash of its contents. This means it can't really understand file renamings and directory renamings in a sensible way.
03:46:28 <Entroacceptor> pozic: I've never seen anyone use monotone 
03:46:29 <kmc> other than being a completely different solution to a completely different problem
03:46:30 <pozic> cheater: I don't know the details. It's more that you don't have to roll your own anymore then. 
03:46:31 <kmc> it's not better
03:46:52 <quicksilver> I think even Hg doesn't do directory renaming well, but I'm not sure.
03:47:01 <cheater> kmc: what problem is it solving then that is not solved by transfering over ssh?
03:47:11 <pozic> Entroacceptor: I have, but yes, it is not very popular. 
03:47:19 <kmc> i want to send you patches but you don't trust me to log into your machine
03:47:23 <pozic> Git is the easiest to sell to a manager.
03:47:38 <kmc> i want to send patches to multiple people and have them agree they came from the same author, without everyone trusting a single machine
03:47:41 <Adamant> git is basically the de-facto standard
03:47:59 <cheater> kmc: ok
03:48:34 <kmc> yes, git does not store file renaming in the history; it's inferred heuristically from files with similar contents at different revisions
03:48:36 <pozic> kmc: it is a pretty big shame that we still don't have secure machines. 
03:48:37 <cheater> kmc: admittedly, this could possibly make it into any dvcs that really needed it?
03:48:56 <kmc> all git stores is commits pointing to trees pointing to blobs
03:48:57 <cheater> since it doesn't seem like a fundamental thing
03:48:59 <Cale> atude: Sorry about the late reply (I work off in a VM much of the time)
03:49:07 <kmc> cheater, sure, git has some signature support too
03:49:10 <Cale> atude: It *sounds* like you're looking for Category Theory.
03:49:29 <Cale> atude: Though your statement wasn't really clear enough to me to be sure.
03:49:37 <cheater> pozic: s/machines/transfers
03:49:56 <kmc> the beauty of git is that it's easy to understand the data model and it has some nice properties (append-only database of immutable objects)
03:50:14 <kmc> the complexity and perhaps ugliness in git is the variety of commands for manipulating this model
03:50:16 <cheater> kmc: have you used bzr or hg?
03:50:20 <kmc> no
03:50:22 <Cale> atude: But to some extent if you want to learn analysis and topology, you just have to jump in and put up with the fact that there are differences.
03:50:33 <cheater> kmc: what other things have you used?
03:50:55 <kmc> things = VCSs?
03:50:59 <atude> Cale: well for example, all the math I seems to use now is for solving problems related to some type of data structure... If I look at an exam question, most of my math is rather useless or I just haven't learned to use it in such a way
03:51:04 <kmc> svn, cvs, darcs (a little)
03:51:06 <Cale> atude: But CT is a general framework which fits essentially every branch of mathematics, and gives you some commonality of language.
03:51:12 <atude> Cale: I could completely just be looking to throughly
03:51:36 <atude> Cale: Ah, I should continue to stick with it? :)
03:51:49 <cheater> kmc: gotcha
03:51:52 <Cale> atude: Have you seen Spivak's Calculus?
03:51:54 <kmc> cvs is a trainwreck
03:52:06 <atude> Cale: I have not seen Spivaks Calculus
03:52:07 <kmc> svn is a decent attempt at "cvs done right" but as torvalds said, that's a fundamentally flawed goal
03:52:08 <Cale> http://cale.yi.org/share/Michael%20Spivak%20-%20Calculus.pdf
03:52:13 <Cale> (pirate!)
03:52:20 <kmc> @yarr
03:52:20 <lambdabot> Arr! Me ship be the biggest brig in the port!
03:52:25 <atude> Cale: In fact, I'm just now learning calculus :p
03:52:25 <cheater> arr!
03:52:40 <Cale> atude: It's one of my favourite textbooks of all time.
03:52:53 <Cale> atude: We used it in first year of uni
03:53:02 <Cale> (at the University of Waterloo)
03:53:29 <atude> Cale: this can be used for beginning calculus as well?
03:53:42 <Cale> It's really an introduction to mathematics proper (proving theorems, enjoying mathematics for its own sake), as well as mathematical analysis.
03:54:02 <Cale> But it starts off with very basic stuff about the properties of numbers and works its way up.
03:55:22 <atude> Cale: I see.. I'm using Skiena's Algorithm Design manual, Knuth's TAoCP; this one should be of great use
03:55:27 <atude> Cale: Thank you :)
03:55:30 <Cale> It can be used for beginning Calculus, but it may take a good bit more courage and willpower than the average book. Some of the exercises are quite difficult, particularly for a beginner in mathematics.
03:55:38 <atude> Cale: though, I need to incorporate haskell into the mix
03:56:03 <Cale> But *all* of the exercises are problems that are worth thinking about, even if you fail to solve them.
03:56:16 <atude> :O
03:56:27 <atude> Cale: what is the outcome?
03:56:29 <Cale> and there's very little of the cookie cutter sort of repeating the same question with different constants nonsense
03:56:42 <manateeUser> atude: I always learn from failure. (By Google)
03:56:54 <atude> manateeUser: me too :)
03:57:01 <atude> manateeUser: and others failures
03:57:19 <atude> which is a subset of failure
03:57:27 <Cale> Haskell would be sort of tricky to incorporate. You could, somewhat, but part of what makes analysis interesting is the bits which deal with functions that are not computable. :)
03:57:38 <manateeUser> atude: lets you see a lot of failures before you see the problem. (Translate By Google)
03:57:53 <ManateeLazyCat> Not good.
03:58:23 <atude> Cale: I think that's where my discrete math comes in to play, yeah? :p
03:58:36 <Cale> discrete math is mostly computable stuff
03:58:56 <atude> analysis seems to be a huge subject
03:59:17 <Cale> But for instance, if you restrict yourself in such a way that everything is computable, then all your functions are continuous, which is boring ;)
03:59:27 <manateeUser> Cale: I cale.yi.org / share / find a lot of good things ah. (Translate by Google)
03:59:46 <Adamant> kmc: it's wrong for Torvalds. it's perfectly reasonable for a lot of other folks.
04:00:06 <Cale> atude: Oh it is.
04:00:12 <atude> Cale: hmm?
04:00:16 <Cale> atude: It's maybe about 1/3 of mathematics
04:00:16 <atude> yeah
04:00:26 <atude> what are the other 2/3s?
04:00:37 <Cale> Depending on how you'd measure :)
04:00:53 <Cale> Things overlap a great deal, and blend together smoothly
04:01:42 <Cale> http://www.math-atlas.org/
04:03:02 <Cale> The bubbles' sizes and positions relative to one another were based on counts of papers published in one particular year, their classifications, and how much they cited each other.
04:03:19 <atude> Cale: I think I need to get a hard copy of this book.. It's too hard to read on my netbook
04:03:27 <Cale> atude: I highly recommend it
04:03:44 <atude> well, I guess it's time to study up :p
04:04:02 <Cale> atude: Abstract algebra is also pretty big
04:04:13 <Cale> and then you have geometry
04:05:14 <Cale> It's hard to succinctly give an overview of the picture of everything in mathematics.
04:06:08 <atude> Cale: I've been finding geometry would be more and more useful for me to visualize a lot of ambiguous things lately
04:06:17 <atude> but, it's seems to be such a dry and boring subject
04:06:22 <atude> Pascal sure did make it fun
04:06:28 <Cale> Depends on how it's taught
04:06:36 <Cale> and what part of it you're studying of course
04:07:00 <atude> no idea where to start.. I only know of the polygonal studies atm
04:07:04 <Cale> Projective geometry is quite beautiful.
04:07:33 <atude> that includes lie groups and such, right?
04:07:50 <Cale> That's differential geometry (I would say)
04:07:56 <cizra> Cale: That site seems VERY interesting! Thanks!
04:08:54 <Cale> Though Lie groups are themselves at a crossroads of differential geometry, algebra (group theory specifically), and topology
04:09:06 <atude> Cale: I think Euclidean Space is cool, but kind of difficult right now
04:09:59 <Cale> Linear algebra is an important and fundamental thing which you should also study when starting out.
04:10:37 <Cale> (and it'll give you a pretty good idea about Euclidean space)
04:10:55 <atude> Cale: I am studying from the book, "Vector Calculus, Linear Algebra, and Differential Forms: A Unified Approach" at the moment
04:10:57 * hackagebot haskell-src-exts 1.9.3 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.9.3 (NiklasBroberg)
04:11:16 <Cale> Interesting
04:11:32 <atude> Cale: It pretty good but a little difficult
04:12:03 <atude> Cale: Do you have a preferred method to reading PDFs?
04:16:46 <Cale> atude: I use Evince
04:17:04 <Cale> atude: and, I set the width comfortably
04:17:59 <Cale> (Evince is the standard document viewer in Gnome)
04:18:28 <atude> Cale: me too... :(
04:18:45 <atude> Cale: I guess I just have the absolute need to touch something
04:22:44 <tomberek> is there a combo mapFilter or filterMap?
04:22:59 <tomberek> where you filter in the same traversal that you map?
04:23:05 <Cale> tomberek: filter f . map g
04:23:17 <Cale> tomberek: and compile with -O
04:23:19 <tomberek> Cale: doesn't that do two traversals?
04:23:21 <Cale> (or -O2)
04:23:21 <tomberek> oh
04:23:23 <tomberek> got it
04:23:29 <Cale> There's fusion.
04:23:33 <tomberek> yay
04:24:04 <tomberek> Cale: does it matter if it's map g . filter f?
04:24:12 <Cale> Nope, that'll fuse also
04:25:01 <quicksilver> [ g x | x <- xs, f x ]
04:25:58 <atude> Cale: Do you have a book on algebra that you suggest? I believe I understand algebra very well, if not, completely understand it, but when asked things like, "Consider the quadratic function of x; y= a(x^2 - 2x - 8)+ x, ....(1)  where a is a real number not equal to 0. If the equation of the axis of symmetry of the graph (1) is x = 3/4, the a = [ ]. In this case, 7x+y take its minimum at x = -[ ], and the minimum value is 
04:29:24 <Cale> atude: For that stuff, read the first 100 pages of Spivak
04:30:11 <atude> Cale: you think that will help me with that indefinately? :D
04:30:23 <atude> Cale: if so, I absolutely will
04:30:44 <Cale> atude: That's just basic properties of numbers stuff, really :)
04:30:59 <atude> then why don't I know what to do...? :(
04:31:08 <atude> I must not understand as well as I think
04:31:16 <Cale> Well, "basic" is relative
04:31:56 <Cale> Actually, the easiest and most natural way to solve that problem is to use calculus
04:32:41 <atude> Cale: That was my EXACT thought when I saw this problem, only because of how you would approach the problem using discrete mathematics
04:33:22 <Cale> Differentiate the quadratic function to give a linear one (in terms of the arbitrary constant a), and then solve for the point at which the derivative is 0 in terms of a, and determine the value of a for which that's 3/4.
04:34:03 <atude> not exactly what I had in mind but that works... :p
04:34:59 <atude> Cale: then I will study more into spivak
04:39:54 <ManateeLazyCat> In Linux execute file is gtk2hsCh2s, and in Windows, execute file  is gtk2hsC2hs.exe, Have a portable Cabal functoin handle extension name?
04:43:50 <ManateeLazyCat> Or "How Cabal generate foo.exe file for Windows" ?
04:46:08 * hackagebot tableaux 0.1 - An interactive theorem prover based on semantic tableaux  http://hackage.haskell.org/package/tableaux-0.1 (PedroVasconcelos)
04:54:10 * hackagebot RNAFoldProgs 0.0.0.3 - RNA secondary structure folding  http://hackage.haskell.org/package/RNAFoldProgs-0.0.0.3 (ChristianHoener)
05:04:27 * ManateeLazyCat pasted "ugly cabal function." at http://paste2.org/get/999982
05:04:27 <ManateeLazyCat> Cabal people : Can I replace above "windows macro" with cabal portable functions? Thanks!
05:07:08 <Botje> ndm blogged about an isWindows function last week
05:07:14 * hackagebot sample-frame-np 0.0.2 - Orphan instances for types from sample-frame and numericprelude  http://hackage.haskell.org/package/sample-frame-np-0.0.2 (HenningThielemann)
05:07:24 <Botje> http://neilmitchell.blogspot.com/2010/09/three-closed-ghc-bugs-i-wish-were-open.html
05:08:05 <Botje> it's not ideal, bu t..
05:09:00 <chrisdone> anyone else get this error? http://hpaste.org/40064/cabal_pattern_match_fail
05:09:14 * hackagebot synthesizer-core 0.4 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.4 (HenningThielemann)
05:10:29 <ManateeLazyCat> Botje: I want some function add ".exe" to the end when current OS is Windows.
05:11:47 <Botje> ManateeLazyCat: filename ++ (if os == "mingw" then ".exe" else "") ?
05:16:06 <Botje> ManateeLazyCat: you know that Cabal already has some functions to find programs, right?
05:16:16 <Botje> raw docs here: http://hackage.haskell.org/packages/archive/Cabal/1.8.0.6/doc/html/Distribution-Simple-Program.html#5
05:16:29 <Botje> but there's probably a better doc somewhere else
05:25:15 <ManateeLazyCat> siracusa: Still there?
05:25:24 <jix> is there a monad transformer with the semantics of the ST monad?
05:25:36 <siracusa> ManateeLazyCat: Again, yes.
05:26:16 <ManateeLazyCat> siracusa: Can you open Gtk2HsSetup.hs and add below lines at beginning of checkGtk2hsBuildtools? 
05:26:18 <ManateeLazyCat>   test <- (programFindLocation c2hsLocal) normal 
05:26:18 <ManateeLazyCat>   putStrLn $ "#### Test " ++ show test
05:26:18 <ManateeLazyCat>  
05:26:23 <Botje> jix: i'd think ST has to live at the bottom of the stack
05:26:48 <ManateeLazyCat> siracusa: Then do "cabal clean && cabal install" and see what output of "#### Test ...".
05:26:50 <ManateeLazyCat> siracusa: Thanks,
05:27:01 <ManateeLazyCat> siracusa: Axel don't like my macro solution "#if defined(mingw32_HOST_OS) || defined(__MINGW32__)"
05:27:18 <jix> Botje: ST has to, but i'm pretty sure you could build a transformer with the same semantics (but different, less efficient implementation)
05:28:05 <Botje> jix: then you'd just have State (Map String (forall a. a) or something? :)
05:28:31 <ManateeLazyCat> siracusa: So i need figure out more portable way....
05:28:50 <jix> Botje: you probably want to use an intmap and some finalizer magic to clean up variables not referenced anymore... but yeah basically something like that
05:29:04 <siracusa> ManateeLazyCat: #### Test Just "c:\\ghc\\ghc-6.10.4\\ext-lib\\bin\\gtk2hsC2hs.exe"
05:29:12 <ManateeLazyCat> siracusa: Oh, great.
05:29:29 <ManateeLazyCat> siracusa: Can you wait me a moment for test *last* patch?
05:29:31 <siracusa> ManateeLazyCat: So you only need to split the last part
05:29:51 <ManateeLazyCat> siracusa: I don't, i just need test result is whether *Just* value
05:30:10 <ManateeLazyCat> siracusa: If gtk2hs-buildtools not install correctly, it will return Nothing.
05:30:18 <siracusa> ManateeLazyCat: Ah, sure.
05:34:15 <siracusa> ManateeLazyCat: May I suggest to replace `Cannot found' by `Cannot find'? :-)
05:34:32 <hpc> hahah
05:35:02 <ManateeLazyCat> siracusa: Yes, i have fix it. :)
05:35:05 <hpc> "None of your $PATH is contain this file"
05:35:22 * hackagebot atom 1.0.6 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.6 (TomHawkins)
05:35:24 * hackagebot improve 0.0.12 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.0.12 (TomHawkins)
05:35:42 <ManateeLazyCat> siracusa: Bad English. :)
05:37:12 <mreh> how much is a tab according to ghc again? 4 spaces right?
05:37:41 <siracusa> mreh: 8 IIRC
05:38:40 <mreh> I don't think it's ever been 4 in the history of computing, actually
05:38:44 <dolio> I think it's less simple than that.
05:39:05 <mreh> by which you mean it is more complicated?
05:39:12 <chrisdone> uh, a single space often works
05:39:12 <dolio> Yes.
05:39:21 <chrisdone> does ghc care about the concept of a tab?
05:39:26 <chrisdone> seems to care more about alignment
05:39:41 <dolio> I mean GHC might actually keep track of tabstops being every 8 characters, and advance to the next tabstop.
05:39:58 <dolio> I seem to recall someone saying that's how it worked.
05:40:00 * ManateeLazyCat pasted "Gtk2HsSetup.hs" at http://paste2.org/get/1000029
05:40:01 <ManateeLazyCat> siracusa: Replace Gtk2HsSetup.hs with above code and do "cabal clean && cabal install", thanks!
05:40:23 <mreh> as a general rule "Don't use tabs" works quite well
05:40:24 <chrisdone> ManateeLazyCat: use hpaste.org you vagabond!
05:40:38 <mreh> but someone has put tabs in this source code, I'm going to remove them all
05:40:40 <ManateeLazyCat> chrisdone: Use paste2.el
05:41:03 <ManateeLazyCat> chrisdone: I can perfect integrate paste2.el with irc client in Emacs. :)
05:41:47 <ManateeLazyCat> chrisdone: Automatic upload and paste irc notify message when upload finish, hpaste.el can do ?
05:42:34 <siracusa> ManateeLazyCat: Yep, works!
05:42:48 <ManateeLazyCat> siracusa: Cool, thanks a lot!
05:43:01 <ManateeLazyCat> siracusa: My god, this is Axel's perfect cabal solution.
05:43:28 <ManateeLazyCat> siracusa: I think he won't complain my patch now. :)
05:57:44 <ManateeLazyCat> siracusa: BTW, can you send your MPlayer.hs patch to gtk2hs list? Just two bugs need fix now.... I hope can merge your patch in gtk-0.12.0
05:58:04 <lpsmith> Just out of curiousity, does anybody think they understand the lazy state monad,  in an operational sense?
05:59:37 <dolio> Only vaguely.
05:59:47 <dolio> It's a good counterexample to "monads sequence things."
06:00:25 <lpsmith> heh, same here.
06:00:28 <pozic> lpsmith: you mean the reverse state monad?
06:00:37 <pozic> lpsmith: or just the normal lazy one?
06:00:39 <lpsmith> pozic, no, Control.Monad.State.Lazy
06:00:41 <lpsmith> normal lazy
06:00:49 <pozic> lpsmith: what's not to understand about it? 
06:00:58 <dolio> Oh, I was thinking backwards, too.
06:01:24 <lpsmith> pozic,  it can be pretty subtle in the operational sense
06:01:28 <dolio> You can do weird stuff with just the lazy state monad, too, though.
06:01:29 * hackagebot hoe 0.2 - Haskell One-liner Evaluator  http://hackage.haskell.org/package/hoe-0.2 (HideyukiTanaka)
06:01:43 <pozic> lpsmith: I would say you should only worry abou those things once you actually have a space-leak. 
06:01:48 <pozic> about*
06:02:17 <lpsmith> With the reverse state monad,  I'd be happy to have a convincing application,  let alone an operational understanding...
06:02:27 <dolio> > runState (let foo = do foo ; modify (1:) ; get in foo) []
06:02:28 <lambdabot>   ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:02:29 <pozic> lpsmith: if you want to know it in advance, you should first write functions that are more easily understood. 
06:03:04 <lpsmith> yay for monochrom's trick!
06:03:28 <dolio> If you try to evaluate that as if it were a series of steps, it looks like an infinite loop.
06:03:39 <dolio> But it isn't.
06:03:59 <pozic> dolio: nice example. 
06:04:10 <pumpkin> dolio: did you see SPJ's responses?
06:04:13 <pumpkin> on that GADT bug
06:04:27 <dolio> I saw some last night. Did he write more?
06:04:42 <pumpkin> hmm, he switched the milestone
06:04:49 <pumpkin> " There is still improvement to be had here, and I want to get to it, but
06:04:50 <pumpkin>  it's not critical for 7.0."
06:04:54 <pumpkin> :P
06:05:07 <pumpkin> I guess he still isn't convinced it's the right behavior
06:05:17 <pozic> What makes 7.0 not 6.16 or whatever?
06:05:24 <lpsmith> nothing
06:05:29 <pumpkin> pozic: new typechecker and inliner (mostly the former though)
06:05:33 <lpsmith> 6.14 has been renamed to 7.0
06:05:38 <allbery_b> new type checker, yeh
06:05:46 <pumpkin> yeah, but mostly because he managed to get the new typechecker in
06:05:51 <pumpkin> and they consider that a noteworthy improvement
06:05:54 <pozic> pumpkin: you mean one that SPJ can actually understand himself now? 
06:06:01 <allbery_b> it was 6.14 until SPJ rewrote the typechecker to make type families sane
06:06:02 <pumpkin> let's hope so! :P
06:06:10 <pozic> pumpkin: and preferably one that can also be understood by others.
06:06:23 <pumpkin> and fixed something I considered a bug but he didn't, in the process :P
06:06:42 <dolio> pumpkin: I don't really know that much about how they do GADT checking, so maybe it wouldn't strictly be an error.
06:06:43 <zygoloid> isn't it called 7.0 to impress people at the ICFP? ;-)
06:07:06 <dolio> I could see you not being able to eliminate the dead cases if you were using some eliminator translation.
06:07:16 <pumpkin> dolio: well in one of my replies, I figured out that pattern matching on a GADT constructor actually refines the type variables using ~
06:07:19 <pumpkin> which behaved differently
06:07:26 <pumpkin> from just changing the type variable completely
06:07:28 <geheimdienst> zygoloid: the people at icfp are not that shallow that they would be impressed by a mere arbitrary number
06:07:37 <pumpkin> but that changed in the new typechecker
06:07:46 <geheimdienst> they are only impressed by long papers of type-theory gibberish
06:07:46 <dolio> But I'd expect a case-and-pattern-matching presentation to result in errors when you refine things like that.
06:07:51 <pumpkin> yeah :P
06:08:21 <pumpkin> but x : (n ~ Z) => Fin n -> a; x Zero = ...; x (Suc n) = ... 
06:08:26 <pumpkin> is accepted in current GHC
06:08:33 <dolio> pumpkin: Well, if it's generating equality constraints, then those two matches must be generating contradictory constraints, which has reason to be an error as well.
06:08:34 <pumpkin> Fin Z -> a with same definition isn't
06:08:39 <pumpkin> yeah, I agree :)
06:10:49 <dolio> The only potential problem would be if deciding if you have a contradictory set of constraints is undecidable.
06:11:05 <dolio> Which I suppose it probably is if they're fancy enough.
06:11:21 <pumpkin> agda can do it, but I guess it doesn't have typeclasses
06:11:21 <geheimdienst> what if deciding if it's undecidable itself is undecidable?
06:11:24 <geheimdienst> ;)
06:11:28 <dolio> But you'd think n ~ Z /\ n ~ S m could be caught.
06:11:53 <pumpkin> yep :)
06:11:55 <pumpkin> anyway, gotta run
06:11:59 <pumpkin> ciao
06:13:57 <zygoloid> > let x :: (a ~ Int, a ~ Double) => Int; x = 0 in 0
06:13:57 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
06:13:58 <lambdabot>         against inferred ty...
06:14:42 <philed> Hey all. I need urgent help getting OpenGL working with the GHC-6.12.*. I'm getting peculiar errors about there being no instance for ColorComponent Float, for ColorComponent GLfloat, for ColorComponent CFloat. Any ideas what could be the problem here?
06:15:20 <philed> I can see the instance declarations for ColorComponent GLfloat, but Haskell doesn't seem to recognise them :/
06:16:11 <lpsmith> philed,  have you imported the modules that the instances are defined in?
06:16:49 <philed> I think so. Let me try again.
06:17:04 <dolio> > let w :: (a ~ a -> a) => a -> a ; w g = g g ; ww : (a ~ a -> a) => a ; ww = w w in ww
06:17:05 <lambdabot>   <no location info>: parse error on input `->'
06:17:24 <dolio> > let w :: (a ~ a -> a) => a -> a ; w g = g g ; ww :: (a ~ a -> a) => a ; ww = w w in ww
06:17:25 <aRcatan> is there some common name for >>?
06:17:25 <lambdabot>   <no location info>: parse error on input `->'
06:17:42 <lpsmith> philed,  I'm not sure otherwise;  I haven't used OpenGL and no other generic advice immediately comes to mind
06:17:45 <aRcatan> like bind for >>=
06:18:32 <philed> lpsmith: Yeah it still complains. There's something funky going on. It's fine in Hugs and GHC 6.10.4.
06:18:35 <opqdonut> some call >> "then"
06:18:52 <lpsmith> philed, are you using ghc or ghci?
06:19:36 <philed> lpsmith: I get the same errors if I compile with ghc or load the file with ghci. However, I *don't* get the errors if I just start importing OpenGL modules and using it interactively in ghci.
06:19:37 <Blkt> good day everyone
06:19:47 <lpsmith> hmm
06:20:07 <philed> A weird FFI problem?
06:20:39 <lpsmith> I doubt it.   At this point,  I'd need to look at an hpaste
06:21:05 <philed> Would that be cool? Just the source?
06:21:36 <lpsmith> well, the error message would be helpful too  :-)    http://hpaste.org
06:22:04 <lpsmith> I'll take a look at it at least,  probably somebody else will as well
06:22:31 <philed> I'll just cut it down a bit. I can get the error with very little code.
06:22:41 <lpsmith> cool
06:22:45 * hackagebot nptools 0.2.2 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.2.2 (NicolasPouillard)
06:22:51 <lpsmith> err,  hpaste is down
06:23:09 <lpsmith> I suppose find another pastebin then
06:25:01 <philed> lpsmith: http://pastebin.com/LzyQruFM
06:26:24 <philed> Ah hang on. 
06:26:27 <siracusa> ManateeLazyCat: There's still a problem with MPlayer, not sure if only on Windows. Can you please test this: http://paste2.org/p/1000072
06:26:29 <philed> It works with GLfloat.
06:26:47 <philed> At least in this snippet, just not in the larger body of code. The plot thickens.
06:29:18 <siracusa> ManateeLazyCat: mWidget doesn't get realized when it is inside of any container. It only works if it's the plug's only element.
06:31:24 <lpsmith> philed, yeah, I dunno what to say :-D.   It works with ghc-6.8.3,  fails with ghc-6.13
06:32:29 <philed> lpsmith: Well, I've fixed it on my end now. Turns out it was conflicting definitions of GLfloat imported by GLUT.
06:32:43 <philed> The cut down bit of code didn't have a GLUT import.
06:32:46 <ManateeLazyCat> siracusa: Ok, i test.
06:32:56 <lpsmith> heh
06:33:06 <Olathe> @hoogle (Monad m) => [a] -> (m b) -> m ()
06:33:06 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
06:33:06 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
06:33:06 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
06:33:14 <lpsmith> Yeah, it might have something to do with the version of OpenGL I have installed for each version
06:33:45 <lpsmith> OpenGL-2.2.1.1 versus OpenGL-2.4.0.1
06:34:49 <chrisdone> who broke my hpaste!?
06:34:51 * shapr install haltavista for sheer name awesomeness
06:35:10 <philed> Sounds a likely possibility. I just hope I don't have the same trouble here!
06:35:24 <ManateeLazyCat> siracusa: I need download some video to test.
06:38:35 <fryguybob> chrisdone: Works for me now
06:42:57 <philed> lpsmith: Cheers for your help! Now more testing to do.
06:44:37 <lpsmith> philed, good luck!
06:45:33 <Olathe> The Mapper monad: http://optimi.wordpress.com/2010/09/23/the-mapper-monad/
06:47:12 <ManateeLazyCat> siracusa: Video still in download, i can't test now, but i suggest you move "widgetShowAll socket" before "          plug <- plugNew $ Just windowId"
06:47:22 <ManateeLazyCat> siracusa: I will test it after i download video.
06:49:18 <siracusa> ManateeLazyCat: Why the extra widgetShowAll? The socket should be realized after the window gets realized.
06:49:59 <siracusa> ManateeLazyCat: Ah sorry, I got that wrong.
06:53:01 <ManateeLazyCat> siracusa: I can recur your bug, give me some time.
06:56:46 * edwardk waves hello.
06:58:59 * mightybyte waves back
07:02:24 <ManateeLazyCat> siracusa: My vidoe file not valid, but i know why can't work.
07:02:53 <ManateeLazyCat> siracusa: When you binding 'realize' signal, should use `afterRealize` and not `onRealize`.
07:03:08 <ManateeLazyCat> siracusa: Can you change to `afterRealize` and try again?
07:04:47 <siracusa> ManateeLazyCat: No, it doesn't help. The version without the additional VBox (in mplayerStick) works correctly.
07:05:55 <siracusa> ManateeLazyCat: Is there a way to force the realize signal of a widget?
07:06:59 <ManateeLazyCat> siracusa: I don't know the detail of Windows, but you binding `onRealize` is wrong usage : look http://hackage.haskell.org/packages/archive/gtk/0.11.2/doc/html/Graphics-UI-Gtk-Abstract-Widget.html#v:realize
07:07:12 <ManateeLazyCat> siracusa: Because you want add some widget after container realized.
07:08:35 <ManateeLazyCat> siracusa: Have you have some little video file give me for test?
07:09:39 <siracusa> ManateeLazyCat: http://www.fileformat.info/format/mpeg/sample/index.htm
07:09:54 <ManateeLazyCat> siracusa: Cool
07:11:24 <ManateeLazyCat> siracusa: MPlayer.hs in gtk2hs repository can work, testing your code.
07:11:35 <siracusa> ManateeLazyCat: So how do you add widgets dynamically to a container? I thought you can do it with boxPack.
07:11:59 <ManateeLazyCat> siracusa: Wait, i have some code can works on Linux. I test.
07:13:25 * ManateeLazyCat pasted "My mplayer demo" at http://paste2.org/get/1000121
07:13:28 <ManateeLazyCat> siracusa: Above is my mplayer.hs code.
07:13:34 <ManateeLazyCat> siracusa: Can you test on Windows?
07:13:41 <ManateeLazyCat> siracusa: I have test on Linux, can work.
07:15:42 <ManateeLazyCat> siracusa: My demo also add other widget,
07:16:31 <ManateeLazyCat> siracusa: I think you should binding `afterShow` on *top-level* window.
07:17:02 <ManateeLazyCat> siracusa: My button command can't work, but there have multiple children in box.
07:18:49 <siracusa> ManateeLazyCat: the video is played, but still the drawing box error.
07:19:03 <ManateeLazyCat> siracusa: Can play? Paste error?
07:19:17 <EvanR-work> > showIntAtBase 51 99
07:19:18 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:19:18 <lambdabot>    arising from the literal `9...
07:19:30 <EvanR-work> :t showIntAtBase
07:19:31 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
07:19:49 <ManateeLazyCat> siracusa: "X11 error: BadDrawable (invalid Pixmap or Window parameter)" ?
07:19:50 <siracusa> ManateeLazyCat: The video is drawn over the buttons, that was the reason for using the socket/plug.
07:20:41 <EvanR-work> > showIntAtBase 51 ("qlkwnergae@#$%!@$#^!#$^!#$^3461234723"!!) 99
07:20:42 <lambdabot>   Overlapping instances for GHC.Show.Show
07:20:42 <lambdabot>                              (GHC.B...
07:20:46 <EvanR-work> lol
07:21:08 <siracusa> ManateeLazyCat: The program only crashes when using multiple widgets in a plug.
07:21:10 <ManateeLazyCat> siracusa: Hmm, i don't know the detail of Windows, my suggestion, you need play video `afterShow` top-level window.
07:21:25 <EvanR-work> what the hell are these arguments?
07:21:29 <ManateeLazyCat> siracusa: And not `realize` signal.
07:21:42 <ManateeLazyCat> siracusa: X error?
07:22:03 <magicman> > showIntAtBase 19 ("qwertyuiopasdfghjkl"!!) 99 ""
07:22:03 <siracusa> ManateeLazyCat: There's no X in Windows :-P
07:22:04 <lambdabot>   "yt"
07:22:13 * shapr boings cheerfully
07:22:28 <ManateeLazyCat> siracusa: Sorry, i can't help you.
07:22:40 <ManateeLazyCat> siracusa: I can't guess since i haven't Windows.
07:22:49 <shapr> Is there a library that has ADTs for tcpdump's pcap format? I'd like to generate pcap files.
07:22:57 <EvanR-work> magicman: whats that last "" for?
07:23:10 <magicman> > showIntAtBase 19 ("qwertyuiopasdfghjkl"!!) 99 "Let's see, shall we?"
07:23:11 <lambdabot>   "ytLet's see, shall we?"
07:23:16 <EvanR-work> o_O
07:23:33 <Axman6> wtf?
07:23:41 <magicman> Probably for the ShowS interface.
07:23:50 <magicman> You know about difflists?
07:23:53 <siracusa> ManateeLazyCat: What happens if you try to play a video with my pasted code?
07:24:28 <ManateeLazyCat> siracusa: "Main: user error (widgetGetDrawWindow: no DrawWindow available (the widget is probably not realized))"
07:24:40 <Axman6> > showIntAtBase 16 ("0123456789abcdef"!!) 32 "
07:24:41 <lambdabot>   <no location info>:
07:24:41 <lambdabot>      lexical error in string/character literal at end o...
07:24:42 <Axman6> > showIntAtBase 16 ("0123456789abcdef"!!) 32 ""
07:24:43 <lambdabot>   "20"
07:24:49 <shapr> I really love the new look for Hackage.
07:25:11 <Axman6> > showIntAtBase 32 ("0123456789abcdefghijklmnopqrstuvwxyz"!!) 8392 ""
07:25:12 <lambdabot>   "868"
07:25:13 <edwardk> shapr: it is far too early in the day to be boinging. ;)
07:25:21 <siracusa> ManateeLazyCat: Okay, so it's not solely related to Windows systems.
07:25:36 <edwardk> especially cheerfully :)
07:26:45 <EvanR-work> ord 4
07:26:48 <EvanR-work> > ord 4
07:26:48 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:26:49 <lambdabot>    arising from the literal `4...
07:26:56 <EvanR-work> > ord '4'
07:26:56 <lambdabot>   52
07:27:01 <EvanR-work> > chr 4
07:27:02 <lambdabot>   '\EOT'
07:27:05 <magicman> Is there a way to make cabal-install automatically do the haddock-hscolor-sourcelink thing?
07:27:39 <EvanR-work> > showIntAtBase 1000 chr 461902831293432 ""
07:27:40 <lambdabot>   "\461\902\831\293\432"
07:27:51 <EvanR-work> > text $ showIntAtBase 1000 chr 461902831293432 ""
07:27:51 <lambdabot>   ǍΆ̿ĥư
07:27:58 <EvanR-work> \o/
07:28:03 <magicman> Awesome.
07:28:43 <EvanR-work> way better than hex
07:29:11 <shapr> edwardk: I'm really cheerful. Life is good, I has code. I get to speak the occasional bit of Swedish and write the occasional bit of Haskell at work.
07:29:11 <magicman> I can't even type half those characters. Not without knowing their Unicode number, anyway :P
07:29:25 <edwardk> shapr: hah
07:29:34 <EvanR-work> get a base 1000 numpad
07:32:44 <zygoloid> > showIntAtBase 1114111 chr 9438560931460046096
07:32:45 <lambdabot>   Overlapping instances for GHC.Show.Show
07:32:45 <lambdabot>                              (GHC.B...
07:32:49 <zygoloid> > showIntAtBase 1114111 chr 9438560931460046096 ""
07:32:50 <lambdabot>   "\ACK\919452\230701\842407"
07:33:37 <zygoloid> @type showIntAtBase -- why not: Integral a => a -> (Int -> b) -> Int -> [b] -> [b] ?
07:33:38 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
07:33:47 <zygoloid> seems like a silly type for it, to me...
07:34:05 <EvanR-work> i was thinking the same thing
07:35:05 <EvanR-work> but the thing is that algorithm is more natural if least significant 'digit' was first in the list
07:35:16 <EvanR-work> showIntAtBase is geared toward strings, so reverses it at the end
07:35:31 <EvanR-work> the more general one seems silly to reverse
07:35:59 <EvanR-work> alien number systems!
07:36:39 <zygoloid> better: showIntAtBase n showChar base = reverseS . map showChar $ splitBase n base
07:37:03 <zygoloid> with splitBase :: Integral a => a -> Int -> [a], reverseS :: [a] -> [a] -> [a]
07:41:47 <EvanR-work> 123.45 -> (321,45) 321 dollars and 45 cents
07:43:25 <zygoloid> EvanR-work: i would like to open an account at your bank.
07:44:26 * zygoloid plans to credit his account with $202, withdraw $3, then withdraw the remaining $991 ;)
07:44:54 <EvanR-work> hahaa
07:45:18 <EvanR-work> su 2 - 3 is 9 mod ten
07:45:28 <EvanR-work> of course!
07:46:23 <EvanR-work> the lower order digits tend to change more
07:47:38 <EvanR-work> i guess we car sales men would have a harder time saying the price
07:47:51 <EvanR-work> since people want to know the second to most significant digit usually
07:48:45 <zygoloid> the most significant digit is most likely to be 1 :)
07:48:45 <EvanR-work> despite it being wrong because of the remaining 99999 on the price
07:49:04 <EvanR-work> only 18999.99 !
07:51:06 <EvanR-work> i have just invented the perfect price ending
07:51:09 <EvanR-work> http://en.wikipedia.org/wiki/File:999_Perspective.png
07:51:33 <EvanR-work> you get the phsychology AND the profit of the saner price since they are equal ;)
07:54:44 <revenantphx> 0.99– is 1
07:54:49 <revenantphx> 0.999... == 1
07:54:53 <revenantphx> mathematicallty
07:55:41 <n00p> Uhh, in integer math maybe
07:55:46 <EvanR-work> yeah so you can put that image on your price tag, and in your books legally put a whole number
07:56:29 <EvanR-work> s/integer/real number/
07:56:36 <n00p> yeh
07:57:02 <zygoloid> but would it stand up in court? :)
07:57:07 <EvanR-work> lol
07:57:09 <Lemmih> 0.999... == 1.000037 with pentium numbers.
07:57:23 <zygoloid> what happened to that 0.01c vs $0.01 thing?
07:58:23 <roconnor> zygoloid: he didn't have to pay
07:58:47 <roconnor> http://verizonmath.blogspot.com/
07:59:16 <roconnor> http://verizonmath.blogspot.com/2006/12/response-from-verizon-getting-closer.html
07:59:31 <roconnor> `` We have issued a credit to your account of $71.79. In order to prevent any future inaccuracies, we are supplementing the reference material used by our representatives to better highlight that the Canadian roaming rate is .002 dollars-per-kilobyte, which is equal to .2 cents per kilobyte.
08:03:45 <zygoloid> roconnor: \o/
08:04:07 <gwern> what is good formatting for a 'warning!' sentence in haddocks/
08:06:19 <gwern> @hoogle URL
08:06:19 <lambdabot> Text.Html type URL = String
08:06:19 <lambdabot> Text.XHtml.Frameset type URL = String
08:06:19 <lambdabot> Text.XHtml.Strict type URL = String
08:06:20 <pozic> gwern: WARNING READ THIS YOU STUPID IDIOT? 
08:06:28 <gwern> pozic: that isn't caps
08:06:37 <pozic> gwern: oh, then I don't know ;)
08:07:00 <pozic> gwern: the blink tag might be nice.
08:07:13 * pozic notes that this was not a serious suggestion. 
08:07:45 <pozic> gwern: I think it would be better not to have to write 'warning' to begin with. 
08:07:51 <EvanR-work> blink element not supported in chrome
08:08:02 <gwern> pozic: that would be nice, but not happening
08:08:22 <zygoloid> gwern: what's good for a warning is ensuring it can't happen via more restrictive types :)
08:08:36 <pozic> zygoloid: which isn't happening.
08:09:04 <gwern> zygoloid: yeah... I have no idea how I would encode 'this function cannot be used more than 100 times in an hour' without making it seriously restrictive or over-engineered
08:09:19 <zygoloid> gwern: srsly? :)
08:09:33 <pozic> gwern: Emphasis may be added by surrounding text with /.../.
08:10:04 <gwern> zygoloid: well, not really. I guess I could do something with monad transformers and acessor functions that check the current time
08:10:08 <zygoloid> what happens if you use the function more than 100 times an hour? :)
08:10:15 <earthy> any cabal wizards present?
08:10:25 <gwern> zygoloid: your IP gets banned and the function starts failing silently
08:10:40 <EvanR-work> sounds like a entry from haskell d&d
08:10:42 <zygoloid> wow. ok. yeah, checking that in the code might be a good idea :)
08:11:01 <EvanR-work> if you use it more than 100 times an hour make a saving throw against referential opaqueness
08:11:05 <pozic> zygoloid: and if you run multiple instances at the same time you still have a problem. 
08:11:25 <Saizan> earthy: what is the problem?
08:11:52 <earthy> well, I'm having trouble understanding the documentation when matched against the cabal files of packages downloaded from hackage
08:12:34 <pozic> gwern: you need a persistent database to store a number. 
08:12:48 <Saizan> earthy: e.g.?
08:12:51 <pozic> gwern: with an atomic increment operation. 
08:12:57 <earthy> according to the user's guide, an executable section in a package must explicitly mention all modules used by that executable
08:13:00 <gwern> pozic: and ACID semantics!
08:13:15 <earthy> that means that even those already mentioned in the library section need to be mentioned again
08:13:16 <Saizan> earthy: yeah, in other-modules
08:13:21 <earthy> (the examples make that clear)
08:13:21 <pozic> gwern: then you can return 'Dude, you are going to call this for the 100th time and that's like falling of a cliff, so we are not going to do that.'
08:13:25 * EvanR-work counters gwern's ACID with SOAP
08:13:34 <EvanR-work> attack was ineffective
08:13:44 <gwern> pozic: and how does my function get access to said data?
08:13:56 * gwern RPCs EvanR-work from behind
08:13:58 <pozic> gwern: it connects to this data base? 
08:14:02 <pozic> database*
08:14:04 <Saizan> earthy: though some packages might get away without filling that field because of how compilation is done
08:14:19 <gwern> pozic: heck, the website isn't going to tell me how many times I did a request
08:14:27 <ddarius> EvanR-work: Soap is basic so it should neutralize.
08:14:28 <earthy> however, when looking at the cabal files for brainfuck, palindromes and graphviz I don't see that happening
08:14:30 <pozic> gwern: that's why you keep track of that yourself..
08:14:48 <earthy> saizan: ah, so basically it's a lucky side effect of ghc's compilation semantics
08:14:54 <Saizan> earthy: btw, since Cabal 1.8 an executable can depend on the lib in the same package, which means those modules will be compiled only once
08:14:55 <pozic> gwern: and if you want it to work for your whole network, you use a distributed component which has that feature. 
08:15:05 <pozic> gwern: you could take into account latency issues, etc.
08:15:17 <pozic> gwern: anyway, you can always create something that works. 
08:15:17 <earthy> ah! that'd be good!
08:15:18 <earthy> how? :)
08:15:20 <gwern> excellent. I'll be able to do a master's thesis at the minimum on this!
08:15:25 <Saizan> earthy: yeah, though it breaks as soon as you start using preprocessors or your exe uses a module that's not in the lib
08:15:36 <pozic> gwern: the question is whether there is economic value in doing so.
08:15:48 <gwern> (the answer is no)
08:15:51 <pozic> gwern: it is however the difference between a quick hack and a library, imho.
08:16:01 * sm thinks / / in the haddock is a bit cheaper
08:16:13 <earthy> saizan: not in the lib, or not *exposed* in the lib?
08:16:42 <Saizan> earthy: heh, the two parallel conversations make this harder :)
08:16:47 <jix> pozic: i wouldn't want a library to force me to use some shared database if the library does something that is completely unrelated to that
08:16:55 <earthy> :)
08:17:05 <sm> usage warnings are ok, System.IO has them
08:17:06 <pozic> jix: it is not completely unrelated. 
08:17:15 <pozic> jix: and you could add a flag, of course.
08:17:32 <pozic> If by default, it would actually always work, I see no issues with that.
08:17:44 <pozic> That's contrary to my experience with libraries. 
08:17:51 <Saizan> earthy: not writing the other-modules with Cabal < 1.8, breaks cabal sdist if your executable uses a module not in the lib, doesn't matter if it's exposed
08:18:15 <earthy> ah, but it'd do that anyway, right?
08:18:22 <pozic> I would love to have all libraries designed with the same kind of rigour that I displayed here. 
08:18:44 <earthy> so, other-modules is mainly there for cabal sdist to work?
08:19:09 <Saizan> earthy: with Cabal 1.8 you can put the lib in the build-depends field of the executable, and it'll just use it as any other lib, so the exe can only make use of the exposed modules
08:19:14 <jix> pozic: i would prefer just stating this limitation in the documentation + a library that handles general rate limiting
08:19:19 * earthy nods
08:19:23 <earthy> that's what I want anyway
08:19:28 <Saizan> earthy: except that because of how ghc --make work you've to use different source dirs
08:19:31 <earthy> (good SE practice)
08:20:08 <Saizan> earthy: other-modules is there for cabal sdist and for modules that need preprocessing, mainly
08:20:19 <pozic> jix: and how would this general rate limiting work?
08:20:21 <sm> pozic: it won't always work if the db requires setup, is hard to install, has its own failure modes
08:20:22 <earthy> the executable sources are in a subdir already so that's not an issue
08:20:33 <earthy> okay. so that'd work.
08:21:10 <jix> pozic: the way you described for example, my point is just that it doesn't belong into a library that issues requests to a server when ther server itself has no means to detect the usage rate
08:21:40 <jix> erm, if you have no way to get the detected usage rate from the server i mean
08:22:28 <earthy> hm. that's odd.
08:22:30 <pozic> jix: where it belongs is rather personal, so what you think (or indeed myself) thinks is rather irrelevant. Whatever solution that uses the least amount of code duplication and shows the lowest error rate should be selected.
08:22:38 <earthy> cannot satisfy -package-id and then the local pacakge
08:22:44 <earthy> and I'm using cabal 1.8.0.2
08:22:46 <gwern> ironically, this wouldn't be a hard problem if we had easy global variables. you could at least be confident that individual programs would not trip the rate-limit
08:22:59 <pozic> gwern: you can use a TVar just fine.
08:23:48 <Saizan> earthy: maybe try cabal clean first?
08:24:16 <earthy> it was clean, afaict, retrying with an upgraded cabal-install :)
08:24:47 <earthy> (man, that upgrades a *lot*... didn't think my libs were that old)
08:24:54 <Saizan> earthy: wait!
08:25:06 <Saizan> did you run "cabal upgrade cabal-install"?
08:25:13 <Saizan> that's bad.
08:25:18 * earthy notices. ;)
08:25:26 <earthy> that upgrades *everything*
08:25:30 <Saizan> "cabal install Cabal cabal-install" better
08:25:32 <earthy> me no want that. ;)
08:27:29 * earthy wipes ~/.cabal and starts afresh
08:27:47 * hackagebot archiver 0.1 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.1 (GwernBranwen)
08:28:15 <Saizan> earthy: the one to wipe is not .cabal but .ghc
08:28:37 <earthy> actually, both. :)
08:28:44 <earthy> nice and clean now.
08:29:38 <Saizan> .cabal has the cache of source tarballs and the config
08:29:51 <earthy> the config I spared
08:30:03 <earthy> the source tarballs were old anyway, as was the hackage cache
08:30:18 <earthy> (late may)
08:31:14 <gwern> pozic: you really want to engineer it, feel free: http://community.haskell.org/~gwern/archiver/
08:34:05 <Saizan> my .cabal is 2.3GB, maybe i should clean it too
08:36:40 * earthy watches a shitload of yummy goody packages get installed anew
08:37:28 <EvanR-work> cabbages
08:37:52 * hackagebot xilinx-lava 5.0.0.3 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.3 (SatnamSingh)
08:38:46 <mm_freak> wow, .cabal grows quickly
08:38:52 <mm_freak> % du -hs .cabal/
08:38:52 <mm_freak> 249M	.cabal/
08:39:07 <earthy> 142M
08:39:14 <earthy> yup, it does. :)
08:40:32 <EvanR-work> this lava thing looks awesome
08:41:00 <earthy> interesting. now it cannot construct a valid install plan...
08:49:08 <earthy> *ah!*
08:49:09 <earthy> gotcha.
08:49:19 <earthy> that's a nasty gotcha by the way...
08:49:40 <earthy> 1. it's not 1.8, but 1.8.0.4 that introduces library self-reference
08:50:21 <earthy> 2. bash keeps a cache of which binaries are where, so a newly installed cabal-install is not automatically picked up even if it comes earlier in the path
08:53:39 <Saizan> ah, sorry for the confusion about the version :)
08:56:18 * sm takes note
08:58:50 <ddarius> Won't cabal install Cabal cabal-install get the latest anyway?
09:00:47 <Saizan> it should
09:07:25 <quicksilver> earthy: hash -r, but maybe you worked that out
09:10:07 <monochrom> ♥
09:10:22 <zygoloid> aww
09:11:57 <quicksilver> monochrom: earthy had bash finding an old version of the 'cabal' binary because of bash's cache
09:13:10 <monochrom> I use bash too but I haven't run into that for a long time.
09:13:29 <zygoloid> @let i ♥ 0 = i; i ♥ u | even (i + u) = (3 * i + 1) ♥ (u - 1) | otherwise = (i `div` 2) ♥ (2 * u)
09:13:31 <lambdabot>  Defined.
09:13:41 <zygoloid> > 4 ♥ 7
09:13:42 <lambdabot>   11957422
09:13:47 <geheimdienst> quicksilver: bash caches binary paths ...?
09:14:04 <monochrom> It can.
09:14:05 <quicksilver> geheimdienst: yup.
09:14:37 <quicksilver> geheimdienst: it's because in the bad old days of NFS it took *ages* to find something on the PATH
09:14:47 <zygoloid> > zipWith (♥) [1..5] [1..5]
09:14:48 <lambdabot>   [4,22,94,364,1336]
09:14:51 <quicksilver> at least, that's what I assume
09:15:09 <monochrom> in the old days everything was slow and cached
09:15:17 <zygoloid> > liftM2 (♥) [1..5] [1..5]
09:15:17 <lambdabot>   [4,40,40,3280,364,40,22,265720,202,1743392200,10,3280,94,21523360,850,22,40...
09:15:37 <monochrom> remember netscape was a big deal over mosaic just because netscape caches?
09:16:29 <geheimdienst> sounds strange ... afaik filesystems do lots of caching already
09:19:13 <ddarius> Why would NFS directories be on your PATH?
09:19:44 <quicksilver> ddarius: used to be the standard way to set up (unix-like) systems
09:19:50 <quicksilver> binaries on a central server
09:19:54 <monochrom> because /home/monochrom/bin is on NFS
09:20:06 <quicksilver> possibly not basic systems binaries
09:20:07 <monochrom> and why? because it's the schools lab
09:20:11 <quicksilver> but all the site-installed stuff
09:22:00 <geheimdienst> i guess i'd have a directory of symlinks locally ... bash could complete them quickly and when you need the binary, the symlink gets resolved over the network. updating the symlink dir would be a short command
09:22:11 <monochrom> then again, in those days, a student is given like just 5MB of disk quota. could not install ghc anyway, nevermind cabal.
09:22:12 <geheimdienst> </armchair-software-redesigning>
09:22:27 <ddarius> monochrom: Presumably GHC fit in 5MB back in the day.
09:23:08 <geheimdienst> a directory of stuff would be more look-into-able than some bash cache implemented lord-knows-how, possibly as a binary blob or whatever
09:47:38 * hackagebot http-enumerator 0.0.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.0.1 (MichaelSnoyman)
09:49:42 * hackagebot msgpack 0.4.0 - A Haskell binding to MessagePack  http://hackage.haskell.org/package/msgpack-0.4.0 (HideyukiTanaka)
09:49:44 * hackagebot msgpack-rpc 0.4.0 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.4.0 (HideyukiTanaka)
09:54:43 * hackagebot RSA 1.0.6 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.0.6 (AdamWick)
09:57:01 <monochrom> alex-meta and happy-meta...
10:00:03 <mreh> does do { ~(a,b) <- m ; return () } get translated nicely?
10:00:24 <dolio> What's nicely mean?
10:00:33 <mreh> m >>= \~(a,b) -> ...
10:00:38 <zygoloid> you mean, without the 'fail' clause in the case?
10:00:45 <dolio> It should.
10:00:52 <mreh> what case?
10:01:03 <zygoloid> i think it's: m >>= \v -> case v of ~(a,b) -> return (); _ -> fail "pattern match failure"
10:01:05 <mreh> I want an irrefutable pattern basically
10:01:25 <mreh> bum
10:01:40 <monochrom> you will get an irrefutable pattern.
10:01:43 <dolio> @undo do { ~(a, b) <- m ; return () }
10:01:43 <lambdabot> m >>= \ ~(a, b) -> return ()
10:01:44 <zygoloid> i'm not sure, but i don't remember the report saying it was a special case?
10:01:55 <vanadium> dons: Thanks for retweeting that guy's blog post on frameworks :V
10:03:04 <monochrom> the report doesn't make a special case
10:03:11 <zygoloid> no. but ghc perhasp does.
10:03:36 <dolio> I suspect GHC's translation is a little more intelligent than the report.
10:03:58 <monochrom> the report allows equivalent coding anyway
10:04:01 <altious> sorry for interrupting. how can i get IO result without assigning it to a variable?
10:04:24 <mreh> altious: s'alright
10:04:25 <vanadium> unsafePerformIO
10:04:25 <zygoloid> altious: you want to pass an IO result to another function?
10:04:33 <zygoloid> altious: it depends whether that function has an IO result or not.
10:04:33 <altious> zygoloid, yes
10:04:46 <altious> not, it does not\
10:04:50 * geheimdienst has scrolled thoroughly over the blog post and read all the section headings. geheimdienst agrees with it.
10:04:54 <zygoloid> if the function has an IO result itself, then you can use =<<. otherwise, you can use fmap or liftM (they're the same thing here)
10:05:03 <mreh> what I actually want is lazy evaluation, does the case allow that?
10:05:15 <altious> zygoloid, ok, thanks
10:05:18 <zygoloid> mreh: yes, since it's got an irrefutable pattern.
10:05:22 <monochrom> but "do I get an irrefutable pattern" is independent of "does the code contain a second case". The second case is ignored anyway.
10:05:33 <zygoloid> (the actual translation is to a function, but i don't think that makes a difference here)
10:06:01 <monochrom> > case Nothing of {~(Just _) -> "just"; _ -> "else" }
10:06:02 <lambdabot>   "just"
10:06:44 <zygoloid> > [undefined] >>= (\v -> let f ~(a,b) = return (); f _ = fail "..." in f v)
10:06:45 <lambdabot>   [()]
10:06:48 <mreh> I wanted to define something with mfix
10:06:55 <mreh> yah, cheers
10:07:06 <monochrom> > let { ok ~(Just _) = "just"; ok _ = "else" } in Nothing>>=ok
10:07:07 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
10:07:07 <lambdabot>         against inferred ...
10:07:09 <zygoloid> > do ~(a,b) <- [undefined]; return ()
10:07:10 <lambdabot>   [()]
10:07:28 <monochrom> > let { ok ~(Just _) = "just"; ok _ = "else" } in return Nothing >>= ok
10:07:28 <lambdabot>   "just"
10:07:43 <monochrom> that is the report's translation
10:11:38 <geheimdienst> > uncurry (++) $ ("J" &&& tail) "Don Stewart"
10:11:39 <lambdabot>   Couldn't match expected type `a b c'
10:11:39 <lambdabot>         against inferred type `[GHC.Ty...
10:11:54 <geheimdienst> > uncurry (++) $ (const "J" &&& tail) "Don Stewart"
10:11:55 <lambdabot>   "Jon Stewart"
10:11:59 <geheimdienst> omg!
10:12:41 <zygoloid> > liftM2 (++) ["Donald", "Kiefer"] [" Steward", " Sutherland"]
10:12:43 <lambdabot>   ["Donald Steward","Donald Sutherland","Kiefer Steward","Kiefer Sutherland"]
10:13:23 <geheimdienst> who are these peoples. kiefer sutherland is some actor dude
10:16:59 <geheimdienst> wasn't there an ivan sutherland who did some groundbreaking computer graphics things in, like, 1720 or something
10:17:15 <Adamant> yes
10:17:20 <sproingie> 1720 computer graphics?
10:17:33 <alej> ivan sutherland invented sketchpad
10:17:35 <sproingie> were there even jacqard looms then?
10:17:36 <alej> wasn't 1720 though
10:17:39 <geheimdienst> i'm using that year as a placeholder for when dinosaurs roamed the earth
10:17:57 <Veinor> haha
10:18:00 <Adamant> geheimdienst: calculus-inventing dinosaurs
10:18:04 <geheimdienst> and computers were made of stone cogwheels
10:18:05 <Veinor> and eight megs was a lot of ram
10:18:43 <geheimdienst> in my day, we didn't have ram! the cpu told us all intermediate results and we had to keep it in our heads!
10:19:06 <byorgey> http://www.qwantz.com/index.php?comic=958
10:19:11 <alej> in my day we didn't have sketchpad
10:20:38 <mreh> I read a paper from the 70s where they talk about deformable objects
10:20:39 <sproingie> sutherland has some pretty famous protogees
10:20:41 <geheimdienst> see, the green dude says "it is an advanced literary technique used by only our most handsome authors". it is clear to me who he refers to
10:20:58 <sproingie> alan kay, henri gourad, edwin catmull
10:21:21 <Adamant> Veinor: Eight Megs And Constantly Swapping
10:21:27 <alej> o buuuurn
10:21:28 <Veinor> yep :D
10:21:30 <geheimdienst> dunno the second, but catmull probably contributed the catmull to catmull-rom splines
10:21:49 <Veinor> my current aquamacs instance is using 24MB
10:21:54 <Veinor> I wonder what they would've thought of that
10:21:54 <Adamant> alej: I use Emacs. it beats the crap out of Eclipse in that regard.
10:22:11 <alej> haha
10:22:13 <alej> i use emacs too
10:22:22 <Veinor> I'm trying to learn org-mode
10:22:46 <alej> man all you'll need is to boot into an emacs session
10:22:47 <Adamant> now if we could just swap out elisp for a parenscript, or Scheme, or basically anything not awful.
10:23:01 <Veinor> pretty much
10:23:27 <geheimdienst> ram free is ram wasted
10:23:53 <Adamant> unless you can power down RAM banks and are power-constrained
10:23:55 <Veinor> I want to hack htop to say 'ram that could be used to help cache data'
10:23:59 <Adamant> so for us, yeh
10:24:23 <Veinor> orgmode is actually pretty cool, the one problem is that I can't look at my todo lists on my phone
10:24:25 <sproingie> Eight Megs and Fits in the L2 CPU Cache doesn't roll off the tongue quite as nicely
10:24:37 <Veinor> haha
10:24:48 <Adamant> I don't think we have Eight Meg L2 caches yet, do we?
10:24:59 <Adamant> I thought it was still 4
10:25:01 <sproingie> my core 2 EE has 12M cache
10:25:05 <Adamant> ah
10:25:07 <altious> zygoloid, sorry, but can fmap/liftM be used to demote monad? fmap prototype is fmap :: (a -> b) -> f a -> f b, but i think i need something like :: f a -> a
10:25:08 <Adamant> fair enough
10:25:25 <altious> cannot get how to use liftM for removing monad
10:25:26 <Adamant> sproingie: there's a cool trick where you fit a interpreter into L1 cache
10:25:39 <Adamant> all of a sudden it gets Very fast
10:25:43 <geheimdienst> individual ram banks can be powered off? woah
10:25:46 <geheimdienst> never heard of that
10:25:57 <sproingie> Adamant: lua tends to fit that way
10:26:01 <Adamant> geheimdienst: theoretically you could design for that
10:26:05 <geheimdienst> http://www.youtube.com/watch?v=mOZqRJzE8xg <- alan kay presenting ivan sutherland's sketchpad. impressive
10:26:22 <Adamant> geheimdienst: I don't know of anywhere but embedded where it would happen
10:26:33 <sproingie> nontrivial lua scripts do a lot of extra heap allocation, but the program and interpreter compile down teeny tiny
10:26:54 <Jafet> "Save power dude, spin down yer RAM"
10:26:54 <Adamant> maybe when we have 16Gigs of memory in your standard laptop it will be adopted as a power saver technique
10:27:30 <sproingie> doubt it.  it'd probably run cooler to spread it out
10:27:37 <Adamant> maybe
10:27:48 <Adamant> not sure it would spread it out by default
10:27:58 <Veinor> altious: there's no general function of the type (Monad m) => m a -> a
10:28:03 <sproingie> the os tends to do a pretty good job of that
10:28:10 <Adamant> that is a good thought, though
10:28:11 <Veinor> consider how you would write a function of type [a] -> a
10:28:14 <geheimdienst> my gut feeling is that ram is not a prime energy eater
10:28:19 <Adamant> it isn't
10:28:27 <geheimdienst> so that optimization may not even buy much
10:28:28 <sproingie> ram gets kinda hot
10:28:32 <Adamant> removing optical drives is first
10:28:55 <Adamant> that's the single biggest easy optimization
10:29:19 <sproingie> already gone in the super slim laptops
10:29:20 <Adamant> screen backlighting used to be awful but is less so with LED's
10:29:29 <geheimdienst> that's more of a weight or space issue. the optical drive doesn't nom power when it's off
10:29:44 <altious> Veinor, :(
10:29:48 <Adamant> geheimdienst: it does, a very small amount. it uses a huge amount in use
10:29:50 <sproingie> when large amoled screens get cost effective to make, we'll see laptops thinner than the connectors that go into them
10:29:58 <Veinor> also, it could let you break out of IO, which is bad
10:29:59 <Adamant> that would be nice.
10:30:04 <sproingie> dell's got one that's already thinner than a usb A connector
10:30:09 <Veinor> sproingie: the eee 1008HA is thinner than an ethernet port
10:30:18 <Veinor> (not including the LCD)
10:30:47 <sproingie> i'm holding out for a 50" OLED TV :)
10:31:00 <sproingie> could get one now if i didnt mind spending half my life savings
10:31:05 <Veinor> it actually does have an ethernet port, the bottom half is on a hinge that swings out
10:31:26 <sproingie> i think the dell puts the usb port near the hinge where it fattens up a smidge
10:32:08 <sproingie> we need a new form factor for the A side of usb
10:32:14 <sproingie> got tons for the B side
10:32:27 <zygoloid> altious: that cannot, in general, be done. (in fact, that wrapper-which-can't-be-removed property is /why/ we can treat IO operations as a monad)
10:32:37 <Adamant> sproingie: mini micro nano pico A
10:32:41 <Jafet> We need something that polls faster than three millionths the clock rate of the processor
10:33:02 <sproingie> should just do like firewire and use the same goddam connection for both sides
10:33:15 <zygoloid> altious: instead, what you can do is to build a bigger "IO a" computation which performs the IO then does whatever else you want to do
10:33:18 <Adamant> let's just use Firewire instead
10:33:29 <Adamant> the cost should be less these days
10:33:34 <sproingie> FW is not without its own problems.
10:33:44 <Adamant> like accessing OS memory
10:33:44 <sproingie> usb and fw need to both stay, competition is good
10:33:46 <Adamant> :P
10:33:55 <sproingie> unreliable protocol too, iirc
10:34:13 <Adamant> sproingie: maybe a common but differenated connector as well
10:34:27 * geheimdienst just realizes that he has never once used the fw port on his laptop
10:34:42 <Adamant> geheimdienst: Firewire 800 is great for laptops
10:34:48 <zygoloid> firewire: increasing the cost of your hardware to give you facilities you will never use
10:34:50 <Adamant> since ESATA requires power
10:34:53 <geheimdienst> you mean for external HDs?
10:34:55 <Adamant> yah
10:35:04 <geheimdienst> i see
10:38:57 <sproingie> ESATA is nice but hotplug support tends to be flakey in most OS's
10:39:15 <boegel> are 'commands' in the IO monad (do notation) executed in non-lazy fashion?
10:39:54 <sproingie> everything's evaluated lazily.  by the time you get to executing a command, there's no laziness to consider though
10:40:35 <sproingie> tho i suspect what you mean is, is the block non-strict, so the answer is nes
10:40:38 <sproingie> yes
10:40:39 <boegel> e.g. if I would want to time how long it takes to execute some stuff, could I do main = do t <- liftIO getClockTime; <whatever>; t' <- liftIO getClockTime; <compute time difference> ?
10:40:46 <sproingie> (nes or yo)
10:40:47 <boegel> sproingie: nes :D
10:41:10 <boegel> sproingie: what's the difference between non-strict and lazy?
10:41:39 * boegel is getting back to Haskell now, and wants to increase his Haskell-fu
10:41:43 <sproingie> boegel: lazy is a specific way of doing non-strict.  haskell doesnt actually say you have to specifically use laziness
10:41:51 <sproingie> boegel: the exact differences are over my head
10:42:16 <osaunders> What does the type ((->) r) mean?
10:42:20 <roconnor> boegel: it is a bit tricky,  the time will include the execution time of all the IO actions that <whatever> take, plus all the evaluation time it takes to comput the inputs to those IO action, but may not include the time to evaluate the result of those IO actions
10:42:24 <boegel> sproingie: ok, but does it allow to time a series of "commands" (right terminology here?) ?
10:42:26 <sproingie> boegel: for all intents and purposes, you can treat them the same
10:42:51 <boegel> roconnor: ok, thx
10:43:00 <boegel> roconnor: so, would you say there's a better way then?
10:43:11 <sproingie> boegel: the reason IO actions execute in series has to do with the way monads work.  you can't get the right side of >>= without evaluating the left
10:43:20 <boegel> roconnor: or should I enforce evaluation of all the inputs prior to the first getClockTime?
10:43:34 <boegel> sproingie: makes sense
10:43:46 <roconnor> boegel: you may want to deepseq on the result of whatever, 
10:43:51 <sproingie> boegel: sequencing is in fact one of the main reasons for using a monad (though don't confuse it with that being the primary or only purpose of monads)
10:44:04 <roconnor> boegel: Of course if whatever is an IO (), then there is no problem.
10:44:29 <roconnor> @wiki IO_Semantics
10:44:29 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
10:44:36 <roconnor> boegel: have you read my page on IO_Semantics?
10:45:07 * osaunders goes for a nap
10:45:31 <boegel> roconnor: checking it out
10:45:47 <sproingie> so it's basically graph reduction?
10:47:33 <boegel> roconnor: ok, done, although I'm not sure I fully get it
10:47:52 <roconnor> I should maybe add some diagrams
10:49:46 <roconnor> The idea is that IO a is a tree.  The node are system calls with their parameters, and there is a subtree under each node for each possible response to the syscall.  Finally the leaves of the tree hold the data a
10:50:54 <roconnor> The IO a data structure contains all the instructuction for interacting with the operating system.  It contains the information of what queries to the OS and how to proceed when it gets a response.
10:52:19 <boegel> right
10:52:25 <roconnor> the runtime system then takes this data structure and uses it to interact with the OS.  Making system calls according to that plan and then looking up in the tree how to respond to those requests with further system calls.
10:52:40 <roconnor> for each run of the program large parts of the tree will be ignored
10:52:46 <boegel> of course
10:52:58 <roconnor> this is the denotational view
10:53:24 <roconnor> operationally speaking the IO tree is only generated just in time.  So those parts of the tree that are not needed are not even computed.
10:53:49 <roconnor> and that's it
10:53:54 <boegel> uhu
10:53:56 <boegel> so
10:54:06 <roconnor> none of this State RealWord nonsense is needed
10:54:46 <boegel> to truly time the <whatever> part, and only that, I need to 1) enforce evaluation of the inputs to whatever first, 2) deepseq on whatever prior to calling getClockTime the 2nd time
10:54:47 <boegel> right?
10:55:08 <zygoloid> my favourite view of the IO monad is that it's really the FFI monad
10:55:17 <roconnor> you don't really need to do 1
10:55:17 <black_custard> i don't quite remember, but, isn't there a function with type [IO a] -> IO a?
10:55:19 <boegel> is deepseq enough to *fully* evaluate the stuff I'm doing in whatever? it's also non IO() stuff being computed as input to the IO () stuff in whatever
10:55:36 <roconnor> boegel: because the inputs that are needed will be forced by whatever anyways
10:55:50 <zygoloid> (the free monad over the obvious FFI functor)
10:55:54 <ppavelV6> black_custard: depends on a :0
10:55:59 <black_custard> its ()
10:56:05 <zygoloid> plus an exception transformer i guess ;(
10:56:09 <vanadium> zygoloid: It is not obvious to me :V
10:56:21 <ppavelV6> black_custard: sequence_
10:56:24 <ppavelV6> :t sequence_
10:56:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:56:28 <boegel> roconnor: yes, but I don't want to include that in the timing, those things shoudl be ready prior to timing whatever
10:56:40 <roconnor> oh yes
10:56:57 <black_custard> yay! thanks ppavelV6 :)
10:57:05 <boegel> roconnor: so, is deepseq enough? even if lists of lists and such things are produced by whatever?
10:57:08 <roconnor> if you don't want that included in the timing then you need to deepseq the inputs before starting the timer.
10:57:36 <roconnor> boegel: it should be enough. ... it might even be too much
10:57:37 <ppavelV6> black_custard: you're welcome. btw hayoo and hoogle are your friends :) both are capable of searching functions by signature
10:58:00 <roconnor> boegel: if your whatever is "return (cycle "forever")"
10:58:09 <roconnor> boegel: then deepseqing that will run forever.
10:58:17 <zygoloid> vanadium: take the FFI functor to be the free functor over 'data FFI a where Read :: CInt -> Ptr Char -> CSize -> FFI CInt; ...' with one ctor for each foreign import
10:58:24 <roconnor> boegel: it really depends on what you really want to time
10:58:25 <black_custard> didn't know they could do that, i was just using google
10:58:29 <zygoloid> then take IO to be the free monad over that
10:59:02 <boegel> roconnor: right
10:59:04 <roconnor> zygoloid: that isn't so different from my point of view
10:59:23 <roconnor> zygoloid: it is just s/syscall/FFI call/
10:59:39 <roconnor> zygoloid: I'll actually consider taking up that point of view.
10:59:51 <vanadium> I will consider reading up on CT until I understand it
10:59:53 <roconnor> zygoloid: my IO is the free monad over syscalls
11:00:05 <zygoloid> roconnor: the trouble with the syscall view, as an operational model, is that it's wrong in the presence of LD_PRELOAD
11:00:19 <roconnor> zygoloid: it is?
11:00:41 <geheimdienst> wat
11:00:49 <zygoloid> yeah. FFI calls and primops don't have a predetermined meaning in terms of syscalls if you can replace read/select/whatever at runtime
11:01:16 <vanadium> *replaces select with epoll at runtime*
11:01:30 <roconnor> zygoloid: but in a free monad I don't give a meaning to the syscalls
11:01:50 <roconnor> zygoloid: so if they "change meaning" that is irrelevent because I haven't used their meaning 
11:02:25 <roconnor> er
11:02:29 <roconnor> hmm
11:02:31 <roconnor> wait
11:02:36 <zygoloid> it's not that the syscalls change meaning, it's that, for instance, getContents becomes a different set of syscalls
11:02:49 <roconnor> I see
11:03:03 <roconnor> okay
11:03:22 <roconnor> this seems good
11:03:28 <roconnor> nodes of FFI calls
11:03:33 <zygoloid> it also seems a little more portable to draw the boundary there rather than at the os interface
11:03:40 <roconnor> yes
11:03:49 <roconnor> I like this
11:04:34 <zygoloid> you still need a mechanism for dealing with exceptions, especially those thrown implicitly by pure code or the RTS.
11:05:18 <roconnor> zygoloid: is that Haskell 98?
11:05:26 <dolio> No.
11:05:33 <roconnor> then I don't care :D
11:05:41 <zygoloid> :)
11:05:54 <zygoloid> it's not even haskell 2010 :)
11:05:59 <roconnor> I'm more intrested in getting a reasonable model of concerency
11:06:05 <roconnor> which isn't H98 either
11:06:12 <roconnor> but far more interesting to me :)
11:07:05 <dolio> Concurrency isn't so hard, although you'll never capture the way GHC does it.
11:08:01 <roconnor> dolio: is this free FFI monad capturing sequntial programming the way GHC does?
11:08:35 <dolio> No. At best, that'd allow you to preempt at each FFI/system call.
11:08:46 <dolio> GHC can preempt during any memory allocation.
11:09:03 <roconnor> preempt?
11:11:10 <ddarius> dolio: Would that be a problem if you only cared about the observable output of the program?
11:11:47 <roconnor> zygoloid: I'm really happy to get away from this State Realworld nonsense
11:11:58 <roconnor> zygoloid: that explaination is nonsensical IMHO.
11:12:16 <roconnor> people need to stop using it to explain to newbies.
11:12:24 <ddarius> Agreed.
11:13:27 <boegel> roconnor: in order to use deepSeq, I need to implement an instance of whatever I'm deepSeq'ing; in my case, that's something of type [Order], with Order a self-defined data type (Order Int Int Int)
11:13:47 <dolio> ddarius: Probably. I'm not sure it even matters then.
11:13:55 <roconnor> boegel: you should be able to use advanced deriving for that.  Writing it yourself isn't hard either.
11:14:00 <Jafet> Does IO () have buddha nature?
11:14:13 <sproingie> Jafet: ()
11:14:20 <boegel> roconnor: is the corresponding NFData instance as simple as "rnf (Order a b c) = a `seq` b `seq` c `seq` ()" ? 
11:14:29 <dolio> You might need to look at stuff like memory usage behavior, or timing of the output to see the difference.
11:14:39 <roconnor> boegel: I believe so.
11:14:55 <boegel> roconnor: will that fully evaluate the Ints?
11:15:02 <roconnor> boegel: I beleive so
11:15:11 <boegel> roconnor: hmmk, great, thx
11:15:20 <roconnor> @type rnf
11:15:21 <lambdabot> forall a. (NFData a) => a -> Done
11:16:35 <Jafet> Another answer might be ⟂.
11:17:32 <roconnor> ``Buddha-nature is not to be confused with the concept of Atman, or Self, but instead is viewed to be empty of defining characteristics (also see Sunyata and Nondualism).''
11:17:46 <roconnor> heh, I think conal thinks that IO () has the buddha-nature
11:17:55 <roconnor> but I don't think it does
11:18:32 <Entroacceptor> so Buddha nature is logically impossible, right?
11:18:37 <dolio> roconnor: I mean, if all you care about is having an IO that has concurrency constructs, then it's easy. You just add stuff like fork, new/get/putMVar and stuff into your free monad.
11:18:40 <roconnor> Entroacceptor: I don't think so
11:18:57 <roconnor> Skolem contants come close to having the buddha-nature.
11:19:34 <Entroacceptor> wouldn't "having the buddha nature" be a defining characteristic?
11:19:54 <roconnor> dolio: indeed, but I suspect there would be equivalent trees that would would like to identify if you did that.
11:20:08 <dolio> If you care about explaining what happens when things are forked, via some scheduler, then you have to decide how to interleave the various trees. GHC can switch out one tree for another any time a memory allocation happens. Some kind of call-response tree can only interleave the commands.
11:20:09 <roconnor> Entroacceptor: O_o
11:20:29 <ddarius> @google poor man's concurrency monad
11:20:30 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039
11:20:38 <roconnor> Entroacceptor: #haskell blows my mind yet again
11:20:41 <geheimdienst> IO has quite a belly and an ear-to-ear smile. close enough for me
11:21:27 <roconnor> dolio: ghc only premepts during memory allocations?
11:21:40 <roconnor> dolio: I presumed it could premept whenever it damn well pleases
11:21:54 <ddarius> roconnor: Nope.  That would be expensive.
11:22:08 <dolio> Nope. And if you have tight-allocationless loops, you can block other threads from running.
11:22:34 <geheimdienst> aim in ur rts, prempin u inespensively at welldefind points
11:22:42 <dolio> Just like if you were only looking at call-response trees, large pure sections would be unable to be preempted.
11:22:43 <roconnor> ddarius: still, the proper semantics of concurent IO should allow schedules ot premept whenever they dam well please.
11:23:17 <roconnor> dolio: but premempting pure sections isn't observable
11:23:19 <ddarius> roconnor: Modulo the starvation case dolio mentioned, it doesn't really matter for IO.
11:23:46 <dolio> roconnor: It isn't observable up to what the program outputs, at least.
11:23:54 <roconnor> dolio: we want to capture only the denotation of concurent IO, not the full operational behaviour
11:25:07 <dolio> But, ghc can, say, preempt the running of 'length (powerlist [1..10000000])' in one thread to do stuff in another.
11:25:28 <dolio> Which, if you can observe allocation behavior, would look different than running the second thread either before or after that entire computation.
11:25:50 <dolio> Or, it could, at least.
11:25:52 * hackagebot exception-mtl 0.1 - An mtl-compatible monad transformer for unchecked extensible  exceptions.  http://hackage.haskell.org/package/exception-mtl-0.1 (GeoffreyMainland)
11:25:54 * hackagebot exception-monads-fd 0.1 - A monads-fd monad transformer for unchecked extensible  exceptions.  http://hackage.haskell.org/package/exception-monads-fd-0.1 (GeoffreyMainland)
11:25:56 <roconnor> dolio: interesting
11:26:52 * hackagebot exception-monads-tf 0.1 - A monads-tf monad transformer for unchecked extensible  exceptions.  http://hackage.haskell.org/package/exception-monads-tf-0.1 (GeoffreyMainland)
11:26:59 <ddarius> For the purpose of just modelling IO, if you can observe memory usage you'd have to define memory usage.  If memory usage is undefined, then any observation is valid.
11:27:30 <roconnor> but I'm unsure it matters since the FFI call "to observe the memory useage" isn't really part of the semantice of our free monad
11:28:01 <roconnor> all you can say is that you made and FFI call and here is what to do with the various responses, whatever they are
11:28:07 <roconnor> so ya, what ddarius said
11:28:12 <dolio> I was thinking more along the lines of an external observer.
11:48:38 <azaq231> lamdabots google module seems broken
11:48:42 <azaq231> @google something
11:48:43 <lambdabot> http://www.something.com/
11:48:43 <lambdabot> Title: Something.
11:48:46 <azaq231> not
11:49:15 <azaq231> @google rheinmetall
11:49:17 <lambdabot> Plugin `search' failed with: No Location header found in 3xx response.
11:49:20 <azaq231> that
11:49:28 <nlogax> is there a function somewhere in the time libs that can help me turn a NominalDiffTime into days/hours/seconds?
11:49:31 <zygoloid> @google cats in hats
11:49:32 <lambdabot> No Result Found.
11:49:38 <zygoloid> ^^ i find that very hard to believe
11:50:56 <azaq231> well, the rheinmetall one doesn't work
11:51:22 <zygoloid> incidentally, win: http://rofl.wheresthebeef.co.uk/Cat%20Hat.jpg
11:51:30 * hackagebot msgpack 0.4.0.1 - A Haskell binding to MessagePack  http://hackage.haskell.org/package/msgpack-0.4.0.1 (HideyukiTanaka)
11:52:18 <EvanR-work> im looking at Network.FastCGI
11:52:27 <EvanR-work> good?
11:55:07 <jcowan> Is there a natural extension of folding to multi-dimensional arrays, or it is it necessary to specify a dimension and fold over the sequence of values on that dimension?
11:57:27 <ddarius> Folds have been extended to exponential types and you can view an array, multidimensional or not, as a function Ix -> a
11:59:50 <c_wraith> in SKI combinators, S=<*>, K=const, I=id ?
12:00:37 <ddarius> Yes.
12:00:50 <c_wraith> K is for Konst.  got it. :)
12:01:47 <ddarius> c_wraith: The letters make (more) sense in German.
12:04:08 <jcowan> ddarius: Can you point me to an explication of this idea?
12:04:28 <ddarius> @google Bananas in Space
12:04:30 <lambdabot> http://www.3dwonders.com/
12:04:35 <ddarius> hmm
12:04:54 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.4921&rep=rep1&type=pdf
12:05:34 * hackagebot smartGroup 0.1.0 - group strings by words in common  http://hackage.haskell.org/package/smartGroup-0.1.0 (SamAnklesaria)
12:06:32 <azaq231> ddarius: what would S mean in german?
12:07:49 <ddarius> I don't recall.
12:30:12 <bonii> How can I do integer division ?
12:30:22 <EvanR-work> > 9 `div` 2
12:30:23 <lambdabot>   4
12:30:25 <ozataman> Hi all. Does anybody know whether the output of attoparsec can be processed lazily? I want to parse a very large input and process it and output back to a file in constant memory.
12:30:36 <EvanR-work> > (-9) `quot` 2
12:30:37 <lambdabot>   -4
12:30:43 <EvanR-work> > (-9) `div` 2
12:30:44 <lambdabot>   -5
12:30:51 <EvanR-work> > 9 `divMod` 2
12:30:52 <lambdabot>   (4,1)
12:31:18 <bonii> EvanR-work: Thanks :)
12:31:36 <bonii> EvanR-work: But why do we have to divs in Haskell ?
12:31:45 <bonii> EvanR-work: Why not let us type cast ?
12:32:22 <EvanR-work> you can
12:32:32 <EvanR-work> > floor (9 / 2)
12:32:33 <lambdabot>   4
12:33:26 <EvanR-work> :t floor
12:33:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:33:30 <Jafet> > let (/) = div in 9 / 2
12:33:31 <lambdabot>   4
12:34:04 <EvanR-work> bonii: integer division and floating point division are totally different operations on totally different objects with totally different aparent behavior
12:34:13 <EvanR-work> so it makes sense to make it two functions
12:34:20 <EvanR-work> one happens to be an operator
12:34:41 <EvanR-work> :t div
12:34:42 <lambdabot> forall a. (Integral a) => a -> a -> a
12:34:59 <bonii> :t /
12:34:59 <lambdabot> parse error on input `/'
12:35:16 <bonii> Oops
12:35:22 <bonii> :t div
12:35:23 <lambdabot> forall a. (Integral a) => a -> a -> a
12:35:46 <bonii> Understood, thanks EvanR-work 
12:35:52 <EvanR-work> :t (/)
12:35:53 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:35:53 <pasch> :t (/)
12:35:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:36:09 <Jafet> > let (//) = div in 9 // 2 -- hissss
12:36:10 <lambdabot>   4
12:36:20 <EvanR-work> python
12:36:46 <EvanR-work> but yeah // vs / is better than / means different things in different cases
12:36:57 <EvanR-work> cases not easy to differentiate by reading code
12:38:30 <EvanR-work> * makes sense because it has apparently the same effect
12:38:45 <EvanR-work> on integral and fractional
12:47:46 * hackagebot plugins 1.5.1.1 - Dynamic linking for Haskell and C objects  http://hackage.haskell.org/package/plugins-1.5.1.1 (DonaldStewart)
12:48:08 <Twey> plugins is still being developed?
12:50:05 <Entroacceptor> would that be a bad thing_
12:50:06 <Entroacceptor> ?
12:50:12 <monochrom> yesterday saw the 1.5.1 release. I wonder what changes cause 1.5.1.1
12:51:07 <monochrom> a month ago dons wanted to revive it. so it is wanted, so it is done.
12:52:38 <Entroacceptor> if I hear DSL one more time...
12:52:41 <monochrom> perhaps because the 1.5.1 build log says invalid UTF-8 sequence
12:52:44 <tommd> monochrom: darcs says  "Make ascii clean and ghci clean, bump"
12:53:08 <tommd> So I'm making this EDSL for ....
12:53:18 * monochrom whispers ADSL, does that count?
12:53:19 * Entroacceptor asplodes.
12:53:34 <Entroacceptor> tommd: but you forgot to spell it out
12:53:41 <Entroacceptor> like it's done every time...
12:53:55 <tommd> Thank god.  Who wants to spell that out what with how often it's said.
12:54:19 <trinithis> > uncurry0 "wow!" ()
12:54:20 <lambdabot>   "wow!"
12:54:49 * hackagebot web-routes 0.23.0 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.23.0 (JeremyShaw)
12:55:49 <bonii> If I have an function like "interpInst WRITE = do x <- pop", how can I chain it so that I can print x to the console ?
12:55:50 * hackagebot web-routes-hsp 0.21 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.21 (JeremyShaw)
12:56:10 <wto> :t all
12:56:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:56:53 <monochrom> I'm afraid "interpInst WRITE = do x <- pop" is incomplete or incorrect
12:57:49 <bonii> monochrom: I have bound the value inside the monadic value of pop to x and now I want to print it to the console 
12:58:09 <monochrom> do { x <- pop; print x }
12:59:09 <kmc> if i hear 'library' one more time...
12:59:29 <monochrom> I will go to my university's library tomorrow
12:59:44 <monochrom> (does that count?)
13:00:10 * monochrom is still choosing between buying or pirating TaPL
13:00:47 <kmc> @yarr
13:00:47 <lambdabot> Keelhaul the swabs!
13:02:26 <bonii> monochrom: interpInst WRITE returns a type Foo Bool
13:02:56 <bonii> so chaining print x is giving me issues with it 
13:03:02 <monochrom> is Foo your monad? is Foo capable of printing things to the console?
13:03:38 <bonii> monochrom: No, that is what I want to find out, how can I make my monad capable of printing or reading from Console 
13:04:29 <monochrom> it has to be built by combining a monad transformer with the IO monad
13:04:44 <edwardk> library.
13:04:48 * edwardk watches kmc explode.
13:05:03 <bonii> monochrom: Can you point me to any documentation for it ?
13:06:12 <monochrom> any tutorial or book that covers monad transformers. your favourite tutorial or book may have it.
13:06:42 <JoeyA> Has anyone made a library that facilitates converting SqlValue lists to/from custom data structures?
13:08:02 <JoeyA> I made an overly generic Serial class for serializing in and out of any monoid, but it's not really a good fit for what I'm doing.
13:08:26 <bonii> monochrom: Thanks 
13:14:03 * hackagebot plugins 1.5.1.2 - Dynamic linking for Haskell and C objects  http://hackage.haskell.org/package/plugins-1.5.1.2 (DonaldStewart)
13:17:01 <moosefish> So, here's an interesting thought experiment. I'm writing tests for the haskell thrift bindings. One obvious thing to do is to have a server receive an RPC from a client, and just reply with the same message (thrift is a request/response system, with an IDL for serializing structs/records to some wire format). How far do I need to go to ensure ghc doesn't optimize the serializing operations away?
13:18:01 <moosefish> Stated otherwise, the client would see the server as the id function, and the server would implement the id function... "ByteString -> SomeStruct -> SomeStruct -> ByteString)
13:18:08 <moosefish> I wanna make sure GHC doesn't remove the middle parts :P
13:19:27 <JoeyA> well, you'd be testing the compiler if you want to keep those optimizations.
13:19:53 <JoeyA> If you're testing the serialization itself, wouldn't you get typecheck errors or semantic bugs if the bindings were wrong?
13:20:02 <moosefish> Not necessarily
13:20:02 <freedrull> how can i parse exactly two digits with parsec? can i just call digit twice?
13:20:08 <leimy> > (,,,) 1 2 3 4
13:20:09 <lambdabot>   (1,2,3,4)
13:20:12 <moosefish> These are fairly loosely typed bindings
13:20:37 <moosefish> (For example, the just skip missing on incorrectly typed fields on the wire format)
13:20:41 <c_wraith> freedrull, you'd probably want something like (\x y -> x * 10 + y) <$> digit <*> digit
13:21:04 <moosefish> So a lot of stuff that's "obviously wrong" once you're used to the Haskell type system aren't particularly wrong from Thrift's perspective
13:22:06 * hackagebot happstack-facebook 0.24 - A package for building Facebook applications using Happstack  http://hackage.haskell.org/package/happstack-facebook-0.24 (JeremyShaw)
13:22:42 <moosefish> JoeyA: And I'm not sure what you mean by testing the compiler
13:26:48 <JoeyA> I was thinking that safe operations in Haskell should not be changed semantically by optimization (such as serialize/unserialize being short-circuited)
13:27:03 <JoeyA> If they were, it would be a compiler bug.
13:27:49 <moosefish> Well, that's the thing. Apart from ByteString I/O on/off the network... everything is manipulation using pure code.
13:28:10 <olsner> if serialize+unserialize is indeed the identity function, then hasn't the compiler already proven the program correct? :)
13:28:13 <moosefish> It's effectively side-effect free. The optimization would be entirely safe (if damn breathtaking)
13:28:40 <JoeyA> Wait for supercompilation :-)  (if it can do that sort of thing)
13:29:36 <freedrull> :t (<$>)
13:29:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:29:55 <freedrull> :t (<*>)
13:29:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:30:20 <c_wraith> freedrull, another way of writing that would be do { x <- digit ; y <- digit ; return $ 10 * x + y}
13:30:41 <freedrull> :3
13:30:48 <freedrull> ah i see
13:31:40 <moosefish> oisner: Yeah, pretty much. But I'd like to know :)
13:32:24 <leimy> > (\x -> pure (x + 1)) 3
13:32:24 <lambdabot>   No instance for (GHC.Show.Show (f a))
13:32:25 <lambdabot>    arising from a use of `M2020605715...
13:32:56 <leimy> > (\x -> pure (x + 1) :: Maybe Int) 3
13:32:57 <lambdabot>   Just 4
13:33:19 <leimy> (\x -> pure (x + 1) :: [Int]) 3
13:33:28 <leimy> > (\x -> pure (x + 1) :: [Int]) 3
13:33:29 <lambdabot>   [4]
13:34:57 <leimy> > Just 3 >>= (\x -> pure (x + 3))
13:34:58 <lambdabot>   Just 6
13:35:18 <leimy> Just (+3) <*> Just 3
13:35:27 <leimy> > Just (+3) <*> Just 3
13:35:28 <lambdabot>   Just 6
14:05:24 * hackagebot QuickCheck 2.3.0.2 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.3.0.2 (NickSmallbone)
14:05:57 <nomemory> I have to functions upperString :: Int -> [Char] and lowerString :: Int -> [Char] . How do I print their results like this: upperString on line 0 and lowerString on line 1 . (In stdout)
14:07:41 <mauke> putStr (upperString 0 ++ "\n" ++ lowerString ++ "\n")
14:12:29 <ajnsit> does anyone know what the status of pivotal is?
14:12:39 <ajnsit> I tried to compile it but it has really old dependencies
14:12:51 <ajnsit> looks like it may not be being updated
14:17:35 <djahandarie> ajnsit, seems dead. Try e-mailing Stefan Kahrs or Keith Hanna, since they are both still at the fp group at kent and they are the ones who made that
14:20:31 * hackagebot snap-core 0.2.12 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.12 (GregoryCollins)
14:23:46 <hancock> I'm having huge trouble with a homework in haskell. I'd say that I've written about 90-95% of the code but the last few steps in making everything work seem insurmountable. Is there anyone willing and able to help?
14:24:16 <wakeupsticky> i'm having some problem using random integers...
14:24:32 * hackagebot plugins 1.5.1.3 - Dynamic linking for Haskell and C objects  http://hackage.haskell.org/package/plugins-1.5.1.3 (DonaldStewart)
14:24:53 <monochrom> hey dons, are you done updating plugins?! XD
14:25:00 <wakeupsticky> Couldn't match expected type `Int' against inferred type `IO t'
14:25:12 <fxr> oh plugins back :)
14:25:33 <monochrom> more than back. 3 new versions in just one hour. XD
14:25:35 <wakeupsticky> I try to do "let cardnumber = getStdRandom (randomR (0, 51)) in ..."
14:25:47 <wakeupsticky> but apparently cardnumber isn't an integer, it's an IO t...?
14:26:00 <monochrom> it's an "IO Integer"
14:26:24 <monochrom> and yes it means you have to work inside IO and not take anything outside. "dine in only"
14:26:48 <wakeupsticky> so...my entire function that uses a random number has to be inside the IO monad? that's retarded
14:26:57 <sioraiocht> wakeupsticky: why? 
14:27:03 <wakeupsticky> because
14:27:06 <wakeupsticky> how is that not stupid?
14:27:10 <sioraiocht> wakeupsticky: you can use pure functions within the monad
14:27:32 <monochrom> some part of your algorithm can be written as a pure function. but you call the pure function from another thingy inside IO
14:27:33 * hackagebot snap-server 0.2.12 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.12 (GregoryCollins)
14:27:39 <PirateUnderwear> fxr: Hello, I built a arch ami on ec2. Thanks for guiding me in a close area.
14:27:43 <wakeupsticky> i've never used a programming language with such a stupid RNG
14:27:45 <wakeupsticky> honestly
14:28:11 <sioraiocht> Oh I see
14:28:20 <c_wraith> You mean you've never used a language that forced you to be clear what you were doing?
14:28:26 <monochrom> we all happily agree it is stupid. we are so friendly no one disagrees with you
14:28:26 <wakeupsticky> lol
14:28:44 <monochrom> People, beware of the provocative tactic. just agree with the whine.
14:28:45 <wakeupsticky> i'm clear on what i'm doing
14:28:52 <hancock> uhm .... yeah
14:29:03 <hancock> it seems no one is willing to help
14:29:04 <hancock> :(
14:29:43 <alej> hancock usually it helps to ask a question rather than ask if you can ask a question
14:29:54 <wakeupsticky> it would be fine if there was some resource that explained how to use random integers
14:29:59 <wakeupsticky> the documentation is cryptic
14:30:01 <megajosh2> There are...
14:30:02 <monochrom> anyway you have now just used a programming language with such a stupid RNG. so, tomorrow, you can no longer say you have never used one! :)
14:30:02 <wakeupsticky> no offense
14:30:02 <hancock> well
14:30:09 <hancock> I'm not able to match
14:30:10 <hancock> types
14:30:16 <hancock> I get multiple errors
14:30:18 <hancock> related to that
14:30:20 <monochrom> "lost innocence" or something
14:30:45 <PirateUnderwear> c_wraith: I was wondering, how would you deploy Snap on a server. Do I use Main.hs in the httpServe part?
14:31:06 <hancock> but the thing is some of these types are custom made
14:31:07 <hancock> so I need someone
14:31:08 <wakeupsticky> if there is a clear explanation of how to use random integers i'd like to see it
14:31:18 <hancock> who has enough time and knowledge
14:31:20 <hancock> to help
14:31:21 <alej> there are lots of explanations on how to use the IO monad
14:31:26 <hancock> me a bit
14:31:42 <megajosh2> hancock: What's the code?
14:31:57 <tommd> hancock: Use the enter key less and hpaste.org more
14:31:59 <megajosh2> hancock: Go ahead and put it on hpaste.com or some other pastebin
14:32:07 <tommd> err, yeah, hpaste.com
14:32:08 <megajosh2> Oh it's .org?
14:32:11 <megajosh2> <_<
14:32:12 <megajosh2> >_>
14:32:26 <megajosh2> Nope it's .org
14:32:26 <tommd> lol, weeee.... confusing everyone.
14:32:28 <hancock> it asks me for a pass :|
14:32:32 <hancock> user/pass
14:32:35 <hancock> i don't have that
14:32:35 <tommd> Yeah, hancock, use hpaste.org
14:32:38 <tommd> @where paste
14:32:38 <lambdabot> http://hpaste.org/ http://codepad.org/
14:32:39 <tommd> that
14:32:45 <wakeupsticky> explanations of how to use it as an integral part of other functions?
14:32:54 <PirateUnderwear> hmm
14:33:04 <conal> maybe wakeupsticky doesn't understand the essential denotative aspect of functional programming, which would then prevent him from understanding or appreciating possibilities for how randomness could fit in.
14:33:24 <wakeupsticky> maybe
14:33:27 <tommd> wakeupsticky: You probably want MonadRandom
14:33:39 <hancock> ok
14:33:41 <hancock> so this is it:
14:33:42 <hancock> http://hpaste.org/40070/haskell_code
14:34:05 <hancock> it's a small virtual machine that executes ASM code
14:34:18 <hancock> however, I'm having trouble with matching types
14:34:26 <hancock> I've spent like hours trying to figure it out
14:34:50 <monochrom> http://www.haskell.org/haskellwiki/Random_list , http://www.haskell.org/haskellwiki/Random_shuffle , http://www.haskell.org/haskellwiki/Guess_a_random_number , http://www.haskell.org/haskellwiki/Examples/Random_list , http://www.vex.net/~trebla/haskell/random.xhtml
14:35:13 <tommd> hancock: A number of errors
14:35:19 <tommd> Take "haltWithError"
14:35:21 <hancock> yup :(
14:35:44 <tommd> So you say it is of type "MSM a" then you try and return a Maybe type.  What do you actually want?
14:35:52 <wakeupsticky> i will review monads and try to figure it out
14:36:03 <wakeupsticky> i'll come back if i still don't get it :"|
14:36:06 <tommd> hancock: haltWithError :: MSM (Maybe a) ?
14:37:14 <hancock> Well, I want to make the VM stop running. 
14:37:35 <hancock> In order to have that I need a function
14:37:59 <hancock> I know from the Maybe monad that Nothing can do that
14:38:07 <hancock> However I'm not sure how to integrate that ....
14:38:47 <hancock> tommd: So you recommend that I change the signature of the function?
14:41:51 <tommd> If MSM is a state monad why are you passing it like an argument?
14:42:37 <hancock> That's another problem. I don't know how to extract the actual state from it.
14:45:47 <hancock> The thing is I have 5 years of experience with imperative programming but this is something totally different. I barely understand monads although I read a lot of tutorials about them. 
14:46:15 <mauke> why are you trying to understand monads?
14:46:28 <hancock> I stopped trying :))
14:46:32 <mauke> seems pointless to me
14:46:46 <hancock> I just want to be able to use them
14:46:49 <medfly> stop being intentionally anal
14:46:54 <medfly> :p
14:47:05 <mauke> you can't use "them"
14:47:18 <mauke> you can use a specific type that happens to be a monad, maybe
14:47:36 <Twey> Sure you can
14:47:39 <alej> understanding of monads will just happen with time. and then you'll go "oh" and be unimpressed
14:47:41 <Twey> @src sequence
14:47:41 <lambdabot> sequence []     = return []
14:47:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:47:41 <lambdabot> --OR
14:47:41 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:47:47 <Twey> Look, using monads!  :þ
14:48:14 <geheimdienst> if code compiles, fine. if not, mash in a return or fmap. repeat until compiles.
14:48:22 <geheimdienst> done! monads are now understood
14:48:23 <Twey> >.<
14:49:00 <ddarius> geheimdienst: That doesn't work.
14:49:02 <medfly> that's what I often do.
14:49:09 <hancock> yeah ....
14:49:11 <hancock> very helpful
14:49:38 <tommd> hancock: Sorry, I really should go but here are two examples.
14:49:39 <tommd> http://hpaste.org/paste/40070/consider_this#p40071
14:49:44 <geheimdienst> ddarius: that's not what these generations of xmonad users said
14:49:45 <geheimdienst> ;)
14:50:08 <monochrom> what is "understanding"?
14:50:29 <tommd> hancock:  HaltWithError isn't returning anything - its halting, so it shouldn't be "MSM a".    Since isn't "returning" anything, so don't use 'return'.
14:50:33 <Jafet> The opposite of overstanding
14:50:36 <tommd> hancock: See how checkPC uses monads?
14:50:45 <medfly> I am under the impression that monads are like vector spaces, in that that you had a thing like the real numbers before but thinking of them as a vector space gives you a whole bunch of stuff like maybe you can try to make an inner product which will have triangle inequality etc. which exists for other things. y/n?
14:50:49 <tommd> hancock: The MSM monad handles the "plumbing" of threading the state
14:51:06 <ddarius> medfly: That was rather incoherent.
14:51:10 <tommd> Each function _can_ get the state, perform some operation, even change the state (using set) and then return a value.
14:51:12 <monochrom> anyway, on the mailing list haskell-cafe there is someone with "12 years of experience" in imperative programming and he/she is even more lost.
14:51:18 <monochrom> @quote monochrom unlearning
14:51:18 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
14:51:39 <tommd> hancock: also note "haltWithError" is usually just the "fail" routine of the Monad instance, which you didn't define.
14:51:47 <mauke> medfly: sort of
14:52:02 <monochrom> @quote is.like
14:52:02 <lambdabot> <BONUS> says: C++ is saner than something? imo C++ is like the guy that goes around shouting "I am napoleon!!!"
14:52:13 <medfly> a monad is a thing that satisfies a bunch of axioms like vector spaces and those axioms result in theorems you may find useful or extensions (like inner products) that could be really neat
14:52:15 <mauke> preflex: quote PoppaVic
14:52:15 <preflex>  <PoppaVic> does your C code care if you are Arab? ;-)
14:52:18 <Jafet> @quote monads.are
14:52:18 <lambdabot> copumpkin says: monads are like monad tutorials
14:52:33 <povman> lol
14:52:34 <medfly> lol
14:52:42 <tommd> hancock: And the "get" call followed by the "let" binding is usually rolled into one function called "gets" that many other functions use.  gets field = do { s <- get ; return (field s) }
14:53:08 <povman> I'm writing a programming game in haskell that is meant to run haskell
14:53:21 <medfly> I don't see how category theory is like a thing slightly above mathematics. I hear it groups together things that are from different fields in mathematics, or something?
14:53:24 <monochrom> what is a programming game?
14:53:27 <nullkuhl> does log base 10 call exist in haskell ?
14:53:30 <medfly> or something. 
14:53:37 <roconnor> > logBase 10 20
14:53:38 <lambdabot>   1.301029995663981
14:53:43 <povman> monochrom: A game where you have to implement an AI to compete against other AIs
14:53:46 <medfly> nullkuhl, log base a (b) / log base a (c) = log base c (b)
14:53:52 <monochrom> oh god, another one
14:53:55 <medfly> @src logBase
14:53:55 <lambdabot> Source not found.
14:54:22 <monochrom> none of those competitions end up involving AI so far
14:54:26 <nullkuhl> > mod 10 2
14:54:27 <lambdabot>   0
14:54:30 <geheimdienst> > 10 ^(logBase 10 20)
14:54:31 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:54:31 <lambdabot>    `GHC.Float.Floating t'
14:54:31 <lambdabot>  ...
14:54:36 <povman> monochrom: I'm designing this game
14:54:38 <ddarius> medfly: Category theory is a part of mathematics.  Who's said otherwise?
14:54:42 <nullkuhl> > mod 9 2
14:54:43 <lambdabot>   1
14:54:47 <geheimdienst> > 10 ^^(logBase 10 20)
14:54:48 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:54:48 <lambdabot>    `GHC.Float.Floating t'
14:54:48 <lambdabot>  ...
14:54:53 <medfly> ddarius, no one
14:54:53 * geheimdienst no likes
14:55:22 <medfly> ddarius, I could learn more about it now that I'm less clueless about mathematics.
14:55:23 <monochrom> you probably should try ** . I don't know who is ^^ .
14:55:41 <medfly> > 10 ** (logBase 10 20)
14:55:42 <lambdabot>   19.999999999999993
14:55:43 <geheimdienst> > 10 ** (logBase 10 20)
14:55:44 <lambdabot>   19.999999999999993
14:55:46 <geheimdienst> thanks man
14:55:56 <HugoDaniel2> why isn't it possible to have an if without an else in haskell ?
14:56:13 <megajosh2> @src (**)
14:56:13 <lambdabot> Source not found. I am sorry.
14:56:28 <medfly> use Maybe.
14:56:30 <ddarius> HugoDaniel: What would print (if False then 3) print?
14:56:31 <monochrom> it is possible but not done
14:56:34 <megajosh2> @src (->) (**)
14:56:34 <povman> Are GHC breakpoints deterministic?
14:56:34 <lambdabot> Source not found.
14:56:38 <FunctorSalad> HugoDaniel2: because it's an expression, like : ? in c-like langs
14:56:52 <geheimdienst> > let x = (if even 42 then "lol" else "cat") in x
14:56:53 <lambdabot>   "lol"
14:56:58 <FunctorSalad> HugoDaniel2: the analogue to a *statement* if-without-else is 'when', kinda
14:57:07 <monochrom> you could decree "if b then x" means "if b then x else undefined". but it's pretty useless I think. but maybe you want to use it.
14:57:07 <HugoDaniel2> ah
14:57:09 <HugoDaniel2> nice
14:57:10 <HugoDaniel2> :)
14:57:21 <FunctorSalad> arghl. I meant ? :
14:57:23 <nullkuhl> > print "4."
14:57:24 <lambdabot>   <IO ()>
14:57:24 <geheimdienst> HugoDaniel2, if i left out the "else" part, there would be no value to assign to x ...
14:57:29 <nomemory> hello, given this code: http://hpaste.org/40072/romannumerals , is it possible to somehow eliminate the need of the two functions : generatorRomOrd and generatorRomRaw ? Is possible to imitate the idea of default values for functions just like in imperative programming ? Something like : def function(a="DefaultValue", b="DefaultValue"): 
14:57:50 <nomemory> *default values for functions input params
14:57:57 <nullkuhl> how to print "4." without quotations and without new line ?
14:57:58 <FunctorSalad> > runState (when False (modify (+1)) 7
14:57:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:58:05 <FunctorSalad> > runState (when False (modify (+1))) 7
14:58:06 <lambdabot>   ((),7)
14:58:12 <megajosh2> nullkuhl: put
14:58:14 <megajosh2> ...
14:58:14 <FunctorSalad> > runState (when True (modify (+1))) 7 -- @ HugoDaniel2 
14:58:15 <lambdabot>   ((),8)
14:58:17 <monochrom> putStr "4."
14:58:20 <megajosh2> nullkuhl: putStr "4"
14:58:20 <megajosh2> Yeah
14:59:08 <HugoDaniel2> ah
14:59:09 <HugoDaniel2> when is nice
15:00:03 <roconnor> nomemory: that idiom is pretty common. I would keep generatorRomOrd and generatorRomRaw
15:00:21 <roconnor> nomemory: the only resonable alternative is to put generatorRomOrd as part of a where clause for generatorRomRaw
15:00:44 <nomemory> roconnor, so having two functions like that is a "normal" practice ?
15:00:49 <roconnor> yes
15:00:52 <povman> Ooh, is it possible to implement a monad that 'knows' when it is recursing?
15:01:38 <nomemory> thanks roconnor 
15:02:36 <monochrom> probably not.
15:02:46 <conal> maybe MonadFix instead
15:03:38 <povman> ah, perfect - thanks conal
15:03:43 <conal> :)
15:03:46 <geheimdienst> omg hpaste has hlint! how cool is that!
15:04:16 <monochrom> in fact yesterday hlint itself answered a newbie question
15:04:18 <pielgrzym> funny thing. once again I was trying to grok haskell by some experimenting :] so I tried to do a fibonacci like this in ghci: let fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]. fibs !! 3 wow, works. fibs !! 300. whooa, fast! Try this now: fibs !! 3000. blonk, whoa, fast for intel atom! fibs !! 30000 - hah, a HUGE number! fibs !! 300000 - boing. all leds blinking, sound loop. we've got a softlock :D
15:04:27 <pielgrzym> doesn't it mean there is a bug in ghci?
15:05:21 <monochrom> I forgot the details. But it when like this. newbie shows paste and asked a question. but the answer was already in the hlint section, "you should do ___".
15:05:47 <monochrom> s/when/went/
15:06:16 <geheimdienst> monochrom: that's what i'd expect. very cool. and i don't think it's limited to newbie questions
15:07:34 <monochrom> A real AI contest would be about answering newbie questions robotically. Not those "race around the circle and shoot down other robots".
15:08:08 <geheimdienst> monochrom: it's already in progress. it's called #haskell. didn't you notice about 2/3 of us are bots?
15:08:13 <monochrom> You need 0 AI for racing around and shooting others.
15:08:24 <monochrom> I didn't notice.
15:09:10 <nullkuhl> i cant load module due to errors, could any one take a look over http://hpaste.org/40074/calculating_pi
15:09:11 * benmachine through inaction allows monochrom to come to harm
15:09:50 <Jafet> http://last.fm/robots.txt
15:10:49 <monochrom> hahaha neato
15:11:54 * geheimdienst has enough trouble getting his Natural Intelligence brain into a state that it can reliably answer newbie questions. geheimdienst shudders at the challenge of making an Artificial Intelligence for that.
15:12:08 <nullkuhl> can anyone help me ?
15:12:46 <Saizan> nullkuhl: you need parens around finalize
15:13:02 <Saizan> otherwise you're applying print to 2 arguments
15:13:04 <geheimdienst> nullkuhl: try putting a $ between print and finalize
15:13:16 <monochrom> you may do both, too.
15:13:23 <Saizan> print (finalize (machin_pi 300))
15:13:23 <geheimdienst> ... or enclosing it in parens
15:13:42 <monochrom> print $ (finalize $ (machin_pi $ (300)))
15:14:07 <nullkuhl> now i get  Ambiguous type variable `a' in the constraints:`Floating a' arising from a use of `finalize'
15:14:07 <monochrom> in fact, (print $ (finalize $ (machin_pi $ (300))))  now it's kind of schemy, too!
15:14:18 <nullkuhl> `Integral a'arising from a use of `machin_pi'
15:15:08 <Jafet> nullkuhl: let kick = fromIntegral in
15:15:09 <Saizan> ?quote fromIntegral
15:15:09 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
15:15:10 <Entroacceptor> but hlint warns if you use redundant $...
15:15:37 <nullkuhl> Jafet: huh ?
15:15:45 <nullkuhl> where should i write that
15:16:19 <Saizan> nullkuhl: since machin_pi is written to return a type that's an instance of Integral but finalize wants one that's an instance of Floating, an easy way is to add fromIntegral to convert
15:16:31 <jnj> I'm using runSTUArray to build an array. Is there a version of this function that supports errors in the form of Maybe or Either? runSTUArray requires an array returned, even if constructing the array fails for some reason
15:16:54 <Saizan> nullkuhl: print (finalize (fromIntegral (machin_pi 300)))
15:17:27 <nullkuhl> Saizan: same problem
15:17:37 <nullkuhl> i think its because logBase 10 x returns a float
15:17:59 <nullkuhl> how can i cast it into an integer ? fromIntegral ?
15:18:05 <povman> monochrom: our game is more similar to corewars
15:18:15 <povman> but i must leave :(
15:18:18 <Saizan> no, but also i think (**) is causing problems
15:18:20 <Saizan> ?type (**)
15:18:21 <lambdabot> forall a. (Floating a) => a -> a -> a
15:18:37 <nullkuhl> ?type(^^)
15:18:37 <lambdabot> Unknown command, try @list
15:18:40 <Saizan> it wants two Floatings, but you're using mod in the first argument
15:18:46 <nullkuhl> hmm
15:19:02 <nullkuhl> so i convert first to float ?
15:19:51 <megajosh2> > 2 ** 5
15:19:52 <lambdabot>   32.0
15:19:57 <megajosh2> > 2 ^ 5
15:19:58 <lambdabot>   32
15:20:00 <megajosh2> Oh
15:20:05 <megajosh2> > 2 ^^ 5
15:20:06 <lambdabot>   32.0
15:20:27 <Saizan> nullkuhl: this compiles http://hpaste.org/paste/40074/#p40077
15:21:13 <nullkuhl> woo, give wrong answer though
15:21:27 <Saizan> nullkuhl: to convert from a Floating type to an Integral one you can use round/truncate/floor/ceiling, depending on how you want the rounding to behave
15:21:32 <nullkuhl> am trying to remove the 1st digit in the output of machin_pi
15:21:46 <nullkuhl> so i mod it by 10 and multiply it but it's logbase10 
15:21:53 <nullkuhl> by*
15:23:46 <nullkuhl> Saizan: isnt that mathimatically correct ? if there is an easier method in haskell please advise though
15:24:25 <nomemory> hi. I am using Ubuntu, I've installed cabal from the repo. I want to install hlint. The error i receive is: ExitFailure 1
15:24:25 <nomemory> hlint-1.8 depends on haskell-src-exts-1.9.3 which failed to install.
15:24:31 <nomemory> any suggestions ?
15:26:07 <Saizan> nullkuhl: it doesn't make much sense to me, by "removing the first digit" you mean going from e.g. 12345 to 2345?
15:27:10 <nullkuhl> yes
15:27:12 <c_wraith> > read . drop 1 . show $ 573 :: Int
15:27:13 <lambdabot>   73
15:27:31 <monochrom> read and show solves all numerology problems
15:27:35 <c_wraith> yes.
15:27:39 <c_wraith> forget math.
15:27:46 <c_wraith> solve the problem as a list problem!
15:28:43 <nullkuhl> print (read . drop 1 . show $  (machin_pi 300) :: Int)
15:28:47 <nullkuhl> that doesnt work 
15:29:21 <c_wraith> the name "machin_pi" makes it sound like it's not an int
15:29:34 <c_wraith> So...  attempting to read it as an Int is probably going to fail
15:29:50 <nullkuhl> machin_pi will return a number of about 300000 digit
15:30:03 <kyagrd> nomemory: if ur machine is fast enough recommend src installing from Hackage directly using cabal
15:30:03 <c_wraith> Oh.  well, then Int is definitely wrong
15:30:07 <c_wraith> You'd want Integer, at least
15:30:27 <Jafet> > read . drop 3 . show $ 1e7 :: Double
15:30:29 <lambdabot>   *Exception: Prelude.read: no parse
15:30:32 <nomemory> kyagrd, Ubuntu seems to have hlint in his own repository
15:30:34 <nullkuhl> i was going for a math solution , because i though that reading such a number would be too slow
15:30:36 <nomemory> I've installed that version
15:30:39 <nullkuhl> c_wraith: ^^
15:31:14 <nullkuhl> c_wraith: btw , is there is a larger type than Integer ?
15:31:26 <monochrom> there is much fun in debating what counts as math solutions
15:31:28 <c_wraith> No.  Integer is unbounded, for practical purposes
15:31:38 <kyagrd> nomemory: using distro binary version of Haskell package usually didn't trun out very comfortable if you are developing in Haskell
15:31:49 <monochrom> Ratio Integer is "larger" than Integer :)
15:32:15 <kyagrd> I'm using Debian (I believe ubuntu repackages the debian package)
15:32:33 <monochrom> if someone provides an "Ordinal a" type, Ratio (Ordinal Integer) may be yet larger :)
15:32:39 <nullkuhl> ok c_wraith anything other than reading the whole number can solve my problem ?
15:32:52 <nullkuhl> because it takes abit of a long time in that operation on its own
15:33:01 <c_wraith> nullkuhl, is the number an integer?
15:33:10 <Jafet> CReal!
15:33:19 <kyagrd> I only install binary Deiban haskell packages for gtk kind of stuff which isn't on Hackage or hard to configure myself
15:33:21 <Jafet> > showCReal 100 $ pi
15:33:22 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
15:33:41 <nullkuhl> c_wraith: yes
15:33:42 <nomemory> kyagrd, you suggest compile from source ?
15:33:50 <nomemory> *ing
15:34:02 <nullkuhl> Jafet: how many digits does CReal has of pi
15:34:16 <c_wraith> nullkuhl, CReal is unbounded.
15:34:18 <kyagrd> nomemory: yes that's usually a clean solution in debain based systems from my experience
15:34:30 <monochrom> what is the question anyway? is it "what is the most significant digit in the 300000-digit decimal expansion of pi?"?
15:34:36 <c_wraith> CReal is just *really* slow
15:34:41 <nullkuhl> hmm
15:35:00 <nullkuhl> c_wraith: ok dont you think that the math approach would be faster ? 
15:35:18 <nomemory> kyagrd , I will keep that in mind. Thanks!
15:36:02 <c_wraith> nullkuhl, Depends on having an appropriately precise value to use with log
15:36:03 <jnj> any ideas on http://hpaste.org/40078/getting_error_out_of_stuarray ? I'm new at this monad stuff ;)
15:36:08 <c_wraith> :t logAtBase
15:36:09 <lambdabot> Not in scope: `logAtBase'
15:36:52 <nullkuhl> :t logBase
15:36:53 <lambdabot> forall a. (Floating a) => a -> a -> a
15:38:10 * hackagebot kit 0.4.2 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.4.2 (NickPartridge)
15:38:34 <kyagrd> monochrom: there is one ordianal package on hackage, not sure if that's what you want though
15:38:51 <kyagrd> @hackage Ordinal
15:38:51 <lambdabot> http://hackage.haskell.org/package/Ordinal
15:38:53 <monochrom> it will do!
15:39:02 <nullkuhl> c_wraith: so ?
15:39:04 <kyagrd> @hackage Ordinals
15:39:04 <lambdabot> http://hackage.haskell.org/package/Ordinals
15:39:19 <monochrom> recall that @hackage is id
15:39:38 <monochrom> @hackage RemotelyImpossible-HaltingProblemSolver
15:39:38 <lambdabot> http://hackage.haskell.org/package/RemotelyImpossible-HaltingProblemSolver
15:40:07 <monochrom> but don't worry :)
15:40:19 <c_wraith> nullkuhl, Double isn't good enough for that purpose. You're probably better off just doing read/show stuff.
15:40:35 <monochrom> Double is not math anyway
15:42:16 <zachk> everything eventually halts 
15:45:33 <nullkuhl> print ((machin_pi 55000)/(10**55000))
15:45:38 <nullkuhl> would this work ?
15:45:52 <nullkuhl> apparently not, it didnt compile
15:46:41 <monochrom> > 10 ** logBase 10 20
15:46:42 <lambdabot>   19.999999999999993
15:46:44 <monochrom> http://img.thedailywtf.com/images/200902/errord/DSC00669.JPG
15:47:13 <benmachine> oh dear
15:47:21 <monochrom> hehe
15:48:02 <monochrom> Kerala Lambda Curry: 8.28999
15:48:03 <Jafet> Revenge of the .99s
15:49:25 <i-blis> monochrom, thanks for the daily wtf
15:49:56 <nullkuhl> how to write machin_pi 55000 / 10^55000 ?
15:50:27 <Saizan> with div?
15:50:37 <Saizan> ?type (^)
15:50:37 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:50:45 <Saizan> yeah, div works
15:51:57 <nullkuhl> div 4 2
15:52:02 <monochrom> 2
15:52:07 <nullkuhl> lol k
15:52:28 <Jafet> Then if you're lucky you get 3
15:52:44 <Jafet> I suppose mod would be more useful.
15:53:26 <Saizan> > 123456 `div` 1000
15:53:27 <lambdabot>   123
15:53:31 <Saizan> > 123456 `mod` 1000
15:53:32 <lambdabot>   456
15:53:40 <nullkuhl> this doesnt work
15:53:42 <nullkuhl> print (div (machin_pi 55000 10^55000))
15:53:54 <monochrom> wrong parentheses
15:53:58 <Saizan> it's div that takes 2 arguments
15:54:05 <nullkuhl> am trying to div 12345 by 100 to get 12.345
15:54:22 <monochrom> play with print (div (4) (2)) first
15:55:19 <Saizan> nullkuhl: div will give 12, if you want 12.345 you need (/) but also fromIntegral on (machin_pi 55000)
15:55:29 <Saizan> anyhow, it's all in the types
15:55:39 <Jafet> You also need CReal for 55000 digits, and it's a crapshoot from there on
15:55:54 <Jafet> > 10^55000 :: CReal
15:55:56 <dmwit> > sqrt 19
15:55:57 <lambdabot>   4.358898943540674
15:55:58 <lambdabot>   mueval-core: Time limit exceeded
15:56:07 <Jafet> > 10^55000
15:56:08 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
15:56:33 <revenantphx> > 10 ^ 55001
15:56:34 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
15:56:49 <zachk> gg gmp ftw 
15:57:03 <nullkuhl>  print ( fromIntegral(machin_pi 55000)/(10^^10)) this gets me infinity
15:57:33 <Jafet> > 10**55000 :: Double
15:57:34 <lambdabot>   Infinity
15:58:44 <nullkuhl> this is my code
15:58:46 <nullkuhl> http://hpaste.org/40081/pi_calc
15:58:48 <nullkuhl> and it doesnt work :(
15:59:07 <Jafet> Just like me
15:59:56 <benmachine> nullkuhl: elaborate
16:00:20 <Jafet> Did you mean: /arctan/
16:00:27 <nullkuhl> the last line has an issue, am trying to divide the output of machin_pi by 10**10
16:00:38 <nullkuhl> Jafet: no no machin_pi works fine
16:00:40 <benmachine> ah
16:00:43 <benmachine> use 10^10 instead
16:00:49 <benmachine> wait no
16:00:58 <nullkuhl> tried ^^, ^, and **
16:01:09 <benmachine> what's the error?
16:01:17 <nullkuhl> it prints infinity
16:01:19 <nullkuhl> if you make it correctly , it should print you pi
16:01:21 <Jafet> nullkuhl: your continual failure to understand types is impeding your progress
16:02:04 <benmachine> Jafet: that's a bit accusatory >_>
16:02:14 <benmachine> and unhelpful
16:02:20 <Jafet> Well, he's been at this for hours now
16:02:29 <hpc> :t (^^)
16:02:30 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
16:02:33 <benmachine> if you're bored helping just stop?
16:02:34 <hpc> :t (^)
16:02:36 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:02:38 <hpc> :t (**)
16:02:39 <lambdabot> forall a. (Floating a) => a -> a -> a
16:05:27 <Lemmih> nullkuhl: Sure you want to use '/' and not 'div'?
16:05:42 <Jafet> Wait, what's wrong with the line you commented out?
16:05:47 <Jafet> It works perfectly fine.
16:06:13 <nullkuhl> Jafet: slower
16:06:32 <nullkuhl> Lemmih: am trying to do 12345/1000 to get 12.345
16:06:33 <Jafet> Slower than what? (What *are* you trying to do?)
16:07:12 <nullkuhl> i mean reading the whole number which is about 55000 digits, is very slow
16:07:13 <Lemmih> nullkuhl: Aren't you trying to print out the digits of pi?
16:07:17 <nullkuhl> am trying to do it the math way
16:07:21 <nullkuhl> Lemmih: yes
16:07:22 <Jafet> A division like that is not, by any reasonable expectation, going to be faster than putStr . drop 1 . show $ blah
16:08:02 <Jafet> There are several type conversions there; look through it carefully and figure out which you don't need.
16:08:28 <Jafet> And anyway, there isn't a builtin type that gives you 55000 decimal digit floating point
16:08:36 <Lemmih> nullkuhl: 'drop 1' is essentially cost free.
16:08:49 <nullkuhl> Jafet: its not floating point
16:09:16 <nullkuhl> i have py till 55000 however its written like 314...etc am trying to divide it by the number of digits to get 3.14... instead
16:09:39 <Jafet> <nullkuhl> am trying to do 12345/1000 to get 12.345 -- however way you do that, it is strictly and totally redundant
16:10:12 <nullkuhl> Jafet: and your suggestion is that i should.. ?
16:10:50 <Jafet> Your commented-out code works. If you noticed the definition of print, you could then remove the redundancy
16:10:54 <Jafet> @src print
16:10:55 <lambdabot> print x = putStrLn (show x)
16:16:09 <medfly> weird that that's not pointless :)
16:16:26 <nullkuhl> medfly: ?
16:16:46 <aavogt> monomorphism restriction
16:16:58 <benmachine> nah
16:17:07 <benmachine> it'll have an explicit type signature
16:17:16 <aavogt> that's redundancy
16:17:23 <benmachine> redundancy is good sometimes
16:17:35 <aavogt> do you really think that?
16:17:39 <benmachine> yes
16:17:51 <aavogt> seems inconsistent
16:17:55 <benmachine> if information is provided in multiple ways, introducing a mistake will cause an error
16:18:02 <benmachine> rather than just changing behaviour
16:18:11 <benmachine> I said sometimes, mind
16:18:41 <benmachine> also, sometimes information should be provided explicitly when it's already implicit, for the sake of easy understanding
16:24:49 <tommd> hancock: How goes?
16:25:23 <hancock> I fixed most of the errors
16:25:27 <tommd> Great!
16:25:27 <hancock> it compiled :D
16:25:32 <hancock> but it gets stuck
16:25:37 <hancock> i think i know what the issue is
16:25:37 <tommd> Ok
16:25:48 <tommd> That's good - feel free to ignore me and don't lose that thought.
16:26:02 <hancock> k
16:33:53 <roconnor> > fromRational (12345/1000)
16:33:53 <lambdabot>   12.345
16:34:11 <hancock> tommd: u still there?
16:34:19 <tommd> hancock: Yep
16:38:35 <monochrom> you cannot avoid types. dynamically typed languages just postpone failures to runtime.
16:39:32 <benmachine> preaching to the converted? :P
16:39:36 <Adamant> what is that supposed to mean, anyway?'
16:40:07 <Adamant> clearly you can avoid types, or C and PHP would not exist
16:40:08 <monochrom> there are some unconverted frustrated newbies here
16:40:40 <FauxFaux> monochrom: Theoretically you can provide implicit coercions between any type and any other type.
16:40:50 <Adamant> also you don't necessarily care if the failure is postponed to runtime.
16:41:22 <FauxFaux> (Or, at least, ensure that every operator is defined for every set of inputs.)
16:42:31 <djahandarie> Of course types exist in dynamically-typed languages... that's why they are called *typed* languages
16:43:48 <ajnsit> What is the status of Pivotal? Is it actively maintained anymore?
16:44:03 <moosefish>  Pivotal?
16:44:08 <djahandarie> ajnsit, did you get my earlier message?
16:44:31 <ajnsit> djahandarie, no sorry I had logged off
16:44:35 <kmc> djahandarie, but people often get that wrong
16:44:41 <ajnsit> moosefish, http://www.cs.kent.ac.uk/projects/pivotal/
16:44:59 <djahandarie> ajnsit, it is probably dead, and you should e-mail Keith Hanna or Stefan Kahrs
16:45:09 <djahandarie> They would be the only two with any idea of the status of that project
16:45:26 <ajnsit> okay thanks
16:45:28 <djahandarie> AFAIK they are both still part of the group at Kent which made that
17:06:10 * hackagebot SVGPath 1.0 - Parsing the path command from SVG  http://hackage.haskell.org/package/SVGPath-1.0 (TillmannVogt)
17:06:31 <kmc> hehe SVG
17:06:37 <kmc> XML is great let's use it for everything!
17:06:44 <vanadium> Aw, svg is fun
17:06:45 <kmc> but actually it's too verbose so let's make another language for the core of our format
17:07:13 <vanadium> You can embed javascript and make the svg do thigns!
17:07:15 <vanadium> things!
17:08:58 <kmc> anything like Attoparsec that works with Text instead of ByteString?
17:10:54 <Pseudonym> kmc, what is really unfortunate is that you have to ask that question.
17:11:32 <kmc> yes
17:11:37 <kmc> maybe?
17:12:15 <benmachine> parsec would work with Text, but that's only vaguely like attoparsec I suppose
17:13:13 <kmc> can a non-newline character UTF8-encode to a byte sequence with a newline byte in it?
17:13:55 <vanadium> no
17:14:18 <vanadium> Newline character starts with a 0 bit. No multibyte UTF8 character has a byte starting with a 0 bit in it.
17:14:59 <kmc> good
17:15:06 <kmc> i remember that UTF8 has these nice properties
17:15:28 <Pseudonym> It was specifically designed to do this so that C could handle it.
17:15:37 <sm> rah parsec!
17:15:38 <kmc> so i think i can get away with parsing as bytes, then utf8-decoding one of the parsed fields
17:15:39 <c_wraith> heh.  silly C
17:15:40 <vanadium> http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt is a fun read
17:15:47 <Pseudonym> No UTF-8 sequence has a zero byte in it unless it's code point zero.
17:21:00 <monochrom> the best napkins were used in the design of utf-8
17:21:29 <Pseudonym> They were very good napkins, yes.
17:23:00 <kmc> hmm
17:23:04 <kmc> are http://tunes.org/~nef/logs/haskell/ stored in UTF-8?
17:23:14 <kmc> or are they whatever bytes people's possibly misconfigured clients wanted to send?
17:23:18 <kmc> seems like probably the latter :/
17:23:33 <Jafet> IRC doesn't know utf-8
17:23:42 <Jafet> It's also more accurate to do the latter, anyway
17:23:53 <kmc> yeah, it's just, like, a community consensus to set our clients to UTF-8 right?
17:24:00 <monochrom> yes
17:24:02 <Jafet> And some clients don't cut off multibyte sequences properly
17:24:08 * kmc remembered he used to send Latin-1, got yelled at for it
17:24:09 <vanadium> There is still channels where they kick you if you send multibyte umlauts or anything
17:24:51 <JoeyA> Are those non-UTF-8?
17:25:04 <vanadium> No, I meant utf-8
17:25:08 <JoeyA> oh
17:25:10 <vanadium> There are weirdo conservatives who stick to latin1
17:25:25 <monochrom> some russian channels actually want you to use KOI or something and not utf-8
17:25:38 <monochrom> similarly swedish channels etc
17:25:38 <kmc> ISO/IEC 8859-1 was good enough for Jesus and it's good enough for me
17:25:41 <pikhq> vanadium: It's more annoying with Japanese channels.
17:25:52 <pikhq> Shift-JIS is still used commonly. Which must die.
17:25:59 <vanadium> Heh
17:26:06 <Jafet> Let's hope it's because they want to type more on one line.
17:26:10 <JoeyA> I prefer the policy of kickbanning when people post invalid UTF-8 (of course, they can appeal with private messages).
17:26:15 <vanadium> I do not understand japanese, so I guess it is not much of an issue for me anyway :v
17:26:18 <JoeyA> That way, more and more people fix their clients.
17:26:27 <pikhq> Shift-JIS is the worst encoding ever.
17:26:29 <dankna> Shift-JIS is an abomination.
17:26:45 <monochrom> IMO there is some vain patriotic arrogance in those cases.
17:27:00 <medfly> kmc, no it wasn't. jesus was a jew.
17:27:01 <dankna> There shouldn't be - EUC-JP is the encoding created by the Japanese government.
17:27:07 <vanadium> I guess it is convenient that UTF-8 is identical to ascii w.r.t. getting Americans to adopt it
17:27:10 <medfly> kmc, iso-8859-8 it is.
17:27:18 <dankna> For that matter Emacs's MULE encoding was also designed with Japanese government funds, at least in part.
17:27:33 <pikhq> dankna: As is raw JIS.
17:27:43 <dankna> Yeah, that too.
17:27:57 <vanadium> Man, I worded that badly.
17:28:14 <pikhq> Shift-JIS is the Microsoft solution to encoding, to allow compatibility with the old DOS encoding.
17:28:30 <vanadium> ... that the encoding of the first 127 characters is identical between ascii and utf-8...
17:28:31 <pikhq> (which was ASCII plus half-width katakana)
17:28:53 <dankna> vanadium: fortunately, as we all know the technical facts you were trying to reference, we understood you :)
17:28:58 <Pseudonym> Yes, shift-JIS is crap because JIS X 0201 is crap.
17:29:13 <pikhq> Pseudonym: Except it makes it worse.
17:29:17 * Pseudonym therefore would be careful in blaming Shift-JIS
17:29:25 <vanadium> dankna: I just feel bad for saying something evidently inaccurate :)
17:29:32 <pikhq> But, yeah, JIS is stunningly bad.
17:29:40 <pikhq> Well. JIS 0201.
17:29:46 <Pseudonym> pikhq: YOu wouldn't agree that JIS + multi-byte + backwards-compatibility = Shift-JIS?
17:30:13 <dankna> Hm?  I have no grudge against JIS, but I guess there could be complaints about it on the grounds of the actual character set?  Shift-JIS is crap because it's a variable-byte-length encoding which lacks the useful properties of UTF-8, such as being able to resynchronize easily.
17:30:16 <Pseudonym> i.e. it's inevitably bad given the complaints?
17:30:18 <pikhq> Pseudonym: That is precisely what Shift-JIS is.
17:30:29 <Pseudonym> It's no worse than it had to be, surely.
17:30:42 <pikhq> Pseudonym: Well, no, but it had to be damned bad.
17:30:58 <pikhq> dankna: This is also inherent in the JIS encoding.
17:31:20 <monochrom> Does Shift-JIS do all the characters Unicode does? Most?
17:31:23 <dankna> you mean because of how it uses the high bit for its own purposes?
17:31:40 <dankna> no, it does only the characters in the JIS charset
17:31:49 <dankna> which does include Latin and accented Latin
17:31:59 <monochrom> but it has no greek
17:32:08 <dankna> if memory serves that is correct
17:32:19 <pikhq> monochrom: Shift-JIS does a subset of Unicode that is defined in the JIS charset standards, using a transformation of the JIS encoding to be backwards compatible with a DOS encoding of Japanese.
17:32:21 <dankna> it also has no Elvish
17:32:23 <monochrom> see, that's the problem with all these national-narrow scheme.
17:32:56 <pikhq> (the modern-day JIS charset is defined specifically *as* a subset of the Unicode character set)
17:32:58 <dankna> yeah - the Japanese charset is slightly better than other national-narrow schemes inasmuch as they tried to include a couple small charsets in it, but.
17:33:07 <dankna> it's still national-narrow.
17:33:57 <pikhq> monochrom: The only national-narrow scheme I can support is GB18030 (used in China).
17:34:11 <pikhq> monochrom: Because it's a Unicode transformation format.
17:34:23 <monochrom> yes, gb18030 is ok. in bijection with unicode. probably will track future unicode additions too
17:35:45 <pikhq> I'd *prefer* if they used UTF-8, but hey. It's Unicode; I can accept Unicode.
17:36:07 <roconnor> ?
17:36:07 <dankna> ah - that sounds decent
17:36:15 <roconnor> Unicode and UTF-8 are not even the same type
17:36:25 <roconnor> one is a character set and the other is a character encoding
17:36:38 <pikhq> roconnor: UTF-8 is a character encoding *of* Unicode.
17:36:44 <Jafet> Codepoint set
17:36:44 <pikhq> roconnor: Just like GB18030.
17:36:47 <roconnor> ah
17:36:51 <monochrom> suppose I buy an mp3 player in japan and it does shift-jis only. that means the player's designer is so narrow-minded to conceive the possibility that maybe I want to put a couple of Russian songs and Greek songs on it. before unicode came along, can't blame them. after unicode came along, that's just stupid.
17:36:52 <roconnor> pikhq: I see I misread your statement
17:37:21 <pikhq> monochrom: Windows is now defaulting to Windows; they couldn't really keep doing that.
17:38:03 <pikhq> Erm.
17:38:07 <pikhq> s/Windows;/Unicode;/
17:38:10 <monochrom> see, this is the vain patriotic arrogance I refer to. to deny the possibility that citizens of a country wants to use foreign languages at all. "you are japanese, why would you do russian" vain patriotic arrogance.
17:38:51 <Pseudonym> Arrogance or ignorance?
17:38:57 <pikhq> It amazes me that Shift-JIS is still used on web sites, though.
17:39:10 <Pseudonym> Most people don't KNOW how to handle multiple languages.
17:39:11 <bremner> Pseudonym: isn't that a stevie wonder song?
17:39:46 <pikhq> Pseudonym: Most people shouldn't be allowed to touch string handling.
17:39:58 <JoeyA> You guys are too smart.  I don't have a clue who Stevie Wonder is.
17:40:49 <pikhq> Heck, it amazes me that there are *4* encodings in *common* use for Japanese.
17:40:58 <Jafet> I bet prince would have some things to say about unicode
17:41:04 <JoeyA> lol
17:41:13 <pikhq> (JIS, Shift-JIS, EUC-JP, UTF-8. These are ALL USED.)
17:41:18 <vanadium> How do you have to handle multiple languages?
17:41:26 <moosefish> plkhq: How many variants and dialects are used daily?
17:41:28 <vanadium> I figured I would just yell and explode at people who are not made of utf-8 and be okay
17:41:32 <c_wraith> I'm told Unicode lacks some characters the japanese really want, but if I ask what, no one can answer.
17:41:44 <kmc> recommendations for converting time from America/Los_Angeles to UTC?  seems we have 'zoneinfo' and 'timezone-series'
17:42:03 <pikhq> c_wraith: Probably just a handful of archaic characters in old names.
17:42:06 <Pseudonym> JoeyA, please tell me you're not serious.
17:42:10 <pikhq> monochrom: What?
17:42:13 <pikhq> Erm.
17:42:16 <pikhq> moosefish: What?
17:42:35 <JoeyA> I've heard that name before, but don't really know what his top hits are.
17:42:48 <pikhq> vanadium: UTF-8 is a very important step, but not *sufficient* to handling multiple languages right.
17:42:58 <Pseudonym> That's probably a good thing.  You want to steer clear of his top hits.
17:43:28 <vanadium> oh dear
17:43:30 <JoeyA> Are there any good papers on Stevie Wonder?
17:43:33 <pikhq> vanadium: You also need to handle left-right text, right-left text, and up-down text.
17:43:54 <pikhq> vanadium: And complex text layout (Indic scripts, Arabic, etc.)
17:44:04 <Pseudonym> http://www.youtube.com/watch?v=6sIjSNTS7Fs <- Any more Stevie Wonder remarks to be handled on -blah.
17:44:04 <vanadium> Right
17:44:10 <JoeyA> jk, of course.  When I read a paper, I typically get 1/3 of the way through, then they pop an "isomorphism" in there and it's over from there.
17:44:12 <pikhq> vanadium: And (it amazes me this is a problem) *diacritics*.
17:44:44 <JoeyA> I can't expect to skim papers without some effort.
17:44:59 <Pseudonym> It depends on the paper.
17:45:10 <JoeyA> But I could use a good dose of formal methods learning.
17:45:19 <pikhq> Finally, you need fonts that don't make people claw their eyes out. (this is mostly a problem for Chinese script)
17:45:26 <moosefish> pikhq: Just wondering how many human-level 'encodings' there are
17:45:30 <Pseudonym> I find that SPJ papers can generally be skimmed, in that the details you miss aren't important on a first reading.
17:45:39 <Pseudonym> Wadler papers, however, you miss out on critical stuff if you skim.
17:45:41 <pikhq> moosefish: Oh, you are asking about dialects of Japanese.
17:45:43 <JoeyA> Indeed.  Milner's paper on type polymorphism has plenty of prose in it that's relatively easy to understand.
17:46:05 <Jafet> In chinese, it's not unusual to make up a character for names
17:46:10 <monochrom> but Wadler papers are fun and easy. you won't need to skip anything.
17:46:14 <Jafet> Of course, this leads to... problems
17:46:19 <pikhq> moosefish: Well, there's about 127,000,000 people in Japan, so I'm going with about 127,000,000 different idolects.
17:46:19 <Pseudonym> JoeyA: Damas/Milner?
17:46:39 <JoeyA> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.67.5276&rep=rep1&type=pdf
17:46:48 <pikhq> Idiolects, even.
17:46:50 <JoeyA> "A theory of type polymorphism in programming"
17:47:28 <Pseudonym> Right.  Damas & Milner is the type inference algorith,.
17:47:42 <Pseudonym> Also worth a read.
17:48:39 <pikhq> Jafet: Yeah, and unless you're going to create a structural encoding of Chinese, that's... Not happening.
17:49:47 <Jafet> And then you'll find characters which cannot be encoded that way
17:50:51 <pikhq> Jafet: That's why you allow encoding strokes to create structural components!
17:51:02 <pikhq> Jafet: Alternately, that's why you kick people in the shin!
17:51:21 <Jafet> That's truetype style madness, not going there
17:56:50 * belley
18:00:20 <belley>  /names
18:06:05 * kmc is lost in a sea of enumerators and iteratees
18:07:13 <kmc> i can open a binary file as an Enumerator, and i can turn my attoparsec parser into an Iteratee
18:07:21 <kmc> i can't figure out how to glue them together
18:08:21 <benmachine> Enumerators are just functions on Iteratees aren't they?
18:08:36 <benmachine> so you just apply one to the other, and run the result
18:12:42 <kmc> ok
18:30:32 <mheld> hey y'all
18:33:36 <kmc> hi
18:36:23 <dibblego> is there a function (in System.Directory?) that tries to rename a file and if it fails, copies that file and deletes the old (as in /usr/bin/mv)?
18:48:08 * edwardk waves hello.
18:48:23 <kmc> what's «foldr (<|>) empty» named?
18:48:34 <kmc> @hoogle (Alternative f) => [f a] -> f a
18:48:35 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
18:48:35 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
18:48:35 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
18:48:41 <kmc> tricky
18:48:54 <roconnor> kmc: so it is asum?
18:48:57 <kmc> yeah
18:49:22 <kmc> i forgot about this incomplete project to generalize away from list
18:50:28 <dibblego> I needed this function just yesterday, but in Scala :(
18:50:53 <dibblego> (which I have written in a library, but it's "too scary")
18:51:03 <dibblego> where f=Parser
19:00:12 <FunctorSalad> hmm it's not important enough to change it now, but does anyone else find the 'ExitCode' type annoying ;)
19:00:31 <FunctorSalad> considering that 'ExitFailure 0' is illegal anyway
19:00:31 <dibblego> wotabootit?
19:00:47 <FunctorSalad> unnecessary verbosity
19:00:55 <dibblego> then yes
19:00:57 <FunctorSalad> compared to just newtyping int
19:01:21 <dibblego> does ExitFailure 0 at least fail?
19:01:34 <FunctorSalad> it fails at failing iirc :)
19:01:44 <dibblego> I find that disturbing
19:02:18 <dibblego> newtype ExitCode = E Int; exitSuccess = E 0 
19:02:32 <FunctorSalad> *** Exception: exitWith: invalid argument (ExitFailure 0)
19:02:32 <dibblego> (don't expose E)
19:02:55 <dibblego> oh of course
19:03:01 <FunctorSalad> failing at failing is not a double negation; pretty sure it will return nonzero
19:03:06 <dibblego> I submit my answer to your question: yes
19:03:38 <clarkg> Has anyone here have experience with Graphics.Gnuplot.Simple? How do I use the Grid constructor for Attribute?
19:04:12 <FunctorSalad> maybe it should derive Num too to get integer literals, don't know
19:05:16 <megajosh2> http://pastebin.com/ngwy9ent Can anybody tell me what I'm doing wrong here? The error is a little ambiguous
19:05:30 <megajosh2> Apparently I made a case statement wrong or somethin
19:05:32 <megajosh2> *g
19:05:54 <Pseudonym> megajosh2: case does pattern matching.
19:05:58 <Pseudonym> I think what you want is:
19:06:00 <Pseudonym> case rest of
19:06:02 <Pseudonym>     [] -> []
19:06:02 <FunctorSalad> hmm you can't pattern match on expressions
19:06:06 <Pseudonym>     _ -> words rest
19:06:08 <Pseudonym> Or:
19:06:11 <Pseudonym> case () of
19:06:15 <Pseudonym>    _ | null rest -> []
19:06:22 <Pseudonym>      | otherwise -> words rest
19:06:23 <Pseudonym> Or:
19:06:23 <megajosh2> I'm confusing guard with case... <_<
19:06:28 <Pseudonym> if null rest then [] else words rest
19:06:41 <Pseudonym> Yup.
19:06:59 <Pseudonym> It's unfortunate that Haskell doesn't have nice syntax for introducing guards in any old place.
19:07:11 <Pseudonym> But in this case, I think you really want pattern matching.
19:07:49 <roconnor> @type guard
19:07:50 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
19:08:15 <benmachine> > words []
19:08:16 <lambdabot>   []
19:08:20 <Pseudonym> Or that.
19:08:22 <megajosh2> I was afraid that was redundant
19:08:59 <Pseudonym> Still, kudos for remembering that edge cases often matter.
19:09:22 <djahandarie> Quickcheck reminds me!
19:09:28 <FunctorSalad> the guard compiles to a pattern match FWIW
19:09:37 <FunctorSalad> f =
19:09:37 <FunctorSalad>   \ (@ a_aed) (x_adf :: [a_aed]) ->
19:09:37 <FunctorSalad>     case x_adf of _ { [] -> A.f2; : _ _ -> A.f1 }
19:09:51 <megajosh2> Oh dear god
19:10:09 <FunctorSalad> (A.f2 and A.f1 are the return-value constants I used)
19:10:10 <Pseudonym> FunctorSalad: At high optimisation levels.
19:10:33 <FunctorSalad> of course you could still argue the pattern match is more understandable or readable :)
19:11:07 <Pseudonym> OTOH, the "null" is more reusable, if you decided to go to a Data.Sequence later.
19:11:09 <FunctorSalad> (and yeah, this is ghc-core, which is -O2 iirc)
19:12:37 <benmachine> just use words :P
19:12:44 <Pseudonym> At -O2, "words" might also be inlined here, and the multiple tests against [] might be compiled away.
19:15:38 <FunctorSalad> I'd have thought so, but at ghc-core default settings 'words' doesn't appear to be inlined at all
19:16:33 <Pseudonym> Right.
19:16:46 <FunctorSalad> which parameter does one crank up to make it inlined? assumed it's in the interface at all
19:17:58 <benmachine> maybe words is too big/recursive to be inlined
19:18:51 <Pseudonym> Or it has the wrong structure.
19:19:04 <dolio> Isn't words recursive?
19:19:24 <FunctorSalad> hmm it doesn't have its source in List.hi if I'm using this correctly ;)
19:19:44 <FunctorSalad> recursive functions don't get offered for inlining at all?
19:20:29 <FunctorSalad> even if it doesn't do any "recursive analysis", it might be nice to have the outermost level inlined and simplified, or not?
19:21:03 <dolio> Well, if you mark it INLINE, GHC will do some weird stuff, but by default, being recursive directly prevents inlining.
19:21:09 <maurer_> Hey, if I want to verify a structure, and error out at several possible points during verification (i.e. via error), what top level return value should this have? Intuitively I should use (), but then the thunk won't get forced and the errors won't happen
19:21:33 <Pseudonym> FunctorSalad: Unless they can be worker/wrappered.
19:21:44 <Pseudonym> In which case the wrapper is usually offered.
19:21:57 <Axman6> maurer_: what's wrong with returning Bool, with False for error?
19:22:05 <Pseudonym> What if you put words in the same file?
19:22:15 <maurer_> Axman6: I want to have different possible error messages
19:22:25 <Axman6> return Either then
19:22:29 <maurer_> And I don't want to continue verifying if I'm done
19:22:49 <maurer_> I guess I can do this with Maybe String and the right combiantions
19:22:58 <maurer_> *combinations
19:23:01 <maurer_> Sorry for bothering you.
19:24:52 <Pseudonym> No bother.  We're very good teddy bears.
19:25:42 <dolio> FunctorSalad: The only other case, besides worker-wrapper, would be if the static argument transform could be applied, and then the outer function inlined.
19:25:45 <dolio> But GHC doesn't do that.
19:26:34 <FunctorSalad> hmm
19:27:13 <dolio> And, if you force inlining, it does something weird, as mentioned.
19:27:32 <dolio> Like, inlining one copy of the function which calls a local copy of the recursive function.
19:29:33 <JoeyA> What's a good name of this function?  (Eq a) => [(a,b)] -> (a, [b])  It groups a list of pairs by their first item.
19:29:44 <FunctorSalad> Pseudonym: no change apparently when putting 'words' into the same module
19:31:26 * Pseudonym nods
19:32:58 <ddarius> JoeyA: Did you mean to have an extra [ ].
19:32:59 <FunctorSalad> even with {-# INLINE words #-}
19:33:00 <ddarius> ?
19:33:26 <JoeyA> oh, right
19:33:27 <JoeyA> thanks
19:33:31 <JoeyA> [(a,[b])]
19:34:21 * FunctorSalad wonders if anything became of the TH loop unroller =)
19:34:40 <FunctorSalad> IIRC it was on one of the maiilng lists once
19:35:04 <Pseudonym> > map (head &&& map snd) . groupBy fst
19:35:04 <lambdabot>   Occurs check: cannot construct the infinite type:
19:35:05 <lambdabot>    a = (a, b) -> GHC.Bool...
19:35:09 <Pseudonym> :t map (head &&& map snd) . groupBy fst
19:35:09 <lambdabot>     Occurs check: cannot construct the infinite type:
19:35:09 <lambdabot>       a = (a, b) -> Bool
19:35:10 <lambdabot>     Probable cause: `fst' is applied to too many arguments
19:35:24 <ddarius> :t groupBy
19:35:25 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
19:35:27 <Pseudonym> :t map (head &&& map snd) . groupBy ((==) `o` fst)
19:35:28 <lambdabot>     Couldn't match expected type `(a1 -> a1 -> Bool)
19:35:28 <lambdabot>                                   -> ((a2, b1) -> a2)
19:35:28 <lambdabot>                                   -> (a, b)
19:35:31 <Pseudonym> Hmm.
19:35:33 <JoeyA> :i (&&&)
19:35:36 <JoeyA> :t (&&&)
19:35:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:35:39 <Pseudonym> :t map (head &&& map snd) . groupBy ((==) `on` fst)
19:35:40 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [((a, b), [b])]
19:35:54 <Pseudonym> :t map ((fst . head) &&& map snd) . groupBy ((==) `on` fst)
19:35:55 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [(a, [b])]
19:35:55 <Pseudonym> Right.
19:36:13 <Pseudonym> It's a bit of a long name.
19:36:36 <ddarius> Pseudonym: People do often say that we should use more meaningful names...
19:36:42 <JoeyA> @let groupPairs = map (liftA2 (,) (fst . head) (map snd)) . groupBy ((==) `on` fst)
19:36:44 <lambdabot>  Defined.
19:36:50 <JoeyA> > groupPairs [(1,2),(1,3),(2,1),(2,2),(1,4)]
19:36:51 <lambdabot>   [(1,[2,3]),(2,[1,2]),(1,[4])]
19:37:22 <JoeyA> A question of style: is it better to use the liftM series or the liftA series when working with types which have instances for both (such as functions)?
19:39:11 <Pseudonym> liftM depends on fewer extensions to H98.
19:39:18 <Pseudonym> But that's probably not an issue.
19:39:35 <JoeyA> You mean library extensions?
19:39:44 <JoeyA> Or language extensions?
19:39:48 <Pseudonym> I mean language extensions, yes.
19:41:05 <avenge> What language extensions are required for liftM?
19:41:46 <ddarius> :t Monad.liftM
19:41:47 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:41:53 <kmc> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r  -- this one?
19:42:00 <kmc> no extensions required to my knowledge
19:42:02 <magicman> I think liftM is H98-compatible.
19:42:04 <ddarius> Presumably none as it is in the Report.
19:42:44 <ddarius> liftA also doesn't rely on any language extensions.
19:42:47 <avenge> That's what I thought.  Also, liftA should be implementable in H98, right?
19:43:01 <avenge> :src liftA
19:43:05 <avenge> @src liftA
19:43:06 <lambdabot> liftA f a = pure f <*> a
19:44:31 <avenge> I wish there were a standard infix operator for liftM.  I used <$> a lot, but when my context only has Monad, I can't assume Functor.
19:44:53 <djahandarie> (Annoyingly)
19:45:33 <Pseudonym> Which is arguably a bug in the typeclass hierarchy.
19:45:46 <Pseudonym> Or, to put it another way, is yet another reason why we need typeclass aliases.
19:46:11 <ddarius> It's not a bug as Gofer had it that way.
19:46:28 <avenge> What are typeclass aliases?  A simpler solution would at least be to declare infixl 4 `liftM`.
19:48:14 <JoeyA> > (you `liftM` me) up
19:48:15 <lambdabot>   ... so I can stand on mountains
19:48:29 <djahandarie> ......
19:48:34 <djahandarie> > you
19:48:35 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:48:35 <lambdabot>    arising from a use of `...
19:48:47 <djahandarie> Heh
19:48:49 <lambdabot> We were discussion you, not me.
19:48:58 <JoeyA>  @let you = id  @let me = id @ let up = "so ..."
19:49:13 <djahandarie> I didn't know bots could make typos...
19:49:23 <lambdabot> I blame the programmer.
19:49:56 <medfly> skynet?
19:50:27 <JoeyA> Crap, it's "You raise me up"
19:50:28 <dho> arnold.
19:50:31 <JoeyA> so much for the pun
19:50:39 <rschnck> Can someone explain what is going awry here? http://codepad.org/Hir442I6
19:50:40 <Pseudonym> :t raise
19:50:40 <lambdabot> forall (a :: * -> * -> *) ex b. (ArrowError ex a) => a ex b
19:50:55 <JoeyA> really.  Hoogle didn't find it
19:51:05 <JoeyA> http://www.haskell.org/hoogle/?hoogle=raise
19:51:40 <Axman6> @instances ArrowError
19:51:41 <lambdabot> Couldn't find class `ArrowError'. Try @instances-importing
19:51:48 <JoeyA> rschnck: isMemeberOf :: (Eq a) => a -> [b] -> Bool
19:51:49 <c_wraith> rschnck, You're using the (==) operator on list elements
19:52:17 <c_wraith> rschnck, Using that operator requires that you restrict the type of list elements allowed to those that support (==), which are those in the Eq typeclass
19:52:28 <JoeyA> err, (Eq a) => a -> [a] -> Bool
19:52:28 * Axman6 wonders at what point in the future Galois renames itself to Cyberdyne Systems
19:52:46 <JoeyA> isMemberOf :: a -> [b] -> Bool says this function will work on any two (possibly distinct) types a and b.
19:53:02 <rschnck> Oh.
19:53:09 <rschnck> And == is only valid for numerical characters.
19:53:19 <rschnck> Right?
19:53:29 <JoeyA> It's only valid for types in the Eq typeclass.
19:53:33 <Axman6> not at all
19:53:38 <Axman6> > "hello" == "world"
19:53:39 <lambdabot>   False
19:53:43 <rschnck> Oh :3
19:53:49 <Axman6> @src Eq
19:53:49 <lambdabot> class  Eq a  where
19:53:49 <lambdabot>     (==), (/=)   :: a -> a -> Bool
19:53:53 <Axman6> @instances Eq
19:53:54 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:53:54 <JoeyA> By saying isMemberOf :: (Eq a) => a -> [a] -> Bool, you enforce two constraints on how your function is called (and get the type checker off your back):
19:54:09 <JoeyA> isMemberOf must be called with types which can be compared with ==
19:54:21 <JoeyA> and the type of the needle must be the same as the type of the haystack items.
19:54:29 <JoeyA> :t elem
19:54:31 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:54:53 <JoeyA> > 3 `elem` [1,2,3]
19:54:54 <lambdabot>   True
19:55:08 <JoeyA> It's good to implement those functions for practice, of course.
19:57:51 * hackagebot AttoJson 0.5.7 - Simple lightweight JSON parser, generator & manipulator based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.7 (HiromiIshii)
19:58:09 <rschnck> So wait, Eq is a typeclass
19:58:28 <rschnck> And in that typeclass, every single type can be utilized with the == operation
19:58:37 <c_wraith> That's what a typeclass means.
19:58:40 <rschnck> So why do we write (Eq a) => ?
19:58:45 <rschnck> What does the => mean?
19:59:03 <c_wraith> it separates the context of the type, from the type itself
19:59:19 <c_wraith> (Eq a) in the context means "a must be an instance of Eq"
19:59:52 <c_wraith> and then the type signature, a -> [a] -> Bool, indicates what the actual type is, when you substitute something specific in for a
19:59:58 <rschnck> Ah, okay.
20:00:26 <c_wraith> :t (<)
20:00:27 <lambdabot> forall a. (Ord a) => a -> a -> Bool
20:00:45 <c_wraith> There's a similar example :)
20:01:18 <rschnck> What does Ord stand for?
20:01:26 <c_wraith> Ordered
20:01:46 <c_wraith> @src Ord
20:01:47 <lambdabot> class  (Eq a) => Ord a  where
20:01:47 <lambdabot>     compare      :: a -> a -> Ordering
20:01:47 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:01:47 <lambdabot>     max, min         :: a -> a -> a
20:01:49 <rschnck> i.e. things of different magnitudes?
20:01:54 <c_wraith> yes.
20:02:00 <rschnck> Neat, that makes sense :D
20:02:16 <Axman6> @src Ordering
20:02:16 <lambdabot> data Ordering = LT | EQ | GT
20:03:59 <c_wraith> Usually, people talk about the context of a type as constraining the type.  It's not polymorphic over *all* types anymore, just the ones that fit the context.
20:04:01 <freedrull> tab doesnt work in ghci in cygwin :X
20:05:18 <rschnck> What's the "it's" in "It's not polymorphic"?
20:06:08 <c_wraith> rschnck, ah, I wasn't clear there.  Any type variable constrained in the context.
20:06:29 <c_wraith> so like...
20:06:58 <c_wraith> :t let ifEq a b c d = if a == b then c else d in ifEq
20:06:59 <lambdabot> forall a t. (Eq a) => a -> a -> t -> t -> t
20:07:18 <c_wraith> The type a is constrained by the context, in that signature.  the type t is unconstrained
20:07:29 <rschnck> Ah!
20:07:56 <rschnck> So even though a can take any type, the contexts in which a is used may limit the types it can take?
20:08:04 <c_wraith> yes
20:08:04 <rschnck> Which is why I ran into my problem.
20:08:50 <rschnck> I have an essay to write, but thanks as always for your continued help with my haskell tribulations.
20:19:50 <Kaidelong> why do people paint monads as these intimidating things when they're ridiculously simple
20:20:19 <Kaidelong> perhaps that's the problem actually, simple and general means you have to figure out how they are used yourself
20:30:22 <freedrull> Kaidelong: surely you thought they were intimidating at one point?
20:30:41 <Kaidelong> yeah, but only because I was told to expect that they would be
20:30:46 <Kaidelong> using them properly is hard
20:30:53 <Kaidelong> but the concept itself is simple
20:32:40 <Kaidelong> It's a bit like how people have trouble understanding differentiation because they expect calculus will be hard and turn off the learning
20:33:00 <FunctorSalad> how simple it is also depends on whether you already know type constructors and type classes
20:33:02 <Kaidelong> when differentiation taught in 100 level classes is really really easy stuff
20:33:05 <freedrull> i understand.....the type signatures of the monad class
20:33:30 <Kaidelong> that's sort of true
20:33:44 <Kaidelong> but you can show monad functions by example without deeply understanding how types work
20:34:01 <Kaidelong> m (m a) -> m a may not make a lot of sense but "concat" does
20:34:08 <Kaidelong> to a person looking at it
20:34:22 <Kaidelong> and getting an explanation of what it does
20:34:30 <medfly> I would like to bash you for being all US centric there. :-D
20:35:46 <c_wraith> about class numbering?  That a convention *some* US schools use, but certainly not all.  Possibly not even a majority.
20:36:15 <Kaidelong> yeah, I think WA state standardized it recently though
20:36:23 <Kaidelong> at least for state schools
20:36:31 <tensorpudding> they don't number classes per say, but "100-level" and "foo 101" has become common enough
20:36:40 <tensorpudding> as metaphors for introductory classes
20:36:45 <Kaidelong> "introductory calculus"
20:36:50 <Kaidelong> exactly yes thank you tensorpudding 
20:37:06 <c_wraith> introductory calculus was 200-level at the school I went to. 100-level was "are you sure you can do algebra?"
20:37:11 <tensorpudding> though maybe it doesn't have international appeal
20:37:38 <Kaidelong> c_wraith: here they tend to put that under 100 level, high school algebra would be MATH 96, for example
20:37:40 <tensorpudding> lots of schools which number classes don't use three digit numbers too
20:38:07 <c_wraith> tensorpudding, that was my main point.  that numbering scheme might be widespread, but it's not even universal in the US
20:38:12 <Kaidelong> actually they use MATH 96, 97, and 98 to describe some of the classes I took in high school
20:38:28 <Kaidelong> and the high school gave me a textbook called "Math 98"
20:38:35 <Kaidelong> so it's probably a standard
20:39:10 <Kaidelong> anyway this is a bit off topic now
20:39:12 <Kaidelong> sorry
20:39:28 <EvanR> direct-fastcgi seems to be not ready
20:39:29 <tensorpudding> Math '98, to be replaced by Math'
20:39:33 <freedrull> Kaidelong: the evergreen *state* college certainly didnt adhere to this standard >:3
20:39:53 <EvanR> if thats true i wish it would say that somewheres on hackage or something
20:40:20 <Kaidelong> Evergreen State College would not adhere to a standard if it costed them their lives
20:40:32 <Kaidelong> that said, what I heard of the place sounds nice
20:40:38 <Kaidelong> but they insist on doing everything differently
20:41:32 <freedrull> well it certainly was interesting 0__p....
20:42:52 <freedrull> if nothing else i got some nice haskell teachings from it
20:43:07 <freedrull> and the stereotype of the hippie firmly ingrained into my mind
20:51:48 <JoeyA> attoJSON fails to display (after parsing) "0.0" with a leaky infinite loop.
20:53:59 <JoeyA> Other than that, it passes all of my validation tests.
20:54:14 <JoeyA> (separately developed; I had nothing to do with attoJSON)
20:55:16 <kmc> Kaidelong, 'monad' is this unusual word associated with Haskell, so people show up and ask "hi, I hear Haskell is about monads, tell me all about them"
20:55:34 <kmc> problem A being that they don't have prerequisites
20:55:48 <kmc> problem B being that they're expecting it to be something big and complex and enlightening
20:56:06 <kmc> and so the answer "it's a little API used by a lot of unrelated stuff" is not satisfying
20:56:26 <Kaidelong> Well it's really more a concept
20:56:30 <kmc> problem C being it's confuddled with IO
20:56:54 <kmc> it might be interesting / enlightening that you can do IO with first-class action description values, but the monadic API is just a small part of that
20:57:58 <kmc> every type class is a concept in a sense, but does the Monad concept go much deeper than the function types and the laws?
20:58:32 <Kaidelong> well concepts are better when they are simple
20:58:40 <Kaidelong> and yes
20:58:46 <Kaidelong> that's probably what makes haskell different
20:59:30 <Kaidelong> you don't talk so much about particular tools you have at your disposal to work with certain kinds of data but you more look at it from the viewpoint that certain kinds of data have certain properties that you can take advantage of
20:59:35 <Kaidelong> I suppose it is the same idea in the end
20:59:41 <Kaidelong> but it does feel very different
21:00:51 <Biggles> I think that in getting what monads are, there is something somewhat enlightening. It's just kind of abstract rather than hugely complex.
21:01:21 <EvanR> 'its too simple!'
21:01:23 <Biggles> But I mostly understand them in a "durr this is how i uses it" sense.
21:01:41 <Jafet> But they don't realize, that's what enlightenment is all along
21:01:51 <EvanR> haskell is zen!
21:01:54 <Jafet> They confuse it with epiphany.
21:10:53 <kmc> Haskell is not that zen
21:10:57 <kmc> it's got too much stuff in it
21:11:28 <kmc> it's a surprisingly effective compromise between lots of different goals
21:11:41 <kmc> it's not near the Platonic ideal of any one goal
21:11:47 <kmc> as are some languages
21:13:22 <tensorpudding> Haskell is daoism, says Internet meme.
21:13:29 <kmc> yeah?
21:13:34 <kmc> internet memes are never wrong
21:13:50 <Kaidelong> wouldn't that somewhat imply that it's impossible to learn?
21:25:57 <EvanR> aaa hahahahaha
21:26:06 <EvanR> direct-fastcgi hacked ;)
21:28:11 <kmc> yeah?
21:29:01 <EvanR> still testing it, but seems like perfectly working fastcgi code, that simply goes 'dud' when you try to use its latest version
21:29:47 <EvanR> unless you make it listen on a Just Socket rather than Nothing by recompiling
21:34:30 * hackagebot kit 0.4.3 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.4.3 (NickPartridge)
21:35:28 <EvanR> yep, just served up "Hello World"
21:35:47 * EvanR wonders if this is what everyone else is using ;)
21:36:05 <EvanR> wheres chrisdone
21:37:05 <seydar> hey guys
21:49:10 <trinithis> I'm not sure if it's possible, but what is the syntax for using rank-n types along with a type class? For example, I want something like [forall (Ident i) => i. i]
21:49:37 <dibblego> @hoogle (Monad m) => m a -> m ()
21:49:37 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
21:49:38 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
21:49:38 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
21:52:51 <kmc> trinithis, you want a list of values, each of which is required to be able to assume any Ident type?
21:53:06 <trinithis> yes
21:53:17 <kmc> each *individual* value has to live in *every Ident type*?
21:53:23 <kmc> that's unusual, but it can be done
21:53:36 * hackagebot http-enumerator 0.1.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.1.0 (MichaelSnoyman)
21:53:42 <trinithis> or at least i think so
21:53:47 <kmc> you could use -XImpredicativeTypes, which is deprecated, but probably you should make a wrapper instead
21:53:48 <trinithis> for example, if
21:53:58 <kmc> data AllIdent = AllIdent (forall i. (Ident i) => i)
21:54:08 <trinithis> Int and () are instances, then [(), 9] would work
21:54:21 <trinithis> oh ok
21:54:27 <kmc> it's much more common to want a list such that each *specific* value belongs to *some* ident type
21:54:34 <kmc> that's existential, not universal quantification
21:54:59 <kmc> so first off, what's wrong with «data Ident = IUnit () | IInt Int»
21:55:00 <trinithis> I'm writing a code generator, and wanted to make things easy on its use
21:55:01 <kmc> [Ident]
21:55:56 <trinithis> or rather less clutter
21:56:50 <trinithis> But ill give your suggestions a shot
21:57:01 <kmc> an existential will require a wrapper type too (in GHC)
21:57:16 <kmc> existentials are useful for *open* sum types: when your users need to be able to add instances
21:57:20 <kmc> e.g. Control.Exception
21:57:37 <kmc> but if you don't need that capability, a plain old boring Haskell 98 sum type is much simpler
21:58:02 <trinithis> ok
21:58:21 <kmc> quite a few Haskell modules go crazy with lots of types and type classes and existential quantification and overloading every name nine different ways
21:58:59 <kmc> i try to argue for the simpler, more direct approach
21:59:16 <trinithis> haha o
21:59:19 <trinithis> ok*
22:38:52 <dancor> is it true that Text.JSON doesn't handle unicode the same way JS does?
22:42:34 <JoeyA> Text.JSON.AttoJSON (a different package) currently doesn't parse surrogate pairs according to the JSON spec, but I'm going to send a patch to the maintainer fixing it in a few hours.
22:42:45 <dancor> ah
22:43:00 <JoeyA> I'm basically being a JSON cop today :-)
22:43:16 <JoeyA> AttoJSON also has a horrible horrible bug where it parses 0.05 as 0.5
22:43:22 <JoeyA> and infinite loop/leaks on 0.0
22:43:33 <JoeyA> (that I've also fixed)
22:44:41 <kmc> did you try JSONb
22:44:45 <kmc> it uses bytestrings
22:44:51 <kmc> so you can decode however you like
22:46:11 <JoeyA> AttoJSON also uses bytestrings
22:46:29 <manateeUser> I use AttrJSON, works well.
22:46:52 <dancor> in JS (chrome anyway), JSON.stringify("Ü") -> '"\\u00dc"'
22:46:53 <JoeyA> and Text.JSON doesn't handle surrogate pairs, no surprise.
22:47:43 <manateeUser> I found getFields in AttrJSON is pretty handy.
22:47:47 <Ke> does ghc runtime require filesystem access after the program has been linked properly?
22:47:55 <manateeUser> @hoogle getFields
22:47:55 <lambdabot> No results found
22:48:01 <Ke> linked and initialized
22:48:04 <kmc> i think the real problem here is JSON itself
22:48:05 <manateeUser> @package AttrJSON
22:48:05 <lambdabot> http://hackage.haskell.org/package/AttrJSON
22:48:13 <kmc> the world doesn't have enough ways to represent nested key-value dictionaries
22:48:26 <kmc> i propose CSON
22:48:31 <kmc> based on the literal syntax of COBOL
22:48:38 <dancor> from what i can tell, none of the haskell JSON packages replicate this behavior..
22:49:27 <JoeyA> what behavior?
22:49:35 <dancor> JoeyA: JSON.stringify("Ü") -> '"\\u00dc"'
22:49:39 <JoeyA> oh
22:50:22 <JoeyA> That's obviously non-conforming.  Make sure you've indicated the proper charset.
22:50:58 <JoeyA> err
22:51:10 <JoeyA> that's right
22:51:15 <JoeyA> are you talking about the \u00dc ?
22:51:18 <JoeyA> or the \\ ?
22:51:20 <bonii_> Hi, I want to check if one of my variables is a valid list index, is there a function to check it?
22:51:26 <JoeyA> Because \u00dc is actually the right codepoint.
22:51:35 <JoeyA> (deceiving because it's so close to ASCII)
22:52:15 <kmc> bonii_, you can get the length of a list with "length"
22:52:24 <kmc> but the phrase "list index" is a warning sign
22:52:27 <kmc> lists aren't good for indexing
22:54:21 <JoeyA> How do you tell an AttoParsec parser that it failed?  By using fail in Monad?
22:54:49 <JoeyA> I want to backtrack when uc is not >= 0xd800 and <= 0xdc00
22:55:38 <JoeyA> err, <
22:56:33 <JoeyA> maybe I could just factor out the backtrack.  Not hard in this case.
22:57:24 <dancor> JoeyA: I'm confused.  With attojson for example, I get 3 for (Data.ByteString.length . showJSON $ toJSON "\220") but I think it should be 8, the result string should contain: " \ u 0 0 d c "
22:58:41 <Mitar> why does (\f -> replay =<< readFile f) work, (replay =<< readFile) does not?
22:58:44 <JoeyA> Unicode doesn't have to be escaped.
22:58:48 <JoeyA> in JSON
22:58:58 <JoeyA> JSON consists of a string of Unicode characters.
22:59:25 <JoeyA> In your case, it looks like it just echoed the Unicode string out.
22:59:31 <JoeyA> character*
22:59:45 <dancor> ah, ok.
23:00:15 <JoeyA> though showJSON might escape it.
23:00:29 <JoeyA> oh, you used that
23:01:36 <JoeyA> hmm:  mustEscape ch = ch < ' ' || ch == '\x7f' || ch > '\xff'
23:02:18 <JoeyA> it's not UTF-8-encoding it, then...
23:02:59 <JoeyA> You're right, length should be > 3
23:03:30 <dancor> JoeyA: am i right?  i'm not sure anymore
23:03:32 <JoeyA> Like someone said on StackOverflow, understanding monads is a cake walk compared to handling Unicode correctly.
23:03:54 <kmc> heh
23:04:02 <dancor> i think it could be 3 if it's " \220 "
23:04:06 <kmc> http://www.joelonsoftware.com/articles/Unicode.html is not a bad intro
23:04:08 <dancor> if that's legal JSON
23:04:42 <kmc> "understanding monads" is not a good benchmark because nobody can agree how hard it is and everyone who does understand them is convinced that current teaching methods suck
23:04:42 <JoeyA> well, it has to be valid UTF-8
23:05:09 <dancor> i can UTF8 encode it after
23:05:11 <JoeyA> When you go above 0x7F, it takes more than one byte to encode.
23:05:33 <JoeyA> But showJSON pidgenholes it to a ByteString
23:06:05 <JoeyA> So it should either encode in UTF-8, or it will cut off everything above 0xFF.
23:06:22 <JoeyA> (or otherwise escape it, which is what AttoJSON does)
23:06:56 <dancor> so it seems like attojson is correct
23:07:08 <JoeyA> Well, it's not outputting valid UTF-8
23:07:10 <dancor> even though my life would be easier if it had escaped everything over 127
23:07:24 <JoeyA> You'd have to convert a ByteString to UTF-8
23:07:34 <dancor> i can do that
23:10:18 <dancor> but it does sort of seem crazy
23:10:30 <dmwit> Mitar: Because they mean different things.
23:10:40 <dmwit> Mitar: But consider (replay =<<) . readFile
23:11:01 <Mitar> thanks
23:11:03 <dmwit> Mitar: ...if you really, really want point-free code, that is. If you want readability, just use a lambda.
23:11:22 <dmwit> It's what they were created for, after all.
23:11:45 <Mitar> true
23:14:09 <JoeyA> Here's the problem: parseJSON treats the input as UTF-8.  showJSON treats the output as ISO-8859-1 or something.
23:14:55 <JoeyA> It'd be nice if showJSON UTF-8 encoded the output, but escaping is probably more robust.
23:15:29 <JoeyA> as in, escaping all non-ASCII characters
23:16:46 <EvanR> how about treating JSON like it was meant to be treated
23:16:47 <dancor> ya
23:17:05 <dancor> in the end this mess works for my case: ok . toResponse . toUtf8 . map (chr . fromIntegral) . B.unpack . J.showJSON $ J.toJSON [wds, map (showHtmlFragment . toHtml) wdDefs]
23:18:11 <EvanR> JSON is a text format. its string data is defined as allowing almost any unicode characters
23:18:21 <EvanR> escaping it only adds confusion
23:20:05 <EvanR> fix processors, not processees, or we will turn into html
23:21:17 <dancor> EvanR: i guess you are saying things are easier if you work with a String instead of shoehorning into a ByteString
23:21:57 <dancor> and you disapprove of attojson's approach in general
23:22:18 <JoeyA> attojson stores JSON strings internally as UTF-8 bytestrings.
23:23:01 <JoeyA> 1. Deprecate all string types in Haskell and introduce a new one parameterized by its encoding (e.g. String UTF8).
23:23:06 <JoeyA> 2. Make Haskell really really popular.
23:23:16 <JoeyA> 3. Deprecate all other encodings except UTF-8.
23:23:23 <JoeyA> 4. Go back to the old string type.
23:23:24 <JoeyA> 5. Profit
23:24:09 <Jafet> (mutilated sarah voice) How dare you oppose Char!
23:24:15 <kmc> steal underpants
23:25:05 * hackagebot clogparse 0.1 - Parse IRC logs such as the #haskell logs on tunes.org  http://hackage.haskell.org/package/clogparse-0.1 (KeeganMcAllister)
23:25:26 <JoeyA> I get it... I think
23:25:37 <JoeyA> Jafet must construct additional pylons.
