00:09:21 <Axman6> itrekkie: are you following a tutorial at all?
00:09:57 <itrekkie> yea, a supposedly gentle one
00:10:05 <itrekkie> but going off on my own a lot
00:11:07 <dolio> The Gentle Introduction?
00:11:30 * hackagebot flower 0.4 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.4 (KetilMalde)
00:12:23 <kmc> itrekkie, the Gentle Introduction isn't really a tutorial, url notwithstanding
00:12:43 <dolio> It's what real pros use to learn.
00:12:47 <itrekkie> well that's basically all I've been going off of
00:13:26 <kmc> @where LYAH
00:13:27 <lambdabot> http://www.learnyouahaskell.com/
00:13:27 <kmc> @where RWH
00:13:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:14:02 <itrekkie> cool, I'll check those out
00:15:18 * geheimdienst followed the tutorial of Messing Around Unwisely With Xmonad.hs, Incompetently Copy-Pasting Stuff From The Web While Yelling at Ghc And Generally Practicing a Ballistic Hit-or-Miss Approach to Haskell Syntax
00:15:53 <flippo> Yelling is an important part of the learning process.
00:16:39 <Zao> geheimdienst: That's my approach to attoparsec and applicative in general.
00:16:39 <geheimdienst> and so is being yelled at
00:16:57 <kdvh> I still haven't really configed Xmonad.hs, apart from keybinds. I guess that would be a test of how much I have learned in the past 2 months.
00:17:05 <Zao> I have no idea why things work, nor why they don't work. All I know is that if I build runways, the planes will come.
00:17:26 <geheimdienst> ghc also has gone through a learning phase, but i feel the two of us have reached an uneasy understanding now
00:17:27 <Phyx-> geheimdienst: that's not true, ghc is generally very polite :P
00:18:12 <geheimdienst> zao, i'm inclined to quote you some feynman on cargo cult ... :)
00:19:08 <Zao> Similarly, Perl sigils and references.
00:19:21 <Zao> I constantly think I understand them fine, then they kick me in the groin.
00:23:01 <kmc> ghc is quite polite, it makes lots of suggestions
00:23:11 <kmc> unfortunately its suggestions are usually hilariously wrong
00:23:29 <Zao> kmc: I hear that FlexibleInstances and IncoherentRamblingMadmen are good ones.
00:28:23 <osfameron> kmc: yeah, they're very long and misguided often
00:29:48 <mm_freak> kmc: what kind of suggestions?  like enabling extensions?
00:30:03 <dolio> The extension suggestions are pretty accurate.
00:31:05 <mm_freak> dolio: i agree
00:31:28 <mm_freak> (although sometimes when an extensions would work the user really needs something else)
00:31:30 <dolio> The only one I can think of that's likely to be inaccurate is suggesting TypeOperators when you write a "forall x. e" type.
00:31:38 <dolio> Assuming it still does that.
00:39:29 <kmc> mm_freak, "    Possible fix: add an instance declaration for (Num (t -> t1))"
00:39:45 <kmc> also, if you create a file with the contents "3\n"
00:40:03 <kmc> the error is: "No instance for (Num (Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]))"
00:41:25 <ddarius> Interesting.
00:42:04 <mm_freak> dolio: or fundeps
00:42:28 <mm_freak> kmc: i see
00:42:54 <ddarius> I remember mentioning a change in TH syntax to allow unmarked splices.
00:49:17 <harlekin> Aren't the Haskell *Weekly* news weekly?
00:54:46 <earthy> they used to be.
00:55:05 <Zao> HWN editors tend to be blackholed.
00:56:26 <harlekin> What a pitty. Thank you.
01:13:23 <ManateeIrcClient> mm_freak: I have run your code all day, works fine.
01:14:40 <ManateeIrcClient> mm_freak: Thanks for build fastirc, it's fast, stable library, like it's name. :)
01:28:21 <mm_freak> ManateeIrcClient: thanks for the feedback
01:42:05 <int-e> Hmm, I wonder whether the  Monoid w  constraint in the  MonadWriter  class could be removed. Here's what I'm doing: http://pastebin.com/R56AXS3P - there is an underlying monoid for that type, but I'd rather use a newtype wrapper than defining a monoid instance for the type itself. The code also shows that the Monoid instance used and that of w can be completely unrelated.
01:45:27 <dolio> The monoid constraint it necessary for the Monad instance.
01:45:36 <dolio> And MonadWriter has a Monad constraint.
01:47:18 <dolio> Or, you're defining your own separate monad that happens to be a writer? I guess it may not be necessary, then.
01:47:56 <Baughn> So.. I've got some file-reading code working with iteratees. What I can't figure out is *why*, as it looks precisely the same as the equivalent IO code. What am I missing?
01:49:06 <mm_freak> int-e: well, from a more practical perspective, if you didn't have the Monoid constraint, you could just as well use a state monad
01:50:34 <mm_freak> int-e: and the newtype wrapper approach is indeed used in the base library
01:50:49 <handonson> i see 'default' gets highlighted when i type the word in a haskell-syntax-highlighted editor. what does the keyword do?
01:50:57 <int-e> mm_freak: I think that 'tell' is the right variavke
01:51:11 <mm_freak> > Sum 13 `mappend` Sum 14
01:51:12 <lambdabot>   Ambiguous occurrence `Sum'
01:51:12 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
01:51:19 <mm_freak> > Sum 13 `mappend` Sum 14 :: Sum Integer
01:51:20 <lambdabot>   Ambiguous occurrence `Sum'
01:51:20 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
01:51:25 <mm_freak> huh?  oh
01:51:28 <dolio> Well, he's right. I don't see any reason for 'class (Monoid w, Monad m) => MonadWriter w m'.
01:51:30 <int-e> dolio: yes, I'm defining my own monad. And there is an underlying monoid, so I believe that tell (and listen and pass) are the right verbs.
01:51:34 <mm_freak> > Data.Monoid.Sum 13 `mappend` Data.Monoid.Sum 14
01:51:35 <lambdabot>   Sum {getSum = 27}
01:51:41 <dolio> If the instance needs it, it can add the Monoid w itself.
01:51:58 <dolio> The only benefit I can see is smaller contexts.
01:52:36 <mm_freak> handonson: using the 'default' key word you can decide, what the default types are, if types are ambiguous around Num and Fractional
01:52:38 <int-e> dolio: that's what I thought. (which also means it's probably too late to change it now.)
01:53:09 <handonson> mm_freak: can you show me a code example?
01:53:11 <dolio> Maybe you can get it taken out of monads-tf.
01:53:19 <dolio> Which will become the standard.
01:53:34 <ddarius> handonson: You probably don't want to use default unless it's to turn it off
01:53:34 <mm_freak> handonson: i think the syntax looks like this:  default (Integer, Double)
01:54:14 <geheimdienst> > "dons" `isInfixOf` "handonson"
01:54:15 <lambdabot>   True
01:54:17 <geheimdienst> woah
01:54:18 <dolio> monadLIb gets it right.
01:54:42 <handonson> geheimdienst: yeah, he is a subset of me
01:54:56 <handonson> i'm the complete version of him
01:57:08 <mornfall> dolio: Why will monads-tf become the standard?
01:57:36 <mm_freak> btw, yesterday i've written a CPS-based state transformer (again) and compared its speed to that of monadLib's StateT
01:57:42 <mm_freak> they are both the same
01:57:44 <dolio> Because it has nicer properties, and eventually type families will subsume functional dependencies.
01:57:59 <mm_freak> aren't CPS-based monads supposed to be faster?  what's the requirement?
01:58:04 <mornfall> mm_freak: What's the difference to MTL?
01:58:17 <mornfall> dolio: Nicer properties than what?
01:58:28 <mornfall> dolio: As for type families, in 6.12 they are really quite immature.
01:58:31 <mm_freak> mornfall: nothing internally
01:58:36 <handonson> mornfall: than fd?
01:59:02 <dolio> All the monad classes in mtl/monads-fd are of the form: 'MonadClass t m | m -> t'.
01:59:04 <mornfall> handonson: Oh. But I was asking about transformers/monad-tf v. monadLib, not against fd. :D
01:59:20 <dolio> Which means that t is a paradigm example of an associated type.
02:00:06 <mm_freak> mornfall: i use monadLib mainly because of the interface, not because of the implementation
02:00:29 <mornfall> mm_freak: I understand that. But I hear that the State(T) implementations in libraries are "notoriously slow".
02:00:40 <mornfall> mm_freak: Compared to hand-rolled state monads.
02:00:45 <mm_freak> if you have ReaderT x (StateT y m) a, you don't need to lift to use state computations
02:00:52 <dolio> And functional dependencies don't handle them very gracefully. You'll notice that undecidable instances are required (last I checked) for the classes of that form in mtl.
02:01:04 <mm_freak> mornfall: if you use a pure state monad, that's wrong
02:01:08 <mornfall> mm_freak: So I was interested if you did some experiment to actually compare them (as opposed to spreading gossip) : - )
02:01:13 <mm_freak> mornfall: but if you use a transformer stack, it /may/ be true
02:01:59 <mm_freak> mornfall: a hand-rolled monad is faster than ReaderT x (StateT y m)
02:02:04 <mm_freak> but not faster than StateT y m
02:03:07 <mm_freak> but my main point against the usual definition of StateT, ReaderT, etc. is that they don't use CPS
02:03:23 <mm_freak> CPS makes them more flexible and slightly less lazy
02:04:01 <dolio> Any instance of the form 'Foo s t => Foo (T s) t' fails the termination checker for fundeps.
02:04:05 <mm_freak> for example you wouldn't need to wrap a ContT around to make computations abortable/restartable
02:04:26 <dolio> But 'Foo s => Foo (T s)' with an associated type is accepted by the type families checker.
02:04:35 <mornfall> mm_freak: No, I use State Foo. I also replaced some data FilePathMonad a = FPM ([FileName] -> ([FileName], a)) with State [FileName] ... was told that the mtl monads are "notoriously slow".
02:05:00 <mm_freak> mornfall: in that case it's wrong
02:05:01 <mornfall> I find it a bit hard to believe though, but didn't yet have time to write a benchmark.
02:05:22 <mm_freak> note this:  newtype State s a = S (s -> (a, s))
02:05:58 <mm_freak> i often use state monads in such a case, because you get then handy do-notation for free
02:06:00 <mornfall> mm_freak: True. I think Heffalump said that GHC won't do enough inlining on mtl (compared to local definitions).
02:06:10 <mm_freak> i also often use the ((->) a) monad
02:06:26 <mm_freak> > zip <$> inits <*> tails $ "abc"
02:06:27 <lambdabot>   [("","abc"),("a","bc"),("ab","c"),("abc","")]
02:06:40 <mornfall> (The original slowness claim was by lispy, but I don't recall if he gave a reason for it...)
02:07:21 <mm_freak> mornfall: well, using a state passing function gives you one advantage:  easier control of strictness
02:08:18 <mm_freak> > let gcd x 0 = x; gcd x y = let y' = mod x y in y' `seq` gcd y y' in gcd 12 15
02:08:19 <lambdabot>   3
02:08:20 <mornfall> Well, I did settle for the strict State monad in the end, IIRC.
02:08:34 <mm_freak> the strict state monad may not do what you think it does
02:09:12 <mornfall> Purely based on seeing a (rather slight) improvement in benchmarks. I don't particularly care.
02:09:27 <mornfall> Although I had to use strict RWST at some point to avoid a leak.
02:09:35 <mm_freak> well, consider this:
02:09:42 <mornfall> (Different story though.)
02:10:10 <mm_freak> > let counter 0 = return (); counter n = modify (+1); counter (n-1) in runState (counter 100) 0
02:10:11 <lambdabot>   <no location info>: parse error on input `in'
02:10:21 <mm_freak> > let counter 0 = return (); counter n = modify (+1) >> counter (n-1) in runState (counter 100) 0
02:10:22 <lambdabot>   ((),100)
02:10:24 <mm_freak> but:
02:10:31 <mm_freak> > let counter 0 = return (); counter n = modify (+1) >> counter (n-1) in runState (counter 10000000) 0
02:10:35 <lambdabot>   mueval-core: Time limit exceeded
02:10:44 <mm_freak> ok, it should give a stack overflow
02:11:19 <mm_freak> because it doesn't count like 0, 1, 2, 3, but like 0, 0+1, 0+1+1, 0+1+1+1, etc.
02:11:52 <mornfall> Yes, that's a common problem.
02:12:09 <mm_freak> it's not a "problem", it's the semantics of State
02:12:18 <mm_freak> often it makes sense
02:12:54 <mornfall> Well, it's a space leak, especially if it's not 0, 0 + 1 but x, modify x, modify (modify x) ... where original x has references to memory that modify x does not.
02:13:13 <mm_freak> 9
02:13:14 <mm_freak> 9
02:13:15 <mornfall> And it took a good deal of headscratching.
02:13:23 <mm_freak> uhm…  i'm failing to type this morning
02:13:36 <mm_freak> i've never used a strict state monad
02:13:45 <Phyx-> I hate rain
02:16:26 <mornfall> mm_freak: It seems that the difference is let v. case in >>=.
02:16:29 <mm_freak> but i seldomly use pure state monads anyway
02:16:37 <mm_freak> mostly i have StateT y m
02:16:41 <mm_freak> where m has IO at its bottom
02:16:42 <mornfall> Well, in this case it was StateT ... IO.
02:16:54 <mornfall> Or RWST ... IO.
02:17:06 <mm_freak> i don't like this RWST monad
02:17:21 <mm_freak> … transformer
02:17:25 <mornfall> Me neither.
02:17:31 <mornfall> But you know the deal with mtl and stacks.
02:17:32 <mm_freak> it always has a component i don't need
02:17:44 <mm_freak> well, i also don't use the MTL =)
02:17:57 <mm_freak> monadLib is my favorite right now
02:18:00 <mornfall> Right. So I was contemplating moving over to monadLib.
02:18:03 <mm_freak> (and for a long time actually)
02:19:08 <boris``> are there any suggested conventions for binding a list in an outer scope when that list is being recursed over in an inner scope?
02:19:36 <mornfall> boris``: Binding in what sense?
02:19:38 <boris``> that is, naming conventions for such a binding
02:20:02 <mornfall> I would probably go with x:xs in the inner scope and something meaningful in the outer. :)
02:20:11 <mornfall> Depends, really.
02:20:30 <mornfall> You *can* shadow the name, but apparently there are folks that don't like to do that.
02:20:34 <boris``> currently i've been doing f xs' = g xs' where g (x:xs) = ...
02:21:49 <mornfall> You colud say f list = ... or something more specific, if it's not actually [a].
02:22:46 <harlekin> Do Haskell programmers like Prolog? (:
02:23:14 <mornfall> harlekin: Well, they like Haskell more by definition. Sort of. :D
02:23:23 <kdvh> harlekin: i am learning it for an AI course... it is different.
02:24:03 <mornfall> IMHO, Prolog is a mess. If Haskell runtime behaviour is unclear, what can you say of prolog?
02:24:31 <mornfall> It's "likely EXPTIME, but no-one actually knows for sure what will happen in practice".
02:25:13 <tensorpudding> people on here have mentioned mercury as being better than prolog i think
02:25:42 <boris``> as a crash course in haskell, i wanted to implement a sufficiently complex data structure from scratch (a radix tree) -- would anyone be kind enough to give me style or best-practice advice? http://codepad.org/yyMRg1t4
02:26:09 <tensorpudding> as far as logic languages are concerned
02:27:27 <harlekin> But apart from performance issues with prolog, is it interesting as far as it goes for the mathematical background like Haskell?
02:27:35 * mornfall wonders what is the deal with haskell and radix trees aka tries...
02:27:42 <harlekin> It is all different from imperative programming, isn't it?
02:28:06 <mornfall> harlekin: It's completely remote to imperative programming, yes. You could say it's completely backwards.
02:30:05 <mornfall> harlekin: And with exptime, I don't mean just performance. Your programs could simply fail to terminate for very modest input sizes if you aren't careful.
02:30:56 <mornfall> boris``: It seems to be much complicated.
02:32:44 <harlekin> One more question: Without any knowledge at all, I suspend Scheme to be Haskell only not as cool as Haskell is. Would Haskellers agree? (:
02:33:08 <harlekin> s/suspend/suspect/
02:33:20 <mornfall> harlekin: Scheme doesn't have static types, is strict and is not pure.
02:33:29 <mornfall> And scheme doesn't have a syntax, either.
02:33:33 <harlekin> Thanks. That's enough. I'm choosing prolog. (:
02:33:37 <boris``> mornfall: yes, it seemed to be a bit hard to follow after i had finished, but inserting into a radix tree has a number of possible outcomes
02:33:48 <harlekin> Thank you very much for your input.
02:33:50 <Twey> Haskell's not much like Scheme at all, really.
02:34:09 <Twey> Prolog is interesting, but not too practical for most applications IME, though there are people who do crazy stuff with it.
02:34:43 <mornfall> boris``: Well, prolog is not very well typed, it's evaluation strategy is somewhat mysterious (due to unification and all) and it's not pure either.
02:34:45 <Twey> (its model is also rather broken — you often have to consider its rather convoluted evaluation model and insert impure operations like cuts to ensure termination and/or efficiency)
02:34:45 <boris``> mornfall: i'd like to think i could greatly simplify it with map or something, at the expense of some efficiency, but i wanted to write it in a way that would be no less efficient than a well-written imperative version
02:35:11 <mornfall> boris``: And is it?
02:35:27 <Twey> Using a map ‘or something’ will often be *more* efficient than explicit recursion.
02:35:41 <mornfall> Twey: Apart from the cases where it won't. :D
02:35:47 <mornfall> Which happens too.
02:35:49 <Twey> Apart from those, yes.
02:35:53 <boris``> Twey: in this case, i'm referring to performing an action on additional edges after the target edge at the current depth has been found
02:35:55 <Twey> But primitive functions can have magical optimisations.
02:36:12 <Twey> boris``: Laziness loves you
02:36:30 <Twey> If you don't use those values, the action never happened.
02:36:50 <mornfall> Twey: Yeah, but it still builds up debris.
02:36:59 <boris``> well, if i mapped one list of edges to a new, updated list i would be using all of the values
02:37:14 <Twey> boris``: Nope
02:37:30 <Twey> mornfall: True, but probably only a thunk
02:37:43 <mornfall> Twey: Well, it could be expensive too.
02:37:44 <Twey> (maybe a few thunks, but probably not too many)
02:37:44 <mornfall> Anyway.
02:38:21 <mornfall> boris``: If you are after actual performance, you should be using arrays and not lists for the successors and probably packed strings for the key bits.
02:38:29 <boris``> Twey: pretend, for instance, that immediately after i insert a key-value, i print the entire tree
02:38:48 <mornfall> boris``: That's going to be O(n) no matter what, though.
02:38:55 <mornfall> boris``: So the operation amortises.
02:39:07 <boris``> mornfall: well, i'm not really trying to micro-optimize, i just want to avoid excessive operations
02:39:56 <mornfall> boris``: For a trie (which is simpler than radix tree, admittedly) you can say:
02:39:58 <mornfall> add [] comm t = t { commonness = Just comm }
02:39:59 <mornfall> add (k:ks) comm t = t { children = mod : filter ((/=k) . fst) (children t) }
02:40:00 <mornfall>   where mod = (k, add ks comm (maybe trie (add ks comm) (lookup k $ children t)))
02:40:32 <mornfall> Well, that commonness is actually the value associated with the key.
02:42:05 <mornfall> For trie, it's actually O(|key|), which probably wouldn't work for radix trees.
02:42:43 <mornfall> The implementation is also somewhat self-optimising, in that recently modified keys are near to the head of the child list.
02:42:54 <Twey> Abs key?
02:43:21 <mornfall> Twey: Length of the key.
02:43:26 <Twey> Oh, right
02:45:07 <boris``> mornfall: yes, this particular naive radix tree implementation requires at most sum(i = 1 .. n edges, length prefix(i)) operations at each vertex
02:45:33 <ddarius> Most logic languages are better than Prolog in theory but have no practical implementations.
02:46:18 <boris``> what i figured i could avoid by not using map are operations on prefixes in the list after when i've found the edge to traverse
02:47:00 <ddarius> lambdaProlog is about the only other logic language with a serious implementation.
02:47:04 <mornfall> boris``: I don't think that arguments make much sense without actually profiling/benchmarking the code. If you use library functions in a chain, they may get fused by the optimizer.
02:47:12 <ddarius> Mercury is a functional logic language.
02:48:18 <mamalujo> aren't there haskell libraries for logic programming that have comparable features, but faster implementations than Curry?
02:48:24 <objorn> Should I learn haskell first before I have unlearn everything?
02:48:51 <objorn> I'm just starting out programming, but I'm told there are no pointers and there are no for loops, which is the basic stuff I was taught to begin with
02:49:46 <objorn> I'm not that good of a programmer though, and it would be nice to become better. I would like to learn Haskell eventually, but I'm not sure I should continue reading about C if I'm going to disregard everything when I learn Haskell.
02:50:15 <mornfall> boris``: Basically, it's hard to argue about actual performance of strict, imperative code. It's much harder with lazy pure code.
02:50:17 <ddarius> objorn: What do you want to get out of programming, i.e. why are you learning it?
02:50:22 <objorn> My thought pattern is that I might learn best practices in Haskell, so I might want to learn it first.
02:50:32 <objorn> ddarius: Let me think about that.
02:51:02 <mornfall> ddarius: You are so cruel. :)
02:51:21 <objorn> ddarius: I guess I would like to be a decent programmer able to solve problems with any language using best practices.
02:51:39 <mamalujo> objorn: learning C is a usefull skill, but quite different from haskell
02:51:55 <ddarius> objorn: Do you want to be a professional programmer?  Do you want to use programming as a tool in some other pursuit?  Are you just curious?
02:53:06 <mornfall> I guess that picking Haskell first is a bit of a Burrito Fallacy.
02:53:10 <mm_freak> i switched to haskell from C…  you can do professional programming in both, but in commercial practice both are seldomly accepted and used, though you'll find C more often than haskell
02:53:21 <mm_freak> anyway, both are a valuable experience
02:53:54 <ddarius> If you are interested in programming in general, I would also recommend learning both as well as several other languages.
02:54:01 <mm_freak> C lets you touch the machine and memory, whereas haskell teaches you great paradigms and concepts
02:54:03 <mamalujo> and, most popular languages look a lot more like C than like haskell
02:54:21 <mornfall> I imagine for many of us, Haskell led us to "click" quite a few things into place, wrt. programming. Unfortunately, it's not guaranteed to work without substantial prior experience with programming in general.
02:54:32 <mornfall> mamalujo: That's quite decieving to.
02:54:46 <mornfall> mamalujo: If I hate something are C programs written in C++, or gods forbid, Java.
02:54:56 <mamalujo> good counter-point :)
02:54:58 <mornfall> +spelling & gramar
02:55:01 <ManateeLazyCat> mm_freak: Great point. :)
02:55:03 <mornfall> OMG!
02:55:05 <Twey> FORTH is nicer than C if you want to ‘touch the machine’.
02:55:21 <kremsera> asm ftw!
02:55:24 <earthy> forth is also slightly harder to wrap your mind around
02:55:28 <medfly> Twey, where did that man touch you?
02:55:30 <objorn> I have seven projects in mind, of those seven, I was planning on using Haskell, the Snap framework, once. The other projects consist of a search engine (web scraping using lxml and other python libs), a financial tool (web scrapers needed), a Blender extension (python is used here), another two other programs relying on scapers
02:55:31 <Twey> Also useful if you're planning to go that way
02:55:32 <ManateeLazyCat> Twey: Well, linux kernel is C. :)
02:56:03 <zygoloid> "Now then x86, show us on this replica CPU where he touched you"
02:56:03 <Twey> ManateeLazyCat: And Geogebra is Java… that doesn't mean it was a wise choice :þ
02:56:06 <mornfall> ManateeLazyCat: Linux kernel is a pile of junk, first of all. :D
02:56:08 <Twey> medfly: Haha
02:56:14 <kdvh> Twey: i had enough 'touching the machine' with assembly :P
02:56:26 <mornfall> ManateeLazyCat: Secondarily, it's a pile of C junk, as you correctly point out.
02:56:27 <Twey> earthy: Not sure I'd agree with that
02:56:40 <Twey> earthy: It's much simpler a language than C.
02:56:49 <kremsera> go with haskell
02:56:51 <mornfall> It's all okey as long as you touch the machine and not yourself.
02:56:55 <mm_freak> mamalujo: http://hackage.haskell.org/packages/archive/countable/0.1/doc/html/src/Data-Countable.html
02:56:59 <earthy> Twey: that does not mean easier to learn
02:57:00 <mm_freak> this is haskell code =)
02:57:16 <objorn> mornfall: What is a Burrito Fallacy?
02:57:19 <kremsera> youll learn c anyway later, but haskell shows you the cool tricks
02:57:33 <Twey> earthy: Sure it does.  Less rules to remember.
02:57:35 <earthy> basically, C is portable assembly, whereas Forth is stack expansion
02:57:37 <ManateeLazyCat> mornfall: Well, C junk can works well, isn't?
02:57:45 <mornfall> lambdabot: @where burrito
02:57:45 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
02:57:47 <earthy> (as I understand it)
02:58:02 <mm_freak> mamalujo: layout is strictly optional in haskell, but in general you want to use it
02:58:13 <earthy> so, C is in some sense 'closer' to the actual hardware than Forth is.
02:58:25 <earthy> which implies there is less of an impedance mismatch to get used to
02:58:27 <objorn> mm_freak: Haskell teaches you great paradigms? Doesn't Haskell only have on paradigm: functional programming?
02:58:28 <boris``> mornfall: yeah, i guess i'll just have to get used to that. would you at least agree that ignoring optimizations, using map or the like and then enumerating the tree would result in the maximum number of operations?
02:58:30 <Twey> earthy: (Low-level) FORTH is closer to assembly than C is
02:58:40 <mornfall> objorn: ^^ It's about how a realisation that X Is Like Burritos after a week of struggle doesn't mean that telling people that X Is Like Burritos will help them realise how X works.
02:58:48 <Twey> earthy: Most FORTH words can be translated directly into ~three instructions
02:58:50 <objorn> mornfall: Also, what is "wrt."
02:58:54 <mornfall> boris``: Not really.
02:58:58 <mornfall> objorn: wrt = with regards to
02:59:05 <mm_freak> as a side note i think C is more complicated than haskell
02:59:09 <Twey> I agree
02:59:10 <earthy> ghe. :)
02:59:17 <ManateeLazyCat> mm_freak: Of course.
02:59:24 <mornfall> mm_freak: In which sense?
02:59:36 <ManateeLazyCat> If you can play C, you can play any language...
02:59:37 <mm_freak> objorn: haskell has many paradigms, including functional and imperative programming
02:59:49 <mm_freak> mornfall: syntax and stuff you need to memorize
02:59:50 <Twey> earthy: Popular FORTH environments include a decompiler for inspection.
02:59:56 * earthy nods
02:59:56 <kdvh> The thing with haskell is, i find it much more difficult to write non trivial stuff than using java/c#... and i am pretty new to those as well. maybe it is just me.
03:00:07 <mm_freak> mornfall: for example i can't write a single useful program in C without looking up man pages all the time
03:00:09 <earthy> I should go play with Forth more. :)
03:00:10 <mm_freak> in haskell i can
03:00:10 <Twey> ManateeLazyCat: Nonsense
03:00:18 <ddarius> Forth is quite a bit more low-level than C.
03:00:20 <Twey> earthy: Yeah.  ☺
03:00:30 <mornfall> mm_freak: Does firing up ghci and using :t count as manpage equivalent? :)
03:00:34 <ManateeLazyCat> Twey: Example?
03:00:37 <mm_freak> in fact i can write an entire IRC server in haskell without looking into documentation even once
03:00:38 <Twey> ddarius: Well, its foundations are.  It also has the capacity for being higher-level.
03:00:48 <mm_freak> mornfall: not really =)
03:00:50 <earthy> maybe design a GA144-based home-automation system once I've moved into our house-to-be-built. :)
03:00:50 <Twey> ManateeLazyCat: Learning C doesn't enable you to work in any language at all.
03:00:51 <mornfall> mm_freak: (I have no idea where that "count" came from...)
03:00:57 <ManateeLazyCat> mm_freak: Well, you have build fastirc, you should know the detail of RFC.
03:01:07 <Twey> ManateeLazyCat: Not even as many as learning e.g. Scheme would, because you don't get nearly so much understanding of the underlying concepts.
03:01:18 <mm_freak> ManateeLazyCat: yes, but i don't need to look into haskell/library documentation
03:01:21 <Twey> Need to run to college, though.  See y'all a little later o/
03:01:28 <ManateeLazyCat> Twey: Just personal point, never mind. ;p
03:01:37 <ManateeLazyCat> Twey: No more debate. :)
03:01:44 <mornfall> Dudes, try to not make me laugh too much. It's not a good style to laugh when attending a talk.
03:01:46 <mm_freak> in haskell i have to look, what arguments are needed in what order, what side effects the function has and what it returns
03:01:48 <mornfall> : - P
03:01:49 <mm_freak> uhm
03:01:51 <mm_freak> in C i mean
03:02:03 <mm_freak> in haskell i don't have to, because the type makes most of this clear
03:02:06 <boris``> well, there's a very large amount of information required to write syntactically and semantically correct C programs
03:02:46 <mornfall> boris``: You can leave out "C" and it still holds.
03:03:02 <mornfall> Maybe throw in nontrivial instead.
03:03:27 <kremsera> in haskell a lot more programs classify as trivial ;)
03:03:36 <kremsera> e.g. compilers
03:03:44 <mm_freak> yeah
03:03:46 * ManateeLazyCat Bye all! :)
03:03:47 <mm_freak> that's my point
03:03:49 <boris``> mornfall: what i mean is, even if you know exactly what you want to do, there's a good chance you will get it wrong unless you have a large amount of additional information about how to write it correctly in C
03:04:13 <mm_freak> boris``: i agree
03:04:24 <ddarius> mornfall: At least for syntax, Jot makes making syntactically correct programs trivial.
03:04:36 <mm_freak> mostly because C uses side effects extensively
03:04:38 <mornfall> Well, I would argue that C itself is quite trivial.
03:04:59 <mornfall> But the library is awful, partially due to the said triviality of the language.
03:05:16 <mm_freak> and also because C has a poor type system
03:05:20 * ddarius should write a Forth in x86 assembly.  That should scratch two itches at the same time.
03:05:27 <mm_freak> just note what an Either would look like in C
03:05:30 <boris``> the complexity comes from the vast amount of non-portable behavior
03:05:37 <mornfall> mm_freak: Well, it seems to be a wild extension of no type system. :D
03:05:39 <mm_freak> or how functions signify failing
03:05:50 <mm_freak> (returning -1 or 0, depending on context and function)
03:06:10 <boris``> . o O (C has a strong type system)
03:06:18 <mm_freak> mornfall: you don't necessarily need polymorphism and ADTs for something to be a type system =)
03:06:20 <mornfall> mm_freak: That Either is not as much a problem of type system as it is of memory management, IMHO.
03:06:39 <mm_freak> boris``: C's type system is weak, but it's static
03:06:41 <mornfall> mm_freak: Afterall, you can have discriminated unions in C.
03:06:46 <mm_freak> (int) 0.1
03:07:07 <mm_freak> mornfall: yes, and an int, which tells you, whether it is left or right =)
03:07:11 <boris``> mm_freak: many people think it's weak because they confuse correctly written C programs with what gcc will compile
03:07:14 <mornfall> mm_freak: No, I mean that the C type system seems to be an adhoc extension of assembler.
03:07:28 * ddarius doesn't really like the way Forth handles control structures.
03:07:52 <mm_freak> mornfall: well i don't know whether you can say that assembler has a type system at all, but C definitely has
03:08:05 <kremsera> haskell uses c as assembler ;)
03:08:08 <mornfall> mm_freak: Exactly.
03:08:08 <objorn> The only person to give me a direct response was kremsera who said "go with haskell"
03:08:14 <mm_freak> boris``: standard C will compile (int) 0.1 just fine
03:08:34 <boris``> mm_freak: as it should, that has a well-defined result
03:08:46 <mm_freak> objorn: i agree with kremsera
03:08:48 <objorn> From what I gather, learning languages before Haskell will give me a deeper appreciation for the language
03:09:04 <mm_freak> objorn: learn C afterwards, because to learn haskell you may have to unlearn C
03:09:11 <medfly> the first language I was any good at was Haskell
03:09:11 <mornfall> objorn: Well, I don't think you can screw up too bad by taking Haskell first.
03:09:12 <mm_freak> the converse isn't true
03:09:37 <medfly> I don't see much implications to that other than, I seem to find it less freakishly unusual than other people.
03:09:38 <objorn> Or maybe it will give me a deeper appreciation if I first become accustomed to Haskell way of programming and then learn another 
03:09:39 <mm_freak> you'll just find that C is very poor =)
03:09:46 <kdvh> objorn: that is if you know an imperative language and then try haskell. You will go "wow, this is so usefull, why cant i do this in (x)?"
03:09:55 <mornfall> mm_freak: But it's true that you'll be pulling a lot of hair when learning C. Knowing that this is not an inherent programming problem (due to knowing Haskell) will probably only make that worse. :)
03:10:17 <kremsera> objorn, when using haskell - you get used to do things that are just difficult in other languages
03:10:28 <medfly> I didn't pull a lot of hair when learning C, after Haskell.
03:10:31 <kremsera> e.g. design patterns like strategy
03:10:33 <lantti> I would recommend making yourself clear the difference between programming and programming languages.
03:10:36 <medfly> I even find PHP tolerable. 
03:10:39 <medfly> but then again, I am not spoiled.
03:10:55 <mm_freak> IMO PHP sucks in all ways it can
03:11:05 <objorn> lantti: Can you make it clear for me?
03:11:06 <mm_freak> i'd happily prefer C over PHP
03:11:10 <lantti> If you learn the basic theory of what you are doing, then the tools matter less.
03:11:14 <mornfall> medfly: I think that finding bad languages to be intolerable is a valuable trait in programmers.
03:11:17 <objorn> Ah
03:11:25 <mm_freak> (although since PHP 5.3 it has closures, which C still lacks)
03:11:26 <objorn> lantti: Best way to do this?
03:11:50 <boris``> mm_freak: by design, C will never have true closures
03:11:59 <objorn> Structure and Interpretation of Computer Programs?
03:12:04 <mm_freak> lantti: i've written a parser monad in C#…  the tools did matter…  monadic parsing in C# is very inconvenient
03:12:06 <boris``> i could see them adding anonymous functions, maybe
03:12:12 <objorn> Or is there a similar book like this for Haskell?
03:12:12 <lantti> Start reading about algorithms and information science at the same time you start programming.
03:12:25 <mm_freak> boris``: anonymous functions would suffice for most things
03:12:37 <boris``> mm_freak: agreed, i wish they were there too
03:12:39 <medfly> mornfall, I dunno. I just don't complain about things as easily
03:12:53 <objorn> lantti: If you could suggests some material, I would greatly appreciate it. It's all new to me, and I want to know the theory, like you mention, of what I'm learning
03:12:56 <mm_freak> boris``: btw, GCC supports lexically scoped functions as an extension, which is useful to some degree, but requires an executable stack
03:13:06 <lantti> mm_freak: for sure some tools are better adapted for some tasks.
03:13:16 <boris``> mm_freak: of course it does, gcc supports a whole bunch of shit that isn't C
03:13:24 <mornfall> mm_freak: With monadic, do you mean recursive-descent?
03:13:26 <lantti> I have not met the ultimate all-general programming method yet.
03:13:28 <mm_freak> boris``: http://ertes.de/techblog/2008-11-17-2-obscure-c.html
03:13:39 <mm_freak> mornfall: i mean using a state monad under the hood
03:13:51 <kdvh> objorn: read up some stuff on data structures and algorithms that are commonly used, i guess that is a start.
03:14:42 <kremsera> well SICP is not bad either ;)
03:15:00 <objorn> From what little I know, C requires me to understand data structures immediately and Haskell makes me think differently, by not using pointers and using something else, queues or something.
03:15:04 <kremsera> luckily there is a book for algorithms in haskell :)
03:15:09 <objorn> kremsera: !
03:15:13 <objorn> awesome, what is it?
03:15:34 <mm_freak> objorn: C requires you to understand memory better, not data structures
03:15:45 <mm_freak> in fact haskell is more data structure-heavy than C
03:16:12 <objorn> mm_freak: This is wonderful news.
03:16:30 <mornfall> mm_freak: That depends on what you mean with structures.
03:16:32 <objorn> Where is this book you mention kremsera?
03:16:39 <boris``> the one thing that C will help you learn best is pedantry
03:16:40 <mornfall> mm_freak: You don't need to know how a list is implemented to work with it in Haskell.
03:16:47 <mornfall> mm_freak: You do in C (because you have to implement it yourself).
03:16:54 <kremsera> objorn, one moment - i forgot the title ;)
03:17:10 <mm_freak> mornfall: yes, but you need to know what a list is and why you shouldn't use random access with it =)
03:17:26 <mm_freak> in C you just make an array as a beginner
03:17:31 <mornfall> mm_freak: Indeed.
03:17:36 <mm_freak> only experienced programmers make list structures themselves
03:17:43 <mornfall> mm_freak: Is that so?
03:17:53 <mornfall> mm_freak: It seems that Linux is full of lists where arrays would fit better.
03:18:02 <boris``> coming from another language, it's easy to see that C arrays don't cut it for anything dynamic
03:18:17 <mm_freak> in general, yes…  most books i've seen also introduce arrays very early and it is used as a list
03:18:27 <mornfall> boris``: Coming from C++, I don't see why people insist on using lists where vectors are much more appropriate.
03:18:43 <mornfall> boris``: In C, that is.
03:18:52 <lantti> I fully agree that C is the hard way to start as it makes no effort to help you along. But getting only Haskell-model of programming to your head is a restriction too.
03:18:59 <boris``> mornfall: well, C++ is far worse than even C
03:19:05 <mornfall> boris``: Huh?
03:19:09 <mornfall> In what sense exactly? :)
03:19:14 <mornfall> I find it to be by far superior to C.
03:19:35 <boris``> mornfall: it is immensely more complex and convoluted than C
03:19:38 <mornfall> It's not exactly Haskell, but in the imperative mainstream land, it's as close as it gets.
03:19:44 <copumpkin> oh noes, language wars in #haskell
03:19:48 <copumpkin> this is unexpected
03:19:51 <lantti> Well C is a minimal language, that must be said. It is quite effortless to understand. But tricky to use.
03:19:52 <mm_freak> in beginner books, "read and save integers from the terminal, until an empty line is input" = make a large array and save the integers there
03:20:13 <mornfall> mm_freak: And hope that you don't overflow. I see.
03:20:22 <mm_freak> mornfall: yeah
03:20:25 <mornfall> mm_freak: That would explain a whole lot of crap software.
03:20:30 <mm_freak> mornfall: it does
03:20:33 <mamalujo> copumpkin, not a war yet, we have to see if a civil discussion escalates :)
03:20:46 <objorn> kremsera: Any luck?
03:20:50 <mm_freak> because most people use this approach even in other languages, where you actually have the proper data structures
03:20:53 <boris``> mm_freak: there are a huge number of very bad C books :)
03:21:18 <mm_freak> boris``: i judge based on whether they talk about recursion as something bad or at all =)
03:21:37 <mornfall> Why they put tutorials first in conferences? I always get spoilt by the (often very good) lectures, and can't bear the rest of the conference...
03:21:43 <boris``> mm_freak: well, scaling recursion in C is a mistake
03:22:02 <mm_freak> boris``: i know
03:22:15 <mornfall> mm_freak: Well, I love how tail calls in gcc with -O0 run out of stack, but work with -O.
03:22:29 <mm_freak> boris``: but not understanding recursion is why many people are turned off of FP languages
03:22:47 <mm_freak> mornfall: nobody uses -O0 in C
03:22:51 <mornfall> mm_freak: (I often find tail recursion to be more elegant than wrapping a function in while(...).)
03:22:59 <mornfall> mm_freak: Ever tried to debug anything? :))
03:23:00 <mm_freak> mornfall: btw, the TCO is quite new in GCC
03:23:01 <qz> mm_freak, because FP languages are hard (
03:23:11 <mm_freak> mornfall: good point =)
03:23:20 <mornfall> mm_freak: Quite new as in, about a decade?
03:23:21 <mm_freak> qz: they're different, not hard
03:23:46 <mm_freak> mornfall: when i wrote the above code, it wasn't there
03:23:55 <mm_freak> it was in november 2008
03:24:07 <mornfall> Huh.
03:24:37 <qz> mm_freak, yeah sure, there's over 9000 expanations of what monad is in haskell. must be a sign its not too easy 
03:24:45 <mornfall> mm_freak: I am fairly sure it worked back in 2000.
03:24:52 <kremsera> objorn, sorry cant find it now - but purely functional datastructures by chris okasaki is not that bad
03:24:58 <mornfall> mm_freak: See eg. http://compilers.iecc.com/comparch/article/00-08-101
03:25:14 <boris``> it's probably worth noting that gcc is a plague and shouldn't be relied upon to test C code for validity
03:25:22 <mornfall> mm_freak: It worked in 2.95 even.
03:25:30 <objorn> What is scaling recursion (in the C language), and why is it a mistake?
03:25:33 <mm_freak> mornfall: oh, i see where my mistake comes from
03:25:37 <mm_freak> i used --std=c99
03:25:37 <kdvh> kremsera: i was interested in this as well, the book i use only has pseudocode implementations. =[
03:25:48 <mm_freak> if you specify a standard, then TCO is disabled
03:25:54 <mm_freak> (for whatever reason)
03:26:14 <mm_freak> qz: because 8000 of them suck
03:26:14 <mornfall> mm_freak: It might be in conflict with something that the standard demands.
03:26:25 <mornfall> mm_freak: Which probably no-one cares about anyway.
03:26:35 <mm_freak> mornfall: i see
03:26:37 <kremsera> ill search for it this evening - than i post the name here
03:26:37 <mm_freak> that's useful…
03:26:38 <qz> mm_freak, could you please point at good one? 
03:26:40 <boris``> mm_freak: no C standard makes any guarantee about TCO
03:26:50 <Zao> Total Cost of Ownership.
03:26:52 <qz> i'd love to finally understand it =p
03:26:57 <objorn> kremsera: Purely Functional Datastructures by Chris Okasaki, is that the book you were referencing previously?
03:27:01 <mm_freak> qz: the two tutorials written by Cale on the haskellwiki
03:27:08 <qz> mm_freak, okay
03:27:24 <kdvh> kremsera: alright, i might be afk so leave a msg, please. =]
03:27:45 <mm_freak> qz: or you may want to try mine, for which i received a lot of positive feedback =)
03:27:48 <mornfall> boris``: We know it's not guaranteed. It's still nice to have if you know your compiler can do it.
03:27:56 <qz> mm_freak, where's it? ;)
03:28:10 <mm_freak> qz: http://ertes.de/articles/monads.html
03:28:23 <qz> thanks
03:28:47 <mm_freak> you're welcome…  but mine is long…  if you just want a quick intro, use Cale's stuff
03:28:53 <mornfall> By any chance, is anyone here attending SEFM 2010 in Pisa at this time? : - )
03:29:15 <boris``> mornfall: that's fine as long as you understand that you're writing in a language that is different from C
03:29:24 <nominolo> preflex: seen jpmoresmau
03:29:24 <preflex>  Sorry, I haven't seen jpmoresmau
03:30:49 <objorn> Does Haskell offer true templates and metaprogramming?
03:31:29 <earthy> not in Haskell'98
03:31:38 <objorn> Is it possible for OOP in Haskell as well?
03:31:49 <objorn> earthy: It doesn't offer either?
03:31:56 <kremsera> true template metaprogramming = Template Haskell
03:31:59 <kremsera> GODLIKE
03:31:59 <tensorpudding> there is template haskell
03:32:07 <Zao> TH is all kinds of scary and awesome.
03:32:14 <kremsera> I use Template Haskell quite heavily
03:32:16 <copumpkin> you get most of what you use C++ templates for in other type features in haskell
03:32:22 <copumpkin> TH isn't very common in most code
03:32:37 <tensorpudding> but it's not like Lisp metaprogramming
03:32:48 <kremsera> still 1000x better than c++ templates
03:33:00 <copumpkin> I wouldn't equate TH with c++ templates at all
03:33:11 <tensorpudding> it's substantially more foreign-seeming
03:33:20 <Zao> copumpkin: Only thing they share really is the word "template"
03:33:25 <copumpkin> c++ templates = haskell's type system, but haskell's type system is better
03:33:39 <kremsera> well one can do similiar things
03:33:43 <mm_freak> objorn: in general you need neither template metaprogramming nor OOP in haskell
03:33:49 <mm_freak> the former is available as a few have noted
03:33:51 <tensorpudding> what OOP in haskell would be like, i do not know
03:34:05 <lantti> objorn: Haskell is not very good for expressing OOP constructs.
03:34:06 <mm_freak> the latter can be encoded in haskell to a certain extent
03:34:10 <tensorpudding> there's that O'Haskell thing
03:34:13 <ddarius> copumpkin: There are many things you can do with C++ templates that you can't do with Haskell.  Though there are some somewhat unexpected things you can do with templates that you can do with Haskell.
03:34:22 <tensorpudding> but it's dead dead
03:34:25 <mm_freak> but nobody cared to add OOP to haskell, and the few OOP-supporting dialects of haskell never got much attention
03:34:37 <ddarius> tensorpudding: It became Timber.
03:34:50 <kremsera> if one really cares for OOP one can take a look at scala
03:35:06 <Cale> With extensions, Haskell's type system is as powerful as C++ templates.
03:35:14 <copumpkin> ddarius: like what? I thought the main thing was associated types, and that was added recently
03:35:19 <copumpkin> except for numeric literals
03:35:21 <copumpkin> in types
03:35:23 <tensorpudding> does it really count as "haskell with OOP" anymore?
03:35:52 <ddarius> tensorpudding: Not really, no.
03:35:58 <tensorpudding> it doesn't even have laziness
03:35:59 <mamalujo> OOHaskell library?
03:36:02 <copumpkin> oh no
03:36:06 <copumpkin> now people will flock to it
03:36:45 <tensorpudding> there was a paper on LtU about combining objects with ADT's
03:36:49 <tensorpudding> a few months ago
03:36:57 <Cale> You can approximate OO in Haskell well enough, depending on exactly what you consider OO to be.
03:37:03 <tensorpudding> the examples were in SML
03:37:17 <kremsera> i dont see why one needs OO at all
03:37:23 <kremsera> its essentially state driven
03:38:18 <mamalujo> class aliases would make some oo idioms quite natural in haskell
03:38:49 <Cale> To me, OO is about defining values based on the operations that can be applied to them
03:39:10 <ddarius> There are more things in OOP, kremsera, than are dreamt of in your philosophy.
03:39:11 <kremsera> its about coupling state and functions
03:40:15 <kremsera> ddarius, what do you mean?
03:40:25 <Cale> It's not really necessarily anything to do with state, but rather the kind of polymorphism which is obtained by "forgetting" or "hiding" the implementation of a piece of data and only exposing the operations on it.
03:40:30 <lantti> One way (my way) to start learning programming would also be to play around with state-machines and ASM with an emulator for a simple RISC microprocessor like AVR just to get a feel of the problems all these fancy paradigms are aimed to solve :). 
03:40:35 <Cale> (at least in my mind)
03:41:10 <ddarius> kremsera: 1) There is a lot more to OO than that and 2) what people put under the rubric of "OO" is way more varied than that.
03:41:28 <lantti> After all in the beginning you often like to produce simple code to give simple results.
03:41:44 <ddarius> Actually, taking the most common "PIE" view of OOP, it says nothing at all about state except passingly with respect to encapsulation.
03:42:07 <Cale> Smalltalk is a dynamically typed language, but informally one still has to think about the types of objects, and the type of an object is essentially the set of messages that it understands (along with their types)
03:42:09 <kdvh> Cale: messing with an Atmel board is definately fun. =P
03:43:12 <kdvh> whoops, meant lantti >.<
03:44:30 <tomberek> hey,i just came up with this, but there must be a Prelude version
03:44:30 <lambdabot> tomberek: You have 10 new messages. '/msg lambdabot @messages' to read them.
03:44:32 <tomberek> onAny :: (a->Bool) -> (a->a) -> [a] -> [a] onAny f g as as' = map (\a-> if f a then g a else a) as
03:44:51 <Cale> A lot of the statically typed OO languages seem to confuse things a lot by forcing programmers to put method definitions into *classes* (data type declarations), rather than where they belong in *objects*
03:45:16 <objorn> What tasks is the OOP paradigm best at tackling?
03:46:02 <Zao> objorn: Object-oriented scenarios :D
03:46:05 <kalven> Cale: how does it confuse things?
03:46:18 <tomberek> anyone?
03:46:23 <Cale> kalven: Because it obscures what objects are, in a way.
03:46:34 <ddarius> tomberek: I recommend a variant with a single (a -> Maybe a) function rather than (a -> Bool) and (a -> a).
03:47:05 <tomberek> ddarius: ok, though I'm sure there's something like this already,, an adjust?
03:47:20 <Cale> An object is the way in which it responds to messages, or to use a different terminology, the manner in which its methods operate.
03:48:50 <ddarius> :t map . (flip fromMaybe .)
03:48:52 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b -> b]
03:49:01 <ddarius> :t map . flip fromMaybe
03:49:02 <lambdabot> forall a. Maybe a -> [a] -> [a]
03:49:39 <ddarius> :t fromMaybe
03:49:40 <lambdabot> forall a. a -> Maybe a -> a
03:49:47 <ddarius> Ah.
03:49:54 <ddarius> :t map . flip maybe
03:49:55 <lambdabot> forall a a1. (a1 -> a) -> [a] -> [Maybe a1 -> a]
03:50:17 <Cale> I mean, that's the whole point -- to hide the implementation and only expose the methods, and thereby gain a lot of freedom in that all the possible ways of implementing those methods give rise to values (objects) which can be treated in a uniform way -- as a single type.
03:51:04 <tomberek> eh,, i just want something to scan through a list, and when the boolean is true, to change that value (and maybe even return a ([a],Bool) afterwards where the Bool signifies if the update was applied)
03:51:05 * ddarius thinks what OOP should be is the style of programming that naturally arises in message passing concurrency.
03:52:44 <kremsera> you mean active objects ?
03:53:01 <lantti> objorn: There is generally no agreement what OOP means, so you might get a lot of different answers with that one... :)
03:54:16 <ddarius> kremsera: No.  Active objects are what you get when you start from (current) OOP and add concurrency.  I mean code that looks like Erlang code.
03:55:12 <kremsera> ddarius, i thought actors and active objects where synonyms ;)
03:55:16 <tomberek> what is the standard way to refactor    f (a:as) = g a : f as  to use tail recursion?
03:55:31 <kremsera> map ;)
03:55:37 <ddarius> kremsera: No one has said anything about Actors.
03:55:50 <ddarius> tomberek: Not to.
03:56:32 <tomberek> kremsera, ddarius: hm, well, i'm really wanting f (a:as) x = g a : f as x
03:56:51 <ddarius> tomberek: So?  That code is fine.
03:57:05 <tomberek> but that will build up a thunk, right?
03:57:14 <tomberek> so on a long list, stack overflow?
03:57:18 <ddarius> tomberek: No.
03:57:21 <copumpkin> nah, you can lazily consume it
03:57:41 <copumpkin> laziness complicates the whole "tail recursion is the only efficient way to recurse" idea
03:57:46 <tomberek> ah, so then I can just stick with that
03:58:10 <tomberek> sweet, i guess i try to overcomplicate
03:58:41 <Cale> tomberek: In fact, tail recursion is bad without strictness. If you want to write something in a tail recursive way, you often need to add strictness to it so that you don't build up large unevaluated expressions in the parameters
03:59:02 <tomberek> copumpkin,, is that general scheme usually an "efficient way to recurse"?
03:59:31 <copumpkin> tomberek: definitely, if you can lazily produce something that's generally a good sign
03:59:39 <tomberek> excellent!
03:59:41 <ddarius> tomberek: Simply unfold evaluation using call-by-name evaluation order by hand and it will be quite clear to you what is and is not efficient.
04:00:12 <tomberek> ddarius,, uh.. not sure how to do that unfolding..
04:00:19 <ddarius> tomberek: There's your problem.
04:00:23 <tomberek> hehe
04:00:59 <tomberek> is it like this ?   g a : f as x   becomes    g a : g (head as) : f (tail as) x
04:01:08 <tomberek> and so on
04:01:10 <ddarius> No
04:01:16 <ddarius> Er, yes.
04:01:29 <ddarius> Er no.
04:01:30 <tomberek> but with fixed (:) operation
04:01:39 <ddarius> I misread what you wrote and then just made a mistake.
04:02:16 <ddarius> Call-by-name evaluation order is an order by which to choose what to evaluate next, so there are relatively specific ways of reducing.
04:02:47 <ddarius> g a : f as x is in weak head normal form and thus doesn't evaluate (reduce) at all.
04:03:37 <tomberek> ddarius, ok, so then how do I do the unfolding to see efficiency vs slow-as-hell?
04:04:51 <ddarius> All you have to do to unfold call-by-name evaluation is reduce outside in.  I.e, to steal Cale's example, say you have double x = x + x, you simply evaluated double (1+1) -> (1+1) + (1+1) -> 2+2 -> 4 rather than the call-by-value way most languages use double (1+1) -> double 2 -> 2+2 -> 4.
04:05:29 <ddarius> Haskell does some sharing to avoid the recomputation in the first example, and that can be important for some efficiency concerns, but it mostly doesn't matter for stack usage concerns.
04:05:53 <copumpkin> "Medium term: GHC 7.2: dynamic linking by default, and use system linker"
04:06:27 <copumpkin> straight from The Man Himself
04:07:25 <ddarius> Simon Marlow?
04:07:45 <copumpkin> the other one
04:07:56 <ddarius> Simon Marlow the RTS one which I would think would deal with linking.
04:08:22 <copumpkin> http://snapplr.com/r6m3
04:08:24 <Zao> copumpkin: In the context of "aaaargh, GHC doesn't build on OS X", one might add
04:08:29 <copumpkin> :P
04:09:22 <Zao> Too bad that it's not the proper "system linker" on Windows, but mingw shenanigans :(
04:09:56 <ManateeIrcClient> copumpkin: Use dynamic linking default?
04:10:17 <copumpkin> Zao: you should fix that! :P
04:10:19 <Zao> ManateeIrcClient: Of runtime and libraries.
04:10:29 <Zao> copumpkin: Trivial, I'm sure.
04:10:50 <Zao> MSVC-compatible object files would be quite sweet though.
04:11:09 <Zao> Quite annoying to have to go via a DLL if you want to consume Haskell.
04:13:00 <fasta> Zao, how well is the format documented?
04:14:15 <Zao> fasta: Considering that mingw can partially consume some types of .lib files, I'd expect it to be slightly documented somewhere.
04:14:33 <Zao> Also, considering that the GHC team is at MSR and all, I'm sure they could shake up some proper documentation.
04:14:33 <fasta> http://www.microsoft.com/whdc/system/platform/firmware/pecoff.mspx
04:14:48 <fasta> You need to hand over your soul to read it, I suppose.
04:14:58 <fasta> I am not going to read all that legalese right now. 
04:15:53 <Zeiris> Is lazy IO = bad?
04:15:57 <fasta> Actually, it is not that much, but putting that on an object format is ridiculous. They are just numbers encoding programs, like Godel did in the 1930s. 
04:16:13 <mm_freak> Zeiris: flawed
04:16:20 <Zao> Zeiris: Depends, but it has the risks of having files open for too long.
04:16:41 <fasta> Zeiris, if you know exactly what you are doing, it can be good. 
04:16:51 <ddarius> You can find plenty of PE and COFF information on the internet.
04:17:03 <mm_freak> you can't be sure when the FD is closed, and also you can't handle errors
04:17:17 <mm_freak> lazy IO is good for quick-n-dirty stuff, but should be avoided in production
04:17:43 <Zeiris> I've been having unintuitive bugs with it, and having trouble understanding where my code will actually -do- IO. I wasn't sure whether that was my fault 100%, or just a flawed technique.
04:18:18 <mm_freak> at least a flawed technique, but i might by your fault as well =)
04:19:35 <mm_freak> Zeiris: the popular method is to use iteratees, but honestly i don't understand (the implementations of) them
04:19:39 <Zeiris> It might be me trying to use lists as infinite streams of data as well. I have the suspicion something's missing with that.
04:19:48 <mm_freak> another useful method is using a suitable parser library like attoparsec
04:20:14 <mm_freak> well, a lazily read file of course doesn't give you an infinite list
04:20:23 <mm_freak> but reading /dev/urandom might
04:20:34 <Zeiris> Well, reading stdin might.
04:20:59 <Zeiris> But parsing that list of lines, into a list of objects, then reducing/grouping those objects seems to be more headache than I thought it would be.
04:21:34 <mm_freak> it shouldn't be, depending on the complexity of your objects
04:21:49 <copumpkin> there's a PE reader on hackage
04:22:00 <copumpkin> Zao
04:22:10 <copumpkin> you should put a writer component in, and then use that :)
04:23:03 <mietek> What's the LANGUAGE switch to turn on strict field unboxing?
04:23:18 <ddarius> Writing file formats is (usually) -much- easier than reading them.
04:23:19 <mietek> I thought it was UnboxStrictFields
04:23:32 <copumpkin> http://hackage.haskell.org/package/pecoff
04:23:41 <copumpkin> it isn't a language switch
04:23:45 <mm_freak> isn't a strict field "unboxed" anyway?
04:23:47 <copumpkin> (as it doesn't affect the language)
04:23:51 <copumpkin> -funbox-strict-field
04:23:56 <copumpkin> s
04:24:05 * sioraiocht still always reads that as "funbox"
04:24:07 <mietek> copumpkin: ah, so it's a GHC_OPTION?
04:24:09 <copumpkin> or you can put a pragma {-# UNPACK #-} or something
04:24:12 <mietek> sioraiocht: me too
04:24:12 <copumpkin> mietek: yeah
04:24:20 <mm_freak> funbox =)
04:24:58 <mm_freak> so a strict field is still a thunk of its own?
04:25:22 <mm_freak> even with -O2?
04:25:37 <copumpkin> well, it's represented as a pointer
04:25:38 <copumpkin> but yeah
04:25:42 <copumpkin> sometimes you want sharing
04:25:48 <copumpkin> unboxing stops that
04:27:14 <lantti> Heh. At my uni they had a nice intro for the modular electronics course. To demonstrate the benefits of modular hard- and software each student must design, build and test a new model of a mobile phone for themselves. It all fits in the intro :)
04:27:35 <copumpkin> it also can't unbox polymorphic strict fields
04:27:41 <copumpkin> (obviously)
04:27:54 <copumpkin> maybe LHC or JHC will be able to :)
04:28:14 <mm_freak> copumpkin: i see
04:28:36 <zygoloid> copumpkin: i don't see why it shouldn't be able to unbox the /last/ polymorphic strict field in any particular type :)
04:29:05 <copumpkin> zygoloid: how would it figure out the allocation size?
04:29:18 <copumpkin> I guess it would need a more complex system
04:29:28 <zygoloid> copumpkin: you know the type at the point where you create the object, since the field is strict
04:29:41 <zygoloid> at least... i think so?
04:29:47 <copumpkin> hm
04:30:08 <copumpkin> I guess
04:30:20 <copumpkin> you should see what the #ghc folks think about it :)
04:30:49 * zygoloid thinks a simple cost-benefit analysis would show it's a crazy idea
04:31:44 <copumpkin> probably :)
04:31:59 <mm_freak> hmm, CPS-based state monads are actually more flexible than the traditional ones
04:32:37 <mm_freak> intuitive proof:  execStateT can only work for specific computations, otherwise it won't typecheck
04:33:22 <mm_freak> but they are already more flexible in that they support aborting/restarting computations, i.e. exceptions and goto
04:35:28 <objorn> mm_freak: If Haskell is imperative, you may want to edit the sidebar of the Wikipedia article on the language
04:36:57 <mm_freak> objorn: haskell is a multiparadigm language, but its main paradigm is functional programming
04:37:46 <mm_freak> you can just as well do:  main = do var <- newIORef 0; modifyIORef var (+1); readIORef var >>= print
04:37:50 <copumpkin> preflex: seen erikc
04:37:51 <preflex>  erikc was last seen on #haskell 28 days, 8 hours, 15 minutes and 34 seconds ago, saying: ive done similar things in c++
04:56:27 <mm_freak> the Cont monad is often said to be the mother of all monads, because it can encode all kinds of control flow
04:56:45 <mm_freak> is this really true?  i mean, how can you write [] in terms of Cont?  don't you need multiple continuations for that?
04:56:49 <mm_freak> Cont supports only one
04:57:06 <mm_freak> or a more interesting (>>=)?
05:00:31 <roconnor> @quote haiku
05:00:31 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
05:00:34 <roconnor> @quote haiku
05:00:35 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
05:00:38 <roconnor> @quote haiku
05:00:38 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
05:01:07 <ray> pffffffffft
05:09:43 <copumpkin> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
05:14:41 <writer> thanks copumpkin 
05:19:01 <mm_freak> copumpkin: thanks
05:20:20 <copumpkin> @djinn (a -> c) -> (forall b. (a -> f b) -> f b) -> (forall b. (c -> f b) -> f b)
05:20:20 <lambdabot> -- f cannot be realized.
05:22:25 <ddarius> Djinn doesn't do rank 2.
05:22:42 <copumpkin> I figured :(
05:23:14 <ddarius> But that is just pre-pre-composition.
05:23:50 <hpc> wow, that was about the most educational haskell code i have yet seen
05:23:56 <hpc> (in that link)
05:26:05 <zygoloid> hpc: beware, it's a lie-to-children. the Cont monad is not the mother of all monads, since it forces an evaluation order.
05:26:46 <hpc> i meant mostly for me groking monads, but that's good to know
05:26:58 <hpc> er, continuations
05:27:00 <hpc> not monads
05:28:20 <hpc> i understand the inner workings of a continuation-exception/goto thingy
05:28:30 <zygoloid> the evaluation order thing is an important part of continuations in non-strict languages (in particular, the CPS transformation is not semantics-preserving)
05:29:16 <masak> I've recently realized what an important part monad transformers play in the understanding of monads. by what I understand so far, they seem to make monad composition much easier, but still not entirely painless. is that a common opinion?
05:29:48 <hpc> transformers are amazing, but they suck if you try to combine more than two monads, yeah
05:29:55 <hpc> usually there's ways around that though
05:30:01 <masak> I was wondering about more than two, yes.
05:30:18 <masak> two seem to be tricky enough; remembering when to lift, etc.
05:30:22 <zygoloid> one of the great things about applicative functors is that there is a transformer version of every one of them
05:30:23 <hpc> Either is strictly "larger" than Maybe, State = Reader + Writer
05:30:32 <zygoloid> the same isn't true of monads (there's no IO transformer, for instance)
05:30:45 <hpc> IO isn't applicative?
05:30:58 <hpc> @instances Applicative
05:30:58 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
05:31:07 <zygoloid> IO is applicative. there's an applicative transformer for io, but no monad transformer
05:31:17 <zygoloid> (every monad is an applicative functor)
05:31:40 <zygoloid> you can lift 'ap' but not 'join'.
05:31:55 <hpc> funky; what's an applicative transformer, in terms of types?
05:32:09 <hpc> google isn't helping me out
05:32:16 <objorn> mm_freak: it's listed as: functional, lazy/non-strict, modular
05:32:57 <objorn> If imperative is an option, I don't see why it isn't listed, but then, I'm not an expert by any means.
05:33:08 <halpskell> Why is there no single index update in Data.ByteString, something ala update :: Int -> ByteString -> ByteString ?
05:33:39 <hpc> objorn: imperative isn't haskell's primary style; fundamentally, it's a lambda calculus, so functional is more descriptive
05:33:56 <hpc> wikipedia is more "get the gist of something" than "know everything ever about something"
05:34:11 <ddarius> halpskell: Because it would be expensive so they are trying to discourage use and I assume you intended another argument, e.g. Char in that.
05:34:52 <mm_freak> objorn: "lazy/non-strict" and "modular" are not paradigms, but properties of the language
05:35:06 <halpskell> oh, I was supposed to write update :: Int -> Word8 -> ByteString -> ByteString
05:35:24 <halpskell> update the bytestring at said index with a new word
05:35:41 <halpskell> I don't get why it would be costly
05:35:58 <halpskell> is it not implemented as an array?
05:36:01 <mm_freak> zygoloid: for applicatives you don't need a special transformer type…  every applicative functor supports transformation into any other
05:36:28 <copumpkin> halpskell: they're not mutable...
05:36:34 <mm_freak> but not every monad supports transformation into any applicative functor, IO being the most notable example
05:36:49 <halpskell> copumpkin: well that update is not a mutation either
05:37:01 <hpc> how do you transform applicatives?
05:37:19 <halpskell> copumpkin: but a new bytestring
05:37:24 <copumpkin> halpskell: yeah, but you're asking why it would be costly
05:37:30 <copumpkin> it's because it's a new bytestring
05:38:08 <davean> copumpkin: That doesn't have to be costly, depending on the implimentation
05:38:12 <halpskell> copumpkin: why would that require creating a new bytestring rather than changing one value?
05:38:24 <copumpkin> halpskell: because changing one value is mutation :P
05:38:27 <davean> it just isn't implimented in a way that makes it cheap
05:38:35 <halpskell> if I could ensure the old ByteString would never be asked for again
05:38:39 <copumpkin> davean: well, given that it's an immutable array
05:38:50 <copumpkin> halpskell: look into substructural (linear) types :P
05:38:56 <davean> copumpkin: it could be a tree of immutable arrays for example
05:38:56 <copumpkin> haskell doesn't have those though
05:39:19 <copumpkin> davean: sure, but that's not what a bytestring is
05:39:19 <mm_freak> hpc: http://haskell.org/haskellwiki/Applicative_functor#Applicative_transfomers
05:39:28 <davean> copumpkin: right, but you weren't answering the question
05:39:30 <copumpkin> and that would have different asymptotics
05:39:39 <halpskell> well I guess I get the problem
05:39:45 <davean> you were saying "because it is a bytestring", which doesn't explain the CAUSE
05:40:09 <copumpkin> davean: well, given the fact that he seemed to suggest earlier that he knew it was a) an array b) immutable
05:40:13 <copumpkin> o.O
05:40:48 <hpc> mm_freak: oh i see; the similarities between the various lifts and "lift" are so obvious now
05:41:23 <halpskell> the problem is that it causes destructible update
05:41:25 <halpskell> shit
05:41:26 * copumpkin shrugs
05:41:31 <halpskell> well that sucks
05:41:44 <copumpkin> lol
05:41:52 <davean> halpskell: well, you could create a similar datastructure that handled it nicely
05:41:53 <copumpkin> I guess he didn't want to hear potential solutions
05:42:30 <davean> I mean, they're exact performance will vary, they'll almsot definately take a bit mroe memory for example
05:44:55 <davean> hum, does haskell have that already nicely packaged somewhere?
05:46:24 <davean> Data-Rope, though it doesn't look to have the exact function already (easily enough added though)
05:47:56 <davean> (Also, rope)
05:53:41 <sioraiocht> arnihermann: ping?
06:00:10 <mm_freak> given const and <*> you don't need any lambda abstractions?  they two alone make the language turing-complete, right?
06:00:17 <mm_freak> because const = k and <*> = s
06:00:45 <mm_freak> well, add 'fix' to the set of allowed functions
06:01:03 <copumpkin> you might as well write pure :P
06:01:16 <copumpkin> (instead of const)
06:01:21 <ziman> SKY-calculus :)
06:01:28 <mm_freak> copumpkin: sure, but that's not the point…  i'm really talking about functions
06:01:33 <copumpkin> yeah, I know
06:01:35 <mm_freak> ziman: SKI
06:01:43 <copumpkin> I is just SKK
06:01:57 <ziman> and fix is Y, iirc
06:01:58 <mm_freak> i know, otherwise i'd include id, too =)
06:02:12 <mm_freak> ziman: you can't express Y in typed lambda calculus
06:02:50 <mm_freak> but now i finally understand how to write unlambda programs =)
06:03:04 <copumpkin> unless you create an evil intermediate type
06:03:30 <mm_freak> (without lambda abstraction eliminiation)
06:06:15 <mm_freak> so <*> is really a generalization of the S combinator
06:06:52 <mm_freak> it is the S combinator in the ((->) a) functor
06:07:50 <mm_freak> and 'pure' generalizes K
06:08:36 <shachaf> mm_freak: *a* generalization, yes. Does it make much sense to think of it that way?
06:09:43 <mm_freak> shachaf: yeah, i really never understood what the SKI calculus is good for, but seeing that makes things much clearer
06:10:19 <ddarius> shachaf: Yes, it does.
06:11:01 <copumpkin> mm_freak: similar combinator calculi are useful for exploring substructural logics
06:11:16 <shachaf> ddarius: In what way?
06:11:42 <ddarius> mm_freak: Such calculi are useful for theoretical investigations as it significantly minimizes the number and complexity of the cases you need to prove for many proofs.
06:12:26 <ddarius> shachaf: S is application in an environment.  (<*>) is application with some effect.
06:13:18 <shachaf> Ah. Hmm.
06:14:01 <ddarius> Instead of S f g x = f x (g x), write S f g env = (f env) (g env)
06:14:30 <mm_freak> ddarius: i see
06:14:56 <mm_freak> copumpkin: what other calculi are there?  i know only λ, SKI and π
06:15:47 <ddarius> In a different vein, less minimalistic sets of combinators make a good target language for compilers.
06:16:19 <copumpkin> mm_freak: well, have you come across the B and C combinators?
06:16:19 <ddarius> mm_freak: There are a whole lot of lambda calculi, even if you limit yourself to relatively notable ones.
06:16:35 <mm_freak> copumpkin: not yet
06:16:48 <ddarius> A lot of interesting combinatory algebras as well, usually corresponding to one of the lambda calculi.
06:17:30 <ddarius> A relatively recent one is Barry Jay's SF combinatory algebra.
06:18:28 <copumpkin> mm_freak: another one is W, and by picking which combinators you allow, you can encode different substructural rules
06:18:30 <arw> ha. haskell is awesome. colleague needed a list of primes < 10^9. the haskell solution that took me 5 seconds to think up is a factor of about 10 faster than the obvious maple solution...
06:18:54 <mm_freak> a lot of theoretical stuff becomes accessible as well as useful in haskell…  are there any other examples outside of category theory?
06:19:32 * copumpkin tries to find where he read about this stuff
06:19:33 <copumpkin> dammit
06:20:03 <ddarius> There was some guys thesis that I linked Baez to for the Rosetta Stone paper that was fairly comprehensive.
06:20:09 <copumpkin> anyway, IIRC, BCW, BCK, and BCI correspond to the three usual substructural logics
06:20:44 <ddarius> BCI is linear, K throws in weakening, W throws in contraction.
06:21:10 <copumpkin> yeah
06:21:23 <copumpkin> do you have a good reference for that? I can't find where I read it now
06:22:30 <ddarius> http://research.microsoft.com/~gmb/Papers/thesis.pdf
06:27:17 <copumpkin> ah, thanks :) that looks interesting
06:48:10 <xiackok> hello
06:48:44 * edwardk waves hello.
06:48:44 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
06:48:53 <tomberek> hi edwardk
07:03:29 <xiackok> cabal install glade give me an error "Configuring glib-0.11.2...
07:03:31 <xiackok> setup: gtk2hsC2hs is required but it could not be found."
07:04:00 <xiackok> how can i solve this problem
07:04:06 <luite> xiackok: cabal install gtk2hs-buildtools
07:04:21 <nlogax> is that when you need gtk2hs-buildtools or am i.. ok, luite confirms :p
07:04:32 <goldengel> hi
07:04:40 <xiackok> luite: thanks
07:06:26 <goldengel> is there any programmer here with knowledge about database programming?
07:07:42 <quicksilver> undoubtedly, but this channel is specifically about the Haskell programming language
07:07:59 <goldengel> ah ok. 
07:08:15 <goldengel> in this case no one knows anything about Enumerator in SQL. 
07:08:17 <goldengel> thanks
07:08:19 <goldengel> :-)
07:13:04 <xiackok> luite: it said "setup: The pkg-config package cairo-pdf is required but it could not be found."
07:13:22 <xiackok> luite: im using debian
07:13:22 <luite> xiackok: that means you have to install the library first
07:13:40 <luite> using apt-get or similar :)
07:13:54 <luite> oh and you need the development version
07:14:53 <luite> probably libcairo2-dev
07:15:03 <xiackok> luite: i have found only libcairo2 there is no dev. package :S
07:15:37 <xiackok> luite: sorry i found
07:33:11 <BorisL> package gtk fails to install through cabal on Ubuntu with GHC 6.12.1. Error "gtk-0.11.2 failed during the building phase. The exception was: ExitFailure 9". Can you help with this?
07:34:41 <benmachine> BorisL: usually there's a more helpful error in the build log above
07:36:07 <siracusa> BorisL: Did you do `cabal install gtk2hs-buildtools' first?
07:36:15 <xiackok> BorisL: i install via cabal. there is no problem
07:45:28 <BorisL> yes, I installed gtk2hs-buildtools, glib and pango before
07:46:18 <BorisL> the problem was not in dependencies. The build log above did not have any errors
07:46:50 <kremsera> try --global ;)
07:50:57 <BorisL> now it complains about glib, although I have installed it before
08:02:51 <dom96> :t forM_
08:02:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
08:06:41 <BorisL> eventually it installed, thanks
08:10:55 <chandru_in> I installed a library using hackage.  Now how do I link to this library when compiling my code?  Everything works fine in ghci
08:11:19 <Saizan> use --make
08:12:09 <chandru_in> Saizan, Thanks thats what I was looking for
08:12:26 <chandru_in> I'm a haskell newbie sorry for asking stupid questions
08:12:31 <chandru_in> thanks again
08:15:32 <Saizan> no problem :)
08:16:22 <Saizan> at worst you'll get told that google can answer the question too
08:20:05 <chandru_in> Is it mandatory that main do IO?  What iff I want a program which just does some computation and exit without any outpu?
08:21:20 <chandru_in> Saizan, any help for this too?
08:23:07 <Taejo> chandru_in: then just do main = return ()
08:23:16 <Taejo> what is the point of such a program?
08:23:38 <chandru_in> As I mentioned sometime back I'm a haskell newbie so just experimenting
08:23:52 <Philonous> chandru_in: If the program doesn't interact with the outside world all your computations will be optimized away. So you can't for example test the runtime of an algorithm without forcing it's result.
08:23:57 <Saizan> chandru_in: main has to be in IO, if you just want to print out a result you can use "main = print foo"
08:24:29 <chandru_in> Philonous, you mean to say the code won't run at all?
08:24:52 <Philonous> chandru_in: Exactly.
08:25:03 <chandru_in> ok
08:25:07 <chandru_in> thanks for the pointer
08:26:11 <Raghs> I am calling a function that uses error. Is there anyway to recover from an error?
08:26:54 <dmwit> catch
08:26:59 <dmwit> or
08:27:01 <dmwit> spoon
08:27:14 <dmwit> ?hackage spoon
08:27:15 <lambdabot> http://hackage.haskell.org/package/spoon
08:27:16 <Philonous> Raghs: You can catch it in IO. But it is not observable in pure code
08:27:57 <Philonous> Spoon gives me the creeps. 
08:31:36 <dmwit> unsafePerformIO gives me the creeps
08:31:39 <orbital_fox> Philonous, you just have to understand something important about the spoon and then you will be fine
08:43:11 <zygoloid> Raghs: if it's your code, it'd usually be considered much better style to make it not use error. but otherwise, yeah, what they said :)
08:44:08 <Raghs> zygolid -> it's not in my code. so using teaspoon..
08:49:47 <Philonous> orbital_fox: I understand that it break monotonicity
08:49:56 <Philonous> +s
08:50:47 <orbital_fox> Philonous, not quite.. you need to understand that its not the spoon that bends..
08:52:44 <Philonous> orbital_fox: Are you kidding? I can't tell.
08:53:08 <zygoloid> you could imagine teaspoon as being an interpreter which manually reduces your haskell expression to WHNF, but converts any call to error into a bail-out with Nothing
08:53:44 <orbital_fox> :D
08:53:52 <orbital_fox> Philonous, yeah i am kidding :P
08:53:57 <Philonous> ;o)
08:53:58 <zygoloid> if you look at it that way it seems almost pure ;)
08:54:19 <orbital_fox> very poetic zygoloid 
08:55:36 <Philonous> zygoloid: You mean kind of like a monadZero homomorphism? 
08:59:01 <sbrg> I know this isn't specifically related to haskell, but does anyone know what to call and where to store the .ghci equivalent in windows?
09:00:02 <chrisdone> moo
09:00:18 * chrisdone copunches copumpkin
09:01:29 <chrisdone> I just had an epic use for LiberalTypeSynonyms
09:01:39 <chrisdone> needed a type-level `id'
09:02:08 <chrisdone> -XLiberalTypeSynonyms
09:02:08 <chrisdone> boom, type Id a = a
09:02:11 <chrisdone> ^_____________ ^
09:03:57 <chrisdone> type SubmissionE a =
09:03:57 <chrisdone>   (RecCons Id (a Integer) ... -- haskelldb's types for tables/records
09:03:57 <chrisdone> x :: SubmissionE Expr -- table definition
09:03:57 <chrisdone> y :: SubmissionE Id   -- record
09:04:03 <chrisdone> \o\
09:05:13 <aristid> chrisdone: can you write class instances for these?
09:07:18 <chrisdone> I could maybe; I did that first. but then I'd have 20~ classes
09:07:48 <chrisdone> I dunno if it makes much of a difference other than here I don't have to write an instance for the type of x and y
09:10:16 <chrisdone> hm, no. I don't think class instances really provides a solution to this
09:11:07 <chrisdone> as haskelldb works with conrete types, when you define your table
09:11:30 <Twey> ddarius: http://www.annexia.org/_file/jonesforth.s.txt (WRT scratching two itches)
09:11:38 <chrisdone> and it can't infer the types from the definition, so you have to write the whole type out
09:12:07 <chrisdone> and then you have to write the whole thing out again but slightly modified for using results from queries upon that table
09:14:01 <chrisdone> http://paste.tryhaskell.org/30085/haskelldb
09:15:13 <chrisdone> aristid: what you think?
09:15:19 <ddarius> Twey: I'm fairly sure I've skimmed through that before and many similar things, but I'm not interested in copying someone else's implementation and I'll likely tweak the language, taking ideas from Joy and Self.
09:17:53 <aristid> chrisdone: i don't really understand it
09:18:24 <chrisdone> aristid: yeah, I haven't really explained it well and haskelldb is a bit quirky. maybe I'll produce a more straight-forward example later and we can chat about i
09:20:43 <chrisdone> it's mostly in place of a more extensible record system like t-rex. I think using typeable and data.data could make this stuff automatic instead of having to have an abstract type and then mapping that to a concrete haskell value later -- I'd like to go straight from my concrete data type. I might just do this on top of takusen though and ditch haskelldb
09:30:58 <Twey> Why is it that we don't have T-rex in GHC?
09:31:37 <Twey> @tell chrisdone What back-end do you use for tryhaskell.com?  One of the frameworks?
09:31:37 <lambdabot> Consider it noted.
09:39:12 <osaunders> Is there a typeclass for collections in abstract?
09:41:28 <Twey> osaunders: Not collections in general… there are things like Traversable and Foldable for specific behaviour that you might expect from a collection
09:41:58 <osaunders> Ah, OK. Nice thanks.
09:43:02 <osaunders> Isn't null something that all collections have in common?
09:43:08 <osaunders> And length.
09:43:16 <Twey> Not necessarily, no
09:43:32 <osaunders> Can you give an example?
09:43:41 <Twey> Collections can be infinite (lists), and needn't be nullable (non-empty lists)
09:44:02 <osaunders> A non-empty list has null of false.
09:44:08 <osaunders> And a length of _|_.
09:44:24 <osaunders> (for infinite list).
09:44:32 <Twey> Oh, you mean the functions, not the associated data
09:44:51 <osaunders> Yeah.
09:45:04 <Twey> Well, you could define ‘null’ on *anything* and simply have it always be false
09:45:05 <osaunders> My assertion is that all collections can have null and length operations.
09:45:10 <Twey> null 5 == False
09:45:19 <osaunders> > null 5
09:45:20 <lambdabot>   No instance for (GHC.Num.Num [a])
09:45:20 <lambdabot>    arising from the literal `5' at <inter...
09:45:20 <Twey> null undefined == False
09:45:27 <Twey> I said ‘could’
09:45:31 <osaunders> That doesn't really make sense though.
09:45:35 <Twey> And the reason that we don't is that it's silly and pointless
09:45:41 <osaunders> Yeah.
09:45:49 <osaunders> But are there collections where the same is true?
09:46:03 <EvanR-work> you could define non empty sets
09:46:04 <Twey> Of course — any collection that can't be empty
09:46:12 <EvanR-work> restrict empty
09:46:14 <Twey> Non-empty sets, non-empty lists, non-empty… lots of things
09:46:57 <hvr> is there any recommendation wrt to HTF vs test-framework (or should I look for a third option?)
09:47:04 <osaunders> They could just have null always return false then.
09:47:13 <tromp> on planet haskell there was a post on representing sets as objects that given a function a->r for Ord r, will return an element of the set for which the function is maximized
09:47:14 <osaunders> But it would still make sense unlike null 
09:47:17 <osaunders> *null 5
09:47:19 <Igloo> I could imagine collections were length and null would be _|_
09:47:21 <Saizan> null = fromAny . foldMap (const (Any True))
09:47:25 <tromp> length makes no sense there
09:47:26 <Twey> osaunders: Why would it make any more sense than ‘null 5’?
09:47:40 <osaunders> Because they are collections and 5 isn't.
09:47:44 <Igloo> e.g. a collection of the subset of the Integers satisfying some property (e.g. isPrime)
09:47:47 <Twey> Circular logic
09:47:48 <aristid> Igloo: BOTH length and null?
09:48:12 <Twey> Int can be viewed as a non-empty version of ‘Maybe Int’ ☺
09:48:21 <Igloo> aristid: Yes, e.g. the set of Integers which are odd and perfect
09:48:39 <aristid> Igloo: there is no known integer with that property?
09:48:44 <Twey> (Maybe Int, of course, is a collection of 0 or 1 integers)
09:48:58 <Igloo> aristid: Right
09:49:42 <Igloo> aristid: But "the set of Integers that are both odd and even" would work too
09:50:08 <osaunders> I'm not convinced here.
09:50:15 <Saizan> i think "a null method doesn't make sense for X" is either a judgement over the possible polymorphic programs that you might want to instantiate to X or it's a judgement over the possibility of implementing a null for X that respects the specification
09:50:19 <osaunders> Demonstrate how my logic was circular.
09:50:34 <Saizan> non-empty collections are not an example of the latter
09:50:42 <Saizan> and i haven't seen arguments about the former
09:51:30 <osaunders> Saizan: I don't understand what you are saying.
09:53:34 <Saizan> i'm saying that wheter null makes sense for non-empty lists mostly depends on if you could write a sensible program that uses null which gives a sane/useful result when used with non-empty lists
09:53:52 <osaunders> And FWIW if null (Just 5) produced False and null Nothing produced True I don't think that would be a particularly bad thing.
09:56:33 <osaunders> If you have a collection type that always has at least one member such that null will always be False that isn't really a problem.
09:56:45 <osaunders> That is sane.
09:57:05 <osaunders> It's not useful but an abstraction of collections could well be.
09:57:30 <osaunders> It would be consistent.
09:59:19 <EvanR-work> what about a 'has' method
10:00:27 <osaunders> I think that's probably something common to all collections also.
10:01:16 <chrisdone> om nom nominolo, when's the new site coming?
10:01:16 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
10:01:23 <chrisdone> @messages
10:01:23 <lambdabot> Twey said 29m 46s ago: What back-end do you use for tryhaskell.com? One of the frameworks?
10:01:46 <chrisdone> Twey: it's the FastCGI library and nginx
10:02:14 <osaunders> EvanR-work: What do you think?
10:02:14 <chrisdone> apollogies for the down-time, I switched vps from Linode to RapidVPS
10:02:40 <EvanR-work> makes sense to me but i dont know what esoteric collections there are out there
10:02:49 <EvanR-work> basically i know nothing in this channel
10:02:56 <chrisdone> Twey: or by back-end do you mean evaluation? it uses a patched mueval
10:03:18 <osaunders> EvanR-work: Yeah, that's why I was asking.
10:06:28 <chrisdone> Igloo: ping
10:22:28 <osaunders> If I have data Thing = Thing String is there a function that can modify the String inside like a functor only without the type parametricity?  
10:23:55 <EvanR-work> modify inside, functor, for a minute i thought you were talking c++
10:24:10 <zygoloid> osaunders: you mean like a standard typeclass it could be an instance of?
10:24:29 <osaunders> Yes.
10:24:29 <fryguybob> sbrg: Don't know if you are still looking for an answer, but I have ghci.conf under %APPDATA%\GHC\
10:24:37 <zygoloid> osaunders: no, i don't believe so.
10:24:39 <osaunders> zygoloid: A Wrapper typeclass.
10:24:41 <sbrg> fryguybob: Nah, I figured it out, but thanks
10:24:44 <sbrg> It was annoyingly hard to find
10:24:48 <fryguybob> Yeah
10:24:53 <sbrg> Found it in some completely irrelevant guide online
10:26:16 <zygoloid> osaunders: if you use newtype rather than data, you can use GeneralizedNewtypeDeriving to provide instances for Thing
10:26:52 <osaunders> zygoloid: OK, I'll look into that.
10:27:51 <osaunders> zygoloid: Would GADTs likely help?
10:29:27 <Twey> chrisdone: Ah, you handle all the requests yourself?
10:30:10 <midorikid> \msg lambdabot @pl s -> f (g a s) b
10:30:34 <Twey> midorikid: flip f b . g a
10:30:39 <zygoloid> osaunders: i'm not sure what you have in mind with GADTs. i don't see them helping here.
10:31:04 <zygoloid> osaunders: you could use newtype GenThing a = Thing a; type Thing = GenThing String
10:31:11 <osaunders> Well, I'm not familiar with GADTs.
10:31:21 <zygoloid> then you could just use a Functor instance for GenThing
10:32:08 <midorikid> hehe, thanks Twey!
10:32:25 <Twey> midorikid: \s -> f (g a s) b = \s -> flip f b (g a s) -> \s -> (flip f b . g a) s = flip f b . g a
10:32:29 <Twey> midorikid: You're welcome ☺
10:32:42 <Twey> midorikid: Note that ‘flip f b’ can also be written as (`f` b), if you prefer that
10:33:28 <EvanR-work> smooth
10:33:56 <EvanR-work> that could be a 'clever' way to get into a monads run, which invariably takes args in the wrong order
10:44:32 <chrisdone> Twey: yeah, it's pretty low-level I know. I looked at happstack a while ago and got bored. Snap is nice and has some request management but lacks other basics that the CGI library provides, Salvia is probably pretty decent but I couldn't even get the example to run and got bored. the whole framework thing seems like a waste of time
10:45:39 <chrisdone> Twey: the Amlie code uses BlazeHtml, formlets, fastcgi+cgi, nice simple isolated do-one-thing-and-do-it-well libraries that I can pick and choose. I'd gladly pick up some web request handling library. I think there are some but I don't know about them yet
10:46:41 <chrisdone> I could generalise what I did in amelie to a library
10:47:17 <Twey> chrisdone: What sort of other basics?  I know it lacks file uploads, but that's it as far as I can tell
10:47:29 <chrisdone> it handles incoming requests and url-constructing (e.g. /paste/id/23) and rewriting (e.g. /23)
10:48:43 <aruns> hi, trying to define what i thought was a simple function to convert a float number of hours into a tuple - weeks, days, hours, mins, seconds. - http://codepad.org/IHmsQfAF. can't figure out why it doesn't work. especially when it works for a smaller test case of Float -> (Int, Int, Float)
10:48:44 <chrisdone> Twey: yeah, file uploads and handling inputs is kind of raw IIRC. it generally felt pretty bare bones last time I tried it, I can't recall more than that. I think they're working on a layer to go on top
10:49:32 <EvanR-work> every 'form helper' ive seen takes more typing than simply typing the form input
10:49:36 <EvanR-work> in html
10:49:39 <Twey> Heh
10:49:46 <chrisdone> EvanR-work: have you tried Formlets?
10:50:34 <EvanR-work> no
10:51:23 <EvanR-work> i could imagine that haskell or sexpression like function application could make it smaller than html, especially if it allowed user-defined-abstractions
10:51:58 <EvanR-work> php is just abominable
10:52:02 <chrisdone> login :: Formlet xml (String,String)
10:52:03 <chrisdone> login = (,) <$> user <*> pass where
10:52:03 <chrisdone>  user = label "Username: " *> input
10:52:03 <chrisdone>  pass = label "Password: " *> password
10:52:31 <chrisdone> runFormlet on this returns html and the value or a validation error
10:52:36 <Botje> aruns: why the do block?
10:53:15 <aruns> dont i need a code block around those lets ?
10:53:16 <EvanR-work> not sure if all that is necessary
10:53:46 <Botje> aruns: let w = ...\n t = ...\n ... in (...)
10:53:54 <Botje> where \n is an enter
10:53:56 <chrisdone> pass' = pass `check` ensure ((>3) . length) "Must be more than 3"
10:54:00 <chrisdone> bam, validation
10:54:26 <zygoloid> aruns: the problem is that you're using the values that are supposed to be Ints in arithmetic with Floats
10:54:31 <Botje> aruns: statements like "w * 7.0" force w to be Floats
10:54:35 <EvanR-work> ah now youre talking about processing the form
10:54:40 <EvanR-work> i was just talking about display
10:54:45 <chrisdone> this does both in one
10:54:56 <chrisdone> and it composes
10:55:03 <EvanR-work> seems weird
10:55:04 <aruns> like this - http://codepad.org/5KYMdZlV ?
10:55:38 <aruns> Botje: even though i have a floor to round down the value ?
10:56:03 <TapewormGalactos> hey I have a beginner question: I want a 2dimensional array to look up stuff in O(1), is that possible in Haskell?
10:56:16 <EvanR-work> yes
10:56:17 <ClaudiusMaximus> :t Data.Array.(!)
10:56:18 <lambdabot> Couldn't find qualified module.
10:56:18 <Botje> TapewormGalactos: Data.Array
10:56:32 <Botje> aruns: yes, even then
10:56:43 <TapewormGalactos> I found that, but I unfortunately don't understand how to make it 2dimensional
10:56:54 <EvanR-work> use tuples for indexes
10:56:56 <ClaudiusMaximus> @instances Ix
10:56:56 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
10:57:20 <c_wraith> @instances-importing Data.Array Ix
10:57:21 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
10:57:29 <roconnor> ``The word "operad" was also created by May as a portmanteau of "operations" and "monad"
10:57:37 <Botje> aruns: you could put explicit calls to floor in the tuple construction
10:57:44 <aruns> Botje: but if i do an integral division i would lose precision 
10:57:45 <c_wraith> Ordering.  For those cases when you want to look up by LT, EQ, or GT
10:57:55 <FunctorSalad> roconnor: why not?
10:57:55 <EvanR-work> aruns: divMod
10:58:03 <aruns> ok let me try that
10:58:07 <EvanR-work> floating point division loses precision
10:58:20 <EvanR-work> accuracy anyway
10:58:27 <aruns> EvanR-work: thanks looking at that one
10:59:02 <aruns> yes i noticed, certain divisions come back and are not accurate (have wrong recurring bits when they should just terminate)
10:59:05 <TapewormGalactos> EvanR-work, thx I'll try that
10:59:19 <FunctorSalad> EvanR-work: hmm not just one bit?
10:59:47 <FunctorSalad> the killer is subtraction of roughly equal numbers AFAIK
11:00:07 <FunctorSalad> > (1.0+1E20)-1E20
11:00:08 <lambdabot>   0.0
11:00:18 <EvanR-work> floating point is hilarious
11:00:34 <FunctorSalad> > (2*1E20)/1E20
11:00:35 <lambdabot>   2.0
11:00:49 <FunctorSalad> as I expected :)
11:01:00 <aruns> > 3 / 4
11:01:01 <lambdabot>   0.75
11:01:16 <aruns> > 3.0 / 4.0
11:01:17 <lambdabot>   0.75
11:01:47 <FunctorSalad> not saying floating division is *exact*, but intuitively only one bit should be lost
11:01:53 <aruns> Botje: do you mean define type of the function as Float -> (floor Int, floor Int, floor Int... ) ?
11:02:29 <roconnor> I didn't realise this when I first read xkcd 739, but this forum seems to be suggesting that the word "wikipedia" may be a malamanteau.
11:04:18 <aruns> EvanR-work: not sure if divMod would help here. i will have hours as a float  - 10.52. i want to convert that into 10 hours, 31 m, x seconds
11:04:41 <mauke> you can't have 10.52 as a float, though
11:04:45 <aristid> roconnor: what is a "malamanteau"?
11:04:51 <FunctorSalad> roconnor: "wicked ...."?
11:04:52 <FunctorSalad> ;)
11:04:52 <mauke> preflex: calc '2 10.52
11:04:53 <preflex>  1010.1000010100011110101110000101000111101011100001
11:05:20 <FunctorSalad> anyway, isn't it from "wiki" = fast in some language
11:05:24 <aruns> mauke: 10.52 is not a float ?
11:05:50 <mauke> aruns: it's not exactly 10.52
11:05:53 <FunctorSalad> why would it be?
11:06:29 <FunctorSalad> 10.52 = 8+2+0.5+0.2
11:06:33 <FunctorSalad> 0.02
11:06:44 <FunctorSalad> which isn't one is it
11:06:54 <aruns> > 8 + 2 + 0.5 + 0.2
11:06:55 <lambdabot>   10.7
11:07:01 <FunctorSalad> :p
11:07:07 <aruns> > 8 + 2 + 0.5 + 0.02
11:07:07 <lambdabot>   10.52
11:07:19 <aruns> > 8 + 2 + 0.5 + 0.02 == 10.52
11:07:20 <lambdabot>   True
11:07:33 <aruns> i dont get it
11:07:34 <FunctorSalad> well, they're both equally inaccurate
11:07:49 <aruns> so whats a good way of writing this function ?
11:08:00 <roconnor> aristid: a malamenteau is a portmanteau that incorrectly combines a malapropism with a neologism
11:08:01 <FunctorSalad> 0.02 isn't a finite sum of powers of two unless I'm mistaken
11:08:14 <aruns> given that i will have calculations that will give me hours in the format - 10.523
11:08:24 <aruns> i want to convert that into a tuple of hours, minutes, seconds
11:08:25 <FunctorSalad> ("finite" being necessary but not sufficient)
11:08:26 <mauke> preflex: calc '2 0.02
11:08:26 <preflex>  0.0000010100011110101110000101000111101011100001010001111
11:08:28 <roconnor> aristid: e.g. zygohistomorphic 
11:08:33 <roconnor> no, just kidding
11:09:08 <aristid> roconnor: evil words! you need to be exorcised!
11:09:12 <FunctorSalad> :o
11:09:30 <FunctorSalad> aruns: *3600, round?
11:09:40 <FunctorSalad> then divmod
11:09:49 <roconnor> Prelude Data.Time> fromRational (10.52*60*60) :: NominalDiffTime
11:09:51 <roconnor> 37872s
11:10:04 <FunctorSalad> assuming you don't care enough about speed to mess with the bits
11:10:16 <FunctorSalad> ^^^^^^ or that ;)
11:10:54 <aristid> > 10.52 :: Rational
11:10:55 <lambdabot>   263 % 25
11:11:00 <aruns> so switch to seconds, then do a divMod to get the hours, mins ?
11:11:59 <aristid> :t 10.52
11:12:00 <lambdabot> forall t. (Fractional t) => t
11:12:21 <zygoloid> aruns: is this homework?
11:12:27 <aristid> Fractionals are constructed by GHC with fromRational, right?
11:12:40 <aruns> zygoloid: no i'm just trying to build a small game
11:12:42 <aristid> > 10.52*60*60 :: NominalDiffTime
11:12:43 <lambdabot>   Not in scope: type constructor or class `NominalDiffTime'
11:12:47 <aruns> and i've gotten stuck at the most basic thing :P
11:13:06 <aruns> which is probably good, because i obviously dont understand this
11:13:17 <zygoloid> aruns: ok. here's how i might write it: http://codepad.org/YWV7or4h have a look if you think it'll help you
11:13:59 <zygoloid> though if you can round to seconds first and use divMod on that, it might be a bit nicer
11:14:07 <roconnor> > 10.52*60*60 :: Data.Time.NominalDiffTime
11:14:08 <lambdabot>   Not in scope: type constructor or class `Data.Time.NominalDiffTime'
11:14:12 <zygoloid> (for one thing you could write it as a nice foldr)
11:14:31 <FunctorSalad> for two iterations? ;)
11:14:53 <ManateeIrcClient> Good night, all! :)
11:14:54 <FunctorSalad> isn't there some tool for partially evaluating it to bit operations?
11:15:06 <zygoloid> FunctorSalad: there're 4 iterations in the code i was looking at :)
11:15:35 <aruns> thanks zygoloid, still trying to understand why that works, and mine doesn't
11:15:37 <FunctorSalad> hmm I understood it as just hours,mins,secs
11:15:53 <FunctorSalad> I have a dejavu about this now
11:16:01 <FunctorSalad> not that unlikely I guess
11:16:51 <cizra> Hi guys. Is there a standard lib function for creating all possible 2-tuples out of 2 lists? Sorta like zip, but permutating.
11:17:30 <roconnor> Prelude Data.Time> timeToTimeOfDay (10.52*60*60)
11:17:31 <roconnor> 10:31:12
11:17:34 <ezyang> cizra: Not that I know of, but you can easily do it with the list monad. 
11:17:47 <ezyang> > [(a,b) | a <- [1,2,3] | b <- [4,5,6]] 
11:17:49 <lambdabot>   [(1,4),(2,5),(3,6)]
11:17:51 <ezyang> erm 
11:17:54 <mauke> cizra: liftM2 (,)
11:18:00 <ezyang> > [(a,b) | a <- [1,2,3], b <- [4,5,6]] 
11:18:01 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:18:11 <aruns> roconnor: cool good to know. though in my case hours could be over 24. so it wouldn't fit the day format
11:18:16 <cizra> ohhh. I like the list comprehension way! Thanks.
11:18:20 <FunctorSalad> @let dm60 = (`divMod` 60)
11:18:22 <lambdabot>  Defined.
11:18:24 <roconnor> aruns: ya, if you go past one day, this won't work
11:18:57 <FunctorSalad> @let hms x = let (dm60 -> (h,dm60 -> (m,s))) = round (3600*x) in (h,m,s)
11:18:57 <lambdabot>   ViewPatterns is not enabled
11:19:01 <FunctorSalad> @fu
11:19:02 <lambdabot> Done.
11:19:08 <zygoloid> > foldr (\d (r, v) -> first (:r) (v `divMod` d)) ([], 116732) [1, 60, 3600, 86400, 86400 * 7]
11:19:09 <lambdabot>   ([32,25,8,1,0],0)
11:19:13 <aruns> yes i have a time for a future event to happen which i'm calculating. then i'd like to convert to h/m/s. or even weeks, days, hours, mins, seconds, if its a long time
11:19:28 <poucet> @quote vincenz
11:19:28 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
11:19:57 <FunctorSalad> @let hms x = let (h,ms) = dm60 (round (3600*x)) in (h,dm60 ms)
11:19:58 <lambdabot>  Defined.
11:20:03 <FunctorSalad> > hms 10.52
11:20:04 <lambdabot>   (631,(0,12))
11:20:13 <roconnor> aruns: I guess it is best do use divMod
11:20:15 <FunctorSalad> hmm.
11:20:16 <roconnor> to use
11:20:17 <FunctorSalad> ;)
11:20:44 <roconnor> er
11:20:49 <roconnor> divMod has the wrong type
11:20:51 <roconnor> :(
11:20:53 <FunctorSalad> @let hms2 x = let (hm,s) = dm60 (round (3600*x)) in (dm60 hm,s)
11:20:54 <lambdabot>  Defined.
11:21:00 <aristid> roconnor: try the one in Data.Fixed?
11:21:13 <FunctorSalad> > hms2 10.52
11:21:14 <lambdabot>   ((10,31),12)
11:21:17 <roconnor> @type divMod
11:21:17 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
11:21:25 <aristid>  Data.Fixed> :t divMod'
11:21:25 <aristid> divMod' :: (Real a, Integral b) => a -> a -> (b, a)
11:21:30 <roconnor> ah
11:34:35 <aruns> is timeTuple :: Float -> (Int, Int, Int, Int, Float) a valid type for a function ? 
11:34:46 <zygoloid> aruns: yes.
11:34:47 <mauke> yes
11:35:04 <TapewormGalactos> is there a way in a list comprehension to say something like:    i,j <- [1..100] ?
11:35:12 <mauke> what would that do?
11:35:27 <TapewormGalactos> enumerate 1 from 1 to 100 and j from 1 to 100
11:35:32 <TapewormGalactos> *i
11:36:11 <mauke> what, in parallel?
11:36:28 <TapewormGalactos> so basically is there a shorter version for        i <- [1..100], j <- [1..100]
11:36:28 <ClaudiusMaximus> > range ((1,1),(4,4))
11:36:29 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4...
11:36:30 <tommd> > [ (i,j) | i < [1..100] , j <- [1..100]
11:36:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:36:42 <tommd> > [ (i,j) | i < [1..100] , j <- [1..100] ]
11:36:43 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
11:36:43 <lambdabot>         against inferred ...
11:36:44 <mauke> TapewormGalactos: yeah, don't use a list comprehension
11:36:57 <aruns> > [ (i, j) | i <- [1..10], j <- [1..10]]
11:36:58 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
11:37:02 <tommd> oh, typo
11:37:21 <tommd> > [ (i, j) | i <- [1..10] | j <- [1..10]]
11:37:22 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
11:37:22 <FunctorSalad> > let x = [1..100] in x >> x
11:37:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:37:29 <TapewormGalactos> mauke, what should I use instead?
11:37:29 <zygoloid> > [ (i,j) | (i,j) <- join zip [1..100] ]
11:37:30 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,...
11:37:37 <zygoloid> > join zip [1..100]
11:37:37 <mauke> TapewormGalactos: liftM2 (,)
11:37:38 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,...
11:38:27 <zygoloid> > join (liftA2 (,)) [1..100]
11:38:28 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
11:39:27 <ClaudiusMaximus> TapewormGalactos: if this is for a specific array, there is indices : http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-IArray.html#v:indices
11:40:51 <TapewormGalactos> ok thanks I'll look into that
11:46:41 <cizra> Any statistics packages for Haskell? Specifically, I need correlation and I'm too lazy to write it.
11:46:52 <cizra> oh. Hm. "statistics"
11:47:46 <monochrom> hehe
12:05:42 <TapewormGalactos> Is there a way to strictly evaluate (generate) an array?
12:07:28 <monochrom> perhaps unboxed arrays e.g. UArray but there are constraints in element types.
12:09:03 * hackagebot wai 0.2.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.2.1 (MichaelSnoyman)
12:09:05 * hackagebot wai-handler-devel 0.0.0 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.0.0 (MichaelSnoyman)
12:09:20 <TapewormGalactos> I have Doubles so that should be fine
12:09:58 <monochrom> yes, Double is supported
12:16:00 <midorikid> I'm doing a lot of squaring ((x::Double)^2) in a part of my code, but I get warnings unless I do (x^(2::Int)). This is making my formula ugly.  Is there a better way of doing it than redefining (^::Double->Int)?
12:17:24 <monochrom> @quote monochrom speed
12:17:24 <lambdabot> No quotes match. I've seen penguins that can type better than that.
12:19:34 <wli> x^(2::Int) or x^(2::Integer) is basically required to shut up the warning, sorry.
12:19:35 <kmc> > (3 :: Double) ** 2
12:19:36 <lambdabot>   9.0
12:19:57 <kmc> Haskell has three exponentiation operators: (^), (^^), and (**)
12:21:36 <espadrine`> How does lambdabot work? Why did it respond to monochrom?
12:21:38 <midorikid> kmc: Aha! I see. ** :: a -> a -> a  I had missed that one.  Thanks a lot!
12:25:23 <tommd> @hoogle (**)
12:25:23 <lambdabot> Prelude (**) :: Floating a => a -> a -> a
12:25:24 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:25:24 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:26:33 <Twey> Why (on Earth) does Haskell have three exponentiation operators?
12:26:47 <kmc> espadrine`, lambdabot responds to commands beginning with '@', as well as a few special cases like '>' and ':t'.  for more info:  /msg lambdabot @list
12:26:54 <kmc> @. elite nixon
12:26:54 <lambdabot> A PUBlIc mAN /\/\Uz7 N3vER foRgE7 7Ha7 HE 1OsES His U5ephuLnES5 w|-|EN |-|e Az An INDiviDUa|, RA7hER +Han HiS pO|iCy, b3C0/\/\Es 7hE Iz$Ue.
12:28:28 <tommd> @. elite vixen Hello!
12:28:28 <lambdabot> +31l m3 7ruThfuL1y w|-|AT TH3 na57IE57 +|-|iNG u |-|a\/E E\/ER d0n3.
12:29:36 <espadrine`> Wow. Built-in leet!
12:30:23 <fryguybob> @. elite run text $ concat . take 10 $ cake
12:30:24 <lambdabot> 0Ne 18.25 OUNCE PaCk4g3 (ho(o1a+e C4K3 /\/\iX.oN3 C4N prEPARed cOCOnut Pe(AN f...
12:31:11 <Nibble> IORefs vs using state monads? do they even accomplish the same thing?
12:31:29 <kmc> Nibble, vaguely similar things, but by completely different mechanism
12:31:36 <Nibble> kmc: I understand that
12:31:44 <Nibble> but I can accomplish the same thing with IORefs?
12:31:53 <Nibble> I really cba with the state monads just yet.
12:32:04 <kmc> it depends on how you're using State
12:32:19 <Nibble> kmc: I know you use it to pass around computations
12:32:22 <kmc> IORefs are real mutating in-place update; you can't get the old value back unless you save it yourself
12:32:33 <kmc> whereas State is just sugar for pure functions of the form s -> (a, s)
12:32:43 <kmc> and so you can do "local" state manipulation, then restore some or all of the previous state
12:33:33 <kmc> lots of other considerations -- IORef can be used concurrently, can allocate cells of many different types, is maybe faster, etc.
12:34:07 <dolio> IORefs can allow you to make mutable structures.
12:34:11 <kmc> and you can "run" a State computation to get its result value, but you can't do the same with an IO computation
12:34:13 <dolio> Which is hard to fake with State.
12:34:13 <kmc> (but see ST)
12:34:56 <dolio> If you just want to have a single mutable reference, State is probably nicer than IORef, though.
12:35:27 <dolio> Or possibly even several references, the amount of which are statically known.
12:35:42 <monochrom> Twey: Because on earth there are different kinds of "numbers", or number systems.
12:46:00 <Nibble> @hoogle IORef
12:46:01 <lambdabot> module Data.IORef
12:46:01 <lambdabot> Data.IORef data IORef a
12:46:01 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
12:46:40 <Twey> monochrom: And that's why we have the Num typeclass :þ
12:47:26 <Twey> kmc: Um, IORefs aren't thread-safe, are they?
12:47:57 <ezyang> Twey: for certain definitions of thread safe. 
12:48:19 <monochrom> ^, ^^, ** are for different subclasses of Num.
12:48:26 <Twey> I thought they weren't safe at all.  Access halfway through writes, resultant segfaults, the works.
12:48:47 <Twey> monochrom: Like + and +. are for different subclasses of Num?  Oh, wait… :þ
12:48:50 <wli> (^) gets struck by ambiguity when literals are used in the second arg, which is Integral
12:48:56 <ezyang> No, I think they have basic synchronization. 
12:48:57 <monochrom> different number systems means different subclasses of Num.
12:49:06 <ezyang> "This function is useful for using IORef in a safe way in a multithreaded program. If you only have one IORef, then using atomicModifyIORef to access and modify it will prevent race conditions." 
12:49:08 <ezyang> for example. 
12:49:10 <Twey> wli: Example?
12:49:18 <Twey> ezyang: Oh, cool.
12:49:23 <benmachine> Twey: atomicModifyIORef?
12:49:29 <benmachine> oh
12:49:30 <benmachine> right
12:49:31 <benmachine> yes
12:49:32 <wli> -Wall complains that it has to default
12:49:35 <Twey> benmachine: Too slow :þ
12:49:40 <wli> Twey: x^2
12:49:41 <Twey> wli: Ahh, I see.
12:49:52 <Twey> :t (^^)
12:49:53 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
12:49:59 <Twey> :t (^)
12:50:00 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
12:50:13 <Twey> Um
12:50:22 <Twey> :t (**)
12:50:23 <lambdabot> forall a. (Floating a) => a -> a -> a
12:50:27 <monochrom> x^^(negative integer) cannot be done if x doesn't support division. this is why we have ^
12:50:31 <Twey> Oh, right — it's all the same, so it doesn't default
12:50:45 <Twey> But what's the point of (^) (versus (^^)) then?
12:50:48 <Twey> Ah
12:51:08 <benmachine> (^) I think of exponentiation of a group
12:51:15 <monochrom> x**(non-integer) cannot be done if x doesn't support roots, logs, exp. this is why we have **
12:51:15 <benmachine> whereas (^^) needs division
12:51:17 * hackagebot mount 0.2 - Mounts and umounts filesystems  http://hackage.haskell.org/package/mount-0.2 (NicolaSquartini)
12:51:23 <monochrom> err, this is why we have ^^
12:51:24 <Twey> Got it.  Thanks.
12:52:01 <benmachine> I wonder which is faster out of (^) and (**) when both are available
12:52:04 <benmachine> and if they are always consistent
12:52:05 <Nibble> Hmm..
12:52:16 <monochrom> It is depressing that before this obvious explanation, you bought traditional mathematician's dogma of "one single ^" wholesale.
12:52:26 <Twey> Presumably ** optimises to ^ if appropriate
12:52:51 <benmachine> Twey: maybe, maybe not; I imagine, especially with floating-points being as they are, it's rarely safe to do so
12:52:54 <Twey> monochrom: I always just assumed.  I guess it's because it's argument-dependent.
12:53:05 <monochrom> But even they can't reach a consenus under their "one single ^" whether 0^0 should be 0, 1, or undefined.
12:53:10 <Nibble> http://pastebin.com/9rBcDBC8
12:53:27 <Nibble> I don't see what the hell could go wrong
12:53:35 <benmachine> I don't think a consensus is really useful
12:53:49 <Twey> Saying that x^½ is different from x² because ½ requires division feels to me like saying that 1 - 5 is different to 7 - 5 because 1 - 5 requires negative numbers
12:54:00 <monochrom> No, a consensus on that is not useful. This is why the "one single ^" dogma is stupid.
12:54:17 <benmachine> oh
12:54:21 <benmachine> is it a dogma?
12:54:28 <benmachine> I thought it was just, some related ideas
12:55:02 <monochrom> Did any math teacher tell you there are different exponentiations?
12:55:31 <benmachine> not as such
12:55:45 <benmachine> they said "we sometimes use exponentiation syntax to mean repeated operations" in group theory though
12:55:55 <medfly> lol
12:56:43 <benmachine> Nibble: give dracula an explicit type signature, then the error will be more helpful, I think; basically looks like you've left a field off the Monster constructor
12:57:30 <benmachine> Nibble: also, calculateDamage dracula player is type Double if you get the dracula right, you're using it in a context that expects IO
12:57:36 <benmachine> IO () in fact
12:57:36 <Philonous> Twey: If you define x^n to the the product of n xs it is not clear what x^(1/2) is supposed to mean. It is a real generalization.
12:58:20 <monochrom> give a vampire a cup of blood, and he lives for a day. give dracula a type signature, and he knows how to do blood tests?
12:59:16 <enigmus> Probably a common question: any advanced book on Haskell you would recommend? I more interested in example and insight on using advanced features like Applicative, Seq, ... I'm OK with the basics of the language, functional programming, etc. But I'd like more example of great, subtle, and idiomatic code
12:59:51 <newsham> enigmus: RWH is the only one i know of off hand that gives idiomatic examples
12:59:57 <Nibble> I forgot to add the coordinates part of dracula and the player.
13:00:04 <benmachine> Applicative is covered in RWH and LYAH I think
13:00:06 <newsham> there's tons of academic papers with haskell code in em
13:00:07 <Olathe> Does anyone know how to get a lazy ByteString of the contents of stdin on Windows (ByteString uses hGetBufNonBlocking, which doesn't work on Windows)?
13:00:28 <newsham> olathe: getContents doesnt do it?
13:00:30 <benmachine> Olathe: doesn't work?
13:00:40 <Olathe> No, it has a noted bug.
13:00:48 <xiackok> monochrom: dracula? hahah :D
13:00:50 <Philonous> Twey: Errr, on second thought that didn't make much sense. Sorry.
13:01:05 <newsham> Prelude> s <- getContents
13:01:05 <newsham> Prelude> head $ lines s
13:01:06 <newsham> "testing
13:01:06 <newsham> testing"
13:01:12 <newsham> in winders.  
13:01:17 <newsham> (older version.. 6.10.1)
13:01:35 <Olathe> That's in ghci, but in a compiled thing, it doesn't work, I think.
13:01:41 <monochrom> Philonous makes perfect sense. x^(1/2) requires way more than division.
13:02:07 <Guest94071> I was curious why AdvSTM TVars use 3x as much space as regular TVars.
13:02:10 <Olathe> http://hackage.haskell.org/trac/ghc/ticket/1276
13:02:11 <monochrom> Definitely can't be done within Integer.
13:02:13 <Olathe> That has the bug.
13:02:22 <Philonous> monochrom: Yes, I still think my statement was correct, it just didn't fit into the conversation
13:02:25 <monochrom> Hell, can't be done within Rational
13:02:31 <newsham> olathe: my small test worked here (again, older version of ghc)
13:02:35 <Olathe> Which is a duplicate of http://hackage.haskell.org/trac/ghc/ticket/806, which has been unhandled for 10 months.
13:02:46 <Olathe> Ahh, might be my version or something.
13:03:05 <Olathe> Can you try it with lazy bytestring, please?
13:03:19 <wolverian> The syntax of the configuration often changes when awesome updates. So, remember to repeate the command above when you get something strange with awesome, or you'd like to modify the configuration.
13:03:27 <newsham> whats the function for getting lazy bytestream contents?
13:03:27 <wolverian> argh, mousespaz, sorry
13:03:37 <Olathe> import Data.ByteString.Lazy as L (getContents); main = do { x <- L.getContents; print x }
13:04:20 <newsham> tst.exe: <stdin>: hGetBufNonBlocking: resource exhausted (Not enough space)
13:04:28 <newsham> :)
13:04:28 <Olathe> Yeah, same here.
13:04:56 <newsham> hGetContents and convert to lazy bytestream as a workaround?
13:05:10 <Olathe> Hmm, let me see about doing that.
13:05:20 <Philonous> monochrom: We could have Cauchy-sequences of Reals 
13:05:21 * hackagebot CSPM-Frontend 0.4.1.1 - A CSP-M parser compatible with FDR-2.83  http://hackage.haskell.org/package/CSPM-Frontend-0.4.1.1 (MarcFontaine)
13:05:39 <tommd> Huh, I don't have any problems with that code
13:05:44 <benmachine> Philonous: those are called real numbers aren't they?
13:05:48 <newsham> tommd; in windows?
13:05:51 <Olathe> newsham: It would be L.pack (theContents)?
13:05:54 <tommd> Who uses that?
13:05:57 <benmachine> (cauchy sequences of rationals, rather)
13:06:01 <Philonous> Of rationals*
13:06:07 <Philonous> And yes they are
13:06:09 <tommd> ;-) No, not in Windows.  Didn't catch that.
13:06:13 <newsham> tommd: apparently not enough people to fix the bug? :)
13:06:18 <benmachine> Philonous: so that's kinda cheating :P
13:06:31 <benmachine> Philonous: might as well say you can do it in integers, with cauchy sequences of pairs
13:06:32 <newsham> olathe: something like that.. its been a while :)
13:06:40 <benmachine> with some weird metric that you can work out
13:06:42 <newsham> might have to map from Char to Word8?
13:06:46 <monochrom> just for x^(m/n) you could just go algebraic.
13:06:50 <tommd> newsham: Windows developers/ghc users are very hands-off.  I tried to get a (any) windows user to test a single function in crypto-api (or just install it) with no luck.
13:07:02 <Olathe> Ahh, OK, thanks :)
13:07:04 <Philonous> benmachine: No, it's not kind of cheating. It's just cheating. ;-P
13:07:10 <benmachine> giggle
13:07:34 <monochrom> but people are complaining about too many number systems and too many exponentations already. would revolt for adding the 4th "algebraic".
13:08:36 <newsham> import qualified Data.ByteString.Lazy.Char8 as L
13:08:37 <newsham> main = getContents >>= print . L.pack
13:08:37 <monochrom> "why are there ^, ^^, ^^^, **, ***, %, %%?"
13:08:38 <newsham> works for me
13:08:48 <newsham> tommd: *nod*
13:08:59 <tommd> So... any windows users want to run "cabal update ; cabal install crypto-api" and tell me what happens?
13:09:17 <newsham> tommd: i can do that, but warning, I have reallyold ghc :)
13:09:18 <Olathe> tommd: Running
13:09:19 <tommd> oh, newsham, "works for me" means you installeD?
13:09:20 <tommd> good
13:09:32 <newsham> trying now
13:09:49 <newsham> please dont install the malwares on my box, tommd :)
13:09:50 <tommd> Olathe, newsham: if one of you could run (ghci is fine):  import Crypto.Random ; getEntropy 64
13:10:12 <tommd> newsham: No, its clean.  you can trust me, I put Haskell RTS in the kernel, I wouldn't do anything unsafe...
13:10:26 <newsham> unsafePerformBotnet
13:10:34 <Olathe> Hahoa
13:10:39 <cadabra> Trying to package a binary on Mac OS X. Can I get ghc --make to link some things statically? Specifically libpcre, libcurl, libgmp.
13:10:45 <newsham> Crypto\Modes.hs:1:34: unsupported extension: MonoLocalBinds
13:10:49 <Olathe> Downloading the package list is taking forever.
13:11:09 <tommd> oh, sorry, that code should have been: import System.Random.Crypto ; getEntropy 64
13:11:20 <tommd> newsham: That's a newish extension, sorry.
13:11:25 <tommd> newsham: What GHC version?
13:11:28 <newsham> tommd: no worries, I didnt expect it to bulid :)
13:11:36 <newsham> GHCi, version 6.10.1: http://www.haskell.org/ghc/  :? for help
13:11:45 <tommd> ah, didn't know the extension was _that_ new.
13:11:47 <devinus> i love when developers name things e.g. aether
13:11:48 <tommd> good to know.
13:12:07 <newsham> I thikn the 6.10.* stuff is before they ripped apart base into tons of packages, no?
13:12:15 <tommd> Olathe: Did you have success?  Note my fixed test code a few lines up.
13:12:17 <newsham> i have newer ghc on other non-winders boxes
13:12:28 <tommd> newsham: No, split base was around 6.8
13:12:32 <Olathe> tommd: <interactive>:1:0: Not in scope: `getEntropy'
13:12:32 <benmachine> devinus: why? :P
13:12:55 <tommd> Olathe: Yeah, I corrected myself (sorry) with: import System.Crypto.Random ; getEntropy 64
13:13:29 <tommd> A couple runs of getEntropy to show it _looks_ random would go a long way to making me feel better.
13:15:29 <Olathe> *** Exception: /dev/urandom: openFile: does not exist (No such file or directory)
13:16:03 <tommd> Olathe: Huh, I must have the CPP code messed up
13:16:13 <tommd> It should know you're on Windows and have compiled different code.
13:16:16 <tommd> Olathe: Thanks
13:16:55 <Olathe> You're welcome :)
13:18:10 <devinus> benmachine: it's so...je ne sais quoi
13:20:51 <mpiechotka> a
13:21:09 <mpiechotka> Ups. sorry wrong window
13:22:19 <tommd> Olathe or other windows users with a spare second:  Could someone test:
13:22:19 <tommd> > darcs get http://community.haskell.org/~tommd/crypto/
13:22:19 <tommd> > cabal install
13:22:19 <tommd> > ghci ; import System.Crypto.Random ; getEntropy 10 ; getEntropy 10 ; getEntropy 10
13:22:19 <tommd> I made the CPP match what the Nnetwork package has, though I'm not sure if cabal sets the defs or if it leverages the configure script  for that.
13:22:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:22:20 <lambdabot>   Not in scope: `cabal'Not in scope: `install'
13:22:20 <lambdabot>   <no location info>: parse error on input `;'
13:22:26 <tommd> oops, sorry bot
13:35:22 <retybok> why are there so few haskellers in the best entries of the ai challenge? (http://ai-contest.com/rankings.php)
13:35:58 <monochrom> because one rules them all
13:36:35 <retybok> I'm really wondering, haskell should be ideally suited for a problem like that
13:36:50 <benmachine> retybok: there aren't that many haskellers full stop :)
13:37:05 <benmachine> by comparison to other languages we're still quite small
13:37:26 <retybok> I know, but I'd expect haskellers to be good at this.
13:37:38 <retybok> So I'd expect to see the few haskellers in the top 100
13:38:01 <newsham> retybok: haskell is a lazy language
13:38:15 <monochrom> haha
13:38:17 <tommd> I think I'm going to have to setup a Windows VM if I want any hope of getting windows working with $libraryname
13:38:40 <newsham> tommd: you should.
13:38:40 <retybok> :)
13:40:07 <newsham> everyone should have a windows, osx and a few linux VMs handy
13:40:11 <monochrom> Or use Windows on hardware and set up a Linux VM.
13:40:52 <Palmik> Hmm... ai-challenge even here :)
13:41:13 <newsham> also 64-bit linux and windows vm is a nice thing to have occasionally
13:41:36 <roconnor> anyone have an example of a module of a monad?
13:41:53 <roconnor> a module over a monad I mean
13:42:07 <monochrom> not sure it's ai or second-guessing other teams' tactics and so "we'll add this special case"
13:42:40 <roconnor> http://ncatlab.org/nlab/show/module+over+a+monad
13:43:20 <benmachine> monochrom: given the number of other teams I'd've thought that wouldn't pay off in the long run
13:45:04 <Cale> roconnor: Well, apart from T-algebras, I guess?
13:45:20 <monochrom> given the universality of stupidity I would say most teams think like "most other teams think like blahblah so I'll add this special case and who else could guess I am doing this!"
13:45:21 <roconnor> yes, a T-algebra example
13:45:33 <roconnor> concrete for people with small brains like me
13:46:28 <Cale> Okay, so let T be the list monad, and think about what a T-algebra would have to be
13:46:33 <monochrom> I saw several similar tournaments. It always happened.
13:47:03 <Cale> A T-algebra is an object A together with some rule TA -> A, or [A] -> A
13:47:33 <Cale> Call that a :: [A] -> A
13:48:05 <Cale> Then we must have a . join = fmap a . a
13:48:24 <Cale> (by the first square)
13:49:02 <Cale> er, sorry, a . fmap a
13:49:10 <medfly> hi
13:49:16 <roconnor> yes yes
13:49:19 <roconnor> I know all this
13:49:52 <Cale> So, anyway, the upshot is that the algebras of the list monad are monoids.
13:50:01 <roconnor> I can't think of an example of a T-Algebra
13:50:18 <Cale> So, every monoid is an example of a []-algebra
13:50:23 <roconnor> ah
13:50:29 <roconnor> ooh
13:50:32 <roconnor> mmm
13:51:30 <roconnor> is there a T such that every group or every ring is a T-algebra?
13:52:41 <Cale> yes
13:53:04 <roconnor> how do I solve for such a T?
13:53:43 <Cale> Well, I think of T as being sort of the natural syntax for free whatever-structures
13:54:26 <roconnor> let's do rings then
13:54:30 <Cale> Just like with a free monoid, to determine an element of a free monoid, you just make a list of the multiplied elements
13:55:20 <roconnor> so for rings we take a set of variables and but them as the sum of products?
13:55:53 <roconnor> (with signs in front of each product)
13:56:12 <roconnor> I guess the sums and products will have to be sets
13:56:17 <Cale> Yeah, T will send some set A to the set of sums of products of elements of A up to equivalence under the ring axioms
13:56:17 <roconnor> not lists
13:56:41 <roconnor> multi-sets
13:57:01 <Cale> That is, essentially, it basically sends A to the set of elements of the free ring on A
13:57:04 <roconnor> and this T will be a monad?
13:57:14 <roconnor> ah
13:57:19 <Cale> yeah
13:57:28 <roconnor> sytax with variables is always a monad
13:57:29 <Cale> There's an adjunction there you can see
13:57:57 <Cale> We're going from Set to Ring by the free construction and back to Set via the forgetful functor
13:58:05 <Cale> and that's a monad
13:58:19 <roconnor> how do I find a free construction in general?
13:58:54 <Olathe> If I use runST to give a list, will the list be lazy?
13:59:22 <Cale> Well, it's not perfectly formulaic, but if you have a bunch of operations on some set, and a bunch of laws, you just take the set of all ways of composing those operations and quotient by the equivalence relation induced by the laws
13:59:26 <benmachine> Olathe: it probably depends on what you were doing that constructed the list
13:59:34 <benmachine> Olathe: it's almost certainly possible
13:59:44 <Olathe> I'm writing to and reading from an STArray.
14:00:11 <roconnor> Control.Monad.ST.Lazy
14:00:17 <benmachine> yeah I was thinking that
14:00:29 <benmachine> I don't know what bit it means is lazy exactly
14:00:41 <roconnor> the monad delays evaluation of state operations until a value depending on them is required. 
14:01:15 <Cale> What computation are you doing? Are you treating the STArray as your list and taking its elements at the end? STArrays aren't very lazy...
14:01:18 <c_wraith> it may or may not be lazy, depending on how the algorithm works
14:01:41 <benmachine> it'd probably be easiest to just scatter undefineds about and see if it crashes
14:01:45 <benmachine> if so, not lazy
14:01:49 <Cale> (well, the elements are lazy, the structure is not)
14:01:52 <benmachine> in that particular bit of the structure
14:03:14 <handonson> Can someone take a look at this message generated by ghci? http://pastebin.com/xNi6pvDC
14:04:15 <Olathe> benmachine: Good idea :)
14:04:15 <c_wraith> handonson, looks like you have the ghc package hidden, either via ghc-pkg or command-line options
14:04:17 <Cale> handonson: Did you try what the message suggested?
14:04:51 <benmachine> c_wraith: the ghc package is usually hidden, isn't it?
14:04:59 <benmachine> yeah, it is
14:05:02 <handonson> Cale: you mean reporting a bug? no, but i was going to do so if this channel couldn't give me the answer (which i doubted)
14:05:06 <Olathe> Hmm, it doesn't even get to runST.
14:05:17 <Cale> handonson: No, I mean deleting any out-of-date .hi files
14:05:42 <handonson> Cale: oh, it doesn't have any intermediate files at all. i never even tried to compile it yet
14:05:46 <Cale> okay
14:05:59 <Cale> Let me try the same example
14:06:25 <handonson> c_wraith: if that's the case, do you know how i can get the ghc package exposed?
14:06:41 <Cale> Which one is it? The short first one?
14:06:42 <c_wraith> oh, I missed the ghc panic
14:06:49 <c_wraith> that's caused by something else
14:07:27 <handonson> Cale: A.hs, slightly changed. i'll post it too. wait a sec.
14:08:32 <handonson> the source file, named Source.hs http://pastebin.com/Wpsj1tUc
14:10:52 <Cale> Okay, A.hs works for me, after a small modification to make it use the GHC.Paths module
14:11:14 <Cale> (I mean, the one on the wiki)
14:12:08 <Cale> handonson: Oh, wait, what?
14:12:24 <handonson> Cale: huh?
14:12:46 <handonson> did I make some silly mistake? :)
14:13:04 <Cale> oh, Source.hs fails for me in the same way as you're seeing
14:13:15 <handonson> huh.
14:13:34 <Cale> But, it could be that something about the way you're using GHC as a library is causing it to panic
14:13:50 <Cale> I don't really know a whole lot about GHC as a library
14:14:04 <Cale> A.hs/B.hs works for me though
14:15:20 <handonson> Cale: well, my first impression was, if it does that in a compilation/execution phase, I'd be sure it's my fault, but as you see it panics while trying to load DynFlags... so I thought the problem wasn't me
14:16:01 <Cale> handonson: I think it's complaining that the module you're trying to compile imports DynFlags from the ghc package, but the ghc package isn't loaded
14:16:17 <Cale> This is all quite confusing because we're running the program on itself
14:16:46 <Cale> The ghc package must be loaded for the program to be running, but that's the outer ghc of course, and not ghc-as-a-library
14:16:48 <handonson> aha.
14:17:18 <handonson> so i shouldn't be targeting... myself. :) let me try
14:18:08 <Cale> When I switch it to  ... TargetFile "B.hs" ...  then it works and returns True
14:19:11 <tomberek> hey, anyone there?
14:20:00 <Olathe> Wow, throwing undefines in is a great debugging technique :)
14:20:04 <medfly> no one at all
14:20:12 <handonson> Cale: when I do that... ghc: panic! (the 'impossible' happened)  (GHC version 6.12.1 for i386-unknown-linux):	defaultDynFlags: No filesToClean
14:20:55 <Cale> hmm
14:21:09 <Cale> Oh, I also removed the defaultCleanupHandler for some reason
14:21:35 <handonson> Cale: oh, that works
14:21:40 <handonson> ...why?
14:22:07 <tomberek> I've done a rewrite of a graph library using concepts from the boost graph library, i'd like some feedback... This approach with more type classes seems to organize things better for me.  http://codepad.org/UXUL7LZv
14:22:25 <handonson> maybe because the two handlers are both trying to clean something?
14:22:28 <Cale> handonson: I removed it because it wasn't in the example
14:22:42 <Olathe> It appears that do { input <- getContents; L.pack input } where L is lazy ByteString doesn't work lazily. It waits until end of file on stdin.
14:22:53 <Cale> handonson: It also seems like you're changing the dynflags later?
14:23:10 <benmachine> Olathe: that's odd
14:23:12 <Cale> I got it working with Source.hs as a target
14:23:34 <benmachine> Olathe: have you considered alternatives to lazy IO?
14:23:36 <Cale> http://paste.lisp.org/display/114540
14:23:57 <Cale> Olathe: How is that not a type error?
14:24:01 <benmachine> Olathe: you don't have to, I just feel silly helping you do something if there's a better and different idea entirely you haven't thought of
14:24:19 <handonson> Cale: yeah, but apparently changing dynflags doesn't matter, because even after i erased that part it still crashed, so i think having two handlers is the problem
14:24:22 <Olathe> I was hoping to use lazy ByteStrings for their reputed speed.
14:24:42 <benmachine> Olathe: bytestrings are reputed for speed, I don't think lazy ones are particularly better?
14:24:44 <Olathe> Plus, I need lazy IO, since it's a sort of repeated response to input.
14:24:48 <Cale> Olathe: Use the getContents from the ByteString library
14:24:53 <benmachine> unless you've heard something I haven't which is very possible
14:24:58 <Olathe> I can't use getContents on Windows.
14:25:03 <benmachine> Olathe: how about iteratees and that sort of thing?
14:25:04 <Olathe> It fails due to a bug.
14:25:05 <Cale> ?
14:25:36 <Cale> Olathe: Which bug? I haven't heard anything about that.
14:25:52 <Cale> Olathe: That seems like it would break a lot of Haskell programs on Windows
14:26:08 <Olathe> Cale: http://hackage.haskell.org/trac/ghc/ticket/1276
14:26:19 <Olathe> This seems to affect me with lazy ByteString.
14:26:22 <tomberek> is anyone looking or should I just post to mailing list?
14:26:37 <Olathe> newsham got the same results earlier.
14:26:52 <deech> Hi all, I could probably roll one,  but is there a construct available to iterate through a list while keeping track of the index? 
14:26:56 <Olathe> benmachine: What are iteratees?
14:27:16 <Cale> Olathe: That's not a bug
14:27:22 <Olathe> deech: zip [0..] xs
14:27:32 <Olathe> Cale: What do you mean?
14:27:33 <Cale> Olathe: You can look at how it was immediately closed
14:27:40 <benmachine> Olathe: an idea Oleg came up with for getting the same benefits as lazy IO but without the unpredictability of resource usage
14:27:52 <benmachine> Olathe: there's a hackage package
14:27:57 <benmachine> they take a bit of getting used to
14:28:01 <benmachine> but they're kinda neat
14:28:07 <Olathe> Cale: See the very bottom of the closing message.
14:28:26 <Olathe> benmachine: Ahh, OK, I'll take a look :)
14:28:46 <Cale> Olathe: Oh, so you get an error about hGetBufNonBlocking?
14:28:51 <Olathe> Cale: Yeah :(
14:29:06 <benmachine> Cale: just out of curiousity, have you had a look at the newer iteratees API and do you like it any better?
14:29:16 <Cale> benmachine: Which one?
14:29:17 <Olathe> I tried to work around it with L.pack the result of IO's getContents, but that blocks until the end of file on stdin.
14:29:21 <benmachine> Cale: the 0.4 series
14:29:23 <tomberek> deech. something like:   func g (a:as) x =g a : func as (x+1)   ?
14:29:23 <Zao> The new Haddock style is a bit annoying. It tends to fold itself together if you click on what appears to be blank space.
14:29:26 <benmachine> it's not really different enough that I think you would
14:29:29 <benmachine> but I'm curious
14:29:46 <Zao> Click the browser area to focus it and you've got a decent chance of folding some instances/modules/whatnot section up :(
14:29:52 <tomberek> so.. graph library rewrite, anyone thoughts:   http://codepad.org/UXUL7LZv
14:29:53 <handonson> So, having more than one handler seems illegal, but even if that's the case, GHC'd better not panic. Or at least it'd better be documented... so... where should I report?
14:31:39 <Cale> benmachine: I can't really tell... it looks maybe slightly better, but it's still not elegant.
14:31:54 <benmachine> Cale: mm, okay
14:32:03 <deech> tomberek, Olathe : These are nice solutions, I just wondered if there was a pre-existing construct. Sometimes you want to know where you are along the iteration!
14:32:13 <benmachine> apparently John Lato came up with an implementation with no explicit chunking, but it's significantly slower
14:32:18 * benmachine shrugs
14:32:25 <Cale> mapStream :: (Monad m, ListLike (s el) el, ListLike (s el') el', NullPoint (s el), LooseMap s el el') => (el -> el') -> Enumeratee (s el) (s el') m a
14:32:50 <Cale> ^^ Does the analogue to List.map really need to have such a complicated type? :)
14:33:07 <tomberek> deech, i just learned today that that sort of recursion plays well with laziness, other than that, I guess tagging everything with zip might work
14:33:29 <Cale> It looks like maybe they could be making better use of the fact that GADTs can distribute class constraints? I don't know.
14:33:30 <imc> hello
14:33:35 <Cale> imc: hi!
14:33:38 <Olathe> Hello
14:33:40 <imc> :D
14:33:59 <mornfall> Cale: GADTs and class constraints aren't very foolproof, IME.
14:34:22 <tomberek> anyone need graphs? http://codepad.org/UXUL7LZv   i'm looking for ideas/complaints/feedback
14:34:28 <Cale> Also, the extraneous Monad m is still there.
14:34:56 <mornfall> Cale: I'd wish it wouldn't (need to have that hideous type sig).
14:35:32 <mornfall> Although I sort of see the point, I guess.
14:35:51 <benmachine> hmm I wonder who is using iteratees outside of IO
14:36:20 <mornfall> benmachine: I guess it'd make sense to use them in StateT IO.
14:36:21 <poucet> Completely offtopic, I'm afraid, but hoping someone might know. Anyone know a good game dev channel?
14:36:27 <mornfall> If nothing else.
14:36:41 <mornfall> (And other transforms of IO.)
14:37:50 <handonson> turns out i misread the documentation.
14:37:53 * handonson bangs his head against the wall
14:39:41 <tomberek> graph library, http://codepad.org/UXUL7LZv  thoughts,suggestions?
14:40:21 <Cale> underscores_bad, camelCaseGood ;)
14:40:46 <imc> uhm.. i'm trying to install 'himerge' cabal package from hackage, it says it needs "mozembed" but that cannot be found... any idea?
14:40:48 <tomberek> Cale: ok, that's an easy fix
14:41:59 <benmachine> imc: dependencies of hackage packages aren't required to be on hackage, you could try looking for it elsewhere
14:42:15 <Cale> tomberek: That looks pretty comprehensive otherwise. I'd need to see some instances to be sure...
14:42:39 <tomberek> cale: one moment...
14:43:05 <monochrom> underscores_good, primes'even'better, camelWhat?
14:43:39 <Cale> imc: hmm...
14:44:04 <tomberek> Cale, monochrom: here's an instance i threw together  http://codepad.org/VqMw3mQH   i haven't played with making it look pretty yet, i know ivanm is way better at that
14:44:44 <imc> benmachine: i tried, with no luck
14:44:45 <Cale> tomberek: Looks decent to me, anyway :)
14:44:52 <Susefreak> Hi. I am having issues installing Haskell on OSX.
14:45:17 <Cale> imc: Do you have gtk2hs installed?
14:45:39 <Susefreak> When installing it spits out an error about running a postupgrade script
14:45:47 <imc> Cale: not yet
14:45:49 <Cale> Susefreak: I take it you're using http://darcs.haskell.org/download/dist/6.12.3/GHC-6.12.3-i386.pkg ?
14:46:46 <Cale> imc: You'll need to install it first before you can build himerge. Which platform are you on?
14:46:54 <Cale> Oh, Gentoo, obviously
14:47:04 <imc> :D
14:47:05 <Susefreak> I guess that's the same as this one right? http://hackage.haskell.org/platform/
14:47:12 <imc> building now
14:47:23 <Cale> imc: So make sure the development packages for gtk and mozembed are installed, and then install gtk2hs using cabal
14:47:25 <tomberek> Cale: well, printing, Show instances, etc...    I am thinking something like this lays out a step by step path for any graph implementation writer to follow.  Made it easier for me anyway.  So with a solid base, and lots of implementations that are refined for different applications, it could be useful.
14:47:27 <Cale> Actually...
14:47:43 <Cale> cabal install gtk2hs-buildtools
14:47:45 <Cale> and then gtk2hs
14:48:34 <Cale> Susefreak: Well, it's not...
14:48:50 <Cale> Susefreak: I haven't tried that one.
14:49:08 <Cale> Susefreak: The Haskell Platform is GHC + a bunch of starter packages
14:49:19 <imc> Cale: thanks
14:49:58 <Susefreak> So I should install the one you posted to see if I get the same results
14:50:34 <Cale> Susefreak: Well, give it a try. If it works, we can work on installing cabal-install separately, and then from there you can get whatever packages you may need easily using cabal
14:50:55 <imc> Cale: you also answered a question i didn't asked: what the most used/common/easy/tested way to build GUIs in haskell :D
14:51:31 <imc> Cale: gtk2hs does not exists on hackage, gtk do
14:51:37 <Susefreak> Allright, cheers, waiting for the DL to finish right now
14:51:50 <Cale> imc: oh, right
14:51:54 <Cale> imc: sorry about that :)
14:51:56 <imc> (still complains about mozembed)
14:52:05 <imc> Cale: no need to be sorry
14:53:02 <imc> the only thing that look like "mozembed" on gentoo are python/perl/ruby bindings
14:54:04 <Cale> imc: Yeah, I was thinking that either it would be a conditionally compiled part of the gtk package or it would be available as a separate package on Hackage, but I don't see it there.
14:54:45 <tomberek> Cale: what do you suggest next? i was going to write some instances, perhaps add quickCheck code
14:55:31 <Cale> tomberek: Well, instances are the best way to make typeclasses useful :)
14:56:55 <tomberek> Cale: is this something that you'd think would be used, or should we stick with the main FGL line?
14:57:05 <Cale> imc: When you built the gtk package, did you see at some point during configuration a list of features each followed by "yes" or "no" (glib, gtk, gio, glade, cairo, ...)
14:57:19 <Cale> imc: mozembed would be among them
14:58:06 <jeltsch> Cale: If you build Gtk2Hs from the monolithic source bundle, then this would be the case.
14:58:31 <Cale> jeltsch: Yeah, I'm more familiar with that process than the new cabalised one.
14:58:54 <jeltsch> Cale: When using Cabal packages, you don’t enable features with flags. You already have separate packages gtk, gconf, … on Hackage.
14:58:59 <Cale> jeltsch: Do you happen to know where imc can get mozembed?
14:59:26 <jeltsch> Cale, imc: If it’s not on hackage then no. :-( 
15:00:23 <Cale> I guess it was last updated in 2008... perhaps someone should update it to use the webkit package.
15:00:38 <jeltsch> imc: Maybe you should ask on the Gtk2Hs mailing list why mozembed isn’t on Hackage.
15:01:09 <jeltsch> Cale: Isn’t webkit Qt-based?
15:01:10 <Cale> Apparently mozembed was considered deprecated, but there are still packages which rely on it, so it's a bit unfortunate that they wouldn't have built it.
15:01:17 <Cale> http://hackage.haskell.org/package/webkit
15:01:20 <Cale> ^^ seems not
15:01:56 <Susefreak> Cale: GHC installed without a hitch
15:02:07 <Cale> Susefreak: Okay, great...
15:02:27 <Cale> Susefreak: now you'll want to get http://hackage.haskell.org/packages/archive/cabal-install/0.8.2/cabal-install-0.8.2.tar.gz
15:02:54 <Cale> Susefreak: Unpack that and then run the bootstrap.sh script
15:03:36 <Cale> (Unfortunately, not a pretty GUI installer, but it should work anyway ;)
15:04:01 <Susefreak> No worries, can handle CLI work ;)
15:05:14 * hackagebot split 0.1.2.1 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.2.1 (BrentYorgey)
15:05:29 <Mitar> is there a way to write "when (gets target >>= isJust) ..." or something similar?, when required Bool and not m Bool
15:06:03 <Susefreak> Cale: Installed that too
15:06:27 <monochrom> gets target >>= \b -> when b isJust  ???
15:06:41 * Zao fmaps
15:06:52 <Zao> fmap seems to be the answer to life, the universe and everything.
15:06:54 <monochrom> oh, (gets target >>= isJust) >>= \b -> when b ...
15:07:09 <Cale> Susefreak: great. Now you'll want to do whatever is necessary to add ~/.cabal/bin to your PATH, and you can use the cabal binary from there to install packages as listed on Hackage
15:07:13 <Zao> @type fmap when
15:07:14 <lambdabot> forall (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f Bool -> f (m () -> m ())
15:07:19 <Zao> Close :D
15:07:24 <Cale> Susefreak: "cabal install <packagename>"
15:07:27 * sm fnaps
15:07:35 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html -- there are lots of packages available
15:07:40 <Mitar> gets target >>= \t -> when (isJust t)
15:07:50 <Zao> Cale: Or if you've got a perfectly fine ~/bin, point cabal-install's config there.
15:07:57 <Cale> Zao: yeah
15:08:01 <monochrom> @pl x >>= \b -> when b y
15:08:01 <lambdabot> flip when y =<< x
15:08:20 <monochrom> @pl x >>= \b -> when (f b) y
15:08:21 <lambdabot> flip when y . f =<< x
15:08:29 <Cale> Actually, what I tend to do is to move everything from ~/.cabal/bin to ~/bin and then replace ~/.cabal/bin with a symlink to ~/bin
15:08:45 <illissius> jeltsch: in the beginning there was KHTML which was Qt-based, then Apple forked it into WebKit and made a Qt emulation layer (API wrapper) so it'd work on Mac, *then* later on they opened up the development process, and also abstracted out the platform-specific bits, and one of the backends that got added was Qt
15:09:14 <Cale> illissius: (and GTK presumably)
15:09:36 <illissius> Cale: "one of" so yeah :)
15:09:36 <Philonous> Mitar: "whenM p b = p >>= \p -> when p b" then you can write "wheM (isJust <$> gets target) doStuff". I find this function quite handy. Similarly I often have "ifM p a b = p >>= \p -> if p then a else b"
15:09:51 <illissius> also EFL, Windows, MacOS itself, and probs. others I'm forgetting
15:10:20 <Susefreak> Cale: so cd to ~/.cabal/bin, get a symlink in there for ~/bin and get the packages from hackage. Any tips for starters?
15:10:35 <Zao> Cale: Slightly more elegant, and gets you past getting hold of a config in the first place.
15:11:11 <Mitar> thanks
15:11:34 <Cale> Susefreak: Well, I mean, what I do is to  mv ~/.cabal/bin/* ~/bin/  and then ln -sf ~/bin ~/.cabal/bin
15:11:52 <Cale> er, hopefully that's what I mean -- always have to be careful with the ln command
15:12:08 <monochrom> indeed you do have them reversed
15:12:10 <Cale> I mean actually replace the directory ~/.cabal/bin with a symbolic link
15:12:20 <Susefreak> Yeah just did that
15:12:21 <monochrom> oh wait, you have them right.
15:12:30 <Susefreak> :D
15:14:27 <Cale> Susefreak: So, let's see... try  cabal update && cabal install network
15:15:01 <Cale> another one which is strangely off in its own package now is  parallel
15:15:12 <Cale> and you'll most likely end up wanting  mtl  at some point
15:15:19 <Cale> and text
15:15:48 <Cale> QuickCheck
15:16:06 <Cale> maybe  parsec  too :)
15:17:04 <nominolo> :t fmap fmap fmap
15:17:05 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:18:06 <nominolo> > fmap fmap fmap (+2) (Just [3,4])
15:18:07 <lambdabot>   Just [5,6]
15:20:25 <copumpkin> -XIdiomBrackets when can you be mine!?
15:20:36 * copumpkin weeps
15:20:46 <Susefreak> sorry was afk, allright is running the first command right now
15:20:54 <Susefreak> just finished
15:20:58 <copumpkin> I don't want to use SHE, but I might
15:22:27 <Susefreak> so how'd do I get mtl, text, QuickCheck and parsec?
15:22:55 <nominolo> :t fmap . fmap
15:22:55 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:23:23 <Mitar> Non-exhaustive patterns in record update? hm, it is not possible to update multiple fields at the same time in record?
15:23:32 <nominolo> Susefreak: cabal install mtl text 'QuickCheck >= 2' parsec
15:26:07 <Susefreak> Thanks got that, now for running a program it's just using cabal $file.haskel or not?
15:26:43 <Mitar> vau, new hackage documentation style is really great ;-)
15:26:57 <nominolo> thanks
15:27:10 <Mitar> good work
15:27:40 <nominolo> well, actually lots of refinements were done by tibbe and mtnviewmark
15:28:32 <Mitar> just that ghc documentation would not 404 all the time ...
15:31:28 <nominolo> Mitar: from hoogle?
15:34:18 <Mitar> from what google finds ;-)
15:35:21 <Mitar> not always
15:35:30 <Mitar> but with all those versions and documentation for that
15:35:40 <Mitar> it happens that some links are 404
15:37:48 <Martty`o_O`> i really feel like learning haskell
15:38:00 <Martty`o_O`> damn if only handling unpure code didnt scare me so much
15:38:06 <Martty`o_O`> oh well, i'll leave it for next time
15:45:00 <bss03> Hrm, is there something like a "local hoogle".
15:45:17 <bss03> I have some code I pulled from git, and I think there's a function with a specific signature that I need.
15:45:30 <bss03> I have hoping to be able to grep the new code "by signature".
15:45:37 <dankna> hoogle can run as a CLI tool yes
15:45:44 <dankna> I think cabal can build hoogle databases, though I'm not sure how
15:47:30 <Saizan> it can give you an hoogle file with cabal haddock --hoohle
15:47:38 <Saizan> --hoogle
15:49:26 <bss03> Hrm, I don't have the hoogle CLI as a package in my distribution.  Once I install the cabal package is there anything special I need to do to get the CLI interface?
15:49:54 <fxr> uhm regexps are looks complicated
15:51:24 <tommd> bss03: cabal install hoogle
15:51:34 <tommd> its a hackage package
15:51:56 <tommd> And the ticket for the feature dankna was referring too is http://hackage.haskell.org/trac/hackage/ticket/402
15:52:21 <benmachine> bss03: as far as I recall it didn't need any setup
15:53:32 <dankna> oh - hmm, I didn't realize that feature didn't exist yet hmm
15:55:02 <bss03> Looks like I need to add ~/.cabal/bin to my PATH.
15:57:41 <fxr> which one is the fastest way to match and collect email addresses, parser combinators or regexps?
15:57:47 <bss03> After I "haddock --hoogle" my file, how do I add that to the hoogle DB?
15:57:53 <bss03> I don't see a .hoo file.
15:58:14 <Saizan> you use the hoogle cli to make a .hoo file out of the .txt one
15:58:41 <bss03> Hrm, I don't think I got a .txt file either. :(
15:59:14 <tommd> cabal haddock --hoogle will put one in the projects dist/ directory (See the std output)
15:59:16 <Saizan> somewhere under dist, didn't you get a message with the path from cabal haddock?
15:59:49 <sm> fxr: regexpr plus an email regexp from the net may be the easiest to start with
15:59:49 <bss03> Oh, I was just using "haddock" directly, not the cabal sub-command.
16:00:07 <Mitar> what does "Non-exhaustive patterns in record update" mean?
16:00:13 <bss03> I'm not building this with cabal, so I don't have a .cabal file. :(
16:00:22 <sm> or did you mean fastest at processing data 
16:01:02 <bss03> Mitar: The means one of your record updates will fail when used on certain data.
16:01:10 <fxr> sm: yeah I mean fastest at processing files
16:01:20 <bss03> Mitar: There's more information in the GHC manaull on in the ranings documentation.
16:02:34 <sm> good question. I can only say attoparsec's supposed to be faster than parsec, and regex-pcre's probably faster than regexpr
16:03:18 <sm> regular folks would consider them all fairly fast
16:04:35 <tomberek> Saizan
16:04:52 <fxr> sm: thank you
16:05:12 <Saizan> tomberek: ?
16:05:55 <Philippa> sm: that depends who you think 'regular folks' are in this context, really. For someone munging large quantities of data, there's good odds on the point of comparison being something like perl
16:06:27 <tomberek> can you take a look at something,, offer some advice, opinions, suggestions?
16:06:51 <Philippa> there've been people on -cafe who found the shift from parsec 2 to (pre-optimisation) parsec 3 resulted in significant wall clock time differences for them
16:07:29 <Saizan> tomberek: i don't promise any useful feedback but ok :)
16:07:34 <tomberek> Saizan: http://codepad.org/fXLYrcKc
16:07:35 <Philippa> fxr: my money's on regexes with an external lib, but I'd be pleased to be surprised and I've not benched it
16:08:06 <Saizan> iirc regex-tdfa is supposed to be quite fast
16:08:37 <fxr> Saizan: but it only supports posix ere
16:08:40 <sm> it also depends on your regexps
16:08:46 <tomberek> Saizan: i drew some inspiration from the boost graph library, and ended up with something where a graph instance writer is led along an easier path to make a graph implementation... nicely organized typeclasses
16:09:03 <roconnor> "Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?" 
16:09:28 <Philippa> sm: and your combinator grammar, naturally
16:13:18 <fxr> I don't understand
16:14:15 <tomberek> .
16:15:01 <fxr> I can write a parser for email syntax, it will compile and run fast. Also I can write a matcher with regexp, it will also compile and run fast. So which one should I choose in which situation?
16:15:35 <Peaker> fxr, parsec parser would probably be fast enough but when parse fails it will have nicer error diagnosis
16:16:06 <Peaker> But parsec is monadic, monadic parsers (of that style, anyway) cannot really compile to O(N) parsers
16:16:27 <Peaker> An Applicative parser (with some more combinators) could do that.. but parsec is fast enough for most purposes
16:17:00 <mauke> fxr: you can't write a matcher with regexp
16:17:11 <fxr> you mean I have to take care of bandwith rather than agoritm performance?
16:17:53 <Saizan> tomberek: i'm quite skeptic about the number of classes and methods, do you really need all these primitives? is it to allow faster specialized implementations?
16:18:26 <fxr> mauke: let matcher = (=~ "(foo|bar)") in ...
16:18:39 <mauke> oh, I mean for email addresses
16:18:50 <fxr> mauke: why not?
16:18:55 <IceDane> I'm trying to use quickcheck as RWH does it to do some unit testing, but as far I understand from the comments the latest suite changed operator ==> in quickcheck. How would I use it for a prop -> Int -> Int -> Bool to make sure that neither of the integers is 0?
16:19:01 <mauke> because last time I looked the grammar was non-regular
16:19:21 <dara> What's haskell used for?
16:19:27 <tomberek> Saizan: no, i'm going to go back and give defaults to much of them,, they are there because graphs lend themselves to a wide array of sepcializations
16:19:28 <dmwit> Also because email addresses have several layers of cruft due to changing several times over the years.
16:19:29 <mauke> dara: writing programs
16:19:41 <Philippa> Peaker: actually parsec /can/ be O(N), it's LL(1) by default
16:19:42 <dmwit> dara: for what ails ya
16:19:52 <dara> What makes it different from, say, Java?
16:19:53 <tomberek> Saizan: though it seems like a lot, it's no more than what's in FGL
16:20:02 <Peaker> Philippa, Well, it has combinators that ruin it but in Applicative style combinators, wouldn't have to
16:20:04 <Philippa> that said, regexes are the way to go if that's the format you've already got stuff in, this smells like a regex task to me
16:20:13 <Phyx-> evening haskellers
16:20:13 <Peaker> mauke, regexps are regular?
16:20:26 <Philippa> mauke: "regex" doesn't mean "regular expression"/"thing that denotes a regular language"
16:20:37 <tomberek> Saizan: and it's organized a bit better I think in that class structure, keeps each task smaller... at least it made it easier for my, i hope for others as well
16:21:05 <mauke> Philippa: nesting is still hard in most regex dialects
16:21:06 <Peaker> dara, It separates computation from actions, has very different semantics, has features Java doesn't, very different grammar, ...
16:21:09 <mauke> and/or impossible
16:21:10 <bremner> @where lyah
16:21:11 <lambdabot> http://www.learnyouahaskell.com/
16:21:14 <bremner> ^dara
16:21:50 <Phyx-> :t 9
16:21:51 <dara> Peaker: Hm.. that's cool
16:21:51 <lambdabot> forall t. (Num t) => t
16:21:56 <Phyx-> :t is
16:21:57 <lambdabot> Not in scope: `is'
16:22:19 <Phyx-> :t id
16:22:20 <lambdabot> forall a. a -> a
16:22:49 <Phyx-> :t ((+) on)
16:22:50 <lambdabot> forall b c a. (Num c) => ((b -> b -> c) -> (a -> b) -> a -> a -> c) -> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:22:51 <Phyx-> :t ((+) on)
16:22:52 <lambdabot> forall b c a. (Num c) => ((b -> b -> c) -> (a -> b) -> a -> a -> c) -> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:22:57 <Phyx-> whoops
16:23:02 <hpc> whoa
16:23:13 <hpc> what the fresh hell happened there?
16:23:21 <Phyx-> i typed it twice
16:23:24 <mauke> the usual stuff
16:23:25 <Philippa> mauke: I'm pretty sure you can get at least a good approximation of matching an email address without any nesting required
16:23:29 <hpc> i mean with the type being huge
16:23:32 <Peaker> dara, Dare I say Haskell is a far more interesting and more mind-expanding language than Java :-)  It also requires a lot less code to achieve most of the same tasks.  It of course is less mainstream and has disadvantages as a result
16:23:42 <Phyx-> :t ((+) `on` (-))
16:23:43 <lambdabot> forall a. (Num a) => a -> a -> a -> a
16:23:45 <fxr> hmp
16:23:48 <Cale> hpc: Well, on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:23:49 <kmc> dara left...
16:23:50 <Cale> :t on
16:23:51 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:23:57 <mauke> Philippa: yes, and it's 4k bytes long
16:24:03 <Phyx-> > ((+) `on` (-)) 8 7 6
16:24:04 <lambdabot>   3
16:24:09 <Cale> and (+) :: (Num t) => t -> t -> t
16:24:17 <Cale> So unify the type of on with t
16:24:24 <Cale> and you get a pretty big type
16:24:44 <Cale> The reason that the context is small is because there's an instance of Num for functions
16:24:57 <Cale> So it only requires the codomain to be an instance of Num
16:25:19 <hpc> oh wait, i see what happened
16:25:28 <hpc> :t ((+) `on`)
16:25:30 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> a -> b
16:25:54 <hpc> the section with the huge type was (on +)
16:25:59 <Phyx-> yes
16:26:38 <Phyx-> :t email
16:26:39 <lambdabot> Not in scope: `email'
16:26:51 <Phyx-> does lambdabot have easter eggs?
16:26:57 <hpc> email :: (Spam -> Spam) -> Spam
16:28:35 <Phyx-> trying to find an unsanswered haskell question on stackoverflow is like trying to find a lambda in GHC
16:28:51 <hpc> lol
16:28:54 <fxr> last time I read rfc 822 I thought that it is impossible to match a string as email.
16:28:59 <fryguybob> @vixen do you have any easter eggs?
16:28:59 <lambdabot> maybe. do you?
16:29:23 <fxr> implementing 822 is pain in the ass
16:29:23 <IceDane> Did they remove verboseCheck from quickCheck? o.o
16:29:32 <Adamant> fxr: it's not impossible, just brutally hard to do it right
16:29:40 <Adamant> so most people don't do it right
16:29:59 <Adamant> also, a lot of the complexity is from legacy systems
16:30:07 <fxr> yeah
16:30:09 <Adamant> which you can ignore in a pinch
16:30:27 <Adamant> especially in 2010
16:34:43 <maltem> IceDane, QuickCheck 1 and 2 are really quite different beasts
16:35:59 <IceDane> maltem: It would indeed seem so. Is one better than the other, or are they just different?
16:36:41 <kmc> does GHC support pragmas to turn off warnings for individual source code locations?
16:37:08 <maltem> IceDane, Not sure, I think the point of v2 is to provide more features (even if that should seem contradictory to your first question)
16:37:33 <tomberek> Saizan: i'm going back over, filling in defaults,, but most of those defaults are easy, packers, constructors, unpackers, etc.. easy stuff for an implementor
16:38:34 <sm> fxr: oh you're matching whole messages, I assumed just email addresses
16:39:16 <tomberek> kmc: would you be interested in taking a look at the graph library I co-opted from Boost? i could use opinions,pointers,suggestions...
16:39:36 <sm> well if you need it, I've got a regex that matches mbox From separators :)
16:40:36 <tomberek> or anyone else with ideas    http://codepad.org/D7nkyZBM
16:40:47 <sm> surprised if there isn't a lib for this on hackage, btw
16:42:50 <fxr> sm: actually simons' package may include them
16:43:11 <sm> simons' package ? 
16:43:27 <sm> there's http://hackage.haskell.org/packages/archive/mbox but I'm not sure how robust that can be
16:43:46 <fxr> sm: hsemail
16:44:00 <sm> ah nice
16:45:23 <tolkad> If I'm using STM and I run something "atomically" does that mean atomically relative to all other threads that call atomically? or all other threads? or all other threads using atomically that access some STM data structure shared between the two atomic blocks
16:45:24 <tolkad> ?
16:47:09 <ManateeLazyCat> tolkad: STM use thread log, all do just care current thread, if current thread write conflict with other threads, it will restore value and *re-execute*.
16:47:27 <tolkad> ManateeLazyCat: sorry, "all do just care"?
16:47:56 <kmc> tolkad, ManateeIrcClient is talking about implementation, not semantics
16:47:59 <tolkad> ManateeLazyCat: it's ok I think I understood you
16:48:08 <kmc> tolkad, if one thread runs "atomically x" and another "atomically y" then x and y are atomic with respect to each other
16:48:09 <Mitar> is there some better way to block thread until an exception arrives?
16:48:09 <Mitar> newEmptyMVar >>= takeMVar
16:48:24 <kmc> forever (threadDelay maxBound)
16:48:42 <kmc> tolkad, furthermore, there's no way to run an STM action except from IO using "atomically"
16:48:47 <kmc> (excluding unsafe low level hacks)
16:49:56 <kmc> likewise there's no way for an STM action to affect state that's observable outside STM (same caveat)
16:49:57 <Peaker> Mitar, that's dangerous as it might trigger some deadlock detection?
16:50:24 <tolkad> kmc: in GHCs implementation though, do I have to worry about one use of atomically blocking all other uses globally?
16:50:25 <Mitar> why it would?
16:50:41 <ManateeLazyCat> tolkad: No, you don't 
16:50:55 <tolkad> ok good it seems easy enough to use then
16:50:58 <Peaker> Mitar, I'm not sure what the rules are for deadlock detection
16:51:03 <Peaker> Mitar, but I think it might
16:51:40 <tolkad> Mitar: a better solution would be to block it on reading an MVar ()
16:52:00 <kmc> isn't that what "newEmptyMVar >>= takeMVar" does?
16:52:05 <kmc> (assuming you default the ambiguous type variable to ())
16:52:27 <tolkad> ooh better idea
16:52:35 <tolkad> an MVar holding an exception
16:52:35 <kmc> tolkad, GHC's implementation is optimistic and lock-free.  the thing to worry about is "livelock", where two threads interrupt each other's transactions and prevent either from finishing
16:52:47 <kmc> in those situations, locking can perform much better
16:52:54 <kmc> what's wrong with «forever (threadDelay maxBound)»
16:53:08 <tolkad> kmc: it might trigger deadlock detection
16:53:18 <kmc> how?
16:53:22 <ManateeLazyCat> tolkad: STM is lock-free.
16:53:23 <tolkad> kmc: no idea, Peaker said so
16:53:32 <kmc> tolkad, i thought Peaker meant that the MVar solution might
16:53:40 <kmc> since the garbage collector can see which MVars are reachable
16:53:48 <tolkad> kmc: oh
16:53:53 <tolkad> nevermind then
16:53:57 <kmc> and if a var is reachable only from one thread, which is blocking on it
16:54:00 <Peaker> Yeah, I was referring to the MVar one
16:54:01 <kmc> then it will send that thread an exception
16:54:07 <ManateeLazyCat> tolkad: Just sometimes you need use MVar instead STM for better performance, STM will waste some time on *re-execute*.
16:54:37 <kmc> it'd be great if GHC's STM had an adaptive implementation that could use locks if it detects high contention
16:55:03 <tolkad> kmc: in a livelock, GHC starts the whole atomic operation over again or just the interrupted STM operation?
16:55:29 <kmc> tolkad, a transaction runs through from beginning to end, writing to a local buffer.  then it checks if anything else touched those vars
16:55:33 <kmc> if so, it will retry
16:55:37 <tolkad> -_-
16:55:50 <c_wraith> That means two transactions *can* livelock indefinitely
16:55:52 <Martty`o_O`> anyone have any particularly recommended readings on monads and understanding IO in haskell?
16:55:52 <Peaker> If STM was Applicative and not Monad, GHC could even use CPU-atomic operations in some cases rather than locks (lockless updates using locked-bus CMPXCHG and such)
16:55:59 <Martty`o_O`> (for beginners)
16:56:04 <Martty`o_O`> be..ggin..er..
16:56:06 <kmc> Martty`o_O`, "monads" and "understanding IO in Haskell" are two nearly unrelated topics
16:56:17 <Peaker> Martty`o_O`, You can understand IO first, and worry about monads later
16:56:26 <c_wraith> IO in haskell is much easier to learn than the monad generalization
16:56:34 <Martty`o_O`> i think i want to understand monads first
16:56:45 <tolkad> kmc: it seems that deciding whether to use GHC STM requires some thought
16:56:48 <c_wraith> I think you won't understand the abstraction until you've used it for a while
16:56:50 <Martty`o_O`> i guess its not a good idea. alright then
16:57:02 <c_wraith> read the LYAH chapter on IO
16:57:06 <Peaker> Martty`o_O`, http://learnyouahaskell.com/input-and-output
16:57:06 <c_wraith> @where LYAH
16:57:07 <lambdabot> http://www.learnyouahaskell.com/
16:57:11 <mauke> Martty`o_O`: understanding monads is pointless
16:57:20 <copumpkin> what's the nicest way to write select :: [a] -> [Bool] -> [a] were the bools are zipped with the elements and decide which are kept and which aren't
16:57:29 <Peaker> Martty`o_O`, Understanding a generalized concept before understanding a few examples of it is very difficult!
16:57:38 <Martty`o_O`> i see
16:57:42 <kmc> Martty`o_O`, furthermore, IO is a weird, atypical example of a monad
16:57:58 <kmc> Martty`o_O`, for understanding IO i recommend http://haskell.org/haskellwiki/Introduction_to_IO
16:57:59 <Martty`o_O`> thanks everyone
16:58:04 <kmc> for monads, probably Typeclassopedia
16:58:13 <Peaker> copumpkin, first, flip that type :)
16:58:14 <Martty`o_O`> ill read this one and LYAH
16:58:19 <copumpkin> Peaker: fine :P
16:58:28 <copumpkin> Peaker: although, for my use, the order I gave is more useful
16:58:29 <tolkad> Martty`o_O`: Monads are used for automating some behavior of a sequence of things
16:58:31 <Peaker> copumpkin, map snd . filter fst . zip
16:58:34 <Peaker> copumpkin, ?
16:58:37 <kmc> Martty`o_O`, but beware the trap of trying to figure out "what monads are".  what they are is simply an API, the set of things implementing that API is very broad
16:58:45 <kmc> hard to give a nice concrete description of that set
16:58:47 <copumpkin> Peaker: that's simple enough :) I should've thought of it!
16:58:52 <roconnor> zipWith (flip guard)
16:59:00 <roconnor> @type zipWith (flip guard)
16:59:01 <lambdabot> forall a. (MonadPlus ((->) a)) => [a] -> [Bool] -> [()]
16:59:07 <roconnor> hmm
16:59:33 <kmc> hmm, will (map snd . filter fst) fuse into a single traversal?
16:59:48 <Peaker> I would hope so
16:59:49 <tolkad> Does it annoy anyone else that Monad instances need to implement "fail"?
16:59:51 <roconnor> @type zipWith (flip when)
16:59:52 <lambdabot> forall (m :: * -> *). (Monad m) => [m ()] -> [Bool] -> [m ()]
16:59:57 <Peaker> kmc, I don't like operational semantics in my simple programs!
17:00:02 <roconnor> @type zipWith (flip when . return)
17:00:03 <lambdabot> forall (m :: * -> *). (Monad m) => [()] -> [Bool] -> [m ()]
17:00:06 <benmachine> tolkad: they don't *need* to, fail = error works fine
17:00:10 <copumpkin> Peaker: you missed a composition!!
17:00:11 <benmachine> tolkad: but yes it does
17:00:15 <copumpkin> Peaker: I WILL NEVER FORGIVE YOU
17:00:19 <kmc> tolkad, you're right that the choice of concurrency system requires some thought.  simon marlow had a presentation comparing various implementations of a concurrent stack, and found that a simple IORef [a] performed best
17:00:21 <Peaker> copumpkin, which one?
17:00:23 <copumpkin> Peaker: select = ((map fst . filter snd) .) . zip
17:00:28 <kmc> atomicModifyIORef is cheaper than anything with MVar and STM
17:00:29 <Peaker> copumpkin, oooh
17:00:39 <Peaker> copumpkin, I hate that form :)
17:00:40 <copumpkin> Peaker: okay fine, I'll forgive you, just this once
17:00:44 <copumpkin> Peaker: :P
17:00:45 <roconnor> copumpkin: ugh, pairs
17:00:45 <kmc> and the beauty of immutable data is that you can "snapshot" it for free and use the snapshot locklessly
17:00:47 <copumpkin> okay, use :.
17:00:50 <copumpkin> roconnor: yeah, ugh!
17:00:50 <Peaker> copumpkin, (result . result) (map fst . filter snd)
17:00:59 <Peaker> (result . result) (map fst . filter snd) zip
17:01:07 <copumpkin> lol
17:01:10 <tomberek> hey copumpkin, kmc, benmachine, anyone really... looking for feedback on a different style graph library http://codepad.org/D7nkyZBM
17:01:14 <wli> RCU-ready at all times.
17:01:26 <roconnor> @type zipWith (\a b -> guard b >> return a)
17:01:27 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> [Bool] -> [m a]
17:01:31 <benmachine> :O someone wants me feedback
17:01:33 * benmachine feels important
17:01:38 <copumpkin> roconnor: you can't escape the monad of doom!!!
17:01:40 <roconnor> @type join . (zipWith (\a b -> guard b >> return a))
17:01:41 <lambdabot>     Couldn't match expected type `[Bool] -> m a'
17:01:41 <lambdabot>            against inferred type `[m a]'
17:01:41 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
17:01:43 <ManateeLazyCat> @hoogle atomicModifyIORef
17:01:43 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
17:01:53 <benmachine> tomberek: different from?
17:01:55 <roconnor> @type (join .) . (zipWith (\a b -> guard b >> return a))
17:01:55 <lambdabot> forall a. [a] -> [Bool] -> [a]
17:02:02 <copumpkin> zomg
17:02:03 <Peaker> roconnor, heh
17:02:20 <tomberek> benmachine, from FGL
17:02:27 <benmachine> oh, I haven't used fgl
17:02:29 <copumpkin> will it know what monad to use?
17:02:38 <roconnor> yes
17:02:42 <roconnor> zipWith says so
17:02:50 <copumpkin> ah fair enough, yeah
17:02:55 <c_wraith> kmc: atomicModifyIORef didn't perform well under contention last time I tried.  an MVar was better under really heavy contention.
17:03:01 <roconnor> finally, a use for join
17:03:04 <copumpkin> lol
17:03:07 <tomberek> benmachine: well, can you take a look, tell me what is confusing, what is going to need a lot of documentation, if you would use it for your graph needs?
17:03:09 <c_wraith> maybe it has a better implementation since i tried last
17:03:20 <benmachine> tomberek: I don't really have many graph needs :P
17:03:37 <ManateeLazyCat> If you use STM with wrong way, you will got infinite loop....
17:03:42 <ManateeLazyCat> And never stop.
17:03:51 <benmachine> hmm I wonder if I should implement my step evaluator with explicit graphs
17:03:53 <tomberek> benmachine:  hm... well, get some
17:03:56 <benmachine> giggle
17:03:57 <roconnor> copumpkin: I wonder if my code fuses?
17:04:09 <copumpkin> hmm, beats me :)
17:04:12 <tomberek> yeah! graphs!
17:04:26 <roconnor> copumpkin: I was going to use catMaybes, but join seemed to get to the heart of the matter :D
17:04:26 <c_wraith> @pl \a b -> guard b >> return a
17:04:26 <lambdabot> flip ((>>) . guard) . return
17:04:36 <copumpkin> :P
17:04:38 <c_wraith> eww, that's ugly
17:04:40 <roconnor> @pl (join .) . (zipWith (\a b -> guard b >> return a))
17:04:40 <lambdabot> (join .) . zipWith (flip ((>>) . guard) . return)
17:04:56 <benmachine> @pl \b a -> guard b >> return a
17:04:57 <lambdabot> (. return) . (>>) . guard
17:05:07 <c_wraith> that's less ugly
17:05:13 <c_wraith> Though still pretty bad :)
17:05:17 <roconnor> that's kinda pretty looking
17:05:20 <benmachine> heh
17:05:31 <c_wraith> :t (. return)
17:05:32 <lambdabot> forall b a (m :: * -> *). (Monad m) => (m a -> b) -> a -> b
17:05:34 <roconnor> you know, forgetting about understanding it
17:05:41 <roconnor> nice placement of dots
17:06:06 <benmachine> > ((join .) . zipWith (flip ((>>) . guard) . return)) [True, False, True, True, False, False, True] [1 ..]
17:06:06 <c_wraith> ... that is a bizarre type signature.
17:06:07 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
17:06:07 <lambdabot>    arising from the literal `1'...
17:06:12 <benmachine> eeerm
17:06:23 <benmachine> > ((join .) . zipWith (flip ((>>) . guard) . return)) [1 ..] [True, False, True, True, False, False, True]
17:06:24 <lambdabot>   [1,3,4,7]
17:06:30 <benmachine> woo
17:06:44 <c_wraith> Oh, I see.  It makes enough sense.  But it's still bizarre. :)
17:07:13 <c_wraith> :t ((>>=), (. return))
17:07:14 <lambdabot> forall (m :: * -> *) a b b1 a1 (m1 :: * -> *). (Monad m, Monad m1) => (m a -> (a -> m b) -> m b, (m1 a1 -> b1) -> a1 -> b1)
17:07:16 <tolkad> benmachine: I hate trying to understand those
17:07:35 <benmachine> those?
17:07:57 <tolkad> when people combine 6+ functions
17:07:58 <tolkad> :P
17:08:00 <benmachine> oh
17:08:04 <benmachine> programs :P
17:08:39 <c_wraith> pointfree expressions, I think
17:08:46 <tolkad> I guess it probably gets better with more FP experience
17:08:57 <c_wraith> I really wish .. wasn't a reserved token
17:09:29 <c_wraith> because I really want to define f .. g = \x y -> f (g x y)
17:09:55 <Cale> map fst . filter snd . zip [1..] $ [True, False, True, True, False, False, True]
17:09:58 <Cale> > map fst . filter snd . zip [1..] $ [True, False, True, True, False, False, True]
17:09:59 <lambdabot>   [1,3,4,7]
17:10:46 <Cale> > [k | (k,x) <- zip [1..] [True, False, True, True, False, False, True], x]
17:10:47 <lambdabot>   [1,3,4,7]
17:12:03 <tomberek> swift... you at berkeley?
17:12:14 <tomberek> i was there a while ago
17:12:38 <roconnor> Cale: ugh, pairs
17:12:39 <Draconx> c_wraith, ·· is available.
17:12:50 <Cale> What's wrong with pairs?
17:13:03 <roconnor> lots of memory
17:13:08 <roconnor> pairing
17:13:10 <roconnor> unpairing
17:13:14 <roconnor> time consuming
17:13:18 <tommd> Wahoo, more proposals to l@h.o.  Change the world, start with old crufty libraries.
17:13:34 <Cale> There's at most one live pair at any time in the production of the resulting list.
17:13:41 <roconnor> oh right
17:13:46 <roconnor> just time consuming then
17:14:18 <roconnor> of course, my code isn't great either if it isn't fused away
17:14:40 <roconnor> concat feels like it can fuse
17:14:47 <roconnor> kinda
17:15:04 <Cale> > concat . zipWith (\x y -> if y then [x] else []) [1..] $ [True, False, True, True, False, False, True]
17:15:05 <lambdabot>   [1,3,4,7]
17:16:47 <roconnor> Cale: that's what I wrote :D
17:17:01 <roconnor> (join .) . (zipWith (\a b -> guard b >> return a))
17:17:36 <roconnor> oh right
17:17:41 <kmc> anyone here used cmdargs?
17:17:51 <roconnor> I should use concat instead of join (unless there are rewrite rules)
17:17:51 <kmc> it's duplicating my "help" for my first mode as "help" for the program itself, and i can't override it
17:17:58 <Cale> I generally go with zip [0..] or zip [1..] whenever I absolutely need to work with list indices though.
17:17:59 <roconnor> stupid join not being in the Monad class
17:18:31 <c_wraith> @pl f (a', b') = if a' == a then (a, b) else (a', b')
17:18:32 <lambdabot> f = uncurry (ap ((.) . flip if' (a, b) . (a ==)) (,))
17:23:08 <dmwit> > concat . zipWith (\x y -> [x | y]) [1..] $ [True, False, True, True, False, False, True]
17:23:09 <lambdabot>   [1,3,4,7]
17:23:24 <kmc> http://codepad.org/uzQtRAyJ here's my cmdargs code with the problematic output
17:23:25 <dmwit> cute syntax, eh?
17:23:29 <kmc> the fourth line of output should be just "foo"
17:23:51 <kmc> i think i'm following ndm's examples precisely
17:23:56 <kmc> anyone know what i'm doing wrong?
17:24:03 <aavogt> cmdargs is nice
17:24:21 <kmc> yeah, it is nice
17:24:26 <kmc> it'd be nicer if i could figure this out ;P
17:24:35 <IceDane> So I can't really figure out the ==> operator for quickcheck; instead I simply take all cases using guards or patterns that are invalid for the input and make them return true for my prop -- is this a bad way of doing it? Does the other operator actually do something so that quickCheck simply doesn't generate bad input instead of just ignoring it?
17:24:58 <kmc> IceDane, QuickCheck runs, say, 500 tests
17:25:03 <dmwit> kmc: Sounds like maybe a bug.
17:25:10 <kmc> but your code rejects 499 of them due to bad precondition
17:25:15 <aavogt> kmc: what line in the paste is your problem?
17:25:22 <kmc> now you've only actually tested 1 input to your function
17:25:33 <kmc> IceDane, using (==>) ensures that the rejected inputs won't count towards the number of tests run
17:25:39 <IceDane> Oh, I see
17:25:39 <dmwit> aavogt: line 39 should be "foo"
17:25:40 <aavogt> the specific number
17:25:43 <IceDane> then I really do need to use ==>
17:25:48 <kmc> aavogt, the fourth line of the pasted output should be just "foo".  on line 21 i think i say so
17:25:50 <IceDane> I'll look at docs
17:25:52 <IceDane> Thanks
17:25:54 <kmc> :)
17:26:05 <kmc> but it doesn't stick
17:26:58 <aavogt> I agree with dmwit
17:32:02 <kmc> so this is a bug in cmdargs? :(
17:32:31 <dmwit> How hard can it be to track down? Everything is pure, right? ;-)
17:33:00 * mauke bets there is an unsafePerformIO
17:33:03 <Cale> iirc, cmdArgs is rather sneaky
17:33:13 <dmwit> 100% guaranteed unsafeSomethingSomewhere
17:33:17 <benmachine> I think it has global IORefs
17:33:39 <benmachine> which is indeed sneaky
17:34:21 <aavogt> it doesn't escape as far as I can tell
17:34:33 <aavogt> so it's only as bad as say an unsafeInterleaveIO then?
17:36:15 <benmachine> it's not really bad at all, in my view
17:36:24 <benmachine> except that there's no builtin-to-GHC way of doing this
17:36:33 <kmc> cmdargs's (&=) is one of the sneakiest things i've seen
17:36:41 <kmc> but i'm not using that
17:36:45 <kmc> i'm using the "safe" interface
17:37:53 <benmachine> heh
17:37:59 <benmachine> I had an idea the other day
17:38:11 <benmachine> that unsafeCoerce and unsafePerformIO should be split into a different package
17:38:18 <benmachine> then you can tell if a package uses them by its cabal file
17:38:35 <benmachine> or at least the transitive dependencies 
17:38:46 <kmc> it would be nice if Haskell had a way to track which functions are impure in the type system
17:39:00 <benmachine> uhm
17:39:02 <benmachine> yes
17:39:18 <benmachine> some kind of special type for functions that do IO, perhaps?
17:39:31 <benmachine> or am I missing your point :P
17:40:20 <kmc> i don't propose that the IO type should be replaced with this
17:40:29 <dstcruz_> does this create a lot of thunks?: let fact n = product [1..n]
17:40:35 <dstcruz_> or is that "strict"?
17:40:39 <kmc> i like describing IO using pure functions
17:40:43 <kmc> for everyday stuff
17:40:44 <copumpkin> dstcruz_: yes, unless you compile using -O2
17:40:47 <dstcruz_> I don't know if I'm phrasing my question right
17:40:51 <kmc> but it would be nice to track which stuff might potentially call unsafePerformIO
17:40:51 <copumpkin> in which case it figures out that it's strict and avoids doing bad stuff
17:41:10 <benmachine> product is a foldl, right?
17:41:12 <benmachine> but not a foldl'
17:41:13 <copumpkin> yeah
17:41:14 <dstcruz_> copumpkin: thanks
17:41:23 <kmc> of course, Haskell is often described as tracking impure functions in the type system, but this is quite inaccurate
17:41:40 <copumpkin> unsafePerformIO would be useless if you had a type-level marker saying you'd used it :P
17:41:46 <benmachine> yeah
17:41:56 <kmc> copumpkin, i mean on an advisory basis only
17:42:01 <copumpkin> ah
17:42:06 <benmachine> unsafePerformIO is *supposed* to be only on pure functions
17:42:15 <enigmus> Some help with http://pastebin.com/cknM8Tkz ?
17:42:16 <benmachine> ...that use IO, admittedly, but are still pure
17:42:38 <benmachine> in which case what good is the advisory?
17:42:46 <benmachine> but I kind of see what you mean
17:42:47 <mauke> ... unboxed?
17:42:51 <hpc> the advisory is "unsafe" :P
17:42:55 <kmc> enigmus, UArray can't hold arbitrary types, only some specific ones
17:43:12 <dstcruz_> is it ok to generally compile things with -O2? are there any gotchas?
17:43:17 <enigmus> kmc: ah, thanks
17:43:26 <benmachine> dstcruz_: generally speakign the only downside is it takes longer
17:43:29 <benmachine> and uses more memory, perhaps
17:43:31 <ddarius> We could use an LCF approach (plus some seq) and require a proof that the passed in IO action is pure before you could use unsafePerformIO.
17:43:48 <kmc> enigmus, use regular "Array".  though personally i think IntMap is a simpler API, almost as fast at lookup, and much faster than Array if you have frequent updates
17:43:55 <hpc> some optimization levels will go slower by making an otherwise tight loop too large for the cache
17:43:58 <benmachine> ddarius: what about FFI interfaces? seems like that proof wouldn't really exist in the language?
17:44:08 * hackagebot SHA 1.4.1.3 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.4.1.3 (AdamWick)
17:44:21 <benmachine> hpc: but if that effect was ever significant, I think that would be considered a GHC bug
17:44:39 <benmachine> hpc: significant/not very very rare
17:44:44 <hpc> yeah
17:45:03 <roconnor> ooh, another implementation of sha
17:45:18 <tommd> Huh, I wonder what changed in SHA
17:45:42 <roconnor> why yet another?
17:46:44 <dstcruz_> ah! did not know that foldl' was a strict version of foldl :) thanks for the tip
17:46:56 <enigmus> kmc: Thanks
17:47:04 <hpc> that's a typical pattern in names
17:47:19 <hpc> M at the end means monad, ' means strict, _ means it drops an argument, etc
17:49:19 <ddarius> p'M_s
17:49:20 <benmachine> I think of _ as meaning drops a result
17:49:27 <hpc> ah, yes
17:49:46 * benmachine runs off to write foldM'_
17:49:49 <hpc> :t (sequence, sequence_)
17:49:49 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m, Monad m1) => ([m a] -> m [a], [m1 a1] -> m1 ())
17:50:34 * hpc runs off to write runLiftFoldlM2'_
17:50:54 <kmc> ' can mean a lot of stuff
17:50:55 <hpc> (i think that's all of them)
17:51:21 <hpc> doh, forgot unsafe
17:52:45 <ddarius> :t let p'M_s = [guard . even] in p'M_s
17:52:46 <lambdabot> forall a (m :: * -> *). (Integral a, MonadPlus m) => [a -> m ()]
17:56:13 <bss03> foldl vs. foldr -- Which one is faster?  My list is finite and the value retunred requires processing the whole list.
17:56:55 <hpc> either one, i think
17:57:01 <hpc> so long as you use the strict version
17:57:24 <bss03> The strict version?
17:57:34 <hpc> foldl' and foldr'
17:57:35 <monochrom> pseudoquestion
17:57:36 <xvinyl> bss03: foldl' ?
17:57:51 <copumpkin> foldr' doesn't exist
17:58:06 <hpc> copumpkin: oh?
17:58:15 <copumpkin> foldl' should be faster if you don't need to lazily consume the output, I think
17:58:20 <monochrom> but I guess it's just like "cat vs car, which one is faster" and we can still answer "car"
17:58:24 <copumpkin> not sure ow noticeable it is
17:59:03 <dstcruz_> so, with something like the typeclass Eq, I only have to define one of the functions to get the otherone for free.  How would I have know that from the documentation?
17:59:19 <dstcruz_> are all typeclasses like that?
17:59:30 <kmc> the documentation needs to say so
17:59:31 <dstcruz_> or do you just "have to know"?
17:59:31 <hpc> @src Eq
17:59:31 <lambdabot> class  Eq a  where
17:59:32 <lambdabot>     (==), (/=)   :: a -> a -> Bool
17:59:33 <xvinyl> bss03: working on ai-challenge stuff ?
17:59:41 <copumpkin> dstcruz_: http://snapplr.com/tk8h
17:59:46 <copumpkin> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#t%3AEq
17:59:50 <bss03> I suppose the output could be lazily consumed... but foldl' is probably what I need.
17:59:50 <zaphar_laptop> I've been learning haskell and have come across this function: <$> but can't find any details on what it does. can anyone point me to the the relevant documentation?
17:59:57 <kmc> @hoogle (<$>)
17:59:57 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
17:59:58 <copumpkin> zaphar_laptop: it's the same as fmap
18:00:00 <hpc> you can also tell from the class definition, if it doesn't document it
18:00:01 <kmc> zaphar_laptop, ti's a synonym fro fmap
18:00:03 <bss03> xvinyl: Yeah.
18:00:21 <bss03> xvinyl: Implementing an engine so my bot can predict the future better.
18:00:35 <xvinyl> bss03: i discussed this with jmcarthur earlier
18:01:07 <xvinyl> bss03: he has a different PlanetWars.hs
18:01:22 <bss03> xvinyl: Yeah, I have a link to his.
18:01:35 <dstcruz_> Ah! The Data.Eq doc has the blip about it.  Prelude does not give that extra bit of info.  Thanks.
18:01:48 <xvinyl> bss03: but wasn't interested/didnt see the point in imlpementing the game engine in Haskell
18:01:51 <bss03> xvinyl: But, I don't like his because it only handles two players.
18:02:01 <xvinyl> bss03: well
18:02:12 <xvinyl> bss03: I didn't test either one to be honest
18:02:36 <xvinyl> bss03: but looking through his code, he paid more attention to strictness
18:03:03 <copumpkin> dstcruz_: the prelude docs I just linked you to did...
18:03:11 <bss03> xvinyl: Ah, well, I haven't had any problems with the existing one ebing too lazy.
18:03:12 <zaphar_laptop> thanks for pointers :-)
18:03:34 <bss03> xvinyl: And strictness made sense here.  I'm doing the departure phase of the game state update.
18:03:52 <dstcruz_> copumpkin: I just went back to them, and you are right.  There is a small blip about Eq higher up in the document that doesn't say much, other than the definition.  I was confused.  Thanks!
18:03:55 <xvinyl> bss03: yep ; just mentioning it
18:04:18 <xvinyl> bss03: in case people become crazy on code optimisation
18:04:28 <copumpkin> dstcruz_: it would be nice to have a better mechanism for indicating things like that! for some classes if you omit enough methods you'll get infinite loops whenever you use them :P
18:04:42 <xvinyl> bss03: like in the Tron edition, if I understand well
18:04:59 <dstcruz_> copumpkin: ouch!
18:06:33 <xvinyl> bss03: anyway, I think implementing the engine inside the bot is the way to go
18:08:27 <dstcruz_> copumpkin: could the compiler give a warning when the min required has not been defined? Is that even possible?
18:08:29 <darrint> I'm using the State monad here: http://pastebin.com/T29safgG but it feels to me like I should be able to improve on it. Could someone review?
18:08:42 <copumpkin> dstcruz_: that's what I meant :) it can't, but would be nice
18:09:17 <bss03> xvinyl: I agree that the bot needs some engine.
18:09:52 <bss03> xvinyl: alpha-beta or minimax don't apply well to the problem, but that doesn't mean prediction isn't useful.
18:10:10 <xvinyl> bss03: tbh, I think it's an optimal control problem
18:10:12 <zachk> DUDE NO WAY, the cat is faster if you strapped it to a rocket 
18:10:37 * zachk reminds himself not to comment on things people said like 3 hours ealier whilst perusing logs 
18:10:40 <xvinyl> bss03: Hamilton-Jacobi equations, etc
18:10:52 <benmachine> darrint: it looks like you're basically making a list of sprites in a bunch of locations, evenly spaced in the y-coordinate?
18:11:15 <xvinyl> bss03: similar to what you would see in a financial setting
18:11:24 <benmachine> darrint: oh wait, not evenly spaced
18:11:42 <xvinyl> bss03: each planet is an 'option', and you try to buy it when you send fleet
18:12:03 <darrint> benmachine: Right. I wasn't sure if I really need the whole freedom of the state monad here or should I be able to do with less.
18:12:07 <xvinyl> bss03: when the planet is yours, you get dividends, etc.
18:12:09 <benmachine> darrint: but instead of modify followed by get, get followed by put seems to make as much sense
18:12:22 <benmachine> darrint: yeah, my first instinct seeing that is that you didn't need the State monad
18:12:41 <benmachine> darrint: but it's a tough call to make because you never *need* the State monad, it's jsut a matter of what's most convenient
18:12:45 <xvinyl> bss03: these things are well-studied and many advanced techniques already exist ; but we need to find a way to formalize it
18:13:45 <darrint> benmachine: Well, I half expected someone to say, no that's a writer or a reader or an rws or something. So I'll probably stick with it for now. I do like the convenience of it.
18:13:47 <benmachine> darrint: I'm thinking something like scanl (+) 0 (map (h . spriteSize) ss) will give you all the locations
18:13:58 <benmachine> darrint: I don't think you necessarily need a monad at all :)
18:14:12 <darrint> Ah. Ok. I'll take a look at that then.
18:14:23 <benmachine> I'm not confident of that scanl
18:14:29 <benmachine> but play about with it a bit I'm sure something'll work
18:15:56 <bss03> xvinyl: I haven't approached to problem from that angle.  I don't have any experience there.
18:16:13 <bss03> xvinyl: Sounds like it might make from some good bots.
18:16:29 <ddarius> The main driver, beyond semantics, of whether to use foldr or foldl' is whether the passed in function is strict in the recursive argument or not.
18:16:54 <darrint_> benmachine: Yeah. That's not quite right. Do I want accum* something?
18:17:13 <benmachine> darrint_: in what way is it wrong?
18:17:19 <benmachine> scanl does a sort of accumulation already
18:19:40 <darrint_> benmachine: Well, yours isn't wrong, but it results in ... -> [Integer], so I have more work to do. mapAccumR lets me start with an Integer and I get back (Integer, [PlacedSprite]) which fits my mental model better.
18:19:53 <bss03-AFK> ddarius: g2g... Which one is the recursive argument?
18:20:19 <bss03-AFK> ddarius: I'm strict in the second argument to "accum", so foldl' is good?
18:20:19 <xvinyl> bss03-AFK: I didn't take the time to write everything down on a paper but I feel it can be a good way to formalize the game
18:20:26 <darrint_> benmachine: I can take that Integer and do pack more sprites in the same texture.
18:20:43 <xvinyl> bss03-AFK: then it's all optimization technique + well-chosen value function
18:21:43 <bss03-AFK> Really gone after this; gotta pick my Dad up from the airport.
18:22:51 <benmachine> darrint_: well, my idea was that after you'd got the [Integer] you'd zipWith (\s i -> PlacedSprite s (Point 0 i))
18:22:57 <darrint_> benmachine: Although I'm very proud of myself for noticing that mapAccumR is similar to mapM in the state monad. At this rate next week I'm going to arguing with conal about something.
18:23:02 <benmachine> haha
18:23:11 <copumpkin> onoes, I need to turn on undecidable instances to write a show instance for one of my types :P
18:23:20 <benmachine> yeah, mapAccumR is very statey
18:23:47 <darrint_> benmachine: Thanks for the review. That gives me a lot to think about.
18:24:19 <benmachine> darrint_: you may find out that State was what you wanted after all, but it's good to know your alternatives, I think
18:27:10 <hpc> :t mapM
18:27:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:36:52 <ddarius> copumpkin: Is one of your types Mu?
18:36:57 <copumpkin> nope
18:37:10 <copumpkin> I've used it for that before too though
18:37:42 <geheimdienst> typed cow says moo moo
18:38:39 <aavogt> infinitely typed :)
18:43:31 <Cyndre> Just thought I would tell you guys that your awsome.  The things you do to help promote languages is awsome.  I have no first hand experience, but plenty of gushing endorsements.  Once again you guys are awsome.
18:43:45 <jmcarthur> lol
18:43:55 <jmcarthur> i just told Cyndre about tryhaskell.org in another channel :P
18:43:55 <geheimdienst> i wish there was a speech bubble containing "mu" in this picture: http://s3.amazonaws.com/lyah/cow.png
18:48:35 <ddarius> geheimdienst: Tell BONUS
18:50:22 <ManateeLazyCat> I want print package information if search 'build-tools' failed when i do "cabal install ...". Example, in gtk package, it's need build-tools from package 'gtk2hs-buildtools', if search failed, i want print "Please install gtk2hs-buildtools first or make sure it's in your PATH. "
18:50:28 <ManateeLazyCat> It's possible?
18:51:41 <aavogt> how does gtk fail now?
18:52:22 <ManateeLazyCat> aavogt: Most people don't read gtk2hs manual, just do "cabal install gtk", but it will failed if you haven't install gtk2hs-buildtools first.
18:52:37 <ManateeLazyCat> aavogt: You need install gtk2hs-buildtools manually before install gtk.
18:53:00 <aavogt> ManateeLazyCat: I mean, what does it say when it fails now?
18:53:17 <ManateeLazyCat> aavogt: Wait, i paste.
18:54:29 * ManateeLazyCat pasted "gtk error" at http://paste2.org/get/988415
18:54:30 <ManateeLazyCat> aavogt: ^^^
18:55:47 <ManateeLazyCat> aavogt: When user saw above error, he don't know it's need install gtk2hs-buildtools first.
18:56:20 <dmwit> ManateeLazyCat: This would be a good feature request for cabal.
18:56:25 <benmachine> geheimdienst: μ, surely
18:56:55 <ManateeLazyCat> dmwit: Yes, i want a hacking way before cabal add this feature.
18:56:58 <dmwit> As a workaround, you could have the gtk2hs-buildtools package install an executable called gtk2hs-buildtools, and depend on that instead of gtk2hsC2hs.
18:57:45 <ManateeLazyCat> dmwit: Well, we have three tools (gtk2hsC2hs, gtk2hsHookGenerator, gtk2hsTypeGen) in gtk2hs-buildtools.
18:57:59 <dmwit> Make a fourth, that doesn't do anything. =)
18:58:10 <dmwit> Depend on only that one. At least they will know the package name, then.
18:58:10 <Cale> ManateeLazyCat: btw, someone was here today looking for the mozembed package for gtk2hs
18:58:31 <aavogt> ManateeLazyCat: perhaps check yourself for gtk2hsC2hs in   runC2HS  in Gtk2HsSetup.hs
18:58:33 <ManateeLazyCat> Cale: mozembed has departed, won't maintain.
18:58:39 <Cale> It's apparently a dependency for himerge
18:58:49 <ManateeLazyCat> Cale: I have update all WebkitGTK+ APIs, so use webkit package instead.
18:59:21 <Cale> ManateeLazyCat: Yeah, it just means that the himerge package isn't installable
18:59:30 <ManateeLazyCat> Cale: 'Mozembed' cabal package is easy, just it's code can't work with mozembed library.
18:59:33 <Cale> (I don't actually care about the library myself)
18:59:37 <ManateeLazyCat> Cale: I don't know how to fix it.
19:00:07 <ManateeLazyCat> @hoogle himerge
19:00:07 <lambdabot> No results found
19:00:15 <ManateeLazyCat> @package himerge
19:00:15 <lambdabot> http://hackage.haskell.org/package/himerge
19:00:57 <benmachine> upload date 2008
19:01:00 <benmachine> good luck with that
19:01:06 <ManateeLazyCat> Cale: Well, i suggest himerge switch to webkit if it just use it display some webpage.
19:01:52 <ManateeLazyCat> Cale: The real reason is mozembed library can't work somehow....
19:03:23 <ManateeLazyCat> aavogt: dmwit Thanks for your suggestion, we will discuss those in gtk2hs list.
19:04:31 <geheimdienst> so, why does gtk.cabal not just say "build-depends: gtk2hs-buildtools" or something similar?
19:04:39 <geheimdienst> (i'm trying to learn more about cabal)
19:04:48 <ManateeLazyCat> Cale: Webkit's APIs is much simple and damn fast.
19:04:58 <monochrom> executable-only package
19:05:19 <dmwit> geheimdienst: gtk2hs-buildtools doesn't register a (library) package with GHC
19:05:20 <ManateeLazyCat> geheimdienst: Because gtk2hs-buildtools just provide executable tools, not any library that gtk package need depend.
19:05:38 <dmwit> geheimdienst: So even when it's installed, you can't check for it via ghc-pkg.
19:05:42 <monochrom> although some people do argue "why not just rebuild the same package over and over again"
19:06:51 <ManateeLazyCat> This cabal issue really confuse many gtk2hs user, many people give up last, how user does know where can find gtk2hsC2hs?
19:07:15 <geheimdienst> got it. so this is because of the known problem that cabal doesn't effectively track executables. i've heard about that before
19:07:16 <monochrom> perhaps it avoid success.
19:07:43 <ManateeLazyCat> They just know "cabal install gtk" can install everything for him, and fact is you need gtk2hs-buildtools *manually*, this is really really bad.
19:08:10 <monochrom> perhaps they shouldn't know "cabal install gtk" installs everything.
19:08:17 <dmwit> ManateeLazyCat: Have you considered installing a (dummy) library for gtk2hs-buildtools?
19:08:23 <monochrom> it doesn't install the c libs, for starters
19:08:46 <ManateeLazyCat> dmwit: What you mean?
19:09:11 <dmwit> ManateeLazyCat: Let gtk2hs-buildtools be both an executable package *and* a library package. Then you can depend on it.
19:09:21 <monochrom> it means add a useless module to gtk2hs-buildtools
19:09:27 <dmwit> yes
19:09:30 <dmwit> It is a hack.
19:09:37 <ManateeLazyCat> monochrom: Well, because C library have different way on different OS, even in different Linux (e.g. Debian and Fedora).
19:09:37 <dmwit> But MLC requested a hack. =)
19:09:57 <ManateeLazyCat> dmwit: I have suggest that, but Axel and Duncan don't like that.
19:10:10 <ManateeLazyCat> dmwit: They don't like gtk package depend dummy package.
19:10:36 <ManateeLazyCat> dmwit: In technology, it's really easy, but they don't like this ugly way.
19:10:40 <dmwit> Tell Duncan to FIX CABAL then. ;-)
19:10:57 <ManateeLazyCat> dmwit: I guess Duncan too busy now .:)
19:11:33 <monochrom> perhaps cabal already does too much. perhaps the solution is do less, not more.
19:11:35 <geheimdienst> i would just do the dummy module as a workaround. when cabal is fixed, you can remove the workaround and do it the proper way
19:12:29 <benmachine> monochrom: I like that solution
19:12:32 * benmachine falls asleep
19:12:33 <ManateeLazyCat> geheimdienst: If you build dummy module, everytime you update gtk2hs-buildtools, you need update all depend package (such as: gtk, webkit, sourceview....) again.
19:12:49 <ManateeLazyCat> geheimdienst: That's why Axel don't like that.
19:13:01 <monochrom> do not install dependencies automatically at all. at most list them as suggestions. now we have a level playing field. no more high expectations.
19:15:33 <monochrom> here is another way. have ghc-pkg track executables too.
19:15:54 <ManateeLazyCat> monochrom: How?
19:15:57 <benmachine> have OS package managers suck less
19:16:34 <monochrom> I don't know how. Modify the record type in ghc source code?
19:16:43 <monochrom> s/the/a/
19:16:50 <ManateeLazyCat> monochrom: Oh, you kid me. :)
19:17:56 <ManateeLazyCat> Thanks all, i will ticket this issue in list, many people give up to install gtk2hs, unfortunately, it's not fault of gtk2hs.
19:18:47 <ManateeLazyCat> Currently, best way is notify user install gtk2hs-buildtools first explicitly...
19:19:11 * ManateeLazyCat gtk2hs really really easy to install on Windows, Linux, Mac. 
19:25:28 <lispy> monochrom: I think a separate layer (abstraction) that tracks executables would help
19:25:49 <lispy> That layer could be taught to interface with the native package manager as needed
19:26:49 <lispy> I think you'd need a way for cabal-install to query that layer and optionally a way to let that layer know things were installed
19:27:00 <monochrom> perhaps cabal should do that itself. it is not like $HOME/.cabal is empty and clean.
19:27:30 <lispy> We should form a committee to decide
19:27:47 <lispy> First I would like to nominate a committee that will establish the deciding committee
19:29:08 <lispy> (and if it turns out we have too many committees I would like to propose we hold a committee workshop, and of course have a committee in charge of the workshop)
19:29:47 <ManateeLazyCat> lispy: I think cabal developer can fix problem easily, i guess just haven't time on those *little* issue...
19:36:16 <ManateeLazyCat> IMO, should make gtk depend gtk2hs-buildtools, because most people just install it once and won't update gtk2hs-buildtools
19:42:30 <roconnor> I accidently put my computer to sleep when I in the middle of updating grub
19:43:07 <Mitar> roconnor: and?
19:43:08 <roconnor> my computer doesn't wake up from sleep without crashing
19:43:20 <ezyang> Not surprising. Do you have a boot CD? 
19:43:25 <roconnor> nope
19:43:28 <roconnor> no CD drive
19:43:32 <ezyang> Well, boot USB? 
19:43:35 <roconnor> nope
19:43:43 <roconnor> I got a grub prompt!
19:43:49 <ezyang> oh, that's kinda useful. 
19:43:52 <roconnor> whew
19:45:26 <roconnor> @spell propogated
19:46:25 <copumpkin> propagated 
19:46:44 <roconnor> @pumpkin-snack
19:46:45 <lambdabot> Unknown command, try @list
19:46:50 <copumpkin> :)
19:47:21 <ManateeLazyCat> Cale: If that user really need himerge, here is old mozembed backup : http://www2.in.tum.de/~simona/mozembed/
19:47:42 <Mitar> just a little bit more and i will finish first sewing machine powered with haskell ;-)
19:47:52 <roconnor> :O
19:47:57 <ManateeLazyCat> Cale: But it's need use gtk-0.10.xx or older version to build mozembed and with "./configuration && make" way. 
19:48:13 <Cale> ManateeLazyCat: okay, I'll keep it in mind :)
19:48:20 <ManateeLazyCat> Cale: :)
19:54:09 <ManateeLazyCat> Though firefox is very very powerful, but mozbembed's APIs is than complicated webkit. So i suggest haskeller use 'webkit' package for build browser or other web application (Exmaple, this have webkit base on feed reader : http://www.flickr.com/photos/48809572@N02/4960339299/lightbox/)
19:54:59 <lispy> ManateeLazyCat: cabal doesn't track exes because the cabal devs don't want to be in the business of mediating between OS/package-manager installed things and cabal-installed things.  In fact, cabal doesn't even track libraries.
19:55:15 <lispy> This is actually why I think it should be a separate layer
19:55:24 <lispy> So that cabal can continue to stay out of the 'business'
19:56:31 <ManateeLazyCat> lispy: Why not make cabal become really package-manager? 
19:57:13 <lispy> ManateeLazyCat: because that would be a big change in what cabal does and is for.  Cabal is not a package manager currently.
19:58:07 <ManateeLazyCat> lispy: I guess most haskellers use cabal instead package-manager in their's system to update haskell package.
19:58:47 <ManateeLazyCat> lispy: Why we need care package-manager in user's system? We just need cabal, and it's enough...
19:59:18 <ManateeLazyCat> lispy: I hope cabal will become package manager someday...
20:01:01 <lispy> ManateeLazyCat: Well, if cabal becomes a package manager it will need to interoperate with the user's native package manager (if any)
20:01:22 <lispy> ManateeLazyCat: So it seems to me that cabal does have to care about the package manager that is native
20:02:20 <lispy> ManateeLazyCat: So, I think everyone agrees that the current setup is sub-optimal.  What people disagree about is how to implement the fix.
20:02:40 <lispy> ManateeLazyCat: I suspect dcoutts is waiting for someone to implement a fix
20:03:59 <ManateeLazyCat> lispy: Haskeller is productive and less time... :)
20:04:50 <lispy> ManateeLazyCat: Are you volunteering to submit a fix?
20:05:27 <ManateeLazyCat> lispy: Well, i'm so busy on my own project (ILE) and many gtk2hs base on packages.
20:05:53 <ManateeLazyCat> lispy: I want fix everything, but haven't time.
20:06:06 <ManateeLazyCat> lispy: Infact, i'm testing my irc client when talk to you. :)
20:06:10 <lispy> ManateeLazyCat: Right.  My priorities are not with cabal either.
20:06:27 <lispy> Even though I want cabal fixed, I don't put any time into learning the code or fixing it.
20:06:38 <lispy> I think others are similar
20:07:37 <ManateeLazyCat> lispy: Yes, we are all volunteer, and we have we own plan ...
20:09:02 <ManateeLazyCat> lispy: I need gotta go, bye! :)
20:11:51 <kmc> Hackage versioning policy is API change => minor version bump, correct?
20:12:05 <kmc> this means that my cabal file should probably specify things as "foo >= 0.3" and not any more precise?
20:12:53 <ezyang> kmc: Features can be added in 0.0.x  
20:12:57 <ezyang> iirc 
20:14:32 <kmc> damn
20:15:02 <geheimdienst> what's the third part called anyway? major.minor.microscopic?
20:15:32 <p_l> geheimdienst: depends.
20:15:57 <kmc> i've heard "revision"
20:15:58 <monochrom> major.minor.mini.nano.shuffle (just joking)
20:16:01 <kmc> haha
20:16:32 <lispy> kmc: you need upper bounds
20:16:33 <p_l> for linux kernel it's major.minor.sublevel.extra
20:16:37 <monochrom> my sister had an ipod mini
20:16:45 <p_l> though it can be understood as major.minor.revision.patchlevel
20:16:45 <geheimdienst> major.minor.itsy.bitsy
20:16:46 <kmc> lispy, for every package?
20:16:51 <lispy> kmc: yes
20:16:52 <kmc> i know it's conventional for base
20:16:52 <monochrom> and an ipod shuffle
20:17:16 <lispy> kmc: foo > 0.3 && foo < 0.5 -- or something reasonable like that
20:17:23 <monochrom> classic.touch.mini.nano.shuffle (now the series is complete!)
20:17:56 <luite> major second . minor second
20:19:12 <geheimdienst> "i'm majoring in version numberology" (he he)
20:19:39 <monochrom> hehe
20:20:05 <geheimdienst> major.corporal.sergeant.private
20:20:30 <p_l> some use <Type><Release>.<Version>-<Update>
20:21:50 * monochrom misplaced his music harmony book. major second, dominant seventh, ...
20:22:35 <monochrom> err, probably "dominant seventh" doesn't exist, but there is "diminished seventh"
20:30:18 <Cale> no, it exists
20:31:02 <Cale> It's a major triad + a minor seventh
20:31:07 <monochrom> cool
20:33:39 <dmwit> (also known as a major-minor seventh)
20:53:17 <tommd> @tell dcoutts I've proposed splitting 'split' from RandomGen.  If you could weigh in on the ML I'd appreciate it.
20:53:17 <lambdabot> Consider it noted.
20:54:13 <roconnor> tommd: eh?
20:54:24 <tommd> roconnor: On l@h.o
20:54:33 <roconnor> splitting split?
20:54:44 <tommd> "split" is a method in RandomGen.  I want it to get moved to it's own type class.
20:55:04 <geheimdienst> "the proposal to split split split the community"
20:55:17 <Martty`o_O`> hmm using the c++ std lib and functors its cool to code haskellish code :D
20:55:17 <tommd> geheimdienst: That looks to be true right now.
20:55:18 <roconnor> tommd: that is a H98 class
20:55:49 <Martty`o_O`> i just figured out a way to use something like [1..]!
20:55:51 <tommd> roconnor: I'm not a fan of sticking with historical baggage just because it is historical
20:56:27 <tommd> roconnor: "random" is a library under the control of l@h.o.  If the Haskell98 package wants to specify its deps as "random == 1.0.0.1" then fine.
20:58:51 <roconnor> tommd: but it is in the Haskell report
20:59:02 <roconnor> I don't see how library can change it
20:59:07 <roconnor> you have to put it in Haskell prime
20:59:14 <tommd> I already made a patch - its that simple ;-)
20:59:19 <roconnor> ya
20:59:29 <roconnor> but RandomGen is part of the Haskell Report
20:59:34 <tommd> GHC /= Haskell.  They made that clear long ago
20:59:38 <roconnor> if you change it, it is no longer Haskell
20:59:54 <roconnor> tommd: how did they make it clear?
21:00:02 <tommd> But the Haskell Report does not exclude other libraries
21:00:06 <tommd> That's all this is.
21:00:26 <roconnor> huh?
21:00:34 <tommd> Naturally it would make sense to have a matching proposal in Haskell'.
21:00:38 <roconnor> but the Haskell Report does include the Random library
21:23:29 <monochrom> @remember geheimdienst "the proposal to split split split the community"
21:23:29 <lambdabot> I will remember.
21:24:33 <trinithis> ^ words of a poet
21:29:06 <geheimdienst> words of a buffalo, maybe ... http://en.wikipedia.org/wiki/Buffalo_buffalo
21:30:38 <mbuf> are there any functions that I can use for computing sha1sum?
21:31:07 <dmwit> Have you checked Hackage?
21:31:14 <dmwit> I thought somebody *just* released a crypto package.
21:32:26 <dmwit> In fact, there's a whole Cryptography category on Hackage. =)
21:33:48 <mbuf> dmwit: where should I check in hackage?
21:34:03 <mbuf> dmwit: ok, under packages
21:34:11 <dmwit> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:cryptography
21:34:25 <monochrom> I always jump straight to http://hackage.haskell.org/packages/archive/pkg-list.html
21:34:57 <monochrom> like most websites, front pages are useless.
21:35:11 <Mitar> how can i run commands in my own monad in ghci, interactively (i have a StateT s IO monad)?
21:35:24 <Mitar> so i would like to exec that monad and then write my own commands
21:35:25 <dmwit> Hackage wouldn't have to be that way.
21:35:32 <geheimdienst> omg "packages by category"
21:35:35 <dmwit> In fact I think it's rather silly that the front page is not the packages list.
21:36:17 <geheimdienst> category-extras is in the "category" named "comonads"
21:36:24 <geheimdienst> let me think about that a little
21:36:27 <dmwit> uh
21:36:29 <dmwit> That's a bit odd.
21:36:41 <dmwit> Actually, no it's not odd.
21:36:44 <ddarius> A package can be in more than one category.
21:36:59 <dmwit> It's also in the categories "Control" and "Monads".
21:37:04 <geheimdienst> yeah
21:37:23 <geheimdienst> "these monads are totally out of control"
21:38:27 <mtnviewmark> "Ya got some big monads there, don' cha?"
21:39:35 <mbuf> can anyone give me an example on how to use SHA256 from here? http://hackage.haskell.org/packages/archive/SHA2/0.2.2/doc/html/Codec-Digest-SHA-IO.html 
21:39:55 <trinithis> Whoa! What's with the ACME packages on hackage?
21:40:32 <dmwit> mbuf: I guess you'd call newCtx, then update with the bytes you want to digest, then finalize.
21:40:32 <monochrom> jokes
21:40:41 <dmwit> mbuf: But that interface looks horrible.
21:41:06 <dmwit> http://hackage.haskell.org/packages/archive/Crypto/4.2.1/doc/html/Data-Digest-SHA1.html looks much saner
21:41:19 <trinithis> > let blowUpWorld = undefined in don't blowUpWorld
21:41:20 <lambdabot>   Not in scope: `don't'
21:41:30 <trinithis> pah
21:41:50 <mbuf> dmwit: I see
21:41:53 <geheimdienst> i note that http://hackage.haskell.org/package/empty in its current version 9 is quite different from version 1.0
21:42:12 <geheimdienst> http://hackage.haskell.org/package/empty-1.0 might be put to some use by someone
21:43:02 <dmwit> geheimdienst: Data.Default seems to be the new standard for that kind of thing.
21:43:06 <dmwit> It has more instances, too.
21:43:46 <Mitar> how can i run commands in my own monad in ghci, interactively (i have a StateT s IO monad)?, so i would like to exec that monad and then write my own commands
21:43:58 <dmwit> Mitar: There isn't a way, so far as I know.
21:44:03 <dmwit> You can use runStateT, of course.
21:44:36 <geheimdienst> dmwit, i see. that must be why they discontinued Data.Empty
21:45:12 <Mitar> with runStateT i cannot execute new commands ...
21:45:31 <dmwit> You can, you just need to feed in the updated state.
21:45:34 <dmwit> Sorry about that.
21:47:16 <monochrom> the point of repl
21:47:22 <monochrom> is to do everything by hand
21:47:35 <monochrom> even the acronym suggests it
21:47:52 <monochrom> rhymes like "repetitively"
21:49:30 <monochrom> s/rhymes like/so close to/
21:50:12 <Mitar> yes, by hand
21:50:52 <monochrom> whoever coined the acronym
21:51:01 <monochrom> must have intended this pun
21:51:17 <monochrom> he did not call it "interactive language lab" (ill)
21:51:31 <monochrom> he did not call it "language interpreter prompt" (lip)
21:51:43 <geheimdienst> @time monochrom
21:51:44 <lambdabot> Local time for monochrom is Wed Sep 15 00:51:19
21:51:51 <ddarius> "repl" sounds more like a verb.
21:51:52 <monochrom> or a thousand other better names
21:52:11 <monochrom> he had to call it "read eval print loop"
21:52:36 <monochrom> first 3 letters and second last letter of "repetitively"
21:55:04 <monochrom> even Jobs and Wozniak had a better name: immediate mode
22:01:02 <mbuf> I have Crypto installed, and able to import Data.Digest.SHA1; how do I know use the hash function to compute the sha1sum of a string, say "hello"?
22:01:14 <mbuf> s/know/now/
22:01:48 <copumpkin> hash :: [Word8] -> Word160	
22:02:05 <copumpkin> > map (fromIntegral . ord) "moo" :: [Word8]
22:02:07 <lambdabot>   [109,111,111]
22:03:09 <ddarius> > 24*60
22:03:10 <lambdabot>   1440
22:03:22 <ddarius> This doesn't bode well.
22:04:34 <qwebirc95917> @pl \x -> rem x 5 == 0
22:04:34 <lambdabot> (0 ==) . flip rem 5
22:06:46 <monochrom> @time monochrom
22:06:47 <lambdabot> Local time for monochrom is 3.1415926535897932384626433832795028841972
22:07:55 <geheimdienst> how can this be?
22:08:07 <geheimdienst> on what planet is the local time currently pi?
22:08:42 <monochrom> too bad xchat doesn't let me change ctcp version
22:09:40 <geheimdienst> i think you could give time as fractions of pi ... 12 o'clock would be pi
22:10:12 <geheimdienst> make that: pi = 12:00, 2pi = 0:00
22:10:31 <mbuf> hash [1] returns a Word160
22:10:32 <geheimdienst> 1.5pi = 18:00 and so on
22:13:16 * ddarius begins developing a folk fiddle repertoire.
22:14:24 * geheimdienst thinks his idea of pi time is complete bunk, although it could use the awesome name "pime"
22:35:20 <etherealite> Im a xmonad user trying to find out what <+> means in layman's terms. Anyone break it down for me a send a link?
22:36:36 <etpace> @hoogle Bool -> Int
22:36:36 <lambdabot> Data.Time.Calendar.MonthDay monthLength :: Bool -> Int -> Int
22:36:36 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
22:36:36 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
22:37:16 <ddarius> > map fromEnum [False ..]
22:37:17 <lambdabot>   [0,1]
22:37:55 <Cale> etherealite: It composes a pair of ManageHooks into a ManageHook which does both
22:40:41 <Cale> etherealite: Is that the sort of answer you were looking for?
22:41:18 <etherealite> Cale yeah, but now I'm trying to figure out what a ManageHook does.
22:42:22 <etherealite> This is what I found: The X monad, a state monad transformer over IO, for the window manager state, and support routines.
22:42:38 <Cale> etherealite: I'm not really an XMonad user, but I believe you can think of a ManageHook as something which describes a bunch of stuff to automatically do to open windows based on their properties.
22:44:00 <Cale> For example, suppose you always want Firefox to go to a particular workspace.
22:44:03 <geheimdienst> etherealite, you're right, the name "ManageHook" is a little strange. it runs whenever a new window opens. you can use it for stuff like: move all my firefox windows to desktop 3, if a video player window opens make it fullscreen, etc.
22:44:43 <geheimdienst> it might have been better to call it "newWindowHook" or something
22:46:28 <etherealite> geheimdienst  ok well it couldn't be any more clear than that without actually knowing haskell, thanx.
22:46:44 <Axman6> time to learn you come haskell :)
22:46:47 <Axman6> some*
22:47:35 <etherealite> heh, yeah, just the shear number of operators is scaring the wits outa me.
22:48:23 <geheimdienst> and i'd recommend to not get confused by all the stuff about monoids and mappend and whatnot. i'm not an expert myself, but frankly i don't know why they chose to implement it that way. i'm pretty sure the manageHook could just as well be implemented by a simple function (ignoring some details)
22:52:28 <etherealite> geheimdienst ok, ill just keep following the tutorial.
23:03:48 <Mitar> how can i define a bounded data type of number 0 - 9?
23:05:45 <Starfire> newtype and a smart constructor.
23:06:14 <Starfire> Or data Bounded = One | Two ... etc
23:06:56 <geheimdienst> > minBound :: Bool
23:06:57 <lambdabot>   False
23:07:08 <geheimdienst> @instances Bounded
23:07:08 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
23:07:24 <Mitar> so i will have to list all numbers?
23:07:25 <geheimdienst> > minBound :: (a,b)
23:07:26 <lambdabot>   Could not deduce (GHC.Enum.Bounded a, GHC.Enum.Bounded b)
23:07:26 <lambdabot>    from the conte...
23:08:02 <Mitar> i hoped for something like: data InboxNumber = 0 .. 9 deriving (Bounded, Enum, Eq, Ord, Read, Show)
23:08:58 <ivanm> well, do something like Starfire suggested, make it an instance of Num and Integral but don't expose the constructors
23:09:32 <Mitar> i do not really follow
23:09:33 <ivanm> and write your own custom Show and Read instances that go via Integer
23:10:01 <ivanm> Mitar: well, if you want to be able to use 1 instead of One, then a Num instance will let you define fromInteger which will do that for you
23:10:41 <Mitar> but i will then have to write (fromInteger 1) :: InboxNumber?
23:10:52 <Mitar> it will not be automatic?
23:11:10 <Starfire> 1 :: InboxNumber is enough.
23:11:17 <kmc> or probably just 1, in context
23:11:34 <Starfire> And the type annotation can be omitted if it can be inferred.
23:11:45 <ivanm> yup
23:11:50 <ivanm> that's the whole point of fromInteger
23:11:56 <ivanm> Mitar: same as how you can do this:
23:11:58 <ivanm> > 2 :: Double
23:11:59 <lambdabot>   2.0
23:12:08 <ivanm> ^^ uses an implicit fromInteger to do the conversion
23:12:23 * ivanm wonders who the first two men were
23:14:28 <Mitar> "Only unit numeric type pattern is valid" hmm
23:14:35 <Mitar> i decided for Inbox0 | Inbox1 | ...
23:14:56 <Starfire> You could also newtype InboxNumber = IN Int, not export IN and write Num etc. as above.
23:15:09 <ivanm> true
23:15:19 <ivanm> you'd just have to be more careful with +, etc.
23:15:29 <Mitar> i do not want + ;-)
23:15:29 <ivanm> and not rely on just lifting it inside the newtype
23:15:48 <Mitar> there is no semantics in adding two inboxes together
23:16:28 <Mitar> so Inbox0 is not a valid name for data?
23:16:42 <ivanm> well, you need to define + as well if you want to use fromInteger
23:16:46 <ivanm> Mitar: should be valid
23:16:59 <kmc> ivanm, sure, define it to error "can't do that" ;)
23:17:06 <ivanm> kmc: heh
23:17:07 <kmc> Num kinda sucks :/
23:17:11 <Mitar> ups, i had one space too much
23:17:12 <ivanm> mmmmm
23:17:20 * ivanm wants type class aliases!!!!!
23:26:45 <ezyang> it's true. 
23:27:18 <ivanm> what's true?
23:27:23 <ivanm> that I want type class aliases? :p
23:32:13 <danderson> I'm confused: permutations [1,2,3] produces the correct output
23:32:43 <danderson> but `permutations (replicate 20 0 ++ replicate 20 1)` doesn't
23:33:04 <danderson> it outputs [20x0, 20x1] repeatedly
23:33:08 <ivanm> @type permutations
23:33:09 <lambdabot> forall a. [a] -> [[a]]
23:33:17 <ivanm> > permutations [0,0,0,1,1,1]
23:33:18 <lambdabot>   [[0,0,0,1,1,1],[0,0,0,1,1,1],[0,0,0,1,1,1],[0,0,0,1,1,1],[0,0,0,1,1,1],[0,0...
23:33:19 <danderson> oh, hm, duh.
23:33:28 <danderson> it's permuting the zeros around.
23:33:30 <ivanm> danderson: it assumes they're all unique methinks
23:33:48 <tensorpudding> @src permutations
23:33:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:33:55 <tensorpudding> hmm
23:36:04 <tensorpudding> > let x = permutations (replicate 5 undefined) in x `seq` 5
23:36:05 <lambdabot>   5
23:37:43 <tensorpudding> seems that it is completely ignorant of the values
23:39:41 <tensorpudding> hmm
23:39:53 <tensorpudding> seq only evaluates the outmost layer
23:40:24 <tensorpudding> how might you force it to be "completely evaluated" for some reasonable definition?
23:41:12 <tensorpudding> is that what deepseq does?
23:42:12 <ddarius> :t permutations
23:42:13 <lambdabot> forall a. [a] -> [[a]]
23:42:31 <kmc> tensorpudding, yes
23:42:42 <ddarius> tensorpudding: That is what deepSeq does, but it has to traverse the structure to do that.
23:44:19 <tensorpudding> also what would be the formal name for "completely evaluated"?
23:49:18 <kmc> normal form
23:49:30 <kmc> there's normal form, head normal form, and weak head normal form
23:49:46 <kmc> the basic unit of computation in Haskell is evaluation to whnf
23:49:48 <kmc> and that's what seq does
23:51:00 <kmc> nf contains no redexes; hnf can contain a redex in an argument position, whnf can contain redexs anywhere as long as the top is not a redex
23:52:03 <tensorpudding> i thought that was just for LC
23:52:51 <tensorpudding> Though now I remember that whnf was mentioned in C.P.S
23:53:02 <tensorpudding> as an evaluation strategy
23:56:31 <kmc> the terminology comes from λ calculus, but is easily extended to include data constructors and primitive functions
23:56:50 <kmc> and what else do you need for an operational semantics of Haskell?
23:57:23 <ddarius> The lazy functional community is the one that created the term "weak head normal form."
23:57:55 <tensorpudding> I'd heard of it through TTFP, but I never finished that book.
