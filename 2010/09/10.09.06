00:00:07 <kmc> you could build the type expression (Either a) using the TH combinators
00:00:11 <kmc> just not using its quotation syntax
00:00:26 <ivanm> how do I get the `a' ?
00:00:54 <kmc> mkName "a"
00:00:56 <kmc> i presume
00:01:31 <kmc> :t AppT (ConT ''Either) (VarT $ mkName "a")
00:01:32 <lambdabot>     lexical error in string/character literal at character '\''
00:01:45 <ivanm> ugh
00:02:05 <ivanm> it's almost easier to just do the type explicitly
00:02:10 <kmc> you could use a quasiquoter with haskell-src-meta
00:02:13 <ivanm> possibly using a script to generate it
00:02:17 <kmc> or a preprocessor
00:02:23 <kmc> (CPP, M4, custom)
00:02:24 <ivanm> yeah
00:02:34 <ivanm> M4 with Haskell? really?
00:02:38 <kmc> why not?
00:02:46 <kmc> i've never seen it done, but go ahead and be the first :)
00:02:47 <ivanm> don't think I've seen anyone do that before
00:02:55 <kulin> do you guys have an ide of choice when working on yer haskell projects? I've spent the last week, probably 30+ hours tinkering with emacs/leksah/gvim trying to get something I like
00:03:24 <kmc> kulin, i don't use anything special for haskell compared to other languages
00:03:30 <ivanm> kulin: emacs
00:03:33 <Pseudonym> Congratulations, you are picky about your tools.  Therefore you are one of us.
00:03:44 <kmc> just editor (emacs or vim) and compiler / REPL, tab between them with screen or xmonad
00:03:49 <ivanm> kulin: just about everyone here uses a text editor of some kind
00:03:54 <ivanm> rather than an IDE
00:04:10 <ivanm> other choices: texmate (OSX), geany, nedit, jedit, kate
00:04:18 <ivanm> I think that covers the main popular ones
00:04:41 <Adamant> Pseudonym: gabba gabba hey?
00:05:01 <kmc> nano
00:05:01 <ivanm> http://chart.apis.google.com/chart?cht=bhs&chs=500x300&chd=e:..9gtmR0JNGtFXEaEaDECT&chxt=x,y&chxl=1:%7CKate+-+1%25%7Cyi+-+2%25%7CNotepad%2b%2b+-+3%25%7CGedit+-+3%25%7CEclipse+%2f+EclispeFP+-+3%25%7CTextMate+-+4%25%7CLeksah+-+6%25%7COther+-+12%25%7CCommand+line+REPL+-+30%25%7CEmacs+%2f+haskell-mode+-+40%25%7Cvi+-+42%25&chxr=0,0.0,334.0&chbh=a
00:05:07 <kulin> i probably just need to learn elisp and write what i want for emacs
00:05:09 <ivanm> gah, didn't realise that was a live generated one
00:05:20 <Jonno_FTW> ivanm: I installed using darcs but it didn't finish, this time with a different error
00:05:22 <ivanm> kmc: people actually use nano for serious editing? I just use it to quickly hack something
00:05:26 <ivanm> Jonno_FTW: huh
00:05:29 <kmc> i know a few who do
00:05:33 <kmc> they get made fun of though
00:05:52 <ivanm> heh
00:06:05 <Jonno_FTW> cabal: Error: some packages failed to install:
00:06:05 <Jonno_FTW> ghc-paths-0.1.0.6 failed during the configure step. The exception was:
00:06:05 <Jonno_FTW> ExitFailure 1
00:06:05 <Jonno_FTW> haskell-src-exts-1.9.0 failed during the configure step. The exception was:
00:06:05 <Jonno_FTW> ExitFailure 1
00:06:06 <ivanm> but yes, vi and emacs cover about 80% of the community by the looks of things
00:06:07 <Jonno_FTW> hint-0.3.2.3 depends on ghc-paths-0.1.0.6 which failed to install.
00:06:10 <Jonno_FTW> lambdabot-4.2.2.1 depends on haskell-src-exts-1.9.0 which failed to install.
00:06:12 <Jonno_FTW> mueval-0.8 depends on ghc-paths-0.1.0.6 which failed to install.
00:06:13 * shachaf tried and failed to get sam running yesterday.
00:06:27 <ivanm> Jonno_FTW: wow, which version of GHC?
00:06:40 <ivanm> what error did you get for ghc-paths?
00:06:47 <Jonno_FTW> jonno@max-damage:~/lambdabot$ ghc --version
00:06:48 <Jonno_FTW> The Glorious Glasgow Haskell Compilation System, version 6.12.1
00:06:49 <ivanm> my guess for haskell-src-exts is that you didn't have happy installed
00:06:57 <ivanm> because I've got all of those installed
00:07:04 <ivanm> with 6.12.3
00:07:21 <Jonno_FTW> I tried to upgraed ghc but that failed, and now dpkg complains about it
00:07:39 <kulin> how was that chart generated?
00:07:49 <ivanm> kulin: using google chart APIs
00:07:57 <kulin> ok, populated :)
00:08:09 <ivanm> but the data was from the survey tibbe did a month or so ago
00:08:09 <cwb> kulin, if you'd like to use vim, you can use slime.vim to paste things into the REPL easily (C-c C-c).
00:08:19 <ivanm> http://blog.johantibell.com/2010/08/results-from-state-of-haskell-2010.html
00:08:52 <Jonno_FTW> ivanm: so should I install happy? or attempt to upgrade ghc?
00:14:32 <Jonno_FTW> ivanm: happy is installed and the latest version
00:15:47 <Jonno_FTW> and when I run cabal install happy, I get: <command line>: cannot satisfy -package Cabal-1.8.0.2:  Cabal-1.8.0.2-72f6eafc7def741b28f6ec75d2686d14 is unusable due to missing or recursive dependencies:
00:34:16 <Jonno_FTW> no ideas?
00:34:51 <Jonno_FTW> should I completely remove the entire haskell setup and start from scratch?
00:36:09 <ivanm> Jonno_FTW: might be a good idea
00:36:20 <Jonno_FTW> It's not even my machine
00:36:25 <Jonno_FTW> I just have root access
00:36:43 <ivanm> oooohhh.....
00:36:49 <ivanm> consider the possibilities! :D
00:37:12 <Jonno_FTW> ....
00:38:16 <Jonno_FTW> is there no other way?
00:38:46 <ivanm> does "ghc-pkg check" bitch?
00:38:53 <ivanm> have you been using cabal upgrade?
00:40:07 <Jonno_FTW> max-damage:/home/jonno/lambdabot# ghc-pkg check
00:40:08 <Jonno_FTW> WARNING: cache is out of date: /var/lib/ghc-6.12.1/package.conf.d/package.cache
00:40:16 <Jonno_FTW> so I did that
00:40:28 <Jonno_FTW> and then it told me to ghc-pkg recache
00:40:39 <ivanm> if it's just your local cache, then get rid of that
00:40:55 <Jonno_FTW> max-damage:/home/jonno/lambdabot# ghc-pkg recache
00:40:56 <Jonno_FTW> ghc-pkg: /root/.ghc/i386-linux-6.12.1/package.conf.d/unlambda-0.1-601bc7704196b7ec58170920ab22d694.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
00:41:16 <Jonno_FTW> what's up with that error?
00:41:31 <ivanm> ugh
00:41:39 <ivanm> looks like problems
00:41:56 <Jonno_FTW> can they be fixed?
00:42:03 <ashley_s> How is parMap implemented?
00:42:11 <Jonno_FTW> even though it screwed up partway through installation?
00:42:19 <Jonno_FTW> @src parMap
00:42:19 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:42:28 <c_wraith> ashley_s, it's implemented in terms of par
00:42:30 <c_wraith> @index par
00:42:30 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
00:42:46 <c_wraith> The implementation is actually pretty straight-forward, once you see how par works.
00:43:08 <jutaro> Johhno_FTW: This is a problem, that UTF-8 chars don't work in cabal files with ghc-pkg, but they are accepted when uploading a package to hackage.
00:43:28 <Jonno_FTW> this is a pretty significant problem
00:43:39 <jutaro> So Ørjan Johansen wrote unlambda, which is unfortunate
00:43:59 <jutaro> My real name is Jürgen, so I know
00:44:24 <Jonno_FTW> what do I do then?
00:44:37 <Jonno_FTW> edit unlambda and install?
00:45:21 <ivanm> jutaro: really?
00:45:25 * ivanm tries installing unlambda
00:45:49 <jutaro> This is at least possible: cabal unpack unlambda, the edit the cabal file and cabal install from this folder
00:46:32 <ivanm> jutaro: I just installed unlambda, and ghc-pkg doesn't seem to be bitching
00:46:54 <ivanm> what is more likely is that the encoding of the file doesn't match the encoding of Jonno_FTW's system
00:46:57 <Jonno_FTW> oh wow
00:46:59 <Jonno_FTW> it worked
00:47:08 <Jonno_FTW> I just changed the author and it installed
00:49:35 <Jonno_FTW> it installed but ghc-pkg check, still bitches
00:50:46 <Jonno_FTW> and it won't let me run ghc-pkg recache
00:51:26 <ivanm> ghc-pkg recache --user ?
00:51:35 <ivanm> (assuming you did user-based installs with cabal-install)
00:52:08 <Jonno_FTW> I get the same error
00:52:24 <ivanm> try unregistering that package
00:52:31 <Jonno_FTW> how?
00:52:32 <ivanm> ghc-pkg unregister unlambda
00:53:07 <Jonno_FTW> that worked
00:53:19 <ivanm> OK, so recache shouldn't bitch now
00:53:21 <ivanm> now install it again
00:53:47 <Jonno_FTW> install lambdabot?
00:54:06 <ivanm> re-do unlambda again first from your edited copy
00:54:07 <Jonno_FTW> from darcs or hackage?
00:54:11 <Jonno_FTW> ok
00:56:19 <Jonno_FTW> when i install lambdabot now, I get the error about src-exts again
00:58:59 <ivanm> Jonno_FTW: do you have happy installed?
00:59:03 <Jonno_FTW> yes
00:59:03 <ivanm> and what's the actual error?
00:59:28 <Jonno_FTW> cabal: Error: some packages failed to install:
00:59:28 <Jonno_FTW> ghc-paths-0.1.0.6 failed during the configure step. The exception was:
00:59:29 <Jonno_FTW> ExitFailure 1
00:59:29 <Jonno_FTW> haskell-src-exts-1.9.0 failed during the configure step. The exception was:
00:59:29 <Jonno_FTW> ExitFailure 1
00:59:31 <Jonno_FTW> hint-0.3.2.3 depends on ghc-paths-0.1.0.6 which failed to install.
00:59:33 <Jonno_FTW> lambdabot-4.2.2.1 depends on haskell-src-exts-1.9.0 which failed to install.
00:59:35 <Jonno_FTW> mueval-0.8 depends on ghc-paths-0.1.0.6 which failed to install.
00:59:50 <ivanm> Jonno_FTW: it should say what the actual error was
00:59:58 <ivanm> if not, re-run it with --verbose=3 or something
01:00:03 <Jonno_FTW> k
01:01:07 <Jonno_FTW> I get the same error
01:01:19 <ivanm> paste the entire build output somewhere
01:02:55 <Jonno_FTW> k
01:03:39 <Jonno_FTW> just gotta install a command line psatebinner
01:04:16 <ivanm> or xsel or something
01:04:21 * ivanm likes wgetpaste
01:04:30 <Jonno_FTW> http://pastebin.com/y3NYYSx4
01:05:10 <ivanm> is that --verbose=3 ?
01:05:17 <Jonno_FTW> yes
01:05:20 <ivanm> try "cabal install haskell-src-exts --verbose=3"
01:05:36 <ivanm> maybe even remove the downloaded version
01:05:44 <Jonno_FTW> Will putting > log.txt on the end of that command be correct?
01:05:52 <ivanm> yeah, should be OK
01:06:01 <ivanm> Jonno_FTW: actually, maybe not
01:06:07 <Jonno_FTW> hmm?
01:06:08 <ivanm> 2>&1 > log.txt
01:06:14 <ivanm> in case there's stderror output
01:08:23 <Jonno_FTW> http://pastebin.com/jwE6kqzK
01:09:37 <Jonno_FTW> It also seemed to chop some stuff when logging
01:09:55 <ivanm> yes
01:10:00 <ivanm> maybe you're pasting too much stuff?
01:10:37 <Jonno_FTW> maybe
01:11:04 <Jonno_FTW> this was the last error: <command line>: cannot satisfy -package Cabal-1.8.0.2:
01:11:04 <Jonno_FTW>     Cabal-1.8.0.2-72f6eafc7def741b28f6ec75d2686d14 is unusable due to missing or recursive dependencies:
01:11:07 <Jonno_FTW>       directory-1.0.1.0-10fc46e61b67ff4a83f3e553454d003c process-1.0.1.2-8b5308cb23fbdc3c2df27e298550937f
01:11:11 <Jonno_FTW>     (use -v for more information)
01:11:23 <ivanm> "ghc-pkg check" doesn't bitch?
01:11:41 <Jonno_FTW> nope
01:11:45 <Jonno_FTW> gives no output
01:11:58 <Jonno_FTW> should I unregister directory and process?
01:12:04 <ivanm> no
01:12:08 <ivanm> not if you want ghc to work
01:12:19 <ivanm> it looks like you've borked your system
01:12:21 <Jonno_FTW> then what do i do?
01:12:36 <Funktorsalat> reinstall cabal maybe
01:12:41 <ivanm> have you been doing all this with user installs or global installs?
01:12:52 <Jonno_FTW> as root
01:12:54 <ivanm> Funktorsalat: not sure if that'll fix it; sounds like there are underlying problems
01:13:03 <ivanm> Jonno_FTW: didn't answer my question
01:13:13 <ivanm> does "ghc-pkg list" mention a user pkg-db?
01:13:20 <Funktorsalat> ivanm: well, if it's the same problem as I often have, he has a working directory and process
01:13:25 <ivanm> in /root/.ghc/
01:13:25 <Funktorsalat> just with a different ABI hash
01:13:40 <ivanm> Funktorsalat: then again, it's Cabal: no part of GHC will dep on it
01:13:42 <Funktorsalat> so he'd just need to compile cabal against his actual directory and process
01:14:00 <ivanm> yeah
01:14:15 <ivanm> but it sounds like he upgraded directory and process, which is generally considered a bad thing to do
01:15:59 <Jonno_FTW> ivanm: http://pastebin.com/ppgqaNCM
01:16:25 <ivanm> Jonno_FTW: user install
01:16:33 <ivanm> so rm -rf /root/.ghc/
01:16:41 <Jonno_FTW> hmk
01:17:00 <Jonno_FTW> then what?
01:17:14 <ivanm> then reinstall whatever you want to install
01:17:43 <ivanm> i.e. go into your lambdabot directory and run "cabal install" there
01:17:46 <Jonno_FTW> as root?
01:18:08 <ivanm> well, as whatever user you want it installed into
01:18:09 * Jonno_FTW doesn't want to soud clueless, I just want to do it right
01:18:21 <ivanm> if you want it installed globally, you need to do cabal install --global or something
01:18:36 <ivanm> but with something like lambdabot it's probably an idea to try doing it locally first
01:19:07 * ivanm -> dinner
01:19:17 * Jonno_FTW -> frisbee
01:23:04 <luite> is there a mutable unboxed array type that automatically grows when adding more elements?
01:24:45 <c_wraith> luite, everything I've seen is fixed-size.
01:37:49 <lispy> hmm...if I have a tree type and the internal nodes and the leaf nodes have different structure, is there a way to make them be different types?
01:38:30 <opqdonut> sure
01:38:52 <opqdonut> but why do you want to do that?
01:39:00 <lispy> For type saftey
01:39:10 <opqdonut> ok, I recommend using a GADT
01:39:27 <opqdonut> implementing it with mutually recursive normal datatypes is ok but a bit hairy
01:39:28 <lispy> opqdonut: can you provide an example of how you'd do this?
01:40:38 <opqdonut> data Leaf; data Node; data Tree t a where TreeNode :: a -> (Tree t a) -> (Tree s a) -> Tree Node a; TreeLeaf :: Int -> Tree Leaf a;
01:40:58 <opqdonut> for having arbitrary data (of type a) in the nodes and integer data in the leafs
01:41:23 <lispy> yes, thanks I'll give that whirl
01:41:29 <opqdonut> off the top of my head, you might not need the phantom types
01:41:45 <opqdonut> depending on which type of safety you need
01:42:56 <lispy> Well, my tree is balanced and one of the properties is that leafs are only at one level
01:43:03 <lispy> The bottom level, to be precise
01:43:17 <opqdonut> ah
01:43:25 <lispy> So I wanted my data structure to make it so that the internal nodes are separate (so I can enforce that invariant)
01:43:28 <opqdonut> then you can use a trick
01:43:35 <opqdonut> that the finger tree guys used
01:43:41 <opqdonut> I'll dig up the paper
01:43:48 <lispy> thanks
01:44:16 <opqdonut> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html section 3
01:45:06 <opqdonut> a GADT-based solution might be clearer, but that's H98 compatible
01:45:12 <opqdonut> and it is cute in its way
01:46:09 <lispy> cool, thanks
01:46:23 <opqdonut> np
01:46:30 <lispy> 2-3 trees look (at least superficially) very similar to b+ trees
01:46:51 <lispy> which is actually what I set out to make
01:46:54 <opqdonut> yeah the idea is similar
01:48:16 <shachaf> lispy: Hmm, you're writing a B+ tree in Haskell?
01:48:22 * shachaf would be curious to see it when you're done.
01:50:25 <lispy> shachaf: yeah, partially inspired by your questions earlier about the btree filesystem
01:50:32 <lispy> shachaf: But, I have other planned uses for it
01:53:59 <aruns> hi does anyone have wxHaskell working on win/mingw ?
01:56:20 <aruns> i'm running into problems with undefined references to LoadLibrary at the linker stage.
02:00:56 <Maxdamantus> Is there something like (\f (a,b) -> (f a, f b)) in the standard libraries?
02:02:32 <shachaf> @ty join (***)
02:02:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
02:02:45 <shachaf> > join (***) succ (5,3)
02:02:46 <lambdabot>   (6,4)
02:03:04 <Maxdamantus> O_o
02:03:19 <shachaf> Maxdamantus: That's a "kind of".
02:03:26 <Maxdamantus> :t (***)
02:03:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:03:39 <Maxdamantus> @hoogle (***)
02:03:39 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:07:50 <lispy> opqdonut: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29761#a29761
02:07:51 <copumpkin> shachaf: unfortunately the join solution forces the two tuple elements to have the same type
02:07:57 <lispy> opqdonut: That's what I'm looking at, currently
02:09:00 <shachaf> copumpkin: Oh, that's true.
02:09:12 <shachaf> copumpkin: To be fair, so does Maxdamantus's function.
02:11:01 <Maxdamantus> > (\f (a,b) -> (f a, f b)) (+1) (42,41.5)
02:11:02 <lambdabot>   (43.0,42.5)
02:11:06 <Maxdamantus> Hm.
02:11:13 <shachaf> :t (\f (a,b) -> (f a, f b))
02:11:14 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
02:12:01 <ClaudiusMaximus> :t let g f (a,b) = (f a, f b) in g
02:12:01 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
02:16:05 <yitz> @hoogle (a->b)->(a,a)->(b,b)
02:16:05 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
02:16:05 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
02:16:05 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
02:16:23 <yitz> @type (&&&)
02:16:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:18:04 <yitz> @hoogle Arrow a => a b c -> (b,b) -> (c,c)
02:18:04 <lambdabot> Data.Graph.Inductive.Query.BFS leveln :: Graph gr => [(Node, Int)] -> gr a b -> [(Node, Int)]
02:18:04 <lambdabot> Data.Graph.Inductive.Query.BFS bfen :: Graph gr => [Edge] -> gr a b -> [Edge]
02:18:04 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
02:21:14 * hackagebot generic-deriving 0.3 - Generic programming library for generalized deriving.  http://hackage.haskell.org/package/generic-deriving-0.3 (JosePedroMagalhaes)
02:21:54 <maurer_> I'm trying to run an external program and capture the output, and have been trying
02:21:54 <maurer_>              (stdin, stdout, stderr, h) ← runInteractiveProcess
02:21:55 <maurer_>                                             out [] Nothing Nothing
02:21:55 <maurer_>             ret ←  hGetContents stdout
02:21:55 <maurer_>             ec  ←  waitForProcess h
02:21:55 <maurer_>             print ret
02:21:55 <maurer_> However, this keeps yielding "" even though the actual program outputs a string. Ideas?
02:22:59 <ivanm> maurer_: please use a paste site next time
02:23:13 <ivanm> I think I know about your problem; lemme dig something up
02:23:19 <maurer_> ivanm: Sorry, just figured it was moderately short and nobody was talking.
02:23:39 <ivanm> maurer_: https://ivanmiljenovic.wordpress.com/wp-admin/post.php?post=84&action=edit
02:23:47 <ivanm> maurer_: it's easier to read code in a paste site ;-)
02:23:57 <maurer_> ivanm: That's the edit link for the post
02:24:51 <ivanm> it is? dammit
02:24:58 <ivanm> http://ivanmiljenovic.wordpress.com/2009/12/10/command-inputoutput-and-blocking/
02:28:04 <maurer_> ivanm: Where is hGetContents' from?
02:28:29 <ivanm> I wrote it
02:29:16 <maurer_> OK. I'll check graphviz for it (my best guess is that hGetContents is not harvesting the output befor the program finishes, the program finishes and the data disappears)
02:29:18 <ivanm> hgetCOntents' h = do { r <- hGetContents h; evaluate $ length r; return r }
02:29:21 <ivanm> maurer_: ^^
02:32:05 <maurer_> Hm. Simply switching hGetContents for hGetContents' doesn't seem to solve the problem :/
02:32:19 <orbital_fox> are all impure functions starting with IO?
02:33:19 <ivanm> maurer_: you need the hclose
02:33:25 <ivanm> orbital_fox: ST?
02:33:27 <ivanm> STM
02:33:28 <ivanm> etc.
02:33:39 <ivanm> anything with liftIO
02:33:44 <ivanm> @hoogle liftIO
02:33:44 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
02:33:48 <ivanm> @instances MonadIO
02:33:48 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
02:34:17 <orbital_fox> ivan, ok, so not just IO then
02:35:12 <aruns> ghc is giving me some 'undefined reference' linker errors while compiling a wxHaskell app - a very basic one. i checked the command line with verbose mode (-v3) and have checked the directories for the libraries are present with the -L switch and the library itself with -lkernel32 -lole32. anyone have any clue what might be going on?
02:35:44 <maurer_> ivanm: I've tried adding mapM_ hClose [stdin, stdout, stderr] right after that, but it doesn't change anything.
02:36:20 <ivanm> maurer_: try using it with bracket, etc.
02:36:24 <maurer_> OK
02:36:52 <ivanm> grab the latest version of the graphvizWithHandle' function that I have in Data.GraphViz.Commands and base your way on that
02:37:07 <ivanm> (note that I have some extra fancy things there like hSetBinaryMode that won't apply to you though)
02:39:16 <yitz> maurer_: that doesn't look like the right way to capture output. why are you sending output that you want to capture directly to stdout?
02:40:03 <maurer_> yitz: Another program produces some output. I run that program and it produces said output on standard out (I don't have a choice in that). I just want to get it into haskell.
02:43:19 <yitz> maurer_: oh i see, "stdout" is not the regular stdout, it is the "stdout" of the process. that's a bit confusing.
02:43:58 <Kaidelong> does haskell have a general type class for collections of objects on which you can turn it into a list of the type it contains? Foldable?
02:44:17 <c_wraith> yeah, Foldable is approximately that.
02:44:34 <c_wraith> Though the class is really complicated for just that functionality
02:45:27 <Kaidelong> yeah
02:45:44 <Kaidelong> I was also thinking that any such class should imply both Monad and Monoid
02:45:48 <yitz> maurer_: yeah i'm not sure how lazy handle input interacts with a process like that. can you use something strict instead of hGetContents?
02:45:50 <maurer_> yitz, ivanm: This is my bad. I replaced "out []" with "/bin/echo" ["test"] and it worked.
02:46:02 <maurer_> I'm going to try to figure out what's going on.
02:46:52 <Kaidelong> maybe not actually
02:47:12 * maurer_ is an idiot.
02:47:35 <maurer_> I assumed runProcess allowed for relative paths, i.e. implicitly placed "." in the PATH
02:47:37 <maurer_> Oop.
02:47:38 <maurer_> *Oops.
02:55:38 <Kaidelong> so as I was sending to the wrong channel elsewhere
02:56:00 <Kaidelong> are there things you may want to filter over that you can't filter over with (>>=)
02:56:10 <Kaidelong> or couldn't potentially
02:56:22 <Kaidelong> like the data structure itself could not possibly be considered a monad
02:56:49 <c_wraith> Kaidelong, I fear that the filtering view won't obey the monad laws often
02:56:52 <ivanm> Kaidelong: if you consider the normal version of a monad, then Set is the easiest option which you may want to filter over
02:57:22 <Kaidelong> Sets are not monads then?
02:57:42 <ivanm> no
02:57:49 <ivanm> unless you use rmonad or something
02:58:05 <ivanm> because a Monad by default doesn't let you constrain the types the data type contains
02:58:32 <Kaidelong> I would think you could do return as a singleton set, join as the set formed by the union of all its component sets, and functor through the use of map
02:58:35 <Kaidelong> hmm
02:58:43 <ivanm> Kaidelong: return (+) ;-)
02:58:53 <ivanm> > length $ return (+)
02:58:53 <lambdabot>   1
02:59:02 <ivanm> > Set.size $ Set.singleton (+)
02:59:03 <lambdabot>   Not in scope: `Set.size'Not in scope: `Set.singleton'
02:59:06 <ivanm> bah
02:59:10 <ivanm> > S.size $ S.singleton (+)
02:59:11 <lambdabot>   1
02:59:14 <ivanm> :o
02:59:19 <quicksilver> ;)
02:59:25 <ivanm> quicksilver: laziness?
02:59:28 <quicksilver> Set doesn't require Ord.
02:59:41 <quicksilver> but some of the operations on it do
03:00:00 <quicksilver> including union/insert which you need for join
03:00:01 <ivanm> I would have thought singleton did
03:00:02 <Kaidelong> oh underlying tree implementation getting in the way is what you were mentioning then
03:00:09 <ivanm> oh, right, you can't put anything else in
03:00:25 <Kaidelong> that seems silly
03:00:26 <ivanm> Kaidelong: well, anything that places a restriction on the types it can have
03:00:34 <ivanm> @hackage rmonad
03:00:34 <lambdabot> http://hackage.haskell.org/package/rmonad
03:00:37 <ivanm> Kaidelong: ^^
03:00:53 <ivanm> quicksilver: I'm guessing singleton doesn't need Ord since no comparisons are needed for only one value?
03:01:06 <ivanm> > S.size $ S.fromList [(+)]
03:01:07 <lambdabot>   1
03:01:18 <ivanm> OK, that definitely needs Ord
03:01:18 <Kaidelong> for the purposes of a set you wouldn't always have to compare values using Ord, anyway, would you?
03:01:21 <ivanm> so why didn't that bork?
03:01:32 <ivanm> Kaidelong: with the current implementation you typically do
03:01:38 <c_wraith> > (+) < (-)
03:01:38 <ivanm> any time you want to add a value, remove a value, etc.
03:01:39 <lambdabot>   *Exception: (==): No overloading for function
03:01:57 <c_wraith> That's...  not a compile error
03:01:57 <ivanm> > compare (+) (+)
03:01:58 <lambdabot>   *Exception: (==): No overloading for function
03:02:07 <Kaidelong> needs to manipulate the tree. But you could use something like a memory address or a hash as a desperation measure
03:02:10 <yitz> @type S.fromList
03:02:10 <c_wraith> Why is there an Ord instance for functions?
03:02:11 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
03:02:16 <ivanm> c_wraith: yes; looks like someone has made functions an instance of Ord...
03:02:17 <c_wraith> in lambdabot, that is.
03:02:23 <ivanm> c_wraith: Caleskell
03:02:26 <Kaidelong> perhaps you could make a type constructor that turns things that aren't Ord into things that are
03:02:33 <Kaidelong> and do it that way
03:02:36 <ivanm> Kaidelong: ummm..... how?
03:02:36 <c_wraith> I think it's because there's the Num instance for functions, actually
03:02:43 <c_wraith> But it's implemented as "error ..."
03:02:48 <ivanm> unless you have random comparisons
03:03:01 <ivanm> c_wraith: Num doesn't require Ord though
03:03:04 <ivanm> @src Num
03:03:05 <lambdabot> class  (Eq a, Show a) => Num a  where
03:03:05 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:03:05 <lambdabot>     negate, abs, signum     :: a -> a
03:03:05 <lambdabot>     fromInteger             :: Integer -> a
03:03:08 <ivanm> just Eq and Show ^^
03:03:09 <c_wraith> Oh, you're right
03:03:12 <ivanm> > (+) == (+)
03:03:12 <lambdabot>   *Exception: (==): No overloading for function
03:03:20 <ivanm> c_wraith: ^^ there's the problem
03:03:29 <Kaidelong> ivanm: comparing memory addresses
03:03:31 <c_wraith> Still, there's an Ord instance, or it wouldn't even compile
03:03:43 <ivanm> Kaidelong: (+) doesn't ahve a memory address
03:03:53 <c_wraith> Kaidelong, that assumes memory addresses are stable, which isn't true for garbage-collected languages
03:03:55 <ivanm> Kaidelong: and how would you compare (*2) and (\ x -> x + x) ?
03:04:32 <Kaidelong> hmm, I suppose you'd have to do what something like .NET does and give each value a unique ID so that it can be put in things like sets
03:05:07 <Kaidelong> I guess that's one of the nice things about runtime types
03:05:09 <ivanm> Kaidelong: what, can .Net tell that (*2) and (2*) are equal, let alone (\ x -> x + x) ?
03:05:31 <Kaidelong> ivanm: it could tell that they are the same object, not neccessarily that they are equal
03:05:49 <Kaidelong> FastFunc and Func are objects just like anything else
03:06:05 <ivanm> Kaidelong: how could it tell they are the same?
03:06:19 <ivanm> does it go and compare the domain, co-domain, etc. ?
03:06:23 <Kaidelong> each object is given a unique identifier at runtime
03:06:37 <Kaidelong> two objects with equal values can be given different objects
03:06:41 <Kaidelong> err
03:06:44 <Kaidelong> different identities
03:06:50 <Kaidelong> so those will not be equal
03:07:00 <ivanm> so, I can use (*2) twice and each one will be unequal from the other
03:07:04 <Kaidelong> but you can have some idea of putting them in a set and searching for one by its identities
03:07:04 <ivanm> in that case, it's Ord instance is useless
03:07:41 <Kaidelong> well you won't be able to avoid duplicate insertions into your set but you could keep a balanced tree and save on some time
03:08:00 <Kaidelong> also strictly speaking the two would be different objects anyway
03:08:07 <ivanm> and it will be a horrible failure
03:08:19 <ivanm> Kaidelong: you can't then do Set.member (2*)
03:08:42 <Maxdamantus> How might I go about changing something like http://codepad.org/DaAEcudM so it doesn't require hundreds of megabytes of memory?
03:08:43 <copumpkin> you could with my enumerable package, if you didn't mind being horribly efficient and restricting yourself to finite domain
03:09:16 <ivanm> copumpkin: is that the one that tests for equality by seeing if it's an inductive function, etc.?
03:09:23 <Kaidelong> ivanm: no, the language design would have to be very different
03:09:31 <copumpkin> its main purpose is to enumerate all values of a given type
03:09:35 <copumpkin> including all values of function types
03:09:41 <copumpkin> and by extension, can tell if functions are equal
03:09:43 <Kaidelong> well, technically I suppose you could have it
03:09:45 <ivanm> copumpkin: wasn't there a cafe discussion about that recently?
03:09:47 <Kaidelong> but it'll always return false
03:09:51 <copumpkin> ivanm: beats me
03:09:56 <Kaidelong> since the (*2) will construct a new, unique object
03:09:56 <ivanm> Maxdamantus: did you profile?
03:10:05 <ivanm> Kaidelong: my point precisely
03:10:07 <Kaidelong> that the set can't possibly already contain
03:10:09 <Maxdamantus> Hm, no.
03:10:23 <Kaidelong> so it wouldn't be an error but it wouldn't be useful
03:10:24 <ivanm> if you can't tell that (2*) and (*2) are the same function, then you can't do function equality
03:10:40 <ivanm> Maxdamantus: we already have brainfuck interpreters you know...
03:10:52 <Maxdamantus> I know, just figuring out how to make my own
03:10:58 <ivanm> @bf ++++++++++[>+++++++>++++++++++>+++++++++++>+++>++++++++++++>++++<<<<<<-]>++.>+.>--..+++.>++.>-.<<.+++.------.<-.>>>>++++.<<.>---.<<<++++.>---.>>-.<.<.>>.<.<<-------.>>.>+.<<<++++.>>>-.+.
03:10:58 <lambdabot>   Hello world, this is a test
03:11:02 <Kaidelong> but if you pass it an instance of an existing object that'd be a different story
03:11:10 <Kaidelong> err
03:11:16 <Kaidelong> an existing object
03:11:20 <Kaidelong> no need to say instance
03:11:22 <ivanm> Kaidelong: I hate to tell you this, but we don't really have instances in the OO sense of the word... ;-)
03:11:30 <ivanm> nor objects
03:11:36 <Kaidelong> Yeah
03:11:40 <ivanm> Maxdamantus: using ! looks bad
03:11:50 <ivanm> oh, wait, it's an array
03:11:51 <ivanm> nvm
03:11:52 <Kaidelong> I guess the fact that Set requires Ord is one of the problems with that approach
03:11:52 <shachaf> Since when does @bf work?
03:12:00 <ivanm> Maxdamantus: using // is bad though
03:12:02 <copumpkin> ! is arrays or maps, usually
03:12:05 <ivanm> shachaf: since always!
03:12:11 <Kaidelong> since some things are hard to think of at a value level
03:12:11 <shachaf> ivanm: I've never seen it work before since I first joined #haskell.
03:12:18 <Maxdamantus> Oh.
03:12:24 * Maxdamantus looks back at that array article
03:12:25 <ivanm> well, ! is bad from a total function point of view; using it for arrays is OK for a performance POV
03:12:38 <ivanm> Maxdamantus: however, IIRC // is expensive
03:21:39 <Maxdamantus> So what's an alternative to using // there?
03:22:15 <Maxdamantus> Ah, maybe not using Data.Array.array
03:22:26 <Maxdamantus> Data.Array.IO.newArray perhaps
03:22:45 <opqdonut> lispy: looks fine, but do you really need a parent pointer? it will ruin sharing
03:39:26 <ManateeLazyCat> Hi all. :)
03:39:26 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
03:41:09 <ManateeLazyCat> ivanm: Are you there?
03:44:47 <ivanm> ManateeLazyCat: for a bit
03:44:54 <ivanm> (have to go back to finish marking)
03:46:07 <luite> does Integer have some fast way to count 1-bits?
03:47:46 <opqdonut> luite: using Data.Bits I guess
03:47:59 <yitz> > 2 .&. 1 :: Integer
03:48:00 <lambdabot>   0
03:48:16 <yitz> yeah Integer has a Bits instance
03:48:18 <opqdonut> err?
03:48:20 <opqdonut> ah, and
03:48:36 <opqdonut> > testBit (123::Integer) 3
03:48:37 <lambdabot>   True
03:48:57 <luite> opqdonut: that's rather inefficient, I mean something that uses __builtin_popcount or something like that, on the underlying array
03:49:23 <opqdonut> haven't bumped into anything like that
03:49:57 <yitz> luite: i can't imagine there's anything faster than O(log n)
03:50:11 <luite> yitz: it's low level optimization
03:50:21 <yitz> ?
03:51:24 <yitz> do processors have a bit count instruction these days? never heard of that. so anyway you've got to count them.
03:52:06 <opqdonut> you can tabulate the bitcounts for bytes and use that
03:52:15 <yitz> true
03:52:15 <luite> some processors do, but I don't think the x86 ones have. the __builtin_popcount gcc primitive should use an architecture specific fast way to count the bits
03:52:26 <opqdonut> probably way faster than iterating testBit
03:52:45 <luite> it may use some floating point trick to do so
03:53:02 <opqdonut> luite: you can of course access the internal representation of the Integer
03:53:36 <yitz> luite: check to see if GMP has such an operation.
03:55:25 <luite> ah there's mpz_popcount
03:57:00 <luite> but I have no idea how to call it with an Integer
03:58:03 <yitz> luite: or the low-level mpn_popcount
03:59:34 <yitz> luite: ghc allows you to install your own implementation of Integer. the default GMP is actually a separate package, on hackage. You can modify that to give you access to the function you need.
04:01:14 <yitz> luite: hmm, no it's actually not on hackage. but you'll find it in ghc darcs. integer-gmp.
04:01:40 <luite> hmm, I thought that could only be changed by recompiling ghc
04:01:46 <yitz> luite: could be
04:12:19 * hackagebot bits-extras 0.1.2 - Efficient high-level bit operations not found in Data.Bits  http://hackage.haskell.org/package/bits-extras-0.1.2 (GabrielWicke)
04:13:36 <luite> hehe it has a populationcount function
04:14:25 <luite> unfortunately no for Integer
04:18:56 <luite> and it doesn't work on windows :(
04:21:03 <yitz> really? why shouldn't it work on windows?
04:21:51 <luite> "/Issues:/ A GCC-provided library, @libgcc_s@, is dynamically linked to provide software fallbacks on architectures without instructions corresponding to specific operations. This is currently only expected to work on Linux systems, and even there can lead to issues with GHCi's custom linker. A workaround for GHCi on a linux system: @ln -s \/lib\/libgcc_s.so.1"
04:22:42 <luite> oh I missed the last part
04:30:01 <luite> it gives linker errors, so I guess the description is right...
04:43:44 <Philonous> I really like ironic types: "empty :: full" (as seen in Data.ListLike.Base). 
04:54:29 <yitz> > let single = 1 in single :: Double
04:54:30 <lambdabot>   1.0
04:56:19 <fxr> I'm connecting to my linux machine from putty but couldn't see left arrow, :: and some more symbols in emacs. Instead it shows a box. Are there any solutions for this type of problem?
04:56:52 <ramb0> !src map
04:56:56 <ramb0> @src map
04:56:56 <lambdabot> map _ []     = []
04:56:56 <lambdabot> map f (x:xs) = f x : map f xs
04:57:00 <ramb0> @src (>)
04:57:01 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
05:02:03 <ramb0> Hey
05:02:19 <ramb0> How can I get the definition of operators for some data types?
05:07:02 <Saizan> @src (>) Int
05:07:03 <lambdabot> Source not found. :(
05:07:30 <Saizan> ramb0: it's probably best to look at the actual source files
05:07:40 <ramb0> I don't know where to look :(
05:09:13 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ <- these are the docs for the core libs, the definitions have links to the source, for typeclass methods it's a bit harder since you've to look for where the instance is defined yourself
05:09:42 <Saizan> if you don't know in which module a symbol is define you can look it up in hayoo or hoogle
05:09:54 <Saizan> *defined
05:10:09 <Saizan> hackage has similar docs for other packages
05:10:38 <ramb0> Yeah, Ive found that page, but, for example, when I look into Data.List
05:10:44 <ramb0> there's no type declaration
05:11:21 <Philonous> ramb0: List is special. data [] a = [] | a : ([] a) -- not actual haskell code
05:12:57 <Philonous> ramb0: This isn't a valid data declaration, so it has to be build into the compiler, which is somewhat unfortunate 
05:13:13 <ramb0> Ok, well.. There's no order defined for List, But it uses "Deriving Ord.." it says that you can onlye assign orderable elements? Or that a list is orderable if and only if its elements are.. ?
05:14:18 <Saizan> the latter
05:14:35 <Philonous> ramb0: "derving Ord" means that it will generate an appropriate instance. So you will get "instance Ord a => Ord [a] where ..." for free. 
05:14:42 <Saizan> how deriving works is explained in the haskell report
05:14:49 <Saizan> ?where haskell
05:14:49 <lambdabot> http://haskell.org
05:14:54 <Saizan> ?where report
05:14:54 <lambdabot> http://www.haskell.org/onlinereport/
05:15:18 <Saizan> in short, it's lexicographic ordering :)
05:15:56 <ramb0> Yeah, I know, but It messed me that a list can derive "Ord" from a non-orderable type
05:17:08 <Philonous> ramb0: It can't. The instance is "Ord a => Ord [a]", so you only get ordering for lists with orderable elements
05:18:06 <Philonous> ramb0: So you can't for example compare lists of functions
05:18:39 <ramb0> About functions..
05:19:02 <ramb0> A function that goes from a -> b, can a be another function?
05:19:16 <Philonous> Sure. Any type at all
05:19:58 <Jafet> Hm, I can only think of one function of the type a -> b
05:20:23 <Philonous> Jafet: 2. undefined and const undefined 
05:20:30 <doofer> and unsafeCoerce
05:20:42 <dobblego> and let f = f
05:20:43 <Jonno_FTW> I have lambdabot running, how do I get it to use mueval?
05:21:19 <Jonno_FTW> it just says: Terminated whenever I run anything
05:21:42 <ramb0> Noob Question: And why can't you instance Ord for functions? Like, I don't know, ordering about the orderness (?)
05:22:02 <dobblego> ramb0, what is "ordering about the orderness"?
05:22:57 <doofer> ramb0: depending on what you want to do, sortBy and similar functions may help
05:23:21 <dobblego> @type comparing
05:23:22 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:23:25 <ramb0> I don't want to do anything, :P
05:23:25 <Jafet> ramb0: what does it mean for a function to be greater than another?
05:25:06 <ramb0> No, I don't know the answer for that, Jafet, but what if I want to define an arbitrary order between functions, like, for example (a -> b -> c) < (a -> b) -> d -> b
05:25:19 <ramb0> -> c is the lastone
05:26:09 <Jafet> Uh, (<) is a -> a -> Bool. Your functions have different types.
05:26:15 <ramb0> is it.. Can I instance a function to allow an order? What instance do functions have?
05:26:20 <ramb0> Oh :(
05:26:58 <Jafet> There's Functor, but dragons lurk there
05:27:16 <ramb0> So, in the best case, I can only derive an instance for functions with the same arity?
05:27:35 <maurer_> ramb0: Not just same arity, same argument types
05:27:38 <Jafet> With the same type.
05:27:44 <Jafet> @type (<)
05:27:45 <lambdabot> forall a. (Ord a) => a -> a -> Bool
05:27:53 <ramb0> Oh
05:27:54 <doofer> you could make a new class Ordah a b where ordah :: a -> b -> Ordering
05:28:07 <doofer> dunno if you could compare functions the way you want though
05:28:24 <maurer_> doofer: You could with that class, it's just a question of if he has a useful comparison metric
05:28:45 <doofer> true
05:29:34 <ramb0> It just more like a theorical question :P
05:31:59 <ramb0> If I want to redefine the Ord for a list, I have to use newtype ?
05:32:54 <sioraiocht> ramb0: I suppose you do, is that bad?
05:33:39 <ramb0> No, I was wondering if there was another way
05:34:07 <Jafet> Why do you want to redefine Ord?
05:35:34 <sioraiocht> ramb0: in my opinion that is the most straightforward way to do it.
05:35:40 <ramb0> Just because I cant. If, for example, i want to redefine an order for integer numbers, I want to know that I can. But I have to do a newtype or something like that 
05:36:18 <sioraiocht> ramb0: Indeed, this is true.  But how else would you want to resolve ambiguities?
05:37:52 <ramb0> Don't missunderstood me, I wanted to know the way that it was done in haskell, Just "Am I wrong if I do it with newtype?"
05:38:42 <sioraiocht> ramb0: Okay =) Often people like to express a preferences for "it should be this way"
05:38:46 <sioraiocht> Which is fine
05:39:03 <sioraiocht> but I don't mind explaining the rationale
05:39:10 <sioraiocht> some poeple are more satisfied with such an explanation =)
05:39:16 <sioraiocht> but yes, newtype, would be the standard way
05:39:38 <sioraiocht> That's how one defines a monoid on Int, for example, as there is no canonical Monoid for integers
05:39:51 <ramb0> I don't know another way to do it though
05:39:56 <ramb0> That's too advanced for me :P
05:40:12 <sioraiocht> there might be compiler extensions that let you do something unsafe
05:40:19 <Jafet> That depends on why you want a different instance. Usually newtype is the only reasonable way
05:40:21 <sioraiocht> but the newtype way is how I would do it almost every time, It hink
05:44:32 <ramb0> Is there a way to "newtype" an existing list having a similar syntax?
05:46:45 <Jafet> No, there is no newsyntax
05:47:20 <Jafet> You can still misappropriate the (:), I guess
05:47:44 <ramb0> newtype Pepe = Pepe [a] isn't valid :(
05:48:45 <DanielDiaz> try "Pepe a = Pepe [a]" ?
05:48:49 <Jafet> That's because a isn't bound anywhere
05:49:48 <Jonno_FTW> when you run your own lambdabot, does it automatically use mueval?
05:51:28 <Jonno_FTW> @elite
05:51:29 <lambdabot> Say again?
05:51:36 <Jonno_FTW> @bf 
05:51:37 <lambdabot>  Done.
05:51:40 <Jonno_FTW> @bf  ####
05:51:40 <lambdabot>  Done.
05:51:49 <Jonno_FTW> @dice
05:51:49 <lambdabot> unexpected end of input: expecting number
05:51:52 <Jonno_FTW> @dice 3
05:51:53 <lambdabot> 3 => 3
05:51:56 <Jonno_FTW> @dice 6
05:51:57 <lambdabot> 6 => 6
05:52:04 <Jonno_FTW> @dice 6 7
05:52:04 <lambdabot> 6 7 => 67
05:52:07 <ppr> @pl \f t a b c -> f $ t a b c
05:52:07 <lambdabot> (.) . (.) . (.)
05:52:19 <ivanm> Jonno_FTW: please use a privmsg if you're just playing
05:52:35 <Jonno_FTW> I was in the wrong channel
05:52:44 <Jonno_FTW> I got it running btw, it just doesn't evaulate stuff
05:53:13 <ppr> will do
05:54:42 <MasseR> Is there a function in the standard libraries that would account for (\x y -> x y)
05:54:45 <ramb0> http://pastebin.com/Efax3sU1 :(
05:55:22 <burp> @pl \x y -> x y
05:55:22 <lambdabot> id
05:55:23 <burp> :P
05:55:34 <MasseR> :D
05:55:39 <DanielDiaz> ¿id?
05:55:58 <DanielDiaz> it seems ($)
05:56:14 <doofer> ramb0: why the sad face?
05:56:21 <byorgey> ($) is just a restricted version of id
05:56:23 <ramb0> Because that doesn't work :(
05:56:46 <byorgey> ramb0: you need to implement either compare or (<=), IIRC
05:56:48 <ramb0> I wanted to redefine an Ord instance for the list data type, but It trows errors
05:57:06 <byorgey> ramb0: what errors?
05:57:06 <doofer> ramb0: minimal complete definition for Ord is (<=) or compare
05:57:15 <DanielDiaz> ramb0: where are you from?
05:57:44 <hpc> your constraint also isn't polymorphic enough, but that won't cause errors
05:57:50 <hpc> your Num a should be Ord a
05:57:58 <ramb0> DanielDiaz, Argentina, why?
05:58:02 <hpc> er, nvm
05:58:07 <hpc> i see why now
05:58:28 <hpc> @src Ord
05:58:28 <lambdabot> class  (Eq a) => Ord a  where
05:58:28 <lambdabot>     compare      :: a -> a -> Ordering
05:58:28 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
05:58:28 <lambdabot>     max, min         :: a -> a -> a
05:58:33 <DanielDiaz> ramb0: speak spanish is more easy for me :)
05:58:35 <ramb0> http://pastebin.com/5xW8LLNw
05:59:18 <byorgey> ramb0: ah, right, you need to make an Eq instance for (Pepe a) too, since Eq is a superclass of Ord
05:59:26 <ramb0> Oh
05:59:28 <byorgey> ramb0: just use the same logic
05:59:41 <byorgey> (Pepe x) == (Pepe y) = sum x == sum y  will work fine
05:59:47 <ramb0> Could I just use deriving eq ?
06:00:02 <byorgey> ramb0: no, that won't give you the same behavior as the Ord instance
06:00:23 <ramb0> I don't want the same behaviour for the Eq and the Ord!
06:00:34 <hpc> why?
06:00:44 <hpc> something could return true for (==) and (>)
06:00:46 <ramb0> No rational reason
06:00:52 <hpc> and that's a huge incorrectness
06:01:26 <byorgey> ramb0: if Eq and Ord have inconsistent behaviors things such as sort are likely to break
06:01:58 <byorgey> if you want to compare lists for equality the normal way, you can just take off the Pepe constructors
06:02:14 <ramb0> Good Idea
06:02:59 <hpc> and for future reference, "no rational reason" == "consider not deviating from the expected behavior"
06:03:49 <ramb0> Im not implementing this in any real world example
06:04:06 <ramb0> Im just playing with haskell and what can you do with ti
06:04:07 <ramb0> it
06:04:18 <ramb0> It keeps throwing errors :(
06:04:46 <ramb0> http://pastebin.com/iqw2QUv3
06:06:08 <DanielDiaz> ramb0: Pepe MUST be an instance of Eq class before be an instance of Ord class
06:06:26 <ramb0> Oh
06:06:27 <ramb0> Ok
06:07:15 <Nibble>  Does anyone in here know of a hack that makes vim highlight haskell functions(variables
06:07:20 <Nibble> I am tired of it just highlighting keywords
06:07:21 <doofer> so, how often are the hackage documentation batch runs run?
06:08:04 <ramb0> Ok thanks all for the help
06:08:11 <ramb0> It works now :D
06:08:13 <ramb0> Bye!
06:08:50 <DanielDiaz> ramb0: bye!
06:13:46 <Nibble> in the paste someone linked before
06:13:47 <Nibble>  newtype Pepe a = Pepe [a]
06:13:55 <Nibble> Is that recursive?
06:14:06 <DanielDiaz> no
06:14:13 <Nibble> Is Pepe the value constructor
06:14:20 <Nibble> or how does it work
06:14:24 <Nibble> I haven't really used newtype
06:14:33 <Nibble> or any data stuff with arguments
06:14:38 <DanielDiaz> Pepe is both the name of the type and the constructor
06:15:25 <Zeiris> Is it possible to import a module, hiding a specific instance definition?
06:17:18 <DanielDiaz> so, actually, elements of type Pepe have the form: Pepe [a], where a is some type.
06:17:49 <DanielDiaz> Pepe [1,2,3] :: Pepe [Integer]
06:18:09 <DanielDiaz> Pepe [True,False] :: Pepe [Bool]
06:18:39 <hpc> wrong
06:18:45 <burp> Pepe Integer, Pepe Bool
06:18:49 <DanielDiaz> YES
06:18:51 <hpc> yeah, that
06:18:54 <DanielDiaz> sorry
06:19:02 <hpc> Pepe :: [a] -> Pepe a
06:19:09 <DanielDiaz> exactly
06:19:11 <hpc> it's easy to get confused
06:19:28 <DanielDiaz> I know the rules, but I'm human ^_^
06:19:42 <burp> Nibble: well, it's not any different for Data
06:19:56 <Nibble> burp: I understand now
06:20:13 <Nibble> burp: do you know how to get vim to highlight custom haskell functions and variables?
06:20:26 <burp> no
06:20:31 <Nibble> :(
06:32:42 <ppr> @pl \f q a b c d -> f $ q a b c d
06:32:42 <lambdabot> (.) . (.) . (.) . (.)
06:33:29 <Axman6> :t (.) . (.) . (.) . (.)
06:33:30 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
06:33:51 <ppr> Does anyone know why lambdabot does respond to /PRIVMSG lambdabot @pl \f q a b c d -> f $ q a b c d
06:34:25 <ppr> does not respond I mean
06:34:41 <mornfall> ppr: It does.
06:35:02 <mornfall> (Although the command is /msg.)
06:35:17 <Axman6> works fine here, with .msg
06:35:23 <Axman6> /msg*
06:35:48 <ppr> .msg @pl \x -> x
06:35:51 <Nibble> Axman6: privmsg is the same thing.
06:35:59 <Axman6> not in irssi
06:36:05 <Axman6> 23:34 -!- Irssi: Unknown command: PRIVMSG
06:36:10 <Nibble> Axman6: in the irc protocol
06:36:21 <Nibble> most clients just use msg instead of PRIVMSG
06:36:30 <Nibble> actually, you message channels with PRIVMSG too
06:36:35 <Zao> irssi makes a distinction between /query and /msg, somehow.
06:36:45 <Zao> Probably mostly wrt to window creation.
06:37:58 <ppr> I'm using http://webchat.freenode.net/
06:40:28 <Axman6> @leet yes
06:40:29 <lambdabot>   Parse error: SemiColon
06:40:32 <Axman6> o.O
06:40:40 <Axman6> @le
06:40:40 <lambdabot> Maybe you meant: learn leave let
06:40:52 <Axman6> @elite yes
06:40:52 <lambdabot> yES
06:41:20 <Nibble> @elite I AM DAS GOT
06:41:20 <lambdabot> i 4M d4z0rz 907
06:41:37 <Nibble> @elite IN DER HIMMEL
06:41:37 <Axman6> @elite yes
06:41:38 <lambdabot> In deR hI/\/\/\/\E1
06:41:38 <lambdabot> Yez
06:41:42 <Axman6> @elite y
06:41:42 <lambdabot> y
06:41:44 <Axman6> @elite y
06:41:44 <lambdabot> y
06:41:47 <Axman6> weak
06:44:15 <ppr> thanks, I figured out why I wasn't seeing the lambdabot private message responses: they went to a different window :)
06:45:01 <Axman6> that's generally what private messages do
06:45:25 <ivanm> heh, I was wondering about that
06:45:58 <Twey> Haha
06:46:09 <ppr> hadn't used irc in years, maybe ten :)
06:46:34 <Nibble> ppr: and still, there are thousands using it
06:46:38 <Nibble> it is amazing really
06:47:09 <DanielDiaz> I used IRC for first time yesterday
06:47:25 <medfly> now you're a pro
06:47:35 <DanielDiaz> medfly: haha, no exactly
06:48:09 <Nibble> DanielDiaz: you highlight people when you write something to them
06:48:10 <Nibble> == pro
07:00:02 <Zeiris> Is there a way to do qualified imports in GHCI? Typing Data.ByteString.Char8 before functions gets old.
07:02:40 <geheimdienst> zeiris, try: import qualified Oompa.Loompa as OL
07:03:06 <Zeiris> In GHCI REPL :(
07:03:13 <Axman6> there's been a ticked to implement it for a very long time. just needs someone to do it
07:03:13 <hpc> yeah
07:03:20 <hpc> ghci does import now
07:03:40 <Axman6> if you're interested enough, you should try implementing it ;)
07:03:48 <yitz> Zeiris: it has been added for the next version of GHCi
07:04:01 <Zeiris> Ah. Looks like I'm just a step behind, then.
07:04:06 <tab> yitz: 6.14 ?
07:04:11 <hpc> hmm, it doesn't do import qualified
07:04:16 <hpc> :(
07:04:30 <Zeiris> 6.14 has no import.
07:04:42 <yitz> Zeiris: in the meantime, use let foo = Long.Name.foo (make sure you have :set -XNoMonomorphismRestriction)
07:04:56 <yitz> Zeiris: :m
07:05:01 <byorgey> Zeiris: as a workaround you could make a module that imports Data.ByteString.Char8 and re-exports it
07:05:07 <yitz> tab: i think so
07:05:18 <byorgey> and give that module a short name
07:06:18 <geheimdienst> yitz, do you mean "added" as in a patch has been applied, or they wrote the number 6.14 on the bug ticket?
07:06:19 <yitz> Zeiris: yes, and use byorgey's trick if you need many functions from the same module.
07:06:44 <yitz> geheimdienst: it is marked "fixed" in GHC trac.
07:06:55 <Zeiris> I'm just writing some haddock docs, and felt like using >>>. It's not a huge deal, I'll just lie.
07:06:57 <geheimdienst> sounds nice
07:07:09 <Zeiris> If anyone ends up trying it in GHCI, they can figure out which namespaces to add...
07:07:33 <yitz> Zeiris: let (>>>) = (Control.Arrow.>>>)
07:07:51 <yitz> or whatever.
07:08:00 <yitz> @hoogle (>>>)
07:08:00 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
07:08:01 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
07:08:11 <Zeiris> Err, the haddock markup >>>, not the arrow one :)
07:08:31 <yitz> there is a haddock markup like that?
07:09:12 <Zeiris> It pretty-prints examples for REPL use.
07:09:25 <sshc> \la
07:26:54 <xplat> Control.Category and COntrol.Arrow make me kind of annoyed in the math sense because they only seem to allow categories with an object for each Haskell type and quite a bit of parametricity, so that's a pretty small subsection of all the categories you could model using Haskell
07:27:38 <xplat> well, subset
07:28:12 <geheimdienst> Control.CategoriesForRealMen
07:28:36 <geheimdienst> Control.OriginalGenuineCategory100%Guaranteed
07:28:53 <geheimdienst> Control.Category.TheRealMcCoy
07:29:31 <hpc> Control.Category.ForRealThisTime
07:30:12 <geheimdienst> Control.Category.OnlyGenuineWithMicrosoftHologramSticker
07:30:43 <xplat> it's not so much that i don't think they're useful, just resent them squatting on the name
07:30:52 <dmwit> I thought category-extras was parametrized on enough stuff to restrict the category somewhat.
07:35:10 <sshc> How do I disable the +RTS options for a program?[4~
07:36:05 <Nibble> sshc: -RTS?
07:36:45 <sshc> Nibble: I want to know how to build a program that doesn't handle the command line specially
07:37:12 <Nibble> sshc: I see
07:37:59 <Zao> Isn't there some fancy flag for that nowadays?
07:38:45 <fasta> sshc, you can also just let another binary run your real binary. 
07:39:05 <fasta> sshc, but I am pretty sure that there is a flag. 
07:39:13 <xplat> dmwit: Category is a typeclass for a two-argument type constructor, it doesn't mention the arguments in the constraint so they cannot be restricted
07:40:25 <dmwit> xplat: surely GADTs or existentials allow you to restrict it somehow
07:41:00 <geheimdienst> nibble, sshc, i don't know what the flag is, but "-RTS" isn't it :
07:41:04 <geheimdienst> :)
07:41:09 <geheimdienst> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html
07:41:25 <geheimdienst> you apparently enclose rts options in +RTS ... -RTS
07:41:59 <xplat> dmwit: GADTs just possibly, in an annoying way, existentials are definitely no use.
07:42:41 <Zao> geheimdienst: I assume he wants the program to completely ignore them, even if they're present.
07:42:52 <sshc> geheimdienst: I'm not asking how to use RTS on the command line
07:43:03 <geheimdienst> zao, yes, i got that
07:43:05 <Zao> The list talks about some -rtsopts to GHC, but I'm unsure if it's in any of 6.12.x or just 6.13
07:43:20 <sshc> Zao is correct
07:43:30 <Zao> Unfortunately the patches are not available anymore from the links in the commit messages, and I'm sure as heck not going to dive into the GHC source.
07:43:39 <Zao> sshc: The simple solution tends to be a wrapper script.
07:43:51 <Zao> Which would filter out the flags and unset GHCRTS.
07:44:22 <xplat> dmwit: by 'an annoying way' i mean you might be able to make a Category that has no arrows from some types to others, but that would probably cause nonobvious errors and it would almost certainly violate the laws.
07:45:17 <dmwit> mmm
07:45:18 <dmwit> yes
07:45:46 <geheimdienst> sshc, "If you absolutely positively want all the rest of the options in a command line to go to the program (and not the RTS), use a --RTS". so i guess you could make a wrapper script that adds --RTS as the first parameter
07:47:02 <JoeyA> Given a lazy list from IO, what's an efficient way to consume it with two consumers, namely one IO action and one pure function?  For instance; do {txt <- readFile "bigFile"; putStr txt; printHex $ hash txt} .  If I'm not mistaken, this will dump the entire file into memory while it's printing it, then hash the memory (rather than printing and computing the hash side-by-side).
07:48:17 <JoeyA> Do I have to torture one of the consumers into operating lazily and passing the lazy list given to the next consumer?
07:48:29 <Zao> JoeyA: If hash is separable into working on chunks, you might be able to interleave them on chunks of input.
07:48:29 <JoeyA> Or is there an easier way?
07:49:11 <xplat> JoeyA: that, or torture them into working on an accumulator instead of recursing internally and do the recursion yourself on the outside
07:50:04 <DanielDiaz> is haddock on hackage now slower?
07:52:01 <JoeyA> you mean, after it got its new look?
07:52:21 <DanielDiaz> yes
07:52:43 <geheimdienst> haddock has a new look?
07:52:51 <Zao> geheimdienst: Yes.
07:53:03 <Zao> geheimdienst: Recently updated packages has it on hackage.
07:53:25 <JoeyA> example:  http://hackage.haskell.org/packages/archive/cryptohash/0.5.2/doc/html/Data-CryptoHash-SHA1.html
07:53:33 <geheimdienst> zao, okay, that's why i haven't seen it yet
07:53:34 <JoeyA> I thought they all did
07:54:00 <JoeyA> The package I linked was updated a few weeks ago (before the new look)
07:54:05 <geheimdienst> woah. that looks really 21st century
07:54:19 <Nibble> Is there any other haskell compiler than ghc?
07:54:30 <Zao> Nibble: jhc, yhc, uhc, hugs
07:54:33 <Zao> Also, quit.
07:57:54 <Saizan> hugs is not a compiler, but you forgot nhc :P
07:58:57 <Zao> Saizan: I've never bothered to use anything but GHC, really.
07:59:35 <Jonno_FTW> > 3 
07:59:35 <lambdabot>   3
08:08:42 <Zeiris> Request for feedback: this CSV/TSV file parser I'm working on is pleasantly low on boilerplate, except for a TypeConstr<$>dec<*>dec<*>dec<*>... pattern that pops up. Is there some way to write that as "apply dec Passwd 7" or something? http://amtal.github.com/tables/Text-Tables.html#4
08:11:18 <shapr> Is there an url shortening service on hackage?
08:16:25 <dmwit> Is every byte a Unicode codepoint?
08:16:36 <dmwit> > '\0'
08:16:37 <lambdabot>   '\NUL'
08:16:41 <dmwit> I suppose so.
08:16:43 <Twey> dmwit: Yes
08:17:25 <Twey> Every number from 0 to 0x10FFFF is a valid Unicode codepoint, which includes the range [0 .. 0xFF] representable as an unsigned byte.  Is that what you were asking?
08:18:58 <xplat> Twey: ones ending in FFFE or FFFF are not, nor are the surrogate ranges, but of course that makes no difference for bytes
08:19:13 <dmwit> Yes, thanks.
08:21:37 <xplat> Zeiris: you can if you use a type-level number, but not a value-level number like 7
08:22:01 <xplat> to do that you would need dependent types
08:22:17 <Zeiris> Would it be worth the effort?
08:22:25 <Twey> xplat: Ah, really?
08:22:43 <Twey> > '\uFFFE'
08:22:43 <lambdabot>   <no location info>:
08:22:44 <lambdabot>      lexical error in string/character literal at chara...
08:23:00 <geheimdienst> > '\uFFFD'
08:23:00 <lambdabot>   <no location info>:
08:23:01 <lambdabot>      lexical error in string/character literal at chara...
08:23:34 <dafis> > '\xFFFE'
08:23:34 <lambdabot>   '\65534'
08:23:38 <Twey> Oh, that's the one
08:23:40 <xplat> Twey: some implementations allow them, but the official unicode standard states that they are invalid codepoints, not merely undefined or anything
08:23:52 <Twey> Huh
08:23:53 <Saizan> Zeiris: the number of arguments could also be inferred from the type of Passwd
08:23:54 <Twey> Why?
08:23:55 <xplat> Zeiris: depends how much it comes up
08:24:04 <geheimdienst> i seem to recall FFFE is used as a big-endian/little-endian mark. if it shows as FEFF, you know it's the wrong endianness
08:24:15 <Twey> Oh, right, yes
08:24:17 <geheimdienst> xplat, link to reference?
08:24:18 <Twey> The BOM
08:24:22 <xplat> geheimdienst: FEFF is when it's right
08:24:43 <Twey> But isn't that an encoding detail?
08:31:14 * hackagebot derive-IG 0.1 - Macro to derive instances for Instant-Generics using Template Haskell  http://hackage.haskell.org/package/derive-IG-0.1 (HiromiIshii)
08:32:58 <xplat> geheimdienst: http://www.unicode.org/versions/Unicode5.2.0/ch02.pdf  pp23-24
08:33:38 <geheimdienst> thanks man
08:33:51 <xplat> it's a little more complicated than what i said, but see the paragraphs labelled 'Noncharacters', 'Surrogates', and 'Restricted Interchange'
08:33:53 <geheimdienst> i'm just reading section 16.7 "Noncharacters" http://www.unicode.org/versions/Unicode5.2.0/ch16.pdf
08:34:07 <geheimdienst> that's damn interesting. i'd never have guessed
08:35:19 <Eduard_Munteanu> o/
08:38:05 <xplat> and i even forgot about FDD0-FDEF which are also noncharacters
08:38:44 <xplat> just goes to show how dangerous it is to talk about unicode off the top of one's head, i guess
08:39:08 <monochrom> generally dangerous for all topics
08:39:48 <geheimdienst> except on haskell-blah
08:45:20 <mjd> I have an "instance Functor Seq where ... {{3 clauses}}" and two of the clauses use a nonce function 'pmap'.  How can I make a local definition for 'pmap' that is only in scope for the instance declaration?
08:45:47 <Twey> mjd: You can't, but don't be afraid to use module scope and then just not export
08:45:58 <mjd> Okay, thanks.
08:46:06 <Twey> (better for GHCi debugging, too)
08:47:20 <BrianHV> does sequence do anything interesting given a list of non-IO monads?
08:47:47 <Twey> BrianHV: Yes
08:48:13 * geheimdienst points out that the unicode documentation is damn good. very readable, no gibberish at all. and you quickly find what you wanted. this thing was done by someone who's a very good writer.
08:48:27 <BrianHV> meh.  the more I think I understand monads, the less I actually understand monads. ;)
08:48:46 <mjd> Bah, all my weird and inexplicable errors have evaporated now that I am in channel.
08:48:51 <geheimdienst> also, documentation exists. this is more than can be said for many large OSS projects. *and* it's all online (i'm looking at you, IEEE)
08:49:04 <mjd> Or perhaps it's because I am not now 10 hours deficit on sleep.
08:49:33 <monochrom> > sequence [[0,1], ['a','b']]
08:49:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:49:34 <lambdabot>    arising from the literal `0...
08:49:40 <monochrom> oh oops
08:49:47 <monochrom> > sequence [[0,1], [100,110]]
08:49:48 <lambdabot>   [[0,100],[0,110],[1,100],[1,110]]
08:50:06 <hewei> Hi there, I've built an program that uses GHC(without enable-shared) and hxt library. But hxt depends on curl, which further requires libcurl.so.4. The thing is that libcurl.so.4 is not at standard location, so I used extra-lib-dirs to build it. Now, my program can build alright, but gives "error while loading shared library" for libcurl.so.4 at runtime. Could you shed some light on the cause of the problem and how I can fix it please? Thanks! 
08:50:24 <BrianHV> > [0,1] >>= [100,110]
08:50:24 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
08:50:30 <BrianHV> right
08:50:55 <geheimdienst> > fmap [0,1] >>= [6,7]
08:50:56 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
08:51:09 <geheimdienst> > [0,1] >>= fmap [6,7]
08:51:10 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
08:51:23 <dmwit> hewei: Perhaps #ghc would be a better place for that question.
08:51:26 <megajosh2> Mapping a list predicate to a list? :O
08:51:35 <megajosh2> Wait no I'm thinking of filter
08:51:37 * geheimdienst fails with his technique of randomly inserting fmap to fix monad issues
08:51:44 <dmwit> hewei: You'll want to ask and then wait a while, too; it's a little less active than #haskell.
08:52:02 <hewei> dmwit: Thank you for the info!
08:52:12 <Igloo> hewei: That sounds like a system problem, not a Haskell problem
08:52:18 <Igloo> hewei: A C program would have the same problem
08:52:36 <dmwit> > [0, 1] >> [6, 7]
08:52:37 <lambdabot>   [6,7,6,7]
08:52:49 <dmwit> > [0, 1] >>= const [6, 7]
08:52:49 <monochrom> LD_LIBRARY_PATH=where is your libcurl.so.4
08:52:50 <lambdabot>   [6,7,6,7]
08:54:10 <mjd> Oh, I know what I wanted to ask.  Is there some sort of environment of config file setting I can make so that ghci will always use -i $HOME/lib/haskell ?
08:54:52 <geheimdienst> hewei, maybe you can do a workaround by running: "LD_LIBRARY_PATH=/location/of/libcurl   your-program --arguments"
08:55:01 <Saizan> Zeiris: i've done it for the Binary class/Get monad, it seems to work quite well :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29764#a29764
08:55:03 <geheimdienst> see also http://linux.die.net/man/8/ld.so
08:55:09 <xplat> [0,1] >>= map (,) [6,7]
08:55:16 <xplat> > [0,1] >>= map (,) [6,7]
08:55:17 <lambdabot>   Couldn't match expected type `t -> [b]'
08:55:17 <lambdabot>         against inferred type `[b1 ...
08:55:27 <xplat> > [0,1] >>= $ map (,) [6,7]
08:55:28 <lambdabot>   <no location info>: parse error on input `$'
08:55:46 <xplat> oh, hm
08:55:53 <geheimdienst> > map (,) [6,7]
08:55:54 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (a, b))
08:55:54 <lambdabot>    arising from a use...
08:55:59 <mjd> I have never been clear on why Tuesday was "Dienstag".
08:56:37 <Twey> mjd: That's okay
08:56:41 <Twey> mjd: Neither is anyone else
08:56:42 <monochrom> mjd: echo ':set -i/home/monochrom/lib/haskell' > .ghci
08:56:49 <mjd> Aha!  thanks.
08:56:53 <monochrom> unfortunately you can't have $HOME there.
08:56:58 <mjd> That's okay.
08:57:21 <monochrom> another option is to cabalize everything in lib/haskell
08:57:26 <dmwit> > map (\x -> sin (x * pi / 8)) [0..15]
08:57:26 <lambdabot>   [0.0,0.3826834323650898,0.7071067811865475,0.9238795325112867,1.0,0.9238795...
08:57:34 * BrianHV gets another haskell program working.  which is still a big achievement for him these days, unfortunately...
08:57:45 <dmwit> > map (\x -> 16 + 8 * sin (x * pi / 8)) [0..15]
08:57:46 <lambdabot>   [16.0,19.061467458920717,21.65685424949238,23.391036260090296,24.0,23.39103...
08:57:53 <dmwit> > map (\x -> floor $ 16 + 8 * sin (x * pi / 8)) [0..15]
08:57:54 <lambdabot>   [16,19,21,23,24,23,21,19,16,12,10,8,8,8,10,12]
08:58:15 <dmwit> > map (\x -> floor $ 8 + 4 * sin (x * pi / 8)) [0..15]
08:58:15 <lambdabot>   [8,9,10,11,12,11,10,9,8,6,5,4,4,4,5,6]
08:58:38 <mjd> I was inspired this month by Swierstra and Duponcheel's paper about "Deterministic, Error-Correcting Combinator Parsers".  I have a fantasy that I will win fame and renown by porting it to Perl.
08:58:55 <dmwit> > map (\x -> round $ 8 + 4 * sin (x * pi / 8)) [0..15]
08:58:56 <lambdabot>   [8,10,11,12,12,12,11,10,8,6,5,4,4,4,5,6]
08:58:59 <dmwit> mjd: A very cool paper!
08:59:51 <mjd> dmwit: Perl has suffered for years from slow, clunky recursive-descent parser generators that everyone uses anyway.  This could fix them.
09:00:12 <mjd> The clever use of type classes  could be replaced by slightly-less-clever use of OOP.
09:00:22 <mjd> technology transfer!
09:00:32 <dmwit> =)
09:01:00 <mjd> Oh, you're Daniel Wagner.   I think we know each other.  Hi!
09:01:16 <dmwit> Hi!
09:01:24 <dmwit> You're Mark, yeah?
09:01:26 <mjd> Yes.
09:01:35 * geheimdienst wires perl interpreters all over the world to connect to irc and use lambdabot for parsing
09:02:10 <xplat> it's too bad nobody ever did a version of Inline::Haskell for perl5
09:02:42 <xplat> the Inline::Java is pretty good if you want to try implementing it in scala :)
09:02:54 <Jafet> That sounds like the wrong way round to do things
09:05:30 <medfly> that is a pretty strange conversation. how can you guys identify each other like that?
09:05:43 <Twey> /whois?  :þ
09:05:46 <medfly> oh, right
09:05:51 <medfly> just noticed they have their real names there
09:05:54 * Twey chuckles.
09:06:01 <medfly> shame on you! the internet is for anonymity and furry porn
09:06:17 * Twey will do that once he has one
09:06:28 <medfly> one real name?
09:06:34 <Twey> Mmhm
09:06:52 <dmwit> Are you kidding? How am I going to get famous if I hide my name!!
09:07:08 <Twey> Heh.
09:07:13 <mjd> Had he been projecting anonymity, I would not have known who he was and would not have been able to identify him.
09:07:26 <geheimdienst> plenty of people got famous under a pseudonym
09:07:30 <dmwit> dmwit.com probably would have tipped you off.
09:07:34 <Twey> It's true
09:07:35 <medfly> well, maybe if you had a second online identity, there wouldn't be any need for using your real name!
09:07:41 <medfly> :p
09:09:41 <xplat> yeah, eventually you wouldn't even need to use it in real life!
09:10:24 * hackagebot derive-IG 0.1.1 - Macro to derive instances for Instant-Generics using Template Haskell  http://hackage.haskell.org/package/derive-IG-0.1.1 (HiromiIshii)
09:11:06 <xplat> http://www.telegram.com/article/20100822/COLUMN01/8220416/0/flash06
09:12:46 <geheimdienst> from tfa: "He makes a six-figure salary doing something very complicated that involves computers."
09:12:54 <geheimdienst> now which part of that sentence is redundant?
09:14:13 <Twey> geheimdienst: Feminists would say ‘he’ :þ
09:14:18 <monochrom> after optimization: "he involves computers"
09:14:24 <Twey> Haha
09:14:52 <yitz> yeah, think about it - haskell curry became famous using the name of a programming language as a pseudonym.
09:14:59 <BONUS> i make a six figure salary as well, too bad they're binary
09:15:40 <Twey> Haha.
09:15:52 <geheimdienst> i guess "something very complicated" means the guy is not good at explaining, or is purposefully being pompous
09:16:00 <yitz> BONUS: don't worry, the book is coming out soon...
09:16:08 <BONUS> indeed
09:16:41 <monochrom> the book will sell a six figure number of copies
09:16:44 <BONUS> i just have to manage not to spend all of the money from it on sour candy and sunglasses
09:16:51 <yitz> monochrom: in base?
09:17:03 <BONUS> 16 i hope
09:17:09 <yitz> at least!
09:18:34 <kdvh> i hope it comes with those nifty drawings that were absent in the .pdf version, those are worth paying for :D
09:20:15 <BONUS> kdvh: yeah, drawings will be in of course
09:20:24 <BONUS> although some people might be disappointed that they won't be in color
09:20:29 <yitz> the drawings are great, they add so much fun to the book. i can't believe BONUS would publish it without them
09:20:46 <luite> BONUS: will there be a pdf version of the book, with pretty colors?
09:20:50 <BONUS> printing 350-400 pages in color would make it cost A LOT
09:20:53 <BONUS> luite: that there will
09:20:56 <luite> cool
09:21:46 <yitz> BONUS: put out a special limited edition in color for a higher cost. sign each copy maybe. :)
09:22:01 <BONUS> with my blooood
09:22:02 <yitz> glossy, you know
09:22:17 <yitz> the kind you'd put on your coffee table
09:22:18 <medfly> BONUS, maybe you can only print the ones with the drawings in colour? :-/
09:22:48 <kdvh> it'd still cost a lot for printing
09:23:00 <BONUS> medfly: i don't think print works like that. and pretty much every other page has a drawing i think
09:23:28 <xplat> medfly: you'd still have to print ones on opposite leaves in color as well and there'd be extra cost for collation, hard to even guess if it's a win in the end
09:23:52 <geheimdienst> art prints? "i'd like the elephant from the front page 70x50 cm and framed to hang on the wall"
09:24:07 <xplat> and with every other page with a drawing, definitely not a win
09:24:50 <medfly> ;s
09:24:57 <yitz> BONUS: ask the publisher if you can sell fancy color ones done one by one on order at kinkos.
09:25:20 <BONUS> hmmm yeah, i'll ask about having a fancy color edition or something
09:27:58 <medfly> oh well
09:57:47 <ManateeLazyCat> siracusa: Are you there?
10:00:22 <ManateeLazyCat> @tell siracusa I'm working on review old gtk+-2.18 patches and update to gtk+-2.20 APIs in gtk2hs, if interesting, welcome to join! Feel free to ask any question about binding gtk2hs, i will do my best. :) 
10:00:22 <lambdabot> Consider it noted.
10:01:55 <ManateeLazyCat> If any haskeller interested new APIs in gtk2hs, welcome to join! My mail is : lazycat.manatee@gmail.com.
10:02:14 <ManateeLazyCat> Binding is pretty easy, i even have some elisp extension do most convert work.
10:03:07 <dcoutts__> ManateeLazyCat: perhaps you can recruit a volunteer to work on OSX packaging
10:03:27 <dcoutts__> making gtk2hs work with the gtk-osx stuff, the native/quartz gtk backend
10:03:30 <ManateeLazyCat> dcoutts__: I haven't OSX
10:03:40 <ManateeLazyCat> dcoutts__: I just have Linux.
10:03:42 <dcoutts__> ManateeLazyCat: I know, but perhaps you can recruit a volunteer
10:04:18 <ManateeLazyCat> dcoutts__: I know leksah's author have Mac.
10:04:26 <dcoutts__> ManateeLazyCat: it would really help the acceptance of gtk2hs as a standard gui lib if it worked ok on OSX
10:04:57 <ManateeLazyCat> dcoutts__: Yep, if i have Mac, i can do it.
10:05:10 <ManateeLazyCat> dcoutts__: But i'm not sure other people will do that.
10:05:40 <ManateeLazyCat> dcoutts__: Most haskellers even don't like GUI program, IMO....
10:05:43 <dcoutts__> ManateeLazyCat: with support, advice and encouragement, I think people would
10:06:24 <ManateeLazyCat> dcoutts__: I'm create new post in gtk2hs list, i hope will more people join gtk2hs team.
10:06:58 <dcoutts__> ManateeLazyCat: see http://www.reddit.com/r/haskell/comments/d9wm2/is_it_time_for_a_strike_team_to_form_dedicated_to/
10:07:37 <jutaro> dcoutts__: We had a problem here today, with an Umlaut in a cabal file and ghc-pkg. I searched if it is in a bug tracker but didn't find. You know about it, and if it was fixed? 
10:08:44 <dcoutts__> jutaro: as far as I know it works fine, both cabal and ghc-pkg use utf8 exclusively
10:08:56 <dcoutts__> jutaro: perhaps you were using latin1 for the .cabal file?
10:09:03 <dcoutts__> jutaro: rather than utf8
10:09:11 <jutaro> it doesn't work. I had to change Jürgen to something else. 
10:09:27 <jutaro> It is ghc-pkg which doesn't work.
10:09:41 <tommd> Where is the file?
10:09:50 <ManateeLazyCat> dcoutts__: I hope i can find some time build "fully automatic tool" after update gtk2hs, it's painful with current tool.
10:09:51 <tommd> The broken one
10:10:16 <dcoutts__> jutaro: we'd need more info, there are plenty of packages on hackage that do use 'ü' and other similar chars
10:10:34 <dcoutts__> jutaro: what ghc-pkg version?
10:10:46 <dcoutts__> what locale
10:10:54 <dcoutts__> and cabal version
10:12:25 <jutaro> dcoutts__: I look for an example 
10:13:05 <dcoutts__> jutaro: thanks, I realise it's vital that tools let people spell their names correctly! that's why we tried to sort it all out to use UTF8 about a year ago.
10:14:12 <dcoutts__> jutaro: I believe that there was one version of ghc where there was some problem because cabal was using utf8 but ghc-pkg was using the locale encoding, which is not always utf8
10:14:30 <dcoutts__> jutaro: I'd have to check which version that was, certainly it is fixed now though
10:14:36 <dcoutts__> in the latest releases
10:15:16 <jutaro> dcoutts__: the problem today was with the unlambda package. But I just installed it, and have no problems. (6.12.3) So maybe it is fixed.
10:15:31 <ManateeLazyCat> @tell juhp I will spend one week update gtk2hs APIs, perhaps i won't add new module in manatee this week. If you interested, welcome to join gtk2hs team. All gio patches has push to repo, i need more test before gio-0.12.0. 
10:15:32 <lambdabot> Consider it noted.
10:15:43 <dcoutts__> jutaro: I think the problem was in 6.12.1
10:16:21 <jutaro> Ok, I somehow had the opinion it was fixed, but was not shure.
10:16:33 <dcoutts__> jutaro: so does ghc-pkg describe show the text correctly?
10:17:07 <jutaro> dcoutts__: Yes
10:17:11 <dcoutts__> ok great
10:17:29 <jutaro> dcoutts__: ok, bye for now
10:17:36 <dcoutts__> bye
10:18:08 <djahandarie> dcoutts__, you get my message yesterday?
10:18:23 <dcoutts__> djahandarie: no, sorry
10:18:30 <dcoutts__> about hackage or something?
10:18:32 <djahandarie> Nope
10:18:45 <djahandarie> dcoutts__, spelling error in your blog post... "peograms" -> "programs" :P
10:18:51 <dcoutts__> oh :-)
10:18:57 <dcoutts__> ta
10:24:27 <JoeyA> I want to schedule an action (namely, update a progress bar) to happen in 250 milliseconds, but cancel the scheduled action if something else happens before the 250 ms elapses.  In C, I would probably use pthreads.  I suppose I should look into Control.Concurrent.Thread ?
10:25:21 <dankna> forkIO will do it fine
10:25:23 <dankna> so yes
10:25:27 <Jafet> You may also look into Control.Exception
10:27:46 <vanadium> m <- newEmptyMVar; forkIO (threadDelay 250000; b <- isEmptyMVar w; when b updateProgressBar) ... possibly putMVar m () ...?
10:29:12 <chrisdone> I come in peace
10:29:55 <JoeyA> cool
10:30:39 <JoeyA> I suppose it'd be better to make the progress bar operate in a separate thread during its entire lifespan rather than forking every update?
10:30:50 <vanadium> forking is cheap, so do what is easier
10:31:16 <vanadium> You could make it a single thread that always blocks on a Chan or MVar and the main thread can push dummy values in there to tell it to update
10:31:17 <dankna> forkIO is supposed to be pretty cheap, actually, since it's not a "real" fork
10:31:26 <HugoDaniel> chrisdone: :D pieceeee
10:31:27 <Jafet> The ghc runtime uses user threads.
10:31:29 <pumpkin> TacticalGrace: you around?
10:31:46 * chrisdone gives HugoDaniel the vulcan greeting
10:31:51 <HugoDaniel> yeeehhhhhhh
10:31:53 <HugoDaniel> :D
10:31:54 <JoeyA> Well, I expect the progress bar update to be called a lot, since the caller might update a bunch of times with really small changes.
10:31:58 <HugoDaniel> how is itally ?
10:32:43 <JoeyA> Perhaps I could simply snub requests to update from 53.3 to 53.4 percent when they happen close to each other.
10:32:44 <chrisdone> HugoDaniel: good. I miss some english food but the work is great and I'm getting exercise here. how's portugal?
10:33:08 <JoeyA> Though that begs the question of whether getCurrentTime is faster than forkIO
10:33:11 <HugoDaniel> portugal is the same, im fed up with my job, but ehh i guess thats life :P
10:33:15 <JoeyA> (or passing data through an MVar)
10:33:26 <chrisdone> HugoDaniel: why don't you come and work here
10:33:36 <ManateeLazyCat> vanadium: updateProgressBar ? gtk2hs code?
10:33:41 <HugoDaniel> are there any job offers
10:33:51 <vanadium> ManateeLazyCat: It was meant to be the placeholder for whatever JoeyA wants to do
10:33:55 <HugoDaniel> ... :/
10:33:56 <chrisdone> HugoDaniel: yeah. we're after a web developer who speaks haskell
10:34:01 <HugoDaniel> !
10:34:07 <vanadium> if it is gtk2hs code I hope gtk2hs works better with threads than it used to
10:34:22 <chrisdone> HugoDaniel: parlo italiano?
10:34:23 <JoeyA> Eventually, when I get it all good and fancy, I plan to release a command-line progress bar API.
10:34:26 <ManateeLazyCat> vanadium: gtk2hs can support multi-thread
10:34:44 <ManateeLazyCat> vanadium: Need '-threaded' falg, don't need threadDelay
10:34:52 <JoeyA> (with optional percentage and/or status messages)
10:34:56 <HugoDaniel> chrisdone: um pouco
10:35:00 <chrisdone> HugoDaniel: lol
10:35:13 <ManateeLazyCat> vanadium: That's why i ask you whether write gtk2hs code, threadDelay is perfect way to write gtk2hs multi-thread code.
10:35:17 <HugoDaniel> :D
10:35:53 <dcoutts__> vanadium, ManateeLazyCat: you've got to be very careful with -threaded and gtk2hs
10:36:03 * ManateeLazyCat pasted "gtk concurrent library" at http://paste2.org/get/978025
10:36:09 <chrisdone> HugoDaniel: you do web dev. right? do you know javascript/css?
10:36:11 <dcoutts__> it's possible but it's also easy to do wrong
10:36:13 <ManateeLazyCat> vanadium: ^^^ is my gtk concurrent library.
10:36:14 <freedrull> are type constructors for functions *really* instances of arrows?
10:36:18 <HugoDaniel> yes, yes :)
10:36:28 <HugoDaniel> i dont particularly enjoy javascript, but we get along
10:36:36 <dcoutts__> vanadium, ManateeLazyCat: I use forkIO threads with gtk2hs but not linking in the -threaded rts
10:36:57 <ski> freedrull : `Arrow (->)', yes
10:37:04 <chrisdone> HugoDaniel: true, appreciating javascript requires a certain kind of brain damage. would you move to italy?
10:37:13 <Twey> Hahaha
10:37:26 <HugoDaniel> chrisdone: right now ?!
10:37:27 <dankna> hahaha
10:37:42 <chrisdone> HugoDaniel: sure
10:38:13 <HugoDaniel> i can't, i have to stay here for another month after i quit this
10:38:40 <HugoDaniel> but that would be neat :)
10:38:46 <HugoDaniel> let me think about that
10:38:55 <chrisdone> :-)
10:39:37 <chrisdone> HugoDaniel: well we'll post on haskell-cafe at some point so if you're up for it then give us a buzz :-)
10:39:45 <HugoDaniel> olraite :D
10:39:58 <HugoDaniel> ill send a CV then
10:40:14 <Twey> chrisdone: ‘We’?  You're not in Italy, are you?
10:40:16 <chrisdone> > sort "excellent"
10:40:17 <lambdabot>   "ceeellntx"
10:40:22 <chrisdone> Twey: yeah
10:40:33 <Twey> Oh.  Whom're you working for?  (IIMA)
10:40:43 <chrisdone> CREATE-NET
10:41:01 <chrisdone> I'm not shouting. it's one of those lame acronym names
10:41:07 <Twey> That's interesting
10:41:17 <Twey> Their site is almost entirely upper-case
10:41:42 <Twey> Okay, that's hyperbole, but it has a significantly larger proportion of upper-case text than I expect :þ
10:41:44 <chrisdone> the site's horrid, I'm hopeful it's going to be re-done
10:42:14 <chrisdone> that's what you get when you leave web development to academics :p
10:42:33 <Twey> Heh
10:42:38 <ManateeLazyCat> chrisdone: Do you want join gtk2hs ?
10:42:43 <Twey> So *that's* what happened to the Haskell wiki
10:42:49 <chrisdone> ManateeLazyCat: join?
10:42:57 <chrisdone> Twey: hahaha
10:43:02 <ManateeLazyCat> chrisdone: Yes, help us udpate APIs in gtk2hs.
10:43:47 <chrisdone> not really, I've never done any gtk development. maybe a tiny bit in C but generally I don't care about that library. if I ever need it for something I'll contribute, sure
10:43:56 <ManateeLazyCat> chrisdone: Just Axel and me working on new APIs, if more people help us, we can release next version quicker.
10:45:08 <Olathe> Is there an easy way to derive Integral for newtype A = A Integer ?
10:45:12 <ManateeLazyCat> chrisdone: I have gtk2hs.el that convert gtk+ documentation from w3m page to haddock style. And most gtk+ code are simple enough, you just need copy code from other module.
10:45:33 <chrisdone> ManateeLazyCat: I'm not saying it's hard to figure out, I'm saying I don't have interest in that library
10:45:41 <ManateeLazyCat> chrisdone: Ok. :)
10:45:55 <chrisdone> ManateeLazyCat: unless someone's making a music player in Haskell?
10:45:57 <ManateeLazyCat> chrisdone: Just try find new gtk2hs developer.
10:46:10 <ManateeLazyCat> chrisdone: yes, i have make a mplayer client.
10:46:29 <ManateeLazyCat> chrisdone: http://www.flickr.com/photos/48809572@N02/4916078721/
10:46:36 <chrisdone> then I might hack on it. /me adds a TODO to write a Last.fm library
10:47:13 <ManateeLazyCat> chrisdone: Simple, just fetch last.fm link and pass to mplayer process.
10:47:15 <chrisdone> talking to mplayer makes sense
10:47:44 <ManateeLazyCat> chrisdone: I use MVC design like mpd, but with haskell lightweight thread with daemon mplayer process.
10:47:52 <chrisdone> sure
10:47:58 <ManateeLazyCat> chrisdone: You can listen music even don't need open player buffer.
10:48:31 <ManateeLazyCat> chrisdone: I guess you has know my project.
10:48:42 <benmachine> has anyone released a bytestring API for reading directories?
10:48:51 <ManateeLazyCat> chrisdone: I will release first version after i release gio-0.12.0 and gtk-0.12.0
10:49:03 <chrisdone> ManateeLazyCat: cool
10:49:07 <benmachine> Olathe: look up GeneralizedNewtypeDeriving
10:49:22 <ManateeLazyCat> benmachine: bytestring API for reading directories.
10:49:59 <benmachine> ManateeLazyCat: :O
10:50:30 <ManateeLazyCat> chrisdone: Code at https://patch-tag.com/r/AndyStewart you can build it with darcs gtk2hs.
10:50:35 <Olathe> benmachine: Thanks :)
10:50:54 <ManateeLazyCat> benmachine: I just don't understand your problem, what's your real want to resolve?
10:51:20 * sbahra is really confused by this discussion
10:51:22 <benmachine> ManateeLazyCat: oh, I just want to read directories, ideally without using lazy IO, and ideally quite quickly
10:53:06 <ManateeLazyCat> benmachine: Do you mind use C library? There has gio APIs in gtk2hs (darcs), gio is cross-platform APIs to read file/directory information.
10:53:43 <ManateeLazyCat> benmachine: Not just file directory, and include volume, drive, icon many other APIs...... 
10:54:00 <ManateeLazyCat> benmachine: And those APIs can run on Windows or UNIX.
10:54:03 <benmachine> ManateeLazyCat: well, I'm only doing a simple thing, and I want to do it today :P
10:54:25 <benmachine> I just want to write a script, and I remembered all that discussion about du, and wondered if anyone had released anything out of that
10:54:34 <ManateeLazyCat> benmachine: http://www.flickr.com/photos/48809572@N02/4793031888/ my file-manager that use gio APIs.
10:55:40 <monochrom> http://hackage.haskell.org/package/directory-tree
10:56:06 <benmachine> monochrom: that looks interesting
10:56:14 <benmachine> ManateeLazyCat: that too
10:56:23 <monochrom> it was conceived for the du discussion
11:08:37 <SML> hi
11:09:02 <SML> I am the SML, how hard it is to convert myself to haskell?
11:09:29 <dankna> nontrivial
11:09:56 <SML> it's all about the functional paradigm
11:10:07 <SML> why nottrivial?
11:10:52 <dankna> well, I don't actually know SML, you understand, except by reputation.  but the languages have different concepts in them.  yes they're both functional...
11:10:57 <notabel> you'll have to unlearn a lot about modules, and learn a lot about type classes and type-system extensions (which are much more prevalent in Haskell than SML)
11:12:05 <notabel> whereas the module system plays a central role in SML, it is less important (and weaker) in Haskell, because type classes substitute for its functionality
11:12:13 <kmc> kind of
11:12:18 <kmc> lazy evaluation is a big difference
11:12:22 <notabel> laziness and type classes are really the differences, in my opinion
11:12:23 <notabel> yes
11:12:44 <kmc> learning to use it to write things that would be impossible in SML; and learning how to deal with performance problems from laziness
11:13:11 * notabel came to haskell from ocaml, only really knows SML by distinction from ocaml
11:14:40 <companion_cube> notabel: uh, purity is also a big change
11:15:16 <notabel> companion_cube: yes, but only if you were habitually impure in ml.  i wasn't
11:15:34 <Eduard_Munteanu> Isn't the temptation just too great?
11:15:55 <benmachine> nooope
11:15:59 <notabel> not much worse than the temptation to unsafePerformIO
11:15:59 <kmc> in Haskell you can't perform effects as part of function evaluation; you have to build effect-descriptions and return them to the runtime system
11:16:04 <benmachine> I write pure python when I think I can get away with it >_>
11:16:19 <companion_cube> notabel: it can surprise, for example when you were accustomed to use hash tables or vectors
11:17:45 <Martty> :t unsafePerformIO
11:17:46 <lambdabot> Not in scope: `unsafePerformIO'
11:18:33 <notabel> Martty: lambdabot uses a carefully-restricted evaluator to keep itself secure
11:18:47 <Martty> thus, lambdabot is a faggot
11:18:55 <Martty> note: careful choice of words
11:18:59 <medfly> lambdabot is a lesbian if anything
11:19:01 <notabel> unsafePerformIO :: IO a -> a
11:19:24 <notabel> hey now, no need for that choice of words.  there's the signature you wanted
11:20:08 <Eduard_Munteanu> @vixen Are you lesbian?
11:20:09 <lambdabot> good question
11:20:18 <chrisdone> ಠ_ಠ
11:21:59 <Jafet> Imagine if robots were sexual -- the number of possible orientations would be doubled. Main streets of liberal American cities would be booked end-to-end
11:22:39 <Jafet> @vixen are you pure?
11:22:39 <lambdabot> yes, i am
11:23:24 <winxordie> I don't know how many genders robots would have.
11:24:21 <DanielDiaz> This is awesomely off-topic (still funny)
11:24:41 <companion_cube> winxordie: well, depends on how many bits it is encoded
11:24:47 <chrisdone> thus when implementing robots make orientation a class which the consciousness can implement
11:25:14 <winxordie> companion_cube: touche.
11:29:47 <JoeyA> Is it common practice to make IO callbacks have type 'IO a' and ignore instead of IO () ? (so the caller doesn't have to >> return () so it'll type check)
11:29:58 <Twey> JoeyA: Yes
11:30:01 <Twey> Please do this
11:30:05 <JoeyA> thanks
11:30:31 <Twey> Things that require () despite ignoring the return type should be considered buggy.
11:30:50 <chrisdone> just because of the inconvenience?
11:31:08 <Twey> Because there's no reason to do it
11:31:16 <Twey> And yes, it's horrible
11:31:34 <roconnor> Twey: you lost me
11:32:03 <Jafet> Doesn't IO () already mean "we'll ignore the return value"?
11:32:17 <Twey> roconnor: Some functions take an IO-performing callback and ignore its return type
11:32:33 <Twey> But even though they don't care what the value is, they require in the type that the callback be ‘IO ()’
11:32:52 <JoeyA> :t catch
11:32:53 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:32:56 <Twey> Which means that if you want to use a callback that also returns a value, you need to write someFunc (callback >> return ())
11:33:00 <Zao> Jafet: We return a value of type (), which is either () or bottom.
11:33:07 <JoeyA> oh wait, return value isn't ignored there
11:33:09 <Twey> WHich is horrible
11:33:18 <chrisdone> it's also a way to avoid accidentally putting the wrong expression
11:33:37 <kmc> Twey, GHC introduced a warning for unused non-() values in do-blocks
11:33:45 <Twey> I know
11:33:48 <Twey> And I hate it
11:33:50 <kmc> if you think that warning is legit, you should require your callbacks to be IO ()
11:34:01 <roconnor> Twey: Ironic
11:34:09 <Twey> How so?
11:34:18 <kmc> i like the warning
11:34:30 <roconnor> Twey: the GHC warning is trying to introduce the opposite behaviour I think
11:34:38 <kmc> istr void :: (Functor m) ⇒ m a → m ()
11:34:43 <JoeyA> hmm, I'm not sure IO a to ignore the type will work so well in this case:
11:34:47 <kmc> but don't know where it's defined
11:34:50 <roconnor> Twey: however there may be a  covarient/contravarient thing going on here with callbacks
11:34:58 <JoeyA> data ScanHandler = ScanHandler (FilePath -> IO a)
11:35:20 <chrisdone> good point
11:35:23 <JoeyA> I'd need existential quantification (or even rank 2 types?) just for the convenience here.
11:35:26 <chrisdone> over to you, Twey
11:35:51 <kmc> that seems like a gratuitous use of existentials :)
11:36:04 <kmc> «∃a. IO a» should be equivalent to «IO ()»
11:36:07 <pumpkin> TacticalGrace: I have a cute idea for objc in haskell
11:36:21 <pumpkin> @tell TacticalGrace I have a cute idea for objc in haskell
11:36:21 <lambdabot> Consider it noted.
11:36:41 <chrisdone> JoeyA: technically you could construct it as: ScanHandler (f >> return ())
11:36:48 <chrisdone> and have no problem
11:36:58 <kmc> or «void f»
11:36:59 <diefrage> I'm trying to search for optimal Starcraft II build orders and am trying to figure out the best way to structure my program.  I'm thinking of defining both units and resources by their "requirements", which I would like to compose, eg. scv = (Require (Minerals 15)) `someOperator` (Require (Supply 1)) `someOperator` (Require (Time 17)) `someOperator` (Require (Builder command_center))
11:37:20 <diefrage> Any ideas on how I should look into structuring this?
11:37:21 <kmc> diefrage, [Requirement] ?
11:37:31 <Twey> roconnor: It's getting into ‘programmers are stupid’ territory.
11:37:56 <roconnor> programmers are stupid
11:38:14 <roconnor> If programmers weren't stupid we wouldn't need type safty
11:38:23 <diefrage> As well, maybe "time" and "builder" be some sort of separate type, handled seperately
11:39:23 * chrisdone is still on the fence
11:39:47 <benmachine> hmm
11:39:56 <benmachine> I like that you can see from the type that the result isn't used
11:40:04 <Jafet> Is there an optimal build order? It might be a rock lurker scissors kind of thing
11:40:05 <benmachine> but actually if it's IO a you can see that anyway, right?
11:40:08 <benmachine> due to parametricity
11:40:11 <chrisdone> benmachine: indeed
11:40:25 <roconnor> benmachine: exactly
11:40:32 <diefrage> I keep falling into thinking unit types should be their own types, instances of typeclasses like Requires and Produces.  But various Haskell reading has somehow lent me the notion that typeclasses are bad and interfaces in common should be denoted by common types
11:40:54 <Jafet> discard = (>> return ())
11:41:01 <JoeyA> (<chrisdone> JoeyA: technically you could construct it as: ScanHandler (f >> return ())) => Alternatively, have a wrapper that does it.  But if ScanHandler has multiple callbacks and uses record syntax, the elegance here goes away and explicit return () is needed where applicable.
11:41:04 <benmachine> Jafet: discard = (() <$)
11:41:14 <Jafet> Ricer!
11:41:18 <benmachine> :P
11:41:24 <benmachine> my version works on any functor
11:41:24 <kmc> diefrage, "typeclasses are bad" is an oversimplification.  but yes, i prefer to represent interfaces by ordinary types when possible
11:41:31 <Twey> There's actually a ‘void’ somewhere
11:41:32 <kmc> or by existentially quantified types
11:41:34 <Twey> @index void
11:41:34 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign
11:41:37 <Twey> That's the one
11:41:45 <Twey> Foreign.void :: IO a -> IO ()
11:41:45 <diefrage> Okay
11:41:50 <kmc> diefrage, was this one of the articles you read: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
11:41:51 <JoeyA> Ricer!  Was that a Dvorak typo?
11:41:56 <JoeyA> (instead of Nicer)
11:42:03 <diefrage> Well, how should I structure composing requirements?
11:42:09 <Twey> JoeyA: Heh
11:42:13 <diefrage> kmc: yeah
11:42:23 <chrisdone> I thought it was an insult
11:42:29 <benmachine> chrisdone: me too!
11:42:34 <Jafet> If pretending to use dvorak makes me look cool, sure
11:42:38 <benmachine> heh
11:42:42 <JoeyA> lol
11:42:55 <JoeyA> I use Dvorak, and I noticed N and R are next to each other.
11:43:10 * chrisdone sniggers at programmers learning dvorak
11:43:38 <benmachine> chrisdone: why?
11:44:21 <chrisdone> typing english is the least of your worries
11:44:28 <benmachine> err
11:44:29 <benmachine> kinda
11:44:32 <Twey> Programmer's Dvorak ☺
11:44:38 <benmachine> class, instance, where, case, of
11:44:43 <kmc> dvorak is more comfortable in general
11:44:45 <benmachine> most function names are english-ish
11:44:52 <burp> that's worth it
11:44:58 <kmc> and anyway i spend more time arguing about programming languages on IRC than actually programming
11:45:02 <benmachine> :D
11:45:04 <benmachine> exactly!
11:45:06 <chrisdone> benmachine: like I said, english is the least of your problems, so, so what?
11:45:08 <Twey> Heh.
11:45:37 <Cale> diefrage: Concatenate lists of them?
11:45:39 <benmachine> chrisdone: oh, do you mean like, the hard part about programming isn't the bit where you write it down?
11:45:46 <chrisdone> !@#$%^&*()_+{}[];':".-=`,Ctrl,Shift,Ret,Tab <- make these more comfortable
11:45:53 <Jafet> Let's make a layout where all the punctuation is on the home row
11:45:55 <benmachine> oh pfft
11:45:56 <diefrage> Well, they're heterogenous
11:45:59 <Twey> chrisdone: Programmer's Dvorak
11:46:00 <benmachine> heh
11:46:06 <Mathnerd314> chrisdone: just use a language where you don't use those
11:46:08 <kmc> diefrage, then define a variant type
11:46:18 <benmachine> I bet if you frequency-analysed typical haskell source
11:46:28 <benmachine> it'd be mostly letters, and mostly vowels
11:46:29 <Twey> chrisdone: http://www.kaufmann.no/roland/dvorak/
11:46:34 <kmc> data Requirement = ReqMinerals Minerals | ReqBuilder Unit | ...
11:46:41 <Cale> diefrage: It seems reasonable to me that there would be a single type with a bunch of constructors, one per sort of requirement for building.
11:46:52 <chrisdone> benmachine: again, it's not about frequency. it's about what's hard to type
11:47:05 <kmc> newtype Minerals = Minerals Int deriving (Eq, Ord, Num, Integral)
11:47:18 <benmachine> chrisdone: but I'm arguing that what you spend most of your time typing is what's easier to type with dvorak
11:47:22 <diefrage> Whoa, they changed the Hackage look
11:47:29 <Mathnerd314> chrisdone: e.g., in Factor, nothing but [] and words
11:47:48 <Cale> You could indeed use typeclasses and existentials, but that seems needlessly complicated given that you have a fixed set of possible requirements dictated by the game itself.
11:48:07 <Cale> Data extensibility isn't so important here
11:48:20 <diefrage> Sorry, just taking another stab at understanding Schrijvers' monadic constraint programming
11:48:31 <diefrage> I feel like what I'm looking for is in there somewhere
11:49:03 <chrisdone> Twey: yeah I already thought about moving punctuation to the number row
11:49:45 <diefrage> Can't find where he's defined /\
11:50:48 <JoeyA> heh, programmer dvorak scrambles the numbers
11:50:54 <JoeyA> That's a shame, because 1048576 is fun to type!
11:50:55 <diefrage> Gah!  The Source link on the new hackage looks like part of the type signature
11:51:11 <chrisdone> I don't really find much interesting in an analysis of someone else's code to decide what *I* type the most often and find the most difficult to press
11:51:12 <JoeyA> (it goes back and forth, converging toward the center of the numbers)
11:51:19 <notabel> diefrage: INDEED!  I was upset by this yesterday
11:51:47 <diefrage> Can anyone here fix it?
11:51:52 <Twey> JoeyA: ANSI Dvorak makes it so that 012345678 is really fun to type.  ☺
11:51:56 <notabel> dunno
11:52:35 <JoeyA> ANSI dvorak?  Is that different than dvorak proper?
11:52:56 <Twey> JoeyA: ANSI Dvorak is Dvorak proper
11:53:00 <JoeyA> ah, okay
11:53:08 <Twey> A lot of modern implementations keep the numbers in QWERTY numerical order
11:53:33 <Twey> But the standardised one uses the numbers in optimised order, as seen on Programmer Dvorak
11:53:48 <JoeyA> oh
11:53:57 <chrisdone> I *am* interested in an adaptive keyboard layout
11:54:02 <JoeyA> my numbers (and their respective shift keys) are 1234567890 like in QWERTY
11:54:03 <b52> hey guys, i need a little help, again ... i use "primitive getCh :: IO Char" in a script i try to load with hugs but it fails: Unknown primitive reference "getCh"
11:54:49 <chrisdone> i.e. you can promote keys to and banish keys from the home and center rows on the fly to suite your task
11:55:24 <chrisdone> I'm talking a lot of english right now, I want commas, apostrophe's, speechmarks, return etc on the home row
11:55:35 <Cale> b52: You're trying to mess around with hugs' implementation details?
11:55:54 <chrisdone> when I'm coding I want a subset of !@#$%^&*()_+{}[];':".-=`,Ctrl,Shift,Ret,Tab there
11:56:10 <Cale> b52: getChar is the usual IO action to use to get a character from the keyboard
11:56:12 <chrisdone> when I'm coding lisp I want normal qwerty with a two parens in the center
11:56:38 <Twey> Why would you want QWERTY?
11:56:41 <Twey> Ever?
11:56:41 <notabel> chrisdone: good luck.  i have my doubts about the human factors here :-)
11:56:54 <b52> Cale: the book says i should do so
11:57:03 <b52> cause getCh doesnt echo the typed char
11:57:21 <b52> where as getChar does
11:57:32 <chrisdone> because I can type 90wpm happily but most of the time just type at 20wpm because I'm thinking, typing english isn't a big problem. I also want to be able to use someone else's keyboard without thinking about it
11:57:41 <aristid> Twey: because it allows you to type on keyboards that you haven't bought yourself
11:57:51 * ManateeLazyCat pasted "TODO for gtk-0.12.0" at http://paste2.org/get/978112
11:57:51 <ManateeLazyCat> Above is TODO for gtk-0.12.0, if anyone interested, help us!
11:58:03 <chrisdone> I also don't believe hype
11:58:03 <Twey> aristid: Oh, you're one of those people who can't type without staring at the keycaps?  :þ
11:58:21 <aristid> Twey: obvsly
11:58:29 <Cale> b52: That's sort of a bad recommendation since it's not really Haskell, but if the book is old, it might have been the only thing one could do at the time it was written...
11:58:46 <burp> www.daskeyboard.com :P
11:58:47 <notabel> Twey: no, I'm one of those people who sometimes uses computers he can't reconfigure to his whims
11:58:56 <Twey> chrisdone: 1) Screw hype, check statistics 2) you don't really lose QWERTY like that 3) keycaps don't have to match layout
11:58:58 <aristid> Twey: QWERTY isn't that bad either. so... *shrug*
11:59:04 <chrisdone> Twey: (there are no statistics)
11:59:06 <Twey> aristid: QWERTY is pretty damn awful
11:59:15 <aristid> so says the FUD
11:59:17 * ziman uses programmer dvorak + caps<->esc (on standard qwerty hardware) and likes it more than the simplified dvorak, exactly because of the special symbols
11:59:18 <chrisdone> Twey: (I did lose qwerty like that)
11:59:31 <Twey> chrisdone: http://colemak.com/Compare
11:59:34 <burp> http://www.artlebedev.com/everything/optimus/ ← wish this was affordable
11:59:37 <chrisdone> and keyboard layout, as notabel aren't at your whims
11:59:37 <b52> Cale: maybe, is there a function which does the sameß
11:59:49 <Twey> Sorry
11:59:52 <Twey> aristid: http://colemak.com/Compare
12:00:01 <b52> btw the book is from 07
12:00:03 <ManateeLazyCat> Bye all, night. :)
12:00:18 <Twey> Not everybody agrees that Dvorak is the best, but everybody agrees QWERTY is the worst.  I think even a straight alphabetic layout is more efficient than QWERTY.
12:00:37 <chrisdone> Dvorak proponents claim the Dvorak layout uses less finger motion, increases typing rate, and reduces errors compared to the de facto keyboard standard QWERTY.[1]  This reduction in finger distance traveled was originally purported to permit faster rates of typing, but in later years is also purported to reduce repetitive-strain injuries, including carpal tunnel syndrome.[citation needed]
12:00:41 <roconnor> Twey: I prefer my keys not jam up thank you very much!
12:00:46 * Twey laughs.
12:00:48 <aristid> Twey: no actual data
12:01:14 <Cale> b52: I'm just going to test if something works in hugs and then I'll give you the code :)
12:01:16 <JoeyA> " you don't really lose QWERTY like that" well actually, you kind of do
12:01:23 <Twey> aristid: The applet on that page allows you to test for yourself the amount of finger movement required on the respective layouts.
12:01:32 <b52> Cale: that would be nice, thanks
12:01:32 <JoeyA> but you can get all your speed back if you decide you don't want to learn Dvorak anymore, but it takes a few days.
12:01:47 <aristid> Twey: it does not work
12:01:49 <Twey> JoeyA: I haven't… I can still type QWERTY as well as ever I could (and it still gives me as much strain as ever it did)
12:01:50 <chrisdone> I can count the number of dvorak users I know who touch typed QWERTY with proper finger positions before learning dvorak. no wonder it seems like an amazing improvement
12:02:02 <JoeyA> I can currently do ~100 Dvorak and ~60 or 70 QWERTY.  I used to be able to do 100 QWERTY.
12:02:09 <Twey> Meh, good enough.
12:02:20 <JoeyA> Though I do most of my heavy typing with Dvorak.
12:02:25 <roconnor> JoeyA: that doesn't sound like an improvement
12:02:34 <burp> Twey: wow, the reduction is huge
12:02:41 <roconnor> JoeyA: heavy typeing, like Java?
12:02:46 <JoeyA> lol
12:02:50 <Twey> burp: *nod*
12:02:50 <JoeyA> I don't do Java.
12:03:00 <JoeyA> The only thing I've ever written in Java is an easter calculator.
12:03:03 <Twey> burp: QWERTY is *awful*.
12:03:07 <Twey> JoeyA: Haha, cute.
12:03:10 <roconnor> I actally like that term for expecit typing
12:03:25 <roconnor> "heavy typing" := explicit typing
12:03:39 <chrisdone> Twey: but with an adaptive layout I don't have the concerns of choosing a specific incarnation, I can mod it to suite my personal needs
12:03:56 <aristid> Twey: do you use emacs?
12:04:11 <Twey> aristid: Yes
12:04:30 <aristid> Twey: i'm told that dvorak does not work well with emacs
12:04:35 <Twey> chrisdone: That's true, but wouldn't you face the problem of mastering an ever-changing layout?
12:04:37 <Adamant> touch typing is worth picking up if you're gonna spend a substantial amount of time programming
12:04:46 <chrisdone> Twey: yeah, it'd be like using emacs
12:05:14 <Twey> aristid: I use ErgoEmacs, which has toggles to switch the key combos to Dvorak or Colemak layouts
12:05:38 <Twey> But straight emacs in Dvorak isn't much worse than in QWERTY, either.
12:05:56 <Adamant> Twey: is that a straight elisp dropin or seperate?
12:06:46 <DanielDiaz> Why some packages (like http://hackage.haskell.org/package/msgpack-0.3.0) does not have the haddock documentation in Hackage yet? How many hours have passed?
12:07:18 <DanielDiaz> What is the normal time?
12:07:22 <Martty> > 2 ^^ 64
12:07:22 <lambdabot>   1.8446744073709552e19
12:07:30 <Martty> > 2 ** 64
12:07:31 <lambdabot>   1.8446744073709552e19
12:07:39 <Martty> > 2 ** 64 :: Integer
12:07:40 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Internals.Integer)
12:07:40 <lambdabot>    arisi...
12:07:45 <mceier> > 2^64
12:07:46 <lambdabot>   18446744073709551616
12:07:49 <ezyang> DanielDiaz: msgpack probably doesn't compile on Hackage. 
12:07:58 <DanielDiaz> see other packages
12:08:07 <aristid> :t (^^)
12:08:08 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
12:08:14 <aristid> :t (**)
12:08:15 <lambdabot> forall a. (Floating a) => a -> a -> a
12:08:22 <aristid> :t (^)
12:08:23 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
12:08:40 <aristid> huh, what's the difference between ^^ and ^?
12:08:59 <Martty> > floor $ log(2^64)/log(10)
12:09:00 <lambdabot>   19
12:09:12 <DanielDiaz> for example: http://hackage.haskell.org/package/statistics
12:09:41 <DanielDiaz> since a date, no package has haddock documentation
12:09:42 <Cygnet> helloes
12:10:31 <Twey> Adamant: It comes as an elisp drop-in on *nix, or a separate application bundling emacs for Windows and OS X
12:12:46 <Cale> b52: Hmm, hugs seems to ignore buffering settings and remain in line buffered mode no matter what I do
12:12:55 <Cale> But here's the code you want anyway...
12:13:24 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29767#a29767
12:13:31 <sshc> I just installed haskellmode for vim, but it can't figure out the type of anything.  Whenever I press _t over anything, it reports "type not found"
12:14:09 <revenantphx> RWH is nice ^_^
12:14:25 <revenantphx> LYAH is a nice intro, buy RWH is more in depth
12:14:34 <tommd> sshc: Yeah, I've not even tried haskellmode for a long while.
12:14:41 <pumpkin> any objective c people feel like commenting on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29766#a29766 as a general idea?
12:14:50 <revenantphx> I had one question though...
12:14:53 <tommd> It doesn't seem to work out for me.
12:15:44 <revenantphx> pumpkin: I've done quite a bit with ObjC
12:15:45 <revenantphx> lemme look
12:15:53 <sshc> I also see three lines below the white status bar instead of one
12:16:01 <sshc> How do I set that setting back?
12:16:16 <revenantphx> wait... pumpkin... are you suggesting binding the objC runtime to haskell?
12:16:33 <pumpkin> revenantphx: yeah, just trying to find reasonably elegant ways of doing it
12:16:36 <revenantphx> also, I should mention
12:16:38 <revenantphx> line 11 is false.
12:16:40 <pumpkin> without dropping into Dynamic everywhere
12:16:46 <pumpkin> lol
12:16:52 <revenantphx> categories are used a LOT in class clusters and private api's for private methods
12:16:57 <pumpkin> yeah, sure
12:17:09 <revenantphx> you can place a category in the implementation file to simulate private methods.
12:17:10 <pumpkin> they're just less of a concern for a binding to objective c
12:17:24 <revenantphx> pumpkin: Bindings to objective-c would only need to bind to the objc-runtime.h
12:17:29 <revenantphx> objc_runtime.h*
12:17:31 <kmc> GADT data instances eh
12:17:34 <pumpkin> yeah, I know how it works
12:17:36 <revenantphx> everything on top of that is an abstraction.
12:17:47 <pumpkin> just trying to think of what things will look like on the haskell side
12:17:53 <revenantphx> Oh, well one thing I'm thinking
12:17:56 <revenantphx> about your point on classes.
12:18:09 <revenantphx> Objective-C uses isa pointers to navigate a class tree.
12:18:15 <revenantphx> I think the word "tree" is a key word there
12:18:17 <pumpkin> my issue there is implicit protocols
12:18:24 <revenantphx> oh I see.
12:18:49 <revenantphx> like categories on NSObject?
12:19:20 <pumpkin> just the fact that formal protocols aren't mandated, and people can call protocol methods on something that doesn't advertise having them
12:19:41 <pumpkin> but I guess people can send any selector to any object
12:19:46 <pumpkin> and I don't have a good answer for that yet
12:19:59 <pumpkin> maybe just using Dynamic
12:20:07 <Cale> b52: aha!
12:20:08 <revenantphx> objective-c is a pretty dynamic language
12:20:17 <revenantphx> that could be a bit hard to fit into immutable data 
12:20:27 <pumpkin> revenantphx: most things will be in IO
12:20:33 <pumpkin> except for things which we decide shouldn't be :P
12:20:34 <revenantphx> hm
12:20:38 <Cale> b52: Even though they're supposed to be equivalent, replacing  getChar  with  hGetChar stdin  fixes the behaviour in hugs
12:20:40 <revenantphx> well this is certainly an interesting idea though
12:20:45 <revenantphx> but I'm wondering how far you want to go?
12:21:02 <pumpkin> a complete binding, ideally :P there's talk about one here http://www.reddit.com/r/haskell/comments/d9wm2/is_it_time_for_a_strike_team_to_form_dedicated_to/
12:21:06 <pumpkin> there's the old HOC
12:21:20 <revenantphx> wow, surprising amount on OS X
12:21:22 <pumpkin> but it's kind of bitrotted and I'm not a fan of how it works
12:21:38 <Cale> b52: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29767#a29768 -- like this
12:22:04 <revenantphx> pumpkin: XCode integration is definitely not a priority though
12:22:08 <revenantphx> though, a dedicated IDE would be nice.
12:22:16 <revenantphx> something like DrScheme, with ghci on the bottom, and a code editor on top.
12:22:18 * hackagebot yeganesh 2.2.1 - small dmenu wrapper  http://hackage.haskell.org/package/yeganesh-2.2.1 (DanielWagner)
12:22:22 <pumpkin> revenantphx: yeah, I agree
12:22:23 <revenantphx> Actually... that would be a pretty fun project to try
12:22:32 <pumpkin> main thing I want is easy cocoa bindings
12:22:40 <revenantphx> yeah I see.
12:22:51 <pumpkin> so we can stop relying on GTK on mac os
12:22:53 <pumpkin> which is a nightmare
12:23:00 <revenantphx> heh
12:23:16 <revenantphx> well RubyCocoa and PyCocoa aren't exactly dreams either
12:23:17 <revenantphx> but they work
12:23:26 <revenantphx> RubyCocoa works well because both languages share a lot of traits.
12:23:31 <revenantphx> Objective-C and Haskell are both under appreciated imo anyhow
12:23:50 <revenantphx> Now, what I think would be very cool... is making an Objective-C binding to Haskell as an alternative to Apple blocks
12:23:56 <b52> Cale: thanks
12:24:05 <revenantphx> as in, allowing Haskell functions AS blocks.
12:24:10 <revenantphx> THAT would be awesome.
12:24:25 <ajnsit> Okay this is driving me nuts.. I am not able to solve a simple problem.. I have a monad that returns a string value.. Now I want to memoize it so that the result is a function that takes an integer and simply returns the value gotten when it was previously invoked with the same integer argument or runs the monad to get a value (which it then stores for future use)
12:24:44 <Cale> There is already a Haskell Objective C binding called HOC. I'm not saying you should use that instead, but you might want to look at it.
12:24:53 <pumpkin> revenantphx: yeah :)
12:25:03 <pumpkin> Cale: I have, and it's bitrotted and I'm not a fan of the approach
12:25:06 <Cale> It's probably somewhat bitrot... yes
12:25:23 <revenantphx> the syntax I'd want is something like this
12:25:36 <pumpkin> I think the GA data families thing seems to give me what I want
12:25:49 <revenantphx> makeHSBlock("myfile.hs", "myModule", "function")
12:25:55 <revenantphx> vaguely
12:26:01 <pumpkin> hah, you can do the opposite binding ;)
12:26:10 <kmc> ajnsit, you're using the word "monad" incorrectly.  examples of monads are types like IO and Maybe
12:26:19 <revenantphx> and that'd return a block which when used, binds to haskell
12:26:21 <kmc> values of type (IO t) or (Maybe t) might be called "monadic actions"
12:26:27 <kmc> or "monadic values"
12:26:39 <revenantphx> pumpkin: you might be able to work something out through dyld and compiled haskell btw
12:26:49 <ajnsit> kmc, yes ofcourse you are right
12:26:50 <Cale> ajnsit: Which monad?
12:26:53 <kmc> anyway, it's going to matter *which* monad
12:26:55 <revenantphx> if you can figure out how it converts haskell functions to C symbols.
12:27:09 <pumpkin> that really boils down to the haskell foreign export FFI stuff
12:27:10 <revenantphx> blocks are just a collection of information wrapping a function pointer...
12:27:11 <pumpkin> which isn't too bad
12:27:12 <ajnsit> Cale, I'm currently working with the IO monad but I'd like to generalise if possible
12:27:26 <pumpkin> revenantphx: yeah, but I mostly want to call objc from haskell for now :P
12:27:31 <revenantphx> pumpkin: mmk I see.
12:27:37 <revenantphx> with no extra syntax
12:28:04 <pumpkin> revenantphx: well, making it as pleasant and haskelly as possible given the huge difference in languages
12:28:25 <revenantphx> read: *huge*
12:28:27 <lispy> ajnsit: there is a type class MonadIO that directly generalizes the IO monad
12:28:33 <Cale> ajnsit: It's probably impossible in most monads. Let's look at just doing it in IO
12:28:39 <Cale> You probably want to take your value of type IO t, and turn it into an IO (IO t).
12:28:50 <revenantphx> pumpkin: make sure you account for all of OC's dynamism though...
12:28:57 <Cale> which sets up a memo table of some sort for results of executing the action:
12:29:03 <pumpkin> revenantphx: I'm explicitly trying not to :P
12:29:04 <revenantphx> pumpkin: function swizzling and class-tree rewrites are common enough to be an issue.
12:29:12 <revenantphx> Especially with SIMBL.
12:29:14 <Cale> memoIO :: (Ord t) => IO t -> IO (IO t)
12:29:20 <pumpkin> oh that kind of stuff is mostly behind my back in the runtime
12:29:33 <pumpkin> I mean, I'm not going to deal with dynamically generated selectors and the like
12:29:37 <pumpkin> at least not for now
12:29:55 <revenantphx> If you're not aware of it, SIMBL loads bundles when some program is run and uses categories to exploit the objective-c runtime, swizzling in replacement functions and such
12:29:57 <pumpkin> most people send messages that the compiler knows about in advance
12:30:00 <revenantphx> it can also override nibs
12:30:02 <Cale> memoIO x = do r <- newIORef (Map.empty); return (...)
12:30:30 <pumpkin> revenantphx: yeah, I know quite a bit about how it works :)
12:30:40 <revenantphx> its fun stuff
12:30:52 <pumpkin> yep :)
12:31:00 <revenantphx> I love playing around with the OC runtime. My favorite thing after Haskell (as of a week ago)
12:31:01 <pumpkin> omg well-typed doubled in size!
12:31:02 <Cale> Er, oops
12:31:28 <Cale> memoIO :: (Ord t) => (t -> IO s) -> IO (t -> IO s)
12:31:30 <revenantphx> pumpkin: the blocks implementation is open sourced I believe.
12:31:32 <Cale> better :)
12:31:36 <revenantphx> Since libdispatch depends on it.
12:31:45 <revenantphx> (which is opensourced)
12:31:50 <revenantphx> libdispatch kicks ass :P
12:31:58 <pumpkin> revenantphx: yeah, but can't do everything :P I have limited time and mostly want to focus on the other direction for now :P
12:32:02 <pumpkin> (plus I have a bajillion other projects)
12:32:06 <revenantphx> yeah I understand.
12:32:11 <revenantphx> Have you played with libdispatch though?
12:32:17 <Cale> ajnsit: So, we create an IORef holding a Map of the results of running our action with various initial parameters
12:32:30 <pumpkin> revenantphx: nope
12:32:37 <revenantphx> it's an amazing queueing library
12:32:44 <revenantphx> with a huge spread.
12:32:46 <Cale> ajnsit: and we want to return a function whose resulting action checks the Map to see if it already has a result
12:32:50 <pumpkin> GCD seems less useful in GHC haskell
12:32:53 <revenantphx> it's not
12:33:01 <BrianHV> I'm getting a "cannot construct the infinite type: a = IO a" error that doesn't make sense to me.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29769#a29769
12:33:01 <revenantphx> you can use it to write signal handlers easily
12:33:06 <revenantphx> without worrying about ayns-sig safety
12:33:09 <revenantphx> async*
12:33:13 <pumpkin> revenantphx: yeah, but the point is that GHC's runtime already does what GCD does
12:33:17 <revenantphx> and to run units multicore...
12:33:20 <revenantphx> pumpkin: precisely.
12:33:29 <revenantphx> 10$ says it was partially inspired by haskell.
12:33:31 <revenantphx> > >
12:33:32 <lambdabot>   <no location info>: parse error on input `>'
12:33:36 <pumpkin> so what would be the benefit of attaching to GCD?
12:33:38 <ajnsit> Cale, I'd like to generalise it to IO (t -> m s) where m is any monad
12:33:42 <pumpkin> yeah :)
12:33:52 <revenantphx> pumpkin: not GCD itself, but the blocks implementation
12:33:58 <monochrom> in soviet russia, GCD calls GHC
12:34:00 <revenantphx> that'd be a convenient place to tie in some haskell bindings.
12:34:07 <pumpkin> revenantphx: ah okay
12:34:13 <Cale> ajnsit: Probably not possible
12:34:14 <pumpkin> makes sense
12:34:26 <revenantphx> pumpkin: as I said before, blocks are struct/function pointer based
12:34:27 <Cale> ajnsit: What would it look like in the case of the Maybe monad?
12:34:27 <ajnsit> Cale, okay.. but I get the general idea, thanks I'll try it out
12:34:38 <pumpkin> revenantphx: yeah, I've looked at disassemblies of them before :)
12:34:57 <Cale> ajnsit: There are however, much better ways to memoise pure functions already
12:34:57 <ajnsit> Cale, well it wouldn't make sense but it still would work
12:35:02 <revenantphx> you could produce an extended struct which uses a function pointer to compiled haskell potentially
12:35:12 <revenantphx> it'd probably be much more difficult though
12:35:12 <pumpkin> yeah
12:35:13 <Cale> http://hackage.haskell.org/package/data-memocombinators
12:35:23 <Cale> ^^ make sure you check out that library :)
12:35:23 <revenantphx> anyhow, more power to you!
12:35:30 <revenantphx> I might write a simple little IDE at some point.
12:35:32 <pumpkin> revenantphx: that actually sounds like a fairly simple project :)
12:35:34 <revenantphx> that'd be an awesome projet.
12:35:36 <pumpkin> you should do it!
12:35:43 <pumpkin> :)
12:35:45 <revenantphx> have you seen DrScheme?
12:35:50 <revenantphx> that's exactly what I'm thinking basically.
12:35:54 <pumpkin> yeah
12:35:58 <revenantphx> Editor on top, ghci on bottom
12:35:59 <pumpkin> have you tried leksah?
12:36:02 <revenantphx> nope.
12:36:07 <revenantphx> macports is a bitch about it
12:36:07 <pumpkin> it'd be nice if it were MVC though
12:36:19 <revenantphx> MVC is easier than otherwise
12:36:24 <pumpkin> so we could stick an eventual haskocoa front end on it :P
12:36:25 <Cale> ajnsit: Somewhat surprisingly, that library uses no impure mutation at all. It only relies on the basic property of lazy evaluation that a parameter to a function is computed at most once.
12:36:30 <revenantphx> haskocoa?
12:36:32 <revenantphx> I like the name XD
12:36:36 <sepp2k> BrianHV: You're missing a return
12:36:40 <pumpkin> lol, just came up with it on the spot, not sure I do :P
12:36:44 <revenantphx> yeah its kinda corny
12:37:11 <revenantphx> Anyhow, I could throw together an editor (sans syntax highlighting) easily.
12:37:21 <Cale> (And in that way, takes advantage of the mutation in the implementation of lazy evaluation, where expressions are replaced with their values)
12:37:23 <revenantphx> Now what would be really great.. is if I could bootstrap TextMate into that view >:D
12:37:29 <pumpkin> lol
12:38:00 <revenantphx> My workflow right now consists of ghci with :set editor mate, and :! mate newfile.hs and so on
12:38:19 <BrianHV> sepp2k: adding one around the case produces a different set of compilation errors... I'll see if I can work through those
12:38:24 <revenantphx> well, good luck!
12:38:29 <ajnsit> Cale, this looks very interesting! I'm yet to wrap my head around pure memoization
12:38:37 <ajnsit> I must confess I'm a bit confused by even the Haskell memoisation article's fib' x = (map fib [1..] !! x)
12:38:38 <revenantphx> When I have some free time that isn't school occupied i'll definitely work on this.
12:38:48 <pumpkin> awesome
12:39:09 <revenantphx> I'll put up a repo so you can see progress I suppose.
12:39:17 <sepp2k> BrianHV: Well, another error I can see in the code is that you don't have the constraint `Show e`, but are still trying to call show on an e
12:39:27 <revenantphx> any idea for a quick name?
12:39:29 <ajnsit> how does first mapping over all integers and then taking the result you want entail less work??
12:39:33 <Cale> ajnsit: Well, I should really fix that example, it relies on the compiler doing an optimisation that is even more optional than lazy evaluation.
12:39:46 <Cale> ajnsit: It makes more sense if you write it like this:
12:39:58 <Cale> fibs = map fib [1..]
12:40:05 <Cale> fib' x = fibs !! x
12:40:11 <BrianHV> sepp2k: good point
12:40:18 <Cale> Now it's clear that fibs is a constant
12:40:24 <Cale> and so should only be computed once
12:40:27 <revenantphx> @let fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs . tail fibs]
12:40:27 <lambdabot>  <local>:3:0:
12:40:28 <lambdabot>      Multiple declarations of `L.fibs'
12:40:28 <lambdabot>      Declared at: <local...
12:40:32 <revenantphx> > take 20 fibs
12:40:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
12:40:39 <revenantphx> oh, it was never undefined from last night.
12:40:55 <revenantphx> take 1000 fibs
12:40:58 <revenantphx> > take 1000 fibs
12:40:59 <ajnsit> Cale, okay that makes a lot more sense!
12:40:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:41:06 <revenantphx> pumpkin: name idea?
12:42:28 <BrianHV> I feel like I should know this... but what does fail do in the IO monad?
12:42:38 <revenantphx> fails.
12:42:39 <monochrom> raise exception
12:42:41 <mathijs> Hi all, is there something like a "safe read" ?  I would like to parse a IP address, but using "read addr :: IPv4" throws an exception if addr is not valid
12:42:51 <Zao> @type reads
12:42:52 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:43:18 <mathijs> Zao, yeah, thought so too... doesn't work for IPv4 for some reason
12:43:37 <pumpkin> revenantphx: nah, I'm terrible with names and always try to avoid naming things :P
12:43:51 <sepp2k> BrianHV: It throws an exception, which if you don't catch it, will print the error message and exit the program
12:44:15 <Zao> > map (reads :: String -> [(Int, String)]) ["42lol", "asdf", ""]
12:44:16 <lambdabot>   [[(42,"lol")],[],[]]
12:44:18 <chrisdone> mathijs: readMay from the Safe library
12:44:21 <revenantphx> pumpkin: I had a brain fart last night about making a unix utility that deletes all haskell files in the current directory
12:44:25 <revenantphx> i'd call it Hasket.
12:44:29 <Zao> chrisdone: Does that have a readMe?
12:44:56 <BrianHV> I didn't even realize haskell had a way to catch exceptions...
12:45:04 <pumpkin> in IO, definitely
12:45:10 <BrianHV> that said, I've wrangled this code into submission
12:45:13 <pumpkin> in pure haskell, controversially :P
12:45:16 <pumpkin> @hackage spoon
12:45:17 <lambdabot> http://hackage.haskell.org/package/spoon
12:45:37 <Eduard_Munteanu> Did copumpkin get co-ed one more time? :)
12:46:14 <copumpkin> surely not!
12:46:23 <Eduard_Munteanu> Oh :).
12:46:43 <Eduard_Munteanu> Well, I know, it's tricky to get those arrows right.
12:47:34 <mathijs> chrisdone: readMay does not seem to work
12:47:42 <mathijs> I still get an exception
12:48:41 <chrisdone> mathijs: sounds like the read implementation is broken
12:49:14 <chrisdone> what's the exception?
12:49:24 <mathijs> nice :)   so is Data.IP still the recommended library for doing stuff with IP addresses? or is it deprecated?
12:49:39 <mathijs> eadMay "192.168.2" :: Maybe IPv4
12:49:39 <mathijs> *** Exception: parseIPv4 192.168.2
12:50:01 <copumpkin> revenantphx: hah
12:50:21 <copumpkin> mathijs: that seems silly, lol
12:50:23 <chrisdone> reads "192.168.2" :: [(IPv4,String)] gives what?
12:50:39 <chrisdone> :t reads -- I got the type right, right
12:50:41 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:50:44 <chrisdone> ja
12:50:49 <mathijs> reads "192.168.2" :: [(IPv4, String)]
12:50:49 <mathijs> *** Exception: parseIPv4 192.168.2
12:50:56 <chrisdone> yeah, the implementation is broken
12:51:10 <copumpkin> bitch at the maintainer
12:51:42 <chrisdone> if the maintainer doesn't respond to bitching, you could wrap it in an exception handler. kind of sucks though
12:51:50 <dmwit> Better yet: fix it yourself.
12:51:57 <dmwit> Take advantage of Hackage's crappy security.
12:52:04 <dmwit> THEN bitch at the maintainer.
12:52:05 <mathijs> isn't readMay from Safe supposed to wrap it?
12:52:07 <chrisdone> hehe
12:52:26 <chrisdone> mathijs: no, readMay handles properly implemented 'read', which shouldn't throw exceptions
12:52:48 <chrisdone> (well, readsPrec)
12:53:02 <copumpkin> mathijs: use spoon
12:53:02 <copumpkin> until they do fix it
12:53:07 <copumpkin> (then stop using spoon)
12:53:14 <dmwit> what a silly name
12:53:16 <chrisdone> like dmwit said you could patch the library
12:53:25 * copumpkin glares at dmwit 
12:53:28 <chrisdone> yeah, what is the spoon library? from the name I have no idea
12:53:41 <chrisdone> I'm hoping some kind of container
12:53:51 <jmcarthur> and ugly way to turn ugly library functions into pretty library functions
12:53:56 <jmcarthur> *an
12:54:00 <copumpkin> good description
12:54:10 <copumpkin> @hackage spoon
12:54:10 <lambdabot> http://hackage.haskell.org/package/spoon
12:55:20 <chrisdone> another ghost library from matt morrow
12:55:26 <copumpkin> no actually I wrote it :P
12:55:39 <chrisdone> why's his name on it? :p
12:55:46 <copumpkin> cause he helped with it too :)
12:55:49 <copumpkin> and named it
12:56:21 <copumpkin> it is a massive library, after all
12:56:39 <chrisdone> yeah, it took about 5 minutes to load the documentation page
12:56:39 <copumpkin> :P
12:56:51 <mathijs> copumpkin: IPv4 is not an instance of NFData
12:57:03 <copumpkin> mathijs: then use teaspoon
12:57:08 <chrisdone> lol
12:57:12 <copumpkin> teaspoon :: a -> Maybe a
12:57:16 <mathijs> ah :)
12:57:17 <copumpkin> spoon :: NFData a => a -> Maybe a
12:57:32 <mathijs> wow... very nice :)
12:57:38 <chrisdone> <mmorrow> call it spoon, and you can use teaspoon for a -> Maybe a, and then one day you can say "use teaspoon" in conversation ^_^
12:57:40 <dmwit> What, no Either String a?
12:57:53 <copumpkin> dmwit: there was a big discussion about allowing that
12:58:08 <dmwit> oh no
12:58:10 <copumpkin> dmwit: and in the end we decided not to, as it made it even less referentially transparent than it already is
12:58:13 <mathijs> would it be bad to just use this with read in all cases? instead of reads ?
12:58:14 <dmwit> Did somebody make a semantic argument?
12:58:20 <copumpkin> there was a load of discussion on on reddit about it
12:58:21 <dmwit> bother
12:58:21 <copumpkin> yeah :P
12:58:29 <copumpkin> also about specifically what exceptions we should catch
12:58:35 <dmwit> yeah
12:58:37 <dmwit> fine
12:59:16 * copumpkin wants mmorrow to come back
12:59:20 <copumpkin> @get-mmorrow
12:59:20 <lambdabot> Unknown command, try @list
13:00:42 * chrisdone misses mmorrow too
13:01:13 <chrisdone> I regret being mean to him, calling him ugly, etc
13:01:28 <chrisdone> he was a great leader and a moral figure
13:01:32 <chrisdone> okay you can come out now!
13:01:42 <chrisdone> ...            :-(
13:01:56 <roconnor> @seen mmorrow
13:01:56 <lambdabot> Unknown command, try @list
13:01:57 <preflex>  mmorrow was last seen on #ghc 231 days, 17 hours, 4 minutes and 11 seconds ago, saying: * mmorrow is rtfm'ing
13:02:08 <chrisdone> that's one god damn big manual
13:02:22 <chrisdone> maybe it was the Common Lisp HyperSpec
13:02:31 <copumpkin> someone should try phoning one of his potential phone numbers
13:02:37 * copumpkin touches nose
13:02:44 <mornfall> I wish GHC wouldn't mind ambiguous types when they have no constructors.
13:02:52 <mornfall> Or something.
13:02:56 <mornfall> They are phantom.
13:03:01 <mornfall> Anything... :)
13:03:14 * benmachine touches nose
13:03:21 * chrisdone touches copumpkin's nose
13:03:24 <chrisdone> woops
13:03:30 <benmachine> copumpkin: only 648 more and we'll have a candidate!
13:03:39 <Ke> this is getting silly
13:04:09 <copumpkin> Ke?
13:04:49 <Ke> nvm
13:04:59 <revenantphx> copumpkin: halp
13:05:06 <revenantphx> I've spent 15 minutes on the project name window.
13:05:09 <tommd> #haskell is never silly.  Haskell ⊦ #haskell ∉Silly
13:05:12 <revenantphx> > >
13:05:13 <lambdabot>   <no location info>: parse error on input `>'
13:05:30 <copumpkin> revenantphx: put in a dummy name and think about it later
13:05:35 <copumpkin> that's what I usually do
13:05:39 <revenantphx> Yeah except XCode is a bitch about dummy names.
13:05:48 <copumpkin> yeah, screw xcode
13:05:49 <revenantphx> Doesn't have a single good way to rename the entire project
13:05:49 <chrisdone> revenantphx: call it uberpea
13:05:59 <revenantphx> chrisdone: how does that make snese.
13:06:11 <chrisdone> uberpea. he's come to eat, you and me
13:06:15 <mornfall> revenantphx: You mean you still find the dummy name 5 years into the project in random places? :)
13:06:29 <chrisdone> what is the project?
13:06:30 <revenantphx> mornfall: I mean there's no good way to rename the entire project.
13:06:38 <revenantphx> chrisdone: A DrScheme clone for haskell editing on mac.
13:06:48 <revenantphx> Basically a REALLY simple two pane IDE.
13:06:58 <revenantphx> more as a personal experiment I suppoe.
13:06:59 <mornfall> McHaskell :D
13:07:35 <hpc> Haskellovich
13:07:46 <revenantphx> sorry bou that
13:08:46 <revenantphx> I was thinking Crappy Haskell IDE --> CHIDE
13:09:01 <revenantphx> since it will inevitably be crappy :P
13:09:07 <revenantphx> if it EVER gets finsihed... 10%
13:09:10 <geheimdienst> DrScheme -> ProfHaskell
13:09:18 <chrisdone> a name that chides itself by naming itself chide
13:09:19 <chrisdone> clever
13:09:23 <revenantphx> chrisdone: precisely > >
13:09:44 <chrisdone> MrsLambda
13:09:59 <copumpkin> Haskode ;)
13:10:15 <geheimdienst> icanhaskode
13:10:19 <copumpkin> no can haz
13:10:20 <hpc> lol
13:10:45 <revenantphx> It's only a matter of time before someone writes a LOLSKELL variant.
13:11:03 <chrisdone> -XLOL
13:11:30 <revenantphx> like LOLPython
13:11:49 <revenantphx> HAI
13:11:50 <revenantphx> CAN HAS STDIO?
13:11:50 <revenantphx> IM IN YR LOOP UPPIN YR VAR TIL BOTH SAEM VAR AN 10
13:11:50 <revenantphx>     VISIBLE SUM OF VAR AN 1
13:11:50 <revenantphx> IM OUTTA YR LOOP
13:11:51 <revenantphx> KTHXBYE
13:12:05 <mornfall> That ain't pure!
13:12:10 <revenantphx> thats LOLCODE
13:12:11 <aristid> yes it is
13:12:17 <revenantphx> it's a turing complete language :D
13:12:30 <revenantphx> and some guy wrote a .NET implementation
13:12:41 <revenantphx> and it's included in the Parrot VM...
13:12:43 <aristid> mornfall: that's all in the lazy State monad
13:12:47 <revenantphx> It's surprisingly prolific.
13:12:50 <mornfall> aristid: Stdio?
13:13:04 <benmachine> hmm, I have a C function that will return a file descriptor or -1 on error - should the return type of the call be Fd or CInt?
13:13:04 <aristid> mornfall: no stdio, just lists.
13:13:16 <mornfall> aristid: You need to fix 2nd line then.
13:13:39 <chrisdone> benmachine: Either CInt Fd?
13:13:43 <mornfall> benmachine: Depends if you throwErrnoIfMinusOne or something.
13:13:47 <benmachine> chrisdone: this is just the foreign import
13:13:51 <hpc> Maybe Fd
13:14:14 * mornfall would most likely throw.
13:14:16 <benmachine> wait, does foreign import play nicely with newtypes?
13:14:32 <mornfall> benmachine: In what sense?
13:14:42 <mornfall> You need to wrapper it anyway.
13:14:52 <benmachine> mornfall: can I specify a newtype in the type signature of a foreign import and expect it to work?
13:14:57 <mornfall> I wouldn't.
13:15:03 <benmachine> mm, okay
13:15:04 <mornfall> Although it theoretically could.
13:16:02 <geheimdienst> i guess a Maybe Fd would be the haskell parallel to a C value of "-1 on error, >-1 on success"
13:16:49 <kmc> benmachine, the FFI Addendum says nothing on newtypes
13:17:02 <hpc> i wouldn't directly import the function as any non-primitive type
13:17:02 <kmc> but see http://haskell.org/ghc/docs/6.12.2/html/users_guide/ffi.html#ffi-ghcexts
13:17:20 <hpc> import it to something internal and make a convenient function of a nice type
13:17:36 <benmachine> kmc: "The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum)."
13:17:48 <kmc> hmm yeah
13:17:56 <kmc> but i can't find that section in the FFI addendum actually
13:18:02 <revenantphx> oh wow
13:18:09 <kmc> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-120003.2
13:18:13 <revenantphx> Xcode 4 has a "credits.rtf" in the default application project
13:18:29 <revenantphx> this is the default contents
13:18:29 <revenantphx> http://gist.github.com/567479
13:18:29 <kmc> "a type synonym or renamed datatype of a marshallable foreign type"
13:18:34 <kmc> is that meant to include newtype too?
13:18:45 <kmc> newtype is not a type synonym, but is it a "renamed datatype"?
13:18:49 <copumpkin> revenantphx: lol
13:19:13 <benmachine> kmc: what else would a renamed datatype mean?
13:20:34 <hpc> i would consider it an alternate definition
13:20:48 <hpc> newtype, not "renamed ..."
13:22:19 <kmc> i think it's a poor choice of phrase, but i agree it must refer to newtype
13:22:32 <kmc> if only because "type synonym" is separately mentioned
13:22:49 <benmachine> kmc: http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1540008.4 the 2010 report is rephrased and explicit
13:22:56 <benmachine> interestingly, abstract newtypes can't be used
13:23:11 <kmc> ah, good
13:24:38 <benmachine> hmm
13:25:22 <revenantphx> what is "newtype"?
13:25:37 <benmachine> that precludes a lot of the types in System.Posix.Types
13:26:32 <benmachine> how irritating
13:27:23 <benmachine> revenantphx: it's like 'data', but can only have one constructor with one field; the advantage is that unwrapping and wrapping is free because the runtime representation is the same
13:27:50 <revenantphx> so it's kind of like a typedef?...
13:27:53 <revenantphx> more so than type even > >?
13:27:59 <benmachine> the types are distinct to the typechecker
13:28:08 <benmachine> so you can define different class instances for example
13:28:17 <revenantphx> mmk
13:29:22 <kmc> revenantphx, "type" is like typedef.  just a synonym that can be mixed in freely
13:29:56 <revenantphx> I got that.
13:30:04 <kmc> "data" creates a new type; the type checker will prevent you from mixing it with any other type
13:30:10 <revenantphx> okay got it
13:30:24 <kmc> and "newtype" is just a more efficient, more limited version of "data" — except that they have different semantics for "undefined"
13:30:30 <dmwit> "newtype" is for premature optimization
13:30:32 <dmwit> oops
13:30:54 <kmc> the idea is that "newtype" provides the compile-time checking of "data", but no extra run-time boxing/unboxing
13:31:10 <kmc> IOW the "newtype" is represented in-memory the same as the type it wraps
13:33:28 <revenantphx> copumpkin: I think that IDE would be a really cool idea, but
13:33:43 <revenantphx> copumpkin: I'm going to first learn significantly more haskell, write a bf interpreter in haskell... 
13:33:50 <copumpkin> yeah :)
13:33:53 <revenantphx> copumpkin: and do a lot of boring schoolwork
13:34:04 <revenantphx> and learn how to write a syntax highlighting engine
13:34:22 <revenantphx> the bottom pane will be easy, I'll just pipe a subprocess tty
13:35:43 <Veinor> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
13:35:45 <Veinor> What the hell?
13:35:53 <copumpkin> isn't it fun?
13:36:16 <Veinor> how does that even work?
13:36:56 <revenantphx> lazy execution and infinite sequences are fun :D
13:37:16 <Veinor> I mean, I get why it compiles
13:37:20 <revenantphx> Im thinking of writing a minecraft map generator in haskell later.
13:37:28 <revenantphx> Which would work great, since the map is inherently infinite.
13:37:32 <Veinor> but... aggh
13:38:23 <dmwit> wacky, eh?
13:39:34 <Veinor> so Integer -> Integer isn't decidable, but Cantor -> Integer is
13:39:37 <Veinor> that's awesome
13:40:38 <copumpkin> Veinor: the point is that you can always examine a finite number of bits to decide
13:40:52 <arnihermann> does anyone know of a reference of parsec being used to parse java-like language?
13:41:15 <Veinor> copumpkin: yeah, I gathered
13:44:26 <Eduard_Munteanu> I'm a bit lazy, what does that program do exactly?
13:44:37 <Eduard_Munteanu> It's seemingly impossible for me to tell. :)
13:44:38 <Veinor> which program?
13:44:47 <Eduard_Munteanu> Veinor: the seemingly impossible stuff :)
13:44:53 <dmwit> It tests (Integer -> Bool) functions for equality.
13:45:35 <dmwit> Functions with finite codomain can sometimes have decidable equality.
13:45:35 <Veinor> yeah.
13:45:51 <Eduard_Munteanu> Hm, that is seemingly impossible.
13:46:15 <Veinor> in particular, it defines a type Cantor = Integer -> Bool, and it turns out that if you can compare a type t for equality, then you can compare Cantor -> t for equality
13:47:50 <Eduard_Munteanu> Veinor: I don't see how the Cantor abstraction helps, I mean the Integer -> Bool functions is for all purposes infinite.
13:47:59 <dmwit> So?
13:48:02 <Veinor> yeah, I'm just using that as shorthand
13:48:04 <dmwit> Integer is infinite, but has decidable equality.
13:48:06 <Eduard_Munteanu> You only know them by application.
13:48:21 <kmc> if «f :: Cantor → T» returns in finite time then it only called its argument at finitely many values
13:48:27 <kmc> is that significant?
13:48:37 <dmwit> Yes.
13:49:38 <Eduard_Munteanu> Well, in Haskell, you don't really have an encoding that helps you compare certain functions, as opposed to numbers. So I'm a bit baffled.
13:50:29 <kmc> for each of «f,g :: (Nat → Bool) → T» you can build a binary tree of the Nats that the function tests, with a branch for each of True and False result
13:51:06 <kmc> and leaves labeled with elements of T
13:51:21 <kmc> this is a finite tree by assumption of totality; for every input f,g must return in finite time
13:51:39 <kmc> so comparing values of type «(Nat → Bool) → T» comes down to comparing binary trees with leaf labels from T
13:51:45 <Eduard_Munteanu> Hmm.
13:51:50 <kmc> does that make any sense?
13:51:55 <kmc> i'm really not sure i got it right
13:52:04 <Eduard_Munteanu> kmc: yeah, but do f and g exist?
13:52:10 <kmc> what do you mean?
13:52:26 <kmc> the problem statement is: given «f,g :: (Nat → Bool) → T» decide if f == g
13:52:55 <Eduard_Munteanu> kmc: is there any f,g :: (Nat -> Bool) -> T, that
13:53:00 <Eduard_Munteanu> scratch that.
13:53:16 <Eduard_Munteanu> Hm, that's another thing.
13:54:09 <Eduard_Munteanu> I thought it was: given f,g :: Nat -> Bool, decide if f == g. But this is a bit more contrived and my head hurts :)
13:54:56 <kmc> yeah, that one is clearly impossible
13:56:04 <bss03> kmc: What are "computable functionals"  are they related to computable reals / numbers ?
13:56:24 <kmc> "functional" is a mathematician's term for a higher-order function, afaik
13:56:40 <kmc> so it just means a computable function which takes a function as an argument
13:56:59 <opqdonut> usually linear
13:57:13 <revenantphx> mathematician == mathmagician?
13:57:19 <revenantphx> I'm not clear on the distinction.
13:57:32 <opqdonut> functionals are usually linear mappings from a function space to another
13:58:07 <bss03> I must admit, it's been a while since analysis class, and I'm not sure we covered the Cantor space very well.
13:58:17 <bss03> What's the measure used in the Cantor space?
13:58:24 <opqdonut> it's not analysis, it's topology
13:58:32 <rizlah> Is there any good IDEs for writing haskell projects?
13:58:42 <revenantphx> hey kmc
13:58:47 <opqdonut> I don't think there's any standard measure for the cantor space
13:58:52 <kmc> hi revenantphx
13:58:52 <bss03> kmc: analysis and topology have the idea of compactness.
13:58:55 <revenantphx> could you help me with the syntax for one of the RWH exercises?
13:58:57 <opqdonut> I'd guess it isn't measureable
13:58:59 <kmc> sure
13:59:23 <revenantphx> kmc: It's from the section where it shows 'data List a = Cons a (List a) | Nil deriving (Show)
13:59:27 <bss03> kmc: and the document said "... in anaylsis and topology there is a theorem ..."
13:59:35 <revenantphx> and then you write a function to convert [a] to List a
13:59:38 <revenantphx> easy enough
13:59:50 <revenantphx> now one of the exercises is to do the reverse, but I can't figure out how to write the function
13:59:56 <revenantphx> given the data constructor syntax
14:00:03 <DrSyzygy> Aaaactually, functionals in analysis tend to be mappings from a vector space to its scalars.
14:00:03 <dmwit> What have you got so far?
14:00:09 <kmc> f (Cons x xs) = ...
14:00:10 <kmc> f Nil = ...
14:00:15 <bss03> kmc: So, I figured I could approach it from my shaky analysis background instead of my intuitive understand (i.e. wrong understanding) of topology.
14:00:19 <opqdonut> DrSyzygy: wouldn't those be covectors?
14:00:21 <revenantphx> kmc... crap
14:00:23 <revenantphx> thanks>  
14:00:25 <orbital_fox> anyone know of an object/relational mapper in haskell (haskell doesnt have a OOP so maybe functional/relational mapper)
14:00:34 <DrSyzygy> opqdonut: Yes, except in functional analysis, where they are named functionals instead.
14:00:39 <kmc> OOP is a style, you can do OOP in Haskell too
14:00:51 <revenantphx> kmc: its not a "feature" of the language though :P
14:00:54 <kmc> true
14:00:56 <opqdonut> yes, hmm, scalar value
14:00:57 <opqdonut> my bad
14:01:01 <Adamant> given how mathy relational algebra is
14:01:08 <Adamant> which SQL is based on
14:01:16 <revenantphx> and Haskell lacks the concepts of Classes, Instances, Methods etc
14:01:21 <ajnsit> Cale, I managed to write something similar to what I wanted - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29772#a29772
14:01:24 <revenantphx> you could implement it but it'd be a pain in the ass.
14:01:27 <Adamant> I wonder if Haskell has any specialized packages for working on it
14:01:28 <kmc> revenantphx, not really
14:01:32 <kmc> foo is math, Haskell is math, therefore Haskell is foo
14:01:35 <Adamant> revenantphx: typeclasses
14:01:41 <revenantphx> Adamant: I suppose > >
14:01:55 <Eduard_Munteanu> You can say classes etc. don't map onto language features, but they can be used.
14:01:57 <Adamant> revenantphx: they work a bit like interfaces in practice
14:02:04 <revenantphx> Adamant: I'm aware.
14:02:09 <Adamant> ah, right.
14:02:21 <kmc> drawing parallels between Haskell and other languages is a fool's errand
14:02:29 <revenantphx> kmc: heh, true
14:02:35 <Adamant> kmc: many fools have attempted it, then
14:02:37 <kmc> on another note, damn the new haddock looks good :)
14:02:37 <Adamant> :P
14:03:20 <Cale> ajnsit: Oh, sure, you can certainly do it using StateT
14:03:20 <Eduard_Munteanu> Hm, it does look nicer.
14:03:21 <orbital_fox> right
14:03:56 <orbital_fox> how would you call (in the mathy world) a persistent object? not one whose value never changes, but one that doesnt ever die :P
14:04:10 <kmc> so, building on the earlier discussion, is it possible to implement this function?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29774#a29774
14:04:11 <hpc> a constant
14:04:20 <dmwit> orbital_fox: state
14:04:30 <kmc> i can't see how, without using continuations
14:04:40 <ajnsit> Cale, yeah somehow I figured it was better than using IORefs
14:04:42 <revenantphx> wait kmc
14:04:49 <revenantphx> is that supposed to map functions to tree branches?...
14:04:57 <revenantphx> or take a function and return a tree based on it?
14:05:02 <kmc> the latter
14:05:17 <revenantphx> so basically it builds a tree based on the return value of each call 
14:05:24 <orbital_fox> are you guy still discussing my question, or have you moved on? :P
14:05:27 <kmc> revenantphx, we were discussing the problem of: given «f,g :: (Nat → Bool) → T» decide if «f == g»
14:05:35 <kmc> which sounds impossible
14:05:39 <revenantphx> oh, yeah that one, I know it so well.
14:05:44 <revenantphx> (that makes no sense to me)
14:06:00 <kmc> but i argued that each such f can be represented by a finite binary tree labeled with T at the leaves and Nats on the branching nodes
14:06:15 <kmc> because f can't do anything except call its argument, a function of type (Nat → Bool), on one Nat at a time
14:06:21 <revenantphx> Well, I could see representing functions as trees as possible.
14:06:25 <dmwit> kmc: Perhaps you had better just read TFA.
14:06:28 <revenantphx> No clue how.
14:06:30 <kmc> i did read TFA
14:06:39 <kmc> several times
14:06:51 <dmwit> oh
14:06:52 <kmc> i don't think this question is addressed directly
14:06:58 <Eduard_Munteanu> kmc: mm, I'm not sure you're supposed to, you should have Nat -> Bool on nodes, if anything.
14:07:15 <Eduard_Munteanu> TFA?
14:07:21 <kmc> why's that?
14:07:24 <bss03> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
14:07:45 <kmc> wlog, f = \c → ...
14:07:47 <kmc> c :: Nat → Bool
14:08:00 <kmc> so the only thing f can do is call c for some Nat n, then branch on the return value of c
14:08:03 <revenantphx> so wait
14:08:12 <Eduard_Munteanu> kmc: I just don't see any mapping of Nat -> Bool onto Nats.
14:08:16 <revenantphx> this («f,g :: (Nat → Bool) → T» decide if «f == g») in english would be
14:08:19 <kmc> that's not what i propose at all
14:08:24 <kmc> revenantphx, it's Haskell
14:08:25 <DrSyzygy> kmc: Are you assuming some sort of finiteness of T?
14:08:26 <revenantphx> trying to prove if two functions are equal?
14:08:32 <kmc> DrSyzygy, you assume decidable equality of T
14:08:48 <bss03> T must be decidable.
14:08:58 <kmc> from TFA: Eq t => (Cantor -> t) -> (Cantor -> t) -> Bool
14:09:01 <revenantphx> this stuff is over my head > <
14:09:02 <DrSyzygy> In that case it's not at all clear to me that the tree ends up necessarily being finite. Do you have an argument for that?
14:09:05 <jmcarthur> Eduard_Munteanu: Nat -> Bool sounds like a representation of binary numbers, which is can represent a Nat :)
14:09:16 <jmcarthur> *which is a representation of Nat
14:09:20 <kmc> where type Cantor = Nat -> Bool
14:09:26 <DrSyzygy> jmcarthur: Nope.
14:09:26 <kmc> DrSyzygy, f,g are total functions
14:09:27 <dmwit> DrSyzygy: the article says "by compactness" and leaves it at that (approximately)
14:09:33 <kmc> for any input, they return in finite time
14:09:38 <Eduard_Munteanu> jmcarthur: multiple Bools, yes.
14:09:40 <DrSyzygy> jmcarthur: It's not finite sequence of booleans, it's a stream of booleans.
14:09:42 <kmc> so every path through the tree must have finite depth
14:09:45 <Eduard_Munteanu> But Nat and Bool aren't isomorphic.
14:09:48 <dmwit> kmc: Okay, I've only just now understood your question.
14:09:55 <dmwit> sorry =P
14:09:59 <DrSyzygy> jmcarthur: More appropriate comparison is 2-adic expansion of some real number in [0,1).
14:10:00 <jmcarthur> DrSyzygy: sure, it's not something you can compute a Nat from, if that's what you're getting at
14:10:19 <DrSyzygy> jmcarthur: No, it's worse than that - it isn't the same size as Nat.
14:10:29 <kmc> anyway, from this argument it seems like my function «Fun t → Tree t» should exist
14:10:37 <Eduard_Munteanu> Umm, same size can only be defined by isomorphism consistently.
14:10:37 <dmwit> Yes, I agree.
14:10:40 <kmc> (and is computable)
14:10:41 <kmc> but can i write it in Haskell?
14:10:46 <DrSyzygy> Eduard_Munteanu: Yes.
14:11:10 <kmc> i can't directly observe how f calls its argument c
14:11:20 <roconnor> kmc: what is your function?
14:11:27 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29774#a29774
14:11:44 <bss03> It includes infinite sequences, so it is a subset of the reals that is larger than Nats.
14:11:46 <dmwit> roconnor: Converting a function to a decision tree without having the source of the function at hand.
14:12:13 <kmc> the above argument doesn't rely on source, but it does rely on observing the function's behavior
14:12:21 <jmcarthur> DrSyzygy: okay, i see why and agree that it's not the same
14:12:30 <roconnor> kmc: Anrej effectively writes that function in his blog post doesn't he
14:12:34 <jmcarthur> and retract my former statement
14:12:40 <kmc> which?
14:12:50 <DrSyzygy> kmc: Oooooh. So the iso Cantor = Nat -> Bool is the one you get by writing the points of the Cantor set by 3-adic expansion (thus only using 0 and 2, and not 1); and picking 0/2 according to the sequence given.
14:13:02 <kmc> i think so
14:13:17 <DrSyzygy> Does the paper say that the tree you're talking about is finite? 
14:13:28 <bss03> roconnor: Yep, he effectively builds the list of bits.
14:13:29 <kmc> "the Cantor space" is just the name for the space of infinite binary sequences
14:13:33 <kmc> but i think that's where the name comes from
14:13:42 <roconnor> kmc: http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/
14:14:07 <roconnor> kmc: specifically unfn'
14:14:16 <kmc> ah, cool
14:14:23 <kmc> that does look close
14:14:26 <kmc> "there is no point in explaining the code, just stare at it for a while"
14:14:27 <roconnor> kmc: ya it isn't quite the same
14:14:30 <DrSyzygy> Coz the Cantor space is IIRC uncountable; and so your leaves won't necessarily be finite enough....
14:14:32 <roconnor> :D
14:14:55 <kmc> DrSyzygy, but we're considering functions *from* the Cantor space *to* some other set
14:15:22 <DrSyzygy> And those functions are only finitely many? Or form a finite depth tree? 
14:15:45 <copumpkin> those functions if they terminate must only check a finite number of values
14:15:53 <DrSyzygy> Ah, that's the statement?
14:15:58 <kmc> i described an isomorphism between the types «Tree t» and «Fun t»
14:16:16 <copumpkin> DrSyzygy: yeah
14:16:22 <kmc> every function of type «Cantor → t» can be described completely by a binary tree of finite depth
14:16:27 <bss03> He argues that "by compactness".
14:16:31 <Eduard_Munteanu> Mmm, the explicit definition of those functions might be infinite even if they are computable.
14:16:57 <roconnor> Eduard_Munteanu: huh?
14:17:14 <roconnor> all computable functions have a finite description
14:17:23 <DrSyzygy> Hmmmmm. Certainly I know what Heine-Borel compactness is. Just not how it comes into play here, exactly.
14:17:36 <Eduard_Munteanu> The graph of the underlying relation of Integer->Bool might be infinite.
14:17:41 <roconnor> DrSyzygy: Scott topology
14:18:21 <Eduard_Munteanu> But f(x) for any x can be computed in a finite time.
14:18:44 <Twey> ?
14:18:48 <mathijs> is there a way to convert between instances of MonadPlus? I wrote this function but I have the feeling there is probably a generic way to do it:
14:18:51 <mathijs> maybeToMonadPlus :: (MonadPlus m) ⇒ Maybe a →  m a
14:18:51 <mathijs> maybeToMonadPlus = maybe mzero return
14:18:53 <DrSyzygy> roconnor: Oh dear. Those things make my head hurt. I'm going to stop helping out here.
14:19:10 <Twey> :t (== 0) . fix (+ (1 :: Integer))
14:19:11 <lambdabot>     Couldn't match expected type `f a' against inferred type `Integer'
14:19:11 <lambdabot>     In the second argument of `(.)', namely `fix (+ (1 :: Integer))'
14:19:11 <lambdabot>     In the expression: (== 0) . fix (+ (1 :: Integer))
14:19:23 <Twey> Oops
14:19:44 <Twey> :t \n -> (== 0) $ fix (+ (n :: Integer))
14:19:44 <dmwit> mathijs: That is the best you can do.
14:19:45 <lambdabot> Integer -> Bool
14:19:52 <Twey> That doesn't look too finite to me
14:20:03 <Twey> Oh wait.
14:20:20 <mathijs> dmwit: no extensions that can do something like this? it feels like boilerplate
14:20:35 <Eduard_Munteanu> Ok, rephrasing, there are infinitely many total functions Integer -> Bool.
14:20:37 <dmwit> mathijs: Incidentally, that function is the arrow showing that Maybe is initial in the category of MonadPlus type constructors. =)
14:21:13 <dmwit> mathijs: Why would you expect such a conversion to exist? Do you demand a conversion between different instances of Monad?
14:21:17 <Veinor> dmwit: you can't generalize because there's no function (MonadPlus m) => m a -> a, right?
14:21:31 <Jon> hi folks. I import a module in my code which defines a type (module hfuse, type FileStat) which has 'deriving Show'. However, I want to provide my own show fn. Is there a form of qualified import that I can use to 'disable' the 'deriving show'? Or, can I override the show fn that results?
14:21:48 <Jon> if I declare my own I get "Duplicate instance declarations"
14:21:56 <dmwit> Veinor: um
14:21:58 <roconnor> Jon: nope.  The best you can do is a newtype wrapper
14:22:05 <Veinor> or am I being confused?
14:22:07 <dmwit> Veinor: mu, I guess
14:22:13 <Veinor> yeah.
14:22:22 <Veinor> mu seems like the right answer here (assuming you don't mean Mu :P)
14:22:48 <Jon> roconnor: oh darn. thanks anyway!
14:22:57 <dmwit> Such a function would make many things possible, of course. But it would also severely restrict which things could be instances of MonadPlus.
14:23:07 <roconnor> Jon: you can also write your own print function and call it
14:23:13 <Veinor> right.
14:23:14 <mathijs> dmwit: I'm parsing something (using parsec) but need some validations on some stuff, so I pipe the parsed strings through functions that return Maybe a. if all goes well, a is parsed, if it's Nothing, a parse-error is raised
14:23:21 <Veinor> in particular [] wouldn't be in MonadPlus
14:23:53 <medfly> @hoogle fix
14:23:53 <lambdabot> Data.Function fix :: (a -> a) -> a
14:23:54 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
14:23:54 <lambdabot> module Control.Monad.Fix
14:23:57 <Veinor> ... it strikes me that it would be impossible to write a total function with that type because of mzero
14:25:20 <dmwit> mathijs: sounds good to me
14:25:22 <Eduard_Munteanu> Maybe that's why most comonadic stuff refers to non-empty stuff.
14:25:33 <Eduard_Munteanu> That's an awful lot like coreturn.
14:25:37 <Jon> hm a related question. I've imported a simple type which is just data Foo = Bar | Baz (or thereabouts). It does *not* derive Eq, but I would like it to. Can I bolt-on a derived Eq after import?
14:25:45 <Eduard_Munteanu> (extract as they name it in category-extras)
14:25:51 <dmwit> Jon: Yes, via standalone deriving.
14:26:29 <dmwit> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
14:26:40 <hpc> is there a reason you can't modify that module and add the deriving yourself?
14:26:54 <Jon> dmwit: thanks - I think that's beyond me so late this eve, but I shall bookmark it for another time ☺
14:27:09 <Jon> hpc: I might submit a patch to do so, I could modify it locally, yes
14:27:25 <hpc> oh, it's not your module :P
14:27:55 <dmwit> Jon: It's not very hard. Add "{-# LANGUAGE StandaloneDeriving #-}" to the top of your file, then write "deriving instance Eq Foo" in the middle of your file somewhere.
14:28:59 <Jon> dmwit/hpc: actually side-stepping, I can achieve what I wanted to using a 'case' construct (I was using guards, which required equality testing)
14:29:15 <dmwit> Oh, good.
14:29:17 <Jon> dmwit: that *isn't* very hard, true. I didn't get that from reading the page myself!
14:29:20 <dmwit> That's often better anyway.
14:29:41 <Jon> I take it that approach is a GHC-ism?
14:29:46 <dmwit> Yes.
14:30:05 <dmwit> I probably should have linked http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/deriving.html#stand-alone-deriving instead, anyway.
14:38:24 <mathijs> @pf parseTimePlus locale fmt = maybeToMonadPlus∘parseTime locale fmt
14:38:24 <lambdabot> Maybe you meant: bf pl
14:38:30 <sshc> Which extension enables mdo?
14:38:32 <mathijs> @pl parseTimePlus locale fmt = maybeToMonadPlus∘parseTime locale fmt
14:38:32 <lambdabot> (line 1, column 45):
14:38:33 <lambdabot> unexpected "\136"
14:38:33 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
14:38:40 <revenantphx> copumpkin: is there any way to get a function symbol from compiled haskell?
14:38:47 <tehgeekmeister> @pl (((>1).).gcd)
14:38:47 <lambdabot> ((> 1) .) . gcd
14:38:54 <Cale> @let takeUntil p [] = []; takeUntil p (x:xs) | p x = [x] | otherwise = x : takeUntil p xs
14:38:54 <revenantphx> copumpkin: it seems like the function has been optimized out of existence actually > >
14:38:55 <lambdabot>  Defined.
14:39:02 <tehgeekmeister> why won't it give me other versions of it!
14:39:08 <Jon> dmwit/hpc: thank you both for your help
14:39:12 <sshc> (mdo is the one that lets me refer to whatever is on the left of "<-" on the right, right?)
14:39:19 <tehgeekmeister> is there a way to take a pointless bit and make it pointful?
14:39:23 <tehgeekmeister> @pf (((>1).).gcd)
14:39:24 <lambdabot> Maybe you meant: bf pl
14:39:33 <tehgeekmeister> @bf pl (((>1).).gcd)
14:39:34 <lambdabot>  Done.
14:39:34 <hpc> @unpl (((>1).).gcd)
14:39:34 <lambdabot> (\ e h -> (gcd e h) > 1)
14:39:47 <Cale> map length . filter (all (=='a')) . takeUntil (null . drop 1) . iterate (\(x:y:xs) -> xs ++ case x of 'a' -> "bc"; 'b' -> "a"; 'c' -> "aaa") $ "aaa"
14:39:49 <Cale> > map length . filter (all (=='a')) . takeUntil (null . drop 1) . iterate (\(x:y:xs) -> xs ++ case x of 'a' -> "bc"; 'b' -> "a"; 'c' -> "aaa") $ "aaa"
14:39:50 <lambdabot>   [3,5,8,4,2,1]
14:39:57 <hpc> huh, that's the least ugly unpl i have ever seen
14:40:17 <dmwit> :t do { x <- return x }
14:40:18 <lambdabot>     The last statement in a 'do' construct must be an expression
14:40:19 <Twey> Heh
14:40:23 <dmwit> :t do { x <- return x; return x }
14:40:24 <lambdabot> forall (m :: * -> *). (Monad m) => m Expr
14:40:31 <dmwit> argh
14:40:33 <Cale> > map length . filter (all (=='a')) . takeUntil (null . drop 1) . iterate (\(x:y:xs) -> xs ++ case x of 'a' -> "bc"; 'b' -> "a"; 'c' -> "aaa") . flip replicate 'a' $ 52
14:40:34 <lambdabot>   [52,26,13,20,10,5,8,4,2,1]
14:40:44 <dmwit> :t do { xyz <- return xyz; return xyz }
14:40:45 <lambdabot> Not in scope: `xyz'
14:40:49 <dmwit> :t mdo { xyz <- return xyz; return xyz }
14:40:50 <lambdabot> forall t (t1 :: * -> *). (MonadFix t1) => t1 t
14:41:12 <hpc> what does mdo desugar to?
14:41:16 <dmwit> :t mfix
14:41:17 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:41:44 <dmwit> sshc: RecursiveDo
14:42:00 * hackagebot reference 0.1 - A class for references in Haskell  http://hackage.haskell.org/package/reference-0.1 (MaciejPiechotka)
14:42:01 <hpc> i see
14:42:27 <dmwit> hm
14:42:37 <hpc> @src mfix
14:42:37 <lambdabot> Source not found. Are you on drugs?
14:42:41 <dmwit> :t do { rec xyz <- return xyz; return xyz }
14:42:42 <lambdabot> Parse error in pattern
14:42:50 <dmwit> :t do { rec (xyz <- return xyz); return xyz }
14:42:51 <lambdabot> parse error on input `<-'
14:43:17 <dmwit> I'm not sure I understand the documentation for mdo, however.
14:43:30 <dmwit> hpc: It's implemented differently for each instance, of course.
14:43:38 <hpc> ah, right
14:43:45 <Cale> > map length . filter (all (=='a')) . takeUntil (null . drop 1) . iterate (\(x:y:xs) -> xs ++ case x of 'a' -> "bc"; 'b' -> "a"; 'c' -> "aaa") . flip replicate 'a' $ 27
14:43:48 <lambdabot>   mueval-core: Time limit exceeded
14:43:59 <Cale> > map length . filter (all (=='a')) . takeUntil (null . drop 1) . iterate (\(x:y:xs) -> xs ++ case x of 'a' -> "bc"; 'b' -> "a"; 'c' -> "aaa") . flip replicate 'a' $ 49
14:44:00 <lambdabot>   [49,74,37,56,28,14,7,11,17,26,13,20,10,5,8,4,2,1]
14:44:06 <tehgeekmeister> length "nubBy (((>1)http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:.).http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:gcd) [2.http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:.]"
14:44:15 <tehgeekmeister> > length "nubBy (((>1)http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:.).http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:gcd) [2.http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:.]"
14:44:15 <lambdabot>   235
14:44:28 <tehgeekmeister> i didn't want thatttttt
14:44:32 <dmwit> hehe
14:44:33 <hpc> rofl
14:44:47 <Cale> That would be quite an extension of Haskell
14:45:17 <Cale> Seamlessly use definitions from the web by putting their URLs in place!
14:45:29 <Veinor> haha
14:45:34 <mauke> fuck yeah
14:45:45 <Veinor> Cale: what does that code do
14:45:47 <mauke> we should use this to replace modules
14:45:50 <luite> the next version should also support irc
14:45:51 <olsner> from hackage import QuickCheck
14:46:15 <Veinor> it automatically updates your packages, too!
14:46:21 <Veinor> even when you don't want it to!
14:46:24 <mauke> import http://haskell.org/lib/Data/Map
14:46:28 <EvanR-work> but under no circumstances shall it send mail
14:46:31 <illissius`> from Future import Program
14:46:32 <EvanR-work> gotta draw the line somewhere
14:46:35 <EvanR-work> thats gonna be a library
14:46:36 <Cale> Veinor: it's a secret ;)
14:47:04 <Veinor> hm
14:47:19 <tehgeekmeister> (i just pasted a bit of code, my irc client transformed it somehow for me.  D=)
14:47:36 <Cale> > let collatz n | odd n = (3*n+1) `div` 2 | otherwise = n `div` 2 in takeUntil (== 1) . iterate collatz $ 49
14:47:37 <lambdabot>   [49,74,37,56,28,14,7,11,17,26,13,20,10,5,8,4,2,1]
14:47:44 <illissius`> XML does something like that with its doctypes though, I never got whether those had to be live URLs and what happens when one of the machines goes down, if so
14:48:04 <Veinor> Cale: that's what I was thinking
14:50:12 <Cale> It turns out that by just varying the case expression there, it's Turing complete. I'm not certain how large an alphabet you need, but I think it's pretty small.
14:50:58 <monochrom> if a doctype uses a URL, it has to be a live URL. the client has choice of downloading or using client's cached copy.
14:51:10 <monochrom> actually cached copy is recommended
14:51:44 <monochrom> if the client caches, it is not too bad if the server goes down
14:52:16 <olsner> here I thought Cale had discovered a variant of collatz whatchamacallit that was turing complete, when I scroll back and see a plain old string rewriting system
14:52:19 <Cale> EvanR-work: Heh, "from haskell-cafe import ..."
14:52:23 <hpc> Cloudskell?
14:52:34 <hpc> Haskloud?
14:52:39 <Cale> olsner: It's just that 2-tag systems are Turing complete.
14:52:53 <Cale> olsner: and it's particularly easy to encode the Collatz problem as one
14:53:46 <Veinor> olsner: generalized collatz is undecidable
14:54:09 <EvanR-work> Claskeloud
14:54:25 <Veinor> for a certain definition of 'generalized'
14:55:33 <monochrom> "Cale Smith, 'The Collatz problem in unary logic notation'. Journal of Fringe Formal Logics, v 34 n 10, pp 5-26. October 2010."
14:56:15 <Veinor> more like Cale S. Kell
14:56:18 <Veinor> :D
14:57:37 <dmwit> Cale "skillz" Gibbard
14:57:53 <EvanR-work> lol
14:59:35 <BrianHV> hm... Either isn't a monad?
14:59:57 <dmwit> argh
14:59:59 <dmwit> sadly, no
15:00:03 <monochrom> because you don't know what to do if I say fail "haha"
15:00:19 <monochrom> well you can say Left blah, but what is blah?
15:00:24 <dmwit> However, if the first argument is an instance of Error (i.e. can be constructed from a String), then there's an instance.
15:00:38 <illissius`> monochrom: ah, i see
15:01:05 <BrianHV> there's an instance?
15:01:10 <dmwit> yes
15:01:14 * BrianHV is still getting used to the functional terminology
15:01:17 <monochrom> however, you can do instance Read x => Monad (Either x), so you can convert string to x.
15:01:49 <benmachine> IsString x
15:02:06 <EvanR-work> BrianHV: in oop objects are instances of a class, in haskell types are instances of a class
15:02:16 <dmwit> BrianHV: Well, for any a, Either a forms a monad in the theoretical sense. But in Haskell there's a mild constraint on a. Check Control.Monad.Instances to see more.
15:02:43 <benmachine> dmwit: you can just ignore fail
15:02:45 <benmachine> fail = error
15:03:00 <dmwit> You can, yes. But the standard library doesn't.
15:03:14 <EvanR-work> what would an Either monad do?
15:03:26 <hpc> the same thing a Maybe would
15:03:30 <dmwit> EvanR-work: Just like Maybe, but carrying around a bit of data for failures.
15:03:37 <hpc> only worse, if fail = error
15:03:49 <EvanR-work> ah
15:04:03 <EvanR-work> Left 'foo', the whole thing is Left 'foo'
15:04:08 <dmwit> yes
15:04:12 <BrianHV> so is there anything like Maybe that carries around a bit of data for failures? ;)
15:04:20 <dmwit> BrianHV: Yes, Either does this.
15:04:20 <hpc> haha
15:04:36 <EvanR-work> write your own monads for fun an profit
15:04:54 <BrianHV> dmwit: except that it's unlike Maybe because I can't use it in a nice-looking do-block
15:05:13 <dmwit> > return 3 :: Either String Int
15:05:13 <lambdabot>   Right 3
15:05:22 <BrianHV> wait, what now?
15:05:36 <dmwit> > do { x <- Right 3; y <- Left "die die die"; return (x, y) }
15:05:36 <lambdabot>   Left "die die die"
15:05:49 <hpc> > do {Left foo <- return $ Right 3} :: Either String Int
15:05:49 <BrianHV> my ghci disagrees with lambdabot
15:05:50 <lambdabot>   <no location info>:
15:05:50 <lambdabot>      The last statement in a 'do' construct must be an ...
15:05:56 <dmwit> BrianHV: :m + Control.Monad.Error
15:06:00 <hpc> > do {Left foo <- return $ Right 3 return foo} :: Either String Int
15:06:01 <lambdabot>   <no location info>:
15:06:01 <lambdabot>      The last statement in a 'do' construct must be an ...
15:06:11 <BrianHV> well, how about that
15:06:14 <hpc> > do {Left foo <- return $ Right 3; return foo} :: Either String Int -- third time's a charm
15:06:15 <lambdabot>   Left "Pattern match failure in do expression at <interactive>:1:141-144"
15:06:24 <BrianHV> thanks!
15:06:54 <EvanR-work> instances of Error what? can be constructed from a string? not the other way around?
15:06:55 <hpc> actually that's a type error... <.<
15:07:03 <dmwit> ?src Error
15:07:03 <lambdabot> class Error a where
15:07:03 <lambdabot>     noMsg  :: a
15:07:03 <lambdabot>     strMsg :: String -> a
15:07:08 <dmwit> EvanR-work: right
15:07:12 <hpc> er, no; it just barely avoided being one
15:07:28 <BrianHV> it's a shame that the PortMidi binding got Either backwards
15:07:29 <dmwit> EvanR-work: fail s = Left (strMsg s)
15:08:00 <EvanR-work> ok, so errors would like to have a type safe wrapper around the error message so you can tell classes of errors apart
15:08:19 <dmwit> yes
15:08:41 <EvanR-work> not that any real computation is done on the string to produce an 'error object' ;0
15:08:43 <EvanR-work> ;)
15:08:49 <EvanR-work> like parsing
15:09:11 <hpc> when is noMsg ever useful?
15:09:12 <dmwit> There's no reason it can't be.
15:09:30 <EvanR-work> an error with no explanation
15:09:34 <dmwit> That is, there's no reason strMsg can't parse the string.
15:09:52 <hpc> Left "WTF just happened?" :P
15:10:22 <EvanR-work> if its a tolerant parser, it would be meta-error-prone, and if it were strict, it would be annoying
15:10:36 <dmwit> class Read a => Error (Either a String) where ...
15:10:51 <EvanR-work> sometimes doesnt seem right about specifying data in string form
15:10:55 <dmwit> s/class/instance/ of course
15:11:05 <EvanR-work> something*
15:11:19 <EvanR-work> cant be checked at compile time
15:12:23 <EvanR-work> anti haskell propaganda: haskell has no fewer than 110 ways to handle errors, thats a lot.
15:13:00 <hpc> EvanR-work: 110 in what base?
15:13:05 <hpc> :D
15:13:07 <EvanR-work> lol
15:13:15 <EvanR-work> natural base
15:13:18 <dmwit> Yes, I find that annoying, as well.
15:13:26 <dmwit> And the number is still growing. =/
15:13:36 <dmwit> kinda like sound subsystems and Linux
15:13:46 <monochrom> > 1*exp 2 + 1*exp 1 + 0
15:13:47 <lambdabot>   10.107337927389695
15:13:47 <dmwit> Everybody says "man, there's too many of these -- let's make another".
15:13:51 <hpc> oh god, yes
15:13:54 <hpc> pick one and make it suck less
15:14:10 <medfly> what results in something like [a, f a, f (f a), ...] ?
15:14:13 <Adamant> dmwit: at least sound systems sometimes have truly different requirements
15:14:14 <EvanR-work> with linux its obvious, you could have done it right each time, and didnt
15:14:19 <dmwit> > iterate f a
15:14:20 <lambdabot>   [a,f a,f (f a),f (f (f a)),f (f (f (f a))),f (f (f (f (f a)))),f (f (f (f (...
15:14:20 <EvanR-work> i dont know about 'the right way to do errors'
15:14:24 <medfly> ok, thx
15:14:27 <medfly> @hoogle iterate
15:14:27 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
15:14:28 <Adamant> consumer, prosumer, and pro
15:14:28 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
15:14:28 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
15:15:23 <hpc> yay for ByteString and it's special contradictory implementations of half the prelude
15:15:29 <EvanR-work> Adamant: errors have different requirements
15:15:44 <Adamant> EvanR-work: to some degree
15:16:04 <hpc> exceptions at least, are hideous
15:16:08 <Adamant> I mean Either/Maybe vs. exceptions and all that.
15:16:21 <EvanR-work> IO vs IO-like in pure code
15:16:38 <EvanR-work> with pure code / monads, not
15:16:44 * EvanR-work goes insane
15:17:08 <EvanR-work> wtf is this spoon thing
15:17:24 <dmwit> spoon undefined = Nothing
15:17:34 <hpc> wait, what?
15:17:35 <dmwit> spoon x = Just x
15:17:41 <Adamant> EvanR-work: you've got to bend it with your mind by realizing there is no spoon
15:17:41 <EvanR-work> there is no spoon
15:17:50 <copumpkin> mmm
15:17:56 <dmwit> spoon (error s) = Nothing -- also
15:18:00 <copumpkin> EvanR-work: that's more or less where the name came from
15:18:04 <EvanR-work> its really you who are bending
15:18:09 <monochrom> no, bend the spoon with your mind
15:18:14 <copumpkin> omg spoon lets you pattern match on undefined and functions
15:18:33 <benmachine> omg
15:18:43 <monochrom> oms
15:18:44 <hpc> and comments! spoon {-probability of Cale making me a sandwich-} = 4
15:18:46 <EvanR-work> haskell gets weirder and weirder the deeper you go
15:19:19 <benmachine> hpc: four times certain?
15:19:34 <EvanR-work> copumpkin: does it accomplish this using pure code?
15:20:13 <hpc> benmachine: no, the parameter isn't related to the return value
15:21:55 <EvanR-work> > spoon undefined
15:21:56 <lambdabot>   Not in scope: `spoon'
15:22:16 <hpc> @let spoon = const Nothing
15:22:17 <lambdabot>  Defined.
15:22:38 <hpc> > spoon undefined
15:22:39 <lambdabot>   Nothing
15:22:42 <hpc> it works!
15:22:59 <EvanR-work> i like spoon
15:23:05 <EvanR-work> suddenly
15:23:23 <Adamant> @let TheTick = take 5 (iterate . spoon)
15:23:24 <lambdabot>  <local>:5:0: Not in scope: data constructor `TheTick'
15:23:29 <Adamant> oops
15:23:35 <rizlah> Does haskell compile to machine or bytecode? More specifically, Assuming I compile a Haskell application on this machine, it will run on any other machine with the same OS? Much like C.
15:23:55 <Adamant> @let thetick = take 5 (iterate . spoon)
15:23:56 <lambdabot>  <local>:5:28:
15:23:56 <lambdabot>      Couldn't match expected type `[a -> a]'
15:23:56 <lambdabot>             again...
15:23:56 <EvanR-work> ghc statically links a lot of crap into the binary
15:24:11 <EvanR-work> ldd the result to see what its dynamically linked again / needs to have on the target system
15:24:12 <monochrom> machine code
15:24:24 <EvanR-work> against*
15:24:32 <hpc> it compiles similarly to C
15:24:50 <hpc> if you compile a 64-bit binary, you can't run it on an older computer
15:24:58 <rizlah> So you won't need to have say, certain libraries on the target system unless you are expecting to use them? Much like C.
15:25:03 <hpc> nope
15:25:07 <rizlah> Good good.
15:25:12 <hpc> nor will you need a runtime like Java
15:25:29 <rizlah> So in theory, you could compile a Haskell application for an embedded system?
15:25:34 <hpc> indeed
15:25:41 <hpc> in fact
15:25:41 <rizlah> Grand.
15:25:45 <hpc> @google embedded haskell
15:25:45 <lambdabot> No Result Found.
15:25:54 <Adamant> are lambdabot's declarations per-user or general for the room?
15:26:01 <monochrom> some people did it to iPhone
15:26:15 <EvanR-work> spoon is strict?
15:26:22 <hpc> global until @undefine
15:26:46 <bss03> > spoon (error "foo")
15:26:47 <lambdabot>   Nothing
15:26:52 <bss03> > spoon 123
15:26:53 <lambdabot>   Nothing
15:26:54 <Adamant> rizlah: for REALLY embedded systems, there are languages embedded in Haskell designed for emitting to 8-bit procs to small ARM's
15:27:45 <conal> as well as generating code for gpus
15:27:51 <hpc> then there's Habit, which is intended for kernels
15:27:54 <mathijs> is there any "preferred" way of extending libraries? I used to put lots of simple utility functions in a personal library module, but it grows large and requires splitting.
15:28:15 <Adamant> I think some are in Hackage, one is named Atom, and a guy from a company that sounds something like Denton makes a lot of them and does a lot of design work in that space
15:28:32 <hpc> mathijs: just separate concerns until you are happy
15:28:39 <mathijs> can I go like "MyLib.Data.Maybe" and "MyLib.Network.HTTP" ?
15:28:46 <hpc> sure
15:28:57 <hpc> or even Data.Maybe.MyLib
15:29:05 <rizlah> So Haskell's speed would be somewhat on-par with other compiled languages?
15:29:22 <hpc> rizlah: faster, in a fair few cases
15:29:26 <EvanR-work> languages dont have speed
15:29:33 <EvanR-work> rules lawyer
15:29:36 <mathijs> yeah... so that's why I ask. is there any "default" way that seems to get used most? prefixing/postfixing MyLib ?
15:29:36 <pumpkin> it's faster than compiled brainfuck
15:30:05 <rizlah> hpc: So I assume that learning Haskell is a valid alternative to C.
15:30:16 <hpc> mathijs: it's usually extending from MyLib to MyLib.Foo
15:30:24 <hpc> with MyLib importing and exporting the sublibs
15:30:25 <Adamant> rizlah: it's in the ballpark of C/C++/Java, and by ballpark I mean it's faster than all but C commonly.
15:30:32 <Adamant> modern Java
15:30:37 <rizlah> I see
15:30:41 <hpc> "modern java" :D
15:30:47 <Adamant> rizlah: depends on what you want to do
15:30:54 <EvanR-work> if you use the same algorithms and data structures as C itll be like C
15:31:05 <EvanR-work> but you probably dont want to
15:31:10 <Adamant> hpc: I mean Java after the compiler geniuses have gotten loose on it :P
15:31:15 <mathijs> hpc: but in this case, I don't have control over MyLib. (for example Data.Maybe)
15:31:38 <tromp> i ported a java/c benchmark to haskell and it was 20-50 times slower:(
15:31:42 <Adamant> rizlah: for embedded and OS work you probably need to know C to interop
15:31:57 <megajosh2> tromp: Wow you're so doing it wrong
15:31:58 <mathijs> so I can extend that to Data.Maybe.MyExtensions or to MyExtensions.Data.Maybe
15:32:06 <Adamant> even if you do things in Haskell
15:32:13 <rizlah> Sure, but I've heard about a kernel written in Haskell. Will that have similar speeds as C/ASM?
15:32:14 <hpc> the latter, probably
15:32:16 <EvanR-work> Data.Maybe.Mathijs ;)
15:32:19 <bss03> I think learning Haskell first will make learning C a tortuous experience.
15:32:37 <pumpkin> preflex: seen TacticalGrace
15:32:37 <preflex>  TacticalGrace was last seen on #haskell 48 days, 20 hours, 50 minutes and 28 seconds ago, saying: kfish: sounds great!
15:32:37 <rizlah> I already know C fairly well. I'm looking for an alternative
15:32:41 <Adamant> rizlah: close enough, if you code in a optimized manner
15:32:48 <mathijs> ok thanks :)
15:32:59 <bss03> Then I would recommend Haskell.
15:33:09 <Adamant> for OS stuff you'd also have to be careful with the non-obvious problems from laziness
15:33:15 <megajosh2> In an ugly scary way? :C
15:33:16 <tromp> i dont see what im doing wrong though
15:33:31 <megajosh2> tromp: What's the code look like?
15:33:33 <bss03> It has a decent C/Haskell FFI, so you can already write the stuff is whatever language is most appropriate.
15:33:41 <tromp> http://www.cwi.nl/~tromp/c4/fhour.html
15:34:01 <BrianHV> I've come back to my problem from last week... if I have a couple of functions of type IO (Maybe a), I don't see a way to get the monad chaining effect out of the Maybe results from the IO actions
15:34:49 <bss03> mtl still doesn't maybe MaybeT?
15:35:27 <bss03> Cause IO (Maybe a) is similar to MaybeT IO a, IIRC.
15:36:14 <BrianHV> if MaybeT exists, I don't know how to use it...
15:36:54 <BrianHV> oh well.  what I have works, even if it's not as elegant as I'd like.
15:38:47 <rizlah> How well would a properly written HTTP server compare to one written in C?
15:39:11 <hpc> an HTTP server is not one single thing
15:39:22 <hpc> usually
15:39:35 <hpc> and "properly written" doesn't exclude C
15:40:13 <BONUS> BrianHV: or you can convert them to IO (Either e a) and use ErrorT IO a
15:40:28 <bss03> riz: 15.1k request per second on a 4 core machine, after tuning the Linux kernel.
15:40:44 <BONUS> even with MaybeT, usage is what you'd expect, except the type is a bit different and there's some newtype wrapping/unwrapping
15:40:47 <BrianHV> BONUS: interesting.  I'll see if I can figure that out.
15:41:07 <BrianHV> BONUS: you overestimate my ability to expect anything in haskell. ;)  I'm getting there though
15:41:15 <BONUS> haha
15:41:28 <tromp> it is usually possible to write haskell code competitive with c, but it often requires a lot of expertise and non-idiomatic code
15:41:43 <kmc> yeah
15:42:31 <kmc> you can write your whole program quickly and in clear idiomatic style
15:42:39 <kmc> then profile it
15:42:42 <kmc> then optimize the parts which need it
15:43:00 <kmc> and do automated testing of the optimized version against the reference implementation
15:43:28 <kmc> refactoring is easier in Haskell than in most languages
15:43:38 <winxordie> BONUS! Thank you for your haskell tutorial. It was a great introduction. ^^
15:43:42 <kmc> though also more necessary -- for example, when introducing monadic effects to your code
15:43:50 <BONUS> winxordie: you're welcome! thanks for reading!
15:44:33 <winxordie> it was great reading a year ago; it's also great propaganda for converting people to the pure side of the force now.
15:44:34 <hpc> do you have an ETA on the next section?
15:44:43 <bss03> let { f :: IO (Maybe Int); f = return $ return 1; g :: Int -> IO (Maybe Int); g n = return . return $ n + 1; } in {- h = -} do { m_v <- f; maybe (return Nothing) g m_v; }
15:44:43 <BONUS> hehe, cool
15:44:53 <bss03> > let { f :: IO (Maybe Int); f = return $ return 1; g :: Int -> IO (Maybe Int); g n = return . return $ n + 1; } in {- h = -} do { m_v <- f; maybe (return Nothing) g m_v; }
15:44:54 <lambdabot>   <IO (Maybe Int)>
15:45:21 <benmachine> bss03: sounds like a job for MaybeT!
15:45:58 <bss03> Yeah, trying to show BrianHV how to do it without MaybeT.
15:46:12 <benmachine> oic
15:46:25 <benmachine> sorry
15:46:27 <benmachine> not keeping up
15:46:29 <jmcarthur> tromp: what was the benchmark?
15:46:44 <jmcarthur> woops i was scrolled up
15:46:50 <hpc> you wouldn't even need to use maybe
15:47:04 <hpc> you can match on the inside of m_v and let fail drop you out
15:47:31 <bss03> BrianHV: Did you see the example code there.  Should work for a != Int as well.
15:48:02 <tromp> it solves connect-4 positions
15:48:14 <BrianHV> bss03: studying it now, thanks
15:48:24 <jmcarthur> haskell is also a great language for generating C from a DSL :)
15:48:28 <tromp> http://www.cwi.nl/~tromp/c4/fhour.html
15:48:46 <jmcarthur> tromp: yeah, thanks, i found the link from earlier since i discovered i was looking at backbuffer
15:50:25 <jmcarthur> tromp: so, i haven't looked at the code and probably won't because i don't really feel like getting into it right now, but is my guess that the algorithm searches a game tree?
15:50:37 <jmcarthur> *is my guess [...] correct?
15:50:38 <tromp> yes, alpha-beta search
15:50:40 <dmwit> Wow, that Haskell performance is abysmal.
15:50:42 <jmcarthur> ah
15:51:00 <pumpkin> lol haskle sux haha
15:51:43 <monochrom> what haskell performance?
15:51:55 <Adamant> it got a standing ovation for it!
15:52:01 <jmcarthur> tromp: i did some game tree search in haskell in an ai competition. it was in the same order of magnitude as the C++ bots. i don't know if i still have that one around though, because i eventually scrapped the whole thing and wrote a new bot with an entirely different algorithm that nobody else was really using, so i can't really compare my final bot with anything else for performance
15:52:07 <dmwit> monochrom: see tromp's link
15:52:12 <jmcarthur> it was alpha-beta as well, for the record
15:52:17 <monochrom> (just kidding)
15:52:29 <jmcarthur> it was *not* as fast as the C++ bots
15:52:33 <tromp> well, mine uses 64 bit bitboards
15:52:34 <jmcarthur> but not as far as yours
15:52:35 <dmwit> oh
15:52:57 <bss03> > @type {- With MaybeT it looks more like: -} let { f :: MaybeT IO a; f = undefined {- whatever -}; g :: a -> MaybeT IO b; g = undefined; } in {- h = -} f >>= g
15:52:58 <tromp> and just testing for a win was alrd 20+ times slower than java
15:52:58 <lambdabot>   <no location info>: parse error on input `@'
15:53:02 <bss03> @type {- With MaybeT it looks more like: -} let { f :: MaybeT IO a; f = undefined {- whatever -}; g :: a -> MaybeT IO b; g = undefined; } in {- h = -} f >>= g
15:53:03 <lambdabot>     Not in scope: type constructor or class `MaybeT'
15:53:04 <lambdabot>     Not in scope: type constructor or class `MaybeT'
15:53:14 <tromp> which takes just a few shifts and bitwise-ands
15:53:29 <BrianHV> bss03: perhaps I'm missing something... but that code doesn't seem to do the "short-circuiting" and the Right value unpacking I'm trying to figure out
15:53:41 <BrianHV> bss03: the non-MaybeT code I mean
15:54:39 <tromp> i just profiled my code under ghc 6.10.4 -o3
15:55:07 <tromp> it spends most time in one function:
15:55:09 <tromp>       isWon              Connect4                                             246   919153791  57.9   59.4    58.6   60.1
15:55:29 <bss03> BrianHV: g only gets executed if f results in a non-nothing value.
15:55:57 <bss03> Assuming I'm remembering my type signatures right, I'm still relatively new to this.
15:56:20 <bss03> @type maybe
15:56:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:56:36 <rizlah> Does haskell mind if whitespace is tabs or spaces?
15:56:56 <bss03> rizlah: The layout engine treats tabs as 8 spaces, IIRC.
15:57:05 <megajosh2> I don't think so, but it'd be probably better to just use spaces
15:57:12 <bss03> rizlah: I use tabs a lot, but I've heard others recommend against it.  It's never tripped me up.
15:57:20 <rizlah> Ah
15:57:27 <rizlah> megajosh2: So like, 2 spaces as an indent?
15:57:42 <monochrom> oh god, after overloaded string, we now face overloaded list in general!
15:57:44 <megajosh2> I use two or four depending on the size of the name I'm indenting near
15:57:53 <megajosh2> Sometimes 5
15:58:28 <monochrom> I indent by 2.0943951023931953
15:58:52 <BrianHV> bss03: oh, I think I see what you did.  I imagined a semicolon where there was none.
15:59:07 <dmwit> tromp: My profiling doesn't match. I get most of the time being spent in statsTT, with isWon coming in a distant second.
15:59:33 <rizlah> What is wrong with this source: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29787#a29787 ?
15:59:36 <bss03> BrainHV: I haven't figured out how to make IRC use the layout engine to make my code look good. :
15:59:37 <bss03> P
15:59:40 <rizlah> The module name matches the filename
15:59:48 <tromp> i changed the inputs file to have just the first two positions
15:59:52 * rizlah is starting to learn
15:59:55 <megajosh2> rizlah: Make the module name capitalized
15:59:57 <tromp> otherwise it would take forever
15:59:59 <rizlah> Ah
16:00:03 <monochrom> and filename too
16:00:06 <rizlah> Beginner error
16:00:09 <tromp> what did you run it on , dmwit?
16:00:19 <megajosh2> Oh, and you don't really need to indent the toplevel functions like that
16:00:21 <dmwit> inputs, but I didn't let it finish, so that may be the problem
16:00:24 <megajosh2> I think most people dont'
16:00:26 <megajosh2> *don't
16:00:40 <rizlah> megajosh2: Could you show me what you mean?
16:00:46 <tromp> statsTT should take almost no time
16:00:46 <megajosh2> One sec
16:01:00 <monochrom> yeah, I don't indent top-level things
16:01:29 <tromp> i have    statsTT               GameTreeSearch                                       279          22   1.0    0.9     1.8    1.5
16:01:29 <megajosh2> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29787#a29788
16:01:53 <tromp> only 1% of time
16:02:05 <dmwit> Let me run it to completion and see what it says.
16:02:13 <tromp> versus 58% in isWon
16:02:28 <BrianHV> so to use MaybeT on a function that's currently IO (Maybe a), do I have to wrap the current function so that it becomes MaybeT IO a?
16:02:55 <tromp> dmwit, completion could take hours
16:03:16 <tromp> dmwit just run the first two positions
16:03:56 <dmwit> tromp: Okay. My stats now roughly match yours: isWon seems to be doing about 50% of the allocation (and taking 50% of the time).
16:04:28 <rizlah> I see. Thanks megajosh2, the comment cleared things up
16:05:14 <megajosh2> Wow this is kind of weird... I think my IO actions are out of order
16:05:51 <rizlah> When I compiled a quick program, it left three things in my director. main.o, main.hi and main. I know the latter is the application and the first is the object file, but what is main.hi?
16:06:02 <kmc> an "interface file"
16:06:10 <kmc> it's produced for each module, alongside the .o file
16:06:21 <kmc> basically has everything ghc needs to import that module and use what's in it
16:06:27 <rizlah> kmc: Is it required to run the application?
16:06:30 <kmc> no
16:06:33 <rizlah> Ok
16:06:41 <dmwit> It's required for separate compilation.
16:07:07 <monochrom> oh god, while we're still talking about ghc 6.14 in the future, ghc 7.0 already rears its head!
16:07:17 <megajosh2> :O
16:08:02 <monochrom> SPJ says in glasgow-haskell-users: "I've spent most of the last month working on the new type checker, and unless there's a major hiccup it'll be in GHC 7.0.  We'll produce a release candidate just before ICFP."
16:08:18 <BONUS> GHC 7.0???? wowow
16:08:21 <megajosh2> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29789#a29789 I get weird results with this seemingly simple code
16:08:23 <monochrom> This is so surreal. This reminds me of Windows 7.
16:08:26 <dons> oh oh oh
16:08:35 <BONUS> will it be H98 based or H2010
16:08:42 <dons> funny. we just had a discussion in utrecht about what would happen to warrent a ghc 7
16:08:54 <BONUS> second coming of jesus
16:08:56 <tromp> how do i test if my ghc is 64 buts?
16:08:57 <dons> e.g. 4 -> 5 (ghci), 5 -> 6 (parallel runtime)
16:08:58 <tromp> bits
16:09:17 <megajosh2> New type checker...
16:10:07 <monochrom> megajosh2: merely buffering. insert «hFlush stdout». you have to import System.IO
16:10:25 <megajosh2> Ah, okay
16:10:29 <megajosh2> Thanks!
16:10:42 <megajosh2> I was just finding an excuse to use runhaskell
16:10:43 <rizlah> Is this the generally accepted way to lay out an if statement? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29790#a29790
16:11:00 <kmc> "if expression" not "if statement"
16:11:02 <rizlah> Looks quite strange to me, surely the else if should come under the if, not under the then
16:11:02 <kmc> and yeah it's fine
16:11:10 <kmc> however you might want to use "case" instea
16:11:14 <BONUS> dons: do you think something like node.js (evented async I/O library for javascript) might be worth doing in haskell?
16:11:15 <monochrom> it is one of many accepted ways.
16:11:18 <kmc> or in this case, guards
16:11:23 <BONUS> i've been wondering about that lately
16:11:39 <kmc> rizlah, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29790#a29791
16:11:42 <dons> BONUS: well, the Clean and Timber compilers have JavaScript backends, so you can write reactive web apps in Clean and Timber
16:11:51 <monochrom> do whatever you like as long as the parser doesn't misunderstand you
16:11:56 <dons> we should be able to do almost the same to get haskell apps
16:12:12 <kmc> node.js is server-side javascript
16:12:24 <pumpkin> BONUS: what would be the point?
16:12:35 <BONUS> yeah, i was thinking of replacing the javascript with haskell pretty much
16:12:37 <kmc> the Haskell approach seems to be threads + blocking IO, rather than event-based async
16:12:53 <rizlah> Is this also possible: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29792#a29792 ?
16:12:56 <kmc> it'd be nice to support both
16:13:10 <kmc> rizlah, it works here
16:13:14 <BONUS> kmc: yeah i don't know if it's an idea worth pursuing at all
16:13:16 <kmc> but won't work in every situation
16:13:25 <rizlah> Or do people not usually place if expressions like that? I'm trying to understand how haskell parses whitespace
16:13:30 <rizlah> kmc: Why might it not work?
16:13:39 <BONUS> is the overhead incurred from haskell threads enough to warrant an evented async i/o library
16:13:50 <kmc> rizlah, if you want to understand the whitespace rule, read http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
16:14:03 <BONUS> and even if it isn't, it would be nice to have something akin to the node.js API for easily writing servers
16:14:59 <rizlah> kmc: So you can use braces (I'm guessing curly ones {}) in haskell?
16:16:17 <copumpkin> BONUS: I agree there
16:20:32 <carter> has anyone pointed out in some discussion context how the new haddock layout seems to make it always look like the source link is part of the type?
16:31:06 <JoeyA> carter: you mean it sometimes looks like ByteString | Source ?
16:31:14 <carter> or 
16:31:26 <JoeyA> I didn't notice that until I tried to make my browser do it by expanding the font and shrinking the window.
16:31:30 <JoeyA> But it's not hard to reproduce.
16:31:37 <carter> JoeyA or something like OP: TYPE SIG SOURCE
16:31:53 <benmachine> carter: it's been mentioned in here before
16:31:54 <carter> and i was briefly trying to find the def of Source
16:32:00 <carter> and then i went
16:32:01 <carter> OHHHH
16:32:07 <benmachine> heh
16:32:10 <JoeyA> what page were you looking at?
16:32:16 <benmachine> it should probably go on the haskell-cafe thread
16:32:24 <carter> the Data.Tree
16:32:27 <carter> or intmap stuff
16:32:31 <carter> that bunch
16:32:37 <carter> which thread is talking about that?
16:32:51 <carter> 'cause i think theres several different haddock threads
16:33:52 <revenantphx> so, i'm wondering about the ST Monad
16:33:59 <revenantphx> where would I find a clear example/explanation?
16:35:11 <revenantphx> does it involve threads at all? I'm trying to work out how state could work on my own in my head.
16:35:32 <revenantphx> and my one thought was having a continuously running function on another thread (which could "keep alive" state)
16:36:46 <Saizan> the underlying implementation just uses mutable cells/arrays
16:36:52 <Saizan> no concurrency is involved
16:37:40 <megajosh2> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29793#a29793 Can anybody explain what's going on here? :/
16:37:50 <Saizan> though since all the references to those mutable things are nicely encapsulated via the 's' tag you can still get the result out without breaking referential transparency
16:38:21 <shachaf> megajosh2: You want to flush stdout *after* printing text to it.
16:38:27 <revenantphx> Saizan: that... made sense?
16:38:32 <shachaf> megajosh2: Which actually prints the text out to the screen.
16:38:32 <revenantphx> you're using words I don't know :P
16:38:38 <dmwit> revenantphx: Are you thinking of ST or STM?
16:38:42 <revenantphx> define: "referential transparency"
16:38:45 <revenantphx> dmwit: I don't know XD
16:39:03 <dmwit> revenantphx: Do you want efficient mutable state or composable multithreading?
16:39:04 <revenantphx> I'm thinking about state.
16:39:08 <dmwit> ST, then
16:39:09 <revenantphx> the former.
16:39:42 <shachaf> megajosh2: Alternatively, you can «hSetBuffering stdout NoBuffering» at the beginning of main to get rid of buffering completely.
16:40:15 <dmwit> The ST monad has an 's' type attached to each mote; e.g. ST s Bool.
16:40:39 <JoeyA> Bah, flushing errors.  I'm sure glad to be programming in Haskell and not having to worry about silly errors arising from incorrectly sequenced instructions.  Oh wait.
16:40:48 <dmwit> That 's' type isn't so important to *using* the ST library, but it is very important to *proving* that the library is safe.
16:40:54 <dmwit> That's all Saizan was saying.
16:40:57 * BrianHV got ErrorT working!
16:41:00 <Saizan> revenantphx: referential transparency simply means that in "let x = <body> in <e>" i could substitute <body> in place of all the occurrences of x in <e> and i'd get the same result, or equivalently that the output of a function depends only on its inputs
16:41:23 <revenantphx> ok I see.
16:41:32 <revenantphx> so basically "substitutability"
16:41:53 <Saizan> a property which doesn't hold for e.g. <-
16:42:06 <revenantphx> Right/
16:42:16 <shachaf> JoeyA: ...This is IO, an imperative sequenced programming language.
16:42:21 <revenantphx> since <- can connect with... the outside world.... 
16:42:33 <Saizan> that's not true
16:42:38 <revenantphx> Haskell seems to not be good friends with.... the outside world....
16:42:44 <revenantphx> the outside world is impure...
16:42:51 <megajosh2> It is EEEEEVILLL
16:42:54 <copumpkin> it puts on a hazard suit if it goes outside
16:43:00 <winxordie> I like the Descartian dualism.
16:43:01 <revenantphx> copumpkin: there we go.
16:43:13 <megajosh2> Haskell has agoraphobia
16:43:29 <JoeyA> Lazy IO seems to me like it's rife with all the things functional programmers think imperative languages are full of.
16:43:38 <JoeyA> unpredictability and whatnot
16:43:44 <Saizan> for a function to be referentially transparent it can't get additional information from a non-deterministic oracle behind the scenes
16:44:38 <Saizan> but it can still tell you to ask the oracle and plug the answer back into the computation :)
16:44:42 <JoeyA> (Lazy IO beyond merely reading from one source)
16:45:10 <revenantphx> Saizan: ... like the outside world...
16:45:14 <revenantphx> We should remove the outside world.
16:45:15 <monochrom> lazy I/O is not used extensively
16:45:17 <revenantphx> create a pure world.
16:45:22 <revenantphx> that exists only inside Haskell.
16:45:25 <revenantphx> Where no IO is needed.
16:45:29 <revenantphx> And then, we will be complete.
16:45:29 <megajosh2> This is starting to sound like that Land of Lisp comic
16:45:34 <megajosh2> I'm scared
16:45:35 <Saizan> why remove the outside world?
16:45:38 <monochrom> sometimes I write a toy program and I'm lazy and so I use lazy I/O, that's all.
16:45:47 <revenantphx> Saizan: with no outside world, we never have to use IO monads.
16:45:54 <revenantphx> We'll all be safe, as functions.
16:46:00 <revenantphx> We'll all be functions, you and I.
16:46:02 <Saizan> and why would i want to never use IO?
16:46:11 <revenantphx> Because there would be nothing to use it with.
16:46:17 <revenantphx> There would be nothing outside of the pure world.
16:46:20 <megajosh2> This is madness! MADNESS
16:46:23 <revenantphx> A perfect world.
16:46:27 <Saizan> it's hard to interact with my program if it doesn't do any I/O :)
16:46:34 <kulin> IO makes programs useful
16:46:47 <itsmonktastic> I'm sure all your computations involve interaction with the real world (cpus are pretty physical!)
16:47:17 <Saizan> yeah, i guess i could encode results in the heat generated by the cpu..
16:47:18 <bss03> Without IO, you don't need a CPU.
16:47:29 <bnonym> itsmonktastic: just in theory
16:47:30 <bss03> Your program would simply be a complex constant.
16:47:39 <dmwit> encode all IO in whether your computation halts or not
16:47:44 <dmwit> bam
16:47:50 <shachaf> itsmonktastic: Actually, it's VMs all the way down.
16:47:51 <Twey> Nonsense!  How else am I going to keep my house warm in Winter?
16:47:52 <revenantphx> Saizan, you will BE the program.
16:48:07 * revenantphx sets off to remove the real world from existance.
16:48:11 <Twey> Hehe
16:48:14 <monochrom> Donald Knuth did encode results in the tones generated by the cpu.
16:48:15 * revenantphx to create a universe that runs in haskell.
16:48:27 <Twey> monochrom: Really?
16:48:27 <revenantphx> and with is itself, haskell.
16:48:34 <revenantphx> So there is no need for a computer on which it will run.
16:48:37 <monochrom> He wrote programs to get the cpu play music.
16:48:38 <revenantphx> It will run on itself.
16:48:42 <Twey> Awesome.
16:48:43 <revenantphx> using beeps?
16:48:47 <Twey> No, the CPU.
16:48:50 <revenantphx> 0.o
16:48:53 <revenantphx> jesus.
16:49:02 <Twey> monochrom: Link us?
16:49:10 <monochrom> I read it in a book.
16:49:13 <Twey> Aw.
16:49:15 <revenantphx> monochrom: Will you help me...?
16:49:24 <revenantphx> Help me create a world with no impurity... with no "reality"
16:49:26 <lispy1> How does a CPU generate tones?
16:49:31 <revenantphx> Where there is only Haskell.
16:49:41 <kulin> haskell is not the best thing ever, its a tool
16:49:57 <JoeyA> What's an efficient way to sort a lot of items in Haskell?  For instance, sum $ sort (takeWhile (> 0) $ iterate (subtract 1) 10000000 :: [Int])
16:49:58 <revenantphx> The best thing ever is horseradish with steak.
16:50:05 <bss03> As electricty moves though it imperfect conductors it causes vibrations.
16:50:08 <revenantphx> And cayenne with peppers.
16:50:08 <JoeyA> For merely sorting 10 million items, it's not very efficient.
16:50:14 <benmachine> hmm, no ssize_t in Foreign.C.Types?
16:50:18 <bss03> These vibrations are well beyond the hearing of humans.
16:50:21 <JoeyA> It takes a really long time, and it uses 1 GB of RAM.
16:50:24 <revenantphx> amplified however...
16:50:32 <JoeyA> (and I think it stack overflows if not optimized enough)
16:50:44 <revenantphx> JoeyA: ...quicksort :P
16:50:56 <dmwit> > sort [10000000, 9999999 ..]
16:50:58 <bss03> sort is a quicksort, IIRC.
16:51:02 <lambdabot>   mueval: ExitFailure 1
16:51:02 <dmwit> sort is mergesort
16:51:17 <dmwit> (in GHC, anyway)
16:51:20 <revenantphx> @let qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
16:51:20 <JoeyA> Not anymore.
16:51:24 <lambdabot>  Defined.
16:51:29 <JoeyA> (as of ... 2002)
16:51:30 <JoeyA> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-List.html#sort
16:51:32 <Saizan> JoeyA: try foldl' (+) 0 instead of sum
16:51:38 <dmwit> > sort [10000000, 9999999 .. 0]
16:51:41 <JoeyA> Quicksort replaced by mergesort, 14/5/2002.
16:51:43 <lambdabot>   mueval: ExitFailure 1
16:51:44 <Twey> JoeyA: That's because you're sorting a million items.
16:51:48 <JoeyA> Saizan: That's not sorting :-)
16:51:52 <Twey> It's going to be slow.
16:51:55 <JoeyA> That's 10 million items
16:52:09 <Saizan> JoeyA: but you're doing a sum of the sorted items there, no?
16:52:12 <revenantphx> @let qsort [] = []
16:52:13 <lambdabot>  Defined.
16:52:16 <dmwit> JoeyA: The sorting doesn't actually take that long here. 1-2s or so
16:52:23 <Cale> sort is a mergesort
16:52:36 <Cale> ah, this has already been pointed out :)
16:52:37 <JoeyA> Gotta do something with the result :-)
16:52:40 <revenantphx> > qsort [1,4,4,2,4,5,6,8,3,2,3,4,5,7,8,4,3,4,6,7,8,1,1,2,1,1,1,11,5,6,8,8,9,5,3,2,4,5]
16:52:44 <lambdabot>   mueval-core: Time limit exceeded
16:52:47 <revenantphx> > >
16:52:48 <megajosh2> Hmm...
16:52:48 <lambdabot>   <no location info>: parse error on input `>'
16:52:51 <dmwit> JoeyA: I printed the result.
16:52:55 <revenantphx> qsort [1,4,4,2,4,5,6,8,3,2,3,4,5]
16:52:57 <Saizan> JoeyA: yeah, what i'm saying is that the sum might be the culprit there
16:53:00 <Cale> @undefine
16:53:15 <revenantphx> D:
16:53:19 <revenantphx> > print "hi"
16:53:20 <lambdabot>   <IO ()>
16:53:25 <JoeyA> I wonder if it would be more efficient to implement a sort that builds a giant vector, quicksorts it, and reads it back into a list.
16:53:26 <revenantphx> > putStrLn "hi"
16:53:27 <lambdabot>   <IO ()>
16:53:29 <revenantphx>  > >
16:53:32 <Cale> @let qsort [] = []; qsort (x:xs) = qsort less ++ x : qsort greater where (less,greater) = partition (< x) xs
16:53:33 <lambdabot>  Defined.
16:53:39 <Cale> > qsort [1,4,4,2,4,5,6,8,3,2,3,4,5,7,8,4,3,4,6,7,8,1,1,2,1,1,1,11,5,6,8,8,9,5,3,2,4,5]
16:53:40 <lambdabot>   [1,1,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,6,6,6,7,7,8,8,8,8,8,9,...
16:54:08 <JoeyA> And let the magic of list fusion allow me to use the array like a list.
16:54:08 <revenantphx> qsort [0,1..100000000000000000]
16:54:13 <revenantphx> > qsort [0,1..100000000000000000]
16:54:15 <dmwit> JoeyA: You're welcome to try it. I recommend checking out STArray.
16:54:18 <lambdabot>   mueval: ExitFailure 1
16:54:25 <revenantphx> crap it broke
16:54:29 <revenantphx> > print "hi"
16:54:32 <lambdabot>   <IO ()>
16:54:33 <revenantphx> okay, he's still alive.
16:54:40 <dmwit> she
16:54:42 <Cale> The nice thing about the actual sort function is that taking the head of the resulting list is O(n)
16:54:43 <revenantphx> she
16:54:45 <revenantphx> > qsort [0, 1... 1000]
16:54:46 <lambdabot>   Not in scope: `...'
16:54:53 <revenantphx> qsort [0, 1.. 1000]
16:55:09 <revenantphx> > qsort [0, 1.. 1000]
16:55:10 <bss03> You should probably optimize out one of the (++) calls.  [x] ++ y = x : y, you know.
16:55:11 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:55:40 <dmwit> take k (sort xs) is O(length xs * log k), I guess
16:55:54 <revenantphx> > take 4 $ reverse . qsort [0, 1.. 100000]
16:55:55 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
16:55:56 <lambdabot>    arising from a use...
16:55:56 <Cale> dmwit: I think that's right
16:56:07 <benmachine> bss03: probably not a big deal, it'll be inlined I'd've thought
16:56:09 <revenantphx> take 4 $ reverse $ qsort [0, 1.. 100000]
16:56:13 <revenantphx> bleh
16:56:23 <bss03> benmachine: Yeah, the compiler probably does that for you.
16:56:43 <bss03> > take 4 . reverse $ qsort [0, 1.. 100000]
16:56:47 <lambdabot>   mueval-core: Time limit exceeded
16:57:07 <bss03> > take 4 $ qsort [0, 1.. 100000]
16:57:08 <lambdabot>   [0,1,2,3]
16:57:10 <dmwit> That's not really quicksort, anyway.
16:57:17 <benmachine> > take 4 . reverse $ [0, 1 .. 100000]
16:57:18 <lambdabot>   [100000,99999,99998,99997]
16:57:31 <duckinator> hi
16:58:02 <dmwit> howdy
16:58:14 <BrianHV> is there anything crazy about this code?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29794#a29794  (m2e and pmEither are just wrappers that make sure a sensible Either is being used.)
16:59:20 <dmwit> No, not crazy.
16:59:47 <dmwit> Two things seem a bit odd: 1. you haven't got top-level ErrorT definitions for the various things you're calling 2. you runErrorT
17:00:32 <BrianHV> for 1, does that mean I have to wrap everything I want to call?
17:00:39 <byorgey> seems perfectly sensible to me, using adapters to fit existing functions into a particular monad, then running it locally
17:00:51 <dmwit> You don't have to, of course.
17:00:55 <byorgey> but I would include the ErrorT wrappers in the definition of m2e and pmEither
17:01:14 <BrianHV> byorgey: oh, that's a good idea
17:01:23 <byorgey> I would also align all the <-   ;)
17:01:33 <BrianHV> :)
17:02:00 <BrianHV> as for 2, I couldn't figure out a way to do that without runErrorT...
17:02:46 <byorgey> well, the type of getMidiStreams could just be ErrorT String IO (PMStream, PMStream)
17:02:56 <dmwit> right
17:03:01 <BrianHV> hmmm
17:03:20 <byorgey> which is nicer if you want to combine it with other things that might fail with error messages...
17:04:00 <BrianHV> indeed, I like that better.
17:04:15 <JoeyA> Is there a way to call a Haskell function from C?
17:04:23 <byorgey> JoeyA: yes.
17:04:32 <byorgey> don't ask me how to do it though.
17:04:47 <byorgey> look into the FFI.
17:05:50 <bss03> The FFI should let you export the Haskell function, but the types need to all be FFI-compatible.
17:06:08 <JoeyA> ah
17:06:30 <bss03> Of course, I've not doen it either, so I'm not sure about all the glue steps.  Like if GHC geneates a .h you need to include in the C program or what.
17:06:35 <benmachine> and you need to initialise the haskell runtime and stuff
17:07:50 <JoeyA> Let's take it up another notch:  I wonder if it's possible to call a Haskell _closure_ from C?
17:08:22 <JoeyA> I'm just thinking about if it's possible to implement a sortBy that uses C's qsort.
17:08:43 <lispy1> why would you use C's qsort
17:09:13 <bss03> You can only call things you export, but it certainly could be a closure, FWIU.
17:09:24 <Pseudonym> C's qsort is almost always the wrong thing.
17:09:37 <benmachine> I don't think you could export a lambda?
17:09:48 <lispy1> C's qsort isn't stable for one thing.
17:10:10 <Pseudonym> lispy: Not always a necessary feature.
17:10:25 <lispy1> JoeyA: hackage has an external merge sort
17:10:30 <bss03> benmachine: I don't see why not.  f n x = stuff is the same as f = \n -> \x -> stuff.
17:10:55 <bss03> sortBy take a comparision function, and qsort isn't a comparision function.
17:10:57 <benmachine> bss03: you can only export names, though
17:11:02 <lispy1> JoeyA: and it has this: http://hackage.haskell.org/packages/archive/uvector-algorithms/0.2/doc/html/Data-Array-Vector-Algorithms-Radix.html
17:11:04 <bss03> qsort requires a comparision function.
17:11:19 <bss03> benmachine: Yeah, you'd have to give your closure a name.
17:11:52 <bss03> benmachine: That doesn't mean it isn't a closure.  Like you could have a fib function that does memoization behind the scenes.
17:12:11 <itsmonktastic> So I'm having a look at GADTs and was stuck with this SafeList example. safeHead made sense to me, but my attempt to write a safeTail function doesn't work as my type constraints aren't right. Anyone know how I could fix this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29795#a29795
17:12:13 <lispy1> JoeyA: I spoke too soon, this is the prefered version: http://hackage.haskell.org/packages/archive/vector-algorithms/0.3.2/doc/html/Data-Vector-Algorithms-Intro.html
17:12:19 <lispy1> the other thing is now deprecated
17:12:45 <bss03> I don't think it is possbile to pass something with a function type across the FFI, if that's what you are asking.
17:13:10 <bss03> Like taking a CInt -> IO CInt and passing it to a C function that take a int (*)(int).
17:13:25 <lispy1> itsmonktastic: I tihnk you need to look at xs and have 2 equations.  1 for when xs is Nil and one for when xs is non-nill
17:13:28 <bss03> It might be possible though, I'm just not sure.
17:13:46 <benmachine> you can funptr-ise haskell functions, I think
17:14:22 <bss03> benmachine: That's be awesome, but I haven't delved into that part of the FFI at all.
17:14:39 <bss03> @type safeTail
17:14:42 <lambdabot> Not in scope: `safeTail'
17:14:44 <byorgey> itsmonktastic: the problem is that your type signature for safeTail promises that it can return a SafeList with *any type index you want*
17:15:10 <bss03> @let safeTail [] = Nothing; safeTail (x:xs) = xs;
17:15:11 <lambdabot>  <local>:2:41:
17:15:11 <lambdabot>      Couldn't match expected type `Maybe a' against inferred t...
17:15:12 <byorgey> itsmonktastic: but clearly this is not true, it will return one with whatever particular index happened to be on the list inside the cons
17:15:19 <bss03> @let safeTail [] = Nothing; safeTail (x:xs) = Just xs;
17:15:20 <lambdabot>  Defined.
17:15:25 <bss03> @type safeTail
17:15:26 <lambdabot> forall t. [t] -> Maybe [t]
17:15:32 <bss03> > safeTail []
17:15:32 <lambdabot>   Nothing
17:15:36 <itsmonktastic> bss03: that's not what I'm trying to achieve
17:15:38 <bss03> > safeTail [1..4]
17:15:39 <lambdabot>   Just [2,3,4]
17:15:59 <bss03> Are you trying to do safeLast?
17:16:12 <byorgey> bss03: itsmonktastic is learning about GADTs.
17:16:57 <itsmonktastic> bss03: Look at safeHead. It can't actually receive an empty list
17:16:59 <itsmonktastic> statically
17:17:12 <bss03> Ah, the whole issue where the caller determines the binding for any ubound type variables in the return value?
17:17:13 <lispy1> byorgey: oh, that's a good point.  I was focused on the problem of type refinement for what b should be, but yeah the way the signature works now, that's funky with the b being whatever the caller wants
17:17:40 <byorgey> in fact there's no type signature for safeTail that will work. 
17:18:01 <byorgey> fundamentally the problem is that the type index on the list inside the Cons has been existentially quantified.
17:18:24 <byorgey> so the only possible thing to return from safeTail is an existential wrapper.  but I think this is the correct thing to do.
17:18:55 <byorgey> make an existential wrapper, data SomeList a where  SomeList :: SafeList a b -> SomeList a
17:19:11 <byorgey> 'SomeList a' is a list but you don't know whether it is empty or not
17:19:41 <JoeyA> oh, here's an example of where the Source link isn't being styled properly:  http://hackage.haskell.org/packages/archive/vector/0.6.0.2/doc/html/Data-Vector-Unboxed.html#7
17:19:44 <byorgey> so  safeTail :: SafeList a NonEmpty -> SomeList a
17:19:51 <itsmonktastic> byorgey: Okay, thanks a lot :)
17:20:03 <JoeyA> It should look like:  http://hackage.haskell.org/packages/archive/cryptohash/0.5.2/doc/html/Data-CryptoHash-SHA1.html
17:20:08 <byorgey> which should make sense: if all you know about a list is that it is nonempty, you don't know whether removing an element will result in an empty or a nonempty list
17:20:20 <itsmonktastic> yeah
17:20:21 <magicman> So... 'SomeList a' is just [a]?
17:20:45 <byorgey> magicman: yes, but with more angst
17:20:52 <byorgey> since you used to know something else about it but now you forgot
17:21:19 <itsmonktastic> I think I might need a bit more practise at type level programming. xD
17:22:05 <lispy1> byorgey: you could  check if it's now empty by doing a pattern match on the remaining cons
17:22:26 <dmwit> Man, that is a great quote.
17:22:52 <lispy1> dmwit: ?
17:23:01 <byorgey> lispy1: sure, but you can no longer reflect what you learn in the type index
17:23:09 <byorgey> that would require dependent types.
17:23:36 <dmwit> lispy1: more angst, know something else but forgot, etc.
17:23:46 <byorgey> dmwit: hehe, thanks =)
17:23:54 <magicman> And even then... I don't think I could write a safeTail in Agda, with a SafeList defined as it is now.
17:24:21 <magicman> Though... no, wait.
17:24:25 <lispy1> byorgey: hmm..even if you put Empty and NonEmpty into a type class and added a type class constaint on b?
17:24:48 <magicman> Right. Some type-function that depends on the input value and does the pattern-match *for* you. Kinda ugly, though :P
17:25:17 <dmwit> Pierce's Conjecture: forall x, x is possible with typeclasses
17:25:38 <byorgey> magicman: right.  and this is the point where you decide to move all the way to length-indexed lists, because it's actually simpler =)
17:25:47 <itsmonktastic> :D
17:26:15 <itsmonktastic> wait, length indexed at a type level?
17:26:24 <dmwit> It's all the same in Agda.
17:26:36 <byorgey> not to be confused with Peirce's Law, ((P -> Q) -> P) -> P
17:28:24 <byorgey> itsmonktastic: type-level length-indexed lists makes a nice exercise in Haskell too, although it's not as nice as in Agda
17:28:41 <itsmonktastic> interesting, thanks
17:29:21 <benmachine> I made type-level length-indexed lists in haskell once but couldn't actually work out how to do anything with them
17:30:00 <Eduard_Munteanu> I guess the fun is doing it without dependent types.
17:30:06 <benmachine> total head and total tail, woo
17:30:25 <benmachine> and (++) :: List a n -> List a m -> List a (Add n m)
17:30:50 <benmachine> but you can't sensibly do functions like take or drop
17:31:31 <magicman> take :: n -> List a (Add n m) -> List a m
17:31:34 <magicman> I wonder if that'd work...
17:31:49 <magicman> Wait, no.
17:31:52 <magicman> That's the sig for drop.
17:32:11 <magicman> take would be similar...
17:32:34 <bss03> s/a m/a n/
17:33:05 <magicman> Probably needs some constraint that means "Yes, the 'n' is actually a type-leve number".
17:33:21 <magicman> On the other hand, it gets enforced by the type family and the GADT, so maybe not.
17:33:56 <benmachine> magicman: in order to write take and drop you'd need information to go from the value-level to the type-level
17:34:06 <magicman> With Int, yes.
17:34:20 <benmachine> well sure you could write take and drop that operated on type-level naturals
17:34:24 <Eduard_Munteanu> Yikes, did that once, it had to have rank-2 types.
17:34:29 <benmachine> but what good would it do you exactly :P
17:34:33 <magicman> Fair enough.
17:34:59 <Eduard_Munteanu> I mean converting from type-level into value-level and reverse.
17:35:07 <benmachine> hmm I wonder in how many uses of take/drop are the taking/dropping amounts known at compile-time
17:35:17 <dmwit> Many, but definitely not all.
17:35:25 <magicman> type to value can be done with typeclasses.
17:35:32 <magicman> value to type is a tricky one.
17:35:49 <Eduard_Munteanu> magicman: yes, one of them was definitely easier.
17:36:11 <magicman> Might need a class TypeInt n where {toType :: Int -> Maybe n}
17:36:14 <benmachine> value-to-type doesn't really make sense when you consider types don't exist at runtime
17:36:29 <magicman> But then you're stuck with Maybe, so yeah, doesn't make sense.
17:36:55 <Eduard_Munteanu> magicman: yup, looked it up, my toPeano (meaning from values) had to have tricky existentials.
17:37:03 <Eduard_Munteanu> Erm, rank-2 types.
17:37:16 <magicman> *shudder*
17:37:57 <Eduard_Munteanu> benmachine: if you think of it in terms of compile-time computations, then they do.
17:38:40 * magicman considers writing "filter" for those length-annotated lists, but gives up.
17:38:45 <benmachine> Eduard_Munteanu: well sure, but values can be determined at runtime
17:39:55 <Eduard_Munteanu> To be honest, I'm really not sure how/if my valueToPeano worked with runtime data, though IIRC it did.
17:39:56 <monochrom> onoes, hackage haddock pages now have the full shebang of slide-out synopsis!
17:40:29 <lispy1> the new hackage is nice, but it keeps putting "Source" in to type signatures
17:40:35 <lispy1> But there is no Source type :(
17:40:39 <Eduard_Munteanu> It probably makes sense if I get to expand those definitions by hand.
17:40:56 <monochrom> it is now fixed.
17:41:10 <monochrom> example: http://hackage.haskell.org/packages/archive/haskell-src/1.0.1.3/doc/html/Language-Haskell-Pretty.html
17:41:53 <Eduard_Munteanu> Ah, one thing about this new Hackage... I liked the blue hyperlinks from the old one. That orange is a bit tougher to see.
17:42:01 <Eduard_Munteanu> Other than that, kudos.
17:42:16 <monochrom> so it seems haskell-src-exts is preferred to haskell-src. haskell-src isn't even updated to depend on base-4
17:42:29 <revenantphx> I know right.
17:43:48 <Cale> I don't mind the orange, but I do think it's a little too light.
17:44:21 <monochrom> ho hum, haskell-src already comes with haskell platform, good enough for me :)
17:45:38 <Cale> If it was either more saturated, or just darker, it would be easier to read.
17:46:50 <monochrom> if it's darker, it becomes brown not orange :)
17:47:20 <Cale> For example, #b62c00 is a good deal nicer to read
17:47:43 <Cale> Well, yes, dark orange is brown
17:48:50 <monochrom> alright, I concur
17:50:08 <Eduard_Munteanu> Yeah, should be better.
17:51:39 <Eduard_Munteanu> Also, I'm not sure if the 'Source' links are visible enough, though that's not a problem if you used Haddock before.
17:52:01 <revenantphx> I personally like FF8800 as a color.
17:52:14 <revenantphx> in terms of oranges
17:52:19 <revenantphx> FFB100 is pretty too though.
17:52:35 <monochrom> My favourite orange is #000000
17:52:42 <monochrom> My favourite blue, too.
17:52:49 <revenantphx> and cyan?
17:53:15 <Eduard_Munteanu> monochrom: that does go well with your nick, I have to admit :)
18:04:45 <benmachine> does anyone have any experience with using getErrno?
18:05:03 <benmachine> it seems to me it would struggle to be useful in a threaded environment
18:05:35 <tommd> benmachine: Correct.
18:06:01 <tommd> benmachine: I had a blog on this type of issue.  Damned c libs and their use of static buffers.
18:06:07 <benmachine> tommd: so I basically have to wrap every C function from which I want reliable error reporting?
18:06:20 <benmachine> or is it worse than that, even
18:06:36 <tommd> benmachine: If you have multiple Haskell threads per OS thread, then yes.
18:06:43 <benmachine> siiigh
18:06:51 <tommd> If you can be sure your haskell thread won't share OS threads you're ok
18:06:51 <dmwit> Haddock is dropping backquotes here. http://hackage.haskell.org/packages/archive/reactive/0.11.5/doc/html/FRP-Reactive.html#4
18:06:56 <dmwit> Is it supposed to do that? =/
18:06:56 * benmachine just goes fuckit return Maybe
18:07:41 <tommd> There was actually a nano-md5 bug due to static buffers too.
18:08:00 <tommd> You could get a hash result that was part one hash and then part of the next.
18:15:23 <benmachine> neat
18:18:58 <tommd> not really
18:19:02 <benmachine> :P
18:24:42 <JoeyA> For some reason, constructing an unboxed vector from a list manually and sorting it is faster than using apply sort . fromList
18:25:12 <JoeyA> This is fast (4 seconds on my comp):  http://codepad.org/QvfL65eu
18:26:01 <JoeyA> This is not fast:  http://codepad.org/FVb35QE7
18:27:04 <JoeyA> (takes 1 minute 5 seconds)
18:28:35 <JoeyA> So the fastest, generic (sort of) way I know of to sort a list of 10 million items is to sort them into a Vector and just use the vector:  http://codepad.org/QvfL65eu
18:28:47 <JoeyA> (well, read them into a vector and then qsort)
18:29:52 <JoeyA> hmm, I wonder if it's possible to mergesort from a list into a vector without needing a temporary buffer.
18:30:11 <dmwit> list = [10000000, 9999999 .. 1]
18:30:36 <dmwit> list = (\x -> [x, x-1, .. 1]) 10000000 -- if you don't want to repeat the 10 million
18:30:37 <JoeyA> d'oh!
18:30:45 <JoeyA> didn't think of that
18:30:46 <dmwit> Shouldn't change the performance, of course.
18:31:19 <JoeyA> By the way, making it a boxed instead of unboxed vector kills the performance (makes it take a minute instead of 4 seconds)
18:36:40 <benmachine> ugh I have to wrap readdir anyway because it's stupid and non-threadsafe
18:37:08 <dankna> yeah :(
18:37:16 <benmachine> unless I can call offsetof and pathconf from haskell, maybe
18:37:30 <dankna> I thought there was a threadsafe version of it
18:37:41 <dankna> but I don't remember the name
18:37:47 <benmachine> there's readdir_r yes but I need to allocate based on offsetof and pathconf in order to use it
18:37:50 <dankna> possibly readdir_r?
18:37:51 <dankna> ah
18:38:16 <benmachine> which means I need to carry around the path as well
18:38:33 <benmachine> why is C API design so stupid :|
18:38:46 <dankna> it just is
18:39:41 <benmachine> I can't actually carry around the path *and* support openDirFd
18:39:47 <dankna> hrm
18:39:48 <dankna> ugh
18:40:32 <benmachine> unless you can get paths from an fd but I don't think that even makes sense
18:40:44 * benmachine just drops openDirFd because who would use that anyway
18:41:05 <dmwit> Anybody familiar with Reactive? Is reactive-glut doing polling for its events?
18:42:20 <dmwit> That is my reading of it, but I'm not convinced I really understand it yet.
18:42:44 <nniro> is the pattern matching style (x:xs) hardcoded or I can also implement it for a data/type of my own?
18:42:58 <dmwit> It's hardcoded.
18:43:09 <dmwit> However, you can define your own infix data constructors.
18:43:15 <dmwit> They need merely begin with a :.
18:43:19 <applicative> nniro, : is the constructor of lists, with[]
18:43:24 <dmwit> data Foo a = a :+ Int -- for example
18:43:33 <dmwit> then
18:43:41 <nniro> dmwit: yeah that's what I did
18:43:43 <dmwit> foo (x :+ n) = n
18:43:47 <dmwit> or whatever
18:44:05 * applicative is trying to think of a lib with good examples of this.
18:44:11 <nniro> it absolutely needs to start with : ?
18:44:18 <dmwit> Yes.
18:44:19 <applicative> yes
18:44:23 <nniro> ah ok let me try :D
18:44:26 <applicative> @quote fugue
18:44:26 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
18:44:41 <dmwit> The other option is to start with an uppercase letter, but then it will be prefix, not infix.
18:44:51 <dmwit> You can still use it infix using backticks.
18:46:23 <nniro> hmm I implemented the function as (:!)  but it says it has an invalid type signature
18:46:57 <JoeyA> "<benmachine> why is C API design so stupid :|" You ain't seen nothing if you haven't seen getcwd.  This is one of my favorite comments:  http://ccan.ozlabs.org/browse/tools/tools.c#l-44
18:47:26 <dmwit> nniro: You may not call a function anything beginning with a colon.
18:47:29 <JoeyA>  /* *This* is why people hate C. */ -- commenting on how you have to use trial and error with the buffer size you pass to the getcwd function.
18:47:35 <dmwit> nniro: Only data constructors can start with a colon.
18:47:54 <JoeyA> readlink is similar.
18:48:24 <benmachine> JoeyA: but here I don't even have that option!
18:48:30 <nniro> dmwit: ah but my data construction needs to have 5 Ints so I can't really do it like that -_-
18:48:40 <applicative> nniro I just compiled: data Blah a b = a :! b  
18:48:42 <benmachine> I just have to sort of guess :|
18:48:59 <JoeyA> By the way, why do you have to wrap readdir?
18:49:00 <benmachine> well no that's not quite true
18:49:07 <benmachine> oh I don't really
18:49:11 <benmachine> just thought it might be nice
18:49:11 <applicative> nniro, when I ask ghci *Main> :t 'a' :! "haha"  it says, 'a' :! "haha" :: Blah Char [Char]
18:49:13 <JoeyA> oh
18:49:27 <benmachine> System.Directory's directory reading stuff annoys me by being lazy
18:49:32 <JoeyA> oh
18:49:39 <benmachine> and not bytestring
18:49:39 <JoeyA> I don't think it is lazy...
18:49:53 <benmachine> well, not bytestring anyway :P
18:50:07 <JoeyA> oh
18:50:09 <dmwit> nniro: You're right, infix constructors can probably only take exactly two arguments.
18:50:18 <applicative> nniro, oh, i didn't see the five fields.  you'd have to make a tuple or two of some of them.  The infix things take two arguments.
18:50:57 <nniro> let me paste the constructor and my fake (:) function
18:50:57 <dmwit> oh no!
18:51:00 <dmwit> nniro: you can
18:51:06 <dmwit> data Foo = (:!) Int Int Int Int Int
18:51:20 <applicative> oh, wow
18:51:26 <nniro> dmwit: ah nice
18:51:36 <benmachine> hmm, I thought getDirectoryContents was lazy but I can't back that up, now
18:51:37 <dmwit> but it's hardly better than a prefix constructor
18:51:42 <dmwit> You must pattern match the same way.
18:51:48 <dmwit> e.g. foo ((:!) a b c d e)
18:52:15 <benmachine> apparently it isn't!
18:52:24 <nniro> dmwit: let me try it
18:53:17 <benmachine> oh heh, readdir does have a binding
18:53:23 <benmachine> it's in System.Posix >_>
18:53:34 <applicative> hm, yeah, i get *Main> :t (5 :!! 5)  yielding (5 :!! 5) :: Int -> Int -> Int -> Foo  but there are subtleties.  
18:53:35 <benmachine> still want my bytestrings though
18:54:06 <dmwit> 5 :!! 5 $ 5 $ 5 $ 5
18:54:08 <applicative> can nniro make 5 :! 5 5 5 5  make sense? 
18:54:12 <applicative> oh, check
18:54:46 <lucca> :t (:!)
18:54:47 <lambdabot> Not in scope: data constructor `:!'
18:55:19 <dmwit> heh
18:55:23 <applicative> lucca, nniro has just made it up.  
18:55:30 <dmwit> the derived show instance uses a prefix constructor, too =)
18:55:42 <benmachine> System.Posix never exports quite enough >:|
18:56:39 <dmwit> Anyway, yeah, infix constructors best used with exactly two arguments. =)
18:57:05 <jaredj> aw darn i just jumped in too late. does infix anything work with anything but two arguments?
18:57:12 <benmachine> well whatever
18:57:21 * benmachine destroys his wip binding
18:57:29 * benmachine just uses String
18:57:42 <dmwit> jaredj: Short answer: yes, but it's not worth the extra syntax.
18:57:51 <jaredj> ic
18:58:04 <dmwit> You can define data Foo = (:!) Int Int Int -- for example
18:58:14 <dmwit> and then write (5 :! 5) 5
18:58:37 <dmwit> but pattern matching is still like case foo of (:!) a b c -> ...
18:58:51 <jaredj> ic
18:58:52 <benmachine> (a :! b) c -> doesn't work?
18:59:08 <dmwit> Really? It works here.
18:59:18 <benmachine> oh
18:59:27 <shachaf> dmwit: For pattern matching?
18:59:30 <benmachine> that's what I thought you meant when you said about (:!) a b c
18:59:41 <dmwit> Oh, no, you can't write that for pattern matching.
18:59:57 * JoeyA is using Haskell to scan the stat info of a million files into a binary file.
19:00:01 <benmachine> oh
19:00:06 <benmachine> this surprises me
19:00:19 <bss03> JoeyA: Been there, done that.
19:00:38 <nniro> dmwit: instead of data Foo = (:!) Int Int Int Int Int, I implemented this :  data Foo = Foo Int Int Int Int Int | (:!) Int Foo
19:00:40 <bss03> Wekll, sort of.
19:00:43 <jaredj> ogh, even better is if you can avoid statting a million files :/
19:01:02 <tommd> stat 1, tell boss all 1 million were the same.
19:01:07 <dmwit> nniro: Um. Lists with at least six elements?
19:01:07 <jaredj> ha
19:01:09 <JoeyA> Even better if you can avoid having a million files.
19:01:10 <dmwit> nniro: a strange type
19:01:13 <bss03> I was organizing them into a Data.Map size (Data.Map id info) strucutre.
19:01:21 <JoeyA> Worse, they're *my* files
19:01:29 <JoeyA> (mostly extracted tarballs and OS files)
19:01:43 <jaredj> pro-tip: remove those old Linux kernel source trees ;)
19:01:55 <JoeyA> Well, here's the problem
19:02:09 <JoeyA> In some cases, I have megabytes of data completely duplicated in a Linux tarball
19:02:14 <JoeyA> But a couple files, I tweaked.
19:02:17 <jaredj> oho
19:02:27 <jaredj> and that's why you need to stat them all
19:02:29 <lucca> that's what diff is for.
19:02:36 <nniro> dmwit: there's also other constructors that gradually contain more Ints
19:02:45 <bss03> JoeyA: I was scanning my downloads directory, going to replce duplicate files (same SHA-1) with hardlinks. :)
19:02:49 <JoeyA> Well, automatic finding-what-directories-are-similar is what I'm after.
19:03:05 <JoeyA> bss03: did you end up doing it?
19:03:16 <dmwit> nniro: Why?
19:03:35 <jaredj> JoeyA: ah, nifty if you can do it.
19:03:48 <bss03> Didn't finish.  I have the code that generates the Map and prints it, I didn't write the code to go further.
19:04:05 <bss03> Next step is Hashing the candidate files.
19:04:09 <JoeyA> I have code that generates a file tree and separate code for hashing files.
19:04:11 <bss03> Final step is doing the hardlinking.
19:04:21 <nniro> dmwit: data Foo = Foo Int Int Int Int Int | (:!) Int Foo | FooN Int | FooK Int Int | FooM Int Int Int | FooG Int Int Int Int | FooT Int Int Int Int Int
19:04:30 <JoeyA> The code to tie it together should be fairly simple.
19:04:38 <nniro> dmwit: ah and a nill one, I forgot
19:04:43 <JoeyA> But I'm considering writing file trees to a database.
19:05:06 <dmwit> nniro: Yes, I understand what you're doing. What I'm asking is: why?
19:05:07 <JoeyA> The problem with writing to a binary file is that Data.Binary doesn't handle reading binary as well as it could.
19:05:16 <JoeyA> err
19:05:17 <applicative> nniro,you want there to be zero to six ints exactly?
19:05:28 <JoeyA> doesn't handle laziness well as far as reading binary goes, afaik
19:05:48 <JoeyA> as in, you can't query random directories without having to unserialize lots and lots of data.
19:05:56 * applicative is wondering if a type family could give nniro something lovelier.
19:06:16 * jaredj visits awkwardfamilyphotos.com
19:06:20 <JoeyA> I considered writing "M-way binary serialization" code, but just using SQLite would be easier for me.
19:06:39 <bss03> JoeyA: I had preformance issues with Data.Map being too lazy.  I had to throw in some seq calls to avoid a stack overflow.
19:06:43 <JoeyA> By M-way binary serialization, I mean it would be able to store trees, and trees could be retrieved lazily.
19:06:50 <nniro> dmwit: I implemented this to hold byte units, it's used to count bandwidth usage
19:07:27 <JoeyA> I guess that was a lot of files.
19:07:57 <nniro> applicative: what do you have in mind?
19:08:15 <bss03> Probably not quite a million, by 4+ TB of random crap I've accumulated.  DVDs captured with DVD backup, various internet downloads, etc.
19:08:25 <dmwit> nniro: What you're doing looks wordier and more awkward than [Int]. What does Foo do that [Int] doesn't?
19:09:18 <dmwit> nniro: (I didn't understand your last answer, so I'm asking "why" again, but with different words this time. ;-)
19:09:19 <bss03> JoeyA I think doing all the seeking is probably going to kill your laziness for the most part.
19:09:19 <nniro> dmwit applicative: the problem lies in the program from which I get my data, it could output things like 200K 1.2G 20.99M
19:09:50 <bss03> JoeyA: Storing the tree in a SQLite DB doesn't sound like a bad idea to me.
19:10:12 <nniro> dmwit applicative: so I use this to hold the values so they can be processed by far easier than otherwise
19:10:13 <bss03> But, it still wouldn't be to lazy, IIRC.
19:11:27 <JoeyA> By the way, why were you using Data.Map?  Why not sort?  My approach would be:  sort and group all the files by size, sha1 hash groups of files that are the same size.
19:11:38 <JoeyA> (oh, and check inodes to avoid hashing files already hardlinked together)
19:11:44 <nniro> dmwit applicative: the idea is to hold those values in a general type so they can be calculated, evaluated and such
19:11:46 <mgsloan> what's the presently preferred fields / labels library? should I just use the one that I like best?
19:12:03 <dmwit> nniro: I still don't understand. What does Foo do that [Int] can't do?
19:12:54 <applicative> nniro, so data like "200K" will go into a different type from "1.2G" ?
19:13:50 <nniro> applicative: data like 200K would be : Foo 0 200 0 0 0       and 1.2G would be : Foo 0 0 0 2 1
19:14:16 <jaredj> nniro: what happens if you get Foo 0 200 0 2 1
19:14:46 <bss03> JoeyA: I added the file to the map as I processed it.  That first layer of map grouped by size; the second layer of map grouped by st_dev + st_ino.
19:14:47 <nniro> jaredj: the 200 is used to calculate but when you convert it to the raw value, it would output 1.2G
19:15:01 <applicative> 120000021K obviously
19:15:22 <bss03> Empty or singleton elements of the size map would be discarded.
19:15:24 <applicative> to put it wrongly
19:15:47 <dmwit> Okay, that I definitely do not understand.
19:15:52 <bss03> I would only hash one of the pathnames that was an element of the "fileid" map.
19:15:58 <applicative> nniro what about 3.3M?
19:16:06 <JoeyA> Makes sense.  However, it *might* be more efficient to locate all groups of files of the same size, sort them by path to avoid jumping all over the place when hashing files.
19:16:23 <nniro> applicative: Foo 0 Kilo Mega Giga Tera
19:16:30 <dmwit> Why wouldn't 200K and 1.2G result in plain old Integers near 200000 and 1200000000, respectively?
19:16:33 <JoeyA> Also, summing up the amount of hashing that needs to be done means a progress bar can be used :-)
19:16:45 <dmwit> That seems much easier to me than doing base-1024 arithmetic by hand.
19:16:53 <bss03> There are also some checking in there to avoid doing anything with files that had changed since being processed;  like if the same st_dev+st_ino was found but the ctime/mtime was different it would avoid even hashing that file.
19:17:12 <applicative> dmwit, is that what this amounts to?  Maybe I'm getting the idea...
19:17:47 <JoeyA> hmm
19:17:48 <bss03> I basically wanted to do interate across the file system as fast as possible, and only to minimal work when adding to the map.
19:18:08 <JoeyA> I haven't put a whole lot of thought into deduplicating directories that aren't meant to sit around as archives (such as home directories)
19:18:26 <JoeyA> The problem with hardlinking identical files in a home directory is:
19:18:32 <nniro> dmwit: because it is converted to a string rather than an integer and the idea is to leave aside values which are not really important in the larger scheme... like 20K in 1.2G is unmeaningful, at least when we check for bandwidth usage
19:18:34 <JoeyA> echo hello > a; echo hello > b
19:18:40 <applicative> nniro, why not construe the letters in 200K 1.2G 20.99M as numbers, and do the multiplication? Or do you want to store the unit used too?
19:18:51 <bss03> Yeah, this isn't meant for that either; the stuff I am processing is mostly read-only.  The hardlinks might not be entirely safe to use otherwise.
19:19:01 <JoeyA> If you say echo world >> a after hardlinking, the change will show up in b.
19:19:07 <nniro> applicative: yes, the units are very important when you calculate values together
19:19:08 <JoeyA> btrfs really needs to hurry up :-)
19:19:18 <bss03> JoeyA: I'm already using it.
19:19:21 <JoeyA> cool
19:19:21 <nniro> applicative: just not when the total is to be output to the user
19:19:30 <dmwit> nniro: But in your examples, you didn't leave aside the values which weren't important. You were perfectly willing to do computations with a value like Foo 1 0 0 0 0 1.
19:19:53 <JoeyA> Does it already support copy-on-write files? (which, if I'm not mistaken, is btrfs's flagship feature)
19:19:55 <applicative> yes, but what about just interpreting 200K as 200000 (treating K naively)
19:20:00 <bss03> My laptop is btrfs except for /boot.  My desktop has /srv /opt and /usr/local (all mostly empty) on btrfs.
19:20:10 <JoeyA> as in, cp huge.img huge2.img
19:20:11 <dmwit> (or 200K as 200 * 1024, or whatever)
19:20:17 <dmwit> I'm with applicative here, or he's with me.
19:20:21 <JoeyA> Then screw with huge2.img and huge.img be kept intact.
19:20:24 <dmwit> You should just use a plain Integer, and leave your rounding to the end.
19:20:26 <applicative> i'm with dmwit
19:20:33 <bss03> JoeyA: Yes, transparently.  It's also part of how it implements snapshots.
19:20:40 <bss03> "
19:20:53 <JoeyA> Does btrfs automatically save all versions of files?
19:21:01 <applicative> nniro, it is more amusing your way, if i'm starting to understand it, but one senses chaos and error around the corner.
19:21:01 <JoeyA> Or do you explicitly indicate when you want a snapshot taken?
19:21:18 <nniro> dmwit applicative: heh what about 999T + 999T?
19:21:28 <bss03> "cp" on a btrfs filesystem is about as fast as "ln", but writing to either copy will start then do the "full" copy or at least one "inode" at a time.
19:21:37 <bss03> Snapshots are manually taken.
19:21:43 <nniro> dmwit applicative: or just 999G + 999G
19:21:52 <bss03> btrfs isn't a full versioned filesystem like VMS used to have.
19:22:00 <JoeyA> Is copy-on-write done at the block level?
19:22:01 <dmwit> > let bigger = (* 2^10); kilo = bigger 1; mega = bigger kilo; giga = bigger mega; tera = bigger giga in 999 * tera + 999 * tera -- nniro, what about it?
19:22:02 <lambdabot>   2196824232296448
19:22:19 <applicative> > show (999 + 999) ++ "G"
19:22:20 <lambdabot>   "1998G"
19:22:22 <JoeyA> As in, if you cp an emulator image, then run the emulator on it and change a few blocks in the file
19:22:29 <JoeyA> Will it only copy the blocks that changed?
19:22:29 <applicative> nniro what about that ^^
19:22:33 <bss03> Inode level, IIRC, but it might actually be full extents.
19:22:35 <JoeyA> Or will it copy the whole freaking file?
19:22:37 * mgsloan1 decides to use fclabels..
19:22:50 <Adamant> zfs über alles
19:23:00 <bss03> IIRC, just the changed bytes and some space around them.
19:23:27 <nniro> dmwit applicative: yeah... that's basicly what I'm doing with a data constructor...
19:23:29 * applicative praises another bold acte gratuite in the record package sweepstakes
19:23:51 * dmwit sighs
19:24:00 <dmwit> Well, have fun, then.
19:24:20 <revenantphx> I'm already starting to see how i'd miss some haskell features  > >
19:24:21 <applicative> nniro, surely there will be ample scope for sweet haskell types in the later development
19:24:22 <dmwit> When you discover how painful it is, and how error-prone, don't blame us.
19:24:24 <revenantphx> partial application is really nice.
19:24:58 <nniro> dmwit: heh I already implemented it...
19:25:00 <revenantphx> > tera
19:25:01 <lambdabot>   Not in scope: `tera'
19:25:29 <applicative> nniro, well.. don't come cryin' to us...
19:25:30 <bss03> JoeyA: It's been good to me, but I'm still a little wary of recommending btrfs to anyone.
19:25:47 <nniro> applicative: it works perfectly :D
19:25:59 <dmwit> > let bigger = (* 2^10); (_:kilo:mega:giga:tera:_) = iterate bigger 1 in tera
19:26:00 <lambdabot>   1099511627776
19:26:11 <JoeyA> bss03: Because it's unstable, or because there are some performance quirks and such? (or worse, data loss)
19:26:14 <bss03> JoeyA: The fsck can't really do any repairs, so if the filesystem does go sideways for some reason, you basically get real friendly with the developers and a hex editor.
19:26:25 <JoeyA> lol
19:26:34 * applicative has just introduced an alternative Int type BetterInt  he switches the positions of 3 and 17
19:26:48 <JoeyA> DvorakInt
19:26:54 <revenantphx> applicative: what?
19:26:55 <pantsd_home> In Data.Set is difference supposed to return all of the elements which are unique to both the first set and second set or only the ones in the first set not in the second set?
19:27:09 <applicative>  > 5 + 12
19:27:11 <applicative> 3
19:27:12 <bss03> JoeyA: There's also no, fsck -a for you OS to run at boot time, so you get a few little errors there.
19:27:16 <dmwit> pantsd_home: asymmetric difference, I believe
19:27:32 <shachaf> bss03: Have you had that happen to you?
19:27:40 <applicative>  > 17 +3 
19:27:46 <applicative>  20
19:27:48 <dmwit> pantsd_home: You can get symmetric difference via (a \\ b) `union` (b \\ a), of course. =)
19:27:50 <applicative> > 17 + 2
19:27:51 <lambdabot>   19
19:27:52 <applicative> 5 
19:28:00 <pantsd_home> dmwit: Shiney, thanks :)
19:28:00 * shachaf needs to pick a filesystem soon, and might give up on Windows compatibility.
19:28:04 <JoeyA> > enumFromTo 0 10 :: [DvorakInt]
19:28:05 <lambdabot>   Not in scope: type constructor or class `DvorakInt'
19:28:08 <bss03> Since you fsck on-line, you could do it with a cronjob I suppose, but I found a case when the fsck reported errors on a mounted filesystem but a remount solved them... and not I can't repeat the issue. :(
19:28:18 <JoeyA> [1/4,7,5,3,1,9,0,2,4,6,8]
19:28:20 <revenantphx> pantsd_home: You mean \\?
19:28:25 <revenantphx> pantsd_home: it says " In the result of xs \\ ys, the first occurrence of each element of ys in turn (if any) has been removed from xs. Thus"
19:28:28 <applicative> [0,1,2,17,4,5,6,7,8,8,10]
19:28:54 <bss03> No, btrfs has been good to me, no real data loss, and the fsck, defrags, and resizing all have run fine.
19:28:56 <lispy> bss03: is btrfs webscale?
19:29:01 <applicative> do the dvorak ints not go in the usual order?
19:29:04 <revenantphx> > [1,2,3,4,5,6] \\ [1,2]
19:29:05 <lambdabot>   [3,4,5,6]
19:29:07 <dmwit> revenantphx: No, Data.Set.\\.
19:29:23 <dmwit> (Though the result is similar.)
19:29:24 <bss03> webscale?  I don't think I know the term.
19:29:26 <JoeyA> Supposedly, ANSI Dvorak uses this layout:  http://en.wikipedia.org/wiki/File:KB_DSKtypewriter.svg
19:29:34 <revenantphx> dmwit: oh my bad
19:29:40 <JoeyA> But the Dvorak most people use keeps the numbers in the same place
19:29:59 <shachaf> bss03: I believe that was an allusion to <http://www.xtranormal.com/watch/6995033/>.
19:30:04 <bss03> I haven't noticed any big performance gains or losses, but I also haven't run any good benchmarks.
19:30:17 <dmwit> Okay, I no longer believe reactive-glut is using polling. My mind is slowly warping, though.
19:30:30 <applicative> i see.  is the theory that one uses 0 1 and 2 more often?  i guess it is known that disproportionately many numbers start with 1
19:30:32 <bss03> I'm just trying to get off of reiserfs3, and I need a filesystem that can both grow and shrink.
19:30:42 <Veinor> "i guess it is known that disproportionately many numbers start with 1
19:30:44 <Cale> lispy: lol, is that a reference to the recent video?
19:30:45 <lispy> bss03: just a bad joke :)  So, why would someone be interested in btrfs?
19:30:48 <Veinor> this sounds rather silly
19:31:05 <mm_freak> to get a file's size i'm currently doing:  withFile "path" ReadMode hFileSize
19:31:06 <lispy> Cale: Shared are the secret ingredient in the webscale sauce.
19:31:09 <mm_freak> is there a faster way?
19:31:15 <lispy> Cale: shardes*
19:31:15 <Cale> haha
19:31:21 <dmwit> Veinor: not silly
19:31:23 <applicative> Veiner, put that yes.  But if you think of e.g. street adresses, you can convince yourself rapidly that far more that 1/10 start with 1
19:31:29 <Veinor> welll, yes
19:31:30 <bss03> It's *supposed* to be faster than the ext* line, supports snapshotting, multiple devices, does data checksumming, etc.
19:31:39 <mm_freak> related question:  is there an interface to 'stat'?
19:31:47 <applicative> it is a well known result belonging to a science that surely has no name
19:31:48 <bss03> It's really supposed to be a GPL equivalent of ZFS is a number of ways.
19:31:53 <Veinor> guys, is /dev/null webscale?
19:32:02 <dmwit> Veinor: If you start with x money, compounded at 1%, you will spend most of your time with an amount of money starting with a 1.
19:32:22 <bss03> mm_freak, I don't think a portable one.  If you are on linux you can stat the file with stuff in System.Posix.
19:32:25 <Cale> Veinor: Yeah, you turn it on and it scales right up
19:32:25 <dmwit> Veinor: Why? Because when you have money amounts starting with a 9, you very quickly reach over to a 1, but then it takes a long time to get back to 2.
19:32:32 <mm_freak> i've written a toy 'du' implementation, which takes forever for my home directory, while the real 'du' runs in reasonable time
19:32:34 <dmwit> Something similar happens for other quantities.
19:32:40 <applicative> Veinor, i suppose it is the sort of consideration that leads to sorting algorithms that take account of what they might be dealing with, like timsort.
19:32:56 <shachaf> bss03: If ZFS was GPL, would there be any reason to use Btrfs?
19:33:10 <Veinor> dmwit: right, I know about zipf's law
19:33:19 <applicative> mm_freak, did you follow one of the patterns on the Reddit Du Tempest-in-a-Teapot
19:33:26 <Veinor> I just felt like quoting that statement out of context and being silly
19:33:35 <mm_freak> applicative: no, i used ChoiceT from MonadLib
19:33:48 <dmwit> oh
19:33:52 <mm_freak> it's a fast and correct ListT
19:33:56 <bss03> bss03: I don't know, I haven't follow ZFS too closely.  Does it handle online resizing of filesystems, both shrinking and growing?
19:33:58 <dmwit> Well, you're right. It *does* sound silly! =)
19:34:11 <dmwit> Luckily, sometimes the world is a bit silly.
19:34:15 <bss03> er, I mena that for shachaf ^^
19:34:43 <mm_freak> applicative: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29796
19:34:50 <applicative> i tried to perfect the wilder du's with so called hylomorphisms.  roconnor made much better progress.
19:35:27 <shachaf> bss03: Not sure. Wikipedia says "In ZFS, filesystem manipulation within a storage pool is easier than volume manipulation within a traditional filesystem; the time and effort required to create or resize a ZFS filesystem is closer to that of making a new directory than it is to volume manipulation in some other systems.", but I haven't used ZFS myself.
19:35:56 <mm_freak> applicative: i don't think my data structures are the bottleneck…  it seems like it's withFile
19:36:02 <shachaf> bss03: If the two are rougly equivalent, it seems strange to write a brand new filesystem rather than work on a GPL implementation of ZFS.
19:36:05 <mm_freak> my program is opening every single file just to get its size
19:36:29 <bss03> Well, ZFS (and some of btrfs) features don't matter much to me, since I've been doing volume management via LVM since 2004.
19:36:42 <JoeyA> Just stat it and use that fileUsed function that should be in System.Posix.Files but is not.
19:36:46 <bss03> Dos-style, even EFI-style partitioning sucks.
19:37:14 <shachaf> bss03: Presumably ZFS would mean that you wouldn't need to. :-)
19:37:45 <mm_freak> JoeyA: there is 'fileSize' in there
19:37:53 <mm_freak> i'll try it out
19:38:07 <bss03> I think btrfs was actually started before ZFS was the new hotness or at least before code was avilable, it's actually been a project for quite some time.
19:38:34 <bss03> Eh, I actually prefer LVM over the examples I've seen of ZFS pool management.
19:39:14 <shachaf> bss03: Ah.
19:39:23 <JoeyA> fileSize isn't the same as space used.
19:39:26 <shachaf> (#-blah might be a better place for this.)
19:39:37 <JoeyA> If it's a sparse file, it won't be correct, for instance.
19:39:46 <JoeyA> But it's close enough for country.
19:39:50 <bss03> Agreed.  We have quite drifted from #haskell conversation.
19:39:59 <JoeyA> And it's all my fault.
19:40:37 <lispy> shachaf: ZFS isn't GLP'd it has some weird license on it that I don't recognize
19:40:46 <nniro> dmwit applicative: if I used your technique, how would I hold those values so they can be calculated together? say we can only hold 32 bits integers
19:40:51 <bss03> CDDL is the OpenSolaris license.
19:41:28 <shachaf> lispy: Yes, that's the main reason it's implemented in FUSE instead of in the Linux kernel.
19:41:38 <bss03> It's also used for a few other things.  It's not a bad license, it's just not compatible with any version of the GPL, so having it in the mainline kernel is not allowed.
19:42:37 <bss03> I hear there's a out-of-tree module for ZFS that does use any "GPL-only" kernel interfaces in the works.
19:42:59 <bss03> It's supposed to out-perform the FUSE implementation, but I don't know how stable it is.
19:43:30 <shachaf> bss03: So do you use btrfs as your primary FS?
19:43:31 <lispy> I bet mongoDB is faster
19:44:14 <bss03> shachaf: On the laptop, yes.  I haven't converted my desktop, yet.
19:44:58 <shachaf> bss03: But you're still wary of recommending it?
19:45:02 <JoeyA> Here's a function that'll let you get the space used by a file:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29797#a29797
19:45:20 <JoeyA> (extracts the underlying st_blocks and multiplies it by 512 to get bytes)
19:45:27 <JoeyA> And surely only works on GHC.
19:45:52 <bss03> shachaf: I'm fairly confident in the combined data recovery skill of me and my roomates.  I'm not sure about the public.
19:45:58 <JoeyA> (note: this is a function that probably ought to be in System.Posix.Files but isn't)
19:46:31 <bss03> shachaf: I think most people should at least wait until the developers feel confident enough to remove the THIS IS EXPERIMENTAL warning from their wiki.
19:46:33 <nniro> dmwit applicative: nevermind... I didn't know I could hold almost inifinite sized integers, thanks I'll look into that
19:47:04 <mm_freak> applicative: i'm thinking there should be a way to make an elegant 'du' without going too deep into CT
19:47:05 * JoeyA wonders how st_blocks is calculated for btrfs when files can share used space.
19:47:15 <JoeyA> CT?
19:47:33 <lispy> category theory
19:47:35 <mm_freak> JoeyA: category theory
19:47:35 <JoeyA> oh
19:48:07 <lispy> that's how haskellers spell "advanced technique"
19:48:14 <JoeyA> Just use unsafeInterleaveIO when scanning a directory to build a file tree :-)
19:48:17 <lispy> "Requires CT"
19:48:19 <bss03> JoeyA: Probably charges each file for it.
19:48:21 <JoeyA> though that's not really necessary here.
19:48:34 <shachaf> bss03: Hmm. I might install with btrfs and then call you and your roommates if there's an issue.
19:48:48 <mm_freak> JoeyA: i never use unsafe*
19:49:09 <bss03> shachaf: Well, at least two of us are incorporated in the state of Arkansas, we could certainly give you a quote. ;)
19:49:22 <mm_freak> IMO that's dirty and should be avoided, unless it's absolutely necessary
19:49:33 <mm_freak> i think i should try a CPS-based approach
19:49:35 <JoeyA> I kind of hate the way this is implemented since it, in my own-ish words, "goes nuts with monad transformers":  http://hackage.haskell.org/packages/archive/lazyio/0.0.3/doc/html/src/System-IO-Lazy.html
19:49:44 <JoeyA> It's really hard to tell what it does.
19:50:12 <JoeyA> err, how it works
19:50:14 <shachaf> lispy: I don't think CT is webscale.
19:51:10 <danderson> but can it run map-reduce on sharded key-value pairs?
19:51:31 <mm_freak> JoeyA: what's wrong with monad transformers?
19:51:37 <danderson> (which is the definition of web-scale, need I remind you)
19:55:13 <JoeyA> I don't understand them, that's what's wrong with them.
19:57:05 <conal> dmwit: no, not polling.  read "push-pull functional reactive programming"
19:57:25 <conal> dmwit: sry for the brief answer.  happy to explain more later.
19:58:24 <lispy> shachaf: but it supports mapReduce!
20:00:07 <dmwit> conal: Thanks, I've decided I need to look again with fresh eyes in the morning. Will have a look at push-pull FRP.
20:00:37 <mm_freak> JoeyA: start with StateT, it's one of the easier transformers (and the one i use most often)
20:01:10 <mm_freak> while State models (s -> (a, s)), StateT models (s -> m (a, s)) for a monad m
20:01:26 <conal> dmwit: cool.  catch you later.
20:03:07 <JoeyA> I guess I should be lucky that lazyio uses StateT
20:03:21 <JoeyA> (from Control.Monad.Trans.State)
20:03:29 <JoeyA> That might not be the same StateT you're thinking of.
20:03:35 <mm_freak> JoeyA: i think lazyio rather abuses StateT to get the laziness
20:03:44 <mm_freak> better learn from other examples =)
20:03:49 <JoeyA> heh
20:04:08 <JoeyA> the main reason I wanted to know how lazyio works is: I want to know how to add exception support.
20:04:14 <mm_freak> it uses StateT RunAll IO
20:04:21 <mm_freak> but RunAll is isomorphic to ()
20:04:41 <mm_freak> so it doesn't make much sense to make a state monad with RunAll as the state type
20:04:45 <JoeyA> hmm, perhaps I can just use liftCatch
20:04:58 <JoeyA> Though I'm not seeing a liftFinally
20:05:06 <mm_freak> have you looked into iteratees?
20:06:05 <JoeyA> A teeny tiny bit.  However, I'm not currently toying with lazy IO at the moment.
20:06:16 <mm_freak> (personally i don't understand them, but they seem to be the preferred approach to elegant and predictable IO)
20:06:45 <lispy> iteratee isn't as hard to understand as the iteratee libarry makes them seem
20:06:48 <JoeyA> That sure makes 'em sound good.  Someone else recommend I look into them before.
20:07:04 <lispy> they are 1) foldl 2) they have explicit chunking
20:07:27 <danderson> the enumerator package makes it slightly less incomprehensible
20:07:46 <danderson> attoparsec is also a good simple iteratee implementation
20:07:49 <mm_freak> lispy: yes, but i wonder if you couldn't write a parser library, which does its IO by itself
20:08:11 <mm_freak> attoparsec allows that to some extent, i think
20:08:27 <lispy> attoparsec tells you when it needs more input
20:08:32 <danderson> danger: you are mixing pure concerns (how to parse stuff) with impure concerns (how do you get the chunks to parse, i.e. I/O)
20:08:34 <lispy> You can then choose to feed it or terminate it
20:09:11 <danderson> attoparsec has one helper where you can pass an action that retrieves more input, but the basic API is all nice and pure.
20:09:57 <mm_freak> danderson: i don't think i'm mixing them…  you have a pure representation (a parser), but an impure function to run it (parseFile)
20:10:13 <lispy> the way attoparsec does it is nice because it fits the model of a well behaved iteratee, so you can easily transform it into the framework of the iteratee library
20:10:15 <mm_freak> because the parser knows how to parse, it also knows when to get more data and when to close the file
20:10:27 <JoeyA> lol:  1 attoParsec = 3.08568025 centimeters
20:10:41 <mm_freak> lispy: yes, there is even a library to do just that
20:11:08 <lispy> yup :)
20:11:22 <monochrom> haha
20:12:06 <monochrom> 3.08568025 should inspire atto-parsec version numbers :)
20:12:19 <danderson> mm_freak: As long as you also have pure functions to execute a partial run of a parser (see attoparsec's parse and feed functions), parseFile is just a helper. Which is fine.
20:12:28 <mm_freak> in fact i just found that attoparsec has that new parseWith function, which seems to fit my purposes =)
20:13:15 <lispy> mm_freak: one thing to know about attoparsec.  You pretty much have to "parse p `feed` B.empty" to get the full parse out of it
20:13:30 <lispy> which is to say, it really needs that empty input to know that it should stop
20:13:39 <danderson> yeah, that's a bit of an API wart imho
20:14:36 <lispy> I just defined a helper function and I was done with it :)
20:14:47 <mm_freak> yeah, ditto
20:14:52 <lispy> fullParse p s = parser p s `feed` B.empty, or so
20:15:05 <danderson> (can't wait for the revised version of binary that will also have continuation-based parsing <3)
20:15:07 <mm_freak> but that's still much better than lazy I/O
20:22:19 <lispy> Does haskell-mode have a way to "tell cabal to configure and build my project"?
20:22:40 <mm_freak> lispy: i use a Makefile
20:30:41 <monochrom> i use "cabal build" :)
20:31:08 <monochrom> normally you can skip "cabal configure". (just do it once.)
20:35:12 <lispy> yeah, I just wondered if people had a nice way to make emacs do the cabal build for you
20:35:22 <co_dh> @pl \x -> x-10
20:35:23 <lambdabot> subtract 10
20:35:32 <co_dh> @src subtract
20:35:32 <lambdabot> subtract x y = y - x
20:36:20 <bss03> @type (-(10))
20:36:20 <lambdabot> forall a. (Num a) => a
20:36:50 <Veinor> yeah.
20:37:21 <bss03> @type ((flip $ flip (-)) 10)
20:37:22 <lambdabot> forall a. (Num a) => a -> a
20:38:00 <bss03> @type (10 (flip (-)))
20:38:01 <lambdabot>     Ambiguous type variable `a' in the constraint:
20:38:01 <lambdabot>       `Num a' arising from a use of `-' at <interactive>:1:10-12
20:38:01 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
20:38:02 <Veinor> :t ((-) 10)
20:38:03 <lambdabot> forall t. (Num t) => t -> t
20:38:37 <Cale> There's always (+(-10))
20:38:45 <dankna> lispy: I have a simple keyboard shortcut to make emacs do that.  It's bound to alt-tab c a b a l SPC b u i l d RET
20:38:46 <bss03> > ((-) 10) 13
20:38:47 <lambdabot>   -3
20:38:53 <Veinor> dankna: haha
20:38:55 <dankna> grin
20:39:35 <co_dh> Cale : (+ (-10 )) is nice :)
20:40:45 <co_dh> haskell is so elegant , I love it !!! but I have to find a c++ job, damn it , lol
20:41:32 <Adamant> co_dh: you do games?
20:41:45 <Adamant> I think the folks at Epic <3 Haskell
20:41:49 <co_dh> Adamant : yes. 
20:41:54 <co_dh> Epic < 3 ? 
20:42:04 <Adamant> love Haskell
20:42:25 <etpace> Where could I find the code that ghc uses to work out wether you import is used or unused
20:42:54 <Adamant> co_dh: I'm not saying you'll get to use it, except maybe if they use it for internal stuff
20:43:08 <Adamant> but the folks there are least look on it favorabl
20:43:09 <Adamant> y
20:43:50 <monochrom> oh what fun. one of the emacs haskell-mode binding is "<C-M-S-mouse-3> haskell-doc-ask-mouse-for-type"
20:44:26 <dankna> ha
20:44:32 * monochrom picks up mouse, put mouse close to mouth, says "computer, infer the type of f <$> a <*> b"
20:44:32 <co_dh> Qualifications:
20:44:33 <co_dh> Strong C++ knowledge  
20:44:56 * monochrom literally asks mouse for type!
20:45:05 <Adamant> monochrom: you and Scotty
20:45:06 <Adamant> :P
20:45:21 <monochrom> yeah that scene was totally hilarious
20:45:51 <Adamant> well, maybe not for UI and interaction guys. they can look at it as inspiration[
20:46:05 <Adamant> but yeah, it was good
20:46:19 <mm_freak> lispy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29798#a29798
20:46:44 <mm_freak> and in subdirectories you just make a rule to do:  $(MAKE) -C ..
20:48:53 <JoeyA> Is there a function for Data.Tree for converting a tree to a list of items, but the converter takes a parent argument
20:49:11 <JoeyA> As opposed to flatten, which just makes a flat array with no parent context.
20:49:15 <JoeyA> err, list
20:49:36 <JoeyA> The function I wrote has the type signature (Maybe b -> a -> b) -> Tree a -> [b]
20:50:08 <JoeyA> the root of the tree is converted with that first function, with Nothing as the first argument and the label as the second.
20:50:31 <JoeyA> The children of the root are converted with the same function, but with Just rootItem as the first argument
20:51:05 <JoeyA> rootItem comes from applying the function to the root node.
20:51:28 <co_dh> Do you guys have a career suggestion for a haskell programmer ? bank ? web ? I think game is a wrong choice..
20:51:46 <co_dh> or for a guy who love haskell. 
20:53:11 <Adamant> get really good at Haskell.
20:53:41 <Adamant> I'll let people who actually get paid to do Haskell give more specific advice
20:54:40 <co_dh> I think there are < 100 people get paid to do Haskell.
20:54:42 <Pseudonym> Type theorist?
20:54:48 * Pseudonym ducks
20:55:10 <etpace> good chance most of that 100 are here though
20:55:38 <geheimdienst> i will slap my forehead and say d'oh in 2 minutes, but ... how do i simplify this code to be one line? «x <- gets blah ; x»
20:55:55 <copumpkin> gets blah
20:56:01 <copumpkin> oh
20:56:09 <copumpkin> join (gets blah)? 
20:56:24 <Cale> co_dh: I'm fairly sure it's more than 100 depending on who you count (researchers?), but yeah, the number isn't large. On the other hand, if you know Haskell well, there are people hiring.
20:56:29 <geheimdienst> yeah well no. gets blah will give me a compiler warning that a result of type X () was discarded
20:56:35 <copumpkin> hmm, that makes no sense
20:56:43 <copumpkin> :t gets
20:56:44 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
20:57:04 <Pseudonym> The trouble is, I suspect, that you can't work for Credit Suisse your whole career.
20:57:13 <geheimdienst> no no, that's correct. i'm storing that X action there, and using gets to retrieve it. then i wanna run it
20:57:30 <Pseudonym> My advice, which is worth exactly what you paid for it, is to learn as many languages as you can, even if not fluently.
20:57:42 <co_dh> Cale: How do you consider somebody know Haskell well ? some paper ? or a Haskell package ? or some side project ? 
20:57:57 <Pseudonym> You'll be in a better position to get your boss to adopt Haskell, even if not for release code.
20:57:59 <Adamant> Pseudonym: good advice, although it helps to get really good with some of them
20:58:04 <Pseudonym> Of course.
20:58:13 <QtPlatypus> co_dh: Like any programing language by reading there code.
20:58:15 <Pseudonym> You need to be really good with one of each paradigm.
20:58:17 <etpace> heres more than credit suisse though Pseudonym 
20:58:30 <mm_freak> geheimdienst: sounds like 'join (gets blah)' to me
20:58:51 <Pseudonym> I know, etpace, I'm just making the point that there aren't very many places hiring Haskell programmers, and your career doesn't want to be a crawl of all of them.
20:59:00 <copumpkin> mm_freak: he didn't like that?
20:59:01 <co_dh> QtPlatypus: I've read a lot code & paper, so I consider myself know Haskell well :)
20:59:03 <Pseudonym> And by that I mean Haskell programmers _specifically_.
20:59:11 <Cale> co_dh: I would say combinations of those -- people would look at all the stuff that you've done to try to figure out how well you know things.
20:59:21 <mm_freak> copumpkin: then, well…  gets blah >>= id
20:59:27 <etpace> you're correct in its better to just write haskell code for non-production, thats what a friend is currently doing at GS
20:59:29 <geheimdienst> copumpkin, i like all haskell equally. it sounded like you weren't sure, with the question mark ...
20:59:34 <QtPlatypus> co_dh: No I mean, you judge anouther programer by there code.
20:59:38 <etpace> trying to win the mover slowly ;)
20:59:47 <geheimdienst> i'm trying join right now. hang on, compiling ...
20:59:50 <copumpkin> geheimdienst: oh, no, I'm just out of it
20:59:55 <copumpkin> so am not feeling confident :P
21:00:10 <QtPlatypus> You can consider yourself as a good programer if other people who's programing skills you respect consider you a good programmer.
21:00:31 <copumpkin> QtPlatypus: but _are_ you a good programmer in that situation?
21:00:42 <kmc> the vector of programmer goodness is a graph eigenvalue?
21:00:45 <co_dh> QtPlatypus: Yes, I'm 
21:00:51 <mm_freak> QtPlatypus: a lot of people respect the skills of dumb people
21:01:06 <co_dh> kmc : graph eigenvalue ? lol
21:01:17 <kmc> graph eigenvalue, aka pagerank
21:01:31 <QtPlatypus> Or paper impact.
21:02:01 <geheimdienst> thanks guys, that worked :-)
21:02:22 <QtPlatypus> I retract that, paper impact isn't graph eigenvalue but it should be.
21:03:40 <co_dh> the graph eigenvalue remind me something interesting . in a game work, A could win B , or lose sometime, how could you give a rank of a player in such condition ? what mathematical model (theory) solved this problem? 
21:04:07 <co_dh> it's a game tournament ranking problem. 
21:09:39 <sm> hey all.. is http://sebfisch.github.com/haskell-regexp/regexp-play.pdf implemented by one of the regex libs on hackage ?
21:12:53 * hackagebot hledger-lib 0.12.1 - Core types and utilities for working with hledger (or c++ ledger) data.  http://hackage.haskell.org/package/hledger-lib-0.12.1 (SimonMichael)
21:12:55 * hackagebot hledger 0.12.1 - A command-line (or curses or web-based) double-entry accounting tool.  http://hackage.haskell.org/package/hledger-0.12.1 (SimonMichael)
21:14:21 <sm> aha.. weighted-regexp
21:23:38 <dibblego> what is the name of the GHCi warning for "Warning: This binding for `foo' shadows the existing binding"
21:23:49 <dibblego> *GHC
21:24:46 <dibblego> warn-name-shadowing
21:25:57 * hackagebot witness 0.2 - values that witness types  http://hackage.haskell.org/package/witness-0.2 (AshleyYakeley)
21:26:31 <geheimdienst> hm ... a new twist on the familiar "join, ask question, leave within seconds" move. "join, ask question, answer own question, leave, all within a minute".
21:27:09 <shachaf> geheimdienst: You must admit it's more effective.
21:27:12 <c_wraith> well, dibblego's a regular.
21:27:52 <sm> hey, I'm all for more answers
21:29:54 * sm decides that the way to test your dependencies is install in a clean (capri) environment constraining all dependencies to their lowest bound. And again constraining all to the uppermost, I guess
21:31:25 <sm> would that catch all dependency problems ? Perhaps only if all packages follow pvp ?
21:32:24 <tolkad> I have become better at haskell but I'm still a bit confused about when to use a class vs. a type with a parameter vs. a single type with a set of constructors. I feel like choosing one option might conflict with something I want to do in the future. Does anyone have advice/reading that migh help me with this problem?
21:32:37 <tolkad> might*
21:34:16 <tolkad> is my question too vague?
21:34:20 <Cale> tolkad: hmm
21:34:27 <Cale> It is a bit vague :)
21:34:44 <Cale> Different options do have different properties with respect to extensibility
21:35:14 <kmc> tolkad, those three things solve different problems
21:35:24 <kmc> do you have a single problem in mind which you believe is solved by all three?
21:35:31 <kmc> it would be easier to discuss the tradeoffs in that context
21:36:32 <sidek> Question : I am using  [ [ x | x <- xss, even x] | xss <- xs] to make a list of numbers out of a larger list found in xs. I want to run sum on this, but sum doesn't seem to take it as a direct argument. How do I run sum on it?
21:36:33 <tolkad> hmm, I'll see if I can think of an example
21:36:59 <tolkad> > [ [ x | x <- xss, even x] | xss <- xs]
21:37:00 <lambdabot>   Not in scope: `xs'
21:37:18 <tolkad> sidek: what's xs?
21:37:23 <kmc> sidek, [ sum [ x | x <- xss, even x] | xss <- xs] perhaps?
21:37:25 <sidek> the fibonacci series
21:37:32 <sidek> up to the 34th entry
21:37:46 <kmc> i don't understand why you have nested lists here
21:37:59 <kmc> xss is a list of lists?
21:38:02 <sidek> kmc, yours works
21:38:04 <kmc> it would have to be, for that to type-check
21:38:28 <tolkad> > foldl sum [ [ x | x <- xss, even x] | xss <- [1..]]
21:38:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> [a]
21:38:36 <Cale> tolkad: You might want to watch Ralf Lmmel's recent lectures on C9 about the expression problem and typeclasses. I'm not sure it constitutes a real answer to your question, but it's also not unrelated.
21:38:36 <sidek> ....I don't even know, to be honest. I just started learning haskell last night and haven't had much time to work with it because of school.
21:38:41 <Cale> http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem/
21:38:45 <Cale> http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes/
21:38:53 <kmc> sidek, ok
21:39:05 <kmc> sidek, what's the goal? sum the even entries of the fibonacci sequence?
21:39:12 <sidek> yes
21:39:14 <tolkad> > foldl (\a b -> a + (sum b)) [ [ x | x <- xss, even x] | xss <- [1..]]
21:39:15 <lambdabot>   Overlapping instances for GHC.Show.Show ([[[[t]]]] -> [[t]])
21:39:15 <lambdabot>    arising fro...
21:39:22 <tolkad> > foldl (\a b -> a + (sum b)) 0 [ [ x | x <- xss, even x] | xss <- [1..]]
21:39:22 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
21:39:23 <lambdabot>    arising from a use...
21:39:31 <sidek> I'm redoing some project euler problems in haskell
21:39:35 <tolkad> darn it what was wrong with that one...
21:39:36 <Cale> :t [ [ x | x <- xss, even x] | xss <- [1..]]
21:39:37 <lambdabot> forall t. (Num [t], Enum [t], Integral t) => [[t]]
21:39:39 <kmc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in sum (filter even fibs)
21:39:43 <lambdabot>   mueval-core: Time limit exceeded
21:39:46 <kmc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in sum (filter even (take 34 fibs))
21:39:47 <lambdabot>   4613732
21:40:03 <Cale> Enum [t]  seems suspicious :)
21:40:30 <Cale> (as does Num [t])
21:41:33 <tolkad> > foldl (\a b -> a + (sum b)) 0 [ [ x | x <- xss, even x] | xss <- [1..]]
21:41:34 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
21:41:34 <lambdabot>    arising from a use...
21:41:37 <tolkad> I think that should work...
21:42:18 <tolkad> > foldl (\a b -> a + (sum b)) 0 ([ [ x | x <- xss, even x] | xss <- [1..]] :: [[Integer]])
21:42:19 <lambdabot>   No instance for (GHC.Num.Num [GHC.Integer.Internals.Integer])
21:42:19 <lambdabot>    arising fr...
21:44:00 <tolkad> Cale: I'll watch them thanks
21:44:18 <tolkad> I probably just need experience to get used to modeling stuff with haskell's type system
21:44:43 <oscillo> *9
21:44:43 <copumpkin> wow, I like the idea of this, but this guy really doesn't like layout: http://hackage.haskell.org/packages/archive/countable/0.1/doc/html/src/Data-Countable.html#countDown
21:45:03 <kmc> wow
21:45:22 <kmc> must have missed C syntax
21:45:32 <kmc> wouldn't be so bad except for putting { on its own line
21:45:42 <kmc> that bugs me, in any language
21:46:25 <copumpkin> stuff like http://snapplr.com/91np
21:46:42 * copumpkin shrugs
21:47:36 <geheimdienst> s = maybe def id mx ?
21:47:51 <copumpkin> :t fromMaybe
21:47:53 <lambdabot> forall a. a -> Maybe a -> a
21:48:17 <copumpkin> anyway, I like the package
21:48:26 <copumpkin> it just seems like a pity to pollute potentially very elegant code with so much syntax
21:52:54 <kmc> it's the norm in most languages though
21:54:22 <kmc> new type checker? GHC 7.0?
21:54:26 <kmc> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/18866
21:54:33 <copumpkin> yep
21:54:38 <copumpkin> he's been working on it for a while
21:54:40 <kmc> hot damnnnnn
21:55:47 <mm_freak> copumpkin: i'm not a friend of braces, but i must admit, his code is quite readable
21:55:51 <Eduard_Munteanu> Ah, nice to see SPJ is still alive and kicking ass in the Haskell community.
21:56:13 <copumpkin> mm_freak: yeah, but his aversion for even simple higher-order functions and eliminators like in that bit I screenshotted
21:56:24 <copumpkin> just detracts from overall legibility and pattern-findability :P
21:56:34 <Eduard_Munteanu> I wonder, does he come in here?
21:56:39 <copumpkin> nope
21:56:44 <Eduard_Munteanu> Aw :(.
21:58:44 <Eduard_Munteanu> Oh my... those braces do make that code look a bit like C++ if you ignore the actual keywords.
21:59:31 <Eduard_Munteanu> Well, in the wrong way at least, the instances look like methods :).
21:59:50 <Eduard_Munteanu> Like the "instance Countable () where
21:59:55 <Eduard_Munteanu> " stuff.
22:01:33 <mm_freak> IMO haskell has a characteristic look, and that code doesn't match it at all
22:01:47 <mm_freak> on a first glance, i would have confused it with some OOP language
22:02:02 <Eduard_Munteanu> Yeah, it feels really strange.
22:02:32 <Eduard_Munteanu> Similarly, the ';'-terminated lines.
22:02:53 <mm_freak> but it's a great example to show to beginners…  a lot of people turn away from haskell, because they prefer braces
22:03:24 <mtnviewmark> "prefer braces" ... hmmmm.... kind of a thin view of programming, eh?
22:03:28 <Eduard_Munteanu> Hm, I'm bookmarking it.
22:03:37 <Eduard_Munteanu> Though the confusion factor might be too great.
22:04:21 <geheimdienst> my main objection is that all the lines with only { and } are a huge waste of space. if somebody left every second line blank, i'd be unhappy that i need to scroll twice as much
22:06:20 <kmc> yeah, i'd be pretty much fine with it if it put { on the end of the previous line
22:06:30 <kmc> that's the style i use in C, C++, etc
22:06:51 * geheimdienst remembers how layout drove him absolutely nuts as a newbie. a tiny indentation change, in a place where by all intuition it should not matter, made ghc yell at me.
22:06:59 <kmc> yeah
22:07:20 <kmc> when i was a newb i was very careful about laying stuff out
22:07:30 <kmc> it turns out that the rule is a good bit more lenient than i thought
22:07:54 <arw> hm. i can program C without my glasses, because i don't overlook {}. but aligning haskell without glasses sometimes fails :)
22:08:12 <geheimdienst> i mean, it is confusing. even if you've used python and are fine with the idea of significant whitespace
22:08:13 <arw> (otoh i shouldn't put my glasses in places i won't find them later...)
22:08:22 <JoeyA> Is it safe for compare a b to be EQ, yet a == b be false?
22:08:51 <JoeyA> For instance, consider an alternative semantic for instance Eq Maybe where Nothing /= Nothing
22:08:52 <bss03> JoeyA: What is safe?
22:09:16 <JoeyA> But you still want to be able to sort out Maybes so the Nothings will all be pushed to the side and not group'd together.
22:09:28 <JoeyA> As in, is it "weird", is it "wrong", etc. to do that.
22:09:34 <roconnor> JoeyA: I think so
22:09:40 <kmc> JoeyA, i would say it's weird and wrong
22:09:40 <roconnor> JoeyA: in some cases
22:09:42 <bss03> JoeyA: I think it is wierd.
22:09:49 <kmc> define a new class, or just a Maybe-specific function
22:09:58 <arw> JoeyA: i guess its ok, i can think of one case where i would do something like that: lexical sorting.
22:10:26 <bss03> JoeyA: I think maybe a newtype wrapper that provides separate Eq and Ord instances and had a comment would be documentation enough, though.
22:10:27 <JoeyA> (note: I'm not redefining instance Eq of Maybe itself)
22:10:33 <arw> JoeyA: compare "Schäfer" "Schaefer" should give EQ (at least in german) but its not ==.
22:10:46 <JoeyA> interesting
22:10:49 <bss03> JoeyA: I can see why you might want those semantics, I guess.
22:10:55 <roconnor> JoeyA: I don't think I'd use it in that situation
22:11:00 <kmc> there's a class for partial orders somewhere
22:11:16 <roconnor> JoeyA: I was more thinking that NaN /= NaN but compare NaN NaN = EQ
22:11:29 <kmc> floating point is just evil
22:11:32 <JoeyA> right
22:11:36 <kmc> we can expect that kind of stupidity from it
22:11:44 <kmc> but not from a nice good type like Maybe ;P
22:12:06 <JoeyA> Well, in my case, I'm comparing two file's st_dev/st_ino to see if they're hardlinked together.
22:12:11 <bss03> roconnor: But, doesn't NaN == NaN always return false? (by IEEE fiat?)  Sort of like NULL = NULL is false in SQL?
22:12:14 <JoeyA> (and I have both fields Maybe'd)
22:12:41 <bss03> Why do you have the fields Maybe'd?
22:12:47 <JoeyA> If it can't get the st_dev/st_ino, then it'll assume it's not equal to anything.
22:13:17 <JoeyA> I basically wrapped Stat in a container that Maybes a bunch of special fields that tend to be OS-specific.
22:13:18 <ulfdoz> bss03: NULL = NULL isn't false in SQL, it is NULL.
22:13:37 <JoeyA> or transient
22:13:46 <bss03> Well, NULL is equivalent to FALSE in a Boolean context.
22:13:53 <arw> no.
22:13:57 <JoeyA> Mainly so the stat information can be stored portably, at least in theory.
22:14:10 <roconnor> bss03: yes that is my point
22:14:20 <arw> bss03: a boolean in sql can be TRUE, FALSE or NULL
22:14:34 <roconnor> I think of EQ as being a parital equivalence relation
22:14:40 <JoeyA> Maybe the non-comparables should be shoved to the side rather than be involved in the sort.
22:14:41 <bss03> I *know* it can have 3 values.
22:14:52 <roconnor> so if a == a is false, then that value is "outside the domain"
22:14:59 <bss03> But, if you do if NULL then stuff1 else stuff2, you get the stuff2.
22:15:04 <bss03> It is equivalent to FALSE.
22:15:11 <roconnor> and thus any (other) function can do random things with it
22:15:22 <JoeyA> meh, compare NaN NaN = EQ is simple enough.
22:15:28 <roconnor> at least that is how I justify the NaN nonsense
22:16:51 <roconnor> how is being shoved to the side different from comparing larger or smaller than everything else?
22:17:24 <bss03> > sort [Nothing, Maybe 4, Nothing, Maybe 2, Nothing]
22:17:25 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe'
22:17:36 <bss03> > sort [Nothing, Just 4, Nothing, Just 2, Nothing]
22:17:37 <lambdabot>   [Nothing,Nothing,Nothing,Just 2,Just 4]
22:17:55 <ulfdoz> bss03: The reason you get that is, NULL <> TRUE, thus the first if doesn't hold. You would also get in if NOT x <> NULL then ... else the else part.
22:18:00 <arw> bss03: it is _not_ equivalent to false, only in very special cases.
22:18:35 <arw> bss03: if i = NULL then stuff else something will always do 'something', never 'stuff', even if i is NULL.
22:19:24 <bss03> Right, because NULL (the value of i = NULL for all values of i) is equivalent to FALSE in the Boolean context.
22:20:24 <arw> bss03: no, damnit. only in that special context, not in any boolean context.
22:20:47 <arw> insert (i = NULL) into something will NOT insert FALSE...
22:21:15 <bss03> arw: I agree with you there.  That's an SQLBoolean, not a true Boolean context.
22:21:34 <bss03> True Boolean contexts you CAN'T treat it as NULL -- NULL isn't in the Boolean set.
22:21:42 <ulfdoz> bss03: No, it is not true. "(i = NULL) IS NULL" is true, while "false IS NULL" is false.
22:22:08 <bss03> When it HAS to be True/False (a REAL Boolean context) it is FALSE.
22:23:29 <arw> bss03: also not correct. insert (NULL) into a boolean NOT NULL column will be an exception, not an insert (FALSE), although that would be a real boolean context.
22:23:31 <FunctorSalad_> hmm network isn't a ghc library?
22:24:09 <arw> bss03: NULL is only false in an 'if' because it has the same consequences in that case, not because it really IS the same.
22:24:20 <bss03> arw: I disagree that that is any more a true boolean context than a column without the NOT NULL contraint.
22:26:26 <bss03> Plus, it's not an exception if you contraints are currently deferred.
22:28:27 <ulfdoz> With the same argument, non-strict lazy evaluation of boolean expressions can't be a boolean context. Consider "(i = i) or (i/0 > 0)".
22:31:32 <etpace> @hoogle [Maybe a] -> Maybe [a]
22:31:33 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:31:33 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
22:31:33 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
22:32:20 <mtnviewmark> note that the semantics of sequence and catMaybes are different
22:32:41 <etpace> sure
22:33:17 <mtnviewmark> I love those two --- because one of them is always exactly what I need!
22:33:54 <mm_freak> why isn't Bool a Bits instance?
22:35:08 <kmc> :t msum
22:35:09 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
22:38:26 <JoeyA> :t (>>=)
22:38:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:38:39 <JoeyA> Hmm, what does the * -> * mean?
22:39:21 <JoeyA> :t compare
22:39:22 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
22:39:35 <JoeyA> :t fromMaybe
22:39:36 <lambdabot> forall a. a -> Maybe a -> a
22:39:58 <oscillo> :t Ord
22:39:59 <lambdabot> Not in scope: data constructor `Ord'
22:40:03 <kmc> * -> * is a kind
22:40:12 <JoeyA> lambdabot isn't responding to :t via PM, by the way
22:40:13 <kmc> kinds classify types and type constructors, the way that types classify values
22:40:19 <kmc> JoeyA, in PM you use @type
22:40:27 <kmc> it recognizes :t as a special case here only
22:40:33 <JoeyA> Ah
22:40:47 <kmc> JoeyA, saying (m :: * -> *) says that the type variable 'm' has to be instantiated at something that's not a type, but a 1-argument type constructor
22:41:02 <kmc> IO and Maybe and (Either String) are monads
22:41:16 <kmc> they are all of kind * -> *, meaning they accept a type and return a type
22:41:37 <kmc> * is the kind of types themselves, those which have values
22:41:50 <kmc> if v is a value and v :: t, then you know that t :: *
22:42:16 * copumpkin wants higher-kinded values
22:42:19 <JoeyA> can (,) be considered of kind * -> * ?
22:42:22 <JoeyA> :t (,)
22:42:23 <lambdabot> forall a b. a -> b -> (a, b)
22:42:24 * copumpkin ponders what that would mean
22:42:31 <JoeyA> Or does that only make sense for type constructors?
22:42:32 <copumpkin> JoeyA: on the type-level, it would be * -> * -> *
22:42:35 <copumpkin> :k (,)
22:42:36 <lambdabot> * -> * -> *
22:42:42 <JoeyA> oh
22:42:48 <copumpkin> :k (->)
22:42:49 <lambdabot> ?? -> ? -> *
22:43:29 <JoeyA> Is (->) as an operator some kind of extension?
22:43:39 <copumpkin> nope
22:43:56 <mm_freak> JoeyA: haskell's syntax is quite consistent compared to other languages
22:44:11 <mm_freak> > (id :: (->) a a) 15
22:44:12 <lambdabot>   15
22:44:46 <mm_freak> > Left 3 :: Integer `Either` String
22:44:46 <lambdabot>   Left 3
22:44:59 <c_wraith> I want type operator sections
22:45:07 <c_wraith> ...  For no particular reason
22:45:14 <mm_freak> i want type lambdas
22:45:17 <mm_freak> for several reasons
22:45:32 <copumpkin> you need one for the other
22:45:51 <copumpkin> maybe you could have special-cased operator sections without general lambdas actually
22:46:15 <mm_freak> copumpkin: having a type flip operator makes it equivalent to lambda calculus?
22:46:45 <JoeyA> :k compare
22:46:46 <lambdabot> Not in scope: type variable `compare'
22:47:25 <mm_freak> anyway, partially applied type synonyms would suffice, but it would make the type system turing-complete
22:47:31 <kmc> JoeyA, as others hinted, the data constructor (,) has no kind (it's a value; it has a type) but the type constructor also named (,) has kind * -> * -> *
22:48:01 <kmc> mm_freak, type synonym families?
22:48:16 <mm_freak> kmc: i don't think that's what i'm looking for
22:48:21 <kmc> JoeyA, the kind of (->) is a long story, i can explain if desired
22:48:24 <mm_freak> i'm looking for this:
22:48:26 <kmc> to first approximation it is * -> * -> *
22:48:40 <kmc> because (->) is a binary type constructor like Either or ST
22:48:43 <mm_freak> type StateT s m a = s -> m (a, s)
22:48:54 <mm_freak> instance Monad m => Monad (StateT s m) where …
22:49:11 <mm_freak> but haskell doesn't allow that, because the type synonym isn't fully applied
22:49:44 <mm_freak> and it would also allow monadic functions to be arrows without that nasty Kleisli constructor
22:49:57 <kmc> that would come down to overlapping instances for (->)
22:50:01 <kmc> a bad idea imo
22:50:13 <mm_freak> indeed
22:51:22 <mm_freak> kmc: on the other hand you wouldn't need the (a -> b) instance anymore
22:51:32 <mm_freak> because (a -> Id b) would suffice
22:51:47 <kmc> ;P
22:51:54 <mm_freak> type Id a = a
22:51:56 <mm_freak> =)
22:55:58 <mm_freak> hmm, 'type' effectively makes type functions, doesn't it?
22:56:09 <mm_freak> type Flip f a b = f b a
22:56:34 <kmc> they aren't first-class though
22:56:43 <mm_freak> i see
22:56:46 <kmc> as you noted, you can't make an instance for a partially-applied type synonym
22:56:54 <kmc> or use a partially-applied synonym as a type parameter
22:58:02 <kmc> type synonyms are basically macros that don't participate in the later stages of type checking
22:58:31 <kmc> i don't know much about systems with "real" type functions
22:58:38 <kmc> it's one axis of the lambda cube
22:58:46 <kmc> i guess it's discussed in TaPL but i don't remember it that clearly ;P
23:01:27 <mm_freak> so agda must have them, right?
23:02:40 <kmc> generally once you have dependent types, you unify the value and type levels syntactically
23:03:18 <kmc> at which point you have only one lambda
23:04:30 <mm_freak> ok
23:04:47 <kmc> and a λ on one side of :: gives rise to a ∀ on the other side
23:04:55 <kmc> left, right sides respectively
23:05:22 <kmc> at that point, S → T is just sugar for ∀ (_ : S). T
23:10:20 <chrisdone> how is that different to haskell?
23:15:22 <copumpkin> chrisdone: which part?
23:15:31 <copumpkin> the (_ : S) you can't do in haskell
23:15:37 <copumpkin> or rather
23:15:43 <copumpkin> (x : S) wouldn't work :)
23:16:11 <kmc> in Haskell there are value and type levels
23:16:31 <copumpkin> in agda types are just values of the next universe up
23:16:42 <kmc> \x -> case x of True -> Bool; False -> Char
23:16:45 <kmc> can't do stuff like that
23:18:11 <Nibble> kmc: Why would anyone want to do that?
23:18:22 <kmc> that's a silly contrived example
23:18:31 <copumpkin> Nibble: proofs often do that with the empty type and unit type as output types
23:18:37 <kmc> anyway dependently typed programming is nifty
23:18:45 <kmc> you can state and prove any property of your code in its type
23:18:48 <kmc> www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
23:18:48 <copumpkin> Nibble: but there are plenty of reasons to even do something like that
23:19:17 <copumpkin> Nibble: one reason I have something like that (although defined as a datatype, same basic idea) is to emulate haskell's repa
23:19:45 <copumpkin> Nibble: in repa, you have arrays of any dimension, and you have shapes of arrays
23:19:50 <copumpkin> where the shape is effectively a list of dimensions
23:20:08 <Nibble> kmc: are you from swe?
23:20:08 <copumpkin> so if you have a 3 x 4 x 6 3d array
23:20:26 <Nibble> copumpkin: ok
23:20:40 <kmc> swe?
23:20:43 <copumpkin> so a valid index of a 3 x 4 x 6 array might be (1,1,1)
23:20:47 <copumpkin> but not (5,1,1)
23:21:01 <copumpkin> so I have a function that takes a shape and returns the type of valid indices for that shape
23:21:13 <copumpkin> so I can write index : Array shape element -> Index shape -> element
23:21:29 <copumpkin> and it is safe by construction
23:21:31 <Nibble> kmc: thought of the chalmers link (.se)
23:21:34 <Nibble> but nvm.
23:21:51 <copumpkin> anyway, it's pretty awesome
23:21:58 <copumpkin> completely addictive
23:24:04 <copumpkin> too much agda will make you do ridiculous type-level crap inhaskell too
23:26:41 <copumpkin> not that there's such a thing as too much agda
23:27:53 <mm_freak> i wonder if there is a more advanced formalism, which beats every corner of the lambda cube
23:27:54 <Nibble> copumpkin: so you prefer agda over haskell?
23:28:03 <copumpkin> depends
23:28:08 <kmc> mm_freak, pure type systems
23:28:15 <copumpkin> mm_freak: I'm not sure agda really fits the lambda cube very cleanly
23:28:22 <mm_freak> kmc: what does that mean?
23:28:27 <copumpkin> Nibble: it's missing some nice things that I like in haskell
23:28:30 <kmc> http://en.wikipedia.org/wiki/Pure_type_system
23:28:33 <bss03> ulfdoz: Agreed, since in haskel Bool isn't just True or False.  It is True, False, or _|_.
23:28:33 <Nibble> copumpkin: eg.?
23:28:54 <bss03> (Really, I guess anything non-strict has _|_ or the equivalent)
23:28:59 <copumpkin> Nibble: no typeclasses, at the programming level
23:29:24 <mm_freak> also haskell has much shorter type signatures =)
23:29:33 <mm_freak> and they're optional, too
23:29:45 <Nibble> mm_freak: type inference(?) ftw
23:29:48 <copumpkin> they're semi-optional in agda too
23:30:06 <Nibble> copumpkin: semi like in semi-trucks?
23:30:06 <copumpkin> but yeah, the fact that you can write arbitrary programs in types does mean they can be long :)
23:30:07 <bss03> What's semi-optional?
23:30:15 <bss03> You mean optional if they are monomorphic?
23:30:37 <copumpkin> the only place type signatures are forced is for functions if they bind parameters directly
23:30:38 <copumpkin> like 
23:30:40 <copumpkin> f x = ...
23:30:45 <copumpkin> f would need a type sig
23:30:50 <copumpkin> if you write f = \x -> ...
23:30:56 <copumpkin> it would not need one, but it would be yellow :)
23:31:18 <copumpkin> so in practice, you need type sigs on all top-level functions, but you can often get away with not putting them on values
23:31:38 <copumpkin> and things you define inline often have enough context so you don't need to specify their types explicitly
23:32:01 <Nibble> copumpkin: I had this strange code that needed a type
23:32:11 <Nibble> Inline types me no like.
23:32:21 <bss03> Idiomatic Haskell uses types on all top-level definitions anyway, so little difference in practice?
23:32:23 <copumpkin> you can't even write inline types in agda
23:32:29 <copumpkin> bss03: exactly
23:32:31 <mm_freak> kmc: interesting
23:32:44 <copumpkin> mm_freak: if you want to play with one, dolio has a nice one
23:33:53 <copumpkin> of course, it's on code.haskell.org and that happens to be down right now
23:34:02 <mm_freak> copumpkin: with what?
23:34:10 <copumpkin> how do you mean?
23:34:23 <mm_freak> "play with one"
23:34:33 <copumpkin> oh, with a pure type system
23:34:52 <copumpkin> it's written in haskell I think
23:35:09 <mm_freak> well, honestly i'm not using agda, because i know how haskell demotivated me of using other languages
23:35:17 <mm_freak> i can't write a single program in C without CPS
23:35:37 <Adamant> mm_freak: just translate it to SSA :P
23:35:49 <mm_freak> using agda or a PTS would demotivate me to use haskell =)
23:35:58 <copumpkin> mm_freak: I thought I'd feel that way about learning agda
23:36:05 <copumpkin> but it definitely is nowhere close to being a haskell replacement
23:36:06 <mm_freak> Adamant: SSA?
23:36:13 <Adamant> Single Static Assignment
23:36:25 <copumpkin> mm_freak: but it's amazingly interesting to learn and play with
23:36:36 <Adamant> CPS and SSA are mostly formally equivalent
23:36:42 <mm_freak> copumpkin: that's probably because agda is in an early stage of development
23:36:46 <Adamant> probably not the CPS you meant
23:37:00 <mm_freak> Adamant: continuation passing style
23:37:12 <copumpkin> mm_freak: sure, but it's worth broadening horizons, and it just makes me play with what's possible at the type level in haskell more :)
23:37:26 <Adamant> yeah, there's doing that with call/cc and there's doing it as a compile tech
23:37:28 <mm_freak> void *withFile(const char *fileName, void *(*k)(FILE *));
23:37:46 <Adamant> the two compiler tech ones are formally equivalent
23:37:57 <Adamant> with like some exception I don't remember
23:37:58 <mm_freak> copumpkin: i've read a lot about agda and i could probably write simple programs
23:37:59 <SubStack> I should port my CPS asynchronous RPC system to haskell
23:38:19 <SubStack> you can pass references functions between sides of the connection
23:38:36 <copumpkin> mm_freak: satisfying the termination checker can be difficult :) but apart from that, yeah, sure, it's almost the same as haskell for writing programs with haskellish types
23:38:40 <chrisdone> I'll try agda at some point. be nice if I can mix it with haskell
23:38:48 <copumpkin> except that you need coinduction for anything infinite
23:38:52 <copumpkin> and that gets more painful :)
23:39:16 <mm_freak> is there a real IO system for agda or do you need to use haskell for that?
23:39:32 <copumpkin> it can FFI out to haskell, and there's a module that binds to the basic System.IO calls iirc
23:39:39 <copumpkin> but most people writing agda never run it :P
23:39:55 <chrisdone> masturbation at its most profound level
23:39:56 <mm_freak> yes, but that doesn't really fit into agda's type system
23:40:06 <copumpkin> mm_freak: you mean the partiality?
23:40:10 <mm_freak> yeah
23:40:15 <copumpkin> yeah, you lie to it
23:40:24 <copumpkin> but it's inevitable
23:40:36 <copumpkin> if you're interfacing with the outside world, it's up to you to make correct statements about it to the language
23:40:49 <mm_freak> why?  i think the early IO system of haskell was based on codata
23:41:01 <mm_freak> something similar should work in agda
23:41:08 <copumpkin> that is how IO works
23:41:17 <copumpkin> to allow non-terminating programs
23:41:58 <copumpkin> I just don't think many people have really done much with agda's IO module because not many people write real programs in it
23:42:06 <mm_freak> anyway, agda seems to be amazing, but i'm quickly demotivated
23:42:10 <copumpkin> they tend to be simple pure algorithms that you prove stuff about 
23:42:16 <copumpkin> or just abstract mathematical properties
23:42:22 <mm_freak> i know how painful it is for me to write a program even in advanced languages like F#
23:42:38 <copumpkin> :)
23:42:49 <copumpkin> agda-mode really helps out
23:43:00 <mm_freak> that's not what i mean
23:43:12 <copumpkin> you mean that it'll put you off haskell?
23:43:17 <mm_freak> yes =)
23:43:25 <copumpkin> as I was saying, I don't think it will :P
23:43:34 <copumpkin> many things are fundamentally more tedious in it
23:43:54 <mm_freak> when i read a tutorial into agda, i really got to miss dependent types
23:43:59 <copumpkin> :)
23:44:19 <copumpkin> we really need to find a good way to do generic programming in a dependently typed language
23:44:22 <mm_freak> (later i realized i don't really need them…  i don't need to prove every single character of my code)
23:44:29 <copumpkin> because it's so common to define your own datatype that preserves properties you want in the indices
23:44:45 <copumpkin> like you can have a dozen list-like things that preserve different properties
23:45:05 <mm_freak> some of them can be encoded quite easily in haskell using GADTs
23:45:11 <copumpkin> yeah I know
23:45:17 <mm_freak> including length and sortedness
23:45:31 <copumpkin> sortedness?
23:45:35 <mm_freak> yeah
23:45:50 <mm_freak> mergeSortedLists :: List Sorted a -> List Sorted a -> List Sorted a
23:45:57 <mm_freak> or even:
23:46:19 <mm_freak> mergeSortedLists :: Add l1 l2 l3 => List Sorted l1 a -> List Sorted l2 a -> List Sorted l3 a
23:46:26 <copumpkin> that seems dependent, unless you're just using it as a tag
23:46:37 <copumpkin> or are reflecting all values into the type-level at some point
23:46:43 <mm_freak> it's not
23:46:50 <mm_freak> i tried it =)
23:47:06 <copumpkin> what do the constructors for List sortedness a look like?
23:47:26 <mm_freak> data Sorted; data Unsorted
23:47:29 <copumpkin> (leaving out the length as that's quite simple)
23:47:59 <mm_freak> data List s a where Nil :: List Sorted a; Cons :: a -> List s a -> List Unsorted a
23:48:23 <mm_freak> sort :: List s a -> List Sorted a
23:48:31 <copumpkin> so the only sorted list is an empty list? :P
23:48:37 <copumpkin> you need another constructor there
23:48:48 <mm_freak> or a list passed to the 'sort' function
23:49:13 <copumpkin> huh
23:49:16 <mm_freak> but this is a compile-time check, so a list coming from a file can never be sorted
23:49:29 <copumpkin> there's no way you can construct a non-empty list that's Sorted
23:49:40 <copumpkin> according to your data definition up there
23:49:42 <mm_freak> but it guaratees that lists passed to 'mergeSortedLists' have been passed through 'sort' first
23:50:11 <mm_freak> hmm…  i see your point
23:50:34 <copumpkin> I can see doing this with a phantom type
23:50:53 <copumpkin> and forcing you to pass through sort to get a List Sorted a
23:51:17 <mm_freak> hmm
23:51:23 <mm_freak> a SortedCons constructor would help
23:51:33 <mm_freak> but it would need to be hidden
23:51:39 <copumpkin> yeah, but it would need to take a proof of a being less than head of the second parameter
23:51:53 <copumpkin> which would require lifting all your values up to the type levl
23:52:16 <mm_freak> a sortedCons function would suffice, wouldn't it?
23:52:35 <mm_freak> sortedCons :: a -> List Sorted a -> Maybe (List Sorted a)
23:52:53 <copumpkin> if you're willing to trust that only well-behaved functions touch the hidden constructor of List
23:53:03 <mm_freak> yeah, that's the point
23:53:08 <copumpkin> ah okay
23:53:31 <copumpkin> but you'd have to prove the well-behaved-ness of the sort function by hand
23:53:55 <mm_freak> or you have 'sort' use 'sortedCons'
23:54:17 <copumpkin> well, sortedCons (with your original List definition) can still only return Just Nil or Nothing
23:54:21 <Gilly> Hey, does anyone know if there's a package that could perform Gauss-Jordan on matrices with elements from F_2?
23:54:38 <Nereid> wouldn't dependent types be nice
23:54:51 <mm_freak> copumpkin: no, 'sort' would have access to the hidden constructor
23:54:56 <mm_freak> uhm
23:54:57 <mm_freak> no
23:55:07 <mm_freak> it wouldn't need to, actually, if it uses sortedCons
23:55:15 <mm_freak> i'll try this out
23:55:38 <copumpkin> okay, but in the end it's effectively behaving like a phantom type
