00:01:40 <shachaf> Does Applicative have an equivalent of MonadPlus?
00:02:06 <ski> shachaf : `Alternative', iirc
00:02:16 <shachaf> ski: That's not really the same thing, is it?
00:02:21 <shachaf> > [1] `mplus` [2]
00:02:22 <lambdabot>   [1,2]
00:02:24 <shachaf> > [1] <|> [2]
00:02:25 <lambdabot>   [1,2]
00:02:27 <shachaf> Oh.
00:02:41 * shachaf is wrong. Never mind.
00:03:11 <rschnck> Is...this inching on right? myReverse (x:xs) = myReverse (xs:(xs ++ x))
00:03:17 <rschnck> Not sure what to do for my base case.
00:03:30 <evant_> rschnck: Whats the reverse of an empty list?
00:03:36 <rschnck> []
00:03:51 <evant_> There you go!
00:03:52 <shachaf> rschnck: That approach won't really work.
00:03:56 <rschnck> shachaf: Didn't think so
00:04:29 <shachaf> rschnck: You can't add to the end of a linked list except by traversing the entire list and constructing a new one.
00:05:23 * shachaf isn't sure what you're trying to do, actually.
00:05:30 <rschnck> Trying to reverse a list.
00:05:58 <rschnck> Trying to sort of following the logic of [1,2,3,4] , we then move 1 to the back and get  [2,3,4,1]
00:06:10 <rschnck> Oh wait
00:06:12 <rschnck> That won't work =/
00:06:17 <shachaf> rschnck: There is no "moving", exactly.
00:06:28 * hackagebot roman-numerals 0.4 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.4 (RoelVanDijk)
00:06:29 <shachaf> rschnck: What you want to do is probably construct a new list, except do it backwards.
00:07:37 <ski> `[1,2,3,4]' is a list of the `x:xs' case, namely `x' is `1' and `xs' is `[2,3,4]'
00:07:56 <rschnck> So we want x to be 4 and xs to be 3,2,1
00:08:01 <ski> so, what list should you recursively call `myReverse' on ?
00:08:10 <rschnck> xs
00:08:35 <ski> yeah, and if `xs = [2,3,4]' then `myReverse xs = [4,3,2]' (since if it isn't we have a bug)
00:08:54 <ski> so, you now hold `1' in your left hand, and `[4,3,2]' in your right hand
00:09:09 <ski> what was the result you wanted `myReverse (1:[2,3,4])' to become ?
00:09:35 <rschnck> Lost me at the hand analogy
00:09:44 <rschnck> but you want it to become
00:09:48 <ski> sorry, that was just a figure of speech
00:09:48 <rschnck> 4:[3,2,1]
00:09:59 <ski> yeah, and that is `[4,3,2,1]'
00:10:18 <ski> so, if the input is `[1,2,3,4]', then `x' will be `1' and `xs' will be `[2,3,4]'
00:10:23 <rschnck> Yep
00:10:35 <ski> then if you call recursively on `xs' then `myReverse xs' will be `[4,3,2]'
00:10:35 <rschnck> so x needs to be merged
00:10:37 <rschnck> with xs
00:10:49 <rschnck> Oh
00:10:50 <ski> and now you want to combine `1' and `[4,3,2]' into `[4,3,2,1]'
00:11:15 <rschnck> so myReverse xs ++ x?
00:11:20 <ski> almost :)
00:11:40 <ski> remember `myReverse xs' is a list of digits, but `x' is not a list of digits, it's just a single digit
00:11:58 <ski> `++' wants lists as both arguments
00:11:58 <rschnck> myReverse xs ++ [x]?
00:12:03 <ski> yes ! :)
00:12:14 <rschnck> Woot!
00:12:32 <rschnck> Does it usually take a while to get the concept of recursion stuck into your head?
00:12:34 <ski> > let x = 1; myReverse_xs = [4,3,2]  in  myReverse_xs ++ [x]
00:12:35 <lambdabot>   [4,3,2,1]
00:12:41 <rschnck> Or am I just especially unlucky in the upstairs department
00:13:01 <ski> rschnck : yeah, it usually takes a little while, since it's not so common to think of ordinary concepts in terms of recursion
00:13:12 <rschnck> It's extremely neat, though
00:13:21 <rschnck> Especially at how small the resulting code is
00:14:24 <ski> rschnck : however, note that e.g. language is based on recursion. in "XXX kicks YYY", "XXX" and "YYY" can be any phrases specifying individuals, like "John kicks Fido", or "The happy man owning the butchery kicks the starving dog"
00:14:29 <kmc> rschnck, yeah.  it's infamously difficult to wrap your head around
00:14:48 <kmc> rschnck, you'll find that even a lot of successful professional programmers don't understand it, although the best ones will
00:15:10 <kmc> joel spolsky thinks that recursion and pointers are just about the most complicated things you could hope for an employee to understand
00:15:30 <shachaf> rschnck: You should read _The Little Schemer_.
00:15:32 <kmc> (but he should be taken with a grain of salt)
00:15:50 <kmc> and SICP, i think i recommended it before
00:15:54 <rschnck> ski: is it recursion since you define XXX and YYY first o.O?
00:15:55 <shachaf> rschnck: That's an excellent book that will probably improve your understanding of recursion by quite a bit.
00:16:03 <luite> using pointers in haskell quickly gets unreadable though, isn't there an edsl to make it prettier?
00:16:15 <kmc> it's called C ;)
00:16:17 <luite> hehe
00:16:25 <kmc> SICP is profoundly recursive -- not only do you write recursive functions, but you do things like implementing Scheme in Scheme
00:16:33 <rschnck> shachaf: I'll look for it tomorrow at the library :D
00:16:40 <rschnck> kmc: I still don't really udnerstand what SICP is
00:16:44 <kmc> it's a book
00:16:51 <kmc> _Structure and Interpretation of Computer Programs_
00:16:55 <medfly> the little schemer is so user friendly
00:16:57 <ski> rschnck : it is recursion since you can say "The happy man kicks the dog" but also "The happy man owning the butchery kicks the starving dog". note how both "the happy man" and "the butchery" and "the happy man owning the butchery" is specifying individuals
00:17:01 <kmc> by Abelson, Sussman and Sussman
00:17:07 <kmc> available free online at http://mitpress.mit.edu/sicp/
00:17:10 <medfly> it instructs you to take a break and have a peanut butter jelly sammich.
00:17:14 <kmc> used in the intro CS courses at many top schools
00:17:17 <shachaf> kmc: I haven't read SICP, but TLS is specifically intended as a book to teach recursion.
00:17:21 <kmc> cool
00:17:37 <rschnck> kmc: Oh right, you linked me before. Sorry, I'm not paying attention.
00:17:40 <ski> rschnck : but note how the last of those three contains the former two as *parts*. that's recursion for you. just like a non-empty list contains a first elament, *and* another list (the rest of the elements)
00:17:45 <shachaf> It ends by deriving the Y Combinator, I think.
00:18:08 <shachaf> (Actually, by writing a small Scheme interpreter, I think? Something of that sort.)
00:18:20 <rschnck> ski: Aha
00:18:42 <rschnck> I'll look at the little schemer
00:18:48 <rschnck> If it piques my interest, I'll dive into the MIT stuff.
00:19:02 <rschnck> But I'm going to a school that's often rated #1 in workload...so again, time-permitting.
00:19:21 <medfly> heh.
00:19:31 <shachaf> rschnck: Is this a class at Reed?
00:19:48 <rschnck> shachaf: Yes, Math 121
00:19:51 <rschnck> Intro to Computation
00:22:08 <SecondOrderSalad> hmm is it fundamentally impossible to make the 'parse error - possibly incorrect indentaton' error more informative?
00:22:24 <SecondOrderSalad> I waste quite some time finding the (usually) missing parenthesis/bracket
00:22:45 <shachaf> SecondOrderSalad: Nope, not *fundamentally*.
00:23:08 <shachaf> For instance, you could write a GHC extension that @pastes your code and asks #haskell to find the bug. It'd probably work very well.
00:23:37 <rschnck> So I just defined revDig :: Int -> Int
00:23:37 <rschnck> revDig n = digitsReverse(myReverse(reverseDigits n)) 
00:23:40 <SecondOrderSalad> shachaf: I meant it in the sense that up to the line it tells me, it is probably still possible to extend the code to something valid
00:23:44 <rschnck> and the original problem....is complete!
00:23:45 <rschnck> : D
00:23:48 <SecondOrderSalad> shachaf: but the missing parens is usually way earlier
00:24:35 <SecondOrderSalad> it could use a heuristic to tell you possible positions where you may have wanted the parens maybe
00:24:56 <ski> rschnck : btw, now note that that can be written as `revDig n = (digitsReverse . myReverse . reverseDigits) n'
00:25:05 <shachaf> SecondOrderSalad: It could try inserting it at different places and see what type-checks. :-)
00:25:16 <ski> .. which can even be simplified to `revDig = digitsReverse . myReverse . reverseDigits'
00:25:18 <rschnck> ski: Oh, sort of like f o g in math?
00:25:25 <ski> rschnck : exactly :)
00:25:33 <ski> @src (.)
00:25:33 <lambdabot> (f . g) x = f (g x)
00:25:34 <lambdabot> NB: In lambdabot,  (.) = fmap
00:25:36 <shachaf> Hmm. Informative names there!
00:25:57 <ski> `f . g' is exactly like `f o g' in math, i.e. the composition of the functions `f' and `g'
00:26:15 <SecondOrderSalad> shachaf: revDig?
00:26:51 <ski> SecondOrderSalad : reverse the order of digits in a natural number, in base 10
00:26:54 <ketil> > (+1) . [1..10]
00:26:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
00:27:19 <ketil> Whoa!
00:27:38 <rschnck> ski: And splitting this up into three functions allowed us to work from right-to-left contiously
00:27:41 <rschnck> Which made it much easier.
00:27:43 <rschnck> Right?
00:27:46 <QtPlatypus> ketil: That is caleskell getting you again.
00:28:11 <shachaf> QtPlatypus: That is Caleskell getting you exactly where you want to be.
00:28:23 <medfly> hehehe
00:28:29 <ketil> Hm.  I guess I'll have to think about why that makes sense.
00:28:31 <ski> rschnck : yeah, the idea of splitting a large task/function into smaller ones, which can then be solved independently of each other, is a useful one
00:28:45 <QtPlatypus> shachaf: I aggry
00:29:04 <ski> rschnck : also, sometimes some of the parts you broke the problem into are useful in their own right, so can then be reused later
00:29:09 <medfly> :t (putStr . show)
00:29:10 <lambdabot> forall a. (Show a) => a -> IO ()
00:29:23 <medfly> @hoogle (Show a) => a -> IO ()
00:29:23 <lambdabot> Prelude print :: Show a => a -> IO ()
00:29:23 <lambdabot> System.IO print :: Show a => a -> IO ()
00:29:23 <lambdabot> System.IO hPrint :: Show a => Handle -> a -> IO ()
00:29:29 <rschnck> ski: Yeah, I should have a rschcnk module :P
00:29:34 <rschnck> rschnck*
00:30:25 <ski> rschnck : a common approach to solve a problem is to imagine that you have functions solving smaller problems, then you write a solution of the large problem in terms of the functions for the smaller problems, imagining that those functions already work. then after that, you turn to the problem of solving each of the smaller ones (possibly dividing yet again) .. this approach is called "top-down"
00:31:21 <rschnck> ski: Makes it much easier
00:31:29 <int80_h> rschnck : I found that doing recursive exercises in a modern lisp environment is very helpful towards understanding recursion.
00:31:36 <ski> rschnck : another approach is to imagine that you "probably" will need some smaller functions to be able to solve your main goal, so you write those small functions, then you write ones that use the ones you've previously written, &c. until you solve the main problem .. this approach is called "bottom-up"
00:32:22 <rschnck> Right. So we did bottom-up.
00:32:41 <ski> rschnck : the hard part about that approach is the guessing what small functions you will need (you might guess wrong, in which case you've solved sub-problems that you have no use for) .. the good part of this approach, though, is that you can test your small functions directly
00:33:04 <shachaf> ski: Another good part, potentially, is that your small functions may end up being more general.
00:33:10 <rschnck> ski: and the problem wasn't too complicated and required only three functions, so it worked well
00:33:25 * shachaf wonders if that's true.
00:33:26 <luite> the third approach is to stuff everything in a huge complicated calculation, after finding out that the other approches will never result in code that runs fast enough
00:33:29 <ski> rschnck : in the top-down approach, you can't always test much until you've got all the code written .. so it might be only then that you'll dicover earlier errors you've written
00:33:47 <ski> shachaf : yeah, that is part of the "small language" approach
00:34:17 <luite> fortunately that isn't required very often
00:34:25 <rschnck> shachaf: So you have the potential to create things that are useful for future things
00:34:28 <shachaf> int80_h: I think pencil and paper might be enough for the purpose of figuring out recursion.
00:34:37 <rschnck> shachaf: That's what I've been doing
00:34:42 <rschnck> I have a whiteboard and go through the calculation
00:34:45 <rschnck> Makes it very clear
00:34:57 <ski> rschnck : often a mixture of the approaches are useful. what order to do things in comes with experience (but is also partly a matter of personal style)
00:35:29 <rschnck> ski: Right. Well, I think I'll spend some more time with Haskell
00:35:41 <ski> happy hacking ! :)
00:35:51 <rschnck> My prof said it's sort of like a big scientific calculator
00:36:19 <rschnck> ski: and kmc thanks a ton for your help
00:36:26 <ski> yw
00:36:30 <rschnck> Bedtime. G'night.
00:36:36 <ski> night, rschnck
00:41:48 <ketil> There seems to be a huge amount of redundancy in Haskell now - (.) == fmap == <$>, return == pure, etc.  Doesn't this annoy people?
00:42:25 <shachaf> ketil: (<$>) = fmap is just by definition -- just a different name.
00:42:31 <etpace> i wouldnt say fmap == <$> is a redundency
00:42:33 <ski> `return = pure' is because `Applicative' is not a superclass of `Monad'
00:42:34 <shachaf> (.) = fmap is pretty arguable.
00:42:42 <etpace> but things like ++ and . id like generalised
00:43:13 <shachaf> And the return/pure (And (<*>/ap, liftA/liftM) business is for Haskell 98 compatibility.
00:43:20 <ketil> ski, but every Monad is Applicative, right?  So it *should* be a superclass, no?
00:43:27 <shachaf> etpace: (++) I agree on. But why should (.) be fmap?
00:43:27 <ski> ketil : yes
00:43:28 <QtPlatypus> map vs fmap always irked me
00:43:42 <ski> shachaf : generalization from the `(r ->)' functor
00:43:43 <shachaf> @ty (Control.Category..)
00:43:44 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
00:43:55 <etpace> shachaf: I thinik (+5) . [1..10] would be good :p
00:43:57 <shachaf> ski: Yes, but why should we use that generalization in particular?
00:44:01 <ski> QtPlatypus : in Haskell 1.4, `map' was the method of `Functor'
00:44:11 <ski> shachaf : that's a good question
00:44:20 <ski> @type flip
00:44:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
00:44:28 <ski> is the same kind of generalization, btw
00:44:38 * shachaf didn't know Cale generalized that one.
00:44:46 <QtPlatypus> ski: Why was it moved away from?
00:44:49 <ski> (i suggested it :)
00:45:20 <ski> QtPlatypus : well, aiui, to not confuse newbies with the most general form of an operation (especially in conjunction with type errors)
00:45:49 <shachaf> ski: So flip on [] is sequence on (r ->)?
00:46:02 <masak> when I try to compile one of the Hakyll examples (downloaded as a .zip file), GHC gives me a bunch of linker errors. why is that, you think?
00:46:16 <ski> shachaf : yes
00:46:28 <luite> hmm, I wonder whether that is important. c++ has become pretty popular for a language with often terrible type errors
00:46:33 <Jafet> masak: did you use --make?
00:46:39 <masak> no.
00:46:42 * masak tries that
00:47:06 <masak> Jafet: worked like a charm. what does --make do?
00:47:17 <Jafet> No idea
00:47:24 <Jafet> Let me read the manual
00:47:34 <ski> shachaf : it is interesting that `sequenceA' needs `Traversable' instead of `Functor' (and `Applicative' instead of the `(r ->)') .. compared to the above `flip'
00:47:35 <Veinor> --make makes things work :D
00:47:41 <ski> @type Data.Traversable.sequenceA
00:47:42 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
00:47:47 * masak has now read ghc --help, which provided some clues
00:48:10 <masak> "compile and link a complete Haskell program", it seems.
00:48:37 <ski> shachaf : btw, i didn't say i agree with the "not confuse newbies" argument. only that that's what i've heard was the resoning in Haskell 98
00:49:22 <Jafet> The linker, which is ld, doesn't know about Haskell modules.
00:49:42 <ski> shachaf : something similar to PLT Scheme^W^WRacket's teaching languages could be a nice idea, for a haskell implementation
00:49:54 <ski> (Helium has something like this, but i don't know that much about it)
00:50:16 * shachaf just found out about PLT's renaming a few days ago.
00:50:23 <ketil> > flip [(+1),(+2),(+3)] 0
00:50:24 <lambdabot>   [1,2,3]
00:50:35 <ketil> @type sequence 
00:50:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:52:10 <ski> in `sequenceA', the `Monad m' is generalized to `Applicative f' (which is an easy generalization, since we don't really need the full power of monads)
00:52:33 <ski> also, `[]' is generalized to an `t' which supports `Traversable t'
00:53:13 <ski> otoh, in `flip' above, `m' is always '(r ->)', while `[]' is generalized to any *`Functor'*
00:53:33 <ski> so it seems that `sequenceA' can't replace that `flip' in all cases
00:54:12 <ski> it might be interesting to have an abstraction of `(r ->)', which supports the above `flip' thing, for any `Functor'
01:00:18 <etpace> I have a function that when I explicitly type, I error
01:00:29 <etpace> but the typechecker infers a type correctly, even though they are the exact same type
01:00:32 <etpace> ideas?
01:00:43 <Veinor> post it?
01:01:35 <shachaf> etpace: Probably an extension.
01:01:37 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29695#a29695
01:01:53 <etpace> explicitly typing duplicateR gives me an error
01:02:07 <shachaf> What extensions are you compiling with?
01:02:46 <etpace> MultiParamTypeClasses, FlexibleInstances, ExistentialQUantification
01:03:32 <etpace> now just with multiparam and flexible instances
01:03:34 <etpace> same problem
01:03:49 <Veinor> I can replicate with just multiparam
01:04:28 <shachaf> What's the error?
01:05:21 <Veinor> http://pastebin.com/jUeLf7Bt
01:06:53 <dmead> hi channel
01:06:54 <etpace> o idea whats going on there
01:07:07 <dmead> whats it called when you compile from one high level language to another?
01:07:11 <dmead> static translation?
01:07:33 <QtPlatypus> dmead: I just always called it compiling
01:08:03 <dmead> yea, i think of that as involving machine specific stuff
01:08:38 <dmead> i'm really not interested in producing binaries, just translating between languages
01:09:18 <Jafet> You can compile a C program to LML, which is an obscure machine-specific language, and run it on a lisp machine.
01:09:48 <Jafet> Assuming you have a lisp machine. They cost so much nowadays.
01:10:05 <dmead> hehe
01:12:20 * ski thought LML was "Lazy ML", which the original haskell implementation was based on (not sure whether it compiled to LML or just reused most of the machinery of the compiler)
01:12:42 <ski> (augustss probably remember)
01:12:56 <ski> preflex: xseen augustss
01:12:56 <preflex>  augustss was last seen on freenode/#haskell 47 days, 11 hours and 55 minutes ago, saying: I've not been on in a while
01:13:53 <dmead> how not ironic
01:13:55 <dmead> hmm
01:16:13 <ski> etpace : in duplicateR :: (Channel a a1) => Readable a -> IO (Readable a)
01:16:28 <ski> it doesn't know which `a1' you want to use
01:16:39 <ski> (since it's not mentioned otherwise in the type signature)
01:16:56 <etpace> forall a1. didnt ffix it
01:17:08 <ski> because it is ambiguous
01:17:19 <ski> possibly you want to add a FD to the class ?
01:17:31 <etpace> but a c does not uniquely identify a n a
01:17:46 <etpace> how can it infer it without explicitly typing?
01:17:55 <ski> then how should it know *which* `Channel a a1' instance to use, when you call `duplicateR' ?
01:18:10 <orbital_fox> hello
01:18:30 <Necro_> hi
01:18:41 <Necro_> can you help me with haskeel?
01:18:49 <Necro_> it's my first minute in studying it
01:18:49 <ski> if you have `instance Channel Foo BarA' and `instance Channel Foo BarB', those two might do very different things in the `_duplicate' method
01:19:08 <ski> Necro_ : what is it you want help with ?
01:20:00 <ski> orbital_fox : and hello to you, too :)
01:20:26 <orbital_fox> hello ski 
01:21:36 <Necro_> I need help with this: "Define function which return square from arguments."
01:21:53 <Botje> what part are you having trouble with?
01:22:30 <Necro_> how to define functions in haskell?
01:22:35 <Botje> f x = x
01:22:42 <Botje> that's a function that returns its argument
01:22:53 <Botje> and it's good style to also give the type
01:23:00 <Botje> f :: Int -> Int
01:23:10 <Botje> (the actual type is more general, but Int will do for now , i guesS)
01:24:10 <Itkovian> Necro_: think about which type your argument may have. It should be squarable. How many arguments do you need? Do not forget the return type as well.
01:29:23 <Necro_> I defined the function:  let squar­e x = x * x in squar­e 10
01:29:32 <Necro_> how to run it?
01:31:13 <Botje> that already executes it
01:31:21 <ski> well, the simplest is to just enter that into GHCi or Hugs
01:31:34 <ski> for more permanent storage, enter
01:31:37 <nlogax> > let square x = x * x in square 10
01:31:38 <ski>   square x = x * x
01:31:38 <lambdabot>   100
01:31:41 <ski> into a file
01:31:54 <ski> and then load that file into GHCi / Hugs
01:31:55 <Necro_> but i want to run it again, like square(4)
01:32:17 <ski> so store it in a file ?
01:32:34 <ski> (in GHCi you can actually also say `let square x = x * x')
01:36:36 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29696#a29696 is it possible to do something like Writable and Readable without impredicativetypes which it says is deprecated
01:39:01 <Eltges> Hi, I have a question regarding the .hs file icons. Is there a specific reason, that they don't use the "new" haskell icon? >>
01:39:50 <McManiaC> can you ignore "Defaulting the following constraints to Integer" messages with -Wall?
01:57:04 * hackagebot leksah-server 0.8.0.7 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.7 (JuergenNicklischFranken)
02:04:41 <ski> etpace : those `Readable' and `Writable' there looks pretty useless
02:05:43 * ski is not exactly sure what etpace is wanting to do, though
02:08:48 <etpace> refactoring with trying to do the minimal amount of change
02:09:23 <ski> refactoring what ?
02:10:38 <ski> afaics, the only values of type `Readable a' and `Writable a' will be `undefined'
02:10:49 <ski> (which seems pretty useless, to me)
02:16:22 <etpace> asically ski, Channel used to be a datatype, but now some channels arnt polymorphic over the input a
02:16:43 <etpace> WRitable used to be Writable a = Writable (Channel a), and I'd like to keep that interface
02:17:19 <etpace> so people can write Writable a to specify only the vlaue of a, without having CHannel c Int => Writable c over the place
02:19:12 <ski> s/polymorphic over the input a/parametric over the input a/
02:19:22 <etpace> yeah :)
02:20:04 <ski> would `a' in `Writable a' typically be `Int' ?
02:20:19 <ski> (yeah, i suppose so)
02:20:41 <etpace> typically in what way?
02:20:49 <etpace> its a couple of different things over the place
02:21:14 <ski> it appears you want something like `type Readable a = exists c. Channel c a *> Readable_ (c a)'
02:21:52 <ski> (of course, that's currently not valid code (maybe in UHC))
02:22:01 <etpace> yeah thats what I need
02:22:07 <etpace> oh well, failed rfactor :p
02:22:16 <ski> you could of course define
02:22:38 <ski>   data Readable a = forall c. Channel c a => MkReadable (Readable_ (c a))
02:22:54 <ski> which would accomplish the same, except that then it becomes a new datatype
02:23:41 <ski> btw, it might be more useful to define
02:23:55 <ski>   data Readable a = forall c x. Channel c x => MkReadable (Readable_ (c x)) (x -> a)
02:24:07 <ski> that would make `Readable' into a `Functor'
02:26:36 <ski> anyway, you have two ambiguous methods in your class `Channel'
02:26:57 <ski> you might want to normalize, if you don't want to add an FD
02:27:26 <ski> (or otherwise rephrase the methods)
02:27:30 <etpace> mm ok
02:27:43 <ski> e.g. you could merge `    readFrom        :: Readable_ c -> IO a
02:27:51 <ski> ' and `    isEmptyReadable :: Readable_ c -> IO Bool
02:27:52 <ski> '
02:28:11 <ski> into `tryReadFrom :: Readable_ c -> IO (Maybe a)'
02:28:41 <ski> that way, you'd get rid of one of the ambiguous methods, at least
02:29:45 <ski> etpace : .. did you grasp what i meant by "normalize", btw ?
02:33:01 <ivanm> preflex: seen bos
02:33:01 <preflex>  bos was last seen on #haskell 2 days, 9 hours, 18 minutes and 49 seconds ago, saying: copumpkin: thanks!
02:37:10 <inertial> could you write a device driver in haskell?
02:37:32 <Jafet> A device driver to do what for what on what?
02:37:50 <Jafet> linux? Probably.
02:38:11 <inertial> say to control an lcd controller, on a microcontroller running an rtos
02:38:20 <inertial> or linux
02:38:59 <inertial> i'm just asking in general.. I don't know much about haskell and am an embedded developer
02:39:11 <ivanm> inertial: I think you need to write it in C and get it into the kernel
02:39:17 <ivanm> (or at least a locally patched version)
02:39:28 <inertial> can haskell be compiled to C?
02:39:31 <ivanm> there was a blog post or two about using some stuff from House to patch the linux kernel though...
02:39:35 <ivanm> inertial: not really
02:39:44 <ivanm> I mean, technically yes but IIRC it needs a lot of hand-holding
02:39:44 <Jafet> If you manage to get Haskell running on a microcontroller...
02:39:48 <ivanm> and it isn't readable C
02:39:54 <ivanm> and not the kind of C you'd need for a kernel patch
02:40:15 <inertial> in a more general sense though.. drivers are all about side effects
02:40:55 <ski> (rather about effects, i'd say)
02:41:08 <fasta> inertial, people have already written device drivers in Haskell for Linux.
02:41:28 <inertial> fasta: any links? i had trouble finding any
02:43:39 <fasta> inertial, not at this time, but there was a blogpost once of someone showing how to do it. You just include the right header files and you can call whatever Linux stuff you want via the FFI. 
02:44:15 <ivanm> don't expect to get it put into the mainline kernel though ;-)
02:45:24 <fasta> You could write a DSL which generates code which will be accepted into the mainline, but once it is accepted your generator is useless.
02:46:41 <fasta> If you would provide a ZFS implementation that was extremely high performance for example, I don't think the language would matter to users, though. 
02:47:15 <ivanm> true
02:47:25 <ivanm> except that then they'd need GHC installed as well...
02:47:35 <ivanm> and IIRC that blog post used a _patched_ GHC
02:50:44 <fasta> ivanm, still, they are still all numbers in the end. If you provide an installer, users won't care it has to be patched, because you can do it behind the scenes.
02:51:19 <ivanm> well, there already is a "patch it yourself" ZFS patch available...
02:54:27 <fasta> ivanm, is there also someone offering a pile of money in case something goes wrong?
02:54:38 <ivanm> ummm, dunno
02:54:42 <ivanm> can't recall that much
02:54:55 <fasta> ivanm, I mean, that's basically what banks will need. 
02:55:19 <fasta> Or large organizations that actually depend on all this enterprise stuff. 
02:55:34 <Jafet> Are you sure? Because I've seen ATMs running windows and shit
02:56:00 <fasta> Jafet, a crashing ATM is not important. 
02:56:12 <fasta> Jafet, 10000 crashing ATMs at the same time is important. 
02:56:40 <fasta> Jafet, the important systems run on mainframes. 
02:56:51 <fasta> Machines with an actual uptime of 20 years. 
02:57:54 <Jafet> I wonder how many machines in the world have had an uptime of 20 years
02:58:02 <earthy_> many.
03:00:12 <quicksilver> fasta: in practice, nobody really offers piles of money in case something goes wrong
03:00:23 <quicksilver> such agreements are rare, not always enforceable, and very very rarely enforced.
03:00:32 <quicksilver> it's just a game of reputation and PR
03:00:48 <quicksilver> people fix stuff because they don't want their reputation damaged not because there are financial penalties.
03:01:31 <ivanm> preflex: seen blackh
03:01:31 <preflex>  blackh was last seen on #haskell 6 hours, 9 minutes and 56 seconds ago, saying: int80_h: Also currently there is no ARM back end for GHC so it compiles via C.
03:03:42 <earthy> for the financial penalties there's insurance companies
03:04:29 <earthy> and most of the financial liability clauses in contracts are basically 'who gets to pay the insurers'
03:05:04 <Jafet> Ah, who will be the John Stapp of programming! Who will be the Ralph Nader! It might not be so good for your cred to be the Ralph Nader.
03:06:07 <quicksilver> earthy: but, in fact, in the case of a substantial disaster/problem, the insurers don't have the money to pay anyway :P
03:06:22 * earthy nods
03:06:59 <earthy> that's why there's 'act of god' clauses
03:07:31 * ivanm is reminded that he still hasn't seen "the man who sued god"
03:07:36 <inertial> GHC... global haskell crisis?
03:08:01 * ivanm backs away slowly from in
03:08:06 <ivanm> *inertial
03:13:37 <ski>   data Fib :: * -> *
03:13:44 <ski>     where
03:14:06 <ski>     Zero ::                           Fib               Void
03:14:21 <ski>     One  ::                           Fib        (Maybe Void)
03:14:37 <dmead> hey channellll
03:14:41 <ski>     Step :: Fib n -> Fib (Maybe n) -> Fib (Maybe (Maybe n   ))
03:14:52 <dmead> does anyone know how to get ghc to show the ast of the program it's compiling?
03:14:55 <dmead> either by flags or the api?
03:14:56 <ski>   data SomeFib = forall n. WrapFib (Fib n)
03:15:12 <ivanm> dmead: closest I know of is vacuum
03:15:27 <ski> is `Maybe SomeFib' non-recursively isomorphic to `(SomeFib,SomeFib)' ?
03:15:37 <Saizan> vacuum shows something more like the heap
03:15:48 <ivanm> oh, right
03:15:54 <dmead> yea thats not what vaccum does
03:15:55 <Saizan> dmead: there's a -ddump-parsed flag iirc
03:16:09 <dmead> i'm trying to start a project where i want to do a bunch of transforms on haskell programs
03:16:22 <dmead> and i'd rather not have to partially implement that stage of the compiler myself
03:16:52 <Saizan> and there's also a way in the ghc api to get ghc's ast after typechecking, probably even just after parsing
03:17:17 <Saizan> dmead: there's also haskell-src-exts
03:17:30 <dmead> Saizan, i'm looking here:
03:17:31 <dmead> http://www.haskell.org/haskellwiki/GHC/As_a_library
03:18:13 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/index.html <- check the haddock docs, even if they are not easy to navigate
03:18:22 <ivanm> Saizan: not sure if you could get the AST out from hsx
03:18:55 <ivanm> actually, you probably could
03:19:01 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/GHC.html <- this is probably the most interesting module
03:19:05 <dmead> hmm
03:19:24 <dmead> i got that example working from the wiki, but hpaste is messed up
03:19:34 <Saizan> ivanm: AST = Abstract Syntax Tree, isn't that all that hsx produces?
03:19:44 <dmead> hsx?
03:19:51 <Saizan> haskell-src-exts
03:19:52 <ivanm> yeah, I got confused
03:19:54 <dmead> whats hsx?
03:19:57 <quicksilver> dmead: I'm pretty sure haskell-src-exts is a better route than the GHC API.
03:19:59 <ivanm> haskell-srx-exts
03:20:02 <ivanm> ;-)
03:20:04 <dmead> hmm cool
03:20:05 <ivanm> s/srx/src/
03:20:07 <dmead> thanks guys
03:20:15 <ivanm> quicksilver: except that there's some stuff hsx can't parse
03:20:23 <ivanm> but yes, it'd be more stable and portable
03:20:37 <quicksilver> AFAIK it's what all the other program transform libraries are either using, or moving towards.
03:20:46 <ivanm> yup
03:20:48 <dmead> ahh
03:20:49 <dmead> kewl
03:21:01 <ivanm> it can't deal with mixed operators though
03:21:08 <dmead> thats fine
03:21:10 <quicksilver> mixed operators?
03:21:33 <ivanm> e.g. this confuses it: f . g &&& a . b
03:21:36 <Saizan> i think the problem with operators is that you've to pass it the fixities manually
03:21:43 <ivanm> it doesn't know about the relative fixities of those operators
03:21:53 <ivanm> if, however, you do "(f . g) &&& (a . b)" it's OK
03:22:03 <ivanm> hlint does a manual hack for some things like that
03:22:11 <Saizan> even if it has a table of the operators in base
03:22:16 <ivanm> Saizan: yeah
03:22:22 <ivanm> especially if you're overriding an operator
03:22:43 <dmead> quicksilver, isn't haskell-src-exts a package?
03:22:49 <ivanm> dmead: yes
03:23:00 <dmead> what should i be looking for?
03:23:10 <ivanm> what do you mean?
03:23:28 <dmead> whats in that package that can get you an ast from code?
03:23:54 <ivanm> dmead: haskell-src-exts parses haskell code to get the AST
03:24:13 <dmead> ah
03:24:58 <quicksilver> ivanm: Interesting. Doesn't sound too hard to teach it about fixities. Presumably it already follows 'import' statements so it can resolve symbol lookups?
03:25:31 <ivanm> quicksilver: don't think it follows anything tbh
03:25:45 <ivanm> ndm posted a bug on its trac; don't know if niklas got around to doing anything about it
03:26:09 <dmead> does compiling haskell to clojure sound like a bad idea?
03:26:44 <ivanm> yes
03:27:06 <dmead> why?
03:27:06 <ivanm> if anything just doing a JVM backend for GHC would probably make more sense rather than trying to do a language transformation
03:27:26 <ivanm> since it's highly unlikely that you'll be able to convert generic haskell code to readable clojure code anyway
03:27:53 <dmead> oh, i don't expect it to be readable at all
03:28:00 <dmead> just that'll work and past tests
03:28:04 <dmead> *pass
03:28:06 <ivanm> also, optimisation tricks typically don't work across languages
03:28:16 <dmead> true true
03:28:20 <ivanm> dmead: well then, have a look at bernie pope's burp; might give you an idea
03:28:36 <ivanm> and there's blackdog's hubris that is a haskell <-> ruby bridge
03:28:46 <dmead> ahh
03:28:49 <dmead> cool cool
03:28:59 <ivanm> OK, why is blackh only in here and blackdog only in #haskell.au ?
03:29:15 <dmead> yea i'm just thinking that it'd be a good rout to try and do things like TCO and such
03:29:30 <dmead> which you can't do directly on the jvm
03:29:39 <ivanm> if you want Haskell code to run on the JVM and interop with clojure, then port GHC to the JVM
03:29:45 <ivanm> don't try and do language mangling
03:29:47 <dmead> but converting TCO in haskell to normal iteration might get you someplace
03:29:47 <dobblego> yes you can
03:29:49 <ivanm> (IMHO, of course)
03:30:02 <dobblego> (and it does)
03:30:07 <dmead> it does?
03:30:11 <ivanm> dmead: I thought we didn't really have TCO in Haskell though...
03:30:18 <ivanm> dobblego: using trampolines or something, right?
03:30:27 <dobblego> /opt/ibm-java2-i386-50/bin/java
03:30:35 <dobblego> that does ^^
03:30:36 <dmead> ivan, i've heard many opinions on that, none authoritative 
03:31:17 <dmead> the guy that wrote clojure has said that he doesn't do TCO because it somehow won't work on the jvm
03:31:23 <dmead> which i thought was strange
03:31:39 <dobblego> Scala uses trampolining for JVMs that do not support TCO
03:32:23 <quicksilver> ivanm: Hmm. Maybe it's only intended as a parser.
03:32:35 <ivanm> quicksilver: well, and a printer
03:32:39 <quicksilver> ivanm: but program transformers want symbol resolution, maybe they have to do that on their own.
03:32:55 <quicksilver> unfortunately, in haskell, infix parser requires symbol resolution.
03:33:16 <ivanm> quicksilver: right; that's why hare can't use hsx (they wanted a semantic parser, which hsx doesn't have)
03:35:45 <Saizan> hlint seems to have a very simple approach to symbol resolution: check the name against a table
03:36:15 <dmead> ivanm, wouldn't porting ghc to the jvm require all sorts of work on the rts?
03:36:24 <Saizan> all "id" exported by any module look like Prelude.id to it :)
03:36:29 <ivanm> Saizan: I'm guessing that that's because hsx can't do it and doesn't provide any such info, so it does so to be able to work out what's going on when hsx fails
03:36:33 <ivanm> dmead: yup
03:36:43 <ivanm> which is probably why all previous attempts have failed
03:36:50 <ivanm> Saizan: heh, yeah
03:36:58 <dmead> right, which is why i think targeting clojure is a better idea
03:37:17 <dmead> i mean, you'll have to end up writting a bunch of support stuff in the clojure side
03:37:27 <Saizan> i don't think it'd require working on the RTS
03:37:32 <dmead> like pattern matching, etc
03:37:37 <Saizan> the JVM would be your rts.
03:37:52 <ivanm> dmead: a complete language transformation would probably be a PITA to do as well
03:37:59 <dmead> PITA?
03:37:59 <Saizan> you'd have to take GHC's Core or Cmm and spit java bytecode
03:38:04 <ivanm> unless you limit yourself to a sub-set of the language
03:38:10 <ivanm> dmead: pain in the proverbial
03:38:13 <dmead> xD
03:38:16 <dmead> right right
03:38:28 <dmead> you couldn't really just use anything in the standard library
03:38:47 <quicksilver> Saizan: it would require writing an entire RTS.
03:38:49 <dmead> it'll be parametrized differently than on the jvm etc etc 
03:38:58 <dmead> yea isn't much of the ghc rts in C?
03:39:04 <dmead> ie all of it?
03:39:14 <quicksilver> I use the word "entire" for shock value; it might be simpler than the GHC RTS because it could pass off some functionality to the JVM
03:39:18 <quicksilver> btu it's still a body of work
03:39:25 <quicksilver> dmead: the GHC RTS is in haskell and Cmm and C
03:39:31 <quicksilver> depending where you choose to draw the line
03:39:36 <dmead> ah
03:39:37 <quicksilver> correction
03:39:46 <quicksilver> the GHC RTS is in "GHC code" and haskell and Cmm and C
03:39:55 <dmead> yea, any sort of translation like this would have to be a subset 
03:39:55 <Saizan> i guess something has to implement the STG-machine
03:40:04 <Saizan> would you have to implement a GC though?
03:40:16 <dmead> no
03:40:29 <quicksilver> if you decide to delegate to the java GC you have to make every single haskell heap object a Java Object.
03:40:42 <quicksilver> I suspect that would slow things down by an order of magnitude or six ;)
03:40:50 <dmead> ahhh
03:40:58 <dmead> i'm not sure what the other jvm languages do
03:41:01 <quicksilver> haskell heap objects are very lightweight compared to java objects
03:41:04 <dmead> i'm sure they just use the jvm GC
03:41:14 <quicksilver> would you want every cons cell in a haskell list to be an Object?
03:41:24 <dmead> nope
03:41:32 <quicksilver> would be the simplest way though.
03:41:32 <Jafet> Shouldn't java have some sort of unboxing mechanism by now?
03:41:37 <dmead> that can't be how clojure does it
03:41:49 <quicksilver> Jafet: java has unboxed types, int/double etc
03:41:54 <dmead> yea i think the jvm isn't bound by what java needs
03:42:00 <quicksilver> but it doesn't have custom unboxed types, AFAIK.
03:42:29 <Jafet> Ah, it's like C++ over again
03:42:34 <dmead> what what?
03:42:35 <quicksilver> there has been at least one previous haskell->JVM attempt, I think
03:42:39 <quicksilver> might even have been two.
03:42:52 <dmead> quicksilver, they went right for jvm bytecode yea?
03:42:57 <dmead> do you remember the names?
03:43:27 <fasta> quicksilver, have you ever seen numbers?
03:43:44 <Saizan> it might be better to just go via JNI
03:43:50 <quicksilver> dmead: lambdavm was one
03:44:22 <quicksilver> fasta: you're referring to my penalty clause mumblings? I work in card processing / payments / banking / atms
03:44:38 <quicksilver> fasta: I was just giving some informal overview of my personal experiences.
03:44:53 <fasta> quicksilver, I mean performance numbers for any of the attempts of running Haskell on a JVM. 
03:45:00 <quicksilver> oh that.
03:45:01 <quicksilver> No.
03:45:07 <quicksilver> I never cared enough to follow the projects :)
03:45:28 <quicksilver> "LambdaVM is not vaporware"
03:45:34 <quicksilver> so claims http://www.cs.rit.edu/~bja8464/lambdavm/ ;)
03:45:51 <quicksilver> I've never heard of anyone actually *using* it though.
03:46:03 <quicksilver> (of course the fact I haven't heard of it doesn't mean it doesn't happen)
03:47:43 * quicksilver points interested parties to http://hackage.haskell.org/trac/ghc/ticket/2959
03:47:53 <dmead> sure sure
03:48:49 <quicksilver> it looks likely to die because nobody cares enough to keep it working
03:48:58 <quicksilver> like distributed haskell and mobile haskell and and and and...
03:49:54 <dmead> true true
03:49:57 <maltem> Today's random question of mine: I realize that the gdk layer is not completely covered in gtk2hs. Would it make sense to tackle a seperate gdk package? Afaik, it would give easy access to on-screen cairo&pango rendering without the need to link to full gtk.
03:49:59 <dmead> that ticket seems dead
03:52:17 <theorbtwo> Too many people inventing from short-term need rather then long-term need.
03:52:53 <theorbtwo> Looks like LambdaVM was written for a thesis.  It doesn't need to be merged or maintained for that.
03:53:08 <dmead> i'm trying to write mine for a thesis as well 
03:53:32 <dmead> or at least i'm trying to talk myself out of it, before i'm in up to my eyeballs
03:53:46 <quicksilver> theorbtwo: no, but I imagine the author believes or believed it was useful
03:54:10 <theorbtwo> quicksilver: Maybe, but he didn't actually have a use for it.
03:54:50 * theorbtwo wonders if it'd be useful for writing jme applications (for non-Apple phones).
03:54:59 <dmead> perhaps
03:55:06 <theorbtwo> Java ME, rather.
03:55:13 <dmead> it would get you haskell on android i think
03:57:59 <Saizan> they are working on getting haskell on android through JNI
03:58:11 <quicksilver> dmead: android doesn't use the JVM
03:58:44 <quicksilver> dmead: it uses the java programming langauge but a different (incompatible) VM called 'dalvik'
03:59:05 <quicksilver> that's why oracle are suing them. Well, sort-of.
03:59:09 <ivanm> Saizan: they are? who?
03:59:12 <dmead> yes
03:59:23 <dmead> but they provide a compiler to convert from jvm bytecode to dalvik
03:59:24 <quicksilver> ivanm: ipwnstudios
03:59:32 <quicksilver> (and maybe other people)
03:59:35 <ivanm> quicksilver: I thought they were working on native binaries, not dalvik
03:59:44 <quicksilver> yes, native
03:59:53 <quicksilver> Saizan said "JNI" which is Java Native Interface
03:59:57 <quicksilver> I thought that's what he meant
04:00:09 <dobblego> Java Nightmare Initiation
04:00:31 <ivanm> quicksilver: which is what I querying as well
04:00:32 <dmead> Java Nightmare Infiltration
04:01:25 <quicksilver> ivanm: right. I don't know, then ;)
04:02:44 <Saizan> ivanm: the native binaries have to have a dalvik wrapper to run afaik, and so they use JNI for that
04:03:47 <Saizan> also for interfacing with android's API i guess
04:28:19 <cch`> :t show
04:28:20 <lambdabot> forall a. (Show a) => a -> String
05:05:52 <revenantphx> that birds on a pole example is a pretty nice way to put it.
05:06:01 <revenantphx> makes a fair bit of sense.
05:14:11 <iocor> is there a haskell compiler that can target matlab?
05:16:55 * ski shudders
05:19:06 <Nibble> iocor: explain
05:19:48 <burp> there are matlab bindings in hackage
05:21:22 * hackagebot grammar-combinators 0.1 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.1 (DominiqueDevriese)
05:31:02 <ryo_hazuki> hey, i'm having a question... i hope someone can explain how to get rid of an error
05:31:13 <Zao> Quite possibly.
05:31:16 <ryo_hazuki> :)
05:31:20 <ryo_hazuki> my code:
05:31:24 <ryo_hazuki> pretty :: Char -> String -> String
05:31:24 <ryo_hazuki> pretty _ [] = ""
05:31:24 <ryo_hazuki> pretty s (x:xs) | s == x    = ' ' : (pretty xs)
05:31:24 <ryo_hazuki>                 | otherwise = x : (pretty xs)
05:31:33 <ryo_hazuki> gives this error:
05:31:49 <ski> you forgot to pass `s' tothe recursive calls
05:31:56 <ivanm> yup
05:31:57 <ryo_hazuki> awwwww
05:32:01 <ivanm> good catch ski 
05:32:01 <ryo_hazuki> now i saw it
05:32:15 <ryo_hazuki> thanks anyways =D
05:32:19 <ski> np :)
05:32:40 <ski> also, you don't need any brackets around the recursive calls, there
05:33:24 <ryo_hazuki> higher priority for calling fuctions, you mean?
05:33:50 <ski> yeah, function application has the (almost) highest precedence of all operators
05:34:07 <ryo_hazuki> ok, cool
05:34:38 <ivanm> ski: what has higher?
05:35:19 <ski> (the exceptions are record update (both pattern and expression forms), `as'-patterns, irrefutable patterns, strict patterns)
05:35:46 <ivanm> what's the expression form of record update?
05:35:47 <luite> possibly some pagerank increasement scheme?
05:36:09 <ski> > (Node 'a' []) {subForest = [Node 'b' []]}
05:36:10 <lambdabot>   Node {rootLabel = 'a', subForest = [Node {rootLabel = 'b', subForest = []}]}
05:36:23 <ski> > Node 'a' [] {subForest = [Node 'b' []]}  -- error
05:36:24 <lambdabot>   Constructor `[]' does not have field `Data.Tree.subForest'
05:36:24 <ivanm> oh, I figured that was the pattern form
05:36:37 <ski> that's an expression
05:36:53 <ivanm> so what's pattern form?
05:37:31 <ski> > let foo Node {rootLabel = x,subForest = ts} = (x,ts) in foo Node {rootLabel = 'a',subForest = []}
05:37:32 <lambdabot>   ('a',[])
05:37:48 <ski> hm, i suppose that is more like record construction pattern
05:37:50 <ivanm> oh, so a pattern match rather than an actual update?
05:38:09 <ski> and record update expression i mentioned before should have been record update/construction expression
05:38:20 <ivanm> so, the only non-match that has higher precedence over function application is record updates?
05:38:36 <ski> yeah, i don't think the update (as opposed to construction) form is allowed in patterns
05:38:58 <ski> ivanm : in *expressions*, yes .. if i'm not missing some
05:39:05 <chrisdone> still alpha, but here is a perma-link until I'm finishing implementing basic features and I'm happy that it's stable, hpaste.org will then point to it http://paste.tryhaskell.org/
05:39:23 <ivanm> chrisdone: oh? why are we dumping hpaste?
05:39:53 <ski> ivanm : though i suppose it might be an interesting question to ask what a record update *pattern* might mean ..
05:39:57 <chrisdone> ivanm: "we"?
05:39:58 <ivanm> chrisdone: I don't like the whole "let's only use the middle third of the screen" thing
05:40:06 <ivanm> chrisdone: we == haskell community
05:40:19 <chrisdone> ivanm: right now we're not even using it
05:40:21 <ivanm> or are you in charge of hpaste?
05:40:25 <benmachine> > let foo x@Node { rootLabel = y } = (x, y) in 0
05:40:25 <lambdabot>   0
05:40:26 * ivanm uses it...
05:40:32 <chrisdone> 58030 14: unable to open database file
05:40:43 <ivanm> well, I use it when it's working... ;-)
05:42:38 <frerich> I'm currently at work so I can't try this myself, but I just wondered: is there any difference in efficiency between 'f' and 'g' in http://paste.tryhaskell.org/paste/59/pattern_matching_vs__guards_efficiency ?
05:42:49 <ski> consider `foo (r {s = (x,y)}) = ..r..x..y..' .. this ought to bind `x' and `y' to the parts of the pair in the field `s' of the input record .. *and* bind `r' to a record that is just like the input record, except that the `s' field may be anything at all
05:42:54 <frerich> Is it preferrable to use pattern matching over guards, if possible?
05:43:27 <ivanm> frerich: the former gets de-sugared to a case statement, I think the latter gets desugared to a bunch of ifs
05:43:28 <ski> i suppose this shows that instead of a record *update* syntax, the primitive syntax really ought to be a record *modification* syntax
05:43:33 <ivanm> I would think the former would be more efficient
05:44:14 <ski> frerich : pattern-matching is better than guards, yes
05:44:41 <frerich> ivanm: Is that also true if I had chosen [1] and [] instead of True and False, as in: can it desugar to case statements when with lists instead of booleans?
05:45:00 <ivanm> yes
05:45:13 <ivanm> pattern matching is desugared into case statements
05:45:15 * frerich assumes 'desugaring' is the process of rewriting the Haskell code to some intermediate, possibly more optimized, code.
05:45:43 <deteego> not more optimized (yet)
05:45:47 <deteego> its just sytactic sugar
05:45:52 <ivanm> yup
05:46:07 <ivanm> frerich: e.g. do-notation is de-sugared to >>= and >>
05:46:09 <ski>   f x = case x of
05:46:10 <deteego> like do is syntactic sugar >>-
05:46:12 <deteego> ffs
05:46:14 <deteego> stop
05:46:16 <deteego> copying me ivanm
05:46:21 <deteego> or I will have to slap you
05:46:23 <ivanm> list comprehensions are de-sugared into the list monad IIRC
05:46:31 * ivanm dodges deteego 
05:46:42 <chrisdone> @faq Can Haskell host a duel between ivanm and deteego?
05:46:42 <lambdabot> The answer is: Yes! Haskell can do that.
05:46:51 <deteego> hmmm
05:46:52 <ivanm> frerich: http://en.wikipedia.org/wiki/Syntactic_sugar
05:47:05 <fasta> ivanm, that's not the official translation, but there is no real difference with the more correct answer. 
05:47:09 <ivanm> chrisdone: bah, he's a sydney-sider
05:47:10 <ivanm> ;-)
05:47:18 <deteego> lol
05:47:23 <frerich> ivanm: Ah, I didn't realize that 'desugaring' is related to syntactic sugar (which I know from many other languages)
05:47:28 <ski> er
05:47:28 <ski>   f x = case x of
05:47:28 <ski>     [1] -> 1
05:47:28 <ski>    [ ] -> 2
05:47:29 <ski> frerich : ^
05:47:29 <ski> (module the indentation-typo)
05:50:07 <frerich> Interesting. Is that desugared variant the 'core'? Or is desugared haskell code a step before that? I recently read that 'haskell core' is actually code which was rewritten for the same of performance.
05:54:53 <burp> is there a program that automatically adds type signatures to existing haskell sources?
05:56:43 <benmachine> I haven't heard of such a thing
05:57:02 <benmachine> it's probably not quite as simple as it sounds, you'd have to pull in the GHC API and stuff
05:58:26 <Jafet> burp: -Wall?
05:58:33 <quicksilver> the haskel emacs mode can do that burp 
05:58:40 <burp> oh nice
05:58:48 <quicksilver> if the file compiles, at least
05:58:54 <quicksilver> (it loads the file into ghci and asks ghci for the type sig)
05:59:29 <benmachine> oh yeah that would work better
05:59:34 * benmachine silly
06:00:14 <quicksilver> C-u C-c C-t inserts a type annotation, for symbol at point, on the line above
06:00:20 <quicksilver> ( from http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs )
06:01:34 * hackagebot twilight-stm 1.0 - Twilight STM library  http://hackage.haskell.org/package/twilight-stm-1.0 (AnnetteBieniusa)
06:01:47 <burp> let's see if there is something like that for vim, but I assume not ;(
06:04:28 <drksd> yeah, it seems nice.
06:08:20 <ski> that `twilight-stm' sounds interesting ..
06:10:26 <kremsera> what ides are you using to program in haskell?
06:10:54 <luite> many people use text editors like vim or emacs (I use emacs myself)
06:11:08 <Ke> vim
06:11:15 <kdvh> vim + syntax highlighting
06:11:19 <Zao> For now, vim. In the future, Phyx-'s Visual Haskell.
06:11:23 <tab> vim too
06:11:27 <Zao> Some use Leksah.
06:12:05 <itsmonkt1stic> I basically just use vim and a separate ghci session to look at types :p
06:12:20 <kremsera> :)
06:12:21 <Axman6> kremsera: i dispute the premise of your question, i don't use an IDE to program haskell ;)
06:12:37 * hackagebot lhae 0.0.2 - Simple spreadsheet program  http://hackage.haskell.org/package/lhae-0.0.2 (AlexanderBau)
06:12:49 <kremsera> axman6, vim and emacs count as ide for me ;)
06:12:58 <Axman6> i don't use either
06:13:03 <kremsera> just ghci?
06:13:15 <Axman6> just a programmer's editor (TextMate), and ghci
06:13:31 <chrisdone> 'use' is such a dirty word
06:13:33 <Ke> real programmers input binaries using morse keys
06:13:44 * chrisdone waits for the hilarious M-x butterfly joke
06:13:55 <kdvh> i knew someone would mention it eventually
06:13:56 <itsmonkt1stic> yes yes, we've all read the xkcd comic ¬¬
06:14:00 <Ke> =oP
06:14:10 <itsmonkt1stic> s/read .*/used the internet/
06:14:16 <itsmonkt1stic> :P
06:14:46 <kremsera> rofl
06:36:55 <deteego> anyways im off
06:36:57 <deteego> adios
06:40:54 <chilili> "If then"  without "else" I got a indentation error on Line 28 in http://codepad.org/G5XcLHgD, what's wrong? please.
06:41:21 <yrlnry> looking
06:41:36 <chilili> thanks
06:41:36 <kdvh> else is commented?
06:41:59 <yrlnry> "else" is mandatory.
06:42:02 <chilili> kdvh: yes, after comment else, I got the error.
06:42:09 <kdvh> dont comment it
06:42:15 <yrlnry> You are not allowed to have "if" without "else".
06:42:19 <luite> chilili: it's not possible to use if without else. you may want to use Control.Monad.when instead
06:42:36 <yrlnry> You can have else return ()
06:42:57 <chilili> the code from http://en.wikibooks.org/wiki/Haskell/Monad_transformers in askPassworld part. 
06:43:16 <Itkovian> dons: you do realise that most research code is just a bunch of scripts, quick hacks, etc? Most researchers have little time to write beautiful/decent/maintainable code. ergo, rechecking tehir results might take a long time
06:43:19 <chilili> yrlnry: luite , thanks. 
06:43:31 <Axman6> chilili: try using the function when:
06:43:33 <Axman6> :t when
06:43:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:43:42 <Itkovian> ok, that was prolly the wrong use of realise :-)
06:43:50 <Itkovian> _vlenglish_
06:43:50 <benmachine> chilili: that's confusing, but I think it's meant to be not a complete function definition
06:43:57 <Itkovian> but you geet the point
06:44:05 <benmachine> chilili: I mean, it doesn't in fact store the password in the database, for example
06:44:18 <chilili> Of course.
06:44:20 <benmachine> chilili: I guess they only wanted to illustrate the first part of the function
06:44:52 <benmachine> so they left the rest of it (which would have to contain an else) out
06:45:00 <chilili> I got it, thanks you all.
06:46:08 <luite> hmm, I wonder why my code runs twice as fast when profiling...
06:48:05 <ivanm> luite: :o
06:48:11 <ivanm> normally it's the other way round...
06:48:36 <Itkovian> luite: there was some talk on #ghc about that a while back
06:49:31 <luite> Itkovian: does #ghc have logs?
06:49:39 <Itkovian> hmm, good question
06:52:04 <luite> 20 seconds for the profiling version, 50 seconds for the regular one
06:53:32 <luite> unfortunately I need to get it down to less than a second, preferably less than 0.1
07:21:02 * hackagebot http-monad 0.1 - Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation  http://hackage.haskell.org/package/http-monad-0.1 (HenningThielemann)
07:22:14 <revenantphx> Wonderful, turns out my school's CS teach, who is pretty young and majored in mathematics, is willing to let me borrow all his books as needed.
07:22:17 <revenantphx> ^_^
07:23:33 <Nibble> nice
07:30:49 <Peaker> anyone here knows how DDC/discipile compares to monad transformers?
07:34:08 * hackagebot PrimitiveArray 0.0.2.1 - Unboxed, multidimensional arrays based on the primitive  package.  http://hackage.haskell.org/package/PrimitiveArray-0.0.2.1 (ChristianHoener)
07:37:18 <copumpkin> @ask dons what's that new serialize# primop you mentioned in a tweet? any more information on the plans there?
07:37:18 <lambdabot> Consider it noted.
07:38:19 <_unK> is there any conveniant method to parse C style special floating values (nan, inf, -inf) in haskell, i.e. not using something like this: http://codepad.org/o7x2U9Gp ?
07:40:30 <Peaker> I just figured -- if you have something like:  LockTransaction a = LT [Mutex] (IO a)   with an Ord instance for Mutex you could make this type an instance of Monad and get composable lock-based transactions
07:40:38 <Peaker> would this not work or did anyone do this?
07:42:11 <Peaker> oh, this wouldn't work
07:42:45 <Peaker> (Need to know all locks ahead of time, so this can only be applicative, not monad)
07:43:06 <zygoloid> Peaker: i think disciple assumes a certain sort of commutativity of effects (it's more like having a (MonadFoo m, MonadBar m) => type than directly using a transformer stack)
07:43:06 <Peaker> Making this a monad means sometimes "giving up" which is what STM does
07:43:38 <quicksilver> IO ([Mutex],a), perhaps
07:43:44 <Peaker> zygoloid, so only for commutative effects it makes sense?
07:43:49 <quicksilver> using IO's own exceptions if you have to give up
07:43:53 <Peaker> quicksilver, but then you can't lock them all ahead of time
07:44:04 <Peaker> quicksilver, ah, with giving up as exceptions, yeah
07:45:07 <zygoloid> Peaker: no, you can have IO stuff in there too. certain run-this-monad functions will put restrictions on the computation such as 'it must be pure' to avoid the old IO-isn't-a-transformer issue
07:45:49 <Peaker> zygoloid, I'm wondering if it solves a deep problem or just syntactic convenience 
07:46:14 <zygoloid> it solves a /different/ problem. i don't think you can express the list monad as an effect type for instance.
07:49:47 <zygoloid> the impression i get is that it's more-or-less a different approach to ST
07:50:04 <zygoloid> (a much more implicit approach)
07:50:12 * hackagebot lazyio 0.0.3 - Run IO actions lazily while respecting their order  http://hackage.haskell.org/package/lazyio-0.0.3 (HenningThielemann)
07:50:15 <krey_> hey guys, quick way to get first 5 lines of a file?
07:50:54 <krey_> (as a String)
07:51:05 <zygoloid> with region types taking the place of the 's' type, and closure types replacing types of the form data Foo s = {... STRef s a ...}, and an implicit runST
07:51:53 <aristid> :t take 5 . lines
07:51:54 <lambdabot> String -> [String]
07:51:57 <aristid> krey_: ^
07:52:07 <zygoloid> it has the same property as ST that if you nail down 's' you can perform additional operations, but on a finer-grained basis
07:52:46 <krey_> aristid: LOL, thanks
07:53:25 <aristid> :t replicateM 5 getLine
07:53:26 <lambdabot> IO [String]
07:54:22 <chrisdone> take 5 . lines <$> readFile "foo.txt"
07:55:30 <aristid> heh, replicateM 5 getLine behaves weird wrt EOF
07:57:39 <mreh> does that read five lines?
07:58:00 <mreh> yes... I've read the scrollback now
07:59:10 <revenantphx> :t (<$>)
07:59:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:59:13 <revenantphx> :t fmap
07:59:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:59:20 <revenantphx> ...they're synonyms aren't they
08:01:00 <ski> zygoloid : btw, Mercury basically has a `newST :: exists s. STState s' operation, with our `ST s a' basically being expressed as `STState s -> (STState s,a)'
08:05:09 <Peaker> zygoloid, except as a local optimization in a few places, I didn't find ST immensely useful... It sounds a bit peculiar to go to all that trouble just to get more light-weight mutability
08:10:00 <aristid> i have a type which is an instance of Functor, and which has two functions, returnQ and joinQ, which behave like monad functions, except that joinQ has an Ord constraint on the contained type. right now i just have these functions returnQ and joinQ separate of any typeclass, but is there maybe some typeclass out there which i could use?
08:10:28 <Peaker> aristid, RMonad
08:10:35 <Peaker> @hackage RMonad
08:10:35 <lambdabot> http://hackage.haskell.org/package/RMonad
08:11:05 <Peaker> capitalization matters: http://hackage.haskell.org/package/rmonad
08:11:47 <falsealarm> newbie here- I'm going to write myself a scheme in 48 hours :D http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps
08:12:43 <jmcarthur> aristid: it has an Ord constraint on join but not on fmap?
08:12:44 <aristid> Peaker: mmh yeah, i'm not sure i understand how to use it
08:12:49 <aristid> jmcarthur: only on join
08:12:53 <jmcarthur> that's unusual
08:12:58 <jmcarthur> not necessarily wrong, just unusual
08:13:16 <medfly> :t return
08:13:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:13:24 <jmcarthur> aristid: you might want to make sure that with your definition of join, liftM = fmap
08:13:25 <aristid> jmcarthur: well it doesn't make sense to have a type inside without Ord, but the implementation of fmap does not care at all
08:13:53 <jmcarthur> i see
08:14:02 <aristid> it's roughly an Interval type
08:14:15 <Peaker> aristid, Do you have an Applicative instance without Ord constraint?
08:14:21 <jmcarthur> oh, so it's like a data Pair a = Pair a a?
08:14:23 <aristid> Peaker: no
08:14:29 <HugoDaniel> im looking for documentation on iteratee
08:14:38 <aristid> jmcarthur: a bit more complex but yea
08:14:44 <jmcarthur> aristid: what if fmap causes the two values to go out of order?
08:14:49 <Peaker> HugoDaniel, there's the new "enumerator" package
08:15:15 <HugoDaniel> oh
08:15:17 <HugoDaniel> nice
08:15:39 <aristid> jmcarthur: yeah i thought i would ignore that
08:15:50 <medfly> dumb question about not using do notation: http://codepad.org/pG42IlEi (question inside) 
08:15:51 <medfly> :o
08:15:59 <jmcarthur> aristid: that is probably invalid though. you probably want an Ord constraint on your fmap operation ;)
08:16:09 <aristid> jmcarthur: good point
08:16:17 <aristid> that way i lose Functor, too
08:16:19 * hackagebot protocol-buffers 1.8.0 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-1.8.0 (ChrisKuklewicz)
08:16:21 * hackagebot protocol-buffers-descriptor 1.8.0 - Text.DescriptorProto.Options and Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-descriptor-1.8.0 (ChrisKuklewicz)
08:16:37 <jmcarthur> aristid: you can always go with a restricted functor. not sure if the rmonad package has one
08:16:44 <Botje> medfly: perhaps you want something like withFile
08:17:07 <aristid> jmcarthur: it has. but i wonder what semantics i actually want when the function functor-applied to a range is not monotonic
08:17:51 <medfly> thanks
08:18:23 <jmcarthur> aristid: yeah. it's tough
08:18:43 <jmcarthur> aristid: it's not even like Data.Set where a restricted functor could at least work in all cases
08:18:50 <medfly> is it wasteful to open and close a handle several times vs. opening it, doing everything, and then closing it again?
08:19:02 <jmcarthur> aristid: perhaps it would be best to just say that your type is not a functor
08:19:02 <aristid> i shall look how other interval types solve it
08:19:22 <aristid> jmcarthur: oh, i definitely need those 
08:19:50 <aristid> i use fmap on it all the time
08:19:54 <jmcarthur> aristid: you could still provide functor-like operations, but a type class instance is usually a claim that your type satisfies the necessary laws
08:19:55 <aristid> and then joinQ to get it flat
08:20:01 <aristid> (sometimes)
08:20:21 <aristid> jmcarthur: rmonad probably has a slightly different set of laws
08:20:34 <jmcarthur> aristid: same laws
08:20:44 <jmcarthur> just the ability to use tighter constraints
08:20:53 <jmcarthur> actually, it's just on a different category
08:21:06 <aristid> jmcarthur: let me check first how interval packages on hackage solve it
08:23:30 <aristid> ah, it has functions increasing and decreasing
08:24:00 <aristid> @hackage intervals
08:24:00 <lambdabot> http://hackage.haskell.org/package/intervals
08:26:21 * hackagebot hprotoc 1.8.0 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-1.8.0 (ChrisKuklewicz)
08:27:57 <aristid> @src liftM
08:27:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:29:28 <chrisdone> preflex: be poppavic
08:29:28 <preflex>  You cannot walk into ##C and speak "C" as a moron. Really-really. This shit is the underlayer to scripting and an uber-layer to the machine.
08:29:52 * chrisdone nods sagely and repeats, "uber-layer"
08:30:30 <Peaker> did you guys kidnap PoppaVic and make him type stuff for preflex?
08:31:18 <aristid> @undo liftM f m1 = do { x1 <- m1; return (f x1) }
08:31:18 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1)
08:32:10 <Nibble> The version without sugar looks better imho
08:32:46 <c_wraith> liftM f m1 = m1 >>= return . f
08:32:47 <ski>   liftM f ma = return . f =<< ma
08:32:56 <c_wraith> I hate lambdas. :)
08:33:09 <aristid> jmcarthur: i think i can provide fmap (with Ord), making it work like liftM would
08:33:24 * hackagebot regex-pderiv 0.0.8.2 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.0.8.2 (KennyLu)
08:34:11 <chrisdone> Peaker: yeah, we rescued him from whoever was making him type stuff in ##c, but then felt the same urges as his previous captors to release him unto an innocent audience from time to time
08:34:48 <Peaker> chrisdone, When I first encountered him, I thought I was the only one who found him incoherent
08:35:27 <edon> what's the best introduction to monad transformers ?
08:36:24 <chrisdone> Peaker: when I encountered him he was accepted like a family pet that humps limbs and licks the carpet when you have friends over. I think it was generally assumed it was booze
08:36:36 <Nibble> here is a funny joke. A person entered the hotel and said: I want to book a room. Name, age and sex. Goran Pettersson, 35 and yes. Are you serious the receptionist asked? Yes, he said. Receptionist: I mean, male or female. He said, both, sometimes animals too.
08:36:44 <Peaker> edon, I wrote one :)
08:37:05 <Peaker> edon, maybe there's a better one somewhere, but here is mine: http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial
08:37:05 <edon> Peaker: which one?
08:37:34 <edon> ok thanks
08:37:58 <Peaker> edon, if it doesn't work for you, tell me, maybe I can improve it
08:38:29 <edon> Peaker: sure :)
08:42:57 <chrisdone> I'm gonna use the tunes.org irc logs to provide a "Context in IRC" pane for pastes
08:43:00 <sm> yay, another regex implementation
08:43:15 <chrisdone> a la what paste.lisp.org used to do, but it will be embedded within the paste page
08:43:33 <Peaker> chrisdone, sounds nice
08:44:47 <chrisdone> Peaker: seen? http://paste.tryhaskell.org/ I'm waiting for bos to point hpaste.org to it. I still have some other things to implement, but at least it doesn't have locking issues
08:46:15 <jmcarthur> aristid_: but does it preserve your invariants?
08:46:18 <sm> chrisdone: make it default to #haskell maybe
08:46:22 <chrisdone> Peaker: hey that's a good idea. (defaulting to language)
08:46:27 <sm> and Haskell
08:46:41 <chrisdone> I'll do that
08:46:53 <chrisdone> I thing I intended on doing that and then forgot immediately
08:47:10 * sm likes pastebins where you don't have to think & click much
08:47:33 <chrisdone> it's a good point. most users will be from #haskell
08:47:46 <ski> chrisdone : what will happen to the old pastes on `hpaste.org', then ?
08:47:54 <jmcarthur> the default language is haskell anyway, isn't it?
08:48:12 <Twey> chrisdone: Box should be bigger
08:48:35 <chrisdone> Twey: try pasting something into it
08:48:42 <jmcarthur> oh i mean on hpaste
08:48:44 <ski>  /window 132
08:49:02 <Twey> Oh, it expands — cool :þ
08:49:08 <chrisdone> ski: well the old host is still accessible, so I can scrape the old pastes if desired, maybe with an anti-spam filter
08:49:21 <chrisdone> Twey: :D
08:49:42 <ski> chrisdone : i have some pastes on it that i sometimes refer people to
08:49:49 <Twey> Nooo, don't make it default to #haskell
08:49:56 <Twey> We'll get spammed.
08:50:18 <ski> (actually, at least one of those is a repaste of a pastee from an earlier hpaste incarnation)
08:51:14 <chrisdone> ski: indeed; I thought some people might. I can either setup a redirect to the old host, or import select ones that you want, and redirect the old url format to the new one with a 301
08:51:16 <ski> Twey,chrisdone : why not do something like lisppaste does, then, i.e. have `@paste' in lambdabot give `http://paste.tryhaskell.org/new/haskell', but only give the `http://paste.tryhaskell.org/' link otherwise
08:51:20 <ski> ?
08:52:00 <Peaker> Twey, all edit boxes expand in Safari/Chrome
08:52:04 <chrisdone> ski: good idea. url-entered defaults
08:52:07 <Peaker> Twey, It's a webkit feature, afaik
08:52:12 <Twey> ski: That's a good idea
08:52:18 <ski> chrisdone,Twey : btw, lisppaste has a "captcha" (which is always the same word). `paste.tryhaskell.org' could possibly do the same thing
08:52:18 <Twey> Peaker: Oh, really?  Okay
08:52:25 <Twey> ski: Not any more
08:52:34 <Twey> ski: They changed it… now my blind friend can't use it any more ☹
08:52:43 <chrisdone> Peaker: yeah, but firefox doesn't so I added a rows==number_of_lines expander for the textarea
08:53:17 <chrisdone> ski: yeah I've already got that covered, spam protection was my second main motivation for doing this
08:53:40 <ski> Twey : oh, ok (i remember chandler talking in #scheme about being forced to higher the bar to avoid smarter spammer attach, but i never got around to checking exactly how that was accomplished)
08:53:49 <ski> chrisdone : ok
08:54:26 <chrisdone> http://dis.4chan.org/prog/ uses a neat hidden input field trick, which I *think*, but would have to actually get someone to test, blind people have no problem with. essentially, have a hidden email field that spambots will fill in, and humans don't even see rendered
08:54:29 <ski> Twey : hm .. does the emacs interface to lisppaste still work, though ?
08:54:43 <Twey> Don't know… I don't use it
08:54:56 <Twey> chrisdone: Yeah, that's a good one to start with
08:54:58 <chrisdone> alternatively there's always recaptcha if that method starts to fail
08:55:10 <Twey> ReCAPTCHA is probably best
08:55:11 <chrisdone> Twey: your blind friend can use recaptcha right?
08:55:13 <Twey> Yeah
08:55:17 <chrisdone> good good
08:55:22 <Twey> It's a bit heavy-weight, though
08:55:25 <chrisdone> I know
08:55:32 <Twey> I'd go with the hidden field to start with, and only upgrade if you have to
08:55:38 <chrisdone> indeed
08:56:20 <chrisdone> (a javascript-inserted authorization token is another way, but yeah I think the hidden input serves /prog/ well)
08:57:01 <Twey> There are also simple text-based CAPTCHAs you can generate
08:57:09 <Twey> Before going the whole hog with ReCAPTCHA
08:57:11 <chrisdone> sure, what is 2 + 4, etc
08:57:18 <chrisdone> yeah
08:57:21 <Twey> That sort of thing, yeah
08:57:26 <Twey> ‘How many legs does a pig have?’
08:57:40 <chrisdone> lol
08:58:00 <chrisdone> who posted the really wide paste? it's a good example of the expanding code box
09:01:28 <chrisdone> anyhoo, I'm going shopping and then I'm gonna work on it at home. ciao!
09:03:10 <quicksilver> Twey: four.
09:03:23 <quicksilver> such a relief to get a question in #haskell I can answer confidently.
09:03:24 <Twey> \o/
09:03:27 <Twey> Hahaha.
09:03:54 <Twey> quicksilver: None after ham sandwiches
09:03:59 <quicksilver> NOM
09:05:40 <DamienCassou> hi
09:06:13 <DamienCassou> I've just created my first (useful) haskell program: http://github.com/DamienCassou/HYahtzee. It's a Yahtzee implementation in command-line for one player
09:06:25 <DamienCassou> I very welcome all possible comments and patchs
09:11:07 <quicksilver> nice idea
09:11:25 <quicksilver> DamienCassou: I think it would have been funnier to call it Hyatzee
09:11:33 <quicksilver> DamienCassou: it's possible I have a very poor sense of humour though.
09:11:34 <Twey> Hehe
09:11:40 <DamienCassou> quicksilver: :-) sorry
09:11:45 <Twey> Hya!  Tzeeeeee~!
09:12:01 <quicksilver> The only think I like about github is the markdown formatted README support
09:12:05 <geheimdienst> hyacinth?
09:12:05 <quicksilver> but, that is a really shiny thing.
09:12:29 <quicksilver> at work we have two different wiki markups in use and I always have to remember which one I'm using.
09:15:07 <Twey> quicksilver: Ick
09:16:58 <copumpkin> tommd: how do you plan on dealing with padding schemes for e.g., RSA in your API, by the way?
09:21:36 <DamienCassou> I need to leave. Please fork my game and fix whatever you see :-). I really appreciate comments to improve my skills
09:21:46 <DamienCassou> http://github.com/DamienCassou/HYahtzee
09:21:49 <DamienCassou> bye
09:28:32 <tommd> coumpkin: I was going to provide some trivial padding algorithms in Data.Crypto.Padding (eventually).
09:29:57 <tommd> Some cipher implementations specify a padding (PKCS1 I think)
09:29:59 <copumpkin> tommd: so you'd pad them yourself before using the RSA instance on them, for example?
09:30:01 <copumpkin> yeah
09:30:07 <copumpkin> that's mostly what I was thinking of
09:30:15 <copumpkin> cause RSA is insecure without them
09:31:18 <c_wraith> I like CFB mode for symmetric block ciphers because it doesn't require padding.  Though it does require signing.  But you should always be signing anyway.
09:31:20 <tommd> Yes.  There is a set of semantics associated with each class (or will be).  For AsymCipher no semantics have been specified and no one has complained (ha!), for Hash I proposed three different semantics and adopted one that said the user of "updateCtx" would have to provide n*blockSize bits per call
09:31:28 <tommd> Where n \in [0..]
09:31:43 <tommd> copumpkin: Same goes for the BlockCipher class
09:31:50 <copumpkin> yeah
09:31:56 <copumpkin> so will you provide ECB? :)
09:31:58 <copumpkin> :P
09:32:02 <tommd> Yep
09:32:04 <tommd> Exactly
09:32:08 <c_wraith> ECB?  ewww.  :)
09:32:17 <copumpkin> I actually realized that apple encrypted their latest ipod nano firmware with it yesterday
09:32:23 <c_wraith> ECB?
09:32:24 <tommd> I provide the most fundamental primitive and use that to build the others
09:32:25 <copumpkin> not that I can decrypt it, but I can tell they used ECB :P
09:32:26 <c_wraith> brilliant, apple
09:32:33 <tommd> CBC, CTR, OFB are all in Data.Crypto.Modes
09:32:35 <copumpkin> they use CBC on their bigger devices
09:32:53 <c_wraith> I mean, at least use CTR.
09:33:00 <c_wraith> It's better than ECB!
09:33:07 <tommd> c_wraith: We are discussing the API, not the end user mode.
09:33:08 <c_wraith> Actually, CTR is pretty good.
09:33:14 <c_wraith> and ECB is horrible :)
09:33:36 <copumpkin> tommd: what did you think about the Crypto. prefix by the way? I'm sort of with roconnor on the "overcrowded" Data. idea
09:33:51 <tommd> c_wraith: Providing the fundamental (block encryption) in the class allows people (me) to build CTR, CBC, etc in a general way that works for all ciphers
09:34:08 <copumpkin> yeah, I like that
09:34:20 <tommd> copumpkin: I actually don't care.  If people prefer Crypto.Classes, Crypto.Modes etc then I'm game.
09:34:43 * copumpkin does, but nobody seems to have chimed in or disagreed with my email on the list, so who knows :P
09:34:50 * copumpkin enlists roconnor 
09:35:02 <tommd> I'll likely make the change but if more people could chime in I would appreciate it.
09:35:21 <tommd> Ok, going to the park with my daughter - will talk about crypto another time.
09:35:28 * tommd runs away
09:36:10 <copumpkin> :) ciao
09:40:24 <Cale> Control.Data.Miscellaneous
09:40:53 <c_wraith> Wouldn't that be better-named Control.Data.Utility?
09:41:27 <Cale> Why be picky? Control.Data.Miscellaneous.Utility
09:43:07 <chrisdone> sup
09:43:31 <luite> inf
09:44:37 <geheimdienst> miscellaneous is a great start, but could we add some more words no one can spell?
09:44:52 <geheimdienst> Control.Data.Miscellaneous.Shlimazel.Utility
09:45:37 <copumpkin> Stuff. ?
09:46:08 <geheimdienst> Control.Shlimazel.Meschugge.Utility
09:47:52 <Twey> Control.Data.Miscellaneity.Shlimazel.Meschugge.Sazysamselpla.Utility
09:49:27 <jmcarthur> @check \xs ys zs -> nub (nub xs ++ (nub ys ++ nub zs)) == nub ((nub xs ++ nub ys) ++ nub zs :: [Int])
09:49:28 <lambdabot>   "OK, passed 500 tests."
09:49:51 <geheimdienst> so, i notice there's only 2 google hits for "Sazysamselpla". guess i don't have to be ashamed that i don't know that word
09:51:09 <Twey> Haha, and they're both me, albeit aggregated in one
10:04:30 <chrisdone> lol, sazysamselpla
10:10:52 <rschnck> kmc: ski: bored in physics lecture, any ideas for an interesting recursive problem?
10:14:02 <c_wraith> rschnck, How complicated?  My favorite problem for intro-level haskell learners is to implement generating all permutations of a list.  There are interesting efficiency considerations.
10:14:39 * sm suddenly sees where #haskell's high traffic comes from
10:15:02 <ski> .. and where might that be from ?
10:15:26 <c_wraith> First, just generating list permutations is an interesting problem.  But once you have a solution, it's interesting to analyze its performance, and find other, better solutions.
10:15:51 <ski> e.g. to write a maximally parsimonious solution
10:15:58 <rschnck> c_wraith: Well yesterday we figured out how to reverse the digits of an integer (1234 -> 4321) of any length. I had considerable difficulty with that
10:16:08 <rschnck> So maybe something along that line of difficulty?
10:16:14 <rschnck> I just want a bit more practice.
10:16:26 <zygoloid> > (read.reverse.show) 1234 :: Int
10:16:28 <lambdabot>   4321
10:16:39 <ski> rschnck : well, you might want to improve your `myReverse' to be linear instead of quadratic in performance
10:17:19 <c_wraith> oh, that's a good one.
10:17:33 <rschnck> Erm, how is it quadratic?
10:17:48 <rschnck> myReverse :: [Int] -> [Int]
10:17:49 <rschnck> myReverse [] = []
10:17:51 <rschnck> myReverse (x:xs) = myReverse xs ++ [x]
10:17:55 <copumpkin> ++ is lienar
10:17:56 <c_wraith> ++ is O(n)
10:18:01 <copumpkin> in the length of the first arg
10:18:20 <krey_> hi, I have an interpreter that produces some output (using WriterT) but it appears in one chunk (ie it is not produced line-by-line)
10:18:21 <copumpkin> so you get 1 + 2 + 3 + 4 + 5 .. + n, basically
10:18:24 <copumpkin> which is quadratic
10:18:26 <ski> rschnck : to see this, you should really see the implementation of `(++)' (or write it yourself)
10:18:34 <krey_> so I changed the output format from String to IO ()
10:18:42 <rschnck> ski: Okay, how about I write a function for ++
10:18:46 <krey_> but it still won't appear step-by-step
10:18:46 <rschnck> and then try the linear vs. quadratic bit.
10:18:47 <ski> sure
10:18:58 <krey_> I think it's because of laziness
10:19:02 <krey_> is that possible?
10:19:05 <zygoloid> krey_: can you hpaste the code? it's probably overly strict somewhere.
10:19:54 <c_wraith> well, WriterT what?
10:20:12 <c_wraith> some monoids are strict
10:20:51 <rschnck> and I'm guessing I'll have a base case along the lines of myList [a] + [] = [a]
10:21:04 <krey_> zygoloid: http://github.com/krey/Parsers-and-Interpreters/blob/master/Counter.hs
10:21:12 <c_wraith> rschnck, that's not the usual base case
10:21:32 <c_wraith> rschnck, because the second list never will get shorter in your recursion.  probably
10:21:54 <ski> rschnck : well, you can try something first, and we can criticize it afterwards :)
10:22:17 <krey_> zygolod: sorry, I'm being an idiot
10:22:26 <krey_> zygoloid: ^
10:22:59 <krey_> zygoloid: it works after all, but the stack was too small to run code that produces output slowly enough
10:23:12 <zygoloid> hah :)
10:24:18 <burp> hm, how would you normalize mixed utf-8/iso input? (in my case for an irc bot, added quotes)
10:24:29 <krey_> zygoloid: so, would it still produce immediate output if I reverted the output type to String from IO ()
10:24:35 <krey_> ?
10:25:38 <zygoloid> if it works with IO () using (>>) as mappend, then it should work with String using (++).
10:26:12 <krey_> zygoloid: thanks!
10:28:04 <rschnck> Hmm. Would I want to isolate the first element in list [a] and then define that as the head, with the remaining elements the tail?
10:28:17 <zygoloid> rschnck: pattern match on (x:xs).
10:28:28 <zygoloid> rschnck: that is to say, yes, do that :)
10:28:47 <rschnck> What do you mean by "pattern match"?
10:29:14 <zygoloid> rschnck: when you write a function like: f (x:xs) = x + f xs, the (x:xs) bit is called a pattern match
10:29:23 <rschnck> Oh
10:30:25 <pyf> is there some set structure that can contain types not in the Ord typeclass?
10:30:39 <tromp> :t max
10:30:39 <lambdabot> forall a. (Ord a) => a -> a -> a
10:30:48 <zygoloid> pyf: what operations do you have? is it in Eq?
10:30:54 <pyf> yes
10:31:02 <pyf> that's all
10:32:02 <zygoloid> ok, what operations do you want on the set structure? it's probably not going to be very efficient ;(
10:32:48 <zygoloid> there's probably not going to be anything much better than building a list and nubbing it
10:33:27 <pyf> hmm ok
10:33:53 <pyf> but i don't need to represent the order of elements
10:34:27 <c_wraith> there still needs to be an order, just that the structure will be traversed in.
10:34:36 <aristid> pyf: then a list should be fine
10:34:48 <c_wraith> if all you have is Eq, then every insert is going to be a linear scan.
10:35:31 <c_wraith> And this really sounds like list. :)
10:36:50 <roconnor> tommd: I'm on board with Cryto.
10:36:50 <pyf> thanks
10:37:04 <roconnor> tommd: Crypto. works too
10:38:08 <bos> CosmicRay: do you know anything about the HDBC mysql bindings?
10:38:08 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
10:39:16 * hackagebot AttoJson 0.5.2 - Simple lightweight JSON parser & generator based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.2 (HiromiIshii)
10:40:18 <rschnck> Ugh, I'm stuck.
10:40:50 <rschnck> If we have myList (a:as) (b:bs) I can sort of see how you'd want to get as, b, and bs all as the same list and then a is simply the header
10:40:54 <rschnck> But have *no clue* how to go about doing that
10:41:55 <chrisdone> bos: can you update hpaste.org's domain please? :p
10:42:08 <bos> chrisdone: when i have time
10:42:09 <chrisdone> rschnck: you mean as ++ [b] ++ bs?
10:42:17 <tommd> roconnor: Good to hear
10:42:20 <chrisdone> bos: thanks :-)
10:42:38 <c_wraith> chrisdone, he's trying to re-implement ++
10:42:44 <chrisdone> ah, ok
10:42:46 <c_wraith> So telling him to use it doesn't help much :)
10:42:53 <chrisdone> nope
10:43:11 <c_wraith> rschnck, let's try to simplify a bit
10:43:44 <roconnor> techinically we now have software to synthesise the definition of ++ from a handful of example inputs and outputs
10:43:50 <tommd> roconner: Unless someone has damning things to say about the RandomGenerator class I'm leaning toward releasing in a few days with the Crypto.X modules names.
10:44:17 <xplat> (++) = xxxx × xxxxx (×)
10:44:58 <c_wraith> rschnck, let's start with lists in haskell.  You're familiar with the underlying structure they have?  (ie, they're immutable singly-linked lists.  does that mean anything to you?)
10:45:10 <rschnck> Nope :D
10:45:27 <c_wraith> well, let's start with singly-linked.
10:45:43 <c_wraith> That means each element of this list has a value, and points to the rest of the list.
10:45:47 <c_wraith> @src []
10:45:47 <lambdabot> data [] a = [] | a : [a]
10:45:59 <c_wraith> Or, it's the [] element, which indicates an empty list
10:46:22 <c_wraith> so the list [1, 2, 3] is actually 1:(2:(3:[]))
10:46:45 <rschnck> Because 3:[] = [3] and 2:[3] = [2,3] and 1:[2,3] = [1,2,3]?
10:46:50 <c_wraith> yes
10:47:13 <rschnck> So if lists are defined in their elemetns like that
10:47:25 <rschnck> We should be able to take any one element we like
10:47:31 <rschnck> If that makes sense
10:47:59 <c_wraith> well, but if you have [1..100], there's no way to get the 100 out without going through each of the links on the way
10:48:11 <rschnck> Right.
10:48:13 <Peaker> rschnck, Pattern-matching lets you take any part of a structure, even one with nested structures in it. A list is just a structure with nested structures in it, so pattern matching lets you get any part of the structure
10:48:27 <Peaker> (any element we like)
10:48:45 <c_wraith> But since each node has a link to the tail, and that's the only link it has to the rest of the list, we call it a single-linked list.
10:48:48 <Peaker> but not just elements.. Also the tails of the list
10:49:07 <sm> ski: folks bored in lectures
10:49:27 <rschnck> I'm still a bit unsure
10:49:31 <rschnck> What is meant by pattern matching
10:49:52 <c_wraith> It means determining what to do by the matching some input against a pattern.
10:49:58 <rschnck> Oh.
10:50:01 <c_wraith> The pattern can be any data constructors
10:50:09 <rschnck> so if I had func n = n^5
10:50:16 <rschnck> My input is n, and the pattern is n^5?
10:50:20 <zygoloid> no
10:50:21 <copumpkin> nope
10:50:22 <c_wraith> no, the pattern is n
10:50:23 <rschnck> Yikes
10:50:33 <c_wraith> the input is whatever is passed to func when you call it.
10:50:35 <rschnck> Oh
10:50:40 <c_wraith> n, as a pattern, is kind of boring.
10:50:45 <c_wraith> it just matches every value
10:50:49 <zygoloid> if you had func 0 = "hello"; func 1 = "goodbye", then 0 and 1 are patterns there.
10:50:55 <rschnck> Right
10:50:58 <rschnck> Okay that makes sense
10:51:02 <rschnck> and "hello" is just the output?
10:51:04 <c_wraith> yes
10:51:05 <zygoloid> the first definition whose pattern matches gets used
10:51:21 <copumpkin> but you can also write f [a, b, c] = blah and it'll run blah whenever you have a list of exactly three elements
10:51:29 <copumpkin> (and a will be the first element and so on)
10:51:39 <rschnck> Okay, and that's why it's pattern matching
10:51:42 <rschnck> because you have a, b, c
10:51:47 <rschnck> and you'd input numbers
10:51:50 <rschnck> and it'd match to that
10:51:57 <c_wraith> or anything else
10:51:58 <zygoloid> > let len [] = "empty list"; len [a] = "list of one element"; len xs = "list of multiple elements" in (len [], len [42], len [1,2,3])
10:51:59 <lambdabot>   ("empty list","list of one element","list of multiple elements")
10:52:05 <c_wraith> Not everything is a number :)
10:52:07 <rschnck> Okay, sorry. Lecutre's over
10:52:10 <rschnck> I'll be back in an hour
10:52:26 <rschnck> Thanks for the help so far
10:53:14 <ski> sm : ah
10:55:39 <kyagrd> Anyone using hmatrix with ghc 6.12.3 with cabal installed?
10:55:44 <roconnor> oooh Monatron
10:57:24 * hackagebot hyahtzee 0.1 - A Yahtzee game implementation in Haskell  http://hackage.haskell.org/package/hyahtzee-0.1 (DamienCassou)
11:09:54 <sshc> If I have "data Foo = Cons {_fieldName :: ...}" and use fclabel's mkLabels, how to I export the labels ("fieldName" and not "_fieldName")?
11:10:57 <aristid> sshc: specifying them in the module export list does not work?
11:13:22 <sshc> aristid: I could add them to the export list individually, but is there a way to export them all automatically?
11:13:40 <aristid> sshc: probably not, not sure tho
11:13:41 <sshc> aristid: Repeating each one seems boilerplate-ish
11:13:58 <aristid> yeah haskell has quite some amount of required boilerplate
11:14:04 <aristid> better than other languages but still
11:14:38 * sshc writes boilerplate
11:15:02 <Twey> sybsybsybsyb…
11:15:28 * ski boils writer plates
11:15:28 <sshc> Twey: ?
11:16:19 <Twey> http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
11:16:23 <sshc> Is there a template haskell thing I can put in the eexport list?
11:16:28 <sshc> I'm not familiar with template haskell
11:16:39 <Twey> Yeah, I think you can do it with TH
11:16:47 <Twey> I'm not either, but that's the sort of thing it's for
11:17:07 <chrisdone> using template haskell makes me feel like I'm doin it rong
11:17:11 <c_wraith> You can't use TH to modify a module's export list.
11:17:16 <aristid> Twey: i don't think syb writes export lists for you
11:17:17 <Twey> Damn
11:17:32 <Twey> Maybe a preprocessor, then?
11:17:35 <kyagrd> QuickCheck instansces must be spearate package. I got bitten from hmatrix :)
11:18:12 <kyagrd> hmatrix has some quickcheck instances like (Complex a) which is not defined in version 1.x but it is in version 2.x
11:18:33 <kyagrd> Fortunately then had a flag to disable all the quickcheck instances though.
11:19:09 <aruns> has anyone here installed hogre ? haskell bindings to ogre game engine? i'm having trouble installing it with cabal on mingw. cgen appears to be looking for headers in a non standard place, even though i have provided the --extra-include-dirs flag
11:19:48 <aruns> i should say cgen is looking for the headers in the standard place, instead of the location in the extra-include-dirs flag
11:29:48 <tommd> aruns: It installs fine for me, but I'm on Linux so that isn't surprising.
11:30:09 <aruns> i know it installed perfectly for me on unbuntu
11:30:35 <aruns> but unfortunately i'm having truoble with graphics drivers on ubuntu, so i've kind of gotten forced back to win/mingw :P
11:31:36 <aruns> trying to poke around Setup.hs to see if i can figure out whats going on
11:34:02 <aruns> ^:t normal
11:34:12 <aruns> :type normal
11:34:32 <aruns> hmm whats the command prefix for lambda bot ?
11:34:42 <Cale> :t normal
11:34:43 <lambdabot> Not in scope: `normal'
11:34:47 <Cale> @type normal
11:34:48 <lambdabot> Not in scope: `normal'
11:34:56 <Cale> The :t thing is a special case
11:35:04 <Cale> Most commands are prefixed by @
11:35:18 <aruns> just like ghci. cool thanks Cale
11:35:42 <aristid> :t does not work in a query with lambdabot, there you should use @ty or @type
11:35:43 <lambdabot> parse error on input `in'
11:35:58 <aristid> why doesn't :t work in queries btw?
11:36:25 <copumpkin> someone forgot to support it in the bot source? :P
11:36:34 <copumpkin> I'm imagining it was a special case in the first place
11:36:43 <aruns> anyone know what 'normal' is doing in this line -  mogreincpath <- (filter (\w -> take 2 w == "-I") . words) <$> getProgramOutput normal pkgconfig ["--cflags", "OGRE"]
11:36:54 <aruns> i kind of understand the rest of the line, but i can't see where normal is being included
11:37:05 <aruns> and its not defined in the file (Setup.hs) either
11:37:35 <Cale> aruns: According to the GHC Libraries documentation, normal :: Verbosity
11:37:47 <Cale> and is defined in Distribution.Verbosity
11:37:54 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/Distribution-Verbosity.html#v%3Anormal
11:38:03 <aruns> thanks again
11:38:23 <Cale> (note the index link in the upper right corner of the page)
11:38:40 <Cale> lol, deafening
11:45:49 <tommd> Wow, hogre is a bit... dense.  Not much in the way of modularity or haddock documentation (yes, yes, see Ogre, but gtk2hs is a good example of reasonable documentation above GTK)
11:46:43 <aruns> you are right it doesnt have much information at all, just the examples
11:46:58 <aruns> i do know ogre and pyogre a bit, so i'm kind of familiar with the api
11:48:20 <aruns> this is kind of interesting. the rest of setup.hs took my alias for pkg-config with a --dont-define-prefix flag fine and worked. but this section for cgen seems to be taking the explicit path and not picking up the alias
11:49:15 <chrisdone> ugh
11:49:35 <aruns> slightly off topic, but has anyone here worked with Gobo linux ?
11:50:04 <chrisdone> somehow Network.CGI.getInputs is giving strings with unicode characters as HTML entities
11:50:17 <chrisdone> I provide "代 &#20195;" I get back "&#20195; &#20195;"
11:50:24 <chrisdone> :/
11:50:25 <Entroacceptor> aruns: I've made a friend install it, once. Does that count? :)
11:50:29 <kmc> slightly
11:52:12 <burp> has anyone a snippet of utf-8/latin detection for bytestrings?
11:52:42 <aruns> haha well do you know about its packaging mechanism? i think its called Compile
11:52:55 <Entroacceptor> yes...
11:53:39 <aruns> i'm still downloading the iso, but i'm wondering if that works with any language? including haskell, or is it suited best for c/c++ etc.
11:54:02 <Entroacceptor> that I don't really know
11:55:10 <aruns> ok. just wondering what a good cross-platform setup would be. and seeing if there can be anything like a single package manager for win/linux/mac. probably a bit too much to ask for
11:55:25 <aruns> cross-platform development platform
11:55:48 <aruns> i think there is one too many platform in that sentence, i need sleep
11:55:58 <xplat> even microsoft can't settle on a single package manager
11:56:39 <xplat> for a while they were close to settling on msi but now they have update.exe or something that can't be slipstreamed on XP disks
11:56:43 <kmc> does windows even have a package manager yet?
11:56:57 <kmc> i mean can i type "foo" and have it download and install the package named foo?
11:57:35 <xplat> if you know debian, it has a (poor) equivalent of dpkg but no equivalent of apt.
11:57:53 <kmc> right
11:57:57 <Twey> And always has had, since about Windows 3.1
11:58:03 <aruns> there is a dpkg for windows ?
11:58:08 <Twey> Good old PKGMAN.EXE
11:58:12 <aristid> aruns: hmm .msi?
11:58:14 <kmc> just remember, Windows is the user friendly OS, Linux only for super nerds
11:58:19 <aruns> ahh that
11:58:20 <Twey> Heh
11:58:51 <Martty> im not sure what size windows packages repository would be
11:58:54 <aruns> well packaging and installing software and generally closed source msi and whatever else
11:59:02 <kyagrd> kmc, what is user friendly is the hardware vendors who preinstall the OS
11:59:23 <aruns> but i'm kind of talking along the lines of open source - so cygwin has its package manager. mingw seems to have released a auto installer
11:59:48 <kyagrd> For non-nerds/geeks installing OS is itself a mission impossible task whatever OS it is and however simple the installer is don't matter
12:00:04 <Twey> They just look at it and go ARGH WHAT DO I DO
12:00:17 <xplat> msi is pretty weak tech, though, it's recommended against uninstalling msis without first uninstalling each one installed afterward O_o
12:00:20 <aristid> kyagrd: guessing the key needed to get the BIOS to boot from CD is non-trivial :D
12:00:53 <bos> has anyone used the FFI successfully with blocking socket calls?
12:01:15 <xplat> for extra fun, the UI doesn't tell you what order they were installed in
12:01:28 <ulfdoz> xplat: msi is not much beyond shar, it is just colored.
12:01:33 <Twey> xplat: Haha
12:04:51 <chrisdone> ah, oops
12:05:43 <chrisdone> I forgot Network.CGI sends the page as ISO-8859-1. thus the browser sends unsupported characters as html entities
12:06:18 <Twey> Ew
12:06:52 <aristid> the (a -> b) instance of Monoid is endo, right?
12:07:07 <chrisdone> Twey: yeah
12:11:17 <roconnor> aristid: no
12:11:25 <kmc> there's no (a -> b) instance
12:11:34 <kmc> it would have to be (a -> a)
12:11:34 <roconnor> aristid: Endo-, prefix referring to something internal 
12:11:41 <kmc> and that's newtype-wrapped as Endo
12:11:50 <roconnor> aristid: in math it means when the codomain and domain are the same
12:11:53 <aristid> kmc: huh? yes, there is an (a -> b) instance
12:12:00 <kmc> oh
12:12:10 <kmc> you mean (Monoid b) => (a -> b) ?
12:12:15 <roconnor> there is a (Monoid b)  => (a -> b) instance
12:12:18 <roconnor> but it isn't Endo
12:12:18 <aristid> instance (Monoid b) => Monoid (a -> b) -- Defined in Data.Monoid
12:12:26 <kmc> f ++ g = \x -> f x ++ g x
12:12:33 <roconnor> it is pointwise
12:12:36 <kmc> that's not endo
12:12:44 <aristid> yeah i see it now
12:14:53 <djahandarie> Oh, that's a neat instance
12:15:24 <aristid> yes, i only wish Text.JSON.Result a was a Monoid too :/
12:15:37 <aristid> maybe i'll add an orphan instance
12:15:47 <djahandarie> DUN DUN DUN
12:16:07 <aristid> djahandarie: is that the danger music?
12:16:11 <xplat> what would Text.JSON.Result do if it were a Monoid?
12:16:38 <aristid> xplat: much like First
12:17:26 <djahandarie> aristid, yeah, orphan instances should generally be avoided
12:17:31 <djahandarie> Ask the author to include it
12:17:31 <aristid> > getFirst . msum . map First $ [Nothing, Just 1, Just 2]
12:17:32 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Monoid.First)
12:17:32 <lambdabot>    arising from...
12:17:44 <djahandarie> And if that isn't possible wrap it with a newtype and write the instance for that
12:17:51 <aristid> djahandarie: :/
12:19:38 <roconnor> aristid: is  Text.JSON.Result on hackage?
12:20:04 <aristid> roconnor: it's in the package json
12:20:13 <aristid> so yeah i'm sending a mail to sigbjorn finne
12:20:30 <djahandarie> It's usually a good move to do that. Often there is a reason an instance isn't declared
12:20:31 <roconnor> aristid: I would add the monoid instance directly to hackage, then email the author to let them know you've done this. :)
12:20:40 <aruns> :t (</>)
12:20:41 <lambdabot> Not in scope: `</>'
12:20:42 <aristid> roconnor: that is possible?
12:20:49 <roconnor> aristid: do you have a hackage account?
12:20:52 <aruns> @type (</>)
12:20:52 <aristid> roconnor: no
12:20:53 <lambdabot> Not in scope: `</>'
12:21:00 <djahandarie> roconnor, it'd still be an orphan instance wouldn't it?
12:21:01 <roconnor> aristid: oh, I guess it isn't possible :(
12:21:04 <aristid> roconnor: i thought only the maintainer can upload packages
12:21:16 <aristid> can i get a hackage accoutn?
12:21:25 <roconnor> djahandarie: not if you add the instance right to Text.JSON.Result
12:21:33 <roconnor> aristid: you can ask for one.
12:21:39 <aristid> who?
12:21:42 <roconnor> aristid: I don't know what the criteron is
12:21:50 <aristid> i'm very trustworthy.
12:21:51 <roconnor> aristid: but I think it might be asking for one
12:22:17 <roconnor> aristid: Q1: will you abuse your account by modifying other people's packages? :D
12:22:17 <aristid> when somebody says on IRC that he is trustworthy, there is no remaining doubt possible.
12:22:23 <Saizan> aristid: http://hackage.haskell.org/packages/accounts.html
12:22:53 <aristid> hmm it's probably best to just send the request to the maintainer
12:23:20 <roconnor> aristid: I've modified other people's packages before
12:23:28 <roconnor> aristid: but only to make bug fixes, not interface changes
12:23:45 <xplat> can you justify why a First-like instance is so much more useful than other possible instances (direct or overlapping) that it is worth adding to the package instead of just wrapping in First?
12:24:19 <djahandarie> Yeah I don't think modifying another person's package is a good idea
12:24:26 <djahandarie> Especially if it is an interface change
12:24:35 <djahandarie> (And instances are automatically imported so it is)
12:25:22 <aruns> resCgenHs = resCgenHsBase</>"Graphics"</>"Ogre"  - anyone know what the </> operator does ? is it concating file paths
12:25:35 <aruns> cant seem to find anything in the docs
12:25:49 <xplat> that's sure what it looks like it's doing
12:26:06 <roconnor> aruns: it does (++"/"++) on unix and (++"\"++) on windows
12:26:18 <kmc> Arnar, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/filepath-1.1.0.4/System-FilePath-Posix.html#v%3A%3C%2F%3E
12:26:24 <kmc> sorry
12:26:26 <kmc> aruns,
12:26:40 <chrisdone> mauke: what's that link to the text file that basically demonstrates a bunch of unicode characters?
12:26:43 <roconnor> and probably does (++"."++) on CPM
12:26:54 <roconnor> CP/M
12:27:08 <xplat> i would be surprised if it did anything on CPM :)
12:27:11 <aruns> thanks. gaah so its taking my mingw system as ... hmm what system has / and \ ? i can never keep track :P
12:27:47 <kmc> :t (++"/"++)
12:27:48 <lambdabot> parse error on input `)'
12:27:49 <kmc> :(
12:27:53 <chrisdone> lol
12:28:04 <roconnor> pseudo haskell :)
12:28:07 <chrisdone> intercalate "/"
12:29:58 <Twey> If only, eh
12:29:59 <chrisdone> :t on (++) id
12:30:00 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:30:07 <chrisdone> :-)
12:30:13 <Twey> Cute
12:30:33 <aruns> has anyone worked with cgen? how do i get it to use / instead of \ ?
12:30:37 <Twey> :t ((++ "/") . ++)
12:30:38 <lambdabot> parse error on input `++'
12:30:40 <Twey> Er
12:30:42 <zachk> @src on 
12:30:42 <lambdabot> Source not found. It can only be attributed to human error.
12:30:43 <Twey> :t ((++ "/") . (++))
12:30:44 <lambdabot>     Couldn't match expected type `[Char]'
12:30:44 <lambdabot>            against inferred type `m -> m'
12:30:44 <lambdabot>     Probable cause: `++' is applied to too few arguments
12:30:51 <chrisdone> :t on
12:30:52 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:30:57 <Twey> :t ((++) . (++ "/"))
12:30:58 <lambdabot> [Char] -> [Char] -> [Char]
12:31:00 <Twey> Right
12:31:32 <djahandarie> :t fmap (++) (++ "/")
12:31:33 <lambdabot> [Char] -> [Char] -> [Char]
12:32:13 <mauke> chrisdone: http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-demo.txt ?
12:33:09 <chrisdone> mauke: that's exactly it. thanks!
12:33:27 <copumpkin> > sequence [Just 5, Just 7, Just 1]
12:33:28 <lambdabot>   Just [5,7,1]
12:33:34 <copumpkin> > sequence [Just 5, Just 7, Nothing, Just 1]
12:33:35 <lambdabot>   Nothing
12:33:51 <copumpkin> > msum [Just 5, Just 7, Nothing, Just 1]
12:33:52 <lambdabot>   Just 5
12:34:16 * roconnor wishes MonadPlus had one set of semantics
12:36:12 <monochrom> ♥ haskell
12:36:16 <chrisdone> I actually don't know why msum returns Just 5 there
12:36:31 <xplat> isn't the whole point of MonadPlus (and Monad for that matter) that you can change the semantics by changing the type?  ^_^
12:36:33 <chrisdone> it's because Just 7 + Nothing = Nothing?
12:36:36 <copumpkin> monochrom: you really do love haskell, don't you
12:36:40 <monochrom> because Just 5 `mplus` blah = Just 5
12:36:49 <copumpkin> chrisdone: it's giving you the first "success"
12:36:51 <chrisdone> ahhh
12:36:54 <copumpkin> that's just what it does :P
12:37:11 <chrisdone> > Just 5 `mplus` Just 1
12:37:12 <lambdabot>   Just 5
12:37:15 <chrisdone> yeah, I remember now
12:37:16 <monochrom> it is not like really nondeterministic
12:37:20 <copumpkin> > msum [Nothing, Just 3, Just 7, Nothing, Just 1]
12:37:21 <lambdabot>   Just 3
12:38:07 <xplat> mplus is consistent with the mapping [a, _] -> Just a, [] -> Nothing
12:38:22 <Gracenotes> M_Mplus
12:38:23 <chrisdone> I used the mplus instance for backtracking on my wordcloud library
12:38:23 <roconnor> xplat: there are two different sets of laws for MonadPlus
12:39:19 <chrisdone> http://github.com/chrisdone/wordcloud/blob/master/Graphics/WordCloud.hs#L119
12:39:19 <xplat> roconnor: oh, hm?  i thought there was only one.  no wonder you're bothered.
12:39:36 <chrisdone> agloToFunc, best and aroundRec all use it. sweet
12:39:47 <xplat> if there's two different sets of laws, there should have been two typeclasses :(
12:39:56 <roconnor> xplat: yes
12:40:18 <roconnor> Maybe should be removed from the MonadPlus class and put in another
12:40:23 <roconnor> IMO
12:41:22 <xplat> the laws for Maybe are different from List?
12:41:31 <chrisdone> foldr1 (best (head rs) s)
12:41:32 <chrisdone> somehow I find the above extremely pleasing to read
12:42:03 <copumpkin> > msum [[1,2], [3], [], [5,6,7]]
12:42:04 <lambdabot>   [1,2,3,5,6,7]
12:42:29 <kmc> > join [[1,2], [3], [], [5,6,7]]
12:42:30 <lambdabot>   [1,2,3,5,6,7]
12:42:41 <copumpkin> xplat: I BET YOU LIKE THAT!
12:42:54 <kmc> @check \xs -> msum xs == join xs
12:42:55 <lambdabot>   "OK, passed 500 tests."
12:43:02 <kmc> @check \xs -> msum xs == join (xs :: String)
12:43:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:43:08 <kmc> @check \xs -> msum xs == join (xs :: [String])
12:43:10 <lambdabot>   "OK, passed 500 tests."
12:43:23 <Heffalump> does John Lato IRC?
12:43:48 <djahandarie> 500 tests usually is not enough for quickcheck to be good
12:44:03 <copumpkin> djahandarie: how about 501?
12:44:44 <djahandarie> copumpkin, dunno, try running a shrinking meta-quickcheck to see where quickcheck fails
12:44:51 <roconnor> how about 2^2^2^2^2 tests?
12:45:07 <copumpkin> left or right-associative? 
12:45:19 <roconnor> copumpkin: the haskell way
12:45:26 <copumpkin> > foldl1 (^) (replicate 5 2)
12:45:26 <lambdabot>   65536
12:45:30 <copumpkin> > foldr1 (^) (replicate 5 2)
12:45:31 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
12:45:49 <tommd> Wow - amazing RNG!
12:46:07 <djahandarie> > foldr1 (^) (replicate 4 2)
12:46:08 <lambdabot>   65536
12:46:09 <chrisdone> RNG?
12:46:16 <xplat> 2^^5 is kind of a lot
12:46:16 <roconnor> copumpkin: that number is smaller than I thought
12:46:48 <noteventime> > length . show $ foldr1 (^) (replicate 5 2)
12:46:49 <lambdabot>   19729
12:46:54 <copumpkin> @let x ^^ n = foldr (^) 1 (replicate n x)
12:46:55 <lambdabot>  Defined.
12:46:59 <copumpkin> > 5 ^^ 2
12:47:00 <lambdabot>   Ambiguous occurrence `^^'
12:47:00 <lambdabot>  It could refer to either `L.^^', defined at <loc...
12:47:03 <copumpkin> lol
12:47:15 <xplat> i would ask lambdabot to compute 3^^^3 but i only have until the end of the universe
12:47:24 <copumpkin> @let x ^^^ n = foldr (^^) 1 (replicate n x)
12:47:24 <lambdabot>  <local>:10:16:
12:47:24 <lambdabot>      Ambiguous occurrence `^^'
12:47:24 <lambdabot>      It could refer to either ...
12:47:26 <djahandarie> @check \n -> foldl1 (^) (replicate (n+1) 2) == foldr1 (^) (replicate n 2)
12:47:26 <lambdabot>   "Falsifiable, after 0 tests:\n3\n"
12:47:32 <copumpkin> @let x ^^^ n = foldr (L.^^) 1 (replicate n x)
12:47:33 <lambdabot>  Defined.
12:47:39 <copumpkin> > 2 ^^^ 3
12:47:40 <lambdabot>   65536
12:47:44 <copumpkin> > 2 ^^^ 4
12:47:45 <lambdabot>   65536
12:47:50 <copumpkin> whoops
12:48:36 <ppr> @pl \i f u -> i (f u) u
12:48:37 <lambdabot> flip flip id . liftM2
12:48:40 <noteventime> What's the disambiguating L? Local?
12:49:17 <xplat> Lambdabot?
12:50:07 <noteventime> I'm stupid
12:53:09 <xplat> when i define that ^^^ it returns 65536 for everything after 3 ... after increasingly long pauses
12:54:21 <Mitar> why is not IO defined as Monad.ST by default?
12:54:23 <xplat> when i do 2 ^^^ 4 by hand (2 ^^ 65536) it pauses forever
12:54:31 <roconnor> xplat: what is the type of replicate?
12:54:46 <djahandarie> @type replicate
12:54:47 <lambdabot> forall a. Int -> a -> [a]
12:54:54 <djahandarie> @type replicateM
12:54:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:54:56 <copumpkin> ah, that would explain it
12:55:01 <xplat> and by 'forever' i mean 'physically indistinguishable from infinity except by abstract reasoning'
12:55:02 <copumpkin> :t genericReplicate
12:55:03 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
12:55:08 <djahandarie> Ah
12:55:10 <copumpkin> use that
12:55:19 <djahandarie> Wow heh that is a little odd
12:55:50 <xplat> actually i can't interrupt it, i had to pause and kill
12:56:19 <djahandarie> Don't let the OOM killer run loose
12:57:10 <xplat> roconnor: good catch
12:57:52 <djahandarie> If you added an :: Integer somewhere in there it should have given you an error at some point for not type-checking
12:58:27 <djahandarie> But that one explicit Int forced all the Integral / Num types to Int :-(
12:58:36 <djahandarie> Type inference gone wrong!
13:02:49 <aristid> is bind (=<<) or (>>=)?
13:03:03 <medfly> @src bind
13:03:03 <lambdabot> Source not found. Maybe you made a typo?
13:03:30 <aristid> i mean semantically:)
13:03:30 <copumpkin> aristid: the latter
13:03:35 <roconnor> I like how in haskell data dependencies are independent of control flow
13:03:43 <aristid> copumpkin: oh, too bad
13:03:59 <aristid> if i have an operation that is similar to (=<<), how could i name it? :D
13:04:07 <roconnor> ... or maybe Haskell has no control flow
13:04:10 <roconnor> :O
13:04:17 <roconnor> aristid: (-<<)
13:04:59 <aristid> roconnor: i want a textual name, because i have a set of functions returnQ (similar to return), joinQ (similar to join), and now i want fooQ that is like (=<<)
13:05:42 <Saizan> bindQ?
13:06:02 <roconnor> bindQ
13:06:04 <xplat> @check \mebbe -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in mebbe == ltm mtl mebbe
13:06:05 <lambdabot>   Couldn't match expected type `[t]'
13:06:09 <Saizan> kliesliStarQ
13:06:11 <byorgey> bind is usually the other way around though
13:06:12 <xplat> dnibQ
13:06:17 <roconnor> =<< is called bind
13:06:26 <roconnor> ... though i often also call >>= bind
13:06:28 <aristid> roconnor: copumpkin said (>>=) is bind
13:06:28 <byorgey> xplat++
13:06:40 <aristid> k so i'll settle for bindQ
13:06:41 <roconnor> oh right
13:06:49 <roconnor> >>= is called bind
13:06:56 <roconnor> though I often call =<< bind
13:07:25 <Saizan> let the type disambiguate, unless you also need a name for (>>=)
13:07:26 <xplat> @check \mebbe -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in mebbe == ltm $ mtl mebbe
13:07:26 <lambdabot>   Couldn't match expected type `a -> b'
13:07:43 <aristid> Saizan: no, (=<<) suits me better
13:07:44 <roconnor> I'd still use bindQ, unless you also plan to have a name for flip bindQ
13:08:05 <roconnor> ya
13:08:09 <roconnor> what Saizan said
13:08:29 <aristid> hmm actually it will be bindIncreasingQ
13:09:14 <xplat> @check \mebbe -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in mebbe == (ltm $ mtl mebbe)
13:09:15 <lambdabot>   "OK, passed 500 tests."
13:11:19 <chrisdone> what do you call (>=>)? I call it the fish
13:11:47 <trounce> trounce@linux-agko:~> ghci
13:11:47 <trounce> GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
13:11:47 <trounce> Loading package ghc-prim ... linking ... done.
13:11:47 <trounce> Loading package integer-gmp ... <command line>: can't load .so/.DLL for: gmp (libgmp.so: cannot open shared object file: No such file or directory)
13:11:52 <trounce> any advice?
13:11:53 <copumpkin> chrisdone: kleisli composition
13:11:54 <chrisdone> kliesli composition?
13:11:58 <roconnor> chrisdone: I call it Klesli compose
13:11:58 <chrisdone> ya
13:12:07 <xplat> @check \mebbes -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in (msum . (map mtl)) mebbes == (mtl . msum) mebbes
13:12:08 <lambdabot>   "Falsifiable, after 1 tests:\n[Just (),Just (),Just ()]\n"
13:12:09 <huntse> "fish" is better.
13:12:34 <chrisdone> you can tune a kleisli composition, but you can't tuna fish!
13:12:43 * huntse sniggers
13:13:34 <trounce> running opensuse 11.3
13:13:46 <trounce> installed from source
13:14:19 <Saizan> trounce: do you have libgmp installed?
13:14:25 <xplat> @check \mebbes -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in (ltm . msum . (map mtl)) mebbes == (ltm . mtl . msum) mebbes
13:14:26 <lambdabot>   "OK, passed 500 tests."
13:14:56 <Saizan> and the file libgmp.so in particular
13:14:58 <kyagrd> Oh, when did lambdabot increased 500 quickcheck?
13:15:10 <trounce> noone?
13:15:12 <chrisdone> when cale got his new computer
13:15:27 <Cale> ?
13:15:40 <chrisdone> (I make joke)
13:15:41 <Saizan> trounce: i've asked you if you have a libgmp.so file on your machine
13:15:46 <sshc> Which order of arguments is better?  "Container -> Args -> Result" or "Args -> Container -> Result"?
13:15:47 <xplat> @check \lists -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in (msum . (map ltm)) mebbes == (ltm . msum) mebbes
13:15:48 <lambdabot>   Not in scope: `mebbes'Not in scope: `mebbes'
13:15:59 <sshc> Data.Map uses the latter, but I've also seen tho former used
13:15:59 <xplat> @check \lists -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in (msum . (map ltm)) lists == (ltm . msum) lists
13:16:00 <lambdabot>   "OK, passed 500 tests."
13:16:06 <trounce> I missed that
13:16:08 <Cale> I did nothing to the lambdabot configuration. Maybe a new version of QC was installed on the machine that lambdabot is running on. Lispy might know something.
13:16:12 <bos> dcoutts_: dcoutts: ping?
13:16:16 <xplat> @check \lists -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in (msum . (map ltm)) lists == (ltm . msum) (lists :: [Int])
13:16:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:16:25 <trounce> checking
13:16:31 <xplat> @check \lists -> let mtl x = case x of Just x -> [x]; Nothing -> [] in let ltm x = case x of x:_ -> Just x; [] -> Nothing in (msum . (map ltm)) lists == (ltm . msum) (lists :: [String])
13:16:31 <lambdabot>   "OK, passed 500 tests."
13:16:44 <Saizan> xplat: lambdabot also answers in private :)
13:16:58 <lispy> Cale: I installed gunzip recently, but that's all that was changed.
13:16:59 <xplat> aha!
13:17:12 <sshc> Ah, http://www.haskell.org/haskellwiki/Parameter_order
13:17:22 <sshc> Data.Map is right and RWS disagrees
13:17:28 <Mitar> why is not IO defined as http://Monad.ST/ by default?
13:17:55 <xplat> anyway, i can't see where Maybe is different as a MonadPlus from List ... ?
13:18:19 <aristid> Mitar: http?!
13:18:20 <Twey> :t mplus
13:18:21 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
13:18:31 <Twey> > Just 5 `mplus` Just 8
13:18:32 <lambdabot>   Just 5
13:18:35 <trounce> no but I have libgmp3 and libgmpxx4
13:18:39 <Twey> > [5] `mplus` [8]
13:18:40 <lambdabot>   [5,8]
13:18:46 <Twey> xplat: That's how
13:18:58 <Mitar> http?
13:18:58 <Mitar> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad-ST.html
13:19:06 <trounce> YaST doesnt seem to recognize libgmp.so
13:19:10 <Saizan> xplat: http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
13:19:17 <xplat> Twey: that doesn't differ if you consider 'Just foo' to mean 'any list starting with foo'
13:19:34 <Saizan> trounce: you could make a symlink i guess
13:19:50 <trounce> Saizan: how would I do that?
13:20:23 <Saizan> trounce: with ln
13:20:34 * devinus wonders if soon Haskell will be as synonymous with distributed concurrent parallel applications as erlang...
13:20:42 <sm> parsec's implementation of guard calls error, does that sound right ?
13:20:56 <trounce> why does ghci even need this
13:20:56 <Twey> xplat: Ummm, sure
13:21:04 <trounce> is thins not a GIMP thing?
13:21:07 <nlogax> i need to stuff a date into sqlite3, i figured a unix timestamp would be the easiest, sqlite doesn't have any fancy date types anyway. but how do i get a Double or something out of a POSIXTime? can't find it
13:21:11 <Twey> xplat: But that's not what it means, is it?  :þ
13:21:13 <Saizan> trounce: no
13:21:30 <Saizan> trounce: the GMP library is used to implement Integer
13:21:31 <Twey> xplat: [a] has more information than Just a
13:21:32 <kmc> gmp /= gimp
13:21:37 <trounce> so what do I link to where
13:21:49 <kmc> gmp is the GNU Multiple Precision Arithmetic library 
13:22:00 <Saizan> trounce: first of all, do you have a package like "libgmp3" installed?
13:22:10 <trounce> yes
13:22:14 <trounce> I have that very one
13:22:26 <Saizan> does it include a .so file?
13:22:39 <trounce> I'm not very good at this
13:22:41 <trounce> bare with me
13:23:22 <trounce> Saizan: I wouldnt know how to check
13:23:28 <Saizan> i've never used yast, but there should be a way to tell which files belong to libgmp3
13:23:51 <trounce> yes ok
13:24:12 <trounce> it has an so.3 and an so.3.5.2 in it
13:24:39 <trounce> and its in /usr/lib
13:25:02 <Saizan> ok, so you want to link /usr/lib/libgmp.so.3 to /usr/lib/libgmp.so
13:25:05 <xplat> oh, i see where it goes wrong now
13:25:56 <aristid> yay for "case (a,b) of"
13:26:23 <xplat> Saizan: thanks for the reform link, it was a good enough explanation
13:26:28 <Saizan> (or should have i said link .../libgmp.so to ../libgmp.so.3 ?)
13:26:28 <trounce> ok it looks like there are more hardlinks to be made, but I think I can handle it from here
13:26:46 <trounce> no it seemed to have worked
13:27:05 <Saizan> anyhow /usr/lib/libgmp.so should be the link (usually it'd be a soft one) to /usr/lib/libgmp.so.3
13:27:27 <trounce> oh wait it was actually the same error
13:27:31 <trounce> ok
13:27:35 <trounce> one more try
13:27:55 <xplat> it's funny, it turns out to be basically the same issue that bit me with scala's parser combinators and their inherent MonadPlus instance ...
13:28:44 <xplat> which was really a MonadOr
13:29:03 <monochrom> @quote monochrom MonadOr
13:29:03 <lambdabot> monochrom says: MonadOr is french for Gold Monad.
13:29:28 <aristid> lol
13:29:40 <Twey> Hehe
13:29:48 <Twey> Le classique Monad d'Or
13:30:44 <trounce_> making a mess of things
13:30:56 <trounce_> ok I hardlinked it both ways and still not working
13:31:07 <sm> what's the right way to have a parsec parser abort the whole parse, other than error ? Eg if it fails, I don't want an enclosing choice parser to try other choices.
13:32:03 <Saizan> trounce: both ways makes no sense..
13:32:25 <Saizan> trounce: one has to be the real binary, the other a reference to it..
13:33:16 <trounce_> anyway the link has been made is the point and it still gives the same error
13:33:58 <Mitar> is it possible to make threadWaitRead timeout?
13:34:13 <Saizan> trounce: can you paste "ls -l /usr/lib/libgmp3*" in a pastebin?
13:34:14 <aruns> trounce: i think you are looking for ln -s /usr/lib/libgmp.so /usr/lib/libgmp.so.x.y.z
13:34:28 <huntse> trounce_: what does "ldd $( which ghci )" say?
13:35:12 <trounce_> not a dynamic exicute
13:35:18 <Saizan> (the output of that command, i mean)
13:35:19 <huntse> trounce_: good.
13:35:19 <trounce_> exicutable
13:35:28 <Saizan> ghci is a script
13:35:49 <Saizan> also, gmp is loaded via dynload
13:36:13 <trounce_> youre speaking french to me
13:36:28 <kmc> Mitar, what about System.Timeout
13:37:13 <Saizan> trounce: you should read all the messages addressed to you, not just some of them, can you paste the output of "ls -l /usr/lib/libgmp3*" in a pastebin?
13:38:14 <trounce_> sorry it didnt go red
13:38:17 <trounce_> ok
13:38:46 <trounce_> no such file or directory
13:39:19 <trounce_> I was actually just looking for it to see if the link went ok and couldnt find it myself
13:39:23 <Saizan> oh, sorry, it should have been "ls -l /usr/lib/libgmp*"
13:39:41 <trounce_> I dont think its there
13:39:50 <trounce_> I dont know where the damn thing is anymore
13:39:53 <Saizan> can you try this other command?
13:40:27 <trounce_> never mind ok
13:40:39 <roconnor> ghc isn't packaged for opensuse?
13:40:45 <trounce_> trounce@linux-agko:~> ls -l /usr/lib/libgmp*
13:40:45 <trounce_> lrwxrwxrwx 2 root root     15 2010-09-02 18:55 /usr/lib/libgmp.so.3 -> libgmp.so.3.5.2
13:40:45 <trounce_> -rwxr-xr-x 1 root root 346536 2010-07-01 04:35 /usr/lib/libgmp.so.3.5.2
13:40:45 <trounce_> lrwxrwxrwx 1 root root     17 2010-09-02 18:51 /usr/lib/libgmpxx.so.4 -> libgmpxx.so.4.1.2
13:40:45 <trounce_> -rwxr-xr-x 1 root root  13948 2010-07-01 04:35 /usr/lib/libgmpxx.so.4.1.2
13:40:55 <trounce_> I couldnt find one that worked
13:41:16 <Saizan> ok, so the symlink is not there
13:41:45 <trounce_> I could have swarn it went through
13:41:52 <trounce_> should I try again/
13:42:02 <Saizan> trounce_: run "ln -s /usr/lib/libgmp.so /usr/lib/libgmp.so.3" as root
13:42:38 <trounce_> it says File exists
13:43:13 <Saizan> ouch, arguments swapped.
13:43:30 <Twey> Yeah… don't do that
13:43:32 <Saizan> aruns: you got me!
13:43:38 <aruns> doh sorry :)
13:43:51 <trounce_> swap out the .3?
13:43:53 <Saizan> trounce_: "ln -s /usr/lib/libgmp.so.3 /usr/lib/libgmp.so" <- this is the right one
13:43:55 <aruns> always make that mistake, always think it should be swapped, swap it and turns out to be the wrong way around
13:44:10 <Igloo> aruns: It's the same way round as it would be for "cp"
13:44:21 <trounce_> I ran it and got back no outpur
13:44:34 <aruns> Igloo: thats true
13:44:44 <trounce_> is no output a good thing?
13:44:44 <Saizan> trounce_: that means it went fine
13:44:48 <trounce_> ok
13:44:50 <Saizan> try ghci
13:45:02 <aruns> i dont know, its just wired in my brain as thats how it should be
13:45:02 <trounce_> ahahaha were laughing
13:45:08 <trounce_> thanks so much
13:45:36 <Saizan> aruns: same here, i always need to check ln --help :)
13:45:48 <Saizan> trounce_: works now? nice :)
13:45:50 <trounce_> everything is working as expected 
13:45:53 <trounce_> good job team
13:46:50 <aruns> i think you have amazing patience Saizan
13:49:04 <luite> you can even use cp (at least the gnu one) to make the symlink
13:50:05 <aruns> has anyone worked with cgen/hogre or is the guy who wrote it here? antisalonen ?
13:55:09 <chrisdone> @hoogle MonadPlus
13:55:10 <lambdabot> Control.Monad class Monad m => MonadPlus m
13:56:05 <Nibble> @hoogle drugs
13:56:06 <lambdabot> No results found
13:56:08 <Nibble> :(
13:59:20 <sshc> How do I convert a lazy bytestring to a strict bytestring?
13:59:41 <c_wraith> concat . toChunks
13:59:55 <c_wraith> if those names are imported from properly places :)
14:00:04 <c_wraith> That's like B.concat . L.toChunks
14:00:29 <c_wraith> :t BS.concat
14:00:30 <lambdabot> [BSC.ByteString] -> BSC.ByteString
14:00:39 <c_wraith> :t LBS.toChunks
14:00:40 <lambdabot> Couldn't find qualified module.
14:02:26 <c_wraith> @hoogle toChunks
14:02:26 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
14:02:27 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
14:02:48 <c_wraith> :t BLC.toChunks
14:02:49 <lambdabot> Couldn't find qualified module.
14:02:53 <c_wraith> bah. :(
14:03:47 <aristid> :t BL.toChunks
14:03:48 <lambdabot> Couldn't find qualified module.
14:04:04 <aristid> :t BSL.toChunks
14:04:05 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
14:04:23 <c_wraith> ah, ok.
14:04:28 <c_wraith> there we go!
14:04:48 <c_wraith> :t BS.concat . BSL.toChunks
14:04:49 <lambdabot> BSLC.ByteString -> BSC.ByteString
14:06:51 <tommd> Efficiency warning! Danger, Danger!
14:07:21 <c_wraith> In that?  Isn't that pretty much maximally efficient for the operation it's performing?
14:07:47 <c_wraith> Of course, there's the question of whether you actually *need* a single strict bytestring, or if your code could work with multiple sequential ones.
14:08:03 <c_wraith> But if you do need a single value, for some reason, that seems as good as possible.
14:08:18 <kmc> will 'concat' allocate a single buffer and copy them all in?
14:08:26 <kmc> or is it just a fold on pairwise concat?
14:08:34 <jmcarthur> @src BS.concat
14:08:35 <lambdabot> Source not found.
14:08:37 <jmcarthur> if only
14:08:37 <c_wraith> I sure hope it pre-allocates the bufffer.
14:08:50 <kmc> looks like it does
14:08:54 <c_wraith> Since it's strict in the entire input anyway, it might as well.
14:09:02 <kmc> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.7/doc/html/src/Data-ByteString.html#concat
14:09:10 <tommd> c_wraith: Yes, that question is what I was meaning.  It is efficient if you need a strict bytestring (compare, say, to many B.append calls).  But many algs can operate on the chunks with a little modification.
14:09:12 <jmcarthur> yeah, one big one
14:09:18 <kmc> unsafeCreate len $ \ptr -> go xs ptr where len = P.sum . P.map length $ xs
14:09:39 <aristid> what does STRICT2(go) do?
14:09:48 <kmc> #define STRICT2(f) f a b | a `seq` b `seq` False = undefined
14:09:54 <jmcarthur> tommd: not only that, but the chunks are designed to be at least a little cache friendly :)
14:09:55 <tommd> c_wraith: Some algorithms need blocks of particular sizes and thats when I'm ticked off that bytestring doesn't export a way to read in lazy BS in particular chunk sizes (and its default size is not good)
14:10:02 <kmc> a common trick from before bang patterns
14:10:42 <jmcarthur> i do wish you could control lazy bytestring chunk sizes
14:10:52 <jmcarthur> i mean, you can, but it's not pretty
14:11:00 <tommd> I wish they would be at least (mod 128 bits) large
14:11:03 <jmcarthur> and the IO operations can't
14:11:10 <tommd> not this 64 bit multiple we're stuck with right now.
14:11:13 <tommd> (on 32 bit systems)
14:11:19 <jmcarthur> yeah :(
14:13:05 <c_wraith> I'm sort of annoyed that BS.foldr is more strict than it needs to be.
14:13:22 <c_wraith> there's already BS.foldr'
14:13:28 <tommd> huh, never had any issue with that one.  I guess I look for strict right folds.
14:13:29 <c_wraith> Why is BS.foldr strict, too?
14:13:36 <jmcarthur> how is it more strict than it needs to be?
14:13:47 <c_wraith> :t BS.foldr
14:13:48 <lambdabot> forall a. (Word8 -> a -> a) -> a -> BSC.ByteString -> a
14:13:55 <c_wraith> It forces the second argument
14:14:04 <jmcarthur> ah
14:14:08 <c_wraith> Even when the function passed in doesn't need to
14:14:22 <sm> I see.. I'm getting different fail behaviour from parsec 2.1.0.1 and 3.1. If anyone knows why, let me know; their code looks similar
14:14:54 <jmcarthur> > BS.foldr (:) undefined (BS.pack "foo")
14:14:55 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
14:14:55 <lambdabot>         against inferred type...
14:15:03 <jmcarthur> > BS.foldr (:) undefined (BSC.pack "foo")
14:15:04 <lambdabot>   *Exception: Prelude.undefined
14:15:10 <jmcarthur> > head $ BS.foldr (:) undefined (BSC.pack "foo")
14:15:11 <lambdabot>   *Exception: Prelude.undefined
14:15:12 <jmcarthur> lame
14:15:14 <c_wraith> yeah
14:15:17 <c_wraith> that was my thought, too
14:17:21 <jmcarthur> #define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined     -- gross!
14:17:43 <Mark_> Hey, Fritz!
14:17:48 <Mark_> You learning Haskell
14:18:06 <fritz_> yes, we are! (we are a class at a school)
14:18:27 <Mark_> Willamette University? 
14:18:38 <fritz_> hey, good guess! :)
14:18:48 <jmcarthur> wait, tryhaskell in front of a classroom?
14:19:03 <fritz_> they are happy & laughing at this
14:19:08 <jmcarthur> that's awesome
14:19:09 <c_wraith> Willamette?  I have a friend there.  In the CS program, even, I think.
14:19:22 <copumpkin> c_wraith: quick, reveal his/her identity!
14:19:23 <fritz_> hey, who is it?
14:19:47 <c_wraith> If he's there, he'll know me by this name. :)
14:20:04 <Bobdole> Wait, are you fritz ruehr?
14:20:04 <fritz_> well, he's not in this class, but I'll ask at tea
14:20:23 <fritz_> only if you are Bob Dole! (well, yeah)
14:20:33 <Bobdole> I am, as a matter of fact!
14:20:34 <jmcarthur> same ip range :P
14:20:53 <jmcarthur> Mark_ too
14:21:56 <Bobdole> Oops! Time to make a dramatic exit!
14:22:08 <Mark_> Goodbye, Mr. Dole!
14:22:28 <fritz_> (sorry, distracted by actual tryhaskell in other window)
14:22:39 <jmcarthur> chrisdone: your irc thingy on tryhaskell is being used by a classroom right now
14:23:04 <tommd> What class?
14:23:27 <Mark_> Introduction to Functional Programming at Willamete University
14:24:09 <tommd> Ok then.  Hello from Portland State.
14:24:28 <jmcarthur> any good functional programing research go on at willamete?
14:24:34 <fritz_> Hey! I was just talking about you guys!
14:24:39 <jmcarthur> i know pdx does
14:25:26 <fritz_> reverse ["foo","bar","baz"]
14:25:32 <fritz_> Ooops, wrong window
14:25:32 <jmcarthur> gotcha! http://www.willamette.edu/~fruehr/254/
14:25:39 <jmcarthur> hey you can do that here too ;)
14:25:44 <tommd> About how Habit or Tims dependently typed language will take over the world?  I know it seems like Agda, Coq, F#, and the ML family are falling to them already but don't assume success yet.
14:25:46 <fritz_> off by one: it's now 154
14:25:54 <jmcarthur> > reverse ["foo", "bar", "baz"]
14:25:55 <lambdabot>   ["baz","bar","foo"]
14:26:50 <jmcarthur> no link to real world haskell on that page :(
14:27:53 <fritz_> second day of class, give me a break!
14:28:04 <fritz_> (they are still laughing at y'all)
14:28:20 <jmcarthur> @protontorpedo
14:28:20 <lambdabot> is there an oo db in haskell?
14:28:33 <copumpkin> ooh yeah, we should troll the classroom
14:28:34 <Mark_> Well, that's what happens when you let the internet into a classroom. =)
14:28:42 <jmcarthur> definitely
14:28:59 <jmcarthur> i've never trolled a classroom before
14:31:16 <tommd> Ok class - your assignment is to get the latest crypto-api and comment.  Run:
14:31:16 <tommd> darcs get http://code.haskell.org/~tommd/crypto
14:31:16 <tommd> And see the 2 latest blogs at tommd.wordpress.com - I need feedback.
14:31:35 <tommd> Or ignore me and follow the instruction - that might be wiser.
14:31:35 <jmcarthur> great, instead of trolling the class we will just spam it
14:32:06 <Twey> >.<
14:32:13 <tommd> jmcarthur: Weren't you involved in discussing the network work that Creighton started?
14:32:28 <jmcarthur> you must be mixing me up with somebody else, i think
14:32:32 <tommd> ok
14:32:51 <jmcarthur> what network work?
14:33:21 <tommd> Creighton and I had started to revamp the network package
14:33:42 <jmcarthur> i have discussed the API before, but i don't remember the context
14:33:45 <tommd> Basically, he was annoyed by the lack of extensibility of the SockAddr (it could have been a type class)
14:33:56 <jmcarthur> it wasn't with any knowledge of changes going on though
14:34:03 <tommd> And I was annoyed by the lack of features (no access to any IP_ or SOCK_ options)
14:34:22 <tommd> So we set off to fix this, but shelved the project a bit ago as we're both busy.
14:37:35 <BONUS> idea: a node.js-like library for haskell
14:37:56 <djahandarie> Sounds like a neat idea
14:38:07 <BONUS> that enables real easy async i/o
14:38:15 <BONUS> with not a lot of code
14:38:20 <BONUS> might be worth looking into
14:38:29 <aristid> BONUS: in haskell it might actually be usable, other than in JS:
14:38:36 <aristid> :=.
14:38:42 <BONUS> hehe
14:39:27 <jmcarthur> i'm not familiar with node.js. it looks a lot like stream programming. am i far off?
14:39:52 <chrisdone> my manager used haskell to model the roles in the corporate hierarchy and, surprise, found some inconsistencies
14:40:09 <jmcarthur> of course
14:40:25 <jmcarthur> where do you work that your manager uses haskell?
14:40:35 <BONUS> jmcarthur: not far off. basically it's for writing servers and such by making all the i/o asynchronous and managing it with higher order functions
14:40:37 <chrisdone> 'CREATE-NET'
14:40:41 <BONUS> which sounds right up haskell's alley
14:40:50 <jmcarthur> ah
14:40:57 <mrsolo> Is there a synonym mappend?
14:41:28 <chrisdone> fwiw my colleague doesn't rate node.js much but uses it because it has and will have a large user base
14:41:30 <jmcarthur> mrsolo: not a standard one
14:41:39 <chrisdone> woops I thought we were in -blah
14:41:54 <aristid> chrisdone: using haskell to model the corporate hierarchy? sounds unusual, but i guess that proves my theory that haskell is perfect for business logic ;)
14:42:06 <jmcarthur> mrsolo: but if your problem is that you are mappending a lot of things in one line, you could use Data.Foldable.fold to save some characters
14:42:17 <jmcarthur> or of course you could define a shorter name or operator for it
14:42:32 <jmcarthur> aristid: don't forget financial contracts ;)
14:42:56 <aristid> jmcarthur: heh
14:43:05 <chrisdone> aristid: I mean using the type system. putting things into the type system is a great way to get requirements. we were all debating the various roles in a conference peer review process, and I opened up a Haskell buffer and started writing out some types. "is this accurate?" "um, yes." "done."
14:43:14 <jmcarthur> aristid: http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm
14:43:27 <BONUS> http://paste.tryhaskell.org/63/node_hs_ <--- like this
14:43:48 <aristid> jmcarthur: hey, i'll read that
14:43:58 <chrisdone> BONUS: hey you're using my paste site :P ^5
14:44:13 <BONUS> haha, its very nice yeah
14:44:16 <chrisdone> that looks fun
14:44:25 <aristid> chrisdone: i can't really imagine how you did it
14:44:31 <jmcarthur> chrisdone: i don't know if you noticed earlier, but there is a class watching us through tryhaskell
14:44:36 <BONUS> it just seems like doing something like node.js would be natural in haskell
14:44:41 <BONUS> i gotta look more into node.js first though
14:44:48 <chrisdone> jmcarthur: there is? /me reads backscroll
14:44:58 <aristid> node.js is dead - long live node.hs
14:45:01 <fritz_> Hey, Chris, (@chris??): thanks for TryHaskell!!
14:45:13 <aristid> fritz_: his nickname is chrisdone
14:45:30 <chrisdone> fritz_: hey there, that's no problem I'm glad you like it :-D
14:45:36 <mrsolo> jmcarthur, nice thanks 
14:45:45 <fritz_> yeah, yeah, you young people and ur fancy chat stuff ... (where's talk?)
14:46:04 <djahandarie> fritz_, you'd probably be surprised at the amount of old people in this channel :)
14:46:06 <fritz_> :)
14:46:18 <fritz_> was Mark mark jones by chance?
14:46:33 <Mark_> Guess again =)
14:46:49 <djahandarie> I don't think I've seen him in this channel
14:46:59 <djahandarie> Simon Marlow is in here however
14:47:06 <Mark_> Tue, it's my first time here, too.
14:47:11 <Mark_> True*
14:47:19 <chrisdone> haha, that's awesome. tryhaskell in a classroom is my ideal scenario!
14:47:56 <djahandarie> chrisdone, quick, start flashing inappropriate content on the screen! I'm sure you have prepped material for this
14:47:59 <jmcarthur> fritz_: is there anything you wish was different about tryhaskell for a classroom setting like this?
14:48:02 <fritz_> They are lovin' it (cue McD's commercial jingle)
14:48:14 <sioraiocht> chrisdone: had never seen tryhaskell before
14:48:17 <sioraiocht> it's brilliant1
14:48:26 <chrisdone> \o/
14:48:26 <fritz_> It hink it's great; I set my kid on it earlier this summer, too
14:48:29 * jmcarthur can only think of the Old Spice tune
14:48:47 <Mark_> The Haskell is now DIAMONDS!
14:49:02 <fritz_> I actually did the old spice thing with "look at your Java, now look at this haskell, ..." last time
14:49:13 <jmcarthur> lol
14:49:26 <jmcarthur> I am the language you want your language to look like!"
14:49:48 <jmcarthur> to... smell like?
14:49:53 <fritz_> (see <http://www/~fruehr/154/figs/JavaVSHaskell.pdf> for old spicy stuff)
14:50:07 <aristid> fritz_: 404
14:50:15 <jmcarthur> link fail
14:50:20 <jmcarthur> www/?
14:50:38 <fritz_> oops: <http://www.willamette.edu> == www sorry
14:50:38 <Mark_> http://www.willamette.edu/~fruehr/154/figs/JavaVSHaskell.pdf
14:50:38 <aristid> haha my browser goes to www.www.com
14:50:50 <fritz_> yeah, like that
14:51:42 <jmcarthur> slightly unfair comparison in that the Java code outputs the results and the Haskell code is just pure
14:51:45 <aristid> :t ap (==) reverse . map toLower . filter isAlpha
14:51:45 <lambdabot> [Char] -> Bool
14:51:54 <jmcarthur> but all you have to do is add "print" to the front of it, though
14:52:10 <aristid> > ap (==) reverse . map toLower . filter isAlpha $ "abcba"
14:52:11 <lambdabot>   True
14:52:13 <aristid> > ap (==) reverse . map toLower . filter isAlpha $ "abcb"
14:52:14 <lambdabot>   False
14:52:28 <jmcarthur> i did a scary palindrome the other day
14:52:41 <aristid> jmcarthur: more scare than ap (==) reverse?
14:52:52 <aristid> scare=scary
14:53:20 <djahandarie> Yeah that one is pretty frightning if you don't know the ((->) b) monad instance
14:53:27 <djahandarie> :t ap
14:53:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:53:31 <fritz_> OK, class is leaving
14:53:34 <jmcarthur> >  all id $ zipWith (==) =<< uncurry take <<< (`div` 2) . fst . head &&& map snd <<< reverse . zip [1..] $ "abcdedcba"
14:53:35 <lambdabot>   True
14:53:42 <fritz_> Thanks for demo'ing about the wonderful Haskell community 
14:53:44 <Mark_> Bye, Fritz!
14:53:46 <djahandarie> Goodbye fritz_ and students
14:53:49 <fritz_> (which was my first topic today)
14:53:50 <jmcarthur> bye!
14:54:25 <fritz_> and esp. thanks chrisdone for tryhaskell!
14:54:34 <djahandarie> jmcarthur, an arrow palindrome is just cruel man
14:54:41 <djahandarie> Cruel and unusual haskell
14:55:23 <jmcarthur> djahandarie: it's also more efficient than the (==) <*> reverse one ;)
14:55:23 <aristid> > 1 `div` 2
14:55:24 <lambdabot>   0
14:55:26 <fritz_> Bye!
14:55:46 <aristid> jmcarthur: do you have a good numeric palindrome test, too?
14:55:54 <jmcarthur> numeric palindrome?
14:56:04 <aristid> yeah, optimally without going via string
14:56:07 <aristid> or list
14:56:07 <jmcarthur> like for the digits in an integer?
14:56:10 <aristid> yes.
14:56:17 <jmcarthur> ah, no, i hadn't considered that one before
14:57:38 <djahandarie> :t (`div` 2) . fst . head &&& map snd
14:57:38 <lambdabot> forall a b. (Integral a) => [(a, b)] -> (a, [b])
14:58:19 <djahandarie> :t uncurry take
14:58:20 <lambdabot> forall a. (Int, [a]) -> [a]
14:58:24 <kschadt> hello Mark, jmcarthur
14:58:43 <kschadt> Just got out of Fritz's class
14:58:48 <kschadt> remember him?
14:58:48 <jmcarthur> > (1+2+3+4+5+6+7+8+9+8+7+6+5+4+3+2+1)*12345678987654321 == 999999999^2
14:58:49 <lambdabot>   True
14:58:54 <jmcarthur> cool equation
14:58:59 <jmcarthur> kschadt: yup
14:59:18 <jmcarthur> hello!
14:59:30 <kschadt> howdy
15:00:45 <aristid> :t ap (==) reverse . unfoldr (\x -> if x > 0 then Just $ (snd&&&fst) (x `divMod` 10) else Nothing)
15:00:46 <lambdabot> forall b. (Integral b) => b -> Bool
15:00:49 <djahandarie> What would be an algebraic structure which is a vector space with an another binary operator being the inner product?
15:00:57 <aristid> > ap (==) reverse . unfoldr (\x -> if x > 0 then Just $ (snd&&&fst) (x `divMod` 10) else Nothing) $ 151
15:00:58 <lambdabot>   True
15:00:59 <djahandarie> Like some cross between a Lie algebra and a Hilbert Space
15:01:00 <aristid> > ap (==) reverse . unfoldr (\x -> if x > 0 then Just $ (snd&&&fst) (x `divMod` 10) else Nothing) $ 15
15:01:01 <lambdabot>   False
15:01:18 <aristid> but i'm not particularly happy with that version
15:01:42 <jmcarthur> aristid: you said no lists :P
15:01:46 <copumpkin> lol, (snd &&& fst)
15:01:50 <kschadt> well, I'm actually gonna head out, but I'll be comin back here
15:01:53 <kschadt> later, all
15:01:58 <djahandarie> o/
15:01:58 <aristid> jmcarthur: yeah that's part of why i'm not overly happy :D
15:02:09 <jmcarthur> copumpkin: a common idiom for swap
15:02:12 <copumpkin> I know :P
15:02:21 <copumpkin> just amused that we still don't have a swap
15:02:25 <copumpkin> just because nobody can agree on its strictness
15:02:48 <aristid> if a then Just x else Nothing <- does a function exist for that?
15:02:54 <jmcarthur> wait, who argues that it should be strict?
15:02:59 <djahandarie> :t maybe
15:02:59 <Saizan> i think we have a swap now
15:03:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:03:04 <Saizan> and it is strict
15:03:08 <copumpkin> jmcarthur: I vaguely remember seeing a discussion
15:03:20 <ray> why would it be strict?!
15:03:20 <djahandarie> lol uh
15:03:25 <aristid> Saizan: where is the swap?
15:03:41 <aristid> djahandarie: maybe goes the other way
15:03:45 <copumpkin> @let swap ~(x, y) = (y, x); swap' (x, y) = (y, x)
15:03:46 <lambdabot>  Defined.
15:03:58 <djahandarie> aristid, yeah I know
15:04:05 <djahandarie> It doesn't exist in Data.Maybe
15:04:05 <Saizan> http://darcs.haskell.org/libraries/base/Data/Tuple.hs <- se the bottom of this
15:04:10 <sshc> I have a Dynamic which contains a value of a type that is a member of the typeclass Foo.  I only use the functions in the Foo class.  But GHC complains "Ambiguous type variable `a' in the constraint:" when I try to use it.  Is there a way to use it in this manner, regardless of which Foo type it contains?
15:04:11 <Saizan> *see
15:04:17 <aristid> :t guard
15:04:18 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:04:36 <aristid> :t \x y -> guard x >> y
15:04:37 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
15:04:42 <aristid> @pl \x y -> guard x >> y
15:04:43 <lambdabot> (>>) . guard
15:04:56 <Saizan> it'll be in the base for ghc-6.14.1
15:04:59 <aristid> oh, that's actually a reasonable output from @pl
15:05:16 <aristid> Saizan: looking forward to 6.14!
15:05:22 <djahandarie> No it's definitely better written as (flip .) flip id (fmap) liftM2
15:05:29 <copumpkin> I'm looking forward to GHC 7!
15:05:52 <djahandarie> I'm more excited for the GC improvements in simon m's latest branch
15:05:58 <Saizan> sshc: no
15:06:04 <jmcarthur> copumpkin: is that actually in the plans?
15:06:14 <copumpkin> jmcarthur: beats me :P probably not
15:06:31 <aristid> ghc is like linux: perpetually in 2.6.x respectively 6.x
15:06:36 <aruns> is the llvm backend going to be in ghc-6.14 ?
15:06:44 <copumpkin> I think so
15:06:45 <Saizan> sshc: you could use an existential with a Foo context instead of a Dynamic
15:07:23 <Saizan> sshc: or combine the two
15:08:01 <sshc> Saizan: I have a list of Dynamics, and all the values that were wrapped have a type that is an instance of the Foo class
15:08:33 <jmcarthur> it's simon marlow's fault that swap is strict :P
15:08:34 <aristid> @pl \x -> guard (x > 0) >> (Just . swap $ x `divMod` 10)
15:08:35 <lambdabot> ap ((>>) . guard . (> 0)) (Just . swap . (`divMod` 10))
15:09:10 <Saizan> sshc: the point is that you've to store an evidence of that fact
15:10:26 <aristid> :t ap (==) reverse . unfoldr ((>>) . guard . (>0) <*> Just . swap . (`divMod` 10))
15:10:27 <lambdabot> forall b. (Integral b) => b -> Bool
15:10:52 <aristid> i'm not sure if that one is evil or nice
15:11:07 <jmcarthur> eh, still using lists :P
15:11:15 <aristid> yeah but point-free
15:12:10 <aristid> jmcarthur: you still haven't proposed a list-free version either way :P
15:13:25 <jmcarthur> i'm not sure how convenient a non-list version would be
15:13:42 <aristid> hm yeah not using any lists at all might be a pain in the ass
15:13:59 <jmcarthur> especially if the list is just being used to replace what would otherwise be recursion
15:14:19 <jmcarthur> i could do a binary palindrome without lists for a fix size integer
15:14:22 <BONUS> does anyone here post to haskell-cafe from gmail? if so, how do you set up your filters and such
15:14:24 <jmcarthur> *fixed size
15:19:19 <sshc> Saizan: This is essentially what I want:
15:19:36 <sshc> > let x = [toDyn (3 :: Integer), toDyn (6.5 :: Double)]; f :: (Num a) => Dynamic -> Maybe a; f x = fromDynamic x >>= return . (^2) in (f $ x !! 0, f $ x !! 1)
15:19:37 <lambdabot>   Could not deduce (Data.Typeable.Typeable a)
15:19:37 <lambdabot>    from the context (GHC.Num.Nu...
15:20:07 <sshc> The problem is `f'
15:20:49 <Cthulhon> BONUS: In 'has words' in the filter setup, use the search list:"haskell-cafe.haskell.org".
15:21:21 <Saizan> sshc: that'd be easy, adding a Typeable constraint, but from your previous explanation i don't think that's what you want
15:21:23 <Mitar> why IO is not simply replaced by ST on RealWorld?
15:22:33 <BONUS> Cthulhon: just put in that string?
15:22:38 <copumpkin> Mitar: it's an implementation detail
15:23:04 <Cthulhon> With the 'list:' qualifier.
15:23:26 <BONUS> ah so in the box i input list:"haskell-cafe.haskell.org"
15:23:27 <Mitar> exactly
15:23:27 <Mitar> but because ST is more powerful than IO we could have main :: ST RealWorld () no?
15:23:35 <Cthulhon> Yes.
15:23:45 <BONUS> nice, cheerio
15:23:49 <jmcarthur> @let word8Palindrome = (==) <*> (fromIntegral :: Word64 -> Word8) . (`mod` 1023) . (.&. 0x010884422010) . (* 0x0202020202) . (fromIntegral :: Word8 -> Word64)
15:23:51 <lambdabot>  Defined.
15:24:00 <jmcarthur> aristid: ^^
15:24:07 <jmcarthur> it's for binary palindromes
15:24:12 <Mitar> then why it is not like that?
15:24:12 <Mitar> legacy?
15:24:32 <Saizan> Mitar: ST more powerful than IO? in which sense?
15:24:42 <sshc> > let x = [toDyn (3 :: Integer), toDyn (6.5 :: Double)]; f :: (Typeable a, Num a) => Dynamic -> Maybe a; f x = fromDynamic x >>= return . (^2) in (f $ x !! 0, f $ x !! 1, (3::Integer)^2, (6.5::Double)^2)  -- Why is the second one Nothing?
15:24:44 <lambdabot>   (Just 9,Nothing,9,42.25)
15:25:41 <Mitar> saizan: that it can do everything that IO can do, but also values can leave the monad
15:25:42 <Mitar> (and still be pure)
15:25:43 <Saizan> sshc: because the type is choosen by the caller of 'f', and in this case it's defaulting to Integer
15:25:44 <Cthulhon> BONUS: Also, GMail will make list filters for you if you use the 'filter messages like this' option in the menu in the upper-right of messages.
15:26:02 <Saizan> Mitar: ST can't do everything IO can do.
15:26:07 <aristid> jmcarthur: zomg.
15:26:19 <BONUS> ah, nice. so even if i send to haskell-cafe, this filter will keep match on that?
15:26:38 <Cthulhon> It should.
15:26:42 <aristid> :t stToIO
15:26:43 <lambdabot> Not in scope: `stToIO'
15:26:45 <BONUS> cool, thank alot
15:26:50 <Saizan> Mitar: ST let you only deal with chunks of memory in a quite safe way
15:27:12 <Mitar> what can't ST do?
15:27:13 <Saizan> *only let you
15:27:18 <jmcarthur> aristid: convert to Word64, then project 5 copies of it into a single Word64, then mask out one bit from each copy, then collapse it all back down, then convert back to Word8
15:27:22 <Saizan> Mitar: putStrLn "foo"
15:27:36 <Saizan> Mitar: or getLine 
15:27:39 <jmcarthur> > word8Palindrome 0x66
15:27:40 <lambdabot>   True
15:27:43 <aristid> jmcarthur: itsalllogical
15:27:43 <jmcarthur> > word8Palindrome 0x67
15:27:44 <lambdabot>   False
15:27:57 <Mitar> isn't stToIO there for that?
15:28:22 <aristid> > word8Palindrome 0121
15:28:23 <lambdabot>   False
15:28:37 <jmcarthur> 0121?
15:28:37 <Saizan> Mitar: stToIO promotes an ST action into an IO one, you'd need the reverse for that.
15:28:44 <aristid> > 0121
15:28:45 <lambdabot>   121
15:28:48 <jmcarthur> > showHex 121
15:28:48 <lambdabot>   Overlapping instances for GHC.Show.Show
15:28:49 <lambdabot>                              (GHC.B...
15:29:00 <aristid> jmcarthur: what's the octal number syntax?
15:29:13 <jmcarthur> > showHex 121 ""
15:29:14 <lambdabot>   "79"
15:29:18 <Mitar> hmmm
15:29:21 <jmcarthur> > showOct 121 ""
15:29:22 <lambdabot>   "171"
15:29:31 <copumpkin> there isn't one
15:29:33 <jmcarthur> aristid: dunno :\
15:29:34 <copumpkin> thankfully
15:29:40 <jmcarthur> none for binary either
15:29:48 <jmcarthur> in haskell, anyway
15:30:40 <Mitar> thanks
15:30:41 <aristid> i shall try reading papers on kindle!
15:31:18 <jmcarthur> > sum . zipWith (*) (iterate (^2) 1) . map read . reverse $ "110"
15:31:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:31:19 <lambdabot>         against inferred ty...
15:31:23 <jmcarthur> doh
15:31:30 <jmcarthur> > sum . zipWith (*) (iterate (^2) 1) . map (read . pure) . reverse $ "110"
15:31:31 <lambdabot>   2
15:31:36 <jmcarthur> err
15:31:44 <jmcarthur> > sum . zipWith (*) (iterate (*2) 1) . map (read . pure) . reverse $ "110"
15:31:45 <lambdabot>   6
15:31:55 <jmcarthur> there we go
15:32:07 <jmcarthur> @let readBin = sum . zipWith (*) (iterate (*2) 1) . map (read . pure) . reverse
15:32:08 <lambdabot>  Defined.
15:32:28 <jmcarthur> > word8Palindrome . readBin $ "11011"
15:32:29 <lambdabot>   False
15:32:32 <jmcarthur> nope
15:32:48 <aristid> @let readSmallBase b = sum . zipWith (*) (iterate (*b) 1) . map (read . pure) . reverse
15:32:49 <lambdabot>  Defined.
15:33:00 <aristid> > readSmallBase 3 "120"
15:33:01 <lambdabot>   15
15:33:18 <jmcarthur> oh duh
15:33:27 <jmcarthur> word8Palindrome only works for all 8 bits
15:33:35 <jmcarthur> > word8Palindrome . readBin $ "11000011"
15:33:36 <lambdabot>   True
15:33:41 <jmcarthur> > word8Palindrome . readBin $ "11011011"
15:33:42 <lambdabot>   True
15:33:45 <aristid> it's fixed size
15:33:45 <jmcarthur> > word8Palindrome . readBin $ "11011010"
15:33:46 <lambdabot>   False
15:33:48 <jmcarthur> yeah
15:33:49 <aristid> and not up-to-size
15:34:10 <jmcarthur> @pl readSmallBase b = sum . zipWith (*) (iterate (*b) 1) . map (read . pure) . reverse
15:34:11 <lambdabot> readSmallBase = (sum .) . (. (map (read . pure) . reverse)) . zipWith (*) . flip iterate 1 . (*)
15:34:16 <jmcarthur> :\
15:34:32 <aristid> the b is so deep inside..
15:34:37 <jmcarthur> yeah
15:35:03 <aristid> @pl readSmallBase b = sum . zipWith (*) (flip iterate 1 (*b)) . map (read . pure) . reverse
15:35:03 <lambdabot> readSmallBase = (sum .) . (. (map (read . pure) . reverse)) . zipWith (*) . flip iterate 1 . (*)
15:35:15 <aristid> ah, same :D
15:35:32 <djahandarie> There should be something more aggressive than pl
15:35:40 <aristid> and more clever?
15:35:40 <djahandarie> Something that just goes and refactors your entire function
15:35:49 <aristid> @gimmehaskell
15:35:50 <lambdabot> Unknown command, try @list
15:35:57 <Mitar> why would then anyone use stToIO instead of runST from IO directly?
15:36:13 <aristid> Mitar: because he is evil
15:36:14 <chrisdone>  @plint
15:36:31 <djahandarie> Heh
15:36:34 <Mitar> because by passinf RealWorld as state you do not gain anything?
15:36:37 <jmcarthur> Mitar: so you can leak the STRefs as IORefs?
15:36:52 <Mitar> you can leak them?
15:36:58 <jmcarthur> with stToIO i think
15:37:01 <djahandarie> "leak" sure doesn't make it sound desirable
15:37:17 <chrisdone> hmm. hlint is actually improving my coding style. it's hard discipline
15:37:38 <djahandarie> Yeah I like it
15:38:04 <jmcarthur> Mitar: okay, you can't convert them to IORefs i think, but since RealWorld is concrete you should be able to turn around and reuse STRefs in later ST computations (as long as you again use stToIO on that one as well)
15:38:05 <chrisdone> everytime I hit F5 (which is to load my code in the *haskell* buffer) it also runs hlint on the buffer, so instead of a "OK, modules loaded." I get "OK, modules loaded. Redundant 'do', sort that out. Why not ..."
15:38:26 <aristid> Found:
15:38:26 <aristid>   (a -> b -> c) -> (a -> b -> d)
15:38:26 <aristid> Why not:
15:38:26 <aristid>   (a -> b -> c) -> a -> b -> d
15:38:32 <aristid> chrisdone: and that is an improvement?
15:38:33 <jmcarthur> hlint not longer finds anything in my code that i agree with
15:38:47 <jmcarthur> aristid: yeah i hate stuff like that
15:38:53 <jmcarthur> i'd rather leave the old one
15:38:59 <Mitar> so stToIO is more a theoretical idea ;-)
15:39:11 <Mitar> is there any program which uses it?
15:39:14 <jmcarthur> Mitar: what do you mean theoretical? it's real
15:39:22 <aristid> hlint doesn't find many things
15:39:31 <Mitar> i described that in second line ;-)
15:39:43 <aristid> at least for me, i always never get many warnings from hlint
15:40:37 <aristid> -Wall is much more useful
15:40:44 <jmcarthur> Mitar: you could use stToIO if you just happen to be in the IO monad anyway. it might be more aesthetically pleasing than a do-let to some people
15:40:48 <aristid> always=almost
15:40:51 <jmcarthur> Mitar: i dunno, i'm grasping at straws here
15:41:15 <Mitar> ok
15:41:18 <Mitar> thanks
15:41:37 <Mitar> probably it is one of those function which you find when you need them
15:41:38 <Mitar> ;-)
15:42:03 <aristid> chrisdone: but you should make a write-up describing your haskell+emacs setup
15:43:14 <chrisdone> I'll do that as an accompaniment to my emacscast which shows my whole development process
15:44:29 * chrisdone wonders where ManateeLazyCat is tonight
15:44:52 <aristid> chrisdone: just make sure it's fully accessible and understandable without watching the video, because many people cannot or do not like watching video
15:45:38 <chrisdone> this isn't actually video, it's a git repo where each commit is a keypress or buffer change that I intend on making a web viewer for
15:45:51 <djahandarie> -_-
15:45:52 <chrisdone> once I'm satisfied with amelie..
15:46:26 <luite> not an emacs viewer?
15:47:09 <Mitar> amelie? movie?
15:47:17 <aristid> chrisdone: you will get into the guiness book of records for the git repo with the smallest commits :D
15:47:40 <chrisdone> yeah. 37,000 of them
15:48:04 <chrisdone> Mitar: just the name for my pastebin project. but yeah that movie is brilliant
15:48:18 <Mitar> chrisdone: interesting, this was something i also was thinking off
15:48:22 <chrisdone> http://github.com/chrisdone/amelie
15:48:23 <chrisdone> http://github.com/chrisdone/amelie-emacs-cast
15:48:33 <Mitar> why google wave reinvent the well, if you already have git or mercurial
15:48:47 <Mitar> and you already have a federation protocol with push/pull
15:50:09 <p_l> chrisdone: ... I think your granularity is too fine
15:50:21 <chrisdone> p_l: you do? :p
15:50:25 <Mitar> you can go around granularity with tags ;-)
15:50:40 <p_l> chrisdone: otoh, there's a timed-commit tool designed mostly for writers etc.
15:50:46 <Mitar> so you have fine granularity but you then use tags to combine more of them together
15:50:54 <p_l> with granularity set sufficiently low, it could do the job
15:52:09 <mietek> Anyone familiar with quasiquotation in Haskell?
15:53:00 <aristid> chrisdone: do you have a player already?
15:53:03 <chrisdone> yeah I just need a less heavy-duty tool that records changes on a per-line and per-column basis without the heavy dutiness of commits
15:53:08 <chrisdone> aristid: no I need to write one
15:53:37 <aristid> chrisdone: heavy-dutiness? does it matter if it's a couple of megabytes?
15:54:40 <chrisdone> it's 117mb
15:55:09 <chrisdone> it was starting to make my hard drive churn and I didn't like that so I left it
15:55:35 <aristid> churn?
15:55:37 <p_l> chrisdone: I suspect you could usea log structure and then commits with bigger granularity.
15:55:50 <aristid> chrisdone: means you've stopped creating the emacscast?
15:56:04 <sshc> How do I convert a lazy bytestring to a strict bytestring?
15:56:04 <chrisdone> I could've written a bit of elisp to record it in chunks or just in a custom format but at the time I was more interested in getting the project done than doing the recording efficiently
15:56:14 <p_l> cause git is really inefficient when the changes are very small
15:56:21 <chrisdone> aristid: yeah, I stopped once I'd got the basic fastcgi process. the rest is HTML/CSS/Javascript coding
15:56:29 <p_l> (like one character etc.)
15:56:31 <chrisdone> p_l: indeed
15:56:52 <p_l> chrisdone: well, anything other than log will be.
15:57:11 <chrisdone> :t toChunks
15:57:12 <lambdabot> Not in scope: `toChunks'
15:57:21 <chrisdone> :t Data.ByteString.Lazy.toChunks
15:57:22 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
15:57:56 <Guest87300> I'm trying to use Haskell Platform's (v2010.2.0.0) fastcgi (v3001.0.2.3) on cygwin 6.1 but when I compile my program (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29697), I get linker errors (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29698).
15:58:37 <chrisdone> Guest87300: what are all the versions of all your softwares?
15:59:21 <chrisdone> p_l: I did ask around in #emacs and StackOverflow for a bit for a couple days before but got nothing
15:59:42 <Guest87300> Windows 7 x64, FastCGI dev kit 2.4.0. 
16:00:12 <chrisdone> oh, windows. hmm
16:00:46 <Zao> Try msys+mingw maybe, as that's what GHC's built with?
16:01:05 <Guest87300> Zao: I'll give that a shot.
16:01:40 <ezyang> Guest87300: I recommend running GHC from outside cygwin 
16:01:49 <ezyang> there are several known bugs, one of which I'm trying to fix right now ;-) 
16:02:38 <Guest87300> ezyang:  Thanks!
16:09:40 <chrisdone> hlint assumes even qualified names A.id is Prelude.id. annoying
16:09:50 <chrisdone> /home/chris/Projects/me/amelie/src/Main.hs:334:38: Error: Redundant id
16:09:50 <chrisdone> Found:
16:09:50 <chrisdone>   A.id "created"
16:09:50 <chrisdone> Why not:
16:09:53 <chrisdone>   "created"
16:10:07 * chrisdone disables that message
16:16:18 <c_wraith> chrisdone, didn't you complain about that yesterday?
16:28:56 * sm finds this monadic trace surprisingly handy: http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=commitdiff;h=20100903232059-3c3f9-2835de0a60ee552e6cd146e046a4b7ae512169a8.gz
16:28:57 <chrisdone> maybe. I did something about it today
16:33:51 <aruns> probably a vague question - but simply what causes the large sizes of compiled haskell programs?
16:34:20 <Zao> aruns: Runtime, mostly.
16:35:03 <aruns> i thought ghc compiles to native machine code ?
16:35:41 <p_l> aruns: doesn't mean the runtime isn't complex
16:35:59 <p_l> or doesn't have big memory usage due to various reasons
16:36:00 <fxr> aruns: you can compile dynamic executables
16:36:30 <p_l> and yes, GHC usually compiles haskell modules statically
16:37:37 <aruns> i guess i dont understand compilers and VMs as well as i'd like. but lets say you write a simple hello world program in haskell and then in c. compile the two and the c one might be a few k, the haskell seems to run a min of a few 100 k
16:37:48 <aruns> what is in that extra 100k
16:38:16 <copumpkin> there's lots of symbols
16:38:23 <copumpkin> have you tried stripping the executables?
16:38:38 <aruns> the -fomit-xx flag ?
16:38:44 <fxr> aruns: do you mean the resident size or the executable size?
16:38:48 <Saizan> also, there's the whole RTS linked in
16:38:53 <aruns> i thought i did, even then it was big
16:38:53 <copumpkin> run the strip utility on it
16:38:57 <aruns> executable size
16:39:16 <aruns> ok i haven't come across that one. i'll have to look it up
16:39:35 <copumpkin> just run `strip x` where x is the name of your program :P
16:39:54 <fxr> aruns: try ghc --make -dynamic hello.hs && strip hello
16:40:07 <Cale> aruns: A garbage collector, lots of other stuff.
16:40:10 <fxr> it will be around 9k
16:40:54 <aruns> ahh cool. didnt know about strip. its even on my mingw system
16:41:08 <aruns> thanks everyone
16:41:11 <Cale> You can now choose to dynamically link the runtime system into the binary if you really care about the size difference of the executable. Just be aware that it's only a constant term.
16:42:11 * Twey chuckles.
16:42:50 <monochrom> huge constant
16:42:50 <aruns> which means you will need a libghc/libhugs/libnhc what-have-you to run it?
16:42:58 <monochrom> yes
16:43:56 <aruns> and how much does haskell vary in resident memory size for a comparable program say written in c? i've read the bits about being careful about using foldl and avoiding over-thunking (if thats the right word)
16:44:52 <Twey> @remember Cale You can now choose to dynamically link the runtime system into the binary if you really care about the size difference of the executable. Just be aware that it's only a constant term.
16:44:52 <lambdabot> Nice!
16:45:11 <fxr> aruns: dont compare like that, a program written in haskell gains much by means of manageability, expressiveness and modularity
16:45:34 <aruns> i totally understand that, and thats the reason i'm learning it
16:45:50 <Cale> Twey: What's so notable about that? :)
16:45:51 <aruns> but i just want to understand what the trade offs are.
16:46:22 <monochrom> "constant" is always notable :)
16:47:26 <Saizan> aruns: hard to say, depends a lot on the code
16:47:26 <Twey> Cale: It's just very… indicative :þ
16:48:01 <Saizan> aruns: it's easy to introduce larger constant factors than you'd have in C
16:48:43 <monochrom> My long-running haskell programs stay at 3MB or 4MB
16:48:45 <Saizan> because if you don't think about the data representation much you're likely to have more indirections
16:49:05 <Twey> Cale: ‘Only a constant term’ is very #haskell, especially when the constant is that big :þ
16:49:54 <aruns> monochrom: are they GUI programs, do they deal with images?
16:50:09 <Cale> Heh, all right. I was just pointing out that if you make larger Haskell programs they're not going to grow as quickly as the Hello World example would suggest.
16:50:13 <monochrom> No. background process monitoring irc.
16:50:36 <kmc> aruns, jhc produces pretty small binaries
16:50:52 <aruns> cool thanks for the info
16:51:03 <kmc> there are many compilers for Haskell with different properties
16:53:24 <aristid> but everybody uses ghc
16:54:41 <aristid> i think SPJ's financial Observables are Applicative but not Monad, looking at the available operations
17:05:53 <chrisdone> k, I need to split amelie into separate modules now. ghc takes way too long to build it
17:06:23 <chrisdone> seven seconds to compile and link
17:11:02 <monochrom> heh
17:12:36 <chrisdone> good job refactoring in haskell is trivial
17:24:13 <chrisdone> excellent. done
17:24:28 <chrisdone> took me 11 minutes :p
17:24:51 <aristid> chrisdone: do you have techniques to automate some of it?
17:25:05 <aristid> i'm currently manually switching buffers and M-% to change stuff
17:25:53 <itsmonktastic> tbf, that depends on what refactoring needs to be done
17:26:28 <aristid> itsmonktastic: sure, but it's always good to automate the stuff that can be
17:26:29 <itsmonktastic> moving some stuff into another module is hard if you haven't set out clear separation of responsibilities in the first place
17:27:23 <itsmonktastic> sorry, I'm talking entirely about manual refactors
17:27:38 <itsmonktastic> but I don't have a large history of refactoring my usually quite small haskell programs :p
17:28:09 <itsmonktastic> I just meant the comment "good job it's trivial to refactor haskell"
17:28:55 <itsmonktastic> seemed a bit of an "all sheep are white" comment, though I do think I agree in some respect :p
17:28:59 <aristid> itsmonktastic: i have a _huge_ haskell library now: it's at 1400 lines now ;) (my largest haskell package ever)
17:29:05 <chrisdone> well the fact that everything is statically checked means that any change I make will be highlighted where it affects
17:29:36 <chrisdone> for example, if I add a new constructor to a data type, every function that pattern matches on that data type will signal a compile time warning to say that I don't handle the new case
17:30:54 <itsmonktastic> chrisdone: Um, it does?
17:30:59 <itsmonktastic> Do you need a switch for that?
17:31:07 <aristid> chrisdone: if you have, say, an instance JSON for your type, that helps with showJSON, but not with readJSON :/
17:31:12 <aristid> itsmonktastic: yes. -Wall
17:31:30 <itsmonktastic> aha, ty :p see, I don't know as much as I should ¬¬
17:33:44 <chrisdone> -Wall is really great
17:34:02 <itsmonktastic> Yeah, not sure why I've not used it before tbh
17:34:14 <aristid> chrisdone: do you use it in ghci, too?
17:36:35 <chrisdone> yep
17:36:48 <chrisdone> b
17:36:52 <chrisdone> woops
17:38:13 <aristid> chrisdone: me too, but the defaulting warnings do annoy me :)
17:40:29 <chrisdone> once I add text properties to make warnings gray it won't annoy me so much
17:41:16 <kmc> is ¬¬ a smiley of some form?
17:41:39 <kmc> expressing the emotion "i am a logical constructivist"?
17:41:45 <djahandarie> Haha
17:41:53 <djahandarie> I think it is similiar to -_- / >_>
17:41:54 <dankna> it's a stare, haha
17:41:58 <itsmonktastic> it's a shifty eyes
17:42:16 <djahandarie> ┐(´ー｀)┌
17:42:17 <itsmonktastic> without a outh
17:42:19 <itsmonktastic> mouth*
17:42:21 <itsmonktastic> urgh :p
17:45:39 <aristid> chrisdone: mmh maybe if warnings are collapsible and you can make them collapsed by default..
17:45:53 <sm> why does runParser (many digit >> fail "") () "" "2" add "unexpected end of input\nexpecting digit" to the parse error ?
17:46:01 <aristid> do you have a special emacs buffer for ghci? i run it in the terminal so far
17:46:16 <sm> without the many, it doesn't
17:47:12 <kmc> sm, reporting what was expected is a Parsec feature
17:47:28 <kmc> do you think the message is incorrect?
17:47:57 <sm> kmc: I do.. it got what was expected. I want it to fail silently here
17:48:32 <sm> "many digit" itself can never fail
17:48:41 <megajosh2> I need to start using GHCi in vim
17:50:45 <sm> parsec is adding junk to my parse errors >:/
17:52:05 <aristid> sm: maybe you want <?> or so?
17:52:13 * hackagebot GotoT-transformers 1.0 - A monad and monadic transformer providing "goto" functionality  http://hackage.haskell.org/package/GotoT-transformers-1.0 (GregoryCrosswhite)
17:52:20 <sm> like <?> "" ? I have tried that a bit
17:53:22 <sm> here's an example in practice: http://gist.github.com/564783
17:58:22 <lispy> sm: can I see the code of the parser that generated the error?
17:59:17 <sm> sure, http://gist.github.com/564789
17:59:42 <sm> the example above is a minimal case
18:00:00 <sm> the one-liner I gave earlier, I mean
18:00:15 <lispy> sm: what is datesepchar?
18:00:38 <sm> datesepchars = "/-."
18:00:39 <sm> datesepchar = oneOf datesepchars
18:01:47 <lispy> sm: fascinating
18:01:57 <lispy> sm: So how did parsec think you wanted " "
18:02:09 <lispy> or rather, how did it find that in the input
18:02:36 <sm> that's the next thing after the bad date
18:02:46 <djahandarie> You know, haddock should make it clear when certain instances are derived
18:02:47 <lispy> sm: does the error reported change when you introduce try on the (sub)parsers that are failing?
18:02:58 <sm> no.. choice' does try on each option
18:03:36 <lispy> sm: oh, I think I see the problem
18:03:38 <sm> also it still thinks I wanted another digit if I change to [datesepchar, digit]
18:04:19 <deech> Hi all, I was looking at the List package and wondering why it exists (as in what's wrong with the regular list) and how I would go about using it. 
18:04:29 <lispy> sm: choice' is consuming (really alternating between the options digit and datesepchar) all the input up to the " ".  That's where the cursor is at in the input.  Now, you check datestr in a pure computation and fail.
18:05:04 <lispy> sm: so parsec _thinks_  you failed at the current input token, not a previously consumed token
18:06:05 <sm> lispy, you're talking about the long example right ?
18:06:20 <lispy> sm: yes, due to when I logged in, it's the first thing on my scroll back
18:06:29 <Krimpet> I'd like to read input_event structs from /dev/input/eventX and marshal them into Haskell types. What would be the best way to go about this? I suspect I should use the C FFI, but it seems hairy when dealing with structs.
18:07:00 <lispy> sm: the problem is the way you parse datestr.
18:07:15 <rschnck> I managed to massively simplify my reverseDigits fucntion to:
18:07:17 <rschnck> --reverseDigits2 does the same as revDig, but with tail recursion and without using lists
18:07:20 <rschnck> reverseDigits2 :: Int -> Int -> Int
18:07:23 <rschnck> reverseDigits2 0 x = x
18:07:26 <rschnck> reverseDigits2 n x = reverseDigits2 (n `div` 10) (x*10 + (n `mod` 10))	
18:07:28 <rschnck> :D
18:07:38 <rschnck> Sorry about the messy c&p.
18:08:06 <lispy> rschnck: does that run into stack (or heap) overflow for large x?
18:08:13 <sm> lispy: could you explain this one, I might see it more clearly: why does runParser (many anyChar >> fail "") () "" "2" add "unexpected end of input\nexpecting digit" to the error ?
18:08:42 <ClaudiusMaximus> > maxBound :: Int
18:08:43 <lambdabot>   9223372036854775807
18:09:41 <sm> sorry, let me paste that again
18:09:46 <aristid> > maxBound :: Word64
18:09:46 <lambdabot>   18446744073709551615
18:09:47 <lispy> sm: yes I can explain that
18:09:55 <sm> why does runParser (many digit >> fail "") () "" "2" add "unexpected end of input\nexpecting digit" to the parse error ?
18:09:57 <aristid> my maxBound is bigger than your maxBound
18:10:02 <lispy> sm: what is the source of anyChar?
18:10:14 <lispy> ah okay
18:10:49 <lispy> sm: yes, so digit tells parsec that it's looking for input.  That way, when it fails parsec can say why (you probably get that part)
18:10:49 <sm> I'll take the digit example.. digit source is: satisfy isDigit       <?> "digit"
18:10:49 <rschnck> lispy: Yeah--it gets stuck
18:10:57 <rschnck> lispy: Why is that?
18:11:14 <rschnck> In fact, it responded with "killed"
18:11:33 <lispy> rschnck: because when transforming to tail cail in haskell, often your accumulator parameter ends up building a thunk that is larger in memory than the value of the accumulator
18:11:47 <lispy> rschnck: the solution then, is to evaluate the accumulator at each step
18:12:00 <sshc> @type flip liftM get
18:12:01 <lambdabot> forall a1 r (m :: * -> *). (MonadState a1 m) => (a1 -> r) -> m r
18:12:03 <lispy> rschnck: you can do like: reverseDigits2 0 !x = x; ...
18:12:07 <sshc> What is that syntax??
18:12:16 <lispy> rschnck: or reverseDigits2 0 x = x `seq` x; ...
18:12:25 <revenantphx> ello again
18:12:28 <sshc> —minus a question mark
18:12:29 <lispy> rschnck: probably want to add that to both equations not jsut the first
18:12:37 <revenantphx> One little question,
18:12:41 <sm> with "many", it adds "unexpected end of input\nexpecting digit" to the error; without it, it does not
18:12:45 <sshc> Which extension does it require?
18:12:49 <rschnck> lispy: I understood...almost none of that. I started programming/using Haskell this week.
18:12:56 <revenantphx> what do you guys recommend in terms of installing lisp on os x?
18:13:03 <rschnck> Accumulator parameter?
18:13:06 <revenantphx> Which mplementation?
18:13:19 <lispy> rschnck: well, you preformed the tail call optimization, I assumed you were familiar with taht :)
18:13:20 <sshc> I see KindSignatures in there?
18:13:21 <dankna> sbcl.  though it's disloyal of me to say so, since I know the OpenMCL people, heh.
18:13:21 <revenantphx> It's for SICP
18:13:23 * sshc looks up
18:13:24 <lispy> rschnck: in your case, the x
18:13:37 <lispy> rschnck: but, I need to help sm for a bit :)
18:13:47 <sm> back rschnck, back! :)
18:13:57 <lispy> sm: Do you have the definition of many handy?
18:13:59 <megajosh2> @src (->) (<|>)
18:13:59 <lambdabot> Source not found. You untyped fool!
18:14:18 <lispy> sm: you know why it works without the many right?
18:14:40 <lispy> sm: because your parser (digit) is designed to look for exactly your input so you're golden
18:14:55 <sm> sure, I think I have a pretty good feel for parsec except in this case
18:15:00 <revenantphx> kmc: I'm going to take a stab at SICP, what do you recommend in terms of lisp implementation?
18:15:02 <sm> any p
18:15:03 <sm>   = do xs <- manyAccum (:) p
18:15:03 <sm>        return (reverse xs)
18:15:08 <sm> s/any/many/
18:15:14 <revenantphx> I'm on osx, if that makes any difference at all.
18:15:24 <aristid> megajosh2: there's no Alternative instance for functions?!
18:15:31 <lispy> sm: there should be a comment in the documentation near it
18:15:39 <lispy> sm: parsec version?
18:16:01 <sm> uh.. 2.1.0.1 right now
18:16:09 <sm> though I was looking at 3.0 source
18:16:42 <lispy> okay, that helps, I'll make sure and reference the right haddocks
18:16:49 <sm> http://hackage.haskell.org/packages/archive/parsec/2.1.0.1/doc/html/src/Text-ParserCombinators-Parsec-Prim.html#many
18:16:58 <lispy> rschnck: you should learn about thunks, BTW :)
18:17:16 <rschnck> lispy: I'm going to read through the O'Reilly haskell book
18:17:36 <lispy> sm: ugh, parsec 2 has no haddocks :(
18:18:10 <lispy> rschnck: a thunk is just how you represent a calculation that is "in progress" aka implementation detail to achieve laziness
18:18:12 <sm> ^^^
18:18:40 <rschnck> lispy: So one of the intermediate steps during the recursive "process"
18:18:42 <rschnck> is a thunk?
18:19:21 <lispy> rschnck: I mean, (+1) is a thunk
18:19:31 <sm> lispy: since I'm not getting this, if you see a way to suppress that part of the error I'd be most grateful!
18:19:32 <lispy> rschnck: lots of things in haskell are thunks
18:19:49 <lispy> sm: The definition of many is not making this easy
18:19:57 <rschnck> So (+1) is a thunk because it has yet to be added to whatever you're adding it to?
18:20:19 <lispy> sm: Basically, I think many is designed to complain if applied when a) the input is empty, b) many was not given a parser for end of input
18:20:27 <lispy> rschnck: yes
18:20:41 <lispy> rschnck: you can also have a thunk if you've created a computation but you don't need it yet
18:21:03 <rschnck> lispy: Right, so during some recursive function that still needs to "continue"
18:21:05 <rschnck> It has some values
18:21:06 <lispy> rschnck: let x = 5 + 1 in 2 -- I didn't use x here so it exists unevaluated
18:21:08 <rschnck> But not all of them
18:21:10 <sm> I think usually it's fine parsing the first part (or none) of the stream. But when I call fail, it looks like parsec looks at the recent parser and modifies the error
18:21:10 <rschnck> That's a thunk.
18:21:38 <lispy> rschnck: and thunks can sometimes be larger (in space) than their evaluated representation (often the case with Int)
18:21:52 <lispy> sm: yes
18:22:13 <lispy> rschnck: the trick then, is to do evaluations along the way to keep the thunk from growing too big
18:22:13 <rschnck> But in the case of x = 5+1 in 2, you have no x...so because you have no x, it remains unevaulated?
18:22:18 <syntaxglitch> er, I don't think (+1) is a thunk, as such, it's just a partially applied function
18:22:19 <rschnck> And stimply exists as "x = 5 +1"?
18:22:21 * FunctorSalad_ eats the thunk
18:22:44 <sm> well.. I'd better do some dishes.. Thanks a lot lispy
18:22:59 <lispy> sm: okay, sorry I Wasn't more helpful
18:23:13 <sm> will reread what you said with fresh brain
18:23:24 <rschnck> lispy: Right
18:23:31 <rschnck> lispy: So there's some limit to the size thunk that haskell can store
18:23:31 <lispy> syntaxglitch: how would (+1) get evaluated to a value?
18:23:41 <lispy> rschnck: definitely
18:24:03 <FunctorSalad_> according to haskell-blah something that doesn't evaluate further is a value :p
18:24:10 <rschnck> So how would I remedy that problem? 
18:24:21 <lispy> rschnck: bang patterns, seq, and pattern matching all evaluate things at least a little bit.
18:24:52 <syntaxglitch> I mean, you could have an unevaluated thunk with a value of (+1), but it's not a thunk because it's short one argument
18:25:06 <aristid> hmm, f _ x could be syntactic sugar for flip f x
18:25:13 <syntaxglitch> unless I have my terminology confused
18:26:29 <lispy> rschnck: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29700#a29700
18:26:30 <kmc> revenantphx, the course i helped teach using SICP used drscheme
18:26:49 <revenantphx> that's been converted into "racket" now. 
18:26:56 <kmc> yeah
18:27:01 <revenantphx> I'm a bit worried that might have diverged too far from scheme itself.
18:27:04 <lispy> aristid: I think I like RHS _ to be undefined
18:27:07 <kmc> don't worry
18:27:15 <kmc> DrScheme itself implemented like a dozen language variants
18:27:17 <lispy> aristid: i mean, if we're going to give it meaning
18:27:19 <kmc> i'm sure it still has R5RS Scheme
18:27:21 <revenantphx> I'm worried it'd be something like C++/C
18:27:25 <kmc> oh, no
18:27:26 <rschnck> lispy: So this bang pattern calls for immediate evaluation?
18:27:27 <kmc> god no :)
18:27:29 <revenantphx> MOST C compiles in C++... but there are subtle distinctions.
18:27:37 <kmc> oh, in that sense
18:27:38 <lispy> rschnck: oh, let me show you what it is translated to
18:27:51 <revenantphx> kmc: yeah
18:27:56 <kmc> revenantphx, can you get the successor to Dr Scheme
18:27:57 <aristid> lispy: do you propose another symbol?
18:27:59 <kmc> whatever GUI comes with Racket
18:28:05 <kmc> and then see what languages it allows you to select?
18:28:10 <revenantphx> the succesor to Dr Scheme is Dr Racket 
18:28:19 <revenantphx> from what I've seen.
18:28:22 <kmc> ok
18:28:31 <revenantphx> It has "backwards support" for DrScheme (PLTScheme)
18:28:36 <revenantphx> I think.
18:28:55 <kmc> doesn't it still have R5RS?
18:29:01 <revenantphx> R5RS?
18:29:04 <kmc> that's a version of the Scheme standard
18:29:08 <revenantphx> the thing is, since it has a different name ,it doesnt HAVE to stick to the spec for the langauge I suppose.
18:29:12 <revenantphx> That's what I'm worried about.
18:29:19 <kmc> just get it and look at the languages list
18:29:22 <revenantphx> mmk
18:29:25 <lispy> grrr. hpaste is broken
18:29:27 <revenantphx> I'm opening it now.
18:30:11 <lispy> rschnck: so, foo !x !y !z = bar becomes foo x y z | x `seq` y `seq` z `seq` False = undefined | otherwise = bar
18:30:29 <lispy> rschnck: recall that foo x y z | False = ...., will always fall through to the next branch
18:30:46 <lispy> rschnck: but as a "side effect" of checking that pattern it will evaluate x, y, and z a little bit
18:30:55 <rschnck> I've never seen `seq` before, let me look that up
18:31:00 <lispy> aristid: There must be a good unicode symbol?
18:31:03 <lispy> :t seq
18:31:04 <lambdabot> forall a t. a -> t -> t
18:31:09 <kmc> the whole "racket" rebrand is funny... like they realized that Lisp/Scheme have negative associations, but that the language itself is close to some things that are popular now
18:31:12 <lispy> > 1 `seq` True
18:31:13 <lambdabot>   True
18:31:20 <lispy> > [1..] `seq` True
18:31:21 <lambdabot>   True
18:31:30 <avenge> > undefined `seq` True
18:31:31 <lambdabot>   *Exception: Prelude.undefined
18:31:32 <aristid> lispy: ugh, unicode symbols are not keyboard friendly
18:31:43 <djahandarie> aristid, not if you have the right sort of keyboard ;)
18:31:55 <djahandarie> Ｏｒ　ａｎ　ＩＭＥ　；）
18:31:56 <lispy> aristid: editor support :)
18:32:09 <revenantphx> kmc: Odd, it's not listed in the documentation or README...
18:32:13 <revenantphx> but DrScheme is packed in here.
18:32:15 <revenantphx> 0.o
18:32:22 <avenge> lispy: [1..] is just 1:(something else), so seq only needs to evaluate the outer : constructor.
18:32:28 <lispy> avenge: right
18:32:35 <revenantphx> oh wait, its just a shortcut
18:32:42 <revenantphx> or an alias of some sort.
18:32:44 <lispy> rschnck: So, the thing about seq is that it only evaluates a little bit
18:32:45 <rschnck> lispy: So it evaluates its first argument, returns the second?
18:33:00 <revenantphx> kmc: It has "R5RS" listed.
18:33:03 <revenantphx> Should I just use that?
18:33:03 <lispy> rschnck: yes, but the "evaluates" bit might not be what you expect
18:33:05 <kmc> yes
18:33:05 <rschnck> so x `seq` therestofmyfunction is just evaluating x for as far as it's currently defined
18:33:12 <revenantphx> kmc: okay great, thanks
18:33:12 <lispy> rschnck: like my example above with [1..] `seq` True
18:33:16 <rschnck> That's brilliant: D
18:33:30 <revenantphx> kmc: I'm getting some books on set theory and discrete math from my cs teacher, who has a math major.
18:33:35 <revenantphx> He said I can have some of his old college books.
18:33:41 <kmc> nice!
18:33:43 <lispy> rschnck: seq [1..] just evaluates enough to see _:_, and then stops
18:33:44 <aristid> lispy: or just use _ :P
18:33:54 <aristid> we have undefined for bottom already
18:34:14 <revenantphx> kmc: It seems like there are a LOT of lisp implementations/variants?
18:34:26 <djahandarie> Having a math major in addition to a CS major seems to usually mark someone who knows what they're doing
18:34:43 <revenantphx> djahandarie: he only has a CS minor at best if I recall.
18:34:49 <revenantphx> He's much more of a math guy.
18:35:05 <revenantphx> He also teaches physics.
18:35:50 <revenantphx> His programming background is in SML mostly though
18:36:00 <revenantphx> And he has to teach Java
18:36:02 <djahandarie> The useful-to-CS math fields usually aren't done until late undergrad or in grad
18:36:03 <syntaxglitch> if you need deeper evaluation, just use "seq seq seq" instead, repeating it will tell the compiler that you really mean it
18:36:05 <revenantphx> Sad, I'd be happier learning SML
18:36:18 <revenantphx> syntaxglitch: seriously?
18:36:22 <syntaxglitch> no :)
18:36:24 <revenantphx> lol.
18:36:49 <lispy> rschnck: so, the moral of the story is: transforming the function to take advantage of tail recursion needs to consider the possibility that the accumulator parameter may grow to large if you don't add a bit of evaluation in the recursive call to keep it small (now if the accumulator value is larger than the unevaluated representation, then best to not evaluate it as you go)
18:36:51 <djahandarie> I really hate when I need to liter non-denotational functions all over my code
18:37:07 <revenantphx> new syntax in 2011 HP: "GODDAMIT monad to express REALLY F'ING IMPORTANT values"
18:37:24 <revenantphx> new stuff*
18:37:32 <avenge> > (undefined:undefined) `seq` True
18:37:33 <lambdabot>   True
18:37:33 <ManateeLazyCat> Have any *exist* library for line edit? I want function "deleteBackwardWord :: String -> String", (deleteBackwardWord "/home/andy") ==> "/home/", the word i mean match '\b' in regular expression.
18:37:34 <lispy> rschnck: Bottom line, optimizing for tail recursion in Haskell is not always a good idea :)
18:37:51 <ManateeLazyCat> Just ask to avoid duplicate work.
18:38:06 <lispy> ManateeLazyCat: haskeline?
18:38:49 <syntaxglitch> revenantphx, nothing yet beats having "PLEASE DON'T GIVE UP" as a valid and useful line of code
18:38:58 <revenantphx> syntaxglitch: where?
18:39:04 <syntaxglitch> for whatever definition of "useful" can be applied to INTERCAL I suppose
18:39:08 <revenantphx> also, have you seen my C macro for an infinite loop?
18:39:23 <revenantphx> #define loop while(1>>0 && 0xC0DEDBAD)
18:39:28 <syntaxglitch> heh
18:39:36 <FunctorSalad_> revenantphx: HP=haskell'?
18:39:51 <ManateeLazyCat> lispy: haskeline haven't function i want, I want some function can search forward/backward regexp in string. 
18:39:52 <revenantphx> FunctorSalad_: Sure, I meant the release in the haskell platform.
18:39:57 <FunctorSalad_> we need a 'whatever' monad too then
18:40:26 <ManateeLazyCat> lispy: then i can implement delete forward/backward with any regexp.
18:40:35 <FunctorSalad_> 'this value may or may not be evaluated even when needed, and I don' really give a damn anyway'
18:41:03 <revenantphx> FunctorSalad_: an Apathy monad you mean.
18:41:25 <FunctorSalad_> 'whatever' is an uttering expressing apathy no?
18:41:29 <revenantphx> sure
18:41:32 <ManateeLazyCat> lispy: Perhaps haven't those functions, i miss Emacs' regexp search/replace function.
18:41:36 <revenantphx> also, a RandomlyRandom monad. It's either your number or a random number.
18:41:40 <revenantphx> but which one it is is random.
18:41:43 <revenantphx> XD
18:42:38 <rschnck> lispy: Why is this happening? http://paste.ubuntu.com/488080/
18:42:44 <lispy> ManateeLazyCat: haskeline is a readline/editline replacement.  It might not be obvious, but it does have that functionality.
18:42:44 <rschnck> lispy: Oh shoot, nevermind
18:43:26 <lispy> rschnck: change to Integer, right?
18:43:37 <rschnck> lispy: http://paste.ubuntu.com/488081/ there, it's corrected. Same result
18:43:46 <ManateeLazyCat> lispy: Ah? I will read it's source code, thanks! :)
18:43:47 <rschnck> What do you mean?
18:43:50 <revenantphx> syntaxglitch: I'm just waiting for programming languages for those lyric processors.
18:43:53 <lispy> > 1235555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555321 :: Int
18:43:54 <lambdabot>   4099276460824344569
18:43:55 <revenantphx> That wil be interesting.
18:44:06 <lispy> > 1235555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555321 :: Integer
18:44:07 <lambdabot>   123555555555555555555555555555555555555555555555555555555555555555555555555...
18:44:12 <lispy> rschnck: make sense?
18:44:23 <rschnck> lispy: None
18:44:24 <aristid> > 1235555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555321 `mod` toInteger (maxBound :: Int)
18:44:25 <lambdabot>   2795366422668646435
18:44:30 <revenantphx> analog encoded (0-255) probability based processing.
18:44:48 <lispy> rschnck: Int is bounded.  Typically either 32 or 64 bits.  But, Integer is arbitrary is size
18:44:50 <revenantphx> They're based on Bayesian probability rather than Boolean logic.
18:44:54 <rschnck> lispy: Oh o.O
18:45:06 <aristid> > 1235555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555321 `mod` (1 + toInteger (maxBound :: Int))
18:45:06 <lambdabot>   4099276460824344569
18:46:33 <sshc> Is there a convensional meaning of adding a ' to a function name in a library?
18:46:54 <copumpkin> "a related function that differs somehow"
18:46:55 <sshc> If "foo" already exists, what will somebody typically assume about "foo'"?
18:46:57 <copumpkin> :P
18:47:13 <sshc> That's what I thought, but I hope it didn't indicate anything about strictness
18:47:22 <aristid> > 1235555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555321 `mod` 2^63
18:47:23 <lambdabot>   4099276460824344569
18:47:26 * hackagebot AbortT-transformers 1.0 - A monad and monadic transformer providing "abort" functionality  http://hackage.haskell.org/package/AbortT-transformers-1.0 (GregoryCrosswhite)
18:47:45 <copumpkin> man, there are a lot of 5s in here
18:51:04 <avenge> I'm totally stumped.  I'm doing something to cause hSetBinaryMode to hang forever, and have now idea what it is.
18:51:05 <FunctorSalad_> anyone else feel like they're actually using fewer monads these days? :o
18:51:51 <avenge> I'm using more monads!
18:51:58 <rschnck> What do you call the rDig :: Int -> Int portion of a function?
18:52:05 <FunctorSalad_> especially for Reader the sequencing it imposes (on the intensional form of your code, not its semantics after expanding everything, before people jump at me :p) is annoying
18:52:28 <FunctorSalad_> I just use lexical scope now sometimes ;)
18:53:16 <avenge> As a substitute for Reader that's fine.  But I find myself using the IO monad a lot.
18:53:32 <avenge> (And no, unsafePerformIO is not a good substitute...)
18:53:36 <FunctorSalad_> yeah, IO is pretty much unavoidable unless you want to resort to ghc primops ;)
18:53:56 <lispy> rschnck: I call the rDig the actual function and I call your reverseDigits2 the "worker"
18:54:21 <FunctorSalad_> (actually I don't know whehter the rock bottom of functions like readFile explicitly passes the RealWorld token or is IO too)
18:54:24 <lispy> rschnck: I would actually write it so that reverseDigits2 is in a "where" clause hanging off of rDig so that no one can call it directly
18:54:40 <rschnck> lispy: well the :: Type -> Type section, what would you call that?
18:55:44 <avenge> FunctorSalad_: My guess would be uses unsafeInterleaveIO at the lowest level, and only through that function passes realWorld.
18:56:07 <lispy> rschnck: type signature
18:56:32 <rschnck> lispy: Ah, okay
18:56:34 <rschnck> Thanks.
18:56:53 <FunctorSalad_> avenge: for the 'lazy' part of 'lazy IO' you mean, I guess? I just meant the part that actually reads from the disk
18:57:03 <FunctorSalad_> which may be an ffi decl?
18:57:22 <kmc> rschnck, btw, writing types is usually optional in Haskell
18:57:51 <kmc> rschnck, writing a type for each thing you define at the "top level" of your file is good style and can help you find errors
18:58:00 <avenge> FunctorSalad_: Yes, has to be FFI.
18:58:17 <kmc> "top level" is by contrast with a let/while block, in which it's less common to write type signatures, though you still can
19:02:23 <chrisdone> you mean let/where
19:02:32 <chrisdone> you C++ scum
19:03:08 <FunctorSalad_> ^^
19:03:12 <FunctorSalad_> @ty while
19:03:13 <lambdabot> Not in scope: `while'
19:03:55 <FunctorSalad_> I thought it existed
19:04:13 <FunctorSalad_> @ty until
19:04:14 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
19:05:33 <chrisdone> until . not
19:07:23 <chrisdone> http://hpaste.org/
19:07:27 <chrisdone> again
19:07:43 <FunctorSalad_> it is happening.. again :o
19:07:51 * chrisdone waiting for bos to update the domain
19:09:07 <chrisdone> http://github.com/chrisdone/amelie/commit/096ebaf86befde70d27bca0324642b54a510b35a
19:09:16 <chrisdone> refactorization
19:09:18 <chrisdone> mmm
19:09:19 <kmc> err yes where ;)
19:12:41 <lispy> chrisdone: how is that takusen example going?
19:15:29 <chrisdone> lispy: which takusen example?
19:17:43 <lispy> chrisdone: your hpaste clone
19:18:07 <lispy> chrisdone: you are going to blog about your experience with takusen or announce or code or similar right?
19:18:27 <chrisdone> sure
19:19:11 <chrisdone> the server is here http://paste.tryhaskell.org/
19:20:07 <chrisdone> it's 560~ lines of haskell, 3x less than hpaste2
19:20:21 <chrisdone> I finished the emacs/git cast thingie, I stopped before I started writing html/css/desihn stuff
19:21:05 <chrisdone> I'll probably start on a gitcast web page tomorrow and a blog. I've had no takusen probs yet. although I will do some profiling so that might be fun
19:21:38 <lispy> chrisdone: cool.  Well, your experience (positive and negative feedback) is most welcome
19:21:57 <lispy> chrisdone: I'd like to get takusen to the point where it's the obvious choice for database stuff in Haskell
19:22:02 <lispy> but that's going to take some time and work
19:22:40 <chrisdone> sounds good to me!
19:23:30 <chrisdone> I switched over to it at work
19:24:52 <chrisdone> lispy: I did have a wee bit of trouble with dates with time zones and postgresql, but I think that's more to do with the derived Data.Data/Read instace
19:25:34 <lispy> chrisdone: interesting.  Do you have notes about it on your blog or anything?
19:25:47 <lispy> chrisdone: one weak spot in the Haskell libraries is the whole date/time stuff
19:25:53 <chrisdone> no I guess I should do that
19:26:09 <lispy> there is a haskell_proposal subreddit where date/time library is requested :)
19:27:28 <aristid> lispy: i found time to be quite nice actually
19:27:30 <chrisdone> basically the default read instance couldn't read postgres's (valid ISO) timestamp, possibly too strict. whether it's the data.time library's fault or the postgresql driver's is debatable
19:28:04 <chrisdone> amelie=> select now();
19:28:04 <chrisdone>               now              
19:28:04 <chrisdone> -------------------------------
19:28:04 <chrisdone>  2010-09-04 04:27:32.042681+02
19:28:08 <chrisdone> you get this in postgresql
19:28:21 <aristid> timezones aren't really done right, but there's timezone-series and timezone-olson from yitz for that
19:28:30 <chrisdone> but data/time wants something more like 2010-09-04 04:27:32.042681 CEST+0002
19:28:32 <chrisdone> or whatnot
19:29:46 <chrisdone> I don't see a fault with the time libraries themselves, they make sense and work as expected. not sure what the complaints are about unless I'm missing something
19:29:58 <aristid> chrisdone: data/time has a full customizable time parser
19:30:14 <chrisdone> and?
19:30:39 <aristid> chrisdone: i don't really know what you do, but maybe you can avoid using Read.
19:31:38 <lispy> chrisdone: Brent Yorgey asked on Haskell-Cafe if any projects could use student contributions for a class he's teaching.  I mentioned your idea about having a type safe query builder for takusen
19:31:47 <chrisdone> I can. the point of Takusen is the marshalling from database to your haskell values is automatic. fiddling about with the reader defeats the purpose
19:32:11 <chrisdone> lispy: awesome! any response?
19:32:24 * chrisdone checks his haskell-cafe archives
19:32:25 <lispy> chrisdone: hehe, no but the course hasn't started yet
19:33:14 <aristid> chrisdone: then "automatically" use a format that better suits your needs..
19:33:16 <chrisdone> it would be really nice to see some combination of what haskelldb has done and typeable/data.data -- best of both worlds
19:37:02 <chrisdone> is gregory crosswhite a clever troll or just funny?
19:37:21 <lispy> I don't recall thinking of him as a troll
19:37:44 <chrisdone> People want to believe that Haskell is a better language than C, but how could this possibly be true when Haskell lacks the very basic "goto" feature???  If the world is going to take Haskell seriously, then this serious blight needs to be addressed immediately!  Thus I proud to present to you the "GotoT-transformers" package which provides this missing functionality and so finally makes Haskell a serious contender with C.
19:37:56 <chrisdone> eh I'm probably imagining it
19:38:23 <tommd> I thought Haskell became a serious contender with C once the FFI Addendum was approved.
19:39:08 <lispy> chrisdone: ah, GotoT is tongue-in-cheek, IMO
19:40:25 <tommd> lispy... now there's someone we know is trolling the Haskell community. I mean - look at his affiliations.
19:41:19 <lispy> tommd: I heard Haskell can write kernel modules, how do you implement USB without malloc??
19:49:25 <tommd> Who said anything about not having malloc?  malloc is quite prominent in the RTS under the rts/sm directory.
19:49:28 <lispy> chrisdone: have you seen this? http://www-db.informatik.uni-tuebingen.de/research/ferry
19:50:07 <lispy> tommd: But haskell doesn't have ternary operator.  How can you implement high performance code?
19:50:57 <lispy> tommd: i heard you need duff's device for game engines.  no duff's device on hackage.  Haskell can't write game engines :(
19:51:08 * lispy stops trolling
19:51:43 <FunctorSalad_> lispy: if/then/else *cotroll*
19:52:10 <copumpkin> that's not equivalent
19:52:20 <FunctorSalad_> why :-(
19:52:34 <copumpkin> if we had fall-through case statements ("or patterns"?) we could simulate it
19:52:42 <copumpkin> *expressions
19:52:47 <lispy> copumpkin: or use GotoT
19:52:52 <FunctorSalad_> copumpkin: I meant i/t/e is the ternary operator
19:53:03 <copumpkin> oh I was talking about duff's device
19:53:06 <copumpkin> yeah :)
19:53:22 <lispy> FunctorSalad_: oh, I think that's part of a good troll.  The claim the troll is making is clearly false, so people want to say so
19:53:41 <copumpkin> trolling is a art
19:53:56 <tg_> I was just going to imagine that Duff's Device is a homer simpson prop and ignore all of you bastards
19:54:10 <FunctorSalad_> lispy: heh :) or subtly false, getting people angry at having to start a long counterargument...
19:54:18 <tommd> The most effective one I've seen convinced other people that the person arguing with the troll was the actual troll.
19:54:35 <tommd> Evil things
19:55:24 <lispy> tommd++ (for rethinking design of RandomGen)
19:56:22 <lispy> tommd: BTW, subtle hint about code snippets: http://blog.codersbase.com/2010/08/import-prelude-hiding-logimport-control.html
19:56:28 <lispy> tommd: :)
19:58:52 <copumpkin> http://scottaaronson.com/blog/?p=103 is so cute
19:59:03 * copumpkin founds #ultrafinitism
19:59:35 <FunctorSalad_> finitism is silly
19:59:56 <FunctorSalad_> why not go ahead and reject any abstractions whatsoever? :\
20:00:08 <danderson> time is an illusion, lunchtime doubly so.
20:00:22 <tommd> lispy: Thanks!
20:00:24 <FunctorSalad_> there are is no cat concept in actual physical reality! just this particular cat, and that one, and
20:02:40 <tehgeekmeister> there *has* to be a synonym for fmap (fmap f) in one of haskell's libraries
20:02:46 <tehgeekmeister> please, tell me what it is.
20:03:14 <lispy> tommd: if you use my syntax file and improve it (notice that it makes the first bracket on [Maybe b] blue) let me know :)
20:03:33 <ray> the highest number is 1
20:03:33 <tommd> will do
20:03:35 <lispy> :t \f -> fmap (fmap f)
20:03:36 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
20:03:48 <lispy> ?pl \f -> fmap (fmap f)
20:03:48 <lambdabot> fmap . fmap
20:03:51 * ray founds hyperfinitism
20:04:10 <alise> ha
20:04:15 * lispy bases a religion on the prime numbers and begins waiting for the second coming of the even prime
20:04:18 <tg_> ray: you have to have at least 2
20:04:22 <tg_> for the evens :o
20:04:27 <ray> what evens
20:04:31 <ray> oh, you mean 0
20:04:49 <alise> I hereby found infinite-finitism. No objects exi-
20:04:59 <tg_> you don't need 0 :o
20:05:05 <tg_> I don't need 0
20:05:45 <tg_> alise: giggles.
20:07:54 <FunctorSalad_> sometimes adding nonphysical stuff just makes the theory as a whole simpler...
20:12:09 <xplat> tommd: concern trolls make that 'convince people that the other guy is the troll' thing into an art form of a sort
20:12:21 <chrisdone> lispy: hey sorry I was checking haskell-cafe. thanks for thelink I'll watch it tomorrow (off to bed now)
20:14:10 <xplat> and 0 is the largest number in the divisibility order
20:14:24 <xplat> so clearly it can't exist
20:14:51 <xplat> 1 is the only number, it's just that sometimes there are a lot of them
20:15:43 <lispy> xplat: where "a lot" can be counted by a number, therefore "a lot" = 1?
20:18:51 <applicative>  Yessenin-Volpinism is being espoused on #haskell ?  What next?
20:19:23 <tehgeekmeister> related to lazy bytestrings using interleaved IO; is it not possible to make an action that opens a file, reads the contents lazily, closes the file, and then returns the contents?
20:19:30 <tehgeekmeister> or would interleaved io break this?
20:19:35 <applicative> > length [1.. 2^2000]
20:19:39 <lambdabot>   mueval-core: Time limit exceeded
20:19:42 <copumpkin> what would reading it lazily mean in that context?
20:19:47 <copumpkin> since you close the file immediately
20:20:08 <tehgeekmeister> ah, i see
20:20:17 <tehgeekmeister> i was expecting haskell to magically figure out when i was done with the file
20:20:17 <tehgeekmeister> a
20:20:23 <tehgeekmeister> nd had read all i intended to
20:20:37 <tehgeekmeister> but it can't figure that out, so it just moves on, assuming i didn't want to read any of the file
20:20:38 <tehgeekmeister> and closes it
20:20:44 <tehgeekmeister> okay.
20:20:55 <tehgeekmeister> then i will not try to do the impossible.  =P
20:22:20 <tehgeekmeister> copumpkin: oh but if i'm using strict bytestrings, that works, right?
20:22:28 <FunctorSalad_> use strict IO and hClose :p
20:22:49 <FunctorSalad_> hGetContents is eager for strict bytestrings iirc yes
20:22:59 <kmc> @remember lispy * bases a religion on the prime numbers and begins waiting for the second coming of the even prime
20:22:59 <lambdabot> Good to know.
20:23:23 <kmc> "Today, a young man on acid realized that all matter is merely energy condensed to a slow vibration – that we are all one consciousness experiencing itself subjectively. There's no such thing as death, life is only a dream, and we're the imagination of ourselves. Here's Tom with the weather."
20:23:24 <FunctorSalad_> well what about -2?
20:23:29 <FunctorSalad_> @kmc lispy
20:23:29 <lambdabot> Maybe you meant: ghc rc src
20:23:51 <FunctorSalad_> it is prime in the ring theory sense in the ring of integers :p
20:24:05 <applicative> FunctorSalad_, right lispy's religion is Int
20:24:15 <FunctorSalad_> I for one welcome our new overloard
20:24:21 <FunctorSalad_> (-2)
20:24:24 <kmc> does that mean that only 2^29 people get to be saved?
20:24:38 <kmc> it could be more, but the Scripture only mandates that much
20:25:05 <applicative> kmc, well, it keeps going and round, more and more are saved, but they're the same.  Something like that.
20:25:18 <FunctorSalad_> kmc: seriously?
20:25:25 <FunctorSalad_> > 2 ^ 29
20:25:26 <lambdabot>   536870912
20:25:35 <FunctorSalad_> > log (2 ^ 29)  / log 10
20:25:36 <lambdabot>   8.729869874255455
20:25:51 <kmc> FunctorSalad_, iirc the H98 report only requires 2^29.  in order to allow for implementation using 2 tag bits on a 32-bit machine
20:25:56 <FunctorSalad_> seems like a case of 'nobody will ever need more than 640k'
20:26:04 <FunctorSalad_> ah.
20:26:12 <FunctorSalad_> thought you meant the bible
20:26:24 <kmc> i was trying to make a funny
20:26:34 <kmc> i'm not aware of a Haskell implementation that uses the tag bits on integers
20:27:23 <lispy> kmc: JHC might
20:28:11 <kmc> i mean typically you'd want your Ints to be boxed anyway
20:28:25 <tehgeekmeister> > ','::Word8
20:28:26 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
20:28:26 <lambdabot>         against inferred type...
20:28:30 <kmc> and then you can know the thing in the Int box isn't a pointer without tagging it
20:28:32 <tehgeekmeister> boooooo
20:28:32 <sshc> With what status code should a program return when it is invoked with the "-h" flag and displays usage instead of doing anything?
20:28:42 <lispy> sshc: 0?
20:28:50 <tehgeekmeister> @hoogle Char -> Word8
20:28:50 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
20:28:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:28:50 <lambdabot> Prelude error :: [Char] -> a
20:28:52 <lispy> sshc: unless it failed to display help
20:29:31 <sshc> lispy: grep seems to return 2
20:29:39 <lispy> sshc: interesting
20:29:48 <lispy> sshc: I made up what I said, to be fair :)
20:29:53 <pantsd_home> Anyone used hsemail recently?
20:30:08 <lispy> pantsd_home: not me
20:30:24 <pantsd_home> Or is there a better library for parsing email?
20:31:20 <lispy> pantsd_home: (this based solely on my own personal philosophy) use hsemail and if it fails for you, improve it and send a copy to the maintainer :)
20:32:09 <lispy> pantsd_home: if you want it for email filtering, I would recommend you checkout autoproc, a haskell EDSL for procmail recipes
20:34:39 <FunctorSalad_> 'procmail' sounds scary
20:34:57 <FunctorSalad_> like all the ancient (?) mail commands on linux really
20:35:35 <FunctorSalad_> (fear of the unknown)
20:36:27 <lispy> FunctorSalad_: procmail recipes really are a pain in the ass.  Hence why I wrote an EDSL for correctly constructing them
20:36:36 <FunctorSalad_> :)
20:36:45 <kmc> yeah
20:37:09 <kmc> procmail is like every other UNIX tool, in that it implements an idiosyncratic domain specific language
20:37:51 <FunctorSalad_> the avoidable part being 'idiosyncratic' I suppose?
20:38:12 <FunctorSalad_> (contrast with using something clean like haskell as the background)
20:38:40 * FunctorSalad_ really doesn't like ad-hoc syntaxes...
20:39:55 <applicative> wow, we learn j. dagit's parents' email addresses from the autoproc source...
20:40:22 <applicative> he's taken 'mom' and 'dad' from the available namespace!
20:43:10 <kmc> FunctorSalad_, yeah
20:43:29 <kmc> doesn't have to be Haskell, just wondering how different UNIX had been if they'd standardized early on on one "scripting" language
20:46:55 <applicative> nobody seems to have any opaque type errors to resolve.  perhaps life is not worth living. 
20:48:28 <araujo> kmc, probably worse
20:48:36 <kmc> yeah
20:50:52 <FunctorSalad_> worse?
20:51:26 <aavogt> because that's better too... isn't it?
20:59:11 * hackagebot vector-space 0.7.2 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.7.2 (ConalElliott)
21:04:39 <juhp_> anyone tried porting vty to parallel-2?
21:06:44 <lispy> juhp_: what is parallel-2?
21:07:34 <aavogt> it's a library
21:07:44 <juhp_> lispy: sorry as in vty requires parallel < 2 :)
21:07:53 <lispy> ah
21:08:08 <lispy> sorry, I thought parallel-2 was maybe an OS or terminal type
21:08:24 <juhp_> HP has 2.2.0.1 I think
21:11:42 <Maxdamantus> Is there a prelude/standard library function something like this? \f (a,b) -> f a b
21:12:02 <aavogt> @src curry
21:12:02 <lambdabot> curry f x y = f (x, y)
21:12:07 <Maxdamantus> Ah.
21:12:11 <Maxdamantus> Thanks.
21:12:25 <tehgeekmeister> (x:[]), will this match only one element lists?
21:12:33 <aavogt> well, you actually want uncurry then
21:12:42 <Maxdamantus> Ah yes.
21:12:44 <tehgeekmeister> (and (x:y:[]) for two element lists?)
21:12:46 <aavogt> tehgeekmeister: [x] works too
21:12:56 <Maxdamantus> @src uncurry
21:12:56 <lambdabot> uncurry f p = f (fst p) (snd p)
21:12:57 <tehgeekmeister> aavogt: doh.
21:13:07 <Maxdamantus> Funny source.
21:13:18 <tehgeekmeister> actually, is there a split function for lists/bytestrings that only splits once and returns a tuple?
21:13:23 <tehgeekmeister> before i go implementing this
21:14:51 <Maxdamantus> @hoogle curry
21:14:51 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
21:14:51 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
21:14:51 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
21:16:20 <aavogt> > let uncurry f ~(x,y) = f x y in uncurry (\_ _ -> ()) undefined
21:16:21 <lambdabot>   ()
21:16:27 <aavogt> > let uncurry f (x,y) = f x y in uncurry (\_ _ -> ()) undefined
21:16:28 <lambdabot>   *Exception: Prelude.undefined
21:28:37 <xplat> @hoogle a -> String -> (String, String)
21:28:38 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
21:28:38 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
21:28:38 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
21:29:37 <tehgeekmeister> will (x:_:_) always match at least two elements?
21:29:49 <flux> yes
21:29:55 <tehgeekmeister> huh.
21:30:31 <lispy> > let foo (x:_:_) = x in foo (1 : 2 : undefined)
21:30:32 <lambdabot>   1
21:30:39 <lispy> > let foo (x:_:_) = x in foo (1 : undefined)
21:30:40 <lambdabot>   *Exception: Prelude.undefined
21:30:52 <flux> well undefined is something else :P
21:31:00 <tehgeekmeister> so this should be total, then, aside from the intended exception:
21:31:01 <tehgeekmeister> readWord xs = case B.split ',' xs of
21:31:01 <tehgeekmeister>   (x:_:_) -> (x, True)
21:31:01 <tehgeekmeister>   [x] -> (x, False)
21:31:02 <tehgeekmeister>   [] -> error "malformed wordlist, splitting by commas resulted in an empty list."
21:31:09 <flux> it's almost like the null pointer of haskell ;)
21:31:41 <flux> tehgeekmeister, you can ask the compiler to warn about non-total matches
21:31:48 <tehgeekmeister> flux: ooh how?
21:31:58 <flux> don't remember the switch, I just remember there is one :)
21:32:07 <flux> -fwarn-incomplete-patterns
21:32:32 <lispy> -Wall ftw
21:32:47 <tehgeekmeister> ah, i'm already using -Wall
21:32:51 <tehgeekmeister> so it is total, then.
21:32:58 <tehgeekmeister> apparently it's just wrong.
21:33:03 <tehgeekmeister> (my code)
21:33:07 <flux> :)
21:35:05 <lispy> :t split
21:35:06 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
21:35:11 <lispy> ?hoogle split
21:35:11 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
21:35:11 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
21:35:11 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
21:36:09 <lispy> tehgeekmeister: well, you probably want to return the remainder of the input too
21:36:40 <lispy> (x:y:xs) -> (x, True, y:xs), or something
21:36:50 <tehgeekmeister> no, i don't care about that
21:36:55 <tehgeekmeister> if there's more than two elements, that's an error
21:37:05 <tehgeekmeister> oh, i should make that explicit in my code
21:38:42 <tehgeekmeister> ah hah!  split will return an empty bytestring at the end.  that's what i was missing.
21:39:09 <lispy> [x,y] -> (x, True); [x] -> (x, False); _ -> error "you suck"
21:39:20 <Maxdamantus> O_o
21:39:26 <Maxdamantus> > let a = a in a
21:39:30 <lambdabot>   mueval-core: Time limit exceeded
21:39:37 <Maxdamantus> > let a = a in (a :: Integer)
21:39:41 <lambdabot>   mueval-core: Time limit exceeded
21:39:49 <Axman6> > let a = a in a :: ()
21:39:51 <Maxdamantus> Oh weird, on my ghci I get a stack overflow for the latter
21:39:53 <lambdabot>   mueval-core: Time limit exceeded
21:39:55 <ezyang> Given a list of command line arguments, how can I join them into a single string that is quoted properly and portable across platforms? 
21:40:04 <ezyang> i.e. works on bash and cmd.exe 
21:40:33 <Maxdamantus> > let a = a
21:40:34 <lambdabot>   not an expression: `let a = a'
21:40:40 <Maxdamantus> Meh, dw
21:41:20 <Veinor> Maxdamantus: that's because lambdabot stops evaluating due to a time limit
21:42:06 <aavogt> ezyang: System.Process isn't an option?
21:42:16 <Maxdamantus> If I do "let a = a" on one line, then "a :: Int" on the next it gets a stack overflow instantly
21:42:29 <Maxdamantus> Just trying to evaluate "a" hangs forever.
21:43:26 <ezyang> aavogt: The idea is to give a better error message. 
21:43:37 <Axman6> :t let a = const a in a
21:43:38 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
21:43:38 <lambdabot>     Probable cause: `const' is applied to too few arguments
21:43:38 <lambdabot>     In the expression: const a
21:43:43 <ezyang> You should be able to copypaste a command line trace into the appropriate shell and just run it. 
21:43:56 <Maxdamantus> Oh, it does it the second time I try to evaluate a
21:44:33 <aavogt> ezyang: does copy-paste even work with CMD.EXE?
21:45:15 <ezyang> Yes! 
21:45:20 <ezyang> You have to right-click and then select paste. 
21:47:13 <Axman6> :t let a = flip const a in a
21:47:14 <lambdabot> forall b. b -> b
21:47:52 <xplat> O_o
21:48:50 <xplat> owait, of course it is
21:48:52 <Veinor> > let a = flip const a in a 2
21:48:53 <lambdabot>   2
21:49:02 <Veinor> > fix (flip const) 7
21:49:03 <lambdabot>   7
21:49:58 <xplat> a = flip const a ignores a and returns its second (nee 1st) argument, so it is id
21:50:18 <Veinor> yeah
21:51:13 <Jonno_FTW> @src flip
21:51:13 <lambdabot> flip f x y = f y x
21:51:16 <Axman6> :t let a = flip const $! a in a
21:51:18 <lambdabot> forall b. b -> b
21:51:27 <Axman6> > let a = flip const $! a in a 2
21:51:31 <lambdabot>   mueval-core: Time limit exceeded
21:51:55 <xplat> still id, just very slow :)
21:52:28 <Axman6> and non terminating
21:53:20 <Veinor> id, more like const _|_
21:53:56 <FunctorSalad_> @let (||>) = flip (.)
21:53:57 <lambdabot>  Defined.
21:54:00 <xplat> yes, but after omega eval steps it would have finished unfolding itself and returned its argument
21:54:04 <FunctorSalad_> hey look, an operator that isn't taken
21:54:48 <xplat> some nonterminating functions are even more nonterminating than that
21:55:37 <FunctorSalad_> > ((log***log) ||> uncurry (+) ||> exp) (2,3)
21:55:39 <lambdabot>   6.0
21:56:15 <xplat> all the REALLY fun ones are even LESS nonterminating
21:57:44 <xplat> they go up to some number that is either omega or finite, depending whether some axiom set for arithmetic is consistent or not
21:58:00 <xplat> and then do something else
22:05:25 <tehgeekmeister> how can i get the decimal value of a word8 so i can substract from it and turn it back into a word8, in order to implement toLower for iso 8859-1?
22:05:45 <avenge> fromIntegral
22:05:49 <avenge> What do you mean by decimal?
22:06:23 <lispy> tehgeekmeister: do you mean, interpret the Word8 as a Char then take the ascii reperesentation's decimal value?
22:06:44 <tehgeekmeister> oops, it's more complicated than i thought.  i should really just switch to using Text.
22:06:45 <lispy> ?hoogle Word8 -> Char
22:06:45 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
22:06:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:06:45 <lambdabot> Prelude show :: Show a => a -> String
22:07:21 <tehgeekmeister> because at the point in my code i need to downcase, i've already converted to utf8
22:07:29 <tehgeekmeister> where it's not simple subtraction anymore
22:07:39 <avenge> Why don't you just use Data.Char?
22:07:45 <avenge> Shouldn't that handle unicode?
22:08:00 <avenge> ?hoogle toLower
22:08:00 <lambdabot> Data.Char toLower :: Char -> Char
22:08:44 <tehgeekmeister> avenge: not sure it could, a char is a single byte, isn't it?  sometimes when you downcase/upcase you go from a one byte to a multibyte character.
22:09:00 <tehgeekmeister> (least that's what the data.text docs said.)
22:09:00 <avenge> No, in Haskell a Char is a unicode code point.
22:09:05 <tehgeekmeister> oh, cool
22:09:22 <avenge> But it's kind of messed up, because for example there's no way to pack a ByteString from a full unicode String.
22:09:32 <tehgeekmeister> well then the question is why that was messing up my code, because that's what i started with.
22:09:45 <tehgeekmeister> oh, but i am using bytestring.char8
22:09:50 <tehgeekmeister> not utf8
22:10:16 <avenge> If you are using ByteString.Char8, then you have latin1, not Unicode.
22:11:17 <tehgeekmeister> well, i convert to utf8 and immediately shove the data into a char8 bytestring
22:11:18 <tehgeekmeister> =P
22:11:32 <tehgeekmeister> so i have unicode.  just mangled unicode.
22:11:47 <tehgeekmeister> i think i will deal with this tomorrow.
22:12:28 <avenge> This is where Haskell's internationalization support stops making sense to me.  If you don't hSetBinaryMode h True on all your file handles, you get weird input errors on binary data, meaning it is expecting UTF8.
22:12:53 <avenge> But what you end up doing is working with some mapping of UTF8 into latin1.
22:13:21 <avenge> Where you have the Unicode code points corresponding to the latin1 characters that if you were to interpret as UTF8 would give you your string.
22:13:25 <avenge> Makes my head hurt.
22:18:02 <Cale> avenge: What do you mean regarding the mapping of UTF8 into latin1?
22:18:59 <Cale> avenge: If you use Data.Text or just the plain Prelude String type, you keep everything in unicode.
22:19:02 <avenge> Maybe I don't understand what's going on, but when I use, say S.head to look at a character in a ByteString, what I get back is a Char (meaning a Unicode Code point).
22:19:27 <avenge> Cale:  Yes, agree that Strings are Unicode.
22:19:54 <avenge> Cale:  But I don't think those are realistic for programs that do a lot of IO.
22:19:59 <juhp_> (nm vty.darcs is already parallel >= 2.2 btw)
22:20:00 <Cale> Data.ByteString.Char8 doesn't really do any encoding, it does the obvious stupid thing.
22:20:10 <Cale> If you want proper encoding, use Data.Text
22:20:25 <Cale> http://hackage.haskell.org/package/text
22:20:49 <avenge> Right.  I wish that instead of having a separate module for ByteString.Char8, they just had two functions, like packByte and packLatin1 or something.
22:21:28 <avenge> What happens when, for example, I use -XOverloadedStrings with ByteStrings?
22:21:40 <avenge> Does it actually convert my strings properly?
22:21:52 <Cale> The Char8 module is mostly just for convenience in applications where you don't care about i18n.
22:22:12 <avenge> But why is it a separate module?
22:22:39 <avenge> ByteString.pack and ByteString.Char8.pack are doing different things, so they should have different names.
22:23:06 <avenge> Incidentally, using Data.Text, how do you create bytestrings from Unicode?
22:23:33 <Cale> instance IsString ByteString where
22:23:33 <Cale>     fromString = pack
22:23:41 <Cale> ^^ from Data.ByteString.Char8
22:24:14 <avenge> Exactly, meaning ByteStrings are not Strings.
22:24:21 <Cale> http://hackage.haskell.org/packages/archive/text/0.8.0.0/doc/html/Data-Text-Encoding.html
22:25:14 <avenge> Ah, looks like encodeUtf8 is the function I want.
22:26:40 <avenge> ?hoogle encodeUtf8
22:26:40 <lambdabot> No results found
22:26:58 <avenge> ?hoogle String -> ByteString
22:26:58 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
22:26:58 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
22:26:59 <lambdabot> Prelude read :: Read a => String -> a
22:34:01 <Maxdamantus> Hmm.. so what's generally bad is the recursive use of ++, right?
22:34:51 <Maxdamantus> Simply concatting two arbritrary length lists will be fine
22:35:22 <copumpkin> assuming you don't mind linear time in the length of the first argument, sure
22:35:33 <kmc> asymptotics are misleading here
22:35:42 <kmc> due to laziness
22:36:00 <kmc> the thing that's linear time is observing every element of (a ++ b)
22:36:10 <Cale> Maxdamantus: Using (++) recursively where you're adding things to the *end* is bad
22:36:28 <Cale> Maxdamantus: Adding small lists of elements to the beginning of a list is fine.
22:36:30 <avenge> Just make sure the first argument to (++) is a relatively short list.
22:36:36 <Cale> yeah
22:36:42 <kmc> and of course observing every element takes linear time
22:36:42 <avenge> For instance, use foldr, not foldl.
22:36:53 <Cale> xs ++ ys, if fully evaluated, takes O(length xs) steps
22:37:24 <kmc> Cale, walking the spine of that list takes O(length xs + length ys) steps
22:37:33 <Maxdamantus> fmap foo a ++ fmap bar b
22:37:35 <kmc> the list is in normal form once you've finished traversing xs, but you can't tell
22:37:35 * copumpkin was going to make a dumb joke there
22:37:38 <Maxdamantus> er, map, rather
22:37:54 <kmc> i think the better way to put it
22:38:08 <kmc> is that left-associated (++) takes *per-element* time O(number of ++)
22:38:14 <kmc> and right-associated doesn't
22:38:17 <Cale> Well, I'm counting the steps to reduce applications of (++)
22:38:25 <Maxdamantus> (Where that should only ever be done once in the program, but the lists a and b may be very large)
22:38:35 <kmc> because on the left, you have to apply through all these nested ++
22:38:51 <kmc> but on the right, once you've finished traversing a in (a ++ (b ++ c)), it can entirely forget about the first ++
22:39:40 <avenge> Sometimes you want to build up a list from the left.  To avoid taking quadratic time, you can build a linked list of thunks.  The dlist package does this (as well as ShowS).
22:42:05 <Cale> I just think of it as replacing lists [a] with functions [a] -> [a], the empty list with the identity function, singleton lists [x] with (x:) and concatenation with composition.
22:42:57 <Cale> So instead of lists, you're working with functions that add elements to the beginning of any list. Composition is of course constant time, since it only takes one step.
22:44:16 <avenge> I guess that's another way of thinking about it.  I kind of think of it as wanting to build up the list backwards and then reverse it.  So you have thunks pointing to thunks in the opposite direction of the list, and then you apply them all at the end to get things going in the right direction.
22:45:27 <djahandarie> Someone should make one of those nifty diagrams showing what happens with foldr ++ vs foldl ++
22:46:18 <Cale> I rarely think at the level of thunks. One can get by just thinking in terms of expressions being reduced.
22:46:19 <avenge> There used to be some web page like foldr.com or foldl.com or something.  But those don't seem to work any more
22:46:42 <pantsd_home> is there an easy way to make parsec work with ByteStrings?
22:47:01 <Cale> (or in a pinch, expression graphs, rather than expression trees)
22:47:22 <Cale> pantsd_home: It does work with ByteStrings, the recent versions of it anyway.
22:47:47 <Cale> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-ByteString.html
22:50:18 <Maxdamantus> !src (:)
22:50:27 <Maxdamantus> @src (:)
22:50:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:50:57 <Cale> Maxdamantus: (:) is built in syntax, but if it weren't, it would be part of the data declaration that defines the list type
22:51:16 <Cale> Maxdamantus: data [a] = [] | a:[a]
22:51:29 <Cale> (except that's not valid syntax)
22:51:31 <Maxdamantus> Right.
22:52:46 <kmc> it is valid syntax in GHC if you set -package ghc-prim
22:53:08 <kmc> but don't tell anyone i told you that ;)
22:53:39 <copumpkin> omg, time for a length-index GADT with built-in syntax
22:53:48 <copumpkin> *reserved
22:55:34 <FunctorSalad_> you mean type-level integer literalz?
22:55:43 <copumpkin> just vector literals
22:55:57 <copumpkin> but I can't get it to accept it
22:56:20 <FunctorSalad_> huh? you mean by talking to it, without a ghc patch or anything? :p
22:56:58 <FunctorSalad_> or are you coding said patch
22:57:15 <copumpkin> no, was just trying to write what kmc said
22:57:20 <copumpkin> but it isn't working :(
22:59:14 <blackdog> has anyone had any luck getting ghc installed on a mac with shared libraries?
23:08:45 <pantsd_home> Cale: is there an example somewhere where someone uses it with a regular bytestring rather than from a file?
23:21:40 <Cale> pantsd_home: The following type is a bit of a mouthful perhaps, but the main thing is that ByteString is a valid type for s to be:
23:21:43 <Cale> parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
23:22:22 <Cale> There's also  parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
23:24:06 <Cale> The token type, if you import Text.Parsec.ByteString is simply Char, so you can use any character parser that you'd use on a String
23:24:18 <Cale> (essentially)
23:25:00 <Cale> So, the code should be the same, only you put a ByteString in at the top instead of a String
23:25:31 <pantsd_home> shineys
23:28:06 <pantsd_home> So if I have an old parsec-2 parser that imported the parser type from Text.ParserCombinators.Parsec , would I need to replace it with Text.Parsec.ByteString or could I use Text.Parsec.String ?
23:29:18 <Cale> You'd import whichever one you were using, or import Text.Parsec and get all the instances
23:39:07 <cpfr> hey where can i get a css file to style what pandoc outputs?
