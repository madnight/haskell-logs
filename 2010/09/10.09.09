00:00:03 <carter> or  prove that the HL code == some short sequence of LLVM instructions or something
00:00:42 <carter> i look forward to the day that proof automations make that a sane exercise 
00:01:05 <carter> that is worth while outside of the most dire of important real time critical thingies
00:01:57 <carter> and I want a pony too :P (not really)
00:02:07 <carter> ok, i'm talking too much ehre
00:02:11 <carter> night all
00:02:13 <dolio> Ponies are overrated.
00:02:34 <c_wraith> no one actually wants a pony
00:03:00 <carter> yeah,  i never understand why anyone would also want to ride in an open carriage
00:03:07 <carter> icky smells
00:03:23 <koala_man> just one horsepower
00:03:37 <carter> and smelly
00:03:40 <carter> haha
00:03:42 <carter> night
00:04:06 <smanek> Hi, I just installed the "haskell package" on my mac. Whenever I try to 'cabal install' anything (including cabal-install), I get the error: "cabal: failed to parse output of 'ghc-pkg dump'"
00:04:51 <smanek> fwiw, ghc --version yields "The Glorious Glasgow Haskell Compilation System, version 6.12.3"
00:05:18 <smanek> and cabal --version yields "cabal-install version 0.6.2
00:05:18 <smanek> using version 1.6.0.3 of the Cabal library"
00:05:23 <smanek> Any ideas?
00:07:57 <nejucomo> smanek: Maybe you installed ghc separate from the haskell platform?
00:08:12 <nejucomo> I believe ghc comes bundled with hp.
00:10:26 <ddarius> I'm pretty sure that version of cabal-install is pretty old.  Perhaps your path is setup so that it sees an old version rather than the newly installed version.
00:12:05 <ManateeLazyCat> It's possible convert String (unknown encoding) to CString (byte of array)?
00:12:05 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
00:17:17 <smanek> ddarius:  Thanks, it did appear to be a PATH issue
00:37:14 <ManateeLazyCat> @tell siracusa gtk2hs is self-documentation package, you can find same template in other modules when you binding new module. If you interested, you can find missing modules/functions in TODO file of darcs repository.
00:37:14 <lambdabot> Consider it noted.
00:53:31 <deteego> is there a haskell function which takes the first element out of a list and returns the rest of the elements
00:53:41 <Botje> tail?
00:53:49 <Botje> > tail [1..5]
00:53:50 <lambdabot>   [2,3,4,5]
00:54:25 <deteego> Eh I phrased that incorrectly
00:59:07 <c_wraith> > (head &&& tail) [1..5]
00:59:08 <lambdabot>   (1,[2,3,4,5])
00:59:14 <mm_freak> > splitAt 1 [1..5]
00:59:15 <lambdabot>   ([1],[2,3,4,5])
00:59:29 <mm_freak> ok
00:59:36 <c_wraith> deteego, I suspect you really just want to pattern match against the : constructor
00:59:39 <mm_freak> > zip <$> head <*> tail $ [1..5]
00:59:40 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
00:59:40 <lambdabot>    arising from a use...
01:00:00 <mm_freak> huh?!
01:06:17 <flux> has anyone compiled darcs for n900?
01:13:55 <zachk> how do i manually check the upperbound on Int ? 
01:14:24 <ddarius> What do you mean?
01:14:25 <zachk> :t ubound 
01:14:26 <lambdabot> Not in scope: `ubound'
01:14:26 <medfly> > maxBound :: Int -- ?
01:14:27 <lambdabot>   9223372036854775807
01:14:39 <zachk> yea thank you 
01:14:58 <zachk> does that very from implemntation to implemntation or is it in the report or is it machine specific 
01:15:09 <zachk> vary* 
01:15:13 <medfly> machine specific, I guess
01:15:26 <ddarius> The Report gives a minimal range, but it varies between implementations.
01:15:33 <zachk> ah
01:15:41 <medfly> listen to someone who isn't me
01:15:43 <medfly> he is correct
01:15:44 <medfly> :D
01:15:59 <ddarius> Use Int32/64 if you need something fixed.
01:16:29 <zachk> : maxBound :: Int64 
01:16:37 <zachk> oops too much forth ;) 
01:16:44 <deteego> is there a haskell function which appends the results of a recursive expression into a list?
01:16:59 <deteego> (as you recurse through the expression)
01:17:17 <zachk> what do you mean by "appends into " ? 
01:17:50 <zachk> :t intersperse 
01:17:51 <lambdabot> forall a. a -> [a] -> [a]
01:17:52 <deteego> lets say you have a recursive expression that outputs 3 on the first iteration, 4 on the second, 5 on the third
01:18:09 <deteego> it will return [3,4,5]
01:18:12 <deteego> hmm
01:18:22 <zachk> well then you are returning a list 
01:18:45 <deteego> well yes
01:18:55 <zachk> ok then you need something that works on lists 
01:19:06 <zachk> doesnt matter that the list is defined using recursive functions 
01:19:24 <zachk> so what do you want to do with your list result? 
01:19:32 <zachk> mix it into another list? 
01:19:48 <bss03> @type iterate
01:19:48 <lambdabot> forall a. (a -> a) -> a -> [a]
01:20:36 <bss03> take 12 $ iteratate (+1) 1
01:20:39 <deteego> zachk: no I just want to use the list result
01:20:40 <bss03> > take 12 $ iteratate (+1) 1
01:20:40 <lambdabot>   Not in scope: `iteratate'
01:20:47 <bss03> > take 12 $ iterate (+1) 1
01:20:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12]
01:21:04 <zachk> > take 10 . iterate (+1) $ 0 
01:21:05 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
01:21:11 <deteego> ok thanks
01:21:15 <deteego> iterate is what I am looking for
01:21:27 <zachk> hehe i just noticed iterate earlier today 
01:21:39 <zachk> so thanks to helpful people as well ;) 
01:21:44 <nimred> any idea about http://haskell.pastebin.com/X9GHVMJE when running `sh bootstrap.sh` in cabal-install directory ?
01:22:41 <zachk> you need the zlib library 
01:22:50 <zachk> you might be better off with the haskell platform 
01:22:56 <zachk> the zlib c library 
01:23:52 <nimred> zachk sure the script is trying to install it but cannot...
01:24:02 <nimred> my question is about why it cannot install it
01:25:26 <zachk> cabal installs haskell libraries
01:25:36 <zachk> not the c libraries that some of them need 
01:26:25 <nimred> zachk so what is the solution to my problem according to you ?
01:26:29 <zachk> nimred, any particular reason you need 6.8.3? 
01:26:41 <zachk> use your package manager and install zlib-dev libraries 
01:26:49 <zachk> or just install the haskell platform 
01:27:30 <zachk> http://hackage.haskell.org/platform/ haskell platform download 
01:27:31 <nimred> zachk zlib is already installed on my system
01:27:40 <zachk> not sure then 
01:27:43 <nimred> just need binding to haskell
01:27:57 <zachk> what os are you on? 
01:28:01 <nimred> NetBSD
01:28:10 <nimred> and ghc is installed from pkgsrc
01:28:26 <nimred> http://pkgsrc.se/search.php?so=ghc
01:28:49 <nimred> 6.12.3 is in wip section
01:28:58 <nimred> so it doesn't compile yet...
01:29:10 <nimred> that's why i use 6.8.3
01:29:55 <zachk> uhh is the zlib dev c library registered with your os's c package manager, or in the correct place
01:30:08 * zachk has never used netbsd and is not an expert on build systems 
01:31:09 <nimred> zachk here is where it installs libraries http://cvsweb.se.netbsd.org/cgi-bin/bsdweb.cgi/pkgsrc/devel/zlib/PLIST?rev=1.3;content-type=text%2Fplain
01:31:44 <nimred> so zlib.h is located in /usr/pkg/include/
01:32:50 <nimred> i meant headers not libraries
01:35:33 <nimred> zachk any idea ?
01:36:18 <zachk> let me check out zlib again on ubuntu
01:36:31 * zachk rembers banging his head off the wall for a few days before with a similar problem 
01:37:38 <zachk> ok 
01:38:03 <zachk> for unbuntu ,at least: I have a zlib1g , zlib1g, zlib1g-dev 
01:38:10 <zachk> you need the dev version 
01:38:17 <zachk> im not sure how netbsd does things though 
01:39:26 <nimred> the dev version ?
01:40:10 <zachk> well on unbuntu at least, packages have user versions, and dev versions, well some libraries do...
01:40:26 <zachk> the user version is sufficient for a program calling them 
01:40:43 <zachk> but the dev(eloper) version is for programs building off the libraries 
01:40:55 <nimred> on NetBSD you have one version
01:40:56 <nimred> lol
01:41:03 <zachk> yea thats what i thought 
01:41:23 <zachk> ghc isnt finding your zlib libraries for some reason 
01:41:23 <nimred> but it probably is your dev one
01:41:27 <nimred> http://pkgsrc.se/devel/zlib
01:41:29 <zachk> cabal install zlib 
01:41:34 <zachk> whats that say? 
01:41:48 <nimred> zachk cabal is not installed since i am installing it...
01:42:33 <nimred> remember i am running bootstrp.sh scrip from cabal-install directory when getting errors i pasted to http://haskell.pastebin.com/X9GHVMJE...
01:42:49 <nimred> s/bootstrp.sh/bootstrap.sh
01:47:05 <zachk> do you have a package for cabal or cabal install? 
01:47:11 <zachk> cabal-install 
01:48:21 <nimred> zachk yes but in Work In Progress section of pkgsrc
01:48:37 <nimred> sure if we have had a stable version i would have installed it from pkgsrc...
01:49:20 <zachk> http://pkgsrc.se/wip/hs-cabal
01:49:28 <nimred> yes in WIP section
01:49:28 <zachk> does that version work? 
01:49:35 <nimred> not yet
01:49:35 <zachk> whats wip? 
01:49:43 <nimred> Work In Progress
01:49:52 <zachk> ah
01:50:34 <nimred> as i said wip/hs-cabal requires wip/ghc wich doesn't compile yet
01:50:37 <nimred> so forget it
01:50:56 <nimred> what works is lang/ghc
01:51:06 <nimred> 6.8.3 version
01:51:40 <zachk> so you are doing this by hand? 
01:52:06 <zachk> cabal is a haskell library 
01:52:19 <zachk> and a command line program 
01:52:25 <nimred> i know
01:52:29 <nimred> i already used it
01:52:50 <nimred> and have no problem
01:52:59 <nimred> had no problem
01:54:35 <zachk> ld: canno find -lgmp
01:54:41 <zachk> library gnu multiprecision 
01:54:54 <zachk> ghc uses that to do alot of numerical work 
01:56:20 <rprichard> I wrote some code that overflows the stack, but I don't know why.  I was trying to force a list of ByteString to be evaluated using foldl' and (flip seq).  Can someone help?  http://haskell.pastebin.com/z6maqVHq
01:58:37 <nimred> zachk sure but why cannot it find libgmp.so
01:58:43 <nimred> it is on my system
01:58:50 <zachk> dunno 
01:58:59 <zachk> did ghc build ? 
01:59:01 <nimred> [~/cabal-install-0.8.2]->> locate libgmp.so
01:59:01 <nimred> /usr/pkg/lib/libgmp.so
01:59:01 <nimred> /usr/pkg/lib/libgmp.so.10
01:59:02 <nimred> /usr/pkg/lib/libgmp.so.10.0.1
01:59:06 <zachk> can you run ghci ? 
01:59:23 <zachk> try manually installing the haskell zlib library
01:59:28 <nimred> sure i can :
01:59:30 <nimred> [~/cabal-install-0.8.2]->> ghci
01:59:30 <nimred> GHCi, version 6.8.3: http://www.haskell.org/ghc/  :? for help
01:59:30 <nimred> Loading package base ... linking ... done.
01:59:31 <nimred> Prelude>
01:59:36 <zachk> and manually installing i believe the haskell http library 
01:59:50 <nimred> http library are installed
02:00:04 <zachk> ok manually install zlib for haskell then 
02:00:13 <ketil>    @seen ndm
02:00:14 <preflex>  ndm was last seen on #haskell 1 year, 122 days, 22 hours, 41 minutes and 33 seconds ago, saying: plus with current compiler technology, it would be slower
02:00:14 <nimred> caba-install's bootstrap script could install it
02:00:23 <ketil> No good waiting around for him, then?
02:00:23 <zachk> or you could just try downloading sorce for 6.12.x and building that 
02:00:43 <nimred> zachk ouch building ghc 6.12.x
02:00:51 <zachk> it takes a while 
02:00:59 <nimred> sure it does
02:01:03 <zachk> manually install haskell packages http and zlib 
02:01:09 <zachk> i had to do that before 
02:01:12 <nimred> http one is already installed
02:01:22 <nimred> just need zlib one
02:02:20 * nimred doesn't think it is a good idea to manually install it by hand. cabal-l-install install script should be able to install it
02:02:35 <testfacecase> hello 
02:02:40 <testfacecase> anybody home?
02:02:51 <zachk> hi
02:02:58 <zachk> nimred, do it by hand 
02:03:18 <testfacecase> whats the recommended library for image manipulation in haskell?
02:03:19 * zachk remembers installing gentoo, by hand , with errors in the installation text file 
02:03:45 <zachk> testfacecase, not sure 
02:04:02 <testfacecase> I see lots of the on hackage
02:04:09 <testfacecase> just not sure whats the industry standard
02:04:47 <nimred> zachk if cabal cannot be installed because of error, let me think about what it will be once i will have installed zlib binding for haskell by hand and i will need to install a package...
02:05:03 <zachk> no it goes smoothly after that 
02:05:08 <zachk> except for libs with ffi 
02:05:13 <zachk> foreign function interfaces
02:05:18 <zachk> then you need the c libraries again 
02:05:25 <nimred> should work
02:05:39 <nimred> no reason to install by hand
02:05:56 <foolcraft> hey all
02:05:59 <zachk> dude why are you running a nix if you dont want to get your hands dirty? ;) 
02:06:00 <zachk> sup 
02:06:20 <nimred> the solution is not to install by hand but to understand why gmp libraries can not be found by ghc
02:06:25 <foolcraft> I want to create a list based on a list comprehenshion of another list
02:06:40 * zachk uses the shotgun approach at first 
02:06:42 <foolcraft> I just don't know how to refer to the other list's elements
02:06:53 <foolcraft> something like
02:06:56 * zachk knows very little about list comprehensions 
02:07:09 <foolcraft> let x = generateFirstList
02:07:30 <zachk> > let x = [1..10] in x 
02:07:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
02:07:46 <foolcraft> oh okay
02:08:02 <nimred> zachk there are other opportunities to get hands dirty
02:08:15 <zachk> im saying 
02:08:19 <foolcraft> sweet I'm trying it out now
02:08:44 <zachk> getting cabal-install working is a tedious process, most of which ive done by hand before, but once its up and running its golden 
02:09:01 <foolcraft> so how can I generate a variable sized list...
02:09:12 <zachk> use a function 
02:09:22 <zachk> you want to start at 1 and goto n? 
02:09:36 <zachk> > let f n = [1..n] in f 5 
02:09:37 <lambdabot>   [1,2,3,4,5]
02:09:42 <zachk> or
02:09:56 <zachk> > let f n = enumFromTo 1 n in f 5 
02:09:57 <lambdabot>   [1,2,3,4,5]
02:09:59 <zachk> or 
02:10:04 <foolcraft> hmm
02:10:06 * hackagebot flowsim 0.2.7 - Simulate 454 pyrosequencing  http://hackage.haskell.org/package/flowsim-0.2.7 (KetilMalde)
02:10:09 <zachk> > let f = enumFromTo 1 in f 5 
02:10:10 <lambdabot>   [1,2,3,4,5]
02:10:26 <zachk> > 2 + 2 -- use this to tinker with haskell code in the channel 
02:10:27 <lambdabot>   4
02:10:42 <foolcraft> so lets say I'm refering to the entire list of lists in the form [1<=x<=5, 1<=y<=5, 1<=z<=5]
02:11:02 <zachk> ok and you want a triple ? 
02:11:13 <Jonno_FTW> > --
02:11:14 <lambdabot>   not an expression: `--'
02:11:17 <foolcraft> yeah I want a set of triples
02:11:22 <foolcraft> well list*
02:12:28 <zachk> > let list = ['a'..'c'] in let cp l1 l2 l3 = do a1<-l1; a2 <-l2; a3<-l3 ; return (a1,a2,a3); in cp list list list 
02:12:29 <lambdabot>   [('a','a','a'),('a','a','b'),('a','a','c'),('a','b','a'),('a','b','b'),('a'...
02:12:46 <zachk> that do notation is in the list monad 
02:14:07 * hackagebot redis 0.8.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.8.1 (AlexanderBogdanov)
02:16:43 <bla123> why is getArgs in IO? can command line arguments change during program execution?
02:17:26 <deteego> bla123: because its not a pure function
02:17:42 <bla123> deteego: what is impure about it?
02:17:44 <nimred> zachk `LIBRARY_PATH="${LIBRARY_PATH}:/usr/pkg/lib" sh bootstrap.sh` worked
02:17:45 <nimred> lol
02:17:49 <deteego> you cant implicitly determine what getArgs will return during program exection
02:18:29 <deteego> a pure function is the mathematical definition of the word function
02:18:47 <deteego> as in, it can only return one and only one y for that x
02:19:08 <bla123> but couldn't i see getArgs as a constant?
02:19:29 <deteego> Haskell doesn't
02:19:33 <deteego> its not constant
02:19:41 <deteego> it changes depending on the arguments you put in
02:19:58 <deteego> if I put in 5 as an argument, getArgs will return 5
02:20:01 <bla123> but the arguments don't change within one program run
02:20:05 <deteego> if I put in 3 as an argument, getArgs will return 3
02:20:09 <deteego> its returning different values
02:20:20 <deteego> even though the input for the function call (getArgs) is the same
02:20:25 <deteego> that makes the function impure
02:20:29 <deteego> which is what IO() means
02:20:54 <deteego> to force the function to be pure
02:21:03 <deteego> so for one IO(), getArgs will return 5
02:21:12 <deteego> and for another (seperate) IO(), getArgs will return 3
02:21:13 <Zao> bla123: getArgs is a constant of type IO [String] "an action in the IO monad returning a list of strings when sequenced"
02:21:14 <deteego> etc etc
02:21:33 <bla123> the result of getArgs only changes between program runs, and there is no communication between runs
02:21:49 <Zao> Monadic actions are values like everything else, it's just that they have particular meanings in some contexts.
02:21:49 <deteego> anything that talks with the outside world (input/output) requires IO
02:22:11 <foolcraft> let loses = [[lst in c, otherLst in c] | sum (lst) < sum(otherLst)]
02:22:17 <zachk> monads are better known as , "Warm Fuzzy Things" 
02:22:21 <foolcraft> it's complainingness for some reason :p
02:22:23 <jeltsch> bla123: Imagine a hypothetical Haskell implementation for distributed systems. Two Haskell programs on two different computers could exchange expressions.
02:22:44 <bla123> jeltsch: ok, i see
02:23:11 <bla123> convinced. :)
02:24:04 <zachk> > let list = [1..5] in sum list -- look foolcraft no () needed around function args 
02:24:04 <lambdabot>   15
02:24:16 <foolcraft> zachk: sowwy, new to haskell land
02:24:20 <zachk> its ok 
02:24:35 <foolcraft> (haskell is solving a lot of probs for me, and I just started playing with it!)
02:24:39 <deteego> beh I have this problem that I am trying to solve in an elegant way
02:24:39 <zachk> once you get too used to it all other languages feel like icky poo D: 
02:25:09 <deteego> I need to 'zip' two expressions, however one is recursive and the other one is a list
02:25:25 <zachk> whats the recursive expression 
02:25:37 <deteego> its recursive decent parser
02:25:47 * ketil prefers indecent parsers.
02:26:17 * zachk loved playing descent 2 on pc 
02:26:25 <ketil> what do you mean by 'zip'ing them?
02:26:27 <deteego> the recursive expression is eval env expr
02:26:28 <Zao> foolcraft: f(a,b,c) in a typical language maps to (f a b c) here.
02:26:44 <ManateeLazyCat> @hoogle "String -> [Word8]"
02:26:45 <lambdabot> Parse error:
02:26:45 <lambdabot>   --count=20 ""String -> [Word8]""
02:26:45 <lambdabot>              ^
02:26:55 <deteego> and inside the function definition of eval it can (obviously) call eval again
02:26:57 <zachk> deteego, ok whats the type of the return val of your parser? 
02:26:59 <Zao> foolcraft: That is, apply f to a, then the result of that to b, then the result of that to c, evaluating to the result of that.
02:27:09 <deteego> zachk: a value
02:27:22 <deteego> the problem is I am dealing with closures/function applications
02:27:25 <zachk> yea but what Type 
02:27:29 <Zao> My terminology being slightly off with "apply" :)
02:27:33 <zachk> whats its type signature 
02:27:39 <deteego> oh
02:27:54 <ketil> @type zip
02:27:55 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
02:28:05 <deteego> Value data Value
02:28:07 <deteego>     = IVal Integer
02:28:09 <deteego>     | BVal Bool
02:28:10 * hackagebot feldspar-language 0.3.3 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.3.3 (EmilAxelsson)
02:28:11 <deteego>     | CVal Exp Env [Id] -- closures
02:28:11 <ketil> (what - no caleskell?)
02:29:01 <deteego> the issue is that on closures, the list of ids is the function arguments
02:29:07 * zachk isnt very good at parsing 
02:29:25 <deteego> however I receive an exp (which is the function application)
02:29:32 <deteego> that is called recursively
02:29:43 <deteego> minhs: exp1 : App (App (Var (Id "add" 1949213168)) (Num 1)) (Num 2) exp2: Num 3
02:29:50 <deteego> thats what a function application looks like for example
02:29:54 <zachk> you need to build an abstract syntax tree 
02:29:57 <deteego> (its recursive)
02:30:01 <deteego> I already have an AST
02:30:14 <zachk> then you just need to evaluate it 
02:30:15 <deteego> where as the [Id] in the closure
02:30:18 <deteego> is a lost
02:30:20 <deteego> *list
02:30:28 <deteego> zzz im not explaining this well
02:30:43 <deteego> ok, I am at the point
02:30:49 * zachk doesn't understand this stuff yet ... 
02:30:49 <deteego> where I am evaluating a function application
02:31:04 <deteego> such as f 10 -3 15
02:31:23 <deteego> f being a function, 10, -3, 15 being the arguments
02:31:27 <Zao> (-3), you mean.
02:31:31 <zachk> do you need state? 
02:31:39 <deteego> there is a closure in the environemnt with the function definition
02:31:48 <deteego> the App im my AST is of the form
02:31:48 <zachk> Zao, he is making his own language he can do what he wants, for now ;) 
02:32:01 <Zao> Oh. I thought this was #haskell :D
02:32:13 <deteego> App Exp Exp
02:32:17 <zachk> well he is writing his language to be haskellish it seems 
02:32:41 <zachk> make your language pure and disallow closures, t hen half your problems go away 
02:32:42 <deteego> so you have to evaluate the two expressions
02:33:11 <deteego> the expressions corellate with exp1: App (Var (Id "eq" 2025572021)) (Num 3) exp2: Num 4
02:33:18 <deteego> so thats recursive
02:33:41 <deteego> however when you retrieve the closure, it has a list of [ids] which need to get mapped with the various arguments in the application
02:34:08 <zachk> whats an Id? 
02:34:15 <deteego> (so in above example, x would get mapped to 3 and y mapped to 5)
02:34:21 <deteego> identifier for the binding
02:34:59 <deteego> like [Id] would be [("x", hash),("y", hash)]
02:35:15 <deteego> thats what you would receive from the closure in the environment
02:35:34 <deteego> so in the above case, 3 would have to get mapped to x and 4 to y
02:35:42 <foolcraft> hmm so how can I declare a generic fiveElement list
02:36:00 <deteego> problem is that exp1 has to be evaluated recursively (by calling eval env exp1) where as the id
02:36:09 <deteego> id's from the closure are already in the form of a list
02:36:14 <foolcraft> nevermind that's not what I was asking for ;p
02:36:28 <deteego> zachk: I asked this before and someone told me about iterate
02:36:37 <foolcraft> I guess I want to create an empty list and add to it
02:36:38 <deteego> as in a function that takes a recursive statement and returns it as a list
02:36:44 <zachk> foolcraft you want 5 elements only? use tuples, you want n elements, (n can be infinite) use lists 
02:36:51 <deteego> but thats not exactly what I am looking ofr
02:36:52 <deteego> *for
02:37:09 <foolcraft> let a = [sum any c]
02:37:14 <Jonno_FTW> is there a function which returns the inverse of that function?
02:37:16 <foolcraft> I want to write what means this
02:37:22 <foolcraft> but of course this doesn't work :
02:37:46 <zachk> foolcraft, what do you mean? in english 
02:37:48 <deteego> actually simply put, is there a function which takes a recursive function and returns a list of the outputs of that recursion through every iteration
02:37:56 <foolcraft> I want to create a list of all the sums of all the lists in c
02:38:11 <Jonno_FTW> > map sum xs
02:38:12 <lambdabot>   Not in scope: `xs'
02:38:19 <foolcraft> so if I have [[1,2],[3,4],[4,5]] I want [3,7,9]
02:38:31 <Jonno_FTW> > map sum [[1,2],[3,4],[4,5]]
02:38:31 <lambdabot>   [3,7,9]
02:39:03 <Jonno_FTW> ?
02:39:21 <foolcraft> hmm :D sweet
02:39:29 <zachk> > sum <$> [1,2] <*> [3,4] <*> [4,5] 
02:39:30 <lambdabot>   No instance for (GHC.Num.Num [a -> a1 -> b])
02:39:30 <lambdabot>    arising from a use of `e_11...
02:39:33 <foolcraft> I think I just got an aha moment that should be enjoyed sometime
02:39:41 <deteego> so for example, something like someFunc (factorial 5) -> [20,12,6,2,1]
02:39:47 <zachk> > [sum] <$> [1,2] <*> [3,4] <*> [4,5] 
02:39:48 <lambdabot>   Couldn't match expected type `a2 -> a1 -> a -> b'
02:39:48 <lambdabot>         against inferred ...
02:39:58 <nimred> zachk i now encouter troubles when installing x11 from cabal : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29826#a29826. Command was : `LIBRARY_PATH="${LIBRARY_PATH}:/usr/pkg/lib:/usr/X11R7/lib" cabal install xmonad`
02:41:18 <deteego> zachk: any ideas?
02:41:23 <foolcraft> so I want to evaluate a combinatorial game (might as well spill it out ;p)
02:41:40 <Jonno_FTW> foolcraft: there is a library for game theory
02:41:50 <foolcraft> and I wanted to have a list of all possible plays, which is done, but then I want to take out the wins into another list
02:41:57 <foolcraft> Jonno_FTW: combi games are simpler
02:42:01 <foolcraft> there's always a winner
02:42:07 <foolcraft> and everyone has the same moves
02:42:17 <Jonno_FTW> you know of filter?
02:42:22 <Jonno_FTW> or list comprehension?
02:42:22 <foolcraft> nope :(
02:42:27 <zachk> nimred, http://hackage.haskell.org/package/xmonad get 6.12 
02:42:31 <zachk> deteego, im not sure 
02:42:32 <Jonno_FTW> @src filter
02:42:32 <lambdabot> filter _ []     = []
02:42:32 <lambdabot> filter p (x:xs)
02:42:32 <lambdabot>     | p x       = x : filter p xs
02:42:32 <lambdabot>     | otherwise = filter p xs
02:42:40 <foolcraft> Jonno_FTW: I'm a haskell noob, tbqh, but I want to learn more about this awesomeness!
02:42:47 <Jonno_FTW> cool
02:43:00 <zachk> get "programming in haskell" by graham hutton 
02:43:08 <zachk> or "real world haskell" 
02:43:13 <Jonno_FTW> filter (\ x -> win x) plays
02:43:21 <zachk> programming in haskell got rid of most of my noobie questions 
02:43:22 <Jonno_FTW> so you have a list of plays
02:43:30 <zachk> and im still reading real world haskell 
02:43:31 <Jonno_FTW> and apply the win function to each play
02:43:33 <deteego> zachk: do you understand what I mean at least
02:43:38 <zachk> yes
02:43:40 <kamatsu> I want to read data from a handle into a bytestring until i hit a 255 word8
02:43:46 <zachk> its a hard problem as far as i know 
02:43:56 <zachk> cause you are messing with state 
02:44:02 <kamatsu> is there a way to do this that is more efficient than reading 1 word8 as a time.
02:44:24 <deteego> oh hey kamatsu 
02:44:36 <kamatsu> bbl
02:44:49 <deteego> zachk: yeh I know its a tough problem, since im mixing recursion with something already evaluated
02:45:13 <foolcraft> in english: for lists a and b, a is the list we want, if it has more elements greater than b than the elements in b that are greater than the elements in c
02:45:24 <foolcraft> okay, I think this wasn't a good explanation
02:45:30 <foolcraft> but lets take a small example
02:45:57 <zachk> try an explanation with two lists, a and b 
02:46:10 <Jonno_FTW> ^
02:46:15 <zachk> or even simpler 
02:46:30 <zachk> try an explanation with 1 list and some number that is fixed 
02:46:59 <foolcraft> (2,2,2,4,5) is a winner over (1,1,4,4,5) because the number of instances where picking one of (2,2,2,4,5) is greater than a number picked from (1,1,4,4,5) is 12
02:47:20 <foolcraft> while the same number for the other list is 4
02:47:28 <deteego> actually there is a way to solve my problem
02:47:34 <Jonno_FTW> are a and b always of equal length?
02:47:35 <deteego> but its REALLY REALLY hacky
02:47:38 <foolcraft> Jonno_FTW: yup
02:47:46 <foolcraft> I wrote the function that generates them
02:47:46 <deteego> and I would feel dirty for doing it
02:47:58 <foolcraft> of course they're of fixed length cuz I had trouble generating it for n-sized lists
02:48:08 <foolcraft> :p but I'll overcome that
02:48:11 <zachk> deteego, get dirty and solve the problem 
02:48:14 <Jonno_FTW> can't you just just check for equality of the sums?
02:48:24 <foolcraft> they are always of the same sum :)
02:48:34 <Jonno_FTW> then how is a winner defined?
02:48:43 <pao> which http client library do you suggest?
02:48:57 <Jonno_FTW> also, in haskell, we use lists like this: [1,2,3]
02:49:11 <foolcraft> the winner is defined by having more likelihood of winning, when winning is defined as "if you pick a number from a, and another from b, a > b"
02:49:12 <Jonno_FTW> (1,2,3) is a different structure
02:49:37 <Jonno_FTW> so you want every element of a to be more than b?
02:50:21 <foolcraft> not every element, but I want more elements in a that pass the comparison with an element in b and more elements in b that fail the comparison with an element in a
02:50:39 <Jonno_FTW> ok
02:50:40 <foolcraft> that's why (2,2,2,4,5) and (1,1,4,4,5) evaluates to 12
02:50:59 <foolcraft> because I've 12 such instances, 3 draws and 4 loses
02:51:09 <foolcraft> Jonno_FTW: better picture now?
02:51:12 <Jonno_FTW> yes
02:51:18 <Jonno_FTW> do you know the map function?
02:51:23 <Jonno_FTW> @src map
02:51:23 <lambdabot> map _ []     = []
02:51:23 <lambdabot> map f (x:xs) = f x : map f xs
02:51:58 <foolcraft> :( nope
02:52:05 <foolcraft> but I'm trying to get it..hmm
02:52:14 <Jonno_FTW> basically it applies a function to every element in a list
02:52:14 <deteego> how do you take the nth element out of a list again
02:52:27 <Jonno_FTW> deteego: xs !! 3
02:52:41 <Jonno_FTW> > let xs = [1..5] in xs !! 2
02:52:42 <lambdabot>   3
02:52:51 <deteego> da hell, its an infix function
02:53:01 <Jonno_FTW> > let xs = [1..5] in  (!!) xs 2
02:53:02 <lambdabot>   3
02:53:05 <Jonno_FTW> :3
02:53:48 <Jonno_FTW> > map (*10) [1,2,3,4,5]
02:53:49 <lambdabot>   [10,20,30,40,50]
02:56:20 <foolcraft> so what I want right now should be: function (list1, list2): if (number of times an element in list1 is greater than an element in list2 > number of times in an element in list2 is greater than an element in list1 True else False
02:56:48 <Jonno_FTW> ok
02:56:54 <foolcraft> lots of typos geez..hehe
02:56:58 <Jonno_FTW> break your problem down into a few functions
02:57:14 <foolcraft> Jonno_FTW: that's what my prof.s tell me :D *dejavu*
02:57:26 <Jonno_FTW> one to compare a number against every element of a list
02:57:44 <foolcraft> and the other to run that function on every element in the list
02:57:51 <Jonno_FTW> yes
02:57:55 <Jonno_FTW> sounds like a job for map
02:58:13 <Jonno_FTW> but you should make the main function recursively
03:00:13 <foolcraft> I'll move out to my group now, and definitely rejoin when I'm on campus
03:00:37 <foolcraft> thanks a lot guys, haskell sounds like a really good problem-solving tool
03:08:34 <kamatsu> what is the most efficient way, short of black magic, to read from a handle into a bytestring until i hit chr(255)?
03:10:30 <deteego> kamatsu: I just wanted to quickly ask, will there be dryrun tests for bonus marks?
03:18:45 <Jonno_FTW> @tell foolcraft  f x xs =length $ filter (< x) xs
03:18:45 <lambdabot> Consider it noted.
03:19:41 * hackagebot local-search 0.0.3 - A first attempt at generalised local search within Haskell, for applications in combinatorial optimisation.  http://hackage.haskell.org/package/local-search-0.0.3 (RichardSenington)
03:19:43 * hackagebot iyql 0.0.5.3 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.5.3 (DiegoSouza)
03:21:14 <hhooi> hello
03:21:29 <hhooi> I have a question, I just started with Haskell
03:21:36 <Jonno_FTW> go on
03:21:54 <hhooi> i have a function which is called getColumnPart 
03:22:00 <hhooi> which works
03:22:03 <Jonno_FTW> yep
03:22:10 <hhooi> getColumnPart :: [String] -> Int -> String getColumnPart [] 0 = "" getColumnPart column id = column !! id
03:22:14 <hhooi> thats the function
03:22:22 <hhooi> now I also want a getColumn
03:22:31 <hhooi> with Table ([[string]]) as input
03:22:42 <hhooi> and get a column with column from that
03:22:50 <hhooi> getColumn :: Table -> Int -> [String] getColumn column id = (map getColumnPart (column id))
03:22:55 <hhooi> but the latter doesnt work
03:23:03 <hhooi> *** Expression     : column id *** Term           : column *** Type           : [[[Char]]] *** Does not match : a -> b
03:23:14 <hhooi> i think i'm doing somewthing wrong with the map function
03:23:27 <Jonno_FTW> > id
03:23:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:23:28 <lambdabot>    arising from a use of `...
03:23:40 <Jonno_FTW> > id 5
03:23:41 <lambdabot>   5
03:24:05 <hhooi> but when I make a getColumnPart with just [String] as input and [String] as output
03:24:18 <hhooi> and with the id hardcoded to like 1 (eq column !! 1)
03:24:27 <hhooi> and use map getColumnPart (column) it works fine
03:24:50 <hhooi> i tried a lot of changes with ( and ) in the map but I'm unable to succeed
03:25:16 <Jonno_FTW> you'll have to ask someone else, I have to go
03:25:26 <hhooi> ok thanks
03:25:48 <hhooi> anyone else knows how I can solve this problem?
03:25:58 <kamatsu> deteego: no
03:26:01 <hhooi> how can I get a map with multiple arguments working?
03:26:22 <Silvah> map with multiple arguments?
03:26:38 <hhooi> yes
03:26:47 <Silvah> What do you mean?
03:26:49 <deteego> kamatsu: ok thanks
03:26:53 <hhooi> like this:
03:26:54 <hhooi> (map getColumnPart (column id))
03:27:00 <hhooi> getColumn column id = (map getColumnPart (column id))
03:27:23 <hhooi> this doesnt work but when I hardcode an id in getcolumnpart and I drop the second argument -> map getColumnPart (column)
03:27:24 <Zao> hhooi: What types are involved, and how does it not work?
03:27:24 <hhooi> it works fine
03:27:27 <hhooi> but I need the both
03:27:31 <hhooi> it gives this error:
03:27:37 <hhooi> *** Expression     : column id *** Term           : column *** Type           : [[[Char]]] *** Does not match : a -> b
03:27:49 <hhooi> getColumn :: Table -> Int -> [String]
03:27:54 <hhooi> Table = type [[string]]
03:28:40 <hhooi> i can paste the code on pastebin if thats easier
03:29:00 <Zao> What is your intent with this?
03:29:33 <hhooi> http://pastebin.com/G5NW31H2
03:29:45 <hhooi> to write some sort of sql wrapper
03:29:52 <objorn> Is there haskell documentation for the non-programmer?
03:29:56 <Zao> Do you perhaps mean   map (\x -> getColumnPart x id) column ?
03:30:23 <objorn> I have experience with C++ and Python, but I might as well be a non-programmer since complex programs befuddle me.
03:30:30 <Zao> That is, evaluating    getColumnPart whateverYouMapOverHere id   for each element in column?
03:30:50 <Zao> @pl \x -> gCP x id
03:30:50 <lambdabot> flip gCP id
03:31:00 <Zao> Or simpler, map (flip gCP id) column
03:31:10 <Cale> hhooi: You can use a lambda like Zao suggests, but if you reverse the parameters to getColumnPart, then you can just write map (getColumnPart id) column
03:31:43 <Cale> objorn: You might try "Learn You A Haskell"
03:31:49 <Cale> @where lyah
03:31:49 <lambdabot> http://www.learnyouahaskell.com/
03:32:01 <hhooi> i'll try it out, but why would the change of id and column work and not reverse? 
03:32:25 <Cale> objorn: Also, feel free to ask lots of questions, beginners are always welcome here
03:32:39 <Zao> hhooi: What you did in your original code was to try to map getColumnPart over the list (column id), which doesn't type check.
03:33:16 <hhooi> with the flip it works indeed
03:34:05 <Zao> What would the type of   map getColumnType column  be?
03:34:10 <Zao> Err, getColumnPart
03:34:34 <hhooi> getcolumnpart returns a string
03:35:26 <Zao> If you have a function  f :: a -> b -> c,  feeding that a value of type a gives you a function  f' :: b -> c
03:35:54 <Zao> map f as  would give you a result of type   [b -> c]
03:36:10 <Zao> That is, a list of functions from b to c.
03:36:39 <hhooi> aha
03:36:51 <hhooi> I now reversed the parameters of gCP
03:36:52 <hhooi> to:
03:37:07 <hhooi> getColumnPart :: Int -> [String] -> String
03:37:09 <hhooi> and with:
03:37:15 <hhooi> getColumn column id = (map (getColumnPart id) column)
03:37:24 <hhooi> but this doesnt work it gives me this error:
03:37:33 <hhooi> *** Term           : [] *** Type           : [a] *** Does not match : Int
03:37:42 <Zao> "functions" tend to fit best into a map if you have the thing you map over as the last argument, as you can then easily provide all the prior arguments in parens.
03:38:11 <hhooi> nvm forgot a simple change :)
03:38:13 <Zao> :D
03:38:55 <hhooi> so basically, when you use something with map you want the additional parameters first and use the real map thing as last
03:39:19 <Zao> hhooi: Or use lambdas to slip in the argument where you want.
03:39:28 <Zao> hhooi: Or use insane amounts of flips and (.) :)
03:40:04 <hhooi> how do lambdas work in haskell? just like c# etc?
03:40:33 <Zao> @type \x y z -> ()
03:40:34 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> ()
03:40:45 <deteego> kamatsu: you would probably get a faster answer ib the haskell-cafe mailing list
03:40:55 <Zao> (\all parameters here -> body here)
03:41:07 <deteego> hhooi: http://zvon.org/other/haskell/Outputsyntax/lambdaQabstractions_reference.html
03:41:20 <Zao> @pl \x -> f x a b c d e
03:41:20 <lambdabot> flip (flip (flip (flip (flip f a) b) c) d) e
03:41:31 <Zao> @pl \x -> f a b x c d e
03:41:32 <lambdabot> flip (flip (flip (f a b) c) d) e
03:41:32 <deteego> hhooi: functions are first class objects in haskell
03:41:43 <Zao> Sometimes flips are nicer, sometimes lambdas are smoother :D
03:42:30 <hhooi> i see
03:42:38 <objorn> Cale: thank you so much for that welcoming response, that's very heart-warming, and I truly appreciate it.
03:42:39 <Zao> @type flip
03:42:40 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:42:52 <Zao> What kind of insane flip is that?
03:43:04 <Zao> @type Prelude.flip
03:43:05 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:44:13 <Cale> > map (\x -> x^2 + x + 1) [1..10]
03:44:13 <lambdabot>   [3,7,13,21,31,43,57,73,91,111]
03:48:06 <kamatsu> hm
03:48:08 <kamatsu> actually
03:48:31 <kamatsu> if i have 8 bytes, how can I make Haskell interpret them as a 64-bit unsigned big-endian integer?
03:49:29 <zygoloid> kamatsu: http://code.haskell.org/binary/
03:49:47 <Cale> kamatsu: In what form are those bytes? binary or cereal are decent choices
03:49:58 <Cale> http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/Data-Serialize-Get.html#v:getWord64be
03:50:04 <objorn> Cale: i asked a question in #haskell-blah: http://pastebin.com/PDxHFA50
03:50:24 <objorn> Oh, there someone goes!
03:50:40 <zygoloid> yeah. cereal's Data.Serialize.Get.getWord64be or binary's Data.Binary.Get.getWord64be
03:51:27 <Cale> objorn: There are a lot of ways to approach learning programming. Working on fundamentals wouldn't be a bad idea, but jumping right in works for some people too.
03:51:52 <hhooi> Zao, thanks
03:52:04 <hhooi> I just used the lambda method and I understand that now as well
03:52:07 <hhooi> much appreciated 
03:52:40 <kamatsu> which is better? binary or cereal?
03:52:59 <Cale> objorn: I had been programming for maybe 8 years or so before I wrote a search engine, but it's not like I used all the knowledge I'd collected in that time.
03:53:21 <Cale> kamatsu: cereal is better at handling failure
03:53:36 <kamatsu> Cale: also uses strict bytestrings which suits me
03:53:38 <kamatsu> thanks all!
03:53:41 <hhooi> can you also have multiple lambas?
03:53:48 <Cale> hhooi: sure
03:53:49 <hhooi> like (\x \y -> ....)
03:53:55 <Cale> \x -> \y -> ...
03:53:59 <Cale> Or \x y -> ...
03:54:08 <hhooi> ah last one I prefer :)
03:54:40 <Cale> > zipWith (\x y -> x + y) [1..] [10,20..]
03:54:41 <lambdabot>   [11,22,33,44,55,66,77,88,99,110,121,132,143,154,165,176,187,198,209,220,231...
03:55:57 <bss03> zipWith (\x y -> x * y + 2 * x - 3 * y - 6) [1..] [1...20]
03:56:01 <bss03> > zipWith (\x y -> x * y + 2 * x - 3 * y - 6) [1..] [1...20]
03:56:02 <lambdabot>   Not in scope: `...'
03:56:07 <bss03> > zipWith (\x y -> x * y + 2 * x - 3 * y - 6) [1..] [1..20]
03:56:07 <lambdabot>   [-6,-4,0,6,14,24,36,50,66,84,104,126,150,176,204,234,266,300,336,374]
03:56:20 <kamatsu> cereal/binary are very pleasant.
03:56:50 <bss03> > zipWith (\x y -> x * y + 2 * x - 3 * y - 6) [n, x] [m, y] :: [Expr]
03:56:51 <lambdabot>   [n * m + 2 * n - 3 * m - 6,x * y + 2 * x - 3 * y - 6]
03:57:01 <Blkt> good day everyone!
03:57:12 <Cale> good night all
03:57:33 <Blkt> omg time zones!
04:00:59 <ashley_s> I have a problem, whenever I change Main.hs and run 'ghc --make Main', Main.hs is not recompiled and instead the executable is just linked. Whats the cause of this? I have tried removing all .o and .hi files. Nothing works.
04:01:32 <ManateeLazyCat> ashley_s: 'ghc --make Main.hs' ?
04:02:56 <ashley_s> nvm, I just fixed it. Thanks anyway ManateeLazyCat
04:03:25 <quicksilver> ashley_s: what was wrong?
04:04:13 <ashley_s> Compiling off my usb took forever, so I copied my source to my HDD, and my editor was pointing to the old version. lol.
04:05:16 <quicksilver> :)
04:06:52 <ManateeLazyCat> quicksilver: Do you have text-scale-decrease-global, text-scale-increase-global, text-scale-default-global ?
04:07:50 * ManateeLazyCat pasted "global scale" at http://paste2.org/get/981623
04:07:51 <ManateeLazyCat> quicksilver: Looks above, global scale. 
04:08:23 <ManateeLazyCat> quicksilver: Source code at lazycat-toolkit.el . :)
04:22:55 <yaxu> hi all, I'd like to upload some code to hackage, a client for a music time sync protocol called 'netclock', should I worry about namespace pollution?
04:23:22 <yaxu> at the moment it's called Netclock.Client , would Network.Netclock.Client be better?
04:25:54 <Zao> Maybe it fits in under one of the usual root names, like Network or something?
04:26:02 <Zao> Or if there's a Protocol or Data, maybe?
04:28:21 * hackagebot lbfgs 0.0.1 - L-BFGS optimization  http://hackage.haskell.org/package/lbfgs-0.0.1 (DanielDeKok)
04:29:10 <atude> how do you guys read ebooks?
04:30:33 <Twey> You're making the important assumption that we do in fact read ebooks
04:31:14 <atude> of course you do
04:31:36 <Twey> yaxu: I'd put it under Network.
04:33:48 <bss03> I read PDFs using Okular.
04:34:04 <bss03> I read HTML books using Konqueror.
04:34:26 <bss03> I read RWH on my Android-based phone using the app that came with the book.
04:37:05 <kremsera> chm: kchm
04:37:22 <atude> bss03: any particular resolution, monitor, some method where you multitask?
04:46:07 <bss03> atude: I have dual monitors.  So, often I'll have full screen documentation on one and do stuff on the other.
04:46:29 <bss03> atude: X resolution 3200x1920, but a bit of that is dead space.
04:47:48 <tab> look like a weird resolution
04:47:53 <atude> bss03: what resolution is most practical for majority of pdfs documents, I'm not too sure what 8.5"x11
04:47:54 <p_l> bss03: two 1920x1600 monitors in portrait mode?
04:48:24 <p_l> ah, dead space, so mismatched displays? :D
04:49:20 <mm_freak> as soon as a library needs something external like a C library, installing it under windows becomes a pain in the ass
04:49:32 <mm_freak> in my case it's SDL
04:49:54 <davean> p_l: or not oriented the same
04:49:58 <p_l> davean: true
04:49:58 * davean has deadspace with 3 identially displayes (two in portrait, one in widescreen)
04:50:18 * p_l would love 2 Big Bertha displays :3
04:50:36 <tab> in standard inches size what's a big bertha ? :P
04:50:39 <p_l> thoguh I suspect configuring them would be a great... "adventures"
04:51:00 <p_l> tab: Big Bertha is a very specific, no longer manufactured 22" display
04:51:26 <p_l> that has 3840x2400 resolution
04:51:52 <tab> probably better 2 24" isn't it ?
04:52:09 <tab> (and you keep the same resolution)
04:52:10 <davean> tab: i'd take a high res 22 over a 24 any day
04:52:21 <p_l> tab: it has enough pixels to display 4 FullHD frames on single display :D
04:52:22 <davean> screens are very pixely, and I don't like that
04:52:46 <tab> davean: you need to get further from the screen though :)
04:52:49 <bss03> @hoogle writeSTRef
04:52:49 <lambdabot> Data.STRef writeSTRef :: STRef s a -> a -> ST s ()
04:52:49 <lambdabot> Data.STRef.Lazy writeSTRef :: STRef s a -> a -> ST s ()
04:53:11 <p_l> “The IBM T220 and T221 are LCD monitors with a native resolution of 3840×2400 pixels (WQUXGA) on a screen with a diagonal of 22.2 inch (564 mm). This works out as over 9.2 million pixels, with pixel density of 204 pixels per inch (80 dpcm, 0.1245 mm pixel pitch)”
04:53:35 <bss03> Yeah, they are mismatched displays.
04:53:47 <deteego> is there a name given to the process of mapping out recursive iterations into a list
04:53:58 <bss03> One is a 4x3, the other is 16x10.
04:54:21 <deteego> mm_freak: yeah C libraries with windows are painful
04:54:28 <deteego> mm_freak: hopefully it will get better with LLVM
04:54:36 <deteego> actually that reminds me
04:55:12 <ski> deteego : "mapping out recursive iterations into a list" meaning ?
04:55:23 <p_l> though to drive T221-DG5 at full speed I'd need... four dual-link DVI connections?
04:55:51 <deteego> ``well I just made a function that does something like this
04:56:25 <deteego> funcName :: (fac 5) -> [20,12,6,2,1]
04:56:41 * yaxu gets a lesson from hlint
04:56:42 <deteego> so if you put in fac5 into this function
04:57:06 <foolcraft> ello!
04:57:06 <lambdabot> foolcraft: You have 1 new message. '/msg lambdabot @messages' to read it.
04:57:19 <bss03> Hrm, I need to keep some state between invocations of a (a -> IO ()) function.
04:57:27 <mm_freak> deteego: in what way could LLVM help?
04:57:28 <deteego> it would return a list of iterations through the recursion (5x4, 4x3, 3x2, 2x1) and put them in a list
04:57:32 <bss03> What's a good way to do that.  MVar? STRef?
04:57:34 <ski> deteego : that doesn't look like a valid type signature
04:57:41 <deteego> ski: its not, its just an example
04:57:48 <deteego> I wrote the function in a different context
04:57:56 <foolcraft> hey all, so I want to be able to write this
04:57:59 <bss03> No explicit calls to par or other concurrentcy stuff.
04:58:08 <foolcraft> Prelude> let a = [[a,b,c,d,e] | [a,b,c,d,e] <- possible5, zip tail [a,b,c,d,e] fst [a,b,c,d,e]  not in a]
04:58:12 <deteego> im just asking if that process has a technical name
04:58:22 <mm_freak> bss03: StateT
04:58:42 <deteego> mm_freak: if they include LLVM C compiler, LLVM can be used to compile the C libraries and directly link it with the LLVM assembly code instead of having to rely on gcc
04:58:47 <ski> deteego : so, do you somehow want a "trace" of the recursive calls made ?
04:59:05 <mm_freak> bss03: turn your 'a -> IO ()' into 'a -> StateT StateType IO ()'
04:59:20 <mm_freak> deteego: ah, i see
04:59:22 <bss03> mm_freak: I don't think that works.  I need to hide the fact that I'm using state.
04:59:34 <bss03> mm_freak: The API I'm writing to expects a (a -> IO ()).
04:59:47 <foolcraft> any ideas... on how to say "not in" in haskell
04:59:58 <ski> @type notElem
04:59:58 <deteego> ski: I just want to name my function
04:59:59 <bss03> `notElem`
04:59:59 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:00:02 <mm_freak> bss03: in that case either a state manager thread and MVar or (much simpler, but less safe) an IORef
05:00:04 <deteego> ski: it already works as intended
05:00:18 <ski> deteego : oh, you've already written a function ? what's its type ?
05:00:22 <deteego> ski: yes yes
05:00:30 <deteego> ski: I just dont know what to call it
05:00:31 <Twey> deteego: Looks like a scan.
05:00:34 <bss03> I foudn the MVar docs...
05:00:38 <bss03> @hoogle IORef
05:00:38 <lambdabot> module Data.IORef
05:00:38 <lambdabot> Data.IORef data IORef a
05:00:39 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
05:00:44 <mm_freak> foolcraft: doesn't make sense to me
05:00:47 <Twey> > scanl (*) 1 [1 .. 5]
05:00:48 <lambdabot>   [1,1,2,6,24,120]
05:01:04 <ski> > 5 `notElem` [2,3,5,7]
05:01:05 <lambdabot>   False
05:01:13 <deteego> Twey: I guess its a recursive scan
05:01:14 <mm_freak> bss03: but the problem is:  you still need to pass something around, in this case the particular IORef
05:01:18 <Twey> > scanr (*) 1 [1 .. 5]
05:01:19 <lambdabot>   [120,120,60,20,5,1]
05:01:24 <Twey> Damn
05:01:27 <mm_freak> bss03: unless you want to get /really/ evil and use a global IORef
05:01:40 <bss03> mm_freak: Well, I was going to use a closure.
05:01:41 <foolcraft> let a = [[a,b,c,d,e] | [a,b,c,d,e] <- possible5, [zip tail [a,b,c,d,e], fst [a,b,c,d,e]] `notElem` a]
05:01:57 <foolcraft> so I want to get rid of all permutations of lists in possible5
05:02:11 <ski> deteego : still waiting for the type signature (or any description of what the function actually *does*), here ..
05:02:34 <deteego> ski: in my case the type signature is for a specific, not for a generic function
05:02:49 <deteego> I mean I can post the function if you want
05:02:54 <bss03> So, make a IORef b called "state", then make an IORef b -> a -> IO () called "f", then pass the "f state" into the API.
05:02:54 <mm_freak> foolcraft: permutations of what list(s)?
05:02:59 <deteego> its nothing really special
05:03:02 <Twey> No, that wasn't a type signature… it was an example of calling
05:03:03 <bss03> mm_freak: Might that work?
05:03:12 <foolcraft> possible5 returns a list of lists
05:03:18 <mm_freak> bss03: i don't see how that could work
05:03:25 <Twey> fac 5 ===> [20, 12, 6, 2, 1]
05:03:30 <Twey> … I think.
05:03:36 <ski> deteego : well, i'm afraid i can't help with name suggestions if i don't even get what the function is supposed to do (so please elaborate on that)
05:03:41 <mm_freak> bss03: remember you need to access the variable from the computation, so you need to pass it there
05:03:44 <foolcraft> mm_freak: and I want to get rid of all the permutations of 'any' list in possible5, but keep one instance
05:03:58 <mm_freak> foolcraft: i see
05:04:06 <Jonno_FTW> nub $ map sort?
05:04:11 <bss03> mm_freak: That's why I'm using partial application, yes?
05:04:39 <deteego> liftApp :: Env -> Exp -> [Value]
05:04:42 <deteego> liftApp env exp = case exp of
05:04:44 <deteego>             Var _g -> [eval env (Var _g)]
05:04:46 <deteego>             App e1 e2 -> (eval env e2:(liftApp env e1))
05:04:48 <deteego> thats the function
05:05:12 <deteego> Env, Exp refer to a generic recursive descent parser (Value is the value returned by the eval env exp function)
05:05:27 <ski> Twey : confusingly masqueraded as a type signature (and i still don't know whether `fac 5' was one argument or two separate arguments)
05:06:36 <deteego> Twey: it was just an example
05:06:41 <foolcraft> let a = [[a,b,c,d,e] | [a,b,c,d,e] <- possible5, tail [a,b,c,d,e] fst [a,b,c,d,e] `notElem` a]
05:06:44 <deteego> I just posted the function that I meant
05:06:47 <foolcraft> sorry about the earlier zip
05:06:52 <foolcraft> (it was wrong and I get why now)
05:06:58 <ski> deteego : btw, the brackets after `App e1 e2 -> ' are not needed
05:07:02 <foolcraft> it still doesn't work, but it makes more sense now
05:07:15 <mm_freak> > let perms = permutations "abc" in nubBy (\x y -> x `elem` perms) ["def", "abc", "acb", "def", "eee"]
05:07:16 <lambdabot>   ["def","def","eee"]
05:07:30 <mm_freak> uhm
05:07:30 <deteego> ski: thanks, I didn't clean up the code yet
05:07:34 <mm_freak> not quite
05:08:27 <Jonno_FTW> foolcraft: you can't define a function called a, if a is a variable in the function
05:08:28 <ski> deteego : .. so it appears this evaluates the arguments of a top-level (curried) application, giving the results in a list
05:09:08 <ski> (Jonno_FTW : why not ?)
05:09:21 <mm_freak> > nubBy (\x y -> let sx = sort x in if sx == "abc" then sx == sort y else False) $ ["eee", "abc", "acb", "eee", "fff"]
05:09:22 <lambdabot>   ["eee","abc","eee","fff"]
05:09:26 <mm_freak> there you go
05:09:43 <deteego> ski: yes
05:09:53 <mm_freak> @ foolcraft 
05:09:57 <Martty> > permutations "test"
05:09:58 <lambdabot>   ["test","etst","sett","estt","stet","tset","tset","stet","sett","test","ets...
05:10:11 <mm_freak> bss03: try to implement it
05:10:12 <ski> foolcraft : i think `tail [a,b,c,d,e] fst [a,b,c,d,e]' doesn't make sense
05:10:16 <mm_freak> eventually you'll see what i mean
05:10:17 <Jonno_FTW> > let a = [a+5] in a
05:10:18 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
05:11:25 <ski> deteego : so .. maybe `evalAppExprs' or something ?
05:11:37 <deteego> well I called it liftApp
05:11:50 <deteego> I guess I can use evalLiftApp
05:11:59 * ski doesn't really see how it does any "lifting"
05:12:04 <deteego> (lift implying it lifts it out of the recursive expression and puts it into a list)
05:12:18 <deteego> although lifting is a term used for monads
05:12:22 <deteego> *sighs*
05:12:42 <ski> (well, applicative functors, as well)
05:12:53 <ski> @type liftA2
05:12:54 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
05:13:05 <deteego> yeah thats true
05:13:09 <Twey> We should rename fmap to liftF
05:13:10 <mm_freak> for all functors in fact
05:13:14 <mm_freak> :t fmap
05:13:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:13:16 <deteego> but anyways, does that process have a term
05:13:30 <deteego> its not lifting
05:13:42 <ski> deteego : not that i can think of .. what are you using this for ?
05:13:53 <deteego> its like flattening a recursive expression into a list (while evaluating)
05:13:59 <deteego> kind of like iterate
05:14:06 <mm_freak> deteego: i'd call it runApp or evalApp
05:14:06 <deteego> ski: its actually a uni assignment
05:14:09 <ski> not really like `iterate', imo
05:14:20 <Jonno_FTW> :t iterate
05:14:21 <deteego> well its already obvious its evaluating
05:14:21 <lambdabot> forall a. (a -> a) -> a -> [a]
05:14:25 <mm_freak> at least it looks like something like that
05:14:41 <mm_freak> well
05:14:43 <ski> deteego : it's an uni assignment to implement this function, *and* to invent a name for it ?
05:14:44 <mm_freak> flattenApp =)
05:14:52 <deteego> ski: no its not, but I am being pedantic
05:15:03 <foolcraft> hmm I think it shouldn't be in the permutations...
05:15:06 <deteego> I was just curious
05:15:08 <foolcraft> or take out one from the permutations
05:15:12 <ski> i'm just wondering for what you want to use this function
05:15:14 <foolcraft> what's the package for permuting lists
05:15:21 <ski> (that might suggest a better name, namely)
05:15:27 <mm_freak> foolcraft: it's in base in the Data.List module
05:15:28 <deteego> ski: well I get a closure from the environment, but its in a list form
05:15:35 <mm_freak> foolcraft: but you don't really need permutations
05:15:41 <deteego> ski: however the AST for function App is a recursive data type
05:15:41 <mm_freak> you just need sorting, which is in Data.List, too
05:15:55 <deteego> ski: so this functions flattens while evaluation the recursive data type
05:15:57 <mm_freak> > permutations "abc"
05:15:58 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
05:16:02 <mm_freak> > sort "cba"
05:16:03 <lambdabot>   "abc"
05:16:13 <deteego> ski: so I can easily zip the arguments in the closure with the function application
05:16:22 <mm_freak> > sort "abc" == sort "cba"
05:16:23 <lambdabot>   True
05:16:45 <mm_freak> foolcraft: look at the code sample above
05:16:53 <ski> deteego : what if the closure accepts (for the moment) three arguments, but is applied to four ?
05:17:14 <deteego> ski: its invalid (type checker will pick that up)
05:17:21 <mm_freak> foolcraft: the 'nub' function removes duplicate elements, and i'm using nubBy, which takes a custom comparison function
05:17:23 <ski> > foldr ((.) . (:)) id "abcd" ""
05:17:24 <lambdabot>   "abcd"
05:17:29 <deteego> if you have a function with 3 arguments, closure will have 3 arguments
05:17:32 <mm_freak> > nub "abbcdccaabbbe"
05:17:33 <lambdabot>   "abcde"
05:17:38 <deteego> and when you do a function application it will require 3 argumentsw
05:17:40 <deteego> *arguents
05:17:43 <deteego> *arguments
05:17:56 <ski> deteego : what if you define something like `foo x y z = \w -> ...' ?
05:18:10 <mm_freak> i say that if one element is a permutation of "abc", then the two elements are equal, if they are permutations of the same string
05:18:17 <mm_freak> if not, then they never are equal
05:18:20 <deteego> ski: this isn't haskell im parsing, its a basterdised version of a haskell/ML hybrid
05:18:30 <mm_freak> > nubBy (\x y -> let sx = sort x in if sx == "abc" then sx == sort y else False) $ ["eee", "abc", "acb", "eee", "fff"]
05:18:31 <lambdabot>   ["eee","abc","eee","fff"]
05:18:41 <deteego> ski: I mean I can show you the assignment language if you are interested
05:18:55 <ski> deteego : so, if arguments are tupled, why not `App :: Exp -> [Exp] -> Exp', rather than `App :: Exp -> Exp -> Exp' ?
05:19:12 <ski> deteego : sure
05:19:16 <deteego> no App represents the AST
05:19:25 <deteego> it has nothing to do with the static semantics
05:19:36 <deteego> minhs: exp1 : App (Var (Id "eq" 2025572021)) (Num 3) exp2: Num 4
05:19:52 <deteego> thats an example of what an application would look like (this is the AST)
05:20:29 <bss03> mm_freak: This seems to compile http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29828 and I think it does what I want.
05:22:11 <mm_freak> bss03: why are you passing an IORef instead of the value itself?
05:22:31 <bss03> So I can modify it.
05:23:12 <mm_freak> bss03: pass it as an argument
05:23:17 <kremsera> hi, im trying to use 2 monads at once, which fails for me completely : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29829
05:23:19 <mm_freak> then you can still modify it
05:23:32 <kremsera> are there special tricks needed to "combine" monads?
05:23:48 <bss03> The modification has to stick for next time the api calls partially applied g.
05:24:31 <bss03> kremsera: The MTL seems a descent way.  Requires some GHC extensions to Haskell, but StateT and the like worked well for me.
05:24:50 <mm_freak> bss03: the IORef is lost, as soon as your hidden_state_fn finishes
05:25:02 <bss03> mm_freak: That's fine.
05:25:22 <bss03> mm_freak: The important thing is that is exists thorugh the call to "api".
05:25:26 <kremsera> bss03, it doesnt work with Control.Monat.Trans.State either :(
05:25:32 <mm_freak> kremsera: the usual way to combine monads is to use monad transformers
05:25:42 <mm_freak> kremsera: but look at your code, it doesn't make much sense
05:25:42 <bss03> "api" calls the function I pass into it multiple times.
05:25:43 <deteego> kamatsu: another question on the message board
05:26:01 <mm_freak> kremsera: you're dealing with 'nn' like it were an ordinary function, but it's not
05:26:24 <kremsera> mm_freak, well its a simple example demonstrating my lack of monad understanding ;)
05:26:48 <mm_freak> bss03: unless you're dealing with an opaque API, which absolutely needs an IORef, you can always get along without it
05:27:23 <bss03> Well, I have an opaque API that needs a (a -> IO ()) and I need to maintain state between those different calls to the function I provide.
05:27:32 <mm_freak> kremsera: but wait, it might be my mistake, it is in fact a normal function =)
05:27:41 <bss03> I can't use StateT or similar directly.
05:27:53 <mm_freak> kremsera: give your functions type signatures, and better give them type signatures, /before/ you write them
05:28:14 <mm_freak> bss03: i see
05:28:33 <bss03> Heck, @djinn's older brothers can derive function bodies as long as you give a good type annotation.
05:29:02 <bss03> mm_freak: So, is IORef the best way to go, or would it be better to use MVar or something else?
05:29:09 <mm_freak> @djinn Either e a -> Maybe a
05:29:09 <lambdabot> f a =
05:29:09 <lambdabot>     case a of
05:29:09 <lambdabot>     Left _ -> Nothing
05:29:09 <lambdabot>     Right b -> Just b
05:29:26 <bss03> mm_freak: I figured I could hide state fairly well since I'm already in IO.
05:29:40 <mm_freak> bss03: i don't know your application…  personally i try to avoid IORef as much as possible, but if it's the simplest option, use it
05:29:56 <mm_freak> IO is not meant to hide state
05:30:04 <mm_freak> it's meant to do imperative/effectful stuff
05:30:46 <mm_freak> in fact i don't know a way to hide state with IO alone without using global variables or opaque types containing IORefs
05:30:54 <bss03> mm_freak: Well, as far as the API I'm dealing with is concerned the state of my function might as well be part of the "System".
05:31:12 <mm_freak> also "hiding" state means not having to pass it to me…  it doesn't mean it disappears from the type signature
05:31:18 <bss03> mm_freak: Since I'm already in IO, I could serialize/deserialize state to files, for example.
05:31:43 <ski> deteego : ok, so this appears to be Bonus 1
05:32:07 <bss03> mm_freak: But, in this case, I'm not sure I'll have a writable filesystem available. :/  So, I need to serialize/deserialize to RAM. ;)
05:32:42 <mm_freak> bss03: that's quite a dirty way to do it…  just writing it in C with a global variable sounds safer ;)
05:33:33 <bss03> What makes IORef unsafe, just for my own enlightenment?
05:33:48 <bss03> I didn't see an unsafe* function like with the ST module.
05:34:11 <mm_freak> well, it's classic imperative BASIC style coding
05:34:21 <mm_freak> that's what makes it unsafe =)
05:34:54 <ski> deteego : i don't see a specification that in `letfun foo :: (tau_0 -> ... -> tau_{n-1} -> tau_n) x_0 ... x_{m-1} = e', `m' has to be equal to `n', afaik, `m' could well be non-greater than `n'
05:35:28 <deteego> ski: what are you going on about
05:35:38 <deteego> ski: this in regards to implementing n-ary functions
05:35:49 <ski> deteego : page 7, 3.1 `n'-ary functions
05:35:55 <mm_freak> mutable ~ immutable like goto ~ while
05:36:04 <mm_freak> in terms of safety
05:36:23 <mm_freak> it's not "unsafe" by itself, but humans make it unsafe =)
05:36:36 <deteego> ski: oh right, that is in the concrete syntax grammer
05:36:41 <deteego> ski: which isn't in that pdf
05:36:58 <deteego> ski: and I honestly cbf finding it
05:37:27 * ski wonders what "cbf" could be meaning
05:37:34 <deteego> ski: we dont have tuples in this language anyways
05:37:52 <deteego> there are only 2 types, int/bool, and they can't be tupled
05:41:10 <ski> deteego : yeah i see. but i still don't see why e.g. `letfun f :: (Int -> Int -> Int) x = if x == 0 then (letfun g :: (Int -> Int) y = y) else (letfun g :: (Int -> Int) y = if y == 0 then f (x-1) (x*x) else 1 + g x (y-1))' would be invalid
05:42:02 <bss03> mm_freak: I'll keep that in mind.  Still, I think this usage is fairly safe.
05:42:33 <ski> deteego : also, even if that is disallowed, if we have `f :: Int -> Int -> Int', and also `foo :: (Int -> Int) -> Int', why would `foo (f 42)' be invalid ?
05:42:52 <deteego> there isn't any currying in this language
05:43:07 <ski> what disallows that ?
05:43:24 <deteego> actually sorry my bad
05:43:32 <deteego> (int -> int) goes down into a closure
05:43:35 <deteego> as a single argument
05:43:43 <deteego> so it still resolves down to 2 arguments in the AST
05:43:46 <deteego> which is what we deal with
05:44:01 <deteego> (Int -> Int) is the first argument, Int is the second
05:44:14 <ski> `letfun sum :: (Int -> Int -> bool) x y = x == y' (an example from the paper) seems to construct a curried function to me
05:44:28 <ski> (s/bool/Bool/)
05:44:30 <yaxu> i'm trying to upgrade to the latest haskell platform, but configure tells me to upgrade ghc to 6.12.3 .  When I go to the ghc download page it recommends installing the haskell platform _instead_ of ghc
05:44:45 <deteego> I mean doing something like Int (Int -> Bool) -> Int
05:44:53 <deteego> or (Int -> Bool) -> Bool
05:45:00 <yaxu> is this trying to teach me recursion?
05:45:02 <deteego> (Int -> Bool -> Bool) is fine
05:45:27 <ski> deteego : and i would say `Int -> Bool -> Bool' is the type of a (perhaps trivially) curried function
05:45:46 <yaxu> i've got ghc 6.10.4 by the way
05:45:46 <deteego> well yes it is
05:45:53 <deteego> look it passed the test cases
05:45:57 <deteego> so w/e
05:46:44 <ski> deteego : the two questions about things like `Int -> Bool -> Bool' is :
05:46:48 <ski> deteego : (a) is it allowed to say `letfun f :: (Int -> Bool -> Bool) x = ...', i.e. only to expect some of the arguments of the function, letting `...' itself be a function expression ?
05:47:37 <ski> Deewiant (b) is it allowed to apply such a function `f' of type `Int -> Bool -> Bool' to only some of the "expected arguments", passing the result on to another function (which can provide the rest of the arguments), like `foo (f 42)'
05:47:41 <ski> er
05:47:55 <yaxu> ok, uninstalled ghc, and now the problem is getting clearer
05:47:55 <ski> s/Deewiant/deteego/
05:48:25 <yaxu> "This installer for the Haskell Platform requires ghc to be installed first" vs "The current Haskell Platform release includes a recent GHC release"
05:49:35 * yaxu decides to ignore ghc and install it from tarball
05:50:10 <ski> deteego : in the absense of any documentation disallowing those two things, i would assume that both are allowed, and so you can't expect that the number of formal parameters of a closure will match the number of actual parameters in an appliction .. the former may be lesser, equal to, or greater than the latter
05:50:46 <deteego> ski: we have test cases that mark the assignment and the example passed all
05:50:50 <ski> ok
05:51:15 <deteego> I cant see how untrivially curried functions even work in this language
05:51:23 <ski> (i wouldn't be satisfied unless i was satisfied with the design myself, by ymmv :)
05:51:25 <deteego> due to not having first class functions as types
05:52:04 <yaxu> I probably shouldn't be upgrading ghc the day before I present my software at anglohaskell, though
05:52:06 <ski> deteego : well, the spec says you *do* have things like `(Int -> Bool) -> (Int -> Bool)'
05:52:58 <ski> (apart from that, i'm not sure what you could mean by "having first class functions as types")
05:53:24 <deteego> ski: uh no it doesn;t
05:53:41 <deteego> ski: I don't see a single example of a function like (Int -> Bool) -> (Int -> Bool)
05:55:24 <ski> deteego : "MinHs is a spartan language. We only have to consider 3 types: `Int', `Bool', `t1 -> t2'", that suggests to me that `t1' and `t2' in the function type there could be any type expressions (including function types)
05:56:30 <ski> deteego : and then they go on talking about types like `Int -> Int -> Bool' (i.e., presumably `Int -> (Int -> Bool)'), so i would be very surprised if they didn't mean to include things like `(Int -> Bool) -> Bool', as well
05:57:21 <deteego> ski: why are you arguing with me, curried functions arent in the spec
05:57:22 <ski> (i mean they go on talking about types like `Int -> Int -> Bool' without saying anything special, so i ...)
05:57:55 <ski> deteego : afaict, curried functions are in the spec as soon as you allow types like `t1 -> t2', where `t1' and `t2' can also be of that form
05:57:59 <deteego> deadguys: also
05:58:01 <deteego> it doesn't parse
05:58:12 <deteego> so its DEFINITLY SOMETHING WE DONT NEED TO TAKE INTO ACCOUNT
05:58:36 <ski> i'm sorry if i'm annoying you. i can just go from what the spec talks about
05:58:53 <deteego> I told you there is a concrete grammer syntax we have
05:58:55 <ski> (i would go complain to the TA about ambiguous spec)
05:59:05 <deteego> and curried functions are not defined in the concrete syntax
05:59:16 <deteego> so they definitly can't be defined in the dynamntic semantics of the language
05:59:37 <deteego> *dynamic
05:59:48 <JuanDaugherty> TA?
06:00:08 <zygoloid> yaxu: the problem you're seeing is that building GHC requires GHC. can you use a binary tarball?
06:00:22 <ski> i would be very suprised if they were in the concrete syntax, since "curried functions" is not a local property of the grammar .. you can't just look at the individual rules of the grammar to say "there's the rule for curried functions", it doesn't work like that
06:00:37 <ski> ("TA" being "Teaching Assistant")
06:00:51 <deteego> in our concrete grammer, function decleration is defined something along the lines of
06:00:55 <JuanDaugherty> i thought so, but didn't seem to make contextual sense
06:01:01 <ray> ta being whoever actually teaches the class
06:01:05 <deteego> funcName = (type...types)
06:01:47 <deteego> ski: I just tried an example with tuples, there was a parser error on the right bracket
06:01:48 <JuanDaugherty> (since I thought implementing haskell 2010 or the like was being discussed)
06:02:44 * ski hasn't been talking about tuples for a long time
06:02:53 <zygoloid> deteego: a -> b -> c is curried, (a, b) -> c is not curried. it looks to me like you're thinking of them the other way around?
06:02:54 * hackagebot hyahtzee 0.2 - A Yahtzee game implementation in Haskell  http://hackage.haskell.org/package/hyahtzee-0.2 (DamienCassou)
06:03:23 <yaxu> zygoloid: no that's the message on the webpage for downloading both binaries and source
06:03:29 <deteego> zygoloid: eh I need a break
06:03:29 <yaxu> I've got a binary tarball now anyways
06:04:12 <zygoloid> cool :) what are you presenting at anglohaskell, btw?
06:04:36 <kremsera> omg i hate monads !
06:04:39 <yaxu> my system for improvising music with haskell
06:05:14 <zygoloid> the livecoding thing? neat
06:05:16 <deteego> kremsera: monads are sex, with the container being LOOOOOVEEEE
06:05:31 * zygoloid is looking forward to it :)
06:06:19 <zygoloid> deteego: with (>>=) being transitivity of love? "if I love A, and A loves B, then I love B" ?
06:06:46 <kremsera> deteego, children only possible with unsafePerformSex?
06:06:47 <yaxu> zygoloid: yes, if I can get it working again :)
06:07:24 <yaxu> i just realised I still haven't released the source, so trying to do that now...
06:07:33 <zygoloid> kremsera: nah, the encapsulation of the love monad is a leaky abstraction. sometimes you get kids even if you never unsafePerformSex :)
06:08:06 <zygoloid> yaxu: yeah, i was thinking i should upload my code to hackage if i'm going to do a functional grit on it
06:08:25 <kremsera> zygoloid, so the pope was right
06:17:50 <ccasin> any tagsoup experts?  (~== TagOpen "a" [("onmouseout","")]) should match any <a> tag with an "onmouseout" attribute, right?
06:23:56 <obbele> ccasin: what about flip (~==) "<a onmouseout>" ?
06:27:35 <ccasin> obbele: sure that makes sense too.  Only neither seems to work for me :)
06:28:14 <obbele> ccasin: it works for me, but I may have misunderstand what you want
06:28:42 <ccasin> hmm, they should match any tag of the form <a ... onmouseout="..." ...>, right?
06:28:51 <obbele> yes
06:29:05 <obbele> I get  "flip (~==) "<a onmouseout>" (TagOpen "a" [("onmouseout", "")])" == True
06:29:17 <obbele> and flip (~==) "<a onmouseout>" (TagOpen "a" []) == False 
06:29:20 <obbele> one my ghci prompt
06:30:43 <ccasin> me too.  but for some reason they aren't working correctly in my more complicated real-life example
06:30:46 <ccasin> let me see if I can distill it
06:31:01 <obbele> yeah, I got a problem with type inference
06:31:15 <obbele> something like "Ambiguous type variable `str' in the constraint: `Text.StringLike.StringLike str'
06:33:20 <zygoloid> filter (~== "<a onmouseover>") (parseTags "<html><body><a>Foo</a><b>Bar</b><a onmouseover='whee'>Whoo</a></body>")
06:33:23 <zygoloid> ^^ this works for me.
06:33:34 <zygoloid> [TagOpen "a" [("onmouseover","whee")]]
06:33:39 <obbele> (and for correctness, (flip (~==) "<a onmouseout>") could be rewritten (~== "<a onmouseout>") )
06:35:09 <obbele> by the way, any one know how to generate haddock documentation for function generate by C2HS #fun hook ?
06:36:23 <ccasin> obbele and zygoloid: thanks for the help.  these examples work for me too, so there must be something else going on in my larger development
06:38:18 <obbele> ccasin: you're welcome, hope you find a solution
06:40:03 <atude> does anyone know q-analogs?
06:43:00 <yaxu> I'm having problems getting cabal to see the modules I have installed.  I've added 'hosc' to my build-depends, and it keeps saying "hosc -any" is missing, despite it being freshly reinstalled
06:43:28 <yaxu> could this be due to stuff being left around from a previous ghc install?  if so, what do I need to wipe?
06:44:21 <yaxu> ah, "cabal --global install hosc" fixed it
06:44:56 <kremsera> seems like --global is the way to go. always
06:45:18 <Saizan> please, no.
06:45:43 <kremsera> most packages won`t install for me without --global
06:45:49 <dcoutts> kremsera: I'd suggest the opposite actually
06:45:49 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
06:45:49 <Twey> You're doing it wrong
06:46:01 <dcoutts> the default user install should work fine
06:46:02 <Twey> Are you mixing cabal install with a distro's package manager?
06:46:03 <Saizan> well, maybe if you're careful about never upgrading any core package..
06:46:33 <kremsera> no the distro does not provide any haskell stuff
06:46:41 <dcoutts> kremsera: perhaps you could explain the problem
06:47:34 <Saizan> yaxu: if you ran cabal install with --dry-run -v it should've told you why it excluded the hosc you had installed
06:47:35 <kremsera> packages like accelerate dont resolve the dependencies correctly or at all
06:47:49 <Saizan> yaxu: probably because it was incompatible with something else in your user instal
06:48:01 <kremsera> or c2hs
06:48:09 <Saizan> *user installed packages
06:48:09 <yaxu> Saizan: could the problem be me doing runhaskell Setup.hs instead of using cabal?
06:48:38 <Saizan> yaxu: runhaskell Setup uses --global by default, so it won't see packages in the userdb without --user
06:48:54 <yaxu> I see, thanks
06:49:00 <dcoutts> kremsera: we'll need more details, since it works for the rest of us, e.g. what command you ran and what error happened.
06:49:52 <kremsera> dcoutts, i ran "cabal install accelerate", "cabal install c2hs" - both failed without --global
06:50:15 <kremsera> both on debian lenny with distro packages - and on opensuse without distro packages
06:50:24 <dcoutts> kremsera: have you been using sudo cabal install btw?
06:50:51 <Saizan> kremsera: failed with which error?
06:51:03 <kremsera> dcoutts, hmm i dont know anymore 
06:51:50 <dcoutts> kremsera: perhaps you can run cabal install c2hs again and paste the log somewhere
06:53:21 <kremsera> dcoutts, okay i found the problem again
06:53:44 <kremsera> dcoutts, when installing without --global - other packages dont see c2hs
06:54:54 <dcoutts> kremsera: ah, this will be a $PATH issue
06:55:06 <dcoutts> you don't have ~/.cabal/bin on your $PATH
06:55:24 <dcoutts> alternatively you can configure cabal to add symlinks into ~/bin
06:55:34 <dcoutts> see symlink-bindir in ~/.cabal/config
06:55:52 <Saizan> dcoutts: btw, i was wondering if we shouldn't add the executable install dirs to cabal's search path for programs by default
06:56:04 <kremsera> oh thx
06:56:06 <kremsera> that fixed it :D
06:56:18 <kremsera> lol - that was fast
06:56:56 <dcoutts> Saizan: yeah we should, there's an open ticket on it. It's slightly harder than it looks because the information plumbing doesn't make it easy to pass extra info at the point needed.
06:57:24 <Saizan> dcoutts: ah, i thought so
06:57:38 <dcoutts> Saizan: and we should make it add symlinks to ~/bin by default if it exists and is on the $PATH, or some other first-time config thing
07:06:44 <MasseR> How do I print out 'raw' output such as terminal color sequences? (Or better yet, if there's a simple library for it)
07:07:04 <wli> Print in what sense? On paper?
07:07:09 <MasseR> wli: stdout
07:07:31 <wli> Well, there are raw modes for tty/pty affairs.
07:07:58 <wli> hscurses or something might have something for it.
07:08:15 <MasseR> I think hscurses would be way overboard
07:08:49 <wli> Well, it clearly has much more, but getting the tty/pty into raw mode wants some syscall wrapper.
07:09:45 <MasseR> wli: ? In c it's as simple as printf("\033[34mfoobar\033[0m\n");
07:09:50 <kmc> MasseR, you can do that in Haskell too
07:09:59 <kmc> you might need to use binary IO mode
07:10:06 <kmc> of course that's not portable across different terminals etc
07:10:27 <MasseR> kmc: In this case my needs are "one-off" (RPROMPT for zsh, battery status)
07:10:38 <wli> That's why you use curses wrappers.
07:10:40 <MasseR> kmc: I'll look into binary mode
07:10:40 <kmc> should be fine then
07:11:01 <kmc> hSetBinaryMode stdout True
07:11:02 <kmc> or so
07:11:12 <kmc> if that fails, use ByteString IO
07:11:57 <MasseR> Binarymode failed, testing bytestring
07:12:59 <dcoutts> failed in what sense?
07:13:14 <MasseR> ![34mfoobar![0m <- in that sense :)
07:13:39 <dcoutts> and what is that?
07:13:43 <wli> You're supposed to ue stuff like tcsendbreak() for that kind of stuff.
07:14:15 <MasseR> dcoutts: The same string in C prints blue text
07:14:42 <dcoutts> MasseR: binary mode is pretty simple, it just outputs the 8bit byte of each char
07:15:14 <dcoutts> there's not a lot to fail, if you check the output I'm pretty sure you'll find it does output exactly the bytes you told it to
07:15:22 <kmc> yeah, try hexdump on the output
07:15:32 <dcoutts> if you're using TTY control codes then perhaps you need to look into how to set that up
07:16:07 <wli> I'm guessing it's a VT100/VT220/etc. escape sequence.
07:16:37 <MasseR> dcoutts: The same string sequence in C and haskell produce different hexdumps
07:16:46 <wli> Maybe not if it's color control codes.
07:16:50 <dcoutts> perhaps it's not the same string
07:17:04 <MasseR> dcoutts: Inside the "" it is. Not sure internally
07:17:11 <dcoutts> MasseR: map toEnum
07:17:23 <dcoutts> to see the integer values
07:17:38 <dcoutts> erm fromEnum
07:17:44 <wli> ord/chr are around (ord to be used here, presumably).
07:17:52 <dcoutts> > map fromEnum "![34mfoobar![0m"
07:17:52 <lambdabot>   [33,91,51,52,109,102,111,111,98,97,114,33,91,48,109]
07:19:08 <MasseR> dcoutts: The original string is "\033[34mfoobar\033[0m\n"
07:19:23 <dcoutts> MasseR: then use the appropriate escape codes
07:19:54 <wli> > map ord "\033[34mfoobar\033[0m\n"
07:19:54 <lambdabot>   [33,91,51,52,109,102,111,111,98,97,114,33,91,48,109,10]
07:20:39 <MasseR> I get the same output. How does that help me?
07:20:49 <maurer_> Is there a function similar to mapM_ that will gaurantee me the IO actions are sequenced in order?
07:20:56 <wli> \033 isn't what MasseR expects.
07:21:44 <maurer_> I've got a program that acts on many noninteracting files, and am currently using mapM to execute on each of them, but I get a huge memory leak (program tries to use more than 8 gigs of RAM) if I pass the program a large number of files.
07:21:50 <dcoutts> MasseR: are you sure that's the right control code? when I echo that to the terminal it prints literally, no colours.
07:22:11 <kremsera> it works for me - prints blue in c++
07:22:13 <maurer_> I was hoping to make sure the IO acitons get forced sequentially so that there isn't alot of partially executed IO
07:22:17 <MasseR> dcoutts: Yep works here
07:22:22 <maurer_> *actions
07:22:25 <MasseR> dcoutts: "echo -e "
07:22:35 <Saizan> maurer_: mapM_ will make the actions run in order, it doesn't touch the results of those actions though
07:22:46 <dcoutts> MasseR: like this? echo -e '![34mfoobar![0m'
07:22:53 <MasseR> dcoutts: You got the wrong string
07:22:57 <MasseR> Look for the one with \033
07:23:05 <dcoutts> \033 is !
07:23:16 <MasseR> \033[34mfoobar\033[0m\n
07:23:35 <Igloo> 33 octal, not dec
07:23:41 <Saizan> maurer_: but you can make the actions themselves more strict on what they are reading/producing
07:23:58 <maurer_> Saizan: Hm. Not sure what to do then. My situation is I've got "expensiveAction" which doesn't normally use up memory, and does a little bit of IO after calling some pure functions, and I've got a long list of files. "mapM_ expensiveAction files" memory overflows, but for i in *; do progName $i; done is fine.
07:24:01 <MasseR> dcoutts: Do try echo -e "\033[34mfoobar\033[0m\n" it should work. Does on urxvt anyway
07:24:25 <dcoutts> MasseR: ahh so it's hex vs octal
07:24:49 <maurer_> maurer_: Is it not possible to wrap a strictness chunk around each expensiveAction so that within expensiveAction it is lazy, but it has to complete all things within expensiveAction before starting to compute the next one?
07:25:10 <dcoutts> > toEnum 0o033 :: Char
07:25:11 <lambdabot>   '\ESC'
07:25:13 <Saizan> maurer_: it does have to complete all of its side effects already.
07:25:13 <dcoutts> > toEnum 0x033 :: Char
07:25:14 <lambdabot>   '3'
07:25:18 <dcoutts> > toEnum 0x33 :: Char
07:25:19 <lambdabot>   '3'
07:25:35 <Saizan> maurer_: and since mapM_ discards the result it should get garbage collected..
07:25:51 <dcoutts> erm
07:25:53 <dcoutts> > toEnum 33 :: Char
07:25:54 <lambdabot>   '!'
07:26:04 <kremsera> putStr  "\027[34mfoobar\027[0m\n"
07:26:07 <pao> is there a way to hide instance declaration carried into scope by import?
07:26:12 <kremsera> works
07:26:14 <dcoutts> MasseR: so you mean "\o033[34mfoobar\o033[0m\n"
07:26:17 <Saizan> pao: no
07:26:26 <maurer_> Saizan: Then I have no clue how this is happening (the last action in expensiveAction requires it to execute another program that acts on a file it wrote out). Any suggestions as to why I get a space leak here?
07:26:29 <MasseR> dcoutts: kremsera I'll test
07:26:46 <maurer_> Or a technique I could use to track it down?
07:27:11 <Saizan> maurer_: you could use heap profiling
07:27:12 <MasseR> dcoutts: Apparently I do mean \o033 yes. kremsera Thanks. And to whoever figured it was octal, thanks
07:27:12 <pao> Saizan, this means that if HTTP package export a overlapping instance (mtl vs transformers) I cannot do anything better than switching http client library... correct?
07:27:15 <int-e> > "\ESC\o033\x1b\x1B\27"
07:27:16 <lambdabot>   "\ESC\ESC\ESC\ESC\ESC"
07:27:20 <MasseR> And thanks to dcoutts ofcourse too
07:27:32 <dcoutts> MasseR: the Haskell escape codes for text strings are ['\o33', '\33', '\x33'] for octal, dec, hex
07:28:01 <jmcarthur> is there a way to make ghc automatically strip the binary after linking?
07:28:06 <Saizan> pao: which instance is this?
07:28:12 <dcoutts> jmcarthur: cabal will do that on install
07:28:33 <maurer_> Saizan: OK
07:28:35 <dcoutts> jmcarthur: otherwise the answer is no, though you might be able to pass a linker flag through that does it
07:28:42 <jmcarthur> dcoutts: i'm looking for a way to do it just upon `cabal build' rather than `cabal install'
07:28:43 <jmcarthur> ah
07:28:54 <jmcarthur> thanks
07:28:56 <dcoutts> jmcarthur: any particular reason ooi?
07:29:27 <int-e> jmcarthur: -optl-s
07:29:54 <pao> Saizan,  instance Monad (Either e)
07:29:59 <jmcarthur> dcoutts: participating in ai-contest.com, trying to convince them to allow binaries so i can use a modern version of ghc (they already accept and compile arbitrary C to run in a sandbox, so i think this is no big deal). just trying to make it convenient to keep the binaries small so that they don't take too much bandwidth
07:30:09 <int-e> (in other words, tell the linker to produce a stripped binary)
07:30:12 <jmcarthur> int-e: rock! thanks
07:30:22 <jmcarthur> int-e: i was looking at the ld manpage but couldn't find anything
07:30:52 <dcoutts> jmcarthur: you know you can cabal copy --destdir=./image
07:31:22 <dcoutts> e.g. configure with --prefix=.
07:31:38 <dcoutts> or ""
07:31:47 <Saizan> pao: i guess so, you either avoid HTTP or transformers
07:32:23 <Saizan> pao: or you try to be very careful about which modules you import, assuming that instance is only in Control.Monad.Error
07:33:29 <pao> Saizan, yep
07:34:05 <pao> Saizan, another question ... :-)
07:34:27 <pao> Saizan, the main monad stack in my toy project was ErrorT String IO a
07:34:46 <jmcarthur> dcoutts: the binary is the only thing i'm submitting, so there isn't really any other directory structure that i care about. on that note, since i have to zip and upload the binary anyway, i guess just adding a call to strip in the script for that wouldn't have been bad anyway
07:34:59 <pao> Saizan, is that correct that with extensible exception the way to go is to use Control.Exception instead of ErrorT?
07:36:11 <pao> I'm starting thinking that my use of ErrorT was a bit misguided :-)
07:36:26 <jmcarthur> thanks guys
07:37:04 <Saizan> i haven't considered that before, though i guess ErrorT IO is a bit redundant now
07:37:41 <McManiaC> can you define application instances for arrows?
07:37:51 <McManiaC> *applicative
07:37:55 <Saizan> unless you want to keep the catcher separate
07:38:00 <Saizan> *catchers
07:39:08 <pao> Saizan, thanks
07:39:24 * hackagebot rbr 0.8.6 - Mask nucleotide (EST) sequences in Fasta format  http://hackage.haskell.org/package/rbr-0.8.6 (KetilMalde)
07:50:27 <pao> ok
07:50:28 * hackagebot netclock 0.1 - Netclock protocol  http://hackage.haskell.org/package/netclock-0.1 (AlexMcLean)
07:50:44 <pao> can anyone suggest a good alternative to HTTP (the package)? :-)
07:52:31 <bss03> @type (!)
07:52:32 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
07:52:38 <bss03> @type (!!)
07:52:39 <lambdabot> forall a. [a] -> Int -> a
07:55:30 * hackagebot list-tries 0.3 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.3 (MattiNiemenmaa)
07:58:12 <bss03> jmcarthur: You here?
07:58:34 <jmcarthur> bss03: hey
07:58:36 <jmcarthur> what's up?
07:59:15 <bss03> Is it fine to take the Java starter package, translate the Java to Haskell, and include that in your starter package?
07:59:27 <bss03> (Google AI Challenge)
08:00:02 <jmcarthur> bss03: well, the haskell starter on github is jaspervdj's, not mine
08:00:07 <jmcarthur> bss03: and that's fine
08:00:16 <jmcarthur> bss03: btw, #aichallenge :)
08:01:02 <bss03> jmcarthur: Is jaspervdj on IRC?
08:01:08 <jmcarthur> sometimes
08:01:15 <jmcarthur> he appears both here and in #aichallenge
08:05:07 <pao> http://paste.pocoo.org/show/259933/
08:05:30 <pao> Why ghc is asking for base 3 while I defined base 4 in project.cabal?
08:06:30 <int-e> pao: can you paste the cabal file?
08:07:52 <pao> int-e, http://paste.pocoo.org/show/259935/
08:09:52 <int-e> pao: odd. does  ghc-pkg find-module Control.Monad  find it? does ghc-pkg check complain about anything?
08:10:58 <lispy> pao: did you give an upper bound on base in your cabal file?
08:11:16 <int-e> lispy: base == 4.*
08:11:19 <lispy> oh, sorry didn't see that you pasted your cabal file
08:11:36 <lispy> pao: sometimes cabal configrue -v will help
08:12:14 <pao> int-e, ghc-pkg finds that module in base-3.0.3.2 and base-4.2.0.2
08:12:15 <gwern> base issues are always fun...
08:12:35 <pao> int-e, no problem with ghc-pkg check
08:12:51 <pao> lispy, I have base == 4.*
08:12:51 <geheimdienst> yes, crank up the verbosity. it will tell you why it goes for base-3. i guess you're pulling in some package which pulls in base-3
08:13:34 * pao is trying with configure -v 4
08:13:48 <int-e> geheimdienst: except that the error message indicates that cabal did not select base-3. I'd assume that this means that it selected base-4.2.0.2.
08:14:11 <Nibble> is there something like read but for single characters?
08:14:30 <pao> selecting base-3.0.3.2 (installed) and 4.2.0.2 (installed)
08:15:08 <pao> how so?
08:15:13 <pao> why two bases?
08:15:18 <int-e> pao: cabal build -v should give you the ghc command line it used. that should contain a -package base-4.2.0.2
08:15:46 <int-e> pao: because base-3 is just a compatibility wrapper around base-4. there's a special hack in Cabal and cabal-install to allow this.
08:16:57 <pao> int-e: I confirm ghc -package-id points only to base-4.2.0.2-.....
08:18:06 <int-e> but of course it doesn not answer the question why ghc then doesn't find the module :/
08:18:31 <pao> this is driving me crazy
08:18:47 <int-e> which ghc version is that?
08:19:01 <pao> int-e 6.12.3
08:23:28 <pao> am I correct to think that this is a problem with ghc and not cabal?
08:23:33 <Saizan> pao: try cleaning the .hi files
08:24:01 <lispy> pao: I'm pretty sure -v only goes to 3 with cabal.
08:24:14 <dcoutts> and make sure there's no local module called Control.Monad
08:24:20 <pao> Saizan, already done (find . -name "*.hi" -or -name "*.o" -delete) + cabal clean
08:24:48 <pao> dcoutts, by local you mean in my source tree?
08:24:53 <lispy>  -v --verbose[=n]                  Control verbosity (n is 0--3, default
08:24:53 <lispy>                                    verbosity level is 1)
08:24:54 <dcoutts> pao: right
08:25:18 <lispy> (not sure what -v 4 will mean, I would do --verbose=3 if you want more verbosity)
08:25:37 <monochrom> ignore the message "selecting base-3.0.3.2 (installed) and 4.2.0.2 (installed)". It is printed 99% of the time.
08:26:16 <lispy> monochrom: add preference: base >= 4, and it will change to selecting base 4 :)
08:26:24 <pao> dcoutts, no Control.Monad... (I knew that, but we never know :-) )
08:26:29 * lispy did this and has had really good results
08:27:37 <nlogax> is there a way out of mazes of Eithers and Maybes like this? http://paste.pocoo.org/show/V6EhntABM1iB37SMFs6y/
08:28:01 <nlogax> i even skipped one of them, risking pattern match failure 
08:28:01 <Nibble> nlogax: most likely
08:28:15 <Nibble> I can't tell you a solution tho
08:28:24 <monochrom> lispy: I just tried. Does not do.
08:28:51 <pao> SOLVED
08:29:10 <pao> I remove all package imports and reverted to "standard" imports
08:29:13 <lispy> monochrom: did you put it in your ~/.cabal/config ?
08:29:16 <pao> *removed
08:29:37 <monochrom> I put it on the command line. cabal configure --user --preference='base>=4' -v
08:29:41 <lispy> monochrom: (it's also only a "preference" so I think package constraints override it in some scenarios an not others"
08:29:57 <monochrom> My point is the message is to be ignored.
08:30:28 <lispy> yeah, my point was different.  That you can change the default from base3 to base4
08:30:41 <lispy> (which helps and saves time later debugging)
08:31:49 <pao> thanks everyone for the help
08:31:56 <dcoutts> lispy: I really think that preference should not generally be needed
08:32:09 <dcoutts> lispy: if a package needs base 4 then it should specify it in the .cabal file
08:32:09 <monochrom> The message totally does not say which base will be used. It only says "found something already installed, will not download from hackage"
08:32:33 <geheimdienst> pao, you're welcome
08:33:06 <monochrom> narrowing down to base-4 happens at a later stage with a different message: "Dependency base ==4.2.0.2: using base-4.2.0.2"
08:33:07 <lispy> dcoutts: Right.  But, with the implicit logic of preferring base 3, a lot of ill-specified packages have been allowed to exist and get by.  Now that lots of things use base 4 it seems to be causing subtle problems.
08:33:36 <dcoutts> lispy: that heuristic only applies to only packages which never said if they could work with base 4
08:34:15 <dcoutts> lispy: as far as I can see the only sensible use is to more easily check if a package can build with base 4, when it'd normally default to version 3
08:34:18 <monochrom> This heuristic will disappear soon.
08:34:58 <lispy> dcoutts: Well, one thing it fixes is packages that will not build because cabal ignores --constraints that ask for base 4
08:35:25 <lispy> dcoutts: YMMV, but for me the preference base >= 4 helps things build
08:35:37 <lispy> and helps me ensure I'm getting the latest base instead of 3
08:35:43 <dcoutts> lispy: well perhaps packages that were already broken
08:36:16 <lispy> IMO, the bug is having cabal ignore constraints and prefer base 3.
08:37:08 <lispy> I've noticed similar weirdness with parsec and quickcheck
08:37:20 <dcoutts> like what?
08:37:27 <lispy> ignored constraints
08:37:59 <monochrom> perhaps he means --constraint
08:38:15 <lispy> Just 2 days ago or so I needed QC >= 2.  I typed, "cabal install QuickCheck" and get something in the 1.x line
08:38:20 <dcoutts> lispy: that's nothing to do with the package, --constraint="base >= whatever" is effectively ignored, but that's because base is special
08:38:35 <dcoutts> lispy: I'm pretty sure it works for all other packages
08:38:50 <dcoutts> lispy: right, nothing to do with constraints
08:39:04 <dcoutts> lispy: you asked for the "default" version of QC and got 1.x
08:39:17 <lispy> Why the special handling?
08:39:23 <dcoutts> because there's a preference for 1.x
08:39:27 <dcoutts> for QC specifically
08:39:28 <lispy> Other packages I'll get the latest version
08:39:32 <dcoutts> right
08:39:40 <lispy> And you don't think that's a bug?
08:39:41 <dcoutts> there's a set of global default prefs on hackage
08:39:42 <dcoutts> no
08:39:45 <dcoutts> it's a feature
08:39:59 <lispy> How can I as a user know that cabal is ignoring me?
08:40:14 <dcoutts> http://hackage.haskell.org/packages/archive/preferred-versions
08:40:37 <lispy> Is there a way I can tell cabal-install to ignore those?
08:40:41 <dcoutts> lispy: it's not ignoring you, you did not ask for QC2, you asked for the "default" / "best" / "recommended" version
08:40:53 <dcoutts> lispy: sure, cabal install 'quickcheck >= 2'
08:41:08 <lispy> No, I mean, I want cabal to pretend that file does not exist.
08:41:23 <monochrom> fork hackage.
08:41:33 <dcoutts> lispy: there's no feature to do that
08:41:46 <lispy> Or at least say, "WARNING:  Using non-standard behavior for package FOO."
08:42:17 <monochrom> "non-standard" is wrong.
08:42:32 <dcoutts> lispy: I'm happy to add a warning that you're getting the listed version not the latest because the package maintainer has recommended that version as the latest stable version.
08:42:33 <monochrom> This is correct: "WARNING: Using standard behaviour for package FOO"
08:42:51 <dcoutts> lispy: the "bug" is that the feature is not very visible
08:43:01 <lispy> the bug is the feature itself :)
08:43:01 <dcoutts> so it's counter to your expectations
08:43:06 <dcoutts> I disagree
08:43:27 <geheimdienst> ACTION recalls how he waltzed into #haskell saying something like "i installed quickcheck, but that hasn't been updated in years and is nearly undocumented ...". after some wondering what geheimdienst might be smoking, it turned out "cabal install quickcheck" is not enough because of the prefer file thingy. it's easily fixed by saying "cabal install "quickcheck>=2"". geheimdienst's reputation as a serious hardcore haskell bad-ass could never 
08:43:32 <dcoutts> lispy: it's important to be able to release expermental new versions on hackage without breaking everyone's systems
08:43:39 <geheimdienst> ;-)
08:44:19 <monochrom> your action is truncated.
08:44:31 <dcoutts> lispy: as it happens, I think the QC preference is now out of date because the latest HP uses QC2
08:44:49 <dcoutts> lispy: the preferences are particularly important in the case of HP packages
08:45:10 <geheimdienst> really? shows fine here. must be client-side ... anyhoo, was just silly joking. nothing productive :)
08:45:28 * monochrom much regrets that the irc protocol does not sends back to you what the server thinks you sent.
08:45:29 <lispy> As a user of cabal-install, what I know is that I cannot trust cabal-install to do what I ask and that costs me time troubleshooting.  As it is, I've started to assume cabal-install is broken FIRST and that helps me save time.  But it's still frustrating.
08:46:08 <dcoutts> lispy: I'd really rather you didn't assume that.
08:46:12 <dcoutts> some things are broken
08:46:19 <monochrom> Yes, really. Generally, you the author is not told what the server and/or other people see when you say something.
08:46:27 <dcoutts> if there's things that are genuinely broken then we want to know
08:46:43 <dcoutts> if the behaviour is confusing then that's useful to know too, we can try and make it clearer
08:46:54 <lispy> dcoutts: One of the things that drives me nuts is when cabal says it's doing something but it does something different.
08:47:06 <monochrom> You should try to irc using netcat someday. It's very sobering.
08:47:38 <dcoutts> lispy: so there's the --constraint='base ...' bug, and it not telling you when it's selecting a version other than the latest. Any others?
08:47:38 <lispy> dcoutts: for example, if something is already built and you type 'cabal build' it seems to say it will link it but your program won't pickup changes from libraries.
08:48:07 <ray> sobering in that it's just the same as using ircII but with slightly more typing?
08:48:13 <dcoutts> lispy: I'm not sure what you mean
08:48:26 <monochrom> haha
08:48:38 <lispy> dcoutts: I was trying to benchmark something in darcs.  I had a separate .cabal file where I was using darcs as a library.
08:48:59 <lispy> dcoutts: I would rebuild darcs, reinstall it as a library with the same version
08:49:00 <geheimdienst> lispy, i'm using cabal build all the time, and for me it *does* check if any .hs file is newer than its compiled counterpart
08:49:17 <lispy> dcoutts: then I would go back to my benchmark project, type 'cabal build' and cabal would say something about linking it
08:49:28 <dcoutts> lispy: ok, so ghc links...
08:49:45 <lispy> dcoutts: but I'd run it and the performance would be the same as last time.  Then I would do, cabal clean && configure && build and the performance would be different
08:50:08 <dcoutts> lispy: if the library was really registered with the same version then if ghc says it links then it really links, there's no hidden copy of the old lib anywhere
08:50:40 <dcoutts> lispy: sounds like if you can reproduce this then it's a ghc thing, and you should be able to reproduce it with just ghc --make
08:51:16 <lispy> dcoutts: and just this weekend I had to re-install ghc
08:51:35 <monochrom> buy a new computer
08:51:51 <lispy> dcoutts: cabal was telling me that it couldn't configure a package because somethin (ghc-prim?) dependent on Foo = 1.X and it depended on Foo =1.Y.
08:52:03 <lispy> dcoutts: the cabal faq says that it a diamond dependency
08:52:17 <lispy> dcoutts: it says to ghc-pkg unregister the --user package
08:52:18 <geheimdienst> lispy, i think you should just bump the version number. that gives clarity, both for humans and the tools. it's not like version numbers cost anything
08:53:22 <lispy> dcoutts: So I ran the command on the cabal faq page.  And (this is ghc-pkg not cabal) but it did two odd things a) said it was ignoring my command and to use --force (which I was doing) 2) unregistered both global and user versions even with --user on the command line
08:53:35 <luite> look again, the dependencies are now diamonds
08:54:28 <lispy> geheimdienst: that would have require a lot more time because darcs takes a while to build so bumping the version # there would require a cabal clean, etc.  And I was doing quick iterations so I would have had about 30 different darcs libraries installed.
08:55:05 <dcoutts> lispy: did you report the ghc-pkg bug?
08:55:06 <lispy> luite: the message has been changed?  I had a very recent cabal-install according to cabal-install
08:55:16 <luite> sorry that was a bad joke :p
08:55:27 <monochrom> hahahaha
08:55:48 <lispy> dcoutts: No, I don't have a trac account and I'm sick of making new ones (I keep losing my password and then when I try to reset it trac blows up.  I've been through that 2-3 times already).
08:55:49 <monochrom> at least they are diamonds rather than salt pillars
08:56:00 <geheimdienst> luite, i thought it was funny. the only problem was that i couldn't figure out how to weave a "i'm on a horse" into the conversation
08:57:09 <dcoutts> lispy: it's pretty hard to get things resolved if the developers do not know about it
08:57:35 <dcoutts> lispy: I'm sure you can get the trac account issue resolved, e.g. ask Igloo for help.
08:58:00 <lispy> Possibly.  I didn't have any luck with that the first time.
08:58:02 <geheimdienst> lispy, but bumping the version number does not require a full rebuild. it just needs a re-configure and then builds whatever .hs files were changed. i'm pretty sure about that
08:59:12 <dcoutts> lispy: I appreciate that you're a bit grumpy about all these problems but it does need a bit of cooperation in both directions to make sure they're properly reported so that you're not just being frustrated in silence
08:59:29 <lispy> Oh, I'm not in silence :P
08:59:45 <Igloo> If nothing else, you can log in as guest
09:00:04 <Igloo> I think trac now behaves properly, BICBW
09:00:08 <monochrom> My father is not in silence either.
09:00:10 <lispy> Igloo: does the ghc trac have that?  I thought that was only the cabal-install wiki?
09:00:27 <monochrom> He has all sorts of complaints and opinions about governments.
09:00:50 <monochrom> He loudly voices them over the dining table. Definitely not in silence.
09:00:53 <Igloo> lispy: Well, the front page claims it does in bold letters
09:00:56 <geheimdienst> monochrom, did he file bugs in the appropriate trac instances. possibly logging in as guest
09:01:00 <monochrom> The governments still didn't hear them.
09:01:34 <monochrom> Right, that's the point. He is loud but barking to the wrong people.
09:01:42 * geheimdienst thinks a guest account is great! more bug trackers should have that. kudos, guys.
09:01:56 <Igloo> lispy: If you use it, it's useful if you sign tickets/comments so we know who to ask if we have a question, though
09:02:28 <lispy> Igloo: okay.  I think I usually forget though.
09:03:13 <monochrom> If dinner is over, he barks to the TV.
09:03:59 <dcoutts> lispy: btw, I've removed the pref on QC1, since version 2 is now the default since the new HP release.
09:04:33 <dcoutts> lispy: see also http://hackage.haskell.org/trac/hackage/ticket/408
09:04:42 <geheimdienst> dcoutts, one less source of confusion. thanks, man :-) keep up the good work
09:05:19 <lispy> dcoutts: What is the motivation for base < 4?  Shouldn't that be bumped?  GHC is about to get rid of 3.  And parsec 3 is now preferred, IIRC.  The performance gap has been closed as it has a parsec2 compatibility layer.
09:05:59 <dcoutts> lispy: ok, so the issue there is that preferred versions is actually the union of actual preferred versions and version hacks to make old packages not break.
09:06:15 <lispy> I think the warning on #408 would be very nice.
09:06:30 <dcoutts> lispy: I'll have to check if the way we handle base prefs means the global pref there can disappear
09:06:45 <dcoutts> lispy: it was originally needed to stop all of hackage breaking when ghc-6.10 was released
09:06:45 <lispy> I think we should fix the ill-specified packages.  I really feel that strongly.  You may disagree.
09:07:03 <dcoutts> lispy: oh I agree, but we also could not allow all of hackage to stop working
09:07:23 <dcoutts> lispy: do you remember the flak we took when we broke it all in the 6.6 -> 6.8 transition?
09:07:41 <monochrom> This is just a long grace period. base-3 will disappear yes. soon.
09:07:44 <dcoutts> that's where the whole base 3 + 4 thing comes from
09:07:45 <lispy> Did we have cabal in that transition?  No, I don't recall it.
09:07:50 <dcoutts> lispy: yes
09:07:57 <dcoutts> from our desire to smooth out the transition
09:08:20 <lispy> Then, your grace period has been too generous :)
09:08:24 <dcoutts> heh
09:08:28 <lispy> Time to put down the hammer
09:08:46 <dcoutts> lispy: ghc-6.12 warns about base 3, ghc-6.14 / 7 does not have base 3
09:08:52 <monochrom> I remember. It is why I stayed at 6.6 for a long time. Due to reading all sorts of chaotic rumours here.
09:08:52 <dcoutts> lispy: I think that's reasonable.
09:09:31 <lispy> Well, I think the current machinery interacts with those deprecation warnings.  You get base3 more often than you otherwise would
09:09:50 <dcoutts> lispy: if you use: base >= 3 && < 5 then you get base 4
09:09:57 * hackagebot thimk 0.3 - Command-line spelling word suggestion tool  http://hackage.haskell.org/package/thimk-0.3 (BartonMassey)
09:10:06 <dcoutts> lispy: the problem is cabal doesn't tell authors of new packages to do that, it should do, I accept that.
09:10:40 <lispy> Is there a cabal-install ticket where cabal says, "Hey, I have a global pref on package FOO.  You really need to specify a better version range?"  Related to #408 of course
09:11:29 <dcoutts> lispy: no, feel free to file one. We'd need to distinguish version hacks from real preferences
09:12:10 <dcoutts> lispy: and then we'd need to make it warn when a version hack rule was invoked (when the version picked would have been different without it)
09:12:15 <lispy> dcoutts: I was actually thinking about it as one of the checks hackage could do on upload
09:12:23 <dcoutts> lispy: sure, it could do that
09:12:47 <dcoutts> lispy: we implement those checks in the Cabal lib, so that "cabal check" can report the same issues
09:21:29 <bss03> @type guard . not
09:21:30 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:21:55 <bss03> @type guard $ not $ 1 == 2
09:21:56 <lambdabot> forall (m :: * -> *). (MonadPlus m) => m ()
09:22:26 <Phyx-> :t \a b->guard a >> b
09:22:27 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
09:25:51 <Phyx-> :t when
09:25:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:25:57 <Phyx-> @src when
09:25:58 <lambdabot> when p s = if p then s else return ()
09:26:09 <Phyx-> why is when restricted to just m () ?
09:26:17 <Phyx-> wouldn't m a be alot more useful
09:26:28 <bss03> It can't be m a.
09:26:42 <bss03> What does it return when the Bool is false.
09:27:02 <bss03> It could be Bool -> m a -> m (Maybe a), I guess.
09:27:12 <Phyx-> it calls fail, so what it returns depends on the monad used
09:27:24 <bss03> When doesn't call fail.
09:27:31 <bss03> "when" doesn't call fail.
09:27:47 <Phyx-> I know, I meant, the m a version could call fail
09:28:17 <bss03> Ah, well, that's possible, but I think many people would like to see fail done away with.
09:28:21 <Phyx-> basically, (>>) . guard
09:28:38 <bss03> It doesn't have any correspondence with the mathematical notion of Monads.
09:28:54 <bss03> It's really only in the language as something for "do" to call when pattern matching fails.
09:30:09 <Phyx-> ok
09:38:06 * hackagebot amqp 0.2 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2 (HolgerReinhardt)
09:43:57 <spatters> hi all... very basic question. i've installed a package using cabal, but I can't seem to load it in ghci. do i need to update a path variable somewhere to tell ghci where to look for it?
09:44:22 <Nibble> spatters: how are you trying to load it?
09:44:33 <tommd> spatters: No, it should just work.
09:44:46 <tommd> cabal install crypto-api
09:44:46 <tommd> ghci
09:44:46 <tommd> import Crypto.Random
09:45:00 <spatters> :load <package name>
09:45:10 <tommd> no, use :m (for module
09:45:14 <tommd> or "import"
09:45:28 <tommd> :load is based on your current directory, iirc.  Not something I really ever use.
09:46:33 <c_wraith> :load is actually based on the current source path in ghci, which defaults to ".", but you can add stuff to it with the -i option
09:46:34 <spatters> ah ok... 
09:46:48 <spatters> just trying that now - thanks
09:47:15 * tommd leaves for the office
09:47:27 <spatters> yes that works now - thanks very much for the help
09:48:01 <c_wraith> basically, :load is meant for source you're working on, and :module is meant for installed libraries
09:48:30 <dcoutts> c_wraith: or switching module context between loaded packages
09:48:35 <dcoutts> erm loaded modules
09:48:44 <dcoutts> modules from packages are always considered loaded
09:49:17 <spatters> ok, got it
09:49:31 <c_wraith> Ah.  I guess :module does do that too.  I just never have had occasion to use that functionality :)
09:50:06 <Phyx-> @src undefined
09:50:06 <lambdabot> undefined =  error "Prelude.undefined"
09:53:30 <McManiaC> anyone familiar with hxt-xpath and their xpath syntax? is there a way to do something like...
09:53:45 <McManiaC> getXPathTrees "div/a" >>> getChildren
09:53:46 <McManiaC> in one go?
09:54:26 <McManiaC> and why can't I access attribute values with "div/a@href"? I get an xpath error that it didn't expected a "@" here?
09:55:29 <Colours> hi! where is HsFFI.hs located on OSX?
09:55:35 <Colours> or do you need to install a package seperately for it
09:55:37 <kulin> mcmaniac, i believe it should be div/a/@href
09:55:52 <Colours> I am trying to #include "HsFFI.h" and I get an error :(
09:56:18 <Botje> Colours: /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.1/include/HsFFI.h
09:56:39 <Botje> you might have to do something like -framework GHC, but don't trust me on that :)
09:57:01 <Colours> ah hah
09:57:03 <Colours> awesome thanks a bunch :3
09:57:12 <Colours> I was not expecting it to be there at all
09:57:13 <bss03> Does "Double" have "+Inf" or something like Java's Double.INFINITY?
09:57:20 <Colours> I guess I haven't been using OSX for long enough
09:57:37 <Botje> Colours: two months here :P
09:58:05 <Colours> pft
09:58:45 <monochrom> If Double is IEEE754 on your platform, it has +inf. But not an identifier for it. use 1/0 to obtains.
09:59:12 <McManiaC> kulin: ah cool! but this will get me 'href="..."' - how do I access the "..." again?
09:59:24 <rschnck> There's an "and" argument in Haskell, right? I want to have some function such if the inputs satisfy two conditions, it will do something.
09:59:33 <rschnck> ...and if so, what is it?
09:59:50 <McManiaC> > True && False
09:59:51 <lambdabot>   False
09:59:59 <McManiaC> > and [True, False, True]
10:00:00 <lambdabot>   False
10:00:07 <vanadium> He wants a higher-order one
10:00:13 <vanadium> surely
10:00:27 <rschnck> Well, I have this:
10:00:30 <rschnck> insertInOrder x l | (head l) `div` x == 1 || (head l) `mod` x == 0
10:00:32 <rschnck> And at the ||
10:00:38 <rschnck> I'm really thinking "and"
10:00:42 <vanadium> &&, then?
10:00:45 <rschnck> Oh
10:00:47 <Nibble> yeah
10:00:47 <rschnck> Okay, great
10:00:51 <Nibble> && worksah
10:01:23 <McManiaC> 18:59    McManiaC > True && False
10:01:24 <McManiaC> :P
10:02:24 <kulin> mcmaniac, i only use xpath with other languages which return the attribute as an object with a 'value' property, but i believe you can do something like string(div/a/@href)
10:08:49 <McManiaC> kulin: nope, syntax error :(
10:09:27 <McManiaC> kulin: I still need to do "getXPathTrees "div/a/@href" >>> getText"
10:09:54 <kulin> ya, but i don't know where to start on that one :)
10:10:07 <kulin> all my xpath experience is c#
10:10:40 <McManiaC> hmkay
10:18:24 <ManateeLazyCat> @hoogle stringEncode
10:18:24 <lambdabot> No results found
10:18:35 <ManateeLazyCat> Does have a function do "stringEncode :: Encoding -> [Char] -> [Word8]" ?
10:19:20 <ManateeLazyCat> In Haskell, Char in String is Unicode, but some C function need [Word8], i want to know whether have package do those work automatically? 
10:20:29 <Saizan> http://hackage.haskell.org/package/encoding
10:20:30 <ManateeLazyCat> withCString will convert Char (Unicode) to the encoding of current locate, but if filename's encoding is not same as locate encoding, withCString is wrong.
10:21:51 <vanadium> Is [Word8] not basically an unpacked ByteString
10:22:19 <c_wraith> Isn't there an easy way to convert ByteStrings to CString?
10:22:32 <ManateeLazyCat> vanadium: If i need convert String to [Word8], i need give encoding information.
10:22:38 <vanadium> Yeah, I get it
10:22:40 <notabel> c_wraith: yeah, it's a primitive conversion in the bytestring library
10:22:54 <c_wraith> ManateeLazyCat, Saizan pointed you at the encodings package.  it does what you want
10:23:09 <ManateeLazyCat> c_wraith: Yes, but i need convert String to ByteString first.
10:23:21 <c_wraith> that's what the encodings packages *does*
10:23:31 <ManateeLazyCat> c_wraith: Yes.
10:23:41 <ManateeLazyCat> Saizan: Thanks, i think encode is my need.
10:24:31 <ManateeLazyCat> c_wraith: We still need "automatic detect encoding" package, then integrate 'encoding' package convert unknown string.
10:24:45 <ManateeLazyCat> c_wraith: Maybe i will send some patch to text-icu package
10:26:45 * ManateeLazyCat It's awesome if all system use UTF-8, so many variant encoding in my file-manager.....
10:27:24 <ManateeLazyCat> vanadium: Look http://hackage.haskell.org/trac/haskell-prime/wiki/CharAsUnicode
10:32:23 <ManateeLazyCat> c_wraith: We use unsafeUseAsCStringLen or unsafeUseAsCString convert ByteString to CString.
10:36:58 <Nibble> in this "instance SomeClass SomeInstance where" what is SomeInstance, a type constructor or a value constructor
10:37:57 <ManateeLazyCat> A complete solution to handle variant encoding filepath like this: Use 'text-icu' got filepath's encoding or from locate, then use 'encoding' convert String to ByteString, then use unsafeUseAsCString convert to CString pass to low-level C function.
10:39:19 <ManateeLazyCat> I think encodeStrictByteString is my need.
10:40:41 <Nibble> what types does maximum and minimum act on
10:41:14 <geheimdienst> :t maximum
10:41:14 <Nibble> nvn
10:41:15 <lambdabot> forall a. (Ord a) => [a] -> a
10:43:57 <zygoloid> Nibble: in 'instance SomeContext => SomeClass SomeInstance', the entire instance head is in the type namespace.
10:45:24 <ManateeLazyCat> Thanks all for help! G'night! :)
10:46:14 <Nibble> @info (->)
10:46:15 <lambdabot>  Parse error at "->)" (column 2)
10:46:22 <Nibble> >:i (->)
10:46:53 <zygoloid> @kind (->)
10:46:54 <lambdabot> ?? -> ? -> *
10:47:27 <Nibble> data (->) a b that is what I get in ghci
10:47:33 <Nibble> anyone care to explain why?
10:47:55 <zygoloid> Nibble: because (->) is a binary type constructor
10:48:29 <Nibble> zygoloid: well, binary in the meaning that it takes two inputs?
10:48:36 <zygoloid> yeah
10:50:19 <zygoloid> if you're asking why it says 'data', i guess it's just the most appropriate of 'newtype', 'data' and 'type'. one could imagine that functions are represented by some kind of ADT i suppsoe
10:50:58 <Nibble> ADT?
10:51:12 <zygoloid> algebraic data type. those things you can create with 'data'
10:51:41 <copumpkin> CADT
10:53:56 <monochrom> monadic could mean function with just one argument, e.g., second-order monadic logic
10:55:17 <Nibble> what does CADT mean? I guess it is ADT with some kind of addon
10:55:20 <Nibble> attacked to the head
10:55:37 <copumpkin> coalgebraic data type :P
10:57:15 <Martty> i need a step by step explanation of complexity analisis for 2 simple c++ algorithms, any takers? pm
11:00:27 <monochrom> whereas that of simple haskell algorithms will have to be thunk-by-thunk instead :)
11:06:15 <ski> zygoloid : imo, it would be good to use the same convention as the MLs, i.e. use `type' for any type, specified abstractly, while using `data' for a type specified concretely (i.e. with constructors)
11:06:50 <ski> (SML uses `datatype' for what `data' is used for in Haskell, more or less)
11:07:24 <ski> then `type (->) a b' would just specify `(->)' with its kind, abstractly, without saying anything about implementation
11:12:05 <zygoloid> ski: it's got to be 'newtype' or 'data' because otherwise you couldn't define instances for it.
11:12:37 <zygoloid> that is, it has to be a type /constructor/
11:13:44 <ski> as long as its abstract, that'd work
11:14:21 * copumpkin is just about ready to give up on this damned readProcess
11:14:25 <zygoloid> GHCi's :info says "data (->) a b   -- Defined in GHC.Prim" which seems about as good as we can get without a new keyword
11:14:50 <zygoloid> ok, maybe data (->) (a :: ??) (b :: ?) would be better
11:15:28 <ski> zygoloid : Hugs has something called "Restricted type synonyms" <http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html>, where you define a type synonym, but it's only visible locally that it is a type synonym, everywhere else it behaves like an abstract type (a "type constructor", if you will)
11:15:35 <Saizan> poor readProcess
11:16:21 <zygoloid> ski: yeah, i'd read about those. they sound useful... except that you can't define instances for them.
11:16:31 <ski> zygoloid : also, in SML, regarless of whether you define a type by `datatype' (like `data') or by `type' (i.e. a type synonym), you can use `type' to *abstractly* export it from the structure/module, and then go on to use it like an abstract type
11:16:48 <ski> zygoloid : sure you can define instances for "Restricted type synonyms"
11:17:35 <zygoloid> ski: suppose i have instance Foo String and instance Foo MyString where MyString is an RTS for String
11:17:49 <ski> yeah, no problem
11:17:57 <zygoloid> surely the compiler has to complain about that?
11:18:32 <ski> no, that `MyString' is a synonym for `String' is only visible in a select few operations that you have enumerated in the restricted type synonym declaration
11:18:54 <zygoloid> if you allow that for type family instances too, i'm pretty sure i could write a coerce
11:19:26 <zygoloid> some of the code would need to be one of the privileged can-see-the-synonym functions
11:19:42 <ski> so, either you can also enumerate class methods or maybe a class name there (i think it could possibly work, but i don't think that is implemented); or you just define the bulk of the methods separatedly
11:21:45 <ski> (a `coerce :: forall a b. a -> b' or what ?)
11:23:14 <ski> anyway, i think it's bad to have to include irrelevant implementation detail when specifying the interface of something .. so i think it would make sense to use e.g. `type' when specifying types abstractly
11:23:39 <zygoloid> ski: i'm thinking of something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29832#a29832
11:24:09 <zygoloid> coerce :: forall a b. a -> b
11:27:05 <zygoloid> ski: cleaner example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29832#a29833
11:27:10 <ski> yes, you're right that one would have to distinguish clearly between types which are exported abstractly (so we know nothing about them), and types which we know are different from every other type exported somewhere else (or maybe different from every other such type, with a few specifically enumerated exceptions .. the SML module system has something to specify when types exported from different modules are actually the same
11:28:31 <zygoloid> right. essentially, restricted type synonyms are not in normal form, so it's not safe to pattern-match on them (when selecting instances etc)
11:28:40 <ski> *nod*
11:30:39 <jystic> Hi all, where should I start look if i'm interested in learning how to parse a pseudo Haskell98 language that would uses layout for where clauses?
11:30:55 <jystic> s/look/looking/
11:32:27 <zygoloid> jystic: you could look through the description of the layout rule in the haskell'98 report.
11:33:13 <jystic> i did have a look at that, i was hoping that someone might know about some example implementations
11:34:39 <jedai> jystic: well there are a certain number of Haskell implementation of this parsing
11:35:39 <jedai> jystic: all the Haskell compilers have one for instance, you could also look at the packages that endeavour to parse Haskell
11:37:28 <jystic> jedai: i'll dig a bit deeper on hackage then, cheers
11:39:02 <kulin> is there some trick for c2hs when your chs file does #import "example.h" and example.h has #import "other.h" soley for the purpose of getting access to type "SomeType" but the "other.h" has a lot of other types which break c2hs?
11:39:17 <ezyang> qualified? 
11:39:25 <ezyang> oh, no, that's not your question. 
11:39:25 <kulin> can c do qualified imports?
11:39:35 <kulin> oops i mean #include , not #import
11:40:17 <\yrlnry> C doesn't even have namespaces.
11:40:31 <\yrlnry> All identifiers are either file scope, block scope, or global.
11:40:39 <\yrlnry> So there's nothing to "qualify".
11:40:44 <\yrlnry> That
11:40:57 <\yrlnry> That's why all the opengl functions have names beginning with "gl_".
11:41:48 <tg_> Damn. I wanted to say something witty, but ran out of time.
11:42:33 <Zao> \yrlnry: Well, without the _.
11:42:51 <Zao> Note that those names are particular to the C implementation, as the standard does not define any leader at all.
11:42:56 <Zao> (OpenGL standard, that is)
11:42:57 <\yrlnry> Oh, right.  gl_ is for the Global Inventory Management library.
11:43:13 <tg_> i was thinking "good library"
11:43:22 <\yrlnry> Or maybe the Glass Tempering Control Systems library.
11:43:30 <\yrlnry> No, that's glt_.
11:43:31 <Zao> kulin: Apply violence, lift out the bits that make sense?
11:44:36 <kulin> i feel like you must know something about c that i dont
11:45:29 <Twey> That it's amusing?
11:49:23 <copumpkin> any readProcess experts around? :P
11:49:38 <ezyang> What's the question/ 
11:51:22 <kulin> do you think void* my only option?
11:53:03 <copumpkin> seems to be some sort of timing issue
11:53:20 <copumpkin> ezyang: basically, I'm trying to call objdump with readProcess
11:53:33 <copumpkin> except it always returns exitFailure
11:53:40 <copumpkin> with no stderr or out
11:54:05 <copumpkin> and it seems to be nondeterministic too
11:54:13 <ezyang> What opearting system? 
11:54:16 <copumpkin> mac os
11:54:27 <copumpkin> (I compiled objdump myself)
11:54:37 <copumpkin> since mac os doesn't have it
11:54:57 <ezyang> Hmmm. 
11:55:07 <ezyang> Does it run ok when you do it manually? 
11:55:16 <copumpkin> yeah, definitely
11:55:54 <ezyang> And you're not passing anything for stdin? 
11:57:20 <copumpkin> nothing
11:57:22 <copumpkin> just a few args
11:57:33 <copumpkin> but I copied the source to readProcessWithExitCode
11:57:42 <copumpkin> and modified it slightly, and now I have it behaving nondeterministically
11:57:50 <copumpkin> as in, different calls to it will succeed or fail
11:58:46 <ezyang> My feeling is that there's stdin race of some sort. 
11:59:24 * hackagebot iyql 0.0.5.4 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.5.4 (DiegoSouza)
11:59:56 <copumpkin> ezyang: hmm, not sure
12:02:32 <copumpkin> ezyang: here's an overview: http://pastie.org/1148724
12:02:51 <copumpkin> note that each of the four tests are exactly the same call on my end
12:03:10 <ezyang> whoa, complicated code... 
12:03:50 <copumpkin> readProcessWithExitCode' is just a copy of the System.Process version
12:04:00 <copumpkin> with some quick tests thrown in above the original readProcess code
12:04:49 <ezyang> hmm, yeah, I don't really know. 
12:04:58 <ezyang> Try stracing it? (or whatever the Mac OS X equiv is) 
12:05:07 <steven_t> o no!
12:05:26 * hackagebot iyql 0.0.5.5 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.5.5 (DiegoSouza)
12:05:26 <steven_t> oh wait
12:05:27 <steven_t> hi
12:09:27 * hackagebot iyql 0.0.5.6 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.5.6 (DiegoSouza)
12:25:52 <saml> hey teach me functionaljava
12:26:02 <saml> i bet one of you guys wrote it
12:34:24 <copumpkin> ezyang: definitely some kind of race
12:35:17 <ezyang> Yeah, nondeterminism tends to be that. 
12:35:25 <ezyang> Did strace/dtrace say anything elucidating? 
12:37:00 <copumpkin> http://pastie.org/1148789
12:37:06 <copumpkin> not really
12:37:54 <copumpkin> not really sure that the dtruss output is in sync with the stdout of my program
12:38:02 <copumpkin> in fact, pretty sure it isn't
12:40:06 <copumpkin> I think dtruss is buffering things up
12:44:41 <Nibble> what lib is the functio bracket defined?
12:45:15 <ehamberg> @hoogle bracket
12:45:16 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:45:16 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:45:16 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:45:49 <copumpkin> I should probably use bracket in my function
12:45:55 <copumpkin> but I don't think it would give me my issue
12:49:36 <dolio> Aww, Oleg advertised his multi-prompt delimited continuations as not using unsafeCoerce, so I thought he found some magic.
12:49:43 <dolio> But then he used Data.Typeable.
12:49:49 <dolio> Which uses unsafeCoerce.
12:50:03 <Philippa> heh. Yeah, but at least it doesn't use it directly
12:50:19 <dolio> I guess.
12:51:41 <monochrom> You could imagine a haskell implementation that provides Data.Typeable as builtin and safe.
12:51:55 <dolio> You could, yes.
12:52:00 <notabel> dolio: arguably, Data.Typeable only exports safe coercions, so the fact that it uses unsafeCoerce internally is an implementation detail
12:52:19 <notabel> as long as you treat Data.Typeable as a trusted kernel of code
12:52:52 <dolio> notabel: The implementation of prompts in the original Dybvig et al delimited continuations only exported safe coercions.
12:53:05 <dolio> It just used guaranteed-unique integers in a monad instead of type reps.
12:53:35 <monochrom> perhaps 5 years later he will discover magic and can do "multi-prompt multi-delimited multi-continuations, in pure haskell2010" :)
12:54:22 <notabel> right, the point being that oleg's version relies on an external trusted kernel for coercion, instead of doing it by hand.  so when he says it doesn't use unsafeCoerce, he means "i didn't use unsafeCoerce; any of that happens in a trusted externel library"
12:54:38 <notabel> monochrom: 5 years?  you seem to doubt his pace :-P
12:55:12 <tolkad> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined" -_-
12:55:19 <tolkad> Even C doesn't do that...
12:55:30 <tolkad> I can't rely on unsigned types to wrap around?
12:55:51 <copumpkin> in practice, yes
12:55:53 <medfly> > (maxBound :: Int) + 1
12:55:54 <lambdabot>   -9223372036854775808
12:55:55 <ddarius> Clean provides a "Data.Typeable" that's built-in, safe, and more powerful.
12:55:58 <notabel> tolkad: in practice you can; i think all of the implementations guaruntee it
12:56:09 <dolio> It's also easy to defeat the existing Data.Typeable into providing unsafeCoerce, and, I think, less easy to defeat the implementation in the original prompt generator.
12:56:33 <tolkad> copumpkin: was that a "yes I can" or a "yes I can't"?
12:56:46 <copumpkin> tolkad: yes you can rely on it behaving that way, in any real implementation I know of
12:57:01 <ddarius> The Report doesn't specify a bit width so how could you rely on wrap-around anyway?
12:57:03 <copumpkin> but the standard doesn't want to rely on the underlying representation of those types, I guess
12:57:15 <ketil> @seen dons
12:57:15 <lambdabot> Unknown command, try @list
12:57:15 <preflex>  dons was last seen on #ghc 1 day, 20 hours, 39 minutes and 50 seconds ago, saying: i need more input from bos.
12:57:25 <tolkad> ddarius: let's see what the C standard says
12:57:31 <djahandarie> lol preflex hijacked @seen now? :P
12:57:34 <ddarius> The Int32/64/Word32/64 types do, I believe, specify wrap-around behavior, though I could be mistaken.
12:57:39 <copumpkin> djahandarie: only for the last year or so
12:57:48 <tolkad> ddarius: well that's the only thing I could find
12:57:52 <tolkad> ddarius: have a quote?
12:57:54 <djahandarie> I thought it onles used to use preflex: seen
12:57:57 <djahandarie> only*
12:58:05 <copumpkin> oh I see
12:58:10 <copumpkin> I guess mauke changed it
12:59:08 <tolkad> ddarius: downloading C standard atm, let's take a look for comparison
12:59:38 <mauke> C standard says unsigned types wrap around while signed overflow is UB
13:00:37 <tolkad> here we go
13:00:44 <tolkad> "C’sunsigned integer types are ‘‘modulo’’inthe LIA−1 sense in that overﬂows or out-of-bounds results silently wrap."
13:00:57 <tolkad> sorry stupid PDF copy paste ruins everything
13:01:23 <tolkad> "C’s unsigned integer types are ‘‘modulo’’ in the LIA−1 sense in that overﬂows or out-of-bounds results silently wrap."
13:02:19 <djahandarie> Ligatures sure don't look too good in monospace
13:02:26 <tolkad> it's very useful to be able to rely on this
13:03:36 <notabel> tolkad: as everyone said, you can rely on this in any available haskell.  no plans for GHC: Signalling Unsigned Overflow Edition
13:04:01 <djahandarie> > succ (maxBound) :: Int
13:04:02 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
13:04:16 <copumpkin> > succ maxBound :: Int64
13:04:16 <lambdabot>   *Exception: Enum.succ{Int64}: tried to take `succ' of maxBound
13:05:05 <djahandarie> > iterate succ (maxBound - 2) :: [Int]
13:05:05 <lambdabot>   [9223372036854775805,9223372036854775806,9223372036854775807,*Exception: Pr...
13:05:08 <notabel> indeed.  enumeration semantics already provide signalling overflow if needed, hadn't even occurred to me
13:05:39 <ddarius> notabel: Um... that doesn't help you if you aren't using Enum.
13:06:03 <waterlaz> hi 
13:06:16 <waterlaz> is there a way to make this kind of code tale recursive?
13:06:21 <waterlaz> s <- newIORef 0
13:06:22 <waterlaz> 	forM_ [1..10000000] $ \i -> modifyIORef s (+i)
13:06:22 <waterlaz> 	putStrLn =<< (liftM show . readIORef) s
13:06:25 <djahandarie> > succ (1.0 :+ 1.0) :: Complex Float
13:06:26 <lambdabot>   No instance for (GHC.Enum.Enum
13:06:26 <lambdabot>                     (Data.Complex.Complex GH...
13:06:37 <notabel> ddarius: that's true, but that's why it's useful.  integral overflow is silent, enumeration overflow is signalling
13:07:08 <notabel> djahandarie: the complex numbers aren't totally-ordered, so there's no enum instance
13:07:12 <ddarius> Many people want signalled overflows for arithmetic and few use Enum to do arithmetic.
13:07:54 <waterlaz> can IO monadic code be tail recursive at all?
13:08:13 <copumpkin> @tell Peaker just found this, regarding that question you asked the other day: http://www.cs.nott.ac.uk/~nad/listings/lib/Category.Monad.Partiality.html#194
13:08:13 <lambdabot> Consider it noted.
13:08:59 <waterlaz> the top function "called" would be (>>) (>>=)
13:10:10 <ddarius> waterlaz: Is let f = id f tail recursive?
13:11:38 <waterlaz> ddarius, I don't know =)
13:13:09 <waterlaz> ddarius, anyway, I would expect my forM_ code not to create the whole list 
13:13:17 <tromp> yes, it is, ddarius
13:14:09 <waterlaz> and when I tried to write my own "from a to b loop" I seriously failed
13:14:23 <ddarius> tromp: Actually, it is technically not tail recursive, but yes, it doesn't build up stack even though f isn't in an (obvious) tail position.
13:15:15 <djahandarie> Can you make do desugar to non-prelude >>= ? (Without template haskell/)
13:15:17 <ddarius> waterlaz: forM_ for IO won't create the whole list (all at once) and, if there are no other retainers of the list, it will, potentially, be garbage collected as it goes.
13:15:37 <ddarius> Your problem, assuming there is actually a problem, most likely has to do with your use of modifyIORef.
13:15:42 <byorgey> waterlaz: note, however, that IORefs are lazy
13:15:57 <ddarius> djahandarie: With GHC, yes.
13:16:02 <ddarius> -fno-implicit-prelude
13:16:10 <byorgey> so that code will build up a giant thunk inside the IORef, ((((1 + 2) + 3) + 4) + ......
13:16:25 <byorgey> which will only be evaluated at the very end when you print it
13:16:33 <waterlaz> aha...
13:16:35 <waterlaz> I see
13:16:40 <copumpkin> anyone have any ideas about my weird racey thingy? http://pastie.org/1148789
13:16:59 <Saizan> copumpkin: hFlush h?
13:17:20 <tromp> ddarius, is f n = if even n then f (n`div`2) else f (3*n+1)  tail recursive?
13:17:26 <tolkad> I just understood how sequence works
13:17:30 <copumpkin> Saizan: OMG
13:17:33 * copumpkin hugs Saizan 
13:17:38 <copumpkin> I thought I tried that earlier
13:17:43 <Saizan> :D
13:17:44 <tolkad> this has been confusing me every time I looked at it
13:17:47 <copumpkin> that's why I have an hFlush in my import list
13:17:50 <copumpkin> hmm, must've been doing it wrong
13:18:21 <waterlaz> tromp, yes
13:18:31 <ddarius> tromp: Yes because if is a control structure and not a function.
13:18:53 <tromp> but there is noi difference between control structure asnd function
13:19:08 <ddarius> tromp: I agree that the difference is way more blurry in Haskell.
13:19:12 <tolkad> tromp: of course there isn't
13:19:18 <tolkad> tromp: like { is a function
13:19:22 <tolkad> tromp: and do is a function
13:19:28 <dstcruz> is there any way to search hackage, or a set of libraries for "things that return IO things"?
13:19:30 <tolkad> tromp: and import is a function
13:19:41 <tolkad> tromp: oh wait none of those are functions and you're wrong
13:19:44 <dstcruz> hayoo does not seem very helpful with something like: IO a
13:19:53 <ddarius> tolkad: None of them are control structures either.
13:19:58 <waterlaz> ddarius, so, if I implement myIf (myIf p a b = if p then a else b) and use it the tromps example won't be tail recursive?
13:19:59 <dstcruz> neither does hoogle
13:20:08 <tromp> if then else is simply styntactic sugar for a function
13:20:19 <byorgey> dstcruz: hayoo doesn't do type search
13:20:29 <byorgey> dstcruz: have you tried something like  a -> IO b  in Hoogle?
13:20:41 <tolkad> ddarius: I guess not. they're sort of structurish and controlish though
13:20:43 <dstcruz> let me give that a shot
13:20:46 <ddarius> waterlaz: Technically, yes, but stack behavior isn't determined by whether code is tail recursive.  There are other factors.
13:21:00 <ddarius> tromp: No, if is simply syntactic sugar for case.
13:21:45 <waterlaz> ddarius, can't be
13:21:55 <waterlaz> case is all about pattern matching
13:21:58 <tolkad> ddarius: case is just syntactic sugar for pattern matching with an anonymouse function
13:22:06 <tolkad> waterlaz: you can pattern match on Bool
13:22:13 <waterlaz> hm...
13:22:14 <tolkad> anonymous*
13:22:17 <Philippa> tolkad: no, case is fundamental
13:22:19 <ddarius> @src Bool
13:22:19 <lambdabot> data Bool = False | True deriving (Eq, Ord)
13:22:26 <ddarius> There is nothing special about Bool.
13:22:26 <tolkad> Philippa: oh
13:22:30 <fryguybob> dstcruz: The new hayoo does type search: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=a+-%3E+IO+b
13:22:34 <copumpkin> pattern matching in function definitions is sugar for case :)
13:22:39 <dstcruz> byorgey: that's more like it.  I still got funcitons like: a -> b, but I guess that's ok
13:22:43 <ddarius> (Well, I guess, other than the if and guard syntax.)
13:23:00 <byorgey> dstcruz: those can return IO things too =)
13:23:19 <tromp> any function of the form f arg1 .. argn = <arbitrary f free expression> (f arg1' ... argn') is tail recursive
13:23:22 * ddarius likes the Report's cheesy way of avoiding a real case translation.
13:23:26 <dstcruz> byorgey: Ah :( right.
13:23:27 <Philippa> tolkad: not that it's not encodable in lambda calculus sans case, but you have to generate an awful lot of functions for each algebraic datatype
13:23:44 <ddarius> tromp: That is false by definition.
13:23:45 <Philippa> ddarius: IIRC it translates down to "simple case" and then defines that straight up?
13:23:46 <dstcruz> fryguybob: awesome, that looks nice
13:23:59 <ddarius> Philippa: It translates multi-argument cases into cases over tuples.
13:24:07 <ddarius> s/cases/patterns/
13:24:19 <ddarius> or I guess functions is really what I'm looking for
13:24:21 <Philippa> ddarius: ! I'd forgotten that
13:24:32 <Philippa> ah, right, yeah
13:24:42 <tromp> as well as others involving choice for what args to pass in recursion
13:24:47 <Philippa> the currying isomorphism strikes again
13:25:04 <tolkad> > 1 + 2 `seq` (1 + 2, 1 + 2)
13:25:04 <lambdabot>   (3,3)
13:25:24 <tolkad> that's how you optimize stuff right?
13:25:26 <dstcruz> byorgey: so, (<-) would also match, right?
13:25:29 <tromp> oops, that is wrong indeed
13:26:03 <tolkad> seq make sure 1 + 2 gets evaluated first so that it only gets evaluated once
13:26:09 <dstcruz> oops, wrong
13:26:20 <tolkad> :t (<-)
13:26:21 <lambdabot> parse error on input `<-'
13:26:24 <tolkad> :t (->)
13:26:25 <lambdabot> parse error on input `->'
13:26:38 <tolkad> :k (->)
13:26:39 <lambdabot> ?? -> ? -> *
13:27:01 <tolkad> :k (->) -> (->)
13:27:01 <waterlaz> btw, should I write things like    let x = 1 + 2 in x `seq` (x, x)  ?
13:27:02 <lambdabot>     `(->)' is not applied to enough type arguments
13:27:02 <lambdabot>     Expected kind `??', but `(->)' has kind `?? -> ? -> *'
13:27:09 <vanadium> What is the canonical way to convert numbers to their hexadecimal representation? printf?
13:27:09 <waterlaz> or the compiler is smart enough?
13:27:16 <Cale> tolkad: That's wrong
13:27:30 <tolkad> Cale: what's wrong?
13:27:39 <tolkad> my seq example?
13:27:40 <Cale> If you write  1 + 2 `seq` (1 + 2, 1 + 2), then you'll just evaluate 1 + 2 three times
13:27:46 <monochrom> the compiler is not smart enough
13:27:54 <tolkad> but seq makes sure stuff happens first
13:28:15 <tolkad> uh
13:28:17 <mauke> tolkad: I don't think it does
13:28:18 <Cale> But those three subexpressions are not identified with each other
13:28:32 <tolkad> > let x = 1 + 2 in x `seq` (x, x)
13:28:33 <lambdabot>   (3,3)
13:28:41 <tromp> how about this: f is tail recursive iff it can be written as f a1 ... an = if <test> then <f-free> else f <f-free>1 .. <f-free>n
13:28:42 <Cale> That's better
13:28:45 <djahandarie> seq doesn't give a guarentee of order IIRC
13:28:54 <notabel> tolkad: not actually; the compiler has options about it.  pseq is mandatory
13:29:11 <tolkad> djahandarie: it guarantees the head is weak and in normal form
13:29:25 <Cale> That ensures that the 1 + 2 is evaluated prior to any pattern match on the pair succeeding
13:29:26 <waterlaz> ok, how do you deal with lazyness?
13:29:32 <tolkad> djahandarie: I'm not sure exactly what it has to do with the head function
13:29:39 <waterlaz> I know how to do it
13:29:50 <waterlaz> I don't know how to be sure when to do it :)
13:30:21 <djahandarie> seq is strict in both its argument
13:30:31 <djahandarie> So GHC evaluate either first
13:30:36 <djahandarie> can evaluate*
13:30:45 <Cale> waterlaz: Here's a handy rule-of-thumb: the only case where laziness is bad is where you're collecting up a large amount of data (with lots of separately-evaluable parts) and summarizing it into a small piece of data (with few such parts)
13:31:02 <djahandarie> You would need to use pseq if you want to control the evaluation order
13:31:05 <monochrom> or rather, the compiler is smart enough to not recognize common expressions. http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/b30a1eb973b9d4fc/2b3bc2d6bed0c808#2b3bc2d6bed0c808
13:31:10 <ddarius> tromp: That is incorrect as well, though certainly something of that form is tail recursive, there are many things not of that form that are as well.
13:31:41 <tromp> such as?
13:32:14 <ddarius> f z = if t then f x else f y is tail recursive
13:32:23 <Cale> waterlaz: Those are the places that large expressions would tend to get built up by lazy evaluation and only evaluated all at once later, (in the worst case causing a stack overflow)
13:32:38 <tromp> that's easily written in my form
13:32:43 <waterlaz> Cale, thanks, I understand that
13:32:51 <monochrom> don't worry about what is tail-recursive. red herring.
13:33:00 <ddarius> tromp: Write it.
13:33:03 <waterlaz> somehow I completeley missed the couse of stack overflow in my example above
13:33:03 * hackagebot xsact 1.7.3 - Cluster EST sequences  http://hackage.haskell.org/package/xsact-1.7.3 (KetilMalde)
13:33:42 <tromp> f z = if false then undefined else f (if t then x else y)
13:33:44 <Cale> Tail recursion actually tends to be bad without additional strictness
13:33:47 <ddarius> monochrom: It's not completely misleading.  It's just neither necessary nor sufficient in a lazy language.
13:34:35 <Cale> If we define something like f a 0 = a; f a n = f (a + n) (n-1)
13:34:38 <waterlaz> btw, wasn't ghc able to predict where being lazy is a bad idea?
13:34:46 <waterlaz> at least at some cases?
13:34:47 <Cale> It is, in a lot of cases
13:34:58 <Cale> So long as you turn on -O or -O2
13:35:51 <djahandarie> -O11
13:36:26 <notabel> djahandarie: -O11 is a work in progress :-)
13:36:34 <Cale> If we try to evaluate f 0 3, say, this proceeds like f 0 3 -> f (0 + 3) (3 - 1) -> f (0 + 3) 2 -> f ((0 + 3) + 2) (2 - 1) -> f ((0 + 3) + 2) 1 -> f (((0 + 3) + 2) + 1) (1 - 1) -> f (((0 + 3) + 2) + 1) 0 -> (((0 + 3) + 2) + 1)
13:37:00 <Cale> The second parameter gets evaluated each time, because it needs to be tested against 0
13:37:05 <Cale> But the first parameter doesn't
13:37:12 <Cale> So this is a good place to use seq
13:37:17 <Cale> Or a bang pattern
13:37:43 <djahandarie> > 1 `pseq` undefined in 10
13:37:44 <lambdabot>   <no location info>: parse error on input `in'
13:37:51 <djahandarie> > let x = 1 `pseq` undefined in 10
13:37:52 <lambdabot>   10
13:38:51 <Cale> let only makes definitions, it never causes any evaluation (except with bang patterns now, which are so powerful they can turn let into case :P)
13:39:22 <ddarius> tromp: At any rate, the definition of "tail recursive" is syntactic and is that all recursive calls occur in "tail position" where tail position is a given set of code contexts, which, for Haskell,  would be the function position of application, the branches of a case, the body of let/where/lambda.
13:41:04 <ddarius> Of course, this syntactic criteria 1) doesn't guarantee that stack use will be bounded and 2) doesn't account for laziness for which many non-tail positions would reduce to tail positions without allocating stack, e.g. a myIf function.
13:41:14 <tromp> i feel any syntactic definitions is going to be way too complicated, so i gave a simple semantic one
13:42:19 <ddarius> tromp: You can give a semantic notion but you are not defining "tail recursive."
13:42:38 <djahandarie> What would be an example of somewhere laziness takes care of not overflowing the stack that tail recursion couldn't?
13:42:42 <ddarius> If you are going to break out the semantic guns, then you might as well characterize "doesn't allocate stack" fully.
13:42:43 <notabel> tromp: the point is that in Haskell, the (syntactic) idea of "recursion in tail position (tail recursion)" doesn't correspond to any particularly useful semantic/operational characteristic
13:42:50 <ddarius> djahandarie: map
13:43:08 <ddarius> djahandarie: Or any recursive function using a functional if.
13:43:37 <tromp> stack allocation is operational, not semantic
13:43:38 <ddarius> notabel: It is still important, it's just not as definitive as in a typical eager language.
13:43:44 <ddarius> tromp: Correct.
13:44:26 <Philippa> tromp: more importantly, haskell doesn't have an operational semantics. It (or at least a generalised analogue) is perfectly semantic in Scheme
13:44:30 <tromp> you have yet to exhibit a counterexample to my definition
13:44:52 <ddarius> tromp: What is your definition defining.
13:45:12 <tromp> a property of function definitions
13:45:17 <Philippa> tromp: tail calling is a syntactic property, modulo a number of transforms. A-normalise your code and it's a trivial syntactic one
13:45:38 <Philippa> the rest's a matter of cranking out the sugar first so it still hangs together
13:45:41 <ddarius> tromp: That was a vacuous statement.  What property is it defining?
13:46:06 <Philippa> (note that GHC does, in fact, A-normalise your code at some stage)
13:47:06 <tromp> whether the function is equivalent to a tail-recursive one
13:48:50 <tromp> what's A in A-normalize?
13:49:52 <Philippa> tromp: "Administrative"
13:50:12 <Philippa> tromp: as in "Administrative Normal Form" or just ANF if you want to google for a clear definition
13:50:30 <Philippa> (it's the direct-style equivalent of CPSed code that's had the administrative redexes normalised away)
13:51:33 <tromp> thanks for elaborating
13:51:44 <ddarius> tromp: Can you write length in your form?  Note, that f = length so your code must be of the form, length xs = if ... then ... else length ...
13:52:15 <tromp> not without a helper function that uses an accumulator
13:52:20 <djahandarie> ddarius, would map f !(x:xs) = ... be strict enough to cause a stack overflow?
13:52:42 <ddarius> tromp: If you allowed that then -every- function is able to be put in that form.  Your template is a while-loop.
13:52:55 <copumpkin> djahandarie: putting a bang there doesn't do anything?
13:53:01 <ddarius> djahandarie: That would be exactly the sam ase map f (x:xs) = ...
13:53:05 <djahandarie> Oh
13:53:22 <tromp> indeed. so length is not tail recursive
13:53:24 <copumpkin> evaluating (x:xs) to whnf is the same as evaluating it to (x:xs)
13:53:24 <copumpkin> :P
13:53:32 <djahandarie> Yeah lol
13:55:24 <ddarius> length xs = let len [] acc = acc; len (y:ys) acc = len ys (1+acc) in len xs 0 is, once you expand the pattern matching into cases, tail recursive.
13:55:44 <ben_m> Wish I could use Haskell for everything, it's so fun to code in it.
13:55:51 <ddarius> Note though, that as written, it doesn't use constant stack space (though that can easily be fixed)
13:56:47 <tromp> len is tail recursive but length is not
13:57:05 <ddarius> tromp: length is trivially tail recursive in that definition.
13:57:05 <djahandarie> There should be a wiki article talking about how laziness can help your stack space usage
13:57:21 <ddarius> At any rate, tail recursiveness is a syntactic property.  It is a property of the code.  I can have semantically identical functions where one is "tail recursive" and one is not.
13:57:37 <ddarius> djahandarie: There are.
13:58:13 <djahandarie> Oh yeah, there are
13:59:19 <tolkad> :t 1
13:59:20 <lambdabot> forall t. (Num t) => t
13:59:41 <c_wraith> > -7 :: Word8
13:59:42 <lambdabot>   249
14:04:50 <djahandarie> Can I get O(1) length but with all the other exact asymptotic costs of List?
14:05:26 <mauke> I think so
14:06:35 <tromp> yes, each cell in list can store length from there to end
14:06:55 <mauke> overkill
14:06:59 <djahandarie> That would definitely not have the same asympotic cost
14:07:06 <c_wraith> yes it would
14:07:15 <c_wraith> It would just add a constant factor
14:07:20 <djahandarie> An cons would be O(n) wouldn't it?
14:07:33 <c_wraith> No, it just needs to look at the next cell's length
14:07:38 <djahandarie> Oh
14:07:41 <djahandarie> Misread
14:08:14 <mauke> data LList a = LList{ length :: Int, list :: [a] }
14:08:15 <c_wraith> It would screw with laziness, though.  to the point where it might not actually have the same asymptotics
14:08:32 <c_wraith> At least, not in cases that make use of the laziness.
14:08:40 <mauke> nil = LList 0 []
14:08:42 <tromp> it wld make for strict lists
14:09:06 <mauke> cons x xs = LList (length xs + 1) (x : list xs)
14:09:12 <mauke> make length strict while you're at it
14:09:47 <djahandarie> And this doesn't already exist somewhere? It seems useful
14:09:55 <monochrom> his list is willing but his length is sloppy
14:10:28 <mauke> djahandarie: how often do you need that?
14:10:39 <djahandarie> Well... right now :P
14:10:57 <monochrom> not often enough to land on hackage, apparently
14:15:21 <notabel> vector provides a very list-like interface.  the asymptotics are obviously different, but since it uses stream fusion internally performance could be similar
14:17:55 <dstcruz> is it correct to say that (a -> a) is a subset of (a -> b) ?
14:18:50 <dolio> Not unqualified like that.
14:20:18 <copumpkin> dstcruz: forall a b. a -> b is empty
14:20:41 <copumpkin> except for unsound things that we should ignore
14:20:47 <dolio> Has no total functions, at least.
14:22:20 * copumpkin should give in and write a super simple parser for this , but he really just wants a nice regex library for haskell :(
14:22:38 <notabel> copumpkin: what are you dealing with?
14:22:44 <Twey> Haskellers don't like regex, in general.
14:22:49 <copumpkin> Twey: yeah, I know
14:22:50 <Twey> It's untyped devilspawn.
14:23:05 * djahandarie leads the angry mob
14:23:14 <copumpkin> notabel: I really just want to strip a regular prefix off every line and cut off a regular suffix too
14:24:11 <djahandarie> By the way, is there any case where Data.List would outperform the stream-fusioned verison of lists?
14:24:24 <notabel> but not so regular it's just slicing?
14:24:48 <dolio> Nested concatMap still performs poorly under stream fusion, I think.
14:24:53 <copumpkin> I'd write a regex as /\s+\d+:\s+\d+\s+(.*)\s+;/
14:24:57 <dolio> And is better with foldr/build, I believe.
14:24:59 <notabel> djahandarie: yeah, concatMap is the bugaboo as i recall
14:25:36 <copumpkin> notabel: so basically, ignore some whitespace and numbers up front, and then ignore anything after a semicolon too (and whitespace before it)
14:25:46 <mauke> copumpkin: that looks wrong
14:26:03 <copumpkin> how so?
14:26:07 <mauke> missing anchors, of course
14:26:15 <mauke> but particularly the (.*)\s+ part
14:26:28 <mauke> the + there is redundant
14:26:31 <copumpkin> the first colon and semicolon are effectively anchoring it
14:26:39 <copumpkin> but I could stick a ^ on the front
14:27:28 <copumpkin>    0:	00000001 	andeq	r0, r0, r1       ; zomg wtf
14:27:34 <copumpkin> that's the kind of output I'm stealing :P
14:27:52 <copumpkin> I really just want to grab "andeq r0, r0, r1"
14:28:04 <copumpkin> (objdump output)
14:28:23 <mauke> use two s///
14:29:10 <copumpkin> well the only reason I was giving the regex was to explain to people what I wanted to do, to see if there was a nicer haskelly way of doing it
14:29:29 <copumpkin> without linking to parsec or the like
14:30:52 <mauke> except your regex doesn't work like that
14:32:40 <copumpkin> mauke: so what would my match data contain there?
14:32:56 <mauke> well, I told you the + is redundant
14:32:59 <copumpkin> (and either way, you get what I mean, so why continue the pedantry? I wrote it on the fly in here without testing it)
14:33:20 <mauke> so you'd get "andeqIr0, r0, r1      "
14:33:29 * hackagebot certificate 0.2 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.2 (VincentHanquez)
14:33:33 <mauke> and that I is supposed to be a tab :-)
14:35:05 <geheimdienst> > dropWhile (/=isLetter) "   0:	00000001 	andeq	r0, r0, r1       ; zomg wtf"
14:35:05 <lambdabot>   <no location info>:
14:35:06 <lambdabot>      lexical error in string/character literal at chara...
14:35:23 <geheimdienst> wat
14:35:32 <mauke> I blame the tabs
14:36:02 <geheimdienst> > dropWhile (/=isLetter) "      0: 00000001         andeq        r0, r0, r1       ; zomg wtf"
14:36:03 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Bool.Bool'
14:36:03 <lambdabot>         agai...
14:36:10 <copumpkin> okay
14:36:14 <copumpkin> to shut mauke up
14:36:20 <geheimdienst> > dropWhile (not . isLetter) "      0: 00000001         andeq        r0, r0, r1       ; zomg wtf"
14:36:21 <copumpkin>  /\s+\d+:\d+\s+(.*)\s+;/
14:36:21 <lambdabot>   "andeq        r0, r0, r1       ; zomg wtf"
14:36:37 <copumpkin> and by that I mean  /\s+\d+:\d+\s+(.*?)\s+;/
14:36:39 <copumpkin> :P
14:36:59 <mauke> that's just ugly
14:37:03 <copumpkin> lol
14:37:07 <mauke> morally ugly
14:37:13 <copumpkin> ANYWAY DAMMIT I WANT A NICE WAY TO DO IT, NOT A NICER REGEX :P
14:37:18 <geheimdienst> > takeWhile (/=';') $ dropWhile (not . isLetter) "      0: 00000001         andeq        r0, r0, r1       ; zomg wtf"
14:37:19 <lambdabot>   "andeq        r0, r0, r1       "
14:37:30 <Kaidelong> go learn SNOBOL?
14:37:38 <ben_m> typesafe regex gogo
14:39:21 <geheimdienst> i think 80% of regex uses could be avoided if we just had trim and split in Prelude
14:41:02 <Kaidelong> why not in something like Data.String geheimdienst?
14:41:13 <fizruk> what do those bang mean? data IntSet= Tip | Bin !!Int !IntSet !IntSet
14:41:14 <steven_t> hi guys
14:41:18 <copumpkin> cause Data.String is designed to have nothing useful in it
14:41:33 <notabel> Data.String.Split (from package split) has splitters and trimmers galore
14:41:34 <Kaidelong> fizruk: it forces the stuff to be evaluated immediately
14:41:51 <Kaidelong> if the bang pattern extension is enabled
14:41:57 <fizruk> Kaidelong: what about double bangs?
14:41:58 <copumpkin> not sure what the double bang on Int is for though
14:42:11 <steven_t> i heard you guys are jerks. thats not true, is it?
14:42:16 <c_wraith> Kaidelong, those don't need the extension, because they're part of a data declaration.  the extension is for patterns
14:42:28 <Kaidelong> ok
14:42:29 <c_wraith> steven_t, yes, we're jerks
14:42:32 <steven_t> o
14:42:47 <copumpkin> steven_t: having random people come in here and accuse us of being jerks might cause us to be more jerky than normal though :)
14:43:07 <copumpkin> probably not though
14:43:25 <copumpkin> we're usually pretty troll-proof
14:43:37 <c_wraith> or else we helpt the trolls get better.
14:44:18 <fizruk> does double bang stand for "evaluate this immidiately! twice!" ?
14:44:19 <copumpkin> steven_t: so, have any good questions for us to answer, about haskell this time? :)
14:44:27 <copumpkin> fizruk: not a clue, actually :)
14:45:09 <djahandarie> Make sure to double-bang zombified haskell code
14:45:27 <kyagrd> > [] !! 1
14:45:28 <lambdabot>   *Exception: Prelude.(!!): index too large
14:45:50 <kyagrd> Is this double bang zombified haskell code? or something else?
14:46:16 <Saizan> zombified?
14:46:45 <kyagrd> > let zombie = zombie+1 in [] !! zombie
14:46:47 <notabel> well, haskell-src-exts doesn't think it's valid code
14:46:49 <lambdabot>   mueval-core: Time limit exceeded
14:47:13 <djahandarie> Saizan, well you normally double-tap zombies
14:47:15 <fizruk> mm... in "normal" languages double bang is used to convert smth to bool...
14:47:25 <copumpkin> definitely not here
14:47:42 <mauke> fizruk: only those in which ! means "not"
14:47:49 <fizruk> of course =)
14:47:52 <Twey> And those that have crazy type-systems
14:47:59 <mauke> like haskell
14:48:07 <Twey> Like JS
14:48:24 <mauke> Haskell, Javascript, C, Perl, probably Lisp too
14:48:38 <Twey> (![]+[])[+[]]+(![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]] == "fail".  *That's* a crazy type-system.
14:48:52 <Saizan> ?djinn (Not (Not a)) -> a
14:48:52 <lambdabot> -- f cannot be realized.
14:49:39 <fizruk> how to google "!!Int
14:50:30 <fizruk> it ignores bangs, codesearch does not help =(
14:51:46 <Kaidelong> well check for what kind of extensions are being used fixruk?
14:52:03 <Saizan> where did you find !!Int ?
14:52:30 <Saizan> the (!!) operator is defined in Data.List
14:52:33 <fizruk> m... second
14:52:34 <Saizan> @hoogle (!!)
14:52:34 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:52:35 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:52:40 <djahandarie> (But it isn't a type-level operator)
14:52:42 <dolio> !!T is how haddock displays UNPACK pragmas.
14:52:42 <fizruk> in data type definition\
14:52:51 <dolio> For some reason.
14:56:37 <fizruk> I met !! in some slides about finger trees in definition of IntMap. now looking at source for Data.IntMap, I think !! in slides stands for "{-# UNPACK #-} !"
14:57:01 <c_wraith> fizruk, that's what dolio just said
14:57:31 <fizruk> o, sorry =)
15:02:51 <Cale> I find it strange how Haddock sometimes feels the need to change the way that things are written. The current version doesn't have this bug, but for a while, it was obliterating a bunch of necessary parens in type signatures of higher order functions whose parameters were commented.
15:03:01 <Cale> (like this: http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html)
15:05:02 <vanadium> Man, the encoding package happily converts characters above 127 to ascii, how evil
15:05:30 <Cale> vanadium: What does it do to them?
15:05:38 <dmwit> vanadium: Under which encoding?
15:06:26 <monochrom> apparently under the ascii encoding
15:07:08 <vanadium> It seems to take the eight least significant bits of the unicode codepoint
15:09:20 <dmwit> That's odd.
15:09:25 <vanadium> encodeStrictByteStringExplicit ASCII "λ" -- => Right "\187"
15:09:43 <dmwit> Because encodeable ASCII '\128' returns False.
15:10:24 <dmwit> You're right, the instance for ASCII doesn't satisfy the requirements given in the Encoding class documentation.
15:10:33 <dmwit> This is probably a bug. Would you like to file a patch, or should I?
15:10:33 <monochrom> λ is not ascii anyway
15:10:59 <vanadium> I just started playing around with the package and am not comfortable filing patches. I would appreciate if you could.
15:11:07 <dmwit> No problem.
15:11:10 <vanadium> Thanks.
15:18:05 <monochrom> I lost the battle but won the war. I suggested having 2 HWN people to rotate a long time ago. jfredette is now asking not 2, but 6 to rotate!
15:23:12 <zc00gii> is there any prime factorization function or a function that tests if a number is prime?
15:24:05 <monochrom> yes. not in the standard libs. on the hackage.
15:24:49 <monochrom> http://hackage.haskell.org/package/Numbers seems to suffice
15:25:24 * monochrom forks it and calls the new fork Numb3rs
15:25:35 * djahandarie sues monochrom
15:26:08 <c_wraith> oh, hey.  I didn't see this before.  Apple appears to be allowing other source languages again.  Haskell on iphone time?
15:26:21 <djahandarie> Yep I saw that on reddit
15:26:21 <fizruk> who broke hayoo? (
15:26:34 <monochrom> ghc is already in jailbroken iphones
15:26:39 <djahandarie> fizruk, it goes down all the time
15:26:42 <djahandarie> I'm not really sure why
15:27:08 <monochrom> but yeah, could easily submit ghc to app store or something
15:27:08 <fizruk> that makes me sad (
15:27:11 <Adamant> c_wraith: what's the fine print on that?
15:27:25 <c_wraith> I've only seen the press release, not the new license.
15:27:35 <monochrom> fine print: don't download code from the interweb when your app is running
15:27:41 <c_wraith> The press release suggests the only restriction will be "does not download and execute code"
15:28:08 <c_wraith> But press releasees are notably lacking in fine print
15:28:10 <Adamant> monochrom: fine print: Steve Jobs is gassy today, all submitted apps will be given the thumbs-down
15:28:34 <monochrom> http://www.macrumors.com/2010/09/09/apple-opens-app-store-to-third-party-development-tools-publishes-review-guidelines/
15:28:59 <dibblego> I have a line comment (-- on line 1) before a module declaration and cabal complains "File name does not match module name: Saw: `Main'" -- is cabal right to complain?
15:29:20 <dmwit> vanadium: If you PM me an email address, I'll CC you on the patch (so you can see when it's applied).
15:33:30 <monochrom> dibblego: (1) comments are legal before module declaration. (2) I just did that to a module, cabal is happy with it.
15:34:16 <dibblego> monochrom, I'll produce an isolated case in a moment -- it's easy to reproduce (cabal-install version 0.8.2 using version 1.8.0.2 of the Cabal library)
15:34:37 <vanadium> 6
15:34:41 <vanadium> err. Sorry.
15:34:43 <monochrom> I'm at 1.8.0.6
15:34:48 <copumpkin> gah, why no Random instance for Word*
15:35:29 <Saizan> i'm pretty sure Cabal doesn't try to parse files at all
15:35:53 <Saizan> *haskell source files
15:35:59 <Saizan> so it's ghc, maybe
15:36:12 <monochrom> Now I'm at cabal-install 0.8.0 and Cabal 1.8.0.2. Still no problem.
15:38:27 <dibblego> I take it back, it wasn't just a line comment
15:38:32 <dibblego> it was -- * this
15:38:41 <dibblego> and it was cabal haddock that was complaining
15:38:50 <dibblego> I'm now at cabal 1.8.0.6
15:38:51 <monochrom> haddock does not like that.
15:39:06 <dibblego> yeah thanks
15:39:23 <monochrom> probably illegal as far as haddock is concerned.
15:39:37 <dibblego> yeah it didn't occur to me because I wasn't intending to haddock
15:39:47 <dibblego> -- * I was just making a point
16:10:42 <fizruk> does anybody know some extensive papers about simulation of functional (or other interesting) features in languages like C/C++/C#/Java?
16:11:18 <dibblego> there is http://functionaljava.org/ but that is not a paper
16:12:27 <fizruk> doesn't matter, thanks =)
16:12:38 <dibblego> I've also done some with C#
16:12:43 <dibblego> and Python
16:13:26 <Adamant> laziness is usually accomplished with thunks and delay functions.
16:14:07 <Adamant> function pointers let you kinda-sorta pass functions around in a vaguely-approximating-first-class manner
16:14:26 <Adamant> Tail Cail Optimization can be emulated with a mini-interpreter
16:14:50 <fizruk> I am precisely interested in what is that minimum set of features that can give me maximum expressiveness )
16:14:56 <Adamant> (I think Clojure uses that in the absence of a JVM TCO instruction)
16:15:22 <Adamant> fizruk: adding guaranteed TCO to a language is usually important.
16:15:47 <fizruk> TCO == tail call optimization, right? )
16:15:54 <Adamant> yup.
16:16:33 <Adamant> there are deep mathematical similarities between SSA (standard optimization format for imperative languages) and CPS (more standard for functional languages)
16:16:48 <Adamant> Single Statement Assignment, Continuation-Passing Style
16:17:48 <Adamant> anyway, having a guaranteed TCO mechanism makes things much, much easier for both implementers and programmers trying to do functional stuff, even if it's not the default.
16:17:49 <fizruk> i've thought about typeclasses and GADTs... how could they be implemented in imperative OO language?
16:17:50 <acowley> I think it's usually referred to as static single assignment
16:18:04 <Adamant> acowley: you're right
16:19:01 <roconnor> fizruk: dictionary passing?
16:19:02 <acowley> fizruk: interfaces and overloaded constructors? Many of the static guarantees on GADTs will be hard to get
16:19:30 <copumpkin> GADTs are my favorite thing ever!
16:19:34 <copumpkin> along with the dependent forms of them
16:19:38 <fizruk> =)
16:21:40 <dibblego> fizruk, Scala is an imperative language on the JVM that has type-classes
16:24:07 <simplesimon2k> Scala has typeclasses?
16:24:24 <dibblego> yes (implicit keyword)
16:24:45 <simplesimon2k> ok, so you can fake it ;D
16:24:56 <dibblego> implicit is more powerful than type-classes :)
16:25:17 <simplesimon2k> but you have to build your own dictionaries
16:25:37 <dibblego> you do nothing more than you do for type-classes
16:26:11 <dibblego> a function of type Eq a => a -> ... can also be used as Eq a -> a -> ... that's the only real difference
16:26:25 <fizruk> what's with GADTs in Scala? )
16:26:28 <simplesimon2k> ok
16:27:37 <simplesimon2k> dibblego: what about axiomatic instances
16:30:56 <carter> dibblego : yeah, the implicit key word gives you a lot more to play with
16:31:24 <carter> like... you can actually sensibly try to approach a numerical / algebraic hierarchy that 
16:31:31 <carter> lets you do both symbolic and numerical work
16:31:39 <dibblego> I wouldn't go that far
16:31:54 <carter> dibblego : i mean compared with how you'd do it with haskell
16:32:08 <carter> because type classes don't quite have the needed machinery (yet)
16:32:12 <dibblego> simplesimon2k, I'm not sure what you mean exactly
16:32:42 <simplesimon2k> i mean instances of the form (C1 t, C2 t, ...) => C3 t
16:33:00 <dibblego> that's not as powerful unfortunately
16:33:05 <simplesimon2k> ok
16:34:47 <tommd> Wahoo, Hash instances
16:36:19 <fizruk> i'm missing something... what's "implicit keyword" you are talking about?
16:37:22 * hackagebot pureMD5 2.0.0.0 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  http://hackage.haskell.org/package/pureMD5-2.0.0.0 (ThomasDuBuisson)
16:37:26 <dibblego> fizruk, Scala uses the implicit keyword to implement implicit dictionary passing (type-classes) http://code.google.com/p/scalaz/ is an example usage 
16:38:49 <dmwit> dibblego: Hm, interesting, you can explicitly pass dictionaries?
16:38:55 <dmwit> How would that work for, e.g., Set?
16:39:13 <dmwit> What would happen if you passed different instances on different invocations (but using the same actual piece of data)?
16:39:15 <dibblego> dmwit, you mean can you explicitly pass Ord?
16:39:21 <dibblego> if so, then yes
16:39:28 <m3ga> blackh: you celebrating yet?
16:39:51 <dmwit> dibblego: Is there any protection...?
16:39:52 <tommd> Right after he's done scuttling his plans to destroy apple.
16:39:54 <simplesimon2k> dmwit: you can try it in ghc, there is an extension for implicit parameters
16:39:56 <simplesimon2k> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#implicit-parameters
16:39:56 <blackh> m3ga: Damn. I thought that news would be the end of people asking me questions about it. :)
16:40:00 <dibblego> dmwit, protection?
16:40:26 <dmwit> At risk of repeating myself... what would happen if you passed different instances on different invocations (but  using the same actual piece of data)?
16:40:44 <blackh> m3ga: Well, I'm very happy about Apple removing those restrictions.  Definitely one less thing to worry about.
16:40:59 <dibblego> you'd get different outcomes and nothing prevents this
16:41:18 <dmwit> nasty =)
16:41:41 <simplesimon2k> just like explicit function parameters ;D
16:41:46 <blackh> m3ga: Haskell loud and proud!
16:41:56 <dmwit> simplesimon2k: Yes, I could try it... if I wanted to re-implement every class instance. =P
16:42:04 <m3ga> blackh: preach it!
16:42:40 <dmwit> simplesimon2k: just like explicit parameters, yes, but unlike, for example, plain old classes
16:42:59 <Adamant> (I wonder if SPJ can juke like the Godfather of Soul)
16:44:32 <Cale> I wonder who is responsible for the haddock and new-www.haskell.org stylesheets. I'd like to request some minor tweaks to the link colours to make them more readable.
16:44:45 <acowley> Getting past writer's block is the worst. Code > papers.
16:45:08 <rschnck> I'm trying to write a function that removes all duplicates from a list. I'm trying to spilt it up, so I wrote a function that removes a integer from a list (i.e. removeAll 5 [1,3,4,5,5,7,5] outputs [1,3,4,7]
16:45:15 <rschnck> Not sure where to take it from here
16:45:27 <dmwit> rschnck: Did you know there's a standard function to do that?
16:45:37 <rschnck> dmwit: Doesn't matter, it's a exercise :P
16:45:39 <acowley> rschnck: Break down how it should work while walking down the list
16:45:41 <dmwit> (Re-implementing it yourself is perfectly reasonable, I just wanted to check.)
16:45:43 <dmwit> yeah, okay
16:45:43 <Cale> rschnck: Well, break it into two cases
16:46:09 <Cale> rschnck: Either the list is empty, in which case the result will be an empty list as well
16:46:18 <kmc> oh, Apple dropped the iPhone language restrictions?
16:46:20 <Cale> rschnck: Or, it will be a nonempty list with a first element: (x:xs)
16:46:35 <rschnck> Well I was thinking I could somehow use removeAll and "count" how many times it does so...
16:46:40 <Cale> rschnck: The tail of the list, xs, *may* contain the element x
16:47:01 <acowley> kmc: Yes, just no downloading of code.
16:47:13 <Cale> But you presumably want to keep the first of each set of duplicates, yeah?
16:47:15 <acowley> rschnck: why do you want to count?
16:47:32 <acowley> rschnck: does the number matter or just that it's <= 1?
16:47:36 <Cale> If so, then this means you know that the first element of the result is x
16:47:47 <rschnck> Cale: Yeah. So you should regard the lists like so: [1:[2:[3:[4]]]]
16:47:50 <kmc> i like that Apple is presumptuous enough to declare a distinction between "downloading code" and "using data from the network"
16:47:50 <Cale> So  removeDuplicates (x:xs) = x : ...
16:47:54 <rschnck> And for each head, test for duplicates?
16:48:00 <dmwit> rschnck: More correctly, 1:2:3:4:[].
16:48:07 <rschnck> Oops :P
16:48:09 <Cale> rschnck: With round parens in place of your square brackets
16:48:21 <Cale> 1 : (2 : (3 : (4 : [])))
16:48:42 <kmc> :t [1:[2:[3:[4]]]]
16:48:43 <rschnck> OKay, I think I know how now
16:48:43 <lambdabot> forall t. (Num [[t]], Num [t], Num t) => [[[[t]]]]
16:49:06 <Cale> rschnck: So yeah, what you'll want to do is ensure that xs has no duplicates, and ensure that it has no occurrences of x
16:49:28 <acowley> kmc: They have a person who says, "That's code... and that over there is data." 
16:50:12 <acowley> kmc: they like the classic definition of pornography ("I know it when I see it") so much that they're applying it everywhere they can
16:50:14 <hpc> is Num t => [t] an instance of Num?
16:50:32 <Cale> hpc: Not by default
16:50:40 <hpc> it would be a cool instance to have
16:50:52 <megajosh2> [1] + [2] == [3]?
16:51:00 <hpc> yeah
16:51:13 <hpc> and [0, 1] + [1] = [1,1]
16:51:18 <acowley> hpc: I think it's a little too ambiguous. Rather like List vs ZipList.
16:51:22 <Cale> The more interesting thing is what to do about multiplication.
16:51:23 <megajosh2> Hmm... add them like they're matrices?
16:51:26 <hpc> and [maxBound] + [1] = [0,1]
16:51:47 <hpc> more like a number in base *range of type*
16:51:59 <Cale> oh, that was actually one which I wasn't even considering
16:51:59 <kmc> hpc, http://www.haskell.org/haskellwiki/Blow_your_mind#Polynomials
16:51:59 <megajosh2> [1,2,3] * [4,5,6,7] == [4,10,18,0]?
16:52:09 <Cale> I was thinking of polynomial multiplication
16:52:21 <Cale> [a,b,c] ~= a + b x + c x^2
16:52:30 <hpc> ooh
16:52:32 <fizruk> dmwit: scala's implicit looks strange a bit ) i can't get why it is more powerfull than typeclasses...
16:53:00 <kmc> fizruk, because you can locally re-bind an implicit
16:53:05 <kmc> imagine "instance" within "let" or "where"
16:53:20 <Cale> There's also liftM2 (*) as an option
16:53:29 <kmc> fizruk, there have been a few good articles about implicits on Lambda the Ultimate recently
16:53:42 <Cale> Probably a more consistent option for lists.
16:54:00 <kmc> see also http://lambda-the-ultimate.org/node/3837 fizruk
16:54:03 <hpc> yeah, and make the Num instance a sort-of functor
16:54:23 <hpc> (numericOperation) = fmap (numericOperation)
16:54:23 <Cale> Since with the polynomial view, [], [0], [0,0], etc. all represent the same polynomial, but are different lists.
16:55:00 <elliotstern> I'm currently taking a Cryptography course, and I'm trying to do some of my homework in Haskell.  One of the homework problems is to decrypt a ciphertext encrypted via a Substitution cipher, so I'm trying to write a function that takes in a Data.Map (i.e. the key ) and a cipherText, and spits out "decrypted" (i.e. jibberish till I find the right key) result.  My problem is that Data.Map has...
16:55:02 <elliotstern> ...a lookup function that returns Maybe a, and I don't know how to, within the substitution function, dispatch based on whether it returns Just or Nothing.  Should I write a helper method, use a different approach, or what syntax should I look into?
16:55:19 <Cale> With various extensions, you can write an instance (Num a, Monad m) => Num (m a) -- probably you'd really just want a newtype wrapper for that
16:55:27 <kmc> elliotstern, you can use "case"
16:55:32 <kmc> case foo of Just x -> ...; Nothing -> ...
16:55:40 <rschnck> Is this some sort of "except" operation?
16:55:47 <rschnck> I have: removeDuplicates :: [Int] -> [Int]
16:55:47 <rschnck> removeDuplicates [] = []
16:55:48 <rschnck> removeDuplicates (x:xs) | x == head xs = removeDuplicates(x:(tail xs)) | otherwise = x:(removeDuplicates xs)
16:55:54 <fizruk> kmc: thanks! i'm one step futher on my way to conquer the world =)
16:56:02 <rschnck> But it fails on the last integer of the list since head [] is invalid
16:56:02 <roconnor> @type fromJust
16:56:03 <lambdabot> forall a. Maybe a -> a
16:56:10 <Cale> rschnck: Don't use the head and tail functions
16:56:13 <roconnor> -- use with extreme caution
16:56:13 <kmc> rschnck, «foo | otherwise» is equivalent to "foo".  also "tail xs" isn't a valid pattern
16:56:17 <dmwit> :t concatMaybes
16:56:17 <lambdabot> Not in scope: `concatMaybes'
16:56:21 <dmwit> :t catMaybes
16:56:21 <lambdabot> forall a. [Maybe a] -> [a]
16:56:23 <hpc> use (x:y:ys)
16:56:26 <kmc> rschnck, "otherwise" only makes sense as the last guard of a sequence of more than one guard
16:56:27 <hpc> as your pattern
16:56:29 <rschnck> kmc: why isn't it valid?
16:56:35 <rschnck> hpc: Mmk :3
16:56:39 <dmwit> elliotstern: That one, if you're feeling quick and dirty. =)
16:56:42 <kmc> rschnck, why would it be valid?
16:56:50 <kmc> rschnck, you can't pattern match on whether a particular function was applied
16:56:52 <rschnck> kmc: tail xs = tail of the list xs D:
16:56:53 <kmc> you can pattern-match on constructors
16:56:54 <Cale> removeDuplicates (x:xs) = x : ...
16:56:59 <Nereid> kmc: he's not pattern matching on tail xs
16:57:05 <hpc> head and tail are largely for pointlessness (pointfree :P)
16:57:05 <Cale> You *know* that the result will contain x
16:57:18 <Cale> So it's important to get that out of the way
16:57:20 <kmc> oh
16:57:22 <kmc> i think i misread the code
16:57:23 <rschnck> Well how do I write head xs...without head?
16:57:25 <kmc> beacuse it was all on one line
16:57:29 <Cale> rschnck: Pattern match
16:57:31 <kmc> rschnck, by matching (y:ys) instead of xs
16:57:37 <Cale> rschnck: x is the head of the list (x:xs)
16:57:38 <kmc> rschnck, sorry, i misread your code earlier
16:57:39 <Nereid> rschnck: question. are you trying to remove all duplicates, or just consecutive ones?
16:57:42 <Cale> rschnck: xs is the tail
16:57:44 <rschnck> kmc: No problem
16:57:52 <rschnck> so I shuold have x:y:ys?
16:57:55 <Cale> You don't need to match any more deeply than that here
16:57:55 <kmc> probably
16:58:05 <Nereid> because yours would only remove consecutive duplicates
16:58:16 <Cale> Unless you're only interested in removing consecutive duplicates, yeah.
16:58:21 <rschnck> Nereid: Oh, crap
16:58:24 <rschnck> You're right =[
16:58:37 <kmc> elliotstern, see also functions 'maybe' and 'fromMaybe'
16:58:54 <Cale> rschnck: Don't despair, your code is actually a good bit more complicated than the correct code, so you only have to make things simpler :)
16:59:03 <Nereid> hmm
16:59:12 <rschnck> Cale: Hah, let's see
16:59:12 <Nereid> let me see if nub is implemented like how I think it is
16:59:13 <monochrom> that is the hard part. make things simpler
16:59:37 <monochrom> I mean emotionally hard, of course. People don't want to delete code when it comes to that.
16:59:40 <Cale> rschnck: Let's look at why  removeDuplicates (x:xs) = x : xs  is wrong, and eliminate what's wrong with it.
16:59:41 <Nereid> yup, it is.
16:59:49 <elliotstern> kmc: thanks, that seems to do what I want
17:00:06 <Cale> rschnck: First of all, xs might contain x.
17:00:22 <Cale> rschnck: You already have a function to remove occurrences of an element from a list though, right?
17:00:28 <rschnck> Yes.
17:00:40 <rschnck> Oh
17:00:41 <rschnck> I get it
17:00:51 <Cale> rschnck: So we can try  removeDuplicates (x:xs) = x : removeOccurrences x xs
17:00:52 <rschnck> You just remove all x from xs
17:00:58 <Cale> But this is still not quite right
17:01:09 <Nereid> why not?
17:01:12 <Cale> Because removeOccurrences x xs might contain duplicates of some other element
17:01:12 <geheimdienst> > remove 'x' "xs"
17:01:13 <lambdabot>   Not in scope: `remove'
17:01:15 <Nereid> oh
17:01:16 <Nereid> right
17:01:18 <Nereid> duh
17:01:30 <Cale> So, we use the function which removes duplicates from that list
17:01:34 <Cale> (the one that we're writing)
17:01:34 <Nereid> >delete 'x' "xs"
17:01:40 <Nereid> > delete 'x' "xs"
17:01:40 <lambdabot>   "s"
17:01:46 <Cale> removeDuplicates (x:xs) = x : removeDuplicates (removeOccurrences x xs)
17:01:51 <Nereid> but that only removes the first occurrence
17:01:59 <Nereid> (I'm talking about delete)
17:02:16 <rschnck> Okay, that makes perfect sense
17:02:19 <rschnck> Thanks :D
17:02:23 <Nereid> :)
17:02:58 <Nereid> rschnck: there is a prelude function called "nub" which removes duplicates from a list
17:03:04 <Nereid> just so you know
17:03:05 <Nereid> :)
17:03:17 <rschnck> Thanks, but we're just palying around with Haskell
17:03:21 <Nereid> yeah that's cool
17:03:26 <Cale> Actually, nub is in Data.List
17:03:29 <rschnck> I don't think we'll ever get to the point to where it's "functional"
17:03:31 <Nereid> oops, sorry
17:03:34 <Nereid> yeah, not prelude.
17:04:10 <Nereid> and you can implement removeOccurrences directly or by using filter
17:04:31 <Nereid> > filter (not . (==) 2) [1,2,3,2,4]
17:04:32 <lambdabot>   [1,3,4]
17:04:58 <Cale> > (length "filter (/= x) xs", length "removeOccurrences x xs")
17:04:58 <lambdabot>   (16,22)
17:05:19 <Nereid> oh duh, (/=)
17:05:19 <Nereid> :P
17:06:29 <Cale> It's actually short enough that you probably wouldn't bother defining a special function to do it under normal circumstances :)
17:06:57 <hpc> not to mention that it can be made pointfree
17:07:07 <hpc> @pl \x xs -> filter (/= x) xs
17:07:07 <lambdabot> filter . (/=)
17:07:17 <Cale> Indeed
17:07:19 <hpc> whoa, that's simpler than i expected
17:07:28 <hpc> and in retrospect, obvious
17:07:37 <Nereid> heh
17:08:24 <Nereid> > map length ["filter . (/=)", "removeOccurrences"]
17:08:24 <lambdabot>   [13,17]
17:08:56 <Cale> In general the first may require some parens though
17:09:36 <hpc> or ($)
17:09:48 <Cale> Well, $ will work for one parameter
17:10:00 <hpc> > filter . (/=) $ 'x' "xxblaxhxx!x"
17:10:00 <lambdabot>   Couldn't match expected type `t -> a'
17:10:01 <lambdabot>         against inferred type `GHC.Ty...
17:10:01 <Cale> But since it associates the wrong way, we can't use it for 2
17:10:06 <hpc> > filter . (/=) $ 'x' $ "xxblaxhxx!x"
17:10:07 <lambdabot>   Couldn't match expected type `a -> b'
17:10:07 <lambdabot>         against inferred type `GHC.Ty...
17:10:15 <hpc> ah, poo
17:10:28 <Cale> (One of the stupidities of the Prelude that I'd like to correct)
17:10:45 <Nereid> yeah, because a $ b $ c === a . b $ c
17:10:47 <Nereid> :(
17:11:02 <Nereid> one could remove the spaces to get filter.(/=) no?
17:11:11 <Nereid> > (filter.(/=)) 'a' "abca"
17:11:11 <Cale> yeah
17:11:12 <lambdabot>   "bc"
17:11:25 <hpc> yeah; it can be confusing though
17:11:40 * hpc avoid it, but sees it somewhat often
17:11:43 <hpc> +s
17:11:59 <Cale> I also wish that '.' was never used for the module path separator.
17:12:09 <Cale> But it's too late to fix that one.
17:12:22 <hpc> there isn't a nice alternative either
17:12:27 <Cale> I wouldn't mind |
17:12:33 <acowley> Why do you think ($) associates the wrong way?
17:12:34 <monochrom> /
17:12:36 <geheimdienst> Control/Monad/Lolcats
17:12:44 <hpc> that shadows division
17:12:47 <Cale> acowley: Because function application always associates to the left
17:12:51 <acowley> Isn't the point in it that it associates the opposite way from regular juxtaposition?
17:12:55 <geheimdienst> (also offers copy-paste-ability from the file system)
17:13:03 <Cale> acowley: No, the point is that it has low precedence
17:13:05 <monochrom> all associations are wrong
17:13:24 <Cale> ace2001ac: Whenever you write f $ g $ h $ x currently, you'd be better off writing f . g . h $ x
17:13:34 <Cale> er, acowley rather
17:13:36 <hpc> having a mandatory 'as' clause for qualified imports would be interesting
17:13:45 <acowley> Cale: I do write it as f . g . h $ x :)
17:14:09 <Cale> acowley: Right, so there's no point in it associating to the right, since you never use more than one in a given expression anyway
17:14:46 <hpc> it would eliminate '.' in that usage outside the import itself
17:14:47 <acowley> Cale: I see what you're saying.
17:14:52 <Cale> acowley: But if it associated to the left, we could remove parens from more expressions, and it would encourage the good compositional style that we already use.
17:15:18 <acowley> Cale: I could have sworn I'd used the right associativity of ($) before, but I can't think how now
17:15:39 <dolio> People always say that.
17:15:47 <dolio> But they're wrong. :)
17:16:02 <Cale> f $ g $ h $ x is worse than f . g . h $ x (even though they're equivalent), because, for example, f $ g will be meaningless (typically), while f . g is a well-typed expression.
17:16:56 <Cale> (this with right associative $ as it is now)
17:17:07 <copumpkin> > printf "%#08x" 5
17:17:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:17:08 <lambdabot>    `Text.Printf.PrintfType ...
17:17:13 <copumpkin> > printf "%#08x" (5 :: Int) :: String
17:17:14 <lambdabot>   "*Exception: Printf.printf: bad formatting char #
17:17:19 <copumpkin> > printf "%08x" (5 :: Int) :: String
17:17:19 <lambdabot>   "00000005"
17:17:25 <dibblego> coincidentally, I spent an hour explaining that at our haskell course recently
17:17:34 <hpc> f . g $ x $ y is an idiom i would love to have
17:17:41 <geheimdienst> > printf "%08x" (5 :: Int)
17:17:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:17:42 <lambdabot>    `GHC.Show.Show a'
17:17:43 <lambdabot>      a...
17:17:44 <Cale> Me too
17:18:00 <geheimdienst> *cough* this printf thingy seems less useful than it could be
17:18:01 <Cale> It would also help make $! more useful
17:18:15 <hpc> so why has no one made a patch for Prelude yet?
17:18:16 <dolio> The worst part is: they made $ right-associative in the Agda standard library to mimic Haskell.
17:18:19 <dibblego> what would it mean exactly to have such an idiom?
17:18:22 <dmwit> geheimdienst: No, it's more useful than it could be.
17:18:22 <Cale> Currently if you want to use $! with more than one parameter, you have to go through painful contortions.
17:18:36 <dmwit> geheimdienst: It's simultaneously printf, sprintf, and hprintf.
17:18:49 <Cale> dibblego: f . g $ x $ y = (f . g) x y
17:19:09 <hpc> or f (g x y)
17:19:17 <dibblego> yes but what language feature would make it better?
17:19:30 <Cale> hpc: f (g x) y
17:19:32 <hpc> not make it better, but possible
17:19:45 <hpc> Cale: ah, right
17:19:52 <dibblego> I'm clearly missing something
17:19:53 <Cale> For example, our filter . (/=) $ x $ xs  from before
17:20:08 <hpc> actually, that looks like a continuation, i think
17:20:13 <hpc> f (g x) y
17:20:20 <Cale> (Not that I'd actually recommend it exactly in this situation)
17:20:37 <Cale> The operator section is obviously more readable
17:20:44 <Cale> filter (/= x) xs
17:21:10 <Cale> But it's nice to be able to apply points-free things with multiple parameters without needing more parens
17:21:35 <dolio> f w $ g x y $ h z
17:21:38 <monochrom> > printf "%08x" (5 :: Int) :: String
17:21:38 <lambdabot>   "00000005"
17:21:55 <monochrom> a type is needed because there is also...
17:22:00 <monochrom> > printf "%08x" (5 :: Int) :: IO ()
17:22:00 <lambdabot>   <IO ()>
17:22:21 <hpc> why the Int signature?
17:22:31 <hpc> > printf "%08x" 5 :: String
17:22:32 <lambdabot>   "00000005"
17:22:35 <dolio> if' $ x == y $ f z1 $ g z2
17:22:54 <monochrom> a type is need in theory, not needed in practice because if you write do { putStrLn "hello"; printf "%08x" (5 :: Int) } everyone knows how to infer the type.
17:23:28 <monochrom> you cannot judge a haskell function without context.
17:23:58 <monochrom> the repl is particularly confusing
17:24:11 <monochrom> s/confusing/misleading/
17:24:17 <hpc> no, i mean the type you used for '5'
17:24:24 <monochrom> s/misleading/misrepresenting/
17:24:24 <hpc> not the whole expression
17:24:35 <hpc> s/s\///
17:24:39 <monochrom> I am lagged. Please wait.
17:24:39 <hpc> :P
17:25:11 <monochrom> > printf "%08x" 5 :: String
17:25:12 <lambdabot>   "00000005"
17:25:21 <monochrom> perhaps not needed
17:25:42 <c_wraith> > printf "%08x" 5 :: IO ()
17:25:43 <lambdabot>   <IO ()>
17:25:45 <dons> tommd: why does crypto-api depend on old cereal?
17:25:51 <tommd> old cereal?
17:25:57 <dons> 0.2.*
17:26:03 <dons> current release is 0.3.*
17:26:14 <dons> http://hackage.haskell.org/package/crypto-api-0.0.0.2
17:26:28 <tommd> dons: I didn't know 0.3 was out till earlier today
17:26:35 <dons> ah
17:26:38 <tommd> dons: And I was conservative on the upper bound
17:26:43 <dons> yes, that's fine.
17:26:53 <dons> hackage doesn't make it easy to know that a dep has been bumped
17:26:59 <tommd> I'll fix.  Will probably release 0.0.0.3  some time next week.
17:27:16 <tommd> cereal >= 0.2 && < 0.4
17:27:32 <dons> http://aur.archlinux.org/packages.php?ID=40679 in arch now
17:27:38 <tommd> great
17:27:50 <tommd> pureMD5 2.0 uses crypto-api and I just sent a patch to vincent for cryptohash instances
17:27:55 <dons> yup.
17:28:23 <tommd> Vincent's been busy - lots of crypto libraries being pumped out by him.  Makes me curious
17:29:06 <monochrom> he has found out how to have the packages write themselves
17:29:22 <dons> http://aur.archlinux.org/packages.php?ID=17458
17:29:24 <dons>  puremd5 updated
17:29:47 <dons> almost beer time. bailey's, tommd?
17:30:13 <tommd> Humm, be there in ~ 30 minutes
17:30:20 <dons> oh, already had plans?
17:30:50 <tommd> no, no plans.  Megan and Theresa are even out of town so without a little one trying to crawl under my chair I'm at a loss for what to do (oh yeah, that PhD thing)
17:30:54 <monochrom> "will dump gf for beer. just give me 30 minutes"
17:30:57 <dons> hey nice.
17:31:09 <dons> ok. see you at 6.ish
17:31:54 <geheimdienst> > printf "%x" 6ish :: String
17:31:55 <lambdabot>   Not in scope: `ish'
17:32:08 <geheimdienst> bah
17:32:39 <monochrom> you need nondeterminism to represent 6ish.
17:32:57 <geheimdienst> -XNondeterminism?
17:33:20 <hpc> @let ish = 0.5 +
17:33:20 <lambdabot>   Parse error in expression: PostOp (Lit (Frac (1 % 2))) (QVarOp (UnQual (Sym...
17:33:27 <hpc> @let ish = (0.5 +)
17:33:28 <lambdabot>  Defined.
17:33:32 <hpc> solved!
17:33:35 <monochrom> -XTypeDirectedAutomaticNondeterminism
17:33:54 <geheimdienst> > 6ish
17:33:55 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:33:56 <lambdabot>    `GHC.Real.Fractional t'
17:33:56 <lambdabot>  ...
17:34:04 <monochrom> > ish 6
17:34:05 <lambdabot>   6.5
17:34:18 <monochrom> speak like yoda you will
17:34:19 <geheimdienst> oh yeah, "ish 6" is great
17:34:34 <dmwit> > (6 `ish`)
17:34:35 <lambdabot>   6.5
17:34:43 <geheimdienst> "when ish seven you reach, not as sober you will look"
17:34:54 <monochrom> hehehe
17:36:38 <duckinator> hi
17:36:56 <monochrom> -XTypeDirectedIsh
17:37:08 <hpc> :D
17:37:11 <mm_freak> > let x = 1 in 6x
17:37:12 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:37:12 <lambdabot>    `GHC.Num.Num t' arising f...
17:37:21 <mm_freak> > let x = 1 :: Int in 6x
17:37:22 <lambdabot>   6
17:37:42 <mm_freak> but unfortunately with x = 2 it won't work =)
17:38:11 <monochrom> > let x=2::Int in 6x
17:38:12 <lambdabot>   6
17:38:13 <geheimdienst> and it throws no error only because of lambdabot's funkyness. i've learned that by now
17:38:19 <monochrom> I see
17:38:40 <geheimdienst> > 6 3
17:38:41 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:38:41 <lambdabot>    `GHC.Num.Num t' arising f...
17:38:49 <geheimdienst> > 6 3 :: Int
17:38:50 <lambdabot>   6
17:39:04 <dolio> > 6 3 3 3 3 3 3 :: Int
17:39:05 <lambdabot>   6
17:39:08 <geheimdienst> ^^ no worky in ghci
17:39:34 <hpc> instance Num a => Num (a -> a) where fromIntegral = const
17:39:35 <monochrom> lambdabot is not ghci
17:39:40 <hpc> etc
17:40:14 <hpc> > 6 undefined :: Int
17:40:15 <lambdabot>   6
17:40:23 <hpc> > 6 undefined undefined undefined:: Int
17:40:24 <lambdabot>   6
17:40:27 <hpc> :D
17:40:44 <dolio> Num a => Num (b -> a)
17:40:46 <hpc> > 6 True :: Int
17:40:47 <lambdabot>   6
17:40:50 <hpc> ah
17:40:53 <hpc> freaky
17:41:33 <hpc> also rather hilarious
17:42:10 <monochrom> haskell tends to be freaky and hilarious
17:42:32 <hpc> indeed; that is half of what led me to the language
17:42:56 <geheimdienst> if freaky and hilarious are half, what are the other two adjectives?
17:42:57 <hpc> the other half was seeing berengal go hog wild with it on a forum
17:43:17 <sm> I never thought of GHC as hilarious
17:43:22 <dons> tommd: heading over now.
17:43:30 <sm> it seems a bit more *serious* than that
17:43:31 <tommd> dons: Ok, see yo usoon
17:43:43 <hpc> sm: yes, it is *seriously* funny
17:43:45 <hpc> :P
17:51:35 <sshc> Why isn't IArray defined as an instance of Foldable?
17:51:42 <sshc> I want to fold over an array
17:51:52 <dolio> IArray is a class.
17:51:55 <Mitar> if I have a data Foo = Foo | Bar, can I define a function, which would return type RetFoo if i was called by Foo and RetBar if it was called with Bar? or i have to put those two types into one data? is there some way around?
17:51:57 <monochrom> haha
17:53:30 <dmwit> Mitar: Welcome to dependent types!
17:53:38 <dmwit> (Actually, GADTs are probably enough for this.)
17:53:50 <dolio> Not unless you jump through hoops.
17:54:00 <Veinor> doesn't f Foo = RetFoo; f Bar = RetBar work?
17:54:10 <dmwit> Veinor: RetFoo and RetBar are types.
17:54:24 <Veinor> ah
17:54:44 <Mitar> so there is a way?
17:54:46 <Mitar> how how ;-)
17:54:52 <dmwit> Learn Agda. =)
17:55:04 <Mitar> in haskell?
17:55:16 <dolio> Theoretically (I think) you can mimic arbitrarily complex dependent types with GADTs and type-level shenanigans. But it isn't pretty.
17:55:42 <Mitar> examples? links?
17:55:55 <Mitar> too much unknown terminology
17:56:23 <geheimdienst> mitar, could you tell us a little more about what you're trying to do?
17:57:09 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29841#a29841
17:57:12 <Mitar> will do? ;-)
17:57:49 <Mitar> so i have two types of Nerves, one which can accept wrapped impulse and the other which can accept only one kind of them
17:57:54 <Mitar> (type of them)
17:58:20 <Saizan> data Foo a where Foo :: Foo RetFoo; Bar :: Foo RetBar; f :: Foo a -> a; ...
17:58:29 <Mitar> now sendFromNeuron function is nice, it works whichever type of Nerve you have
17:58:54 <Mitar> but getFromNeuron function is ugly, as you have to check what is return type
17:59:39 <Mitar> the point is that i would like that compiler at compile time checks that if i use Nerve which accepts any type I use result as such type, and if I use Nerve which accepts just specific type that I use the result as such
18:00:53 <Mitar> currently compiler does not check that in theory my function could return mismatched return type (for Nerve which should return "any" type I would return specific) and then at runtime in case ... of I would have to throw runtime exception
18:02:41 <Mitar> it seems stupid to me that I have to make a special data just to case ... of unwrap it and at runtime find out there is not what I expected in
18:03:21 <ezyang> Is trac.haskell.org down? 
18:04:07 <Mitar> seems so
18:04:16 <Mitar> have i explained good enough?
18:10:50 <sshc> dolio: IArray's Array
18:10:59 <sshc> dolio: Isn't here a standard fold or it?
18:11:06 <sshc> for it?
18:11:30 <dolio> @instances-importing Data.Array Data.Foldable Foldable
18:11:30 <lambdabot> Array i, Maybe, []
18:11:56 <sshc> dolio: Are Data.Array's and Data.Array.IArray's Array different?
18:12:07 <dolio> No.
18:12:10 <EvanR> sshc: wtf my terminal is flashing xD
18:12:13 <sshc> Wonderful.
18:12:24 <Veinor> IArray! IArray! Cthulhu fhtagn!
18:12:26 <sshc> EvanR: Is your computer plugged in?
18:12:33 <EvanR> yes
18:12:41 <EvanR> you sent me a 'flash' control code
18:12:50 <sshc> Did you try rebooting your computer?
18:12:54 <EvanR> no
18:13:05 <Martty> i see it in gray 
18:13:48 <sshc> Aw, I thought "why" was after "wtf" :P
18:14:21 <dankna> Veinor: you made me choke up my soda laughing
18:14:57 <ezyang> +1 Veinor 
18:17:09 <sshc> dolio: Is foldr or foldl more efficient for ARray?
18:17:31 <dolio> Conceivably, they could be implemented equally efficiently.
18:17:37 <dolio> I'm not sure if that's actually done, though.
18:17:56 <dolio> Also, it depends what you're doing.
18:18:06 <sshc> I don't care in which direction I fold; the end result is the same
18:19:00 <dolio> If you use a foldr-like implementation, you can short circuit and save work.
18:19:15 <Martty> is there a difference in speed when comparing for equality than for less than ? talking low level wise
18:19:21 <dolio> A tail-recursive version of either is more efficient in other cases.
18:19:27 <Martty> 2<3 takes more time than 2==3 ?
18:19:32 <dolio> You'll have to look at the source.
18:20:01 <Mitar> hm, so no help how to do that?
18:20:02 * EvanR gets the x86 manual ;)
18:20:10 <EvanR> it lists clock cycles for each
18:20:14 <Martty> nice
18:20:25 <EvanR> im not actually getting the manual
18:20:30 <EvanR> but its freely available
18:20:39 <Martty> wow i had my hopes up for a moment there
18:21:33 <sshc> Um..
18:21:34 <sshc> instance Ix i => Foldable (Array i) where foldr f z = Prelude.foldr f z . elems
18:22:06 <sshc> Apparently foldr is most efficient here
18:22:28 <EvanR> Martty: if you just want the result of those expressions and nothing else (like jumping or something) then it seems bare x86 its the same exact instruction
18:22:31 <EvanR> CMP
18:22:50 <EvanR> if 2 and 3 are Integer though you gotta check GMP
18:32:05 <sm> why does GHC complain FilterSpec is not Hledger.Data.Types.FilterSpec (http://gist.github.com/572905) at line 150 of http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/hledger-web/Hledger/Web.hs , ignoring the perfectly good import at line 28 that's been working fine ?
18:33:19 <blackh> sm: Did you upgrade package B with cabal, where A depends on B, but didn't upgrade A?
18:33:58 <sm> blackh: aha.. I need to do another round of installing these packages perhaps ?
18:34:13 * sm tries that
18:34:16 <blackh> sm: Yes, GHC will say ... "hey, that's not the *same* X!"
18:34:28 <blackh> (even though they have the same name)
18:34:36 <sm> and same version number
18:34:52 <blackh> If it's the same version number then I'm barking you up the wrong tree
18:35:28 <sm> well I could be wrong.. should've looked at ghc-pkg list but too late now
18:37:21 <sm> hmm
18:38:40 <roconnor> @bot
18:38:40 <lambdabot> :)
18:42:24 * ddarius thinks he has succeeded in buying more food than he can comfortably consume, and has succeeded in making an NTFS formatted external USB hard drive bootable.
18:43:23 <Saizan> are the two related?
18:43:28 <sm> blackh: fixed a cabal error preventing install, but it hasn't helped one bit... :/
18:44:58 <sm> hmm.. it must be to do with how I'm compiling.. cabal can build it
18:45:21 <sm> will try again later, thanks for the help
18:49:01 <sm> fixed! by adding one more source dir to ghc's search path. Precise causal connection unclear, but good enough 
18:49:33 <ddarius> Saizan: Not really.  I bought so much food because I haven't eaten today, but that is only in small part due to working on getting the drive bootable.
18:55:13 <ddarius> http://new-www.haskell.org/haskellwiki/Haskell
19:00:45 <carter_> ddarius : what sort of food?
19:00:59 <carter> tasty?
19:01:00 <ddarius> carter_: "Chinese"
19:01:08 <carter> ohhh, delivery
19:01:30 <ddarius> I picked it up.  It is decent for Chinese fast food in America.
19:02:36 <carter> ddarius  is that the new web design?
19:04:00 <carter> i kinda split asian restaurants into the "the meat tastes freshly cooked" vs "reheated"
19:04:02 <carter> categories
19:05:23 <pikhq> carter: Also useful to split into Americanised and not. Mostly for Chinese, though... You're not likely to find variations of other Asian cuisines so completely unauthentic.
19:05:35 * Eridius <3's americanized chinese
19:06:40 <pikhq> I mean, it's not like someone Japanese is going to suspect we're completely and utterly mad upon seeing a California roll. :P
19:06:46 <carter> pikhq truish, but the freshly cooked meet flavor is more important
19:06:58 <carter> *meat
19:11:25 <Adamant> most ethnic cuisine in the US is Americanized to some degree, though, either that or from a obscure minority within the larger culture
19:11:47 <Adamant> US Italian food is heavily suited to US tastes AND pretty Sicilian
19:11:53 <pikhq> Adamant: Yes, but "to some degree", as opposed to "being more of an American cuisine than anything else"...
19:12:36 <pikhq> Though Italian food is a lot like Chinese in that it's mostly an American thing. American pizza, for instance, is *not* that much like Italian.
19:13:24 <pikhq> Hrm. Actually, thinking about it. The degree of Americanisation seems to be correlated with general popularity.
19:14:31 <Adamant> pikhq: it's not that much like mainland, although selected bits of US pizzamaking tend to be pretty similar to Sicilian/Southern Italian stuff.
19:44:14 <tolkad> Is it bad to put this at the top of all my haskell files?
19:44:14 <tolkad> import Prelude hiding ($)
19:44:14 <tolkad> import qualified Prelude
19:44:14 <tolkad> ($) = flip (Prelude.$)
19:44:23 <cch`> how can I get fields names of a data type at runtime?
19:44:23 <tolkad> :T ($)
19:44:26 <tolkad> :t ($)
19:44:27 <lambdabot> forall a b. (a -> b) -> a -> b
19:44:34 <tolkad> :t flip ($)
19:44:35 <lambdabot> forall a b. a -> (a -> b) -> b
19:44:54 <tolkad> nevermind I guess it might be confusing
19:45:11 <cch`> or even declare a data type programmingly?
19:45:31 <tolkad> cch`: why would you ever want to do that?
19:45:41 <tolkad> cch`: those names don't even exist at runtime
19:46:24 <cch`> for example, given a list of fieldnames, declare a datatype accordlingly
19:46:56 <tolkad> cch`: why do you want to do this? your question doesn't make sense
19:46:59 <cch`> i have several list of fieldnames, and want to declare several datatype respectively
19:47:05 <tolkad> cch`: explain why
19:48:00 <tolkad> If you just want a mapping between strings and some type use Data.Map
19:48:47 <tolkad> if you want a mapping between strings and a set of types declare a single datatype with a constructor for each of those types and create a Map from strings to this datatype
19:49:03 <cch`> I want to define a function that do something similarly to these several datatypes
19:49:11 <copumpkin> look into generics in haskell
19:49:26 <ddarius> > toConstr (Just 3)
19:49:27 <lambdabot>   Just
19:49:52 <tolkad> cch`: that wasn't precise, explain what you want to do precisely if you want a precise answer
19:51:21 <cch`> ok, i will look into generics haskell
19:51:42 <tolkad> cch`: http://www.haskell.org/haskellwiki/Research_papers/Generics
19:52:56 <cch`> at times i suppose what i want is to write a function to write datatype declaration for me
19:54:41 <cch`> datatype declaration use fieldnames, and my many other function use those fieldnames as well, and i do not want to repeat write down fieldnames in many places, i.ee. datatype declaration and function definition
19:55:42 <davidL> Is there a pretty printer somewhere for ASTs created by haskell-src(-exts)? I want a pretty printer for the AST itself, not a way to go from AST back to haskell source.
19:56:00 <cch`> i am leaving now, pls leave msg, and thank you all.
19:57:09 <ddarius> cch`: Look at Template Haskell
19:59:34 <JoeyA> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-Monad.html
19:59:41 * JoeyA thinks the 4 functions at the top are rather misplaced
19:59:54 <JoeyA> They're neat, general purpose functions.
20:00:00 <JoeyA> I was about to write my own mapFst
20:00:10 <JoeyA> They're not specific to monadic graph algorithms.
20:00:16 <JoeyA> </gripe>
20:00:29 <copumpkin> Control.Arrow
20:00:38 <copumpkin> :t first
20:00:39 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
20:00:39 <copumpkin> :t second
20:00:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
20:01:17 <copumpkin> mapFst ~~ first,  mapSnd ~~ second, >< ~~ ***
20:01:41 <JoeyA> ah
20:01:47 <JoeyA> > first (+1) (1,2)
20:01:48 <lambdabot>   (2,2)
20:01:57 <JoeyA> > first (const 100) (1,2)
20:01:58 <lambdabot>   (100,2)
20:01:59 <copumpkin> orP can be written using uncurry (||) . (f *** g)
20:02:23 <JoeyA> cool, thanks
20:03:06 <NemesisD> hi all. i'm having one hell of a time getting myself out of imperative programming. i'm trying to form a list which div's some initial int until it reaches 1, taking the mod 2 of each. So far i have [mod x 2 | x <- foldl (div) 9 (repeat 2), x > 0] which doesn't work
20:03:20 <NemesisD> initial int being 9
20:03:50 <copumpkin> hm, that doesn't make much sense :)
20:04:17 <copumpkin> sounds like an unfold
20:04:27 * NemesisD has never heard of unfold
20:04:29 <copumpkin> sounds like you want to convert to binary, honestly :P
20:04:35 * hackagebot ecu 0.0.0 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.0 (TomHawkins)
20:04:36 <copumpkin> it's the opposite of a fold!
20:04:44 <JoeyA> NemesisD: very similar to something I pasted in ##programming:
20:04:44 <copumpkin> a fold takes a list down to a value, an unfold makes a list from a value
20:04:55 <JoeyA> > map (sum . takeWhile (>= 1) . tail . iterate (`div` 2))
20:04:56 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
20:04:56 <lambdabot>    arising from a use ...
20:04:57 <copumpkin> well, not necessarily a list, but in this case :)
20:05:05 <JoeyA> > map (sum . takeWhile (>= 1) . tail . iterate (`div` 2)) [1..10]
20:05:06 <lambdabot>   [0,1,1,3,3,4,4,7,7,8]
20:05:23 <JoeyA> hope that gives you something to work with.
20:05:43 <NemesisD> is there literally an unfold
20:06:06 <copumpkin> :t unfoldr
20:06:07 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:06:10 <JoeyA> http://users.skynet.be/jyp/html/base/Data-List.html#v%3Aunfoldr
20:06:21 <copumpkin> the function tells unfoldr what to do next
20:06:26 <copumpkin> if it returns Nothing, it ends the list
20:06:45 <copumpkin> otherwise, it spits out the first value in the pair and uses the second value as the new state
20:08:00 <JoeyA> Meh, who needs b?  I have unsafePerformIO :D
20:09:14 <JoeyA> Though I guess a (probably lazy) IO-driven unfoldr might be useful:
20:09:27 <JoeyA> unfoldIO :: IO (Maybe a) -> IO [a]
20:09:46 <JoeyA> maybe a state variable would make it easier to use:
20:09:59 <JoeyA> unfoldIO :: (b -> IO (Maybe a)) -> b -> IO [a]
20:10:21 <dolio> > reverse . dropWhile (== 0) . map (testBit 9) $ [31, 30 .. 0]
20:10:22 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
20:10:22 <lambdabot>    arising from the literal `0'...
20:10:24 <copumpkin> that wouldn't really work
20:11:01 <dolio> > reverse . dropWhile not . map (testBit 9) $ [31, 30 .. 0]
20:11:02 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:11:02 <lambdabot>    `Data.Bits.Bits t'
20:11:02 <lambdabot>      a...
20:11:10 <JoeyA> copumpkin: It could use unsafeInterleaveIO, if that's what you're referring to.
20:11:17 <dolio> > reverse . dropWhile not . map (testBit (9 :: Int)) $ [31, 30 .. 0]
20:11:18 <lambdabot>   [True,False,False,True]
20:11:31 <copumpkin> JoeyA: how would it keep its state across calls of the inner function
20:11:49 <JoeyA> are you saying in the unfoldIO :: IO (Maybe a) -> IO [a] form?
20:11:53 <dolio> > reverse . dropWhile not . map (testBit (142857 :: Int)) $ [31, 30 .. 0]
20:11:53 <JoeyA> it could use an IORef
20:11:54 <lambdabot>   [True,False,False,True,False,False,False,False,False,True,True,True,False,T...
20:11:58 <copumpkin> oh I guess you could pass in an IORef in the b
20:11:58 <JoeyA> though that would be less convenient.
20:13:12 <JoeyA> oh, I see where I goofed
20:13:19 <JoeyA> unfoldIO :: (b -> IO (Maybe (a,b))) -> b -> IO [a]
20:13:23 <JoeyA> now we're in business.
20:14:08 <JoeyA> Though that's starting to get deep with the parenthesis.
20:14:17 <copumpkin> :t replicateM
20:14:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
20:14:46 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2003-April/004144.html
20:14:50 <dolio> unfoldIO :: (b -> MaybeT IO (a, b)) -> b -> ListT IO a
20:15:26 <NemesisD> wow i love unfoldr
20:16:55 <JoeyA> note that in IO, replicateM/mapM/forM aren't very nice.
20:17:01 <JoeyA> take 10 <$> replicateM 1000000 (unsafeInterleaveIO $ return 5)
20:17:20 <JoeyA> (the unsafeInterleaveIO is a failed attempt at making the results lazily yielded)
20:17:38 <JoeyA> of course, there's nothing wrong with the mapM_ family.
20:17:54 <Veinor> they're not web scale!
20:17:55 <dolio> You need to interleave in the mapM if you want the result interleaved.
20:18:07 <copumpkin> JoeyA: why not?
20:18:15 <copumpkin> nothing wrong with them
20:18:19 <JoeyA> you mean the mapM needs to be inherently interleaved?
20:18:34 <JoeyA> copumpkin: actually, in IO, they can stack overflow, and they aren't very fast.
20:19:02 <JoeyA> It's actually faster to use a function that builds the list in reverse (by prepending), then reverse it upon completion of the strict actions.
20:19:12 <JoeyA> well, not terribly slow
20:20:16 <dolio> Yes.
20:20:31 <JoeyA> of course, mapM_ doesn't have this problem because it doesn't have to build a list.
20:20:39 <dolio> mapM f (x:xs) = do y <- f x ; ys <- unsafeInterleaveIO (mapM f xs) ; return (y:ys)
20:21:21 <JoeyA> Indeed.
20:21:33 <JoeyA> For strict generation:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29842#a29842
20:21:58 <JoeyA> Those should be faster/safer than the stock mapM etc. for IO.
20:22:27 <JoeyA> err, I didn't use an IORef there; I just built the list in reverse.
20:48:39 <bss03> > sort [3,2,1]
20:48:40 <lambdabot>   [1,2,3]
20:49:08 <bss03> > sortBy (flip compare) [3,2,1]
20:49:09 <lambdabot>   [3,2,1]
20:58:05 <sidek> Is there a way to use the map function for a function with two variables? If so, how? 
20:59:18 <sidek> If there's no way, actually, is there an alternative?
20:59:48 <sidek> I could probably use a list comprehension somehow, actually...
21:00:06 <Cale> sidek: zipWith?
21:00:28 <sidek> Cale: What does zipWith do? I've not heard of that function
21:00:35 <sidek> just learning, and I guess it hasn't been introduced
21:00:38 <Cale> > zipWith (+) [1,2,3,4,5] [10,20,30,40,50]
21:00:38 <lambdabot>   [11,22,33,44,55]
21:00:44 <sidek> alright
21:00:45 <Cale> > zipWith (*) [1,2,3,4,5] [10,20,30,40,50]
21:00:46 <lambdabot>   [10,40,90,160,250]
21:00:51 <sidek> well, no
21:00:55 <sidek> that won't work
21:00:58 <Cale> okay
21:01:04 <Cale> What do you want the function to do?
21:01:17 <Cale> :t map (+) [1,2,3,4,5]
21:01:18 <lambdabot> forall a. (Num a) => [a -> a]
21:01:23 <sidek> it checks to see if x operated on a certain way is equal to m
21:01:40 <sidek> then it checks to see if m operated on a certain way is equal to x
21:01:46 <Cale> okay
21:01:50 <sidek> I've done that and it worked
21:01:57 <sidek> I just don't know how to map it
21:02:08 <Cale> Do you have a list of pairs?
21:02:21 <sidek> no; the pairs are summed at the end if they're equal
21:02:30 <sidek> one number is returned at the end
21:02:36 <sidek> there's just two input methods
21:02:36 <Cale> I still don't think I understand what you're trying to do
21:02:43 <sidek> alright
21:02:44 <sidek> one sec
21:02:51 <Cale> > any even [1,3,5,7,8]
21:02:52 <lambdabot>   True
21:02:54 <Cale> > any even [1,3,5,7,9]
21:02:54 <lambdabot>   False
21:03:00 <Cale> > all odd [1,3,5,7,9]
21:03:01 <lambdabot>   True
21:03:03 <sidek>  amicablepair x m = (if sumdivisors x == m then if sumdivisors m == x then (x+m)  else 0 else 0)
21:03:14 <sidek> probably not the best way to do that
21:03:44 <sidek> sumdivisors is the sum of the divisors 
21:03:51 <Cale> okay
21:03:55 <rschnck> If I wanted to create a function that takes a list a returns the number of occurences most frequent in that list (so [1,2,2,2,3] would output 3)
21:04:14 <rschnck> Would trying to first find a function that creates a list of the number of each identical element in that list be a good approach?
21:04:28 <copumpkin> > length . maximumBy length . group . sort $ [1,2,2,2,3]
21:04:29 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
21:04:29 <lambdabot>         against...
21:04:30 <rschnck> So for [1,2,2,2,3] you'd get [1,3,1]
21:04:43 <copumpkin> > length . maximumBy (comparing length) . group . sort $ [1,2,2,2,3]
21:04:43 <lambdabot>   3
21:04:47 <copumpkin> (inefficient though)
21:05:03 <Cale> > maximum . map length . group . sort $ [1,2,2,2,3]
21:05:04 <lambdabot>   3
21:05:05 <rschnck> copumpkin: It's an exercise, so I'm trying to do it using only basic list functions in the prelude
21:05:12 <copumpkin> Cale: oh, duh
21:05:25 <copumpkin> Cale's is even nicer :(
21:05:27 * copumpkin sulks
21:05:35 * rschnck kills self in inferiority
21:05:47 <Cale> sidek: So, you're trying to find the amicable pairs among some choices?
21:05:57 <sidek> the sums of the amicable pairs
21:06:03 <rschnck> So would that....be a decent approach...?
21:06:04 <sidek> from 1 to 10000
21:06:12 <sidek> then I'm summing them
21:06:20 <Cale> sidek: You could use a list comprehension like [amicablepair x y | x <- [1..10000], y <- [x..10000]]
21:06:33 <sidek> alright
21:06:39 <copumpkin> > 10000^2
21:06:39 <lambdabot>   100000000
21:06:42 <sidek> thanks
21:06:44 <copumpkin> that's a nice number of iterations
21:07:30 <djahandarie> > length [(x,y) | x <- [1..10000], y <- [x..10000]]
21:07:34 <lambdabot>   mueval-core: Time limit exceeded
21:09:23 <mtnviewmark> let xy = [ (i, sumdivisors i) | i <- [1..10000] ], yx = [ (y,x) | (x,y) <- xy ] in union xy
21:09:35 <mtnviewmark> let xy = [ (i, sumdivisors i) | i <- [1..10000] ], yx = [ (y,x) | (x,y) <- xy ] in union xy yx
21:09:40 <mtnviewmark> :t union
21:09:41 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
21:12:02 <copumpkin> mtnviewmark: oh by the way, do you have any idea about evil horizontal scrollbars on docs?
21:12:32 <mtnviewmark> well, which horizontal scroll bars?
21:12:51 <mtnviewmark> (concrete example, pls)
21:14:45 <bos> mtnviewmark: someone posted an example on haskell-cafe yesterday or so
21:15:37 <mtnviewmark> really? searching for "scroll" yields nothing
21:15:59 <copumpkin> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v%3AmapException
21:16:09 <copumpkin> oh actually maybe someone fixed it
21:16:13 <copumpkin> that was giving me a scrollbar yesterday
21:16:21 <copumpkin> the bar at the bottom is very large now though
21:16:35 <copumpkin> http://snapplr.com/9k31
21:17:20 <mtnviewmark> notice at the very bottom: produced by Haddock version 2.6.1
21:17:43 <dmead> @hoogle haskell-src-exts
21:17:43 <lambdabot> Text.Parsec.Language haskell :: TokenParser st
21:17:44 <lambdabot> Text.ParserCombinators.Parsec.Language haskell :: TokenParser st
21:17:44 <lambdabot> package haskell-src
21:17:46 <mtnviewmark> Ross tried to restyle all the existing haddock pages on Hackage to look like the pages that new haddock produces
21:18:01 <mtnviewmark> alas, you can't do that - and I'm hoping he'll agree and revert them all
21:18:18 <copumpkin> ah
21:18:48 <mtnviewmark> perhaps if others felt the same way ... nudge nudge
21:18:52 <mtnviewmark> :-)
21:19:47 <copumpkin> I guess actually rerunning haddock over everything would be very expensive?
21:21:23 <mtnviewmark> no - it is impossible: Many packages in Hackage no longer compile
21:21:25 <mtnviewmark> !
21:21:41 <copumpkin> ah :(
21:21:42 <mtnviewmark> and to run Haddock you need to be able to have the compilation environment running (
21:25:27 <deteego> would anyone have any idea what the dynamic symantics for mutually recursive bindings be (in general)
21:27:11 <lispy> is a symantic like a syntax based semantics?
21:27:40 <lispy> deteego: or maybe I didn't follow your question?
21:27:41 <deteego> static symantics is for syntax
21:27:50 <deteego> dynamic semantics is regarding evaluation/compilation
21:28:19 <carter> deteego do you mean for a language like scheme or like haskell?
21:28:29 <carter> strict vs lazy?
21:28:37 <lispy> deteego: have you read some of the papers by Simon Peyton-Jones about the G machine and STG?  He gives some operational semantics of haskell.
21:28:59 <deteego> carter: strict language, similar to ML
21:29:02 <carter> ok
21:29:13 <carter> deteego I gave someone exactly those links yesterday :)
21:29:20 <carter> let me dig em up
21:30:08 <deteego> its just an evaluator I am doing
21:30:18 <carter> http://www.cs.indiana.edu/~dyb/pubs/letrec-reloaded.pdf
21:30:19 <deteego> I believe if I make a closure out of each binding it should work
21:30:19 <carter> and
21:30:38 <carter> http://www.cs.indiana.edu/~dyb/pubs/fixing-letrec.pdf
21:30:48 <carter> should get you started :)
21:31:10 <carter> i did a project with a restricted one that was kinda like a ycombinator letrec in hs as a project
21:31:17 <deteego> thanks heaps
21:31:34 <carter> and to repeat what i was saying yesterday, if you want to play with different semantics / implementations
21:31:43 <carter> do so as a macro in plt scheme / racket lang
21:32:08 <carter> deteego  have fun
21:33:25 <slava> is there a map reduce in haskell?
21:34:05 <bos> uh, what?
21:34:24 <djahandarie> Heh
21:34:28 <bss03> @type fromInteger
21:34:29 <lambdabot> forall a. (Num a) => Integer -> a
21:34:37 <slava> bos: like apache hadoop, etc
21:34:39 <bss03> @type toInteger
21:34:40 <lambdabot> forall a. (Integral a) => a -> Integer
21:34:52 <bos> slava: i don't know of any distributed ones
21:35:04 <djahandarie> slava, map and reduce (called fold in Haskell) are pretty fundemental operations in Haskell which work on lists
21:35:04 <carter> slava : the map reduce style of computing started with haskell, but there aren't any distributed tools
21:35:25 <carter> slava  but it should be relatively "sane"/ "simple" to roll your own
21:35:32 <djahandarie> slava, but if you are specifically refering to doing things distributed I'm not sure about that
21:35:54 <djahandarie> I know there have been attempts at doing generally distributed Haskell but I don't hear about them often
21:36:04 <carter> we're talking about the running it on a cluster case, right?
21:36:19 <carter> or jsut the "use all my cores" case?
21:36:29 <slava> djahandarie: I'm not talking about list operations
21:36:32 <bss03> slava: If you can do SMP across your cluster, just use +RTS -N
21:36:36 <slava> never mind
21:36:49 <copumpkin> slava: in a word, no
21:37:02 <copumpkin> factor will soon? :)
21:47:45 <adnap> How do you use infix notation for a function when you have to specify the module name?
21:47:59 <adnap> `Module.foo`?
21:48:03 <ddarius> Yes.
22:02:46 <copumpkin> -XIdiomBrackets, I want
22:03:21 <adnap> Why can't you have multi-parameter type classes by default?
22:05:27 <dolio> They weren't in Haskell 98.
22:06:27 <adnap> But do they present difficult problems?
22:07:23 <NemesisD> whats the adoption rate of git like in the haskell community?
22:07:56 * Veinor uses it!
22:08:02 * bss03 uses git.
22:08:14 <bss03> multi-parameter types aren't in 2010, either, are they?
22:09:21 <bss03> I think others are more fond of darcs.  I'm go used to manipulating things with git rebase etc. that I think dealing with darcs might break me.
22:09:39 <adnap> How do I refer to Prelude.+?
22:09:45 <dolio> adnap: Not really. But they're an extension, so you need to enable an extension.
22:09:58 <adnap> Why can't I do ":t Prelude.+"?
22:09:59 <shachaf> adnap: Just like that.
22:10:07 <shachaf> adnap: For the same reason you can't do ":t +".
22:10:15 <luite> there are still some difficulties, fundeps are said to be tricky, don't know about associated types
22:10:17 <adnap> shachaf: And what is that?
22:10:26 <shachaf> adnap: You need parentheses. :t (+)
22:10:40 <shachaf> (Or :t (Prelude.+) in your case.)
22:10:45 <adnap> shachaf: I can't do ":t Prelude(+)" either.
22:10:49 <adnap> shachaf: Oh
22:11:04 <adnap> shachaf: lol
22:16:36 <JoeyA> @let split _ [] = []; split n xs = let (g,rest) = splitAt n xs in g : split n rest
22:16:36 <lambdabot>  <local>:2:65:
22:16:37 <lambdabot>      Ambiguous occurrence `split'
22:16:37 <lambdabot>      It could refer to eithe...
22:16:39 <adnap> Also, I can't use '0' for the name of my function, right?
22:16:59 <JoeyA> @let splitIntoGroupsOf _ [] = []; splitIntoGroupsOf n xs = let (g,rest) = splitAt n xs in g : splitIntoGroupsOf n rest
22:17:00 <lambdabot>  Defined.
22:17:10 <JoeyA> > splitIntoGroupsOf 5 [1..12]
22:17:11 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12]]
22:17:19 <JoeyA> Is there a function in the standard libs for this?
22:17:28 <JoeyA> :t split
22:17:29 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
22:17:56 <JoeyA> example usage: trivial character-wrap
22:18:48 <copumpkin> no
22:18:52 <copumpkin> @hackage split 
22:18:52 <lambdabot> http://hackage.haskell.org/package/split
22:19:02 <Veinor> whoa, hoogle is different now
22:19:23 <Veinor> splitEvery in Data.List.Split does what you want
22:19:51 <JoeyA> http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html#v%3AsplitEvery
22:19:58 <JoeyA> thanks
22:22:55 <dmead> hi channel
22:22:58 <dmead> hows it going, etc
22:24:49 <JoeyA> It's dead.  All the Haskell programmers flocked to O'Caml.  As of yesterday.
22:25:30 <dmead> sigh
22:25:56 <JoeyA> hello
22:26:06 <dmead> hi
22:36:11 <adnap> Can anyone see what I'm trying to accomplish with this and tell me what I can do?  I'm having problems with types. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29845#a29845
22:36:57 <dibblego> is there an example usage of Test.QuickCheck.Function?
22:37:29 <adnap> Vector2 has Double's, but the definition of Vector says that (*) can take any Field as its first argument.  So, I don't know how to define (*) for Vector2 since one thing is a Double, and the other could be any Field.
22:38:28 <adnap> I was thinking that maybe every Vector must be definited with a Field, but that would involve multi-parameter type classes.
22:42:30 <ddarius> adnap: A multi-parameter type class with a functional dependency, or alternatively an associated type is the solution here.
22:44:02 <adnap> ddarius: I don't know specifically what you mean by a functional dependency or associated type.
22:44:39 <ddarius> adnap: Ask Google.
22:44:58 <adnap> ddarius: Doing it
22:45:31 <adnap> So, if I use multi-parameter type classes, I can only compile with GHC?
22:46:05 <Cale> Hugs supports MPTCs
22:46:13 <Cale> What other implementations of Haskell are you interested in?
22:47:06 <JoeyA> Is there an even more convenient syntax than (\state -> state {s_nextUpdate = Nothing}) for updating a field in a record?
22:47:14 <adnap> Cale: I was just curious.
22:47:35 <JoeyA> ({s_nextUpdate = Nothing}) just gives a syntax error
22:49:14 <Cale> adnap: The standard is horribly out of date. "Haskell 2010" is misleading as a name, since it's basically Haskell 98 with the addendums folded in and some trivial changes.
22:49:27 <adnap> So, do you all often use multi-parameter type classes and functional dependencies?  I was scared to use anything that wasn't standard, but it seems like these things will be included eventually anyway.
22:49:32 <Cale> Yeah
22:49:46 <adnap> Cale: Yes
22:50:00 <Cale> JoeyA: Yeah, it's unfortunate
22:50:25 <Cale> JoeyA: If you use a single letter variable in your lambda, it'll at least be shorter
22:51:50 <deteego> is there a version of 'seq' where you dont lose the binding to the first variable
22:52:14 <carter> deteego you mean $!
22:52:16 <carter> :)
22:52:17 <carter> ?
22:52:35 <carter> which lets you make the application f a
22:52:48 <carter> be weak head normal form strict on a
22:52:54 <carter> when you write f $! a
22:53:02 <carter> would that be what you want?
22:53:04 <Cale> deteego: Usually the first parameter to seq is a variable which is already in scope.
22:53:19 <Cale> let x = foo bar baz in x `seq` ...
22:53:20 <carter> whnf strictness is often the right amount of strictness
22:53:22 <adnap> ddarius: Ahhh!  I looked up associated type and now I'm getting all this stuff about families, which I didn't even know existed.
22:53:31 <deteego> oh ok, so $! also forces evaluation
22:53:32 <deteego> in that order?
22:53:51 <adnap> I'm opening up a Haskell extension can of worms.
22:53:55 <carter> deteego i spose
22:53:59 <carter> what do you mean by order?
22:54:08 <deteego> a evaluated before b
22:54:18 <deteego> (a -> b) -> a -> b
22:54:23 <carter> deteego 
22:54:26 <deteego> (strict evaluation)
22:54:27 <carter> think about it this way
22:54:28 <Cale> @src ($!)
22:54:28 <lambdabot> f $! x = x `seq` f x
22:54:32 <carter> deteego no
22:54:37 <carter> its not strict in that sense
22:55:03 <carter> its rather
22:55:06 <deteego> well seq forces a to evaluate before b
22:55:13 <carter> deteego yes
22:55:16 <carter> but f a
22:55:29 <carter> can only be evaluated after a 
22:55:36 <Cale> seq x y is an expression which ensures that x is evaluated before the result of evaluating it can be pattern matched on, and it evaluates to y
22:55:38 <carter> in that you can use x = f a
22:55:45 <Cale> It doesn't quite ensure that x is evaluated before y
22:55:54 <carter> righto Cale 
22:56:12 <carter> the tricky bit we're not quite pointing at is infinite lists
22:56:15 <carter> or the like
22:56:16 <carter> where 
22:56:23 <deteego> Cale: it will evlaute x before y ALWAYS (if possible)?
22:56:29 <deteego> carter: well im using thunks in my parser
22:56:43 <carter> deteego : all you need is $!
22:56:46 <deteego> so in my situation, I don't want an expression to be evaluated until all thunks have been created
22:56:47 <adnap> How do I enable muti-parameter type classes in GHCI?
22:56:47 <Cale> deteego: No, the compiler is still free to evaluate y first
22:57:01 <carter> deteego dont' worry about evauation order for now
22:57:05 <Cale> deteego: But both x and y will be evaluated before the result can be pattern matched
22:57:12 <carter> yeup
22:57:25 <deteego> eval _g (Letrec bindings exp) = eval  (foldl evalBindingR _g bindings) $! exp
22:57:30 <deteego> that is the situation I am dealing with
22:57:36 <adnap> I know I can use a compiler flag when I compile, but how do I enable in for experimenting in GHCI?
22:57:44 <carter> deteego 
22:57:45 <blackh> adnap: Add {-# LANGUAGE MultiParamTypeClasses #-} to the top of your source file
22:57:50 <Cale> The real definition is that seq x y is undefined if x is undefined, and seq x y = y otherwise
22:57:59 <carter> you're confusing meta lang semantics with the object lang semantics
22:58:02 <deteego> foldl evalBindingR _g bindings has to be evaluated before exp is
22:58:19 <deteego> hmm wait
22:58:32 <deteego> when you pattern match exp does it evaluate straight away?
22:58:32 <carter> deteego : where is the env parameter in your eval?
22:58:55 <adnap> blackh: Oh, okay.  Is that the only purpose that serves?
22:59:13 <carter> deteego : the correct answer is that for pure haskell code, it doesn't matter :)
22:59:27 <deteego> deteego: (foldl evalBindingR _g bindings)
22:59:30 <deteego> that is the environment
22:59:33 <adnap> ddarius: Woo!  It works!
23:00:12 <deteego> carter: the expression creates thunks in the environment, so it has to be done before exp is evaluated
23:00:16 <carter> deteego don't worry about strictness unless you're finding its too slow  or keeps on overflowing the stack
23:00:27 <deteego> carter: in my case it breaks the program
23:00:41 <deteego> if the thunks aren't there and the exp is evaluated, the program fails
23:00:44 <carter> deteego ... you mean you're wrapping em in \ x -> exp
23:00:58 <deteego> main :: Int
23:01:00 <carter> or you mean you're doing thunking in your object language
23:01:00 <deteego> = letrec a :: Int = b;
23:01:02 <deteego> b :: Int = c;
23:01:04 <deteego> c :: Int = 7;
23:01:06 <deteego> in c + a;that is the exmaple of the program I am evaluating
23:01:17 <carter> deteego : are you trying to write letrec for haskell?!
23:01:18 <deteego> it creates thunks for the 3 bindings (a,b,c)
23:01:28 <carter> or for a mini language in haskell?
23:01:32 <deteego> carter: no this isn't haskell, this is some basterdidsed subset
23:01:34 <deteego> of haskell
23:01:38 <carter> ok...
23:01:41 <deteego> *basterdised
23:01:54 <carter> remember what I said about first playing with your definitions in racket-lang?
23:02:03 <deteego> uh no
23:02:10 <deteego> I don't know scheme/lisp etc etc
23:02:15 <carter> same thingy
23:02:35 <carter> the point being, so you can focus on how the code works for getting letrec right
23:02:39 <carter> ignoring other things
23:02:45 <carter> then plop it in
23:03:11 <carter> because its easy to implement letrec of any style as a scheme macro
23:03:16 <carter> (as in those papers i linked you to)
23:03:28 <carter> earlier
23:03:58 <deteego> we have to code this evaluater in Haskell
23:04:06 <carter> is this for a class?
23:04:22 <deteego> yes
23:04:24 <carter> ahhh
23:05:07 <augur> is @ stronger or weaker binding than other operators, does anyone know?
23:05:08 <carter> i think asking about hw to do homework is something we're not supposed tohelp with on #haskell or the mailing list
23:05:29 <carter> augur depends on what it was defined as in the lib you're using
23:05:34 <carter> look at the source :)
23:05:42 <NemesisD> yeesh.i should set limits before using quickcheck
23:05:43 <augur> aha ok. so @ is treated as just another operator
23:05:52 <NemesisD> system was thrashing for like 20 minutes
23:05:55 <deteego> well I just wanted to know how seq works
23:06:02 <carter> use $! :)
23:06:12 <carter> for your function aps
23:06:20 <carter> and maybe bring in foldl'
23:06:24 <carter> or the like
23:06:27 <deteego> ok then the problem lies elsewhere
23:06:49 <carter> your prof or TA might be better at helping :)
23:07:07 <adnap> Is there any way to define your own sugar in Haskell like [], or (,)?
23:07:15 <carter> hahaha, i may  be the ta for the haskell class at my uni soon
23:07:33 <deteego> carter: these are bonus extra hard questions
23:07:36 <carter> ah
23:07:38 <deteego> carter: we aren't meant to get help for these
23:07:43 <carter> ok
23:07:43 <adnap> What if I wanted |x|?
23:07:52 <carter> adnap maybe look at template haskell?
23:07:58 <carter> or write your own preprocessor :)
23:08:21 <carter> deteego : pardon
23:08:23 <carter> basically
23:08:29 <carter> you can also try deepseq
23:08:38 <adnap> Okay, I was just curious.  I've been hearing about template haskell.
23:08:40 <carter> but it may just be the code is wrong
23:09:13 <carter> adnap I don't knwo how much TH lets you do that sort of thing though
23:09:53 <ManateeLazyCat> Hi all. :)
23:09:55 <carter> deteego : you can try deep seq (or define a $!! using deep seq thats like the $! for seq)
23:10:11 <carter> but if the codes wrong to begin with, that won't fix it
23:11:13 <deteego> well when you pattern match something like eval _g (Letrec bindings exp) in haskell
23:11:18 <deteego> will exp be evaluated
23:11:47 <carter> umm
23:12:01 <carter> why not just make the datastructure strict?
23:14:10 <deteego> which datastructure?
23:14:18 <deteego> exp is an AST
23:15:08 <carter> yeah
23:15:12 <carter> make it strict
23:15:14 <carter> you can do that
23:15:24 <carter> just add ! infront of each entry in the definition
23:15:45 <deteego> well the point is the environment must be evaluted before the exp
23:15:55 <deteego> im not sure we are allowed to make exp strict
23:16:00 <deteego> as a data type
23:16:07 <carter> umm
23:16:08 <carter> well
23:16:26 <carter> gl
23:16:32 <deteego> look what I am doing is im adding thunks to an environment
23:16:43 <deteego> those thunks have to be in the environment before the exp is evaluated
23:16:46 <carter> nope
23:16:56 <carter> well
23:16:57 <carter> hrmm
23:16:57 <deteego> foldl evalBindingR _g bindings
23:17:01 <carter> better idea
23:17:04 <carter> you do that
23:17:05 <deteego> that is the expression to create that environment
23:17:08 <carter> then add a new level
23:17:13 <carter> with the same vars
23:17:24 <carter> that are defined as the evaluation of those thunks
23:17:41 <carter> let vars = thunks
23:17:50 <carter> let vars = thunks ()
23:18:17 <carter> though that still has fiddly bits
23:18:23 <deteego> well the error I am getting in the example is that it can't find an identifier in the environment (which should be the thunk)
23:18:23 <carter> but that might be  helpful starting point
23:18:26 <carter> yes
23:18:31 <carter> i'm showing you how :)
23:18:42 <carter> let rec vars = exps  
23:18:48 <carter> rewrie as
23:18:55 <carter> let vars = thunk exps
23:18:56 <carter> in
23:19:07 <carter> let vars = applythe thunks
23:19:11 <deteego> hmm im thinking
23:19:30 <deteego> what I have, is when the ids of the thunks are retrieved from the environment, they are evaluated at that point
23:19:36 <carter> you still need do a wee bit of extra rewriting in the body of the thunks
23:19:52 <carter>  / body of the exps
23:19:56 <carter> try writing new code
23:20:08 <carter> it sounds like you're stuck on slightly off way 
23:20:17 <carter> and taking a wee break then trying to write it again may help
23:21:13 <carter> or all an N-arry ycombinator / fix operator to the lang
23:21:18 <carter> and define it in terms of that
23:21:21 <carter> *add an
23:21:57 <carter> ok
23:22:02 <carter> i think thats all i can say
23:22:12 <carter> withouth being like "show me the code and let me write a stub"
23:23:43 <deteego> no thats fine
23:24:01 <deteego> the only way to solve this is either using thunks or making a dependancy graph (to show the lowest level dependancy)
23:24:40 <dmead> @hoogle ParseResult
23:24:40 <lambdabot> Language.Haskell.ParseMonad data ParseResult a
23:24:40 <lambdabot> Language.Haskell.Parser data ParseResult a
23:31:38 <arunk> hi, has anyone here had success getting wxHaskell to work on win + mingw ?
23:33:33 <mm_freak> arunk: funnily i'm trying to do just that right now
23:33:42 <ManateeLazyCat> arunk: Do you like gtk2hs?
23:34:28 <arunk> ManateeLazyCat, i'm just more familiar with wx, then gtk
23:34:43 <arunk> mm_freak, are you running into linker problems ?
23:35:03 <ManateeLazyCat> arunk: gtk2hs can install easily on Windows or UNIX, by cabal
23:35:32 <ManateeLazyCat> arunk: And APIs is pretty easy to use.
23:35:57 <arunk> i have managed to get wxHaskell installed. its just that its erroring out with undefined references at the linker stage
23:36:09 <mm_freak> arunk: currently i'm installing it under linux (because if even that doesn't work, then wx is quite useless for me)
23:36:14 <arunk> i've checked the libraries being included (-v3) and they are correct. the functions ought to be found
23:37:09 <deteego> if this is regarding wx for haskell
23:37:11 <arunk> mm_freak: worked for me on ubuntu 10.4 - sudo apt-get , and cabal install two simple commands
23:37:20 <deteego> you need 2.8.00 wxwidgets installed and in the path
23:37:22 <arunk> if only things were this easy on windoz
23:37:25 <deteego> and then wx should build as per normal
23:37:38 <deteego> not sure about windows though
23:37:44 <deteego> (no one ever is)
23:39:15 <arunk> trying to find the link of the page i followed. you also have to do a set WXWIN= path to wx, and set WXCFG=gcc_dll\mswu
23:39:28 <dmead> @hoogle unsaferperformIO
23:39:28 <lambdabot> No results found
23:39:32 <dmead> @google unsaferperformIO
23:39:32 <lambdabot> No Result Found.
23:39:42 <dmead> SPELLCHECK ME PLEASE LAMDABUDDY
23:39:59 <ManateeLazyCat> arunk: If you don't mind, you can try gtk2hs. I will release next version very soon, then support all APIs in newest GTK+
23:40:50 <mm_freak> arunk: same here, now trying windows
23:40:52 <arunk> ManateeLazyCat: installing it now on both ubuntu and windows. will let you know how it goes on windows. if it works right out of the box, then i guess thats all i need for now :)
23:41:01 <mm_freak> but there is no mingw-specific package
23:41:07 <zenzike> This is a bit of a strange question: Is there a function foo :: (a -> m b) -> m (a -> b) ?
23:41:25 <ManateeLazyCat> arunk: Ok.
23:41:51 <zenzike> I'm basically trying to construct some kind of sortByIO :: (a -> a -> IO Ordering) -> [a] -> IO [a]
23:42:12 <mm_freak> ManateeLazyCat: well, i like GTK, but wx looks more native on windows, so i'd like to try it out
23:42:17 <mm_freak> also the interface looks simpler
23:43:27 <ManateeLazyCat> mm_freak: If you application focus on Linux, i suggest use gtk2hs (better performance), if you want native interface, use wx. :)
23:43:28 <mm_freak> zenzike: i don't think such a function is possible
23:43:45 <zenzike> mm_freak: not possible?
23:43:55 <mm_freak> zenzike: why do you need it anyway?
23:44:10 <zenzike> becuase of the sortByIO 
23:44:23 <mm_freak> yes, because with that function you could effectively turn a monadic function into a non-monadic one, which the monad interface doesn't allow
23:44:35 <mm_freak> sortByIO doesn't need that function
23:45:09 <ManateeLazyCat> @hoogle sort
23:45:09 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
23:45:10 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
23:45:10 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
23:45:15 <zenzike> I can implement sortByIO if I have that function ...
23:45:25 <mm_freak> zenzike: you can implement sortByIO without it, too
23:45:26 <zenzike> @hoogle sortBy
23:45:26 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
23:45:48 <zenzike> mm_freak: I was kinda hoping I could make it a simple implementation using sortBy
23:45:53 <dmead> @hoogle ParseOK
23:45:53 <lambdabot> Language.Haskell.ParseMonad ParseOk :: a -> ParseResult a
23:45:53 <lambdabot> Language.Haskell.Parser ParseOk :: a -> ParseResult a
23:45:54 <mm_freak> zenzike: just think of this:  what if m = IO and that computation prints something to the terminal?
23:46:18 <zenzike> mm_freak: oh thanks, that does help
23:46:22 <mm_freak> in other words:  what if you would call your function with the argument:  (const $ putStrLn "blah")
23:46:44 <deteego> bah sometimes I wish haskell wasn't so pure
23:46:52 <mm_freak> deteego: why?
23:47:12 <mm_freak> zenzike: btw, if you need fast sorting, look at the 'vector' package
23:47:26 <ManateeLazyCat> deteego: I love Haskell's pure, and like FFI too....
23:47:28 <dmead> @hoogle ParseResult
23:47:28 <lambdabot> Language.Haskell.ParseMonad data ParseResult a
23:47:29 <lambdabot> Language.Haskell.Parser data ParseResult a
23:47:33 <zenzike> mm_freak: it's not because I need fast sorting, it's because the data I need to compare comes out of an IO
23:47:49 <mm_freak> zenzike: then take it out of IO and pass it to sortBy
23:48:03 <deteego> I want to put a printf in the middle of nowhere
23:48:05 <deteego> thats why
23:48:21 <mm_freak> deteego: why? printing debug stuff?
23:48:25 <zenzike> mm_freak: duh of course :-) silly me how obvious
23:48:29 <deteego> mm_freak: yes
23:48:31 <arunk> ManateeLazyCat: what all do i need to install to get gtk2hs? i tried cabal install gtk, but it errored out with setup: gtk2hsC2hs is required but not found. i'm guessing those should be two separate packages?
23:48:32 <ManateeLazyCat> @hoogle Debug.Trace
23:48:33 <lambdabot> module Debug.Trace
23:48:33 <lambdabot> Debug.Trace trace :: String -> a -> a
23:48:33 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
23:48:40 <mm_freak> deteego: there is a module for that…  it's dirty, but it works =)
23:48:47 <deteego> mm_freak: tell me more
23:49:02 <ManateeLazyCat> arunk: You need install gtk2hs-buildtools manually before install gtk package.
23:49:07 <arunk> cabal install gtk2hs or Gtk2Hs doesnt work either
23:49:26 <ManateeLazyCat> arunk: cabal install gtk2hs-buildtools gtk
23:49:26 <arunk> can i apt-get it ?
23:49:33 <arunk> ahh ok
23:49:35 <ManateeLazyCat> arunk: No
23:49:35 <mm_freak> deteego: i've never used it…  it's essentially just an unsafePerformIO + putStr wrapper
23:49:41 <mm_freak> you could easily write it yourself
23:49:47 <ManateeLazyCat> arunk: And make sure ~/.cabal/bin in your PATH
23:49:58 <deteego> mm_freak: whats the module called?
23:50:08 <ManateeLazyCat> arunk: Otherwise gtk package can't find gtk2hsC2hs
23:50:19 <mm_freak> deteego: Debug.Trace
23:50:20 <zenzike> mm_freak:  thanks for the brain prod that helped lots
23:50:34 <ManateeLazyCat> arunk: I think you can apt-get, but i suggest use newest version from hackage, less bugs.
23:50:35 <mm_freak> zenzike: you're welcome =)
23:51:05 <ManateeLazyCat> deteego: Use Debug.trace.
23:51:12 <ManateeLazyCat> @hoogle Debug.Trace
23:51:12 <lambdabot> module Debug.Trace
23:51:13 <lambdabot> Debug.Trace trace :: String -> a -> a
23:51:13 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
23:51:55 <ManateeLazyCat> deteego: Debug.Trace.trace can print debug information at terminal and keep your code pure.
23:52:06 <deteego> ManateeLazyCat: thanks
23:52:16 <mm_freak> sounds like an advocation
23:52:24 <mm_freak> i prefer not to mention this module to anyone =)
23:52:50 <deteego> hmm, how would one use this in functions without changing them to IO
23:53:10 <mm_freak> wow, wxMSW takes forever to install in a KVM-jailed windows
23:53:15 <roconnor> deteego: you don't need to change them to IO
23:53:25 <roconnor> deteego: (trace uses unsafePerformIO)
23:53:40 <mm_freak> > trace "blah" 0
23:53:41 <lambdabot>   Not in scope: `trace'
23:53:42 <ManateeLazyCat> deteego: let fun = trace ("balbla : " ++ a) a
23:53:49 <mm_freak> > Debug.Trace.trace "blah" 0
23:53:50 <lambdabot>   Not in scope: `Debug.Trace.trace'
23:54:18 <mm_freak> deteego: you can even use your printf
23:54:31 <mm_freak> trace (printf "blabla: %s\n" a) a
23:55:29 <c_wraith> Just be aware that trace will expose the strangeness of lazy evaluation to you, in depth.  You may not see what you expect. :)
23:55:44 <rprichard> > putStr "test\n"
23:55:45 <lambdabot>   <IO ()>
23:56:15 <deteego> c_wraith: thats exactly the problem I am having
23:56:18 <mm_freak> > show (putStr "test\n")
23:56:19 <lambdabot>   "<IO ()>"
23:56:22 <zenzike> mm_freak: sadly the whole story was a  lot more complex
23:56:26 <deteego> c_wraith: im finding out functions do/dont get evaluated
23:57:28 <zenzike> I want a function, sortFoo ::~ [a] -> [a], and I have the following, (b -> b -> Ordering), and (a -> IO b). Any clues how I can do the sort?
23:57:41 <c_wraith> deteego, is the code something you can put on hpaste, along with a description of how it supposed to work, and what's going wrong?
23:57:54 <deteego> c_wraith: not really, its actually an assignment im doing
23:58:17 <mm_freak> zenzike: that doesn't make sense to me…  what are you trying to do?  in english =)
23:58:46 <deteego> great, now this trace is confusing me even more
23:58:48 <ManateeLazyCat> zenzike: Best print the code that you real want to do.
23:58:58 <c_wraith> zenzike, I think the best you can manage is [a] -> IO [a]
23:58:59 <zenzike> basically I'm using Hakyll and trying to sort some HakyllActions by their Contexts
23:59:00 <ManateeLazyCat> deteego: Just use it.
23:59:14 <zenzike> c_wraith: I think that's right, and I'm happy to settle for [a] -> IO [a]
23:59:18 <deteego> ManateeLazyCat: I am, and I am using it with seq to force its evaluation
23:59:25 <deteego> ManateeLazyCat: it hasn't printed anything yet
23:59:35 <zenzike> I'll see if I can smash up some code that doesn't involve everybody having to know how Hakyll works
23:59:44 <mm_freak> zenzike: by a certain context key?
