00:01:01 <copumpkin> mmm, contexts on data
00:01:30 <applicative> whats up with that, I don't do it. 
00:02:09 <copumpkin> it just doesn't do much good
00:02:35 <copumpkin> although you're forced to provide a context when constructing it, you don't get it when pattern matching on it
00:02:39 <applicative> why not put them on the functions Ratio a -> ....
00:03:06 <copumpkin> :t denominator
00:03:07 <lambdabot> forall a. (Integral a) => Ratio a -> a
00:03:09 <copumpkin> they do anyway :P
00:03:41 <copumpkin> it doesn't even need constraints there, really
00:03:51 <copumpkin> (%) :: Integral a => a -> a -> Ratio a	
00:05:43 <applicative> I see, it is in the  actual def. of Ratio a, I thought it was supposed to be the same, but in some illustrative discussion. 
00:17:47 <Cale> applicative: The class context on data declarations is actually known as "the stupid context" in GHC :)
00:18:48 <Cale> applicative: The problem is that it means a whole lot less than it ought to mean. With GADT syntax, you can apply more meaningful class contexts to your data which actually discharge constraints when values are pattern matched.
00:24:33 * hackagebot wai-frontend-monadcgi 0.0.0 - Allows programs written against MonadCGI to run with any WAI handler.  http://hackage.haskell.org/package/wai-frontend-monadcgi-0.0.0 (MichaelSnoyman)
00:25:35 <applicative> Cale, I'm trying to figure out that sentence, when I should ask for a few more... In data (Integral a) => Ratio a ...., I don't "discharge constraints when values are pattern matched." 
00:26:55 <applicative> Of course this can be rewritten 'in GADT syntax', data Ratio a where Ratio :: Integral a => a -> a -> Ratio a , right
00:27:03 <applicative> ?
00:27:08 <copumpkin> yes, that's different though
00:27:10 <copumpkin> that does the right thing
00:27:23 <copumpkin> with the regular (:%) constructor, you'd expect that
00:27:34 <applicative> right, the difference, or the wrong thing, is what i'm hoping to grasp
00:27:45 <copumpkin> f (x :% y) = <here, x and y should have an Integral instance available, but they don't>
00:29:12 <applicative> despite the context in the official definition of Ratio
00:29:15 <copumpkin> yeah
00:29:23 <applicative> It's pointless
00:29:26 <copumpkin> yep
00:29:33 <copumpkin> it's a forgetful construct!
00:29:39 <copumpkin> it asks you for an instance and then forgets you gave it one :(
00:30:26 <applicative> but this simple GADT version, how does it go beyond it the same as data Ratio a = a :% a, with no constraint, followed by a function def. ratio :: Integral a => a -> a -> Ratio a
00:30:54 <applicative> or rather ...how does it go beyond, or is it the same as...
00:31:03 <copumpkin> with the GADT form, you could write functions that expect Integral numerator/denominator without putting it in the type
00:31:13 <copumpkin> so maybe
00:32:10 <copumpkin> hmm, trying to think of something interesting to do with Integral :P
00:32:50 <copumpkin> but anyway, a pattern match on a GADT constructor brings (or can bring) "knowledge" in the form of refined types
00:32:56 <copumpkin> including contexts
00:35:35 <applicative> Is there a good module with an example of class constraints on GADT constructors, followed by skillful pattern matching?
00:37:12 <copumpkin> I don't know of one, but here's a more involved example: data Moo a where Baa :: (Show a) => a -> Moo a; Woof :: (Num a) => a -> Moo a; (Show b) => b -> a -> Moo a
00:37:41 <copumpkin> f :: Moo a -> String
00:37:47 <copumpkin> f (Baa x) = show x -- I can call show, because here I know that x is an instance of Show
00:38:04 <applicative> Pugs source... that's not going to help
00:38:25 <copumpkin> f (Woof a) = show (x + 1) -- I can call (+) because I know it's a Num and Num also implies Show, so I can call Show
00:38:26 <copumpkin> no?
00:38:32 * copumpkin gives up then
00:39:27 <applicative> excellent. 
00:40:42 <copumpkin> not sure what you mean by Pugs source, though
00:44:04 <applicative> oh, just used the google search for haskell code with " GADTs " , and it had them, with class constraints. 
00:44:22 <applicative> But it wasn't going to do as a helpful illustration....
00:45:22 <applicative> http://www.google.com/codesearch/p?hl=en#lVrIEfVOfRw/src/Pugs/AST/Val.hs&q=GADTs%20lang:haskell&d=3
00:46:25 <applicative> damn, that's not the example, what a f*up
00:47:50 <applicative> this was the (useless) example http://www.google.com/codesearch/p?hl=en#FFDdh9FS47Q/CPAN/authors/id/A/AU/AUTRIJUS/Perl6-Pugs-6.2.1.tar.gz|-m6tj1yCK_E/Perl6-Pugs-6.2.1/src/Pugs/AST.hs&q=GADTs%20lang:haskell
00:49:01 <applicative> If you try to find a use of some opaque haskell feature, blind searches inevitably lead one to the Pugs source...
00:50:01 <copumpkin> anyway, it's just another example of the same general GADT behavior
00:50:43 <applicative> i think i get the point, i will have to make experiments; thanks.
00:56:18 <ManateeL`> Which hash algorithm is fastest one that return the 12-bit hexadecimal number.
00:56:20 <ManateeL`> ?
00:57:12 <geheimdienst> ACTION frowns disapprovingly at copumpkin's use uf colorful, lighthearted, easy-to-remember class names. much better would have been A, B, C, D, D', D'', Ḑ, Đ. if we start that, where will it end? if we use memorable names today, tomorrow we may well be writing in simple terms instead of pseudo-latin gibberish, by next week we might be writing haddock docs that don't just say "boolean monoid under conjunction", and in november we might eve
00:57:29 <copumpkin> lol
00:57:35 <copumpkin> you got truncated at "in november we might eve"
00:57:48 <geheimdienst> ... in november we might even have modules in Control comprehensible if you didn't read 18 academic papers!
00:58:56 <copumpkin> can't have that
00:59:13 <geheimdienst> absolutely. kids these days have no respect for elitism at all
01:01:21 <ddarius> > 204 / 4
01:01:22 <lambdabot>   51.0
01:06:34 <ManateeL`> Which hash algorithm return 12-bit hexadecimal number?
01:06:47 <copumpkin> any of them, if you just truncate them
01:07:15 <copumpkin> (.&. 0xfff) . hash 
01:07:18 <copumpkin> :P
01:07:34 <ManateeL`> copumpkin: I want some algorithm don't need truncate. :)
01:07:42 <copumpkin> I doubt you'll find one then
01:07:51 <copumpkin> nobody needs 12-bit hashes for usual uses of hashes
01:08:08 <copumpkin> either way, you're hashing nicknames that are probably no more than 32 bytes
01:08:21 <copumpkin> you could truncate sha512 and still not notice, speedwise
01:08:45 <ManateeL`> copumpkin: Infact, i need cheapest algorithm to return *unique* 12-bit hexadecimal number to unique nick color.
01:09:27 <copumpkin> guaranteeing uniqueness will be hard, as you're mapping an unbounded space to a bounded one
01:09:34 <copumpkin> where hard == impossible :)
01:09:41 <kfish> ManateeL`, how many nicks?
01:09:56 <ManateeL`> kfish: I don't know, i'm developing irc client.
01:10:20 <kfish> ok, so let's say there's 606 nicks in a channel :)
01:10:27 <copumpkin> of whom about 30 speak regularly
01:10:31 <p_l> well, I think 4096 colours is enough to differentiate :P
01:10:33 <n00p> ManateeL`: What is hashing?
01:10:45 <geheimdienst> also, i think being unique is not really necessary. #ff0000 and #fd0000 are different, but the user couldn't tell any difference anyway
01:11:14 <copumpkin> well, his scheme seems to talk about #ff and #ee, for example
01:11:23 <copumpkin> since he's only doing 12 bits
01:11:29 <ManateeL`> kfish: I need some algorithm return 12-bit hexadeciaml, then i split it with three 4-bit hexadecimal, then convert 4-bit hex to Int [0, 65535], then i can use that Int with Color value.
01:11:33 <copumpkin> you should do a perceptual thing with more bits allocated to green than red or blue
01:11:51 <geheimdienst> copumpkin, oh i see. right
01:11:52 <Zao> There's algorithms for generating a sequence of colours that's most distinguishable from each other.
01:11:55 <ManateeL`> n00p: Hash nick name to get unique hex value.
01:12:10 <Zao> rrdtool uses a bunch of different ones, I believe.
01:12:20 <copumpkin> watch my IRC client fail at it: http://snapplr.com/8rkb
01:12:43 <kfish> ManateeL`, if you want uniqueness, just use a hashtable and insert a unique new color each time (no need for randomness, just walk the colorspace)
01:12:44 <n00p> ManateeL`: That's not an answer to my question.
01:13:16 <copumpkin> ManateeL`: anyway, you're not going to get uniqueness out of any regular hash function, but you probably want something more sophisticated. Keep a "working set" of people who have spoken recently, and if someone shuts up for 20 minutes, pull them out so you can reuse their color
01:13:30 <copumpkin> in any IRC channel, you'll probably get at most a few dozen people speaking at once
01:13:35 <copumpkin> within the same rolling window, anyway
01:14:25 <geheimdienst> pidgin tries to do it, but it's actually quite stupid. it assigns the colors alphabetically, so copumpkin and copumpking would have indistinguishable colors. easily confused nick names -> easily confused colors, which is exactly the wrong thing ...
01:14:28 <copumpkin> maybe a simple set of 100 easily distinguishable colors (already pushing it, in my opinion), and just use least-recently-used in addition to a simple hash
01:15:18 <geheimdienst> i agree with copumpkin. make a fixed list of 80 colors and use it for the last 80 people who said something
01:15:24 <ManateeL`> copumpkin: Infact, i have elisp algorithm that use md5 return hex value then truncate to 12-bit, but i don't like it, too costly
01:15:30 <copumpkin> lol
01:15:40 <copumpkin> I'm not going to take you seriously if you talk like that
01:16:09 <Cale> copumpkin: Like what?
01:16:24 <copumpkin> geheimdienst: yeah, and if you have more than 80 people talking at once you can reuse colors anyway, because it'll be too confusing to follow anyway
01:16:27 * geheimdienst is amazed anybody still talks about taking him seriously, after all this time
01:16:28 <ManateeL`> Maybe md5 ist too costly since elisp code can works fine.
01:16:56 <copumpkin> Cale: that an md5 is too costly in a GUI IRC client, where nicks are a couple of dozen bytes maximum, and you have a few hundred of them at most
01:17:17 <ManateeL`> copumpkin: Reuse color is more confusion when you scroll.
01:17:32 <copumpkin> but I wasn't proposing md5 anyway. Just a plain old hashtable hash
01:17:34 <geheimdienst> copumpkin, but suppose he's appending them to a list, not prepending them!
01:17:37 <Cale> Ah, yeah, though you don't really need a fancy hash for nick colouring
01:17:47 <copumpkin> you don't need cryptographically secure hashing (even though md5 isn't even that)
01:18:09 <n00p> ManateeL`: What are you using to render the text to colour?
01:19:06 <ManateeL`> n00p: GTK+ TextBuffer
01:19:30 <ManateeL`> n00p: (Color 0 0 0) to (Color 65535 65535 65535) 
01:19:32 <copumpkin> ManateeL`: you can take your scrollback to be the "recently used" buffer
01:19:35 <copumpkin> so you never get confusion that way
01:19:43 <n00p> ManateeL`: Consider the benefit that HTML/CSS might offer.
01:19:45 <copumpkin> you might need more colors that way
01:19:46 <geheimdienst> ManateeL`: i'd just take maybe 60 or 80 colors from http://en.wikipedia.org/wiki/Web_colors and use that
01:20:17 <ddarius> You don't want people's colors to change.
01:20:33 <n00p> ddarius: Unless you want peoples colours to change...
01:20:49 <n00p> ddarius: eg. someone wants to set you to blue, permenantly.
01:20:50 <geheimdienst> ddarius, you have a point
01:20:55 <copumpkin> I'd say that if someone has spoken so long ago that they scrolled off your scrollback, you won't notice if their color changes
01:21:04 <n00p> ddarius: Doesn't that seem reasonable?
01:21:24 <geheimdienst> copumpkin: well it would be nice if copumpkin every day has the same color
01:21:36 <copumpkin> yeah, I should be orange, shouldn't I
01:21:44 <n00p> copumpkin: Certainly.
01:21:52 <copumpkin> hmm
01:21:53 <kfish> copumpkin, yes, orange
01:22:17 <n00p> copumpkin: ... and if I had the option of colouring your nickname, I would want it to be orange. Otherwise, the colour is useless to me.
01:22:18 <ManateeL`> Maybe best way is build hash (no cryptography) to get 12-bit hex value.
01:22:21 <kfish> perhaps if everyone was a different shade of orange
01:22:37 <ddarius> ManateeL`: Yes.
01:22:53 <mornfall> copumpkin: You are red. :)
01:22:55 <copumpkin> ManateeL`: I'd be thinking more about the algorithm surrounding the hash than what hashing algorithm to use, since they all give you the same properties for your purposes
01:23:34 <n00p> I wouldn't even use a hash algorithm. I'd pull colours in the order that people join/part.
01:23:34 <geheimdienst> let me specify the CTCP NICKCOLOR protocol that allows people to claim colors, as long as it's not too close to anyone else's, with claims to colors being stored in a new interweb-wide DNS-style registry ...
01:23:40 <geheimdienst> *cough*cough*
01:24:13 <copumpkin> smartHash :: String -> Word12; smartHash "pumpkin" = toWord12 Orange; smartHash x = truncateToWord12 (sha512 x)
01:24:16 <copumpkin> ;)
01:24:18 <n00p> geheimdienst: colours on IRC are evil, and thankfully opt-outable at the expense of a little bit of CPU overhead. :)
01:24:35 <n00p> copumpkin: ^5.
01:24:38 <ddarius> n00p: Unless you permanently store the color from then on, that leads to people's nicks changing color.
01:25:01 <n00p> ddarius: Only if they part out of every channel that you're on.
01:25:18 <ddarius> People tend to do that when they close IRC.
01:25:31 <n00p> ddarius: Of course, those who you're fond of could go in a CSS-like configuration with the static colour you provide :)
01:26:00 <ddarius> The hashing solution works better.  You could augment it with a stored color mapping if desired.
01:26:08 <geheimdienst> what about font sizes? luminaries' nicks could be in big friendly letters, with lowly geheimdiensts tiny and nearly unreadable
01:26:15 <geheimdienst> ;)
01:26:27 <ddarius> geheimdienst: That would reinforce the status quo.
01:26:37 <n00p> eg: .copumpkin { .foreground-colour: orange; }
01:27:35 <n00p> geheimdienst: Yes, and while you're at it you could convert n00p to a slightly obscure permutation of the NOP opcode, in x86 machine code...
01:27:53 <copumpkin> why just x86?
01:27:58 <copumpkin> we ARMites have it too
01:28:05 <copumpkin> :(
01:28:10 <ManateeL`> Zao: Where?
01:28:12 <copumpkin> as do several other archs
01:28:27 <Zao> ManateeL`: Wrong guy?
01:28:38 <copumpkin> Zao: the color picking algorithms?
01:28:39 <Zao> Ah, back there.
01:28:43 * ddarius doesn't think QEMU does the right thing with the loadall opcode.
01:28:59 <geheimdienst> oh, and it would be cool if haskell street cred was shown for each nick. if your name is shown very bold, most of your lambdabot "> ..." lines ran without errors, while bumbling newbies have a very thin font
01:29:03 <ManateeL`> Zao: You told me "There's algorithms for generating a sequence of colours that's most distinguishable from each other"
01:29:04 <ddarius> copumpkin: It's hard not to have a nop instruction.
01:29:24 <n00p> Fine. NOP in a fictional assembly language based on truly randomized and uncrackable cryptology.
01:29:30 <Zao> ManateeL`: And I also pointed at rrdtool as a possible place to find out more.
01:29:52 <n00p> As a result, you'd end up with truly randomized gibberish instead of my nickname. Happy?
01:29:53 <Zao> ManateeL`: I don't know personally what they are, but I'd guess it'd be sampling reasonably uniformely in HSV space.
01:30:07 <copumpkin> ddarius: someone should devise an encoding that prevents noppish instructions by construction! nop in ARM assmebly used to just be mov r0, r0, but we should prevent such things :P
01:30:20 * geheimdienst calls dibs on blinking nicknames
01:30:40 <copumpkin> does css even have an equivalent of the blink tag?
01:30:44 <geheimdienst> ... and nicks decorated with lolcats. singing lolcats.
01:30:48 <ddarius> copumpkin: It's not that hard to find the nop instructions and replace them with some arbitrary other thing.
01:30:53 <n00p> When I wrote my (half of an) IRC client in C#, I made it possible for the underline to be coloured differently to the text.
01:31:08 <copumpkin> ddarius: yeah, but there are quite a few of them in your average set
01:31:35 <n00p> So, if you used ^C12^U^C4text, You'd get red text with a blue underline...
01:31:50 <copumpkin> I guess we could take all the wasted combinations and encode an entire new instruction in the space resulting from them
01:32:08 <geheimdienst> one new instruction?
01:32:10 <copumpkin> sounds like a nightmare to decode though
01:32:23 <copumpkin> geheimdienst: I dunno, depends how many nop-like things you end up with :)
01:32:35 <copumpkin> one of these days I'll count how many there are in ARM
01:32:37 <geheimdienst> what would it do?
01:32:50 <copumpkin> beats me :P some horrendous CISCy thing
01:32:51 <n00p> copumpkin: You like ARM, huh?
01:32:59 <copumpkin> n00p: yeah
01:33:32 <n00p> I have a spare ADSL modem/router around now that I bought a new one. Do you think it'd be useful to learn the assembly language for it?
01:33:43 <n00p> I could basically do whatever I want with it...
01:33:44 <geheimdienst> the right to bear ARMs
01:34:02 <copumpkin> n00p: I doubt it, but if you're into that kind of stuff maybe :)
01:34:26 <n00p> bbs
01:36:54 <Starfire> ARM assembly is OK, but the instruction encoding is nasty.
01:38:36 <copumpkin> Starfire: yeah :) I'm actually writing a decoder for it in haskell as we speak
01:39:04 <Starfire> I haven't a written a full decoder, but I wrote a classifier that detects if an instruction is a branch or a load or so on.
01:39:10 <copumpkin> ah
01:39:29 <copumpkin> that seems hard given the other encodings
01:39:36 <Starfire> All the extensions make it very tricky.
01:39:46 <copumpkin> yeah, I'm doing the 32-bit thumb stuff right now
01:40:39 <Starfire> "Instructions that look like this are arithmetic, except these that happen to do something entirely different."
01:41:27 <Starfire> It basically looks like they started with a clean encoding, and then started cramming random extra instructions into whatever parts of the instruction space they had left. :P
01:41:35 <copumpkin> but I mean, thumb's variable-length instructions
01:41:51 <copumpkin> seem like they'd make it hard to even know where boundaries are, let alone classify behavior
01:42:01 <copumpkin> yeah, that's definitely how it happened :)
01:43:09 <copumpkin> for example, thumb has two 16-bit encodings of branches, and two more 32-bit encodings of branches (with link)
01:44:19 <Starfire> I think the regular encoding doesn't really have a concept of branch instructions as such (except for the extensions that go into Thumb and so on). Anything that modifies the PC is a branch.
01:45:13 <copumpkin> yeah
01:57:45 <ddarius> jmp addr is just mov eip, addr (on x86)
01:57:52 <ddarius> (conceptually, of course)
02:00:23 <mm_freak> > unwords . uncurry (zipWith (++)) . first reverse . unzip . map (splitAt 1) . words $ "sony playstation"
02:00:24 <lambdabot>   "pony slaystation"
02:00:33 <atude> lol
02:01:04 <copumpkin> glad to see mm_freak is doing useful things with haskell
02:01:08 <copumpkin> :)
02:01:15 <mm_freak> of course
02:01:24 <copumpkin> probably more useful than what I'm doing :P
02:01:28 <mm_freak> i'm showing THE TRUTH
02:01:50 <copumpkin> how many ponies died to bring you your playstation?
02:02:20 <mm_freak> > splitAt 7 . drop 26 . map head $ cake
02:02:21 <lambdabot>   ("TTOOTOO","TASCIICAT")
02:02:26 <mm_freak> NO!
02:02:30 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
02:02:31 <lambdabot>   ("TOOTOOT","ASCIICAT")
02:02:51 <copumpkin> is that the cake recipe from portal?
02:03:02 <copumpkin> > cake
02:03:03 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
02:03:12 <mm_freak> dunno, you would kick me for trying to read it completely here ;)
02:03:24 <copumpkin> > unlines cake
02:03:25 <lambdabot>   "One 18.25 ounce package chocolate cake mix.\nOne can prepared coconut peca...
02:03:37 <geheimdienst> @google tacocat is a palindrome
02:03:38 <lambdabot> No Result Found.
02:03:43 <geheimdienst> bah
02:03:52 <geheimdienst> http://2.bp.blogspot.com/_BkIXjr-EP3E/SGcbY6g9c1I/AAAAAAAAAPs/C-ku44Cq45g/s400/tacocat.jpg
02:04:02 <geheimdienst> > last cake
02:04:03 <lambdabot>   "That will deodorize and preserve putrid tissue."
02:04:20 <mm_freak> hehe
02:04:45 <copumpkin> yeah, that's it :P
02:04:56 <mm_freak> > let theAnswer = 42; away = theAnswer in drop away cake
02:04:57 <lambdabot>   []
02:07:15 <mm_freak> > let the = id; garbage = ($ 42) drop in the garbage the cake
02:07:15 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
02:08:11 <mm_freak> ok, back to useful stuff
02:13:30 <bastl> Hi, is there any gtk2hs expert around?
02:13:54 <bastl> Why do the keyboard-shortcuts don't work in this snippet ?
02:14:00 <bastl> http://hpaste.org/30141/gtkmenu
02:36:42 <ivanm> preflex: seen Heffalump 
02:36:42 <preflex>  Heffalump was last seen on #darcs 52 minutes and 55 seconds ago, saying: morning
02:48:17 * hackagebot xilinx-lava 4.0 - The Lava system for FPGA design.  http://hackage.haskell.org/package/xilinx-lava-4.0 (SatnamSingh)
02:48:58 <Axman6> ooo, nice
02:49:05 <ivanm> hey Axman6 
02:49:12 * Axman6 has a xilinx FPGA
02:49:14 <Axman6> o/
02:49:28 <ivanm> we get assingment 3 to mark next friday apparently...
02:49:44 <Axman6> how fun, right before the break -_-
02:49:58 <ivanm> yup
02:51:19 <ManateeLazyCat> Any function do "split :: Int -> [a] -> [a]" that "split 4 [1..12] ==> ([1..4], [5..8], [9..12])" ?
02:51:41 <ManateeLazyCat> @hoogle Int -> [a] -> [a]
02:51:41 <lambdabot> Prelude drop :: Int -> [a] -> [a]
02:51:41 <lambdabot> Prelude take :: Int -> [a] -> [a]
02:51:42 <lambdabot> Data.List drop :: Int -> [a] -> [a]
02:51:53 <dschoepe> ManateeLazyCat: splitAt?
02:52:02 <dschoepe> > splitAt 4 [1..12]
02:52:03 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10,11,12])
02:52:13 <dschoepe> oh, misread your question, sorry
02:52:18 * hackagebot xilinx-lava 4.1 - The Lava system for FPGA design.  http://hackage.haskell.org/package/xilinx-lava-4.1 (SatnamSingh)
02:53:03 <ManateeLazyCat> > (fst, splitAt 4 snd) $ splitAt 4 [1..12]
02:53:04 <lambdabot>   Couldn't match expected type `[a]'
02:53:05 <lambdabot>         against inferred type `(a1, b) -...
02:53:05 <ivanm> ManateeLazyCat: repeated applications of splitAt
02:54:02 <ManateeLazyCat> > (\ (x, y) -> x, splitAt 4 y) $ splitAt 4 [1..12]
02:54:03 <lambdabot>   Couldn't match expected type `[a]'
02:54:04 <lambdabot>         against inferred type `SimpleRef...
02:54:07 <bastl> does anyone know why the shortcuts dont work in this gtk2hs example  ??
02:54:11 <bastl> http://hpaste.org/30141/gtkmenu
02:56:07 <ManateeLazyCat> > (\ (x, y) -> (x, splitAt 4 y)) $ splitAt 4 [1..12]
02:56:08 <lambdabot>   ([1,2,3,4],([5,6,7,8],[9,10,11,12]))
02:56:12 <ManateeLazyCat> Ah
02:57:22 <Axman6> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 4 xs)) [1..15]
02:57:23 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15]]
02:58:00 <Axman6> @hoogle (a -> Bool) -> a -> Just a
02:58:01 <lambdabot> Did you mean: a -> Bool -> a -> Maybe a /count=20
02:58:01 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
02:58:01 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
02:58:39 <ManateeLazyCat> bastl: If noone answer you, post to gtk2hs list.
02:58:57 <bastl> ok
02:59:58 <Axman6> @let toMaybe f x = if f x then Just x else Nothing in unfoldr (\xs -> splitAt 4 <$> toMaybe null xs) [1..15]
02:59:59 <lambdabot>   Parse error: KW_In
03:00:06 <Axman6> uh, yesh
03:00:10 <zygoloid> @hoogle (a -> Bool) -> a -> Maybe a
03:00:11 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:00:11 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
03:00:11 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
03:00:13 <Axman6> @let toMaybe f x = if f x then Just x else Nothing
03:00:14 <lambdabot>  Defined.
03:00:21 <zygoloid> @undef
03:00:30 <Axman6> > unfoldr (\xs -> splitAt 4 <$> toMaybe null xs) [1..15]
03:00:30 <zygoloid> @let toMaybe f x = find f [x]
03:00:31 <lambdabot>   Not in scope: `toMaybe'
03:00:31 <lambdabot>  Defined.
03:00:39 <Axman6> -_-
03:00:39 <zygoloid> :)
03:00:40 <Axman6> > unfoldr (\xs -> splitAt 4 <$> toMaybe null xs) [1..15]
03:00:41 <lambdabot>   []
03:00:49 <ManateeLazyCat> Axman6: lambdabot don't like you. :)
03:00:51 <Axman6> > unfoldr (\xs -> splitAt 4 <$> toMaybe notNull xs) [1..15]
03:00:52 <lambdabot>   Not in scope: `notNull'
03:01:03 <Axman6> > unfoldr (\xs -> splitAt 4 <$> toMaybe (not . null) xs) [1..15]
03:01:04 <lambdabot>   Not in scope: `toMaybe'
03:01:10 <Axman6> ...!
03:01:15 <Axman6> @let toMaybe f x = if f x then Just x else Nothing
03:01:16 <lambdabot>  Defined.
03:01:17 <Axman6> > unfoldr (\xs -> splitAt 4 <$> toMaybe (not . null) xs) [1..15]
03:01:18 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15]]
03:01:22 <Axman6> there!
03:01:24 <ManateeLazyCat> Axman6: Someday lambdabot will crazy you, enjoy! :)
03:01:49 <ManateeLazyCat> Axman6: Thanks, neat! :)
03:02:08 <Axman6> i think there's a function to do that in Data.List.Split
03:02:16 <ivanm> probably
03:02:43 <ManateeLazyCat> @hoogle splitEvery
03:02:43 <lambdabot> No results found
03:02:58 <ManateeLazyCat> :t Data.List.Split.splitEvery
03:02:59 <lambdabot> Couldn't find qualified module.
03:03:09 <ManateeLazyCat> give up ....
03:04:16 <ManateeLazyCat> splitEvery 4 [1..12] => [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
03:06:27 <ManateeLazyCat> splitEvery 4 "613f2ec212fd" ==> ["613f","2ec2","12fd"]
03:07:08 <ManateeLazyCat> dinner time
03:08:35 <mm_freak> ManateeLazyCat: 
03:08:51 <ManateeLazyCat> mm_freak: What?
03:09:15 <mm_freak> > let groupsOf n = takeWhile (not . null) . map (take n) . iterate (drop n) in groupsOf 4 [1..12]
03:09:16 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
03:09:35 <levantis> ooohmygod
03:09:40 <mm_freak> this is how i implement it usually
03:09:44 <ManateeLazyCat> mm_freak: Thanks, Data.List.Split.splitEvery has did it.
03:09:51 <mm_freak> oh, i see
03:10:00 <levantis> well, maybe it`s just me, but the recursive way seems much more understandable
03:10:09 <mm_freak> levantis: why?
03:10:20 <mm_freak> you just need to know what the individual functions do
03:10:31 <levantis> well, I need about half a minute to parse this whole concatenation monster ))
03:10:44 <levantis> i.e.
03:11:06 <mm_freak> levantis: composition of higher order functions is a paradigm used extensively in haskell…  and if you don't understand it, i recommend learning it =)
03:11:24 <levantis> okok. it`s just me.
03:11:38 <JoeyA> I'm trying to install the graphviz package with cabal install, but it doesn't actually work (even after "Registering graphviz-2999.10.0.1...")
03:11:41 <mm_freak> read it from right to left, it's just a chain of function calls
03:11:47 <JoeyA> In fact, cabal install graphviz again rebuilds it all.
03:11:58 <mm_freak> (f . g . h) x = f (g (h x))
03:12:18 <levantis> i know how this all works. it`s just you need to remember (or guess) the signature of every function
03:12:27 <levantis> and imagine every  composition step
03:12:48 <mm_freak> well, the functions are quite common…  although i probably use 'iterate' much more often than others
03:12:55 <mm_freak> it's a much simpler variant of 'unfoldr'
03:12:59 <mm_freak> > iterate (+1) 0
03:13:00 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
03:13:38 <mm_freak> always infinite and less stateful
03:14:03 <copumpkin> hmm, I'm following #1 kissy boy on twitter
03:14:11 <copumpkin> little did I know
03:14:16 <levantis> well, in this particular case, i`d write [0..], but whatever
03:14:48 <ivanm> copumpkin: I'm sure everyone else in this channel will agree with me that we're very happy for you, but that really belongs in -blah... ;-)
03:14:53 <levantis> by the way, congratulate me with the first entering of an IRC channel. with all this skype I managed to miss it completely
03:15:07 <copumpkin> ivanm: well, the reason I bring it up is because it turns out he's a well known member of this community :)
03:15:15 <copumpkin> and that's why I'm following him
03:15:19 <ivanm> copumpkin: he is?
03:15:27 <BONUS> he is ME!
03:15:28 <mm_freak> > iterate (\x -> mod (x^2) 85465299488057057) 2
03:15:29 <lambdabot>   [2,4,16,256,65536,4294967296,71704683777284361,63365215824605861,2585561711...
03:15:31 <copumpkin> he just happened to change his name on twitter, so I didn't recognize him
03:15:33 <mm_freak> what about this one? ;)
03:15:34 <copumpkin> BONUS: ZOMG
03:15:39 <ivanm> JoeyA: what's wrong?
03:15:46 * ivanm is the maintainer of graphviz
03:15:49 <JoeyA> hmm, it worked now (after throwing a ghc-pkg recache at it)
03:15:59 <mm_freak> or even just:
03:16:03 <mm_freak> > iterate (*2) 1
03:16:04 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
03:16:08 * BONUS disappears in a puff of smoke
03:16:08 <ivanm> *sigh* trust BONUS to have a completely ridiculous twitter handle...
03:16:09 <JoeyA> A bug in cabal making it look like a package installed but not actually letting me use it.
03:16:16 <ivanm> JoeyA: what bug?
03:16:26 <JoeyA> A bug I encountered.
03:16:38 <copumpkin> lol
03:17:01 <levantis> i just meant that one case with consecutive integers. I do admit that iterate is a handy funcitno )
03:18:21 <mm_freak> levantis: yeah, my point is that a lot of people would write \xs -> [ x+1 | x <- xs ], where it's much better just to write map (+1)
03:20:23 <levantis> ooh. I thought qBasic was weird.
03:20:49 <levantis> wait. I had a nice list comprehension example somewhere
03:22:24 <mm_freak> levantis: i have yet to see a list comprehension, which i wouldn't prefer to write as a composition of higher order functions =)
03:22:45 <levantis> ok ) I`ll try really hard to find one )
03:23:20 <mm_freak> your smileys are missing eyes, or are they supposed to be unbalanced parentheses?
03:24:26 <levantis> mm_freak: Well, that`s how smileys look in here. They`re just faster to write :@} 
03:25:02 <levantis> And I reserve (: smyley for sarcasm
03:25:33 <mm_freak> i see
03:26:09 * osfameron dislikes left-smiling emoticons
03:26:26 <osfameron> as my brane has associated "(" with a frown, even if it turns out the eyes are on the other side
03:26:28 <ivanm> @ask chrisdone I take it hackagebot isn't back yet?
03:26:29 <lambdabot> Consider it noted.
03:27:13 <levantis> osfameron: :D
03:27:42 <levantis> mm_freak: well, this one. loio = (+):[\x y -> foldl op x (replicate (y-1) x)|op<-loio]
03:28:56 <levantis> it doesn`t work well on indexes larger than 5 or 6 because of lazyness and finite memory, but at least give all the +,*,^ and the next one
03:29:26 <levantis> pardon my mistypes, I hate this keyboard
03:29:26 <mm_freak> loio = (+) : map (\op -> \x y -> foldl op x (replicate (y - 1) x)
03:29:43 <mm_freak> sorry
03:29:46 <mm_freak> loio = (+) : map (\op -> \x y -> foldl op x (replicate (y - 1) x) loio
03:30:11 <mm_freak> and you can collapse it to:
03:30:16 <mm_freak> loio = (+) : map (\op x y -> foldl op x (replicate (y - 1) x) loio
03:31:02 <mm_freak> also add one missing ) after "x)"
03:31:03 <mm_freak> =)
03:31:04 <levantis> erm. 
03:31:06 <levantis> yeah )
03:31:12 <levantis> I mean, yeah :)
03:32:09 <levantis> mm_freak: no, I don`t get it. where does it get infinite?
03:32:21 <levantis> oooh
03:32:25 <min> Is there a library function like 'f x = case x of {Just y -> [y]; Nothing -> []'?
03:32:41 <mm_freak> levantis: anyway, that's probably not the way i would write it
03:32:43 <ivanm> @type fromMaybe
03:32:44 <lambdabot> forall a. a -> Maybe a -> a
03:32:46 <Deewiant> catMaybes . return
03:32:48 <ivanm> dammit, that's not it
03:32:52 <ivanm> @type maybeToList
03:32:53 <lambdabot> forall a. Maybe a -> [a]
03:32:56 <ivanm> voila!
03:33:02 <ivanm> min: ^^
03:33:11 <min> oh! that's cool
03:33:25 <ivanm> listToMaybe == safeHead
03:33:28 <copumpkin> @free maybeToList :: forall a. Maybe a -> [a]
03:33:29 <lambdabot> $map f . maybeToList = maybeToList . $map_Maybe f
03:33:42 <copumpkin> mmm
03:34:42 <levantis> mm_freak: ok, you win. I guess it would look more simple or elegant if not for the imperative language addiction
03:34:46 <mm_freak> levantis: 
03:34:49 <mm_freak> loio = iterate (\op x y -> foldl1 op (replicate y x)) (+)
03:34:58 <levantis> yeah
03:35:05 <levantis> that`s definetely simplier
03:35:20 <ddarius> Using foldl makes baby Jesus cry.
03:35:27 <mm_freak> and make that foldl1' to make it stricter =)
03:35:30 <copumpkin> some of us like making him cry
03:36:02 <mm_freak> this list also disregards units
03:36:10 <mm_freak> > (loio !! 2) 5 0
03:36:11 <mm_freak> *** Exception: Prelude.foldl1: empty list
03:36:11 <lambdabot>   Not in scope: `loio'
03:36:20 <copumpkin> lol
03:36:31 <min> trans test "ae"
03:36:39 <min> oh, wrong window :/
03:37:12 <levantis> mm_freak: mine doesn`t :p
03:38:43 <mm_freak> levantis: yes, yours simply gives the wrong answer ;)
03:38:51 <levantis> :(
03:39:10 <mm_freak> try 5^0 with your function
03:39:26 <levantis> yeah, I got it already. that isn`t much better, is it?
03:39:33 <mm_freak> it's worse
03:39:47 <mm_freak> throwing an exception is better than silently giving a wrong answer
03:40:14 <levantis> it is
03:40:32 <mm_freak> giving the right answer would be best though =)
03:44:01 <mm_freak> loio = iterate (\op x y -> foldl op (op 0 1) (replicate y x)) (+)
03:44:14 <mm_freak> it's a hack, but it works
03:44:32 <mm_freak> no, it doesn't
03:44:35 <mm_freak> forget it =)
03:44:36 <copumpkin> lol
03:44:48 <copumpkin> you can define a simple fold over naturals that lets you define all of them quite nicely
03:44:57 <mm_freak> yeah
03:45:21 <mm_freak> or just keep track of the identities =)
03:46:09 <levantis> yeah, prove me the identities for the 20th one )
03:47:47 <copumpkin> @let foldNat :: a -> (a -> a) -> Mu Maybe -> a; foldNat z _ (In Nothing) = z; foldNat z s (In (Just x)) = s (foldNat z s x)
03:47:48 <lambdabot>  Defined.
03:48:51 <levantis> copumpkin: what`s Mu ?
03:49:06 <mm_freak> levantis: 'fix' for types, don't worry about it for now =)
03:49:08 <copumpkin> takes the type-level fixed point of a * -> *
03:49:23 <mm_freak> Mu Maybe = Maybe (Maybe (Maybe (Maybe (Maybe …
03:49:31 <levantis> whouch
03:49:36 <Cale> newtype Mu f = In { out :: f (Mu f) }
03:49:39 <copumpkin> which happens to be equivalent to peano naturals
03:49:47 <mm_freak> Nothing = 0, Just Nothing = 1, Just (Just Nothing) = 2, etc.
03:49:53 <mm_freak> a representation of natural numbers =)
03:50:02 <Cale> You need extra Ins :)
03:50:11 <mm_freak> Cale: just for mental model =)
03:50:14 <Cale> yeah
03:52:01 <mm_freak> btw, if, for a programming language, the fixed point combinator ever produces anything but bottom, does that prove that the language is not completely strict?
03:53:06 <Cale> > In (Just (In Nothing))
03:53:07 <lambdabot>   In {out = Just (In {out = Nothing})}
03:53:14 <Cale> > In (Just (In (Just (In Nothing)))
03:53:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:53:19 <Cale> > In (Just (In (Just (In Nothing))))
03:53:20 <lambdabot>   In {out = Just (In {out = Just (In {out = Nothing})})}
03:53:31 <mm_freak> :t In (Just (In Nothing))
03:53:32 <lambdabot> Mu Maybe
03:53:50 <copumpkin> @let toInteger :: Mu Maybe -> Integer; toInteger = foldNat 0 succ
03:53:51 <lambdabot>  Defined.
03:53:59 <copumpkin> > toInteger $ In (Just (In (Just (In Nothing))))
03:54:00 <lambdabot>   Ambiguous occurrence `toInteger'
03:54:01 <lambdabot>  It could refer to either `L.toInteger', d...
03:54:03 <copumpkin> bah
03:54:08 <copumpkin> > L.toInteger $ In (Just (In (Just (In Nothing))))
03:54:09 <lambdabot>   2
03:54:19 <mm_freak> :t In (Right (In (Right (In $ Left "abc"))))
03:54:20 <lambdabot> Mu (Either [Char])
03:54:35 <ddarius> copumpkin: Lash yourself for not writing a generic fold.
03:54:54 * copumpkin lashes himself
03:55:24 <copumpkin> generic how?
03:55:35 <mm_freak> :t let c = In (putChar 'x' >> return c)
03:55:35 <lambdabot> <no location info>:
03:55:36 <lambdabot>     not an expression: `let c = In (putChar 'x' >> return c)'
03:55:58 <mm_freak> :t let c = In (putChar 'x' >> return c) in c
03:55:58 <lambdabot> Mu IO
03:56:03 <copumpkin> lol
03:56:07 <ddarius> :t let fold f = f . fmap (fold f) . out in fold
03:56:08 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
03:56:14 <mm_freak> i wonder what that does =)
03:56:17 <copumpkin> ddarius: oh :)
03:56:40 <ddarius> :t let fold f = f . fmap (fold f) . out in fold (maybe 0 succ) (In (Just (In (Just (In Nothing)))))
03:56:41 <lambdabot> forall b. (Num b, Enum b) => b
03:56:43 <ddarius> > let fold f = f . fmap (fold f) . out in fold (maybe 0 succ) (In (Just (In (Just (In Nothing)))))
03:56:45 <lambdabot>   2
03:56:50 <copumpkin> that is nicer, isn't it
03:57:15 <copumpkin> but that way lie the zygohistomorphic prepromorphisms
03:57:29 <ddarius> > let fold f = f . fmap (fold f) . out in fold (maybe 0 (uncurry (:))) (In (Just (1, In (Just (2, In Nothing)))))
03:57:30 <lambdabot>   Couldn't match expected type `(a, [a])' against inferred type `[a]'
03:57:40 * copumpkin should resume his old agda *morphism code
03:57:42 <ddarius> > let fold f = f . fmap (fold f) . out in fold (maybe [] (uncurry (:))) (In (Just (1, In (Just (2, In Nothing)))))
03:57:43 <lambdabot>   Couldn't match expected type `(a, [a])' against inferred type `[a]'
03:57:49 <copumpkin> although many of them can't be expressed in agda :(
03:57:53 <mm_freak> :t let c = In (putStrLn "HELL!" >> return c) in c
03:57:54 <lambdabot> Mu IO
03:57:57 <mm_freak> that's a dantemorphism
03:58:07 <ddarius> :t maybe [] (uncurry (:))
03:58:08 <lambdabot> forall a. Maybe (a, [a]) -> [a]
03:58:46 <copumpkin> ddarius: how's twelf treating you?
03:58:49 <mm_freak> i think you can actually run it using 'fix'
03:59:15 <mm_freak> or perhaps foldIO =)
03:59:49 <ddarius> copumpkin: I got it to where it would check a proof of mine in the modelled logic, but writing the proofs is overly tedious and I don't completely grok how I can get Twelf to do more of the work for me.
03:59:59 <copumpkin> ah
04:00:46 <ddarius> The fmap is too shallow.
04:01:10 <ddarius> :k O
04:01:11 <lambdabot> Not in scope: type constructor or class `O'
04:01:18 <ddarius> :k :.
04:01:19 <lambdabot> parse error on input `:.'
04:01:24 <ddarius> :k (:.)
04:01:25 <lambdabot> Not in scope: type constructor or class `:.'
04:01:53 <ddarius> copumpkin: I think a functional logic proof language wouldn't be bad.
04:03:44 <ddarius> copumpkin: You could accompany your hylomorphisms with proofs of termination or productivity.
04:04:16 <ddarius> copumpkin: Right now I'm writing assembly.
04:07:46 <copumpkin> assembly for what?
04:09:21 <ddarius> copumpkin: I don't really know yet.  Right now I have a small bootloader that switches to an unreal mode.
04:12:10 <copumpkin> unreal mode :o
04:12:26 <copumpkin> ah I see
04:17:31 <thelevantis> ddarius: why write a new one? uncommon architecture?
04:18:14 <ddarius> thelevantis: I'm intending to write something that runs straight off the hard drive.
04:19:56 <thelevantis> so, usually, when running the hard drive bootloader, the computer already isn`t in real mode?
04:20:26 <thelevantis> It`s just that I`ve seen a couple of ready small bootloaders with a community (and, presumably, no bugs)
04:20:40 <thelevantis> and I`ve even compiled and run one successfully
04:44:28 <kremsera> in my thesis im working on a th to cuda compiler-library
04:45:08 <kremsera> you feed in a th expression - and it generates the corresponding callable cuda-code
04:45:55 <kremsera> but im still looking for a cool name for it - any suggestions? ;)
04:46:14 <ivanm> thuda? :p
04:46:25 <copumpkin> cudath
04:46:50 <kremsera> ok both noted on my list :)
04:47:03 * ivanm was joking...
04:47:14 <ivanm> kremsera: why TH rather than a specialised DSL?
04:48:03 <kremsera> because you cant overload special syntax like, if then else and there is no compile time evaluation, interpretation overhead ...
04:48:06 <kremsera> th rocks
04:48:51 <kremsera> and: everyone else goes the dsl way ;)
04:50:04 <kremsera> since haskell is quite pure i want to integrate some kind of supercompiler in it so everything that can be evaluated at compile time - will be (except huge lists)
04:50:46 <ivanm> well, I've been playing with TH a bit recently and I can't see how it would be easy to do CUDA stuff with TH
04:50:56 <ivanm> then again, a lot of my problems are due to the lack of documentation
04:50:57 <kremsera> well it is ;)
04:51:10 <kremsera> i can already generate cuda code from th
04:51:44 <kremsera> at compile time - so there is no overhead for this
04:52:03 <ivanm> andrewsw: so, is hpaste.el working? and is this the hpaste.el that's currently on the wiki?
04:52:26 <ivanm> oh, saw your other link
04:52:43 <kremsera> ivanm, why would you prefer a dsl?
04:53:09 <ivanm> well, it's the more usual approach
04:53:34 <kremsera> with lots of drawbacks
04:53:40 <kremsera> why is it taken that often?
04:53:58 <ivanm> and I don't see how a metaprogramming environment for Haskell would behave nicely for translation to CUDA
04:54:02 <Adamant> probably because it's easier
04:54:09 <ivanm> and lets you write a customised language
04:54:44 <ivanm> there was a nice talk at PEPM about that in January, where one way of looking at it is that we're getting more and more at having general purpose languages being used just to write DSLs
04:54:55 <ivanm> (of course, at times the line blurs between a library and a DSL)
04:55:56 <kremsera> most projects using a dsl to generate cuda code are just trying to mimic the haskell syntax - with no specific dsl benefits
04:56:11 <ivanm> what about repa?
04:56:17 <ivanm> or is that just a library?
04:56:30 <kremsera> hmm?
04:56:31 <copumpkin> you're thinking of accelerate
04:56:33 <kremsera> link plz !
04:56:39 <ivanm> could be
04:56:44 <ivanm> well, there's this: http://hackage.haskell.org/package/cuda
04:56:46 <kremsera> yes accelerate, warp speed haskell,
04:56:49 <copumpkin> @hackage accelerate
04:56:50 <lambdabot> http://hackage.haskell.org/package/accelerate
04:57:13 <ivanm> preflex: seen TacticalGrace
04:57:13 <preflex>  TacticalGrace was last seen on #ghc 11 hours, 19 minutes and 55 seconds ago, saying: copumpkin: yeah, has only one arch, I checked that
04:57:19 <kremsera> the cuda package is (somehow) part of accelerate - its just  some cuda bindings
04:57:38 <ivanm> you sure?
04:57:42 <ivanm> accelerate doesn't dep on it...
04:57:47 <copumpkin> nah, it isn't related
04:57:56 <copumpkin> very low-level bindings
04:57:57 <ivanm> only relation I can see is that it's by the same research group
04:59:37 <kremsera> it depends on the cuda package
05:00:16 <ivanm> oh, right, if you tell it to use cuda
05:00:27 <ivanm> because the cuda package abstracts away the FFI bindings probably
05:00:33 <ivanm> *lets them abstract away
05:00:42 <kremsera> well why would one use accelerate without cuda? ;)
05:00:47 <ivanm> llvm?
05:00:54 <copumpkin> for a while they hadn't even released the cuda backend
05:00:55 <ivanm> opencl? :p
05:00:57 <copumpkin> it was just an interpreter
05:01:06 * ivanm wished hackage was smarter about showing deps
05:01:07 <kremsera> oh right ;)
05:01:50 <kremsera> i also want to keep the option open to add opencl support in the future
05:01:53 <ivanm> interesting: despite cuda not building on hackage, accelerate does (even though the cuda flag is enabled by default)
05:02:12 <kremsera> what do you mean by "not building" ?
05:02:13 <ivanm> kremsera: I still fail to see the advantages of using TH for this
05:02:34 <ivanm> oh, it's just haddock that fails to build
05:02:58 <ivanm> kremsera: isn't it better to abstract the whole GPGPU stuff into a nice haskell library than to try and do compile-time code generation?
05:03:37 <kremsera> ivanm, thats what my project is about
05:04:07 <ivanm> ummmm, except the whole point of TH _is_ compile-time code generation...
05:04:08 <kremsera> ivanm, using th for compile-time code generation of cuda from usual haskell code
05:04:32 <ivanm> right, but why use TH?
05:04:46 <kremsera> to *do* something at compile-time?
05:04:58 <ivanm> why do it at compile time?
05:05:02 <ivanm> why not have FFI bindings?
05:05:03 <kremsera> to get the ast of arbitrary haskell expressions
05:05:24 <ivanm> oh, are you doing some kind of expression mangling to try and translate "normal" Haskell into CUDA expressions?
05:05:31 <kremsera> right
05:05:33 <ivanm> i.e. something akin to a CUDA backend for GHC?
05:05:41 <kremsera> similar
05:05:47 <ivanm> or a Haskell -> CUDA translator?
05:05:54 <kremsera> thats the whole idea, yes
05:06:05 <ivanm> that makes more sense now then
05:06:26 <Ke> dynamic mepory allocation is slow^n on a gpu
05:06:28 <ivanm> OK, for a name: CHUDA ? :p
05:06:34 <Ke> memory allocation
05:06:44 <ivanm> Ke: how does one raise slowness to a power?
05:06:54 <copumpkin> by writing ^n after it
05:07:00 <kremsera> lol
05:07:04 <ivanm> heh
05:07:09 <Ke> yes
05:07:10 <ivanm> copumpkin: smart arse
05:07:23 * copumpkin hides
05:07:25 <ivanm> that just denotes that you should raise it to that power
05:07:32 <ivanm> how do you actually perform that calculation/operation?
05:07:45 <Cale> Obviously only the w was exponentiated there
05:07:53 <ivanm> oh?
05:08:47 <Cale> slow^n = slow...w (with n occurrences of w)
05:08:50 <ivanm> not sure that we're going by TeX rules here...
05:10:22 <kremsera> thuda is still the best name i got so far :o
05:10:23 <copumpkin> it's just multiplication rules
05:11:05 <ivanm> kremsera: except the acronyms no longer make much sense...
05:11:16 <ivanm> anyway, you probably don't need the T there
05:11:17 <copumpkin> @let slow n = "slo" + replicate n 'w'
05:11:18 <lambdabot>  <local>:1:9:
05:11:18 <lambdabot>      No instance for (Num [Char])
05:11:18 <lambdabot>        arising from a use of ...
05:11:22 <copumpkin> @let slow n = "slo" ++ replicate n 'w'
05:11:23 <lambdabot>  Defined.
05:11:26 <copumpkin> > slow 6
05:11:27 <lambdabot>   "slowwwwww"
05:11:43 * copumpkin sits back and looks satisfied
05:12:16 <ivanm> oh yeah?
05:12:57 * ivanm goes off to consume frozen yoghurt
05:47:01 <fryguybob> @botsnack
05:47:01 <lambdabot> :)
05:48:59 <kremsera> whats a botsnack?
05:49:53 <ivanm> a snack for bots
05:49:54 <ivanm> duh
05:49:58 <ivanm> @botsmack
05:49:58 <lambdabot> :)
05:50:04 <applicative> no one knows, but it makes her happy
05:50:05 <ivanm> (lambdabot is a masochist!)
05:50:14 <ivanm> probably similar to scooby snacks
05:50:15 <fryguybob> @help botsnack
05:50:16 <lambdabot> botsnack. Feeds the bot a snack
05:50:25 <fryguybob> @help botsmack
05:50:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:51:04 <ivanm> nah, botsmack resolves to botsnack
05:51:07 <ivanm> @. vixen botsnack
05:51:07 <lambdabot> why do you keep repeating yourself?
05:51:17 <kremsera> lol
05:51:21 <copumpkin> ivanm: but do you know that it isn't botsnack resolving to botsmack?
05:51:27 <copumpkin> maybe the authors of lambdabot hated her
05:51:34 <ivanm> copumpkin: looking at the source?
05:51:35 <tab> "her" ? :)
05:51:41 <copumpkin> did you actually read it!
05:51:47 <ivanm> unless, of course, Cale is running a privately customised version for us to use...
05:51:54 <ivanm> copumpkin: IIRC I did read that bit once
05:52:00 <copumpkin> oh okay
05:52:01 <copumpkin> just making sure
05:52:21 <ivanm> boy, you'll believe _anything_, won't you! :p
05:52:53 <zygoloid> @batsmock
05:52:53 <lambdabot> Unknown command, try @list
05:52:54 <zygoloid> @batsnock
05:52:55 <lambdabot> :)
05:52:55 <applicative> does anyone know what devices the main editors use to get type signatures to insert?  
05:53:05 <zygoloid> ^ edit distance ftw
05:53:12 <ivanm> well, emacs does it using the magic of elisp
05:53:20 <ivanm> by running the file through ghci
05:54:26 <applicative> ivanm, i see.   there is the TypeOf package, by dons, but it won't extract signature for things in where clauses, does haskell-mode do that?
05:54:35 <ivanm> no
05:54:41 <ivanm> not sure if it's possible
05:54:52 <ivanm> since ghci doesn't tell you those
05:55:03 <copumpkin> @butsmack
05:55:03 <lambdabot> :)
05:55:13 <zygoloid> possibly could be done with GHC API, but it'd be tricky
05:55:16 <applicative> no, you'd have to rewrite the module before feeding it.  i assume that could be done systemativcally
05:55:55 <applicative> lennart augustson said 'any good editor' does it.  i wonder what he uses?  ed?
05:56:14 <applicative> -- highly customized of course
05:56:18 <ivanm> heh
05:56:27 <ivanm> is that bit like no true scotsman? :p
05:57:02 <zygoloid> Your search for: "any good editor" returned 1 results. 1) vim
05:57:10 <Saizan> you can get a fully annotated AST with the ghc-api
05:57:23 <applicative> zygloid, so vim does it?
05:57:33 <Saizan> so you'll also get types for where clauses
05:58:01 <zygoloid> applicative: i was kidding :) but i'd not be surprised if it did. i don't use any fancy scripting stuff for my haskell editing
05:58:17 <applicative> that seems like it'd be a nightmare.  TypeOf is very simple...
05:58:24 <zygoloid> (i'd be surprised if haskell-mode in emacs doesn't do it to be honest)
05:58:36 <ivanm> do what?
05:58:44 <ivanm> it doesn't put type sigs in for where clauses
05:58:49 <zygoloid> ;(
05:59:01 <applicative> zygloid, i dimly remember chrisdone saying it does it, or there's an extensionfor it. 
05:59:05 <ivanm> because they're usually unnecessary, and if polymorphic then without scopedtypevariables will usually cause problems
05:59:14 <ivanm> applicative: oh, maybe he's hacked something together
05:59:18 <ivanm> preflex: seen chrisdone
05:59:19 <preflex>  chrisdone was last seen on #haskell 16 hours, 24 minutes and 47 seconds ago, saying: sinelaw: x?
05:59:33 <zygoloid> ivanm: being able to display the types is valuable even if you don't want them inserted
05:59:34 <applicative> he mentioned it to convince me to uses haskell-mode
05:59:49 <ivanm> zygoloid: true
05:59:56 <applicative> zygloid, true
06:00:57 <applicative> i chimed in with someone complaining about un-type-signatured- wheres on the damned reddit/r/haskell, which got me thinking.  
06:01:56 <applicative> it would help, where reading somebody's nightmare def. if you could extract the signature.  
06:04:10 <Saizan> haskell-mode will only give you the toplevel ones
06:04:46 <Saizan> i agree it'd be nice, maybe scion already does it, if you can make it work
06:05:13 <applicative> Saizan yeah, i think chrisdone was alluding to a further extension.  I wonder what Lennart Aug. was referring to.
06:05:43 <applicative> wait, may be was speaking utopianly: in the future, when there are good editors, any good editor will ...
06:05:47 <Saizan> applicative: where?
06:06:13 <Saizan> i think Phyx's visual haskell will have that
06:06:37 <Zao> Saizan: I believe it can give you a sig for just about any selection of source.
06:06:38 <applicative> hmm, hunting for it
06:06:58 <Saizan> i don't think he released it yet?
06:07:03 <Zao> Saizan: Correct.
06:07:06 <ddarius> Zao: How is it implemented?
06:07:14 <Zao> ddarius: Magic. Also, see the blog.
06:07:19 <Zao> http://mistuke.wordpress.com/
06:07:28 <Saizan> ghc-api, i'm sure
06:08:03 <Zao> http://mistuke.wordpress.com/2010/08/09/quickinfo/
06:08:35 <applicative> Saizan,  http://www.reddit.com/r/haskell/comments/daozq/the_static_argument_transformation/c0yysea I assume augustss is Lennart Augustss..
06:10:28 <applicative> Somehow the procedure seems like it could be easier than using the full force of ghc-api. I feel i am acting mechanically in making the where'd definition top leverl
06:10:46 <applicative> adding a few extra variables on the left...
06:11:03 <Saizan> mangling the source like that is quite a pain
06:11:33 <applicative> yes but it's in fact what the befuddled reader is inclined to do, though
06:11:41 <Saizan> also, in the next ghc version the typing rule for where clauses differs significantly from toplevel defs
06:12:02 <applicative> o really that suggests its best not to meditate on it for the moment
06:12:58 <Saizan> the HM-style implicit generalization will happen only for toplevel defs
06:14:14 <Razz_> Hey there, I'm trying to implement a small virtual machine in Haskell and need to handle a state. I have the following type for which I need to implement (my first) a monad. Could you offer some assistance? 
06:14:15 <Razz_> newtype MSM a = MSM (State -> Maybe (a, State))
06:15:01 <applicative> i hacked dons' typeOf into Textmate, it's nice, but it'd be much cooler with this functionality.  Of course, as we also know from reddit, foe nt of wisdom, source of joy: Textmate users are "stupid flaunting ruby-textmate-frameworks macfags"
06:15:59 * hackagebot Hipmunk 5.2.0.1 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.1 (FelipeLessa)
06:16:04 <Saizan> Razz_: have you looked at the source for the State monad?
06:16:16 <osfameron> applicative: ooo, that /is/ wise! ;-)
06:16:46 <Razz_> I have, but that uses a type constructor with two values a and s, I only have a.
06:16:48 <Adamant> applicative: I think the foe misspelling is more apt. :P
06:17:06 <Razz_> I have to do it as an assignment so part of the code was given including the newtype.
06:17:08 <Saizan> Razz_: a and s are type variables
06:17:23 <applicative> Adamant, sorry my typing is on a par with my comprehension of type subtleties
06:17:56 <Saizan> Razz_: anyhow, i meant that you can use that as inspiration, since your type is very similar, just take s = YourState
06:18:00 <Adamant> applicative: no problem, I was serious. sometimes unintentional typos are funny and apropos :P
06:18:16 <Razz_> Saizan: thx I'll look into that :-)
06:18:18 * applicative wonders what we "stupid flaunting ruby-textmate-frameworks macfags" are supposed to be flaunting
06:18:39 * applicative doesn't use ruby or Frameworks, so he can pretend not to be offended
06:20:10 <Adamant> applicative: slavish devotion to Steve Mobbs. same thing the Simpsons parodied. :P
06:20:12 <min> Take a look at the definition of stateT. 'runStateT :: s -> m (a, s)', where m is a monad. Your 'State' value is just an instance of 's', in this case. So you have StateT s m a where s = State and m = Maybe.
06:20:30 <Adamant> (I josh, of course)
06:20:41 <applicative> Razz_, is there a module you could paste on hpaste I want to follow your advisors
06:20:46 <applicative> hpaste.org
06:21:03 <Razz_> Just a sec
06:21:21 <Saizan> i'd be happy if we could get something as nice as agda-mode
06:21:36 <applicative> what aspect of agda-mode
06:22:17 <Razz_> applicative: http://hpaste.org/30144/msm
06:23:45 <Saizan> applicative: have you used it? the whole goal types/context of them 
06:25:02 <mm_freak> ski: you said that i can model a list monad using CPS as:  r -> (a -> r -> r) -> r
06:25:19 <mm_freak> just as a hint on how exactly to do this, does 'r' need to be a Monoid?
06:27:23 <zygoloid> mm_freak: think about the type of foldr.
06:28:11 <applicative> I see, isn't your MSM a the same as StateT State Maybe a -- with your State type?  As I think Saizan was saying  newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}
06:29:45 <mm_freak> zygoloid: i see the similarity
06:29:52 <mm_freak> applicative: my StateT looks very different =P
06:30:35 <zygoloid> mm_freak: given a list, obviously you can make the corresponding partially-applied foldr. can you see how to convert from a partially-applied foldr to the list?
06:32:49 <applicative> what StateT is yours, mm_freak  I was just looking at mtl http://hackage.haskell.org/packages/archive/mtl/1.1.1.0/doc/html/src/Control-Monad-State-Lazy.html
06:34:03 <edon> cabal seems to install the package happy (it's in ~/.cabal/bin/happy) but when i cabal list happy, i see it marked as uninstalled, and it's a dependency for happstack, so it doesn't allow me to continue installing happstack
06:34:53 <zygoloid> edon: does "cabal list happy --user" also say it's not installed?
06:35:40 <edon> zygoloid: it says that '--user' is an unrecognized option
06:36:39 <mm_freak> zygoloid: ok, i think i get it
06:37:14 <mm_freak> applicative: newtype StateT r s m a = StateT { getStateT :: s -> (s -> a -> m r) -> m r }
06:37:17 <mm_freak> that's mine
06:37:38 <zygoloid> edon: sorry, try ghc-pkg list happy
06:38:23 <mm_freak> applicative: http://hackage.haskell.org/packages/archive/contstuff/0.1.0/doc/html/src/Control-ContStuff.html#StateT
06:38:43 <edon> zygoloid: it gives the paths to two files named package.conf.d
06:39:08 <zygoloid> edon: if it doesn't give any other output than that, then the happy package isn't successfully registered.
06:39:35 <Razz_> applicative: I'm too new to monads to completely understand the implementation of StateT, what happens in the implementation of bind for StateT?
06:39:37 <zygoloid> perhaps that's expected for a binary-only package though?
06:39:51 <zygoloid> edon: make sure the happy binary is in your $PATH.
06:40:09 <edon> zygoloid: ahh thanks, i don't think it's in my $PATH
06:40:46 <edon> nope, it is actually
06:42:20 <applicative> Razz_ I'm trying to compare.  Actually, I prefer a custom monad like yours to a state transformer, but you can't help noticing you're trying to implement some of the stuff implemented in your commented defs. 
06:43:00 <Razz_> applicative: true
06:44:26 <applicative> return a = MSM $ \s -> Just (a,s) is the same as mtl's return a = StateT $ \s -> return (a, s) seems like.  The second return is in your case the return of Maybe, ie. Just (a,s)
06:45:30 <applicative> Razz, isn't the problem with your instance Monad MSM, the sudden appearance of Bool in the definition of >>= ? Maybe i'm no following
06:46:49 <Starfire> Is there an easy way to create a static library (.a file) from a Haskell library?
06:47:12 <applicative> Saizan, yes, I have used agda mode but only for a couple of weeks.  
06:48:03 <Razz_> applicative: I was trying to figure out how it should work. I figured that the first part of the tuple in the Maybe should be a Boolean that determines whether or not interpretation should continue. However, that is of course not really generic implementation-wise 
06:48:10 <Starfire> I mean, I have some Haskell code that has foreign export declarations, and I'd like to make a .a file that I can link into some C program without having to link using ghc.
06:51:13 <Razz_> applicative: as far as I understand it I have a MSM with in it a function from a state to a maybe containing a tuple of (value, state'). Then I to bind a function to this monad I need to ... ?
06:52:15 <applicative> oh, i was pasting them side by side for clearer thinking http://hpaste.org/30146/msm_redux
06:53:55 <mm_freak> zygoloid: i'm thinking in state monads, in other words, i don't really get it
06:55:07 <mm_freak> oh wait
06:55:14 <mm_freak> i think it made click now
06:55:15 <zygoloid> mm_freak: ok. well, what can a function of type r -> (a -> r -> r) -> r actually do?
06:57:09 <Saizan> edon: "cabal list" will only tell you "installed" for libraries, because executables are not really tracked
06:57:53 <mm_freak> zygoloid: i see the fold pattern and it makes sense to me, but when i try to implement the Functor instance it stops making sense
06:57:59 <mm_freak> it looks to me like a state monad
06:58:07 <Saizan> edon: cabal should find happy when it needs it if it's on the $PATH, but you can also point cabal to it with --with-happy=
06:58:25 <mm_freak> although you can, of course, view a fold as a stateful computation
06:59:13 <zygoloid> mm_freak: well. the function can only produce an 'r' in one of exactly three ways.
06:59:47 <zygoloid> mm_freak: these are: 1) produce _|_. 2) return the first argument. 3) return the second argument applied to a value of type r.
07:00:04 <zygoloid> in case 3 it also needs to know a single (fixed) value of type 'a'.
07:00:46 <edon> Saizan: yep, it doesn't recognize it. It says it wasn't able to find the program 'happy' at ... or on the path, though it obviously is there
07:01:00 <mm_freak> zygoloid: http://hpaste.org/30147/supposed_to_be_a_cps_list_mona
07:01:11 <mm_freak> it compiles but i doubt that it makes any sense
07:01:14 <zygoloid> a value of this function type (call it T a) is therefore equivalent to either: 1) _|_, 2) a constant, call it K, or 3) a pair of (a, T a)
07:01:28 <Saizan> edon: can you paste echo $PATH ?
07:01:38 <zygoloid> a value of type [a] is either 1) _|_, 2) a constant, called [], or 3) a pair of (a, [a]).
07:02:27 <zygoloid> (this is actually a lie -- the (T a) type has a few more values in it due to the existence of seq -- but let's ignore that)
07:02:38 <edon> Saizan: yes: http://hpaste.org/30148/path
07:02:43 <mm_freak> maybe i should try to implement 'empty' and 'cons' for this type, first
07:02:52 <mm_freak> after all i know how to write church lists
07:03:44 <mm_freak> cempty = Choice $ \e0 k -> e0
07:04:28 <Saizan> edon: so "cabal install ... --with-happy=/home/edon/.cabal/bin/happy" works but not without that flag?
07:05:39 <zygoloid> mm_freak: this might help (or might confuse you): http://hpaste.org/paste/30147/renaming#p30149
07:06:02 <zygoloid> that's basically foldr/map fusion.
07:06:41 <mm_freak> zygoloid: yes, it starts to make sense now
07:06:53 <zygoloid> (it's also not valid haskell since you can't have a variable called (:) but that's not the point)
07:07:55 <mm_freak> yes, i see your point
07:08:41 <mm_freak> zygoloid: but then my fmap is in fact correct, isn't it?
07:10:51 <zygoloid> mm_freak: yes, it looks right to me.
07:10:57 <applicative> Razz_  I'm defeated trying to think if there's something special about your MSM.  Here's the beginnings of a transformer version http://hpaste.org/30150/mtld_msm
07:11:18 <mm_freak> zygoloid: renaming my variables helps =)
07:11:58 <mm_freak> zygoloid: my main problem is that i implemented a CPS-based StateT, and that function looks too much like it
07:12:03 <applicative> Razz_ you see we get a couple of functions you commented out 'for free';  I think most of the rest are also in the source for Control.Monad.State.Lazy.  
07:12:34 <mm_freak> also i'll flip 'Choice', so that it looks more like the regular foldr
07:14:03 <applicative> Razz_ I'm just signing on to Saizan's and min's advice.  The mtl definitions just make more generally what you are making, so they can be a guide.
07:15:11 <zygoloid> mm_freak: how dod your CPS StateT work out?
07:15:13 <applicative> Razz_, I imported Control.Monad.State qualified a S in case your State conflicted with theirs.
07:15:42 <mm_freak> zygoloid: it works very well and is already on hackage
07:16:04 <mm_freak> zygoloid: http://hackage.haskell.org/package/contstuff
07:16:08 <zygoloid> mm_freak: there's a connection between monads and lists which might be what you're seeing.
07:16:50 <mm_freak> zygoloid: i'm concerned about the efficiency of this approach
07:16:59 <applicative> Is Razz = Razz_ ?
07:17:25 <mm_freak> but i guess the efficiency depends solely on what folding function you pass to runChoiceT
07:19:02 <mm_freak> ok, implementing <*> for ChoiceT is going to be a challenge
07:20:39 <zygoloid> mm_freak: you could cheat by converting to lists, doing <*> there and converting back :)
07:21:00 <zygoloid> if you can then convert the code into foldr form, you can remove the intermediate lists.
07:21:06 <mm_freak> zygoloid: that would destroy the point of all this =)
07:21:42 <hirsch> Beginner's question: I want to lift a function into a monad to chain my monadic expression like that: stat <- mapM Files.getFileStatus =<< map (liftM (combine dir)) =<< Dir.getDirectoryContents dir
07:21:42 <edon> Saizan: yeah that worked ok with specifying the the absolute location. Is there a option like --with-happy for cabal for the package trhsx? Now at some other package I'm getting the error ghc: could not execute: trhsx, even though that file is in the path and at .cabal/bin/ and it's executable
07:21:45 <mm_freak> i see, but i'm going to try without cheating for now
07:21:59 <hirsch> but it doesn't work
07:22:22 <mm_freak> hirsch: try mapM instead
07:22:26 <mm_freak> :t mapM
07:22:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:22:50 <copumpkin> mm_freak: I'd assume he knows about it, since he's using it in his expression :P
07:23:05 <mm_freak> copumpkin: but he's using 'map', too
07:23:12 <mm_freak> anyway
07:23:15 <hirsch> mm_freak: also doesn't work
07:23:29 <hirsch>     Couldn't match expected type `IO FilePath'            against inferred type `[Char]'
07:23:39 <mm_freak> map (combine dir) <$> getDirectoryContents dir
07:25:19 <hirsch> mm_freak: yes, it works, thanks I think I have to read some docs on <$>
07:25:21 <Saizan> edon: did you change the path just now? maybe you lack an "export", anyhow there's a --with-foo for any executable foo
07:26:48 <edon> Saizan: nope, i have it on my .zshrc
07:27:18 <byorgey> "cabal: failed"
07:27:22 <byorgey> anyone ever see that on Windows?
07:27:32 <byorgey> not a very descriptive error message, is it?
07:28:42 <luite> hmm, never seen it
07:29:16 <luite> even though I'm stupid enough to keep using windows :p
07:30:22 <mm_freak> hirsch: (<$>) = fmap
07:30:31 <mm_freak> > fmap (+1) [1,2,3]
07:30:31 <lambdabot>   [2,3,4]
07:30:36 <mm_freak> > (+1) <$> [1,2,3]
07:30:36 <lambdabot>   [2,3,4]
07:31:39 <mm_freak> zygoloid: i think i got Applicative right without cheating, but Alternative is the next real challenge…  after i've got that one right, i can test whether my <*> works
07:31:56 <mm_freak> 'empty' is very easy in fact
07:32:05 <mm_freak> but <|> is difficult
07:32:45 <osaunders> Am I right in saying error is a special function that doesn't return?
07:33:08 <mm_freak> osaunders: yes
07:33:09 <osaunders> And does that mean it is non-deterministic?
07:33:16 <mm_freak> semantically:  error str = undefined
07:33:42 <osaunders> There's no notion of catching errors in Haskell is there?
07:34:02 <luite> there's exception handling with catch, but you can only do that in IO
07:34:04 <nlogax> @hoogle catch
07:34:04 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
07:34:04 <mm_freak> not in the type system, but the usual exception handling functions are there
07:34:04 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
07:34:04 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
07:34:36 <osaunders> Right OK.
07:34:38 <osaunders> Thank you :-)
07:34:45 <mm_freak> osaunders: but if you want to write pure functions with errors you should probably encode that in the type
07:34:58 <mm_freak> mySqrt :: Double -> Maybe Double
07:35:00 <bastl> is it possible to deserialize "type representations" as in this example? what should the type of "typerep :: String -> ??" be ? http://hpaste.org/30151/typereps
07:35:09 <osaunders> mm_freak: Ahh yes.
07:35:25 <mm_freak> osaunders: Maybe is a monad, which is quite handy here
07:38:03 <mm_freak> zygoloid: great, <|> and <*> are working well =)
07:38:53 <mm_freak> now the Monad instance
07:39:01 <mm_freak> that one should be easy
07:42:29 <magthe> I'm failing to find an instance of Arbitrary for Data.Map.Map... surely there must be such a thing somewhere?
07:43:14 <tab> magthe: can't you use fromList and use the Arbitrary for [a] ?
07:45:15 <magthe> tab: yeah, I've been doing that, but that means I need to think about things like (fromList [("", ""),("","")]) not being a map with two items in it :)
07:45:40 <sshc> What is the KeySym name for ^?
07:45:50 <mm_freak> does anyone know a simple example to test, whether a list transformer is really a monad transformer?
07:45:59 <geheimdienst> sshc, xK_circumflex iirc
07:46:10 <Botje> sshc: you can check with xev if you want
07:46:22 <geheimdienst> no, make that xK_asciicircum
07:46:31 <geheimdienst> (weird really)
07:46:46 <copumpkin> meh, I want an iteratee library without any of that ugly monadic stuff
07:47:10 <copumpkin> I'm not using them for IO or anything outside-worldy
07:47:46 <Peaker> copumpkin, For pure stuff, why not just use infinite lists?
07:47:53 <Peaker> potentially infinite
07:47:56 <sshc> xev reports "asciicircum"; thanks.
07:48:06 <tab> magthe: hm yeah it does involve a bit more setup than expected this way
07:48:24 <Peaker> copumpkin, http://conal.net/blog/posts/enhancing-a-zip/ or maybe this?
07:48:34 <copumpkin> Peaker: not really the same, for my use. I have an instruction decoder for a variable-length encoding that can either return a constructed instruction, or ask for more
07:49:01 <copumpkin> I don't really want to hand it the entire stream, because I don't really have a stream
07:50:34 <Peaker> copumpkin, How do you feed it then?
07:50:59 * geheimdienst agrees that handling a non-existant stream in its entirety would present some practical difficulties
07:51:05 <mm_freak> zygoloid: i think this ChoiceT has a problem: the folding function always traverses the entire list, right?
07:51:07 <copumpkin> well, I have a broader decoder that handles control-flow
07:51:12 <copumpkin> and reading from a memory structure
07:51:24 <mm_freak> so i can't pick just the first answer
07:55:02 <Peaker> copumpkin, so your reads from a memory structure cannot form a stream?
07:55:32 <mm_freak> but i think, i know a solution
07:56:06 <copumpkin> Peaker: they could, up until a branch instruction, but I still don't like the idea, conceptually
07:57:02 <Peaker> copumpkin, a pure producer is supposed to be similar to a list, and a consumer is just a folder on a list, I'd expect
07:57:36 <magthe> tab: sorted it out by a few (toList . fromList)... and quickcheck is still fast enough so I'll leave it this way
07:59:17 <McManiaC> wtf
07:59:50 <byorgey> can someone get haskell.org back to looking pretty again?  pretty please?  =)
08:00:08 <McManiaC> pretty?
08:00:11 <McManiaC> was it ever pretty?
08:00:12 <McManiaC> :D
08:00:16 * geheimdienst hands byorgey a lipstick
08:00:53 <Igloo> Should switch to the new server in about a month, all going well
08:02:49 <geheimdienst> igloo, sounds nice. kudos.
08:04:58 <Leosirth> hi all
08:05:26 <copumpkin> Peaker: I still prefer this architecture a bit for various reasons :)
08:14:03 <byorgey> ah, good =)
08:14:05 <byorgey> Igloo++
08:14:45 <Leosirth> i'm pretty new to haskell programming and i would like to ask how to use the sortby function to sort a list of char with the order of a secondary list. ex: the secondary have a order like [s, d, b, c] and i want to sort another list with the same order
08:16:03 <copumpkin> :t map snd . sortBy (comparing fst) . zip ['s', 'd', 'b', 'c']
08:16:03 <lambdabot> forall b. [b] -> [b]
08:17:06 <byorgey> > map snd . sortBy (comparing fst) . zip "sdbc" $ [1,2,3,4]
08:17:06 <lambdabot>   [3,4,2,1]
08:17:21 <byorgey> Leosirth: do you see how that works?
08:17:33 <geheimdienst> http://www.haskell.org/haskellwiki/X_window_programming_in_Haskell has a nice listing of a small X program. the problem is that the wiki nommed the indentation. does anyone have a version with indentation ...?
08:17:51 <geheimdienst> or can coax it out of the wiki? i can't click "edit" cause i have no account
08:18:07 <Leosirth> thanks for the help......i don't know the zip function.....looking for it in the wiki
08:18:38 <djahandarie> :t zip
08:18:39 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
08:18:57 <djahandarie> > zip [1,2,3] "dcba"
08:18:58 <lambdabot>   [(1,'d'),(2,'c'),(3,'b')]
08:19:09 <Leosirth> oh ok, thanks
08:21:51 <Leosirth> so you combine the elements of the two list to sort
08:23:11 <Leosirth> but having a list [s, d, b, c] and another [c, d, s] i want an output of [s, d, c]
08:23:38 <copumpkin> oh
08:24:16 <djahandarie> Huh
08:24:24 <copumpkin> you might need a Map for that
08:24:27 <copumpkin> to do it efficiently
08:24:29 <djahandarie> Apparently copumpkin got it
08:24:43 <copumpkin> or a Set, if you look at it the other way around
08:24:43 <Peaker> Why not Set?
08:25:04 <Leosirth> hmmmm
08:25:30 <djahandarie> You just want to get the intersect two lists and preserve the order of the first?
08:25:42 * djahandarie doesn't understand the problem definition fully
08:26:06 <Leosirth> yes
08:27:14 <djahandarie> > intersect "sdbc" "cds"
08:27:15 <lambdabot>   "sdc"
08:27:21 <bastl> I have type representations modelled as constants of a GADT. Now I want to serialize (show) them, write them to disk, and then, in a later session, deserialize them back to the GADT-constant. Is that possible? Here is an example:  http://hpaste.org/30151/typereps
08:27:34 <djahandarie> That is in Data.List
08:28:09 <Leosirth> oh
08:28:13 <Leosirth> it was easy
08:29:06 <djahandarie> > [ x | x <- "sdbc", any (== x) "cds" ]
08:29:06 <lambdabot>   "sdc"
08:29:28 <benmachine> :t any (== x)
08:29:29 <lambdabot> [Expr] -> Bool
08:29:33 <benmachine> er
08:29:36 <benmachine> :t \x -> any (== x)
08:29:37 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:29:40 * hackagebot ta 0.1 - Transito Abierto: convenience library when using Takusen and Oracle.  http://hackage.haskell.org/package/ta-0.1 (LeonelFonseca)
08:29:41 <benmachine> :t \x -> elem x
08:29:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:29:54 <copumpkin> \x -> f x === f 
08:30:43 <geheimdienst> :t (===)
08:30:44 <lambdabot> Not in scope: `==='
08:30:47 <copumpkin> I wonder if there's a rewrite rule for (not .) . elem ==> notElem
08:31:43 <geheimdienst> in vim, use :%s/\(not \.\) \. e/notE/g
08:31:50 <geheimdienst> you're welcome
08:31:54 <geheimdienst> ;-)
08:31:55 <djahandarie> That is how intersect is done internally, which means it is O(n*m), which is not that efficient as a size balanced binary tree (like Data.Set) can do it in O(n+m)
08:32:07 <ManateeIrcClient> Hi all! :)
08:32:26 <ManateeIrcClient> Wow, my irc client so beautiful now! :)
08:33:01 <Leosirth> oh ok thanks i get it
08:34:34 <ManateeLazyCat> Look my irc client : http://www.flickr.com/photos/48809572@N02/4998955536/lightbox/ beautiful ah? :)
08:35:04 <copumpkin> nice :)
08:35:05 <geheimdienst> ManateeLazyCat: impressive :-)
08:35:14 <djahandarie> Don't those numbered lines get out of hand after awhile? :P
08:35:20 <copumpkin> you should have a watermark manatee
08:35:32 <ManateeLazyCat> geheimdienst: Next, add nick color over message.
08:35:52 <geheimdienst> yeah, you talked about it this morning
08:36:08 <ManateeLazyCat> geheimdienst: Nick color easy now.
08:36:19 <ManateeLazyCat> geheimdienst: Since i have finish ready work.
08:37:16 <ManateeLazyCat> Eat some food, back soon. :)
08:39:23 <ManateeLazyCat> It's will become more beautiful after add nick color. :)
08:39:31 <ManateeLazyCat> brb, so hungry....
08:42:20 <benmachine> is it possible to install a newer version of the Cabal lib in a user directory?
08:42:56 <benmachine> it doesn't seem to want to
08:43:29 <copumpkin> maybe I'll just use Free ((->) i) instead of writing my own iteratee, but then I have to depend on category-extras :(
08:43:34 <Saizan> benmachine: in a user directory?
08:43:41 <benmachine> Saizan: as in, --user
08:43:56 <benmachine> in ~/.ghc or ~/.cabal or whatever
08:44:15 <Saizan> i do that quite often
08:44:31 <Saizan> what error do you get?
08:44:42 <benmachine> Setup.hs: Unable to rename "/usr/lib/ghc-6.8.2/package.conf" to
08:44:42 <benmachine> "/usr/lib/ghc-6.8.2/package.conf.old"
08:44:49 <benmachine> that sort of thing
08:44:54 <benmachine> it seems to be trying to register it globally
08:44:57 <benmachine> obviously it can't do that
08:45:27 <Saizan> what command are you using?
08:45:43 <Saizan> if you go with runghc Setup you've to pass --user to configure
08:46:01 <benmachine> pretty sure I did
08:46:06 * djahandarie read command as a misspelling of comonad
08:46:20 <benmachine> runhaskell Setup.hs configure --user, runhaskell Setup.hs build, runhaskell Setup.hs install --user
08:46:24 <benmachine> first two worked fine
08:46:47 <Saizan> --user to install is not necessary anyway
08:46:48 <benmachine> oh wait
08:46:49 <benmachine> no
08:47:02 <benmachine> runhaskell Setup.hs build tries to register the package
08:47:03 <benmachine> and fails
08:47:05 <copumpkin> maybe I'll use http://hackage.haskell.org/package/control-monad-free
08:47:38 <copumpkin> ah, the lengths I'd go to to avoid iteratees
08:48:30 <Saizan> mh, maybe 6.8.2's ghc-pkg doesn't support registering in place and ends up registering globally instead..
08:50:14 <benmachine> yeah, runhaskell Setup.hs register --inplace failed
08:51:20 <djahandarie> Free monads have a usage?
08:52:04 <copumpkin> hell yeah
08:52:11 <copumpkin> iteratees are basically free monads
08:52:22 <Saizan> really?
08:52:27 <copumpkin> I dunno, they seem to be :P
08:52:57 <copumpkin> Free ((->) i) seems to match the simplest iteratee structure I could find
08:53:08 <Saizan> yeah
08:53:20 <copumpkin> once you start adding error handling and such, it gets uglier
08:53:34 <copumpkin> but you could handle that in the functor
08:53:57 <Saizan> the problem is chunked input, since then Done has to also return the unconsumed part
08:54:12 <wjt> gtk2hs people: if i were to write a binding for gtk_major_version etc. variables, would you like them to live in Graphics.UI.Gtk.General.General, or somewhere else?
08:54:18 <copumpkin> yeah, I'm not even using that part of it :P
08:54:29 <copumpkin> it seems like an implementation detail
08:54:40 <copumpkin> so I guess it's more accurate for me to say I'm using Free ((->) i) than an iteratee, though
08:55:07 <zygoloid> Free (forall b. (a, b)) is [a], iirc
08:55:45 <copumpkin> Free ((,) a) ?
08:56:11 <copumpkin> it's not quite [a], it seems
08:56:25 <copumpkin> more like one of those lists that can have a custom type at the end
08:56:48 <benmachine> huh, that's odd
08:56:53 <benmachine> $ runhaskell Setup.hs register --user -v3
08:56:59 <benmachine> calls ("/usr/bin/ghc-pkg",["update","-","--global","--user"])
08:57:12 <benmachine> where did the --global sneak in >_>
08:57:27 <copumpkin> Free ((,) a) () ~~ [a]?
08:57:33 <Saizan> yeah, it has to tell it all the package dbs where the deps are to be found
08:57:40 <copumpkin> with extra bottoms
08:57:44 <Saizan> and it'll register the package only in the last
08:57:49 <geheimdienst> i'm passing a config record to a library function: f $ defaultconf { x = \_ _ _ u _ -> do ... return () }. now i'd like to call (1) the IO lambda as mentioned and (2) the original default thing of x. i tried (original &&& (\_ _ _ u _ -> ...)). this works somewhat but gives a (IO x, IO x)
08:57:57 <benmachine> oh
08:58:05 <geheimdienst> so i'm looking for kind of a cross between &&& and >>. is there anything like that?
08:58:09 <Saizan> i guess 6.8 worked differently
08:58:14 <copumpkin> :t uncurry (liftA2 (,))
08:58:15 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
08:58:27 <benmachine> how irritating
08:58:39 <copumpkin> geheimdienst: you probably want liftA2 (,) somewhere in there, although I have no idea what that stuff is
08:58:43 <Saizan> no idea if it's a bug or support got dropped.. 
08:59:10 * benmachine tries Cabal 1.6 instead
08:59:13 <geheimdienst> hm ... i'd have to call that lift thing after &&&
08:59:24 <copumpkin> so if not an iteratee, what should I call this simple helper type I'm using
08:59:43 <benmachine> CopumpkinsSimpleHelperType
08:59:49 <copumpkin> good idea
08:59:54 <djahandarie> CategoryTheoreticalMumboJumboType
09:00:04 <benmachine> fsvo good, yeah
09:00:12 <geheimdienst> copumpkin: it's hooks in a Setup.lhs. they're something like A -> B -> C -> D -> IO X
09:00:16 <djahandarie> HocusPocus!
09:00:22 <benmachine> ah, Cabal 1.6 installs
09:00:35 <benmachine> I guess 1.8 dropped support for 6.8's way of doing things
09:00:54 <geheimdienst> to add to a hook, i'd just use (original >> mystuff), but that does not take care of passing the 4-5 arguments to both guys
09:00:59 <geheimdienst> that's the issue
09:01:59 <geheimdienst> @hoogle liftA2
09:01:59 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:10:51 <geheimdienst> for the record, it turns out i was looking for liftA2 (&&&)
09:11:06 <geheimdienst> or more precisely, (fmap fst) . (liftA2 (&&&) ...)
09:11:09 <Entroacceptor> liftA2? Terrible name
09:11:11 <geheimdienst> thanks copumpkin :)
09:12:08 <Saizan> names have feelings too.
09:12:24 <geheimdienst> liftA2 is an A22hole
09:12:42 <copumpkin> :t liftA2 (&&&)
09:12:43 <lambdabot> forall (a :: * -> * -> *) b c c' (f :: * -> *). (Arrow a, Applicative f) => f (a b c) -> f (a b c') -> f (a b (c, c'))
09:12:50 <copumpkin> mmm
09:13:19 <geheimdienst> copumpkin: , buildHook = (fmap fst) . (liftA2 (&&&) (buildHook simpleUserHooks) $ \pkgdesc _ _ _ -> do ...
09:13:27 <copumpkin> :)
09:13:47 <geheimdienst> (from a Setup.lhs. buildHook is stuff that cabal defines)
09:20:07 <Peaker> geheimdienst, no need for () around func calls in an infix operation
09:21:04 <djahandarie> I often want things like first and second but rarely want the full power of arrows
09:22:09 <Peaker> The full genericity, I think you mean?
09:22:34 <Peaker> The function arrow is nice, arrows in general suck :)
09:23:11 <Peaker> Applicative + Category gives you Arrow, iirc, and those already exist and are more general
09:23:27 <Peaker> Or just as general, but more compositional
09:26:06 <quadro`> w00t, wrote my first line of haskell today ^^
09:26:30 <djahandarie> > "Yeay!"
09:26:31 <lambdabot>   "Yeay!"
09:27:41 <Peaker> quadro`, http://tryhaskell.org/
09:27:47 <Peaker> Can write many lines easily :)
09:27:58 <quadro`> ah cool
09:28:13 <Nibble> Peaker: is that site inspired by tryclojure?
09:28:15 <quadro`> awesome, lessons! ty :)
09:28:42 <Blkt> good evening everyone
09:28:50 <djahandarie> Nibble, nope, but by Try Ruby!
09:29:01 <aristid> > (\(t:ts) -> toUpper t : ts) $ fix ("woohoo"++)
09:29:02 <lambdabot>   "Woohoowoohoowoohoowoohoowoohoowoohoowoohoowoohoowoohoowoohoowoohoowoohoowo...
09:29:07 * byorgey awards quadro` a golden lambda!
09:29:08 <djahandarie> Nibble, I think tryclojure may be based off of try ruby as well, but it could be the other way around
09:29:15 <Peaker> Nibble, Donno
09:29:23 <aristid> @pl \(t:ts) -> toUpper t : ts
09:29:23 <lambdabot> ap ((:) . toUpper . head) tail
09:29:27 <Nibble> ah
09:30:04 <aristid> can somebody improve on @pl? :D
09:31:05 <byorgey> you can always do   ((:) . toUpper . head) <*> tail
09:31:14 <benmachine> > fst $ foldr (\x (xs, ys) -> (toUpper x : ys, xs)) ([], []) "blahblah"
09:31:15 <lambdabot>   "BABA"
09:31:18 <benmachine> erm
09:31:41 <benmachine> > fst $ foldr (\x (xs, ys) -> (toUpper x : xs, x : ys)) ([], []) "blahblah"
09:31:42 <lambdabot>   "BLAHBLAH"
09:31:47 <benmachine> eeerm
09:32:05 <benmachine> > fst $ foldr (\x (_, ys) -> (toUpper x : ys, x : ys)) ([], []) "blahblah"
09:32:06 <lambdabot>   "Blahblah"
09:32:11 <benmachine> total version
09:32:46 <benmachine> > fst $ foldr (\x -> (toUpper x :) &&& (x :) . snd) ([], []) "blahblah"
09:32:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:32:48 <lambdabot>         against inferred ty...
09:32:56 <benmachine> > fst $ foldr (\x -> ((toUpper x :) &&& (x :)) . snd) ([], []) "blahblah"
09:32:57 <lambdabot>   "Blahblah"
09:33:26 <benmachine> @pl (\x -> ((toUpper x :) &&& (x :)) . snd
09:33:26 <lambdabot> (line 1, column 39):
09:33:26 <lambdabot> unexpected end of input
09:33:26 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator or ")"
09:33:31 <benmachine> @pl (\x -> ((toUpper x :) &&& (x :)) . snd)
09:33:32 <lambdabot> (. snd) . ap ((&&&) . (:) . toUpper) (:)
09:33:35 <benmachine> ok I lose
09:37:07 <ManateeLazyCat> wjt: Why you need binding gtk_version?
09:38:16 <ManateeLazyCat> Maybe "convert smile" not is good feature in #haskell, i see smile everywhere... :)
09:38:34 <garret> is this a good place for beginner questions? Or is there another channel for that?
09:38:35 <copumpkin> is the automatic Enum derivation in order of constructor definition defined in the report?
09:38:56 <benmachine> copumpkin: I believe so
09:39:28 <andrewsw> garret: despite the often high level of conversation here, yes.
09:39:32 <benmachine> copumpkin: http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18400011.2
09:39:50 <copumpkin> benmachine: thanks :)
09:39:52 <garret> Ok cool... I'm just getting started with 'real world haskell' and going through the excercises...
09:41:05 <garret> The one I'm working on is basically to write concat
09:41:15 <illissius-> hmm
09:41:18 <garret> but also put in a delimeter to intersperse between the reutnred list
09:41:37 <garret> I have an answer for it and it works for lists of strings (which is what all their test cases are)
09:41:47 <illissius-> what's the 'canonical' way to translate "class Foo a b | a -> b, b -> a" to associated types + equality constraints?
09:41:54 <garret> but i'm confused why it doesnt work for lists of lists where the sub-lists have integer entries
09:42:22 <andrewsw> garret: what are you using for delimiters?
09:42:29 <garret> ','
09:42:32 <garret> so a char comma
09:42:40 <garret> i can paste in the program, its short
09:42:41 <andrewsw> can't have mixed type lists.
09:42:47 <garret> intersperse a xs             | xs == []          = []             | length xs == 1    = head xs             | otherwise         = head xs ++ a : intersperse a (tail xs)
09:42:56 <garret> er, well the spacing is off..  heh
09:43:35 <andrewsw> look at the types of intersperse, your list of strings and your list of integer lists in ghci and see if becomes clear
09:44:23 <garret> *Main> :type intersperse intersperse :: (Eq a) => a -> [[a]] -> [a]
09:44:40 <garret> Not familiar with (Eq a)
09:45:01 <benmachine> it means that whatever type a is, it must support an equality operation
09:45:09 <andrewsw> garret: it means "for any type, we'll call it 'a', that type must support equality"
09:45:28 <djahandarie> > (:) <$> toUpper <$> head <*> tail $ "Hi"
09:45:29 <lambdabot>   "Hi"
09:45:34 <djahandarie> > (:) <$> toUpper <$> head <*> tail $ "hi"
09:45:35 <lambdabot>   "Hi"
09:45:57 <andrewsw> garret: in that type signature, note that everything is an 'a'. That means that the delimiter must be the same type as the elements of the sublists.
09:46:31 <benmachine> > liftA2 ((:) . toUpper) head tail "hi"
09:46:32 <lambdabot>   "Hi"
09:46:34 <garret> oooooh
09:46:38 <garret> interesting ok
09:46:51 <garret> yes yes, they're both 'a'
09:47:02 <garret> and obviously we cant return a list with mixed types as members
09:47:04 <garret> ok cool!
09:47:11 <garret> lemme try with an integer delmiter for my test cases
09:47:54 <garret> Nice! ok the world makes sense again, thank you so mucha ndrew!
09:48:01 <andrewsw> :)
09:51:13 <ManateeIrcClient> Good night all! :)
09:51:18 <Entroacceptor> :)
09:51:21 <Entroacceptor> nice ManateeIrcClient 
09:52:01 <ManateeIrcClient> Entroacceptor: I can do better, but now my bed miss me so much. :)
09:52:47 <ManateeIrcClient> Hope i can perfect my irc client tomorrow. :)
10:05:45 * copumpkin loves monads
10:06:02 <copumpkin> this is by far my favorite application of them
10:07:03 <djahandarie> What're you doing btw?
10:07:45 <copumpkin> this pseudoiteratee thing I'm working with, which happens to be a reader too
10:08:02 <aristid> pseudoiteratee oO Oo oO
10:08:20 <djahandarie> What are you using it for that you couldn't just use iteratees?
10:09:01 <copumpkin> I probably could use iteratees, but they seemed horribly overcomplicated for my simple purpose, and all the typically cited examples of why people use them didn't really match my motivation
10:09:41 <Peaker> copumpkin, And I don't understand why you couldn't make your producer a list :)
10:09:55 <conal> copumpkin: iteratees also lack any clear semantic model, afaict.  
10:10:10 <conal> or clear abstraction boundaries.
10:10:26 <copumpkin> yeah, I'm really just using the free monad aspect of it
10:10:42 <copumpkin> and it luckily happened to mesh nicely with the reader I was already using
10:11:25 <copumpkin> Peaker: it just isn't as clean, semantically
10:16:01 <Tarrasch> Hi, I'm experimenting with operator infix stuff. Do anybody know the solution to this? http://hpaste.org/30156/the__operator
10:16:55 <Tarrasch> Also, can someone suggest a more proper term than 'operator infix stuff'? :)
10:17:39 <dmos> Hi. if GHC bails out with "Ambiguous module name `Control.Monad.State': [snip]in multiple packages: mtl-1.1.0.2 monads-fd-0.1.0.1" what can I do? I tried package imports for the two libraries, but then I get plenty of not in scope errors...
10:18:33 <benmachine> dmos: compiling your stuff with Cabal solves this problem, but if you want to compile with GHC, you can use -hide-package mtl
10:18:36 <benmachine> or whatever
10:18:54 <benmachine> not in scope errors suggest to me you're selecting the wrong package
10:19:21 <benmachine> Tarrasch: I don't see an obvious way you can do what you want, there might be a sneaky way but personally I think parentheses are better for readability anyways
10:19:46 <dmos> benmachine: problem is that I'm compiling from within XMonad, which has it's own recompile command (invokes ghc).
10:20:01 <benmachine> dmos: ah, hmm
10:20:12 <benmachine> you're using stuff in your xmonad.hs
10:20:33 <chrisdone> bump
10:20:33 <lambdabot> chrisdone: You have 4 new messages. '/msg lambdabot @messages' to read them.
10:20:39 <chrisdone> lol
10:20:45 <dmos> no, I'm actually using the functionality that everything in .xmonad/lib gets compiled as well.
10:20:46 <benmachine> well, I would ask #xmonad if you can tell it to use a different compile command
10:20:58 <Tarrasch> benmachine, Yea, parenthesis definitely is better, but I'm mostly trying to be able to say: "Yes, Haskell can do that!" :)
10:21:04 <Tarrasch> benmachine, Thanks anyway! :)
10:21:14 <benmachine> Tarrasch: oh, well like I said there might be a sneaky solution, but I don't see it
10:21:15 <Peaker> dmos, you could try ghc-pkg hide monads-fd or mtl
10:21:20 <benmachine> oh, that's true
10:22:21 <Peaker> Tarrasch, does "infixr" and infixl not work with data constructors?
10:22:46 <dmos> which package would be the correct one? Is enabling PackageImports powerful enough to convince GHC to ignore the other one? Then I don't get the not in scope for the package but a whole host of these:  Not in scope: `initialValue'  Not in scope: `initialValue', Not in scope: type constructor or class `ExtensionClass', etc.
10:22:58 <Tarrasch> Peaker, they work fine, but I don't know how to continue, even being able to use that.
10:23:22 <Peaker> Tarrasch, what do you mean? If you set the :+ to high precedence and ? to low, doesn't that save the () ?
10:23:22 <wjt> ManateeIrcClient: oh, you don't need to call gtk_about_dialog_set_email_hook if you've got gtk >= 2.18
10:23:30 <wjt> ManateeIrcClient: but I just decided to assume that everyone does ;-)
10:24:18 <Tarrasch> Peaker, nope, I don't think so after trying, any particular l or r?
10:25:13 <Tarrasch> Peaker, one second ..
10:27:14 <Tarrasch> This deosn't compile, http://hpaste.org/30157/the__operator
10:27:45 <magicman> Tarrasch: infixr for ?. And you named the thing :+, so please use :+ in your "go". : is for lists and such.
10:28:02 <Tarrasch> me <-- retard :p
10:28:42 <Peaker> Tarrasch, I added another option for implementing it
10:29:19 <Tarrasch> magicman, still doesn't work :-/, http://hpaste.org/30159/the__operator
10:29:35 <chrisdone> Tarrasch: please annotate your pastes instead of making new ones
10:29:40 <Tarrasch> oh
10:29:52 <Tarrasch> sorry, I realized something was wron...
10:30:58 <magicman> Tarrasch: You see that "t :+ t   :+   t" part in there? That gets parsed as (t :+ t) :+ t.
10:31:09 <Peaker> Tarrasch, well, indeed, if :+ has higher precedence then:  x ? y ? a :+ b :+ c         will parenthesize the :+ first
10:31:30 <magicman> Changing infixl to infixr won't really work, then you'd get t :+ (t :+ t). Grmbl.
10:32:17 <Peaker> Tarrasch, seems to need the parser to be aware of relationship between ? and :+ to parse nested application properly
10:32:34 <Tarrasch> Sorry for creating this mess by not annotating :-/
10:32:35 <Peaker> Tarrasch, I think Agda syntax can handle it :)
10:32:48 <Tarrasch> Peaker, oh, that seems interesting
10:33:28 <roconnor> http://youinfinitesnake.blogspot.com/2010/09/programming-language-wars-movie.html -- I'm not sure how Java code manages to get shorter the more cores that are added.
10:34:29 <gwern> roconnor: perhaps it was simply a better version all around
10:34:49 <gwern> I'd hope we could rewrite the oldest haskell prog on the shootout to be shorter even if we were adding parallelism
10:35:40 <magicman> Yeah, Agda can definitely do it. They have that awesome mix-fix stuff.
10:35:57 <magicman> Though : is probably a reserved symbol.
10:36:04 <Baughn> Wait, why does haskell get /slower/ with more cores?
10:36:05 <Peaker> I dislike Agda's name resolution depending on types, though
10:36:15 <gwern> Baughn: last core slowdown?
10:36:16 <benmachine> Tarrasch: I had a vague idea where both would be left-associative, ? would push on to a stack, and a function called maybe -: would pop off it
10:36:53 <Baughn> gwern: It's measured from one to four cores, presumably on a single machine
10:36:56 <roconnor> I like how Lisp SBCL code gets bigger on more cores but not any faster
10:37:19 <gwern> Baughn: well then maybe the haskeller who wrote it wasn't very good
10:37:22 <sepp2k> @pl \x -> (x, f(x))
10:37:23 <lambdabot> ap (,) f
10:37:33 <Baughn> gwern: P'raps
10:37:58 <chrisdone> lispy: openid sounds fun
10:38:29 <roconnor> and even funnier is that JRuby gets slower with more cores
10:38:39 <lispy> chrisdone: I work with one of the OpenID co-creators and another guy that helped too and wrote lots of language specific libraries for it.
10:38:44 <roconnor> at least the memory is reduced
10:38:56 <c_wraith> lispy: you're referring to the guys who worked with me at the time? :)
10:38:59 <lispy> chrisdone: so I'm biased and I could probably prod the right people if you need a haskell library
10:39:05 <Baughn> roconnor: Yeah, but so does haskell, so..
10:39:10 <lispy> c_wraith: you worked at JanRain?
10:39:14 <c_wraith> lispy: still do
10:39:22 <roconnor> Baughn: ah good point
10:39:24 <ddarius> I like how the diagrams have the opposite of faster being "more expressive" as if those were even on the same axis.
10:39:26 <lispy> c_wraith: I had no idea.  Small world!
10:39:38 <lispy> c_wraith: but yeah, j3h and cygnus
10:39:52 <roconnor> this graph makes no sense to me
10:39:54 <chrisdone> lispy: there's already a haskell library. I'm reading the authentication 2.0 spec now
10:39:56 <c_wraith> lispy: I'm technically also on the openid 2 spec author list, though I didn't write any of it. :)
10:40:09 <lispy> cool!
10:40:24 <lispy> chrisdone: maybe you can team up with Michael Snoyman
10:40:36 <chrisdone> I might promote it at work because we have an in-house SSO system and there's not much point in it
10:40:39 <lispy> chrisdone: did you see his recent email on -Cafe about haskell community identity?
10:40:46 <Peaker> ddarius, There is some anti-correlation between them in most languages
10:40:51 <chrisdone> yeah, I thought openid would be right for that
10:41:09 <Peaker> ddarius, (I agree it's not inherent, but sampling the wrong data you can easily come to the conclusion that it probably is)
10:41:14 <lispy> Kerberose is good too.  I'm not sure how OpenID and Kerberose interact.
10:42:30 <lispy> c_wraith, chrisdone:  I'm working on the 3rd item listed here so I'm learning about identity stuff now: http://www.galois.com/blog/2010/08/10/galois-inc-wins-three-department-of-energy-small-business-research-awards/
10:42:42 <lispy> "Collaboration and Sharing on the Grid"
10:42:51 <lispy> I bet Haskell.org has similar hurdles an the grid folks
10:44:27 <lispy> chrisdone: are you on the haskell-infrastructure mailing list?
10:44:57 <lispy> chrisdone: http://community.galois.com/mailman/listinfo/haskell-infrastructure
10:45:03 <rschnck> Can someone give me a hint on how to write a function that would act as a cross product of two lists where one list of length 2? I.e. [Int] -> [Int] -> [(Int),(Int)]]
10:45:34 <rschnck> So you could have cross [2,3] [4,5,6] = [(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:45:46 <Peaker> rschnck, do you want just a hint, or nice solutions?
10:45:50 <rschnck> A hint.
10:45:54 <rschnck> I keep getting close
10:46:02 <rschnck> But using horribly complex and...verbose functions.
10:46:07 <roconnor> liftM2 (,)
10:46:10 <Peaker> rschnck, you can start with a manual recursive definition, later see what you can factor out to higher-order functions
10:46:12 <rschnck> So maybe something that would lead to something more elegant?
10:46:17 <Baughn> Invoking the list monad is cheating
10:46:20 <chrisdone> lispy: nope, I'll join 
10:46:23 <Peaker> rschnck, Later see what "Applicative" instance of List does
10:46:35 <Peaker> roconnor, :-(
10:47:01 <rschnck> Well with the manual recursive definition
10:47:18 <djahandarie> That stuff galois got money to do sounds pretty neat
10:47:23 <rschnck> I'm a bit stuck on *how* exactly tod efine it. I realize I need to take the head of the first list and make a tuple with every element of the second list
10:47:28 <rschnck> And then do the same for the next element in the first list
10:47:38 <rschnck> But I'm unsure how to implement that in a *nice* manner.
10:47:58 <Peaker> rschnck, maybe you can paste your solution, and then you can get hints about how to improve it
10:48:16 <rschnck> Peaker: I don't have a proper solution, and what I have currently...sort of works...but not really
10:48:21 <rschnck> It gets a few right :D
10:49:25 <rschnck> http://codepaste.net/kowpjg you guys are going to laugh =[
10:49:53 <Peaker> Well, if you generalize the type to [a] -> [b] -> [(a, b)]  -- it makes it easier than with specific types
10:50:02 <rschnck> Oh yeah, it only works for the head of the first list
10:50:12 <rschnck> Peaker: Why?
10:50:40 <da-x> haskell is a language for perfectionists.
10:50:55 <Peaker> rschnck, Because the type tells you more about what it should do
10:51:08 <Peaker> rschnck, you're using guards when pattern matching would be better
10:51:28 <Peaker> rschnck, first, translate your guards to pattern matches and re-paste :)
10:51:35 <rschnck> Okay :3
10:51:44 <rschnck> I'll have to cmoe back later, lecture just ended.
10:51:48 <rschnck> Thanks for your help; I'll work on it.
10:53:25 * da-x has walked the ByteString walk of fire
10:59:10 <djahandarie> You know, curried functions feel so much nicer than a function of a pair where the domain is the cartesian product of the domains of each element in the pair
11:00:07 <djahandarie> But in math I don't think I've ever seen curried functions being used rather than their uncurried equivalent
11:00:17 <roconnor> djahandarie: I wonder if thinks would be different if we didn't have lifted products
11:00:25 <roconnor> *things
11:01:25 <roconnor> i.e. do uncurried functions feel more natural in Miranda
11:03:02 <roconnor> Sometimes I feel bad for David Turner.
11:03:38 * djahandarie has never used Miranda
11:03:49 <roconnor> djahandarie: you got to pay $$$
11:04:01 <lispy> roconnor: This is the historic win of open source right?  And look at clean vs. haskell
11:04:12 <roconnor> clean wasn't open source?
11:04:15 <lispy> roconnor: Haskell has dominated clean at this point.
11:04:34 <lispy> Not in the same way as Haskell.  Haskell was open from the start with a BSD mentality
11:04:46 <lispy> Clean was meant for commercial use and research only
11:04:50 <roconnor> djahandarie: Haskell is pretty close to being a copy of Miranda
11:04:53 <lispy> Or something like that
11:05:16 <lispy> roconnor: we do have some important differences from Miranda though.  Like where bottoms can appear
11:05:30 <roconnor> for some definition of important
11:05:39 <djahandarie> roconnor, yeah, I know. Haskell has extra stuff like type classes and monadic io
11:05:56 <bremner> typeclasses seem pretty important as a difference
11:06:00 <roconnor> djahandarie: well haskell didn't get monads untill when?  Haskell 1.3?
11:06:12 * djahandarie wasn't around then
11:06:17 <roconnor> did miranda not have type classes?  I could believe that.
11:06:19 <lispy> roconnor: these days, I think clean seems the value of the Haskell approach and they are trying to mimic Haskell's success with thins like a clean platform
11:06:20 <djahandarie> Was I even alive? :P
11:06:38 <lispy> s/seems/sees
11:06:40 <djahandarie> I was 4 apparently
11:06:44 <roconnor> djahandarie: haskell 1.3 appears to be circa 1995
11:06:58 <roconnor> I was graduating high school then
11:07:04 <solidsnack> roconnor: Haskell was a copy of Miranda?
11:07:18 <roconnor> solidsnack: almost a copy of Miranda
11:07:36 <roconnor> here is an example of Miranda code:
11:07:42 <roconnor>   subsets []     = [[]]
11:07:43 <roconnor>   subsets (x:xs) = [[x] ++ y | y <- ys] ++ ys
11:07:45 <roconnor>                    where ys = subsets xs
11:08:01 <solidsnack> Yes, just looked at Miranda. I was thinking of Mercury.
11:08:10 <solidsnack> Very different :0
11:08:41 <roconnor> sieve (p:x) = p : sieve [n | n <- x; n mod p ~= 0]
11:08:50 <ClaudiusMaximus> hm, since upgrading gtk one of my (old) projects no longer compiles, any suggested workaround for:     Could not find module `Graphics.Rendering.Cairo.Internal.Surfaces.Image': it is a hidden module in the package `cairo-0.11.1'
11:08:50 <roconnor> note the use of ~= instead of /=
11:09:03 <roconnor> thus we know it is Miranda and not haskell :)
11:09:26 <bremner> or haskell with yet another weird operator
11:09:39 <roconnor> :)
11:10:29 <fryguybob> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf -- section 3.8
11:13:43 <aristid> what's the preferred way to group a list into blocks of, say, 8 elements each?
11:13:57 <Botje> Data.List.chunk
11:14:02 <Botje> err
11:14:04 <Botje> Data.List.Split.chunk
11:14:29 <lispy> ClaudiusMaximus: gtk was split up into sub packages
11:14:46 <lispy> ClaudiusMaximus: my hunch is that you now need to add cairo to your build dependencies and install cairo
11:14:54 <aristid> Botje: hah, that does help
11:15:40 <ClaudiusMaximus> lispy: i truncated the error to fit irc norms, but i do have cairo installed and unhidden (using ghc --make, not cabal) - the API must have changed to hide the internal modules?
11:15:51 <aristid> > let input = "101010101010"; byteSize = 2; toBits = (toBit =<<); toBit '0' = return 0; toBit '1' = return 1; toBit _ = []; bits = toBits input; bytes = chunk byteSize bits in map (foldl' (\a b -> shiftL a 1 .|. b) 0) bytes :: [Integer]
11:15:52 <lambdabot>   Not in scope: `chunk'
11:15:55 <aristid> :(
11:16:22 <roconnor> > Data.List.Split.chunk
11:16:22 <lambdabot>   Not in scope: `Data.List.Split.chunk'
11:16:31 <lispy> ClaudiusMaximus: I don't know.  I'd have to read the source to figure that out
11:17:39 <ClaudiusMaximus> lispy: same here, it's an old project that i don't feel like upgrading/maintaining, so i'll see if it still works on my lenny machine with old versions (where it used to work fine)
11:17:57 <ClaudiusMaximus> lispy: thanks
11:18:46 <cadabra> I have [IO ()]. I want to run all concurrently and wait for all to finish. I can see forkIO, but I see no join. Should I synchronize with an MVar or something like that?
11:19:36 <roconnor> @hoogle [IO a] -> IO [a]
11:19:37 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:19:37 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
11:19:37 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:19:42 <roconnor> @hoogle+
11:19:43 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
11:19:43 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
11:19:43 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
11:19:46 <roconnor> :/
11:20:04 <roconnor> @hoogle [IO ()] -> IO ()
11:20:04 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
11:20:05 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
11:20:05 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
11:20:29 <roconnor> @type sequnce_
11:20:30 <lambdabot> Not in scope: `sequnce_'
11:20:32 <roconnor> @type seqeunce_
11:20:33 <lambdabot> Not in scope: `seqeunce_'
11:20:36 <roconnor> @type sequence_
11:20:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
11:20:48 <roconnor> hoogle, sometimes I don't understand why you return what you return
11:20:58 <roconnor> oh
11:21:01 <roconnor> I see why now
11:21:05 <aristid> why?
11:21:18 <roconnor> sequence takes an [m a] not an [m ()]
11:21:18 * mightybyte <3 haskell
11:21:33 <roconnor> hmm
11:21:43 <roconnor> I guess that doesn't really expalin why it wasn't at the top of the list though
11:21:43 <aristid> :t forkIO
11:21:44 <lambdabot> Not in scope: `forkIO'
11:21:52 * fryguybob hugs haskell after writing a bunch of javascript.
11:21:58 <roconnor> cadabra: I think your question is a good one. I don't know the answer though
11:23:24 <cadabra> Strange. I guess I'll write it.
11:24:01 <roconnor> cadabra: I would guess that CHP would do something like this
11:25:12 <zygoloid> @hoogle IO a -> IO (MVar a)
11:25:13 <lambdabot> Control.Concurrent.MVar newMVar :: a -> IO (MVar a)
11:25:13 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
11:25:13 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
11:28:31 <lispy> ClaudiusMaximus: cheers.  I hope it works!
11:28:50 <aristid> @hoogle forkIO
11:28:50 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
11:29:55 <Peaker> [x] ++   rather than x: ?
11:30:13 <Peaker> (about Miranda code from earlier)
11:30:33 <aristid> :t zipM
11:30:34 <lambdabot> Not in scope: `zipM'
11:31:12 <roconnor> Peaker: don't ask me. Ask wikipedia
11:31:34 <Peaker> roconnor, they should run hlint on their miranda code :)
11:31:38 <roconnor> on occassion I write ([x] ++) in haskell
11:31:43 <Peaker> it seems it would parse :)
11:31:50 <roconnor> esp. in (l1 ++ [x] ++ l2)
11:31:53 <Peaker> roconnor, then you should hlint too
11:31:59 <Peaker> ah :)
11:32:01 <roconnor> I do it for clairty
11:32:23 <roconnor> I checked at the rewrite rules should simplify it
11:32:35 <roconnor> I might have even filed a bug that it didn't simply at one point in time.
11:33:26 <Peaker> sounds like inlining or partially evaluating (++), is that called "simplification"?
11:33:56 <roconnor> no, it is a rewrite rule ++ IIRC.
11:33:58 <aristid> .oO(ZipListT)
11:34:16 <roconnor> well maybe you are right
11:34:27 <roconnor> maybe ++ is inlined and then it is a foldr-singleton rewrite rule
11:35:13 <roconnor> Peaker: it could/should be partial evaluation, but GHC does do partial evaluation (of recursive functions)
11:35:21 <roconnor> *doesn't
11:36:55 <Celessar> Hi, who can help me with a Cabal problem?
11:37:19 <Peaker> roconnor, bummer.. it could try to do it for a few iterations and see if it works
11:37:23 <Peaker> Celessar, #haskell can!
11:37:28 <roconnor> Celessar: does it involve the mtl?
11:37:50 <djahandarie> Heh
11:38:08 <djahandarie> Are you collecting statistics roconnor
11:38:09 <Celessar> well, I new with haskell, and I have problems installing packages with cabal-install
11:38:27 <roconnor> djahandarie: I hate the mtl so much!
11:38:44 <roconnor> Celessar: Windows or Linux?
11:38:54 <djahandarie> Well hopefully that proposal gets some movement :)
11:39:17 <Peaker> roconnor, It wouldn't be such a problem if we had signature-based package linkage.. i.e: Anything that provides the used mtl interface would be a suitable dependency -- then we can have a transformers-mtl-interface bridge package
11:39:26 <roconnor> djahandarie:  it is a good proposal.  They even acknowledged all the errors in the mtl, though stopped sort of fixing them.
11:39:27 <Peaker> roconnor, I hate that cabal-install is based on primitive version numbers and not signatures
11:39:45 <Celessar> my default packages are in /var/lib/ghc-6.12.1/package.conf.d and when i install the others they go to /home/xxx/.ghc/i386-linux-6.12.1/package.conf.d
11:39:46 <Celessar> linux
11:39:54 <Celessar> ubuntu
11:41:16 <roconnor> there is some way to choose between "gloabal" and "user" installs
11:41:41 <aristid> @hoogle sleep
11:41:41 <lambdabot> No results found
11:42:01 <roconnor> @hoogle Int -> IO ()
11:42:01 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
11:42:02 <lambdabot> System.Console.Editline.Readline setCompletionQueryItems :: Int -> IO ()
11:42:02 <lambdabot> System.Console.Editline.Readline setEnd :: Int -> IO ()
11:42:16 <Celessar> and how i choose that?
11:42:42 <Celessar> can i tell cabal-install the path where i want it to install?
11:43:03 <roconnor> see ~/.cabal/config
11:44:49 <Celessar> then i change the prefix for instal-dirs global?
11:44:51 <Celessar> or what?
11:46:03 <roconnor> Celessar: I'm not sure
11:46:05 <roconnor> that is my guess
11:46:10 <ClaudiusMaximus> lispy: got it working on lenny with the old versions; in case you're curious: http://img816.imageshack.us/img816/2534/2473.png
11:46:13 <roconnor> you probably have to remove the -- 
11:46:24 <Lemmih> Celessar: What are you trying to do?
11:46:34 <lispy> ClaudiusMaximus: cool
11:46:49 <Celessar> Lemmih, tell cabal-install where i want it to install the packages
11:49:02 <Lemmih> Celessar: 'cabal install --global' isn't doing the trick?
11:50:39 <Celessar> Lemmih, nop
11:50:44 <Lemmih> Celessar: But as roconnor said, you can change the install prefix in ~/.cabal/config.
11:50:59 <Celessar> ok, i'll do it
11:52:58 <Celessar> im trying to install happy
11:54:29 <aristid> :t mapM_ (\t -> newEmptyMVar >>= \v -> forkIO (t >> putMVar v ()) >> takeMVar v)
11:54:30 <lambdabot> Not in scope: `newEmptyMVar'
11:54:30 <lambdabot> Not in scope: `forkIO'
11:54:30 <lambdabot> Not in scope: `putMVar'
11:54:50 <aristid> :: [IO a] -> IO ()
11:55:10 <Celessar> well, exactly i want to install the latest version of gtk but when i try, it doesn't install it where i want, so i tried to install the dependencies manually
11:55:26 <ddarius> roconnor: Don't forget [(x,y) / x <- xs; y <- ys]
11:55:42 <Lemmih> Celessar: Why do you care where it is installed?
11:56:33 <Celessar> cuz when i run my program it doesn't recognize the modules
11:56:53 <Celessar> is like i have 2 compilers
11:58:10 <Lemmih> Celessar: Then the installation must have failed.
11:58:47 <Celessar> that's why i try to install it step by step
11:58:50 <Celessar> in my shell
12:00:28 <Lemmih> Celessar: That shouldn't be necessary. Cabal-install will tell you about any packages that failed to install.
12:00:38 * shapr does cabal install xilinx-lava
12:00:45 * shapr hugs Lemmih 
12:00:57 <Lemmih> Hiya shapr. ltns.
12:01:02 <Celessar> but when i try to do "./setup install" with the happy executable installer it tell me that "HappyTemplate doesn't exist
12:01:05 <ddarius> What Lemmih said.
12:01:14 <shapr> Lemmih: Yeah, totally.. you have programming employment?
12:01:28 <Lemmih> shapr: No /-:
12:01:34 <shapr> ddarius: Not as long as the first time, aren't you soon to be employable?
12:01:52 <ddarius> I'm technically unemployed right now.
12:02:01 <Celessar> ok, if you want i'll do "cabal install gtk" and tell you what it tells
12:02:09 <shapr> ddarius: You're out already?
12:02:15 <ddarius> Yep.
12:02:23 <Lemmih> Celessar: That would be great.
12:02:55 <shapr> ddarius: Where are you living? Would be fun to hang out with you... not that I have any free time lately.
12:03:13 <shapr> Lemmih: You're doing something else for money?
12:03:27 <ddarius> shapr: I'm living not far from where you lived in Massachusetts.
12:03:38 <shapr> hah, funny!
12:03:53 <shapr> So, you're Erdosing your way around?
12:04:03 <Lemmih> shapr: I'm getting a government stipend for finishing my GED.
12:04:06 <monochrom> fun
12:04:43 <aristid> shapr: erdosing?
12:04:59 <djahandarie> ddarius, what did you just finish? a PhD?
12:05:06 <ddarius> djahandarie: Um, no.
12:05:38 <ddarius> djahandarie: My active duty Air Force commitment.
12:05:49 <roconnor> what's a GED?
12:05:50 <shapr> aristid: As in, wandering around the world learning/teaching smart things from people face to face.
12:05:54 <djahandarie> Oh, I never even knew :o
12:06:07 <djahandarie> What are you planning on doing?
12:08:00 <ddarius> djahandarie: I have a programming job lined up (more or less) in the Boston area.  And I'll probably (I'd better) finish by Bachelor's and start on a Master's somewhere here.
12:08:12 <shapr> aristid: Erdos'ing, as in https://secure.wikimedia.org/wikipedia/en/wiki/Paul_Erdos
12:08:24 * hackagebot text-icu 0.5.0.1 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.5.0.1 (BryanOSullivan)
12:08:57 <aristid> ddarius: doing the bachelor's / master's part time?
12:08:59 <shapr> I've met Lemmih, ddarius, bos, edwinb and lots more people from #haskell ! but not dons sadly :-(
12:09:17 <BCoppens> shapr: there's always belhac? ;-)
12:09:29 <shapr> BCoppens: not likely :-)
12:09:32 <djahandarie> ddarius, oh wow, you don't even have your Bachelor's yet? You sound like you've been doing maths and CS for a long time so I assumed you did (and had more)
12:09:33 * ddarius only started meeting people from #haskell after eight years of being on it.
12:09:36 <shapr> would be fun though
12:09:49 <ddarius> shapr: Speaking of which, I'll most likely be meeting Tim Chevalier tomorrow.
12:09:55 <djahandarie> I've never met anyone from this channel :(
12:09:59 <Lemmih> roconnor: A high school degree.
12:10:01 <djahandarie> Haven't been here long at all though
12:10:11 <shapr> ddarius: Oh, Tim is back in the area?
12:10:24 <ddarius> shapr: I'm not exactly sure.  At least visiting.
12:10:31 <djahandarie> I've been neglecting to go to BAHUG for a couple times now though
12:11:00 <ddarius> djahandarie: I've been studying math and CS on my own way longer than I'd need to get even a Master's.
12:12:45 <ddarius> shapr: Any particular restaurants or other places I should go to in this area?
12:15:43 * copumpkin misses the HUGs
12:17:22 <djahandarie> Is there a formal type-theoretic definition of a type class somewhere?
12:18:02 * dilinger just left boston for seattle.  alas, no awesome jobs lined up yet.
12:19:42 <Adamant> dilinger: it's Seattle, shouldn't take forever :P
12:23:45 <Raghs> what's a good linux distro to run on top of windows 7 for haskell programming?
12:24:00 <monochrom> ubuntu. arch.
12:24:04 <dolio> FreeBSD
12:24:33 <monochrom> os/2
12:24:33 * hackagebot happstack-auth 0.2 - A Happstack Authentication Suite  http://hackage.haskell.org/package/happstack-auth-0.2 (NilsSchweinsberg)
12:24:40 <McManiaC> happstack-auth \o/
12:24:56 <McManiaC> my 2nd package :)
12:25:24 <ddarius> djahandarie: http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Qualified_types is one approach
12:25:24 <tommd> McManiaC++
12:26:00 <Raghs> something like an applicaiton in windows instead of a booting into linux
12:26:47 <monochrom> well we assumed you have already picked a virtual machine.
12:27:04 <djahandarie> Blah, all of those links seem to be dead
12:27:16 <Raghs> something like Topologilinux ?
12:27:26 <dolio> Actually, I assumed the idea was kind of nutty to begin with. I'd just dual-boot. :)
12:27:33 <dolio> No offense.
12:27:53 <tommd> McManiaC: Did you talk to Gracenotes about how hackage-server did auth at all?  Do you know if this can be leveraged by hackage-server?
12:28:02 <copumpkin> just single-boot
12:28:10 <dolio> Yeah, or that.
12:28:44 <roconnor> Raghs: with a VM you can pick any distro can't you?
12:29:06 <dolio> Arch is reportedly pretty Haskell savvy.
12:29:27 <dolio> I use Ubuntu, but don't use any of their packages. Maybe it's gotten better since I last checked, though.
12:29:50 <roconnor> nixos is awesome, though maybe not for haskell packages.
12:30:09 <ddarius> dolio: I just upgraded (twice) from Jaunty to Lucid and Lucid's ghc packages were newer than what I had installed.
12:30:10 <aristid> roconnor: why not?
12:30:13 <tommd> We need a good Xen based distribution that supports Haskell.
12:30:25 <McManiaC> tommd: you're talking about H.S.SimpleHTTP.basicAuth ?
12:30:51 <tommd> McManiaC: Something like that - it's been a while since I've looked at hackage-server but recall it using htpasswd
12:30:52 <roconnor> aristid: well either you have to package each cabal package, or there is some hack-nix thing that I've never tried that is suppose to automagically turn cabal packages into nix packages
12:30:53 <ddarius> dolio: Seems reasonably current, though you'll still want/need to use cabal for individual libraries that interest you.
12:31:07 <roconnor> I haven't tired hack-nix since it sounds impossible to do
12:31:18 <djahandarie> I've been thinking of switching to arch
12:31:20 <roconnor> (I mean that cabal doesn't have enough information)
12:31:24 <aristid> roconnor: packaging cabal packages is a problem not limited to nixos.
12:31:32 <roconnor> aristid: indeed
12:31:39 <roconnor> djahandarie: switch to nixos
12:32:07 <McManiaC> tommd: there are planes moving everything related to authentication into one package
12:32:09 <tommd> roconnor: You use nixos?  I thought that was more toy than tool, am I mistaken?
12:32:32 <roconnor> tommd: it is ready for prime time
12:32:33 <roconnor> IMHO
12:32:43 <roconnor> I'm using nixos right now
12:32:49 <roconnor> have been for almost a year
12:33:18 <tommd> McManiaC: The fact that you and Gracenotes/others are connected and unifying things is very encouraging.  Good work.
12:37:00 <applicative> copumkin there?
12:37:09 <applicative> copumpkin rather?
12:37:55 <dolio> copunkin
12:38:36 <monochrom> nixos uses nix. nix refers to a package manager. nix is purely functional, as in, persistent pure functional data structures, i.e., roll backs and forking are trivial.
12:39:20 <copumpkin> applicative: yep
12:39:23 <applicative> I was going to ask for advice with Criterion, but I just notice b o's has simple cases of putting class constraints on GADT constructor functions, or whatever you call them
12:39:24 <copumpkin> if only barely
12:39:26 <applicative> oh hi.
12:39:53 <applicative> i was going to point out http://hackage.haskell.org/packages/archive/criterion/0.5.0.4/doc/html/src/Criterion-Types.html  data Pure where ...
12:40:46 <copumpkin> I vaguely remember suggesting a type like that to him a while ago :)
12:40:48 <roconnor> monochrom: what do you mean by "forking is trival"?
12:40:49 <applicative> and ask for an analysis of his purpose.  is this an irreducibly GADTy trick
12:41:01 <copumpkin> maybe not
12:41:26 <applicative> it is pretty simple. 
12:41:33 <copumpkin> yep
12:41:45 <djahandarie> I don't see why they didn't just write most of it in Haskell
12:41:53 <robertosucks> for a second language Haskell is better then SICP(Scheme) ? (i know C)
12:41:56 <monochrom> multiple versions
12:42:19 <roconnor> yes
12:42:28 <applicative> robertosucks, haskell should have been your first language.  it's too late for you....
12:42:33 <djahandarie> robertosucks, yes.
12:42:41 <djahandarie> robertosucks, Scheme is faster/easier to learn though
12:42:45 <robertosucks> applicative, ?
12:42:53 <monochrom> for all n, for the nth language haskell is the best.
12:42:55 <applicative> just kidding robertosucks
12:42:57 <roconnor> specifically you can have multiple version of the same software installed (even if those versions have the same "version number")
12:43:21 <robertosucks> so haskell over SICP right?
12:43:23 <copumpkin> why does roberto suck, anyway?
12:43:29 <applicative> copumpkin, anyway, just noticed in while studying Criterion, I will keep my eye open for something more opaque to be explained
12:43:29 <copumpkin> robertosucks: yeah, but then again we would think so
12:43:35 <copumpkin> ask #scheme, and they'd suggest SICP
12:43:41 <dafis> robertosucks: although, if you're used to thinking C-wise, Haskell can be difficult to learn, it's much easier to learn as a first language
12:43:43 <copumpkin> applicative: okay :)
12:44:00 <monochrom> learning is unlearning
12:44:10 <robertosucks> i just start programming 7 months ago
12:44:14 <monochrom> @quote monochrom unlearning
12:44:14 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
12:45:46 <robertosucks> can you guys recommend me a book in haskell?
12:45:53 <applicative> strange to put 'intuition is experience' on that list; the mean the same thing, except in decadent english....
12:45:55 <roconnor> @where lyah
12:45:55 <lambdabot> http://www.learnyouahaskell.com/
12:46:04 <applicative> roconnor types too fast
12:46:24 <applicative> @where rwh
12:46:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:46:26 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
12:46:57 <robertosucks> what is the best book, learn you haskell or Real World Haskell ?
12:46:58 <roconnor> @where ttfp
12:46:58 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
12:47:00 <dolio> monochrom: How's that interactive math-learning assistant coming? I was talking it up on the comp-sci reddit a week or two ago.
12:47:24 <djahandarie> robertosucks, they are about two different hings
12:47:28 <djahandarie> things*
12:47:34 <monochrom> I don't know of an interactive math-learning assistant.
12:47:36 <robertosucks> djahandarie, why?
12:47:37 <djahandarie> robertosucks, Learn you a Haskell is about introducing syntax and concepts
12:47:50 <applicative> learnyouahaskell is pleasantly reader-friendly.   RWH presupposes a fair amount of programming background for some things. I'd think LYAH then RWH
12:47:52 <djahandarie> robertosucks, while Real World Haskell is about using Haskell to make actual useful programs and stuff
12:47:57 <roconnor> dolio: link
12:47:59 <monochrom> the best book is the 3rd book you read
12:48:08 <dolio> roconnor: To what?
12:48:25 <roconnor> dolio: it up on the comp-sci reddit
12:48:26 <applicative> monochrom is right, or maybe for some of use, the fifth or sixth.  But my favorite was Bird
12:48:27 <djahandarie> Learn you a Haskell also assumes some background knowledge
12:48:41 <robertosucks> i know C
12:48:51 <dolio> roconnor: http://www.reddit.com/r/compsci/comments/dbnba/teach_computer_science_without_a_computer/
12:49:00 <monochrom> many people use decadent english. they believe intuition is natively born. they are wrong. I have to tell them. intuition is experience. they mean the same thing.
12:49:08 <djahandarie> It basically just assumes background knowledge to tell you exactly what to forget
12:49:28 <robertosucks> lol
12:49:31 <applicative> djahandarie but how much does it presuppose?  admittedly i was already the middleweight halfwit haskeller i am now by the time i read it
12:49:43 <robertosucks> can you guys recommend me some exercices to do in Haskell?
12:49:47 <applicative> oh i see
12:49:48 <robertosucks> Learn you haskell has none
12:50:01 <applicative> haha, there's always the curse of project euler....
12:50:12 <applicative> just swear you'll never use lists....
12:50:25 <djahandarie> I wouldn't say to touch Project Euler
12:50:33 <djahandarie> That is only good if you want to learn math
12:50:34 <copumpkin> I enjoyed them for a while
12:50:34 <dolio> roconnor: "Computer science has nothing to do with physical computers" is a popular meme. But I think a corollary to monochrom's view is "computer science is better with computers."
12:50:39 <robertosucks> to mathy for me
12:50:51 <copumpkin> I think a lot of things are better with computers
12:51:25 <dolio> Exactly.
12:51:31 <roconnor> dolio: I don't know ... I think computers should use be restricted to mathematics :D
12:51:49 <Twey> I prefer ‘computers are a popular application for computer science’
12:52:11 <monochrom> hell, nevermind computer science. I am already better off with computers.
12:52:20 <copumpkin> I also hate the reality of computers about 70% of the time
12:52:28 <applicative> roberto, our gentlemen will know better but one thing is that you inevitably learn how to write functions from one 'pure' data structure to another, only later IO things, except very rudimentarily.  
12:52:43 <monochrom> but don't restrict your work to physical computers, that's for sure.
12:53:06 <applicative> it's that feature that makes project euler ideal, though it is too faux mathy and boring
12:53:44 <applicative> robertosucks, what sort of programs do you tend to write in C
12:54:11 <luite> what's faux mathy?
12:54:25 <monochrom> false mathy
12:54:26 <applicative> oh he's gone, my highlighting is too pale for disconnectors
12:54:39 <copumpkin> the statistics presented on faux news
12:55:03 <luite> monochrom: yes I know, but I don't really understand what's faux mathy about project euler
12:55:18 <applicative> i don't think its that mathematical.  take all the obnoxious problems about which numbers are divisible by their reverses in the digital represenatation
12:55:41 <monochrom> my view: claims to be math, but numerology
12:56:06 <luite> hmm, maybe, but imho that's still some form of (recreative?) math
12:56:13 <applicative> in that sort of case, it seems like it, though of course it is a math problem. just catatonia-makingly stupid
12:56:56 <dolio> Haven't they at least stopped making that variety of problems?
12:57:06 <applicative> what is product of all the 7s in the first 1000 digits of the expansion of pi
12:57:58 <applicative> dolio, i think probably, i just did like the first 40 or so when i first 'learned' haskell now there's tons more, which seem pretty sophisticated. 
12:58:19 <dolio> Actually, I guess they still are.
12:58:30 <roconnor> > let n = length (filter (='7') (showCReal 1000 pi)) in 7^n
12:58:31 <lambdabot>   <no location info>: parse error on input `='
12:58:37 <roconnor> > let n = length (filter (=='7') (showCReal 1000 pi)) in 7^n
12:58:38 <lambdabot>   192448176927753792547429509674553270117046659064950639670012217016224874137...
12:59:03 <dolio> Problem 254 is about sums of digits and sums of factorials of digits.
12:59:13 <applicative> more sophisticated, like, take all the homfunctors in ... and add up the first letters in their names according to a = 1, .... 
12:59:17 <copumpkin> has anyone come up with a CReal-alike that could support dumping of infinite digits?
12:59:32 <roconnor> applicative: I thought some of the digit summing stuff was a poorman's checksum
12:59:46 <roconnor> copumpkin: oh yes, there are several
12:59:47 <luite> > showCReal 4 pi -- that could give te wrong answer
12:59:48 <lambdabot>   "3.1416"
12:59:51 <applicative> oh, i see, its related to a genuine purpose
12:59:54 <copumpkin> roconnor: oh, where?
13:00:03 <applicative> copumkin, no the digits are 1 2 3 4 5 6 7 8 9 0
13:00:05 <Twey> :t showCReal
13:00:06 <lambdabot> Int -> CReal -> String
13:00:10 <Twey> pi is a CReal?
13:00:12 <Twey> :t pi
13:00:13 <lambdabot> forall a. (Floating a) => a
13:00:15 <Twey> Huh.
13:00:21 <Twey> How does that work?
13:00:29 <copumpkin> CReal is an instance of Floating :)
13:00:30 <dolio> pi is computable.
13:00:31 <Philonous> It's part of the FLoating class
13:00:36 <roconnor> copumpkin: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Dynamic_precision_by_lazy_evaluation
13:00:40 <Twey> Oh bloody hell
13:00:50 <Twey> It's part of Floating.
13:00:52 <Twey> Urgh.
13:00:54 <copumpkin> roconnor: oh, thanks :)
13:01:00 <roconnor> copumpkin: fewer than I thought
13:01:05 <roconnor> copumpkin: don't use BigFloat
13:01:12 <roconnor> ... so that leaves only 1
13:01:13 <copumpkin> roconnor: ever think of doing coinductive reals for proofs?
13:01:22 <copumpkin> as in
13:01:24 <roconnor> copumpkin: oh yes
13:01:29 <roconnor> other people do that though
13:01:32 <copumpkin> oh
13:01:37 <applicative> as in??
13:01:44 <monochrom> cauchy sequences?
13:01:56 <roconnor> as in?
13:02:27 <dolio> R -> R is essentially coinductive.
13:02:32 <dolio> Er, Q -> Q.
13:03:09 <roconnor> copumpkin: I wrote an implemenation of integration that take (CReal -> CReal) and produces the integral of that from 0 to 1 using Escardo techniques
13:03:12 <dolio> N -> Q more obviously.
13:03:20 <applicative> the development would be of a piece with ... escardo....
13:03:22 <copumpkin> roconnor: oh, interesting
13:03:25 <roconnor> copumpkin: it is very very slow
13:03:30 <copumpkin> I'd imagine :)
13:03:37 <copumpkin> are you using his fastest techniques?
13:03:38 <copumpkin> :P
13:03:43 <roconnor> copumpkin: yes.
13:03:52 <copumpkin> still pretty neat though
13:03:56 <copumpkin> is that code anywhere public?
13:03:56 <roconnor> copumpkin: If I knew that the function were differentiable, I could do it much faster
13:03:57 <applicative> i wish i could read an essay like "seemingly impossible functional programs" every morning
13:04:07 <roconnor> copumpkin: no where public I don't think.
13:04:14 <roconnor> I can paste it 
13:04:34 <copumpkin> thatnks, that'd be interesting
13:04:51 <djahandarie> I wish people would talk about more complicated stuff in here more often and in more detail
13:05:11 <Martty> anyone broke up recently??
13:05:36 <djahandarie> Complicated Haskell stuff... :P
13:05:45 <djahandarie> @vixen We're breaking up
13:05:45 <lambdabot> what's the matter?
13:05:49 <copumpkin> djahandarie: like what?
13:06:00 <copumpkin> #haskell-blah might give you better responses :)
13:06:01 <applicative> djanderie, like what
13:06:28 <applicative> get them to explain escardo's "seemingly impossible functional programs" to us
13:06:48 <djahandarie> Hm... dunno, like doing crazy type-level things
13:06:48 <copumpkin> the J entry was pretty interesting too
13:07:06 <applicative> the J entry for what?
13:07:22 <copumpkin> "an amazing functional" iirc
13:07:28 <copumpkin> http://math.andrej.com/2010/07/29/an-amazing-functional/
13:07:39 <roconnor> copumpkin: http://hpaste.org/30161/integral01__creal__creal
13:07:48 <roconnor> I'm not sure why I have that extra Int parameter
13:07:56 <roconnor> I think it should be just set to 1.
13:08:03 <roconnor> maybe 0
13:08:06 <dolio> Too bad that blog hasn't been updating in a while.
13:08:11 <monochrom> djahandarie: do you like continuation-passing style and trampolining?  http://www.vex.net/~trebla/tail.html  (see source code, has javascript)
13:08:26 <copumpkin> dolio: 7/29 isn't too long ago
13:08:31 <copumpkin> maybe he went on vacation?
13:09:09 <roconnor> unitInterval = do
13:09:10 <roconnor>   x <- unitInterval
13:09:12 <roconnor>   doubleton (left x) (right x)
13:09:13 <roconnor> :D
13:09:18 <roconnor> ah, what a great definition
13:09:35 <djahandarie> Heh
13:09:38 <copumpkin> :P
13:09:59 <dolio> copumpkin: I guess. That was a link to other work that I've already heard of, though. :)
13:10:06 <copumpkin> roconnor: Data.Searchable?
13:10:14 <copumpkin> ah, yeah
13:10:21 <roconnor> the unit interval is defined to be the [x/2| x<-unitInterval] union [0.5 + x/2| x<-unitInterval]
13:10:32 <dolio> March was the last time I was really interested in an article.
13:11:20 <roconnor> god, even I don't really know why that works.
13:12:08 <roconnor> I guess if you iterate that construction starting with any set, you will get a dense subset of the unit interval, which is a good enough definition of the unit interval for our purposes
13:12:16 <applicative> whoa bar recursion, dreamy
13:13:07 <djahandarie> Is it possible to abstract out that trampolining and make it work for any CPS function? That'd be a nice way of doing tail recursion in JS
13:13:38 <applicative> copumpkin, i dont see any reference to J following that link, but I hadn't seen the post. 
13:14:57 <copumpkin> applicative: oh, the linked paper calls it J 
13:15:04 <copumpkin> type J r x = (x -> r) -> x
13:18:43 <monochrom> djahandarie: Someone else did but I don't like it. His/her solution: write a javascript program to take a javascript cps program as a string, now parse it yourself, transform it yourself, then call eval.
13:18:45 <applicative> I see, i was looking at J this and J that in the agda code
13:19:12 <djahandarie> That's not even a solution
13:19:27 <copumpkin> applicative: J in agda?
13:19:43 <applicative> J : ? -> ? -> ?  
13:19:43 <djahandarie> If you had the ability to run your own transformer you wouldn't even need to deal with the CPS, you could just do the tail-call optimization directly
13:19:49 <applicative> those were omegas
13:20:01 <dolio> J in agda could be equality elimination, depending on what you're looking at.
13:20:36 <monochrom> oh, perhaps he/she also does cps. I just don't like "treat it as string then eval"
13:20:55 <applicative> j : Omega -> Omega -> Omega   Omega = Set -- Type of propositions denoted by ?, like in a topos:
13:20:56 <dolio> Martin-loef type theory used I as the identity type, and then J as its eliminator.
13:21:32 <dolio> And K is an alternate eliminator that's been talked about.
13:21:34 <applicative> Omega = Set -- Type of propositions denoted by Omega, like in a topos
13:22:04 <copumpkin> applicative: I get the impression we're missing something
13:22:24 <applicative> yeah of course
13:22:37 <ddarius> Omega is the subobject classifier?
13:22:51 <applicative> is 'J' the name of a standard combinator like S K etc?
13:23:19 <ddarius> Not a common one.  There's Landin's J operator, but that's related to continuations.
13:23:23 <prey_alone> Is there a graph that uses data Node = Integer instead of Node = Int? Data.Graph.Inductive is a bit restrictive that way.
13:23:41 <monochrom> http://glat.info/pub/tailopt-js/
13:24:16 <monochrom> it doesn't do cps after all. it just automatically trampolines by regex-ing over source code as string.
13:24:33 <applicative> Sorry, this is ludicrous meditation on things with the letter J, like sesame street.  By chance copumpkins remark led me to escardo et als agda code about sequential games bar recursion etc.   including the presuppositionless module http://www.cs.bham.ac.uk/~mhe/papers/msfp2010/MSFP2010/agda/Logic.agda
13:24:34 <dolio> That sounds pretty evil.
13:24:53 <monochrom> anyway I prefer to do it by hand and it's pretty easy for me.
13:25:14 <roconnor> presuppositionless?
13:25:22 <monochrom> or else I write the transformer in haskell not in javascript! :)
13:26:06 * ddarius implemented monadic parsers and a logic monad (not just backtracking) in JavaScript and then implemented (the core of) Prolog.
13:26:32 <monochrom> there is no end to depravity
13:26:44 <ari> Cabal is punishing me for running it in a crazy environment (MinGW+MSYS on Wine) by dropping me into cmd.exe when I try to compile Cairo (more precisely, in the "preprocessing library" part). I wonder if I should even try to figure out how to fix this...
13:27:01 <monochrom> (says the founder of an EFnet channel called #mathdepravity )
13:27:58 <djahandarie> I wish there was a decent Javascript library similar to Prelude
13:28:31 <applicative> ari  ..  MinGW+MSYS on Wine is really avant garde.  You don't need a prophylactic to use windows, you know. 
13:29:28 <applicative> djahandarie do you know a lot of javascript? 
13:29:38 <djahandarie> Yeah, quite a bit
13:29:58 <copumpkin> inhabited : Set → Ω
13:30:49 <ddarius> http://hpaste.org/30163/prolog_implemented_in_javascri
13:31:33 <applicative> yipe. but not in the typesystem.
13:31:44 <ddarius> Besides the unification, I only use externally visible mutation once in that program and it cost me a lot of time.
13:32:52 <ddarius> @tell chrisdone Your hpaste needs preview.
13:32:53 <lambdabot> Consider it noted.
13:34:32 <ddarius> As the cons function demonstrates, the code is a toy.
13:36:35 <applicative> ddarius, i've already incorporated it into the webpage for my course, i'm studying it in the chrome js interpreter
13:36:53 <djahandarie> I imagine writing a linked list would have been a good step
13:37:23 <applicative> > typeof Slice        --- "function"
13:37:24 <lambdabot>   Not in scope: `typeof'Not in scope: data constructor `Slice'
13:37:41 <applicative> lambabot, i was talking to jsbot
13:41:22 <tommd> Having to pattern match 12+ field data types due to Existential Quantification sucks.
13:43:59 <applicative> jsprompt> map(isUpper, ['a','A'])   -- [false, true]  this js-prolog has functional overtones....
13:45:32 <applicative> @type uncurry map
13:45:33 <lambdabot> forall a b. (a -> b, [a]) -> [b]
13:48:20 <applicative> djahandarie, but speaking shamelessly of javascript libraries, is there one that incorporates the wisdom of the book ".Javacript the good parts' I study it on and off like everything
13:50:03 <djahandarie> He left...
13:51:17 <dafis> djahandarie: you right
13:55:16 <ddarius> djahandarie: Writing a linked list is left as an exercise to the reader.
13:55:34 <djahandarie> lol
13:59:39 <enigmus> I'm hitting a stack overflow, but I'm having trouble understanding what is sitting on the stack. Using ghci, :trace and :history looks to me like I'm like 12 levels deep. Clearly, that's not the case, but I'm finding it hard to understand what's going on. I've been trying to force the evaluation of a number of things, but without success. I'm pretty sure my code would not overflow in a strict language. Any tip to explore that kind of problem
14:00:11 <ezyang> enigmus: Is your code short enough to post? 
14:00:55 <enigmus> ezyang: not really, and more than a solution to this particular porblem, I was hoping for some guidance on how to deal with this kind of issue
14:01:32 <ezyang> So, my guess is not a laziness/strictness issue, but the fact that you've written your code in a way that doesn't TCO. 
14:01:52 <ezyang> Can you add tracing statements with Debug.trace? 
14:02:59 <Saizan> enigmus: do you understand the difference between foldl and foldl' ?
14:03:15 <enigmus> Saizan: yeah
14:03:20 <Saizan> people coming from strict functional languages usually have problems with lazy accumulators
14:03:47 <Nibble> data Workspace i l a = Workspace  { tag :: !i, layout :: l, stack :: Maybe (Stack a) }
14:03:54 <Nibble> what does the !i part mean?
14:03:59 <Twey> Strictness
14:04:00 <enigmus> Saizan: yeah, I tried to make sure nothing would remain unevaluated
14:04:21 <dafis> enigmus: tried deepseq?
14:04:26 <benmachine> Nibble: it means that Workspace x y z is actually more like (Workspace $! x) y z
14:04:37 <Nibble> benmachine: hmm?
14:04:43 <Nibble> what does $! mean?
14:04:48 <benmachine> @src $!
14:04:48 <lambdabot> f $! x = x `seq` f x
14:04:51 <dafis> Nibble: strict application
14:05:14 <benmachine> it means x must be evaluated to its toplevel constructor before the Workspace constructor is applied
14:05:29 <enigmus> ezyang: It's possible I failed to make one of my recursion TCO-able. Is there a way to identify these, somehow? (e.g. ghc -fwarn-non-tco :-)
14:05:55 <kmc> ghc-core
14:06:02 <Nibble> @src $
14:06:02 <lambdabot> f $ x = f x
14:06:08 <ezyang> "Core" 
14:06:14 <ezyang> But really, go and stare at your code a little. 
14:06:15 <Nibble> So it evaluates x before f x?
14:06:21 <enigmus> dafis: no, I should (I have meant to emulate deepSeq behavior by hand, but I should try the real thing)
14:06:23 <c_wraith> Nibble: not
14:06:26 <c_wraith> err, *no
14:06:38 <enigmus> kmc: ezyang: How do I see a tail-call in Core?
14:06:45 <c_wraith> evaluation in haskell is always outside-in
14:06:56 <Nibble> c_wraith: outside-in meaning what?
14:06:59 <kmc> Nibble, yeah.  if evaluation of (f $! x) is forced, it will force x before entering f
14:07:19 <c_wraith> Oh.  You meant $!, not $
14:07:21 <ddarius> kmc: Not even then...
14:07:31 <Nibble> kmc: if they used $ instead, what would happen?
14:07:46 <kmc> Nibble, depends on the code to f
14:07:48 <c_wraith> $ doesn't actually do much of anything.  It's identical to id.
14:07:54 <kmc> > const () $ undefined
14:07:55 <lambdabot>   ()
14:07:57 <kmc> > const () $! undefined
14:07:58 <lambdabot>   *Exception: Prelude.undefined
14:08:11 <kmc> ddarius, because "seq" actually lacks operational guarantees?
14:08:18 <Nibble> @src id
14:08:18 <lambdabot> id x = x
14:08:20 <ddarius> Yes
14:08:26 <Nibble> @src seq
14:08:26 <lambdabot> Source not found. Just try something else.
14:08:36 <c_wraith> seq is magical.  it can't be written in haskell
14:08:42 <kmc> right, i should say "if evaluation of (f $! x) is forced, evaluation of x will also be forced before, during, or after it returns"
14:08:47 <kmc> seq can be written for specific types
14:08:51 <kmc> seq True x = x; seq False x = x
14:08:54 <kmc> seq () x = x
14:09:08 <c_wraith> Yes, but you can't write a single function with that type signature that does what seq does
14:09:41 <benmachine> you can't write seq for functions
14:10:00 <benmachine> seq can distinguish between undefined and const undefined, nothing else in the language can
14:10:37 <Nibble> benmachine: chuck norris can.
14:10:49 <c_wraith> Nibble, Chuck Norris is not specified by haskell :)
14:11:02 <Nibble> c_wraith: Haskell is specified by Chuck Norris
14:11:31 <benmachine> it isn't
14:11:41 <Nibble> benmachine: it is.
14:11:42 <dafis> Out of curiosity, does anybody know when and where the Chcuk Norris meme originated?
14:11:47 <mauke> oleg can. in the type system.
14:11:54 <benmachine> heh
14:11:58 <benmachine> oleg > norris
14:12:10 <Nibble> who the hell is oleg?
14:12:13 <dafis> > "oleg" > "norris"
14:12:14 <lambdabot>   True
14:12:17 <benmachine> yesss
14:12:28 <Nibble> he. wtf
14:12:30 <kmc> dafis, http://knowyourmeme.com/memes/chuck-norris-facts
14:12:39 <chrisdone> ddarius: I saw your logic language in javascript, nice! pity the monad is kind of ugly
14:12:39 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
14:12:44 <dafis> kmc: thx
14:13:01 <chrisdone> @messages
14:13:01 <lambdabot> ddarius said 40m 9s ago: Your hpaste needs preview.
14:13:33 <chrisdone> yeah, that's on my todo
14:13:34 <mauke> @quote OlegFacts
14:13:34 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
14:13:40 <mauke> @quote OlegFacts
14:13:40 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
14:14:57 <dankna> @quote OlegFacts
14:14:57 <lambdabot> OlegFacts says: Oleg implemented first-class continuations in Haskell... in the type system
14:15:02 <chrisdone> ddarius: wouldn't Monad.unit.call(parser,a); be more analogous? too bad that's even more verbose
14:18:41 <mjo> I have a newbie question: I want to create a type, XmlData, that's either CharData or Nothing. But when I have some CharData (cd) and try to cast it to XmlData, badness occurs: http://hpaste.org/30164/xmlhs. What am I doing wrong?
14:19:28 <kmc> the Nothing constructor is already used by Maybe
14:19:37 <kmc> instead of inventing a new type, you could use the type (Maybe CharData)
14:19:55 <kmc> anyway there's another flaw
14:20:00 <kmc> you need a constructor on every alternative
14:20:09 <kmc> you don't insert values into a sum type by "casting"
14:20:16 <kmc> i can't say «3 :: Maybe Int»
14:20:20 <kmc> i have to say «Just 3»
14:20:21 <kmc> @src Maybe
14:20:22 <lambdabot> data Maybe a = Nothing | Just a
14:20:28 <kmc> ^^^^ defines constructors Nothing and Just
14:21:23 <mjo> Hmm that's definitely a better way to do it. But if I rename my Nothing to Nothing2, it still blows up?
14:21:28 <kmc> yes
14:21:37 <c_wraith> @src unzip3
14:21:38 <lambdabot> Source not found. It can only be attributed to human error.
14:21:42 <kmc> because «cd» has type CharData
14:21:56 <kmc> so when you say «cd :: XmlData» it's just a lie
14:22:12 <kmc> :: is not a cast or a conversion; it's writing explicitly a fact that must already be true
14:22:49 <mjo> So what you're saying is that I can't create a "synonym" for something that's either CharData or Nothing2, but that I need to wrap the CharData in a constructor e.g. Just?
14:23:00 <dafis> right
14:23:07 <kmc> yeah
14:23:08 <mjo> Ok, got it.
14:23:28 <mjo> Thanks. I'll rewrite it to use Maybe.
14:24:39 <azaq23> > (5 :: (Num t => t)) :: Int
14:24:40 <lambdabot>   5
14:24:51 <azaq23> doesn't that count as conversion / cast?
14:24:56 <benmachine> no
14:25:17 <kmc> there's no "conversion function" at runtime
14:25:26 <benmachine> those type specifications are compatible
14:25:34 <kmc> you are just providing a true fact which is less general than the most general fact
14:26:01 <benmachine> you can constrain a type further with :: but you can't actually change one concrete type into another
14:26:12 <monochrom> :: is a type cast. True :: Bool casts Bool to Bool. 'x'::Char converts Char to Char.
14:26:58 <monochrom> 'x'::Tree would convert, if only the type checker allowed it.
14:27:08 <kmc> and the way type inference works, all the facts you provide are combined with all the stuff implied by how the value is used, resulting in either a single most general consistent type, or an error
14:28:10 <kmc> in particular information flow is bidirectional... a signature on a value can affect the inferred type of something that earlier produces that value
14:28:23 <kmc> which is not how any sane definition of "conversion" would work
14:28:48 <monochrom> but we can try insane definitions. I started one.
14:40:36 <Nibble> A question about function composition
14:40:59 <monochrom> a good answer
14:41:07 <Baughn> Disputing statement
14:41:13 <Nibble> f (g x) = (f . g) x
14:41:19 <dafis> yes
14:41:29 <Baughn> Ayup
14:41:33 <dankna> lol at baughn
14:41:36 <Nibble> what exactly does that mean?
14:41:49 <dankna> f of g of x equals f dot g of x
14:41:53 <Baughn> In this case, it's mathematical equality
14:42:00 <Baughn> The two sides mean the exact same thing.
14:42:07 <Nibble> Baughn: I know....
14:42:14 <Nibble> stop acting like an asshole
14:42:17 <Baughn> (Except that . is technically a function.. but never mind that)
14:42:20 <dankna> I'm not really sure how to explain it any simpler - it's the definition of dot
14:42:36 <dankna> it's saying that the right side is a special notation for the left side
14:42:50 <dankna> you know how function calls are written, I assume
14:42:54 <Nibble> dankna: I am perfectly aware what the equal sign means.
14:43:12 <dankna> then I have to say that I just don't understand what there is to question
14:43:15 <megajosh2> Nibble: What is it exactly that you need clarification on?
14:43:20 <Baughn> Nibble: You may have missed the part where = is /not/ usually mathematical equality in haskell
14:43:26 <dafis> :t (.)
14:43:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:43:36 <dafis> :t (Prelude..)
14:43:37 <djahandarie> lol lambdabot always making things clearer
14:43:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:43:53 <dafis> @src (.)
14:43:53 <lambdabot> (f . g) x = f (g x)
14:43:54 <lambdabot> NB: In lambdabot,  (.) = fmap
14:43:54 <dankna> perhaps if we substituted actual meaningful functions instead of the placeholders f and g?
14:44:39 <Nibble> megajosh2: well, how does it evaluate(not right word for it perhaps)
14:44:40 <djahandarie> Nibble, are you asking about the operations GHC goes through to transform composition into something else?
14:44:50 <dankna> how about, if we have the definitions
14:44:51 <Nibble> djahandarie: no, hang on
14:44:59 <dankna> foo x = x + 1
14:45:02 <dankna> bar x = x * 2
14:45:23 <dankna> foo (bar 5) = 11, right?
14:45:30 <dafis> yup
14:45:37 <dankna> well, the . operator combines the two functions foo and bar, producing a new function
14:45:42 <dankna> (foo . bar) 5 = 11
14:45:47 <Nibble> (f . f) x = f(f(x)), that made it more clear. So basically you first apply the right or left side of the .?
14:45:57 <c_wraith> @hoogle listToMaybe
14:45:57 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
14:45:57 <megajosh2> Right
14:46:07 <dankna> the right-hand side is the inner one
14:46:08 <bss03-AFK> > let { foo = (+ 1); bar = (* 2); } in foo $ bar 5
14:46:09 <lambdabot>   11
14:46:22 <Nibble> And it works the same way in haskell?
14:46:30 <megajosh2> @src (.)
14:46:30 <lambdabot> (f . g) x = f (g x)
14:46:30 <lambdabot> NB: In lambdabot,  (.) = fmap
14:46:34 <megajosh2> Yup
14:46:43 <Nibble> cool
14:46:46 <djahandarie> Using partial application and $ may have not been the best example for showing function composition...
14:47:32 * djahandarie leaves his desk
14:47:33 <bss03-AFK> > let { foo = (+ 1); bar = (* 2); } in (foo . bar) 5
14:47:34 <lambdabot>   11
14:47:39 <bss03-AFK> > let { foo = (+ 1); bar = (* 2); } in foo bar 5
14:47:40 <lambdabot>   11
14:47:50 <djahandarie> Haha
14:48:07 <djahandarie> :t (+1)*2
14:48:08 <lambdabot> forall a. (Num a) => a -> a
14:48:13 <djahandarie> Good old lambdabot
14:48:40 <dafis> remember, kids, don't try this at home
14:48:53 <djahandarie> Ignore that last one btw, that wouldn't normally work without dark magic
14:48:59 <dolio> > sin^2 - 1 $ 357
14:49:00 <lambdabot>   -0.17320100348397982
14:49:29 <dmhouse> > 1 2
14:49:29 <lambdabot>   Ambiguous type variable `t' in the constraint:
14:49:30 <lambdabot>    `GHC.Num.Num t' arising f...
14:49:30 <dafis> > sin^2 + cos^2 $ 357
14:49:31 <lambdabot>   1.0
14:49:44 <dmhouse> Who made a functional Num instance?
14:49:52 <aristid> vector-spaces or so.
14:49:58 <monochrom> a mathematician
14:50:01 <djahandarie> How about we get another operator in lambdabot like # which runs vanilla Haskell?
14:50:01 <aristid> lambdabot imports that
14:50:22 <djahandarie> That way Cale would be happy with Caleskell but we could also show... normal stuff
14:50:24 <benmachine> djahandarie: booooring
14:50:28 <aristid> djahandarie: crybaby
14:50:34 <dmhouse> monochrom: really? Pretty sure a mathematician would balk at the Eq prerequisite... :)
14:50:41 <djahandarie> Lovely response
14:50:44 <djahandarie> Ugh I was going to leave
14:50:46 * djahandarie runs
14:50:49 <dmhouse> Not to mention, what is signum f?
14:51:16 <aristid> :t signum
14:51:17 <lambdabot> forall a. (Num a) => a -> a
14:51:35 <aristid> > sig (const (-1)) $ 5
14:51:36 <lambdabot>   Not in scope: `sig'
14:51:38 <dmhouse> Oh, I thought it was Num a => a -> Int or similar
14:51:44 <aristid> > signum (const (-1)) $ 5
14:51:44 <dolio> "Caleskell" is like 3 definitions.
14:51:45 <dafis> dmhouse: signum f = signum . f would be a natural choice
14:51:45 <lambdabot>   -1
14:51:52 <monochrom> a mathematician would hate the Eq prerequisite and work around it by undefine.
14:51:58 <dmhouse> Well, I stand by the Eq thing.
14:52:10 <dmhouse> The Show is awkward too if you want that show . read = id
14:52:18 <aristid> > (+1) == (+2)
14:52:19 <lambdabot>   *Exception: (==): No overloading for function
14:52:22 <aristid> :)
14:52:27 <dolio> Num instances for functions is from some imported library.
14:52:37 <aristid> dmhouse: Num has no Show requirement
14:52:52 <dmhouse> aristid: my GHCi disagrees
14:53:02 <dafis> mine too
14:53:26 <monochrom> I only claim to know the behaviour of a mathematician. I don't follow or condone their rationales.
14:53:27 <dolio> It definitely does.
14:53:37 <dmhouse> http://pastebin.org/950446
14:53:38 <dolio> So that you don't have to write (Show n, Num n) => ...
14:53:38 <aristid> wut
14:53:45 <aristid> that is stupid.
14:53:46 <dolio> You can just write (Num n) =>
14:53:50 <dolio> Isn't that a great idea? :)
14:53:56 <aristid> um....
14:54:07 <aristid> > (+1)
14:54:07 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:54:08 <lambdabot>    arising from a use of `...
14:54:08 <dmhouse> ISTR there being a semi-convincing reason for it
14:54:45 <dmhouse> Maybe along the lines of we didn't want a complete newcomer to Haskell typing "1+1" into GHCi and it saying "No Show instance for..."
14:54:45 <aristid> the Num class is one of the major travesties in haskell.
14:54:46 <monochrom> yes, if functions are Num, 2 is a function too.
14:55:02 <dmhouse> The Eq dictionary is so you pattern match on numeric literals
14:55:21 <monochrom> there are 3 incentives for making 3 a function.
14:55:25 <aristid> dmhouse: couldn't ghci solve that by doing defaulting first?
14:55:36 <monochrom> incentive A: 3 = const 3
14:55:42 <monochrom> incentive B: 3 = (3 *)
14:55:47 <dmhouse> aristid: that sounds like a nontrivial semantic change
14:55:50 <dolio> It does do defaulting.
14:56:03 <monochrom> incentive C: 3 = (\x -> 3*10 + x)  so for example 3 4 = 34, isn't that nice?
14:56:17 <dafis> ewww
14:56:21 <dmhouse> monochrom: wow, that last one is awful
14:56:29 <megajosh2> I laughed
14:56:35 <monochrom> oh I miscounted.
14:57:22 <chrisdone> ddarius: there you go! :-) http://github.com/chrisdone/amelie/commit/5155f85593a67a8a762fe880e814f140fa67f874
14:57:57 <aristid> monochrom: const has the appeal of beautifully matching the Applicative instance for functions
14:58:11 <monochrom> incentive D: 3 = (3 +)  so for example 3 ½ = 3+½
14:58:42 <monochrom> so there are 4 incentives
14:58:42 <dafis> monochrom: if I were an Op, I'd kick you for that :D
14:58:48 <aristid> incentive E: 3 = undefined
14:58:59 <monochrom> kick me for what?
14:59:15 <dafis> monochrom: for that eeeevil incentive
14:59:36 <dolio> 4 incentives that are mutually exclusive.
14:59:38 <monochrom> do you not write like 3 ½ yourself?
14:59:49 <dafis> nope, I write 7/2
15:00:00 <monochrom> I salute you.
15:00:01 * hackagebot GPipe 1.3 - A functional graphics API for programmable GPUs  http://hackage.haskell.org/package/GPipe-1.3 (TobiasBexelius)
15:00:16 <chrisdone> preview support is definitely something most paste bins lack for some reason
15:00:33 <monochrom> preview is important.
15:00:39 <ddarius> dolio: We can start merging some, 3 = mappend 3
15:01:05 <ddarius> Every form submittal thing should have a preview function.
15:01:18 <chrisdone> indeed
15:01:41 <dafis> Now, where'd be the suspense in that?
15:01:57 <dmhouse> :t mappend
15:01:58 <lambdabot> forall a. (Monoid a) => a -> a -> a
15:02:09 <monochrom> irc clients should also have preview, and compulsory. you have to press enter 3 times to submit a line.
15:02:25 <dafis> w
15:02:26 <dafis> h
15:02:27 <dafis> y
15:02:28 <chrisdone> monochrom: HTATS STUDPI
15:02:29 <dmhouse> ddarius: wouldn't that be an ambiguous type variable error?
15:02:57 <ddarius> dmhouse: I don't think so.
15:05:11 <dmhouse> +
15:05:13 <dmhouse> 3
15:05:18 <dmhouse> Oops, ignore that
15:05:27 <dmhouse> Hmm, IRC should really have a preview function
15:05:42 <Entroacceptor> as if you would use it
15:06:11 <aristid> dmhouse: some clients allow building up a message of more than one line which can be sent in one go when you've completed it
15:06:28 <megajosh2>  
15:09:42 <monochrom> hehehe, see? :)
15:12:57 <ray> irc should require you to print out every line you say before you can send it to irc
15:13:36 <dafis> ray, that would be idc, not irc
15:13:43 <monochrom> hahaha
15:13:46 <dmhouse> Anyone know of a command-line calendar app that will allow me to type stuff like "cal june"? I.e. one that actually has a useful interface?
15:14:30 <monochrom> I think the conventional unix "calendar" program does that?
15:15:10 <dmhouse> ~ $ calendar june
15:15:10 <dmhouse> usage: calendar [-ab] [-A num] [-B num] [-l num] [-w num][-f calendarfile] [-t [[[cc]yy][mm]]dd
15:15:27 <dmhouse> I am averse to typing in numbers for months
15:15:37 <monochrom> two programs, "cal" and "calendar". "cal" shows a month. "calendar" is for you to jot down important dates in a file and it reminds you.
15:16:08 <megajosh2>    September 2010   
15:16:08 <megajosh2> Su Mo Tu We Th Fr Sa
15:16:08 <megajosh2>           1  2  3  4
15:16:08 <megajosh2>  5  6  7  8  9 10 11
15:16:08 <megajosh2> 12 13 14 15 16 17 18
15:16:11 <megajosh2> 19 20 21 22 23 24 25
15:16:13 <megajosh2> 26 27 28 29 30
15:16:22 <monochrom> "cal june 2010"
15:16:23 <megajosh2> The day is inverted
15:16:36 <megajosh2> Also you have to use numbers
15:16:45 <monochrom> I am sorry if you resent typing in 2010
15:16:47 <joyfulgirl> dmhouse: `cal 10 2010' will print a calendar for October of this year
15:16:47 <megajosh2> I think
15:16:50 <dmhouse> Okay, "cal june 2010" isn't too awful
15:16:56 <dmhouse> I can write a quick wrapper around that
15:19:35 <chrisdone> who's coming to belhac?
15:25:09 * hackagebot GPipe-Collada 0.1.1 - Load GPipe meshes from Collada files  http://hackage.haskell.org/package/GPipe-Collada-0.1.1 (TobiasBexelius)
15:26:50 <chrisdone> no one? ;_;
15:27:18 <chrisdone> I'll bring cake
15:27:22 <fxr> :(
15:27:28 <Entroacceptor> I'd like cake
15:27:37 <Entroacceptor> but I don't even know what belhac is
15:27:48 <chrisdone> the hackathon in belgium!
15:28:02 <chrisdone> @google ghent belhac
15:28:03 <lambdabot> http://www.haskell.org/haskellwiki/Ghent_Functional_Programming_Group/BelHac
15:28:04 <lambdabot> Title: Ghent Functional Programming Group/BelHac - HaskellWiki
15:32:58 * chrisdone raves
15:33:23 <chrisdone> where's all the european haskellers up in this?
15:34:14 <Martty> theyre struggling in #c and #c++
15:34:15 <Botje> i have no haskell stuff to hack :'(
15:34:29 <chrisdone> It is open to all -- you do not have to be a Haskell guru to attend. All you need is a basic knowledge of Haskell, a willingness to learn, and a project you're excited to help with (or a project of your own to work on).
15:36:43 <Botje> hmm, if you put it that way :-)
15:36:47 <Saizan_> and a willingness to go :)
15:37:25 <chrisdone> Saizan_: coming? :D
15:40:12 <Saizan_> i don't think so, atm
15:40:54 <chrisdone> if you come to belhac I'll buy a dinner jacket and wear it throughout the conference
15:41:31 <Saizan_> why?:D
15:41:46 <chrisdone> I dunno :p
15:42:45 <chrisdone> I was thinking it would be nice to have a haskell DSL for jquery
15:42:54 <zenzike> I'm playing with Hakyll and want to try to automatically prepend the date from a tag to the URL of a HakyllAction. Does anyone know if this might be possible?
15:43:01 <chrisdone> sort of one level above javascript
15:43:13 <chrisdone> ermm
15:43:45 <djahandarie> Hmm, a Haskell DSL for jQuery
15:43:58 <djahandarie> That might make jQuery actually tolerable
15:44:04 * djahandarie is not a jQuery fan
15:44:10 <chrisdone> zenzike: let me install hakyll, I use it for my blog but haven't done much with it
15:44:16 <magicman> Ghent? *looks*
15:44:57 <zenzike> chrisdone: I don't think the problem is trivial, it involves pulling information out of arrows in a wierd way
15:47:30 <revenantphx> DSL?
15:47:31 <chrisdone> djahandarie: I think it's a nice layer ontop of js for simple cross-browser scripts. it doesn't work for big systems but ideally you would use a higher level language and abstract away from javascript altogether for a big system anyway
15:47:37 <chrisdone> revenantphx: domain-specific language
15:47:46 <chrisdone> like SQL
15:47:52 <revenantphx> ah ok.
15:48:04 <revenantphx> jquery is nice for simple scripts, yes.
15:48:26 <revenantphx> I want to try Objective-J one of these days
15:48:47 <chrisdone> a la cappuchino framework?
15:49:16 <chrisdone> woops, cappuccino, damn italians :p
15:49:18 <revenantphx> yeah.
15:49:22 <revenantphx> haha
15:49:36 <revenantphx> 280 slides is pretty damn nice XD
15:50:01 <revenantphx> I mean, image loading could use some work, but THAT'S an example of a web app imo
15:50:20 <chrisdone> what are you talking about?
15:50:44 <revenantphx> http://280slides.com/Editor/
15:51:22 <chrisdone> revenantphx: nice!
15:51:38 <revenantphx> It's a really cool webapp someone made with cappuccino
15:52:01 <chrisdone> yah
15:52:09 <revenantphx> anothet good one
15:52:10 <revenantphx> http://githubissues.heroku.com/
15:52:20 <chrisdone> I discovered cappuccino from one of those wireframe creators
15:53:31 <revenantphx> yeah, mockingbird
15:53:36 <revenantphx> cappuccino is a nice idea
15:53:50 <chrisdone> same as the google java layer
15:54:03 <chrisdone> so yeah I want to make a haskell layer
15:54:06 <revenantphx> GWT?
15:54:11 <chrisdone> yeah
15:54:13 <revenantphx> ooh, functional web page design?
15:54:17 <revenantphx> sounds fun :O
15:54:52 <djahandarie> I wish that Haskell->JS compiler was done as part of GHC
15:54:57 <djahandarie> That way it wouldn't be as likely to bitrot
15:55:21 <revenantphx> mm
15:55:59 <chrisdone> but I think you can get away with a lot in a GUI by being purely declarative
15:56:19 <chrisdone> so you don't need to actually compile haskell code to javascript, just output javascript or marginally clever templates
15:56:51 <djahandarie> Yeah, but a compiler would be even cooler ;)
15:57:05 <revenantphx> so do you want to do something like cappuccino that's server side?
15:57:09 <revenantphx> er, client
15:57:10 <hpc> it would produce hideous javascript though
15:57:16 <revenantphx> or something like ASP/JSP that's server side?
15:57:47 <chrisdone> it'd need to be a bit of both 
15:58:11 <chrisdone> server side for database access of course
15:58:40 <chrisdone> but maybe you could encode a lot of business logic into the client-side declaratively
15:59:40 <chrisdone> haskelldb has a nice dsl ontop of sql, you write stuff like:
15:59:41 <chrisdone> do r <- table mytable
15:59:41 <chrisdone>    restrict $ r!id .==. constant 1 .&&. r!foo .>. bar
15:59:41 <chrisdone>    return r
16:00:15 <chrisdone> and this outputs to the server:
16:00:15 <chrisdone> SELECT * FROM `mytable` WHERE `mytable`.`id` = 1 AND `mytable`.`foo` > 1
16:00:28 <chrisdone> er, whatever bar is
16:01:26 <Martty> looks like brainfuckSQL
16:02:25 <chrisdone> if you redefine the Eq and Ord classes then you can write:
16:02:26 <chrisdone> r!id == constant 1 && r!foo > bar
16:03:16 <aristid> :t (!)
16:03:17 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
16:03:18 <chrisdone> see the AwesomePrelude from utrecht http://github.com/tomlokhorst/AwesomePrelude
16:03:30 <aristid> chrisdone: r!id? what is (!) there?
16:03:52 <chrisdone> ! is just table!column lookup
16:04:23 <chrisdone> needless to say this AwesomePrelude is pretty awesome
16:05:58 <chrisdone> zenzike: are you using readTagMap?
16:06:06 <x2b> hello everyone, I am just trying to implement some geometric algorithms in haskell. I wrote a type Point, representing a point in the plane. I would like to be able to add points using "+", but I cant define a function because that would be "ambiguous". What can I do about that?
16:06:44 <chrisdone> can you implement a Num instance?
16:07:18 <luite> how would you multiply two points?
16:07:22 <x2b> well, I need to add vectors and have a scalar product, so Vector -> Vector -> Float. 
16:07:24 <zenzike> chrisdone: That would only return a HakyllAction () TagMap: I can't see how you'd combine that with a HakyllAction () Context
16:07:37 <chrisdone> x2b: ah so the type wouldn't match
16:08:49 <zenzike> chrisdone: I'm guessing I'd have to use changeUrl, but the problem is constructing the (String -> String) from a tagmap
16:08:53 <chrisdone> zenzike: the TagMap does contain Contexts, but.. what are you trying to do? I don't understand the original message
16:08:58 <x2b> exactly. I need a scalar product, but not a multiplication that returns a vector
16:09:34 <zenzike> chrisdone: I have a tag called "date" in my posts, and I'd like the contents of the date tag for each post to be prepended to the beginning of the generated URL
16:10:08 <luite> x2b: it may be better not to abuse Num for that, you may want to look at the vector-space package on hackage for example
16:10:28 <zenzike> chrisdone: for example, if I have an article called foo.hs and inside that fiel there's a tag that says "date: 2009-2-23", then I'd like the resulting URL to look something like 2009-2-23-foo.html
16:10:41 <chrisdone> e.g. http://example.com/blog/date-2010-09-18-fryer-tuck.html ?
16:10:51 <chrisdone> ah
16:11:35 <chrisdone> yeah, I was thinking of different type of tags. you're talking about the meta data. hmm
16:11:44 <x2b> well, I already have a lot of code using  my "Point" class, I would not want to rewrite that. Im just lazy, I got a function "add" but it would be convenient to just write "+". I dont want to work with some huge library
16:11:46 <zenzike> when I say tag, I think I mean meta data yeah
16:11:51 <zenzike> sorry :$
16:12:42 <chrisdone> hrm
16:12:48 <zenzike> The annoying thing is that all the data is sitting in the Context part of a HakyllAction, it's just that I can't get hold of it for use :-)
16:12:50 <luite> x2b: you could do something like Point a => VectorSpace a where
16:14:46 <x2b> To be quite honest, I dont really understand the problem, I want a binary function with infix notation. I dont think it is ambiguous to have + defined for multiple data types. I mean, you can overload functions in imperative languages, why not in haskell?
16:14:50 <chrisdone> zenzike: hmm nothing in here can help? http://hackage.haskell.org/packages/archive/hakyll/2.3/doc/html/Text-Hakyll-ContextManipulations.html
16:15:14 <luite> x2b: + is part of the Num class, so you have to implement an instance of Num if you want to use it
16:15:23 <luite> either that, or use some nonstandard Prelude
16:15:34 <dafis> x2b: you can define e.g. (<+>) to add two points
16:15:35 <chrisdone> zenzike: you have changeUrl but you need the meta data. BUT renderValue could technically access that meta data and then change the url. but I swear there was a more general function that gave you the whole assocation list
16:17:10 <tehgeekmeister_> how would i remove every other newline from a file?
16:17:15 <zenzike> chrisdone: I thought about that approach, but it seems that because we're constructing an arrow, using arr $ Context \context -> Context ...$ ,the information in context can't be used outside the lambda expression
16:17:21 <dafis> filter (/= '\n')
16:17:33 <tehgeekmeister_> dafis: every other
16:17:37 <dafis> sorry, overlooked 'every other'
16:17:42 <zenzike> chrisdone: therefore I can't use it to change the value of the action in the arrow itself outside of that context
16:18:10 <dafis> unlines . map concat . splits 2 . lines
16:18:10 <zenzike> chrisdone: (since context is out of scope at that point)
16:18:27 <chrisdone> zenzike: and what of renderValue?
16:18:51 <zenzike> chrisdone: renderValue just constructs an arr, which is the same approach
16:19:22 <chrisdone> but it modifies the context?
16:19:39 <zenzike> ie, it can be used to change things within the context, but not to extract data from the context to a scope outside of the arrow's arguments
16:20:59 <tehgeekmeister_> dafis: oooh!  didn't know about splits.
16:21:02 <zenzike> basically, renderValue lets you create a new key in the context, but it doesn't let you access the data that's in the key.  data can only be accessed once the HakyllAction is executed, by which time it's all too late :-)
16:21:16 <tehgeekmeister_> @hoogle splits
16:21:17 <lambdabot> System.FilePath.Posix splitSearchPath :: String -> [FilePath]
16:21:17 <lambdabot> System.FilePath.Windows splitSearchPath :: String -> [FilePath]
16:21:18 <zenzike> (thanks for the ideas btw, I've just thought about this for a while!)
16:21:26 <tehgeekmeister_> dafis: apparently hoogle doesn't either.  =/
16:22:41 <dafis> tehgeekmeister_: I don't think it's called thus, but I think such a function should be in the splits package, otherwise, splits k = unfoldr (\xs -> case xs of [] -> Nothing; _ -> Just (splitAt k xs))
16:23:17 <dafis> @hoogle Int -> [a] -> [[a]]
16:23:18 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
16:23:18 <lambdabot> Prelude drop :: Int -> [a] -> [a]
16:23:18 <lambdabot> Prelude take :: Int -> [a] -> [a]
16:24:21 <dafis> tehgeekmeister: http://hackage.haskell.org/packages/archive/split/0.1.2.1/doc/html/Data-List-Split.html splitEvery
16:24:23 <chrisdone> changeUrl :: (String -> String)            -- ^ Function to change URL with.
16:24:23 <chrisdone>           -> HakyllAction Context Context  -- ^ Resulting action.
16:24:23 <chrisdone> changeUrl f = let action = changeValue "url" f
16:24:23 <chrisdone>               in action {actionUrl = Right $ liftM f}
16:24:34 <chrisdone> maybe you could do something with this? O_o
16:24:43 <tehgeekmeister> whoa, since when is hackage sexy
16:24:48 <chrisdone> I've got to go to bed now, good luck! ciao
16:24:56 <zenzike> chrisdone: thanks :-)
16:25:08 <magicman> ... Thanks for mentioning that, dafis. I end up writing that function for nearly every program I write >_<
16:33:28 <enigmus> Anybody wrote a strict version of Haskell? God! lazyness is hard.
16:33:49 <pikhq> enigmus: It's not hard, just different.
16:34:06 <pikhq> And taking away the non-strict semantics would necessarily change rather a lot of the language.
16:34:51 <dobblego> "hard" is not a property of laziness, but possibly of a user of laziness
16:35:10 <enigmus> pikhq: Sure, I was not really suggesting that. But it is hard. A single ! somewhere makes the difference between impossible to localize crash (ghci :trace doesn't scale) and program that works fine.
16:35:34 <pikhq> Okay, that actually is legitimately difficult.
16:35:43 <enigmus> Even in terms of code review that's difficult: better be awake.
16:35:57 <pikhq> I'd like to say "just think about it", but... A nice debugger would be nice. :P
16:36:02 <enigmus> Not really complaining about Haskell, though, I like the way to think about it.
16:36:18 <enigmus> But yeah, better tools would be great.
16:36:43 <pikhq> (not that a debugger is impossible for Haskell or anything. It's just a bit harder to get one that's useful than for an imperative language.)
16:36:47 <benmachine> dobblego: oo-er
16:37:07 <dobblego> I wonder what that means
16:37:29 <benmachine> nothing!
16:38:51 <enigmus> pikhq: I envision a future where profiling event logs would be used for tracing, possibly with some dtrace/systemtap/oprofile thrown in for good measure. With dynamic visualization.
16:39:33 <pikhq> I'm imagining a debugger based around visualising the graph reduction of the program.
16:40:50 <enigmus> pikhq: Yeah. In the docs for ghci, there is the assertion that a lexical stacktrace would be useful. But I'm not so sure: the graph of the reduction seems more useful.
16:41:33 <pikhq> And it'd certainly be neat-looking.
16:41:34 <pikhq> :)
16:42:49 <enigmus> Anybody knows whether the current event log mechanism in ghc can support that?
16:50:28 <magicman> It'd be awesome if you could hook up some visualisation-tool like vacuum to the individual reduction steps.
16:51:47 <magicman> Or whichever the actual visualisation was... *searches*
16:54:20 <enigmus> magicman: http://hackage.haskell.org/package/vacuum ?
16:55:00 <magicman> Yeah, that's the underlying library...
16:55:24 <magicman> I'm thinking of that thing that made a neat 3D-looking visualisation that sprouted a bunch of youtube videos back then.
16:56:58 <magicman> Ah, there's vacuum-* packages that do the drawing stuff.
16:56:58 <Saizan> vacuum-cairo? it wasn't 3D though
16:57:30 <magicman> vaccum-ubigraph looks like what I meant :)
16:58:10 <magicman> But to step through evaluation with such a thing? Dunno how useful it'd be, but it'd sure look awesome :P
16:58:27 <ManateeLazyCat> @hoogle vaccum-ubigraph
16:58:28 <lambdabot> No results found
16:58:34 <ManateeLazyCat> @package vaccum-ubigraph
16:58:35 <lambdabot> http://hackage.haskell.org/package/vaccum-ubigraph
16:58:46 <ManateeLazyCat> @package vaccum-cairo
16:58:47 <lambdabot> http://hackage.haskell.org/package/vaccum-cairo
17:00:09 <drbean> @package vacuum-cairo
17:00:09 <lambdabot> http://hackage.haskell.org/package/vacuum-cairo
17:00:33 <ManateeLazyCat> Why vacuum-cairo still haven't fix bug?
17:01:17 <chemuduguntar> whats vaccum
17:01:47 <ManateeIrcClient> Morning all! :)
17:07:10 <magicman> chemuduguntar: A library for visualising the shape of the run-time heap.
17:07:26 <magicman> http://www.youtube.com/watch?v=3mMH1cHWB6c <- video of the vacuum-ubigraph library in action. Rather neat.
17:08:35 <chemuduguntar> cool
17:17:16 <c_wraith> The one thing vacuum doesn't do, that I wish it did, is show you what references are being held in closers for unevaluated thunks
17:17:22 <c_wraith> err, closures
17:17:26 <c_wraith> I speak english, really
17:17:55 <c_wraith> If it did that, it would be a terrific tool for visualizing common kinds of space leaks
17:18:02 <Saizan> yeah
17:30:57 <reorg> is HaskellDB the best library for interacting with databases?
17:32:04 <reorg> if so, how do you do create index with haskellDB?
17:32:07 <c_wraith> I use HDBC.  It's pretty primitive, but that's fine.
17:49:46 <ccasin> is there any way to compile haskell applications for the android?
17:50:42 <Cale> ccasin: kmc is working on that
17:51:14 <ManateeLazyCat> Nice, there have many binding to notify APIs.
17:54:22 <ccasin> Cale: cool.  I suppose one must port the RTS, which is surely a lot of work
18:20:14 <ezyang> Does GHC give me any way to get the file+line of the function that's calling me? 
18:26:24 * hackagebot notmuch-haskell 0.2.2 - Binding for notmuch MUA library  http://hackage.haskell.org/package/notmuch-haskell-0.2.2 (BartonMassey)
18:28:37 <thierry`> hi, I was wondering if there was a way to add a 'let' in a guard
18:29:47 <LolRat> > case () of _ | let x = 1, x + x == 2 = "thierry`"
18:29:48 <lambdabot>   <no location info>: parse error on input `='
18:30:05 <LolRat> > case () of _ | let x = 1, x + x == 2 -> "thierry`"
18:30:06 <lambdabot>   "thierry`"
18:30:33 <ezyang> thierry: You can do a guard in a case expression. 
18:31:21 <ManateeLazyCat> Wow, notmuch binding, that's i plan to do, sweet now. :)
18:31:30 <LolRat> ezyang: if you are assert, maybe
18:31:56 <LolRat> specifically assert False ...
18:32:07 <ezyang> @src assert 
18:32:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:33:22 <LolRat> it gets rewritten to include a line number
18:33:24 <ezyang> LolRat: Oh, assert was the one that was special-cased. 
18:33:48 <LolRat> I dunno if it's better at happening when people call your code than using CPP or TH
18:33:53 * gwern feels nostalgic at seeing a csh.rit.edu host
18:34:21 * LolRat feels nostalgic at seeing a gwern
18:34:46 <gwern> LolRat: the proper singular is 'gwer'; as in, one gwer, many gwern
18:35:11 <LolRat> how many are you?
18:36:06 <gwern> LolRat: the pack can usually support a good 5 or 7; 2 or 3 and the gwern is crippled
18:36:28 <gwern> past 9, coordination problems cause devolution; ultrasound doesn't convey enough
18:38:02 <benmachine> do you argue over the keyboard?
18:38:32 <gwern> we usually designate 2 to exclusively man the keyboard and a third for the mouse
18:38:46 <gwern> as a hivemind there aren't really arguments per se
18:42:44 <fizruk> hi! this code -- http://hpaste.org/30167 -- provides warning and I can't get why (
18:43:46 <ski> mm_freak : actually, rather `forall r. r -> (a -> r -> r) -> r', than `r -> (a -> r -> r) -> r'
18:44:00 * gwern is entertained by seeing overlapping matches warning for a single match and looks forward to the explanation
18:44:13 <fizruk> =)
18:44:49 <benmachine> hahaha
18:44:51 <benmachine> nice
18:44:59 <ezyang> Oh man viewpatterns 
18:45:37 <lispy> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
18:46:04 <ski> fizruk : that sounds strange, yes. report it ?
18:47:10 * ski imagines possibly the view-pattern desugars to a pattern-match with a default case, which causes the warning, in GHC .. still, the warning is inappropriate here, imo
18:47:46 * ezyang doesn't get a warning... 
18:47:50 <ezyang> What version of GHC? 
18:48:08 <fizruk> 6.10.4
18:48:09 <LolRat> fizruk: what ghc version? 6.10 didn't check exhastiveness for those
18:48:15 * lispy can't find anything on the wiki page that looks like the warning
18:48:21 <ezyang> try 6.12. 
18:49:19 <lispy> ezyang: how's it going?  Start school yet?
18:49:42 <ski> mm_freak : so, if you want to write functions interconverting, they should have types `forall a. [a] -> (forall o. o -> (a -> o -> o) -> o)' (i.e. `forall a o. [a] -> o -> (a -> o -> o) -> o') and `forall a. (forall o. o -> (a -> o -> o) -> o) -> [a]'
18:49:57 <LolRat> lispy: rather than not reporting nothing, ghc devs decided to report all view patterns as not exhaustive
18:50:05 <ezyang> lispy: Going well. School doesn't start for another two weeks :^) 
18:50:24 <ski> (mm_freak : if you want, you could flip the order of the `o' and `a -> o -> o' argument types .. it doesn't matter that much)
18:50:42 <lispy> ezyang: oh, are you hacking on anything fun in the meantime?
18:50:49 <lispy> LolRat: that does sound exhausting
18:50:57 <ezyang> lispy: I'm waiting for GHC to compile :^) 
18:52:13 <poincare101> Hello everyone. I was just wondering if functional languages are inherentently more memory intensive than imperative ones (please don't kill me). I think so because imperative languages can use a variable more than once, however, in functional programming, a variable is actually a constant. And recursion, takes up space for the EBP pointer everytime you have a loop. Would this be true?
18:52:43 <co_dh> what device are you programming on ? 
18:52:54 <lispy> poincare101: there are more things to consider.  With immutability comes opportunities for cunning sharing at run-time
18:52:56 <ezyang> poincare101: It's true that functional languages don't map well onto traditional hardware. 
18:53:07 <ezyang> But that's why we have sufficiently smart compilers :-) 
18:53:24 <megajosh2> Don't a lot of "new" values that modify old ones use memory from the old value?
18:53:47 <lispy> poincare101: have you read any papers by Simon Peyton-Jones about implementing functional languages?  Perhaps the STG machine?
18:54:02 <lispy> megajosh2: yes, this is sharing
18:54:06 <poincare101> lispy: sorry, too stupid for that :) 
18:54:27 <poincare101> I'm more of a mathy person, so I don't get the extremely theoretical stuff in CS. I do try though.
18:54:28 <lispy> poincare101: i know a way you can get smarter :)
18:55:01 <LolRat> hearsay about strict immutable languages being asymptotically slower sometimes?
18:56:02 <poincare101> lispy: yeah, by reading the papers.
18:56:08 <LolRat> someting of the sort being cited in Chris Okasaki's book
18:57:19 <dolio> @google More-Haste-Less-Speed
18:57:21 <lambdabot> http://www.usingenglish.com/reference/idioms/more+haste,+less+speed.html
18:57:21 <lambdabot> Title: More haste, less speed - Idiom Definition - UsingEnglish.com
18:57:39 <dolio> Well, that's wrong.
18:57:55 <kmc> poincare101, the statement that recursion takes space for a stack frame with each call is not true of properly implemented tail recursion
18:58:09 <kmc> the situation is more complicated in Haskell, but Haskell is not a typical functional language
18:58:21 <lispy> poincare101: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
18:58:43 <kmc> poincare101, also every real-world functional language lets you program with in-place mutable variables if you really need to
18:59:51 <kmc> Haskell's ST is a nice implementation of this
19:00:20 <kmc> you can program with in-place update; then the type system will verify that your updates form a closed isolated world, and let you use that computation as a pure value
19:01:25 <kmc> also isn't "the extremely theoretical stuff in CS" basically math?
19:01:40 <kmc> i wouldn't consider the STG machine to be theoretical CS
19:01:47 <fizruk> what are those Data and Typeable (and even more strange Typeable1) typeclasses?
19:02:08 <Cale> fizruk: An implementation of reflection of sorts.
19:02:11 <kmc> fizruk, read the Scrap your Boilerplate papers
19:02:24 <kmc> Typeable is pretty simple; it lets you get type information at runtime, and do runtime type-safe casts
19:02:36 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Typeable.html says most of what you need to do
19:02:45 <kmc> Data is quite complex; reading the SYB papers is advised
19:02:49 <LolRat> safety depends on your instances
19:03:12 <kmc> yeah; you should never write a Typeable instance by hand unless you have a damn good reason
19:03:17 <kmc> GHC can derive them and that's much safer
19:03:38 <kmc> Typeable1 is just Typeable for types of kind ∗ → ∗
19:03:59 <kmc> since neither standard Haskell nor GHC implements kind polymorphism for classes
19:04:01 <kmc> (but UHC does)
19:04:11 <poincare101> wow, weather forcasters and TIOBE index people have a real right to lie.
19:04:22 <poincare101> look where Haskell lies in the TIOBE and look at this channel size!
19:04:22 <fizruk> kmc: oh, thanks, my mind becomes clear )
19:04:45 <LolRat> @quote phd
19:04:46 <lambdabot> HaskellLove says: your Phd supervisor is my uncle, watch out !
19:06:16 <Cale> poincare101: It's been shown that there are problems that can be solved in an imperative language with lower asymptotic time complexity than a functional language under strict evaluation, but whether this applies to lazy evaluation is another thing. The counterexample provided by that Pippenger's paper was shown to break down once lazy evaluation was available.
19:06:26 * ezyang is currently unable to do any deep thinking 
19:06:31 <LolRat> kmc: so only one Typeable class would be necessary in UHC? How would you disambiguate whether you  "Maybe Int" or just "Maybe" for   typeOf (Just 1) ?
19:06:40 <kmc> LolRat, i'm not sure
19:06:56 <kmc> but note that «typeOf1 :: t a → TypeRep»
19:07:07 <kmc> hmm
19:07:10 <ezyang> Cale: If I understand correctly, you can think of laziness as a form of "controlled mutation"? 
19:07:11 <kmc> right but it only returns 'Maybe'
19:07:15 <kmc> > typeOf1 (Just 'x')
19:07:15 <Cale> ezyang: yeah
19:07:16 <lambdabot>   Maybe
19:08:29 <kmc> i feel like there's a lack of tool support for tracking down laziness-related space leaks
19:08:35 <kmc> or maybe i'm just unaware of what's out there
19:08:43 <Cale> I think it's an open question still whether there are really any problems solvable with lower asymptotic complexity using mutation rather than using pure lazy evaluation.
19:09:11 <Cale> Practically speaking though, there's an occasional log factor performance hit.
19:09:47 <dolio> kmc: I'd expect typeOf to have a different type.
19:09:54 <dolio> typeOf :: TypeRep t, perhaps.
19:10:12 <Cale> For *space* usage, I don't think there's any difference asymptotically.
19:10:19 <Cale> But I'm not sure.
19:11:34 <Cale> Well, a Map with n elements takes O(n) space, so you can simulate any imperative mutating algorithm that way.
19:12:17 <ezyang> "but there goes your time complexity" 
19:12:20 <Cale> right
19:12:52 <Cale> Usually we can ignore that log factor for the same reason we think of memory accesses as being O(1).
19:13:24 <kmc> yeah.  it's an interesting theoretical question, but i think it's not too relevant to the practicality of FP
19:13:46 <kmc> because a) empirically, pure functions are usually fast enough, and b) every practical functional language has support for mutation too
19:14:20 <kmc> hi revenantphx :)
19:14:23 <revenantphx> yo
19:14:36 <revenantphx> *sigh*
19:14:50 <revenantphx> as of today, I start the college race.
19:15:11 <kmc> you're a college student now?
19:15:15 <revenantphx> oh no
19:15:19 <revenantphx> I'm a high school junior.
19:15:23 <kmc> aha
19:15:24 <revenantphx> I mean application, preparating, etc
19:15:24 <kmc> good luck :)
19:15:26 <revenantphx> my first choice at the moment is CMU
19:15:27 <kmc> right
19:15:38 <revenantphx> Specifically Carnegie Tech
19:16:05 <kmc> what do you want to study?
19:16:19 <revenantphx> I'm absolutely sure of computer science as a broad topic.
19:16:27 <ezyang> revanantphx: Ah, way ahead of the ball are we ;-) 
19:16:28 <revenantphx> What specifically within that, remains to be seen.
19:16:38 <kmc> well, last i heard CMU was the best for CS
19:16:51 <revenantphx> Yeah, depending on who you ask, its the best, or one of the best
19:16:58 <ymasory> kmc: at the graduate level
19:16:58 <revenantphx> CMU, Caltech, Berkely, MIT
19:17:11 <kmc> i went to Caltech
19:17:14 <kmc> ask me anything you like :)
19:17:25 <revenantphx> Standord isn't bad either.
19:17:36 <ezyang> current MIT student, so you if you have questions there ;-) 
19:17:43 <ymasory> revenantphx: come to Penn. you can have byorgey as a teacher
19:17:52 <kmc> that's pretty cool :)
19:17:58 <kmc> what does he teach?
19:18:00 <revenantphx> U of Penn would be free for me actually, I like here.
19:18:12 <ymasory> he teaches cis194 - Haskell
19:18:13 <revenantphx> If I go to college for free, it'll probably be at Pitt
19:18:25 <kmc> revenantphx, you're in PA now?
19:18:28 <revenantphx> yep.
19:18:31 <revenantphx> Moved here last year.
19:18:35 <ymasory> how would that make Penn free?
19:18:36 <kmc> i think there's significant value in going to school far from home
19:18:43 <kmc> ah, but if you've only been there a year, not  as big a deal
19:18:44 <revenantphx> ymasory, free/cheaper/etc
19:18:52 <revenantphx> kmc: that's the thing.
19:18:57 <revenantphx> CMU is not just close to me.
19:19:04 <revenantphx> It's like... walking distance from me.
19:19:05 <ymasory> hmm i don't follow but if you say so. Penn is private there's no in-state rate
19:19:14 <revenantphx> ymasory: I'm mixing it up, my bad.
19:19:22 <revenantphx> I grew up in Oregon, lived a couple years in Chicago, and now I'm in Pitt.
19:19:32 <ezyang> I think MIT might be a kind of bad place for Haskellers. 
19:19:35 <revenantphx> Portland specifically.
19:19:54 <kmc> Caltech's CS program is small and lacks a lot of important classes
19:20:09 <kmc> they had some profs leave recently
19:20:12 <revenantphx> CMU is my top choice at the moment anyhow.
19:20:21 <kmc> like i think there's still no languages / compilers class :/
19:20:27 <kmc> pity, it was one of my favorites
19:20:30 <revenantphx> aw
19:20:59 <revenantphx> I think when I start college, after the required level courses, I'd like to take a lot of low level nitty gritty subjects, and some high level theory stuff
19:21:00 <ymasory> we have it and never offer it. much better.
19:21:06 <revenantphx> then decide which I prefer.
19:21:23 <revenantphx> At the moment I like them both very much ^_^.
19:21:23 <kmc> revenantphx, breadth is good :)
19:21:29 <kmc> there's actually a lot of breadth in languages
19:21:42 <kmc> because you go all the way from type theory and such to low level compiler optimizations
19:21:53 <revenantphx> kmc, I've worked in C, C++, C#, Objective-C, Python, Ruby, (now Haskell)....
19:22:04 <lispy> languages form the foundation of CS, IMO
19:22:06 <revenantphx> I'm quite aware of the breadth
19:22:24 <Mathnerd314> revenantphx: Prolog? Fortran? Factor/Forth? :p
19:22:33 <revenantphx> Prolog is on my list.
19:22:34 <kmc> revenantphx, that's a different axis than the one i mean
19:22:35 <fizruk> scheme =)
19:22:40 <revenantphx> Scheme I've worked in.
19:22:47 <kmc> i meant that if you're writing GHC, you need to know type theory and also assembly
19:22:51 <revenantphx> I'm reading through SICP right now.
19:22:59 <revenantphx> kmc: mm I see.
19:23:38 <alise> is hscurses or nanocurses better? flamewar begin!
19:23:42 <lispy> computability is where it's at
19:23:44 <revenantphx> uh oh...
19:23:48 <LolRat> kmc: those parts are pretty separate though, no?
19:23:50 <revenantphx> alise, shaddup.
19:23:53 <kmc> cool, i didn't know nanocurses exists
19:24:08 <alise> revenantphx: ha
19:24:08 <kmc> LolRat, yeah.  though it's nice to carry types as far as you can through your compiler
19:24:16 <revenantphx> HEY GUYS
19:24:16 <kmc> so you can type check transformed code
19:24:20 <revenantphx> EMACS OR AN IDE?
19:24:23 <revenantphx> FLAMEWAR GO!
19:24:32 <fizruk> VIM!
19:24:41 <lispy> leksah?
19:24:41 <kmc> "Nanocurses differs from Hscurses and Mage in that it is intended to be portable to Curses libraries other than Ncurses, such as Ocurses, Irix's curses"
19:25:01 <kmc> great for all the haskell code i run on IRIX
19:25:09 <lispy> I thought mage was a rougelike
19:25:45 * revenantphx has an urge to play nethack
19:26:02 <kmc> do people really have editor flamewars
19:26:10 <kmc> or is this just an unfounded stereotypical behavior
19:26:18 <revenantphx> No, it really happens.
19:26:26 <kmc> i haven't seen it much
19:26:27 <revenantphx> I personally use the editor that best suits the job.
19:26:49 <kmc> i use vim for most stuff, i think it's pretty good, i've used emacs and my own editor too, whatevs
19:27:01 <kmc> i do like consistency -- i'm annoyed when i'm forced to use a different editor
19:27:10 <ymasory> kmc: i haven't been in one. around here people start getting dizzy if there's no eclipse installed
19:27:15 <kmc> heh
19:27:20 <ymasory> so there's nothing to debate
19:27:21 <revenantphx> I don't like Eclipse.
19:27:23 <revenantphx> it feels clunky.
19:27:39 <revenantphx> I prefer something like TextMate
19:27:40 <revenantphx> Vim is nioce.
19:27:42 <revenantphx> I liek vim.
19:27:51 <ymasory> i asked my intern to do something trivial the other day in java and he was like "well this is going to take a long time since i'm so used to eclipse"
19:28:10 <revenantphx> ymasory: ... which is why all programming languages SHOULD FIRST be learned in a terminal environment
19:28:13 <revenantphx> BEFORE you start using an IDE.
19:28:31 <revenantphx> At one point I finally convinced my friend to learn C (he's an avid rubyist and doesn't like low level)
19:28:38 <revenantphx> and then one day, I ask him to show me some code
19:28:45 <revenantphx> and he pulls up his IDE off his flash drive and compiles it.
19:29:01 <revenantphx> And I asked him, do you even know how to compile multiple files? Or use the linker?
19:29:07 <revenantphx> And he said no. And then I was sad.
19:29:12 <revenantphx> This story has no happy ending, sadly.
19:29:17 <fizruk> =)
19:29:32 <ezyang> linking is Hard™ 
19:29:34 <ymasory> my own history was Eclipse based, I stopped only when I used languages with weaker IDE features (esp Scala) and for some projects that had such damn complicated build chains that the IDE constrained me too much
19:29:42 <revenantphx> ezyang: makefiles!
19:29:52 <ezyang> make is Hard™ 
19:29:54 <revenantphx> ezyang: plan it all out and script it out incrementally
19:29:54 <alise> revenantphx: you seem a bit romantically attached to existing C/Unix-based systems.
19:29:56 <ezyang> autogoo is Hard™ 
19:30:02 <alise> linking has little relevance to Haskell outside of sticking it to these systems.
19:30:02 <revenantphx> alise: Just a little bit :P
19:30:11 <revenantphx> Oh, this has nothing to do with Haskell.
19:30:14 <alise> precisely.
19:30:18 <revenantphx> ...
19:30:22 <ymasory> sbt is awesome. i'm hoping Haskell has something similar
19:30:42 <lispy> sbt?
19:30:50 <ymasory> simple build tool. for scala
19:30:52 <alise> a scala thing, unless it's a different one
19:30:54 <revenantphx> The scala thing?
19:30:58 <revenantphx> ninja'd
19:31:00 <alise> building in haskell is just "ghc --make Main.hs"
19:31:02 <alise> done
19:31:04 <alise> or cabal :P
19:31:18 <revenantphx> why was the name cabal chosen?
19:31:21 <revenantphx> Is there some joke there?
19:31:32 <fizruk> today my friend got 1Mb error message with his C++ code...
19:31:40 <alise> revenantphx: names are pretty arbitrary
19:31:42 <revenantphx> C++ is horrid.
19:31:42 <alise> "Common Architecture for Building Applications and Libraries"
19:31:47 <revenantphx> alise: Oh I see.
19:31:47 <alise> obvious backronym is obvious
19:31:55 <revenantphx> Mm yeah.
19:32:01 <Mathnerd314> revenantphx: the Haskell Cabal does not exist, and there are no members of it (I think)
19:32:02 <LolRat> you can approach that in haskell
19:32:06 <kmc> having a fancy IDE for Java is important
19:32:09 <LolRat> (the error message length)
19:32:12 <kmc> because there's so much boilerplate to write
19:32:23 <revenantphx> kmc: hehe.
19:32:34 <revenantphx> kmc: I have homework for AP CS in hava actually
19:32:43 <revenantphx> let's see what horrendously easy boring assignment awaits me today.
19:32:52 <lispy> fizruk: yeah, functional dependencies give crazy errors in haskell
19:33:18 <LolRat> you need to involve heterogenous lists, so the types are longer than your code
19:33:24 <revenantphx> http://cl.ly/23960cd23db7a9482c63
19:33:29 <revenantphx> this is... bad
19:33:33 <fizruk> lispy: almost never used them =)
19:33:36 <revenantphx> not fun in any way, shape or form.
19:33:37 <LolRat> and the error messages repeat the type twice
19:34:04 <LolRat> Expected: super long, Inferred: super long nearly the same type
19:35:14 <fizruk> LolRat: i'd like never get such error messages =)
19:35:30 <LolRat> it depends what you're doing
19:35:43 <lispy> 95% of the time, I just look at the line number and go stare at the code
19:35:51 <revenantphx> Mathnerd314: It won't happen, my teacher is a bit annoying.
19:35:59 <lispy> I can usually spot the type error from the code faster than I can spot it from the error
19:36:00 <revenantphx> He wont even let me align variable assignments D:
19:36:18 * LolRat would rather have such errors now, than discover (more quickly) that something goes wrong at runtime
19:36:18 <fizruk> LolRat: m... writing simple compiler for a simple language )
19:40:45 <gwern> nanocurses is more reliable than hscurses as far as the compilation goes, I think
19:40:52 <gwern> although hscurses should be more usable
19:41:32 <fizruk> btw, I've saw some examples using GADTs for AST of an expression. it seemed rather cool, but without variables or function applications. can I use GADT for representing such an expression? Is it reasonable?
19:47:22 <kmc> yes
19:47:46 <fizruk> kmc: can you show some code? =)
19:48:18 <fizruk> kmc: yes to both answers, I suppose?
19:48:21 <kmc> data Exp t where { ...; App :: Exp (a -> b) -> Exp a -> Exp b; Lam :: (Exp a -> Exp b) -> Exp (a -> b) }
19:48:25 <fizruk> *questions
19:49:13 <kmc> this is a HOAS (higher order abstract syntax) representation: an object-language binding form (lambda) is represented by an actual Haskell function over expressions
19:49:21 <kmc> (wrapped in a suitable constructor)
19:50:00 <kmc> there's lots of stuff to read about HOAS and numerous variations and wrinkles that others more well-versed than i can explain
19:50:51 <kmc> if you instead represent your binders with explicit names (or de bruijn indices)
19:50:52 <fizruk> kmc: thanks, I'll read some papers on that)
19:51:00 <kmc> then either you lose some of the type safety provided by GADTs
19:51:12 <kmc> or you have to explicitly represent type contexts in Haskell's type system
19:51:16 <LolRat> how do you pronounce HOAS?
19:51:27 <kmc> i prefer to pronounce PHOAS :)
19:51:59 <ymasory> is there a .ghci file or startup script of some kind?
19:52:08 <kmc> .ghci
19:52:25 <ymasory> thanks
19:52:34 <kmc> in TaPL or such you'll see typing judgements of the form «Γ ⊢ x : τ»; it's this Γ that you have to model in the type system
19:52:34 <ologNation> Does anyone use HasekellForMaths?
19:53:10 <fizruk> kmc: TaPL?
19:53:41 <ymasory> TaPL! another reason to go to Penn.
19:53:54 <ymasory> fizruk: types and programming languages
19:53:57 <fizruk> ymasory: Penn ?
19:53:58 <kmc> @where tapl
19:53:58 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:54:02 <ezyang> Pierce! 
19:54:18 <ymasory> yep, teaches undergrad discrete math and sometimes intro to programming
19:54:51 <ymasory> and grad software foundations in coq. another good book.
19:56:48 <fizruk> lots, lots of books... I'd like to have timestopper)
19:57:58 <diPython> @where money
19:57:59 <lambdabot> I know nothing about money.
19:58:09 <diPython> :-(
19:59:07 <fizruk> ask for a key of flat where money is)
19:59:38 <ymasory> guess my organization system: grok.psych.upenn.edu/books.jpg
20:04:06 <fizruk> a $ b $ c == a $ (b $ c) ?
20:04:32 <ezyang> fizruk: Yes. 
20:04:43 <ezyang> more usefully, a $ b $ c = a . b $ c 
20:05:11 <fizruk> ezyang: oh, right )
20:08:22 <fizruk> if cond then f else g $ some args... looks strange?
20:08:51 <ologNation> I'd like to check out the graph library in HaskellForMaths.  I wonder if anyone can help me
20:09:01 <ologNation> my first guess was cabal-install HaskellForMaths. 
20:09:09 <ologNation> is there a cabal version of apt-cache search? 
20:09:38 <LolRat> ologNation: cabal list
20:11:59 <poincare101> where can I find a good tutorial that explains parsing with haskell? (write yourself a scheme is a bit fast paced for me)
20:12:09 <revenantphx> copumpkin: you on?
20:15:58 <ezyang> One of the annoying things about GHC HEAD is that it's impossible to roll back to earlier versions if the build is broken because other libraries need to be rolled back too, in that case... 
20:16:25 <ezyang> I wonder if darcs-all supports a "gimme what the entire repository looked like at date FOO" 
20:16:36 <next> Is it possible to execute dotty from GHC, i.e., from a program generating Dot output?
20:17:10 <ologNation> LolRat, Thanks. 
20:17:11 <ezyang> next: Yes. 
20:17:33 <ezyang> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html 
20:17:35 <ologNation> poincare101, That's a good question. 
20:18:04 <ologNation> poincare101, Maybe there is a good tutorial on parsing generally which you could follow using haskell. 
20:18:19 <ologNation> poincare101, Do you know about Real World Haskell? 
20:18:25 <next> Thanks ezyang :)
20:25:39 <poincare101> ologNation: does it do parsing?
20:26:33 <ezyang> poincare101: Parsing is one of the many topics covered. 
20:26:43 <ologNation> poincare101, It is an OReilley book on haskell which is very effectively released on line.  It has 20 chapters and certainly (i'm guessing) covers the beginnings of parsing. 
20:27:06 <ologNation> I'm interested in your question personally though, I parse things in haskell sometimes, but I do it rather casually.  
20:27:16 <ologNation> It would be worth a good effort if I could learn how to do it well. 
20:27:53 <ologNation> I wonder if you'd be interested to share about your parsing project. 
20:27:54 <ologNation> ? 
20:31:29 <kmc> ghci's :t doesn't apply/reduce type families
20:31:40 <kmc> what's a good way to get the "normalized" type of something
20:36:40 <ezyang> kmc: I vaguely Oleg had a trick for forcing type normalization 
20:36:45 <ezyang> but I can't find it... 
20:37:09 <LolRat> perhaps if you provoke a type error?
20:40:52 <dan> "1" : "2" : "3"
20:40:57 <dan> oops :/
20:47:06 <djahandarie> Is http://research.microsoft.com down for anyone else?
20:49:08 <Starfire> djahandarie: http://downforeveryoneorjustme.com/
20:49:49 <djahandarie> I don't know how that works, it probably just checks it from one machine
20:49:51 <revenantphx> down for me
20:50:44 <revenantphx> gnight
20:51:13 <kmc> djahandarie, their webserver is frequently broken for only some users
20:51:22 <kmc> i've heard it works better if you use IE on Windows
20:51:27 <djahandarie> lol
20:51:30 <revenantphx> lol
20:51:32 <kmc> but that might be the usual unfounded Microsoft-trashing
20:52:19 <djahandarie> It's not responding to ping and a can't traceroute to it, but they could be blocking that stuff
21:01:17 <monochrom> "connection refused" from my home
21:13:58 <lispy> > "1" : "2" : "3" : []
21:13:58 <lambdabot>   ["1","2","3"]
21:19:19 <mm_freak> ski: i'll use a different approach now…  let me write it, then i'll post it
21:37:17 <bogner> is there a function like (a -> Bool -> (a -> a) -> a) that applies a function to a value if a bool is true, else returns the value?
21:38:05 <bogner> basically \x b f -> if b then f x else x
21:38:15 <bogner> I don't know what to call that
21:38:18 <monochrom> no, but there is maybe
21:38:23 <monochrom> @type maybe
21:38:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:38:46 <monochrom> > "default" length Nothing
21:38:47 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
21:38:47 <lambdabot>         against inferred type ...
21:38:53 <monochrom> > maybe "default" length Nothing
21:38:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:38:54 <lambdabot>         against inferred ty...
21:39:06 <monochrom> oh sorry
21:39:18 <Cale> > maybe length (Just "hello")
21:39:19 <lambdabot>   Couldn't match expected type `a -> [a1] -> GHC.Types.Int'
21:39:20 <lambdabot>         against i...
21:39:24 <Cale> > maybe 0 length (Just "hello")
21:39:25 <lambdabot>   5
21:39:30 <Cale> > maybe 0 length Nothing
21:39:31 <lambdabot>   0
21:40:26 <bogner> I suppose that makes sense
21:40:27 <Cale> > maybe "default" reverse (Just "hello")
21:40:28 <lambdabot>   "olleh"
21:40:34 <Cale> > maybe "default" reverse Nothing
21:40:35 <lambdabot>   "default"
21:46:31 <ymasory> Is there any particular reason drop/take aren't methods of lists, as they are in Scala?
21:47:12 <monochrom> drop/take are methods of lists.
21:47:51 <ymasory> hmm i'm not getting the syntax then nvmnd
21:47:52 <dmwit> "method" is kind of a meaningless term in Haskell
21:47:57 <dmwit> There are no objects.
21:48:04 <dmwit> There is only data and functions.
21:48:05 <LolRat> it's not meaningless: it's used in typeclasses
21:48:16 <dmwit> Yes, okay, fine.
21:48:30 <LolRat> (+) is a method of the Num class
21:48:34 <dmwit> But caveat newbie: Haskell uses the term "class" much differently than most OO languages.
21:48:40 <monochrom> well I do relax the meaning liberally. if a function has type "x -> y -> z -> t", then the function is a method of x, y, and z.
21:49:17 <dmwit> ymasory: Can you point to some syntax you don't understand? We could try to explain it a bit.
21:50:50 <ymasory> dmwit: take 2 [1,2,3,4,5]
21:51:24 <ymasory> well :info does say it's from List, just not used to thinking that way
21:51:24 <monochrom> two parameters. "2" is the first parameter. "[1,2,3,4,5]" is the second parameter.
21:51:38 <dmwit> ymasory: Great. What you've just done is provide the two-argument function "take" with two arguments.
21:51:56 <ymasory> why does the second argument's type provide the function and not the first?
21:52:03 <ymasory> what if Int had take as well?
21:52:10 <dmwit> mu
21:52:15 <dmwit> take is a function with a type.
21:52:20 <dmwit> It's not "from" list or "from" Int.
21:52:32 <monochrom> ah, but the first argument's type provide the function too.  ever heard of multiple dispatch?
21:52:39 <ymasory> oh i see. it just belongs to its module and that's that?
21:52:44 <dmwit> ymasory: exactly
21:52:53 <dmwit> monochrom: Yowch. Are you trying to confuse him? =P
21:52:54 <Cale> Another way to look at it is that you've provided it with one argument, namely 2, and it gives a function as its result which you provide with the list [1,2,3,4,5]
21:53:05 <monochrom> No. OO is trying to confuse him.
21:53:13 <Cale> :t take
21:53:13 <lambdabot> forall a. Int -> [a] -> [a]
21:53:17 <Cale> :t take 2
21:53:17 <lambdabot> forall a. [a] -> [a]
21:53:23 <Cale> :t take 2 [1,2,3,4,5]
21:53:25 <lambdabot> forall t. (Num t) => [t]
21:53:30 <ymasory> yeah this is pretty straightforward, it will take me a few days to shake off the OO syntax
21:54:12 <Cale> words "here is a bunch of words"
21:54:15 <Cale> > words "here is a bunch of words"
21:54:16 <lambdabot>   ["here","is","a","bunch","of","words"]
21:54:21 <Cale> > map (take 2) (words "here is a bunch of words")
21:54:22 <lambdabot>   ["he","is","a","bu","of","wo"]
21:55:33 <Cale> The reason that the numeric parameter comes first is that it's more common to want to chop a bunch of different lists off at the same length, than to want to chop the same list off at a bunch of different lengths
21:56:25 <ymasory> Cale: I think I see. it's what we'd call partial function application in Scala. i'm just getting the hang of things here
21:56:33 <Cale> yeah
21:56:43 <dmwit> It's called that here, too.
21:56:54 <Cale> All functions of multiple parameters in Haskell are curried so as to make partial application easy
21:57:25 <ymasory> yeah I never quite understood what the point in Scala is of having both currying and parameter lists
21:57:55 <Cale> Probably mainly for interfacing with Java, I'd suspect.
21:58:01 <ymasory> as far as i can see they're semantically equivalent since you can partially apply by leaving off parameters in a list of by leaving off an entire parameter list
21:58:10 <ymasory> makes sense
21:58:10 <Cale> Though it wouldn't be too hard to just curry the Java functions too...
21:58:26 <Jonno_FTW> how would I round a number to a certain number of decimal places?
21:58:28 <ymasory> yeah, dunno. maybe there are edge cases where they really are different
21:58:59 <monochrom> parameter list is kept for those who are not ready to take the black pill
21:59:04 <Cale> Jonno_FTW: Multiply by 10^n, round, and then divide (using div) by 10^n
21:59:12 <monochrom> (I'm sorry I'm colour-blind, both pills look black to me)
21:59:19 <Jonno_FTW> Cale: is there a better way?
21:59:44 <dmwit> > printf "%0.2f" 3.45678 :: String
21:59:44 <Cale> I don't know, that's how I'd do it.
21:59:44 <lambdabot>   "3.46"
21:59:50 <dmwit> Ho yes.
21:59:55 <monochrom> yeah I'd printf too :)
22:00:01 <Cale> Heh, you could use printf and read
22:00:10 <Jonno_FTW> hmk
22:00:15 <monochrom> great way to reverse digits too
22:01:56 <monochrom> <euler> how many 4's occur in the factorial of 100? <answer> length . filter ('4'==) . show . prod $ [1..100]
22:04:05 <co_dh> monochrom: that was cool. 
22:04:48 <co_dh> I'm wondering if I should finish all euler problems. I only finish 10 of them now. What can I learn by finish them?
22:04:54 <monochrom> euler numerology problems can be answered by show
22:05:09 <monochrom> you can learn the value of show and printf
22:05:30 <dmwit> Finishing all of them is a hard task. The later ones are much, much harder than the first 10.
22:05:49 <dmwit> (Even if you don't hold yourself to the "code should run in one minute" standard.)
22:06:00 <co_dh> dmwit: but what's the gain to finish Euler problems?
22:06:24 * dmwit shrugs
22:06:30 <dmwit> I couldn't justify it to myself.
22:06:40 <co_dh> me too. 
22:06:45 <dmwit> They're fun, but I eventually just tailed off on solving them for exactly that reason.
22:06:49 <monochrom> you can also confirm the rumour that "<the cool language you use> looks nice but no one uses it except for unreal math problems"
22:07:19 <co_dh> monochrom: lol
22:07:34 <ymasory> monochrom: <the cool language you use> is dying
22:07:48 <monochrom> every language dies
22:08:05 <trinithis> except haskell
22:08:31 <nycoder> hello, i'm wondering if someone can explain to me what the "=<<" does? Can't find an explanation anywhere
22:08:52 <trinithis> flip (>>=)
22:09:00 <nycoder> oh okay, thx
22:34:27 <kmc> @src (=<<)
22:34:27 <lambdabot> f =<< x = x >>= f
22:35:13 <dmwit> Now if only they used a second palindromic character like 'w' or 'v' or something, it would be a perfect mirror image.
22:35:31 <dmwit> v =<< w = w >>= v
22:35:54 <dolio> You don't need to replace the x.
22:36:02 <dmwit> I know.
22:36:17 <dmwit> I did it because "v" and "w" are closer to each other than "v" and "x" are.
22:36:24 <dmwit> aesthetics
22:38:21 <co_dh> lol, you guys are funny. the mirrow thing
22:38:28 <co_dh> mirror
22:38:45 <lispy> mirrow is an interesting misspelling
22:39:25 <co_dh> yep, because I can't distinct "or" by "ow" by sound.
22:39:46 <co_dh> for me , "ror" is the same sound as "row"
22:39:54 <co_dh> are they different?
22:39:59 <lispy> yeah
22:40:37 <co_dh> I can't even  find the difference between light and night .:(
22:46:53 <Cale> L http://en.wikipedia.org/wiki/File:Alveolar_lateral_approximant.ogg
22:46:58 <Cale> N http://en.wikipedia.org/wiki/File:Alveolar_nasal.ogg
22:47:49 <Cale> co_dh: those sounds might help :)
22:48:00 <co_dh> Cale: thanks :)
22:55:12 <Cale> The W in row is usually fairly subtle, but W is normally pronounced like this: http://en.wikipedia.org/wiki/File:Voiced_labio-velar_approximant.ogg and depending on accent, R is normally like this http://en.wikipedia.org/wiki/File:Retroflex_approximant.ogg or http://en.wikipedia.org/wiki/File:Alveolar_approximant.ogg
22:56:28 <co_dh> Cale: thanks, I'll ask some native speaker later. I don't think I can learn it by some ogg files.
22:56:52 <co_dh> the problem is : I might think I pronounce correct even if I'm wrong. 
22:57:44 <Cale> co_dh: Only practicing the pronunciation of one letter at a time will probably produce weird results :)
22:58:02 <lispy> co_dh: may I ask what your native language is?
22:58:05 <Cale> Especially as pronunciation is pretty inconsistent in English.
22:58:10 <co_dh> Chinese.
22:58:28 <lispy> oh I see.  Very different than english
22:58:31 <Cale> Mandarin?
22:58:35 <co_dh> Yes.
22:58:52 <lispy> I would be lost in a tonal language (Thai friends have tried to teach me :)
22:59:11 <co_dh> lispy: yes, that's the first difficulty 
22:59:26 <flippo> Yes?  (Second tone.)
23:00:18 * pikhq thinks Chinese would be really easy to learn how to write, though.
23:00:36 <co_dh> pikhq : are you kiding ? 
23:00:53 <pikhq> co_dh: Well, allow me to give you some context.
23:01:25 <pikhq> co_dh: I've got a reasonable level of skill in Japanese. The *one* thing that trips me up is that the mapping from character to reading is one to many.
23:01:34 <pikhq> So yes, it would be really easy.
23:01:35 <pikhq> :P
23:02:02 <lispy> I've often wondered if the spelling rules in english are similar in complexity to memorizing kanji
23:02:21 <pikhq> lispy: Approximately, I'd say.
23:02:36 <co_dh> lispy: yes, remember words are hard for us.
23:02:53 <Cale> lispy: In my experience, it's about the same. You basically have to memorise things, but just like spellings have common components, so do kanji.
23:02:59 <co_dh> lispy: especially remember thing that you might never need to use in your life :)
23:03:08 <pikhq> Well, except for simplified Chinese. Which, by taking away a lot of the structure of some characters that makes it easier to remember, makes it a bit harder to remember.
23:03:26 <pikhq> (though, granted, simplified Chinese seems a lot easier to write if you can remember it.)
23:03:48 <lispy> co_dh: Yes, spending 1 week in japan I learned to recognized more kanji that I ever did by studying them on my computer
23:03:49 <co_dh> I hope in future we all  spoke Haskell
23:04:16 <lispy> ?faq Can Haskell be used as a universal language?
23:04:17 <lambdabot> The answer is: Yes! Haskell can do that.
23:04:24 <co_dh> lol
23:04:38 <ozamosi> co_dh: if you tried to speak to me in that obfuscated pointfree style, I'd punch you. :P
23:04:57 <pikhq> lispy: I'd say the single most helpful thing is seeing the characters as combinations of other pieces, rather than random strokes on the page.
23:05:08 <co_dh> in fact, I love pointfree, just think them as pipeline ( unix pipe)
23:05:34 <pikhq> (this is only helpful, really, rather than merely obvious practice, because everyone seems to *actually treat them as random strokes on the page*.)
23:05:46 <lispy> co_dh: this tends to work well until there is more than one pipeline involved between the expressions
23:05:50 <ozamosi> I do like it for simple things, but it quickly becomes impossible to parse in anything resembling real time.
23:06:12 <co_dh> lispy: agree. we need visual language for more than one pipeline.
23:07:52 <ozamosi> a visual language? like piet?
23:08:28 <co_dh> http://en.wikipedia.org/wiki/Visual_programming_language
23:08:34 <co_dh> I don't know piet
23:08:46 <dolio> I'm pretty sure it doesn't mean piet.
23:09:22 <dolio> More like something where you draw circuit diagrams.
23:09:46 <ozamosi> co_dh: http://www.dangermouse.net/esoteric/piet/samples.html contains some simple piet programs :)
23:11:00 <co_dh> :)
23:11:04 <dolio> I don't really know how piet works, though. It may well be a very esoteric visual language.
23:11:18 * mgsloan thirds the motion
23:11:34 <mgsloan> pointfree will be truly powerful when we escape one dimensional notations
23:13:05 <co_dh> I have a feeling that there is a relation between point-free and arrows (Control.Arrow)
23:14:18 <mgsloan> yup.  Imagine, for example, taking the arrow combinators, particularly *** and &&&, and making them apply to an n-tuple of functions.
23:14:43 <mgsloan> then have your VPL-on haskell notate this by stacking the functions vertically
23:15:16 <dolio> Arrow notation is the pointful way to program with arrows.
23:15:18 <mgsloan> extend similarly for record types, etc
23:15:32 <dolio> proc x -> e is analogous to \x -> e
23:15:49 <mgsloan> my arrow-fu is rather weak.  I only know the tuples interpretation
23:15:53 <dolio> f -< x is analogous to f x
23:16:42 <dolio> do y <- e is analogous to let y = e
23:19:25 <co_dh> I have full time python experience of about 1 year, and we have to write a lot of unit test for simple thing like to test if a variable is defined, and that's the reason drive me from python to haskell. 
23:20:02 <co_dh> and the reason drive me from c++ to python is : their type system is so bad , that I think static type checking is bad , so I went to dynamic type checking, 
23:20:23 <co_dh> but haskell proved that I'm wrong: static type checking could be correct :)
23:20:27 <kmc> yup
23:20:32 <dolio> Happens a lot.
23:20:44 <kmc> C++ and Java are the straw men of arguments against static typing
23:20:48 <co_dh> the problem now is : I can't find a python job.
23:20:50 <kmc> there's a lot of uninformed blognoise to this effect
23:23:41 <copumpkin> lulz static types suck
23:24:07 <dolio> I just use macros.
23:24:15 <dolio> Macros can do anything.
23:24:17 <dmwit> lulz static macros suck
23:24:58 <dmwit> macros suck, look how bad the C preprocessor is
23:27:09 <Cale> OT: http://www.youtube.com/watch?v=Dae7DdfJ1ts
23:28:38 <juhp_> /join #fedora-haskell
23:28:50 <Cale> (It's a video of some engineers free climbing to the top of a 1786 foot (544.3m) tower.)
23:29:03 <Axman6> old news man :P
23:29:13 <Cale> Yeah, it was around a couple days ago
23:31:39 <dolio> I don't know how people do this.
23:32:53 <ddarius> You just start climbing.
23:33:21 <dolio> I'm afraid of heights.
23:33:24 <copumpkin> yeah, it's terrifying
23:33:31 <copumpkin> especially when he's climbing around those metal flower things
23:35:04 <dmwit> I keep thinking they made it to the top... then they go a bit further.
23:35:21 <dmwit> I would definitely lose my lunch a few times.
23:36:00 <dobblego> I used to fit balustrades to high-rise buildings
23:36:22 <copumpkin> dobblego: is it something you get used to or something that just doesn't bother you to begin with?
23:36:32 <dobblego> I wasn't ever bothered to begin with
23:37:02 <dobblego> sometimes the doors were fitted to units prior to the balustrade, and locked, so you'd have to climb around the outside of the building
23:40:10 <kmc> so i'm using -fwarn-incomplete-patterns, and GHC warns about some missing cases which are actually impossible due to my GADT's constructor types
23:40:38 <dolio> Seems like I had this conversation a few days ago.
23:40:42 <kmc> is there a way to convince it those cases are impossible?
23:40:52 <kmc> i can silence the warning by defining them to ⊥ but that's unsatisfying
23:40:58 <kmc> dolio, maybe with me. i know i've asked here before
23:41:18 <dolio> I don't think the completeness checker knows anything about GADTs.
23:41:25 <dolio> I think it was with copumpkin, actually.
23:41:34 <copumpkin> there's a bug in the trac
23:41:48 <kmc> ok
23:41:49 <kmc> link?
23:41:57 <dolio> copumpkin actually has a weird example, though.
23:42:05 <kmc> (i don't care enough to search it, but if you have it handy i'd like to see.  otherwise don't bother)
23:42:18 <dolio> Where you can write a case where two different GADTs refine the same type in incompatible ways.
23:42:34 <dolio> GHC will complain if you don't write it, but it should probably be a type error.
23:42:39 <dolio> But it isn't.
23:42:58 <kmc> strange
23:43:18 <dolio> Maybe it will be in the new type checker.
23:43:55 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3927#comment:5
23:45:36 <ddarius> dolio: You should do some free climbing and bouldering.  It probably won't make you scared of heights but it will give you something to be much more scared about while you're doing it.
23:46:17 <ddarius> It's a good workout as well.
23:46:57 <copumpkin> doesn't even need to be free :P I had loads of fun fully harnessed
23:47:05 <flippo> And if you are afraid of fire, you should become a volunteer fireman.   And if you are afraid of large dogs, you should get a mastiff.   That makes sense.
23:47:31 * copumpkin is afraid of heights (not cripplingly so, obviously) and enjoyed climbing anyway
23:47:49 <copumpkin> kmc: what's your example?
23:49:06 <kmc> hmm in my case the impossibility is due to lack of a particular type family instance
23:49:10 <kmc> which i guess it can't check for
23:49:10 <Axman6> since joining the SES, my mild fear of heights has become greatly diminished
23:49:15 <kmc> because type families are open
23:49:31 <copumpkin> ah yeah
23:49:33 <ddarius> flippo: You don't need to be very high for climbing to be scary as crap.  Also, most firemen calls are for medical emergencies/accidents, not fires, and I suspect it would be a very reward occupation.
23:50:22 <flippo> ddarius, right, maybe a door needs to be knocked down.
23:50:44 <copumpkin> a meow in a tree
23:51:03 <Axman6> firemen have a pretty awesome job here. they basically get paid to work out
23:51:12 <Axman6> though, they steal all our jobs, which sucks
23:51:21 <kmc> or protesters need to be suppressed with a firehose
23:52:33 <Axman6> suiside [~suiside@unaffiliated/suiside] has quit [Quit: leaving]
23:52:35 <Axman6> ouch
