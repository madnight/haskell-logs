00:00:59 <systemfault> How does that affects a haskell programmer?
00:01:19 <systemfault> I thought that you didn't need to play that game with haskell.
00:06:29 <arcatan> :t fmap
00:06:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:06:55 <arcatan> :t a.p
00:06:55 <lambdabot> Not in scope: `a'
00:06:56 <lambdabot> Not in scope: `p'
00:06:58 <arcatan> :t ap
00:06:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:29:05 <remy_o> @src ap
00:29:05 <lambdabot> ap = liftM2 id
00:56:58 <ddarius> "The TeraByte benchmark is now deprecated because it became essentially the same as MinuteSort."
00:59:10 <pozic> What is the best way to view a profile currently?
00:59:27 <pozic> Is there a fancy graphical tool for example?
01:38:19 <lars9> is there any other type system other than algebraic data type?
01:42:26 <monadic_kid> lars9: what do you mean, an adt doesn't define a type system. Haskell98 has sum types (alebraic data types) produce types (tuples and records), (bounded) parametric polymorphism, ad-hoc polymorphism (overloading), and completely type inferred
01:44:22 <monadic_kid> lars9: and higher-kinded polymorphism, which you can think of as generic generic or template template parameters but a lot more useful
01:48:39 <monadic_kid> lars9: that was suppose to say product types not produce
01:49:21 <lars9> monadic_kid: thanks, let me digg more
01:54:12 <pozic> How can I get a profile report showing library functions? 
01:54:36 <pozic> Including primitive operations like (:), etc. 
01:56:19 <monadic_kid> pozic: there are profiled version of libraries
01:56:36 <monadic_kid> *versions
01:57:23 <monadic_kid> pozic: i think you need to install those first
02:00:56 <pozic> monadic_kid: I compile everything with profiling : True
02:01:09 <pozic> monadic_kid: and I also have the distribution profiling package.
02:01:54 <pozic> Is logict known to be buggy?
02:08:44 <lars9> omg, i always though functor in ocaml is the same as in haskell, but just found they are totally different concepts
02:08:50 <lars9> poor naming
02:09:07 <silbo__> hey ppl
02:09:26 <silbo__> can anyone help me with my qurto game? http://hpaste.org/42552/quarto
02:09:40 <silbo__> i am trying to implement the function mkTree
02:10:24 <monadic_kid> lars9: I don't think there different concepts just different implementations
02:10:49 <monadic_kid> lars9: they are both about Functors in category theory
02:10:58 <monadic_kid> lars9: which is the concept
02:11:25 <lars9> monadic_kid: haskell functor is a typeclass, and ocaml functor is parametric module?
02:11:52 <monadic_kid> lars9: yes but it doesn't mean they don't use the same concept
02:12:46 <pozic> Why doesn't this law hold in logict? ifte x (\y -> return y `mplus` z) z == x `mplus` z
02:14:06 <silbo__> pozic: maybe paste more of your code at hpaste.org
02:14:33 <pozic> silbo__: are you saying that I am misinterpreting my own code?
02:14:48 <pozic> silbo__: it is a logical property, a formal question, either it holds or it doesn't.
02:14:59 <pozic> I think it is a bug in logict making the whole library worthless.
02:15:08 <pozic> I just want to check. 
02:15:33 <silbo__> pozic: ok, I am a beginner myself xD
02:16:05 <monadic_kid> silbo__: mkTree, [(move,tree)] looks wrong, I can only see  a function called move and I can't find anything called tree
02:16:21 <lars9> monadic_kid: in haskell functor is like a 'group' which we can apply some function on, how is parametric module in ML the same as it?
02:16:52 <monadic_kid> lars9: it's a functor on modules
02:16:55 <silbo__> pozic: we learn haskell at school and the teacher gave us a task to write the quarto game
02:17:40 <silbo__> monadic_kid: I know it dosen't eaven compile, but the idea is that it has to build up the whole tree of the game
02:18:01 <silbo__> monadic_kid: I think you know the game quarto right ?
02:18:50 <lars9> monadic_kid: are List, Map a, Maybe, Either a, etc functors in ocaml?
02:19:20 <monadic_kid> silbo__: not really, what problem are you having.
02:19:45 <monadic_kid> lars9: i tink you and I have different understanding of what a concept means
02:20:50 <mux> it seems I fail at self-referential data: http://hpaste.org/42555/dfas
02:20:51 <pozic> lars9: they are both functors on different kinds of mathematical objects.
02:20:59 <silbo__> monadic_kid: the idea is that the move is a figure and position, and I have to find all the move with the current configuration and I don't know how to implement this in haskell
02:21:02 <mux> anyone got an idea why this DFA code doesn't work properly?
02:21:03 <pozic> mux: have you ever done something with logict?
02:21:26 <mux> it's supposed to be the example DFA at http://en.wikipedia.org/wiki/Deterministic_finite_automaton
02:21:29 <mux> pozic: nope
02:21:45 <monadic_kid> lars9: http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf
02:22:08 * hackagebot secure-sockets 1.2.1 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.1 (DavidAnderson)
02:22:36 <mux> I suppose my 'self' function to create transition to the same state doesn't really work
02:24:37 <silbo__> monadic_kid: if you would grade my code, how was it ?
02:24:39 <silbo__> xD
02:24:55 <monadic_kid> silbo__: I think these problems are probably best solved with infinite trees
02:25:24 <silbo__> monadic_kid: ok I found a good example, i think i can do it know
02:25:51 <silbo__> monadic_kid: but any recommendations for improvimg my code quality or was it ok?
02:31:21 <monadic_kid> silbo__: hlint program can give you suggestions and it's quite good at it other than your code alignment is a bit weird there is a semi standard convention written somewhere, don't write explicit recursion on things like lists when there are abstract functions for that. Decompose long actions/functions into a function with a some private local functions in a where clause or let expression
02:32:24 <monadic_kid> silbo__: cabal install hlint
02:36:34 <silbo__> monadic_kid: ok, ill try it
02:39:50 <monadic_kid> silbo__: also sometimes list comprehensions can make your code more elegant, I tend to forget about them often
02:41:03 <silbo__> monadic_kid: ok, ill keep that in mind
02:44:10 <pozic> silbo__: where is your code?
03:05:34 <monadic_kid> i love it when a plan comes together
03:05:49 * monadic_kid puts a cigar in his move with a grin
03:05:55 <monadic_kid> mouth!
03:07:46 <Phyx-> in your move? your poor PS3 motion controller
03:09:01 <monadic_kid> heh
03:13:25 * hackagebot storable-endian 0.2.3 - Storable instances with endianness  http://hackage.haskell.org/package/storable-endian-0.2.3 (EugeneKirpichov)
03:22:43 <dobblego> koala_man!!
03:23:17 <koala_man> dobblego!!
03:23:25 <dobblego> how ya going mate?
03:23:27 <koala_man> merry happies!
03:23:32 <dobblego> weeee!
03:24:17 <koala_man> had a lovely drunken christmas with lots of good food. you?
03:24:31 <dobblego> mine was alright, not drunken
03:25:03 <monadic_kid> is koala_man a reference to ugly americans
03:25:25 <monadic_kid> ?
03:26:04 <monadic_kid> i mean the program
03:26:34 <koala_man> I'm expressing my love of beastiality
03:26:46 <monadic_kid> great for you
03:27:40 <monadic_kid> koala_man: bottom right: http://en.wikipedia.org/wiki/File:UglyAmericans.png
03:28:24 <koala_man> haha, gotta see that
03:30:41 <koala_man> dobblego: did you get any phat loot?
03:44:12 * paolino got to understand GADTs as christmas present
03:59:16 <ddarius> @instances-importing Foreign Storable
03:59:16 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
03:59:23 <ddarius> @instances-importing Foreign.Storable Storable
03:59:23 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
04:01:41 * hackagebot usb 0.6.0.6 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.6 (BasVanDijk)
04:28:40 <Znudzon> Hi all. Cany any one tell me how to get time in picoseconds ? I need this to compare a few algorythms . 
04:30:10 <sipa> if you need that kind of precision, you'll need something to read the timestamp counter in the cpu
04:30:42 <sipa> but even won't have a precision below 1/block_frequency
04:31:03 <arcatan> http://en.wikipedia.org/wiki/Picosecond it takes 330 picoseconds to  add to integers
04:31:12 <arcatan> *two integers
04:31:24 <HugoDaniel> Znudzon: try criterion
04:35:00 <Znudzon> tank you i will try that
04:40:12 <Znudzon> criterion will be perfect :) 
04:44:22 <HugoDaniel> :)
04:44:26 <HugoDaniel> im also a huge fan of it
04:52:01 <phao> Hi. has anyone in here read the "Programming in Haskell" book? I'm reading chapter 8 now... The book defines a Parser type, and then starts talking about operators that can work on the type. The problem is that those operators are language operators ('>>=', '+++' and 'do' are three examples). And when I try to use those operators, as said in the book, ghci complains.
04:53:39 <phao> ghci output: http://ix.io/1lm - source file: http://ix.io/1ln
05:00:26 <phao> anyone?
05:01:50 <BONUS> yeah many people ask about that part
05:02:36 <BONUS> if i recall correctly he omits some stuff that's critical for this to work
05:03:11 <phao> do you know if I can just skip that chapther?
05:03:19 <kaf3ii> phao: i think it is strange that the expected type is [((Char, Char), String)], the same functions is used to generate both the first and the second value in the tuple
05:03:38 <BONUS> phao: well it's actually fun to do but you gotta add some stuff to it
05:03:43 <BONUS> just a sec and i'll show you which stuff
05:04:11 <phao> it's fun... but it's not working... and I have no clue how to make it work
05:04:22 <phao> I'm clueless in haskell, this is the first book I'm reading actually
05:04:51 <BONUS> yeah figuring that out by yourself if you're just reading the book is kind of impossible
05:05:03 <ddarius> http://www.cs.nott.ac.uk/~gmh/errata.html
05:06:13 <pozic> How can I clear all the bits of an instance of Bits efficiently?
05:07:07 <ddarius> pozic: Since it's not mutable, there's not a whole lot of sense in "clearing all the bits."  You want 0.
05:07:34 <pozic> ddarius: the documents even has a clearBit function...
05:07:50 <dschoepe> pozic: shiftR foo (bitSize foo) should work
05:08:02 <pozic> dschoepe: without knowing the bitSize?
05:08:02 <ddarius> pozic: Which clears a -single- bit leaving all the others in the previous state.
05:08:16 <ddarius> dschoepe: Again, that's pointless.
05:08:18 <pozic> ddarius: yes....
05:08:33 <pozic> ddarius: and you didn't answer my question, you only said it didn't make sense.
05:08:37 <pozic> ddarius: the question was fine. 
05:08:44 <dschoepe> ddarius: does a value with all bits set to zero necessarily correspond to 0?
05:08:48 <ddarius> pozic: It helps if you read all that I wrote.
05:09:01 <pozic> ddarius: I did, and I don't think I want 0.
05:09:19 <ddarius> dschoepe: Yes and no.  It's not enforced, but if it doesn't then your instance is going to behave extremely oddly.
05:09:35 <pozic> ddarius: so, it's not enforced, so you are introducing a bug.
05:09:38 <ddarius> dschoepe: Furthermore, if -that- doesn't hold then you have no basis for assuming the shiftR approach will work either.
05:09:58 <pozic> ddarius: that's not true. 
05:10:16 <ddarius> pozic: If you aren't relying on the intended semantics, then you have no basis for achieving what you want at all.
05:10:23 <BONUS> phao: http://hpaste.org/42557/parsing
05:10:30 <BONUS> i think this should be enough to egt you started
05:10:52 <dschoepe> ddarius: okay, good point
05:10:55 <pozic> ddarius: I want to get rid of my DiffArrays for representing a chessboard.
05:11:11 <phao> BONUS, sorry, but what do I do with that code?
05:11:41 <pozic> ddarius: storing everything in an Int64 is likely to be more efficient, but I don't know that.
05:12:08 <pozic> For some reason my library calls are not ending up in my profile, so they are worthless.
05:12:15 <BONUS> phao: you can load it in ghci and then try, say: parse p "abc"
05:12:19 <ddarius> Using an Int64 would definitely be more efficient than treating a DiffArray as a 64 bit integer.
05:12:21 <BONUS> or add your own parsers to it
05:12:28 <phao> right
05:12:30 <phao> thx
05:12:35 <BONUS> you'll see that it has definitions for >>= return and +++
05:12:39 <BONUS> you gotta watch out for one thing though
05:12:43 <BONUS> notice how up it says
05:12:46 <BONUS> newtype Parser a
05:12:51 <BONUS> instead of type Parser a
05:13:03 <phao> what is the difference?
05:13:18 <BONUS> type is just a type synonym, it creates two ways to refer to a type
05:13:42 <phao> like an alias?
05:13:46 <BONUS> so when you have (\inp -> ... something ...) you can refer to it either as Parser a or as String -> [(a,String)] right
05:13:51 <BONUS> but when you have a newtype
05:14:18 <BONUS> it means that you have to explicitly wrap a String -> [(a,String)] value into a Parser a value
05:14:22 <BONUS> by using P
05:14:37 <BONUS> see on line 12 for example, which looks a lot like your my_then
05:15:29 <BONUS> the main difference is that we use P to wrap the (\inp -> ...) lambda function into a Parser a
05:16:39 <phao> right
05:17:22 <BONUS> here's graham hutton's code for the other parsers: http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
05:19:28 <phao> lol
05:19:41 <phao> what is it with all the beginning >
05:19:49 <phao> and english text in the middle of the code, uncommented.
05:19:55 <BONUS> that's a literate haskell file
05:20:01 <BONUS> cause it ends with .lhs
05:20:12 <BONUS> that means that for something to be considered code, it has to start with >
05:20:16 <BONUS> everything else is comments
05:20:29 <phao> right
05:24:55 <foocraft> BONUS, I love your book mang! merry xmas
05:25:26 <BONUS> thanks :D marry xmas to you too
05:26:07 <foocraft> the haskell turn off is when faculty in my school label haskell as "too advanced for undergrad" *sniff*
05:26:29 <foocraft> like..what the hell do they mean by that? (is there an instance where my brain will explode while coding?) :p
05:26:43 <BONUS> haha, too advanced for undergrad
05:26:45 <arcatan> instance Exploding Brain where
05:27:19 <pozic> I don't see what is advanced about Haskell; imho, the compiler stinks if it cannot rewrite a use of DiffArray to something more efficient based on a special case use.
05:28:31 <pozic> Sure, you can write something fast, but if it doesn't solve the practical problem and you still have to rewrite it in another language (possibly mutable Haskell) then there is still a problem.
05:31:20 <zeiris> Ooh, that's a neat trick. This paper I'm reading has a lot of t_subscriptedname variable names in the code... Subscript, rather than camel cased code is directly related to LaTeX style conventions!
05:32:48 <pozic> zeiris: you can also use x i notation. 
05:35:17 <Twey> foocraft: In the process of learning Haskell, we encourage multiple brain-explosions.
05:36:06 <foocraft> nice!
05:36:11 <foocraft> it's not like it didn't happen before :p
05:36:19 <Twey> Heh
05:45:04 <phao> Is there any book, excluding the standard, teaching haskell like K&R teaches C?
05:45:45 <burp> you are asking for a book that teaches C?
05:45:51 <burp> ah no :)
05:45:58 <phao> hehehe
05:45:59 <phao> no
05:46:09 <phao> I'm asking for a book that teaches haskell, but focusing on haskell.
05:46:10 <burp> do you know lyah and rwh?
05:46:30 <phao> I'm reading "Programming in haskell", but the book is more like "using haskell for functional programming"
05:46:43 <phao> the focus isn't quite haskell... it teaches it though...
05:46:49 <burp> @where lyah
05:46:49 <lambdabot> http://www.learnyouahaskell.com/
05:46:52 <burp> @where rwh
05:46:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:51:09 <ddarius> phao: I'm pretty sure the Gentle Introduction has already been recommended to you.
05:51:20 <phao> well
05:51:30 <phao> those books.. I cannot tell because I never READ them
05:51:36 <phao> but they don't seem to actually TEACH haskell
05:51:55 <phao> they look like books teaching enough of haskell to do some stuff
05:52:58 <dschoepe> phao: What do you see as "teaching Haskell" then?
05:52:59 <ddarius> I'm pretty sure RWH is comprehensive for Haskell 98 and goes into several extensions as well, but it certainly isn't as succinct as it could be if that was all it cared about.
05:53:18 <ddarius> phao: At any rate, it still sounds like the Gentle Introduction is pretty close to what you are looking for.
05:53:38 <phao> right..
05:54:46 <phao> dschoepe, I don't know how to explain it very well, but it'd be something like K&R, or SICP
05:55:03 <phao> SICP isn't a scheme guide, but the parts that talk about scheme are quite good
05:55:12 <phao> -guide+book
05:56:01 <phao> I think I just don't like "just knowing enough of a feature to follow the next example on the book"
05:56:30 <phao> I prefer reading something like a reference first, and then reading some book on how to use the language to get something out of it.
05:57:06 <BONUS> phao: dont mean to toot my own horn but LYAH pretty much follows the language and focuses on only small examples to showcase the language features
05:57:40 <phao> right
05:59:09 <ddarius> BONUS: Do you cover irrefutable patterns at all?
05:59:59 <BONUS> ddarius: hmmm, no actually i dont think i do
06:00:24 <BONUS> probably should have added them though
06:01:00 <pozic> phao: there is no real reference for Haskell. 
06:01:19 <Bynbo7> like (\(Just x) -> x)?
06:01:22 <pozic> phao: if you want a reference, use ML. 
06:01:23 <phao> pozic, I'm kinda seeing that.
06:01:41 <pozic> phao: some parts have papers, though.
06:01:50 <Bynbo7> phao: the haskell language report is probably the best we have
06:01:56 <pozic> phao: buggy, worthless papers, but still paper. ;)
06:02:05 <pozic> Yes, the report is quite good.
06:03:21 <phao> well... the good news, for me, is that all those books, except RWH
06:03:25 <phao> are small
06:04:00 <phao> I'm hopping that, if I read them all (three small books won't take much time to finish), I'll get what I want.
06:04:06 <phao> strange name, real world haskell
06:04:14 <phao> Gonna write Wonder Land Haskell someday.
06:04:45 <BONUS> too late i already did haha
06:04:49 <phao> hahaha
06:05:28 <phao> Medieval Fantasy RPG World Haskell: Write Your Own RPG Game in Haskell
06:06:19 * ddarius suspects that if you read all of any -one- of the suggested books, you'll understand most/all of the features of Haskell 98.
06:06:37 <phao> ddarius, you're right
06:06:51 <ddarius> Of course, most of the learning curve of Haskell isn't in the language features.
06:06:56 <phao> That's why I started reading Programming in Haskell
06:07:03 <phao> I'm in chapter 8, which is half of the book I think
06:07:35 <phao> but then, the book starts using stuff it didn't explain
06:07:58 <phao> chapter 8 is pretty much wasted, and others that depend on it.
06:08:21 <arcatan> where have the days of proper tutorials such as Gentle Introduction gone :|
06:08:41 <ddarius> I didn't suggest that reading half of a book would allow you to understand most/all of the features of Haskell 98.
06:08:47 <phao> ddarius, =)
06:08:48 <ddarius> arcatan: I don't know.
06:09:24 <phao> ddarius, I still didn't finish the book, but I suspect that from now on, I won't quite understand what the book teaches because it started using things it didn't explain.
06:09:36 <ddarius> In my opinion, the Gentle Introduction is still one of the best introductions to Haskell available.
06:09:44 <phao> ddarius, I hope you're right
06:09:48 <phao> 66pages
06:09:56 <phao> I love good stuff, MUCH MORE when it's small
06:10:49 <arcatan> ddarius: when i was learning haskell, it also seemed to be the one of the most unhelpful introductions to Haskell available
06:11:21 <arcatan> though i guess if you knew, say, ML, it'd be fine
06:12:38 <pozic> phao: if you love small stuff, learn Forth. 
06:12:50 <ddarius> arcatan: The Gentle Introduction was the first thing I read, and I was pretty happy with it.  I had prior experience with Scheme, CL, and Prolog, but not with an ML.
06:13:14 <pozic> If you can read the Gentle Introduction is fine. 
06:13:19 <pozic> +,
06:13:48 <pozic> Has anyone used logict here before?
06:13:51 <ddarius> If you can't read, I don't think any other book or tutorial will be much help.
06:14:19 <pozic> I did now, but it doesn't seem to generate results lazily.
06:15:30 <arcatan> ddarius: I came from the world of Ruby, PHP and C and didn't understand much about it. By contrast YAHT was much more helpful.
06:22:05 <ddarius> I didn't really like YAHT, but it was like a year or two after I started Haskell that it was reasonably complete.
06:31:26 <NAVEENGF> CHAT ONLINE, PLAY GAME, MAKE MONEY, GO TO http://letikfor.webs.com/
06:31:59 <pozic> I am trying to place queens on a chess board. How can I ignore symmetrical solutions, etc?
06:41:18 <nmkolev> @pl pl \x y -> x y
06:41:19 <lambdabot> (line 1, column 4):
06:41:19 <lambdabot> unexpected "\\"
06:41:19 <lambdabot> expecting variable, "(", operator or end of input
06:41:24 <nmkolev> @pl \x y -> x y
06:41:25 <lambdabot> id
06:48:17 <Znudzon> I have problem with criterion. I've instaled it by cabal and i nothing ... i have "Not in scope: 'bench' :/
06:52:55 <Bynbo7> @check \b1' b2' b3' b4' -> (b4' + (256 * b3') + (256 * 256 * b2') + (256 * 256 * 256 * b1')) == b4' +  256 * (b3' + 256 * (b2' + 256 * b1))
06:52:56 <lambdabot>   Not in scope: `b1'
06:53:03 <Bynbo7> @check \b1' b2' b3' b4' -> (b4' + (256 * b3') + (256 * 256 * b2') + (256 * 256 * 256 * b1')) == b4' +  256 * (b3' + 256 * (b2' + 256 * b1'))
06:53:04 <lambdabot>   "OK, passed 500 tests."
06:53:19 <Bynbo7> @check \b1' b2' b3' b4' -> (b4' + (256 * b3') + (256 * 256 * b2') + (256 * 256 * 256 * b1')) == b4' +  256 * (b3' + 256 * (b2' + 256 * (b1' :: Int)))
06:53:20 <lambdabot>   "OK, passed 500 tests."
06:53:27 <Bynbo7> good
06:54:49 <Bynbo7> @check \b1' b2' b3' b4' -> (b4' + (256 * b3') + (256 * 256 * b2') + (256 * 256 * 256 * b1')) == ((b1 * 256 + b2) * 256 + b3) * 256 + b4
06:54:50 <lambdabot>   Not in scope: `b1'Not in scope: `b2'Not in scope: `b3'Not in scope: `b4'
06:55:08 <Bynbo7> @check \b1' b2' b3' b4' -> (b4' + (256 * b3') + (256 * 256 * b2') + (256 * 256 * 256 * b1')) == ((b1' * 256 + b2') * 256 + b3') * 256 + b4'
06:55:09 <lambdabot>   "OK, passed 500 tests."
07:51:26 <jergus> hello
08:05:50 * hackagebot starling 0.3.0 - A memcached client  http://hackage.haskell.org/package/starling-0.3.0 (AntoineLatter)
08:13:44 <paolino> are irrationals the primes of R ?
08:14:03 <sipa> no
08:15:08 <paolino> ok, too much smoking O_o
08:15:20 <sipa> R is a field
08:15:31 <sipa> you need a non-field ring to have primes
08:17:14 * paolino looks up field
08:22:17 <mm_freak> sipa: can a group have irreducible elements?
08:24:44 <sipa> mm_freak: i don't think so
08:24:55 <sipa> wait
08:31:15 <Cale> mm_freak: What would it mean?
08:31:41 <Cale> I suppose that might be your point :)
08:31:42 <mm_freak> Cale: i'm not sure, but i think it's fairly easy to construct a field from a group
08:32:13 <Cale> Yes.
08:32:20 <Cale> Well...
08:32:40 <Cale> Actually, that's a good question.
08:32:48 <Cale> Which groups are the additive groups of fields?
08:32:55 <mm_freak> if a group can have irreducible elements and my thought is right, then you can indeed have fields with multiplicatively irreducible elements
08:33:22 <Cale> (Or which groups are the unit groups of fields)
08:33:33 <arcatan> mm_freak: how would you define an irreducible element of group?
08:34:22 <Cale> Normally, an element x of a ring is called reducible if there is a factorisation x = a b where neither a nor b is a unit.
08:34:29 <mm_freak> arcatan: an element x is reducible, if there exist elements a and b with a,b ≠ 0 with a+b = x
08:34:31 <Cale> and irreducible otherwise
08:35:26 <Cale> er
08:35:43 <Cale> Actually, I messed that up :)
08:35:46 <mm_freak> but primes are a bit stronger than irreducibles, i think…  they guarantee a unique factorization
08:36:17 <Cale> A nonzero nonunit p is prime if whenever p | ab, then either p | a or p | b
08:36:35 <mm_freak> in every group G with |G| > 1 the identity element has multiple factorizations
08:37:04 <mm_freak> so there can be no group with /prime numbers/, but i think irreducible elements are weaker than primes
08:37:53 <Cale> A nonunit x is irreducible if it's not a product of two nonunits.
08:38:44 <Cale> Every prime is irreducible in an integral domain, but the converse is not always true (but implied by fairly common conditions)
08:40:24 <ddarius> xa and a^-1 will likely not be units but will multiply to x.
08:40:39 <arcatan> does unit mean here irreversible element or identity element?
08:40:50 <Cale> a^-1 had better be a unit...
08:40:53 <sipa> in Z, 1 and -1 are units
08:41:15 <arcatan> by irreversible i meant invertible
08:41:31 <Cale> arcatan: unit means invertible
08:41:32 <sipa> invertiable
08:41:34 <arcatan> yeah
08:41:51 <ddarius> Cale: If we use "unit" here to mean "invertible" then there are no non-units in a group.
08:41:57 <Cale> ddarius: right
08:42:21 <Cale> (Hence my confusion about what people are talking about ;)
08:42:55 <ddarius> Well, without knowing what mm_freak intended I think the question has been answered.
08:42:56 <Cale> Hey, we could publish about irreducible group elements to the Journal of the Empty Set!
08:44:08 <Cale> http://pic.blog.plover.com/math/major-screwups-4/emptyset.png :)
08:44:54 <scree> Don't product groups of fields have unusual properties?
08:45:09 <scree> I think every finite subgroup is cyclic
08:45:28 <scree> (where I mean group of units)
08:46:19 <Cale> and of course, the group of units of a field will be commutative
08:46:51 <mm_freak> the term "unit" is ambiguous
08:47:03 <mm_freak> a lot of literature refers to invertible elements as units
08:47:11 <mm_freak> and to the zeroes/ones as identity elements
08:47:40 <ddarius> Every non-commutative cyclic group contains irreducible elements.
08:47:42 <Cale> What's ambiguous about it?
08:47:59 <gio123> Cale
08:48:12 <mm_freak> Cale: some people refer to identity elements as units
08:48:17 <scree> using the "standard" definition of invertible elements, the group of units of a field is everything except 0
08:48:28 <scree> which is what I meant at any rate
08:48:31 <Cale> scree: right
08:49:27 <arcatan> ddarius: wait, what's irreducible element in a group?
08:49:49 <Cale> Let's make this more interesting: Suppose we have a group G. Can we construct a field or ring whose group of units is isomorphic to G? What are sufficient/necessary conditions for that?
08:50:15 <scree> necessary condition above if I can remember the proof
08:50:25 <Cale> http://www.math.uga.edu/~pete/Dicker1966.pdf -- hmm
08:51:53 <ddarius> arcatan: In that sentence I was using Cale's definitions.
08:52:47 <sipa> if 'reduce' means 'being able to write as multiplication', you need an algebraic structure which defines multiplication, like a field or a ring
08:52:48 <Cale> arcatan: There isn't such a thing. It would have to be a noninvertible element, which doesn't exist in a group.
08:53:33 <mm_freak> scree: ℤ/8ℤ* doesn't seem to be cyclic
08:54:00 <scree> mm_freak: units of a field
08:54:13 <gio123> Cale: hi
08:54:15 <Cale> mm_freak: Z/8Z isn't a field
08:54:18 <Cale> gio123: hi
08:54:22 <mm_freak> ah, ok
08:54:40 <sipa> #math, maybe? :)
08:55:09 <Cale> #haskell is a better #math than #math most of the time ;)
08:55:30 <gio123> Cale: could u see pm?
08:56:08 <Cale> gio123: I did see your pm, it just said 'hi'
08:57:40 <mm_freak> hehe
08:57:59 <mm_freak> #math people flamed me off for using "…" inappropriately
08:58:13 <mm_freak> not in math, but in a normal sentence
08:58:30 <Cale> heh
09:00:21 <tonkman> which one takes more space, big number represented in String or in Integer?
09:00:30 <mm_freak> #haskell and ##crypto are the best math channels i think =)
09:00:30 <mm_freak> tonkman: String
09:01:08 <ddarius> It depends on how you encode the number into the String.
09:01:24 <mm_freak> ddarius: it doesn't…  a String will always need more space
09:01:39 <mm_freak> unless you use compression and the number can be compressed well
09:01:43 <mm_freak> very well that is
09:01:58 <tonkman> default haskell way, without any compressions
09:02:15 <tonkman> read "81393219321983219821", for instance
09:02:20 <mm_freak> Integer uses a compact byte array in memory
09:02:44 <sipa> how large is Char ?
09:02:51 <Cale> 32 bits
09:02:56 <ddarius> mm_freak: "1e10000" takes far less space than 1e10000
09:03:14 <qfr> Hello, I'm still very new to Haskell and I still have a lot of problems with thinking in a purely functional way, I suck at recursion, too. I am currently struggling with converting a fairly simple C++ function to Haskell: http://siyobik.info/index.php?module=pastebin&id=543 Would somebody please help me out here? I really don't know how to deal with the jumps in the i variable and such.
09:03:15 <tonkman> ddarius: are you sure?
09:03:16 <ddarius> + 2 0s
09:03:23 <mm_freak> ddarius: ok, but that's compression
09:03:35 <qfr> Maybe you can do that thing in Haskell in like 20 lines or less, heh
09:03:37 <Cale> qfr: I'll have a look
09:03:41 <qfr> Cale: Thanks
09:03:43 <ddarius> mm_freak: Yes, compressing is perfectly acceptable when encoding.
09:03:58 <mm_freak> true
09:04:03 <tonkman> if 1e1000 in represented as floating point
09:04:13 <Cale> qfr: Lots of bitwise operations, eh?
09:04:22 <Cale> qfr: Do you know about Data.Bits?
09:04:29 <qfr> Cale: Yeah, a few, not that that is the problem
09:04:33 <Cale> okay
09:04:40 <Cale> So, the problem is the structure of the loop?
09:04:45 <qfr> I just have problems with converting imperative flow control to Haskell
09:04:50 <mm_freak> tonkman: well, are you really trying to decrease space usage or to increase speed?
09:05:15 <Cale> qfr: Well, it's usually not the best translation, but I can give you a mechanical translation of imperative programs into functional ones :)
09:05:22 <qfr> Because I don't know how you combine all the list operations and recursion etc to achieve the same
09:05:29 <ddarius> A String (in the normal representation) uses about 100 bits per digit (on a 32-bit architecture), Integer uses less than 4.
09:05:31 <tonkman> mm_freak: nothing, I just pondered
09:05:45 <qfr> Cale: A mechanical one? :O Is there some program to achieve this?
09:06:15 <Cale> qfr: Well...
09:06:19 <Cale> qfr: It's possible :)
09:06:30 <qfr> I bet it is, I just wasn't aware anybody had bothered
09:06:36 <Cale> qfr: The basic idea is this: turn each step of the program into a function
09:06:46 <Cale> qfr: and turn each mutable variable into a function parameter
09:06:50 <qfr> Cale: That sounds cumbersome :p
09:07:00 <Cale> and represent the flow of control by function calls
09:07:01 <mm_freak> or use ContT and implement goto =P
09:07:12 <qfr> mm_freak haha that would be dirty
09:07:17 <Cale> It's usually *really* ugly at first, but it's a starting point.
09:07:41 <Cale> Because once you have a functional program, it's easy to use equations to simplify things.
09:07:50 <mm_freak> qfr: well, to really program purely functionally you should try not to write imperative code first
09:08:01 <mm_freak> translating imperative code to functional code is always ugly
09:08:05 <Cale> Usually you don't have to go quite that far
09:08:42 <roconnor> mm_freak: It's hard work translating ICFP imperative algorithm descriptions to functional code.
09:08:54 <roconnor> *ICFP contest
09:09:01 <mm_freak> rather try to see what the code does and split it into subtasks
09:09:11 <mm_freak> implement the subtasks as functions/computations
09:09:17 <mm_freak> and stick them together
09:09:37 <Cale> The main insight to take away is that the only way in which variables vary in pure functional programming is when functions are applied to different parameters. So if you have a variable whose value changes over time, you want a function parameter where the function is being applied to different values.
09:10:10 <Cale> At least, if you're going at the translation in a brute-force sort of way.
09:10:12 <ddarius> It's pretty common for imperative language compilers to compile the code into a functional representation.
09:10:42 <Cale> Let's try to understand what this C++ code actually computes
09:11:22 <Cale> So we have an input vector of numbers, and a key, which is another number...
09:11:26 <qfr> Cale: I think I'd rather stick with a more brute force approach to converting it for now
09:11:36 <ddarius> Admittedly, they only do this for local mutation.
09:11:43 <qfr> so I see how to do it in general when I don't see another way to do it
09:11:52 <qfr> When the code is too complex to simplify
09:12:08 <qfr> This for loop really throws me off
09:12:28 <mm_freak> the main insight to take away is that whatever control flow you want to implement, there is already a ready-made combinator
09:12:31 <Cale> Well, all we're really doing is iterating over the elements of the input vector
09:12:31 <mm_freak> =)
09:12:44 <ddarius> Namely fix.
09:12:45 <Cale> That suggests that this for loop is really computing a fold of some sort.
09:13:09 <qfr> Cale: If it was a linear iteration with i++ or i-- it wouldn't bother me that much
09:13:20 <qfr> But i is shifted by variable amounts in many of the iterations
09:13:26 <Cale> Oh, I see
09:13:30 <Cale> Interesting
09:13:46 <Cale> Yeah, that's not as nice. :P
09:13:52 <qfr> :P
09:14:08 <Cale> You might just go with direct recursion, and something other than a list for representing the input vector.
09:14:22 <Cale> With i as a function parameter (helper function)
09:14:42 <mm_freak> translating that code seems straightforward to me
09:15:02 <qfr> mm_freak please do post your suggestion :( I am no good at recursion
09:15:27 <ddarius> Getting good at it might be something you want to do sooner rather than later.
09:15:32 <Cale> It's reasonably straightforward to translate to recursive code, but using recursion directly is admitting defeat. ;)
09:15:44 <Cale> Though in this case, it's probably warranted.
09:15:55 <qfr> Cale are you still trying to use folds or something? :p
09:15:58 <ddarius> Cale: He could use the Cont monad and callCC.
09:16:08 <qfr> ddarius isn't that dirty?
09:16:16 <qfr> Isn't that the monad which provides the goto hack?
09:16:18 <Cale> qfr: It's always nicer to capture the way in which you're recursing with some sort of higher-order function.
09:16:23 <mm_freak> yes, because the code seems to be a simple parser
09:16:38 <mm_freak> head + replicateM skip
09:16:44 <conal> for qfr's code, maybe a fold over a list of *functions*, using ($) as the fold operator
09:16:57 <mm_freak> i think there is nothing wrong with recursive notation of parsers
09:17:15 <Cale> mm_freak: So you're saying the i -= argument thing is backtracking?
09:17:27 <mm_freak> Cale: yeah
09:17:53 <Cale> The part of my brain responsible for understanding what imperative programs do has atrophied from disuse.
09:18:06 <qfr> Haha
09:18:32 <mm_freak> i have to access PHP code in read/write mode at work, so i read imperative code fairly often
09:18:37 <mm_freak> and ugly ones at that
09:18:43 <qfr> Urgh, PHP
09:18:59 <mm_freak> imagine you would have to prefix every haskell variable with a $
09:19:02 <mm_freak> it SUCKS
09:19:07 <qfr> $;$;$;
09:19:53 <mm_freak> but we're using PHP 5.3 on our servers, which gives me first class functions at least =)
09:19:58 <ddarius> mm_freak: What do you mean?  That would be awesome.  We could say that $ is the invisible application operator named.
09:20:21 <ddarius> (i.e. it is "" with "$" prepended)
09:20:38 <mm_freak> ddarius: in PHP $ is part of the name
09:20:45 <mm_freak> so "$x;" is valid code
09:20:57 <mm_freak> unless you say that ; is applied to x here =)
09:21:29 <ddarius> I'm saying the we would be saying that "$" is the reified name of "".
09:21:53 <mm_freak> ah =)
09:22:15 <mm_freak> then there is a very simple function to convert each haskell identifier to a PHP identifier
09:22:15 <ddarius> But that would probably be too coherent (if insane) for something PHP inspired.
09:22:33 <mm_freak> > let convert name = '$' : convert name in convert "x"
09:22:34 <lambdabot>   "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$...
09:22:35 <mm_freak> ;)
09:22:56 <mm_freak> ah, no, that's wrong
09:23:05 <mm_freak> > let convert name = convert ('$' : name) in convert "x"
09:23:10 <lambdabot>   mueval: ExitFailure 1
09:24:09 <mm_freak> that's right, but the other one looks nicer =)
09:24:22 <lelf> now write reverse convertion :)
09:26:22 * qfr installs Haskell mode for emacs
09:26:28 <qfr> I presume most Haskell hackers use emacs?
09:26:55 <sipa> no, butterflies
09:27:17 <Cale> qfr: Either emacs or vim
09:27:23 <lelf> or M-x butterfly
09:27:54 <ddarius> I would say only a plurality now uses either vim or emacs.  Maybe just barely a majority together.
09:28:10 <sipa> (actually, i use mcedit, but i won't say that too loud...)
09:28:33 <qfr> Oh? What else would you use? I mean, Haskell is pretty sensitive to automatic whitespace management, like Lisp, no?
09:28:56 <sipa> is lisp sensitive to whitespace?
09:29:05 <jdeseno> lisp isn't
09:29:28 <qfr> sipa: My point was that you do want an editor which calculates the indentation for you
09:29:33 <qfr> Otherwise it's very difficult to read
09:29:46 <qfr> ()(()())(()))))))))))))))))
09:30:29 <kmc> Haskell's whitespace sensitivity is optional, although a strong majority of Haskell programmers use it
09:30:32 <mm_freak> if that were valid lisp, it would be easy to read
09:30:40 <qfr> mm_freak: :P
09:31:11 <mm_freak> nil (nil nil) (nil) )))))))))))))))
09:31:55 <mm_freak> anyway, besides emacs and vim there are also yi and leksah
09:31:56 <kmc> i like how it's impossible to discuss the technical merits or drawbacks of Lisp
09:32:03 <mm_freak> also i think that some haskellers use kate
09:32:05 <kmc> because people just argue endlessly about the syntax
09:32:33 <kmc> hey guys, what kind of chair should i sit in while i write Haskell code?
09:32:49 <mm_freak> kmc: because people don't realize that the parentheses really do make sense in lisp
09:32:56 <sipa> a brown one
09:33:10 <sipa> <flamewar>
09:33:10 <qfr> kmc: Arguing about the syntax? I've never witnessed that so far
09:33:10 <mm_freak> kmc: one, which allows you to sit
09:33:20 <kmc> mm_freak, that's one side; the other is that some lisp advocates lie about the language's syntax
09:33:27 <sipa> mm_freak: i'd say, one which allows you to sit in a lazy manner
09:33:30 <kmc> in particular the claim "lisp has no syntax"
09:33:39 <mm_freak> sipa: true
09:33:40 <qfr> What I see people whine about mostly is that SBCL doesn't print the line on which an error occured until you prod it
09:33:45 <qfr> Same with CCL
09:33:48 <kmc> of course it does; only some S-expressions correspond to valid programs
09:34:30 <ODAY> Hey, Im trying to install glade from cabal, and when it gets to building gtk, it hangs for a while then exits with Errorcode 9
09:34:31 <qfr> And that elisp is too archaic
09:34:48 <mm_freak> kmc: yeah, in the same sense haskell has no syntax either
09:34:50 <ODAY> what does that mean/how can I fix it?
09:35:04 <mm_freak> because a simple syntax means no syntax =)
09:35:26 <qfr> Does Haskell have something like Lisp macros btw?
09:35:33 <mm_freak> qfr: template haskell
09:35:58 <mm_freak> qfr: but in general you can translate lisp ideas to haskell without any macros
09:36:11 <mm_freak> qfr: haskell is very good at EDSLs
09:36:16 <qfr> mm_freak well stuff with setf can be a pain :p
09:36:27 <qfr> need to convert it to recursive calls etc
09:36:30 <qfr> same with progn?
09:36:35 <mm_freak> qfr: you don't /need/ to
09:36:43 <qfr> Well it varies
09:36:55 <mm_freak> qfr: the IO monad allows you to translate imperative programs almost as-is
09:37:59 <mm_freak> but there is also ContT, which gives you even more
09:39:33 <mm_freak> > evalContT $ do (x, myLabel) <- labelCC 15; liftIO (print x); when (x < 16) (goto myLabel (x+1))
09:39:34 <lambdabot>   Not in scope: `evalContT'Not in scope: `labelCC'Not in scope: `goto'
09:39:36 <mm_freak> 15
09:39:38 <mm_freak> 16
09:40:02 <mm_freak> good old goto =)
09:40:18 <qfr> :(
09:41:38 <polarina> Hello. :)
09:41:49 <ODAY> anybody know what exitfailure 9 means in cabal install?
09:41:53 <mm_freak> or if you /really/ want destructive update, you can do that, too
09:42:02 <romildo> Hi.
09:42:40 <mm_freak> using IORef or STRef
09:42:51 <romildo> I am getting an index out of bounds error on my application. Is it possible to get a trace of function calls that led to the error?
09:43:01 <ddarius> kmc: That and even a "minimalist" Lisp like Scheme has non-trivial concrete syntax.
09:43:30 <mm_freak> ddarius: is scheme minimalist?  i think it's even more powerful than CL
09:43:48 <ddarius> mm_freak: Minimalism doesn't mean less powerful.
09:43:56 <qfr> Scheme is far more minimal than CL, no?
09:44:08 <ddarius> It definitely is.
09:44:34 <qfr> does it even have an equivalent of let*?
09:44:39 <ddarius> On the other hand, the MLs really are fugly.
09:44:42 <mm_freak> well, maybe the scheme by specification, but there is also racket, which is "the scheme you actually want to use"
09:45:09 <mm_freak> btw, is there a good functional language, which compiles down to javascript?  other than haxe
09:45:32 <ddarius> mm_freak: There are -plenty- of Schemers that don't use Racket.
09:45:44 <raichoo> mm_freak: Dunno if it's that functional but CoffeScript looks interesting.
09:45:45 <Twey> Hey, polarina.  Long time, no see.
09:46:01 <raichoo> Just had a quick look at it.
09:46:08 <mm_freak> raichoo: i looked at it, but haxe seems to be better
09:46:31 <raichoo> Ok. I don't have a lot of insight there tbh.
09:46:51 <mm_freak> haxe also has static typing and algebraic data types, but you can't write functional code effectively
09:47:01 <ddarius> qfr: Scheme has let*.
09:47:08 <qfr> Oh, ok
09:47:20 <qfr> I always miss let* in elisp :*
09:47:26 <qfr> :(*
09:47:32 <ddarius> elisp is an abomination
09:47:36 <qfr> Yeah
09:47:43 <qfr> But it could be worse
09:47:46 <qfr> vim script :D
09:47:51 <raichoo> urgs
09:48:06 <qfr> I've written code for vim, it was not pretty
09:48:06 <raichoo> I've been hacking with vimscript for the last few days…
09:48:27 <raichoo> Agreed.
09:48:27 <qfr> It was one of the reasons that drove me to go for emacs instead, because I really didn't get that language
09:49:32 <qfr> Unluckily the Windows ports of emacs are terribly slow :( I'm forced to run an old version because the new ones nearly die on me whenever I scroll
09:49:58 <qfr> gvim runs really fast
09:50:14 <raichoo> qfr: Though about that too while coding vimscript. But thb, i really prefer the way you can navigate through code in vim.
09:50:20 <hpc> gvim is also ugly and harder to use :/
09:50:20 <mm_freak> raichoo: also coffeescript has those extremely ugly dollar signs everywhere
09:50:44 <raichoo> mm_freak: So has a lot of haskell code ^^ *scnr*
09:51:24 * ddarius uses console vim.
09:51:30 <raichoo> dito
09:51:51 <qfr> ddarius doing that on Windows would be truly masochistic :p
09:52:07 <ddarius> qfr: I did that on Windows.
09:52:09 <qfr> Considering how terrible the csrss GUI is (AllocConsole etc)
09:52:40 <qfr> I want to write a total replacement for that stuff, but it's a lot of work, would require hooking 30-50 calls in kernel32.dll
09:53:16 <polarina> Would anyone happen to know why this is segmentation faulting? http://codepad.org/6EIbVpIC
09:53:56 <qfr> I already wrote a simple replacement: http://siyobik.info/paracletus/ but it just redirects stdin/stdout/stderr so the behaviour is totally different and it would never work with vim nor emacs
09:56:32 <kmc> when i had to do console stuff in Windows i would use putty to ssh to localhost
09:56:51 <kmc> i think someone ripped the console bit out of putty and made an equivalent simpler thing
09:57:51 <lelf> ?go haskell javascript backend
09:57:52 <lambdabot> Maybe you meant: google googleit do
09:58:02 <lelf> ?goo haskell javascript backend
09:58:03 <lambdabot> Maybe you meant: google googleit do ghc todo yow
09:58:16 <lelf> ough
09:59:38 <ODAY> have any of you ever used Yi?
09:59:54 <polarina> What are the practical differences between a MVar and a TMVar?
10:01:50 <ODAY> 3~
10:01:50 <ODAY> 3~
10:01:59 <mm_freak> polarina: TMVar is transaction-aware
10:01:59 <mm_freak> MVar isn't
10:02:23 <ODAY> Oops, stupid cat
10:03:05 <qfr> What's the Haskell equivalent of Lisp's nth?
10:03:14 <mm_freak> what is nth?
10:03:26 <qfr> (nth 1 '(1 2)) returns 2
10:03:31 <mm_freak> > [2,3,4] !! 1
10:03:32 <lambdabot>   3
10:03:35 <qfr> Ah thanks
10:03:47 <mm_freak> but you'll want to use (!!) with care
10:03:59 <qfr> Because of boundaries?
10:04:04 <mm_freak> it's an O(n) operation, while lisp's 'nth' is probably O(1)
10:04:16 <qfr> :O
10:04:28 <sipa> since lisp also uses linked lists for everything, i doubt that
10:04:36 <mm_freak> if you need random access, lists are not suitable…  use Array, Vector or something like that
10:04:44 <mm_freak> sipa: oh, ok
10:05:01 <mm_freak> qfr: if you have a fixed-size tuple, just use a haskell tuple
10:05:06 <mm_freak> > snd (2, 3)
10:05:07 <lambdabot>   3
10:07:14 <qfr> Why does the Haskell array take an index value pair?
10:07:20 <qfr> a list of index value pairs* rather
10:07:27 <qfr> Is it an associative array?
10:07:34 <qfr> Maybe I should be looking at vector instead
10:08:08 <mm_freak> qfr: start index, end index
10:09:52 <ddarius> qfr: Haskell is a pure language.  You can't update in place so modifying an array requires copying it.  Therefore it is better to do such modifications in bulk.
10:12:44 <hoknamahn> hey guys. can I make such dependency? http://pastebin.com/zSyip3h2 So if I have two lists with the same length, one of type [Header] and another of type [ValType] I want each value constructor of [ValType] to match the value constructor of [Header]
10:12:53 <hoknamahn> is it possible to do statically?
10:13:10 <hoknamahn> or better to do it when constructing a list?
10:15:43 <roconnor> hoknamahn: what do you mean you want them to match?
10:16:01 <roconnor> if you have two lists either they all match or they don't.
10:16:23 * hackagebot xhb 0.4.2010.12.26 - X Haskell Bindings  http://hackage.haskell.org/package/xhb-0.4.2010.12.26 (AntoineLatter)
10:16:40 <hoknamahn> so if header of a table says values should be arranged as [Int, int, String, Float, String, Int] then all the values in [ValType] list have to be arranged in this way
10:17:02 <hoknamahn> same as we can do with tuples
10:18:30 <hoknamahn> i want value constructors in one list to be linked somehow to value constructors of another list otherwise I have an error as types don't match
10:18:49 <hoknamahn> like (Int, Float) doesn't match (Float, String)
10:18:56 <roconnor> hoknamahn: I see.  
10:19:06 <roconnor> hoknamahn: in Haskell you should put them together in one list
10:19:30 <roconnor> and in this case, since ValTypes are just a field of Headers, you can just have the one list of Headers and you are done
10:19:45 <sipa> hoknamahn: something of type ValType only exposes that it is of type ValType statically
10:19:50 <roconnor> whenever you need the "second list" you can just write "map valType myHeaderList"
10:19:59 <sipa> no way to say anything about what value it contains
10:20:34 <roconnor> hoknamahn: or are you saying that you have a ValIist with different data values, but what the constructors to align
10:20:35 <ddarius> roconnor: I don't think the "in Haskell" was necessary.
10:20:58 <roconnor> ddarius: in a dependent type system you can have "two lists" whose values are related together
10:21:27 <hoknamahn> well imagine a spreadsheet the header of which shows the type of value you can write in a column
10:21:44 <hoknamahn> so if type of a column is Int I'm not eligible to write String
10:21:53 <roconnor> hoknamahn: in this second case, you want to make a new data type containing both header and valtype data and make a list of that
10:22:06 <hoknamahn> but I need them separate
10:22:08 <roconnor> then write projection functions toget out the header and valtype data
10:22:09 <ddarius> roconnor: It's not a matter of could but a matter of should.
10:22:18 <hoknamahn> one list is an attribute dictionary
10:22:27 <roconnor> and than map the projection functions over your one list to get the two lists
10:22:29 <hoknamahn> another is values we attach to points on geometry
10:23:10 <hoknamahn> but I got an idea thanks. just control that manually, right? so there is no need to think about type system?
10:23:20 <roconnor> no
10:23:24 <roconnor> use the type system
10:23:50 <hoknamahn> but using just one list?
10:24:15 <roconnor> data ValPair = ValPairInt (Int,Int) | ValPairDbl (Double,Double) | ValPairStr (String,String)
10:24:48 <roconnor> data HeaderAndValType = HeaderAndValType { hvName :: String, hvPair :: ValPair }
10:25:04 <roconnor> type myList = [HeaderAndValType
10:25:07 <roconnor> type myList = [HeaderAndValType]
10:26:02 <hoknamahn> okay
10:26:02 <roconnor> fstValPair (ValPairInt (i,_)) = ValInt i
10:26:08 <roconnor> ...
10:26:24 <roconnor> sndValPair (ValPairInt(_,i)) = ValInt i
10:26:29 <hoknamahn> doesn't work for me
10:27:01 <roconnor> getHeader (hav::HeaderAndValPair) = Header (hvName hav) (fstValPair (hvPair hav))
10:27:03 <hoknamahn> as I have Point [ValType], Primitive [ValType] and so on
10:27:16 <roconnor> getValType (hav:HeaderAndValPair) = sndValPair (hvPair hav)
10:27:47 <roconnor> map getHeader myList -- extracts the header list
10:27:52 <tux_mark_5> hello
10:27:54 <roconnor> map getValType myList -- extracts the valList
10:28:07 <hoknamahn> I need just one header for all the points
10:28:10 <roconnor> hoknamahn: What is Point and Primitive
10:28:36 <hoknamahn> imagine any geometry, like a box, faces of a box are primitives, points of it are points
10:28:43 <tux_mark_5> is there a more convenient way to browse through haskell's docs rather than using plain browser?
10:28:44 <hoknamahn> primitives and points contain values
10:29:07 <roconnor> faces can contain values?
10:29:13 <hoknamahn> yep
10:29:32 <hoknamahn> and a dictionary describes what types are available on points and faces
10:29:35 <roconnor> okay, let's pretend I understand. :) go on.
10:29:44 <hoknamahn> for example
10:30:08 <hoknamahn> point can contain normal, velocity, temperature, color values
10:30:38 <hoknamahn> dictionary says that we have 4 attributes with such names and such default values
10:30:49 <roconnor> ok
10:30:53 <hoknamahn> and point contains actual values
10:30:56 <hoknamahn> same for other points
10:31:12 <hoknamahn> types of values should match dictionary
10:31:12 <roconnor> hoknamahn: is this dictionary known statically?
10:31:23 <hoknamahn> well this is the problem - no
10:31:33 <hoknamahn> it's flexible
10:31:52 <roconnor> meh
10:32:11 <roconnor> anyhow, I'd parameterize the values held by points and faces by type variables
10:32:37 <roconnor> generic operations on points and faces won't know what to do with these values anyways
10:32:50 <roconnor> well, maybe with some class contraints they might
10:32:51 <roconnor> anyhow
10:33:27 <roconnor> for example you might want to interpolate points to get new points
10:33:45 <roconnor> and then you'd want to interpolate the values held at the points to get new values for the new point.
10:34:05 <roconnor> this requires that the values behing held be part of an affine space.
10:34:17 <roconnor> so you'd make a class for the operations of an affine space.
10:34:32 <roconnor> and then but a class constraint on the point interpolation function.
10:34:50 <hoknamahn> I see what you mean
10:34:54 <roconnor> this makes your code way more flexible
10:34:58 <hoknamahn> using class constraints
10:35:04 <roconnor> you don't have to enumatate all the possible data you might want to have
10:35:46 <roconnor> strings might not interpolate so well :D
10:35:51 <hoknamahn> yep
10:35:58 <roconnor> but other operations might be fine with strings
10:36:04 <hoknamahn> well let me show you what i mean ;) on real case
10:36:07 <roconnor> so each operation can have different class constraints
10:37:13 <ddarius> Programmer's have a tendency to be solution-oriented.
10:37:26 <roconnor> ddarius: I do too :(
10:38:07 <roconnor> ddarius: it is an unfortuate side effect of being focused.
10:39:00 <hoknamahn> http://pastebin.com/QtmmwvW5
10:39:06 <hoknamahn> this is how it looks like
10:39:31 <hoknamahn> a box with Cd primitive attribute and N, temperature point attributes
10:40:21 <hoknamahn> there is a dictionary that describes names / default values of attribs and actual values on points and faces
10:41:12 <hoknamahn> like in line No 7 (name, type, defaultVal)
10:41:42 <hoknamahn> and line 8 contains a point with attributes
10:41:47 <hoknamahn> -0.5 -0.5 -0.5 1 (0.641600609   -0.577350259 -0.577350259 -0.577350259)
10:42:42 <hoknamahn> so if we change the name of attribute in dictionary it wouldn't change anything for actual values on points
10:43:10 <hoknamahn> changing of value on point doesn't do anything to dictionary
10:45:51 <roconnor> hoknamahn: btw, what is cd?
10:46:31 <hoknamahn> it color
10:46:50 <hoknamahn> Color diffuse I suppose :)
10:47:01 <roconnor> hoknamahn: what are the 1's and 0's in the attribute definitions?
10:47:18 <hoknamahn> which lines?
10:47:37 <roconnor> 6 7 and 17
10:49:12 <hoknamahn> first is name like N, next is length (how many components type has) so 3 means xyz, vector means vector type 0 0 0 means default value is {0,0,0}
10:50:05 <hoknamahn> Cd 3 float 1 1 1 means name of attribute is Cd, it's got 3 components of float type and it's default value is 1,1,1 which is white
10:50:08 <roconnor> hoknamahn: so the way I would do this is that I'd have a data structure of points and faces that are parameterized by type variables a and b.
10:50:24 <hoknamahn> what are a and b?
10:50:42 <roconnor> a is the data held at points and b is the data held at faces
10:51:07 <roconnor> I might even do a "first pass" were faces and points hold strings
10:51:32 <hoknamahn> in some cases we can have 0 prim attributes
10:51:36 <hoknamahn> and 1000 of point
10:51:54 <hoknamahn> in some cases we have no attributes
10:52:26 <hoknamahn> so the lengths of point and prim attribute lists are different
10:52:42 <roconnor> that's fine. That's why there are two different type variables
10:52:57 <qfr> What's the advantage of Data.Array.Vector over using regular lists?
10:53:11 <roconnor> after that I might check out HLists as a way to build a dictionary type at "runtime"
10:53:57 <roconnor> granted that is pretty advanced
10:54:23 <hoknamahn> okay thanks :)
10:54:43 <roconnor> if you are a haskell beginner it might really be easier to use lists of your own enumeration of types and pray that the lengths and attributes line up
10:55:24 <ddarius> qfr: Vector is an array; lists are lists.
10:56:00 <hoknamahn> roconnor what if functions that add/delete attributes take care about lenghts/types?
10:56:10 <hoknamahn> is it that bad idea?
10:56:41 <roconnor> what do you mean by "take care"
10:57:26 <hoknamahn> so user can't use cons on attribute list. instead he should use something like addAttr point attr
10:57:48 <hoknamahn> addAttr will extend both dictionary and value lists
10:58:40 <roconnor> I wouldn't have addAttrbute functions
10:59:07 <hoknamahn> okay so HList is the way to go>
10:59:09 <hoknamahn> ?
10:59:09 <roconnor> I might have a mapattributes function that takes a whole set of attributes and replaces them with a totally different set of attributes
10:59:26 <roconnor> I've never used HList but the description appears to do everything you want
11:04:25 <hoknamahn> what is advantage of existential data type over algebraic data type if I know that all the possible values will be of type a, b and c?
11:04:36 <hoknamahn> so I don't need extencible data type
11:05:20 <qfr> Hmm qualified imports don't work in ghci?
11:05:31 <c_wraith> qfr: not until ghc 7
11:05:35 <qfr> Oh snap
11:05:51 <c_wraith> Which is out, but not yet recommended for general use
11:06:18 <arcatan> luckily i'm just a corporal!!!
11:06:40 <ddarius> You could have been an Admiral.
11:07:43 <monoidal> is there a nice way to define the function Monad m => m (Maybe a) -> m a that performs action till first non-Nothing?
11:07:56 <monoidal> i've got untilSuccess x = x >>= maybe (untilSuccess x) return
11:08:27 <ddarius> @pl untilSuccess x = x >>= maybe (untilSuccess x) return
11:08:28 <lambdabot> untilSuccess = fix (ap (>>=) . flip flip return . (maybe .))
11:08:54 <ddarius> @pl \x -> x >>= maybe (untilSuccess x) return
11:08:54 <lambdabot> ap (>>=) (flip maybe return . untilSuccess)
11:24:48 <qfr> I have a function f and the first argument is fixed to value 3. I have a fixed number of arguments after that whose value depends on a switch. For example, it could be (4, 7). Is there an elegant way to call f 3 4 7 using some apply operator or something like that or should I simply use fst etc?
11:25:28 <parcs> @type curry
11:25:29 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:29:51 <kmc> qfr, if you're using fst and snd for something, you should maybe consider using pattern matching instead
11:30:43 <Cale> > let f x y z = x^2 + y^2 + z^2 in uncurry (f 3) (4,7)
11:30:44 <lambdabot>   74
11:31:12 <kmc> pattern matching is underused by beginners because most other languages don't have it, so they instead look for a function (which usually exists in Haskell, but is often less nice to work with)
11:31:32 <qfr> Ah, thanks
11:32:17 <qfr> Actually pattern matching would be smarter here I think
11:32:26 <Cale> Quite possibly :)
11:32:37 <Cale> > let f x (y, z) = x^2 + y^2 + z^2 in f 3 (4,7)
11:32:38 <lambdabot>   74
11:33:02 <Cale> > let f x (y, z) = x^2 + y^2 + z^2 in map (f 3) [(1,2),(3,5),(4,7)]
11:33:03 <lambdabot>   [14,43,74]
11:33:28 <revenantphx> @hoogle IO ByteString
11:33:28 <lambdabot> Did you mean: :: IO ByteString /count=20
11:33:28 <lambdabot> No results found
11:33:38 <revenantphx> @hoogle :: IO ByteString
11:33:39 <lambdabot> Data.ByteString getContents :: IO ByteString
11:33:39 <lambdabot> Data.ByteString getLine :: IO ByteString
11:33:39 <lambdabot> Data.ByteString.Char8 getContents :: IO ByteString
11:33:46 <revenantphx> :|
11:34:03 <revenantphx> @hoogle [Char] -> ByteString
11:34:04 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
11:34:04 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
11:34:04 <lambdabot> Prelude error :: [Char] -> a
11:34:47 <Phyx-> hah, after hours of coding, i'm kinda afraid to press enter and seeing if it runs :P
11:34:50 <Phyx-> don't wanna be dissapointed
11:35:18 <arcatan> does it typecheck? / will it blend?
11:35:48 <revenantphx> I have IO String i want IO ByteString... great.
11:36:10 <Codex_> arcatan: I think there's an app for that.
11:36:11 <Phyx-> arcatan: it typechecks, doubt it'll blend :)
11:36:25 <Phyx-> @Hoogle String -> ByteString
11:36:26 <lambdabot> Maybe you meant: google hoogle
11:36:31 <Phyx-> @hoogle String -> ByteString
11:36:32 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
11:36:32 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
11:36:32 <lambdabot> Prelude read :: Read a => String -> a
11:36:45 <Phyx-> :t fmap Data.ByteString.Char8.pack
11:36:46 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f Data.ByteString.Internal.ByteString
11:38:50 <monoidal> Given ST s (a,STArray s i e), how do I get (a,Array i e)?
11:40:04 <c_wraith> monoidal, use several steps.  You'll want an unsafeFreeze and runST in there.
11:40:27 <revenantphx> Anyone able to help me with this?
11:40:28 <revenantphx> https://gist.github.com/755586
11:40:32 <revenantphx> Trying to write a trivial parser.
11:41:05 <revenantphx> when I type in anything but foo bar or baz first it errors (which is correct)
11:41:13 <revenantphx> but if I type any of them, it waits for more input
11:41:22 <revenantphx> and no matter what I put in it says "*** Exception: ParseError {errorContexts = [], errorMessage = "Failed reading: takeWith"}"
11:41:41 <revenantphx> Ignore getData, it's not in use here.
11:44:29 <revenantphx> oh, snap, I see the mistake I think.
11:44:43 <revenantphx> yeah got it.
11:47:51 <revenantphx> neat :)
11:53:22 <c_wraith> monoidal: ah, you need to enable Rank2Types, I think.  At least I did. :)
11:54:03 <qfr> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Bits.html#v%3A.%26. <- how do I use this operator after import Data.Bits? & is still undefined when I try to use it as an infix operator
11:54:07 <Phyx-> well.. that sure went boom
11:54:11 <qfr> `xor` works fine though
11:54:33 <arcatan> qfr: its .*., not &
11:55:04 <qfr> Oh, .&. as infix operator works
11:55:05 <arcatan> whoops, .&.
11:55:19 <qfr> Thanks
11:55:30 <qfr> Why the dots and why the ``, by the way?
11:55:56 <c_wraith> monoidal, http://hpaste.org/42561/st_conversion
11:55:59 <aristid> because for some reason they did not want to use &
11:56:15 <monoidal> c_wraith: thanks
11:56:16 <aristid> and `` is haskell syntax to make a non-operator identifier behave like an operator
11:56:17 <ion> Just like (+) 1 2 is alternative syntax for 1 + 2, 1 `foo` 2 is alternative syntax for foo 1 2.
11:56:30 <zygoloid> presumably it's .&. not & for symmetry with |, which isn't a legal operator name. 
11:56:34 <c_wraith> monoidal, The only trick was using the rank 2 type.  Everything else was pretty straight-forward
11:56:36 <monoidal> c_wraith: (although I think there should be a framework that allows that without unsafe* functions)
11:56:55 <c_wraith> monoidal, you could change that to freeze, it'd just be less efficient, and no more safe
11:57:11 <qfr> What's the usual way to get around the Prelude.length and Data.Vector.length collision? Qualified import of the Vector or specifying the full path whenever you use length?
11:57:40 <zygoloid> qfr: import qualified Data.Vector as V, perhaps
11:57:43 <c_wraith> monoidal, unsafeFreeze is only unsafe if you continue to mutate the mutable version of the array after using it.  Due to the guarantees of ST, that isn't possible in that function
11:58:02 <ddarius> Or hide the Prelude version if you're not using it.
11:58:09 <kmc> yeah, a lot of Haskell data structure libraries are designed to be imported qualified
11:58:12 <monoidal> c_wraith: understood, thanks
11:58:16 <qfr> Do people sometimes use a regular import plus a qualified import?
11:58:28 <ddarius> qfr: That happens often.
11:58:41 <qfr> To use Vector for the type and say V.head for collisions? Ah, I see
11:58:45 <c_wraith> yeah.  import Data.Map (Map) ; import qualified Data.Map as Map
11:58:49 <ddarius> qfr: The import mechanism is fairly flexible in this regard.
11:58:49 <kmc> yes qfr, although i don't bother
11:58:50 <c_wraith> that happens all the time
11:58:54 <kmc> i don't mind saying M.Map
11:59:07 <monoidal> c_wraith: I think a more elegant solution might be if there was a type family converting STArray s to Array, that could be combined
11:59:07 <ddarius> kmc: What about C.. ?
11:59:47 <sshc> If I have a function that constructs a value of type Foo in the IO monad, which is computationally expensive, how could I lazily create an array in the IO monad from that function and unsafeInterleaveIO that doesn't evaluate each element until it is necessary?
12:00:04 <c_wraith> monoidal, there are certainly more elegant things, probably.  Just remember that ST is *old*.  It predates type families in GHC.  It is correct, but not necessarily the easiest thing to use.
12:00:05 <sshc> The size of the array can be thousands and even tens of thousands elements
12:00:06 <monoidal> c_wraith: allowing something like (STArray s i a, [STArray s i b]) -> (Array i a, [Array i b])
12:00:08 <ddarius> qfr: Another thing you can do is you can have multiple modules use the same qualifier, i.e. import Foo as M; import Bar as M.
12:00:38 <qfr> That sounds dirty
12:00:51 <c_wraith> Occasionally it's really helpful.  Most of the time it's terrifying :)
12:01:20 <ion> I want import * as M.
12:01:34 <c_wraith> Fortunately, this isn't java :)
12:12:06 <qfr> No instance for (Bits (m Int)) arising from a use of `.&.' in: let argument = (activeCode `shiftR` 16) .&. 0xfff
12:12:11 <qfr> What does m Int mean?
12:12:40 <kmc> m ranges over type constructors, so that type could instantiate to Maybe Int or [Int] or (Either Bool Int) etc.
12:13:16 <kmc> what's the type of activeCode?
12:13:41 <qfr> let activeCode = indexM codes index
12:13:54 <qfr> codes is a Vector Int and index is an Int
12:14:04 <qfr> shouldn't activeCode be Int then?
12:14:09 <kmc> what's the type of indexM?
12:14:27 <qfr> :t Data.Vector.indexM
12:14:28 <lambdabot> Couldn't find qualified module.
12:14:42 <qfr> ;(
12:14:44 <kmc> indexM :: Monad m => Vector a -> Int -> m a
12:14:53 <qfr> Oh hmmm
12:14:58 <qfr> It's not a
12:15:41 <kmc> might you want (codes ! index) instead?
12:16:47 <qfr> Ah, thanks
12:17:11 <qfr> What do you use indexM for then?
12:17:27 <kmc> i'm not sure myself
12:17:30 <kmc> the docs try to explain it
12:17:45 <kmc> something to do with controlling laziness
12:17:53 <kmc> not that monads in general are about controlling laziness -- but this function is
12:20:59 <qfr> What do I use as an emtpy vector for pattern matching?
12:21:09 <qfr> do I need to use fromList [] on the left side?
12:21:48 <qfr> Ohhh
12:21:51 <mauke> oh, you can pattern match vectors?
12:21:56 <qfr> Data.Vector.emtpy
12:22:02 <qfr> mauke: I have no idea :O
12:22:16 <qfr> I am just writing my hello world in Haskell
12:22:43 <qfr> Pattern matching only works for more fundamental stuff then?
12:23:02 <qfr> Qualified name in binding position: Data.Vector.empty
12:23:08 <qfr> I suppose that doesn't work
12:23:16 <mauke> pattern matching only works on constructors
12:23:24 <mauke> I don't think vector's constructors are exported
12:23:36 <mauke> but I've never used or seen vector, so ..
12:23:39 <arcatan> but use Data.Vector.null to test if the vector is empty
12:24:55 <qfr> Alright, thanks
12:28:32 <qfr> Hmm the indentation of haskell-mode in emacs breaks on me sometimes, I think, it was a bit confusing
12:33:20 <qfr> Alright, for my Hello World in Haskell I tried to convert the following C++ code to Haskell: http://siyobik.info/index.php?module=pastebin&id=543  Here's what I came up with: http://hpaste.org/42563/converted_code any thoughts?  What could be improved?
12:33:30 <qfr> Cale ^ I bet I broke something but at least I tried :p
12:34:14 <qfr> HLint is frowning upon what you guys suggested earlier, heh
12:34:26 <qfr> Is that thing built into ghc or is it a separate program?
12:34:38 <mauke> let/let can be merged
12:34:41 <roconnor> HLint appears to be full of shit
12:34:55 <qfr> mauke oh yeah of course
12:35:04 <qfr> I had something between those earlier
12:35:05 <benmachine> hlint is not built in to ghc
12:35:17 <mauke> isJust/fromJust better written using pattern matching
12:35:21 <benmachine> roconnor: how so?
12:35:22 <mauke> roconnor: why?
12:36:15 <qfr> auto indentation is so not working right now, haha :( is haskell-mode that broken for emacs?
12:36:21 <roconnor> qfr: "Import Data.Vector" is to get the infix operators?
12:36:35 <qfr> roconnor: To get Vector
12:36:40 <ski> qfr : instead of `isJust' and `fromJust', i'd just do a `case' on `Just'
12:36:43 <qfr> Otherwise I'd have to do V.Vector, no?
12:36:48 <mauke> qfr: no
12:36:58 <roconnor> ah okay
12:36:59 <mauke> you didn't say "import qualified"
12:37:19 <roconnor> oh wow
12:37:27 <roconnor> okay I take it back.  HLint knows haskell better than me
12:37:43 <roconnor> I didn't know you could import as without the qualified keyword
12:38:00 * ski thinks qfr's code wants to use `Maybe' monad
12:41:15 <qfr> ski: Hmm case handler Just (newKey, newIndex) -> blah gives me parse error on input `->'
12:41:29 <qfr> I'm Doing It Wrong (TM)
12:41:37 <qfr> Can't you pattern match like that?
12:41:43 <mauke> missing 'of'
12:41:45 <ski> you forgot `of'
12:41:46 <qfr> ...
12:41:58 <qfr> Cheers, it works
12:42:27 <ski> qfr : one could break out the part after `handler = ' into a new definition (probably local to the current one, using `where'), and then use `Maybe' monad
12:42:28 <qfr> http://hpaste.org/42564/converted_code better?
12:43:08 <qfr> I still underuse pattern matching, I think
12:43:10 <ski> qfr : next time, annotate the original paste
12:43:17 <qfr> Oh, right
12:43:28 <qfr> I'm used to pastebins where you can actually edit the code
12:43:53 <ski> instead of the outermost `if'-`then'-`else', i'd use a guard
12:44:28 <arcatan> also guard for determineKey
12:44:47 <ski> yes
12:45:34 <arcatan> maybe it's just me, but i feel haskellers almost never use if
12:45:47 <systemfault> Not that it's useful...
12:45:51 <systemfault> We have better.
12:46:02 <qfr> Isn't it tedious to write otherwise instead of else?
12:46:12 <qfr> if then else seems shorter to me when you only have two cases
12:46:13 <djahandarie> Whenever I use if I often want if'
12:46:21 <dschoepe> qfr: you can write true if you don't like otherwise
12:46:24 <dschoepe> > otherwise
12:46:26 <lambdabot>   True
12:47:00 <mauke> @src otherwise
12:47:00 <lambdabot> otherwise = True
12:47:10 <ion> I just type oth^P :-)
12:47:18 <systemfault> :P
12:47:30 <systemfault> I use ^N
12:47:37 <arcatan> djahandarie: what's that?
12:47:40 <monoidal> qfr: you can change let..in.. into where, and have 3 guards for index < 0 || index > ... , testBit activeCode 31, otherwise
12:47:43 <benmachine> I just type otherwise
12:47:47 <ski> qfr : regardless of whether you use a guard there or not, you can float the `let'-`in' up to the top-level of the equation body, and thus use `where' instead
12:47:51 <benmachine> it's like nine letters, big deal
12:47:56 <djahandarie> arcatan, function form of if
12:48:05 <arcatan> ah
12:48:07 <ski> qfr : remember that they won't be evaluated unless they're needed
12:48:15 <djahandarie> :t if'
12:48:15 <lambdabot> Not in scope: `if''
12:48:24 <djahandarie> Hm, used to be in lambdabot at one point
12:48:36 <copumpkin> only in @pl
12:48:41 <scree> @let if' b x y = if b then x else y
12:48:42 <djahandarie> Ah right
12:48:42 <lambdabot>  .L.hs:6:0:
12:48:43 <lambdabot>      Failed to load interface for `Control.Arrow.Operations':
12:48:43 <lambdabot>    ...
12:48:55 <scree> ?
12:49:06 <djahandarie> I think that broke at some point (when lispy upgrade GHC?).
12:49:09 <mauke> @define
12:49:23 <mauke> @let answer = 42
12:49:23 <lambdabot>  .L.hs:6:0:
12:49:23 <lambdabot>      Failed to load interface for `Control.Arrow.Operations':
12:49:24 <lambdabot>    ...
12:49:30 <mauke> lambdabot: YOU!
12:49:30 <qfr> Hmm I don't find where elegant tbh, I like to have my definitions at the top instead of after the place where they are used
12:50:33 <ion> OTOH, i like to put the most relevant stuff in the beginning and the less important implementation detail after it.
12:50:42 <ski> qfr : to avoid the clunky `case ... of ...; Nothing -> Nothing', you should use `Maybe' monad
12:50:48 <ion> in any language
12:53:21 <ski> qfr : `do ...; (newKey,newIndex) <- if testBit activeCode 31 then ... else ...; performKeyCalculation codes newKey newIndex'
12:53:41 <Cale> Oh dear, I should check that out.
12:53:49 <Cale> It's probably just that we need to reinstall some packages
12:55:18 <Cale> @let answer = 42
12:55:18 <lambdabot>  .L.hs:13:0:
12:55:18 <lambdabot>      Failed to load interface for `Control.Monad.Logic':
12:55:18 <lambdabot>        ...
12:55:21 <Cale> okay
12:55:36 <Cale> okay
12:55:37 <Cale> @let answer = 42
12:55:37 <lambdabot>  .L.hs:19:0:
12:55:37 <lambdabot>      Failed to load interface for `Control.Parallel':
12:55:38 <lambdabot>        Use...
12:55:40 <Cale> :)
12:55:47 <djahandarie> It's sometimes nice that mueval is a seperate binary
12:55:56 <Cale> @let answer = 42
12:55:56 <lambdabot>  .L.hs:38:0:
12:55:56 <lambdabot>      Failed to load interface for `Data.Number.BigFloat':
12:55:56 <lambdabot>       ...
12:55:59 <Cale> moar!
12:56:07 <djahandarie> Well... then again it wouldn't have broken in the first place if it was integrated
12:57:24 <Cale> @let answer = 42
12:57:24 <lambdabot>  .L.hs:51:0:
12:57:25 <lambdabot>      Failed to load interface for `ShowQ':
12:57:25 <lambdabot>        Use -v to see ...
12:57:31 <aristid> lol?
12:57:40 <arcatan> you just have to accept that 42 isn't the answer
12:57:55 <djahandarie> Hah
12:58:01 <Cale> I'm just using that to decide which packages I really need to install
12:58:02 <Cale> @let answer = 42
12:58:03 <lambdabot>  .L.hs:55:0:
12:58:03 <lambdabot>      Failed to load interface for `Text.Regex.Posix':
12:58:03 <lambdabot>        Use...
12:58:29 <Cale> (I could do it in private, but the channel's a little quiet anyway)
12:58:31 <Cale> @let answer = 42
12:58:32 <lambdabot>  .L.hs:70:0:
12:58:32 <lambdabot>      Failed to load interface for `Data.MemoCombinators':
12:58:32 <lambdabot>       ...
12:58:56 <Cale> @let answer = 42
12:58:56 <lambdabot>  .L.hs:74:0:
12:58:56 <lambdabot>      Failed to load interface for `Math.OEIS':
12:58:56 <lambdabot>        Use -v to ...
13:00:12 <Cale> @let answer = 42
13:00:13 <lambdabot>  .L.hs:75:0:
13:00:13 <lambdabot>      Failed to load interface for `Control.Monad.Random':
13:00:14 <lambdabot>       ...
13:00:36 <Cale> Everyone gets to see how many modules get loaded :P
13:00:39 <Cale> @let answer = 42
13:00:39 <lambdabot>  .L.hs:77:0:
13:00:39 <lambdabot>      Failed to load interface for `Data.VectorSpace':
13:00:39 <lambdabot>        Use...
13:00:58 <Cale> @let answer = 42
13:00:59 <lambdabot>  .L.hs:81:0:
13:00:59 <lambdabot>      Failed to load interface for `Test.IOSpec':
13:00:59 <lambdabot>        Use -v t...
13:01:04 <Cale> Really?
13:01:10 <Cale> Oh, I guess I remember adding that...
13:01:13 <pastorn> Cale: why are you http://www.youtube.com/watch?v=AC4IXY82UOs
13:01:25 <Cale> hm?
13:01:33 <pastorn> look at song title ;)
13:01:48 <Cale> I'm not breaking anything, I'm fixing it.
13:01:54 <Cale> nice, IOSpec doesn't build
13:02:01 <Cale> Oh well, I'll remove the dependency.
13:02:08 <pastorn> yes, that's what it looks like :p
13:02:42 <Cale> @undefine
13:02:48 <Cale> @let answer = 42
13:02:49 <lambdabot>  Defined.
13:02:54 <Cale> there we are
13:02:57 <pastorn> > answer + 1
13:03:00 <Cale> Should be back to working order.
13:03:01 <lambdabot>   mueval-core: Time limit exceeded
13:03:04 <Cale> haha
13:03:06 <pastorn> exactly
13:03:10 <mauke> > ()
13:03:10 <lambdabot>   ()
13:03:11 <Cale> > answer + 1
13:03:12 <lambdabot>   43
13:03:17 <pastorn> WAT?
13:03:22 <Cale> just a random fail
13:03:24 <pastorn> > answer + 1
13:03:25 <mauke> @oies 1 3 4 9
13:03:25 <lambdabot>   43
13:03:25 <lambdabot>  Sequence not found.
13:03:36 <djahandarie> mauke, that's broken for other reasons :P
13:03:41 <Cale> I have no idea if oeis even works anymore.
13:03:51 <Cale> I think they're working on it.
13:04:16 <benmachine> @oeis 1 2 3 4
13:04:16 <lambdabot>  Sequence not found.
13:04:33 <Cale> But I should at least rebuild lambdabot now
13:04:39 <sipa> @oeis 1 1 2 3 5 8 13
13:04:40 <lambdabot>  Sequence not found.
13:04:47 <djahandarie> Yeah I think ddarius wants some patches in
13:05:13 <mauke> me too
13:05:52 <Cale> lol
13:06:08 <Cale> show-0.3.4 requires QuickCheck <2
13:06:48 <monoidal> qfr: here's version using Either: http://hpaste.org/42565/converted_code
13:07:16 <qfr> >:O
13:09:15 <tonkman> If I have a datatype, Data A = A { foo :: Int, bar :: String }, for example
13:09:16 <qfr> Ah I get it
13:09:20 <wharzl> Can someone explain why I get an error on the third line - http://hpaste.org/42567/why
13:09:46 <tonkman> can I easyly modify already contructed data
13:09:47 <wharzl> It says 'Type is not in scope'.
13:09:49 <Cale> aha, somehow mueval depends on show and lambdabot depends on mueval even though it really doesn't, because there are a whole bunch of spurious dependencies in the cabal file
13:10:07 <benmachine> hmm
13:10:13 <monoidal> wharzl: in your code, "Type" is a value (constructor)
13:10:15 <benmachine> I wonder if there should be a runtime-depends sort of thing
13:10:22 <monoidal> wharzl: it is not a type
13:10:28 <wharzl> ah
13:10:36 <tonkman> if I have: A 123 "foobar", and I want: A 123 "barfoo"
13:10:39 <wharzl> i'm noobin over here :(
13:10:42 <Cale> tonkman: You can write  x { foo = 5 } to mean the value which is the same as x except whose foo field is 5
13:10:48 <djahandarie> Cale, I don't think it's spurious to put a binary dependency in the cabal file
13:10:50 <wharzl> do you guys see what I'm intending to do?
13:10:58 <wharzl> if so, could you advise on the right approach?
13:11:14 <Cale> djahandarie: Well... it's not really required for building the program
13:11:21 <qfr> Hmm can guards only be used at the top most level of a function?
13:11:24 <monoidal> wharzl: data Type = Type Typing Binding String; data Expr = EType Type | Morphism [Type]
13:11:29 <monoidal> wharzl: something like this?
13:11:33 <tonkman> Cale: but does it leave other fields blank?
13:11:45 <Cale> tonkman: No, it leaves them the same as they were in x
13:11:59 <wharzl> let me think
13:12:11 <Cale> So if  x = A { foo = 10, bar = "hello" }
13:12:24 <tonkman> Cale: ok, thanks
13:12:26 <Cale> then x { foo = 5 } means  A { foo = 5, bar = "hello" }
13:12:38 <tonkman> that I was looking for
13:12:40 <wharzl> monoidal, is that pretty idiomatic?
13:12:45 <monoidal> wharzl: yes
13:12:51 <wharzl> k nice
13:12:57 <wharzl> thanks ^_^
13:13:04 <mauke> qfr: no, only after declarations
13:14:03 <Cale> guards can be used to qualify any declaration, as well as on each pattern match inside a case expression
13:14:14 <Cale> (any function or pattern binding declaration)
13:14:19 <wharzl> why did you prepend with 'E'?
13:14:25 <wharzl> E for Expression?
13:14:44 <Cale> wharzl: Probably just to make it clear that they're two different things
13:15:02 <Cale> wharzl: It's okay to name them the same, but trickier to talk about on IRC after :)
13:15:03 <monoidal> wharzl: yes, you can't have two different constructors with same names
13:15:08 <wharzl> ah haha
13:15:23 <Cale> You can have a type constructor and a data constructor named the same thing
13:15:32 <Cale> Because they're in separate namespaces
13:15:34 <wharzl> would it be offensive to other's eyes of I named it ExpressionType instead?
13:15:46 <wharzl> I know it's verbose, but I dislike truncation
13:15:47 <monoidal> Cale: Type was used too
13:15:49 <monoidal> as a value
13:15:52 <Cale> ah
13:15:59 <Cale> Well, ignore me then :)
13:16:21 <Cale> If you already have a value named Type, then you can't define another one
13:17:17 <Cale> wharzl: Just remember that the length of names should be proportional to the size of their scope divided by their frequency of occurrence.
13:17:43 <tonkman> I would have another question
13:18:12 <Cale> wharzl: That is, if you have something which is global or exported, you want it to have a longer name, but if it occurs everywhere throughout your code, you might actually want it to be shorter.
13:18:22 <wharzl> ah hmmm
13:18:27 <tonkman> If a function have an argument where it gathers information, is it possible to get around it
13:18:28 <Cale> Think about things like map, or in the extreme case (.)
13:18:32 <tonkman> an example:
13:18:39 <tonkman> umm
13:18:48 <Cale> Their scope is huge, but they're used everywhere, so short names are okay
13:19:02 <lispy_> Cale: hey, how's it going?
13:19:12 <Cale> lispy_: Okay, just rebuilt lambdabot successfully
13:19:14 <lispy_> Cale: I upgraded ghc to 6.12.3 on the linode (merry christmas :P)
13:19:16 <Cale> I think I'll restart it :)
13:19:19 <lispy_> Woot!
13:19:20 <Cale> Yeah, thanks :)
13:19:28 <tonkman> nothing, forget, I get already it :)
13:19:43 <lispy_> Cale: how is the new ghc memory-wise?
13:19:57 <Cale> I wasn't looking
13:20:00 <lispy_> Cale: eg., can it link hello-world.hs in less than 1GB of memory?
13:20:06 <Cale> ahaha
13:20:08 <lispy_> well, if it took one 1GB you'd notice
13:20:17 <lispy_> (you'd hit swap)
13:20:35 <lispy_> They've changed their rates, I should ask them if they can migrate us to a machine with more ram
13:20:47 <mauke> @seen lambdabot 
13:20:47 <preflex>  lambdabot was last seen on #haskell 16 minutes and 7 seconds ago, saying:  Sequence not found.
13:20:53 <lambdabot> Unknown command, try @list
13:21:00 <Cale> It built things just fine, I didn't notice any trouble except that I had to hack the .cabal file a bit to get it to ignore some dependency issues which weren't really dependency issues.
13:21:06 <lispy_> ?let foo = 1
13:21:15 <lambdabot>  Defined.
13:21:17 <lispy_> > foo
13:21:25 <lambdabot>   mueval-core: unrecognized option `--no-imports'
13:21:31 <lambdabot>  Usage: mueval [OPTION...] ...
13:21:31 <lispy_> Kind of laggy, probably IRC thorttling
13:22:27 <Cale> wat
13:22:32 <Cale> oh, great
13:23:24 <monoidal> anyone know if new Platform will have ghc 7?
13:23:25 <Nibble> Damn I hate log bots
13:23:35 <lispy_> monoidal: yes, it will.
13:23:38 <Cale> Nibble: why?
13:23:40 <monoidal> thanks
13:23:54 <lispy_> monoidal: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
13:24:02 <Nibble> Cale: stuff gets indexed on google and shoop da whoop
13:24:09 <Cale> Nibble: ?
13:24:13 <Cale> Isn't that good?
13:24:34 <Nibble> not really, since freenode doesn't mask ip n' stuff
13:24:52 <Cale> monoidal: Basically, the Platform tries to keep up with GHC once the surrounding libraries have stabilised after a new release
13:24:58 <lispy_> You shouldn't assume the internet is anonymous
13:24:59 <Cale> Nibble: so?
13:25:04 <Nibble> lispy_: it should be
13:25:27 <Nibble> but, back laterz
13:25:37 <qfr> Cale: I use resources like that to get active hosts who are known to run certain software so I can run remote exploits on them, for example
13:25:54 <Cale> Nibble: OH NOEZ, THEY COULD WHOSI MY ISP AND KNOW WHO TO CONTACT IN CASE OF ABUSE!!1
13:26:35 <ion> One is always free to IRC over Tor or something.
13:26:42 <dobblego> koala_man, your phat loot?
13:26:43 <monoidal> i think freenode bans tor
13:26:52 <Cale> Or just get a hostmask
13:26:59 <qfr> For example, a new remote exploit for software XYZ pops up on metasploit or whatever, I get a list of addresses for a channel about XYZ from Google and then I run the framework on it and get maybe 5-15% hits depending on age, routers etc
13:27:22 <qfr> So, log bots basically help me with expanding my bot net
13:27:23 <ion> Oh? I thought i’ve seen people with “hosts” like gateway/tor/blahblah on Freenode.
13:27:28 <mauke> qfr: why should I let you live?
13:27:35 <Cale> But come on. If your worst security concern is that someone knows you're running an IRC client, you're probably not looking hard enough.
13:29:35 <wharzl> <3 haskell
13:31:08 <qfr> mauke: I was just kidding
13:31:15 <wharzl> anyone know if there is an Int128?
13:31:41 <dolio> Not in any of the default packages.
13:31:49 <wharzl> hmm
13:31:57 <wharzl> weird
13:32:01 <dolio> I think there's some crypto library that defines larger Ints somewhere, but I couldn't tell you what it is.
13:32:06 <wharzl> ok
13:32:14 <dolio> And I'm not sure if they have 128, either.
13:32:21 <dolio> It might jump to 512 or 1024 or something.
13:32:35 <ion> > let a ♥ b = a ++ " love " ++ b in "I" ♥ "Haskell"
13:32:35 <lambdabot>   mueval-core: unrecognized option `--no-imports'
13:32:35 <lambdabot>  Usage: mueval [OPTION...] ...
13:32:52 <ion> Meh. Works in ghci. :-P
13:33:00 <byorgey> > 3 + 2
13:33:00 <lambdabot>   mueval-core: unrecognized option `--no-imports'
13:33:00 <lambdabot>  Usage: mueval [OPTION...] ...
13:33:08 <byorgey> ion: not your fault, apparently =)
13:33:09 <benmachine> Caaaaaaale it's broooooken
13:33:21 <monochrom> ones
13:33:27 <wharzl> lol
13:33:30 <qfr> Cale probably has no highlight on Caaaaale
13:33:38 <parcs> > ???
13:33:38 <lambdabot>   mueval-core: unrecognized option `--no-imports'
13:33:39 <lambdabot>  Usage: mueval [OPTION...] ...
13:33:52 <revenantphx> Hm, okay 
13:33:52 <revenantphx> https://gist.github.com/755657
13:33:54 <Cale> great, it changed to --noimports for some reason
13:34:01 <benmachine> awesome
13:34:02 <revenantphx> So I got a basic parser working here.
13:34:12 <revenantphx> The thing is, I want to make it repeat indefinitely.
13:34:32 <revenantphx> so on line 29, it needs to somehow return a Continue
13:34:40 <revenantphx> however, for that I need a (Stream -> Iteratee) function.
13:34:57 <revenantphx> Simply put, I don't know how to kick it back into the continue state.
13:35:24 <Cale> > 1 + 2
13:35:32 <lambdabot>   3
13:35:35 <Cale> okay
13:35:56 * benmachine imagines lambdabot spending those nine seconds counting on her fingers
13:36:11 <qfr> does the ($) operator have a name I can actually Google?
13:36:24 <benmachine> qfr: no
13:36:25 <monoidal> http://www.haskell.org/hoogle/?hoogle=(%24)
13:36:27 <qfr> Oh snap
13:36:30 <benmachine> what do you want to know about it
13:36:36 <benmachine> monoidal has a point actually
13:36:38 <parcs> looks like every lamdabot query takes 9 seconds now
13:36:50 <benmachine> @vixen is this slander
13:36:50 <ski> @src $
13:36:58 <lambdabot> love is all you need, you know?
13:37:04 <lambdabot> f $ x = f x
13:37:21 <benmachine> have people seen this? http://kayalang.org/
13:37:25 <benmachine> it looks kinda neat
13:37:30 <benmachine> well, like haskell only not as good :P
13:37:35 <benmachine> but man, that's high praise these days >_>
13:37:48 <mauke> so can I get some patches into lambdabot?
13:38:47 <qfr> benmachine: Hate against the semicolons
13:39:05 <benmachine> qfr: that's totally the most pressing issue in language design :P
13:39:10 <Cale> mauke: Send them to gwern, or I guess I could apply them if he's not around :)
13:39:10 <qfr> benmachine yes
13:39:25 <ski> preflex: why do you respond to `@seen' ?
13:39:54 <revenantphx> So uh, anyone can help with this? https://gist.github.com/755657
13:40:02 <lelf> ?oeis 3 1 4 1 5 9 2
13:40:05 <lambdabot>  Decimal expansion of Pi.
13:40:05 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
13:40:14 <Gracenotes> lag descreasing?
13:40:18 <revenantphx> ?oeis 1 2 3 4 5
13:40:21 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
13:40:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:40:40 <mauke> ski: because people kept using @seen
13:40:42 <lelf> hurrah
13:40:44 <revenantphx> ?oeis 1 3 2 5 4 7 6 9  8
13:40:49 <lambdabot>  Self-inverse permutation of natural numbers: 1 is fixed, followed by infinit...
13:40:50 <lambdabot>  [1,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24,27,26,29,...
13:40:56 <revenantphx> Damn.
13:41:04 <parcs> ?oeis 1
13:41:04 <revenantphx> There's no stumping oeis.
13:41:06 <lambdabot>  a(n) is the number of unique reduced words of length n (i.e. all possible le...
13:41:06 <lambdabot>  [1,5,20,70,240,810,2730,9180,30870,103770,348840,1172610,3941730,13249980,44...
13:41:10 <mauke> and AFAIK ManateeLazyCat still hasn't managed to get a single seen command right, despite seeing dozens of examples
13:41:13 <flamingspinach> rofl
13:41:27 <revenantphx> So guys
13:41:29 <revenantphx> https://gist.github.com/755657 
13:41:31 <flamingspinach> ?oeis 1 11 21
13:41:32 <lambdabot>  Read n backwards (referred to as R(n) in many sequences).
13:41:32 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,1,11,21,31,41,51,61,71,81,91,2,12,22,32,42,52,62,72,82,...
13:41:32 <revenantphx> Any advice here?
13:41:40 <Boxo> ?oeis 9 8 7 6 5 4 3 2 1 0
13:41:43 <lambdabot>  Triangle T(n,k) = n-k, n >= 0, 0<=k<=k. Integers m to 0 followed by integers...
13:41:44 <lambdabot>  [0,1,0,2,1,0,3,2,1,0,4,3,2,1,0,5,4,3,2,1,0,6,5,4,3,2,1,0,7,6,5,4,3,2,1,0,8,7...
13:41:56 <flamingspinach> hm, that's not what I expected
13:42:03 <flamingspinach> ?oeis 1 11 21 1211
13:42:04 <lambdabot>  Look and Say sequence: describe the previous term! (method A - initial term ...
13:42:04 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
13:42:17 <flamingspinach> this sequence is fascinating
13:42:22 <flamingspinach> I wish the original article about it wasn't behind a paywall :/
13:42:41 <revenantphx> ?oeis 3 4 5 7 9 11 12 13 15 16 17
13:42:44 <lambdabot>  Numbers n such that binary representation ends in even number of zeros.
13:42:44 <lambdabot>  [1,3,4,5,7,9,11,12,13,15,16,17,19,20,21,23,25,27,28,29,31,33,35,36,37,39,41,...
13:43:00 <revenantphx> Wait... those are also numbers which form pythagorean triples.
13:43:02 <Icewing> ?oeis 1 3 4 6 8 9 11
13:43:05 <lambdabot>  Lower Wythoff sequence (a Beatty sequence): a(n) = floor(n*phi), where phi =...
13:43:05 <lambdabot>  [1,3,4,6,8,9,11,12,14,16,17,19,21,22,24,25,27,29,30,32,33,35,37,38,40,42,43,...
13:43:09 <revenantphx> Awesome.
13:43:14 <byorgey> revenantphx: you might need to wrap the call to parseBar in a try
13:43:28 <revenantphx> byorgey: attoparsec's "string" doesn't consume on failure
13:43:30 <Boxo> one. one one. two ones. one two, one one. one one, one two, two ones...
13:43:34 <byorgey> revenantphx: oh, ok.
13:43:36 <revenantphx> It works fine, I'm not trying ot "fix" it.
13:43:50 <revenantphx> I'm trying to see how I can make the Yield state go into a Continue state when passes into this enumerator.
13:43:57 <revenantphx> Basically I want the enumerator to loop it forever.
13:44:10 <byorgey> ah, I don't think I can help then
13:44:14 <revenantphx> Well, until an error :P
13:44:41 <revenantphx> Or a Yield with EOF for chunks.
13:44:57 <ski> mauke: would it be irritating to have preflex respond to `@seen' with something like `<nick> : maybe you wanted to try "preflex: seen <other_nick>" ?' ?
13:45:19 <revenantphx> So... no one knows here?
13:45:33 <mauke> ski: that seems pointless
13:46:20 <ski> well, maybe they'd learn to address `preflex' directly, so we avoid lambdabot complaining
13:46:26 <qfr> Is it possible to do f :: a -> b\nf = blah while mentioning f only a single time? I am tired of having the function name twice in so many places
13:47:02 <mauke> ski: one of my lambdabot patches is to make @seen a no-op
13:47:10 <ski> ah, ok
13:47:11 <revenantphx> @seen revenantphx
13:47:11 <preflex>  revenantphx was last seen on #haskell 1 minute and 52 seconds ago, saying: So... no one knows here?
13:47:11 <lambdabot> Unknown command, try @list
13:47:19 <monoidal> qfr: f = blah :: a -> b, but I think you should get used to it unfortunately
13:47:20 <revenantphx> preflex: @seen revenantphx
13:47:20 <preflex>  revenantphx was last seen on #haskell 9 seconds ago, saying: @seen revenantphx
13:47:25 <revenantphx> That's better.
13:47:26 <ski> mauke : that'd be as good, then
13:47:33 <qfr> monoidal :/
13:47:46 <revenantphx> mauke: Maybe to avoid edge cases you could implement @seen as a no-op plugin instead?
13:47:53 <revenantphx> As in, it exists as a command, it just doesn't echo anything.
13:47:55 <ski> (hm ... `f (... :: a) :: b = ...' ?)
13:48:31 <mauke> revenantphx: huh?
13:48:41 <revenantphx> There are two ways to make it shut up about @seen.
13:48:42 * ski can't recall how type variables are currently treated in pattern signatures
13:48:50 <revenantphx> Make it explicitly ignore the command @seen
13:48:53 <qfr> I'm not even sure when I should specify the types of the arguments anyways
13:48:55 <revenantphx> or make @seen a valid command that does nothing.
13:49:04 <mauke> revenantphx: how are those different?
13:49:11 <revenantphx> The first one would be some change to the code itself
13:49:14 <revenantphx> the second is a plugin.
13:49:23 <mauke> revenantphx: how is a plugin not part of the code?
13:49:35 <revenantphx> I mean, I don't know how lambdabot does its plugins, but if it's loading them from a file,
13:49:40 <revenantphx> then it would be easier to change later.
13:50:06 <monoidal> qfr: if you can't tell almost instantly, it's good idea to give the arguments
13:50:08 <ski> qfr : i usually always do it, for top-level definitions .. but i suppose if it's "obvious" enough, you could omit it
13:50:14 <benmachine> revenantphx: I think what you are suggesting is already what happens basically :P
13:50:18 <revenantphx> I think it's better to make @seen a no-op within the constraints of the current system, rather than modifying the system.
13:50:32 <benmachine> *already what is planned
13:50:37 <revenantphx> gotcha then
13:50:54 <revenantphx> I'm just saying that if I had an irc bot that say, scans through a directory and loads all of the modules in them
13:50:58 <monoidal> qfr: if LHS doesn't have any arguments, like "x = 42", then you must give type signature if x has to be polymorphic
13:51:08 <revenantphx> and then maps them all from their name to functions
13:51:22 <revenantphx> if I wanted it to ignore "seen" I'd make a command that registers "seen" but does nothing
13:51:24 <ski> monoidal : no. only if it has to be *constrained* polymorphic
13:51:29 <revenantphx> instead of modifying the map lookup to ignore the keyword.
13:51:34 <monoidal> ski: what do you mean?
13:51:36 <revenantphx> benmachine: do you understand what I mena >_>?
13:51:41 <benmachine> revenantphx: yes
13:51:48 <mm_freak> are there haskell compilers for embedded devices?
13:51:59 <ski> monoidal : `empty = []' is just fine, and will infer `empty :: forall a. [a]'
13:52:02 <mm_freak> without or with a much smaller RTS
13:52:13 <benmachine> mm_freak: there was talk of GHC on android once, if that counts
13:52:40 <benmachine> mm_freak: apart from that I don't know, I think it's more usual to have haskell generate, say, C, that is then compiled for the target platform
13:52:49 <benmachine> that is how atom and friends do it
13:53:07 <mm_freak> benmachine: not really, because i need to write programs for very small devices (16 MHz, 16 KiB RAM, you get the point)
13:53:22 <benmachine> mm
13:53:28 <mm_freak> and C++ is so damned fucking annoying to deal with
13:53:30 <ski> (monoidal : or `get = State (\s -> (s,s))', or whatever .. also note there's a `NoMonomorphismRestriction' in GHC)
13:53:32 <benmachine> heh
13:53:56 <lispy_> > foo
13:53:57 <lambdabot>   1
13:54:10 <lispy_> >
13:54:22 <lispy_> oh hey
13:54:23 <edwardk> lispy! ltns
13:54:26 <lispy_> I found a bug
13:54:26 <qfr> Is Haskell the biggest purely functional programming language nowadays? Are there any others in use? What are the next bigest ones?
13:54:32 <lispy_> > foo
13:54:33 <lambdabot>   1
13:54:35 <qfr> Apparently ML doesn't even consider itself purely functional
13:54:43 <djahandarie> > bar
13:54:44 <lambdabot>   Not in scope: `bar'
13:54:48 <edwardk> qfr: probaby. the scheme/ml guys don't claim purity
13:54:52 <lispy_> Cale: typing only ">" causes a lambdabot process that never goes away
13:54:54 <systemfault> ocaml would be that language (If you consider it as functional)
13:54:57 <lispy_> edwardk: what's up?
13:54:58 <ski> neither SML nor OCaml is pure, right
13:54:58 <mm_freak> qfr: (concurrent) clean
13:55:20 <mm_freak> but i haven't seen any program written in it
13:55:32 <edwardk> lispy: not a whole lot. i need to get back to writing more haskell
13:55:33 <lispy_> qfr: I think Agda is up and coming
13:55:35 <mm_freak> i think haskell is the only such language, which is actually used to do practical stuff
13:55:36 <Heffalump> qfr: Haskell is definitely the biggest.
13:56:03 <lispy_> edwardk: I'm starting to learn Isabelle and I have big plans :)
13:56:05 <qfr> http://en.wikipedia.org/wiki/Agda_%28theorem_prover%29 ;O
13:56:18 <lispy_> edwardk: but, I've also been not going in Haskell much lately too
13:56:23 <edwardk> agda is fun, but i find that the standard library being written almost entirely in unicode singlehandedly by NAD serves as a rather high barrier to entry for folks
13:56:26 <lispy_> s/going/coding
13:56:44 <lispy_> edwardk: yeah, agda is full of growing pains
13:57:03 <qfr> lol it uses Unicode symbols? :D
13:57:03 <lispy_> > 
13:57:04 <lambdabot>   not an expression: `'
13:57:07 <lispy_> >
13:57:12 <qfr> That is awesome, like APL? :p
13:57:19 <djahandarie> qfr, Haskell could also, it just doesn't
13:57:41 <mm_freak> haskell /supports/ unicode symbols for some things
13:57:58 <lispy_> edwardk: I'm trying to get doc-review (it's on hackage) to work with latex so I can do some document authoring
13:58:00 <edwardk> qfr: yes, but not just a little bit. like everything involves unicode subscripted numerals, etc.
13:58:01 <monoidal> also there's Omega, with infinite hierarchy of types
13:58:02 <mm_freak> like you can write UTF-8, but it will also accept the non-UTF-8 variant
13:58:07 <mm_freak> Integer → Bool
13:58:20 <qfr> Glorious, haha
13:58:25 <OmegaYear> hello
13:58:35 <mm_freak> > (λx → x^2) 5
13:58:36 <lambdabot>   Pattern syntax in expression context:
13:58:41 <mm_freak> > (\x → x^2) 5
13:58:42 <lambdabot>   25
13:58:44 <djahandarie> > let x = 1 in x
13:58:45 <lambdabot>   1
13:58:53 <djahandarie> I think lambdabot is broken in PM
13:58:55 <edwardk> lispy: fun, i've been off in scala implementing lots of category theory lately, trying to get the compiler patched to support some of the crazy strains i've been putting on its type system
13:59:24 <lispy_> edwardk: :)  You're experience with Scala matches mine.  Any real programs expose lots of compiler gotchas/bugs.
13:59:27 <lispy_> your*
13:59:37 <dobblego> lispy_, same as lots of people
13:59:51 <edwardk> its so close to useful though =)
14:00:06 <edwardk> i just want product categories to work so i can have bifunctors as functors and indexed monad transformers
14:00:17 <edwardk> that opens the door to a LOT of generalizations
14:00:37 <lispy_> edwardk: cool
14:00:51 <lispy_> I wish applicative was here
14:00:58 <lispy_> He was helping me with this latex stuff
14:01:03 <lispy_> He's a big fan of pandoc
14:01:04 <edwardk> its actually working at the type checking level, but a couple of bugs in how the compiler generates code prevents it from working at runtime
14:01:10 <lispy_> I'm not sure I can use pandoc without writing a lot of code though
14:01:35 <lispy_> ah
14:01:47 <revenantphx> *sigh*
14:01:50 <lispy_> Code generation is hard, let's go type checking!
14:01:53 <revenantphx> no one to help me with iteratee/enumerator thing.
14:02:03 <edwardk> revenantphx: whats your issue?
14:02:14 <revenantphx> I'm just trying to get recursion...
14:02:15 <revenantphx> https://gist.github.com/755657
14:02:15 <lispy_> edwardk to the rescue!
14:02:48 <revenantphx> I'm trying to do a dummy case where it will keep parsing until EOF/error
14:03:00 <revenantphx> So the enumerator needs to convert Yields into Continues
14:03:05 <revenantphx> by some black magic.
14:03:32 <edwardk> hrmm, trying to figure out how to do this in iteratees a la lato, but food just finished, brb ;)
14:04:27 <revenantphx> no problem.
14:05:42 <bsmntbombdood> combineOneOf (OneOf x) (OneOf y) = OneOf (x ++ y)
14:05:48 <bsmntbombdood> what's the right way to write that?
14:06:22 <parcs> make the type of  OneOf an instance of Monoid
14:08:23 <Taejo> read for Int is taking up 91% of my program's runtime -- what's going on?
14:08:35 <lispy_> Taejo: read is slow on int.
14:08:49 <lispy_> Taejo: Are you using String, ByteString, or Text?
14:08:53 <Taejo> String
14:09:06 <Taejo> it's for code golf so I can't import anything
14:09:22 <lispy_> ?hoogle readInt
14:09:23 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
14:09:23 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
14:09:23 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
14:10:00 <lispy_> Taejo: then you could try writing your own read for integers
14:12:31 <revenantphx> edwardk: srry back
14:13:03 <Taejo> lispy_: in Java, Integer.parseInt does all sorts of locale stuff that (I guess) is what makes it slow, but afaik read for ints doesn't do that
14:13:19 <revenantphx> @src readInt
14:13:20 <lambdabot> Source not found.
14:13:25 <edwardk> revenantphx: np, just got back myself.
14:13:44 <revenantphx> So yeah, basically I'm trying to run the iteratee continuously.
14:14:01 <revenantphx> So the input is used in continuation passing style within the Yield statement, instead of returned.
14:14:12 <revenantphx> within the Yield pattern match*
14:14:26 <revenantphx> slight edit: https://gist.github.com/755682
14:14:53 <Taejo> > toEnum '0'
14:14:54 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:14:54 <lambdabot>         against inferred type ...
14:14:56 <Taejo> > toEnum 0
14:14:57 <lambdabot>   ()
14:15:03 <Taejo> > fromEnum '0'
14:15:04 <hpc> heh
14:15:04 <lambdabot>   48
14:15:14 <revenantphx> > toEnum 0 :: Char
14:15:15 <lambdabot>   '\NUL'
14:15:24 <edwardk> *nods*, can't you take an iterateee for A and turn it into an iteratee that returns an (A, and an iteratee for the tail (listT done right/mealy-machine style), and then just consume that?
14:15:25 <revenantphx> > toEnum 64 :: Char
14:15:27 <lambdabot>   '@'
14:15:42 <hpc> > toEnum 9 :: char
14:15:43 <lambdabot>   Could not deduce (GHC.Enum.Enum char) from the context ()
14:15:43 <lambdabot>    arising from a...
14:15:44 <revenantphx> edwardk: I don't know how?...
14:15:45 <hpc> > toEnum 9 :: Char
14:15:46 <lambdabot>   '\t'
14:16:03 <revenantphx> I'm a bit confused by what you mean I guess.
14:16:38 <revenantphx> The iteratee itself is created by iterParser, I just want to modify it with an enumerator to run it recursively on whats left.
14:16:51 <revenantphx> I don't know *how* to make the iteratee for the tail.
14:17:08 <lispy_> > ord '5' - ord '0'
14:17:09 <lambdabot>   5
14:18:13 <edwardk> so what do you want to do with the produced widgets?
14:18:30 <revenantphx> you see on line 26 where they're just printed?
14:18:40 <revenantphx> there I'd have a switch statement and do something unique for each
14:18:51 <revenantphx> or more realistically, feed them onto a Chan for use on another threa.
14:18:51 <tswett> :t callCC
14:18:52 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:19:00 <tswett> :t callCC (\x -> (x, Nothing))
14:19:01 <lambdabot>     Occurs check: cannot construct the infinite type:
14:19:01 <lambdabot>       m = (,) (Maybe a -> m b)
14:19:01 <lambdabot>       Expected type: m (Maybe a)
14:19:11 <lispy_> > let lispyReadInt [] = 0; lispyReadInt (x:[]) = ord x - ord 0; lispyReadInt (x:xs) = ord x - ord 0 * 10 + lispyReadInt xs in lispReadInt "12345"
14:19:12 <lambdabot>   Not in scope: `lispReadInt'
14:19:12 <revenantphx> Either way, they'd be used from within the inputEnum, they don't get returned.
14:19:16 <lispy_> > let lispyReadInt [] = 0; lispyReadInt (x:[]) = ord x - ord 0; lispyReadInt (x:xs) = ord x - ord 0 * 10 + lispyReadInt xs in lispyReadInt "12345"
14:19:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:19:17 <lambdabot>    arising from the literal `0...
14:19:20 <lispy_> doh!
14:19:46 <lispy_> > let lispyReadInt [] = 0; lispyReadInt (x:[]) = ord x - ord '0'; lispyReadInt (x:xs) = (ord x - ord '0') * 10 + lispyReadInt xs in lispyReadInt "12345"
14:19:47 <lambdabot>   105
14:19:50 <lispy_> hehe
14:19:59 <lispy_> Taejo: ydo you get the general idea?
14:20:04 <revenantphx> edwardk: Do you have some idea how to do it?
14:20:06 <edwardk> an enumerator is just a function from an iteratee to an iteratee, right? at that point why not just call iterParser parseWidget >>== inputEnum?
14:20:16 <edwardk> rather than return
14:20:24 <lispy_> (writing it as a foldr should actually be easier, I think)
14:20:35 <revenantphx> Seriously.
14:20:42 <revenantphx> How did I not think of that TT_TTT
14:20:44 <revenantphx> gah
14:20:48 <Taejo> lispy_: yes -- I didn't notice that you were doing it for me: I was working it out in another window
14:20:49 <Phyx-> hmm lispyReadInt is odd
14:20:51 <revenantphx> wait no edwardk 
14:20:57 <Taejo> foldl seems to be the way to go
14:20:58 <revenantphx> I need to feed it the remaining content too.
14:21:11 <edwardk> you have the guts from the yield
14:21:16 <edwardk> feed it from that ;)
14:21:17 <revenantphx> Yeah
14:21:24 <revenantphx> Feed it in where :P
14:21:36 <edwardk> into the resulting iteratee
14:21:40 <revenantphx> how...?
14:21:47 <lispy_> :t foldr
14:21:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:22:00 <edwardk> this is why i hate enumerators, they obscure whats going on under the hood
14:22:25 <revenantphx> hrm?
14:22:32 <lispy_> > foldr (\a acc -> 10 * a + acc) 0 [x,y,y] :: Expr
14:22:33 <lambdabot>   10 * x + (10 * y + (10 * y + 0))
14:22:40 <edwardk> one sec. i'll have to go set up an environment to work the example in full
14:22:47 <edwardk> i don't know how much of ghc i have installed
14:22:50 <lispy_> > foldl (\acc  a -> 10 * a + acc) 0 [x,y,y] :: Expr
14:22:51 <lambdabot>   10 * y + (10 * y + (10 * x + 0))
14:22:55 <Taejo> lispy_: that helped a *lot* -- perhaps something to do with the fact that Read implements a parser rather than just a converter
14:22:57 <lispy_> > foldl (\acc  a -> 10 * a + acc) 0 [x,y,z] :: Expr
14:22:59 <lambdabot>   10 * z + (10 * y + (10 * x + 0))
14:23:12 <Taejo> > read "((((5))))" :: Int
14:23:13 <lambdabot>   5
14:23:14 <lispy_> Taejo: oh, maybe it is a foldl
14:23:51 <revenantphx> edwardk: no problem.
14:24:23 <revenantphx> I just see an enumerator as something taking a step and producing an iteratee (basically a -> m b)
14:24:31 <revenantphx> Hence the similarity in >>== and ==<< with >>= and such.
14:24:48 <revenantphx> No doubt theres a monad instance there.
14:25:16 <edwardk> :w
14:25:22 <edwardk> oops
14:25:24 <revenantphx> ?
14:25:30 <edwardk> wrong window ;)
14:25:30 <Taejo> interestingly, using my own readInt also reduces the amount of allocation by a lot
14:25:51 <revenantphx> What does your readInt look like?
14:25:55 <lispy_> Taejo: did you use foldl or foldl'?
14:26:00 <BMeph> > foldl (\acc  a -> 10 * acc + a) 0 [x,y,z] :: Expr
14:26:00 <lambdabot>   10 * (10 * (10 * 0 + x) + y) + z
14:26:04 <lispy_> Taejo: the latter is stricter and may do better yet
14:26:07 <revenantphx> > readInt "   10" :: Int
14:26:09 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:26:09 <lambdabot>         against inferred type ...
14:26:14 <revenantphx> > read "    10" :: Int
14:26:15 <lambdabot>   10
14:26:31 <Taejo> lispy_: I used foldl because I don't want to import Data.List
14:26:33 <BMeph> > foldl (\acc  a -> 10 * acc + a) 0 [1,0,5]
14:26:33 <lambdabot>   105
14:26:55 <edwardk> hrmm i'm getting no instance for MonadIO for Iteratee Bytestring m when i go to run your code. checking whats wrong with my environment
14:26:56 <Taejo> but reading ints no longer dominates my profile
14:27:00 * benmachine wishes that Monad ((,) w) was in Control.Monad.Instances
14:27:05 <Taejo> now it's lines and words
14:27:27 <lispy_> > foldl (\acc a -> 10 * acc + (ord a - ord '0')) 0 "12345"
14:27:28 <lambdabot>   12345
14:27:30 <revenantphx> This is the paste, reupdated it with what I have to make sure it's correct.
14:27:31 <revenantphx> https://gist.github.com/755682
14:27:33 <benmachine> (or heck, somewhere even nicer, but one can't be too picky)
14:27:41 <benmachine> hmm that's a thought
14:27:58 <benmachine> given that the Prelude defines Monad and doesn't import Monoid
14:28:04 <lispy_> > foldl (\acc a -> 10 * acc + (ord a - ord '0')) 0 "123045"
14:28:05 <lambdabot>   123045
14:28:21 <benmachine> where would we define instance Monoid w => Monad ((,) w) to stop it being orphan?
14:28:40 * BMeph wonders if Taejo meant: (Monoid w) => Monad ((,) w)
14:29:19 <Taejo> BMeph: I think you meant benmachine 
14:29:21 * BMeph thinks he meant benmachine, not Taejo; he apologizes to the latter. :)
14:29:27 <Taejo> no worries
14:29:48 <edwardk> revenantphx: i'm having trouble getting enumerator to work on my mac, sorry
14:29:58 <revenantphx> edwardk: I'm on a mac too.
14:30:01 * BMeph thinks he needs to learn to type better and faster. He looks for "Six-Million Dollar Hands" on Google...
14:30:03 <revenantphx> ghc version/
14:30:04 <revenantphx> ?
14:30:05 <edwardk> not sure whats going on
14:30:13 <revenantphx> do you have any conceptual idea?
14:30:14 <edwardk> 6.12.3
14:30:19 <revenantphx> same.
14:30:36 <benmachine> BMeph: the first time I omitted context for brevity; I don't think the parentheses are necessary
14:30:42 <edwardk> off hand i was going to go code something rather than make an ass out of myself trying to adapt ideas from other iteratee librares to this one that i don't know ;)
14:30:43 <benmachine> unless you have more than one thing in the head
14:30:45 <lispy_> benmachine: either when you define the class or when you define (,), Right?
14:30:56 <benmachine> lispy_: right, except you need Monoid to be in scope
14:31:02 <benmachine> which it isn't in either of those places
14:31:03 <revenantphx> edwardk: What would you do in another iteratee library?
14:31:08 <Taejo> @pl (\y x -> 10*y+fromEnum x-48)
14:31:08 <lambdabot> flip flip 48 . ((-) .) . (. fromEnum) . (+) . (10 *)
14:31:19 <benmachine> Taejo: heard of digitToInt?
14:31:20 <Taejo> :t flip flip 48
14:31:21 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num a) => f (a -> b) -> f b
14:31:31 <lispy_> Taejo: but ord is fewer characters than fromEnum
14:31:43 <edwardk> normally i'd set up the new iteratee, and feed it the remaining input, then return that
14:31:51 * BMeph thought "that's what she said" when benmachine typed "unless you have more than one thing in the head". ;)
14:31:52 <lispy_> oh, is ord not in perlude?  dang
14:32:01 <Taejo> lispy_, benmachine I have to import Data.Char for those
14:32:06 <benmachine> BMeph: :P u
14:32:12 <benmachine> Taejo: poor you :(
14:32:23 <Taejo> benmachine: playing golf
14:32:30 <benmachine> hmm
14:32:32 <benmachine> kfine
14:32:42 <benmachine> but golf is less fun without arbitrary imports :P
14:32:43 <Taejo> https://www.spoj.pl/problems/SUMITR/
14:33:00 <wharzl> is there a standard number type in haskell that can get arbitrarily large and has a floating point?
14:33:09 <benmachine> wharzl: eek, that sounds messy
14:33:23 <monoidal> > showCReal 100 (sin 1)
14:33:24 <lambdabot>   "0.841470984807896506652502321630298999622563060798371065672751709991910404...
14:33:28 <benmachine> wharzl: Data.Fixed gets arbitrarily large, but the point isn't floating (obv)
14:33:38 * BMeph suggests Taejo just use a qualified reference, and a possible renaming, if multiple uses are wanted.
14:33:39 <benmachine> CReal works but is scary and slow
14:33:44 <edwardk> ah your problem is you are returnI'ing step not the right iteratee
14:33:53 <wharzl> ah, ya, I suppose since the number can get arbitrarily large, I don't need a floating point :)
14:33:55 <aristid> benmachine: what's scary about it?
14:33:59 <edwardk> you need the iteratee that you are returning to be the one that wants more input
14:34:17 <benmachine> aristid: the semantics of comparisons for equality are a little alarmins
14:34:29 <wharzl> I just need a number that can be arbitrarily large and can represent non-whole numbers
14:34:40 <benmachine> wharzl: Rational?
14:34:52 <wharzl> that sounds good
14:35:00 <benmachine> wharzl: depends what non-whole operations you need, Rational can't do sqrt or whatever
14:35:07 <benmachine> but is excellent where it's all just division
14:35:23 <wharzl> well, i def need sqrt
14:35:31 <benmachine> hmm
14:35:35 <benmachine> trickier then
14:35:39 <wharzl> I just want a good general number for my language
14:35:42 <edwardk> rev: why not factor out parserIt = iterParser parseWidget ; then main = run $ parseIt >>= inputEnum  — and in inputEnum for Yield you call returnI parseIt
14:35:48 <benmachine> you're asking rather more than you realise :)
14:35:53 <wharzl> I am going to start with a single number type in the language
14:36:05 * BMeph stops trying to play "guess wharzl's use case". :)
14:36:07 <wharzl> then I'll get more specific number types as I go along
14:36:10 <edwardk> the step you are returnI'ing there has the right type, but it won't DO anything other than tell you exactly what you already know
14:36:52 <edwardk> and you can leave your Yield b EOF case alone so that you terminate at EOF
14:37:05 <benmachine> wharzl: imo, no number type does all three of simplicity, accuracy, and sqrt
14:37:24 <wharzl> I can sacrifice accuracy most easily
14:37:24 <tswett> wharzl: if you're just making a general-purpose programming language, I'd say go with double-precision floating point numbers.
14:37:25 <aristid> benmachine: yeah, there is no real comparison for equality for CReal
14:37:39 <benmachine> wharzl: just use normal floating point then?
14:37:44 <aristid> benmachine: that's more of a shortcoming of Num than CReal, i would argue
14:37:53 <edwardk> (i probably missed something to plumb it back into inputEnum though
14:37:56 <benmachine> aristid: well, sort of
14:37:57 <aristid> benmachine: (==) only returning Bool is just way too specific
14:38:00 <tswett> They can't express arbitrarily large numbers exactly, but they can express large numbers exactly.
14:38:07 <benmachine> aristid: nah
14:38:27 <benmachine> it is sufficient for most things and simplifies things immensely
14:38:33 <wharzl> single or double floats sound good enough
14:38:40 <wharzl> not sure which I should choose
14:38:43 <aristid> benmachine: well, sure, Eq is a worthwhile class
14:38:43 <benmachine> wharzl: they can't get arbitrarily large, though
14:38:47 <wharzl> that's fine
14:38:48 <tswett> If you're going to use this language for cryptography or something, then use a double float paired with an integer, I think.
14:38:53 <aristid> benmachine: and it should be the way it is. but Num should not require it
14:38:59 <benmachine> aristid: oh, right, agreed
14:39:03 <wharzl> well, I just want to get the language up and running
14:39:10 <tswett> And... figure out how sqrt and the like are going to work yourself.  >.>
14:39:15 <benmachine> wharzl: I would advise against cutting corners tbh :)
14:39:24 <wharzl> quick and dirty is fine... if a little inefficient and imprecise
14:39:27 <benmachine> wharzl: let me see if I can find you a cautionary tale on this subject
14:39:33 <wharzl> I will put better numerics in later
14:39:39 <revenantphx> Sorry, back.
14:39:46 * BMeph wonders if aristid is one of those who would appreciate Bool being a typeclass, instead of a type...
14:39:54 <wharzl> though a cautionary tale sounds fun :)
14:39:57 <aristid> BMeph: i'm not sure about that
14:40:16 <revenantphx> Lemme reread the backlog.
14:40:45 * BMeph still wonders, despite aristid's response.
14:40:47 <benmachine> wharzl: http://www.haskell.org/pipermail/haskell-cafe/2007-June/027092.html
14:40:51 <aristid> BMeph: it would not really help in the case of CReal, because what (==) for CReal should return is something like Precision -> Bool
14:41:00 <wharzl> hehe
14:41:02 * wharzl reads
14:41:22 <kmc> class Eq a b where { (==) :: a -> a -> b }
14:41:28 <kmc> useful for EDSLs too
14:41:46 <tswett> class Eq a b | a -> b
14:41:47 <Heffalump> it's tricky though, do you have an a -> b fundep or not?
14:41:54 <tswett> Or not.  :P
14:42:01 <aristid> tswett: that would be pretty interesting
14:42:29 <aristid> (with the fundep)
14:42:37 <benmachine> wharzl: you can pretty much just skimread, the conclusion of the thread is the main point
14:43:10 <revenantphx> edwardk: returnI parseIt wouldn't work
14:43:13 <BMeph> aristid: It would also mess up anyone who wanted to try: (Eq a b, SomeClass c) => Eq a (c -> b)
14:43:37 <aristid> BMeph: would it?
14:43:45 <revenantphx> parseIt is an Iteratee, returnI lifts a step to an iteratee.
14:43:58 <Heffalump> without the fundep, if a == b then x else y becomes painful
14:44:01 <aristid> BMeph: i don't really see the problem there. am i blind?
14:44:08 <Heffalump> with the fundep, you find yourself annoyingly restricted
14:44:12 <BMeph> aristid: If "Eq a b | a -> b" holds, then yes.
14:44:32 <aristid> Heffalump: but a lot less restricted than with the current Bool-only system
14:44:36 <benmachine> Heffalump: surely if a == b then ... gives you the result type of ==?
14:44:43 <benmachine> so you don't need the fundep
14:44:56 <Heffalump> sorry, I was imagining a world with overloaded if then else too
14:45:01 <Heffalump> which you tend to also want in an EDSL
14:45:02 <bsmntbombdood> so i just started with haskell and parsec, and for parsing regex character classes like [a-z] i get this: http://hpaste.org/42570/parsec
14:45:04 <bsmntbombdood> am i doing it wrong?
14:45:04 <benmachine> oh right
14:45:07 <edwardk> revenantphx: sorry, not familiar with the type signatures here in this lib, which is why i wanted to hack up something locally first ;)
14:45:34 <wharzl> while we're on the subject, what's the diff between Rational and Double?
14:46:04 * BMeph prefers to imagine a world where "if/then/else" has been strangled with the entrails of the last "return"... ;)
14:46:08 <benmachine> wharzl: Rational is basically two Integers
14:46:13 <tswett> Rational can store arbitrary-precision rational numbers; Double can't.
14:46:18 <wharzl> ah
14:46:20 <benmachine> it can represent addition, subtraction, multiplication, division with perfect accuracy
14:46:30 <wharzl> that's cool
14:46:34 <wharzl> sounds harder to work with thoug
14:46:39 <byorgey> it's not.
14:46:40 <benmachine> but doesn't support floating-point operations like sqrt or sin or exp or whatever
14:46:55 <byorgey> > 3 / 5 * 99 + 3/22 :: Rational
14:46:56 <lambdabot>   6549 % 110
14:46:57 <wharzl> interesting
14:47:15 <benmachine> you should always use rational if it's powerful enough
14:47:18 <Cale> There's no transcendental functions for Rational though
14:47:31 <benmachine> yeah
14:47:41 <Cale> (like trig/exponential/etc.)
14:47:45 <benmachine> not even any algebraic functions :P
14:47:48 <benmachine> well, er
14:47:53 <kmc> <benmachine> you should always use rational if it's powerful enough <-- and if you don't care about speed
14:47:54 <Cale> and it can be significantly slower in some cases where all you need is an approximation
14:48:01 <benmachine> oh
14:48:04 <benmachine> I thought they were fast
14:48:11 <Cale> They're fast for what they are
14:48:12 <benmachine> but I guess doubles are faster
14:48:13 <kmc> they're not slow in particular
14:48:19 <kmc> but Double will have hardware support, with GHC
14:48:22 <benmachine> yeah
14:48:22 <kmc> on most platforms
14:48:30 <kmc> while Rational uses Integer which usually uses libgmp
14:48:35 <kmc> which isn't slow, but much slower
14:48:53 <aristid> isn't Integer avoiding GMP for really small integers?
14:49:03 <kmc> it avoids GMP for Int-sized integers
14:49:13 <aristid> which will be the case very often
14:49:33 <kmc> but you still have a constructor which has to be checked and boxed/unboxed etc
14:49:46 <kmc> which probably inhibits unboxing optimizations
14:50:26 <kmc> Rational is probably fast enough for most stuff (don't forget, orders of magnitude more people use CPython than will ever use GHC) but don't be surprised if Double is a lot faster
15:02:14 <tonkman> http://haskell.org/ghc/docs/6.12.2/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t%3A%28%2C%29
15:02:23 <tonkman> lol.
15:02:44 <benmachine> they're all super-useful
15:03:41 <tonkman> yeah, but I thought that they are defined some other way
15:05:24 <benmachine> they are, in a sense
15:05:29 <benmachine> they're not really definable in haskell
15:05:31 <benmachine> they're syntax
15:07:27 <tswett> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:07:28 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:07:29 <lambdabot> t63. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 ->
15:07:29 <lambdabot> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> (a, b, c,
15:07:29 <lambdabot> d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53,
15:07:29 <lambdabot> t54, t55, t56, t57, t58, t59, t60, t61, t62, t63)
15:07:33 <tswett> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:07:34 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:07:34 <lambdabot> t63 t64. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36
15:07:34 <lambdabot> -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 ->
15:07:35 <monochrom> heh
15:07:36 <lambdabot> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51,
15:07:38 <lambdabot> t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64)
15:07:44 * benmachine eyebleed
15:07:49 <tswett> That doc page is lying; it said (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) is the biggest.  :P
15:08:05 <benmachine> at that point GHC gets bored listing them
15:08:19 <benmachine> but I think they're probably arbitrarily deep
15:08:26 <monoidal> the last one shouldn't be present
15:08:29 <lispy_> > let (,) = (+) in 1 , 2
15:08:30 <lambdabot>   <no location info>: parse error on input `,'
15:08:33 <sipa> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:08:35 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:08:35 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k ->
15:08:35 <lambdabot>  l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45
15:08:35 <lambdabot> -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 ->
15:08:35 <lambdabot> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> t93 -> t94 -> t95 -> t96 -> t97 -> t98 -> (a, b, c, d, e, f, g, h,
15:08:36 <lispy_> > let (,) = (+) in (1 , 2)
15:08:37 <lambdabot> [3 @more lines]
15:08:39 <monoidal> that should give an error
15:08:39 <lambdabot>   Constructor `(,)' should have 2 arguments, but has been given 0
15:09:20 <monoidal> tuples over 62 have (,,,,) seemingly available but cannot be used
15:09:49 * hackagebot highlighter 0.1 - source code highlighting  http://hackage.haskell.org/package/highlighter-0.1 (AlexSuraci)
15:09:53 <monoidal> > let u =(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
15:09:54 <lambdabot>   not an expression: `let u =(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...
15:10:02 <monoidal> > seq ((,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) ()
15:10:03 <lambdabot>   ()
15:10:35 <monoidal> @let u =(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
15:10:36 <lambdabot>  Defined.
15:11:08 <Phyx-> wtf
15:11:43 <Ke> > u
15:11:44 <lambdabot>   Ambiguous occurrence `u'
15:11:44 <lambdabot>  It could refer to either `L.u', defined at <local...
15:11:50 <djahandarie> > L.u
15:11:51 <lambdabot>   No instance for (GHC.Show.Show
15:11:52 <lambdabot>                     (t,
15:11:52 <lambdabot>                     ...
15:11:52 <Phyx-> @undefine
15:12:02 <djahandarie> I think he wanted the defined one.
15:12:12 <Ke> =D
15:12:15 <Ke> not really
15:12:25 <Phyx-> > u
15:12:26 <lambdabot>   u
15:12:27 <djahandarie> > u -- this one isn't as interesting
15:12:28 <lambdabot>   u
15:12:32 <monoidal> try typing in ghci: let u =(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
15:15:54 <monoidal> > (\((,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) -> 1) $ (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
15:15:55 <lambdabot>   mueval-core: GhcException "\nDuring interactive linking, GHCi couldn't find...
15:17:44 <wharzl> > mod(10, 2)
15:17:45 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> (t, t1))
15:17:45 <lambdabot>    arising fro...
15:18:16 <monoidal> :t mod
15:18:17 <lambdabot> forall a. (Integral a) => a -> a -> a
15:19:00 <benmachine> > uncurry mod(10,2)
15:19:01 <lambdabot>   0
15:19:31 <Phyx-> how imperative of you
15:19:39 <shachaf> @seen BONUS
15:19:39 <lambdabot> Unknown command, try @list
15:19:40 <preflex>  BONUS was last seen on #haskell 9 hours, 14 minutes and 54 seconds ago, saying: too late i already did haha
15:19:54 * hackagebot PBKDF2 0.3.1 - Make password-based security schemes more secure.  http://hackage.haskell.org/package/PBKDF2-0.3.1 (JeremyShaw)
15:19:54 <ion> That has nothing to do with imperative programming. :-P
15:20:49 <Phyx-> k
15:55:10 <Veinor> et
16:01:13 <leod> et
16:01:46 <ion> &
16:02:32 <revenantphx> et?
16:02:38 <revenantphx> ???
16:03:01 <unkanon> et == &
16:04:11 <ion> ðηըᚧ⁊
16:04:46 <revenantphx> unkanon: oh, that et
16:04:56 <systemfault> French?
16:05:01 <revenantphx> " Occurs check: cannot construct the infinite"
16:05:02 <unkanon> latin
16:05:02 <revenantphx> bleh
16:05:08 <revenantphx> and french I believe.
16:05:21 <unkanon> french got it from latin
16:05:32 <revenantphx> yep.
16:05:35 <revenantphx> Now heres a question for you.
16:05:50 <revenantphx> Did the song "Que Sera Sera" derive its name from french or spanish :)
16:06:00 <revenantphx> Que Sera, Sera*
16:06:16 <systemfault> Spanish probably
16:06:20 <systemfault> It's not french
16:06:22 <unkanon> that looks spanish yeah
16:06:34 <unkanon> I don't think the future of etre is sera
16:06:40 <to_On1> Spanish
16:06:50 <systemfault> In french, yes.
16:06:50 <revenantphx> It's also french I believe.
16:06:52 <revenantphx> I know it's spanish.
16:07:00 <systemfault> sera == will be
16:07:01 <revenantphx> "will be" in french is sera
16:07:19 <revenantphx> I know it's valid spanish, I believe its also french
16:08:02 <systemfault> It's valid in both language... But the pronounciation of it I heard it spanish :P
16:08:13 <unkanon> revenantphx: hmm you're right
16:08:17 <systemfault> Que sera, sera (Whatever will be... will be)
16:08:17 <unkanon> according to google translate
16:08:21 <revenantphx> It's not valid spanish though.
16:08:27 <revenantphx> I mean, any person would understand you,
16:08:30 <revenantphx> but its not grammatical.
16:08:34 <systemfault> Ah
16:08:44 <revenantphx> que sera would be a question asking "what will be?"
16:08:48 <unkanon> I believe it is grammatical
16:08:51 <revenantphx> It's not.
16:08:57 <revenantphx> "lo que sera" is "what will be"
16:09:04 <revenantphx> "que sera" is "what will be?"
16:09:12 <unkanon> oh indeed, you gotta use those little words 
16:09:13 <revenantphx> whan is a question, the other is a thing.
16:09:15 <revenantphx> one*
16:10:26 <wharzl> can I compile multiple .hs files into a single module?
16:10:26 <Veinor> so 'lo' is like 'that which'?
16:10:49 <Veinor> also, 'que sera sera' in the song is pronounced like spanish
16:10:54 <revenantphx> "lo que" is "that which" kind of.
16:10:54 <Veinor> oh wait systemfault said that
16:11:01 <revenantphx> lo is "that"
16:11:15 <revenantphx> as in, "that I am ordering tonight"
16:11:18 <revenantphx> Not "that thing over there"
16:11:27 <revenantphx> thuht, not thaht
16:13:24 * revenantphx has successfully derailed #haskell again :D
16:15:15 <p_l|backup> heh, it was only language talk. Get them to talk about time-traveling incest :> (my favourite pieve of derailment that happened on #android-dev)
16:15:45 <ion> Derail #haskell, huh? Vim is so much better than GNU GRUB! KDE totally beats Debian!
16:16:07 <systemfault> If you're a creationist... would having sex with eve be incest?;
16:16:09 * systemfault hides
16:16:30 <systemfault> ion: Totally.
16:17:23 <wharzl> does each .hs file have to be in its own module?
16:19:09 <aristid> ion: the standard way to derail #haskell is to mention c++
16:19:43 <wharzl> the only reason I can figure to use C++ is for hard real time programming
16:21:01 <wharzl> but noone would let me program for something that vital
16:22:03 <systemfault> Games....
16:22:35 <systemfault> That's the field where C++ is the most popular.
16:23:03 <Quadrescence> Why is there an ambiguity: http://codepad.org/JOqX3k0e
16:23:12 <wharzl> true, but I still wouldn't use it for that if I had a choice
16:23:51 <Quadrescence> woops, http://codepad.org/8ECwilR7
16:23:51 <wharzl> games are soft real time and there are other possibilities for that than C++
16:24:32 <wharzl> you could probably use OCAML
16:25:40 <conal> Quadrescence: because Int can't be deduced in your first try
16:25:52 <conal> Quadrescence: because of overloading of numeric literals
16:26:21 <conal> Quadrescence: try: listToPoly [1,2,3 :: Int,4,5]
16:27:18 <Quadrescence> conal: That works too. But I don't quite understand what the ambiguity is still. What else can the type be?
16:27:35 <conal> Quadrescence: for instance Integer instead of Int
16:27:54 <conal> Quadrescence: but lots of other possibilities, e.g. polynomials, functions, derivative towers.
16:28:16 <conal> Quadrescence: anything with a Num and a Monoid instance
16:28:27 <mauke> Quadrescence: Integer, Double, Float, Rational, Complex Double, (), Char, String, [Integer], (Char, Char) -> Int
16:28:31 <Quadrescence> conal: And I only have Int with a Monoid instance.
16:28:45 <mauke> I CAN CONTINUE
16:28:50 <conal> Quadrescence: you only stated an instance for Int. there are lots of others.
16:29:48 <conal> Quadrescence: e.g. in ghci say ":info Monoid"
16:30:01 <conal> Quadrescence: you'll see lots of others.
16:30:30 <Quadrescence> conal: I see instance Monoid Int
16:30:59 <conal> Quadrescence: and no others? not even lists?
16:31:19 <Quadrescence> I defined Monoid to be a typeclass with "add" and "addId"
16:31:20 <conal> Quadrescence: oh!
16:31:45 <conal> Quadrescence: you defined your own Monoid class. that's why. even so, there can be others.
16:32:05 <Quadrescence> Yes, theoretically there can be. And that holds true with just about everything in Haskell.
16:32:49 <conal> Quadrescence: and that's the ambiguity. the compiler cannot know that there aren't other instances. just that it hasn't seen any yet.
16:33:56 <wharzl> yay, I got my interpreter running :)
16:34:09 <conal> Quadrescence: i think this behavior is referred to as "the open world assumption".
16:34:10 <wharzl> (for my new language, that is)
16:35:41 <conal> Quadrescence: i guess the behavior you expected is like nonmonotonic logic. where learning new information invalidates previous deductions. 
16:36:20 <Quadrescence> conal: So let me get this straight. Haskell reads 5, and just determines that it is of type Num t => t. So we have [Num t => t]. Use polyToList, we have that [(Num t, Monoid t) => t]. And it is not able to tell what t can possibly be because I perhaps would define more instances of Monoid in the future, and therefore it can't discern that it is the only current possibility: an Int
16:36:43 <mauke> no, (Num t) => [t]
16:36:53 <Quadrescence> I am using shorthand, mauke
16:37:05 <Quadrescence> (well, it's not actually shorthand)
16:37:14 <conal> Quadrescence: right (modulo mauke's correction).
16:37:15 <Quadrescence> (but emphasis)
16:37:17 <mauke> you are using syntax errors and/or different types
16:37:25 <mauke> but yes
16:37:33 <Quadrescence> mauke: I'm not talking to Haskell interpreters, I'm talking to humans over the internet.
16:37:50 <mauke> I am a Haskell interpreter
16:37:52 <jmcarthur> no, you're talking to programmers. big difference between humans and programmers
16:38:01 <conal> jmcarthur: :)
16:38:04 <mauke> and I read [Num t => t] as [forall t. Num t => t]
16:38:48 <Quadrescence> jmcarthur: big difference between: Haskell Programmer => Programmer and Human, you mean
16:39:38 <jmcarthur> Quadrescence: sure, Programmer can be an instance of Haskell i guess :)
16:39:58 <jmcarthur> (but honestly i'm not sure what you meant to say there)
16:40:15 <Quadrescence> I meant to say that Haskell programmers are distinct from humans, not all programmers.
16:40:50 <jmcarthur> not sure i'd agree
16:41:01 <jmcarthur> in what other field is your worth estimated by the length of your beard?
16:41:13 <Quadrescence> unix programmers
16:41:22 <Quadrescence> C programmers (see K&R)
16:41:33 <jmcarthur> pretty much all programmers, as far as i see it
16:41:49 <Quadrescence> you don't see very far
16:42:09 <jmcarthur> i see that #haskell is off topic. i should rectify this
16:42:11 * jmcarthur gets back to work
16:56:53 <monochrom> I am a haskell programmer and a non-human.
16:59:56 <aristid> monochrom: list commands
17:06:16 <tolkad> Does anyone know of software for the automatic conversion of lambda calculus to SKI combinators?
17:08:44 <tolkad> I guess I'll just write it myself then
17:13:57 <monochrom> I am a turtle. I have no commands.
17:14:46 <mauke> I like turtles
17:16:11 <aristid> turtles are ninjas
17:28:05 <tolkad> ... this is kind of hard
17:28:39 <tolkad> I don't think it's possible to convert without multiple passes
17:29:41 <zygoloid> monochrom: RIGHT 30. PEN DOWN. FORWARD 50. RIGHT 120. FORWARD 50. LEFT 180. FORWARD 100. PEN UP.
17:29:43 <aristid> tolkad: maybe if you've got it working with multiple passes you can see a way to do it in less passes? :)
17:29:49 <tolkad> actually... I guess I can jsut recursively call the function until I'm done with the outermost layers, no need to parse the whole thing each time
17:30:31 <tolkad> but that still requires a transitionary data structure
17:30:46 <mauke> just use @pl
17:31:00 <tolkad> @pl
17:31:01 <lambdabot> (line 1, column 1):
17:31:01 <lambdabot> unexpected end of input
17:31:01 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:31:11 <c_wraith> zygoloid, are you calling monochrom a turtle?
17:31:20 <hpc> @pl \a b c d e f g -> a c d b e g f
17:31:20 <lambdabot> ((((flip .) .) .) .) . flip . (flip .)
17:31:32 <aristid> c_wraith: he did so himself.
17:31:36 <tolkad> but what if I want it in terms of specific combinators?
17:31:47 <hpc> :t ((((flip .) .) .) .)
17:31:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4) => f4 (f3 (f2 (f1 (f (a -> b))))) -> f4 (f3 (f2 (f1 (
17:31:48 <lambdabot> a -> f b))))
17:31:48 <aristid> @remember monochrom I am a turtle. I have no commands.
17:31:49 <lambdabot> Nice!
17:31:54 <aristid> @quote turtle
17:31:55 <lambdabot> monochrom says: I am a turtle. I have no commands.
17:32:54 <zygoloid> @quote command
17:32:54 <lambdabot> command says: lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.
17:33:12 <mauke> preflex: quote
17:33:22 <preflex>  <tm604> i write php when I'm angry, why waste the rage?
17:33:26 <zygoloid> preflex: seen preflex
17:33:26 <preflex>  what
17:33:33 <systemfault> Haha.. damn php
17:33:41 <tolkad> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
17:33:42 <lambdabot> ap (. join id) (. join id)
17:33:52 <tolkad> :t ap (. join id) (. join id)
17:33:53 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
17:33:53 <lambdabot>     Probable cause: `id' is applied to too few arguments
17:33:54 <lambdabot>     In the first argument of `join', namely `id'
17:34:50 <qfr> <zygoloid> monochrom: RIGHT 30. PEN DOWN. FORWARD 50. RIGHT 120. FORWARD 50. LEFT 180. FORWARD 100. PEN UP.
17:34:54 <qfr> Is that a swastika?
17:35:38 <mauke> not even close
17:43:47 <tolkad> SVG to the rescue: http://pastebin.com/35QizkR7
17:43:56 <revenantphx> Hrm.
17:44:06 <tolkad> still not sure what it's supposed to be though
17:44:16 <revenantphx> Anyhow see the issue here?
17:44:16 <revenantphx> https://gist.github.com/755782
17:44:24 <revenantphx> I'm unable to figure out where the infinite type is coming from.
17:44:52 <tolkad> revenantphx: what line is the error on?
17:44:57 <revenantphx> 35.
17:44:59 <revenantphx> It says in the gist.
17:45:03 <tolkad> oh nevermind didn't see that
17:45:36 <revenantphx> I'm just not seeing it :|
17:46:00 <revenantphx> Maybe it's becuase Enumerator comes out to Step -> Iteratee?
17:46:51 <revenantphx> I believe the end type for that is
17:46:52 <revenantphx> (Step a m b -> Iteratee a m b) -> (b -> m () -> (Step a m b -> Iteratee a m b)) 
17:46:59 <revenantphx> er
17:47:03 <revenantphx> (Step a m b -> Iteratee a m b) -> (b -> m ()) -> (Step a m b -> Iteratee a m b))
17:47:07 <revenantphx> (Step a m b -> Iteratee a m b) -> (b -> m ()) -> (Step a m b -> Iteratee a m b)
17:47:08 <revenantphx> gah
17:47:09 <revenantphx> there we go.
17:47:37 <tolkad> rubber duck debugging
17:47:45 <revenantphx> tolkad: what?
17:47:58 <tolkad> explain your code to a rubber duck
17:48:05 <revenantphx> quack
17:48:09 <revenantphx> quack quack quack quack
17:48:13 <revenantphx> quack quaaaack
17:48:15 <revenantphx> okay, now what.
17:48:17 <tolkad> http://en.wikipedia.org/wiki/Rubber_duck_debugging
17:48:25 <tolkad> oh you didn't find the answer?
17:48:35 <tolkad> thought that's what you meant when you said "there we go"
17:48:40 <revenantphx> No, I did not.
17:48:48 <revenantphx> I kept typing the type wrong.
17:48:57 <revenantphx> I'm still unable to see where the infinite type is coming imnm.
17:48:59 <revenantphx> in*
17:49:30 <revenantphx> It's just that line, if I comment it out, the other definition is fine.
17:50:57 <revenantphx> What exactly there is infinite!!!
17:51:06 <revenantphx> How is m = Iteratee a m
17:51:08 <revenantphx> D:
17:51:41 <mauke> add type annotations to subexpressions
17:51:50 <revenantphx> huh, wait
17:51:56 <revenantphx> if I remove n <- f b
17:51:57 <revenantphx> it works
17:52:02 <revenantphx> something's up with that line I think.
17:52:10 <revenantphx> But I don't see how anything could be wrong with it...
17:53:02 <mauke> add type annotations to subexpressions
17:53:12 <mauke> tell the compiler exactly how wrong it is
17:53:45 <revenantphx> TT_TT
17:53:55 <tolkad> you want to use an extension for that
17:54:03 <tolkad> ScopedTypeVariables I think it is?
17:54:10 <revenantphx> Wait what?
17:54:25 <mauke> whatever it takes
17:54:42 <tolkad> it allows you to use type variables from the function type signature in annotations of the functions code
17:54:46 <revenantphx> Oh, I see... it seems 'a', 'm', and 'b' are existing inside the function
17:54:52 <revenantphx> It seems that's already happening.
17:55:04 <revenantphx> If I do liftM f b
17:55:05 <revenantphx> it says
17:55:09 <revenantphx> b = Iteratee a m b
17:55:15 <bsmntbombdood> can someone critique my code?
17:55:18 <bsmntbombdood> http://hpaste.org/42571/bsmntbombdood
17:55:19 <tolkad> just enable ScopedTypeVariables and add "forall a m b." to the beginning of the function type signature
17:55:20 <revenantphx> doesn't make much sense anyhow
17:55:27 <bsmntbombdood> parsec for regular expressions
17:56:31 <tolkad> bsmntbombdood: well there's your first problem, you used spaces for indentation instead of tabs
17:57:04 <bsmntbombdood> well obviously, i'm not a complete fool
17:57:43 <tolkad> bsmntbombdood: tabs for indentation, spaces for alignment
17:58:03 <mauke> bsmntbombdood: see what hlint says at the bottom
17:58:04 <tolkad> then someone can adjust indentation using their editors configuration
17:58:25 <revenantphx> I just use spaces for everything :|
17:58:25 <tolkad> bsmntbombdood: I'm just kidding, that's just personal preference
17:58:33 <revenantphx> soft tabs ftw
17:58:37 <mauke> tolkad: which lines does that apply to?
17:58:50 <mauke> AFAICS all of his lines are alignment
17:59:07 <revenantphx> bsmntbombdood: a regex parser is amusing :3
17:59:08 <tolkad> mauke: 20 - 22?
17:59:30 <mauke> debatable
17:59:33 <bsmntbombdood> revenantphx: why?
18:00:11 <tolkad> bsmntbombdood: why not just use a regex?
18:00:12 <revenantphx> Idk XD
18:00:13 <mauke> incidentally I've been thinking about a delambdifier using regexes
18:00:16 <revenantphx> tolkad ^
18:00:17 <revenantphx> :
18:00:25 <mauke> turns out it's too complicated
18:00:48 <revenantphx> I'm still not able to fix my issue :\
18:01:11 <tolkad> revenantphx: did you try annotating subexpressions? that's what I do when I can't figure out an infinite type error
18:01:11 <bsmntbombdood> use a regex to parse a regex?
18:01:14 <bsmntbombdood> can't be done
18:01:26 <tolkad> bsmntbombdood: perl regex have recursion
18:01:28 <revenantphx> tolkad: what do I need to enable again? ScopedTypeVariables?
18:01:49 <bsmntbombdood> perl regexes aren't regular expressions
18:02:02 <tolkad> I know. they're still called regex though
18:02:08 <tolkad> revenantphx: yes
18:02:24 <tolkad> revenantphx: and add "forall a m b." to the beginning of the function type signature
18:02:33 <bsmntbombdood> what does that have to do with my code though ^_^
18:02:38 <revenantphx> what does that do again tolkad?
18:02:46 <tolkad> revenantphx: this will put those type variables in scope in any annotations within the function body
18:02:47 <revenantphx> explicit polymorphism?
18:03:06 <revenantphx> does the forall go before or after the typeclass constraint?
18:03:18 <tolkad> revenantphx: before
18:03:24 <revenantphx> so
18:03:25 <revenantphx> repeatI :: forall a m b. Monad m => Enum...
18:03:29 <tolkad> yes
18:03:40 <revenantphx> ok... lets see then
18:04:01 <tolkad> now you can add annotations to subexpressions in the function body and use the type variables a, m, and b in those annotations
18:04:01 <revenantphx> okay, both expressions are annotated, same error
18:04:12 <revenantphx> hrm
18:04:18 <tolkad> revenantphx: keep adding annotations until you find the problem
18:04:45 <revenantphx> (f :: (b -> m ())) (x :: b) :: m ()
18:04:54 <revenantphx> Thats annotated to hell, and it's not helping >_<
18:05:05 <tolkad> maybe the type error is somewhere else?
18:05:11 <revenantphx> If I remove that line it works.
18:05:41 <tolkad> revenantphx: replace it with "undefined :: m ()"
18:06:09 <revenantphx> Same error.
18:06:22 <tolkad> revenantphx: then the error is in the second line
18:06:37 <revenantphx> What's weird though, is when I remove the first one the error dissapears.
18:06:49 <tolkad> revenantphx: in other words, the first and second line have conflicting types
18:06:53 <revenantphx> hm
18:07:16 <revenantphx> yeah, if I make it undefined :: Iteratee a m b and remove the second line it's fine.
18:07:38 <revenantphx> time to annotate the second line to hell...
18:09:02 <revenantphx>     returnI (step :: Step a m b) >>== (inEnum :: Enumerator a m b) >>== (spliceI :: Stream a -> Enumerator a m b) (s :: Stream a) >>== repeatI (inEnum :: Enumerator a m b) (f :: b -> m ()) :: Iteratee a m b
18:09:03 <revenantphx> Nothing.
18:09:05 <revenantphx> Same error.
18:10:02 <tolkad> revenantphx: how can "Iteratee a m b" be the same type as "m ()"?
18:10:11 <revenantphx> It's not...
18:10:27 <revenantphx> :: Iteratee a m b is the type on the entire line.
18:10:37 <revenantphx> f is ( b -> m ())
18:11:30 <tolkad> yes but they are in the same monad do statement, don't they need the same monad type?
18:11:44 <tolkad> in other words shouldn't m = Iteratee a m?
18:11:51 <revenantphx> agh
18:12:11 <revenantphx> so what do I need to do here to fix it?
18:12:28 <revenantphx> returnI shouldn't even be in a monad, what am I doing here...
18:12:47 <revenantphx> hrm.
18:12:54 <revenantphx> I need to though, need the side effects
18:13:03 <revenantphx> egh.
18:13:07 <revenantphx> I need to think this through a bit.
18:13:21 <tolkad> I'm sorry I can't help more. not familiar with Data.Enumerator
18:13:30 <revenantphx> I can probably lift the second statement somehow.
18:17:01 <etpace> can anyone help with a type error i'm getting? http://hpaste.org/42572/takusen it cant match DBM mark Session a with: forall mark1. DBM mark1 Session a1
18:17:11 <etpace> I'm using scoped type variables as I want the mark/a to  unify
18:19:52 <revenantphx> tolkad: 
18:19:56 <revenantphx> this fails with a lot of errors ...
18:19:57 <revenantphx> https://gist.github.com/755806
18:20:08 <revenantphx> for example, I mena.
18:20:21 <revenantphx> This whole deal seems a bit odd.
18:20:43 <revenantphx> er sorry, wrong paste
18:20:54 <revenantphx> updated it.
18:21:47 <revenantphx> oh, forall fixes it?...
18:25:04 <tolkad> revenantphx: consider « f :: a -> a; f x = x », you can't write « f :: a -> a; f x = (x :: a) » because "a" isn't in scope, you can fix this by enabling ScopedTypeVariables and specifying that you want to keep a in scope using "forall": « f :: forall a. a -> a; f x = (x :: a) »
18:25:23 <revenantphx> gotcha.
18:25:35 <revenantphx> Right now I'm removing the do block and just trying to get that to work alone, since I broke something else.
18:26:54 <revenantphx> I need to figure out why it doesn't go on forever as it is.
18:27:03 <revenantphx> I had this working as a specific case, and this is my attempt to generalize it.
18:28:50 <revenantphx> urr.
18:28:55 <revenantphx> ouch, that was a silly mistake
18:29:05 <revenantphx> I renamed all of a functions patterns except the most general one
18:30:12 <BMeph> etpace: You're effectively trying to "pin down" the "mark" type in using withSession, when the definition of that function says "the compiler gets to choose". So it's complaining.
18:31:22 <etpace> hmm
18:31:37 <etpace> how would I correct this?
18:33:45 <BMeph> etpace: My first stab at it would be: remove the type annotation on safeSession.
18:33:55 <etpace> yeah, i've tried inlining it now
18:33:57 <etpace> and it's no help
18:34:13 <etpace> also trying a (safeAction `asTypeOf` action)
18:35:25 <etpace> http://hpaste.org/42573/takusen_annotation?pid=42573&lang_42573=Haskell
18:35:33 <etpace> safeAction compiles, safeConnect does not
18:36:40 <lispy_> etpace: takusen?
18:36:42 <BMeph> etpace: Next step: edit safeAction's typesig to conform.
18:36:46 <etpace> yup lispy_ 
18:37:37 <BMeph> E.g. safeConnect :: forall a. (Typeable a) => FilePath -> (forall mark. DBM mark Session a) -> IO a
18:39:52 <etpace> ah, cheers
18:40:54 <etpace> ttp://hpaste.org/42574/takusen_annotation_annotati was the types that work if you are interested
18:53:54 * hackagebot contstuff 1.0.0 - Fast, easy to use CPS-based monad transformers  http://hackage.haskell.org/package/contstuff-1.0.0 (ErtugrulSoeylemez)
18:53:57 * hackagebot dnscache 0.1.2 - Caching DNS resolver library and mass DNS resolver utility  http://hackage.haskell.org/package/dnscache-0.1.2 (ErtugrulSoeylemez)
18:59:56 * hackagebot contstuff-transformers 0.1.1 - Deprecated interface between contstuff 0.7.0 and the transformers package  http://hackage.haskell.org/package/contstuff-transformers-0.1.1 (ErtugrulSoeylemez)
19:17:33 * ManateeLazyCat pasted "dynload.hs" at http://paste2.org/get/1163828
19:17:33 <ManateeLazyCat> Ghc is instance of MonadIO, why above code get error : "No instance for (MonadIO GHC.Ghc) arising from a use of `liftIO' at Dynload.hs:32:16-21" ? I'm confuse, somewhere wrong?
19:19:58 <ManateeLazyCat> Why liftIO can't work?
19:20:13 <monochrom> GHC's own MonadIO
19:20:51 <aristid> ManateeLazyCat: multiple different MonadIO classes?
19:21:09 <monochrom> it's in MonadUtils
19:21:13 <ManateeLazyCat> Oh, monochrom is right, i use wrong liftIO
19:21:23 <ManateeLazyCat> monochrom: Thanks, yes, should use liftIO in MonadUtils
19:21:34 <ManateeLazyCat> Copy wrong code 
19:21:41 <micahjohnston> do cofunctors exist, and if so, what are they?
19:21:51 <ManateeLazyCat> I just confuse my other code use liftIO can work, why this version can't work.
19:22:04 <ManateeLazyCat> I use liftIO in Control.Monad.Trans
19:23:04 <ManateeLazyCat> monochrom: Wow, i success! Yes!
19:23:25 <ManateeLazyCat> monochrom: Change/update user's configure in *runtime* !
19:23:50 <ManateeLazyCat> Wow, cool, just use GHC API.
19:25:32 <ManateeLazyCat> It's so cool, can't waiting mix it in Manatee
19:26:28 <lispy_> micahjohnston: they are just functors according to a recent post on haskell-cafe
19:26:48 * ManateeLazyCat pasted "dynload.hs" at http://paste2.org/get/1163838
19:26:49 <ManateeLazyCat> Above is code, need write some framework to handle *type mismatch in different version*. 
19:27:04 <ManateeLazyCat> monochrom: Thanks for help! Bye. :)
19:27:29 <micahjohnston> lispy_: all right, thanks
19:28:14 <micahjohnston> lispy_: found the haskell cafe post; reading it
19:28:26 <wharzl> Can someone help me understand how to get line 9 to work - http://hpaste.org/42575/asdadsf
19:28:43 <wharzl> I guess I have to do some strange sort of destructuring?
19:29:49 <Axman6> wharzl: you need to match on (ListExpression (List contents))
19:30:16 <wharzl> ah, I was wondering how to do that
19:30:17 <wharzl> thanks :)
19:30:22 <monochrom> meaning: showExpression (ListExpression (List contents)) = ...
19:30:48 <Axman6> why not make List a type? yupe List = [Expression]?
19:30:52 <Axman6> type*
19:31:22 <wharzl> i thought I did?
19:31:33 <wharzl> data List = List [Expression]
19:31:38 <monochrom> he means type synonym, type List = [Expression]
19:31:43 <wharzl> ah
19:31:48 <Axman6> no, you've made a new data type which contains a list in its only constructor
19:32:06 <Axman6> use `type List = [Expression]`, and youir original code will work
19:32:10 <Axman6> -i
19:32:31 <wharzl> ah neat
19:33:23 <Axman6> making new types let you do things like type Point = (Double, Double), which is nice
19:33:37 <monochrom> I wouldn't call that "new type"
19:33:43 <monochrom> or "make a type"
19:33:50 <Axman6> uh, yeah
19:35:17 <wharzl> ya, less indirection
19:35:54 <wharzl> makes me need a lot of tuples tho
19:36:29 <Axman6> well, the alternative is data Point = Point Double Double, which is basically exactly the same
19:36:30 <wharzl> tho I don't suppose that means anything
19:36:37 <Axman6> no, not really
19:44:50 <zeiris> I'm having trouble with type inference and multi-parameter type classes :https://gist.github.com/755837
19:45:38 <zeiris> I've defined some helper functions for hopping between Word8/16/32, but something like low.low (::Word32->Word8) doesn't seem to get properly type inferred. :(
19:45:57 <zeiris> Is this a known limitation of multiparam typeclasses, or am I missing something?
19:54:36 <fmapE> So is the only reason for requiring parallelism in GHC for efficiency?
19:54:52 <fmapE> (Is it semantically possible to evaluate everything in parallel?)
19:55:03 <roconnor> zeiris: MPTC is almost useless without eith FunDeps or Type Families
19:55:09 <Axman6> i don't understand the question
19:55:26 <fmapE> Axman6: my question?
19:55:32 <Axman6> yes
19:55:46 <fmapE> GHC requires the par and pseq combinators for explicit parallelism
19:55:58 <Axman6> it is semantically possible to evaluate things that don't depend on each other in paralle in haskell, yes
19:56:08 <fmapE> but what prevents it from simply evaluating forced thunks in several threads?
19:56:11 <fmapE> ok
19:56:17 <Axman6> fmapE: yes, because automaitcally parallelising something efficiently is extremely hard
19:56:24 <fmapE> ok
19:57:15 * hackagebot regex-pderiv 0.0.9 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.0.9 (KennyLu)
19:57:38 <Axman6> like, you could write the fibonacci function as fibs 0 = 1; fibs 1 = 1; fibs n = a `par` b `pseq` a + b where a = fibs (n-1); b = fibs (n-1) and it will run in parallel, but perform very badly
19:57:44 <fmapE> ok
19:58:07 <Axman6> (or rather, the compiler could turn the usual definition of the fibonacci function into that)
19:58:14 <fmapE> is there a good place to find an explanation of why?
19:58:36 <fmapE> (Google hasn't been helpful)
19:59:04 <Axman6> but, if you do something like fibs n | n < 15 = fibs' n | otherwise  = <parallel version above> where fibs' n = fibs' (n-1) + fibs' (n-1) ....
19:59:05 <DevHC> SPJ says: if u look at the data flow graph of an algorithm, u may see that it may not be parallelized at all.and even if it can be, it's still hard to get a decent granularity.
19:59:09 <ddarius> par is cheap but not free.
19:59:25 <ddarius> You don't want to spark a thread to add two ints.
19:59:31 <Axman6> fmapE: because the cost of forking a computation of to run in parallel may be more expensive than the actual work being computed
19:59:55 <DevHC> in ghci i do this:
20:00:02 <DevHC> let f = [[]..[]]
20:00:13 <DevHC> this gives some error about enums
20:00:15 <DevHC> now i do:
20:00:18 <Axman6> > [[]..[]]
20:00:19 <lambdabot>   No instance for (GHC.Enum.Enum [a])
20:00:19 <lambdabot>    arising from a use of `e_1' at <inte...
20:00:23 <DevHC> let f a = [[]..[]]
20:00:29 <DevHC> this does not give me any error
20:00:34 <fmapE> ddarius:
20:00:34 <DevHC> that is until i try to use f
20:00:37 <DevHC> even like:
20:00:40 <DevHC> let g = f
20:00:47 <DevHC> then i get an enum error again
20:00:52 <etpace> laziness
20:01:01 <DevHC> orly
20:01:04 <fmapE> ddarius: Why could you not have several threads looking for the next thunk that needs to be evaluated?
20:01:05 <Axman6> no, it should type check it when defined, that is odd
20:01:08 <etpace> yup lazy typechecking mate
20:01:28 <DevHC> so: bug? or old ghc?
20:01:30 <DevHC> or?
20:01:50 <Axman6> > let f a = [[]..[]] in id 3
20:01:51 <lambdabot>   3
20:01:57 <Axman6> > let f a = [[]..[]] in f 1
20:01:58 <lambdabot>   No instance for (GHC.Enum.Enum [a])
20:01:59 <lambdabot>    arising from a use of `e_11' at <int...
20:02:01 <Axman6> how odd
20:02:01 <fmapE> or am I understanding wrong?
20:02:02 <aristid> DevHC: just lack of instance
20:02:07 <DevHC> H$X
20:02:24 <aristid> Axman6: why? the definition is not invalid because somebody may define an instance later
20:02:32 <aristid> :t let f a = [[]..[]] in f
20:02:33 <lambdabot> forall t a. (Enum [a]) => t -> [[a]]
20:02:43 <Axman6> fair enough
20:03:02 <Axman6> i was pretty sure there wasn;t lazy typechecking in haskell
20:03:13 <aristid> it's not lazy
20:03:28 <DevHC> if "let f a = [[]..[]]" shouldn't give errors, then why does "let f = [[]..[]]" give errors?
20:03:49 <ddarius> fmapE: If you are talking about speculative evaluation then that's fine and has been looked into for GHC and Haskell.  The point is that the overhead of the parallelism, no matter how you approach it, can easily be more than doing the operations sequentially.
20:03:50 <aristid> Axman6: i don't know the word for a polymorphic type becoming monomorphic
20:03:53 <Axman6> :t [[]..[]]
20:03:54 <lambdabot> forall a. (Enum [a]) => [[a]]
20:03:59 <fmapE> ok
20:04:20 <DevHC> besides, ghci is basically an interactive do statement writer, u can't define an instance later
20:04:22 <DevHC> amiwrong?
20:04:23 <fmapE> that wasn't quite what I was thinking of
20:04:47 <Axman6> DevHC: any chance you could talk like an adult? :\
20:04:52 <aristid> DevHC: well, ghci can't, but that does not mean they use a different language implementation to reflect that fact
20:04:54 <DevHC> NO U
20:05:09 <ddarius> fmapE: If you aren't talking about speculative evaluation, then there is no need to "find" the "next thunk."  You have to be at the thunk for it to be the next.
20:05:15 <fmapE> ok
20:05:22 <fmapE> perhaps that was phrased wrong
20:05:36 <fmapE> I have only thought about this a bit
20:05:59 <fmapE> if you added each thunk that needs to forced to a queue
20:06:11 <fmapE> I'm sure the same problem would still exist
20:06:16 <fmapE> I'm just trying to understand how
20:06:31 <ddarius> fmapE: Something like that is what is happening.  The point is "adding to a queue" is already more work than adding two ints.
20:06:37 <fmapE> ok
20:07:18 <fmapE> ddarius: thanks it makes more sense now
20:07:58 <lispy_> What does this cabal error, exit 11 mean? http://dpaste.com/290988/
20:08:36 <DevHC> let's forget about ghci (the i part that is)
20:09:33 <DevHC> the file "f a = [[]..[]] ; main = return ()" compiles without errors (ghc file.hs -o a.out)
20:09:54 <DevHC> the file "f a = [[]..[]] ; g = f ; main = return ()" does NOT compile, it gives errors about enums
20:11:30 <aristid> DevHC: that's the monomorphism restriction
20:12:29 <DevHC> the file "f a = [[]..[]] ; g a = f a ; main = return ()" compiles
20:12:37 <DevHC> still monomorphism restriction? :P
20:12:38 <aristid> DevHC: that's the monomorphism restriction
20:12:58 <aristid> f a = [[]..[]] ; g :: (Enum [a]) => t -> [[a]]; g = f ; main = return ()
20:13:02 <aristid> this should compile too
20:13:19 * hackagebot sphinx 0.3.6 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.3.6 (GregWeber)
20:13:57 <aristid> DevHC: the monomorphism basically says "a definition that looks like a constant value, must have a monomorphic type"
20:14:16 <DevHC> looks like a constant value?
20:14:27 <aristid> DevHC: where monomorphic means that it must be Int or [Char] or (), ..., but not Integral a => a
20:14:28 <DevHC> to me g = f looks like a function definition
20:14:43 <aristid> well, to GHC g = f looks like a constant value
20:14:54 <aristid> the monomorphism restriction is stupid if you ask me
20:14:57 * DevHC looks up some docs
20:14:57 <aristid> and you can turn it off
20:15:07 <aristid> but it is active by default
20:15:34 <aristid> but it is advisable to write down top-level type signatures anyways, which prevent the monomorphism restriction from kicking in
20:15:37 <aristid> which is what i did
20:15:50 * ddarius would recommend the explanation of the monomorphism restriction and it's motivation in the Report.
20:16:08 <ddarius> That said, it seems to have been a mistake so it will probably go away in the not distant future.
20:17:28 <aristid> RWH just gets hand-wavey about it, but still mentions it in the first chapter or so
20:18:03 <blackdog> at least it's not defended
20:18:17 <aristid> that made me think "what is that? why can't they tell me?"
20:18:21 * hackagebot sphinx 0.3.7 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.3.7 (GregWeber)
20:18:38 <blackdog> i got very tired reading "let over lambda" having to read the ardent justifications of two namespaces for functions and data
20:19:17 <blackdog> hard enough to choose a good tool for the job without wading through fanboyism
20:19:41 <ddarius> blackdog: Just ignore the users.
20:20:09 <aristid> blackdog: wasn't the justification along the lines of "without two-cell, the macro system would not work well"?
20:20:11 <blackdog> ddarius: this was in the book, though - i wanted to know a bit more about lisp + macros, so it seemed a good source
20:20:21 <ddarius> Splitting my ball of yarn into two balls is probably going to leave me with too little cordage.
20:20:48 <lars9> why strictness of foldl' is implemented using seq, not ! ?
20:20:57 <blackdog> aristid: i can't remember the justification any more. i'd understand separate namespaces for functions and macros, maybe.
20:21:07 <ddarius> lars9: ! is an extension (except in data types).
20:21:17 <blackdog> it just seems artificial once you're used to passing functions around
20:21:23 <aristid> blackdog: i don't really understand lisp macros, so i can't comment
20:21:35 <ddarius> blackdog: It is.  I don't find the argument compelling.  It doesn't seem to stop the Schemers.
20:21:47 <lars9> ddarius: so how to implement foldl using !?
20:22:01 <ddarius> @src foldl
20:22:01 <lambdabot> foldl f z []     = z
20:22:01 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:22:11 <lars9> foldl', sorry
20:22:13 <ddarius> Simple put the ! on the first (or both) z.
20:22:16 <lars9> @src foldl'
20:22:17 <lambdabot> foldl' f a []     = a
20:22:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:22:29 <aristid> ddarius: scheme and macros is a bit of a headache isn't it? with r5rs adopting an unloved hygienic macros syntax, and r6rs abandoning it again?
20:22:33 <blackdog> ddarius: the claim is that scheme is inadequate for big hairy macrology
20:22:40 <lars9> :t ()
20:22:41 <lambdabot> ()
20:22:48 <lars9> :t (\!x -> 1)
20:22:49 <lambdabot> parse error on input `->'
20:22:52 <ddarius> blackdog: Which is laughably false.
20:22:55 <lars9> :t (\x -> 1)
20:22:56 <lambdabot> forall t t1. (Num t1) => t -> t1
20:23:08 <ddarius> Or perhaps Schemers only do big not-hairy macrology.
20:23:13 <aristid> :t \ !x -> 1
20:23:14 <lambdabot> Illegal bang-pattern (use -XBangPatterns)
20:23:17 <blackdog> ddarius: it may well be. they claim that capture etc is important
20:23:25 <blackdog> i don't have the background to be able to say
20:23:35 <aristid> lars9: seems like lambdabot does not have that extension active
20:23:43 <blackdog> i've occasionally wanted macros for code generation in haskell, and found TH pretty awkward
20:24:00 <lars9> aristid: my ghc neither
20:24:02 <blackdog> could well be my inadequacy, though.
20:24:11 <ddarius> blackdog: Being able to capture is important, but that doesn't mean you need to separate values and function into separate namespaces.
20:24:24 <aristid> lars9: you can activate it
20:24:44 <blackdog> ddarius: oh, right. yeah. i guess there's just the accident that scheme has both 1 namespace and hygienic macros
20:26:03 <ddarius> blackdog: Scheme implementations have had non-hygienic macros for longer than they've had hygienic ones and most of the research in the late '90s covered approaches that would allow controlled capture.
20:26:24 <lispy_> cabal-install is segfaulting during 'cabal configure' on network-bytestring on my machine
20:26:29 <lispy_> Anyone know what's up with that?
20:26:44 <ddarius> Scheme has never really been a "program to the standard" kind of language.
20:27:50 <blackdog> ddarius: have you got a scheme background, then?
20:27:55 <lispy_> I think ghc-pkg is buggy
20:27:56 <aristid> then there might even be a 2-cell scheme? :D
20:28:06 <blackdog> could you recommend a book for a haskeller who doesn't quite get the point of macros yet? :)
20:28:14 <lispy_> Resolving dependencies...
20:28:14 <lispy_> cabal: internal error: unexpected package db stack
20:28:18 <ddarius> blackdog: TH has a lot of usability issues (and historically has had a lot of completeness issues) but fundamentally it's pretty much the same as CL style macros.  It does have to do more than is asked of lisp macros though.
20:29:27 <blackdog> every time i have to do something meta i end up pulling out something like HINT, producing binaries, and dlopen-ing them in
20:29:31 <blackdog> it's not very elegant.
20:29:54 <lars9> ddarius: it's said to be -fglasgow-exts, but still does not work in my ghc
20:31:40 <zeiris> roconnor: thanks for the tip, fundeps trivially fixed it :)))
20:32:33 <ddarius> lars9: I don't know what you're reading that is telling you to use -fglasgow-exts, furthermore, as demonstrated by lambdabot, it tells you exactly what compile flag to provide.  I'd, however, recommend looking through GHC's user guide.
20:32:34 <lispy_> okay, so having two copies of process was making cabal segfault
20:33:01 <kilo_> hi
20:34:18 <ddarius> blackdog: In my opinion macros are massively oversold in both their abilities and their necessity by many lisp programmer's.  They are definitely useful, but they aren't -that- big a deal.  A short list of what I think macros can add is here: http://lambda-the-ultimate.org/node/687#comment-18142
20:35:58 <jakestothard> hello. I get "Non-exhaustive patterns in function extractTree" when I try to use the shuffle function in the random-shuffle package. I'm very new to haskell. Can someone see if random-shuffle works for them?
20:36:22 <blackdog> ddarius: hm. it's always been the staged programming side that appeals to me
20:36:33 <blackdog> syntax isn't so interesting.
20:37:25 <blackdog> as it stands, though, i'd like to be able to specify a data structure in haskell as a potentially long-running, expensive computation, but one that can be done at compile time
20:37:34 <aristid> jakestothard: use shuffle'
20:37:46 <blackdog> and have some way of indicating to the compiler that it's ok to go ahead and evaluate it fully, then save the result in the binary
20:38:03 <ddarius> blackdog: TH allows you to do that (though GHC may choke on the result.)
20:38:07 <jakestothard> aristid: thanks I'll try that
20:38:13 <c_wraith> We want supercompilation!
20:38:37 <ddarius> Of course, TH would still allow you to spit out binary data and link it in.
20:38:59 <ddarius> blackdog: But, stuff like that would fall under either domain specific optimization or generating from a spec.
20:39:46 <blackdog> ddarius: really? so if i have a Map in memory, I can write out the binary and mmap it straight back in? or are you talking about having a Binary instance, or something similar?
20:39:49 <ddarius> An example of the kind of thing I mean by generating from a spec, is producing recursive equations to form a state machine from a more traditional state machine representation.
20:40:08 <aristid> jakestothard: that module works pretty well, but it is a bit brittle. i have written a similar function in random-extras
20:40:17 <aristid> @hackage random-extras
20:40:17 <lambdabot> http://hackage.haskell.org/package/random-extras
20:40:22 <ddarius> blackdog: TH code is just normal Haskell.  In fact, there's no such thing as a "TH function."
20:40:48 <c_wraith> Though functions with a return type Q Exp are rarely useful outside of TH splices :)
20:43:08 <ddarius> But, GHC has difficulty linking large static data structures.  This has nothing to do with Template Haskell.  However, you could, using whatever format you want, Binary would work, and then link it in and deserialize.  You can't, unfortunately, output it in a way that would allow you to immediately use the structure without doing evil things.
20:43:27 <c_wraith> I think GHC is less bad at large static data structures now
20:43:49 <c_wraith> As in, it doesn't segfault on them so often
20:44:54 <ddarius> c_wraith: The problems have usually been performance issues when compiling.
20:45:09 <c_wraith> Well, it used to crash.  It's still *really* slow compiling them
20:45:27 <c_wraith> the whole BCO > 64k crash thing was caused by large static structures
20:45:42 <ddarius> I could care less about GHCi in those situations.
20:48:25 <lispy_> ddarius: shouldn't you be on the road?
20:48:58 <blackdog> ddarius: yeah, i looked into the evil things a while back - my favourite was emacs's trick of triggering a core dump so it had an image to load back in and restart from.
20:49:08 <blackdog> nothing very principled though:)
20:49:28 * hackagebot bson 0.1.2 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1.2 (TonyHannan)
20:51:17 <bsmntbombdood> is there any relation between a Monad and a Monoid?
20:51:29 <c_wraith> Yes, but pretend there isn't :)
20:51:39 <c_wraith> @quote endofunctor
20:51:39 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
20:52:04 <bsmntbombdood> ...?
20:52:10 <ddarius> lispy_: I decided to replace something extremely time-consuming, grueling, and brutal on my car, with something that was somewhat less time-consuming, grueling, and brutal on my body.  Though even that probably won't happen, and I may just fall back on my original plan of climbing rocks with no safety equipment.
20:52:28 <jakestothard> aristid: so in random-extras I would use weightedShuffle giving everything an equal weight?
20:53:04 <c_wraith> bsmntbombdood, Just treat them as entirely different.  There are theoretical connections, but they aren't especially practical in the context of using them.
20:53:19 <aristid> jakestothard: no, just use shuffle
20:53:27 <bsmntbombdood> ok, what are the theoretical connections?
20:53:38 <ddarius> copumpkin's quote explains it.
20:53:55 <aristid> jakestothard: http://hackage.haskell.org/packages/archive/random-extras/0.18.1/doc/html/Data-Random-Extras.html#2
20:54:38 <aristid> jakestothard: a small warning. random-extras has worse performance than random-shuffle, and random-fu also contains an alternative method for shuffling
20:57:48 <lispy_> ddarius: ah
20:58:02 <lispy_> So, why does my computer hate me?
20:58:25 <lispy_> I was ale to install sqlite from hackage, but when cabal links it, it cannot resolve the symbols
20:58:29 <ddarius> lispy_: Don't take it personally.  All computers hate all people.
20:58:32 <lispy_> So, is that a problem with the sqlite package?
20:58:37 <ddarius> (Can't say that I blame them though.)
20:58:42 <lispy_> heh, yeah
20:58:55 <jakestothard> aristid: Thanks, since I'm just writing a text based blackjack as practice it won't matter too much. Bye
20:58:59 <monochrom> this is why I am a turtle. the computer doesn't hate me. :)
20:59:18 <lispy_> I would have expected that if I could build/install sqlite then it should link correctly
21:00:46 <lispy_> adding --ld-options="-lsqlite" didn't seem to make a difference
21:01:09 <lispy_> http://dpaste.com/290993/
21:01:14 <lispy_> That's the error I'm talking about it
21:02:21 <lispy_> why doesn't anyone magically know the answer to my question :)
21:03:03 <monochrom> at the price of magically gaining remote desktop root access of your computer
21:03:30 <ddarius> monochrom: Cale already has that.
21:03:53 <monochrom> oh good, then Cale with solve it
21:04:04 <ddarius> Exactly.
21:04:16 <lispy_> heh
21:04:35 * lispy_ thinks he found a workable workaround
21:04:50 <lispy_> hmm..nope
21:08:57 <lispy_> Can anyone else here install things that depend on sqlite on osx?
21:13:23 <augur> "In Haskell we think for quite a long time before starting typing."
21:13:25 <augur> god this is so true
21:16:57 * ddarius needs to find a safety pin.
21:27:45 * BMeph is always confused by programmers who seem to talk as if thinking before programming were a Bad Thing...
21:28:18 <path[l]> heh
21:28:28 <path[l]> there is another side to it
21:28:32 <path[l]> bit its far far away
21:28:39 * hackagebot mongoDB 0.9.1 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.9.1 (TonyHannan)
21:28:52 <path[l]> there are people who plan too much
21:29:03 <path[l]> and since plans sits on plans of stuff they havent  verified
21:29:10 <path[l]> it sorta falls apart
21:29:15 <path[l]> castles in the sky
21:29:28 <path[l]> the "just do" philosophy is to counter that
21:29:49 <lispy_> thinking driven development is good
21:29:59 <lispy_> TDD
21:30:53 <path[l]> Ive been on projects where its happened
21:31:21 <path[l]> we took over this "grand architecture" that had been through 2 consultancies that had failed to deliver
21:31:32 <path[l]> the first set had super overengineered it
21:31:35 <blackdog> path[l]: tend to agree - it's good to build something incomplete that's at least partially useful as quickly as you can
21:31:45 <path[l]> we could see the layers upon layers they had designed
21:31:49 <blackdog> you can't get any customer feedback if it doesn't do anything yet.
21:31:51 <path[l]> that didnt make sense
21:32:09 <path[l]> and stuff where they had a good idea that had been dashed to peices by reality
21:32:18 <path[l]> the second set had under engineered it
21:32:34 <path[l]> they put kids out of college on it and said "we're agile! write code"
21:32:48 <path[l]> who had made this horrible mess out of the whole thing
21:32:59 <path[l]> worst thing Ive ever worked on
21:33:25 <blackdog> path[l]: i found it's kinda useful to have both types on a team. my boss writes some of the most awful code i've ever seen, but it's enough for me to see what he's trying to do and then clean it up
21:33:53 <path[l]> yeah, I too like to be on projects where this is a tension between different types
21:34:39 <path[l]> its also nice for me personally because when I see people who are of one type I can pick some biases and lets stuff be handled via discussion rather than do that tempering in my head
21:34:45 <path[l]> so for example 
21:34:45 <path[l]> i
21:35:12 <path[l]> m the type who tends to value long term over short term. 
21:35:34 <path[l]> but thats useful when Im interacting with people who do the opposite
21:38:45 <manateeUser> Test manatee on TV. :)
21:41:01 <jmcarthur> there are more than one way to think about a project before writing it, some ways typically more reliable than others. of course it's a bad idea to design your entire architecture up front, but that doesn't mean that it's a bad idea to try to grasp the meaning of what you are about to try to accomplish before taking each step
21:41:20 <jmcarthur> wordy sentence is wordy
21:43:01 <blackdog> jmcarthur: sure. likelihood of success has a lot to do with it, too. in most business projects, the job itself is not theoretically that difficult - your most likely screwup is in not understanding what the customer wants
21:43:20 <blackdog> whereas in a PhD/paper/academic situation, there's a good chance most things you try will fail, and that's ok...
21:43:51 <manateeUser> Bye all. :)
21:45:04 <ddarius> jmcarthur: I find my sentences have an uncomfortably high percentage of words.
21:47:06 <path[l]> jmcarthur:  I agree. There is a healthy balance and finding it is a good a mix of common sense and experience. 
21:49:28 <jmcarthur> path[l]: i think what i was trying to say is that i don't think it's so much a balance as it is subdividing the idea of upfront design into simpler ideas and *then* deciding which ones are good and which ones are bad
21:49:57 <jmcarthur> path[l]: that is, i think taking upfront design to an extreme is ideal, but only if you're limiting the definition somewhat
21:50:31 <lispy_> any ideas what I'm doing wrong? http://dpaste.com/291006/
21:50:45 <jmcarthur> path[l]: mainly, i think i'm arguing in favor of a rigorous specification
21:50:48 <lispy_> nm says the symbol exists, and I pass the library name directly to gcc/ld, but it still can't find tem
21:51:32 <path[l]> ah ok. Im not sure what you mean by extreme in that case. so for example if you have 2 tasks, I would argue that a reasonable spot to get to is where you limit the likelyhood of variance in one task affecting the other so it can be worked in independently
21:51:51 <lispy_> I think it's actually collect2 that needs them
21:52:10 <jmcarthur> path[l]: sounds like you are describing modular programming, to me
21:52:55 <jmcarthur> a rigorous specification helps that, of course, but i don't think it's (only) what i'm trying to say
21:54:37 <path[l]> yes I understand, that's the reason why I'm not sure. The reason being Ive noticed that when I have come up with a rigorous specification before hand Ive invariably built more complex solutions than necessary. Most of it having to do with things where I was uncertain about how something worked
21:55:24 * lispy_ tries deactivating iconv and adding ports to his LD path
21:55:29 <jmcarthur> path[l]: a specification is going too far if it starts talking about operational details, IMO
21:55:44 <lispy_> \o/
21:55:45 <lispy_> that was it
21:56:51 <jmcarthur> path[l]: i think this is part of the reason i've become such a fan of denotational semantics. it allows you to make a specification in complete isolation of implementation
21:57:14 <path[l]> hmm Im not sure what that is
21:57:28 <ddarius> All you have to do is think up a mathematical model of Enterprise Java Beans.
21:57:53 <jmcarthur> ddarius: :( and that's why people don't normally speak in terms of denotational semantics
21:57:53 <path[l]> traditionally Ive preferred to think of this in terms of risk. i.e the parts Id like to specify before hand are the parts that feel like they'd be more expensive to change later
21:58:12 <path[l]> yeah I dont even know what denotational semantics is
21:58:37 <jmcarthur> path[l]: if it's possible that it will change later at all then either you don't know what you're doing in the first place or you're inadvertantly talking about implementation, i think
21:59:17 <jmcarthur> path[l]: note that i'm kind of taking an academic angle to this that most software engineers would probably hate
21:59:46 <path[l]> yes I am talking about implementations. But that's because I allow implementation details to affect my choice of design. The problems Im solving are rarely of the nature where there are many complicated algorithms in place
21:59:56 <path[l]> I see the difference now
22:00:35 <jmcarthur> "that's because I allow implementation details to affect my choice of design" <-- a habit i'm still trying to break
22:01:39 <path[l]> is that really a bad thing?
22:02:17 <path[l]> Im coming from the "code should be easy to grasp" point of view. So the implementation detail seems to matter
22:02:41 <jmcarthur> i'm coming from the "*interfaces* should be easy to grasp" point of view ;)
22:03:16 <ddarius> "The code is so easy to grasp.  What I'm supposed to be doing is less so, but who cares?!"
22:04:35 <path[l]> ddarius: oh by which I also mean that it should be easy to grasp why something is happening. Id like that communication at all levels
22:04:46 <path[l]> but hmm
22:05:13 <path[l]> let me read about denotational semantics
22:05:14 <jmcarthur> to me, "code should be easy to grasp" doesn't have much to do with the kind of specification i'm talking about. they are independent
22:06:18 <path[l]> this distinction is probably best understood if we had a sample problem 
22:33:57 <ddarius> Now I get to decide between garter or stockinette stitch.
22:41:26 <j-invariant> can I kas here about comma category? o
22:42:03 <copumpkin> j-invariant: probably the most likely place to know anything about one :)
22:43:24 <copumpkin> j-invariant: I "implemented" them a while back here: http://web.student.chalmers.se/~stevan/ctfp/html/Category.Categories.Comma.html#309
22:43:40 <copumpkin> although I'm not sure that's particularly illuminating
22:44:09 <j-invariant> so you have (T : Functor A C) (S : Functor B C)
22:44:47 <j-invariant> what I don't understand is this http://en.wikipedia.org/wiki/Cone_%28category_theory%29 - we have functors Delta : C --> C^J and F : J --> C. How can we form the comma category Delta,F?
22:45:09 <j-invariant> Delta is backwards
22:47:01 <dolio> I think F is supposed to be the constantly F functor with type C -> C^J there.
22:48:09 <dolio> Like, if you have a functor F : A -> C, and an object D of C, then there's a comma category F, D, where the second functor takes all objects to D, and morphisms to the identity on D.
22:48:55 <dolio> Only in this case, the objects are functors J -> C.
22:50:18 <j-invariant> dolio: that's an amazingly confusing way to write this stuff
22:50:25 <ddarius> CT notation is significantly overloaded and massively implicit.
22:50:38 <dolio> It's quite confusing in this particular case, I'll give you that.
22:50:50 <Axman6> the C++ of mathematical notations?
22:50:58 <dolio> It makes more sense when you're defining slice categories as special comma categories or something.
22:51:19 <copumpkin> j-invariant: contrast it with the horrendous explicitness of the agda rendition (which may not even be correct!)
22:51:34 <ddarius> Categorists do the same thing with the slice notation.  You can have C/X and also F/X.
22:51:58 <j-invariant> can I ask another question since yo uguys are really good at this category thor
22:52:13 <ddarius> And incidentally the latter would correspond to this use of the comma category notation.
22:52:13 <j-invariant> what is comma category? - other than defining the category of cones
22:53:11 <ddarius> It's a lax pullback in Cat.
22:53:20 <dolio> Doesn't wikipedia have a definition?
22:53:48 <j-invariant> I have definitions but I meant to ask, what do you use it for
22:53:51 <j-invariant> what's it about?
22:53:58 <copumpkin> pff, this is category theory
22:54:11 <copumpkin> (generalizing slice categories? :P)
22:54:20 <dolio> I think Lawvere introduced their use, no?
22:54:33 <dolio> They're useful for giving a hom-like definition of adjunctions that doesn't mention any underlying set theory.
22:54:44 <dolio> Which feels kind of nice.
22:54:53 <j-invariant> okay thanks 
22:54:58 <copumpkin> the real notion here is the mma category, of which the comma category is the dual
22:55:07 <dolio> Mixed martial arts?
22:55:19 <ddarius> dolio: Which incidentally uses only the pattern used here.
22:55:30 <djahandarie> The comma object of a cospan A -f> C <g- B
22:55:43 <ddarius> Many uses of comma categories are slice categories or slices from/to a functor.
22:56:19 <ddarius> It's less common to use the full generality of comma categories, though I hear there are some nice rules for them.
22:56:55 <j-invariant> that's why they say "F is a diagram" rather than "F : J --> C"
22:57:06 <ddarius> Personally, I'm not familiar with/aware of enough "algebraic" manipulations on comma categories to use them much.  I prefer (co)end manipulations.
22:57:26 * Axman6 wonders if this conversation is more approiate for #haskell-in-depth 
22:57:36 <djahandarie> ddarius, what do you use category theory for?
22:58:09 <copumpkin> Axman6: I though the only thing appropriate for #haskell-in-depth was silence
22:58:28 <danderson> copumpkin: more focused meditation than silence
22:58:34 <ddarius> dolio: Yeah, I believe he introduced them in his thesis.
22:58:53 * Axman6 thinks that CT discussions are very appropriate for #haskell-in-depth 
22:59:29 <dolio> Because of all the other bustle in here?
22:59:56 <djahandarie> I was trying to put a monad in my functor but it exploded, help
23:00:24 <ddarius> djahandarie: I tend to prefer categorical expositions of any math topic, though I've particularly have used it for logic.
23:00:34 <zomg> Is that a monad in your pocket, or are you just happy to see me
23:02:05 <Axman6> is that a pointed type in your pocket...
23:04:57 * ddarius decides to go with garter stitch.
23:06:41 <qfr> Do any of you use haskell-mode in emacs? I had massive problems with the indentation breaking there and indent-region giving me quite unexpected results. It didn't work as fluently as the Lisp modes of emacs do for me at all.
23:07:13 <blackdog> ok, i think i'm doing something dumb. 'cabal install alex --with-ghc=ghc-7.0.1' seems to build the binary ok, but 'ghc-pkg-7.0.1 list alex' doesn't show it...
23:07:26 <blackdog> qfr: the problem is that the indentation is actually semantic
23:07:49 <blackdog> you could mean multiple things, where lisp indentation is always inferrable from the parenthesis nesting
23:07:52 <qfr> blackdog ah right, unlike in Lisp it cannot be generated automatically, that's why multiple tabs actually move the elements around?
23:07:57 <blackdog> that's it.
23:08:03 <qfr> What a bummer :[
23:08:06 <blackdog> it can make an educated guess, but that's about it
23:08:45 <ddarius> See the turtle of enormous girth.  On his back, he holds the earth.
23:12:31 <blackdog> urgh, ok. so, alex doesn't have a library section, so it doesn't register. therefore, i can't list it as a Build-Depend. if i list it in Build-Tools, it won't be automatically installed. what's a boy to do?
23:12:49 <Axman6> cry
23:12:56 <Axman6> /make a new build system
23:13:02 * Axman6 hopes for the latter
23:13:02 <wharzl> Can someone help me make this work - http://hpaste.org/42577/llll
23:13:20 <blackdog> Axman6: quitter
23:13:27 <wharzl> I just want names on the type
23:13:29 <Axman6> wharzl: you need to add a consturctor name: data Func = Func {...
23:13:36 <blackdog> but i'd expect no more of a canberran
23:13:58 <Axman6> i'm just sick of cabal not working
23:14:07 <wharzl> i don't understand
23:14:07 <blackdog> yeah, i can sympathise
23:14:14 <wharzl> it's supposed to be a type
23:14:32 <Axman6> oh, yeah you can't do that )it doesn't make any sense)
23:14:43 <Axman6> (*
23:15:28 <wharzl> I can't have named tuples?
23:15:41 <Axman6> that's a) not a tuple, and b) no :P
23:16:05 <Axman6> you're trying to use record syntax on a type, which makes no sense. to use records, you need to make a new datatype
23:16:24 <Axman6> what you actually want is data Func = Func { ... }
23:16:53 <wharzl> but I already have a data type
23:17:10 <wharzl> data Expression = FuncExpression Func
23:17:36 <Axman6> huh? :\
23:17:46 <Peaker> wharzl, type Func = ... defines Func to be an alias to an existing type
23:18:15 <Peaker> wharzl, but there's no existing record type that has [String], Maybe String, [Expression], Environment in it
23:18:31 <Peaker> wharzl, For this record type you have to declare Func to be a new data type, and not just a type alias
23:19:00 <ClaudiusMaximus> > let (,){} = (1,2) in "hmm..."
23:19:01 <lambdabot>   "hmm..."
23:19:09 <blackdog> Axman6: most systems seem to suck in this realm, unfortunately.
23:19:26 <Peaker> wharzl, And each data type in Haskell requires a "data constructor", so it looks like:  data Func = Func { fields here }
23:19:29 <blackdog> Axman6: ruby/perl seem to escape by being a bit more lenient
23:19:41 <Gracenotes> it's a constructor, Jim, but not as we know it
23:22:07 <ddarius> ClaudiusMaximus: Nice.
23:23:31 <minsa> ddarius: what happened there ? 
23:24:24 <ddarius> minsa: You can use record pattern matching syntax on any data type (they just don't have any fields in most cases).  (,) is a normal data constructor like any other.
23:25:19 <minsa> ddarius: thnx. 
23:30:17 <Peaker> Hmm.. wondering about: http://hackage.haskell.org/trac/ghc/ticket/4219#comment:4 --  spj is right, of course, does anyone have any ideas?
23:30:58 <Zao> Nuke from orbit. It's the only way to be sure.
23:33:58 <Peaker> fmap (take len . randomRs (0,maxint)) newStdGen <-- seems to run in constant stack space
23:35:38 <Peaker> It's pretty awesome you can get a serious response from spj when reporting something :)
23:36:33 <ddarius> I'd imagine that's the case for most open-source projects.
23:37:21 <Peaker> But how many opensource projects are awesome like ghc? :)
23:37:23 <Axman6> yeah, but how many open source projects have such awesome jumper wearing gods running them?
23:37:51 <systemfault> clang/llvm is awesome
23:39:08 <Axman6> yes indeed
23:39:22 <Axman6> all my C work is compiled with Clang, reduces debugging time a lot
23:40:22 <qfr> Too bad that's not that advanced with C++ yet, my newer code still doesn't compile there
23:40:39 <systemfault> qfr Clang is a C++2003 compiler.
23:40:45 <systemfault> (For the moment)
23:40:56 <Zao> qfr: Mostly a matter of libstdc++ being retarded with some unguarded GNU extensions, and leaking 0x stuff everywhere.
23:40:56 <systemfault> They're still implementing the C++0x features.
23:40:56 * ddarius is unclear what clang provides for a typical developer.
23:40:57 <qfr> Yeah they're working on implementing the new standard though, too, afaik
23:41:16 <Zao> It doesn't quite grok the MSVC++10 standard library headers either.
23:41:30 <Zao> There's some insane people working on it though (Lelbach et. al)
23:41:34 <Axman6> ddarius: massively improved error reporting
23:41:43 <systemfault> ddarius: It's a better compiler, compiles faster and better diagnostic messages.
23:41:57 <systemfault> At the performance level, gcc is still a bit ahead.
23:42:00 <Axman6> yeah, compilation time is hugely improved too
23:42:08 <ddarius> So error messages, okay.
23:42:16 * hackagebot system-uuid 1.3.1 - Bindings to system UUID functions.  http://hackage.haskell.org/package/system-uuid-1.3.1 (JasonDusek)
23:42:19 <Axman6> LLVM is getting there with optimisation though
23:42:19 <systemfault> On another level.. clang's c++ support is only one year old.
23:42:37 <systemfault> And they're catching up with gcc
23:42:43 <Axman6> and it can already compile boost, quite an achievement
23:42:48 <Axman6> or whoever it's spelt -_-
23:43:03 <qfr> However what is spelled?
23:43:12 <qfr> I see no mistake
23:43:39 <Axman6> oh, i just assumed i spelt it wrong :)
23:43:54 <systemfault> I love C++.. (I'm masochist it seems)
23:44:49 * ddarius likes C++, but then he's probably provably a masochist.
23:45:45 <Gracenotes> sometimes hopelessly complex interactions of langage features can be fun to untangle
23:46:02 <Axman6> ... like in haskel
23:46:03 <Axman6> l
23:46:08 <qfr> Haha Axman6
23:46:12 <qfr> I didn't want to say it
23:46:22 <qfr> But I struggle far more in Haskell than I ever did in C++
23:46:48 <systemfault> But when you know haskell, you're also getting better at C++ TMP :P
23:46:57 <Gracenotes> plus C++ can give you that I'm-modifying-low-level-bits high
23:47:16 <Axman6> so can haskell
23:47:25 <Axman6> and it can come from a very high level too
23:47:57 <Gracenotes> ..maybe if you're using Foreign.C... but it's nowhere near as pretty
23:48:41 <Axman6> i mena like playing with bytestrings, which are really extremely low level things, that have a very high level interface. 
23:49:08 <Axman6> and things like blaze-builder, which does some awesome low level stuff, without you having to worry about any of it and you juts get awesome speed
23:49:19 <systemfault> I wish I'd become as productive with haskell as I currently am with C++
23:49:30 <vegai> hello, geniuses
23:50:10 <vegai> I suppose this is one of the few channels where that can be said without implying sarcasm
23:50:20 <Axman6> heh
23:50:35 <BMeph> Ice is Nice! ;þ
23:50:48 <systemfault> well.. it's just me.
23:50:50 <Gracenotes> Axman6: still, it's not the same as knowing the precise effect a certain statement/expression has on someplace in memory... not like it's a useful thing, but I like it I guess.
23:50:59 <systemfault> And haskell is still twisting my mind
23:51:01 <qfr> /* How do I do this in Haskell? */ int main() { if(*reinterpret_cast<unsigned char>(&main) == 0x81) { std::cout << "Wow. Looks like you're running this on an x86 box. Congratulations, because x86 sucks." << std::endl; } return 0; }
23:51:05 <systemfault> C++ is "natural" to me.
23:51:19 <qfr> fail, unsigned char *
23:51:23 <qfr> Obviously
23:52:16 <systemfault> I don't know how to detect endianess in haskell :P
23:52:35 <Axman6> there's a package to do that
23:52:44 <Axman6> but, even better is knowing that you don't need to ;)
23:53:43 <Gracenotes> qfr: ... FFI? :|
23:53:50 <Zao> qfr: You don't do it in C++ either.
23:53:52 <qfr> :P
23:54:04 <qfr> Zao well actually I do, heh
23:54:10 <Zao> It is UB to take the address of main.
23:54:34 <arcatan> what's UB?
23:54:40 <systemfault> Undefined Behavior
23:54:40 <qfr> Undefined behaviour
23:54:43 <Zao> It is most probably also UB to coerce a function pointer to a pointer as well.
23:54:52 <Gracenotes> maybe trial and error, by assuming a function exists at 0x81 and calling it
23:55:00 <Zao> arcatan: What most C and C++ code invoke all the time :)
23:55:09 <qfr> Hehe
23:55:11 <systemfault> Only sometimes...
23:55:30 <Zao> Gracenotes: It checks if the first instruction octet is 0x81.
23:55:34 <Peaker> ddarius, btw: Compilation speeds are very important with large C/C++ projects, where it can become pretty tedious to have a compile loop of minutes
23:55:42 <Zao> Which is all kinds of platform dependent evil madness.
23:56:00 <Peaker> systemfault, "natural" is just "familiar" in this context :) Haskell will become "natural" too
23:56:22 <Zao> Peaker: Minutes? What toy projects are you on? :D
23:56:43 <qfr> http://siyobik.info/index.php?module=x86&id=35 <- I might have been wrong though, I can't even remember what /7 meant
23:56:55 <Zao> Compile and nowadays linking time is quite detrimental for progress though.
23:56:55 <systemfault> Peaker: It's just that I'm a beginner, I don't know the language and the "jargon"
23:57:01 <Peaker> Zao, heh, well, typically you do have a build system building just part of the project
23:57:03 <Zao> Particularly if you're used to short iterations.
23:57:14 <qfr> Some x86 opcodes use strange encodings where the first byte can change or something
23:57:15 <Peaker> Zao, Why is it UB to take &main? 
23:57:17 <systemfault> Peaker: I'm just lost when people use some haskell related terms :P
23:57:39 <Zao> Peaker: As per the standard, you may not call main, you may not take the address of main, you may not predeclare main.
23:57:45 <Peaker> systemfault, For me it took a few months to go from "awe" at the snippets of code in this channel to writing them myself :)
23:57:58 <systemfault> Ah ok :)
23:58:13 <Zao> Peaker: I believe that some of the reason for those is that implementations should be able to glue one-time pre/postlude code to the entrypoint.
23:59:07 <Zao> Peaker: If you allow calling main or taking it's address, that code must be elsewhere. It also implies that the signature of main is the one you provide, while in truth it may have other arguments and calling conventions.
23:59:17 <Gracenotes> if there's a list of everything that's UB in the standard, I should read it. Given that nearly all of them come up in one gotcha or another.
23:59:55 <Gracenotes> I wonder if they're going with more or less UB in C++1x
