00:15:22 <c_wraith> @pl \a b -> fmap (&& b) a
00:15:22 <lambdabot> flip (fmap . flip (&&))
01:22:10 <dobblego> can someone please remind me of the fix when you have a time package in --global and --user and you get a linker error?
01:26:04 <dark> in parsec, how to make a parser that parses x, then y, and return the concatenation of the result? i'm trying x >> y but this discards the result of x
01:26:28 <dark> (i'm looking at http://legacy.cs.uu.nl/daan/download/parsec/parsec.html but i can't find..)
01:27:06 <Axman6> what types do x and y return?
01:27:17 <dark> string
01:27:18 <c_wraith> dark, you can use either applicative or monadic styles for that.
01:27:34 <dark> I don't want to use do {}
01:27:40 <Axman6> assuming they're kists, (++) <$> x <*> y will do it
01:27:43 <c_wraith> applicative looks like (++) <$> x <*> y
01:27:52 <dark> oh
01:28:09 <dark> so i will do the concatenation 'by hand' anyway?
01:28:22 <dark> i thought there were some <++> combinator
01:28:28 <dobblego> liftA2 (++)
01:28:35 <c_wraith> You could write one, but...  Why?
01:29:47 <dark> i am writing the productions of my grammar by hand, like S <- AB | CD.. this would be S = A <++> B <|> C <++> D..
01:30:27 <kuzyara> hi The Colonial
01:30:33 <c_wraith> well, then.  (<++>) = liftA2 (++)
01:30:37 <c_wraith> it's short.
01:30:57 <c_wraith> maybe set fixity and parsing precedence, if you like
01:31:04 <uchchwhash> hi dons can I have a quick chat with you?
01:31:07 <dark> fixity?
01:31:52 <c_wraith> whether it interprets a <++> b <++> c as a <++> (b <++> c) or (a <++> b) <++> c
01:32:00 <dobblego> better is to liftA2 mappend
01:32:02 <c_wraith> or disallows either of those
01:32:34 <dobblego> Data.Semigroup on hackage has a (<++>) function
01:32:37 <Twey> dark: infixl <++> ⇒ a <++> b <++> c == (a <++> b) <++> c; infixr <++> ⇒ a <++> b <++> c == a <++> (b <++> c); infix <++> a <++> b <++> c == error "ARGH"
01:32:57 <dark> Twey, thank you
01:33:16 <dark> dobblego, that does that? (also, to liftA2 mappend?)
01:33:30 <dobblego> dark, a little bit more general, but yes
01:39:09 <myname_> quit
01:44:02 <dark> <|> binds at level 1, <?> binds at level 0. I think my <++> should bind between them. is it possible?
01:45:40 <dolio> No.
01:46:05 <dolio> The downfall of having integers 0 - 10 as precedence levels.
01:46:44 <Cale> Yeah, could have at least used rationals
01:47:17 <dolio> Agda allows a much larger range of integers, which I think would work a little better. But then for some reason, the standard library only uses 0-10.
01:48:47 <dolio> They also copied infixr for $.
01:49:49 * shachaf imagines floating-point fixity.
01:51:53 <dark> in certain context one could talk about 'the equivalence class of +' or some other representative, would it be clearer? certainly more flexible
01:52:32 <dark> like "make this operator the same precedence as +" or "make it between + and *"
01:52:55 <Faucelme> :q!
01:53:05 <dolio> Yes, well, specifying orderings between the operators is another option.
01:53:16 <dolio> + < *, etc.
01:54:10 <dolio> That has the disadvantage that operators from two separate libraries may have no precedence declaration with respect to one another.
01:54:44 <dolio> Or they may, if it's induced by way of a third, common set of operators.
01:54:54 <dolio> But whether they do or not is difficult to predict.
01:55:39 <dark> yes. but suppose you just want them both to be between X and Y. if that's the intent, they should not have precedence over one another
01:55:51 <dark> but it may be hard to know the intent..
01:56:33 <dark> so seeing a number could make things simpler
02:01:00 <dark> parsers are not instances of Applicative (at least not here)
02:01:24 <dark> so both liftA2 (++) and (++) <$> a <*> b is not working
02:01:40 <dobblego> liftM2 (++)
02:03:15 <Twey> Err, they should be
02:03:46 <mae> ls
02:03:55 <dark> I'm using an old version, maybe in parsec3 it is? well, liftM2 works
02:04:25 <Twey> mae: ENOTASHELL
02:05:06 <dark> what if I wanted to write it without hiding the parameters, like this (++) <$> a <*> b expansion? (I got that <*> stands for fmap, that is not defined for monads)
02:06:21 <mae> Twey: right?
02:06:40 <c_wraith> dark, <$> is fmap.  <*> is ap
02:07:26 <c_wraith> well, and liftM is the same as fmap (if things are defined properly)
02:08:28 <Twey> And your Parser really should have an Applicative instance
02:08:44 <Twey> I'm pretty sure Parsec 2 has an Applicative instance too
02:08:51 <Twey> Maybe it's in a module somewhere?
02:14:45 <kuzyara> anybody, please, say me how to ask in ghci "what mean this comand"?
02:14:45 <kuzyara> Does it have man pages?
02:15:04 <dobblego> kuzyara, :info
02:21:59 <Cale> kuzyara: It doesn't have built-in documentation. The documentation is available on the web
02:22:22 <Cale> kuzyara: But you can ask where things are defined (and their definition in some cases) with :info
02:22:32 <Cale> kuzyara: and for types with :t
02:24:45 <kuzyara> Cale, Thanks!!:-) 
02:25:13 * hackagebot Javasf 0.0.1 - A utility to print the SourceFile attribute of one or more Java class files.  http://hackage.haskell.org/package/Javasf-0.0.1 (TonyMorris)
02:26:04 <Cale> No problem :)
02:34:16 * hackagebot blaze-html 0.3.0.2 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.3.0.2 (JasperVanDerJeugt)
02:45:25 <kuzyara> Does it not have english documentation for function "map"(or "concat"):
02:45:26 <kuzyara> http://www.haskell.org/haskellwiki/Map - roman description o_0
02:45:26 <kuzyara> Where do locate man webpages? Link? 
02:45:51 <kuzyara> can't find ((
02:47:52 <tonkman> http://zvon.org/other/haskell/Outputprelude/map_f.html
02:49:07 <mauke> kuzyara: http://haskell.org/ghc/docs/latest/html/libraries/base-4.3.0.0/Prelude.html
02:57:48 <Twey> … why *is* that in Romanian?
02:59:38 <Axman6> why indeed o.O
03:00:43 <Jafet> Why not!
03:11:21 <dobblego> is there a HaddockFlags cabal directive or something like it? 
03:15:55 <rkrzr> @src seq
03:15:55 <lambdabot> Source not found. Just try something else.
03:25:11 <kafee> i have a noob question , does compiled haskell programs use some sort of VM, like the C# or Java ones?
03:25:58 <Axman6> kafee: no. they're compiled to native machine code
03:26:13 <lantti> Well, they include the runtime.
03:26:34 <lantti> To me it is something between a library and vm
03:26:38 <kafee> what about the garbage collector?
03:26:42 <Axman6> yes, there's a runtime, but they are also native programs
03:27:10 <Botje> kafee: think about C
03:27:23 <Botje> kafee: C also needs something like libc to provide malloc and stuff
03:27:30 <Botje> haskell is no different :)
03:27:31 <Axman6> or objective-C, it's C with some extra syntax, and garbage collection
03:28:44 <kafee> so why did people say Go has something new because it's garbage collected but compiled?
03:31:20 <Cale> kafee: That's not new at all. Haskell isn't even the first such language.
03:31:40 <Cale> There have been lisp compilers for a long time.
03:32:16 <kafee> it was what I thought
03:32:21 <Axman6> kafee: that's not what's new about Go
03:32:36 <Cale> There isn't a whole lot which is new about Go.
03:32:50 <mreh> I don't think using a Writer was the best way to output a graph translation into dot
03:34:07 <Cale> I sort of get the idea "let's do a better C", but it's sort of too little too late :P
03:34:31 <Cale> Go would have been interesting maybe 20 or 30 years earlier
03:35:57 <lantti> If there is going to be better c++ then why not make a better c too :)
03:37:22 <alpounet> there's no such thing as a better C++ for the moment
03:38:03 <remy_o> are there other low-level languages than C in use ?
03:38:17 <Axman6> assembly >_>
03:38:24 <Cale> LLVM
03:38:52 <mreh> Delphi
03:38:54 <lantti> alpounet: I thought the whole c++0x was about that...
03:38:54 <sipa> fortran
03:39:12 <alpounet> lantti, well, that's still C++
03:39:19 <alpounet> and it is about that
03:39:27 <alpounet> even though there are some weird decisions going on around it
03:39:29 * shachaf was at a talk about D recently. Some of it seems rather nice.
03:39:37 <shachaf> (Especially since I've been writing some C++ recently.)
03:40:22 <alpounet> (now kmc will kick in and tell you how ugly and unpractical C++ is)
03:40:37 <dobblego> unpractical!
03:40:52 <shachaf> alpounet: Is kmc usually awake at 06:40?
03:41:30 <kafee> here is 9:40
03:41:37 <Botje> lies. it's 12:40
03:41:39 <Cale> I'm probably preaching to the choir here, but we've known how to implement first class functions efficiently for decades, and we've known their importance for abstraction arguably for longer than electronic computers have been around. There's no excuse to still be programming in a language without them :)
03:41:40 <krnc> C++ is ugly like your sister!  C++ is unpratical like your mother without a bra!
03:41:41 <shachaf> Here is is 03:40.
03:41:44 <alpounet> 12:40 here too
03:41:52 <adrianlang> \say \vote 12:40
03:41:55 <Axman6> 20:40!
03:42:07 <theorbtwo> 11:41!
03:42:10 <dobblego> http://i.imgur.com/W0QFS.png
03:42:12 <sipa> 12:41 !
03:42:16 <Cale> 6:41
03:42:17 <shachaf> Your time zones are all crazy!
03:42:19 <kuzyara> 19:41)
03:42:26 <alpounet> Cale, the wording for C++0x lambdas just sucks man
03:42:29 <dom96> 11:42! :P
03:42:32 * theorbtwo is in the One True Time Zone.  (GMT.)
03:42:42 <alpounet> but have you taken a look to Boost.Lambda and/or Boost.Phoenix ?
03:42:46 <alpounet> that's a bit better 
03:42:51 <adrianlang> „Method too general“ whooo dammit
03:42:54 <alpounet> even though there's a lot of hackery behind
03:43:04 <shachaf> What would be a good language for the things C++ is typically used for nowadays?
03:43:20 <Cale> Haskell :P
03:43:39 <sioraiocht> shachaf: which "things"?
03:43:51 <sipa> Haskell + C via FFI ;)
03:44:05 <alpounet> i think i'll only use two languages for a while
03:44:14 <shachaf> Let's say, a database.
03:44:18 <alpounet> namely C++ and Haskell
03:46:23 <theorbtwo> shachaf: Why are you programming a database, rather then using an extant one?
03:46:48 <alpounet> i guess he's just talking about an hypothetical case study
03:46:51 <shachaf> theorbtwo: http://rethinkdb.com/
03:46:54 <Cale> theorbtwo: In order to better reflect the categorical structure of databases, of course!
03:47:24 <theorbtwo> The right time to consider what language is best for a project is before you start coding.
03:47:47 <shachaf> theorbtwo: What language would you write it in?
03:48:11 <ulfdoz> Cale: Ok, here is probably the task to get that thing working: Write an Operating System based in Haskell and provide primarily a haskell-API. Secondarily interface with other languages.
03:48:40 <Cale> Which thing?
03:48:44 <theorbtwo> I probably wouldn't write a database.  If I was going to, I'd consider why I was writing it ... and quite possibly write it in haskell.
03:48:55 <ulfdoz> Cale: The thing to get haskell used instead of C/C++
03:49:43 <theorbtwo> I wouldn't write a database other then to experiment with new ways of doing things, and haskell could be part of that experiment.
03:49:57 <Cale> Oh, well, I'm not sure I actually want that. I want to use Haskell myself, and of course, I would advise others to use it, but in a paradoxical fashion, I don't actually want it to be too popular :)
03:49:59 <theorbtwo> If I wanted a database I could trust with actual data, I wouldn't use one I'd written myself.
03:50:23 <theorbtwo> That's OK.  A new OS won't be popular.
03:50:25 <Cale> Unfortunately, it's probably too late :P
03:50:27 <shachaf> theorbtwo: Here's some justification for writing a new database, and a description of it: http://www.youtube.com/watch?v=uDHc3lkr3Ns
03:51:26 <Cale> Languages stagnate as their popularity grows.
03:52:07 <ulfdoz> Imho it is completely reasonable to write a database in haskell. But one should consider that almost any popular database has decades of development history in its back. (not counting the new trendy non-transactional NoSQL)
03:53:10 <Cale> Yeah. It would be nice to have a database with a decent type system where you didn't have to encode everything awkwardly in terms of relations.
03:53:20 <alpounet> now the real question is: would you be able to keep up performance-wise with the other DB engines ?
03:53:45 <ulfdoz> alpounet: I see no reason why not, they are all cooking with water.
03:53:50 <shachaf> Cale: How would you want to encode things?
03:55:27 <Cale> shachaf: Have you seen the databases are categories talk? Perhaps something like that, with say, Haskell's type system added in (each type being another virtual table in the database)
03:55:43 <alpounet> ulfdoz, sure, but even if we're not that far, we're not there yet
03:55:48 <shachaf> Cale: Nope.
03:55:50 <Cale> Well, I'm not sure if we want to be able to record partially evaluated expressions into the database :)
03:56:08 <shachaf> Cale: A Galois Tech Talk?
03:56:18 <Cale> shachaf: yeah, there are two of them actually
03:56:43 <Cale> I want the database to at least have algebraic datatypes
03:57:40 <ulfdoz> alpounet: Nope, that's the lack of development in the past. Having a database run in a cluster of cheap hardware an still scaling well is definitely a non-trivial task. Also there is almost no database, which implements any SQL-Standard completely. On the other hand there are vendor extensions to the standards, which make the one or the other database more suitable for one purpose than for another.
03:58:03 <Cale> SQL is a depressing standard
03:58:24 <shachaf> Cale: Non-standard SQL is depressing too. :-)
03:58:39 <Cale> Well, for the most part, I'd agree with that, yeah.
03:58:49 <Cale> Can't we ever make real progress in expressiveness of our query language?
03:59:12 <alpounet> there's linq
03:59:13 <alpounet> haha
03:59:17 <ulfdoz> Cale: But relational databases are the only ones, which give you some weak guarantees about what happened to your data. Most of them use SQL as a frontend language.
04:02:40 <ulfdoz> But considering the current usage pattern of databases, it is probably a good idea to focus primarily on an API-access instead of statement based access. SQL-statements are something like an alien in any language.
04:03:56 <ulfdoz> What I mean is something like the criterion-queries introduced with JPA 2. That is an API, which allows to construct database queries programmatically instead of doing weird text processing of strings with prepared statements and the like.
04:04:43 <Cale> The categorical approach is basically the idea that tables are objects in a category, and columns are arrows. Every column is a foreign key column, and there are some extra (obviously not on disk) tables consisting of the values of primitive types.
04:05:26 <Cale> Constraints on your data can be expressed as commutative diagrams of arrows (or equivalently, equations of composites of arrows)
04:05:28 <msieradzki> Cale, how does postgresql not have algebraic datatypes (unless I'm missing something)?
04:06:22 <Cale> msieradzki: Does it? Can I have a column whose type is Tree Integer where data Tree a = Tip | Branch a (Tree a) (Tree a) ?
04:06:41 <msieradzki> I'd have to check :_
04:06:43 <msieradzki> :)
04:07:06 <Jafet> I continue to maintain that for nearly all purposes, relational databases are used because it's easier than making a data structure that's actually suited to the problem being solved.
04:07:12 <Cale> (That type is a good example, because it has a sum, a product, and recursion)
04:07:35 <msieradzki> sum, product ok but recursion
04:07:35 <Cale> Also, parametric polymorphism is nice, but I guess I could live without it.
04:07:38 <alpounet> Jafet, just like programming languages in general
04:07:45 <ulfdoz> Cale: You would map that into a table and probably put a recursive view on that, extracting you paths in that table.
04:07:56 <alpounet> *cough* Java *cough*
04:08:37 <Jafet> Well, people have begun to recognize that there will always be more than one useful programming language at any point in time. Some people, at least.
04:08:55 <ulfdoz> Cale: What I did not got working with tree structures: How efficiently define a table constraint which guarantees that there are no cycles.
04:10:24 <ulfdoz> I have to have a look at Postgres 9's new exclusion constraints. I'm not yet sure if they deliver that expressiveness.
04:10:37 <Jafet> Store the branch depth?
04:10:39 <Cale> ulfdoz: Yeah, I admit I haven't done a lot of stuff with relational databases, but I found it extremely awkward and ugly.
04:10:53 <msieradzki> and extremely useful at the same time
04:11:18 <alpounet> msieradzki, isn't it because you're really used to it and know it well ?
04:11:48 <Jafet> alpounet: or, as for most other forms of technology, due to the opposite...
04:12:39 <alpounet> aha, fair point
04:12:49 <ulfdoz> Cale: I completely agree that database access code is most often ugly and most often breaks with things like a programming language's type system. That is imho, what makes it ugly.
04:12:53 <Cale> msieradzki: It's not useful to be forced to express your tree structures by representing them as relations corresponding to graphs, spreading them out over many rows, but mixing them all the trees together into a large table :P
04:13:12 <msieradzki> corner case
04:13:25 <Cale> (and getting no guarantee that they're trees, or that trees which are meant to be separate are actually separate)
04:14:09 <Cale> otoh, I guess the explicit sharing can be nice
04:14:58 <msieradzki> ulfdoz, what breaks first (but I haven't written much) is usually DB connector like JDBC/HDBC
04:15:07 <Cale> But it's sort of like losing type safety and going back to arbitrary messes of pointers :)
04:15:17 <msieradzki> if there's no support for CREATE DOMAIN or CREATE TYPE
04:15:39 <msieradzki> Cale, I get your point I thought pgsql has arbitrary user types
04:16:12 <msieradzki> and no I wasn't thinking about converting every atomic tree into table/set of rows
04:17:19 * hackagebot has 0.5.0.1 - Entity based records  http://hackage.haskell.org/package/has-0.5.0.1 (YusakuHashimoto)
04:41:12 <kafee> I have another question, in which situation should an applicative functor or a monad or an arrow? It seems the monads are ubiquitous .
04:41:51 <Cale> When you have one.
04:42:28 <Cale> You don't normally set out to use a monad or applicative functor or arrow. You design a library, and notice that it fits into one of those shapes.
04:43:00 <Cale> (Sometimes it's worth a bit of trouble to figure out a way to make it fit those shapes)
04:43:25 <Cale> The benefit you get is a library of general functions which work in any monad or any applicative functor, etc.
04:43:41 <Cale> and which might be useful for your library
04:44:02 <kafee> hummm
04:44:07 <Cale> For example
04:44:17 <Cale> sequence :: (Monad m) => [m a] -> m [a]
04:44:27 <Cale> this works for any monad m
04:45:01 <Cale> In, say, the IO monad, it takes a list of IO actions, and produces an action which runs them all, giving a list of the results.
04:45:17 <aristid> > sequenceh [[1,2],[3,4]]
04:45:18 <lambdabot>   Not in scope: `sequenceh'
04:45:22 <Cale> In the list monad, interestingly, it's a Cartesian product
04:45:23 <aristid> > sequence [[1,2],[3,4]]
04:45:24 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
04:45:44 <Cale> "running" a list basically means to choose an element from it in all possible ways
04:45:45 <aristid> > sequence [Just 1, Just 2, Nothing]
04:45:46 <lambdabot>   Nothing
04:45:50 <aristid> > sequence [Just 1, Just 2]
04:45:50 <lambdabot>   Just [1,2]
04:46:00 <mercury^> Is there not a more general version of sequence that works on distributing monads?
04:46:16 <aristid> mercury^: sequence works on all monads
04:46:57 <mercury^> No, it only works for any pair of monads where one of them is [].
04:47:08 <Cale> mercury^: Well, the type of sequence is the right type for a distributive law for commuting m and the list monad, but I'm not sure that it actually satisfies the laws for one.
04:47:12 <xrch> he means "does dist :: (Monad m, Monad u) =>  m (u a) -> u (m a)" I think
04:47:18 <xrch> +exist?
04:48:04 <Cale> distributive laws are somewhat rare, and don't tend to exist if you choose any old pair of monads
04:48:23 <Cale> (but this is getting way far away from kafee's question ;)
04:48:46 <aristid> mercury^: ah, there is sequence in Traversable, if that's what you want
04:48:58 <Cale> kafee: In a parsing monad, sequence acts as the concatenation of parsers
04:49:03 <aristid> :t Data.Traversable.sequence
04:49:03 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
04:49:13 <aristid> yay, i was lucky
04:49:38 <Cale> kafee: There is a whole library of other functions like sequence which work in an arbitrary monad -- a lot of them are control-structure-like things.
04:50:23 <Cale> forM [1..10] $ \n -> print n; getLine
04:50:26 <Cale> er
04:50:29 <Cale> forM [1..10] $ \n -> do print n; getLine
04:50:39 <Cale> You might try that at the ghci prompt
04:50:57 <Cale> forM is general and works in any monad
04:51:17 <sipa> :t forM
04:51:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:51:23 <Cale> But here we've used it in IO as a for-each loop.
04:51:27 <aristid> > replicateM 3 [1,2]
04:51:27 <sipa> but it still takes a list as argument
04:51:27 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
04:51:32 <kafee> ["23","23","23","23","23","23","23","23","23","23"] 
04:51:34 <Cale> yeah
04:51:38 <aristid> :t replicateM
04:51:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
04:52:15 <Cale> kafee: It gets 10 lines of text from the user, (printing a number before each), and produces a list of the results
04:52:39 <kafee> I see
04:52:46 <aristid> kafee: try this at the ghci prompt, too: replicateM 10 (putStrLn "This is repetition")
04:53:03 <aristid> replicateM also works with any Monad
04:53:27 <kafee> but replicateM does not get rid of the ()
04:53:43 <aristid> replicateM 10 $ putStrLn "This is repetition"
04:53:52 <aristid> it's the $ that gets rid of the ()
04:54:02 <kafee> no
04:54:06 <kafee> the units
04:54:29 <aristid> :t replicateM_
04:54:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
04:54:42 <aristid> replicateM_ 10 $ putStrLn "This is repetition"
04:55:18 <kafee> but what about forall ? 
04:55:31 <aristid> which is the same as, but more efficient than, do replicateM 10 (putStrLn "This is repetition"); return ()
04:55:38 <mercury^> Does anyone here know of a nice way to draw string diagrams for (3,2) categories by the way? Naively using the dual cell structure of the nerve would need three dimensional drawings; I would prefer something that looks like the (2,2) picture with some additions.
04:56:16 <aristid> kafee: you can ignore the whole "forall (m :: * -> *) a." stuff, it doesn't add anything very important
04:57:22 <kafee> "The forall keyword is used to explicitly bring type variables into scope" says wikibooks
04:58:15 <sipa> kafee: if you write the type [a], for example, that's identical to "forall a. [a]"
04:58:30 <xrch> hum
04:58:50 <kafee> sipa: so why is that useful?
04:58:57 <sipa> sometimes you do not want it
04:59:00 <xrch> wel actually
04:59:02 <xrch> in [a]
04:59:09 <xrch> the forall a is just implicit
04:59:18 <xrch> well*
04:59:18 <sipa> yes
04:59:21 <aristid> kafee: yes, but type variables are also brought implicitly into scope if you don't bring them explicitly
04:59:47 <sipa> kafee: if you use a type variable that's not forall'd anywhere, it is implicitly forall'd at the start
05:00:06 <xrch> or else you can't do type inference
05:00:11 <sipa> but in combination with some type-system extentions, it's possible to have it elsewhere
05:00:20 <sipa> but don't bother with that for now :)
05:04:05 <Cale> Like, if you wanted a function whose parameter is *required* to be a polymorphic function
05:04:19 <Cale> You could write foo :: (forall a. [a] -> [a]) -> ...
05:06:07 <xrch> without using forall in inner types, you can't have let phi f = (f 1, f True)
05:06:08 <kafee> :t runST
05:06:09 <lambdabot> forall a. (forall s. ST s a) -> a
05:06:23 <xrch> > let phi f = (f 1, f True)
05:06:24 <lambdabot>   not an expression: `let phi f = (f 1, f True)'
05:06:28 <xrch> oops
05:06:33 <xrch> > phi f = (f 1, f True)
05:06:34 <lambdabot>   <no location info>: parse error on input `='
05:06:46 <opqdonut> :t let phi f = (f 1, f True) in phi
05:06:47 <lambdabot>     No instance for (Num Bool)
05:06:47 <lambdabot>       arising from the literal `1' at <interactive>:1:15
05:06:47 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
05:06:48 <opqdonut> there
05:06:58 <kafee> and that type of runST?
05:06:59 <xrch> thanks
05:07:32 <xrch> with ST, a function with a forall means that side effects will not "escape" the scope of the function
05:07:53 <xrch> but that's all I know about it, I never really understood how it works
05:07:54 <sipa> kafee: it says you need to pass an ST action which is polyporphic in s - being it should be valid for any s
05:08:12 <xrch> +have
05:08:14 <sipa> and it is up to runST to decide which s to use
05:08:31 <sipa> instead of having it being determined by type inference
05:08:42 <kuzyara> (>>>)	    :: XmlFilter -> XmlFilter -> XmlFilter
05:08:43 <kuzyara> (f >>> g) t =  concat [g t' | t' <- f t]
05:08:43 <kuzyara> What is it doing? 
05:08:43 <kuzyara> (>>>)-function has 3 arguments f,g,t?
05:08:43 <kuzyara>  Is (t'<-f t) input set? 
05:08:43 <kuzyara> How to read last line? 
05:08:48 <sipa> in particular, the function calling runST can never "know" which s is used
05:08:58 <xrch> hum, if you want to know more about that, I advise you read http://blog.huoc.org/17-higher-rank-polymorphism.html
05:09:07 <xrch> but that's maybe a bit too complicated for now
05:09:13 <xrch> and it uses OCaml
05:09:20 <kafee> i will read
05:13:05 <lars9> how to download all demos here: http://code.haskell.org/gtk2hs/gtk/demo/ ?
05:15:15 <lars9> and gtk2hs is down? haskell.org/gtk2hs/
05:38:41 <augur> i know zippers and continuations have an intimate relationship, but has anyone actually implemented continuations (delimited, preferably) via zippers?
05:52:18 <Whichever> "Exercise 3-6 Write a function named desirable in Hugs which decides if someone is desirable based on the criteria of the person’s gender being male and he being not poor or else being female and aged 30 or under."
05:52:28 <Whichever> Can someone explain to me how to do this?
05:52:43 <medfly> :S
05:52:51 <Botje> Whichever: what datatypes or functions do you have?
05:53:03 <sipa> hmmm sexist functions
05:53:04 <Whichever> desirableFap :: Int -> Char -> Bool -> Bool desirableFap age gender wealthy = age > 18 && gender 'M' && wealthy
05:53:19 <Whichever> i changed it a bit
05:53:28 <Whichever> buIt isn't homework by the way
05:53:39 <Botje> (also, you might want to switch to ghci as it gives nicer error messages)
05:54:01 <benmachine> Whichever: so what's the problem with your defined function?
05:54:18 <benmachine> apart from that only women marrying for money can use it
05:54:36 <Whichever> I waccording to ghci this: ThisGoddamShitDBetterWork.hs:2:46:     Couldn't match expected type `Char -> Bool'            against inferred type `Char'     In the first argument of `(&&)', namely `gender 'M''     In the second argument of `(&&)', namely `gender 'M' && wealthy'     In the expression: age > 1 && gender 'M' && wealthy
05:54:38 <Botje> Whichever: perhaps you could use pattern matching instead, to separate out male and female
05:54:38 <Whichever> dam
05:54:44 <sipa> Whichever: use hpaste.org
05:55:05 <Whichever> look can someone tell me how this is done?
05:55:08 <Botje> desirableFap age 'M' True = True
05:55:16 <Botje> or, uh, something.
05:55:37 <Botje> Whichever: you should use gender == 'M' or explicit pattern matching
05:55:54 <Botje> gender 'M' tries to apply the function gender to the argument 'M'
05:59:45 <mathijs> I read that haskell threads are very lightweight because they don't necessarily map to an OS thread. In other languages, the reactor pattern is becoming more&more popular (ruby, node.js) where just 1 (or a very small pool) thread executes code whenever data is available...
06:02:11 <Kaidelong> mathijs: Essentially haskell "threads" in the sense of par (not sure about other stuff like forkIO) are jobs kept in a thread pool not unlike what you would do on .NET
06:02:13 <mathijs> now since haskell's laziness does something like this by default... I'm a bit confused. Say I create 100 threads and all of them start waiting for data to arrive on a socket. will this internally translate to just 1 epoll call waiting on those 100 socket? or are there 100 (although light) threads being scheduled to each check 1 socket?
06:02:15 <Kaidelong> or Java
06:03:26 <byorgey> Kaidelong: forkIO also generates lightweight threads
06:04:52 <mathijs> Kaidelong: I'm talking about forkIO in this case.  And also, .Net and Java (as far as I've used them) seem to be in favor of traditional threading. where a threadpool (larger than the number of cores on the system) is allocated for some tasks and there are blocking calls instead of handing the task back to the reactor with a provided callback. 
06:05:00 <Kaidelong> mathijs: when you actually evaluate the parallel computation you're going to need to be eager in SOME way or another. If there is indeed some intermediate thing that has to sequentially finish first, you shouldn't worry about the jobs being created when they're not needed.
06:05:29 <Kaidelong> mathjs: the parallel was that the thread pool handles scheduling for the programmer so you don't have to worry about it yourself
06:09:46 <Kaidelong> mathijs: I misread your question, sorry
06:09:55 <Kaidelong> I think the answer is that there will be 100 things waiting
06:10:00 <Kaidelong> but I may be wrong
06:10:38 <Kaidelong> sounds like you are trying to program a server
06:10:50 <mathijs> ah, like that :)  well it's nice if I don't have to worry about it, but in the end I would like to make sure the scheduling is intelligent enough. If I want to create 10000 threads (to keep a design simple) and they are waiting for some external data to arrive (like http or database) most of the time, I would like to know that this will translate to select()/epoll() in the RTS.
06:11:35 <Kaidelong> you'll have to ask someone smarter than me. But try writing it the simple way first, and then profile it to see if it works
06:11:42 <mathijs> Kaidelong: well yes that would be the most logical use-case :)  
06:23:30 <augur> anyone? anyone?
06:23:33 <augur> oh, its not 10:30 yet
06:23:34 <augur> :|
06:29:08 * hackagebot heist 0.4.0.0 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.4.0.0 (DougBeardsley)
06:29:51 <hpc> ooh, great name for a package
06:44:00 <lars9> anyone familiar with gtk2hs or gtk2?
06:44:18 <shachaf> lars9: That seems quite likely.
06:46:35 <byorgey> lars9: if you have specific questions about them you should just ask the questions.
06:46:46 <lars9> shachaf: thanks, i never did it before. i want a window with a single line text field, and a listview. they both fill the wideth, the height of the text field is fixed, the listview should fill the rest space. how to let them auto resize when the main window resizes?
06:47:04 <chrisdone> good evening
06:47:10 <byorgey> hi chrisdone 
06:47:25 <lars9> byorgey: thanks, yeah i just typed the newbie question...
06:47:47 <shachaf> lars9: Note: I don't know anything about Gtk2.
06:48:22 <shachaf> lars9: This question doesn't seem very Haskell-specific, though, so you might have more luck reading general Gtk2 documentation (or asking in another channel).
06:49:49 <mpiechotka> Hello. Does anyone knows how to get a n'th element address of C array (Value (Ptr a)) in Haskell LLVM?
06:53:49 <mpiechotka> Ok. I found
07:04:43 <ente> hi.
07:05:21 <ente> after compiling ghc, I find out it's linked against libraries that don't exist on the system where I built it
07:05:35 <ente> (some .so, not ghc itself, that works fine)
07:08:09 <ente> http://paste.xinu.at/K33gB/
07:08:32 <ente> can anyone tell me what I'm doing wrong?
07:09:06 <niteria> is there an operator that works like this: a `op` b = b . a ?
07:09:24 <unkanon> you gotta make one I think
07:09:26 <byorgey> niteria: yes, (>>>) from Control.Arrow
07:09:58 <unkanon> > let (.>) = flip (.) in (+1) .> (*2) $ 3
07:09:59 <lambdabot>   8
07:10:06 <parcs> are you intentionally dynamically linking?
07:10:16 <ente> yes
07:10:31 <ente> should I be linking statically?
07:10:31 <unkanon> :t (>>>)
07:10:32 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
07:10:42 <byorgey> > (+1) >>> (*2) $ 3
07:10:43 <lambdabot>   8
07:11:04 <niteria> nice
07:11:09 <ente> parcs: the static .a libs are there... I don't understand why it doesn't puy the dynamic ones there.
07:11:10 <unkanon> yeah good to know
07:11:13 <byorgey> It is a bit more general, but you can replace 'cat' in that type with (->)
07:11:26 <byorgey> so  cat a b  ===  a -> b
07:11:27 <byorgey> and so on
07:11:44 <ente> parcs: I have GhcLibWays += p dyn in build.mk
07:11:59 <parcs> ente: i get the exact same ldd output on the same file wrt ghc 6.12.3. i'm don't think you're doing anything wrong
07:12:18 <unkanon> so (->) is a category, besides being a monad? or did I just talk nonsense?
07:12:52 <ente> parcs: maybe it's a ghc bug?
07:14:07 <ente> ghc itself works fine, all the haskell stuff I compiled too. still, having unresolved dynamic library conflicts sounds inelegant to me
07:14:07 <niteria> import Control.Arrow (>>>)
07:14:09 <niteria> huh
07:14:15 <niteria> what do i do?
07:14:38 <niteria> it gives parse error
07:15:04 <parcs> ((>>>))
07:15:07 <duckinator> What's the best way to run a sub-process and return stdio and stderr the output to a haskell var? i'd prefer to be able to use stdin to feed it input, but that's not required.
07:15:37 <niteria> oh, i'm dumb, thx
07:15:53 <Cin> What's a reliable way to get the type of a subexpression of a function declaration?
07:17:21 <Cin> I pondered translating f = 2 + x where x = 2 to: f _x = 2 + x where x = _x; and then inspecting the type of _x, but this may not be possible in the presence of rank-n types.
07:20:21 * hackagebot improve 0.2.2 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.2.2 (TomHawkins)
07:22:12 <byorgey> unkanon: (->) is an instance of Category, yes
07:22:18 <byorgey> unkanon: but it is not an instance of Monad
07:22:28 <byorgey> unkanon: you are probably thinking of ((->) e)
07:22:33 <unkanon> oh just a functor then
07:22:38 <unkanon> yeah that's it
07:23:03 <byorgey> (->) does not have the right kind to be an instance of Monad
07:23:10 <niteria> how do i give another name for something i pattern match?
07:23:12 <byorgey> or Functor
07:23:18 <unkanon> hmm
07:23:26 <niteria> i though @
07:23:31 <byorgey> yes
07:23:34 <unkanon> niteria: xs@(x:xs')
07:23:41 <byorgey> foo m@(Pattern match) = ...
07:24:02 <niteria> ah ok, i was doing sth like this (x:xs)@s
07:28:28 <unkanon> byorgey: what kind does a thing have to have to be a monad? * -> *?
07:29:12 <augur> ahhh look at this
07:29:19 <augur> its 10:30 and the channel is alive!
07:29:20 <byorgey> unkanon: yes
07:29:27 <augur> so!
07:29:40 <augur> has anyone ever implemented delimited continuations via zippers before?
07:29:48 <augur> i know they're connected but has it been done?
07:30:11 <unkanon> byorgey: makes sense then that (->) isn't a monad but ((->) e) is, because e is filling one of the *
07:30:26 <byorgey> unkanon: right
07:32:18 <lars9> @hoogle digittoint
07:32:18 <lambdabot> Data.Char digitToInt :: Char -> Int
07:41:39 <McManiaC> monad comprehensions support "then" statements: http://npaste.de/sC/ :)
07:42:52 <Kaidelong> I'm not entirely sure why do syntax was preferred over some kind of monad comprehension
07:43:15 <Kaidelong> well I suppose do syntax is just without the []s
07:43:34 <unkanon> and with return
07:43:44 <McManiaC> do syntax is more readable for "non-list-like" monads
07:43:48 <Kaidelong> return is just yield
07:43:57 <Kaidelong> in the F# sense
07:44:11 <unkanon> I don't know F# too much, I just think of return as wrap
07:44:20 <Kaidelong> I suppose F#'s workflow syntax is a bit difference in that yield and yield! can be sequenced
07:44:37 <Kaidelong> in haskell that might inconsistently translate as >> or mplus depending on monad
07:44:56 <adu> yield is also lua/python sense
07:45:04 <Kaidelong> but you could use >> for things that are not MonadPlus and mplus for things that are
07:45:12 <Saizan> McManiaC: cool :)
07:45:48 <Kaidelong> McManiaC: I don't know. Look at F#'s async workflow (workflows are their analogies to monads).
07:45:59 <Kaidelong> I like F#'s syntax for monads a bit better I think
07:46:04 <Kaidelong> although I prefer haskell overall
07:46:09 <McManiaC> I dont know F# at all
07:47:02 <mreh> I come for the esoteric appeal, but stay for the trollin'
07:47:11 <unkanon> lol
07:47:53 <mreh> is f# multi paradigm?
07:48:16 <ente> I think so... at least it's based on ML
07:48:18 <unkanon> I think so
07:48:33 <mreh> never learned ML either
07:48:36 <tonkman> have someone tried J?
07:48:43 <mreh> I suppose it's all about what you get exposed to
07:48:45 <Kaidelong> mreh: F# is a lot like haskell, syntax is from OCaml, and it is strict
07:48:45 <ente> ML is definitely multi-paradigm
07:49:04 <mreh> I was lucky enough to learn Miranda as a young-un
07:49:10 <Kaidelong> it has a heavy haskell influence though
07:49:10 <tonkman> The following is a J program to calculate the average of a list of numbers: avg=: +/ % #
07:49:17 <tonkman> sounds compact
07:49:26 <unkanon> is J like ASCII-APL ?
07:49:30 <Kaidelong> anyway the only thing you have to define for F# workflows are "Bind" and "Return"
07:49:39 <Kaidelong> so they are exactly the same as monads
07:49:45 <tonkman> I dont know anything about J
07:49:49 <tonkman> just heard of it
07:49:50 <mreh> looks stack based
07:49:59 <Kaidelong> J is array-based
07:50:06 <Kaidelong> unkanon: yes exactly
07:50:12 <Kaidelong> it has influence from FL as well
07:50:18 <unkanon> oic
07:50:24 <mreh> so that isn't hsilop
07:50:59 <unkanon> a foreseeable problem with an ascii-APL is that you run out of symbols pretty quickly I'd guess :)
07:51:51 * Kaidelong tries to think of the haskell alternative for "let rec onetwothreeloop = seq {yield 1; yield 2; yield 3; yield! onetwothreeloop}" using do syntax for monads in general...
07:52:03 <mreh> :t uncurry (/) . (&&&) sum length
07:52:04 <lambdabot>     No instance for (Fractional Int)
07:52:04 <lambdabot>       arising from a use of `/' at <interactive>:1:8-10
07:52:04 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
07:52:14 <mreh> :t uncurry div . (&&&) sum length
07:52:15 <lambdabot> [Int] -> Int
07:52:18 * Kaidelong wonders if F# just disallows some uses of yield and yield! and requires do/let instead
07:52:59 <wornof> I've been using the hmatrix library, which is awesome, but I now need to run my program on a server which I don't have sudo access to and which doesn't have hmatrix. 'uname -a' suggests they are both 32 bit. I can't work out...is it likely that I will be able to statically compile on my machine and transfer across?
07:53:25 <mreh> wornof: depends on the instruction set
07:53:41 <aristid> can't hmatrix be installed with --user?
07:53:46 <Kaidelong> > [1,2,3] >> [4,5,6]
07:53:47 <lambdabot>   [4,5,6,4,5,6,4,5,6]
07:53:54 <Kaidelong> that's... interesting
07:53:58 <mreh> ever heard of cross-compilation?
07:54:01 <aristid> wornof: why not just do cabal install --user hmatrix?
07:54:06 <mreh> Kaidelong: is it?
07:54:07 <aristid> (on the server)
07:54:13 <aavogt> > [1,2,3] >>= [4,5,6]
07:54:14 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
07:54:19 <wornof> cabal also isn't installed, and possibly nor are the liblapack and libgls libraries hmatrix needs
07:54:26 <mreh> > ["apples", "oranges", "bananas"] >> [1,2,3]
07:54:27 <lambdabot>   [1,2,3,1,2,3,1,2,3]
07:54:33 <wornof> I could install them all as user, I assume, but I had no idea which option would be easier
07:54:37 <Kaidelong> > do {[1,2,3]; [4,5,6]}
07:54:38 <lambdabot>   [4,5,6,4,5,6,4,5,6]
07:55:25 <aavogt> Kaidelong: if yield is return, and ;  is >> in that case, what's the point of yield 1; yield 2; yield 3?
07:55:31 <mreh> concatMap (\_ -> [4,5,6]) [1,2,3]
07:55:55 <Kaidelong> in F# "seq {yield! (seq {yield 1; yield 2; yield 3}); yield! (seq {yield 4; yield 5; yield 6})}
07:55:57 <Saizan> wornof: compiling with -static -optl-static you won't have problems from shared libs (though you might need to add some other -l flags for c libs you need)
07:56:00 <mreh> > concatMap (const [4,5,6]) [1,2,3]
07:56:00 <lambdabot>   [4,5,6,4,5,6,4,5,6]
07:56:02 <Kaidelong> would give you 1,2,3,4,5,6, I'm pretty sure
07:56:18 <Kaidelong> so there is definitely some difference between workflow expressions and do syntax
07:56:27 <Saizan> wornof: anyhow, the "compile here then upload" should be faster to test, at least 
07:56:34 <Kaidelong> @src (>>)
07:56:35 <lambdabot> m >> k      = m >>= \_ -> k
07:56:36 <aavogt> so yield is closer to  tell?
07:56:36 <wornof> Okay, thanks for the help. If the static options don't work, I'll try to install cabal as user.
07:56:38 <aavogt> @ty tell
07:56:39 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
07:56:56 <Kaidelong> aavogt: possibly, but the only two things you need to define to get a workflow are bind and return
07:57:07 <Kaidelong> aavogt: perhaps overloading is involved somewhere
07:57:38 <aavogt> Kaidelong: well WriterT and ContT seem to be allowed in haskell, it's just explicit there
07:57:55 <wornof> Hmm...compiling with -static and -optl-static doesn't work. Cabal time, methinks
07:57:59 <Kaidelong> hmm, well I don't know the answer, interesting though
07:58:00 <mreh> :t tell
07:58:01 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
07:58:14 <mreh> @ty tell
07:58:14 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
07:58:17 <mreh> :)
07:58:24 <Kaidelong> there are some nice things about F# that really should find their way into haskell at some point
07:58:31 <Kaidelong> I guess there is the fpipe library
07:58:55 <aavogt>  ContT for when you'd expect       seq {yield! 2; yield 1}  == ??
07:59:24 <Kaidelong> yield! would be a type error
07:59:27 <Kaidelong> there
07:59:28 <Kaidelong> probably
07:59:47 <Kaidelong> it'd be like going "<- 2" instead of "<- return 2"
08:00:25 <Kaidelong> unless integers are monads somehow and it's a trap!
08:00:45 <hpc> that would be one magic monad
08:02:02 <ddarius> > (do x <- 2; return x) 3
08:02:02 <lambdabot>   2
08:02:06 <ketil> Any cabalists here?  How backwards compatible is the "if impl(ghc > x)" syntax?  Will it work on ghc 6.10 installs?
08:02:26 <hpc> :t (do x <- 2; return x)
08:02:26 <lambdabot> forall (m :: * -> *) b. (Num (m b), Monad m) => m b
08:02:35 <Saizan> ketil: yes, it's quite old
08:02:35 <ente> I just read cannibalists :p
08:02:38 <hpc> oh, the function instance
08:02:41 <Kaidelong> lambdabot
08:02:42 <hpc> @instances Num
08:02:43 <lambdabot> Double, Float, Int, Integer
08:02:44 <Kaidelong> functions are numbers
08:02:49 <Kaidelong> functions are monads, I'm guessing
08:02:58 <Kaidelong> that is the bizzare result
08:02:58 <Kaidelong> yay
08:03:35 <Kaidelong> > 3 4
08:03:36 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:03:36 <lambdabot>    `GHC.Num.Num t' arising f...
08:03:43 <Kaidelong> > fix 2
08:03:44 <lambdabot>   2
08:04:02 <Kaidelong> > flip liftM 2
08:04:03 <lambdabot>   Overlapping instances for GHC.Show.Show ((a1 -> r) -> m r)
08:04:03 <lambdabot>    arising from ...
08:04:16 <Kaidelong> :t flip liftM 2
08:04:18 <lambdabot> forall a1 r (m :: * -> *). (Monad m, Num (m a1)) => (a1 -> r) -> m r
08:04:58 <Kaidelong> someone please tell me that you wouldn't actually want to do these strange things to numbers and that lambdabot is just a silly bot
08:05:14 <Kaidelong> or am I wrong and this actually has some practical use?
08:05:22 <mreh> I have no idea what was going on
08:05:34 <hpc> it has some practical use, but you have to really look for it
08:05:42 <Darkone> Hahah
08:06:45 <adu> :t liftM
08:06:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:06:49 <Kaidelong> :t 3 4
08:06:50 <lambdabot>     Ambiguous type variable `t' in the constraint:
08:06:50 <lambdabot>       `Num t' arising from the literal `4' at <interactive>:1:2
08:06:50 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
08:07:13 <Kaidelong> :t 3 (4 :: Int)
08:07:14 <lambdabot> forall t. (Num (Int -> t)) => t
08:07:32 <Kaidelong> it typechecks, the horror
08:07:35 <adu> why is 3 a function
08:08:06 <Kaidelong> > 3 (4 :: Int)
08:08:06 <lambdabot>   3
08:08:16 <hpc> > fix (\x -> if x > 5 then x else x+1) 2
08:08:17 <lambdabot>   *Exception: (==): No overloading for function
08:08:25 <Kaidelong> > (3 (4 :: Int)) (5 :: Int)
08:08:26 <lambdabot>   3
08:08:36 <hpc> :t fix (\x -> if x > 5 then x else x+1) 2
08:08:37 <lambdabot> forall t t1. (Num (t -> t1), Ord (t -> t1), Num t) => t1
08:08:49 <Kaidelong> so basically you define numbers as their own least fixed points
08:09:04 <Saizan> no
08:09:10 <adu> but that's what const is for
08:09:29 <Saizan> fromInteger = const . fromInteger
08:09:38 <Kaidelong> > (+2) + (+2)
08:09:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:09:39 <lambdabot>    arising from a use of `...
08:09:47 <Kaidelong> :t (+2) + (+2)
08:09:48 <lambdabot> forall a. (Num a) => a -> a
08:09:57 <Kaidelong> :t 2 ((+2) + (+2))
08:09:58 <lambdabot>     Ambiguous type variable `a' in the constraint:
08:09:58 <lambdabot>       `Num a' arising from the literal `2' at <interactive>:1:5
08:09:58 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
08:10:00 <hpc> > (+2) + (+2) 5
08:10:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:10:01 <lambdabot>    arising from a use of `...
08:10:05 <hpc> > (+2) + (+2) 5 5
08:10:05 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:10:06 <lambdabot>    arising from a use of `...
08:10:15 <Kaidelong> :t ((+2) + (+2)) (5 :: Int)
08:10:16 <Saizan> > ((+2) + (+2)) 5
08:10:17 <lambdabot> Int
08:10:17 <lambdabot>   14
08:10:32 <Kaidelong> what
08:10:33 * hackagebot manatee 0.1.5 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.5 (AndyStewart)
08:10:45 <Kaidelong> oh
08:11:02 <Kaidelong> This is bizzare
08:11:23 <ddarius> > (sin^2 + cos^2) 3
08:11:24 <lambdabot>   0.9999999999999999
08:11:27 <adu> i would think that having numbers as types would be more useful than numbers as functions
08:11:49 <ddarius> You are free to think that.
08:12:24 <hpc> it's probably true, even
08:12:33 <Saizan> does the (A -> V) vector space have a name?
08:12:35 <Kaidelong> explaining why numbers are functions (and by extension monads) to someone would be really hard
08:12:44 <opqdonut> hmm, having k :: n for numbers k<n
08:12:49 <opqdonut> Saizan: free vector space over A
08:12:59 <opqdonut> no wait
08:13:34 <opqdonut> that's not it but there is a term. the structure of V induces a structure for functions A->V
08:13:49 <Kaidelong> adu: at that point shouldn't you just be looking into logic programming?
08:14:06 <parcs> > ((==) `on` ($ 3)) (1 - cos^2) (1 - sin^2)
08:14:07 <lambdabot>   False
08:14:08 <opqdonut> if A is finite, that's a free module
08:14:12 <adu> Kaidelong: at what point?
08:14:29 <Kaidelong> the point where you're thinking of numbers as having distinct types from one another
08:14:30 <opqdonut> in general free modules need the functions A->V to be finitely supported
08:14:58 <Kaidelong> so that f 3 may typecheck where f 4 won't
08:15:23 <adu> Kaidelong: that's not what I meant. what I meant was using numbers to denote types, but yeah, same thing
08:15:53 <adu> Vector is a common example
08:15:55 <ddarius> Because most algebraic structures (though not fields) are defined in terms of limits, and (A ->) is a right adjoint, (A ->) preserves that structure and thus most algebraic structures lift pointwise to functions.  So you have A -> M is a monoid/group/ring/etc. for monoids/groups/rings/etc. M.
08:17:03 <duckinator> Hmmm...is an sprintf/format function or similar?
08:17:07 <ddarius> printf
08:17:08 <adu> ddarius: you just blew my mind
08:17:12 <hpc> :t printf
08:17:12 <lambdabot> forall r. (PrintfType r) => String -> r
08:17:36 <unkanon> > printf "%s" "test" :: String
08:17:36 <lambdabot>   "test"
08:18:11 <adu> no that would be left adjoint
08:20:36 * hackagebot flower 0.6.5 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.6.5 (KetilMalde)
08:22:32 <dbelange> Hey jerks, when we take the dual of a category, is there any natural and concrete interpretation for that
08:22:35 <dbelange> or is it just a bunch of dots with arrows going the other way?
08:22:37 * hackagebot parallel-io 0.3.0.1 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.3.0.1 (MaxBolingbroke)
08:22:40 <ddarius> adu: I'm completely certain in everything I stated.  (A ->) doesn't have a right adjoint unless A is something that is, perhaps most commonly, called an "atom."  Atoms and these right adjoints are related to differential equations and their solutions.
08:23:56 <adu> we need more mathematicians in the world
08:25:18 <ziman> hm, (A ->) is Hom(A,—) ?
08:25:56 <ddarius> ziman: No, except in Set.
08:25:59 <McManiaC> "hey jerks"? :>
08:26:20 <ddarius> It's the functor that produces an exponential object.
08:26:51 <ziman> I see, —^A ?
08:26:57 <ddarius> Yes.
08:27:25 <ddarius> The left adjoint is Ax- and the actual adjunction is curry/uncurry.
08:28:18 <ddarius> Incidentally, the only thing keeping fields from being algebraic (in a certain technical sense) is the inequality 0 /= 1.
08:30:06 <adu> hmm
08:30:19 <ziman> Because it is inequality?
08:31:23 <ddarius> Basically.  Inequalities aren't limits.
08:43:43 --- mode: holmes.freenode.net set +o Cale
08:43:48 --- mode: holmes.freenode.net set +o ChanServ
08:44:01 <unkanon> well the book says that (*2) . pifun should be exactly the same as (*2) pi
08:44:40 <hpc> not exactly; _|_ can be :: ()
08:45:09 <hpc> and you can do nastiness with seq to change strictness too
08:46:08 <unkanon> the book made it look like f () = something was a function that did something without having to take parameters
08:47:03 <ddarius> Depending on the book it's possible that it is not using Haskell or that it means theoretically.
08:47:23 <ddarius> Since categories are what are known as almost-algebraic structures, they too are defined solely by limits and so they too are preserved by (A ->).  Presumably instance Category hom => Category (/\a b. x -> hom a b) where id = const id; f . g = \x -> f x . g x is correct (given a newtype instead of a type lambda.)
08:48:03 --- mode: holmes.freenode.net set +o Cale
08:48:03 --- mode: holmes.freenode.net set +o ChanServ
08:51:49 <Kaidelong> hpc: why would _|_ ever be ()?
08:52:02 <hpc> Kaidelong: of that type
08:52:08 <hpc> :t (undefined :: ())
08:52:09 <lambdabot> ()
08:52:10 <Kaidelong> isn't () a value while _|_ is the inability to get a value?
08:52:15 <unkanon> I thought the only thing of type () was ()
08:52:29 <Kaidelong> oh, I thought even the () type was lifted over _|_ and had two members
08:52:34 <Kaidelong> wait
08:52:39 <Kaidelong> > (undefined :: ())
08:52:40 <lambdabot>   *Exception: Prelude.undefined
08:52:46 <Kaidelong> > (() :: ())
08:52:47 <lambdabot>   ()
08:52:53 <hpc> the only types that cannot have bottom are the unboxed ones, i am fairly sure
08:52:55 <Nibble> so yo dawgs
08:53:01 <Nibble> wxhaskell vs gtk haskell
08:53:10 <Kaidelong> both are terrible
08:53:17 <Nibble> any good ones then?
08:53:22 <Kaidelong> no
08:53:31 <unkanon> you're right, the type () has two members
08:53:34 <Kaidelong> the one I've gotten working on windows as well as linux was GTK
08:53:44 <Nibble> FG then?
08:53:46 <Kaidelong> so go with that I guess
08:53:54 <Nibble> I don't care about windowz
08:53:59 <Kaidelong> never used grapefruit, don't know
08:54:21 <Kaidelong> if you want to use grapefruit use gtk since I do not think it has a wx backend anyway
08:54:44 <Nibble> let me put it this way then, what GUI library is more haskell?
08:55:47 <unkanon> Nibble: have you looked at TV?
08:55:56 <unkanon> I don't really know if that's a library
08:56:08 <unkanon> I just saw it mentioned and went look it up and found it pretty cool
08:57:28 <Kaidelong> that is pretty cool unkanon, also it's on hackage if that's what you were unsure about
08:58:08 <unkanon> oh ok then, I think I had just read a tutorial
08:58:22 <unkanon> I didtinctly remeber the tutorial's CSS was all unaligned and crooked
08:58:31 <unkanon> distinctly*
08:58:52 <Nibble> @src (.)
08:58:52 <lambdabot> (f . g) x = f (g x)
08:58:52 <lambdabot> NB: In lambdabot,  (.) = fmap
08:59:20 <aavogt> @src flip
08:59:21 <lambdabot> flip f x y = f y x
08:59:40 <aristid> :t flip
08:59:40 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:06:19 <ddarius> @tell copumpkin I have a 20% off coupon for a mattress if you are looking for one.
09:06:20 <lambdabot> Consider it noted.
09:08:04 <medfly> ??
09:08:08 <medfly> what?
09:15:18 * ddarius should make his messages into an idempotent monoid.
09:18:56 <shachaf> ddarius: Did copumpkin just move to MA?
09:19:12 <ddarius> shachaf: A little bit ago, yes.
09:19:27 <shachaf> Ah. For some reason I thought he'd been there for a while.
09:22:46 <rkrzr> @tell rkrzr does this work?
09:22:47 <lambdabot> You can tell yourself!
09:22:53 <rkrzr> lol
09:24:58 <ketil> Saizan (-1.5h), thanks.  I've uploaded a revised .cabal, let's see if it works... 
09:31:01 <jmc_fr_> hello - basic question : how to get this working (I receive a "Illegal instance declaration for `Show Hillside' ") ?  1. data UpDown = Up | Down deriving Show              2. type Hillside = Maybe UpDown                  3. instance Show Hillside where     show ( Just Up ) = "foo" (etc...)
09:31:17 <lispy> jmc_fr_: hi
09:31:37 <lispy> jmc_fr_: if you want to use us some code, I recommend hpaste.org  (now I'll read your question more carefully)
09:31:52 <jmc_fr_> lispy: hi + OK
09:32:02 <lispy> jmc_fr_: So, type class instances are for data types not 'type'
09:32:09 <lispy> jmc_fr_: 'type' just creates an alias
09:32:20 <mauke> there's already a Show instance for Maybe UpDown
09:32:48 <jmc_fr_> I want to define my own show : how can I do that
09:33:06 <mauke> what, for Maybe?
09:33:08 <mauke> you can't
09:33:16 <mauke> make another type
09:33:24 <lispy> jmc_fr_: One way is to write: newtype Hillside = Hillside (Maybe UpDown)
09:33:28 <adu> jmc_fr_: instance Show X where show x = ...
09:33:34 <mauke> adu: ...
09:33:45 <monochrom> need more scrollback
09:33:46 <ddarius> The error is actually complaining about two other limitations of Haskell 98/2010 instances even before getting to overlap.
09:34:28 <jmc_fr_> lispy : OK tkx
09:34:32 <ddarius> You can't make instances of type synonyms and you can't make instances of the form T A, they need to be T a (i.e. have only type variables as arguments.)
09:34:34 <jmc_fr_> mauke: OK tkx
09:34:46 <ddarius> Both of those restrictions and even the overlapping one can be lifted with extensions.
09:35:41 <jmc_fr_> ddarius: which extensions ?
09:35:45 <lispy> I think lifting them seems unnecessary
09:35:56 <srobertson> it isn't possible even with language extensions to construct a list containing different instances of the same class, right? they have to be wrapped? (i.e. ( [1 :: Int, 2 :: Double] :: [Num] ) )
09:36:08 <shachaf> jmc_fr_: You probably don't want them.
09:36:10 <lispy> jmc_fr_: -XFlexibleInstances and -XOverlappingInstances
09:36:16 <ddarius> jmc_fr_: The former ones are mild, but you don't want overlapping instances
09:36:21 <shachaf> lispy: In general or on this particular case?
09:36:21 <monochrom> srobertson: right
09:36:28 <srobertson> monochrom: 'k, thx
09:36:36 <lispy> shachaf: in this case
09:36:38 <shachaf> s/o/i/
09:36:43 <augur> wee
09:36:45 <jmc_fr_> OK
09:36:48 <augur> zipper-based delimited continuations :D
09:36:57 <lispy> augur: oh, what are you doing?
09:37:11 <lispy> augur: Are you just learning about them or are you making use of them?
09:37:14 * ddarius will make an IRC client that accumulates only so much chat and then stops.  No longer will one lament a lack of scrollback, though there may be complaints about a lack of scrollforward.
09:37:34 <augur> lispy: well, im teaching a friend SICP, and were eventually going to go over delimited continuations, and i've decided that there are a few ways we can do them
09:37:37 <shachaf> srobertson: Well, with some language extensions it's sort of possible. But :: [Num] doesn't make any sense.
09:37:38 <augur> and one of those ways is zippers
09:38:01 <augur> so ive been working to figure out how zippers can be used to handle delimited continuations
09:38:21 <lispy> augur: Well...there is a correspondence between them but teaching zippers won't help your friend understand del cont code, i'm pretty sure
09:38:37 <augur> lispy: well, he already understands the spirit of delcont's
09:38:40 <lispy> augur: Have you read Oleg's generalized zipper paper?
09:39:06 <augur> you see, we're both chomskyan linguists, and delconts are, under another name, intimately part of modern chomskyan syntactic theory
09:39:24 <lispy> Ah yeah, Oleg has some papers about that as well
09:39:35 <augur> so its not the spirit of delconts that he has to understand, it's the details
09:39:40 <augur> specifically
09:39:43 <lispy> augur: http://okmij.org/ftp/continuations/Continuations.html
09:39:51 <augur> we're building delconts into the evaluator
09:40:03 <augur> so im going to show him three ways of doing that
09:40:05 <augur> one is with zippers
09:40:23 <lispy> ah
09:40:43 <augur> lispy: i'll send you the code. you'll be please, i think. it's in scheme. :D
09:41:02 <lispy> heh, I never learned scheme, but I was a CL lisper for a while
09:41:29 <augur> scheme is easy
09:41:30 <lispy> These days, I'm all about Haskell and beyond.  I've been studying me some Isabelle/HOL lately
09:41:32 <augur> easier than CL
09:42:13 <lispy> Speaking of which, Isabelle has an IRC channel on freenode now (#isabelle) for anyone interested in it
09:42:40 <srobertson> shachaf: really going for [(String, JSON a)], as an argument to a function that would call 'toJSON' on each 'a'. just a convenience thing, to avoid many calls to 'toJSON' in list bodies when serializing.
09:44:58 * ddarius likes how the solution to all his threading issues is more threads.
09:44:58 <phao> Hi
09:45:06 <phao> Is there any "K&R" for haskell?
09:45:18 <ddarius> You can read the Report.  It's quite readable.
09:45:20 <Kaidelong> Bird and Wadler's book perhaps
09:45:34 <Kaidelong> http://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460
09:45:34 <phao> ddarius, right... I'm reading this "Programming in Haskell"... damn, that thing sucks
09:45:36 <monochrom> The Gentle Introduction to Haskell
09:45:46 <hpc> @where lyah
09:45:46 <lambdabot> http://www.learnyouahaskell.com/
09:45:48 <hpc> ^
09:46:17 <aavogt> Kaidelong: where is the wadler in that book?
09:46:21 <phao> thx folks
09:46:32 <Kaidelong> aavogt: I don't know!
09:46:49 <Kaidelong> I just heard it called the B&W book before, perhaps that is incorrect
09:47:06 <monochrom> Wadler was in the 1st edition but not the 2nd edition
09:47:14 <Kaidelong> aavogt: amazon lists philip wadler as an author
09:47:30 <shachaf> phao: Hutton's _Programming in Haskell_?
09:47:40 <ddarius> Every FP book needs Lambda Man.
09:47:46 <phao> shachaf, 
09:47:47 <phao> yes
09:47:51 <monochrom> haha
09:48:05 <Kaidelong> ddarius: lambda man? didn't LYAH just use gordon freeman?
09:48:06 <shachaf> phao: I seem to remember that it was quite good. What's the issue with it?
09:48:20 <phao> hmm
09:48:28 <ddarius> http://www.cs.uni.edu/~wallingf/blog-images/misc/lambda-man.jpg
09:48:32 <phao> had some problems so far.. last one is a "missing definition"
09:48:38 <Kaidelong> oh I see
09:48:46 <phao> let me see
09:48:51 <Kaidelong> lambdaman is lambda
09:49:21 <sipa> who is that?
09:49:38 <monochrom> This is why "the 'K&R' of Haskell" doesn't say what you mean.
09:49:38 <phao> "The idea that + can be applied to numbers of any numeric type is made precise in its type by the inclusion of a class constraint. Class constraints are written in the form C a , where C is the name of a class and a is a type variable. For example, the type of + is as follows:"
09:49:54 <phao> and then it gives an example, of the + operator
09:50:02 <phao> end of page 23, begin of page 24.
09:50:24 <phao> and after that it assumes that I know what a class contraint is
09:50:44 <augur> lispy: http://paste.lisp.org/display/117606
09:50:56 <phao> or it assumes it explained it
09:51:05 <jedai_> phao: it never spoke of type class before ?
09:51:06 <shachaf> phao: Didn't it?
09:51:13 <phao> jedai_, no
09:51:17 <ddarius> augur: Needs more types.
09:51:21 <augur> x3
09:51:27 <lispy> augur: list zipper?
09:51:34 <phao> this is section 3.8 
09:51:37 <augur> lispy: well, scheme-list zipper
09:51:56 <lispy> augur: what means you, "scheme-list"?
09:52:17 <augur> lispy: well, scheme lists arent mono-typal, right, so '(1 (2 3) 4) is a valid scheme list
09:52:25 <augur> but [1,[2,3],4] is an invalid haskell list
09:52:45 <ddarius> Lisp lists are rose trees.
09:52:56 <augur> so then its a rose-tree zipper :)
09:52:59 <lispy> augur: So, would it actually work as a tree?
09:53:13 <augur> lispy: well the way im using it, its as a rose tree
09:53:23 <lispy> ddarius: http://3.bp.blogspot.com/_MK_1sahlTjE/Sl-braLMDEI/AAAAAAAACIc/Lp1PG-gqh1M/s400/pink+rose+tree.jpg ?
09:53:36 <augur> its preprocessing scheme code
09:53:40 <ddarius> lispy: You got it.
09:53:46 <lispy> sweet!
09:53:46 <jedai> phao: Well, type class are a mechanism by which several types can be declared to be instances of a class which normally comes with support of a certain number of functions that can be defined specifically type by type
09:53:54 * ddarius presumes that's an elaborate way for augur to say "Yes."
09:54:10 <augur> ddarius: perhaps!
09:54:27 <aavogt> for type-directed name resolution
09:54:53 <jedai> phao: Polymorphism allows you to write functions that works for several types but these functions works the same way for every type
09:54:59 <augur> so if you load this up and then eval this: (decontinuize '(reset x (reset y (+ (shift x 1) (shift y 2)))))
09:55:03 <phao> monochrom, this one? http://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/
09:55:16 <augur> what you get out is ((lambda (f) (f 1)) (lambda (x) ((lambda (f) (f 2)) (lambda (y) (+ x y)))))
09:55:23 <monochrom> that's probably too old
09:55:36 <phao> ouch, yes... 97
09:55:39 <shachaf> phao: OK, I found that page on Google Books. It seems to clarify more than you said.
09:55:42 <jedai> phao: Whereas with type class each type can have his own implementation of the function 
09:55:51 <phao> shachaf, does it?
09:55:55 <shachaf> phao: Did you read past the type of (+)? :-)
09:55:55 <ddarius> shachaf: This is a common occurrence.
09:55:59 <monochrom> http://www.haskell.org/tutorial/ is for Haskell 98
09:56:19 <monochrom> "too old" was for "haskell 1.4"
09:56:25 <phao> shachaf, I read the whole section 3.8
09:56:28 <ddarius> monochrom: All we need to do is remove the n+k section and rename it and it will be for 2010.
09:56:35 <monochrom> yeah
09:57:05 <phao> shachaf, and probably, the definition jedai just gave is worth more than that whole section
09:58:28 <shachaf> phao: I don't see see that it communicates significantly more useful information that http://books.google.com/books?id=olp7lAtpRX0C&lpg=PA23&ots=IvNYgz6C9V&pg=PA23 (of course, I am not you).
09:59:29 <phao> shachaf, I can't make sense out ofthat section
09:59:33 <phao> but only after the 
09:59:38 <shachaf> phao: Which part?
09:59:49 <phao> "A type that contains one or more class constraints, ..."
10:00:10 <phao> "A type that contains one or more class constraints is called overloaded, as is an expression ..."
10:00:32 <hpc> "overloaded" is a haskell term now?
10:00:36 <phao> it doesn't tell what a class constraint is, I don't know what it means a type having more than one class constraint
10:00:52 <shachaf> phao: It explains class constraint right on that page (or the previous one).
10:01:17 <phao> it just tells how they're written
10:01:19 <shachaf> phao: When a word is in italics, that means it's explaining what it means. "class constraint" means that something is constrained to a class. :-)
10:01:45 <phao> "The idea that + can be applied to numbers of any numeric type is made precise in its type by the inclusion of a class constraint. Class constraints are written in the form C a , where C is the name of a class and a is a type variable."
10:01:48 <phao> Honestly
10:01:53 <phao> that doesn't explain class contraints to me
10:02:13 <monochrom> No, but it defines class constraints.
10:02:18 <shachaf> That's why he has examples.
10:02:19 <phao> where?
10:02:25 <phao> I see no definition there too
10:02:38 <monochrom> "Class constraints are written in the form ..." Definition.
10:02:43 <phao> that's not a definition
10:02:56 <monochrom> Then what is a definition?
10:03:26 <shachaf> monochrom: A definition is to be written in the form... Er, never mind.
10:03:36 <monochrom> hehe
10:04:19 <monochrom> "a prime number is a number not divisible by so-and-so" Definition.  Oh it doesn't "explain" the "purpose" of prime numbers, but it is a definition.
10:04:22 <phao> monochrom, something like jedai said earlier... I don't know if the definition he gave was right
10:04:30 <phao> monochrom, but say what it is
10:04:32 <monochrom> That is purpose not definition.
10:04:36 <phao> a prime number IS
10:04:39 <phao> something IS
10:04:44 <phao> this "IS" is normally present on definitions
10:04:55 <monochrom> are = is  except for plural
10:05:01 <phao> =)
10:05:14 <monochrom> "prime numbers are numbers not divisible by so-and-so" Definition. No "is".
10:05:15 <hpc> conflating 'is' and 'is used for' is what resulted in so many bad monad tutorials ;)
10:05:25 * hackagebot stringsearch 0.3.3 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.3 (DanielFischer)
10:05:37 <shachaf> That book has one of the better monad tutorials that you can find, by the way, I think.
10:06:02 <shachaf> It uses parsers, which is entirely reasonable, and doesn't even mention the word "monad" until it's introduced more than one.
10:06:23 <phao> I have no clue what is this monad thing, but I can see how he explained what class constraints are
10:06:36 <phao> looks like my math book from high school trying to explain matrixes
10:06:49 <shachaf> phao: Was jedai's clarification helpful?
10:07:07 <monochrom> I propose that it's just your English skill.
10:07:19 <phao> monochrom, it's not.
10:07:59 <monochrom> "A class constraint is written in the form C a"  There is your IS.
10:08:32 <hpc> that doesn't explain what it is, it explains what the /syntax/ is
10:08:32 <phao> hehe
10:08:52 <phao> and it's pretty useless knwoing how to write it 
10:08:54 <phao> if I don't know what it is.
10:09:00 <monochrom> It's a definition. Definitions are not meant to explain.
10:09:08 <phao> monochrom, yes
10:09:11 <phao> they're made to tell what something is.
10:09:14 <aavogt> it's also useless to know what it does without being able to write it
10:09:19 <phao> and that definition doesn't do it.
10:09:28 <phao> aavogt, yes... there has to be both in the book
10:09:31 <phao> there is only one of them
10:09:51 <phao> maybe more than those two.. I don't know what makes it totally complete
10:09:56 <phao> but it's lacking something
10:09:59 <monochrom> What is "explain"?
10:10:04 <shachaf> <S. Gorn> A formalist is one who cannot understand a theory unless it is meaningless.
10:10:17 <monochrom> And yes I'm a formalist.
10:10:39 <shachaf> If you're asking for *definitions*, you should expect formalist-type answers. :-)
10:10:43 <copumpkin> ddarius: thanks, but I already have a mattress/bed, just need to move it down from storage! Will probably do it on tuesday :D
10:10:55 <monochrom> Because I'll attach my favourite meaning to the formalism and discard your favourite meaning, thank you very much.
10:11:27 <aristid> monochrom: so for you, a monad is not a burrito?
10:11:33 <shachaf> @quote a.monad.is
10:11:33 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
10:11:59 <tonkman> what is the best way to parse command line arguments like "-d 5 -n 10"
10:12:08 <aavogt> @hackage cmdargs
10:12:08 <lambdabot> http://hackage.haskell.org/package/cmdargs
10:12:19 <tonkman> or is it not the haskell way to do things?
10:12:27 <aavogt> that one is probably the shortest way t odo that
10:12:44 <tonkman> oh, theres a library :)
10:12:58 <aavogt> besides maybe:
10:13:03 <shachaf> phao: I learned about type classes from Hutton's book, by the way, as far as I recall.
10:13:20 <shachaf> Actually, I'm not quite certain, but I read it fairly early into learning Haskell, at any rate.
10:13:24 <phao> shachaf, so, he probably explains somewhere else.
10:13:29 <augur> lispy: mutchu fink
10:13:36 <augur> ?
10:13:41 <shachaf> phao: Probably. One approach is to keep reading. :-)
10:13:55 <monochrom> In fact probably type-level programmers disagree with the "several types can be declared to be instances ..." meaning. They seem to use the "this is just like Prolog" meaning instead.
10:13:59 <tonkman> I think Im going to write my own parsing functions, just for practice
10:14:00 <phao> yeah... I just don't like keep reading if I don't understand something
10:14:36 <aavogt>   main = do ["-d",d,"-n",n] <- getArgs -- if you insist on strict ordering of arguments
10:14:57 <aavogt> with no default values etc.
10:15:17 <shachaf> And on crashing with a nasty error if the arguments aren't exactly correct. :-)
10:16:02 <lispy> augur: what?
10:16:09 <augur> lispy: what do you think?
10:17:02 <lispy> augur: seems alright for dynamically typed code
10:17:07 <augur> :P
10:17:10 <lispy> augur: I can't really read it anymore
10:17:12 <augur> aww
10:17:17 <augur> you need types?
10:17:22 <augur> ILL GIVE YOU TYPES
10:17:24 <augur> no, i wont
10:17:27 <augur> not yet
10:17:40 <lispy> Partly, but I also haven't used lisp since circa 2004
10:17:48 <augur> eventually  i'm actually going to build types into this evaluator
10:18:35 <augur> and we're going to use mismatches as the way to handle continuization, instead of with shift and reset
10:18:36 <augur> :T
10:18:37 <shachaf> lispy: You need a /nick.
10:19:01 <augur> well, maybe we'll use reset still. it'll depend.
10:19:23 <lispy> shachaf: sometimes I think about using my name as my nick
10:19:32 <lispy> Then I always come back to lispy
10:19:40 <lispy> haskelly just isn't the same
10:20:04 <Adamant> haskello
10:20:05 <lispy> Dr. Lispy and Mr. Haskelly
10:21:30 <shachaf> lispy: Your voice is much deeper than I expected "lispy" to have.
10:22:00 <lispy> heh
10:22:08 <unkanon> did he sound more like a Grontor ?
10:22:23 <lispy> When my girlfriend found out about my irc nick, she said, "But you don't have a lisp!"
10:22:53 <ion> “you just have a haskell!”
10:22:55 <lispy> "You see, it's not really about how I talk..there's this programming language and you see..."
10:24:36 <shachaf> ion: "Having a Haskell" sounds much worse than "Having a lisp".
10:27:23 <ion> I see a doctor looking you in the eye, touching your shoulder and saying in an empathetic voice “I’m sorry, but you… have a Haskell. It’s malignant.”
10:27:24 <monochrom> now tell your girlfriend you have an isabelle :)
10:28:24 <lispy> monochrom: haha, I actually said, "If I start talking about how much I like Isabelle, don't get jealous..."
10:28:31 <monochrom> hahaha
10:28:57 <aavogt> haskell looks like miranda
10:29:15 <ddarius> lispy: It could be worse, you could be using that other proof assistant...
10:29:39 <lispy> ddarius: "I love Coq!  It's so great....what's wrong?  Oh ...."
10:29:58 <lispy> ddarius: or maybe you meant epigram? ;)
10:30:17 <unkanon> I think Coq is really pronounced coak, isn't it? isn't it French for chicken or something?
10:30:35 <lispy> unkanon: It's french for rooster, AFAIK
10:30:40 <copumpkin> I love pig coq
10:30:46 <unkanon> ok
10:30:54 <unkanon> i'm trying to find out how it's pronounced
10:31:01 <copumpkin> it's pronounced like COCK
10:31:22 <unkanon> I doubt it
10:31:39 <unkanon> Coq au vin = coak oh vun
10:32:00 <copumpkin> no, it's like cock
10:32:06 <augur> copumpkin: unkanon is correct as far as french pronunciation is concerned, i think
10:32:10 <copumpkin> not coak
10:32:30 <copumpkin> no
10:32:33 <lispy> http://www.forvo.com/word/coq/  <-- has a sound bite you can play to hear it
10:32:34 * hackagebot http-enumerator 0.2.1.5 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.1.5 (MichaelSnoyman)
10:32:35 <augur> are you french?
10:32:44 <copumpkin> I've lived in france for a fairly decent period of my life
10:32:50 <copumpkin> it isn't like cock how an american would say it
10:32:54 <number9> So I am trying to code literate haskell in markdown (pandoc), and it throws an error if there are any headings done starting with a #. Any ideas?
10:32:56 <copumpkin> it's shorter
10:33:03 <copumpkin> but it doesn't sound anything like coak
10:33:04 <augur> where's the IPA for this shit
10:33:05 <unkanon> copumpkin is right, it's cock
10:33:10 <unkanon> http://www.cnrtl.fr/definition/coq
10:33:11 <medfly> but yes it sounds like cock because that's what it means
10:33:22 <unkanon> the IPA is [kɔk]
10:33:23 <lispy> number9: can you show me an example?
10:33:26 <augur> oh
10:33:31 <augur> thats not cock, then, unkanon / copumpkin
10:33:34 <augur> thats caulk
10:33:51 <unkanon> uhm.. I don't think so
10:33:56 <augur> unless you have the cot/caught merger
10:33:58 <Kaidelong> @pl a >>= \_ -> b
10:33:58 <lambdabot> a >> b
10:34:02 <augur> in which case it is indeed cock
10:34:03 <Kaidelong> err
10:34:04 <unkanon> yes I have that merger
10:34:10 <augur> but in my dialect of english its caulk
10:34:17 <Kaidelong> @pl \a b -> a >>= \_ -> b
10:34:17 <lambdabot> (. const) . (>>=)
10:34:18 <unkanon> what's your dialect?
10:34:35 <augur> long island, with a healthy influence of documentary english
10:35:18 <unkanon> hmm
10:35:38 <number9> lispy: so I have a file that goes like this: # Main heading \n  \n a line of text \n \n ## Second level heading \n \n >funct x = x \n >funct 0 = 1 and if I try to load it in haskell it throws an error, and gives me the first line where there was a #, and says error at the character that follows the #
10:36:05 <lispy> number9: does your file have .lhs as the extension?
10:36:19 <aavogt> don't you need spaces after the >?
10:36:39 <lispy> number9: you can use hpaste.org to show us the example verbatim :)
10:36:46 <number9> aavogt: yes, my bad there are
10:37:12 <lispy> number9: You may need -XMagicHash but, that seems odd.  GHC should be ignoring everything that's not starting with "> "
10:37:30 <aavogt> doubtful regarding the extension
10:38:46 <jedai> augur: As a french I can confirm that coq is pronunced as cock in english (though maybe a bit shorter o), not with au of caught
10:38:59 <phao> shachaf, now I see it
10:39:05 <augur> jedai: IPA says you're wrong :P
10:39:09 <phao> reading http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
10:39:31 <phao> class constraint is just the restriction of types that is made using those type classes
10:39:37 <phao> they're not the classes themselves.
10:39:39 <number9> lispy: ok: http://hpaste.org/42272/lhs_test
10:39:40 <unkanon> he's just saying he pronounces cock like coq, not the other way around
10:40:43 <number9> lispy: also the extention is .lhs which I thought was enough to tell ghc to ignore lines that don't start with >
10:40:45 <copumpkin> augur: come on :P
10:40:46 <phao> shachaf, now, that part I wasn't understanding makes sense 
10:41:03 <jedai> augur: Well I never heard it pronunced otherwise and I have been in several regions where coq is an appreciated food ;)
10:41:28 <augur> jedai: im more skeptical of your pronunciation of cock, than i am of your pronunciation of coq :P
10:41:34 <unkanon> not merging ɑ ɔ in the US is very uncommon. therefore I rule augur is wrong :P
10:42:07 <Twey> Disagree… cot/caught merger is about 50:50 in the US at the moment
10:42:13 <jedai> augur: I'm pretty sure that I don't conflate caught and cock and that the o in coq is much closer to cock than to caught
10:42:17 <Twey> But the vowel length is different anyway
10:42:27 <unkanon> Twey: not according to maps
10:42:33 <Twey> It's the vowel length difference you hear.  It's more significant than you think.
10:42:42 <copumpkin> augur: I'm a native english speaker and (at some point) fluent french speaker 
10:42:56 <Kaidelong> number9: your factorial function is quite interesting actually
10:42:57 <Twey> unkanon: http://en.wikipedia.org/wiki/File:Cot-caught_merger.png
10:43:08 <unkanon> right, that's exactly what I'm looking at
10:43:28 <augur> jedai:   http://media.merriam-webster.com/soundc11/c/cock0001  http://media.merriam-webster.com/soundc11/c/caulk_01
10:43:38 <unkanon> Twey: there's much more gray than dots in there
10:43:55 <augur> unkanon: you seem to be color blind. there are no grey dots.
10:43:57 <Kaidelong> > let myFact n = case n of {0 -> n; n -> n * (n-1)} in myFact -54 --number9
10:43:58 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
10:43:58 <lambdabot>    arising from a use of `...
10:44:08 <Kaidelong> > let myFact n = case n of {0 -> n; n -> n * (n-1)} in myFact -54 :: Int --number9
10:44:09 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:44:09 <lambdabot>         against inferred type ...
10:44:09 <Twey> unkanon: Yes
10:44:20 <Twey> unkanon: But the dots are about 50:50
10:44:23 <Kaidelong> > let myFact n = case n of {0 -> n; n -> n * (n-1)} in myFact (-54) :: Int --number9
10:44:24 <lambdabot>   2970
10:44:26 <jedai> I love this channel... It's probably one of a handful where you can heard such a conversation amid debate on formalism, type system, close to the metal problems and so on...
10:44:35 <unkanon> augur: there are many gray dots, it's just they're so close together all you see is a big gray blob in the shape of a state
10:44:46 <Twey> Er, no
10:44:47 <augur> unkanon: :P
10:44:50 <Twey> Haha
10:44:58 <augur> unfortunately that is not one of the labels
10:45:04 <phao> btw... are lines like this "name :: Int -> Int" called declarations, like in C?
10:45:08 <ddarius> As another data point, I was born and raised in northern Virginia and I both perceive and pronounce "cot" and "caught" the same.
10:45:26 <unkanon> augur: well it's wikipedia, they forgot the gray label
10:45:36 <augur> this map is confusing tho
10:45:37 <Twey> phao: Type declarations or type signatures, yes
10:45:38 <copumpkin> Johnnie Walker Grey Label?
10:45:42 <lispy> number9: this is weird
10:45:44 <phao> Twey, thx.
10:45:55 <lispy> number9: I downloaded your code to play with it, but I'm not making good progress
10:45:56 <number9> lispy: how do you mean?
10:46:07 <augur> because it's got negation and conjunction/disjunction
10:46:11 <augur> but which scopes over which?
10:46:11 <ddarius> phao: They are a type of declaration specifically called "type signatures."
10:46:18 <lispy> number9: I really don't understand why ghc is having an issue if it's not using CPP
10:46:19 <ddarius> http://haskell.org/onlinereport/decls.html
10:46:43 <number9> lispy: what does CPP mean?
10:46:51 <copumpkin> number9: c preprocessor
10:47:08 <augur> anyway, unkanon, wikipedia says only 40% of americans have the merger
10:47:09 <number9> copumpkin: ah thanks
10:47:10 <augur> therefore im right
10:47:10 <augur> :D
10:47:26 <augur> jedai: did you listen to the links?
10:47:31 * ddarius doesn't even know -how- you'd pronounce "caught" differently.
10:47:35 <jedai> augur: I note that cock is another name for a rooster in english... I think that pretty much settle the debate
10:47:41 <lispy> number9: oh, I see
10:47:49 <augur> jedai: it settles nothing because english is not french
10:47:58 <copumpkin> augur: I'm not even really american
10:48:01 <augur> we're talking about french pronunciation of coq, not english pronunciation of coq
10:48:07 <augur> er, not english pronunciation of cock
10:48:11 <augur> copumpkin: WAT
10:48:13 <augur> canadian?
10:48:13 <copumpkin> we're saying they're fairly similar
10:48:16 <unkanon> augur: you win then :)
10:48:19 <lispy> number9: http://hpaste.org/paste/42272/lhs_test_annotation#p42275
10:48:21 * chrisdone rubs pasta into copumpkin's italian hair
10:48:22 <unkanon> augur: but we'll take over!
10:48:35 <augur> unkanon: ofcourse i win! im right!
10:48:39 <sm> cabal install ExitFailure 11 issue opened at http://hackage.haskell.org/trac/hackage/ticket/777 , please update if you have insight
10:48:42 <lispy> number9: GHC's unlint leaves in lines with #
10:48:45 <augur> copumpkin: this is an empirical issue.
10:48:48 <copumpkin> augur: I'm technically american, among other things :P
10:48:57 <jedai> augur: Do you pronunce the cock in cock-a-doodle-do like cock ? That's exactly how you pronunce it in french (it's probably the same word, borrowed from one side or the other)
10:48:59 <augur> copumpkin: i provided data for jedai to judge.
10:49:13 <augur> jedai: you still havent responded to the links jedai
10:49:30 <jedai> augur: i listened to caulk and that's not how you pronunce  it in french
10:49:33 <number9> lispy: that isn't supposed to happen is it?
10:49:34 <lispy> number9: so, we should look at the source to see what the command line flags of unlint mean
10:49:35 <augur> you can say its the same as in french, but if _you_ dont know how "cock" is pronounced, then it's irrelevant
10:49:40 <augur> jedai: did you listen to "cock"?
10:49:42 <chrisdone> Check it out, playing with some Lisk: http://hpaste.org/raw/42273/lisk_ircd_demo :-)
10:49:45 <copumpkin> augur: your argument against him earlier was that he knew how to pronounce coq in french, but maybe not cock in english. I provided myself as a datapoint as a native english speaker and a fluent french speaker who has spent a couple of years in france
10:49:55 <lispy> number9: well, it wants to do that so you can pass things like, "#ifdef" to the next stage of compilation
10:50:03 <ddarius> jedai: Probably English taking it from French or a predecessor.  I don't think the German's use anything like "cock" for rooster.
10:50:10 <augur> copumpkin: your judgments are invalid. :P
10:50:13 <number9> lispy: if it helps paste.lhs on gitit.net, doesn't ever use the # style headings, which made me suspicious to start
10:50:31 <augur> jedai: better yet, you pronounce it. send us a recording!
10:50:44 <augur> we can do formant analyses and determine the truth of the matter!
10:50:45 <jedai> augur: I am fairly fluent in english, not very good but still good enough to know the pronunciation of caulk and cock (and yes I listened and it's the same as coq in french)
10:51:04 <augur> jedai: well im still skeptical.
10:51:16 <unkanon> and i'm already bored
10:51:24 <jedai> augur: Ok... I think that's going too far, I not _that_ eager to convince you !
10:51:32 <copumpkin> augur: crushing point! I concede
10:51:37 <lispy> augur: if you can figure out the difference you'll be a Coq master!
10:51:51 <unkanon> yeah I'm not a coq expert
10:51:51 <chrisdone> Guys, shut up about Haskell already, I'm sick of hearing about it!
10:52:15 <augur> lispy: well, i dont know about that. but i _am_ a linguist
10:52:23 <lispy> chrisdone: So, I was writing this 400 line "function" in Java and I totally assigned to a variable twice and the code was all like....
10:52:37 <copumpkin> to me, it sounds like cock with a shorter vowel than most americans would pronounce it with
10:52:37 <copumpkin> mmm, coq
10:52:41 <augur> and i know for a fact that standard french orthographic <o> isn't pronounced /A/
10:52:55 <number9> lispy: is there any way around that? So that lines that start with # can be ignored by haskell and listened to by pandoc?
10:53:06 <ddarius> And we all know theory trumps the facts on the ground.
10:53:16 <lispy> number9: Maybe, I'm trying to find the source code so we can see what the command line flags do
10:53:38 <number9> lispy: thanks again for all your help!
10:53:50 <lispy> number9: np!
10:54:01 <jedai> augur: Well it has differend pronunciation depending on the word for instance the o in "moteur" is much more like the o in caulk
10:54:07 <copumpkin> ddarius: damn straight
10:54:32 <augur> jedai: does the vowel in <coq> sound like the vowel in <paul>
10:54:54 <lispy> why is unlit written in C?
10:54:55 <jedai> augur: Nope, in paul the au sounds much like the au of caulk
10:54:55 <copumpkin> augur: that (paul) differs regionally?
10:55:12 <hpc> it sounds like the vowel in "pall" though
10:55:18 <augur> jedai: where in franch are you from
10:55:27 <augur> hpc: im not talking about english
10:55:33 <jedai> augur: Normandy
10:55:41 <jedai> Seine-Maritime
10:55:48 <copumpkin> mmm
10:55:52 <lispy> number9: -r and -P look interesting
10:56:22 <ddarius> Incidentally, the conservation of energy will never, ever be refuted.
10:56:29 <jedai> We have some issues with the é and the è compared to most others french speakers but not with the o as far as I know
10:57:00 <chrisdone> …
10:57:04 <copumpkin> well, considering his question about paul seems pretty vague
10:57:13 <copumpkin> I'd take it with a grain of sault ;)
10:57:21 <augur> jedai: im willing to bet you have other differences as well
10:57:28 <jedai> augur: And I'm mostly immune from those issues given the background of my parents
10:57:41 <augur> standard french has <coq> and <paul> with the same vowel
10:57:51 * copumpkin screams at augur
10:57:56 <augur> you're unlikely to be immune, jedai. thats not how language works.
10:58:14 <jedai> augur: Right, sure, whatever you want.... o_O
10:58:20 <copumpkin> man, such arrogance
10:58:23 <mathijs> Hi all, I came across a notation that I didn't know. at the bottom of https://github.com/TonyGen/mongoDB-haskell/blob/master/Control/Pipeline.hs  "send Pipeline{..} messages = withMVar vHandle (writeAll listenThread encodeSize messages)" the {..} part
10:58:28 <augur> its true!
10:58:43 <copumpkin> augur: oh shut up
10:58:48 <augur> children do not speak the same dialect as their parents, not entirely. they speak the dialect of the people they're surrounded by
10:58:57 <aavogt> mathijs: it's the RecordWildCards
10:58:59 <augur> parents included, but not just
10:59:18 <copumpkin> augur: you're asking an ambiguous question about paul, which invalidates most of my respect for your position
10:59:22 <lispy> number9: you'd have to compile a new version of unlit and install that, and then it would probably break everything else
10:59:23 <mathijs> aavogt: thanks, I'll look that up :)
10:59:30 <augur> copumpkin: ambiguous question? what?
10:59:34 <augur> what are you talking about
10:59:40 * ddarius is eating some French bread (made in America) right this second and thus feels empowered to authoritatively pontificate on the French language.
10:59:45 <copumpkin> paul is pronounced differently in england from the US
10:59:49 <jedai> augur: Did I also said that I spent much of my time in other regions and that they never ever rectified my pronunciation, and globally had the same one (and not one link to Normandy either)
10:59:52 <augur> copumpkin: what
10:59:53 <lispy> number9: looks like you'll need to run a markdown preprocessor to extract the haskell and then feed that to ghc (or add support for this to ghc directly)
11:00:03 <augur> copumpkin: this has nothing to do with ANY english pronunciation of paul
11:00:11 <lispy> I think at this point we should move the off topic discussion to #haskell-blah
11:00:14 <augur> copumpkin: i was asking him about his native french pronunciation of the french name paul
11:00:37 <copumpkin> ah oaky
11:00:42 <augur> jedai: well, this can't truly be solved until we have some audio to work with
11:00:43 <lispy> mathijs: looks like record syntax
11:00:45 <copumpkin> anyway, you're annoying
11:00:51 <number9> lispy: I guess I understand haskell needing to interpret lines that start with # but why in bird-style literate haskell wouldn't they be > # lines?
11:01:02 <augur> so jedai, i'll accept for now that you do indeed pronounce french <coq> like english <cock>
11:01:13 <copumpkin> fina-fucking-ly
11:01:16 <copumpkin> :P
11:01:21 <lispy> number9: it's a bug in unlit, the processor that ghc uses to strip out non-haskell bits
11:01:32 <augur> copumpkin: THE PURSUIT OF TRUTH IS NOT ANNOYING
11:01:33 <augur> >O
11:02:04 <copumpkin> augur: the arrogance of contradicting/discounting people with real world experience is though
11:02:04 <number9> lispy: are you sure it is a bug and not some obscure feature?
11:02:11 <lispy> augur: No, but this is the wrong place to discuss linguistics at this depth.  We have a different channel, #haskell-blah, for off-topic stuff
11:02:34 <jedai> augur: I listened to recordings of coq in french dictionaries (the Larousse for instance) they pronunce it like me and like cock (though with a shorter o like already said)
11:02:34 <lispy> number9: Well, it should preserve some lines starting with #, but not the ones outside of code sections
11:02:36 <augur> copumpkin: its not arrogance, it's just awareness that untrained people have piss-poor ability to judge their own phonology
11:02:45 <number9> lispy: also are you saying/thinking that this wouldn't be an issue if I were to switch to using hugs?
11:02:49 <augur> jedai: link
11:02:55 <augur> also >> -blah
11:03:06 <lispy> number9: No one uses hugs for real work, so it's hard to say :)
11:04:08 <lispy> number9: I'm actually wondering if someone should write a more modern unlit
11:04:26 <number9> lispy: what is so outdated about it?
11:04:42 <ddarius> lispy: As a sed script?
11:04:52 <lispy> number9: first line of the file: /* unlit.c                                   Wed Dec  5 17:16:24 GMT 1990
11:05:11 <Botje> hey, if it works .. :P
11:05:24 <number9> lispy: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal-1.10.0.0/Distribution-Simple-PreProcess-Unlit.html
11:05:25 <lispy> Botje: but we found a bug :)
11:05:34 <hpc> trust not a file comment over stat-ing the file
11:05:35 <Botje> ah :P
11:05:41 <number9> lispy: according to this it should remove the #?
11:06:17 <lispy> number9: That's an unrelated function by the same name
11:06:53 <number9> lispy: ah sorry my bad.
11:06:53 <lispy> number9: I know which unlit ghc is calling by doing, 'ghc -v Foo.lhs'
11:07:13 <lispy> number9: Well, it's actually kind of interesting.  I wonder why cabal has its own unlit
11:07:58 <ddarius> lispy: Because Cabal isn't GHC only.
11:08:51 <number9> lispy: is there a way to set ghc to use cabal's unlit? Would that even make sense?
11:09:33 <duckinator> function declarations in haskell are not ordered, right? ie, you can reorder them however you like and they will work the same?
11:09:34 <lispy> number9: it might make sense, but I don't know how to do it.  I'm also not sure (without testing it) that the cabal version does the right thing.
11:09:52 <lispy> number9: but what would work....is to use a preprocess on the .lhs file to extract the haskell
11:10:02 <lispy> duckinator: yeah
11:10:08 <duckinator> awesome
11:10:15 <lispy> duckinator: the lines with a function definition are ordered though
11:10:16 <number9> lispy: here is the source (I think): http://hackage.haskell.org/packages/archive/Cabal/1.10.0.0/doc/html/src/Distribution-Simple-PreProcess-Unlit.html and it looks to me like it does the right thing but I am unsure
11:10:30 <duckinator> lispy: yea, i'd hope so ;)
11:10:48 <number9> lispy: is there a way to have a preprocesser run automatically when I try to load something in ghci or compile with ghc?
11:11:19 <lispy> number9: if there was it would involved using {-# OPTIONS_GHC ... #-}, most likely
11:11:36 <number9> lispy: in the file?
11:11:42 <lispy> number9: yeah, as the first line
11:12:25 <lispy> number9: due to CPP, cabal/ghc/unlit whatever will always find it a bit awkward to process files that have # in them
11:12:55 <lispy> number9: if you can disambiguate markdown's # from CPP's #, then you could build an unlit (or fix GHC's) and that would actually be nice to have
11:14:08 <lispy> number9: i'm going to use your example to file a bug report
11:14:20 <number9> lispy: well I am doing most of this to learn haskell right now, so writing an unlit migt be out of the question for a bit. 
11:14:50 <lispy> number9: well, you could imagine writing it in any language.  GHC just looks for it in a specific location
11:14:57 <number9> lispy: and yes file away! Thanks again, you have been a huge help and a great time saver
11:14:59 <lispy> newsham: sed/awk would be valid
11:15:04 <lispy> :)
11:15:15 <lispy> newsham: sorry!  Meant that for number9 
11:16:00 <number9> lispy: yes not experienced much there either. Trying to focus on haskell for the time being as well. But I will look into it
11:20:34 <copumpkin> what was the language extension for deferring type synonym expansion?
11:22:01 <aavogt> copumpkin: -XLiberalTypeSynonyms ?
11:22:39 <number9> lispy: if you file the bug will you post the link?
11:23:30 <lispy> number9: http://hackage.haskell.org/trac/ghc/ticket/4836
11:24:43 <copumpkin> aavogt: ah yes, thanks
11:24:48 <number9> lispy: thanks
11:25:29 <lispy> number9: np
11:25:44 <lispy> number9: I sort of feel dirty not just sending a patch that fixes it :)
11:27:44 <Botje> 5~
11:28:18 <Saizan> ghc uses C to unlit?:O
11:28:30 <number9> lispy: where did you find the source for the unlit.c? If I were to try changing the .c program how would I tell ghc to use the modified version?
11:29:26 <number9> lispy: it seems like it shouldn't be a terribly hard thing to fix and it also seems like you already did the hardest part
11:29:53 <lispy> number9: unlit is in the GHC repository: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources?redirectedfrom=GhcDarcs in the directory utils/unlit.  To find out where to place it, run 'ghc -v Foo.hs' and grep for unlit
11:30:27 <number9> lispy: thanks 
11:31:34 <duckinator> right now, for my irc bot i have `handle [n, u, h] "PRIVMSG" [c, '!':xs)] = privmsg c xs` for an echo command (you say !foo, the bot says foo).. How can I do that and match a pair of [[ and ]] with anything (including absolutely nothing) between them?
11:32:28 <ddarius> If you actually had that code, you'd have a syntax error.
11:32:57 <duckinator> ddarius: that's what i get for retyping instead of copy/pasting :( pretend there's a ( where it should be
11:34:15 <ddarius> If Haskell was Curry you could just write a ("[[" ++ xs ++ "]]") pattern, but Haskell isn't Curry.
11:34:36 <duckinator> so i noticed when runhaskell screamed at me ;)
11:36:53 <ddarius> copumpkin: I bought some really awesome yarn yesterday.  Want a hat?  It will definitely be the nicest feeling hat you have ever owned.
11:37:10 <copumpkin> ddarius: yes! I would love one
11:37:16 <copumpkin> my head has been getting very cold recently
11:37:33 <copumpkin> ddarius: have you come across etsy by the way? 
11:37:49 <duckinator> ddarius: what would the best method be? `foohandle [n, u, h] "PRIVMSG" [c, s] | "[[" `isPrefixOf` s && "]]" `isSuffixOf` s = ...` (ow)
11:38:00 <duckinator> ddarius: ...i'm not sure where the "foo" came from, ignore that
11:38:31 <duckinator> was hoping there was a less-wordy version of that, but since such a thing only occurs once it's not too bad if there's not
11:38:44 <ddarius> copumpkin: "etsy"?
11:39:25 <copumpkin> http://www.etsy.com/ for selling homemade things, if you're interested in making some money off your hobby
11:39:39 <ddarius> duckinator: Will you could still pattern match the leading "[[", but yes, you'll need to write some guard like that.
11:40:13 <number9> on a separate note, is there any way of getting ghc to treat a file with a .lhs.page extention as a .lhs extension?
11:41:18 <duckinator> ddarius: that seems valid, but...doesn't work :S
11:41:28 <Twey> duckinator: Maybe view patterns
11:42:13 <duckinator> > let foo ("[[":xs) = "works" in foo "[[test" :: String
11:42:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:42:13 <lambdabot>         against inferred ty...
11:42:33 <duckinator> wtf...where'd i fail in that? :|
11:42:46 <Twey> duckinator: ends start end xs = (take start xs, drop (length xs - end) xs)
11:43:21 <Twey> handle [n, u, h] "PRIVMSG" [c, s@(ends 2 2 -> ("[[", "]]"))] = …
11:44:17 <duckinator> Twey: ah, that looks much nicer :) thank you
11:44:57 <ddarius> Returning a triple would be better.
11:45:23 <duckinator> hm?
11:45:39 <ddarius> duckinator: ("[[":xs) isn't a legal pattern.  You'd have to write ('[':'[':xs)
11:46:05 <ddarius> Note that "[[" means '[':'[':[] (i.e. note the [])
11:46:14 <duckinator> ddarius: you mean returning ("[[", "]]", s) where s is the string i want? and i should've known that (re the "[[":xs not being a legal pattern)
11:46:39 <ddarius> Actually ("[[":xs) is legal, it just means a list of strings that starts with the string "[[".
11:47:02 <duckinator> mmm, right
11:47:08 <ddarius> Well, I would return ("[[", s, "]]"), but yeah.
11:47:24 <duckinator> er, yea, that does make more sense than what i said :)
11:47:27 <ion> > let f ("[["++a) = a in f "[[foo"
11:47:28 <lambdabot>   <no location info>: Parse error in pattern
11:47:41 <ion> I think that kind of a pattern works in Erlang. :-)
11:48:07 <ion> being syntactic sugar for the equivalent of '[':'[':a
11:48:21 <ion> in the context of pattern matching
11:49:06 <ddarius> I'd also probably write something more like bracketed "[[" "]]" xs which produces Just s or Nothing.
11:49:26 <Twey> Yeah, probably
11:49:33 <Twey> Can we make a view pattern fail?
11:49:50 <ddarius> Twey: Only by failing to pattern match on the result.
11:50:15 <Twey> > let v x = error "failure"; f (v -> x) = x; f n = n + 1 in f 5
11:50:16 <lambdabot>   *Exception: failure
11:50:19 <Twey> Aw, damn
11:50:36 <aavogt> you can match on an explicit Maybe for the x
11:50:41 <Twey> Yeah
11:50:42 <Twey> I guess
11:56:27 <hpc> :t let v x = error "failure"; f (v -> x) = x; f n = n + 1 in f
11:56:28 <lambdabot>     Illegal view pattern:  (v -> x)
11:56:28 <lambdabot>     Use -XViewPatterns to enable view patterns
11:56:42 <Twey>  > can do view patterns, but :t can't
11:56:57 <Twey> But it's Num a => a -> a
12:02:35 <number9> lispy: did you read the README near unlit.c?
12:02:47 <lispy> number9: I'm guilty of not readingit.
12:03:24 <mathijs> I read some stuff today about OS threads, haskell threads, the IO manager and the new epoll-based scheduler. Sounds really cool. Essentially the runtime provides a very efficient reactor. I do have some questions though.... 
12:03:24 <lispy> number9: oh, wait, I did.  But, I don't know what stuff they are referring to to go look at
12:03:29 <number9> lispy: is it ok if I post it here? It isn't very long and just makes some cryptic references that I think you might no
12:03:46 <number9> *know
12:03:53 <lispy> number9: it's true that I know some of the references.  like, HBC
12:03:59 <number9> lispy: so it looks like we saw the same thing
12:04:01 <lispy> number9: and I know who Mark Jones is
12:04:23 <lispy> but the important bit: "For more "powerful" swizzling of literate scripts, please see the
12:04:24 <lispy> "literate" stuff from Glasgow."  means nothing to me :(
12:04:27 <number9> lispy: I guess I just want to know what they are talking about here: For more "powerful" swizzling of literate scripts, please see the
12:04:30 <number9> "literate" stuff from Glasgow.
12:04:54 <number9> lispy: yep ok I'll do some digging and see if I find anything
12:04:54 <mathijs> is it possible that 1 haskell thread gets executed on a specific OS thread, then stops executing (waiting for IO), and when IO arrives, execution resumes on another OS thread?
12:05:15 <ezyang> Yes. 
12:05:31 * lispy was about to suggest mathijs look at ezyang's blog and then guess who appeared :)
12:05:36 <ezyang> forkIO gives no guarantees about what OS thread a Haskell thread is run on. 
12:05:38 <ezyang> Haha. 
12:05:54 <ezyang> You want forkOS. 
12:06:12 <augur> ezyang!
12:06:15 <augur> pictures! :D
12:06:17 <augur> <3
12:06:25 <ezyang> \o/ 
12:06:48 <augur> i liked them. <3
12:06:57 <mathijs> ezyang: no I don't want that :)  I think.  if I create 10000 threads, each doing not much, just waiting for some IO to arrive... I think forkOS will be expensive/slow right?
12:07:10 <copumpkin> mathijs: no
12:07:22 <copumpkin> forkOS still doesn't make OS threads
12:07:23 <ezyang> mathijs: forkOS doesn't actually make a new thread. 
12:07:34 <mathijs> ah
12:07:41 <ezyang> augur: That's good to hear. I think people like pictures. 
12:07:44 <monochrom> forkOS still doesn't say "new OS thread for new haskell thread". just promises not moving around.
12:07:47 <ddarius> mathijs: The only difference between forkIO and forkOS is that forkOS threads won't migrate.
12:08:03 <augur> ezyang: i think fairly visually, so it's always wonderful when people give pictures like that
12:08:03 <copumpkin> mathijs: it's still a green thread, but it guarantees that FFI calls from that thread always occur from the same OS thread
12:08:15 <ddarius> That said, usually you want the RTS to be able to move threads if it thinks it's beneficial, so it is better to use forkIO when you can.
12:09:12 <mathijs> ddarius, copumpkin, ezyang: ah, I didn't get that part :)   ok, so there is no memory overhead or more expensive context switching associated with forkOS?
12:09:14 <ddarius> You should only really need forkOS if you are dealing with a library that uses thread local state.
12:09:42 <mathijs> ddarius: the library I'm using has some objects that can only be touched from the thread that created them
12:09:59 <ezyang> mathijs: Definitely you want forkOS then. 
12:10:18 <ezyang> I forget how GHC decides to bundle different bound threads together. 
12:10:31 <ddarius> mathijs: forkOS can lead to more actual OS level thread context switches, but it doesn't cause them.
12:10:50 <ddarius> (It also, theoretically could lead to less if GHC's migration strategy hit a pathological case.)
12:10:59 <mathijs> ok. but their beta-release _does_ have an option for "migrating" the object. I have to make sure to put "full memory barriers" in place. dunno what that means though :(
12:11:27 <ddarius> Using forkOS for this case is probably the easiest and most efficient thing to do.
12:11:55 <number9> lispy: perhaps they are refering to http://www.desy.de/user/projects/LitProg/glasgow/top.html
12:12:27 <lispy> number9: I bet you're right
12:12:35 <lispy> looks suspicious
12:12:57 <number9> lispy: esp. http://www.desy.de/user/projects/LitProg/glasgow/programs-and-options.html
12:13:07 <mathijs> ddarius: think so too ;)   the "memory barriers" stuff doesn't sound easy
12:16:47 * ddarius plugs in his amp for the first time since moving to MA
12:18:01 <mathijs> ah... read some more stuff. does anyone know if GHC's IO manager "ensures full memory barriers" by default when scheduling?
12:19:08 <ezyang> Yes... 
12:21:51 <huski> oh my
12:21:54 <huski> lots of bots
12:21:58 <jmcarthur> lol
12:22:08 <huski> or not
12:22:12 <copumpkin> huski: ?
12:22:18 <huski> at least are they written in haskell ?
12:22:22 <monochrom> there are not bots
12:22:28 <jmcarthur> no, it's just a popular channel
12:22:33 <ketil> What's the deal with build-depends in cabal?  Apparently I have to put it in a section, but it applies globally still?
12:22:35 <jmcarthur> well there are a couple bots at least
12:22:42 <huski> are there haskell girls around or what ?
12:22:42 <monochrom> they are all humans
12:22:42 <ddarius> huski: You might also want to check to make sure you aren't also a bot.
12:22:47 <ketil> I'm not a bot, I'm a free man!
12:23:08 <Saizan> ketil: it shouldn't apply globally
12:23:10 <jmcarthur> obvious troll is obvious
12:23:11 <huski> ddarius from Romania ? 
12:23:47 <medfly> haskell girls :)
12:23:48 <oconnore> hi, can someone help me with this? http://hpaste.org/42278/maybe_monad_help
12:23:48 <copumpkin> I'm not a bot, I'm a free variable!
12:23:58 <ketil> Saizan: hm.  I converted a .cabal to use sections, and it complained about not having build-depends.  But moving it into the first executable section fixed it - for all the executables.
12:24:04 <huski> immutable one
12:24:06 <ketil> Maybe too old cabal?
12:24:22 * hackagebot zeromq-haskell 0.4.2 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.4.2 (ToralfWittner)
12:24:23 <monochrom> ketil: you have to put it in a section, and it applies to that section. but if it's a library section, then it's the unique library section too, so I guess you could call it global insofar as the singleton pattern is global
12:24:37 <ketil> monochrom, ?
12:24:47 <monochrom> ?
12:24:50 <copumpkin> ?
12:24:51 <jmcarthur> huski: the best #haskell trolls are the ones that put forth some effort to learn haskell because then we have no idea whether to kick them
12:25:13 <Saizan> ketil: iirc a bug in old cabal where the build-depends of library and exes were just merged and used for everything, or something like that
12:25:20 <ketil> monochrom, I have multiple executable sections, and only build deps in one.  Seems to work.
12:25:25 <Saizan> ketil: so yeah, a newer cabal should make more sense
12:25:28 <huski> well, I gave haskell a try today
12:25:35 <unkanon> oconnore: what's that supposed to do?
12:25:41 <huski> I still can't find something useful to use it on
12:25:41 <monochrom> interesting. version?
12:25:42 <copumpkin> learn you a haskell for great troll
12:25:50 <ketil> Saizan, sounds reasonable.  Now, I think my cabal just came with the system - is it safe to cabal upgrade it?
12:25:51 <oconnore> unkanon: return the max of a list
12:25:59 <monochrom> @remember copumpkin learn you a haskell for great troll
12:26:00 <lambdabot> It is stored.
12:26:13 <Saizan> ketil: never use "cabal upgrade"
12:26:21 <ketil> cabal insstall cabal?
12:26:29 <unkanon> oconnore: right, what's the helper supposed to do?
12:26:31 <jmcarthur> huski: umm... whatever you would code in another language might be a good candidate to try in haskell :)
12:26:39 <monochrom> "cabal install cabal-install" will do
12:26:39 <copumpkin> parse "cabal upgrade" = error "Never use \"cabal upgrade\""
12:26:44 <ketil> Right - I'm a bit wary of messing with something that - at least appears to - work.
12:26:47 <Saizan> ketil: what monochrom said
12:26:48 <huski> mysql stuff ?
12:26:56 <huski> i'm doing a lot of those
12:27:01 <oconnore> unkanon: the helper takes two values, the list and the maximum. on the first element, the maximum may be nothing.
12:27:15 <huski> don't know if it's worth to use an aircraft carrier to cross a river
12:27:21 <jmcarthur> sure, there are several database bindings
12:27:24 <ketil> monochrom, Saizan : just what cabal update tells me. :-)
12:27:28 <oconnore> unkanon: and then the helper maximizes the first element and the current maximum (if it isn't nothing), and recurses down.
12:27:35 <jmcarthur> haskell is an aircraft carrier? that's awesome
12:27:43 <copumpkin> huski: I (and many other people) use haskell for just about everything. Expecting to be able to use it effectively after just one day is a little arrogant
12:27:44 <monochrom> But my real recommendation is (get current haskell platform) or (get current ghc then bootstrap cabal-install)
12:27:47 <oconnore> the maxList call just wraps the helper so you don't have to supply a Nothing
12:28:02 <oconnore> I figured that would be a good exercize with the maybe monad
12:28:09 <oconnore> but i'm getting type errors
12:28:30 <Saizan> ketil: it'll install the new cabal in ~/.cabal/bin, so make sure that's on your PATH, and in front of wherever else you have your current cabal
12:28:38 <elliott> So what's the recommended library to create and process PNG files simply?
12:28:48 <jmcarthur> calling haskell an aircraft carrier certainly sounds better than calling it a toy like most trolls do :)
12:29:02 <monochrom> oh yeah, that's a new one :)
12:29:12 <ketil> monochrom, right - but. I'd like to have a bit of backwards compatibility.  I think my code ought to work with what gets shipped with current systems - today I ran into a problem with one person using ghc 6.10
12:29:14 <monochrom> apparently you can't please all trolls
12:29:21 <huski> stop calling me a troll :) have some respect
12:29:43 <jmcarthur> huski: heh, you just didn't have the best first impression when you came in. i'll stop
12:29:49 <huski> I am still experimenting the sort function 
12:29:50 <medfly> greater troll
12:29:58 <ketil> trollop?
12:30:02 <monochrom> I don't call anyone troll. Except myself.
12:30:10 <unkanon> oconnore: I'm looking at it
12:30:20 <huski> well I must admit I was wrong
12:30:34 <huski> I still cannot believe that there are so many people inhere
12:30:37 <oconnore> unkanon: thank you
12:30:41 <jmcarthur> well then i apologize for calling you a troll
12:31:00 <huski> but it seems that people gather to see the aircraft carrier
12:31:06 <huski> it's like on intrepid
12:31:32 <jmcarthur> huski: the main reason isn't due to haskell being popular of course. this channel just tend to be generally awesome and helpful
12:31:35 <jmcarthur> *tends
12:31:56 <huski> I noticed that already, that's nice I guess I'll stick around
12:32:02 <jmcarthur> awesome
12:32:24 <dnme> hmm what server is this ? somebody already registered this nickname
12:32:26 * ddarius doesn't call anyone a troll.  Except monochrom.
12:32:29 <jmcarthur> freenode
12:32:33 <dnme> hmm
12:32:34 <alpounet> dnme, irc.freenode.net
12:32:40 <dnme> hmm
12:32:51 <dnme> thank you alpiunet
12:32:57 <dnme> alpounet
12:33:26 <alpounet> i stole a part of my answer to jmcarthur 
12:33:27 <alpounet> :]
12:34:16 <monochrom> ketil: if ghc 6.10.4, at least go for haskell platform 2009.2.0.2 or a subset of it, which has not-too-old cabal
12:34:20 <jmcarthur> alpounet: oh hey. now we can stop playing irc tag
12:34:51 <alpounet> heh
12:35:05 <troll> oh c'mon this one is taken too
12:35:13 <ketil> monochrom, I generally stay with the latest Ubuntu, which is 6.12.  7.0.1 in the next release, I guess.
12:35:27 <jmcarthur> freenode is pretty large
12:35:30 <ketil> but maybe I should make the effort to upgrade manually.
12:35:34 <monochrom> generally use haskell platform for reference versions
12:35:41 <haskoll> ketil don't do it
12:35:52 <alpounet> jmcarthur, still haven't published your graphics dev code ?
12:35:58 <ketil> It's just a lot easier to tell users to apt-get/yum install ghc, then cabal install <program>
12:36:08 <haskoll> i've done that on openbsd just to get a newer version of xmonad and I wrecked it
12:36:10 <ketil> haskoll, no?
12:36:12 <jmcarthur> alpounet: all i've published is OpenGLRaw21
12:36:14 <unkanon> oconnore: hmm, maybe you want to think of a simpler way of doing the same thing?  :)
12:36:24 <unkanon> oconnore: I'm having trouble understanding what the second guard is supposed to do
12:36:31 <ketil> The QC added by distributions is generally a good thing.
12:36:42 <oconnore> unkanon: that would defeat the whole point of learning how to use a maybe monad :)
12:36:46 <jmcarthur> alpounet: the wrapper is still under way. i keep starting over or getting distracted by other things :)
12:37:11 <ketil> Damn it.  Even a new cabal happily built all the executables!
12:37:16 <monochrom> ketil: I have two horror stories for Ubuntu and one for Fedora: http://www.vex.net/~trebla/haskell/sicp.xhtml#ghc6121
12:37:19 <oconnore> unkanon: the second guard just says, if we haven't found an element yet, set the max to the first element
12:37:32 <alpounet> ok
12:37:39 <unkanon> oconnore: okay then tell me how you want the function to behave, so that I can understand it better. you want a function that returns Just the max of a list if it exists or Nothing if what?
12:37:56 <alpounet> what about the ideas you wanted to investigate ?
12:38:02 <ketil> monochrom, Oh, it's you!
12:38:17 <jmcarthur> alpounet: i'm currently back on my quest to make a lazier language than mere call-by-need :)
12:38:32 <jmcarthur> just a temporary side quest. i'll be getting back to the graphics stuff soon
12:38:43 <jmcarthur> alpounet: which ideas?
12:38:57 <elliott> jmcarthur: call-by-absolute-desperate-requirement
12:38:58 <ketil> monochrom, is this unfixable?  I think it should be possible to have system/global/user installs all work together, but maybe not?
12:39:09 <alpounet> haha elliott 
12:39:18 <monochrom> Fixable if you don't interleave.
12:39:38 <oconnore> unkanon: I want to call the function as maxListHelp([4,2,5,3],Nothing). the first recursive step pops 4 off the front, and calls maxListHelp([2,5,3],4). The second step calls maxListHelp([5,3],4), then mlh([3],5), then mlh([],5) => Just 5
12:39:39 <jmcarthur> elliott: heh. more seriously it's looking like it's just head spine reduction with sharing
12:39:40 <monochrom> But 6.12.1 simply can't be helped. Bug. End of story.
12:39:45 <alpounet> jmcarthur, the ideas regarding your graphics stuff
12:39:52 <oconnore> unkanon: maxListHelp([],Nothing) => Nothing
12:39:57 <elliott> call-by-begging-plea
12:40:00 <jmcarthur> for some reason completley lazy evaluation isn't doing as well as head spine reduction
12:40:01 <haskoll> oh I have a question for mac users
12:40:08 <jmcarthur> in my experiments
12:40:17 <alpounet> jmcarthur, what's the motivation for the "lazier than call-by-need" quest ?
12:40:17 <monochrom> You may prefer just telling people to apt-get/yum. Well I prefer just telling people to use brain. I have my preference too.
12:40:17 <haskoll> do you happen to know where the Haskell.tmbundle is ?
12:40:18 <alpounet> oh
12:40:21 <haskoll> for textmate
12:40:22 <jmcarthur> i haven't nailed down why
12:40:36 <unkanon> oconnore: would you say that's the type you want for the helper?
12:40:37 <unkanon> oconnore: maxListHelp :: ([Int], Maybe Int) -> ([Int], Maybe Int)
12:40:50 <jmcarthur> alpounet: because i want runtime specialization, basically
12:41:05 <jmcarthur> alpounet: which turns out to be increased sharing in disguise
12:41:16 <unkanon> oconnore: oh I got it, ok let me go back to the code then
12:41:19 <oconnore> unkanon: sure, although I though the type I supplied would be equivalent.
12:41:25 <oconnore> *thought
12:41:35 <Saizan> head spine reduction is not the same as call-by-need either?
12:41:42 <oconnore> thanks again
12:41:55 <applicative> oconnore, is this the same as you intended?  http://hpaste.org/paste/42278/maybe_monad_help_annotation#p42279
12:41:55 <jmcarthur> alpounet: (sharing work which is normally performed more than one time across multiple uses of a function)
12:41:58 <alpounet> jmcarthur, so basically this relates to your graphics stuff, right ?
12:42:08 <jmcarthur> alpounet: heh, not really, but it does relate to FRP
12:42:32 <unkanon> oconnore: oh I hadn't seen your type signature lol
12:42:37 <alpounet> i've been wondering for a while how much laziness could help for 3D stuffs
12:42:58 <jmcarthur> Saizan: i'm using terminology from Peter Sestoft's paper Demonstrating Lambda Calculus Reduction
12:44:03 <jmcarthur> Saizan: he doesn't really say much about call-by-need actually (or sharing in general), but unless i'm using too tight a definition for call-by-need (call-by-name with sharing?), head spine reduction with sharing is different
12:44:09 <alpounet> jmcarthur, would you have some time to explain the link with FRP ?
12:44:14 <oconnore> applicative: I get an error when I run your code. " Program error: pattern match failure: maxList [4,6,2,7,8]"
12:44:26 <Saizan> jmcarthur: i see
12:44:34 <jmcarthur> alpounet: sure (and for the record i can think of at least one graphics-related application too)
12:44:58 <oconnore> applicative: but yes, that looks like what I wanted. can you explain the changes you made?
12:45:01 <jmcarthur> alpounet: actually, i'll just link you to a blog article that luqui wrote
12:45:52 <jmcarthur> alpounet: http://lukepalmer.wordpress.com/2009/07/07/emphasizing-specialization/
12:46:13 <jmcarthur> alpounet: he explains the basic idea and then relates it to FRP at the end
12:46:42 <unkanon> oconnore: one of the problems is you're naming your variables the same as functions
12:46:51 <unkanon> oconnore: you can't make Just max head max work
12:47:26 <oconnore> unkanon: oh, oops. i'm used to common lisp. we have 2 namespaces :)
12:47:28 <applicative> oconnore, I can't find the mistake, it's giving me maxList [4,6,2,7,8] = 8
12:47:45 <jmcarthur> alpounet: but here's the most interesting (to me) kicker: if you write an interpreter in a language with this evaluation order and then interpret a program with it, there's a constant time overhead to "compile" the program into a more "native" representation, and then it executes the program without the interpretive overhead!
12:48:04 <applicative> right, you were using max as a prelude function and a local letter
12:48:05 <jmcarthur> alpounet: that generalizes to all the various kinds of abstractions you might normally use in a complex program
12:48:10 <monochrom> ketil: Sorry, you're right, the strange phenomenon you observed is true.
12:48:27 <jmcarthur> alpounet: basically, there is no real performance penalty for using many layers of abstractions
12:48:36 <alpounet> wow
12:48:39 <oconnore> applicative: so if I call maxListHelp([4,6,2,8,1],Nothing) => ([], Just 8). but my wrapper function isn't working correctly
12:48:50 <alpounet> so stepanov was right
12:48:51 <alpounet> :-P
12:49:23 * jmcarthur looks up stepanov to see what alpounet is talking about
12:49:31 <alpounet> alexander stepanov
12:49:35 <alpounet> the abstraction penalty benchmark
12:49:36 <alpounet> for C++
12:49:50 <alpounet> (the main author of the STL)
12:50:12 <ketil> monochrom, Found it!  Cabal looks at the cabal-version field, and you need to require >=1.8 to get the right (non-global) behaviour for build-deps
12:50:25 <applicative> oconnore indeed, theres a typo 
12:50:45 <fysx> is there some built in function that makes this point free :  (\x -> isDigit x || isSpace x)  ?
12:50:46 <applicative> oconnore i wrote maxList but also maxlist  you were calling one, I was calling the other.
12:50:59 <monochrom> there is probably no "lazier than call-by-need" but there is "more non-strict than call-by-need". lub is more non-strict than call-by-need. ironically, lub is probably better implemented by crazy evaluation
12:51:00 <oconnore> ok
12:51:02 <jmcarthur> alpounet: i see
12:51:07 <danr> fysx: liftM2 (||) isDigit isSpace
12:51:09 <applicative> oconnore, if they are all maxList, does it work 
12:51:31 <hpc> :t liftM2 (||)
12:51:31 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
12:51:36 <oconnore> aha!
12:51:39 <monochrom> ketil: Haha nice thanks.
12:51:43 <jmcarthur> monochrom: would you classify fully lazy and completeley lazy as call-by-need?
12:52:07 <fysx> danr: itneresting
12:52:13 <monochrom> yes
12:52:16 <jmcarthur> fully lazy can be a compiler transformation and a call-by-need runtime, so maybe it's a bad example for "more" lazy
12:52:26 <ketil> monochrom, tested now, works as advertised.
12:52:28 <oconnore> thank you applicative and unkanon! I'll go back under my rock until I have more interesting questions...
12:52:31 <danr> fysx: applicative style: (||) <$> isDigit <*> isSpace
12:52:38 <jmcarthur> but completely lazy evaluation requires a unique evaluation strategy compared to most call-by-need runtimes
12:52:38 <unkanon> oconnore: http://hpaste.org/paste/42278/maybe_monad_help_annotation#p42280
12:52:44 <alpounet> jmcarthur, ok i'm reading luke's post i'll get back to you right after
12:52:56 <unkanon> oconnore: that one should be easy to follow re the changes I made
12:53:10 <unkanon> sorry I took so long :)
12:53:14 <danr> fysx: using the ((->) e) applicative and monad, respectively
12:53:34 <jmcarthur> monochrom: head spine reduction isn't really any more non-strict than call-by-need though, as far as i can tell. it just shares more work
12:53:36 <Saizan> jmcarthur: i think the most prominent connotation of lazy is the one that distinguishes it from call-by-value, rather than call-by-name
12:53:57 <jmcarthur> Saizan: if you mean sharing, then i agree
12:54:06 <Saizan> no
12:54:12 <jmcarthur> oh sorry
12:54:13 <jmcarthur> i misread
12:54:38 <fysx> danr: I got the applicative style working... the monadic liftM2 complains that it's not a monad
12:54:57 <danr> fysx: import Control.Monad.Instances
12:55:03 <jmcarthur> Saizan: so you mean you connotate lazy with non-strictness more than with sharing?
12:55:15 <jmcarthur> err... *associate
12:55:18 <Saizan> jmcarthur: exactly
12:55:22 <fysx> danr: whoah
12:55:36 <oconnore> unkanon: thanks. i know what I was doing wrong now.
12:55:43 <unkanon> oconnore: cool
12:56:09 <jmcarthur> Saizan: i've always felt that non-strictness was necessary but insufficient for laziness
12:56:20 <ddarius> jmcarthur: Correct.
12:56:44 <fysx> danr: so more generally, suppose i had a list of functions, i want to evaluate x for each function, and then fold over the result... say (\x -> any [f1 x, f2 x, f3 x, f4 x]) ... how can i make that pointfree ?
12:57:23 <unkanon> @pl (\x -> any [f1 x, f2 x, f3 x, f4 x]) 
12:57:23 <lambdabot> any . liftM2 (:) f1 (liftM2 (:) f2 (liftM2 (:) f3 (return . f4)))
12:57:34 <fysx> ick
12:57:34 <Saizan> jmcarthur: i agree, but then i've had to qualify i wanted the sharing of call-by-need in more than one occasion when i said "lazy"
12:57:45 <monochrom> jmcarthur: consider this consideration of conal. «if boo then "hi" else "hi you"». The most non-strict answer gives you 'h':'i':? right away. Only when you ask for resolving the ? part do you care about boo. One way to implement this is to use "parallel or" or equivalently fork off threads to evaluate all three of boo, "hi", "hi you" right away. I call it crazy evaluation.
12:58:28 <jmcarthur> monochrom: right, but that is not the same kind of thing that i'm talking about
12:58:57 <jmcarthur> monochrom: i'm trying to share more work, not avoid evaluation of more values
12:59:08 <monochrom> I see
13:00:27 <opqdonut> fysx: 
13:00:35 <danr> @pl \x -> any ($x) [f,g,h]
13:00:35 <lambdabot> flip any [f, g, h] . flip id
13:00:44 <jmcarthur> monochrom: here's an example from Sinot that i've been using to explain it to people most often:  let f x y = sqrt y + x; g x = f x 4 in g 1 + g 2  -- i'm trying to share the reduction of (sqrt 4), without cheating by using inlining or something of course
13:00:46 <unkanon> applicative: btw, re oconnore's code, using a helper function that takes a tuple and another function that recurses the help, is that good practice?
13:00:48 <opqdonut> > ($3) [(+1),(*2),(const 5)]
13:00:49 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
13:00:56 <danr> flip id? what?
13:00:58 <opqdonut> > ($3) <$> [(+1),(*2),(const 5)]
13:00:59 <opqdonut> eh
13:00:59 <lambdabot>   [4,6,5]
13:01:00 <unkanon> applicative: 'cause that's exactly the same way I code right now (I'm a newbie)
13:01:03 <opqdonut> fysx: ^ there
13:01:08 <jmcarthur> monochrom: and the full laziness optimization is not sufficient. it requires more sharing in the runtime
13:01:09 <opqdonut> the list functor
13:02:00 <fysx> opqdonut: close... ($3) would be ($x) ..
13:02:15 <fysx> danr: yeah.. flip id .. weird
13:02:23 <danr> @type flip any [isSpace, isDigit, isUpper] . flip id
13:02:24 <lambdabot> Char -> Bool
13:02:37 <danr> @type flip id
13:02:38 <lambdabot> forall a b. a -> (a -> b) -> b
13:02:46 <danr> @type flip ($)
13:02:47 <lambdabot> forall a b. a -> (a -> b) -> b
13:02:53 <danr> ah, that's what flip id is :)
13:03:01 <jmcarthur> monochrom: head spine reduction with sharing turns out to be sufficient. completely lazy evaluation is also sufficient. i haven't decided if completely lazy evaluation and head spine reduction with sharing are equivalent. so far they have always shared the same work in my experiments, though
13:03:04 <Saizan> ?type any . sequence  [isSpace, isDigit, isUpper]
13:03:05 <lambdabot>     Couldn't match expected type `a -> Bool'
13:03:05 <lambdabot>            against inferred type `[Bool]'
13:03:05 <lambdabot>     Probable cause: `sequence' is applied to too many arguments
13:03:27 <Saizan> ?type or . sequence  [isSpace, isDigit, isUpper]
13:03:28 <lambdabot> Char -> Bool
13:03:35 * hackagebot blaze-builder 0.2.1.1 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.2.1.1 (SimonMeier)
13:03:44 <danr> Saizan: clever :)
13:03:52 <oconnore> unkanon: how would you have done it simpler? in common lisp I would just map a closure over the list, but haskell doesn't have mutable anything as far as i can tell.
13:04:47 <oconnore> unkanon: so as far as i understand, the only way to do it is to maintain state as you recurse down... thus the whole monad abstraction...
13:05:04 <unkanon> oconnore: I don't know, I'm coding some neural network algorithms and I'm using exactly the same type of coding you use, which is a helper function that takes a tuple and a main functions that recurses the helper
13:05:39 <unkanon> I'm craving some mutability at this point
13:05:54 <oconnore> :)
13:06:39 <fysx> saizan: cool
13:06:44 <unkanon> the thing is my algorithm is a bit complicated. I started with a 2-tuple but now I'm using a 3-tuple
13:06:49 <unkanon> and I don't want it to get any bigger
13:06:55 <unkanon> it's hard to follow what's going on
13:07:11 <unkanon> when I have the whole thing working I'll ask for help on making it look prettier
13:07:17 <sipa> :t sequence
13:07:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:07:26 <ddarius> unkanon: That seems like a suboptimal strategy.
13:07:35 <opqdonut> unkanon: one approach is to use an ADT instead of a tuple
13:07:45 <opqdonut> I sometimes do that for complicated loopy algorithms
13:07:51 <hpc> :t sequence `asTypeOf` flip
13:07:52 <lambdabot> forall a a1. [a1 -> a] -> a1 -> [a]
13:07:57 <opqdonut> but often there is a more high level solution that's nicer
13:08:14 <unkanon> ddarius: how do you mean? it's suboptimal to have it working first before asking for help to make it look prettier?
13:08:25 <hpc> :t flip `asTypeOf` sequence
13:08:26 <lambdabot> forall a b. [a -> b] -> a -> [b]
13:08:33 <oconnore> unkanon: I think he meant using tuples was sub optimal
13:08:34 <unkanon> opqdonut: I started out with an ADT but I found it more complicated than just a [[[a]]] type :)
13:08:53 <ddarius> oconnore: No, unkanon was right.
13:08:58 <oconnore> oh
13:09:00 <fysx> saizan: ahh.   sequence [isSpace, isDigit, isUpper] .. that's pretty slick!  that's what i was looking for!
13:09:26 <jmcarthur> :t sequence [isSpace, isDigit, isUpper]
13:09:27 <lambdabot> Char -> [Bool]
13:09:38 <jmcarthur> gotta love the (a ->) monad
13:09:52 <unkanon> opqdonut: I had it all pretty, with a Neuron being a record with an inputs field and a weights field, then a Layer data type which was [Neuron], and a Net type which was [Layer]
13:09:55 <ddarius> If the code is confusing, it's going to be difficult to get it working, and then once it is you are going to want to rewrite it all in a way that makes it clearer and would have been useful when writing it to begin with.
13:10:08 <unkanon> opqdonut: but I'm not that comfortable with the language yet
13:10:22 <feros> what the hell is this
13:10:36 <unkanon> ddarius: well ok let me post it and get some opinions
13:10:40 <alpounet> jmcarthur, luke's post is tremendously interesting 
13:10:49 <Twey> New Luke post?
13:11:30 <number9> lispy: I think I figured out how to fix this, but not sure if it would break something and am having trouble building it to test.... do you have a minute?
13:11:36 <alpounet> no Twey, an old one
13:11:40 <alpounet> ( http://lukepalmer.wordpress.com/2009/07/07/emphasizing-specialization/ )
13:11:49 <Twey> Oh, okay
13:11:50 <lispy> number9: I have a minute if it means fixing ghc :)
13:12:13 <jmcarthur> alpounet: i know! i read it when it was new and it's been itching ever since
13:12:49 <fysx> danr, saizan: thanks!
13:13:51 <number9> lispy: on line 79 of unlit.c there is an option to leave in cpp lines (lines that start with # right?) which is unnecessary for ghc ( I could be wrong about that), but maybe try setting the '1', to a '0' and see if it fixes our little problem/
13:13:55 <number9> *?
13:14:20 <Twey> Heheh.
13:14:26 <Twey> Binary Debugging 101
13:15:20 <lispy> number9: It's not unnecessary
13:15:46 <number9> lispy: so cpp lines need to be there for other things?
13:15:54 <unkanon> ddarius: I cleaned it up, this is what I have: http://hpaste.org/42281/ann
13:16:11 <lispy> number9: you really want the check (see the snippet I put in the ghc trac), to check if the pattern is "##" and treat it differently.  I don't know the markdown grammar.  Is a singe "#" a valid section in markdown?
13:16:16 <lispy> number9: correct
13:16:37 <unkanon> ddarius: note that the code does work fine, it just looks ugly and it's becoming unmanageable
13:17:00 <number9> lispy: yes # would give a h1 type heading.
13:17:24 <number9> But for the h1, and h2 headings there are alternatives, so really I guess we just need to fix types 3 and up
13:17:41 <lispy> number9: So, that will always be a problem with unlit the way it's written.  It needs to strip out any line that's not part of a code block.
13:18:02 <lispy> number9: This is why/where the Cabal version should be better
13:18:32 <lispy> number9: and why I think we should pass unlit.c into the hall of fame and retire it with our thanks to Mark Jones :)
13:18:35 <number9> lispy: yes I'm looking at that too, I think it will have to wait for a couple of days though...
13:19:09 <number9> lispy: yup agree with you there. unlit.hs is much nicer to look at! I had forgotten how painful reading c code was
13:19:33 <lispy> You can forgive C for being hard to read, but never forget...Never forget. :)
13:19:58 <number9> lispy: ;)
13:20:05 <jmcarthur> alpounet: anyway, i've been experimenting with graph reduction strategies and it turns out that it's tremendously easy to do what luke was describing that way. the problem is just that you can't really generate a whole lot of machine code statically
13:20:22 <jmcarthur> at least not naively
13:20:32 <Alan> Hmm, I'm trying to work out how to pack a Word8 and a Word32 together into a ByteString... any ideas?
13:20:37 <alpounet> jmcarthur, yeah, i see some comments about that
13:20:47 <ddarius> Alan: Use the binary package.
13:20:56 <number9> lispy: alright I'll have to come back to this later, will leave things I find on the bug post, thanks again for your help
13:21:12 <alpounet> jmcarthur, the real fun of the codegen happens at runtime
13:21:15 <jmcarthur> alpounet: i do suspect that JIT would have a good place here
13:21:18 <Alan> ddarius: as in data.binary?
13:21:25 <ddarius> @hackage binary
13:21:26 <lambdabot> http://hackage.haskell.org/package/binary
13:21:31 <lispy> number9: actually, I don't think that C is so hard to read, it's just that we don't seem to have a test suite for it and making small changes might have unforseen consequences.  The change we want to make is not so small because it doesn't detect what "context" you are in.  So you can't really expect it to know how to handle contextual things like this correctly.
13:21:34 <alpounet> jmcarthur, yeah, that's what augusts says
13:21:39 * hackagebot tagsoup 0.12 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12 (NeilMitchell)
13:22:17 <lispy> number9: by contrast, the Cabal one does seem to keep track of what context it's in
13:22:23 <jmcarthur> alpounet: i disagree with augusts on needing code gen for good specialization though
13:22:36 <alpounet> jmcarthur, i manage to see what you mean by "lazier'
13:22:39 <number9> lispy: I would agree there
13:22:43 <jmcarthur> alpounet: but i think maybe augusts wasn't considering that this can lead to exponential speedups compared to call-by-need
13:23:05 <number9> \leave
13:23:08 <Alan> ddarius: ooh, so I should use class instancing to define the binary format rather than writing a translation function? (since everything i'm translating is in a single data type...)
13:23:16 <mpiechotka> Hello. How to turn on [overlap ok] syntax?
13:23:16 <ddarius> Alan: No!
13:23:39 <ddarius> Alan: Use the Put monad and operations directly.
13:23:41 <Alan> ddarius: then the docs for binary are full of crap?
13:23:57 <alpounet> jmcarthur, is there any serious implementation LS ?
13:24:01 <alpounet> of LS*
13:24:39 <Alan> ddarius: seems to me that the docs for binary focus heavily on doing "instance Binary mytype"
13:25:18 <jmcarthur> alpounet: a good example for demonstrating how it's lazier is to have a function that takes a function as an argument and then uses it more than once. in call-by-need, the argument (which is a function) will have internal reductions that are performed redundantly, but head spine reduction with sharing would perform those reductions only once
13:25:29 <jmcarthur> alpounet: not yet
13:26:44 <ddarius> Alan: 1) Data.Binary is where the Binary class is defined, 2) not if you actually read the documentation.
13:26:57 <ddarius> "For parsing and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the Put and Get primitives directly. "
13:27:11 <alpounet> jmcarthur, ok
13:27:17 <alpounet> i'll have to read about head spine reduction
13:27:19 <alpounet> any ref ?
13:27:42 <Alan> ddarius: what i'm doing counts as a simple external binary format i'm pretty sure
13:28:19 <ddarius> Alan: I still wouldn't recommend using the Binary class for it.
13:28:56 <ddarius> Alan: You should use the Binary class when you don't actually care about the representation.
13:29:37 <jmcarthur> alpounet: http://www.itu.dk/people/sestoft/papers/sestoft-lamreduce.pdf  <-- discusses a few evaluation strategies. doesn't talk about sharing at all though
13:30:22 <alpounet> jmcarthur, you should try to share your thoughts about this
13:30:30 <Alan> ddarius: ok... nice that there is no example provided for the other method...
13:30:33 <alpounet> on a blog or something
13:30:37 <alpounet> to get feedback from people
13:30:59 <ddarius> Alan: The "other method" is just to write what you'd put in the put method as a normal function.  There's no special framework.
13:31:39 <jmcarthur> alpounet: head spine reduction is basically where you always reduce to HNF
13:32:02 <ddarius> Alan: Here you go: putFoo (Foo b w) = putWord8 b >> putWord32le w
13:32:07 <alpounet> hm
13:32:14 <jmcarthur> alpounet: as opposed to WHNF
13:33:10 <Alan> ddarius: ok, thanks :)
13:33:17 <Alan> ddarius: sorry for being so obtuse
13:33:36 <jmcarthur> alpounet: i am indeed planning to blog about it. i'm only taking my time to make sure that i understand it well enough to not lead people on
13:33:36 <alpounet> jmcarthur, so it's like always reducing to HNF + heavy use of sharing ?
13:34:12 <jmcarthur> alpounet: that's my idea, yeah
13:34:17 <alpounet> ok
13:34:19 <alpounet> sounds neat
13:34:20 <jmcarthur> alpounet: or luke's, at least
13:34:25 <alpounet> yeah
13:34:39 <jmcarthur> alpounet: i'm still trying to decide where completley lazy evaluation falls. it seems to be equivalent so far
13:34:44 <jmcarthur> *completely
13:35:04 <alpounet> why don't you guys work together on implementing this ?
13:35:28 <jmcarthur> alpounet: it's already come up in discussion with conal and luke ;)
13:36:38 <jmcarthur> alpounet: my overall goal is to eventually make a language that is as lazy and non-strict as i can practically manage, and that seems to be something that conal and luke are also interested in
13:37:05 <jmcarthur> alpounet: with the condition that the language remains practical that is
13:37:07 <alpounet> so that's what the twitter chat was all about :p
13:37:46 <jmcarthur> alpounet: we haven't discussed ideas over twitter as far as i know, unless you mean something *i* said earlier
13:38:34 <alpounet> well, few days ago you were talking about working together
13:38:37 <jmcarthur> alpounet: anyway, it's very likely that all this extra sharing and laziness means that space leaks could be a bigger problem. i'm thinking maybe some sort of dynamic "unevaluation" triggered by the GC could help with that
13:38:48 <jmcarthur> yeah, then we moved the conversation to email
13:39:24 <alpounet> anyway jmcarthur i'm wondering how good this would be for a 3D game for example
13:40:08 <roconnor_> hey, Joe Hurd works at Galois.
13:40:57 <jmcarthur> alpounet: well... i'm not sure it'll be useful for real time graphics for quite some time ;)
13:41:00 <jmcarthur> brb
13:41:43 <alpounet> jmcarthur, that's my worry yeah, but more interestingly: how could we make it be useful for that case? by changing what?
13:41:49 <jmcarthur> err, back... for now
13:42:46 <jmcarthur> alpounet: JIT would probably be the most useful thing, and a static optimization to detect when the extra power isn't used and do a more traditional static code generation for those parts
13:43:02 <dbelange> Hey jerks, when we take the dual of a category, is there any natural and concrete interpretation for that?
13:43:37 <dbelange> That is, if I have some interpretation for the objects and morphisms of C, does that poop out some interpretation for C^op?
13:44:18 <roconnor_> dbelange: we are not going to tolerate that sort of tone in #haskell
13:45:00 <Cale> dbelange: The answer is either that it's the same interpretation and the arrows are just backwards, or no.
13:45:29 * applicative suggests, in a freiendly tone, that it's very concrete, you just turn the arrows around
13:45:40 <dbelange> :)
13:46:11 <alpounet> jmcarthur, sounds quite fun
13:46:16 <benmachine> mpiechotka: if you saw [overlap ok] in :info in ghci, I don't think that's syntax you can actually use
13:46:27 <benmachine> mpiechotka: it just means the module that defined it had OverlappingInstances
13:47:18 <parcs> how do i install a specific version of a package with cabal?
13:47:49 <alpounet> cabal install foo-0.1
13:48:23 <geheimdienst> you can also use things like «cabal install foo "<= 0.3"»
13:48:32 <geheimdienst> iirc
13:50:59 <jmcarthur> alpounet: i hope so at least
13:51:04 <mpiechotka> benmachine: Thanks
13:51:21 <alpounet> jmcarthur, keep me posted if you guys start anything about this
13:51:34 <alpounet> i'd be glad to read, try, etc
13:51:56 <parcs> geheimdienst: that doesn't work for me
13:52:29 <jmcarthur> alpounet: definitely
13:52:30 <dixie> @type Nothing
13:52:31 <lambdabot> forall a. Maybe a
13:53:25 <geheimdienst> parcs, sorry, it's gotta be «cabal install "foo < 0.2"». i don't remember it very clearly
13:54:17 <parcs> yep, that works :)
13:59:30 <huski> @type words
13:59:32 <lambdabot> String -> [String]
14:00:01 <huski> @type snd
14:00:02 <lambdabot> forall a b. (a, b) -> b
14:01:41 <huski> @type drop
14:01:42 <lambdabot> forall a. Int -> [a] -> [a]
14:03:21 <huski> @type map
14:03:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:03:30 <dbelange> @type @type
14:03:31 <lambdabot> parse error on input `@'
14:04:14 <unkanon> someone at #ai told me to use hmatrix for my feedforward backprop neural net. how will that help me? I'm reading about it but can't see how it can help me
14:05:46 <mikeg> you need to compute partials for backpropogation to tell how each weight changes the output, and i guess hmatrix can help depending on your activation function?
14:06:06 <mikeg> have you looked at hnn?
14:06:06 <unkanon> my activation is simply sigmoid
14:06:28 <unkanon> mikeg: I want to come up with my own code before I peek at other people's :) Im trying to understand the algorithm
14:06:49 <unkanon> mikeg: I'm afraid I don't know what a "partial" is
14:07:36 <hpc> :t (:t)
14:07:37 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
14:07:37 <lambdabot>     In the second argument of `(:)', namely `t'
14:07:37 <lambdabot>     In the expression: (: t)
14:09:08 <Alan> Hmm, so Data.Binary.Put.runPut is giving me something of type Data.ByteString.Lazy.Internal.ByteString...
14:09:13 <mikeg> Without backpropogation, you change each weight slightly and find (change in error)/(change in w) to determine how you should change your weights in the next training iteration
14:09:36 <Alan> Should that be the case? and isn't that going to be a pain if i then want to use the bytestring elsewhere?
14:10:19 <huski> :t drop
14:10:20 <lambdabot> forall a. Int -> [a] -> [a]
14:10:42 <unkanon> mikeg: so without backprop I change the weights from the first layer to the last, instead of the reverse as it is with backprop?
14:10:56 <huski> :t map (+2) (map (*2) filter (>2) [2,4,6,8]))
14:10:57 <lambdabot> parse error on input `)'
14:10:58 <ddarius> Alan: You can convert between lazy and strict bytestrings easily if you need to.
14:11:10 <huski> :t map (+2) (map (*2) filter (>2) [2,4,6,8])
14:11:11 <lambdabot>     Couldn't match expected type `[a]'
14:11:11 <lambdabot>            against inferred type `(a1 -> Bool) -> [a1] -> [a1]'
14:11:11 <lambdabot>     In the second argument of `map', namely `filter'
14:12:25 <mikeg> Mhmm it gets confusing when you try to do backpropogation through multiple layers :x
14:12:39 <unkanon> mikeg: that's what I just found out!
14:12:45 <unkanon> I'm done with the feedforward part
14:12:56 <unkanon> I already have a working algo for getting the output
14:13:00 <huski> :t map (+2) (map (*2) (filter (>2) [2,4,6,8]))
14:13:01 <lambdabot> forall a. (Num a, Ord a) => [a]
14:13:28 <unkanon> problem now is thinking how to do the deltas
14:14:54 <mikeg> to get backprop right you should use the delta rule, which requires partials, and hmatrix can do that porition of the code for you for any activation function
14:16:29 <unkanon> hmm I think that would be more complicated for me, since I'm not too math-aware
14:17:07 <Alan> ddarius: how?
14:17:22 <unkanon> I'll just try to run the delta rule on the first layer, since it's naturally recursive anyway (when it wants the weights and deltas of the next node)
14:17:43 <mikeg> So did you do the method I mentioned before, where you just run feed-forward with small changes in each weight?
14:17:59 <Alan> ddarius: never mind, i figured out what i really needed
14:18:13 <Alan> which was putStr from Data.ByteString.Lazy, rather than from Data.ByteString...
14:18:13 <unkanon> mikeg: what I have right now doesn't change any weights
14:18:21 <unkanon> mikeg: http://hpaste.org/42281/ann
14:20:13 <mikeg> `normalDelta x w d = x * (1 - x) * w * d` is the part that hmatrix could help with, since that is derived from your activation function
14:21:21 <unkanon> my activation function is step at line 19
14:21:26 <Leemp> Gah, why do i keep getting the urge to figure out haskell. 
14:21:40 <Leemp> I think it's because it's so mind boggling to me at this point and time.
14:21:57 <unkanon> what I really need help with is not writing the formulae but getting around in the network (knowing how to go back and forward in the layers)
14:22:08 <unkanon> it's confusing when your network is [[[Double]]]
14:22:09 <roconnor> Leemp: once you understand you will never go back
14:22:38 <Leemp> roconnor: Those huge statements are also why i keep trying xD
14:22:54 <Leemp> roconnor: But dear lord.. is it just me, or is it insanely ugly?
14:22:55 <roconnor> Leemp: it would be easier if you didn't know how to "program"
14:23:03 <Leemp> roconnor: Probably
14:23:19 <mikeg> The basic NN algo is to run the feed-forward with your initial weights, to change each weight by some small amount and recalculate error in succession, then update your weights to minimize error
14:23:42 <Leemp> I suppose it's only ugly because every other language i've used or been exposed to uses different schemes. Their code blocks differ greatly (or so it appears)
14:24:06 <Cale> Leemp: Is there something in particular that bothers you?
14:24:23 <roconnor> Leemp: lots of people (who don't know Haskell) find the syntax ugly, but I've never understood why.
14:24:34 <Cale> Leemp: It's certainly possible to write ugly Haskell code, but a lot of Haskell code is quite pretty.
14:24:39 <Leemp> Cale: You mean visually, in me calling it "ugly"? (And i'm sorry for that term, it is harsh.. keep in mind i'm ignorant :)
14:24:45 <unkanon> mikeg: but one can only change the weights after having calculated the output layer, right? so you still have to go all the way
14:24:45 <dibblego> I teach haskell. I come across this often. It never lasts more than a few days
14:25:02 <Cale> I mean, it would be nice to see an example of something you think is ugly, so we could get an idea of why you might think that.
14:25:18 <roconnor> Though I did explain to a friend that white-space was left (right?) associative, and he practically walked away at that point in time.
14:25:24 <dibblego> sometimes I force the student to use braces and semi-colons so that it is "not so ugly" -- that doesn't last long either
14:25:31 <Leemp> roconnor: Keep in mind i'm a Python programmer by nature.. so i find non-alpha syntax generally ugly anyway (even in python). A lot of it just seems hard to read, in terms of things not being easy on the eyes
14:25:48 <Cale> roconnor: whitespace is indeed left associative :)
14:25:58 <roconnor> Leemp: generally non-alpha syntax is only used for infix operators.
14:26:01 <Cale> Leemp: So, the infix operators?
14:26:08 <Adamant> every syntax is beautiful for someone that loves the language
14:26:17 <Leemp> Adamant: Agreed
14:26:31 <Leemp> Adamant: Hence why i proclaimed myself as ignorant :D
14:26:35 <Adamant> some are better or worse at making things look like line noise
14:26:37 <mikeg> unkanon: yeah, the loop i describe is basically: weights[n] += mu; error' = calculateError(feedForward(weights)); weights[n] += alpha*(error'-error);
14:26:46 <Adamant> most of the rest is personal preference
14:27:08 <dibblego> mikeg, those kind of loops are often best written with foldl
14:27:18 <roconnor> foldl'
14:27:32 <dibblego> Data.Foldable.foldl
14:27:37 <roconnor> oh
14:27:41 <Leemp> Adamant: I think that's a good description. I see a lot of, what i feel, is noise. Ie, i googled haskell irc bot (i'd like a simple starting project so i can.. "do" something), and i was taken back by.. well, the noise. Again, i'm ignorant, i mean no offense :)
14:27:45 <mikeg> that's left as an exercise for the reader...
14:27:52 <roconnor> Leemp: link?
14:28:00 <Leemp> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:28:00 <aavogt> @code
14:28:00 <lambdabot> Maybe you meant: more todo vote
14:28:07 <unkanon> Leemp: I often think imperative code has a lot more noise
14:28:15 <unkanon> like all the variable declarations
14:28:19 <Leemp> I think i will try and make an irc bot though, just so i can.. do something
14:28:47 <Adamant> Leemp: personally I don't feel that way about Haskell after learning it. it is definitely something different than what most people are used to, though
14:29:07 <Leemp> But really, i am a poor little self taught and self proclaimed "programmer". Haskell makes me realize that my "title" is far from appropriate lol.
14:29:39 <dibblego> Leemp, just hook in to haskell mate, I'm sure you'll take something profound from it
14:29:45 <Leemp> For the past 2 weeks though, as much as i try to ignore haskell, i keep wanting to figure it out
14:29:54 <Leemp> It's bothering me xD
14:29:57 <Cale> Leemp: While it's possible to go overboard with them, and maybe some libraries do this, most infix operators you'll see are related to composition of things -- they glue things together in various (possibly abstract) ways without doing all that much on their own. So the names we would have for them would be sort of nondescript in a lot of cases.
14:30:27 <dibblego> who wants to write "kleisliCompose f g" anyway? :)
14:30:35 <Adamant> Leemp: think how boring it would be if you really did have it all figured out :)
14:30:56 <Leemp> Here is an ignorant question. Everything in haskell is based off of functions right? Functions that do simple, precise, tasks? So, do you find yourself memorizing (or even forgetting) massive amounts of function names?
14:31:19 <nostrand> Leemp: what would an alternative be?
14:31:21 <mikeg> unkanon: It may be easier to write a network for NOT before XOR, since it can be done without a hidden layer
14:31:24 <roconnor> Leemp: sure, but the functions we have to memorize are keywords in other langauges. :D
14:31:24 <dibblego> when I need to do "something" I formalise it or semi-formalise it to a type, then look it up by that type
14:31:27 <roconnor> @src when
14:31:28 <lambdabot> when p s = if p then s else return ()
14:31:33 <roconnor> @src unless
14:31:33 <lambdabot> unless p s = if p then return () else s
14:31:38 <roconnor> @src guard
14:31:39 <lambdabot> guard True  =  return ()
14:31:39 <lambdabot> guard False =  mzero
14:31:41 <aavogt> the Prelude has roughly 250 functions
14:31:45 <Cale> Leemp: Well... it's certainly quite important to have a good handle on some of the basic libraries of functions. A lot of the basic control structures are just functions in the libraries.
14:31:52 <unkanon> mikeg: I'm afraid if I do that I'll end up with code that is not too general. it'll basically be a hardcoded network 
14:31:54 <roconnor> @src forM
14:31:54 <lambdabot> forM = flip mapM
14:32:05 <dibblego> Leemp, suppose you wish to find the length of a list, this can be written as the type [a] -> Int
14:32:09 <dibblego> Leemp, so then I do this:
14:32:10 <Cale> Leemp: In particular, we use lists and operations on lists in most cases where imperative programmers would use loops
14:32:12 <dibblego> @hoogle [a] -> Int
14:32:13 <lambdabot> Prelude length :: [a] -> Int
14:32:13 <lambdabot> Data.List length :: [a] -> Int
14:32:13 <lambdabot> Prelude head :: [a] -> a
14:32:18 <dibblego> and then I carry on :)
14:33:02 <Leemp> It's hilarious how foreign haskell feels. Moreso than any other language i've ever seen xD. (Again, not a bad thing, but i literally laugh when i read it)
14:33:24 <Leemp> Anyway, back to Learn You a Haskell :)
14:33:25 <mikeg> unkanon: it'd be better to write an inelegant network that you understand over an elegant one you can't :D
14:33:27 <dibblego> Leemp, haskell is quite distant from many languages; like I said, I'm sure you'll take something profound from it, hook in
14:33:50 <dibblego> mikeg, even better, write one that you can't understand, then come to understand it
14:34:28 <unkanon> well I can do feedfwd and backprop by hand using pen and paper, it's just hard to think of how to do it functionally without mutation
14:34:50 <sipa> :t bracket
14:34:51 <lambdabot> Not in scope: `bracket'
14:34:57 <Cale> Leemp: For example, let's suppose we want to keep a running total of something. In an imperative language, we'd initialise a new mutable cell to 0, and then update it in a loop by adding the current value to the old sum. In Haskell, we might take that input to be a list, and we'd use the function scanl (+) 0
14:35:12 <Cale> > scanl (+) 0 [1,20,300,4000,50000]
14:35:12 <lambdabot>   [0,1,21,321,4321,54321]
14:35:52 <Cale> scanl captures this idea of keeping a running accumulation as you march down a list, with a given combining function and initial value
14:38:15 <ziman> now I'm trying hard to come up with a scenario where strict-in-the-accumulator scanl would be appropriate. Would (scanl (*) 1 xs)!!1000000 qualify?
14:38:39 <ziman> as !! goes along the list, it does not force the values, does it?
14:40:13 <Philonous> > [undefined,1,2] !! 2
14:40:14 <lambdabot>   2
14:40:34 <hpc> ziman: it does not force the values; that can be the cause of stack overflow if you are not careful
14:45:17 <unkanon> mikeg: what if I used one of those mutable arrays that Haskell provides? that would make it a lot easier
14:45:54 <unkanon> was that a netsplit?
14:47:15 * ddarius considers getting lost in Boston looking for a place that might not even be in Boston.
14:49:50 <benmachine> ddarius: sounds like fun
14:50:14 <mikeg> i imagine it wouldn't be to difficult to write a function :: [Double] -> [Double] that either 1) recurses with new weights, if error is high 2) returns weights, if error is below a threshold
14:50:54 <mikeg> or you could write a fold, which is probably a little more difficult to reason for this
14:53:47 <Cale> ziman: Sorry, missed your question before -- yeah, something like that would be needed.
14:54:25 <Cale> ziman: Normally if you're processing the elements in order, you don't need a stricter scanl, but !! tends to interact badly with a lot of lazy list producers like that
15:08:25 <copumpkin> isn't there a getInt*(b/l)e ?
15:09:53 <ddarius> fromIntegral . getWord ?
15:10:09 <copumpkin> sure, but it seems odd to leave them out
15:10:21 <copumpkin> I guess they didn't want to assume a two's complement?
15:11:28 <ddarius> Vieleicht
15:12:43 <ddarius> copumpkin: Want to wander aimlessly search for something that doesn't exist fairly near to where you live (near the Back Bay or Copley stops)?
15:13:03 <copumpkin> ddarius: sure!
15:13:20 <copumpkin> just need to finish something and then I'm free
15:14:16 <aavogt> is there some way to include a data-accessor-0.2.1.5:Data.Accessor.Private.T  in a type?
15:15:05 <aavogt> without modifying that package with unfortunate namings of course
15:15:24 <benmachine> aavogt: erm, you can't specify versions in a type
15:15:47 <aavogt> benmachine: that is the type ghci gives me
15:15:55 <benmachine> aavogt: yeah
15:16:12 <benmachine> if you are getting the version in the type it might be because it's trying to link two different versions of the same package
15:16:16 <benmachine> which just won't work
15:17:11 <aavogt> basically this is my task: http://hpaste.org/42286/better_chart_accessors
15:17:45 <Alan> hmmm... GHC hates me...
15:18:02 <ddarius> GHC loves you.  It just doesn't lie to make you feel better.
15:18:05 <benmachine> aavogt: what I would do is try to work out if you're using libraries compiled against different versions of data-accessor
15:18:11 <aavogt> so it generates one class for every name, and instances have a method with that name and the type of the accessor
15:18:14 <Alan> ddarius: :P
15:18:18 <aavogt> benmachine: no that's not what's going on
15:18:31 <aavogt> data-accessor doesn't export that T
15:18:31 <Alan> ddarius: it's saying: "Warning: output was redirected with -o, but no output will be generated
15:18:35 <Alan> because there is no Main module."
15:18:42 <benmachine> aavogt: if a type is not exported, it's not meant to be usable
15:18:53 <benmachine> aavogt: what output do you want to generate?
15:18:55 <benmachine> eeer
15:18:57 <benmachine> Alan: that
15:19:45 <Alan> benmachine: well, i have a package hierarchy, and one of the modules in one of the packages has a "main" function.  I want a binary for that main function
15:20:26 <benmachine> Alan: if it's not the Main module, try doing -main-is Name.Of.Module.main
15:20:31 <benmachine> or
15:20:32 <aavogt> benmachine:  class AccValues a where values :: a;  instance AccValues [| :type plot_candle_values |] where  values = plot_candle_values
15:20:33 <benmachine> Alan: if it's not the Main module, try doing -main-is Name.Of.Module
15:21:01 <aavogt> followed by every other function name with such an ugly name ending in values
15:21:10 <Alan> benmachine: oh, i see, that's not implied by the ghc --make Name.Of.Module ?
15:21:14 <benmachine> aavogt: you can't declare instances of non-exported types, by design
15:21:39 <Alan> benmachine: does haskell expect the main function to be at Main.main then?
15:21:44 <benmachine> Alan: yes
15:21:44 <Alan> sorry, i mean GHC
15:21:51 <Alan> ok, i think i get it
15:21:52 <benmachine> no haskell does :P
15:21:52 <Alan> thanks :)
15:21:59 <benmachine> GHC allows you to override that
15:22:20 <Alan> oh?  so "runhaskell Name.Of.Module" does a hack to look for main in Name.Of.Module instead of Main?
15:22:30 <benmachine> presumably!
15:22:35 <benmachine> runhaskell uses ghc :)
15:22:44 <aavogt> benmachine: can you see any way around this, given my self-imposed constraint on keeping data-accessor unmodified?
15:22:45 <benmachine> well, if you have ghc installed it does
15:23:06 <Alan> so it's like ghc --make $MODULE -main-is $MODULE -o foo ; ./foo
15:23:08 <Alan> or something like that
15:23:09 <Alan> ok
15:23:12 <copumpkin> ddarius: man, it's awfully wet outside though :P
15:23:18 <copumpkin> I can hear the rain, which is a bad sign
15:23:29 <benmachine> aavogt: uhm, not really. is there a good reason why data-accessor didn't export that type?
15:24:10 <Alan> /usr/lib/ghc-6.12.1/libHSrtsmain.a(Main.o): In function `main':
15:24:10 <Alan> (.text+0x1): undefined reference to `ZCMain_main_closure'
15:24:13 <Alan> awesome.
15:24:56 <aavogt> ah, I can probably use   type Accessor r a = data-accessor-0.2.1.5:Data.Accessor.Private.T r a
15:25:18 <aavogt> with appropriate TypeSynonymInstances
15:33:07 <ddarius> copumpkin: I can bring a trenchcoat if need be.
15:33:41 <copumpkin> ddarius: I could get an umbrella (I still don't have my stuff, so no waterproof clothing :P)
15:33:50 <copumpkin> I have a 7 11 right downstairs that might sell one
15:34:51 <ddarius> copumpkin: I have an umbrella.  I could bring it.  And since I never use it, I may even just give it to you.
15:35:12 <Cale> Alan: I'm not sure that runhaskell does anything magical in that regard. I think it's just that if you don't explicitly put a module declaration at the head of the module, the default module name is Main
15:36:04 <Cale> Alan: Normally you have to name your modules with filenames related to their names so that GHC can find them, but that's not a problem if you're specifying them on the commandline.
15:36:20 <copumpkin> ddarius: sure, where and when should we meet?
15:36:45 <copumpkin> no need to give me the umbrella, as I hardly ever use them anyway, when I have waterproof clothing (which I should get back on tuesday!)
15:36:49 <copumpkin> but thanks :)
15:37:04 <copumpkin> although I guess it will be raining tomorrow, so I might borrow it :)
15:37:31 <Alan> Cale: i have a module declaration in every file... this works with runhaskell My.Module but not ghc --make My.Module
15:37:40 <Cale> ah, okay
15:37:41 <ddarius> copumpkin: Presumably at or near one of the stations.  I'll probably go to the Back Bay one since I can do that all on the Orange Line.  I don't know how long it would take me to get there though as I've never ridden the metro here or even walked down to the metro stop.
15:37:50 <copumpkin> oh wow :)
15:38:00 <ddarius> It will probably take on the order of 30-45 minutes is my guess.
15:38:06 <Cale> Alan: I think I agree that it could be made more sensible in that regard
15:38:16 <copumpkin> okay, I can get to back bay in about 30 minutes
15:38:44 <Cale> Alan: That is, it could try harder to find a definition of main *somewhere* and use that. Especially when there's only one .hs file on the commandline.
15:38:51 <ddarius> That's farther than I thought it would be for you.
15:39:19 <copumpkin> ddarius: I'm probably overestimating
15:39:26 <Alan> Cale: also, when i use -main-is it fails to link, so :(
15:39:45 <copumpkin> it takes me exactly 15 minutes to the entrance of the prudential center, and then the back bay station is all indoors from there, but maybe another 7 minutes
15:39:47 <duckinator> can someone please help me with formatting and also any potential methods to clean it up?: https://gist.github.com/2fe11916e8ce3a5ca4e7 quite frankly, i'm ashamed to be the author, but i can't get help without admitting that D;
15:40:08 <benmachine> Alan: that is weird. are you sure you got the module name right?
15:40:17 <benmachine> Alan: also exactly what did you give to -main-is?
15:40:17 <Cale> Alan: I usually find it easier just to pull the main programs out into their own modules.
15:40:18 <Alan> Cale: well, i say that, but for some weird reason it worked this time... wtf?
15:40:24 <benmachine> heheh
15:40:25 <Alan> benmachine: the name of the module
15:40:27 <benmachine> that can happen
15:40:28 <Alan> ghc -ihs --make HWAM.Compiler -main-is HWAM.Compiler -o compiler
15:40:41 <Alan> Cale: it is in it's own module
15:40:50 <benmachine> maybe it happens if the module doesn't require recompilation? :P
15:40:53 <benmachine> er
15:40:55 <benmachine> -:P
15:40:58 <duckinator> also, rest assured that there's nothing else in my code even remotely close to being as horrifying as what i linked to ;P
15:41:00 <benmachine> superfluous emotion
15:41:17 <Cale> Alan: In that case, just delete the module declaration :)
15:41:17 <Alan> benmachine: so when i compiled without -main-is and it didn,t work, and then compiled with -main-is it didn't bother rebuilding or something?
15:41:24 <copumpkin> ddarius: so aim for around 7:30?
15:41:26 <Cale> Alan: and then you don't need -main-is
15:41:41 <Alan> Cale: maybe, but actually this might not remain just a main-file
15:41:42 <benmachine> Alan: that is my current hypothesis but I haven't tested it
15:41:54 <ddarius> copumpkin: That works.  I'll text you when I'm there.
15:42:01 <copumpkin> sounds good, see you soon
15:42:21 <ddarius> Hopefully I don't take a wrong turn on the metro.  I managed to navigate Japan's successfully upon just arriving, so this should be no problem...
15:42:51 <Cale> duckinator: Okay, there are several things which you could do. First: don't use lists as tuples.
15:43:52 <duckinator> Cale: alright, that was my fail
15:44:34 <duckinator> Cale: but other than that i've got no clue what to do for it. it's just all around disgusting, and no matter how many times i rewrite it it's equally disgusting :P
15:44:40 <Cale> The other thing I would recommend is to try harder to avoid using the length function when you can.
15:45:01 <Cale> It's sort of hard to see what the ends function is doing.
15:45:11 <benmachine> duckinator: handle can use guards
15:45:29 <copumpkin> coends!
15:45:43 <Cale> I guess it's chopping off that many elements from each end, and producing the split-up bunch of lists?
15:46:00 <Cale> yeah
15:46:10 <benmachine> splitAt would be useful for that
15:46:33 <Cale> Yes, you'd still have to compute the length once for that, but that might not be too bad in this context.
15:46:55 <Cale> You can certainly avoid computing it twice, like you are here.
15:49:11 --- mode: holmes.freenode.net set +o ChanServ
15:49:33 <duckinator> benmachine: yea, it can, but i decided against having guards /start at/ 73 chars in...
15:49:51 <benmachine> pfft
15:50:31 <duckinator> also,   ends 2 2 "[[abcd]]" -> ("[[", "abcd", "]]")
15:51:37 <duckinator> bbs/bbl, dinner
15:52:09 <applicative> > splitAt 4 "duckinator"
15:52:09 <lambdabot>   ("duck","inator")
15:54:05 <applicative> > splitAt 40 "duckinator"
15:54:06 <lambdabot>   ("duckinator","")
15:54:56 <benmachine> > splitAt (-1000) "duckinator"
15:54:57 <lambdabot>   ("","duckinator")
15:55:24 <aristid> > break (=='m') "benmachine"
15:55:25 <lambdabot>   ("ben","machine")
15:59:21 <applicative> > let duckinator = (\(a,(b,c)) -> (a,b,c) ) . (\(a,b) -> (a, splitAt 3 b) ). splitAt 4 in duckinator "applicative"
15:59:22 <lambdabot>   ("appl","ica","tive")
16:02:20 <applicative> @pl duckinator n m splitat xs = (\(a,(b,c)) -> (a,b,c) ) . (\(a,b) -> (a, op n b) ). op m $ xs
16:02:20 <lambdabot> duckinator = ((const . (uncurry ((`ap` snd) . (. fst) . (,,)) .)) .) . (. op) . (.) . (`ap` snd) . (. fst) . flip ((.) . (,)) . op
16:02:44 <applicative> @pl duckinator n m splitat xs = (\(a,(b,c)) -> (a,b,c) ) . (\(a,b) -> (a, splitat n b) ). splitat m $ xs
16:02:44 <lambdabot> duckinator = (((uncurry ((`ap` snd) . (. fst) . (,,)) .) .) .) . (. flip id) . ap . ((.) .) . flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (,))) .) . flip id
16:09:59 <applicative> @pl \((a,b),c) -> (a,b,c) --not too loathesome
16:09:59 <lambdabot> uncurry (uncurry (,,))
16:16:12 <nostrand> shouldn't "fmap (+3) (0,0)" work?
16:16:25 <nostrand> > fmap (+3) (0,0)
16:16:26 <lambdabot>   (0,3)
16:16:53 <nostrand> i get "No instance for (Functor ((,) t))" ...
16:17:11 <unkanon> :m + Control.Monad.Instances ?
16:17:30 <Cale> nostrand: Unfortunately the instance of Functor for pairs isn't in the Prelude
16:18:58 <nostrand> aa, thanks
16:23:13 <hpc> unkanon: also Control.Functor.Instances, i think
16:23:37 <unkanon> never had to do that one but I'll keep it in mind :)
16:24:25 <unkanon> what does the summation symbol (that uppercase sigma) mean when it doesn't have a superscript saying where it begins and a subscript saying where it ends?
16:24:36 <djahandarie> I wish bifunctors were somewhere besides c-e
16:24:50 <unkanon> the last formula on the bottom of http://www.generation5.org/content/2002/bp.asp
16:25:02 <aristid> wouldn't it be possible to roll those instances into the Prelude, and make Control.Monad.Instances an empty module?
16:31:18 <aavogt> aristid: the Prelude is specified in the standard
16:33:24 <aristid> i'm not sure if it's always necessary to adhere to the standard in every detail
16:33:36 <aavogt> and considering that instances cannot be stopped once you import the module, that's probably not easy to do without breaking some code quite seriously
16:33:42 <aristid> and, even otherwise, those instances could at least be put into Control.Monad
16:34:51 <aristid> well, that would still be orphan instances tho
16:35:27 <Boxo> @pl \(a:b:c) -> (b:a:c)
16:35:27 <lambdabot> ap ((`ap` tail) . (. head) . flip ((.) . (:)) . (:) . head) tail
16:36:17 <geheimdienst> lambdabot: thanks, that's a clear simplification
16:36:38 <applicative> unkanon it looks like the sum is over the values of i
16:36:41 <aavogt> @pl \a b c -> a:b:c
16:36:41 <lambdabot> (. (:)) . (.) . (:)
16:36:44 <Boxo> elegant functional idiom!
16:37:03 <aristid> @pl \a b c -> [a,b] ++ c
16:37:03 <lambdabot> ((++) .) . (. return) . (:)
16:37:05 <unkanon> applicative: thanks, that makes some sense
16:37:08 <aavogt> @ty liftM3 ((. (:)) . (.) . (:)) (!!0) (!!1) (drop 2)
16:37:09 <lambdabot> forall a. [a] -> [a]
16:37:59 <geheimdienst> aavogt, now let's extract the 0 1 2 and instead use [0..] mapped over it ...
16:38:01 <geheimdienst> ;)
16:38:34 <geheimdienst> > map uncurry $ zip ((!!), (!!), (drop 2)) [0..]
16:38:35 <lambdabot>   Couldn't match expected type `[a]'
16:38:35 <lambdabot>         against inferred type `([a1] -> ...
16:38:56 <geheimdienst> > "bah, whatever"
16:38:57 <lambdabot>   "bah, whatever"
16:39:22 <aavogt> @ty \x -> map ($ x) (map (flip (!!)) (1:0:[2..]))
16:39:23 <lambdabot> forall a. [a] -> [a]
16:40:04 <aavogt> > map ($ "note") (map (flip (!!)) (1:0:[2..]))
16:40:05 <lambdabot>   "onte*Exception: Prelude.(!!): index too large
16:40:18 <geheimdienst> a thing that reorders a list given the indices ... that could be mildly useful
16:40:54 <geheimdienst> i think the computer graphics guys work with arrays of indices into vertex arrays or somesuch
16:40:59 <aavogt>  > (!! random) . permutations ?
16:41:31 <geheimdienst> > map ($ "unclear") (map (flip (!!)) (1:0:[2..]))
16:41:32 <lambdabot>   "nuclear*Exception: Prelude.(!!): index too large
16:41:38 <aavogt> > permutations [1..3]
16:41:39 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
16:41:39 <geheimdienst> nuclear BAM!
16:41:42 <djahandarie> Nuclear exception!
16:42:02 <aavogt> > (!! 1) . permutations $ "unclear"
16:42:03 <lambdabot>   "nuclear"
16:42:16 <aavogt> > (!! 1) . permutations $ "unclear"++repeat '_'
16:42:17 <lambdabot>   "nuclear___________________________________________________________________...
16:42:37 <djahandarie> So lazy you can't comprehend
16:42:59 <aavogt> huh, that's you not the code :p
16:43:25 <Olathe> > zip "zomg" (1:0:[2..])
16:43:25 <lambdabot>   [('z',1),('o',0),('m',2),('g',3)]
16:43:31 <geheimdienst> > find (== "aruncle") $ permutations "nuclear"
16:43:32 <lambdabot>   Just "aruncle"
16:44:05 <aavogt> > lookup "aruncle" $ permutations "nuclear" `zip` [0..]
16:44:06 <lambdabot>   Just 2893
16:44:07 <geheimdienst> > length $ takeWhile (/= "aruncle") $ permutations "nuclear"
16:44:08 <lambdabot>   2893
16:44:40 <Olathe> > zipWith (flip const) "zomg" $ (1:0:[2..])
16:44:40 <lambdabot>   [1,0,2,3]
16:44:56 <Olathe> > map ("zomg" !!) . zipWith (flip const) "zomg" $ (1:0:[2..])
16:44:57 <lambdabot>   "ozmg"
16:45:30 <Olathe> @pl \xs -> map (xs !!) . zipWith (flip const) xs
16:45:30 <lambdabot> ap ((.) . map . (!!)) (zipWith (const id))
16:45:48 * geheimdienst devises a scheme of storing plaintext words as indices into permutations arrays. so far, the scheme supports the word "nuclear" and all its permutations.
16:46:05 <Olathe> > ap ((.) . map . (!!)) (zipWith (const id)) "zomg" (1:0:[2..])
16:46:05 <lambdabot>   "ozmg"
16:51:59 <Olathe> > let rearrange xs = map (xs !!) . take (length xs) . nub . filter (< length xs) in rearrange "zomg" ([1, 0, 3, 2, 5, 4] ++ [6..])
16:51:59 <lambdabot>   "ozgm"
16:55:22 <aristid> > let rearrange xs ns = zipWith (!!)  xs . nub . filter (< length xs) in rearrange "zomg" ([1, 0, 3, 2, 5, 4] ++ [6..])
16:55:22 <lambdabot>   Couldn't match expected type `[a]'
16:55:23 <lambdabot>         against inferred type `GHC.Types...
16:55:35 <aristid> > let rearrange xs = zipWith (!!) xs . nub . filter (< length xs) in rearrange "zomg" ([1, 0, 3, 2, 5, 4] ++ [6..])
16:55:35 <lambdabot>   Couldn't match expected type `[a]'
16:55:36 <lambdabot>         against inferred type `GHC.Types...
16:57:28 <mathijsB> can anybode tell me how I can force a boolean to be evaluated using pattern matching (so no 'seq')?
16:57:58 <mathijsB> in all my attempts i keep evaluating the constructor around the boolean, and not the boolean itsself :p
16:58:38 <axman> case foo of Foo True -> ...; Foo False -> ...
16:58:43 <tshred> has anybody here used COntrol.Engine or Control.ThreadPool
16:58:46 <hpc> mathijsB: evalBool True = True; evalBool False = False
16:58:54 <hpc> just match on the Bool :P
16:59:54 <mathijsB> <- ashamed
17:00:02 <mathijsB> thanks hpc :)
17:02:42 <tshred> i am new to haskell and its concurrency packages..would anybody have a recommendation on what i should read?
17:03:02 <tshred> i need to learn about thread pools in haskell
17:03:25 <axman> what do you need thread pools for?
17:03:38 <axman> why not just use the stuff built into haskell?
17:03:50 <hpc> built into GHC, at least
17:04:39 <tshred> what 'stuff' are you referring to?
17:04:51 <tshred> threading?
17:05:09 <axman> forkIO, MVars, Chans, STM, pure parallelism
17:05:20 <hpc> also par and pseq
17:05:28 <axman> haskell is one of the best languages to use for concurrent programming because of these things
17:05:29 <hpc> if you need to be transparent about it
17:05:46 <axman> hpc: well, that's what i meant by pure parallelism
17:05:47 <hpc> er, axman covered that :P
17:05:49 <tshred> ah yes i need to learn about all of that, do you know of a good resource that teaches it?
17:05:50 <axman> :)
17:06:09 <axman> real world haskell must have something good on it
17:06:11 <tshred> i am reading real world haskell as well as learnyouahaskell
17:06:22 <tshred> ok i guess i haven't gotten to it
17:06:39 <tshred> thanks for your time
17:06:45 <tshred> back to reading..hehe
17:07:00 <hpc> tshred: par and pseq are fairly easy; if you want to parallel evaluate a bunch of things and use them for a computation, you write a `par` b `par` c `pseq` f a b c
17:07:06 <hpc> :t par
17:07:07 <lambdabot> forall a b. a -> b -> b
17:07:07 <hpc> :t pseq
17:07:08 <lambdabot> forall a b. a -> b -> b
17:08:11 <tshred> hpc: lambdabot: thanks to both of you
17:08:30 <hpc> STM i have no idea about
17:08:33 <axman> threading in haskell is damn easy too
17:09:02 <hpc> forkIO takes an IO action and executes it in another thread, giving you back the thread id for further manipulation
17:10:18 <hpc> so you can write do {forkIO $ putStrLn "1"; forkIO $ putStrLn "2"; return ()}
17:10:32 <hpc> and it will theoretically print 1 and 2 in unspecified order
17:10:58 <hpc> to communicate between threads, you need a thread-safe structure
17:11:07 <hpc> which is where MVars/Chans/etc come in
17:11:07 <aavogt> or if they are longer strings, they may be interleaved
17:11:37 <axman> bah, he left
17:11:46 <hpc> pah
17:12:36 <duckinator> applicative: were you just bored, or were those confusing (to a haskell noob as myself) examples for me to look at, over an hour ago? :P
17:14:44 <aavogt> anybody familiar with how to identify what makes for a duplicate instance declaration?
17:14:58 <aavogt> this is in code I'm generating with TH
17:15:56 <Cale> duckinator: applicative was just playing around, I don't think those were actually meant to be understood :)
17:16:55 <Cale> duckinator: The @pl plugin for lambdabot will eliminate lambdas from expressions, turning them into compositional things. Sometimes this simplifies code, other times it insanely complicates things into a giant mess :)
17:17:21 <duckinator> haha :)
17:17:26 <axman> s/Somtimes/Rarely
17:17:45 <FauxFaux> @pl bh (a:b:t) = if a < b then a:bh (b:t) else b:bh (a:t)
17:17:48 <lambdabot> bh = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (liftM2 ap .) . ap (ap . (((.) . if') .) . (<)) . flip ((.) . (.) . (:)) . (. (:)) . (.)) ((flip ((.)
17:17:48 <lambdabot> . (:)) .) . (. (:)) . (.)))
17:17:48 <lambdabot> optimization suspended, use @pl-resume to continue.
17:19:13 <djahandarie> Haha
17:19:15 <applicative> oh duckinator, I was first illustrating use of splitAt, then fell off the edge
17:19:26 <djahandarie> I don't think I've seen that happen before
17:19:47 <FauxFaux> That was an innocent attempt to simplify my bubblesort first time I tried it. =p
17:21:59 <djahandarie> @pl \(a:b:t) -> if a < b then a:bh (b:t) else b:bh (a:t)
17:21:59 <lambdabot> ap ((`ap` tail) . (. head) . ap (ap . (ap .) . ap (ap . (((.) . if') .) . (<)) ((. ((bh .) . (:))) . (.) . (:))) (flip ((.) . (:)) . (bh .) . (:)) . head) tail
17:22:09 <djahandarie> Oops
17:22:11 --- mode: Cale set -o Cale
17:22:17 <Cale> wow, I was still opped :P
17:22:46 <applicative> it's not dangerous is it?
17:23:08 <Cale> no, but it's a needless display of authority
17:23:29 <applicative> i think we're confident in your benevolence
17:23:33 <Cale> :)
17:23:39 * geheimdienst for one hails our calean overlords
17:23:57 <djahandarie> @type fix $ (`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (liftM2 ap .) . ap (ap . (((.) . if') .) . (<)) . flip ((.) . (.) . (:)) . (. (:)) . (.)) ((flip ((.) . (:)) .) . (. (:)) . (.))
17:23:57 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:24:05 <Cale> ffs Blizzard, if you're going to make the game client 7GB, you can at least patch it beforehand, can't you?
17:24:24 <djahandarie> > (fix $ (`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (liftM2 ap .) . ap (ap . (((.) . if') .) . (<)) . flip ((.) . (.) . (:)) . (. (:)) . (.)) ((flip ((.) . (:)) .) . (. (:)) . (.))) [1,5,3,2,4,8,1,3]
17:24:25 <lambdabot>   [1,3,2,4,5,1,3*Exception: Prelude.head: empty list
17:24:28 <djahandarie> lol
17:24:35 * Cale is installing StarCraft 2
17:25:30 <ion> What a lovely expression.
17:25:56 <geheimdienst> "lovely" in the sense of mutant atomic abomination
17:26:20 <djahandarie> Is there a way to make @pl show its steps?
17:26:45 <ion> djahandarie: pointfree -v
17:37:07 <nsmryan> Does anyone know why Data.Vector.Vector is not an instance of Traversable, Applicative, or Monad? Would it violate some axiom or something?
17:37:23 <aavogt> nsmryan: is the size fixed?
17:38:24 <nsmryan> it is not fixed by the type, if thats what you mean.
17:38:33 * roconnor_ doesn't see any reason whay they cannot be instances
17:38:39 <aavogt> nsmryan: this one seems to be http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector.html
17:38:50 <aavogt> I mean it has those instances
17:39:07 * aavogt reads monoid as monad... oops
17:39:54 <roconnor_> what differentiates Vector from List?  A vector is like a list with a strict spine?
17:40:37 <nsmryan> As I understand it is implemented over array.
17:40:48 <roconnor_> the existance of fromList and toList indicate that it is a type isomorphic to lists
17:41:19 <hpc> from the docs, it looks like Vector is a hetero list
17:41:37 <roconnor_> hpc: I don't think that is true
18:05:49 <Cale> There's no particularly good reason for it
18:06:10 <Cale> errr
18:06:40 <Cale> Yeah, the elements of a Vector seem suitably unconstrained.
18:06:51 <Cale> So you should be able to write a Monad instance.
18:07:27 <nsmryan> Yea
18:07:54 <nsmryan> The problem is that I don't know how to make it Traversable without making it into a list, traversing, and then back to a Vector.
18:08:14 <nsmryan> most likely due to my being a newbie
18:09:27 <c_wraith> why do you need it to be Traversable?
18:10:28 <nsmryan> I want to be able to do something like make a vector of Bools and randomly flip them.
18:10:47 <c_wraith> So, you want mapM?
18:11:04 <nsmryan> I realize that that is in Vector
18:11:27 <nsmryan> its more of a design sort of thing, I would like the structures to all be traversable
18:11:35 <nsmryan> thats very true though
18:11:42 <Aune> I need some help with my math: http://hpaste.org/42287/z2_over_z2
18:12:20 <Aune> In "instance num ring" which definition of multiplication should be used?
18:12:31 <c_wraith> nsmryan, I actually wasn't even aware that was in vector.  I'm just wondering what the operations are.
18:14:57 <nsmryan> ah, understood. To answer your question: yes, I want mapM.
18:19:17 <c_wraith> I honestly have no clue why it doesn't present the more generic interface.  But at least the function you want is there.
19:22:08 <phao> Hi
19:22:34 <phao> Functional programming does a lot of creation of new objects. like map, it doesn't modify the list, it creates a new one, kinda updated.
19:22:49 <phao> Does this creation, that happens a lot of time, affects much on the program performace?
19:23:13 <FauxFaux> No.
19:23:33 <medfly> haskell does teh memory management
19:23:46 <phao> right
19:30:12 <Gracenotes> haskell's garbage collection is also fine-tuned for creation and subsequent removal of short-lived objects
19:33:06 <ion> A compiler may even convert some code to modify memory in-place.
19:33:10 <ion> as an optimization
19:40:53 <haole> hello there... i'm working with some small microcontroller devices and i was wondering if it is possible to generate C code from haskell so that i can compile haskell code for them
19:41:03 <haole> not that this would be useful at first, but it would be very cool :D
19:42:04 <tg_zzz> haole: yes, you can compile haskell to C
19:42:19 <mwotton>  haole: jhc might be your best option
19:42:37 <mwotton> I used it a while ago to compile haskell with easy C access points so i could call it from ruby
19:43:00 <mwotton> http://repetae.net/computer/jhc/
19:43:12 <byorgey> haole: you should also check out Atom
19:43:28 <byorgey> http://hackage.haskell.org/package/atom
19:45:47 <haole> very nice tools... now i just need to learn haskell properly! :D
19:46:02 <haole> i'm a scheme programmer... haskell is giving me a hard time, but it is fun
19:46:14 <Figs> Hello. Is there a way to make a list that can contain any instance of a particular type class?
19:46:22 <mwotton> haole: your head's in the right place, then, anyway:)
19:46:42 <mwotton> Figs: HList
19:46:51 <mwotton> but it's a reasonably heavyweight solution
19:47:26 <shachaf> Figs: Existential data types.
19:47:30 <applicative> Figs, why would you want to do this? For its own sake?
19:47:43 <shachaf> Figs: Which type class are you after, though?
19:48:12 <Figs> I was trying to write out an example of something earlier today, and I realized I had a hole in my knowledge regarding lists and type classes. 
19:48:48 <Figs> shachaf: I found several things mentioning that online, but I could not figure out how to get them to work correctly; can you give me an example?
19:48:52 <applicative> > [Show, Monad,Applicative, Eq, Ord]
19:48:53 <mwotton> Figs: let's take "Show" as a test case. you can certainly write a function "showWithCommas :: Show a => [a] -> String"
19:49:30 <mwotton> the list itself has to be homogenous, but you could call it on [1,2,3] or [True, False] etc
19:50:25 <shachaf> Figs: Well, depending on the type class, it might not be necessary.
19:50:40 <Figs> mwotton: I would like the list to be homogenous only on the type class, not on the type itself; ie, I can only use it via the type class methods. So, [1,2,True], for example, provided the only case I am doing is show-ing the elements.
19:51:01 <shachaf> Figs: If all you're doing is show-ing the elements, just use a list of Strings.
19:51:16 <mwotton> Figs: you can do it, but it's not idiomatic.
19:51:18 <FauxFaux> alias foo
19:51:21 <FauxFaux> FUU
19:51:31 <Figs> shachaf: Show is just one example though; what if I have a custom type class?
19:51:50 <Figs> mwotton: What is the idiomatic solution then?
19:52:04 <mwotton> Figs: in general, you put the constraints on your functions instead
19:52:18 <diondion> is there something better than "\x -> [x]" or "flip (:) []"?
19:52:27 <mwotton> it might help if you posted an example of what you wanted to do, then someone could show you the idiomatic version
19:53:07 <byorgey> diondion: return, or (:[])
19:53:29 <diondion> byorgey: ah return, duh, thanks
19:53:44 <shachaf> Figs: For the example you gave, you can do data T = forall a. (Show a) => T a
19:54:17 <shachaf> Then:
19:54:18 <shachaf> λ> map (\(T x) -> show x) [T 1, T 'a']
19:54:20 <shachaf> ["1","'a'"]
19:54:54 <Figs> Ah.
19:55:20 <Figs> I think I see where my mistake was -- thanks.
19:56:51 <Figs> Is there any way to make the T implicit? It seems annoying to have to write it for every item in a list if I am writing a literal list. (I'm assuming the answer is 'no' though.)
19:57:48 <shachaf> map T [1, 'a'], of course. :-)
19:58:17 <mwotton> shachaf: ... ?
19:58:20 <shachaf> (Not as far as I know.)
19:58:31 <mwotton> ah, you were being mischievous:)
19:59:13 <Figs> Why aren't type classes allowed to work like normal types in collections then?
19:59:22 <shachaf> Figs: ?
19:59:55 <shachaf> Figs: Do you mean x :: [Show]?
20:00:02 <Figs> Yes.
20:00:06 <shachaf> Because they aren't types.
20:00:10 <dankna> what would that even do?  heh
20:00:18 <shachaf> What you want is x :: [exists a. (Show a) => a]
20:00:34 <dankna> oh, yeah, that
20:04:02 <Figs> shachaf: Is that supposed to work?
20:04:22 <shachaf> Figs: Not as syntax (well, in GHC).
20:04:44 <shachaf> Figs: But you can enumelate it with forall.
20:04:50 <shachaf> ...emulate. That was odd.
20:06:21 <monochrom> data Hehe = forall a. HeheMe (Show a => a)
20:06:50 <monochrom> then your list type is [Hehe]. an example value is [Hehe True, Hehe 'y']
20:07:36 <shachaf> monochrom: Yep, that's data T above.
20:07:48 <monochrom> example function that takes such a beast: concatMap (\ HeheMe x -> show x) [Hehe True, Hehe 'y']
20:07:50 <shachaf> Figs wasn't happy with the extra constructor.
20:07:58 <monochrom> ok
20:08:20 <monochrom> and can't do map Hehe [True, 'y'], would beg the question :)
20:08:34 <shachaf> monochrom: Of course. :-)
20:08:42 <monochrom> oops some of my Hehe's should be HeheMe's. so, nevermind!
20:09:07 <applicative> Figs, here's a Gadty version, no better in point of extra constructors.  http://hpaste.org/42288/run_it_all_together
20:09:30 <monochrom> yeah, Gadt includes existential type
20:09:46 <applicative> somehow it makes it easier for me to take in
20:10:09 <shachaf> Ah, and if I use that then I don't have to remember whether it's ExistentialQualification or ExistentialQuantification!
20:10:13 * shachaf always messes that up.
20:13:37 <zachk> @src filterM 
20:13:58 <shachaf> zachk: Just what you'd imagine it to be. :-)
20:14:02 <shachaf> lambdabot seems to be dead.
20:14:26 <shachaf> Who killed lambdabot?
20:15:15 <Figs> applicative: That's interesting. Unfortunately, I don't know much about GADTs so I'm not exactly sure what that means.
20:15:46 <Figs> What is "I" in terms of a "data ... where" declaration?
20:15:53 <shachaf> Figs: A constructor.
20:15:57 <shachaf> Figs: With a given type.
20:17:33 <Figs> ok
20:18:18 <Figs> If I added a J :: <some other type> -> Shew after the I :: ... line, would that be another constructor (analogus to data Shew = I ... | J ... | ... ?
20:18:19 <Figs> )
20:18:52 <shachaf> Figs: Yep.
20:19:26 <Figs> Does record syntax work with this?
20:20:25 <shachaf> Figs: http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
20:20:31 <Figs> thanks
20:20:58 <applicative> I'll be darned, even records work.  Shoulda read the docs...
20:21:09 <shachaf> applicative: Yes, but not record updates.
20:21:59 <applicative> ah, 
20:22:16 <applicative> just as well, theyre obviously a concession to Imperativalism!
20:23:14 <Figs> Why aren't type classes types?
20:23:46 <jmcarthur> what values would they by types of if they were?
20:23:51 <shachaf> Figs: Because -- they aren't? They're classes of types.
20:23:51 <jmcarthur> s/by/be/
20:24:34 <shachaf> applicative: I propose to ban the word "update" in this channel, and burn all books that reference "state".
20:24:45 <Figs> They would be wrappers holding a type with operations that can be performed on them given by the definition of the type class that they match. 
20:24:57 <applicative> shachaf, agreed
20:25:12 <shachaf> Figs: So they'd be existential types?
20:25:32 <applicative> Figs, what shachaf said.  Why not have both?
20:25:39 <Figs> They would be like your work around without the annoying additional constructor.
20:26:01 <jmcarthur> i don't really understand the proposal here
20:26:40 <shachaf> Figs: What if you, say, want two type classes at once?
20:26:45 <applicative> Figs, how will the ghc know to reject [1,2,'a']?
20:27:29 <Figs> shachaf: I don't see any issue with that, other than maybe a question of how to notate it.
20:27:33 <shachaf> applicative: Well, you'd have to specify the type explicitly, of course. Just like with "exists".
20:27:45 <Figs> applicative: I assume it wouldn't make sense in context when it tried to match it to a type.
20:28:18 <Figs> jmcarthur: The issue I'm asking is why can't you do map show [1,2,True] to get ["1", "2", "True"]  -- which you'd be able to do if Show was a type.
20:28:20 <shachaf> Figs: An exists keyword seems to make much more sense than what you're suggesting.
20:28:36 <applicative> I guess it could be made to work.  I feel all of my beautiful types are secretly disintegrating in this plan
20:28:50 <applicative> no one shall drive us from the paradise that Haskell has made for us!
20:29:44 <Figs> Internally, the way I've been thinking about type classes is basically as a wrapper, but that doesn't seem to be the case since type classes aren't types, and I'm wondering why they are defined the way they are, preventing you from doing things like map show [1,2,True].
20:30:04 * shachaf goes home.
20:30:05 <_TMP_> hey guys, just a heads up <evancharlton> is going to join and try troll the place
20:30:30 * shachaf wonders if this will still be the topic of discussion when he gets there. :-)
20:31:00 <Olathe> Figs: It might be so that it doesn't have to store the type as data.
20:33:04 <applicative> But Figs, its true there are two bit type classes like Num and Show
20:33:17 <applicative> but the real type classes are Functor, Monad etc
20:33:56 <Figs> Do people normally write type classes of their own when writing Haskell programs?
20:34:20 <tg_zzz> Figs: good question
20:42:09 <Guest71593> in let x = 8 * 10 in x + x does the value of x change to 160 or that the return and x is 80
20:42:48 <monochrom> I don't know what is meant by "the return and x"
20:43:35 <Guest71593> what is in x after I type that in, is it 160 or 80
20:43:45 <monochrom> 80
20:43:56 <Figs> Guest71593: let x = 8 * 10 in x + x would mean that you want the value of x to be 80 (ie, 8*10) in the expression x + x, so the result of the entire expression is (8*10) + (8*10) = 80 and x will not be bound outside of the let.
20:44:01 <Figs> *= 160
20:44:05 <Figs> I can't add heh.
20:44:41 <monochrom> x+x doesn't change x. 5+1 doesn't change 5.
20:45:08 <tg_> Figs: that's one of those cases where it's killer to make a adding mistake :o
20:45:15 <monochrom> if 5+1 changed 5 to 6, the next time you look at 5+1 again it would be 7.
20:45:17 <Figs> yeah it is. :p
20:45:55 <Guest71593> thanks
20:53:07 <Cale> Guest71593: In fact, x is not defined outside the scope of that expression. So after you type that in and the result comes back, x isn't defined.
20:53:44 <Cale> But while the expression is evaluating, x gets evaluated to 80, and remains that value until it is garbage collected.
20:57:09 <Figs> Olathe: Couldn't it just be compiled into an existential type automatically though -- doing whatever it's already doing?
20:57:40 <shachaf> Guest71593: I don't know what you mean by "the value of x change". :-)
21:02:10 <Figs> Cale: I'm having an on-going discussion about types and type classes. (I hope I'm not driving everyone nuts with it....) Can you shed any light on why type classes cannot be used as types, and/or how type classes are typically used in Haskell programs?
21:03:07 <Cale> Figs: Typeclasses aren't types because they are open predicates which types might satisfy, and which types can always be added to by future modules.
21:03:34 <Cale> So it's impossible to assume that there's only one instance of any given typeclass.
21:04:48 <Figs> Cale: But as several people have pointed out to me, you can make an existential type that will do what I am describing, but you must manually write the constructor for each instance of a literal list of that type.
21:05:58 <Figs> I suspect that I have mislearned something about type classes, since I have been thinking about them in a manner similar to interfaces and wrappers, but you can't do something like x :: [Show] .... map show x
21:06:12 <Cale> right, you can't
21:06:32 <Cale> You should think of a typeclass as a sort of condition which a type might or might not satisfy
21:06:52 <Cale> So Show is a property of some types, and perhaps not of others.
21:07:17 <Cale> (Show t) is the assertion that the type t has an instance of Show, and so satisfies that condition
21:08:24 <Figs> Yes, but why not allow collections of things that can be Shown?
21:09:37 <Cale> Figs: Well, initially, because if all you know about something is that it's possible to turn it into a String, it might as well be a String.
21:10:30 <Cale> But it more has to do with what typeclasses do. Typeclasses are all about restricting parametric polymorphism.
21:12:24 <Cale> So...
21:12:38 <Cale> For example, you know about how length :: [a] -> Int
21:13:00 <Cale> We have type variables which let us say "for all types a, this function takes a list of values of type a, and produces an Int"
21:13:14 <Cale> Or, more subtly  map :: (a -> b) -> [a] -> [b]
21:13:43 <Cale> "for all types a and b, this function takes a function from values of type a to values of type b, and a list of values of type a, and produces a list of values of type b"
21:14:12 <Cale> But in some cases we want something like that, but constrained so that the type variables only range over certain types, and not just all types
21:15:08 <mdgeorge1> hello
21:15:28 <mdgeorge1> noob syntax question here: is it possible to mix guards and deconstruction in a pattern?
21:15:51 <axman> with an extrnaion you can use pattern guards
21:16:04 <mdgeorge1> extrnaion?
21:16:06 <Cale> Figs: For example, sort :: [a] -> [a] won't do, because not all types have a sensible definition of comparison operations
21:16:10 <axman> which lets you do foox | Just y <- x = blah
21:16:20 <axman> entension*
21:16:33 <Cale> Figs: So instead of this, we have  sort :: (Ord a) => [a] -> [a]
21:16:38 <axman> foo x*
21:16:52 <Cale> Note how this expresses that the type of input list and type of output list are the same type
21:17:05 <Cale> sort :: [Ord] -> [Ord] wouldn't do either
21:17:14 <mdgeorge1> axman: what I want is something like "foo x:xs | x > 0 = bar"
21:17:22 <Cale> (almost no matter what you'd have it mean)
21:18:17 <mdgeorge1> axman: but that doesn't seem to work
21:19:01 <mdgeorge1> perhaps "foo e | x:xs <- e && x > 0 = bar?
21:19:01 <mdgeorge1> "
21:19:07 <mdgeorge1> that's not as nice :)
21:20:05 <BMeph> mdgeorge1: foo is a function. Tell it you're giving it the whole list: "foo (x:xs) | x > 0 = bar"
21:21:29 <mdgeorge1> BMeph: ah thanks!  that worked
21:21:38 <mdgeorge1> how is it parsing it otherwise?
21:21:43 <mdgeorge1> I mean, it's failing to parse
21:21:57 <Figs> Cale: Suppose you have a graphical situation where you have algorithms to construct representations in terms of some primitive types and and some algorithms for doing the rendering, but you'd like to leave the system open to extension so that you could (later) add support for something like rendering transformations of images (as an example). To me, it would seem natural to try to write something like a Renderable type class and defining algorithms in terms of th
21:22:02 <Figs> How would you handle something like that?
21:22:03 <mdgeorge1> but is it reading it as (foo x):xs ... ?
21:23:05 <turiya> "data Prop w where", what does this line mean? Is Prop a typeclass? 
21:24:52 <Cale> Figs: That's not a bad idea.
21:25:27 <Olathe> turiya: It looks like a type with no instances, probably for type system tricks.
21:26:21 <Cale> Figs: Another approach is to determine exactly what operations your renderable things all have in common
21:26:33 <Cale> Figs: and then just bundle those operations together into a new datastructure
21:28:06 <Cale> Figs: So the values simply become essentially tuples of the results of the various operations as applied to them.
21:28:07 <lispy> turiya: that's using GADT syntax
21:28:17 <Cale> Figs: Does that make sense?
21:28:30 <lispy> turiya: http://en.wikibooks.org/wiki/Haskell/GADT
21:28:44 <Figs> Cale: Which values become tuples of the results of oeprations?
21:28:48 <Figs> *operations
21:29:28 <Cale> Figs: Let's take a concrete example. What operations do renderable things have?
21:30:44 <Figs> For simplicity sake, let's just assume there's only one operation for the time being -- something like draw :: self -> screen -> Action -- Where Action might be an appropriate IO type or some other representation
21:30:45 <turiya> lispy: thanks, will read through the link
21:31:01 <Cale> Figs: okay
21:31:22 <Cale> So just define the type   data Renderable = R { draw :: Screen -> Action }
21:32:25 <Cale> If the only thing you need to know about something is that it's possible to apply draw to it, you can just apply draw to it right away and get that over with :)
21:33:48 <Cale> Does that make sense?
21:34:19 <Cale> Just like in the case with Show -- if all you know about some value is that you can turn it into a String, it might as well be a String.
21:34:35 <Cale> Now, other sorts of operations become more interesting.
21:34:46 <Figs> Yes, it makes sense.
21:35:06 <Cale> For example, what if we want to be able to translate renderable things by some vector, so that they appear in a different location
21:35:09 <Cale> Well...
21:35:21 <Cale> data Renderable = R { draw :: Screen -> Action; translate :: Vector -> Renderable }
21:35:58 <Adamant> how realistic is it for someone with no graphics experience but a decent amount of experience with Haskell to at least get a major start on a simple 3D OpenGL game in three weeks?
21:36:04 <Cale> Note that if you want to define one of these things in terms of some internal datastructure, you can use a function with a parameter to keep track of that structure
21:36:15 <Adamant> in Haskell, of course
21:36:25 <Cale> For instance, let's say, spheres with some radius and centre
21:36:54 <Cale> sphere r c = R { draw = drawSphere r c; translate = \v -> sphere r (c ^+^ v) }
21:37:18 <mightybyte> @pl (\f -> f a b)
21:37:20 <Cale> Or of course, you could pair those r and c together and define them as some new Sphere datatype
21:37:51 <Cale> Figs: how's that? :)
21:38:08 <Figs> Makes sense.
21:38:20 <mightybyte> No lambdabot. :(
21:39:37 <Cale> Figs: But about the other approach, Ralf Lmmel did some videos about the expression problem and solving it with typeclasses in Haskell that you might want to look at.
21:39:57 <Figs> expression problem?
21:40:11 <Cale> (That setting uses an interpreter as the classic sort of place where this problem crops up, but the solution applies equally to many problems)
21:40:37 <Cale> The problem of wanting to be able to flexibly extend both data representations, and the operations which act on those representations independently.
21:41:08 <Cale> You see, my solution to your problem here was to *fix* the set of operations, and this gives us extensibility in terms of representation
21:41:21 <Cale> (which is really the secret idea behind OO)
21:42:16 <Cale> The extensibility which is usually treated as more natural in traditional FP settings is where you fix the data representation and have lots of extensibility in terms of operations.
21:43:09 <Cale> http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem -- here's the video explaining what the expression problem is...
21:44:31 <Figs> I'll take a look at it. Thanks.
21:44:34 <Cale> and I think this is the one where he solves it: http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes
21:50:30 <mdgeorge1> Adamant: I've not done GL programming in Haskell, but I would recommend taking a look at the red book.
21:50:37 <mdgeorge1> for openGL
21:50:41 <danblick> darn you silverlight...
21:50:41 <Adamant> mdgeorge1: thanks :)
21:50:56 <mdgeorge1> of course that's C oriented
21:51:32 <mdgeorge1> but it will tell you how the API works, anyhow
21:52:10 <mdgeorge1> and the important concepts - transformations, the rendering stack, lighting and shading and so on
21:52:48 <Cale> danblick: The video is available in various formats on the right
21:53:30 <danblick> Cale: ah - so it is! thanks for pointing that out.
21:59:59 <danblick> i'd been wondering about where to learn more about how to use typeclasses... i think i understand how they work, but not the "style"
22:34:39 <copumpkin> ddarius: did you survive?
22:37:24 <ddarius> Well enough.
22:37:40 <ddarius> Hopefully you are much drier than you were.
22:38:00 <copumpkin> a little, but my only way to dry things off is radiators and they've decided to take a break today
22:38:16 <copumpkin> with any luck they'll come on during the night and dry off my clothes that are sitting on them
22:38:57 <ddarius> I presume that you have some other clothing which is not also wet.
22:39:24 <ddarius> I also realized that I forgot to show you the picture.
22:39:42 <dibblego> I depend on two packages, which depend on mtl1 and mtl2 -- is there a way around this?
22:39:42 <copumpkin> my main "warm" jacket (before I get my stuff from storage) is the one I was wearing
22:39:45 <copumpkin> so it's rather wet
22:39:53 <copumpkin> ah yeah
22:39:58 <copumpkin> I'll see it next time, I guess :P
22:40:15 <copumpkin> dibblego: I thought mtl2 was a completely separate package, or someone was proposing making it one
22:41:16 <ddarius> copumpkin: I could have brought my trenchcoat.  I've only worn it when ordered to.
22:42:20 <Figs> copumpkin: what happened?
22:42:34 <copumpkin> Figs: ddarius and I walked around Boston in the rain :P
22:42:39 <copumpkin> and got rather damp
22:44:34 <Figs> Ah, I see how that could make you rather damp. Indeed.
22:47:39 <copumpkin> :)
22:47:46 <copumpkin> anyway, bedtime
23:37:36 <danblick> Cale: the talk you mentioned was terrific
23:38:27 <Cale> The lectures with Ralf Laemmel?
23:38:32 <danblick> yep
23:40:17 <Cale> Yeah, I had already known lots about using typeclasses, and I'd known about the expression problem, but I had somehow not put two and two together when I first saw that video, so it was a nice insight for me as well. :)
23:41:02 <lars9> do we care about tail recursion when using haskell?
23:41:25 <rmarch> Cale: is his solution not dependent on using value types as opposed to monadic types?
23:41:49 <rmarch> Cale: that is, if he decides someday to change something to use an IORef, does he have to rewrite the entire code base?
23:41:58 <Cale> rmarch: No...
23:42:28 <rmarch> rmarch: No is ambiguous here and most "solutions" do not take this into account.
23:42:47 <Cale> rmarch: But if he decides to change the types of the operations, he'll have to change the implementations of them
23:42:59 <Cale> Using IORefs is orthogonal.
23:43:16 <rmarch> Well, it's the "types of the operations".
23:43:40 <Cale> I'm not sure what you're getting at... :)
23:43:47 <Cale> You mean replacing a -> b with a -> IO b?
23:43:47 <dibblego> copumpkin, praps it is, but I wish to depend on modules outside of my control
23:44:00 <Cale> That's a very nontrivial change in general.
23:44:25 <dibblego> @type fmap return
23:44:42 <Cale> and there's nothing anyone can do about it -- computations in IO have all sorts of ordering of effects which pure expressions don't express on their own
23:44:48 <rmarch> Cale: I think that's a problem with functional programming. You just don't have that in some other languages, in which yes, you have to give up some other things.
23:44:49 <c_wraith> lars9: sometimes tail recursion matters, but in the cases where it does, strictness matters more.
23:45:03 <Cale> rmarch: But you just don't do that.
23:45:11 <dibblego> rmarch, it's a problem with *programming*
23:45:29 <lars9> c_wraith: i see thanks
23:45:44 <c_wraith> lars9: compare foldl (tail-recursive) to foldl' (tail-recursive and strict in its accumulator)
23:45:47 <rmarch> Cale: if you have to call a C library, it's not that odd that you have to introduce a transformation like that.
23:46:09 <rmarch> Cale: I am talking about something which is highly integrated. 
23:46:23 <dibblego> http://paste.pocoo.org/show/304196/ <-- am I hosed?
23:46:27 <Cale> Oh, for FFI, that's different. You can introduce FFI calls, and take the burden of checking that they're pure on yourself.
23:46:33 <lars9> c_wraith: tail recursion is rarely mentioned in haskell community
23:46:42 <Cale> (by importing them at pure types or using unsafePerformIO)
23:46:51 <lars9> c_wraith: but mentioned a lot in lisp, ocaml
23:46:52 <rmarch> dibblego: yes, you use cabal and expect it to always work.
23:46:58 <Cale> Of course, you really want them to actually be pure, or else things get weird.
23:46:58 <rmarch> dibblego: don't do that. Cabal is a mistake. 
23:47:12 <dibblego> rmarch, like IO values too right?
23:47:30 <rmarch> dibblego: you don't want to argue about Haskell with me.
23:47:33 <Cale> dibblego: Maybe rebuild filemanip
23:47:52 <c_wraith> lars9: because of the way lazy evaluation works, tail recursion often isn't what you want in haskell anyway.  You want laziness instead, where possible.  (returning partial results in such a way that they can be consumed as they're needed)
23:48:07 <dibblego> Cale, that's a bit annoying
23:48:18 <Cale> dibblego: Well...
23:48:25 <dibblego> Cale, so then there will be filemanip-that-depends-on-mtl2.cabal?
23:48:35 <Peaker> rmarch, Cabal simply failed to scale with Haskell's success, and needs to be fixed to replace PVP/version numbers to something better :)
23:48:40 <Cale> dibblego: I just mean  cabal install --reinstall filemanip
23:49:01 <dibblego> Cale, you mean a later version of filemanip uses mtl2?
23:49:08 <Cale> uhhh
23:49:11 <rmarch> Peaker: and it has been said a long time ago that Cabal should have feature detection. 
23:49:24 <rmarch> Peaker: not the version number crap there is now.
23:49:32 <Cale> I'm assuming here that the reason for this message is that filemanip is already installed, but uses the old mtl
23:49:36 <lars9> c_wraith: thanks
23:49:39 <dibblego> Cale, correct
23:49:51 <dibblego> Cale, filemanip depeds on mtl 1.1.*
23:49:55 <Cale> oh
23:49:57 <Cale> that's bad
23:49:59 <Cale> um...
23:50:02 <dibblego> yes
23:50:07 <Cale> Okay, so filemanip needs updating.
23:50:19 <dibblego> so does zip-archive while I am at it
23:50:36 <dibblego> actually that may be fixed with an update
23:51:03 <lispy> Is it valid to say that _|_ = _|_?
23:51:11 <Cale> lispy: yes
23:51:19 <lispy> For example, you're trying to compare two computations
23:51:21 <Cale> Though _|_ == _|_ = _|_
23:51:29 <Cale> ;)
23:51:53 <Cale> Mathematically, x = x for any x
23:51:59 <lispy> like, reverse . reverse . reverse $ xs = reverse xs, because _|_ = _|_ when xs is inifinite?
23:52:02 <mauke> .oO( extensional equality of infinite loops )
23:52:06 <Cale> yeah
23:52:32 <lispy> Oh, heh, now I see what you said above with ==
23:52:52 <lispy> > undefined == undefined -- this is an error
23:52:57 <lispy> ?botsnack
23:53:03 <lispy> hmm
23:53:31 <lispy> Cale: did you shutdown lb?
23:53:36 <Cale> no
23:53:48 <lispy> I don't think she's running
23:54:08 <lispy> $ ps -e | grep lambdabot
23:54:08 <lispy> 18573 pts/1    00:30:47 lambdabot
23:54:15 <Cale> lambdabot is running, but hasn't noticed the disconnection yet
23:54:27 <lispy> ah
23:54:40 <Cale> (It almost never does)
23:54:58 <lispy> lazy bots :)
23:56:48 <Cale> lars9: Our stack means something different from their stack
23:57:38 <Cale> lars9: Tail recursion can be an important technique, but there's no such thing as "tail recursion optimisation" in Haskell. It works because of the way that the lazy evaluator works.
23:58:29 <Cale> However, if you have tail recursion together with parameters which accumulate without being pattern matched or otherwise demanded, you can get into trouble when those giant expressions build up and are returned
23:59:52 <Cale> For example, consider   foo n 0 = n; foo n m = foo (n+m) (m-1)
