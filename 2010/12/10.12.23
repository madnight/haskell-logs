00:00:15 <foocraft> alright, so myth or fact: You only use functional languages to test out ideas.
00:00:29 <Scriptor> er, myth I'd say
00:00:32 <foocraft> (someone told me that when I started learning haskell the first time around, and I couldn't really prove him wrong)
00:00:50 <ivanm> I use haskell for all my code
00:01:00 <Scriptor> at least, no more than python is used just to prototype software before it's implemented in Java/C
00:01:01 <gienah> ok I'm new to haskell, hence qualified to comment: lets consider the visitor design pattern, but oops its not really powerful enough, so lets have the heirarchical visitor pattern to walk over some complex symbol tables or ASTs or something
00:01:06 <ivanm> admittedly, I haven't written all that much recently... :/
00:01:21 <gienah> After staring at that for a while, I thought there must be an easier way.
00:01:32 <gienah> There is: pattern matching in Haskell
00:01:51 <Saizan> yeah, algebraic datatypes are very nice :)
00:03:16 <Saizan> foocraft: btw: http://www.haskell.org/haskellwiki/Haskell_in_industry
00:03:45 <gienah> The visitor design patterns are just so ugly, complex and hard to maintain compared to pattern matching, it is obvious whey Haskell is such a powerful language for implementing compilers, type systems, and lots of stuff
00:04:16 <Axman6> foocraft: where i'm working right this very minute, we're using haskell in production for some very complex financial stuff
00:04:56 <foocraft> so maybe I can give it a try by writing an IRC server
00:05:11 <ivanm> foocraft: might be a tad complicated for an initial app
00:05:21 <gienah> Axman6: yes such an obvious thing to do to use Haskell in that area, I wonder if this is part of a new trend
00:05:48 <foocraft> a TSP approximator, then?
00:05:51 <foocraft> :p
00:06:12 <ivanm> gienah: FP in general seems to be popular for financial stuff, presumably due to the relatively quick development times and the extra correctness found in them compared to C, Java, etc.
00:06:29 <foocraft> hehe I have this book from my brother's class (he's an art student) and this math book has a section titled "easy ways of solving the TSP"
00:06:38 <novascotia> Would anyone be willing to look at a two-line code example and help me find the problem with it?
00:06:45 <ivanm> foocraft: "TSP"?
00:06:45 <gienah> I'd imaging the mathematical notation of haskell may be easier for the quants to understand
00:06:52 <ivanm> oh, right, travelling salesmen
00:07:43 <gienah> s/imaging/imagine/
00:12:00 <novascotia> memoize :: (Integral a, Num b) => (a -> b) -> a -> a -> (a -> b)
00:12:02 <novascotia> memoize f m n = (map f [m..n] !!) . flip (-) m
00:12:25 <novascotia> This fails to compile with a type error "Couldn't match expected type `Int' against inferred type `a'", anyone see why?
00:13:59 <lispy_> :t memoize f m n = (map f [m..n] !!) . flip (-) m
00:14:00 <lambdabot> parse error on input `='
00:14:10 <Saizan> ?ty (!!)
00:14:10 <lambdabot> forall a. [a] -> Int -> a
00:14:11 <lispy_> :t let memoize f m n = (map f [m..n] !!) . flip (-) m in memoize
00:14:11 <lambdabot> forall a. (Int -> a) -> Int -> Int -> Int -> a
00:14:24 <Saizan> novascotia: (!!) expects an Int for the index
00:14:58 <lars9> and you can memo in MemoTrie instad
00:15:34 <novascotia> Ah ok, thanks
00:15:50 <novascotia> The error didn't mention !!, it seemed to occur on the flip instead
00:16:31 <novascotia> And cool I've never seen MemoTrie before
00:17:32 <Saizan> it reports the problem where it finds it, not necessarily where it makes sense to change the code
00:18:28 <novascotia> So it binds it to Int on the left, and then is confused when it's no longer a on the right but instead is Int
00:45:19 <ivanm> preflex: seen dcoutts
00:45:19 <preflex>  dcoutts was last seen on #ghc 16 hours, 2 minutes and 37 seconds ago, saying: dons: btw, re cabal-dev, I think it makes sense to do this stuff directly in cabal-install
01:15:52 <eeeee> whois
01:16:05 <eeeee> ...'
01:51:00 * hackagebot ideas 0.7 - Feedback services for intelligent tutoring systems  http://hackage.haskell.org/package/ideas-0.7 (AlexGerdes)
01:54:01 * hackagebot charsetdetect 1.0 - Character set detection using Mozilla's Universal Character Set Detector  http://hackage.haskell.org/package/charsetdetect-1.0 (MaxBolingbroke)
02:31:09 <Peaker> dead timezone for Haskell...
02:31:33 <earthy> ?
02:31:38 <Peaker> very quiet this time of day
02:31:40 <paolino> meditation
02:31:42 <earthy> h
02:31:42 <Peaker> I tried using Haskell for a bit of signal processing, compared with matlab, and the library situation isn't looking very good :(
02:31:54 <earthy> how so
02:32:06 <Peaker> Even when there are libraries to do stuff (e.g: DSP, hmatrix) they can't agree on stuff like a Vector type
02:32:11 <earthy> ah
02:32:24 <Peaker> I couldn't find a good plotting library, just really annoying-to-use ones
02:32:33 <earthy> yes. there's a bit of an issue there
02:32:36 <Peaker> and it seems to me like a nice purely functional/compositional plotting library should be easy to write
02:32:37 <monadic_kid> if you have a strict record field of list type, will that force the entire list to be head normal form or just evaluate the first element like with seq?
02:32:51 <Peaker> monadic_kid, just the first/WHNF
02:32:57 <Axman6> Peaker: matlab rocks for signal processing though
02:33:15 <Peaker> Axman6, Well, the language sucks bad, they just have a lot of libraries that agree on the basic types
02:33:37 <Axman6> don't use the language, stick to um.... that gui thing they have
02:33:46 <earthy> one of the issues is that efficient vectors are a reasonably recent lib for haskell
02:33:53 <Axman6> bugger, what is it called
02:34:09 <monadic_kid> that means i'm going to have to define NFData instances for anumber of types :/
02:34:19 <Peaker> earthy, There's Data.Packed.Vector in hmatrix, and it is an array but doesn't expose a Data.Array if you need one, so I have to go through list to get an Array for the dsp library
02:34:23 <Axman6> hmm, i reckon that iteratees would be quite useful for signal processing
02:34:31 <Peaker> monadic_kid, there are auto-derivers for that
02:34:43 <Peaker> monadic_kid, http://hackage.haskell.org/packages/archive/derive/0.1.1/doc/html/Data-Derive-NFData.html
02:35:01 <Peaker> http://hackage.haskell.org/package/derive-2.4.1  is a better link, google finds old hackage stuff
02:35:21 <monadic_kid> Peaker: nice, yeah google results tend to be older versions of packages
02:35:34 <Peaker> Maybe hackage should always put a version bar on top or such to make clear what version of the library you're looking at and easily jump to the new version without going through "Contents"
02:36:51 <monadic_kid> I spent most yesterday struggling with my function being to lazy, have to get out the deep heat, er  i mean deepseq 
02:37:20 <Peaker> laziness can be painful, yeah :)
02:38:10 <Peaker> It helps programmers separate semantics from model of execution, though..  "Kept Haskell Honest" in this way
02:38:37 <monadic_kid> Peaker: I had a lot of arguments with various people telling me that wasn't an issue with lazyniess that made function not evaluate anything but a bug in my code
02:38:53 <Peaker> monadic_kid, that is a possibility.. can you show the code?
02:39:01 <monadic_kid> Peaker: then i have other people telling me other wise
02:40:37 <monadic_kid> Peaker: i had a number of people look at it, Saizan had look just straight said he/she was surprised that anything was being evaluated at all, I'm using fclabels a lot so I wasn't deconstructing anything, i tried all various combinations of seq, !, $! it wasn't enough
02:41:10 <monadic_kid> Peaker: the best i go do with deepseq is get the first element evaluated
02:41:34 <monadic_kid> Peaker: sorry I meant the best i can do without deepseq is get the firs element evaluated
02:42:09 <Peaker> monadic_kid, can you paste the code again?
02:42:53 <monadic_kid> Peaker: okay, I just need to sort it out again because i've been messing around with it
02:44:22 <Peaker> github! :)
02:46:42 <monadic_kid> Peaker: i have a github account but i usually start with a local repo and  when i finish(esh) then I make in public, but it would be better if didn't work like that
02:47:55 <monadic_kid> Peaker: ah it looks like it was there from yesterday still: http://haskell.pastebin.com/xSt8xfUF
02:49:15 <monadic_kid> Peaker: nextEnemy is the culpret, "modL entities (map updateAnim) gd", (map updateAnim) the map is never evaluated
02:50:00 <monadic_kid> Peaker: then i swapped to use [f x | !x <- xs] which made the first element get evaluated.
02:50:38 <Peaker> monadic_kid, Is your problem a performance thing or a semantic thing?
02:50:53 <monadic_kid> Peaker: not performance
02:51:05 <Peaker> monadic_kid, Why do you care what gets evaluated then?
02:52:05 <Peaker> @hoogle modM_
02:52:05 <lambdabot> No results found
02:52:09 <Peaker> monadic_kid, what's modM_?
02:52:11 <monadic_kid> Peaker: i've been through this already :) I care because at a higher level i have stateful computations because the function never get (fully) evaluated I never see state changes
02:52:14 <Peaker> fclabels?
02:52:49 <monadic_kid> Peaker: modM_ is my action which is like fclabel's modM but takes an action instead of a pure function
02:53:13 <Peaker> monadic_kid, where is it defined? not in that paste
02:53:13 <monadic_kid> Peaker: modM_ = getM >>= act >>= setM
02:53:49 <monadic_kid> Peaker: yeah I pasted everything, which definition are you looking for?
02:53:57 <monadic_kid> Peaker: i mean haven't pasted everything
02:54:04 <Peaker> got it, looking..
02:56:58 <Peaker> modM_ lab act = getM lab >>= act >>= setM lab
02:57:01 <Peaker> right?
02:57:05 <monadic_kid> Peaker: yep
02:58:01 <Peaker> monadic_kid, maybe if you can paste something that compiles...
02:58:55 <monadic_kid> Peaker: that might take some time to do
02:58:59 <paolino> monadic_kid: in my little experience with genetic simulations , a (rnf state `seq` newTurn) has been unavoidable to control space leaks, and make things happen
03:00:34 <paolino> and I believe games have natural unevaluated thunks hanging around , waiting for events they will probably never happen
03:02:02 <monadic_kid> paolino: the problem I'm getting is with timer event system i have which stores a pure function which in a Map and gets called at certain intervals, this map is stored in a record used in monad transformer stack (in state monad)
03:02:17 <paolino> and a rnf state happening at slow pace with some correct NFData instances is much better to see in the code that all those ugly !
03:04:24 <monadic_kid> paolino: the function registered in particular, uses fclabels, there is no deconstruction going on in the function (except for tuples) and then I get barely anything evaluated, nested traversal of lists that aren't get fully evalauted
03:04:48 <Peaker> monadic_kid, but you said your problem isn't a performance problem, but that things don't do what you expect
03:04:56 <Peaker> monadic_kid, if that's the case, I don't understand why you care about evaluation at all
03:06:07 <monadic_kid> monadic_kid: yep i'm not trying fix performance problem, I'm trying to figure out why my computations aren't being fully evaluated when at some point structures do get probed every frame
03:07:17 <paolino> monadic_kid: NFData is there to control evaluation, what is the problem with it ?
03:07:34 <monadic_kid> paolino: no problem, i'm just about to use it lol
03:08:39 <monadic_kid> paolino: i was just whining about having to implement instances for various records but Peaker told me about derive package which should allow me to use generalize derives?
03:09:40 <paolino> I've only written them by hand, to use `par`. Not sure how deriving is done
03:10:19 <monadic_kid> on  a related note, why are there two deepseq libraries, one is minimal and doesn't defin $!! while the other is part of an xml package
03:10:40 <monadic_kid> :t ($!!)
03:10:40 <lambdabot> Not in scope: `$!!'
03:10:50 <paolino> anarchy
03:11:15 <monadic_kid> :t (Control.Strategies.DeepSeq.$!!)
03:11:15 <lambdabot> Couldn't find qualified module.
03:12:57 <Axman6> hmm, would anyone have a problem with adding "Jon Harrop is a douchebag" to http://haskell.org/haskellwiki/Great_language_shootout ? He loves linking to it on stackoverflow whenever the shootout is mentioned, i believe to show how pathetic Haskell is
03:14:13 <monadic_kid> Axman6: on average over all the benchmarks & platforms combined haskell is in a good position :http://shootout.alioth.debian.org/fastest-programming-language.php
03:14:27 <Axman6> indeed
03:14:41 <Axman6> but, Jon Harrop is a douchebag
03:15:11 <Axman6> i'm not even quite sure why he keeps linking there, but being JHD, he must have some shitty motivation
03:16:10 <monadic_kid> Axman6: yeah i know and yeah i think he always has a motivation, probably in terms of money lol
03:16:23 <Axman6> aye
03:16:57 <Phyx-> Haskell war?
03:17:22 <Adamant> why limit yourself to mild insults like "douchbag"
03:17:35 <Phyx-> i keep getting this when installing packages
03:17:39 <Phyx-> Warning: Cannot read C:\ghc\ghc-7.0.1\lib/../doc/html/libraries/time-1.2.0.3\time.haddock: Interface file is of wrong version: C:\ghc\ghc-7.0.1\lib/../doc/html/libraries/time-1.2.0.3\time.haddock
03:17:44 <Phyx-> never seen that before..
03:17:44 <Entroacceptor> why feed the trolls
03:17:45 <Axman6> oj, i'm open to ideas :)
03:18:02 <Phyx-> (and repeat for every version)
03:21:53 <Adamant> Axman6: "Money can't buy Jon Harrop non-douchebaggery"
04:01:17 <etpace> > fix error
04:01:18 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
04:03:30 <monadic_kid> so if i want to the use derive package with template haskell i just need to write $( derive makeNFData ''MyType )
04:03:30 <monadic_kid> ?
04:07:41 <monadic_kid> I really hope Habbit language (or something like it) with macro system becomes popular in my industry one day but I can't imagine it
04:10:42 <Eduard_Munteanu> Are zippers good for mutable trees? I'm particularly interested in mutating structure, more than node values.
04:11:23 <Eduard_Munteanu> Like swapping two subtrees in a binary tree.
04:13:28 <monadic_kid> Eduard_Munteanu: I've never used them but if i remember correctly than can do that, hey are like cursors/iterators
04:14:24 <monadic_kid> Eduard_Munteanu: i might be wrong though
04:15:45 <Eduard_Munteanu> It seems to me swapping might require hacking the context.
04:16:38 <monadic_kid> Eduard_Munteanu: yeah i think so, just looking at the zipper monad
04:16:39 <Eduard_Munteanu> Maybe I should use a tree of IORefs / STRefs?
04:17:59 <monadic_kid> Eduard_Munteanu: although reading this: http://www.haskell.org/haskellwiki/Zipper
04:17:59 <Eduard_Munteanu> They're more like comonadic...
04:18:14 <Saizan> what's wrong with just swapping the subtrees?
04:18:52 <monadic_kid> that's a good point too lol
04:19:09 <Eduard_Munteanu> How exactly? :)
04:19:22 <Eduard_Munteanu> monadic_kid: yeah, but that mutates one point of focus.
04:19:48 <Eduard_Munteanu> Having reached two different locations in a tree (i.e. having two zippers), how do I swap the current locations?
04:19:57 <Saizan> case tree of (Branch l r) -> Branch r l; ..
04:20:00 <monadic_kid> Eduard_Munteanu: clearly I'm not the right person so I should shut up :)
04:20:20 <Eduard_Munteanu> monadic_kid: thanks for trying to help, though :)
04:21:22 <Eduard_Munteanu> Saizan: well that's trivial, but what if I'm navigating the tree with zippers? I can't write it out that way.
04:21:44 <Eduard_Munteanu> I reach location A, I reach location B, want to swap them.
04:22:19 <Eduard_Munteanu> Like, I have two points of focus.
04:23:05 <ManateeLazyCat> Wow, charsetdetect, the package i want to! :)
04:24:20 <Eduard_Munteanu> swap :: Zipper a -> Zipper a -> Zipper a
04:24:30 <Eduard_Munteanu> (the result could be 'Tree a' too)
04:25:17 <Eduard_Munteanu> where Zipper a = ([Ctx a], Tree a)
04:25:30 <Saizan> isn't that trivial too?
04:27:01 <Eduard_Munteanu> Saizan: swap (ca, a) (cb, b) = ... ? If I simply write there (ca, b), I don't think it does it.
04:27:26 <Eduard_Munteanu> (the a is overwritten by b, but it's not swapping)
04:27:39 <Saizan> you also want a to appear in the position individuated by cb?
04:27:41 <Eduard_Munteanu> So I assume 'ca' must change as well.
04:28:04 <Eduard_Munteanu> Saizan: yes.
04:28:22 <Saizan> do you need this for arbitrary positions?
04:28:44 <Eduard_Munteanu> Yeah, I kinda do.
04:29:00 <Eduard_Munteanu> I'm implementing an adaptive Huffman algo, I think it's Vitter's variant.
04:30:06 <Eduard_Munteanu> And zippers make sense as some sort of trees with backlinks (I'm going to have a Map of the leaves)
04:32:01 <Eduard_Munteanu> Currently I settled on data Tree a = Leaf a | Fork a (Tree a) (Tree a)
04:32:10 <Saizan> it seems like you'll have to "unzip" then follow cb down to where you need to put a
04:33:11 <Saizan> or i guess you could try finding a common prefix of ca and cb first, which you can leave untouched
04:33:23 <Eduard_Munteanu> Ah, replace a by b, backtrack to the top, follow b's context, replace b by a?
04:33:30 <Saizan> yep
04:33:38 <Eduard_Munteanu> I see, thanks.
04:33:41 <Eduard_Munteanu> It's kinda ugly though :)
04:33:59 <Eduard_Munteanu> (but I guess it's the same with swapping in lists)
04:34:51 <Eduard_Munteanu> I wonder if there's a Seq analog of trees.
04:35:36 <Eduard_Munteanu> (or I could just try and use refs)
04:36:18 <Saizan> i don't think anything can be uglier than refs
04:36:44 <Saizan> *something (?)
04:39:02 <Saizan> btw, the second derivative could give you a zipper with two holes
04:39:11 <Phyx-> Ugliness is in the eye of the coder
04:39:21 <Saizan> never worked with them though
04:39:58 <Saizan> sure, some coders have better eyes than others though :)
04:41:45 <Saizan> (refs have plenty of uses, but making a datastructure with refs at every node is something i've seen only from newly converted ML programmers :)
04:42:52 <Eduard_Munteanu> Saizan: hm, nice, two points of focus could be helpful
04:43:14 <ManateeLazyCat> Saizan: Yes, i can't smell bad code after long time with my own code.
04:45:00 <Twey> Saizan: ‘Anything’ it is
04:45:12 <Twey> Hrmph
05:22:41 <Phyx-> Anyone have a link to the documentation on the cabal Paths_<project> file?
05:22:47 <Phyx-> i can't seem to find it again
05:26:50 <Phyx-> ah nvm
05:43:25 <wires> (How) can one show the definition of something in ghci ?
05:43:46 <mauke> generally, you can't
05:45:06 <alpounet> wires, you may try :info though
05:45:34 <wires> alpounet: so for methods this only shows the type.. i'd like to see the definition if source is available
05:45:46 <alpounet> methods ?
05:45:51 <alpounet> you mean function in typeclasses 
05:45:51 <alpounet> ?
05:49:09 * hackagebot language-javascript 0.0.2 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.0.2 (AlanZimmerman)
05:49:30 <jedai> wires: you can try to install leksah, it allows you to consult the source of most modules on your system
05:49:46 <wires> alpounet: yes, functions
05:50:07 <alpounet> wires, see what jedai said (hi jedai btw)
05:50:15 <wires> jedai: alright.. but then I'm in a full IDE ?
05:50:24 <alpounet> or consult the source code on the haddock documentations
05:50:43 <alpounet> http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base-4.3.0.0/Data-List.html -- see the "Source" links there
05:51:25 <wires> alpounet: ah, yeah, so can I maybe show haddock help strings inside ghci ?
05:52:08 <wires> so the source links you mention are very usefull, but if would be much quicker if one can directly see them in ghci
05:52:55 <exDM69> I should have shown the great programming language shootout to my ex-coworkers at a "scientific computing" company. They were all using fortran, primarily due to legacy, but they didn't either know haskell or felt that it was something slow, academic and useless. Haskell/GHC is #8, the best Fortran is #10
05:53:54 <exDM69> varies a bit on which comparison you look, sometimes haskell is a bit higher or a bit lower but it's always higher than the best fortran
05:56:36 <alpounet> wires, maybe there's been some work done on this but i haven't really checked
05:56:47 <alpounet> i only use ghci to test my modules 
05:57:06 <alpounet> so my basic use is :load myfile.hs, and then just calling my functions, etc
05:58:57 <Eduard_Munteanu> Or you can install lambdabot locally.
06:01:51 <wires> alpounet: I use it in a similar way, but sometimes I quickly want to check what defined functions look like while prototyping new functions, etc
06:01:51 <wires> Eduard_Munteanu: lambdabot can tell me definitions?
06:02:06 <Jafet> @where goa
06:02:06 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
06:02:26 <Jafet> I've never tried goa, I'm straight edge.
06:02:58 <Entroacceptor> great, I just searched for an error message and found... myself asking that question in here, three months ago
06:03:10 <Entroacceptor> obviously I had solved it, btu don't know how
06:03:32 <Phyx-> ghc-pkg expose ghc
06:03:40 <Phyx-> err. since when did this window get focus
06:04:13 * hackagebot SBench 0.1 - A benchmark suite for runtime and heap measurements over  a series of inputs.  http://hackage.haskell.org/package/SBench-0.1 (DanielSeidel)
06:04:28 <Eduard_Munteanu> wires: yes.
06:04:29 <Eduard_Munteanu> @src foldl
06:04:30 <lambdabot> foldl f z []     = z
06:04:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:04:38 <wires> Jafet: thanks... I somehow missed that
06:04:57 <Phyx-> is GHC.Paths no longer in ghc?
06:05:03 <Phyx-> how do you get the libdir now?
06:05:44 <Phyx-> ah i need ghc-paths
06:05:45 <Phyx-> whoops
06:12:34 <Phyx-> boy my syb is rusty..
06:13:14 <mauke> boy my syb ys rusty  -- now with a y in every word
06:13:41 <Phyx-> heh
06:13:46 <Jafet> scrpyrvwls
06:14:28 <Phyx-> @where
06:14:28 <lambdabot>  @where <key>, return element associated with key
06:16:52 <mauke> @time A4R0NL3WI5
06:16:53 <lambdabot> Local time for A4R0NL3WI5 is Thu Dec 23 22:16:25 2010
06:18:57 <Phyx-> anyone know how the unit type is depicted in Haskell-Src-Exts? as a TyCon "()" or TyTuple Boxed []
06:21:29 <benmachine> TyCon (Special UnitCon) or something I think
06:21:34 <benmachine> parse one and find out :P
06:21:45 <Phyx-> yeah, I just did it, ehehe
06:21:50 <Phyx-> was too lazy at first
06:22:02 <Phyx-> and yeah you're right
06:22:02 <Phyx-> (TyCon (Special UnitCon))
06:33:13 <Renze> Good afternoon!
06:34:18 <Renze> I've got a question about plain Haddock comments: I'd like to use some comments which aren't meant for any function or module, but just as a decription of a heading. Is this possible? Because '-- text' only works if there's a function or module after it...
06:35:36 <benmachine> a description of a heading?
06:35:42 <benmachine> like a subsection in a module?
06:37:29 <Renze> No, like: -- * Exercise 4: ... \n -- |The solution of this exercise is in exercise4.pdf
06:39:56 <Phyx-> time to see if it compiles..
06:42:36 <benmachine> Renze: are the sections like you get in here: http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Control-Concurrent.html#7 sort of like what you want?
06:42:55 <Renze> Yes!
06:43:03 <Eduard_Munteanu> I don't think so, even GHC docs for primitives are generated from stubs.
06:43:16 <benmachine> Renze: look at the source for that module, then :P
06:43:28 <Renze> Yes I'm doing that already, thanks :)
06:53:40 <rumbold1> how do i know what a package must be called in the build dependencies in leksah? for example, data.vect had to be called just vect (i dunno how i knew that), now i want to add Codec.Image.DevIL, but i dont know what to write there
06:54:07 <mauke> uh, I think you have to use the package name
06:54:19 <mauke> which has nothing to do with the modules it contains
06:54:22 <benmachine> rumbold1: well, usually if you try to compile without adding it, ghc will tell you which package was missing
06:54:36 <benmachine> but you can also find it using ghc-pkg find-module
06:54:49 <benmachine> or sometimes hoogle will help
06:55:03 <benmachine> @hoogle Codec.Image.DevIL
06:55:03 <lambdabot> No results found
06:55:07 <benmachine> or sometimes not
06:55:18 <rumbold1> oh yeah, it said i have to use Codec-Image-DevIL
06:55:22 <rumbold1> thanks
06:58:41 <rumbold1> eh, still doesnt work
07:02:00 <Phyx-> hmm it compiles
07:02:02 <rumbold1> oh, i still had ghci activated and Codec.Image.DevIL has that problem where it cant use pthread because its a script or something
07:02:03 <Phyx-> but will it run..
07:08:38 <Phyx-> when using GetOpt, is it possible to format the description field of options? my fields seem a bit too long...
07:08:59 <Phyx-> like http://phyx.pastebin.com/rX684Fhv
07:22:39 <Peaker> Can manual memory management be proven safe reasonably with dependent types or such?
07:23:01 <benmachine> I guess it depends a little on what you think is safe
07:23:16 <benmachine> you could possibly come up with some kind of proof that every allocation was eventually deallocated
07:23:49 <benmachine> but I imagine trying to prove something like "maximum residency doesn't get huge" would be horribly subjective
07:23:52 <Peaker> benmachine, No pointers remaining to released objects, no unreleased unreachable objects
07:24:02 <benmachine> oh
07:24:06 <benmachine> I don't know
07:24:12 <Peaker> I want the things GC guarantees with Manual MM
07:24:52 <benmachine> well there are regions, aren't there
07:24:58 <benmachine> but I don't know how well they work
07:25:26 <Peaker> I am really bothered by GC wasting work reconstructing knowledge you often have when developing, and of the inherent performance problems when the working sets grow larger
07:25:55 <Peaker> And I do manual memory management with the C I write (which is a lot right now) and mm problems are really some of the rarest bugs we have, so I am unconvinced GC is a net win
07:25:58 <Eduard_Munteanu> Dependent types can eliminate bounds checking and provide guarantees, that's a little related.
07:26:35 <Eduard_Munteanu> I'm not convinced either, despite the marketing aroung GC these days.
07:27:21 <Eduard_Munteanu> *around
07:27:42 <p_l|backup> Peaker: I think certain level of assurance is possible, especially if you take extra care to do allocation mostly on stack
07:27:53 <benmachine> Peaker: I'm not show what a functional language with MM would actually look like exactly
07:28:24 <benmachine> Peaker: I also wish there were functional languages with more predictable memory behaviour
07:28:37 <benmachine> but on the other hand, if you write a GC then you write it to be intelligent
07:28:56 <benmachine> possibly even more so than a human doing the management themselves will usually be
07:29:21 <Eduard_Munteanu> Why exactly do we need GC in Haskell (and such languages) again?
07:29:37 <Peaker> benmachine, All the GC schemes I've seen don't seem anywhere near as good/simple as doing almost everything with stack allocations, and almost everything else as O(1) pool allocations
07:29:49 <Eduard_Munteanu> (well not GC, but automatic memory management like GC and region inference)
07:30:08 <Peaker> Eduard_Munteanu, First, I think it eliminates a class of bugs (unreachable objects still allocated, or reachable objects being freed)
07:30:33 <Peaker> Another reason is that it is simpler at the semantic level to just say "all objects exist forever"
07:30:37 <benmachine> yeah
07:30:38 <Eduard_Munteanu> Well that's true, but why do we really need it in Haskell?
07:31:06 <kingping> mapM_ hello haskell
07:31:14 <benmachine> return hi
07:31:18 <kingping> :-D
07:32:11 <Eduard_Munteanu> On the other hand I still think it's wise to restrict pointer arithmetic.
07:32:34 <Eduard_Munteanu> Aliasing analysis can enable lots of optimization.
07:33:32 <benmachine> yes
07:33:44 <Eduard_Munteanu> (that's why we have 'restrict' in C99 though)
07:33:44 * ManateeLazyCat Watch the video that Joe Armstrong and SPJ talk about Erlang and haskell. ....
07:33:57 <benmachine> Eduard_Munteanu: can you actually imagine what manually managed haskell would look like?
07:34:35 <Eduard_Munteanu> Not really, I don't actually understand the semantics of memory management in Haskell, or rather its interactions with syntax.
07:35:09 <benmachine> well, the language haskell doesn't have operational semantics as such
07:35:18 <Eduard_Munteanu> What would be really nice is rebindable memory management.
07:35:26 <Peaker> I do a lot of "top-down" allocations in C now, where the allocation is done by the caller of an API rather than the API itself
07:35:47 <benmachine> Peaker: mm, that kind of makes sense, except when only the API knows how much it will need
07:35:49 <Peaker> so you pass an opaque object as an "allocation" to the API. This is analogous to passing a "proof" that the memory is available :)
07:36:23 <Eduard_Munteanu> I'm not sure how laziness affects the possibility of MM.
07:36:24 <Peaker> benmachine, Well, it is really really common that the API needs some "per-operation" memory that can be allocated this way.  If it needs more memory, it can allocate it and point to it from the "per-operation" memory
07:36:56 <benmachine> Peaker: but if it does the latter then surely it needs to free it later?
07:36:57 <lispy_> This is a brand new clean install of ghc7
07:36:59 <lispy_> http://dpaste.com/289839/
07:37:03 <Peaker> I love the idea of passing all computational resources (cpu/memory) as erased arguments to functions
07:37:07 <lispy_> What's up with all the missing libs?
07:37:16 <Peaker> benmachine, Yeah, and it will explicitly do so
07:37:28 <Peaker> benmachine, but the life-span of the user-provided allocation is simply documented
07:37:42 <Bynbo7> whoot! my first actually useful iteratee code! :D
07:37:52 <Eduard_Munteanu> Peaker: you're decoupling initialization/destruction from allocation, but does it usually make sense?
07:38:01 <Bynbo7> http://www.reddit.com/r/haskell/comments/epmhk/reimplemented_tee_in_haskell_in_a_few_lines_for/c1a3ojz
07:38:05 * Bynbo7 is proud
07:38:25 <Eduard_Munteanu> Usually the callee returns an opaque, so it makes sense to do the allocation in the callee.
07:39:00 <Peaker> Eduard_Munteanu, They're still coupled, just more loosely.  If you have:  my_api__start_op(opaque_op_context *); my_api__stop_op(opaque_op_context *);   then the caller allocates (opaque_op_context *) and the start_op inits it
07:39:01 <Eduard_Munteanu> That way you don't need API/ABI stability.
07:39:43 <Eduard_Munteanu> Peaker: then the caller needs to know its size. It can only do so at compile-time, so you'll most likely have to recompile if the internal representation changes.
07:39:44 <Peaker> Eduard_Munteanu, well, C really wants sizeof() to be very statically known, but a language like C could allow for variable-sized things to live in structures/etc, and get that size from some place
07:40:20 <Eduard_Munteanu> (unless you also provide apis for get_opaque_op_context_size())
07:40:44 <Peaker> Eduard_Munteanu, I want it allocatable on the stack, as a nested member in my allocation, and so forth
07:41:00 <Peaker> Eduard_Munteanu, C can't do it well without recompiling when sizeof() changes. Currently we just use the recompile approach
07:41:28 <Peaker> Eduard_Munteanu, a nice thing about this approach, is that most modular code can just wrap some object with its own, and put the lower allocation in its own, but defer the allocation upwards to its caller
07:41:40 <Eduard_Munteanu> Any particular reason why you prefer the stack? I'm pretty sure those objects have a very narrow lifespan then.
07:41:55 <Eduard_Munteanu> Oh.
07:41:57 <Peaker> Eduard_Munteanu, such that you end up with only the top-most layer doing any allocations, and a single allocation allocates everyone's data, and it also gets rid of a *lot* of error handling (because only the top has a potential allocation error)
07:42:14 <benmachine> Bynbo7: awesome
07:42:24 <Bynbo7> :D
07:42:49 <benmachine> I'm trying to pick up iteratees again
07:42:57 <Eduard_Munteanu> Peaker: I guess it makes sense if you can do it.
07:42:59 <benmachine> you're right about the using being easier than understanding
07:44:04 <Peaker> Eduard_Munteanu, It makes C much more fun, almost all error codes disappear and everything's a happy success-only void func :)
07:44:39 <Bynbo7> benmachine: yeah, definitely. Michael Snoyman's tutorials on using the enumerator package help a hell of a lot though
07:45:01 <benmachine> oh right
07:45:04 <Eduard_Munteanu> Yeah, no more -ENOMEM.
07:45:05 <benmachine> I was looking into enumerator
07:45:09 <Peaker> Eduard_Munteanu, It's nice to be able to reason about much fewer actual allocs/de-allocs, because they're all deferred upwards, and you eventually have one allocation/deallocation per-non-stack-life-span, and non-stack life-spans are few and far between...
07:45:28 <benmachine> just because iteratee didn't seem to have good mechanisms for dealing with UTF8
07:45:41 <benmachine> I was very surprised that an encoding/decoding enumeratee wasn't easy to find
07:45:42 <Bynbo7> benmachine: enumerator is a lot easier to use, but iteratee has more functions defined
07:45:47 <benmachine> does anyone know of one I might have missed
07:46:08 <Eduard_Munteanu> Peaker: I'm still not sure how you'd know the allocation needs beforehand. It seems you have to.
07:46:32 <Eduard_Munteanu> Like if some deeply nested function needs to build up a tree.
07:46:45 <Eduard_Munteanu> You probably don't know how much memory to allocate at top-level.
07:46:54 <Peaker> Eduard_Munteanu, What do the tree elements represent?
07:47:12 <Peaker> Eduard_Munteanu, Each time the caller does X, a tree element is added --> opportunity for caller to provide resources
07:47:34 <Peaker> Eduard_Munteanu, This is related to intrusive data structures, btw, if you want to be able to put caller-provided allocations in data structures
07:48:17 <Eduard_Munteanu> Ah, you mean the caller has to be able to throttle / unfold the computation at its will.
07:49:16 <Eduard_Munteanu> Actually I think this is a bit like returning continuations.
07:49:40 <Bynbo7> benmachine: enumerator seems to be much more lenient (sp?) about the types you can have in streams (ie, you get Chunks with lists of whatever yupes you want)
07:50:28 <benmachine> Bynbo7: iteratee does have a string chunk thing but it doesn't work properly I think
07:50:31 <benmachine> well
07:50:35 <benmachine> it gives you ascii, fine
07:50:44 <benmachine> but it gets the buffer size wrong
07:51:01 <Bynbo7> :\
07:51:04 <gwern> which iteratee? I think there must be a dozen implementations now
07:51:14 <Bynbo7> the iteratee package
07:51:19 <Peaker> enumerators is taking over isn't it?
07:51:24 <Bynbo7> there's only really two implementations
07:51:29 <gwern> it's arrays all over again!
07:51:37 <Bynbo7> Peaker: well i hope so, it's got much better naming
07:51:50 <Peaker> gwern, What?
07:51:58 <Peaker> as in: array, vector, bytestring, etc?
07:52:12 <earthy> enumerator seems easier to deal with, yes
07:52:13 <gwern> @quote arrays
07:52:13 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
07:52:15 <gwern> @quote arrays
07:52:15 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
07:52:18 <gwern> @quote arrays
07:52:18 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
07:52:19 <Bynbo7> they all serve different purposes :\
07:52:22 <gwern> oh wtf
07:52:39 <earthy> uvector... 
07:52:42 <gwern> I do that in privmsg and the first 4 are my quote; I do it in #haskell and three are the other quote!
07:52:49 <gwern> @quote best.arrays
07:52:49 <lambdabot> gwern says: Haskell has the best arrays around; problem is, we don't know which module it is.
07:52:53 <Bynbo7> earthy: uvector is dead, long live vector
07:53:10 <earthy> ghe
07:53:17 <Peaker> answering "what are arrays, really?" is much easier than answering what monads are, really, though :)
07:53:36 <Eduard_Munteanu> Is anybody asking that question? :)
07:53:42 <copumpkin> Peaker: what's an array?
07:54:15 <earthy> really? :)
07:54:28 <Bynbo7> gwern: what's the problem with having array, vector and bytestring? they're all designed for very different purposes (well, vector and array are somewhat similar)
07:54:31 <Peaker> copumpkin, a data structure containing an ordered sequence of mutable cells that can read/write these cells by index, with O(1) time-complexity 
07:54:51 <copumpkin> Peaker: yeah, but it doesn't really fit our model of most datastructures
07:54:53 <gwern> Bynbo7: you are in a maze of twisty sequence-types, each alike
07:54:55 <Bynbo7> Peaker: so Array isn't an array?
07:55:08 <copumpkin> everything else in haskell is a sum of products of other types (possibly including functions)
07:55:09 <gwern> it is dark out. you are likely to be GCed
07:55:10 <Bynbo7> gwern: thank you?
07:55:20 <Peaker> Bynbo7, I guess "Mutable" should just be optional there
07:55:29 <Bynbo7> Peaker: yeah :)
07:55:46 <Eduard_Munteanu> The grim collector? :P
07:56:10 <Bynbo7> hey, does anyone think that if i made an entry for the binary-trees benchmark on the shootout that used an array to represent the tree they'd allow it?
07:56:12 <Peaker> copumpkin, well, functions are special, for sum/product approach you need unit too
07:56:14 <gwern> Eduard_Munteanu: of course. he certainly isn't chuckling as he stops the world
07:56:19 <Eduard_Munteanu> This reminds me of the GC in the linux kernel...
07:56:20 <Bynbo7> because, i'm going to give it a go
07:56:23 <copumpkin> Peaker: yeah, sure, I just mean we have algebraic types
07:56:35 <copumpkin> and functions are "infinite products" or exponents :P
07:56:43 <Eduard_Munteanu> Of course, the OOM killer.
07:57:02 <benmachine> copumpkin: functions don't have to be infinite do they?
07:57:08 <Peaker> the OOM killer has never made a senseful decision IME :)
07:58:55 <gwern> I like the OOM killer. it's so stupid it's brilliant
07:59:49 <benmachine> I imagine it as like a troll in a cave
07:59:49 <Eduard_Munteanu> Most stupid GC ever :P
08:00:01 <benmachine> that comes out when the village is having a riot and just bops people on the head until they stop
08:00:05 <benmachine> and then goes back in again
08:00:37 <Eduard_Munteanu> Actually this reminds me of Lenore.
08:00:52 <unkanon_> E. A. Poe's?
08:00:57 <Bynbo7> ha, oh wow, OOM killer is awesome
08:01:12 <sipa> the rare and radiant maiden whom the angels name lenore
08:01:14 <sipa> ?
08:01:27 <Eduard_Munteanu> unkanon_: yeah, I've seen the cartoons
08:01:58 <unkanon_> quoth the raven: nevermore
08:02:17 <unkanon_> nameless here forever more, I should've said.
08:02:39 <gwern> benmachine: well, so it's like real life - the pigs come out during a riot and just lay about until there's no more riot
08:03:11 <gwern> unkanon_: who, Lenore?
08:03:14 <gwern> (oops)
08:05:04 <unkanon_> heh
08:05:19 <Eduard_Munteanu> This, actually... http://en.wikipedia.org/wiki/Lenore,_the_Cute_Little_Dead_Girl
08:05:26 <Eduard_Munteanu> Inspired from Poe's stuff.
08:05:55 <Eduard_Munteanu> (the animations)
08:12:25 <byorgey> copumpkin: we're definitely planning on having another hac phi this summer
08:12:32 <copumpkin> byorgey: awesome :)
08:24:51 * hackagebot temporal-media 0.1.0 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.1.0 (AntonKholomiov)
08:29:13 * digitteknohippie is more than just giddy with excitement, his christmas present arrived today, Real World Haskell!   WOOHOO!
08:29:37 <sshc> How am I supposed to close an X connection with XHB?
08:30:10 <byorgey> digitteknohippie: =)
08:32:13 <sshc> xhb doesn't seem to export any disconnect function
08:32:49 <Bynbo7> disconnecting would be a side effect!
08:32:53 * hackagebot csound-expression 0.2.0 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.2.0 (AntonKholomiov)
08:33:14 <exDM69> sshc: is there a bracket like function or does it rely on finalizers?
08:36:55 * hackagebot cabal-dev 0.7.3.2 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7.3.2 (RoganCreswick)
08:42:03 <sshc> exDM69: It doesn't even seem to foreign import disconnect, it seems from grepping its source
08:42:20 <copumpkin> I like that GHC now suggests corrections to typos if you type an identifier it doesn't recognize
08:42:27 <exDM69> sshc: can you find any examples and look what they do?
08:42:52 <exDM69> sshc: you can use LD_PRELOAD to verify that the disconnect function is/is not called
08:43:08 <digitteknohippie> ooh, how long has it been doing that copumpkin?   since which version, do u know?
08:43:19 <copumpkin> digitteknohippie: as of yesterday, in GHC HEAD: )
08:43:30 * digitteknohippie facepalms
08:44:46 <monochrom> oh god
08:45:04 <kurtharriger> hey all, I'm been working through a tutorial (http://learnyouahaskell.com/syntax-in-functions) and trying to figure out how to define functions that use pattern matching in gchi
08:45:32 <byorgey> kurtharriger: short answer: you can't.
08:45:35 <monochrom> let { f 0 = True; f n = f (n-1) }
08:45:35 <kurtharriger> he uses  lucky 7 = "yes..." \n lucky  x = "too bad..."
08:45:44 <byorgey> kurtharriger: define them in a file and then load the file into ghci with :load
08:45:54 <byorgey> kurtharriger: then each time you change the file you can just type  :r  to reload it
08:45:59 <sshc> exDM69: How would I use LD_PRELOAD?
08:46:15 <kurtharriger> in a file it works just wanted to reduce the edit compile run loop
08:46:36 <byorgey> kurtharriger: the edit-compile-run loop is pretty short using :r .
08:46:39 <exDM69> sshc: you write a small library that contains the offending functions and tell LD_PRELOAD to use the functions from your dummy lib instead of the proper one
08:46:43 <monochrom> EclipseFP reduces the edit compile run loop
08:46:49 <kurtharriger> let { lucky 7 = "yeah"; lucky _ = "too bad" }
08:46:58 <kurtharriger> thanks monochrom
08:47:12 <exDM69> sshc: google for a tutorial, it's too long for me to explain in IRC
08:47:15 <sshc> exDM69: Huh, it's actually not a C binding
08:47:17 <monochrom> actually emacs haskell mode does too
08:47:26 <exDM69> sshc: it's not?
08:47:40 <exDM69> sshc: is it a haskell lib that's generated from the XCB specs
08:48:38 <monochrom> the pattern is that reducing the edit compile run loop requires stepping away from 1970s terminals.
08:49:31 <monochrom> I wonder what manatee offers in this regard :)
08:49:36 <kurtharriger> I'm using textmate now, and I think it has a bundle as well but I'm just getting started
08:49:42 <sshc> exDM69: Only the Foreign libraries are imported
08:49:52 <kurtharriger> I really need to learn emacs better though
08:50:45 <ManateeLazyCat> monochrom: Don't worried, i have cooler feature.
08:51:17 <sshc> kurtharriger: I use vim for what it's worth
08:51:21 <exDM69> sshc: yeah, but LD_PRELOAD the function in the XCB C lib
08:51:29 <ManateeLazyCat> monochrom: I have interview tomorrow, hope can pass, then i can have a peace heart on manatee develop. :)
08:51:38 <jkff> Hi. Is there a way to abort an STM transaction, discarding all the changes it has done so far?
08:52:00 <jkff> I do not want to use "retry" because I don't want to retry - just abort and that's all
08:52:27 <roconnor> @type accumL
08:52:27 <lambdabot> Not in scope: `accumL'
08:52:30 <roconnor> @hoogle accum
08:52:31 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
08:52:31 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
08:52:31 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap accumFM :: Ord a => FiniteMap a b -> a -> (b -> b -> b) -> b -> FiniteMap a b
08:52:33 <ManateeLazyCat> monochrom: In the near feature, will have crazy IDE features add in Manatee, so don't worried it. :)
08:52:44 <roconnor> @hoogle+
08:52:45 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
08:52:45 <lambdabot> Data.Generics.Twins gmapAccumM :: (Data d, Monad m) => (a -> e -> (a, m e)) -> a -> d -> (a, m d)
08:52:45 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> e -> (a, q)) -> a -> d -> (a, [q])
08:52:52 * ManateeLazyCat Now i just limit by job thing....
08:53:12 <kurtharriger> I use vi as my light weight editor, but I haven't really learned to effectively work across multiple files in vi
08:53:38 * ManateeLazyCat Like music : "In my secret life".... so sweet...
08:53:48 <roconnor> @type mapAccumL
08:53:49 <lambdabot> Not in scope: `mapAccumL'
08:53:59 <roconnor> @type Data.List.mapAccumL
08:53:59 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:54:07 <roconnor> @src Data.List.mapAccumL
08:54:07 <lambdabot> Source not found.
08:54:22 <ManateeLazyCat> kurtharriger: vi is fastest editor for single file edit, but i think emacs is faster if do "integrate" work. :) 
08:54:44 * monadic_kid has a rageface after figuring out the bug that's been deluding him for th past 1 day 1/2
08:54:50 <monochrom> jkff: I wonder if "check" aborts
08:55:30 <jkff> monochrom: alas, it doesn't
08:55:33 <jkff> check b = if b then return undefined else retry
08:55:37 <monochrom> I use vi to edit config files all the time.
08:56:02 <jkff> monochrom: maybe I can throw something and do `orElse` return ()
08:56:32 <ManateeLazyCat> monochrom: I like vi's h/j/k/l idea, shortest finger move.
08:56:41 <benmachine> by vi do we mean vim
08:56:45 <benmachine> (just checking)
08:56:50 <monadic_kid> i'm glad i pursued deep-heat to figure it out
08:56:53 <monochrom> vi/m :)
08:57:10 <benmachine> I use vim
08:57:11 <benmachine> for everything
08:57:32 <benmachine> but I don't particularly defend that as the best choice
08:58:00 <benmachine> it might be, but learning all the alternatives to find out might not be more productive than just getting better at vim
08:58:48 <monochrom> on windows I use notepad++ lately
08:59:59 <jkff> monochrom: Whoohoo, seems to work
09:00:17 <digitteknohippie> gedit, geany, or in a hurry, leafpad or mcedit.  aint found my ONE editor yet.
09:00:46 <monochrom> nice. orElse does promise a lot. "if the first action retries, then the second action is tried in its place"
09:01:14 <monochrom> my ONE editor is a fountain pen
09:01:35 <monochrom> it's purely functional too. no mutation. :)
09:02:02 <benmachine> heh
09:02:14 <digitteknohippie> sounds worthy... does it have syntax hilighting for haskell?   ;D
09:02:24 <dskippy> Is there a function to get the first element of a list matching a predicate?
09:02:33 <monochrom> no but it has -XUnicodeSyntax or something
09:02:41 <dskippy> myFunc :: (a->a) -> [a] -> Maybe a
09:02:45 <digitteknohippie> lmao
09:02:51 <benmachine> dskippy: yes, but that signature is wrong
09:03:06 <dskippy> flip myFunc ?
09:03:07 <dskippy> :)
09:03:08 <benmachine> dskippy: think about what that first argument does
09:03:15 <dskippy> a->Bool
09:03:17 <dskippy> Right
09:03:18 <benmachine> right
09:03:27 <benmachine> @hoogle (a -> Bool) -> [a] -> Maybe a
09:03:27 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:03:27 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
09:03:27 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:03:28 <dskippy> My mistake. Any... what's the function called?
09:03:29 <benmachine> tada
09:03:42 <dskippy> Oh man I can search by type?
09:03:46 <benmachine> you can :)
09:03:53 <benmachine> there's an online version too which fetches more results
09:04:03 <dskippy> Wow, is there a webpage I can do that on so as not to annoy IRC with my search?
09:04:10 <dskippy> You are way ahead of me.
09:04:26 <benmachine> well you can also PM lambdabot
09:04:34 <benmachine> or hell, just annoy us
09:04:37 <benmachine> that's what we're here for
09:04:42 <zaphar_home> so  can anyone recommend a haskell dag library?
09:04:54 <benmachine> I actually can't remember where hoogle is
09:04:58 <benmachine> @where hoogle
09:04:58 <lambdabot> http://haskell.org/hoogle
09:05:06 <unkanon_> monochrom: fountain pens memory leak sometimes
09:05:06 <benmachine> oh I guess that would be it
09:05:33 <ManateeLazyCat> @where lambdabot
09:05:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:05:34 <JeroenDL_> Does anyone here have some Mercury skills ?
09:07:24 <Jesin> @unpl const join
09:07:24 <lambdabot> (\ _ c -> c >>= \ b -> b)
09:07:45 <unkanon_> kurtharriger: you can define functions with pattern matching in ghci without a problem
09:07:57 <unkanon_> kurtharriger: I've no idea why they told you you can't
09:08:05 <unkanon_> you don't need {} either
09:08:22 <unkanon_> I do it all the time, just do: let f 0 = True; f n = f (n-1)   (to use monochrom's example)
09:09:05 <kurtharriger> unkanon_: yeah figured it out from monochrom  example
09:09:13 <monochrom> oh, no one says it can't be done. some people just discourage it, that's all.
09:09:24 <kurtharriger> though :r is actually not to bad way to go 
09:09:35 <unkanon_> 11:45 < byorgey> kurtharriger: short answer: you can't.
09:09:50 <monochrom> that's what "short answer"s are for :)
09:10:16 <unkanon_> "you can't" != "it's convoluted" or whatever
09:10:18 <monochrom> "hi I want IO a -> a" "short answer: you can't" :)
09:10:30 <unkanon_> I'd expect a short answer of "you can't" to be sparing me of the details why
09:10:34 <kurtharriger> its not obvious from tutorial, found let syntax on stack overflow and could do normal functions but hadn't seen the let {} till now
09:10:44 * ManateeLazyCat haskell expert don't answer "IO a -> a" , haha :)
09:10:47 <unkanon_> kurtharriger: you don't need those {}
09:11:29 <unkanon_> I mostly write function solely on ghci and when they're working I transfer them to vim
09:12:07 <Endiannes> Is there a standard haskell function that generates all unique permutations? (combinations) I know you can generate the permutations and then filter them, but that seems very inefficient.
09:12:20 <Jesin> umm
09:12:31 <unkanon_> > permutations "abcd"
09:12:32 <lambdabot>   ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","bdc...
09:12:38 <Endiannes> Thats not combinations.
09:12:40 <monochrom> permutations are unique. there is no filtering needed
09:12:41 <Jesin> can't you get "IO (a -> a)" pretty easily with "return"
09:12:50 <Endiannes> *Sigh*
09:12:54 <Endiannes> http://en.wikipedia.org/wiki/Combination
09:12:54 <kurtharriger> unkanon_: okay guess it works without the {} using ; but I couldn't use two let statements
09:12:57 <unkanon_> Endiannes: you had said permutations?
09:12:58 <aristid> > permutations "112"
09:12:59 <lambdabot>   ["112","112","211","121","211","121"]
09:13:05 <aristid> > nub $ permutations "112"
09:13:05 <lambdabot>   ["112","211","121"]
09:13:06 <unkanon_> Endiannes: you said permutations twice in fact
09:13:07 <Endiannes> unkanon_, Unique permutations as in combinations...
09:13:16 <monochrom> putting "combinations" in parentheses initially is really clarifying, yeah.
09:13:38 <Jesin> unique permutations are not the same as combinations
09:13:38 <unkanon_> then just do as aristid, does that work for you?
09:13:40 <Jesin> :p
09:13:43 <unkanon_> oh then no :P
09:13:44 <benmachine> sarcasm in a text-only medium is super-helpful :P
09:13:55 <monochrom> Jesin: but I meant ((IO a) -> a)
09:13:58 <tromp> @src permutations
09:13:58 <lambdabot> Source not found. Take a stress pill and think things over.
09:13:59 <Jesin> ah
09:14:07 <Endiannes> Well aristids method should work, I'm just not sure if it will be efficient enough, I'm going to check..
09:14:17 <aristid> Endiannes: but that's not combinations either
09:14:19 <benmachine> Endiannes: remind me, are "123" and "321" distinct combinations?
09:14:22 <unkanon_> tromp: although it says source not found, it is a Data.List function
09:14:24 <benmachine> oh they aren't are they
09:14:33 <benmachine> or are they
09:14:33 <ManateeLazyCat> @time 
09:14:34 <lambdabot> Local time for ManateeLazyCat is Fri Dec 24 01:14:06 2010
09:14:39 <aristid> @time
09:14:40 <lambdabot> Local time for aristid is Thu Dec 23 18:14:13 2010
09:14:42 <ManateeLazyCat> @time monochrom
09:14:43 <lambdabot> Local time for monochrom is 3.1415926535897932384626433832795028841972
09:14:43 <unkanon_> anyone care to give an example of what combinatiosn are?
09:14:50 <aristid> hahaha
09:14:55 <ManateeLazyCat> :)
09:15:00 <aristid> monochrom lives in pi spacetime
09:15:14 <benmachine> hmm
09:15:15 <ManateeLazyCat> @time benmachine
09:15:17 <lambdabot> Local time for benmachine is Thu Dec 23 17:14:48 2010
09:15:21 <Endiannes> unkanon_, [1,2] [1,3] [2,3] would be combinations of [1,2,3] in a sequence of size 2.
09:15:26 <aristid> @time lambdabot
09:15:26 <lambdabot> I live on the internet, do you expect me to have a local time?
09:15:52 <unkanon_> Endiannes: oh i've seen that being solved here not long ago
09:16:01 <monochrom> Endiannes has cited wikipedia's http://en.wikipedia.org/wiki/Combination and so let's all just stick to strictly that
09:16:18 <lispy> aristid: on lambdabot's server, date says: Thu Dec 23 17:15:29 UTC 2010
09:16:21 <Endiannes> unkanon_, Do you still have the solution? I tried to do it myself, but my functional programming is bad :(
09:16:22 <unkanon_> > subsequences [1,2,3]
09:16:22 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
09:16:38 <aristid> lispy: so lambdabot lives in UTC, like all good bots :)
09:16:43 <lispy> aristid:  :)
09:16:50 <unkanon_> > filter ((\x -> (length x == 2)))  subsequences [1,2,3]
09:16:51 <lambdabot>   Couldn't match expected type `[[a]]'
09:16:51 <lambdabot>         against inferred type `[a1] ->...
09:16:56 <unkanon_> > filter ((\x -> (length x == 2))  subsequences [1,2,3]
09:16:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:17:06 <unkanon_> > filter (\x -> (length x == 2))  subsequences [1,2,3]
09:17:06 <lambdabot>   Couldn't match expected type `[[a]]'
09:17:06 <lambdabot>         against inferred type `[a1] ->...
09:17:07 <aristid> unkanon_: add $
09:17:07 <ManateeLazyCat> @time lispy
09:17:12 <unkanon_> > filter (\x -> (length x == 2)) $  subsequences [1,2,3]
09:17:12 <lambdabot>   [[1,2],[1,3],[2,3]]
09:17:19 <unkanon_> aristid: haha that's it, thanks
09:17:29 <unkanon_> Endiannes: ^^
09:17:46 <aristid> @src subsequences
09:17:46 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:17:55 <unkanon_> aristid: but it is in Data.List
09:18:09 <aristid> unkanon_: yea
09:18:22 <unkanon_> http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base-4.3.0.0/src/Data-List.html#subsequences
09:18:25 <Endiannes> unkanon_, Thanks, thats it.
09:18:25 <aristid> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#subsequences
09:18:32 <Jesin> @pl \x -> (length x == 2)
09:18:32 <lambdabot> (2 ==) . length
09:18:32 <gwern> copumpkin: so, you mean HEAD ghci is finally catching up to lisp repls from the 70s with DWIM correction?
09:18:33 * ManateeLazyCat I try to sleep 4 hours ago, but can't sleep, can sleep now. Bye all, G'night. :)
09:18:43 <unkanon_> Endiannes: awesome!
09:18:46 <aristid> good night ManateeLazyCat
09:18:47 <copumpkin> gwern: I guess :)
09:18:53 <ManateeLazyCat> aristid: Bye. :)
09:19:03 <Endiannes> unkanon_, I tried doing it for an hour with overly complicated ways and failed ._.
09:19:05 <Jesin> I think (2 ==) . length is actually a bit more elegant here though the output of @pl often isn't
09:19:18 <gwern> copumpkin: gosh. imagine what kind of ghci we'll have in 2020
09:19:36 <benmachine> @time partycat
09:19:37 <lambdabot> Local time for partycat is party time!
09:19:56 <benmachine> that was totally worth it
09:19:56 <unkanon_> Endiannes: I usually just come here and ask if what I'm trying to do is starting to get complicated
09:20:04 <jmcarthur> actually, (2 ==) . length is not all that elegant if elegance depends on efficiency
09:20:11 <unkanon_> Jesin: yeah I like that better too
09:20:23 <unkanon_> @time unkanon_ 
09:20:26 <lambdabot> Local time for unkanon_ is Thu Dec 23 12:20:13 2010
09:20:38 <gwern> benmachine: but isn't it always party time?
09:20:39 <Jesin> [12:19:37]	<jmcarthur>	actually, (2 ==) . length is not all that elegant if elegance depends on efficiency
09:20:41 <Jesin> umm
09:20:44 <Jesin> how's the lambda form any better?
09:20:48 <aristid> jmcarthur: can't GHC optimise that?
09:20:49 <benmachine> gwern: locally to party cat, yes
09:20:50 <jmcarthur> neither are efficient
09:21:00 <jmcarthur> aristid: not really
09:21:09 <Jesin> you just don't like that solution at all, then?
09:21:12 <jmcarthur> > length [1..] == 2
09:21:12 <aristid> well, using subsequences is not the efficient solution obviously
09:21:16 <lambdabot>   mueval-core: Time limit exceeded
09:21:29 <unkanon_> yeah that's obvious
09:21:35 <Endiannes> aristid, Its stil better thsan my stupid filtering method.
09:21:36 <aristid> jmcarthur: oh, you refer to that. that's also true
09:21:43 <unkanon_> but programmer time > machine time in $$
09:22:03 <aristid> unkanon_: depends on the problem
09:22:16 <unkanon_> what's a good counter example?
09:22:39 <Endiannes> unkanon_, The haskell compiler? :P
09:23:17 <unkanon_> I'm not even sure about that
09:24:09 <Endiannes> Hmm
09:24:53 <unkanon_> one can always wait a little longer for a program to do something, but not to ship a product
09:25:02 <Endiannes> It seems you cant use the subsequence filtering method to generate combinations with repetitions.
09:25:37 <unkanon_> Endiannes: CTRL+F for "subsequences" here and look around, you might find some useful stuff: http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base-4.3.0.0/Data-List.html
09:25:49 <unkanon_> otherwise I'm going on lunch now, brb guyses
09:43:39 <jmcarthur> unkanon_: you can't always wait a little longer for a program to do something. there are many hard real time systems that demonstrate that
09:44:53 <test423432> I have a question: let's say I have a datatype of Maybe, that has only Just a and Nothing, well if I try to do it as follows f a | a == Nothing (this works, but if I try the following |a == Just b, then it kind of fails.
09:46:58 <Ilum> Any leksah  users here?
09:47:30 <copumpkin> test423432: you have no b there
09:47:37 <copumpkin> test423432: you're using guards where you should be using pattern matching
09:47:50 <copumpkin> instead of f a | a == Nothing, just write f Nothing
09:48:04 <copumpkin> instead of f a | a == Just b, write f (Just b)
09:48:10 <copumpkin> f Nothing = 1
09:48:21 <copumpkin> f (Just b) = b + 3
09:48:32 <copumpkin> Num a => Maybe a -> a
09:49:26 <monadic_kid> ILum: yep
09:49:29 <monadic_kid> Ilum: yep
09:52:21 <Ilum> monadic_Kid: What do you like most about it?
09:56:55 <monadic_kid> ILum: integrates well with the cabal package methodology, gives you UI for editing cabal files which makes nice not to have to remember all the fields and looking at the docs all the time, a module/package browser, functionality that inegrates with ghci but I have problems with leksah when using ghci alot. ghci tends to crash a lot under leskah, at least on my machine
10:00:41 <monadic_kid> Ilum: so I can't use ghci but i can still use shortcuts to build and run cabal packages
10:01:34 <monadic_kid> Ilum: it does tend to slow you down because of the compile-times since I can't just reload the file in ghci to check for compile errors
10:01:58 <Ilum> monadic_kid: Do you run it on linux or windows?
10:02:21 <monadic_kid> Ilum: linux, and i'm using linux in a virtual machine on windows
10:03:27 <tonkman> Is it possible to clear WinGHCi's old entrys
10:03:56 <monadic_kid> Ilum: i forgot to mention there is background compile/interpretation support but like i was saying this makes ghci crash very easily so i don't do it
10:05:10 <monadic_kid> Ilum: and if i remember correctly when you do get compile errors you'll get that zigg-zag underline feature like eclipse
10:07:35 * hackagebot fclabels-monadlib 0.0.1 - MonadLib monadic interface for the "fclabels" package.  http://hackage.haskell.org/package/fclabels-monadlib-0.0.1 (BardurArantsson)
10:07:38 <monadic_kid> Ilum: there is a visual debugger using ghci but i haven't used that feature yet
10:10:21 <monadic_kid> Ilum: i've been using leksah for sometime now, before that I was using eclipse-fp
10:11:47 <hoknamahn> looks like code.haskell.org is down?
10:12:09 <aristid> better to announce when code.haskell.org is UP :p
10:12:21 <hoknamahn> that would be awesome
10:12:48 <hoknamahn> i need a kde "code.google.org is up" plasmoid
10:21:19 <lispy> hoknamahn: try again
10:21:22 <lispy> should be back up now
10:21:41 <hoknamahn> sweeeeeeeet
10:21:44 <hoknamahn> thanks a lot!
10:21:59 <lispy> hoknamahn: thank SyntaxNinja if you see him :)
10:22:11 <hoknamahn> okay i will!
10:22:37 <gwern> "I remember a funny dinner at  my brother's, where, amongst a few others, were Babbage and Lyell, both of whom liked to talk. Carlyle, however, silenced every one by haranguing during the whole dinner on the advantages of silence. After dinner Babbage, in his grimmest manner, thanked Carlyle for his  very interesting lecture on silence." --Charles Darwin, Autobiography
10:23:27 <murilo> hi
10:23:34 <Twey> gwern: Haha
10:23:36 <murilo> what is this?
10:23:52 <murilo> someone from Brazil?
10:24:01 <gwern> murilo: it is the depths of despair
10:24:10 <Twey> This is madness!
10:24:16 <gwern> it is the Turing Tarpit, where everything is possible and nothing easy
10:26:24 <zmbmartin> Anyone here have some opinions of haskell web frameworks. Which should I look at or try?
10:26:41 <murilo> well, I need to work
10:26:44 <murilo> see you soon friends
10:26:58 <murilo> This is Spartaaaa!!
10:27:03 <Twey> Snap is shiny and new.  Happstack is an ancient, time-tested horrorterror.
10:27:17 <stepcut> Twey: i heard that..
10:27:24 <Twey> Horse looks interesting.
10:27:34 <Twey> Haven't played with that one, though.
10:27:39 <gwern> oh come on, Horse? now you're just making them up
10:27:49 <c_wraith> gwern: haskell on a horse is real.
10:27:52 <Twey> And the fact that its page yields a 500 doesn't seem encouraging
10:27:54 <c_wraith> and baffling :)
10:28:08 <gwern> next you'll tell him to try some loli
10:28:12 <Twey> gwern: http://webcache.googleusercontent.com/search?q=cache:w9WYvU_q3pIJ:haskell.on-a-horse.org/
10:28:58 <stepcut> Twey: happstack is, in fact, very fine >:(
10:29:28 <Twey> A very fine, ancient, crusty horrorterror.
10:29:50 <stepcut> Twey: horrorterror ?
10:29:50 <gwern> it works reasonably well for gitit...
10:30:24 <gwern> stepcut: I think it's a synonym for horrorshow
10:30:25 <c_wraith> mightybyte, you joined to get in on this conversation...  As an author of both happstack and snap, you must have some comments :)
10:30:40 <Twey> stepcut: MSPA reference
10:30:51 <stepcut> Twey: a term of endearment ?
10:31:00 <Twey> Cthulhu, for example, is a horrorterror.
10:31:11 <mightybyte> c_wraith: I'm too biased to comment.
10:31:31 <mightybyte> (and I'm not really a significant contributor to happstack)
10:31:45 <c_wraith> ah, ok.  I didn't realize your contributions there were minor.
10:32:15 <hoknamahn> guys, leksah-server says: leksah-server: Can't find package.conf as /usr/lib64/ghc-6.12.3/inplace-datadir/package.conf
10:32:32 <hoknamahn> can you tell how that file supposed to be created?
10:32:50 <hoknamahn> i don't even have inplace-datadir directory
10:33:14 <mightybyte> But I can certainly answer questions. :)
10:33:19 <stepcut> Twey: I find your arguments unconvincing
10:33:36 <hoknamahn> hey SyntaxNinja, thanks for restarting a server!
10:33:39 <Twey> stepcut: That would be because I haven't made any yet
10:33:47 <stepcut> Twey: i know
10:33:52 <Twey> Alright then.  ☺
10:35:04 <gwern> mightybyte: actually, I was thinking of writing a site to learn lipreading - transclude youtube videos of people speaking, the user enters in their guesses to a field or perhaps clicks buttons, the score is tracked, and there's a daily review where particular videos are selected (based on spaced repetition) for review; which would be better for such a site?
10:35:52 <Twey> stepcut: I'm sure happs(tack) is perfectly reasonable if you like it.  I found it incredibly difficult to get started with, and the entire infrastructure to be extremely inconvenient compared to Snap's much simpler, friendlier model.
10:36:13 <Ilum> is it possible to have a type which implements only some, but not all, of the functions defined in a type class?
10:36:19 <stepcut> Twey: what is something that is simpler about snap that you like ?
10:36:23 <Twey> But like I said, it's time-tested, so I daresay it's much more dependable than most of the newer frameworks
10:36:59 <mightybyte> gwern: That's an awfully broad question.
10:37:19 <gwern> it was an awfully broad discussion to begin with; my awfully broad question is still much narrower
10:37:20 <Twey> stepcut: I find the API much nicer.  Having just one monad for everything really simplifies the mental acrobatics required to get to grips with it.  I had a lot of trouble even following the types for happstack.
10:37:49 <stepcut> Twey: but snap now has MonadSnap which allows for multiple monads?
10:38:09 <stepcut> Twey: MonadSnap  is pretty much like ServerMonad ?
10:38:48 <Twey> stepcut: But ServerMonad isn't the only thing going on in happstack
10:39:01 <stepcut> and ServerPart is like the Snap monad
10:39:30 <Twey> You've got things like ServerPartT and WebT and FilterT…
10:39:50 <stepcut> Twey: WebT and FliterT are internals that are (no longer) exposed in userland
10:40:16 <paolino> > 0.01
10:40:17 <lambdabot>   1.0e-2
10:40:34 <paolino> is there a way to show it as 0.01 ?
10:40:46 <Endiannes> > "0.01"
10:40:46 <lambdabot>   "0.01"
10:40:56 <Twey> > printf "%.2f" 0.01
10:40:57 <warzl> "0.01"
10:40:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:40:57 <lambdabot>    `Text.Printf.PrintfType ...
10:40:59 <benmachine> :t showFFloat
10:40:59 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
10:41:09 <benmachine> > showFFloat Nothing 0.01 ""
10:41:09 <lambdabot>   "0.01"
10:41:11 <Twey> > printf "%.2f" 0.01 :: String
10:41:12 <lambdabot>   "0.01"
10:41:21 <Twey> That too
10:41:24 <Twey> stepcut: Noted
10:41:32 <benmachine> printf is dark magic :P
10:41:43 <benmachine> not the fun kind
10:41:44 <monochrom> using dark matter
10:41:45 <stepcut> Twey: essentially, anywhere you see, (ServerMonad m, ...) => .. -> m a, you can just replace m with ServerPart 
10:42:04 <exDM69> I still don't get how haskell's printf works
10:42:14 <Twey> stepcut: Or Monad m => ServerPartT m?
10:42:17 <paolino> @hoogle showFFloat
10:42:18 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
10:42:18 <Botje> exDM69: evil dark voodoo magic
10:42:18 <benmachine> exDM69: with lots of type classes, and without any static guarantees
10:42:24 <byorgey> @type printf
10:42:24 <lambdabot> forall r. (PrintfType r) => String -> r
10:42:32 <benmachine> but in haskell98, apparently
10:42:33 <Twey> Not *lots* of typeclasses…
10:42:38 <benmachine> ok at least two
10:42:38 <exDM69> although C printf is almost as ugly
10:42:43 <Twey> It's not that terrifying
10:42:46 <SyntaxNinja> hoknamahn: no problem.
10:42:49 <benmachine> exDM69: uglier!
10:42:52 <Botje> exDM69: http://okmij.org/ftp/Haskell/vararg-fn.lhs
10:42:54 <benmachine> but it's C so that doesn't count :P
10:42:56 <Twey> There are, I think, two typeclasses
10:42:57 <Botje> that's the basic idea
10:43:16 <benmachine> Twey: and zero static guarantees :P
10:43:20 <ion> Just have a function that takes a format parameter and returns a function of proper type based on the format parameter and call it printf. Then do some stabbing with types you can read from the source.
10:43:39 <benmachine> ion: you can't choose the type of the function based on runtime data
10:43:41 <exDM69> benmachine: on the elf64 binary format it's undoubtably uglier
10:43:45 <stepcut> Twey: yes, (MonadIO m) => ServerPartT m, would be a valid substitution as well
10:43:58 <ion> benmachine: That would be the stabbing with types. :-)
10:44:07 <exDM69> elf64 + varargs = painful
10:44:07 <benmachine> so you have to return something which can be any kind of function
10:44:17 <benmachine> which is a little bit devious
10:44:27 <benmachine> and also means that a lot of things that shouldn't typecheck will
10:44:49 <monochrom> > Text.Printf.printf "%d" "hello"
10:44:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:44:50 <lambdabot>    `GHC.Show.Show a'
10:44:50 <lambdabot>      a...
10:44:56 <monochrom> > Text.Printf.printf "%d" "hello" :: String
10:44:57 <lambdabot>   "*Exception: Printf.printf: bad argument
10:45:13 <stepcut> Twey: if you look at the crash crouse, I show the types in both the more general and more specific forms so you can understand the type more easily, and get used to reading the generalized types, http://happstack.com/docs/crashcourse/RqData.html#rqdata
10:45:18 <stepcut> Twey:  for example 'look'
10:45:42 <stepcut> I need a better color scheme though for the black background :-/ 
10:46:50 <Twey> stepcut: Nice
10:48:32 <paolino> thanks
10:48:40 <stepcut> Twey: happstack 6 should be significantly easier to understand. It has been refactored so that the internals are not leaking into the user-level API, and the documentation is much better
10:49:07 * paolino is first importing Numeric
10:52:11 <Twey> stepcut: That's good to hear ☺  Is it out now?
10:52:54 <freedrull> im having trouble building crypto http://hpaste.org/42518/crpytobuildfail
10:52:56 <subleq> main = getArgs >>= (\args -> sequence $ map (>>= putStr . unlines . (map reverse) . lines) (map readFile args))
10:53:05 <unkanon_> is printf the function that most breaks rules or something?
10:53:17 <subleq> that's rev(1), is that code good?
10:53:30 <Twey> It's alright…
10:53:32 <unkanon_> by that conversation it feels like it barely made it to haskell, almost not being implementable
10:53:57 <unkanon_> subleq: hah, I like your nick
10:54:35 <benmachine> subleq: I reckon it could be made simpler with some mapMs
10:55:01 <Twey> getArgs >>= mapM_ (>>= putStr . unlines . map reverse . lines . readFile) -- maybe
10:55:07 <subleq> @src mapM
10:55:08 <lambdabot> mapM f as = sequence (map f as)
10:55:44 <mtnviewmark> @src sequence
10:55:44 <lambdabot> sequence []     = return []
10:55:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:55:44 <lambdabot> --OR
10:55:44 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:55:45 <benmachine> subleq: also, map f (map g xs) = map (f . g) xs
10:55:50 <monochrom> not sure you really need sequence rather than sequence_. similarly mapM rather than mapM_
10:56:23 <benmachine> true
10:56:34 <Twey> Oh, wait… that'll not work
10:57:09 <Twey> getArgs >>= mapM_ ((>>= putStr . unlines . map reverse . lines) . readFile)
10:57:24 <augustss> That doesn't parse
10:57:39 <benmachine> getArgs >>= mapM readFile >>= mapM_ (putStr . unlines . map reverse . lines)
10:57:41 <benmachine> I reckon
10:58:12 <benmachine> although I guess that's less than ideal since it opens all the files before processing any of them
10:59:08 <Twey> augustss: It does
10:59:24 <Twey> :t getArgs >>= mapM_ ((>>= putStr . unlines . map reverse . lines) . readFile)
10:59:24 <lambdabot> Not in scope: `getArgs'
10:59:27 <Twey> Oh
10:59:37 <Twey> :t (undefined :: IO [String]) >>= mapM_ ((>>= putStr . unlines . map reverse . lines) . readFile)
10:59:37 <lambdabot> IO ()
10:59:49 <augustss> Twey: You're right
10:59:58 <benmachine> hmm
11:00:09 <subleq> @src mapM_
11:00:09 <lambdabot> mapM_ f as = sequence_ (map f as)
11:00:12 <benmachine> :t putStr . unlines . map reverse . lines <=< readFile
11:00:12 <lambdabot> FilePath -> IO ()
11:00:15 <subleq> @src sequence_
11:00:16 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:00:20 <augustss> Twey: it just didn't parse for me. :)
11:00:25 <Twey> augustss: Heh, alright
11:00:30 <Twey> benmachine: Hm, yes
11:00:41 <benmachine> don't forget our friend the fish operator :)
11:00:53 <benmachine> :t mapM_ (putStr . unlines . map reverse . lines <=< readFile) =<< System.Environment.getArgs
11:00:53 <lambdabot> IO ()
11:02:17 <Twey> ((>>= m1) . m2) = (m1 <=< m2) … huh
11:03:20 <subleq> alright
11:03:22 <subleq> getArgs >>= mapM_ ((>>= putStr . unlines . (map reverse) . lines) . readFile)
11:03:25 <subleq> i like that version
11:04:10 <Twey> subleq: You should prefer the <=<
11:04:23 <subleq> i don't know that that means
11:04:25 <Twey> subleq: And there's no need for brackets around function application — it binds tighter than anything else
11:04:32 <Twey> @src (<=<)
11:04:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:04:38 <Twey> Bah
11:04:50 <subleq> Twey: the (map reverse)?
11:04:56 <Twey> m1 <=< m2 = (>>= m1) . m2, relevantly
11:04:58 <Twey> subleq: Yes
11:05:39 <stepcut> Twey: soon. There is one last code change, and then the rest is mostly documentation, changelogs, migration guides, etc.
11:06:07 <Twey> stepcut: *nod*
11:07:01 <subleq> hmm
11:07:07 <subleq> i'm having a lot of trouble parsing haskell
11:07:56 <mtnviewmark> what language are you coming from?
11:08:17 <revenantphx> Any idea when a 64bit ghci will be working? :|
11:08:46 <monochrom> when someone gives me money for two macbook pros, plus 2 months
11:09:15 <Zao> monochrom: More importantly, when will there be 64-bit GHC at all on Windows?
11:09:38 <revenantphx> brew gives me 64bit binaries :|
11:09:49 <monochrom> 2 months after someone gives me money for two high-end gaming pc's
11:10:35 <Zao> monochrom: You can bootcamp the MBPs? :D
11:11:06 <revenantphx> Zao has a point there.
11:11:06 <monochrom> I can bootcamp to MBPs for the price of money for two high-end gaming pc's
11:11:08 <revenantphx> I triple boot.
11:12:07 <monochrom> The point is flawed. Price is unrelated to cost.
11:13:21 <silbo> yo people
11:13:26 <augustss> Price is very related to the cost for me.
11:13:46 <monochrom> you are not capitalist free-market enough
11:14:27 <silbo> how could I convert maybe type to something specific?
11:14:30 <augustss> If the price is $100, the chances are good that the cost is going to be $100 for me.
11:14:35 <silbo> like maybe int to int
11:14:51 <augustss> silbo: fromJust, but don't use that
11:14:51 <unkanon_> > fromMaybe 0 (Just 5)
11:14:51 <lambdabot>   5
11:14:59 <Twey> silbo: fromMaybe, maybe, or pattern-matching
11:14:59 <unkanon_> silbo: ^^^
11:15:08 <revenantphx> So basically I can't install a lot of stuff because brew is giving me x86_64 binaries, but ghci only wants 32bit.
11:15:13 <revenantphx> monochrom: fix it faster. >_<
11:15:47 <monochrom> 10x the price if you want me to do it in one month
11:16:37 <revenantphx> Why don't you just do it for the hell of it.
11:16:38 <revenantphx> I dare you.
11:16:51 <revenantphx> Oh let me guess, you're busy writing Java and PHP?
11:17:08 <ion> There’s also >>= which may or may not be what you want. E.g. do x ← foo; return x+1 (being syntactic sugar for foo >>= \x → return x+1) returns Just 43 if foo = 42 and Nothing if foo = Nothing.
11:17:10 <revenantphx> If you don't write it now... I'll spread rumors that you've been writing Java, PHP, ASP and.... Io.
11:17:18 <monochrom> There are things I do for the hell of it, such as responding to #haskell and proving theorems of my own choosing.
11:17:32 <silbo> Twey: can you gime me an short example how to use those fromMaybe or maybe, for converting maybe int =
11:17:36 <ion> …if foo =- Just 42 that is.
11:17:42 <revenantphx> monochrom: TT_TT
11:17:49 <monochrom> Your rumours may bring me more monetary opportunities. I thank you for your free service in advance.
11:17:54 <revenantphx> So why hasn't 64bit ghci been done yet?
11:18:03 <revenantphx> whats the issue with it?
11:18:27 <augustss> silbo: what do you want to happen if the Maybe Int is a Nothing?
11:19:00 <silbo> augustss: i handle it with a if
11:19:00 <Zao> augustss: Horrible death!
11:19:14 <monochrom> I would be particularly thrilled if I haven't even learned PHP and people already email me to say "I heard you are a PHP pro, please accept my job offer" :)
11:19:22 <silbo> augustss: if it is a Just then I want to convert it to a int
11:19:39 <augustss> silbo: you shouldn't handle it with an if.  you should use a case, or fromMaybe
11:19:43 <revenantphx> lipo -info ghc-6.12.3
11:19:43 <revenantphx> lipo: can't figure out the architecture type of: ghc-6.12.3
11:19:45 <revenantphx> oh dear. 
11:20:01 <monochrom> That would be the best thrill since last time I tutored a student for a course without learning the course first.
11:20:31 <silbo> augustss: I don't have the time to make my code again the teacher wants it tonight xD
11:20:52 <Twey> silbo: Oh come on, it's one expression >.>
11:20:56 <augustss> silbo: you should do it right
11:21:02 <revenantphx> monochrom: what course was it?
11:21:04 <Twey> silbo: What do you want to have for that value in the Nothing case?
11:21:18 <monochrom> linear regression
11:21:22 <silbo> augustss: if you want to try make it better i will give the pastebin link xD
11:21:38 <revenantphx> oic.
11:21:45 <silbo> Twey: the input comes from the user
11:21:56 <silbo> Twey: so I just ask hime again
11:22:00 <revenantphx> why are all the ghc binaries... magical unknown binary?
11:22:14 <revenantphx> lipo can't figure out their type.
11:22:15 <augustss> silbo: users can usually only input strings
11:22:31 <augustss> not Maybe Int
11:22:57 <revenantphx> unles...
11:23:07 <silbo> augustss: xD I convert the user input to a Int
11:23:10 <revenantphx> oh course, it's shell script
11:23:11 <revenantphx> dur
11:23:20 <silbo> augustss: to a maybe Int
11:24:05 <silbo> augustss: and if the function returns Nothing i'll ask him again
11:24:43 <augustss> silbo: case theConvertedValue of Nothing -> askUserAgain; Just x -> return x
11:25:15 <augustss> which will have type IO Int (probably)
11:29:16 <Twey> maybe askUserAgain return theConvertedValue
11:29:44 <silbo> augustss: hmm? I will upload to pastebin, I don't understand it right now
11:34:49 <silbo> augustss: here is the pastebin link http://pastebin.com/ezXR8X6u im trying to write the function play
11:34:52 <ps-auxw> I am not sure about the expected behaviour of Control.Concurrent.STM.always. It throws an "Transacional invariant violation" exception at me, when the condition is not met. Otherwise it does nothing. Is this correct?
11:35:23 <silbo> augustss: my homework is to write the game quarto
11:38:57 <silbo> so guys listen up, if you want to make a christmas present xD here is your change to help me write this game called Quarto xD http://pastebin.com/ezXR8X6u
11:39:30 <augustss> silbo: so replace the if:  case readMove move of Nothing -> play tree; Just m -> ... m ...
11:39:50 <augustss> silbo: and that's all the help you're gonna get :)
11:40:49 <silbo> augustss: ok thx very much, this helps a lot
11:41:04 <silbo> augustss: trying to figure out for many nights
11:41:05 <augustss> silbo: and the 'm' in that isn't an Int it's a Move.
11:41:18 <deech> Hi all, I'm trying my hand at making the binary trees benchmark (http://shootout.alioth.debian.org/u32/program.php?test=binarytrees&lang=ghc&id=1) a little bit faster. My primary strategy is to benchmark to use more than one CPU but so far annotating the code with par doesn't seem to work.
11:41:31 <silbo> augustss: yea I know xD
11:42:08 <deech> Is there a better way to parallelise or is the problem resistant to it?
11:45:20 <Saizan> shouldn't check be made tail recursive?
11:47:16 <augustss> deech: the mapM_ seems like the easiest bit to parallelize
11:48:31 <deech> Cool, I'll give those a shot!
11:52:18 <EvanR-work> mapM_ is effectively a sequence, which puts actions in order. surely you cant *do* the actions out of order
11:52:38 <copumpkin> the map part is easily parallelizable, the M_ isn't
11:53:02 <EvanR-work> so if its implemented with map, and map is parallelized, youre good
11:53:05 <copumpkin> although you could specialize it for some monads
11:53:27 <dolio> copumpkin: So, I gave my tree thing a brief try, and realized it's worse than I expected. You can't really define equivalences of D As separately from the trees.
11:53:40 <Saizan> here you'd parallelize the evaluation of vs
11:54:07 <dolio> If only Agda had quotient types.
11:54:09 <alej> hi - if I have a project that depends on a shared library, is there a way for ghci to load the appropriate library automatically? that is, if I have a ghci session that wasn't started with "-lmylib"? Alternatively, is there a ghci command to manually load the library?
11:54:12 <copumpkin> dolio: so maybe a trivial proof of monotonicity of my mirror function + what I already had?
11:54:35 <subleq> quit
11:55:06 <dolio> You don't need to prove monoticity. It's pretty obvious that your version there takes the right inputs to the right outputs.
11:55:23 <augustss> copumpkin: of course you parallelize the map and keep the sequencing
11:55:25 <copumpkin> yeah, I just meant for the sake of being exhaustive (and as a general technique)
11:58:17 <copumpkin> it'd be nice to be able to say mapM has implementation x for Monad, but if you have CommutativeMonad, it has implementation y
11:58:28 <copumpkin> (of course, with a proof that y behaves like x ;))
12:00:31 <copumpkin> dolio: I had no idea you could put parameters on mutual blocks
12:00:38 <dolio> You can't.
12:00:54 <dolio> But I thought it was nicer than parameterizing the definitions.
12:01:00 <copumpkin> oh okay
12:01:17 <dolio> And also nicer than putting a 'module Foo (A ...' in my e-mail.
12:03:22 <augustss> what's with the mutual blocks in Agda anyway?  It's just an annoyance.
12:04:41 <dolio> Perhaps you should lend your prowess to helping them figure out mutual definitions automatically. :)
12:05:09 <dolio> I don't know why they don't do it. Is it harder than in Haskell?
12:07:50 <augustss> dolio: I've suggested it to them several times
12:08:03 <copumpkin> what's their response?
12:08:12 <augustss> a shrug
12:08:20 <copumpkin> can't argue with that :)
12:08:22 <dolio> Cayenne did it, I presume?
12:08:27 <augustss> Of course
12:08:50 <dolio> I can't recall if Epigram does it.
12:09:00 <dolio> Coq does not.
12:09:12 <copumpkin> well, the module opening behavior is kind of sequential right now, isn't it?
12:09:17 <copumpkin> so not everything could exist simultaneously
12:09:30 <dolio> Even in mutual blocks, some things happen sequentially.
12:09:45 <dolio> Type signatures are processed in order, I believe.
12:09:47 <Saizan> some people might like to not be able to use induction-recursion or similar inadvertedly
12:10:13 <copumpkin> next I want to be able to index a type by itself!
12:10:14 <dolio> Aside from constructor signatures, that is.
12:10:56 <Saizan> heh, i happened to want to use a function in its type
12:20:09 <tonkman> hey, I want to take random element from list
12:20:38 <freedrull> ever get this error running the happstack-tutorial? happs-tutorial: ./foreigncharsInclude.st: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
12:20:50 <tonkman> how it is done when type of randomRIO is IO Int and type of (!!) is Int
12:20:51 <augustss> Saizan: sounds like you're arguing for FORTRAN.  Or even worse
12:21:14 <augustss> Saizan: why should I have to do things the computer is better at doing?
12:21:41 <copumpkin> oh I thought fortran let you use functions in their own types
12:21:42 <augustss> Saizan: If there are things you don't think should be allowed, generate errors for them.
12:21:52 <mauke> tonkman: the usual way when dealing with IO
12:22:08 <mauke> it's done with mirrors^Wcallbacks
12:22:28 <EvanR-work> ..mirrors?
12:23:18 <alpounet> @pl \(x,y) -> [x, y]
12:23:18 <lambdabot> uncurry ((. return) . (:))
12:23:58 <Saizan> augustss: afaiu, induction-recursion is controversial, i.e. it's not that clear that it always give you sensical definitions, though i guess they could add a flag to disable it
12:27:02 <monochrom> "mirror mirror, who is the smartest haskell programmer?" -- incantation to get tryhaskell to accept definitions and do IO
12:29:32 <sleepynate> ( Mirror, Mirror ) ?
12:33:27 <Mathnerd314> is there a generalized version of zipWith?
12:34:28 <sipa> to do what?
12:34:54 <sleepynate> yea how is zipwith not generalized? :D
12:35:02 <augustss> Saizan: is mutual guaranteed to be sensical?
12:35:21 <Mathnerd314> sleepynate: to compare data structures
12:35:57 <Mathnerd314> sleepynate: e.g. to figure out if two data structures look "the same"
12:36:04 <Saizan> augustss: no, that was sort of the point
12:36:21 <Mathnerd314> sleepynate: particularly, same size, same branches, ...
12:36:27 <sipa> Mathnerd314: you may want to look at Traversable/Foldable
12:36:40 <Mathnerd314> sipa: I did; there's no zipWith :p
12:37:12 <augustss> Saizan: so then I'm not sure what I suggest would make things any worse. :)  As you say, you can always have a flag if you want to make sure you don't have any induction-recursion.  Just as you would today.
12:37:17 <Twey> What you're asking isn't really a generalisation of zipWith…
12:37:38 <sleepynate> yea... what do you want to do, zipWith (==) [] [] ?
12:37:45 <sipa> Mathnerd314: http://www.haskell.org/haskellwiki/Foldable_and_Traversable#Generalising_zipWith
12:37:46 <Twey> It requires access to the elements (Traversable) and to the structure (Foldable).  zipWith is about element-wise operation only.
12:38:07 <augustss> Or worse zipWith (==) [] [1]
12:38:09 <monochrom> Data.Data may have something, since it is based on your constructors
12:38:27 <sleepynate> augustss: story of my life.
12:38:29 <Mathnerd314> sipa: ah, thanks.
12:38:54 <augustss> Mathnerd314: some of the many generics packages have what you ask for
12:39:16 <sleepynate> don't get your list stuck in the zip of your With, is all i'm saying
12:58:27 * hackagebot gf 3.2 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.2 (ThomasHallgren)
13:16:19 <rcharles> do you really need lambda calculus to become proficient at haskell?
13:16:47 <Twey> No
13:17:02 <arcatan> if you get really proficient at haskell, you'll probably learn a thing or two about lambda calculus on the way.
13:17:16 <Twey> I doubt that's even so
13:17:24 <Twey> People do a lot of crazy theoretical stuff in Haskell
13:17:45 <Saizan> the basics about lambda calculus are a subset of the basics of haskell
13:17:56 <Twey> If you get to be very proficient, you're likely to encounter it, and learning the crazy theoretical stuff will probably require that you learn about lambda calculus and other, much more difficult topics
13:18:03 <rcharles> isn't it what functional programming is all about?
13:18:13 <Twey> Learning Haskell, however, requires no understanding of lambda calculus at all
13:18:19 <Endiannes> rcharles, No.
13:18:29 <Saizan> yeah, it doesn't require, but it implies :)
13:18:34 <Twey> rcharles: You could as well say that imperative programming is all about machine code
13:18:35 <rcharles> ok
13:18:44 <Eelis> rcharles: lambda calculus is really nothing more than an extremely rudimentary language that explains what happens when you call a function. there's almost nothing to "learn" about it
13:18:48 <Twey> It might be under there somewhere, but that doesn't mean that you have to know anything about it to code Ruby
13:18:48 <Saizan> a bit like learning reals will make you learn about integers
13:19:01 <rcharles> understood
13:19:14 * Endiannes throws a church literal at Eelis
13:19:36 <sipa> i think you can learn haskell without knowing lambda calculus, and after a while, if you're proficient at it, and you learn lambda calculus, you'll say "ow, it's just that?"
13:19:55 <Twey> TBH I think you'll probably go ‘oh, it's just that?’ anyway
13:20:18 <Saizan> see? the problem is the hype
13:20:23 <Twey> If you can do basic arithmetic, you're well above the level of mathematical competence required to understand lambda calculus :þ
13:20:24 <Eelis> i think if you know lambda calculus (which you can pick up in 2 minutes), then when you look at Haskell you go "oh, it's just that?" ;)
13:20:48 <Twey> Eelis: Nahh, plus types, typeclasses, syntax, patterns…
13:21:05 <sm> this is a great talk on the "myths of OO": http://74.125.155.132/scholar?q=cache:jeM9OMukZPoJ:scholar.google.com/&hl=en&as_sdt=2000
13:21:13 <roconnor> Eelis: typed or untyped lambda calculus?
13:21:17 <sm> don't miss Table 1
13:21:37 <roconnor> A username and password are being requested by http://aop.cslab.openu.ac.il. The site says: "Open University Digital Library"
13:21:44 <roconnor> I see why you used the google cache
13:21:56 <sm> yup. From lambda the ultimate
13:22:00 <Eelis> roconnor: simple types are just common sense, and are what really matters. the rest is just add-on stuff that you can pick up as you go ;)
13:22:05 <roconnor> Stupid open university of israel
13:22:56 <smerz> sm nice read!
13:23:13 * roconnor is reading it now
13:24:36 <arcatan> i've been looking at TAPL and some other books and every time I'm like "yeah, yeah, so far it's trivial, where's the hard and awesome stuff"
13:25:01 <roconnor> arcatan: turns out that everything is easy ... in it's own way.
13:25:14 <roconnor> *its
13:25:43 <copumpkin> arcatan: ATTaPL has some more interesting tidbits on specific applications of types
13:26:32 <Twey> sm: I'm not a fan of this talk.
13:26:48 <Twey> It's very eloquent, but relatively light on actual argument.
13:26:55 <Twey> Or fact.
13:26:56 <arcatan> comb: oh, i shall take a look
13:27:16 <Twey> « Consider the “utter pointlessness” of monads in lazy functional languages. They’re great
13:27:21 <Twey> for computing factorial functions — but can barely echo back user input. »
13:27:22 <Twey> — wha'
13:27:22 <arcatan> comb: disregard that, i meant copumpkin
13:28:49 <roconnor> Speaking about identity and object.  When I was working on implementing a war-game in Haskell I was wondering if two ships at the same location on the board with the same heading with exactly the same damage controlled by the same player are actually different?
13:29:51 <sm> roconnor: if they're two elements in a list, they are
13:30:53 <roconnor> perhaps
13:30:55 <monadic_kid> or not, if they've been instanced
13:31:01 <sm> Twey: he put that in scare quotes. He's just contrasting OO and FP views of things
13:32:51 <silbo> j
13:32:55 <silbo> hey
13:33:04 <silbo> how can i write 2 lines in a case
13:33:14 <mauke> hit enter to start a new line
13:33:25 <silbo> not that simple
13:33:30 <mauke> yes, it is
13:33:35 <sipa> silbo: and indent
13:33:40 <roconnor> if you indent the new line properly it should work
13:33:52 <Saizan> in a source file
13:33:54 <silbo> nope Type error in application :: ....
13:33:59 <roconnor> @paste
13:33:59 <Twey> Haha, History: Haskell, Tragedy: Haskell, Farce: Haskell
13:33:59 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:34:04 <roconnor> pft
13:34:08 <roconnor> @hpaste
13:34:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:34:17 <roconnor> okay that is like 2 years out of date
13:34:23 <silbo> i want to write 2 lines of code into one case
13:34:27 <sm> you found Table 1, but don't give away the punchline :)
13:34:29 <c_wraith> preflex: seen mmorrow
13:34:29 <preflex>  mmorrow was last seen on #ghc 339 days, 18 hours, 36 minutes and 41 seconds ago, saying: * mmorrow is rtfm'ing
13:34:34 <c_wraith> :(
13:34:48 <roconnor> silbo: paste your erronious code at http://hpaste.org/
13:34:49 <mauke> silbo: 2 lines is the same thing as 1 line
13:34:59 <c_wraith> silbo: what do you mean by "2 lines of code"?
13:35:08 <c_wraith> haskell isn't generally divided into lines of code
13:35:24 <c_wraith> Except at the whitespace level, or inside a do block
13:35:29 <silbo> like putstrn and calling some functions
13:35:37 <sipa> silbo: show us your code
13:35:49 <mauke> statements are not the same thing as lines
13:35:57 <c_wraith> you probably need a new do block.
13:36:00 <mauke> what's the type of your functions?
13:36:07 <revenantphx> Hrm
13:36:10 <c_wraith> Which means you probably have forgotten to put "do" at the start of the case
13:36:45 <revenantphx> So how exactly does one go about parsing from attoparsec continupusly?
13:36:54 <revenantphx> I can see that you could get a value when it produces Done
13:37:04 <revenantphx> and then pass the remaining bytestring in...
13:37:12 <revenantphx> and if it partials, pass in new stuff.
13:37:18 <revenantphx> But is there any way to literally run continuously?
13:37:34 <c_wraith> and get continuous output?
13:37:41 <c_wraith> No.
13:37:51 <copumpkin> you'd want lazy parsing, I guess?
13:38:07 <revenantphx> I guess what I just said would work fine?
13:38:21 <c_wraith> well, or something like attoparsec-iteratee or attoparsec-enumerator
13:38:30 <revenantphx> that's what I was just looking at
13:38:37 <revenantphx> they yield when the parser gives a done
13:38:39 <revenantphx> Done
13:38:40 <revenantphx> *
13:39:13 <c_wraith> well, throw it in a forever.
13:39:18 <silbo> http://hpaste.org/42519/quarto
13:39:19 <c_wraith> If that's what you really want
13:39:27 <silbo> sipa: http://hpaste.org/42519/quarto
13:39:31 <revenantphx> "The parser will be streamed bytes until it returns Done or Fail."
13:39:55 <sipa> silbo: put a 'do' before putStrLn
13:40:13 <sipa> and indent the line with 'play' 3 places
13:40:13 <Twey> @where paste
13:40:13 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
13:40:15 <Twey> roconnor: ^
13:40:29 <revenantphx> I'll try some kind of simple example
13:40:43 <sipa> silbo: and all your brackets are redundant
13:41:42 <Twey> Heh
13:41:46 <Twey> All of them!
13:42:04 <Ilum> I'm getting a "y not in scope" compilation error on:  | f x == (Just' y) = y : mapMaybe' f xs. So, I can't use any variables declared in the conditional part of a guard in the statement that follows?
13:42:24 <silbo> sipa: bad format error
13:42:52 <mauke> Ilum: you can't declare variables in guards
13:44:03 <sipa> you could use pattern guards
13:44:36 <silbo> öö what?
13:45:07 <mauke> silbo: what's a bad format error?
13:45:10 <Ilum> sipa: How so?
13:46:18 <revenantphx> :t (<*)
13:46:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:46:21 <revenantphx> :t (*>)
13:46:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:46:23 <sipa> Ilum: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html
13:46:33 <silbo> mauke: http://hpaste.org/paste/42519/quarto_annotation#p42520
13:46:45 <revenantphx> :t (>>)
13:46:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:46:47 <revenantphx> :t (<<)
13:46:47 <lambdabot> Not in scope: `<<'
13:46:50 <revenantphx> mmk
13:46:54 <mauke> silbo: that looks like haskell code
13:47:10 <silbo> mauke: because it is ??
13:47:29 <mauke> silbo: so when you say "bad format error" you mean "haskell code"?
13:47:36 <silbo> mauke: the last line gives bad layout error
13:47:46 <mauke> what's the actual error?
13:48:34 <silbo> syntax error in expression (unexpected ';', possibly doe to bad layout
13:48:52 <mauke> what's the actual error?
13:49:08 <mauke> also, what's the actual code?
13:49:13 <silbo> mauke: I got 10 minutes to send the code to my teacher (CRAP)!
13:49:16 <monochrom> doesn't look like bad layout. the problem is elsewhere
13:49:27 <monochrom> which is what mauke says
13:49:32 <mauke> (hint: real error messages don't contain "doe")
13:49:56 <silbo> due
13:50:01 <silbo> who cares
13:50:03 <sipa> we know it is due
13:50:14 <mauke> yes, but I don't know what else the error message says
13:50:15 <sipa> but you're not giving the actual code/error if you make typo's in ti
13:50:17 <sipa> it
13:50:20 <mauke> like line number, column number, context
13:50:22 <mauke> other errors
13:50:36 <monochrom> if you have only 10 minutes left, one would think you would rather cut-paste without editing than edit heavily before paste
13:50:40 <silbo> sipa: it just says the line and this errror
13:50:46 <silbo> wtf guys
13:50:51 <sipa> what compiler/interpreter are you using?
13:51:00 <silbo> sipa: hugs ? xD
13:51:01 <mauke> silbo: why do you intentionally make it hard for us to diagnose the problem?
13:51:17 <Twey> Heh, people still use hugs
13:51:23 <monochrom> if you edit heavily before paste, you may end up editing away the cause of error, not to mention doing extra work
13:51:31 <silbo> silbo: what do want ill tell you
13:51:36 <mauke> "why do you care? why do you need that information?" wtf dude, just give me the information
13:51:44 <sipa> easy
13:51:46 <silbo> im using version 2006 hugs
13:51:50 <sipa> silbo: i suggest using ghci
13:51:53 <silbo> 2006 september
13:52:12 <silbo> sipa: ok, but I don't got time for install
13:52:19 <silbo> I want to get this working in 1 minute
13:52:29 <monadic_kid> your usernames are too similar
13:52:34 <monochrom> it's most illogical. why would you do extra work to sabotage your own error report?
13:52:43 <sipa> that'll be hard - as far as i can see the piece of code you've shown us is correct
13:52:59 <mauke> sipa: well, it's a syntax error
13:53:03 <mauke> so that's not the real code
13:53:12 <sipa> ?
13:53:17 <mauke> a file can't start with 'do'
13:53:17 <Ilum> Why is this code snippet producing this error? http://pastebin.com/ywMt3ESj
13:53:35 <sipa> mauke: it clearly isn't the whole program
13:53:37 <mauke> in fact, getting a 'do' in column 1 takes some work
13:53:49 <mauke> sipa: so he changed things before pasting it
13:53:54 <sipa> yes, i know
13:54:04 <mauke> so we got fake code and fake error messages
13:54:10 <sipa> that's why i say that the part he's shown us is correct
13:54:17 <sipa> but i can't say more if i don't see more
13:54:23 <mauke> Ilum: [x:xs] is probably wrong. did you mean (x:xs)?
13:54:30 <monochrom> how about this? http://hpaste.org/paste/42519/quarto_annotation#p42521
13:54:33 <monadic_kid> Ilum: change [x:xs] to (x:xs)
13:55:26 <mauke> Ilum: also, your ( ) are redundant
13:56:16 <Ilum> mauke: you mean in the case expression?
13:56:25 <mauke> I mean all of them
13:56:47 <mauke> also, mapMaybe' f (x : xs) = maybe id (:) (f x) (mapMaybe' f xs)
13:58:08 <monadic_kid> mauke: looks like he/she's just learning about Maybe types and written his/her own
13:58:44 <mauke> oh, that makes sense
13:59:44 <mauke> mapMaybe' f (x : xs) = (case f x of Nothing' -> id; Just' y -> (y :)) (mapMaybe' f xs) 
13:59:47 <mauke> then :-)
14:00:35 * mjrosenb has a somewhat fun puzze
14:00:59 <mjrosenb> *puzzle
14:01:05 <mjrosenb> and a not very fun keyboard
14:02:45 * hackagebot bindings-glib 0.1.5 - Low level bindings to GLib.  http://hackage.haskell.org/package/bindings-glib-0.1.5 (MauricioAntunes)
14:03:06 <copumpkin> mjrosenb: well, tell us!
14:05:36 <ddarius> copumpkin: The puzzle was figuring out what the puzzle was.
14:08:07 <monochrom> perhaps in 20 questions or less we could expose the puzzle. is it a mathematical puzzle?
14:08:47 <mjrosenb> write a function bashWords :: String -> [String] that follows the bash word splitting and escaping rules
14:09:21 <mjrosenb> the annoying part that i found was handling empty words
14:09:45 <monochrom> so for example bashWords "hello\\ you there" = ["hello you", "there"]?
14:09:54 <mjrosenb> yes.
14:10:18 <mjrosenb> so bashWords "hello \"\" world" = ["hello", "", "world"
14:10:38 <revenantphx> So one thing I'm not seeing...how do you "run" or "use" iteratees?
14:10:40 <mjrosenb> and bashWords "hello\"\" world" = ["hello", "world"]
14:10:53 <revenantphx> The yesod blog tutorial never even mentions that aspect.
14:11:11 <monochrom> some "runIteratee" function has to be provided by the iteratee library
14:11:27 <revenantphx> monochrom: I see a runIteratee in enumerator... but it's the constructor.
14:11:30 <revenantphx> for iteratee.
14:11:59 <monochrom> then the right function is under some other name
14:12:44 <revenantphx> What i'd like to do, is run the same iteratee repeatedly, taking an action everytime I get a Yield
14:12:59 <monochrom> I played with enumerator once, but I lost my toy exercise, so I forgot the name.
14:13:10 <revenantphx> drat
14:13:33 <revenantphx> http://docs.yesodweb.com/blog/enumerators-tutorial-part-2/
14:13:35 <revenantphx> oh, hah.
14:13:39 <revenantphx> Right at the start of part 2~
14:13:53 <monochrom> it is called "run" and "run_"
14:14:06 <revenantphx> ack
14:14:12 <revenantphx> I was searching for -> b
14:14:22 <revenantphx> of course it's -> m b or (Either ... b)
14:14:47 <monochrom> All I did was scroll-wheel :)
14:14:52 <revenantphx> The thing is though... that's not really what I want monochrom :\
14:15:19 <revenantphx> Oh well, I'll work it out.
14:15:49 <revenantphx> the tutorial has what I want.
14:15:55 <monochrom> nice
14:17:14 <revenantphx> run and run_ are just specialized cases for when you want to have 1 block of input -> 1 block of ouput
14:18:16 <revenantphx> I think I haven't quite grasped iteratees entirely.
14:18:22 <revenantphx> Some practice and I'll get them I hope.
14:18:26 <revenantphx> They're definitely useful.
14:23:07 <revenantphx> hrm.. I need to get it continuous :\
14:23:31 * augustss shudders
14:23:55 <revenantphx> augustss: ?
14:24:32 <augustss> continuous
14:28:14 <copumpkin> @ask kmc I hear you have a lambda to pi calculus compiler?
14:28:14 <lambdabot> Consider it noted.
14:31:35 <ntc2> anyone running windows?  i'm trying to figure out if a problem is due to windows, or the hackage installed program that is failing.
14:32:13 <tonkman> I have had many problems with windows and cabal
14:32:18 <augustss> Does the lambda-to-pi compiler go via mu, nu, and omikron?
14:32:34 <ntc2> tonkman: haha. are you running windows now?
14:32:48 <tonkman> yeah
14:33:13 <revenantphx> hey monochrom... what *is* runIteratee :\
14:33:37 <revenantphx> I mean, its a type constructor but... I'm not seeing why/how/what... you know
14:33:47 <revenantphx> data constructor*
14:33:50 <revenantphx> (don't shoot me)
14:34:09 <revenantphx> Or is it? I don't know at this point.
14:34:16 <ntc2> tonkman: could you try something for me?  namely: 
14:34:17 <ntc2> $ cabal install capri
14:34:19 <ntc2> $ capri bootstrap
14:34:20 <ntc2> $ capri clone syb 'base-*'
14:34:38 <byorgey> revenantphx: something that starts with a lowercase letter cannot be a data constructor.
14:34:45 <tonkman> does that take time?
14:34:47 <revenantphx> yeah, that just hit me.
14:35:02 <revenantphx> I still can't find an implementation in the source code... it's just there
14:35:17 <ntc2> tonkman: not much, maybe 1 minute?
14:35:32 <byorgey> revenantphx: perhaps it is a field label?  check the definition of the Iteratee type
14:35:44 <revenantphx> that it would seem to be.
14:35:45 <tonkman> capri: already exists
14:35:47 <byorgey> e.g.  data Iteratee = I { runIteratee :: foo blah }
14:35:52 <revenantphx> yes, thats about it.
14:35:59 <revenantphx> newtype Iteratee a m b = Iteratee
14:36:00 <revenantphx> 	{ runIteratee :: m (Step a m b)
14:36:00 <revenantphx> 	}
14:36:00 <Twey> revenantphx: It's probably a field label; it's an idiom to have newtype Foo x = Foo { runFoo :: x }
14:36:06 <byorgey> revenantphx: ok, so in that case it just unwraps the Iteratee constructor
14:36:12 <tonkman> ntc2: capri clone syb 'base-*' prints:
14:36:12 <Twey> As a simple wrapper around a value of type x
14:36:14 <revenantphx> byorgey: aah.
14:36:16 <tonkman> : missing id field
14:36:16 <tonkman> : invalid package identifier:
14:36:19 <ddarius> > ['λ' .. 'π']
14:36:20 <lambdabot>   "\955\956\957\958\959\960"
14:36:25 <revenantphx> Is there a simpler example?
14:36:38 <revenantphx> With something I've probably already seen?
14:36:40 <Twey> > 'τ' > 'π' -- tauday.com
14:36:41 <lambdabot>   True
14:37:44 <ntc2> tonkman: hmmmm. but the `capri boostrap` step succeeded?
14:37:49 <byorgey> revenantphx: have you ever used a monad like State or Reader ?
14:38:00 <revenantphx> byorgey: Not much, I was planning too though.
14:38:10 <tonkman> ntc2: it printed: capri: already exists
14:38:23 <byorgey> revenantphx: ok, they use the same pattern.  newtype State s a = State { runState :: s -> (a,s) }
14:38:49 <revenantphx> I see.
14:38:56 <ntc2> tonkman: oh.  could you cd to a empty directory, and try `capri bootstrap` again?
14:38:59 <byorgey> revenantphx: so  runState :: State s a -> (s -> (a,s))
14:39:15 <byorgey> revenantphx: and runIteratee :: Iteratee a m b -> m (Step a m b)
14:39:36 <revenantphx> right right... field labels.
14:39:54 <byorgey> revenantphx: the idea is that Iteratee/State are abstract wrappers, and runIteratee/runState let you 'get at' the actual implementation.
14:39:55 <revenantphx> so runState "unwraps" (State s a) into the actual transformation s->(a,s)
14:40:02 <byorgey> exactly.
14:40:20 <revenantphx> State s a is just a more friendly way to say "a transformation from s to a" then?
14:40:20 <tonkman> ntc2: done
14:40:36 <tonkman> ntc2: : missing id field
14:40:39 <revenantphx> well, s to (s,a)
14:40:43 <Twey> revenantphx: More or less
14:40:49 <revenantphx> interesting.
14:40:52 <ntc2> tonkman: but the `capri bootstrap` step succeeded this time?
14:40:56 <tonkman> yes
14:40:59 <Twey> revenantphx: But as a separate type, State can have instances and methods defined on it (crucially, Monad)
14:41:09 <revenantphx> I think I need to think more haskell-like sometimes. encoding functions as data shouldn't seem weird.
14:41:10 <ddarius> Or just runState . State = id and State . runState = id.
14:41:19 <sipa> State s a is a wrapped type around a computation that transforms something of type s, and computes something of type a
14:41:22 <ntc2> tonkman: ok, could you try `capri clone syb`?
14:41:28 <revenantphx> ddarius: is that a synonym for it?
14:41:34 <Twey> capri?  Yet another VCS?
14:41:37 <ddarius> revenantphx: Nothing is being encoded as data.
14:41:47 <revenantphx> encoded as a data type I guess.
14:41:50 <tonkman> ntc2: it worked
14:41:53 <revenantphx> I'm probably bungling terminology.
14:41:56 <ddarius> Nothing is being encoded.
14:42:00 <ntc2> Twey: it's for managing local/sandboxed cabal installs
14:42:14 <revenantphx> nevermind, I think I get that now.
14:42:20 <sipa> revenantphx: in haskell, function values belong to a particulat data type, yes
14:42:20 <Twey> Oh, interesting
14:42:30 <ntc2> tonkman: ok, how about `capri clone 'base-3*`?
14:42:45 <tonkman> ntc2: : missing id field
14:44:35 <ntc2> tonkman: ok.  that's a different error than the person over here had :P  thanks for your help
14:47:30 * ddarius is going to see if he can find the PDF of "Paradise Lost" that he read half of a year or so ago.
14:49:03 <ntc2> ddarius: http://free-books.dontexist.com/search?req=paradise+lost&nametype=orig
14:49:20 <ntc2> (best ebook site i'm aware of)
14:49:45 <tonkman> is it good idea to "carry" programs configuration on state monad
14:50:28 <sipa> if configuration is static, you may prefer a Reader monad
14:50:33 <ddarius> ntc2: I wasn't looking for another PDF, I was looking for mine.
14:50:49 <tonkman> oh, Reader, I forgot that
14:51:04 <ntc2> ddarius: ah.  well, great ebook site, just the same.
14:57:10 <bos> @pl o=map(['A'..'Z']:)$[]:o
14:57:16 <bos> @pl o=map(['A'..'Z']:)$[]:o
14:57:16 <lambdabot> o = fix (map (['A'..'Z'] :) . ([] :))
14:58:42 <ddarius> bos: What the heck did you type?
14:58:59 <Twey> Heh
14:59:02 <Twey> Italics?
14:59:32 <bos> apparenty so
14:59:35 <bos> i had no idea
14:59:49 <ddarius> It's reverse video here.
15:01:32 <Twey> Yeah, that's how my terminal displays it, too.
15:02:22 <bos> wow
15:04:20 <roconnor> sm, Twey: Table 1 is wrong.  It should go KRC - Miranda - Haskell
15:06:05 <mauke> bold italics underline
15:07:26 <mtnviewmark> ☺
15:08:17 <mauke> ｗｉｄｅ sᴍᴀʟʟ ᴄᴀᴘs uʍop ǝpısdn
15:08:48 <djahandarie> Those aren't from control characters though. :P
15:09:27 <mauke> <blink>ahtmla</blink>
15:10:58 <copumpkin> ezyang: you around?
15:15:23 <copumpkin> dons: where's the haskell for detexify? it looks like ruby to me
15:15:54 <copumpkin> oh I see
15:16:06 <revenantphx> :\
15:16:27 <copumpkin> there's https://github.com/kirel/detexify-hs-backend and https://github.com/kirel/detexify
15:16:43 <teki> does anybody have a plausible explanation for why GHCi would fail to load a module
15:17:04 <monochrom> if the module is in a package
15:17:08 <teki> e.g. i run (:m + mymodule.hs) and i get a message telling me the syntax of the :m + command
15:17:20 <teki> monochrom: nope, it's just sitting in a folder
15:17:20 <monochrom> that is not "load" per se
15:17:26 <copumpkin> :m + takes a module name
15:17:29 <copumpkin> not a file name
15:17:32 <teki> i know
15:17:42 <ddarius> monochrom: For future situations, always assume user error first.
15:17:49 <mauke> mymodule.hs is not a module name
15:18:05 <teki> look, i've used :m + before
15:18:11 <teki> i have an importer module
15:18:20 <monochrom> compulsory reading for all users of ghci: http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/interactive-evaluation.html#ghci-scope
15:18:21 <teki> for a bunch of code i work with
15:18:28 <teki> and it's worked fine before
15:18:29 <copumpkin> teki: I'm just saying, your example of usage is wrong
15:18:33 <copumpkin> so as we don't know you
15:18:35 <copumpkin> we assumed you didn't know it
15:18:43 <teki> fair enough, sorry for the indignation
15:18:46 <teki> at any rate
15:19:00 <ddarius> copumpkin: Except that he's still wrong.
15:19:01 <copumpkin> you also haven't given us the input and error it gave you, explicitly, as much as your interpretation of it
15:19:07 <teki> alright
15:19:26 <teki> so i'll cd over to say mydirectory, which contains a file mycode.hs
15:19:41 <monochrom> have you ever heard of ":load mycode.hs"?
15:20:10 <teki> and...sorry for wasting your time
15:20:41 <teki> i'm being a fool
15:21:19 <ddarius> @wn reeking
15:21:21 <lambdabot> *** "reeking" wn "WordNet (r) 2.0"
15:21:21 <lambdabot> reeking
15:21:21 <lambdabot>      adj 1: wet with secreted or exuded moisture such as sweat or blood
15:21:21 <lambdabot>             or tears; "wiped his reeking neck" [syn: {dripping}, {watery}]
15:21:21 <lambdabot>      2: giving off a strong unpleasant smell
15:21:56 <monochrom> torn between two commands, feeling like a fool. mixing both of you is breaking all the rules.
15:22:10 <monochrom> http://www.tsrocks.com/m/mary_macgregor_texts/torn_between_two_lovers.html
15:22:28 <BMeph> Is there already an idiomatic name for a function, 'func f (x:xs) = f x : xs'?
15:22:37 <monochrom> no
15:22:58 <byorgey> BMeph: I call it onHead
15:22:59 <sipa> mapHead ?
15:23:11 <sipa> onHead is better
15:23:22 <monochrom> mapReduceJustTheHead
15:24:04 <Twey> I call it list undefined ((:) . f)
15:24:20 <sipa> :t list
15:24:20 <lambdabot> Not in scope: `list'
15:24:22 * BMeph decides to call the function, "listNom"...
15:24:29 <monochrom> hehehehe
15:24:31 <mauke> s/undefined/[]/
15:24:39 <Twey> Works
15:24:42 * BMeph agrees with mauke
15:24:58 * BMeph also agrees with monochrom! :)
15:25:02 <revenantphx> quick check: Iteratee a m b is an Iteratee taking a, producing b in the monad m?
15:25:02 <Twey> sipa: list d _ [] = d; list _ f (x : xs) = f x xs
15:25:09 <Twey> revenantphx: Yes
15:25:13 <revenantphx> kk.
15:25:18 <copumpkin> jj
15:25:23 * Twey is not really sure why the arguments are in that order
15:25:36 <copumpkin> I'd make it Iteratee m a b
15:25:39 <Twey> Yeah
15:25:48 <copumpkin> since then it's somewhat functionlike
15:25:54 <mauke> hmm, I call list uncons
15:25:55 <Twey> Iteratee a m b feels like m should be an Arrow
15:25:59 * BMeph beleives it is because of: 'data [] a = [] | a : [a]'
15:26:13 <revenantphx> Twey: maybe it's like that since it's producing (m b)
15:26:16 <Twey> mauke: c.f. maybe, either
15:26:25 <revenantphx> the input is not in m
15:26:25 <Twey> revenantphx: Maybe
15:26:32 * BMeph means that conceptually, not literally.
15:26:35 <copumpkin> since Iteratee can be an instance of Category (not sure if it is), I'd still prefer m a b
15:26:41 <mauke> Twey: but mine is a method
15:26:45 <revenantphx> Anyways.
15:26:56 <Twey> mauke: A method of what?
15:27:11 <revenantphx> I'm going to go back to figuring out how to adapt iteratee's to network parsers.
15:27:11 <mauke> class Stream s a | s -> a where uncons :: b -> (a -> s -> b) -> s -> b
15:27:12 <BMeph> mauke: Is there madness in your method? ;)
15:27:22 <revenantphx> Seem's like my idea for looping it comes out to an Enumerator.
15:27:46 <revenantphx> Except instead of returning a value when a Yield is got, it instead would start a new iteratee.
15:27:52 <revenantphx> Using what's left from the old one.
15:28:08 <mauke> do you have better names?
15:28:22 <revenantphx> I wish there was something combining Continue/Yield :\
15:28:39 <ddarius> BMeph: Probably.
15:29:21 <joker_> is there any way to check if haskell is installed on linux machine from shell command 
15:29:31 <mauke> what do you mean by "haskell"?
15:29:43 <copumpkin> the h98 spec
15:29:43 <joker_> like if i can edit and compile haskell
15:29:49 <Twey> joker_: which ghc, probably
15:29:52 <joker_> i can edit with vi
15:30:01 <mauke> joker_: you can edit with any editor
15:30:06 <mauke> including ed, cat, and dd
15:30:11 <joker_> ok but how do i run it then from shell
15:30:23 <mauke> with any haskell interpreter or compiler
15:30:46 <BMeph> ddarius: Aw, I was secretly hoping for a "SPARTA!" reference... ;þ
15:30:55 <joker_> thats what i mean....how do i check it if this linux that i have access to it have interpreter installed
15:31:07 <mauke> which interpreter?
15:31:17 <joker_> any
15:31:21 <bos> Bay Area Haskell Hackathon FTW! http://twitter.com/#!/bos31337/status/18085284927246336
15:31:26 <joker_> glasgow or any other
15:31:33 <mtnviewmark> joker: see if you the command runhaskell on your path
15:31:40 <mtnviewmark> as in run    which runhaskell
15:32:21 <joker_> ok tx
15:33:50 <warzl> bos - nixw
15:33:53 <warzl> *nice
15:34:01 <warzl> I'll be there too I hope
15:34:29 <warzl> I'm prototyping a new language in haskell
15:34:38 <bos> warzl: cool!
15:34:56 <warzl> what you doing the haskell?
15:35:04 <warzl> *with
15:36:38 * mtnviewmark thinks "nixw" should become an internet meme
15:37:01 * mtnviewmark immediately started trying to figure out what it was leet speak for
15:37:52 * ntc2 thinks "what you doing the haskell?" would be a better meme
15:38:37 * benmachine does the haskell
15:38:46 <benmachine> it's similar to the robot I think
15:39:51 <sipa> @faq can one do the haskell?
15:39:51 <lambdabot> The answer is: Yes! Haskell can do that.
15:40:14 <ntc2> :)
15:48:03 <revenantphx> So, lets see.
15:48:15 <revenantphx> I've thought it out a bit, and what I think seems to be a good idea (?)
15:48:24 <revenantphx> is to feed the iteratee some amount of data, until I get a Yield
15:48:28 <mtnviewmark> oh, so Haskell can do the haskell.... is that in the SelfReferential monad?
15:48:48 <revenantphx> when I do, refeed the leftovers until I get a continue.
15:48:54 <revenantphx> so basically I only supply new data in continue.
15:49:04 <BMeph> @faq Can Haskell get Xzibit do put a Haskell in your Haskell?
15:49:04 <lambdabot> The answer is: Yes! Haskell can do that.
15:49:32 <revenantphx> http://yoyodawgdawg.com/pics/yo-dawg-beer.jpg
15:50:25 <revenantphx> Yo dawg i herd yo and yo dawg like yoyos so we put yo dawg and a yoyo in a yo yo so yo dawg can yo yo while yo yo yo, dawg.
15:51:12 <bos> @hoogle liftIO
15:51:12 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
15:51:17 <sipa> http://static.funnyjunk.com/pictures/ae65d1e7_8699_7660.jpg
15:51:23 <sipa> oh, this is #haskell
15:51:36 <Twey> > fix $ (++) "yo dawg, i herd yo like "
15:51:37 <lambdabot>   "yo dawg, i herd yo like yo dawg, i herd yo like yo dawg, i herd yo like yo...
15:56:38 <mtnviewmark> > fix $ (++) "yo dawg, i herd yo like \""
15:56:40 <lambdabot>   "yo dawg, i herd yo like \"yo dawg, i herd yo like \"yo dawg, i herd yo lik...
15:58:15 <revenantphx> :|
16:04:35 <chreekat> What's the problem likely to be if I can :l a file in ghci and run main successfully, but I get linker errors when I try to compile the file with ghc?
16:05:11 <mtnviewmark> are you using one of the packages that can dynamically load haskell code?
16:05:22 <Apocalisp_> What is State# exactly?
16:05:40 <chreekat> Maybe? It looks to be complaining about Data.IntSet and Data.Numbers.Primes
16:06:48 <benmachine> chreekat: are you compiling with ghc --make?
16:06:52 <benmachine> ghci does that automatically
16:06:57 <benmachine> which tracks down some dependencies for you
16:07:08 <benmachine> but plain ghc either requires --make or specifying packages with -package
16:07:16 <mtnviewmark> no, I meant like hs-plugins
16:07:26 <chreekat> oh, snazzy!
16:07:50 <chreekat> mtnviewmark: benmachine is right, I needed --make
16:09:03 <megatron242> Hi, quick question - I have a file that includes double serialized using a C program. I'm using ByteString to parse. How do I parse the double numbers?
16:09:22 <mtnviewmark> sigh
16:09:25 <Zao> Serialized how?
16:09:30 <Zao> Dumped octets?
16:09:44 <Zao> In some 8-bit narrow encoding?
16:09:45 <nominolo_> megatron242: have you tried Data.Binary?
16:09:50 <megatron242> using fwrite("%d", n)
16:10:12 <megatron242> I'm not sure what you're meaning?
16:10:13 <mtnviewmark> nominolo_ that won't work, the encoding in Data.Binary for Double is only compatible with itself
16:10:17 <Zao> With what separator?
16:10:28 <mtnviewmark> it doesn't follow any standard convention for encoding doubles on the wire
16:10:29 <Zao> I'd use something like attoparsec to parse things, myself.
16:10:29 <megatron242> I'm trying to load some standard binary format...
16:10:37 <Zao> mtnviewmark: What "standard encoding"?
16:10:45 <nominolo_> mtnviewmark: ah, too bad
16:10:50 <mtnviewmark> "any" - there are several in common use
16:10:54 <megatron242> It contains geographical information, serialized using doubles
16:11:03 <Zao> Since when does write take a format string?
16:11:05 <megatron242> (for the lattitude and longitutde).
16:11:10 <Zao> *fwrite
16:11:21 <Zao> Did you mean fprintf? Is this text or some binary format?
16:11:24 <mtnviewmark> but - seems megatron242 has doubles as decimal strings
16:11:39 <Zao> Specify the encoding properly first. Then look for solutions.
16:11:47 <Zao> If it's text, attoparsec is quite suitable.
16:12:00 <Zao> If it's binary, steal stuff from Data.Binary and friends.
16:12:11 <megatron242> No, I'm using a state monad to do the parsing over a Data.ByteString.Lazy
16:13:33 <benmachine> attoparsec might do binary as well actually
16:13:46 <megatron242> Does this Does the binary package supports parsing doubles (serialized in C)?
16:14:04 <benmachine> megatron242: there's more than one way of serialising doubles
16:14:05 <mtnviewmark> no
16:14:31 <mtnviewmark> if you were to, for example, write the 8 bytes of a C double to a file (in binary mode) --- 
16:14:54 <mtnviewmark> which some protocols and file formats do, then - alas - no, Data.Binary will not deserialize that for you
16:15:21 <megatron242> Sorry, my IRC client got stucked... So, Does this does the binary package supports parsing doubles (serialized in C)?
16:15:23 <nominolo_> the binary package (or attoparsec) allows you to parse binary data (using custom instances)
16:15:27 <mtnviewmark> what you'd need would be http://hackage.haskell.org/package/data-binary-ieee754
16:15:33 <mtnviewmark> Data.Binary.IEEE754
16:16:15 <Zao> megatron242: You haven't even said how you wrote it out on the C side. Or described how the data is encoded in exact terms.
16:17:10 <nominolo_> mtnviewmark: hm, it uses unsafePerfomIO internally.  That can be slow under some circumstances
16:17:20 <nominolo_> (specifically: deep stacks)
16:17:22 <mtnviewmark> yes- it can...
16:17:37 <mtnviewmark> I was going to add, don't use that code if you need to do 1000s of 'em
16:18:25 <megatron242> It's written using fwrite()
16:18:35 <megatron242> with a pointer referening to a double
16:18:48 <megatron242> On any rate, Data.Binary.IEEE754 seems to be what I was looking for.
16:18:52 <Zao> So it's the octets dumped in platform endianess.
16:18:59 <mtnviewmark> whee!
16:19:07 <Zao> megatron242: You however, said fwrite("%d",... which is completely invalid syntax.
16:19:35 <mtnviewmark> if you need to do lots of them, then you can read them as Word64, and use something like this: https://bitbucket.org/lindenlab/llsd/src/340154853d86/haskell/Network/Format/LLSD/IEEE754.hs
16:19:38 <megatron242> Zao: Yes, that was stupid. It's 2.18AM from where I'm writing this...
16:19:42 <mtnviewmark> it is GHC specific, but fast
16:19:49 <revenantphx> mtnviewmark: wow you ninja'd me.
16:19:52 * Zao tucks megatron242 in.
16:19:55 <revenantphx> I was about to pull up that exact page :|
16:20:03 <revenantphx> Why does that even work though?
16:20:19 <mtnviewmark> oh - well - that's *my* code, so I knew it was there
16:20:33 <revenantphx> Does it just map to a C cast?...
16:20:34 <Bynbo7> eh
16:20:39 <revenantphx> somehow... >_>
16:20:40 <Bynbo7> heh*
16:20:40 <nominolo_> revenantphx: yes
16:20:45 <Zao> revenantphx: Unbox it, coerce the value, rebox it?
16:21:09 <revenantphx> It seems like the only safe time to use unsaferPerformIO and unsafeCoerce type stuff, is on things immediately entering or leaving "the system".
16:21:17 <nominolo_> revenantphx: it's like C++'s reinterpret_cast<...>
16:21:22 <revenantphx> nominolo_: mmk.
16:21:28 <megatron242> Thanks a lot guys...
16:22:05 <mtnviewmark> BTW if you use that code, depending on the version of GHC, you may have to make sure it doesn't get INLINEd
16:22:39 <revenantphx> mtnviewmark: theres a NOINLINE pragma I believe.
16:22:53 <revenantphx> yeah
16:23:01 <revenantphx> {-# NOINLINE function #-}
16:23:14 <mtnviewmark> yup 
16:23:20 <revenantphx> why not use that :\
16:25:07 <mtnviewmark> if I recall, we didn't need it when I wrote that, and then later, some rev of GHC failed at inlining that code and we did. I don't know why the NOINLINE pragmas aren't in the depo version -- perhaps still later GHCs fixed the issue?
16:25:07 <megatron242> Excuse my ignorance, but he code in that page would not run GHCi, only in GHC?
16:25:28 <revenantphx> GHC vs Hugs vs Helium etc
16:25:31 <revenantphx> I believe.
16:25:33 <mtnviewmark> megatron242: Note the pragma at the top
16:25:48 <mtnviewmark> you need to turn on MagicHash in ghci:   :set -XMagicHash   i believe
16:26:30 <revenantphx> Are there any seriously competing haskell compilers?
16:27:09 <copumpkin> sort of
16:27:23 <megatron242> mtnviewmark: Great, that did the trick
16:27:24 <copumpkin> JHC is fairly capable now, and UHC has some features that GHC doesn't have
16:27:30 <copumpkin> LHC seems to be on hold these days
16:27:39 <c_wraith> GHC has the greatest breadth.  But the ones copumpkin mentioned have their niches.
16:27:50 <megatron242> OK, once again, thanks to whole those who replied my question!
16:30:33 * hackagebot kit 0.6 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6 (NickPartridge)
16:30:36 <jmcarthur> i keep hearing that JHC is quite capable, but everything *i* try to use it i just find bug after bug after bug
16:30:41 <jmcarthur> *every time
16:31:37 <revenantphx> If you're using OverloadedStrings, how can you produce real strings?
16:31:46 <revenantphx> jsut by annotating them as String or [Char]?
16:31:56 <monochrom> yeah
16:32:19 <c_wraith> Or by using them somewhere that String is inferred
16:35:43 <elliott> Is there an explicit -no-threaded for GHC? i.e. use a non-threaded runtime
16:36:14 <c_wraith> it defeaults to a single-threaded runtime, but that runtime still supports green threads
16:36:55 <elliott> c_wraith: and yet.
16:37:00 <elliott> $ ghc hello.hs -static -optl="-static"
16:37:00 <elliott> /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/libffi.a(closures.o): In function `init_mparams':
16:37:00 <elliott> (.text+0x3e): undefined reference to `pthread_mutex_lock'
16:37:04 <elliott> ...lots of lines like that...
16:37:23 <monochrom> no, there is no explicit no-threaded option
16:37:27 <c_wraith> you forgot --make
16:37:51 <elliott> c_wraith: ah. :)
16:37:59 <revenantphx> uh oh guys, type error!
16:38:06 <elliott> c_wraith: wrong
16:38:09 <elliott> c_wraith: same thing with --make
16:38:16 <elliott> c_wraith: -optl="-pthreads" fixes it
16:38:22 <elliott> so, it's clearly trying to use the threaded runtime
16:38:28 <revenantphx> https://gist.github.com/753751
16:38:43 <revenantphx> getData is of type B.ByteString
16:38:52 <revenantphx> (Widget is some random thing being parsed)
16:38:53 <copumpkin> elliott: or the unthreaded runtime just doesn't not mention pthread stuff
16:39:05 <copumpkin> doesn't mean it's necessarily using it
16:39:06 <elliott> copumpkin: Strange definition of "unthreaded", then. :p
16:39:16 <elliott> True. The resulting executable is 1.7 megs.
16:39:22 <revenantphx> Anyone see the (probably obvious) solution?
16:39:23 <elliott> So it probably isn't putting any of pthreads in there.
16:39:54 <monochrom> conservative dependency chasing links in all kinds of junk not used
16:40:28 <revenantphx> monochrom: do you see it TT_TT?
16:40:48 <monochrom> libffi has some function that calls some pthread functions. are they called? you have to use strace or something to prove it.
16:41:03 <elliott> revenantphx: Oh come on, every Haskell user grapples with type errors every day.
16:41:07 <elliott> Surely you know how to fight them now.
16:41:13 <revenantphx> k should be of type (Stream a -> Iteratee a m b) though..
16:41:24 <revenantphx> apply that to something of type Stream a (Chunks [ByteString])
16:41:28 <elliott> monochrom: probably. ld is smart enough to omit all the pthreads crap if it isn't used though, so it doesn't matter too much
16:41:31 <revenantphx> and it should give me an iteratee, whats up here.
16:41:48 <revenantphx> elliott: I would, but this one just doesn't make sense.
16:42:01 <monochrom> what is the type of k?
16:42:10 <aristid> :t k
16:42:10 <lambdabot> Not in scope: `k'
16:42:13 <revenantphx> k is (Stream a -> Iteratee a m b)
16:42:17 <revenantphx> in this case I believe that's
16:42:25 <aristid> revenantphx: why the parens?
16:42:27 <revenantphx> Stream ByteString -> Iteratee ByteString IO Widget
16:42:36 <revenantphx> aristid: dunno
16:42:38 <revenantphx> k is a function
16:42:54 <revenantphx> getData :: Stream B.ByteString
16:44:33 <revenantphx> The type error doesnt make any sense to me >_<
16:44:42 <revenantphx> it says its in the pattern Continue k
16:45:00 <revenantphx> it acts like step is a ByteString D:
16:45:09 <revenantphx> which makes no sense.
16:45:17 <monochrom> Iteratee Widget m B.ByteString? Iteratee B.ByteString m Widget ?
16:45:24 <Bynbo7> revenantphx: i don't believe you're quite using iteratees in the right way
16:45:34 <revenantphx> Bynbo7: probably, I'm playing with some ideas
16:45:36 <Bynbo7> monochrom: it'll be the latter
16:45:43 <revenantphx> monochrom: ack
16:45:46 <revenantphx> thanks
16:45:58 <Bynbo7> oh, heh
16:46:14 <revenantphx> still, now its the same error but with Widget instead of ByteString
16:46:36 <revenantphx> :\
16:47:01 <Bynbo7> what's the type of getData?
16:47:08 <monochrom> is Iteratee a type synonym?
16:47:25 <revenantphx> no, newtype.
16:47:31 <Bynbo7> monochrom: it's basically Stream a -> m (Iteratee a m b)
16:47:32 <monochrom> is Iteratee a monad?
16:47:33 <revenantphx> getData is Stream B.ByteString
16:47:45 <revenantphx> newtype Iteratee a m b
16:47:55 <revenantphx> Bynbo7: thats k
16:47:56 <Bynbo7> revenantphx: are you sure about that? if it is, it will always return the same data
16:48:04 <monochrom> your do-block is in the Iteratee monad rather than the m monad.
16:48:05 <revenantphx> Bynbo7: yeah thats on purpose.
16:48:10 <Bynbo7> revenantphx: ah yes, my bad
16:48:28 <revenantphx> monochrom: but the resultant type is m (Maybe SomeException)
16:48:55 <monochrom> but the iter type is Iteratee ByteString m Widget
16:49:14 <monochrom> the monad is (Iteratee ByteString m) here
16:49:17 <revenantphx> which is (m Step ByteString m Widget)
16:49:28 <monochrom> no, it's a newtype, you said it.
16:49:46 <revenantphx> right right sorrry
16:50:18 <Bynbo7> revenantphx: so what you're really trying to write here is an enumerator?
16:50:22 <revenantphx> Bynbo7: kind of.
16:50:23 <monochrom> let N be a monad. if you see "step <- (haha :: N Widge)", what is the type of step?
16:50:26 <revenantphx> But not quite Bynbo7 
16:50:36 <revenantphx> hm
16:50:54 <revenantphx> monochrom: Widge(t)?
16:51:10 <monochrom> yes. now let N = Iteratee ByteString m
16:51:22 <revenantphx> hm
16:51:29 <Bynbo7> monochrom: step <- iter :: Iteratee s m a won't made step of type a
16:51:30 <monochrom> you may want runIteratee to undo the newtype
16:51:33 <revenantphx> ByteString m though...
16:51:36 <revenantphx> actually it says Widget now.
16:51:38 <Bynbo7> i don't think
16:51:44 <benmachine> Bynbo7: sure it will
16:51:46 <Bynbo7> make*
16:51:53 <revenantphx> Let me post more context.
16:51:58 <Bynbo7> hmm
16:52:06 <benmachine> Bynbo7: but that probably means that iter returns _|_
16:52:15 <revenantphx> https://gist.github.com/753751
16:52:20 <elliott> Are there any Linux syscall bindings for haskell?
16:52:22 <elliott> e.g. mount.
16:52:38 <hpc> elliott: all you need is a binding for a shell
16:52:46 <revenantphx> step <- iter should yield step :: Step ...
16:52:48 <elliott> hpc: that's rather suboptimal.
16:52:50 <revenantphx> from what I've seen.
16:52:53 <elliott> hpc: i would prefer the real mount syscall
16:53:02 <revenantphx> ack I know what the issue is.
16:53:04 <revenantphx> here we go...
16:53:16 <Bynbo7> revenantphx: can you post the definition of Iteratee too?
16:53:20 <Bynbo7> just paste it here
16:53:21 <revenantphx> got it
16:53:27 <revenantphx> the parameter should be (Iteratee i), not i
16:53:37 <revenantphx> http://hackage.haskell.org/packages/archive/enumerator/0.4.4/doc/html/src/Data-Enumerator.html#Iteratee
16:54:39 * hackagebot secure-sockets 1.1.0 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.1.0 (DavidAnderson)
16:55:02 <monochrom> yeah you need to runIteratee iter to get m (Step a m b)
16:55:23 <revenantphx> or change the param type, either works it seems.
16:55:55 <Bynbo7> revenantphx: is this an attorparsec parser?
16:56:06 <revenantphx> yes.
16:56:09 <monochrom> newtype X = X Y really means "X is no longer essentially Y"
16:56:18 <revenantphx> iterParser converts an attoparsec parser into an iteratee.
16:56:27 <Bynbo7> yeah
16:56:28 <revenantphx> Apparently through magic.
16:56:32 <revenantphx> :O
16:56:35 <Bynbo7> well, not really
16:56:39 <revenantphx> (not really, they're quite similar)
16:56:46 <monochrom> advanced technology
16:56:52 <revenantphx> attoparsec's incremental parsing is *very* Step/Iteratee-ish
16:56:54 <Bynbo7> they map very well onto each other, attoparsec parsers are almost iteratees to begin with
16:57:07 <revenantphx> Bynbo7: thats the first thing I thought when I saw iteratees.
16:57:15 <Bynbo7> heh, yeah
16:57:19 <revenantphx> What I'm trying to do however,
16:57:28 <Bynbo7> first thing i thought way "this is just like stream fusion"
16:57:31 <revenantphx> :|
16:57:36 <revenantphx> is there here instead of getting some value out of a parse, 
16:57:52 <revenantphx> this is for network code, so I need to be able to repeatedly kickstart the iteratee.
16:58:03 <revenantphx> (or create a new identical one and start it with what was left over from before)
16:58:17 <Bynbo7> well, that's the point of iteratees
16:58:30 <revenantphx> except once they hit the Yield step, they're done.
16:58:52 <Bynbo7> when one iteratee has finished consuming as much input as it needs, it returns its value, and the rest of the steeam
16:58:55 <Bynbo7> r*
16:59:16 <Bynbo7> yes, but they yield the value, and the rest of the stream
16:59:21 <revenantphx> right, so this just infinitely parses, and whenever yield is hit, acts on the value yielded, then recursively calls with the rest of the stream.
16:59:42 <Bynbo7> which you use other functions in the enumerator package to extract their values
16:59:58 <revenantphx> Bynbo7: ?
17:00:03 <Bynbo7> yes, so this is not how you want to write this code
17:00:14 <revenantphx> Can you pseudocode/paste it?
17:00:19 <revenantphx> How it should be done?
17:00:28 <revenantphx> I honestly have no idea I started reading this stuff last night.
17:02:00 <Bynbo7> i think the way you want to do things is: you have an enumerator which takes data from the network, which you would pass an iteratee that does something like say: do { len <- parseLengthIter; data <- getData len; csum <- getCheckSumIter; return (len, data, csum) } 
17:02:06 <Bynbo7> i think that's how it works
17:02:32 <revenantphx> I seriously can't read code in irc >_<
17:02:37 <revenantphx> one moment.
17:02:53 <revenantphx> ...what?
17:03:08 <revenantphx> what are parseLengthIter, getData and getCheckSumIter?
17:03:14 <revenantphx> why are checksums even involved here?
17:03:16 <Bynbo7> they're things i' ve made up
17:03:28 <Bynbo7> to demonstrate how you combine iteratees
17:03:34 <revenantphx> And what says I know the length of each packet at any given time?
17:03:41 <revenantphx> Why do I have to work with fixed lengths :\
17:03:49 <revenantphx> er, variable lengths.
17:03:53 <revenantphx> and not just blocks of data.
17:04:03 <revenantphx> Could you paste that a bit more... fleshed out? I'm really not seeing it.
17:04:10 <Bynbo7> oi, this isn't related to your exact example, i'm trying to teach you something more fundamental ;)
17:04:18 <revenantphx> sorry >_<
17:04:39 <revenantphx> I'm not getting it anyhow.
17:04:41 <revenantphx> :|
17:05:05 <Bynbo7> you'll see
17:05:08 <revenantphx> if the enumerator is getting data, why is getData in the iteratee.
17:05:18 <Bynbo7> (bare in mind i'm not 100% sure i'm correct about this)
17:05:40 <Bynbo7> getData shouldn't be in the iteratee, but we'll get to that, understand iteratees first
17:06:05 <revenantphx> that would seem to be an important thing... understand them... yes.
17:07:53 <Bynbo7> urgh
17:08:17 <Bynbo7> revenantphx: http://hpaste.org/42526/iteratees
17:08:51 <revenantphx> huh? I already pasted that bit for myself :P
17:08:56 <revenantphx> no need for you to do it TT_TT
17:09:13 <Bynbo7> here, parseData would be an iteratee of type (i hope...) Iteratee ByteString m (Int, ByteString, Int) say
17:09:13 <revenantphx> I got the data type once I did it, sorry.
17:09:19 <revenantphx> Sure.
17:11:56 <Bynbo7> you give it to an enumerator which produces ByteStrings, and then it will first pull out the length from the bytestrings, leaving the rest of the stream to then be processed by the getData iteratee, which would pull out len bytes of data, and when its done, would dive the remaining data to getChecksum to pull out a checksum. it would then yield the tuple, along with the remaining data in the stream, so you can pass it to another iteratee to c
17:12:26 <revenantphx> Right...
17:12:38 <revenantphx> so how is that so different from what I'm doing?
17:12:53 <Bynbo7> the part you're missing is the enumerator
17:12:58 <revenantphx> mmk.
17:14:08 <revenantphx> I'm missing one other bit anyhow.
17:14:34 <revenantphx> hm yeah, I see how an enumerator is the right move here.
17:15:04 <Bynbo7> ok, i need to be going to work :P
17:15:11 <revenantphx> oh, sorry to hold you up...
17:15:16 <Bynbo7> where i get to play with this stuff :D
17:15:23 <revenantphx> >_>
17:15:28 <revenantphx> where do you work?
17:15:30 <Bynbo7> s'all good, they're flexible with when i work
17:15:42 <Bynbo7> Tsuru Capital in Tokyo
17:16:32 <revenantphx> cool.
17:17:23 <revenantphx> btw, this is what mine looks like now
17:17:24 <revenantphx> https://gist.github.com/gists/753751
17:17:41 <revenantphx> it'd work if I could make a function from a stream value to an iteratee >_>...
17:17:54 <revenantphx> But yeah, it probably is missing the point.
17:18:36 <Bynbo7> are you sure you want an infinite loop? you're just throwing away the data you're parsing here
17:18:45 <revenantphx> This is a dummy example :P
17:18:51 <Bynbo7> ok :
17:18:54 <Bynbo7> )
17:18:58 <revenantphx> in a real case example, Foo Bar and Baz would actually have stuff in them
17:19:27 <revenantphx> https://gist.github.com/753751
17:19:28 <revenantphx> there
17:19:30 <Bynbo7> have you read michael snoyman's posts on the enumerator package?
17:19:31 <revenantphx> makes a bit more sense now :P
17:20:01 <revenantphx> which one is that?
17:20:22 <Bynbo7> http://docs.yesodweb.com/blog/enumerators-tutorial-part-1/
17:20:28 <revenantphx> oh, that
17:20:32 <revenantphx> yes, I've been using it.
17:20:36 <Bynbo7> there's three parts, helped me understand a lot better
17:20:38 <Bynbo7> ok
17:20:46 <Bynbo7> anyway, work time!
17:20:50 <revenantphx> yeah, I'm in the second part right now. bye bye.
17:28:18 <revenantphx> netjoin?
17:28:32 <revenantphx> if runIteratee unboxes Iteratee a m b into m (Step a m b)...
17:28:36 <revenantphx> then how can i do the reverse?
17:28:51 <revenantphx> an enumerator basically does that :|
17:29:18 <benmachine> Iteratee constructor?
17:30:07 <Twey> someIteratee :: Iteratee a m b; runIteratee someIteratee :: m (Step a m b); Iteratee $ runIteratee someIteratee :: Iteratee a m b
17:30:20 <Twey> Iteratee :: m (Step a m b) -> Iteratee a m b
17:31:08 <revenantphx> My case statement is basically doing what an enumerator could/should be doing.
17:32:07 <sciolizer> Is there a Haskell equivalent to the Python Cmd module?
17:32:24 <Twey> sciolizer: If there were, what would it do?
17:32:51 <kaf3ii> is there a library function  'f (x:xs) = [x:xs] : f xs'
17:33:33 <Twey> I don't think so
17:33:33 <sciolizer> Twey: idunno. loop between a prompt message, splitting the line, and executing a function mapped from the first word?
17:33:55 <Twey> :t let f (x : xs) = [x : xs] : f xs in f
17:33:57 <revenantphx> kaf3ii: what's xs'?
17:34:04 <Bynbo7> :t interact
17:34:04 <Twey> revenantphx: Quotation mark
17:34:10 <revenantphx> oh right :3
17:34:11 <Twey> λb got split
17:34:17 <Bynbo7> weak
17:34:24 <kaf3ii> revenantphx: f :: [a] -> [[a]]
17:34:26 <copumpkin> :t tails
17:34:31 <sciolizer> Bynbo7: readline support would be nice
17:34:33 <copumpkin> did you mean the [ ] there ?
17:34:48 <Bynbo7> sciolizer: there's a readline package
17:34:50 <Twey> sciolizer: Don't think so.  Readline is probably about what you want.
17:35:02 <sciolizer> k
17:35:12 <copumpkin> kaf3ii: tails seems like what you want, assuming the [] around the x:xs was not intentional
17:35:23 <copumpkin> otherwise, map pure . tails ;)
17:35:32 * Bynbo7 -> work (Bynbo7 -> Axman6)
17:35:43 <kaf3ii> oh
17:35:46 <copumpkin> > map pred "Bynbo7"
17:36:16 <monochrom> "Axman6"
17:36:25 <BMeph> > tails [0..3]
17:36:31 <kaf3ii> copumpkin: for input [1,2,3] it should return [[1,2,3],[2,3],[3]]
17:36:49 <copumpkin> then definitely tails, and you had an extra [ ] in your example :)
17:36:57 <copumpkin> tails has [] at the end there too
17:37:02 <BMeph>  -> [[0,1,2,3],[1,2,3],[2,3],[3],[]]
17:37:04 <copumpkin> which makes sense, really
17:37:18 <copumpkin> if you don't like that, init . tauils
17:37:40 <BMeph> kaf3ii: It has to have a '[]' at the end, since [3] = (3:[])
17:38:04 <monochrom> monkey with a crown
17:38:32 <BMeph> monochrom: Or just curly hair.
17:42:23 <kaf3ii> works now 'f [] = []; f (x:xs) = (x:xs) : f xs'
17:42:35 <Znudzon> hi. I have a little problem with installing Yi on mu ubuntu. Any can help ? (error said that i don't have HackerMain)
17:42:49 <kaf3ii> but wont give me that [] at the end.. 
17:43:07 <copumpkin> kaf3ii: it makes more sense for it to give you the [] at the end, but if you don't like it you're welcome to have it your way :P
17:43:15 <mauke> f [] = [[]]
17:43:59 <monochrom> [] : [] :)
17:44:14 <kaf3ii> mauke: thx for that =P.. everything now seems so clear
17:44:26 <mauke> f xs = xs : case xs of [] -> []; _ : xs' -> f xs'
17:45:20 <mauke> @src tails
17:45:27 <copumpkin> @get Cale 
17:45:38 <mauke> preflex: seen lambdabot
17:45:38 <preflex>  lambdabot was last seen on #haskell 1 hour, 3 minutes and 27 seconds ago, saying: Not in scope: `k'
17:46:21 <benmachine> @get-shapr
17:46:31 <revenantphx> :(
17:46:32 <benmachine> or something
17:46:38 <benmachine> oh hi
17:46:42 <revenantphx> :O
17:46:46 <copumpkin> @bot
17:46:51 <revenantphx> > print "Hello world"
17:46:54 <lambdabot> :)
17:46:58 <revenantphx> D:
17:47:00 <lambdabot>   <IO ()>
17:47:02 <benmachine> give her a little time to acclimatise
17:47:04 <revenantphx> @bot
17:47:05 <benmachine> she just woke up
17:47:10 <lambdabot> :)
17:47:16 <mauke> @src tails
17:47:24 <lambdabot> tails []         = [[]]
17:47:30 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
17:56:24 <kaf3ii> mauke: there it is :D
18:08:20 <revenantphx> Does anyone have any examples of iteratee's being used with network code?
18:08:30 <c3l> im learning about the Maybe. lets say I have a function that returns Nothing or Just a. how can I use that result, if lets say a is a number, 1 + Just 2 gives errors. so how is that useful?
18:08:56 <benmachine> c3l: you can pattern-match on the Maybe to recover the value
18:09:07 <Twey> c3l: You can get the value out of the Maybe, or you can push a transformation into the Maybe
18:09:13 <benmachine> often you'll use a function like fromMaybe to say "use what's in the Just, or a default value if it's nothing"
18:09:21 <Twey> > 1 + fromMaybe 0 (Just 2)
18:09:22 <lambdabot>   3
18:09:32 <Twey> > (1 +) <$> Just 2
18:09:33 <lambdabot>   Just 3
18:09:46 <Axman6> > succ `fmap` Just 2
18:09:47 <lambdabot>   Just 3
18:09:53 <parcs> don't scare the fellow
18:09:58 <Twey> … is the same thing in other words
18:10:02 <Axman6> hmm, that came out a lot more sus than anticipated
18:10:07 <revenantphx> or case statement :|
18:10:11 <Twey> A lot more sus?  :þ
18:10:13 <revenantphx> to pattern match it
18:10:14 <c3l> oooh, thanks for the examples!
18:10:15 <Twey> revenantphx: Ick
18:10:37 <Axman6> c3l: i would recommend you go and learn about the Functor class, it's super simple, and will help you here
18:10:43 <Twey> c3l: In practice, pushing a transformation in with ‘fmap’ (a.k.a. <$>) tends to be more useful than extracting the value immediately
18:11:22 <c3l> Axman6: will do, thanks
18:11:27 <Twey> You generally only want to extract the value when you can provide a suitable default for the Nothing case
18:11:42 <Twey> Up until then, if you just push more transformations in there, you don't have to worry about it
18:12:03 <Axman6> @src Functor
18:12:03 <lambdabot> class  Functor f  where
18:12:03 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:12:11 <Axman6> just to get you started c3l ;)
18:12:20 <c3l> Twey: hm, I guess it will take some getting used to. the haskell syntax is really convoluted and strange untill you understand it, then its just awesome :)
18:12:42 <Axman6> it's just maths, how can it be strange :O
18:12:50 <Twey> Haskell syntax is not maths >.>
18:13:03 <Axman6> >_>
18:13:32 <Axman6> well, sure it is, it's just a strange notation
18:13:34 <Axman6> :P
18:13:56 <Twey> Heh
18:14:06 <c3l> Axman6: exactly my point, its all strange until you get it, then its almost natural =)
18:14:18 <c3l> at least so far, I hope it will remain the same
18:14:37 <Axman6> before long you'll be dreaming in haskell
18:14:46 <benmachine> heh
18:17:00 * hackagebot xmobar 0.12 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.12 (JoseAntonioOrtegaRuiz)
18:28:43 <sciolizer> What's the best way to do exceptions these days?
18:29:00 <Axman6> using exceptions? :\
18:29:03 <blackdog> throw 'em good and hard.
18:29:05 <Axman6> see Control.Exception
18:29:41 <Axman6> better catch those exceptions or they'll hit you in the stack!
18:30:14 <sciolizer> hmm
18:30:39 <sciolizer> What if I want to be able to catch the exception from pure (monadic but not IO) code, but I want the collection of catchable exceptions to be extensible?
18:31:30 <Axman6> well, exceptions aren't pure, so you can't really catch them in pure code
18:31:53 <Axman6> you can use Either to represent errors, but that's not quite the same
18:32:06 <sciolizer> I was thinking something along these lines:
18:32:06 <sciolizer> http://nominolo.blogspot.com/2007/05/towards-better-error-handling.html
18:32:14 <sciolizer> But I wasn't sure if that had been improved upon.
18:34:00 <Axman6> hmm, is Error still used?
18:34:02 <sciolizer> I guess Control.Monad.Error is what I want.
18:34:24 <sciolizer> But it just seems like everybody frowns on mtl these days.
18:35:04 <lispy_> sciolizer: yes, mtl2 breaks a lot of code
18:35:12 <lispy_> sciolizer: plus all the other documented issues
18:35:28 <Axman6> i thought the point of mtl2 was to not break lots of code, just play nicer with transformers
18:35:51 <lispy_> Axman6: Well, getting rid of exported constructors wasn't such a great idea in that case :)
18:36:22 <Axman6> i'm not familliar with the whole thing
18:36:49 <lispy_> Axman6: and now we get the joy of having mtl1 and mtl2 in the deps of things we want to build (although, with cabal-dev this isn't so bad)
18:37:22 <lispy_> Axman6: IMO, mtl2 is an attempt to make people stop using mtl by releasing an incompatible release
18:37:31 <gienah> the mtl-1 to mtl-2 upgrade incompatibility seems really confusing to a Haskell newbiew
18:37:54 <benmachine> it's a major version upgrade
18:38:03 <benmachine> surely incompatibility is expected
18:38:57 <lispy_> benmachine: Well, mtl has documented flaws and now I have to fix code that uses it.  I might as well use something else.
18:39:17 <lispy_> That's what I'm trying to say, anyway
18:39:23 <benmachine> lispy_: what I think has happened is that people realised that monads-tf was better
18:39:28 <benmachine> so they basically switched to that
18:39:35 <benmachine> but they kept the mtl name because it has momentum behind it
18:39:47 <benmachine> er
18:39:49 <benmachine> monads-fd
18:39:55 <gienah> On gentoo I had to conditionally patch lambdabot to compile with mtl-2
18:40:07 <lispy_> gienah: we had to do that for darcs too
18:40:27 <lispy_> gienah: darcs can accept mtl1 or mtl2 in a-yet-to-be-released version
18:41:05 <gienah> lispy_: that's neat, thanks for going to the trouble to make it compile with either mtl-1 or mtl-2
18:41:52 <lispy_> Unless I'm missing some undocumented cabal feature (likely, the manual is seriously out of date), then cabal doesn't have good support for communicating to the compiling code which version of a library was picked.  So you kind of have to do some trickery in the cabal file everytime this comes up.
18:42:07 <benmachine> lispy_: CPP macros?
18:42:12 <benmachine> although, ew, cpp
18:42:18 * benmachine prefers cabal file trickery
18:42:18 <lispy_> benmachine: I used CPP in the end
18:42:30 <lispy_> CPP + cabal file trickery
18:42:49 <gienah> I used ebuild trickery to see if mtl-2 was installed, if so, apply the mtl-2 patch
18:42:55 <lispy_> http://www.mail-archive.com/darcs-users@darcs.net/msg17201.html
18:42:59 <lispy_> That has my patch in it
18:43:20 <lispy_> +      if flag(old_mtl)
18:43:20 <lispy_> +        cpp-options:  -DMTL1
18:43:42 <lispy_> +#ifdef MTL1
18:43:42 <lispy_> +state = State
18:44:25 <Saizan> in dist/build/autogen there's a .h file that's automatically generated by build that defines macros to check the version of the packages picked
18:44:41 <benmachine> lispy_: it is simpler than that
18:44:41 <lispy_> then you need one more bit of magic
18:44:48 <benmachine> as Saizan said
18:44:58 <lispy_> Saizan: the macro there lets you check some min version
18:44:58 <benmachine> MIN_VERSION_mtl(1,0,0) I guess
18:45:05 <benmachine> er rather
18:45:10 <benmachine> MIN_VERSION_mtl(2,0,0)
18:45:20 <lispy_> I didn't want to check for a minimum version
18:45:30 <benmachine> #if !MIN_VERSION_mtl(2,0,0)
18:45:31 <lispy_> I wanted to know if I had mtl 1 or 2
18:45:32 <benmachine> state = State
18:45:35 <benmachine> #else
18:46:02 <benmachine> state = StateT . Identity -- or whatever, I don't remember
18:46:03 <lispy_> and dist/build/autogen is not documented
18:46:13 <Axman6> MAJOR_VERSION_mtl(1)?
18:46:22 <Axman6> (such a thing should exist)
18:46:55 <benmachine> I got a patch to cabal's user guide accepted fairly promptly :)
18:47:13 <benmachine> in fact, my patch inspired duncan to rewrite some of the bits I improved as well
18:47:17 <lispy_> why is the cabal manual NOT a wiki?
18:47:26 <Axman6> aye :\
18:47:28 <lispy_> I've asked this before, BTW
18:47:31 <gienah> ormaaj: I used these keywords and also symlinked a file in package.unmask to the keywords file, for ghc 6.12.3: http://hpaste.org/42043/etcportagepackagekeywords ghc 7.0.1: http://hpaste.org/42044/gghc7etcportagepackageke
18:47:31 <Saizan> lispy_: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#cpp
18:47:38 <lispy_> I think the problem is that no one is developing cabal these days
18:47:38 <gienah> sorry: wrong channel
18:47:54 <Saizan> it is actually documented :)
18:47:58 <benmachine> lispy_: sure they are! just not as enthusiastically as GHC or whatever
18:48:35 * Axman6 can't help thinking that cabal needs to be replaced with something less flaky and painful
18:48:57 <lispy_> Saizan: maybe that's newer than when I was doing this stuff
18:49:20 <lispy_> It's certainly not within the realm of things I grepped for
18:49:24 <Saizan> i'd be very surprised if it was newer than mtl2
18:50:15 <lispy_> So, why is that macro named MIN_VERSION_foo?  I looked at that macro and it looked like gibberish and the name made me think it was something totally different
18:51:15 <Saizan> cabal pick some version for foo
18:51:33 <benmachine> Axman6: what, like autoconf? >_>
18:51:41 <benmachine> as build systems go I think cabal is one of the nicer ones I've used
18:51:45 <Saizan> and then that macro let you check if the version picked is greater or equal than the version you specify in the call
18:52:14 <Saizan> though i'm not convinced that's the best name either
18:52:46 <benmachine> what *is* the best name, then?
18:52:49 <lispy_> that page should also tell you where the file is.
18:52:52 <Axman6> benmachine: i'd agree if it didn't frigging break itself every three or four days on my system
18:53:06 <lispy_> Once I knew about that file I still didn't find that snippet in the docs
18:53:12 <Axman6> how come languages like perl and python and ruby can get this stuff right, but we can't?
18:53:18 <lispy_> It would also be nice if the file that is autogenerated explained the macros at the top
18:53:25 <blackdog> Axman6: i've got problems with Cabal, but it's still better than anything else i've used in a static language
18:53:34 <benmachine> Axman6: because we insist on using alpha of everything
18:53:43 <blackdog> rubygems and CPAN are like a dream of productivity
18:53:44 <Saizan> lispy_: i guess the docs don't want to include an implementation detail like that
18:53:46 <benmachine> on using pre-pre-super-pre-release
18:54:08 <Saizan> lispy_: you could open a ticket, though
18:54:39 <lispy_> benmachine: So one reason why I say that it's not actively developed is that some moderately serious bugs have gone for something like 7 months now without updates, and I know some patches have been sent from around that time without making it into a release.
18:54:48 <lispy_> Saizan: They don't seem to get worked on
18:54:58 <ormaaj> I tried quickpkg'd my ghc and tried ghc 7 a month ago to see if it magically worked without spending >5 minutes messing with it. It didn't, so i reverted :)
18:56:07 <lispy_> If we're going to all be recommending Cabal to each other, it would be nice if it had more development momentum
18:56:19 <lispy_> I'd really like to spend my hacking time on non-cabal hacking.
18:56:35 <lispy_> But, I feel like if I'm going to get anything done, cabal needs some workd
18:56:55 <gwern> lispy_: well, of course we're recommending cabal to each other. at this point, what else would we recommend?
18:57:21 <Saizan> it does need more people, considering the number of open tickets
18:57:31 <lispy_> gwern: this is usually where someone mentions nix ;)  (I have no idea about it)
18:58:13 <kaf3ii> is there a quick way to do:     [Just 1, Nothing, Just 3] -> [1,3]
18:58:16 <Saizan> i'm pretty sure nix calls cabal to build..
18:58:35 <lispy_> kaf3ii: catMaybes
18:58:35 <Saizan> kaf3ii: catMaybes
18:58:42 <kaf3ii> thx
18:58:44 <lispy_> > catMaybes [Just 1, Nothing, Just 3]
18:58:45 <lambdabot>   [1,3]
18:59:08 <byorgey_> (be sure to  import Data.Maybe)
19:00:08 <lispy_> I really hope you guys don't think I'm complaining about Duncan.  I'm not.  He's busy, that's fine.  I just want something to change with respect to Cabal.  I think that thing is, I want to see it developed more actively by someone other than me.  I feel bad saying it, because that's not fair.
19:00:26 <Saizan> lispy_: anyhow, if you don't even open tickets it's pretty hard to imagine it'd get fixed
19:01:01 <lispy_> Saizan: I was more eager to open tickets a while back.  I have explained several of my frustrations with it to Duncan, FWIW.
19:01:31 <Axman6> lispy_: you're not alone in those feelings
19:01:55 <lispy_> cabal-dev helps with some of the frustrations
19:02:08 <Axman6> yeah, i must try it out sometime
19:02:09 <lispy_> Having per-project packages really helps with dependency hell
19:02:38 <lispy_> and you don't get into a situation where you killed your boot libs
19:03:32 <Saizan> that doesn't happen anyway if you stick to --user, though cabal-dev looks nice, in fact it'd probably make sense to just merge it in cabal-install
19:03:53 <lispy_> Saizan: then what happened to my ghc install last night?
19:04:11 <Axman6> Saizan: i'm sorry, it happens to me all the time
19:04:17 <lispy_> Saizan: I only use --user but somehow 'ghc-pkg check' was freaking out
19:04:27 <lispy_> and linking was failing
19:04:42 <Axman6> cabal-install keeps installing new version of directory, and then ban, packages depend on two versions
19:04:50 <Axman6> bam*
19:04:59 <Saizan> lispy_: your installation had something weird about the .o files for ghci, it seems it'd be some problem with your system
19:05:11 <lispy_> Saizan: merging it may make sense.  But, it would be nice to separate cabal-install into a few more libraries to make it easier to do proof-of-concept tools like cabal-dev.
19:05:22 <Saizan> Axman6: right, but it can't screw your boot libs, they are never touched if you don't pass --global
19:05:54 <Saizan> lispy_: yep, it should export an api, maybe in a separate hackage-client package
19:06:02 <Axman6> whoopdeedo, i'm so glad my boot libs are fine, i just can't build anything, that's not a big problem at all
19:06:20 <lispy_> Saizan: yes, hackage-client is the name we were thinking
19:06:28 <Saizan> Axman6: if you unregister the problematic user lib you get a working system back
19:06:41 <Mathnerd314> @pl (\(Test _ x) -> cast x)
19:06:42 <lambdabot> (line 1, column 9):
19:06:42 <lambdabot> unexpected "_"
19:06:42 <lambdabot> expecting operator or ")"
19:06:57 <lispy_> I think ghc/Cabal need to agree not to install or upgrade certain packages without --force
19:07:10 <Axman6> yeah
19:07:12 <lispy_> Regardless of where it puts them
19:07:39 <lispy_> And, I know some people are pulling their hair out about the lack of parallel builds
19:07:57 <Axman6> Saizan: when you've just done a clean install of ghc, removed all of .cabal and .ghc, and then run cabal install foo (i forget what it was exactly) and it breaks my system, i get very pissed off
19:08:03 <Saizan> even just fixing the bug that makes Cabal confused about what it installed would prevent the breaking :)
19:08:07 <lispy_> IIRC, it's Halvm builds that are really painful now that you can't build it in parallel
19:08:18 <lispy_> Painful in terms of wait
19:08:19 <Mathnerd314> ^ is there some nice way to do f (\(Haskell _ x) -> cast x) involving pattern guards and/or view patterns?
19:09:04 <lispy_> Saizan: confused about what it installs?
19:09:19 <lispy_> I wonder if it would help if cabal tracked the -f flags that you built with
19:09:36 <Saizan> lispy_: i mean the problem highlighted in the first Cabal FAQ
19:09:42 <jmcarthur> honestly i think GHC is the thing that should support parallel builds. it would probably be easy to have it naively use forkIO at first, then later improvements could be stuff like avoiding reloading data from .hi files if the data is already in memory from building a different module and stuff like that
19:10:35 <lispy_> Saizan: ah yeah, the diamond dependency problem?
19:10:41 <Saizan> lispy_: i think it does track the -f flags in the "world" file now (or the devel version)
19:10:45 <Saizan> lispy_: no.
19:11:06 <jmcarthur> of course memory has to be reclaimed somewhere. you don't want to have an entire project in memory at once unless you're doing crazy things like whole program optimization. so there's always a tradeoff
19:11:13 <lispy_> Saizan: the first one here? http://www.haskell.org/cabal/FAQ.html
19:11:45 <Saizan> lispy_: yes, which is not the "diamond dependency problem"
19:12:10 <lispy_> jmcarthur: http://hackage.haskell.org/trac/ghc/ticket/910
19:12:44 <jmcarthur> lispy_: that's not *quite* what i had in mind
19:13:16 <monochrom> "triangle dependency problem"? :)
19:13:42 <lispy_> jmcarthur: http://hackage.haskell.org/trac/hackage/ticket/447 ?
19:15:07 <jmcarthur> lispy_: that would be a good one for cabal-install, but still isn't quite what i meant when i was talking about ghc
19:15:56 <jmcarthur> lispy_: i was suggesting that ghc could build more than one module at a time (similar to -jN), but in a single process so that it can also potentially share some work across modules instead of reloading and recomputing a lot of the same stuff for each module
19:16:20 <lispy_> jmcarthur: ah yeah.  And Haskell threads are lighter than processes
19:20:58 <lispy_> Axman6: BTW, nice tee implementation on reddit
19:21:20 <lispy_> When I build ghc, I see messages like this: time-1.2.0.3: file Data/Time/Calendar.hi is missing (ignoring)
19:21:30 <lispy_> have you guys ever seen that before?
19:22:26 <lispy_> I'd use a binary but my version of OSX is 10.5 and they are built specifically for 10.6
19:29:01 <Axman6> lispy_: thanks :) the original author brought up some good points about it though
19:29:12 <lispy_> oh really?
19:29:17 <lispy_> I'll reload my tab
19:29:48 <Axman6> yeah, it doesn't output lines, rather waits for 4096 bytes to be input then writes (i think)
19:30:39 <Saizan> hSetBuffering LineBuffering should fix that
19:30:41 <lispy_> Axman6: you could fix that
19:30:45 <Axman6> sure
19:31:01 <lispy_> ghc-7.0.1: file Vectorise/Vect.hi is missing (ignoring)
19:31:13 <lispy_> Should I be concerned?  I get a lot of those messages building ghc7
19:31:31 <Axman6> i think the usage i was thinking about is less frequent than the line by line case
19:31:47 * Axman6 will have to test when he gets home
19:31:49 <lispy_> I may just give up on ghc7 for now
19:41:29 <lispy_> Oh, now this cool: http://www.patch-tag.com/r/merehap/HusyHox/wiki/
19:41:35 <lispy_> I'm really happy to see that project
19:41:49 <shachaf> @seen mtnviewmark
19:41:49 <lambdabot> Unknown command, try @list
19:41:49 <preflex>  mtnviewmark was last seen on #haskell 3 hours and 16 minutes ago, saying: you need to turn on MagicHash in ghci:   :set -XMagicHash   i believe
19:42:09 <Axman6> lispy_: that is cool :) a haskell based linux distro would be fun
19:42:16 <lispy_> Yeah it would
19:42:54 <lispy_> I actually sent a message to -Cafe asking for that project at one point.
19:43:04 <lispy_> I'm glad to see I'm not the only one who likes the idea
19:43:23 <Axman6> would be a great way to show that haskell can actually be used in the real world
19:43:33 <Axman6> nix is a haskell thing isn't it?
19:44:21 <Axman6> heh: standardUtil "arch" False True False False True Nothing
19:47:28 <benmachine> smooth
19:49:42 <lispy_> yikes
19:50:00 <blackdog> that'd be one of those self-documenting APIs
19:50:09 <blackdog> types really help out there :)
19:50:36 <blackdog> (it's 18, right? 2 + 16?)
19:50:52 <blackdog> oh, wait, that last one's a Maybe. #markfail
19:50:57 <monochrom> haha
19:51:11 <monochrom> @quote monochrom 17
19:51:11 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
19:53:51 <lispy_> Axman6: looks like nix is mostly C++ and xml: http://hydra.nixos.org/build/768489/contents/5
19:54:14 <Axman6> hmm, there was something to do with a lot of haskell use on nixos i thought
19:54:47 <lispy_> the about page describes it as being a pure package manager in the same sense as Haskell
19:56:04 <monochrom> "a movie based on haskell" :)
19:56:28 <lispy_> Lambda of the Rings?
19:56:53 <Saizan> lord of the lambdas makes more sense
19:57:10 <copumpkin> lord of the semirings
19:57:18 <monochrom> i, nix
19:57:52 <lispy_> I nix,  you nix, we all nix for unix.
20:01:07 <applicative> When did Oleg change all the types for Iteratees et. al? 
20:01:52 <applicative> Has it thrown the Iteratee/Enumerator comunity into a state of confusion.
20:02:50 <applicative> http://okmij.org/ftp/Streams.html#design  -- the "Done" or "Yield" term no longer has the extra bit of stream that it didn't use; it's just Done a
20:04:57 <Axman6> applicative: it's causing some real problems here
20:05:10 * ddarius should probably have done more grocery shopping.
20:05:58 <applicative> The new type is for pure iteratees is the fixed point X = Either a (State Stream X)
20:06:26 <applicative> Axman6, really? I didn't know you were a member of the ... uh ... iteratee community
20:07:04 <djahandarie> applicative, he just hasn't submitted his formal application yet
20:07:25 <applicative> I see.   A fellow traveller
20:07:40 <Axman6> well, i'm not, but we're using them quite a bit here, and it's causing a lot of frustration converting from an older version to the latest
20:07:58 <djahandarie> Also he probably doesn't have the money for the 10000USD member's fee
20:08:34 <applicative> djahanderie, i thought it was the 10000000 iq  points fee
20:09:03 <shachaf> Join the co-iteratee community. They pay members 10000 co-USD.
20:09:11 <monochrom> hahaha
20:09:25 <applicative> Axman6, so you mean not the difference between the Iteratee and Enumerator packages on hackage respectively, but with the revised Oleg modules?
20:09:58 <applicative> Axman6, I mean, the latter is what you're being frustrated by?
20:10:18 <applicative> It seems in principle nicer.  Just that so much labor has gone into fretting about the other(s)
20:10:44 <Axman6> applicative: talk to lostman__, he can tell you more about his pain ;)
20:11:17 <applicative> Oh I see, don't know lostman.   
20:12:10 <applicative> lostman__ ping, reveal all. 
20:13:25 <ddarius> Solution: Don't use libraries.
20:13:28 <applicative> anyway, having fretted about them once again in a halfwitted way, the revised modules threw me completely. 
20:13:56 <applicative> ddarius, I was just more interested in whether the new version would be more perfectly intelligible. 
20:14:55 <applicative> it's more obviously a variant  of a standard state type, with stringy things keeping state
20:15:31 <applicative> ddarius, are we allowed to use the prelude??
20:17:03 <ddarius> Using Haskell at all is already too much opacity.
20:17:05 <applicative> more interesting is that the new version would seem to contain an implicit concession of error on the part of Oleg, which has a certain charm
20:17:38 <applicative> ddarius, what, but what do you recommend?
20:19:35 <ddarius> Building discrete components by hand, but machine code is a baby step in the right direction.
20:21:25 * ddarius considers making a blinker using a Leyden jar and a coiled wire.
20:21:28 <applicative> but arent 'discrete components' mere macroscopic aggregates, hiding the objects of physics from us?  
20:22:20 <ddarius> That's why you have to build them.
20:22:35 * applicative proposes to find someone who has implemented a rational programming language on stock hardward; he will then follow him
20:22:36 <ddarius> Simply using pre-existing discrete components would not be acceptable.
20:23:22 <applicative> I see, so I piece together fundamental particles?  
20:24:19 <applicative> That would take very fancy equipment; opacity would again reign. 
20:24:24 <ddarius> applicative: That would be ideal because then you could make something that doesn't weigh ten pounds.  However, the tools to do so would themselves be opaque.
20:24:30 <ddarius> Exactly.
20:24:45 * BMeph proposes to find someone who has implemented a rational programming language
20:24:58 * ddarius proposes to find someone
20:25:09 * BMeph proposes to find someone who has implemented a rational programming language
20:25:13 <Saizan> also fundamental particles are mere high intensity regions in the corresponding fields
20:25:16 * Axman6 proposes to someone
20:25:17 * applicative wonders with Scripture, "Can anything good come from Glasgow?"
20:25:34 * BMeph proposes
20:31:40 * BMeph was really expecting someone else to dispose by now...
20:32:14 <applicative> > "disposes"
20:32:15 <lambdabot>   "disposes"
20:32:41 <BMeph> > text "disposes"
20:32:42 <lambdabot>   disposes
20:32:53 * BMeph WinZ0rZ!
20:32:55 <applicative> damn, too fast for me..
20:33:19 * applicative concedes defeat, as usual
20:35:49 <applicative> > text "says, BMeph proposes" $$ text "disposes"
20:35:50 <lambdabot>   says, BMeph proposes
20:35:50 <lambdabot>  disposes
20:36:08 <lispy_> otto_s_: question, how do *you* convert from latex to html?
20:36:26 <lispy_> gah, sorry otto_s_ my client auto correct OT: to your nick
20:36:38 <lispy_>  OT : question, how do *you* convert from latex to html?
20:36:46 * applicative affirms there is only one true way
20:36:56 <lispy_> I was thinking of using tex4ht
20:36:59 <applicative> lispy_ what's wrong with pandoc?
20:37:08 * BMeph believes that way is suicide...
20:37:19 <lispy_> applicative: hmm...I thought pandoc had really pitiful support for reading latex (or maybe none at all)
20:37:40 <applicative> it reads latex, i have convince many to move to it from some of the others.
20:37:56 <jmcarthur> it's always worked fine for me
20:37:59 <lispy_> applicative: I will be doing maths and other custom stuffs
20:38:07 <jmcarthur> pandoc supports that fine
20:38:09 <applicative> it is very far from perfect, expecially if you use lots of esoteric packages and your own macros, etc, which you probably do
20:38:21 <applicative> math is left alone
20:38:24 <applicative> or can be
20:38:30 <lispy_> Is it possible to use latex without custom macros??
20:38:42 <jmcarthur> pandoc supports a few different ways to render math into html, even
20:38:51 <applicative> i use the same preamble and never vary
20:39:03 <lispy_> Let me back up and explain what I'm trying to accomplish
20:39:28 <lispy_> I want to write a large document that needs good support for math and I have to convert to html and apply my own CSS at the end
20:39:48 <lispy_> So, ending at docbook or xml would be fine actually
20:39:51 <jmcarthur> oh so this doesn't necessarily have to be latex?
20:40:02 <jmcarthur> my preferred way of using pandoc is to use markdown
20:40:04 <lispy_> Well, I know latex and I'm quite comfortable with it
20:40:08 <jmcarthur> pandoc's markdown supports latex math and stuff
20:40:10 <applicative> in principle this shouldnt be a problem with pandoc.  
20:40:13 <lispy_> and I need maths
20:40:17 <jmcarthur> ^^
20:40:55 <lispy_> I also need to assign a unique id to each paragraph in the final html
20:41:06 <applicative> pandoc also writes docbook, though I think it is not much used and thus not much tested
20:41:09 <lispy_> I'll probably use a hash of the paragraph for that
20:42:03 <applicative> lispy_ pandoc is the way; any difficulties you have with it will lead to improvements to the system :)
20:42:15 <lispy_> Oh, my
20:42:20 <lispy_> The way is before me! ;)
20:42:46 <applicative> pandoc stores section headings already for cross references, maybe you could extend this to paragraphs.  I haven't looked at it lately.
20:42:51 <jmcarthur> i love pandoc
20:43:01 <applicative> I love pandoc
20:43:10 <systemfault> I love turtles
20:43:18 <jmcarthur> but actually if you are rendering to html anyway you could probably use javascript to add those IDs to the paragraphs dynamically
20:43:36 <jmcarthur> *to generate those IDs for whatever purpose you have in mind, at least
20:43:47 <applicative> why do you need all the id's ?
20:45:32 <lispy_> applicative: it's a secret!  Nah, it's so that the javascript layer can match them up with the database layer
20:45:36 <applicative> lispy_, as jmcarthur says, you would write in markdown, putting math in the $$ brackets, then crank out latex for editing, and whatever for final submission
20:45:56 <lispy_> writing in markdown requires learning markdown
20:46:03 <jmcarthur> markdown is dead simple
20:46:15 <applicative> lispy_ there are a few fools traps, but you already know it
20:46:25 <applicative> we will teach you now. 
20:46:30 <applicative> new paragraph? same as latex
20:46:48 <lispy_> also, one of the tools that I will be using generates latex
20:47:07 <applicative> footnote?   {^note]   then elsewhere [^note]: This is a note
20:47:17 <applicative> you think pandoc doesn't generate latex?
20:48:14 <applicative> *italics* , **bold** , super^script^ sub~script~
20:49:02 <lispy_> I know pandoc generates latex
20:49:02 <applicative> lispy_ pandoc isn't just the right way, it's the *Haskell* way
20:49:14 <applicative> lispy_, to use anything else would be worse than a crime,
20:49:17 <jmcarthur> applicative is persistent
20:49:18 <applicative> it would be a mistake
20:49:21 <lispy_> I need to transform latex (some of it not under my control) to html/xml/docbook
20:49:39 <applicative> no, you need to transform markdown into all three
20:49:49 <jmcarthur> i've used pandoc to do that before, lispy_ 
20:49:52 <jmcarthur> latex -> html
20:49:58 <allbery_b> "some of it nopt under my control" kinda limis that
20:50:02 <jmcarthur> worked fine for me, but i didn't do anything fancy
20:50:30 <applicative> depends what it is like.  I have convinced several double-died latex users to convert
20:50:55 <applicative> they were forever faced with the torture that the publisher wants .doc
20:51:23 <lispy_> Let me try pandoc on my thesis, if that works I'll be ready to try it on "real" projects
20:51:31 <ddarius> http://en.wikipedia.org/wiki/Oxford_Electric_Bell
20:52:00 <applicative> your thesis is already written, in latex?
20:52:22 <lispy_> applicative: ya
20:52:53 <lispy_> pandoc -f latex foo.tex -t html (and where does the output go?  stdout?)
20:52:56 <applicative> see what happens.  pandoc can take sections.
20:53:10 <applicative> stdout, unless you write -o
20:53:20 <lispy_> The output looks funny
20:53:30 <lispy_> It should be the whole thing, it must ignore included tex files?
20:53:33 <applicative> the html is made with one of the haskell xml libs
20:53:40 <applicative> pipe it through tidy 
20:54:14 <revenantphx> You know what's even worse than peeking at your christmas presents?
20:54:28 <revenantphx> Peeking at your parents emails and seeing what you got for christmas :|.
20:54:33 <jmcarthur> talking about it in #haskell?
20:54:39 <revenantphx> jmcarthur: exactly.
20:54:45 <revenantphx> which is why all email must be in haskell.
20:54:47 <applicative> can latex give you the document with the included files?
20:54:56 <revenantphx> So little kids can't peek at their presents without first learning haskell.
20:55:06 <revenantphx> And that jmcarthur... will have given them the greatest gift of all.
20:55:19 <jmcarthur> i think you missed the point of what i said
20:55:24 <applicative> more knowledge of haskell?
20:55:34 <lispy_> applicative: I don't think it can.  I use \include{foo} to include foo.tex in the same directory
20:56:18 <applicative> http://johnmacfarlane.net/pandoc/scripting.html
20:56:30 <revenantphx> You'll probably need to preprocesses the LaTex somehow.
20:56:40 <revenantphx> I'm sure theres someway to run through a document and force it to resolve all includes.
20:56:52 <lispy_> applicative: http://dpaste.com/290054/
20:57:24 <applicative> you didn't specify a standalone document
20:57:41 <applicative> pandoc -f latex foo.tex -s -t html 
20:58:38 <applicative> revenantphx, i was looking at one of your github pastes, are you in ... uh.. western pa?
20:58:49 <revenantphx> applicative: 0.o....yes?
20:58:57 <applicative> same here. 
20:59:07 <revenantphx> how does it know....
20:59:14 <revenantphx> Wait, where are you?
20:59:17 <applicative> so is allbery_b who intervened above
20:59:19 <applicative> pittsburgh
20:59:22 <ddarius> One day lawer revenantphx is never heard of agaiv.
20:59:29 <applicative> hah
20:59:30 <lispy_> applicative: -s didn't seem to help
20:59:35 <revenantphx> Yeah, I'm in Pittsburgh too.
20:59:39 <applicative> cool
20:59:45 <revenantphx> I just moved here though.
20:59:56 <applicative> are you studying?
21:00:02 <revenantphx> In high school, yes.
21:00:13 <applicative> my god.  
21:00:38 * ddarius recommends "Great Scott" instead.
21:00:40 <revenantphx> Oh look. It says Pittsburgh on my git profile. That explains it.
21:00:54 <applicative> Yeah, that's what i noticed
21:01:14 <applicative> sorry, maybe it was tasteless to mention it.
21:01:23 <revenantphx> Nah, it's fine.
21:01:58 <ddarius> applicative is from the old generation
21:02:03 <revenantphx> I don't really think we have privacy on the internet anymore anyways.
21:02:28 <djahandarie> Anyone who wants to kill you can already get your information from somewhere else.
21:02:34 <revenantphx> Oh for sure.
21:03:27 <shachaf> ddarius: When does one become of "the old generation"?
21:03:28 <revenantphx> applicative: why "my god". :|?
21:03:50 <revenantphx> shachaf: By growing a "functional programmer forehead"
21:03:52 <applicative> oh, i was just thinking awfully young for so much brains
21:04:09 <revenantphx> right...
21:04:10 <applicative> going by a few bits of talk i've seen
21:04:19 <revenantphx> It's like a unix beard, shachaf, except functional programmers get it.
21:04:32 <revenantphx> I'm sure there are other bits that make me look like an idiot.
21:04:36 <applicative> what is functional programmer forehead like?  i doubt I have it
21:04:41 <djahandarie> I think there are a number of uni undergrads in here
21:04:49 * djahandarie counts...
21:04:54 <applicative> that's what i was expecting. 
21:04:55 <shachaf> #haskell has always had a bunch of high school students.
21:05:03 <ddarius> Technically I count, but that doesn't mean anything.
21:05:04 <applicative> revenantphx was, that's all
21:05:13 <ddarius> And the occasional middle schooler.
21:05:21 <revenantphx> D:
21:05:23 <revenantphx> Seriously?
21:05:34 <shachaf> ddarius: Count as what?
21:05:36 <applicative> ddarius, is still doing his equiv. test, but he insists on applying a nonstandard logic
21:05:40 <djahandarie> ddarius, how goes your uni stuff anyways?
21:05:48 <revenantphx> Well, theres a freshman studying at CMU at my school anyways >_>
21:05:53 <revenantphx> And he's been doing that since 7th grade.
21:06:02 <revenantphx> ...his mom must be a tyrant.
21:06:04 <ddarius> He must be pretty bad at it.
21:06:05 <shachaf> revenantphx: What's your school?
21:06:07 <revenantphx> I feel sorry for him more than anything.
21:06:17 <revenantphx> Winchester Thurston, private school.
21:06:28 <applicative> hah, i live about 10 blocks from there
21:06:32 <djahandarie> lol
21:06:35 <ddarius> shachaf: As an "undergraduate."
21:06:39 <avicenna> breeding future leaders
21:06:42 <revenantphx> applicative: D:
21:07:01 <revenantphx> applicative: quick experiment....
21:07:13 <applicative> ready
21:07:14 <revenantphx> Scream out your window as loud as you can "VIVA LA LAMBDA REVOLUCION"
21:07:14 <ddarius> avicenna: Bah, it would be far more impressive if the future leaders were being grown in a test tube.
21:07:18 <revenantphx> If I hear you I'll say so.
21:07:22 <applicative> no way
21:07:37 <ddarius> Breeding is so 4,000,000,000 BC.
21:07:39 <applicative> i am laughing though...
21:07:42 <allbery_b> it;'s not exctly hard to figure out where most of 128.2/16 is :)
21:07:51 <revenantphx> Let me put it this way...
21:08:00 <revenantphx> At one of my internships I was writing a simple mapping widget type thing.
21:08:05 * shachaf ended up deciding today not to start university for another N months.
21:08:10 <revenantphx> And the boss got me sample data from one of the clients (with scrambled names)
21:08:18 <applicative> there's allbery_b, western PA takeover of #haskell
21:08:20 <revenantphx> about 15000 data points
21:08:40 <revenantphx> These were from all sorts of stores, members of programs and so on.
21:08:52 <revenantphx> There were sooooo many pockets of like 10 consecutive neighbors.
21:09:00 <revenantphx> It was really really cool to sift through the data visualizing it.
21:09:19 <revenantphx> Anyways, my point is... you're a lot closer to similar people than you know.
21:09:46 * ddarius thought all the people like him were on the other side of the world.
21:10:40 <revenantphx> Hm... I have an idea for a little project some time.
21:10:48 <applicative> lispy_ we can figure this out.  The test on your thesis is not a rational one.  The chief difficulty will be keeping your friend's LaTeX in shape to be eaten by pandoc
21:10:56 <revenantphx> I'd like to put up on a site a simple map, and you can anonymously record your position...
21:11:05 <revenantphx> Then password protect it, and give everyone in #haskell the password.
21:11:11 <revenantphx> I think it would be interesting.
21:11:27 <djahandarie> haskellers.com has a map
21:11:28 <revenantphx> but hide the results until 200 people are on it I guess.
21:11:30 <shachaf> revenantphx: There's already a map of #haskellers somewhere.
21:11:34 <revenantphx> damnit :|
21:11:37 <revenantphx> all my ideas are taken.
21:11:49 <shachaf> revenantphx: Anyway, just give everyone in here the URL and look up the IP address. It should be close enough.
21:11:57 <djahandarie> Still only one other Haskeller in Connecticut. :(
21:12:14 <shachaf> djahandarie: Who?
21:12:15 <revenantphx> shachaf: I can use location services easily enough.
21:12:15 <applicative> yale is rife with haskellers
21:12:27 <djahandarie> applicative, not ones that are part of the community apparently
21:12:35 <djahandarie> shachaf, ray 
21:12:49 <ddarius> djahandarie: Like Paul Hudak?
21:12:55 <applicative> just ring up Hudak and say "Paul...."
21:13:03 <shachaf> djahandarie: Yes, I imagine that Yale is full of Haskell people.
21:13:50 * ddarius is also surprised that hosting haskell.org is not being part of the community.
21:13:58 <djahandarie> Haha
21:14:02 <djahandarie> True I guess
21:14:15 <djahandarie> (Though I don't know if I'd call that 'hosting'...)
21:14:25 * lispy_ just got off the phone
21:14:42 <lispy_> applicative: sorry about that, had a phone call
21:15:32 <applicative> lispy_, I think it shouldnt' be diffficult to handle this. If you are beginning anew you plan things so that pandoc or a scripted pandoc can handle everything
21:16:07 <lispy_> applicative: okay, but my friend is name Isabelle and doesn't always listen when I ask for latex.  In fact, I haven't yet checked to see what kind of latex Isabelle will be giving me.
21:16:35 <applicative> as long as it is inline or block it's ok
21:16:44 <lispy_> What do you mean?
21:17:15 <applicative> i was thinking of math, what is isabelle going to be cranking out?
21:18:17 <ddarius> djahandarie: They've been doing it for over a decade I believe.
21:18:19 <lispy_> applicative: I still need to find out.
21:18:21 * applicative is studying Isabelle's latex powers
21:19:11 <revenantphx> applicative: I don't take any offense right now, but if you try to find me I will be severely disturbed.
21:19:21 <revenantphx> Just saying.
21:20:21 <shachaf> @locate revenantphx
21:20:21 <lambdabot> Unknown command, try @list
21:20:28 <shachaf> @localtime revenantphx
21:20:29 <revenantphx> shachaf: creeper.
21:20:29 <lambdabot> Local time for revenantphx is 2010-12-24 00:20:02 -0500
21:20:54 <revenantphx> Oh come on, my hostname tells you where I am anyways.
21:21:00 <shachaf> revenantphx: I don't see why people care about other people finding out public information.
21:21:10 <applicative> revenantphx, if you try to find me, i will crush your lambda forehead
21:21:22 <revenantphx> applicative: My forehead has no such lambda on it :|
21:21:29 <revenantphx> Just a little bit of acne.
21:21:36 <applicative> oh ok then
21:22:13 <applicative> lispy_, I see, it looks like Isabelle+TeX is kind of a nightmare... you need the rationality of Pandoc to mediate all this for you.....
21:22:24 <revenantphx> applicative goes by night as the Errant Monad... a procedural killer who does not obey the laws (of monads).
21:22:41 <revenantphx> he unsafely performs many daredevil feats. 
21:22:54 <applicative> instance Monad Char where  return = 'c'
21:23:02 <lispy_> ah!
21:23:02 <revenantphx> D:
21:23:07 <lispy_> Overloaded instances!
21:23:08 <revenantphx> QUICK MODE +M
21:23:10 <revenantphx> HURRY
21:23:51 <applicative> you cant stop me, I have -XNoImplicitPrelude on my side....
21:24:44 <stepcut> applicative: :)
21:24:48 <revenantphx> No... no... no... D:
21:25:02 <revenantphx> He's going to break all of our skulls...
21:25:07 <revenantphx> and referential transparency!
21:25:32 <revenantphx> On a side note, can we PLEASE have a Haskell a capella group?
21:25:40 <copumpkin> is being of kind * -> * really a "law"?
21:25:51 <copumpkin> I figured laws were things we couldn't get our type system to enforce
21:26:07 <ddarius> copumpkin: Do laws cease being laws in Agda?
21:26:17 <copumpkin> ddarius: indeed!
21:26:20 <copumpkin> everything is just a term
21:26:35 <copumpkin> as it should be
21:26:42 <applicative> copumpkin is beyond law
21:27:25 <lispy_> applicative: if need be, I can generate the isabelle sources from the document that I feed to pandoc.  The invariant I want there is that 1) maths look like latex, 2) my isabelle source is forced to match what goes in the human readable version so I can always check if I introduced a typo
21:28:18 <applicative> lispy_ the Isabelle sources will be in code blocks?
21:28:36 <lispy_> "As a side-eﬀect of running a logic sessions, Isabelle is able to generate theory browsing information, including HTML documents that show a theory’s
21:28:36 <lispy_> deﬁnition,"
21:28:47 * hackagebot data-ordlist 0.4.4 - Set and bag operations on ordered lists  http://hackage.haskell.org/package/data-ordlist-0.4.4 (LeonSmith)
21:28:51 <lispy_> html documents could be handy
21:29:16 <lispy_> applicative: in the latex document I could put them in code blocks.  The normal isabelle way is the other way around.
21:29:18 <applicative> the html parser is much stronger in pandoc
21:29:27 <lispy_> applicative: I'd just extract an isabelle theory file from my latex
21:30:05 <applicative> how is the Isabelle distinguished from the rest?
21:30:50 <applicative> is like literate haskell?
21:31:00 <lispy_> applicative: http://isabelle.in.tum.de/verificard/obj-init/Example.html
21:32:15 <lispy_> applicative: It's more like the inverse of literate haskell.  The comments become tex and the non-comments are valid isabelle
21:35:03 <lispy_> applicative: admittedly, Isabelle looks like a pain to work with wrt automating it
21:35:16 <lispy_> applicative: I've only ever used it interactively
21:36:32 <copumpkin> iteratee.lhs = literatee!
21:36:35 <ddarius> When my water becomes ice, I will prepare the dough.
21:38:01 <Saizan> that sounds very zen
21:38:27 * ddarius imagines the layout of copumpkin's living room.
21:38:59 <copumpkin> covered in boxes still!
21:40:44 * ddarius has like ten days off and is no longer bound by a notion of local area.
21:40:53 * ddarius may drive somewhere arbitrary in America.
21:40:55 <lispy_> applicative: have I scared you away yet? :)
21:41:14 <lispy_> applicative: If you want to work on it more, I wonder if we should move it to #isabelle
21:41:15 <applicative> lispy_, if there were only going to be a bit of text by you, it wouldnt be worth it, I guess.  But if it is a written work, it'd be crazy to follow their method
21:41:28 <lispy_> heh
21:41:55 <ddarius> They are writing in Isabelle...
21:42:03 <applicative> lispy_, you can always add an isabelle writer to pandoc....
21:45:09 <applicative> header {* \isaheader{Example MicroJava Program} *}  suggests that some things fall outside the comments that arent code
21:46:08 <revenantphx> Well good night folks.
21:46:27 <applicative> be good. 
21:46:39 <revenantphx> Okay see,
21:46:42 <revenantphx> that was kind of creepy.
21:46:46 <revenantphx> Don't do that.
21:46:54 <revenantphx> >:|
21:47:01 <path[l]> lol
21:47:10 <path[l]> what "be good" ?
21:47:46 <revenantphx> Anyways... good night, and happy holidays
21:47:50 <lispy_> applicative: there are some directives in Isabelle that seem to be sort of special latex-only directives
21:48:03 <lispy_> applicative: I'm still learning isabelle...
21:51:13 <applicative> lispy_ yes, I'm looking at it.  Still, my main point way, would you really want to trust tex4ht, when the code looks like this: http://svn.gnu.org.ua/viewvc/tex4ht/trunk/src/tex4ht.c?revision=4&view=markup
21:51:56 <lispy_> heh
21:51:57 <lispy_> #define MYVOID
21:51:57 <lispy_> #define ARG_I(x)
21:52:08 * lispy_ closes eyes, "Looks okay to me!"
21:52:32 <lispy_> maybe this is why the author died suddenly and unexpectedly :(
21:53:12 <applicative> rather than, say, this https://github.com/jgm/pandoc-types/raw/master/Text/Pandoc/Definition.hs 
21:54:04 <applicative> or this  https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs
21:54:50 <applicative> "import Text.ParserCombinators.Parsec" -- you can't go wrong with source like that ....
21:55:34 * applicative doesn't want to learn Isabelle, agda is torture enough
21:56:14 <lispy_> agda changes too much
21:56:24 <lispy_> tutorials are broken 2 months after publishing :(
21:56:32 <lispy_> Beautiful syntax though.
21:56:40 <applicative> man, is it. 
21:58:13 <applicative> hey, surely literate agda is more rational
21:59:18 <lispy_> I can't use agda for this :(
21:59:33 <applicative> what were you saying though about the 'final' output, that it should be xml somehow?
21:59:53 <applicative> but not whatever Isabelle itself makes, as in the page you linked....
22:00:26 <applicative> by the way, pandoc parses that page and rewrites it seemingly without error.
22:02:15 <lispy_> applicative: oh, that's just an example isabelle file but rendered in your browser
22:02:46 <lispy_> applicative: Yeah, I was hoping to author my document using whatever the normal isabelle pdf generation is (it's quite adequate for pdf generation), but I want to redirect it to xml
22:03:00 <lispy_> applicative: once in XML I need to XSLT it a bit and then get HTML
22:03:18 <lispy_> applicative: I have to go right now
22:03:29 <lispy_> my gf showed up and I shoudn't ignore her :)
22:03:52 <lispy_> applicative: thanks for your help, the saga will continue later, and I'll study the isabelle authoring tools a bit more in the mean time
22:04:08 <lispy_> It could be that I should generate the isabelle input from pandoc or docbook or ...
22:06:00 * hackagebot json-enumerator 0.0.0 - Pure-Haskell utilities for dealing with JSON with the enumerator package.  http://hackage.haskell.org/package/json-enumerator-0.0.0 (MichaelSnoyman)
22:06:07 <applicative> lispy_ yes, it looks a little complicated.  The pdf-via-tex document associated with the html you linked is almost all rendered code, not much writing.
22:07:32 * applicative has evangelized enough for one day.  all he wanted was a trivial type error of the sort he can explain, to explain.
22:07:59 <Saizan> > 'a' == True
22:08:00 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
22:08:00 <lambdabot>         against inferred type...
22:08:06 <ddarius> May your type errors be interesting.
22:09:16 <applicative> Saizan, it's very simple, 'a' is a Char, True is a Bool....
22:10:37 <applicative> or to quote 'Fun with Type Function" " adding a speed to a distance is as much nonsense as adding a character to a boolean."
22:11:12 <applicative> substitute "equating with" for "adding to"
22:11:13 <djahandarie> I think the intuition goes the other way around with that, applicative 
22:11:37 <applicative> we should be able to add a Char and a Bool?
22:12:24 <djahandarie> Given that adding a character to a boolean makes no sense, then neither does adding a speed to a distance.
22:12:47 <ddarius> djahandarie: So adding a speed to a distance makes sense in PHP?
22:13:00 <Saizan> but if i add a distance to a speed i could get a vector in the 2-dimensional space of distance-speeds
22:13:13 <listofoptions> looool
22:13:17 <djahandarie> ddarius, fsvo sense.
22:15:00 <applicative> Conversely, most languages will accept the expression   " speed + distance  "  where speed is a variable representing speed, and distance represents distance, even though  adding a speed to a distance is as much nonsense as adding a character to a boolean.
22:15:08 <applicative> That's the spirit!
22:15:23 <avicenna> what do you call those ladders in apartment buildings?
22:15:29 <avicenna> outside the window
22:15:33 <applicative> the fire escape
22:15:40 <avicenna> thanks
22:15:43 <applicative> nice nick ibn sina
22:15:46 <avicenna> is there another term?
22:17:27 <systemfault> Wait.. PHP and makes sense in the same sentence?
22:18:43 <applicative> avicenna, do you know a word in another language?  
22:19:20 <applicative> If Oleg and Simon P J says most languages will accept it, then surely PHP accepts it. 
22:20:19 <ddarius> Pam's baking cooking spray smells amazing
22:20:33 <applicative> I'm sure Oleg and Simon P J know their PHP
22:21:10 * applicative hadn't considered huffing Pam
22:21:57 * ddarius would hope applicative had never considered huffing anything.
22:22:00 * applicative hadn't considered huffing PHP either
22:22:18 <systemfault> PHP rots the mind.
22:22:19 <Saizan> so much reverence around here :)
22:22:48 <systemfault> I wonder what Dijkstra would say about PHP... because he hated BASIC..
22:23:09 <systemfault> And BASIC is an example of elegance compared to PHP
22:24:08 <applicative> "stepcut says: I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for"
22:24:22 <stepcut> :p
22:24:38 <systemfault> :)
22:24:46 <stepcut> that's why i use happstack now ;)
22:25:10 <monochrom> haha
22:28:52 <applicative> The software my school uses for turning in grades has a little dropdown thing for each student.  
22:29:05 <applicative> The possibilities descend as follows
22:29:16 <applicative> A A+ A- B B+ B- C C+ C-
22:29:36 <applicative> I wrote to the dean suggesting the next valedictorian would likely be an A- student
22:30:44 <applicative> > sort ["A+", "A", "A-", "B+", "B", "B-"]
22:30:45 <lambdabot>   ["A","A+","A-","B","B+","B-"]
22:31:48 <djahandarie> Please give out A+s? I've never gotten one...
22:32:09 <ddarius> djahandarie: You shouldn't care.
22:32:09 <applicative> and suggesting that a programming language in which  grades are represented as grades, rather than strings, might be worth looking into....
22:32:40 <djahandarie> ddarius, why not?
22:32:46 <ddarius> djahandarie: Why should you?
22:32:54 <djahandarie> Why should I care about grades at all?
22:32:55 <applicative> djahandarie, there is much complain about so called grade inflation, especially from right wingers. 
22:32:59 <ddarius> djahandarie: Indeed.
22:33:15 <applicative> but the relevant science, whatever it is, teaches that the A+ is just as rare as ever. 
22:33:38 <djahandarie> Dunno. Thinking about doing more education after undergrad perhaps
22:33:42 <ddarius> They could certainly both be right.
22:34:06 <ddarius> djahandarie: You won't need A+s for that, or even school for that matter.
22:34:26 <applicative> yeah, it's tending toward three grades, A- A and the very rare A+
22:34:39 <applicative> there is a certain loss of information ....
22:34:45 <Mathnerd314> > concat $ sort (liftM2 ((.(:[])).(:)) "ABC" "+- ")
22:34:47 <lambdabot>   "A A+A-B B+B-C C+C-"
22:35:13 <applicative> stunning, I will recommend Mathner314 as designer of the new system.
22:35:18 <djahandarie> ddarius, I do if I want the degree that proves it
22:35:36 <Mathnerd314> > concat $ liftM2 ((.(:[])).(:)) "ABC" "+ -"
22:35:37 <lambdabot>   "A+A A-B+B B-C+C C-"
22:36:00 <Mathnerd314> the question IMO is how to get the spacing uniform
22:36:00 <ddarius> djahandarie: Degrees will matter less and less with time and even the degree doesn't require A+s.
22:37:45 <kmc> don't let school get in the way of your education
22:37:45 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
22:37:52 <ddarius> Damn straight.
22:37:58 <ddarius> (not to mention the rest of your life)
22:38:34 <ddarius> "I spent four years and $50,000 and all I got was this piece of paper (and a bunch of debt.)"
22:40:25 <ddarius> Ugh, the kerning in this paragraph is horrid.
22:56:29 <Adamant> lol, $50,000
22:56:42 <Adamant> try tripling that for some schools
22:58:13 <ddarius> Adamant: Indeed.
22:58:54 <Adamant> I am very glad I will be walking out of college with no debt
23:02:30 <Heffalump> how long does it usually take people to pay it back?
23:03:33 <listofoptions> about 20 years
23:05:37 <Adamant> depends
23:05:38 <ddarius> Heffalump: I would say, if their degree was worthwhile they could readily do it in less than five years but probably more than two (assuming essentially all of the costs became debt and they are fiscally responsible.)
23:06:52 <ddarius> How long it actually takes typically, I have no idea.
23:07:33 <Adamant> it depends on if what you are doing takes a grad degree as wlel
23:07:46 <Adamant> more debt, but sometimes significantly higher paying jobs
23:07:49 <ddarius> Adamant: I'm talking about a four year degree.
23:08:10 <Adamant> ddarius: for some fields, 4 year degrees are just a waypost on the way to a higher degree
23:08:14 <Adamant> medical, for instance
23:08:22 <Adamant> that's MD or Ph.D minimum
23:08:34 <ddarius> I know, I was just basing my statements on a four year degree.
23:08:38 <Adamant> alright
23:09:32 <ddarius> The debt accrued from staying in school longer probably increases (slightly) superlinearly while the boost in pay decreases.
23:09:37 <ddarius> But money isn't everything.
23:09:50 <Adamant> truth, but being in debt to other people sucks
23:10:02 <ddarius> (Especially considering opportunity costs and interest.)
23:10:10 <Adamant> you don't own your time and efforts for the duration it takes to get paid off
23:13:12 <ddarius> If you want to make a lot of money, you are probably best off starting your own business.  On the other hand, if you want to lose a lot of money, starting your own business is also a rather good way to do it.
23:34:52 <newsham> ddarius: you can lose money lots of times, you just have to make money once!
23:37:26 <ddarius> newsham: My impression is that you end up doing both more often than you'd like or seems necessary.
23:37:49 <newsham> few people learn how to just say no
23:38:30 <Adamant> even fewer people learn the proper placement of a interrobang in a spoken sentence
23:38:39 <Adamant> and that's the real tragedy
23:39:08 <ddarius> What say you‽
23:39:27 <Adamant> I DON'T KNOW ?!
23:40:17 <flippo> What ‽ do you mean
23:40:43 <Adamant> ah, Unicode
23:41:04 <Adamant> the cause of, and solution to, all of our string processing problems
23:41:34 <newsham> http://en.wikipedia.org/wiki/%E2%80%BD
23:41:46 <flippo> ˙ʎllıs s͵ʇɐɥ⊥
23:42:06 <newsham> what a useless character
23:42:44 <flippo> "The State Library of New South Wales, Australia uses an interrobang as its logo."
23:43:48 <Adamant> newsham: there's worse. apparently there is irony punctuation.
23:43:53 <phao> is there a relationship between monads and parsers?
23:44:18 <Taejo> phao: some kinds of parsers are monads
23:44:22 <Taejo> for example, the parsec family
23:44:26 <newsham> irony is useful in chat.
23:44:37 <newsham> if its easier to type than "<irony>"
23:44:49 <newsham> "?!" is already easy enough to type
23:45:22 <Taejo> "a parser for things is a function from Strings to lists of pairs of Strings and things" -- this type of parser is a monad (namely State String thing)
23:45:27 <newsham> > let x ‽ y = 2*x+y in 3 ‽ 5
23:45:27 <lambdabot>   11
23:45:30 <Adamant> but then we would reduce the amount of hilarious misinterpretation on the Internet, and then where would be be?
23:45:41 <Taejo> newsham: unless you have an ‽ key
23:45:46 <ddarius> Taejo: StateT String [] thing
23:46:03 <Taejo> right
23:46:05 <Taejo> d'oh
23:46:05 <flippo> When I'm discussing something cold, I make sure to include a snowman ☃
23:46:16 <Adamant> ALL HAIL KING FROSTY
23:46:25 * hackagebot storable-endian 0.2.0 - Storable instances with endianness  http://hackage.haskell.org/package/storable-endian-0.2.0 (EugeneKirpichov)
23:46:28 <ddarius> I'm cool ☃
23:46:38 <newsham> frosty.. heh.
23:46:40 <newsham> I went to the beach today
23:46:54 <newsham> i have sunburn
23:47:09 <ddarius> Last I checked beaches and the sun remained even in the wintry months.
23:47:09 <Taejo> ⸘
23:47:18 <Adamant> that's the price of not having seasons
23:47:25 <ddarius> However, what newsham wants to say is that it was a chilly 65 degrees.
23:47:25 <newsham> its true, i verified it today
23:48:15 <phao> right
23:48:16 <phao> thx
23:48:17 <newsham> 80F
23:48:29 <ddarius> Cripes
23:49:04 <Adamant> I like fall leaves and snow and such
23:49:07 <Adamant> just not too much of it
23:49:26 * hackagebot storable-endian 0.2.1 - Storable instances with endianness  http://hackage.haskell.org/package/storable-endian-0.2.1 (EugeneKirpichov)
23:49:34 <shachaf> > let (꞉) = ($); (‽) b x = if b then const x else id in (True ‽ 'a' ꞉ 'b', False ‽ 'a' ꞉ 'b')
23:49:35 <lambdabot>   ('a','b')
23:49:59 <Adamant> places like Hawaii and California freak me out climate-wise. it's too damn nice all the time.
23:50:05 <newsham> the waves were about 12 feet high (faces)
23:50:32 <Adamant> I do believe surfers would commit murder for that on this coast
23:50:53 <newsham> which coast are you on?
23:50:56 <Adamant> East
23:51:13 <Veinor> shachaf: :|
23:51:14 <newsham> :(
23:51:36 <Adamant> I'm no surfer, but the only way to get waves like that here are bays and hurricanes, as far as I know
23:51:39 <newsham> thats why they all visit here
23:51:40 <shachaf> Veinor: ‽
23:55:05 <dskippy> I have this function "add :: (Eq a, Bounded a, Enum a, Enum b) => a -> b -> a" basically a non-commutative addition. Does anyone know if there's a clever way to use type classes to say "b must be a type that is the difference of a" ?
23:56:08 <dskippy> I suppose I could set up a type that is two operators of the expression and only allow constructors for that type that are of the correct pairings. But that seems to be a little bit strange to me.
