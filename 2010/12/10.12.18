00:01:05 <ManateeLazyCat> laurus: If you interested Manatee's framework, look this: http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/
00:01:40 <laurus> ManateeLazyCat, ah thanks
00:02:02 <imcmeans> Restarting winGHCi seems to have fixed it - maybe a combination of that and redoing the windows permissions and command-line package commands.
00:02:12 <Cale> imcmeans: great :)
00:02:32 <imcmeans> thanks for the assistance! :D
00:02:32 <ManateeLazyCat> laurus: Detail documentation haven't finish, but feel free ask any question about Manatee, i will reply you ASAP
00:02:46 <laurus> ManateeLazyCat, sure, I will, thank you!
00:04:58 <laurus> ManateeLazyCat, I need to go... take care!
00:05:13 <ManateeLazyCat> laurus: Ok, bye, nice to meet you. :)
00:05:21 <laurus> Nice to meet you too :) See ya!
00:13:05 <ManateeLazyCat> Who want to join us build "haskell operating system" ?
00:13:40 <ManateeLazyCat> I know i'm crazy, but Manatee provide it is possible.
00:13:46 <pastorn> ManateeLazyCat: you gonna use HalVM?
00:14:00 <ManateeLazyCat> pastorn: I heard it, but i don't know what's it. 
00:14:12 <ManateeLazyCat> pastorn: Some OS running on VM ?
00:14:19 <pastorn> it's a virtual machine that you run inside Xen iirc.
00:14:40 <Itkovian> what pastorn said^^
00:14:43 <ManateeLazyCat> pastorn: If don't use virtual machine, HalVM can running standalone?
00:15:05 <pastorn> if i understand it they've made an 'os' which is basically the haskell runtime system and some libraries
00:15:08 <Itkovian> Afaik it's run directly inside a Xen domain, so no underlying linux
00:15:26 <pastorn> ManateeLazyCat: you'd have to write drivers like crazy
00:15:34 <ManateeLazyCat> I'm waiting for some crazy guys join Manatee team....
00:15:41 <ManateeLazyCat> A crazy guy like me.
00:15:43 <Itkovian> ManateeLazyCat: I'd go with (ab)using Xen functionality
00:16:27 <pastorn> ManateeLazyCat: if you want to distribute it, just use a linux/BSD with some basic drivers then when you boot instantly boot up your XEN image and run your entire OS from there
00:16:28 <ManateeLazyCat> pastorn: I want write OS that everyone can running, and don't need Xen's help.
00:16:52 <pastorn> how is Xen licensed?
00:17:00 <ManateeLazyCat> pastorn: Why must need Xen?
00:17:05 <ManateeLazyCat> pastorn: I don't understand?
00:17:10 <pastorn> ManateeLazyCat: because HalVM requires it
00:17:16 <pastorn> it can't be run on bare metal
00:17:29 <pastorn> ah, Xen is GPL2
00:17:45 <ManateeLazyCat> pastorn: If it can running standalone, i will interested it.
00:18:08 <pastorn> ManateeLazyCat: well... as i said... you can cheat
00:18:24 <pastorn> your boot process could be this:
00:18:58 <pastorn> load linux kernel --> initialize drivers --> load xen --> load HalVM --> load your OS written in haskell
00:19:53 <ManateeLazyCat> pastorn: So i need write drivers for Xen ?
00:20:08 <pastorn> no, Xen doesn't have any drivers
00:20:57 <ManateeLazyCat> pastorn: I'm doing is "load linux kernel --> load GTK+ library --> load Manatee". :)
00:21:06 <pastorn> Xen tell the VM that "i have a XEN graphics card", then the VM says "ok, using XEN video driver". Xen in its turn translates all the "XEN video driver" calls to the host operating system calls
00:21:29 <ManateeLazyCat> pastorn: Oh, i see.
00:21:45 <pastorn> anyone: please jump in here... i don't really know what i'm talking about...
00:21:53 <pastorn> anyone good with virtualization?
00:22:14 <pastorn> ManateeLazyCat: http://halvm.org/wiki/
00:24:34 <ManateeLazyCat> pastorn: So we can use HaLVM at any machine that can run Xen?
00:24:57 <pastorn> yes
00:25:09 <ManateeLazyCat> pastorn: Interesting
00:26:35 <pastorn> ManateeLazyCat: well, if you want to run on something non-x86 you might have some problems
00:27:21 <pastorn> wikipedia says that Xen runs on x86, x86-64, IA-64 and PPC
00:27:32 <ManateeLazyCat> pastorn: Yes, HaLVM looks interesting, but i perhaps chose my way : "linux kernel + gtk + manatee"
00:27:36 <pastorn> can GHC output PPC binaries?
00:28:08 <pastorn> ManateeLazyCat: bah! then you don't get to write your own kernel
00:28:48 <Bynbo7> pastorn: older versions for OS X could
00:37:23 <ManateeLazyCat> pastorn: My own kernel is future plan, after i finish details of manatee.
00:37:52 <pastorn> ManateeLazyCat: then you should do it for HalVM
00:38:17 <pastorn> ManateeLazyCat: then, later on, when you have a kernel, you could build drivers for HalVM that isn't Xen drivers
00:38:30 <pastorn> and maybe then you could get haskell running on bare metal
00:38:38 <pastorn> </troll>
00:38:58 <ManateeLazyCat> Now i just want finish haskell integrated environment that can running *everywhere*
00:39:29 <pastorn> ManateeLazyCat: then i'd choose HalVM... you could distribute your code together with your own version of Xen
00:40:11 <Bynbo7> o.O
00:40:19 * Bynbo7 does not think this is a good plan
00:40:33 <ManateeLazyCat> pastorn: I'm afraid HaLVM have limit since it's running on Xen....
00:40:54 <pastorn> Bynbo7: notice the "</troll>"
00:41:10 <Bynbo7> but you kept going after you finished the trolling ;)
00:41:20 <pastorn> oh, you meant distributing his application?
00:41:43 <Bynbo7> manatee needs gtk, which needs some other OS to be able to run it
00:44:20 <pastorn> Writing a loader for an PCX image files... should that be Codec.PCX, Codec.Image.PCX or Graphics.PCX? (Or even Graphics.Image.PCX?)
00:49:23 <Bynbo7> good question!
00:49:41 <pastorn> looking at hackage Codec.Image.PCX seems to be the way to go
00:50:03 <Bynbo7> do things like Codec.Image.PNG exist?
00:50:20 <pastorn> http://hackage.haskell.org/package/pngload
00:50:45 <Bynbo7> food time!
00:50:47 <pastorn> but this is also being done: http://hackage.haskell.org/package/bmp
00:51:17 <pastorn> aww shit... Graphics.Formats.TGA.TGA
00:51:28 <pastorn> there should be guidelines for this kind of stuff...
00:51:52 <Bynbo7> yes there should :(
00:54:38 <pastorn> what's the cleanest haskell choice of loading a file with two different implementations? Either A B, data SomeFile = A {lots of fields} | B {slightly different fields} or perhaps a typeclass with loadFile :: DataWhichDeterminesAorB -> ByteString -> classparameter ?
00:55:27 <pastorn> the last one would have instances for many more types than just these two
01:03:17 <argiopeweb_> 'Evening folks. I'm playing around with Haskell and I've got two functions that solve the same problem. Looking for an opinion as to which the two is closer to the ways of Haskell, or if there's a cleaner method than the one I used.  Paste at http://hpaste.org/42402/
01:04:14 <pastorn> argiopeweb_: right off the bat i can see taht you use ++ in the second one
01:04:29 <pastorn> so that should be slower
01:05:29 <Cale> hmm, so you want to split after the element which matches.
01:05:58 <argiopeweb_> pastorn: That would make sense.
01:06:02 <argiopeweb_> Cale: Correct.
01:06:27 <argiopeweb_> I heard rumor of a Data.List.Split, but couldn't manage to dredge it up.
01:06:31 <pastorn> @src lines
01:06:31 <lambdabot> Source not found. Wrong!  You cheating scum!
01:06:38 <pastorn> holy moly!
01:06:49 <argiopeweb_> And writing my own is good practice anyway. ;)
01:06:56 <pastorn> lines might be slow... i dunno...
01:07:19 <pastorn> argiopeweb_: you're doing it wrng on line 24
01:07:30 <pastorn> i get that you want to case on a variable, but you can't :/
01:07:37 <argiopeweb_> Algorithm 1 throws me into GC measurably more often, I can say that.
01:08:21 <Cale> argiopeweb_: It's on hackage
01:08:24 <pastorn> argiopeweb_: consider this little nifty hack:
01:08:25 <Cale> In the split package
01:08:36 <Cale> @let breakAfter p [] = ([],[]); breakAfter p (x:xs) = let (us,vs) = break (p . fst) (zip (x:xs) xs) in (x : map snd us, map snd vs)
01:08:37 <lambdabot>  Defined.
01:08:38 <argiopeweb_> pastorn: Good catch... I apparently hard-coded that in there without noticing.
01:08:52 <Cale> (still not so pretty...)
01:08:58 <pastorn> case () of { _ | p0 -> e0; | p1 -> e1; | p2 -> e2 ... }
01:09:10 <pastorn> @type span
01:09:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:09:25 <pastorn> argiopeweb_: use that ^^^
01:09:32 <Cale> span is just the opposite of break
01:09:41 <pastorn> wait
01:09:47 <Cale> The problem is that the cut he wants to make is off-by-one from the cut which break makes
01:09:54 <pastorn> > span (==' ') "ubtea uehtao uheotan"
01:09:55 <lambdabot>   ("","ubtea uehtao uheotan")
01:10:01 <pastorn> > break (==' ') "ubtea uehtao uheotan"
01:10:02 <lambdabot>   ("ubtea"," uehtao uheotan")
01:10:19 <argiopeweb_> Hmm, I could use span : tail rest.
01:10:26 <Cale> > breakAfter (==' ') "ubtea uehtao uheotan"
01:10:27 <lambdabot>   ("ubtea ","uehtao uheotan")
01:10:33 <pastorn> wat?
01:10:40 <pastorn> @hoogle breakAfter
01:10:40 <lambdabot> No results found
01:10:46 <Cale> I just defined it
01:10:51 <pastorn> you cheat!
01:11:28 <pastorn> Cale: could you look at my above question plz?
01:11:54 <pastorn> i've never written any libraries before, so i'm a bit at a loss here
01:11:58 <Cale> pastorn: Yeah, I was looking at it before... I'm not exactly sure what you mean, but maybe Either?
01:11:59 <argiopeweb_> Hmm, I'll go look over breakAfter and figure it out.  It's 0400 and I'm not moving so quick. ;)
01:12:15 <Cale> argiopeweb_: I'm not sure I actually recommend that ;)
01:12:33 <Cale> argiopeweb_: If you can get away with using plain break, then that might be better.
01:12:48 <pastorn> ok, so here are the definitions: http://codepad.org/9DMPVLUL
01:13:28 <argiopeweb_> I'm just interested in the way that uses the least code on my part. If I have to go make hackage work, it will be done. ;)
01:13:30 <pastorn> Cale: and here are my types (as they are now). Right now my parser is takePCX :: Parser (Either PCXDataBGR PCXDataIndexed)
01:14:17 <Cale> This context has a funny definition of 'indexed' :)
01:14:40 <Cale> So is that Either causing any difficulty?
01:15:06 <pastorn> well, the problem comes when i'm having loader for all the other formats
01:15:12 <Cale> Right, okay
01:15:13 <pastorn> there will probably be three more
01:15:20 <pastorn> or maybe that's not a problem
01:15:26 <Cale> Well...
01:15:56 <pastorn> i can know in beforehand which kind of file i'm parsing
01:16:07 <pastorn> (i get that metadata earlier)
01:16:13 <Cale> Oh, then just have loaders for each?
01:16:34 <Cale> You could put them in separate types perhaps.
01:16:46 <Cale> Or convert them all to the same internal format.
01:17:00 <Cale> Or make a single type with constructors for each.
01:17:01 <pastorn> i was thinking that maybe i should have some sort of type typeclass for this
01:17:15 <pastorn> yeah, i might need a wrapper
01:17:29 <pastorn> but what do you think about a typeclass?
01:17:47 <Cale> One potential compromise is to determine exactly which operations apply to images, and define a record datatype with those operations as fields.
01:18:21 <pastorn> that's probably gonna be hard... there are also an animation format
01:18:27 <pastorn> *there's
01:18:58 <Cale> (That would be sort of like the OO way to do it)
01:19:05 <pastorn> yeah
01:19:07 <pastorn> none of that
01:19:47 <pastorn> it makes me think of how you allocate gluints in the open gl bindings
01:19:51 <Jafet> With recursive types, you can compose operations, so it's not that bad.
01:20:09 <Cale> right
01:20:10 <pastorn> well, there et's called something like... Buffer*something*
01:20:12 <Jafet> Uh, depending on what you're operating on
01:21:30 <Cale> pastorn: So you're doing something with Heroes of Might and Magic?
01:21:30 <pastorn> ah, yes: http://hackage.haskell.org/packages/archive/ObjectName/1.0.0.0/doc/html/Data-ObjectName.html
01:21:44 <pastorn> Cale: yeah... so far a library for loading data files only
01:22:12 <pastorn> there are no open source tools... only some windows-only programs which some un-cooperative russians wrote way back in the day
01:23:19 <Cale> I'd probably start out just working out separate file loaders giving different types of results, and possibly a filetype detector if necessary. (Which it sounds like you've done.) Then after that, you can look at what the things have in common and maybe invent some typeclasses to capture that.
01:23:51 <pastorn> sounds good
01:24:07 <pastorn> i detect filetypes from the TOC: http://wiki.enleth.com/homm:homm3-lod-archives
01:24:23 <pastorn> h3lod_file -> type
01:25:15 <pastorn> hmm... the problem is if i'm gonna write it back to the LOD
01:26:53 <Cale> It's a bit curious how back in the day, a lot of games had their own custom filesystem of sorts rather than just using the OS filesystem.
01:27:20 <pastorn> probably saves space
01:27:31 <pastorn> and increases performance, i guess
01:28:25 <Jafet> Well, back in the day, they didn't issue data file patches
01:28:42 <pastorn> data file patches?
01:30:37 <Jafet> Actually many games still use their own filesystems, like Bethesda's
01:30:54 <Jafet> And patching means adding another database with entries that override the old ones
01:31:36 <shachaf> Cale: What custom filesystem of sorts do you mean?
01:31:41 <pastorn> why not just doing a validation and then a binary patch?
01:32:03 <Cale> shachaf: Things like this LOD format which pastorn is working on, and Doom WADs and such.
01:32:21 <pastorn> what's the quake format? is that also .wad?
01:32:34 <Cale> pak?
01:32:38 <pastorn> right
01:32:49 <pastorn> pak0.pak
01:32:58 <pastorn> that's some good stuff right there
01:33:33 <shachaf> Cale: Some games implemented their own custom virtual machines for the purpose of running the game. :-)
01:33:45 <shachaf> Though admittedly that makes more sense.
01:33:53 <pastorn> shachaf: what do you mean by that?
01:34:00 <pastorn> something other than a script interpreter?
01:34:07 <shachaf> pastorn: http://en.wikipedia.org/wiki/Z-machine
01:34:27 <Jafet> Or SCUMM for graphical games
01:34:34 <shachaf> Jafet: Yep.
01:34:45 <Jafet> It enables them to distribute compiled (obfuscated) games, for one thing
01:34:52 <argiopeweb_> Cale: Wrote up a quick text for the breakAfter algorithm and tested all three on a ~45mb file.. It spends an ungodly amount of time GCing and a significant quantity more actual time operating than the other two.
01:35:07 <shachaf> Jafet: Compiled /= obfuscated. Games tended to be compiled either way. :-)
01:35:11 <Cale> argiopeweb_: I'm not surprised :)
01:35:16 <pastorn> argiopeweb_: if you have a file that big, look into bytestrings
01:35:49 <argiopeweb_> pastorn: I won't. I just did it as a basic test. Bytestrings would definitely be in order if I were planning on doing it in a production file.
01:35:54 <Jafet> I thought that was one of the reasons for the z-machine, anyway
01:36:55 <Cale> argiopeweb_: Was this with -O2, btw?
01:37:16 <argiopeweb_> As for the other two, #1 is slightly faster with slightly more memory, #2 is the inverse. God only knows which is more readable, though I'd say #1 is cleaner looking.
01:37:22 <Cale> argiopeweb_: Looked at naively at least, my algorithm builds a lot of excessive tuples
01:37:24 <shachaf> Jafet: Obfuscation? I'd be somewhat surprised.
01:37:26 <argiopeweb_> Cale: Of course. Got to be optimized.
01:39:19 <argiopeweb_> Cale: I'm almost curious enough to rerun it... I killed it after 2 minutes (vs. 10 seconds for the others). It had allocated 160mb of memory as compared to 20 for the others.
01:39:40 <Cale> argiopeweb_: hmm...
01:40:19 <argiopeweb_> Cale: It was also spending about 3x as much time in GC land than the others.
01:40:19 <pastorn> is there some naive function that reads a file as a [Word8]
01:40:38 <pastorn> like readfile, but without the whole unicode check thing
01:40:44 <Cale> let breakAfter p [] = ([],[]); breakAfter p (x:xs) | p x = ([x],xs) | otherwise = (x:us,vs) where (us,vs) = breakAfter p xs -- how about this one?
01:40:58 <Cale> The other one was mostly written to be cute
01:41:19 <Cale> Oh, and we could actually probably speed that up some more
01:41:28 <Cale> Passing around p all the time is bad :P
01:41:39 <argiopeweb_> pastorn: Data.ByteString has a readfile, doen't it?
01:41:57 <pastorn> argiopeweb_: yes, but that's fast and efficient
01:42:00 <Cale> pastorn: heh
01:42:14 <pastorn> i want to find out how long it takes to traverse a 45 MB file
01:42:19 <Cale> pastorn: I think you can open the file in binary mode
01:42:44 <pastorn> i tried to run 'last' on a file i have here, but i got ** Exception: Heroes3.snd: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
01:43:00 <Cale> lol, wtf, now haskell.org is misbehaving for me, after the problem is supposed to be fixed?
01:43:33 <Cale> what's the IP?
01:43:56 <pastorn> www.haskell.org has address 78.46.100.180
01:44:06 <pastorn> hackage.haskell.org has address 69.30.63.204
01:44:29 <Cale> great
01:44:57 <Cale> withBinaryFile "foo" ReadMode hGetContents
01:46:24 <argiopeweb_> Cale: Now that one was impressive. GC time went up, but memory usage was down 2.4mb from the best, and speed was down ~1.5 real seconds from the previous best.
01:47:16 <pastorn> withBinaryFile "Heroes3.snd" ReadMode (\h -> hGetContents h >>= putChar . last)
01:47:18 <pastorn> (0.62 secs, 889821200 bytes)
01:47:28 <Cale> argiopeweb_: try:  let breakAfter p = f where f [] = ([],[]); f (x:xs) | p x = ([x],xs) | otherwise = (x:us,vs) where (us,vs) = breakAfter p xs
01:47:32 <pastorn> 42 MB
01:47:59 <Cale> er, oops
01:48:04 <Cale> argiopeweb_: try:  let breakAfter p = f where f [] = ([],[]); f (x:xs) | p x = ([x],xs) | otherwise = (x:us,vs) where (us,vs) = f xs
01:48:25 <argiopeweb_> Yeah, that one's going to work better.
01:48:32 <Cale> Forgot to finish the job doing something the optimiser ought to be able to do anyway :P
01:49:06 <Cale> I'm not sure, but I think GHC's optimiser still misses that opportunity.
01:49:26 <pastorn> argiopeweb_: what was your running time for 45 MB?
01:49:29 <argiopeweb_> Now, before I run that, why is it faster than the other? It just seems like an additional level of abstraction.
01:49:41 <argiopeweb_> pastorn: Between 8-10 seconds.
01:49:51 <Cale> argiopeweb_: It avoids passing p along while recursing.
01:50:05 <Cale> argiopeweb_: fewer parameters to deal with -> faster
01:50:33 <pastorn> argiopeweb_: i usually code in a style where i 'fixate' arguments in let-blocks before i do something
01:50:49 <argiopeweb_> Ah, I see. P is essentially viewed as a global binding by f, so it doesn't need passing.
01:50:54 <Cale> right
01:50:55 <argiopeweb_> External binding, even.
01:52:37 <Cale> Sometimes it makes a bigger difference than others though. Here, I think most of the time will indeed still be GC, though this algorithm only makes very short-lived pairs, and GHC's garbage collector is really good at short-lived garbage.
01:52:51 <Cale> (but it still eats up time)
01:54:03 <argiopeweb_> Yeah, looks like the compiler probably already gets that one. 3 fewer collections, no obvious differences in time/memory.  GC is ~27%
01:54:40 <Cale> It's possible they added it recently
01:55:19 <argiopeweb_> I imagine I could run through and optimize my calling functions and cut off a bit more time there if I was really concerned.
01:55:22 <Cale> I'm not always sure which GHC-backend things are in the future and which ones are current :P
01:55:40 <argiopeweb_> hehe... Got to love constantly-evolving software.
01:59:56 <pastorn> argiopeweb_: i often write like this, for performance: http://codepad.org/kED7l5AV
02:01:05 <pastorn> oh, forgot to use x :)
02:01:12 <argiopeweb_> Avoids recalculating/rebinding y and z if the compiler fails to optimize it properly.  Makes sense.
02:01:55 * pastorn has gone beyond simple 3-4-line-functions
02:02:19 <pastorn> Cale: is that a measurement of haskell proficiency? Average function length/
02:02:21 <pastorn> L
02:02:27 <pastorn> ? <-- THERE! a question mark!
02:03:08 <Cale> I try not to have too many definitions which are very long, or at least, they ought to be easy to split up into smaller parts at any moment.
02:03:16 <argiopeweb_> I would argue no... You could be doing complex stuff, or you could be Doing It Wrong (tm).
02:03:26 <pastorn> hehe
02:03:54 <pastorn> i've noticed that i write longer and longer functions... maybe i should start coding C instead
02:03:55 <Cale> Being able to keep everything short while doing complicated things is probably a measure of proficiency.
02:04:18 <Cale> It's really hard though :P
02:04:32 <argiopeweb_> Cale: Grr, now we have to develop a metric for complication. :P
02:04:42 <argiopeweb_> or level thereof.
02:04:43 <pastorn> like... i make a few basic functions that does just what i need, then i usually comine lots of these into pretty big stuff, often monadic code
02:05:00 <Cale> argiopeweb_: We'll it's all relative :)
02:06:09 <Cale> pastorn: Yeah, that might not be too bad. Sometimes it can be hard to give decent names to parts of things so you have a big definition or two, but the big definitions divide up compositionally anyway, and that can still be good.
02:06:32 <eflister> hey i'm trying to make an Network.TCP.HStream instance for Data.Text.  i have stuff installed via cabal -- what's a good way to try out edits to Network.TCP?
02:07:06 <Cale> cabal unpack packagename
02:07:20 <Cale> will give you a directory with the given package expanded into it
02:07:24 <Cale> You can then edit it
02:07:39 <Cale> and cabal install (with no extra parameters) the edited package to try it
02:07:57 <Cale> (you might want to bump the version number in the .cabal file before you do)
02:08:05 <pastorn> like for this i have 'readFromLOD :: LodTocEntry -> IO ByteString', which is 31 lines
02:08:26 <pastorn> it opens the source file, seeks, reads, closes the handle and returns
02:08:28 <eflister> cool thx, will try :) think there are plans to make Data.Text instances?
02:08:30 <pastorn> oh, and it unzips
02:08:56 <Cale> eflister: I don't know that library...
02:09:13 <Cale> (which package is it?)
02:09:29 <Cale> er, is that just the Network library?
02:09:51 <Cale> (seems not)
02:09:52 <eflister> or HTTP?  as far as i can tell its' the standard for downloading stuff, what do you use?
02:10:11 <Cale> I mean this Network.TCP.HStream thing
02:10:42 <eflister> well i use Network.Browser, which uses it...
02:11:22 <eflister> http://hackage.haskell.org/packages/archive/HTTP/latest/doc/html/Network-TCP.html
02:11:30 <eflister> i think that means HTTP right?
02:11:34 <Cale> ah, okay
02:12:04 <Cale> Ah, I hadn't thought to interpret HStream as the name of a class :)
02:12:12 <eflister> there are instances for bytestring
02:13:04 <Cale> This might be the sort of thing where you'd want to be careful about encoding and so ByteString would be the way to go, but an instance for Text probably wouldn't hurt anyway.
02:13:48 <eflister> yeah i was going to close my eyes and hope regarding that stuff
02:13:55 <Cale> (You could still use the Text library, you'd just encode the text appropriately before sending it)
02:14:13 <Cale> which would be a Text -> ByteString operation
02:14:47 <eflister> well the idea was to avoid bytestring and any conversions to maximize performance...
02:16:47 <pastorn> Cale: hmm... you're right... i thought this function was long for a reason, but i see now that i can write another one that does a lot of the boring stuff and thus reduces my big one
02:17:17 <pastorn> (i'm processing a list, and after each entry i print out " entry# / entryCount : somedata "
02:18:08 <pastorn> i could do withCounter :: [a] -> (a -> IO (String,b)) -> IO [b]
02:18:37 * pastorn feels silly for not thingking of if before
02:18:52 <Phantom_Hoover> What are the historical reasons for monads not needing to be functors?
02:19:30 <pastorn> Phantom_Hoover: makes the class declaration cleaner ;)
02:19:42 <Phantom_Hoover> pastorn, ...how?
02:19:57 <pastorn> it won't have (Functor m) => ...
02:20:17 <Phantom_Hoover> That's hardly a great cost for category-theoretical correctness.
02:20:30 <pastorn> Phantom_Hoover: notice the ";)"
02:20:34 <Phantom_Hoover> Ah.
02:20:38 <pastorn> :p
02:31:27 <Phantom_Hoover> What's the definition of the (->) r monad?
02:32:13 <Bynbo7> @src (->) (>>=)
02:32:13 <lambdabot> f >>= k = \ r -> k (f r) r
02:32:18 <Bynbo7> @src (->) return
02:32:18 <lambdabot> return = const
02:32:23 <Cale> Phantom_Hoover: return v x = v  and  (f >>= g) x = g (f x) x
02:32:31 <shachaf> Phantom_Hoover: The only total definitions that work with the types. :-)
02:33:30 <Bynbo7> :t (>>= const)
02:33:31 <lambdabot> forall a b. (b -> a) -> b -> a
02:33:51 <Bynbo7> sure looks like an identity to me!
02:34:46 <Phantom_Hoover> Thanks...
02:44:25 <blenderer> thank curry for google cache
02:49:21 <kaf3ii> primes = filter isPrime [2..]
02:49:21 <kaf3ii> isPrime x = all (\y -> (x `mod` y)/=0 ) (takeWhile (<x) [2..])
02:50:14 <kaf3ii> is there a way to use the primes list in the isPrime function
02:52:01 <Cale> yes
02:52:23 <Cale> kaf3ii: As long as you "prime the pump" (no pun intended!)
02:52:41 <Cale> kaf3ii: primes = 2 : filter isPrime [3,5..]
02:53:08 <Cale> isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
02:54:13 <kaf3ii> Cale: thx :D
02:54:18 <Cale> The initial 2 is enough to get things started, and since you never need any prime larger than sqrt n to determine whether n is prime, it'll always be possible from that point on to determine enough primes to keep going
02:58:29 <kaf3ii> Cale: thats true
03:11:19 <pastorn> > sqrt 11
03:11:20 <lambdabot>   3.3166247903554
03:11:30 <pastorn> > sqrt 12
03:11:30 <lambdabot>   3.4641016151377544
03:12:45 <luite> > sqrt 12 * sqrt 12 < 12
03:12:46 <lambdabot>   True
03:13:04 <geheimdienst> > sqrt 12 * sqrt 12
03:13:05 <lambdabot>   11.999999999999998
03:13:10 <pastorn> hahahaha
03:13:12 <pastorn> nice
03:13:17 <geheimdienst> ah, the joys of floating point
03:13:33 <pastorn> what was that insane doc about floating point precision?
03:14:02 <pastorn> hello wall of text! http://docs.sun.com/source/806-3568/ncg_goldberg.html
03:14:10 <shachaf> > sqгt 10
03:14:11 <lambdabot>   3.141592653589793
03:14:34 <shachaf> Interesting.
03:14:40 <geheimdienst> omg pi
03:14:52 <pastorn> seing all that text makes me want to know even less about floating points than i already do
03:15:17 <ziman> > 3.141592653589793 * 3.141592653589793
03:15:18 <lambdabot>   9.869604401089358
03:15:31 <pastorn> > pi
03:15:32 <lambdabot>   3.141592653589793
03:15:49 <ziman> > sqrt 9.9
03:15:50 <dobblego> are you guys sure that the DNS entry is fixed for haskell.org? I still haven't got it
03:15:50 <lambdabot>   3.146426544510455
03:16:01 <pastorn> is that some property?
03:16:07 <shachaf> dobblego: Works for me.
03:16:13 <pastorn> > sqrt 10 == pi
03:16:14 <lambdabot>   False
03:16:22 <shachaf> > sqгt 10 == pi -- Works for me.
03:16:23 <lambdabot>   Not in scope: `sqгt'
03:16:26 <shachaf> Grr.
03:16:36 <ziman> pastorn, no, definitely not; sqrt 10 ~ 3.16
03:16:38 <shachaf> > sqгt 10 == pi -- Works for me.
03:16:38 <lambdabot>   True
03:16:45 <sipa> wth?
03:16:48 <luite> pastorn: no it's wrong :) you can't express pi as some combination of square roots and other elementary operations
03:16:49 <geheimdienst> > sqrt 10
03:16:50 <lambdabot>   3.1622776601683795
03:17:01 <luite> at least not a finite one
03:17:06 <pastorn> luite: yeah, thought so
03:17:20 <shachaf> > sqгt (pi^2)
03:17:21 <lambdabot>   3.141592653589793
03:17:21 <sipa> @undef
03:17:25 <geheimdienst> interesting. 3 mins earlier lambdabot gave a different answer when shachaf said "> sqrt 10"
03:17:26 <pastorn> who was overloading lambdabot?
03:17:39 <dobblego> @google Why Dependent Types Matter
03:17:41 <lambdabot> http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf
03:17:41 <lambdabot> Title: Why Dependent Types Matter
03:17:44 <burp> lol
03:17:50 <geheimdienst> trolling by lambdabot
03:18:04 <shachaf> @vixen Do you approve of this behavior?
03:18:05 <lambdabot> no
03:18:05 <ManateeLazyCat> I will send 10 days on "compile cache server", if anyone interested, join me. :)
03:18:11 <shachaf> @vixen :-(
03:18:11 <lambdabot> I will NOT be ignored...
03:18:34 <pastorn> http://xkcd.com/217/
03:19:24 <shachaf> > eхp pi - pi
03:19:24 <lambdabot>   20.0
03:19:31 <shachaf> Seems right to me.
03:19:37 <luite> hmm, I wonder, was --with-rtsopts= changed to -with-rtsopts= in ghc-7.0.2rc1, or was my Makefile wrong all along?
03:19:38 <eflister> is there a way to get ghci to reload packages it has pulled in?  :reload only does the one i have loaded with :load
03:19:49 <pastorn> > sqrt (sqrt (9^2 + 19^2 / 22)
03:19:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:19:54 <pastorn> > sqrt (sqrt (9^2 + 19^2 / 22))
03:19:55 <lambdabot>   3.141592652582646
03:20:00 <pastorn> > pi
03:20:01 <lambdabot>   3.141592653589793
03:20:11 <pastorn> hahahaa
03:20:46 <pastorn> > exp 1
03:20:47 <lambdabot>   2.718281828459045
03:21:06 <shachaf> > eхp pi
03:21:06 <lambdabot>   23.141592653589793
03:21:42 <pastorn> > 20.0 == eхp pi - pi
03:21:43 <lambdabot>   True
03:22:04 <pastorn> @undef
03:22:13 <pastorn> > 20.0 == eхp pi - pi
03:22:14 <lambdabot>   True
03:23:35 <jsd> fst [2,1]
03:24:19 <shachaf> jsd: That doesn't make sense.
03:25:50 <pedro3005> what's wrong with this?  sort . (insert  4) [3, 4, 1, 2, 5, 6, 7, 3, 2]
03:26:09 <Cale> pedro3005: insert 4 [3 ...] isn't a function anymore
03:26:20 <shachaf> pedro3005: (sort) . ((insert 4) [3, 4, 1, 2, 5, 6, 7, 3, 2])
03:26:22 <Cale> (Basically, precedence)
03:26:23 <sipa> > sort . insert  4 $ [3, 4, 1, 2, 5, 6, 7, 3, 2]
03:26:24 <lambdabot>   [1,2,2,3,3,4,4,5,6,7]
03:26:48 <sunnyps> > 1 :+ 2
03:26:49 <lambdabot>   1.0 :+ 2.0
03:26:54 <Cale> The most important thing to remember about precedence in Haskell is that function application (whitespace) binds more tightly than any infix operator
03:27:09 <emph> Is it any alternative ip/url to haskell or is the site totally down?
03:27:16 <emph> haskel.org*
03:27:19 <sunnyps> > exp (2 * pi * (0 :+ 1))
03:27:20 <lambdabot>   1.0 :+ (-2.4492935982947064e-16)
03:27:48 <Cale> emph: www.haskell.org 78.46.100.180  -- but you must put it in your hosts file
03:27:49 <ziman> emph, just see the topic.
03:27:59 <ziman> there are more hosts there.
03:28:05 <shachaf> Cale: I thought it was back up.
03:28:11 <Rutix> dns still not fixed?
03:28:16 <Cale> It apparently is, but there will be DNS cache nonsense
03:28:30 <emph> Oh, so sorry. To my defense my morning coffee is just finished ;)
03:28:58 <Cale> emph: That's fine, nobody ever reads the topic :)
03:31:08 <arcatan> hmm, morning coffee. i need one.
03:32:43 <emph> Indeed
03:34:30 <rajeshsr> emph: If you actually meant, "wake-up" coffee, then i need one, though it is actually evening here :)
03:35:45 <emph> That's what I meant. It's around noon here, the perfect time to wake up!
03:39:09 <rajeshsr> BTW, i was just wondering, had anyone attempted the exercises in SICP in Haskell?
03:39:27 <rajeshsr> SICP => Structure and Interpretations of Computer Programs
03:40:32 <Feuerbach> rajeshsr: http://sicp.org.ua/
03:41:37 <rajeshsr> Feuerbach: Awesome!!
03:41:40 <rajeshsr> thanks
04:09:51 <eflister> is there a way to get ghci to reload packages it has pulled in?  :reload only does the one i have loaded with :load
04:16:30 <Twey> overscore: Why did I get randomly ++'d?  x.x
04:35:35 <frustrated> I was trying to install alex with cabal, but i got exitFailure 1: perl is required but could not be found. does anyone know how to solve this problem?
04:36:17 <Heffalump> do you have perl?
04:37:43 <frustrated> yes i do
04:38:07 <frustrated> it's installed in c:\strawberry
04:39:32 <jeltsch> Does anyone know how to get the GTK+ frontend in Yi? yi --help only lists vty, pango, and batch as frontends. :-( 
04:40:06 <jeltsch> I use Yi 0.6.2.4
04:48:50 <gol> Hi, anyone who knows why the hackage site is down?
04:53:19 <Heffalump> there were DNS problems yesterday, your local server may not have caught up
04:53:46 <Heffalump> try refreshing
04:54:33 <Heffalump> if you're just trying to upload you can use the IP (69.30.63.204) but that's harder for HTTP because your browser then won't send the right headers to identify the site.
04:55:22 <pastorn> can djinn do monads?
04:55:52 <pastorn> @type (\f -> f >>= (\x -> return ("",x))
04:55:53 <lambdabot> parse error (possibly incorrect indentation)
04:55:58 <pastorn> @type (\f -> f >>= (\x -> return ("",x)))
04:55:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ([Char], a)
04:57:44 <hpc> @pl (\f -> f >>= (\x -> return ("",x)))
04:57:44 <lambdabot> ((,) [] `fmap`)
04:57:53 <gol> Thanx, now the site is OK.
04:57:55 <Boxo> @djinn Monad m => a -> m a
04:57:56 <lambdabot> f = return
04:57:59 <McManiaC> from where is "groupWith" ? hoogle can't find anything - is it an old version of groupBy ?
04:58:17 <Boxo> @djinn Monad m => (m (m (m (m a)))) -> m a
04:58:17 <lambdabot> -- f cannot be realized.
04:58:24 <Boxo> no it can't
04:58:30 <pastorn> McManiaC: perhaps check Data.Split
04:58:38 <pastorn> McManiaC: might do grouping as well :)
04:58:53 <hpc> :t join . join . join
04:58:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m (m a))) -> m a
04:59:01 <hpc> :t join . join . join . join
04:59:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m (m (m a)))) -> m a
04:59:27 <hpc> perhaps djinn doesn't know join?
04:59:30 <pastorn> @let twice f = f . f
04:59:30 <lambdabot>  Defined.
04:59:44 <Boxo> :t (>>= id) . (>>= id) . (>== id)
04:59:45 <lambdabot> Not in scope: `>=='
04:59:45 <pastorn> @type twice . twice . twice $ join
04:59:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
04:59:46 <lambdabot>       Expected type: m (m a)
04:59:46 <lambdabot>       Inferred type: m a
04:59:47 <Boxo> :t (>>= id) . (>>= id) . (>>= id)
04:59:47 <lambdabot> forall b (m :: * -> *). (Monad m) => m (m (m (m b))) -> m b
04:59:54 <pastorn> @type twice . twice . twice . join
04:59:54 <lambdabot> forall b. (b -> b -> b) -> b -> b
05:00:10 <McManiaC> pastorn: it's GHC.Exts :)
05:00:24 <pastorn> defaults to ((->) r) monad?
05:01:09 <hpc> pastorn: it has to; the argument to twice is the result of join
05:01:23 <hpc> :t twice . twice . twice $ (>>=)
05:01:24 <lambdabot>     Occurs check: cannot construct the infinite type:
05:01:24 <lambdabot>       m = (->) (a -> m b)
05:01:24 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
05:01:30 <Boxo> :t twice
05:01:31 <lambdabot> forall b. (b -> b) -> b -> b
05:01:37 <hpc> :t twice . twice . twice $ (+)
05:01:37 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> b
05:01:37 <lambdabot>     Probable cause: `+' is applied to too few arguments
05:01:37 <lambdabot>     In the second argument of `($)', namely `(+)'
05:01:47 <hpc> :t twice . twice . twice $ (+2)
05:01:48 <lambdabot> forall b. (Num b) => b -> b
05:01:51 <hpc> there, jeez
05:04:10 <Boxo> @let exponentiate n f = foldr (.) id (replicate n f)
05:04:11 <lambdabot>  Defined.
05:04:24 <Boxo> > exponentiate 10 (*2) 2
05:04:25 <lambdabot>   2048
05:05:24 <Boxo> :t exponentiate 64 join
05:05:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
05:05:25 <lambdabot>       Expected type: m (m a)
05:05:25 <lambdabot>       Inferred type: m a
05:08:25 <Boxo> Huh. "join.join.join" is valid but "exponentiate 3 join" is not. I can see why though.
05:08:28 <Twey> > cos^2 50 + sin^2 50
05:08:29 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
05:08:29 <lambdabot>    arising from a use of `...
05:08:39 <Twey> Aw
05:09:26 <luite> > (cos^2 + sin^2) 50
05:09:27 <lambdabot>   1.0000000000000002
05:11:13 <benmachine> Twey: cos^(2 50)
05:12:20 <Boxo> instance Num a => Num (a -> a) eh...
05:12:58 <Twey> Ahh
05:14:27 <rumbold> 78.46.100.180 doesnt seem to work. it only says "It works!" :)
05:14:36 <Twey> @check (0.999 >< 1.001) . (cos^2 + sin^2)
05:14:36 <lambdabot>   No instances for (Test.QuickCheck.Arbitrary
05:14:36 <lambdabot>                      (Test.Quic...
05:14:46 <Twey> @check \x -> (0.999 >< 1.001) . (cos^2 + sin^2) $ x
05:14:46 <lambdabot>   No instances for (Test.QuickCheck.Arbitrary
05:14:46 <lambdabot>                      (Test.Quic...
05:14:56 * Twey can never remember how this goes.
05:15:56 <tonkman> what has happened to haskell.org
05:16:06 <tonkman> omg
05:22:11 <Cale> tonkman: There was a misunderstanding with the DNS record. The problem has been cleared up, but DNS caches will mean that the mistake will persist a while. See the topic for a link to some /etc/hosts lines which will fix the problem in the meantime.
05:22:33 <tonkman> ok, thank you
05:22:44 <rumbold> i tried using 78.46.100.180, but it doesnt seem to work
05:23:30 <kaf3ii> Only get "It works!" page. 
05:23:31 <Botje> even google's public dns is still confused
05:23:32 <Botje> boo!
05:23:35 <Cale> rumbold: You have to request www.haskell.org at that address
05:24:06 <Cale> rumbold: Which makes the easiest way to do that to put the line  www.haskell.org 78.46.100.180  into your /etc/hosts
05:24:44 <Cale> (or  C:\windows\system32\drivers\etc\hosts  on Windows)
05:25:25 <Cale> er, sorry, it's the other way around
05:25:34 <Cale> 78.46.100.180 www.haskell.org
05:26:58 <kaf3ii> magic :)
05:28:18 <benmachine> :t (><)
05:28:19 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
05:28:26 <Cale> It's actually not that uncommon for a single server to host multiple sites depending on which address is requested. I do it in order to have multiple webservers behind my NAT.
05:28:52 <Cale> (Mine and my dad's)
05:29:55 <Cale> That's an interesting operator :)
05:30:42 <Cale> It's for constructing coarbitrary instances for product types
05:31:23 <Cale> coarbitrary (x,y) = coarbitrary x >< coarbitrary y
05:37:36 <sshc> When I compile a program that uses tuple sections, e.g. "(1024, )", GHC fails with "Illegal tuple section: use -XTupleSections", but when I add TupleSections to the "extensions" list in the cabal project, cabal gives the warning "Warning: Unknown extensions: TupleSections"
05:37:48 <sshc> Why doesn't cabal recognize that extension?
05:39:43 <benmachine> sshc: it's new as of 6.12
05:40:03 <benmachine> sshc: if your cabal is sufficiently old it might predate it
05:40:22 <benmachine> I have a vague memory that cabal also had a trac ticket open about how it handles unknown extensions
05:40:28 <benmachine> might have been unusually strict
05:40:35 <benmachine> *unnecessarily
05:46:46 <lars9> why www.haskell.org/gtk2hs is down?
05:47:18 <tonkman> < Cale> tonkman: There was a misunderstanding with the DNS record. The problem has been cleared up, but DNS caches will mean that the mistake will persist a while.
05:47:21 <tonkman>               See the topic for a link to some /etc/hosts lines which will fix the problem in the meantime.
06:23:22 <revenantphx> What's my best bet for parsing a network stream without Binary/Lazy IO.
06:23:30 <revenantphx> ?
06:25:02 <liyang> Attoparsec?
06:26:24 <revenantphx> How would I want to "hook up" the handle to attoparsec?...
06:39:01 <revenantphx> ?
06:40:41 <Bynbo7> revenantphx: can you be more specific?
06:41:06 <revenantphx> If I have a handle representing a TCP socket, how should I feed the data to an attoparsec parser.
06:41:12 <revenantphx> (a continuous stream)
06:42:06 <Bynbo7> using the various bytestring functions for reading from handles?
06:46:43 <revenantphx> Bynbo7: the issue lies in packets length not being able to be known until the end of the packet.
06:47:02 <revenantphx> They're variable length and written artardedly. (Lazy I/O worked nicely for instance, but i want to try something else)
07:01:57 <pastorn> @hoogle absolute
07:01:57 <lambdabot> System.IO AbsoluteSeek :: SeekMode
07:01:57 <lambdabot> Data.Time.Clock.TAI data AbsoluteTime
07:01:57 <lambdabot> Data.Time.Clock.TAI addAbsoluteTime :: DiffTime -> AbsoluteTime -> AbsoluteTime
07:06:58 <ddarius> :t abs -- ?
07:06:59 <lambdabot> forall a. (Num a) => a -> a
07:14:49 <halppppp> hi
07:15:50 <Cale> hi
07:15:54 <halppppp> hi
07:16:07 <Cale> Need halp with something?
07:16:22 <halppppp> link to haskell compiler
07:16:37 <pastorn> Cale: can't you see that he needs halppppp - not just halp
07:16:40 <pastorn> @where ghc
07:16:40 <lambdabot> http://haskell.org/ghc
07:16:42 <Twey> halppppp: http://hackage.haskell.org/platform/
07:16:49 <halppppp> XDD
07:16:51 <halppppp> Thanks guys :)
07:16:59 <Twey> Argh, they rethemed that page
07:17:01 <Twey> It's so orange
07:17:04 <pastorn> halppppp: the URL:s might seem broken, though
07:17:09 <pastorn> halppppp: web server trouble
07:17:09 <Cale> Note that if either of those links doesn't work, haskell.org had some DNS problems lately
07:17:18 <Twey> No, it's back now
07:17:27 <halppppp> Still broken :(
07:17:29 <Cale> It's back, but DNS caches are still messing things up
07:17:32 <Twey> Oh, damn
07:17:35 <halppppp> That's why i'm here
07:17:38 <Rutix> halppppp
07:17:40 <Rutix> check topic
07:17:42 <pastorn> halppppp: ok, so what do you need?
07:17:53 <halppppp> I just need the compiler to get started?
07:17:55 <pastorn> i could download the file you want and mirror it
07:17:57 <Rutix> http://hpaste.org/42369/haskellorg_ips
07:17:59 <pastorn> halppppp: OS?
07:18:06 <halppppp> xp 32 bit
07:18:06 <Rutix> put those in your /etc/host file
07:18:09 <Twey> http://69.30.63.204/platform/ not very useful
07:18:21 <Twey> Yeah, you'll have to /etc/hosts it
07:19:02 <pastorn> halppppp: http://mkeyd.net/~alexander/HaskellPlatform-2010.2.0.0-setup.exe.torrent
07:19:02 <Cale> You can put http://hpaste.org/42382/haskellorg_ips  in your  C:\windows\system32\drivers\etc\hosts
07:19:19 <Cale> (not the link, the stuff that's pasted there, of course :)
07:19:27 <pastorn> halppppp: do you have a torrent client? i could grab the executable otherwise
07:19:39 <halppppp> nope :(
07:19:45 <halppppp> Checking the ips there guys sent
07:19:46 <pastorn> halppppp: ok, sec...
07:20:22 <pastorn> halppppp: http://lambda.galois.com/hp-tmp/2010.2.0.0/HaskellPlatform-2010.2.0.0-setup.exe
07:20:28 <pastorn> that's the one... does that work?
07:22:12 <halppppp> Thanks :D
07:22:14 <halppppp> this worked
07:22:16 <halppppp> downloading now
07:22:21 <halppppp> Thanks a lot guys !! ^^
07:36:11 <Clex> Hey. Is there a mirror somewhere for haskell.org ?
07:37:28 <Twey> Clex: haskell.org is up, but there've been some DNS issues; add the IPs in the paste in the topic to your /etc/hosts or whatever it is on Windows
07:37:47 <Twey> (C:\Windows\system32\drivers\printers\etc\hosts or something, IIRC)
07:38:24 <Clex> Thanks. Don't worry, I don't use Windows. :)
07:44:31 <Cale> Twey: hehe, printers :)
07:44:47 <Twey> Cale: I wouldn't be that surprised :þ
07:45:01 <Twey> I think there's a ‘printers’ dir in ‘drivers’ too, or something
07:45:12 <Cale> Yeah
07:45:21 <Cale> I seem to recall that as well
07:45:57 <Twey> 'cause C:\Windows\system32\drivers\printers\spool\ is where you go to delete jobs that get stuck in the queue
07:46:29 <Botje> Twey: hah! I thought rebooting was the only cure
07:46:30 <Botje> cool!
07:46:56 <Twey> Botje: You have to ‘net serve spooler stop’ (or something like that), then go into there and nuke everything you find, then start it up again
07:47:06 <Twey> Er, s/serve //
07:47:36 <Twey> No, s/serve/service/ I think
07:47:46 <Twey> Heh, I haven't had to tackle this problem in ages.  It's great.
07:47:54 <ddarius> On my Windows 7 install there's no printers directory in drivers or etc.
07:48:15 <Twey> ddarius: It would be XP I saw it on
07:48:28 <ddarius> XP is on my other computer.
08:06:12 <Gmind> Hi
08:06:25 <Gmind> can anyone suggest me an auto indent editor for Haskell ?
08:06:40 <Botje> leksah?
08:07:26 <parcs> the usual: emacs, vim
08:09:10 <myBrain> Why can't I do (\'a':b:c -> f b c) "a Test"?
08:09:52 <sipa> > (\('a':b:c) -> f b c) "a Test"
08:09:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:09:53 <lambdabot>    `GHC.Show.Show a'
08:09:53 <lambdabot>      a...
08:10:12 <sipa> > (\('a':b:c) -> c) "a Test"
08:10:13 <lambdabot>   "Test"
08:12:09 <myBrain> sipa, thx
08:13:54 <Gmind> thanks
08:40:35 <sshc> How should I run an action of a monad stack on top of IO as "System.Timeout.timeout" does, returning Nothing / failing after the time has passed?
08:42:19 <exDM69> oh noes, haskell.org's DNS issue has gotten worse
08:42:35 <exDM69> yesterday only www.haskell.org was affected, now it's also without the www
08:43:44 <arcatan> i gather the DNS issue is actually fixed now, but due to DNS caches it doesn't yet work for everyone
08:44:56 <monadic_kid> sshc: I'm not sure I understood your problem but you can lift an IO action with liftIO but you cant give an action in a monad stack to a function that expects an IO action
08:45:16 <monadic_kid> :t timeout
08:45:16 <lambdabot> Not in scope: `timeout'
08:47:00 <monadic_kid> sshc: did you want to use timeout inside an action in a monad stack?
08:47:33 <monadic_kid> sshc: if so then just use liftIO, liftIO $ timeout n $ do ...
08:48:15 <gwern> I hear it's all the registrar's fault since we were paid up until next year
08:48:19 <gwern> they have disrespected us
08:51:01 <gwern> @quote respect
08:51:01 <lambdabot> uninverted says:  Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
08:51:18 <sshc> monadic_kid: I want to run an action of the monad stack itself within a certain amount of time, as timeout does.  It isn't an IO action.
08:51:33 <sshc> The monad stack does have IO at the bottom
08:52:51 <monadic_kid> sshc: timeout expect an IO actiion, what you can do is run your monad stack inside an IO action 
08:53:00 <Twey> gwern: Damn them!  We must don our fighting trousers at once!
08:53:13 <gwern> and our wizard hats
08:54:28 <monadic_kid> sshc: timeout n $ runMonadStacK actionInMyMonadStack param1 param2.... where runMonadStack returns an IO action
08:55:22 <monadic_kid> sshc: timeout n $ \ _ -> runMonadStack
08:56:13 <sshc> Thanks
08:56:29 <monadic_kid> sshc: timeout n $ \ _ -> do ... runMonadStack ... return x -- if runMonadStack doesn't return an IO action
08:58:42 <monadic_kid> sshc: yeah the first bit of code wouldn't work, ignore that one, the one with a lambda :P
09:00:07 <monadic_kid> sshc: the one with lambda which is in an IO monad, internally it calls your monad stack action and escapes back into the IO Monad
09:01:23 <arch1> hello to all :  i've problem with  www.haskell.org : the site resolved  is not  haskell.org 
09:01:41 <arch1> is changed the domain ?
09:01:55 <Botje> arch1: DNS issues. look at the topic for a fix
09:02:02 <Botje> arch1: it should be solved in the next few days
09:02:16 <Botje> hmm
09:02:18 <arch1> thanks 
09:02:24 <Cale> Well, it has been resolved in a sense, but DNS caches preserve the fail
09:02:30 <monadic_kid> sshc: did you get what I meant, the second example is the one you want
09:02:36 <Botje> Cale: Google's public DNS seems to have the correct IP
09:02:47 <Botje> so you could advise people to use 8.8.8.8 instead :)
09:02:52 <Cale> On and off, depending on when you ask it.
09:02:56 <monadic_kid> sshc: it doesn't have to be a lambda, could just be a named action in the IO monad
09:03:03 <arch1> how i can point to real address ?
09:03:06 * Bynbo7 suggests you all switch to OpenDNS, the site's been fine for about a day now
09:03:13 <mdgeorge1> hello
09:03:21 <Cale> (I was using 8.8.8.8 and haskell.org was popping on and off)
09:03:30 * Twey is using OpenDNS
09:03:34 <Twey> 8.8.8.8 is Google's?
09:03:38 <Botje> yes
09:03:38 <monadic_kid> opendns ftw
09:03:43 <arch1> i attempt ....
09:03:47 <Twey> Wonder how much they paid for that
09:03:52 <Cale> arch1: By adding the lines in the paste at http://hpaste.org/42369/haskellorg_ips to your /etc/hosts file
09:04:24 <applicative> hello mdgeorge1
09:04:51 <mdgeorge1> if I have a type that is an instance of a class in two ways, how does haskell choose which implementation to use?
09:05:33 <Bynbo7> it should complain...
09:05:43 <Nakilon> guys, I'm new in haskell; I see, you have a Haskell-bot; I have the same one but Ruby; to prevent hacks (redefining bot functions, socket operations, shell commands), I use $SAFE=4; does exist something like $SAFE in Haskell? how to make safe bot?
09:05:59 <applicative> mdgeorge1, it will be an error if both are defined and available.
09:06:07 <Bynbo7> wtf is $SAFE?
09:06:18 <applicative> mdgeorge1, do you mean you want to make a different instance in place of the usual one?
09:06:20 <Nakilon> Bynbo7, to prevent hacks (redefining bot functions, socket operations, shell commands)
09:06:21 <Bynbo7> Nakilon: haskell is fairly well known for its safety...
09:06:35 <Bynbo7> uh, yeah, you can't do that with lambdabot...
09:07:00 <aavogt> mdgeorge1: can you be more specific about what the two instances are? There's a sort of 'more specific instance' with -XOverlappingInstances  as well as a 'most general instance' with -XIncoherentInstances
09:07:01 <Nakilon> so how to do it? give me keywords i have to google
09:07:02 <Bynbo7> > print 1
09:07:02 <lambdabot>   <IO ()>
09:07:07 <arch1> okay : tnx the modify of /etc/hosts is okay : now the site is correct : thanks very very much
09:07:09 <mdgeorge1> but is there a  way to specialize?  for example, if I have a definition for Ring, and a definition for Field, and MyType is both a Ring and a Field, I will get an error?
09:07:45 <Bynbo7> mdgeorge1: no, why would it?
09:08:01 <mdgeorge1> Bynbo7: wait, let me get my example straight
09:08:02 <applicative> Ring and Field are typeclasses?  If so there is no problem
09:08:29 <aavogt> so   instance Field a => Ring a -- or something?
09:08:42 <Bynbo7> Nakilon: what you're asking for doesn't really make sense. haskell isn't the sort of language where you can go around redefining stuff
09:08:57 <mdgeorge1> ok, I want to define both instance (Ring a) => Show (MyType a) and (Field a) => Show (MyType a)
09:09:08 <Bynbo7> eh?
09:09:23 <ddarius> Security can be reduced to scoping.
09:09:36 <Bynbo7> what about instande (Ring a, Field a) => Show (MyType a)?
09:09:49 <mdgeorge1> Bynbo7: I want to print the two things differently
09:09:59 <aavogt> mdgeorge1: contexts aren't used to choose instances (at least not directly)
09:10:06 <Bynbo7> in that case, try it and see :P
09:10:22 <mdgeorge1> aavogt: what do you mean by contexts?
09:10:31 <mdgeorge1> oh, the thing on the left of =>
09:10:32 <aavogt> mdgeorge1: the stuff before =>
09:10:37 <mdgeorge1> :)
09:11:03 <Nakilon> so how to prevent shell commands execution? (Win7)
09:11:10 <mdgeorge1> so how can I want to do this kind of specialization?
09:11:22 <applicative> I see, you want show MyType a to be defined differently according as a is a Ring or Field?
09:11:22 <mdgeorge1> basically I want to print it more nicely if I can use absolute value
09:11:26 <aavogt> mdgeorge1: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
09:11:34 <Zao> Nakilon: Run a second process with severely restricted security tokens and communicate through IPC?
09:12:19 <Nakilon> I don't know, what security tokens are
09:12:23 <Bynbo7> Nakilon: a better question might be how to allow command execution, because that i think would be much harder than allowing it...
09:12:31 <mdgeorge1> which actually isn't ring or field but you get the idea
09:12:35 <Nakilon> hm
09:12:44 <zaphar_home> Bynbo7: lol
09:12:46 <Bynbo7> > runCommand "rm -rf /"
09:12:46 <lambdabot>   Not in scope: `runCommand'
09:13:32 <mdgeorge1> aavogt: thanks, that's exactly what I was looking for
09:13:48 <Bynbo7> all you have to do is make sure your bot can only execute pure commands, and it won't be able to execute anything that isn't haskell
09:13:51 <Nakilon> so it would be possible, if load some module with runCommand function - so I need to prevent modules loading
09:14:04 <mdgeorge1> aavogt: you've been very helpful since I started this whole haskell thing, thanks :)
09:14:04 <Bynbo7> > unsafePerformIO $ return 1
09:14:05 <lambdabot>   Not in scope: `unsafePerformIO'
09:14:40 <parcs> you're not going to break lambdabot
09:14:58 <Bynbo7> Nakilon: i don't think you're understanding me here, you'd have to explicitly enable the use of such commands, and unless you do that, you cannot use them. this isn't like the crap ruby does
09:15:19 <aavogt> mdgeorge1: be warned that most people don't do that sort of abuse of type classes :p
09:15:47 <mdgeorge1> aavogt: yeah, I figured it was probably a bad idea, but wanted to know if I could do it anyway
09:15:59 <zaphar_home> Nakilon: just loading the module would be pretty much impossible in lambdabot 
09:20:21 <aavogt> @let r = sqrt (?x^2 + ?y^2)
09:20:21 <lambdabot>   Parse error: VarSym "?"
09:20:51 <Bynbo7> :T?
09:21:59 <aavogt> > let r =  sqrt (?x^2 + ?y^2) in let ?x = 1; ?y = 0 in let r1 = r in let ?y = 3 in (r1,r)
09:22:00 <lambdabot>   (3.1622776601683795,3.1622776601683795)
09:23:00 <aavogt> > let r =  sqrt (?x^2 + ?y^2) in let ?x = 1; ?y = 0 in (r, let ?y = 3 in r)
09:23:00 <lambdabot>   (1.0,3.1622776601683795)
09:23:47 <Bynbo7> ... :O
09:23:57 <Bynbo7> what the fuck is this evil magic!
09:24:17 <aavogt> you can think of it as an implicit reader monad
09:24:53 <Bynbo7> it's... it's... like introspective 'n shit dawg!
09:24:59 * Bynbo7 mind blown
09:25:39 <aavogt> > let r =  sqrt (?x^2 + ?y^2) :: Double in let ?x = 1; ?y = 0 in (r, let ?y = 3 :: Float in r)
09:25:40 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
09:25:40 <lambdabot>         against inferred typ...
09:29:54 <applicative> Bynbo7 is it the ?x ?y  ImplicitParams business  that seems strange?  http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html
09:30:32 <Bynbo7> yes, very much so
09:30:46 <Bynbo7> though, potentially quite handy, in the right situation
09:31:31 <Bynbo7> though, also horrible. i can imagine trying to explain to a C programmer how that is still pure, but the equivalent C isn't...
09:31:43 <aavogt> http://www.haskell.org/ghc/docs/6.2/html/users_guide/type-extensions.html#LINEAR-IMPLICIT-PARAMETERS
09:31:50 <Bynbo7> well, syntactically equivalent anyway
09:37:09 <Jesin> hmm
09:37:23 <Jesin> why is there a foldl' but no foldr' in the standard library?
09:37:46 <dankna> because read their descriptions, it wouldn't make sense
09:37:48 <zaphar_home> is there a way to ask cabal for the list of dependencies for a build target?
09:38:34 <Jesin> foldl' is "a strict version of foldl"
09:38:43 <Jesin> why wouldn't that make sense for foldr?
09:39:14 <Bynbo7> how do you make a `f` b `f` c `f` z strict?
09:39:24 <Bynbo7> there's no accumulating parameter
09:39:59 <Bynbo7> you want the laziness so you can exit early if you know you can
09:40:19 <ddarius> In foldr the passed in function controls the laziness or strictness and furthermore you wouldn't want it to be strict i.e. don't use foldr if the function being folded is strict in its second argument.
09:41:07 <Bynbo7> unless you need to use all the elements..
09:42:30 <Jesin> umm
09:42:33 <ddarius> Bynbo7: You still wouldn't want to use foldr.
09:42:37 <Jesin> when would you *not* need to use all the elements?
09:42:56 <ddarius> Jesin: Certainly on infinite lists you wouldn't want to use all the elements.
09:42:59 <aavogt> > take 10 $ foldr (:) [] [1..]
09:43:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:43:05 <Jesin> ah.
09:43:38 <Jesin> yeah, and foldl doesn't work on infinite lists, because it would need to start at the end to give any results, right?
09:43:53 <Bynbo7> > > foldr (&&) True [True,True,False,True,True]
09:43:54 <lambdabot>   <no location info>: parse error on input `>'
09:44:01 <Bynbo7> > foldr (&&) True [True,True,False,True,True]
09:44:02 <lambdabot>   False
09:44:16 <aavogt> @src (++)
09:44:16 <lambdabot> []     ++ ys = ys
09:44:16 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:44:16 <lambdabot> -- OR
09:44:16 <lambdabot> xs ++ ys = foldr (:) ys xs
09:44:24 <Bynbo7> > foldr (&&) True $ [True,True,False] ++ repeat True
09:44:25 <lambdabot>   False
09:44:40 <Bynbo7> > foldl (&&) True $ [True,True,False] ++ repeat True
09:44:46 <lambdabot>   mueval: ExitFailure 1
09:45:16 <Jesin> @src foldl
09:45:16 <lambdabot> foldl f z []     = z
09:45:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:45:24 <Jesin> @src foldr
09:45:24 <lambdabot> foldr f z []     = z
09:45:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:46:35 <ezyang> Hey guys, is there a way to distinguish between \(x, y) -> x `seq` y `seq` (x, y) and \(x, y) -> y `seq` x `seq` (x, y) 
09:46:51 <ddarius> ezyang: No.
09:46:58 <ezyang> GHC-specific hacks welcome. 
09:47:00 <aavogt> look at the source code
09:47:11 <ddarius> Well, you certainly can if you allow unsafe action.
09:47:12 <ezyang> heh 
09:47:14 <ddarius> +s
09:47:57 <ddarius> Though the compiler isn't required to be consistent in any way as far as that's concerned so you'd still technically not be able to distinguish them.
09:47:57 <aavogt> maybe seq will force Debug.Trace.trace in some deterministic order, not that it has to
09:48:07 <ezyang> Yeah. I'm thinking maybe attach unsafePerformIOs to both arguments and look at the order they're forced? 
09:48:31 <ddarius> ezyang: That isn't guaranteed to work because seq doesn't specify an order of evaluation.
09:48:40 <ddarius> It would work if you replaced seq with pseq though.
09:48:56 <Jesin> hmm
09:49:12 <aavogt> what is the use-case for telling the two functions apart?
09:49:13 <Jesin> is `foo` left- or right-associative by default, btw?
09:49:24 <c_wraith> left, probably
09:49:28 <c_wraith> I think it's infixl 9
09:49:34 <ddarius> If you don't specify, an operator is infixl 9 I think, by default.
09:49:37 <ddarius> I should check though.
09:49:42 <ezyang> aavogt: I've been reading about game semantics, which is able to tell something like this apart. 
09:49:45 <c_wraith> I know it's at precedence 9
09:50:12 <aavogt> ezyang: in haskell?
09:50:41 <ddarius> They are semantically equivalent in Haskell.
09:51:30 <ezyang> aavogt: Nah, they were using PCF :-) 
09:53:20 <ezyang> I think game semantics might be an interesting way to reason about performance while not throwing out all of the mathematical rigor 
09:56:05 <Jesin> umm
09:56:07 <Jesin> btw
09:56:10 <Jesin> [12:38:47]	<Bynbo7>	how do you make a `f` b `f` c `f` z strict?
09:56:11 <Jesin> [12:38:57]	<Bynbo7>	there's no accumulating parameter
09:56:18 <Jesin> @unpl a `f` b `f` c `f` z
09:56:19 <lambdabot> (f (f (f a b) c) z)
09:56:26 <Jesin> I think you got the associativity wrong?
09:57:08 <Jesin> Bynbo7 :p
09:57:13 <aavogt> > foldl f z [a,b,c]
09:57:14 <lambdabot>   f (f (f z a) b) c
09:57:17 <aavogt> > foldr f z [a,b,c]
09:57:19 <lambdabot>   f a (f b (f c z))
09:57:49 <Jesin> hmm
09:57:52 <Jesin> > foldl' f z [a,b,c]
09:57:53 <lambdabot>   f (f (f z a) b) c
09:57:58 <Jesin> yup
09:58:07 <Jesin> > foldr' f z [a,b,c]
09:58:08 <lambdabot>   Not in scope: `foldr''
09:58:54 <Jesin> > x `seq y
09:58:55 <lambdabot>   <no location info>: parse error on input `y'
09:58:57 <Jesin> > x `seq` y
09:58:58 <lambdabot>   Ambiguous occurrence `x'
09:58:58 <lambdabot>  It could refer to either `L.x', defined at <local...
09:59:04 <Jesin> ...
09:59:16 <Jesin> > f x `seq` f y
09:59:17 <lambdabot>   Ambiguous occurrence `x'
09:59:17 <lambdabot>  It could refer to either `L.x', defined at <local...
09:59:21 <Jesin> > f z `seq` f y
09:59:22 <lambdabot>   Ambiguous type variable `a' in the constraint:
09:59:22 <lambdabot>    `SimpleReflect.FromExpr a...
09:59:41 * Jesin apparently does not know the nuances of lambdabot
09:59:43 <Jesin> =/
10:00:15 <ddarius> What is x `seq` y supposed to mean?
10:00:27 <Jesin> I don't know that either  :p
10:00:36 <Jesin> it's something to do with strict evaluation of x, I think
10:00:42 <Zao> @where seq
10:00:42 <lambdabot> I know nothing about seq.
10:00:46 <Jesin> but I don't know exactly what it does
10:01:01 <Zao> seq evaluates x before it evaluates y.
10:01:10 <Zao> That is, to WHNF or something.
10:01:14 <ddarius> Jesin: My question has more to do with what you believe x `seq` y is supposed to do when you haven't -bound- x or y.
10:01:31 <ddarius> (It turns out they are bound in lambdabot, but...)
10:01:59 <Jesin> [13:00:34]	<Zao>	seq evaluates x before it evaluates y.
10:02:00 <Jesin> umm
10:02:12 <ddarius> Zao: That's not true.
10:02:13 <Jesin> hmm.
10:03:03 <Zao> ddarius: Feel free to clarify.
10:03:24 <Jesin> [13:00:47]	<ddarius>	Jesin: My question has more to do with what you believe x `seq` y is supposed to do when you haven't -bound- x or y.
10:03:25 <Jesin> I don't know, it was just an idle experiment  =/
10:03:27 <Jesin> I
10:03:28 <Jesin> ...
10:03:43 <Zao> I'm struct by h.org's DNS snafu, so I can't look docs up.
10:03:45 <Cale> seq x y is an expression which evaluates to y provided that x is not undefined
10:03:46 <Jesin> grr enter key.  anyway
10:03:54 <Jesin> I haven't really gotten very far with haskell yet.
10:03:59 <ddarius> Zao: It's perfectly legitimate for it to evaluate y first and then x and GHC does do this upon occasion.
10:04:04 <Cale> This ensures that x is evaluated before the result of evaluating y can be used
10:04:09 <ddarius> Zao: This is the difference between pseq and seq.
10:04:15 <Cale> But it doesn't exactly ensure that x is evaluated before y
10:04:17 <Zao> ddarius: I blame shitty explanations and docs then.
10:04:27 <ddarius> I'm pretty sure the docs make this clear.
10:04:48 <Cale> It's quite a subtle point. You can usually assume that seq x y means to evaluate x and then result in y.
10:04:51 <Zao> Well, the only docs I had access to, which are those zwon crap ones, doesn't mention anything of the likes.
10:04:52 <ddarius> Particularly the ones for pseq, but even seq doesn't specify any evaluation only a denotational equation seq _|_ x = _|_
10:04:54 <Cale> But it's not *quite* correct
10:05:14 <Jesin> umm
10:05:15 <Jesin> [13:04:22]	<Cale>	It's quite a subtle point. You can usually assume that seq x y means to evaluate x and then result in y.
10:05:16 <Twey> I think of it as adding a ‘hook’ to y that automatically evaluates x when y is forced
10:05:19 <ddarius> In fact, foldl' should be defined with pseq not seq technically.
10:05:21 <Jesin> where does the result of evaluating x *go* then?
10:05:36 <Twey> Jesin: Depends
10:05:37 <ezyang> into the great ether 
10:05:37 <ddarius> Jesin: It's discarded as the type clearly implies.
10:05:45 <Twey> If it's not used elsewhere, it's immediately discarded
10:05:46 <Cale> Jesin: If x goes unused in the rest of the program, straight to the garbage collector
10:05:48 <ezyang> but its result might be shared 
10:05:57 <Jesin> hmm
10:06:03 <Cale> Jesin: But the usual case is that x is a variable which is bound and used elsewhere.
10:06:10 <Jesin> I've been told GHC doesn't do common subexpression elimination
10:06:12 <Jesin> umm
10:06:14 <Jesin> ok
10:06:45 <Cale> and no, ghc does not do CSE, which means that seq is pretty useless if the first parameter to it isn't a variable
10:06:48 <Zao> I don't suppose that lambdabot has trace, right?
10:07:01 <Cale> (or, rather, yes, GHC doesn't to CSE ;)
10:07:05 <Cale> do*
10:07:18 <ddarius> Zao: No because printing things out to stdin on lispy's box wouldn't be particularly useful.
10:07:29 <Zao> ddarius: Well, it could have a custom one.
10:07:37 <Zao> ddarius: Also, stdin? :D
10:07:44 <Jesin> (why doesn't it, by the way?  It seems a good use of referential transparency, though I'm saying this from rather limited knowledge  :p )
10:07:44 <ddarius> s/in/out
10:07:46 <Zao> It's not like it doesn't violate other parts of the library/language.
10:08:05 <Zao> Jesin: I expect it's hard, for little gain.
10:08:14 <ddarius> Jesin: Because it hase pretty significant performance repercussions in some cases.
10:08:19 <ddarius> Zao: No, it's stupid easy.
10:08:24 <Zao> Particularly when interacting with extensions, I reckon.
10:08:27 * Zao guesses wildly.
10:09:17 <Cale> Jesin: You can imagine that when you do define something like let x = 5 + 5 in ... what that means is that x starts out its life as an expression graph with a (+) node and two arcs leading to 5. Any demand for the evaluation of x will cause that graph to be replaced with the result of evaluating, which is 10
10:09:28 * applicative dimly remembers Peyton Jones saying attempts to implement "CSE"  led to wild space leaks
10:10:02 <Cale> applicative: yeah
10:10:13 <ddarius> Sharing, like parallelism, is something that is best under programmer control.
10:10:22 <Jesin> hmm
10:10:24 <Jesin> k
10:11:50 <Cale> combs [] = [[]]; combs (x:xs) = combs xs ++ map (x:) (combs xs)
10:11:54 <Cale> consider that program
10:12:58 <wharzl> i want to write a language in haskell
10:13:13 <applicative> wharzl, excellent plan
10:13:43 <wharzl> i'm wondering if it would be less development time to write it in haskell than in ocaml
10:13:43 <Cale> Jesin: If we were to do CSE, it becomes  combs (x:xs) = let cs = combs xs in cs ++ map (x:) cs
10:14:12 <wharzl> i just want to get the language up really fast as a prototype
10:14:16 <Cale> In the first program, the results of the first combs xs can be discarded from memory as they're consumed
10:14:33 <ddarius> wharzl: Then I'd suggest using a language that you know well.
10:14:39 <Cale> In the CSE'd program, the second use of cs causes them all to be retained
10:14:50 <Cale> which is very bad, since there's O(n!) of them
10:14:57 <applicative> wharzl is 48 hours too long? http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours :)
10:15:22 <wharzl> i know C++ well, but I'd never want to write a language (or, well, anything) in that
10:15:30 <Cale> wharzl: Do you know either of these languages already?
10:15:54 <wharzl> haven't used either but have been studying lisp and FP for a couple years
10:16:02 <Cale> wharzl: Haskell's a great language in which to implement languages.
10:16:20 <Cale> (O'Caml's pretty good at it too, but obviously we're biased ;)
10:16:42 <aristid> but haskell is also good for other things
10:16:48 <aristid> (just to say it for good measure)
10:17:05 <wharzl> holy crap wysas looks awesome
10:17:16 <Cale> wysas?
10:17:26 <wharzl> write yourself a scheme
10:17:32 <Cale> ah
10:18:02 <wharzl> wonderful resource
10:18:21 <wharzl> <3 haskell now
10:18:42 <Cale> Hmm, it looks like it could use a little update...
10:18:48 <applicative> wharzl, hackage has a pile of examples of course http://hackage.haskell.org/packages/archive/pkg-list.html#cat:compilers/interpreters
10:19:00 <Cale> Text.ParserCombinators.Parsec is the old (but still working) location for Parsec
10:19:07 <Cale> It's now just Text.Parsec
10:19:44 <Cale> (because after you type ParserCombinators a few dozen times, it starts to get annoying :)
10:20:21 <Cale> (No, I meant some other Parsec which has nothing to do with parser combinators)
10:21:17 <wharzl> yep, writing my language in haskell is what I will do over the holidays :)
10:21:26 <Cale> Heh, someone should create an astronomy library called Parsec, just to be annoying ;)
10:23:53 <applicative> wharzl, a recent example is http://atomo-lang.org/  http://darcsden.com/alex/atomo  He may use more up to date devices.
10:24:00 <Twey> Cale: Or a Web utility library called ‘typeclass’.
10:25:05 <wharzl> ty sir
10:25:40 <Cale> Twey: even better: http://hackage.haskell.org/package/TypeClass
10:25:47 <Twey> Ha!
10:27:36 <alexsuraci> wharzl: a more up to date repository for atomo is http://bitbucket.org/alex/atomo
10:27:55 <aristid> Cale: that astronomy library would almost certainly NOT be under Text
10:28:26 <geheimdienst> aristid: oh, you've never heard of textual astronomy?!
10:28:27 <Cale> aristid: indeed, but it would provide an argument for not moving Parsec up to just be Parsec
10:28:33 <Cale> (instead of Text.Parsec)
10:28:38 <applicative> haha, wharzl, alexsuraci can give you plenty of advice...
10:29:00 <Cale> heh, Text.Parsec -- parses Parsec format astronomical text files
10:29:14 <aristid> geheimdienst: not yet
10:29:24 <overscore> hrm, quick question; what is a "common" or nice use for  sequenceA
10:29:33 <aristid> Cale: if it uses parsec to parse it, it could be Text.Parsec.Parsec
10:29:58 <Cale> overscore: I've used it a few times in the UI for the game that we're working on at iPwn.
10:30:13 <Cale> overscore: I have an applicative functor called Widget
10:30:43 <ddarius> Scottish snaps seem easy on violin.
10:30:50 <Cale> overscore: A value of type Widget t is something which can be put somewhere on the screen and interact with the user to continually produce values of type t
10:31:17 <ddarius> overscore: You can use sequenceA everywhere you use sequence and then some.
10:31:23 <Cale> overscore: sequenceA provides me with a handy way to put bunches of similarly-typed widgets on the screen at once.
10:32:05 <Cale> (like a menu of options, for instance)
10:33:22 <aristid> Cale: sounds like ad hoc FRP?
10:33:59 <Cale> aristid: It's a little layer on top of Yampa
10:34:30 <Cale> It's *almost* a monad
10:34:55 <Cale> In fact, it might be possible to make it a monad, but I'd have to understand Yampa just a little bit better to know if it's really safe.
10:34:57 <aristid> class AlmostMonad
10:36:05 <Cale> Instead of  join :: Widget (Widget a) -> Widget a  all I currently have is an operation  Widget (Event (Widget a)) -> Widget a, which switches on each occurrence of an event.
10:36:11 <Cale> er, sorry
10:36:20 <Cale> a -> Widget (Event (Widget a)) -> Widget a
10:37:31 <Cale> and I have a similar analogue to bind
10:39:25 <aristid> and how would you make that into an actual monad?
10:47:26 <Cale> Well, if we have a Widget (Widget a), it's unconditionally producing a widget all the time, and so the hope is that we could use rSwitch to run that new widget on the very first step, and have it ignore any initial value.
10:47:37 <Cale> I could test this out and find out pretty easily I guess.
10:49:09 <Cale> But I'm not sure we even really want that behaviour -- switching on every tick would probably not do what you'd want in most cases. Building Event into the definition of Widget (so that Widget a can produce values only when it wants to) might be a better plan.
10:50:52 <Jesin> @src seq
10:50:52 <lambdabot> Source not found.
10:51:01 <Jesin> hmm
10:51:08 <Cale> It's primitive
10:51:15 <Jesin> http://haskell.org/ghc/docs/7.0-latest/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html#seq
10:51:18 <Cale> But for specific types, it could be defined in terms of case
10:51:24 <Jesin> it says this though:
10:51:28 <Jesin> seq :: a -> b -> b
10:51:29 <Jesin> seq = let x = x in x
10:51:45 <Cale> Read the comment at the top of that file ;)
10:51:46 <monochrom> that's wrong
10:52:06 <Jesin> ah
10:52:11 <Cale> That definition is just there to please the documentation generator. None of that code is real.
10:52:15 <Jesin> "not code to actually be used"
10:52:16 <Jesin> got it
10:52:54 <Cale> For Maybe, for example, we could define   seq x y = case x of Nothing -> y; Just _ -> y
10:53:34 <ddarius> Jesin: Every single function in that file is defined that way.
10:53:52 <Cale> let x = x in x  is just another way to write an undefined value
10:54:09 <Cale> :t let x = x in x
10:54:09 <lambdabot> forall t. t
10:54:15 <Cale> > let x = x in x
10:54:18 <lambdabot>   mueval-core: Time limit exceeded
10:54:28 * ddarius continues working on Lonesome Fiddle Blues.
10:54:30 <geheimdienst> > undefined
10:54:31 <lambdabot>   *Exception: Prelude.undefined
10:55:00 <geheimdienst> so, "let x = x in x" is bottom?
10:55:05 <Jesin> hmm
10:55:08 <Cale> yep
10:55:09 <Jesin> ($!)    :: (a -> b) -> a -> b
10:55:10 <Jesin> #ifdef __GLASGOW_HASKELL__
10:55:12 <Jesin> f $! x  = let !vx = x in f vx  -- see #2273
10:55:13 <Jesin> #elif !defined(__HUGS__)
10:55:14 <geheimdienst> i see, thanks
10:55:15 <Jesin> f $! x  = x `seq` f x
10:55:16 <Jesin> #endif
10:55:44 <Cale> Jesin: I'm not sure why GHC would prefer that bang-patterned version
10:56:04 <Cale> They mean about the same thing though
10:56:17 <Jesin> what does the bang-pattern mean
10:56:44 <Cale> I would usually say that it means what the hugs code says
10:57:02 <applicative> > length [ let x = x in x]
10:57:03 <lambdabot>   1
10:57:16 <Cale> Bang patterns are weird, in that they cause let to do evaluation, where it normally doesn't.
10:57:22 <Jesin> http://hackage.haskell.org/trac/ghc/ticket/2273
10:57:24 <Cale> (at least, now they do)
10:57:44 <ddarius> Cale: That's like saying irrefutable patterns are weird.
10:58:03 <Cale> ddarius: that's true, they're a bit strange as well :)
10:58:20 <Jesin> irrefutable patterns, what
10:58:43 <overscore> hmm, applying sequence to functions is neat
11:00:19 <Cale> Jesin: If p is any pattern then ~p is a pattern which always succeeds in matching (without really looking) and then only really tries to match if the variables bound by it are used
11:00:36 <Cale> Jesin: (and causes an error if it didn't really match after all)
11:01:18 <Jesin> ...
11:01:23 <Jesin> k
11:01:37 <Cale> This can be useful in some cases where you don't want evaluation to happen too early.
11:01:37 <Jesin> so the syntax for that is ~(pattern)
11:01:40 <Cale> yeah
11:02:21 <gwern> so, I wrote a script to use sqlite and wget to download every URL I've visited in firefox over the last year or so for offline viewing / viewing in the future. I thought I could just stick it in a darcs repo. the folder is currently up to 15G
11:02:25 <gwern> d'oh
11:02:56 <dmhouse> Heh, what did you expect?
11:02:57 <ddarius> Why do you want that in a darcs repository?
11:03:02 <overscore> wow
11:03:05 <Cale> gwern makes a serious attempt to download the internet
11:03:07 <overscore> that must be a lot of porn
11:03:10 <dmhouse> gwern: including photos?
11:03:36 <dmhouse> Or does it just download the HTML?
11:04:42 <Cale> I downloaded 15GB yesterday alone.
11:04:54 <Cale> er, no sorry, on the 12th
11:04:59 <ddarius> Cale: In HTML would be impressive.
11:05:02 <Cale> only 6GB yesterday
11:05:17 <geheimdienst> cale, how much is that in lolcats?
11:05:22 <Cale> heh
11:06:22 <Cale> I should probably slow down a bit for the rest of the month... :)
11:06:50 <Cale> I don't really need to see Starcraft 2 replays in 1080p on YouTube
11:08:11 <Cale> Oh right, the 12th was when I downloaded both SC2 and the latest XCode at the same time.
11:08:31 <Cale> XCode is astonishingly large
11:08:51 <overscore> it is, now.
11:08:57 <ddarius> Perhaps its a Windows program and includes a copy of Windows to run it.
11:09:02 <Cale> heh
11:09:14 <overscore> What is the current status regarding HS development for the iPhone ?
11:09:21 <Cale> overscore: It works
11:09:25 <geheimdienst> and they do updates about every 2 minutes, which means you have to re-download the entire damn thing
11:09:35 <overscore> Any guidelines or something to go by ?
11:09:49 <gwern> dmhouse: images, css, js - everything a page pulls in
11:10:02 <overscore> An URL perhaps?
11:10:07 <gwern> dmhouse: it was even worse when I had --level=1 --recurse :)
11:10:35 <gwern> ddarius: I wanted it in a darcs repo so I could check out 'my internet as of dec 2009' and suchlike
11:10:35 <Cale> overscore: You should definitely talk to blackh if you're interested in it, since he's responsible for GHC iPhone
11:10:52 <gwern> dmhouse: and actually, I had expected something like 1 gb max
11:11:01 <gwern> I mean how many URLs could I possibly have visited in a year
11:11:08 <Cale> http://projects.haskell.org/ghc-iphone/ -- there's this, but I don't know if it's up to date at all.
11:11:12 <gwern> (somewhere around 73k, turns out)
11:11:16 <Nibble> haskell having unmutable variables, wouldn't a more efficient implementation of a list be an array?
11:12:01 <Cale> Nibble: Suppose you want to change just the first element of a list
11:12:21 <Cale> Nibble: You build one new list cell, and you point the tail of it at the tail of the old list
11:12:36 <Cale> Suppose you want to change just the first element of an array. You copy the entire array.
11:12:48 * hackagebot digestive-functors-hsp 0.2 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.2 (JeremyShaw)
11:13:13 <Cale> Also, arrays are finite
11:13:17 <Nibble> But really, how often does that happen in haskell? Aren't variable unmutablee?
11:13:20 <Nibble> unmutable*
11:13:26 <gwern> Nibble: depends on what operations you want. lists beat arrays for some operations, which is why even languages like C sometimes use linked lists
11:13:27 <Cale> Which means that they're no good for almost everything we use lists for.
11:13:58 <Cale> Nibble: yes, I'm assuming immutability
11:13:59 <ketil> Nibble, so they're both immutable, but lists are more useful for recycling its parts.  You can do something similar with arrays, look at bytestring.
11:14:21 <Cale> Nibble: My point is that lists decompose nicely into parts which can be shared between multiple lists
11:14:26 <overscore> cabal install gtk  fails :(
11:14:29 <Cale> But arrays don't.
11:14:31 <Nibble> Cale: ah, I see
11:14:34 <Nibble> fair point
11:14:57 <Nibble> ghc actually does that?
11:15:03 <Cale> > zip [0..] "hello, there"
11:15:04 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,','),(6,' '),(7,'t'),(8,'h'),(9...
11:15:15 <Cale> ^^ this is an idiom in Haskell for numbering the elements of a list
11:15:27 <Cale> Note how we casually use an infinite list there
11:15:28 <geheimdienst> > length $ zip [0..] "hello, there"
11:15:29 <lambdabot>   12
11:15:34 <Cale> You can't do that with an array :)
11:15:52 <overscore> > length [1..]
11:15:55 <lambdabot>   mueval-core: Time limit exceeded
11:16:13 <gwern> overscore: not a surprise. you install gtk-tools or whatever the helper package is?
11:16:22 <Cale> Nibble: Whenever you reuse the same variable, all the occurrences of it in the same scope point to the same thing.
11:16:36 <overscore> gwern: yeah
11:17:02 <Cale> Nibble: They're all identical in memory, and any evaluation done to the expression that the variable is bound to is shared between all the copies
11:17:02 <geheimdienst> huh? what's this now? http://www.haskell.org/haskellwiki/IPhone
11:17:06 <aavogt> did you add ~/.cabal/bin to your path overscore ?
11:17:07 <overscore> why is GTK not part of the Haskell Platform anyway ?
11:17:14 <Zao> > [0..] !! 9000**100
11:17:15 <lambdabot>   Infinity
11:17:18 <Zao> That's ... surprising.
11:17:28 <Zao> > [0..] !! 9000**10
11:17:29 <lambdabot>   3.486784401e39
11:17:38 <aavogt> > [0..] !! (9000**100)
11:17:39 <Zao> I guess it's so huge, it's clamped?
11:17:39 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
11:17:39 <lambdabot>    arising from a use of...
11:17:45 <Zao> Oh.
11:17:52 <Zao> Sneaky precedence :D
11:17:59 <Saizan> overscore: you could paste the build log somewhere, before all the channel starts guessing what went wrong :)
11:18:02 <overscore> Zao: floating points have a upper limit I thing
11:18:04 <geheimdienst> > 9000**100
11:18:04 <aavogt> it doesn't look at spaces
11:18:05 <lambdabot>   Infinity
11:18:07 <overscore> floats
11:18:18 <Zao> I can never remember which one of ^ and ** is for real.
11:18:23 <geheimdienst> > [0..] !! 9000
11:18:24 <lambdabot>   9000
11:18:41 <Cale> overscore: I'm guessing because it's huge dependency-wise, and would require the GTK runtime to be bundled on windows...
11:18:43 <aavogt> :t ((^),(^^),(**))
11:18:44 <lambdabot> forall a b a1 b1 a2. (Num a, Integral b, Fractional a1, Integral b1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
11:18:47 <Cale> (and mac)
11:19:05 <overscore> Fair enough
11:19:13 <Zao> I assumed [0..] !! (9000**100), and that the output was somehow lambdabot-modified.
11:19:34 <geheimdienst> http://www.haskell.org/haskellwiki/ <- is this weird for anyone else? a network solutions spammy "buy this domain" page?
11:19:48 <Zao> overscore: Not to mention that it's very bad form to put dynamic libraries in $PATH.
11:19:49 <Cale> overscore: I don't even use the Platform myself. I just download the binary GHC and then cabal install, and get everything I need from there :P
11:19:58 <aavogt> Zao: why should you  [0 .. ] !! number, when you  could just  have   number?
11:20:04 <overscore> Cale: on windows ?
11:20:06 <Zao> aavogt: For amusement.
11:20:10 <overscore> sounds like a recipe for disaster
11:20:10 <Cale> overscore: On Linux
11:20:15 <overscore> aah
11:20:28 <Cale> I'd probably do the same thing on Windows, I'm not sure :)
11:20:28 <Zao> overscore: Nothing wrong with building what you need on Windows.
11:20:38 <Jesin> umm, what's the difference between ^ and ^^ ?
11:20:39 <Zao> As I expect that the GLUT library is still rather broken in the HP.
11:20:42 <overscore> except the lack of a proper unix environment, hah
11:21:05 <Zao> overscore: msys'll od.
11:21:11 <Cale> geheimdienst: For some people until the DNS caches sort themselves out. See the topic.
11:21:25 <Zao> For the few retarded packages that can't survive without it.
11:21:38 <aavogt> > (2 ^^ (-3), 2 ^ (-3)) -- Jesin 
11:21:38 <lambdabot>   (0.125,*Exception: Negative exponent
11:21:46 <Cale> geheimdienst: The issue was quickly dealt with, but some DNS caches are sloooow to update
11:22:03 <overscore> > import Graphics.UI.Gtk
11:22:04 <lambdabot>   <no location info>: parse error on input `import'
11:23:29 <monochrom> even if lambdabot had gtk2hs installed, do you really expect it to pop up windows on your screen remotely? XD
11:23:51 <overscore> No :P
11:24:06 <overscore> but on yours, sure
11:24:38 <geheimdienst> cale: oh, okay. thanks. i was confused because haskell.org worked for me but h.o/wiki didn't
11:29:09 <unkanon> I want pcre. so do I want regex-pcre-0.94.2? or do I want regex-base? or pcre-light-0.4?
11:31:52 <aavogt> unkanon: you'll end up with regex-base with either of the other two
11:32:04 <aavogt> @ty (=~)
11:32:05 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
11:32:06 <unkanon> so cabal install regex-base then?
11:32:13 <AnAdorableNick>  \la
11:32:24 <aavogt> unkanon: no, regex-pcre or the other one
11:32:44 <ddarius> Well lambdabot could use the HTML5 backend of Gtk2 and render to a website.
11:33:02 <unkanon> oh, then that's what I need help deciding :) do I get dons' pcre-light or the other guy's regex-pcre ?
11:34:32 <unkanon> regex-pcre is some versions ahead at 0.94.2 but its stability is described as "seems to work"  :P
11:35:00 <gwern> ddarius: I still can't believe there's an html5 backend
11:35:49 <geheimdienst> gtk can paint its widgets into html? so you could run a gtk app on a server and use it via a web browser ...?
11:37:00 <overscore> that's insane, I didn't know it had
11:37:38 <aavogt> hmm, maybe the pcre-light doesn't seem to use the interfaces in regex-base
11:38:03 <unkanon> what I understand so far is that with regex-pcre I'd have to have libpcre installed already
11:38:10 <unkanon> it seems that's not the case for pcre-light
11:39:37 <unkanon> I'll try regex-pcre first
11:40:16 <unkanon> hmm it failed to install, probably because I don't have libpcre
11:41:58 * hackagebot hoogle 4.1 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.1 (NeilMitchell)
11:42:26 <ddarius> s/Gtk2/Gtk3 in my earlier statement
11:42:35 <danblick> I'm starting work on a network application that I'd like to be able to test without making real connections.  Are there any test strategies folks would recommend?
11:43:42 <unkanon> ok, libpcre and regex-pcre installed
11:43:53 <geheimdienst> danblick: how about connections to localhost?
11:44:49 <danblick> gheimdienst: fair question, but I'm not sure I'd be able to test dropped connections or errors that way.
11:45:07 <sm> \o/ hoogle!
11:45:30 <ddarius> Abstract away from the method of connection so you can interpose mock interfaces at will.
11:46:25 <Twey> Arbitrary Iteratee?
11:48:11 <ddarius> There are (at least) two ways of doing this.  One is to directly parameterize by the relevant interfaces.  If you were an OO programmer you'd call this basic parameterization "dependency injection."  The other way, and one of my favorites, is to use concurrent processes and channels.
11:49:05 <geheimdienst> danblick, hm ... i think i'd test connection timeouts with something like { cat part-of-a-response; sleep 60 } | nc 
11:49:11 <danblick> I think parameterization makes sense; I'm not sure I'm very good at it yet;
11:49:15 <geheimdienst> similar for an aborted connection
11:49:20 <ddarius> Technically though the latter is a specialization of the former.
11:49:48 <danblick> I still spin my wheels a little bit when thinking about how to type something that is either doing real IO or just using a reader, for instance
11:52:33 <danblick> thanks guys for your suggestions
11:56:04 <unkanon> I have no idea how to use regex-pcre after having installed it and assured that it's alright (I can run getVersion)
11:56:13 <unkanon> > "blah" =~ "a"
11:56:13 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
11:56:13 <lambdabot>                    ...
11:56:22 <Cale> danblick: My advice is that if you have any doubts about whether to use monad transformers over the IO monad, don't.
11:57:12 <Cale> danblick: The IO monad already has lots of bells and whistles, and a little bit of parameter passing will not hurt nearly as much as even just reader-transforming your code will, usually.
11:57:45 <Cale> (Monad transformers are useful, I just don't think they're all that great over IO.)
11:59:04 <Cale> unkanon: That regex library is insanely polymorphic in its result types (there are something like 20 different variations)
11:59:16 <Cale> unkanon: So you have to say what sort of result you want.
11:59:22 <unkanon> Cale: yeah I think I remember now, I have to say :: some type
11:59:29 <Cale> yeah
11:59:33 <unkanon> I remember reading that on RWH. ok I'll take it from here, thanks Cale!
11:59:35 <Cale> http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base-Context.html
12:00:17 <Cale> actually, http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base-RegexLike.html#t:RegexContext
12:06:09 <ddarius> Cale: If you are already using the IO monad, there isn't much cost in adding a monad transformer, particularly if you have a limited set of IO actions you actually need.
12:07:07 <Cale> Well, yeah, if there's a limited set of IO actions you actually need and you can wrap things up nicely, then it's okay.
12:07:51 <Cale> But more often I've seen people jump in and reader transform everything and have to liftIO all over the place, and the benefit becomes really questionable.
12:09:07 <Cale> and then if you want to forkIO or bracket, you run into more awkwardness, and it's usually just not worth the trouble
12:09:35 <Cale> (even though it's quite possible to push forward)
12:13:24 <ddarius> You have no more or less trouble with ReaderT r v. an extra parameter with regards to forkIO or bracket.
12:14:09 <ddarius> And certainly for more complicated monad transformers than Reader, the benefit is quickly apparent.
12:17:20 <monochrom> like this? r <- ask; liftIO (forkIO (runReaderT r m))
12:17:59 <monochrom> as opposed to: forkIO (m r)  -- r is already a parameter in scope
12:18:45 <monochrom> and approximately 3 times that if I try to use bracket
12:18:58 <ddarius> ReaderT (\r -> forkIO (runReaderT m r))
12:19:06 <ddarius> And you can readily capture this pattern.
12:19:37 <monochrom> yeah, I know two libraries on hackage for that
12:20:04 <nooodl> @src List.transpose
12:20:04 <lambdabot> Source not found. Take a stress pill and think things over.
12:20:31 <Cale> @src transpose
12:20:31 <lambdabot> transpose []             = []
12:20:31 <lambdabot> transpose ([]   : xss)   = transpose xss
12:20:31 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
12:20:37 <nooodl> yikes
12:20:46 <Cale> transpose is sneaky
12:21:09 <aavogt> > let transp = getZipList . sequenceA . map ZipList in  transp [[a,b],[c,d]]
12:21:09 <lambdabot>   Not in scope: `sequenceA'
12:21:19 <aavogt> > let transp = getZipList . Data.Traversable.sequenceA . map ZipList in  transp [[a,b],[c,d]]
12:21:20 <lambdabot>   [[a,c],[b,d]]
12:21:56 <aristid> > transpose . words $ "<Cale> transpose is sneaky"
12:21:57 <lambdabot>   ["<tis","Crsn","aae","lna","esk",">py","o","s","e"]
12:21:58 <aavogt> Cale: can that be in scope (stuff from Data.Traversable and similar, that don't conflict)?
12:22:07 <aristid> > transpose . transpose . words $ "<Cale> transpose is sneaky"
12:22:08 <lambdabot>   ["<Cale>ose","transp","iseaky","sn"]
12:22:15 <aavogt> or even hiding the Prelude clashes
12:22:35 <Cale> aavogt: probably
12:22:38 <nooodl> transpose m = map (\x -> map (!! x) m) [0..length (m !! 0)-1]
12:22:41 <nooodl> is what i have right now
12:22:46 <ddarius> Bass is too brutal on my nails.
12:22:52 <monochrom> This only flies for something complicated like RWST. For the specific case of ReaderT it is just wrapper bloat.
12:29:16 <Twey> > iterate transpose $ words "<Cale> transpose is sneaky"
12:29:17 <lambdabot>   [["<Cale>","transpose","is","sneaky"],["<tis","Crsn","aae","lna","esk",">py...
12:29:50 <Twey> Hm
12:48:07 <andreypopp> Hi, is there any precompiled binaries for mac os x x64 of cabal install, that works with ghc 7.0.1
12:49:10 <aavogt> if you find a precompiled binary of cabal install that works for earlier ghc, it might work for the newer ghc
12:49:55 <Cndy> ncdy@Cndy ~/Haskell $ ghc --make -package qt -fglasgow-exts -O2 -o a HCK.hs 
12:49:57 <Cndy> [1 of 1] Compiling Main             ( HCK.hs, HCK.o )                       
12:49:58 <Cndy> Linking a ...                                                               
12:50:00 <Cndy> ncdy@Cndy ~/Haskell $ ./a                                                   
12:50:01 <Cndy> Segmentation fault 
12:50:10 <andreypopp> aavogt: ok
12:50:14 <Cndy> qt is not so good for haskell yes ?
12:53:02 <alpounet> Cndy, well, i haven't yet met a GUI library that fits almost perfectly with haskell
12:53:20 <alpounet> and the qt binding isn't much used afaik
12:53:55 <alpounet> but well the segfault shouldn't be the library's fault
12:55:31 <Cndy> alpounet: I guess it is , I used qtHaskell example )
12:55:51 <Cndy> alpounet: and first ones worked fine 
12:55:59 <alpounet> weird
12:57:30 <alpounet> if you don't see any error you could have made
12:57:34 <alpounet> then contact the author
12:58:01 <Cndy> alpounet: but looking like the trouble is static/dynamic libraries
12:58:07 <alpounet> yeah
12:58:14 <alpounet> that wouldn't be surprising...
13:00:04 <unkanon> > "blahblah" =~ ".a" :: (AllMatches [] (MatchOffset, MatchLength))
13:00:04 <lambdabot>   No instance for (GHC.Show.Show
13:00:04 <lambdabot>                     (Text.Regex.Base.RegexLi...
13:00:19 <unkanon> so that has no Show. how do I find out how to manipulate its result?
13:01:21 <unkanon> :tAllMatches
13:01:24 <unkanon> :t AllMatches
13:01:24 <lambdabot> forall (f :: * -> *) b. f b -> AllMatches f b
13:02:07 <wharzl> what does 'many' mean?
13:02:14 <aavogt> > "blahblah" =~ ".a" :: AllMatches [String]
13:02:14 <Cndy> qtHaskell is very dangerous ... build with O3 = Segmentation fault  , build with O1 = Segmentation fault  , using MessageBox = Segmentation fault  :)
13:02:14 <lambdabot>   Kind mis-match
13:02:14 <lambdabot>  Expected kind `* -> *', but `[GHC.Base.String]' has kind `*'
13:02:15 <wharzl> I can't seem to google it right
13:02:45 <aavogt> :k AllMatches
13:02:46 <lambdabot> (* -> *) -> * -> *
13:02:57 <wharzl> :k many
13:02:58 <lambdabot> Not in scope: type variable `many'
13:03:01 <unkanon> aavogt: Cale gave me a link to a document that really helps me but I don't know how to go from the signature to using it
13:03:16 <unkanon> I know that that is the signature I want (out of the tens of possibilities)
13:03:21 <aavogt> unkanon: no, your signature is probably right
13:03:38 <unkanon> yeah, but it doesn't derive Show so I don't know how to learn to manipulate it
13:04:10 <aavogt> > case "blahblah" =~ ".a" of AllMatches x -> x :: [(MatchOffset, MatchLength)]
13:04:11 <lambdabot>   [(1,2),(5,2)]
13:04:36 <unkanon> wow :)
13:07:06 <unkanon> I don't understand how that works
13:07:14 <unkanon> because you didn't specify my signature
13:07:18 <unkanon> so how does it know which one to use?
13:07:23 <unkanon> for example, this doesn't work:
13:07:31 <unkanon> > case "blahblah" =~ ".a" of array x y -> y :: [(Int,(String,(Int,Int)))]
13:07:32 <lambdabot>   <no location info>: Parse error in pattern
13:07:42 <unkanon> > "blahblah" =~ ".a" :: [MatchText String]
13:07:43 <lambdabot>   [array (0,0) [(0,("la",(1,2)))],array (0,0) [(0,("la",(5,2)))]]
13:08:04 <aavogt> unkanon: I'm assuming there's a       data AllMatches f b = AllMatches (f b) 
13:08:05 <unkanon> how do you do that case of trick with this?
13:08:22 <aavogt> in regex-base you can probably find the proper definition
13:08:43 <aavogt> this is based on the output of:
13:08:47 <aavogt> :t AllMatches
13:08:48 <lambdabot> forall (f :: * -> *) b. f b -> AllMatches f b
13:09:09 <aavogt> since you can get the inverse of functions with capital letters by pattern matching
13:09:33 <unkanon> hmm that's what I was trying to do with array but it doesn't begin with a capital letter :(
13:09:59 <aavogt> unkanon: what is  array?
13:10:12 <aavogt> @hoogle toList
13:10:13 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
13:10:13 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
13:10:13 <lambdabot> Data.IntMap toList :: IntMap a -> [(Key, a)]
13:10:16 <mauke> :t array
13:10:17 <unkanon> no idea
13:10:17 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
13:10:26 <unkanon> :t array doesnt work for me in ghci
13:10:27 <lambdabot> parse error on input `in'
13:10:35 <mauke> @index array
13:10:35 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
13:11:05 <unkanon> hmm now it works
13:11:55 <unkanon> so how do I unbox array ... ?
13:12:00 <unkanon> > "blahblah" =~ ".a" :: [MatchText String]
13:12:01 <lambdabot>   [array (0,0) [(0,("la",(1,2)))],array (0,0) [(0,("la",(5,2)))]]
13:12:16 <mauke> :t (!)
13:12:17 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
13:12:59 <unkanon> > ("blahblah" =~ ".a" :: [MatchText String]) ! 0
13:13:00 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
13:13:00 <lambdabot>         against inferred t...
13:13:15 <mauke> er, you've got a list there
13:13:30 <mauke> > ("blahblah" =~ ".a" :: [MatchText String]) !! 0
13:13:31 <lambdabot>   array (0,0) [(0,("la",(1,2)))]
13:13:36 <mauke> > ("blahblah" =~ ".a" :: [MatchText String]) !! 0 ! 0
13:13:37 <lambdabot>   ("la",(1,2))
13:13:56 <mreh> urgh, I always forget to submit patches as I go
13:14:05 <unkanon> mauke: thanks!
13:15:17 <ursthegizmo> hi
13:15:35 <mreh> is there alot of point submitting patches when you're at the design stage of development?
13:15:48 <ddarius> Why not?
13:16:14 <mreh> it is easy
13:16:47 <mreh> it *is* easy
13:18:58 <Cndy> what setText mb $ "Hello world" makes ?
13:20:13 <mreh> now i just need to integrate vim into darcs
13:21:36 <alpounet> wharzl, it's a parser combinator in the parsec library
13:21:55 <Cndy> hello ?
13:22:15 <alpounet> see http://book.realworldhaskell.org/read/using-parsec.html
13:27:05 <Cndy> http://pastebin.com/XK5pSgEY
13:31:47 <zachk> cndy whats the qtc library do? 
13:37:00 <Cndy> zachk: it's Qt
13:38:40 <dobblego> @hoogle m a -> m ()
13:38:40 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:38:40 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
13:38:40 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
13:42:02 <Baughn> Has the "last core slowdown" been ameliorated at all in GHC 7? Anyone check?
13:42:21 <Baughn> Maybe I should just try myself..
13:46:19 <zepard> hello
13:47:14 <alpounet> Baughn, haven't heard about improvements about this
13:47:18 <alpounet> but if there are keep me posted please
13:48:14 <Baughn> alpounet: I've been wondering how GHC would play with hyperthreading. Just need to get a hyperthreaded processor first..
13:48:37 <alpounet> heh ok
13:48:49 <Baughn> alpounet: Ideally I'd be able to avoid it by, say, running three threads on a fourt-virtual-core processor
13:49:04 <Baughn> Though IIRC the slowdown is really a linux kernel problem
13:49:07 <hpc> Baughn: hyperthreading should be transparent, afaik
13:49:28 <alpounet> Baughn, I don't remember the deep cause of the problem, can't answer that one sorry
13:49:30 <hpc> i thought the slowdown was the RTS not scheduling itself enough
13:50:01 <Baughn> hpc: Well, it's kind of noticable that the problem fails to exist on OS X
13:50:10 <wharzl> reee
13:50:14 <hpc> oh really? interesting
13:52:33 * hackagebot hoogle 4.1.1 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.1.1 (NeilMitchell)
13:52:50 <Baughn> The real fundamental issue is that GHC wants its threads to be scheduled as a group
13:53:52 <Baughn> That is, it wants full control over scheduling internally in its thread group
13:53:56 <Baughn> Linux /doesn't support this/.
13:54:05 <Baughn> Neither does OS X, nor any other mainstream OS except windows.
13:54:34 <Baughn> OS X does, however, use a slightly different algorithm to schedule that seems to work out better
13:54:39 <Baughn> ..hm.
13:54:51 <Baughn> I wonder if linux' newfangled control groups could be exploited for thi
13:54:52 <Baughn> s
13:55:17 <co_dh> Good morning guys, glad that Haskell.org is back. is that normal that haskell-platform is only 140 MB ?
14:11:30 <Cndy> is there some qt users ?
14:15:34 <gwern> Baughn: it sounds plausible to me. but they're hardly newfangled, I have a close cousin right now just from userland stuff
14:18:13 <monadic_kid> Cndy: I've used qt quite a bit but not in the context of Haskell
14:18:30 <monadic_kid> Cndy: i might be able to help
14:18:37 <dimmy> Cndy: I used Qt a while ago (and played a bit with qtHaskell once, but it is long ago)
14:19:07 <Cndy> dimmy can you help me with simple qshow )
14:19:21 <Cndy> dimmy: http://stackoverflow.com/questions/4480293/qshow-segmentation-fault
14:20:15 <Cndy> dimmy: and why you don't use it anymore ?
14:23:45 <Peaker> Qt made C++ bearable
14:23:58 <monadic_kid> Cndy: why are you calling qshow on a hello (a button) ?
14:26:23 <Cndy> monadic_kid: I though it's like msgbox there but also ... it is official qtHaskell example
14:26:28 <dimmy> Cndy: I had difficulties with using it on my mac (mostly linking x86 vs. x86-64 stuff); besides that, I do not program GUIs very often
14:26:43 <dimmy> monadic_kid: it's the equivalent of QWidget::show()
14:28:09 <Cndy> so maybe I just need to forget about qtHaskell and use GTK# with F#
14:28:31 <monadic_kid> dimmy: I know, it looks like he is creating a button and attaching it to a QMessageBox but calling show on the button instead of the dialog
14:31:21 <wharzl> i read a bit of 'write yourself a scheme' and am looking for a resource that will aid me in writing a scheme compiler in haskell addition to the interpreter
14:33:08 <monadic_kid> Cndy: did you try calling qshow on the mb instead of hello
14:33:13 <monadic_kid> Cndy: that makes more sense to me
14:33:15 <overscore> does Apple approve iPhone apps written in Haskell ?
14:34:08 <dankna> overscore: they changed their policy recently, so I don't know
14:34:09 <dimmy> monadic_kid: IIRC Qt creates a window around the first widget that is created (in this case: hello); the QMessageBox is then constructed with the button as "parent", not the other way round.
14:34:45 <overscore> They seem to change it every few weeks :s
14:35:39 <Cndy> monadic_kid: not
14:35:56 <Cndy> monadic_kid: ill try some later think so
14:36:10 <monadic_kid> dimmy: that doesn't make sense to have the button as parent of a MessageBox (QDialog)
14:37:46 <fliebel> Are there any games made in Haskell?
14:37:55 <medfly> yes
14:37:56 <Kaidelong> a few
14:38:07 <Kaidelong> the one that has seen the most "success" is probably bloxors
14:38:27 <Kaidelong> also the state of haskell survey says that 11% of people who use haskell write games in it
14:38:48 <medfly> lol
14:38:49 <hpc> that figure is likely significantly askew
14:38:54 <medfly> it's probably a bad survey
14:39:06 <Kaidelong> it is still something to think about
14:39:07 <aristid> medfly: why? it's a precise figure after all
14:39:15 <medfly> :)
14:39:15 <Kaidelong> also there is that one undergraduate thesis
14:39:30 <Kaidelong> lambdafrag or something
14:39:31 <Kaidelong> the FPS
14:39:32 <fliebel> I fear I'm one of those guys who plans to do a game as his first project in a language, or something else mundane like a twitter client or a reddit clone. I do know a few other languages though.
14:39:35 <medfly> Cale is working with these awfully optimistic people on a game
14:39:41 <medfly> they reckon they'd make a decent profit. LOL
14:39:52 <hpc> lol
14:40:09 <aristid> medfly: do they already have a published version of it?
14:40:16 <hpc> i tried to figure out a system to make game state an embarassingly parallel problem
14:40:25 <alpounet> medfly, oh, they are ?
14:40:25 <hpc> it was interesting, but damn hard
14:40:25 <Kaidelong> medfly: games are actually quite profitable even if they are comparatively unsuccessful, so long as you keep development costs low
14:40:28 <medfly> Cale, tell me
14:40:30 <alpounet> any link ?
14:40:31 <hpc> so i moved on to things i could finish
14:40:55 <medfly> Kaidelong, are you talking about flash games? I think in Haskell you have to write almost everything from scratch.
14:41:25 <monadic_kid> fliebel: it's probably best if you get quite comfortable with Haskell before doing something like that, games are non-trivial to write even simple ones
14:41:27 <hpc> medfly: i think he means indie stuff
14:41:32 <fliebel> medfly: No nice opengl wrappers and game engines? I heard people do Haskell guis in opengl, because the wrapper is dead simple.
14:41:35 <Kaidelong> medfly: flash would be a good platform I suppose. I'm talking in general though. For a very long time now, game distribution has been cheap so you could charge low prices.
14:41:43 <monadic_kid> fliebel: and I mean a complete game
14:41:43 <Kaidelong> and still make a profit
14:41:51 <Kaidelong> so long as you minimized the cost of developing it
14:41:52 <hpc> fliebel: it's simple, but opengl is tough to learn
14:41:59 <fliebel> monadic_kid: I know, I know. I'll do the Twitter client first.
14:42:03 <hpc> i think it's also missing a few things
14:42:10 <Peaker> I hate the expression "embarrassingly parallel"..
14:42:13 <medfly> this is a discussion too deep to me
14:42:14 <Kaidelong> basically it is easy to make a profit of off shareware games
14:42:19 <medfly> I was just going to call them terribly optimistic
14:42:36 <Kaidelong> well depends what their ambitions are
14:42:38 <hpc> Peaker: same, but it's the most understood term for it
14:42:40 <Kaidelong> mainstream success is hard
14:42:47 <Kaidelong> making a profit I'm told is actually not that hard
14:42:50 <fliebel> At least I'm not going to do 3D :)
14:42:53 <monadic_kid> fliebel: there are games on Hackage and I've written some simple complete games (and working on more): https://github.com/snkkid
14:43:59 <monadic_kid> fliebel: but yeah if haven't been using haskell for a long, probably best you don't do a game first
14:44:19 * hpc bookmarks lazyfoohaskell
14:44:21 <Cndy> so wxHaskell vs qtHaskell(if I can fix my error) vs F# ???
14:44:27 <fliebel> Yea, Haskell alone is hard enough.
14:44:50 <Kaidelong> Cndy: if you don't care about portability, C#, then write the rest of the code in F#
14:46:05 <Kaidelong> Cndy: you could also look at the reactive framework if you're going to do that
14:47:19 <Kaidelong> that said I haven't used qtHaskell, but from what I understand it is still an early alpha anyway
14:47:45 <Cndy> Kaidelong: so what about wxHaskell ?
14:48:02 <Kaidelong> Cndy: it is a nightmare to get the developer's part of it working and once you do it is not that impressive
14:48:03 <monadic_kid> i think wxHaskell is more widely used at the moment
14:48:25 <Cndy> Kaidelong: I don't trust Mono , but I'm also yet another .net programmer
14:48:25 <Kaidelong> if you want good developer tools I'd say go for WPF or Windows Forms
14:48:37 <Kaidelong> Cndy: mono is pretty awful
14:48:45 <Kaidelong> but it does windows forms well enough
14:49:09 <monadic_kid> awful in what way?
14:49:21 <Kaidelong> monadic_kid: a lot of things don't work on it out of the box
14:49:43 <Cndy> sure mono is not .net
14:49:45 <Kaidelong> it isn't a complete implementation of .NET
14:49:48 <Cndy> but linux is not windows
14:49:59 <overscore> mono runs on windows
14:49:59 <Peaker> .net is also pretty awful
14:50:06 <Kaidelong> Peaker: how so?
14:50:10 <Peaker> though I guess it is better than Java
14:50:20 <Kaidelong> Peaker: how is it better than java?
14:50:23 <Cndy> .net is the best for developers in my opinion
14:50:49 <Peaker> Kaidelong, Well, I really meant that C# is better than Java.. Due to generators, Linq, delegates, various other features Java insists on not having
14:51:05 <Kaidelong> C# is better than the Java language no question
14:51:26 <Cndy> F# is better then C# )
14:51:32 <Kaidelong> Microsoft has somewhat neglected .NET though unfortunately and Java as a runtime has caught up or outperformed it
14:51:37 <dobblego> I have met MSR guys and I have worked with JSR teams; there is a reason C# is better
14:51:53 <Peaker> Kaidelong, And .net is awful because all of the languages within it are kludges, many of the .net framework libraries and systems are badly designed.  A friend of mine which I trust the opinion of works with .net every day, and files a new bug report every day.
14:52:15 <monadic_kid> Cndy: if it was me I'd probably pursue the qtHaskell route if I wanted to stick with Haskell. You could probably use the Qt Designer, the .ui files are just xml but you will have dynamically create the ui from it because usually in C++ those files go get converted to C++ code
14:52:26 <Kaidelong> Peaker: .NET is gigantic. And the Haskell platform isn't the best designed thing in the world either.
14:52:39 <Kaidelong> it's just a problem you have if you have a large set of base libraries
14:52:53 <Peaker> Kaidelong, Well, the kinds of awful behaviors and bugs suggest very poor design is behind it
14:52:59 <monadic_kid> Cndy: what is you're trying to make anyway?
14:53:05 <aavogt> monadic_kid: what abou glade (a similar thing to the qt designer)?
14:53:09 <overscore> Qt + c++ + boost is pretty nice
14:53:44 <Cndy> monadic_kid: some utils with little gui
14:53:46 <Peaker> Kaidelong, the kinds of generic types/polymorphism you have in C# is pretty crappy (e.g: no higher-kinded polymorphism, no type-classes, ..)
14:54:02 <Kaidelong> Cndy: if you care about portability I'd say go Haskell w/ GTK
14:54:02 <monadic_kid> it's nice for C++, it does not make C++ itself any nicer!
14:54:05 <Peaker> Kaidelong, I don't actually know how much of C#'s suckage is C# and how much is due to .net itself
14:54:17 <Kaidelong> if you don't, you're not going to beat C# and F# in terms of tool support
14:54:23 <Peaker> Kaidelong, Nullability by default is a stupid mistake repeated again..
14:54:50 <Kaidelong> Peaker: but that's not the case in F#. Moot anyway.
14:54:54 <monadic_kid> Peaker: as well as not pure by default
14:55:00 <Kaidelong> The thing you get is tool support
14:55:06 <Peaker> monadic_kid, You could at least defend that decision as controversial
14:55:08 <Kaidelong> it is not the C# language itself that appeals here
14:55:17 <Peaker> monadic_kid, I don't think there's much of a controversy left about nullability
14:55:31 <Kaidelong> which is why I suggested writing a view in C# and then calling it from F#
14:56:13 <Cndy> so ... good night 
14:56:14 <monadic_kid> f# still has the limitations imposed by the .net type system, such as higher-kinded polymorphism
14:56:17 <Peaker> Kaidelong, I am sorry for mixing up my dislike for .net, C#, etc.  My knowledge of those is mainly the rants I get about truly awful things found there, and every time I meet him he has a few new truly-awful bullets about C# or .net
14:56:22 <Cndy> .I will think about it more tomorrow
14:56:42 <Kaidelong> Peaker: nothing is perfect. .NET is actually pretty nice.
14:56:48 <Kaidelong> all things considered
14:56:53 <Kaidelong> just like haskell
14:57:04 <Kaidelong> which is why I use both
14:57:30 <Peaker> Kaidelong, It's all relative, and depends on how high your standards/demands are.  My friend's demands are relatively similar to mine, similarly calibrated, and so when he says .net sucks, I am pretty sure that'd be my opinion too if I had used it daily :)
14:57:43 <Kaidelong> Peaker: the main thing microsoft has going for them is that their developer tools are pretty much unparalleled. They are expensive though, hence why I make something of a point of trying not to use them.
14:58:09 <Peaker> Kaidelong, Other friends of mine who've used C# dev. tools and Eclipse for Java say the latter is much better and that's why they stick with inferior Java
14:58:44 <Peaker> (though they may be wrong)
14:58:46 <monadic_kid> As soon as they add support generic generics parameters and generics constraints with operators then it will be a lot more nicer but I doubt that is going to happen
14:58:47 <Kaidelong> Peaker: It depends how much you pay. I'm able to get a rather posh .NET setup for free since I'm a student. Neither NetBeans nor Eclipse really compare
14:59:03 <Peaker> Kaidelong, Do you have all of the functionality from Eclipse's "refactor menu"?
14:59:09 <monadic_kid> any time soon as anyways
14:59:09 <Kaidelong> Peaker: in C#, yes
14:59:17 <Kaidelong> in F#, tool support is sparse
14:59:27 <Kaidelong> but the same is true of all the other functional languages I care to use
15:00:00 <Kaidelong> also C# is noticably nicer than Java which helps
15:00:32 <Peaker> Kaidelong, I myself have already been convinced, for example, that inheritance is the wrong tool for all jobs, and that single-dispatch polymorphism based on inheritance is awful.  I find it really hard to like any language that is centered around these notions
15:00:58 <Kaidelong> Peaker: inheritance is really convenient if you want to avoid repeating yourself
15:01:15 <Kaidelong> there are actually some things about the haskell type system that gets to me a bit with that
15:01:22 * ddarius was gifted with an extra screw by Ikea.
15:02:10 <ddarius> My impression is also that Java (and some other languages) have more advanced tools than the typical Visual Studio setup, but Visual Studio is pretty nice.
15:02:18 <ddarius> C#, on the other hand, is far nicer than Java.
15:02:36 <Kaidelong> ddarius: there are a lot of nifty plugins for VS as well
15:02:49 <ddarius> Kaidelong: I'm sure there are even more for Eclipse.
15:02:58 <Kaidelong> that's what I was meaning really
15:03:12 <Kaidelong> a lot of what makes eclipse so nice is the plugins you can get for it
15:03:31 <Kaidelong> so I thought that is what you meant
15:04:14 <Peaker> Kaidelong, Inheritance is a horrible tool for code re-use
15:04:25 <Peaker> Kaidelong, can you name an example where you'd use inheritance to avoid repeating yourself?
15:04:34 <ddarius> Peaker: It's easy enough not to use inheritance in C#.
15:04:53 <Peaker> ddarius, The whole polymorphism model is based on inheritance?
15:05:29 <Kaidelong> Peaker: (Monad m, Monoid m a) => MonadPlus m 
15:05:38 <monadic_kid> Peaker: sub-type polymorphism, .NET type constraints do use the interfaces for doing constraints
15:05:40 <Peaker> Kaidelong, That isn't inheritance...
15:05:41 <Kaidelong> err
15:05:43 <Kaidelong> (m a)
15:05:47 <ddarius> Interface inheritance (both the general meaning and the specific 'interface' concept in C#/Java) is fine.  You never need to use implementation inheritance in C# except for, admittedly, some common libraries e.g. ASP.NET.
15:06:08 <Kaidelong> Peaker: why's that not inheritance?
15:06:16 <ddarius> (The same is more or less true in Java as well.)
15:06:18 <Peaker> Kaidelong, It's just a class context
15:06:24 <Kaidelong> well
15:06:37 <Kaidelong> "instance (Monad m, Monoid (m a)) => MonadPlus m
15:06:45 <Kaidelong> that sort of thing
15:06:46 <Peaker> ddarius, interface inheritance is fine in the sense of not being harmful (which impl. inheritance is) but it is still a pretty weak/bad way to implement polymorphism
15:06:50 <monadic_kid> sub-type polymorphism is mixed in with inheritance in java/c#
15:07:06 <Peaker> Kaidelong, What's being "inherited" here?
15:07:15 <Kaidelong> methods from MonadPlus
15:07:25 <Peaker> Kaidelong, It just means that all MonadPlus instances need to also have a Monad/Monoid instance. The methods aren't "inherited" into a new class
15:07:39 <ddarius> Peaker: It's seems quite a reasonable way to implement inclusion/sub-type polymorphism.  Both C# and Java have parametric polymorphism as well.
15:07:51 <Kaidelong> what that is saying is that there exists an instance for MonadPlus if you have an instance for Monad and Monoid
15:07:52 <ddarius> And bounded parametric polymorphism is pretty powerful.
15:08:06 <Peaker> ddarius, Well, they lack type-class-style polymorphism, and afaik they lack existential-types in their parameteric polymorphism
15:08:07 <Kaidelong> which basically would be roughly analogous to MonadPlus being a supertype
15:08:35 <Kaidelong> that is being inherited from
15:08:40 <monadic_kid> but it's not it's nothing to do with types
15:08:48 <monadic_kid> you can't really compare them
15:09:04 <monadic_kid> i mean it is not sub-type polymorphism
15:09:18 <Peaker> ddarius, I never found a convincing example of how interface-inheritance (or any other form of inheritance) is really a good way to represent "sub-types".  How is it superior to using either a simple record of functions/actions, or a type-class?
15:09:19 <ddarius> Peaker: Subtype polymorphism already supports a degree of existential behavior.  Haskell also lacks existential types.  Type classes are a completely orthogonal concept.  You could add it to C# or Java.
15:09:22 <Kaidelong> Peaker: I thought you didn't need existential types anymore with Java style polymorphism
15:09:40 <Kaidelong> it becomes the default behavior
15:10:21 <ddarius> Type classes aren't even comparable to subtype polymorphism on their own.
15:10:33 <Peaker> ddarius, I don't see type-classes as orthogonal.  Compare:  interface IShow { String show(); }  to class Show, for example of non-orthogonality. 
15:11:10 <Peaker> Kaidelong, I am not sure, but I think that when you use parameteric-polymorphism in Java/C#, your type parameters must be universally quantified
15:11:27 <ddarius> Peaker: There is some overlap to the extent that you wouldn't want each to be completely disjoint concepts, but they are not comparable concepts and you -could- have each of them in a language separately.  They provide different things.
15:11:28 <Kaidelong> Peaker: but you could just give a supertype as a parameter
15:11:45 <Kaidelong> if Object is the type parameter the actual type could be ANYTHING
15:12:19 <Peaker> ddarius, I think (existential-support + type-classes + simple records) does everything inheritance/single-dispatch does, and far far more
15:12:19 <Kaidelong> a list of objects would be a heterogenous list
15:12:38 <monadic_kid> but in a not so useful way
15:12:53 <monadic_kid> unless you use an interface
15:13:11 <Peaker> Kaidelong, A few reasons super-types aren't quite good enough:  1) Each type must explicitly "inherit" all interfaces it possibly implements, rather than stating so elsewhere (e.g: the interface, or an orphan instance in a 3rd-party connecting the two)
15:13:19 <Kaidelong> monadic_kid: which you can! you could have an IEnumerable of IEnumerables
15:13:27 <ddarius> Peaker: Yes, you can encode dynamic dispatch, but that still wouldn't give you bounded parametric polymorphism and some other aspects (at least in Haskell.)  But if you do do that equation, you find that type classes are unnecessary and more of liability to implementing dynamic dispatch.
15:13:42 <Peaker> Kaidelong, 2) Inheritance of interfaces is not conditional:  Is a generic list in Java IComparable or not?  It depends on whether the typed item is IComparable -- but there is no conditional inheritance
15:13:55 <monadic_kid> Kaidelong: i think you missed the second sentance i wrote
15:14:05 <Kaidelong> Java doesn't have IComparable (.NET does)
15:14:08 <Kaidelong> to be pendantic
15:14:18 <Kaidelong> there is Comparable and Comparator, though
15:14:30 <Peaker> ddarius, I find that dynamic dispatch/existentials are very rarely useful in actual programs (and almost all uses I've ever had of them were removed when I cleaned up the code, without that actually being a goal)
15:14:48 <Peaker> ddarius, But when they are, I think they are better encoded by existentials in GHC haskell than with inheritance
15:15:05 <Peaker> Kaidelong, well, pick any interesting interface a list could be an instance of
15:15:10 <ddarius> Peaker: I find that Haskell programmers tend to underuse object-oriented styles of polymorphism to their detriment.
15:15:17 <Peaker> Kaidelong, It can't *conditionally* be an instance of it, depending on the type of the member
15:15:25 <Peaker> ddarius, Example?
15:15:55 <Peaker> Kaidelong, 3) Inheritance polymorphism cannot encode return-type polymoprhism, higher-kinded polymorphism, and so forth
15:16:01 <Kaidelong> Peaker: You can do that, but support for constraints is a bit spotty (but that is true of haskell as well). Unlike haskell though, you'd have to encode it right there in the definition of the first interface.
15:16:17 <Peaker> Kaidelong, Can you have *conditional inheritance* based on constraints?
15:16:31 <Peaker> Kaidelong, Can you say this in C# or Java?   instance Eq a => Eq (Maybe a) where ... ?
15:16:41 <ddarius> Peaker: Our collection libraries are overly concrete and you can't check if an element is in a collection of Set-like things.
15:16:50 <Peaker> Kaidelong, Don't you have to say:  class Maybe<a> : IEq ... { ?
15:17:09 <Peaker> ddarius, I agree that's a problem but IMO we need better type-class vocabularies here, and not single-dispatch
15:17:11 <elliott> Ugh ... trying to declare an instance of a typeclass for a type; it has to be a newtype since it's overlapping if I use a type alias and expand its definition in the instance declaration ... but now I have to write conversion functions from the aliased type to my wrapper.
15:17:22 <Kaidelong> Peaker: well you can throw an exception if a person calls it with the wrong types, but that it true, more elegant to know at compile time
15:17:25 <monadic_kid> Peaker: .NET generics have type constraints, they use generic intefaces instead of type-classes but there is no support for higher-kinded polymorphism
15:17:40 <Peaker> elliott, do you know of the Wrapped class? Or conal's SECs and "inNewType" style functions?
15:18:00 <elliott> Peaker: I think I've heard of Wrapped, but never used it -- is it in a hackage package?
15:18:03 <elliott> The latter I haven't seen.
15:18:26 <ddarius> Peaker: I don't think "better type class vocabularies" would be as helpful as some think, though it would help quite a bit.  It certainly would have no impact on the latter part though and encoding with an existential is simply implementing single dispatch.  You get all the benefits and drawbacks.
15:18:27 <Peaker> Kaidelong, It's even worse than that: If you say List<a> inherits Eq, and constraint it to a inheriting Eq, then you can't use lists of unequalables! If you say it doesn't inherit Eq, you just can't use the IEq interface on lists. It's horrible.
15:18:33 <pao> hi all!
15:18:36 <Peaker> elliott, not afaik, it's just a snippet
15:18:46 <elliott> Peaker: got a link? :)
15:18:54 <Peaker> ddarius, I am not sure why you link between what you said and existentials
15:19:10 <pao> how do I convert a Int -> IO String function to a Maybe Int -> IO (Maybe String) func?
15:19:25 <ddarius> Peaker: Because without existentials or some equivalent packaging, you can't get that affect at all.
15:19:30 <ddarius> s/affect/effect/
15:19:41 <Peaker> ddarius, e.g: class HasLength l where length :: l -> Int
15:19:53 <Peaker> ddarius, And all uses of "length" are no longer overly-concrete
15:20:27 <Peaker> elliott, I'll write it down, sec
15:20:40 <ddarius> Peaker: That doesn't help with the latter sentence of what I first said and that is what I was referring to hence "It certainly would have no impact on the latter part though."
15:20:40 <mauke> :t maybe (return Nothing) (liftM Just . ?f)
15:20:41 <lambdabot> forall a (m :: * -> *) a1. (Monad m, ?f::a1 -> m a) => Maybe a1 -> m (Maybe a)
15:20:59 <pao> mauke, that was my take
15:21:00 <ddarius> s/sentence/clause
15:21:20 <pao> mauke, but I have the feeling that there can be something simpler...
15:21:38 <aavogt> @type Data.Foldable.traverse ?f . (`asTypeOf` Just undefined)
15:21:39 <lambdabot> Not in scope: `Data.Foldable.traverse'
15:21:47 <aavogt> @type Data.Traversable.traverse ?f . (`asTypeOf` Just undefined)
15:21:47 <lambdabot> forall (f :: * -> *) b a. (?f::a -> f b, Applicative f) => Maybe a -> f (Maybe b)
15:21:55 <pao> mauke, that generalize over a generic functor and not just Maybe
15:22:15 <Peaker> ddarius, oh, I misread you before, you want to check if an element is in a list of existentially-typed Set-like things?
15:22:26 <pao> aavogt, let me understand
15:22:27 <pao> :-)
15:23:05 <ddarius> Peaker: No, I want to check if an element is in any of a "list" of Set-like things.  You only (explicitly) need existentials (or something similar) in Haskell.
15:23:22 <Peaker> ddarius, data SetLike a = forall s. SetClass s => SetLike (s a) ; isInSetLike :: [SetLike a] -> a -> Bool ?
15:23:57 <Peaker> ddarius, Or simply:  [(a -> Bool)] -> a -> Bool
15:23:59 <pao> aavogt, why don't I have traverse in Data.Foldable? I've got only traverse_
15:24:03 <ddarius> That would be one way of doing it in Haskell which is unpleasant in a few ways and is exactly the "implement single dispatch" that I mentioned.
15:24:19 <aavogt> pao: because it's in Data.Traversable
15:24:32 <Peaker> ddarius, Well, Haskell's type system (+existentials) let you encode the C#/Java-esque inheritance power, but not vice versa
15:24:59 <Peaker> ddarius, And existentials carry many overheads, so it is an advantage that they are not the default in Haskell, and IME they're very very rareful useful
15:25:17 <pao> aavogt, thanks! that has exactly the "generic" signature I was looking for :-)
15:25:48 <Peaker> elliott, http://hpaste.org/42404/wrapped
15:26:28 <Peaker> monadic_kid, Can .NET generics express the "conditional instance" thing?  (instance Eq a => Eq (Maybe a)) which does NOT forbid you from using Maybe on a non-Eq a? 
15:26:54 <elliott> Peaker: right
15:27:06 <elliott> Peaker: It's just a pain to have to write inWrap all the time in the external API :/
15:27:16 <Peaker> elliott, the idea with this class is that you don't
15:27:18 <elliott> or else redefine every function in the wrapped type, for the wrapper
15:27:20 <elliott> Peaker: what, then?
15:27:24 <Peaker> elliott, you just have to make an instance (ideally TH that derives it)
15:27:47 <ddarius> Peaker: I wasn't saying Haskell's type system isn't more powerful than C#/Java's, but I will say that now.  The systems are incomparable.  I can do things in C# that I can't in Haskell and vice versa.  However, while single dispatch can be encoded in Haskell, it isn't the most pleasant or natural thing and it's rarely done even when it would be beneficial.  Also, Haskell can't reasonably encode the full power of bounde
15:27:47 <ddarius> d parametric polymorphism as present in C# or Java.  Let alone a language like Scala.
15:28:24 <elliott> Peaker: yes, but things using the wrapped objects still have to say inWrap.
15:28:25 <Peaker> ddarius, Can you name an incident in real code that would become better/simpler with single-dispatch but wasn't?
15:28:38 <ddarius> -C#- libraries are, in many ways, more flexible/extensible than their Haskell counterparts.  If the C# community also valued immutability more, they'd be even more flexible.
15:28:50 <Peaker> ddarius, What example of bounded parameter polymoprhism does C# have that Haskell can't reasonably encode?
15:29:23 <dobblego> I really prefer data Monoid a = M a (a -> a -> a) to interface Monoid<A> { A blah(A a1, A a2); A empty(); }
15:29:42 <Peaker> ddarius, I'm sorry if I repeat, but I still didn't get what advantage you saw in inheritance-single-dispatch over the way it is encoded in Haskell and I strongly disagree that it is very useful too (can count on one hand the number of times I wanted hetero containers or any other supposed case for existentials)
15:30:12 <dobblego> edwardk is trying to demonstrate that with scala and a library I wrote at this moment
15:30:19 <Peaker> elliott, Yeah, is that a big price to pay?
15:30:25 <elliott> Peaker: Well, it's awkward.
15:30:28 <ddarius> Peaker: Haskell can't encode lower bounds at all.  Haskell can't properly encode even subtyping in my opinion, as I view being able to use a subtype wherever its supertype is asked for (in a covariant context) to be a key feature.
15:30:37 <Peaker> ddarius, Do you have examples for all of that? It sounds almost implausible to me, and you carry on without examples :)
15:30:57 * hackagebot copilot 1.0 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-1.0 (LeePike)
15:31:57 <monadic_kid> Pearker: class Maybe<A> : IEquatable< Maybe<A> > where A : IEquatable<A> ... i think
15:31:59 <Peaker> ddarius, I don't think the implicit existential type *everywhere* in C# /Java is a good idea - in Haskell if the type can be used as another type (i.e: you have a->b, and someone wants a "b", you just call the (a->b) first)
15:32:13 <Peaker> monadic_kid, that means Maybe should always be Equatable?
15:32:23 <monadic_kid> Pearker: yep
15:32:24 <Peaker> monadic_kid, and you cannot use Maybe on non-equatable things?
15:32:34 <ddarius> Peaker: I'm not talking about implicit existentials, I'm talking about what could be viewed as implicit upcasts which are orthogonal to existentials.
15:32:41 <Peaker> monadic_kid, so that's what I was talking about - that their type systems cannot encode conditional instances, and that is horrible
15:33:17 <Peaker> ddarius, I don't find the implicit upcasts a good idea at all, especially in the manner they are implemented in C# and Java, such that different authors' namespaces are mingled up together
15:35:02 <Peaker> ddarius, I would love to see examples and compare them. I think I can find plenty of examples of how type-classes make code more wonderful than the equivalent in C#/Java that force the type to specify *all* interfaces it implements, cannot encode conditional instances, and only support single-dispatch.  I haven't seen examples of code that is ugly in Haskell because it doesn't have inheritance/implicit-upcasts
15:35:33 <Peaker> (I have seen plenty of Haskell code that is ugly IMO because type-classes are under-used and too many concrete API's are used)
15:36:13 <alpounet> ddarius, that's a "reproach" i made months ago but oleg answered right away with some oleg-ish hackery :P
15:37:02 <ddarius> alpounet: I don't know what your referring to with either "reproach" or Oleg's "solution".
15:37:23 <alpounet> to this : <ddarius> Peaker: Haskell can't encode lower bounds at all.  Haskell can't properly encode even subtyping in my opinion, as I view being able to use a subtype wherever its supertype is asked for (in a covariant context) to be a key feature.
15:37:58 <ddarius> And while Oleg has definitely pushed the type system of Haskell, few of those examples are things you'd actually want to seriously use.  Even if you were okay with the encoding costs, the compiler has problems with such code.
15:38:04 <monadic_kid> Pearker: yes if the Maybe is going to be used in Maybe it needs to implement IEquatable, if you wanted to use it in a non-equatable place you'd either implement another interface or convert to System.Object (or any other derived class)
15:38:33 <FunctorSalad> *Peaker ;)
15:39:20 <Peaker> monadic_kid, There are various workarounds, they all have serious drawbacks, and are just horrible
15:39:26 <ddarius> alpounet: And Oleg's "solution."  I can think of one approach where you have an explicit IsSubTypeOf multiparameter type class.
15:39:33 <Peaker> monadic_kid, inheritance of interfaces is just inferior, IMO, to independent, potentially conditional, typeclass instances
15:40:04 <Peaker> alpounet, ddarius: I think when in C# you say something like:  f :: Blah -> Bleh  you're actually saying:  f :: forall a. exists b. (Blah a, Bleh b) => a -> b
15:40:05 <monadic_kid> Peaker: I don't disagree with you, i agree with what you say I rarely need to use sub-type polymorpism
15:40:21 <ddarius> dobblego: I would say edwardk -has- demonstrated that with Scala as he's been able to do things in Scala that he couldn't in Haskell.
15:40:32 <Peaker> alpounet, ddarius: And you can say that in Haskell if you want, but making it the default is very wrong, IMO
15:41:08 <Zol> http://www.youtube.com/watch?v=Eq3CuMDXaPs
15:41:53 <Peaker> ddarius, If edwardk has shown actual examples that's great: I'd love to see examples of things like that in C# or Java 
15:41:55 <monadic_kid> Peaker: I use C++ at work, most of my code is predominantly modulo programming rather than OO because you just don't need sub-type polymorphism in 98% of the time
15:42:13 <Peaker> I can easily believe Scala has various interesting powers that Haskell doesn't based on my limited knowledge of it, but I find it hard to believe with C#/Java
15:42:20 <monadic_kid> *modular programming
15:43:16 <Peaker> monadic_kid, And when sub-type polymorphism is useful, passing around a record of functions is almost always good enough, you don't actually need existentials
15:43:18 <zepard> bye
15:43:57 <monadic_kid> Peaker: The only times I've recently used it is was forced onto me by UI frameworks
15:44:17 <chturne> Why are + and * defined at left-associative in Haskell, when they're associative operators? I think I'm misunderstanding this associative business. Why can't they be defined as non-associate?
15:44:53 <mauke> chturne: because then you couldn't say a + b + c
15:44:54 <aristid> chturne: because they need to be evaluated some way
15:45:11 <augustss> chturne: who says they are associative?
15:45:26 <ddarius> Peaker: One of the main things he is using to go beyond what he was doing in category-extras is bounded (from above and below) types.  In one case, this allows you to have a category with objects "between" Int and Int say, i.e. a category whose objects are forced to be Ints, or things that implement Monoid, or the bounds can be between Top and Bottom, i.e. everything.  You would need different "Category" classes for ea
15:45:27 <ddarius> ch in Haskell.
15:45:27 <augustss> chturne: they are for some types, but not for others.
15:45:48 <aavogt> @check \x y z -> (x+y)+z == x+(y+z :: Float)
15:45:49 <lambdabot>   "Falsifiable, after 2 tests:\n0.3333333\n1.75\n-2.0\n"
15:46:06 <chturne> mauke: Oh, so if you define an operator to be non-associative, Haskell can't compute a <op> b <op> c ... ?
15:46:20 <ddarius> Peaker: As an insane example, he reworked the numeric hierarchy so integers implemented -were- monoids (which -were- categories with one object.)
15:46:26 <mauke> chturne: this is about parsing, not computation
15:46:43 <chturne> ... So it can't parse it then?
15:46:55 <elliott> chturne: indeed
15:46:57 <augustss> chturne: that's right
15:46:57 <mauke> yes, that's what non-associativity is for
15:47:02 <elliott> chturne: is that (a <op> b) <op> c or a <op> (b <op> c)?
15:47:04 <chturne> I see, thanks alot :)
15:47:06 <elliott> it can't know, obviously, unless you tell it
15:47:25 <mauke> > 1 == 2 == 3
15:47:25 <lambdabot>   Precedence parsing error
15:47:25 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
15:47:31 <FunctorSalad> ddarius: sounds like constraint polymorphism or whatever it's properly called (what rmonad does)
15:47:37 <ddarius> Peaker: The main thing keeping C# and Java from being able to do some of this (if anything...) would be the lack of -higher kinded- polymorphism and definitely not type classes.
15:47:51 <FunctorSalad> (that may be a nice feature, yes)
15:48:17 <Peaker> ddarius, Type-classes are keeping C#/Java from doing many many interesting things
15:48:34 <chturne> < augustss> chturne: they are for some types, but not for others.
15:48:34 <chturne> 23:45 -!- Cobra_ [~Cobra@p57B207CD.dip0.t-ipconnect.de] has joined #haskell
15:48:35 <chturne> 23:45 < aavogt> @check \x y z -> (x+y)+z == x+(y+z :: Float)
15:48:35 <chturne> 23:45 < lambdabot>   "Falsifiable, after 2 tests:\n0.3333333\n1.75\n-2.0\n"
15:48:35 <chturne> 23:45 < chturne> mauke: Oh, so if you define an operator to be non-associative, Haskell can't compute a <op> b <op> c ... ?
15:48:38 <chturne> 23:45 -!- Gracenotes [~person@wikipedia/Gracenotes] has quit [Remote host closed the connection]
15:48:39 <FunctorSalad> class Category class (~>) where (.) :: (class a, class b, class c) => ...
15:48:39 <monadic_kid> ddarius,Peaker: another annoying thing about .NET type contraints is you can not have interfaces with operators, so can have constraints using operators
15:48:41 <chturne> 23:45 < ddarius> Peaker: As an insane example, he reworked the numeric hierarchy so integers implemented -were- monoids (which -were- categories 
15:48:45 <chturne>                  with one object.)
15:48:47 <chturne> 23:45 < mauke> chturne: this is about parsing, not computation
15:48:50 <chturne> 23:46 -!- Gracenotes [~person@wikipedia/Gracenotes] has joined #haskell
15:48:52 <chturne> 23:46 < chturne> ... So it can't parse it then?
15:48:55 <chturne> 23:46 < elliott> chturne: indeed
15:48:56 <monadic_kid> *can't have constraints using operators
15:48:58 <chturne> 23:46 < augustss> chturne: that's right
15:49:00 <chturne> 23:46 < mauke> yes, that's what non-associativity is for
15:49:01 <aristid> chturne: what are you doing?
15:49:02 <chturne> 23:46 < elliott> chturne: is that (a <op> b) <op> c or a <op> (b <op> c)?
15:49:05 <chturne> 23:46 < chturne> I see, thanks alot :)
15:49:05 <elliott> chturne: umm, stop that.
15:49:06 <aristid> @where ops
15:49:06 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:49:07 <chturne> 23:46 < elliott> it can't know, obviously, unless you tell it
15:49:10 <chturne> 23:46 -!- theorbtwo [~theorb@91.84.53.6] has joined #haskell
15:49:11 --- mode: ChanServ set +o mauke
15:49:12 --- kick: chturne was kicked by mauke (chturne)
15:49:18 <Peaker> ddarius, I still don't agree with you that C#/Java type systems can encode anything interesting that Haskell cannot reasonably encode (probably more concisely even in the worst cases for Haskell, though that may not hold)
15:50:22 <monadic_kid> Peaker: you can't have IEquatable using operators, got to be named methods
15:50:27 <aristid> Peaker: the haskell records systems is pretty sub-optimal tho
15:50:42 <augustss> Haskell records suck
15:51:12 --- mode: mauke set -o mauke
15:51:14 <FunctorSalad> Peaker: I think ddarius's point was that the upcasts are *implicit*... in contrast to an explicit function ConcreteType -> WithRecordOfFunctions ConcreteType?
15:51:32 <Peaker> aristid, Yeah.. Haskell has many faults. I was claiming that Haskell's (type-classes + records + existentials, and other consensual GHC extensions, perhaps) do everything C#/Java inheritance/single-dispatch does, better, and then far more
15:51:37 <aristid> FunctorSalad: a better record system might allow doing that, no?
15:51:40 <monadic_kid> well at least there people trying to tackle the "records suck" problem, lots of proprosals. This might go away in a future version of haskell
15:51:52 <Peaker> FunctorSalad, Type-class dictionary passing is also implicit
15:51:57 <FunctorSalad> (I don't have a strong opinion on how important the implicity is, just saying)
15:52:55 <Peaker> aristid, I don't currently believe (though I may be convinced otherwise) that there is any interesting example that is nicely encoded by Java/C#'s inheritance/type-system that cannot be as concisely and reasonably encoded in Haskell (or at worst slightly less concisely, though I disbelieve that too)
15:53:08 <aristid> i think i have actually written type classes to get some common elements from a bunch of records
15:53:19 <aristid> and that's pretty annoying labor
15:53:22 <Peaker> This all started because I stated I think inheritance is a bad idea: always.   I think it was just a historical mistake
15:53:24 <FunctorSalad> Peaker: yes, though I think you still need to explicitly wrap things in existentials sometimes (for storage in a list etc)
15:54:01 <Peaker> FunctorSalad, Yes, and the syntax for that is considered a pain in Haskell, and even that is far more concise than the syntax to do anything trivial in C#/Java :) And conceptually it's not really any more complex than what's happening all over the place in C#/Java (implicit forall/exists on every type)
15:55:28 <Peaker> I think it is a bit sad that new programming languages are all basing their main polymorphism mechanisms around inheritance
15:55:40 <Peaker> s/new/new mainstream
15:55:57 <romildo> In the application I am writing I want to open a file with an appropriate program, as does most of the file managers. In my case the file is a movie, and I want to play it from my Haskell application. I am using gtk2hs. Is there support for this in any library?
15:56:41 * augustss agrees with Peaker.
15:57:24 <FunctorSalad> one advantage of interfaces over records of functions (in C#) is that visual studio will automatically generate the method stubs for you ;)
15:57:30 <FunctorSalad> j/k
15:57:46 <Saizan> romildo: where "this" is decide which is the appropriate program?
15:58:19 <FunctorSalad> ('j/k' on it being somehow an intrinsic language feature, though I do find the editor support convenient ;))
15:58:22 <romildo> Saizan, maybe from the mime type data base.
15:59:53 <ezyang> @tell copumpkin Here is the GHC 7.0 fixed Hoopl. http://web.mit.edu/~ezyang/Public/hoopl/ 
15:59:53 <lambdabot> Consider it noted.
16:00:15 <Saizan> romildo: i don't know if there's a lib for that
16:00:19 <romildo> Saizan, I want a button on my application that, when clicked, a dialog would appear to choose a program to be used to open the file, with a reasonable default.
16:04:19 <Saizan> my guess would be that such things are only present in gnome/kde/.Xdefault configurations/conventions on linux, while windows and osx probably have some more centralized registry
16:05:38 <Saizan> though you might only care about what's available, but that'd require a scan of the system
16:05:55 <Saizan> it seems a very messy domain in any case
16:06:55 <FunctorSalad> kde does have a file association database, though I have no idea how to access it in haskell
16:07:04 <FunctorSalad> (maybe it's some relatively easy to parse file?)
16:10:30 <nagnatron> I haven't checked it in quite  some time but the wikipedia page for Monads is awesome.
16:12:43 <romildo> As I am using gtk2hs, I was hoping that there is something in the set of libraries that complement gtk+. Maybe gio, although I know almost anything about it yet.
16:19:45 <romildo> Is there a good library for saving/reading configurations for an application?
16:22:07 <hpc> hmm, going through the wikipedia page for monads, it occurs to me that one could explain the kleisli category by using the identity monad
16:22:09 <megajosh2> Does anybody know if Network.HTTP can send things over https?
16:22:12 <hpc> and comparing bind to ($)
16:22:28 <hpc> and return = id
16:24:09 <ezyang> bind is more like flip ($) 
16:24:42 <ezyang> And when we're in the Kleisli category we think more about >=> and <=< 
16:26:17 <Saizan> the kliesli triple has >>= though as element :)
16:26:51 <ezyang> bah humbug 
16:27:35 <polux_> hello, has there been more satisfying answer to that question recently? https://groups.google.com/d/msg/haskell-cafe/lbxUZBdEYnQ/RXfaYw5xoSYJ
16:27:50 <polux_> the question is: Has anybody replicated =~ s/../../ or even something more basic for doing replacements with pcre haskell regexen?
16:28:00 <polux_> the answer was: no
16:31:14 <hpc> ezyang: obviously it wouldn't just be "bind == ($) and category! shazam!"
16:31:32 <hpc> polux_: i don't think so
16:33:06 <polux_> hpc: ok
16:33:11 <hpc> i've been searching for ages
16:33:37 <polux_> hpc: by looking at the conversation, I have found http://patch-tag.com/r/tphyahoo/haskell-learning/snapshot/current/content/pretty/regexStuff/pcreReplace.hs
16:33:51 <polux_> I'm not sure it has the same semantics as, say, sed
16:33:59 <polux_> but it looks like
16:34:06 <polux_> it does
16:34:25 <polux_> (sorry my last sentence was broken into two lines)
16:34:37 <ion> > > subRegex (mkRegex "(o+)") "foobar" "(\\1)"
16:34:38 <lambdabot>   <no location info>: parse error on input `>'
16:34:40 <ion> whoops
16:34:42 <ion> > subRegex (mkRegex "(o+)") "foobar" "(\\1)"
16:34:42 <lambdabot>   Not in scope: `subRegex'Not in scope: `mkRegex'
16:35:04 <ion> Oh well, needs ‘import Text.Regex’.
16:35:44 <necroforest> What's the name of a type system that lets you have something like: f :: (a->b) -> [a] -> [b] ?
16:35:51 <necroforest> (i.e, a and b can be any type)
16:36:01 <necroforest> I want to say 'generic' but I don't think that's correct.
16:36:32 <hpc> necroforest: you are confused, i think
16:36:40 <hpc> "type system" is not the word you are looking for
16:37:27 <necroforest> i'm not really confused, I just don't know what the terminology is
16:37:32 <hpc> ah, k
16:37:40 <hpc> could you give more examples of stuff similar to your f?
16:38:09 <hpc> it could be you want "functor", "polymorphic", "hindly-milner", anything really
16:38:23 <necroforest> I'm just talking about having the type of something be parameterized... i.e, f :: a -> a
16:38:49 <hpc> ah
16:38:58 <megajosh2> Hey, does anybody know how most people would go about sending an HTTP request over SSL with Haskell?
16:39:01 <hpc> the function would be polymorphic
16:39:07 <necroforest> ok
16:39:37 <FunctorSalad> "type system supporting parametric polymorphism"?
16:41:35 <hpc> megajosh2: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023587.html
16:41:45 <hpc> top result when googling "haskell ssl"
16:41:57 <hpc> "haskell https" yielded no help either
16:43:09 <polux_> ion: cool, thanks
16:43:46 <hpc> megajosh2: oh wait, i'm dumb: http://hackage.haskell.org/package/HsOpenSSL-0.9
16:44:13 <hpc> (first release is a few months after that linked email)
16:45:04 <necroforest> FunctorSalad, that sounds good :)
16:49:04 <mikeg> I think the curl package can work with SSL, no?
16:49:12 <aristid> mikeg: yea
16:49:30 <mikeg> imo that's the "obvious" way to do it
16:49:47 <megajosh2> Oh good
16:50:01 <aristid> curl supports it, http-enumerator too (but http-enumerator is still pretty young and has some bugs and lacks some other features which curl has)
16:50:07 <megajosh2> For a second there I thought I had to do a lot of stuff manually
16:53:08 <NemesisD> is there a way to use where with guards?
16:54:45 <megajosh2> What do you mean?
16:55:14 <kmc> yes; the primary advantage of "where" over "let" is that it scopes over a set of guards
16:55:44 <kmc> > let { f x | odd x = g "odd" | even x = g "even" where g s = "It's " ++ s } in f 3
16:55:45 <lambdabot>   "It's odd"
16:55:48 <hpc> where is also more fun to read out loud
16:55:57 <lispy_> hey
16:56:00 <lispy_> How's it going?
16:56:19 <kmc> one annoyance in Haskell is that data sometimes flows left-to-right, top-to-bottom, and sometimes right-to-left, bottom-to-top
16:56:40 <kmc> i know a few mathematicians who want to redefine function composition and application by reversing the args
16:56:53 <kmc> and i think this would make Haskell nicer too, if we weren't already so used to the opposite
16:57:08 <lispy_> learning to read the order of data does trip up quite a few haskell beginners :(
16:57:25 <kmc> (>>>) is such a visually heavier operator than (.)
16:57:37 <lispy_> kmc: use a unicode symbol
16:57:52 <lispy_> (I don't know which one to recommend, just saying)
16:58:31 <kmc> the Prelude-unused single-character ASCII operators are (!)  (#)  (&)  (%)
16:58:43 <kmc> i know this because i've used them for code obfuscation ;)
16:59:09 <conal> lispy_: "hey" directed at me?
16:59:32 <medfly> ...
17:00:11 <lispy_> conal: just being friendly, not directed at anyone really :)
17:00:32 <lispy_> conal: Although, since you asked, how's it going Conal?
17:00:40 <conal> lispy_: ah :)  going well on my end. we got a lot of rain here last night. i just took a walk down to the creek. as high as i remember ever seeing it.
17:00:59 <lispy_> cool, it snowed a tiny bit here last night
17:01:00 <hpc> kmc: there's also the hilarious few instances in which it goes from the edges to the middle
17:01:15 <kmc> like what hpc?
17:01:22 <kmc> using (>>=) together with (.) and ($) has that kind of mis match
17:01:43 <hpc> :t ((x >>=) =<<)
17:01:44 <lambdabot>     Ambiguous occurrence `x'
17:01:44 <lambdabot>     It could refer to either `L.x', defined at <local>:1:0
17:01:44 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:73:0-32
17:01:51 <hpc> :t \x -> ((x >>=) =<<)
17:01:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> m b) -> m b
17:01:57 <conal> lispy_: and i'm studying cuda and exploring what high-level functional specs might be that could compile down to the sort of programs people now write in low-level cuda style.
17:02:20 <hpc> kmc: there's some sections of (.) that can do it
17:02:31 <mikeg> @let f·g = g.f
17:02:32 <lambdabot>  Defined.
17:02:36 <hpc> :t \x -> ((>>= x) =<<)
17:02:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m (m a) -> m b
17:03:05 <hpc> :t (>>=) . join
17:03:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (m a) -> (a -> m b) -> m b
17:03:18 <hpc> nifty
17:03:19 <aristid> :t \m k -> join m >>= k
17:03:19 <lispy_> conal: cuda is (mostly) general purpose computation using GPU?
17:03:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (m a) -> (a -> m b) -> m b
17:03:26 <lispy_> conal: Nvidia specific, IIRC?
17:03:29 <hpc> lispy_: indeed
17:03:36 <conal> lispy_: yes on both.
17:04:10 <lispy_> conal: do you have any opinion about cuda vs. opencl?  Also, did you see that bitcoin miners like to use cuda to generate bitcoins
17:04:49 <conal> lispy_: i haven't studied opencl yet. i may switch to it after a while. i hear that opencl compilers aren't very good yet.
17:05:29 <conal> right now i'm mainly retooling my head to think about programming with zillions of threads.
17:05:50 <conal> pretty fun.
17:06:00 <lispy_> conal: yes, opencl is much less mature but well, it's open (I learned this 3rd hand, it was a big debate at Super Computing this year)
17:07:06 <conal> lispy_: yep. though not a 'but' for me, as i don't mind learning both, shifting to opencl as its implementations improve.
17:07:26 * kmc did GPGPU before it was cool
17:07:38 <kmc> aka in GLSL representing all your data as RGBA quadruplets and textures
17:07:49 <conal> kmc: hard core.
17:07:50 <kmc> i haven't used any of the nicer frameworks, i'm sure they make everything i did before trivial
17:08:14 <kmc> also it was mainly difficult because every card implements an incompatible subset of GLSL and lies about which
17:08:21 <hpc> conal: you also have to retool your head to think around branch-less code
17:08:24 <kmc> i don't know if CUDA has the same problem; i've heard third-hand that it does
17:08:28 <lispy_> conal: I'm learning Isabelle these days
17:08:58 <conal> there's now also Thrust, a Boost-like library on top of cuda. much less tedious coding.
17:09:02 <conal> lispy_: nice!
17:09:20 <conal> hpc: that's what i hear.
17:09:58 <conal> hpc: minimizing branching to avoid stalling processors.
17:11:15 <patrickthomson> Are there any good tutorials on the 2.x versions of QuickCheck? The documentation is a little baffling.
17:11:44 <hpc> conal: there's apparently tricks that let you cheat and get some branching, but it's thesis-level stuff
17:12:35 <conal> hpc: are you talking about lack of branching, or expensive to branch?
17:12:45 <hpc> expensive to branch
17:13:03 <kmc> the ratio of control units to arithmetic units is increasing, right?
17:13:07 <hpc> er
17:13:19 <hpc> it turns lack of branching into some branching, which is expensive
17:13:22 <hpc> and i forget how
17:13:33 <kmc> it used to be that the expense of a conditional was always the expense of both sides
17:13:38 <kmc> you just compute both and throw one away
17:13:46 <kmc> but i think modern GPUs have some control flexibility
17:13:53 <kmc> multiple independent SIMD units
17:14:01 <hpc> so i have heard
17:14:18 <kmc> i did GPGPU on basically the first card designed for it, the GeForce 8800
17:14:21 <kmc> and it was fucking sweet
17:14:24 <kmc> and that was in 2007 ish
17:14:36 <hpc> yeah, the 8800 was a fantastic card
17:14:43 <kmc> btw EC2 has GPU instances now
17:14:51 <hpc> it ran mirror's edge better than this 5870 does
17:18:30 <conal> i don't think i've quite gotten my head around the architecture. sometimes branching is expensive and sometimes not. depending on whether thread divergence is within a warp or between warps.
17:19:01 <hpc> wtf is a warp?
17:19:21 <hpc> oh, simd group
17:19:26 <kmc> obviously, you're not a weaver
17:19:55 <kmc> presumably all the threads in a warp pay the cost of all branches taken within that warp
17:20:12 <hpc> yeah
17:20:39 <hpc> oh, that's what it was
17:20:44 <hpc> (the paper)
17:21:09 <hpc> it's a utility that rewrites branches so it runs true on one warp, and false on another
17:21:18 <conal> oh wow.
17:21:33 <conal> hpc: do you have a ref to that paper?
17:21:45 <hpc> i don't; i didn't save the link
17:21:48 <kmc> it seems like some dynamic scheduling between warps is in order
17:22:08 <patrickthomson> @quote Perl
17:22:08 <lambdabot> ben_m says: "perl -MTime::HiRes=sleep -e '$|++; for(1..30) { print "\r8" . "=" x $_ . "D"; sleep 0.2 }'"
17:22:15 <patrickthomson> @quote relative
17:22:15 <lambdabot> ghc says: ld64: INFO    171: Multigot invoked. Gp relative region broken up into 2 separate regions.
17:22:18 <patrickthomson> damnit
17:22:25 <kmc> @ghc
17:22:25 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: ZCt{tc a2AN} (* -> *) -> * -> *
17:22:33 <conal> hpc: i'll probably run into it in my studies.
17:22:33 <kmc> that sounds painful
17:22:39 <hpc> oh man, if GPUs ever get the equivalent of CPU out of order execution
17:22:39 <kmc> @ghc
17:22:39 <lambdabot> ghc says: Can't represent Oxford brackets
17:23:14 <hpc> (as in, a hardware scheduler for warps and branches, etc)
17:24:01 <conal> from what i read, the scheduling is all hardware, switching in a single cycle.
17:25:35 <conal> and using massive multi-threading as an alternative to tricks like out-of-order. "throughput-oriented" rather than (low) "latency-oriented". hiding single-thread latency rather than minimizing it.
17:28:06 <conal> does anyone here know of work on deriving parallel (imperative) algorithms from functional ones?
17:28:38 <hpc> no
17:28:45 <conal> i'm playing with deriving parallel prefix sum and parallel histogram, as simple first case studies.
17:28:59 <hpc> i doubt significant work has been done, as both are new and disparate fields
17:29:12 <hpc> (for certain values of new, i suppose)
17:30:46 <conal> and yet a natural fit, since functional programming isn't intrinsically sequential.
17:31:12 <hpc> indeed
17:34:16 <aristid> conal: http://www.youtube.com/watch?v=NWSZ4c9yqW8 ?
17:34:44 <conal> aristid: thx for the reminder. i still haven't watched that video.
17:34:58 <aristid> quick quick
17:35:05 <hpc> i would watch that video but oh god, comic sans in the powerpoint
17:35:22 <aristid> and carrots
17:35:36 <aristid> just close your eyes and hope the spoken words suffice
17:38:42 <conal> hpc: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.3423 ?
17:40:31 <hpc> not it, but still cool
17:56:47 * ddarius goes to get some mediocre sushi.
17:57:40 <copumpkin> ddarius: enjoy! did the guy from that sushi place ever call you back?
17:57:40 <lambdabot> copumpkin: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:58:39 <copumpkin> @tell ezyang hmm, it fails at getting that repo, not sure why
17:58:39 <lambdabot> Consider it noted.
18:06:31 <lispy_> copumpkin: darcs?
18:06:37 <copumpkin> yeah
18:06:54 <copumpkin> darcs get http://web.mit.edu/~ezyang/Public/hoopl/
18:06:56 <copumpkin> maybe it's just me
18:09:46 <aristid> did i mention how nice it is to use github, even if darcs may have some technological advantages?
18:10:02 <kmc> what are darcs's technological advantages?
18:10:04 <gwern> nah, broken here too
18:10:15 <gwern> kmc: a heck of a lot easier to understand, I think
18:10:31 <aristid> kmc: i didn't want to say it actually has them, i don't really care about that
18:11:11 <kmc> gwern, i think git is pretty easy to understand, especially if you're used to thinking in terms of immutable data and sharing between versions
18:11:16 <lispy_> copumpkin: it's not just you
18:11:32 <gwern> git has always seemed very alien to me, though I took to darcs like a duck to water
18:11:34 <kmc> it's haskelly in spirit, even though it's implemented in C and shell
18:11:36 <kmc> but i haven't tried to understand darcs in detail
18:11:39 <kmc> so it might still be easier
18:11:40 <lispy_> copumpkin: if you add --lazy it works, but will break eventually
18:11:46 <aristid> in my last bigger c++ project, i found a collaborator through github. or actually, he found us. it really is about more than just the fact that it uses git
18:12:55 <lispy_> aristid: yes, github is really nice.  I wish they were darcs friendly but oh well.
18:14:00 <gwern> nobody likes darcs. ohloh just gave us the run-around or ignored us for years
18:14:19 <aristid> nobody likes to spend effort
18:14:20 <gwern> and I don't give good odds to them accepting any future darcs support we write for them...
18:14:37 <aristid> wasn't ohloh bought by some company?
18:15:09 <lispy_> Who cares about ohloh?  They don't even have a pronunciation guide for their made-up-word name.  How can I even talk about them?
18:15:22 <gwern> obviously it's 'oh-low'
18:15:44 <lispy_> clearly it's all-oh
18:15:45 <gwern> lispy_: dons apparently did considering how he spent many hours getting haskell stuff into ohloh and publicizing it. are you questioning the great dons?
18:15:58 <kmc> :
18:16:52 <olsner> I think it's more like ochloch
18:17:17 <kmc> lispy_, needing to talk about companies with vocal speech is so Web 1.0
18:17:17 <gwern> olsner: dat cannae be passible!
18:19:48 <lispy_> But, seriously, what does ohloh do that is useful?
18:19:54 <lispy_> How does it help me?
18:20:12 <aristid> statistical graphs!
18:20:29 <aristid> but it's probably too broken to be useful
18:21:13 <gwern> lispy_: it ranks programmer penis sizes
18:21:49 <lispy_> gwern: oh, well in that case...
18:23:45 <sshc> Huh, the 'm' type parameter in the Monad class should be of kind "* -> *", right?
18:23:53 <kmc> yes
18:28:01 <sshc> Do I need to use special syntax to indicate that a type synonym variable (type families) in a class decleration (I forget the correct term) has kind "* -> *"?
18:29:02 <kmc> the parameters of an associated type synonym have to be a subset of the parameters of the class
18:29:34 <kmc> so you shouldn't need a kind annotation unless you needed a kind annotation without the asstype
18:29:50 <kmc> for the parameters, that is
18:29:54 <kmc> however you might need to annotate the "result" kind of the synonym
18:31:12 * applicative thinks, "but kind signatures look great, and they provide a kind of documentation for the user..."
18:31:35 <kmc> hahaha
18:31:45 <kmc> just use :k ;)
18:31:58 <Saizan> note that "type family Foo (x :: *)" and "type family Foo :: * -> *" are not equivalent, even if in both cases Foo accepts a * and produces a *
18:32:00 <kmc> i'm totally upset that i can't write "sort signatures"
18:32:17 <applicative> @kind IO
18:32:17 <lambdabot> * -> *
18:32:20 <hpc> sort is evil
18:32:52 <kmc> right.  a type family takes one or more "index" types and then zero or more types which are parametric in the usual way
18:47:45 <Entroacceptor> anyone up to help me install digestive-functors-happstack?
18:48:14 <Entroacceptor> I get some mtl-2.0.0.0/mtl-2.0.1.0 conflicts
18:53:37 <applicative> hmm, digestive-functors wants monads-fd >= 0.1 
18:55:54 <applicative> happstack-server wants mtl (?1.1 & <2.1)
19:00:38 <turiya> is there a way to make a resizable window without a title bar in wxhaskell?
19:00:56 <kmc> is there a way to do it in wx?
19:01:22 <turiya> kmc, i am not sure
19:01:52 <kmc> i'd start there; the answers are likely to be the same, and there will be more documentation for wx than for wx + obscure language
19:02:08 <kmc> if the answers are not the same, finding out how to do it in C++ or Python is still a good first step for hacking that feature into wxhaskell
19:03:19 <turiya> kmc, from the c++ manuals atleast I could not find a way to obtain that feature
19:04:06 <kmc> maybe you can do it non-portably by calling X or Windows directly
19:04:19 <kmc> there are pretty good Xlib bindings for Haskell
19:05:45 <turiya> yes, i tried those bindings some time back but it is too much of work sometimes [creating menu's and stuff]
19:06:57 <Entroacceptor> applicative: so, no?
19:10:19 <applicative> Entroacceptor, oh sorry, I got lost once again trying to comprehend the monad transformer library situation.
19:10:22 <kmc> yeah programming a whole GUI in X would suck
19:10:33 <kmc> but i mean maybe you can use wxhaskell and call X only to set special window properties that wx doesn't know about
19:13:38 <turiya> can Xlib and wxhaskell be used in the same application?
19:13:47 <Entroacceptor> applicative: ah :) I don't even know what the libs are doing...
19:13:50 <kmc> i am not sure; i'm speculating
19:14:47 <kmc> there's no obvious reason they couldn't; wx is making X calls anyway, and it could provide the necessary information (window handles or whatever) so you can make the calls yourself
19:14:58 <kmc> of course you lose portability to non-X systems
19:15:25 <applicative> Entroacceptor, I assume it's telling you that half of the dependencies are using mtl-2.0.0.0, and half are using mtl-2.0.1.0?
19:15:27 <kmc> although it is possible, windows users tend to get annoyed when you make them install an X server just to use your app ;)
19:15:31 <turiya> portability is an issue but it would still be good to know how that is done
19:15:59 <kmc> of course what i'm proposing could be done, separately, for windows
19:16:12 <kmc> and the code built with one or the other depending on the target platform
19:17:13 <turiya> yes, that could be done especially if the platform-dependent code is small
19:17:20 <Zao> Most toolkits have ways to expose a native window "handle".
19:17:36 <Zao> Maybe not for every control, but most certainly for top-level windows.
19:20:27 <turiya> should read on mixing xlib and wxhaskell
19:22:52 <revenantphx> So if I want to read out a fixed amount of data with attoparsec, what'd be the tidiest way to do so?
19:22:59 <kmc> turiya, you should probably read on mixing xlib and wx
19:23:14 <revenantphx> using `take` and then converting from the bytestring seems to be the best option I see.
19:23:18 <kmc> i doubt that the fact you're programming in Haskell will have much bearing on this task
19:23:40 <kmc> you can write your special window manipulation in C and call that, though i doubt it will be necessary
19:24:01 <kmc> revenantphx, seems reasonable.  slicing a bytestring into a smaller bytestring should be a cheap operation
19:24:13 <kmc> (because bytestrings are stored as pointer + length + offset)
19:24:17 <revenantphx> Chances are since it's lazy, it's never actually going to "slice" it anyhow.
19:24:23 <kmc> could be
19:24:28 <revenantphx> oh, well I guess the bytestring isn't lazy.
19:24:39 <kmc> and even if it were, lazy bytestring is lazy in chunks
19:24:46 <revenantphx> But since it's immutable, it probably won't ever copy the data at all.
19:25:18 <revenantphx> What would I use to get an Int out of a bytestring?... binary >_>?
19:25:30 <turiya> kmc, oh yeah, wx and xlib 
19:25:34 <revenantphx> I'll look at Data.Binary's source code.
19:25:36 <bsmntbombdood> http://hpaste.org/42408
19:25:47 <bsmntbombdood> is that canonical?
19:26:03 <revenantphx> @hackage binary
19:26:03 <lambdabot> http://hackage.haskell.org/package/binary
19:26:20 <kmc> revenantphx, my point was that it doesn't copy the data, because it can produce another bytestring with different length and offset and the same pointer
19:26:24 <kmc> i think that's roughtly the same as your point
19:26:27 <revenantphx> Right.
19:26:35 <kmc> bsmntbombdood, those are in Data.List i think
19:26:43 <kmc> @src isInfixOf
19:26:43 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
19:26:48 <kmc> @src isPrefixOf
19:26:49 <lambdabot> isPrefixOf [] _          = True
19:26:49 <lambdabot> isPrefixOf _  []         = False
19:26:49 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
19:26:49 <revenantphx> It's the same optimization you can make in any case with immutable strings/buffers.
19:26:57 <bsmntbombdood> kmc: i know, just practicing
19:26:59 <revenantphx> The catch22 in most languages is memory...
19:27:02 <kmc> oh
19:27:05 <kmc> then what are you asking bsmntbombdood?
19:27:06 <revenantphx> unless you have garbage collection, it's a pain in the butt.
19:27:15 <kmc> revenantphx, most languages have garbage collection
19:27:18 <applicative> Entroacceptor, have you tried adding a constraint, so it's like cabal install digestive-functors digestive-functors-happstack --constraint=mtl mtl-2.0.0.0 
19:27:29 <revenantphx> kmc: some, such as C, do not :P.
19:27:35 <kmc> i think the world has finally stopped pretending C++ is the typical programming language.  Java maybe in 20 years
19:27:41 <kmc> revenantphx, yes.  you said "most languages".
19:27:46 <revenantphx> Heh, true.
19:27:47 <applicative> Entroacceptor, the syntax is something like that
19:27:47 <Codex_> if I have a type and want to enumerate all values of it, what would be best way to do it?
19:27:55 <kmc> the catch (22?) in C is memory, i'll grant
19:28:20 <kmc> Codex_, is your type an instance of the type class Enum?
19:28:24 <kmc> > [minBound ..] :: [Bool]
19:28:25 <lambdabot>   [False,True]
19:28:29 <kmc> > [minBound ..] :: [Char]
19:28:29 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
19:28:36 <revenantphx> :t ($!)
19:28:37 <lambdabot> forall a b. (a -> b) -> a -> b
19:28:47 <kmc> @src ($!)
19:28:48 <lambdabot> f $! x = x `seq` f x
19:28:54 <Codex_> kmc: ok, that looks nice way to do it.
19:28:57 <ddarius> copumpkin: I don't think so, but it's possible he did and I didn't answer and he didn't leave a message.
19:29:07 <kmc> Codex_, you can use "deriving (Enum)" on some types you define, but not all
19:29:11 <Entroacceptor> applicative: that syntax seems to have worked
19:29:14 <kmc> or you can write the instance yourself
19:29:21 <revenantphx> Trying to see how Binary reads ints and such from bytestrings.
19:29:22 <bsmntbombdood> kmc: where can i find that source?
19:29:28 <kmc> bsmntbombdood, for Data.List?
19:29:32 <ddarius> copumpkin: I have a sofa and a desk now.  But no desk chair...
19:29:33 <kmc> http://www.haskell.org/ghc/docs/latest/html/libraries/
19:29:43 <kmc> that is The Page to bookmark
19:29:50 <Codex_> kmc: I was having small problems with things that other languages do with for-loops. But enumerating the elements will fix it
19:29:50 <revenantphx> Is there an... easier way?
19:29:51 <Entroacceptor> oh, or not
19:30:12 <kmc> revenantphx, there's more than one way to read an Int from a bytestring
19:30:17 <revenantphx> Sure, what would you suggest?
19:30:24 <kmc> i mean, there's more than one interpretation
19:30:27 <revenantphx> Ah.
19:30:29 <bsmntbombdood> kmc: just seeing type signatures, am i missing something?
19:30:35 <kmc> bsmntbombdood, the links labeled "source"
19:30:46 <kmc> revenantphx, do you mean, say, a 32-bit integer in little-endian order?
19:30:49 <revenantphx> big-endian.
19:30:52 <kmc> okay
19:30:57 <revenantphx> and I'm going to need 8, 16, 32, and 64
19:31:05 <revenantphx> I also need to figure out how to read swapped IEE754 floats.
19:31:09 <applicative> Entroacceptor, oh cool.  
19:31:10 <bsmntbombdood> kmc: cool, thanks
19:31:11 <revenantphx> fun times.
19:31:19 <kmc> revenantphx, see data-binary-ieee754
19:31:23 <Entroacceptor> applicative: no, doesn't
19:31:24 <revenantphx> I'm aware of that.
19:31:34 <ddarius> revenantphx: You should implement an arbitrary precision floating point library.
19:31:34 <Entroacceptor> cabal: dependencies conflict: happstack-server-0.5.1 requires mtl ==1.1.0.2
19:31:38 <kmc> if you're dismayed at the complexity of the code in binary... why not use the library?
19:31:42 <revenantphx> ddarius: good idea.
19:31:45 <kmc> then you don't need to implement it yourself :)
19:31:45 <revenantphx> So... should I just use binary within this attoparsec parser?...
19:31:51 <kmc> probably
19:31:56 <kmc> unless you want to micro-optimize for speed
19:32:07 <revenantphx> I can always change the functions later though.
19:32:09 * ddarius -loves- micro-optimizing for speed.
19:32:36 <kmc> i'm sure you can write a really fast ByteString -> Word64 using C and/or unsafe ops, especially for the platform byte order
19:32:48 <bsmntbombdood> the worst-case time complexity of that isInfixOf is O(m * n) right?
19:32:48 <kmc> you just peek the ByteString's ForeignPtr
19:33:32 <ddarius> bsmntbombdood: Yes.
19:33:55 <applicative> Entroacceptor, damn, I think your happstack is too old for this?   Its using an mtl digestive functors rejects?  But I cant be sure. 
19:34:25 <kmc> help doctor, i think i've got digestive functors
19:34:29 <Entroacceptor> applicative: from what I know I installed the -darcs version of happstack
19:34:39 <Entroacceptor> but I have no idea which mtl it uses
19:34:45 <revenantphx> kmc: ... that sounds really fun.
19:35:05 <kmc> revenantphx,  not as fun as loading machine code into a ByteString and then executing it
19:35:06 <Entroacceptor> the cabal file has >=1.1 && <2.1
19:35:11 <revenantphx> kmc: heh.
19:35:12 <kmc> "anything C can do, we can do better"
19:35:17 <revenantphx> "....in C"
19:35:23 <kmc> i didn't use any C for that
19:35:24 <revenantphx> "... in Haskell"
19:35:30 <revenantphx> "... in a ByteString."
19:35:54 <revenantphx> Now to go look up the unsafe ops. >:D
19:36:00 <revenantphx> Er but...
19:36:07 <kmc> i'm just disappointed that GHC's homegrown ELF / PE dynamic linker isn't written in Haskell
19:36:09 <revenantphx> is there anything I should be worried about?
19:36:23 <kmc> yes, you should be worried about fucking it up and crashing the program
19:36:24 <revenantphx> Causing untraceable errors or some jazz like that?
19:36:32 <kmc> you should be exactly as worried as you are when programming in C
19:36:40 <kmc> revenantphx, you might like http://mainisusuallyafunction.blogspot.com/2010/09/executing-bytestring.html
19:37:00 <revenantphx> nice
19:37:08 <kmc> revenantphx, did you profile the version using "binary" and conclude it's too slow?
19:37:13 <kmc> btw, are you running this on a big-endian machine?
19:37:24 <revenantphx> No, the machine is little endian.
19:37:32 <revenantphx> And no, I just wanted to try it with attoparsec.
19:37:35 <revenantphx> I can compare them later.
19:37:37 <kmc> then peeking a big-endian 32-bit word is probably not going to work
19:37:46 <kmc> you'll have to do an endian-swap anyway
19:37:49 <revenantphx> I can do some bit fiddling >_>
19:37:56 <revenantphx> is there any way to... inline C?
19:37:56 <kmc> at which point the theoretical speed advantage over the safer approach vanishes
19:38:07 <revenantphx> aw... but but the fun...
19:38:10 <kmc> revenantphx, .... that would be a brilliant quasiquoter
19:38:20 <kmc> revenantphx, i agree it's fun and i encourage you to try the unsafe hack
19:38:25 <revenantphx> quasiquoter?
19:38:26 <yac> hello, could you explain or give me a hint why am i getting http://pastebin.blesmrt.net/index.php/view/7d50eeb3 in http://pastebin.blesmrt.net/index.php/view/7e39eb0a ?
19:38:29 <kmc> but i don't think it's what you'd want for Real Code
19:38:34 <revenantphx> you mean like lisp?
19:38:37 <kmc> ;)
19:38:44 <ddarius> kmc: It actually would not be hard to make an inline C quasiquoter.
19:39:01 <revenantphx> Anyhow...
19:39:20 <revenantphx> I'd love to try to implement bytestring --> int reading functions in that manner.
19:39:20 <kmc> revenantphx, http://haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html#th-quasiquotation
19:39:22 <kmc> cool paper too
19:39:30 <revenantphx> oic, Template Haskell.
19:39:43 <revenantphx> I'm still scarred by C++ templates sadly :(
19:39:52 <kmc> fortunately Template Haskell is nothing like C++ templates
19:39:55 <revenantphx> whew.
19:39:57 <kmc> TH sucks in its own special unique way
19:39:58 <ddarius> Template Haskell is nothing like C++ templates.
19:39:58 <yac> its kind of type error but i dont see how there could ever be ()
19:40:01 <revenantphx> kmc XD
19:40:10 <revenantphx> Care to elaborate?
19:40:19 <kmc> on why it sucks? not at the moment
19:40:23 <ddarius> Actually, you can do similar things to C++ template metaprogramming in Haskell type class system.
19:40:33 <kmc> but they're quite different
19:40:37 <revenantphx> generics...
19:40:38 <kmc> with TH you write Haskell programs that output Haskell programs
19:40:39 <applicative> Entroacceptor, I see, the cabal happstack is 0.5.0.4; I wonder what you have thats forcing this older mtl on you.  It's too dark for me.
19:40:41 <revenantphx> on one hand, very useful
19:40:47 <revenantphx> on the other... oh god the error messages...
19:40:52 <revenantphx> convulsions in my stomach...
19:40:52 <kmc> with C++ you write Template programs that output C++ programs
19:41:04 <kmc> and Haskell is the same language as Haskell, while Template and C++ are about as different as two languages can be
19:41:11 <kmc> in fact Template is closer to Haskell than it is to C++
19:41:11 <revenantphx> STL and C++?
19:41:15 <kmc> no not STL
19:41:17 <ddarius> revenantphx: C++ templates are not "generics".  They are quite a bit more powerful and unstructured than what "generics" usually means in OOP.
19:41:21 <Entroacceptor> applicative: will nuking .ghc help?
19:41:30 <revenantphx> ddarius: I see.
19:41:47 <kmc> STL is a library written in a combination of the two languages C++ and Template
19:41:54 <Entroacceptor> applicative: or nuking the whole of ghc
19:41:56 <applicative> It cant be that bad, you just need a cabal install guru; it's probably a simple incantation
19:42:25 <Entroacceptor> if you know one, send him my way ;)
19:42:59 <ddarius> STL doesn't do too much crazy stuff.
19:43:43 <kmc> yeah
19:43:55 <ddarius> That said, the C++ template metalanguage is a rather pretty language just with extremely verbose syntax.
19:44:28 <kmc> ddarius, it may be a pretty language in isolation, but its interaction with C++ variable scoping rules, and with the compile/link process, is downright disgusting
19:44:39 <Mathnerd314> has anyone ever actually *used* multirec in one of their programs?
19:45:16 <applicative> Entroacceptor, they're frequently around.  Try the same query again later, or in the morning. 
19:45:20 <revenantphx> Data.ByteString.Internal...
19:45:25 <revenantphx> this is like a box of chocolates to me :3
19:45:49 <kmc> and the syntax isn't just verbose; it's full of traps.  consider "> >", "typename", and "C<S>::template f<T>()"
19:46:14 <revenantphx> mm.
19:46:42 * kmc takes the C++ to #haskell-blah
19:47:19 <revenantphx> @hoogle ForeignPtr a -> a
19:47:19 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
19:47:19 <lambdabot> Prelude id :: a -> a
19:47:19 <lambdabot> Data.Function id :: a -> a
19:50:44 <revenantphx> @hoogle Ptr a -> a
19:50:44 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
19:50:44 <lambdabot> Foreign.Ptr ptrToWordPtr :: Ptr a -> WordPtr
19:50:44 <lambdabot> Prelude id :: a -> a
19:51:45 <Entroacceptor> applicative: ok, thanks
19:54:33 <revenantphx> So er, any way to get a foreignptr to an int?
19:55:37 <ddarius> revenantphx: The path seems pretty clear from what you've already hoogled.
19:56:03 <revenantphx> gah kick me.
19:56:18 <tehgeekmeister> what's the best resource for learning template haskell?
19:56:21 <revenantphx> wait... IntPtr and WordPtr don't seem to be helping...>_>
19:56:47 <ddarius> @instances-import Foreign.Ptr Integral
19:56:48 <lambdabot> Int, IntPtr, Integer, WordPtr
19:56:58 <revenantphx> fromInteger >_>
19:57:03 <ddarius> No!  fromIntegral
19:57:05 <revenantphx> fromIntegral*
19:57:26 <revenantphx> fromIntegral is like that old friend you're not quite happy to see... but you're glad he's around when you need him somehow.
20:01:46 <revenantphx> hm
20:02:08 <revenantphx> toForeignPtr returns (ForeignPtr Word8, Int, Int)... so let's see...
20:02:13 <kmc> tehgeekmeister, read the original Template Haskell paper, then complain about the fact that it's not all implemented
20:02:21 <revenantphx> Do I need to make the Word8 into another Ptr?
20:02:28 <revenantphx> @hoogle Word8 -> Ptr
20:02:29 <lambdabot> Did you mean: Word8 -> Ptr a /count=20
20:02:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:02:29 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
20:02:41 <kmc> revenantphx, no
20:02:50 <kmc> a bytestring is (pointer to byte array, length, offset)
20:02:56 <kmc> (i might have length and offset swapped)
20:03:10 <revenantphx> ack, ForeignPtr is just the Word8
20:03:12 <kmc> you can cast ForeignPtr Word8 to Ptr Word8 and also Ptr A to Ptr B
20:03:13 <revenantphx> my bad.
20:03:21 <kmc> no, (ForeignPtr Word8) is not a Word8
20:03:32 <kmc> it's the address of an array of Word8's
20:03:36 <kmc> do you know C?
20:03:59 <kmc> struct bytestring { unsigned char* buf; int length; int offset; };
20:05:17 <revenantphx> Yes yes, I understand, I mixed up the tuple/data constructor etc
20:05:25 <revenantphx> I just read the doc wrong XD.
20:05:54 <revenantphx> I thought it was giving a pointer to a word8 and some other stuff representing a pointer... and was a tad confused as to why it would do that.
20:05:59 <ddarius> One more reason you shouldn't write documentation.  Even if people read it (which they won't), they'll simply misread it.
20:06:07 <revenantphx> Exactly.
20:09:10 <Xilon> Is what I'm doing here fundamentally wrong in some way? http://hpaste.org/42409/illegal_polymorphic_or_qualifi Basically I want to have a type for a function like (Show a) => MVar a -> IO (), but haskell's not liking the type class
20:09:11 <tehgeekmeister> the problem with learning haskell is every thing seems so daunting.  none of it's really all that hard, but it *seems* hard.  first lazy evaluation, then monads, then monad transformers, then template haskell or any other number of things.  i think it holds a lot of people back (myself included.)
20:09:57 <kmc> Xilon, is a single value of type Widget supposed to work for all 'a'?  or for one, particular, hidden 'a'?
20:10:11 <revenantphx> I wish I knew why this won't compile point free, but will if it's not.
20:10:19 <revenantphx> _short :: ByteString -> Int16
20:10:19 <revenantphx> _short = fromIntegral . ptrToIntPtr . unsafeForeignPtrToPtr . sel1 $ toForeignPtr bs
20:10:28 <revenantphx> (i'm sure this is terribly silly somewhere)
20:10:33 <kmc> what error do you get point-free
20:10:39 <revenantphx> I'm pasting.
20:10:46 <kmc> the description of the behavior sounds like monomorphism restriction, but you have a type signature so that can't be it
20:10:54 <revenantphx> https://gist.github.com/747094
20:11:06 <revenantphx> The latter error is strange.
20:11:08 <ddarius> kmc: It's also monomorphic.
20:11:12 <kmc> yes
20:11:20 <kmc> revenantphx, your last ($) should be a (.)
20:11:22 <Xilon> kmc: I guess the latter. Different functions of type Widget would potentially have different 'a's
20:11:26 <ddarius> revenantphx: That code is insane by the way.  I don't think it does swhat you want.
20:11:32 <revenantphx> Probably not
20:11:36 <revenantphx> Only one way to find out.
20:11:37 <kmc> Xilon, but they can't be "Widget A", "Widget B", etc?
20:11:43 <kmc> why are you trying to hide the type parameter?
20:11:49 <revenantphx> "_short = fromIntegral . ptrToIntPtr . unsafeForeignPtrToPtr . sel1 . toForeignPtr"
20:11:53 <revenantphx> Kind of scary tbh,
20:12:04 <ddarius> tehgeekmeister: Perhaps people shouldn't be daunted so easily.
20:12:08 <revenantphx> ddarius: what's wrong with it?
20:12:45 <tehgeekmeister> ddarius: yeah, i think you're right.  still going to impede adoption of haskell.  just commenting, really.
20:12:49 <Xilon> kmc: Just trying to make it generic. Rather than having a String I want to accept anything from Show, although there's no reason it can't just be a String
20:13:01 <ddarius> revenantphx: You are writing (short)ptr, when, I'm assuming, you want *(short *)ptr
20:13:10 <kmc> Xilon, oh.  that sounds like the first option i gave, not the second
20:13:15 <kmc> "single value of Widget works for all a"
20:13:18 <revenantphx> Hm...
20:13:18 <ddarius> tehgeekmeister: Only by easily daunted people.
20:13:36 <revenantphx> Well, IntPtr claims to be able to be converted straight to Int.
20:13:46 <kmc> the problem with learning Haskell is that it's not Java.  if only Haskell were Java then it would be easy to learn
20:13:47 <revenantphx> How would you write it "correctly"?
20:13:51 <ddarius> revenantphx: IntPtr is for when you want to do crazy pointer arithmetic stuff.
20:14:06 <ddarius> revenantphx: You want to -read- the pointer, not change its format.
20:14:19 <ddarius> See peek in Serializable, but before you do that, read the FFI spec.
20:14:38 <kmc> Xilon, i'm not convinced this is a good design
20:14:43 <revenantphx> I probably should. That code was pulled straight out of my ass and will probably break something :D
20:14:54 <kmc> Xilon, but if you really want to do it:  data Widget = MkWidget (forall a. (Show a) => MkVar a -> IO ())
20:15:04 <kmc> note that we had to introduce a constructor and make it a proper data type, not a type synonym
20:15:04 <tehgeekmeister> ddarius: or people who don't want to spend an uncertain amount of time learning a language only to find out it's not even useful to them.  i mean, i certainly think it's useful.  but it held me back from diving in at first, because i couldn't be sure of how long it'd take to learn the language and whether it'd be useful at all.  ruby or python on the other hand, i was pretty sure i'd be able to start doing useful things quickly.
20:15:09 <ddarius> revenantphx: All it will do is return the lower word of the pointer which is very likely not what you want.
20:15:11 <kmc> you also need to turn on a GHC extension like RankNTypes
20:15:15 <revenantphx> Yeah, I see that now.
20:15:31 <revenantphx> I was misunderstanding what IntPtr was.
20:15:47 * revenantphx needs a dereferencing function... too seek!
20:15:48 <kmc> Xilon, wouldn't it be far easier to use "type Widget = MVar String -> IO ()" and have a function "send :: (Show a) => a -> Widget -> IO ()" which applies "show" itself?
20:15:54 <revenantphx> Should I look at the source?
20:16:26 <ddarius> tehgeekmeister: Those people don't want to learn any language which isn't obviously "useful" to them, or they are easily daunted.
20:16:31 <Xilon> kmc: Yeah, they will probably all return strings anyway. Just playing around :P
20:16:32 <revenantphx> where is serializable...
20:16:48 <ddarius> revenantphx: You should read the FFI spec like I already told you to.
20:16:54 <revenantphx> I am, I am.
20:16:58 <revenantphx> I just want to find Serializable. 
20:17:41 <revenantphx> Where is the spec anyhow.
20:18:34 <revenantphx> I found this http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:19:03 <ddarius> @where ffi
20:19:03 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:19:16 <ddarius> That's the spec.  It says so on the box.
20:19:20 <revenantphx> @where Serializable
20:19:20 <lambdabot> I know nothing about serializable.
20:19:26 <revenantphx> foiled again.
20:19:39 <Xilon> tehgeekmeister: Any turing complete language can do useful things with enough effort, although it depends on your definition of "useful" :P
20:19:48 <revenantphx> turing tarpits!
20:20:07 <revenantphx> oh you meant Storable?
20:20:14 <ddarius> Xilon: Ah, but the new in thing is to try to convince people to use languages that aren't Turing complete.
20:20:24 <applicative> Entroacceptor, it occurs to me, the obvious next step is to reinstall the darcs happstack server using the constraint=mtl mtl-2.0.1.0 or something like that. 
20:20:38 <ddarius> revenantphx: Maybe.  Perhaps it was a devious plan to get you to read the spec.  Or perhaps I just misspoke.
20:20:45 <revenantphx> ingenious.
20:20:53 <revenantphx> oh great.
20:20:56 <revenantphx> peek is in the IO monad...
20:21:02 <ddarius> "Borrow money from a pessimist -- they don't expect it back."
20:21:05 <revenantphx> that means i can add another unsafe* function right :D?
20:21:06 <ddarius> revenantphx: As well it should be.
20:21:23 <ddarius> revenantphx: If it's safe for your case, which I think it is safe enough for bytestring.
20:21:36 <revenantphx> so something like
20:21:37 <revenantphx> _short = fromIntegral . unsafePerformIO . peek . unsafeForeignPtrToPtr . sel1 . toForeignPtr
20:21:39 <revenantphx> (just guessing)
20:21:47 <ddarius> No.
20:22:18 <ddarius> You don't need unsafeForeignPtrToPtr and you need to do the equivalent of the (short *) cast still.
20:23:01 <revenantphx> peek takes a Ptr... not a ForeignPtr though :\?
20:23:11 <revenantphx> wait...
20:23:19 <revenantphx> no I'm not seeing it
20:23:21 <kmc> :t withForeignPtr
20:23:22 <lambdabot> Not in scope: `withForeignPtr'
20:23:27 <kmc> :t Foreign.Ptr.withForeignPtr
20:23:28 <lambdabot> Not in scope: `Foreign.Ptr.withForeignPtr'
20:23:30 <kmc> grr
20:23:36 <ddarius> @hoogle withForeignPtr
20:23:36 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
20:23:42 <ddarius> Hoogle is a better @index and @type.
20:23:54 <revenantphx> Oh I see.
20:24:08 <ddarius> :t withForeignPtr (peek . castPtr)
20:24:09 <lambdabot> Not in scope: `withForeignPtr'
20:24:09 <lambdabot> Not in scope: `peek'
20:24:09 <lambdabot> Not in scope: `castPtr'
20:24:17 <revenantphx> Yes, I got the idea :P
20:24:38 <ddarius> :t Foreign.ForeignPtr.withForeignPtr (Foreign.Storable.peek . Foreign.Ptr.castPtr)
20:24:39 <lambdabot>     Couldn't match expected type `GHC.ForeignPtr.ForeignPtr
20:24:39 <lambdabot>                                     (GHC.Ptr.Ptr a)'
20:24:39 <lambdabot>            against inferred type `GHC.Ptr.Ptr a1 -> GHC.Ptr.Ptr b'
20:25:04 <megajosh2> For some reason, when I compile this program I made in Haskell, it eventually gets to a point where it quits with a message like this
20:25:10 <megajosh2> test: <<loop>>
20:25:18 <ddarius> :t \fp -> Foreign.ForeignPtr.withForeignPtr fp (Foreign.Storable.peek . Foreign.Ptr.castPtr)
20:25:19 <lambdabot> forall a b. (Foreign.Storable.Storable b) => GHC.ForeignPtr.ForeignPtr a -> IO b
20:25:23 <megajosh2> "test" being the name of the executable I ran
20:25:23 <kmc> that means you're trying to enter an infinite loop
20:25:30 <megajosh2> Alright, thanks
20:25:35 <ddarius> Of an particular type.
20:25:40 <kmc> GHC uses Roswell UFO alien technology that can solve the Halting Problem
20:25:46 <ddarius> megajosh2: Turn on the warning that warns about shadowed variable names.
20:26:09 <revenantphx> so...
20:26:10 <revenantphx> _short bs = fromIntegral $ unsafePerformIO . withForeignPtr (sel1 . toForeignPtr bs) (peek . castPtr)
20:26:14 <kmc> (not really, it will only print <<loop>> in a restricted set of cases)
20:26:33 <ddarius> revenantphx: You don't need the fromIntegral, the castPtr is already casting to whatever type you want.
20:27:03 <ddarius> Don't listen to kmc.  He doesn't know what technology is and isn't Roswell UFO alien technology.
20:27:11 <revenantphx> ah, Ptr Int16 in this case
20:27:20 <kmc> ddarius, because i don't have top secret government clearance
20:27:32 <ddarius> kmc: Among other reasons.
20:28:28 <revenantphx> weird
20:28:29 <revenantphx> _short bs = unsafePerformIO $ withForeignPtr (sel1 $ toForeignPtr bs) (peek . castPtr)
20:28:49 <revenantphx> removing the fromIntegral makes the (.) in the first parentheses fail.
20:28:51 <ddarius> Incidentally, you -really- want a type signature on that if don't still have one.
20:28:56 <revenantphx> I do XD
20:29:00 <revenantphx> _short :: ByteString -> Int16
20:29:06 <kmc> ByteString -> ()
20:29:09 <kmc> would be the best type
20:29:12 <kmc> ;)
20:29:19 <ddarius> Is () in Storable?
20:29:23 <revenantphx> :|
20:29:26 <ddarius> @instances Storable
20:29:26 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
20:29:37 <ddarius> @instances-importing Foreign.Storable Storable
20:29:37 <lambdabot> Bool, Char, Double, Float, Int
20:29:45 <kmc> ddarius, i hope so, with a size of 0.  but actually C++ mandates that empty classes have size at least 1 byte
20:29:48 <kmc> so maybe we do the same
20:31:09 <tehgeekmeister> wow, template haskell is remarkably simple, it seems.
20:31:37 <ddarius> tehgeekmeister: It's pretty straightforward conceptually.
20:31:46 <revenantphx> Prelude ...> let test = pack [0x00, 0x04]
20:31:47 <revenantphx> Prelude ...> _short test
20:31:47 <revenantphx> 1024
20:32:04 <revenantphx> goddamn endianness >_>
20:32:35 <ddarius> Little endian is the One True Endianess.  Curse all the heretics.
20:32:37 <kmc> it's nice that Haskell is the Haskell metalanguage
20:32:46 <kmc> since Haskell is a good language for AST manipulation
20:33:02 <kmc> however TH has some traps and annoying limitations
20:33:08 <kmc> and generally i find it takes forever to write TH code
20:33:14 <revenantphx> so uh kmc, what should I blame here?
20:33:18 <revenantphx> is it pack or is it my _short?
20:33:20 <tehgeekmeister> i don't need to do much with it (for now).  do not like the approach of current persistence libraries, want something more like activerecord.
20:33:20 <kmc> for what?
20:33:29 <revenantphx> For the number being *backwards*
20:33:34 <ddarius> revenantphx: I'd blame the programmer.
20:34:00 <kmc> revenantphx, it looks like you're using a little-endian machine
20:34:11 <kmc> therefore, peek reads a little-endian Word16
20:34:17 <kmc> didn't we go over this?
20:34:22 <revenantphx> Ok, so it's peek.
20:34:32 <kmc> no, like ddarius said, it's you
20:34:42 <revenantphx> Yes, I'm just wondering which function is doing the flipping.
20:34:47 <revenantphx> I know it's me.
20:34:47 <kmc> nothing is flipping anything
20:35:06 <kmc> it's probably using your platform's native "movw" or whatever instruction
20:35:10 <kmc> with no flip anywhere
20:35:30 <kmc> in the old country, we have this saying
20:35:33 <kmc> "garbage in, garbage out"
20:36:18 <revenantphx> heh.
20:36:30 <kmc> @quote CharlesBabbage
20:36:30 <lambdabot> CharlesBabbage says: On two occasions I have been asked, 'Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?' I am not able rightly to apprehend the kind
20:36:30 <lambdabot> of confusion of ideas that could provoke such a question.
20:36:41 <revenantphx> :)
20:37:17 <revenantphx> "test" is {0x00, 0x04} (apparently)...
20:37:48 <kmc> yeah, "test" is a ByteString whose contents are 0x00, 0x04
20:38:06 <revenantphx> shit, seriously?
20:38:12 <revenantphx> That'd be the cause of it all then.
20:38:13 <kmc> "let test = pack [0x00, 0x04]"
20:38:23 <revenantphx> That's definitely not exactly what I did.
20:38:31 <kmc> it's exactly what you said above
20:38:36 <revenantphx> No it's not, you're lying.
20:38:56 <kmc> ok i'm confused now
20:39:03 <revenantphx> Sorry >_<
20:39:43 <revenantphx> I need this to read big endian...
20:40:02 <revenantphx> It's reading it in little endian apparently! what a shock!
20:40:42 <ddarius> If only Babbage could have forseen the trend in those questions.  He would have destroyed his differential engine and burnt the plans for his analytical engine.
20:40:55 <Jafet> gegs: scrambled eggs.
20:41:17 <revenantphx> >_>
20:41:30 <kmc> unfortunately computing devices are an inevitable outcome of evolution
20:41:46 <kmc> so the only true solution is to destroy all energy in the universe
20:41:52 <ddarius> Luckily, extinction is an inevitable outcome to life.
20:41:56 <Xilon> i.e. the sun?
20:42:05 <revenantphx> ddarius: I'd think that remains to be proven?
20:42:15 <Jafet> kmc: but the most efficient way to do that is to build computers!
20:42:29 <revenantphx> Xilon: you're thinking too small.
20:42:42 <Xilon> Yes, the sun is tiny :P
20:42:43 <Jafet> Well, borg computers
20:43:12 <revenantphx> ugh, endianness conversion. Why isn't there a package for this
20:43:19 <ddarius> @hoogle htons
20:43:20 <lambdabot> No results found
20:43:20 <Xilon> revenantphx: reverse! :P
20:43:24 <kmc> perhaps the "binary" package?
20:43:44 <revenantphx> kmc: Don't be silly.
20:43:46 <revenantphx> that's absurd.
20:44:07 <ddarius> Binary already will read words from a bytestring in whichever endianness you want (as long as its little or big, none of that middle endianness nonsense.)
20:44:30 <ddarius> Stupid network protocols are the only reason big endian is even tolerated.
20:44:35 <kmc> i store my 2-byte words by XORing the LE and BE representations
20:44:35 <Eduard_Munteanu> I think binary only deals in big-endian.
20:44:51 <revenantphx> kmc: It's more secure against hackers that way!
20:45:01 <kmc> getWord16be :: Get Word16, getWord16le :: Get Word16
20:45:04 <ddarius> I store all my numbers by xoring them against themselves.
20:45:18 <kmc> revenantphx, actually, do you know about XOR linked lists?
20:45:19 <revenantphx> I'm aware using Binary is an easy solution, but it seemed more fun to *not* do it XD.
20:45:29 <revenantphx> No, but I've heard the term a few times.
20:45:46 <Eduard_Munteanu> kmc: what good is xor-ing LE & BE ?
20:45:52 <kmc> Eduard_Munteanu, none as far as i know
20:45:58 <Eduard_Munteanu> :)
20:46:00 <revenantphx> What is it kmc?
20:46:05 <revenantphx> nmd, google is my friend.
20:46:14 <revenantphx> oh wow. That's neat :D.
20:46:40 <kmc> it reminds me slightly of this other trick
20:46:50 <kmc> for making binary trees with traversal in O(1) space
20:46:51 <Saizan> kmc: why are computing devices an inevitable outcome of evolution?
20:47:14 <kmc> where the right-child pointer of a leaf is a pointer to the next node in the in-order traversal
20:47:16 <kmc> appropriately tagged
20:47:42 <revenantphx> cool
20:47:53 <revenantphx> so now I'll put a stop to this foray and just use binary XD
20:48:01 <revenantphx> (inside attoparsec :O)
20:48:14 <Jafet> Unfortunately, that isn't functional
20:48:31 <revenantphx> Should I use Binary or Cereal? (pros cons?)
20:48:41 <kmc> revenantphx, lazy vs. strict bytestring, and how they report errors
20:48:51 <kmc> "binary" comes in the Platform and supports lazy IO through lazy bs
20:48:57 <kmc> which is kind of dubious, but at least convenient
20:49:02 <revenantphx> lazy bull shit?
20:49:06 <kmc> Jafet, by which you mean you can't update them with sharing?
20:49:10 <revenantphx> Well, I'm dealing with stricts here I guess.
20:49:31 <revenantphx> The point was to write this with attoparsec... :\
20:49:43 <revenantphx> but Binary with lazy io was convenient and all.
20:49:51 <Jafet> kmc: yeah. Not in an obvious way, that is
20:50:23 <kmc> yeah.  any scheme whereby the whole tree is reachable from node X is going to require you to copy node X on insert
20:50:33 <kmc> that's why you always copy the root
20:51:19 <ddarius> @google recycling continuations
20:51:19 <lambdabot> No Result Found.
20:51:26 <ddarius> Freakin' @google.
20:51:36 <Jafet> Oh no, here comes the non-obvious
20:53:03 <lars9> does anyone know why http://www.haskell.org/gtk2hs/ is not accessable? what is gtk2hs' homepage now?
20:58:55 <Zao> lars9: DNS snafu.
20:59:06 <Zao> It's resolved, but some DNS caches are slow to catch up.
20:59:15 <Zao> Try another DNS server, like say 8.8.8.8
20:59:30 <revenantphx> I wonder how much google payed for 8.8.8.8
20:59:36 <Zao> Or use the hosts listed in a recent cvs-ghc mail for in your hosts file.
21:00:00 <Zao> http://www.haskell.org/pipermail/cvs-ghc/2010-December/058379.html
21:00:05 <Zao> Erm... silly link :D
21:01:12 <tehgeekmeister> @hoogle lift
21:01:12 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
21:01:12 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
21:01:12 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
21:01:48 <Zao> http://paste-it.net/public/m4870a5/
21:02:55 <Saizan> it's not a DNS problem in this case
21:03:14 <Saizan> it's 404
21:03:34 <Saizan> they probably forgot to move it when they changed server
21:04:04 <Zao> Ah.
21:04:17 <Zao> I'd hug a Manatee.
21:04:24 <Zao> He has a tendency to know things about gtk :)
21:04:24 <Saizan> not sure who should be notified..
21:04:32 <kmc> oh the huge manatee
21:10:25 <revenantphx> I'm going to need to think about how to parse with attoparsec a bit
21:10:43 <revenantphx> Since I want to produce output as I'm going, not at the end. I guess Partial/Done and such would help me a bit.
21:10:54 <revenantphx> Actually, those remind me of the very little I saw on iteratees.
21:10:57 <revenantphx> I need to read up on those.
21:13:12 <kmc> revenantphx, yes, i believe attoparsec parsers are very nearly iteratees
21:13:14 <revenantphx> probably parse/feed in a loop.
21:13:22 <kmc> see also 'attoparsec-iteratee' and 'attoparsec-enumerator' packages
21:13:23 <revenantphx> I found an attoparsec-->iteratee library
21:13:25 <revenantphx> yeah.. XD
21:13:45 <revenantphx> parseWith looks to be about what I want
21:13:49 <revenantphx> "Run a parser with an initial input string, and a monadic action that can supply more input if needed."
21:13:53 <kmc> we just need glue code to connect our various enterprise incremental IO frameworks together
21:14:01 <kmc> can you feel the javafication already
21:14:26 <revenantphx> In this case, if I need more stuff, read more data, and append it to the end of the leftovers from before?
21:14:53 <revenantphx> Would appending even be an issue here...?
21:14:58 <revenantphx> given the immutability and all.
21:15:07 <revenantphx> Or can I just do it and forget about it.
21:17:00 <revenantphx> I think I'll write a different parser type thing for practice. Something not network based.
21:17:05 <Saizan> appending is generally something you've to be careful about.
21:17:16 <revenantphx> Saizan: hm.
21:17:52 <ddarius> kmc: Only when we have third parties selling tools/libraries whose only purpose is to connect other (usually also third-party tools/libraries) will we have arrived.
21:18:00 <Saizan> it's generally quadratic if nested on the "left"
21:18:31 <ddarius> If you are producing data with an enumerator you will already being dealing with sporadic chunkiness.
21:18:41 <ddarius> And that should be mostly transparent to the consumers.
21:24:12 <kmc> help doctor, my digestive applicatives have sproadic chunkiness
21:26:59 <ddarius> Mathematicians have a -lot- of words for (categorical) arrows.
21:41:13 <mtnviewmark> Woot! My Haskell Platform installer for Mac OS X works on both 10.6 and 10.5!
21:41:27 <mtnviewmark> just a few nits to work on.... 
21:41:47 <mtnviewmark> it will be ready in time for the next release -- a single click installer
21:45:49 <revenantphx> hurrah mtn
22:01:30 <Xilon> Trying to figure out this error message: http://hpaste.org/42415/monadio Is it saying that (MonadIO MPD) isn't an instance of MonadIO, or that just MPD isn't (which it is)?
22:02:14 <Saizan_> Xilon: it's saying that MPD is not an instance of MonadIO
22:02:50 <Xilon> Wonder why GHC thinks that...
22:02:52 <Saizan_> (maybe you're mixing transformers and mtl<2?)
22:03:04 <kmc> it would not make sense to say that (MonadIO MPD) is an instance of MonadIO
22:03:36 <kmc> or that it isn't
22:03:40 <Xilon> kmc: Yeah, just thought maybe it was inferring that from my code for some reason
22:05:08 <kmc> yeah, libmpd makes MPD an instance of mtl-1:Control.Monad.Trans.MonadIO
22:05:42 <kmc> and you're importing Control.Monad.IO.Class from transformers
22:05:58 <Xilon> Hmm got mtl 1.1 exposed in the system package.conf.d
22:06:01 <kmc> which defines a separate class named MonadIO
22:06:20 <kmc> import Control.Monad.Trans instead of Control.Monad.IO.Class
22:06:26 <kmc> if you want to use mtl
22:06:41 <kmc> if you don't want to use mtl generally, you can write a dumb instance to adapt the two
22:07:09 <mwc> is there a list of errata for TMR issues anywhere?
22:07:47 <Xilon> I'll try that. It looks like ghc is using mtl 2.0.1.0, and not transformers
22:08:39 <Xilon> Importing Control.Monad.Trans didn't help
22:08:50 <kmc> you can explicitly use mtl-1
22:08:57 <kmc> the cleanest way is to use Cabal for building
22:09:04 <kmc> and depend on mtl >= 1.0 && < 2
22:09:42 <kmc> the best solution is for the lib you're using to upgrade to mtl-2
22:09:44 <Xilon> Oh, I want < 2?
22:09:50 <kmc> or better to transformers
22:10:25 <kmc> looks like the lib is actually maintianed
22:10:29 <kmc> i.e. has had more than one version
22:10:35 <kmc> last upload a few months ago
22:10:58 <Xilon> Yep, hid mtl-2.0.1.0 and it works
22:13:02 <zodiac> hello everyone
22:13:59 <kmc> Xilon, mtl-2 re-exports the transformers from 'transformers' under the old module structure
22:14:07 <kmc> hi Guest27029
22:14:22 <Guest27029> hi kmc
22:14:44 <Guest27029> just started learning haskell...looks interesting
22:15:11 <kmc> it is :)
22:18:45 <Xilon> kmc: So why doesn't it work with mtl >= 2 if it re-exports the class anyway?
22:19:14 <Xilon> Or is it to do with what libmpd uses?
22:20:01 <kmc> right, it's because libmpd defines an instance of mtl-1:MonadIO and not of transformers:MonadIO
22:20:16 <kmc> , which is the same as mtl-2:MonadIO
22:21:38 <kmc> that's why the nicest solution is to change libmpd
22:21:59 <kmc> especially because Haskell Platform will have mtl-2 soon
22:22:07 <kmc> (or does it already?)
22:23:50 <Xilon> Nope, 1.1.0.2 is in the platform currently
22:28:35 <gienah> http://code.haskell.org/haskell-platform/haskell-platform.cabal says its mtl == 2.0.1.0
22:29:26 <Xilon> Yeah for the next release.
22:29:41 <gienah> which seems confusing trying to build packages for ghc 6.12.3 and ghc 7.0.1 with ebuilds on gentoo, I do not really know how to handle the mtl 1 and mtl 2
22:52:02 <CindyLinz> how to parse the right hand side of the '=' sign in this statement? sequence (c:cs) = return (:) `ap` c `ap` sequence cs
22:52:35 <Saizan_> (return (:) `ap` c) `ap` sequence cs
22:52:57 <Saizan_> = ap (ap (return (:)) c) (sequence cs)
22:53:30 <CindyLinz> Saizan_: thx ^^
22:53:41 <Saizan_> which is the same as liftM2 (:) c (sequence cs)
22:53:53 <Saizan_> np
22:54:09 <CindyLinz> um um.. I've read it from here http://www.soi.city.ac.uk/~ross/papers/Applicative.html
22:54:25 <CindyLinz> I mean the 'ap' one
22:55:14 <kmc> `f` is the function "f" used infix
22:55:29 <kmc> as an infix operator, it binds less tightly than function application
22:55:40 <kmc> > let plus = (+) in 2 `plus` succ 3
22:55:41 <lambdabot>   6
22:55:50 <kmc> 2 `plus` (succ 3)
22:56:13 <CindyLinz> ok~~ ^^  thank you
22:56:40 <kmc> no problem :)
22:58:30 <lars9> @hoogle join
22:58:30 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
22:58:30 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
22:58:31 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
23:19:26 <Zeiris_> I wanna start a blog. How can I do so with 1. Haskell syntax highlighting (and others) 2. ability to embed TeX math?
23:19:45 <Zeiris_> (It seems that blogs about Haskell are a popular thing, so I figured this is on topic.)
