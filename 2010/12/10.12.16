00:09:35 <sina> I can break Enigma now :)
00:11:44 <ivanm> does anyone know if ghc-7 has proper superclass constraint support yet?
00:15:33 <zztr> why is regex looked down upon?
00:15:39 <c_wraith> Uh, you mean superclass equality constraints?
00:16:04 <c_wraith> I think those are in GHC 7, but I really know nothing about it.  Just repeating what I've read
00:17:17 <ivanm> c_wraith: yeah, them
00:17:32 <ivanm> zztr: see the quote by jwz
00:17:58 <c_wraith> zztr: a couple reasons.  first, library support for them is kind of bad.  second, things like parsec are so easy to use, and more flexible, why bother?
00:18:46 <ivanm> c_wraith: I know TacticalGrace was talking about them being possible with the new typechecker, but I'm not sure if it ever got implemented or not :/
00:19:19 <Cale> lol, whaaat -- I was just intending to type "ghci" into my terminal, and instead I typed "Thai"
00:19:31 <zztr> maybe jwz said something before I joined. but it sounds like the reasons are pragmatic rather than ideological. nothing wrong with that...
00:19:51 <ivanm> zztr: jwz isn't a haskeller ;-)
00:19:58 <c_wraith> Cale: hungry?
00:20:05 <Cale> c_wraith: heh, maybe
00:20:56 <ivanm> zztr: the quote is: Some people, when confronted with a problem, think "I know, I'll use regular expressions."  Now they have two problems
00:21:22 <ivanm> Cale: some kind of weird auto-correcting shell?
00:22:08 <Cale> ivanm: Yeah, my hands :P
00:22:12 <ivanm> heh
00:22:36 <romildo> I have two versions of the gtk package installed on my gentoo linux system. One using the package manager of the linux distribution, and other directly by me using cabal. How do I choose one over the other when compiling my application?
00:23:03 <ivanm> romildo: the one installed as a user gets defaulted to if both versions match
00:23:24 <ivanm> why are you using cabal-install _and_ ebuilds though?
00:24:47 <ivanm> c_wraith: *sigh* the release notes don't mention it, so it probably hasn't been implemented yet :(
00:26:30 <romildo> ivanm, primarily I use the ebuild, but my application is not working, and I cannot know why. So I want to see what is happening with some function calls from the gtk package. Therefore I installed "my own" version of the package so that is leading to the runtime error messages from gtk.
00:26:42 <ivanm> ahhhhh
00:26:56 <ivanm> then yeah, the user-installed one is used when building stuff as that user
00:28:14 <romildo> ivanm, and what about if I want to use the system one, without  not installing it?
00:28:37 <romildo> I mean, without uninstalling it.
00:28:54 <ivanm> dunno...
00:29:05 <ivanm> maybe hide the user-installed one?
00:29:22 <ivanm> or build it with --global? :/
00:34:10 <dark> I need to do collision detection, and thus I need to project a point on a line. I am looking into some linear algebra things, like http://en.wikipedia.org/wiki/Projection_(linear_algebra)#Oblique_projection etc but I am having a hard time figuring it out. my line is currently represented by an angle and it passes on the origin. should I represent it by giving two points of it instead? (I confess it is off-topic, although I'm back and forth between o
00:34:10 <dark> caml and haskell for implementing it)
00:36:02 <dark> I can find the solution wrote out as a linear system of equations but it is a bit too ugly / large
00:39:48 <dark> it seems that i should take a look at homogeneous coordinates
00:44:15 <dark> actually found out that what I want is an "orthogonal projection", not oblique, and that calculating the angle serves for no purpose
00:48:53 <nmkolev> does anyone have lambdabot running on snow leopard?
00:48:57 <ivanm> hmmm.... how long has the DatatypeContexts extension been available?
00:49:15 <ivanm> nmkolev: lambdabot is difficult to build at the best of times, so don't feel suprised if you can't build her
00:49:28 <nmkolev> fails for me with: /Users/nmk/.cabal/lib/readline-1.0.1.0/ghc-6.12.3/HSreadline-1.0.1.0.o: unknown symbol `_rl_basic_quote_characters'
00:49:38 <nmkolev> readline is installed fine
00:49:49 <ivanm> OK, looks like DatatypeContexts is new in ghc-7
00:50:08 <ivanm> nmkolev: yeah, I don't think lambdabot is buildable with 6.12
00:51:08 <nmkolev> seems line readline is not fine after all: do { readline "Prompt" } in ghci gives /Users/nmk/.cabal/lib/readline-1.0.1.0/ghc-6.12.3/HSreadline-1.0.1.0.o: unknown symbol `_rl_basic_quote_characters'
00:51:46 <ivanm> yes; could be the wrong version of the C library
00:51:58 <ivanm> note also that GHC stopped using readline as of 6.10.2 IIRC
00:52:54 <nmkolev> i have readline 6.1 installed, the cabal package builds without problems
00:53:13 <nmkolev> I do not need readline per se; just as a lambdabot  dependency
00:54:26 <ivanm> but lambdabot doesn't build atm, so don't worry about it! ;-)
00:55:04 <gienah> I built lambdabot on ghc 6.12.3 on gentoo, no problems with readline, I had to patch lambdabot and show
00:55:55 <ivanm> oh, so you've worked out how to patch lambdabot?
00:56:14 <ivanm> IIRC, the C readline library on OSX is different than the one on Linux, which could be causing problems
00:56:45 <nmkolev> i built the one from gnu.org (using homebrew actually)
00:57:11 <ivanm> are you sure cabal-install used that one rather than the default one?
00:57:30 <ivanm> nmkolev: but what are you wanting a local copy of lambdabot for anyway?
00:58:02 <nmkolev> yep, passed in all the necessary options to cabal
00:58:28 <gienah> I built ghci on acid as well, which is neat as you can run lambdabot in ghci, again with ghci 6.12.3
00:58:49 <gienah> I'd love to contribute the ebuilds to gentoo
00:59:34 <nmkolev> goa depends on lambdabot though :-)
00:59:48 <sina> Is regex possible in Haskell?
01:00:27 <silver> yes
01:00:38 <sina> how?
01:00:43 <c_wraith> haskell is finite-state-machine complete
01:01:09 <c_wraith> You know, I think that'll be my new preferred answer to that question.
01:01:28 <silver> Text.Regex.Posix for example
01:02:04 <silver> sina, you can try and read http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html just be careful -- there are some mistakes and somewhat outdated info
01:02:42 <silver> but you should get the general idea
01:03:50 <sina> thanks
01:04:23 <sina> I'm just wondering, is there anyway someone can tell me what are monads? I just have no idea and every tutorial starts with so much details.
01:05:00 <c_wraith> monads are just an interface.  Don't worry about them.  They really aren't that big of a deal.
01:06:38 <ian_mi> pay no attention to that man behind the curtain!
01:06:43 <sina> I heard people are calling them amazing and fantastic and powerful, ... And I have no single clue what they are
01:08:03 <silver> sina, for example I don't really know, despite that I can write simple haskell programs :-)
01:08:49 <sina> silver, I can write simple haskell programs. in fact I wrote an enigma decoder
01:09:19 <sina> but this monads thing is just everybody is talking about it, and saying its hard, but powerful.
01:09:27 <earthy> as c_wraith stated monads are an interface. however, the interface crops up many many times
01:10:00 <ian_mi> regardless who would want to restrict themselves to knowledge which is practical
01:10:03 <sina> what kind of interface?
01:10:11 <silver> sina, do you know that Maybe is a monad?
01:10:17 <Boxo> sina: I recommend sigfpe's monad tutorials. Especially "monad are trees with grafting"
01:10:19 <earthy> basically the monad interface allows you to combine functions that return results 'with benefits'
01:10:25 <Boxo> *monads
01:10:44 <earthy> a monadic value can be thought of as a value 'with benefits'
01:11:02 <sina> what kind of benefits?
01:11:05 <ian_mi> silver: isn't Maybe an algebraic type?
01:11:27 <Philippa> ian_mi: those aren't mutually exclusive things
01:11:30 <earthy> these benefits may be an IO action, or alternatives to the value, or the possibility that the value is not present, or...
01:12:02 <Boxo> earthy, you know you're not describing only monads. lots of things are values with benefits, like functors
01:12:44 <earthy> but the thing is, to the monad interface what the benefits are does not matter
01:12:58 <sina> is there any simple example someone can give?
01:13:07 <earthy> boxo: true. however, with functors, you can only combine functions on the benefits
01:13:14 <earthy> err... on the values that is
01:13:20 <Boxo> @google monads are trees with grafting
01:13:21 <lambdabot> http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html
01:13:21 <lambdabot> Title: A Neighborhood of Infinity: Monads are Trees with Grafting
01:13:38 <earthy> whereas with monads you can also combine functions that operate on the benefits
01:14:06 <sina> 12 pages?
01:14:27 <Boxo> sure
01:14:39 <sina> I'll take a look when I get some time
01:15:36 <earthy> > let index = Data.Map.singleton 1 'a' in do value <- Data.Map.lookup 2; return value
01:15:37 <lambdabot>   Not in scope: `Data.Map.singleton'Not in scope: `Data.Map.lookup'
01:15:41 <earthy> !sigh
01:16:15 <triyo> I have something like this: execWriterT (countEntries "..") that returns IO [(FilePath, Int)] .. How do I map over each item in the list in the IO world to apply something like putStrLn on each element?
01:16:31 <lars9> anyone can help write the code for instance Monad ((->) e) where ? thanks
01:16:36 <sipa> :t mapM
01:16:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:16:39 <triyo> do I have to lift it or something>
01:16:51 <shachaf> lars9: Figure it out from the types.
01:16:55 <triyo> oh mapM
01:17:02 <triyo> prob mapM_ right?
01:17:05 <earthy> sina: look in the docs for Data.Map.lookup. it has a nice example
01:17:06 <sipa> yes
01:17:24 <shachaf> lars9: m x = (r -> x), so (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)
01:17:25 <sipa> mapM wouldn't hurt, but you don't need the return type
01:17:35 <shachaf> lars9: And return :: a -> (r -> a)
01:18:15 <sina> earthy, will take a look
01:18:41 <earthy> (usage example that is)
01:18:51 <Boxo> or just (>>=) :: ra-arb-rb , return :: ara
01:19:28 <shachaf> Boxo: That notation doesn't work that well when you have nesting.
01:20:31 <Boxo> it does, shachaf, give me any type!
01:20:39 <Boxo> it doesn't work that well with constructors, though
01:21:18 <shachaf> Boxo: Oh, do you use multiple dashes?
01:22:24 <Boxo> :t flip flip flip
01:22:25 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b
01:23:09 <shachaf> @ty flip -- Oh, Cale...
01:23:09 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:23:23 <shachaf> I hadn't seen that one before.
01:23:44 <Boxo> flip flip flip :: a(zbc-bzy)c-ac
01:23:55 <Boxo> but flip with functors? eh, dunno
01:24:04 <shachaf> Boxo: You're using *parentheses*? Come on.
01:24:10 <Boxo> of couse
01:24:52 <shachaf> That's just weird, then. Why not use them at every level for consistency?
01:24:58 <Boxo> join for the continuation monad :: (((ar)r)r)r-(ar)r
01:25:22 <earthy> you know, that's unreadable.
01:25:26 <ivanm> gienah: we did have lambdabot as an ebuidl at one stage, then got rid of her because building her was too hard/finicky
01:25:42 <ivanm> (gah, scrollback caught me)
01:25:43 <Boxo> fine, suffer your overly verbose notation
01:25:58 <lars9> shachaf: return x = \_ -> x ?
01:26:10 <shachaf> lars9: Don't ask me, ask lambdabot.
01:26:34 <lars9> shachaf: how to get src for that? i dunno the command
01:26:43 <shachaf> lars9: Not src. Just try to type-check it.
01:27:27 <shachaf> Boxo: It seems reasonable in the sense that using juxtaposition to mean "->" can be argued for.
01:27:38 <Boxo> It can
01:27:45 <shachaf> Boxo: Then you'd need a special syntax for type function application, though.
01:27:50 <Jafet> @djinn (r -> a) -> (a -> (r -> b)) -> (r -> b)
01:27:50 <lambdabot> f a b c = b (a c) c
01:28:05 <quicksilver> and you're restricted to single letter type names.
01:28:06 <Jafet> @pl \a b c -> b (a c) c
01:28:06 <lambdabot> flip flip id . (ap .) . flip (.)
01:28:07 <shachaf> Jafet: I believe this was supposed to be an exercise.
01:28:19 <ivanm> what does the DatatypeContexts extension in ghc-7 give you?  Just having the contexts in datatypes actually be passed through to type-sigs as required?
01:28:20 <shachaf> quicksilver: Well, the notation would be similar if you allowed spaces.
01:28:44 <quicksilver> shachaf: sure, but a lot of the conciseness would go once you put spaces and consistent () back in :)
01:28:45 <Boxo> single letter names makes everything nice and concise. I even wrote a little lambda calculus interpreter that eschews spaces
01:28:57 <Axman6> @pl \a b c d e f ->  f e d c b a
01:28:58 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
01:29:08 <shachaf> quicksilver: You could use unlambda-style prefix ` instead of (). :-)
01:29:09 <Jafet> shachaf: well, you half-solved it already by giving the type!
01:29:20 <Jafet> That's not unlambda, but jot.
01:30:04 <shachaf> Jafet: No, that's unlambda.
01:30:45 <shachaf> Jafet: True, but it seemed helpful enough as an "exercise in figuring things out".
01:30:56 <Boxo> Or, alternatively, have capital letters be single-character names, and lowercase be multi-character names
01:31:10 <shachaf> Jafet: lars9 can always implement it for Cont when he/she/it wants a similar challenge. :-)
01:31:19 <Boxo> you could write \ABCDEF.FEDCBA !
01:31:32 <Jafet> Oh okay, it's both unlambda and jot.
01:32:11 <shachaf> Jafet: No, I don't think it's Jot.
01:32:32 <shachaf> Jafet: Jot is made of 1s and 0s.
01:33:58 <Cale> shachaf: hehe, yeah, iirc, ski noticed that definition of flip
01:35:08 <Jafet> Right; it's iota that has apply, not jot
01:36:32 <Jafet> Since we're now debating with reference to languages like unlambda and iota, I think Boxo's proposal is doomed
01:38:27 * shachaf thinks all these two-symbol languages are uselessly inefficient in their symbol use.
01:38:31 <shachaf> You only need one.
01:39:11 <shachaf> Jafet: You brought the esoteric language up, anyway. :-)
01:39:15 <shachaf> Oh, wait. I did.
01:44:17 <ivanm> Cale: I'm trying once again to write a graph class; do you think it suffices to force vertex and edge labels in the class, and to have edge-less versions be defined outside of the class?
01:44:24 <ivanm> s/edge-less/label-less/
01:57:52 <Renze> Good morning Haskell fokes!
01:59:39 <pacak> Renze: it's midday here :)
02:00:03 <Renze> My assignment says: "Consider the datatype: data SplitReader r a = SplitReader {runSplitReader :: r -> a}, which is isomorphic to the Reader datatype. Define a variant of the Reader monad: instance (Splittable r) => Monad (SplitReader r), where the passed state is split before it is passed on.", but I don't understand what they really mean and my professor sneaked away after college... Could anyone explain the purpose if you'd underst
02:00:13 <Renze> Not in The Netherlands :P
02:00:45 <Renze> (Btw: class Splittable a where split :: a -> (a, a))
02:02:48 <aleator_> What is the fastest way to get an Array a e from f :: (Ix a) => a->e?
02:04:39 <quicksilver> you need your "range" of indices
02:05:30 <lars9> @pl \ r -> k (f r) r
02:05:30 <lambdabot> k =<< f
02:05:31 <aleator_> quicksilver: Yeah, well, lets add pair of Ixes to list of things I have.
02:05:58 <quicksilver> but then I would have thought "listArray ixes (map f (range ixes))"
02:07:02 <aleator_> quicksilver: That seems a bit slow for my application, unless there are some magic options I can give to ghc
02:07:50 <quicksilver> Renze: I think they mean, each individual instruction is executed with a different value in 'r', obtained by using split.
02:07:55 <quicksilver> I think this fails the monad laws :)
02:08:54 <Renze> Yes, that was my intuition as well...
02:09:27 <Renze> And I've tried several ways to implement it, but all failed as an instance and when I looked at the type they all break the laws
02:09:29 <quicksilver> aleator_: I'm not entirely surprised, I don't think the array types are particularly tightly optimised. I suspect for speed you'll do better with vector/uvector but I can't help you with them, I've never used them.
02:09:29 <pedro3005> is there a standard haskell function which takes a char and returns its ascii value?
02:09:38 <quicksilver> > ord 'A'
02:09:38 <lambdabot>   65
02:09:51 <quicksilver> pedro3005: not ASCII value, technically, but unicode point
02:09:51 <pedro3005> <interactive>:1:0: Not in scope: `ord'
02:09:53 <silver> > "юникод"
02:09:54 <lambdabot>   "\1102\1085\1080\1082\1086\1076"
02:10:00 <quicksilver> still, they do coincide for the first 127 chars
02:10:06 <quicksilver> pedro3005: :m Data.Char
02:10:12 <aleator_> quicksilver: Hmm. I'll take a look. Interface wise data.vector seems a step backwards :/
02:10:16 <pedro3005> okay, thanks
02:11:41 <aleator_> It is bit bad that there are IArrays, MArrays, UArrays, Data.Vector, Data.CArray, Data.Accelerate.Array, Data parallel array, hmatrix vectors, hmatrix matrices and none of them seems easily compatible.
02:13:25 <aleator_> Oh, and repa arrays!
02:13:36 <Renze> You know how long it took untill aleator_ Protestant  and Roman Catholic where accepted as compatible, so I don't think your problem will be solved very soon :(
02:13:59 <Renze> well, your nick should've been at the beginning...
02:14:10 <aleator_> C people must be happy to have just one pointer :)
02:14:41 <quicksilver> aleator_: agreed. Although I'm sure the number will reduce in due course.
02:14:53 <quicksilver> there's definitely a place for mutable + immutable + boxed + unboxed
02:15:56 <bartavelle> I have a basic question : when a pure function is evaluated, is the result cached and will all subsequent calls with the same arguments use this cache ?
02:16:24 <quicksilver> no.
02:16:38 <quicksilver> there is no magic implicit cache.
02:16:56 <quicksilver> effectively, you explicitly cache things by naming them, as in "let x = f y in .... use x multiple times ...."
02:17:00 <aleator_> quicksilver: Yeah. Mr Murphy does however dictate that the one I choose to use will first to go :)
02:17:20 <quicksilver> aleator_: but, hopefully, only because one of the others becomes good enough to subsume your use case.
02:17:20 <bartavelle> ah this is not fun then :/
02:17:41 <Jafet> @google memo tries
02:17:42 <lambdabot> http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/
02:17:43 <lambdabot> Title: Conal Elliott » Elegant memoization with functional memo tries
02:17:44 <bartavelle> I thought it was "easy" given that pure code have same arguments -> same results property
02:18:40 <nostrand> bartavelle: but som computations are easier to calculate then save
02:18:45 <bartavelle> true
02:19:03 <bartavelle> that memoization thingie seems to be a good start
02:19:14 <aleator_> quicksilver: Hopefully. DPH might actually (when done) end up being "the" array I guess
02:19:33 <Jafet> A Haskell implementation is of course allowed to cache functions. Since you can do that with data structures anyway, it's also redundant, so they don't
02:19:54 <bartavelle> i don't really know how to do that properly actually
02:20:08 <Philippa> well, that and it'd have to deal with the general case which is pretty vicious
02:20:20 <bartavelle> i have a tree where subtrees can be common
02:20:34 <Philippa> I mean, how would you cache a function with potentially-infinite inputs?
02:20:40 <companion_cube> i like this way of thinking : you do not memoize the result of your function call, but you compute the memoized value the first time you access it...
02:21:12 <Jafet> Memoization is also bad in Haskell, because it's harder to forget things than to remember them
02:22:00 <Jafet> Philippa: lazily
02:22:10 <Philippa> eh, I don't think that's the problem - not being able to check the impure factors that should decide your caching/memoization strategy? That's a problem
02:22:32 <Philippa> Jafet: not good enough, memoisation involved an equality check to look up where you shoved the answer
02:23:06 <Jafet> That's not relevant to infinite inputs, though
02:23:26 <Philippa> it is if you can't check equality on them in finite time!
02:23:36 <pedro3005> how do I join a list of strings by one string, to make it all one whole string? equivalent to python's join()
02:23:42 <quicksilver> pedro3005: concat
02:23:52 <quicksilver> pedro3005: you could have answered that question with 'Hoogle'
02:23:53 <Jafet> Philippa: then neither could the original function in the first place
02:24:03 <quicksilver> pedro3005: if you knew the type, [String] -> String
02:24:13 <Philippa> sure, but the original function doesn't have to
02:24:25 <pedro3005> quicksilver, hmm, but it seems that concat doesn't allow me to place a string beside each of the joined strings
02:24:31 <Jafet> Philippa: then neither does the memoized one
02:24:38 <quicksilver> pedro3005: intercalate / intersperse
02:24:48 <quicksilver> pedro3005: sorry, I didn't understand your question ;)
02:25:00 <quicksilver> > intercalate "," ["sorry","pedro3005"]
02:25:00 <lambdabot>   "sorry,pedro3005"
02:25:08 <Jafet> Basically, you can memoize a function matching its information content, which conal worked out above
02:25:10 <pedro3005> thank you quicksilver !
02:25:59 <pastorn> dcoutts, dcoutts_, dons: you guys are listed as maintainers: http://hpaste.org/42357/bytestring0918_build_error
02:26:25 <Jafet> Oh wait
02:26:49 <pedro3005> quicksilver, what do I need to import to have intercalate?
02:26:58 <Jafet> @google conal memoizing non-strict
02:26:59 <ivanm> pastorn: you do realise that you're not meant to upgrade boot libraries like bytestring, aren't you?
02:26:59 <lambdabot> http://conal.net/blog/posts/nonstrict-memoization/
02:26:59 <lambdabot> Title: Conal Elliott » Non-strict memoization
02:27:15 <ivanm> @index intercalate
02:27:15 <lambdabot> bzzt
02:27:20 <ivanm> @hoogle intercalate
02:27:20 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
02:27:21 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
02:27:21 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
02:27:25 <pastorn> ivanm: i thought it might fix my problem... i can't get the IsString-instance for ByteString.Lazy to work
02:27:26 <ivanm> pedro3005: ^^
02:27:35 <ivanm> pastorn: are you importing the Char8 module?
02:27:38 <pedro3005> thank you ivanm 
02:27:46 <ivanm> pedro3005: np
02:27:49 <pastorn> not to my knowledge
02:27:55 <pastorn> ivanm: or is that the default?
02:28:06 <quicksilver> ivanm: hmm I wonder why @index didn't find it; lambdabot must have a very out of date @index db.
02:28:09 <ivanm> no; but I think that's what defines the IsString instance
02:28:24 <pastorn> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.8/doc/html/Data-ByteString-Lazy.html
02:28:27 <Philippa> Jafet: so to sum that up rapidly, "memoise based on single-step datatype structure"?
02:28:37 <ivanm> pastorn: check the source
02:28:39 <pastorn> ivanm: IsString is right there
02:28:44 <Philippa> I still don't see how that can conclude equality (as opposed to inequality) on an infinite structure
02:28:53 <ivanm> haddock is too smart for its own good sometimes :p
02:29:01 <Jafet> Philippa: well, it actually uses lub, so it's a theoretical novelty at this point
02:29:09 <dcoutts_> pastorn: heh, someone didn't test it with base < 4.3
02:29:20 <ivanm> pastorn: yeah, check the source for Data.ByteString.Lazy.Char8; the instance is actually defined there
02:29:23 <dcoutts_> code's quite broked
02:29:44 <pastorn> dcoutts_: i'm looking at the Lazy.Internal source now... it doesn't export IsString
02:29:53 <quicksilver> Philippa: you don't need complete equality.
02:29:53 <ivanm> pastorn: I told you where it's defined! :p
02:30:06 <dcoutts_> pastorn: that specific bug is fixed in darcs, so I expect they'll be a release soonish
02:30:08 <quicksilver> Philippa: you lazily split up your memotree based on a lazy proof of inequality.
02:30:24 <quicksilver> but, I'm not sure it's worth doing.
02:30:57 <pastorn> wait... i don't get this... why is there always a Word8 and Char-versions?
02:31:12 <pastorn> looking at the source of the whole thing it just points to Internal
02:31:43 <Philippa> pastorn: because you might want to interpret that Word8 as a latin-1 char, and it's a common use case, but you might not
02:31:51 <ivanm> pastorn: bytestring uses Word8 internally; the Char8 version just provides a pseudo-drop-in for String using single-byte Chars
02:32:06 <ivanm> but if you are wanting to do textual stuff, you're better off using Text
02:32:07 <pastorn> typeclass, anyone?
02:32:15 <ivanm> pastorn: for what?
02:32:23 <ivanm> it's the same data-type, just with a different API
02:32:32 <dcoutts_> pastorn: no, they're the same type on purpose
02:32:44 <dcoutts_> pastorn: for dealing with protocols that mix binary and ascii
02:32:53 <pastorn> class ByteStringT t where; cons :: t -> ByteString -> ByteString ...
02:32:58 <dcoutts_> if you're handling unicode, then decode and use text
02:33:25 <pastorn> dcoutts_: i'm writing a loader for the heroes of might & magic 3 .lod-file format
02:33:32 <pastorn> i want those sprites!
02:33:58 <pastorn> dcoutts_: why doesn't the Word8 version export the IsString instance?
02:34:18 <quicksilver> because it's illogical to treat bytes as strings? ;)
02:34:20 <dcoutts_> pastorn: why do you think it should, rather than the Char version?
02:34:31 <pastorn> dcoutts_: convenience
02:34:39 <dcoutts_> pastorn: just import the right module
02:34:51 <pastorn> dcoutts_: doing that now, thanks for the help
02:35:08 <pastorn> i really like attoparsecs instance of IsString (Parser a)
02:36:02 <quicksilver> that is clever, in a way.
02:36:19 <quicksilver> although I tend to think that excessive overloading is a bad plan.
02:36:51 <pastorn> quicksilver: did you see the overloaded if:s?
02:37:03 <pastorn> head ---> asspl0wd
02:37:12 <Philippa> pastorn: not seen it, is it equivalent to calling parsec's string func?
02:37:46 <Philippa> I like overloading so long as it's reasonably controllable. IsString is on the edge for me, but with plenty of good use cases IMO
02:37:47 <pastorn> Philippa: basically, and there also is a 'string' :: [Char] -> Parser ByteString function
02:38:05 <pastorn> wait
02:38:11 <pastorn> ByteString -> Parser ...
02:38:25 <Philippa> no IsString s => IsString Parser s?
02:38:31 <pastorn> http://hackage.haskell.org/packages/archive/attoparsec/0.8.2.0/doc/html/Data-Attoparsec.html#v:string
02:38:39 <pastorn> IsString (Parser ByteString)
02:40:16 <pastorn> hmm... there should be a BNF-like thingy for binary formats along with some BNFC-like tool
02:40:33 <quicksilver> well, BNF works fine for binary formats
02:40:52 <quicksilver> BNF can work on any kind of token, whether it's words, bits, or bytes
02:40:54 <pastorn> quicksilver: do you have a .cf (bnfc) file for a binary file format
02:41:16 * quicksilver has never used bnfc
02:41:25 <Jafet> erlang has bitstring pattern matching syntax
02:41:55 <pastorn> quicksilver: and usually you do stuff like load = do { entryCount <- takeW32; entries <- replicateM entryCount takeEntry; ... }
02:42:34 <Jafet> Woah, that's not context-free.
02:42:47 <pastorn> Jafet: true
02:42:58 <pastorn> Jafet: binary formats rarely are
02:43:22 <pastorn> but the idea of having the parser generated for you sounds like a good idea (in my head at least)
02:43:32 <pastorn> well, "loader" is probably the right word
02:43:45 <quicksilver> I don't find using a good parser combinator library much different from using a parser generator
02:43:55 <quicksilver> writing in good combinators is much like writing in BNF
02:44:00 <quicksilver> but more composable / abstractable
02:44:19 <quicksilver> the main reason I'd choose a generator is speed, not convenience of authoring.
02:44:43 <Jafet> There is some work on making parser combinators themselves generate efficient parsers.
02:45:01 <pastorn> like this: http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure
02:45:34 <pastorn> a loader for that could quite easily be generated...
02:46:45 <pastorn> what's that weird C++/template hack that let's you write ascii-art-code?
02:50:19 <pastorn>  http://hpaste.org/42358/tcp_header_datagram <-- that, but maybe some additional information could probably be used to generate a loader...
02:50:55 <Itkovian> Any idea if regex-tdfa will replace regex-posix or if it will be included in the next platform release?
02:51:31 <Bynbo7> pastorn: wasn't there a TH... thing that let you do that?
02:51:56 <pastorn> copumpkin: the bad thing about writing your own is that it's bound to your language
02:52:23 <Bynbo7> so, i feel i understand iteratees somewhat, but i can't think of a good way to play with them :9
02:52:28 <Bynbo7> :(*
02:52:28 <Jafet> pastorn: I don't see how you can get any more compact than an appropriate set of parser combinators.
02:52:40 <Jafet> @google analog literals
02:52:41 <lambdabot> http://www.xs4all.nl/~weegen/eelis/analogliterals.xhtml
02:52:58 <pastorn> Jafet: i don't think it's about compactness, i think it's about readability and language-agnosticism
02:53:12 <pastorn> Jafet: right, that :)
02:53:21 <Nibble> btw guys
02:53:23 <Nibble> great idea here
02:53:27 <Jafet> pastorn: you want to be language-agnostic by inventing a new language?
02:53:27 <Nibble> Karel the robot
02:53:30 <Nibble> anyone knows about it?
02:53:37 <Jafet> That sounds very strange to me.
02:53:50 <pastorn> Jafet: it's not a new language, it's just a specification for datagrams
02:54:07 <Jafet> There is no such thing as language-agnosticism, any more than there is a way to wire a neural net with no preconceptions...
02:54:20 <pastorn> Jafet: have you used bnfc?
02:54:24 <pastorn> http://www.cse.chalmers.se/research/group/Language-technology/BNFC/
02:54:30 <Nibble> pastorn: oh, swe
02:54:34 <Nibble> dtek?
02:54:40 <pastorn> Nibble: hehe, klart
02:55:05 <Nibble> pastorn: många därifrån här :)
02:55:13 <pastorn> Jafet: the idea being .cf-file ==> parser in haskell/java/c/c++/ocaml
02:55:15 <Nibble> pastorn: what year?
02:55:19 <pastorn> d06
02:55:36 <pastorn> Nibble: #haskell-blah
02:55:39 <Jafet> No, pastorn. It looks vaguely like yacc, antlr, happy and all the other parser generators, though. And I've never used any of them.
02:56:17 <Jafet> Using a separate generator may be your thing, but don't call it "language-agnostic". That just obscures the issue.
02:56:18 <pastorn> Jafet: the java 1.1 grammar file is pretty nice :)
02:56:51 <Nibble> But back to Karel the Robot
02:57:40 <Nibble> anyone in here that have heard about it?
02:58:27 * hackagebot language-c 0.3.2.1 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.3.2.1 (BenediktHuber)
02:58:55 <quicksilver> pastorn: jafet's right, though, that is a new language
02:59:10 <quicksilver> it's a grammar-specification language not a general purpose programming language.
02:59:17 <quicksilver> Inventing new languages isn't a bad thing.
02:59:28 <quicksilver> parser combinators are a DSL after all
03:00:58 <Nibble> DSL?
03:01:24 <Philippa> Domain Specific Language
03:01:43 <Philippa> and yeah, inventing new small languages is a good thing that we should (and inevitably do anyway) do all the time
03:02:00 <Philippa> only, in such a way that we develop taste in doing so and understand the semantics sufficiently
03:02:50 <pastorn> writing these datagram images is preatty easy for me (using vim + visual block all the time), but i'm guessing that other users might have problems...
03:03:00 <Nibble> vivivi
03:03:05 <Nibble> the editor of the beast
03:03:07 <pastorn> the editor of the beast
03:03:10 <pastorn> smurf
03:03:26 <Nibble> pastorn: använd ett riktigt operativsystem istället
03:03:31 <Jafet> Actually, 666 is DCLXVI.
03:04:03 <pastorn> Jafet: well, the song goes "six six six", not "sixhundred and sixtysix";
03:04:24 <Jafet> Also, visual languages look nice, but computing hasn't really studied them much yet, so be prepared for a ride
03:04:42 <Nibble> But seriously, Karel the Robot
03:04:47 <Philippa> eh, I think one reason they've not been studied much is that in one sense they're "just syntax"
03:04:50 <Nibble> anyone ever heard of it?
03:05:07 <pastorn> Philippa: there are cool versions of FORTH
03:05:38 <Jafet> Colorforth is still pretty stuck in Moore's basement
03:05:43 <quicksilver> Philippa: people do study 'just syntax' though, sometimes ;)
03:05:48 <quicksilver> Philippa: my PhD was on a visual syntax.
03:06:58 <Philippa> sure, I'm not saying it's not worthy of study at all
03:07:06 <Jafet> quicksilver: what was that xyntax for?
03:07:23 <Philippa> though I'm generally of the view that once I'm veering on using turing completeness I want another view too
03:07:24 <Jafet> Er, xyntax
03:07:30 <Jafet> Argh
03:08:41 <pastorn> quicksilver: linky?
03:08:44 <Jafet> Must be from typing xs all the time
03:10:05 <pastorn> now for something completely different - endianness!
03:10:25 <quicksilver> Jafet: proofs in a (slightly obscure) logic called bunched implications
03:10:41 <pastorn> i want to get the Word32 0xaabbccdd but it's stored as 0xddccbbaa, then what do i call it's endianess?
03:10:46 <pastorn> reverse?
03:10:56 <pastorn> byte-reverse? byte-little?
03:11:07 <Jafet> What does that word represent?
03:11:42 <pastorn> Jafet: uint32_t
03:11:47 <Jafet> Endianness refers to how a complex object is stored as bytes, so it only has meaning with respect to that object
03:12:24 <Jafet> Well, s/(complex )?object/number/g
03:12:30 <pastorn> Jafet: all i know is that if i have 0xHILO and store that as 0xLOHI, then i'm using little endian
03:12:50 <quicksilver> pastorn: LSB-first?
03:13:05 <pastorn> but this is a 4 byte construct which isn't 0xlolohihi
03:13:10 <pastorn> quicksilver: awesome, thanks :D
03:13:27 <Jafet> Well, is 0xHILO in little or big endian?
03:13:27 <pastorn> takeW32lsbf :: Parser Word32
03:13:37 <pastorn> quicksilver: best function name EVAR
03:13:39 <pastorn> Jafet: big
03:14:02 <Jafet> If 0xHILO is in big endian, then 0xLOHI is its representation in little endian, and vice versa
03:14:05 <Bynbo7> big endian is the same as how we write numbers
03:14:20 <pastorn> Bynbo7: that, i know
03:14:22 <Jafet> Pretty much by definition
03:14:23 <pastorn> :p
03:14:37 <Bynbo7> pastorn: that was more for Jafet's benefit
03:14:39 <Jafet> Bytes don't have endianness by themselves
03:14:51 <pastorn> Jafet: they can have bit-endianness
03:15:23 <Jafet> Okay, bytestreams don't have endianness by themselves
03:15:37 <pastorn> Jafet: http://en.wikipedia.org/wiki/Endianess#.22Bit_endianness.22
03:17:01 <sipa> If 0xHILO is in big endian, then 0xLOHI is its representation in little endian, and vice versa  --> no, 0xLOHI would be the number resulting from incorrectly interpreting the big-endian encoded number 0xHOLI as little-endian
03:17:36 <sipa> (or the other way around)
03:17:44 <Jafet> I assumed that it referred to two bytes, LO and HI
03:17:46 <pastorn> sipa: ah, good point there :)
03:17:51 <Bynbo7> it's all a matter of persoective bro!
03:17:59 <Bynbo7> perspective too
03:18:02 <pastorn> Jafet: that was what i did
03:18:51 <sipa> ow my
03:19:02 <sipa> 0xHILO, not 0xHOLI
03:19:11 <pastorn> http://hpaste.org/42359/takeword32leastsignifacantb
03:19:15 <Jafet> I suspect you still don't really understand what endianness is, but that never stopped anyone so I'll stop
03:19:24 <pastorn> any profiling nuts wanna help me? ^^^^
03:19:25 <Jafet> sipa: fine, (quote 0xLOHI)
03:20:30 <Bynbo7> so, with the tao main iteratee packages, iteratee and enumerator, is there any chance we'll have the same situation we had with mtl/transformers where one ends up exporting the other?
03:20:35 <Bynbo7> two*
03:20:45 <pastorn> copumpkin: ^^^^
03:20:46 <pastorn> copumpkin: i know you want to :D
03:21:28 <Bynbo7> looks ok to me
03:22:50 <pastorn> Bynbo7: in C i'm guessing it would be a byte[] and then just drop-in each read byte and afteth that cast that to a 32-bit thingy
03:23:12 <pastorn> this allocates 4*32 bits
03:23:14 <Bynbo7> most likely
03:23:19 <Jafet> You can do that in Haskell as well and non-portably as you can do it in C.
03:23:21 <pastorn> wait... 5*32
03:23:37 <pastorn> Jafet: Foreign.Ptr ?
03:23:37 <Jafet> In fact, it's probably more portable in Haskell, which isn't used on all sorts of strange systems
03:23:42 <Bynbo7> :t replicateM
03:23:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:23:53 <Jafet> I was thinking of unsafeCoerce, but you get the idea
03:24:21 <pastorn> Jafet: hmm... what types in haskell gives me the *actual* C representation, without thunks etc.?
03:24:41 <Jafet> You could also FFI to ntohl
03:24:42 <pastorn> (so that unsafeCoerce works)
03:25:05 <Bynbo7> :t foldl
03:25:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:25:06 <Jafet> Haskell doesn't have any such types, but there's GHC.Prim
03:25:19 <pastorn> Jafet: that's probably smarter... seing how the C would be very straight-forward
03:26:00 <Bynbo7> do { [a,b,c,d] <- replicateM 4 anyWord8; return (foldl (\acc x -> shiftL acc 8 + fromIntegral x) 0 [d,c,b,a])
03:26:14 <pastorn> where is GHC.Prim? http://hackage.haskell.org/package/base-4.3.0.0
03:26:31 <Jafet> What is your takewordblahblah too slow for, anyway?
03:26:41 <Bynbo7> pastorn: also, premature optimisation...
03:27:02 <pastorn> Bynbo7: of cource! but i'm doing game-related stuff, so it's allowed
03:27:19 <Bynbo7> wait until it's actually a problem, then fix it
03:27:22 <pastorn> games/cg is the only place where you're allowed to do crazy bit-optimizations
03:27:35 <pastorn> Bynbo7: NEVAR (also, this is a fun problem)
03:27:40 <Bynbo7> when things are running too slowly
03:28:53 <Jafet> Games never need to do that!
03:28:58 <quicksilver> optimising loading of a file doesn't sound right
03:28:59 <Jafet> I demand you come up with a better excuse
03:29:00 <quicksilver> that's a one-off task
03:29:09 <quicksilver> you optimise things which happen in the main loop every frame
03:29:15 <quicksilver> not something which takes 60ms at startup
03:29:17 <Jafet> Like mixed-endian HPC
03:29:21 <pastorn> Bynbo7: i don't really know how much i'll be using this operation yet, but i'm working with three files that are 12, 42, 62 and 101 MB
03:29:26 <pastorn> *four files*
03:29:27 <Jafet> Or filesystems
03:30:35 <pastorn> quicksilver: what if i don't like having things stored in memory? huh? ever thought of that?
03:30:45 <pastorn> i might want to reload all the graphics from files at each frame!
03:30:51 <Bynbo7> pastorn: so, quite small files then ;)
03:31:21 <quicksilver> pastorn: then the byteswapping time is 3 orders of magnitude smaller than the load from disk time
03:31:26 <pastorn> Bynbo7: actually these giant files are containers for thousands of .PCX files and some other stuff
03:31:29 <quicksilver> pastorn: possibly as much as 6 orders of magnitude...
03:32:00 <Bynbo7> only 6? i would have said closer to 9...
03:32:25 <Jafet> How much is one order of magnitude, anyway?
03:32:28 <quicksilver> Bynbo7: well, I'm assuming an inefficient haskell byteswap
03:32:29 <quicksilver> Jafet: 10.
03:32:34 <quicksilver> Jafet: I'm a decimal kind of guy.
03:32:56 <quicksilver> Bynbo7: a machine word byteswap would be faster in principle
03:33:05 <quicksilver> (although that might not matter due to memory bottleneck)
03:33:08 <pastorn> hmm... using GHC.Prim* requires a lot of MagicHash to cast to "real" values later on, right?
03:33:19 <Jafet> Or run all your code on an Alpha, and toggle the processor endianness
03:33:29 <pastorn> wait! isn't there a possibility to inline LLVM in haskell nowadays?
03:33:45 <Bynbo7> not inline, no
03:33:47 <Jafet> pastorn: what the fuck
03:33:54 <Bynbo7> you can write llvm code in haskell
03:33:58 <Nibble> the fuck what?
03:34:07 <pastorn> Nibble: precisely
03:34:10 <Bynbo7> actually, maybe you can
03:34:16 <Cale> I bet you actually could pull it off
03:34:22 <Bynbo7> you can run said llvm code from your program...
03:34:29 <Cale> Generate code at runtime and use the FFI to jump into it
03:34:30 <Bynbo7> i'd like to see that actually :P
03:34:46 <Jafet> That sounds more wrong than that other program which got its own filename by deliberately causing an exception
03:35:00 <Cale> Why?
03:35:00 <Jafet> And less portable
03:35:07 <Cale> LLVM is portable :P
03:35:16 <pastorn> Jafet: http://mainisusuallyafunction.blogspot.com/2010/09/executing-bytestring.html
03:35:52 <pastorn> Jafet: that what you were looking for? :)
03:36:04 <Jafet> That isn't what you're looking for?
03:36:15 <pastorn> Jafet: maybe, but not really
03:36:17 <Nibble> that just uses FFI
03:37:05 <Cale> Actually, I think the LLVM binding may actually allow you to run the generated code.
03:38:46 <sipa> pastorn: have you any idea exactly how much cpu time you will gain by doing such optimizations?
03:38:57 <pastorn> sipa: no clue at all
03:39:04 <Nibble> probably none
03:39:04 <pastorn> i'm not actually gonna do this
03:39:06 <sipa> then do not worry about it none
03:39:16 <sipa> *now
03:39:17 <pastorn> sipa: but it's fun :D
03:39:28 <sipa> ok, fun is a very reasonable excuse
03:39:29 <pastorn> the moar u kno
03:39:30 <Cale> http://www.serpentine.com/blog/2008/01/03/llvm-bindings-for-haskell/ -- yep
03:39:33 <Cale> here's how to do it
03:40:12 <pastorn> is it just me or is that pages font microscopic?
03:40:20 <Cale> not just you
03:40:26 <Jafet> It might be fun to have a parser combinator that produces parsers that way
03:40:26 <Cale> it's pretty tiny for me as well
03:40:38 <Cale> at least, the code font is
03:40:42 <Jafet> A parser combinator library
03:41:06 <sipa> with LLVM code generation?
03:41:17 <Jafet> It might be optionally available.
03:41:37 <Jafet> Doesn't parsec internally optimize its parsers?
03:42:07 <Cale> Well, it uses a not-so-naive representation of them anyway
03:42:44 <quicksilver> it can't do much because they're so general
03:42:58 <pastorn> Jafet: lecture 4: http://www.cse.chalmers.se/edu/course/afp/lectures.html
03:42:58 <quicksilver> it's hard to optimise monads much, because they can use earlier values in arbitrary ways
03:43:15 <quicksilver> and >>= uses a function on the right, which is not introspectable in haskell
03:43:22 <pastorn> Jafet: Parser3 is the optimized version, seems to have lots of comments as well
03:43:27 <quicksilver> this is (one of) the justifications for SD arrow parsers
03:43:37 <quicksilver> they can do first-token tables
03:45:07 <pastorn> btw, does GADTs have a performance penalty over regular ADTs?
03:46:08 <Cale> pastorn: I would be quite surprised.
03:46:35 <Cale> pastorn: The difference between GADTs and normal ADTs at runtime is almost nothing.
03:46:42 <pastorn> ok
03:47:03 <Cale> The tricky part about GADTs is the typing stuff which is all eaten up and discarded by compilation.
03:47:47 <Cale> Your data constructors will still have integer tags followed by appropriate pointers to the fields.
03:48:06 <pastorn> yeah, thought so
03:48:10 <pastorn> but are there any cons?
03:48:39 <sipa> portability
03:48:47 <sipa> maybe?
03:49:04 <pastorn> like... you can't express 'Bind :: T a -> (a -> T b) -> T b' with normal ADTs, but is there some advantage to GADTs other than that?
03:49:19 <pastorn> that right there + phantom types is the only use i've seen of it
03:49:34 <pastorn> are there other uses?
03:53:02 <quicksilver> pastorn: the advantage of GADTs is they give the type checker a little more help
03:53:34 <quicksilver> that enables you to write code a little more tightly (some cases excluded) a little more concisely (no need to worry about impossible cases) and a little more automatically (the extra type information can be enough to magically select from a typeclass)
03:53:50 <quicksilver> they're essentially a compile-time only advantage.
03:54:27 <Bynbo7> > let (<:>) = (:) in 1 <:> [2,3]
03:54:28 <lambdabot>   [1,2,3]
03:57:27 <Nibble> > let (<:>) = : in 1 <:> [2,3]
03:57:28 <lambdabot>   <no location info>: parse error on input `:'
03:57:35 <Nibble> wait wut
03:57:36 <shachaf> quicksilver: Just like types? :-)
03:57:43 <Nibble> why does it whine about that
03:57:50 <Bynbo7> :t :
03:57:51 <lambdabot> parse error on input `:'
03:57:53 <shachaf> Nibble: Because ":" isn't an expression.
03:58:16 <Nibble> what is an expression and what is not an expression?
03:58:28 <Bynbo7> (:) is an expression
03:58:35 <Nibble> I see that
03:58:37 <Bynbo7> (a :) is an expression
03:58:43 <Nibble> but what is an expression and what is not
03:59:06 * Bynbo7 pokes quicksilver who is much better at answering questions likc this
03:59:12 <Cale> Nibble: Unless you intend to use an infix operator as infix, you must give it both its parameters
03:59:54 <Cale> Nibble: An expression refers to a bit of code which can be evaluated to produce a value.
04:01:21 <Cale> (and there's a definition of exactly what bits of text are valid expressions in the Haskell Report, though that doesn't cover all the extensions)
04:04:29 <xplat> if you want to use an operator in an expression, you have two choices: either you give it both its parameters, or you give it either or none of its parameters and enclose it in parentheses so the parser knows you meant to do that
04:05:24 <zygoloid> pastorn: GADTs allow a greater number of correct programs to make it through the type checker.
04:06:24 <zygoloid> (thus getting us closer to the impossible ideal of all correct programs accepted and no incorrect programs accepted)
04:07:10 <zygoloid> and i mean "correct" in the "well-typed programs don't go wrong" sense, not in the computes-the-right-answer-and-halts sense
04:08:00 <xplat> zygoloid: that's such a 'turing tarpit is half empty' way to look at it.  i prefer to think of it as 'GADTs let you define correct programs that use fewer runtime tag checks'
04:08:53 <xplat> or 'GADTs let you delete more dead code from your correct programs'
04:09:43 <zygoloid> or 'GADTs let you check more stuff at compile time'? :)
04:09:49 <xplat> or even 'GADTs let you do more of your computation at compile time'
04:11:14 <dark> quicksilver, SD arrow parsers?
04:13:08 <zygoloid> xplat: compromise: 'GADTs allow programs to be expressed in more natural ways and still type-check'
04:13:45 <xplat> ah, that might be a good compromise
04:13:49 <pastorn> Cale: maybe i was thinking about the the optimization that's done in Parallel Parsing Processes by Koen as the optimization
04:13:56 <pastorn> *faster code
04:14:20 <pastorn> it the SymbolBind-thing is faster, and doesn't need GADTs
04:14:34 <Nibble> dph looks awesuuuuuum
04:14:41 <pastorn> Nibble: no it doesn't :9
04:14:42 <pastorn> :(
04:14:47 <Cale> pastorn: That's what ReadP does
04:14:48 <pastorn> Nibble: can't generate imports
04:14:58 <Cale> (I think)
04:15:04 <pastorn> Cale: ah, is that where that paper is implemented?
04:15:35 <pastorn> "This is a library of parser combinators, originally written by Koen Claessen"
04:15:37 <pastorn> hehe
04:22:47 <pastorn> why use parsec? this seems much nicer...
04:23:20 <pastorn> also: it's in base
04:23:22 <quicksilver> dark: Swierstra-Duponcheel parsers are one of the motivating examples of arrow parsers.
04:28:18 <pastorn> quicksilver: they seem cool
04:28:33 <pastorn> isn't there some big haskell parser shootout somewhere?
04:28:41 <quicksilver> I'm not aware of one
04:28:50 <pastorn> there should be...
04:28:56 <quicksilver> not a bad idea
04:29:05 * pastorn is full of ideas
04:29:07 <quicksilver> although convenience and performance are very different axes
04:29:18 <quicksilver> and they are both very problem dependent, but convenience especially so.
04:29:38 <pastorn> quicksilver: precisely, so it they shoulb be used for many different purposes
04:30:15 <pastorn> for example stuff like an expression evaluator/calculator parser, s-expressions, loading something binary etc.
04:30:46 <pastorn> and maybe a subset of java
04:44:45 <xplat> yeah, for example, you can't use a pure context-free parser generator to load most of even the nice streamable binary formats, because they use counts
04:45:37 <xplat> so the best approach for something else could be Right Out for that
04:46:39 <pastorn> xplat: Right Out?
04:46:43 <quicksilver> xplat: well, you might be able to use a simplist front-end to chunk the frames
04:46:54 <quicksilver> xplat: and it might be context-free within the frames. (Or it might not.)
05:25:55 <pastorn> hmm... i have found an esthetic type error bug...
05:26:03 <pastorn> *aesthetic
05:26:24 <pastorn> in my source i have B.span (/= 0x00)
05:26:37 <pastorn> ghci tells me "B.span (/= 0)"
05:27:30 <pastorn> also, i hate this:     Couldn't match expected type `ByteString'
05:27:32 <pastorn>            against inferred type `Data.ByteString.Internal.ByteString'
05:28:59 <xplat> i'd have expected some kind of 'not in scope' error rather than that, certainly
05:29:05 <xplat> what ghc version?
05:29:18 <pastorn> this is why i don't like bytestrings very much
05:29:28 <dom96> You're probably importing the wrong version of ByteStrings.
05:29:35 <pastorn> dom96: no i'm not
05:29:48 <pastorn> import Data.ByteString.Lazy.Char8 (ByteString (..))
05:29:50 <pastorn> import qualified Data.ByteString.Lazy as B
05:30:09 <dom96> pastorn: Try without the .Lazy
05:30:17 <pastorn> it's worked all the way up to this point (180 lines so far)
05:30:20 <xplat> no, that's the wrong version.  lazy but your expression returns strict.
05:30:28 <dom96> yeah.
05:30:38 <xplat> well, then the expression is wrong
05:30:51 <pastorn> dom96: the strict verson is not very fun for testing, especially when you're dealing witha 96 MB file
05:31:22 <dom96> pastorn: You need to use functions which use lazy ByteStrings then. 
05:31:30 <pastorn> I AM!
05:31:40 <pastorn> import qualified Data.ByteString.Lazy as B
05:31:46 <xplat> you probably are in general, but not in that expression
05:31:48 <dom96> ...
05:31:53 <dom96> Where are you getting that error?
05:32:29 <xplat> you need a fromChunks [ ... ] somewhere
05:32:55 <xplat> because of some library function that is returning a strict bytestring
05:33:51 <pastorn> xplat: i'm guessing that would be span....
05:34:05 <xplat> for example, the crypto hash functions all return strict bytestrings even if you hash a lazy one with hashLazy
05:34:23 <dom96> pastorn: That wouldn't make any sense, since B.span is in Data.ByteString.Lazy
05:35:14 <pastorn> i get the source with Data.Attoparsec.Lazy.take :: Int -> Parser ByteString
05:35:41 <pastorn> oh, that one is strict!
05:35:45 <pastorn> SNEAKY!
05:36:05 <pastorn> wait...
05:36:56 <pastorn> xplat: what's the idea with the chunks? is this some sort of buffering trick?
05:37:41 <xplat> pastorn: a lazy bytestring is essentially a list of strict-bytestring chunks.  fromChunks is basically a smart constructor.
05:37:54 <pastorn> cool
05:38:27 <xplat> so you give it a list of strict bytestrings, it gives you a lazy bytestring
05:40:08 <romildo> Is cabal able to fetch a package from its darcs repository, instead of fetching a released file?
05:40:56 <dcoutts_> romildo: not yet
05:53:53 <Nibble> better name for cabal, cabel. it wires stuff over to you!
05:55:20 <sipa> and packages which have serious memory leaks, become leaky cabels then (not the same as leaked cables, though)
05:55:39 <Nibble> indeed
05:56:51 <Bynbo7> whoot! my first semi-useful iteratee program!
05:57:30 <Bynbo7> you give it a file name, and it'll tell you how many of each byte there is, in constant memory!
05:58:13 <benmachine> neat
05:58:22 <pastorn> Bynbo7: how did you do it?
05:58:26 <Bynbo7> can do a 3.5MB file in just under 2 minutes (and using like 30% CPU
05:58:32 <pastorn> do you have an Array? List?
05:58:38 <Bynbo7> uh, 3.5GB* :P
05:58:40 <pastorn> Map
05:58:43 <Bynbo7> an IOUArray
05:58:51 <pastorn> cool
05:58:55 <meltingwax> cool
05:58:58 <benmachine> cool
05:59:01 * dcoutts_ notes it can be done shorter with lazy IO and still in constant space ;-)
05:59:19 * dcoutts_ runs off before the flames about lazy IO...
05:59:22 <pastorn> dcoutts_: please explain
05:59:30 <Bynbo7> heratic!
06:00:10 <sipa> it's not because lazyness and IO are Haskell's most distictive features, you should encourage the use of lazy IO!
06:00:15 <Bynbo7> yeah he's right, all you need for the laxyIO version is for get a lazy bytestring, and do a foldl' on it (or something along those lines)
06:00:16 <dcoutts_> honestly, I think people have been a little hysterical about lazy io vs iterator style things
06:00:59 <Bynbo7> well, we're using iteratees extensively where i'm working, and it seems to be working well (except when it doesn't and you get horrible space leaks :))
06:01:19 <Bynbo7> but, i haven't touched any iteratee code properly yet
06:01:31 <dcoutts_> so no resource leaks, just space leaks :-)
06:01:57 <Bynbo7> in general they're well behaved, it's just it a very large and complex system
06:13:56 <quicksilver> dcoutts_: you say that like being hysterical is a bad thing.
06:14:03 <quicksilver> dcoutts_: I promise you, it's merely a debating technique.
06:14:04 <quicksilver> :P
06:14:07 <dcoutts_> quicksilver: :-)
06:14:24 <meltingwax> :)
06:14:26 <quicksilver> @quote glass
06:14:26 <lambdabot> islands says: how will people know I'm cool if I'm not wearing my sunglasses?
06:14:29 <quicksilver> hmm
06:14:37 <benmachine> B)
06:14:53 <quicksilver> @quote broken.glass
06:14:53 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
06:14:53 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
06:15:18 <quicksilver> hyperbole++
06:15:55 <pastorn> is there a way to combine printf with ByteString?
06:16:08 <Bynbo7> in which way?
06:16:26 <Bynbo7> i would love to see ByteString made a PrintfType
06:16:37 <pastorn> well, the formatting string can stay the same, i think i want an instance of PrintfArg ByteString
06:17:00 <Bynbo7> so you can give it a bytestring as an argument?
06:17:11 <pastorn> sure, and just use %s for it
06:17:23 <pastorn> maybe %S
06:17:25 <Bynbo7> might be possible to implement
06:17:31 <pastorn> since it's special...
06:17:37 <Bynbo7> i
06:18:03 <Nibble> how do I use Map.Insert?
06:18:03 <Bynbo7> i'd love to see %@ added to printf, that would show anything with a show instance
06:18:09 <Nibble> Map.insert*
06:18:12 <quicksilver> instance PrintfArg ByteString where toUPrintf = UString . unpack
06:18:12 <Bynbo7> :t M.insert
06:18:13 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
06:18:15 <quicksilver> it's trivial
06:18:29 <quicksilver> but IIRC that's a non-exported class so you'll have to build an altered package.
06:18:36 <Bynbo7> > M.insert 1 "hello" M.empty
06:18:37 <lambdabot>   fromList [(1,"hello")]
06:18:51 <Nibble> hmm
06:18:51 <pastorn> quicksilver: that's pretty shoddy
06:18:54 <quicksilver> (I thought printf was a proof-of-concept I didn't realise people actually used it)
06:19:06 <Nibble> how would a map handle about 60000 updates each second?
06:19:07 <pastorn> quicksilver: it's friggin awesome?
06:19:11 <Bynbo7> quicksilver: all the time
06:19:40 <pastorn> Nibble: in log n time
06:19:42 <Bynbo7> quicksilver: baing abe to use it as printf and sprintf without modification is awesome
06:19:46 <pastorn> that's how it would handle it
06:19:53 <Bynbo7> Nibble: what are you doing?
06:20:03 <Nibble> Bynbo7: writing to you
06:20:12 <Bynbo7> .. more specifically
06:20:36 <Nibble> Bynbo7: pressing buttons on my keyboard that my computer then transfers to you by the internetz
06:20:46 <quicksilver> pastorn: it's an ugly type-system hack which ressurects an ugly varargs hack which was only necessary because C had a limited type system.
06:20:56 <quicksilver> pastorn: really we have better ways of formatting strings than that.
06:20:59 <benmachine> Bynbo7: is it? do you think your productivity is improved by not having to type that s? :P
06:21:43 <pastorn> quicksilver: show me a better way of showing pi as "3.142"
06:21:51 <Bynbo7> Nibble: you know, if you want help from people, not being annoying is usually beneficial to your cause
06:21:59 <pastorn> printf "%d.2" pi
06:22:08 <pastorn> pretty awesome if you ask me ;)
06:22:13 <benmachine> isnt't that %.2f
06:22:19 <benmachine> or .3 actually
06:22:22 <Nibble> Bynbo7: I don't see the relevance of what I might be doing to the question whether Map can handle thousands of updates and insertions per second.
06:22:41 <Bynbo7> Nibble: i meant what are you trying to do with the map... -_-
06:22:56 <Nibble> I just said that? Didn't I?
06:23:06 <Nibble> Updating it and insertions thousands of times per second.
06:23:29 <pastorn> benmachine: probably
06:23:36 <pastorn> i don't deal with decimals
06:23:43 <pastorn> i just use it for %d and %s
06:23:43 <Bynbo7> yes, what dor, we might be able to offer you comthing better suited to the job, and be able to answer your question more accurately
06:23:53 <Bynbo7> but if you don't want help, that's fine
06:23:56 <Nibble> pastorn: take 5 (show pi)
06:24:05 <Nibble> would work :P
06:24:09 <pastorn> Nibble: haha
06:24:11 <pastorn> RIGHT
06:24:37 <dcoutts_> Nibble: btw, 60,000 map updates per sec sounds quite realistic
06:25:03 <Alligau> nice tutorial here!! :)
06:25:12 <Alligau> is sth like this aviable for prolog too?
06:25:14 <Nibble> The only problem is going to be them memory copies.
06:25:34 <Bynbo7> what memory copies?
06:25:57 <Bynbo7> there'll be log n of them with each update... but possibly less with laziness, not sure
06:26:13 <Nibble> I am lazy, so
06:26:38 <dcoutts_> Nibble: if you're worried, benchmark it. It's not tricky.
06:26:48 <copumpkin> the people in haskell be out there to steal ur ideaz
06:27:23 * Bynbo7 just steals copumpkin instead
06:27:46 <copumpkin> :O
06:28:04 * benmachine steals Bynbo7
06:28:08 * benmachine gets copumpkin by transitivity
06:28:22 <quicksilver> > showFFloat (Just 3) pi ""
06:28:22 <lambdabot>   "3.142"
06:28:33 <quicksilver> pastorn: ^^ although you probably don't think it's better
06:28:37 * fryguybob wonders of theft of copumpkin is the same as pumpkin being stolen from you.
06:29:14 <pastorn> quicksilver: that's pretty bad
06:29:22 <pastorn> > showFFloat Nothing pi ""
06:29:22 <lambdabot>   "3.141592653589793"
06:29:34 <pastorn> > showFFloat Nothing (200 + pi) ""
06:29:35 <lambdabot>   "203.14159265358978"
06:29:43 <pastorn> > showFFloat (Just 3) (200 + pi) ""
06:29:43 <Bynbo7> copumpkin: quick, steal benmachine  and get yourself back!
06:29:43 <lambdabot>   "203.142"
06:29:58 <pastorn> copumpkin: nono, i ain't doing thta
06:30:03 <pastorn> nowai
06:30:32 <quicksilver> pastorn: the printf format string isn't an awful minilanguage for describing floating point presentation format, but the variable argument hack is horrid, and the whole idea of carrying around a string which isn't parsed until runtime is nasty.
06:30:41 <copumpkin> o.O
06:30:52 <benmachine> quicksilver: there's a TH version that avoids both problems
06:31:12 <benmachine> bit heavyweight just for formatting strings though :)
06:31:20 * Bynbo7 wishes that printf would be added to ghc somehow, so you can get the type checking that C compilers like clang do
06:31:50 <pastorn> quicksilver: yes, and i will burn for it - alas, i do not care
06:32:30 <pastorn> quicksilver: a few runtime crashes never killed anyone...
06:33:11 <copumpkin> Bynbo7: via a special case? I hate that hack
06:33:13 <Twey> Bynbo7: There's a TH version that does static checking.
06:33:31 <Bynbo7> hooray
06:33:46 <Twey> @package printf-th
06:33:46 <lambdabot> http://hackage.haskell.org/package/printf-th
06:34:02 <Twey> Hm, not there
06:34:12 <Bynbo7> i think i'm doing quite well, in the past week, i've managed to learn how to use monad transformers (something i've been putting off), and learn how to use iteratees
06:34:17 <Twey> Oh
06:34:20 <Twey> @package printf-TH
06:34:20 <lambdabot> http://hackage.haskell.org/package/printf-TH
06:34:22 <Twey> Case
06:34:33 <Twey> There's also xformat
06:34:39 <Bynbo7> no dice
06:35:36 <Twey> http://hackage.haskell.org/package/Printf-TH
06:35:52 <quicksilver> benmachine: yes, and undoubtedly you can come up with something cleverer, too
06:35:57 <Bynbo7> what a lovely minimal package
06:36:00 <quicksilver> benmachine: to me, it's a non problem though
06:36:09 <quicksilver> I'm quite happy with concat + show.
06:36:47 <Bynbo7> not unwords?
06:37:46 <benmachine> I'm generally happy with that too, tbf
06:41:28 <copumpkin> @ask ezyang do you have a version of hoopl that works on GHC 7?
06:41:28 <lambdabot> Consider it noted.
06:42:50 <quicksilver> Bynbo7: sometimes unwords, yes, and sometimes unlines
06:43:14 <copumpkin> we need an unparagraphs
06:43:21 <copumpkin> and an uncharacters = id
06:44:13 <quicksilver> if I thought I needed unparagraphs, I imagine what I really needed was pretty printing combinators a.la Doc 
06:44:21 <quicksilver> but I've never written that kind of code
06:44:30 <copumpkin> just being silly :)
06:44:51 <unkanon> morning, augur
06:46:52 <unkanon> what's the latest on nplusk?
06:49:01 <lars9> is undefined == fix id?
06:49:20 <unkanon> I'm curious because I bought a book that uses it and I hadn't seen it in a long time in anything new (but the book is old)
06:49:25 <benmachine> lars9: depends what you mean by ==
06:49:29 <Bynbo7> @src undefined
06:49:29 <lambdabot> undefined =  error "Prelude.undefined"
06:49:37 <benmachine> lars9: there are some senses in which the two are the same
06:51:03 <lars9> benmachine: can compiler know fix id is 'unevaluatable'?
06:51:29 <benmachine> lars9: it's possible under certain circumstances that the compiler would work it out
06:51:58 <lars9> topology of ast?
06:53:06 <ion> Programming: http://i.imgur.com/0DNIZ.png (not quite on-topic, but perhaps enough)
06:54:42 <lars9> > fix id
06:54:46 <lambdabot>   mueval-core: Time limit exceeded
06:54:54 <lars9> > undefined
06:54:54 <lambdabot>   *Exception: Prelude.undefined
06:55:01 <lars9> > undefined :: Int
06:55:01 <lambdabot>   *Exception: Prelude.undefined
06:55:21 <quicksilver> GHC spots some infinite recursion at runtime (blackhole) but never at compile time.
06:55:30 <Bynbo7> > fix ($!)
06:55:30 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
06:55:30 <lambdabot>    arising from a use of `...
06:55:47 <Bynbo7> > fix ($!) 1
06:55:52 <lambdabot>   mueval: ExitFailure 1
06:56:15 <lars9> > ((\x -> 1)::(Int->Int)) undefined
06:56:16 <lambdabot>   1
06:56:22 <lars9> > ((\x -> 1)::(Int->Int)) (fix id)
06:56:23 <lambdabot>   1
06:56:37 <lars9> :t (fix id)
06:56:37 <lambdabot> forall a. a
06:56:39 * hackagebot timeplot 0.2.9 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.9 (EugeneKirpichov)
06:58:40 * hackagebot splot 0.1.7 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.7 (EugeneKirpichov)
06:59:09 <Twey> > fix id
06:59:12 <lambdabot>   mueval-core: Time limit exceeded
07:14:43 <Cndy> Good evening
07:27:15 <byorgey> hi Cndy 
07:30:28 <augur> hey unkanon
07:44:25 <pastorn> union is the worst word in C
07:44:31 <pastorn> you never know what you have :(
07:45:09 <dankna> maybe, but the worst GRAMMAR in C is the typecast
07:45:47 <Cndy> all my Kopete chats opening on first desktop :( How can I fix it ?
07:48:41 <pastorn> ah, here we go: http://takuto.info/libnds/arm9/union_sprite_entry.html
07:48:42 <dankna> you might try checking in a channel for KDE, if that is indeed the desktop environment you are using
07:48:48 <dankna> I doubt anyone else here is using Kopete
07:49:06 <dankna> oh, heh, libNDS
07:49:10 <dankna> I used to work with that
07:49:18 <pastorn> dankna: you like that struct?
07:49:25 <dankna> can't say I do
07:49:40 <dankna> doesn't C99 have alignment annotations that you can put in to avoid needing to do that?
07:49:45 <quicksilver> pastorn: that's a work of beautry
07:49:45 <dankna> oh this is for padding not alignment
07:50:02 <pastorn> quicksilver: write a loader/parser for it
07:50:14 <pastorn> maybe that's not even possible
07:50:33 <dankna> I'll see that and go one better - I wrote code that dynamically updated the binary display-list format of the NDS to animate models
07:50:40 <dankna> by putting in new rotation matrices
07:50:48 <dankna> and accounting correctly for the hardware bug
07:50:49 <Jafet> "u16   posY:8"
07:50:52 <Jafet> ...what
07:50:54 <dankna> lol
07:51:27 <pastorn> dankna: what hardware bug? i never got past hello world :/
07:51:36 <dankna> pastorn: it's documented if you have the official docs
07:51:38 <pastorn> i changed the displayed image in the example
07:51:59 <dankna> most people will never need to know about it, so don't worry
07:52:57 <pastorn> dankna: oh! primitive mode GL! how retro!
07:53:04 <pastorn> glBegin(), good times
07:53:35 <dankna> yes, it's not actually as similar to GL as the reverse-engineered group thinks it is
07:53:46 <dankna> they gave it GL-like names but under the hood it's fairly different
07:54:10 <pastorn> yeah
07:56:12 <pastorn> dankna: do you have some link to what you've made for the ds?
07:56:21 <pastorn> pixx? romz? anything?
07:56:40 <dankna> well, I have a link to a blog post I wrote about what it was going to be.  I never finished it.  it would have been a commercial project and might still be someday (but, for the iPhone if that happens), so I can't really give much more than that
07:56:46 <dankna> oh but I can give a pic of the bestiary come to think of it
07:57:01 <pastorn> :)
07:58:03 <dankna> http://dankna.com/cs-thoughts/2008/02/my_game_project.html and http://dankna.com/himitsu/bestiary.jpg
07:58:26 <dankna> note that I wasn't working alone on this - I was doing the code; those lovely models (all of which would have been playable races) were done by people working for me
07:58:27 <pastorn> dankna: did you do all models yourself?
07:58:42 <dankna> ah :) I anticipated your question
07:59:01 <dankna> some of them were slightly too high poly-count for the DS but most of them actually did fit in the poly budget, which I think is pretty impressive
07:59:56 <dankna> I spent probably about $5k on assets of various sorts for it, so it would be nice to redeem that investment by finishing the project someday, heh
08:00:10 <dankna> I do think that was impressively cost-effective for the amount of work that got done
08:01:45 <dankna> this is your cue to compliment me on the concept and stuff :)
08:01:57 <pastorn> oh, sorry
08:02:02 <dankna> no that's okay haha
08:02:09 <pastorn> i'm looking at the slides here: http://lambda-the-ultimate.org/node/3560
08:02:18 <pastorn> linked by "The slides"
08:02:26 <dankna> hmm
08:02:27 <dankna> interesting
08:02:57 <pastorn> dod you should perhaps look at this first: http://lambda-the-ultimate.org/node/1277
08:03:07 <pastorn> (there's a PDF if you don't have M$ office)
08:03:14 <dankna> hmm k
08:03:17 <dankna> I do have M$ haha
08:03:35 <pastorn> he says that haskell is awesome but has "weird syntax"
08:03:43 <pastorn> WHAT DOES HE KNOW!?!?
08:03:44 <dankna> haha
08:03:55 <Ke> "shared cache" trololo
08:03:57 <dankna> well, honestly I could live without the layout rule
08:04:06 <pastorn> the what?
08:04:23 <dankna> the indentation-matters feature
08:04:49 <Twey> Is this the one about game development?
08:04:50 <Twey> Ah, yeah
08:05:04 * Twey doesn't get why people hate on layout
08:05:09 <pastorn> dankna: you can use ';' all over the place if you want to :)
08:05:11 <dankna> well, it is an obstacle when you're learning
08:05:18 <quicksilver> I never found it one.
08:05:23 <dankna> especially because Emacs loves to break your program by indenting things the wrong way
08:05:27 <Twey> I wouldn't think so
08:05:34 <Twey> Not for me…
08:05:34 <quicksilver> But I'm sure it would only take a few weeks to get used to explict {;} everywhere
08:05:51 <quicksilver> if you use the replaced indendation engine, emacs does a pretty good job of offering up the legal options
08:05:55 <pastorn> my only real trouble was getting stuck on if-then-else here and there
08:05:58 <quicksilver> (and it's normally pretty clear which option means which)
08:06:08 <dankna> I don't necessarily want explicit semicolons...  I'd be satisfied with the compiler thinking "maybe this would parse if the indentation were different?  oh look, it does, let's suggest that to the user"
08:06:10 <pastorn> and i still don't know the exact relus for cases and let-in
08:06:43 <Twey> I don't know the exact rules for any of it
08:06:45 <dankna> my other problem was getting confused on let-within-do, none of the tutorials I used (don't remember which they were, I fear) mentioned that it was special syntax
08:06:47 <Twey> It Just Works™
08:06:52 <benmachine> I want an error-correcting parser for haskell
08:06:58 <benmachine> like uu-parsinglib does
08:07:07 <dankna> and on the fact that there is no corresponding where-with-do syntax, which led me to form a habit of never using where at all
08:07:16 <pastorn> benmachine: parsec?
08:07:17 <dankna> error-correcting in the sense of doing beam search?
08:07:20 <dankna> or something more sophisticated?
08:07:23 <pastorn> it can recover quite nicely
08:07:26 <dankna> yeah uu-parsinglib is GLR* I believe
08:07:36 <dankna> you may be in luck if I ever finish Joy
08:07:40 <dankna> since it will have that feature
08:07:44 <quicksilver> benmachine: a really nice error-correcting parser would be type-sensitive (during recovery)
08:07:48 <quicksilver> benmachine: but, that's hard!
08:07:48 <benmachine> is this an alternative to happy
08:07:54 <dankna> Joy?  yes
08:07:56 <benmachine> :P
08:08:00 <dankna> uu-parsinglib is ALSO an alternative to happy
08:08:01 <benmachine> quicksilver: sounds it
08:08:09 <benmachine> oh
08:08:27 <pastorn> what's a GLR parser?
08:08:30 <benmachine> is it?
08:08:50 <benmachine> happy is a parser generator, uu-parsinglib is a parser
08:08:54 <dankna> pastorn: do you know what a LALR(1) parser and a shift-reduce automaton are?
08:09:34 <dankna> pastorn: GLR is an algorithm which replaces the normal engine that runs a shift-reduce automaton with a nondeterministic one
08:09:36 <pastorn> i've never heard of shift-reduce automation, but in hand-in i had to write the BNF for C++ (no templates) and i had a lot of shit-reduces in it
08:09:38 <dankna> it can parse ambiguous grammars
08:10:02 <dankna> shift-reduce automaton is the type of automaton that the LALR(1) and related algorithms generate to actually perform the parses
08:10:04 <benmachine> shit-reducing C++, huh?
08:10:10 <benmachine> let me know how that goes.
08:10:12 <wtcross> hi, i am getting a weird message from ghc
08:10:15 <wtcross> Prelude.read: no parse
08:10:17 <dankna> benmachine: hah :)
08:10:31 <dankna> yeah, so you were using a shift-reduce automaton without knowing it
08:10:32 <Twey> > read "foo" :: Int
08:10:33 <lambdabot>   *Exception: Prelude.read: no parse
08:10:44 <benmachine> wtcross: happens when the 'read' function tries to convert a string into a value but the string doesn't make sense
08:10:45 <pastorn> wtcross: yes, very weird :p
08:10:56 <dankna> shift-reduce conflicts usually point to conceptual flaws in your grammar, and should be eliminated whenever possible
08:10:58 <benmachine> like Twey demonstrated
08:11:02 <dankna> but GLR can actually handle them fine
08:11:12 <pastorn> dankna: like dangling else
08:11:14 <dankna> it returns a set of possible parses in a compact representation that shares common structures
08:11:16 <dankna> yes, exactly
08:11:55 <dankna> whereas the more common deterministic algorithm returns only a single parse and therefore gets its panties in a twist when it is given an automaton containing conflicts
08:12:00 <pastorn> dankna: ok, so how would a GLR parse parse this "if b0 stm0 if b1 stm0 else stm1" ?
08:12:19 <pastorn> what major "operations" would be done on it?
08:12:19 <dankna> it would return both possible parses
08:12:24 <dankna> it's bottom-up
08:12:31 <tshred> hi i just posted as wtcross but my computer screwed up
08:12:35 <tshred> i am getting this error from ghc
08:12:35 <dankna> okay, let me go into detail then
08:12:38 <tshred> Prelude.read: no parse
08:12:43 <tshred> anybody have an idea what this means?
08:12:55 <dankna> okay, so first I have to explain that a deterministic shift-reduce automaton has a stack
08:13:07 <hpc> tshred: it means it couldn't read the string you gave it
08:13:17 <dankna> you "shift" things onto the stack - push it onto its top - and "reduce" things - pop the top items and push the item that represents their combination
08:13:20 <pastorn> dankna: yeah, you push a token at a time, right?
08:13:23 <hpc> if you tried to read "oblargag" as an Int, it would not be able to make a number
08:13:23 <dankna> yeah
08:13:31 <dankna> a nondeterministic one has a "stack" too but it's actually a DAG
08:13:36 <dankna> you can process multiple shifts from the same state
08:13:43 <dankna> I can refer you to papers on this btw if you care
08:13:44 <pastorn> ehm... wut?
08:13:45 <pastorn> DAG?
08:13:51 <dankna> directed acyclic graph
08:14:12 <dankna> graph without loops
08:14:13 <pastorn> dankna: is there some paper/text i could read to get better introduced
08:14:16 <dankna> yes
08:14:22 <pastorn> feels like we're spamming the channel a bit :D
08:14:26 <dankna> I found the best introduction to be the paper that invented the concept, as it has nice diagrams
08:14:28 <tshred> hpc: well that is confusing because i have changed nothing and it randomly stopped working
08:14:29 <dankna> well we could go to -blah if you prefer
08:14:47 <pastorn> dankna: no, it's not unrelated - it's just much
08:14:54 <hpc> tshred: changed nothing in code, or nothing in the input?
08:14:57 <dankna> I'm happy to talk about this, I think it's important to educate Haskellers on real state-of-the-art parsing stuff
08:15:05 <pastorn> though my IRC window only shows 10 lines of text :D
08:15:06 <hpc> because it's the input that is failing you, it seems
08:15:06 <dankna> well, let me dig up the citation/link
08:15:11 <dankna> oh haha
08:15:20 <benmachine> there's #haskell-in-depth
08:15:27 <dankna> that's a point
08:15:31 <tshred> hpc: the inputs are well formed
08:15:35 <pastorn> benmachine: bah! that's only for general abstract nonsense
08:15:56 <benmachine> u
08:15:57 <tshred> hpc: it must be something with the input i will just remake it, thanks for your help
08:15:59 <pastorn> i'm thinking that #haskell-in-depth is just #idlerpg in disguise
08:16:14 <dankna> M.?Tomita. An efficient augmented-context-free parsing algorithm. Comput. Linguist., 13(1-2):31?46, 1987.
08:16:19 <dankna> and one sec for the link
08:16:30 <pastorn> 87? not exactly new then :)
08:16:32 <dankna> oh, there is no link to pdf, because it's commercial
08:16:51 <dankna> yeah, but it took a surprisingly long time to be generally adopted - it was originally seen as useful only for natural-language processing
08:17:03 <monochrom> there may be a commercial pdf and it may be smuggled out. :)
08:17:10 <pastorn> dankna: i could probably get it through my school with SOCKS / ssh -X
08:17:13 <dankna> indeed, you'll still see people talking about the Earley algorithm, which does a similar thing but imo in an inferior way
08:17:27 <dankna> pastorn: okay, let me try to dig up a link
08:17:33 <dankna> I only have the pdf itself in my database of papers and not the actual link it came from
08:20:26 <monochrom> eh? google finds http://acl.ldc.upenn.edu/J/J87/J87-1004.pdf :)
08:21:03 * hackagebot usb 0.6.0.5 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.5 (BasVanDijk)
08:21:06 <dankna> oh
08:21:10 <dankna> well that saves some trouble
08:21:43 <dankna> anyway this is an intro to GLR which assumes some familiarity with the deterministic algorithm
08:21:46 <dankna> but I think you can follow it
08:22:12 <dankna> the important thing to remember is that this doesn't talk about how you generate the "parse table" (which is a representation of the automaton), only about how you use it
08:22:34 <dankna> as it's agnostic to which of the several algorithms (LALR(1), SLR, LR(0), and so on) you use to do that
08:29:17 <triyo> is this 'execWriterT (countEntries "..") >>= mapM_ (\(d,_) -> putStrLn d)' the best way to express if countEntries function returns 'FilePath -> WriterT [(FilePath, Int)] IO ()'
08:29:46 <triyo> I tried 'mapM_ (\(d,_) -> putStrLn d) `liftM` (execWriterT (countEntries ".."))' and the produces no output
08:29:53 <dankna> mapM_ means no output
08:29:54 <triyo> *the=this
08:30:00 <dankna> er, sorry, means no return
08:30:01 <dankna> never mind me
08:30:11 <benmachine> putStrLn is supposed to output :P
08:30:17 <triyo> right
08:30:23 <dankna> right, I didn't see that for a moment
08:30:41 <benmachine> triyo: I'm a little surprised that the one that doesn't work compiles at all
08:30:48 <triyo> so I though mapM_ (\(d,_) -> putStrLn d)  will get lifted to the IO world on the right hand side
08:30:50 <benmachine> but >>= looks more right there yes
08:31:03 <monochrom> @type execWriterT
08:31:04 <lambdabot> forall w (m :: * -> *) a. (Monad m) => WriterT w m a -> m w
08:31:42 <triyo> benmachine: ok (>>=) is simple enough. I'm just trying to learn why the lifting wouldn't work.
08:31:46 <benmachine> @type mapM_ (\(d,_) -> putStrLn d) `liftM` (execWriterT (?countEntries ".."))
08:31:46 <lambdabot> forall t (m :: * -> *) a. (?countEntries::[Char] -> WriterT [(String, t)] m a, Monad m) => m (IO ())
08:31:57 <benmachine> hmmm
08:32:14 <benmachine> guess that makes sense
08:32:47 <triyo> so it compiles but I get no output. :)
08:32:56 <triyo> on the liftM ver
08:32:59 <benmachine> yes
08:33:07 <benmachine> you're generating an IO (IO ()) I guess
08:33:14 <triyo> oh haha
08:33:15 <triyo> oops
08:33:23 <triyo> now I see what you mean
08:33:34 <benmachine> :t join
08:33:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:33:38 <benmachine> you can use that
08:33:39 <triyo> I dont need the lift, I need to peal of the IO
08:33:39 <benmachine> but
08:33:46 <triyo> hence the >>=
08:33:48 <benmachine> join (liftM f b) == f =<< b
08:34:26 <benmachine> so you might as well just use =<< or >>= directly
08:35:00 <benmachine> :t liftM putStrLn getLine
08:35:01 <lambdabot> IO (IO ())
08:35:02 <triyo> right, ok I get it now, thanks benmachine
08:35:30 <hpc> :t liftM
08:35:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:35:55 <hpc> huh
08:37:12 <benmachine> hpc: huh what
08:38:55 <triyo> that seems simple enough to me. Lift normal Function to the Monad m "world" (context) and then apply it in that context. Right?
08:39:35 <monochrom> liftM is like fmap
08:39:51 <triyo> exactly for Functors right?
08:40:18 <kmc> yes, morally every Monad is a Functor and liftM = fmap
08:40:29 <kmc> i say "morally" because the stdlib is not actually built this way, for historical reasons
08:40:31 <merijn> :t fmap
08:40:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:40:39 <merijn> :t liftM
08:40:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:40:52 <kmc> and I wouldn't think of "IO" as a "world"
08:41:02 <triyo> context?
08:41:09 <kmc> i'd say that "IO T" represents a "recipe" for how you could do some IO and get a result of type T
08:41:16 <kmc> it's not much like a T within a container
08:41:31 <monochrom> you take "world" too seriously
08:41:40 <kmc> because the T doesn't exist yet -- only after you perform the action -- and you might perform it twice and get different results
08:41:50 <merijn> The only reason for liftM to exist then is to compensate for evildoers who do not make their monad an instance of Functor?
08:42:10 <benmachine> merijn: it's also convenient in that you can define a monad instance and then go instance Functor where fmap = lifTM
08:42:44 <triyo> is it because of historic reasons that Monad does't require to be a Functor?
08:42:44 <hpc> ^
08:42:46 <merijn> benmachine: I don't see why you could not have that convenience the other way around?
08:43:00 <merijn> instance Monad where liftM = fmap
08:43:08 <hpc> you can also do applicative with pure=return (<*>)=liftM2
08:43:34 <hpc> merijn: liftM isn't a useful function for building a monad instance with
08:43:43 <benmachine> merijn: erm, there's no reason for liftM to be a method of Monad
08:44:17 <merijn> oh, yeah, duh
08:45:27 <kmc> merijn, and for consistency
08:45:51 <kmc> hpc, (<*>) = ap
08:45:56 <gyusik> hi
08:46:00 <gyusik> haskel??
08:46:06 <gyusik> hey 
08:46:07 <gyusik> there
08:46:27 <hpc> kmc: er, that
08:46:31 * hpc <.<
08:46:32 <merijn> liftM f a = a >>= return . f $ a, right?
08:46:40 <hpc> @src liftM
08:46:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:47:04 <merijn> Oh, right.
08:47:09 <hpc> liftM f a = a >>= \x -> return . f $ x
08:47:19 <merijn> The same I guess, but needlessly complex in my case
08:53:53 <benmachine> merijn: nope, you didn't want the $ a at the end
08:54:06 <benmachine> liftM f m = m >>= return . f
08:56:30 <merijn> Oh, duh
08:57:02 <lars9> too late and too cold to learn haskell now, good night~
08:57:06 <tromp> 0........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:07 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:09 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:10 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:12 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:13 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:15 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:16 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:18 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:19 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:21 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:22 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:24 <tromp> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
08:57:25 <tromp> .............................................................................................................................................................................................................................................................................
08:57:36 <zaphar_ps> whoah
08:57:38 <magicman> Fuck yeah, punctuation.
08:57:39 <hpc> ...
08:57:51 <kmc> …
08:57:59 <tromp> oops, shldnt rest my tablet on my keyboard:(
08:58:01 <Ke> I can see a point there
08:58:01 <kmc> tromp, ?
08:58:05 <tromp> sorry
08:58:07 <kmc> :D
08:58:15 * hackagebot timeplot 0.2.10 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.10 (EugeneKirpichov)
08:58:16 <hpc> haha
08:58:53 <merijn> For some odd reason this (http://tartley.com/?p=1267) explanation of git reminds me of #haskell :p
08:59:31 <merijn> "Git, complicated? Of course not! Commits map to isomorphic contours in source-code phase space."
08:59:40 <kmc> it reminds me of darcs actually ;)
09:00:03 <magicman> I don't get it... where do the burritos come in?
09:00:23 <dankna> A burrito is like a bad meat-aphor.
09:00:35 <merijn> Burritos are out, enchiladas are the new metaphor
09:00:36 <quicksilver> dankna: what about a veggie burrito?
09:00:50 <dankna> true
09:01:10 <dankna> and we've failed entirely to account for pitas
09:03:48 <kmc> i still can't tell if that git thing is a joke or not
09:04:39 <benmachine> it sounds a bit like a joke
09:04:45 <benmachine> isomorphic to what?
09:05:26 <benmachine> oh
09:05:28 * benmachine shrug
09:05:55 <zaphar_ps> the consensus here at work from two former topologists is it must be a  joke
09:06:09 <dankna> haha okay
09:06:18 <dankna> but it took two topologists to determine that? :)
09:06:27 <zaphar_ps> :-p
09:06:32 <dankna> I can't tell if that maekes it a bad joke or a very good one
09:06:37 <zaphar_ps> not being a topologist I have no idea
09:06:52 <zaphar_ps> no both of them sort of independently said it's BS
09:06:58 <merijn> dankna: What did you expect, they have a hard enough time telling the difference between their coffee cup and their donut
09:07:03 <dankna> fair, haha
09:08:00 <unkanon> they solve that by using cups with two wings
09:08:27 <dankna> hey, they're not so different from us
09:08:33 <dankna> we can't tell the difference between Halloween and Christmas
09:09:08 <dankna> ("Why is that, dankna?")
09:09:12 <dankna> because Oct 31 = Dec 25
09:09:17 * hackagebot mime-directory 0.5.1 - A library for parsing/printing the text/directory mime type.  http://hackage.haskell.org/package/mime-directory-0.5.1 (MathieuBoespflug)
09:09:57 <roconnor> it seems to me that the author of the git blog post was trying to make fun of the git manual
09:10:18 <dankna> I certainly find darcs more accessible
09:10:20 <roconnor> maybe
09:10:24 <kmc> > 0o31 == 25
09:10:25 <lambdabot>   True
09:10:25 <dankna> I don't understand what "staging" a git commit is, for example
09:10:33 <dankna> kmc: yeah that's the best part, it really does
09:10:44 <benmachine> the thing that annoyed me about darcs is I didn't see an obvious way to refer to patches
09:10:47 <kmc> dankna, you can learn though
09:10:55 <dankna> kmc: no doubt I can
09:11:05 <benmachine> there's like twenty ways but none of them are obvious
09:11:05 <kmc> the thing that annoys me most about darcs is that it chokes and dies on large repos
09:11:18 <dankna> but I like darcs and have no strong incentive to switch; nobody has really convinced me git has any advantages
09:11:28 <dankna> I also like the darcs development community
09:11:42 <roconnor> dankna: anything with 3-way merge, such as git, is inherently broken
09:11:48 <dankna> roconnor: do tell!
09:11:51 <kmc> perhaps git has no specific advantage over darcs, but it's still a good tool, and massively more popular
09:11:54 <dankna> what would it even use 3-way merge for?
09:11:57 <unkanon> I've never tried darcs, I really should, all I know is git
09:12:00 <benmachine> merging, three ways
09:12:05 <srobertson> nested 'where' or 'let' clauses: good or evil, and why?
09:12:11 <dankna> yes, but why would you want that
09:12:19 <roconnor> dankna: merging code back into branches
09:12:23 <benmachine> srobertson: I wouldn't say evil, but perhaps a little ugly
09:12:24 <kmc> so if you want to contribute to open source, or you get a job with a company that uses git, you should learn git
09:12:26 <dankna> srobertson: merely tools; it's mortal users who make things good or evil.  they have appropriate uses.
09:12:29 <dankna> oh hmmmmmm okay
09:12:42 <roconnor> dankna: http://web.archive.org/web/20070603113858/zooko.com/badmerge/simple.html
09:13:27 <duckinator> srobertson: i'm kinda new, but from what i've seen i think you can usually avoid them, but they don't seem inherently evil if not taken to a disgusting extreme (like 50 nested where/let clauses :P)
09:13:40 <zaphar_ps> darcs has a better UI than git but git is way faster and the cheap branches are nice
09:13:42 <roconnor> dankna: in any sane system, if you merge changes from branchA to branchB, and then further changes from branchA into branchB, the result should be the same as merging both changes from branchA into branchB all at once
09:13:54 <roconnor> dankna: git et. al. do not have this sane property
09:14:05 <roconnor> dankna: darcs and a few others (codeville?) do.
09:14:31 <sm> kmc: re choking an dying on large repos, what's an example ?
09:15:07 * unkanon is excited to see people using "re" insteadof the ugly "w.r.t."  :))
09:15:10 <srobertson> hmm. haskell's type system is so strict, but its coding style is so loose. almost the opposite of python.
09:15:25 * sm bows
09:15:42 <srobertson> benmachine, dankna, duckinator: thanks, i will go forth and use style pragmatically
09:15:42 <dankna> right hmmm
09:15:43 <dankna> gotcha
09:15:47 <dankna> well darcs has commutative patches
09:15:50 <dankna> I imagine that's exactly why
09:16:07 <benmachine> srobertson: if you want strict coding styles, there are some
09:16:12 <benmachine> but they're not standard
09:16:14 <benmachine> don't use tabs :P
09:16:21 <sm> benmachine: re referring to patches, isn't -p "patch name (or regexp)" for selecting the most recent matching patch simple enough ?
09:16:24 <unkanon> what's a coding style?
09:16:26 <zaphar_ps> what benmachine said
09:16:59 <benmachine> sm: I dunno I never liked it as much as numbers or hashes
09:17:05 <benmachine> it doesn't feel obviously uniqu
09:17:06 <benmachine> e
09:17:56 <duckinator> what are some good haskell editors for me to mess with? gedit has mental disorders when it comes to indenting haskell
09:18:19 <zaphar_ps> duckinator: emacs,vim take your pick
09:18:33 <sm> well, it isn't unique - which indeed feels different, but is not a problem in typical practice. You've got to use the hash for a unique match
09:18:36 <zaphar_ps> of if you are feeling adventurous you can try to compile and use Yi
09:19:20 <duckinator> i'm bored, i'll try yi ;)
09:20:41 <zaphar_ps> duckinator: it works but if you run it for too long it starts to get bogged down. If I can ever compile it with profiling support I plan to try to tackle that
09:20:57 <zaphar_ps> but compiling something for profiling in cabal is not trivial it seems
09:21:04 <duckinator> zaphar_ps: bogged down how? RAM usage?
09:21:28 <zaphar_ps> it just gets sluggish and cpu useage ramps up
09:21:31 <merijn> zaphar_ps: I saw someone post a one line cabal config to compile everything with profiling, but forgot how
09:22:24 <zaphar_ps> duckinator: I haven't investigated real far yet myself but you can see some discussion of it on the mailing list
09:22:43 <duckinator> wow...that's a lot of deps... (it's in aur - ArchLinux's User Repository, PKGBUILD to compile it) ._.
09:22:50 <duckinator> 45 deps, to be exact :P
09:23:04 <zaphar_ps> how recent is the ArchLinuxes copy?
09:24:09 <duckinator> hang on, hoc doesn't have a PKGBUILD so it hangs on that..will have to look on http://aur.archlinux.org >.>
09:25:10 <duckinator> zaphar_ps: 0.6.2.4
09:25:49 <duckinator> zaphar_ps: was apparently updated to latest in august
09:27:15 <sm> benmachine: fyi hash matching is done with --match 'hash HASH' where HASH is the full hash you see with changes --xml
09:27:25 <duckinator> zaphar_ps: apparently hoc is apparently not in aur, and something glitched enough that it gave me a blank PKGBUILD :| that's odd. know where i can get hoc, by chance?
09:28:11 <duckinator> or....haskell to obj-c binding?...why would it need that on linux? xD
09:28:21 <benmachine> sm: xml :O
09:28:31 * benmachine dislike
09:29:20 <sm> you dislike that darcs has an option to display patches in a machine-readable xml format ? :) Well not to worry, that might be changing in future
09:29:38 <elliott>     The first argument of `Functor' should have kind `* -> *',
09:29:38 <elliott>     but `Blah' has kind `(* -> *) -> *'
09:29:42 <elliott> any solution for this?
09:31:50 <roconnor> git developers will try to rationalize their incorrect behaviour by saying that it almost always works and it is better to be wrong as long as you are really fast when you are wrong.
09:33:04 <duckinator> roconnor: what "incorrect behaviour"?
09:33:10 <kelvie_> Is it normal for System.Cmd.system to truncate unicode Strings in unix?
09:33:22 <kelvie_> Or is that a bug I should report?
09:36:49 <sm> kelvie_: can you paste an example ?
09:40:49 <hpc> elliott: it's not possible without reworking your data type
09:41:01 <hpc> for example, the (* -> *) of Blah could be a monad
09:41:11 <hpc> how do you write fmap to transform something from one monad to the other?
09:41:12 <elliott> hpc: right. in this case Blah is data Blah f = Blah (f (Blah f)), i.e. what is usually called mu
09:41:15 <elliott> so that would be a bit difficult
09:41:18 <kelvie_> sm: in a sec
09:41:26 <elliott> admittedly, it's arguable whether or not that is a functor :P
09:41:50 <hpc> not just arguable; it isn't :P
09:42:03 <elliott> hpc: pah!
09:43:04 <kmc> sm, ghc
09:43:16 <teki> question: how do i set the -caf-all flags when compiling for profiling in GHC
09:43:27 <kmc> ghc --make foo.hs -caf-all
09:43:38 <teki> so i don't need the -prof flag then?
09:43:43 <kmc> you need that too
09:43:47 <teki> alright
09:43:50 <teki> i have been running
09:43:57 <kmc> maybe -auto-all too
09:43:57 <teki> ghc --make -prof -caf-all ...
09:44:06 <kmc> sm, "darcs annotate" on a file in the ghc repo will spin for a few minutes then die with a stack overflow
09:44:14 <teki> and it gives the same thing as just ghc --make -prof upon execution with the RTS flags
09:44:22 <kmc> "git blame" on a comparably sized repo (Linux) will return in a fraction of a second
09:44:28 <kmc> maybe you don't have any cafs then
09:44:40 <roconnor> duckinator: http://web.archive.org/web/20070603113858/zooko.com/badmerge/simple.html
09:44:55 <sm> kmc: I see, thanks. Agreed that annotate is weak in darcs
09:45:26 <sm> which is not quite the same as "darcs chokes on large repos", but annoying I'll grant you
09:46:51 <duckinator> roconnor: huh, i've done merges of that sort all the time with git without issue. unsure of if there was duped code of any sort, since i try to avoid that...
09:47:11 <kmc> sm, my experience with darcs is extremely limited; this is one of the few things i've tried to do, and it completely failed
09:47:22 <kmc> i'll grant that if i used darcs more, i might come to have a more nuanced view
09:47:58 <teki> kmc: let's say that i'm profiling and im using a bunch of functions in Main that are imported from a module
09:48:10 <teki> kmc: do i just add SCCs in the module in order to see profiling output?
09:49:37 <kmc> you'll want to build that module with profiling too
09:49:50 <timophey_> Sorry, i have an error (Irrefutable pattern failed for pattern (Data.Either.Right a)) whlie compiling curl exmple http://blog.tupil.com/a-small-mashup-of-upcoming-and-lastfm-in-haskell/ ... do you know how to fix it?
09:49:57 <kmc> remember that ghc --make doesn't keep track of compilation flags, so if in doubt also use -fforce-recomp
09:50:20 <timophey_> line 24
09:50:24 <kmc> ghc --make -fforce-recomp -prof -auto-all -caf-all
09:50:49 <kmc> timophey_, is that really an error while compiling?
09:50:55 <timophey_> Yes(
09:51:01 <byorgey> timophey_: that means the call to parseCSV is failing
09:51:04 <timophey_> timophey@timophey-laptop:~/MODULES$ runhaskell last.hs timopheym
09:51:05 <timophey_> last.hs: last.hs:24:6-45: Irrefutable pattern failed for pattern (Data.Either.Right a)
09:51:14 <kmc> that's a run-time error
09:51:17 <kmc> "runhaskell"
09:51:26 <kmc> it means that you're failing to parse the CSV file
09:51:33 <timophey_> oh... sorry. i'm newboy
09:51:44 <jmcarthur> darcs annotate is one of the things they are just now working on to speed up
09:52:26 <mao> hi im newbie.. and got a haskell favor.. could any help me out?
09:52:36 <byorgey> timophey_: try inserting the line 'print text' (without the quotes) right before that line with parseCSV, to see if the webpage is being fetched correctly
09:53:03 <timophey_> Thnx! I will
09:53:26 <byorgey> mao: probably, but no one knows whether they can help until you ask your question.
09:54:36 <byorgey> timophey_: also, note that blog post is from 2008 so it's possible some APIs have changed since then (?)
09:54:40 <byorgey> who knows
09:55:14 <timophey_> 28-byorgey-: it's fetch's good http://hpaste.org/42361/lastfm
09:56:22 <byorgey> timophey_: ok, so now see what the result of the parseCSV call is, by sticking in 'print (parseCSV (url username) text)'
09:56:47 <byorgey> the parseCSV call is failing for some reason, and it probably gives you an error message
10:00:33 <teki> kmc: thanks, got it to work!
10:01:58 <timophey_> byorgey: strange... it prints Left "http://ws.audioscrobbler.com/1.0/user/timopheym/topartists.txt" (line 39, column 23):
10:01:58 <timophey_> unexpected "\""
10:01:58 <timophey_> expecting "," or end of input
10:02:37 <bitreader> Hi, could someone tell me a program written in haskell (or almost entirely), that has a nice gui.
10:02:38 <byorgey> right, so that is the parse error it is generating
10:03:05 <absentia> do games count?
10:03:17 <bitreader> absentia, Sure.
10:04:47 <byorgey> timophey_: so either the downloaded CSV is corrupt, or there is a bug in the CSV parser
10:05:25 <byorgey> timophey_: actually it looks like it may be choking on some characters which are in an encoding it is not expecting
10:05:37 <byorgey> I don't really know what the solution would be.
10:05:43 <absentia> is the talk on a cereal box?
10:06:03 <timophey_> i try for another last.fm user...
10:06:06 <hpc> bitreader: xmonad, perhaps? :P
10:12:40 <kafee> why do I get "Irrefutable pattern failed for pattern" for let [(move, _ )] = reads m :: [([Int],String)] ?
10:13:10 <c_wraith> kafee, there were multiple parses returned
10:13:13 <Twey> kafee: Either you got no parses or you got more than one parse
10:13:18 <c_wraith> or none, right
10:13:37 <c_wraith> basically, your pattern claims there will be exactly 1 parse.
10:14:22 <Twey> > let [(move, _)] = [("clearly", "not one parse"), ("or rather", "not exactly one")] in move
10:14:22 <kafee> but an irrefutable patter is not said to never fail?
10:14:22 <lambdabot>   "*Exception: <interactive>:1:137-214: Irrefutable pattern failed for patter...
10:15:00 <Twey> kafee: An irrefutable pattern is one that is not allowed to fail, not one that can't possibly fail.  If you had other options it would be refutable: it could fail without error, and just fall through to the next pattern.
10:15:11 <c_wraith> kafee, an irrefutable pattern is one that the programmer claims won't fail.  If the programmer was wrong, it's a runtime error.
10:15:31 <Twey> > let ~(a, _) = 5 in a
10:15:31 <lambdabot>   5
10:15:37 <Twey> *blink* *blink*
10:15:39 <hpc> kafee: doing "let *pattern* = *foo*" is an irrefutable pattern; doing "let f *pattern* = *foo*" isn't
10:16:00 <Twey> > let ~(_, a) = 5 in a
10:16:01 <lambdabot>   5
10:16:08 <Twey> > let ~(a, b) = 5 in a
10:16:09 <lambdabot>   5
10:16:13 <hpc> if you do the latter, you get a pattern matching fall-through
10:16:15 * Twey thought that was supposed to fail.
10:16:32 <hpc> and you can write "let f _ = *bar*" to catch failed parses
10:16:39 <sipa> Twey: Num a => (a,a) is an instance of Num in lambdabot
10:16:44 <Twey> Oh.
10:16:47 <Twey> -.-
10:16:51 <sipa> @instances Num
10:16:51 <lambdabot> Double, Float, Int, Integer
10:16:55 <sipa> bleh
10:17:02 <Twey> > let ~[a, _] = 5 in a
10:17:02 <lambdabot>   No instance for (GHC.Num.Num [a])
10:17:02 <lambdabot>    arising from a use of `e_15' at <inter...
10:17:04 <hpc> > let ~(a,b) = Nothing in a
10:17:04 <lambdabot>   Couldn't match expected type `(t, t1)'
10:17:04 <lambdabot>         against inferred type `Data....
10:17:10 <Twey> > let ~[a, _] = (5 :: Int) in a
10:17:11 <lambdabot>   Couldn't match expected type `[t]'
10:17:11 <lambdabot>         against inferred type `GHC.Types...
10:17:40 <colah> I've been using cabal to install libraries, but I can't seem to import them. I'm sure it's some trivial thing I need to do, but I've just started haskell and can't figure it out.
10:17:43 <Twey> > let ~[a, _] = "foo" in a
10:17:44 <lambdabot>   *Exception: <interactive>:1:137-151: Irrefutable pattern failed for pattern...
10:17:47 <Twey> *There* we go.
10:17:52 <Twey> > let ~[a, _] = "foo" in 5
10:17:53 <lambdabot>   5
10:18:27 <int-e> > let 1 = 2 in 1
10:18:28 <lambdabot>   1
10:18:29 <Saizan> colah: what are you trying and what error are you getting?
10:18:37 <colah> For example, I cabal install gamma, but then import gamma doesn't work.
10:18:40 <dom96> :O, what does `~` do?
10:19:01 <colah> Prelude> import gamma
10:19:01 <colah> syntax:  :module [+/-] [*]M1 ... [*]Mn
10:19:08 <kafee> ~ is lazy pattern
10:19:09 <Saizan> colah: gamma is the package name, the modules it export have different names
10:19:32 * colah slaps head.
10:19:32 <int-e> dom96: turns the pattern match into one that always succeeds (is irrefutable) and is only checked when one of the values bound by it is actually used.
10:19:36 <colah> Thanks.
10:19:40 <Saizan> colah: http://hackage.haskell.org/package/gamma <- the ones that have links under Modules
10:19:53 <int-e> dom96: in 'let' it's superfluous; let behaves that way in any case.
10:20:09 <dom96> int-e: I see. Interesting. Thanks for the explanation.
10:20:14 <int-e> > fix (\ ~(a, b) -> (b, 1))
10:20:14 <lambdabot>   (1,1)
10:20:18 <int-e> > fix (\ (a, b) -> (b, 1))
10:20:21 <lambdabot>   mueval-core: Time limit exceeded
10:21:16 <magicman> That's... pretty sweet :o
10:21:23 <int-e> > let (~(a,b), c) = ((b, 1), c) in (a,b,c)
10:21:27 <lambdabot>   mueval-core: Time limit exceeded
10:21:40 <int-e> hah.
10:21:45 <int-e> > let (~(a,b), c) = ((b, 1), a) in (a,b,c)
10:21:45 <lambdabot>   (1,1,1)
10:21:50 <int-e> > let ((a,b), c) = ((b, 1), a) in (a,b,c)
10:21:50 <lambdabot>   (1,1,1)
10:22:02 <int-e> never mind.
10:26:32 <timophey_> byorgey: yahooapis.com does not work. Thanx you!! 
10:32:47 * hackagebot zmidi-core 0.2.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.2.0 (StephenTetley)
10:33:43 <Joseph__> Hey guy's I'm new to haskell.
10:33:55 <kmc> welcome :)
10:34:09 <pimeys> me too :)
10:34:14 <timophey_> Hi Joseph__ im't too)
10:34:15 <pimeys> I hope I learn the Monads soon
10:34:24 <pimeys> want to dive into web development with haskell
10:34:37 <djahandarie> pimeys, where did you learn that Monads are anything special?
10:34:44 <merijn> Monads aren't as hard or special as everyone makes them out to be
10:34:48 <pimeys> djahandarie: side effects
10:34:55 <Joseph__> http://learnyouahaskell.com/ I'm learning there
10:34:56 <pimeys> I may need those with web design
10:35:04 <merijn> pimeys: Monads are not just for side effects
10:35:16 <djahandarie> pimeys, follow the guide that Joseph__ just linked, it's a good one
10:35:16 <c_wraith> pimeys, for side effects, use IO.  ignore that it's a monad.  That's not as important as the fact that it's IO
10:35:18 <benmachine> pimeys: IO is for side effects, and you can do IO without knowing about monads
10:35:26 <pimeys> djahandarie: been reading that for a while
10:35:46 <djahandarie> It shows that Monads are really nothing special
10:35:47 <merijn> Learn You a Haskell rocks, once you're done with that I recommend Real World Haskell
10:36:23 <Joseph__> Alright
10:36:26 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO <-- no monads here
10:36:36 <pimeys> been coding for a while with different languages and Haskell seems to be the one I should use
10:36:52 <kmc> "monad" is the name of a generic API which is used by lots of stuff, including IO, but it's not "about IO" and you don't need to understand the generic API to do IO
10:37:08 <monochrom> there is nothing to understand anyway
10:37:08 <pimeys> so can you make side effects without monads?
10:37:12 <djahandarie> As an aside... I _still_ really wish the monad typeclass wasn't the only way to interact with IO... would just like some primitive functions like bindIO, returnIO, etc
10:37:18 <kmc> pimeys, technically there are no side effects
10:37:51 <kmc> values of type "IO T" are just descriptions of effects you *could* perform
10:37:51 <Twey> djahandarie: Why?
10:37:58 <kmc> no effect occurs until you pass that value off to the runtime system
10:38:01 <kmc> probably by naming it "main"
10:38:08 <Twey> djahandarie: That's just a renaming
10:38:14 <Joseph__> What is haskell used for?
10:38:21 <kmc> Joseph__, writing computer programs
10:38:23 <c_wraith> programming
10:38:26 <timophey_> ))
10:38:33 <Martty> feeling smuggly superior
10:38:41 <sm> thinking about computer programs
10:38:42 <djahandarie> Twey, because it is confusing.
10:38:43 <kmc> "Monad" is an API that's useful for manipulating many different data types.  one of those data types is "descriptions of effects"
10:38:43 <Twey> Proofs
10:38:44 <Twey> ;)
10:38:56 <sm> getting hired
10:39:04 <kmc> but another one is "lists"
10:39:07 <Twey> djahandarie: But it would be less confusing if we gave everything two names?
10:39:11 <merijn> I second "feeling smugly superior" :p
10:39:16 <kmc> or "nullable values" or "logic programs"
10:39:25 <kmc> or "parsers"
10:39:27 <kmc> so it's really not about effects in general
10:39:34 <djahandarie> Twey, not "everything". Just IO.
10:39:44 <Martty> well thats all the use its been for me.. excluding the whole "helps you think better about your programs" in any language
10:39:51 <timophey_> Guys, i think about writing module for working with SOAP, becose i didn't find one. is anybody new some think about it?
10:39:57 <sm> writing programs with fewer runtime errors than other languages
10:39:58 <monochrom> kmc: So modify pimeys's question as: can you make the runtime system do side effects without monads in your source code?
10:40:12 <djahandarie> Twey, the main problem being that there are primitives in the typeclass
10:40:23 <Twey> timophey_: http://hackage.haskell.org/package/shoap
10:40:26 <djahandarie> Twey, contrasted to say, the Maybe monad where you could write the Monad typeclass yourself
10:40:30 <merijn> monochrom: Well sure, that's how it used to work before monads, right?
10:40:31 <rajeshsr> hi all
10:40:32 <timophey_> I sow
10:40:41 <timophey_> it's VERY simple
10:40:42 * monochrom is really tired of this artificial distinction
10:40:43 <kmc> not portably, but with djahandarie's proposal or by importing GHC internals, sure
10:40:56 <timophey_> There no functions for WSDL for exmple
10:42:08 <monochrom> The point is that's what the beginner means and you are supposed to be experienced enough to know it.
10:42:34 <pimeys> haskell makes me think better
10:42:49 <djahandarie> When I'm required to write something in another language I usually do it in Haskell first
10:42:50 <jmcarthur> if you ignore that (>>=) and return have anything to do with Monad you definitely can do IO without monads
10:43:06 <rajeshsr> This is not directly relevant to Haskell, but you guys can give a good insight into it! I was just reading through Lambda calculus. In going through that, i came across this interesting idea. Does it matter at all to have the notion of a function being applied on a variable and results in some function? Why can't it be just regarded as pure syntactical structure, that defines some entities? Does the semantics that there is a function application add any
10:43:06 <merijn> I'm looking for dupChan but instead of items inserted in either Chan's appearing in both I just want items appearing in the original chan to appear in the duplicate, but not vice versa. Does this exist or do I need to implement my own based on the source of Data.Concurrent.Chan?
10:43:06 <rajeshsr> at all?
10:43:07 <jmcarthur> in GHC you could also import bindIO and returnIO and use those instead
10:43:15 <rajeshsr> Hope I have made myself clear!
10:43:26 <djahandarie> jmcarthur, I'd like for it to happen without needing to import GHC internals
10:43:49 <jmcarthur> just define it from the "Monad" functions then
10:43:53 <hpc> wasn't IO applicative before monad was made standard?
10:43:55 <benmachine> rajeshsr: some of your first message mught have been cut off?
10:43:58 <benmachine> Does the semantics that there is a function application  add any
10:44:11 <djahandarie> jmcarthur, in terms of teaching someone, that is utterly worthless
10:44:12 <jmcarthur> returnIO = return :: a -> IO a; bindIO = (>>=) :: IO a -> (a -> IO b) -> IO b
10:44:17 <benmachine> hpc: applicative was discovered relatively recently
10:44:20 <jmcarthur> djahandarie: i know, that's kind of my implicit point
10:44:31 <rajeshsr> benmachine: > Does the semantics that there is a function application add any value at all?
10:44:33 <djahandarie> jmcarthur, I want to say "returnIO is magic", not "return for IO a is magic"
10:44:35 <jmcarthur> djahandarie: it's what i would tell a beginner too
10:45:02 <benmachine> rajeshsr: oh, only "value" got cut out
10:45:05 <jmcarthur> it's just a matter of learning a simple API made up of only two functions
10:45:27 <benmachine> rajeshsr: what's the point of lambdas without applying them?
10:45:34 <merijn> rajeshsr: You mean "what is the difference between "(\x.x) y" and "y"?
10:46:29 <monochrom> the point of having lambdas without applying them is to know when to stop evaluation and declare "I have a normal form now".
10:46:29 <rajeshsr> it is just a syntactical structure that defines an abstract entity called "identity" function. It is just an accident that the structure can be regarded as modeling an identity function.
10:47:17 <benmachine> rajeshsr: what's the syntax for?
10:47:41 <benmachine> rajeshsr: I mean, what is the purpose or interest in λx.x
10:47:43 <Shrimpson> hello everyone. im having problems using the "putStrLn :: String -> IO ()" command. i want him to do 12 lists but each one in its own row (hes supposed to calculate the first few rows of pascal's triangle)
10:47:55 <Shrimpson> how exactly does it work or how do you implement it?
10:48:17 <monochrom> mapM_ putStrLn the_twelve_monkeys
10:48:33 <benmachine> that assumes the_twelve_monkeys :: [String]
10:48:48 <rajeshsr> benmachine: Just a syntactical reprsentation chosen to represent some abstract entity. It doesn't matter if the semantics of it is interpreted as an identity function or any other function. 
10:48:49 <benmachine> Shrimpson: where are you failing?
10:49:08 <Shrimpson> benmachine: ill upload my code in a moment. the given error states:
10:49:11 <benmachine> rajeshsr: but the abstract entity is only interesting in terms of how it interacts with other things
10:49:25 <rajeshsr> My point is lambdas are lingusitic structures modeling abstract ideas. And the motivation that, they define a function application can be irrelevant, like in Peano's arithmetics
10:49:26 <Shrimpson> benmachine: the type signature for putstrln lacks an accompanying binding (you cannot give a type signature for an imported value)
10:49:49 <benmachine> Shrimpson: indeed, you cannot give a type signature for an imported value
10:50:08 <benmachine> Shrimpson: haskell already knows what type putStrLn is, you don't need to give it a signature
10:50:08 <monochrom> haha, trying to redefine its type?
10:50:57 <benmachine> rajeshsr: you say they model abstract ideas, but aren't those ideas "things that can be applied"?
10:51:14 <monochrom> Q: "how do you do side effects without Monad?" A: "I have an even better idea. Side effects without IO. putStrLn :: Int -> ()"
10:51:15 <benmachine> if all you do is define some lambdas and never apply them to anything, what do you learn?
10:51:43 <Shrimpson> benmachine: http://hpaste.org/42363/pascals_triangle
10:52:01 <hpc> monochrom: hahaha
10:52:21 <rajeshsr> need not be. The idea of lambda defining a function application is probably just a motivation for creating it and understanding it. But is actually a syntactical structure that defines the abstract idea in hand. Thats the idea i get.
10:52:59 <benmachine> Shrimpson: are you using ghci?
10:53:16 <Shrimpson> benmachine: ghci and hugs, but mainly ghci
10:53:17 <benmachine> rajeshsr: but what *is* the abstract idea? what is the information content of a lambda?
10:53:23 <benmachine> Shrimpson: right
10:53:38 <benmachine> Shrimpson: well, I'm not sure why you've put putStrLn in there with a type
10:53:47 <benmachine> Shrimpson: try doing something like
10:53:55 <benmachine> test = putStrLn "this is a test!"
10:54:04 <benmachine> and then put test into ghci
10:54:16 <elliott> Is Data.Binary still useful if I only want to use custom serialisation formats?
10:55:56 <rajeshsr> benmachine: Let us take peano's arithmetics. The way we define 0, 1 etc. is actually giving a syntactical representation that agrees with the axioms of Peano. This can be further seen by, how equivalence of expressions in lambda calculus, is defined by their syntactical representations, formally!
10:56:31 <benmachine> rajeshsr: but 0 and 1 etc. are meaningless without those axioms
10:56:38 <benmachine> what good is a number you can't add?
10:56:43 <rajeshsr> benmachine: right
10:57:13 <Shrimpson> benmachine: so how do i make "new lines" between the lists? seems like my command doesnt do what i wanted it to
10:57:46 <rajeshsr> additiion is defined by getting a new "lingusitic" structure. Their semantics as function application has never been used, in lambda calculus as far as i have seen..
10:58:12 <monochrom> mapM_ putStrLn ["hi", "it's me" "bye"]
10:58:20 <rajeshsr> To be more clear, it gives a grammar for generating the strings
10:58:28 <monochrom> syntax error
10:58:29 <benmachine> or putStrLn "hi\nit's me\nbye"
10:58:31 <monochrom> mapM_ putStrLn ["hi", "it's me", "bye"]
10:58:50 <benmachine> Shrimpson: 'pascal' looks like a type error to me
10:59:05 <benmachine> or rather, extendWith (+) "/n" does
10:59:07 <hpc> or mapM_ id [test, test, test]
10:59:12 <benmachine> (guessing you meant "\n")
10:59:21 <Shrimpson> yes i did
11:00:21 <rajeshsr> benmachine: and the grammar is so contrived as to satisfy the Peano's arithemtics. If we look deeply, all we need is the notion of equivalence and a grammar for generating new structures to define Peano's arithmetics or probably any deep axiomatic systems
11:01:00 <benmachine> rajeshsr: what do you mean by the notion of equivalence
11:01:17 <rajeshsr> when you regard 2 lambda expressions as being same
11:02:52 <benmachine> same in what sense?
11:03:29 <rajeshsr> benmachine: in terms of their "string" representation, alpha equivalence etc...
11:03:31 <benmachine> Shrimpson: you're using extendWith with a function that works on numbers, but giving it a list of characters
11:03:42 <benmachine> rajeshsr: oh. why is that equicalence interesting
11:04:40 <rajeshsr> benmachine: well, suc (x) == suc (y) iff x == y etc. Things like these qre not defined in lambda calculus if there is no notion of equivalence.
11:05:00 <merijn> rajeshsr: You can define equivalence inside the lambda calculus
11:05:16 <rajeshsr> merijn: you mean?
11:05:27 <merijn> First define booleans, then define a comparison function which returns true or false
11:06:02 <benmachine> rajeshsr: I mean why is alpha equivalence interesting
11:06:11 <benmachine> oh, never mind
11:06:17 <benmachine> I don't have the background for this conversation :P
11:06:38 <merijn> I haven't heard of alpha equivalence? You mean equivalence modulo alpha conversion?
11:06:40 <gakusei> anybody familiar with Python?
11:06:49 <merijn> gakusei: Plenty people, probably
11:07:13 <merijn> gakusei: What's your question?
11:07:33 <monochrom> who is Python?
11:07:57 <rajeshsr> benmachine: oh, nvm! it was a very interesting perspective to realize this, that semantics of lambada as function application is irrelevant to the way it is mainly used, which is a synatctic structure! So just thought will trigger a conversation here, so that people can correct me, if am wrong!
11:08:02 <gakusei> marijn: I have a question regarding composition
11:08:04 <gakusei> I found out that I can transform a list comprehension into
11:08:06 <gakusei> (map square . filter odd)[1..5]
11:08:16 <rajeshsr> merijn: well, \x.x == \y.y etc...
11:08:30 <merijn> gakusei: You know haskell has list comprehensions? (Python stole them from Haskell)
11:08:53 <monochrom> you can always transform a list comprehension into something else
11:09:24 <monochrom> but I'm dumber. I didn't find it out myself. I had to read a paper. :)
11:09:26 <gakusei> merijin: sure [x*x| x<-[1..5], odd x] and I want to transform it into map/filter with composition
11:10:37 <merijn> gakusei: So, what's the problem?
11:11:15 <elliott> anyone used Data.Binary?
11:12:10 <monochrom> "-- Yes, I come from Java..." "type HashMap = M.Map FilePath ClockTime"  hehehe
11:13:20 <Twey> Haha
11:20:21 <kafee> to catch an expection of no parse form read do I must use evaluate?
11:20:53 <Igloo> You probably want to use the 'reads' function instead
11:21:22 <kafee> from*
11:22:00 <kelvie_> Okay; I think I found a bug in System.Cmd in GHC:  the System.Cmd.system seems to truncate multibyte characters when given a String:
11:22:02 <kelvie_> http://pastebin.ca/2021438
11:22:26 <kelvie_> Is this intended? Or a bug? I'm on linux with LC_ALL set to en_US.utf8
11:22:57 <elliott> What's the best thing to use for SHA-2 (SHA-512 etc.) hashing?
11:23:30 <merijn> kelvie_: How are you sure it's truncating?
11:25:27 <sm> kelvie_: I think that's intended. When you talk to unix platform facilities (arguments, shell commands, etc.) you generally need to talk utf-8
11:25:53 <sm> s/intended/normal/
11:26:24 <merijn> kelvie_: Two possible problems could be: System does not convert to UTF-8 and stdout of the system call is different from the stdout you're looking at
11:27:33 <elliott> sha-2? anybody? :) there's Data.Digest.Pure.SHA but I imagine it might be pretty slow being pure Haskell unconcerned with efficiency.
11:28:42 <monochrom> Is there any reason why it is en_US.utf8 rather than en_US.UTF-8 ?
11:29:04 <sm> arguably system should convert, on unix, to be more portable, you could propose it to the maintainer
11:29:18 <monochrom> I see, en_US.utf8 is also valid
11:29:55 <Shrimpson> benmachine: but there must be a way how to make him write each list in its own row, isnt there?
11:30:02 <kelvie_> merijn: yeah, I'm not sure that it's truncating
11:30:14 <kelvie_> merijn: actually, I can easily check
11:30:18 <sm> yeah, on linux the canonical spelling (reported by locale -a) is .utf8, but other hyphenations and capitalisations are also accepted
11:30:21 <Shrimpson> benmachine: is there a hint you could give me for google or something?
11:30:28 <sm> on mac, it must be exactly .UTF-8
11:32:14 <kelvie_> http://pastebin.ca/2021442
11:32:21 <monochrom> alright, some problem about System.Cmd
11:32:21 <kelvie_> Anyone know encodings better than I do? :P
11:32:24 <kelvie_> I suspect it's truncating
11:33:01 <kelvie_> But not on the first character, for some reason
11:33:19 <merijn> Try encoding to UTF-8 before passing to system?
11:33:32 <sm> kelvie_: btw to make it work,  import Codec.Binary.UTF8.String,  system $ encodeString "echo 中文"
11:34:20 <kelvie_> sm: Ah
11:34:35 <kelvie_> Is there a function to just convert to the local encoding?
11:34:50 <merijn> Probably :p
11:35:30 <Palmik> Hi guys... would something like this foo = (\x -> do_something_with x) be considered pointfree by definition?
11:35:45 <merijn> Palmik: That's silly
11:35:47 <sm> kelvie_: yes, but your linux is probably not going to like it. See http://www.cl.cam.ac.uk/~mgk25/unicode.html#linux
11:35:53 <monochrom> (\x -> do_something_with x) is not pointfree
11:36:01 <merijn> Palmik: Why not "foo = do_something_with"?
11:36:11 <Palmik> because that is just an example....
11:36:20 <kelvie_> sm: Ah
11:36:31 <kelvie_> I guess I should probably just email the maintainer to try to use utf8 by default
11:36:43 <merijn> kelvie_: No, that's awful
11:36:48 <kelvie_> No?
11:36:58 <merijn> Default encodings are what got us into this mess in the first place
11:37:05 <kelvie_> So we should default to ASCII?
11:37:14 <Palmik> merijn, what I meant is "will hiding the argument into the lambda make it pointfree?"
11:37:22 <merijn> No, we should default to "Exception: unencoded text" :p
11:37:24 <Palmik> monochrom, ok
11:37:54 <kelvie_> merijn: I would heartily endorse that
11:38:04 <sm> I use a type PlatformString = String alias for talking to the system, where on unix PlatformString is utf8-encoded
11:38:14 <sm> but on windows it's not, afaik
11:38:38 <kelvie_> Oh well, it just makes the code a bit uglier
11:38:41 <sm> I think this should be provided by one of the base system libs
11:38:47 <kelvie_> It just surprised me a little
11:39:22 <kelvie_> On other platforms, the System* functions don't use bytestreams?
11:39:50 <monochrom> System.Cmd probably just assumes everything is just ascii
11:39:52 <kelvie_> (as opposed to encoded strings)
11:40:52 <sm> yes, it differs by platform, at least unix and windows are different in this respect
11:41:13 <kelvie_> monochrom: Yeah, I think it does
11:41:49 <sm> that's why we need a PlatformString abstraction
11:42:03 <kelvie_> Switching to encoding to utf-8 by default would at least be backwards-compatible, right?
11:42:07 <kelvie_> I mean, Ascii stays Ascii
11:42:21 <kelvie_> just multibyte strings won't get truncated
11:42:30 <monochrom> not portable to windows
11:42:39 <kelvie_> monochrom: For just posix, I mean :P
11:42:49 <monochrom> then alright
11:43:07 <merijn> Does posix have a default encoding then?
11:43:08 <monochrom> not portable to future versions of System.Cmd
11:43:14 <merijn> I'm pretty sure it doesn't
11:43:23 <kelvie_> merijn: You can query one from the locale
11:43:38 <merijn> kelvie_: Yes, but who says that the locale will be UTF-8?
11:43:50 <merijn> So utf-8 is not the default posix encoding
11:43:51 <elliott> hmm, what's the best Map-like structure to use for keys with no obvious ordering?
11:43:56 <monochrom> yeah, sometimes the locale is called "C" :)
11:43:56 <kelvie_> Hmm.
11:44:12 <sm> merijn: I think de facto it is (http://www.cl.cam.ac.uk/~mgk25/unicode.html#linux)
11:44:18 <kelvie_> I'm just saying, it's still better than defaulting to truncating to ASCII
11:44:38 <merijn> sm: It is the defacto standard under linux
11:44:57 <monochrom> if you just run your program on your own computer, it's ok.
11:45:09 <merijn> Now of course rabid linux fans never shy away from defaulting to gross linuxisms in their code. But they shouldn't pretend its standard
11:45:23 <sm> ok, but I'll guess posix is the same until I find a reputable doc saying otherwise
11:45:37 <elliott> sm: no, POSIX default locale is C
11:45:41 <merijn> BSD and OSX are both posix compliant, neither default to utf8
11:45:45 <sm> oh sure, sometimes the locale is not a utf8-aware one
11:45:53 <monochrom> I know people in Sweden and Russia who still refuse UTF-8.
11:45:56 <sproingie> UTF8 is actually a plan-9-ism that made its way back to unix
11:46:19 <elliott> sproingie: indeed
11:46:27 <merijn> sm: There is no such thing as utf8-aware
11:46:32 <merijn> It is either utf8 or not
11:46:52 <c_wraith> utf8 is really a completely brilliant encoding scheme.  The guarantees it provides are terrifically useful.
11:47:10 <monochrom> sm means locales like en_US.utf8 and zh_CN.utf8
11:47:16 <sm> yes
11:47:42 <sm> monochrom: this my question, what are the reasons why using utf8 for everything evermore is not ideal ? I know there must be some
11:47:45 <merijn> What if someone has a locale based on iso-8859?
11:48:05 <Twey> Then they can get stuffed >.>
11:48:20 <merijn> Twey: Sure, but as I said then you're commiting gross linuxisms
11:48:35 <Twey> sm: UTF-8 is not as efficient as the other UTFs for higher-codepoint characters
11:48:48 <Twey> sm: E.G. it requires three bytes to encode Han characters as opposed to UTF-16's two
11:48:48 <merijn> Which is fine if you want to produce buggy code as long as you don't go around pretending your standards compliant
11:48:48 <Ke> utf-8 is impossible to handle unless you are using pre-made libraries for string operations
11:48:51 <c_wraith> sm: mostly because of asian countries that don't like that UTF-8 tends to end up at 3 bytes per character average
11:48:58 <monochrom> the only tenable objection to utf8 are (a bit hard to count characters) and (a bit longer for certain strings).
11:49:09 <Twey> merijn: It's not a ‘Linuxism’ to rely on people not using horribly outdated technology
11:49:15 <monochrom> but no one ever uses tenable objections.
11:49:37 <merijn> Twey: The correct approach would be to query the environment for locale and encode accordingly instead of defaulting to utf8
11:49:47 <Twey> merijn: I'm pretty sure all the modern OSes can all do UTF-8.
11:49:48 <c_wraith> Also, there are some users of asian languages who reject unicode entirely, saying the choices it made do not allow for proper representation of their langauge.
11:49:55 <merijn> I encounter plenty of unix systems which do not default to utf8 in daily live
11:49:55 <Twey> merijn: Well, the default is what you use when the querying fails
11:50:20 <monochrom> people refuse utf8 because they are too proud of their nationalities to go international.
11:51:00 <monochrom> think of it as neo-racism
11:51:02 <sm> merijn: that sounds like the correct approach, but there are parts of posix systems that don't or can't do that, I believe
11:51:12 <Twey> Well, nationalism ≠ racism, but yeah
11:51:25 <c_wraith> And I'll agree that unicode *really* made a mess out of some parts of the CJK character sets.
11:51:55 <c_wraith> The glyph used for a particular codepoint shouldn't be completely different depending on locale, but in some cases it is.
11:52:04 <merijn> c_wraith: Well, it might be a mess, but still it's less of a mess then before unicode
11:52:06 <Twey> Mm
11:52:09 <Twey> Right
11:52:15 <sm> monochrom: well, there's pride and there's resisting imperialistic standards crammed down your throat :)
11:52:19 <monochrom> there is only a little bit of Japanese it fails, from what I know. it does all of Chinese just fine.
11:52:24 <Adamant> CJKV probably shouldn't have been unified, in retrospect
11:52:33 <c_wraith> Adamant, that's precisely the problem
11:52:41 <Adamant> sm: imperialism requires the powers involved to give a shit
11:52:46 <Adamant> the problem is they don't
11:52:54 <sm> not at all, it's a perception by people
11:53:02 <monochrom> ascii is the real imperialistic standard
11:53:12 <elliott> <monochrom> there is only a little bit of Japanese it fails, from what I know. it does all of Chinese just fine.
11:53:13 <sm> influencing their feelings and technology choices
11:53:16 <monochrom> together with inches and feet
11:53:19 <elliott> This encoding does all of English but j and z.
11:53:23 <elliott> Switch to it quickly!
11:53:42 <c_wraith> no one uses those letters.  It's ok.
11:53:42 <monochrom> what is "This encoding does all of English but j and z"?
11:53:54 <c_wraith> monochrom, an analogy
11:53:58 <Adamant> I want to establish an empire just to slap people in the face that overuse the word "imperial"
11:54:11 <monochrom> "j and z" is not "a bit of English"
11:54:36 <c_wraith> they're not used very often.
11:55:09 <monochrom> Adamant just used j up there. In fact I just used j right here.
11:55:26 <c_wraith> Unless you're a fan of oregon state university's football team, and need to talk about Jacquizz Rodgers.  His name really goes out of the way to use lots of unusual letters :)
11:55:46 <monochrom> If you say "this encoding does all of English but the word xylophone" you begin to have a case.
11:55:49 <Adamant> I'm also low on booty, wenches, and captured riches, which is what you used to get back when people had actual empires
11:56:11 * hackagebot clientsession 0.4.1 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.4.1 (MichaelSnoyman)
11:56:16 <monochrom> s/case/analogy/
11:57:00 <Adamant> they should just add the seperate CJKV shit as additional characters so we can drop it
11:57:11 * hackagebot xml-enumerator 0.0.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.0.1 (MichaelSnoyman)
11:57:18 <Adamant> make UTF-32 useful
11:57:39 <monochrom> but then you realize "if it just misses out 'xylophone' it is bearable. it is not like misses out 'just' which we use every other minute" and so you see the original analogy was broken.
11:57:57 <Adamant> I am in favor of bans on bagpipes
11:58:10 <Adamant> unless they are playing "Scotland the Brave"
11:58:17 * c_wraith considers starting a xylophone/bagpipe ensemble
11:58:34 <Adamant> c_wraith: don't forget your Sousaphone
11:59:14 <Adamant> I hear tell there are also hydrophones these days
11:59:29 <Adamant> or hydrauliphones, excuse me
12:03:44 <monochrom> When confronted with an argument, some people say, "I know, I'll use an analogy". Now they have two problems.
12:06:41 <monochrom> "learning to read haskell in english" is that a joke?
12:07:51 <monochrom> "I come from an object oriented background(C, c++, java) so I am used to being able to read a line of code in english to understand what it is doing."  So server.reset() is english, reset server is not english? what kind of english is that?
12:08:00 <Shrimpson> Does someone know a command how to make haskell write, say, 12 lists in seperate lines?
12:09:55 <dobblego> Shrimpson, mapM_ show
12:10:30 <monochrom> please don't put "show" there
12:10:33 <jmcarthur> Shrimpson: did you already ask this question and get an answer?
12:10:42 <jmcarthur> i seem to recall
12:11:01 <Shrimpson> benmachine gave me some hints
12:11:04 <Shrimpson> but it didnt work out for me
12:11:08 <Shrimpson> im trying "mapM_ show" now
12:11:14 <dobblego> oops
12:11:16 <dobblego> Shrimpson, mapM_ print
12:11:35 <jmcarthur> Shrimpson: monochrom had given you exactly that answer earlier (mapM_ print)
12:11:55 <monochrom> Actually I used mapM_ putStrLn
12:11:57 <Shrimpson> i wasnt sure whether it was directed to me 
12:12:02 <jmcarthur> ah, right
12:12:15 <Shrimpson> but how do you use that command? is everything after "mapM_ print" written in a new line?
12:12:15 <jmcarthur> print would be better
12:12:26 <jmcarthur> Shrimpson: apply it to your list of lists
12:12:30 <Shrimpson> k, mom
12:12:33 <jmcarthur> mapM_ print listOfLists
12:12:40 <dobblego> >> mapM_ print ["hello", "there"]
12:12:40 <dobblego> "hello"
12:12:40 <dobblego> "there"
12:13:26 <Shrimpson> well my lists are being made by a "iterate" command
12:13:36 <Shrimpson> can i put it in front of that somehow? hes giving me errors
12:13:51 <dobblego> mapM_ print $ iterate "does this ever stop?"
12:14:07 <monochrom> whatever I gave, it was conveniently ignored, so no harm is done!
12:14:07 <dobblego> oh wait
12:14:28 <jmcarthur> :t iterateM
12:14:29 <Shrimpson> monochrom: sorry, i didnt know you meant me
12:14:29 <lambdabot> Not in scope: `iterateM'
12:14:30 <monochrom> you need to test your code in ghci before suggesting! :)
12:14:36 <dobblego> mapM_ print $ iterate ("does this ever stop?"++) []
12:14:39 <jmcarthur> i thought we had that. i must just be thinking replicateM
12:15:02 <dobblego> we have replicateM but not iterateM or repeatM
12:15:09 <jmcarthur> shame
12:15:45 <Shrimpson> what does the "$" mean?
12:15:51 <jmcarthur> :t ($)
12:15:51 <lambdabot> forall a b. (a -> b) -> a -> b
12:15:56 <jmcarthur> @src ($)
12:15:56 <lambdabot> f $ x = f x
12:16:02 <Shrimpson> eh..
12:16:17 <jmcarthur> foo bar $ baz wibble   ==>  foo bar (baz wibble)
12:16:17 <monochrom> "f $ blah blah" means "f (blah blah)"
12:16:32 <Shrimpson> hm, ok
12:16:41 <Shrimpson> thx
12:17:10 <Twey> More specifically, (foo bar) (baz wibble)
12:17:17 <Twey> Which matters sometimes with operators
12:17:27 <Shrimpson> hmmm still getting errors..
12:26:34 <kafee> I cannot understand; why does OIOJH isn't printed in this code: http://hpaste.org/42364/exception ?
12:27:34 <mauke> because return (read "23" :: String) doesn't throw an exception
12:27:55 <monochrom> some laziness (more correctly non-strictness) implies what mauke says.
12:28:06 <monochrom> See also Control.Exception.evaluate
12:28:07 <kafee> it says "*** Exception: Prelude.read: no parse 
12:28:09 <mauke> > length (return (read "23" :: String))
12:28:10 <lambdabot>   1
12:28:18 <mauke> kafee: but not in that code
12:28:47 <monochrom> try http://hpaste.org/paste/42364/exception_annotation#p42365
12:29:00 <mauke> try reads
12:29:25 <monochrom> Control.Exception.evaluate is expressedly for this purpose. To speed up exceptions.
12:29:26 <kafee> mauke, then my GHC is crazy, it says that
12:29:43 <mauke> kafee: so?
12:29:53 <jeltsch> How does GHCi search for #include files?
12:29:54 <mauke> the exception isn't thrown in 'a'
12:30:10 <monochrom> I think since some version GHCi no longer search for #include files
12:30:48 <monochrom> wait, length (return (read "23" :: String)) is not even in IO
12:30:58 <jeltsch> I have some *.h files in the current directory, but when an module tries to #include them, GHCi 6.12.1 says: “error: xyz.h: No such file or directory”
12:35:30 <kafee> mauke: it keeps saying Exception
12:36:23 <mauke> kafee: yes
12:41:52 <monadic_kid> android 2.3 supports full native apps, that should make a it a bit easier to get haskell on there with a unregistered port of ghc
12:46:58 <mreh> do some libraries on hackage really have dependencies on profiling libs?
12:50:59 <monochrom> I haven't heard of one. It also seems hard to specify in project.cabal files.
12:53:10 <mreh> prolly because I've enabled profiling=True in my .cabal/config :)
12:53:38 <c_wraith> indeed.  after doing that, everything you install will depend on profiling libs of everything you've installed
12:53:53 <c_wraith> This leads to issues if you installed much before doing that
12:54:30 <mreh> yah, shame we have no tool to fix this.. yet
12:54:36 <romildo> Is there any convention on how to name variables designating widgets in gtk2hs? For instance, how would I name an entry widget to input the age of a person? ageEntry or entryAge?
12:55:06 <dankna> this strikes me as a situation where both conventions are probably used
12:55:22 <dankna> I would use ageEntry because it's purpose as an adjective, followed by kind of thing as a noun
12:55:32 <mreh> you can't do a reinstall without reisntalling everything can you?
12:55:38 <mreh> cabal install --reinstall
12:55:45 <monochrom> there is no convention
12:57:32 <monochrom> not to mention that you may regret calling it "entry" later
12:58:05 <romildo> I keep using both ways of naming the widgets, and now my program has a mix of them. I think I wil choose one in favor or the other.
13:00:02 <romildo> monochrom, I do not see why I would regret calling it "entry" later. The widget would be named like this, and its content (I mean the text input by the entry) would be named just "age" in this example.
13:34:03 <mreh> q
13:34:17 <mreh> sorry, wrong window
13:42:31 <mreh> did you get that last question, got cut off?
13:43:05 <byorgey> mreh: don't think so
13:43:56 <mreh> Reader in mtl is defined as a type, can I use it as a constructor with LiberalTypeSynonyms? Seems to suggest I can
13:44:31 <c_wraith> It's not a newtype
13:44:33 <c_wraith> ?
13:45:41 <byorgey> mreh: I don't understand what you mean by "use it as a constructor"
13:45:58 <byorgey> c_wraith: mtl-2 defines Reader as a type synonym for ReaderT Identity
13:46:01 <mreh> it's defined in terms of ReaderT
13:46:01 <mreh> ReaderT Identity infact
13:46:05 <c_wraith> ah
13:46:30 <monochrom> mtl new version uses ReaderT
13:47:39 <monochrom> If you wrote "Reader haha" for the old version, now write "reader haha" for the new version. :)
13:48:35 <monochrom> But yes if you try to "instance MyEnchancedMonad Reader" it won't end very well.
13:55:52 <pumpkin> shhh, be vewwy vewwy quiet
13:55:56 <pumpkin> I'm hunting bunny wabbits
13:59:29 <mreh> xmonad-contrib wont compile for this reason, they've used Reader as a type constructor
13:59:58 <c_wraith> @kind Reader
13:59:59 <lambdabot> * -> * -> *
14:00:08 <c_wraith> Oh, you mean in an instance declaration?
14:01:39 <byorgey> mreh: oh, I see, that's super annoying.  someone put  mtl >= 1 && < 3
14:01:51 <mreh> in a type
14:02:13 <mreh> byorgey: why's that
14:02:27 <byorgey> why did they put it? or why is it annoying?
14:02:38 <mreh> why is it annoying?
14:02:40 <byorgey> answers: I have no idea, and because it is false
14:02:55 <byorgey> xmonad-contrib.cabal claims it will build with any version of mtl less than 3, and it does not.
14:03:09 * byorgey fixes it
14:03:38 <mreh> excellente, I'd love to know what you fix
14:03:44 <byorgey> hmm, code.haskell.org seems to be down again
14:03:55 <byorgey> mreh: I was just planning to set the upper bound on the mtl dependency to <2
14:04:05 <byorgey> so it won't try to build with the latest version of mtl
14:04:12 <mreh> or the rational behind it
14:04:13 <mreh> rationale*
14:04:24 <byorgey> mreh: you can specify it yourself like so:  cabal install xmonad-contrib --constraint='mtl<2'
14:04:28 <mreh> i can force it not to
14:04:46 <pumpkin> byorgey: it's down more than it isn't :P
14:04:56 <byorgey> hmm, haskell.org seems down too
14:05:01 <byorgey> I know =P
14:05:06 <pumpkin> not for me
14:05:15 <pumpkin> code.haskell.org works here too
14:05:35 <byorgey> hmm, maybe it is a DNS problem with my local network
14:05:52 <pumpkin> PING community.haskell.org (72.249.126.23): 56 data bytes
14:05:57 <pumpkin> try the IP directly?
14:06:04 * hpc visited it just fine
14:06:26 <hpc> haskell.org is 78.46.100.180
14:07:19 <byorgey> oh, now it works for me again
14:07:25 <byorgey> looks like it was just a local network hiccup
14:07:46 <mreh> ;)
14:07:46 <mreh> it's down with the kids
14:10:11 <rhapsodhy> hi
14:10:32 <rhapsodhy> i'm a haskell noob, and trying to extract values from a list into a tuple
14:10:43 <rhapsodhy>  let splitIntoPieces line = map (\x -> (take 2 x, drop ((length x) - 5) x) (splitOn "," line))
14:11:14 <rhapsodhy> running this in ghci gives error:  Couldn't match expected type `t -> b'
14:11:26 <rhapsodhy> and i can't figure out what i'm getting wrong
14:11:30 <mauke> what's the real error message?
14:11:38 <rhapsodhy> uhm, let me pastie that
14:12:02 <unkanon> we need to know also how you defined splitOn
14:12:04 <rhapsodhy> http://pastie.org/1384052
14:12:07 <unkanon> rhapsodhy: ^
14:12:16 <rhapsodhy> splitOn is from Data.List.Split
14:12:22 <byorgey> rhapsodhy: it looks like your parentheses are screwy
14:12:23 <unkanon> oh sorry :)
14:12:34 <rhapsodhy> byorgey: ?
14:12:34 <mauke> rhapsodhy: misparenthesized
14:12:45 <byorgey> rhapsodhy: the paren before (\x  is matched by the one at the very end
14:12:50 <rhapsodhy> oh shi-
14:12:53 <unkanon> don't mind me, I can't even manage to get ord in ghci
14:12:58 <sleepynate> unless 2 can take x as a parameter :D
14:13:05 <mauke> unkanon: import Data.Char
14:13:50 <rhapsodhy> oh, cool
14:13:51 <rhapsodhy> thanks
14:14:14 <rhapsodhy> btw, is there a prettier way of doing  drop ((length x) - 5) x) ?
14:14:14 <unkanon> mauke: thanks, I did @hoogle ord and it told me it comes from Data.Ord ??
14:14:27 <unkanon> mauke: I don't know any better tricks than @hoogle
14:14:40 <monochrom> Data.Char.ord
14:14:57 <mauke> unkanon: no, it didn't
14:15:05 <unkanon> > (\x -> drop ((length x ) -5) x)) "abcdefghijkl"
14:15:06 <lambdabot>   <no location info>: parse error on input `)'
14:15:09 <mauke> it told you class Ord comes from Prelude and Data.Ord
14:15:16 <unkanon> > (\x -> drop ((length x ) -5) x) "abcdefghijkl"
14:15:17 <lambdabot>   "hijkl"
14:15:25 <mauke> but that ord :: Char -> Int is from Char and Data.Char
14:15:43 <hpc> :t fromEnum
14:15:44 <lambdabot> forall a. (Enum a) => a -> Int
14:15:47 <unkanon> @hoogle ord
14:15:47 <lambdabot> Data.Char ord :: Char -> Int
14:15:47 <lambdabot> module Data.Ord
14:15:47 <lambdabot> Prelude class Eq a => Ord a
14:15:49 <hpc> ord = fromEnum
14:15:56 <unkanon> mauke: module Data.Ord
14:16:02 <Twey> Haha, never figured that out before.
14:16:09 <mauke> unkanon: ok, that's the module itself
14:16:23 <unkanon> then I naively tried :m + Data.Ord
14:16:26 <mauke> its name contains "ord"
14:16:34 <mauke> why did you ignore the first hit?
14:16:43 <unkanon> I ddn't even see it  *ashamed*
14:16:52 <c_wraith> too used to ads in that first spot?
14:17:41 <unkanon> > reverse . drop 5 . reverse $ "abcefghijkl"
14:17:42 <lambdabot>   "abcefg"
14:17:52 <unkanon> > reverse . take 5 . reverse $ "abcefghijkl"
14:17:53 <lambdabot>   "hijkl"
14:17:58 <unkanon> rhapsodhy: ^^
14:18:07 <rhapsodhy> thanks
14:18:17 <unkanon> I believe my function performs worse than yours
14:18:45 <unkanon> c_wraith: hahaha maybe thats it
14:18:47 <unkanon> ad blindness
14:18:57 <rhapsodhy> unkanon: isn't it optimized by compiler?
14:19:17 <maltem> unkanon, I think yours performs better (if the list is longer than 5) because it doesn't traverse the whole list twice
14:19:38 <maltem> But I'm always wrong about such things
14:20:02 <pumpkin> there are nicer ways to do it
14:20:08 <unkanon> rhapsodhy: judging by your question I think you know more about this than I do :)
14:20:18 <unkanon> I honestly have no idea
14:20:21 <unkanon> I'd love to know though
14:20:32 <rhapsodhy> :)
14:20:52 <pumpkin> > (join . (zipWith const .) . drop) 5 [1..100]
14:20:53 <rhapsodhy> although maltem might be right
14:20:53 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
14:20:54 <unkanon> maltem: hold on, I have to think about how rhapsodhy's function traverses the whole list twice...
14:20:56 <pumpkin> oh wait
14:21:27 <pumpkin> this one is the more annoying one
14:21:31 <rhapsodhy> i just don't know anything about haskell's internals
14:21:33 <pumpkin> but you can do it in a single traversal
14:21:38 <rhapsodhy> or haskell for that matter
14:21:56 <maltem> unkanon, length, then drop
14:22:08 <rhapsodhy> why is reverse faster?
14:22:09 <unkanon> but drop doesnt treaverse the whole list
14:22:11 <unkanon> or does it?
14:22:26 <unkanon> it stops at the first parameter's position
14:22:33 <maltem> unkanon, well, nearly the whole list, if 5 is small compared to the list
14:22:43 <pumpkin> > let f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = f xs ys in f (drop 5 [1..100]) [1..100]
14:22:44 <lambdabot>   [96,97,98,99,100]
14:22:50 <pumpkin> that one
14:23:06 <unkanon> maltem: hmm
14:23:15 <pumpkin> I think that's about as efficient as you can get
14:23:27 <unkanon> maltem: oh I get it now :)
14:24:10 <pumpkin> drop doesn't have to rebuild anything
14:24:13 <pumpkin> it's just dropping stuff
14:24:29 <pumpkin> same with my f up there
14:24:30 <unkanon> but it has to walk until the point where it returns the rest
14:24:39 <pumpkin> sure, but that's fine
14:25:05 <pumpkin> > (\n xs -> let f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = f xs ys in f (drop n xs) xs) 7 [1..100]
14:25:06 <lambdabot>   [94,95,96,97,98,99,100]
14:25:09 <unkanon> pumpkin: your function is cheating
14:25:13 <pumpkin> why?
14:25:23 <byorgey> mreh_: do you know which xmonad-contrib module it is that uses the Reader constructor?
14:25:26 <unkanon> pumpkin: because when you do [1..100] you're implicitly saying you already know the length of the list
14:25:31 <pumpkin> no I'm not
14:25:49 <byorgey> mreh_: also, what version of ghc?
14:25:52 <pumpkin> > (\n xs -> let f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = f xs ys in f (drop n xs) xs) 7 (last cake)
14:25:53 <lambdabot>   "tissue."
14:25:58 <unkanon> > cake
14:25:59 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:25:59 <pumpkin> > (\n xs -> let f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = f xs ys in f (drop n xs) xs) 7 (head cake)
14:26:00 <lambdabot>   "ke mix."
14:26:05 <byorgey> mreh_: it seems to compile fine for me with mtl-2 and ghc-6.12.3
14:26:11 <c_wraith> > last cake
14:26:11 <lambdabot>   "That will deodorize and preserve putrid tissue."
14:26:18 <pumpkin> unkanon: I'm pretty sure my function is as good as you can get for lists
14:26:25 <pumpkin> if not as elegant
14:26:28 <byorgey> mreh_: also, are you talking about the darcs version, or the version from Hackage?
14:26:36 <pumpkin> but I can't think of a nice Data.List function that would give us that
14:26:52 <unkanon> pumpkin: I understand it intuitively but not concretely
14:27:14 <pumpkin> it's basically a zip-like function
14:27:28 <pumpkin> but instead of zipping the lists together it traverses them in parallel, and when it hits the end of one, it returns the other
14:27:28 <rhapsodhy> splitIntoPieces line = (\x -> (take 2 x, reverse . take 5 . reverse $ x)) (splitOn "," line)
14:27:29 <unkanon> yes I also thought of zipWith
14:27:32 <pumpkin> what's left of the other, that is
14:27:45 <unkanon> pumpkin: I got that part too
14:27:51 <rhapsodhy> is this good style for a function?
14:27:52 <unkanon> I just don't get what are the two different lists
14:28:03 <pumpkin> > drop 5 [1..20]
14:28:04 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
14:28:04 <rhapsodhy> or should i do a where clause instead
14:28:06 <pumpkin> > [1..20]
14:28:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
14:28:11 <pumpkin> those are overlaid now
14:28:27 <maltem> pumpkin, I really like that one, it feels clever :)
14:28:44 <pumpkin> I'm sure I saw someone else do it in here way back in the day, so I can't take credit :)
14:28:47 <pumpkin> but it's elegant
14:29:10 <pumpkin> preflex: seen ezyang
14:29:10 <preflex>  ezyang was last seen on #haskell-blah 22 hours, 58 minutes and 26 seconds ago, saying: dun worry, I mix all the time too. 
14:29:11 <mm_freak> pumpkin: can you summarize what you want to do?
14:29:18 <pumpkin> mm_freak?
14:29:31 <unkanon> > (\n xs -> let f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = f xs ys in f (drop n xs) xs) 5 [1..20]
14:29:32 <lambdabot>   [16,17,18,19,20]
14:29:40 <unkanon> oh I got it. 
14:29:42 <Twey> What's the story behind ‘cake’?
14:29:44 <pumpkin> @let lastN = (\n xs -> let f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = f xs ys in f (drop n xs) xs)
14:29:45 <lambdabot>  Defined.
14:29:47 <pumpkin> Twey: portal
14:29:51 <Twey> Oh
14:29:56 <pumpkin> > lastN 10 [1..200]
14:29:56 <lambdabot>   [191,192,193,194,195,196,197,198,199,200]
14:30:03 <unkanon> Twey: it's a lie anyway  :P
14:30:03 <pumpkin> mm_freak: that!
14:30:10 <mm_freak> ah
14:30:15 <Twey> Hehe
14:30:23 <hpc> @src lastN
14:30:23 <lambdabot> Source not found. You speak an infinite deal of nothing
14:30:27 <pumpkin> > isLie cake
14:30:28 <lambdabot>   True
14:30:34 <unkanon> no way!
14:30:39 <hpc> :t isLie
14:30:40 <lambdabot> [[Char]] -> Bool
14:30:40 <rhapsodhy> :D
14:30:57 <hpc> > isLie ["isLie cake"]
14:30:58 <lambdabot>   False
14:31:14 <mauke> @v
14:31:14 <lambdabot> "\""
14:31:43 <mm_freak> > foldl (.) id (repeat 5 last) $ [0..19]
14:31:44 <lambdabot>   Couldn't match expected type `([a1] -> a1) -> [a -> a]'
14:31:44 <lambdabot>         against inf...
14:31:51 <mm_freak> > foldl (.) id (repeat 5 init) $ [0..19]
14:31:52 <lambdabot>   Couldn't match expected type `([a1] -> [a1]) -> [a -> a]'
14:31:52 <lambdabot>         against i...
14:31:54 <mauke> replicate
14:31:56 <unkanon> > isStillAlive "GladOs"
14:31:57 <lambdabot>   True
14:31:58 <mm_freak> uhm
14:32:02 <mm_freak> > foldl (.) id (replicate 5 init) $ [0..19]
14:32:02 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
14:32:09 <mm_freak> doing too much PHP recently
14:32:14 <mm_freak> ah, no, that's not it
14:32:54 <mauke> @let a === b = cast a == Just b -- zomg php
14:32:55 <lambdabot>  Defined.
14:33:29 <hpc> wtf
14:33:31 <hpc> :t cast
14:33:31 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
14:33:44 <hpc> ah
14:34:01 <hpc> > 5.0 === (5 :: Int)
14:34:01 <mm_freak> pumpkin: what about take n . reverse?
14:34:02 <lambdabot>   False
14:34:25 <pumpkin> mm_freak: and reverse again? that's less efficient
14:34:35 <mm_freak> ah yes, you need to reverse again
14:34:35 <pumpkin> it's rebuilding the list and isn't lazy
14:34:54 <mm_freak> such a function needs to be strict anyway
14:34:55 <unkanon> what we need is a function reverseButNotReallyIfYouKnowWhatIMean
14:35:21 <hpc> > head . reverse $ [undefined, 5]
14:35:22 <lambdabot>   5
14:39:09 <parcs> > fix cast
14:39:10 <lambdabot>   Nothing
14:39:26 <sproingie> > fix php
14:39:27 <lambdabot>   Not in scope: `php'
14:39:29 <sproingie> yay
14:40:24 <c_wraith> @let php = const "do what now?"
14:40:24 <lambdabot>  Defined.
14:40:28 <c_wraith> > fix php
14:40:29 <lambdabot>   "do what now?"
14:40:59 <unkanon> hahahaha
14:42:48 <mauke> > fmap fix return fix cast
14:42:49 <lambdabot>   Nothing
14:42:57 <unkanon> > php "fetch me a Monad"
14:42:58 <lambdabot>   "do what now?"
14:43:09 <parcs> > fix $ fmap fix return
14:43:13 <lambdabot>   mueval-core: Time limit exceeded
14:44:11 <mm_freak> pumpkin: i think you need to calculate the length anyway
14:44:18 <pumpkin> mm_freak: ?
14:45:02 <mm_freak> > let lastN n xs = take n . drop (length xs - n) . cycle $ xs in lastN 5 [0..19]
14:45:03 <lambdabot>   [15,16,17,18,19]
14:45:13 <pumpkin> that keeps the list around for longer than it needs to be
14:45:22 <pumpkin> it'll use loads of memory if the list is huge
14:45:41 <pumpkin> mine is traversing the list twice, but in parallel
14:45:51 <pumpkin> so it can be discarded
14:46:11 <mm_freak> why does it keep the list?
14:46:31 <c_wraith> because you call length and drop
14:46:59 <pumpkin> you're doing two separate traversals of the list
14:47:03 <pumpkin> you cross it once to get length
14:47:15 <pumpkin> and need to keep it all around for the second time when you traverse it with drop
14:48:53 <mm_freak> ah yes
14:49:08 <mm_freak> what does your code do?  when doing it properly, i'd make a moving window
14:49:18 <mm_freak> (i haven't read it yet)
14:49:28 <pumpkin> this: @let lastN = (\n xs -> let f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = f xs ys in f (drop n xs) xs)
14:50:04 <pumpkin> if you had a genericLength on a lazy natural, you might be able to do it smartly using length too
14:50:32 <pumpkin> but that Int that returns from length forces the entire traversal at once
14:51:14 <pumpkin> anyway, gotta go :)
14:51:33 <monoidal> is the usual way to write [A..B] is [A .. B]?
14:51:55 <monochrom> you may be forced to write [A .. B]
14:51:58 <monoidal> like [False..True]
14:52:05 <mauke> yes
14:52:18 <unkanon> > [False..True]
14:52:18 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
14:52:22 <unkanon> > [False .. True]
14:52:23 <lambdabot>   [False,True]
14:52:24 <unkanon> wow
14:52:31 <monochrom> > [False ..True]
14:52:32 <lambdabot>   [False,True]
14:52:34 <monochrom> :)
14:52:40 <unkanon> one fewer byte :)
14:52:41 <mm_freak> i write [a..b] for numbers and simple expressions
14:52:44 <mauke> > [minBound..True]
14:52:44 <lambdabot>   [False,True]
14:52:49 <mm_freak> > let n = 5 in [1..n-1]
14:52:50 <lambdabot>   [1,2,3,4]
14:52:53 <mauke> mm_freak: I don't!
14:52:56 <monochrom> lexer thinks "False.." is one token, qualified operator
14:53:01 <unkanon> why doesn't False..True work?
14:53:06 <unkanon> oh ok
14:53:11 <mm_freak> mauke: why not?
14:53:12 <unkanon> that makes sense
14:53:19 <mauke> mm_freak: because it looks ugly
14:53:25 <mauke> and sometimes it doesn't work, as in this case
14:53:40 <mm_freak> mauke: that's probably a matter of taste
14:53:41 <mm_freak> =)
14:53:44 <mauke> yes
14:54:00 <mm_freak> i don't like too much space
14:54:06 <mauke> but you're already relying on the parser not being completely stupid in "1.."
14:54:19 <monochrom> [ 1 .. 2 ]
14:55:33 <Twey> Whoneedsspacesanyway
14:55:34 <hpc> [False..True]
14:55:39 <hpc> > [False..True]
14:55:39 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
14:55:53 <mauke> > [minBound..] :: [Bool]
14:55:54 <lambdabot>   [False,True]
14:56:16 <hpc> Twey: i remember suggesting here a while back that normal function application have mandatory whitespace
14:56:38 <hpc> (it's optional for m>>=f, etc)
14:56:45 <unkanon> because in f(a) it's optional?
14:56:53 <mauke> whatever it takes for me to get - in identifiers
14:57:24 <Twey> hpc: I've suggested that a bunch of times
14:57:28 <Twey> mauke: +1
14:57:29 <hpc> mauke: it would also be nice to have the full set of symbols in function names
14:57:32 <hpc> like <x>
14:57:36 <Twey> Yeah
14:57:43 <Twey> And it would make parsing *so* much easier.
14:57:50 <Twey> And solve the horrible negation problem.
14:57:55 <unkanon> are you guys serious?
14:58:02 <hpc> unkanon: deadly serious
14:58:04 <mauke> remove unary -
14:58:05 <unkanon> how would allowing all symbols make parsing serious?
14:58:06 <mauke> problem solved
14:58:06 <Twey> unkanon: Entirely
14:58:17 <mauke> unkanon: have I got a language for you
14:58:21 <Twey> Haha
14:58:25 <unkanon> mauke: lisp?
14:58:43 <monochrom> we make parsing serious
14:58:45 <mauke> http://mauke.ath.cx/stuff/ploki/ploki-0.6.5.1/
14:58:47 <Twey> unkanon: The point is that with the spaces non-optional parsing becomes relatively trivial — a+b no longer needs to be split apart; it can only possibly be one identifier
14:58:51 <unkanon> if all symbols are allowed then obviously whitespace will be mandatory, which I'm fine with
14:58:53 <chrisf> oh, not the unary- removal thing again.
14:59:06 <unkanon> oic
14:59:10 <Twey> So you get easier parsing *and* more symbols in identifiers as a side-effect
14:59:16 <unkanon> ploki? hm...
14:59:39 <Twey> It would also stop people writing m>>=f
14:59:44 <unkanon> mauke: that's like LOLCODE
14:59:46 <Twey> Which I consider a worthy goal in itself :þ
14:59:47 <mauke> there's rudimentary documentation but I don't remember if it explains which part of the language allow arbitrary symbols
14:59:50 <hpc> hmm, propose it for haskell 2011?
14:59:52 <mauke> unkanon: but older
15:00:00 <parcs> did someone say side-effects?
15:00:02 <unkanon> wow
15:00:06 <Twey> Haha
15:00:12 <Twey> hpc: I don't think it would get accepted
15:00:18 <Twey> It would break too much code
15:00:25 <Twey> :-\
15:00:26 <unkanon> Twey: I agree with you there
15:00:29 <Twey> Maybe an extension
15:00:43 <hpc> -XEverythingWorksLikeItShould
15:00:47 <Twey> Haha
15:00:47 <monochrom> "REM faculty program in false and ploki" REM? are we back to BASIC?
15:00:50 <unkanon> break code? I thought the point of avoiding success was to be able to change the language?
15:00:56 <hpc> ^
15:01:00 <Twey> unkanon: Yeah, we failed
15:01:06 <unkanon> "now I will DIM this variable..."
15:01:13 <Twey> Haha
15:01:27 <unkanon> DIM makes complete sense.... NOT
15:01:46 <unkanon> Twey: you should propose it anyway and use that as an argument
15:02:05 <unkanon> a-function-like-this would save me so much shift-pressing
15:02:12 <hpc> also, the whole purpose of versions is to change things
15:02:26 <mauke> monochrom: read on :-)
15:02:26 <hpc> if they don't want to break their code, they shouldn't upgrade
15:02:35 <unkanon> that's what I think
15:02:56 <monochrom> a-function-like-this resolves the debate between caml_case and using underscores
15:03:18 <unkanon> see, we can all see advantages to this
15:03:23 <unkanon> Twey, see to it!
15:03:32 <hpc> monochrom: "and so the debate between TRUE and FALSE was finally over; the winner: FILE_NOT_FOUND"
15:03:44 <monochrom> FILE-NOT-FOUND
15:03:44 <revenantphx> Computer's still broken, books are still interesting, and my teacher is still annoying me >_<.
15:04:06 <revenantphx> FILE-NOT-FOUND: CORRUPTING HARD DRIVE TO SEE IF IT CAN BE REGENERATED VIA BOGO-GEN.
15:04:14 <monochrom> there is some rate-my-prof website
15:04:23 <hpc> also, removing the case sensitivity of symbols would be awesome
15:04:35 <hpc> (meaning start constructors with symbols that aren't ':')
15:05:42 <revenantphx> monochrom: the ones for K-12 that I know off, do not cover private school.
15:05:47 <Saizan> well, for prefix constructors too then
15:05:48 <revenantphx> of do*
15:06:04 <monochrom> oh, K-12 you're in?
15:06:13 <revenantphx> 11th, I am.
15:06:39 <monochrom> then all hope is lost. regarding teachers I mean.
15:07:14 <monochrom> K-12 teachers are protected from criticism.
15:08:18 <xplat> any K-12 teachers are okay, except pedos
15:08:52 <revenantphx> monochrom: heh
15:08:54 <int80_h> not any. Too many become teachers for lack of any job skills. The competent often don't get paid crap.
15:09:27 <xplat> int80_h: it wasn't a normative statement from my point of view so much as a summary of the social consensus.
15:09:45 <int80_h> I suspect there's an unwritten assumption people who become teachers do it "for the love", and therefore do not have t
15:09:49 <int80_h> o be paid what they are worth.
15:10:12 <int80_h> xplat well, that's true.
15:11:28 * int80_h lives with tw teachers and gets an earful weekly.
15:14:41 <dark> int80_h, sometimes they become teachers because they want to teach
15:15:03 <int80_h> yeah, btu they have to eat, manage homes and raise families too.
15:15:47 <monochrom> Google programmers do it for love too. They still get paid well.
15:15:48 <dark> i have a lot of teachers that are otherwise competent in their field of expertise. (and in fact they do some consulting. also hm. i'm at university, i think teachers there are instead called professors)
15:16:28 <int80_h> yeah generaly when we refer to someone s a teacher here, we're talking about K-12
15:16:30 <dark> not sure why. in portuguese, there are only one word for both kind of teachers
15:16:35 <revenantphx> The thing about this guy is, when it comes to mathematics, he's great.
15:16:45 <revenantphx> He knows his stuff and is good at explaining it.
15:16:55 <dark> revenantphx, who?
15:17:04 <revenantphx> But when it comes to computer science, he knows the gists of most stuff, but hasn't *really* invested time in understanding them.
15:17:20 <revenantphx> The school's AP CS teacher.
15:18:10 <dark> is there an cs teacher in K-12?
15:18:17 <revenantphx> Yeah, for the AP course.
15:18:24 <dark> AP?
15:18:34 <revenantphx> I forget what it stands for...
15:18:41 <revenantphx> the gist is that at the end you take an exam...
15:18:56 <revenantphx> if you do well, many schools will take that score as either credit, or let you waive entry level classes.
15:19:24 <revenantphx> dark: now they have a silly "let's make sure everyone knows how to use Microsoft Word" type class too, in most schools.
15:19:25 <dark> hmm. o.o
15:19:28 <revenantphx> Which I suppose is good.
15:19:32 <dark> here there are a kind of secondary course called "technical school" where people learn kinds of electrothings or even little CS things. but most secondary schools are instead focused on vestibular (the entry exam for universities)
15:19:44 <revenantphx> But it's amusing to troll the class by championing Open Office (which imo is not good).
15:19:54 <dark> ha
15:19:56 <parcs> ap stands for advanced placement
15:20:05 <dark> I am in love with latex
15:20:06 <revenantphx> More specifically, pretending to be really offended that they didn't mention open source alternatives.
15:20:27 <monochrom> and you see how "advanced placement" is so much more informative that the real explanation
15:20:30 <revenantphx> dark: LaTeX and gnuplot and a collection of scripts save me a lot of time :).
15:20:45 <monochrom> s/that/than/
15:20:49 <revenantphx> I have a ruby script that automatically scrapes definitions and sample sentences for my vocab lists.
15:20:59 <dark> I could never figure out how to do amazing things with office programs. (And I tried really hard. I never find anything through those menus. And the result is always ugly. Both for word and OO)
15:21:00 <revenantphx> And then formats it into a LaTeX document.
15:21:08 <revenantphx> dark: I agree.
15:21:09 <dark> latex is amazing by default
15:21:30 <revenantphx> The sheer awesome of being able to generate a fully-formatted, pretty vocab list is... nice.
15:21:42 <revenantphx> Especially when you forget about it and need it done the next morning.
15:21:57 <revenantphx> Next step, right a script to do my math homework by pulling work/solutions from Mathematica :)
15:22:00 <revenantphx> write*
15:23:09 <monochrom> you can write that script in Mathematica too
15:23:23 <revenantphx> Sounds like a plan.
15:23:30 <dark> revenantphx, how do you compare mathematica and scilab?
15:23:40 <revenantphx> I haven't used either much at all.
15:23:42 <monochrom> you can also use "mathlink" for C binding
15:24:04 <monochrom> then use Haskell FFI on the other end
15:24:10 <revenantphx> hah.
15:24:39 <revenantphx> Now that my computers been fried I need to rewrite my simulation...
15:24:44 <revenantphx> :)
15:24:52 <revenantphx> Well, I have a backup on git
15:25:00 <revenantphx> But it's not super recent.
15:25:23 <meadowlark> revenantphx: and it's in Haskell, so it's only like four lines :P
15:25:36 <revenantphx> I need to go back and thoroughly look into State monad and such. I don't want to have to have ants, ants', ants'', ants''', ants'''' for all the transformations.
15:25:45 <monochrom> hahaha
15:26:00 <revenantphx> I want to be able to arbitrarily insert transformations as I change rules.
15:26:26 <c_wraith> that sounds like the state monad.
15:26:32 <revenantphx> yep yep.
15:27:44 <revenantphx> I'd like to get a simple drawing loop in there too, so I can visualize it a bit.
15:27:50 <revenantphx> It'd help my debugging process.
15:28:17 <revenantphx> And I'd like to use proper gnuplot bindings (which I see are in hackage). Outputting to a file and then using a script was a bit cumbersome.
15:28:57 <revenantphx> I'd like a lot of things... >_<
15:32:43 <ddarius> @hackage pony
15:32:43 <lambdabot> http://hackage.haskell.org/package/pony
15:37:21 <revenantphx> I'd like to see a package that exists solely to trigger blue screens of death on old Windows 95/98 systems.
15:37:43 * hackagebot HStringTemplate 0.6.6 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.6 (SterlingClover)
15:37:43 <Pseudonym> revenantphx: They're called third-party device drivers.
15:39:48 <revenantphx> Pseudonym: ba dum KISH
15:39:58 <revenantphx> I meant a haskell package though.
15:40:04 <revenantphx> unsafePerformBSOD
15:40:09 <revenantphx> something along those lines.
15:40:43 <shachaf> unsafePerformF00fc7c8
15:41:07 <revenantphx> unsafePerformDEADBEEF
15:41:30 <Pseudonym> This reminds me of something my brother told me when he was doing his Novell certification many years ago.
15:41:47 <Pseudonym> Someone asked: "I need to do some testing.  How can I deliberately crash a Novell server?"
15:41:53 <Pseudonym> Reply: "Take two weeks leave."
15:41:59 <revenantphx> XD
15:42:23 <revenantphx> Now to figure out a way to reliably create a BSOD
15:42:32 <revenantphx> Preferably a not-so-serious one.
15:42:45 <revenantphx> Overwriting everything in memory with bogus might do the trick.
15:43:11 <revenantphx> OS won't let me though >_<
15:43:43 <Pseudonym> http://knowyourmeme.com/i/18675/original/microsoft-blue-screen-of-death-bsod-tattoo_49-765346-765611.jpg <- Someone's tattoo.
15:43:44 <ddarius> revenantphx: It would be trivial to make a BSOD in Win95/98.  The OS doesn't stop you at all.
15:43:58 <revenantphx> ddarius: hah, that'd be convenient.
15:44:03 <revenantphx> I've only used W2K+
15:44:14 <revenantphx> So if I wanted I could do something like
15:44:42 <ddarius> Pseudonym: I'm sure that impresses all the girls.
15:44:57 <Pseudonym> It impresses the _right_ girls.
15:45:29 <revenantphx> Actually, kmem roulette might be an easier method :D
15:45:31 <ddarius> Somehow I doubt that.
15:45:45 <Pseudonym> http://pcsupport.about.com/od/tipstricks/ht/makebsodxp.htm
15:45:52 <Pseudonym> That apparently works on XP.
15:46:00 <revenantphx> Pseudonym: If by "_right_ girls" you mean mac fangirls.
15:46:15 <revenantphx> (or gay fanboys)
15:46:47 <revenantphx> for(size_t p = null;;p++){*p = 0xDEADBEEF;}
15:46:58 <revenantphx> oh wait, not quite >_<
15:47:10 <revenantphx> don't want to be dereferencing null there XD.
15:48:03 <ddarius> That's just going to GPF.
15:48:26 <revenantphx> blargh.
15:49:12 <revenantphx> while(1){void *p = malloc(1048576)}
15:49:33 <revenantphx> Nah, probably wouldn't work either. Seems like the people who made the computers were a wee bit smart after all...
15:51:16 <chrisf> revenantphx: a while back there was a very nice remote BSOD in the SMB2 protocol driver..
15:51:25 <revenantphx> heh
15:51:29 <ddarius> The people who made the 386 were smart enough, Win95/98 just fails to use the protection mechanisms correctly.
15:51:33 <ddarius> (Possibly by design.)
15:53:59 <Pseudonym> Buggy device drivers have historically been the cause of most BSoDs that I'm aware of.
15:53:59 <chrisf> i imagine it makes a good deal of the win9x hackery easier.
15:56:06 <chrisf> Pseudonym: well, that's how it ought to be. if user code can knock the machine over, someone in kernel land did it wrong :)
15:57:08 <chrisf> where 'someone' is usually nvidia, for the last 10 years :)
15:57:21 <ddarius> Pseudonym: Most user level programs have a low probability of doing real damage before GPFing.
15:58:23 <ddarius> However, the WinCIH virus just does something completely direct to get kernel 0 privileges, and something that is straightforward to block.
16:21:53 <elliott> I can't believe "instance Foo Bar where ..." isn't valid Haskell98 if Bar :: *.
16:21:58 <elliott> Who came up with that restriction?
16:22:09 <elliott> Oh, wait, never mind, Bar is a "type Bar = ..." >_<
16:22:43 <ddarius> elliott: The fact that Int is an instance of Eq should have tipped you off.
16:22:55 <elliott> ddarius: I'm not so smrt.
16:23:46 <elliott> What's the recommended way to combine two libraries using different kinds of bytestring (lazy vs. strict) without pain? Or is the recommended way pain?
16:23:49 <ddarius> That said the restriction on type synonyms is a bit silly.
16:24:26 <elliott> ddarius: A lot of Haskell 98 is awfully silly...
16:24:51 <elliott> ddarius: Like removing monad comprehensions, because they make error messages less obvious. Clearly they had not yet grasped just how hard the GHC team were working on making error messages impossible to understand at the time.
16:25:01 <elliott> (At least that's the justification I've heard.)
16:27:03 <tg_> "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."
16:27:03 <tg_> - Brian W. Kernighan.
16:27:22 <elliott> tg_: I can disprove that.
16:27:23 <elliott> tg_: Oleg.
16:27:45 <tg_> elliott: I was suggesting that might be a source for the relative impossibility of understanding GHC errors
16:27:59 <elliott> tg_: You can't apply any quote to Haskell if it falls down on Oleg :-)
16:28:16 <elliott> tg_: But yeah, GHC's error messages could be smarter though.
16:28:24 <elliott> Just special-casing simpler, more obvious messages in restricted cases.
16:28:39 <sproingie> monad comprehensions look to be coming back though
16:28:41 * ddarius considers making a type checker than will produce a comprehensive list of ways to fix code with errors so that you can have a menu-driven interface to fix type errors.
16:28:52 <ddarius> Then I intend to sit back and cackle as I unleash it upon the world.
16:29:05 <elliott> ddarius: They made one of them. It's called Coq.
16:29:21 <tg_> Yeah, everyone likes the coq
16:29:47 <sproingie> most java ide's also have quick-assists that fix errors or warnings
16:29:52 <sproingie> mostly good for warnings tho
16:30:13 <tg_> sproingie: that always seemed like a bad thing to me
16:30:32 <sproingie> no doubt backed up by the "real men" argument
16:30:33 <tg_> I don't want Clippy popping up every few minutes to remind me how stupid I am
16:31:00 <tg_> nein, real men use the best tools they can for the job
16:31:12 <sproingie> well good thing it doesn't pop up
16:31:17 <elliott> yeah eclipse always irritated me with its red squiggly underlines and sidebar icons... I appreciate the sentiment
16:31:20 <elliott> it's just implemented obnoxiously
16:31:35 <sproingie> idea does it a little better
16:31:39 <elliott> a very light red background for erroring code, and warning/error text perhaps appearing in another pane, would be more acceptable, IMO.
16:31:41 <sproingie> actually a lot better
16:31:42 <elliott> sproingie: How does IDEA do it?
16:31:57 <sproingie> elliott: pretty much the same but it has smarter fixes in general
16:32:31 <sproingie> i prefer the IDE to be obnoxious rather than the compiler
16:32:52 <sproingie> you can change the squiggly style to whatever style you like in most ide's
16:33:34 <sproingie> haskell + flymake = love.  long as you're on a fast machine :)
16:33:56 <elliott> i thought flymake would be awesome, but it turns out it's not as nearly as smart as I was hoping it would be :(
16:38:22 <ddarius> "These results generalize when Set is replaced with a locally finitely presentable enriched category."
16:44:18 <djahandarie> Where do I get me one of those?
16:45:57 <djahandarie> And does that mean a category where the objects are finitely presentable or does it mean the category itself is finitely presentable??
16:47:05 <djahandarie> s/??/?/ -- I'm not THAT interested
16:48:23 <Bynbo7> ha
16:53:13 <ntc2> Hi. I'm having cabal trouble: a package (RepLib-0.3) I need changed its dependencies from base >= 4.2 to base >= 4.3, and now cabal install of RepLib fails with "... base-4.3.0.0 was excluded because of the top level dependency base -any".  Any ideas?
16:54:57 <ntc2> I tried manually installing base-4.3.0.0, but that fails too: cabal install base-4.3.0.0 gives "... config.status: error: cannot find input file: `base.buildinfo.in'"
16:56:01 <Bynbo7> which ghc is base 4.3 tied to?
16:56:21 <ntc2> I'm using ghc 6.12.1.
16:56:41 <ntc2> How do I tell which ghc it's tied to?
16:57:52 <Bynbo7> i'm not sure, but each base version is part of a ghc version, they're heavily linked, and should not be installed by users
17:00:52 <monochrom> Each GHC user guide has release notes stating its base version.
17:01:23 <monochrom> example. "1.5.10.2. base ... Version number 4.3.0.0 (was 4.2.0.2)" is in the user guide of GHC 7.0.1
17:01:57 <monochrom> you could also unpack each GHC tarball and look.
17:02:53 <ntc2> OK, 6.12.1 lists base 4.2.0.1 (was 4.2.0.0).
17:03:18 <ntc2> `cabal list base` shows 4.3.0.0 as latest version, but I guess that's independent of my ghc version?
17:03:29 <monochrom> correct.
17:03:33 <sshc> Should I hClose the Handle returned by Network.accept before accepting another connection on the same socket?
17:03:37 <ntc2> (by "6.12.1" lists I mean "the user guide for ...")
17:03:51 <monochrom> "cabal list base" asks the hackage.haskell.org website
17:04:19 <ntc2> So, does this mean I should install ghc 7 if I want base >= 4.3?
17:04:25 <monochrom> yes
17:04:35 <ntc2> OK, thanks!
17:04:36 <monochrom> sshc: no need
17:05:48 <Bynbo7> sshc: close the handle when you've finished using it. accept doesn't care about it once it's been accepted
17:35:09 <mun> hi
17:35:26 <mun> is \lambda x y. x f y equivalent to f?
17:36:23 <lispy> mun: it's not valid haskell :)
17:36:33 <lispy> > \lambda x y. x f x
17:36:33 <lambdabot>   <no location info>: parse error on input `.'
17:36:44 <lispy> > \lambda x y -> x f y
17:36:45 <lambdabot>   Overlapping instances for GHC.Show.Show
17:36:45 <lambdabot>                              (t -> ...
17:36:48 <siorai> > \ x y . x f x
17:36:48 <lambdabot>   <no location info>: parse error on input `.'
17:36:54 <Saizan> "\x y -> f x y" would be, if f has a suitable type
17:36:54 <siorai> > \ x y -> x f x
17:36:55 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t -> t1
17:36:57 <siorai> yeah
17:36:59 <siorai> there we go
17:36:59 <siorai> heh
17:37:32 <Saizan> mun: is f an infix operator in your case, though?
17:37:35 <lispy> > \x y -> x f y
17:37:35 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> t -> t1) -> t -> t1)
17:37:36 <lambdabot>    aris...
17:37:44 <siorai> or \ x y -> x `f` y
17:37:55 <c_wraith> yeah...  \x y -> x f y when applied to g and h would reduce to g f h, whereas f when applied to g and h would reduce to f g h
17:37:59 <c_wraith> Those aren't the same
17:38:16 <mun> Saizan, no it's not.
17:38:22 <mun> i guess i made an error. sorry.
17:38:23 <mun> thanks
17:39:15 <thisisnotmynick> \x y -> f x y is the same as f, if f can receive 2 or more arguments
17:39:25 <mun> yep
17:39:45 <ddarius> And f /= undefined and f x /= undefined.
17:40:08 <ddarius> and f x y /= undefined (which subsumes the latter cases.)
17:40:18 <ddarius> And by latter I mean former.
17:40:57 <djahandarie> ddarius, so was I right or was I right?
17:42:46 <Saizan> seq on functions makes everything more complicated :P
17:42:49 <monochrom> "yes" :)
17:43:30 <djahandarie> ⊕!
17:43:50 <monochrom> oh, then "no" :)
17:43:59 <djahandarie> Damn
17:45:11 <monochrom> well you know how b `xor` b = false
17:45:13 <ddarius> djahandarie: A category is finitely presentable if, for all object X, Hom(X,-) preserves filtered colimits.
17:45:28 <ddarius> A locally finitely presentable category is not necessarily finitely presentable.
17:45:43 <djahandarie> Okay, but the objects are finitely presentable
17:46:20 * hackagebot ssh 0.2.1 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.1 (AlexSuraci)
17:46:41 <djahandarie> Was just trying to parse whether it was (locally finitely presentable category) or locally (finitely presentable category)... though thinking about it now the second doesn't make much sense
17:47:03 <djahandarie> And crap, put the parens in the wrong place for the first... lol
17:47:06 * djahandarie resigns
17:48:17 <alexsuraci> yay, removed the Crypto dependency from ssh
17:48:38 <alexsuraci> next up is HsOpenSSL ideally
17:52:54 <ddarius> Actually, I'm not sure if finitely presentable is applied to categories alone.  I misspoke above.  An object is a category is finitely presentable if Hom(X,-) preserves filtered colimits.  A locally finitely presentable category is not one where every object is finitely presentable.
17:54:53 <ddarius> A category is locally finitely presentable very roughly if every object X of C is a filtered colimit of the diagram Hom(ι-,X) where ι : C_fp -> C the inclusion of the full subcategory of all finitely presentable objects into C.
18:14:34 <etpace> @Hoogle Map k a -> Map k b -> Map k b
18:14:34 <lambdabot> Maybe you meant: google hoogle
18:14:51 <etpace> @hoogle Map k a -> Map k b -> Map k b
18:14:51 <lambdabot> Data.Map (\\) :: Ord k => Map k a -> Map k b -> Map k a
18:14:51 <lambdabot> Data.Map difference :: Ord k => Map k a -> Map k b -> Map k a
18:14:51 <lambdabot> Data.Map intersection :: Ord k => Map k a -> Map k b -> Map k a
18:16:56 <sm> what do you call a data declaration with a where clause ?
18:17:04 <monochrom> GADT
18:17:17 <sm> thanks.. hrm.
18:17:30 <monochrom> {-# LANGUAGE GADTs #-}
18:17:34 <enoksrd> G = generalized
18:17:50 <sm> if it had just constructors with no where, it would be an ADT ?
18:18:24 <monochrom> yes
18:19:00 * sm reads up on the wiki.. which is quite enjoyable now I must say
18:30:41 <etpace> j css
18:30:43 <etpace> oops!
18:42:00 <adnap> is this the simplest way to get the branches of a tree?  i feel it's a bit ugly, and i wonder if there's a way to do it all in one function: http://hpaste.org/42366/branches
18:46:41 <Veinor> is the haskell platform recommended for linux, or should I just use my distribution's repos?
18:47:07 <Axman6> your distro should have the haskell platform :\
18:47:26 <Veinor> it does
18:47:47 <Veinor> well... I guess what I'm asking is, should I apt-get install haskell-platform?
18:47:55 <Zao> Most probably.
18:47:55 <liyang> Yes, do that.
18:47:58 <Axman6> sure
18:48:21 <ntc2> I'm still having trouble with base >= 4.3 requirements: turns out I don't actually need base >= 4.3, but cabal thinks I do :P
18:48:22 <ntc2> The problem is that cabal is looking up the dependencies in two different places at two different times:
18:48:24 <adnap> what does haskell-platform have that ghc doesn't have?
18:48:48 <Axman6> more packages
18:48:50 <adnap> does it come with cabal or something?
18:48:56 <ManateeLazyCat> adnap: Manay packages, include cabal
18:48:57 <Axman6> like network, cabal-install
18:48:57 <adnap> cabal-install, rather
18:49:02 <tswett> @djinn ((a -> c) -> c) -> (((a -> b) -> c) -> c) -> (b -> c) -> c
18:49:02 <lambdabot> f a b c = b (\ d -> a (\ e -> c (d e)))
18:49:03 <Veinor> yeah
18:49:10 <Veinor> but the haskell-platform package also uses GHC 6.12.1 :/
18:49:25 <adnap> can you cabal install ghc?
18:49:29 <winxordie> Anyone familiar with the merits of Data.Heap vs meldable-heap?
18:49:36 <ManateeLazyCat> adnap: No.
18:49:36 <tswett> lambdabot: you make it look so minting easy.
18:49:50 <ManateeLazyCat> adnap: You need install ghc first, then use cabal install other packages.
18:50:08 <adnap> i was wondering if you could upgrade ghc via cabal
18:50:11 <ntc2> (1) I'm installing a package from source (RepLib-3.0) with `cabal install` in the dir with the RepLib.cabal file.  The RepLib.cabal file lists base >= 4.2 as a dependency.  
18:50:13 <ntc2> (2) However, I have another package I need to install from source (trellys-core-0.0), which lists RepLib >= 0.3 as a dependency, and cabal thinks that RepLib-0.3 has base >= 4.3 as a dependency, when it tries to resolve the trellys-core-0.0 dependencies :P
18:50:58 <not_equals_in_hs> ehlo?
18:51:10 <adnap> ntc2: why not get base >= 4.3?
18:51:12 <not_equals_in_hs> my router just reset it's self so I'm not sure if you can hear me
18:51:22 <adnap> not_equals_in_hs: yes, we can
18:51:30 <not_equals_in_hs> so, I'm wondering how the not equal is expressed in haskell
18:51:32 <ntc2> The RepLib-0.3 in hackage does have base >= 4.3 as a dependency, but the local version I installed form source does not.  How do I tell cabal to use the local RepLib dependencies?
18:51:44 <ManateeLazyCat> adnap: Every ghc include different base library and Cabal, so you can't. :)
18:51:51 <adnap> not_equals_in_hs: /=
18:51:56 <not_equals_in_hs> ahh
18:51:59 <int80_h> how do I specify which package to import a module from without cabal?
18:52:28 <ntc2> adnap: I tried using base >= 4.3, by installing ghc7, but it turns out that trellys-core-0.0 is not compatible with the current RepLib-3.0 that uses base >= 4.3 :P
18:52:55 <adnap> ntc2: maybe you can modify the cabal file to suit your needs
18:53:08 <ManateeLazyCat> int80_h: You can put your source code under *same* directory, but best use cabal. :) 
18:53:23 <adnap> did anyone see my "branches" code?
18:54:46 <int80_h> ManateeLazyCat: so there is no ghc argument I can pass, or a keyword I can use in my source?
18:55:55 <int80_h> okay, I'll do it right. I was reading the cabal documentation. Maybe not closely enough because I could not find the cabal keyword to specify packages. Say my module name is foo, what does the cabal line look like ?
18:56:10 <ManateeLazyCat> int80_h: I give you a example, you have two files, A.hs and B.hs, and A.hs depend on B.hs, when you use ghc compile A.hs, you can do "ghc --make A.hs /yourpath/B.hs"
18:56:15 <ntc2> adnap: which cabal file?
18:56:55 <adnap> ntc2: oh, i was thinking you had the source downloaded.  you could always download the source and then modify the cabal file it comes with that has the dependencies.
18:57:00 <ManateeLazyCat> int80_h: If you put A.hs and B.hs at *same* directory, ghc will find B.hs, if not, you need pass the path of B.hs to ghc. 
18:57:33 <int80_h> ManateeLazyCat: I'll do it the proper way. But having trouble locating the right cabal keyword to use.
18:58:06 <adnap> ntc2: does tre
18:58:17 <adnap> ntc2: does trellys-core have base >= 4.3 as a dependency?
18:58:22 <ntc2> adnap: i have the source for all packages I'm trying to install, but not the *newest* source.
18:58:37 <ManateeLazyCat> int80_h: Cabal is package manager, when you create/install cabal package, Cabal will register your packages to cabal/ghc database.
18:58:57 <ntc2> adnap: no, trellys-core has base >= 4
18:59:06 <interferon> so i have a project whose cabal file specifies that Control.Monad.CatchIO should be loaded from a specific package, but when i try to load the .hs file from ghci, it says the package is ambiguous
18:59:15 <adnap> ntc2: what is 
18:59:32 <adnap> ntc2: what is causing cabal to think base >= 4.3 is needed?
18:59:34 <ManateeLazyCat> int80_h: In foo.cabal, you can write which package you need depend, then you can write "import ..." in your source code, Cabal will help you find import modules in database
19:00:00 <ntc2> adnap: the RepLib-0.3 on hackage requires base >= 4.3
19:00:26 <adnap> ntc2: but you want the replib that has base >= 4.2, right?
19:01:17 <ntc2> adnap: the RepLib-0.3 i'm installing from source locally is a "pre-release" version (brought in with a svn:external for a fixed revision) and has base >= 4.2 as a requirement.
19:01:21 <int80_h> ManateeLazyCat: I realize what cabal can do for me. I don't know what the cbal command is to do this. If the package is named foo, and the module from it I want to use is bar, what does the cabal command look like to make sure I only get the module bar that is in foo?
19:01:28 <ntc2> adnap: yes
19:01:41 <interferon> i have the most recent haskell platform installed (i think it's from March) - can install ghc 7.0 over it or do i need to wait for the new haskell platform?
19:02:07 <int80_h> it's "keyword something something" but that's not getting me very far. I don't know what the details are.
19:02:07 <adnap> ntc2: ah, i see the problem
19:02:22 <ntc2> adnap: so, i guess the problem is that the two RepLibs have the same version, 0.3, but different deps?
19:02:50 <Saizan> ntc2: you should bump the version of your local one when you install it
19:02:59 <adnap> ntc2: so, you can install the pre-release replib okay, right?
19:03:08 <ntc2> adnap: yes
19:03:19 <Saizan> ntc2: so edit the .cabal file so that it says "version: 0.3.1" and then run "cabal install" with no arguments from that dir
19:03:25 <ntc2> Saizan: OK, trying that ...
19:03:37 <adnap> ntc2: but then when you go to install trelleys, it thinks you need replib from hackage, which has a different dependency
19:03:59 <Saizan> cabal assumes that all the 0.3 versions are created equal :)
19:04:32 <adnap> Saizan: why would it check for replib on hackage if the pre-release version is already installed with the same version number?
19:04:34 <Saizan> so if it finds it can't configure the one on hackage, it assumes that it also can't use the already installed one
19:04:43 <int80_h> Saizan, maybe you could help me with this?
19:05:00 <Saizan> adnap: because in general the fact that a lib is installed doesn't mean it can be used in the current install plan
19:05:11 <adnap> int80_h: why do you only want one module from a package?
19:05:23 <adnap> int80_h: why don't you just get the whole package and then import the one module?
19:05:26 <Saizan> adnap: it might still conflict with other libs you're trying to use
19:05:35 <Saizan> int80_h: what's the problem?
19:06:05 <ManateeLazyCat> Saizan: int80_h don't know how to use Cabal. :)
19:06:19 <ManateeLazyCat> int80_h: Simple, use "cabal install"
19:06:33 <ntc2> adnap, Saizan: the version bump worked.  Thanks, you guys rock!
19:06:36 <ManateeLazyCat> int80_h: Other work, such as find module from package, Cabal will do it for you. :)
19:07:34 <adnap> Saizan: were you here when i posted my branches code?
19:08:16 <int80_h> ManateeLazyCat it will do it for me, when I tell it what to do, I've been trying to communicate to you, that I don't know how and trying to figure that out.
19:08:27 <Saizan> interferon: you can install ghc 7, but it won't have access to the haskell platform libs, you'll have to install the ones you need from hackage, otoh, you can keep more than one ghc installed
19:08:33 <Saizan> adnap: i don't think so
19:08:35 <adnap> int80_h: if the package name is foo, you do "cabal install foo"
19:09:04 <adnap> int80_h: if there is a specific module in foo that you need, you still do "cabal install foo" and then you import the specific module in your program.
19:09:19 <int80_h> Saizan: so the problem is, I have a program using a module in two different packages. How do I tell cabal to only use the module foo from package bar?
19:09:24 * ManateeLazyCat pasted "manatee.cabal" at http://paste2.org/get/1146374
19:09:25 <ManateeLazyCat> int80_h: Above is my project's cabal file, a bit little complicated...
19:09:34 <adnap> Saizan: can you tell me if there is a simpler way than this to get the branches of a tree: http://hpaste.org/42366/branches
19:09:42 <int80_h> adnap: thanks but you're solving someone elses problem. I appreciate the effort though.
19:09:56 <Saizan> int80_h: do you need to use both packages in this program?
19:11:08 <int80_h> Saizan: no, just one
19:11:10 <adnap> int80_h: oh, it seemed like your question was different earlier.
19:11:46 <ManateeLazyCat> int80_h: So you create directory 'foo' and file 'foo/foo.cabal' , you can edit information in foo.cabal. such as, name version, and you can add package name in keyword 'build-depends', then all you need do is import any module you want in your source code. Cabal will find those modules for you when you do "cabal install" at directory 'foo'
19:11:46 <adnap> int80_h: do you have two distinct packages that definite a module with the same name?
19:11:49 <int80_h> adnap: no worries. I often don't say what I mean because I get confused
19:11:56 <Saizan> adnap: can you clarify what you mean by branches?
19:12:02 <phao> is there any function like fromInteger and toInteger, but for Int?
19:12:17 <copumpkin> :t fromIntegral
19:12:18 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:12:25 <phao> right
19:12:26 <phao> thx
19:12:54 <adnap> Saizan: Branches represent one path down the tree.
19:13:05 <Saizan> int80_h: doing this with cabal requires you to create a .cabal file for your program, put the package bar and other you need in the build-depends: field, and then build your program with cabal install
19:13:30 <int80_h> so, if the package I want to use is "foo", I would include the line "build-depends foo" right?
19:13:41 <Saizan> build-depends: foo
19:13:42 <int80_h> ah yes thank you 
19:14:01 <ManateeLazyCat> int80_h: yes.
19:14:02 <Saizan> but you also need other fields in the .cabal file
19:14:20 <Saizan> int80_h: you can use "cabal init" to create a new basic one
19:14:50 <Saizan> another way is to pass -hide-package theotherpackageyoudon'twant to ghc or ghci
19:15:00 <Saizan> or use ghc-pkg hide
19:15:16 <int80_h> I could have used -hide-package?! Ugh I will just do that
19:16:14 <Saizan> adnap: i'd just follow the HLint hint there
19:16:35 <Saizan> or maybe i'd use a list comprehension
19:16:51 <Saizan> but they all amound to the same more or less
19:17:30 <adnap> Saizan: yeah, i essentially have the hint commented out in the code.  i was just wondering if it was possible to write the function as one expression, without having to pattern match for a tree with no children.
19:17:58 <adnap> Saizan: and also not resorting to an if then else
19:20:06 <Switch> why is haskell
19:20:10 <Switch> ASJFDSDJFJSDFJFD
19:20:15 <Starscream> Can GHC compile Haskell to C? I'm having trouble finding a definitive answer.
19:20:32 <Adamant> Starfire: yes, for some values of C
19:20:50 <danderson> but, mostly, don't
19:20:51 <Starscream> What does that mean?
19:20:52 <Adamant> it's compilable by gcc because it uses extensions
19:21:01 <danderson> let the native and/or LLVM backends do the work
19:21:17 <Starscream> Oh, I'm just looking at if for curiousity
19:21:18 <Adamant> unless you really need it in C, compiling to C is a bad idea at this point
19:21:23 <c_wraith> If you really want to compile to C, look at JHC
19:23:03 <danderson> Starscream: for reference, the C backend was the first GHC backend
19:23:31 * ddarius wanders nLab.
19:23:42 <danderson> IIRC, it produces C, uses gcc to compile that to assembler, and then has horrible procedural hacks to monkey with the assembler in order to implement the calling conventions and related fun stuff
19:23:55 <danderson> and then tells gcc to assemble/link that
19:24:16 <ddarius> GHC compiles to C in two ways.
19:24:36 <ddarius> Also, the "horrible procedural hack" that danderson mentions is the Evil Mangler which is written in Perl.
19:24:53 <danderson> right, that one.
19:25:03 <chrisf> it's pretty evil.
19:25:11 <danderson> ddarius was probably involved in all this, I only know of it at the level of ancient lore retold through the centuries :)
19:26:20 <danderson> so, as a morbid curiosity, it's interesting to explore
19:26:26 <ddarius> No, that all happened long before I joined the Haskell community.
19:26:45 <danderson> for development, the native or LLVM backends are now the strong preference.
19:27:00 <danderson> and LLVM is the Way of the Future
19:27:58 <chrisf> must be, because the future is really really big... like LLVM.
19:28:26 <danderson> heh
19:28:43 <danderson> if the compiler has to put on a few pounds to produce better programs, fine :)
19:30:11 <chrisf> actually, i think the bulk of its bloat is c++-induced junk.
19:30:13 <ddarius> Woo, a nice succinct definition of sieve.
19:31:01 <ddarius> The NCG has quite a bit of potential.  Unfortunately, in part due to the LLVM backend, it will probably never be fully realized.
19:32:05 <danderson> yeah.
19:32:17 <danderson> feels a little like a research vs. industry thing
19:32:48 <JuanDaugherty> you mean academe vs. industry don't you?
19:32:53 <danderson> do you implement cool new and exciting things in NGC, or use LLVM and get the combined benefits of all the work going into it?
19:32:58 <danderson> possibly.
19:33:37 <JuanDaugherty> s/?/./
19:33:40 <the_dude_q> hey
19:33:52 <the_dude_q> why does "map (+1) [1,2,3]" work
19:33:59 <the_dude_q> but not "map (-1) [1,2,3]"
19:34:47 <thisisnotmynick> hahaha
19:34:50 <ddarius> The thing is the NCG makes it very easy to implement new things, not only because it is written in Haskell, but also because of the fairly unique technology in it.  And of course, the NCG has none of the limitations of LLVM.
19:35:04 <thisisnotmynick> the_dude_q, some people at haskell community are really upset with this inconsistency
19:35:06 <the_dude_q> what did I do wrong?
19:35:18 <ddarius> the_dude_q: You didn't read the Report.
19:35:19 <ntc2> the_dude_q: it's treating the - as unary
19:35:44 <the_dude_q> I have gotten a somewhat acceptable result with "map ( (-)1 ) [1,2,3]"
19:35:50 <the_dude_q> i've only been using haskell for 10 minutes
19:35:56 <the_dude_q> but after that you have to map +1
19:36:05 <thisisnotmynick> (+ a) is \x -> x + a
19:36:25 <c_wraith> > map (subtract 5) [1..10]
19:36:26 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4,5]
19:36:26 <thisisnotmynick> but (- a) is just -1 times a
19:37:10 <ddarius> subtract was defined pretty much specifically for this
19:37:33 <the_dude_q> ok, thanks...  This would be really great learning tool--this IRC channel.
19:37:36 <sm> the_dude_q: it's because haskell requires negative numbers to be parenthesised, (-1) is -1. map (+(-1)) [1,2,3] works
19:37:45 <ntc2> the_dude_q: the ((-)1) is equiv \x.1-x, but you want \x.x-1
19:37:45 <Zao> @type (-1)
19:37:46 <lambdabot> forall a. (Num a) => a
19:37:47 <the_dude_q> ohhh
19:38:12 <ntc2> which is (subtract 1)
19:38:22 <the_dude_q> I don't know what the definition of the "map" function is
19:38:49 <Boxo> @src map
19:38:49 <lambdabot> map _ []     = []
19:38:49 <lambdabot> map f (x:xs) = f x : map f xs
19:38:52 <chrisf> @type (- 1)
19:38:53 <lambdabot> forall a. (Num a) => a
19:39:58 <the_dude_q> confusing syntax to me, but I did start to understand it a bit with the interactive help/learning thingy
19:40:06 <thisisnotmynick> the_dude_q, (-) is - as a function that receives two parameters and subtract the second from the first. it is the same as \x y -> x - y. so ((-) 1) is ((\x y -> x - y) 1) that is \y -> 1 - y. (I hope you figured out this lambda thing. \x -> y is the function that receives x and returns y)
19:40:12 <JuanDaugherty> ddarius, how then is it that the NCG has a LLVM backend and at the same time none of it's limitations
19:40:16 <Boxo> > map f [a,b,c]
19:40:17 <lambdabot>   Ambiguous type variable `b' in the constraints:
19:40:17 <lambdabot>    `GHC.Show.Show b'
19:40:17 <lambdabot>      a...
19:40:31 <JuanDaugherty> ?
19:40:57 <Boxo> hm, wasn't there a lambdabot thing that returns "[f a, f b, f c]" if you give it that
19:41:00 <thisisnotmynick> > 1 `(-)` 2
19:41:00 <lambdabot>   <no location info>: parse error on input `('
19:41:01 <parcs> > map f [a,b,c] :: [Expr]
19:41:02 <lambdabot>   [f a,f b,f c]
19:41:06 <Boxo> that's it
19:41:07 <chrisf> @type ((-)1)
19:41:08 <lambdabot> forall t. (Num t) => t -> t
19:41:08 <elliott> I notice that acme-dont depends on base <1000000. Are there any plans for porting when base 1000000 comes out?
19:41:17 <elliott> I don't want to use a library I can't rely on to be future-proof.
19:41:23 <JuanDaugherty> is it in some sense independent of the LLVM and also doesn't ghc generate native code?
19:41:35 <ntc2> the_dude_q: you can also define map as (foldr ((:) . f) []), but you probably haven't seen foldr in your 10 minutes of haskell
19:42:11 <thisisnotmynick> ntc2, and what about foldl? you would have to reverse it afterwards right?
19:42:33 <thisisnotmynick> foldr is not tail recursive
19:42:54 <ntc2> thisisnotmynick: i think you have to careful with foldl, since foldl is strict in the list argument
19:43:16 <thisisnotmynick> oh, why? performance?
19:43:44 <thisisnotmynick> but shouldn't foldr be strict too? (you need to begin from the end)
19:43:54 <ntc2> > let map = foldr ((:) . f) [] in take 1 $ map id [1..]
19:43:54 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> a1'
19:44:22 <the_dude_q> I only could interpret a couple of lines you've posted so far.
19:44:30 <Switch>  -------------- SLaP Me SuMMa DaT PLuS oH! -------------------
19:44:30 <Switch>     <<<<                 +o+o+o+o+o+ o+o+o+o+o+o+ o+o+o+o+o+o
19:44:30 <Switch>    <<<<                  o+o     o+o +o+      o+o +o+
19:44:30 <Switch>   <<<<                   +o+     +o+ o+o      +o+ o+o
19:44:30 <Switch>  <<<<=================   o+o     o+o +o+      o+o +o+o+o+o+o+
19:44:30 <ntc2> > let map f = foldr ((:) . f) [] in take 1 $ map id [1..]
19:44:31 <Switch>  <<<<=================   +o+     +o+ o+o+o+o+o+o+ o+o+o+o+o+o
19:44:31 <lambdabot>   [1]
19:44:33 <Switch>   <<<<                   o+o     o+o +o+                  +o+
19:44:37 <Switch>    <<<<                  +o+     +o+ o+o                  o+o
19:44:37 --- mode: ChanServ set +o Cale
19:44:38 <c_wraith> @where ops
19:44:38 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
19:44:39 <Switch>     <<<<                 o+o+o+o+o+o +o+          +o+o+o+o+o+
19:44:41 <Switch> -------------- SLaP Me SuMMa DaT PLuS oH! -------------------
19:44:42 --- mode: Cale set +b *!*@hades.skidsr.us
19:44:42 --- kick: Switch was kicked by Cale (Switch)
19:44:43 --- mode: ChanServ set +o monochrom
19:44:54 <c_wraith> Cale is the fastest in the land!
19:45:07 <ntc2> thisisnotmynick: what i mean is, a foldl based version probably won't work for infinite lists, as in the examplle
19:45:14 --- mode: monochrom set -o monochrom
19:45:18 --- mode: Cale set -o Cale
19:45:34 <Boxo> > let map f = foldr (\x xs -> f x : xs) [] in map (*2) [0..]
19:45:35 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
19:45:55 <Cale> > let map f = foldr ((:) . f) [] in map (*2) [0..]
19:45:56 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
19:46:00 <ntc2> thisisnotmynick: and foldr is not strict, is in my and Boxo's examples
19:46:01 <thisisnotmynick> the_dude_q, sorry. in fact i had a hard time learning the few i know, there is no problem you spend some time without understanding the inner details
19:46:08 * zakwilson thought Switch was trying to post obfuscated Haskell.
19:46:20 <ntc2> ... and Cale's :)
19:46:23 <thisisnotmynick> @src foldr
19:46:23 <lambdabot> foldr f z []     = z
19:46:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:46:27 <c_wraith> > foldl (flip const) 0 [1..10]
19:46:27 <lambdabot>   10
19:46:41 <c_wraith> not lazy at all :)
19:47:03 <thisisnotmynick> @src foldl
19:47:03 <lambdabot> foldl f z []     = z
19:47:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:47:11 <thisisnotmynick> isn't there some non-strict foldl out there?
19:47:13 <the_dude_q> I decided to give Haskell a whirl because my ~2-3 GB C++ compiler is going to take me around 12 hours to download.  I'm glad I did too.
19:47:42 <thisisnotmynick> the_dude_q, oh nice :) windows?
19:47:49 <the_dude_q> of course
19:47:54 <the_dude_q> VS2010 (from dreamspark)
19:48:00 <the_dude_q> free for students :D
19:48:10 <thisisnotmynick> it's more of an ide
19:48:21 <the_dude_q> I use compiler/ide interchangeably
19:48:33 <the_dude_q> hmm
19:48:41 <the_dude_q> is there any way to use the windows API with Haskell?
19:49:18 <c_wraith> win32 stuff, you mean?
19:49:30 <ntc2> thisisnotmynick: i don't it's possible to write a non-strict foldl, since the top level application of the combining function has the *last* element of the list as second arg
19:49:34 <the_dude_q> Yep, the C API for Windows.
19:49:47 <c_wraith> I don't think anyone's made any bindings to that.  It's kind of...  huge.
19:50:14 <the_dude_q> A good way to make bindings to certain functions would be excellent...
19:50:34 <the_dude_q> like the import or declspec or w/e those C# developers use
19:51:01 <c_wraith> haskell's FFI is pretty easy to use, but I haven't tried binding to the windows api
19:51:27 <the_dude_q> FFI? ?
19:51:27 <c_wraith> FFI = Foreign Function Interface
19:51:39 <the_dude_q> ooh, shiny
19:51:53 <c_wraith> There are also several tools to help automate parts of it.
19:52:02 <c_wraith> Ranging from really low level to really high-level
19:52:04 <the_dude_q> and it glitters!
19:52:32 <thisisnotmynick> the_dude_q, anyway the basics is: if a is a function, the expression (a b) applies function a with the parameter b. (\x -> k) is the function that receives x and returns k. so to evaluate (\x -> k) b you substitute all occurrences of x in k for b. so (\x -> x + 1) 5 is 5 + 1 that is 6
19:52:46 <thisisnotmynick> > (\x -> x + 1) 5
19:52:47 <lambdabot>   6
19:53:26 <thisisnotmynick> (+ 7) is really a syntactical hack for \x -> x + 7
19:53:28 <ddarius> @hackage win32
19:53:28 <lambdabot> http://hackage.haskell.org/package/win32
19:53:56 <the_dude_q> hmm
19:54:05 <the_dude_q> bot didn't preserve capitalization of W in Win32
19:54:19 <the_dude_q> broken link, but website failure recovery suggested the correct one
19:54:36 <c_wraith> oh, hey.  someone did write bindings for it
19:54:56 <c_wraith> Or at least a large swath of it
19:55:15 <elliott> Is there a nice literal bytestring syntax?
19:56:06 <c_wraith> the OverloadedStrings extension
19:56:15 <c_wraith> Gives you literals ascii bytestrings, anyway
19:56:36 <the_dude_q> well I have no clue what that page means, but I do notice some familiar function names
19:57:11 <ddarius> JuanDaugherty: The NCG is a different backend from the LLVM one.
19:57:20 <the_dude_q> It's like reading alien to a kid who learned C++ by himself and a couple of text books.
19:57:30 <the_dude_q> I want to learn your "Haskell"
19:57:53 <c_wraith> hang out here, ask questions.  We like people who do that, assuming they actually appear to be learning in the process :)
19:58:01 <the_dude_q> so, seriously, any good advice for expanding my haskell vocabulary from the tryhaskell.org app?
19:58:07 <monochrom> read "alien vs predator"
19:58:25 <c_wraith> @where lyah
19:58:25 <lambdabot> http://www.learnyouahaskell.com/
19:58:36 <c_wraith> I recommend that as an intro
19:58:43 <c_wraith> It's a good introduction to the language
19:58:47 <monochrom> I concur
19:58:56 <MtnViewMark> LYAH rocks
19:59:15 <the_dude_q> interesting graphic
19:59:43 <the_dude_q> the only problem i will have is if i reside in any chat room or forum long enough everyone starts to hate me
19:59:49 <sm> and if you don't like that one, http://book.realworldhaskell.org/read/
20:00:06 <the_dude_q> it's like wearing out your welcome that people who communicate in the real world have problems with
20:00:30 <the_dude_q> i have 22 minutes left on the Haskell platform DL
20:00:39 <thisisnotmynick> i have difficulty in actually writing real applications in haskell. monads, type errors difficult to grasp, lots of things. or at least i'm yet to find some doc on parsers combinators or otherwise figure out how to make something with parsec. (that is my main interest in haskell atm)
20:00:56 <the_dude_q> i will be reading me some learn me a some haskell
20:01:52 <MtnViewMark> thisisnotmynick: I believe Real World Haskell has a chapter or two on parsec
20:01:56 <monochrom> http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements is a parsec example. It is not a tutorial; it is a medium-size example.
20:03:02 <MtnViewMark> http://book.realworldhaskell.org/read/using-parsec.html
20:03:20 <thisisnotmynick> I have a grammar written in paper and i can write a lexer and a parser with ocamllex and ocamlyacc. but i can hardly do anything with parsec. =( (Like: I don't know how to combine a parser that reads a (, a parser that reads X, and a parser that reads ), into a parser that reads (X) and returns the result of reading X. all my attempts fail somehow, usually with some odd type error)
20:03:41 <sm> thisisnotmynick: it gets easier.. returning after some time away helps.. be sure to add type signatures to get better errors
20:04:25 <MtnViewMark> between ( char '(' ) ( char ')' ) parseX
20:04:36 <thisisnotmynick> i have been reading this, but somehow I don't want to build parsers with do { .. }. I want purely applicative style, like if I was defining purely a grammar, not an automaton
20:04:43 <thisisnotmynick> uhm
20:04:56 <monochrom> can be done too
20:05:09 <thisisnotmynick> ok, one more attempt..
20:05:16 <c_wraith> thisisnotmynick, look into *> and <* then
20:05:24 <Axman6> using both makes a very nice combination
20:05:37 <sm> good point.. why are my parsers so.. procedural looking
20:05:46 <MtnViewMark> and look at the utilities like between
20:05:48 <the_dude_q> I'm wondering how this fits in with the CS "P = NP" thing:   " but it also allows you to easily deduce (and even prove) that a function is correct"
20:06:30 <c_wraith> the_dude_q, it's really more of a completeness and computability thing than a complexity thing.  But in any case, only certain types of functions can be proven right by their type signature.
20:06:40 <c_wraith> For instance, something like fst :: (a, b) -> a
20:06:47 <Axman6> haskell's purity makes it much easier than most languages to prove its correctness
20:07:01 <c_wraith> There's only one correct (non-degenerate) implementation possible for that type signature.
20:07:10 <the_dude_q> I was thinking the pure functional design of it would
20:07:15 <c_wraith> But something like (+) :: Int -> Int -> Int
20:07:25 <the_dude_q> i was just trying to make some food for thought
20:07:26 <c_wraith> That type signature is nearly useless in proving the operation correct
20:07:49 <the_dude_q> ok
20:07:50 <the_dude_q> brb
20:07:59 <Axman6> the_dude_q: look at seL4, a version of the L4 kernel originally written in haskell, and proven to be correct
20:08:11 <Axman6> ie: it will never crash, unless there's a hardware fault
20:08:22 <Axman6> like my frigging phone is having right as i type this
20:08:25 <Axman6> frigging android
20:08:29 <Axman6> /sony
20:09:09 * sm wants a fully open HalVM phone
20:09:32 <monochrom> P=NP has little to do with program verification. many verification problems are not even in NP. for example type inference is already outside.
20:09:51 <sm> with hackage as app store, bwahaha
20:10:31 <the_dude_q> I want a job so I can buy an android and have it crash one m..
20:10:33 <the_dude_q> e..
20:10:35 <monochrom> hackage is not app store. cabal-install errors such as dependency problems are a pain.
20:10:36 <the_dude_q> on*
20:11:38 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml and accept the fate that hackage can never been as streamlined as app store.
20:12:23 <sm> come on monochrom.. think big, cackle maniacally..
20:12:28 <thisisnotmynick> monochrom, i think it is a good tradeoff (considering that most app stores will never be selling mostly/entirely free software)
20:12:59 <sm> we shall hire dcoutts full time for one MILLION dollars
20:13:20 <monochrom> no, money is not the distinguishing factor. dependency is.
20:14:17 <sm> Bah, fine, nix for app store
20:14:25 <thisisnotmynick> monochrom, my problem with language-specific repositories is that they hardly can capture all dependencies. (like, dependency on C libraries, with specific version number and so on)
20:15:25 <monochrom> you don't hear an app store (paid or free or pirate or smuggle) saying "Flight Control depends on GTK, Base, Container, Network... (2000 more other apps) Download all of them now... Oops, there is a conflict"
20:16:00 <monochrom> you ask for Flight Control and it just installs Flight Control and not 2000 dependency apps. And no conflict.
20:16:08 <Zao> thisisnotmynick: When you deploy to an app store, you deploy something baked, with say Bamse or whatever suits your platform.
20:16:43 <c_wraith> right.  the problem is that hackage is designed for distributing libraries, not apps
20:18:05 <Cale> I have trouble with things compiled for ARM 7 all the time.
20:18:27 <Cale> (My iPod Touch has an ARM 6)
20:19:28 <Cale> Though I suppose the real App Store would just stop you :P
20:21:54 <thisisnotmynick> monochrom, nix is supposed to make you download dependencies with no conflict whatsoever (but i don't know how much it succeeds. but will try it someway)
20:22:50 * zaphar_home would be happy if cabal would just automatically download and recompile dependencies with out excessive hand holding
20:24:37 <copumpkin> Cale: :O
20:24:45 <copumpkin> Cale: omg
20:29:08 <Cale> copumpkin: what?
20:29:16 * ddarius should hit algebraic topology hard again.
20:29:47 <monochrom> don't punch holes accidentally :)
20:30:08 <monochrom> "I accidentally my topology"
20:30:25 <the_dude_q> i don't get the joke monochrom..
20:30:35 <ddarius> "I accidentally my genus"
20:30:36 <the_dude_q> i've seen the lame "i accidentally" "someting" everywhere
20:30:51 <the_dude_q> what does it *really* mean?
20:30:57 <monochrom> a verb is intentionally omitted.
20:31:06 <monochrom> the verb is usually "deleted"
20:31:14 <the_dude_q> ahh
20:31:18 <the_dude_q> i'm quite a bright one
20:31:23 <the_dude_q> lmao, brb
20:31:26 <c_wraith> or "forgot" or "left out"
20:31:31 <c_wraith> same basic idea in all the cases
20:31:36 <the_dude_q> k
20:32:03 * hackagebot svm 1.0.0.1 - A support vector machine written in Haskell  http://hackage.haskell.org/package/svm-1.0.0.1 (AndrewDougherty)
20:32:04 <Cale> Hey guys, a little help? I think I accidentally the whole topology!?
20:32:04 <monochrom> the prototypical one is "I accidentally my disk"
20:32:13 <copumpkin> Cale: you're saying you don't necessarily use the legit appstore to get your apps on your ipod?
20:32:26 <Cale> copumpkin: Yeah.
20:32:27 * ddarius blames copumpkin.
20:32:44 <copumpkin> :P
20:33:02 * copumpkin goes to play world of goo
20:33:12 <elliott> I accidentally the copumpkin.
20:33:14 <copumpkin> <3 steam for mac
20:33:26 <elliott> It's like accidentallying the pumpkin, but turned inside-out.
20:34:21 <Cale> Steam is a slower, clunkier version of The Pirate Bay which costs money to use ;)
20:34:46 <Cale> (and only has games)
20:35:05 <the_dude_q> there're no weird sheep videos on steam?
20:35:28 <elliott> Cale: Steam actually has trackers (well...servers) that work now, though.
20:35:31 <monochrom> perhaps everything on mac costs money. except ghc and handbrake.
20:35:36 <elliott> That's a rather big advantage :P
20:35:44 <elliott> monochrom: and a text editor. you get that for free!
20:35:47 <the_dude_q> I want OpenCL for my Windows/Ubuntu :(
20:38:04 * hackagebot explicit-sharing 0.8 - Explicit Sharing of Monadic Effects  http://hackage.haskell.org/package/explicit-sharing-0.8 (SebastianFischer)
20:41:32 <the_dude_q> Can someone tell me if "Try Haskell" can do everything the haskell compiler can do?
20:41:42 <monochrom> probably not
20:42:05 <the_dude_q> on "learnyouahaskell" the baby's first function is "doubleMe x = x+x"
20:42:20 <the_dude_q> which causes "Try Haskell" to error me
20:42:31 <Saizan> definitions like those are supposed to go in a .hs file
20:42:32 <Cale> the_dude_q: tryhaskell wants expressions
20:42:46 <Cale> the_dude_q: That's a declaration. You could use it in tryhaskell with 'let'
20:42:47 <bos> Okay, whew!
20:42:54 <Cale> let doubleMe x = x + x in doubleMe 10
20:42:56 <the_dude_q> ok i was goign to try "let"
20:42:57 <the_dude_q> really i was
20:43:00 <the_dude_q> ...
20:43:10 <the_dude_q> but i wanted to avoid the "in .." part
20:43:12 <monochrom> I believe you
20:43:23 <Saizan> ghci supports "let doubleMe x = x + x"
20:43:31 <Saizan> maybe tryhaskell does too?
20:43:36 <Cale> nope, seems it doesn't
20:43:55 <Cale> So, you probably can't make any permanent declarations with it.
20:44:45 <thisisnotmynick> about my parsec problem: my actual problem is to parse 0 or more spaces, then sequence of atoms, then 0 or more spaces, where a sequence of atoms is an atom, or an atom, 1 or more spaces, and a sequence of atoms. this:  http://paste.pocoo.org/show/305907/ works partially, when i enter "a " it says unexpected end of input expecting space or atom
20:44:46 <the_dude_q> ok I guess I will be using let ... in ..
20:44:47 <Cale> (unless there's a secret syntax for that)
20:45:01 <Cale> the_dude_q: You should just get a copy of GHC, and use ghci :)
20:45:15 <thisisnotmynick> the current code was suggested by MtnViewMark. my past code was that commented out
20:45:16 <the_dude_q> i'm tryihng
20:45:20 <the_dude_q> the download speed is horrible
20:45:24 <Cale> ah
20:45:31 <the_dude_q> and i didn't have bit-torrent installed so i used the weblink
20:45:36 <the_dude_q> 43 minutes left
20:45:37 <the_dude_q> D:
20:45:39 <Cale> which link?
20:45:56 <Cale> http://haskell.org/ghc/download_ghc_6_12_3 -- one of the ones from here?
20:45:59 <the_dude_q> finding it..
20:46:10 <Cale> Or the Haskell Platform?
20:46:11 <the_dude_q> the HaskellPlatform-201...
20:46:29 <the_dude_q> 9KB/s
20:46:43 <ntc2> the_dude_q: you could also try codepad.org while you're waiting for your ghc to download.
20:46:46 <the_dude_q> 50 of 73 MB downloaded
20:46:50 <the_dude_q> excellent idea
20:46:55 <the_dude_q> that website slipped my mind
20:47:03 <Cale> Started the download...
20:47:10 <Cale> It's going at 2 MB/s for me
20:47:11 <ntc2> it's a pastebin that lets you run your code
20:47:14 <Cale> 2.5...
20:47:18 <Cale> and it's done :)
20:47:31 <Cale> http://lambda.galois.com/hp-tmp/2010.2.0.0/HaskellPlatform-2010.2.0.0-setup.exe
20:47:33 <the_dude_q> did i mention i have inferior rural american DSL?
20:47:48 <monochrom> "open sesame, who is the smartest haskell programmer in the world? power to me, castle crayskull! doubleMe x = x + x"
20:48:04 <Cale> monochrom: lol
20:48:23 <Cale> the_dude_q: The US really has to modernise :)
20:48:32 * Cale is Canadian
20:48:34 <the_dude_q> If you want I can weave some webs of C++ ?
20:48:44 <the_dude_q> there are a lot of rural american places though...
20:49:16 <monochrom> rural can't be helped. rural canada is just as slow
20:49:16 <Cale> Yeah, I suppose if you're out in the middle of nowhere, it's hard to get decent service.
20:49:24 <the_dude_q> i'm lucky I have dsl at all
20:49:37 <the_dude_q> had to pay $80.00 to extend the line back in 01/02
20:49:53 <the_dude_q> then be lucky enough to pay $50.00/month for this crappy service
20:49:54 <monochrom> move to Hong Kong so there is no "rural" :)
20:50:27 <the_dude_q> I don't speak hong kong.
20:50:31 <the_dude_q> or I would think about it
20:50:43 <the_dude_q> I intend to move to Australia actually..
20:50:50 <Cale> My service silently got ~3 times faster on the start of this billing period for some reason.
20:50:57 <the_dude_q> I should be able to Immigrate there with a CS degree .
20:52:09 <thisisnotmynick> I was describing things, but, maybe the problem is that separator' can be a zero-width string?
20:57:00 <Saizan> might be
20:57:10 <thisisnotmynick> between (many space) (many space) $ sepBy atom (many1 space) -- should not this work?
20:58:53 <thisisnotmynick> if this is the problem, I can expand S -> s* L s* to S -> L | L s+ | s+ L | s+ L s+ in a grammar (this is some elimination rule..), but I don't know how to do it in parsec
20:59:05 <Saizan> i think the problem is that once it has parsed a separator, it wants to parse a new element too
20:59:34 <thisisnotmynick> it is an ambiguity
20:59:58 <thisisnotmynick> a separator can be the (many space) or (many1 space)
21:00:31 <thisisnotmynick> I was trying to eliminate the empty string at the end with <|> and so on but I am unable to do
21:01:10 <thisisnotmynick> (I mean, since the end is (many space), it may be comfortable in just making this equal "" and ignoring)
21:01:24 <Saizan> many space >> many (atom >>= \a -> many space >> return a) -- does this work?
21:01:57 <thisisnotmynick> yup!
21:02:40 <the_dude_q> I'm starting to like this "greater than lambda equals" thing
21:02:45 <thisisnotmynick> I was trying to actually work with combinators to make this
21:02:51 <monochrom> I would do this. many space *> many (atom <* many space) . the operators come from Control.Applicative. equivalent to what Saizan says.
21:03:03 <thisisnotmynick> uhm o.o
21:03:18 <thisisnotmynick> pretty. but no luck using between?
21:03:44 <Chaze> i asked this more than once, but please tell me again: (\n f -> n-th composition of f)
21:04:01 <Chaze> how would i implement this?
21:04:33 <thisisnotmynick> Chaze, don't this require dependent types?
21:04:37 <Saizan> \n f x -> iterate f x !! n
21:04:51 <monochrom> the whole idea of "space* (atom space)* space*" is either an ambiguous grammar or the final "space*" is useless. you know that?
21:05:22 <Chaze> Saizan: ah, lets see if it works
21:05:23 <monochrom> but of course everything looks like a pair of parentheses if all you have is between.
21:05:58 <thisisnotmynick> I was grasping the ambiguity problem, yes, but all my grammar things are full of ambiguities. :(
21:07:04 <thisisnotmynick> No instance for (Control.Applicative.Applicative (GenParser Char ()))
21:07:08 <Saizan> maybe it'd be easier to use ReadP, since it doesn't commit early like parsec does
21:07:22 <monochrom> ooh, old parsec version. use Saizan's code for now.
21:07:43 <djahandarie> Is there ANY tutorial/serious documentation on Parsec 3?
21:07:48 <thisisnotmynick> yes. i actually have parsec 3 installed. for some odd reason i'm using 2. (maybe i was following a doc written for 2?)
21:07:59 <Chaze> let mydrop n l = iterate tail l !! n in drop 3 "this is a test"
21:08:04 <thisisnotmynick> yes, that was my problem: not finding things about parsec3
21:08:04 <Chaze> > let mydrop n l = iterate tail l !! n in drop 3 "this is a test"
21:08:05 <lambdabot>   "s is a test"
21:08:14 * djahandarie nominates ddarius to write one
21:08:21 <Saizan> djahandarie: the haddocks now have descriptions :)
21:08:44 <djahandarie> Yeah, I saw that... but it wasn't very inspiring
21:09:31 <djahandarie> I think a couple paragraph doc showing how to do common things will do the job very well
21:11:22 <ddarius> The common things to do are the same things you do in earlier versions.  What is more needed are worked examples of uncommon things to do.
21:11:48 <ddarius> (and done in the same way pretty much, continuing the first sentence)
21:15:45 <djahandarie> ddarius, that should make writing that document even easier, just copy a bunch of stuff!
21:16:56 <monochrom> since values are immutable, there is no need to copy.  <duck>
21:16:59 <thisisnotmynick> isn't do { a <- atom; separator; return a } the same as endBy atom separator? (the former works, the latter interpreter: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
21:17:44 <ddarius> djahandarie: That's what I did.  But you can read the Parsec letter for something with a more narrative format.
21:18:00 <thisisnotmynick> i do many (one of those things above)
21:18:30 <Saizan> thisisnotmynick: endBy p sep         = many (do{ x <- p; sep; return x })
21:20:09 <the_dude_q> <yawns> time for me to cut out tonight
21:20:10 <thisisnotmynick> oh, so I was changing that your code until i came to line = separator >> endBy atom separator
21:20:24 <thisisnotmynick> the_dude_q, bye
21:20:27 <the_dude_q> may programmer jesus bless your haskell tonight
21:20:47 <Chaze> @pl curry $ sequence $ map uncurry [(+),(-)]
21:20:47 <lambdabot> curry (sequence [uncurry (+), uncurry (-)])
21:21:22 <Saizan> sequence . map f = mapM f
21:21:38 <pastorn> i have a file format which has two different internal representations
21:22:07 <pastorn> (it's an image, either it's RGB or it's indexed with 256 24-bit colors)
21:22:29 <pastorn> is it good to two different types for this?
21:22:54 <pastorn> to enforce that rendering might need two different backends
21:23:34 <pastorn> otherwise it feels like i'd have to constantly keep in mind that it has two representations and i'll have to check etc.
21:23:50 <Chaze> @pl (\a b ->  ((a + b),(a - b)))
21:23:50 <lambdabot> ap (ap . ((,) .) . (+)) (-)
21:23:54 <pastorn> so is two types + typeclass something i should do here?
21:24:03 <Chaze> @pl (\(a,b) ->  ((a + b),(a - b)))
21:24:03 <lambdabot> uncurry (ap (ap . ((,) .) . (+)) (-))
21:24:48 <thisisnotmynick> @type >>
21:24:49 <lambdabot> parse error on input `>>'
21:24:53 <thisisnotmynick> @type (>>)
21:24:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
21:26:49 <kfish> @type *>
21:26:49 <lambdabot> parse error on input `*>'
21:26:55 <kfish> @type (*>)
21:26:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
21:27:43 <int80_h>  have a good evening/morning/whatevs #haskell
21:29:50 * ddarius wishes he could get a list of all the books he's ever read.
21:30:54 * djahandarie wishes he could claim that list as his own
21:41:46 <boegel> has anyone ever considered getting GHCi to work on iPhone/iPod Touch?
21:41:48 <boegel> can it be done?
21:47:32 <JuanDaugherty> <ddarius> The NCG has quite a bit of potential.  Unfortunately, in part due to the LLVM backend, it will probably never be fully realized.
21:47:42 <thisisnotmynick> why haskell designers opted for flat and simple modules, instead of ocaml's approach with functors etc?
21:47:54 <JuanDaugherty> I misread you as saying there that the NCG used LLVM.
21:48:10 <JuanDaugherty> rather than that it was an alternative
21:48:21 <thisisnotmynick> could functors be integrated into haskell with an extension?
21:49:01 <ddarius> A system more powerful than O'Caml's or SML's module system can be not too unreasonably encoded into Haskell type classes.
21:49:18 <ddarius> The opposite way can also be done, but then the encoding is quite definitely unreasonable.
21:50:02 <thisisnotmynick> .. type classes as functors? o.o
21:50:44 <thisisnotmynick> like, with power equivalent to module X = Functor(data S = ..)?
21:50:54 <JuanDaugherty> and according to wikipedia, ghc does in and of itself produce native code
21:51:11 <thisisnotmynick> or even let module X = Functor(data S = ..) in X.b
21:52:14 <djahandarie> JuanDaugherty, that'd be the NCG, no?
21:52:17 <djahandarie> Native Code Generator
21:52:21 <JuanDaugherty> although it would seem to imply that it doesn't do so by default, that you have to take measures to do so
21:52:29 <JuanDaugherty> such as producing C
21:52:54 <JuanDaugherty> (it states 3 ways (including llvm))
21:53:21 <monochrom> no, not that kind of functor
21:54:50 <thisisnotmynick> i think haskell has a 'functor' type class, unrelated to ml functors (parametrized modules)
21:56:50 <ddarius> JuanDaugherty: GHC uses -fasm by default now and has for a couple of years give or take.  There are indeed currently three backends: LLVM (-fllvm), NCG (-fasm), and C (-fvia-C).
21:57:26 <ddarius> (There are also some other forms such as the byte code used internally by GHCi and unregisterised C used for porting.)
22:00:33 <diPython> hi
22:01:00 <diPython> i'm getting a bus error when trying to create sockets on mac 
22:01:04 <diPython> does anyone have a clue?
22:01:24 <pastorn> diPython: how do you try to create them?
22:01:31 <Axman6> which version of ghc?
22:02:28 <JuanDaugherty> ddarius, Acknowledged. I am having trouble figuring out if it is "safe" to switch to ghc7. Does it install to replace or run side by side with 6?
22:03:03 <diPython> ghc 6.12.3
22:03:18 <diPython> if i use Network.Socket library it works fine
22:03:25 <diPython> but if I use listenOn
22:03:29 <diPython> it doesn't work
22:08:34 <ddarius> JuanDaugherty: You can install every version of GHC ever made side by side.
22:09:13 <JuanDaugherty> everyone I've ever installed defaulted to replacement
22:11:21 <pastorn> @hoogle listenOn
22:11:21 <lambdabot> Network listenOn :: PortID -> IO Socket
22:13:46 <diPython> so basically for what i understood there is Network and Network.Socket, whereas Network is a high-level library, but it seems that the parameteres its using are not suited for my system
22:16:23 <rainyrhy> anyone have opengl on mac working using haskell platform libraries?
22:16:45 <Axman6> it doesn't work in ghci
22:17:02 <pastorn> rainyrhy: runhaskell is your friend, i guess :)
22:17:46 <rainyrhy> mine it would have a white screen and couldn't render, stdout is not outputting,
22:18:26 <rainyrhy> then i tried to update OpenGL with cabal, it would render, but i can't send input to it, and the native window borders is not showing up
22:18:34 <rainyrhy> i can only exit by killing it
22:18:38 <ddarius> JuanDaugherty: If you are using distribution packages or Windows installers, those will do whatever they do.
22:19:07 <JuanDaugherty> i've only used on linux distros
22:19:09 <ddarius> GHC itself installs in a version specific directory and the packages are registered separately as well.
22:19:21 <ddarius> I have 6.12.1 and 7.0.1 installed right now on Ubuntu.
22:19:36 <rainyrhy> i'm using the opengl sample code here http://www.haskell.org/haskellwiki/OpenGLTutorial1
22:20:54 * JuanDaugherty finds, unsurprisingly, don't have it installed on Mac and don't even need to check on Windows
22:21:53 <JuanDaugherty> after installing a new version typically the first thing I would do is ghc --version to confirm the replacemnt
22:26:02 <applicative> rainyrhy, the hello world example works if I compile it, but not if I call main from inside ghci
22:26:21 <dobblego> are there any packages on hackage that bundle up some example usages of the library?
22:26:45 <rainyrhy> @applicative yes it would not run properly
22:26:45 <lambdabot> Unknown command, try @list
22:27:12 <pastorn> dobblego: lots of packages contains an 'examples' directory within the .tar.gz
22:27:35 <dobblego> pastorn, I'm just looking for the best way to lay it out and specify it in the .cabal
22:27:45 <pastorn> you don't
22:27:55 <pastorn> unless you want some example binary installed
22:28:01 <pastorn> haha does that
22:28:04 <dobblego> so then Extra-files?
22:28:23 <pastorn> i dunno, though... you should probably ask someone else ;)
22:28:27 <dobblego> ok
22:28:46 <pastorn> but i always get the .tar.gz and look for an examples directory within when i want to know :)
22:29:18 <rainyrhy> any more mac users able to use opengl in haskell?
22:43:49 <applicative> rainyrhy, i see, yes.  have you tried compiling the modules in the GLUT /examples folder?
22:44:19 <rainyrhy> applicative let me try again
22:55:23 <rainyrhy> applicative, its the same, there is only a white rectangle, could not respond
22:55:44 <pastorn> rainyrhy: which example are you running?
22:56:10 <rainyrhy> BOGLGP/Chapter01/OnYourOwn1.hs
22:56:37 * pastorn grabs some code..
22:59:14 <pastorn> i get a red triangle and a blue pentagon
22:59:54 <pastorn> http://users.mkeyd.net/~alexander/OnYourOwn1_hs.png
23:00:39 <rainyrhy> pastorn, sigh there really is something wrong with my GLUT
23:01:35 <pastorn> rainyrhy: have you tried running C versions of the code?
23:02:34 <rainyrhy> pastorn I could do it fine when using XCode
23:02:42 <rainyrhy> pastorn i'm using a mac btw
23:02:49 <pastorn> yeah, got taht
23:04:15 <pastorn> rainyrhy: try OrangeBook/ogl2brick/Brick.hs
23:06:40 <thisisnotmynick> do { a; .. } is a >> do { .. }, but what if .. is empty? what is the empty monad such as a >> empty = a? (or this translating rule is valid only if .. contains actual statements?)
23:07:58 <rainyrhy> .
23:08:03 <pastorn> rainyrhy: well?
23:08:14 <Axman6> do { a; b} is a >> b, do { a; } is a
23:08:50 <rainyrhy> pastorn, it shows up and draws every frame, but i can't send input
23:09:06 <pastorn> rainyrhy: that sounds like GLUT is messing up
23:09:07 <thisisnotmynick> a >>= id = a, it seems
23:09:25 <pastorn> rainyrhy: guess you'll have to do without the fixed function pipeline, then :)
23:09:39 <Boxo> nope.
23:09:43 <Boxo> @type (>>= id)
23:09:44 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
23:09:44 <pastorn> rainyrhy: is this you learning 3D programming or are you doing this to do it in haskell?
23:09:49 * applicative is stunned he made his mac go fullscreen with /examples/BOGLGP/Chapter03/polygons.hs
23:10:12 <thisisnotmynick> oh. hm.
23:10:22 <Boxo> > [[1,2], [4,5], []] >>= id
23:10:23 <lambdabot>   [1,2,4,5]
23:10:35 <thisisnotmynick> õ.o
23:10:47 <Boxo> look at the type of (>>=)
23:10:48 <thisisnotmynick> i tried this at ghci with [] >>= id, and the result was []
23:10:50 <Boxo> @type (>>=)
23:10:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:10:59 <rainyrhy> applicativve :O
23:11:05 <djahandarie> :t concatMap
23:11:05 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
23:11:07 <thisisnotmynick> oh. a >>= return?
23:11:16 <djahandarie> :t concatMap id
23:11:16 <thisisnotmynick> @type return
23:11:16 <lambdabot> forall b. [[b]] -> [b]
23:11:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:11:18 <Boxo> thisisnotmynick, that result is fine
23:12:15 <Boxo> a >>= return == a. That's monad law #2
23:13:10 <applicative> > Just (Just "September") >>= id
23:13:10 <lambdabot>   Just "September"
23:13:53 <thisisnotmynick> it may not make sense doing a >> something and expecting to get a, right? since the value "inside" a is lost
23:13:59 <thisisnotmynick> @type (>>)
23:14:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:14:15 <thisisnotmynick> it returns m b, that is not related to m a
23:14:41 <Boxo> well try it
23:14:49 <thisisnotmynick> tried and failed
23:15:08 <thisisnotmynick> why can't >>= work with different types of monad?
23:15:13 <Boxo> then yep, the a is lost. you can tell that from the type
23:15:36 <thisisnotmynick> would it be possible to write a >>= that worked with different types?
23:15:47 <Boxo> > [1,2,3,55] >> ["quqquu"]
23:15:47 <c_wraith> :t (>>=)
23:15:47 <lambdabot>   ["quqquu","quqquu","quqquu","quqquu"]
23:15:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:16:04 <thisisnotmynick> like (Monad m, Monad n) => m a -> (a -> n b) -> n b
23:16:20 <c_wraith> Ah.  No, that really doesn't make any sense
23:16:27 <c_wraith> How are you going to convert a list to IO?
23:16:28 <thisisnotmynick> a generalization of >>=
23:16:33 <thisisnotmynick> uhm...
23:16:42 <Boxo> you would have to define how every possible pair of monads, m and n, work together
23:16:56 <Boxo> well, it wouldn't be about monads anymore anyway
23:17:05 <thisisnotmynick> hmmm. o.o
23:17:26 <thisisnotmynick> but look the signature
23:17:35 <thisisnotmynick> it is the function that says how to conver a to n a
23:17:49 <thisisnotmynick> but hmm, how to look inside m a..
23:17:52 <thisisnotmynick> to get the a
23:17:54 <c_wraith> But how would it do that in a polymorphic way?
23:17:57 <djahandarie> You'd need a natural transformation from n to m, and it ends up that that signature is no more general in that case
23:17:59 <thisisnotmynick> hmm, with >>=
23:18:12 <Boxo> thisisnotmynick, that's the problem, you can't take stuff out of a generic monad
23:18:17 <thisisnotmynick> I look inside a with >>=, then apply the function I received at the parameter
23:18:29 <thisisnotmynick> but.. >>= returns a monad
23:18:30 <c_wraith> >>= doesn't look inside.
23:18:40 <thisisnotmynick> yeah, >>= transforms
23:18:42 <c_wraith> >>= combines a value and a function
23:19:55 <Boxo> I find it easier to think that (ma >>= f) first does "fmap f ma" getting a value of type (m (m a)). Then it collapses the two m's, getting an m a.
23:20:16 <thisisnotmynick> @type fmap
23:20:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:20:23 <Boxo> @type liftM
23:20:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:20:34 <thisisnotmynick> fmap does not work with monads
23:20:46 <c_wraith> then use liftM
23:20:48 <thisisnotmynick> i never understood the relationship between all those monads
23:21:05 <c_wraith> (though every instance of Monad can be made an instance of Functor such that fmap = liftM)
23:21:12 <thisisnotmynick> a lot of monads are also functors right?
23:21:15 <thisisnotmynick> @type liftA
23:21:16 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
23:21:26 <Boxo> but if you're defining (>>=) you can't use liftM there, of course.
23:21:51 <Boxo> thisisnotmynick, all monads are functors
23:21:58 <Boxo> in principle...
23:22:05 <thisisnotmynick> there is a general transformation from monads to functors?
23:22:14 <c_wraith> Yes.
23:22:16 <thisisnotmynick> that automatically apply to all monads
23:22:16 <Boxo> liftM is fmap for monads.
23:22:17 <applicative> rainyrhy, just to see if we're on the same page, examples/RedBook/Robot.hs (absurdly so called) compiled with ghc --make -O2 Robot.hs -o robot 
23:22:27 <c_wraith> yes.  for every monad, fmap = liftM
23:22:45 <thisisnotmynick> why there is liftA, liftM, fmap, map..? supposedly Applicative means something different than Functor?
23:22:46 <applicative> rainyrhy, when i call ./robot it responds fine to keyboard e E s S 
23:23:05 <c_wraith> applicative also defines pure and <*>
23:23:15 <c_wraith> those are more than what you get from Functor
23:23:25 <thisisnotmynick> and Monad is more specific than Functor, so there are functors that are not monads
23:23:29 <Boxo> thisisnotmynick, well, they all do the same thing
23:24:07 <thisisnotmynick> pure is just like return, right?
23:24:16 <applicative> yes
23:24:19 <thisisnotmynick> so the thing is that applicative is monads + <*>
23:24:25 <thisisnotmynick> @src (<*>)
23:24:25 <lambdabot> Source not found. That's something I cannot allow to happen.
23:24:35 <Boxo> applicative is FUNCTORS plus <*> and pure
23:25:01 <dobblego> applicative is pointed functors plus (<*>)
23:25:09 <thisisnotmynick> monad has something that applicative does not?
23:25:12 <Boxo> and monads are applicatives plus (>>=). in principle.
23:25:18 <thisisnotmynick> ah
23:25:18 <dobblego> thisisnotmynick, yes, join
23:25:43 <Boxo> join can be implemented in terms of >>=, and the other way around. 
23:25:44 <thisisnotmynick> @src (Control.Applicative.<*>)
23:25:44 <lambdabot> Source not found. You speak an infinite deal of nothing
23:25:47 <Boxo> @type join
23:25:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:25:59 <thisisnotmynick> @src Control.Applicative.(<*>)
23:25:59 <lambdabot> Source not found. Sorry.
23:26:07 <Boxo> personally I much prefer join
23:26:11 <applicative> > join [[2,3][4,5]]
23:26:12 <lambdabot>   Couldn't match expected type `t -> [a]'
23:26:12 <lambdabot>         against inferred type `[a1]'
23:26:19 <applicative> > join [[2,3],[4,5]]
23:26:20 <lambdabot>   [2,3,4,5]
23:26:25 <dobblego> Boxo, you can define join in terms of (>>=) but you need fmap to define (>>=) in terms of join
23:26:34 <Boxo> dobblego, yea
23:26:50 <thisisnotmynick> functor has fmap. monads has kind of fmap because >>= can be used to implement fmap. right?
23:26:59 <Boxo> yep
23:27:11 <dobblego> Functor <- PointedFunctor <- Applicative <- Monad
23:27:20 <dobblego> fmap <- pure <- (<*>) <- join
23:27:24 <thisisnotmynick> pointed functor?
23:27:46 <Boxo> functors plus "pure :: a -> f a"
23:27:47 <dobblego> class Functor f => PointedFunctor f where pure :: a -> f a
23:28:03 <Boxo> same as return as you see
23:28:06 <dobblego> s/pure/point if you will
23:28:16 <applicative> > liftM (+1) (Just 4)
23:28:16 <lambdabot>   Just 5
23:28:29 <applicative> > fmap (+1) (Just 4)
23:28:29 <lambdabot>   Just 5
23:28:52 <applicative> >  (+1) <$> (Just 4)
23:28:53 <lambdabot>   Just 5
23:29:16 <applicative> >  (+) <$> (Just 1) <*> (Just 4)
23:29:17 <lambdabot>   Just 5
23:30:29 <thisisnotmynick> > [\x -> x+1, \x -> 2*x] Control.Applicative.<*> [1, 2, 3]
23:30:30 <lambdabot>   [2,3,4,2,4,6]
23:30:44 <thisisnotmynick> @src Control.Applicative.<*>
23:30:44 <lambdabot> Source not found. Where did you learn to type?
23:30:56 <thisisnotmynick> strangest operator i have ever seen
23:31:12 <applicative> thisisnotmynick, one  Applicative lets you do is fmap a two place function over two things up in the higher level
23:31:24 <applicative> one thing it lets you do
23:31:40 <thisisnotmynick> why can't you build <*> from fmap?
23:32:17 <dobblego> since you need (a -> b) -> f (a -> b)
23:32:39 <applicative> which is pure
23:33:00 <thisisnotmynick> so why isn't a pointedfunctor an applicative?
23:33:06 <applicative> and you need f ( a -> b) -> f a -> f b which is <*>
23:33:07 <dobblego> @djinn ((a -> b) -> f a -> f b) -> f (a -> b) -> f a -> f b
23:33:08 <lambdabot> -- f cannot be realized.
23:33:09 <Boxo> you could do this... \ff fx -> fmap (\x -> fmap ff x) fx
23:33:10 <Boxo> but
23:33:16 <Boxo> @type \ff fx -> fmap (\x -> fmap ff x) fx
23:33:17 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
23:33:29 <Boxo> return type has TWO f's, and you can't get rid of them
23:33:39 <Boxo> eh
23:33:42 <Boxo> that's wrong, sorry
23:33:46 <applicative> pointed just means there's a natural way of taking an ordinary value and putting into the functored version of its type, to put it ineptly
23:34:17 <applicative> what's an example of an unpointed functor? I can't remember
23:34:23 <Boxo> ah, this \ff fx -> fmap (\x -> fmap (\f -> f x) ff) fx
23:34:26 <Boxo> @type \ff fx -> fmap (\x -> fmap (\f -> f x) ff) fx
23:34:27 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f1 a -> f1 (f b)
23:34:35 <Boxo> two f's.
23:34:59 <thisisnotmynick> o.o so you _can't_ totally define <*> in terms of fmap and maybe pure?
23:35:11 <Boxo> but this works:
23:35:18 <Boxo> @type \ff fx -> ff <*> fx
23:35:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:36:04 <Boxo> if you could, <*> wouldn't be required for the typeclass
23:36:37 <thisisnotmynick> that's my doubt. since i haven't figured out what <*> does
23:36:47 <thisisnotmynick> i see some properties at http://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Applicative_Functors
23:36:53 <applicative> thisisnotmynick there are other things you could define to get the same thing going, but pure and fmap arent enough
23:37:23 <thisisnotmynick> fmap f x = pure f <*> x
23:37:28 <applicative> thisisnotmynick if you define the monad operations, you get <$> under the name of liftM and <*> under the name of ap
23:37:32 <applicative> @src ap
23:37:32 <lambdabot> ap = liftM2 id
23:38:49 <Boxo> check this out, thisisnotmynick http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
23:39:07 <thisisnotmynick> > Control.Monad.ap [\x -> x+1, \x -> 2*x] [1, 2, 3]
23:39:08 <lambdabot>   [2,3,4,2,4,6]
23:39:56 <thisisnotmynick> ap is a really weird function
23:40:13 <applicative> so if you have a Monad instance defined for "MyCrazy  a " you can immediately write Functor and Applicative instances
23:41:19 <Boxo> ap is <*> for monads, like liftM is fmap for monads. turns out you can do it with just >>= and return
23:41:40 <thisisnotmynick> why don't the compiler has some automatic rule like instance Monad m => Applicative m ? I sometimes handle with monads that aren't applicative
23:41:59 <applicative> > return (*) `ap` [1,2,3] `ap` [1,10,100]
23:41:59 <lambdabot>   [1,10,100,2,20,200,3,30,300]
23:42:02 <Boxo> it's a weakness of haskell IMO..
23:43:00 <thisisnotmynick> Boxo, about those exercises, should I just insert a function there with correct type, that returns anything but undefined?
23:43:01 <applicative> It is forever being suggested that this be done.  But, for one thing, there are sometimes more than one possible Applicative instance
23:43:09 <Boxo> yep, thisi
23:43:14 <Boxo> thisisnotmynick*
23:45:23 <thisisnotmynick> doesn't haskell emacs mode have some integration with ghci?
23:46:09 <thisisnotmynick> actually C-c C-b ran an interpreter. but I was supposing that C-x C-e would send some piece of code there
23:48:55 <thisisnotmynick> ok, C-c C-l works ok for sending the whole file. it seems I can't send just a part of a file..
23:57:06 <thisisnotmynick> can someone say that something of type ((->) t) is some function that receives type t? that is, some function of type t -> a for some a
23:57:33 <Boxo> exactly
