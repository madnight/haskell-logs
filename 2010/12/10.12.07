00:13:12 <zul_netbsd>  /quit
00:51:41 <Eduard_Munteanu> Bah, I can't have a zipper for 'data Tree a = Leaf a | Fork (Tree a) (Tree a)', can I?
00:52:44 <ddarius> Sure you can.
00:53:20 <Eduard_Munteanu> ddarius: could you give a general zipper formula? I'm having trouble following the examples on wikibooks.
00:54:53 <Eduard_Munteanu> I guess it should be Zipper(T_X A) = (d/dX T, something), only I don't know how to generalize that something.
00:55:56 <Eduard_Munteanu> d/dX T here should be 1 + X^2.
00:55:58 <ddarius> strictlypositive.org/diff.pdf  Is one of the earlier papers on it and is pretty readable and short.
00:56:08 <Eduard_Munteanu> ddarius: thanks.
00:56:32 <ddarius> It also has a similar example, namely data Tree a = Tip | Node a (Tree a) (Tree a)
00:57:31 <Eduard_Munteanu> erm, d/dx T = 2 X
00:57:36 <Eduard_Munteanu> (my bad)
00:58:36 <ddarius> Eduard_Munteanu: In that paper you can probably skip most of the stuff defining regular types as they are basically a reasonable subset of Haskell types.  Roughly polynomial types with recursion.
01:02:13 <Eduard_Munteanu> ddarius: what's that <o ?
01:02:40 <Eduard_Munteanu> I didn't read Huet's paper.
01:06:06 <ddarius> Huet's paper is also good (and the original paper) but it doesn't give a concrete algorithm if I remember correctly.
01:07:18 <ddarius> That said that operator is being defined by those rules.
01:07:37 <Cale> Eduard_Munteanu: Remember the chain rule
01:08:45 <Cale> If T(x) = x + T(x)^2, then T'(x) = 1 + 2 T(x) T'(x)
01:09:04 <Eduard_Munteanu> Cale: oh, I didn't read it as such, I see.
01:09:05 <Cale> Or if you prefer, T'(x) = 1 + T'(x) T(x) + T(x) T'(x)
01:09:30 <ddarius> It (the operator) corresponds to a single step of "plugging in."
01:10:01 <ddarius> Cale: Just put your isomorphism goggles on.
01:10:17 <Cale> Which makes sense -- if you have a tree with one element deleted from it, either it's a Leaf with the element deleted from it, or it's a Fork with the element deleted from the left subtree, or it's a Fork with the element deleted from the right.
01:12:31 <Eduard_Munteanu> Hm, I'm not really sure how this lets me navigate the tree though.
01:12:54 <Eduard_Munteanu> I kinda needed a tree "with backlinks" or which can be "reversed" (bottoms up), and I figured a zipper could do it.
01:13:18 <Eduard_Munteanu> For zippers on lists it's really easy.
01:18:03 <ddarius> type DTree a = [Either (Tree a) (Tree a)]; type Zipper a = (DTree a, Tree a); top :: Tree a -> Zipper a; top t = ([], t); left, right :: Zipper a -> Zipper a; left (path, Fork l r) = (Right r:path,l); right (path, Fork l r) = (Left l:path, r); up (Left l:path, t) = (path, Fork l t); up (Right r:path, t) = (path, Fork t r)
01:18:27 <manateeUser> /nick hydo
01:18:33 <manateeUser> /whois hydo
01:21:05 <Eduard_Munteanu> ddarius: oh, thanks.
01:22:08 <ManateeLazyCat> Ah, manateeUser, who is it?
01:23:43 <Eduard_Munteanu> ddarius: so how do I go from the derivative to DTree a? Indeed, Either (Tree a) (Tree a) is somehow my naive derivative T' = 2 * T
01:24:10 <Eduard_Munteanu> But I would've seen 2 more as a Bool than Either.
01:24:34 <Eduard_Munteanu> Oh... that fits Cale's more.
01:24:56 <Eduard_Munteanu> But the list?
01:24:59 <ddarius> Eduard_Munteanu: If you look at the equation Cale produced, you'll see that it states that the derivative satisfies the same recursion equation as DTree.
01:25:14 <ddarius> L(x) = 1 + A L(x)
01:25:34 <ddarius> 2 does correspond to Bool, but (Bool, a) is isomorphic to Either a a.
01:25:36 <Eduard_Munteanu> ddarius: oh, where 1 = [] ?
01:25:43 <ddarius> Eduard_Munteanu: Yep.
01:25:51 <Eduard_Munteanu> ddarius: thanks a lot, that makes sense now.
01:27:12 <kosmikus> Either is like +, so: 2 * A = (1 + 1) * A = A + A
01:27:33 <Eduard_Munteanu> Yeah.
01:27:37 <ManateeLazyCat> Any Skype address i can study Spoken English?
01:27:44 <ddarius> Incidentally, up roughly corresponds to that <. operator (it does a bit more than that operator though)
01:35:17 <jkff> Hi. Looks like my ghci broke - I'm checking out CPUTime.getCPUTime and ghci prints the same value every time I call it (within a single ghci session), however the value sometimes sporadically changes after other IO actions. Any idea what might be the problem?
01:36:50 <Jafet> It should sporadically increase, yes
01:37:13 <jkff> But getCPUTime should be a high-resolution timer
01:37:46 <Veinor> the resolution is cpuTimePrecision
01:37:46 <Eduard_Munteanu> It's not a realtime timer, it looks.
01:37:54 <jkff> But it changes in absolutely wild ways
01:38:12 <jkff> My main question is whether it's getCPUTime is broken, or my ghci
01:38:34 <jkff> More precisely, my question is "how do I answer the previous question?"
01:38:34 <Jafet> We have no idea what you're talking about. Try posting a transcript of your ghci interaction.
01:38:35 <Eduard_Munteanu> (not realtime as in RT, but as in world time)
01:39:35 <Eduard_Munteanu> So if you're waiting for input in kernel it won't count that, I gather from its description.
01:40:16 <jkff> I'm doing nothing but calling "getCPUTime" in ghci several times. Let me create a sufficiently convincing-looking transcript :)
01:40:49 <Eduard_Munteanu> If so it, it means it's not that expensive to make a difference.
01:41:00 * ddarius should go running before it gets too late, and by "late" I mean early.
01:41:48 <jkff> Ouch. Disregard that, I totally misunderstood the semantics of getCPUTime :(
01:42:12 <jkff> I thought it's like Java's System.nanoTime() which returns nanoseconds elapsed since some point in the past
01:42:29 <Jafet> The keys are like right next to each other!
01:42:46 <ddarius> jkff: Don't worry.  I usually disregard statements of the form "Is my implementation broken or the libraries?"
01:43:00 <Eduard_Munteanu> :)
01:48:43 <Chaze> @pl (\a b -> a b)
01:48:43 <lambdabot> id
01:50:34 <Chaze> when i have a list of functions, lets say [Integer -> Integer] .. how would i use 'map' to apply all of them to the same argument?
01:51:01 <Jafet> The apply operator is ($).
01:51:16 <Chaze> ah, right. thank you
01:51:36 <Chaze> how is it defined?
01:51:41 <Jafet> @pl rightly recognizes flip ($) as flip id
01:51:41 <lambdabot> rightly recognizes flip id as flip id
01:51:51 <Jafet> \o/
01:51:56 <Jafet> @src ($0
01:51:56 <lambdabot> Source not found. Wrong!  You cheating scum!
01:51:58 <Jafet> @src ($)
01:51:59 <lambdabot> f $ x = f x
01:52:16 <Chaze> in lambda notation?
01:52:17 <jkff> Well... So where do I get a high-resolution timer then? System.Posix.Clock doesn't build on Windows :(
01:52:28 <Chaze> it should be (\a b -> a b).. but that's 'id'
01:52:56 <Jafet> They're all equivalent to some degree, Chaze
01:53:15 <jkff> > (+1) `id` 5
01:53:16 <lambdabot>   6
01:53:22 <jkff> > (+1) $ 5
01:53:23 <lambdabot>   6
01:53:44 <Jafet> But using `id` instead of $ is a good way to get strange looks
01:54:04 <Chaze> @pl (\a b -> b a)
01:54:04 <lambdabot> flip id
01:54:24 <Chaze> (flip id) == ($) ?
01:54:56 <sipa> :t ($)
01:54:57 <lambdabot> forall a b. (a -> b) -> a -> b
01:55:08 <Chaze> no, what i said is wrong
01:55:10 <sipa> :t id
01:55:11 <sipa> Chaze: no, id == $
01:55:11 <lambdabot> forall a. a -> a
01:55:21 <sipa> but restricted to function arguments
01:55:24 <Chaze> but:
01:55:33 <Chaze> > map ($ 1) [(* 2),(+ 2)]
01:55:33 <lambdabot>   [2,3]
01:55:43 <Chaze> >  map (id 1) [(* 2),(+ 2)]
01:55:44 <lambdabot>   [1,1]
01:55:48 <sipa> ($ 1) == \x -> x $ 1
01:55:57 <Chaze> >  map ((flip id) 1) [(* 2),(+ 2)]
01:55:57 <lambdabot>   [2,3]
01:56:05 <sipa> $ is an operator, and ($ 1) is a section
01:56:18 <Jafet> id 1 (*2) isn't supposed to typecheck; it's a lambdabotism
01:56:25 <Jafet> > 1 2 3
01:56:26 <lambdabot>   Ambiguous type variable `t' in the constraint:
01:56:26 <lambdabot>    `GHC.Num.Num t' arising f...
01:56:48 <Chaze> sipa: what's that, a section?
01:56:56 <Chaze> :t ($ 1)
01:56:57 <lambdabot> forall a b. (Num a) => (a -> b) -> b
01:57:04 <Chaze> :t ($)
01:57:05 <lambdabot> forall a b. (a -> b) -> a -> b
01:57:43 <nlogax> a partially applied operator (hope it's fine to call it that)
01:57:55 <sipa> > (-3) 5
01:57:56 <lambdabot>   -3
01:57:59 <sipa> > (- 3) 5
01:58:00 <lambdabot>   -3
01:58:09 <sipa> stupid prefix operator magic
01:58:23 <Chaze> > ((-) 3) 5
01:58:24 <lambdabot>   -2
01:58:30 <sipa> right
01:58:43 <sipa> > (3 (-)) 5
01:58:44 <lambdabot>   Ambiguous type variable `t' in the constraint:
01:58:44 <lambdabot>    `GHC.Num.Num t' arising f...
01:59:00 <sipa> oh that's not right
01:59:09 <Chaze> i thought the difference between operators and functions is entirely syntactical
01:59:14 <sipa> it is
01:59:25 <sipa> (`op`) means op
01:59:36 <sipa> (`op` x) means \y -> (y `op x)
01:59:40 <Chaze> > map (($) 1) [(* 2),(+ 2)]
01:59:41 <lambdabot>   [1,1]
01:59:47 <ddarius> sequence [succ, pred] 2
01:59:51 <Chaze> > map ($ 1) [(* 2),(+ 2)]
01:59:51 <ddarius> > sequence [succ, pred] 2
01:59:51 <lambdabot>   [2,3]
01:59:52 <lambdabot>   [3,1]
01:59:53 <sipa> (y `op`) means \x -> (y `op` x)
02:00:12 <sipa> (`subtract` 5) 3
02:00:13 <sipa> > (`subtract` 5) 3
02:00:14 <lambdabot>   2
02:00:16 <Chaze> :t sequence
02:00:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:01:20 <Chaze> so from my understanding ($ 1) is some syntax magic that somehow applies the second argument to the ($) function
02:01:44 <HugoDaniel> hello there
02:01:56 <Chaze> > map ((flip ($)) 1) [(* 2),(+ 2)]
02:01:57 <lambdabot>   [2,3]
02:02:27 <ddarius> Chaze: There is no more magic in ($ 3) than there is in (/ 2).
02:02:56 <Chaze> > (/ 2) 1
02:02:57 <lambdabot>   0.5
02:03:04 <Chaze> > ((/) 2) 1
02:03:05 <lambdabot>   2.0
02:03:09 <Chaze> i see
02:03:32 <sipa> (/) 2 "fills in" the first argument
02:03:45 <sipa> (2/) 1 "fills in" the second argument
02:04:40 <Chaze> for functions that are not operators, the only way to achieve this is flip?
02:04:54 <silver> > (2/) 1
02:04:55 <lambdabot>   2.0
02:06:18 <silver> Chaze, looks like no
02:06:43 <silver> > ('a' `elem`) "asd"
02:06:43 <lambdabot>   True
02:06:55 <silver> > (`elem` "asd") 'a'
02:06:56 <lambdabot>   True
02:07:07 <Chaze> ah, thanks
02:12:13 <sohum> I'm looking for a map with set semantics. as in - given an index, O(1) lookup and delete times, but it doesn't store the same element more than once
02:13:15 <Botje> so .. Data.Set? :P
02:13:36 <danr> Data.Set is O(log n)
02:13:48 <sohum> I don't think Data.Set has O(1) lookup/delete times
02:14:21 <danr> sohum: if you're using Int, then you might want to look at Data.IntSet
02:14:23 <mux> neither is Data.Map; your question made it look like you thought it had
02:14:38 <dobblego> why isn't cabal sdist compiling an executable in the .tar.gz?
02:14:39 <danr> Or Data.IntMap, then :)
02:15:22 <mux> cabal sdist is supposed to package a source tarball, not a pre-compiled binary
02:15:34 <dobblego> ah yeah duh
02:15:47 <engla> what's the complexity of Data.HashTable? Must be O(1) insert/lookup
02:16:04 <sohum> hang on, Data.Map isn't O(log n) lookup. huh.
02:16:15 <sohum> mux: thanks, I did not actually know that
02:16:44 <sohum> but in retrospect, it makes sense
02:16:54 <danr> sohum: Data.Map's lookup is indeed O(log n): http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
02:17:01 <sohum> it's using... yea, binary trees
02:17:12 * sohum shakes the hashmap assumptions out of his head
02:18:21 <dobblego> mux, what cabal command will produce a binary?
02:18:38 <engla> hm, what kind of strange hack is this HashTable thing?
02:18:43 <mux> dobblego: cabal configure followed by cabal build; but it won't produce a tarball
02:19:16 <danr> engla: So an type can be an instance of Hashable, which converts the elment to a hashvalue, an Int. This is then inserted in a Data.IntMap
02:19:31 <danr> a type*
02:21:40 <mino> hi, can someone help me to know how i could rename a cabal installed package? which i want to install says it needs integer -any (i need an old base) but now its named integer-gmp
02:24:34 <ezyang> mino: That's highly unlikely to work; you're more likely to have luck modifying this package's dependencies to update them. 
02:26:11 <mino> oh, and do you have any good reference on web who tell me how to do that? do you mean edit the package tarball which i want to install?
02:26:45 <ezyang> Yes. 
02:26:48 <ezyang> What package, btw ? 
02:27:09 <mino> hieroglyph is named is about 2d drawing with cairo
02:27:21 <ezyang> ...oh. 
02:27:25 <ezyang> That could get messy. 
02:28:08 <mino> damn, any other package with similar functionality? (cairo 2d mixed with gtk, and perhaps pango?=)
02:28:20 <ezyang> Though I'm not sure where the integer dep came from. 
02:28:42 <mino> it cames from base.4.1.0.0
02:28:56 <mino> it needs that exact version
02:29:10 <ezyang> ...oh. 
02:29:13 <ezyang> Don't do that. 
02:29:21 <ezyang> What version of GHC do you have? 
02:29:28 <mino> latest
02:29:36 <mino> latest non dev
02:29:47 <mino> 6.12.3
02:30:23 <ezyang> You might have to ferret out a 6.10 copy of GHC to get base-4.1 
02:30:58 <mino> mmm ok, i think it wont be difficult
02:31:27 <sohum> may as well use Data.Set, then. no real reason to use the index indirection
02:31:39 <sohum> @pl (a,b,c) -> (a,b,foo c)
02:31:39 <lambdabot> (line 1, column 9):
02:31:39 <lambdabot> unexpected ">" or "-"
02:31:39 <lambdabot> expecting variable, "(", operator or end of input
02:31:44 <sohum> @pl \(a,b,c) -> (a,b,foo c)
02:31:44 <lambdabot> (line 1, column 6):
02:31:44 <lambdabot> unexpected ","
02:31:44 <lambdabot> expecting letter or digit, operator or ")"
02:31:44 <lambdabot> ambiguous use of a non associative operator
02:32:34 <sohum> @hoogle (a,b,c) -> (c -> d) -> (a,b,d)
02:32:34 <lambdabot> No results found
02:32:46 <sohum> @hoogle (c -> d) -> (a,b,c) -> (a,b,d)
02:32:46 <lambdabot> No results found
02:35:01 <rothwell> the following gives me a list of pairs such that no member of the list contains a pair (n, m) such that n == m: filter (\(x,y) -> x /= y) $ concat $ map (\y -> map (\x -> (y, x)) a) a
02:35:21 <rothwell> i'd also like to pretend that (n, m) == (m, n) and remove those pairs too, though
02:35:35 <rothwell> is there a clean way to do this? the above's a bit of a eyeful
02:35:42 <ezyang> rothwell: that seems like a bit of a circuitous way round 
02:35:48 <rothwell> it does indeed...
02:36:20 <ezyang> rothwell: Is your equality not symmetric? 
02:37:00 <ezyang> also, what type is your function? As it stands it looks something like [[a]] (with appropriate constraints) 
02:37:04 <rothwell> ezyang: er, concretely, i'm getting a list of files to compare
02:37:06 <ezyang> *the domain 
02:37:14 <rothwell> i don't want to end up comparing files more often than necessary
02:37:29 <rothwell> also don't want to compare a file to itself
02:37:30 <ezyang> Ah. so you want to eliminate duplicates from the list? 
02:37:33 <rothwell> yeah
02:37:44 <ezyang> > nub [1,2,3,4] 
02:37:45 <lambdabot>   [1,2,3,4]
02:37:51 <ezyang> > nub [1,1,2,1,3] 
02:37:51 <lambdabot>   [1,2,3]
02:37:54 <ezyang> @src nub 
02:37:54 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:38:10 <ezyang> forget my last comment about map; I misinterpreted the inner map 
02:38:14 <ezyang> *type 
02:38:27 <ezyang> and then... generate pairs 
02:38:50 <ezyang> @hoogle [a] -> [(a,a)] 
02:38:50 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
02:38:50 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
02:38:50 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
02:38:56 <adnap_> how do you raise something to a decimal power in haskell?
02:39:04 <Botje> ^, ^^ or **
02:39:13 <rothwell> ezyang: hehe, i've wandered through the same functions you've just queried
02:39:31 <rothwell> not quite sure why i'm having trouble with this... brain doesn't seem to be firing
02:39:47 <ezyang> I guess use list monad 
02:39:58 <engla> adnap_: **
02:40:48 <sohum> @hoogle (a,b,c) -> (c -> d) -> d
02:40:48 <lambdabot> No results found
02:41:01 <sohum> @hoogle (c -> d) -> (a,b,c) -> d
02:41:01 <lambdabot> No results found
02:41:07 <sohum> @hoogle (a,b,c) -> c
02:41:08 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
02:41:08 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
02:41:49 <adnap_> engla: ty
02:42:15 * hackagebot splot 0.1.2 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.2 (EugeneKirpichov)
02:42:52 <sohum> :t foldM
02:42:53 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
02:43:56 <sohum> :t (>>=)
02:43:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:45:59 <sohum> @hoogle (m a -> b -> m a) -> m a -> [b] -> m a
02:45:59 <lambdabot> No results found
02:49:22 <otto_s> > let pairs [] = []; pairs (x:xs) = map ((,)x) xs ++ pairs xs in pairs [1..4]
02:49:23 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
02:50:17 * hackagebot splot 0.1.3 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.3 (EugeneKirpichov)
02:50:27 <rothwell> otto_s: nice... will take a few minutes to work that out
02:55:30 <silasdavis> could someone point me at haskell source code for zip?
02:55:50 <Twey> @src zip
02:55:50 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
02:55:50 <lambdabot> zip _      _      = []
02:56:02 <Twey> @src zipWith
02:56:02 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
02:56:02 <lambdabot> zipWith _ _      _      = []
02:56:09 <Twey> (zip = zipWith (,))
03:03:12 <ddarius> @hackage stm
03:03:13 <lambdabot> http://hackage.haskell.org/package/stm
03:06:58 <rkrzr> Does somebody know whether there is an example available for the usage of the OpenCLRaw library?
03:09:09 <silasdavis> thanks
03:09:25 <silasdavis> how could I convert a list of pairs to a flat list in the same order?
03:09:39 <silasdavis> [(1,2),(3,4)] --> [1,2,3,4]
03:09:39 <quicksilver> silasdavis: concatMap (\(x,y) -> [x,y])
03:09:57 <silasdavis> @src concatMap
03:09:57 <lambdabot> concatMap f = foldr ((++) . f) []
03:10:13 <quicksilver> concat map is map followed by concact
03:10:27 <quicksilver> > map (\(x,y) -> [x,y]) [(1,2),(3,4)]
03:10:27 <lambdabot>   [[1,2],[3,4]]
03:10:33 <quicksilver> > concat  [[1,2],[3,4]]
03:10:33 <lambdabot>   [1,2,3,4]
03:10:35 <quicksilver> see?
03:11:06 <silasdavis> ah yes, is the . in the previous defn where the argument is injected?
03:11:21 <silasdavis> haskell is very nice
03:13:06 <quicksilver> silasdavis: no.
03:13:14 <quicksilver> silasdavis: . is composition of two functions.
03:13:22 <silasdavis> ah
03:13:37 <quicksilver> that is not a very intuitive definition of concatMap unless you have a good understanding of what foldr does
03:13:47 <quicksilver> I would normally write : concatMap f = concat . map f
03:13:58 <quicksilver> which makes the choice of name fairly clear :)
03:15:01 <silasdavis> downright uninventive on the naming front yes
03:16:39 <silasdavis> how can i convert a list [1,2,3] to the string "1,2,3"?
03:16:46 <sohum> :t foldl (>>=)
03:16:47 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
03:17:04 <BONUS> silasdavis: intercalate "," . map show
03:17:09 <ddarius> concat = foldr (++) [], foldr/map fusion -> concat . map f = foldr (++) [] . map f = foldr ((++) . f) []
03:17:10 <sohum> :t foldl (flip >>=)
03:17:12 <lambdabot>     Occurs check: cannot construct the infinite type:
03:17:12 <lambdabot>       a = (a1 -> f b) -> f (a1 -> b) -> a
03:17:12 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
03:17:13 <BONUS> > intercalate "," . map show $ [1,2,3,4]
03:17:14 <lambdabot>   "1,2,3,4"
03:17:52 <sohum> :t (flip >>=)
03:17:54 <lambdabot> forall (f :: * -> *) a b b1. (Functor f) => ((a -> f b) -> f (a -> b) -> b1) -> f (a -> b) -> b1
03:17:56 <silasdavis> BONUS: great, thanks
03:18:05 <ddarius> > fix (show . intercalate ".")
03:18:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
03:18:06 <lambdabot>         against inferred type...
03:18:22 <ddarius> > fix (show . intercalate '.')
03:18:23 <lambdabot>   Couldn't match expected type `[a]'
03:18:24 <lambdabot>         against inferred type `GHC.Types...
03:18:30 <sohum> :t foldl (flip (>>=))
03:18:31 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
03:18:31 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
03:18:31 <lambdabot>     In the first argument of `flip', namely `(>>=)'
03:18:46 <sohum> :t \f -> foldl (flip (>>=) f)
03:18:47 <lambdabot> forall b a. (a -> b -> b -> a) -> (b -> a) -> [b] -> b -> a
03:19:29 <sohum> :t \f -> foldl (flip (>>=) $ f)
03:19:30 <lambdabot> forall a b. (a -> b -> b -> a) -> (b -> a) -> [b] -> b -> a
03:20:28 <sohum> oh, *bah*
03:20:29 <sohum> right
03:20:34 <sohum> I don't need any of that
03:21:00 <ddarius> > fix (flip intercalate ["(",")"])
03:21:02 <lambdabot>   "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
03:23:11 <quicksilver> sohum: are you looking for foldM, perhaps?
03:23:19 <Jafet> > iterate (flip intercalate ["(",")"]) ""
03:23:21 <lambdabot>   ["","()","(())","((()))","(((())))","((((()))))","(((((())))))","((((((()))...
03:23:46 <sohum> quicksilver: yep. and I found it, and I thought that wasn't it, because I had this idea in my head that the a parameter needed to be in the monad as well
03:24:19 <sohum> :t sequence
03:24:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:27:31 <quicksilver> sohum: foldM is also just sequence_ in a slightly 'higher' monad
03:27:42 <quicksilver> sohum: (that is, StateT a over the thing you had before)
03:27:43 <sohum> :t foldM
03:27:45 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:28:02 <sohum> that... kinda makes sense
03:28:56 <quicksilver> actually, possibly mapM_ in the higher monad.
03:28:56 <quicksilver> so (a -> b -> m a) becomes (b -> StateT a m ())
03:29:14 <quicksilver> mapAccumR is also very similar
03:29:21 <quicksilver> :t mapMAccumR
03:29:21 <lambdabot> Not in scope: `mapMAccumR'
03:29:26 <quicksilver> :t mapAccumR
03:29:27 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:29:36 <quicksilver> that's not-monadic, but it's the same thing as mapM in State acc
03:29:53 <sohum> yep, yep
03:32:05 <adnap_> you can have a tuple of infinite lists without forcing evaluation, right?
03:32:19 <BONUS> sure
03:32:30 <adnap_> okay, good
03:33:47 <quicksilver> > (take 3 *** take 2) ([1..],[3..])
03:33:47 <lambdabot>   ([1,2,3],[3,4])
03:34:27 <adnap_> :t ***
03:34:28 <lambdabot> parse error on input `***'
03:34:33 <adnap_> :t (***)
03:34:34 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:34:46 <adnap_> oh no!  not arrows!
03:34:51 <adnap_> does not compute
03:35:13 <quicksilver> adnap_: *** is just a way of applying take 3 to the left half of the tuple and take 2 to the right half
03:35:28 <quicksilver> adnap_: it was just so I could 'prove' to you that I could access both infinite lists.
03:35:41 * hackagebot fclabels 0.11.1 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-0.11.1 (SebastiaanVisser)
03:35:54 <adnap_> > (map (*2) *** take 2) ([1..],[3..])
03:35:55 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
03:35:56 <quicksilver> adnap_: I could have written let (a,b) = ([1..],[3..]) in (take 3 a, take 2 b)
03:36:19 <adnap_> I can have any two functions on lists that I like on either side of ***?
03:36:24 <quicksilver> adnap_: ...and I wanted to reduce both halves to finite because if the first half remains infinite the second half won't get printed.
03:36:27 <quicksilver> adnap_: yes, you can.
03:36:31 <adnap_> that's cool
03:36:51 <quicksilver> > ((!!2) *** head) ([1..],[3..])
03:36:52 <lambdabot>   (3,3)
03:38:39 <adnap_> Is this idea generalize to other n-tuples like (a,a,a)?
03:38:44 <adnap_> *Does this
03:39:01 <quicksilver> no.
03:39:05 <adnap_> aw
03:39:19 <quicksilver> you could write ternary versions
03:39:26 <quicksilver> but it's the thing about infix syntax
03:39:30 <quicksilver> N=2 looks nicest.
03:40:57 <sohum> @pl \b v -> b { foo = v }
03:40:58 <lambdabot> (line 1, column 11):
03:40:58 <lambdabot> unexpected "{"
03:40:58 <lambdabot> expecting variable, "(", operator or end of input
03:42:17 <quicksilver> sohum: @pl doesn't speak record selector notation.
03:42:24 <sohum> I noticed :P
03:42:34 <quicksilver> sohum: but, there is no short form of that - investigate fclabels or data.accessor on hackage
03:42:43 <quicksilver> for a more thorough treatment of labels
03:42:57 * sohum bookmarked
03:43:04 <sohum> but for now, I'll do it the dirty way
03:45:43 * hackagebot regular-xmlpickler 0.1.2 - Generic generation of HXT XmlPickler instances using Regular.  http://hackage.haskell.org/package/regular-xmlpickler-0.1.2 (ErikHesselink)
04:01:24 <Eduard_Munteanu> Why do I get non-exhaustive pattern errors here? http://hpaste.org/42142/nonexhaustive_patterns
04:02:29 <Eduard_Munteanu> I'm puzzled :/
04:05:23 <waern> seems like hackage passes -XHaskell98 to ghc 7 by default
04:05:43 <Eduard_Munteanu> Oh, I think I got it, it might be a bug in my implementation, and given my assumptions.
04:05:50 <sohum> @pl \d f b = set d b $ f (get d b)
04:05:50 <lambdabot> (line 1, column 8):
04:05:50 <lambdabot> unexpected "="
04:05:50 <lambdabot> expecting pattern or "->"
04:05:55 <Eduard_Munteanu> b:bs might not match.
04:05:57 <sohum> @pl \d f b -> set d b $ f (get d b)
04:05:57 <lambdabot> ap ((.) . ap . set) (flip (.) . get)
04:06:38 <sohum> @src modify
04:06:39 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:23:34 <quicksilver> sohum: modify is technically a method, I think
04:23:47 <quicksilver> sohum: but morally it's "s <- get; put (f s)"
04:24:00 <quicksilver> sohum: perhaps they imagine there might be a more efficient implementation in some monadstate instances.
04:24:50 <sohum> quicksilver: *nod*
04:29:43 <quicksilver> sohum: certainly if you were in a concurrency monad you might want modify to be atomic
04:29:44 <Cin> quicksilver: FWIW, get and put are the methods, modify is a derived function.
04:29:51 <quicksilver> oh, I'm wrong then
04:30:08 <Cin>  At least, in mtl. They could be implemented in the inverse way, that's true.
04:30:53 <Cin> (Where modify :: (s -> s) -> ms, and get = modify id, put = modify >=> return . const (), of course.)
04:31:38 <quicksilver> put x modify (const x) .... surely
04:31:44 <quicksilver> put x = modify (const x) .... surely, rather
04:35:01 <mino> why running a Setup.hs, it says me some packages are not installed when they are installed but in user config?
04:36:28 <quicksilver> mino: because it thinks you want to install against the global config
04:36:36 <quicksilver> mino: so, in that context, it's ignoring the user config.
04:38:12 <mino> oh, thank you, --user flag solved it you were right
04:45:06 <Cin> quicksilver: (Sorry, surely. put x = modify (const x) >> return ())
04:45:54 <jaspervdj> @seen chrisdone
04:45:55 <lambdabot> Unknown command, try @list
04:45:55 <preflex>  chrisdone was last seen on #haskell 5 days, 13 hours, 8 minutes and 28 seconds ago, saying: sinelaw: yup
04:48:28 <quicksilver> Cin: yes, the >> return () was the ..... part
04:51:57 <knobo> to understand monads better, I'd like to see an example that violates the monadic law: m >>= (f >>= h) = (m >>= f) >>= h
04:58:55 <hpc> knobo: how about the counter monad?
04:58:57 <parcs> knobo: make one up yourself ;) it's not that hard
04:59:30 <hpc> it works like the identity monad, but with every call to (>>=), it increments a counter
05:00:08 <hpc> you can write f as a function that doubles the counter, and the law is broken
05:01:20 <knobo> but one could implement a counter monad by using the state monad, and get it right, right?
05:02:07 <knobo> I think i got it now :) 
05:03:45 <knobo> I implemented the state monad in Lisp withouth having to look at the haskell version. That should mean that I pretty much got it (: I think :)
05:04:08 <sohum> @pl \ls -> zip (k:ls) ls
05:04:08 <lambdabot> zip =<< (k :)
05:04:42 <quicksilver> hpc: ITYM the counter "not-monad" ;)
05:04:52 <hpc> quicksilver: indeed
05:05:03 <knobo> good point
05:05:42 <opqdonut> the amonadic counter functor?
05:07:06 <quicksilver> however, I'm not sure it is a counter example to associativity.
05:07:12 <haskeller> is there a way to remove duplication when I defining the same function twice, but differently?
05:07:28 <quicksilver> I don't think you can write "f as a function which doubles the counter"
05:07:29 <haskeller> http://hpaste.org/42143/duplication
05:07:39 <quicksilver> haskeller: almost always, yes.
05:08:31 <haskeller> do you see any ways to do that on what i just pasted?
05:08:48 <quicksilver> yes, I'm just doing it
05:10:18 <haskeller> well, I just did abs', abs'' :: Int32 -> Maybe Int32
05:10:57 <haskeller> that's a start
05:11:36 <quicksilver> haskeller: http://hpaste.org/42144/mkabs
05:12:22 <haskeller> sweet! that allows me to add a third abs =D
05:12:28 <haskeller> thank you
05:12:39 <haskeller> do they have that karma thing here?
05:12:59 <opqdonut> quicksilver++ -- it seems so
05:13:00 <haskeller> @karma quicksilver 
05:13:00 <lambdabot> quicksilver has a karma of 22
05:13:07 <haskeller> @karma quicksilver++
05:13:07 <lambdabot> quicksilver++ has a karma of 0
05:13:15 <haskeller> opqdonut do it for me please
05:14:10 <haskeller> thanks
05:14:13 <ski> hpc,knobo : the "counter" (not-)monad doesn't violate `ma >>= (\a -> amb a >>= bmc)  =  (ma >>= amb) >>= bmc' ..
05:15:53 <quicksilver> ski: right, that's what I thought. rather, it violatees the unit laws.
05:15:55 <hpc> ski: ah, well it violates (>>= return) = id
05:16:16 <ski> .. however
05:16:20 <ski>   data MonadOn (f :: * -> *) :: * -> *
05:16:22 <ski>     where
05:16:41 <ski>     Return :: a -> MonadOn f a
05:16:50 <ski>     Bind :: MonadOn f a -> (a -> MonadOn f b) -> FreeMonad f b
05:16:56 <ski>     Lift :: f a -> MonadOn f a
05:16:58 <ski> does
05:17:08 <hpc> eek, GADTs
05:18:09 * ski was about to call that `FreeMonad f', but realized it would be free wrt the usual structure one'd think of (i.e. `return' and `join' plus laws)
05:18:30 <quicksilver> ski: although you can think of that as a monad, morally, because there is a natural notion of observation over which it satisfies the laws
05:18:33 <ski> (and apparently i missed striking one occurance down ..)
05:18:50 <quicksilver> or is there
05:18:55 <ski> yes, a quotient of that will be a monad
05:19:41 <ski> there's a `run :: Monad m => MonadOn m a -> m a' that can act as such an observation
05:20:20 <sohum> @pl \x -> if c == k then t else f
05:20:20 <lambdabot> const (if' (c == k) t f)
05:20:35 <sohum> @pl \x -> if x == k then t else f
05:20:35 <lambdabot> flip (flip if' t . (k ==)) f
05:21:32 <ski> quicksilver : possibly there's also a reformulation of it that will satisfy the laws
05:21:56 <ski> (similarly to how `CoYoneda f' makes a functor out of `f')
05:22:32 <quicksilver> ski: there are also probably examples which 'utterly' fail the laws, and no non-degenrate equivalence relation saves them
05:23:05 <sohum> @hoogle (a -> m b) -> (b -> c) -> a -> m c
05:23:05 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
05:23:21 <sohum> @hoogle (b -> c) -> (a -> m b) -> a -> m c
05:23:21 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
05:23:51 <bartavelle> is there a way to access stuff i defined in a "where", for example to get their type in ghci ?
05:23:57 <ski> @type (>>^)
05:23:58 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> (c -> d) -> a b d
05:23:59 <ski> @type (^>>)
05:24:01 <lambdabot> forall b c (a :: * -> * -> *) d. (Arrow a) => (b -> c) -> a c d -> a b d
05:24:10 <ski> sohum : looking for those ?
05:24:21 <quicksilver> bartavelle: sadly not
05:24:36 <bartavelle> ah, too bad !
05:25:15 <hpc> @src (>>^)
05:25:16 <lambdabot> a >>^ f = a >>> arr f
05:25:38 <hpc> @src (^>>)
05:25:38 <lambdabot> f ^>> a = arr f >>> a
05:25:59 <dblhelix> @type \k f -> Control.Monad.liftM f . (>>= k) . return 
05:26:00 <lambdabot> lexical error at character '\FS'
05:26:38 <sohum> ski: aaaah arrows. I *think* so...
05:26:39 <silasdavis> @src odd
05:26:39 <lambdabot> odd = not . even
05:26:43 <silasdavis> @src even
05:26:43 <lambdabot> even n = n `rem` 2 == 0
05:26:44 <sohum> ski: thanks!
05:26:44 <quicksilver> :t \act f -> fmap f . act
05:26:45 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f a) -> (a -> b) -> f1 (f b)
05:26:53 <quicksilver> :t \act f -> act . fmap f 
05:26:54 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (f b1 -> b) -> (a -> b1) -> f a -> b
05:26:54 <silasdavis> @src filter
05:26:54 <lambdabot> filter _ []     = []
05:26:55 <lambdabot> filter p (x:xs)
05:26:55 <lambdabot>     | p x       = x : filter p xs
05:26:55 <lambdabot>     | otherwise = filter p xs
05:27:04 <quicksilver> hmm
05:27:26 <dblhelix> sohum: \k f -> liftM f . (>>= k) . return
05:27:45 <sohum> :t \k f -> liftM f . (>>= k) . return
05:27:46 <lambdabot> forall a1 r (m :: * -> *) a. (Monad m) => (a -> m a1) -> (a1 -> r) -> a -> m r
05:27:54 <sohum> @pl \k f -> liftM f . (>>= k) . return
05:27:55 <lambdabot> flip ((.) . fmap)
05:28:07 <sohum> :t ((.) . fmap)
05:28:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:28:37 <sohum> heh
05:29:00 <leino> not sure if this is the place to ask, but I wish to upgrade quickcheck and I'm not sure how to go about doing that...
05:29:32 <byorgey> leino: cabal install QuickCheck-<version>
05:29:40 <byorgey> where <version> is the specific version you want
05:29:54 <leino> byorgey: which leads me to my next problem, I wish to install cabal :)
05:30:07 <byorgey> aha =)
05:30:16 <byorgey> leino: how did you install a Haskell compiler?
05:30:17 <leino> Im running debian stable
05:30:25 <leino> installed the debian package "ghc6"
05:30:26 <dblhelix> sohum: that uses the Functor instance for (->) a
05:30:43 <sohum> dblhelix: yea. is there a difference?
05:31:27 <byorgey> leino: just install the "cabal-install" package
05:31:47 <dblhelix> sohum: no, it's rather elegant... for some definition of elegant, I suppose ;-)
05:31:48 <byorgey> leino: in fact you may want to just install the "haskell-platform" package, which will pull in cabal-install and a bunch of other useful stuff as ewll
05:31:59 <leino> byorgey: doesnt seem to be in any of my repositiories
05:31:59 <sohum> dblhelix: :P
05:32:10 <dblhelix> sohum: it also assume that each monad is in Functor
05:32:26 <dblhelix> assumes even
05:32:52 <ski> @type (runKleisli .) . (Kleisli .) . (^>>)
05:32:53 <ski> @type (runKleisli .) . (>>^) . Kleisli
05:32:54 <lambdabot> forall (m :: * -> *) a b c. (a -> c) -> (c -> m b) -> a -> m b
05:32:55 <lambdabot> forall (m :: * -> *) a b c. (Monad m) => (a -> m c) -> (c -> b) -> a -> m b
05:33:15 <ski> sohum : you might want `Kleisli', maybe like that ^
05:33:28 * ski still wonders why there's a `Monad' in one, but not the other
05:33:45 <leino> byorgey: both of those packages seem to be only in debian/sid, whereas Im running debian/lenny
05:33:50 <sohum> dblhelix: instance Monad a => Functor a !
05:34:01 <byorgey> leino: oh, that's unfortunate. silly debian.
05:34:23 <leino> byorgey: yeah, tell me about it.. this is a frequent problem
05:34:24 <byorgey> leino: well, no worries, you can install it manually
05:34:32 <byorgey> leino: let me get you a link...
05:34:38 <sohum> ski: Kleisli looks iinteresting
05:34:40 <leino> byorgey: which leads me to my next question...
05:34:49 <sohum> man, I really should go learn about arrows
05:35:02 <byorgey> leino: http://hackage.haskell.org/platform/linux.html
05:35:23 <byorgey> leino: grab the tarball there under "build from source"
05:35:26 <ski> @src Kleisli
05:35:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:35:59 <ski>   newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
05:36:08 <ski>   instance Monad m => Arrow (Kleisli m)
05:36:17 <leino> byorgey: it seems I will have to install ghc at least 6.12.3... I have 6.8.2
05:36:22 <sohum> byorgey: just try the package cabal-install
05:36:35 <byorgey> leino: what!
05:36:49 <byorgey> leino: 6.8.2 is the version that you get from the 'ghc6' package in debian?
05:36:57 <sohum> byorgey: and ghc 6.12.1 is in testing
05:37:01 <leino> byorgey: yeah I guess so
05:37:08 <byorgey> yikes
05:37:15 <byorgey> well, 6.12.1 would probably be fine
05:37:15 <sohum> uh
05:37:25 <sohum> sorry, byorgey, I meant leino those past two lines :P
05:37:58 <sohum> leino: 6.12.1 is in testing. upgrade to that, then install the package cabal-install
05:38:01 <leino> sohum: ok, now we are moving more into debian territory, but if you bear with me...
05:38:37 <leino> I have tried to install packages from testing before... and frankly, it fucked my system up... I guess this is due to my ignorance of apt
05:39:05 <sohum> right. mind if we take this to pm, then?
05:39:15 <leino> sohum: not at all
05:39:58 <ManateeLazyCat> Wow, some Indian guy talk with me in Skype, and my Spoken English is not bad as i thought.
05:40:23 <hpc> ManateeLazyCat: lol
05:40:25 <byorgey> leino: you can also get a binary GHC package from here: http://haskell.org/ghc/download_ghc_6_12_3
05:40:52 <byorgey> if you decide you don't want to upgrade to debian testing
05:41:04 <hpc> ManateeLazyCat: you should hear how bad it can get in actual english-speaking countries like the US
05:41:06 <ManateeLazyCat> hpc: Really, I join ##English and #Mandarin #learnanylanguage, and some guy help me much about my Spoken English
05:41:24 <ManateeLazyCat> hpc: You know, it's my first time talk English to other people.
05:41:41 <ManateeLazyCat> hpc: Unbelievable, we talk 40 minutes.
05:43:30 <Nibble> A quick question
05:43:34 <Nibble> deleteBy
05:43:40 <Nibble> the type is pretty counter intuitive
05:43:45 <hpc> :t deleteBy
05:43:46 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
05:43:59 <hpc> o.O
05:44:00 <ManateeLazyCat> @hoogle deleteBy
05:44:00 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:44:18 * hpc expected (a -> Bool) -> [a] -> [a]
05:44:18 <Nibble> why not just do a deleteBy (=='a') "helloa"  accomplishes the same thing
05:44:25 <Nibble> is there any reason for this?
05:44:43 <quicksilver> hpc: that's filter :)
05:44:57 <quicksilver> Nibble: it's allowing you to specify your own Eq instance
05:45:04 <quicksilver> that' what (a -> a -> Bool) is
05:45:09 <quicksilver> like nubBy and sortBy
05:45:26 <quicksilver> it's not terribly useful, but it's consistent.
05:45:33 <Nibble> ok
05:45:38 <Nibble> just struck me as odd
05:45:53 <hpc> quicksilver: it's included to appease those wankers in #haskell who insist on it being in the standard library? :D
05:45:58 <ManateeLazyCat> hpc: To be honest, that guy's accent like the people in "The Big Bang", you know? ;p
05:46:06 <Nibble> since filter has the inline equality testing stuff
05:47:05 <quicksilver> hpc: not sure about that choice of tone
05:47:17 <quicksilver> hpc: as far as I know, nothing in the online report was based on anything anyone said in #haskell
05:47:19 <byorgey> > deleteBy (>) [1,2,3,4,5,3,6,2,1,5]
05:47:20 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[t]])
05:47:20 <lambdabot>    arising from a ...
05:47:26 <quicksilver> I'm pretty sure it predates the channel.
05:47:32 <byorgey> > deleteBy (>) 3 [1,2,3,4,5,3,6,2,1,5]
05:47:33 <lambdabot>   [2,3,4,5,3,6,2,1,5]
05:47:51 <hpc> quicksilver: ah; i remember hearing a joke about how #haskell is the reason for all useless functions on hackage
05:48:05 <hpc> i thought i heard it here
05:48:26 <quicksilver> hackage != standard library though :)
05:48:44 <byorgey> > deleteBy (<) 3 [1,2,3,4,5,3,6,2,1,5]
05:48:45 <lambdabot>   [1,2,3,5,3,6,2,1,5]
05:48:47 * hpc was never good at history ;)
05:49:06 <hpc> @src deleteBy
05:49:06 <lambdabot> deleteBy eq x []        = []
05:49:06 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
05:49:17 <byorgey> oh, I see.  That is... odd.
05:49:39 <hpc> @hoogle filterBy
05:49:39 <lambdabot> No results found
05:49:54 <hpc> er, that wouldn't be very different from filter <.<
05:50:00 <ketil> Hm - isn't this akin to groupBy etc?
05:50:05 <ketil> @src groupBy
05:50:05 <lambdabot> groupBy _  []       =  []
05:50:05 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:50:05 <lambdabot>     where (ys,zs) = span (eq x) xs
05:50:12 <byorgey> I think that's the motivation for the type
05:50:30 <byorgey> but it's a bit different. groupBy, sortBy, etc. use the provided function to compare elements of the list to each other
05:50:53 <byorgey> whereas deleteBy applies the provided function to the provided argument and to elements of the list
05:51:20 <byorgey> which is odd.  why not just provide a partially applied version of the function in the first place ?
05:51:33 <ketil> so essentially, the function is always applied to the provided parameter... right.
05:51:47 <ketil> deleteBy (eq x) ys would make more sense.
05:51:54 <byorgey> indeed.
05:52:11 <ski> > delete 'o' "foo"
05:52:12 <lambdabot>   "fo"
05:52:25 <ski> > "foo" \\ "o"
05:52:26 <lambdabot>   "fo"
05:52:32 <ski> @src (\\)
05:52:32 <lambdabot> (\\) = foldl (flip delete)
05:52:38 <hpc> :t (\\)
05:52:38 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
05:52:52 <hpc> "foo" \\ "oo"
05:52:55 <hpc> > "foo" \\ "oo"
05:52:56 <lambdabot>   "f"
05:53:06 <ski> > repeat 'f' \\ "oo"
05:53:07 <lambdabot>   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff...
05:53:10 <hpc> > "ofo" \\ "oo"
05:53:11 <lambdabot>   "f"
05:53:41 <ray> > "fofofo" \\ "oo"
05:53:42 <lambdabot>   "fffo"
05:54:05 <silasdavis> what lightweight syntax can I use to write the function \x -> x*2
05:54:08 <quicksilver> byorgey: right. it's consistent in that sense but still odd.
05:54:10 <quicksilver> silasdavis: (*2)
05:54:31 <silasdavis> oh, I should have just tried that, thanks
06:00:49 <bartavelle> I'm trying to do this : http://pastebin.ca/2012846
06:01:12 <bartavelle> I'm stuck when trying to define an instance of GameState, as it whines about the type of my output
06:01:23 <bartavelle> does that make sense ? 
06:01:28 <bartavelle> (what I'm trying to do)
06:02:11 <bartavelle> if that makes sense, how can I define "getDecisions" (I already have a decision instance, but cheated by declaring getOutcome dc gs = [ ])
06:02:53 <quicksilver> bartavelle: the type of 'getDecisions' says that, for a given GameState you can get a list of *any* instance of Decision
06:03:10 <quicksilver> in other words "the caller gets to choose" which type, being an instance of Decision, it wants.
06:03:13 <ski> > repeat 'f' \\ repeat 'o'
06:03:14 <quicksilver> is that what you intend?
06:03:18 <lambdabot>   mueval-core: Time limit exceeded
06:03:23 <bartavelle> I'm not sure
06:03:26 <ski> > let (\\) = foldr delete in repeat 'f' \\ repeat 'o'
06:03:30 <lambdabot>   mueval-core: Time limit exceeded
06:03:38 <quicksilver> bartavelle: then I can't help you.
06:03:40 <quicksilver> :)
06:03:50 <bartavelle> haha
06:03:50 <bartavelle> wait
06:03:55 <bartavelle> http://pastebin.ca/2012849
06:03:59 <hpc> ski: it's strict in the second argument, because GHC can't know there isn't an 'f' at the very end of that string
06:04:01 <bartavelle> this is what i want to do
06:04:11 <hpc> also because of the code itself :P
06:04:17 <ski> hpc : yeah, i realized that :)
06:08:37 <ski> bartavelle : maybe you actually wanted `getDecisions :: gs -> exists dc. Decision dc *> [dc]' ?
06:08:50 <ski> or maybe `getDecisions :: gs -> [exists dc. Decision dc *> dc]' ?
06:09:09 <ski> or maybe you want to have a class which has both `gs' and `dc' as type arguments ?
06:09:24 <bartavelle> that's probably the last statement yes
06:09:32 <bartavelle> i should give gs and dc
06:09:38 <bartavelle> in a single class
06:10:07 <bartavelle> (I don't understand the syntax of the two others, so they might apply)
06:10:18 <phao> very interesting... found some video lectures on haskell here for the book I'm reading =)
06:12:19 <cch`> when I try to profiling a program using parsec, ghc tell me "profiling libraries for package `parsec-3.1.0'" not installed , any suggestion? thanks
06:13:27 <bartavelle> of course I can't have multi parameters classes with vanilla
06:13:31 <quicksilver> cch`: reinstall parsec with profiling.
06:13:54 <quicksilver> bartavelle: you shouldn't be concerned about MPTC
06:14:03 <quicksilver> bartavelle: it's not a "controversial" extension, it's a very natural one.
06:14:13 <bartavelle> ok
06:14:18 <cch`> quicksilver: I install parsec from cabal
06:14:43 <quicksilver> cch`: then you reinstall it the same way, with profiling ;)
06:14:59 <cch`> do need I need add any options to cabal ?
06:15:00 <quicksilver> I think the cabal option is called --enable-library-profiling, or some such
06:15:09 <quicksilver> you can make it a default in .cabal if you profile a lot
06:15:49 <cch`> ok let me try, thank you so much 
06:23:43 <benmachine> quicksilver: arguably MPTC isn't that useful without more controversial extensions though
06:23:52 <benmachine> *aren't
06:24:00 <benmachine> *MPTCs aren't I suppose
06:45:52 <arkonten> I needed a "stateless" random generator for some testing and I come up with this: http://hpaste.org/42145/stateless_random_generator
06:45:56 <arkonten> punish me!
06:48:21 <Saizan> arkonten: randomRIO
06:48:46 <phao> damn, it's killing me... 
06:49:00 <phao> I'm trying a book example from a book, and I'm getting errors
06:49:16 <arkonten> Saizan: I'll be damned... thanks!
06:49:46 <phao> http://ix.io/1in
06:49:49 <phao> what is the problem with this code?
06:49:58 <phao> I'm getting "<interactive>:1:9: parse error on input `='"
06:50:03 <phao> right when I type the first line in the interpreter
06:50:06 <Saizan> you've to put it in a file
06:50:22 <Saizan> and then load that file from ghci with :l thatfile.hs
06:50:43 <phao> hmm
06:50:44 <phao> ok
06:50:54 <phao> working =) thx
06:51:05 <phao> anyway I can type in that code directly into the interpreter?
06:51:32 <Saizan> let mysum [] = 0; mysum (x:xs) = x + mysum xs
06:51:42 <phao> right
06:51:46 <phao> thx
06:52:30 <byorgey> not recommended though.  the usual method is to type things in a file, then just type :r to reload it in ghci every time you change something
06:52:40 <phao> hmm
06:52:43 <phao> why is that//
06:53:06 * ClaudiusMaximus agrees - otherwise the things you defined 2 days ago are no longer in ghci's history and you can't remember what you wrote :)
06:53:29 <phao> heh
06:54:05 <ClaudiusMaximus> that actually happened to me today - how do i make ghci store more history?
06:54:09 <phao> I think I'm going to like this language
06:54:17 <phao> thx people
06:55:32 <Saizan> also, ghci has a few hacks (like extended defaulting) that are nice for evaluating single expressions, less so for definitions, and in general an haskell source is not meant to be interpreted line by line, but as a single potentially mutually referring block
06:55:45 <Saizan> (i.e. the order of definitions doesn't matter)
06:56:10 <Saizan> and then ghci simply doesn't support data/class/instance declarations at the prompt
06:56:31 <ClaudiusMaximus> right.  in ghci if you do:  let n = 256    \n   let y = 1 / n    -> you get an error because n defaulted to an integral type...
06:57:34 <arkonten> is there a way to get the least number below some x w.r.t. to its precision? E.g. to get 0.9999...-something from the Float 1.0? 
06:58:32 <aWagner> Hello, I am stuck. I need to find the indicies of tuples in a list in which the first element of the matching tuple(s) is greater than or equal to some Int and the second element of the tuple(s) matches some Char.
06:58:54 <aWagner> Can someone point me in the right direction?
07:00:17 <Zao> aWagner: zipWith f [0..] xs  with f = \(x,(y,z)) -> ...
07:00:37 <Zao> And then filter that on snd or so.
07:00:56 <abbe> http://www.youtube.com/watch?v=BipvGD-LCjU
07:01:10 <ClaudiusMaximus> > let nextBefore n = last . takeWhile (\x -> n - x /= n) . iterate (/2) $ 1 in nextBefore 1
07:01:13 <lambdabot>   1.1102230246251565e-16
07:01:25 <ClaudiusMaximus> well, something like that perhaps...
07:02:04 <int-e> > uncurry encodeFloat . first pred . decodeFloat $ 1.0 -- needs to be fixed for 0 and negative powers of 2.
07:02:06 <lambdabot>   0.9999999999999998
07:03:02 <ClaudiusMaximus> ah, that reminds me - i've been writing bindings for libqd and i still haven't worked out how to implement encodeFloat and decodeFloat for its types...
07:03:38 <ClaudiusMaximus> stuff like   data DD = DD Double Double   where DD a b represents a + b
07:03:58 <Zao> arkonten: I expect you want something similiar to 'eps' in matlab?
07:04:29 <Zao> (which gives you the distance to the next above FP number)
07:04:33 <arkonten> Zao: yeah, machine epsilon
07:04:46 <fryguybob> > last . takeWhile (/= 1) . map (+1) . iterate (/2) $ 1
07:04:47 <lambdabot>   1.0000000000000002
07:05:23 <int-e> ClaudiusMaximus: presumably decodeFloat is something like let (m1, e1) = decodeFloat f1; (m2, e2) = decodeFloat m2; e = min e1 e2; m = m1 * 2^(e1 - e) + m2 * 2^(e2 - e). encodeFloat is trickier because it has to take apart the Mantissa.
07:07:42 <int-e> ClaudiusMaximus: where the number is DD f1 f2; I wrote m2 instead of f2 above though.
07:08:31 <ClaudiusMaximus> int-e: yeah - but i could probably use the data invariant like i did for toRational:  toRational (DD a b) = toRational a + toRational b   -- and similarly with fromRational
07:08:50 <ClaudiusMaximus> int-e: thanks for the ideas
07:10:11 <ClaudiusMaximus> int-e: fromRational k = let a = fromRational k ; k' = k - toRational a ; b = fromRational k' in  DoubleDouble a b
07:10:18 <int-e> ClaudiusMaximus: I actually did that. taking the minimum of the exponents and adding the corresponding (shifted) mantissas is how you'd add two numbers of the form  m*2^e  the results of decodeFloat.
07:10:37 <ClaudiusMaximus> :)
07:10:55 <ClaudiusMaximus> :t decodeFloat
07:10:58 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
07:11:25 <ClaudiusMaximus> i'd probably use instance Bits Integer
07:12:19 <int-e> yeah, I was lazy. you shouldn't even shift the part which has the smaller exponent.
07:14:19 <zygoloid> int-e: of course, if you want to round correctly, it's harder: http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/addsf3.c
07:14:32 <zygoloid> fsvo "correctly"
07:15:09 <ClaudiusMaximus> a short (work-in-progress) video made with the help of haskell (finding coordinates to zoom in on; generating latex source for the subs; misc ghci-ing to compute various magic numbers) >> http://claudiusmaximus.goto10.org/v/mandelbrot/with-subs.ogv
07:20:17 <aWagner> Zao: What is "with"?
07:23:18 <Muncuie> 0,0 kontol
07:24:43 <Sina> Hi everyone...
07:27:32 <Sina> How to check if a list is empty? (without pattern matching), is there any function for it?
07:28:32 <benmachine> Sina: null
07:29:01 <Sina> benmachine: cheers
07:29:15 <Saizan> ClaudiusMaximus: omg, you found the bottom!
07:30:29 <ClaudiusMaximus> Saizan: heh, that's where 'Double' isn't precise enough to distinguish neighbouring pixels - and why I've been writing bindings to libqd
07:34:21 <Sina> Is it possible to have two arguments in where? like where a= fst pair , b= snd pair ?
07:34:43 <BONUS> yeah. but better to do where (a,b) = pair
07:35:30 <Sina> BONUS:thanks, I will do where (a,b) = pair, but how to have two things in where? :)
07:35:53 <BONUS> where a = fst pair
07:35:57 <BONUS>        b = snd pair
07:36:11 <Sina> BONUS: great, thanks :)
07:36:11 <BONUS> whoops, indented one space too much
07:36:14 <Saizan> except that b has to be aligned with 'a'
07:36:22 <Saizan> "where x = foo; y = bar" also works
07:36:39 <Sina> aligned? ok.
07:37:04 <Sina> saizan: thanks
07:37:46 <ManateeLazyCat> I talking with some American on Skype, they can understand my Spoken English. Sweet... :)
07:39:44 <Jafet> You can probably attend a Newcastle football match and not hear a sentence of proper english
07:40:33 <kmc> Sina, yeah.  when two lines within 'let', 'where', 'do', or 'of' are aligned, they get an invisible semicolon between them
07:40:39 <ManateeLazyCat> Jafet: Hehe. :)
07:40:49 <kmc> when a line starts to the left of the line which started the block, the whole block closes
07:41:03 <kmc> when a line starts to the right of the first line, it continues the previous line and no implicit punctuation is added
07:42:58 <Sina> kmc: thanks. will keep that in mind :)
07:43:45 <Jafet> ClaudiusMaximus: what do the numbers mean?
07:45:18 <ClaudiusMaximus> Jafet: they're angled internal addressed as defined in http://arxiv.org/abs/math/9411238v2
07:45:41 <ClaudiusMaximus> Jafet: each cardioid is labeled with the period of its attractor
07:46:08 <Jafet> I didn't know periods existed for such well-rounded numbers
07:46:22 <Jafet> I guess there is a period for every positive integer then
07:49:26 <ClaudiusMaximus> Jafet: well, there is at least 1 "mu-atom"/"hyperbolic component" for every positive integer - but no cardioid-shaped one for period 2
07:50:18 <ClaudiusMaximus> Jafet: see also http://mrob.com/pub/muency/enumerationoffeatures.html
07:51:31 <ClaudiusMaximus> @oeis 1, 0, 1, 3, 11, 20
07:51:32 <lambdabot>  Sequence not found.
07:56:29 <Zao> @t zipWith
07:56:30 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:56:33 <Zao> @type zipWith
07:56:34 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:57:38 <roconnor> koninkje_away: are you away?
08:03:03 <bartavelle> followup of the "MultiParamTypeClasses", I don't know how to do this : http://pastebin.ca/2012951
08:03:09 <bartavelle> this seems to be really tricky
08:03:35 <bartavelle> if somebody has an idea on how to do that in a simpler way I'd be really happy
08:06:22 <bartavelle> should i define instances with generic types for all functions that only have one type as a parameter, and then other functions with specific types ??
08:08:22 <bartavelle> hum it works with functional dependencies
08:12:13 <quicksilver> bartavelle: at a glance it seems likely you want gs to uniquely determine dc, and you should make that explicit with a fundep or a type family
08:12:35 <bartavelle> i did a functional dependency
08:12:40 <bartavelle> it seems to work nice
08:13:04 <bartavelle> but I'm not sure what I am doing, what are those extensions supposed to be regarding to Haskell ?
08:13:29 <bartavelle> they are built-in, so why do I have to activate them ? For compatibility purpose with older ghc ?
08:13:50 <bartavelle> I guess I should just google
08:14:06 <roconnor> multiprameter type classes are not part of any offical Haskell
08:14:36 <bartavelle> so ghc is to haskell what vim is to vi ? a nonstandard, yet extremely more user friendly derivate ?
08:14:50 <roconnor> sort of I guess
08:15:16 <quicksilver> bartavelle: I don't think extensions are really about user-friendlyness :)
08:15:22 <roconnor> I'm not sure IncoherentIntances is user friendly :D
08:15:31 <bartavelle> well, it gets me working :)
08:15:31 <quicksilver> extensions are about exploring how the language might be expanded
08:15:47 <kmc> bartavelle, "Haskell" is a standard language with a specification
08:15:53 <quicksilver> however, when people say 'Haskell' there is a good chance they are actually thinking of some GHC dialect
08:15:55 <kmc> GHC implements features above and beyond what's required by the specification
08:16:08 <kmc> but for compatibility with the spec, you have to enable them
08:16:20 <bartavelle> ok
08:16:28 <kmc> there's actually a few versions of the Haskell spec; in GHC 7 the latest spec (Haskell 2010) is the default
08:16:47 <kmc> but there's still many features GHC has supported for 5+ years that aren't in the spec
08:16:53 <bartavelle> does that mean that using them is bad ? or that nobody cares as everybody use GHC anyway ?
08:16:58 <kmc> mostly the latter
08:17:18 <quicksilver> using extensions is not bad in principle
08:17:19 <kmc> the extensions range from "trivial but handy syntax that makes your life easier" all the way to "oh god now the type system is punching me in the face"
08:17:20 <bartavelle> ok, then I'll not try to find a workaround and just enable them
08:17:22 <quicksilver> some of the extensions are bad.
08:17:37 <kmc> so it really depends on which ones
08:17:43 <quicksilver> (in my opinion, but that's the only one I'm qualified to give)
08:18:15 <kmc> some of them break the nice guarantees from Haskell 98, like the idea that type inference always works, or that the compiler will always terminate successfully if your program is type-correct
08:18:35 <kmc> some of them make error messages a lot more confusing
08:18:41 <kmc> these are reasons to have them off by default
08:19:30 <kmc> i think the only extension to H2010 which is really necessary for real-world code is Rank2Types
08:19:36 <kmc> most of the rest can be worked around without too much pain
08:19:46 <roconnor> bartavelle: multiparameter type classes + fundeps are two very common extensions.
08:19:56 <bartavelle> I would be really interested in a suggestion on how to work around this
08:20:00 <quicksilver> some are nice ideas but we don't yet know the best way to imlpement them.
08:20:27 <quicksilver> bartavelle: multi parameter type classes are almost useless without either FDs or type families.
08:20:33 <quicksilver> so it's fine to use one or another
08:20:48 <quicksilver> if you're asking a bigger question about what you're doing, then my default answer is "don't use a typeclass for that"
08:20:55 <quicksilver> but I can't really see what you're actually trying to do.
08:21:01 <bartavelle> a generic game solver
08:21:09 <bartavelle> perhaps it is a bit too ambitious
08:21:10 <bartavelle> :)
08:21:48 <kmc> there's a fallacy that generic code => type classes
08:21:58 <kmc> sometimes the easiest design is to just pass around a record of functions
08:22:01 <kmc> or even a single function
08:22:12 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
08:22:21 <kmc> i think type classes are significantly overused
08:22:49 <HugoDaniel2> i want to to very fast parsing of a C like language, what is the best tool to use ?
08:22:51 <HugoDaniel2> parsec ?
08:23:02 <mux> I think they are often overused because there are no other mechanism to have open data types
08:23:03 <Zao> Mangle Language.C until it fits your world?
08:23:06 <bartavelle> passing around functions likethat makes me feel like when i'm doing OOP in plain C
08:23:23 <shepheb> I'm trying to write a Minesweeper solver. I'm just getting started but I'm already sick of using STArrays. anyone with a better idea for data structures to hold the game board?
08:24:42 <quicksilver> shepheb: Data.Map
08:25:13 <quicksilver> shepheb: Haskell Array Rules: Rule 1 - Don't use arrays.
08:25:30 <roconnor> harsh rule
08:26:07 <bartavelle> Data.Map element access is O(log n), while with an array it O(1)
08:26:17 <shepheb> "Rule 2: Now, this term, I don't want to catch anybody not drinking."
08:26:25 <kmc> but updating Array takes a full copy
08:26:25 <roconnor> log n is like 32
08:26:31 <kmc> while updating Map copies only log n elements
08:26:38 <bartavelle> ah indeed
08:26:42 <shepheb> bartavelle: I care more about convenience for me than for runtime, I don't want to have to use the monadic interface
08:26:45 <kmc> if you have a read-only finite map, Array is appropriate
08:26:55 <kmc> and STArray / IOArray are completely different beasts
08:27:07 <shepheb> IArrays are brilliant for dynamic programming, too. but I'm not doing that.
08:27:20 <revenantphx> shepheb: i'd love to hear details on that 0.o
08:27:28 <shepheb> revenantphx: on which?
08:27:34 <quicksilver> bartavelle: wrong. Array element access is O(log n). Data.Map element access is O(log n).
08:27:35 <kmc> i think most dp can be represented as memoized recursion in which case data-memocombinators or MemoTrie is an even nicer way to write it
08:27:54 <revenantphx> nevermind.
08:28:50 <kmc> shepheb, my recommendation is Data.Map for simplicity, Data.IntMap if you need speed (or your keys are already Int)
08:29:04 <bartavelle> but array access should be O(1) according to my imperative programming wisdom :/
08:29:18 <ente> hi
08:29:19 <kmc> bartavelle, find a machine that can address an unbounded amount of memory in a constant pointer size
08:29:31 <bartavelle> this is not a practical question
08:29:34 <ente> is there a statically linked ghc version?
08:29:36 <shepheb> kmc: the keys are pairs of ints, but the Minesweeper board isn't very big, N is only about 40x25
08:29:40 <kmc> ok
08:29:42 <kmc> probably Map is fine
08:29:46 <kmc> simplest :)
08:29:49 <quicksilver> bartavelle: it is exactly as practical as addressing an unbounded amount of memory in a tree
08:29:56 <ente> this whole "wrong gmp version" is annoying
08:29:57 <quicksilver> bartavelle: they are teh same problem.
08:30:10 <kmc> i'm starting to think the teaching of asymptotic analysis in CS schools does more harm than good
08:30:10 <quicksilver> certainly an array has a better constant factor for read acces.
08:30:24 <ente> linking everything except glibc statically would be nice
08:30:40 <bartavelle> I do not get it
08:30:51 <kmc> ente, if you can't link gmp statically, one workaround is to use integer-simple instead of integer-gmp
08:31:00 <kmc> another would be to bundle libgmp.so
08:31:08 <quicksilver> but the sharing between old + new versions of the map can occasionaly make it actually asymptotically faster than an array, as kmc hinted.
08:32:08 <quicksilver> bartavelle: the point of asymptotic analysis is to measure the speed as "n" goes to infinity.
08:32:15 <bartavelle> that is not what i mean
08:32:20 <kmc> i'd like to point out that Criterion is a great library and easy to use
08:32:25 <quicksilver> bartavelle: your pointers are artificially bounded by 2^32 or 2^64
08:32:35 <bartavelle> yes but i can't reasonnably work on more
08:32:38 <quicksilver> bartavelle: ... if you permit a map the same artifical bound then it is *also* O(1)
08:32:44 <ente> kmc: guess I'll just symlink it and build my package, I don't expect upstream to react on this
08:32:54 <bartavelle> map is a binary tree
08:32:59 <quicksilver> bartavelle: "can't reasonably work on" is not an asymptotic analysis.
08:33:01 <kmc> yep, Data.IntMap has O(1) everything because the depth of the tree is at most 64
08:33:08 <bartavelle> ok i get your point
08:33:14 <bartavelle> mine is that it doesn't really matter
08:33:19 <kmc> and the worst case depth of Map is much higher, but still finite
08:33:36 <kmc> yes, just profile your code if you think it's slow
08:33:42 <quicksilver> kmc: I think depth of tree in Data.Map is at most 65, isn't it, because of the balancing.
08:33:52 <kmc> maybe
08:33:55 <quicksilver> kmc: (assuming your memory model can only store 2^64 cells)
08:34:01 <quicksilver> maybe you can get deeper by laziness, actually
08:34:06 <quicksilver> the tree doesn't all have to be there.
08:34:15 <kmc> yeah, the "depth" of nested thunks is another question too
08:34:19 <quicksilver> ...but the balancing does tend to force it.
08:34:39 <quicksilver> bartavelle: OK, but don't tell us it's a question of asymptotics, then.
08:34:42 <quicksilver> because it's not asymptotics.
08:34:49 <bartavelle> ah !
08:34:53 <bartavelle> indeed it is not
08:34:56 <quicksilver> it's just "I think array access is faster than Data.Map"
08:34:57 <kmc> analyzing performance of lazy programs is Fucking Hard, especially in terms of half-baked Algorithms 101 asymptotic analysis
08:34:59 <quicksilver> and you might be right.
08:35:02 <quicksilver> actually you are right
08:35:04 <kmc> @quote ChrisOkasaki
08:35:05 <lambdabot> ChrisOkasaki says: Historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict.
08:35:11 <bartavelle> it is more, array access should be faster than data.map
08:35:12 <quicksilver> but the difference is much smaller than you imagine.
08:35:33 <quicksilver> data.map is just following a few pointers, and modern CPUs are pretty good at following pointers
08:35:44 <quicksilver> and GHC is pretty good at arranging for your structure to be in cache line.
08:35:52 <quicksilver> following a pointer in-cache is "free"
08:36:00 <roconnor> kmc: if you are computing upper bounds on time complexity, anaylsing lazy programs as strict should work.
08:36:16 <quicksilver> roconnor: but you can be infinitely pessimistic
08:36:19 <roconnor> yes
08:36:35 <quicksilver> you can conclude that a program doesn't terminate, for example, when it doe :)
08:36:36 <roconnor> though techically the same is true for analysing strict programs
08:37:07 <roconnor> ... I will just approximate this while loop by an infinite loop ... :D
08:39:35 * roconnor is starting to think that delimited control operators are really important
08:40:04 <crutcher> if I install a newer GHC, what do I need to do to recompile my installed packages?
08:40:28 <quicksilver> crutcher: new GHC major version or new GHC minor version?
08:40:43 <crutcher> major version, thinking of installing ghc 7
08:40:56 <quicksilver> almost certainly you'll need to download new ones from hackage
08:41:02 <quicksilver> many packages won't be compatible.
08:41:23 <crutcher> is there a command I can give to cabal, or some sequence of commands?
08:41:25 <kmc> roconnor, but you're interested in bounding individual operations, not the whole program
08:41:29 <kmc> laziness will make some ops slower and some faster
08:41:41 <crutcher> or do I need to wipe my haskell install and start from scratch?
08:41:41 <kmc> in particular, it tends to turn regular analysis into amortized analysis
08:43:08 <kmc> crutcher, wiping / moving the package db should suffice
08:43:09 <quicksilver> crutcher: you don't particularly need to wipe it
08:43:21 <quicksilver> crutcher: the new GHC will automatically have a clean package database
08:43:24 <quicksilver> as far as I understand it
08:43:30 <kmc> in fact i think quicksilver's right
08:43:32 <quicksilver> you can keep your old packages to use with the old GHC
08:43:41 <kmc> i thought there was also one in ~/.cabal but i guess not
08:44:31 <crutcher> thanks; I need a better understanding of cabal and packages I think
08:44:48 <quicksilver> kmc: there is, but it's in .ghc/arch-6.x.y/package.conf.d
08:45:02 <crutcher> how do I update cabal to use the new ghc?
08:45:02 <quicksilver> kmc: (where arch is a metasyntactic variable for i386-linux or whatever)
08:45:19 <crutcher> or does it just use whatever is at /usr/bin/ghc?
08:45:23 <quicksilver> I *think* the 'cabal' command is controlled by what it finds on the path
08:45:28 <quicksilver> so it will use the ghc and ghc-pkg on PATH
08:45:37 <quicksilver> doesn't matter what it was "compiled with"
08:45:40 <fysx2> hey, anyone know if there's a way to specify the compiler option -funbox-strict-fields as a pragma such as {-# LANGuAGE unboX_STRICT-FIELDS #-} ?
08:45:40 <blackh> That's correct.
08:45:50 <jmcarthur> crutcher: it uses whatever's on the path, or you can specify which ghc to use like   cabal install -w /usr/local/bin/ghc mypackage
08:45:51 <quicksilver> (which is lucky, because you can't yet compile cabal-install with ghc7)
08:46:31 <jmcarthur> crutcher: i have ghc 7 installed under /usr/local so that it doesn't replace by ghc 6 installation. cabal uses ghc 6 by default, or i can specify for it to use ghc 7
08:46:37 <jmcarthur> *replace my
08:47:15 <kmc> {-# OPTIONS_GHC -funbox-strict-fields #-}
08:47:15 <crutcher> the reason i wanted ghc7 was mainly to play with the new IO manager, and event IO.
08:47:17 <jmcarthur> cabal-install, i should say
08:47:17 <kmc> fysx2
08:47:29 <kmc> fysx2, you can put it in your foo.cabal file too
08:47:33 <fysx2> kmc: thanks
08:47:43 <kmc> we put the fun in funbox
08:47:51 <crutcher> I know that event driven IO is planned, but I'm not sure if it has landed; the stuff using select/epoll/kqueue
08:47:53 <crutcher> ?
08:47:56 <jmcarthur> crutcher: i highly recommend having ghc 6 and ghc 7 installed side by side like i have. it's easy and it means i don't have to run into so many compatibility issues. i can always just fall back to ghc 6 if something isn't working
08:48:22 <dcoutts_> crutcher: yep, it's using it in ghc 7
08:48:25 <jmcarthur> and it's nice for testing your code for forward compatibility
08:48:45 <crutcher> jmcarthur: and cabal installs packages to a sane location that doesn't conflict?
08:49:08 <jmcarthur> crutcher: libraries get registered for each version of ghc separately. they won't overwrite each other
08:49:20 <jmcarthur> crutcher: executables will overwrite each other though
08:49:26 <crutcher> dcoutts_: do I have to do anything special to get event driven accept, recv, and send?
08:49:37 <dcoutts_> crutcher: nope, that's the beauty of it
08:50:12 <jmcarthur> does any other popular language runtime have that?
08:50:27 <crutcher> dcoutts_: oh joi. I've been working on cloning servers in haskell; I've got some stuff that works, but I want it to be faster
08:50:45 <crutcher> jmcarthur: have what? event IO? maybe java?
08:51:14 <dcoutts_> crutcher: it's not going to be faster, but it'll scale to more than 1024 sockets
08:52:15 <jmcarthur> hmm, yeah, it would make sense for java to have it
08:52:29 <dcoutts_> jmcarthur: only if it had lightweight threads
08:52:37 <jmcarthur> doh!
08:52:41 <jmcarthur> indeed
08:52:54 <jmcarthur> i take lightweight threads for granted
08:52:56 <dcoutts_> crutcher: if speed is your problem, make sure you're using appropriate data structures for your buffers etc ie ByteString
08:53:09 <crutcher> dcoutts_: I was following some discussion on wiki pages about snap's event stuff
08:53:51 <dcoutts_> crutcher: oh well snap is doing crazy stuff with libev
08:53:57 <crutcher> dcoutts_: and that linked to other pages, I can hunt them if you want, but my impression was that while then IO manager did many fun things, it wasn't doing the select/epoll/kqueue stuff _yet_.
08:54:05 <crutcher> dcoutts_: and that it would in the future
08:54:12 <dcoutts_> crutcher: it's doing it now, as of ghc 7
08:54:20 * dcoutts_ does know these things
08:54:41 <dcoutts_> one of our clients is currently testing http servers with ghc 7 for exactly this reason
08:54:49 <crutcher> dcoutts_: okay, so how would libev provide any additional speed? or do you expect snap to remove it when they upgrade?
08:55:12 <jmcarthur> crutcher: there are two ways to build snap. one of the ways uses libev. the eventual plan was to stop using libev when the new event manager made it into ghc, but i think they are holding onto it a bit longer now for performance reasons
08:55:41 <dcoutts_> crutcher: as I understand it, their performance issue is with multi-core scaling of IO events
08:56:01 <dcoutts_> crutcher: the IO manager is a single manager for all processors, the libev does some more per-core stuff
08:56:10 <dcoutts_> we think that's probably the root of it
08:56:20 <crutcher> oh. there was a simonmar comment on a wiki page about that problem; suggesting that the next step would be to try running multiple IO managers
08:57:31 <dcoutts_> right, the people working on the new IO manager tried some initial experiments but have not had time yet to properly investigate it
08:57:48 <crutcher> I've been screwing about with haskell for a few years, off and on. A friend of mine and I decided that we should get serious about it, so we're looking at taking a drunken walk through the open source server space, and reimplementing fun things we find; trying to make the haskell perfomant as well.
08:57:56 <crutcher> so, motivation for this interest
08:57:57 <dcoutts_> it's also possible that libev has some lower overheads
08:58:30 <dcoutts_> but on the downside, making libev play nicely with the existing rts and IO system would give me nightmares
08:58:50 <dcoutts_> I understand the snap people found it very hard, lots of subtle bugs
08:59:28 <crutcher> I've been building toy servers with Data.Enumerator, and I'm getting near 10k qps on a pass through proxy, but the base server is at 67k
09:00:03 <crutcher> so I'm looking at various approaches to speed things up, without screwing my compositional stack
09:00:53 <dcoutts_> hard to guess without knowing what you're doing
09:01:12 <dcoutts_> main thing is to use the right IO routines and buffer types
09:01:17 <dcoutts_> ie not String
09:01:36 <crutcher> dcoutts_: snap's libev stuff looks like they use watcher threads to flip mvar that are used to trigger reads and wrights
09:02:03 <crutcher> yeah, using ByteString and Attoparsec
09:03:45 <tibbe> Seems like I missed a whole discussion on networking!
09:03:52 <kmc> so snap uses its own libev rather than going through the GHC IO manager?
09:03:56 <kmc> i vaguely remember hearing this
09:04:04 <dcoutts_> kmc: it can do either
09:04:17 <crutcher> tibbe: just trying to get up to speed, so to speak
09:04:18 <tibbe> kmc, like dcoutts_ said, but it uses libev by default
09:04:33 <tibbe> crutcher, if you have any questions, I know the implementation pretty well ;)
09:05:02 <crutcher> I was looking through some of your benchmark code on github last night
09:05:38 <crutcher> it was mainly a question of what's the Right Way to build a high throughput server, given the dev direction of ghc
09:06:06 <crutcher> and the answer seems to be: use accept, recv, and send in ByteString, and wait for GHC 7
09:07:25 <tibbe> crutcher, right, and use vectored I/O when possible
09:07:32 <tibbe> crutcher, in the latest version of the network package
09:07:42 <revenantphx> Guys. I'm shocked.
09:07:52 <revenantphx> Cabal is ridiculously easy to work with (at least for simpel stuff)
09:07:55 <revenantphx> how'd you do it 0.o?
09:07:57 <revenantphx> Anyways, I have to go.
09:08:05 <tibbe> crutcher, I get about 20k req/s for a simple HTTP poll benchmark on a single core on my MacBook Pro
09:08:32 <tibbe> crutcher, we really need some better profiling tools. I need to get perfevent into ThreadScope so I can see what the I/O manager is doing
09:08:40 <tibbe> look at lock contention and what not
09:08:48 <tibbe> we got another 10% performance by using lock striping
09:09:02 <crutcher> tibbe: I'm seeing ~10q qps on a macbook air for a pass tthrough redis proxy, that parses everything both ways using attoparsec
09:09:15 <crutcher> sorry, ~10k qps
09:09:30 <tibbe> hmm ok
09:09:42 <tibbe> crutcher, are you able to profile it?
09:09:50 <tibbe> crutcher, I would look at the ThreadScope profile
09:09:53 <crutcher> oh, and that's with GHC 6.12.3
09:10:00 <tibbe> ok
09:10:00 <crutcher> I still need to upgrade
09:10:45 <tibbe> so both libev and the new I/O manager doesn't really increase throughput for programs that use few file descriptors. They help programs that have a large number of open file descriptors but where only a few hundred are in use at any given time.
09:11:52 <tibbe> i.e. they're O(active connections) rather than O(total connections)
09:12:01 <haskeller> if there's a single function I don't want to export in the whole module, I have to create the export list for all the functions but this one?
09:12:12 <tibbe> haskeller, yup
09:12:21 <crutcher> tibbe: yes, that's the idea. I've written async engines in C
09:12:25 <haskeller> Life sucks then.
09:12:37 <tibbe> crutcher, OK
09:12:44 <tibbe> crutcher, just checking :)
09:13:03 <tibbe> I gotta go actually
09:13:03 <Jonno_FTW1> hello, I was trying to write a function to generate the sequence described here: http://www.reddit.com/r/math/comments/ehim5/is_there_a_name_for_this_pattern/
09:13:05 <crutcher> tibbe: no it's cool, just skipping ahead a few steps in this conv
09:13:15 <Jonno_FTW1> but I got this far and it didn't work
09:13:24 <tibbe> crutcher, I gotta go actually, feel free to drop me an email if you have questions
09:13:31 <crutcher> thanks
09:13:44 <Jonno_FTW1> concat $ sequence $ sequence (\x y->if x`mod`(y-1) == 0 then y else x)[n,n-1..1] [1..]
09:13:48 <tibbe> ciao
09:15:47 <haskeller> Jonno_FTW1 why don`t you define the function like suggested on the first answer?
09:15:52 <haskeller> f(n-1) n f(n-1)
09:16:07 <Jonno_FTW1> but I don't see how that works
09:16:18 <Saizan> Jonno_FTW1: do you mean mapM rather than sequence? but it wouldn't work either
09:16:19 <haskeller> f1 = 1
09:16:25 <revenantphx> How is cabal so easy to work with :O
09:16:40 <haskeller> f2 = f(2-1) ++ 2 ++ f(2-1)
09:16:46 <haskeller> f2 = f(1) ++ 2 ++ f(1)
09:16:51 <Jonno_FTW1> revenantphx: you'll get to the point where it's not so easy
09:16:51 <haskeller> f2 = 1 ++ 2 ++ 1
09:16:54 <haskeller> f2 = 121
09:16:57 <revenantphx> Jonno_FTW1: I'm sure.
09:17:06 <dcoutts_> revenantphx: that's not the usual complaint I get, but nice to hear :-)
09:17:28 <revenantphx> dcoutts_: Cabal is your fault?
09:17:42 <dcoutts_> at the moment, I'm current maintainer
09:17:44 <revenantphx> I blame you. (in a positive way)
09:17:51 <dcoutts_> not the original author
09:18:49 <Jonno_FTW1> but now I get an error
09:18:59 <byorgey> > let { f 0 = [0]; f n = let l' = f (n-1) in l' ++ [n] ++ l' } in f 5
09:19:01 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
09:19:07 <byorgey> > let { f 0 = []; f n = let l' = f (n-1) in l' ++ [n] ++ l' } in f 5
09:19:08 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
09:19:22 <byorgey> I've also heard this called the "ruler" function
09:19:45 <byorgey> since it looks like the markings on an (English-unit) ruler
09:20:00 <Jonno_FTW1> how is it useful on a ruler?
09:20:27 <byorgey> long lines indicate inches, then slightly shorter lines indicate half inches, slightly shorter lines yet indicate quarter inches, and so on
09:20:51 <Jonno_FTW1> interesting
09:21:33 <haskeller> wamhttp://hpaste.org/42148/ruler
09:21:55 <Jonno_FTW1> could it be rewritten using fix?
09:22:15 <byorgey> Jonno_FTW1: every recursive function can always be rewritten using fix =)
09:22:31 <Jonno_FTW1> that's what I've been trying to figure out how to do lately
09:22:50 <byorgey> > let { f g 0 = []; f g n = let l' = g (n-1) in l' ++ [n] ++ l' } in fix f 5
09:22:52 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
09:23:07 <byorgey> you just make the function take an extra argument which is the function it calls in place of recursive calls
09:23:17 <byorgey> then fix makes it back into a recursive function.
09:24:34 <revenantphx> I'm sure you could write that more concisely >_<
09:24:49 <revenantphx> Wait, not really.
09:24:53 <byorgey> which, the function or the explanation?
09:25:40 <revenantphx> hey so guys
09:25:54 <revenantphx> I tried Binary w/ Lazy IO, what should I try next, attoparsec or iteratees?
09:26:09 <revenantphx> (I noticed an attoparsec-to-iteratee converter too)
09:26:16 <revenantphx> attoparsec looks fun anyhow.
09:26:22 <revenantphx> brb
09:28:37 <Jonno_FTW1> I get it now
09:28:45 <Jonno_FTW1> it makes the sequence from the middle
09:29:22 <zygoloid> > let ruler n | even n = ruler (n `div` 2) + 1 | otherwise = 1 in map ruler [1..]
09:29:23 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
09:29:27 <Jonno_FTW1> these things make sense more slowly at 4am
09:33:00 <aristid> > concat $ zipWith (\a b -> [a, b]) (repeat 1) [1..]
09:33:01 <lambdabot>   [1,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,1,15,1,16,1,1...
09:33:05 <Muncuie> 4,4_1,8 ( ( ( Made in Indonesia ) ) ) 4,4_15,1
09:33:09 <aristid> > concat $ zipWith (\a b -> [a, b]) (repeat 1) [2..]
09:33:10 <lambdabot>   [1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,1,15,1,16,1,17,1,...
09:33:10 <Muncuie> 4,4_1,8 ( ( ( Made in Indonesia ) ) ) 4,4_15,1
09:33:15 <Muncuie> 4,4_1,8 ( ( ( Made in Indonesia ) ) ) 4,4_15,1
09:33:17 <aristid> @where ops
09:33:17 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:33:18 --- mode: ChanServ set +o quicksilver
09:33:20 <Muncuie> 4,4_1,8 ( ( ( Made in Indonesia ) ) ) 4,4_15,1
09:33:24 --- mode: quicksilver set +q Muncuie!*@*
09:33:33 <quicksilver> Muncuie: is that deliberate or an accident?
09:33:35 <jmcarthur> wtf how does that even achieve anything
09:33:53 --- mode: quicksilver set -q Muncuie!*@*
09:34:18 <quicksilver> jmcarthur: looked more like a misconfiged IRC client or failed scripting attempt than anything else
09:34:31 <quicksilver> they hadn't just joined.
09:34:57 --- mode: quicksilver set -o quicksilver
09:38:28 <EvanCarroll> that irssi hack is annoying
09:38:56 <EvanCarroll> seriously, why doesn't it scrub its own non-irc color codes
09:40:07 <quicksilver> that was an irssi hack?
09:40:27 <EvanCarroll> actually, maybe not
09:40:31 <EvanCarroll> oddly this chan doesn't have +c
09:40:37 <quicksilver> indeed not
09:40:38 <EvanCarroll> but, typically and probably yes.
09:40:40 <quicksilver> we find it useful.
09:40:45 <quicksilver> occasionally.
09:45:52 <crutcher> does anyone have a good suggestion for thread safe logging?
09:47:03 <quicksilver> crutcher: Chan String
09:47:18 <quicksilver> crutcher: (or some more sophisticated alternative to Chan)
09:47:44 <crutcher> okay, yeah I was looking at that. clearly a logger could be built with it.
09:47:45 <quicksilver> erm.
09:47:55 <quicksilver> I actually meant some more sophisticated alternative to String ;)
09:47:59 <crutcher> I was just hoping there was a package I didn't know about where this had been done right
09:48:03 <quicksilver> the Chan bit is probably fine.
09:48:35 <quicksilver> well haskell doesn't go big on "thread-safe X" because we tend to assume most stuff is thread safe :)
09:48:52 <crutcher> Show a => Chan (LogEvent LogLevel LogPoint a)
09:49:00 <quicksilver> true that writing direct to a Handle can get interleaved, and to that part, a Chan is a good solution.
09:49:04 <Saizan_> see if hlogger fits
09:50:22 <crutcher> Saizan_: I can't find it on hackage, hoogle, or hayoo
09:51:31 <kmc> logger = do c <- newChan; _ <- forkIO (forever (readChan c >>= putStrLn)); return (writeChan c)
09:51:35 <kmc> crutcher, ^^
09:51:53 <kmc> closures + first-class IO + concurrency is *really powerful*
09:52:03 <kmc> the user doesn't see the chan, they just get a function for printing strings
09:52:09 <kmc> logger :: IO (String -> IO ())
09:52:12 <crutcher> kmc: yes, that's easy to write
09:52:18 <crutcher> but how buffered is it.
09:52:29 <crutcher> does the user have to block until their string gets consumed?
09:52:32 <kmc> no
09:52:37 <kmc> Chans are unbounded
09:52:54 <kmc> i believe writeChan will never block except during someone else's Chan operation
09:53:06 <crutcher> that's cool
09:53:25 <kmc> if you're interested, Chan is implemented as two MVars pointing to different points in a linked list of MVars
09:53:39 <kmc> it's in the original "Concurrent Haskell" paper
09:53:42 <crutcher> okay, yes, neat
09:54:11 <quicksilver> well, unbounded is not always what you want
09:54:13 <crutcher> related issue: is there any thing remotely equivalent to __function__ and __LINE__ in C?
09:54:27 <quicksilver> but if you're happy for it to be unbounded that's a simple and elegant solution.
09:54:27 <kmc> if you use the C preprocessor with Haskell then you get __LINE__
09:54:29 <kmc> i think
09:54:31 <crutcher> I'd like to be able to work out where a log was called from
09:54:34 <kmc> {-# LANGUAGE CPP #-}
09:54:42 <kmc> you'd have to write a macro though
09:54:53 <kmc> otherwise you'd just get the line of your "log" function
09:54:55 <crutcher> kmc: wouldn't have access to the function name
09:56:07 <fysx2> I know this is delayed, but that 'ruler' question is a neat question.  For a sequence of n values, a naive analysis gives O(nlogn) run time, but an amortized analysis should give O(n).  Cool.
10:00:11 <zygoloid> > let ruler n = 1 + popCount (complement n .&. (n - 1)) in map ruler [1::Int ..]
10:00:14 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
10:00:37 * hackagebot uuagc 0.9.35 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.35 (ArieMiddelkoop)
10:00:49 <lispy1> ?oeis 1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1
10:00:49 <lambdabot>  Sequence not found.
10:01:21 <lispy1> ?oeis 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5
10:01:21 <lambdabot>  Sequence not found.
10:01:48 <zygoloid> it's A001511
10:02:01 <newsham> ?oeis vini vidi
10:02:01 <lambdabot>  Sequence not found.
10:02:12 <tromp_> > mapM_(print.g 2)[0..]where g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
10:02:13 <lambdabot>   <no location info>: parse error on input `where'
10:02:17 <zygoloid> @oeis 1 2 3 4
10:02:17 <lambdabot>  Sequence not found.
10:02:48 * zygoloid recalls from byorgey's recent blog post that OEIS changed something and the haskell package doesn't work any more
10:04:28 <tromp_> @let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
10:04:28 <lambdabot>   Float with missing exponent
10:04:55 <tromp_> hmm, ghci doesnt complain about that
10:05:30 <roconnor> @seen koninkje_away
10:05:31 <lambdabot> Unknown command, try @list
10:05:31 <preflex>  koninkje_away was last seen on #haskell-in-depth 3 days, 11 hours, 2 minutes and 6 seconds ago, saying: @tell roconnor assuming composePlate is associative and complete (i.e., closed, not total) and assuming purePlate is the identity for composePlate, then it is a category regardless; with multiplate an endofunctor
10:08:09 <byorgey> zygoloid: indeed.
10:08:34 <revenantphx> It'd be amusing to create a simple data type called a Chandle.
10:08:40 <revenantphx> (Handle w/ built in chan for writes)
10:08:50 <byorgey> zygoloid: it has a new maintainer now, so hopefully it should be working again in the near future.
10:08:58 <zygoloid> revenantphx: i read that as C handle ;(
10:08:59 <byorgey> zygoloid: although apparently the new OEIS site is still in a bit of flux.
10:09:03 <zygoloid> \o/
10:09:05 <revenantphx> zygoloid: pretty much
10:09:12 <revenantphx> haha
10:19:51 <pheuter> How does Haskell know how to teat a data type I defined as an Eq just by deriving it? Without me telling it how to "unwrap" the data type, how does Haskell know how to compare my data types ?
10:19:54 <pheuter> treat*
10:20:37 <younder> terror - error
10:20:51 <younder> Tired of that USA hysteria
10:21:39 <auric_goldfinger> how old is 6.4.2 ghc
10:21:45 <auric_goldfinger> seems all netbsd will give me
10:21:53 <younder> well done some work on concurrency..
10:22:21 <exDM69> auric_goldfinger: it's a piece of antiquity
10:22:24 <exDM69> belongs in the museum
10:22:39 <lantti> pheuter: Your datatype is probably composed of other datatypes that Haskell knows how to compare.
10:22:59 <younder> rentrant hash tables were possible with some code from sun (or is it oracle) thanks!
10:23:01 <pheuter> lantti: is there no typeclass that defines mathematical operations ?
10:23:49 <younder> Actually you have a lot to learn from Java.
10:23:49 <exDM69> I have always wondered about the deriving clauses too. Especially using some of the newer extensions, you can add neat instances of typeclasses with a simple deriving-directive
10:23:53 <auric_goldfinger> heh and this is in pkgsrc, supposedly the new stuff
10:24:04 <younder> I'm talking to you Jones!
10:24:25 <exDM69> younder: yep, "closures are a poor man's objects"
10:24:35 <kmc> pheuter, each "derive"able class has a special case in the compiler
10:24:45 <kmc> in the case of Eq, it compares the fields one by one
10:24:56 <kmc> i think the Report specifies the derived instances
10:25:00 <auric_goldfinger> java is the great satan
10:25:07 <kmc> also ghc will dump them with ghc -ddump-deriv
10:25:31 <younder> exDM69, more to the point they go all to hell in a concurrent setting
10:25:34 <kmc> pheuter, mathematical operations are in Num, Fractional, Floating, etc.
10:25:36 <exDM69> kmc: how about the newer extensions related to deriving directives?
10:25:55 <pheuter> kmc: ah, thnx
10:26:01 <kmc> those aren't derivable because there's not a single obvious way to implement them for all types
10:26:05 <exDM69> younder: I especially dislike java's syncronized methods and blocks
10:26:09 <kmc> exDM69, the same except for GeneralizedNewtypeDeriving
10:26:16 <younder> Mind you the functional style is A/OK.
10:26:35 <exDM69> younder: what I especially dislike is that you can have only one condition variable per object
10:26:49 <kmc> in Java the solution to every such problem is to invent n+1 additional classes and objects
10:27:14 <kmc> OOP is supposed to model the problem domain's objects, but in Java you end up with a lot of "synthetic" classes for control flow
10:27:16 <auric_goldfinger> www.prevayler.org is nice java app
10:27:17 <kmc> because it's all you've got
10:27:39 <younder> Better that Java. But you need  objects as a alternative to Monads.
10:28:00 <lantti> pheuter: There are typeclasses for various kinds of numbers that define mathematical operations.
10:28:11 <lantti> But you can only derive Read, Show, Bounded, Enum, Eq, and Ord
10:28:23 <pheuter> k
10:28:32 <exDM69> lantti: you can get a bit farther using some of the new cool extensions
10:28:36 <younder> I have had a shitload of problems verifying monads in a concurrent setting. So much in fact I had to resort to ML.
10:28:38 <mun_> hi
10:28:44 <exDM69> lantti: I remember using deriving for Data.Binary
10:28:50 <exDM69> or something like that
10:28:52 <mun_> if f is a function, is \lambda f x same as f?
10:29:02 <mun_> i mean \lambda x. f x same as f.
10:29:15 <exDM69> mun_: \x . f x == f, yes
10:29:27 <lantti> exDM69: Ah, yes. I remember hearing about that but never used, so didn't come to mind...
10:29:45 <younder> It can be done. But it is a pain..
10:30:15 <exDM69> lantti: Data.Binary is an example where you can end up writing very trivial and boring class instances
10:30:22 <mun_> exDM69, thanks
10:31:25 <younder> ah the lambda bit 
10:33:42 <younder> I am sitting with a article from 1966 called 'the next 700 programming languages' by  Landin the first approach to a Haskel type syntax.
10:34:00 <younder> Yeah, that early
10:36:14 <pheuter> how can i specify a datatype X to include the type constructors from Y. In other words, all Y are also of type X
10:36:51 * hackagebot Unixutils 1.29 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.29 (JeremyShaw)
10:37:20 <stepkut> pheuter: you can't do that. 
10:37:40 <stepkut> pheuter: you want X to be like Y, but some extra constructors ?
10:37:51 <pheuter> yes
10:38:03 <c_wraith> stepkut, I think he wants subclass polymorphism.
10:38:09 <pheuter> yes
10:38:32 <stepkut> pheuter: if you were to write, Foo "bar", how would you know if that had the type X or Y ? (Assuming Foo is a constructor of both)
10:38:34 <c_wraith> Doesn't exist in haskell.  Find a different abstraction.  What's the problem you're trying to solve?
10:39:36 <pheuter> i'm writing a compiler in haskell, and I am setting up the ast, where I want to have a data Prim, and a data Exp which encompasses Prim and extra operations on Prim
10:40:09 <stepkut> data Exp = ExtraThing1 | ExtraThing2 | Prim Prim, would be a common solution I think
10:40:31 <pheuter> if i have compile :: Exp ->
10:40:45 <pheuter> i cannot pass it a Prim, can I ?
10:40:47 <pheuter> i tried
10:40:53 <pheuter> but i got Couldn't match expected type `Exp' against inferred type `Prim'
10:40:59 <stepkut> no, you do, compile (Prim thePrim)
10:41:10 <pheuter> ah
10:41:21 <gaze__> hey, how is ghc currently feeding code into LLVM? there appears to be an LLVM binding on hackage for haskell but it looks like it hasn't been touched in quite some time.
10:41:49 <gaze__> some blog sez it's just using temporary files... but maybe that was during the beginning of development?
10:42:15 <Botje> gaze__: it's baked into the compiler
10:42:21 <povik> is there some interpreter, that supports graphical representation of values? (something like Wolfram Mathematica interface)
10:42:40 <gaze__> Botje: Bawww... please tell me it's exposed somehow
10:43:19 <gaze__> I'd hate to have some nice well maintained LLVM api baked into the compiler while using a secondary older LLVM api in my own program
10:43:32 <Botje> gaze__: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/Design
10:43:48 <Botje> ah, you're just looking for how to use llvm ..
10:44:05 <Botje> i think the llvm package is more general
10:44:18 <gaze__> that's the package I was referring to on hackage.
10:45:01 <c_wraith> the llvm package is *totally* unrelated to the llvm backend
10:45:11 <gaze__> yeah that's what I'm a little peeved about.
10:45:16 <auric_goldfinger> ghc 6.8.3 looks like netbsd pkgsrc is building
10:45:17 <c_wraith> Why?
10:45:46 <gaze__> because there's two totally separate llvm apis being developed.
10:46:08 <c_wraith> Not really.  There are two totally seperate *things* happening that involve llvm
10:46:43 <c_wraith> They aren't interchangeable in any way.
10:46:45 <gaze__> true... but why couldn't the haskell backend use the llvm package?
10:46:52 <c_wraith> And, in fact, contain no interchangeable parts
10:46:56 <jro> Hi, I cannot find Network.NewCGI from anywhere
10:47:04 <jro> haskell.org links seems to be broken
10:47:14 <gaze__> I mean, from the beginning... in the end they turn llvm IR into object code, right?
10:47:25 <gaze__> just trying to understand what's going on
10:47:35 <zygoloid> gaze__: iirc the llvm package was deemed not mature enough for ghc
10:47:37 <c_wraith> gaze__, the llvm backend just produces llvm IR from the stg machine code.
10:47:56 <gaze__> OH!
10:48:11 <gaze__> that makes much more sense.
10:48:27 <gaze__> I could see then why the LLVM backend is not so general
10:49:33 <kmc> doesn't it produce LLVM from Cmm
10:49:54 <c_wraith> Oh, right.  That is what I meant, I think.  If not what I said. :)
10:50:42 <Saizan> haskell -> Core -> STG -> Cmm -> LLVM, iirc
10:50:51 <gaze__> makes sense
10:51:58 <c_wraith> yeah, the llvm backend is just about code generation.  The llvm package is about manipulating llvm instructions, and possibly converting them to executable code at runtime
10:52:32 <gaze__> basically I'm writing a live coding environment for making synthesizers... and I'd like to be able to go from scheme to llvm
10:53:07 <zygoloid> the llvm package is also good for generating llvm bitcode
10:54:05 <ManateeLazyCat> gaze__: live coding environment?
10:55:00 <gaze__> oh it's this thing where people compose music in front of an audience by programming
10:55:24 <ManateeLazyCat> gaze__: Any link?
10:55:52 <gaze__> http://impromptu.moso.com.au/ this one is pretty popular
10:56:33 <gaze__> my issue is that one is OS X only, and I want something that I can plug into a DAW like protools or cubase or something, and transform midi signals, stuff like that
10:56:57 <fengshaun> OS X only? :(
10:57:19 <gaze__> and it's not terribly fast... some of these synths get pretty grody as far as CPU usage goes.... it's pretty intense DSP stuff
10:57:42 <gaze__> so I figure if I can have the user write high level DSP code and shoot it down through LLVM, I can get a reasonably nice signal pipeline
10:58:00 <jro> does Network.CGI support JSON?
10:58:32 <ManateeLazyCat> gaze__: Looks cool .
10:58:39 <c_wraith> jro: that question doesn't make much sense.  That's like asking if it supports jpeg.
10:59:32 <gaze__> right? for geeky musicians at least, it'd be great because you can write this big ass scheme program, write libraries for various synthesis techniques, blah blah
10:59:51 <gaze__> the current offerings are things that really don't plug into DAWs
11:00:54 <gaze__> and are fairly low level
11:01:41 <ManateeLazyCat> gaze__: So it's written in Scheme?
11:01:44 <gaze__> OR... are graphical in nature, which is great for people who don't like programming. NI Reaktor is an example of this. It's essentially like labview for sound.
11:02:08 <gaze__> I'm not sure what impromptu is written in
11:02:26 <gaze__> but the idea is to have a sort of JITted audio DSL.
11:02:31 <gaze__> with some sense of time.
11:02:41 <gaze__> well, what I'm proposing, anyway
11:03:03 <ManateeLazyCat> gaze__: "basically I'm writing a live coding environment for making synthesizers" ?
11:03:41 <gaze__> right! well, I'd like to use haskell to do the parsing and jitting of the code for the synth that the user provides
11:03:58 <gaze__> and then some c++ glue code to get the whole application to plug into various audio workstations
11:05:11 <ManateeLazyCat> gaze__: So impromptu is not "live coding environment" you said?
11:05:20 <gaze__> it is
11:05:33 <gaze__> it's just not so much geared to plug into bigger audio sequencing programs
11:05:38 <gaze__> from what I understand
11:05:59 <ManateeLazyCat> gaze__: So you want create new one but with Haskell?
11:06:42 <gaze__> I mean, it's not important what language it's implemented in... just that it takes an audio geared dialect of scheme and jits it and plugs into whatever audio program the user is using
11:06:48 <zygoloid> there are existing live coding environments for haskell
11:06:55 <gaze__> but yes I plan on doing it in haskell
11:08:12 <ManateeLazyCat> gaze__: If you just care audio, maybe you can watch my project : http://goo.gl/MkVw
11:08:28 <zygoloid> gaze__: http://yaxu.org/
11:10:02 <gaze__> OH! So you're the dude that's cranking out tons of nifty little haskell gui apps
11:10:04 <gaze__> that's really cool
11:10:27 <zygoloid> ManateeLazyCat is scarily prolific ;)
11:10:31 <ManateeLazyCat> gaze__: Also watch video : http://www.youtube.com/watch?v=weS6zys3U8k
11:10:54 <ManateeLazyCat> zygoloid: I'm looking for job recently, develop will slow down. :)
11:11:04 <ManateeLazyCat> But i will back. :)
11:11:57 <sh10151> autechre livecoding: http://goo.gl/Xq9xu
11:12:11 <gaze__> hahaha
11:12:52 <ManateeLazyCat> gaze__: My project is multi-process framework, you can use Haskell write any program in it, i don't care. And you can get the power of "integrated environment", that's mean you can mix your extension with other extension, and you don't need care framework problem.
11:13:50 <ManateeLazyCat> gaze__: So you can focus you time on Audio, and other people working on IDE, and i'm working on framework.
11:14:12 <ManateeLazyCat> gaze__: Then we can mix those together and get uniform user interface.
11:14:30 <ManateeLazyCat> gaze__: Because it's multi-process framework, so it's fast and perfect safety. :)
11:15:16 <ManateeLazyCat> gaze__: My detail still missing, but framework is stable, i believe. :)
11:16:21 <ManateeLazyCat> s/my/many
11:16:55 <sm> ManateeLazyCat: does manatee work on a mac ?
11:17:17 <sm> I ask because the doc says "works well in Gnome, KDE and XFCE"
11:17:20 <ManateeLazyCat> sm: It's possible to porting, but i haven't so much time.
11:17:37 <ManateeLazyCat> sm: yes, i think much easy than Windows. :)
11:17:38 <sm> I can understand that! Is it not just an X app ?
11:17:41 <ManateeLazyCat> sm: But i haven't Mac.
11:17:54 <ManateeLazyCat> sm: It's just need GTK+
11:18:00 <sm> well I have all that
11:18:27 <sm> I just wondered why it works with some window managers and not others 
11:19:02 <ManateeLazyCat> sm: In current situation, it's just need Linux Kernel and GTK+ library, don't need any other DE or WM's help
11:19:19 <ManateeLazyCat> Infact, just XMOnad can't work after i test.
11:20:00 <ManateeLazyCat> sm: It's perhaps need change XMonad's config to make it support Manatee, but i haven't so much time on those.
11:20:10 <ManateeLazyCat> Any patches are welcome! :)
11:21:28 <sm> though I have gtk, it looks like more work to get it installed here, or I'd try it now. But it sounds to me like a gtk app (that usually runs full screen ?) so I don't see why it wouldn't run alongside other apps on my mac
11:21:30 <ryan_> hello
11:21:39 <sm> thanks for making it
11:22:04 <ManateeLazyCat> sm: Press F11 to exit fullscreen.
11:22:27 <ManateeLazyCat> sm: Fullscreen is default setup to show my idea about "what's it?" :)
11:22:33 <sm> makes sense
11:22:58 <leino> -quit
11:23:02 <leino> oops
11:24:02 <ManateeLazyCat> sm: But i never test Manatee on Mac. :)
11:25:26 <sm> $ cabal install manatee
11:25:34 <sm> cabal: dependencies conflict: ghc-6.12.3 requires process ==1.0.1.3 however
11:25:35 <sm> process-1.0.1.3 was excluded because ghc-6.12.3 requires process ==1.0.1.4
11:25:46 <dcoutts_> see Cabal FAQ #1
11:25:54 <sm> oh oh
11:27:16 <sm> that's a nice faq dcoutts, I will use it to extricate myself from this later
11:29:21 <ManateeLazyCat> sm: If you can install Manatee on Mac, and i believe some extension is linux-special (such as process manager). :)
11:29:26 <ManateeLazyCat> sm: Good luck! :)
11:29:31 <sm> at http://www.haskell.org/cabal/ it would be nice to see the cabal-install user docs delineated from and before the Cabal user (ie package developer) docs
11:30:11 <sm> ManateeLazyCat: thanks :) I have used up my haskell packaging budget for this week, so maybe later
11:30:53 <lispy1> sm: have you ever blogged about your hacking time budgets and how you set that up and manage it?
11:31:07 <c_wraith> Agh.  Oops.  I made some code so polymorphic it compiles, and runs, using either map or mapM in one spot.  But they do very different things at runtime, so I accidently had it do nothing like what I wanted. :(
11:31:13 <lispy1> sm: if you have, I'd like to read it :)
11:31:16 <ManateeLazyCat> sm: Please watch http://www.youtube.com/watch?v=weS6zys3U8k before you play it, video is a little bit long, but include all tips except "terminal emulator" (press 'super + n') :) 
11:31:33 <sm> lispy: thanks for the encouragement.. I haven't *blogged* in years.. I keep wanting to but fear the time demands
11:31:54 <zygoloid> sm: no room in the budget for blogging? :(
11:32:11 <sm> yeah, hoping to change that :)
11:32:21 <ManateeLazyCat> @package budget
11:32:21 <lambdabot> http://hackage.haskell.org/package/budget
11:32:30 <lispy1> ManateeLazyCat: haha
11:32:31 <sm> I'm also stubbornly resisting just jumping back on blogger.com, and haven't figured out what shiny thing to use instead
11:32:32 <zygoloid> (no room in the time budget for reallocating time in the time budget?)
11:32:40 <ManateeLazyCat> lispy1: What's it? ;p
11:32:43 <dcoutts_> sm: it'd be nice if we had separate cabal-install docs at all! :-)
11:32:47 <sm> hakyll seems my favourite but still a bit of work
11:33:05 <ManateeLazyCat> lispy1: I was think it's a package name. ;p
11:33:10 <lispy1> ManateeLazyCat: :)
11:33:27 <lispy1> sm: mathblog is haskell based
11:34:09 <lispy1> sm: wordpress is better for styles/code snippets.  Blogger is free with a custom domain redirection (so I use that) and my blog has ways to setup syntax highlighting for haskell if you're interested (http://blog.codersbase.com)
11:34:40 <sm> ugh wordpress.. no chance. I just helped a friend with his crazy setup and it was scary
11:35:06 <ManateeLazyCat> Anyway, need sleep, G'night all. :)
11:35:12 <sm> yes code highlighting would be good, thanks 
11:35:14 <sm> night ManateeLazyCat 
11:35:32 <povik> gn
11:35:50 <muhtimin> doesn't blogger reserve rights to basically everything you've blogged?
11:36:01 <muhtimin> at least so i remember from reading their eula
11:36:29 <sm> probably, that's one of the numerous reasons to avoid it's seductive, sirenish simplicity..
11:36:51 <sm> would be
11:37:28 <sm> I am increasingly for decentralised computing systems these days
11:37:46 <pozic_> You can get a flog. 
11:37:54 <sm> flog ?
11:39:40 <pozic_> sm: Freenet Log.
11:39:51 <pozic_> sm: it is decentralized. 
11:40:00 <pozic_> sm: you don't need to pay for hosting.
11:40:02 <sm> ah.. not http://en.wikipedia.org/wiki/Fake_blog then :)
11:40:26 <pozic_> sm: but you can only use static files, IIRC.
11:40:55 <sm> that's the next big question, dynamic web app or static files all the way ?
11:40:57 <pozic_> sm: for feedback you can use forums or plain reddit as lots of people do. 
11:41:16 <proq> sm: there are also a few free web site hosts
11:41:56 <pozic_> proq: but they don't offer one to run dynamic scripts, right?
11:42:05 <mreh> @instances Monoid
11:42:06 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:42:28 <mreh> is a Map not a monoid?
11:42:31 <sm> and then: no comments, host your own comments, or use disqus ?
11:42:40 <sm> decisions, decisions
11:42:46 <bragh> pozic_, some do. but it's mostly php. well, heroku allows you to use ruby. but free hosts are still very much limited
11:42:51 <proq> pozic_: you can run javascript and php on most of them, I guess running anything else depends on each provider
11:43:14 <pozic_> proq: and there is no shell access or has that changed?
11:43:46 <pozic_> proq: a pay as you make money model would be much more convenient. 
11:43:57 <proq> pozic_: I haven't seen any with shell access
11:44:02 <pozic_> Then again, for $10 you have a VPS.
11:44:22 <proq> for $10 a month you can get shell access easily
11:44:33 <pheuter> is ghc 7 intended for mainstream use now ?
11:44:50 <pozic_> pheuter: the official answer is when it is part of the platform.
11:45:15 <pozic_> pheuter: but the more people test, the better it will be by the time it is part of the platform.
11:45:26 <pheuter> k
11:46:36 <kmc> i refuse to blog about Agda until i can use blogging software written in Agda
11:47:02 <kmc> pheuter, especially test it if you're maintaining libs on hackage :)
11:47:09 <c_wraith> Uh......   "Could not find module `GHC.Integer.Type': it is a hidden module in the package `integer-gmp'"
11:47:21 <c_wraith> Yet, I have explicitly told cabal to use that package.
11:47:26 <pheuter> mk
11:47:28 <c_wraith> How do I un-hide it?
11:47:36 <c_wraith> (yes, I'm doing terrible hacky things)
11:48:16 <dcoutts_> c_wraith: you cannot access it, it is a private module in that package.
11:48:25 <dcoutts_> c_wraith: nothing to do with cabal
11:48:38 <c_wraith> Oh, it's a hidden module, not in a hidden package.
11:48:49 <c_wraith> I totally misread that error.  Thanks.
11:49:01 <dcoutts_> yep, so if you want to unhide it then you need to go edit the package
11:49:06 <c_wraith> Are the constructors re-exported elsewhere?  GHC.Prim maybe?
11:49:33 <dcoutts_> c_wraith: I'd look at GHC.Integer.GMP.Internals
11:50:54 <c_wraith> dcoutts_, ah, thanks again.  that worked.
11:51:13 <dcoutts_> c_wraith: ghc-pkg describe is you friend in this circumstance
11:51:19 <dcoutts_> you/your
11:52:11 <c_wraith> I see.  That would have pointed me in the right direction.  Thanks for the tip.
11:58:42 <younder> I have a question. Does the GNU multi precision library spec constitute a proof. And can I use it as a substitution for the rather inadequate one in 'Principia Matematica' by Russel and Withmore
12:03:18 <kmc> a proof of what?
12:03:26 <kmc> i suggest you use Presburger arithmetic
12:06:07 <pygmalion> can someone hash out the pros and cons (or some other comparison) of using HDBC vs. HaskellDB?
12:14:32 <ttvd> hi, i have a question, if i have an infinite list [n..] and i run filter on it, how do i stop after first match?
12:14:41 <Cale> younder: Principia Mathematica was written by Russell and Whitehead (or at least, that's the only one I'm familiar with :)
12:14:50 <Cale> ttvd: head
12:15:00 <ttvd> Cale: blah, thank you, so simple :)
12:15:29 <Cale> ttvd: Of course, if there's no match, it'll take forever
12:15:35 <ttvd> nod
12:16:48 <sm> ttvd: also see take and take*
12:17:01 <ttvd> yeah, take can also work
12:17:14 <Cale> take and take?
12:17:52 <ttvd> okay thanks guys
12:17:53 <Cale> Oh, maybe you mean other functions beginning with take, like takeWhile
12:24:42 <pheuter> how can i define addition on a datatype i created (I Int)
12:24:51 <pheuter> well, the type is Exp, but the constructor is I Int
12:25:41 <c_wraith> Do you want to evaluate addition, or do you want to represent addition in the AST?
12:26:51 <pheuter> addition is represented as OpAdd, but I would also like to interpret it and return a value
12:27:30 <c_wraith> Well.  probably the most general approach is to write an interpreter function
12:27:52 <c_wraith> That takes an AST, and evaluates it
12:28:04 <pheuter> right
12:28:15 <c_wraith> That's done with basic pattern-matching and recursion
12:28:22 <pheuter> but how can i evaluate the addition between two derived data types ?
12:28:28 <pheuter> i get no instance of Num for Exp
12:28:56 <c_wraith> Pattern Match
12:28:56 * edwardk waves hello.
12:28:59 <mauke> eval OpAdd (I a) (I b) = I (a + b)
12:29:08 <c_wraith> yes, like mauke demonstrate
12:29:14 <c_wraith> *demonstrates
12:30:42 <alexyk> this doesn't work in ghci 6.12.3: import Data.UString (u) -- will it work in 7?
12:32:08 <revenantphx> dcoutts: If I may ask, why isn't there a cabal uninstall?
12:32:14 <arjanb> who's admin of haskell wiki? i see a dozen spam PDFs uploaded to it in the past two days
12:32:35 <revenantphx> Is there a technical limitation, or lazyness?
12:32:40 <pheuter> hm
12:32:41 <pheuter> i see
12:33:30 <jmcarthur> revenantphx: well, aside from hd space there isn't much point. there's always ghc-pkg hide and ghc-pkg unregister
12:33:38 <pheuter> what if there are 2 type constructors under Exp that can cary addition, and i want to match either
12:33:47 <pheuter> carry*
12:34:16 <revenantphx> Well I mean, to have a more complete abstraction.
12:34:21 * jmcarthur shrugs
12:36:37 <dcoutts_> revenantphx: it's not made it to the top of the TODO list yet
12:36:43 <revenantphx> What's at the top?
12:37:01 <dcoutts_> http://hackage.haskell.org/trac/hackage/roadmap
12:37:12 <dcoutts_> there's over 300 open tickets
12:37:34 <dcoutts_> revenantphx: what's at the top depends on what people feel like working on
12:37:57 <revenantphx> I know, I'm just wondering what's specificaly at the top XD.
12:38:05 <revenantphx> I'll check the trac...
12:38:17 <revenantphx> If it'd load.
12:40:08 <mreh> was there a specific reason why they didn't use type classes for specific monad interfaces in the transformers library
12:40:28 <mreh> I suppose mtl 2.* adds that functionality in
12:40:38 <dcoutts_> revenantphx: there is no specific top of the list
12:40:47 <benmachine> mreh: what do you mean? they didn't use MonadState and so on because transformers doesn't require fundeps or type familiries
12:40:51 <benmachine> families
12:41:29 <mreh> benmachine: I don't know why, but they didn't include MonadState etc. at all
12:41:36 <mreh> in transformer
12:41:41 <mreh> s
12:42:05 <benmachine> mreh: to reduce the extensions it needed
12:42:17 <benmachine> mreh: the idea was, there was transformers, which didn't need much
12:42:36 <benmachine> and there were monads-fd and monads-tf which needed MPTCs, and fundeps and type families respectively
12:42:54 <mreh> oh, I didn't know
12:43:15 <benmachine> mtl was basically similar to transformers+monads-fd
12:43:33 <mreh> you need those fun-deps for those type classes
12:43:37 <mreh> I remember
12:43:48 <benmachine> so recently, the two were merged, so that mtl depends on transformers now
12:43:56 <benmachine> we kept the name mtl because it's well-known
12:43:58 <benmachine> I assume
12:44:28 <mreh> but old code needs to be updated
12:44:36 <mreh> to use mtl when it once used transformers
12:45:16 <benmachine> it needs to be updated to use mtl if it used monads-fd
12:45:22 <benmachine> code that only used transformers is fine
12:45:48 <aristid> mreh: what? mtl now depends on transformers
12:46:23 <benmachine> I don't know why monads-fd was deprecated
12:46:27 <aristid> and code that uses monads-fd does not need to be updated either, if it doesn't have overly restrictive version restrictions on its monads-fd dependency
12:46:40 <aristid> benmachine: because it's just a re-export of mtl 2.0
12:48:56 <benmachine> did hackage just choke
12:49:03 <benmachine> oh no it's fine again
12:50:32 <Will> hi ppl
12:58:57 * orbital_fox greets everyone
13:00:05 <mreh> Will: whazzaaap
13:00:44 <mee> cabal install is hanging at  "Downloading failure-0.1.0.1...", heh.
13:01:45 <monochrom> Downloading failure indeed :)
13:03:47 <Botje> appropriate.
13:20:23 <iamjwc> hi haskellers
13:20:38 <iamjwc> i added the line "import Text.Regex" to my source
13:20:52 <iamjwc> and tried to compile
13:20:56 <Botje> ghc --make
13:21:05 <iamjwc> but i get ld: symbol(s) not found
13:21:05 <iamjwc> collect2: ld returned 1 exit status
13:21:14 <iamjwc> ah
13:21:29 <iamjwc> whats ghc --make?
13:21:56 <Botje> magically fix everything
13:22:10 <Botje> ghc will find the correct packages and include them
13:22:10 <iamjwc> whoa
13:22:12 <iamjwc> nice!
13:22:20 <kmc> default behavior in GHC 7
13:22:21 <kmc> :)
13:22:26 <Olathe> It also names the output something nicer than a.out.
13:22:33 <iamjwc> amazing
13:22:42 <iamjwc> worked
13:22:44 <iamjwc> thanks, guys
13:22:58 <Olathe> When is GHC 7 going into Haskell Platform?
13:25:53 <kmc> early next year
13:26:18 <kmc> iamjwc, ghc --make will also find and compile other local files
13:26:24 <alexyk> can anybody remind me, how to make this work in ghci 6.12.3: mport Data.UString (u) -- will it work in 7?  I need to reproduce things from http://hackage.haskell.org/packages/archive/mongoDB/latest/doc/html/Database-MongoDB.html#MongoDB at the proompt
13:30:29 <andern> if it possible to see the source of a predicate in GHCi? like the @src command here
13:31:02 <monochrom> not possible
13:31:15 <Eduard_Munteanu> andern: you can cabal-install lambdabot locally
13:31:33 <Eduard_Munteanu> And you get its tools.
13:31:42 <andern> hmm. ok
13:32:14 <kmc> lambdabot's @src is just reading from a text file
13:32:22 <kmc> andern, there's source links in the package doc on Hackage
13:32:22 <edbond> how to get Right value from Either?
13:32:30 <kmc> edbond, by pattern-matching
13:32:30 <Botje> edbond: pattern match
13:32:33 <kmc> f (Left x) = ...
13:32:36 <kmc> f (Right y) = ...
13:32:46 <kmc> or:  case foo of Left x -> ...; Right y -> ...
13:41:23 <revenantphx> So, what are the major new features in GHC7/Haskell Prime or w/e
13:41:45 <revenantphx> I'm a bit confused, haskell prime is the effort/process right?
13:41:55 <revenantphx> Not the actual release name... so would thatb e Haskell 2010?
13:42:01 <Botje> GHC7 is just a new version
13:42:08 <byorgey> revenantphx: Haskell prime is the process for producing new versions of the language standard.
13:42:11 <revenantphx> Ok.
13:42:16 <byorgey> Haskell 2010 is the latest standard.
13:42:29 <revenantphx> I could see Haskell prime as an amusing differential calculus joke
13:42:34 <byorgey> GHC is an implementation of the standard (and a bunch of extensions to it as well), the latest release of which is 7.0.1
13:42:40 <tg_> and you'd be right
13:42:42 <revenantphx> It's the rate of progression of Haskell. >_>
13:55:17 <pozic> Since Haskell is a constant, the value of Haskell' must be zero everywhere, no?
13:55:46 <jmcarthur> Haskell is a function from years to programming languages
13:56:24 <c_wraith> indeed.  but it's a partial function
13:56:32 <c_wraith> So far, it's only defined at '98 and 2010
13:56:45 <jmcarthur> indeed
13:57:04 <jmcarthur> *Haskell is a function from certain years to programming languages.
13:57:48 <jmcarthur> or  Haskell is a function from years to maybe programming languages
14:11:53 <rkrzr> @src unlines
14:11:54 <lambdabot> unlines = concatMap (++ "\n")
14:12:17 <rkrzr> @src concatMap
14:12:18 <lambdabot> concatMap f = foldr ((++) . f) []
14:25:53 <aristid> jmcarthur: what about years in the future where it is not clear whether haskell maps to a programming language?
14:26:17 <aristid> rkrzr: concatMap f xs is just concat $ map f xs
14:27:11 <rkrzr> aristid, yes I was just wondering how it's implemented
14:27:36 <aristid> rkrzr: @src does not show you the actual implementation
14:27:36 <mauke> @src concatMap
14:27:36 <lambdabot> concatMap f = foldr ((++) . f) []
14:27:50 * mauke slaps himself
14:28:20 <c_wraith> aristid: the function's domain is lazy
14:28:32 <wires> I have a list of functions, how do you apply a value to all of them ?
14:28:46 <c_wraith> actually, that's not right.  it just takes a long time to evaluate for future years
14:29:07 <Saizan> wires: map (\f -> f value)
14:29:15 <mauke> wires: \value -> map value fs
14:29:21 <aristid> c_wraith: then it is not really pure, i think
14:30:01 <c_wraith> aristid, it may have impure implementation details, but someone put an unsafePerformIO in front of it, which is ok, because whenever it finally returns, it will always return the same thing.
14:30:06 <Saizan> wires: assuming you meant "pass a value as an argument" rather than "apply a value"
14:30:23 <wires> Saizan: aha.. yes :)
14:30:34 <aristid> c_wraith: well, that guarantee is rather weak. what if a version of haskell falls out of favor with the emperor?
14:30:34 <mauke> wires: sequence
14:30:38 <wires> i thought there might be a nice function like "apply"
14:31:07 <Saizan> there is, actually
14:31:09 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
14:31:09 <lambdabot>   [5,7,10,25,32]
14:31:11 <Saizan> ?src ($)
14:31:12 <lambdabot> f $ x = f x
14:31:29 <Cale> > map ($ 5) [id, (+2), (*2), (^2), (2^)]
14:31:30 <lambdabot>   [5,7,10,25,32]
14:31:35 <aristid> @src sequence
14:31:36 <lambdabot> sequence []     = return []
14:31:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:31:36 <lambdabot> --OR
14:31:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:32:12 <lispy1> Do those have different strictness?
14:32:15 <dikdik> HOLY SHIT: http://www.dailymail.co.uk/news/article-1336509/Insurance-File-Decrypted-Reveals-US-Mossad-Involvement-In-911-Attacks.html
14:32:24 <Cale> I don't think so.
14:33:27 <aristid> dikdik: plenty of fun with editable urls
14:34:05 <EvanCarroll> 1hahahahha
14:34:11 <EvanCarroll> dikdik: +++
14:34:12 <EvanCarroll> very nice.
14:34:43 <wires> Saizan, Cale, aristid , mauke : thanks guys
14:35:45 <bavardage> how to I write to a file from a given FileOffset (which is a type from System.Posix )
14:35:55 <aristid> wires: i helped you?
14:35:57 <bavardage> or convert a FileOffset to an integer and hence use hSeek and standard IO
14:36:26 <mauke> bavardage: fromIntegral
14:36:34 <wires> aristid: it was helpful to see the source of sequence.. not sure if that was intentional ;)
14:37:08 <bavardage> mauke: haha oh thanks
14:37:12 <bavardage> yeah that was a stupid question
14:37:20 <aristid> wires: i did that for myself :D
14:37:34 <aristid> wires: but glad it helped you too!
14:40:56 <Cale> wires: Yeah, sequence is a more general monadic thing. Here we're using it with the function monad. In this monad, our computations are simply functions with a fixed domain, and running a computation means applying it to the parameter to which the whole function has been applied
14:41:11 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:41:12 <lambdabot>   ("hello","olleh","HELLO")
14:43:33 <EvanCarroll> how does x y z get set there?
14:43:57 <mauke> with <-
14:43:59 <Cale> y, for instance, refers to the result of applying reverse to "hello"
14:44:26 <Sina> I have a question. I have a tuple (a,b) and I have a c, and I want to see if c is equal to any of them, it should replace it with the other one. (so if b==c, I get a)
14:44:27 <EvanCarroll> right, and the argument to each one of those is supplied "hello"
14:44:30 <Cale> You can work out exactly how the parameter gets distributed to the functions if you desugar this and look at the definition of >>=
14:44:34 * hackagebot RepLib 0.3 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.3 (BrentYorgey)
14:45:34 <benmachine> Sina: are you looking for a function like lookup?
14:45:36 <benmachine> :t lookup
14:45:37 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:45:37 <Cale> Sina: f (a,b) c | (c == a) = b | (c == b) = a | otherwise = c (?)
14:46:11 <benmachine> > lookup 7 [(4,'a'),(5,'b'),(7,'c'),(8,'c')]
14:46:11 <lambdabot>   Just 'c'
14:46:36 <Sina> something like this, but I want to have it as the condition of if
14:46:41 <unkanon2> I have a question I'm not quite sure how to phrase. How can I make a haskell program whose GUI is a local webpage (running in the browser of course)?
14:48:02 <jmcarthur> unkanon2: you mean run a web server?
14:48:19 <unkanon2> jmcarthur: yes, but without the webserver
14:48:22 <jmcarthur> unkanon2: checkout happstack, snap, yesod... any of the web frameworks, really
14:48:33 <jmcarthur> unkanon2: they all have their own web servers. you don't need apache or anything
14:48:35 <c_wraith> unkanon2, if the gui is a web page, it's a web server.
14:48:47 <unkanon2> jmcarthur: oh then those might be what I'm looking for :)
14:48:54 <unkanon2> I'll check them out, thanks
14:49:05 <Sina> thanks benmachine and cale. I will take a look if I can sort it out with lookup :)
14:49:47 <Sina> for lookup should I make a list myself? [(a,b),(b,a)] ?
14:50:03 <Cale> Sina: I suppose, if you were going to go that route.
14:51:04 <Cale> > let foo (a,b) c = maybe c id (lookup c [(a,b),(b,a)]) in map (foo (1,2)) [1,2,3]
14:51:05 <lambdabot>   [2,1,3]
14:51:44 <unkanon2> jmcarthur: do you know if any of those frameworks have a command where I can talk to the user's terminal and execute commands and grab their output?
14:52:11 <Sina> Cale: thanks
14:53:32 <Sina> Is there any way to know the element number in map? I mean map applies the function to each element. can I get the element number?
14:53:58 <kmc> :t \f -> zipWith f [0..]
14:53:59 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
14:54:14 <unkanon2> Sina: you'd have to zip it with [0..] like kmc did
14:54:54 <Sina> kmc, unkanon2: thanks. looks like a good idea :)
14:55:13 <sm> unkanon2: hledger-web is an app like that. There is also (though hledger-web doesn't use it) http://hackage.haskell.org/package/wai-handler-webkit that makes web apps seem like normal desktop apps
14:55:17 <sm> (more like)
14:56:55 <unkanon2> sm: hmm, so that hledger package will allow my happstack webpage to run terminal commands and print their output to a textarea?
14:57:05 <sm> no
14:57:39 * hackagebot roguestar-engine 0.4.0.3 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-engine-0.4.0.3 (ChristopherLaneHinson)
14:57:54 <unkanon2> hmm that's what I need. I don't really want my app to look like a desktop app, I really want it to run in the browser
14:58:17 <sm> unkanon2: ok, it sounds like you just need the "system" command
14:58:18 <lispy1> > \Just{} -> () -- davidL
14:58:18 <lambdabot>   Overlapping instances for GHC.Show.Show (Data.Maybe.Maybe t -> ())
14:58:19 <lambdabot>    arisi...
14:58:31 <sm> function. thing.
14:58:39 * hackagebot roguestar-gl 0.4.0.3 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-gl-0.4.0.3 (ChristopherLaneHinson)
14:58:41 * hackagebot rsagl 0.4.0.3 - The RogueStar Animation and Graphics Library  http://hackage.haskell.org/package/rsagl-0.4.0.3 (ChristopherLaneHinson)
14:59:13 <unkanon2> sm: oh that's right, haskell already has that, doh!
14:59:23 <sm> \o/
15:00:16 <davidL> > \Just{..} -> ()
15:00:18 <lambdabot>   Illegal `..' in record pattern
15:00:18 <lambdabot>  Use -XRecordWildCards to permit this
15:01:11 <unkanon2> yep, definitely \o/  :)
15:01:24 <aristid> :t \Just{} -> ()
15:01:25 <lambdabot> forall t. Maybe t -> ()
15:03:40 * hackagebot cpython 3.1.2.1 - Bindings for libpython  http://hackage.haskell.org/package/cpython-3.1.2.1 (JohnMillikin)
15:18:43 <dibblego> does anyone happen to have Erik Meijer's email address?
15:19:39 <Twey> « Since joining Microsoft, I have refocused my creative energy from writing research papers to filing patents. » >.>
15:23:05 <DrDuck> Would there happen to be any text editor out there that will automatically indent my hakell code without me having to manipulate xyz in the .xyz file for the xyz or xyz editor.
15:23:37 <byorgey> haha, I like the way you phrased that =)
15:23:53 <tg_> I am confused by that
15:23:57 <Twey> DrDuck: Depends how you install it.
15:24:03 <DrDuck> :|
15:24:47 <byorgey> DrDuck: There might be, but I don't know of any.
15:25:05 <DrDuck> I'd just like a nice little text editor that I don't have to worry about pre configuring so that it'll indent haskell code. Open, write code, press Enter, indent!
15:25:07 <DrDuck> Ahh.
15:25:09 <DrDuck> Alright.
15:26:05 <Twey> DrDuck: *shrug* ergoemacs will do it if you get one of the preconfigured binaries for Windows or OS X.  Otherwise I think you have to paste a couple of lines into a file.  Oh, and change a path.
15:26:36 <DrDuck> I'll keep looking.
15:26:45 <Twey> DrDuck: Otherwise, it depends on your package manager.  IIRC the Arch package will set everything up for you.  Any decent package manager should.
15:27:31 <Saizan> at some, very early, point the time spent looking would exceed the time needed for the configuration
15:28:05 <Twey> … in fact I think it already has, assuming you started looking when you entered the channel.
15:29:08 <jmcarthur> DrDuck: haskell can't be fully automatically indented since it's whitespace-sensitive anyway. that is, there may be more than one valid level of indentation with different meanings in some circumstances
15:29:13 <byorgey> the trick to finding/configuring software to do what you want is iterative deepening.
15:30:25 <ddarius> byorgey: So you should retry all the software you've ever tried periodically?
15:30:35 <DrDuck> Right I'm just going to read up on a tut and be done with it. I found something useful: http://learnhaskell.blogspot.com/2007/09/lesson-1-hello-world.html
15:31:03 <byorgey> ddarius: hmm, ok, so iterative deepening with pruning.
15:36:51 * hackagebot anansi 0.2.1.3 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.2.1.3 (JohnMillikin)
15:38:16 <HaskellElephant> Hi, I just found out that the mandlebrot benchmark on language shootout gains about 20% performance switching code generations from via-c to llvm. I'm just wondering if I should submit the change seeing that I have no prior envolvment in making this entry...
15:38:42 <mauke> Haskelephant <- optimized!
15:40:21 <DrDuck> What is #haskell's review on "Learn You a Haskell for Great Good!"?
15:40:22 <wires> Cale: thanks for your further explanations
15:40:38 <mauke> DrDuck: <3
15:40:41 <kfish> DrDuck, awesomeness!
15:40:42 <HaskellElephant> I just switched flags from "-fglasgow-exts -fvia-c -optc-mfpmath=sse -optc-msse2" to "-fllvm"
15:40:53 <DrDuck> Ok. Sweet!
15:41:11 <Twey> DrDuck: We generally like it.  Especially BONUS.
15:42:12 <sipa> yes, he's a big fan i hear
15:42:14 <proq> HaskellElephant: that switches the compiler from gcc to llvm, right?
15:42:26 <DrDuck> Sounds good. Going to be reading the pdf tonight.
15:43:07 <HaskellElephant> proq: yes
15:43:56 <proq> HaskellElephant: that is impressive.  I didn't realize it was that much faster
15:45:00 <HaskellElephant> proq: well, I didn't run many tests, but on that benchmark it is quite significant.
16:03:07 <sajkr> i have "class C a where (:~) :: a -> a -> a", ghc chokes saying "invalid type signature". wtf?
16:03:56 <mauke> : is an uppercase symbol
16:03:58 <hpc> sajkr: you can only begin an infix operator with ':' if it is a constructor
16:04:15 <hpc> how many upper case symbols are there?
16:04:26 <sipa> one, i believe
16:04:33 <sajkr> mauke, hpc: thanks. apparently, i am an idiot.
16:05:05 <hpc> sajkr: nah, i didn't know about that for a long time
16:05:08 <chrisf> that's an excellent error message, is that really the best that's possible?
16:06:02 <hpc> GHC is usually pretty good at error messaged
16:06:04 <hpc> *s
16:06:14 <BestCodeEver> I have a question
16:06:49 <hpc> okay, you have a question :P
16:06:57 <kmc> GHC is pretty bad at suggestions, though
16:07:09 <sajkr> hpc: no, i know that ':' is special. that's why i'm an idiot.
16:07:20 <hpc> oh, lol
16:07:32 <sajkr> a very sleepy, tired idiot.
16:08:54 <BestCodeEver> i have this line type CellsMap  = (Map CellRef Cell) 
16:09:12 <BestCodeEver> but I am confuse what is doing?
16:11:11 <kmc> it defines "CellsMap" as an alias for the type "Map CellRef Cell"
16:11:17 <kmc> it's not a new type, just another name for the old one
16:11:22 <bobtheterminator> hey everybody, i wrote a simple gtk2hs application that's supposed to read from a glade file and display a window, and it compiles fine, but I get this error when I try to run it: (Converter:7673): libglade-WARNING **: Expected <glade-interface>.  Got <interface>.
16:11:45 <bobtheterminator> any ideas why that would happen?
16:11:58 <aavogt> bobtheterminator: glade has two options when saving files
16:12:21 <bobtheterminator> ooo
16:12:28 <bobtheterminator> thanks, i'll see if that works
16:12:30 <aavogt> you have to pick the other one, or hope that things work out ok if you change that tag in the xml
16:12:42 <bobtheterminator> yeah just changing the tag didn't work
16:13:38 <benmachine> 'time' is a GHC package, right? one that you shouldn't upgrade with cabal?
16:13:42 <bobtheterminator> awww, I can't use entry completion in libglade format
16:14:18 <revenantphx> Hm, so I'm doing the eid allocator (or rather, a demo of it) to start.
16:14:25 <aavogt> bobtheterminator: or you can change your hs file to use that builder format (or whatever it's called)
16:14:48 <bobtheterminator> aavogt: oh I can? do you have any idea how to do that, because that would be excellent
16:15:11 <revenantphx> I'm trying to think out how to do it.
16:15:50 <revenantphx> I'm thinking i pass it a list of the currently taken eids, and it just runs through from the left, 
16:16:11 <revenantphx> so if its [0,1,2,3,4,7,8]
16:16:22 <revenantphx> then it will go from left to right, checking if the value x+1 is taken.
16:16:27 <aavogt> bobtheterminator: I think Graphics.UI.Gtk.Builder is the right one, but I've never used it
16:16:31 <revenantphx> however the amount of membership tests might be a bit harsh.
16:16:41 <revenantphx> (so in that case when it hits 4 it sees 5 is unused)
16:17:59 <benmachine> revenantphx: why not just take the list of all possible eids, subtract the currently taken eids, and use the head of that?
16:18:18 <revenantphx> the list of all possible eids is every value from 0 to 2^32
16:18:35 <revenantphx> I guess with haskell being lazy and all that'd be fine :\
16:18:39 <bobtheterminator> aavogt: yup, that's the one. Thank you very much.
16:18:40 <sipa> 2^32-1 i hope
16:18:53 <revenantphx> sipa: right.
16:19:07 <revenantphx> Well, all values possible for an Int32
16:19:22 <revenantphx> positive only I believe.
16:19:45 <BestCodeEver> How can i do this http://pastebin.com/JJByg5R6
16:20:35 <revenantphx> so benmachine, given that haskell is lazy...
16:20:45 <revenantphx> or rather, non-strict, w/e
16:20:52 <revenantphx> it will only evaluate as far as necessary to find an eid?
16:21:00 <benmachine> revenantphx: I'd expect that
16:21:04 <revenantphx> cool
16:21:11 <benmachine> revenantphx: you could potentially make it go wrong by sharing the list
16:21:17 <benmachine> but even then it'd probably be fine
16:21:20 <revenantphx> what?
16:21:37 <revenantphx> Well, the allocation of an EID must be atomic actually.
16:22:50 <aavogt> BestCodeEver: the   Map.toList  already sorts by keys (or use  Map.toAscList to have more of a guarantee of that)
16:22:58 <revenantphx> Well, lets see. My entity table is an TVar IntMap (TVar Entity) at the moment...
16:23:06 <revenantphx> (or will be)
16:23:21 <pokoko222> has someone here ever been to ACM competition?
16:23:27 <revenantphx> so I could have it take in the map reference, and return the next possible eid.
16:23:59 <aavogt> > M.toList $ M.fromList $ [ (x,()) | x <- [(1,1) , (3,9), (1,0), (4,4) , (4,-3) ]]
16:24:00 <lambdabot>   [((1,0),()),((1,1),()),((3,9),()),((4,-3),()),((4,4),())]
16:24:09 <BestCodeEver> aavogt: do i need rows and rows
16:24:17 <BestCodeEver> aavogt: do i need rows and cols
16:24:50 <aavogt> BestCodeEver: look at that example ^^  it does the same as what your sortBy should
16:25:39 <aavogt> also, what happens if the array has elements like:
16:25:42 <Hilbert> What does @ do in haskell?
16:25:46 <aavogt> _xx
16:25:47 <aavogt> xxx
16:26:10 <aavogt> where the _ is a missing element: this way you can have an incorrect minimum bound
16:26:15 <kmc> Hilbert, x@p is a pattern.  it matches everything  matched by the pattern p, binds the same variables, and also binds x to the whole thing matched
16:26:22 <mee> Hilbert: capture patterns -- foo@(x:xs) means you can access x:xs as foo as well as x and xs seperately
16:26:52 <BestCodeEver> aavogt:  I am solving a puzzle
16:26:56 <aavogt> > let x @ ~ y = 1 in x + y
16:26:57 <lambdabot>   2
16:27:24 <aavogt> > let x @ ~ !y = 1 in x + y
16:27:25 <lambdabot>   <no location info>: parse error on input `!'
16:27:37 <benmachine> lazy bang pattern?
16:27:38 <aavogt> > let x @ ~ (!y) = 1 in x + y
16:27:39 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
16:27:40 <benmachine> neat
16:27:49 <parcs> > let a@b@c = 1 in a + b + c
16:27:50 <lambdabot>   3
16:27:54 <parcs> what.
16:27:57 <aavogt> @vixen -XBangPatterns
16:27:57 <lambdabot> I will NOT be ignored...
16:28:11 <inimino> @seen Trinithis
16:28:11 <lambdabot> Unknown command, try @list
16:28:11 <preflex>  Trinithis was last seen on #haskell 74 days, 9 hours, 33 minutes and 58 seconds ago, saying: "String -> GenJen a JVar" or "GenJen a JVar"
16:28:25 <aavogt> @ty let a@b@c = 1 in (a,b,c)
16:28:26 <lambdabot> forall t. (Num t) => (t, t, t)
16:29:20 <revenantphx> "Setup.lhs: dist/package.conf.inplace: permission denied
16:29:20 <revenantphx> "
16:29:21 <revenantphx> the hell
16:30:00 <blackh> revenantphx: Never type 'sudo cabal'.  Instead, type cabal --root-cmd=sudo ...
16:30:08 <revenantphx> I didnt.
16:30:13 <aavogt> what happened to  http://haskell.org/gtk2hs ?
16:30:14 <revenantphx> I'm using my Setup.hs file >_>
16:30:32 <revenantphx> I'm trying to use build.
16:30:34 <revenantphx> It was just working
16:32:33 <revenantphx> apparently that error related to me importing STM
16:32:41 <revenantphx> adding it to the build-deps in the cabal file fixed it.
16:32:53 <aavogt> @ty let a@~b@c@d@e@f@~g = 1 in a b c
16:32:54 <lambdabot> Parse error in pattern
16:33:13 <aavogt> @ty let a@(~b@c@d@e@f@(~g)) = 1 in a b c
16:33:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t -> t1
16:33:14 <lambdabot>     Probable cause: `a' is applied to too many arguments
16:33:14 <lambdabot>     In the expression: a b c
16:33:38 <aavogt> parcs: amusing how that's specified http://haskell.org/onlinereport/exps.html#pattern-matching
16:36:15 <revenantphx> how can I have Setup.hs cause haddock to be generated on build?
16:36:32 <mtnviewmark> runhaskell Setup haddock
16:36:52 <mtnviewmark> it doesn't run on build - it is always a separate step
16:36:56 * shachaf wonders why people don't use an executable Setup.lhs.
16:36:59 <kmc> but you can make cabal always run that step
16:37:17 <revenantphx> kmc: out of curioisyt, how?
16:37:28 <revenantphx> I'd also like it to always provide hlint, if possible.
16:37:30 <dcoutts__> shachaf: it's not needed, and it's not portable
16:37:31 * revenantphx likes hlint.
16:37:35 <mtnviewmark> what functionality is in the cabal-install package vs. which is in the Cabal package (and hence in Setup.hs) is always a mystery to me
16:37:54 <revenantphx> Setup.lhs: Can't find transitive deps for haddock
16:37:55 <revenantphx> hrm
16:38:22 <shachaf> dcoutts__: It's mostly portable to UNIX (#!/usr/bin/env runhaskell), and it saves typing one command.
16:38:36 <dcoutts__> mtnviewmark: it's the difference between configure+make (Setup.hs) and a package manager (cabal - sortof)
16:38:42 <shachaf> dcoutts__: OSes that go by file extension should be able to figure it out too.
16:38:48 <dcoutts__> shachaf: ah but it doesn't save typing a command
16:39:05 <aavogt> you don't need to know the extension if you type   runghc Setup
16:39:09 <shachaf> dcoutts__: Not a command line, just a command. :-)
16:39:37 <dcoutts__> shachaf: "cabal blah" is less typing than "./Setup.(l)hs blah"
16:39:52 <shachaf> dcoutts__: Fair enough.
16:39:55 <mtnviewmark> dcoutts_ - I sort of get it, but in the end, seems to me that there isn't much value in those all being separated apart since they aren't really used independently
16:40:29 <dcoutts__> mtnviewmark: distro packages do use the Setup.hs interface
16:40:43 <dcoutts__> but the main end-user interface is (or should be) cabal
16:40:58 <mtnviewmark> would they be at all disadvantaged if they used cabal?
16:40:59 <dcoutts__> or their IDE or whatever else that uses the lower level Setup.hs interface
16:41:20 <Draconx|Laptop> dcoutts__, actually, the former is caba<tab> blah, the latter is ./S<tab> blah, so "cabal blah" is actually more typing :P
16:41:25 <dcoutts__> mtnviewmark: yes, distro packages should use the lower level interface, it does just what they need and no more
16:41:30 <dcoutts__> it also has fewer deps etc
16:41:47 <Sina> How can I take a triple like (Int,Maybe a,Char) while a is a char and return (Int,Char,Char) if Maybe is Just x
16:42:00 <mtnviewmark> would including cabal-install as part of what GHC distributes be too much?
16:42:17 <dcoutts__> Draconx: ah, but cabal the program also has tab completion, so it's really "caba<tab> bl<tab>" ;-)
16:42:24 <shachaf> Sina: And if it isn't?
16:42:44 <dcoutts__> mtnviewmark: it'd add dependencies on zlib, tar, mtl, parsec, network and HTTP
16:42:51 <Sina> shachaf: not include it in return
16:43:00 <shachaf> Sina: So what would the type be?
16:43:01 <mtnviewmark> oh - well, that is a bit much... 
16:43:16 <dcoutts__> mtnviewmark: but that's not really the point
16:43:30 <Sina> shachaf: only char. (Int,Char,Char)
16:43:35 <dcoutts__> mtnviewmark: the point is they are separate projects, have separate release cycles etc etc
16:43:43 <shachaf> Sina: What would that second Char be?
16:43:53 <dcoutts__> mtnviewmark: we don't distribute pkg-config or apt-get with gcc
16:44:15 <dcoutts__> but we do have bundles containing both (distros)
16:44:20 <mtnviewmark> its just that somethings - like installation locations (who me?) and package removal -- seem to need a fair bit of coordination between them (and *-pkg to boot)
16:44:45 <dcoutts__> sure, Cabal needs to know a bit about each compiler
16:44:55 <dcoutts__> but it also works with many versions of many compilers
16:45:00 <Sina> shachaf: the 3rd char in the triple. from the first triple, I leave the first and third items. just want to check if second element is Just x (and not Nothing) and if so, I would like to return on that x part
16:45:09 <mtnviewmark> and each platform (it makes default assumptions about layout)
16:45:49 <dcoutts__> mtnviewmark: just as ./configure + make do
16:45:59 <shachaf> > let f (x,Just y,z) = (x,y,z); f (x,Nothing,z) = (x,z,z) in (f (5,Just 'a','b'), f (5,Nothing,'b')) -- This?
16:45:59 <lambdabot>   ((5,'a','b'),(5,'b','b'))
16:46:12 <mtnviewmark> and somethings about installation are in Cabal, while others (symlinking) are in cabal-install
16:46:16 <heatsink> Is there a way to memoize values that are marshaled using the Data.Binary.Binary interface?
16:46:34 <dcoutts__> mtnviewmark: right, the division between preparing an install image, and package management
16:46:58 <mtnviewmark> well, in practice, configure is optional for a package, and the package manager changes with the distro ---- here, we all use just Cabal and cabal-install
16:46:58 <dcoutts__> mtnviewmark: if you use something like nix or stow then you get the same division
16:47:16 <Sina> shachaf, I want to not return it if it is Nothing. so I just want 5, a, b. in the returned list
16:47:22 <mtnviewmark> except that Cabal will actually do an install, right? so it IS doing package management
16:47:33 <dcoutts__> mtnviewmark: and sure, from the pov of an end user, they just use 'cabal' and do not have to care about the distinction, that's good.
16:47:45 <shachaf> Sina: That's not a list, it's a tuple.
16:48:02 <mtnviewmark> (by Cabal there, I meant the library that Setup.hs files import, not cabal-install)
16:48:05 <shachaf> Sina: And what you're asking for makes no sense. How can it not return?
16:48:10 <dcoutts__> mtnviewmark: well, only because 'cabal' happens not to install into a temp dir first, but it could (and probably should) do that
16:48:26 <mtnviewmark> won't it all do an install into your system?
16:48:35 <dcoutts__> mtnviewmark: distro packages use cabal copy --destdir=$IMAGE/
16:48:38 <dcoutts__> erm
16:48:39 <Sina> I have a list of triples. I want to check each triple, if it is (int,Just x,char) and if so, want to include it in my returned list of triples. with the change that Just x be changed to only x.
16:48:40 <mtnviewmark> and, alas, doesn't have to know about how it will install into your system?
16:48:53 <dcoutts__> mtnviewmark: runghc Setup copy --destdir=$IMAGE/
16:49:09 <dcoutts__> mtnviewmark: I don't quite follow
16:49:15 <shachaf> Oh, a *list*.
16:49:20 <mtnviewmark> right - but that is because it can do the move into place (rooted or not), and it does the xxx-pkg registration
16:49:32 <mtnviewmark> inotherwords, what aspect of installation does the Cabal lib NOT do?
16:49:51 <mtnviewmark> seems to me it IS doing package managment
16:49:52 <dcoutts__> mtnviewmark: the traditional thing for package managers is to make install DESTDIR=$IMAGE/, followed by making a manifest and copying into the real file system (or into some binary package format)
16:49:54 <benmachine> dcoutts__: 'cabal upgrade' used to give me a list of my outdated packages, can I still do that at all?
16:50:02 <shachaf> > [(x,y,z) | (x,Just y,z) <- [(5,Just 'a','b'),(5,Nothing,'b')]]
16:50:03 <lambdabot>   [(5,'a','b')]
16:50:25 <dcoutts__> mtnviewmark: cabal could do the same thing, but it currently skips out the temp image dir bit, and does not record which files it installed (and hence cannot uninstall)
16:50:44 <Sina> Shachaf, I think that is exactly what I wanted. I tried to do it the way you did but failed. thanks a lot
16:50:48 <dcoutts__> mtnviewmark: but that does not change the division of responsibility
16:51:02 <mtnviewmark> I suppose, in the end, I'm not feeling that the traditional split here is well applied in our case
16:51:24 <dcoutts__> benmachine: I presume you're using the darcs version, no the only equivalent feature at the moment is cabal install world
16:51:36 <benmachine> ah ok
16:51:42 <mtnviewmark> because ultimately, the thing that builds, has to know in the end how it will be installed --- that it doesn't do the tar/untar and copy is sort of minor to me
16:52:38 <dcoutts__> mtnviewmark: yes, and it is cabal (the program) that decides what layout to use (though the current impl takes a basic default from the Cabal lib, it could have its own default instead)
16:53:09 <dcoutts__> mtnviewmark: it dictates it to the Setup.hs by passing the standard flags, --prefix, --libdir etc
16:53:29 <dcoutts__> benmachine: the cabal install world thing is not perfect however
16:54:10 <revenantphx> how can I get this to stop?
16:54:11 <revenantphx>     Warning: Module `Prelude' is deprecated:
16:54:11 <revenantphx>                You are using the old package `base' version 3.x.
16:54:29 <revenantphx> It only does it for one of my files, not both of them... :\
16:54:54 <dcoutts__> revenantphx: use base 4, as the message suggest
16:54:56 <revenantphx> I suppose I could specify base >= 4.00
16:55:16 <dcoutts__> revenantphx: if it works with both base 3 and 4 then use base >= 3 && < 5
16:55:30 <mtnviewmark> right - I get that - I just wonder if that is sensical -- in otherwords, since Setup.hs (and hence Cabal lib) have to know that, why not have them manage the install locations and registration entirely -- and relegate only packaging (tar/zip/http dependencies) to cabal (the program)
16:55:45 <dcoutts__> revenantphx: that's the recommended way, then it may work for older ghc too
16:56:06 <revenantphx> yep, its fine now.
16:56:07 <mtnviewmark> well... don't get me wrong - I don't feel deeply strongly here - just a feeling (as a distro packager) that these three things are far more interdependent than it might appear
16:56:25 <dcoutts__> mtnviewmark: but it's not just cabal, distro package managers need the same level of control over things like registration
16:56:31 <revenantphx> I do like that if I use cabal install, I can always pull up the current state of a library in any ghci instance or other project.
16:57:03 <mtnviewmark> right - but the registration script is generated by Setup.hs - !
16:57:38 <dcoutts__> mtnviewmark: the installed package description is necessarily generated by Setup.hs, but the package manager can do the actual registering itself
16:57:54 <dcoutts__> mtnviewmark: that Setup.hs can also do the registration is a convenience for humans
16:58:03 <revenantphx> Hm.
16:58:09 <revenantphx> So if I have a bunch of different types of entities.
16:58:22 <revenantphx> All of them having different properties, but sharing in common a few things (like position)
16:58:32 <revenantphx> would it be reasonable to make "Entity" a typeclass?
16:58:35 <dcoutts__> mtnviewmark: runghc Setup register --gen-pkg-config=foo.pkg
16:58:42 <revenantphx> and then make instances for each type of Entity?
16:59:17 <aavogt> that doesn't easily let you make a list of anything in Entity
16:59:23 <mtnviewmark> yes - I do that wen building H.P.
16:59:28 <revenantphx> aavogt: ??
16:59:41 <mtnviewmark> and then I write a script that registers them after I install on the machine.
17:00:04 <revenantphx> Well, the most simplistic entity is something like an arrow. It has a position and velocity.
17:00:16 <revenantphx> and a yaw, pitch and roll
17:00:38 <revenantphx> and more complex would be a player, having all of the above (sans velocity) as well as an inventory, health, and god knows what other state.
17:00:40 <aavogt> revenantphx: you have    data A = A; data B = B; class Entity a; instance Entity A; instance Entity B... it isn't pretty to encode (in ghc haskell)    [exists e. Entity e => e]
17:00:53 <aavogt> so the list can contain   [A,B,B,A]
17:01:05 <revenantphx> I'm confused :\
17:01:32 <revenantphx> why would it be necessary to encode that?
17:01:38 <revenantphx> why is the exists e. there?
17:02:06 <revenantphx> Why can't I just do [Entity]
17:02:07 <aavogt> revenantphx: so you can have a list of anything that's an instance of Entity
17:02:21 <aavogt> revenantphx: because you can't use a class name like that in haskell
17:02:31 <revenantphx> hm
17:02:33 <Sina> Can I do a map (\(Int,Char,Char)->(Int,Maybe Char,Char)) (Int,Char,Char) ? I am getting type error
17:03:07 <Cin> Sina: What is the type of "map"?
17:03:12 <kmc> you can use map at the type  ((Int,Char,Char) -> (Int, Maybe Char, Char)) -> [(Int,Char,Char)] -> [(Int, Maybe Char, Char)]
17:03:25 <kmc> you can't map over a tuple, if that's what you're asking
17:03:28 <Cin> Sina: Nevermind.
17:03:30 <kmc> but you can map over a list of tuples, because it's a list
17:04:18 <Sina> kmc, sorry, its: map (\(Int,Char,Char)->(Int,Maybe Char,Char)) [(Int,Char,Char)]
17:04:51 <kmc> that should work
17:04:59 <kmc> i mean not that syntax
17:05:07 <revenantphx> I guess I'll just have a bunch of data constructors then.
17:05:07 <kmc> but you can use map at the type which you're trying to express
17:05:36 <Sina> I am getting this error: *** Type           : (b,Char,c) -> (b,Maybe Char,c) *** Does not match : (a,(Char,Char)) -> (b,Maybe Char,c)
17:05:57 <kmc> is your input [(Int,(Char,Char))] ?
17:06:09 <kmc> (A,B,C) is not the same as (A,(B,C))
17:06:17 <revenantphx> aavogt: the issue I'm concerned about is, what if I have 7 entity types, and they *all* need record syntax functions to get an X coordinate 
17:06:28 <revenantphx> positionXForPlayer, positionXForArrow
17:06:31 <revenantphx> not nice.
17:06:52 <Sina> kmc, oh, found a mistake, hope this be the problem...
17:07:16 <revenantphx> I want the type class to encompass the common elements of what an "Entity" can do.
17:07:45 <aavogt> revenantphx: what's the difference between all these types that should belong in Entity?
17:08:08 <kmc> perhaps you should have one type only
17:08:15 <kmc> in Java-land, new behavior => new type
17:08:20 <kmc> but this is not true in Haskell or most other langsz
17:08:21 <revenantphx> I hate Java-land.
17:08:25 <revenantphx> As I said before, they all share the fact that they have a position in space.
17:08:28 <kmc> back later
17:08:45 <revenantphx> and a pitch, roll and yaw
17:09:05 <dibblego> revenantphx, I deal with that problem all the time but I have no good answer, there is data-accessors and fclabels though
17:09:05 <revenantphx> But they can differ wildly, between a single arrow (which has nothing beyond that and a velocity), to a player that has inventory, a name, and so on.
17:09:49 <aavogt> that solution involves classes more or less
17:10:31 <revenantphx> So the solution that came to me was to have a type class for Entity with the general behavior they all share.
17:11:11 <copumpkin> oh no
17:11:13 <aavogt> revenantphx: maybe nesting (basically a tuple) like        data WithPos a = WithPos { x,y,pitch,roll,yaw :: Double, priv :: a }
17:11:14 <copumpkin> and an existential?
17:11:18 <aavogt> yes
17:11:36 <revenantphx> copumpkin: oh no what?
17:11:38 <aavogt> but revenantphx hasn't seen how ugly existentially quantified types are in haskell
17:11:52 <revenantphx> What *is* an existentially quantified type?
17:12:01 <copumpkin> more or less what you'd expect in an OO language
17:12:17 <copumpkin> if you say "I want something that implements interface X"
17:12:23 <aavogt> revenantphx: there are a couple ways to get the  exists or the [Entity] you suggested
17:12:38 <copumpkin> you're saying "there exists a type that satisfies these requirements, and that's all I need"
17:13:20 <revenantphx> Oh, i see.
17:13:33 <revenantphx> interface types are nice (I think so at least)
17:13:44 <revenantphx> How bad are they in haskell? (or ugly rather)
17:13:58 <dibblego> much nicer than in Java
17:14:13 <revenantphx> Oh ok.
17:14:15 <aavogt> http://hpaste.org/42151/right_exists or the ghc manual on -XExistentialQuantification
17:14:17 <revenantphx> Can't be *THAT* bad.
17:14:31 <revenantphx> ...Rank2Types?
17:14:35 <hpc> revenantphx: a Java interface is a decent substitute for a Haskell typeclass
17:14:43 <dibblego> data CharSequence = { charAt :: Int -> Maybe Char; length :: Int }
17:14:47 <revenantphx> In any language that has interfaces, I abuse the hell out of them.
17:14:59 <revenantphx> Sometimes a bit too much...
17:15:16 <aavogt> revenantphx: what about it?
17:15:26 <revenantphx> nothing, I just have more googlign to do
17:15:29 <Sina> hmm, I have a list of tuples (Char,Char), I want to add an int to each. and the Ints are incrementing from 0 ([0..]). for example, [(a,b),(c,d)] should get [(0,a,b),(1,c,d)]. any suggestion how to do this?
17:15:51 <dibblego> Sina, you want zipWith (is this homework?)
17:16:06 <Alan> Hmm, this line of code totally looks like it needs a refactor, but i'm not sure what device i should use to do so: (execute e (fetch e s) s)
17:16:16 <aavogt> revenantphx: in that example you can have a class constraint after the    `forall b.'
17:16:18 <dibblego> Alan, ap or (<*>) would hel pthere
17:16:35 <dibblego> Alan, \x -> f x (g x) is equivalent to f <*> g
17:16:41 <revenantphx> aavogt: I'm not quite sure I follow. Before you had 'exists' and stuf.
17:16:58 <Sina> dibblego: yeah, its part of a massive homework. will take a look at zipwith.
17:17:08 <hpc> > (f <*> g <*> h) x :: Expr
17:17:09 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:17:09 <lambdabot>    `SimpleReflect.FromExpr ...
17:17:19 <dibblego> Sina, righto, take a look at zipWith it will do most of the work for you, ask questions as they come up
17:17:26 <aavogt> (type KLeft a r = (forall b. Either a b -> r) -> r)  is one way to encode       exists b. Either a b
17:17:43 <revenantphx> I only need to work with a map of an entity
17:17:49 <Alan> :t (<*>)
17:17:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:17:53 <revenantphx> map of entities*
17:18:02 <aavogt> well the list there is the same idea
17:18:58 <revenantphx> o...k....
17:19:58 <aavogt> revenantphx: I mean in terms of handling what `a' is in the types    [a]   and   Map k a
17:20:19 <revenantphx> hm
17:24:27 <revenantphx> aavogt: do you have a more simplistic example?
17:25:14 <revenantphx> I'm getting from this that you have to explicitly say its polymorphic (forall), and then put a class constraint.
17:25:18 <Sina> dibblego: brill :) sorted... :)
17:25:25 <revenantphx> But why can you not just put only a class constaint...?
17:25:52 <revenantphx> doesSomethingWithEnts :: Entity e => [e] -> [e]
17:25:53 <dibblego> Sina, great :)
17:25:54 <revenantphx> for instance.
17:26:27 <copumpkin> revenantphx: you can, but that means something else
17:26:33 <revenantphx> what does it mean?
17:26:53 <copumpkin> it means for all types e, that are members of the Entity typeclass, [e] -> [e]
17:26:56 <dmansen> i'm curious about this too, i've never understood the difference
17:27:09 <aavogt> revenantphx: no
17:27:17 <copumpkin> they are related to each other
17:27:35 <revenantphx> copumpkin: so how doesn't that encompass what I need?
17:27:49 <copumpkin> revenantphx: lists contain the same type
17:27:55 <revenantphx> Oooh, I see.
17:28:02 <copumpkin> what you'd really want is
17:28:09 <dmansen> ohhhh
17:28:13 <copumpkin> [exists e. Entity e *> e] 
17:28:20 <copumpkin> but haskell doesn't let you write that
17:28:21 <revenantphx> ...what 0.o
17:28:30 <dmansen> so you could have a list of different types of entities in the same list?
17:28:30 <aavogt> ski's notation :)
17:28:39 <dmansen> *with different types
17:28:40 <copumpkin> it's saying I want a list of anything that is a member of the Entity typeclass
17:28:45 <copumpkin> yeah
17:28:57 <copumpkin> the only way to do that in haskell is with a wrapper
17:29:13 <copumpkin> data Wrapper = forall e. Entity e => Wrapper e
17:29:27 <copumpkin> note the forall there is equivalent to the exists on the other function
17:29:54 <revenantphx> so then... maybe i should name the class EntityC or something
17:29:58 <revenantphx> and then declare
17:30:06 <copumpkin> you're saying that the _introduction_ of the type is universal, which means that the elimination of it is existential
17:30:07 <revenantphx> data Entity = forall e. EntityC e => Entity e
17:30:24 <revenantphx> and then I can use Entity as an "interface type" of sortd.
17:31:41 * BMeph thinks everyone should just "get over it" and use Comonads already... ;)
17:32:14 <Zao> BMeph: With the current set of explanations for "monads", I fear what the "comonads are..." ones will be.
17:32:44 <hpc> "comonads are anti-backwards negative containers" :D
17:32:47 <dmansen> i've been looking for a decent resource on comonads
17:45:04 * hackagebot Javav 0.0.1 - A utility to print the target version of Java class files.  http://hackage.haskell.org/package/Javav-0.0.1 (TonyMorris)
17:45:07 * applicative wonders whether what BMeph wants people to get over is, e.g. "data Wrapper = forall e. Entity e => Wrapper e"
17:49:01 <ManateeLazyCat> QinGW: Morning. :)
17:50:01 <phao> I'm reading a book from the book recomendations in haskel.org
17:50:10 <phao> "programming in haskell"
17:50:16 <phao> I don't know what got in the head of whoever wrote it
17:50:30 <ManateeLazyCat> phao: Yeap, nice book, and another book : "Real World Haskell". :)
17:50:31 <phao> but the guy writes the symbol 'smaller than or equal to' like it's writte
17:50:37 <phao> instead of <= in the code
17:50:43 <applicative> the use of non-ascii 
17:50:45 <applicative> yes
17:50:50 <phao> there is the 'arrow up' character in the code
17:50:58 <phao> applicative, those characters are not even in my keyboard
17:51:17 <revenantphx> But they can be!
17:51:20 <ManateeLazyCat> phao: <= => <- -> \
17:51:25 <revenantphx> For the low low price of $0.00!
17:51:26 <phao> what's in the head of that guy to use that as the default in the book
17:51:31 <ManateeLazyCat> phao: You can type those.
17:51:31 <revenantphx> Um, unicode.
17:51:39 <phao> ManateeLazyCat, right, thx.
17:51:43 <revenantphx> Keyboard shortcuts are good for you.
17:51:57 <revenantphx> on osx, alt+< or > yields ≤ and ≥ for instance
17:52:03 <ManateeLazyCat> phao: The symbol in book just print version.
17:52:17 <ManateeLazyCat> phao: So don't worried it.
17:52:26 <revenantphx> > let (÷) a b = a `div` b in 10 ÷ 2
17:52:27 <lambdabot>   5
17:52:29 <phao> ManateeLazyCat, yes
17:52:33 <applicative> yes, it is 'literate haskell', in some form.  there are conventions for typesetting our favorite operators. 
17:52:37 <phao> except that the book doesn't mention the alternative
17:52:39 <phao> not up to where I am.
17:53:10 <phao> is there any table out there
17:53:21 <phao> relating those 'different' ones to 'normal' ones?
17:53:33 <hpc> phao: the alternative is what it looks like, roughly
17:53:37 <hpc> → becomes ->
17:53:42 <hpc> ⇒ becomes =>
17:53:44 <hpc> etc
17:53:47 <phao> and the 'up key'?
17:53:55 <phao> ops
17:53:58 <phao> 'up arrow'
17:54:02 <ManateeLazyCat> phao: Can you past it?
17:54:19 <phao> 2↑3
17:54:24 <hpc> the up arrow doesn't have a good ascii analog that i know of
17:54:38 <dolio> Exponentiation, maybe?
17:54:46 <hpc> dolio: it's up-arrow notation
17:54:48 <ManateeLazyCat> phao: We don't use ↑ in haskell source code.
17:54:54 <hpc> http://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation
17:55:06 <dolio> hpc: One up arrow is exponentiation, right?
17:55:10 <revenantphx> aavogt: still here?
17:55:12 <applicative> right, dolio
17:55:19 <dolio> Okay.
17:55:24 <ManateeLazyCat> phao: But → and ⇒ , yes, like hpc said. :)
17:55:25 <hpc> oh, indeed it is
17:55:26 <aavogt> revenantphx: sure
17:55:38 <hpc> phao: so one up arrow is the same as '^'
17:55:44 <revenantphx> aavogt: Okay I'm trying to do a simple proof of concept, but I'm running into a small issue.
17:55:44 <revenantphx> https://gist.github.com/732780
17:55:46 <phao> right..
17:55:52 <revenantphx>     Can't make a derived instance of `Show Entity':
17:55:52 <revenantphx>       Constructor `Entity' does not have a Haskell-98 type
17:55:52 <revenantphx>       Possible fix: use a standalone deriving declaration instead
17:56:03 <hpc> one i just saw recently is circled asterisk = <*>
17:56:17 <revenantphx> so er, can't do that?
17:56:42 <aavogt> you can add Show to the constraints
17:58:27 <aavogt> data Entity = forall e. (Show e, EntityC e) => Entity e; instance Show Entity where show (Entity e) = show e
17:59:09 <revenantphx> ah, gotcha
17:59:35 <applicative> phao, did you look on the website for Hutton's book,  there's code and some powerpoints that don't do the fancy typesetting. http://www.cs.nott.ac.uk/~gmh/book.html#code
17:59:38 <revenantphx> cant use derive though?
17:59:45 <aavogt> no idea
17:59:57 <phao> looking
18:00:06 <phao> haven't opened the website so far
18:00:09 <revenantphx> ok lets see
18:01:02 <applicative> phao, i think it has solutions too, so don't look at them  :)
18:01:07 <revenantphx> hm
18:01:08 <revenantphx> https://gist.github.com/732783
18:01:15 <phao> heheheh
18:01:21 <revenantphx> wait, erp
18:01:38 <revenantphx> refresh that
18:01:48 <revenantphx> so its not working it seems.
18:02:15 <revenantphx> refresh again
18:02:15 <revenantphx> https://gist.github.com/732783
18:02:17 <revenantphx> this doesn't work either.
18:02:22 <pygmalion> if anyone has a minute i just posted a stackoverflow (didn't come here first mainly because it's long form): http://bit.ly/fdzipz
18:03:02 <applicative> phao, hah, the solutions are typeset with latex too...
18:03:33 <phao> what happened with good and old txt files for source code =(
18:23:01 <revenantphx> ello?
18:23:23 <revenantphx> https://gist.github.com/732783
18:23:36 <revenantphx> (where a and b are Simple and Complex entities respectively)
18:24:07 <jmcarthur> revenantphx: [Entity a, Entity b]?
18:24:18 <revenantphx> ?
18:24:35 <jmcarthur> revenantphx: i assume you are trying to use existentials?
18:24:47 <revenantphx> yeah... and failing at it.
18:24:49 <jmcarthur> revenantphx: [a, b] is wrong. [Entity a, Entity b] is right
18:24:55 <aavogt> which docs are you looking at for that extension?
18:24:56 <jmcarthur> revenantphx: a and be have different types
18:24:59 <jmcarthur> *a and b
18:25:34 <jmcarthur> revenantphx: lists can only contain values of the same type. so you have to wrap things in Entity to make them the same type
18:25:38 <revenantphx> jmcarthur: kk.
18:25:59 <revenantphx> Prelude Network.Currycraft.Entity> listEntities e
18:25:59 <revenantphx> ["SimpleEntity 1.0 2.0 3.0","ComplexEntity 4.0 5.0 6.0 \"Phil\" \"Collins\""]
18:26:03 <revenantphx> alright :).
18:26:36 <revenantphx> So, what about if I wanted to have a tree (yes this is very OOPish)
18:26:42 <jmcarthur> revenantphx: btw, if you define class Show a => EntityC a where ..., then you can just say data Entity = forall e. EntityC e => Entity e
18:26:55 <hpc> hehe, Phil Collins
18:27:00 <jmcarthur> a tree of what?
18:27:09 <revenantphx> It's my generic name.
18:27:12 <revenantphx> dunno why
18:27:21 <applicative> pygmalion if you are still around take a look at the illustrative module http://gitit.johnmacfarlane.net/paste.lhs it has something in common with you todo scheme
18:27:25 <revenantphx> Entity -> PersonEntity -> NPCEntity, PlayerEntity / ProjectileEntity -> ArrowEntity/SnowballEntity
18:27:42 <revenantphx> er, lemme make that more clear...
18:28:21 <jmcarthur> revenantphx: btw, an Entity is basically equivalent to (Double, Double, Double) right now, or perhaps (String, Double, Double, Double)
18:28:31 <revenantphx> Yes, this is a hyper-simplified case.
18:28:53 <revenantphx> Entity – PersonEntity – NPCEntity
18:28:53 <revenantphx>                                         \ PlayerEntity
18:28:53 <revenantphx>            \ ProjectileEntity – Arrow Entity
18:28:53 <revenantphx>                                            \ SnowballEntity
18:29:05 <jmcarthur> err...
18:31:26 <revenantphx> so er...
18:31:33 <jmcarthur> revenantphx: the approach i think you're looking for will not end well, i think
18:31:45 <revenantphx> I'm not actually doing that mind you.
18:32:00 <revenantphx> The main issue here is overlapping record functions though.
18:32:30 <revenantphx> well, it's not that much of an issue.
18:32:51 <jmcarthur> so what's the difference between, say, a ProjectileEntity and a SnowballEntity?
18:33:03 <lars9> how to make "+RTS -N2 -RTS" default option when running an executable?
18:33:27 <jmcarthur> lars9: you have to make some sort of a simple C wrapper. i don't know the details though
18:34:10 <lars9> jmcarthur: that sounds wierd though
18:34:32 <jmcarthur> i'm sorry?
18:35:15 <lars9> jmcarthur: lol
18:36:25 <lars9> jmcarthur: i mean it's weird that we can not specify that inside haskell program.
18:37:21 <ezyang> lars9: No, not really, since once Haskell is started the RTS is already running. 
18:37:38 <aavogt> you can call one haskell program with another haskell program which can set those options
18:37:39 <ezyang> What you're finding weird is the fact that we can't adjust the -N during the execution of the runtime. 
18:37:54 <kadoban> lars9: http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/runtime-control.html  look for 4.15.8
18:38:07 <kadoban> that's how to do the thing in C
18:38:44 <ManateeLazyCat> lars9: Do you use Cabal? you can add those option in .cabal file.
18:39:22 <lars9> 4.15.8 looks good
18:39:26 <lars9> thanks
18:39:50 <kadoban> ya, it seems kind of hacky, but whatever, it works
18:40:00 <lars9> ManateeLazyCat: does that work? cabal only controls compilation right?
18:41:16 <revenantphx> oh sorry, back
18:41:25 <revenantphx> jmcarthur: at the moment those two should just be different constructors.
18:41:43 <revenantphx> the only difference (in data) is their type
18:41:49 <jmcarthur> oh, so you aren't talking about different types at all
18:41:50 <revenantphx> they have different trajectories though
18:41:57 <revenantphx> it was a contrived example
18:42:08 <jmcarthur> okay, then i guess i just don't understand the question
18:42:29 <jmcarthur> anyway i gotta go
18:42:53 <revenantphx> k, thanks anyhow
18:44:48 <dolio> dmansen: Read, The Dual of Substitution is Redecoration by Uustalu and Vene.
18:47:32 <dmansen> oh, thanks. i'll check it out
19:02:49 <younder> is there a ML group on freenode?
19:03:57 <younder> I can't seem to find one
19:04:37 <younder> actually MLTon rocks!
19:05:36 <younder> It's data-flow optimization set's new standards in functional code performance.
19:06:33 <younder> It finished just after ADA in a shootout. Before OCAML and Haskel
19:07:42 <younder> This was a 7'th place C was in 2'nd after D
19:08:04 <younder> (Who's ever heard of a D programmer..)
19:08:37 <FauxFaux> A friend of a friend likes D!
19:08:45 <FauxFaux> 6 degrees of D programmers.
19:10:30 <romildo> Can a string literal have an explicit newline character?
19:10:45 <FauxFaux> TIAS.
19:11:44 <romildo> For instance,  can I write a string literal in two lines of code without using a gap, and the newline will be part of the string? Something like "first line
19:11:47 <romildo>   second line"
19:12:09 <aavogt> @hackage haskell-src-meta
19:12:09 <lambdabot> http://hackage.haskell.org/package/haskell-src-meta
19:13:01 <aavogt> romildo: the short answer is no
19:14:41 <romildo> aavogt, so in the above example I have to write something like "first line\n\
19:14:44 <aavogt> but you could with {-# LANGUAGE QuasiQuotes #-}  write       [$here| first line
19:14:48 <aavogt> second line |]
19:14:51 <romildo>     \second line"
19:15:17 <aavogt> using here as defined in http://hackage.haskell.org/packages/archive/haskell-src-meta/0.2/doc/html/src/Language-Haskell-Meta-QQ-Here.html
19:16:32 <romildo> Let me search about quasi-quote on the web ...
19:18:37 <aavogt> romildo: http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html#th-quasiquotation
19:21:43 <younder> String performance in Haskell is much better with the array monad package.
19:22:36 <younder> As in Lisp strings as list's are a mistake..
19:26:55 <Axman6> younder: not a mistake, just not always the right choice
19:28:13 <younder> Well in my experience strings a write once read mostly. and random access matters.
19:28:25 <crutcher> hey there; in haskell 6.12.3; how long after I call hClose does it take for a socket coverted to a Handle to actually close?
19:28:36 <crutcher> (I'm running out of file descriptors)
19:30:33 <younder> Just go a new book on Game theory. My favorite form of math :)
19:31:25 <younder> Finally get a chance to look a Wilson's equilibrium principle.
19:33:11 <younder> You see in 'Land of Lisp' there is a game which could really benfit from this technique. So of course I have to 'improve' it.
19:33:54 <younder> s/go/got/
19:57:19 <unkanon> are (.) and flip all the tools one needs to convert a function to pointfree style?
19:58:43 <dmansen> those help, but you can also use partial application
19:58:58 <dmansen> there's no one-size-fits-all approach...i think
19:59:22 <sshc> If I absolutely *need* the internal representation of a data type, but its constructors aren't exported as they certainly should be, would copying the data type's definition to another data type and unsafeCoering to the properly exported type be safe?
19:59:26 <int80_h> hey #haskell, I'm talking to a troll who says oop is the way humans naturally think. responses?
19:59:58 <unkanon> dmansen: yes I forgot to mention partial application, that is another good tool too.
20:00:03 <roconnor> int80_h: tell him he is wrong
20:00:04 <kfish> int80_h, respond objectively
20:00:20 <unkanon> I'm trying to learn how to convert to point free manually and so far I've only used flip, (.) and partial application.
20:00:29 <unkanon> and ($)
20:00:29 <winxordie> int80_h: Ask him to define the object object.
20:00:35 <int80_h> I did. now we can troll each other.
20:00:44 <int80_h> hah hah
20:00:53 <roconnor> unkanon: const and join are important
20:01:41 <roconnor> int80_h: where is this trolling happening?
20:02:30 <sshc> Is this usage of unsafeCoerce safe?
20:03:00 <roconnor> sshc: it is when the two types are the same
20:03:12 <winxordie> identity?
20:03:17 <winxordie> oh. hehe. roconnor beat me to it.
20:03:36 <sshc> roconnor: They're named differently but otherwise the same
20:03:39 <unkanon> roconnor: can you do a @pl command that outputs something using join or const so I can learn from it?
20:03:40 <sshc> roconnor: One's a copy of another
20:03:53 <sshc> roconnor: But I actually have access to the copy's constructors
20:04:22 <Veinor> @pl \x -> f x x
20:04:22 <lambdabot> join f
20:04:25 <roconnor> what does a copy mean?
20:04:46 <unkanon> Veinor: thanks, now do one with const please and I'll go back to studying :)
20:04:55 <Veinor> @pl \x y -> x
20:04:55 <lambdabot> const
20:04:57 <Veinor> ;)
20:05:08 <unkanon> aww but that's the definition of const!
20:05:13 <Veinor> hehe
20:05:34 <magicman> @pl \f x y -> f (f x)
20:05:34 <lambdabot> (const .) . join (.)
20:05:48 <unkanon> that's beautiful, thanks!
20:06:00 <magicman> join - for when you need to use something twice. const - for when you don't need to use something at all.
20:06:02 <unkanon> so I should always keep const in mind when I see a function that ignores one of its arguments
20:06:13 <magicman> Yep.
20:06:15 <sshc> roconnor: module A defines "data Foo = Foo Int Bar | Quux String (Bar -> Foobar)", but only exports the type.  I *need* the constructor of that type (not really; just want to know hypothetically).  I thought of writing "data PublicFoo = Foo Int Bar | Quux String (Bar -> Foobar)", and unsafeCoercing from one type to another in case such a situation ever arises.
20:06:30 <unkanon> magicman: oh that's what I thought, though I hadn't understood join before. thanks a bunch!
20:06:35 <parcs> unkanon: don't forget about id
20:06:38 <min> @pl \x -> h (f x) (g x)
20:06:38 <lambdabot> liftM2 h f g
20:06:47 <roconnor> sshc: well, there are different levels of safetyness
20:07:05 <magicman> Fun fact: (.), flip, const, and join (and combinations of it) form a combinator calculus that is Turing complete.
20:07:10 <parcs> @pl (\x f -> f x)
20:07:10 <lambdabot> flip id
20:07:23 <sshc> roconnor: Provided that the definition is the same, even though their names are different, is unsafeCoercing those safe?
20:07:34 <copumpkin> magicman: ap and const are sufficient
20:07:42 <unkanon> parcs: hmm I'll think about that for a while
20:07:51 <magicman> Oh, sure, those are S and K :)
20:07:57 <roconnor> sshc: I don't know.  Probably not safe, but it may be hard to find a case where it goes wrong.
20:08:31 <sshc> roconnor: How would it not be safe?
20:08:33 <roconnor> BCKW FTW!
20:08:45 <sshc> BCKW?
20:08:52 <copumpkin> (.), flip, const, and join
20:08:54 <applicative> sshc, you could ask the library author to export it.  I've done this, when it was clear it didn't matter to the design.
20:09:14 <min> hmm, \x -> h (f x) (g x) = liftM2 h f g - what monad is liftM2 returning in?
20:09:14 <roconnor> sshc: if say constructor tags names are assigned by hashing the full name of constructors
20:09:26 <Pseudonym> Well, join is a more generic version.
20:09:37 <roconnor> sshc: oh BCKW is in regards to the combinator discussion
20:09:38 <copumpkin> min: ((->) r)
20:09:52 <magicman> min: The (r->) monad, where m x = (r -> x)
20:09:53 <unkanon> copumpkin: what's defining about those four functions?
20:09:57 <Pseudonym> :t \h f g x -> h (f x) (g x)
20:09:58 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
20:10:06 <applicative> copumkin, did you make progress on your Proto-Sub-Iteratee scheme?
20:10:06 <Pseudonym> @hoogle forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
20:10:07 <JoeyA> @sk (.)
20:10:07 <lambdabot> No results found
20:10:07 <lambdabot> Consider it noted.
20:10:15 <min> Oh! That makes sense. I always forget about (r ->).
20:10:20 <sshc> applicative: For what it's worth, I always advocate using .Internal for "private" stuff for when you really really need the internal representation
20:10:24 <roconnor> sshc: not that I'm saying that GHC does such hashing, but, you know, it could in some imaginary future version
20:10:30 <copumpkin> unkanon: they correspond to the BCKW combinators (or are slightly more general than them) :)
20:10:33 <Pseudonym> I like S', C' and B*.
20:10:40 <unkanon> min: yeah I was wondering why @pl thought that had to do with a monad....
20:10:40 <Pseudonym> We don't use them enough.
20:10:44 <JoeyA> @sk Oops, I was hoping lambdabot had an sk or ski command.
20:10:44 <lambdabot> Consider it noted.
20:11:34 <magicman> @help sk
20:11:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:11:34 <sshc> roconnor: Ah, so, with the current implementation it's likely fine, but it really depends on the implementation / system or in other word's any safeness is coinsidence.
20:11:52 <magicman> An ask alias?
20:11:56 <Pseudonym> How does BCKW represent I?  Is it WKK or something?
20:12:03 <magicman> Just WK
20:12:03 <min> It's odd that everyone uses functors, but I only just realized that fmap in (r ->) is (.).
20:12:13 <magicman> join const x = const x x = x
20:12:16 <JoeyA> How do you express the (.) operator in SKI?  The closest I got is (.) = S . K
20:12:19 <Pseudonym> Right.
20:12:22 <applicative> sshc, and then putting .Internal in the export list?  Like Text.Foo.SlightlyUnsafe?
20:12:48 <magicman> S (K S) K, according to wikipedia. I'm too lazy to double-check.
20:13:28 <copumpkin> :t ap (const ap) const
20:13:29 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
20:14:01 <applicative> up next: combinator palindromes
20:14:21 <sshc> applicative: Like Data.ByteString
20:14:24 <unkanon> what are you guys talking about with I and WKK? (how do I evengoogle for these things?)
20:14:35 <applicative> :t ap (const const) ap
20:14:36 <magicman> http://en.wikipedia.org/wiki/B,C,K,W_system <- unkanon
20:14:36 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m (a -> b1) -> b -> m a -> m b1
20:14:36 <Pseudonym> \f g x -> f (g x) = \f g (S (K f) g) = \f -> S (K f) -> S (K S) K
20:14:36 <sshc> applicative: Data.ByteString doesn't export Data.ByteString.Internal, but Data.ByteString.Internal can still be used
20:14:46 <magicman> And that probably has more references on it.
20:14:49 <unkanon> oh, SKI, i remember that, isn't that a kind of LC?
20:15:09 <copumpkin> http://en.wikipedia.org/wiki/SKI_combinator_calculus
20:15:09 <JoeyA> magicman: You're right: S (K S) K z = K S z (K z) = S (K z)
20:15:10 <roconnor> sshc: yes I'd say that
20:15:22 <JoeyA> which means S (K S) K = S . K
20:15:31 <JoeyA> and as I found earlier, (.) = S . K
20:15:34 <applicative> yes, that's the type of case i was thining of,  the main system doesn't export it, but it's secretly listed in the ,cabal file
20:15:46 <magicman> Sweet :)
20:15:57 <Pseudonym> Oh, BCKW is actually quite nice to work in.  The optimisation rules are very simple.
20:15:57 <copumpkin> :t ap . const
20:15:58 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
20:16:14 <unkanon> magicman: thanks for the link
20:16:23 <copumpkin> Pseudonym: optimization by partial evaluation?
20:16:30 <copumpkin>  / reduction
20:16:38 <Pseudonym> Basically, the rules are this:
20:16:48 <Pseudonym> T[\x -> x] = W K
20:16:57 <Pseudonym> T[\x -> y] = K y
20:17:21 <Pseudonym> T[\x -> (K F) (K G)] = K (F G)
20:17:38 <Pseudonym> T[\x -> (K F) G] = B F G
20:17:50 <Pseudonym> Erm.
20:18:04 <Pseudonym> Sorry, that's not how I'd implemented it.
20:19:12 <JoeyA> > fix ((0:) . (1:) . (zipWith (+) <*> tail)
20:19:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:19:16 <JoeyA> > fix ((0:) . (1:) . (zipWith (+) <*> tail))
20:19:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:19:20 <magicman> I understand the first two of those transformations, but the last two look weird...
20:19:28 <magicman> How should I interpret \x -> (K F) G?
20:19:39 <magicman> 'cause (K F) G = F.
20:21:09 <Pseudonym> translate (Lam x f) = abstract x f
20:21:09 <Pseudonym> translate (f `Ap` g) = translate f `Ap` translate g
20:21:09 <Pseudonym> translate (Var x) = Var x
20:21:18 <Pseudonym> abstract x (Var y) | x == y -> W `Ap` K
20:21:18 <Pseudonym>                    | otherwise -> K `Ap` Var y
20:21:29 <Pseudonym> And finally, the optimisation rules:
20:21:31 <Pseudonym> abstract x (Ap f g)
20:21:32 <Pseudonym>     = case (abstract x f) (abstract x g) of
20:21:32 <Pseudonym>         (K `Ap` f', K `Ap` g') -> K `Ap` (f' `Ap` g')
20:21:32 <Pseudonym>         (K `Ap` f', g) -> (B `Ap` (f' `Ap` g'))
20:21:32 <Pseudonym>         (f', K `Ap` g') -> (C `Ap` (f' `Ap` g'))
20:21:43 <Pseudonym> I don't know how much of that you got.
20:22:35 <Pseudonym> Basically, the case for \x -> f g returns a single W, K, B or C at the top level depending on how \x -> f and \x -> g translate.
20:24:19 <magicman> I see how that code is equal to the transformations earlier, but I still don't see how (K F) G translates to anything other than F.
20:25:14 <Pseudonym> magicman: What's the original lambda expression?
20:26:13 <Pseudonym> The task, remember, is to compile lambda calculus without B, C, K and W into lambda calculus with B, C, K and W but no lambdas.
20:26:32 <magicman> Right.
20:29:23 <magicman> So, let's take \x y -> y x, (or flip id, or C (W K))
20:29:43 * magicman hopes the case will pop up there <_<
20:29:53 * magicman grabs pen and paper and writes it out.
20:32:44 <Pseudonym> OK, looks like you still need to implement the optimisation rule:
20:32:55 <Pseudonym> W (K f) (W K) -> f
20:33:31 <Pseudonym> Or: B f (W K) -> f
20:34:22 <min> @pl \x y -> h (f x) (g x) x
20:34:22 <lambdabot> const . join (liftM2 h f g)
20:34:43 <magicman> And otherwise, abstract x stuff = stuff with abstract x on its children, right?
20:35:14 <magicman> Wait, no, that doesn't make sense.
20:35:24 <Pseudonym> No.
20:35:31 <magicman> Never mind. You make sure there's always an Ap there.
20:35:46 <Pseudonym> The case does come up, though, of things like:
20:35:50 <Pseudonym> abstract x W
20:35:52 <Pseudonym> Which is (K W)
20:37:00 <magicman> Right. I only just noticed that you have a data Comb = B | C | K | W | Ap Comb Comb
20:37:26 <Pseudonym> Or something.
20:37:28 <magicman> Which is the only way to make sense of it, anyway, with it being untyped and not caring about argument count or anything.
20:37:34 <magicman> *nod*
20:37:36 <Pseudonym> I have only proven this correct, I havent' run it.
20:37:39 <magicman> ;)
20:38:02 <magicman> There's a Var and a Lam in there, too, but this is the gist of it.
20:38:20 <Pseudonym> What you need to be able to guarantee is that abstract x f = K `Ap` f if x is not free in f.
20:38:40 <Pseudonym> This code doesn't guarantee that.
20:39:00 <unkanon> a free variable is when it's inside a function but it didn't get there by being bound to one of that function's arguments/parameters ?
20:39:15 <Pseudonym> Or an internal lambda, yeah.
20:39:35 <unkanon> wow, I never thought I really knew that :)
20:39:40 <unkanon> I guess I picked it up somehow
20:40:18 <magicman> Latent knowledge is awesome :P
20:41:01 <unkanon> lol
20:44:23 <magicman> I guess the easy thing is to have a guard | x `elem` freeVars thing = K thing | otherwise = <interesting stuff>
20:44:39 <magicman> But I can see how the translation rules work now :)
20:44:48 <Pseudonym> But you really want to do it piecemeal.
20:44:56 <Pseudonym> The SKI translation rules handle it automatically.
21:04:57 <min> Is there a good way to simplify the list operations at the bottom here <http://codepad.org/ML16BQ2Q>? They're getting unwieldy and CYK is such a simple algorithm; it doesn't deserve this.
21:09:16 <tehgeekmeister> is there a function that returns true if all values in a list of maybes are Justs rather than Nothing?
21:09:40 <monochrom> @type all
21:09:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:09:47 <ben> @type isJust
21:09:47 <lambdabot> forall a. Maybe a -> Bool
21:09:48 <monochrom> all isJust your_list
21:10:02 <tehgeekmeister> (or, really, they aren't in a list to start with, i just need to do something only if a set of Maybes are Justs)
21:10:10 <tehgeekmeister> ah, right
21:10:29 <ben> catMaybes if you actually want the ones that are Just and do not need all of them to be Just
21:10:55 <tehgeekmeister> oh actually, catMaybes could be useful.
21:11:02 <tehgeekmeister> hmm.
21:11:03 <tehgeekmeister> thanks.
21:11:55 <monochrom> Data.Set.fold (\m b -> b && isJust m) True your_set
21:12:06 <tehgeekmeister> it's not a set to start with
21:12:16 <tehgeekmeister> i'm pulling a few parameters out of a request in snap
21:12:26 <tehgeekmeister> the action only makes sense with all the parameters
21:12:36 <tehgeekmeister> (i'll handle error messages and whatnot later)
21:21:22 <monochrom> onoes, haddock 2.9 drops support for ghc<7
21:27:37 <tehgeekmeister> @hoogle isJust
21:27:37 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
21:36:34 <barosl> what is a recommended method for detecting parse errors for read :: String -> Int ?
21:36:42 <barosl> Control.Exception i think?
21:36:59 <lispy> barosl: use a different read function :)
21:37:07 <barosl> for example?
21:37:14 <lispy> barosl: readS I think might be the name
21:37:16 <lispy> :t readS
21:37:18 <lambdabot> Not in scope: `readS'
21:37:36 <lispy> ?hoogle Show a => String -> a
21:37:37 <lambdabot> Prelude error :: [Char] -> a
21:37:37 <lambdabot> Debug.Trace trace :: String -> a -> a
21:37:37 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
21:37:43 <lispy> ?hoogle Read a => String -> a
21:37:43 <barosl> oops, i only tried searching safeRead
21:37:43 <lambdabot> Prelude read :: Read a => String -> a
21:37:43 <lambdabot> Text.Read read :: Read a => String -> a
21:37:43 <lambdabot> Prelude readIO :: Read a => String -> IO a
21:38:09 <lispy> barosl: iirc, there is one that is like, Read a => String -> (a,String)
21:38:16 <lispy> or there was a list?
21:38:19 <lispy> :t readP
21:38:20 <lambdabot> Not in scope: `readP'
21:38:28 <lispy> ?hoogle readS
21:38:28 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
21:38:28 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
21:38:28 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
21:40:43 <lispy> > reads "1" :: [(Int, String)]
21:40:44 <lambdabot>   [(1,"")]
21:40:53 <lispy> > reads "a" :: [(Int, String)]
21:40:54 <lambdabot>   []
21:40:58 <lispy> barosl: ^^
21:41:05 <lispy> > reads "1a" :: [(Int, String)]
21:41:06 <lambdabot>   [(1,"a")]
21:41:29 <lispy> > reads "1 2a" :: [(Int, String)]
21:41:31 <lambdabot>   [(1," 2a")]
21:42:11 <barosl> well..
21:42:56 <adnap_> is using the "flip" function a bad idea?  do you think it makes code less readable?
21:44:23 <lispy> adnap_: it's fine at times
21:44:27 <lispy> ?src reverse
21:44:27 <lambdabot> reverse = foldl (flip (:)) []
21:44:37 <lispy> adnap_: I think it's pretty readable in that example
21:48:38 <pygmalion> I'm trying to implement (instantiate?) showList for a specific type but I'm not really sure how it's supposed to be used
21:49:14 <pygmalion> I have already implemented show for the type in question
21:49:36 <pygmalion> and i just want a list of objects of this type to be display individually with a newline separating them
21:59:56 <pygmalion> :r
22:11:53 <BeginnerHere> hello 
22:18:41 <BeginnerHere> hello who is in charge of this IRC?
22:18:53 <BeginnerHere> for today?
22:20:04 <lispy> BeginnerHere: we all are
22:29:56 <BeginnerHere> lispy are u still here?
22:30:32 <maurer_> BeginnerHere: What are you looking for?
22:31:33 <BeginnerHere> maurer: A friend of my was banned yesterday and they would like to know what is the process to get unbanned 
22:33:26 <maurer_> You'll either need to talk to freenode or the person who banned him.
22:33:50 <maurer_> If he was actually banned in this channel, chances are it won't get reversed--you usually have to be kind of a dick for that to happen.
22:34:50 <Kaidelong> someone was on here yesterday saying "did you know obama was black?" repeatedly and other such things
22:35:03 <Kaidelong> (s)he ended up getting banned
22:35:59 <BeginnerHere> kaidelong: it wasn't that person
22:38:18 <BeginnerHere> maurer: who in freenode does the person need to talk/email to? I am not sure of what happen but their was an argument between them and pumpkin and I think monochrom was involved somehow
22:40:09 <lispy> BeginnerHere: it might help if you could find the place in the log where the person was banned: http://tunes.org/~nef/logs/haskell/
22:41:38 <danderson> what version of base ships with GHC 7 ?
22:41:41 <danderson> is it 4.4?
22:42:11 <lispy> danderson: 4.3 here
22:43:08 <danderson> ah, right. I have 4.2 on ghc 6, so that makes sense.
22:43:15 <danderson> I confused myself with my cabal definition.
22:43:35 <Kaidelong> BeginnerHere: the only person who got banned yesterday was Cookies, who was spamming the stuff I mentioned
22:43:55 <BeginnerHere> it was guest2425
22:44:21 <Kaidelong> I remember that guy
22:44:37 <BeginnerHere> they said after the argument they tried to log in and couldn't get back in
22:45:02 <BeginnerHere> maybe someone blocked their ip address?
22:45:04 <Kaidelong> he never encountered copumpkin
22:46:01 <Kaidelong> he also was still on after Cookies got banned
22:46:18 <Kaidelong> I think he's dealing with technical difficulties, not a channel ban
22:48:13 <Kaidelong> BeginnerHere: I do not think he was banned, most likely explanation is if he used a second connection to also be cookies, and got himself IP banned for spam
22:48:13 <lispy> danderson: why do you need to know which version of base shipped with which ghc if you're writing a cabal file?
22:48:31 <lispy> danderson: (I have a small fear you're writing the cabal file in a sort of brittle way)
22:48:42 <Kaidelong> if that is not it, then he wasn't banned
22:48:58 <lispy> Kaidelong: what is set -q?
22:49:07 <danderson> lispy: I'm updating a package of mine to work with GHC7. I'd specified a dependency of "base >=3.0 && <4.3", as that was the range I'd tested with.
22:49:13 <lispy> Kaidelong: if you search for that, you will see that quicksilver had to take care of someone too
22:49:24 <danderson> now, I need to change that last bit to <4.4, as I've had someone verify that ghc7 builds my package fine.
22:49:27 <danderson> does that make sense?
22:49:43 <lispy> danderson: yes, that's perfectly logical
22:49:57 <danderson> I guess I could make it require any v4 base version, but I prefer to not blindly trust future releases of base :P
22:49:58 <Kaidelong> lispy: set -q doesn't match anything in the log as far as firefox's find function is concerned
22:50:18 <lispy> Kaidelong: I think you have to search in the log for the 7th
22:50:39 <lispy> 09:33:53 --- mode: quicksilver set -q Muncuie!*@*
22:50:41 <Kaidelong> lispy: yeah, found it already =3
22:50:47 <Kaidelong> seems it was also for spam though
22:50:54 <BeginnerHere> kaidelong: this what they email me right now, Usermode change: +i :46] == -   [22:46] == End of /MOTD command. [22:46] == Usermode change: +i [22:46] == gateway/web/freenode/ip.152.131.10.195 is now your hidden host (set by syn.) [22:46] frigg [~frigg@freenode/utility-bot/frigg] requested CTCP VERSION from guest2425: [22:46] frigg [~frigg@freenode/utility-bot/frigg] requested CTCP VERSION from guest2425: [22:46] == #Haskell Can
22:50:58 <lispy> Kaidelong: Indeed
22:52:16 <Kaidelong> BeginnerHere: doesn't look different from what I see when I log on
22:52:40 <Kaidelong> BeginnerHere: +i means they've been identified by the services
22:52:48 <Kaidelong> that's a good thing
22:54:21 <lispy> they seem to be connected to freenode
22:55:01 <lispy> In fact, the log doesn't show that they ever left...
22:55:13 * lispy >>= sleep
23:02:08 <jun_> i want to learn this language. where should I start?
23:06:30 <crutcher> any idea why the sub packages in Data.Enumerator (IO, Util, ...) in enumerator aren't indexed by hoogle or hayoo!
23:06:34 <luite> jun_: http://learnyouahaskell.com/
23:08:24 <BeginnerHere> kaidelong and lispy; I have looked at the logs for the last night and I also agree I don't c anything relating to an argument between gues2425 and copumpkin, is it possible someone deleted them?
23:08:50 <jun_> luite: thanks!
23:09:19 <quicksilver> lispy, Kaidelong : +q silences someone without banning them or kicking them
23:09:31 <quicksilver> it's useful if you suspect the spam is accidental
23:09:47 <quicksilver> and you can turn it off after they've fixed the problem
23:13:12 <BeginnerHere> kaidelong or lispy: what about the part where it says #Haskell Cannot join channel (+b) - you are banned , why would it say that?
23:13:36 <lispy> quicksilver: do you know how to answer BeginnerHere's questions?
23:14:18 <lispy> BeginnerHere: it's extremely unlikely someone tampered the logs.  There isn't a precedent for it and the person who does the logging is not really involved here
23:14:38 * lispy goes back to bed
23:14:51 <quicksilver> BeginnerHere: well, to get unbanned your friend needs to join #haskell-ops
23:15:03 <quicksilver> and talk to someone there
23:15:08 <quicksilver> they won't be banned there.
23:15:57 <BeginnerHere> quicksilver: thanks im letting them know now
23:16:25 <BeginnerHere> lispy: ok 
23:16:31 <antimatroid1> http://www.graphwar.com/tutorial.html
23:16:33 <antimatroid1> check that game out
23:16:39 <antimatroid1> that would be interesting to play ai on
23:17:44 <antimatroid1> oops, wrong channel :)
23:18:02 <mae> hello everybody
23:19:19 <Kaidelong> BeginnerHere: it didn't say that in the thing you pasted, or it cut
23:20:17 <BeginnerHere> I c it, maybe it was cut from everyone else? wierd...
23:23:57 <Kaidelong> BeginnerHere: more likely the paste was just too long and the whole thing didn't get sent, even if it looks that way on your end
23:24:03 <BeginnerHere> kaidelong: I think my friend is talking to quicksilver in that #haskell-ops room, thanks
23:24:25 --- mode: ChanServ set +o quicksilver
23:24:29 --- mode: quicksilver set -b *!*@gateway/web/freenode/ip.152.131.10.*
23:27:34 <BeginnerHere> kaidelong: thats probably what happen .. haha
23:29:33 <NewUser> hello
23:30:13 <NewUser> Cale: Thank you so much for your help
23:31:29 <Kaidelong> I had a project that wouldn't compile and now does (and works correctly) after enabling Rank2Types
23:31:49 <Kaidelong> clearly I have somehow understood something without understanding it
23:31:56 <Kaidelong> but what was it?
23:32:03 <NewUser> Kaidelong: lol
23:32:09 <NewUser> Kaidelong: new material
23:32:12 <NewUser> ?
23:34:06 <BeginnerHere> how does it feel to be back NewUser???:)
23:34:33 <NewUser> good
23:34:45 <NewUser> Hello I have a question 
23:35:01 <crutcher> anyone here work on Network?
23:35:28 <crutcher> I'd like to request a refactoring of Network.connectTo
23:35:32 <jun_> I'm just starting out on haskell. Is this also good for web programming?
23:35:52 <NewUser> jun_: The best where you have been
23:36:03 <Kaidelong> jun_: not haskell itself but there are several sorts of ruby-on-rails sorts of libraries for it to facilitate that
23:36:14 <NewUser> Here is my question http://pastebin.com/STNQ3dh0
23:36:51 <Kaidelong> http://www.haskell.org/haskellwiki/Web
23:36:59 <Kaidelong> for jun_
23:37:22 <NewUser> BeginnerHere: are you here?
23:38:01 <BeginnerHere> yup
23:38:09 <jun_> thanks for the help guys!
23:46:19 <NewUser> Here is my question http://pastebin.com/STNQ3dh0
23:53:49 <BeginnerHere> http://pastebin.com/STNQ3dh0 for this link, does anyone know any reason why one would want to sort 1D array or list 
23:56:08 <BeginnerHere> Does anyone know about sudoku or kenken?
23:57:05 <NewUser> Kaidelong: Do you know about the Kenken puzzle
23:58:41 <cch`> hi, I am using heist, I encounter a problem as describe in https://gist.github.com/733014
23:59:19 <cch`> I wonder where do so many repeated <YY/> come from
23:59:36 <Kaidelong>  NewUser: I do not
