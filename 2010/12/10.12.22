00:00:00 <c_wraith> Oh.  Then I claim no knowledge at all! :)
00:00:06 <McManiaC> kk :)
00:00:53 <Saizan_> ?type return
00:00:55 <Veinor> McManiaC: oh, I thought you were confused about the nature of the function return and was like 'uhhhhh'
00:01:03 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:01:46 <McManiaC> Saizan_: so first a then m?
00:02:18 <Saizan_> McManiaC: i'd guess so, but i'm not so sure that ghci and Core agree on the ordering
00:02:48 <McManiaC> k
00:04:42 <McManiaC> it typechecks and runs, but I always get an empty list :(
00:07:39 <listofoptions> haskell+beer = ?
00:08:18 <c_wraith> a good combination
00:08:54 <McManiaC> <3
00:08:55 <listofoptions> lmao i learned haskell (or started to) with the help of a large dose of coffee
00:09:16 <McManiaC> another good combination
00:09:17 <McManiaC> ^^
00:09:25 <listofoptions> aprently so
00:09:31 <listofoptions> now i wont touch c++
00:09:44 <listofoptions> unless i want some state
00:10:21 <lispy_> Cale: I'm building ghc-6.12.3 on the lambdabot server, FYI
00:10:48 <McManiaC> lispy_: Control.Monad.State ;)
00:11:02 <lispy_> McManiaC: Sorry?
00:11:06 <listofoptions> i dont think i can work out an algorithm for a nondeterministic Turing machine if i'm non-sober
00:11:17 <McManiaC> @hoogle State
00:11:18 <lambdabot> module Control.Monad.State
00:11:18 <lambdabot> Test.HUnit.Base data State
00:11:18 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
00:11:43 <McManiaC> lispy_: oh, sorry, meant listofoptions 
00:11:49 <lispy_> McManiaC: ahh!
00:11:53 <listofoptions> thx
00:12:08 <c_wraith> isn't the algorithm for a non-deterministic turing machine just concatMap?
00:12:25 <listofoptions> whoa fancy shit
00:12:32 <c_wraith> Or are you trying to avoid exponential state space use?
00:12:41 <listofoptions> yes
00:12:42 <lispy_> ghc-cabal: Cannot find the program 'hscolour' at '' or on the path
00:12:44 <lispy_> Weird
00:12:44 <c_wraith> I guess there's something to be said for keeping the state space small :)
00:13:20 <McManiaC>    ds_dHJ{v} [lid]
00:13:21 <McManiaC>       @ ghc-prim:GHC.Types.Int{(w) tc 3J} x{v aEz} [lid]
00:13:24 <McManiaC> (correct)
00:13:26 <McManiaC> vs:
00:13:32 <McManiaC>    base:GHC.Base.return{v 01T} [gid[ClassOp]]
00:13:32 <McManiaC>       @ ghc-prim:GHC.Types.Int{(w) tc 3J} x{v aEz} [lid]
00:13:33 <McManiaC> :(
00:13:43 <lispy_> Where do I get hscolour?
00:13:44 <listofoptions> i'm using one simmilarly to the three tape machine in Elemnts Of The Theory Of Computation 2d ed 
00:14:07 <listofoptions> i think it's somewhere between page 206-211
00:15:29 <lispy_> oh, it should be HsColour not hscolour...weird.
00:15:46 <listofoptions> McManiaC c++ has it's uses, save for the clarity of haskell i definetly sugest learning it
00:15:54 <lispy_> has vector-algorithms been tested on ghc 7?
00:16:33 <danderson> is there an in-file pragma to tell GHC to disable a single specific warning?
00:16:53 <danderson> (c2hs FFI is generating unused arguments - I want the rest of the warnings, but not the unused parameter one)
00:16:58 <lispy_> danderson: yes, {-# OPTIONS_GHC -fno-warn-foo #-}, IIRC
00:18:04 <danderson> ah, cheers
00:19:35 * hackagebot strptime 0.1.8 - Efficient parsing of LocalTime using a binding to C's strptime  http://hackage.haskell.org/package/strptime-0.1.8 (EugeneKirpichov)
00:20:55 <McManiaC> listofoptions: I never said it doesn't. I prefer C though for simplicity and haskells FFI :)
00:21:17 <listofoptions> indeed, but i really like pure
00:21:21 <listofoptions> for it's FFI
00:21:26 <McManiaC> whats pure?
00:22:05 <listofoptions> http://pure-lang.sourceforge.net/
00:22:14 <listofoptions> term-rewriting
00:22:42 <listofoptions> typesa aren't as strong as haskell's but they can be easily emulated
00:23:40 <danderson> hrm, doesn't look like I can turn off that unused definition warning :/
00:25:31 <dibblego> do one of the Data.Map functions allow me to fix this? http://paste.pocoo.org/show/308263/
00:25:50 <danderson> ah, I needed -fno-warn-unused-matches
00:26:06 <listdata> has anyone used CmdArgs with multiple modes? the example at http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm only prints what occurred --- i'm not sure how to go about connecting the parsed arguments with my program logic...
00:26:32 <danderson> so lambda args are pattern matches, not defined symbols. Makes sense, in hindsight.
00:27:03 <ivanm> dibblego: use maybe with Map.lookup instead of a case?
00:27:11 <ivanm> or else Map.adjust?
00:28:25 <dibblego> actually Map.update looks like it
00:28:55 <dibblego> or not
00:29:27 <Saizan_> ?type Data.Map.update
00:29:31 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
00:29:41 <listofoptions> @hoogle concatMap
00:29:42 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
00:29:42 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
00:29:42 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
00:29:45 <Saizan_> ?type Data.Map.alter
00:29:46 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
00:29:53 <Saizan_> dibblego: ^^^
00:30:00 <Saizan_> ?type Data.Map.adjust
00:30:01 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
00:30:13 <dibblego> yeah I'm giving it a crack with alter
00:31:43 <dibblego> http://paste.pocoo.org/show/308267/
00:32:03 <ivanm> dibblego: did my messages to you go through?
00:32:09 <ivanm> my net seemed to have hiccuped... :s
00:32:15 <dibblego> ivanm, yes
00:32:21 <ivanm> k
00:33:02 <listofoptions> wait c_wraith how is concatMap nondeterministic?
00:33:24 * listofoptions is having a headsplosion
00:33:24 <dibblego> I don't think I can do much better than with adjust
00:33:31 <c_wraith> listofoptions, it's not, really
00:33:42 <ivanm> dibblego: I think "Just . maybe d f" is better than your case statement though
00:33:55 <dibblego> yeah I can tidy that
00:34:03 <c_wraith> It can be used to simulate non-determinism as "just tracking every possibility at once"
00:34:11 <Saizan_> listofoptions: you can think of a function a -> [b] as a non-deterministic function a -> b
00:34:14 <c_wraith> But that's obviously potentially exponential space usage
00:34:19 <Saizan_> listofoptions: since it returns multiple results
00:34:29 <ivanm> dibblego: so you want to insert it if it's not already there?
00:34:44 <ivanm> then yeah, adjust won't do what you want and alter appears to be a better option
00:34:45 <dibblego> ivanm, I want to insert a value regardless , yes
00:35:21 <listofoptions> holly crap i didnt realise it was that nifty
00:35:50 <ivanm> M.alter (Just . maybe d f) doesn't look too bad though... but I think the code you have there doesn't quite typecheck
00:35:59 <Saizan_> dibblego: btw, you probably want to make sure (f w) gets evaluated, using "Just $! f w"
00:36:08 <ivanm> dibblego: are you really wanting to insert a Map into your Map if that key isn't present in it? :p
00:36:23 <dibblego> ivanm, I'm not inserting a Map
00:36:31 <Saizan_> ivanm: (d :: a)
00:36:50 <ivanm> dibblego: oh, wait, whoops, I mis-read your argument list :/
00:36:51 <ivanm> sorry
00:37:00 <ivanm> Saizan_: yeah, I see that now
00:37:11 <dibblego> Saizan_, yes I do, thanks
00:37:22 <ivanm> for some reason I read it as taking in two maps and I associated the last two values provided as the two maps :/
01:03:48 * hackagebot data-accessor-template 0.2.1.6 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-template-0.2.1.6 (HenningThielemann)
01:06:48 * hackagebot graph-wrapper 0.2.1 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.1 (MaxBolingbroke)
01:07:06 <ivanm> is Max Bolingbroke on here?
01:14:51 * hackagebot wai-handler-snap 0.1.0 - Web Application Interface handler using snap-server.  http://hackage.haskell.org/package/wai-handler-snap-0.1.0 (MichaelSnoyman)
01:26:54 * hackagebot blaze-html 0.3.1.0 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.3.1.0 (JasperVanDerJeugt)
01:36:37 <romildo> Hi.
01:38:20 <romildo> Given a string  and a string list, I want to sort the string list based on how their elements "looks like" the given string. Is there a function for that?
01:44:06 <Entroacceptor> @hoogle sortBy
01:44:07 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
01:44:14 <Entroacceptor> romildo: maybe try that
01:44:43 <Entroacceptor> but you'd have to write the "looks like" part yourself
01:46:44 <flux> romildo, levenstein (?) distance is perhaps something you want to look up
01:47:06 <flux> perhaps someone has already implemented it for haskell
01:47:41 <Entroacceptor> or one of http://en.wikipedia.org/wiki/Category:String_similarity_measures :)
01:47:44 <flux> if not, perhaps my O'Caml implementation comes close (but it uses arrays)
01:49:40 <Entroacceptor> but I just found some implementations with google
01:49:48 <Entroacceptor> there's a package edit-distance
01:54:58 <romildo> Thanks for the tips. I will look at them.
01:55:13 <muep> I tried to get rid of the stuff that I had installed with cabal to $HOME/.cabal by removing $HOME/.cabal, but cabal still thinks I have all that stuff installed
01:55:42 <muep> how can I revert to the situation as it was before I installed anything?
01:57:14 <hvr> muep: there's also ~/.ghc
01:57:31 <muep> hmm, maybe I'll nuke that, too
01:58:17 <Saizan_> muep: actually, you could've deleted .ghc and not .cabal
01:59:01 <muep> the reason for me wanting to clean it up is that as far as it is easily possible, I want the things out of my homedir to /opt/$USER/haskell or something similar
02:00:38 <muep> thanks, now it seems to install them again
02:01:21 <romildo> flux, where is  your levenstein distance implementation in OCaml available?
02:17:15 * hackagebot digest 0.0.0.9 - Various cryptographic hashes for bytestrings; CRC32 and Adler32 for now.  http://hackage.haskell.org/package/digest-0.0.0.9 (EugeneKirpichov)
02:20:06 <monadic_kid> man this is some real head f*** bug I'm getting with using modL from fclabels
02:21:17 * hackagebot jarfind 0.1.0.2 - Tool for searching java classes, members and fields in classfiles and JAR archives  http://hackage.haskell.org/package/jarfind-0.1.0.2 (EugeneKirpichov)
02:44:16 <monadic_kid> nuts layzniess, code was never evaluated
03:01:45 <monadic_kid> are guard patterns really lazy or something?
03:02:21 <shachaf> monadic_kid: Yes, it's a new Haskell feature. "really lazy" evaluation, up to three times lazier than regular lazy evaluation.
03:03:34 <monadic_kid> that's not a useful answer
03:04:52 <monadic_kid> not funny either
03:05:29 <monadic_kid> shachaf: there are levels of lazyniess, weak and head normal form but i don't remember the rules
03:07:07 <shachaf> monadic_kid: Your question was also not particularly useful. More context might help.
03:15:50 <Lemmih> monadic_kid: They are as strict as they need be.
03:20:01 <monadic_kid> Lemmih: I've managed to force evaluation of some parts but I'm still having a problem using fclabel's modL function, can't force evaluation
03:21:06 <Lemmih> monadic_kid: What's your end goal?
03:21:23 <ezyang> Code please 
03:21:56 <alpounet> I think lambdabot is having some problems at the moment
03:22:03 <alpounet> <alpounet> > 2 <lambdabot>   thread killed
03:22:40 <monadic_kid> okay I'll post the function but there is going to be a lot of missing context
03:30:38 <monadic_kid> http://haskell.pastebin.com/3E7rgHj6
03:30:53 <monadic_kid> this code is before adding strictness annotations
03:31:21 <monadic_kid> it's the calls to modL that are not being evaluated
03:31:59 <monadic_kid> oops made a mistake
03:34:09 <monadic_kid> http://haskell.pastebin.com/5yJbBqee
03:35:54 <ezyang> What is the type of EventHandler? 
03:37:15 <monadic_kid> Word64 -> a -> (Word64, a)
03:37:34 <ezyang> Ok. What's your strict version? 
03:38:18 <ezyang> There are a bunch of obvious places to add strictness, and I'm curious what you did. 
03:40:36 <monadic_kid> ezyang: basically I just change the first level of the modL (updateAnim) to getL/setL, adding a bang pattern to a let expression, that made map updateAnim get evaluated but not the call to modL within that function, it does not get evaluated then I tried adding bang patterns to the functions arguments of updateAnim and nextAnim but that didn't work
03:41:57 <ezyang> that sentence is hard to parse. Define "didn't work" (what is your criterion). 
03:43:26 <ezyang> Did you add a Debug.trace call to see if an expression is being evaluated? 
03:44:27 <monadic_kid> ezyang: this expression "modL (sheetDataList . sprites) (snd . mapAccumL nextAnim 0) entity" the modify function ( snd . mapAccumL nextAnim 0) never gets evaluated. I've doing something simillar to using Debug.trace which did not get evaluated
03:44:38 <ezyang> Ok. 
03:44:54 <ezyang> The first thing you should reach for when you have a laziness is not bang pattersn in lets. 
03:45:05 <ezyang> It should be looking at the data types you define and making them strict. 
03:45:14 <ezyang> (because any strictness annotation you add there will apply globally) 
03:45:33 <ezyang> In particular, tuples are lazy. I suspect you actually want data GameWorld = GameWorld !GameConfig !GameData 
03:45:48 <ezyang> And depending on what GameConfig and GameData look like, you may need strictness annotations there too. 
03:47:01 <ezyang> I wonder if Haskell ought to have a strict tuple. :-/ 
03:47:30 <monadic_kid> ezyang: I don't have something like GameWorld, I have GameMonad (monad transformer stack), my timer event system doesn't use monads
03:47:35 <ezyang> This advice is assuming you're not actually using laziness in your code (which doesn't appear to be the case: what you have looks very imperative) 
03:48:10 <ezyang> Oh, so you've extracted this from a state-like GameMonad? 
03:48:18 <ezyang> Is your monad strict? 
03:49:05 <monadic_kid> ezyang: ahhhhh, okay I never specified Lazy/Strict in the module imports
03:49:27 <ezyang> Then it's lazy. 
03:50:09 <ezyang> Also, if you have StateT (Foo, Bar), that will be "lazy" in that the contents of the tuple won't be forced. 
03:50:16 <ezyang> So you'll eed to add strictness there too. 
03:51:01 <monadic_kid> xchat crashed :/
03:51:53 <ezyang> Then it's lazy. Also, if you have StateT (Foo, Bar), that will be "lazy" in that the contents of the tuple won't be forced. So you'll need to add strictness there too. 
03:51:58 <ezyang> (repaste) 
03:52:07 <monadic_kid> ezyang: I'm not using tuples in StateT/ReaderT but I do have an action called getWorld that extracts a tuple of out of those
03:52:21 <ezyang> That tuple will be lazy. 
03:52:43 <ezyang> unless getWorld forces both of its arguments. 
03:53:03 <monadic_kid> getWorld :: GameMonad r s (r,s)
03:53:03 <monadic_kid> getWorld = (,) <$> ask <*> get
03:53:05 <ezyang> The key insight here, I think, is that strictness is "layered." 
03:53:55 <ezyang> Each time you peel away a outer constructor, any fields that are strict will be forced, but only as far as you've added strictness annotations. If you'd like some sub-sub-sub-field to be strict, you need strictness annotations all the way down. 
03:54:18 <ezyang> monadic_kid: That should be ok, if you strict-ify ReaderT and StateT 
03:54:32 <monadic_kid> ezyang: yep i'm going try this out
03:54:54 <ezyang> It is slightly lazy, but as soon as you try to use a value in the tuple it becomes strict, so I don't think you're too worried about that. 
03:55:04 <ezyang> And GHC might be able to optimize that appropriately. 
03:58:11 <monadic_kid> ezyang: thanks for the tips, I've tried it but I think I need to add strictness annotations to the timer event system
03:58:43 <tsbo> Is there and tutorial style documentation for haskelldb? Every link I find just 404s...
03:58:47 <ezyang> Maybe. I haven't identified where the "top" of your layers are. If that top is the timer event system, then you need it. 
03:59:04 <tsbo> s/and/any/
04:02:55 <monadic_kid> ezyang: GameMonad is the top layer i think, the timer events is mostly pure functions, with a data type of a map of named functions with data that says at what interval to apply these functions, I have an action in GameMonad that uses those timer events
04:03:56 <ezyang> Ah, so game monad has a "tick" function? 
04:04:19 <monadic_kid> ezyang: something like that yeah
04:04:56 <ezyang> What is the output of the timer event, since it's a pure function? An updated state? 
04:05:06 * ezyang is not sure why the timer events are not monadic. 
04:06:41 <monadic_kid> ezyang: yep
04:06:59 <ezyang> Hm. Swapping out your monad transformer stack to be strict should work then. 
04:07:14 <ezyang> It's more likely that you need more strictness in your state representation. 
04:07:58 <ezyang> (because remember, once we shove the value of the evaluated timer event into the strict state monad, it will be forced to whnf) 
04:09:41 <ezyang> Does your state contain any functions, btw? 
04:11:45 <monadic_kid> ezyang: indirectly, I'm storing the timer event map within the data-type used in the state monad
04:14:20 <ezyang> "Is your map strict?" 
04:14:37 <ezyang> From my limited understanding of your problem domain, that shouldn't make a difference, but I'm not sure. 
04:15:58 <monadic_kid> ezyang: these are the types i'm using for the timer events http://haskell.pastebin.com/CCeVxHy5
04:16:32 <ezyang> All of them coudl do with some extra strictness. 
04:16:56 <monadic_kid> ezyang: I think I'll use a data type instead of a tuple there
04:17:12 <ezyang> Also, Data.Map doesn't have a "strict" variant, rather, you have to use strict modifier functions. 
04:18:14 <monadic_kid> ezyang: i think it might be a good idea to use record becuse i've forgotten what the members of the tuple mean now lol
04:18:32 <ezyang> Indeed a good reason :-) 
04:18:46 <ezyang> In fact, if these Int64s mean different things, you might want to newtype them. 
04:20:59 <monadic_kid> okay one is the time period, the other is the last tick
04:21:31 <monadic_kid> so now i now i remember why I need to store this in my state monad
04:24:21 <ezyang> you almost definitely want to newtype that. 
04:24:32 <ezyang> Confusing intervals and timestamps is not fun :-) 
04:25:48 <monadic_kid> heh
04:27:15 <alpounet> ezyang, why not just a type synonym ?
04:27:25 <alpounet> (unless there are some smart constructors or somesuch under the hood)
04:27:28 <ezyang> alpounet: No static checking. 
04:43:08 <ManateeLazyCat> aristid: I have upload a version without music, at http://www.youtube.com/watch?v=A3DgKDVkyeM
04:43:43 <ManateeLazyCat> @tell aristid I have upload a version without music, at http://www.youtube.com/watch?v=A3DgKDVkyeM 
04:43:43 <lambdabot> Consider it noted.
04:44:46 <xarch> > 2
04:44:48 <lambdabot>   2
04:44:56 <ManateeLazyCat> Once i use "Linker.linkPackages" linking some package/module in running program, i can't re-linking it even i have install new version in ghc/cabal database, how to use GHC-API re-linking package or re-load module? Thanks! :)
04:46:47 <phao> have you guys ever felt sorry for some other programmer, because he/she knew so little?
04:48:25 <koala_man> no, because they probably made much more than me
04:48:31 <Eelis> @pl (\f g (x,y) -> (f x, g y))
04:48:31 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
04:48:39 <Eelis> hm. there's gotta be something for that
04:49:12 <parcs> Eelis: liftM2 curry
04:49:43 <alpounet> @type (***)
04:49:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:49:45 <Eelis> parcs: ah, i think (***) might be it
04:50:01 <alpounet> @unpl ***
04:50:01 <lambdabot> (***)
04:50:05 <alpounet> hm
04:50:09 <alpounet> anyway, you got it :p
04:50:15 <Eelis> yeah, thanks :)
04:50:33 <xarch> @pl \f x -> f x x
04:50:33 <lambdabot> join
04:50:36 <xarch> hum
04:56:23 <blenderer> did anything database related get into the haskell platform?
04:58:05 <ezyang> aha! 
04:58:09 <ezyang> mix. 
05:02:55 <Bynbo7> blenderer: no, and i doubt it ever would
05:04:31 <blenderer> Bynbo7: This page http://www.haskell.org/haskellwiki/Haskell_Platform/Batteries_Included seems to list some things for "eventual" inclusion
05:04:53 <Bynbo7> databases aren't used very often in haskell
05:06:02 <blenderer> are you saying in haskell people don't often need to have persistant data? Or do they use other means?
05:07:11 <alpounet> blenderer, this isn't the kind of application haskell is often used for
05:07:23 <alpounet> not often enough at least
05:07:45 <Bynbo7> blenderer: i use other means
05:09:07 <ivanm> blenderer: just because it isn't in the platform doesn't mean you can't use it
05:09:12 <ivanm> IMHO, the platform is _way_ overrated
05:09:44 <ManateeLazyCat> ivanm: Hi. :)
05:09:59 <ivanm> hey ManateeLazyCat 
05:10:11 <blenderer> ivanm: i peeked at hackage and there were a lot of choices. I thought I'd favor something in the platform if it existed.
05:10:12 <ManateeLazyCat> ivanm: How are you? :)
05:10:47 <ivanm> blenderer: RWH has a section on HDBC IIRC, so you may prefer that option if you want an actual tutorial/guide
05:10:51 <ivanm> ManateeLazyCat: not bad, yourself?
05:11:00 <ManateeLazyCat> ivanm: hacking GHC API. :)
05:11:29 <ivanm> oh? what for?
05:12:01 <ManateeLazyCat> ivanm: I have find a way to perfect "script haskell" in running haskell application.
05:12:02 <blenderer> ivanm: thanks
05:12:16 <ManateeLazyCat> ivanm: Fast and safe as compile code, but dynamic like script. :)
05:12:38 <ManateeLazyCat> ivanm: You can update the code in runtime, but won't lose speed. :)
05:12:40 <mm_freak_> blenderer: i use databases heavily
05:12:48 <mm_freak_> using the 'persistent' packages
05:12:58 <ivanm> there's also haskelldb, takusen, etc.
05:13:23 <ManateeLazyCat> ivanm: Now i need find which GHC-API reload package/module, after that, my code should be finish, then integrate in Manatee. :)
05:13:32 <ivanm> cool
05:13:43 <ManateeLazyCat> ivanm: I call it "compile cache server" :)
05:13:43 <ivanm> I take it you're abusing the GHC API way more than hint allows you to? :p
05:13:48 <mm_freak_> those have the advantage that you don't have to write SQL
05:14:08 <ManateeLazyCat> ivanm: I'm build "compile cache server" and not interpreter. :)
05:14:42 <ivanm> hmmm...
05:15:12 <ManateeLazyCat> ivanm: I build "TVar middle layer" between dynamic-linking thread and application, so "compile server" compile *new* code to ghc/cabal database. and running application dynamic-linking new version code to TVar.
05:15:38 <ManateeLazyCat> ivanm: So dynamic-linking thread and application running in *two* threads for write/read TVar. :)
05:15:47 <ManateeLazyCat> ivanm: That's why i call it *cache*. :)
05:16:37 <ManateeLazyCat> ivanm: Dynamic-Linking code have finish, just need fix *reload* problem, that i can't reload *new* version library once it linked in memory.  
05:17:04 <ManateeLazyCat> ivanm: I believe have this GHC-API, just haven't found, seek in GHC ocean :p
05:17:30 <ivanm> heh
05:17:33 <ivanm> anyway, I'm off to bed
05:17:34 <ivanm> g'night all
05:17:41 <ManateeLazyCat> ivanm: G'night. :)
05:18:21 <blenderer> mm_freak_, ivanm: yeah, an overwhelming number of choices when you first start out with 0 knowledge :)
05:18:57 <ManateeLazyCat> Please tell me if any ghc expert know how to use GHC-API reload linked module
05:19:01 <ManateeLazyCat> Thanks! :)
05:20:19 <ManateeLazyCat> mm_freak_: How about the fastirc? 
05:25:02 <mm_freak_> ManateeLazyCat: started working on it yesterday =)
05:26:05 <ManateeLazyCat> mm_freak_: I can't wait new version, you know. :)
05:26:56 <ManateeLazyCat> mm_freak_: I just need new code parse *number* message and ssh support. :)
05:27:40 <ManateeLazyCat> @time JaffaCake1
05:28:12 <JaffaCake> ManateeLazyCat: can I help?
05:29:51 <ManateeLazyCat> JaffaCake: Do you know which GHC-API use to *reload* package/module that has linked in memory? I can't use "Linker.linkPackages" linking new version code in running program.
05:30:35 <JaffaCake> ManateeLazyCat: the API isn't designed to update packages, it assumes they do not change
05:30:54 * ManateeLazyCat pasted "GHC dynmaic linking" at http://paste2.org/get/1155665
05:30:55 <ManateeLazyCat> JaffaCake: My code snippets like above. 
05:30:57 <JaffaCake> probably a lot would need to change to relax that assumption
05:31:53 <mm_freak_> ManateeLazyCat: i've completely rewritten the parsing code
05:31:55 <ManateeLazyCat> JaffaCake: So i can't use GHC-API linking *new* version if *old* version has already linked?
05:32:23 <JaffaCake> you'd need to get GHC to reload the package database
05:32:24 <mm_freak_> ManateeLazyCat: the next version will contain a Numeric type, which lists all the usual numerics as constructors
05:32:31 <ManateeLazyCat> mm_freak_: Why need rewritten? I think current one is good enough? Any big improve from rewritten?
05:33:04 <ManateeLazyCat> JaffaCake: How? You just need tell me which API for it, i hacking myself. 
05:33:11 <mm_freak_> ManateeLazyCat: today i understand attoparsec and it's features much better, so i optimized a lot, which almost needed a complete rewrite
05:33:15 <ManateeLazyCat> JaffaCake: So many GHC API...
05:33:18 <JaffaCake> ManateeLazyCat: the package database is cached in DynFlags, so you have to restart the session to get a new DynFlags I think
05:33:57 <mm_freak_> ManateeLazyCat: as promised/threatened, the next version will come along with large API changes =)
05:34:16 <JaffaCake> or... if you set pkgDatabase to Nothing, then call setSessionDynFlags, that should do it
05:34:28 <ManateeLazyCat> JaffaCake: Restart session will cause GHC session linking *new* version package?
05:34:46 <mm_freak_> ManateeLazyCat: also the parsing API will allow you to use iteratees directly
05:34:56 <mm_freak_> which is very useful for networking code
05:35:17 <JaffaCake> ManateeLazyCat: if you have installed a new package, you need to get GHC to load the new package database
05:35:31 <JaffaCake> then you should be able to link the new package
05:35:59 <ManateeLazyCat> JaffaCake: Ok, those information help me a lot, thank you very much! :)
05:36:25 <JaffaCake> no problem
05:36:45 <JaffaCake> you might run into problems, we don't normally do this
05:37:09 <JaffaCake> that is, change the package database during a running GHC API session
05:37:12 <ManateeLazyCat> JaffaCake: I have got the memory problem you told me yesterday.
05:37:32 <JaffaCake> yes, that's a tricky one to fix
05:37:34 <ManateeLazyCat> JaffaCake: Memory is increase along with dynamic-linking times.
05:37:36 <alpounet> http://haskell.org/haskellwiki/Ghc-gc-tune awesome
05:38:03 <ManateeLazyCat> JaffaCake: But there have Maximum memory value i found.
05:38:12 <JaffaCake> ManateeLazyCat: it could be fixed, but we have to do a full heap traversal to make sure there are no pointers to the old code remaining
05:39:13 <ManateeLazyCat> JaffaCake: Maybe GHC should release memory to OS once it found haven't any pointer reference to old code address?
05:39:42 <ManateeLazyCat> JaffaCake: Perhaps not immediately, but should release when no reference?
05:40:23 <JaffaCake> we don't have the code to check for references yet. somebody needs to write it
05:41:13 <ManateeLazyCat> JaffaCake: I'm research dynamic-linking code in running program, I will let you know if i get problem.
05:41:24 <JaffaCake> ok, thanks
05:42:12 * ManateeLazyCat pasted "dynload" at http://paste2.org/get/1155671
05:42:13 <ManateeLazyCat> JaffaCake: Above is my complete code, just *reload* features haven't finish.
05:42:52 * ManateeLazyCat pasted "Main.hs" at http://paste2.org/get/1155672
05:43:06 <ManateeLazyCat> Above is simple code test dynload function.
05:44:50 <ManateeLazyCat> mm_freak_: New version will break current API?
05:45:44 <ManateeLazyCat> mm_freak_: I have 2000 lines IRC Client code base your fastirc, i don't want change too much since i'm very happy with current version.  
05:47:15 * ManateeLazyCat Manatee still use very old dbus-client-0.3 , because i have 20+k lines code use old one, hard to change...
05:48:42 <mm_freak_> ManateeLazyCat: you can state the dependency on the older version explicitly
05:48:51 <mm_freak_> in your cabal file
05:48:58 <ManateeLazyCat> mm_freak_: Yes
05:49:28 <mm_freak_> the new API will definitely break old code, because a few things have different names and types
05:50:25 <ManateeLazyCat> mm_freak_: I remember John add DBus monad in new version dbus-client that break Manatee everywhere, hope new version fastric won't break too much....
05:51:08 <mm_freak_> ManateeLazyCat: well, it's a simplified API
05:51:31 <mm_freak_> you can decide for yourself whether you want to migrate
05:51:31 <ManateeLazyCat> mm_freak_: Ok, Thanks. Can't wait you new version. :)
05:51:54 <mm_freak_> if not, i recommend packaging the old fastirc as an own package
05:51:57 <mm_freak_> manatee-fastirc =)
05:51:59 <ManateeLazyCat> mm_freak_: I always want to use newest version if change is not too painful. :)
05:52:16 <ManateeLazyCat> mm_freak_: I try to avoid fork. :)
05:52:16 <mm_freak_> the painful part will mostly be renaming stuff
05:52:34 <mm_freak_> and there will be an extended and simplified session manager
05:53:13 <ManateeLazyCat> mm_freak_: To be honest, i think session manager is always useful for everyone.
05:53:26 <ManateeLazyCat> s/always/not always
05:53:47 <mm_freak_> yes, and that's no problem, because you don't have to use it
05:53:58 <mm_freak_> but i suggest at least looking at it
05:54:00 <ManateeLazyCat> mm_freak_: Yes, i don't use your session code.
05:54:05 <ManateeLazyCat> mm_freak_: Ok, :)
05:54:10 <mm_freak_> the current one isn't good anyway
05:54:23 <mm_freak_> the new one will be based on real life experience with networking code =)
05:55:05 <ManateeLazyCat> Good to know that. :)
05:58:56 <alpounet> are there any examples of using fastirc ?
05:59:07 <ManateeLazyCat> @package manatee-ircclient
05:59:07 <lambdabot> http://hackage.haskell.org/package/manatee-ircclient
05:59:21 <ManateeLazyCat> alpounet: ^^^ My IRC client use fastirc.
05:59:46 <alpounet> i was thinking of a tinier piece of code :-P
06:00:01 <ManateeLazyCat> alpounet: Screenshot at : http://www.flickr.com/photos/48809572@N02/5003871553/lightbox/
06:00:22 <ManateeLazyCat> alpounet: Code is clean, just my framework is special. :)
06:00:32 <alpounet> yeah yeah i heard about it don't worry
06:00:36 <ManateeLazyCat> alpounet: BTW, fastirc is damn fast and stable. :)
06:00:46 <alpounet> i'm just looking for a tiny piece of code using fastirc
06:01:37 <ManateeLazyCat> alpounet: You can ask mm_freak_ how to use fastirc. :)
06:01:54 <ManateeLazyCat> alpounet: fastirc have simple and clean API. :)
06:02:28 <mm_freak_> at least the parsing code =)
06:02:45 <mm_freak_> the current session code isn't that simple and clean
06:03:30 <ManateeLazyCat> mm_freak_: Split session out and make fastirc *perfect*, haha. :)
06:03:43 <mm_freak_> hehe
06:12:31 * ManateeLazyCat Research JaffaCake's idea, bye all. :)
06:19:47 <alpounet> mm_freak_, don't you have a sample for fastirc somewhere ? something "minimal" -- whatever that means for such a library
06:24:28 <mm_freak_> alpounet: nope, sorry
06:24:32 <mm_freak_> nave 
06:24:48 <mm_freak_> haven't written a wiki entry for fastirc yet, because i knew i would change the API some time
06:25:48 <mm_freak_> after all it's the first haskell project i released =)
06:26:17 <djahandarie> I thought it was simple enough when I looked at it some time ago
06:26:59 <mm_freak_> i made some poor choices regarding its API and implementation, as well as its use of existing libraries, but of course "poor" doesn't mean "bad", it just means, "could be done better"
06:27:04 <mm_freak_> now i'm doing it better
06:27:17 <mm_freak_> that's why the next release will be a major API change
06:27:55 <mm_freak_> most notably i'm planning that the user doesn't touch attoparsec directly, but instead gets a nice enumerator API
06:33:09 <alpounet> mm_freak_, sounds good
06:33:12 <alpounet> when will it be released ?
06:33:24 <alpounet> (by the way, just found this : http://hpaste.org/25767/more_irc )
06:33:43 <alpounet> (and man, i love that OverloadedString ext)
06:35:18 <mm_freak_> alpounet: i'm not sure…  i'm planning to release this week
06:35:38 <alpounet> mm_freak_, you know what would be great for this release?
06:35:59 <alpounet> a nice simple example provided with the library :]
06:36:24 <mm_freak_> alpounet: yeah, that code uses the old session handler
06:36:42 <mm_freak_> alpounet: it's difficult to write a /simple/ example for using an IRC library =)
06:37:04 <mm_freak_> i think the parsing API should be quite straightforward though
06:37:09 <blendere1> how would I install documentation for all the packages i've installed via "cabal insall"?
06:37:39 * hackagebot Useful 0.0.6 - Some useful functions and shorthands.  http://hackage.haskell.org/package/Useful-0.0.6 (DanielHolden)
06:38:00 <phao> Hah
06:38:07 <phao> it's possible to give a type a type?
06:38:16 <mm_freak_> phao: types have kinds
06:38:19 <mm_freak_> :k Maybe
06:38:20 <lambdabot> * -> *
06:38:21 <phao> cool =)
06:38:39 <mm_freak_> blendere1: you need to enable building documentation in your ~/.cabal/config
06:38:53 <mm_freak_> documentation: True
06:39:10 <blendere1> mm_freak_: will that retroactively grab all the documentation for me?
06:39:16 <mm_freak_> blendere1: nope
06:40:45 <blendere1> is there something I could do short of reinstalling everything?
06:41:29 <ManateeLazyCat> blendere1: If enable documentation explicitly, it's perhaps waste time if you're a haskell developer.
06:42:18 <mm_freak_> blendere1: reinstall the packages, of which you need documentation
06:42:28 <mm_freak_> or use the online docs on hackage
06:42:58 <blendere1> I was offline all day today. hence the sudden desire to have everything offline
06:43:28 <mm_freak_> well, easiest is to reinstall everything
06:47:42 * hackagebot storable-endian 0.1.0 - Storable instances with endianness  http://hackage.haskell.org/package/storable-endian-0.1.0 (EugeneKirpichov)
06:55:05 <sshc> Does `Control.Monad.STM.atomically' block other threads?
06:55:29 <ManateeLazyCat> sshc: No
06:56:04 <ManateeLazyCat> sshc: STM won't block other thread, but perhaps rollback action if conflict with other threads.
06:56:34 <ManateeLazyCat> sshc: STM is *block-free* concurrent mechanism
07:01:59 <sshc> ManateeLazyCat: Is it safe to create and use a TVar in the IO monad using  (`main = do{var <- atomically (newTVar "foo"); …}')?
07:02:15 <sshc> Or should Tvars only be allocated and used in the same action?
07:03:37 <sshc> Oh, somehow I thought IO could be in an STM action
07:03:56 <Jonno_FTW> @src print
07:03:56 <lambdabot> print x = putStrLn (show x)
07:04:16 <ManateeLazyCat> sshc: Yes, TVar is safe.
07:05:15 <ManateeLazyCat> sshc: If you not use 'atomically', code running in STM action, and STM action won't cause I/O action.
07:05:17 <sshc> Does STM require a function other than `forkIO' to spawn threads?
07:05:52 <mm_freak_> sshc: no
07:05:55 <ManateeLazyCat> sshc: no
07:06:05 <ManateeLazyCat> sshc: forkIO is enough
07:06:17 <sshc> I see
07:06:21 <sshc> Thanks for your help
07:06:30 <mm_freak_> ManateeLazyCat: STM isn't "block-free", it's just "lock-free", but that's an implementation detail, as far as i know
07:06:40 <ManateeLazyCat> sshc: You can read book named "Beautiful Code", i remember have chapter detail of STM
07:06:44 <ManateeLazyCat> mm_freak_: Yes, typo. :)
07:06:49 <mm_freak_> obviously an atomic operation waiting for a value blocks =)
07:06:55 <ManateeLazyCat> mm_freak_: I want type "lock free"
07:07:11 <ManateeLazyCat> mm_freak_: But my English helper always completion other word
07:07:13 <mm_freak_> yeah, thought so, but even then it's just an implementation detail
07:07:58 <ManateeLazyCat> mm_freak_: I use some English helper help me completion English word fastly, but sometimes it's easy cause me type wrong word. :)
07:08:02 <mm_freak_> so you can say, "look, STM in haskell is awesome, wonderful stuff" =)
07:08:30 <ManateeLazyCat> mm_freak_: In most time, i can type faster than native speaker. :)
07:08:49 <mm_freak_> dunno, i don't use a helper
07:09:08 <ManateeLazyCat> mm_freak_: I just need type beginning few characters, then i can completion the word i want type. :)
07:09:14 <mm_freak_> i hate it if my computer tries to be smarter than me
07:09:27 <Jafet> I wouldn't mind if it actually was
07:09:33 <ManateeLazyCat> mm_freak_: I like it, for my bad English. :)
07:09:50 <mm_freak_> well, other than very long words you might still be faster, if you typed the word manually, because using the helper requires some time for thinking, while i just type non-stop
07:10:10 <ManateeLazyCat> mm_freak_: My English helper is real time. :)
07:10:19 <mm_freak_> Jafet: computers aren't smarter, but often companies insist on them /trying/ to be =)
07:11:06 <mm_freak_> ManateeLazyCat: is that helper a manatee package? =P
07:11:35 <ManateeLazyCat> mm_freak_: elisp code at now. I will write haskell code after i finish "script engine" for manatee. :)
07:11:53 <mm_freak_> oh, interesting
07:12:01 <mm_freak_> is it like completion or fully automatic?
07:12:19 <ManateeLazyCat> mm_freak_: Just completion when i want to, not automatic.
07:12:20 <Jafet> Oh, they have their moments. Like when ispell suggests correcting "benzodiazepines" to "sleepinesses".
07:12:24 <zimba> has anyone succeeded in importing ParsecToken or ParsecLanguage?
07:12:34 <ManateeLazyCat> mm_freak_: I can choose continue type and ignore word suggestion.
07:12:46 <ManateeLazyCat> mm_freak_: But it will study my *behaviour* . :)
07:12:56 <mm_freak_> ManateeLazyCat: i see
07:13:11 <mm_freak_> maybe i should write a package 'fasttyping' =P
07:13:12 <ManateeLazyCat> mm_freak_: Like i type mm_freak_  many times, it will remember mm_freak_ , and help me completion it next time. :)
07:13:44 <Jafet> Of course, you'll try the autocomplete on the day he's mm_freak
07:13:49 <ManateeLazyCat> mm_freak_: I more like write some package to correct my English syntax in real time, if i have time. :)
07:16:39 <mm_freak_> well, i could think of an interesting autocompletion concept, which isn't too intrusive
07:17:24 <mm_freak_> if you type some letters, which belong unambiguously to a word, then this word is completed and the editor switches to overwrite mode, until you either type different characters or hit enter to accept the current word
07:17:46 <mm_freak_> i think openoffice does it that way…  i found that useful sometimes
07:18:06 <ManateeLazyCat> mm_freak_: yes, my elisp code use Emacs' override attribute.
07:18:19 <Jafet> Obviously not. A yellow scrolling popup box should open
07:18:45 <ManateeLazyCat> mm_freak_: Use highlight area display completion part, completion part will change along with your input.
07:20:11 <earthy> manateelazycat: you *do* realize that a. checking the syntax of english is a hard problem b. there's open source software to do full-sentence syntactical analysis of english?
07:21:07 <Jafet> You want to type in a whole sentence of partial words and then have a program try to figure out if it interpolated the remaining letters correctly?
07:21:11 <Jafet> ...sounds like compiling.
07:21:21 <earthy> jafet: :)
07:21:27 <blendere1> "you do realize" always comes of as an overly smug way to start a sentence
07:21:41 <earthy> my apologies
07:22:09 <earthy> however, I've tried doing the syntax checking thing... and it *is* hard. :)
07:23:04 <ManateeLazyCat> earthy: Nothing is impossible, i just need finish those think one by one.
07:23:18 <earthy> jafet: basically what you could do is restrict the completion options to only those from the lexicon that would syntactically fit given the already typed words
07:23:50 <earthy> you could even annotate the completion options with syntactic markers for that word and all the previous ones
07:23:54 <ManateeLazyCat> I got new Lenovo notebook, need to go...
07:24:04 <earthy> (think about sentences like   the horse raced past the barn fell   )
07:24:39 <benmachine> I don't think I like the sound of "intelligent" completion mechanisms
07:24:52 <Jafet> And the other horse raced to the Vvardenfell
07:24:59 <benmachine> well, for IRC at least, it would be ncie if the mechanism was predictable and understandable
07:25:10 <ManateeLazyCat> Bye all. :)
07:25:13 <benmachine> it always annoys me when I press tab on an empty field in irssi and it comes up with the most irrelevant nonsense
07:25:16 <earthy> manateelazycat: look at www.agfl.cs.ru.nl for a grammar of english
07:25:52 <earthy> benmachine: ah yes.
07:27:34 <red32> ?
07:27:44 <benmachine> !!
07:28:17 * Jafet draws red squiggly lines underneath those
07:28:22 <earthy> another interesting tidbit: IRC conversations use a language somewhat unlike ordinary written english
07:29:13 <opqdonut> who'd'a thunk it
07:29:21 <monadic_kid> still having problems with lazyniess :(
07:29:43 <Jafet> Of course. It's typed, for one thing
07:30:22 <mm_freak_> benmachine: if you press tab in an empty field irssi assumes that you want to write a reply to the most recent query
07:30:33 <mm_freak_> benmachine: if you tab again, it goes to the second most recent
07:31:05 <mm_freak_> i find this very useful, because for short chats i don't open a query window, but use the messages window instead
07:31:47 <earthy> opqdonut: it's actually so bad that a parser that can do 80% of the sentences in a book (which for natural language parsing is a *good* score), may just be able to do 30% of those on IRC
07:32:04 <earthy> if that
07:32:06 <benmachine> mm_freak_: hmm. I use query windows all the time, worksforme >_>
07:32:21 <Jafet> earthy: surely that depends on which channel you're in.
07:32:30 <earthy> jafet: yes and no
07:32:34 <mm_freak_> benmachine: what would want it to do instead?
07:32:40 <mm_freak_> +you
07:33:10 <benmachine> mm_freak_: I guess that's okay
07:33:10 <Twey> earthy: Really?  My language on IRC and my language in real-life conversations are not very different.
07:33:14 <earthy> there's all sorts of things that trip up parsing: incorrect punctuation, discourse markers such as 'nick:', smileys...
07:33:24 <Jafet> It should run an arbitrary perl script! Wait, I guess it can do that already.
07:33:27 <benmachine> mm_freak_: but nick-tab completion is quite often difficult to predict, imo
07:33:53 <mm_freak_> benmachine: yes, because it uses windows-cmd style completion, where i would prefer it to use shell style
07:34:07 <earthy> twey: spoken language is a *lot* harder to parse than written language, as it is *much* more context dependent
07:34:17 <benmachine> well yes, but also the order in which it cycles through things
07:34:38 <benmachine> is just plain weird
07:34:47 <mm_freak_> benmachine: it orders by activity…  as soon as you get the feel for it, it's actually quite great
07:35:01 <mm_freak_> for me it often hits the right nick even in very full channels
07:35:11 <mm_freak_> right with the first tab stroke
07:35:23 <benmachine> the first tab stroke is good
07:35:32 <Jafet> (If it doesn't, do you continue anyway?)
07:35:34 <benmachine> but if that's *not* what you want it can be confusing
07:36:02 <benmachine> in general irssi tries to guess what you want and often gets it right
07:36:10 <mm_freak_> well, i usually try to /make it/ hit the first time =)
07:36:35 <benmachine> but because it uses a lot of information to do so, when it's wrong you can't work out why
07:36:36 <mm_freak_> for example i know when i type only 'b' and press tab, it will come up with 'benmachine', even though there are many other b* nicks here
07:37:16 <benmachine> when I press t and then tab, it gives me the name of the person who just joined instead of the person who's actually been talking
07:37:38 <benmachine> which is sometimes what I want
07:37:41 <benmachine> and sometimes isn't
07:38:16 <mm_freak_> yeah, that's unfortunate
07:38:21 <benmachine> well anyway
07:38:23 <benmachine> I admit
07:38:25 <mm_freak_> it assumes that recently joined people are active
07:38:29 <benmachine> I didn't realise how clever it was :P
07:38:37 <benmachine> but I still in principle don't like DWIM type things
07:38:48 <Jafet> It could learn which people tend to be active recently after joining
07:38:51 <mm_freak_> but my brain keeps track of it, so it doesn't happen often for me…  after all i use irssi for many years now
07:38:58 <benmachine> Jafet: woo, more overhead
07:39:07 <mm_freak_> Jafet: no, because that would make it less predictable
07:39:38 <mm_freak_> irssi's completion is a bit more complicated than straightforward alphabetic completion, but it's designed to be still predictable by humans
07:40:30 <Jafet> That reminds me, does lambdabot have a way to prefix a nick on command output?
07:41:01 <Jafet> While you people are busy figuring out how to type the nicks faster, I prefer to type just the nick and let a program do the rest
07:41:40 <Twey> earthy: Oh, written English.  Right.
07:41:52 <Twey> earthy: Yes, of course.  IRC is a conversation medium, not an essay.
07:42:02 <Twey> It stands to reason that it would use spoken language.
07:42:05 * earthy nods
07:42:58 <earthy> it's just surprising how large the delta is
07:43:18 <benmachine> kind of
07:43:24 <benmachine> if you look at previous sentences here
07:43:47 <benmachine> how many are actually complete phrases
07:43:56 <benmachine> or whatever
07:44:08 <Twey> Being as ‘phrase’ has no real definition, probably all of them ;)
07:44:12 <earthy> oh, actually, phrase parsing is easier than full sentence parsing. :)
07:44:16 <Twey> ‘Sentence’ maybe
07:44:28 <earthy> if you look at noun phrases and their ilk
07:44:39 <Twey> Yeah
07:44:50 <Twey> It can sometimes be difficult to tell what's what, though
07:45:01 <Twey> ‘Time flies like an arrow’, and all that
07:45:29 <earthy> yah, that can only be solved probabilistically
07:45:32 <benmachine> they do like their arrows
07:45:53 <earthy> using part of speech probabilities in a lexicon
07:47:02 <Twey> Which is halfway to purely statistical translation à la Google Translate
07:47:57 <earthy> actually, no
07:47:59 * hackagebot Hsed 0.1 - Stream Editor in Haskell  http://hackage.haskell.org/package/Hsed-0.1 (VitaliyRukavishnikov)
07:48:29 <earthy> because the probabilities can be forced if the sentence does not parse otherwise
07:48:43 <earthy> which is harder in purely statistical parsing
07:49:22 <Twey> True
07:50:07 <benmachine> you make a compromise at some point anyway though
07:50:16 <benmachine> because not even the people who invented the language can do it perfectly
07:50:27 <monadic_kid> yeah so still having issues with lazyniess, "map updateAnim" never gets evaluated: http://haskell.pastebin.com/5yJbBqee
07:51:15 <Twey> monadic_kid: Why does that matter?
07:51:39 <Twey> If it never gets evaluated, it's because it never needs to be evaluated
07:52:20 <benmachine> how can you even tell :P
07:53:10 <monadic_kid> Twey: it doesn't quite work like that, that function is beening used in parent function for which is mostly evaluated up to the point
07:54:05 <Twey> monadic_kid: Do you mean that it *is* evaluated, but much later than you'd like?
07:54:18 <benmachine> how do you tell
07:56:24 <monadic_kid> Twey: where I stick trace functions into calls of modL I see an evaluation, if i use map which calls trace further down it never gets evaluated, I never see any observable effect
07:56:47 <benmachine> monadic_kid: but what's the problem?
07:56:53 <benmachine> performance?
07:57:19 <monadic_kid> benmachine: no, I never get a nested call evaluated
07:57:32 <benmachine> ...so?
07:57:55 <monadic_kid> benmachine: it's suppose
07:57:59 <monadic_kid> benmachine: tp
07:58:10 <blendere1> ls
07:58:20 <blendere1> :/
07:58:27 * benmachine hugs blendere1 
07:58:33 <earthy> .: unreadable
07:58:35 <benmachine> monadic_kid: why
07:59:09 <aristid> earthy: no, .: is not unreadable
07:59:09 <lambdabot> aristid: You have 1 new message. '/msg lambdabot @messages' to read it.
07:59:55 <monadic_kid> benmachine: because I do need lazyniess here, I don't want part of my computation to be evaluated and the rest to be unevaluated, this is no the behaviour I want
08:00:03 <azaq23> > [() .. ()]
08:00:04 <lambdabot>   [()]
08:00:12 <monadic_kid> benmachine: I mean i don't want layzniess here
08:00:18 <benmachine> monadic_kid: but the whole point of laziness is you can't actually tell the difference
08:00:31 <benmachine> it behaves the same
08:00:35 <benmachine> unless it doesn't
08:00:40 <benmachine> does it?
08:00:41 <aristid> @tell ManateeLazyCat Please also link the music-free version from your Wiki page, because it cannot be found elsewhere. Actually, someone on IRC pointed me to that version already, but I didn't find it on the web.
08:00:41 <lambdabot> Consider it noted.
08:01:58 <monadic_kid> benmachine: this isn't really helping me, my function never gets evaluated so my states don't change and I don't get state changes
08:02:28 <benmachine> monadic_kid: if your states don't change it's not because of laziness
08:02:37 <benmachine> it's because you're not using the new state
08:04:31 <monadic_kid> benmachine: that's not true, I'm using it every frame. I've already fixed most of speaking to someone else I've added it using strictness annotations and change my monad transformer stack to use a strict state monad
08:06:10 <benmachine> monadic_kid: if a lazy and strict evluation of a function both come up with an answer, they come up with the same answer
08:06:26 <benmachine> if a function is not being evaluated in your code, it's because you're not using its result
08:06:36 <benmachine> in which case whether or not it is evaluated is irrelevant
08:07:04 <benmachine> I'd like to give more specific help but I don't know what modL, entities, etc. are
08:08:03 <benmachine> or what an EventHandler is
08:08:05 <benmachine> etc.
08:08:31 <benmachine> but laziness is *not* supposed to change the result of a function - i.e. the behaviour of your program
08:09:00 <Jafet> Well, I'd use a more specific term than behaviour
08:09:03 <monadic_kid> benmachine: you might be right it'st still issue to do with layzniess, basically i'm using a function some where that is lazily evaluated when it should be strict and thus like you say it's never needed.
08:09:33 <benmachine> monadic_kid: it's not an issue to do with laziness, if it's never needed then it still wouldn't be needed if it was evaluated strictly
08:09:39 <benmachine> the result would be evaluated and then discarded
08:09:58 <benmachine> and since haskell is pure, the result being evaluated would have no other effect
08:10:13 <monadic_kid> anyway
08:10:24 <revenantphx> So, what was that url for iteratees last night?
08:10:29 <revenantphx> I need a good thing to read on them.
08:11:43 <monadic_kid> i'm suspecting it might be the actions i'm using in fclabels, I'd assume that getM/setM/modM should use which ever version of MonadState  is being used?
08:11:57 <benmachine> revenantphx: from this http://tunes.org/~nef/logs/haskell/10.12.21 I found http://docs.yesodweb.com/blog/enumerators-tutorial-part-1/
08:12:14 <revenantphx> ty
08:13:29 <FunctorSalad> is this a bug in 'network'? this works: (connectTo "l" (PortNumber 6600)) , this doesn't: (connectTo "localhost" (PortNumber 6600)); both "l" and "localhost" are /etc/hosts aliases for 127.0.0.1
08:13:52 <FunctorSalad> (either works with netcat)
08:13:57 <monadic_kid> looks like fclabels does use MonadState from Lazy package: http://hackage.haskell.org/packages/archive/fclabels/0.11.1.1/doc/html/src/Data-Record-Label-Monadic.html#setM
08:17:02 <Guest43961> [42,13,22]
08:17:25 <monadic_kid> ah ignore what i wrote that is not right
08:17:49 <Guest43961> hi there
08:17:51 <benmachine> FunctorSalad: possibly. what does Network.BSD.getHostByName say?
08:17:58 <benmachine> Guest43961: hi
08:18:18 <Guest43961> i m pretty new to programming and i wana 
08:18:25 <roconnor> isn't the lazy state monad the default one?
08:18:29 <Guest43961> learn it but dont know where to start
08:18:49 <benmachine> Guest43961: are you using tryhaskell
08:18:55 <Guest43961> yes
08:18:59 <benmachine> good start :)
08:19:23 <Guest43961> thanx
08:19:40 <monadic_kid> roconnor: yes, but MonadState instances are defined in the Lazy/Strict module so it looks like as long as your using Strict.State/T it should use that instance and not the lazy one, i don't think fclabels is picking the wrong one, at least i don't think it is
08:21:09 <benmachine> monadic_kid: do you still not believe me :P
08:21:15 <roconnor> monadic_kid: setM doesn't use the monadState instance, it only uses the MonadState class.
08:21:29 <FunctorSalad> benmachine: hmm somewhat different results... http://hpaste.org/42494/gethostbyname_results
08:21:35 <monadic_kid> benmachine: I don't believe or disbelieve, it's just not helping me much
08:21:43 * roconnor also wonders why fclables is more popular that data.accessor.
08:21:47 <danr> Guest43961: you can also proceed with the page http://www.learnyouahaskell.com/
08:21:47 <monadic_kid> roconnor: yes that is what i meant
08:22:05 <FunctorSalad> benmachine: the two equal hostAddresses for 'localhost' look a bit suspicious (but I have no real clue)
08:22:37 <benmachine> FunctorSalad: honestly I have no real clue either, I just thought it might be illuminating
08:23:04 <benmachine> monadic_kid: what's EventHandler?
08:23:08 <FunctorSalad> benmachine: it is somewhat, didn't know about the function :) (connectTo uses it?)
08:23:21 <bartavelle> is there a way to know where ghci was when you press ctrl-c ?
08:23:49 <roconnor> monadic_kid: setM should work with both lazy and strict state monads.  The being said, after a quick review of your conversation wiht benmachine, he is right.  If you have a bug it isn't due the lazy/strict state monads.  The difference between lazy/string will only affect performance, not functionality.
08:24:14 <benmachine> FunctorSalad: I'm not sure, I'll have a look at the source
08:25:06 <benmachine> FunctorSalad: seems it uses getAddrInfo, from Network.Socket
08:25:17 <monadic_kid> roconnor: it's not a bug, I'm just not getting my code evaluated soon enough, I've added trace calls at various points and it gets invoked where I expect it too but further down i don't see my trace calls
08:25:32 <sleepynate> has anyone started a "learn haskell the hard way" ala Zed Shaw type endeavor?
08:25:32 <roconnor> monadic_kid: so it is a performance issue only?
08:25:59 <roconnor> sleepynate: what is special about Shaw's tutorial?
08:26:29 <benmachine> FunctorSalad: http://hackage.haskell.org/packages/archive/network/2.3/doc/html/src/Network.html#connectTo
08:26:41 <monadic_kid> roconnor: no, I'm just trying to get part of computation to be computated
08:26:42 <benmachine> maybe you could check to see where it's going wrong there
08:26:54 <ClaudiusMaximus> :t readFloat
08:26:55 <lambdabot> forall a. (RealFrac a) => String -> [(a, String)]
08:27:02 <ClaudiusMaximus> :t readsPrec
08:27:02 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
08:27:07 <tux_mark_5> hello
08:27:32 <ClaudiusMaximus> any easy way to implement readsPrec using readFloat for my custom number type?
08:28:00 <roconnor> monadic_kid: if it is a functionality issue, switching to a strict state monad won't fix it.
08:28:15 <sleepynate> roconnor: 2 things stand out.. he makes a good effort at explaining "doing" without overexplaining "why", which is a failing of a lot of haskell stuff (except perhaps lyah). however, he also pairs this with trivial tasks to complete that are rather unbounded, without completely walking you through each step (such as an Haskell Road to Logic, or the on that danish guy from MS did)
08:28:17 <benmachine> ClaudiusMaximus: readsPrec _ = readFloat? :P
08:28:20 <tux_mark_5> i have function "foo :: a -> a"; is there a way to write special case when a == Int?
08:28:35 <roconnor> monadic_kid: again, strict vs lazy state only affects performance, not the final outcome.
08:28:40 <ClaudiusMaximus> benmachine: sure, types match - but is that correct? :)
08:28:46 <sleepynate> roconnor: zed's book is not unique to programming books at all, there's a lot out there lik it, i just have yet to see a haskell-oriented one
08:29:33 <benmachine> ClaudiusMaximus: I'm not sure, but it might well be. the tricky part is handling the precedence argument, but if the thing you are reading is entirely one token, you might well be safe to ignore it
08:29:57 <monadic_kid> roconnor: okay let me rephrase that there could be a bug, i'm not seeing all of my state changes that i'm expecting that is why i started to add trace calls to this function where modL calls are, I don't see a trace all the way down the point where I'm interested
08:29:57 <roconnor> sleepynate: ironically haskell programming is all about the why and not so much about the doing :P
08:30:03 <sleepynate> roconnor: and that happened to be the first that came to mind... SICP does the same thing, if a bit out of date
08:30:22 <roconnor> monadic_kid: then it is due to some bug in your code.
08:30:23 <sleepynate> roconnor: this is true, but here's why i bring it up
08:30:31 <roconnor> sleepynate: :)
08:30:45 <sleepynate> i teach python at our hackerspace from children 8 to 88
08:31:13 <sleepynate> now, i have no problem coming up with good resources to be like: "OK! We're gonna make a twitter client!"
08:31:18 <benmachine> monadic_kid: what's EventHandler?
08:31:21 <sleepynate> or "We're gonna make a gui calculator"
08:31:24 <sleepynate> etc etc
08:31:41 <sleepynate> however, our more hardcore want to learn haskell
08:31:43 <roconnor> sleepynate: where is your hackerspace?
08:31:54 <sleepynate> All Hands Active in Ann Arbor, MI
08:32:00 <monadic_kid> roconnor: yes but even when i disable that part which could be buggy, I'm not seeing traces further down
08:32:42 <monadic_kid> benmachine: http://haskell.pastebin.com/CCeVxHy5
08:32:43 <sleepynate> roconnor: but it's hard to get unitized lessons on how things work that actually have some kind of product at the end, preferably that's rather self-driven
08:32:51 <roconnor> monadic_kid: well becareful what you disable.  If you disable the part of the program that demands the results that you are trying to trace, they won't be evaluated.
08:34:08 <roconnor> sleepynate: I want a hackerspace too! :D  That looks great
08:34:28 <sleepynate> roconnor: the real antics are on the facebook group
08:34:38 <sleepynate> but yea
08:34:47 <sleepynate> (i'll not get in to how i feel about that)
08:35:00 <sleepynate> Pumping Station: One has a haskell class and we're jealous
08:35:27 <roconnor> Pumping Station?
08:35:34 <sleepynate> (chicago hackerspace)
08:35:34 <benmachine> monadic_kid: you're not using the monadic features of fclabels at all?
08:35:55 <monadic_kid> benmachine: I am
08:35:56 <sleepynate> now, creating something like twidge in haskell is relatively trivial, even with a fail-fool at haskell such as myself
08:36:14 <monadic_kid> benmachine: not in the code i've shown
08:36:24 <benmachine> monadic_kid: well I can only help you with code that I see :P
08:36:27 <sleepynate> but our resident haskell expert is having a hard time "breaking things down" into something we can teach
08:36:50 <roconnor> sleepynate: I see.
08:36:57 <sleepynate> every haskell resource is very "pure fp programming" or math oriented
08:37:17 <roconnor> such is the nature of programming with types :D
08:37:24 <sleepynate> which is awesome... but really you COULD put everything in main = do, despite however many people here might pull out their hair ;)
08:37:40 <benmachine> @quote imperative
08:37:40 <lambdabot> IceDane says: [on escaping an imperative mindset]: <kmc> i recommend heavy drinking <IceDane> I've tried that. I just have fun and wake up and feel like shit the day after. but still think in loops.
08:37:51 <benmachine> hmm
08:37:55 <benmachine> not what I was looking for
08:38:25 <sleepynate> so, roconnor, i'm looking a kind of "let's get shit done and learn as much haskell as possible along the way" type of resource
08:38:37 <sleepynate> roconnor: example -- snake wranglinng for kids
08:38:45 <sleepynate> or "how to think like a computer scientist"
08:38:46 <benmachine> there was that one for writing a scheme interpreter wasn't there?
08:38:57 <monadic_kid> sleepynate: real world haskell?
08:38:59 <sleepynate> benmachine: more on the fun, less on the compsci
08:39:07 <benmachine> sleepynate: heh :(
08:39:15 <benmachine> what are you implying about compsci!!
08:39:19 <benmachine> but yes I see what you mean
08:39:20 <roconnor> sleepynate: I presume you've looked at Real World Haskell
08:39:33 <sleepynate> roconnor: yea, it's a bit long on the topic
08:39:35 <monadic_kid> benmachine: i'd have post a lot of code then, to see all the relevant bits
08:39:58 <sleepynate> roconnor: i personally loved it, but it's a hard resource to go over if people have little other experience in the lang
08:40:13 <roconnor> ya, I haven't read it myself :D
08:40:19 <chturne> The "haskell school of expression" is pretty good
08:40:23 <sleepynate> benmachine: and i teach compsci -- i'm implying that people get bored with it
08:40:27 <roconnor> sleepynate: sorry, I don't think I can help you. :(
08:40:37 <sleepynate> chturne: true... but i'd say it's "over-mathy"
08:40:54 <roconnor> It's hard to be overmathy with haskell
08:40:58 <revenantphx> The more I look at options for parsing... the more I'm seeing that combining Binary, attoparsec, and maybe iteratees seems to be the best option.
08:41:17 <revenantphx> Attoparsec lacks facilities for parsing out fixed size integer types and so on, Binary can readily provide those.
08:41:17 <roconnor> If you are turned off math then you probably shouldn't be programming in Haskell (or any other languge IMHO).
08:41:29 <chturne> sleepynate: It's not all like that, you can focus on the more practical parts of the book if you desire, imo.
08:41:34 <sleepynate> roconnor: well, you have to bait them!
08:41:47 <roconnor> :)
08:41:48 <roconnor> ok
08:41:54 <sleepynate> roconnor: you have to keep them interested in haskell long enough to learn the math behind it
08:42:02 <roconnor> sleepynate: teach them agda first, then Haskell will be a breaze
08:42:24 <sleepynate> this is why when we teach python we don't start with "derive a class from TkWidget"
08:42:38 <sleepynate> we "print 'Hello World!'"
08:42:42 <sleepynate> etc etc
08:42:51 <roconnor> Actually I kinda think CS courses should with Agda .
08:42:58 <unkanon_> roconnor: or any other language? wow, that's a strong statement
08:43:06 <roconnor> unkanon_: I'm opinionated
08:43:20 <sleepynate> hmm
08:43:22 <unkanon_> I noticed
08:43:47 <sleepynate> roconnor: do you see my quandry though?
08:44:29 <roconnor> sleepynate: I don't think I caught your quandry.  It seems you are missing a tutorial in Haskell to hook people.
08:44:35 <sleepynate> how do you pull in someone in the 15-30 range with enough "fun stuff" without learning the boring end of what's a thunk or a monad and why we lift
08:45:03 <roconnor> sleepynate: have you looked at Helium and it's resources?
08:45:10 <aristid> sleepynate: it's not boring IMO
08:45:14 <roconnor> *its
08:45:18 <revenantphx> sleepynate: Well, Haskell requires a certain level for masochism.
08:45:25 <sleepynate> aristid: yes, but you and i are nerds :P
08:45:29 <ClaudiusMaximus> benmachine: it fails for parenthesis and/or negative numbers
08:45:39 <ClaudiusMaximus> > read "(-(1))" :: Double
08:45:40 <lambdabot>   -1.0
08:45:40 <sleepynate> revenantphx: also true 8)
08:45:45 <aristid> sleepynate: yeah, i'm very much of a nerd
08:45:53 <aristid> sleepynate: i take your word that you are, too :)
08:45:59 <benmachine> > readFloat "(-10)" :: Double
08:45:59 <sleepynate> roconnor: i haven't
08:46:00 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
08:46:00 <lambdabot>         against inferred ty...
08:46:21 <benmachine> oh right
08:46:24 <benmachine> > readFloat "(-10)"
08:46:24 <lambdabot>   []
08:46:29 <benmachine> hmm
08:46:40 <ClaudiusMaximus> > head . map fst . readFloat $ "(-10"
08:46:41 <lambdabot>   *Exception: Prelude.head: empty list
08:46:42 <revenantphx> If no one has coined it yet, I'd like to point out the paradox that the people who are most masochistic, and therefore most amicable to learning Haskell, are the same people who are so entrenched in imperative programming that it is difficult for them to learn Haskell... C programmers.
08:46:44 <ClaudiusMaximus> > head . map fst . readFloat $ "(-10)"
08:46:45 <lambdabot>   *Exception: Prelude.head: empty list
08:46:46 <roconnor> sleepynate: Helium is a light weight Haskell-like language developed for teaching purposes
08:46:56 <ClaudiusMaximus> > head . map fst . readFloat $ "(-10)" :: Double
08:46:57 <lambdabot>   *Exception: Prelude.head: empty list
08:46:57 <sleepynate> hah-so
08:46:58 <unkanon_> > readFloat "-10.0"
08:46:58 <lambdabot>   []
08:47:05 <revenantphx> GHC Haskell is like big boy haskell.
08:47:08 <revenantphx> I'm a big boy too~
08:47:09 <benmachine> > readFloat "10.01"
08:47:10 <lambdabot>   [(10.01,"")]
08:47:12 <roconnor> sleepynate: http://en.wikipedia.org/wiki/Helium_%28Haskell%29
08:47:24 <sleepynate> roconnor: can you teach it on ghc? or do we need them to have their own instances?
08:47:24 <revenantphx> >readFloat "-10.01"
08:47:26 <roconnor> sleepynate: I don't know much about it, but maybe it has some nice resources associated with it.
08:47:33 <revenantphx> > readFloat "-10.01
08:47:34 <lambdabot>   <no location info>:
08:47:34 <lambdabot>      lexical error in string/character literal at end o...
08:47:37 <revenantphx> > readFloat "-10.01"
08:47:38 <lambdabot>   []
08:47:40 <sleepynate> ok, awesome
08:47:51 <roconnor> sleepynate: helium will have it's own interpreter
08:48:11 <unkanon_> > readFloat "- 10.0"
08:48:13 <revenantphx> Helium is a good tool to learn how to lift monads :D.
08:48:15 <lambdabot>   []
08:48:17 <revenantphx> ba dum kish.
08:48:21 <sleepynate> roconnor: sure... it's just easier to install one of them and have them use shells on our blade
08:48:24 <roconnor> sleepynate: apparently it has an intepreter written in Java
08:48:28 <sleepynate> ahh
08:48:32 <ClaudiusMaximus> thanks - looks like i'll figure out something from GHC.Read.readNumber 
08:48:34 <benmachine> ClaudiusMaximus: hmm, see also: readParen, readSigned
08:48:45 <revenantphx> > readSigned "-10"
08:48:45 <lambdabot>   Couldn't match expected type `GHC.Base.String
08:48:45 <lambdabot>                              ...
08:48:52 <sleepynate> not perfect, but still a fantastic rabbit-trail. thanks roconnor 
08:48:56 <benmachine> > readSigned readFloat "-10.0"
08:48:57 <lambdabot>   [(-10.0,"")]
08:49:30 <benmachine> readParen is a bit tricky because it's not readOptionalParen
08:49:38 <monadic_kid> roconnor: something I didn't point out before when I just set a particular value and then later on print it out i don't see a change but another value which gets transformed in the same function does change
08:49:38 <benmachine> but you can work that out manually I think
08:49:39 <roconnor> sleepynate: be big benifit of Helium from what I can tell is no obtuse messages about No instances of Num (a -> b)
08:50:06 <sleepynate> oh good
08:50:13 <roconnor> monadic_kid: this is due to a bug in your code, not due to any lazy/strict issue.
08:50:58 <sleepynate> see it's shit like that that requires a 20-minute divergence from what you're meaning to talk about
08:51:17 <benmachine> monadic_kid: the most likely explanation is that you're using the wrong state somewhere, e.g. modifying state1 to produce state2 and then state1 to produce state3 and using state3, discarding state2
08:51:56 <benmachine> monadic_kid: this kind of error can't easily be caught by the type system, but is less likely if you use monadic style (modM etc.)
08:52:28 <monadic_kid> roconnor: the part of that function (the one i posted) which could be buggy, i've commented it out and just set a particular value where another part of the same record gets modified and I see that change but not the one I just set for debugging purposes
08:53:15 <roconnor> monadic_kid: can you paste the link again for me?
08:53:56 <monadic_kid> it's updateAnim that is suspect: http://haskell.pastebin.com/5yJbBqee
08:54:16 <roconnor> sleepynate: it's easier for non-programmers who don't even know what evaluation is, and hence won't be confused by the issue
08:54:28 <roconnor> sleepynate: teaching Haskell to people with programming experience is much harderr
08:54:53 <sleepynate> naturally
08:55:16 <sleepynate> i know it still throws me for a loop all the time switching mindsets
08:55:50 <sleepynate> my other thought was adapting some of the more "fun" lisp/scheme resources out there
08:56:04 <sleepynate> there's actually a new one out there called "Land of Lisp" that's adorable
08:56:14 <unkanon_> sleepynate: have you read it already?
08:56:30 <sleepynate> unkanon_: i'm 65%-ish through it
08:57:01 <unkanon_> sleepynate: thoughts? (besides being adorable)
08:57:02 <sm> +1, translate that
08:57:02 <edwardk> sleepynate: there is one in a similar tone for haskell: Learn You a Haskell for Great Good
08:57:32 <sleepynate> edwardk: read the backlog ;)
08:57:32 <roconnor> monadic_kid: I can't help but notice that the state monad isn't used here at all.
08:57:39 <edwardk> sleepynate: ah
08:58:03 <unkanon_> edwardk: lyah feels more like a tour of haskell, whereas I think land of lisp goes through creating several different programs, but maybe I'm wrong
08:58:13 <sm> does LYAH contain a bunch of fun standalone examples, eg games ? I don't think so
08:58:25 <edwardk> unkanon_: fair nuff
08:58:30 <sm> it's pretty, but actually reads like a chatty textbook
08:58:33 <sleepynate> unkanon_: its primary advantage is it is goal oriented, and explains the "how" of using lisp and leaves a lot of things around like "don't worry about that, we'll get to it in chapter 7"
08:59:07 <sleepynate> unkanon_: so, he doesn't let things like why you preface a function name with #' when using a higher-order function get in the way of explaining how a map works
08:59:23 <sleepynate> or more importantly, why you're using a map in that situation anyways
08:59:26 <edwardk> maybe i'm broken. i just prefer a textbook to tell me what all the parts are and then the puzzle to me is how to assemble them in interesting ways. i never liked goal directed textbooks. ;)
08:59:32 <monadic_kid> roconnor: yeah this function is stored in a map and gets called at intervals, the map is stored in a record I used in a state monad, it gets run in an action i haven't posted, I'd have to start copy and pasting various bits to give more context
08:59:55 <revenantphx> What's the easiest way in haskell to represent a bounded sum?
09:00:08 <revenantphx> like for some number n,
09:00:10 <paolino> @src sum
09:00:10 <lambdabot> sum = foldl (+) 0
09:00:28 <revenantphx> n/5 + n/25 + n/125 ... n/5^n
09:00:38 <edwardk> revenantphx: a sum that is no larger than some number? or a sum of no more than n items?
09:00:39 <sleepynate> unkanon_: so, the big thing is he explains the making of a game in the context of LISP and FP, without letting the syntax or FP get in the way
09:00:45 <revenantphx> edwardk: see above.
09:00:48 <paolino> :t sum
09:00:49 <lambdabot> forall a. (Num a) => [a] -> a
09:00:54 <edwardk> ah
09:01:00 <jmcarthur> :t \f n -> sum $ map f [1..n]
09:01:01 <lambdabot> forall a a1. (Num a, Num a1, Enum a1) => (a1 -> a) -> a1 -> a
09:01:03 <unkanon_> sleepynate: I see, that sounds cool, I might have to get that. did you get to where it covers macros yet?
09:01:19 <paolino> mh, how 0 is Num ?
09:01:24 <jmcarthur> :t 0
09:01:25 <lambdabot> forall t. (Num t) => t
09:01:26 <jmcarthur> it just is
09:01:30 <revenantphx> :t 1
09:01:31 <lambdabot> forall t. (Num t) => t
09:01:31 <sleepynate> i think so, i haven't had a chance in about two weeks
09:01:40 <sleepynate> lemme fire up yonder kindle
09:01:47 <jmcarthur> paolino: integer literals implicitly have fromInteger applied to them
09:01:56 <paolino> ah fromInteger
09:02:03 <revenantphx> Basically I'm wondering how to represent sums like that...
09:02:04 <paolino> sum shouldn't use it
09:02:24 <jmcarthur> shouldn't use what?
09:02:30 <paolino> fromInteger
09:02:33 <jmcarthur> why not?
09:02:37 <unkanon_> sleepynate: I was just wondering what you thought of the macros coverage
09:02:55 <sleepynate> i don't think he got that in-depth yet
09:02:58 <jmcarthur> revenantphx: i gave you a solution already
09:03:10 <revenantphx> Oh, sorry. Didn't see that.
09:03:12 <jmcarthur> revenantphx: sum $ map f [1..n]
09:03:15 <paolino> jmcarthur: think of dimensioned numbers
09:03:28 <sleepynate> i know he explained the difference of the expansion of macros as LISP code by the interpreter
09:03:35 <jmcarthur> paolino: fromIntegral 0 = (0, 0, 0) ?
09:03:49 <sleepynate> unkanon_: but i think he doesn't explain the creation of your own macros until later
09:03:51 <paolino> you can sum them as long as they have the same dimension
09:03:56 <jmcarthur> right
09:03:56 <roconnor> @type mapAccumL
09:03:57 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:04:05 <jmcarthur> paolino: i'm failing to see the problem here though
09:04:34 <paolino> but fromInteger would create a no dimensioned number
09:04:43 <jmcarthur> no
09:04:47 <paolino> *Main> sum $ replicate 15 $  g / 15
09:04:49 <paolino> GuessedQuantity {meanQuantity = *** Exception: summing apples and pears
09:05:18 <roconnor> monadic_kid: I think I found your bug
09:05:24 <paolino> *Main> g / 15 + g / 15
09:05:26 <paolino> GuessedQuantity {meanQuantity = Quantity {value = 8 % 15, qdim = [(1,Chilogrammo)]}, errore = Quantity {value = 1 % 15, qdim = [(1,Chilogrammo)]}}
09:05:26 <jmcarthur> paolino: say you have a Vector3D type. the Num instance would define fromIntegral like this:    fromIntegral n = let x = fromIntegral n in Vector3D x x x
09:05:28 * hackagebot timeplot 0.2.15 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.15 (EugeneKirpichov)
09:06:10 <sleepynate> but i have to say, i'd been reading it from the primary point of teaching FP to young'uns, not from how in-depth it is with LISP
09:06:16 <jmcarthur> paolino: so fromInteger would create a 3D vector as expected
09:06:23 <unkanon_> sleepynate: well as long as it's explained somewhere in the book, it's fine
09:06:25 <paolino> jmcarthur: that's a vector, not a dimensioned number
09:06:34 <sleepynate> unkanon_: how could it not be? :D
09:06:40 <jmcarthur> okay i must be hitting a terminology wall then
09:06:52 <allbery_b> can I note that sum doesn't use fromIntegere anyway?  It wants a Num a => a
09:06:53 <unkanon_> sleepynate: I know, right? I was just making sure
09:06:58 <monadic_kid> roconnor: cool, hit me !
09:07:02 <jmcarthur> allbery_b: it does because it uses 0 in the definition
09:07:06 <revenantphx> jmcarthur: wait, how can I get the 'n' value in there though?
09:07:08 <roconnor> #
09:07:08 <revenantphx> I need the current index.
09:07:09 <roconnor>        updateAnim entity
09:07:11 <roconnor> #
09:07:12 <roconnor>             | isGOType GOTEnemy entity = modL (sheetDataList . sprites) (snd . mapAccumL nextAnim 0) entity
09:07:14 <roconnor> #
09:07:15 <roconnor> ah sorry
09:07:17 <roconnor> I thought it was 2 lines
09:07:18 <jmcarthur> revenantphx: the function f uses it
09:07:25 <paolino> jmcarthur: a dimensioned number is 1 kg/m
09:07:33 <sleepynate> unkanon_: if it isn't, i'll be sending some angry letters. this Barski fellow has got me on high hopes for something I can use in the teen crowd
09:07:34 * Fargeee http://imagetwist.com/e1ubou2tvag6/156897_168406319867731_100000950924332_325446_5758311_n_1_.jpg.html
09:07:39 <jmcarthur> paolino: oh so you mean units?
09:07:50 <allbery_b> nevertheless.  if fromInteger doesn't promote the 0 to an appropriate Num, it is broken
09:07:53 <roconnor> monadic_kid: oh wait, nevermind. 
09:08:00 <roconnor> monadic_kid: sorry
09:08:03 <unkanon_> sleepynate: you teach CS or what?
09:08:06 <jmcarthur> paolino: i still don't see the problem. you should be using types appropriately for such things
09:08:08 <sleepynate> unkanon_: if it came with assignments i'd be hooked :P
09:08:11 <monadic_kid> roconnor: no worries
09:08:21 <sleepynate> unkanon_: CS and CIS, yes
09:08:25 <jmcarthur> allbery_b: it *does* though... i'm not sure where you're going with this
09:08:29 * hackagebot splot 0.1.11 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.11 (EugeneKirpichov)
09:08:33 <revenantphx> jmcarthur: sum $ map f [1..n]
09:08:33 <unkanon_> sleepynate: Deitel & Deitel's books usually do, they're pretty good to, but they only have them for the widespread languages
09:08:38 <revenantphx> I'm not seeing it.
09:08:39 <unkanon_> sleepynate: cool
09:08:46 <jmcarthur> revenantphx: the function f takes a parameter
09:08:47 <allbery_b> even if you have units, the unit-added type should match Num to the appropriatre unit and fromInteger for that typoe should add the unit/
09:08:51 <revenantphx> Yes, I don't need the value of n
09:08:51 <allbery_b> if it doesn't then it is broken
09:08:52 <jmcarthur> revenantphx: that parameter is the current n
09:08:53 <pumpkin> sleepynate: you teach CS with yonder kindle?
09:08:57 <sleepynate> unkanon_: but i also volunteer for a non-profit to teacn the younger crowd python/arduino fun
09:09:02 <allbery_b> but this is up tpo your unit-cwarrying type
09:09:02 <revenantphx> Yes, I need the current n.
09:09:09 <sleepynate> pumpkin: cute :P
09:09:11 <allbery_b> meh, typing
09:09:14 <jmcarthur> "<revenantphx> n/5 + n/25 + n/125 ... n/5^n"
09:09:29 <unkanon_> sleepynate: never done anything with hardware, but I'd try it
09:09:30 <allbery_b> basically I don't see what the complaint is
09:09:35 <jmcarthur> revenantphx: so f would be (\n -> n / (5^n))
09:09:44 <revenantphx> Erp, I messed that up.
09:09:46 <monadic_kid> has anyone seen this message from ghc before? "mkUsageInfo: internal name? r{tv a1yF}"
09:09:47 <pumpkin> jmcarthur: not sure about that
09:09:59 <FunctorSalad> benmachine: think I tracked it down to localhost resolving to ipv6 ::1 and connectTo "::1" ... not working either
09:09:59 <monadic_kid> mkUsageInfo: internal name? s{tv a1yG}
09:10:02 <allbery_b> aside from "it doesn't automatically fix my buggy fromInteger implementation"
09:10:05 <sleepynate> unkanon_: it's a subset of C that you flash onto a board with a java app... you'd be amazed at how easy it is 
09:10:06 <revenantphx> x/5 + x/25 + x/125 ... x/5^n where n = [1..x]
09:10:07 <pumpkin> monadic_kid: yeah, just a debug message that they forgot to suppress I think
09:10:10 <revenantphx> make more sense now jmcarthur?
09:10:19 <unkanon_> sleepynate: now I see your point about the lack of that kind of a tutorial for haskell. indeed, it does lack that.
09:10:21 <monadic_kid> pumpkin: nice :/
09:10:30 <FunctorSalad> (the ipv6 prob might well be my machine's fault somehow)
09:10:33 <EvanCarroll> @src replicate
09:10:33 <lambdabot> replicate n x = take n (repeat x)
09:10:38 <jmcarthur> revenantphx: still not a problem though
09:10:41 <EvanCarroll> @src repeat
09:10:41 <lambdabot> repeat x = xs where xs = x : xs
09:10:53 <sleepynate> unkanon_: well, and it may just be one of those things where you don't teach kids C until they know python
09:10:58 <jmcarthur> revenantphx: sum $ map (\n -> x / (n^5)) [1..x]
09:11:10 <unkanon_> true
09:11:12 <revenantphx> jmcarthur: k.
09:11:18 <sleepynate> but at the same time, there's a vastly rich set of libs for haskell, but not for something "on the way there" like scheme or clisp
09:11:34 <paolino> so my fromInteger is broken, but I think sum shouldn't
09:11:35 <sm> I think there's no getting around it - overall haskell is complicated as a first language
09:11:50 <unkanon_> that's true as well
09:11:51 <sleepynate> often, it takes more effort to bring a clisp lib up-to-date with what it needs to be than to just write it your damned self
09:11:55 <benmachine> FunctorSalad: weird. and weird that netcat would get it right, so it might still be good
09:12:01 <pumpkin> sm: I definitely think there is getting around it
09:12:02 <benmachine> er, might still be a bug
09:12:04 <BONUS> hmmm oh man i can't decide about a styling issue in lyah and i need some help. should i write all tuples as (a, b) or all of them as (a,b) or just sort of do what's more readable in any specific example. thoughts?
09:12:20 <benmachine> BONUS: I think each style has its place
09:12:29 <Botje> BONUS: make it configurable! *ducks*
09:12:32 <BONUS> lol
09:12:36 <Ke> !
09:12:41 <sleepynate> unkanon_: not to mention, try explaining how to install a clisp library on linux to a 13-year old
09:12:45 <sm> pumpkin: pick a subset as the teaching language, like racket ?
09:13:07 <BONUS> (1,2) is better than (1, 2) to me, but (Foo a b, Bar b c d) is better than (Foo a b,Bar b c d)
09:13:12 <aristid> BONUS: (1, 2) always
09:13:21 <jmcarthur> BONUS: i certainly wouldn't *always* do (a,b). that can get weird when either of the components are more than just a single identifier or literal
09:13:21 <unkanon_> BONUS: how do you compare your work with land of lisp?
09:13:29 <jmcarthur> BONUS: i usually do (a, b)
09:13:35 <pumpkin> sm: I don't think the whole thing is that tough. h98 or so. I think as a first language it'd be good, but not as a second or third
09:13:55 <jmcarthur> i think (a,b) is great when a and b are literals, but otherwise i use a space
09:14:05 <BONUS> yeah i sort of do the same thing
09:14:06 <aristid> BONUS: do you write "cookie, biscuit, pizza" or "cookie,biscuit,pizza" when listing favorite food?
09:14:21 <jmcarthur> english /= haskell
09:14:25 <BONUS> unkanon_: i havent read LoL but i hear it's good
09:14:25 <revenantphx> jmcarthur: That's not right either, sorry.
09:14:38 <revenantphx> Wait, I think I can fix it anyhow.
09:14:41 <revenantphx> Thanks.
09:15:05 <jmcarthur> paolino: how is sum supposed to know what to do with an empty list without 0?
09:15:11 <aristid> jmcarthur: well, there is a reason why you put the space there. and i think that reason equally applies to haskell
09:15:17 <jmcarthur> aristid: perhaps
09:15:31 <aristid> it looks way too cramped otherwise IMO
09:15:36 <jmcarthur> i agree
09:15:37 <aristid> lack of visual separation
09:15:42 <roconnor> @src mapAccumL
09:15:42 <lambdabot> mapAccumL _ s []        =  (s, [])
09:15:42 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
09:15:42 <lambdabot>    where (s', y ) = f s x
09:15:42 <lambdabot>          (s'',ys) = mapAccumL f s' xs
09:15:47 <BONUS> however, haskell's Show instance for tuples omits the space
09:16:04 <Botje> but Show was only made to be compatible to Read
09:16:12 <BONUS> true
09:16:15 <Botje> and btw it's human-readable too!
09:16:32 <aristid> > show [1, 2, 3]
09:16:33 <BONUS> it's weird that when it shows you tuples when explaining type errors, haskell puts spaces
09:16:37 <BONUS> i mean ghci does
09:16:39 <FunctorSalad> benmachine: localhost resolves to two results (the ipv6 one and the ipv4 one) and connectTo apparently always uses the first one... I guess netcat tries each resolution result in turn (netcat ::1 6600 doesn't work)
09:16:40 <roconnor> monadic_kid: as an aside I think "zipWith foo [0..]"  would be better than mapAccumL
09:16:41 <lambdabot>   mueval: ExitFailure 1
09:16:41 <pastorn> How do i register a callback i.e. writing to a file?
09:16:49 <BONUS> > [(1,2),(3,4,5)]
09:16:50 <aristid> > show [1 :: Int, 2, 3]
09:16:54 <pastorn> (dynamic reload on writing a config file)
09:16:56 <lambdabot>  Terminated
09:16:57 <lambdabot>   mueval: ExitFailure 1
09:17:00 <aristid> wtf
09:17:02 <aristid> > 1
09:17:08 <FunctorSalad> benmachine: (at least telnet seems to do that, netcat is silent about it)
09:17:13 <lambdabot>   mueval: ExitFailure 1
09:17:13 <roconnor> 1
09:17:38 <sleepynate> unkanon_: whatever it's faults "cabal install" is a lot more accessible than "Locate a website with the library you'd like to use as well as the installation directory of clisp on your machine..."
09:17:47 <paolino> jmcarthur: bottom ?
09:18:00 <FunctorSalad> maybe connectTo should try the next getAddrInfo result on failure too
09:18:11 <BONUS> hmmm ithink i just might go for the option that always puts spaces
09:18:11 <revenantphx> jmcarthur: thanks, I got it working now.
09:18:35 <sleepynate> unkanon_: then again, maybe if that book gets a bit more coverage this means there will be more cl-* packages in "that one distro's" repositories :P
09:18:40 <BONUS> what about in types though? (Int, Char) or (Int,Char)?
09:18:44 <paolino> summing an empty list is not well defined, I think
09:18:56 <benmachine> FunctorSalad: that might be sensible, yeah
09:20:06 <patrickthomson> buildExpressionParser, why you gotta treat me this way?
09:20:06 <revenantphx> okay... while this works jmcarthur, it's terribly inneficient for large values.
09:20:33 <paolino> jmcarthur: anyway I see that accepting fromIntger in Num class is enough for sum to use it
09:20:39 <aristid> BONUS: in types, i would use the same convention as in values
09:21:55 <paolino> jmcarthur: it is just strange that (+) works in my instance and sum not
09:22:03 <roconnor> monadic_kid: sorry kid, I can't immedately find anything wrong.
09:22:55 <monadic_kid> roconnor: that's okay, thanks anyway. I'm just checking around,
09:23:06 <unkanon_> sleepynate: I didn't know about clisp
09:23:17 <roconnor> monadic_kid: I still recommend zipWith foo [0..] over mapAccumL
09:23:43 <monadic_kid> roconnor: okay but bug first :P
09:23:43 <sleepynate> unkanon_: that more modern distributions are pre-packaging less and less of their libs? :)
09:24:14 <unkanon_> sleepynate: yes, that. quite the opposite of what smalltalk does :)
09:24:58 <sleepynate> well it's not exactly *buntu's fault.. their folks just don't use lisp as much i guess
09:25:20 <sm> unkanon_: smalltalk (squeak, pharo etc.) have been separating out their libs for years
09:25:32 <sm> moving in that direction I mean
09:26:00 <sleepynate> cl libs are packaged up, they're just not accessible from apt-get most of the time
09:26:10 <unkanon_> sm: I misunderstood. maybe we should take this to #haskell-blah
09:26:12 <sleepynate> you gotta find that shit and do it the old fashioned way
09:26:38 <sleepynate> unkanon_: can't we just mention cabal off-handedly so it's on topic? :)
09:26:44 <unkanon_> haha
09:26:52 <sm> haskell way more deployable than cl
09:27:12 <sleepynate> sm: that's basically my point
09:27:20 <unkanon_> smalltalk > haskell > CL in deployability
09:27:37 <sleepynate> > > > > > > > > > > scheme
09:27:40 <lambdabot>   <no location info>: parse error on input `>'
09:27:46 <sm> wait now, racket is pretty darn good
09:27:47 <sleepynate> sorry lambdabot 
09:27:55 <sm> better than cl
09:28:05 <unkanon_> especially for catching errors, quite good
09:28:08 <Feuerbach> FunctorSalad: "maybe connectTo should try the next getAddrInfo result on failure too" -- it does, since today :)
09:28:19 <unkanon_> sm, we're in -blah now
09:28:22 * sm is talking about deployability
09:28:49 <Feuerbach> FunctorSalad: (today Johan applied my patch which was hanging for 7 months)
09:28:54 <sleepynate> sm: come to -blah and we plaudertn more :P
09:30:00 <revenantphx> okay, so i'd like to optimize this...
09:30:01 <revenantphx> https://gist.github.com/751788
09:30:16 <revenantphx> the issue is that for really large numbers, its iterating over all values [1..num]
09:30:29 <paolino> jmcarthur: http://www.rwc.uc.edu/koehler/biophys/1a.html  , they are related, dimensions and units. I'm not sure "dimensioned number" is correct in english
09:30:34 <FunctorSalad> Feuerbach: nice :) (FWIW, it just occured to me that I probably need to make the thing that's currently listening on 127.0.0.1:6600 listen on ::1:6600 for ipv6 to work ;))
09:30:34 <revenantphx> what i'd like to do is, ignore values that would come out to (rounded0 0.
09:30:50 <FunctorSalad> (I presumed it's just some sort of alias)
09:31:06 <revenantphx> basically, while some value that is being repeatedly divided by 5 is greater than 5.
09:31:23 <revenantphx> I know how to express it imperatively with a while loop...
09:31:36 <Feuerbach> FunctorSalad: that would be another solution, but in general you do not control this (for arbitrary host)
09:32:11 <FunctorSalad> Feuerbach: yep, trying the second entry would be the right thing in this case
09:32:22 <FunctorSalad> (as in your patch)
09:32:59 <benmachine> hmm
09:33:29 <benmachine> when I use iteratee's enumHandle with a buffer size of 1
09:33:45 <benmachine> it decides that since Chars are four bytes, this means a four-byte buffer
09:33:52 <benmachine> and hence reads characters from the input stream in fours
09:34:06 <benmachine> because of encoding, I suppose
09:34:57 <jmcarthur> paolino: either way, if you have a bad definition for fromIntegral then it naturally follows that any function relying on it for proper behavior might give you bad results
09:35:03 <jmcarthur> *fromInteger
09:35:17 <benmachine> which doesn't really make sense because it opens its files in binary mode
09:36:23 <FunctorSalad> benmachine: it seems to use sizeOf (undefined :: el) http://hackage.haskell.org/packages/archive/iteratee/latest/doc/html/src/Data-Iteratee-IO-Handle.html#enumHandle
09:36:43 <FunctorSalad> ghci> sizeOf (undefined ::Char)
09:36:43 <FunctorSalad> 4
09:37:02 <revenantphx> um
09:37:02 <revenantphx> https://gist.github.com/751811
09:37:10 <revenantphx> the value of z and f1 seem to differ here?
09:37:11 <revenantphx> It's kind of odd.
09:37:20 <benmachine> FunctorSalad: right, but that's not actually the size of incoming data
09:37:22 <revenantphx> er, ignore the f on the end
09:37:24 <Twey>  /join #conlang
09:37:31 <Twey> … dammit
09:37:59 <revenantphx> why do f1 and z have different values 0.o
09:38:03 <benmachine> revenantphx: at a guess, z is integer
09:38:09 <benmachine> revenantphx: is it bigger than 2^32?
09:38:15 <revenantphx> Hm, possibly.
09:38:17 <revenantphx> Wait no.
09:38:22 <revenantphx> z is 24, f1 is -13
09:38:26 <revenantphx> z is the correct value.
09:38:42 <benmachine> revenantphx: try changing signature of f1 to Integer -> Integer
09:38:44 <benmachine> see if that helps
09:38:45 <revenantphx> er, 14*
09:38:51 <c3l> why do you have to specify a value constructor for a type constructor, if they are always given the same name? couldnt that just be ommited?
09:38:57 <revenantphx> yeah that fixes it.
09:39:04 <benmachine> c3l: they're not always given the same name
09:39:06 <paolino> jmcarthur: it all comes down to the fact that Num is just a class , not the *right* class for numbers. I'm not an expert but fromInteger seems a hack , not related to algebra
09:39:27 <revenantphx> okay so
09:39:29 <revenantphx> https://gist.github.com/751811
09:39:29 <benmachine> c3l: they're often given the same name when there is only one value constructor, but for e.g. Maybe there are multiple value constructors for each type
09:39:36 <revenantphx> f1 there is really inneficient.
09:39:50 <revenantphx> I know how I'd express it cleanly imperatively, but I don't know how to transfer it to haskell.
09:40:16 <benmachine> revenantphx: how would you do it imperatively?
09:40:18 <c3l> benmachine: what purpose would that serve?
09:40:30 <benmachine> c3l: do you know the Maybe type?
09:40:45 <revenantphx> basically i'd continuously divide num by 5, summing each result, while the current result is greater than or equal to 5
09:41:04 <revenantphx> while(r >= 5) r = r/5; total+=t
09:41:08 <benmachine> revenantphx: ah, try mapAccumL or mapAccumR or one of those
09:41:24 <revenantphx> The important part is that theres a shuttoff.
09:41:24 <c3l> benmachine: no, maybe I should leave this for future me with more experience =) thanks
09:41:25 <benmachine> sum . takeWhile (>= 5) $ something
09:41:33 <revenantphx> ah!
09:41:39 <revenantphx> forgot about takewhile.
09:41:51 <benmachine> :)
09:41:53 <Twey> revenantphx: Switching from Integer to Int or something would probably increase efficiency, too, if you can afford it.
09:42:00 <revenantphx> Twey: of course.
09:42:07 <benmachine> Integer's not that bad
09:42:41 <FunctorSalad> benmachine: haven't used the function before, but it seems to use Storable
09:42:59 <revenantphx> benmachine: It's tempting to rewrite as
09:43:00 <revenantphx> f2 num = sum . takeWhile (>= 0) $ map (\n -> num `div` (5^n)) [1..num]
09:43:12 <FunctorSalad> (so Char's Storable instance would be the 'encoding')
09:43:15 <revenantphx> however that hangs for large values too.
09:43:37 <revenantphx> I kind of expected that to be fine with lazyness and all...
09:43:48 <benmachine> FunctorSalad: I'm just wondering if it's a bug that it assumes it's reading 4-byte values from the handle
09:43:55 <revenantphx> oh
09:43:56 <revenantphx> >= 0
09:43:57 <revenantphx> fail
09:44:01 <Twey> revenantphx: It still has to iterate over the whole list — there might be a big number after all those 0s
09:44:01 <benmachine> :P
09:44:05 <Twey> Yeah
09:44:11 <revenantphx> Twey: thats not how takeWhile works
09:44:12 <Twey> f1 = sum . takeWhile (>= 5) . iterate (`div` 5) . enumFromTo
09:44:16 <revenantphx> it shuts off after the first failure.
09:44:18 <benmachine> Twey: no because takeWhile, not filter
09:44:31 <Twey> revenantphx: But there will never be a failure with >= 0 there
09:44:31 <pastorn> How do i install a hook on a file?
09:44:37 <benmachine> yes
09:44:41 <revenantphx> Twey: exactly, it should be >-
09:44:43 <revenantphx> >0*
09:44:44 * hackagebot yesod-paginate 0.1 - Pagination for Yesod sites.  http://hackage.haskell.org/package/yesod-paginate-0.1 (AlexanderDunlap)
09:44:45 <Twey> revenantphx: Division of a positive by a positive will never result in a negative
09:44:57 <revenantphx> if was a mistake
09:44:59 <Twey> revenantphx: You said 5 in your imperative code.  Why is that different?
09:45:04 <benmachine> Twey: it isn't :P
09:45:07 <nejucomo> pastorn: What do you mean?
09:45:23 <benmachine> it was a typo/thinko/whatever
09:45:27 <Twey> Oh
09:45:27 <pastorn> nejucomo: i want a function to get called once something happends to file X
09:45:32 <paolino> :t mapAccumL
09:45:32 <revenantphx> Oh, that's the old algorithm + lazyness
09:45:38 * benmachine giggles at iteratee source code
09:45:38 <lambdabot> Not in scope: `mapAccumL'
09:45:40 <pastorn> but i don't want to poll on X, i want the OS to call it for me
09:45:41 <benmachine> instance Exception NotAnException where
09:45:45 <Twey> benmachine: Heh
09:45:53 <c_wraith> pastorn, linux only ok?
09:45:53 <Twey> > 0/0
09:45:54 <lambdabot>   NaN
09:45:55 <revenantphx> the takeWhile (> 0) prevents it from summing useless elements.
09:45:57 <benmachine> revenantphx: Twey gave you a version with iterate, might be worth looking at
09:45:57 <Twey> :t 0/0
09:45:58 <lambdabot> forall t. (Fractional t) => t
09:45:59 <revenantphx> So it serves as a cutoff.
09:46:00 <pastorn> c_wraith: yes
09:46:06 <revenantphx> Yeah I am now benmachine 
09:46:06 <Twey> NaN is a Num
09:46:06 <c_wraith> @hackage hinotify
09:46:07 <lambdabot> http://hackage.haskell.org/package/hinotify
09:46:19 <c_wraith> pastorn, look at that package
09:46:24 <benmachine> Twey: *facepalm* :P
09:46:27 <paolino> :t Data.List.mapAccumL
09:46:27 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:46:40 <Twey> IIRC ‘quot’ is also faster than ‘div’ because it's the instruction implemented by the hardware
09:46:46 <pastorn> c_wraith: i looked in base for this :/
09:47:00 <Twey> So maybe: f1 = sum . takeWhile (> 0) . iterate (`quot` 5) . enumFromTo 1
09:47:06 <revenantphx> Twey: should be enumFromTo 0 anyhow
09:47:07 <revenantphx> er, 1
09:47:08 <FunctorSalad> benmachine: as I understand it so far, using the "ReadableChunk ByteString Word8" or "ReadableChunk [Word8] Word8" instance will actually use as many bytes as you specified for the bufferSize
09:47:08 <revenantphx> yeah
09:47:10 <Twey> Right
09:47:24 <benmachine> FunctorSalad: yeah, that looks like a sensible option
09:47:25 <revenantphx> `quot`?
09:47:28 <Twey> :t quot
09:47:28 <c_wraith> pastorn, is being a base a requirement, or were you just saying that's the only place you looked
09:47:29 <lambdabot> forall a. (Integral a) => a -> a -> a
09:47:36 <Twey> 17:46:16 < Twey> IIRC ‘quot’ is also faster than ‘div’ because it's the instruction implemented by the hardware
09:47:41 <benmachine> means I have to find myself *another* iteratee for encoding/decoding UTF-8 though :(
09:47:42 <revenantphx> :t (sum . takeWhile (> 0) . iterate (`quot` 5) . enumFromTo 1)
09:47:42 <lambdabot> forall t. (Integral [t], Num t, Enum t) => t -> [t]
09:47:43 <nejucomo> pastorn: So you mean file access and not "file handle" access, as in select()?
09:47:44 <revenantphx> :|
09:47:49 <revenantphx> Twey: eeeeh
09:48:06 <benmachine> I think
09:48:09 <pastorn> c_wraith: i looked in hoogle, because i thought the functionality would exist there
09:48:15 <benmachine> :t sum . takeWhile (> 0) . iterate (`quot` 5)
09:48:16 <lambdabot> forall a. (Integral a) => a -> a
09:48:22 <pastorn> nejucomo: ehm... i don't exactly understand how select works
09:48:27 <benmachine> the enumFromTo is bogus now
09:48:43 <FunctorSalad> benmachine: the ReadableChunk [Char] Char instance uses "peekCAStringLen", whatever that is
09:48:46 <revenantphx> what is `quot`?
09:49:00 <benmachine> FunctorSalad: it assumes ASCII :(
09:49:10 <nejucomo> Do you want events about opened files, or events about the file system (ie: path Foo was opened for reading, directory Bar was opened for reading), etc?
09:49:14 <Twey> quot rounds down, div rounds towards zero… IIRC
09:49:15 <benmachine> revenantphx: it is `div` but with different behaviour < 0
09:49:24 <revenantphx> Oh... well I don't care about less than 0 :|
09:49:29 <benmachine> Twey: vice versa I think
09:49:33 <Twey> Is it?
09:49:39 <benmachine> > quot (-5) 2
09:49:40 <lambdabot>   -2
09:49:43 <FunctorSalad> benmachine: then I don't see how using 4 bytes per char makes sense, either
09:49:48 <Twey> Oh, yeah
09:49:56 <benmachine> FunctorSalad: mm, I guess this looks like a bug then
09:50:02 <revenantphx> f2 :: Integer -> Integer
09:50:02 <revenantphx> f2 num = sum . takeWhile (> 0) $ map (\n -> num `div` (5^n)) [1..num]
09:50:03 <pastorn> nejucomo: if anyone writes in the config file i want to reload it
09:50:04 <revenantphx> that works fine.
09:50:15 <benmachine> FunctorSalad: well, sort of. it's treating Char as Word8 basically
09:50:27 <benmachine> but then I guess it's a bug that it's using sizeOf Char
09:50:31 <Twey> f1 = sum . takeWhile (> 0) . iterate (`quot` 5) . enumFromTo 1 -- is probably faster, and is definitely neater
09:50:38 <nejucomo> pastorn: Ok, so I think you want something like inotify.
09:50:38 <revenantphx> hm
09:50:46 <pastorn> when do i want select?
09:50:59 <benmachine> Twey: that enumFromTo is unnecessary
09:51:07 <benmachine> in fact, just plain erroneous
09:51:10 <benmachine> iterate is generating the list now
09:51:14 <Twey> benmachine: Oh?
09:51:15 <Twey> Oh
09:51:16 <Twey> Right
09:51:23 <Twey> f1 = sum . takeWhile (> 0) . iterate (`quot` 5)
09:51:24 <nejucomo> You want select if you have opened a file to read, and you want to be notified that there is new data to be read.
09:51:37 <nejucomo> For example, if you were writing "tail -f".
09:51:39 <pastorn> oh, like sockets etc.
09:51:49 <nejucomo> Yes, often used for sockets.
09:51:50 <revenantphx> also, your f1 is summing the original value as well.
09:52:02 <revenantphx> so f1 60 ->74 (should be 14)
09:52:02 <benmachine> nejucomo: I looked at tail -f
09:52:06 <pastorn> but Handles solves all that automagicaly, right?
09:52:09 <benmachine> it just stats the file like every two seconds or something
09:52:10 <nejucomo> However, I think the haskellish way is to have different IO processes which all block in IO.
09:52:10 <Twey> f1 = sum . takeWhile (> 0) . drop 1 . iterate (`quot` 5)
09:52:16 <benmachine> to see if it's got bigger
09:52:26 <jmcarthur> pastorn: i agree with you there. i think fromInteger should be in its own type class. regardless, the definition of sum would still require it, and it makes sense to me that it does
09:52:37 <nejucomo> benmachine: Ok, I meant a different "tail -f" implementation, then.
09:52:47 <pastorn> jmcarthur: precisely
09:52:52 <pastorn> :p
09:52:53 <jmcarthur> pastorn: there's always defining sum with foldl1' instead, but then you can't use empty lists
09:52:57 <benmachine> nejucomo: ok, but the point is that select et al don't do what you want in that regard
09:53:08 <pastorn> jmcarthur: lolwat?
09:53:15 <jmcarthur> dang wrong person
09:53:25 <jmcarthur> ah paolino left
09:53:35 <benmachine> jmcarthur: sum would only require a zero - Monoid :P
09:53:38 <jmcarthur> pastorn: sorry ^_^
09:53:51 <jmcarthur> benmachine: yeah. we need a nicer algebra
09:53:57 <revenantphx> My solution : Correct Answer – Execution Time: 4.76
09:53:57 <revenantphx> Twey's solution: Correct Answer – Execution Time: 4.43
09:54:01 <pumpkin> moar algebra
09:54:08 <pastorn> jmcarthur: nevar!
09:54:15 <benmachine> revenantphx: are you optimising?
09:54:21 <revenantphx> Seems really weird.
09:54:30 <revenantphx> C programs that do the same get times of 0s easily.
09:54:40 <revenantphx> I'm using: z2 = sum . takeWhile (> 0) . drop 1 . iterate (`quot` 5)
09:54:53 <benmachine> are you optimising?
09:54:59 <revenantphx> how would I optimize it?
09:55:03 <pastorn> revenantphx: write it as a function, skip the list construct part?
09:55:03 <revenantphx> (I don't control the compiler)
09:55:07 <benmachine> oh :(
09:55:09 <benmachine> in which case
09:55:13 <benmachine> try foldl' (+) 0
09:55:14 <benmachine> instead of sum
09:55:23 <benmachine> without optimisations, GHC won't detect the sum is strict
09:55:25 <jmcarthur> sucks when you can't control the compiler
09:55:28 <benmachine> which leads to big thunks
09:55:44 <benmachine> (also, do OPTIONS_GHC pragmas work?)
09:55:46 <pastorn> @type foldl'
09:55:46 <lambdabot> Not in scope: `foldl''
09:55:50 <benmachine> (foldl' is in Data.Lost)
09:55:51 <benmachine> er
09:55:52 <benmachine> List
09:56:05 <pastorn> Data.Lost, where all my missing code goes to die
09:56:12 <benmachine> yes
09:56:21 <Twey> Heh
09:56:29 <Twey> Strange to not control the compiler…
09:56:31 <revenantphx> Switching to fold'...
09:56:45 <revenantphx> 4.75s >_>
09:56:47 <revenantphx> didn't help much
09:56:49 <benmachine> wat
09:56:50 <pastorn> how about writing it as a no-list function?
09:57:00 <pastorn> just doing it with basic recursion
09:57:01 <benmachine> pastorn: we could do that, but it's unhaskelly
09:57:10 <benmachine> would be nice if we could get code that is fast *and* idiomatic
09:57:22 <pastorn> sum, takewhile and drop each checks for empty lists
09:57:36 <benmachine> revenantphx: do you know typical values for the input?
09:57:37 <pastorn> which seems unnessesary
09:58:05 <benmachine> pastorn: sure, but drop only does so, like, twice
09:58:11 <revenantphx> Uh yes
09:58:21 <revenantphx> about 100000 numbers between 1 and 1000000000
09:58:26 <pastorn> revenantphx: to write it optimized, let the first argument to the function be an accumulator, and once you reach a base case you just return that
09:58:37 <benmachine> oh, that'll be why your Int version failed
09:58:49 <revenantphx> well, actually int version works now.
09:58:56 <benmachine> mm
09:59:01 <revenantphx> There was some other stuff I did that made it fail.
09:59:04 <benmachine> oic
09:59:09 <benmachine> where was your paste again?
09:59:11 <benmachine> I've lost it
09:59:22 <benmachine> also, what is your compiler and options, even if you can't control them
09:59:25 <revenantphx> https://gist.github.com/751841
09:59:38 <revenantphx> ghc-6.10.4 apparently.
09:59:41 <benmachine> oh right
10:00:26 <revenantphx> this is the problem, http://www.codechef.com/problems/FCTRL
10:00:33 <revenantphx> Im just trying to get a 0.00s time 
10:01:07 <pumpkin> I think I mostly like point-free code in haskell cause I hate \ for lambdas
10:01:39 <benmachine> okay, I guess we have no choice but to try an iterative version like pastorn suggested
10:01:42 <revenantphx> Why can't we use λ for lambdas instead :(
10:01:52 <pumpkin> cause it's a greek letter
10:01:59 <revenantphx> make a special case >:(
10:02:04 <pumpkin> I'm not sure it should have any special syntax, really
10:02:24 <revenantphx> At least make it a compiler extension then.
10:02:26 <benmachine> > let λ x = x + 1 in λ 0
10:02:27 <lambdabot>   1
10:02:28 <Twey> pumpkin: Haha, probably
10:02:36 <pumpkin> we use it plenty
10:02:44 <revenantphx> anyways
10:02:48 <revenantphx> back to this
10:02:52 <pumpkin> NO
10:03:02 <tux_mark_5> are there any reasons why haskell doesn't support ad-hoc polymorphism?
10:03:05 <benmachine> revenantphx: have you considered there might be a closed form for the calculation?
10:03:11 <pumpkin> tux_mark_5: do you still beat your wife?
10:03:21 <revenantphx> benmachine: Luckily, as of last week, I know what you're talking about!
10:03:21 <Twey> µ
10:03:31 <c_wraith> twey has become a greek cow?
10:03:31 <tux_mark_5> pumpkin: ???
10:03:33 <revenantphx> Actually, I think this very problem might be an exercise in Concrete math....
10:03:37 <revenantphx> >_>
10:03:42 <benmachine> revenantphx: it might well be!
10:03:46 <revenantphx> I should try to work it out mathematically, that'd be fun.
10:04:00 <pumpkin> tux_mark_5: http://en.wikipedia.org/wiki/Loaded_question
10:04:04 <revenantphx> If theres a closed form I win :)
10:04:30 <j-invariant> closed form for what?
10:04:35 <revenantphx> Are there any times when recurrence > closed form in performance/
10:04:42 <tux_mark_5> pumpkin: could you be more specific?
10:04:48 <j-invariant> revenantphx: yes there can be
10:04:56 <j-invariant> usually for small numbers
10:04:57 <pumpkin> tux_mark_5: what do you mean by ad-hoc polymorphism?
10:05:10 <tux_mark_5> pumpkin: c/c++/java-like function overloading 
10:05:19 <benmachine> tux_mark_5: uhm
10:05:21 <benmachine> > show (
10:05:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:05:22 <benmachine> er
10:05:24 <benmachine> > show ()
10:05:25 <lambdabot>   "()"
10:05:26 <benmachine> > show 7
10:05:27 <lambdabot>   "7"
10:05:28 <pumpkin> tux_mark_5: we do, surrounded by a typeclass
10:05:31 <benmachine> > show [1,2,3]
10:05:32 <lambdabot>   "[1,2,3]"
10:05:32 <tux_mark_5> pumpkin: i know that we can do something like what with type classes
10:05:52 <tux_mark_5> pumpkin: but the problem is, that i have a function, which's signature i can't change
10:05:57 <pastorn> z3 acc 0 = acc
10:05:58 <pastorn> z3 acc x = let q = quot x 5 in z3 (acc + q) q
10:06:06 <revenantphx> tux_mark_5: i don't think haskell is the write language here :P
10:06:07 <pumpkin> tux_mark_5: because otherwise there's no way of specifying in a type that you need such a thing
10:06:13 <tux_mark_5> pumpkin: and yet I need to make it behave differently when a variable of different type is supplied
10:06:17 <pastorn> revenantphx: benmachine ^^^^
10:06:23 <paper_cc> tux_mark_5: then you'll have to invent a new name
10:06:25 <revenantphx> right*
10:06:26 <revenantphx> mmk
10:06:27 <pumpkin> tux_mark_5: that breaks the very fundamental behavior of haskell
10:06:34 <pumpkin> it's called parametricity, and you're basically asking for typecase
10:06:37 <tux_mark_5> pumpkin: the problem is with >>=
10:06:40 <pastorn> i think that's what you're doing... not too sure :/
10:06:45 <benmachine> pastorn: could probably throw a few seqs in for good measure :P
10:06:46 <pumpkin> tux_mark_5: that's in a typeclass...
10:06:48 <Twey> tux_mark_5: (‘whose signature’ — works for things as well as people)
10:06:51 <paper_cc> :t (>>=)
10:06:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:06:53 <revenantphx> lets see how it does pastorn
10:06:55 <tux_mark_5> pumpkin: i want for the bind operator to behave differently
10:06:58 <monochrom> type class is close to type case
10:07:01 <pumpkin> tux_mark_5: then you write an instance
10:07:11 <pumpkin> monochrom: yeah, but you need to be explicit about it in your type signature, which makes it okay :P
10:07:16 <monochrom> which is what pumpkin says
10:07:28 <paper_cc> tux_mark_5: either you can write an instance or what you want to do is not a bind operator conceptually
10:07:44 <revenantphx> running~
10:07:46 <paper_cc> tux_mark_5: (an instance of Monad, see the signature above)
10:07:48 <pumpkin> the issue with secretly making forall a. a -> a behave like id for all types but Int, where it behaves like (+3)
10:08:01 <tux_mark_5> basically i want for a >>= b to behave differently depending on what type a is
10:08:01 <revenantphx> 4.07s!
10:08:04 <revenantphx> pastorn wins so far XD
10:08:09 <pastorn> haha!
10:08:09 <pumpkin> if I see forall a. Typeable a => a -> a, I know to expect funny business
10:08:17 <pastorn> revenantphx: add Int as a type signature
10:08:18 * revenantphx is going to hunt for closed form.
10:08:19 <pumpkin> if I see forall a. a -> a, I can make big assumptions
10:08:27 <pastorn> or Int#
10:08:29 <revenantphx> pastorn: it is Int - > Int -> Int
10:08:37 <pastorn> not unless you tell it to be
10:08:41 <revenantphx> I did.
10:08:48 <revenantphx> Int#?
10:08:50 <pastorn> revenantphx: throw in a MagicHash
10:08:52 <pastorn> yes
10:08:59 <benmachine> revenantphx: put {-# LANGUAGE BangPatterns #-} at the top
10:09:00 * pumpkin smokes some MagicHash
10:09:03 <pastorn> {-# LANGUAGE MagicHash #-}
10:09:08 <benmachine> and then put !s in your equations
10:09:10 <benmachine> EVERYWHERE
10:09:15 <benmachine> <_<
10:09:15 <pastorn> revenantphx: it gives you access to I#, which is the constructor for Int
10:09:20 <ski> tux_mark_5 : you can already make `a >>= b' behave differently, depending on what type `a' is .. what's the problem ?
10:09:20 <pumpkin> benmachine: sounds like a good plan
10:09:32 <tux_mark_5> ski: who can I do that?
10:09:35 <revenantphx> TT_TT
10:09:35 <benmachine> hopefully, GHC will then unbox for you
10:09:38 <tux_mark_5> *how
10:09:39 <pumpkin> tux_mark_5: that's what I was saying
10:09:39 * revenantphx is scared.
10:09:42 <pastorn> revenantphx: it's the last optimization you do before doing it in C and call it with unsafePerformIO
10:09:44 <pumpkin> (>>=) is a method in a typeclass (Monad)
10:09:47 <paper_cc> tux_mark_5: implement an instance of Monad
10:09:49 <pumpkin> you can instance it and make it behave differently :P
10:09:51 <revenantphx> pastorn: haha
10:09:54 <revenantphx> cheating :3
10:09:56 <ski> tux_mark_5 : you make a new instance of the type class `Monad'
10:10:01 <pastorn> revenantphx: but listen to benmachine, you should add seq in it
10:10:13 <pumpkin> instance Monad MyTypeConstructor where (>>=) = ...; return = ...
10:10:18 <revenantphx> so wait, how would I rewrite your version?
10:10:24 <paper_cc> tux_mark_5: see, say, the Gentle Haskell tutorial for a exhaustive explanation of typeclasses
10:10:37 <revenantphx> this z4 :: Int# -> Int# -> Int# gives parse error
10:10:38 <pastorn> change the code to be q `seq` z3 ....
10:10:44 <monochrom> > [4,5] >>= return
10:10:44 <lambdabot>   [4,5]
10:10:46 <tux_mark_5> ski: well, i already have an instance of monad
10:10:48 <pastorn> revenantphx: well, you need to wrap it up
10:10:49 <pumpkin> revenantphx: you need -XMagicHash turned on
10:10:51 <monochrom> > Just 4 >>= return
10:10:52 <lambdabot>   Just 4
10:10:55 <revenantphx> pastorn?
10:10:58 <pastorn> revenantphx: look in the compiler docs
10:10:58 <revenantphx> pumpkin: I do.
10:10:59 <monochrom> behave differently
10:11:01 <benmachine> revenantphx: add this before your first equation: z3 acc x | acc `seq` x `seq` False = undefined
10:11:14 <tux_mark_5> however in a >>= b within the same monad can be of different types obviously
10:11:19 <revenantphx> Factorial.hs:31:6: Not in scope: type constructor or class `Int#'
10:11:19 <benmachine> revenantphx: I think if you do that you won't need to faff about with hashes
10:11:24 <benmachine> but you might still
10:11:33 <tux_mark_5> and when a is of type Int, i need for >>= to behave differently
10:11:46 <revenantphx> Ok, I have three people saying what to do at once TT_TT
10:12:03 <benmachine> too many answers oh no :P
10:12:08 <revenantphx> @fugues
10:12:08 <lambdabot> Unknown command, try @list
10:12:11 <revenantphx> @quote fugues
10:12:11 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
10:12:13 <revenantphx> https://gist.github.com/751861
10:12:19 <revenantphx> whast should I change on that last one?
10:12:44 <revenantphx> It doesn't compile right now
10:12:47 <revenantphx> actorial.hs:31:6: Not in scope: type constructor or class `Int#'
10:12:51 <ski> tux_mark_5 : yes, but since `(>>=) :: m a -> (a -> m b) -> m b' is polymorphic in `a' (and in `b'), for each specific `m' which you make an instance of `Monad', `(>>=)' will behave "the same" for different types plugged into `a' (and into 'b')
10:13:13 <ski> that's just how parametric polymorphism works
10:13:21 <tux_mark_5> that's the problem
10:13:26 <roconnor> ski: it is only natural
10:13:50 <monochrom> use machine code. you have full control over pretended types.
10:13:53 <pastorn> revenantphx: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#magic-hash
10:13:58 <tux_mark_5> because i wanted to make an IO monad which benchmarks executed funtions
10:14:16 <tux_mark_5> and benchmarks only those which take or return an argument of specific type
10:14:20 <benmachine> revenantphx: https://gist.github.com/751864 is what I think you should do
10:14:22 <pumpkin> oh, you can't do that
10:14:32 * ski transforms roconnor with a terminal morphism
10:14:45 <pumpkin> tux_mark_5: you can do it in a very sketchy way, but I advise against it
10:14:56 <tux_mark_5> pumpkin: how?
10:15:00 <pumpkin> RULES
10:15:08 <revenantphx> Doesn't work benmachine 
10:15:12 <ski> tux_mark_5 : if you don't like in what way `(>>=)' is parametric polymorphic vs. overloaded, then you make a new type class
10:15:16 <revenantphx> wait, lets see
10:15:20 <revenantphx> yeah no
10:15:30 <benmachine> revenantphx: elaborate
10:15:30 <revenantphx> z4' 0 n is always 0
10:15:51 <benmachine> revenantphx: oh wups
10:16:02 <benmachine> I meant acc `seq` x == 0 = acc
10:16:03 <benmachine> sry
10:16:06 <monochrom> not convinced it is less work to forbid benchmarking of other return types
10:16:10 <ski> tux_mark_5 : the point of `(>>=)' is to behave the same for every `a' and `b' in its type `m a -> (a -> m b) -> m b'
10:16:38 <pumpkin> tux_mark_5: as I was saying before, not being able to do what you want is kind of important
10:16:39 <ski> tux_mark_5 : this is because only the `m' is a parameter of the type class `Monad'
10:16:53 <tux_mark_5> it's a bit restrictive
10:16:54 <monochrom> indeed if you want to use a kind of type case, it is already more work
10:17:45 <ski> tux_mark_5 : the restriction constrains the implementer, but makes useful guarantees to the user
10:17:56 <ski> it's a trade off
10:18:01 <benmachine> haskell does that a lot
10:18:05 <tux_mark_5> i don't like tradeoffs ;D
10:18:09 <benmachine> which is sensible because only one person does implementation
10:18:16 <benmachine> but loads of people end up using the thing
10:18:23 <pumpkin> tux_mark_5: restricting the language is often a good idea. Good language design is as much about deciding what to prevent as what to allow
10:18:36 <monochrom> the history of programming is a class struggle between implementer and user
10:18:43 <monochrom> in fact...
10:18:46 <pumpkin> tux_mark_5: unfortunately, many recent languages don't realize that :P
10:18:53 <monochrom> "the history of programming is a class struggle between implementer and user" --- Cyber Marx :)
10:19:12 <roconnor> types are proofs of correctness, not things to make decisions with.
10:19:19 <tux_mark_5> i like languages which are less restrictive; they allow nicer expressions and less boiler-plate code
10:19:59 <monochrom> haskell is a counterexample to (less restrictive => nicer expression and less boilerplate"
10:20:09 <revenantphx> benmachine: 4.11s
10:20:16 <benmachine> revenantphx: waaat
10:20:18 <tux_mark_5> personally, i think compiler should allow for user/implementer to specify via command-line parameters or such how much to allow or restrict
10:20:21 <benmachine> :(
10:20:34 <pastorn> revenantphx: could you paste all of your code?
10:20:36 <benmachine> ok closed form it is :P
10:20:44 <revenantphx> benmachine: yep
10:20:45 * allbery_b is having watfiv flashbacks.  "thanks"
10:20:46 <pastorn> revenantphx: with running examlpes
10:20:53 <revenantphx> ?
10:20:55 <pumpkin> tux_mark_5: you can do what you want with rules, as I said
10:20:59 <revenantphx> https://gist.github.com/751841
10:20:59 <pumpkin> it gives you all the control you want
10:21:04 <pastorn> revenantphx: > z3 0 99999999
10:21:05 <pastorn> 8333329
10:21:07 <pastorn> (0.00 secs, 0 bytes)
10:21:18 <tux_mark_5> pumpkin: example would be nice; i've never used rules so i'm not sure how to do it
10:21:26 <ski> tux_mark_5 : maybe you could explain what you're actually trying to do, here ?
10:21:27 <revenantphx> how can I time a function call?
10:21:29 <revenantphx> In ghci?
10:21:34 <benmachine> :set +s or something
10:21:44 <pumpkin> rules let you specify a rewrite at compile time. "if I see this, replace it with that"
10:21:55 <pumpkin> do it with the types and write a specific version
10:22:13 <pumpkin> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
10:22:21 <revenantphx> 0.00s for any ONE run
10:22:25 <benmachine> are there iteratees around for encoding/decoding UTF-8?
10:22:31 <revenantphx> but for 1000000 numbers, I could see it racking up some time.
10:22:33 <tux_mark_5> ski: i have a custom IO monad, which times how much each computation takes
10:22:39 <djahandarie> revenantphx, use criterion
10:22:41 <monochrom> <tux_mark_5> because i wanted to make an IO monad which benchmarks executed funtions <tux_mark_5> and benchmarks only those which take or return an argument of specific type
10:22:45 <tux_mark_5> ski: and i want to filter trivial computations
10:22:47 <monochrom> that's the real question
10:22:48 * djahandarie walked in and isn't sure who is actually benchmarking stuff
10:23:02 <pastorn> revenantphx: oh, you want map (z3 0) [1..1000000] ?
10:23:05 <benmachine> revenantphx: is it possible to get the runtime even if the answer is wrong?
10:23:10 <revenantphx> pastorn: no no no
10:23:18 <revenantphx> oh, I should try that though
10:23:20 <revenantphx> not a bad test
10:23:24 <monochrom> I totally don't see the need to forbid benchmarking of certain other return types and why it might save work.
10:23:26 <pastorn> as i said, give me running examples
10:23:29 <benmachine> revenantphx: hmm, there might be a potential for memoisation here
10:23:37 <revenantphx> memoisation?
10:23:46 <benmachine> storing the results of previous computations
10:23:50 <benmachine> to be re-used
10:23:51 <monochrom> For example see "criterion", no such restriction, totally successful benchmarks.
10:23:54 <pastorn> revenantphx: in an array
10:24:01 <revenantphx> It's not linear.
10:24:04 <benmachine> an array or a trie or a whatever
10:24:05 <revenantphx> Its 1000000 random values I believe.
10:24:15 <pastorn> revenantphx: write a function that takes 4 seconds to run
10:24:27 <pastorn> or give numbers that you feed to main
10:24:29 <revenantphx> how can i get ghci to *not* print the result?
10:25:00 <pastorn> revenantphx: if (z num == 0) then return () else return ()
10:25:12 <pastorn> that way you check the number AND do nothing about it
10:25:21 <revenantphx> what?
10:25:23 <benmachine> z num `seq` return ()
10:25:38 <monochrom> In the limit all you need for benchmarking is looking at the clock and ensuring full evaluation at the right time.
10:25:49 <revenantphx> I want this
10:25:50 <revenantphx> map (z3 0) [1..100000]
10:25:54 <pastorn> revenantphx: you want to iron out all the lazyness, that's what keeping your program slow
10:25:54 <revenantphx> and I dont want it printing out
10:26:27 <monochrom> Only the full-evaluation part puts a bit of restriction on the return type, and even then it is already done by the deepseq library and the type class NFData.
10:27:00 <j-invariant> can anyone tell mewhen are two natural transforms equal?
10:27:00 <monochrom> We're merely looking at (NFData a) => IO a -> IO TimeDiff
10:27:20 <revenantphx> I'm going to go see about a closed form
10:27:25 <j-invariant> revenantphx: for what
10:27:42 <revenantphx> see above
10:27:45 <monochrom> This is both more general and less work than "I only allow benchmarking of Int"
10:28:18 <j-invariant> revenantphx: I don't see it
10:28:22 <pastorn> revenantphx: use this: http://hpaste.org/42498/time_me
10:28:39 <pumpkin> tux_mark_5: in case you didn't see monochrom's question, why do you need to make it do different things based on the return type? benchmarking works on everything, or did you want a constraint of NFData?
10:29:50 <poop_toucher> hey i have a question. why does (((a ++ b) ++ c) ++ d) run in O(n^2) time but (a ++ (b ++ (c ++ d))) runs in linear time? i kind of have an intuition for why it does that but not like why specifically
10:30:09 <monochrom> In particular I don't see a reason to change the behaviour of >>=
10:30:17 <pastorn> poop_toucher: because list traversal is left-to-right
10:30:43 <pumpkin> poop_toucher: think of it as (++) runs in O(length of first argument)
10:30:52 <roconnor> poop_toucher: (++) takes time propotional to the first argument, but doesn't care about the second argument
10:30:54 <pumpkin> poop_toucher: in the first case, you're making the first argument longer and longer each time
10:31:06 <poop_toucher> hmmmm
10:31:08 <pumpkin> poop_toucher: the second case, you're doing it on the second argument
10:31:25 <roconnor> poop_toucher: also notice that the output shares the end bit with the input
10:31:39 <roconnor> opqdonut: but the first argument needs to be rebuilt and cannot be shared
10:31:43 <poop_toucher> roconnor: shares theend with the input?
10:31:55 <poop_toucher> oh i see
10:32:05 <roconnor> opqdonut: sorry that wasn't for you
10:32:07 <poop_toucher> ah but two lists can't share a prefix right
10:32:13 <poop_toucher> i see
10:32:15 <roconnor> poop_toucher: right
10:32:34 <roconnor> because the linked list structure is asymetrical
10:32:49 <pastorn> poop_toucher: define ++ yourself and you'll see why :)
10:33:08 <poop_toucher> yeah i sort of see because the second can be done with a foldr
10:33:19 <poop_toucher> and ++ itself can be done with a foldr
10:33:38 <pastorn> i meant writing out the recursion yourself ;)
10:33:47 * mjrosenb fails at implementing bash style word spliting :(
10:33:48 <pastorn> that's when you see it clearly
10:34:34 <poop_toucher> yeah i see now why that is so. thanks a lot guys
10:35:09 <monochrom> It seems all very noble to say "computer should give me freedom so I can do nicer things". My experience with people who say that is they don't do nicer things; they decompose their problems wrong and mix up concerns that should be separated, and that is only why they want so much more freedom.
10:35:34 <roconnor> poop_toucher: note using continuation-like things you can make any monoid (or monad) into a new one that automagically left (or right) associates the operation.
10:35:41 <roconnor> poop_toucher: Dlist does this for lists.
10:36:07 <mjrosenb> roconnor: that sounds neat.
10:36:36 <mjrosenb> roconnor: Dlist == difference list?
10:36:42 <roconnor> I think so
10:36:53 <poop_toucher> roconnor: cool. i think i know about difference lists
10:36:59 <ski> yeah .. but it's not *that* related to the logic programming concept
10:37:08 <poop_toucher> is that where you have (\xs -> xs ++ [1,2,3]) instead of like [1,2,3]
10:37:18 <ski> the other way around
10:37:25 <poop_toucher> ah
10:37:32 <roconnor> mjrosenb: Conor and I were talking once about adding runWriterLeft and runWriterRight to automatically left/right associate the monoid operation for a writer.
10:37:32 <pastorn> poop_toucher: (++) = (.)
10:37:34 <pastorn> iirc
10:37:45 <pastorn> maybe it was flip (.)
10:37:48 <ski> > ($ []) (([0,1] ++) . ([2,3,4] ++))
10:37:50 <lambdabot>   [0,1,2,3,4]
10:38:12 <pumpkin> roconnor: that's nice, and seems similar to edwardk's Reducer idea
10:38:38 <pumpkin> but I guess it's on the runner's side rather than the instance writer's side
10:38:40 <revenantphx> I think I've found the pattern for this function.
10:38:56 <revenantphx> however theres one weird irregularity.
10:39:04 <roconnor> revenantphx: nooooo
10:39:19 <revenantphx> probably a pattern in it though
10:39:24 <pastorn> revenantphx: fix!
10:39:27 <pastorn> @type fix
10:39:28 <lambdabot> forall a. (a -> a) -> a
10:39:41 <revenantphx> https://gist.github.com/751900
10:39:51 <revenantphx> basically, its some number in a group of 5 (which makes sense)
10:39:57 <revenantphx> however, some numbers are skipped.
10:40:05 <BONUS> @djinn (a -> a) -> (a -> b) -> b
10:40:05 <lambdabot> -- f cannot be realized.
10:40:14 <revenantphx> 11, 17, 23...
10:40:23 <BONUS> :t \f g -> g (fix f)
10:40:24 <lambdabot> forall a t. (a -> a) -> (a -> t) -> t
10:40:35 <BONUS> hehhh, foiled you, djinn!
10:40:50 <c_wraith> yes, djinn has this strange hangup about only creating total functions :)
10:41:50 <revenantphx> nub and friends are useful for debugging :)
10:42:59 <mjrosenb> revenantphx: do you have a definition of that function?
10:43:08 <revenantphx> I'm working out a recurrence.
10:43:17 <revenantphx> But it'd be defined as...
10:43:20 <roconnor> @oesis 0,1,2,3,4,6,7,8,9,10,12,13,14,15,16,18,19,20,21,22,24,25,26,27,28,31,32,33,34,35,37,38,39,40,41,43,44,45,46,47,49
10:43:20 <lambdabot>  Sequence not found.
10:43:40 <revenantphx> ah, one moment mjrosenb
10:43:48 <revenantphx> roconnor: try the numbers that *aren't* in the sequence?
10:44:00 <revenantphx> @oesis 5,11,17
10:44:00 <lambdabot>  Sequence not found.
10:44:11 <roconnor> @oesis 5,11,17,23,29,30,36,42,48
10:44:11 <lambdabot>  Sequence not found.
10:45:10 <revenantphx> wait.
10:45:11 <revenantphx> oh shit.
10:45:12 <revenantphx> dude
10:45:21 <ski> @oeis 6,28,496,8128
10:45:21 <lambdabot>  Sequence not found.
10:45:27 <revenantphx> wait... damnit nevermind
10:45:35 <revenantphx> oh
10:45:35 <revenantphx> http://oeis.org/search?q=5%2C11%2C17%2C23%2C29%2C30%2C36%2C42%2C48&language=english&go=Search
10:45:38 <mjrosenb> ski: wait, it doesn't know that one?
10:45:50 <revenantphx> >_>
10:45:54 * ski suspects something is broken
10:46:08 <revenantphx> its totally broken
10:47:11 <revenantphx> So basically, theres no pattern to the excluded numbers :|
10:47:39 <mjrosenb> revenantphx: not suprised.
10:48:56 <revenantphx> You can calculate the value by summing x/5^1+ x/5^2 + ... as long as the result is greater than or equal to one
10:49:00 <revenantphx> (with rounding)
10:49:12 <revenantphx> (flooring actually)
10:50:37 <revenantphx> it'd be nice if there was a closed form but I'm not sure at this point if there is.
10:50:45 <revenantphx> (if there is I probably can't solve for it)
10:50:46 <j-invariant> revenantphx: for what?
10:50:57 <revenantphx> up 5 lines.
10:51:05 <revenantphx> "You can calculate the value by summing x/5^1+ x/5^2 + ... as long as the result is greater than or equal to one"
10:51:13 <revenantphx> You really don't understand a backlog do you?
10:51:27 <j-invariant> no need to be an asshole
10:51:28 <jmcarthur> no need to be rude
10:51:35 <revenantphx> jmcarthur: you shoudl see what he's been pming me
10:51:39 <revenantphx> Also, stop pm'ing me. It's just annoying.
10:52:16 <revenantphx> I told him to read the backlog when he asked earlier and he's been pming me:
10:52:19 <revenantphx> j-invariant: you should just kill yourself
10:52:19 <revenantphx> j-invariant: fuck off faggot kill yourself
10:52:21 <jmcarthur> just use /ignore
10:52:26 <revenantphx> mmhm, I have been.
10:52:44 <revenantphx> Anyways.
10:52:47 <revenantphx> Any ideas?
10:52:48 <j-invariant> revenantphx: what the fuck?
10:53:27 <pumpkin> o.O
10:53:29 <jmcarthur> j-invariant, revenantphx: i'm not going to take sides. just don't do this in #haskell
10:53:31 --- mode: ChanServ set +o pumpkin
10:53:41 <revenantphx> I'm not bothering with him.
10:53:45 <revenantphx> Anyways, back to the problem :|
10:54:19 <pumpkin> revenantphx: I don't care what he says, but telling someone to go kill themselves is overreaction for just about everything they could do
10:54:24 <pumpkin> please act like an adult ;)
10:54:29 --- mode: pumpkin set -o pumpkin
10:54:33 <jmcarthur> pumpkin: i don't think that's what was intended there
10:54:34 <revenantphx> pumpkin: No no, he sent that to me XD
10:54:36 <revenantphx> I was quoting him.
10:54:38 <jmcarthur> i think it was quotes
10:54:42 <pumpkin> oh
10:54:45 <revenantphx> XD
10:54:47 <pumpkin> oh well, then j-invariant, same to you
10:55:22 <Botje> note: I have experienced something similar
10:55:36 <Botje> I got a /msg from somebody but they claim they didn't send it
10:55:43 <pumpkin> if you experience stuff like that, I'd recommend joining #haskell-ops to let us know
10:55:53 <Botje> it was a month ago
10:55:56 <pumpkin> ah
10:56:00 <Botje> could be the irc server being screwy or something :)
10:56:03 <revenantphx> Anyways... if finding a closed form isn't a solution, I need to work out how to get a fast version.
10:57:01 <revenantphx> 4s compared to 0s is not acceptable >_<
10:57:06 <merijn> Or you could do "/msg chanserv access #haskell list" and get a list of ops and msg one of those
10:58:12 <pumpkin> merijn: we mostly tend to hang out in #haskell-ops, and saying something in the channel there will catch our attention without having to wait on a possibly-idle op you chose to PM :)
10:58:21 <tux_mark_5> pumpkin: ghc for some reason doesn't seem to rewrite >>=
10:59:23 <tux_mark_5> pumpkin: i tried to rewrite other operators, and it worked; however with >>= i can't get for rule to fire
10:59:39 <pumpkin> tux_mark_5: can you elaborate on why you need to have specific behavior for certain types?
10:59:45 <pumpkin> your use case doesn't seem to support that
10:59:49 * ManateeLazyCat Hmm, sweet... hi guys, join those music : http://www.xiami.com/song/play?ids=/song/playlist/id/2839039/type/3
10:59:49 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
10:59:50 <revenantphx> this looks fun, but tricky
10:59:50 <revenantphx> http://www.codechef.com/problems/KX/
11:00:16 <tux_mark_5> pumpkin: i'm evaluating an expression which is supposed to take a long time to evaluate
11:00:31 <tux_mark_5> pumpkin: therefore i'd like to see how much each part of computation takes to evaluate
11:00:32 <pumpkin> tux_mark_5: yeah, but why have it change behavior based on type?
11:00:43 <ManateeLazyCat> @tell aristid I have update music-free video at Wiki page, and also hackage page, thanks for your suggestion. :) 
11:00:43 <lambdabot> Consider it noted.
11:00:53 <aristid> ManateeLazyCat: imma here
11:00:53 <lambdabot> aristid: You have 1 new message. '/msg lambdabot @messages' to read it.
11:01:13 <tux_mark_5> pumpkin: because functions which take expression as an argument are the ones which i'd like to benchmark
11:01:22 <ManateeLazyCat> aristid: Infact, Wiki page have that information : at http://haskell.org/haskellwiki/Manatee#Video
11:01:28 <pumpkin> tux_mark_5: and you can't live with other functions being benchmarked too?
11:02:00 <ManateeLazyCat> aristid: I have update docs in Manatee darcs, information will update when next version release.
11:02:00 <tux_mark_5> well, i don't want to see inner things of liftM2 being timed
11:02:28 <ManateeLazyCat> aristid: So you can watch music-free video now?
11:02:45 <aristid> ManateeLazyCat: yes
11:02:54 <ManateeLazyCat> aristid: Good. :)
11:03:17 <ManateeLazyCat> aristid: New module that video haven't : http://www.flickr.com/photos/48809572@N02/5237505999/lightbox/ :)
11:03:22 <aristid> ManateeLazyCat: it could use some explanation though, maybe just blend some text over it
11:03:47 <ManateeLazyCat> aristid: YouTube have 15 minutes limit
11:04:06 <ManateeLazyCat> aristid: Infact, my *first* video have text explanation, but got 35 minutes.
11:04:27 <merijn> I though youtube recently removed their time limit on videos?
11:04:43 <ManateeLazyCat> merijn: For everyone?
11:04:53 <aristid> merijn: only for partners i think
11:05:10 <aristid> ManateeLazyCat: but i thought of explanations that are just shown as "subtitles"
11:05:20 <merijn> Dunno, I don't use youtube much
11:05:37 <ManateeLazyCat> aristid: I haven't good tool do that. :)
11:05:55 <ManateeLazyCat> aristid: Maybe future get : manatee-video-editor. :)
11:07:09 <ManateeLazyCat> aristid: If you select 720p, you can see what i'm doing. :)
11:08:46 <aristid> ManateeLazyCat: and maybe it is not the best idea to show your ebook collection :)
11:09:00 <ManateeLazyCat> aristid: Why?
11:09:06 <ManateeLazyCat> aristid: It's not all. :)
11:09:28 <ManateeLazyCat> aristid: I have many ebooks under every category. :)
11:09:48 <ManateeLazyCat> aristid: I will search ebook from internet when i'm boring. :)
11:10:00 <aristid> ManateeLazyCat: because some people might find it immoral :P
11:10:17 <copumpkin> I've brought this up before :P
11:10:25 <ManateeLazyCat> aristid: Well, it's depend on what kind people looks those book. :)
11:10:44 <copumpkin> I don't really know why, but it feels odd to publicize one's book piracy in a huge channel that contains several authors
11:11:29 <aristid> yeah, it made me feel a bit uncomfortable even watching it
11:11:54 <copumpkin> regardless of my position on the matter, it just feels disrespectful
11:12:07 <noteventime> If it's meant as a manifestation it would be quite a reasonable place to publicise it
11:12:09 <ManateeLazyCat> aristid: Well, most book i download i just curious, i won't do that book tell me. :)
11:13:42 <ManateeLazyCat> aristid: Knife can cook, you can also kill, but you can not say that knife is evil, do you think I'm evil? ;p
11:13:58 <copumpkin> ManateeLazyCat: that doesn't really make sense
11:14:02 * ManateeLazyCat Great, install Manatee on another notebook. test it.
11:14:25 <j-invariant> ;4;
11:14:27 <copumpkin> ManateeLazyCat: it's more about not offending people who write books, of which there are quite a few in here
11:14:31 <ManateeLazyCat> copumpkin: My point is, many thing depend on you "how to do"
11:15:16 <ManateeLazyCat> copumpkin: Well, how to i say, i never send my book to other.
11:15:24 <ManateeLazyCat> copumpkin: I just download it from internet.
11:15:52 <ManateeLazyCat> copumpkin: To be honest, many Chinese people buy the book since watch my video.
11:16:01 <copumpkin> I know, we've been over this before
11:16:21 <ManateeLazyCat> copumpkin: Yes, i download book from internet, but i'm not send it to other people.
11:16:53 <ManateeLazyCat> copumpkin: I will tell my friends buy book to support author.
11:17:26 <Phyx-> Hi all.. exactly how stable is GHC 7? i'm getting segfaults 60% of the time on a tool that used to work fine with 6.12
11:17:46 <ManateeLazyCat> Phyx-: Wait next Haskell platform
11:17:57 <ManateeLazyCat> Phyx-: GHC-7 still have many bugs.
11:18:01 <djahandarie> Phyx-, I don't think it should be segfaulting
11:18:38 <Phyx-> djahandarie: the program basically *only* segfaults now
11:18:44 <benmachine> Phyx-: it has never segfaulted for me, which program?
11:19:15 <Phyx-> benmachine: it's an attribute grammar compiler that uses base and fgl
11:19:49 <Phyx-> ruler-core to be precise
11:20:07 <Phyx-> could be the tool, but it was working fine before
11:20:08 <djahandarie> Could ask ivanm, but he isn't here
11:20:37 <ManateeLazyCat> djahandarie: ivanm in sleeping. :)
11:20:59 <Phyx-> ManateeLazyCat: I don't really use HP, but afaik GHC 7 was released
11:21:30 <benmachine> GHC 7 *should* be stable now
11:21:45 <acowley> Phyx-: But HP adopting it will be a sign that a plurality of important libraries work with it
11:22:00 <monochrom> wait for HP just for the sake of knowing HP proves that GHC compiles some code correctly
11:22:11 <ManateeLazyCat> Phyx-: Yes, like acowley said.
11:22:29 <ManateeLazyCat> Phyx-: HP mean most libraries have test with new version ghc. 
11:22:31 <monochrom> you don't have to actually download HP
11:22:56 <djahandarie> Most of GHC 7's bugs are fairly odd type checking bugs to my knowledge
11:23:08 <djahandarie> I don't think it should start segfaulting on random pieces of code
11:23:37 <ManateeLazyCat> I will waiting ghc-7.0.2...
11:23:51 <Phyx-> ManateeLazyCat: well, i'm only dependent on fgl and base which changed. I assume base is stable
11:23:51 <mtnviewmark> and - while next HP isn't out - I've been building it with 7 and it is compiling and running fine
11:24:00 <alpounet> is there any library out there for parsing makefiles ?
11:24:08 <acowley> Okay, stupid space profiling question: I've got a big chunk of memory that's allocated by the GHC.Float module according to -hm, and I haven't found another profiling option that narrows it down any more. How can I chase it down?
11:24:19 <ManateeLazyCat> Phyx-: ghc-7.0.1 break my project. :)
11:24:36 <Phyx-> bleh, i guess I'll nuke the install
11:24:43 <Lemmih> acowley: Does -hc give any hints?
11:25:09 <DrDred> hi all, is anyone has problems with platform 2010.2 (ghc 6.12.3) with building bytestring 0.9.1.8? cabal update; cabal upgrade bytestring -> "Data\ByteString.hs:1959:21: Parse error in pattern" during building?
11:25:29 <acowley> Lemmih: Not really, -hc says it's GHC.Float.CAF
11:25:35 <Saizan> DrDred: 1) don't use cabal upgrade
11:25:46 <alpounet> acowley, you're most likely accumulating a lot of computations because of laziness
11:25:49 <acowley> Lemmih: I should have said, it's not a useful hint to me
11:25:53 <alpounet> such computations have to be strict
11:25:53 <acowley> alpounet: No this is constant
11:26:11 <Lemmih> acowley: How big is the memory chunk?
11:26:13 <c_wraith> cabal upgrade should have been named cabal breakstuff
11:26:21 <Saizan> DrDred: 2) bytestring-0.9.1.8's code has a bug, it won't build on ghc-6.12.x, i wonder if someone reported it
11:26:24 <acowley> I have a totally flat memory profile, I'm just trying to identify where each main piece is coming from
11:26:38 <acowley> Lemmih: about 17k
11:27:16 <acowley> I imagine it's something I'm doing, but I just want some help from GHC to find it so I can explain it
11:27:20 <Lemmih> acowley: In Haskell-land, that's not really a big chunk of memory (:
11:27:28 <acowley> I'm actually trying to use the memory profile to show off how tight this code is with memory
11:27:33 <acowley> and the biggest chunk is that Float CAF
11:27:41 <acowley> so it makes a less impressive presentation :)
11:27:45 <DrDred> Saizan: ok. thanks
11:28:02 <Mathnerd314> data X = forall a. (Eq a) => X a. Is there a function unX :: X -> <something involving Eq> ?
11:28:16 <acowley> If I could at least say, with some confidence, where it's coming from then I'd be fine
11:28:56 <Saizan> Mathnerd314: yes, unX :: X -> forall r. (forall a. Eq a => a -> r) -> r
11:29:10 <Phyx-> ok, that's odd.... on another machine with an identical installation it doesn't segfault..
11:29:27 <monochrom> Saizan wins :)
11:29:34 <Phyx-> one is 32bit and the other 64bit, but ghc still only produces 32bit exes on windows right?
11:29:36 <benmachine> Mathnerd314: I'm not sure you can do much useful with Eq
11:29:52 <Phyx-> could there be anything from an older install cauzing trouble? I still have 6.10 and 6.12 around
11:30:06 <benmachine> i.e. I'm not sure that there are any interesting functions of type (forall a. Eq a => a -> r)
11:30:16 <benmachine> you can't compare two X for equality
11:30:35 <Mathnerd314> benmachine: in my actual program I also have a Typeable constraint
11:30:39 <Saizan> Phyx-: different versions are pretty well separated, at least on linux
11:31:06 <Phyx-> Saizan: yeah, i thought so too, So i don't get why on 1 it segfaults and on the other it just works, lol
11:31:07 <benmachine> ah, that's more interesting
11:31:17 <Lemmih> invariant (X x) = x == x
11:31:39 <Phyx-> not unless ghc started producing 64bit code on windows without telling anyone, lol
11:31:56 <Saizan> checked the changelog?:)
11:32:05 <Mathnerd314> Saizan: can I put forall r. (forall a. Eq a => a -> r) -> r back into an X?
11:32:35 <Saizan> Mathnerd314: yes, pass it X
11:32:52 <Mathnerd314> ah, cool.
11:33:08 <Phyx-> Saizan: another oddity, two identical installs, same code, one produces a 5.23mb exe (the one that works) and the other produces a 2.90MB exe
11:33:11 <Phyx-> wtf..
11:33:26 * Phyx- scratches head and gives ghc a weird look
11:34:42 <acowley> Phyx-: dynamic linking?
11:35:32 <Phyx-> acowley: both are windows installs though, with defaults, why would it choose to dynamically link on one and not the othe
11:35:35 <ManateeLazyCat> acowley: Once you use dynamic linking, ghc will eat too much memory
11:35:52 <acowley> Phyx-: murphy's law?
11:35:54 <acowley> :P
11:35:56 <c_wraith> Phyx-, I've seen that on OS X, when the linker was trying to link 32 bit binaries against 64 bit libraries
11:36:08 <ManateeLazyCat> acowley: I mean dynamic linking library in *running* program
11:36:32 <Phyx-> acowley: in any case, the bigger exe that works fine on the 32 bit platform still segfaults when ran on the 64bit one. so I'm guessing it's the runtime
11:37:02 <Phyx-> c_wraith: yeah, looking at the changelogs now, afaik, ghc has no 64bit support on windows
11:37:34 <c_wraith> Phyx-, I've also seen it when libgmp was installed on one system, but not another...  I don't know what other environmental issues might cause it
11:37:41 <Mathnerd314> Saizan: is there a simpler type? :p 
11:38:05 <revenantphx> goddamn timeout TT_TT
11:38:27 * ManateeLazyCat Ubuntu every good on different hardware... 
11:38:41 <Phyx-> c_wraith: but usually in the exe everything is statically linked right? so it should work if i just copy the exe, which it doesn't. also it doesn't consistently segfault, just 60-70% of the time
11:38:45 <revenantphx> this is too slow: https://gist.github.com/751976
11:38:53 <Phyx-> the changelog mentions there's a new I/O system
11:39:05 <Phyx-> that is one possibility maybe
11:39:06 <revenantphx> I need to process about 10^7 inputs in 8s?
11:39:15 <Saizan> Mathnerd314: X itself :)
11:39:17 <c_wraith> There would be a lot of things going on.  Usually, it can be explained :)
11:39:22 <c_wraith> err, *could be
11:39:59 <Saizan> Mathnerd314: we'd need first class existentials for a simpler type, the one above is their church encoding
11:40:32 <Phyx-> hmm, is there anyway to get any more information other than "Segmentation fault/access violation in generated code"
11:41:21 <ManateeLazyCat> Phyx-: gdb?
11:41:37 <ManateeLazyCat> Phyx-: Use bt in gdb, you can get backtrace.
11:42:12 <Phyx-> doesn't it need debug symbols to produce anything meaningful?
11:42:18 <dafis> revenantphx: read the entire input in one piece as a lazy ByteString
11:42:46 <revenantphx> dafis: and then?
11:42:54 <naujas> http://imagetwist.com/lyz1x3okhl0y/sakes_1_.jpg.html
11:42:56 * Phyx- gives it a try
11:43:27 <dafis> revenantphx: and then work with that, the umpteen separate readLn's take far too long
11:43:36 <revenantphx> hm.
11:43:40 <dafis> revenantphx: it's SPOJ, isn't it?
11:43:51 <revenantphx> no, similar.
11:43:58 <dafis> codechef?
11:44:02 <revenantphx> yar
11:45:52 <dafis> revenantphx: probably you should use readInt to read the numbers
11:46:16 <revenantphx> mmk
11:46:29 <dafis> revenantphx: and use `rem` instead of `mod`, it's faster
11:46:34 <revenantphx> got it
11:47:00 <dafis> the big one is IO though, so definitely ByteStrings
11:47:16 <ManateeLazyCat> Off to bed, G'night all. :)
11:47:46 <acowley> yeah, read is killing you there
11:49:58 <Phyx-> according to windbg, the program is segfaulting on a nullpointer dereferencing. SO i think i'll stick with the theory that the new runtime has bugs :P
11:51:04 <Mathnerd314> Saizan: it seems like GHC doesn't infer RankNTypes?
11:51:59 <Phyx-> inference of higher rank types isn't decideable afaik
11:52:31 <Saizan> right
11:52:48 <Mathnerd314> so it doesn't even try? :-(
11:53:00 <copumpkin> Mathnerd314: there is no try
11:53:08 <dankna> do or do not?
11:53:30 <Saizan> Mathnerd314: you've to annotate lambdas, applications are usually fine
11:53:33 <Mathnerd314> copumpkin: there is for difficult problems (solutions that are "good enough")
11:53:56 <Saizan> Mathnerd314: and by lambdas i also mean function declarations
11:54:43 <Mathnerd314> Saizan: if I change Eq to Typeable, then GHC doesn't seem to infer the type of "flip unX cast"
11:55:33 <Mathnerd314> or wait, it does. nvm
11:56:00 <philo> hi
11:56:00 <Saizan> mh, that looks like it needs impredicativeness
11:56:33 <philo> is fold strictly equivalent to reduce . map ?
11:56:34 <monochrom> it's so easy to say "how about good enough" when one doesn't have to define it.
11:56:42 <philo> .i thinks not but want to be sure
11:57:18 <Botje> philo234: what do you mean by reduce?
11:57:19 <c_wraith> philo234, it'd be interesting to know what "fold" you mean.
11:58:20 <c_wraith> philo234, but in general, "reduce" in programming languages tends to be identical to haskell's "foldl"
11:58:26 <copumpkin> or foldl'
11:58:47 <c_wraith> Well.  The difference between those two isn't something that most languages have to deal with :)
11:58:49 <copumpkin> or just fold :)
11:58:49 <philo234> trying to get the wording right give me a sec lol
12:00:10 <monochrom> http://hpaste.org/41000/mapreduce
12:00:26 <djahandarie> Hahaha oh god
12:00:50 <Saizan> i thought that one was over!
12:00:51 <philo234> what is the diffence between mapreduce and fold ?
12:00:54 * Botje runs screaming
12:01:04 <roconnor> what did I miss?
12:01:16 <djahandarie> I forget what we decided that was... a catamorphism with a natural transformation?
12:01:40 <djahandarie> philo234, define 'mapreduce' since we don't use that term in Haskell
12:01:42 <monochrom> the course was over. but the general public will not cease to talk about "map, reduce" for another 10 years.
12:02:15 <philo234> from the link of monochrom 
12:02:27 <djahandarie> oh lmao
12:02:34 <djahandarie> philo234, that's some big pile of junk
12:02:39 <monochrom> I don't think this particular definition by the course has any mathematical footing at all.
12:02:41 <philo234> lol
12:03:18 <monochrom> It's just put together.
12:03:21 <philo234> so fold always imply a notion of sequence or order on the set we are folding on ?
12:04:24 <ski> @type let mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin | (turnAroundCond xin) = turnAroundFn xin | otherwise = reduceFn (mapFn xin) (mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn (wayAheadFn xin)) in mapReduce
12:04:24 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t) -> (t -> Bool) -> (t -> t2) -> (t1 -> t2 -> t2) -> t -> t2
12:04:37 <copumpkin> fold :: Group g => c g -> g
12:04:49 <copumpkin> or CommutativeMonoid m => c m -> m
12:04:50 <roconnor> cata :: Functor f => Algebra f a -> FixF f -> a -- this is a fold
12:04:54 <copumpkin> that's probably more useful
12:05:57 <philo234> ok completly lost
12:06:14 <ski> @type let mapReduce unit (*) f [] = unit; mapReduce unit (*) f (a:as) = f a * mapReduce unit (*) f as in mapReduce
12:06:14 <roconnor> what is the ytpe of that "mapReduce"  It looks like it has nothing to do with lists.
12:06:14 <lambdabot> forall t t1 t2. t -> (t1 -> t -> t) -> (t2 -> t1) -> [t2] -> t
12:06:30 <djahandarie> :t foldl
12:06:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:06:32 <copumpkin> :t Data.Foldable.foldMap
12:06:33 <ski> roconnor : see lambdabot above
12:06:33 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
12:06:46 <ski> (roconnor : the earlier one, i.e.)
12:06:46 <roconnor> ski: that is not the type for the function in the paste
12:06:50 <copumpkin> to me, that comes closest to mapReduce
12:06:52 <roconnor> oh
12:06:54 <roconnor> ok
12:07:10 <copumpkin> conceptually, at least
12:07:31 <djahandarie> philo234, vaugely, 'mapReduce' and folds are similar. It's just mapReduce is really overcomplicated and doesn't buy you very much of anything
12:07:34 <roconnor> philo234: firstly functors are the heart of recursive data types
12:08:12 <philo234> ok
12:08:13 <roconnor> philo234: for example the functor at the heart of [Y] is /\x -> Maybe (Y,x)
12:08:41 <philo234> ok let me try to simplify my problem
12:08:51 <copumpkin> roconnor: not sure that's a good way to get a beginner to understand it :P
12:08:53 <djahandarie> Really? You're going to use type lambdas and Mu to answer his question?
12:08:56 <roconnor> when we take the fixpoint of this functor Fix (/\x -> Maybe (Y,x)) we get something like Maybe (Y,(Maybe(Y,Maybe(Y...))
12:09:00 <alexsuraci> @pl \x y z = f (g x y) z
12:09:01 <lambdabot> (line 1, column 8):
12:09:01 <lambdabot> unexpected "="
12:09:01 <lambdabot> expecting pattern or "->"
12:09:07 <alexsuraci> @pl \x y z -> f (g x y) z
12:09:07 <lambdabot> (f .) . g
12:09:12 <philo234> i know that if the function is communative and assotiative then the oder of the folding is not important
12:09:18 <roconnor> djahandarie: I might as well if I'm going to use the word "Algebra"
12:09:20 <philo234> the same as in map
12:09:26 <djahandarie> roconnor, then don't use that either. :P
12:09:32 <philo234> is that correct ?
12:09:42 <copumpkin> philo234: yeah, that sounds good so far
12:09:43 <roconnor> philo234: folding has nothing to do with commutativity or associativity or even containers
12:10:01 <copumpkin> roconnor: it does for optimization
12:10:30 <ski> @type let mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn xin | (turnAroundCond xin) = turnAroundFn xin | otherwise = reduceFn (mapFn xin) (mapReduce mapFn wayAheadFn turnAroundCond turnAroundFn reduceFn (wayAheadFn xin)) in mapReduce head tail null . const
12:10:30 <lambdabot> forall a a1. a1 -> (a -> a1 -> a1) -> [a] -> a1
12:10:31 <copumpkin> an associative operation folded over something can be reassociated at will and broken up across different machines
12:10:34 <philo234> now the question is that when we dont have those property... doest it mean that "somewhere" we need an ordering on the set to "know" how to fold ?
12:10:40 <yrlnry> copumpkin:  do you find McBride's papers harder to read than other people's papers?
12:11:03 <roconnor> philo234: Are you intrested in folds of lists specifically?
12:11:06 <copumpkin> yrlnry: I find them amusing to read, but the naming in some of his code is often a little obtuse and takes a while to figure out
12:11:10 <copumpkin> yrlnry: how come?
12:11:49 <elliott> "Theoretical" question -- consider an infinite set of objects (doesn't matter what they are), uniquely identified by a natural number. Now imagine some operating system that implements a system call that takes such a number and gives back the corresponding object; the table cannot be changed, and it never will change. I think you can agree that implementing a lookup function in haskell as "unsafePerformIO . lookupWithSysCall" is, therefore, accept
12:11:50 <elliott> able (in an internal, low-level library), since the interface is pure in the... purest sense. Now imagine that it's accessing an object by its hash -- i.e., according to the pigeonhole principle, there /are/ collisions, but in practice (assume a very large hash) there are none. How acceptable would you consider exposing a lookup function for that data set as a pure function?
12:11:50 <yrlnry> I do, and I was wondering if it was just me.
12:11:55 <philo234> roconnor: well list are odered , what i want to know is how fold is define for unordered set
12:11:58 <acowley> It is true that there are options in how to define a fold over certain types
12:11:58 <copumpkin> yrlnry: not sure if you're aware, but if you have any questions for him he's actually on IRC in #epigram and #agda
12:12:00 <philo234> if that make sense
12:12:09 <yrlnry> copumpkin:  I did not know that, thanks.
12:12:09 <copumpkin> yrlnry: nah, I've definitely heard of others getting frustrated at his writing :)
12:12:12 <acowley> yrlnry: I have trouble with them sometimes, too
12:12:23 <sbahra> copumpkin <3
12:12:28 <elliott> i.e. theoretically, there are multiple values (lookup someHashGoesHere) could give, but in practice, there is only ever exactly one.
12:12:29 <copumpkin> hi sbahra :)
12:13:05 <yrlnry> There was an earlier draft of the "clowns and jokers" paper called "why walk when you can take the tube" which I found to be more McBride-like than other McBride papers, also harder to understand.  
12:13:07 <roconnor> philo234: it does, an unordered mutli-set is a type of species, and has an associated catamorphism
12:13:33 <monadic_kid> I'm still struggling to figure why part of my computation is left unevaluated, i've added more context code: http://haskell.pastebin.com/BgH0rDJy
12:13:38 <yrlnry> I couldn't figure out what he was getting at; when the clowns and jokers paper came out it was clear that it was the same paper, but written in a slightly less McBride style.
12:13:41 <roconnor> philo234: but it only "works" on commutative monoids or something similar.
12:13:46 <philo234> could someone point me to a good read on catamorphism and functor ?
12:13:47 <acowley> yrlnry: Part of the trouble is that he really is talking about more abstract things than most of us are comfortable with 
12:13:49 <yrlnry> But I can't figure out how to characterize what made the earlier one difficult.
12:13:51 <monochrom> elliott: I agree with unsafePerformIO for this.
12:14:09 <yrlnry> acowley:  Could be.
12:14:30 <monochrom> In fact the table may as well be a trig function.
12:14:45 <elliott> monochrom: For the hash-accessing function? Yeah, I thought so; it's just that it *does* violate purity "in theory", since if you can get a hash H with two objects A and B that hash to it, (lookup H) == A == B by defined semantics even though A /= B.
12:14:57 <roconnor> elliott: unsafePerformIO seems reasonable here
12:15:08 <monochrom> if you determine that the probability is low, I don't mind.
12:15:12 <elliott> right. so the language becomes "pure, modulo hash collisions" :-)
12:15:13 <acowley> yrlnry: I still don't really understand Clowns to the Left, actually
12:15:24 <elliott> Like a lot of things, really (git springs to mind).
12:15:34 <roconnor> elliott: the hardware is more likely to violate purity due to a wayward cosmic ray than the Hash collision
12:15:38 <acowley> yrlnry: I've read it a few times, and after a strong start I lose touch with it
12:15:49 <elliott> roconnor: that's what they said about MD5 :-)
12:16:09 <roconnor> fair
12:16:18 <elliott> roconnor: (also, ECC! although i suppose a whole /bunch/ of cosmic rays flipping more than two bits is more likely than an N-bit hash collision for large N)
12:16:30 <srobertson> given independently defined "class A" and "class B", where an instance of B can be defined entirely in terms of A, can you make all instances of A also instances of B in one statement? (i.e. "instance A => B where ...")
12:16:48 <roconnor> elliott: btw, I've had md5sum return two different values on the same input
12:16:51 <roconnor> http://r6.ca/blog/20041110T014300Z.html
12:16:59 <philo234> could someone point me to a good read on catamorphism and functor ?
12:16:59 <elliott> roconnor: good job :P
12:17:20 <acowley> roconnor: never do that again
12:17:27 <tonkman> is it possible to write \a b -> (a ++ " ") ++ b shorter
12:17:29 <elliott> roconnor: now what about "put :: Hash -> Object -> ?" :-P semantically, it's a nop; the system already knows about all possible hashes and their values ... but it would serve to put (hash => obj) into the system's cache
12:17:46 <roconnor> elliott: you said the table was immutable
12:17:47 <djahandarie> path[l], http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
12:17:50 <djahandarie> Oops
12:17:52 <elliott> roconnor: the table is platonic
12:17:53 <djahandarie> philo234, http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
12:17:59 <elliott> roconnor: for every object X, it's (hash(X) => X)
12:18:01 <roconnor> sure make it return ()
12:18:01 <path[l]> heh
12:18:15 <elliott> roconnor: heh ... I think I just made IO disappear ...
12:18:17 <roconnor> elliott: since it effecitvely does nothing and no one should ever use it
12:18:20 <elliott> where did it go
12:18:24 <djahandarie> irssi should really not count joins as activity -_-
12:18:26 <elliott> roconnor: it's a rather important optimisation, though
12:18:29 <philo234> djahandarie: any books ?
12:18:39 <roconnor> elliott: what is it used for?
12:18:50 <elliott> roconnor: (get hash) could churn for an awful long time if the system has no idea how to get that object
12:18:58 <elliott> roconnor: after (put hash obj), it'll "probably" be instant
12:19:06 <elliott> it is, as I said, a mere optimisation... but an important one
12:19:10 <elliott> semantically, put does squat
12:19:20 <roconnor> elliott: what does get hash do when there are no table entries?
12:19:38 <monadic_kid> just added a bit more context, trying to figure out why is some computation in nextEnemy is left unevaluated: http://haskell.pastebin.com/xSt8xfUF
12:19:40 <elliott> roconnor: ask other computers on the network about it :-)
12:19:48 <djahandarie> philo234, books?! Who needs 'em.
12:19:57 <elliott> roconnor: but, err, from a platonic point of view, I suppose it'd churn out the first object it bruteforces that matches the hash
12:20:00 <philo234> lol
12:20:09 <philo234> djahandarie: i do
12:20:13 <elliott> roconnor: (in reality it'd probably stop the program and say "Hey, I don't know how to get this.", but that's invisible to the program)
12:20:22 <roconnor> elliott: now you are violating purity I feel.
12:20:34 <elliott> roconnor: at what point?
12:20:41 <elliott> <elliott> roconnor: (in reality it'd probably stop the program and say "Hey, I don't know how to get this.", but that's invisible to the program)
12:20:48 <elliott> roconnor: you can view that like ghc outputting <<loop>>
12:21:19 <elliott> roconnor: or did you mean another point?
12:21:21 <roconnor> elliott: either your table looks up the "first" valuing having a certain hash, or it computes "the known value" having the hash.  You can't have a table do both.
12:21:36 <roconnor> if you see what I'm getting at
12:21:37 <acowley> tonkman: (intercalate " " .) . (. (:[])) . (:)
12:21:40 <elliott> roconnor: well the model here is that every hash has exactly one object
12:21:55 <elliott> roconnor: (get hash) gets that object by whatever means -- we can assume that it iterates through every object until it finds one that matches
12:22:03 <tonkman> acowley: thanks
12:22:04 <elliott> roconnor: as i said, this is pure up to hash collisions
12:22:36 <roconnor> ya, but the iteration procedure ought to be disallowed in your model
12:22:45 <roconnor> you are trying to have your cake and eat it too.
12:22:48 <elliott> roconnor: well, it's an implementation detail
12:22:58 <elliott> roconnor: get isn't written in Haskell
12:23:30 <elliott> roconnor: so i don't see how this is impure yet
12:23:37 <Saizan> monadic_kid: i'd rather wonder why some computation in nextEnemy is evaluated at all
12:23:59 <roconnor> either you treat hashes are they actually are and allow searching for values with a hash, or you treat hashes as idealized objects/functions and you don't allow searching
12:24:03 <roconnor> IMHO
12:24:16 <elliott> roconnor: ah, there's no "searching" as such I don't think
12:24:27 <Saizan> monadic_kid: the only source of strictness is the pattern match against (gc,gd) there
12:24:29 <roconnor> elliott: searching is how you defined the semantics of get
12:24:49 <elliott> roconnor: the "platonic model" is: every object has one hash, hash(X). get hash(X) = X. -- an example of how this could be implemented is: get(hash) { while(obj=nextobj()) if(hash(obj)==hash) return obj }
12:24:54 <elliott> roconnor: but that's not part of the actual model
12:25:46 <Saizan> monadic_kid: i don't think that's enough to propagate to the rest
12:25:55 <Mathnerd314> Saizan: this is still confusing. Here's where I started: http://hpaste.org/42501/existential_qundrary
12:26:05 <elliott> roconnor: platonic model: put :: Hash -> Object -> () does absolutely nothing. -- a "practical" implementation would have get just be a table lookup, and if the hash isn't found, would evaluate to _|_ (by *cough* alerting the user and stopping the program). and put would add a new entry into the table.
12:26:09 <monadic_kid> Saizan: i've added strictness annotations to the recoard which has the field entities
12:26:18 <elliott> roconnor: (one can see this as get taking "infinite time" to find a hash it doesn't know about, i.e. _|_)
12:26:21 <monadic_kid> Saizan: but it doesn't evaluate everything
12:26:30 <Mathnerd314> (s/qundrary/quandary)
12:26:55 <monadic_kid> Saizan: i tried using !, $!, seq in various places without much luck
12:27:00 <Saizan> monadic_kid: try with strict tuples, or bang patterns
12:27:05 <elliott> roconnor: so I don't see how the semantics are impure?
12:27:15 <merijn> Given "data Foo = forall a. (Bar a) => Foo a" is there any way to turn a Foo back into an a?
12:27:34 <roconnor> let me try this tack
12:27:53 <Saizan> Mathnerd314: unX (X a) k = k a
12:27:53 <roconnor> get "foo" -> _|_ if  "foo" isn't in the table
12:28:03 <roconnor> then I do put "foo" which puts it into the table
12:28:12 <roconnor> er
12:28:16 <elliott> roconnor: well, (put something-that-hashes-to-"foo")
12:28:17 <Saizan> Mathnerd314: ah, wait
12:28:21 <roconnor> get 123 -> _|_ if  "foo" isn't in the table
12:28:24 <Saizan> Mathnerd314: you changed the type :)
12:28:26 <elliott> roconnor: I was wrong put is :: Object -> (), not Hash -> Object -> ()
12:28:29 <elliott> right yeah
12:28:31 <monadic_kid> Saizan: I did try bang patterns in various places without much, i guess it wouldn't make a difference if i tried using strict tuples?
12:28:34 <roconnor> then I do put "foo" which puts it into the table
12:28:39 <Saizan> Mathnerd314: that unX is not possible
12:28:44 <monadic_kid> Saizan: *without much luck
12:28:46 <roconnor> now when I do get 123" I get "foo
12:28:50 <elliott> roconnor: but note that the way this is related to the _semantic_ model is that it's just get 123 taking a very long (infinite) time to find 123
12:28:57 <roconnor> see how the return value of get has changed
12:28:58 <elliott> roconnor: time is, after all, an implementation detail
12:29:07 <roconnor> or if you want
12:29:09 <elliott> roconnor: nope, the first get returns "foo", it just never gets around to it
12:29:24 <roconnor> get 123 -> "first value with has of 123" if  "foo" isn't in the table
12:29:25 <Saizan> monadic_kid: strict tuples would propagate the strictness, it depends on how deep you went with bang patterns.
12:29:27 <elliott> put is an optimisation to help your programs run in less than infinite time
12:29:28 <roconnor> then I do put "foo" which puts it into the table
12:29:38 <roconnor> now when I do get 123 I get "foo"
12:29:43 <elliott> roconnor: the model is that there is only one thing that hashes to 123, and it's "foo"
12:29:43 <roconnor> see how the value of get 123 has changed
12:29:46 <roconnor> it isn't pure
12:29:52 <elliott> roconnor: I agree that this is not true in practice, but as I said, pure /up to hash collisions/
12:29:57 <elliott> which is what I said from the start
12:31:03 <roconnor> elliott: fine, the short answer is your operation of get isn't pure and you shouldn't use unsafePeformIO
12:31:09 <monadic_kid> Saizan: I'm not using a tuples every where, I'm using monad transformer stack, I'm only using the tuple when I extract the world from my monad and use it in the timer callbacks. if that makes sense?
12:31:25 <elliott> roconnor: I still don't agree, though -- can you demonstrate how it's impure when hash X is assumed to have a unique value for all X?
12:31:31 <roconnor> elliott: the long answer is in any of the models of computation where you could make sense of what you are doing, what you are trying to do still doesn't make sense.
12:31:56 <Saizan> monadic_kid: i'm just talking about nextEnemy
12:31:58 <elliott> I liked it better when you and monochrom agreed with me :-)
12:32:23 <Mathnerd314> Saizan: right, so then I made version 2: http://hpaste.org/paste/42501/existential_quandary#p42502
12:32:36 <monadic_kid> Saizan: sure, just mentioning that I don't use tuples for my world representation
12:32:43 <elliott> roconnor: I guess I just want to understand /why/ it's impure if we completely ignore hash collisions.
12:32:54 <Mathnerd314> Saizan: but "combine" fails to typecheck :-/
12:33:13 <copumpkin> Mathnerd314: not surprising
12:33:16 <Saizan> Mathnerd314: if you could've passed id as second argument to unX you could've written the original unX :)
12:34:12 <copumpkin> omg fromJust . cast
12:34:16 <roconnor> elliott: because ignoring hash collisions is usually a consequence of picking a model of computation either with an oracle or with computation restricted to poly-time functions.
12:34:40 <elliott> roconnor: But we agreed to ignore hash collisions at the /start/. I agree it is demonstrably not true if hash collisions exist.
12:34:41 <roconnor> elliott: I'm only familiar with the latter, and in that case your semantic definition of get isn't a poly-time function.
12:34:43 <Mathnerd314> copumpkin: what? perfectly reasonable. :p
12:34:59 <alpounet> @hoogle ByteString -> ByteString -> ByteString
12:34:59 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
12:34:59 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
12:34:59 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
12:35:00 <elliott> roconnor: But if we assume that hash, say, outputs an opaque, unique entry for every single object?
12:35:04 <alpounet> no.
12:35:08 <alpounet> isn't there any 'replace' ?
12:35:10 <elliott> roconnor: I do not see how it is impure then at all.
12:35:10 <Mathnerd314> Saizan: so I don't see how to remove id
12:35:14 <elliott> alpounet: nope.
12:35:41 <roconnor> elliott: hmm
12:35:47 <roconnor> maybe if you do that it is okay
12:36:07 <roconnor> semantically
12:36:09 <elliott> roconnor: right ... because _|_ can be interpreted as the right value, returned after infinite time (tongue firmly in cheek here)
12:36:10 <Mathnerd314> copumpkin: would you prefer unsafeCoerce?
12:36:16 <roconnor> no
12:36:20 <copumpkin> Mathnerd314: I'm just wondering why you're doing this :P
12:36:28 <roconnor> acutally
12:36:30 <copumpkin> Mathnerd314: also, why not just pattern match in combine and remove the unX indirection?
12:36:32 <elliott> roconnor: well, no, not really. but you can't distinguish (get 123 => _|_) between (get 123 => "foo")
12:36:35 <dafis> alpounet: http://hackage.haskell.org/package/stringsearch
12:36:50 <elliott> because anything that can recognise "foo" gives you _|_ when called on _|_. I think.
12:36:57 <Saizan> Mathnerd314: http://hpaste.org/paste/42501/existential_qundrary_annotati#p42503
12:37:04 <Mathnerd314> copumpkin: because I'm actually using lub instead of mappend
12:37:21 <copumpkin> Mathnerd314: I don't see how that changes it :o
12:37:28 <copumpkin> combine (X a) (X b)
12:37:32 <alpounet> yeah just saw this dafis 
12:37:32 <copumpkin> gives you those same constraints on a and b
12:37:33 <alpounet> thanks
12:37:34 <copumpkin> directly
12:38:01 <Mathnerd314> copumpkin: I can't pattern-match, because one of those might be _|_
12:38:13 <elliott> roconnor: I'd love to be proved wrong, though ... even if it would mess up my design :)
12:38:27 <Mathnerd314> Saizan: thanks! they look so similar :p
12:38:44 <merijn> Saizan: Would it be possible to add extra data to the X datatype which would be able to get the actual original value out rather then the "forall r. (forall a. (Monoid a, Typeable a) => a -> r)" indirection?
12:38:58 <Saizan> Mathnerd314: you're still strict in the X constructor of a
12:39:06 <copumpkin> merijn: you mean data X a = X a? :P
12:39:11 <copumpkin> and forget all that nasty Typeable stuff? :P
12:39:15 <Saizan> Mathnerd314: and you can't do anything about that because you need the dictionary stored in there
12:39:36 <copumpkin> why use the type system to guarantee your invariants when you can check them at runtime!
12:39:40 <Mathnerd314> Saizan: but I can do unamb with the opposite, and be happy
12:40:23 <copumpkin> Mathnerd314: I'm curious what you're doing with this machinery
12:40:43 <Mathnerd314> copumpkin: implementing a programming language
12:40:53 <benmachine> elliott: maybe you could have that as a conceptually pure interface, but as a user of the interface you'd more or less expect get to return _|_ p much whenever it likes
12:40:59 <Mathnerd314> copumpkin: and it has lub at the center of it :D
12:41:03 <merijn> copumpkin: Basically I want a heterogeneous tree, now the simplest way seems to me to use "data Foo = forall a. (Bar a) => Foo a" and creating a Foo tree, just wondered if you could get the original type back somehow. Which I figured was tangentially related to Mathnerd314's examples
12:41:03 <merijn> )
12:41:05 <benmachine> elliott: you lose all the benefits of purity pretty much
12:41:07 <copumpkin> Mathnerd314: hmm, still seems odd to need this existential stuff :P
12:41:13 <roconnor> elliott: do extensionally equal functions hash to the same token?
12:41:19 <Mathnerd314> copumpkin: that's for interfacing with Haskell
12:41:20 <roconnor> elliott: or are functions not hashable?
12:41:23 <copumpkin> merijn: but no, you can't get the original type back
12:41:31 <elliott> roconnor: well. ouch. why did you have to go and throw that at me :-)
12:41:40 <roconnor> elliott: I want to break you
12:41:42 <elliott> roconnor: let's say that hashes are opaque... and non-comparable
12:41:52 <elliott> roconnor: so the answer is: YOU CAN'T TELL! But obviously YES by the semantics.
12:42:01 <roconnor> Just for your semantics
12:42:16 <elliott> benmachine: well actually, unless you construct your own special hash, you're likely to have been given it.
12:42:31 <elliott> benmachine: so (get X) would return something useful in the majority of practical usages
12:42:37 <elliott> whoops
12:42:39 <roconnor> so semantically we can solve the halting problem.
12:42:44 <roconnor> (which is fine)
12:43:00 <elliott> roconnor: yep!
12:43:01 <roconnor> oh wait
12:43:04 <elliott> roconnor: except not really
12:43:08 <merijn> copumpkin: Ok, so I will basically have to stuff everything into typeclass or implement my own "type" data type and store that with the value (and unsafeCoerce abusage)?
12:43:08 <elliott> roconnor: since you can't say h1==h2
12:43:10 <roconnor> can hash values be compared for equality?
12:43:11 <roconnor> ah
12:43:15 <Saizan> merijn: if you've a closed universe you can embed a gadt representing the original type, which you can then recover by pattern matching on it
12:43:26 <elliott> roconnor: no, i just declared that to be so to get around your damn functions :)
12:43:30 <copumpkin> merijn: usually if you need existentials for that stuff, you're doing it wrong :P
12:43:31 <elliott> so you weren't missing anything
12:43:37 <copumpkin> merijn: but yeah, all that machinery is basically Data.Dynamic
12:43:41 <copumpkin> so no need to reimplement it
12:43:44 <benmachine> elliott: well, maybe, but practically you have behaviour that depends on execution order, which is unpleasant
12:43:52 <copumpkin> Mathnerd314: why not use Data.Dynamic by the way?
12:43:56 * monochrom welcomes all solutions to the halting problem :)
12:44:02 <elliott> benmachine: well. I might make it "put :: Object -> a -> a".
12:44:11 <elliott> benmachine: the semantics being "put _ x = x" :)
12:44:16 <merijn> copumpkin: Well, just using typeclasses + existentials might be enough
12:44:19 <monochrom> Acta Informatica. Data Dynamica. :)
12:44:23 <Mathnerd314> copumpkin: no way to have constraints
12:44:30 <roconnor> elliott that doens't seem worse than seq
12:44:39 <roconnor> *doesn't
12:44:44 <elliott> indeed...
12:44:48 <monochrom> Data.Dynamica.Principia.Mathematicia
12:45:10 <roconnor> elliott: I could be good with this, in as much as I'm good with seq, which I'm not good with by the way. :D
12:45:11 <copumpkin> Mathnerd314: and a GADT doesn't serve your purpose here?
12:45:19 <elliott> roconnor: i'm disappointed that now my hashes are totally opaque though, haha...
12:45:30 <copumpkin> every time you use existentials and typeable god clubs a little kitten
12:45:34 <merijn> monochrom: Will, you could just invent a "super Turing" machine which could solve the halting problem in ordinary Turing machines. But then you couldn't guarantee your super Turing machine would terminate :p
12:45:43 <elliott> roconnor: I might as well just tell you what I'm trying to do -- figure out the actual semantics for my pipe-dream-OS-project...
12:45:47 <Mathnerd314> copumpkin: what, a huge ADT like Int Int | Double Double | ...
12:45:50 <elliott> roconnor: actually, wait, I have no put!
12:45:53 <roconnor> elliott: what is the type of get again?
12:45:59 <elliott> roconnor: forget put ever existed :)
12:46:03 <elliott> roconnor: get is (Hash -> Object).
12:46:08 <elliott> Object can be anything you want really.
12:46:09 <roconnor> what is Object?
12:46:11 <copumpkin> Mathnerd314: a GADT, like Con :: a -> Term a
12:46:11 <elliott> it's just a placeholder.
12:46:12 <elliott> haha
12:46:30 <monochrom> yeah, something about super Turing machine not able to solve problems about super Turing machine
12:46:31 <roconnor> ya, but if I don't know that it is it is pretty useless
12:46:35 <elliott> roconnor: well, it's (Hash -> (a:Type, a)) conceptually.
12:46:42 <elliott> roconnor: or similar.
12:46:48 <copumpkin> Mathnerd314: well, not that, but you get what I mean?
12:47:09 <roconnor> sure, but that Exists a. a is isomorphic to () (pamerically speaking)
12:47:29 <Mathnerd314> copumpkin: yeah, I tried it earlier and ran into constructor conflicts. But those have probably gone away now.
12:47:36 <roconnor> Hash -> Data.Dynamic.Dynamic is more like what you want I guess
12:47:38 <elliott> roconnor: well, okay, (Hash -> Foo) where data Foo = Integer Integer | String String | ...
12:47:46 <roconnor> @hoogle Dynamic
12:47:47 <lambdabot> module Data.Dynamic
12:47:47 <lambdabot> Data.Dynamic data Dynamic
12:47:47 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
12:47:59 <elliott> right, yeah
12:48:18 <roconnor> in fact, semantically Hash and Dynamic are isomorphic
12:48:29 <elliott> and hash is id :-D
12:48:32 <roconnor> yes
12:48:49 <elliott> roconnor: actually I'm wondering now if my capability-esque security mightn't be better served by having no get at all...
12:49:12 <elliott> and just passing things around
12:49:12 <copumpkin> Mathnerd314: I dunno, I just feel that there are very few problems that need the kind of unsafe stuff you're doing, but maybe you are in one of those domains :P
12:49:25 <copumpkin> I usually try to guarantee my invariants locally with more expressive types and then provide friendlier wrappers to the outside
12:49:27 <Mathnerd314> copumpkin: main problem: what's the type for eval?
12:49:36 <copumpkin> eval :: Term a -> a ? :P
12:49:46 <roconnor> elliott: my brother was telling me about a talk about a systems where all data is immutable and is refered to by hash.
12:49:56 <elliott> roconnor: venti?
12:50:01 <roconnor> I don't remember
12:50:02 <copumpkin> trenta!
12:50:07 <elliott> probably that. by the plan 9 guys.
12:50:26 <Mathnerd314> copumpkin: but it's dynamically typed; a method dispatch could return pretty much any type
12:50:51 <elliott> roconnor: the basic model of my OS is that every single value in the system -- well, not integers and whatnot -- is persisted and loaded onto and from disk automatically... and identified by a big, globally unique hash; the disk, in turn, is considered as a kind of cache for the entire network of systems running it
12:50:54 <roconnor> elliott: I aplaud your capabilities idea, but I'd be inclinded to hide it all under the hood in the runtime systems.
12:50:58 <elliott> but integrating this nicely into a pure language seems... a bit difficult
12:51:07 <Mathnerd314> copumpkin: carrying around the entire state in the type system is currently too much work
12:51:15 <copumpkin> hm okay
12:51:26 <elliott> I don't really want all object accesses to be through the IO monad, it'd make it a lot less useful
12:51:30 <copumpkin> so X is your language Term?
12:51:33 <merijn> Mathnerd314: Have you tried looking at how Berp does this?
12:51:53 <copumpkin> if you're modeling a dynamically typed language, then I can understand what you're doing
12:51:54 <merijn> I figure Berp has largely the same problems?
12:52:40 <Mathnerd314> merijn: I'd expect not; it *translates* to haskell, whereas I interpret it
12:53:26 <merijn> But then they'd still need to handle arbitrary return types in the generated Haskell
12:53:47 <roconnor> elliott: Your ideas are intriguing to me and I wish to subscribe to your newsletter.
12:53:55 <merijn> You have no guarantee the python code doesn't much with a function causing it to return different types midway during execution
12:54:11 <elliott> roconnor: Check back in 20 years, maybe I'll have written a bootloader.
12:54:22 <merijn> elliott: Story of my life :D
12:54:38 <roconnor> elliott: what distro do you use?
12:54:55 <elliott> roconnor: Debian, I keep being tempted by NixOS though.
12:55:00 <Mathnerd314> merijn: from a random glance, it looks like it doesn't use GADT's
12:55:05 <roconnor> you should switch to NixOS
12:55:36 <elliott> roconnor: Stop tempting me. :)
12:55:43 <roconnor> I did
12:55:46 <merijn> If you're going to write an unreasonably incompatible new OS you might as well go for Plan9 :p
12:56:00 <merijn> To get used to lack of support :p
12:56:00 <elliott> merijn: Plan 9 is not even half as ambitious as my psychiatric disorder^W^Wambition.
12:56:14 <elliott> roconnor: But, uh, uh, it's C++!
12:56:17 <elliott> I'm allergic to C++!
12:56:19 <Mathnerd314> Saizan: actually, that doesn't seem to be working
12:56:48 <roconnor> elliott: I've never looked at the source for nix :D
12:57:26 <elliott> roconnor: Shh, I'm trying to think of another excuse.
12:57:49 <Saizan> Mathnerd314: thinking about it, it's strict in b too, since cast needs both dictionaries
12:58:11 <roconnor> elliott: You can do it like I do, wait for a debian upgrade to fail due to lack of diskspace and stare at an unsuable computer for a few days.
12:58:35 <elliott> roconnor: You went a FEW DAYS without a COMPUTER?! Write a book about your experiences, I could never manage that ...
12:58:54 <elliott> /dev/sda1             223G   13G  199G   6% /
12:59:01 <elliott> I don't think I'm going to run out of disk any time soon though.
12:59:04 <roconnor> download more movies
12:59:19 <roconnor> ya, my problem was a few years ago
12:59:20 <elliott> roconnor: as a way to force myself to use NixOS? :-D
12:59:24 <roconnor> smaller disks back then
12:59:48 <Mathnerd314> Saizan: no, it doesn't typecheck
13:00:03 <Saizan> Mathnerd314: paste the error
13:00:14 <elliott> roconnor: more seriously though, I'm not sold on Nix's "configure everything through here" method when applied to such complex configurations as we see on modern unix
13:00:18 <monadic_kid> Saizan: tried using strict tuples, still the same
13:00:37 <aristid> roconnor: disks are getting smaller again due to the popularity of SSDs :)
13:01:04 <Mathnerd314> Saizan: http://hpaste.org/paste/42501/error#p42504
13:02:32 <earthy> elliott: the thing is that with NixOS, there is proof that it actually can be made to work
13:02:50 <Saizan> Mathnerd314: try "unX b (\y -> fromJust (cast y))"
13:03:00 <elliott> earthy: Yeah... but say there's a package with not-so-good configuration support. Is there an easy way to override it with some literal configuration, as NixOS stands now?
13:03:13 <elliott> Also I don't really like upstart, but that's more a personal failing than a problem with NixOS. Sort of.
13:03:46 <Mathnerd314> Saizan: same error
13:06:21 <monadic_kid> Saizan: if I change "modL entities (map updateAnim) gd" to "modL entities (\x -> trace "foo" x) gd" i see the trace but as soon I try "modL entities (map (\x -> trace "bar" x)) gd" it never gets evaluated
13:06:41 <monadic_kid> Saizan: the list is definately not empty
13:07:32 <elliott> See, silence gives me a perfect reason not to use NixOS. :-)
13:09:20 <mreh> has anyone got a nice haskell syntax vim plugin?
13:09:26 <Saizan> Mathnerd314: sorry, this works http://hpaste.org/paste/42501/existential_qundrary_annotati#p42505
13:09:46 <mreh> all the ones I find are pretty incomplete, gedit does a better job for heaven's sake
13:10:42 <unkanon_> lol gedit
13:10:51 <unkanon_> here at work our joke victim is Kate
13:10:51 <Saizan> monadic_kid: so nothing is evaluating the elements of the list, only the head
13:11:06 <Saizan> monadic_kid: well, the outhermost constructor, or at most the spine
13:11:13 <aristid> is mixing type families and fundeps possible? :)
13:11:17 <djahandarie> Yes
13:11:26 <djahandarie> I think it breaks sometimes though
13:11:40 <djahandarie> Eventually they will be written to use the same thing and that won't happen, I think
13:11:55 <djahandarie> Not sure if that already has happened or is going to happen anytime soon though
13:12:00 <unkanon_> mreh: gedit does a better job at what, exactly?
13:13:16 <Mathnerd314> Saizan: yay, it compiles and runs and works :-)
13:14:27 <Mathnerd314> well, almost
13:14:47 <Mathnerd314> but I think that's because I broke something
13:15:01 <mreh> unkanon_: highlighting haskell
13:15:04 <mreh> out of the box
13:15:42 <aristid> djahandarie: so is it a bad idea?
13:16:12 <aristid> djahandarie: i find that sometimes one is more beautiful than the other, and sometimes it's the other way round
13:16:32 <djahandarie> aristid, I think it's fine, IIRC the bugs only happens when you're doing weird stuff
13:18:02 * augur hugs everyone
13:18:02 <djahandarie> I think I normally use fundeps whenever I need to express mutual dependencies
13:18:09 <augur> you guys are the best channel ever :\
13:18:20 <unkanon_> mreh: yeah vim does do a bad job at that
13:18:22 <djahandarie> sup augur
13:18:36 <augur> djahandarie: frustration with unity/blender
13:18:44 <augur> and the community for each
13:19:07 <djahandarie> Unity/blender? Isn't that 3D stuff?
13:19:13 <djahandarie> Game engines?
13:19:31 <augur> yes
13:19:36 <dankna> what's the frustration?
13:19:54 <augur> a bunch of different crap.
13:20:10 <augur> shit thats trivial in lightwave is damn near impossible in blender
13:20:13 <augur> not for any good reason
13:20:15 <augur> just because
13:20:27 <proq> blender isn't very easy to use
13:20:38 <augur> no, its not
13:20:51 <augur> thats partly the problem im having
13:21:01 <dankna> well
13:21:21 <dankna> Blender is supposed to be (I'm told by people who are fans of it) its own thing, not a clone of Lightwave, Maya, or any other program
13:21:26 <dankna> with its own workflows
13:21:39 * djahandarie is actually wondering what the fundep/typefam situation is now
13:21:56 <djahandarie> I don't think it'd be TOO hard to get something that transforms fundeps into type families
13:21:57 <augur> dankna: sure, but that doesnt mean that the end result should be almost impossible to achieve
13:22:01 <dankna> oh, I agree
13:22:03 <copumpkin> djahandarie: what about it? I don't think it's really changed
13:22:07 <dankna> but that's open-source GUI programs for you
13:22:11 <copumpkin> apart from a brief period of allowing superclass equality constraints
13:22:19 <augur> dankna: ass backwards priorities is the problem
13:22:23 <djahandarie> copumpkin, brief? Isn't it possible in 7 now?
13:22:46 <augur> dankna: B2.5 has a shiny new GUI and an amazing smoke engine that uses real physics
13:22:48 <copumpkin> djahandarie: I thought it was removed again
13:23:04 <djahandarie> copumpkin, probably was, I have no idea
13:23:22 <augur> but it still doesnt have a way to tie a material's color or transparency to the surface's properties easily
13:23:26 <Mathnerd314> copumpkin, conal: does nested lub/unamb work?
13:23:39 <aristid> djahandarie: aren't fundeps still slightly more powerful than type families?
13:23:51 <djahandarie> copumpkin, yeah, you're right
13:23:55 <djahandarie> aristid, apparently, yes.
13:24:14 <dankna> yeah, you're preaching to the choir here.  I didn't know about that specific issue but I just know in general that you get that sort of problem with development that's essentially a hobby for most of the people doing it
13:25:18 <djahandarie> It also seems like they don't really care about adding superclass equality constraints either
13:27:18 <augur> dankna: i would accept that as an answer were it not for the exceptionally high quality of the haskell community
13:27:47 <augur> it seems to accord with the approach to achieving things in the knowledge domains
13:28:11 <augur> in unity/blender, there is little aim at _understanding_, just a bunch of recipes that are mixed and mashed to get a result
13:28:25 <monadic_kid> Saizan: i tried not using modL with record (update) patterns, tried deconstructing the list, everything I try I can not get evaluation to with map
13:28:33 <augur> whereas you cant do that with haskell
13:28:37 <augur> you have to understand
13:28:50 <dankna> haskell has a) some corporate money in it, ie SPJ, and b) a very theory-intensive approach.  people who do theory stuff are qualitatively different from people who just want to apply things :)
13:29:00 <augur> and so haskell is resilient, it's hack-unfriendly
13:29:15 <augur> yes thats my point
13:29:17 <augur> (b) i mean
13:29:23 <aristid> dankna: i wouldn't count SPJ as real corporate money
13:29:27 <dankna> okay.  well, then we're not really in disagreement.
13:29:34 <aristid> dankna: but i guess Galois counts :P
13:29:35 <augur> people who dont aim to understand are hacks
13:29:36 <dankna> aristid: well, okay.
13:29:58 <augur> i mean, the technology of haskell has support, sure, but the community
13:30:06 <augur> its not like anyones paying byorgey to write the shit he writes
13:30:13 <augur> he does that for fun
13:30:14 <aristid> dankna: i think SPJ could just as well work at some university or so. why not? i mean, at microsoft he's a researcher
13:30:22 <Saizan> monadic_kid: are you aware that seq and bang patters and strict fields only force evaluation of the outermost constructor? if you need to add strictness to the elements of the list you've to write an explicit loop yourself
13:30:27 <augur> the haskell community is replete with people trying to explain things they've discovered
13:30:39 <Saizan> monadic_kid: or you could use the deepseq sledgehammer
13:30:41 <augur> whereas the blender community is replete with people who achieve much but only show off, never explain
13:30:51 <dankna> aristid: I actually disagree, I think corporate research has different (more productive) qualities than academic research, but that's a deep question and I'm not so confident of my opinion on it to want to argue it
13:30:51 <augur> or people who achieve little, but explain much
13:31:26 <aristid> dankna: well, i'm not really familiar with either, so i will certainly not fight over something that i know little about
13:31:35 <djahandarie> SPJ used to be a professor at Glasgow
13:31:51 <dankna> afk one sec
13:32:46 <monochrom> the qualitatitive difference: clear-headed holistic design vs hasting to patch and patch and patch. so simple it obviously has no problem vs so complicated it has no obvious problem.
13:33:02 <aristid> monochrom: which is which?
13:33:26 <monochrom> theoretically inclined vs not theoretically inclined
13:33:57 <dankna> well, it seems we're clear there's a qualitative difference but we have various opinions on what exactly it is
13:34:05 <dankna> I suppose it doesn't matter as long as we can keep that difference intact :)
13:34:07 <aristid> monochrom: so the difference between the haskell and blender communities?
13:34:21 <monochrom> I wouldn't call the latter practical or applied. or rather, I wouldn't exclusively call the latter practical or applied. you can easily be theoretically inclined and very practical and applied too.
13:34:46 <monochrom> In fact SPJ is an example.
13:34:51 <aristid> but calling haskell simple is not really accurate IMO. it may be less complex than, say, c++, but haskell has acquired quite some complexity by now
13:34:59 <merijn> I like the holistic vs non-holistic distinction you made
13:35:59 <merijn> aristid: It's not the goal to be simple, simple is a way of reaching the goal
13:36:04 <dankna> ooh ooh
13:36:07 <dankna> Richard Buckminster Fuller:
13:36:13 <dankna> "When solving a problem, I never think about beauty.
13:36:16 <aristid> merijn: this is getting philosophical today :D
13:36:24 <dankna> "But when I am finished, if the solution is not beautiful, I know that it is wrong."
13:36:40 <merijn> aristid: Of course, this discussion tends to the Zen of Python :p
13:36:56 <merijn> "Simple is better then complex. Complex is better then complicated." :p
13:37:22 <monochrom> type directed name resolution is an example of patchy complicating extension to haskell
13:37:54 <monochrom> hasting to fix a symptom vs asking what's the real problem.
13:38:23 <mreh> "operators starting with : are a constructor"?
13:38:31 <monochrom> yes
13:38:45 <mreh> is that a rule or a guideline?
13:38:59 <monochrom> they may be introduced by data declarations and used in pattern matching. it is a rule.
13:39:11 <c_wraith> It's a syntax rule.  Much like "functions starting with a capital letter are a constructor"
13:39:12 <dafis> mreh: rule
13:39:56 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4 compulsory reading
13:40:39 <mreh> but it's booooring
13:40:46 <dafis> huh
13:40:59 <mreh> i was just scanning my vim file for the word constructor when I came accross that
13:41:02 <monochrom> not as boring as exhaustive testing
13:41:45 <monochrom> in fact it is quite fun to read because you may find an easter egg or two
13:41:52 <mreh> that is true
13:42:04 <mreh> I might find the secret to syntax highlighting nirvana
13:44:10 * hackagebot cookie 0.0.0 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.0.0 (MichaelSnoyman)
13:44:53 <aristid> i has fundep question
13:45:11 * hackagebot pool 0.0.0 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.0.0 (MichaelSnoyman)
13:45:12 <aristid> class A a b | a -> b
13:45:34 <aristid> class A a b => B a
13:45:51 <edwardk> merijn: overall that is a good philosophy, the problem is when the arbiter of what is too complex is Guido.
13:45:52 <aristid> GHC does not accept this, is it possible at all?
13:46:29 <edwardk> aristid: define a type family for the first one instead
13:47:03 <edwardk> class A a where type Foo a :: * class A a => B a
13:47:24 <monochrom> interesting!
13:47:27 <edwardk> otherwise you'll wind up infecting all of your subtypes
13:47:29 <merijn> edwardk: Any issues with Guido/Python don't invalidate the Zen of Python as sound guiding principles for any programming language
13:48:06 <aristid> edwardk: hmm, usually i prefer using fundeps because they have neater syntax, but in this case using a type family would probably be OK
13:48:09 <edwardk> merijn: i agreed that it is a decent philosophy, just disagreed with the consequences in the python community, POSIWID and all that ;)
13:48:45 <alpounet> saw you started a bunch of scala repos edwardk :)
13:48:53 <edwardk> alpounet: yeah
13:49:01 <BONUS> hmm, with pattern guards, if the guard isn't in the form of p <- e, then it has to be a boolean expression, right?
13:49:16 <edwardk> bonus: yeah, the p <- e form is actually a language extension
13:49:22 <alpounet> yes BONUS 
13:49:39 <BONUS> edwardk: i think it's in the haskell 2010 report though
13:50:22 <monochrom> guard → pat <- infixexp 	    (pattern guard)
13:50:29 <monochrom> I be damned
13:50:37 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
13:50:43 <edwardk> bonus: yeah
13:51:14 <monochrom> so Haskell 2010 isn't a lame duck update at all! :)
13:51:20 <edwardk> 13 years to get something standardized. thats moving fast ;)
13:51:29 <copumpkin> edwardk: where did you see sclv's clique finder that you mentioned the other day?
13:51:41 <edwardk> copumpkin: scrolling past in the hackage announcements
13:52:02 <boegel> yo peepz
13:52:07 <BONUS> y0 dude
13:52:15 <edwardk> http://hackage.haskell.org/package/maximal-cliques
13:52:16 <monochrom> yo bunch of molecules
13:52:41 <BONUS> haskell 2010 is a lot more conservative than i thought it would be
13:52:43 <monochrom> yo bunch of molecules so complicated it has no obvious problems XD
13:52:46 <BONUS> they could have included view patterns easily
13:53:11 <edwardk> bonus: meh, the view patterns are okay, but they do complicate checking if you've matched all the cases
13:53:20 <copumpkin> edwardk: oh, whoops :P
13:53:20 <dankna> I'm pleased that it's conservative honestly
13:53:23 <edwardk> so i can see why one would leave them off, they aren't as nice as wadlers views
13:53:39 <edwardk> i'm relatively happy with slow progress as long as there is progress
13:53:45 <monochrom> yes it's conservative but I thought it was so conservative it merely deleted n+1 and added M.N.P module names.
13:53:56 <BONUS> i've also noticed that sometimes they seem to make it so that you have to recompute some stuff
13:53:59 <edwardk> i'd be happier if they just added type/data/mptcs/fundeps to the spec though
13:54:00 <benmachine> BONUS: but then what would be left for haskell 2011 :(
13:54:06 <benmachine> (...what's happened to that, btw?)
13:54:21 <benmachine> edwardk: type/data families?
13:54:30 <dankna> I mean it's not like we don't have progress, after all, we have extensions in GHC
13:54:49 <dankna> our strategy is that the standard lags behind the implementation.  not the only possible one, but not at all a bad one.
13:55:13 <edwardk> monochrom: when i mentioned that the only backwards incompatible change in haskell' that was really under consideration was removing n+k patterns at icfp 2006, the entire room laughed like they thought it was a joke. funny how times change
13:56:27 <edwardk> benmachine: they are there, they are working, but letting the perfect be the enemy of the good they aren't standardized because folks on either side of the type/data families vs. mptc+fundep debate aren't willing to agree that they both make sense for different problem domains and just happen to overlap a bit, neither subsumes the other
13:56:39 <edwardk> so neither one can win out and we're at a stalemate when it comes to standardization
13:56:51 <edwardk> until someone comes along with a better meta-theory or something
13:57:37 <monochrom> we need political assasins :)
13:57:52 <copumpkin> anyone know if there's going to be another hac phi this coming year?
13:58:12 <edwardk> you'll have to quiz brent, is he back from the other cambridge yet?
13:58:15 <Mathnerd314> can lub be extended so (Left 1) `extension` (Right undefined) = Left 1 ?
13:59:15 <jmcarthur> Mathnerd314: how does it know to choose the left side?
13:59:43 <Mathnerd314> jmcarthur: it gets back 1 before undefined
13:59:52 <monochrom> perhaps by looking ahead and find more defined things in Left 1.
13:59:59 <jmcarthur> Mathnerd314: is that referentially transparent?
14:00:14 <benmachine> Mathnerd314: what does it do given Left (0, undefined) and Right (undefined, 1)?
14:00:18 <patrickthomson> So, under the definition of Functor, it says that [::] is an instance of Functor. What exactly is [::]?
14:00:33 <copumpkin> parallel arrays
14:00:38 <Mathnerd314> benmachine: unspecified; probably gives one of the two
14:00:38 <copumpkin> part of DPH
14:00:51 <benmachine> Mathnerd314: sounds dangerous :)
14:00:56 <jmcarthur> sounds bad to me too
14:01:08 <patrickthomson> copumpkin: ah, i see. thanks. was curious :-)
14:01:21 <benmachine> patrickthomson: see: dph
14:01:58 <aristid> yay, bringing down a type class from 5 parameters to 2, and without a lot of annoying type families syntax (a bit of it tho)
14:03:19 <Mathnerd314> benmachine: it's about as "dangerous" as unamb or lub
14:03:39 <Mathnerd314> benmachine: the question is if it's possible
14:03:43 <benmachine> Mathnerd314: nah. those always have defined and consistent behaviour
14:03:45 <benmachine> you don't
14:03:59 <benmachine> that there is a sound semantics is important
14:04:16 <Mathnerd314> benmachine: it's just an extension for datatypes involving Either
14:04:58 <benmachine> Mathnerd314: no it isn't
14:05:04 <benmachine> you're changing the whole principle
14:05:05 <Peaker> monochrom, reading above, I totally agree type-directed name resolution is a horrible idea
14:05:18 <Peaker> monochrom, Agda succumbed to it, iirc :(
14:05:23 <copumpkin> not really
14:05:29 <copumpkin> only on constructors
14:05:29 <benmachine> agda is a different sort of thing though
14:05:44 <copumpkin> I quite like having reusable constructor names
14:05:45 <Peaker> copumpkin, It does so on constructors :(
14:06:07 <Peaker> copumpkin, They may not have full type inference, but that's no reason to kill the ability to type-infer a constructor name completely for good
14:06:48 <hpc> haha, polymorphic constructors
14:06:55 <jmcarthur> Mathnerd314: lub could be defined for Either, but it would have to be:   Left 1 `lub` Right undefined == undefined
14:06:57 <hpc> data Identity x = return x
14:07:00 <hpc> :P
14:07:17 <jmcarthur> Mathnerd314: but...     Left 1 `lub` Left undefined == Left 1
14:07:50 <copumpkin> Peaker: I think it's a lot more important in a dependently typed language to have reuse though, since you often have variations on the same datastructure with different type indices and such
14:07:56 <c_wraith> jmcarthur, doesn't your first example violate the semantic precondition for lub?
14:08:00 <copumpkin> list/vector/heterogeneous list for example
14:08:12 <Mathnerd314> jmcarthur: yeah, that first "undefined" is "unspecified by contract of lub", not actually forced to be undefined
14:08:16 <jmcarthur> c_wraith: oh right. i'm mixing up lub and glb
14:08:40 <Peaker> copumpkin, That's fixing the symptom.. Names are the problem :)  With DT, the need for a structural editor is more apparent
14:08:43 <tizr> I'm a cs undergrad who really only knows C and some of its derivatives.  I just got on break for a month with the goal of learning haskell.  I was planning on using the haskell for c programmers tutorial on haskell.org but its 404 now.  Can you guys point me to an intro that should help me out while trying to dive right into solving things on programming praxis to learn fast?
14:08:58 <copumpkin> Peaker: yeah, but nobody wants to work on that
14:09:01 <c_wraith> tizr: I recommend lyah and rwh
14:09:03 <mauke> @where lyah
14:09:03 <lambdabot> http://www.learnyouahaskell.com/
14:09:03 <copumpkin> :)
14:09:06 <c_wraith> @where rwh
14:09:06 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:09:06 <Peaker> tizr, If you like the "light" approach, you can try learn you a haskell
14:09:15 <jmcarthur> Mathnerd314: you're right. that was a bad example. either way, i don't see how you could really make that contract tighter
14:09:19 <Peaker> I wouldn't recommend rwh for initial learning, I think it's too advanced/mis-ordered for a beginner
14:09:27 <Peaker> @where tryhaskell
14:09:27 <lambdabot> http://tryhaskell.org/
14:09:30 <jmcarthur> or looser, that is
14:09:42 <copumpkin> tizr: I'd skip the "real world shit" to begin with
14:09:47 <c_wraith> I really do think lyah is good for beginners
14:09:50 <copumpkin> it'll pollute your approach to haskell :P
14:10:08 <Peaker> tizr, Some people don't like LYAH's "happy happy joy" approach, try haskell is also nice
14:10:16 <BONUS> lyah is good for beginners but doesn't teach you much about, well, real world haskell
14:10:19 <Peaker> But if you haven't a problem with the cartoons, it's pretty great
14:10:23 <tizr> I'll check those out, thanks :)
14:10:23 <BONUS> guess which book is good for the latter :)
14:11:13 <tizr> I'm more interested in learning the quirks, rather than just using it as a practical problem solving tool, if that makes sense
14:11:14 <copumpkin> BONUS: how dare you insult LYAH!!!
14:11:18 <jmcarthur> lol
14:11:29 <copumpkin> BONUS: you have no respect
14:11:39 <jmcarthur> BONUS: are you sure you're qualified to criticize LYAH?
14:11:39 <BONUS> haha. it sucks!!!!
14:12:47 <Peaker> tizr, Every language has quirks and if you focus on them and know little else, the language will look pretty bad :)
14:13:52 <tizr> people say when they learn a functional language for the first time it changes the way they think.  I'm trying to maximize that kind of "ah hah!"
14:14:35 <copumpkin> tizr: this channel is probably the prime resource for that kind of stuff, more than any single static online document
14:14:49 <copumpkin> (I say that as someone who learned haskell almost entirely from this channel)
14:15:19 <mauke> > let 2+2 = 5 in 2+2
14:15:20 <lambdabot>   5
14:15:25 <mauke> BAM!
14:15:41 <copumpkin> > let (a, b, c) = (b + 2, c * 5, 3) in (a, b, c)
14:15:42 <lambdabot>   (17,15,3)
14:16:03 <mauke> > let (a, b, c) = (b + 2, c * 5, a) in (a, b, c)
14:16:06 <lambdabot>   mueval-core: Time limit exceeded
14:16:16 <mauke> > let (a, b, c) = (b + 2, c * 5, d) in (a, b, c)
14:16:17 <lambdabot>   (d * 5 + 2,d * 5,d)
14:16:42 <copumpkin> if those past few lines don't make you go "wtf", you're at a better stage than most of us were when we started
14:16:44 <mauke> hello and welcome to "maximizing confusion", a game for the whole family
14:16:51 <ddarius> copumpkin is not representative.  Results may vary.  Please consult your doctor before use.
14:16:55 <Phyx-> LYAH is happy happy? lol, now you make me wanna look at it
14:17:16 <merijn> mauke: When do we bring up category theory and lambda calculi?
14:17:20 <copumpkin> yeah, I am a vegetable, so take me with a sprinkle of salt
14:17:24 <mauke> merijn: never
14:17:38 <merijn> On unrelated note, I full endorse LYAH as awesome for learning Haskell :>
14:17:39 <mauke> mostly because I don't know category theory
14:18:00 <mauke> it's all abstract nonsense to me
14:18:03 <copumpkin> merijn: we mention haskell as a decent starting point for exploring type theory and category theory
14:18:05 <merijn> mauke: I have a book on it here, but so far I can't force myself to start on it :p
14:18:10 <copumpkin> if you're interested, you can go down that route
14:18:18 <copumpkin> but you certainly can get by just fine without any interest in it
14:18:22 <mauke> .oO( skill tree )
14:18:33 <dmhouse> Eurgh, I took a course on category theory this term (I study maths), and just couldn't get in to it
14:18:51 <dmhouse> I just had zero intuition and everything was symbolic guesswork
14:18:52 <merijn> copumpkin: Yes, but mauke was playing "maximizing confusion" for newbies in which case that seems like a good place to start :p
14:19:03 <Peaker> One guy at work likes reading boring text, he said LYAH was too cartoonish for him
14:19:11 <dmhouse> Which is sorta odd because my main interest is set theory, and a lot of people would group those two together as similar areas
14:19:12 <copumpkin> CT for its own sake is bound to be boring, especially without many examples of its concepts applied to other branches of math
14:19:15 <BONUS> sounds like a fun dude
14:19:19 <c_wraith> Peaker, did you tell him to turn off images?
14:19:20 <merijn> Peaker: That guy probably writes java boilerplate for fun...
14:19:30 <copumpkin> well, boring to a beginner, anyway
14:19:34 <c_wraith> do browsers still have a "turn off images" function?
14:19:45 <merijn> c_wraith: Mine does :p
14:19:51 <BONUS> i use opera and it has it
14:19:55 <merijn> Real browsers run in text mode anyway...
14:19:56 <c_wraith> merijn, is it wget? :P
14:20:00 * ddarius thinks view patterns (formerly known as transformational patterns) are a good compromise.
14:20:07 <aristid> my browser is called netcat
14:20:18 <merijn> ddarius: Views as in what Wadler proposed?
14:20:36 <ddarius> merijn: No, view patterns.
14:20:40 <dmhouse> copumpkin: well there were a ton of examples too. It wasn't boring per se, I just couldn't follow it without focusing really hard. I don't think my lecturer helped very much; he was the type to quote "theorem 3.1" or "definition 2.7" from four chapters ago with zero context
14:20:54 <copumpkin> dmhouse: eugh :P
14:21:48 <merijn> ddarius: Quick google for ViewPatterns shows something which seems pretty much what Wadler described
14:21:55 <ddarius> merijn: It isn't.
14:22:08 <ddarius> Views have quite a bit more overhead and non-obviousness.
14:22:41 <merijn> I guess I'll have to read the explanation more closely some time
14:25:45 <augustss> hi
14:26:02 <HugoDaniel> hey augustss
14:27:51 <ddarius> A lot of old school network protocols really wouldn't be that bad to do manually.
14:28:31 <monochrom> I sometimes enter nntp manually
14:28:34 <HugoDaniel> im going to start a new haskell package
14:28:59 <HugoDaniel> it is going to be the haskell web api toolkit
14:29:20 <HugoDaniel> the purpose is to create bindings to the most known web api's out there
14:29:27 <ddarius> HugoDaniel: Is it going to provide an enterprise service bus architecture?
14:29:34 <HugoDaniel> what ?
14:29:36 <HugoDaniel> no
14:29:42 <djahandarie> Haha
14:29:52 <HugoDaniel> just fiddling with OAuth and curl
14:30:03 <HugoDaniel> anyone wants to team up with me ?
14:30:37 <merijn> HugoDaniel: My experience is that most people want to see code written before committing to something
14:30:43 <HugoDaniel> ok
14:30:52 <HugoDaniel> ill ask again by the end of january
14:30:52 <merijn> To many people shouting "I'm going to do X, who's helping me?"
14:31:02 <Peaker> HugoDaniel, What about Yesod/etc?
14:31:09 <HugoDaniel> yesod is a pain :(
14:31:11 <HugoDaniel> sorry
14:31:30 <Peaker> HugoDaniel, seems pretty productive in the screencasts
14:31:34 <augustss> oh, another web toolket, huh?
14:31:41 <augustss> toolkit
14:31:52 <HugoDaniel> no
14:32:04 <HugoDaniel> not another web toolkit
14:32:04 <ddarius> <tool|ket>
14:32:05 <HugoDaniel> argh
14:32:19 <HugoDaniel> i said "create bindings to the most known web api's out there"
14:32:20 <augustss> <bra|kit>
14:32:29 <HugoDaniel> it is completely different from "another web toolkit"
14:32:36 <augustss> it is
14:33:24 <HugoDaniel> im talking about twitter, facebook and some of google
14:33:31 <HugoDaniel> by the end of january ill ask again
14:34:03 <augustss> now that sounds useful, actually
14:34:55 <HugoDaniel> it is
14:35:48 <HugoDaniel> useful and easy
14:36:01 <dankna> what about amazon
14:36:08 <Mathnerd314> jmcarthur: actually, I'll be fine with just making it strict (then Right _|_ = _|_ < Left 1)
14:36:11 <HugoDaniel> yes, and ebay, and bandcamp, and...
14:36:22 <HugoDaniel> but by the end of january im planing only twitter facebook and some google
14:36:26 <Mathnerd314> so how does one make a strict list?
14:36:30 <dankna> cool.  sounds like the sort of thing I'd use.  not necessarily invest my own time in.  but yeah, best of luck with it.
14:36:31 * ddarius doesn't even know what bandcamp is.
14:36:41 * dankna doesn't even want to know what bandcamp is, but that's beside the point
14:36:51 <aristid> HugoDaniel: that's pretty ambitious, tho
14:36:57 <aristid> HugoDaniel: there are LOTS of web apis
14:37:00 <HugoDaniel> yes
14:37:04 <HugoDaniel> lets start with the big 3
14:37:13 <aristid> HugoDaniel: i'm doing an AWS api, and it's a lot of effort
14:37:15 <dankna> oh yeah, and paypal
14:37:18 <HugoDaniel> twitter, facebook, and google
14:37:20 <aristid> granted, AWS has lots of functionality
14:37:29 <dankna> amazon, paypal, ebay, those are the three biggies for me personally
14:37:31 <Phyx-> ForeignPtr is the one to use to receive callback functions from say... c right?
14:37:34 * ddarius imagines a lot of this is already done.
14:37:57 <aristid> ddarius: huh?
14:39:34 <aristid> dankna: shameless plug: https://github.com/aristidb/aws
14:39:43 <monochrom> ddarius: "enterprise band camp service bus architecture" :)
14:40:44 * monochrom 's big 3 are igoogle, google reader, google groups
14:41:50 <mauke> Phyx-: you want to call C functions from Haskell?
14:41:52 <augustss> Phyx-: ForeignPtr is the one to use when you need to point to things that need resource management.
14:42:00 <Phyx-> mauke: yes
14:42:26 <Phyx-> mauke: but I would ideally like to receive the function as an argument
14:42:30 <Phyx-> and not have to import it
14:42:43 <augustss> Phyx-: You only need Ptr for simple things.
14:42:46 <mauke> who will pass the function as an argument?
14:42:49 <djahandarie> monochrom, aren't you forgetting Google Mind Control and Google All of Your Personal Information?
14:43:23 <monochrom> perhaps Google Mind Control forbids me from knowing Google Mind Control
14:43:35 <Phyx-> mauke: I'm basically trying to see if it's possible to export higher order functions from haskell with FFI
14:43:35 <HugoDaniel> :)
14:43:39 <djahandarie> Already a slave...
14:43:42 <Phyx-> augustss: what do you mean?
14:43:47 <monochrom> and iGoogle subsumes Google All of Your Personal Information
14:43:52 <ddarius> Phyx-: Yes it is.
14:44:23 <mauke> Phyx-: who will call what and what's the main program written in?
14:44:32 <Phyx-> ddarius: ah ok
14:45:07 <augustss> Phyx-: You can pretty much ignore ForeignPtr.  Unless you do things like allocate memory on the C side that needs to be freed on last reference on the Haskell side.
14:45:34 <jmcarthur> Mathnerd314: spine strict or element strict or both?
14:45:36 <Phyx-> mauke: who, i don't know, but i'll provide the marshalling information for any datatype used, and inforce a calling convention. but for this example, the main program could be C
14:45:55 <Mathnerd314> jmcarthur: both
14:46:09 <jmcarthur> Mathnerd314: data List a = Cons !a !(List a) | Nil
14:46:21 <HugoDaniel> blaze html is really cool 
14:46:34 <Phyx-> augustss: hmm Ok,
14:46:44 <Phyx-> ah, it seems FunPtr fits my requirements more
14:47:02 <augustss> Phyx-: Yes, FunPtr you'll need for function pointers
14:47:11 <mauke> this is how you do it wrong: http://mauke.ath.cx/stuff/haskell/hell.hs
14:47:14 <ddarius> Haskell is tricky like that.
14:47:39 <Phyx-> heh
14:47:45 <copumpkin> oh, I thought FunPtr was for doing fun stuff, like games
14:47:55 <copumpkin> for accounting apps, I use regular Ptr
14:48:04 <bos> @hoogle peekByteOff
14:48:04 <lambdabot> Foreign.Storable peekByteOff :: Storable a => Ptr b -> Int -> IO a
14:49:40 <Mathnerd314> jmcarthur: is there an easier way? passing it through a strictness function?
14:49:54 <jmcarthur> that seems harder to me, not easier
14:50:15 <jmcarthur> i mean, you can do it, but you will probably end up typing more and performing more work at runtime
14:51:33 <ddarius> Incidentally, what GHC needs to do to support foreign import wrapper is interesting.
14:52:11 <Phyx-> what does it need to do? never really read the implementation
14:52:12 <aristid> @remember copumpkin oh, I thought FunPtr was for doing fun stuff, like games... for accounting apps, I use regular Ptr
14:52:12 <lambdabot> I will remember.
14:52:32 <Phyx-> oh, lol, I just got that
14:52:34 <aristid> copumpkin: i hope you don't mind my editorial liberty of replacing the newline with ...
14:52:40 <Phyx-> :P didn't get it before
14:52:49 <aristid> Phyx-: now you do!
14:53:26 <copumpkin> aristid: I forgive you, just this once!
14:53:26 <Phyx-> yup, late bloomer
14:53:28 <augustss> ddarius: yes, interesting as in "may you live in interesting times"
14:53:50 <mauke> runtime code generation?
14:53:59 <ddarius> augustss: I blame C (or specifically the majority of C implementations.)
14:54:29 <augustss> ddarius: yeah, C ABIs are messy
14:59:51 <Peaker> augustss, x86/32 had a relatively simple C ABI, afaik, though I don't know about struct passing
15:00:54 <augustss> Peaker: simple and inefficient
15:01:05 <Peaker> Yeah, not messy though :)
15:03:41 <HugoDaniel> i like to keep my haskell code at most with the length of 80 columns
15:12:45 <Phyx-> how great is the sin of using unsafePerformIO in ffi code?
15:12:58 <mauke> depends
15:13:09 <Bynbo7> well, it was designed for use in FFI code really
15:13:13 <c_wraith> if you know that it will still be referentially transparent, it's fine
15:13:14 <mauke> but FFI is one of the main applications of it
15:13:45 <Phyx-> well, i would like to pass a function imported as Int -> IO Int as an argument to a pure function expecting (Int -> Int)
15:13:49 <Phyx-> for instance
15:14:03 * qwr thinks, how could i see, what the fuck really uses memory in ghc compiled program
15:14:05 <mauke> why was it imported as Int -> IO Int?
15:14:14 <mauke> qwr: profiling
15:14:28 <c_wraith> qwr: heap profiling, in particular,  rwh has a chapter on it
15:14:33 <qwr> mauke: it's daemon that seems to leak memory over time
15:14:50 <Phyx-> mauke: don't know really, I thought thought from looking at the examples in the FunPtr docs that they all had to be in the IO monad
15:15:02 <Bynbo7> haskell programs don't leak memory, they leak space ;)
15:15:06 <qwr> mauke: some link about profiling such thing?
15:15:12 <c_wraith> You can import functions without IO.
15:15:19 <Bynbo7> @where rwh
15:15:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:15:22 <Bynbo7> qwr: ^^^
15:15:26 <qwr> ok.
15:15:41 <c_wraith> It just tells the FFI mechanism that the call is referentially transparent.  If that's not true, there will be bugs :)
15:15:56 <tswett> Huh.  I wonder for what functions f there exists a function g such that g . g = f.
15:16:13 <Phyx-> c_wraith: ah ok, I wasn't entirely sure in the context of FunPtrs. but i'll change the code then
15:16:17 <mauke> int foo(int n) { return n % 2 ? 3 * n + 1 : n / 2; }   // I'd foreign import that as :: CInt -> CInt
15:16:26 <sipa> tswett: in a mathematical sense?
15:16:41 <tswett> sipa: I guess.
15:16:49 <Bynbo7> tswett: all functions f = g . g! :P
15:19:15 <mauke> Bynbo7: what is g for f(x) = -x?
15:19:31 <alpounet> i*sqrt(x) ? :-P
15:19:54 <alpounet> oh, . as in composition
15:20:07 <mauke> no items. ℝ only. final destination.
15:25:06 <Phyx-> @index FunPtr
15:25:06 <lambdabot> Foreign.Ptr, Foreign, GHC.Exts, GHC.Exts
15:27:28 <Phyx-> ok, so i'm trying to work up a small example, but i'm getting an unacceptable result type error
15:27:31 <Phyx-> http://phyx.pastebin.com/vUcNwk3k
15:28:32 <benmachine> Phyx-: dyanmic?
15:29:03 <aristid> @quote FunPtr
15:29:03 <lambdabot> copumpkin says: oh, I thought FunPtr was for doing fun stuff, like games... for accounting apps, I use regular Ptr
15:29:05 <benmachine> that is not to say I can actually help you with your problem
15:29:19 <Phyx->  wow, didn't see that at all
15:29:53 <Phyx-> but yeah, error persists :P
15:30:41 <Phyx-> it just seems like the result for the wrapper should be an IO
15:30:45 <litb> hello guys and gals
15:30:50 <Phyx-> added that and it compiled
15:31:07 <Phyx-> now i'm wondering if it'll work
15:31:09 <Phyx-> hehe
15:31:48 <Pseudonym> It compiled?  Ship it!
15:32:36 <aristid> litb: hello little bear
15:33:03 <mjrosenb> is there anything like readFile that returns a Maybe String (and Nothing if the file does not exist)
15:33:29 <mauke> mjrosenb: what if the file exists but can't be opened?
15:33:58 <Pseudonym> What if the file changes?
15:34:07 <Phyx-> just to reiterate to see if i understand this, it's "safe" to call unsafePerformIO or drop the IO on a foreign import when we know what we're importing preserves referential transparency, and in no other circumstances?
15:34:21 <sipa> yes
15:34:44 <Phyx-> looks like I need another annotion then
15:34:47 <Phyx-> a -- safe
15:34:50 <Phyx-> or something
15:34:54 <sipa> it's safe if you don't mind whether the function is called once, twice, or not at all if not necessary
15:34:58 <litb> aristid: haha xD
15:35:06 <Pseudonym> Basically, unsafePerformIO is safe when it's used safely.
15:35:13 <mjrosenb> mauke: i'd consider it equivalent.
15:35:40 <mauke> mjrosenb: what if the file exists and can be opened but can't be read? :-)
15:36:08 <mjrosenb> mauke: you know what i mean
15:36:10 <aristid> Pseudonym: which is why it's unsafe :)
15:36:18 <Phyx-> sipa: right, it'll fall under normal evaluation rules of pure functions right, so it'll only be called if the value is actually needed then
15:36:24 <Pseudonym> Safe call to unsafePerformIO is safe.
15:36:33 <mauke> mjrosenb: I don't think it exists but it sounds easy to write
15:36:37 <mjrosenb> is there any way of dealing with files that cannot be read other than handling an exception?
15:36:50 <Phyx-> :t when
15:36:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:37:48 <mauke> mjrosenb: foreign import open
15:37:51 <Phyx-> :t guard
15:37:52 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:38:03 <Phyx-> do exist <- doesFileExist file; guard exist >> readFile file
15:38:11 <Phyx-> I would guess something like that
15:38:22 <aristid> Phyx-: race condition!
15:38:53 <Phyx-> where?
15:38:56 <mauke> Phyx-: that's a terrible way of doing things
15:39:01 <aristid> <Phyx-> do exist <- doesFileExist file; guard exist >> readFile file
15:39:04 <aristid> Phyx-: there.
15:39:31 <aristid> checking whether a file exists and then reading it is a classical example of a race condition
15:39:32 <Phyx-> mauke: lol, why?
15:39:43 <aristid> it's terrible because it's got a race condition
15:39:45 <aristid> obvsly
15:40:03 <mauke> because checking doesFileExist is neither necessary nor sufficient
15:40:18 <Phyx-> Ok, I know it's nearing 1am.. but I must be missing something here..
15:40:20 <mauke> also because open can fail for other reasons
15:40:50 <mauke> Phyx-: your code does two things: 1) check existence  2) open file
15:40:55 <Phyx-> mauke: right.. but he only asked for when the file doesn't exist
15:40:58 <mauke> this is not atomic
15:41:03 <Phyx-> i suppose you could just bracket readFile
15:41:15 <mjrosenb> mauke: what is this foriegn import thing?
15:41:28 <mauke> mjrosenb: lets you call arbitrary C functions from Haskell
15:42:34 <Phyx-> aristid, mauke right, your points have been seen. It's late, that's my excuse :)
15:42:49 <aristid> Phyx-: the shame finger is on your desk now ;)
15:43:11 <Phyx-> i'll be eager to pass it on :)
15:45:26 <mjrosenb>  x <- liftM Just (readFile "DNE") `catch` const (return Nothing)
15:45:44 <mjrosenb> it does not handle exceptions in an intelligent way
15:45:53 <mjrosenb> but I suspect that I do not care.
15:48:32 <Phyx-> wow, it's been a while since i've done any C..
15:48:36 <Phyx-> it feels weird somehow
16:02:02 <mjrosenb> @hoogle [Maybe a] -> a
16:02:03 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
16:02:03 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
16:02:03 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
16:02:57 <aristid> :t mconcat . catMaybes
16:02:57 <lambdabot> forall a. (Monoid a) => [Maybe a] -> a
16:03:32 <mjrosenb> :t mconcat
16:03:32 <lambdabot> forall a. (Monoid a) => [a] -> a
16:04:04 * mjrosenb totally missed the lack of [a] on mconcat . catMaybes
16:04:59 <aristid> mjrosenb: it's not what you want, eh?
16:05:36 <Phyx-> :t mconcat
16:05:37 <lambdabot> forall a. (Monoid a) => [a] -> a
16:06:00 <mjrosenb> catMaybes is what i wanted.
16:06:02 <mjrosenb> oh hey
16:06:13 <mjrosenb> i missed that when i asked lambdabot as well
16:06:18 <mjrosenb> oops. :(
16:06:25 <aristid> mjrosenb: that's why i added the mconcat :)
16:06:32 <aristid> the human lambdabot
16:06:43 * Phyx- hands mjrosenb the shame finger
16:06:44 <Phyx-> :P
16:07:02 <mjrosenb> djinn doesn't know about lists, does it.
16:07:12 <mjrosenb> @djinn [a]- > [a]
16:07:12 <lambdabot> Cannot parse command
16:07:22 <mjrosenb> @djinn x :: [a]- > [a]
16:07:23 <lambdabot> Cannot parse command
16:07:36 <mjrosenb> @djinn x :: a -> a
16:07:36 <lambdabot> Cannot parse command
16:07:39 <mjrosenb> :(
16:07:45 * mjrosenb takes a second shame finger
16:07:50 <mjrosenb> @djinn a -> a
16:07:50 <lambdabot> f a = a
16:07:52 <Phyx-> you know, i regurly use mconcat, but for some reason my mind just went blank just now on it
16:07:57 <Phyx-> when you said it, heheh
16:28:03 <bitstream0101> Any type family / exception handling interaction experts here? http://hpaste.org/42511/custom_exceptions_and_type_fam
16:29:39 <Bynbo7> mauke: for what g is f x = -x? g that rotates pi/2 in the complex plane ;)
16:30:01 <mauke> <mauke> no items. ℝ only. final destination.
16:30:43 <aristid> Bynbo7: that joke is pretty bad :P
16:31:00 <Bynbo7> joke?
16:31:22 <aristid> oO
16:32:09 <Bynbo7> i was answering a question
16:33:02 <Bynbo7> mauke: i don't think i was clear in what i meant though, i meant that there exists a g for all f where g . g == f when f = g .g
16:35:37 <lispy> ?tell ezyang the cryptol download pages should work now :)
16:35:37 <lambdabot> Consider it noted.
16:40:29 <qwr> damn, that profile is really informative - most memory is used by (:)
16:40:52 <c_wraith> qwr: likely to be strings, unless you have large lists of something else
16:41:10 <qwr> c_wraith: strings yes, but why it doesn't free them
16:41:36 <qwr> c_wraith: it shouldn't collect them like trophies
16:42:18 <c_wraith> likely, it's holding on to them because of excessive laziness somewhere.
16:42:53 <c_wraith> Are you building up results by manipulating an accumulating string anywhere?
16:43:41 <qwr> c_wraith: yes, but it all should be temporary storage
16:43:59 <c_wraith> really does sound like excessive laziness.
16:44:06 <qwr> c_wraith: something that finally gets written to network for example
16:44:14 <c_wraith> Something holds on to the entire thing because it's not actually evaluated until much later.
16:44:26 <c_wraith> are  you doing any accumulated statistics, or anything else?
16:45:22 <qwr> c_wraith: afaik not. but some data it stores. i've tried to make that strict afaik, should check again
16:45:34 <Mathnerd314> Why would I get an infinite loop in GHCi saying "*** Ignoring breakpoint"?
16:46:18 <c_wraith> qwr, you might look into retainder profiling.  It's supposed to give you an idea what's holding on to memory that otherwise would be released.
16:48:33 <qwr> ok.
16:53:26 <Phyx-> is this code correct? http://phyx.pastebin.com/rkUy5AP3 i'm getting gabberish when i call it
16:55:14 <Phyx-> whoops
16:55:25 <Phyx-> i was missing a return statement in the c code
16:56:03 <Phyx-> I had mistaken the function for a pure function in haskell and ommited the return, heh...
16:56:28 <Phyx-> mauke: so it that a proper way of creating a wrapper to a higher order function?
16:57:27 <Phyx-> thanks for all the help btw
16:57:31 <Phyx-> sped this up alot :)
17:04:22 <imcmeans> Does the list comprehension syntax have anything to do with lists as monads?
17:04:49 <imcmeans> specifically, the x <- allpossiblevals stuff
17:04:53 <benmachine> yes
17:05:04 <benmachine> list comprehensions are very close to do-statements
17:05:09 <benmachine> or do-expressions rather
17:05:24 <imcmeans> that's pretty awesome
17:05:29 <blackh> imcmeans: It's intentionally similar, and in the old days they were even generalized monad compehensions, but they got dropped for some reason.
17:05:29 <benmachine> > [x + 1 | x <- [3 .. 10], even x]
17:05:30 <lambdabot>   [5,7,9,11]
17:05:45 <benmachine> > do x <- [3 .. 10]; guard (even x); return (x + 1)
17:05:46 <lambdabot>   [5,7,9,11]
17:08:57 <Balahla> Hi
17:09:05 <Bynbo7> imcmeans: haskell used to have monad comprehensions, you could use any monad, not just lists with the same syntax
17:09:27 <aristid> the good old days
17:09:40 <Balahla> Is somebody out there who would help me with windows library installs?
17:09:47 <ion> bynbo7: [x+1 | x <- Just 42] == Just 43?
17:09:56 <aristid> ion: ya
17:09:56 <Bynbo7> yup
17:10:26 <sm> Balahla: what's the problem ?
17:10:48 <Bynbo7> it feels to me like momnadic where, [x|y] sort of reads this thing is equal to x, where y is used to compute x
17:10:53 * Bynbo7 goes to work
17:11:01 <Balahla> I want to code a little program. A kmz file to kml converter.
17:11:34 <Balahla> Don't know how to install the apropriate library for windows.
17:12:02 <Balahla> Wanna converte kmz to kml.
17:12:22 <Balahla> Sorry, english is not my primary language.
17:12:33 <ion> I haven’t done Haskell on Windows™, but i’d assume the Haskell Platform installation comes with cabal.
17:12:36 <sm> that's ok.. have you found a library you want to use ?
17:13:18 <Balahla> I guess it would be: http://hackage.haskell.org/package/zip-archive
17:14:02 <sm> ok, have you installed the haskell platform and tried > cabal install zip-archive ?
17:15:26 <Balahla> Have the plataform installed, but... where do I digite cabal install zip-archive? In the WinGHCi? Sorry about the noobness...
17:15:42 <sm> in a DOS window
17:16:00 <Phyx-> s/DOS/cmd
17:16:06 <sm> windowskey-R, cmd
17:16:26 <Balahla> Ok! Gonna try. Come back later to say how it works...
17:16:32 <Balahla> Thanks a lot!
17:16:32 <roconnor> WTF onsider the Java expression Date(2006,1,1); what calendar date do you suppose that specifies?The answer is February 1, 3906. In Java we count months starting with 0, days starting with 1, and years starting with 1,900.
17:16:50 <sm> sure, good luck
17:17:14 <Phyx-> roconnor: wtf
17:17:31 <sm> some packages will not install on windows because they need a configure script, or depend on a non-cross-platform package like unix
17:17:54 <Phyx-> unfortunately
17:18:00 <sm> and you should do > cabal update  first
17:19:29 <Balahla> How about cygwin? How does it work?
17:19:40 <sm> beats the heck out of me
17:20:05 <Balahla> I mean, related with this  non-cross-platform  issue?
17:20:07 <ion> For a more bearable terminal for Windows™, get mintty http://code.google.com/p/mintty/
17:20:07 <sm> but yes, in a cygwin shell, it's possible to get more of those packages to install on windows
17:20:30 <Phyx-> except the unix package still won't install
17:20:33 <sm> example: http://neilmitchell.blogspot.com/2010/12/installing-haskell-network-library-on.html
17:20:52 <Phyx-> while the description says it should
17:20:56 <Phyx-> but, *shrug*
17:21:15 <sm> The package is not supported under Windows ?
17:21:26 <sm> I mean: it says "The package is not supported under Windows" ?
17:21:37 <Phyx-> i don't see the point of the unix package anyway, there are better cross platform ways of doing most of it
17:21:47 <sm> oh and "(except under Cygwin)"
17:22:39 <sm> some packages may be able to be adjusted to use http://hackage.haskell.org/package/unix-compat  instead
17:23:06 <sm> I guess. Though that seems to depend on unix, so I don't know how it's supposed to work
17:24:11 <Phyx-> i wonder how many packages depend on it
17:24:30 <Phyx-> hackage should have a "browse by dependency" feature
17:25:31 <sm> there are two alternate hackage instances which do
17:25:57 <Phyx-> oh?
17:26:15 <sm> sorry, they have unmemorable but googleable urls
17:26:25 <Phyx-> lol
17:27:25 <elliott> Wasn't there some hubbub about Parsec 3 being slower than Parsec 2?
17:27:30 <elliott> Okay, so hubbub is an inaccurate word.
17:28:45 <Phyx-> hmm i wonder if i can use some shellcode and code injection to get around the dllmain limitations..
17:30:03 <lispy> elliott: yes there was talk about that.  Last I heard, the performance gap was closed.  If you don't find that answer satisfactory, try attoparsec.
17:30:22 <elliott> lispy: I was just curious. OK then, I'll use Parsec 3 then.
17:30:32 <elliott> Even if it is less simple as far as types go.
17:30:44 <lispy> and undocumented :(
17:30:51 <elliott> ...come to think of it, YAY PARSEC 2
17:31:41 <dolio> Parsec 2 is even more undocumented, from what I hear.
17:32:11 <sm> I wouldn't call parsec undocumented
17:32:14 * Phyx- pokes lispy 
17:32:18 <Phyx-> long time no see
17:32:51 <dolio> Parsec 1 is documented on its old website.
17:32:54 <sm> elliott: and parsec 3.1 was supposed to fix most speed issues
17:33:04 <dolio> And people believe those are docs for Parsec 2, but they aren't.
17:33:10 <dolio> As I recall.
17:33:15 <elliott> dolio: Indeed, but they're close enough.
17:36:03 <dolio> Presumably, the Parsec 1 docs work equally well for the compatibility layer in Parsec 3.
17:36:30 <dolio> Or, if not equally, close.
17:36:57 <elliott> dolio: Is being a luddite curmudgeon an acceptable excuse?
17:37:12 <dolio> No. :)
17:37:18 <bsmntbombdood> am i correct in reasoning about actions in haskell as values, and the only way an action is ever run is by assigning it to main, or by composing it with another action that is run with >>=?
17:37:34 <elliott> dolio: That's okay -- luddite curmudgeons like me don't need excuses!
17:37:38 <dolio> Heh.
17:37:43 <Axman6> bsmntbombdood: i'd say you're correct up until or
17:37:58 <dolio> If you're talking about IO actions.
17:38:08 <Axman6> also, you can call haskell from C, so technically there's a bit more to it, but that's basically it
17:42:32 <bsmntbombdood> Axman6: how so?
17:42:41 <lispy> Phyx-: hey
17:42:50 <lispy> Phyx-: how's it going?
17:42:57 <dolio> You could run a C program that executes some non-main Haskell IO actions.
17:43:18 <bsmntbombdood> Axman6: main = getLine >> getLine ?
17:43:23 <dolio> Since the C program is the entry point of the program, not Haskell.
17:44:18 <alpounet> re. parsec 2/3... isn't attoparsec more used these days ?
17:45:10 <imcmeans> I have a debugging question - if my code hangs in ghci, is there a way to 'break' into the running execution to see where it's stuck?
17:45:48 <imcmeans> right now I have to kind of figure it out, in other languages I could just break execution in a debugger 
17:46:14 <Axman6> there's a debugger in ghci
17:46:23 <lispy> imcmeans: actually, that would be a nice feature
17:46:34 <lispy> imcmeans: for instance, if you could sent HUP to ghci and have it break
17:46:35 <Phyx-_> lispy: i'm good thanks, finally have some free time, and you?
17:46:59 <imcmeans> I know there's a debugger, but (reading the documentation) you can set breakpoints and stop at them, but once the execution has started I have to kill the winghci process and restart it :(
17:47:06 <lispy> Phyx-: my free time starts next week.  I'm going to spend it hacking Haskell and Isabelle (join #isabelle if you have any interest in theorem proving :)
17:47:25 <lispy> imcmeans: you should propose this feature to the GHC folks.
17:47:27 <Axman6> imcmeans: what are you working on?
17:47:32 <elliott> lispy: oh /that/ isabelle
17:47:38 * elliott parts channel
17:47:46 <elliott> gotta keep my coq reputation
17:47:50 <Axman6> lispy: shhh! there's got enough other stuff to be working on at the moment! :P
17:47:59 <imcmeans> Just learning haskell, going through project euler as a tutorial.
17:48:12 <Phyx-> lispy: i'm spending mine working on visual haskell. seeing if i can finally make a release :P
17:48:21 <lispy> Phyx: cheers!
17:48:50 <Phyx-> wow, i should go to bed. 3am and my vision is kinda blurrt
17:48:53 <Phyx-> blurry*
17:48:57 <elliott> visual haskell -- please tell me that's not what I think :-(
17:48:58 <lispy> heh
17:49:04 <lispy> Phyx-: get some rest and make that release :)
17:49:30 <imcmeans> I'm sure the developers are busy, but if the runtime supports breakpoints a "break now" button shouldn't be hard to add, I'd assume?
17:49:41 <imcmeans> Then again, that's easy to say since I'm not one of the developers :)
17:49:48 <elliott> the developers of what?
17:49:59 <Phyx-> lispy: heeh, cheers! 
17:50:01 <Phyx-> gn
17:50:09 <elliott> imcmeans: ?
17:50:09 <Phyx-> elliott: I won't :)
17:50:23 <elliott> Phyx-: *cry*
17:50:43 <Phyx-> what.. I didn't say anything
17:50:53 <elliott> Phyx-: well i tend to assume the worst
17:51:04 <imcmeans> GHCi, I guess? I'm not really sure where the code to test breakpoints exists.
17:51:20 <elliott> ah
17:51:25 <elliott> here i was thinking you meant hugs or yhc ;-)
17:51:28 <Phyx-> elliott: lol, and yes it's haskell language support for visual studio
17:51:35 <lispy> imcmeans: yeah, if you're just learning Haskell you'll need a mentor to hack on GHC features
17:51:40 <Phyx-> imcmeans: you mean :b ?
17:51:55 <elliott> Phyx-: I'm going to step away slowly ... scratch that, I'm running away from you
17:52:00 <elliott> aaaaaa
17:52:12 <alpounet> imcmeans, that's quite tricky with laziness...
17:52:26 <Phyx-> elliott: looool, *hog ties you*
17:52:43 <elliott> Phyx-: you must really hate people!
17:52:58 <Phyx-> why? some of us prefer VS
17:53:04 <lispy> > let x = x in x
17:53:07 <lambdabot>   mueval-core: Time limit exceeded
17:53:19 <Phyx-> most don't care, some rather jump of buildings, but some prefer it
17:53:26 <imcmeans> What does laziness have to do with it?
17:53:36 <elliott> Phyx-: bah! i remember when every user of haskell had a ph.d.
17:53:41 <elliott> and uh
17:54:00 <elliott> before deforestation, when unoptimised trees flourished in our forests
17:54:03 <alpounet> imcmeans, some expression might get evaluated way after it appeared in the source code
17:54:03 <Phyx-> elliott: if that is the case, I'm not allowed to do haskell!
17:54:07 <Phyx-> all i have is a Bsc :(
17:54:11 <elliott> Phyx-: precisely! get out! somebody ban him!
17:54:13 <Phyx-> getting my Msc soon though
17:54:37 <imcmeans> alpounet: I'd be OK with that, honestly I just want to see what's *currently* being evaluated.
17:54:40 <Phyx-> ok.. laptop is slipping from my hands now..
17:54:41 <Phyx-> gn
17:54:44 <imcmeans> aka "why does ghci hang when I try to execute this code"
17:54:49 <alpounet> imcmeans, http://haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html
17:54:51 <alpounet> seen this ?
17:55:06 <Axman6> imcmeans: you've probably got an infinite loop btw
17:55:54 <imcmeans> yeah, I know I did, but having a "break execution" debugger feature makes figuring them out trivial
17:56:33 <imcmeans> I'll just wait for Phyx-'s visual haskell to add a "Looks like you've got an infinite loop!" wizard
17:56:37 <imcmeans> complete with helpful dog
17:56:53 <monochrom> the dog ate my moon last night
17:57:36 <elliott> monochrom: i was there, my deepest condolences
17:57:42 <alpounet> Phyx-, any neat screenshot around ?
17:58:27 <Phyx-> alpounet: http://mistuke.files.wordpress.com/2010/07/screenshot1.png was one of the lasts
17:58:53 <Phyx-> http://mistuke.wordpress.com/ has more info and some older videos
17:59:50 <Phyx-> imcmeans: debugging support is going to be quite hard, even with ghci doing most of the heavy lifting, To be honest i haven't even started thinking about it yet. But i have it planning somewhere in "features wanted"
18:01:28 <monochrom> blow your mind with http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/ or http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/ for how a haskell-like language is executed. finish with a devastated state of mind, no longer knowing what debugging would mean.
18:02:00 <elliott> monochrom: but ghci already does debugging :p
18:02:21 * Phyx- turns closes laptop lid
18:02:46 <monochrom> oh, I don't mean debugging doesn't exist. I just mean superficial people will find out they don't know what debugging means.
18:07:56 <imcmeans> What's the current state of an executing haskell program? It's a series of unevaluated functions, right? In a big call graph that only computes neccesary expressions for main to return. 
18:08:12 <imcmeans> I guess that should say "unevaluated expressions".
18:08:30 <lispy> I'd just say thunks
18:08:46 <imcmeans> so a debugger would have to show you a thunk graph
18:09:35 <imcmeans> I was thinking you could just execute everything eagerly and show a callstack, but that wouldn't terminate in a lot of cases :(
18:12:12 <lars9> what's the formal term for "unevaluated exprs"?
18:12:26 <Axman6> thunk?
18:12:42 <monochrom> depends on context
18:13:22 <monochrom> in some context, unevaluated expression is simply expression, evaluated expression is value.
18:19:59 <elliott> what was the limitation of combined parsing/deparsing combinators again?
18:20:02 <elliott> too limited parsing?
18:21:48 <hpc> elliott: you mean like tofoo :: String -> Foo, fromfoo :: Foo -> String, parsefoo = fromfoo . parse . tofoo?
18:22:03 <elliott> hpc: no :)
18:22:19 <elliott> hpc: I mean a set of combinators that defines a syntax, such that you can build both parser and deparser (printer) functions from the one source
18:22:52 <hpc> ah
18:23:13 <elliott> hpc: which has been done but IIRC they're too weak to actually be useful
18:23:56 <hpc> at the very least, it needs to be bijective between parsed and unparsed form
18:23:58 <hpc> i think
18:24:17 <elliott> yeah
18:24:28 <hpc> which knocks out a lot of really basic shit, like html
18:24:43 <elliott> well not really, I think you can have one canonical printing for many input syntaxes
18:25:13 <hpc> right
18:25:27 <hpc> how would one define those combinators?
18:25:30 <elliott> (char '0' `is` 0) <&> ((char 'S' `andthen`) `isfunc` (1+)) <-- or something
18:25:40 <elliott> hpc: I forget exactly how, ^ is a vague reconstruction from basic memory if the theory
18:25:45 <elliott> except, er, you'd actually want
18:25:51 <elliott> (char '0' `is` Z) <&> ((char 'S' `andthen`) `isfunc` S) <-- or something
18:25:55 <elliott> for data Nat = Z | S Nat
18:26:08 <elliott> and then you'd do the obvious for parsing, but look at it the other way for deparsing...
18:26:18 <elliott> i.e. if you have a Z, you'd see that you do char '0' i.e. return "0"
18:26:32 <elliott> but if you have an S, you'd see that you result in 'S' : something, and you recurse on the thing inside the S
18:26:39 <elliott> so you get SSSSS0 and the like
18:26:47 <hpc> oh, so all your combinators are to build a map
18:26:57 <hpc> or something
18:26:59 <elliott> hpc: well. it was more advanced than that. but I don't recall exactly :-)
18:27:03 <hpc> :P
18:27:03 <benmachine> I never worked out a good way of encoding bijections
18:27:07 <elliott> hpc: arbitrary lambdas are of course verboten, since you can't go the other way
18:27:13 <elliott> benmachine: it's eaaaasy in Coq!
18:27:17 <benmachine> o rly
18:27:22 <elliott> benmachine: FSVO easy
18:27:44 <benmachine> when I did it in agda I just had a function together with an inverse together with a proof that it's a left inverse together with a proof that it's a right inverse
18:27:51 <benmachine> and dang, trying to do anything with that
18:27:54 <benmachine> = not easy
18:28:01 <elliott> well.
18:28:20 <ddarius> benmachine: You probably just needed to make some nice combinators for those.
18:28:23 <elliott> benmachine: Inductive Bij A B := bij : forall (f : A -> B) (g : B -> A), (forall x, f (g x) = x) /\ (forall x, g (f x) = x)
18:28:28 <elliott> good luck with the proofs though :P
18:28:29 <ddarius> I don't see that being particularly hard to work with.
18:28:30 <hpc> haskell's bijection package does a funky data structure
18:28:32 <elliott> erm
18:28:39 <elliott> benmachine: Inductive Bij A B := bij : forall (f : A -> B) (g : B -> A), ((forall x, f (g x) = x) /\ (forall x, g (f x) = x)) -> Bij A B
18:28:42 <elliott> *B.
18:28:43 <benmachine> hpc: funky eh?
18:28:45 <elliott> that's from memory though ... whatever
18:28:48 * benmachine intrigued
18:28:53 <hpc> data Bijection a b = Bijection {from :: a -> b; to :: b -> a}
18:28:57 <elliott> hpc: funky?
18:29:02 <elliott> that's just the obvious data structure
18:29:14 <elliott> benmachine: not that easy to prove Bijs in Coq though, but that's ok; *nothing* is easy to prove in Coq!
18:29:16 <hpc> fair, but it's awkward to use
18:29:27 <benmachine> elliott: :P
18:29:27 <hpc> the other approach would be a bijection typeclass
18:29:28 <ion> In some Erlang toy code i define the encoder and the decoder for a binary protocol using a list of tuples filtered through a parse transform. In here i use pairs of lambdas for e.g. bidirectional pad-with-zeros/unpad: https://github.com/ion1/upstest/blob/master/src/ut_protocol.erl#L23
18:29:36 <benmachine> hpc: can't find a bijection package
18:29:45 <hpc> class Bijection a b where from :: a -> b; to :: b -> a
18:29:50 <elliott> benmachine: in fact a harder-to-use proof system was thought to be impossible before they invented agda, where proving anything is a superhuman feat :)
18:29:53 <hpc> http://hackage.haskell.org/packages/archive/TypeCompose/0.5/doc/html/Data-Bijection.html
18:29:56 <elliott> hpc: that's nicer i think... but more ambiguous
18:30:12 <benmachine> elliott: hey, I proved that addition of natural numbers was commutative
18:30:16 <benmachine> that's useful rite
18:30:25 <elliott> benmachine: in agda?
18:30:30 <hpc> huh, that one is an arrow-y thing
18:30:30 <benmachine> elliott: yes
18:30:33 <elliott> benmachine: well, more useful than what they call the standard library ;-)
18:30:38 <benmachine> <_<
18:30:47 <benmachine> don't think I even installed the agda stdlib
18:31:00 <elliott> benmachine: let me know when anyone manages to write a computable reals library in agda faster than it takes to discover the next inconsistency
18:31:01 <elliott> :D
18:31:09 * elliott troll
18:31:10 <benmachine> <_<
18:31:27 <benmachine> you are trolling the wrong audience :P
18:31:44 <elliott> benmachine: yeah but i'd be kicked right out of #agda, nobody understands me enough to kick me here!
18:31:48 * hpc lol'd
18:31:58 <elliott> now to go to #epigram and ask if they have any gtk bindings
18:32:04 * benmachine lols
18:42:58 * ddarius wonders what Agda contexts are not preserved by isomorphism.  Obviously there's equality. What else?
18:45:38 <djahandarie> elliott, I'm pretty sure   people in #agda \subset people in #haskell   except a couple folks
18:46:00 <elliott> djahandarie: Shhh, don't tell them about what I said!
18:46:02 <elliott> They're idling right now!
18:46:43 * ddarius is pretty sure many would agree.
18:55:59 <Saizan> it's even hard to show that two isomorphic types are not equal
19:04:11 * ddarius should implement a pretty full-featured database some day.
19:07:30 <warrenharris> what does it mean when I run my compiled program, and it prints <<loop>>
19:07:50 <ddarius> It means you either didn't turn on or you didn't heed a shadowing warning.
19:08:03 <warrenharris> what is a shadowing warning?
19:08:37 <kmc> it means that you have some expression e such that attempting to evaluate e first requires evaluating e
19:08:56 <kmc> i.e. a circular data dependency
19:09:28 <kmc> it means your program would have entered an infinite loop, but the infinite loop was simple enough for GHC's runtime system to detect
19:09:37 <ddarius> It could also mean that somehow you are confusing Haskell for an imperative language.
19:10:37 <warrenharris> what do I have to turn on to see the warnings?
19:10:46 <kmc> ghc -Wall
19:11:02 <kmc> if you're calling ghc yourself, you should pretty much always pass --make and -Wall
19:12:18 <lispy> ddarius: like a sql database?
19:12:45 <lispy> ddarius: if so, I'm working towards that but I need to take a few pre-requisites off my todo list first
19:12:57 <ddarius> lispy: Well the query language probably wouldn't be SQL, but yes, a relational database of some sort.
19:13:33 <lispy> Ah, I'm definitely going to support SQL.  Not because it's amazing and I'm love with it, but because of ubiquity.
19:13:42 <ddarius> I find myself rather interested in all the aspects that database implementation requires such as data layout, external algorithms, concurrency control, query planning and on.
19:14:51 <ddarius> Hmmm.  Maybe I should make a cache-oblivious database.
19:15:04 <lispy> ddarius: have you read this? http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf
19:15:39 <ddarius> Probably not but Stonebraker is a good name.
19:15:51 <ddarius> (in that field I mean)
19:16:26 <djahandarie> ddarius, how do you read so many papers? I usually find it boring
19:16:28 <lispy> ddarius: it doesn't go deep into any one area, but it has a lot of references and it gives a good overview of how it all fits and the places where real databases spend their implementation effort
19:17:21 <lispy> It's my current starting point for this undertaking, but I assume it's not sufficient.
19:18:11 <ddarius> djahandarie: Read the stuff that interests you.  As time progresses you'll find a lot of the stuff that was originally boring becomes really important (and thus interesting) later.  Particularly if you try to implement a lot of the ideas you read about.
19:19:08 <ddarius> For example, TTT has quite a lot of technical content that is boring (and incomprehensible) in the first several readings, but I've found that, eventually, I've specifically gone back to TTT for that content when it became relevant.
19:19:30 <lispy> djahandarie: it helps to keep a list of papers you think you should read when.  Then keep good notes on the papers you do read.
19:19:34 <interferon> so say i have a cabalized project and i want to test out its functions interactively in ghci.  is there anyway to have ghci read its dependencies from the cabal file rather than doing "ghc -package blah -package foo -packge blah" ?
19:19:44 <lispy> ddarius: TTT?
19:19:55 <ddarius> @where ttt
19:19:55 <lambdabot> I know nothing about ttt.
19:19:59 <ddarius> Foiled.
19:20:07 <Axman6> @google TTT
19:20:08 <lambdabot> http://www.urbandictionary.com/define.php?term=ttt
19:20:08 <lambdabot> Title: Urban Dictionary: ttt
19:20:18 <ddarius> @google Toposes, Triples, and Theories
19:20:19 <lambdabot> http://www.cwru.edu/artsci/math/wells/pub/ttt.html
19:20:19 <lambdabot> Title: Toposes, Triples and Theories
19:20:24 <djahandarie> @google tapl
19:20:24 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:20:25 <lambdabot> Title: Types and Programming Languages
19:20:26 <lispy> interferon: someone I work with just added that feature to cabal-dev *today* but it's not on hackage yet
19:20:32 <djahandarie> Yes, we have claimed one acronym!
19:20:39 <ddarius> @google sicp
19:20:39 <lambdabot> http://mitpress.mit.edu/sicp/
19:20:39 <lambdabot> Title: Welcome to the SICP Web Site
19:20:41 <interferon> lispy: that's awesome
19:20:53 <djahandarie> @google lyah
19:20:54 <lambdabot> http://www.lyahbethleflore.com/
19:20:54 <lambdabot> Title: Lyah Beth LeFlore - Available Books
19:20:54 <lispy> interferon: it is in the git repo
19:20:58 <djahandarie> Damn
19:21:10 <interferon> too much lambdabot noise, PM it
19:21:13 <lispy> interferon: https://github.com/creswick/cabal-dev
19:21:33 <lispy> interferon: install cabal-dev then: cabal-dev install; cabal-dev ghci
19:21:45 <benmachine> argh fuck you default method definitions
19:21:50 * benmachine forgot about negate and (-)
19:21:51 <djahandarie> On that note, I wonder why @google doesn't just return the title and url in the same line
19:21:57 <interferon> lispy: that feature is available in that github repo?
19:21:58 <benmachine> oop, pardon my language
19:22:05 * benmachine forgot his context for a moment
19:22:24 <lispy> interferon: it currently uses the installed version.  So you'll need to re-install the package and restart ghci when you make changes.  That will get refined later.
19:22:30 <lispy> interferon: yes
19:23:54 <interferon> nice, thanks
19:24:31 <djahandarie> ddarius, dunno. I open this and see 'page 14 of 303' and want to close it
19:25:16 <ddarius> TTT isn't for the faint of heart even if you are interested in that stuff.
19:26:12 <djahandarie> I read nearly all of scott aaronson's dissertation and I'm not interested in quantum computing. :P
19:26:22 <interferon> i feel an intensifying hatred toward cabal the more i use it
19:26:39 <ddarius> clog is never there when I need him or Google is sucking.
19:26:56 <ddarius> interferon: Perhaps you should use it less.
19:27:00 <djahandarie> Though that seems to have only been 228 pages
19:32:04 <ddarius> Yep, it's clog and not Google.
19:34:13 <Zeiris> Where do people usually host Haskell blogs with syntax highlighting? Most of the ones I've seen are black and white :[
19:34:37 <bitstream0101> Anyone know how to get Control.Exception exceptions and type families to play nicely together? I'm somewhat stumped: http://hpaste.org/42511/custom_exceptions_and_type_fam
19:34:54 <bitstream0101> In particular, I can't get seem to get rid of the instance ambiguity
19:35:31 <lispy> Zeiris: http://blog.codersbase.com/2010/08/import-prelude-hiding-logimport-control.html
19:35:47 <Zeiris> :D
19:36:01 <kmc> Zeiris, host it anywhere that hosts HTML
19:36:11 <lispy> Zeiris: github gists work well too, but I don't know how you do that
19:36:16 <kmc> Zeiris, my blog is on blogspot.  i write in markdown + literate haskell, and convert with pandoc
19:36:26 <kmc> there's also http://hackage.haskell.org/package/BlogLiterately
19:36:45 <ddarius> :t fromException
19:36:46 <lambdabot> Not in scope: `fromException'
19:36:53 <ddarius> :t Control.Exception.fromException
19:36:53 <lambdabot> forall e. (GHC.Exception.Exception e) => GHC.Exception.SomeException -> Maybe e
19:37:13 <lispy> Zeiris: there are libraries on hackage that take Haskell source and output colorized html
19:37:20 <bitstream0101> ddarius: You can see what I'd kinda like to do with the commented out sig for the 'h' function
19:38:20 <lispy> Zeiris: I'm honestly not so happy with the blog spot interface.
19:38:23 <kmc> Zeiris, it was really easy to set up and i can give you a few tips if you like
19:38:38 <lispy> Zeiris: I just haven't had the nerve to improve it
19:39:15 <Zeiris> I kind of liked the wordpress interface and style, but it was overcomplex and embedding code looked painful.
19:39:20 <lispy> Zeiris: I didn't want to have to run my own blog server.
19:39:21 <ddarius> bitstream0101: ScopedTypeVariables doesn't trigger unless you use an explicit forall.
19:39:30 <Saizan> bitstream0101: you need ScopedTypeVariables, then run :: forall m. (CatchMIO m, Monad m, Show (Term m), Typeable (Term m)) => SM m a -> m a .... h :: Maybe (Exc (Term m))
19:39:35 <lispy> Zeiris: well, wordpress is good enough for dons
19:39:40 <bitstream0101> aha!
19:39:51 <lispy> Zeiris: http://donsbot.wordpress.com/
19:39:56 <warrenharris> ddarius: I recompiled with -Wall, got rid of all my warnings, but still get the <<loop>>
19:41:09 <ddarius> warrenharris: Somewhere you wrote code like, let x = x + 1
19:41:41 <bitstream0101> Saizan: Hm, doing that gives me: Not in scope: type variable `a' for both uses of it in the signature
19:42:04 <ddarius> You can't quantify only some of the variables.
19:42:15 <Saizan> bitstream0101: yeah, sorry, add 'a' to the forall
19:42:34 <bitstream0101> ah, okay, makes sense. i thought i tried that but i must not have saved the file. >.>
19:42:47 <warrenharris> hmmm... my module works on its own when I test it in ghci (I've got a bunch of trace messages in it), but when I  call it from my main I deadlock 
19:43:26 <bitstream0101> So the key is that I needed the explicit function signature -and- I needed ScopedTypeVariables to work to get the binding to the 'm' in the function for run.  Is that right?
19:43:36 <ddarius> warrenharris: Does it -terminate- in GHCi?  You have an infinite loop.  GHCi doesn't do the same loop detection.
19:43:40 <bitstream0101> function signature for run*
19:43:59 <Saizan> bitstream0101: and you needed the forall in run's signature
19:44:06 <warrenharris> the test routine terminates, but when called from main it blocks
19:44:25 <bitstream0101> Saizan: Right, but that's because I won't get the type variable binding in the body of run without it, correct?
19:44:35 <Saizan> bitstream0101: yep
19:44:46 <bitstream0101> Saizan: Excellent. Thanks muchly. (You too, ddarius)
19:46:30 <tolkad> I just learned about SKI combinator calculus and I'm trying to write some code to generate a random term (without the I combinator). I'm generating the term trees from the root down so I need to know the number of possible terms at a given tree depth, I think that would be a(n)=a(n-1)^2+2 where n is the tree depth but I'm not sure how to convert this to a closed-form expression
19:50:00 <warrenharris> ddarius: what you said about writing let x = x+1... does that apply to x <- foo x as well?
19:50:07 <ddarius> No.
19:50:16 <ddarius> Unless you are using recursive do notation.
19:50:21 <warrenharris> no
19:50:42 <Axman6> warrenharris: x <- foo x is the same as foo x >>= \x -> ...
19:50:48 <warrenharris> right
19:50:50 <Axman6> they're different x's
19:51:04 <ddarius> And incidentally would be shadowing x so should produce such a warning.
19:51:10 <tolkad> so then I can stop generating the tree at a certain level if « randomRIO (1, a(n)) >=> (return . (<= 2)) »
19:53:17 <kmc> "let x = x+1" is perfectly fine, even useful, for certain definitions of (+)
19:53:41 <kmc> > let x = 1:x in x
19:53:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:54:06 <djahandarie> There is a useful Num instance for lists?
19:54:11 <kmc> it's not much good for Int or Integer or Double or the like, because those types are represented in an all-or-nothing way that can't be built incrementally
19:54:28 <kmc> djahandarie, you can define several of them; i didn't say anything about that though
19:55:29 <ddarius> kmc just did a bait and switch.
19:55:59 <interferon> what am i supposed to do about a package that indirectly depends on two different versions of mtl?
19:56:10 <ddarius> Cry.
19:56:24 <interferon> haha
19:56:25 <interferon> for real
19:57:06 <ddarius> (or you could probably download the relevant dependency and modify it's .cabal unless none will work with a different version of mtl)
19:57:06 <lispy> interferon: Well, fix one or both packages to work with both versions of mtl
19:57:35 <lispy> interferon: which is more painful that it sounds because mtl2 didn't have any mtl1 compatible releases
19:57:47 <lispy> They just broke what they felt like break
19:57:51 <lispy> breaking*
19:57:53 <interferon> grumble grumble grumble
19:59:31 <ddarius> lispy: That paper looks like it will be an enjoyable overview and hopefully will point me at some interesting, more modern references.
19:59:35 <interferon> mtl should just be silent low-level infrastructure
19:59:41 <ddarius> (That said, the old school references are pretty good.)
19:59:46 <interferon> instead it interferes with nearly every cabal package i've ever put together
20:00:02 <ddarius> interferon: I don't see how that could be as it is part of the public interface of many packages that use it.
20:00:27 <lispy> ddarius: If you find some cool references about databases, let me know
20:10:29 <Jonno_FTW> > takeWhile isDigit "abc123abc"
20:10:30 <lambdabot>   ""
20:13:04 <JoeyA> > filter ((||) <$> isDigit <*> isAlpha) "abc, 123"
20:13:05 <lambdabot>   "abc123"
20:13:26 <JoeyA> > filter (liftA2 (||) isDigit isAlpha) "abc, 123"
20:13:27 <lambdabot>   "abc123"
20:14:19 <lispy> > takeWhile isDagit "abc123abc"
20:14:20 <lambdabot>   Not in scope: `isDagit'
20:14:50 <lispy> hmm
20:14:57 <lispy> ?let  isDagit = (`elem` "dagitDAGIT")
20:14:57 <lambdabot>  .L.hs:6:0:
20:14:57 <lambdabot>      Failed to load interface for `Control.Arrow.Operations':
20:14:57 <lambdabot>    ...
20:15:06 <lispy> Cale: Do you know what's up with that?
20:15:18 <lispy> Cale: is that because I upgraded ghc?
20:21:49 <Saizan> cabal install arrows ?
20:42:59 <ddarius> lispy_: If you are interested in this area, you should definitely talk to Pseudonym sometime.
20:55:54 <revenantphx> Is there a Haskell hypertext processor type thing?
20:55:56 <revenantphx> out of curiosity?
20:56:53 <Axman6> as in HTML/XML?
20:59:57 <revenantphx> Yeah, like PHP
21:00:07 <revenantphx> Server side preprocessor.
21:00:32 <Axman6> well, things like Snap can use Heist for templating, that count?
21:00:46 <revenantphx> dunno what snap or heist are
21:01:11 <Axman6> snap is a web framework, heist is a templating system (i think)
21:04:07 <deech> Hi all, I was looking at the GHC vs Java Server Alioth benchmarks. Would it make any sense for me to try and make some of the GHC entries faster? Or are they pretty much optimized?
21:04:39 <Axman6> by all means, go for it! :)
21:05:00 <Axman6> any one in particular?
21:05:51 <deech> Axman6: No I just have a general queasiness about Java 6 being faster than GHC. And also I'd like to learn to optimize Haskell code. 
21:06:19 <Axman6> well, it's a great way to learn how to do it, i've spent a fair amount of time doing that
21:06:32 <Axman6> (the thread-ring entry is my one :))
21:06:37 <ddarius> They all have been optimized, but GHC is a moving target so they can probably all be improved in both readability and performance.
21:06:41 <revenantphx> gr
21:06:41 <elliott> i suggest writing an inline assembler in haskell
21:06:41 <revenantphx> https://gist.github.com/752586
21:06:43 <elliott> and writing the rest in that
21:06:49 <ddarius> @hackage harpy
21:06:49 <lambdabot> http://hackage.haskell.org/package/harpy
21:06:57 <Axman6> beat me to it
21:07:00 <Axman6> heh
21:07:07 <elliott> tbh i think more people go "OMG THE BENCHMARK ENTRIES ARE UNREADABLE THIS IS WHAT FAST HASKELL MUST LOOK LIKE" than "oh slow benchmark results, language must SUCK then"
21:07:20 <revenantphx> ghc-asm is there though
21:07:25 <djahandarie> deech, Java is fast.
21:07:41 <Axman6> yeah, java, especially with -server is very fast
21:07:53 <Axman6> it's java gui apps that make people think java is slow
21:07:58 <ddarius> When you ignore start up.
21:08:10 <revenantphx> Java is very fast
21:08:18 <revenantphx> However, it's very easy for morons to write slow java code.
21:08:21 <ddarius> A lot of the benchmark programs were written when GHC was less capable.  For example, almost none of them should be using explicit unboxing anymore.
21:08:22 <deech> Interesting, I always thought GHC was competitive with Java. 
21:08:26 <Axman6> ddarius: the results on the shootout include startupi believe
21:08:32 <revenantphx> And the second you involve swing, its shitastically slow.
21:08:33 <Axman6> ddarius: it is
21:08:37 <Axman6> uh, deech 
21:09:06 <revenantphx> so guys
21:09:06 <revenantphx> https://gist.github.com/752586
21:09:09 <revenantphx> any idea about this
21:10:23 <Axman6> revenantphx: can you run ghc-asm?
21:11:19 <revenantphx> hrm.
21:11:19 <interferon> i get this error (http://hpaste.org/42512/cabal_error) when i try to run "ghci -package MissingH" but i can use cabal to build packages that depend on MissingH without issue.  how can i resolve this?
21:11:26 <revenantphx> I can navigate to it
21:11:34 <revenantphx> but when I try to execute it at the command line it doesnt work...?
21:11:56 <Axman6> sumfin dun broked ur install
21:12:37 <revenantphx> odd...
21:12:48 <Axman6> well, that's my guess anyway
21:12:53 <revenantphx> bash REFUSES to auto-complete /Library/Frameworks
21:13:02 <revenantphx> its fine for library, but then refuses to admit Frameworks exists
21:13:02 <deech> interferon: Have you tried unregistering and reinstalling regex-compat?
21:13:06 <revenantphx> even though it does, and i can cd to it.
21:13:21 <revenantphx> oh here we go
21:13:32 <interferon> deech: yeah
21:13:39 <interferon> deech: i unregisted it and then reinstalled missingh
21:13:55 <deech> interferon: what about regex-compat itself?
21:13:55 <revenantphx> hnhnhnhnh... bash wont admit the directory is real D:
21:14:08 <revenantphx> it shows all of the other directories when I double tap tab, except Frameworks
21:14:08 <interferon> deech: i just tried that now, too
21:14:11 <interferon> deech: no dice
21:15:05 <deech> interferon: The latest regex-compat is 0.93, how come your's says 0.92?
21:15:19 <revenantphx> otherwise, yeah I can run it.
21:15:33 <interferon> deech: dunno, i'll try a cabal update
21:17:00 <interferon> deech: sorry, nothing
21:17:16 <interferon> deech: now i just get the error but it refers to regex-compat-0.93
21:17:24 <deech> interferon: ugh.
21:17:41 <ivanm> preflex: seen mtnviewmark
21:17:41 <preflex>  mtnviewmark was last seen on #haskell 9 hours, 53 minutes and 49 seconds ago, saying: and - while next HP isn't out - I've been building it with 7 and it is compiling and running fine
21:17:46 <deech> interferon: try an earlier version of MissingH
21:18:15 <interferon> deech: how do i do that?  unregister the old one and then install a specific version
21:18:15 <interferon> ?
21:18:32 <deech> interferon: Yeah first unregister the old one.
21:19:06 <deech> interferon: then do cabal install missingh-1.1.whatever.
21:19:41 <interferon> deech: i have a feeling this isn't the problem - the most recent MissingH is from February of this eyar
21:19:55 <ivanm> what's a nice way of having a function [[a]] -> [[a]] which gives you every single way of picking something from each list in order?
21:20:12 <ivanm> I seem to recall something relatively simple doing this but can't recall what :/
21:21:18 <ivanm> wait, nvm, I can't do that anyway *sigh*
21:21:30 <ddarius> sequence?
21:21:35 * ivanm goes back to banging his head
21:21:40 <ddarius> > sequence ["ab","cd"]
21:21:41 <lambdabot>   ["ac","ad","bc","bd"]
21:21:56 <ivanm> ddarius: that's the one, but it won't do me any good :/
21:22:11 <ivanm> I forgot about an extra requirement I had :s
21:22:31 <deech> interferon: I haven't seen that error before but it seems that cabal thinks that there are two packages that depend on each other.
21:23:07 <revenantphx> Anyone in here have a mac?
21:23:13 <Axman6> yes
21:23:20 <Axman6> though, not with me at the moment
21:23:21 <deech> interferon: maybe downloading the missingh or regex-compat packages and looking at their respective cabal files will give some insight.
21:23:22 <etpace> @hoogle (a -> b) -> (a,a) -> (b,b)
21:23:22 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
21:23:22 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
21:23:22 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
21:23:25 <revenantphx> Agh
21:23:32 <ivanm> I have trees composed of white and black vertices, with different in-degrees and numbers of vertices; given a specific degree sequence I need to find all ways of getting a collection of trees that have those degrees and a total number of white and black vertices :s
21:23:33 <revenantphx> I need someone else to try installing bytestring-mmap
21:23:36 <ivanm> etpace: f *** f
21:23:40 <ivanm> or join (***) f
21:23:44 <etpace> yeah, I was just wondering if there was something else
21:24:12 <ivanm> @type join (***) f
21:24:12 <lambdabot> Not in scope: `***'
21:24:12 <lambdabot> Not in scope: `f'
21:24:26 <ivanm> wait, no *** ? :o
21:24:31 <ivanm> @type (***)
21:24:31 <lambdabot> Not in scope: `***'
21:24:41 <ivanm> @hoogle (***)
21:24:41 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:24:43 * hackagebot cabal-dev 0.7.3.1 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7.3.1 (RoganCreswick)
21:25:47 <revenantphx> Oh god dammit.
21:25:54 * largos idly points out that cabal-dev-0.7.3.1 will now invoke ghci with a fairly reasonable package db :)
21:25:57 <revenantphx> ghc-asm is trying to use /opt/local/bin/perl
21:26:01 <revenantphx> what the fuck. Seriously?
21:26:46 <revenantphx> I mean, it's not even something you'd need macports for
21:26:47 <revenantphx> what
21:26:54 <Saizan> the evil mangler!
21:27:00 <Axman6> gow did you install ghc?
21:27:02 <ddarius> revenantphx: Didn't you know?  Haskell compiles to Perl.
21:27:04 <Axman6> how*
21:27:12 <revenantphx> Oh look.
21:27:15 <revenantphx> Changed to usr/bin/perl
21:27:16 <monochrom> hahahaha
21:27:18 <revenantphx> and it magically works.
21:27:44 <ivanm> ddarius: oh, is that something new in ghc-7?
21:27:52 <revenantphx> So guys...
21:27:55 <etpace> @hoogle [(a,b)] -> (a,b)
21:27:56 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
21:27:56 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
21:27:56 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
21:27:57 <danderson> revenantphx: why are you using the old evil mangler?
21:28:01 <etpace> mm
21:28:03 <revenantphx> danderson?
21:28:22 <danderson> revenantphx: back in the dawn of time, there was the C backend to GHC
21:28:25 <etpace> @pl (\(a1,a2) (x,y) -> (a1+x,a2+y))
21:28:26 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
21:28:29 <danderson> which compiled haskell to C code, then assembled it
21:28:30 <etpace> ahuh
21:28:34 <Axman6> heh
21:28:44 <danderson> and then ran a horrible perl script over the assembler to implement haskell's calling conventions and stuff
21:28:50 <revenantphx> I'm just using whatever's in the 2010 HP.
21:28:51 <danderson> this script is the Evil Mangler
21:29:06 <revenantphx> 0.o
21:29:08 <ivanm> danderson: maybe he's still got a ppc-based mac...
21:29:12 <revenantphx> Nope, intel.
21:29:12 <jmcarthur> is -fvia-c still around or something?
21:29:15 <revenantphx> What is it today...?
21:29:18 <ddarius> jmcarthur: Yes it is.
21:29:19 <ivanm> jmcarthur: yup
21:29:20 <revenantphx> llvm?
21:29:21 <danderson> these days, there is a native code generation backend, and more recently an LLVM-based backend
21:29:32 <revenantphx> cool.
21:29:32 <ivanm> danderson: NCG is only x86 and x86_64 IIRC
21:29:34 <ivanm> maybe sparc
21:29:37 <revenantphx> Well, I guess this package is using it.
21:29:44 <revenantphx> I'm on x86_64 ivanm
21:29:50 <revenantphx> Is there any way to check what it's using?
21:29:55 <ivanm> OK, must be explicitly using -fvia-C
21:30:03 <roconnor> @hoogle digit
21:30:03 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
21:30:03 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
21:30:03 <lambdabot> Data.Char digitToInt :: Char -> Int
21:30:05 <ivanm> revenantphx: is this something you're building via cabal?
21:30:10 <ivanm> if so, check its cabal file
21:30:11 <revenantphx> ivanm: yep.
21:30:35 <revenantphx> How would I tell in there?
21:30:44 <ivanm> revenantphx: search for -fvia-c
21:30:48 <revenantphx> -fvia-C
21:30:49 <revenantphx> yep
21:30:58 <ivanm> IIRC, going via C produces better numeric code (not sure if they fixed that in 6.12 or not)
21:31:04 <ivanm> which package is this?
21:31:08 <revenantphx> OY dons, stop using /opt/local/bin/perl
21:31:09 <revenantphx> kk?
21:31:16 <revenantphx> capisce?
21:31:17 <kmc> the C backend still exists, it's deprecated in GHC 7 in favor of the LLVM backend, iirc
21:31:19 <Axman6> iuused to produce better numeric code
21:31:21 <revenantphx> bytestring-mmap
21:31:26 <kmc> and you can also build a GHC whose C backend does not require the evil mangler
21:31:29 <kmc> "unregisterized GHC"
21:31:37 <kmc> at the penalty of about a 2x slowdown in the compiled code
21:31:50 <Axman6> unregistered i believe
21:31:54 <revenantphx> LLVM seems to be pretty popular these days
21:31:56 <kmc> i've heard both Axman6
21:32:03 <revenantphx> All I know is, clang is quite nice.
21:32:10 <kmc> LLVM is quite popular these days
21:32:12 <Axman6> it hasn't been americanifized
21:32:14 <revenantphx> I love its error messages, the static analyzer is great.
21:32:30 <monochrom> unregisterised
21:32:37 <revenantphx> Pretty much the first thing I do on all my C projects is change compiler to LLVM clang :|
21:32:38 <kmc> GHC already uses a language-agnostic backend layer named C-- or Cmm, which is kind of an LLVM-like project which never caught on
21:32:46 <ivanm> revenantphx: yeah, but it doesn't compile Haskell code, so who cares? :p
21:32:49 <djahandarie> I like when it rolls your program down into a constant.
21:32:50 <Axman6> revenantphx: yeah man, me too. saves so much pain
21:32:51 <kmc> but LLVM being popular and well developed, GHC can translate Cmm to that
21:33:04 <revenantphx> mm yeah Axman6 
21:33:07 <ivanm> kmc: well, it isn't _real_ C--...
21:33:19 <Axman6> yeah, it's Cmm
21:33:24 <revenantphx> I've fleshed out my plan for next year's independent study :\
21:33:33 <kmc> yeah.  i think ghc is the only program which can compile ghc's cmm output
21:33:36 <revenantphx> simple compiled language, parsed/lexed in haskell to llvm backend
21:33:41 <revenantphx> I think it'd be a cool project.
21:33:44 <kmc> but, is C-- used anywhere else?
21:33:47 <djahandarie> revenantphx, are you in uni now?
21:33:52 <revenantphx> No, high school.
21:34:19 <revenantphx> ...to be honest, I'd choose haskell because parsec is very nice.
21:34:35 * ivanm prefers polyparse :p
21:34:57 <ddarius> revenantphx: You should implement a C compiler.  With Language.C and the LLVM package you should be able to do it in a couple of days.
21:35:23 <revenantphx> idk about that >_>... it could be fun though :P
21:35:47 <roconnor> @type readFile
21:35:47 <lambdabot> FilePath -> IO String
21:35:51 <revenantphx> parseCFile
21:35:53 <revenantphx> ._.
21:35:58 <revenantphx> Oh, well there goes half the work.
21:36:42 <ddarius> And the LLVM package takes care of the other half.
21:36:49 <ddarius> You just need to stick them together.
21:37:00 <revenantphx> ... Can I write a one-line, point-free, haskell, C compiler?
21:37:02 <revenantphx> :3
21:37:09 <kmc> the parser is probably not half the work in a C compiler
21:37:16 <kmc> C's grammar is bordering on reasonable
21:37:38 <roconnor> readFile is lazy?
21:37:42 <ddarius> Yes.
21:37:44 <kmc> probably 80% of the work in a "real" C compiler is stuff that wouldn't exist in a toy one at all
21:38:02 <roconnor> @type isDigit
21:38:03 <lambdabot> Char -> Bool
21:38:14 <ddarius> kmc: And probably 50% of that is in LLVM now.
21:38:37 <roconnor> @type isLetter
21:38:37 <lambdabot> Char -> Bool
21:41:47 <revenantphx> kmc: I can see optimizations... what else?
21:44:55 <kmc> portability to tons of architectures and platforms
21:45:07 <kmc> error handling and reporting
21:45:17 <kmc> language extensions
21:45:29 <kmc> compatibility with different language versions and with weird illegal things people want to do anyway
21:46:01 <kmc> support for profiling, debugging, etc
21:46:47 <kmc> i was impressed at the recent report of building Linux with clang, though i understand it used gcc in a few bits
21:47:01 <kmc> Linux uses loads of gcc-specific hacks
21:47:30 <ddarius> Incidentally, Language.C will at least parse a lot of GCC stuff.
21:48:16 <kmc> yeah; a lot of gcc's extensions are syntactically regular
21:48:25 <kmc> either magical builtin functions or attributes
21:55:37 <jmayhak> hello. I'm trying to install the snap framework and it is failing because 'ghc: could not execute: /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/ghc-asm'
21:56:01 <Axman6> heh, jmayhak, see revenantphx for help
21:56:11 <jmayhak> ok. thanks
21:56:13 <revenantphx> Yeah, I just solved this
21:56:17 <revenantphx> open up ghc-asm with a text editor
21:56:19 <jmayhak> very good to hear
21:56:24 <revenantphx> and change the bang to /usr/bin/perl
21:56:26 <jmayhak> i don't have the file at all
21:56:34 <revenantphx> The file's there.
21:56:53 <jmayhak> wil lit be in /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/ghc-asm ?
21:56:57 <revenantphx> yes.
21:57:03 <revenantphx> It's set to /opt/local/bin/perl (which is for macports)
21:57:09 <revenantphx> But you should be good and avoid macports like the plague.
21:58:29 <revenantphx> What is OverloadedStrings for btw?
21:58:35 <revenantphx> jmayhak: found it?
21:59:07 <kmc> revenantphx, for letting string literals in source code have type other than String
21:59:08 <kmc> i.e.
21:59:12 <kmc> "foo bar" :: Text
21:59:31 <revenantphx> I see.
22:00:15 <Axman6> a very handy extension
22:00:51 <kmc> *shrug* i don't mind putting "T.pack" before my string literal
22:00:59 <kmc> but i've never written a module with a large number of Text literals
22:01:17 <revenantphx> idk what it's being used for, but snap uses it
22:01:27 <revenantphx> for its routing tables and splices
22:01:41 <revenantphx> routing table is the wrong word... list of handlers
22:01:42 <revenantphx> that's better.
22:02:22 <kmc> ok
22:02:54 <kmc> well it could be used for many things; it just lets you write «"foo"» rather than «fromString "foo"»
22:02:57 <c_wraith> It's used for ByteStrings in snap code, generally.
22:03:11 <kmc> where fromString is a type class method
22:03:21 <Axman6> it makes a lot of sense in things like blaze, where you can just use "this is some text" in the middle of your monadic code, and it'll be added to the html i believe
22:03:22 <c_wraith> It's really just a mechanism for uncluttering code, a bit
22:03:44 <kmc> i object to the conflation of bytes and characters, so i object to the use of OverloadedStrings with ByteString
22:04:05 <revenantphx> Off the bat, I can say it has the notable disadvantage of not being able to tell.
22:04:07 <c_wraith> kmc: do you object to the use of fromInteger with numeric literals of bounded size, too?
22:04:18 <revenantphx> Looking at this code, I can't tell what's a string or bytestring :\
22:04:22 <kmc> c_wraith, only a little
22:04:38 <c_wraith> revenantphx, nothing's a String in snap.  Ever.
22:04:43 <revenantphx> :|
22:04:48 <kmc> bytes vs. characters is a huge point of confusion among programmers in general
22:04:59 <revenantphx> bytes vs character doesn't confuse me...
22:05:01 <Axman6> i don't believe it is used for direct String -> ByteString conversion in Snap, i believe it does the right thing
22:05:04 <kmc> leading to various real world software stupidity
22:05:09 <revenantphx> character is a single unit of text (could be multiple bytes)
22:05:13 <revenantphx> is there anything beyond that?
22:05:13 <kmc> i don't think machine ints vs. bignums has the same practical effect
22:05:18 <kmc> revenantphx, that's not correct
22:05:22 <revenantphx> drat.
22:05:24 <kmc> not exactly
22:05:31 <kmc> a character isn't multiple bytes, nor one byte
22:05:42 <kmc> it's a numeric value, but you aren't supposed to care how GHC represents it in memory
22:05:52 <revenantphx> oh, gotcha
22:05:56 <mtnviewmark> indeed, using overloaded Strings with ByteString sounds like a recipe for disaster
22:05:56 <revenantphx> I'm thinking C definition.
22:06:16 <kmc> you can't say "this character is two bytes"; you can only say "this character is two bytes in UTF-16 encoding"
22:06:30 <revenantphx> kmc: right.
22:06:33 <kmc> and you'll find many characters which are one byte in UTF-8 and two bytes in UTF-16, etc
22:06:42 <revenantphx> I'm aware.
22:07:17 <c_wraith> Honestly, using OverloadedStrings with ByteStrings is going to confuse the exact same people who will use Data.ByteString.Char8.unpack without understanding it anyway.
22:08:14 <c_wraith> err, pack, not unpack.  But anyway.
22:08:27 <revenantphx> :t Data.ByteString.Char8.unpack
22:08:28 <lambdabot> Data.ByteString.Internal.ByteString -> [Char]
22:08:29 <kmc> ByteString.Char8 is a problem
22:08:47 <c_wraith> kmc: it's also *really* convenient when you know what you're doing.
22:08:55 <revenantphx> What is it supposed to be?
22:08:56 <mtnviewmark> I think it is a bit sad that Snap is defined in terms of ByteString and (gulp) CIByteString
22:08:58 * revenantphx has never used it.
22:09:05 * ddarius uses packed 7-bit EBCDIC personally.
22:09:19 <kmc> revenantphx, ByteString variant which "works" on "Char"s but silently does the wrong thing for any Char value above 255
22:09:29 <revenantphx> :|
22:09:39 <revenantphx> wünderbar
22:09:41 <c_wraith> Not the wrong thing.  It does something very well-defined.
22:09:51 <kmc> something completely arbitrary and almost never what you want
22:09:54 <revenantphx> c_wraith: which is
22:09:57 <kmc> which iirc is to wrap the value?
22:10:05 * mtnviewmark points out that EBCDIC was always an 8-bit code.... and admits to being old enough to have actually used it...
22:10:11 <c_wraith> it uses the low 8 bytes of the multi-byte representation
22:10:18 <c_wraith> err, of the unicode codepoint
22:10:26 <revenantphx> :|
22:10:27 <kmc> if you want to encode some Text as Latin-1, by all means go ahead and use encodeTextAsLatin1 :: Text -> ByteString, or whatever it's called
22:10:29 <revenantphx> That seems a bit silly.
22:10:33 * ddarius objects to the use of fromInteger entirely.
22:10:41 <revenantphx> ddarius: What's the alternative?
22:10:43 <revenantphx> No seriously.
22:10:46 <revenantphx> If there is one.
22:10:47 <revenantphx> Tell me now.
22:10:48 <ddarius> fromIntegral.
22:10:56 <revenantphx> Oh, damnit I keep mixing them up.
22:11:02 <revenantphx> fromIntegral... yeah....
22:11:42 <mtnviewmark> wonders why anyone, in this day and age, would want to encode text as Latin-1
22:12:01 <c_wraith> The fact remains that there are many cases where the .Char8 stuff is both convenient and correct.
22:12:05 <mtnviewmark> as it probably will be misinterpreted by almost everything that receives it
22:12:37 <kmc> mtnviewmark, and i wonder too why anyone would want to encode text as Unicode mod 256
22:12:47 <mtnviewmark> for lands-sakes, HTML5, in fact, mandates that it be misinterpreted!!!
22:12:56 <revenantphx> some times I wonder about this menu in safari.
22:12:57 <revenantphx> http://cl.ly/2p021m0N0Y2n351v0A2X
22:12:58 <c_wraith> Anyone who doesn't understand where the .Char8 stuff isn't correct also doesn't understand where anything else they might use is incorrect
22:12:59 <mtnviewmark> kmc - agree as well!
22:13:33 <revenantphx> The lack of UTF-16...
22:13:38 <revenantphx> Where is it TT_TT
22:13:46 <djahandarie> In space-wasting land
22:13:54 <kmc> c_wraith, ByteString.Char8 is manifestly confusing -- just look at the name.  i'll prefer an orderly world with a Text type (for text) and a ByteString type (for bytes) and conversion functions between them which actually mention relevant encoding standards
22:13:55 <revenantphx> :P
22:14:02 <c_wraith> and mtnviewmark, of course snap is defined in terms of bytestring.  Nothing else is correct for arbitrary http.
22:14:05 <revenantphx> kmc: I agree.
22:14:21 <kmc> actually let's just make all the foreigners speak english
22:14:29 <kmc> and the mathematicians and APL programmers
22:14:36 <revenantphx> kmc: http://www.youtube.com/watch?v=eEPh_KlTyII
22:14:48 <revenantphx> Tim James supports the use of Latin-1 exclusively.
22:14:49 <revenantphx> :|
22:15:00 <mtnviewmark> c_wraith - I don't think that is quite correct - almost all the components of HTTP are either well defined what encoding they are in implicitly, or carry an explicit encoding (in the MIME type)
22:15:24 <c_wraith> mtnviewmark, you seem to believe http is for text only.
22:15:27 <kmc> if English was good enough for Jesus Christ then it's good enough for the State of Texas
22:15:33 <Axman6> Snap served UTF-8 by default, i strongly assume that using the OverloadedStrings with UTF-8 strings will work perfectly fine. everything gets converted into the proper bytestring representation, not Char `mod` 256
22:15:43 <Axman6> serves*
22:15:47 <mtnviewmark> too bad HTML5 explicitly states that user agents MUST treat bytes tagged as ISO-8859-1 (Latin-1) AS Windows-1252!
22:15:54 <mtnviewmark> the spec says you have to misinterpret!!!
22:16:04 <mtnviewmark> I do not, c_wraith, not at all
22:16:24 <mtnviewmark> but only the MIME bodies can be arbitrary octet data
22:16:34 <mtnviewmark> headers, are ALWAYS text
22:16:42 <mtnviewmark> and hence ByteString is really the wrong data type for them
22:16:44 <revenantphx> mtnviewmark: what?
22:16:54 <mtnviewmark> what what?
22:17:19 <djahandarie> In the... oh God, what have I sunk to here...
22:17:21 <c_wraith> Ah, so you really just object to the handling of headers.  That makes more sense.
22:17:38 <kmc> what character encoding is used for HTTP headers?
22:17:46 <kmc> slash MIME headers
22:17:48 <c_wraith> ascii, I believe
22:18:13 <mtnviewmark> well- and URL parts, and cookies, and all the other parts of the HTTP protocol that Snap handles --- 
22:18:14 <c_wraith> I'm pretty sure the headers have to be 7-bit clean
22:18:30 <mtnviewmark> I'm checking, but I think it is Latin-1, actually.... sigh....
22:18:48 <revenantphx> I demand that we only use a 7bit, PDP-endian, 2's complement character encoding
22:18:54 <revenantphx> With the alphabet in reverse order.
22:19:07 <c_wraith> url parts aren't text.  They're ascii.
22:19:12 <revenantphx> And with all common whitespace in other encodings mapping to the bell character.
22:20:05 <mtnviewmark> c_wraith- that is true
22:20:19 <revenantphx> Good night...
22:23:10 <Zeiris> Is there a way to wrap the monte-carlo monad + generator, in a MonadRandom?
22:24:11 <xud477_> try Arrows 
22:24:14 <mtnviewmark> Ah - just so that it is clear how complicated this is - headers in HTTP are in ISO-8859-1 by default
22:24:46 <mtnviewmark> BUT *portions* of a header value can use a different encoding, using the escape mechanism of RFC-2047
22:25:21 <Zeiris> Isn't breaking out arrows for a monad->monad conversion kinda overkill? All I want to do is get the genprog package to work with a MC random generator, not grasp fundamental concepts of category theory. :(
22:26:52 <mtnviewmark> Really- Snap, or any HTTP framework, should take care of all that, and pass either String or Data.Text for the header and other protocol components ---- saving ByteString only for MIME bodies -- and even there should make access to such bodies as String or Data.Text when the MIME type starts "text/"....
22:27:14 <kmc> Zeiris, can you implement System.Random.RandomGen for the Monte Carlo RNG type? probably not, as it doesn't seem to have 'split'
22:27:20 <kmc> but there might still be a way to do it
22:27:54 <mtnviewmark> Though, all that being said, I've never known anyone to use the RFC 2047 mechanism in HTTP... but it's in the spec
22:27:58 * hackagebot json-types 0.1 - Basic types for representing JSON  http://hackage.haskell.org/package/json-types-0.1 (JohnMillikin)
22:27:59 <kmc> it looks like the MonadRandom class methods are things you should be able to implement for RNG
22:28:12 <Zeiris> Does split get used? Is the base implementation's 'split' even trustworthy? Could I get away with adding an arbitrary portion of the period to the MC generator, since MC has such a huge period?
22:28:31 <kmc> haha
22:28:36 <kmc> these are interesting questions
22:29:14 <Zeiris> Eh, I might be barking up the wrong tree entirely. My assumption that GenProg takes ages to populate the initial tree may be due to something totally unrelated :e
22:29:18 <Zeiris> I should probably go benchmark it.
22:32:49 <xud477_> topo
22:51:36 <blenderer> leksah is taking me forever to install. every time I tell it to install and come back 10 minutes later, I find out there is yet another system library dependency I need to install.
22:52:32 <blenderer> it would be great if cabal could somehow give me the list ahead of time
22:52:54 <Entroacceptor> cabal should be able to install it on its own
22:53:47 <blenderer> Entroacceptor: ?
22:53:59 <blenderer> you mean invoke my OS's package manager for me?
22:54:16 <Axman6> heh
22:54:57 <mtnviewmark> @pl \f cs -> map (f:) $ reverse cs
22:54:57 <lambdabot> (. reverse) . map . (:)
22:55:44 <Entroacceptor> mh, that would be nice 
22:55:51 <Entroacceptor> sorry, I think I misunderstood you
22:56:20 <ddarius> There's probably a document which gives a good selection of the non-Haskell dependencies of Leksah.
22:56:21 <lispy_> I want cabal to be able to hand an install plan to something that correctly interfaces with another package manager that will install the deps
22:56:24 <mtnviewmark> you are building Leksah, right
22:56:31 <ddarius> Alternatively, you could just use vim.
22:57:57 <blenderer> i actually do use vim. I was wondering if there some neat compelling features that leksah had
22:58:26 <mtnviewmark> backgound compilation in Leksah is nice
22:58:39 <xud477_> and wath about ghci ?
23:01:32 <blenderer> vim has a lot of little annoyances that you need to work to fix... like it doesn't handle ghc's error output well
23:02:37 <xud477_> yep
23:05:53 <novascotia> Hi, would anyone know if there is a standard way to fold a function across a list until a condition is met, or should I write my own?
23:09:33 <Saizan> depending on the condition a composition of a fold with takeWhile could work
23:10:43 <lars9> or scanl + takwwhile?
23:11:01 <lars9> :t scanl
23:11:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:11:51 <lars9> depends, if you want to test original list or result
23:12:24 <novascotia> Testing the result is good
23:12:35 <kmc> takeWhile with scanr might seem wasteful -- you build the whole list and then throw out part.  but i think it won't actually due that work, due to laziness
23:12:36 <novascotia> I guess a strict fold with takeWhile shouldn't have space difficulties?
23:12:42 <kmc> with scanl i don't think you get that property
23:13:52 <Saizan> ?src scanr
23:13:52 <lambdabot> scanr _ q0 []     =  [q0]
23:13:52 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
23:13:52 <lambdabot>     where qs@(q:_) = scanr f q0 xs
23:14:47 <Saizan> the weirdness of scanr is that the first result is the one relative to the whole list
23:15:04 <Saizan> while with scanl it's the last one
23:16:08 <c_wraith> yeah.  foldr is lazier than foldl, but scanl is lazier than scanr
23:16:30 <lispy_> Arg.  Why does cabal keep breaking my package DB???
23:16:47 <kmc> oh, interesting
23:23:41 <ivanm> lispy_: you mean cabal-install? use -v 3
23:24:33 <lispy_> ivanm: I mean, I install things and then suddenly something will fail to install due to "broken packages".  I run ghc-pkg check and half of the packages I have are considered broken.  I don't do anything weird with my cabal-install or ghc.  It's madness.
23:25:14 <ivanm> lispy_: because you're updating packages that other packages depend on and thus need to be rebuilt?
23:25:36 <lispy_> http://dpaste.com/289716/
23:25:47 <lispy_> ivanm: I don't use update, I only use 'cabal install'
23:26:10 <ivanm> doesn't matter
23:26:19 <ivanm> since it could go and install newer/older versions of other packages
23:26:30 <ivanm> and if you use compile-time flags, then cabal-install will keep resetting them
23:26:46 <ivanm> lispy_: but those errors just look wrong :/
23:28:01 <lispy_> ivanm: I thought cabal only installed new things?  Why would it deleted an existing package?  That's broken :(
23:28:25 <Saizan> lispy_: it doesn't delete.
23:28:39 <Saizan> it can, sometimes, overwrite 
23:28:49 <ivanm> lispy_: if you have installed version x of foo, and then wanted to install bar that depends upon version y of foo, it will install foo-y
23:29:15 <lispy_> ivanm: and then you'd have foo-x and foo-y, right?
23:29:30 <ivanm> yes
23:29:36 <lispy_> That much seems fine
23:30:18 <ivanm> errors like the ones you pasted above seem to be related to C libs or something though
23:30:25 <ivanm> doesn't hexpat use some C lib?
23:30:47 <c_wraith> yes.  expat
23:31:35 <lispy_> ivanm: how about this output: http://dpaste.com/289719/
23:32:34 <ivanm> ghc-pkg list deepseq
23:32:44 <ivanm> but the first breakage is due to hexpat being broken
23:32:53 <Saizan> ghc-pkg list hexpat :)
23:33:20 <ivanm> Saizan: he's already shown that hexpat is broken: http://dpaste.com/289716/
23:33:29 <lispy_> http://dpaste.com/289720/
23:33:40 <Saizan> that just shows the compilation wasn't smooth
23:33:48 <ivanm> actually, all those other errors later on indicate you have heaps of problems :s
23:33:57 <ivanm> looks like all the boot libraries are broken :/
23:34:20 <Saizan> lispy_: what probably happened is that you recompiled hexpat for some reason, producing it with a different ABI, so you've to recompile the libs that depend on it against the new ABI
23:34:29 <ivanm> lispy_: it looks like your global db is broken/missing :s
23:34:43 <Zvpun> I have "import Control.Monad.Writer" but get "Not in scope: data constructor 'Writer'", what am I missing?
23:34:57 <lispy_> Zvpun: welcome to mtl2
23:35:07 <ivanm> Zvpun: mtl-2 is different from mtl-1
23:35:13 <ivanm> doesn't use as many constructors
23:35:14 <Saizan> ivanm: only the ghci libs though
23:35:54 <Saizan> Zvpun: in mtl-2 Writer is just a type synonym for WriterT w Identity
23:36:59 <kmc> the future has just begun
23:37:04 <Zvpun> I am sorry I cant follow. I was reading a blog about monads and wanted to try the examples. I found a wiki page about mtl1 and mtl2 but understand nothing.
23:37:57 <Saizan> Zvpun: the code in your examples is meant for mtl-1
23:38:25 <kmc> in the library 'transformers', and the library 'mtl' version 2, the type "Writer w a" is a synonym for the type "WriterT w Identity a"
23:38:31 <kmc> before, in mtl version 1, it was a distinct type
23:38:34 <ivanm> Zvpun: there have been some API changes in the new version of mtl-2
23:38:36 <Zvpun> it is return 7 >>= (\x -> Writer (x+1,"inc.")) from http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
23:38:38 <kmc> with much duplicated code between Writer and WriterT
23:38:55 <Zvpun> I understand that there are API changes but know too little to adapt it.
23:38:57 <kmc> Zvpun, you should be able to write 'writer' instead of 'Writer'
23:39:01 <Zvpun> ty
23:39:08 <lispy_> I think that the mtl2 release was secretly designed to give people a reason to stop using mtl (it's not longer compatible with itself so the last reason is pretty much gone)
23:39:14 <kmc> http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-Writer-Lazy.html
23:39:27 <Saizan> return 7 >>= (\x -> WriterT (Identity $ x+1,"inc.")) -- i guess?
23:39:59 <kmc> return 7 >>= (\x -> writer (x+1,"inc."))
23:40:29 * lispy_ re-installs ghc again
23:40:50 <Saizan> lispy_: rm ~/.ghc or you won't change much your situation
23:42:15 <lispy_> oh, ranlib is giving crazy errors
23:42:22 <lispy_> Something is seriously broken
23:46:13 <lars9> anyone payed attention to D? it was thought to be an elegant C++, but turned out to be as complicated as C++, if not more complicated
23:46:17 <ivanm> lispy_: rm /Users/dagit/ghc-7.0.1/ as well just in case
23:47:37 <gienah> lars9: D might a parallel runtime, but parallel haskell can scale to million use threads
23:47:50 <gienah> haskell has more packages than D
23:48:14 <Scriptor> millions of threads?
23:48:33 <Scriptor> is haskell's threads system similar ot erlang's then?
23:48:34 <gienah> sure D might be easier to parse than C++, but C++ can be parsed, its just a lot of work since C++ is a big language
23:48:38 <gienah> yes
23:49:00 <Scriptor> hmm, how recently did that happen?
23:49:05 <gienah> haskell wins the thread ring benchmark in the language shootout, erlang also does very good
23:49:07 <lars9> as a language D has too many features to me
23:49:07 <Scriptor> Someone might have to change some wiki articles
23:49:46 <kmc> Scriptor, Haskell has no thread system.  threading is not in the Haskell spec
23:49:48 <Saizan> actually, haskell threads might be lighter than erlang ones, though less indipendent
23:49:51 <gienah> I've used C++ for a long time, I've never really seen the point in moving to a language that is less powerful than C++
23:49:53 <kmc> GHC has quite a nice thread system
23:49:57 <Saizan> s/haskell/GHC/
23:50:03 <Scriptor> righ, ghc
23:50:11 <kmc> millions of threads are feasible, with threaded IO converted into epoll() / kqueue() calls
23:50:12 <gienah> Lisp was always interesting
23:50:31 <lispy_> usr/bin/ranlib: file: /Users/dagit/lib/ghc-7.0.1/integer-gmp-0.2.0.2/libHSinteger-gmp-0.2.0.2.a(mp_clz_tab.o) has no symbols
23:50:31 <kmc> there's big differences to erlang though
23:50:43 <gienah> Of course Haskell and Lisp are more powerful than C++, making Haskell very interesting
23:50:45 <Scriptor> lisp and C++/D are for very different things though :)
23:50:56 <gienah> Yes.
23:50:57 <Scriptor> er, are better suited for
23:51:04 <foocraft> hey guys
23:51:09 <Scriptor> hey foocraft 
23:51:28 <foocraft> is the haskell school of expression book good?
23:51:33 <kmc> GHC Haskell also supports parallel computation *without* threads, which is really nice
23:51:41 <gienah> As a C++ programmer though, Haskell seems more interesting as the very powerful type system in Haskell can teach us stuff that we can then transfer back to C++ programming if we need to
23:51:43 <Scriptor> kmc: wait, how?
23:51:58 <Scriptor> sorry, I really don't know much about either Haskell or GHC
23:52:03 <foocraft> I am looking for a good book to start learning functional programming, and haskell seems to be really optimized at this stage
23:52:12 <Scriptor> beyond the basics
23:52:55 <kmc> Scriptor, http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
23:53:00 <kmc> check out the part about "par" and "pseq"
23:53:40 <kmc> (par x y) will always evaluate the same as y, but also acts as a hint to evaluate x in parallel
23:53:41 <Scriptor> kmc: thanks
23:53:51 <kmc> you can't change the semantics of your program by replacing y with (par x y)
23:54:07 <kmc> which is a lot nicer than worrying about threads and pooling and communication and synchronization
23:54:17 <kmc> of course sometimes you're after concurrent semantics
23:54:27 <kmc> in which case you would spawn threads explicitly
23:54:44 <gienah> @shootout
23:54:44 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
23:55:14 <foocraft> the haskell school of expression "seems" to touch on the multimedia aspects of some haskell libraries, but can anyone tell me what sort of familiarity with functional programming or haskell does it assume?
23:55:24 <ivanm> none
23:55:28 <ivanm> it's a tutorial book
23:55:51 <ivanm> but its actual multimedia libraries are its own; there is a version of them on hackage but I don't know if anyone actually uses them seriously
23:56:40 <Scriptor> it's also not a bad idea to try and read bits of other haskell docs
23:56:54 <foocraft> hmm I want a book that would make functional programming, and maybe haskell, shine. I usually never deal with functional code and it's a big bummer considering the hype around them
23:56:54 <Scriptor> learn you a haskell did a good job helping me understand a lot of functional concepts
23:57:19 <foocraft> Scriptor, I read through that one, but never reached escape velocity with it
23:57:22 <ivanm> define "shin"
23:57:24 <ivanm> *shine
23:58:10 <foocraft> as in: "Here's some java and C, and here's the corresponding haskell, and this is some serious asskickin"
23:58:41 <ivanm> no such book
23:58:49 <ivanm> well, I think RWH might have _some_ C
23:58:55 <ivanm> but code comparisons usually really suck
23:59:17 <Saizan> RWH still seems the most fitting there
23:59:25 <foocraft> RWH?
23:59:32 <Saizan> @where rwh
23:59:36 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:59:37 <ivanm> because realistically only really good, advanced code is worth comparing, but people that are relatively new to either language won't really get them
