00:00:04 <djahandarie> copumpkin, I imagine it'd be illegal to use the full list inside the fold? :P
00:15:55 <Philippa_> @tell augur got to be elsewhere for a while, it's tomorrow morning here now
00:15:55 <lambdabot> Consider it noted.
00:16:21 <edwardk> have a nice night er.. morning philippa ;)
00:19:31 <Philippa_> time zone, what's one of those?
00:43:46 <ddarius> copumpkin: I fell asleep.  My sleep cycle has been like 6-7PM to 12-1AM for like the past two weeks which is rather annoying.
00:51:54 <ddarius> Also I'm pretty certain that you cannot write tail as just a single list foldr, and this can probably be proven relatively easily.
00:54:23 <ddarius> > foldr (\x xs -> maybe (Just x) Just xs) Nothing "abc" -- you can write this though
00:54:24 <lambdabot>   Just 'c'
00:54:42 <ddarius> Er that's last (wtf is with that?)
00:58:12 <edwardk> heya ddarius
00:58:41 <edwardk> ddarius: i wanted to pick your brain a bit =)
01:04:26 <Jafet> > foldr (\x (s,xs) -> case s of Just x' -> (Just x, x':xs); _ -> (Just x, [])) (Nothing,[]) [1..5]
01:04:27 <lambdabot>   (Just 1,[2,3,4,5])
01:05:01 <ddarius> Jafet: There are plenty of ways of doing it that only require a little bit post/pre processing.
01:05:01 <Jafet> Okay, that was cheating
01:07:35 <Jafet> You could write foldl with foldr, too, but probably not by using foldr only once
01:08:02 <dolio> foldl only needs one foldr.
01:08:03 <ddarius> My program that is full of race conditions sort of by design behaves strangely.
01:08:25 <Jafet> Hm, I used two. I hope I won't be taxed for that
01:09:35 <ddarius> You won't be taxed for it, but when the next person brings his sheep to the foldr fields there will be less to go around and so he will be more greedy and soon no one will have any foldrs.
01:11:46 <dolio> @type \f z l -> foldr (\e k r -> k (f r e)) id l z
01:11:46 <lambdabot> forall a a1. (a1 -> a -> a1) -> a1 -> [a] -> a1
01:12:05 <dolio> > (\f z l -> foldr (\e k r -> k (f r e)) id l z) (flip (:)) [] [1..10]
01:12:07 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
01:12:54 <Jafet> ddarius: I prefer the keynesian retelling
01:21:27 * ddarius should implement some of Knuth's ideas from "Structured Programming with Goto" as higher order functions.
01:26:36 <ddarius> loop S; while B: T; repeat
01:33:51 <mreh> what we need is a really specialised command line parsing EDSL with localisation support
01:33:56 <mreh> do we have that?
01:41:19 <mreh> if I collect all the warnings that such a parser might produce with a Writer monad, I can garantee that the output will be ordered and also reflect the execution of such a program?
01:51:05 <jro> > (liftM (+) (Just 1)) >>= \a -> (liftM a (Just 1))
01:51:06 <lambdabot>   Just 2
01:51:18 <jro> is there simpler way to say this?
01:52:06 <mauke> > Just (1 + 1)
01:52:07 <lambdabot>   Just 2
01:52:26 <jro> that is not the same
01:52:36 <mauke> why?
01:53:56 <jro> I mean, I want to say a + b in values of a and b, where a and b are Maybes
01:54:17 <jro> and I want it to be silent if a or b is nothing
01:54:59 <mauke> > (+) <$> Just 1 <*> Just 2
01:55:00 <lambdabot>   Just 3
01:56:41 <Jafet> > liftM2 (+) (Just 1) (Just 1)
01:56:42 <lambdabot>   Just 2
01:58:40 <jro> @src <*>
01:58:40 <lambdabot> Source not found. Maybe you made a typo?
01:59:02 <Jafet> @quote (<*>)
01:59:02 <lambdabot> xerox says: > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
01:59:17 <Jafet> @quote hpc magic
01:59:17 <lambdabot> No quotes for this person. There are some things that I just don't know.
01:59:28 <Jafet> Hrm
01:59:52 <jro> @src (<*>)
01:59:52 <lambdabot> Source not found. :(
02:00:03 <c_wraith> @src Applicative
02:00:03 <lambdabot> class Functor f => Applicative f where
02:00:03 <lambdabot>     pure  :: a -> f a
02:00:03 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
02:00:15 <c_wraith> There is no single source for <*>.  It depends on the type
02:07:43 <Axman6> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
02:07:44 <lambdabot>   <no location info>: parse error on input `where'
02:07:53 <Axman6> bah
02:08:39 <Guest15228> ok
02:15:48 <Saizan> mreh: sure
02:27:19 <sohum> @hoogle [a] -> [[a]]
02:27:19 <lambdabot> Data.List inits :: [a] -> [[a]]
02:27:20 <lambdabot> Data.List permutations :: [a] -> [[a]]
02:27:20 <lambdabot> Data.List subsequences :: [a] -> [[a]]
02:28:49 <sohum> @hoogle [a] -> [(Int,a)]
02:28:49 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
02:28:50 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
02:28:50 <lambdabot> Data.Graph.Inductive.NodeMap mkNodes_ :: Ord a => NodeMap a -> [a] -> [LNode a]
02:31:15 <sohum> @pl \x -> (length x, head x)
02:31:15 <lambdabot> liftM2 (,) length head
02:31:48 <mauke> :t (length &&& head)
02:31:49 <lambdabot> forall a. [a] -> (Int, a)
02:31:55 <sohum> yes, &&&!
02:32:03 <sohum> I'd forgotten about &&&
02:32:08 <sohum> bad @pl.
02:33:07 <sohum> @pl \x -> map foo (bar x)
02:33:07 <lambdabot> map foo . bar
02:33:12 <sohum> ...duh
02:37:57 <merijn> What does @pl do anyway?
02:38:11 <mauke> removes named parameters
02:38:31 <merijn> Ah
02:41:13 <merijn> :t Network.accept
02:41:14 <lambdabot> Network.Socket.Socket -> IO (GHC.IOBase.Handle, Network.Socket.HostName, Network.Socket.Internal.PortNumber)
02:47:59 <merijn> Ok, so my first server attempt is http://hpaste.org/42081/gameloop (feel free to comment on the structure/naming/layout), however I'm still not happy with using 2 threads per socket. This means I have no way to communicate between both threads to synchronize anything and adding an extra Chan to allow both threads communicate just takes me back to my original problem where you can't multiplex Chan's and sockets...
02:51:25 * hackagebot HTF 0.6.0.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.6.0.1 (StefanWehr)
02:57:51 <sohum> @pl \(a,b) -> (f a,b)
02:57:51 <lambdabot> first f
02:57:58 <sohum> :t first
02:57:59 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:58:33 <Jafet> :t first :: (a,b) -> (a->c) -> (c,b)
02:58:34 <lambdabot>     Couldn't match expected type `(a, b)'
02:58:34 <lambdabot>            against inferred type `a -> b'
02:58:34 <lambdabot>     In the expression: first :: (a, b) -> (a -> c) -> (c, b)
02:58:46 <Jafet> :t first :: (a->b) -> (a,c) -> (b,c)
02:58:47 <lambdabot> forall a b c. (a -> b) -> (a, c) -> (b, c)
03:46:50 <merijn> Ok, so my first server attempt is http://hpaste.org/42081/gameloop (feel free to comment on the structure/naming/layout), however I'm still not happy with using 2 threads per socket. This means I have no way to communicate between both threads to synchronize anything and adding an extra Chan to allow both threads communicate just takes me back to my original problem where you can't multiplex Chan's and sockets...
04:02:19 <edlinde> has anyone here used "continuations"?
04:02:28 <edlinde> is there such a concept in Haskell?
04:02:32 <Botje> edlinde: in scheme, yes
04:02:38 <Botje> edlinde: yep. 
04:02:46 <Botje> there's a Cont monad and a ContT transformer
04:02:52 <edlinde> Botje: I got a problem in Erlang ... its probably a real simple one
04:02:57 <edlinde> I just have to update a state
04:02:59 <edlinde> and its not working
04:03:08 <edlinde> been stuck on it for hours and hours now :(
04:03:14 <edlinde> at my wits ends
04:03:25 <edlinde> Botje: would it be ok to discuss it with you?
04:03:39 <edlinde> I can paste it on ideone
04:03:46 <Botje> edlinde: my erlang is so rusty the UN has declared it a tetanus hazard :)
04:03:51 <Botje> have you tried #erlang ?
04:03:57 <edlinde> Yeah i did
04:04:02 <edlinde> it will be piss easy for you
04:04:04 <edlinde> I promise
04:04:05 <edlinde> :)
04:04:13 <edlinde> Erlang guys haven't done continuations 
04:04:16 <edlinde> and hate it etc etc
04:04:25 <Botje> don't blame 'em :p
04:05:08 <Botje> merijn: how about having one thread simply dumping whatever it sees on the socket onto a chan?
04:06:26 <edlinde> Botje: http://ideone.com/F761j
04:06:36 <edlinde> Yeah its really convoluted this CPS style of writing
04:06:48 <edlinde> ok so in that code.. example is a binary tree
04:06:59 <merijn> Botje: That's what I want, but how will it monitor data coming out the channel that needs to be send to the socket?
04:07:11 <edlinde> the first function path works ... but it prints out the paths from root to each leaf TWICE.. which is ok for now
04:07:19 <edlinde> but that version has side-effects
04:07:42 <edlinde> The prof basically wants a STATE into which the results will keep getting "accumulated"
04:07:45 <merijn> Botje: There's no function in the basic libraries for multiplexing sockets and chan's
04:07:48 <edlinde> so like a list of all possible paths
04:08:08 <Botje> merijn: can't you do a non blocking send to a socket?
04:08:20 <merijn> Botje: That's not the problem
04:08:26 <Botje> edlinde: it's printed twice because each 'leaf' still has two leaves nil and nil
04:08:29 <edlinde> Botje: I have printed out what R and S hold in them ... just to debug and see whats going on
04:08:35 <edlinde> Botje: correct
04:08:41 <edlinde> Botje: thats fixed in another version
04:08:45 <merijn> Botje: The problem is 1) wait for input on socket OR chan 2) deal with input 3) goto 1
04:08:47 <edlinde> but this one is much simpler
04:09:04 <merijn> Botje: However there is no function which does "wait for input on socket OR chan"
04:09:06 <edlinde> Botje: so if I can convert this to a "stateful" version then I am sure I can do the other one to
04:09:10 <edlinde> *too
04:09:49 <merijn> Because I don't want to just send info from the socket to my main thread, but also from my main thread to the socket, so blocking on just the socket or just the chan is not enough
04:09:53 <edlinde> Botje: I have tried a million things but somehow the solution is eluding me.... I thought I had got the hang of how recursion works in case of continuations... but something is missing
04:10:29 <Botje> edlinde: it's a bit early for me to screw around with continuations
04:10:32 <edlinde> Botje: but this almost looks like a haskell thing, other than the fact that Haskell would have used a Tree type
04:10:53 <Botje> but my gut instinct tells me you have to chain continuations
04:10:57 <edlinde> Botje: How about in a couple of hours? I can work on someething else
04:11:09 <edlinde> Botje: yeah I do.. but don't know how to chain this shit :(
04:11:46 <edlinde> I thought storing the state in S1 and then calling paths4 with it... is somehow doing this for me
04:11:59 <edlinde> I can post another example where it actually works...
04:12:22 <Botje> the continuation of the left-most leaf should invoke paths4 for its sibling
04:12:38 <Botje> and likewise, the node above it should invoke paths4 for its sibling eventually
04:13:01 <Botje> merijn: i have no idea, btw :(
04:13:05 <edlinde> Botje: not sure I understand
04:13:29 <edlinde> Botje: I was hoping you would be able to spot why from my output I am not able to keep collecting R into S
04:13:34 <merijn> Botje: Oh well, I'll try again tonight when there's more people
04:13:37 <edlinde> like a list of lists
04:14:18 <Botje> edlinde: the output of paths4(Left,...) is not used at all
04:14:49 <Botje> edlinde: have you tried simply paths4(Left,...) ++ paths4(Right,...à?
04:14:56 <edlinde> no
04:15:00 <edlinde> lemme give it a shot
04:15:08 <edlinde> I might have a vague idea what you mean
04:16:00 <edlinde> that almost worked
04:16:08 <edlinde> but its got more repetitions now
04:17:17 <edlinde> http://ideone.com/FEkDp
04:17:23 <edlinde> Updated my paste
04:17:43 <edlinde> so in some ways now we have both the left and right subtrees "linked" to each other huh with the ++
04:17:45 <edlinde> ?
04:17:45 <edlinde> \
04:17:47 <Botje> move your nil case up one level
04:17:58 <Botje> that is, pattern match on {node, a, nil nil}
04:18:17 <edlinde> ok one sec
04:18:42 <edlinde> a is data?
04:18:55 <Botje> uh, yeah
04:19:14 <edlinde> k
04:20:21 <edlinde> it didn't work
04:20:27 <edlinde> chopped off the last bit
04:20:31 <edlinde> ideone is playing up
04:20:43 <Botje> you have to call C( [Data]) then, of course
04:21:44 <edlinde> http://paste.lisp.org/display/117346
04:21:51 <edlinde> ah right
04:22:56 <edlinde> http://paste.lisp.org/display/117346#1
04:23:02 <edlinde> I annotated that paste
04:23:24 <edlinde> this is much closer ... 
04:23:48 <edlinde> Are you sure we need to be one level higher?
04:24:05 <edlinde> or are you trying to even get rid of the duplicated paths?
04:25:28 <dan__> Is there a language extension that permits wild cards in pattern matches on value constructors? E.g., for data A a b = A a | B b , f  ( _ x) = x :: Common_ab_class c => A a b -> c
04:25:52 <Botje> edlinde: okay, then i'm not awake enough
04:26:08 <edlinde> Botje: dude don't give up just yet :) You are super close 
04:26:17 <edlinde> Botje: this is the closest I got
04:26:27 <dawagner> BONUS: On http://learnyouahaskell.com/types-and-typeclasses you say that () is an Enum... Is it? If so, why?
04:26:44 <c_wraith> > enumFrom ()
04:26:45 <lambdabot>   [()]
04:26:47 <Botje> > fromEnum ()
04:26:48 <Jonno_FTW> @seen pastorn
04:26:48 <preflex>  pastorn was last seen on #haskell-blah 5 hours, 11 minutes and 8 seconds ago, saying: what's going on in this channel?
04:26:48 <lambdabot> Unknown command, try @list
04:26:48 <lambdabot>   0
04:26:57 <edlinde> Botje: what if I save the state from Left and pass it to Right?
04:27:01 <c_wraith> @instances Enum
04:27:01 <edlinde> or something along those lines?
04:27:01 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
04:27:12 <Botje> edlinde: that's what i meant by chaining the continuations, yes
04:27:21 <edlinde> ah lemme give it a shot
04:27:35 <edlinde> do we still keep the base case as you mentioned now?
04:27:38 <edlinde> or revert that too?
04:27:43 <Botje> you give the left branch a continuation that calls the continuation for the right branch, which calls the main continuation
04:27:54 <c_wraith> :t toEnum
04:27:55 <lambdabot> forall a. (Enum a) => Int -> a
04:28:04 <dawagner> c_wraith: ok, it is... Why?
04:28:07 <Botje> makes sense, i guess
04:28:19 <edlinde> will try
04:28:21 <edlinde> one sec
04:28:25 <edlinde> I hope it works
04:28:40 <c_wraith> dawagner, Why not?  It satisfies all the requirements necessary to be an instance of Enum
04:29:10 <dawagner> But in what way is it useful?
04:29:25 <mauke> what do you mean?
04:29:53 <c_wraith> It's useful because sometimes you might want to pass () into a function that takes an instance of Enum.  *shrug*
04:30:06 <Jonno_FTW> > fix (\x->1 : scanl (\n->n*(2*n-1)) 1 x)
04:30:07 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
04:30:14 <Jonno_FTW> what am I doing wrong here?
04:30:15 <Twey> > [() ..]
04:30:16 <lambdabot>   [()]
04:30:16 <c_wraith> It's never sane to say "no one will have a use for this, so I refuse to do it."
04:30:26 <dawagner> That's fair, I guess :) Thanks
04:30:29 <Botje> scanl's function takes two arguments
04:30:43 <c_wraith> I mean, there's a reason EmptyDataDecls was added to ghc. :)
04:30:47 <Twey> Heh
04:30:54 <edlinde> Botje: http://paste.lisp.org/display/117346#2
04:30:55 <c_wraith> Sometimes you really do want a type with no possible values
04:31:08 <edlinde> Botje: almost there... but it seems to put out some stupid stuff in between too :(
04:31:10 <c_wraith> ...  Said types cannot be instances of Enum, by the way. :)
04:31:37 <mauke> why not?
04:31:38 <c_wraith> at least, not by Enum's contract
04:31:48 <edlinde> Botje: so also note that I had to change the main call to be S++[R]  and not [S]++{R]
04:31:56 <c_wraith> Really, I'd complain about the Double and Float instances of Enum.
04:32:01 <Jonno_FTW> :t scanl
04:32:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
04:32:22 <c_wraith> > enumFromThenTo 1.1 1.2 1.55
04:32:23 <lambdabot>   [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.5999999...
04:32:25 <dawagner> Yeah, I did find that curious... And couldn't come up with something concrete I expected them to be before trying succ 1.1
04:32:41 <Twey> instance Enum Void where succ _ = error "ARGH!"; pred _ = error "ARGH!"; toEnum = error "ARGH!" …
04:33:04 <Twey> Hooray for ‘undefined’ :þ
04:33:25 <mauke> succ x = x
04:33:42 <Botje> get rid of the S1 = S ++ [Data], maybe?
04:33:59 <c_wraith> I *really* don't understand the rules for Enum for Float and Double, but apparently they are correct.  Somehow.
04:34:02 <edlinde> and just pass S?
04:34:20 <edlinde> in the line where it says S4 = .... you want me to pass in S?
04:34:31 <Botje> i guess
04:34:55 <mauke> c_wraith: I don't think they are
04:35:15 <edlinde> Botje: SUCCESS!!!!
04:35:19 <edlinde> Botje: :))
04:35:36 <c_wraith> mauke, "correct" meaning "obey the rules specified in the report".  I was sure someone claimed they were correct.
04:35:42 <edlinde> one sec
04:35:57 <ManateeLazyCat> Hi guys. :)
04:36:08 <edlinde> http://paste.lisp.org/display/117346#3
04:36:12 <c_wraith> hey ManateeLazyCat.  How is it going?
04:36:32 <ManateeLazyCat> c_wraith: Too busy recently. :)
04:36:32 <edlinde> Botje: thanks a million... lemme try this out on the version that suppresses the duplicate paths too
04:37:09 <ManateeLazyCat> Thanks all help me answer Manatee question, i found many Chinese users join here. :) 
04:37:48 * ManateeLazyCat I'm glad many Chinese students start to study Haskell. :)
04:40:16 * CindyLinz a newbie from Taiwan :p
04:40:57 <hpc> it would be funny if haskell ends up the dominant language in china
04:41:04 <edlinde> Botje: you still around?
04:41:09 <medfly> will never happen
04:41:12 <hpc> suddenly you have a billion people using this obscure confusing math language
04:41:18 <hpc> yeah, but one can hope
04:41:22 <edlinde> Botje: thanks for the idea of chaining the continuations from the subtrees
04:41:55 <Botje> no problem
04:41:56 <ManateeLazyCat> Many Chinese student's English bad as me, please help them patiently, Chinese students are very hard-working intelligent people.
04:42:11 * hackagebot hxt 9.0.1 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.0.1 (UweSchmidt)
04:42:25 <ManateeLazyCat> CindyLinz: Welcome! :)
04:43:21 <edlinde> Botje: now my soul can rest in peace
04:43:23 <edlinde> :)
04:43:38 <ManateeLazyCat> hpc: Many many Chinese people buy dons' book : RWH. :)
04:45:06 <ManateeLazyCat> I hope Chinese programmer use Haskell everywhere someday, like Java in China now. :)
04:51:15 <CindyLinz> ManateeLazyCat: ^^
04:52:10 <dom96> I wonder how many Polish students study haskell.
04:53:00 <ManateeLazyCat> CindyLinz: Haskell community is growing at an alarming rate. 
04:53:15 <Jonno_FTW> not here in Australia
04:53:42 <ManateeLazyCat> Jonno_FTW: I found many Japanese people interested Haskell recently. :)
04:53:56 <Jonno_FTW> hmm
04:54:16 <Jonno_FTW> I'll just keep practicing it on the side from other things
04:54:22 <Axman6> yeah, it's shrinking in Aus... since I left for Japan :P
04:54:39 <Jonno_FTW> I started to teach myself haskell because I heard it improves your skills in other languages
04:54:56 <Jonno_FTW> Haskell being my first programming language
04:55:03 <ManateeLazyCat> Jonno_FTW: I started to study Haskell because i heard Pugs. :)
04:55:05 <Axman6> no one tells you it improves your hatred for other languages too though
04:55:18 <Jonno_FTW> unless you count Excel, which is functional
04:55:34 <Axman6> i thougth excel was something else
04:55:45 <bremner> a spreadsheet?
04:55:54 <ManateeLazyCat> Many people said Pugs is awesome project, then i found Leksah and gtk2hs..... 
04:56:17 <Jonno_FTW> excel is functional 
04:56:28 <Jonno_FTW> it just happens to be presented in a spreadsheet
04:56:29 <ManateeLazyCat> I was surprise Haskell can do this when i first time seen Leksah. :)
04:56:31 <preyalone> How can I reverse a function's arguments? I want to turn mod x base into mod' base x
04:56:36 * dom96 was just looking through many languages and got interested in haskell
04:56:39 <Jonno_FTW> preyalone: flip
04:56:44 <ManateeLazyCat> @hoogle flip
04:56:45 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
04:56:45 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
04:56:45 <Axman6> preyalone: flip
04:56:53 <preyalone> Jonno_FTW: That was fast, and thanks!
04:57:18 <Jonno_FTW> preyalone: it's source is: flip f xy = f y x
05:02:42 <ManateeLazyCat> Recently i was thinking new "hot-swapping framework": build "code server" like Erlang, when user change configre file, will re-compile source and dynamic linking in running program. Then application can call "hot-swapping entry" directly and don't need check new version everytime, it's too slow if use interpreter solution. 
05:03:57 <ManateeLazyCat> "Code server" like "object cache" for user's configre file. User application don't need care dynamic linking problem, just call at newest address.
05:04:28 <Axman6> like Xmonad does?
05:04:32 <ManateeLazyCat> Then avoid frequently I/O action.
05:04:33 <Xilon> Not sure how it works in Haskell, but wouldn't there be an issue with immutability?
05:04:41 <Jafet> That sounds tricky
05:05:04 <Xilon> I.e. some function in a specific module would get replaced with a different function by the same name...
05:05:04 <Jafet> Xilon: notice that it isn't related to haskell
05:05:26 <Jafet> But yes, that's a concern. I believe erlang just places the burden of correctness on the programmer
05:05:38 <ManateeLazyCat> Jafet: Infact, application just care newest version code, it's don't need check dependency and re-compile everytimes function call. 
05:06:40 <ManateeLazyCat> Jafet: Like i do in pdynload, function need check dependency everytime we call pdynload function, and in most time it's unnecessary. 
05:07:08 <CindyLinz> It should be designed carefully to ensure the code fragments are atomically upgraded.
05:07:28 <CindyLinz> In case there are more than one file.
05:07:41 <ManateeLazyCat> If my idea can work, then we can use Haskell like script and *fast* as compile code, not like interpreter too slow.
05:07:44 <Jafet> Note that erlang keeps the old and new versions around, so that uses of the existing module version remain consistent. 
05:08:07 <ddarius> Old versions should be garbage collected when they are no longer being used.
05:08:08 <ManateeLazyCat> Jafet: I heard Erlang use OTP framework do that.
05:08:13 <CindyLinz> Yeah, compatibility is also important.
05:08:14 <ManateeLazyCat> ddarius: Yes.
05:08:34 <ManateeLazyCat> CindyLinz: In first version, i suppose user just change value in runtime
05:08:45 <ManateeLazyCat> Not consider "change type" in runtime.
05:08:50 <Axman6> i didn't think OTP had anything to do with the code replacement stuff
05:08:56 <Jafet> For correctness, I would do a top-down recompilation, checking all dependents of the module that's being changed. It would be much less efficient, though.
05:09:02 <ManateeLazyCat> Axman6: Code server do, 
05:09:15 <dom96> What's the difference between Text.Parsec and Text.ParserCombinators.Parsec ?
05:09:16 <Jafet> Otherwise, the programmer has to make sure that the new version remains compatible
05:09:57 <Axman6> i thought OTP was for writing failure tolerant servers, not live code replacement. i thought that was an Erleng though
05:09:58 <Xilon> Hot-swapping is built into the language. OPT is a layer on top
05:10:07 <Axman6> yeah
05:10:18 <ManateeLazyCat> Jafet: I just want use my idea on "customize system" now, that mean, interface is fixed, user just change *value* in runtime.
05:10:36 <Axman6> gross :\
05:10:58 <ddarius> dom96: One is Parsec 3 and the other is a Parsec 2 compatibility layer.  The difference is Parsec 3 is a monad transformer and handles the input stream a bit differently.
05:11:01 <Jafet> Nine-nines uptime isn't gross.
05:11:10 <Jafet> ...at least, they claim nine nines.
05:11:15 <dom96> ddarius: oh, so which one should i use?
05:11:44 <ManateeLazyCat> Axman6: I think XMonad use reboot solution. :) 
05:11:46 <dom96> ddarius: Text.Parsec is Parsec 3 isn't it? So i should use that?
05:11:57 <ManateeLazyCat> Axman6: Reboot so fast that user haven't noticed that.
05:12:01 <gds> Huh.
05:12:37 <ddarius> dom96: You will have to use Parsec 3 if you want to work with ByteStrings, say, instead of Strings.  Or if you actually need the monad transformer aspects.
05:12:39 <gds> I just did "cabal install happy", which finished with "linking dist/build happy" and "installing happy in /home/gds/.cabal/bin"
05:12:44 <ManateeLazyCat> Or better hot-swapping idea than mine?
05:12:46 <Jafet> Putting code into different processes and restarting them is another way to have hot-swapping
05:13:07 <gds> and then I do "cabal list happy" and see " Latest version installed: [ Unknown ]"
05:13:16 <dom96> ddarius: I see. Thanks.
05:13:18 <Jafet> But it normally involves inter-process communication, and is a little bit slower
05:13:21 * hackagebot SpaceInvaders 0.4.2 - Video game  http://hackage.haskell.org/package/SpaceInvaders-0.4.2 (GeorgeGiorgidze)
05:13:28 <ManateeLazyCat> Jafet: Yeah, like my Manatee, all extension is running in separate process, but reboot will lost state. :)
05:13:55 <Saizan> gds: cabal only sees libraries as installed
05:14:17 <Jafet> ManateeLazyCat: not sure if you want to keep the state of the process... the new version might use a different state
05:14:56 <mreh> :t whne
05:14:57 <lambdabot> Not in scope: `whne'
05:14:59 <mreh> :t when
05:15:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:15:03 <ManateeLazyCat> Jafet: Yeah, keep state between old and new version still is a problem....
05:15:12 <gds> Saizan: So, haskell-src-exts claims to require happy >= 1.17 ...
05:15:35 <Jafet> You can design a special message "save-state-and-reboot" that every process should implement.
05:15:51 <Jafet> Then the process decides how to save state in a version-independent way.
05:16:08 <gds> Saizan: I can just delete the dependancy from the /
05:16:12 <gds> .cabal file...
05:16:56 <ManateeLazyCat> Jafet: Problem is some situation, reboot is unacceptable, like you're running some command in terminal, I guess you don't want *re-execute* command again after reboot. :)
05:17:20 <ManateeLazyCat> Jafet: My aim is make application update itself and don't need reboot. 
05:20:08 <Saizan> gds: no
05:20:25 <Saizan> gds: the problem there is that you don't have happy on your PATH
05:20:29 <gds> Ah!
05:20:37 <Saizan> gds: add /home/gds/.cabal/bin
05:20:38 <gds> Thanks - this I can fix :)
05:21:39 <CindyLinz> ManateeLazyCat: Sounds like you need something called "graceful restart" ?
05:21:58 <ManateeLazyCat> CindyLinz: My aim is don't need restart. :)
05:22:17 <ManateeLazyCat> CindyLinz: Just like Emacs, but don't use interpreter policy
05:22:39 <Xilon> Is it just for updating the software? I don't think it's worth the effort. Saving state and restoring would probably be easier
05:23:29 <bremner> ManateeLazyCat: how come you don't use an interpreter?
05:24:04 <CindyLinz> ManateeLazyCat: The process could hand over fd to another, so that user will not notice that
05:24:32 <Jafet> I wonder how far you can abuse ghc's implicit variables to get configurable programs
05:25:24 <ManateeLazyCat> CindyLinz: All new version code still re-compile in backend, just bulid server dynamic linking new entry in runtime program, just idea, haven't implement it.
05:25:59 <ManateeLazyCat> bremner: ^^^^
05:26:06 <CindyLinz> ^^|
05:26:23 <ManateeLazyCat> bremner: interpreter need check everytime you call functoin.
05:26:32 <ManateeLazyCat> bremner: IMO, it's not unnecessary in most time. :)
05:27:03 <ManateeLazyCat> bremner: If use interpreter solution, it will make Haskell slow as elisp. :)
05:28:12 <bremner> ManateeLazyCat: instead of C core, you could have compiled haskell core.
05:29:10 <ManateeLazyCat> bremner: Just post here, haven't implement, hope other people have better idea than mine. :)
05:30:19 <bremner> ManateeLazyCat: I don't know much about it, but it seems that xmonad has a bit the same problem. It would be nice not to need ghc to change the config.
05:31:01 <ManateeLazyCat> bremner: I have similar code like XMOnad, save-reboot-restore 
05:31:14 <ManateeLazyCat> bremner: But i don't want use that policy.
05:32:05 <ManateeLazyCat> bremner: I perhaps just test this feature with user's configre file, disable update application self....
05:32:32 <ManateeLazyCat> But it's same since user can write his own code in config file.
05:33:31 <tibbe> anyone with CPP-fu that can tell me why this doesn't work
05:33:41 <tibbe> define INLINABLE(f) {-# INLINABLE f #-}
05:33:58 <tibbe> when called as: INLINABLE(foo') is get an error message about the use of '
05:34:10 <ManateeLazyCat> Anyway i will try to modified pdynload's code to test my idea, thanks all for help . :)
05:35:24 <ndm> tibbe: is it perhaps lexing the ' as a c character
05:35:39 <tibbe> ndm: do you know how to escape that?
05:35:43 <ndm> tibbe: have you tried that same trick with cpphs, much better chance of success
05:35:52 <edwardk> ddarius: btw- precategories compiled with the fancier hom-sets, though i need to rewire their products and duals to handle the new ob machinery
05:36:10 <ndm> tibbe: no idea how to escape that, if it's even possible
05:36:29 <tibbe> ndm: :/
05:36:31 <ndm> \' would be the only thing i can think of, although there is probably some cpp thing
05:36:42 <tibbe> ndm: this is for containers so I don't know if I want to pull in cpphs
05:36:49 <tibbe> ndm: I tried \;
05:36:52 <tibbe> \'
05:36:58 <edwardk> ddarius: made a branch to track the funny hom-sets. https://github.com/ekmett/magpie/blob/dinatural-hom/src/main/scala/magpie/hom.scala
05:37:34 <Jafet> Just use cpphs.
05:38:30 <ndm> tibbe: have you tried #define INLINABLE_(f) = {-# INLINABLE f' #-}
05:38:37 <ndm> i.e. move the ' inside the define
05:39:48 <Jafet> I'm not sure why you need a macro for that, anyway.
05:47:29 <ddarius> edwardk: Have you tried building with 2.9?
05:47:44 <edwardk> same bug
05:49:01 <ddarius> Color me unsurprised.
05:49:05 <edwardk> =/
05:49:18 <adnap_> how do you convert a double to a float?
05:49:31 <ddarius> realToFrac
05:49:36 <adnap_> ty
05:49:44 <ddarius> fromIntegral and realToFrac cover all your numeric conversion needs.
06:22:14 <qsorix> Hi guys, this is my first time here. I've got a question about exception handling
06:22:32 <qsorix> http://hpaste.org/42082/exception_in_an_interruptible
06:23:19 <qsorix> the problem is that when I use putMVar with finally, the exception is not re-raised
06:23:37 <basti_> qsorix: maybe someone can help you. i can't, right now. but you're welcome.
06:23:55 <qsorix> thanks basti_ 
06:29:57 <dom96> Is there an alternative to the http package with SSLv3 support, except for http-enumerator and curl? (http-enumerator doesn't seem to be working very well)
06:31:55 <aristid> dom96: you got problems with http-enumerator? i want to use it, so i'm curious about that
06:32:03 <aavogt> qsorix: you should have a   {-# NOINLINE children #-}
06:32:48 <dom96> aristid: perhaps I am doing something wrong, but i just get a 404. I'm trying to make a new gist.
06:34:19 <dom96> I wish there was a way to check what it sends to the server.
06:35:52 <aristid> there is.
06:35:55 <aristid> use wireshark
06:36:08 <aristid> well, that doesn't really work with SSL tho :D
06:36:30 <dom96> Yeah... :\
06:37:07 <dom96> But i can just make it non-ssl i guess :P
06:37:10 <qsorix> aavogt: could you elaborate please? because just adding that didn't solve my problem
06:38:20 <aristid> dom96: http-enumerator worked in my experiments, so i'm a bit curious
06:38:37 <dom96> aristid: What did you use it for?
06:39:17 <aavogt> qsorix: well ghc could inline your unsafePerformIO'd mvar, which will mean you don't refer to the same mvar each time
06:39:38 <aristid> dom96: i'm writing aws bindings :D currently progress is slow because i'm busy doing a seminar for my university, tho
06:40:27 <dom96> aristid: I see, nice.
06:40:48 <aristid> dom96: https://github.com/aristidb/aws
06:40:56 <qsorix> aavogt: i see. but this doesn't affect behaviour in my case, thanks
06:41:28 <aristid> dom96: see branch http-enumerator for my incomplete work on moving from curl to http-enumerator
06:41:30 <dom96> aristid: I'm working on a little pastebin application :P
06:41:47 <aristid> dom96: and that needs an http client?
06:41:56 <dom96> yes.
06:42:00 <aristid> for what?
06:42:46 <dom96> To POST to gist/pastebin.com/other pastebin sites.
06:45:11 <dom96> I have no idea how to use Wireshark.
06:45:25 <aristid> which platform are you on?
06:45:25 <Jonno_FTW> dom96: what are you trying to do
06:45:35 <dom96> Linux
06:45:40 <aristid> dom96: sudo wireshark
06:45:48 <aristid> and then tell it to capture
06:46:12 <dom96> ahh, now i have interfaces.
06:49:23 <ClaudiusMaximus> anyone got any tips for writing RealFloat instances?  not even sure if my type is a sane RealFloat, but i need it for  data RealFloat a => Complex a
06:50:31 <dom96> Yeah, i'm not gonna be able to use this...
06:52:30 <aristid> dom96: what's the URL you're trying to reach? maybe i can try it
06:52:49 <dom96> aristid: https://gist.github.com/gists
06:54:04 <mreh> what's the behaviour of a dervied Ord?
06:54:16 <mreh> those appearing before are less than the others
06:54:23 <mreh> appearing after
06:54:56 <aristid> dom96: works for me
06:55:04 <aristid> dom96: i tried it with simpleHttp
06:55:35 <dom96> aristid: I suppose it works with GET.
06:55:59 <mreh> the answer is yes
06:56:13 <aristid> dom96: you didn't tell me to use another HTTP method
06:56:47 <dom96> aristid: Use POST.
06:57:15 <aristid> dom96: what should be the body?
06:58:03 <aavogt> qsorix: well I can suggest using   throwTo   with the ThreadId from the main thread (from myThreadId) may do what you want
06:59:52 <dom96> aristid: I used parseUrl and then urlEncodedBody with http://hpaste.org/42083/headers
06:59:53 <qsorix> aavogt: first of all, I'd like to understand why my code isn't working
07:00:19 <qsorix> aavogt: beause as far as I understand, it should :)
07:00:21 <aavogt> qsorix: you want the main thread to die when the forked ones do?
07:01:17 <aavogt> you can see that    forkIO undefined   does nothing for the main thread
07:01:30 <aristid> dom96: i can reproduce that you first get a 302 redirect and then a 404
07:01:45 <aavogt> so finally does re-raise the exception, but not where you'll see a difference
07:01:52 <aristid> dom96: i used no headers tho
07:02:19 <dom96> yeah, I know that I get a 404.
07:02:25 <qsorix> aavogt: so why i see the exception if i replace putMVar var () with that commented putStrLn?
07:02:42 <aristid> dom96: that's weird. maybe you should contact the author of http-enumerator?
07:03:13 <aavogt> qsorix: I'm guessing the main thread gets to quit before the exceptions get printed
07:03:15 <dom96> aristid: Yeah. I suppose I should.
07:03:35 * dom96 writes a test case.
07:03:36 <qsorix> aavogt: ooh. i didn't think of that
07:04:02 <aavogt> qsorix: say you run       forkIO (io `finally` forkIO (threadDelay 10000 >> putMVar mvar ()))
07:04:06 <aristid> dom96: i still think http-enumerator is the nicest http library
07:04:21 <aristid> dom96: but it's probably still got some bugs
07:04:28 <dom96> aristid: I would too if it worked :P
07:04:36 <aavogt> that prints the exceptions
07:04:45 <aristid> dom96: curl works well, but the API is terrible
07:04:58 <aristid> dom96: i'd rather ping the author of http-enumerator
07:04:59 <dom96> aristid: Yeah, i looked at curl, it scared me.
07:05:57 <qsorix> aavogt: hm. it does
07:06:08 <aavogt> qsorix: another thing to look into is whether there's any buffering on stderr
07:06:53 <aavogt> but I guess that's not necessary to explain what happened in this example
07:08:02 <qsorix> aavogt: OK, i put that delay in main after waitForChildren and I see the exception there
07:08:04 <aristid> dom96: i actually tried to use curl. it works. but i'd rather stick a fork in my ear :D
07:08:06 <jro> minutes <- ((liftM (\a b -> a:b:[]) number05) >>= \o -> (liftM o number)) <|> do { (number >>= \a -> return (a:[])) } 
07:08:11 <jro> notFollowedBy number
07:08:40 <dom96> aristid: heh, i was about to use curl, but when i saw the API i changed my mind :P
07:08:41 <mreh> :t fromEnum
07:08:42 <lambdabot> forall a. (Enum a) => a -> Int
07:08:44 <aristid> .oO(list sections)
07:08:48 <mreh> :t toEnum
07:08:49 <lambdabot> forall a. (Enum a) => Int -> a
07:08:50 <jro> the first question is: thing before <|> parser correctly 00-59
07:09:07 <aristid> dom96: you shouldn't immediately switch away from a library just because you found a bug, anyways
07:09:08 <hpc> :t (<|>)
07:09:09 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
07:09:16 <aristid> dom96: that's unfair to the author of the library
07:09:18 <hpc> [1..3] <|> 4..6]
07:09:20 <jro> but there might be a simpler thing
07:09:21 <hpc> > [1..3] <|> 4..6]
07:09:21 <lambdabot>   <no location info>: parse error on input `..'
07:09:28 <hpc> > [1..3] <|> [4..6]
07:09:29 <lambdabot>   [1,2,3,4,5,6]
07:09:31 <dom96> aristid: Yeah, you're right.
07:09:52 * hackagebot Grempa 0.1.1 - Embedded grammar DSL and LALR parser generator  http://hackage.haskell.org/package/Grempa-0.1.1 (OlleFredriksson)
07:10:33 <qsorix> aavogt: thanks for help, with your tips i'll try to investigate this further to better understand what happens
07:12:35 <mreh> fromEnum 9001
07:12:38 <mreh> > fromEnum 9001
07:12:39 <lambdabot>   9001
07:12:44 <mreh> > fromEnum 9001 :: Bool
07:12:45 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
07:12:45 <lambdabot>         against inferred type ...
07:12:57 <mreh> > (toEnum 9001) :: Bool
07:12:58 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
07:13:09 <mreh> am I being dense
07:13:17 <mreh> :t toEnum
07:13:19 <lambdabot> forall a. (Enum a) => Int -> a
07:13:57 <dblhelix> exit
07:14:06 <dblhelix> sorry, wrong screen :)
07:14:42 <mreh> > toEnum 9001
07:14:43 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
07:14:47 <mreh> > toEnum 0
07:14:48 <lambdabot>   ()
07:14:50 <mreh> > toEnum 1
07:14:51 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
07:15:26 <aristid> > toEnum 1 :: Ord
07:15:27 <lambdabot>   Class `GHC.Classes.Ord' used as a type
07:15:35 <aristid> > toEnum 1 :: Ordering
07:15:35 <lambdabot>   EQ
07:16:03 <mreh> I wanted to parse my verbosity arguments with toEnum
07:16:27 <mreh> then it would be more future proof
07:16:36 <mreh> if I wanted to add more levels of verbosity
07:18:12 <mreh> min (map fromEnum [True..]) 9001
07:18:18 <mreh> >min (map fromEnum [True..]) 9001
07:18:27 <mreh> > min (map fromEnum [True..]) 9001
07:18:27 <lambdabot>   <no location info>: parse error on input `]'
07:18:34 <aristid> mreh: haha, you're not having luck today
07:18:51 <mreh> > min (maximum . map fromEnum $ [True..]) 9001
07:18:52 <lambdabot>   <no location info>: parse error on input `]'
07:19:47 <mreh> so much fail
07:20:41 <kstt> does anybody know why this code ( https://github.com/chrisdone/throttle/blob/master/src/Main.hs ) is CPU bound when compiled with ghc 6.12, -threaded and RTS -N 2 ?
07:20:57 <aristid> > [True..]
07:20:58 <lambdabot>   <no location info>: parse error on input `]'
07:21:00 <aristid> > [True.. ]
07:21:01 <lambdabot>   <no location info>: parse error on input `]'
07:21:05 <aristid> > [True .. ]
07:21:06 <lambdabot>   [True]
07:21:09 <aristid> wtf
07:21:12 <aristid> ooh
07:21:15 <mreh> > min (maximum . map fromEnum $ [ False .. ]) 9001
07:21:16 <lambdabot>   1
07:21:25 <aristid> mreh: i think the problem is that True.. is an operator
07:21:47 <mreh> aristid: in what language?
07:22:11 <byorgey> True.. parses as the (.) operator from the True module
07:22:14 <aristid> mreh: haskell.
07:22:48 <mreh> True module?
07:22:58 <mreh> that's not even a type
07:23:00 <aristid> that's the evil of separate lexing and grammar
07:23:15 <aristid> mreh: so? nothing stopping you from writing a True module
07:23:18 <byorgey> you know, Data.List.elem, Prelude.+, True..
07:24:34 <mreh> interesting
07:24:52 <mreh> > :t True..
07:24:53 <lambdabot>   <no location info>: parse error on input `:'
07:24:56 <mreh> :t True..
07:24:57 <lambdabot> parse error on input `True..'
07:25:07 <mreh> *&"&^"£"%^"&
07:25:44 <mreh> @src Enum
07:25:44 <lambdabot> class  Enum a   where
07:25:44 <lambdabot>     succ                     :: a -> a
07:25:44 <lambdabot>     pred                     :: a -> a
07:25:44 <lambdabot>     toEnum                   :: Int -> a
07:25:44 <lambdabot>     fromEnum                 :: a -> Int
07:25:46 <lambdabot> [3 @more lines]
07:25:50 <mreh> @more
07:25:50 <lambdabot>     enumFrom                 :: a -> [a]
07:25:50 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
07:25:52 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
07:26:22 <mreh> this is going to produce the worst code in the world, but it'll work!
07:26:25 <aristid> mreh: you know, maybe you should take your misadventures to a query with lambdabot ;)
07:26:37 <mreh> yeah, I suppose
07:26:48 <mreh> but what about the restraining order?
07:26:55 <aristid> haha
07:27:56 * hackagebot Grempa 0.1.2 - Embedded grammar DSL and LALR parser generator  http://hackage.haskell.org/package/Grempa-0.1.2 (OlleFredriksson)
07:28:50 <mreh> lexing does make simpler parsers
07:29:04 <mreh> more efficient parsers I should say
07:36:10 <niteria> does anyone know where can i find working link for 'http://www.haskell.org/haskellwiki/Typeclassopedia' ?
07:37:02 <hpc> @where typeclassopedia
07:37:02 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:37:12 <hpc> huh
07:37:19 <niteria> link is broken
07:39:41 <niteria> ok, i've found it somewhere else
07:44:45 <Kaidelong> http://hpaste.org/42084/occurs_check_with_simple_insta
07:44:53 <Kaidelong> anyone can help me here?
07:45:50 <Kaidelong> oh wait
07:45:50 <Kaidelong> I think it's the missing returns
07:46:47 <Kaidelong> nm, I got it
07:46:59 <Kaidelong> two returns were missing, now things work as I was originally planning
08:05:13 <copumpkin> jix: ask here :P
08:08:18 <ddarius> copumpkin: Sorry to pass out on you.
08:12:41 <unkanon> I have this: \xs -> removeAt bla xs
08:12:51 <unkanon> now bla returns [x] and I need an x there
08:13:26 <unkanon> what's a better way to do that than \xs -> removeAt ((\(x:[]) -> x) bla) xs  ?
08:13:34 <aavogt> head
08:14:08 <unkanon> doh of course :)
08:14:08 <Twey> \xs -> blah xs = blah
08:14:21 <aavogt> unkanon: or do you need to guarantee that the list has only one element?
08:14:31 <Twey> removeAt (\[x] -> x) bla = removeAt head bla
08:14:36 <unkanon> no, the list is guaranteed to have only one element
08:14:55 <unkanon> Twey: oh ok, I didn't know I could pattern match using []
08:15:10 <unkanon> but I'll use head, thanks guys
08:15:22 <aavogt> the pattern match is better in that it'll give you a clearer indication if/when your assumptions are wrong
08:15:37 <unkanon> you mean it'll give me better error messages?
08:15:40 <unkanon> I'm all for that
08:16:17 <aavogt> unkanon: it'll fail if you're given a list with 2 elements. And if the list is empty:
08:16:20 <aavogt> > head ""
08:16:21 <lambdabot>   *Exception: Prelude.head: empty list
08:16:30 <unkanon> right yeah head is partial
08:16:32 <aavogt> > (\[x] -> x) ""
08:16:33 <lambdabot>   *Exception: <interactive>:1:134-142: Non-exhaustive patterns in lambda
08:17:05 <AmunRa> Hello! Is there some scaffolding script for creating a standard directory structure and cabal files?
08:17:15 <aavogt> cabal init
08:17:24 <Twey> > head ""
08:17:25 <lambdabot>   *Exception: Prelude.head: empty list
08:17:31 <Twey> The head has a nicer error message
08:17:48 <unkanon> in this case yes
08:17:50 <aavogt> AmunRa: but it only makes a .cabal and a Setup.hs
08:18:01 <aavogt> Twey: which would you rather debug though?
08:18:13 <AmunRa> aavogt: that's fine.. that's the more fiddly stuff
08:18:16 <Twey> The head, probably
08:18:39 <Twey> Oh, you mean in the case that *too many* elements are passeD?
08:18:42 <Twey> passed**
08:19:06 <aavogt> I guess you've never had some code fail with  "*Exception: Prelude.head: empty list", and have no idea which of the 50 calls to head is at fault
08:19:23 <Twey> aavogt: Means you're using ‘head’ too much ;)
08:19:43 <unkanon> well one key difference is that the lambda says exactly where the error is (line and column)
08:19:46 <aavogt> yes, once is too much
08:19:53 <Twey> I don't tend to use it at all, really — I prefer ‘list (error "Descriptive error message here") const’
08:19:54 <Zao> Simply make a thousand aliases for head that catch the exception and rethrows it with a description :D
08:20:01 <unkanon> maybe that's what aavogt is referring to
08:20:58 <aavogt> there's the ghci debugger for finding where stuff happens, but that's provided you can reproduce the failure
08:21:18 <aavogt> unkanon: exactly
08:21:41 <unkanon> so yes, I'd rather debug the one that has the line and column number, no doubt about it :)
08:23:16 <aavogt> @hackage interlude
08:23:16 <lambdabot> http://hackage.haskell.org/package/interlude
08:23:53 <pumpkin> ddarius: no problem, I was still pretty tired anyway :)
08:26:59 <unkanon> copumpkin, you look... different
08:27:11 <pumpkin> lol
08:27:25 <pumpkin> I accidentally pulled my ethernet adapter out of my usb port and got disconnected
08:27:28 <pumpkin> no wireless at my apartment yet
08:27:49 <ddarius> What's your ethernet adapter doing in your USB port?
08:27:54 <unkanon> oh :)
08:28:12 <copumpkin> ddarius: it's a USB ethernet adapter! cause this laptop has no ethernet port of its own
08:28:33 <ddarius> Where do you find such a laptop?
08:28:49 <geheimdienst> ethernet adapter in the usb port? my word, kids these days. in my day we had laptops that had ethernet built in
08:29:08 <copumpkin> ddarius: in an apple store :P
08:29:35 <ddarius> Well now I know where not to look for laptops.
08:30:01 <ddarius> Unfortunately I don't feel like I gained any information.
08:30:01 <unkanon> it's a tradeoff, it's got its advantages
08:30:08 <unkanon> it's a macbook air
08:30:10 <ddarius> unkanon: Like a higher price!
08:30:26 <unkanon> that would be one of its disadvantages, yes
08:31:15 <copumpkin> it's pretty light
08:31:15 <geheimdienst> http://www.youtube.com/watch?v=_hnOCUkbix0 <- "we build it in"
08:31:47 <ddarius> copumpkin: Ed has some strange vim habits by the way.  (Apropos to nothing.)
08:31:51 <unkanon> geheimdienst: I'm actually going to sell my macbook to buy a lenovo and switch to linux
08:31:55 <copumpkin> ddarius: like what?
08:32:12 <unkanon> ed is the standard editor
08:32:42 <Twey> Hehe
08:33:06 <ddarius> copumpkin: I'm not exactly sure which command he's using, but something like 10000k to get to the end of a file.
08:33:26 <ddarius> Which of course assumes the file is less than 10,000 lines long.
08:33:35 <copumpkin> :o
08:34:36 * ddarius suspects that he could quickly filter potential mates by describing his morning.
08:34:42 <copumpkin> geheimdienst: ew, I wouldn't want that
08:34:43 <unkanon> Twey: I just found out that (!!)'s error messages suffer from the same problem as head's
08:34:50 <copumpkin> geheimdienst: it's way more expensive than my macbook air, and is heavier
08:35:09 <copumpkin> :P
08:35:15 <copumpkin> and thicker
08:35:43 <unkanon> I love the track nub thingy thought
08:35:47 <unkanon> don't know what it's called
08:36:01 <bremner> trackpoint
08:36:08 <unkanon> yeah
08:36:18 <unkanon> never leaving the home row, not even to use the mouse.
08:36:21 <geheimdienst> unkanon: was similar for me. i had a macbook for a year (back when they were called powerbooks), but when the "oooh shiny" feeling wears off, it's just some computer, from a vendor that treats you like crap
08:36:41 <unkanon> geheimdienst: then you bought a lenovo and put linux on it?
08:36:57 <ddarius> geheimdienst: Some people like being treated like crap.
08:36:59 <geheimdienst> yes, t61. i'm perfectly happy with it
08:37:41 <unkanon> what linux are you using? or in other words, do I have to install Arch or Gentoo if haskell is my lang-of-choice or can I just go with ubuntu?
08:37:50 <unkanon> (I already use ubuntu at work)
08:39:05 <geheimdienst> ddarius: i think the shiny is the more important part. nearly everyone gets excited by that, including people who think of themselves as rational ...
08:39:34 <geheimdienst> unkanon: i had ubuntu, but got fed up with stuff breaking every 6 months. i dumped it for arch and i like that better
08:39:43 * ddarius rationally believes that his belief in his own rationality is laughable.
08:40:05 <ddarius> Apply shiny doesn't appeal to me at all.
08:40:14 <parcs> unkanon: seems like arch linux is the distro of choice for haskell
08:40:26 <unkanon> geheimdienst: the reason I got a macbook, to be honest, was because I wanted a unix environment but didn't want a Linux (bad experiences with it in the past)
08:40:29 <Twey> You can do it with Ubuntu, though.
08:40:35 <unkanon> parcs: yeah I'm guessing I'll go with it
08:40:37 <Twey> Just install cabal-install and cabal install everything.  >.>
08:40:49 <ddarius> cabal install cabal-install
08:41:32 <geheimdienst> unkanon: i don't really know why you would prefer distro X "because of haskell". as long as it runs cabal, you're done. i think ubuntu is as good as anything for haskelling
08:42:15 <bremner> just depends if you want to use distro packages or not.
08:42:16 <unkanon> geheimdienst: well it's not just because of haskell, it will be my home computer for me to use for eveyrthing
08:42:37 <Twey> Well, no, because having the packages in the distro's repos mean they integrate better with the rest of the stuff on your system
08:42:41 <Twey> And update automatically, &c.
08:43:05 <ddarius> copumpkin: If you are interested in wandering about the Fells today tell me.  We could also attempt to hunt down Nipponese alcohol but I imagine we both have work and the Sunday night crowd is probably strange.
08:43:36 <ddarius> (Not that I really plan on staying out late looking for alcohol on a Sunday.)
08:43:54 * geheimdienst is an arch user and briefly tried 2-3 distro packages, but they were all in AUR (= more difficult to install) and didn't even come with documentation ...
08:44:04 <copumpkin> ddarius: I have lots errands I need to run unfortunately :/
08:44:11 <geheimdienst> ... so i went back to cabal for everything
08:47:34 <ddarius> I need to buy something to get three quarters in change.  What should I buy?
08:47:49 <geheimdienst> a quarter
08:48:31 <ddarius> Tax would lead to that giving me less than 75 cents in change.
08:48:33 * Twey 's first reaction was ‘Three quarters of what?’.  Crazy Merkins…
08:49:37 <tg_> ddarius: can I get four quarters for this <unitary currency>?
08:49:51 <tg_> If they get scissors out, rephrase the question.
08:49:57 <mreh> who is Brian Lewis?
08:50:06 <tg_> @google Brian Lewis
08:50:07 <lambdabot> http://www.brianlewisviolin.com/
08:50:07 <lambdabot> Title: Brian Lewis | Violinist - Home Page
08:50:26 <ddarius> Speaking of violin...
08:50:37 <mreh> he needs to update language dot to use mtl 2
08:50:48 <mreh> unless there's a way I can conditionally compile
08:51:08 <mreh> I want to use monadIO a la transformers 0.2 in mtl 2
08:51:16 <tg_> Brian Lewis <brian@lorf.org>
08:51:58 <tg_> mreh: it's hosted on git, you could submit a patch
08:52:18 <mreh> hmm
08:52:59 <aavogt> preflex: seen benmachine
08:52:59 <preflex>  benmachine was last seen on #haskell 18 hours, 22 minutes and 48 seconds ago, saying: k
08:53:00 <mreh> git - the stupid content tracker
08:53:19 <Zao> Content authored by stupids?
08:53:26 <mreh> ls
08:53:39 <mreh> that's what my man page says
08:53:59 <tg_> surely Linus's attempt at humor
08:54:05 <tg_> Linus'?
08:54:08 <Yrogirg> Hello, I need precision more than Double. And I want to have it in the program already written. What is the easiest way to get higher precision (smth like just changing types)?
08:54:24 <aavogt> @hackage CReal
08:54:24 <lambdabot> http://hackage.haskell.org/package/CReal
08:54:38 <mreh> if linus's programming was like his humour...
08:54:38 <aavogt> @hackage numbers -- has CReal
08:54:39 <lambdabot> http://hackage.haskell.org/package/numbers -- has CReal
08:55:03 <tg_> also http://hackage.haskell.org/package/AERN-Real
08:55:55 <tg_> aavogt: not to be confused with
08:55:58 <tg_> @hackage cereal
08:55:58 <lambdabot> http://hackage.haskell.org/package/cereal
08:59:18 <ddarius> My man page says "No manual entry for git"
08:59:19 <dom96> aristid: ping
08:59:55 <aristid> dom96: yeah?
09:00:35 <dom96> aristid: I got it working. Although I think http-enumerator has a bug with redirection.
09:01:19 <aristid> dom96: what is the bug with redirection?
09:01:31 <dom96> All i had to do is use httpLbs instead of httpLbsRedirect, and look at the Location header.
09:01:49 <aristid> ok, so you just had to redirect manually?
09:01:51 <dom96> aristid: I'm not sure, it seems as if it doesn't read the Location header correctly.
09:02:08 <dom96> aristid: I don't actually need to redirect, all I need is that URL.
09:02:14 <aristid> dom96: well, that looks like something snoyman could easily fix! :)
09:02:26 <dom96> aristid: Yeah, i'm sending him an email.
11:13:19 --- topic: '["GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
11:13:19 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Wed Nov 24 17:56:54 2010]
11:13:19 --- names: list (clog twaffle hoknamahn_ AmunRa gemelen magicman eb4890 amiri FeiRuoWa jimmyjazz14 unon ab3 Azrael- Rotaerk jeltsch molbdnilo asflierl vitka baguasquirrel Benjamardo kaf Tezeract jethomas tibbe Aune jaspervdj Maytsh applicative sannysanoff dino- stenobot2011 Jantaro morricone flippo Cin pikhq copumpkin Eduard_Munteanu andyjgill schroedinbug ekidd sm mlesniak stianhj wippler dancor jedai MigoMipo Amadiro mino mtnviewmark freiksenet BCoppens raichoo jutaro)
11:13:19 --- names: list (thetallguy chreekat ceii Colours maurer_ dcoutts_ hgolden borism evildalton preflex Utkarsh em zomg majoh pix| davidL abbe quidnunc hiredman Unforgivable mejalx ddarius Nereid alexsuraci Snark bbee inimino cognominal naraga paper_cc kamatsu_ Zephyrus ddilinger kolmodin _br_ Miciah killerswan tab hvr_ onehundredtwenty kaini fpletz joe6 int-e_ snr_ SecretAg1nt regalia_ brailsmt_ iFire` duairc_ thiago__ steve_hi` Jaak_ jvogel_ nominolo_ tridactyla andern Sunhay_)
11:13:19 --- names: list (crutcher rkrzr MoALTz_ Fuco jao hoknamahn andrewe ibt Rayne path[l] djl Yacoby desu h_man paolino geheimdienst hzh_ MrFahrenheit lanthan overscore1 Nshag dual unkanon Kaidelong ketil int80_h povik dfkjjkfd_ Yvemath Oejet mmaruseacph2 bos nff JaffaCake Darkone carlocci ndrsndrs demolithion weebl edlinde helgikrs _s1gma Palmik bgs100 mceier Hilbert khiroc edwardk haskeller THC4k Olathe phyrex1an joerisamson mreh emiel_ engla msieradzki ms4py lopex antimatroid1)
11:13:19 --- names: list (iago FireFly novas0x2a medfly trin_cz Shown lokydor iveqy IIcke basti_ ulfdoz Icewing morphling yitz ExtraSpice der_eq s76_ comak ceii_ bsod1 dschoepe Schmallon sipa edon earthy pacak Rutix m3ga dolio CindyLinz muep ski danvet point-triangle nchaimov RayNbow PepeSilvia gniourf_gniourf zax chemuduguntar cibs augur lsthemes xenyl insomniaSalt araujo janbanan portnov mauke zeiris_ Vicfred xinming dcolish scm Cthulhon phenom_ ilab dfeuer waern abiraja)
11:13:19 --- names: list (krainboltgreene Philippa_ wto anders^^ otto_s Philonous blackdog xxpor mgsloan danblick baldo ousado_ lispy palmje parcs andersk smiler sgtarr geekounet leoncamel cubi sciolizer siracusa theorbtwo mpiechotka remy_o mjrosenb Cobra_ rothwell sbahra ville arkx arcatan Fingerzam klugez ormaaj akosch damex Gracenotes erg0t dmwit Fullma Axman6 Draconx|Laptop mcglk _nickel Itkovian xarch gereedy sonnym arnihermann saccade drbean henr_k jmv_ meanburrito920 eyck)
11:13:19 --- names: list (Baughn BurgessShale saurik adimit __nickm__ hamishmack lyn dubhrosa eregon Vq comb cozmic sophacles nimred DJ_Ice wagle woodworm kermit moozilla pastorn sidke necroforest aculich Martty Hugglesworth jsgf electrogeek `0660 jbauman ricky xplat knobo Saizan kadoban brisbin FauxFaux Igloo devinus perlite Berengal tswett suiside museun helgim_ jomat rdd thorkilnaur Innominate Raku^ dRbiG flori polarina edenc Twey felipe_ Anoq dMazz m4thrick thetallguy1 gienah)
11:13:19 --- names: list (onteria|i7 dreixel comex spetrea_ Maxdamantus Dashkal jkimball4 CodexArcanum cYmen willb eno gbeshers BMeph fxr Counter-Strike sasha__ alip tg_ Ornedan ksandstr xmikedavis hc Zol cizra Cale yiannis_t ben Aestas shepheb sshc Sisu andrewsw tiz luite Paradox924X vili_ gju_ timchen1` The_third_man adnap_ bqf ve jcapper rizzen`` tobiw [df] dibblego niko shutdown_-h_now srcerer entrosca sajkr derekwright chitragupt kniu kaol AnAdorableNick teratorn sbok epmf flux)
11:13:19 --- names: list (jkr djfm Eelis endojelly Vorpal path Janno ivan waern_ ernst TacticalGrace Veinor jpatota gdsx jonafan ps-auxw Zao proq mikeg nostrand dixie mindwarp alexbobP jro levitation_ chromakode monochrom rks waterlaz bartavelle Leemp mattam spetrea Spacejoker ixzkn yurug Laney ortmage mux mm_freak Muad_Dibber mrd benmachine mrshoe trez Ke slaye jon_of_arc [swift] Starfire hirsch mortberg mafs Rooz kurganme joeytwiddle nniro liesen nothingmuch shachaf mee pygmalion)
11:13:19 --- names: list (caligula __marius__ Raynes freedrull lalle Xorlev fihi09``` danly mercury^ alexsdutton ToRA qebab finnomenon Aisling jb55 Liskni_si EvanCarroll noj jix netcat And[y] dionoea_ sohum cjay ion _janne erk_ snorble_ Valodim onteria Sonicvan1Jr fabjan_ ziman franksh_ integral A1kmm profmakx stepnem edwtjo bremner semifor_ djahandarie nornagon joni6128 allbery_b companion_cube ninegrid bd_ ath ede BONUS osfameron bolmar_ koninkje_away ClaudiusMaximus dom96)
11:13:19 --- names: list (robinsmidsrod absentia StoneToad Lemmih blackrain orclev tromp_ cpa jd10 yrlnry koala_man ibid gds dimensia rokoteko dogmaT_ boyscared defn aleator_ Nanar Boney mlh dilinger_ Reisen alpounet jayne johs DustyDingo idnar mornfall zakwilson fnordus dqd endpoint_david solidsnack Deewiant dm120769 cynick guerrill1 ray canvon samulihs_ tessier_ pettter_ noddy2000 drhodes Vulpyne_ BrianHV OnionKnight sleepynate sid3k aristid mvid_ danr HalfWayM1n jdsc_ newsham)
11:13:19 --- names: list (deavid jql DrSyzygy jlouis obraun solarus ido liyang marienz scree jamwt itsjar Guest35776 npouillard Jiten Alan Cerise wires alios FDFlock d-snp jrk_ Belgarion0 yahooooo arkonten welterde jvoorhis ahf vandemar jyper jmcarthur hellige birkenfeld Scala hyko MasseR shortcircuit frerich quicksilver svk_ cyanoacry Guest32383 cathper tmuki TML SimonRC Mitar harlekin Botje jrockway duckinator Razz Obfuscate idoru skaar slabanja kalven thoughtpolice dropdrive Gilly)
11:13:20 --- names: list (KaneTW tafryn ChongLi quaestor muhtimin mietek untwisted encryptio milli Bleadof bezik opqdonut exDM69 deadguys pantsd kwuxalot ahihi Hunner sproingie McManiaC Gabbie kosmikus inr_ dumael Blub\0 norm2782 david` zygoloid saiam lantti _2x2l stroan shawn davean elliottcable aavogt aempirei @ChanServ guybrush tomaw taruti CosmicRay pigoz tamiko emias burp byorgey danderson aj| nlogax Firegolfer dorkitude jml dax aiko_)
11:14:10 <twaffle> if I have "f :: m a -> m a" and "s :: StateT s m a", how do I apply f to the inner monad of s?
11:19:06 <povik> hi
11:19:32 <povik> exists in haskell some standarized type for image?
11:20:18 <Eduard_Munteanu> povik: like in JPG images? No.
11:20:18 <byorgey> twaffle: probably the easiest way is to first write a function   stateize :: (m a -> m a) -> (m (a,s) -> m (a,s)), then use  mapStateT from Control.Monad.Trans.State (from the transformers package)
11:20:41 <Eduard_Munteanu> povik: there are many libs which deal with images, there's no standard one.
11:21:16 <Eduard_Munteanu> povik: what kind of application are you developing? Perhaps we can recommend one.
11:21:46 <povik> i am not developing anything, just asking because of my interest :)
11:21:53 <byorgey> twaffle: hmm, on second thought, 'stateize' might be impossible to implement
11:22:11 <bblum> hey guys, is there a function in the prelude or somewhere that does "Either a a -> a"?
11:22:15 <Kaidelong> is there a way to make instances at runtime?
11:22:24 <Eduard_Munteanu> povik: ah. AFAIK there is no image support in base Haskell libs.
11:22:26 <byorgey> bblum: either id id
11:22:27 <Kaidelong> doubt it
11:22:45 <bblum> byorgey: ah, ok; thanks
11:22:54 <byorgey> @type either
11:23:03 <twaffle> byorgey: I could also modifiy "f", but it seems like there should be an easy way to do this
11:23:29 <Eduard_Munteanu> Kaidelong: how would that make sense for Haskell?
11:24:11 <Eduard_Munteanu> povik: but I've used the GDK image stuff from Gtk2Hs with good results.
11:24:40 <Kaidelong> Eduard_Munteanu: If there is a way it would it might be helpful, I can't hard-code WHY my buses can be ordered in a set but the way in which they can can be known once the parameters for the fitness function have been specified...
11:24:58 <povik> Eduard_Munteanu: okay, i will try it :)
11:25:09 <byorgey> twaffle: I am not actually sure it is possible, but I am having trouble wrapping my head around it enough to provide an explanation
11:25:27 <Kaidelong> makes me think it'd be helpful if sets used some "with ordering" convention rather than relying on the Ord typeclass
11:25:50 <Eduard_Munteanu> Kaidelong: fitness as in genetic algos?
11:25:51 <byorgey> twaffle: it's a bit odd having a function of type  m a -> m a
11:25:55 <byorgey> twaffle: what does it do?
11:25:58 <Kaidelong> Eduard_Munteanu: yes
11:26:12 <sm> povik: search for image on http://hackage.haskell.org/packages/archive/pkg-list.html to find more
11:26:22 <Eduard_Munteanu> Kaidelong: hm, why use a Set then?
11:26:23 <twaffle> byorgey: it takes a parser and returns a parser that parses the original with parens on either side
11:26:45 <povik> sm: i am already searching with hoogle..
11:26:47 <byorgey> oh, I see
11:26:53 <byorgey> I guess that's quite sensible.
11:26:56 <sm> povik: hoogle doesn't search all of hackage
11:26:58 <Kaidelong> Eduard_Munteanu: It was the easiest way to set up a harmony memory, but now there is the nagging problem with typeclasses being less flexible than functions here...
11:27:02 <sm> (alas)
11:27:10 <byorgey> twaffle: let me think about it a bit more
11:27:16 <povik> sm: ok, i didn't know it
11:27:38 <sm> hayoo does. But often, searching hackage's package list is more direct
11:27:41 <Kaidelong> I suppose I could just make a data-type that includes the fitness function and then map over the set if the parameters change
11:27:59 <Kaidelong> really bad, but I can change it later without breaking the code using the harmonymemory typeclass
11:28:01 <twaffle> byorgey: perhaps I shouldn't be using StateT at all, but that's where I'm at
11:28:33 <freedrull> this parser should parse 0 or more spaces, then 1 or more comments, then if that parse fails without consuming input, one or more newlines... but it actually only succeeds if there is a comment, if there is just a newline, it doesnt work...http://pastebin.com/vM43SKmp
11:29:25 <sm> byorgey: thanks for the reminder about http://packdeps.haskellers.com/
11:29:29 <mauke> what is spaces?
11:29:52 <freedrull> spaces is in a parsec module, its equivalent to skipMany space
11:30:01 <mauke> \n is whitespace
11:30:44 <freedrull> oh :0
11:31:23 <freedrull> well it would certainly fail on "
11:31:30 <freedrull> "  \n" then
11:32:55 <freedrull> thanks
11:55:20 <byorgey> twaffle: oh! I was being dense
11:55:33 <byorgey> twaffle: your  m a -> m a  function is polymorphic in the 'a', yes?
11:55:40 <twaffle> byorgey: yes
11:55:59 <byorgey> so in particular  a could be  (b,s) for some types b and s
11:56:05 <byorgey> so you can just use mapStateT directly
11:56:28 <twaffle> aha
11:57:34 <joe6> freedrull: how are you finding parsec? is it hard to pick up? i am in the same boat as you, trying to use parsec.. what tutorial are you using?
11:57:41 <twaffle> byorgey: thanks
12:02:51 <lally> Hi, anyone having any build problems with data.bytestring?
12:05:45 <wires> is there a (named) standard function to construct a singleton list, like \x -> [x]
12:06:28 <deech> Hi all, I was wondering why lazy evaluation makes location the source of a "error" call hard. Doesn't the thunk that failed have some notion of by whom it was created and called?
12:06:30 <freedrull> joe6: i am finding that i really need to make a separate lexer.... i used this blog entry to get started http://www.serpentine.com/blog/2007/01/31/parsing-a-simple-config-file-in-haskell/
12:06:34 <benmachine> wires: (:[])
12:06:42 <benmachine> wires: alternatively, return/pure should do it
12:06:42 <wires> ah, cool
12:06:43 <byorgey> wires: the robot monkey operator! =)
12:06:50 <dons> deech: nope. you have to implement that. which means modelling a lexical call stack
12:06:51 <wires> Lol
12:06:59 <wires> robot monkey operator hahaha
12:07:08 <byorgey> > (:[]) (:[]) (:[]) 5
12:07:10 <dons> or is it the monkey robot operator?
12:07:11 <wires> lol, that made my day
12:07:13 <dons> there is much debate.
12:07:25 <dons> heya byorgey 
12:07:30 <povik> > 5
12:07:31 <freedrull> joe6: i also used the parsec docs 
12:07:33 <povik> hm
12:07:37 <byorgey> dons: good point.  you should be sure to include a chapter on that in RWH v2
12:07:40 <dons> heh
12:07:41 <byorgey> hi dons
12:07:41 <monochrom> no, laziness does not make locating the source of an "error" call hard. See Control.Exception.assert, exact line number of call site. Somone just has to bring it to "error".
12:07:48 <joe6> freedrull: thanks. that blog seems pretty helpful. hopefully, I will get parsec this time.
12:08:19 <dons> monochrom is right, and that illustrates that the source isn't the problem :)
12:08:27 <wires> lol... still laughing about the robot monkey operator
12:08:32 <dons> we all know that head [] = error "foo" is easy to find. doesn't tell you what called 'head' though
12:10:59 <deech> dons
12:11:59 <deech> sorry, dons, how is it easy to find? If I have a lot of list processing code, I find it hard to figure out which "head" call caused the error.
12:12:01 <byorgey> wires: =)
12:12:33 <dons> deech: right. so the attempts to fix this involve using a simulated lexical call stack. see the breakpoint support in ghci
12:13:31 * byorgey points out that the REAL solution is to never use 'head'
12:13:56 <byorgey> or 'tail', 'init', 'last', 'minimum', 'fromJust', and their ilk
12:14:10 <deech> dons: Ah cool! I had forgotten that GHC had a debugger. I just never think about it. Funny - it's the first thing I would have tried in another language.
12:14:38 <deech> byorgey: So any function uses "error" ?
12:14:47 * applicative suggests redefining it several times -- 'head' 'schmead' 'fred', once for each use
12:14:54 <dons> not necessarily the most practical solution, though.
12:15:26 <deech> And I've always wondered when it was appropriate to use "error" in my own code.
12:18:30 <dblhelix> edwardk: any suggestions on how to name the recursion scheme that arises from the composition of an anamorphism after a paramorphism? ;-)
12:18:45 <byorgey> deech: any function that is partial (i.e. crashes for some inputs)
12:18:57 <byorgey> deech: think of it more as an ideal that you are always striving for.
12:19:09 <byorgey> deech: for example, instead of using head and tail, use pattern-matching
12:19:40 <byorgey> sometimes it is unavoidable.  but if you keep it in mind you will find yourself using such things less and less.
12:19:44 <tg_> anaparamorphism?
12:20:06 <aristid> .oO(first-class pattern matches)
12:21:27 <dblhelix> tg_: I was hoping for something a bit more catchy ;-)
12:21:32 <copumpkin> dblhelix: call it a metamorphism++ ?
12:22:11 <dons> here are my notes on Control.Monad.Inception guys, http://donsbot.wordpress.com/2010/12/05/control-monad-inception/ 
12:22:14 <dblhelix> copumpkin: :)
12:22:20 <dons> take your sunday to implement it, and i'll buy you a beer 
12:22:30 <tg_> dblhelix: animaniac?
12:22:46 <tg_> dons: MATT DAMON
12:23:14 <copumpkin> dblhelix: well, para is like cata++, and ana . cata == meta
12:23:20 <copumpkin> so you'd think that ana . cata++ == meta++
12:23:44 <dblhelix> copumpkin: yeah, I saw how you got there ;-)
12:24:18 <dblhelix> copumpkin: perhaps, I should ask someone who speaks greek? ;-)
12:24:23 <copumpkin> sure :P
12:24:47 <copumpkin> but then some of those morphisms use latin roots
12:24:52 <copumpkin> so it's a huge mess
12:25:31 <merijn> Ok, so my first server attempt is http://hpaste.org/42081/gameloop (feel free to comment on the structure/naming/layout), however I'm still not happy with using 2 threads per socket. This means I have no way to communicate between both threads to synchronize anything and adding an extra Chan to allow both threads communicate just takes me back to my original problem where you can't multiplex Chan's and sockets...
12:27:05 <Cale> merijn: Then why use two?
12:27:34 <merijn> Cale: That was an earlier suggestion from people here because no one knew a way to multiplex sockets and Chan's
12:27:40 <Cale> merijn: The usual thing to do is to forkIO one new handler thread after each accept
12:27:53 <dblhelix> copumpkin: grammar school's been a while for me---which ones use latin prefixes?
12:27:55 <Cale> I'm not sure what that means :)
12:28:06 <povik> why is my cabal still exiting with error that something is missing?
12:28:19 <copumpkin> futu and histo, prepro, postpro 
12:28:21 <copumpkin> are ones I can think of
12:28:46 <Cale> Latin/Greek consistency is overrated
12:28:59 <copumpkin> Cale: you must like television
12:29:08 * geheimdienst can see cale's elitism points burn
12:29:18 <merijn> Cale: The thread reads from a socket and would post to input Chan (where the master thread picks it up and handles it) the master thread then posts updates on world state to another Chan (where the socket threads are supposed to pick it up and write to the socket) but I don't know how do "wait for input on socket or Chan"
12:29:19 <byorgey> dons: hahaha, awesome =)
12:29:30 <povik> hm, cabal is like emerge (compiling, compiling, compiling....)
12:29:36 <Cale> Nobody cares. They're really English words, and the prefixes are English ones now.
12:29:41 * hackagebot DBlimited 0.1 - A command-line SQL interface for flat files (tdf,csv,etc.)  http://hackage.haskell.org/package/DBlimited-0.1 (JohnMayer)
12:29:46 <copumpkin> Cale: clearly some people do :)
12:30:05 <dons> byorgey: a good implementation would be publishable, I think :) still yet to determine if it is useful though
12:30:07 <merijn> copumpkin: No one important cares ;)
12:30:12 <copumpkin> ah, fair enough
12:30:20 <copumpkin> no true scotsman cares, amirite?
12:30:25 <Cale> All shall be assimilated into the English linguistic hegemony.
12:30:40 <merijn> I for one welcome our new English speaking overlords
12:31:38 <Cale> merijn: Oh, you do that using threads.
12:31:50 <merijn> Cale: How?
12:31:51 <Cale> merijn: (Waiting on multiple events)
12:32:08 <merijn> One thread for the chan and one for the socket you mean?
12:32:19 <merijn> That's rather...pointless
12:32:26 <mauke> merijn: why?
12:32:26 <Cale> Um, well, I wish it were in the libraries, but it's easy to write a function which forks a bunch of actions of the same type and races them.
12:32:52 <Cale> (Just have them race to write to an MVar)
12:33:06 <mauke> Cale: I think it's nearly impossible to do in a sane way
12:33:11 <dons> it would be cool to have a 'monad' credit card:  http://www.monadfcu.com/ 
12:33:25 <merijn> The only sane way would be to rewrite the RTS to support it, I think
12:33:40 <Cale> merijn: what?
12:33:41 <mauke> merijn: huh?
12:33:43 <Cale> merijn: I just mean short-lived threads
12:34:04 <Cale> merijn: Concurrency is how you express selection between multiple events.
12:34:39 <Cale> merijn: It's the RTS's job to manage the appropriate select/kqueue/epoll nonsense to do it :)
12:35:49 <merijn> mauke: To accomodate multiple clients interacting with a persistent world I need to separate the client handling code from the "world" so I figured one thread per client and one Chan which the world listens too and all client handlers post events too. Now of course the clients also need to get information back so the world writes out any "output" events to another channel (duplicated to each client thread). But the end result is client threads
12:35:49 <merijn> needing to know when there's either new input from the socket or new output from the world.
12:36:16 <mauke> merijn: no
12:36:21 <merijn> mauke: Separating the channel and the socket into separate threads kinda defeats the purpose of using a Chan to handle the communication, no?
12:36:23 <mauke> all input comes from a single channel
12:36:43 <mauke> spawn another thread to throw socket data into the channel
12:36:44 <Cale> merijn: Force both of those input types to be the same type, and pass it all down one channel.
12:37:21 <joe6> which is better: cs <- many (noneOf "\r\n") or cs <- (manyTill anyChar newline)
12:38:54 <joe6> s/or/OR/
12:39:30 <merijn> Cale: You mean a thread that listens to the socket and writes everything to a Chan and have the world write everything to the same Chan and have one thread listening to that?
12:45:04 <Cin> joe6: The latter is probably clearer if it behaves the same.
12:47:47 * hackagebot attoparsec-enumerator 0.2.0.3 - Convert an Attoparsec parser into an iteratee  http://hackage.haskell.org/package/attoparsec-enumerator-0.2.0.3 (JohnMillikin)
12:47:58 <Cin> joe6: I think their behaviour may be different, however.
12:49:02 <Cin> joe6: parse (many $ noneOf "\r\n") "" "" => Right "", parse (manyTill anyChar newline) "" "" => error, expecting-newline
12:50:17 <Cin> joe6: Meaning that the equivalent is more like do cs <- many (noneOf "\r\n") <* newline.
12:50:36 <Cale> merijn: Yeah, that'd work :)
12:50:43 <Cin> joe6: That said, manyTill is shorter. :-)
12:51:41 <merijn> Cale: I think that'd add some difficult bookkeeping about which messages are going into which direction, though, wouldn't it?
12:51:48 <joe6> Cin: thanks a lot. that was very helpful.
12:59:14 <Cale> merijn: err, aren't those all input, essentially? I thought the problem was about waiting on two types of input
13:00:49 <merijn> Cale: Yes, but they're not in the same direction. Stuff from the gameworld needs to (after processing) go out over the socket and stuff coming in from the socket needs to end up (after processing) in the chan the gameworld is reading from
13:01:13 <edon> any way to make this expression consume less memory http://hpaste.org/42092/e ?
13:03:51 <Cale> edon: um, it shouldn't really be the culprit
13:04:02 <joe6> in parsec: how can I convert "many digit" to a number?
13:04:15 <joe6> Int, I meant
13:04:39 <joe6> google talks about Number . Read , but I could not find Number anywhere.
13:04:56 <joe6> fmap (Number . Read) $ many digit
13:05:51 <mauke> fmap read $ many1 digit
13:06:21 <pumpkin> joe6: presumably that's how whatever code you're reading represents numbers in their AST
13:06:29 <joe6> yes
13:06:34 <pumpkin> ...
13:06:35 <aristid> mauke: read <$> many1 digit
13:06:39 <pumpkin> so that's why Number isn't anywhere
13:06:46 <pumpkin> because it's specific to their AST structure :P
13:06:53 <sm> multiple packages now give me ExitFailure 11 during cabal configure, on two separate cabal installations (one linux, one mac). Anyone else seeing these or know why this has started recently ?
13:06:55 * Kaidelong gotten his buses working as pitches after getting their routes and scheduling priorities working as pitches...
13:06:58 <joe6> oh, ok.
13:07:13 <edon> Cale: i've put a SCC tag there, seems like it's using 75% of the memory. I'm trying to fix a leak in http://hpaste.org/42089/du
13:07:39 <Cale> edon: Can I see the profile?
13:08:18 <sinisa> Even though hackage successfully built persistent==0.3.0.1 and later versions, I get an error for ambiguous occurrence of `mapM` and others, where the Prelude definitions clash with those from Data.Enumerator. Am using GHC-6.12. What am I doing wrong?
13:08:23 <Cale> edon: It might be doing lots of allocation there, because it's allocating strings for the contents of the file, and doing concatenation.
13:08:51 <Cale> edon: But most of that will be immediate garbage once it's written back out.
13:09:11 <aavogt> sinisa: does the error message qualify the module with a package version?
13:10:16 <Cale> edon: Actually, no it isn't :P
13:10:19 <sinisa> I don't think so. Just simply Prelude.mapM clashes with Data.Enumerator.mapM. No package versions mentioned.
13:10:24 <edon> Cale: http://hpaste.org/42094/a
13:10:26 <Cale> edon: You're just looking at the size of the file :)
13:10:33 <sinisa> I should upgrade enumerator, you think?
13:11:02 <Cale> edon: Okay, %alloc doesn't actually tell you anything about how much memory at any one point in time that thing was responsible for
13:11:11 <edon> Cale: yeah it just lists the files recursively and their size
13:11:33 <Cale> (it just tells you how much it was responsible for allocating memory, but maybe a lot of that was GC'ed immediately)
13:11:43 <joe6> i cannot get this to work: parseTest (read <$> many1 digit) "3"
13:12:18 <joe6> any thoughts, please?
13:12:23 <aavogt> sinisa: you can try    cabal install persistent --constraint="foo == 1.2.3"   to force it to use the same versions of dependencies that worked on hackage
13:12:58 <pumpkin> joe6: I'll try to use my psychic powers to read your error message, but I can't guarantee anything
13:13:25 * pumpkin makes grunting noises
13:13:27 * pumpkin fails
13:13:38 <joe6> pumpkin: funny..
13:13:46 <aavogt> perhaps you need a type signature
13:13:50 <lally> joe6: I just made public a little project of mine on github called 'libmet' (old name, will change soon).
13:13:55 <lally> it's got a parsec parser in there.
13:14:03 <aavogt> otherwise you can see how   "()"   gets properly read
13:14:28 <lally> for a reasonable mini language (for something similar to 'struct' declarations in C)
13:14:45 <aavogt> preflex seen lambdabot cale
13:14:45 <preflex>  lambdabot was last seen on #haskell 4 hours, 18 minutes and 47 seconds ago, saying: http://hackage.haskell.org/package/cereal
13:14:47 <lally> https://github.com/lally/libmet/blob/master/StaticInstrumentation.hs
13:14:57 <joe6> lally: ok, will check it out.
13:14:59 <lally> should hopefully let you see the latest version.
13:15:00 <freedrull> lally: does it have a lexer
13:15:38 <lally> yup, and it's at https://github.com/lally/libmet/blob/master/SIParser.hs
13:15:43 <lally> (not the other one, which is a prereq)
13:15:55 <freedrull> nice
13:15:55 <ddarius> pumpkin: You just need to practice more.
13:16:20 <aavogt> joe6: did you get a *** Exception: Prelude.read: no parse
13:16:28 <joe6> aavogt: yes.
13:16:36 <aavogt> then see what I wrote earlier
13:16:36 <mauke> better not tell us, though!
13:17:33 <ddarius> pumpkin: Here you go: http://www.remoteviewed.com/files/CRV%20manual%20full.pdf
13:17:35 <lally> freedrull: yeah, in the sense that it uses parsec's 'makeTokenParser' function to generate one as we want it.
13:17:49 <Cale> edon: er, I'm not sure I see a memory leak here...
13:17:50 <lally> the lexer is a set of grammar rules that eat up whitespace, comments, etc.
13:18:00 <pumpkin> ddarius: sweet, thanks!
13:18:06 <Cale> edon: How big of a file tree do I need to test this on?
13:18:27 <revenantphx> Enggh.
13:18:30 <revenantphx> What's wrong with this?
13:18:31 <revenantphx> (entities, selfeid) <- atomically $ liftM (,) (readTVar (selfEID ast)) (readTVar (entityMap ast))
13:18:49 <freedrull> lally: so you can just use the whitespace function to handle comments, whitespace, and newlines
13:18:50 <aavogt> you want  bind2 or something like that
13:19:00 <aavogt> actually no
13:19:02 <benmachine> revenantphx: liftM2?
13:19:04 <mauke> what is it with people and not telling us their symptoms?
13:19:07 <revenantphx> ah, right >_<
13:19:10 <unkanon> you're misspelling seinfeld :)
13:19:12 <pumpkin> ddarius: their webpage talks about "the known six senses", which already sets off a bit of a red flag though. I have a slight hunch that the document may not be 100% reliable
13:19:21 <sshc> How do I tell ghci which modules to load on the command line?
13:19:44 <unkanon> sshc: you want some modules pre-loaded when you load ghci?
13:19:52 <sshc> unkanon: Yes
13:19:53 <Cale> edon: I'll do a memory profile :)
13:19:54 <lally> freedrull: for the initial whitespace in the file.  the lexing functions that makeTokenParser creates will automatically gobble that up for you too
13:19:55 <unkanon> you can put the :m My.Module command on your ~/.ghci
13:20:01 <ddarius> pumpkin: If it's what I think it is (I didn't look at this particular link), it's from the government.  Of course you trust the government!
13:20:10 <lally> (for the whitespace after the match)
13:20:11 <pumpkin> oh okay, that's reassuring
13:20:13 <pumpkin> thanks
13:20:13 <edon> Cale: actually after hp2ps seems like throughFiles is the culprit
13:20:26 <sshc> unkanon: How would I load those modules on the command?
13:20:28 <sshc> line?
13:20:36 <Luke1> anyone else having a problem installing scion because of it's <6.12 dependency?
13:20:38 <unkanon> sshc: the same way (I suppose you mean ghci
13:20:38 <aavogt> sshc: you could check out writing a .ghci
13:20:40 <unkanon> s commandline)
13:21:03 <sshc> When I invoke ghci in the shell
13:21:05 <Cale> edon: Ah, yes, I'm seeing that.
13:21:11 <edon> Cale: i run it on / and it reaches 1G of memory before I C-c it
13:21:35 <unkanon> sshc: I'm not sure I get it, then. if you put the :m commands in .ghci then when you load ghci your modules will be loaded for you
13:21:37 <aavogt> but that's not exactly addressing the question (but maybe the actual problem nonetheless)
13:21:38 <ddarius> pumpkin: There's another one that's much more readable and has much less ridiculous jargon at the cost of being even less "reliable."
13:22:18 <ddarius> pumpkin: That said, it's an interesting thing to try.  It doesn't cost you anything other than an hour or two of your life.
13:22:27 <Luke> http://hackage.haskell.org/packages/archive/scion/0.1.0.2/logs/failure/ghc-6.12 anyone know how to fix this?
13:22:45 <Luke> do I need special access to hackage or something?
13:22:48 <sshc> unkanon: What can I pass to ghci to load a module on init?
13:23:02 <monochrom> ghci load_me.hs
13:23:03 <unkanon> sshc: oh! like a switch?
13:23:16 <monochrom> unless "on init" means something else
13:23:19 <hpc> Luke: you can download the tarball and try and fix it yourself
13:23:27 <unkanon> I've never done that, I use either ~/.ghci or :m
13:23:31 <Cale> Luke: Maybe it's trying to build with ghc 7 now?
13:23:33 <hpc> then contact the maintainer with the fixed version
13:23:39 <sshc> monochrom: <no location info>: module `Data.Char' is a package module
13:23:53 <aavogt> Luke: cabal unpack; fix the .cabal file in that dir, which probably means fixing whatever incompatibilities happened in the ghc-api
13:23:59 <sshc> % ghci Data.Char
13:24:01 <monochrom> yeah, package modules are not to be loaded.
13:24:10 <Luke> aavogt: thanks
13:24:18 <Luke> Cale: hpc: thanks
13:24:33 <Cale> Luke: The requirements of that package are insisting that the GHC-API be < 6.12, so it won't work on anything recent.
13:24:40 <sshc> monochrom: Yes they are; I can type :m + Data.Char
13:24:46 <aavogt> you can use   -e ":m Foo"   but that only works with ghc, not ghci
13:25:13 <aavogt> maybe ghci should be changed to accept -e flags
13:25:54 <Luke> looks like the github version of scion is much newer =/
13:26:17 <monochrom> perhaps you consider this hair-splitting, but :m is not loading. this is ghc user guide wording, not mine.
13:26:38 <revenantphx> One question...
13:26:47 <revenantphx> which one is "expected type" and which one is "inferred type"?
13:26:54 <revenantphx> (which it thinks you should have)
13:26:55 <monochrom> I suggest writing your own module that says "import Data.Char" and load that on init.
13:27:41 <unkanon> that'll probably defeat the purpose for him, it looks like he finds himself opening and closing ghci many times loading different modules each time
13:27:50 <unkanon> otherwise he could just use ~/.ghci
13:28:01 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope  compulsory reading for every ghc user.
13:28:13 <Cale> edon: Even though it'll change the traversal order, try changing (ds ++ ds') to (ds' ++ ds)
13:28:18 * sm bookmarks
13:28:24 <merijn> Hmm, so can I read at least read from 2 Chan's or is that also impossible?
13:29:14 <sm> revenantphx: inferred is what ghc inferred the type to be based on the expression's components. Expected is what the expression's "consumer" is expecting it to be
13:29:26 <Cale> edon: That should be typically a lot more efficient.
13:29:35 <sm> s/consumer/parent expression/ I guess
13:29:50 <Cale> edon: If you need to keep the same sequential order, use Data.Sequence
13:29:54 <revenantphx> https://gist.github.com/729488
13:29:58 <revenantphx> I'm not seeing what's causing this.
13:30:09 <revenantphx> I had `when isJust self $` before
13:30:18 <revenantphx> but according to IntMap, lookup doesn't use Maybe
13:30:21 <monochrom> if you can't tell apart "expected" and "inferred", don't worry about it, just know that there are two conflicting type requirements.
13:30:22 <revenantphx> (which is a bit odd I suppose)
13:31:01 <edon> Cale: yeah that makes it quite a lot more memory efficient, i don't understand why though
13:31:06 <sm> I think it's good to be clear about them to have a better chance of reading ghc errors
13:31:07 <pumpkin> lookup :: Key -> IntMap a -> Maybe a
13:31:21 <monochrom> IntMap.lookup (mkKey selfeid) entities :: Maybe Entity
13:31:25 <revenantphx> I usee, lookup :: Monad m => Key -> IntMap a -> m a
13:31:27 <sm> revenantphx: IntMap.lookup is not in the IO monad
13:31:28 <Cale> edon: Because ds is the big one, and xs ++ ys uses O(length xs) memory and time
13:31:29 <monochrom> the monad is IO
13:31:34 <pumpkin> revenantphx: do you have an ancient version of GHC?
13:31:42 <revenantphx> No, 6.12.3 or w/e
13:31:45 <revenantphx> newest one that isn't 7
13:31:52 <aavogt> then the type won't have Monad in it
13:31:52 <edon> Cale: ah i see, yeah. thanks
13:31:55 <pumpkin> then you probably don't use the version with that signautre
13:31:57 <revenantphx> Oh, I'm looking at ancient docs.
13:31:59 <revenantphx> TT_TT
13:32:02 <monochrom> haha
13:32:03 <pumpkin> :)
13:32:25 <Cale> edon: I'm glad that I'm right, since I didn't actually try it before I said that ;)
13:32:35 <revenantphx> lookup :: Key -> IntMap a -> Maybe a
13:32:38 <revenantphx> okay, there we go.
13:32:53 <adnap_> Is there a preferred way to thread debugging state through your program in Haskell?
13:32:53 <revenantphx> wait... what.
13:32:57 <revenantphx> That's what I'm giving it.
13:33:01 <revenantphx> self <- IntMap.lookup (mkKey selfeid) entities
13:33:07 <revenantphx> oh, I see...
13:33:44 <revenantphx> Ok, I'm running into a bit of an issue then. I want to bind the Maybe result of that, and then ifJust is true, do stuff.
13:33:53 <revenantphx> I don't want to have to add fromMaybe in there and then check a default value.
13:35:40 <monochrom> you have to case it
13:36:07 <monochrom> your do-block is IO so you can't just say "x <- Just fine"
13:36:15 <aavogt> or the do block produces a value like    Maybe a
13:36:17 <joe6> this works: "fmap (read::String->Int) (return "12")" but I cannot get this to work"  :t parseTest (fmap (read::String->Int) many1 digit) "12""
13:36:22 <joe6> can someone please help?
13:36:42 <monochrom> let y = IntMap.lookup etc; case y of Nothing ... Just ...
13:36:47 <revenantphx> yeah
13:36:54 <revenantphx> thats similar to what I did for my command lookup.
13:36:56 <aavogt> joe6: "12"" doesn't look right
13:36:58 <revenantphx> case fromMaybe (Anyone, commandInvalid) (Map.lookup command commandMap) of
13:37:04 <monochrom> actually, case IntMap.lookup etc of Nothing ... Just ...
13:37:04 <unkanon> joe6: I don't know enough to help you but have you looked at the "write a scheme in 48 hours" tutorial?
13:37:06 <revenantphx> I found that line rather concise.
13:37:20 <aavogt> joe6: also you've lost the parens around   many1 digit
13:37:21 <revenantphx> If it can't find it, it cases using the commandInvalid command.
13:37:26 <revenantphx> (which simply says "Invalid command")
13:37:40 <joe6> aavogt: will try with parens
13:37:47 <aavogt> or use <$> instead of fmap
13:38:07 <joe6> cool, it works. parseTest (fmap (read::String->Int) (many1 digit)) "12"
13:38:39 <revenantphx> @src case
13:39:32 <aavogt> case is built in
13:39:43 <aristid> joe6: you can also use fmap as an operator if you don't want to use <$>: `fmap`
13:41:01 <joe6> i cannot get :t <$>
13:41:17 <joe6> to work, but can get :t fmap to work, hence I used fmap.
13:41:19 <monochrom> :m + Control.Applicative
13:41:20 <aavogt> joe6: :t  expects an expression
13:41:25 <joe6> yes, I did that.
13:41:36 <monochrom> :t (<$>)
13:42:01 <joe6> monochrom: thanks. that helped
13:42:09 <monochrom> you may also compare :t + with :t (+)  same story
13:42:34 <monochrom> otoh :info + <$> is just fine
13:43:30 <Twey> joe6: parseTest (read <$> many1 digit :: Parser Int) "12" … or something
13:51:02 <lally> Is it possible to attach shared memory in a running haskell process safely?
13:51:07 <lally> E.g. shmat()?
13:51:53 <monochrom> I don't really know. I guess it can be done.
13:52:26 <dons> lally: you can use the unix shared memory primitives to map in patges
13:52:27 <dons> pages.
13:52:37 <dons> there's a bytestring-mmap library to take as a starter, for example
13:52:55 <dons> the "foreign memory" isn't part of the GHC managed heap, so you manage it with Foreign.* support
13:53:13 <lally> ohhh, yes!  Thanks man.
13:53:46 <joe6> Twey: that worked too. thanks.
13:56:09 * monochrom wonders what's the official capitalization of "gtk2hs"
13:56:15 <dcoutts_> Gtk2Hs
13:56:53 <monochrom> yeah. thanks. :)
14:03:25 <Cale> http://www.vimeo.com/16311288 :D
14:04:30 <monochrom> http://upnotnorth.net/2010/10/29/a-new-way-to-interact-with-fiction/ may be more efficient
14:04:57 <ketil> Anybody using hircules?
14:05:08 <ddarius> @bot
14:05:13 <monochrom> or http://upnotnorth.net/projects/typewriter/
14:05:34 * ketil_ am now.
14:07:40 <tonkman> any opengl wizards present?
14:08:04 <aristid> @bot
14:08:08 <aristid> oh
14:08:18 <aristid> monochrom: somehow i thought you were lambdabot. happens.
14:08:27 <monochrom> :)
14:08:34 <monochrom> pardon my delay
14:09:13 <tonkman> im just wondering, is it possible to get a string from pressed keys via keyboardMouseCallback
14:09:22 <aristid> the only problem is that your type-checking is unreliable, monochrom
14:09:39 * ddarius is currently using 4002 threads, but I think I need to approximately triple or quadruple that.
14:10:03 <tonkman> I can see that it is typed SettableStateVar, but im not very experienced with monads
14:15:11 * hackagebot language-dot 0.0.6 - A library for the analysis and creation of Graphviz DOT files  http://hackage.haskell.org/package/language-dot-0.0.6 (BrianLewis)
14:15:59 <Alan> Colud somebody maybe help me with Parsec?  I'm getting an "Inferred type is not general enough" from this code: http://hpaste.org/42096/
14:16:24 <Alan> it's complaining at the TokenParser{...} = ... part...
14:18:17 <monochrom> before I actually try, perhaps add {-# LANGUAGE RankNTypes #-} to the top of the source code?
14:18:58 <Alan> that didn't do anything.
14:19:08 <Alan> what was that supposed to do?
14:22:08 <benmachine> Alan: can you add the whole error to the hpaste?
14:22:16 <Alan> benmachine: sure
14:22:52 <sdj> Alan: http://www.haskell.org/haskellwiki/Rank-N_types
14:23:33 <Cale> btw, Text.ParserCombinators.Parsec is the deprecated module path
14:23:36 <Alan> benmachine: just updated
14:23:41 <Cale> It's just Text.Parsec now.
14:23:57 <Alan> Cale: awesome... is there actually any up-to-date documentation on parsec anywhere?
14:24:03 <Cale> http://hackage.haskell.org/package/parsec
14:24:12 <Alan> at the moment this is like groping around in the dark :|
14:24:28 <Cale> (click the module name links)
14:25:12 <Alan> ok, so up-to-date API documentation, but no up-to-date "this is how you use this monster" stuff :(
14:25:22 <Alan> at least that should be SOME help though
14:29:13 <Alan> Cale: also, that import doesn't work on my system - how recent is that change?
14:29:48 <benmachine> Alan: parsec >= 3
14:31:01 <edwardk> ddarius: i think we may have messed up the dual ob
14:31:36 <edwardk> ddarius: not that that affects the correctness of the hom machinery
14:37:35 <pumpkin> whois Apocalisp
14:37:39 <horace89> Please may someone explain to me why this error happens at the GHCi repl, instead of printing [3,2] => http://codepad.org/sFF0StmK , thanks.
14:37:43 <pumpkin> gah, he's not here
14:37:56 <alpounet> troubles with \bot ?
14:37:57 <ddarius> edwardk: I didn't think we did anything to dual.
14:38:02 <alpounet> not here again
14:38:11 <ddarius> Or do you mean made it so it wouldn't be able to work?
14:38:21 <Twey> horace89: It can't type [[1, 2, 3], ["a", "b"]]
14:38:26 <mauke> horace89: because what's the type of [[1,2,3], ["a","b"]]?
14:38:33 <ndrsndrs> horace89: what type is [[1,2,3], ["a", "b"]]?
14:38:36 <edwardk> ddarius: the latter
14:39:02 <Twey> horace89: [1, 2, 3] and ["a", "b"] are of different types (Num a => [a] and [String], respectively) so the type of the outer list is unknown
14:39:13 <ddarius> edwardk: The compiler will no longer put up with your lies?
14:39:48 <shachaf> [[1,2,3],["a","b"]] :: [[exists a. a]]
14:40:00 * ddarius should probably make it so that his simulator doesn't sporadically segfault when it closes, but fixing it doesn't seem worthwhile.
14:40:20 <Alan> benmachine: looks like the version ubuntu ships is from 2006 :|
14:40:21 <mauke> *> [[1,2,3],["a","b"]]
14:40:21 <mauke> [["\SOH","\STX","\ETX"],["a","b"]]
14:40:38 <ddarius> shachaf: We have exists a. a in Haskell.  It's called ().  The injection is const ().
14:40:41 <edwardk> ddarius: basically ;)
14:41:10 <benmachine> Alan: a lot of people stuck to parsec 2 because for a while it was faster
14:41:12 <pumpkin> ddarius: yay, existentials!
14:41:17 <benmachine> Alan: it isn't anymore but no-one's noticed yet :P
14:41:20 <ddarius> edwardk: Might it be possible to do dual The Right Way now, though?
14:41:27 <horace89> Twey: Thanks for your response. I'm muddled then as to how I should approach the problem of writing a function that takes a list of lists and returns a list of their lengths
14:41:38 <mauke> horace89: like that
14:41:42 <edwardk> ddarius: possibly, i may have to unfactor hom through ob
14:41:48 <mauke> horace89: your problem is that you don't have a list of lists
14:44:04 <horace89> Wow, I've no idea what I'm doing here :D
14:44:26 <horace89> Like what mauke?
14:44:33 <mauke> map length
14:44:39 <Alan> benmachine: fair enough
14:44:54 <Alan> benmachine: i guess i'll have to go outside of my distro's package manager then
14:45:07 <horace89> Right, what I tried earlier, which gave an error, so could you patiently explain what I did wrong? I didn't understand the [[exists a. a]] comment
14:45:25 <Twey> horace89: It gave an error because the list you passed it is not a valid list
14:45:37 <Twey> The function is not at fault
14:46:15 <Alan> so cabal won't install it either? wtf. :|
14:46:26 <benmachine> Alan: yeah, because of the thing I mentioned
14:46:34 <benmachine> Alan: try cabal install 'parsec >= 3'
14:46:55 <horace89> <mauke> *> [[1,2,3],["a","b"]]
14:47:00 <horace89> ^ The same list as mine, no?
14:47:03 <Alan> ah, that's better
14:47:07 <mauke> horace89: yes, but I cheated
14:47:18 <mauke> horace89: (by making Strings numbers)
14:47:28 <alpounet> who's hosting lambdabot nowadays ?
14:47:48 <applicative> Alan, It's not like the old parsec is unusable.  The error you pasted isnt from the module you pasted though
14:47:51 <Twey> @where host
14:48:04 <Alan> applicative: oh?
14:48:04 <benmachine> @what's going on
14:48:10 <Twey> @help us
14:48:42 <applicative> Alan, the old parsec is fine; the new one does ByteStrings etc. so it's sexier
14:48:56 <Alan> applicative: if you mean "because of the line number", then no, I omitted the "module" line and some comments
14:49:09 <horace89> So, it's not possible to map length over a list of lists of different element types?
14:49:31 <ddarius> horace89: It's not possible to have a list of different element types.
14:49:42 <Alan> applicative: line 31 is the final line
14:50:41 <horace89> ddarius: You misunderstand me, in Scheme, this works fine: (map length '((1,2,3),("a","b"))) => '(3,2) -- how to do it in Haskell?
14:50:55 <applicative> Alan, ok i see.  I haven't used the Language module.  But I can't follow line 15, what are you defining?
14:51:17 <wires> is there a standard (indexed set of) method(s) that turns it's arguments into a tuple, like \x -> \y -> (x,y)
14:51:19 <ddarius> horace89: You misunderstand me.  You can't map length over a list of different element types because you can't have a list of different element types to begin with.
14:51:30 <aavogt> wires: (,)
14:51:36 <ddarius> A list of lists of different element types is still a list with different element types.
14:51:39 <wires> aavogt: awesome thanks
14:51:45 <horace89> ddarius: Oh, sorry, I see what you mean now.
14:52:27 <applicative> Alan, like this would make sense, it compiles:  http://hpaste.org/42098/more_parsec
14:52:29 <Alan> applicative: well according to  http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements i'm using a silly syntax to bind the various parsers, i think
14:53:24 <Alan> applicative: maybe the writer of that wiki article was on crack then :| if i make a token parser like that and do "m_parser = parser myTP" etc then it works
14:53:35 <sshc> If I have a TypeFamily in a class, is it possible to restrict that type to the Num class?
14:56:24 <applicative> Alan, I'm studying the wiki page, it is strange to me, that bit. 
14:56:50 <Alan> applicative: does that syntax even exist? or is it a case of "it exists but we wish it didn't"?
14:57:02 <Alan> not seen it used anywhere else (yet, i'm pretty new to Haskell)
14:57:08 <aavogt> sshc: class Num (T a) => C a where type T a ?
14:58:26 <sshc> aavogt: I have "class Foo a where type AssociatedTypeThatMustBeOfNumClass a"
14:58:47 <wires> say i have a function f which has many arguments. I want to modify the n-th argument of f using a function g which takes a single argument; like (\x -> \y -> \z) -> (x, g y, z)  -- there must be a compact way to do this?
14:58:49 <sshc> I want "(AssociatedTypeThatMustBeOfNumClass a)" to only be an instance of the Num class
14:59:11 <aavogt> sshc: did you try that?
14:59:17 <pumpkin> sshc: nope
14:59:24 <sshc> pumpkin: No what?
14:59:31 <sshc> aavogt: Did I try what?
14:59:35 <pumpkin> sshc: you can't do that
14:59:44 <pumpkin> except by making the superclass
14:59:55 <sshc> pumpkin: Elaborate?
14:59:59 <pumpkin> what aavogt wrote :P
15:00:13 <pumpkin> [05:56:41 PM] <aavogt> sshc: class Num (T a) => C a where type T a ?
15:02:26 <sshc> Oh, somehow I misunderstood that
15:03:21 <sshc> It works!! (with FlexibleContexts)
15:03:25 <sshc> Thanks, aavogt
15:04:40 <applicative> Alan, here's a typical use http://www.google.com/codesearch/p?hl=en#Jgqw3H3S1nM/agbkb/forschung/formal_methods/CoFI/hets/hets-daily-src.tgz%7CwhhDNDNCfAs/Hets/Maude/Language.hs&q=emptyDef%20lang:haskell
15:06:22 <Alan> applicative: ok, that doesn't use the "strange" bit
15:06:40 <Alan> that syntax that is causing me problems, is that a "record pattern match" of sorts?
15:08:59 <applicative> http://hpaste.org/42099/maude just chops off a bit, but it compiles.  It actually seems pretty subtle the usage of the module.  
15:10:19 <applicative> Alan, curses, I have to go.  But if you follow the model of maudeTokenParser and maudeLanguageDef with alanTokenParser  ... it should be clear
15:10:28 <Alan> applicative: ok, thanks :)
15:11:04 <applicative> Alan, the idea is to import the Parsec stuff qualified.  Then you get to export the simple terms. not remark on line 108
15:11:15 <applicative> note the remark.
15:11:48 <monochrom> My medium Gtk2Hs example: http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
15:16:28 <wires> Wait, let me rephrase. How can one have a function operate on the n-th element of a tuple and return the other elements untouched?
15:18:16 <Enigmagic> tup3 (t1, t2, t3) f = (t1, f t2, t3)
15:18:17 <Enigmagic> ?
15:18:23 <wires> or something like "vertical" function composition operator, say it's called ",," then (id ,, f ,, id ,, id) would give function that works on 4-tuples
15:19:05 <sm> monochrom: nice
15:19:05 <wires> Enigmagic, yes like that but I'm looking for a generic one, e.g.   tup f n  ...
15:19:17 <monochrom> hehe thanks
15:19:37 <wires> or tup3, etc.. (i understand that tuple length polymorphism is not possible/easy)
15:20:21 <sdj> wires: sounds like you need some sort of generic programming
15:20:22 <sm> monochrom: shouldn't you have a feed for these ? then the planet would pick them up
15:20:29 <Enigmagic> you could probably generate such a function with TH
15:20:45 <wires> sdj: yes, where do I look?
15:20:54 <wires> s/do/should/
15:21:27 <sdj> Honestly, I don't really know. Maybe template haskell
15:21:55 <wires> sdj: ah what Enigmagic suggested ... okay
15:22:14 <sdj> right
15:22:25 <wires> k, thanks guys
15:22:42 <wires> (or girls.. ;) )
15:22:53 <aavogt> wires: or otherwise generated code like http://hackage.haskell.org/package/tuple
15:24:40 <ddarius> Unsurprisingly, compiling with optimizations makes no difference to the responsiveness of this program.
15:25:39 <wires> aavogt: hehe ok cool.. thanks
15:30:56 <wires> Hmm I'm more or less looking for things along this line:
15:30:56 <wires> (,,) :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))
15:30:56 <wires> (,,) f g = \(a, b) -> (f a, f b)
15:31:29 <wires> such that i could do (id ,, f) to get a function that works only on the second argument of the tuple
15:31:36 <aavogt> check Control.Arrow.&&&
15:31:49 <aavogt> err ***
15:31:50 <hpc> and more relevantly, ***
15:32:01 * wires checking
15:32:13 <aavogt> but that's only for 2-tuples
15:33:01 <hpc> (if tuples were a native haskell construct, there wouldn't need to be a distinction :/)
15:38:56 <aavogt> hpc: what do you mean by native?
15:39:36 <hpc> data (,) a b = (,) a b
15:39:54 <hpc> triple x y z = x, y, z
15:40:12 <hpc> x, y, z = x, (y, z)
15:40:44 <hpc> actually, it wouldn't have to be native; just written less shittily, like the function type
15:40:45 <aavogt> there's a difference bottom-wise between flat and nested tuples
15:41:11 <hpc> the distinction isn't very important, i think
15:41:24 <hpc> as in, there's no practical need for both meanings
15:42:04 <aavogt> you can't easily recurse through nested tuples
15:42:21 <hpc> you can't easily map over a flat tuple
15:42:26 <wires> aavogt, hpc : thanks for the arrows link, that looks appropriate (for now)
15:43:05 <wires> also, i think to do tuples properly you might need dependent types (like in agda), but i'm not completely sure on that
15:43:28 <aavogt> you probably just need more sugar
15:43:51 <aavogt> wires: it's not as if real code arbitrarily selects elements from tuples based on values determined at runtime
15:44:31 <Veinor> yeah
15:44:38 <Veinor> and it's not like you ever need more than a 3-tuple or 4-tuple
15:45:03 <aavogt> yeah, a one-tuple ought to be enough for anybody
15:45:04 <wires> hmm, \true
15:45:08 <wires> -\
15:45:13 <hpc> even still, requiring parenthesis around tuples is annoying as hell
15:45:32 <Cale> hpc: Why?
15:45:36 <aavogt> hpc: how do you write lists then?
15:45:50 <hpc> aavogt: x:y:z:[] :P
15:46:09 <aavogt> import lists :p
15:46:18 <Veinor> hpc: how do you parse a+b,c+d?
15:46:41 <hpc> Veinor: you are conflating "require" with "blindly omit"
15:46:44 <Cale> hpc: Tuples larger than pairs are very uncommon, and you almost never see anything larger than a triple.
15:46:48 <hpc> :t curry
15:47:09 <hpc> curry :: ((a, b) -> c) -> a -> b -> c
15:47:12 <Cale> hpc: The reason for this is that if you have a bunch of related data of different types, you probably should define a proper named datatype for it.
15:47:18 <hpc> curry :: (a, b -> c) -> a -> b -> c
15:47:35 <hpc> fair
15:47:56 <pumpkin> hpc: is that (a, (b -> c)) or ((a, b) -> c) ?
15:48:26 <hpc> i still think that's settling for inconsistency
15:48:46 <aavogt> both curry types are legal right now
15:49:06 <pumpkin> except one of them can't be written
15:49:15 <pumpkin> oh I guess it can be
15:49:16 <Cale> Yeah, I'd totally read (a, b -> c) as being (a, (b -> c))
15:49:30 <aavogt> @djinn (a, b -> c) -> a -> b -> c
15:49:39 <pumpkin> it's pretty trivial, ignore me :P
15:49:39 <hpc> no lambdabot
15:49:44 <Cale> oh
15:49:50 <aavogt>  \(_, f) _ b -> f b
15:49:53 <monochrom> following PVS, I read (a,b -> c) as ((a,b) -> c)
15:50:01 <pumpkin> aavogt: or just eta reduce vurther
15:50:08 <pumpkin> further, even
15:50:43 <aavogt> monochrom: what is a PVS?
15:50:57 <hpc> http://en.wikipedia.org/wiki/Persistent_vegetative_state
15:51:05 <hpc> aavogt: ^^ :D
15:51:09 <monochrom> at any rate, how to read (a,b -> c) is just like how to read (a :+: b -> c). it's just a matter of defining operator precedence.
15:51:29 <pumpkin> yep, and exponentiation has higher precedence than multiplication
15:51:42 <Aune> Cale: How can I show whether f(x) = 1 + x + x^2 + .. + x^(p-1) is reducible in a field K when p is prime?
15:51:43 <monochrom> PVS is a theorem prover
15:52:21 <monochrom> intuitionistic conjunction has higher precedence than intuitionistic implication
15:53:14 <pumpkin> my type algebra has higher precedence than your logic algebra!
15:53:40 <monochrom> if you say so
15:54:41 <monochrom> why does lambdabot disappear so often? do we know?
15:56:11 <c_wraith> in my experience running it, mueval processes that time out aren't actually killed.  They keep building up until the drag the machine down to a halt.
15:56:19 <c_wraith> even though lambdabot stops waiting for them
15:56:25 <monochrom> eww
15:56:33 <hpc> c_wraith: cronjob a killall mueval?
15:56:57 <monochrom> cronjobbing it is like russian roulette :)
15:57:03 <c_wraith> hpc: that's a good idea, actually.  If only I didn't hate cron so much. :)
15:57:10 <hpc> yeah, cron is a pain
15:57:26 * hpc has had better luck perl-scripting his own cron by hand
16:02:16 <Cale> Aune: That's a cyclotomic polynomial
16:02:38 <Aune> ok, will google it
16:02:54 <Cale> Aune: So it factors as a product of (x - w), where the w are pth roots of unity
16:03:30 <Cale> Aune: (Well, all the primitive pth roots of unity)
16:05:11 <Aune> Cale: Ok, what happens if we restrict ourselfs Q for example? Then the roots of unity is only unity which is not a solution for the polynomial.
16:05:33 <Aune> Does this mean it is irreducible in Q?
16:06:06 <Cale> Well, all cyclotomic polynomials happen to be irreducible in Z[x] (and thus in Q[x])
16:06:27 <Aune> Ok
16:06:59 <Cale> I think we might be able to apply Eisenstein's criterion in this particular case, after making an appropriate substitution...
16:07:43 <medfly> @hackage xor
16:07:43 <lambdabot> http://hackage.haskell.org/package/xor
16:07:45 <medfly> er
16:07:47 <medfly> @hoogle xor
16:07:48 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
16:07:51 <medfly> sigh
16:07:52 <Cale> ah, it's detailed here: http://en.wikipedia.org/wiki/Eisenstein%27s_criterion#Examples
16:07:56 <Cale> medfly: /= :)
16:08:14 <medfly> what do you want from me?
16:08:20 <Aune> Cale: Thanks : )
16:08:22 <pumpkin> lol
16:08:25 <Cale> > [(x,y,x /= y) | x <- [False, True], y <- [False, True]]
16:08:26 <lambdabot>   [(False,False,False),(False,True,True),(True,False,True),(True,True,False)]
16:08:26 <pumpkin> friendly as always
16:08:38 <medfly> I'm just continuing an argument from before
16:08:42 <medfly> I'm very friendly
16:08:47 <medfly> just not towards Cale
16:08:47 <pumpkin> yeah, it's been going on for months as far as I can tell
16:08:53 <Cale> lol
16:08:54 <pumpkin> seems like it's time to get over shit
16:08:57 <medfly> it's Cale's fault
16:09:04 <Cale> wat?
16:09:11 <pumpkin> well, even if it is, be the better person
16:09:14 <Cale> I was just explaining how /= was xor :)
16:09:14 <pumpkin> :P
16:09:28 <pumpkin> Cale: you are a bad bad person
16:09:46 <medfly> :P
16:09:52 <pumpkin> Cale: did you murder medfly's puppy or something?
16:09:59 <Cale> It seems so
16:10:32 <monochrom> /= is xor for Bool. But probably you are interested in bitwise xor too.
16:10:33 <Cale> Aune: Ah, cool, it handles the case of Z/pZ too
16:11:05 <Aune> Cale: Awesome ^^
16:11:29 <medfly> everything is equivalent in boolean algebra, it's fucking ridiculous
16:12:06 <Cale> I like how each operator distributes over the other.
16:12:07 <Philippa_> yeah, starting with True and False
16:12:27 <monochrom> it's just math. not worth getting frustrated over it.
16:12:32 <medfly> my book is using (1 xor X) instead of not X now.
16:12:40 <monochrom> haha
16:13:01 <hpc> that's silly
16:13:26 <monochrom> I know books that use (not X or Y) instead of (X implies Y)
16:13:26 <medfly> well, I guess it could have just introduced not this way, but it would be an additional construct
16:13:33 <medfly> :))
16:13:46 <pumpkin> xor has great power
16:13:53 <pumpkin> with great power comes great responsibility, or something like that
16:14:17 <monochrom> with great exponentiation comes great implication
16:14:22 <pumpkin> lol
16:15:05 <Aune> Cale: Do you now of any good pictures tha shows the relations between algebraic structures. Like a graph where each node is an algebraic structure and each vertex shows the extra requirements?
16:15:14 <hpc> with rapidly diverging energy output comes great responsibility
16:16:18 <Aune> Cale: I can draw it muself but I stink at making discernable pictures
16:16:44 <monochrom> write it as an xml file and give it to graphviz :)
16:17:22 <Aune> Hmm, good suggestion
16:17:26 <Aune> thanks
16:17:29 <Cale> Aune: I have seen such diagrams... I don't have one off-hand though
16:17:41 <Aune> Ok
16:18:51 <Cale> Does it bother anyone else when people use the Weierstrass p for "power set"?
16:19:32 <dankna> it would bother me if I recognized it as such
16:19:50 <dankna> (in unrelated news, "Java is a DSL for converting large XML files to stack dumps.")
16:20:00 <hpc> hahaha
16:20:03 <monochrom> heh stack dumps
16:20:08 <mjrosenb> can anyone think of a reason that this would have exhaust the memory on my computer?
16:20:11 <mjrosenb> main = print ((randoms $ mkStdGen 2) ‼ (2^22) ∷ Int)
16:21:07 <Cale> Aune: here's one http://space.mit.edu/home/tegmark/toe.gif
16:21:21 <Cale> Aune: that's more focused on physics
16:21:24 <hpc> @src (!!)
16:21:25 <lambdabot> xs     !! n | n < 0 = undefined
16:21:25 <lambdabot> []     !! _         = undefined
16:21:25 <lambdabot> (x:_)  !! 0         = x
16:21:25 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:21:49 <hpc> > 2^22
16:21:50 <lambdabot>   4194304
16:22:00 <Cale> Aune: and it makes at least one unconventional choice :P (fields are normally commutative)
16:22:27 <monochrom> does it mean java programmers turn coffee into stack dumps? :)
16:22:41 <mjrosenb> Cale: main = print (([1..]) ‼ (2^22) ∷ Int)
16:22:43 <mjrosenb> is just fine
16:22:47 <Aune> Cale: Ok. Still nice though.
16:22:55 <pumpkin> hm, not a fan of that one
16:23:01 <mjrosenb> >  (([1..]) ‼ (2^22))
16:23:02 <lambdabot>   Not in scope: `‼'
16:23:06 <mjrosenb> >  (([1..]) !! (2^22))
16:23:07 <lambdabot>   4194305
16:23:14 <hpc> mjrosenb: element n depends on element n-1
16:23:28 <Cale> pumpkin: I found it through 15 seconds of google images searching, so it's probably not the best one :)
16:23:38 <hpc> write a version of !! that makes the last pattern something like this:
16:23:42 <monochrom> [1..] probably got optimized. randoms is too lazy.
16:23:49 <pumpkin> not that I'm an expert, but it seems to contain a lot of very vaguely related stuff, and leave out some useful stuff
16:23:52 <hpc> (x:xs) !! n = x `seq` xs !! (n-1)
16:24:04 <mjrosenb> ahh, and it is building up a giant stack of thunks evaluating the whole list
16:24:07 <pumpkin> the arrows also don't really have any kind of clear meaning sometimes
16:24:17 <monochrom> in fact I heard [m..] for Int got heavily hand-optimized
16:24:18 <mjrosenb> rather than just evaluating each element in order
16:24:22 <mjrosenb> and discarding it
16:24:42 <Aune> Cale: Its nice that the integers are a ring in that diagram but not a group ^^
16:24:54 <Cale> heh
16:25:13 <Cale> There should be an arrow from Abelian groups to rings
16:25:29 <Cale> (but for some reason there isn't)
16:26:30 <pumpkin> seeing this is making me want to make one that doesn't suck
16:26:47 <Cale> http://upload.wikimedia.org/wikipedia/en/c/cc/Lattice_v4.png
16:27:03 <Cale> There's a Hasse diagram of some order theoretic concepts
16:27:14 <Cale> It bothers me that it ends at partial order though :P
16:27:18 <pumpkin> conveniently, they form an order themselves
16:27:46 <Cale> preorders are important too! :)
16:27:56 <pumpkin> no preorders for you!
16:28:02 <pumpkin> if you want preorder, go to amazon.com
16:28:12 <monochrom> that is fairly meta, to apply partial orders to partial orders
16:29:15 <Cale> You can do this with any logical concepts which are related by implication :)
16:30:02 <monochrom> someone should draw a category diagram of well-known categories
16:30:19 * hackagebot doc-review 0.7 - Document review Web application, like http://book.realworldhaskell.org/  http://hackage.haskell.org/package/doc-review-0.7 (JoshHoyt)
16:32:22 <Alan> numLiteral = do x <- integer return (Literal (fromIntegral x))
16:32:45 <Alan> oops, that stripped the newline... anyway, i feel that should be something i can condense into a one-liner... what am i missing?
16:33:13 <benmachine> Alan: fmap
16:33:22 <Alan> (there's a linebreak between "integer" and "return"
16:34:09 <pumpkin> Alan: Literal . fromIntegral <$> integer
16:34:28 <Alan> ooh, what's <$>?
16:34:33 <pumpkin> a synonym for fmap
16:34:43 <pumpkin> fmap (Literal . fromIntegral) integer 
16:34:46 <pumpkin> has the same effect
16:34:55 <Alan> oh, interesting
16:35:02 <pumpkin> why do you have a fromIntegral there by the way?
16:35:18 * hpc has never used fmap in a serious program, ever
16:35:28 <hpc> (<$>) is so much nicer to look at
16:35:58 <Alan> pumpkin: because "Literal Int"?
16:36:16 <pumpkin> Alan: why would you want to discard information like that?
16:36:31 <pumpkin> Integer can hold arbitrarily large values, whereas Int is limited by your system
16:36:43 <pumpkin> well, they obviously both are, but Int is tiny by comparison :P
16:36:50 <benmachine> Alan: where is the Literal constructor from
16:36:59 <Alan> pumpkin: right, but this is the top part of a compiler
16:37:04 <Alan> i.e. parsing
16:37:10 <pumpkin> Alan: I figured :)
16:37:18 <pumpkin> I just wondered why you'd want a lossy AST :P
16:37:32 <Alan> Hmm, i guess you have a point there
16:38:11 <Alan> also, hmm, fmap as <$> is nice
16:38:24 <Alan> i guess if i read it as "like $ but with Monads" ?
16:38:35 <Alan> kinda, anyway
16:39:15 <Alan> <$> not in the prelude?
16:39:19 <hpc> no
16:39:19 <pumpkin> it doesn't even need a full Monad
16:39:20 <pumpkin> just Functor
16:39:23 <hpc> Control.Applicative
16:39:25 <pumpkin> it's in Control.Applicative or Data.Functor
16:39:32 <hpc> it's in Functor now?
16:39:35 <Alan> OR? which import should i use?
16:39:40 <pumpkin> doesn't really matter
16:39:41 <hpc> use applicative
16:39:45 <hpc> you get <*> that way too
16:39:57 <pumpkin> yeah, Applicative will be very useful in a parser
16:40:04 <hpc> > (+) <$> Just 5 <*> Just 2
16:40:06 <lambdabot>   Just 7
16:40:23 <Alan> what's <*>?
16:40:36 <Alan> sorry, i don't know my way around all these combinators (right terminology?) yet...
16:40:39 <hpc> :t (<*>)
16:40:40 <shachaf> Alan: "like * but with Applicatives". :-)
16:40:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:41:20 <hpc> Alan: f <*> v = pull a function out of f, and pull a value out of v; apply f to v, and wrap it up again
16:41:24 <shachaf> liftMn f a1 ... an = f <$> a1 <*> ... <*> an
16:41:43 <shachaf> (Or, rather, liftAn, which is more general.)
16:41:53 <Alan> ok, wow, i got a little lost there
16:42:14 <Cale> > [id, (+2), (*2), (^2), (2^)] <*> [3,5]
16:42:15 <lambdabot>   [3,5,5,7,6,10,9,25,8,32]
16:42:18 <shachaf> (<*>) is also ap, if you're familiar with it
16:42:21 <hpc> Alan: consider (+) <$> Just 5 <*> Just 2
16:42:27 <Cale> > [id, (*10)] <*> [3,5]
16:42:28 <lambdabot>   [3,5,30,50]
16:42:34 <hpc> what happens when you do (+) <$> Just 2?
16:42:46 <hpc> you get Just (2 +)
16:42:57 <hpc> so you apply that to another Just value with <*>
16:43:07 <hpc> > Just (2 +) <*> Just 5
16:43:08 <lambdabot>   Just 7
16:43:31 <Alan> oh
16:43:44 <roscoe> would someone mind telling me what the $ operator is
16:43:53 <hpc> roscoe: it's a synonym for id :P
16:43:56 <Alan> so <*> is like <$> when both the function and the argument is inside whatever?
16:44:06 <hpc> roscoe: (it's function application)
16:44:12 <hpc> f $ x = f x
16:44:17 <roscoe> okay
16:44:24 <Alan> heh
16:44:32 <roscoe> just saw it in a xmonad config example
16:44:34 <roscoe> and it wasn't clear
16:44:34 <hpc> Alan: indeed
16:44:39 <Alan> so is the whole point of $ the precedence/associativity hack?
16:44:54 <geheimdienst> roscoe, it's mostly used to save typing some parens. basically, replace the "(" with a "$" and you can leave out the ")"
16:44:55 <hpc> ($) is used for precedence, but also for wild functional magic
16:45:01 <shachaf> @ty let ap mf mx = do { f <- mf; x <- mx; return (f x) } in ap -- Alan: Equivalent to this, if a monad is involved.
16:45:02 <lambdabot> forall (m :: * -> *) t b. (Monad m) => m (t -> b) -> m t -> m b
16:45:05 <hpc> it turns function application into a function
16:45:07 <hpc> :t fmap ($)
16:45:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
16:45:12 <hpc> er
16:45:16 <hpc> :t zipWith ($)
16:45:17 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
16:45:58 <roscoe> what is tryhaskell.org done with? are there web libraries for haskell?
16:46:53 <shachaf> Alan: zipWith ($) is a specialization of (<*>), by the way.
16:47:38 <hpc> shachaf: it's a specialization for ZipLists, only the arguments are []
16:48:01 <Alan> yeah, i TOTALLY didn't understand what happens with lists etc. inside do ... or any other applicative stuff going on...
16:48:17 <hpc> yeah, don't worry about that
16:48:22 <hpc> it's really damn hard to understand
16:48:24 <fryguybob> roscoe: https://github.com/chrisdone/tryhaskell
16:48:26 * hpc barely gets it
16:48:38 <Alan> x <- [1, 2, 3]; y <- [4, 5, 6]
16:48:44 <roscoe> ty fryguybob 
16:48:51 <Alan> i understand what they do inside a list comprehension
16:48:52 <Alan> ish
16:48:59 <shachaf> hpc: Yes, *a* specialization. :-)
16:49:02 <aavogt> is there a good example of the difference between   [$qq| foo |] and   $(quoteExp qq " foo ")  around somewhere?
16:49:43 <shachaf> Alan: A list comprehension is almost exactly the same thing as do notation.
16:50:11 <Alan> shachaf: yeah, i saw something explain it that way
16:50:56 <hpc> a list comprehension with no Bool clauses can be blindly translated into do notation in the obvious way
16:51:12 <shachaf> hpc: Bool clauses can be translated into guard.
16:51:13 <Alan> seems like a list comprehension is just a special syntax for do-notation when creating lists?
16:51:19 <hpc> right
16:51:22 <hpc> @src guard
16:51:22 <lambdabot> guard True  =  return ()
16:51:22 <lambdabot> guard False =  mzero
16:51:31 <hpc> :t guard
16:51:32 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:51:37 <shachaf> Alan: Yep. In the past (with monad comprehensions), the list comprehension notation could be used for any monad.
16:52:04 <aavogt> and in the future too
16:52:14 <shachaf> aavogt: Oh?
16:52:27 <Alan> hpc: as in foo l1 l2 = do { x <- l1; y <- l2; x * y }  ===  [x * y | x <- l1, y <- l2] ?
16:52:30 <aavogt> shachaf: probably it'll be in the next ghc
16:52:30 <hpc> monad comprehensions would be cool, for trees and such
16:52:36 <hpc> Alan: indeed
16:52:44 <shachaf> aavogt: Hmm. I hadn't heard.
16:53:03 <shachaf> Alan: Except that it would be "return (x * y)".
16:53:07 <Alan> :t <*>
16:53:08 <lambdabot> parse error on input `<*>'
16:53:12 <Alan> :t (<*>)
16:53:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:53:20 <hpc> and [x * y | x <- l1, y <- l2, x < y] === do { x <- l1; y <- l2; guard (x < y); return x * y }
16:53:31 <FauxFaux> @pl [x * y | x <- l1, y <- l2, x < y]
16:53:31 <lambdabot> [x * y | x <- l1, y <- l2, x < y]
16:53:37 <FauxFaux> Boo.
16:53:40 <hpc> pl can't handle comprehensions
16:53:44 <shachaf> Alan: And a shorter way to write taht comprehension would be "liftA2 (*) l1 l2". :-)
16:53:55 <Alan> Applicative... is that like "Monad lite" ?
16:54:05 <shachaf> @. pl undo [x * y | x <- l1, y <- l2, x < y]
16:54:05 <lambdabot> (l2 >>=) . flip flip [] . ap (ap . (if' .) . (<)) (flip flip [] . ((:) .) . (*)) =<< l1
16:54:07 <hpc> Alan: don't compare it to monad
16:54:15 <Alan> hpc: ok
16:54:20 <hpc> Alan: consider it an "uberfunctor"
16:54:36 <FauxFaux> "@. pl" O_o
16:54:36 <Alan> shachaf: heh, also a less readable way? unless you assume the reader knows what liftA2 does :P
16:54:48 <geheimdienst> überfünctor
16:54:52 <shachaf> @src liftM2
16:54:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:55:00 <shachaf> Alan: That's exactly the definition of liftM2.
16:55:11 <Alan> shachaf: as i'm finding out ,breaking into the more advanced haskell can be a little tricky because it's non-obvious until somebody explains it :P
16:55:22 <shachaf> Alan: The whole point of monads is that you can write libraries that work across more than one. :-)
16:55:24 <hpc> FauxFaux: @. x y input does out = @y input; @x out
16:55:42 <Alan> Yeah, i've totally forgotten whan a functor is now as well
16:55:48 <Alan> :(
16:55:50 <FauxFaux> hpc: Ow.
16:55:54 <shachaf> Alan: Something that has fmap.
16:55:55 <hpc> a functor is something you can apply a function to the inside of
16:56:00 <hpc> vaguely
16:56:04 <shachaf> s/fmap/a reasonable fmap/
16:56:06 <Alan> ok
16:56:06 <dancor> what's the best way to have a bunch of things available for quick-and-dirty scripting?  if i just do import MyScriptingLibThatReExportsEverything i can't get anything qualified
16:56:37 <benmachine> if you want stuff qualified you need lots of imports
16:56:39 <hpc> dancor: i don't think you would want qualified names if you are doing quick-and-dirty
16:56:46 <dancor> should i use TH or just some simple preprocessing that slams a bunch of qualified imports at the top?
16:56:52 <benmachine> TH can't do imports
16:56:58 <dancor> hpc: i do want them
16:57:24 <dancor> lists, sets
16:57:30 <dancor> errr maps, sets
16:57:53 <dancor> i guess it's a preprocessor then
16:58:08 <benmachine> just write the like four lines?
16:58:37 <dancor> i have 16 lines
16:58:41 <dancor> that i use in ghci
16:58:52 <dancor> and 4 would be too much anyway, you academic types
16:59:24 <Eduard_Munteanu> Maybe CPP?
16:59:37 <Eduard_Munteanu> I'm not sure what exactly you want to do.
17:00:01 <hpc> CPP would muddle the process of running it in ghci, i think
17:00:20 <Eduard_Munteanu> ghci can't use CPP?
17:00:22 <dancor> i guess the same amound as MyPP would
17:00:27 <dancor> amounT
17:01:01 <dancor> maybe CPP is a good way
17:01:06 <benmachine> if you're running in ghci, use a .ghci
17:01:31 <Eduard_Munteanu> I suppose you could pass the CPP flag on the ghci cmdline.
17:01:39 <Eduard_Munteanu> *invocation, even
17:01:43 <joe6> > parseTest (do {x <- manyTill anyChar (try (string "CBLOCK")); y <- string "CBLOCK ";return (x,y)}) "CBLOCK 0"
17:01:44 <lambdabot>   Not in scope: `parseTest'Not in scope: `manyTill'Not in scope: `anyChar'Not...
17:02:18 <joe6> parse error at (line 1, column 7):  unexpected " " expecting "CBLOCK "
17:04:04 <Zeiris> Is there a GHC extension for generalizing list comprehensions to monad comprehensions?
17:04:39 <pumpkin> there will be
17:04:42 <Saizan> joe6: CBLOCK got already parsed by (try (string "CBLOCK")) at that point
17:04:54 <pumpkin> Zeiris: someone has code for it, but I don't think it's merged into GHC tree yet
17:05:03 <Zeiris> cool
17:06:05 <joe6> Saizan: oh, that is what I am missing .thanks
17:09:46 <dancor> this is awesome, i can just make a /usr/local/include/h
17:10:51 <Eduard_Munteanu> What for?
17:11:12 <aavogt> Zeiris: you could make a quasiquoter for that in the meantime
17:11:27 <Zeiris> Template haskell scares and intimidates me. :(
17:11:40 <aavogt> with haskell-src-meta and maybe the @undo code from \bot it won't take much effort
17:11:43 <Eduard_Munteanu> Is it me or are the docs not that good?
17:12:03 <aavogt> Eduard_Munteanu: which docs?
17:12:12 <Eduard_Munteanu> aavogt: TH. Or at least not very instructive.
17:12:27 <Eduard_Munteanu> I remember looking at them and I couldn't extract much useful info.
17:12:52 <aavogt> it's not terribly well organized, but there's more than enough written about them
17:14:02 <Cale> The main thing you need to use the TH docs for are the datatype declarations anyway
17:14:25 <Cale> They kinda suck, but you can get by...
17:14:43 <aavogt> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH.html
17:14:54 <aavogt> compare with previous docs
17:15:03 <Eduard_Munteanu> Oh.
17:15:11 <Eduard_Munteanu> I was looking at the GHC manual IIRC, or the wiki.
17:15:27 <Eduard_Munteanu> s/or/and/
17:16:35 <Cale> and then note that almost everything else which is defined there is a lowercase version of one of the data constructors which is lifted into the Q monad.
17:17:31 <Luke> I mistakenly installed the wrong version of ghc with make install... is there any way to uninstall it?
17:17:53 <flippo> make uninstall?
17:17:54 <Saizan> make uninstall
17:18:10 <Luke> i didnt see it...
17:18:29 <flippo> You don't have to see it.  You just type it.
17:18:37 <Luke> yeah there's no make uninstall rule in the makefile
17:19:35 <Saizan> most of it gets installed under /usr/local/lib/ghc-$ver
17:19:52 <Saizan> + some executables in /usr/local/bin
17:20:13 <Luke> yeah i have 'locate' to find it =/ just seems messy
17:20:15 <Luke> thanks
17:20:25 <Eduard_Munteanu> I wouldn't recommend installing anything you built yourself system-wide.
17:20:47 <Eduard_Munteanu> I use a subdir in my home, and make separate subdirs, so you could have something like ~/apps/foo.
17:21:37 <Eduard_Munteanu> Then it's easy to hack ~/.bashrc to add it to PATH and LD_LIBRARY_PATH
17:22:07 <Eduard_Munteanu> To uninstall you just delete that subdir.
17:22:47 <Saizan> make uninstall would still be nice to have
17:23:06 <Eduard_Munteanu> Doesn't it use autoconf? I've seen a few Haskell pkgs use it.
17:23:14 <Eduard_Munteanu> autotools give you uninstall for free.
17:25:28 <aavogt> Eduard_Munteanu: I agree regarding the docs. Part of it is that the topic isn't very easy (sort of like monads, but less popular)
17:27:09 <pumpkin> how would one combine HOAS with pattern-match bindings? any references?
17:28:04 <Saizan> pumpkin: i.e. how do you use HOAS to represent case expressions?
17:28:13 <pumpkin> I don't have case expressions :)
17:28:16 <pumpkin> if I did, it'd be simpler :P
17:28:36 <pumpkin> how would one do that?
17:30:19 <mtnviewmark> The ghc-pkg database has most of the information needed to find the files you need to uninstall a package. cabal can figure out the rest... It would great if cabal had an uninstall command
17:30:26 <dankna> we know
17:30:31 <dankna> it comes down to
17:30:40 <dankna> you wipe everything out when you upgrade ghc anyway
17:30:46 <dankna> and nobody has stepped forward to write the code
17:30:58 <Eduard_Munteanu> Doesn't that Nix stuff work yet?
17:31:18 <Eduard_Munteanu> (I didn't bother trying it, I do the same, wipe it)
17:31:31 <aavogt> distro packages can be uninstalled
17:32:19 <Eduard_Munteanu> Yeah, I tend to use whatever Gentoo before going cabal-install usually.
17:32:32 <Eduard_Munteanu> *Gentoo has
17:33:14 * hpc uses a disposable partition for his linux install
17:33:31 <Eduard_Munteanu> And you wipe it away every now and then? :)
17:33:34 <hpc> if i am unhappy with a configuration, i reinstall the whole thing
17:33:34 <mtnviewmark> understood --- though wiping it all away before upgrading is hard ... finding all that stuff...
17:33:36 <hpc> yeah
17:33:57 <hpc> i tend to break things with frequency, anyway
17:34:10 <Eduard_Munteanu> Well that's just like some people do with Windows. They shit on their install and regularly wipe it.
17:34:31 <hpc> i am much better at keeping windows clean than linux
17:34:37 <Eduard_Munteanu> hpc: what distro? I can usually fix any breakage I do in Linux.
17:34:38 <hpc> though it is also easier
17:34:48 <hpc> Eduard_Munteanu: xubuntu
17:34:57 <hpc> mainly for wubi
17:35:03 <hpc> i dislike burning a CD every time
17:35:16 <Eduard_Munteanu> I'm clueless what to do if Windows gets really broken. With Linux it's easy to patch it up.
17:35:38 <hpc> when windows breaks, boot into safe mode and uninstall the last installed thing
17:35:40 <hpc> or do system restore
17:35:43 <hpc> or a virus scan
17:35:58 <Eduard_Munteanu> If that works... Linux's idea of failover modes is more barebones.
17:36:29 <hpc> yeah, i hate it too
17:36:46 <hpc> what's baffling is people like to suggest safe mode with networking
17:37:00 <hpc> because it's a good idea to go on the nets without firewall or antivirus
17:37:12 <Luke> "/bin/sh: /usr/local/lib/ghc-6.12.3/ghc-pkg: not found" getting this when trying to make install ghc. any ideas why that would be a prereq?
17:37:54 <aavogt> variables names tend to be accidentally (almost?) offensive: http://www.haskell.org/haskellwiki/Scrap_your_boilerplate#fmap
17:37:56 <Eduard_Munteanu> Admittedly, if it's anything like a clean Linux install, safe mode w/ net should be safe. But then again, Windows' track record of security isn't bright. 
17:39:04 <hpc> win7 is much better than previous versions
17:39:12 <hpc> but there's still exploits to be found
17:39:59 <flippo> I hear that win8 will fix all the problems with win7, too.
17:40:02 <Eduard_Munteanu> I think the biggest problem with Windows is stupid users. Which they've kinda encouraged.
17:40:37 <Eduard_Munteanu> If they had more paranoid people using Windows... well let's say viruses wouldn't be so common.
17:40:44 <dankna> I think the biggest problem with Windows is back-compatibility constraints.  Which is their ENTIRE marketing strategy.
17:40:49 <Eduard_Munteanu> (or is it virii? :D)
17:40:52 <hpc> correction: if they had more paranoid people /writing/ windows
17:41:01 <Eduard_Munteanu> That too.
17:41:14 <dankna> Viruses is correct - it's a word that has no attested plural in Ancient Greek, but the most likely declension for it to be in would be "viruses".
17:41:30 <dankna> er I mean Ancient Latin
17:41:49 <Eduard_Munteanu> http://en.wiktionary.org/wiki/virii
17:41:55 <hpc> windows has a great UI design
17:41:59 <Eduard_Munteanu> Yeah, virii is pedantic maybe.
17:42:00 <dankna> if they didn't have to remain compatible with Win 3.1 apps, for example, they could avoid using shared-memory segments and remove the ability of heap corruption to spread cross-process
17:42:15 <hpc> it's not consistently executed though, and the OS is kinda nasty when you want to configure something deep inside it
17:42:39 <hpc> like disabling or enabling services
17:42:48 <Eduard_Munteanu> I'm not sure whether it's the UI, or just integrating many many things together tightly.
17:42:58 <dankna> I'll concede that Windows has a great UI design, yes, that's clear when you consider Linux's several attempts at it, but OS X has a world-class stellar UI design.
17:42:59 <hpc> dankna: they removed that compatibility layer
17:43:03 <dankna> hpc: oh!  good!
17:43:04 <Alan> Damn, i've got myself into a corner with parsec :9
17:43:33 <pumpkin> Saizan: any ideas?
17:43:35 <Eduard_Munteanu> Dunno, I'd still use xmonad.
17:43:36 <hpc> it goes back to...
17:43:40 <hpc> 2000, iirc
17:43:41 * hackagebot DBlimited 0.1.1 - A command-line SQL interface for flat files (tdf,csv,etc.)  http://hackage.haskell.org/package/DBlimited-0.1.1 (JohnMayer)
17:43:55 <hpc> no, still 95
17:44:01 <Eduard_Munteanu> Admittedly UNIX stuff was pretty ugly. Like Motif.
17:44:03 <hpc> though it has improved greatly
17:44:12 <dankna> Motif, ugh.
17:44:15 <Eduard_Munteanu> Even Win3.1 looks less ugly maybe.
17:44:15 <hpc> 7 can old code that XP won't, for example
17:44:29 <hpc> *run
17:44:49 <hpc> yeah, old unix was hilari-bad
17:44:55 <Eduard_Munteanu> I hear Motif apps are still being developed, *sigh*
17:45:14 <hpc> Eduard_Munteanu: java swing, probably
17:45:38 <Eduard_Munteanu> No I think it's the reason for OpenMotif's existance, I don't really know.
17:47:13 <joe6> my first parsec script: http://hpaste.org/paste/42102/first_parsec#p42103 (please scroll to the bottom). Any thoughts, please?
17:48:48 <Saizan> pumpkin: not really, i guess the problems is that the number (and types maybe?) of the variables bound depend on the pattern, right?
17:49:15 <pumpkin> Saizan: yeah :/
17:49:29 <pumpkin> Saizan: not representing types in the ADT so that is less of a problem
17:49:48 <pumpkin> but I'm currently thinking of a [Term] -> Term representation of the bindings from the patterns
17:49:51 <pumpkin> makes me feel icky though
17:50:38 <Saizan> you could index a pattern by the number of free variables and use Vec Term that_number rather than [Term]
17:50:50 <pumpkin> I was thinking of that, except I'm not in haskell :P
17:51:20 <Saizan> scala?
17:51:21 <pumpkin> yep
17:51:38 <pumpkin> was just wondering in general how languages dealt with variable-arity binders, really
17:51:51 <pumpkin> with HOAS, that is
17:52:04 <dankna> sorry, HOAS?
17:52:06 <Saizan> i don't remember examples of that
17:52:09 <dankna> I know how Common Lisp deals with it
17:52:41 <hpc> yeah, it's generally done with parenthesis
17:53:01 <hpc> hence every language that ever made a function call look like foo(x, y, z)
17:53:02 <Saizan> HOAS is a way to represent your syntax trees
17:53:13 <Saizan> so the question is not much about the surface syntax
17:53:19 <dankna> oh
17:53:40 <dankna> yeah, CL does it with parentheses as well (duh) :)
17:53:41 <joe6> guys, any thoughts on this script please? http://hpaste.org/42103/first_parsec (no need to scroll).
17:54:00 <dankna> another strategy would be to use hyphens to mean "shift" and commas to mean "reduce"
17:54:41 <Saizan> Higher Order Abstract Syntax is higher order because it represents binders via the(/a) function space of the host language
17:55:03 <dankna> this sounds like an interesting concept which I should learn about
17:55:28 <Saizan> yep it's uite nice
17:55:41 <pumpkin> except for variable-arity binders it seems! :P
17:55:54 <dankna> so it could be used, for example, to make parser-generator inputs terser?
17:56:30 <pumpkin> hmm, how so?
17:56:46 <pumpkin> it mostly saves you from dealing with alpha-equivalence of variables in your AST representation
17:56:49 <dankna> hmm
17:56:57 <dankna> alpha-equivalence = over my head
17:57:12 <Saizan> the first order way is to have datatypes like data Expr = Var Name | App Expr Expr | Lam Name Expr
17:57:16 <dankna> I was thinking of something like how ANTLR lets you build an AST without writing procedural code
17:57:16 <pumpkin> dankna: renaming of variables, basically :)
17:57:19 <dankna> oh, okay
17:57:20 <joe6> Saizan: can you please take a look at my script? i am looking for any feedback. this is my first parsec script and am really looking to learn on how I can make it better.
17:57:38 <dolio> Alpha equivalence says that (\x -> x) and (\y -> y) are the same.
17:57:50 <dankna> oh!  okay
17:58:43 <dankna> so the short answer is no, I'm up the wrong tree with what I was saying
17:58:51 <dankna> but I'm interested in the long answer
17:59:18 <pumpkin> dankna: here, there's a nice paper that goes over some different approaches
17:59:26 <dankna> oh, that would be great :)
17:59:29 <pumpkin> http://www.augustsson.net/Darcs/Lambda/top.pdf
17:59:39 <dankna> can't promise to read it this week as I'm busy, but I will add it to my bibdesk for reading later
17:59:44 <dankna> thanks!
17:59:48 <pumpkin> it's very digestible :)
18:01:22 <Saizan> joe6: looks nice, you could refactor the two uses of map (read::String->Int) (many1 digit) as a "number" parser
18:01:32 <Saizan> (natural, maybe)
18:01:34 <dolio> There are first-order representations that unify all alpha equivalent terms in the same way HOAS.
18:01:42 <dolio> But they have their own problems.
18:01:57 <joe6> Saizan: I wish I could do something like banks <- many (bank <|> eof)
18:02:00 <Luke> how can I hide a package while installing a package with cabal?
18:02:03 <pumpkin> dolio: ah, any references? also, any ideas about my pattern bindings in HOAS?
18:02:10 <joe6> but am not able to figure out how I can do that.
18:02:22 <dolio> pumpkin: de Bruijn indices/levels.
18:02:26 <pumpkin> oh fair enough :)
18:02:48 <dolio> There's no (\x -> x) and (\y -> y). There's only (\ -> 0)
18:02:50 <pumpkin> does the "typed de bruijn index" approach have a name by the way?
18:03:16 <Luke> http://hpaste.org/42104/ambiguous_reference anyone know which package is correct?
18:03:25 <dolio> Typed de Bruijn index?
18:03:47 <Saizan> joe6: i'm a bit rusty on the details of parsec, does manyTill bank eof work?
18:04:01 <pumpkin> dolio: http://pumpkinpat.ch/moo.html the Var thing from there (basically a list of types, which is like an annotated natural)
18:04:02 <joe6> Saizan: took care of the number
18:04:04 <pumpkin> I've seen it in a few places
18:04:30 <dolio> Oh.
18:04:56 <dolio> I don't know if there's a name for that, no.
18:05:04 <dolio> Other than nice use of indexed types.
18:06:39 <dolio> And no, I don't really know about your pattern matching stuff.
18:07:01 <pumpkin> ah well, I'll experiment with indexing the pattern by the number (and maybe type) of bound variables in it as Saizan suggested
18:07:17 <dolio> I've never bothered figuring out how to handle pattern matching, because all the languages I've implemented, I'm more interested in other aspects.
18:07:45 <pumpkin> yeah, same here
18:08:23 <dolio> And it seems like a hassle.
18:09:50 <Saizan> parametric polymorphism + subtyping should let you encode gadts a la oleg's finally tagless
18:10:19 <pumpkin> you can encode GADTs, sort of, but I don't want to deal with the type-level numerals
18:11:36 <pumpkin> I quite like the HOAS in agda through oleg's "symantics" approach
18:12:09 <pumpkin> haven't really played much with it though, so maybe it fails elsewhere
18:12:55 <freedrull> is there some parser generator lib that the name is something like greppa, or grappa...
18:13:13 <pumpkin> made of fermented grape skins?
18:13:38 <freedrull> grempa thats it
18:13:41 <freedrull> pumpkin: yes
18:13:50 <aavogt> maybe happy accomplishes the same
18:25:05 <Axman6> so, is there a preferred database connection framework in haskell? any comment on which ones you prefer, pros, cons?
18:28:36 <sshc> What does the acronym "NB" represent?
18:29:08 <crutcher> i've got a lib in ./A/B.hs ; and ghci Prelude> import A.B doesn't work.
18:29:25 <crutcher> I've played about with -i, as described here: http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/separate-compilation.html#search-path
18:29:31 <crutcher> but I'm a bit lost
18:31:28 <Cale> sshc: nota bene
18:31:42 <Cale> "note well"
18:32:02 <Cale> (In a general context, anyway :)
18:32:40 <Cale> crutcher: Does A/B.hs start with  module A.B where ...
18:32:41 <heatsink> crutcher: does the module start with 'module A.B'?
18:32:45 <kmc> it stands for "negabyte"
18:32:53 <crutcher> yes
18:32:54 <kmc> which is -1 bytes
18:33:10 <kmc> crutcher, you shouldn't need -i then
18:33:16 <kmc> what error do you get?
18:33:21 <crutcher> in fact, ./B.hs (module B where ...) ; ghci Prelude> import B also doesn't work
18:33:22 <Cale> Heh, nB = nanobyte = 10^(-9) of a byte
18:33:31 <heatsink> If you read a document whose size is measured in negabytes, you get dumber.
18:33:37 <crutcher> <no location info>:
18:33:37 <crutcher>     Could not find module `HagisRequest':
18:33:37 <crutcher>       it is not a module in the current program, or in any known package.
18:33:44 <crutcher> where HagisRequest is my module
18:33:50 <kmc> crutcher, you can paste error messages at hpaste.org
18:33:56 <gwern> mm. Hagis.
18:34:01 <kmc> that *should* work
18:34:12 <kmc> you're sure the filename and the module name match, and it's in the current directory?
18:34:15 <kmc> also, what OS?
18:34:36 <crutcher> osx, ghc 6.12.3
18:34:47 <kmc> anything interesting if you run ghci with -v
18:34:47 <crutcher> not setting -i
18:34:48 <kmc> ?
18:36:08 <crutcher> kmc: not during the import
18:36:12 <aavogt> crutcher: module *A.*B   -- * are for emphasis
18:36:14 <crutcher> lots of stuff during the boot
18:36:36 <crutcher> aavogt: yes, i'm aware. I've reduced this down to Foo.hs : module Foo where
18:36:40 <crutcher> in the current directory
18:37:15 <crutcher> oh, this is awesome.
18:37:17 <heatsink> Does 'import' require the module to be compiled?
18:37:23 <aavogt> heatsink: no
18:37:25 <kmc> no heatsink
18:37:32 <kmc> with ghci it will interpret it; with ghc --make it will compile it
18:37:41 <crutcher> create Bar.hs; module Bar where import Foo; ghci Bar.hs; works fine
18:37:56 <heatsink> Check the case of your filename
18:37:58 <Cale> oh
18:38:05 <Cale> import in ghci is equivalent to :m + 
18:38:07 <crutcher> but I can't type import Foo and have it work
18:38:10 <Cale> You want :l
18:38:41 <heatsink> :) :l :(
18:38:48 <Cale> (I never actually use import syntax in ghci :)
18:39:17 <c_wraith> more people making me feel weird for being able to type "import " much faster than ":m +"
18:39:24 <crutcher> Cale: that is not at all clear given the docs on search paths
18:39:40 <joe6> how can I convert: Int -> GHC.Word.Word8
18:39:45 <crutcher> I saw that this all got re-written in 7.0, haven't tried that yet
18:39:46 <heatsink> joe6: fromIntegral
18:39:47 <kmc> :t fromIntegral
18:39:49 <lambdabot> forall a b. (Integral a, Num b) => a -> b
18:39:50 <crutcher> but thanks :)
18:39:52 <joe6> ok, thanks.
18:39:58 <kmc> of course it's a lossy conversion joe6
18:40:08 <Cale> c_wraith: It's more because I'm used to it than for any reason of speed
18:40:12 <kmc> unless you're running GHC on an 8-bit machine
18:40:42 <aavogt> that would be a GHC that doesn't comply with the spec
18:40:58 <kmc> it's true
18:41:06 <kmc> you're fine on a 30-bit machine, though
18:41:09 <Cale> joe6: as a side note, fromIntegral is the answer to almost all questions about how to convert one type of number into another -- with realToFrac covering a lot of the rest of the cases :)
18:41:20 <heatsink> :t realToFrac
18:41:20 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
18:41:22 <crutcher> an 8bit machine doesn't _have_ to have 8bit Ints
18:41:32 <heatsink> @instances Real
18:41:32 <lambdabot> Double, Float, Int, Integer
18:41:35 <crutcher> you could fake them
18:41:40 <crutcher> it would just be slow
18:42:28 <heatsink> It would probably require more than 256 bytes of code to do that
18:50:59 <joe6> Cale: ok, thakns.
18:56:09 <joe6> quick design question: one file has the data structure and another file has the data. I am reading the structure into an ADT and then assigning the data to the structure. The structure in this case is linear, so no big deal. I am just thinking how it would be done if the data structure is a tree with multiple data subtrees
18:57:40 <joe6> the data structure says: tree can have atmost 3 sub-trees. the data is: tree with 1 datatree or the data could be: tree with 2 datatrees.
18:58:45 <joe6> something similar to edifact processing.
18:59:01 <crutcher> hey, so ... is --make really the default mode for ghc foo.hs ?
18:59:18 <crutcher> because I see very different behaviour with and without (one links, the other doesn't)
18:59:23 <joe6> where they give you a file with the data structure. and the other file has the data in that structure.
19:01:49 <Cale> crutcher: no
19:02:02 <Cale> crutcher: You should (almost) always use --make though
19:02:02 <kmc> crutcher, it's default in GHC 7
19:02:06 <kmc> not earlier
19:02:21 <kmc> you were reading the GHC7 docs i think
19:02:22 <Cale> joe6: I really don't understand your question.
19:02:32 <crutcher> oh, I see; yes, that's what I did
19:02:45 <kmc> the default behavior in GHC6 is almost never what you want
19:02:48 <kmc> unless you are a Makefile
19:02:51 <kmc> or you are Cabal
19:03:03 <kmc> and since most people are neither a Makefile nor Cabal, the default was changed
19:03:14 <kadoban> seems like a good change...i always forget --make
19:03:29 <kmc> alias ghc='ghc --make'
19:03:31 <kmc> if you like
19:03:39 <joe6> Cale: a file describes the structure of data. There is the data file that should be used parsed based on how the "structure" file defines that data.
19:04:01 <Saizan> kmc: even Cabal uses --make
19:04:09 <kmc> oh
19:04:20 <Cale> joe6: If you were using parsec, you'd parse the first file and have the result of the parser be another parser
19:04:22 <kmc> but it also specifies packages explicitly
19:04:26 <kmc> ok
19:05:05 <Cale> joe6: But for the end result, you'd need a datatype general enough to admit any possible structure described by the first sort of file
19:05:19 <joe6> Cale: yes, but that would not be static/compiled. generate the parsec script and then use that script.
19:05:35 <joe6> i am wondering if it is possible to have something dynamic..
19:05:46 <Cale> joe6: what?
19:06:02 <Cale> joe6: I'm saying that the parser for the first file would have type  Parser (Parser Structure)
19:06:24 <Cale> joe6: and after running that parser on the contents of the first file, you'd get a result of type  Parser Structure
19:06:31 <Cale> and run that parser on the second file
19:06:41 <sshc> Can anybody familiar with type families help me figure out why this code isn't compiling?  I've been trying to figure this out for hours http://hpaste.org/42105/type_family_gah
19:06:49 <sshc> Where is s2 coming from??
19:07:02 <Eduard_Munteanu> Can I build RTS options into my program?
19:07:12 <joe6> Cale: that is an interesting approach. Thanks, will think through it.
19:08:05 <Cale> Eduard_Munteanu: Yes, by linking it with a small C program
19:08:31 <joe6> Cale: actually that is pretty smart. having a parser structure within a parser structure..
19:08:42 <Cale> Eduard_Munteanu: char *ghc_rts_opts = "-H128m -K1m";
19:08:45 <Eduard_Munteanu> Oh, not what I expected but I guess it's ok if I really really need it sometime. Thanks.
19:09:03 <Cale> Eduard_Munteanu: put something like that in  rts.c  and then just include it on the commandline to GHC
19:09:11 <heatsink> sshc: The problem is in toMainChar and toAltChar.  They cannot decide which type 's' to use.  
19:09:21 <Eduard_Munteanu> Cale: oh, that's nice.
19:09:42 <sshc> heatsink: I don't understand
19:10:02 <Eduard_Munteanu> BTW, is there any way to reduce GC time other than -H ?
19:10:24 <Cale> Eduard_Munteanu: make less garbage? :)
19:10:27 <Eduard_Munteanu> It's currently eating 17% time compared to -H64m.
19:10:33 <Eduard_Munteanu> Heh.
19:10:57 <sshc> heatsink: Isn't there only one s?
19:11:07 <heatsink> sshc: Ignoring type class constraints, altCons has type (StringConstructAltChar s) -> s -> s, and toMainChar has type 	c -> StringConstructChar s
19:11:40 <heatsink> Oh, I mean cons
19:11:42 <heatsink> cons has type (StringConstructChar s) -> s -> s
19:12:24 <sshc> Shouldn't GHC choose "(StringConstructorChar s)" as the result of the toMainChar?
19:12:28 <Saizan> cons makes sense actually
19:12:34 <heatsink> it does
19:12:37 <sshc> If not, how could I be more explicit?
19:12:48 <heatsink> In the body of altCons, you have a call (toMainChar c).  So GHC starts by inferring that this call has type c1 -> StringConstructChar s1
19:13:05 <shachaf> haskell.org claims Haskell has "debuggers".
19:13:14 <shachaf> Is there more than one?
19:13:23 <Saizan> sshc: the problem is that for a type synonym family F, F a ~ F b doesn't imply a ~ b
19:13:24 <mtnviewmark> yeah - everyone on this channel!
19:13:30 <heatsink> Or rather, that c has type c1, and the call's result has type StringCOnstructChar s1
19:13:51 <mtnviewmark> we're the on-line automated debugger for Haskell
19:14:05 <heatsink> Then it sees the call to cons, which has type (StirngConstructChar s2) -> s2 -> s2
19:14:10 <kadoban> you're automated?  damn, and i'm sitting here typing manually :(
19:14:52 <joe6> Cale: return (Parser Bank x) => Not in scope: data constructor `Parser'
19:15:04 <heatsink> Since (toMainChar c) is the first parameter of cons, it must also have type StringConstructChar s2
19:15:07 <joe6> test :: Parser (Parser Bank)
19:15:31 <heatsink> So (toMainChar c) has two types.  The first is (StringConstructChar s1) and the second is (StirngConstructChar s2). 
19:15:34 <joe6> test = do {x <- bank; return (Parser Bank x)}
19:16:15 <mtnviewmark> when you type gdb on a Haskell compiled executable, it opens an IRC client the #haskell
19:16:34 <kmc> ghc -fvia-stack-overflow
19:16:48 <shachaf> @quote to.oleg
19:16:49 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
19:18:43 <heatsink> sshc: However, nothing else is there to help GHC determine what type s1 is.  Since it can't figure out the type of s1, it can't figure out the type of StringConstructChar s1.  So it can't decide whether StringConstructChar s1 is the same as StringConstructChar s2.
19:19:07 <sshc> heatsink: How do I tell GHC that they are the same?
19:19:25 <heatsink> sshc: Perhaps you want data families rather than type families.  What are StringConstructChar and StringConstructAltChar?
19:19:38 <sshc> heatsink: Also, since (StringConstructChar s1) is the result of a typeclass, shouldn't GHC be able to infer that?
19:19:54 <sshc> heatsink: For Bytestrings, StringConstructChar is Word8 and AltChar is Char
19:19:59 <sshc> heatsink: for Strings, they're both Char
19:23:14 <heatsink> I'm guessing that whenever there is a call to toMainChar or toAltChar, the caller knows the desired string type
19:23:27 <heatsink> In that case, add a parameter of type 's' to both those functions
19:25:16 <sshc> heatsink: To which functions?
19:25:42 <heatsink> In general, if there are values of type T a for some type family T, you also need values that aren't wrapped in T constructors so that GHC can infer what type a is.
19:25:52 <heatsink> sshc: toMainChar and toAltChar
19:26:52 * Eduard_Munteanu has a neon lamp in the room which looks like it's failing.
19:33:30 <sshc> heatsink: Adding a parameter of type 's' works!
19:33:36 <sshc> heatsink: Thanks for your help!
19:33:52 <sshc> (Even if it is a bit... unclean / unelegant)
19:33:55 <heatsink> np
19:34:02 <heatsink> :t nullPtr
19:34:03 <lambdabot> Not in scope: `nullPtr'
19:34:30 <heatsink> :t sizeOf
19:34:31 <lambdabot> Not in scope: `sizeOf'
19:34:47 <heatsink> :t typeOf
19:34:47 <lambdabot> forall a. (Typeable a) => a -> TypeRep
19:34:55 <heatsink> There you go.  Unused parameter.
19:35:33 <heatsink> > typeOf (undefined :: [IO a -> IO b])
19:35:34 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:35:34 <lambdabot>    `Data.Typeable.Typeable a...
19:35:44 <heatsink> > typeOf (undefined :: [IO Int -> IO Handle])
19:35:44 <lambdabot>   Not in scope: type constructor or class `Handle'
19:35:52 <heatsink> > typeOf (undefined :: [IO Int -> IO ()])
19:35:53 <lambdabot>   [IO Int -> IO ()]
19:44:29 <sshc> > typeOf (undefined :: Integer)
19:44:30 <lambdabot>   Integer
19:44:56 <sshc> What extension is needed to support signatures that contain "forall foobar."?
19:45:08 <heatsink> ScopedTypeVariables
19:46:53 <afilatun> hi, I'm looking at http://www.haskell.org/haskellwiki/99_questions/Solutions/3 and I was wondering why in the last solution we have to use a tuple to represent the list?
19:46:58 <sshc> Thanks
19:47:48 <heatsink> Where do you see a tuple?
19:49:31 <afilatun> heatsink : the parentheses aren't use only for the tuples?
19:49:43 <applicative> afiltun, the : is not the same as ,
19:49:48 <heatsink> Parentheses are also used for enforcing precedence
19:50:02 <sbahra> :t (1:2:[])
19:50:03 <lambdabot> forall t. (Num t) => [t]
19:50:12 <sbahra> :t (1,2,3)
19:50:13 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1, t2)
19:50:16 <afilatun> heatsink : mmm ok, I don't know what is "enforcing precedence"
19:50:27 <applicative> > let a = "a" in 'a':a
19:50:27 <lambdabot>   "aa"
19:50:29 <heatsink> > (1 + 2) * 3
19:50:30 <lambdabot>   9
19:50:33 <heatsink> > 1 + (2 * 3)
19:50:34 <lambdabot>   7
19:50:36 <sbahra> Associativity and precedence.
19:50:37 <applicative> > let a = "a" in ('a':a)
19:50:38 <lambdabot>   "aa"
19:50:47 <applicative> > let a = "a" in ('a',a)
19:50:48 <lambdabot>   ('a',"a")
19:51:23 <afilatun> k, so when exactly should I use parenthses instead of [ ]
19:51:46 <heatsink> afilatun, never.  That's not what parentheses are for
19:52:02 <afilatun> like in my example, I was using [x:xs], why did it failed and why does (x:xs) works?
19:52:25 <afilatun> I ashamed of myself, I tough I understoof the lists as a whole in haskell :P
19:52:33 <afilatun> understood*
19:52:33 <Cale> [x:xs] means a one element list whose only element is x:xs
19:52:35 <applicative> [] and [,,,,] are for lists, (,,,) is for 'tuples'  but otherwise we use (foo bar) just to keep foo bar together
19:52:46 <heatsink> The colon is one way to make a list.  The [] are an alternative way to make a list.
19:52:50 <heatsink> > [x, y]
19:52:51 <lambdabot>   [x,y]
19:52:54 <heatsink> > x : [y]
19:52:55 <lambdabot>   [x,y]
19:52:57 <heatsink> > x : y : []
19:52:58 <lambdabot>   [x,y]
19:53:02 <heatsink> > x : (y : [])
19:53:03 <lambdabot>   [x,y]
19:53:10 <heatsink> > (x : (y : []))
19:53:11 <lambdabot>   [x,y]
19:53:34 <Cale> > [1 : [2,3,4]]
19:53:35 <lambdabot>   [[1,2,3,4]]
19:53:39 <xcthulhu> > foldr [] : [x,y]
19:53:40 <lambdabot>   Couldn't match expected type `a -> b -> b'
19:53:40 <lambdabot>         against inferred type `[...
19:53:44 <sbahra> afilatun: Remember that (,) is a special operator as well.
19:53:46 <sbahra> :t (,)
19:53:47 <Cale> > (1 : [2,3,4])
19:53:48 <lambdabot>   [1,2,3,4]
19:53:48 <lambdabot> forall a b. a -> b -> (a, b)
19:53:48 <xcthulhu> > foldr : [] [x,y]
19:53:49 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]
19:53:50 <lambdabot>                         ...
19:53:56 <sbahra> > (,) 1 2
19:53:58 <lambdabot>   (1,2)
19:54:04 <afilatun> ok I think I get it
19:54:08 <afilatun> thanks a lot
19:54:19 <xcthulhu> > foldr : [] [1,2]
19:54:20 <lambdabot>   Couldn't match expected type `[t]
19:54:20 <lambdabot>                                -> [(a -> ...
19:56:12 <bobtheterminator> hey everybody, I have a main function that's mostly a bunch of statements like this: window <- xmlGetWidget xml castToWindow "mainWindow" and I'm getting a bunch of errors like this:  No instance for (gtk-0.10.1:Graphics.UI.Gtk.Types.WidgetClassWindow)       arising from a use of `xmlGetWidget'
19:56:24 <bobtheterminator> any idea why this is happening?
19:56:41 <applicative> grrrrrr
19:57:35 <heatsink> > let def = const
19:57:36 <lambdabot>   not an expression: `let def = const'
19:57:45 <heatsink> @help let
19:57:45 <lambdabot> let <x> = <e>. Add a binding
19:57:50 <heatsink> @let def = const
19:57:52 <lambdabot>  Defined.
19:57:58 <heatsink> > def mempty(): return []
19:57:59 <lambdabot>   [[],[]]
20:01:21 <joe6> is there a better way to get the Right value out: case memstructure of Right xs -> print (show xs)
20:01:41 <heatsink> What do you do with Left?
20:01:47 <joe6> ignore it.
20:02:10 <joe6> i just want  the right value as I am doing something from the ghci prompt
20:02:15 <twaffle> what's parsec's equivalent of Prelude's lex function?
20:02:23 <heatsink> I think there's a fromRight in Data.Either
20:02:27 <joe6> I could do the case statement above , but just curious if there is a better way.
20:02:32 <applicative> @type either
20:02:33 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:02:33 <joe6> thanks. that could help
20:02:49 <applicative> @type fromRight
20:02:50 <lambdabot> Not in scope: `fromRight'
20:02:53 <heatsink> There's not, but you could just define it.
20:03:37 <Cale> Or even  let Right xs = memstructure
20:03:47 <joe6> > rights
20:03:48 <lambdabot>   Overlapping instances for GHC.Show.Show
20:03:48 <lambdabot>                              ([Data...
20:03:56 <joe6> @type rights
20:03:57 <lambdabot> forall a b. [Either a b] -> [b]
20:04:10 <applicative> @type lefts
20:04:11 <lambdabot> forall a b. [Either a b] -> [a]
20:04:24 <heatsink> @type wrongs
20:04:25 <lambdabot> Not in scope: `wrongs'
20:04:49 <applicative> whats the one with both ([a],[b])
20:04:55 <heatsink> partitionEithers
20:05:22 <applicative> @type partitionEithers
20:05:23 <lambdabot> forall a b. [Either a b] -> ([a], [b])
20:06:03 <applicative> > partitionEithers [Right 1, Left "Hahaa", Right 5, Left "The horror!"]
20:06:04 <lambdabot>   (["Hahaa","The horror!"],[1,5])
20:06:44 <joe6> > concat $ rights [memstructure]
20:06:45 <lambdabot>   Not in scope: `memstructure'
20:06:59 <joe6> > concat $ rights [Either a b]
20:07:00 <afilatun> is it me or talking about cons (reconses) in haskell makes no sense : http://www.haskell.org/haskellwiki/99_questions/Solutions/5 
20:07:00 <lambdabot>   Not in scope: data constructor `Either'
20:07:12 <afilatun> (I know it's based on lisp questions)
20:09:13 <heatsink> Instead of answering that question, I will point out that "cons" is short for "construct".  The (:) operator constructs a list from the given head and tail.
20:09:19 <applicative> afilatun, : is often called cons.   x : xs, can be read, by a haskeller as x cons xs
20:09:40 <afilatun> ha, I didn't know that, thanks
20:09:46 <haskeller> yes, i can read that.
20:09:53 <afilatun> :)
20:10:00 <applicative> this is how Peyton Jones pronounces (:) in one of those tutorial videos, for example
20:10:34 <afilatun> me reading Land of Lisp while also learning haskell got me confused :P
20:10:44 <haskeller> oh yes, Peyton Jones can read that too.
20:11:49 <applicative> afilatun, 'cons' and 'uncons' are often used in so many letters in ByteString libraries, but just there the Lisp connection gets more remote.
20:12:11 <haskeller> doubt spj can read Brainfuck, though
20:12:26 <bobtheterminator> does anybody see anything wrong with this code? http://hpaste.org/42107/whats_wrong
20:15:44 <afilatun> let say I have this : isPalindrome :: (Eq a) => [a] -> Bool
20:15:54 <afilatun> what does (Eq a) give me?
20:16:04 <afilatun> or what does it do?
20:16:18 <haskeller> you can compare whatever a is
20:16:22 <applicative> it makes our function apply to anything that has an Eq instance, not just chars
20:16:32 <heatsink> You can check whether values of type 'a' are equal using the (==) function, or not equal using the (/=) function.
20:16:52 <afilatun> ok, my question is a bit more general, what are instances?
20:17:03 <applicative> @instance Eq
20:17:03 <lambdabot> Maybe you meant: instances instances-importing
20:17:07 <applicative> @instances Eq
20:17:07 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
20:17:26 <applicative> ^^^ are the inbuilt types that support == and /=
20:17:32 <afilatun> mmm, is it some sort of library?
20:17:46 <afilatun> or (scuse me for the OO parralel) some sort of class?
20:18:00 <applicative> Data.Eq defines them
20:18:22 <blackdog> afilatun: no. that'll give you entirely the wrong mental image.
20:18:32 <applicative> afilatun, the comparison with OO classes is very remote and immediated we are told to put it out of our minds
20:18:42 <afilatun> ok, it's forgotten :P
20:18:51 <blackdog> it's a much more static thing - if you needed an OO metaphor, it'd be more like an implementation of an interface. but even that's wrong.
20:19:06 <afilatun> but why do I need to add it to my class?
20:19:15 <afilatun> (I was trying to use == on two list in it)
20:19:18 <applicative> you mean to your function definition?
20:19:21 <afilatun> yes
20:19:33 <afilatun> (sorry it's late)
20:19:36 <applicative> if you just want to decide about strings, you dont
20:19:49 <applicative> isPalindrome :: String -> Bool
20:20:16 <afilatun> ok but I wanted it like isPalindrome :: [a] -> Bool
20:20:19 <applicative> and then your definition could use things like x `elem` "abcdefghijklmnop"
20:20:29 <applicative> right, then you want something general
20:20:43 <applicative> but do you want to decide whether a list of functions is a palindrome?
20:20:47 <applicative> good luck!
20:21:06 <applicative> so you decide for all things where == and /make sense.  
20:21:09 <afilatun> haha, that's a problem of the 99 questions on haskell.org
20:21:19 <afilatun> but yeah a list of function would be problematic
20:21:26 <applicative> defining isPalindrome :: [a] -> Bool would be hopeless
20:21:35 <afilatun> http://www.haskell.org/haskellwiki/99_questions/Solutions/6
20:22:00 <applicative> you can define functions that apply to lists of functions too, like
20:22:01 <afilatun> anyway thanks a lot, I'm going to bed
20:22:05 <applicative> @type reverse
20:22:06 <lambdabot> forall a. [a] -> [a]
20:22:13 <bobtheterminator> somebody may have already answered this, but does anybody see anything wrong with this? http://hpaste.org/42107/whats_wrong
20:22:15 <applicative> ^^^ look no restriction
20:22:29 <copumpkin> bobtheterminator: I'm sure GHC found something wrong with it
20:22:32 <copumpkin> it'd help us to know that
20:22:38 <bobtheterminator> right
20:22:59 <bobtheterminator> it was a bunch of this type of error: No instance for (gtk-0.10.1:Graphics.UI.Gtk.Types.WidgetClass                        Window)       arising from a use of `xmlGetWidget'
20:23:02 <applicative> bobtheterminator, looks like the gtk2hs crowd is not out in its usual force tonight
20:23:08 <joe6> can I do pattern matching on Either:? bankstructure :: Int -> Either ParseError [Bank] -> Bank; bankstructure 0 (Either ParseError xs) = head xs
20:23:20 <joe6> i am getting an error when I try the above?
20:23:30 <applicative> so you need to make Window an instance of WidgetClass.  
20:23:40 <copumpkin> bobtheterminator: maybe you need to import another module that has the WidgetClass for Window in it?
20:23:45 <applicative> bobtheterminator, I wonder if you're failing to import... 
20:23:53 <applicative> @quote fugue
20:23:53 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:23:53 <copumpkin> not sure where it is as I've never used gtk
20:23:57 <copumpkin> lol
20:24:25 <bobtheterminator> I imported Graphics.UI.Gtk and Graphics.UI.Gtk.Glade, which are the only two modules that are ever imported in any examples I've seen
20:24:51 <bobtheterminator> here's a random example: http://refactormycode.com/codes/1381-haskell-walpaper-slide
20:24:54 <applicative> its in the RWH examples, it seems to me.  Have you looked at the source for them
20:24:58 <bobtheterminator> I don't see the difference between their code and mine
20:25:29 <applicative> that site really does refactor...
20:26:28 <applicative> bobtheterminator does that module compile for you?  There have been developments in gtk2hs.  I couldn't get it to hook up with the C libraries last I tried
20:26:44 <applicative> bobtheterminator, i mean, the module you linked
20:26:44 <Cale> bobtheterminator: There are tab characters in this code
20:26:57 <adu> o noes
20:27:01 <Cale> bobtheterminator: You should reconfigure your editor to expand them to spaces
20:27:06 * adu </3 tabs
20:27:29 <joe6> bankstructure 0 memstructure = head xs where Right xs = memstructure
20:27:31 <joe6> bankstructure 2 memstructure = head $ tail xs where Right xs = memstructure
20:27:53 <joe6> any thoughts on how I can combine the above where clauses?
20:27:56 <applicative> Not ..... TABS...!!!
20:28:06 <joe6> probably use case, I guess? any other suggestions?
20:28:13 <Cale> joe6: use pattern matching on the left?
20:28:31 <Cale> (so that you don't need the where clauses at all)
20:28:37 <bobtheterminator> @applicative honestly I don't know how to check...
20:28:38 <lambdabot> Unknown command, try @list
20:28:39 <joe6> Cale: I tried pattern matching on eIther but am not getting it right.
20:28:46 <Cale> bankstructure 0 (Right (x:xs)) = x
20:28:51 <applicative> joe, doesn't that seem like you're inviting errors, what if it's Left, what if it's Right, but has no head
20:28:54 <Cale> bankstructure 2 (Right (x:y:xs)) = y
20:29:05 <hristoasenov> hey, does anyone happen to know what algorithm the pidigits benchmark from shootout is based on?
20:29:15 * applicative notes that Cale approves, so he drops it
20:29:36 <joe6> applicative: it is a pretty specific scenario. I am just putting together some helper functions that I can run from ghci
20:29:51 <hristoasenov> here is the link: http://www.haskell.org/haskellwiki/Shootout/Pidigits#Current_Entry
20:29:51 <joe6> when I am looking through the data that I want to look at.
20:29:55 <Eduard_Munteanu> afilatun: [x:xs] is a list of lists.
20:30:02 <Cale> Well, that also makes it easier to fill in the other cases
20:30:05 <Eduard_Munteanu> Oh crap, I was scrolled up, sorry.
20:30:14 <bobtheterminator> applicative: how would I check whether the module compiles?
20:30:24 <joe6> Cale: Thanks a lot for your help.
20:30:45 <joe6> the code looks so much simpler in the hands of an expert.
20:31:52 <kadoban> hristoasenov: http://shootout.alioth.debian.org/u64/performance.php?test=pidigits  at the very bottom here it links to a description of the algorithm
20:35:12 <hristoasenov> kadoban: oh cool, thanks!
20:35:22 <kadoban> np
20:36:41 <applicative> bobtheterminator I was just thinking save the wallpaper file and open it in ghci, for example, and see if it gives errors like yours
20:38:55 <applicative> bobtheterminator try adding import Graphics.UI.Gtk.Abstract.Widget to your file. that's where Widget is put under WindowClass or whatever
20:39:04 <applicative> its a chs module, so i'm out of my depth.
20:39:48 <applicative> bobtheterminator http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Abstract-Widget.html
20:40:39 <applicative> bobtheterminator it may be that there is a different import scheme inside gtk2hs now than with the models youre following
20:41:19 <applicative> the cabal file says Graphics.UI.Gtk.Abstract.Widget is "exposed" by the library.
20:42:40 <applicative> but it seems it was exposed in the past too, so who knows.
20:42:45 <monochrom> hrm if you "import Graphics.UI.Gtk", that's included already
20:43:18 <applicative> monochrom is here.  ... his error says he doesn't have an instance declared there
20:44:00 <applicative> but he has import Graphics.UI.Gtk
20:44:00 <applicative> import Graphics.UI.Gtk.Glade
20:44:18 <applicative> uh oh we've lost him....
20:46:41 <applicative> monochrom, i think i get it, the error was No instance for (gtk-0.10.1:Graphics.UI.Gtk.Types.WidgetClass Window) arising from a use of `xmlGetWidget'
20:47:09 <applicative> monochrom, but this is an ancient gtk, I think, maybe it was different. 
20:47:28 <monochrom> 0.10.1 is quite dated! we're now at 0.12.0
20:49:09 * applicative just realized that when library writers boldly break the API and we complain about all the existing code that is broken, we should also complain about all the tutorials that are broken....
20:50:27 <monochrom> no, I think he is trying modern tutorial examples on ancient lib version.
20:51:02 <applicative> yes, maybe.  anyway, if he comes back, we have possible account of the difficulty.
20:53:55 <applicative> bobtheterminator?
20:54:37 * monochrom installs the glade part to try it
20:54:37 <bobtheterminator> yes?
20:54:56 <monochrom> slow virtual machine is slow :)
20:54:58 <bobtheterminator> sorry, did I miss something you told me?
20:55:37 <applicative> yeah, one thing we noticed isyoure using an old gtk2hs.  i annotated your hpaste post about it.  i'm not sure if it contains the answer
20:55:42 <monochrom> the gold linker may be quite a must-have for slow small virtual machine
20:56:28 <applicative> bobtheterminator i'm very error prone in general, so i can't give sound advice when i can't test against the compiler, as in this case.
20:57:10 <monochrom> loads fine in ghci (no type error) with gtk2hs version 0.12.0
20:57:35 <bobtheterminator> well, I tried cabal install glib, and I got this error: /tmp/glib-0.12.014193/glib-0.12.0/Gtk2HsSetup.hs:56:2:     Module     `Distribution.Simple.PackageIndex'     does not export     `lookupPackageId' 
20:57:51 <ManateeLazyCat> I got a offer from "Jane Street" (http://janestreet.com/), anyone heard this company? How about it?
20:57:52 <applicative> rrrrrrrrrrrrrrrrrrrrrrrrrr  this is my kind of trouble....
20:58:08 <applicative> hahah, of course
20:58:14 <applicative> congrats
20:58:16 <monochrom> you probably have ancient cabal etc too
20:58:28 <applicative> does that mean you're moving to New York?  
20:58:57 <ManateeLazyCat> applicative: They invite me to first round of phone interviews
20:58:57 <applicative> ManateeLazyCat, they are of course much more well known in the ocaml world. 
20:58:58 <bobtheterminator> and cabal install gtk fails because glib won't install
20:59:25 <ManateeLazyCat> bobtheterminator: "cabal install gtk2hs-buildtools glib gio pango cairo gtk"
20:59:35 <ManateeLazyCat> bobtheterminator: And make sure ~/.cabal/bin in your path.
20:59:55 <copumpkin> ManateeLazyCat: they're well known
21:00:02 <ManateeLazyCat> applicative: How about "Jane Street"? I never heard this company. :)
21:00:03 <copumpkin> ManateeLazyCat: you should read up about them before interviewing ;P
21:00:12 <ManateeLazyCat> applicative: If everything work, i perhaps goto Hong Kong.
21:00:13 <applicative> haha, bobtheterminator, ManateeLazyCat is a gtk2hs developer
21:00:22 <monochrom> oh ManateeLazyCat, I have a gtk2hs example at http://www.vex.net/~trebla/haskell/gtk-interact.xhtml :)
21:00:27 <applicative> others would know more, i've just heard of them
21:00:34 <copumpkin> ManateeLazyCat: do you have a program that translates spoken chinese to english live for the interview?
21:00:36 <copumpkin> :P
21:01:03 <applicative> in fact, whenever i use gmail and mention haskell, there's an ad "Do you think in closures" and I think, maybe but I don't call them that
21:01:05 <ManateeLazyCat> copumpkin: Yes, translate Chinese to English, then use festival read English.
21:01:50 <ManateeLazyCat> copumpkin: But i think best talk Chinese. ;p
21:02:00 <ManateeLazyCat> copumpkin: Since the have office at Hong Kong.
21:02:04 <copumpkin> oh okay
21:02:04 <kmc> ManateeLazyCat, i think finance is not a great industry for programmers
21:02:18 <applicative> Oh that's good, someone knows CHinese, surely
21:02:35 <kmc> and i don't care enough about choice of language to go back to finance for Haskell, let alone OCaml
21:02:35 <joe6> finance: a lot more money but sucks from a programming perspective.
21:02:43 <joe6> most of the code is cookie-cutter. 
21:02:50 <kmc> anyway if you want to ask me questions about programming in finance, i'm in #haskell-blah
21:02:51 <copumpkin> depends what kind of company!
21:02:55 <joe6> managers are not prepared to take any IT risks
21:02:58 * applicative agrees, kmc is probably right, but is more worried that ManateeLazyCat will move over to ocaml
21:02:58 <ManateeLazyCat> kmc: They said "they need Haskell programmer". :)
21:03:01 <kmc> yep, some of them don't pay a lot more money
21:03:16 <kmc> some of them just promise you that money and fail to deliver
21:03:21 <copumpkin> lol
21:03:25 <copumpkin> kmc: you sound rather bitter :)
21:03:28 <kmc> :)
21:03:31 <applicative> kmc, is this said of Jane Street?
21:03:38 <kmc> i have no knowledge of Jane St in this regard
21:03:41 <kmc> i speak generally
21:03:50 <kmc> and it's off topic ;P
21:03:51 <joe6> if they are not paying you good money, then you are being screwed, atleast in the financial industry.
21:04:03 <applicative> from the little I know, they are completely unique and strange
21:04:18 <ManateeLazyCat> I just want find a "haskell job" to support my project, that's all.
21:04:56 <applicative> i favor it on condition that you can do honor to our excellent language
21:04:58 <ManateeLazyCat> And i have a baby will born at 2011, and job is important for me. :)
21:05:09 <kmc> congratulations on spawning
21:05:27 <ManateeLazyCat> kmc: Thanks. :)
21:05:27 <joe6> can't take a risk with a baby on the way.
21:05:35 <monochrom> unsafeForkIOCat
21:05:37 <joe6> good luck..
21:05:49 <applicative> right, head to the countryside, emulate the peasantry...
21:05:53 <copumpkin> if I have a data Iteratee i a = Done (Maybe i) a | More (i -> Iteratee i a)
21:06:00 <copumpkin> is (Iteratee i) a Monad?
21:06:05 <copumpkin> or even an Applicative?
21:06:18 <applicative> in a, hmmm
21:06:18 <monochrom> I seem to have seen it is.
21:06:22 <gwern> ask the monad laws
21:06:42 <copumpkin> well, my main puzzlement is with the <*>
21:06:45 <bobtheterminator> gah, irc keeps failing
21:06:46 <bobtheterminator> does anybody know why cabal install glib would fail with /tmp/glib-0.12.014193/glib-0.12.0/Gtk2HsSetup.hs:56:2:     Module     `Distribution.Simple.PackageIndex'     does not export     `lookupPackageId'  ?
21:06:51 <copumpkin> if I have two Dones
21:06:52 <applicative> do the monad laws speak, like the Laws of Athens in the Crito?
21:07:10 <ManateeLazyCat> monochrom: Great, nice code. :)
21:07:15 <danblick> applicative: they do, if you listen
21:07:29 <ManateeLazyCat> bobtheterminator: Upgrade your cabal
21:07:34 <ManateeLazyCat> bobtheterminator: Your cabal is too old.
21:07:37 <monochrom> I just know that applicative does speak :)
21:08:09 <monochrom> in fact I'm curious about the ghc version too.
21:08:11 <copumpkin>   Done i f <*> Done j x = Done ? $ f x
21:08:17 <copumpkin> that question mark is the problem
21:08:39 <applicative> if fmap obvious>
21:08:46 <copumpkin> yeah
21:08:49 <applicative> yeah
21:09:20 <copumpkin> I just don't know what to do with the case when both of the leftovers are Justs
21:09:32 <copumpkin> and discarding one feels wrong
21:09:37 <ManateeLazyCat> applicative: Yes, i found "Jane Street" from Google's ads. :)
21:09:49 <monochrom> @src ap
21:09:50 <lambdabot> ap = liftM2 id
21:10:10 <monochrom> @src liftM2
21:10:10 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:10:16 <ManateeLazyCat> kmc: Do you have any better company let me know?
21:11:10 <copumpkin> it seems like I'd need Done [i] a or something
21:11:21 <copumpkin> and would need to stick the two leftover elements into there
21:13:06 <jburka> hey everybody, I'm bobtheterminator, but browser based irc was failing
21:13:10 <danblick> wow, i'm very impressed with the number of hackage packages right now.
21:13:55 <jburka> did anybody have any advice on why cabal install glib was failing?
21:14:03 <jburka> because cabal 1.8.0.6 is definitely not too old
21:14:48 <monochrom> "cabal --version" ?
21:15:22 <jburka> cabal-install version 0.8.2 using version 1.8.0.6 of the Cabal library 
21:15:24 <ManateeLazyCat> jburka: Like monochrom said, check cabal version first.
21:15:38 <monochrom> "ghc --version"?
21:15:40 <jburka> is 1.8.0.6 really too old, or could there be another problem
21:15:53 <jburka> The Glorious Glasgow Haskell Compilation System, version 6.10.4
21:16:01 <monochrom> I'm afraid that is a problem.
21:16:07 <jburka> blast
21:16:08 <jburka> alright
21:16:17 <ManateeLazyCat> jburka: We suggest use 6.12.3 for gtk2hs now.
21:16:35 <ManateeLazyCat> jburka: ghc-7 also can work, but ghc-7 still have bug.
21:17:20 <jburka> do i need to reinstall the whole haskell platform, or just update ghc?
21:17:47 <ManateeLazyCat> jburka: Best reinstall newest haskell platform, less problem. :)
21:19:27 <jburka> haskell-platform won't install because the dependency ghc6 (>= 6.12.1) is not satisfied
21:19:35 <jburka> sooooo should i just upgrade ghc first?
21:19:55 <Eduard_Munteanu> No
21:20:06 <Eduard_Munteanu> The Platform includes GHC.
21:20:22 <monochrom> that is not always true
21:20:29 <jburka> i downloaded the package and it won't install because of that dependency issue
21:20:33 <jburka> is the package not the right way to do it?
21:20:46 <ManateeLazyCat> applicative: "Jane Street" for ocaml like Galois for Haskell?
21:20:49 <Eduard_Munteanu> jburka: by installing a new platform we mean getting the binary version torrent and downloading it
21:21:01 <jburka> oh ok
21:21:10 <monochrom> no, please exclude me from that "we"
21:21:10 <ManateeLazyCat> jburka: reinstall everything
21:21:25 <Eduard_Munteanu> jburka: is this Windows?
21:21:30 <jburka> no, linux mint
21:21:38 <mtnviewmark> http://hackage.haskell.org/platform/
21:21:48 <ManateeLazyCat> monochrom: If you want, i can add your program in gtk2hs demo. :)
21:21:49 <Eduard_Munteanu> Does it have distro packages for the platform?
21:22:02 <Eduard_Munteanu> monochrom has a point, I was thinking about Windows.
21:22:07 <mtnviewmark> http://hackage.haskell.org/platform/linux.html
21:22:23 <monochrom> I would be more like http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
21:22:24 <jburka> yeah, i'm there
21:22:25 <copumpkin> nobody knows about those iteratees?
21:22:27 <jburka> "You need GHC 6.12.3 installed before building the platform. You can get this from your distro or you can get a GHC 6.12.3 generic binary."
21:22:37 <Eduard_Munteanu> monochrom: lol, why?
21:22:39 <jburka> doesn't that mean i need to do ghc individually before i get the platform?
21:22:45 <mtnviewmark> jburka - that is if you are building the HP from source
21:22:56 <mtnviewmark> many distros have the HP already built as an installable package
21:23:00 <mtnviewmark> you just install it
21:23:04 <monochrom> on linux there is much benefit in building the platform from source
21:23:07 <mtnviewmark> with your standard pcakge manager
21:23:22 <jburka> well i don't know how to "just install it", because downloading the package doesn't work
21:23:30 <jburka> so i guess i'll build from source
21:23:32 <Enigmagic> copumpkin: the Data.Iteratee package or something else?
21:23:33 <mtnviewmark> what distro are you running?
21:23:33 <monochrom> more precisely, on linux there is much benefit in forgetting about the distro
21:23:45 <jburka> linux mint 
21:23:49 <Eduard_Munteanu> Yeah, possibly.
21:24:08 <Eduard_Munteanu> Would you say the same about Gentoo?
21:24:17 <copumpkin> Enigmagic: a simple reimplementation of them, avoiding all the cruft from making them monadic and stuff
21:24:46 <mtnviewmark> aha -- okay so, your linux package manager should already all the Ubunu packages, 
21:24:50 <monochrom> there are problematic interleavings of "apt-get install" and "cabal install".
21:24:52 <mtnviewmark> one of which IS Haskell Platform
21:25:00 <Enigmagic> copumpkin: ok... so what do you want to know? too much scrollback to read through 
21:25:07 <copumpkin> data Iteratee i a = Done (Maybe i) a | More (i -> Iteratee i a)
21:25:10 <copumpkin> is that valid?
21:25:19 <jburka> mtnviewmark: it doesn't
21:25:20 <copumpkin> namely, what to do when implementing <*> for Applicative?
21:25:24 <monochrom> All linux distros will have the same problem.
21:25:24 <copumpkin> on the Done <*> Done case
21:25:56 <ManateeLazyCat> lambdabot will down everyday?
21:26:12 <ManateeLazyCat> I use lambabot keep topic on ##manatee . :)
21:26:18 <mtnviewmark> jburka - don't know then, not really familiar with mint
21:26:27 <monochrom> Here is the deal: unless you chase dependencies yourself, the only safe way to use linux distro's ghc-related packages is to never "cabal install".
21:26:29 <Eduard_Munteanu> monochrom: idk, so far I've been doing well with getting as many packages as I can from the distro and cabal-installing the rest user-local.
21:26:43 <monochrom> But I know.
21:26:56 <Eduard_Munteanu> :)
21:27:20 <Enigmagic> copumpkin: where does the source data stream hook up?
21:27:22 <jburka> are you saying i should never use cabal install, or just that it could cause problems
21:27:26 <jburka> because I really like cabal install
21:27:46 <Eduard_Munteanu> Admittedly I did have to unmask keyword a few ebuilds to make some stuff work.
21:27:56 <blackdog> jburka: it's not safe to mix, usually. i tend to go all cabal...
21:27:59 <mtnviewmark> so, you need to get GHC 6.12.3 binary --- then, go here: http://haskell.org/ghc/download_ghc_6_12_3
21:28:02 <Enigmagic> copumpkin: or, what is the type of a? :)
21:28:03 <copumpkin> Enigmagic: I'm avoiding talking about chunks or streams, if that's what you're asking. I feed it elements one at a time
21:28:07 <monochrom> My http://www.vex.net/~trebla/haskell/sicp.xhtml already has an example problem for ghc 6.12.1 due to a bug. But even without that bug there is another problem.
21:28:29 <mtnviewmark> once you get that - THEN you can download the Haskell Platform source package and build and install that
21:28:30 <Enigmagic> copumpkin: that was my question.. what problem are you trying to solve?
21:29:22 <copumpkin> Enigmagic: to simplify the idea down to something very basic, as it seems overcomplicated by ideas of error recovery/messages, monadic behavior within the iteratee, and so on
21:29:41 <copumpkin> it feels like it _should_ just be a very simple free monad
21:29:47 <Enigmagic> copumpkin: have you looked at the enumerator package?
21:29:53 <copumpkin> but the leftover data is mucking it up
21:30:01 <copumpkin> yeah, even that is fairly overcomplicated by practical issues
21:30:37 <jburka> mtnviewmark: will i have to do stuff in the terminal to install ghc from source?
21:30:50 <Enigmagic> (i haven't used enumerator, but i do use iteratee)
21:31:45 <mtnviewmark> from source? I don't think you need to do that --- that page I pointed to has pre-built binary versions of GHC for linux
21:32:08 <jburka> i am so linux incompetent
21:32:11 <ManateeLazyCat> jburka: I give you complete step, wait.
21:32:13 <Enigmagic> copumpkin: so in your Iteratee type... what type is 'a' supposed to be?
21:32:15 <jburka> so what do i do with it once it downloads?
21:32:23 <copumpkin> Enigmagic: return type, and i is the element type
21:32:42 <ManateeLazyCat> jburka: First download ghc-6.12.3 from http://haskell.org/ghc/download_ghc_6_12_3
21:32:55 <monochrom> copumpkin is asking: is (Iteratee i) an Applicative? a Monad?
21:33:01 <ManateeLazyCat> jburka: And uncompress it do command : ./configure && sudo make install
21:33:07 <ManateeLazyCat> jburka: Then ghc is install complete.
21:33:16 <jburka> ok, thats the step i was missing
21:33:23 <jburka> i got it from there
21:33:23 <copumpkin> I feel like right now I'd need something like Monoid i => Monad (Iteratee i)
21:33:26 <jburka> thanks very much everybody
21:33:29 <ManateeLazyCat> jburka: Then 
21:33:32 <mtnviewmark> jburka - perhaps then it would be better for you to figure out how to get your GUI system package manager to include the more larger package repositories, like Ubuntus --
21:33:38 <ManateeLazyCat> jburka: Download cabal-install http://hackage.haskell.org/packages/archive/cabal-install/0.8.2/cabal-install-0.8.2.tar.gz
21:33:40 <mtnviewmark> because then you could install all this point-and-click
21:34:06 <ManateeLazyCat> jburka: uncompress cabal-install-0.8.2.tar.gz
21:34:18 <ManateeLazyCat> jburka: Have script "bootstrap.sh" in it.
21:34:35 <ManateeLazyCat> jburka: Just do "sudo chmod +x ./bootstrap.sh && ./bootstrap.sh"
21:34:43 <ManateeLazyCat> jburka: Then cabal is will install complete.
21:34:49 <jburka> mtnviewmark: ubuntus? it includes archive.ubuntu.com/main and such as repositories
21:35:19 <monochrom> ubuntu is still at ghc 6.12.1, has a nasty bug related to packages, don't use it.
21:35:19 <ManateeLazyCat> jburka: After that, just do "cabal update && cabal install gtk2hs-buildtools glib gio pango cairo gtk" will install newest gtk2hs in your system.
21:35:39 <jburka> ManateeLazyCat: sweet. thanks very much.
21:35:53 <ManateeLazyCat> jburka: Follow my step, i also use Ubuntu, but never install any haskell package from source (too old)
21:36:06 <monochrom> The nasty bug: you expect user packages to shadow global packages, yeah? but no, 6.12.1 uses package with bigger hash to shadow package with smaller hash.
21:36:22 <mtnviewmark> jburka - I think you need archive.ubuntu.com/universe    
21:36:27 <monochrom> My http://www.vex.net/~trebla/haskell/sicp.xhtml has a true story on this.
21:36:43 <ManateeLazyCat> jburka: Follow my step, it's simplest way to install gtk2hs
21:36:46 <jburka> mtnviewmark: I have that
21:37:02 <mtnviewmark> should be there: http://packages.ubuntu.com/search?keywords=haskell-platform
21:37:04 <ManateeLazyCat> Haskell platform is awesome, but many library in it is not unnecessary for gtk2hs
21:37:47 <medfly> not unnecessary?
21:37:48 <ManateeLazyCat> jburka: As Debian/Ubuntu user, i recommend you use cabal install haskell package instead from apt sources
21:38:02 <ManateeLazyCat> medfly: Just need ghc and cabal
21:38:03 <Enigmagic> copumpkin: i'm not very good with irc coding otherwise i'd try to help more :-/
21:38:23 <ManateeLazyCat> medfly: Oh, sorry typo
21:38:30 <ManateeLazyCat> medfly: is unnecessary
21:38:45 <ManateeLazyCat> medfly: Mind faster than finger. :)
21:38:50 * hackagebot doc-review 0.7.1 - Document review Web application, like http://book.realworldhaskell.org/  http://hackage.haskell.org/package/doc-review-0.7.1 (JoshHoyt)
21:40:18 <ManateeLazyCat> brb
21:41:09 <jburka> Thanks very much everybody for your help.
21:41:17 <jburka> this was a much better use of my time than economics homework
21:41:22 <monochrom> haha
21:41:45 <winxordie> Anyone know of any implementation of Hopcroft's minimization algorithm for finite state machines in Haskell? I'd prefer not to cook up one.
21:52:59 <lars9> ManateeLazyCat: hi there?
21:53:12 <ManateeLazyCat> lars9: Yes.
21:53:24 <ManateeLazyCat> lars9: I remember you're Chinese, right? ;p
21:53:54 <lars9> ManateeLazyCat: yeah, i'm in hong kong. do you know newsmth?
21:54:16 <ManateeLazyCat> lars9: Oh, nice to meet you. :)
21:54:30 <ManateeLazyCat> lars9: 水木？
21:54:37 <lars9> ppl are discussing about your manatee there: http://www.newsmth.net/bbsdoc.php?board=FuncProgram
21:54:40 <lars9> yep.
21:54:59 <ManateeLazyCat> lars9: Hehe, too busy haven't time see that. :)
21:55:27 <lars9> nvm, just in case you are interested
21:55:53 <ManateeLazyCat> lars9: It's not truth, i just a normal programmer, not like that. :)
21:56:56 <ManateeLazyCat> lars9: 现在项目才刚刚开始， 没你们说的那么强大。 :)
21:57:12 <lars9> that's one of the very few chinese forums about functional programming
21:57:51 <lars9> ManateeLazyCat: anyway, you are welcome to that forum.
22:01:27 <zuwiki> So I've read the "the procedure to uninstall a cabal package" is to run `ghc-pkg unregister pkg-id` "and then manually delete the files." Where are those files stored so that I may delete them?
22:01:56 <shachaf> ~/.cabal/lib
22:02:06 <shachaf> ~/.cabal/*, actually.
22:03:59 <zuwiki> Hm. So if I have uninstalled GHC and deleted /Library/Frameworks/HaskellPlatform.framework (this is on a mac) and completely removed ~/.cabal/ before installing a new GHC and HaskelPlatform2010, why does `cabal info pkgname` say that it is still installed?
22:04:47 <mtnviewmark> perhaps you missed ~/.ghc
22:05:06 <mtnviewmark> which is where the --user package database resides
22:05:46 <zuwiki> Aha!
22:06:27 <zuwiki> Thank you both, shachaf and mtnviewmark!
22:06:33 <mtnviewmark> :-)
22:07:50 <mtnviewmark> really, that procedure should be to first "ghc-pkg describe foo" - because that will list the locations of all the files you need to remove. Then remove those files, then "ghc-pkg unregister foo"
22:08:12 <shachaf> mtnviewmark: Is there a particular reason that's not automated?
22:08:43 <mtnviewmark> sigh.... no - just noone has written the "cabal uninstall" command yet...
22:08:55 <mtnviewmark> the mechanics are easy, what's hard is doing all the saftey checks (I think)
22:09:28 <shachaf> Really? That's silly.
22:09:30 <shachaf> What safety checks?
22:09:57 <mtnviewmark> you don't want to remove a package other packages depend on
22:10:33 <shachaf> mtnviewmark: If you unregister it, it should be equivalent, shouldn't it?
22:10:42 <mtnviewmark> there are some other things, like I don't think ALL the files that need to be removed are registered - so you have do some work there
22:11:14 <mtnviewmark> ? be equivalent to what?
22:11:36 <shachaf> mtnviewmark: To uninstalling, as far as other packages are concerned.
22:12:01 <mtnviewmark> right - but if you uninstall A and B is still installed and depends on it - now you have problems
22:12:22 <shachaf> mtnviewmark: Yes, but those problems should still show up if you just unregister the package. I would hope.
22:12:29 <mtnviewmark> yup - 
22:12:55 <mtnviewmark> but I don't know if ghc-pkg does those checks....
22:13:12 <shachaf> Ah, so ghc-pkg gets away with being a lower-level thing.
22:14:04 <mtnviewmark> somewhat 
22:15:08 <mtnviewmark> Cabal, cabal-install, and ghc-pkg are kind of like three witches working over the same cauldron
22:24:14 <jburka> everything is terrible forever
22:24:18 <jburka> upgrading ghc made my problem worse
22:30:23 <jburka> while i was upgrading my haskell package, cabal warned me that my version of base is too old
22:30:26 <jburka> how do i update that?
22:30:36 <Axman6> o.O
22:30:45 <Axman6> base gets installed with GHC, it's very ghc specific
22:31:04 <jburka> oh wait i have two versions of base installed
22:31:06 <jburka> what is this
22:31:19 <jburka> will that cause problems?
22:32:34 <kmc> it's typical to have base 3 and base 4
22:33:12 <jburka> oh ok, good
22:38:55 <gienah> maybe you could try and sed your "haskall package" .cabal file to change which base version it will accept, and see if it compiles
23:24:19 <sohum> \x y -> foo (bar y)
23:24:25 <sohum> @pl \x y -> foo (bar y)
23:24:25 <lambdabot> const (foo . bar)
23:25:39 <Twey> FeiRuoWa: Learning Haskell now?
23:27:24 <sohum> @pl \x y -> foo (bar y) x y
23:27:25 <lambdabot> join . flip (foo . bar)
23:27:52 <adnap_> Is there an existing function [(a,a)] -> [a], which essentially flattens a list of tuples?
23:28:45 <sipa> @pl \(a,a) -> [a,a]
23:28:45 <lambdabot> ap (:) return . snd
23:30:04 <adnap_> huh?
23:30:31 <adnap_> @pl \[(a,a)] -> [a]
23:30:31 <lambdabot> (line 1, column 2):
23:30:31 <lambdabot> unexpected "["
23:30:31 <lambdabot> expecting pattern
23:31:19 <sipa> pl isn't very good at handling lists
23:31:44 <sipa> but concatMap (ap (:) return . snd) would do what you need
23:32:35 <adnap_> >:t ap
23:32:38 <adnap_> :t ap
23:32:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:33:03 <sipa> oh what
23:33:07 <sipa> wait
23:33:23 <sipa> > (ap (:) return . snd) (1,2)
23:33:25 <lambdabot>   [2,2]
23:33:32 <sipa> not very right
23:34:23 <adnap_> > foldr (\(x, y) acc -> x:y:acc) [] [(1,2)]
23:34:25 <lambdabot>   [1,2]
23:34:26 <adnap_> :p
23:34:50 <adnap_> surely this has been done before
23:40:07 <shachaf> adnap_: That operation doesn't seem like a very common one.
23:40:48 <sipa> @pl [fst x,snd x]
23:40:48 <lambdabot> [fst x, snd x]
23:40:58 <sipa> @pl \x -> [fst x,snd x]
23:40:59 <lambdabot> liftM2 (:) fst (return . snd)
23:42:31 <sipa> @let { untuple [] = []; untuple ((a,b):c) = [a,b] ++ untuple c }
23:42:32 <lambdabot>  <local>:16:0: parse error on input `{'
23:42:36 <sipa> @let untuple [] = []; untuple ((a,b):c) = [a,b] ++ untuple c
23:42:38 <lambdabot>  Defined.
23:56:08 <sohum> @pl \x -> if f x then Just x else Nothing
23:56:09 <lambdabot> flip (liftM2 if' f Just) Nothing
23:56:25 <sipa> :t if'
23:56:27 <lambdabot> Not in scope: `if''
23:56:50 <c_wraith> @pl \b t f -> if b then t else f
23:56:50 <lambdabot> if'
23:56:58 <c_wraith> that should tell you what if' :)
