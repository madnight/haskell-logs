00:01:38 <Chaze> takeWhile, sure
00:01:57 <Chaze> but why fold doesn't iterate the whole list is beyond my understanding
00:02:19 <c_wraith> some folds work on infinite lists
00:02:33 <c_wraith> @botsnack
00:02:42 <c_wraith> ...  Cale hasn't come back, eh?
00:03:00 <magicman> He was here less than an hour ago.
00:03:03 <c_wraith> foldr can work on infinite lists, depending on the operation being folded.
00:03:19 <c_wraith> foldl can't work on an infinite list
00:03:44 <c_wraith> well.  where "work" means "be productive"
00:04:25 <magicman> That. foldr *does* iterate over the entire list, but it keeps producing, so you will have some output to work with.
00:04:49 <c_wraith> foldr doesn't necessarily fold over the entire list.
00:04:53 <magicman> Well, no.
00:05:01 <magicman> In this case not if it's cut short by takeWhile.
00:05:03 <c_wraith> foldr (&&) will stop when it hits a False, for instance
00:05:13 <dk> ok
00:06:08 <magicman> "foldr (\x xs -> x) 1000 [1..]" won't go far into the list at all :P
00:06:31 <c_wraith> indeed.  that'll just evaluate to 1 :)
00:10:36 <dk> m new to haskeel
00:10:43 <dk> haskell
00:10:46 <Chaze> i'm pretty sure i was aware of this at some point
00:10:55 <Chaze> but yeah, thanks for refreshing my memory
00:10:59 <kfish> hi dk
00:11:04 <dk> hi
00:12:55 <yitz> preflex: seen Igloo
00:12:56 <preflex>  Igloo was last seen on #ghc 7 hours, 57 minutes and 11 seconds ago, saying: Can we not change the default?
00:13:35 <dk> i want to learn haskel
00:13:45 <Axman6> @where lyah
00:14:02 <Axman6> argh
00:14:14 <Axman6> dk: http://www.learnyouahaskell.com/
00:16:43 <dk> thankx for the website axman
00:17:31 <guest2425> who wants to make $300 for 4 hours?
00:17:32 <Axman6> Cale: has lambdabot passed away?
00:17:48 <Axman6> you can SELL time? :O
00:18:42 <guest2425> Axman6: are you interested
00:18:49 <Axman6> very
00:18:50 <kfish> i'll pay $450 for 4 hours, as long as i get to choose what i do with the time
00:19:27 <Axman6> i coudl sell the time i spend waiting for this program to run, i'd save hours!
00:21:42 <hirsch> are there any benchmarks available for the new shiny HaLVM? Are there any performance benefity expectable?
00:35:42 <augur> dons: how should i optimize this program
00:38:43 <L29Ah> what is the best way to make assert's in do blocks?
00:39:14 <L29Ah> like "assert_ b = return $ assert b ()" but working
00:40:14 <visof> where is lambdabot ?
00:40:37 <adnap> > 2 * 2
00:41:00 <Zao> @botsnack
00:45:52 <ddarius> visof: She has fallen into a life of drugs and prostitution and now works the streets in Nevada.
00:46:45 <visof> ddarius: ok
00:50:19 <aleator_> Which of the many haskell webservers would be easiest for local usage? Nothing complex, usually single connection at a time?
01:01:44 <Boxo> Hey, what's it called when youuse functions instead of constructorsin your data structures, so 1:2:3:[] is \cn.c1(c2(n3)) ?
01:02:17 <aleator_> church encoding?
01:02:54 <Boxo> isn't that just for natural numbers?
01:03:20 <aleator_> thats church numerals I think?
01:03:32 <c_wraith> yeah, church encoding is arbitrary data types
01:03:41 <Boxo> Okay then, cool
01:06:34 <ddarius> There is also Scott-encoding.
01:09:31 * Boxo can't make sense of the wiki page for that
01:11:27 <guest2425> hello
01:27:02 <pastorn> guest2425: hiya
01:30:30 <quicksilver> ooh, halvm.
01:31:14 <guest2425> pastorn: a long time
01:33:14 <arch1> hello to all : has anyone  notice where i can download  : Jeï¬€ Newbern. "All about Monads" : the link is lost in www.haskell.org....
01:42:59 * hackagebot syb 0.3 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3 (JosePedroMagalhaes)
01:50:23 <arch1> grazie
01:52:30 <pastorn> I have a Handle that i read Strings from
01:52:44 <pastorn> How do i force the outputted strings to be in UTF?
01:53:24 <pastorn> do i have to pack it as a [ Char8 ] and then unpack it as a [ Char ] (where these might be unicode characters)
01:57:03 <basvandi`> pastorn: Have you seen: http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/System-IO.html#23
01:58:26 <quicksilver> pastorn: no, you dont' have to do any packing or unpackge
01:58:33 <quicksilver> you just set the encodings appropriately
01:58:52 <quicksilver> ( basvandi`'s link is to the right part of the docs)
02:06:26 <engla> @src product
02:06:41 <engla> ;_;
02:09:48 <pastorn> basvandijk: awesome dude!
02:13:37 <yitz> preflex: seen lambdabot
02:13:37 <preflex>  lambdabot was last seen on #haskell 9 hours, 44 minutes and 42 seconds ago, saying: let me answer that later, okay?
02:14:15 <yitz> wow that must have been a perplexing question. lambdabot hasn't been back since then.
02:14:23 <yitz> preflex: seen Cale
02:14:23 <preflex>  Cale was last seen on #haskell 2 hours, 59 minutes and 8 seconds ago, saying: Yeah.
02:15:36 <yitz> @tell Cale The old bot has gone south again. <sigh> Thanks.
02:15:41 <yitz> oops, no bot!
02:15:48 <yitz> preflex help tell
02:15:48 <preflex>  tell NICK MESSAGE - when NICK shows activity, tell them MESSAGE
02:16:13 <yitz> preflex: tell Cale The old bot has gone south again. <sigh> Thanks.
02:16:14 <preflex>  Consider it noted.
02:37:58 <altmattr> I am trying to extract the mechanism by which SYB manages to reject the expression (\x.x) `extT` (\y.y)
02:38:05 <altmattr> It seems to match the type of extT
02:38:25 <altmattr> but fails with an ambiguous type variable in constraint "Typeable b" error
02:42:25 <magicman> Typeable only works for monomorphic types.
02:44:54 <altmattr> magicman: I have heard that, but I don't see how that gets enforced.  I mean I see that it does, but I don't understand how
02:45:07 <quicksilver> haskell only works for monomorphic types.
02:45:16 <quicksilver> polymorphic types are not "real types" in haskell
02:45:38 <quicksilver> you can't pass a polymorphic type as an argument, you can't make a polymorphic type an instance of a class
02:46:02 <quicksilver> (the former can be lifted by an extension HigherRankTypes, the latter cannot as far as I know)
02:46:25 <quicksilver> although there are hacks to put polymorphic types in Dynamic. By oleg, possibly.
02:50:23 <altmattr> quicksilver: To be clearer - I can do what I want with a vacuous version of extT (see http://codepad.org/Yv1Z40KX)
02:50:52 <altmattr> bu the type constraints in extT stop me from writing the equivalent in SYB.
02:51:02 <quicksilver> that's not doing what you think it is.
02:51:11 <quicksilver> well, maybe I shouldn't guess what you're thinking ;)
02:51:16 <quicksilver> but that's not passing the polymorphic id
02:51:19 <altmattr> I don't think I am trying to make a polymorphic type as an argument
02:53:54 <altmattr> quicksilver: I didn't know I wanted it to be polymorphic
03:01:58 <altmattr> dreixel: any thoughts?
03:02:00 <quicksilver> altmattr: ok, then what *are* you trying to do? ;)
03:02:47 <altmattr> I just want to write a fucntion with type (a->a) -> (b -> b) -> (a -> a) and get it to accept id as both arguments
03:03:14 <altmattr> since extT has the same type (but with the type constraints) and *won't* accept id as both arguments
03:03:33 <quicksilver> altmattr: what are you trying to use extT for, though?
03:03:48 <altmattr> I am actually just trying to understand how it works :)
03:04:31 <altmattr> I am implementing something similar in another language.  I am having trouble working out how to get my own version to reject that as SYB does.
03:05:05 <quicksilver> well the second argument to extT, the (b -> b) part, is for some specific b
03:05:14 <quicksilver> some specific typeable b.
03:05:29 <quicksilver> so, (mytrans `extT` (id :: Int -> Int)) would be a typical example
03:05:32 <altmattr> Right, so it is like an existential I guess
03:05:40 <quicksilver> given an existing transformation 'mytrans'
03:05:49 <quicksilver> that extends to one which does nothing on Int nodes
03:05:57 <quicksilver> (but does exactly what it did before in all other places)
03:06:15 <quicksilver> of course (mytrans `extT` ((+1) :: Int -> Int)) would be a more typically useful case.
03:06:37 <altmattr> quicksilver: indeed, what is interesting though is that there is nothing in the type signature of extT that tells me that b needs to be a specific type
03:06:57 <paolino> hi, I think I have a silly question, why is Eq instance required by Ord instance ?
03:07:58 <altmattr> paolino: I think the Ord has default definitions for equality which it gets from Eq, so you only need to define > (or <) for Ord
03:08:05 <altmattr> but I could be wrong
03:08:23 <quicksilver> altmattr: essentially this is just because in haskell everything is always a specific type.
03:08:37 <quicksilver> altmattr: polymorphism is a tool but it is always resolved.
03:08:46 <altmattr> but the other type variable in the signature of extT
03:09:01 <quicksilver> is a specific type too, it's just it gets chosen later
03:09:11 <quicksilver> because the result of extT is still polymorphic in that.
03:09:18 <quicksilver> s/is a/will be a/
03:09:45 <quicksilver> I'm aware I'm not explaining this very well, but I can't quite think of the right way to put it :)
03:09:49 <quicksilver> I've probably not had enough coffee yet
03:09:50 <altmattr> right, so what forces one to get chosen then and one to get chosen later
03:10:03 <altmattr> quicksilver: I just appreciate having someone to talk to about it
03:10:06 <paolino> I have a type data Assertion p o = Leaf p o | Node p [Assertion p o], and my Eq instance should ignore the list ordering in the second arg of Node
03:10:23 <quicksilver> altmattr: the fact that "b" isn't present in the result type
03:10:41 <quicksilver> altmattr: there is no "b" in the type of (mytrans `extT` extension)
03:10:47 <altmattr> quicksilver: ha!  you legend
03:10:52 <quicksilver> altmattr: so, therefore, "b" must already be determined (by now)
03:11:09 <quicksilver> "a" is still present, so we can "still" be polymorphic in "a" for a little longer.
03:11:23 <paolino> I could sort the list in the Eq instance but the Ord instance require Eq
03:12:12 <altmattr> oh - but why does my codepad code work then
03:12:26 <altmattr> nothing is resolved in that example, and there is no b in the result type
03:12:52 <quicksilver> altmattr: which codepad example?
03:13:10 <altmattr> http://codepad.org/Yv1Z40KX
03:13:19 <quicksilver> paolino: that's not a problem; you can have recursive dependence between your instances
03:13:33 <quicksilver> paolino: that is, your Ord instance can depend on your Eq instance and your Eq instance on your Ord instance
03:14:12 <quicksilver> altmattr: true. GHC doesn't complain because it didn't matter what b was, you never used it.
03:14:39 <quicksilver> altmattr: unused parametric polymorphism is necessarily vacuous, so it can be ignored by the compiler.
03:14:51 <quicksilver> altmattr: however, unused *typeclass* polymorphism might not be vacuous
03:14:55 <quicksilver> so you have to pick a dictionary
03:15:00 <quicksilver> so it can't be left ambiguous
03:15:17 <altmattr> quicksilver: I think you have nailed it
03:15:27 <altmattr> quicksilver: you did explain it well, thanks!
03:16:26 <paolino> thanks quicksilver
03:16:32 <opqdonut> the type of myExt in "(id `myExt` id) 5" is forall b. (Int->Int) -> (b->b) -> (Int->Int)
03:16:40 <opqdonut> (assuming that 5::Int)
03:16:55 <opqdonut> that's a perfectly valid type
03:17:21 <opqdonut> another example is "print Nothing"
03:17:31 <opqdonut> it works even though Nothing :: forall a. Maybe a
03:17:55 <Jafet> Evil defaulting magic?
03:18:04 <opqdonut> unrelates
03:18:06 <opqdonut> *unrelated
03:18:21 <opqdonut> (except with the 5, but I'm ignoring that)
03:20:05 <altmattr> opqdonut: thanks, that does make things a bit clearer
03:20:17 <paolino> the compiler is lazy in fixing types
03:20:41 <quicksilver> opqdonut: I disagree. I think "print Nothing" depends on evil defaulting magic.
03:20:47 <opqdonut> oh?
03:20:54 <opqdonut> ah, yes, good point
03:21:03 <quicksilver> the show instance for Maybe requires a show instance for a
03:21:08 <opqdonut> yes
03:21:18 <opqdonut> "let f Nothing = "Nothing" in print $ f Nothing"
03:21:21 <opqdonut> that's a nicer example
03:21:27 * quicksilver nods
03:21:41 <opqdonut> one can think of it this way: "forall a. a" is a perfectly valid type, kind of like void *
03:21:45 <Jafet> It would default to Maybe ()
03:21:50 <opqdonut> I mean, perfectly valid at run-time
03:22:18 <quicksilver> I disagree with that way of thinking
03:22:24 <quicksilver> at least, I don't think it's haskell98
03:22:36 <quicksilver> I maintain that in haskell98, polymorphic types are not true types
03:22:46 <quicksilver> they are more like constraints bounding the concrete type
03:22:49 <opqdonut> you have a point
03:22:59 <quicksilver> but the H-M algorithm is clever
03:23:08 <quicksilver> and it knows that irrelevant polymorphism can be ignored
03:23:22 <quicksilver> (i.e. quantified variables who do not appear int he result type cannot be relevant)
03:23:30 <quicksilver> so it doesn't trouble it's little head about them
03:23:35 <quicksilver> this is a neat property of H-M inference.
03:23:46 <quicksilver> however it breaks down for typeclasses
03:23:55 <quicksilver> hence the whole area of "ambiguous type errors"
03:24:10 <quicksilver> once you add typeclasses, quantified type variables who do not appear in the result may still be relevant.
04:00:05 <pao> hi all, does anyone knows where I can find ghc head nightly build?
04:57:21 * hackagebot flock 0.2.4 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.2.4 (ErikHesselink)
05:11:36 <ManateeLazyCat> lambdabot is down?
05:11:44 <ManateeLazyCat> @hoogle show
05:12:04 <quicksilver> yup
05:12:57 <silver> @botsnack
05:13:03 <silver> :(
05:14:04 <turiya> ghc-pkg list shows that wx is installed but i cant load the module in ghci
05:15:23 <paolino> turiya: which error ?
05:15:49 <turiya> ghci says cant load module Graphics.UI.WX
05:16:08 <paolino> turiya: maybe you are in the wrong directory
05:16:24 <quicksilver> what director you are in doesn't matter.
05:16:43 <quicksilver> modules from the installed package database are located from the database.
05:16:53 <TheOm3ga> Hi
05:17:09 <TheOm3ga> I have a type synonym for lists: type Lista a = [a]
05:17:19 <TheOm3ga> I'm trying to print it in a special way using 
05:17:30 <paolino> quicksilver: I had errors like that when I was loading from the source dir
05:17:31 <turiya> what could be the problem? any ideas
05:17:40 <TheOm3ga> instance Show Lista c where	
05:17:40 <TheOm3ga>   show (x:xs) = show x ++ ":<< (" ++ show xs ++ ")"
05:17:40 <TheOm3ga>   show [] = "Empty"
05:17:50 <aristid> TheOm3ga: not possible with type synonyms.
05:17:50 <TheOm3ga> but it says that there's a syntax error
05:18:01 <quicksilver> turiya: I need to see the full error.
05:18:03 <TheOm3ga> oh
05:18:11 <TheOm3ga> ok aristid , thanks
05:18:15 <quicksilver> the syntax error is that it should be "instance Show (Lista c) where "
05:18:26 <quicksilver> however even when you fix the syntax error you will hit aristid's problem.
05:18:30 <Saizan> whois TheOm3ga 
05:18:35 <turiya> quicksilver: in ghci, "tab" does not show the module
05:18:46 <quicksilver> turiya: I need to see the full error.
05:18:56 <quicksilver> turiya: paste me the GHCi session.
05:18:58 <aristid> TheOm3ga: it might be easiest to just write a normal function with a different name. listaShow, for example. and whenever you want to print a Lista, you use that function
05:19:16 <TheOm3ga> aristid, yep I think that's what I'm going to do
05:19:17 <turiya> <no location info>:
05:19:17 <turiya>     Could not find module `Graphics.UI.WX':
05:19:17 <turiya>       it is not a module in the current program, or in any known package.
05:19:45 <turiya> quicksilver^^
05:20:08 <quicksilver> turiya: paste the output of ghc-pkg list to a pastebin
05:21:48 <turiya> quicksilver: http://hpaste.org/41995/ghcpkg_list_out
05:22:20 <paolino> TheOm3ga: you can also wrap the [] in a newtype to supply a new instance
05:23:12 <quicksilver> turiya: try ghc-pkg find-module Graphics.UI.WX
05:23:27 * hackagebot uulib 0.9.13 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.13 (DoaitseSwierstra)
05:24:02 <turiya> /usr/lib/ghc-6.12.3/package.conf.d
05:24:03 <turiya>    wx-0.12.1.6
05:24:03 <turiya> /home/phani/.ghc/x86_64-linux-6.12.3/package.conf.d
05:24:25 <quicksilver> turiya: looks fine. I wonder if you're running the wrong ghci
05:24:28 * hackagebot interpolatedstring-perl6 0.6 - QuasiQuoter for Perl6-style multi-line interpolated strings  http://hackage.haskell.org/package/interpolatedstring-perl6-0.6 (AudreyTang)
05:24:53 <turiya> quicksilver: hmm.. I have to install the latest ghc?
05:24:57 <quicksilver> turiya: no
05:25:05 <quicksilver> turiya: I'm wondering if you have two ghcs installed
05:25:12 <quicksilver> turiya: what does ghci --version say
05:25:31 <turiya> The Glorious Glasgow Haskell Compilation System, version 6.12.3
05:25:45 <quicksilver> Saizan: how can I get turiya to check which package.conf his ghci is consulting?
05:25:57 <quicksilver> Saizan: because it doesn't seem to be the same one as his ghc-pkg does
05:27:04 <quicksilver> Saizan: (alternative, could his locally installed parallel-3.1.0.1 somehow be a problem?)
05:27:09 <quicksilver> dcoutts_: ?
05:28:48 <MrAI> http://www.haskell.org/haskellwiki/Category_theory/Functor Are the pictures on that site showing for anyone?
05:28:53 <haskellElephant> @pl fromMaybe x (fix x)
05:29:07 <turiya> quicksilver: looks like none of them are online
05:29:11 <quicksilver> MrAI: lots of the pictures in the wiki are broken
05:29:17 <haskellElephant> @pl (\x -> fromMaybe x (fix x))
05:29:20 <MrAI> quicksilver: Ah ok
05:29:40 <haskellElephant> @botsnack
05:29:45 <haskellElephant> no bot today?
05:29:53 <quicksilver> turiya: I'm a bit confused, I'm wondering if your locally installed parallel-3.1.0.1 is confusing things although I can't see why
05:30:06 <turiya> hmm..
05:30:07 <MrAI> :t map
05:30:17 <turiya> i will just uninstall it and check
05:30:19 <quicksilver> turiya: can you try ghc-pkg hide parallel-3.1.0.1 ?
05:31:15 <turiya> quicksilver: that does not work either
05:32:51 <quicksilver> turiya: can I just say running as root sucks ?
05:32:57 <quicksilver> sorry, I had to say that.
05:33:08 <quicksilver> I'm afraid I'm baffled, about your actual problem.
05:33:14 <quicksilver> you need a Cabal Expert (TM)
05:33:57 <turiya> quicksilver: i thought installing system wide was good thing as all the users can load the modules.. 
05:34:13 <turiya> i will try uinstalling everything and try again
05:35:00 <quicksilver> installing system wide is good
05:35:02 <quicksilver> running as root is bad
05:35:12 <quicksilver> root having a local cabal directory is bad.
05:35:29 <turiya> oh..i am not running ghci as root
05:35:51 <quicksilver> you must have been running ghc-pkg as root
05:36:00 <quicksilver> otherwise why would it talk about /root/.ghc ?
05:36:01 <turiya> i made a mistake of installing the packages as root once
05:36:20 <turiya> oops.. the output was that of sudo ghc-pkg list
05:36:25 <quicksilver> ah.
05:36:28 <quicksilver> well, don't do that :)
05:36:33 <quicksilver> show me the output of ghc-pkg list, no sudo
05:38:05 <turiya> quicksilver: http://hpaste.org/41996/ghcpkglist
05:38:28 <quicksilver> turiya: ok well that's a *much* more interesting picture
05:38:46 <quicksilver> you have a massive amount of crap in your user databae
05:38:59 <quicksilver> I bet something there is satisfying a dependency and confusing things
05:39:08 <turiya> oh
05:39:22 <turiya> i must have been really careless then..
05:39:35 <quicksilver> can you try your ghci trick in another user?]
05:39:45 <quicksilver> (just trying to load the Graphics.UI.WX thing)
05:39:51 <quicksilver> a user who would never have used cabal 
05:39:57 <quicksilver> that would confirm this possibility
05:40:28 <quicksilver> I *think* it might be the copy of wxdirect installed as a user package but I'm not sure.
05:40:47 <turiya> i will check now..
05:42:21 <turiya> quicksilver: yes, it works in another account
05:42:29 <quicksilver> ok, that's good to confirm.
05:42:45 <quicksilver> so the problem, roughly, is that if you have user-local packages they take priority
05:43:05 <quicksilver> but then if the user-local packages pull in a package which is incompatible with a global one, that's not permitted
05:43:11 <quicksilver> but this error is not properly reported
05:43:23 <quicksilver> so instead you get that annoying generic module not found error
05:44:27 <quicksilver> I'm not exactly sure what your problem is but I'd guess something like your local wxdirect depends on your local parsec which is incompatible in some way with the global parsec
05:44:29 <turiya> so the global wx package is pulling a the wxdirect package from the local source
05:44:36 <quicksilver> turiya: yes, I think so.
05:44:49 <quicksilver> I can't actually put my finger on the incompatibility.
05:45:19 <turiya> removing the local wxdirect should work?
05:45:27 <quicksilver> hiding it should work
05:45:31 <quicksilver> if we are right in our diagnosis
05:46:10 <turiya> just tried it, does not seem to work..
05:46:16 <quicksilver> :(
05:46:32 <quicksilver> I don't really understand this situation although at least we made some progress.
05:46:36 <quicksilver> cabal expert still needed
05:46:55 <turiya> quicksilver: yeah
05:47:02 <lars9> data D = A | B, can I define a function, which is only defined for A but not for B?
05:47:07 <turiya> may be i should stop installing things globally
05:47:48 <hirsch> are there any benchmarks available for the new shiny HaLVM? Are there any performance benefity expectable?
05:48:14 <hpc> lars9: not so it fails at compile-time
05:48:16 <benmachine> lars9: you can define a function that throws an error when it is given B
05:48:21 <hpc> @src fromJust
05:48:27 <hpc> bah
05:48:33 <hpc> fromJust (Just x) = x
05:48:33 <lars9> hpc: benmachine: i see
05:48:34 <MrAI> I like like im so close, lol
05:48:35 <MrAI> newtype T a = T a
05:48:35 <MrAI> afmap :: (Functor t) => (a -> b) -> t a -> t b
05:48:35 <MrAI> afmap a (T b) = T (fmap (afmap a) b)
05:48:44 <hpc> fromJust Nothing = error "you fool! what have you done!"
05:48:54 <MrAI> *like=feel
05:49:27 <lars9> did i miss some discussion on HaLVM?
05:49:31 <benmachine> MrAI: what type is the RHS of that equation
05:49:57 <benmachine> MrAI: (I know the answer but I'm trying to get you to think about it :P)
05:50:11 <MrAI> benmachine: Gah... functors has thrown me off my game
05:51:11 <benmachine> does that main you don't know or you just realised your problem or what >_>
05:51:26 <hirsch> lars9: Don't know, the concept is new to me, as I understand it, it runs virtualized on the CPU, correct?
05:51:34 <MrAI> I dont know, what I dont know, if I know what I know
05:51:57 <benmachine> this is #haskell not a rap competition
05:52:02 <MrAI> haha
05:52:04 <lars9> its webpage said it runs on bare Xen
05:52:24 <lars9> i dunno details
05:52:28 <hirsch> lars9: ok, what does that mean?
05:52:51 <MrAI> benmachine: I tied learning functors 10 mins ago
05:52:59 <MrAI> benmachine: *tried
05:53:02 <adnap> What is the best way to represent data with elements that are linked to each other arbitrarily in Haskell as in a graph?  I noticed that there are some implementations of graphs on hackage, but is this necessarily the best choice in Haskell?
05:53:12 <hirsch> shouldn't it be possible to also 'boot' it directly from grub ;-)
05:53:18 <benmachine> MrAI: what's the newtype for?
05:53:39 <MrAI> benmachine: *shrugs* Guess work so far
05:53:40 <lars9> hirsch: means it's a haskell runtime on bare Xen, without an OS
05:53:50 <benmachine> MrAI: guessing at what :P
05:53:57 <benmachine> MrAI: what is your goal
05:54:49 <MrAI> To show ffold :: Functor f => (f a -> a) -> M f -> a without using a functor on the function mapping (f a -> a)
05:55:33 <benmachine> what
05:55:54 <benmachine> what's M
05:56:19 <MrAI> newtype M f = Inn {unInn :: f (M f)}
05:56:19 <MrAI> ffold :: Functor f => (f a -> a) -> M f -> a
05:56:19 <MrAI> ffold h (Inn k) =  h (fmap (ffold h) k)
05:56:42 <MrAI> I have no idea how that actually works beyond what I know the definition needs to take in,
05:56:49 <hirsch> lars9: Hmm, that's what i know, but this whole virtualization stuff is like magic for me. Isn't that the definition of an OS
05:57:55 <flux> virtualization is very much like an OS, except it provides lower-level services in term of other services.
05:58:18 <benmachine> MrAI: that's kind of a messy example to be starting with :P
05:58:39 <benmachine> MrAI: are you sure your goal is achievable?
05:59:13 <quicksilver> you can think of bare Xen as an abstracted 'bare machine'
05:59:18 <MrAI> benmachine: Yep yep - deep end again :D Not really sure. Thus I tried to make a simplier example for myself
05:59:26 <quicksilver> so haskell on bare Xen is a bit like haskell on a bare PC, say
05:59:39 <quicksilver> except you don't have to take account for billions of hardware permutations
05:59:41 <lars9> hirsch: virtualizaton provides the ability of executing CPU instructions and simulating devices, OS does memory paging, virtual memory, threads/process info and scheduling, inter process communication etc
05:59:43 <benmachine> you can think of ben Xen as an abstracted 'ben machine'
05:59:53 * benmachine >_> <_<
05:59:54 <quicksilver> you have a 'standard interface' to something like a 'standard computer'
06:00:49 <hirsch> quicksilver: that's cool stuff then it could be also possible to boot the runtime directly e.g. for number cruching machine and run on the bare metal
06:02:03 <quicksilver> well, Xen adds essentially zero overhead to number crunching
06:02:09 <lars9> it already can, if Galois want to spend some litte effort. 
06:02:20 <quicksilver> so, as far as executing x86 instructoins goes, it is bare metal
06:02:40 <quicksilver> the xen abstraction is in timeslicing guest kernels and providing abstract hardware
06:03:30 <lars9> some benchmarks show Xen's performance reduction is under 3-4%
06:03:43 <MrAI> benmachine: Suggestions for learning functors? Best place to read...
06:04:15 <benmachine> MrAI: learn you a haskell?
06:04:30 <alvivi> One design question, if I have a library that all its functions return something like IO (Either ErrorCode Result), should I use functions with result type like IO Result + Exceptions or a monad like ErrorT?
06:04:31 <hirsch> wow, would be interesting to compare virtualized to non-virtualized runtimes
06:04:52 <lars9> hirsch: you can find a dozen
06:05:10 <benmachine> alvivi: it depends on what an errorcode means, imo
06:05:42 <benmachine> alvivi: it doesn't matter a huge deal because you can use try/either throw return to convert between them
06:07:38 <lars9> i doubt if galois has the ability to build a mature OS equivalence thing on their own...
06:08:15 <Zao> Too bad that FreeBSD doesn't seem to have any dom0 stuff yet :(
06:08:28 <Zao> I guess that modern Xen require the silly VT extensions anyway, though.
06:09:10 <quicksilver> they are required for good performance and certain featueres, I think? 
06:09:50 <lars9> VT is essential to Xen
06:10:42 <quicksilver> don't think so, no.
06:10:47 <quicksilver> VT is essential to run windows.
06:10:57 <quicksilver> and, in general, unmodified OSes.
06:11:30 <quicksilver> but Xen predates the VT extensions and linux/bsd/solaris/probably others can run as 'cooperating' guests
06:11:41 <quicksilver> (i.e. specially compiled kernels)
06:12:41 <alvivi> benmachine: Thanks, then I'm going to use Either, the simple way ^^
06:13:36 <lars9> it will be great if we can see some benchmarks of HaLVM:)
06:18:49 * hackagebot ruler-core 1.0 -   http://hackage.haskell.org/package/ruler-core-1.0 (ArieMiddelkoop)
06:20:39 <byorgey> can anyone explain to me in two sentences or less what Xen is and why it is so awesome that Haskell runs on it now?
06:21:28 <MrAI> No OS to hug resources
06:21:58 <benmachine> god damn OSes, always getting in the way
06:22:51 <Jafet> Why won't they just go away and let us use the hardware!
06:23:07 <byorgey> but won't the resources get sad if they stop getting hugs?
06:23:39 <benmachine> well no because we're doing the hugging from haskell instead
06:23:48 <quicksilver> byorgey: Xen is a model for a virtual PC, which lets you write baremetal code without getting too upset by IO details.
06:24:06 <Jafet> My resources never ran Hugs, and they're doing fine
06:24:08 <quicksilver> byorgey: (Xen is also a software package which lets you run multiple of these things on a single piece of hardware)
06:24:34 <quicksilver> byorgey: it is useful for OS development, since you can run multiple OSes on one computer, as well as virtualisation.
06:24:42 <MrAI> haha Jafet
06:26:18 <byorgey> so HaLVM is basically a compiler from Haskell to this virtual PC model?
06:27:29 <quicksilver> byorgey: it's a patched GHC which targets this model, yes
06:27:38 <byorgey> I see, cool.
06:27:46 <quicksilver> byorgey: mostly, it was the GHC RTS they had to port, since the current RTS expects an underlying OS (POSIX or Windows)
06:27:59 <byorgey> oh, I see.
06:28:10 <quicksilver> they'll be doing their own memory management, for example.
06:28:23 <quicksilver> and their own threads
06:28:34 <quicksilver> (I assume. I haven't checked what it's capable of)
06:29:04 <quicksilver> I would love to know what galois actually use it for,  mind.
06:29:49 <revenantphx> I discovered I had a bookmark from galois... from before I even knew about haskell.
06:29:50 <revenantphx> funny.
06:31:32 <xuan> is there any haskell tutorals for beginner?
06:31:41 <MrAI> Many
06:31:49 <byorgey> @where lyah
06:32:01 <xuan> for example.....
06:32:10 <fryguybob> http://learnyouahaskell.com/
06:32:13 <MrAI> xuan: learn you a haskell, real world haskell, google search and you will find many
06:32:18 <byorgey> hmm, no \bot ?
06:32:23 <benmachine> none.
06:32:24 <MrAI> No bot today :(
06:32:31 <byorgey> =~(
06:33:26 <xuan> emm,I had read them lastnight,but I find it's hard to understand functional program
06:33:36 <revenantphx> I doubt you read them all last night.
06:33:44 <revenantphx> LYAH has a whole section on thinking functionally.
06:34:15 <xuan> haha~,just skiming
06:34:36 <benmachine> cabal is misbehaving for me, I'm trying to install xmonad-contrib and it's going cabal: cannot configure xmonad-0.9.1. It requires base ==3.*
06:34:44 <fryguybob> xuan: Feel free to ask any specific questions you have here.
06:34:50 <revenantphx> @quote fugues
06:34:53 <benmachine> but I already have xmonad-0.9.1 installed, and I'm pretty sure it doesn't need to be rebuilt
06:34:54 <revenantphx> ....oh right.
06:35:07 <Jafet> As a rule, functional thinking moves faster than one's progress towards learning it
06:36:51 * benmachine uses this as an excuse to use darcs cabal install
06:37:46 <xuan> to fryguybob :thanks,but my english is poor
06:38:07 <xuan> :(
06:38:56 <dcoutts_> benmachine: on the contrary, it is behaving perfectly :-)
06:39:03 <xuan> I can read english paper but speak or write
06:39:13 <dcoutts_> benmachine: what it says is quite correct
06:39:14 <Guest8288> telephoning : "It is me "or "It is I" ?
06:39:40 <benmachine> dcoutts_: why does it want to configure xmonad?
06:40:37 <dcoutts_> benmachine: because xmonad-contrib depends on xmoand, and both packages need base 3
06:40:51 <paolino> ghc-7.0.1 ?
06:40:57 <benmachine> dcoutts_: the darcs versions need base 4, I already have xmonad installed from darcs
06:41:13 <benmachine> dcoutts_: and I'm running cabal install from the xmonad-contrib darcs directory
06:41:19 <benmachine> dcoutts_: sorry, I should have mentioned that :)
06:41:29 <dcoutts_> benmachine: if you hacked xmonad locally so that it builds with base 4 then you're confusing things because it means you have the same version installed as available but with different dependencies
06:41:36 <benmachine> ah ok
06:41:47 <dcoutts_> benmachine: cabal expects that if they're the same version then they're the same
06:42:14 <benmachine> so I should bump the xmonad version, if I'm going to do that?
06:42:17 <paolino> installing ghc-7.0.1 changes cabal program ?
06:42:40 <quicksilver> dcoutts_: I was unable to help turiya (he's gone now) with a ghc-pkg/cabal problem earlier, and discovered some gaps in my knowledge.
06:42:55 <akamaus> hello, I'm writing a program for cleaning html produced by OpenOffice. I'm looking for some html/xml handling library. I remember HXT includes a rich DSL for describing transformations. But maybe there're better choices?  
06:42:59 <dcoutts_> benmachine: yep
06:43:10 <benmachine> dcoutts_: ok thanks :)
06:43:46 <quicksilver> dcoutts_: Am I write in thinking that the unhelpful "Could not find module `Foo.Bar'" from ghci *can* be caused by the module actually being installed, but ghc not finding the right way to choose a consistent set of packages?
06:44:39 <Saizan> quicksilver: yes
06:45:17 <quicksilver> Saizan: is there any way to get the system to explain the problem?
06:45:21 <Saizan> quicksilver: in those cases ghci -v should help, because it'll print warnings about shadowing packages and ignoring those that depend on that
06:45:34 <dcoutts_> quicksilver: yep
06:45:45 <Saizan> s/that/them/
06:45:52 <quicksilver> Saizan: http://hpaste.org/41996/ghcpkglist -- wx-0.12.1.6 is the problem, package, I believe that the route of the problem is it's picking up the *local* wxdirect-0.12.1.3
06:46:07 <dcoutts_> quicksilver: yes, local ones shadow global ones
06:46:27 <quicksilver> ...and I don't know what's wrong with the local wxdirect, but I have to guess it depends on the local parsec which in turn depends on the wrong version of base
06:46:30 <Saizan> yep, with a recent ghc at least
06:46:38 <quicksilver> or maybe it just depends on the wrong version of base itself.
06:46:44 <quicksilver> I didn't know how to find out.
06:47:13 <b0fh_ua> http://pastebin.com/TWAHn16h - how can I get rid of "args" there?
06:47:36 <benmachine> quicksilver: you can find out what depends on what with ghc-pkg field wxdirect depends
06:47:55 <benmachine> but I guess that wouldn't be the fastest way
06:50:55 <Saizan> wrong version of base shouldn't matter btw, since base-3 depends on base-4 anyway
06:52:21 <benmachine> Saizan: trying to compile with GHC 7 which doesn't have base3 anymore
06:52:34 <quicksilver> benmachine: I went through the dependencies using the hackage pages
06:53:03 <quicksilver> Saizan: hmm. Then what might it be? wxdirect doesn't have many dependencies.
06:53:03 <benmachine> quicksilver: the ghc-pkg thing tells you which version exactly it was built against, is why I thought it would help
06:53:10 <quicksilver> benmachine: ah.
06:53:20 <quicksilver> http://hackage.haskell.org/package/wxdirect-0.12.1.3
06:53:42 <benmachine> $ ghc-pkg field mtl depends
06:53:42 <benmachine> depends: base-4.3.0.0-b91367e4fa5bd47d8e75958171ad21b7
06:53:42 <benmachine>          transformers-0.2.2.0-2b42e771f1a8057e2ab6dac97c917eed
06:53:44 <benmachine> for e.g.
06:54:00 <Saizan> quicksilver: the original problem was that ghci couldn't find a module of wxdirect?
06:54:32 <quicksilver> Saizan: wx, actually
06:54:40 <quicksilver> (Graphics.UI.WX is in wx)
06:54:45 <quicksilver> but wx depends on wxdirect
06:54:59 <Saizan> ah, ok
06:55:36 <nostard> b0fh_ua: something like: main = getArgs >>= readFile >>= mapM_ ...
06:55:48 <b0fh_ua> nostard: doesn't work well
06:56:13 <Saizan> quicksilver: ghci picks the local wxdirect and shadows away the global one, hence it must remove wx because it depends on the global one
06:56:28 <quicksilver> Saizan: Ah. That's a simpler answer indeed :)
06:56:32 <quicksilver> Saizan: thanks.
06:56:48 <quicksilver> Saizan: I told him to hide the local wxdirect and that didn't seem to work, but maybe we did it wrong.
06:57:00 <Saizan> quicksilver: i'm not sure if that helps
06:57:46 <b0fh_ua> just wanted to do nice one-lined in haskell
06:58:04 <nostard> b0fh_ua:  ah, now i see, you want to print several files
06:58:26 <Saizan> quicksilver: running ghci with -package-id wx-$ver-$hash should work if this is the problem, you can find the hash with ghc-pkg field wx-$ver id
06:59:01 <revenantphx> I feel like haskell is growing on me.
06:59:02 <revenantphx> https://gist.github.com/723589
06:59:07 <revenantphx> This code makes me really happy :)
06:59:40 <mux> you don't need all those casts though
06:59:47 <benmachine> they're not casts
06:59:49 <benmachine> they're annotations
06:59:50 <quicksilver> Saizan: yowch.
06:59:53 <benmachine> and yes they're unnecessary
06:59:56 <quicksilver> Saizan: that's not very nice :)
07:00:11 <revenantphx> benmachine: except I want it to use specific types.
07:00:19 <revenantphx> I guess it could infer t and c
07:00:19 <quicksilver> Saizan: why doesn't hiding the local wxdirect work? what should I have done? unregistered the local wxdirect entirely?
07:00:21 <benmachine> revenantphx: except haskell knows which types you want
07:00:53 <benmachine> revenantphx: you give them to the MCInventory constructor, there's only one type they can be
07:00:58 <mux> revenantphx: your data constructors are already defined to take Int16, Int32, etc
07:01:04 <quicksilver> it can't infer iid
07:01:12 <benmachine> true
07:01:12 <Saizan> quicksilver: i don't know if it'll work, i never tried, unregistering would work
07:01:14 <revenantphx> quicksilver: ^
07:01:19 <mux> yes, iid can't be infered
07:01:53 <benmachine> you could do iid `asTypeOf` c though :>
07:02:32 <quicksilver> revenantphx: it can infer everything except iid
07:03:00 <quicksilver> I imagine you won't always want to throw away iid
07:03:11 <quicksilver> seems strange to give your inventory items ids and then discard them ;)
07:03:22 <revenantphx> I realize that, it's incorrect :P.
07:03:37 <revenantphx> Especially considering that Int16 in there IS the id.
07:03:41 <revenantphx> so that's an issue.
07:03:54 <mux> see how type errors can sometimes point you at design errors and/or bugs? :-)
07:03:56 <revenantphx> If the id is -1 I want to read nothing else, but if its anything else I want to parse the rest...
07:04:43 <mux> why don't you just use a list then?
07:04:54 <revenantphx> Wait, here's an issue
07:04:56 <revenantphx> https://gist.github.com/723601
07:05:04 <revenantphx> Couldn't match expected type `(t, t1, t2)'
07:05:04 <revenantphx>            against inferred type `Get t3'
07:05:09 <revenantphx> oh right, return
07:05:12 <mux> there is a Binary a => Binary [a] instance
07:05:30 <revenantphx> I know.
07:05:38 <quicksilver> mux: don't use it, ever.
07:05:42 <revenantphx> Couldn't match expected type `Int8' against inferred type `Get t'
07:05:42 <revenantphx>       Expected type: [MCInventoryItem]
07:05:42 <revenantphx>       Inferred type: [(Int16, Get t, Get t1)]
07:05:43 <revenantphx> :\
07:05:48 <quicksilver> revenantphx: 'get' is monadic
07:05:53 <revenantphx> ah right.
07:06:01 <revenantphx> so how will I fix that....
07:06:03 <mux> quicksilver: I've used it successfully once though
07:06:16 <nostard> b0fh_ua: what do you want the program to do?
07:06:18 <revenantphx> quicksilver: how can I extract them from the monad other than binding them prior?
07:06:21 <quicksilver> otherwise -> do x <- get; y <- get; return (iid,x,y);
07:06:24 <quicksilver> revenantphx: like that.
07:06:29 <revenantphx> no other way?
07:06:37 <mux> (iid,,) <*> get <*> get
07:06:42 <mux> I suppose
07:06:44 <quicksilver> or, otherwise -> (,,) <$> pure iid <*> get <*> get
07:07:02 <nostard> b0fh_ua: sry, i can just try your code for that =)
07:07:03 <mux> mine uses an extra extension, for good measure
07:07:20 <benmachine> mux: that first <*> should be a <$>
07:07:28 <mux> right, typo
07:07:51 <quicksilver> mux: well, I was being hyperbolic, but my objection to the Binary [a] instance is that it uses a binary representation not chosen by you, and if it changes in a later version of Binary, you're screwed.
07:08:06 <mux> that was quite hyperbolic indeed
07:08:10 <mux> :D
07:08:12 <quicksilver> for file formats and wire formats I feel you should control your binary instances more carefully.
07:08:17 <quicksilver> Binary itself has no versioning.
07:08:43 <mux> by that same reasoning you wouldn't use any single predefined Binary instance if you care about stability
07:09:00 <benmachine> quicksilver: if you're serialising stuff to be sent over a network connection you might reasonably expect the version at each end to match
07:09:10 <benmachine> at least up to major versions of binary
07:09:25 <quicksilver> benmachine: you often want old versions to be able to speak to new versions.
07:09:32 <benmachine> often!
07:09:39 <quicksilver> benmachine: but yes, it's less worse for wire than file.
07:09:50 <quicksilver> benmachine: you *always* want to be able to read old files.
07:09:58 <quicksilver> and really you want to be able to define your file format extrinsically.
07:10:19 <quicksilver> not by saying "well, this bit is formatted however the Binary authors chose to represent lists in version 2.0.1.0"
07:10:39 <quicksilver> it's not really as big a problem as I'm suggesting
07:10:43 <quicksilver> but it's something to think about .
07:11:38 <Saizan> you could have a preprocessor that generates a module with a file format specification inferred from the type, so it's both extrensic and automatic
07:12:13 <Saizan> more like a tool than a preprocessor, you'd manually run it
07:12:24 <quicksilver> Saizan: that would be excellent, but you'd need a corresponding tool to generate parsers for old versions.
07:12:31 <quicksilver> (from the specification you just described)
07:12:57 <quicksilver> the Binary guys quite happily considered all this out-of-scope for their project, which is 100% reasonable.
07:13:03 <dcoutts> sort-of
07:13:15 <dcoutts> there's two layers, that need pulling apary
07:13:17 <dcoutts> apart
07:13:20 <quicksilver> but it does mean people who are drifting out-of-scope from Binary should be aware that they have to make some decisions about some of these bits.
07:13:44 <dcoutts> one is binary formats in general (with format externally defined)
07:13:48 <quicksilver> dcoutts: I would prefer if it Binary as a class was dropped.
07:13:56 <quicksilver> dcoutts: and it became a type.
07:14:11 <quicksilver> (a bit like the Arbitrary class vs the Gen a type, if you're familiar with that)
07:14:14 <dcoutts> quicksilver: I would prefer it be moved to another package and called e.g. serialise
07:14:27 <quicksilver> then, "Binary a" would be a binary instance for a
07:14:35 <quicksilver> but you could have multiple such and choose the one you wanted.
07:14:53 <dcoutts> quicksilver: isn't the "binary" type you're thinking of the Builder monoid?
07:15:00 <quicksilver> oldParsers :: (VersionNum,Binary MyBigType)
07:15:16 <dcoutts> quicksilver: oh you mean some generic sum of products traversal thing
07:15:24 <dcoutts> parametrised by the format details
07:15:26 <quicksilver> oldParsers = [ (V10, parser10), (V11, parser 11), (V12, parse12)]
07:15:41 <quicksilver> I just mean a standard unpacked dictionary.
07:15:59 <quicksilver> so that the type "Binary a" is exactly the information we currently have in a Binary instance.
07:16:21 <quicksilver> i.e. Binary a = (Get a, a -> Put ())
07:16:32 <dcoutts> oh right
07:16:50 <quicksilver> but by making it not-a-type-class anymore, we can have multiple of them coexisting.
07:16:56 <quicksilver> for old versions of parsers.
07:17:01 <dcoutts> you can have multiple of them anyway
07:17:08 <quicksilver> with newtypes.
07:17:15 <dcoutts> no, just do exactly the above
07:17:17 <quicksilver> that feels worse but maybe it doesn't matter.
07:17:22 <quicksilver> well, yes, true.
07:20:12 <quicksilver> type Format a = (Get a, a -> Put ()); allFormats = [(V10,parser10), (V11,parser11), (V12,parser12)]; instance Binary MyBigType where get = fst parser12; put = snd parser12;
07:20:58 <Saizan> except that via typeclasses you can't easily access  "listBinary :: Binary a -> Binary [a]", so you've to newtype or duplicate that code
07:21:25 <quicksilver> and, in principle, you'd want the way to access the old instance
07:21:38 <quicksilver> if the theoretical "Binary people decided to change the list instance" thing happened.
07:25:59 <bhaskar00666> hi
07:41:59 <kriomant> hello all. what library to prefer for writing safe lazy io: iteratee/enumerator/something else?
07:42:03 <roconnor> how about store comonad.
07:42:15 <roconnor> *?
07:43:21 <roconnor> state/store feels like a nice duality :)
07:55:35 <d-snp> lol, I thought I was learning haskell io so I could research and implement io in some other language
07:55:58 <d-snp> but they actually want me to make something haskelly
08:03:55 <user> http://www.australia.spmgame.com/partner.php?ID=268747
08:03:57 <user> http://www.australia.spmgame.com/partner.php?ID=268747
08:04:07 <b0fh_ua> nostard: well, in fact I want to read files from cmd-line arguments and print the content in order: 1-st line from 1-st file, 1-st line from 2-nd file ... 1-st line from N-th file, 2-nd line from 1-st file, 2-nd line from 2-nd file ... 2-nd line from N-th file and so on
08:04:49 <b0fh_ua> so I need to understand how to get rid of reading file names from command line into variable and then iterate over it
08:09:46 <byorgey> b0fh_ua: do { files <- getArgs; ls <- (concat . transpose . map lines) `fmap` mapM readFile files; ... do something with ls ... }
08:09:51 <byorgey> something like that?
08:12:46 <roconnor> do { files <- getArgs; ls <- (concat . transpose . map lines) `fmap` mapM readFile files; print (unlines ls) }
08:14:26 <b0fh_ua> getArgs >>= mapM readFile >>= mapM_ putStrLn . concat . transpose . map (lines)
08:14:30 <b0fh_ua> that's it
08:17:45 <revenantphx> @undo 
08:17:51 <revenantphx> ugh, lambdabot's still dead?
08:18:15 <benmachine> has been all day, apparently
08:18:21 <revenantphx> Yeah, was last night too.
08:18:24 <medfly`> hi cale
08:18:30 <revenantphx> After I was playing with some stuff it stopped working.
08:18:31 <revenantphx> I blame myself.
08:18:44 <Cale> medfly`: look at your messages on medfly
08:18:44 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
08:19:18 <Cale> (I answered some of your questions about calculus)
08:19:21 <roconnor> ugh, It's annoying when people put references to the wrong articles for what they are citing.
08:19:32 <roconnor> thank goodness for google
08:20:12 <benmachine> @botsnack
08:20:16 <roconnor> :)
08:20:18 <lambdabot> :)
08:20:19 <benmachine> :)
08:21:41 <aristid> @botsnack
08:21:48 <lambdabot> :)
08:22:41 <roconnor> :)
08:22:59 <aristid> roconnor: you're a second instance of lambdabot?
08:23:04 <d-snp> you're not convincing anyone roconnor :P
08:23:08 <roconnor> I'm just another bot
08:23:31 <aristid> roconnor: you could maximising your co-ness by renaming yourself coroconnor
08:23:53 <aristid> that's two Co
08:24:03 <roconnor> :D
08:26:12 <turiya> i am still stuck at ghci not loading the WX module even though ghc-pkg list shows it in the golbal database, any suggestions?
08:27:24 <Saizan> turiya: ghc-pkg unregister --user wxdirect
08:28:48 <turiya> ghc-pkg: unregistering wxdirect would break the following packages: wx-0.12.1.6 wxcore-0.12.1.6 (use --force to override).. still do it?
08:30:11 <Saizan> i'm not sure if we can trust that message, however a less invasive solution is to get wx's package-id with "ghc-pkg field wx id"
08:30:37 <Saizan> and then pass it to ghci at the start with -package-id
08:31:22 <Saizan> that should make sure the wx package is kept into the installed package set and not shadowed away
08:32:03 <turiya> Saizan: i did the -package-id thing.. there seems to be an error..
08:32:14 <turiya> ghc: /usr/local/lib/wxcore-0.12.1.6/ghc-6.12.3/HSwxcore-0.12.1.6.o: unknown symbol `__dso_handle'
08:32:14 <turiya> Loading package wxcore-0.12.1.6 ... linking ... ghc: unable to load package `wxcore-0.12.1.6'
08:33:41 <Saizan> __dso_handle looks like a symbol that should come from a C lib
08:33:54 <aristid> turiya: well that explains why it does not work: it cannot be loaded
08:34:01 <Saizan> not really
08:34:17 <Saizan> ghci doesn't even attempt to load it if it gets shadowed
08:34:25 <turiya> oh.. i can load it as a different user
08:35:04 <turiya> dont know why it does not work for a particular user
08:35:31 <Saizan> could be a problem of paths or environment variables that influence dynamic linking
08:37:13 <revenantphx> One question
08:38:15 <Zao> One answer
08:40:06 <turiya> i found something on the web which says that gcc should be used in place of ld for linking
08:40:09 <quicksilver> Saizan: could it be something to do with the way wx installs it native libs.
08:40:25 <quicksilver> Saizan: I know that version (N-1) of wx couldn't be cabalized, because of the native libs
08:40:31 <quicksilver> but I don't know how they fixed it for this one.
08:40:57 <Saizan> yeah, i'm in the same boat
08:41:16 <Saizan> looking at "ghc-pkg describe wxcore" could reveal something
08:42:51 <turiya> Saizan: http://hpaste.org/41999/ghcpkg_describe
08:43:31 <tromp_> typing fox error in http://tryhaskell.org/ gives odd results
08:43:39 <tromp_> fox->fix
08:43:58 <roconnor> > fix error
08:44:01 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
08:44:08 <tromp_> when i reset it, it returns the prompt but also shows the busy animation
08:44:49 <revenantphx> On a funny note, a good indication of a 2nd world country (developing) is the appearance of distributed free porn.
08:44:56 <revenantphx> I have funny debates.
08:45:46 <arcatan> for funny debates, there's -blah
08:47:27 <Saizan> turiya: the extra-libraries are the C ones that get linked in, afaiu, so __dso_handle probably comes from one of those
08:48:46 <quicksilver> Saizan: http://comments.gmane.org/gmane.comp.lang.haskell.wxhaskell.general/923
08:48:51 <turiya> Saizan: ok
08:48:56 <quicksilver> ...but that's odd, because turiya said it worked as another user.
08:49:35 <turiya> yes, the module gets loaded when logged in as another user
08:51:30 <turiya> there should be a conflict between a global and a local package?
08:53:31 <turiya> hmm..if i have version N of a package in the global database and version M in the local database where M and N are not equal, could that be a problem?
08:54:02 <Saizan> that's less of a problem than if they were equal
08:55:27 <d-snp> hmm the IO_inside article is really good
08:55:34 <d-snp> you guys should've pointed me to that :P
08:55:44 <turiya> hmm.. 
08:55:58 <Saizan> it still means that you can end up with packages that use different versions and so can't be used together, but that should manifest as a type error, or by cabal install trying to reinstall things to get a consistent set
08:57:06 <roconnor> d-snp: link?
08:57:40 <abstractstone> can I have a .hs file for factoring small numbers (10 digits) quickly?
08:57:52 <d-snp> roconnor: http://haskell.org/haskellwiki/IO_inside
08:58:26 <roconnor> that is terrible explaination
08:58:36 <roconnor> @wiki IO_Semantics 
08:58:36 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics_
08:58:40 <roconnor> @wiki IO_Semantics
08:58:40 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
08:58:53 <roconnor> is better IMHO
08:58:58 <roconnor> ... though I am the author
08:59:07 <roconnor> that might bias me
08:59:10 <d-snp> lol
08:59:47 <d-snp> wtf, it's only one page? :P
08:59:51 <turiya> Saizan: ok
08:59:57 <roconnor> d-snp: actually I only don't like section 3 of IO_inside
08:59:59 <roconnor> the rest is probably good
09:00:31 <d-snp> hmm oh, but I really like section 3 so far, what's bad about it?
09:01:02 <roconnor> the whole RealWord token passing thing doesn't really make sense if you start pressing on it.
09:01:40 <roconnor> for example the semantics of (forever (print ">")) doesn't denote anything according the the RealWorld state transformer interpretation
09:02:53 <roconnor> but clearly (forever (print ">")) does denote something. :D
09:02:56 <turiya> quine.. can you write one in haskell
09:03:24 <roconnor> main = putStr (s ++ [';',' ','s',' ','=',' '] ++ show s);
09:03:26 <roconnor> s = "main = putStr (s ++ [';',' ','s',' ','=',' '] ++ show s)"
09:04:07 <roconnor> http://www.iis.sinica.edu.tw/~scm/2007/a-haskell-quine/comment-page-1/
09:04:30 <roconnor> main = (\s -> putStr s >> print s) "main = (\\s -> putStr s >> print s) "
09:04:34 <yescalona> who is the best editor in haskell?
09:04:37 <d-snp> roconnor: what do you mean with that (forever (print ">")) does not denote anything?
09:06:49 <turiya> rconnor: oh..neat
09:07:37 <turiya> http://www.haskell.org/haskellwiki/Category:Theoretical_foundations <-- was talking about quines
09:07:47 <lispy> Okay, so I don't like the no RTS options feature of GHC7 or the implicit --make.
09:07:59 <lispy> Those seem like misfeatures
09:08:13 <roconnor> according to the RealWorld State Transformer (forever (print ">")) is a value of type "RealWorld -> (RealWorld,Void)"  And when you pass an initial RealWorld, you get out the resulting RealWorld with ">" printed an infinite number of times.  But the thing is that this "function" runs forever so never produces any output RealWorld.  So according to those semantics, (forever foo) = (forever bar) for any actions foo and bar, which is clearly wrong.
09:09:13 <lispy> roconnor: is RealWorld State Tranformer a follow up book to RealWorld Haskell?
09:09:16 <turiya> hw do i completely remove  the local database  with ghc-pkg?
09:09:19 <roconnor> The thing is that we can observer the intermedate worlds that (forever (print ">")) produces
09:09:41 <roconnor> as we watch the lines whiz by on our screen
09:10:12 <roconnor> the fact that these intermedate worlds are observable (and highly relevent) is totally missed by the RealWorld state transformer semantics.
09:10:18 <quicksilver> turiya: you can just blow away (or rename) .ghc
09:10:20 <d-snp> hmm
09:10:35 <d-snp> but the RealWorld state transformer is what ghc does isn't it?
09:10:43 <roconnor> d-snp: I admit the reasons that it doesn't work out are kinda subtle.
09:10:52 <tromp_> :t guard
09:10:54 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:11:26 <roconnor> d-snp: yes, but it is a big hack that basically (adds?) extra strictness to case analysis over RealWorld.
09:11:29 <tromp_> @hoogle Int->Int-Int
09:11:30 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
09:11:30 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
09:11:30 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
09:11:46 <turiya> ha.. neat.. WX can be loaded  now.. :P
09:12:06 <quicksilver> d-snp: No, GHC does not use the RealWorld state transformer.
09:12:06 <roconnor> d-snp: sorry, gotta go for lunch now
09:12:08 <turiya> rm -rf .ghc/ :
09:12:09 <roconnor> later
09:12:12 <benmachine> d-snp: I understand that GHC internally uses impure functions, and uses RealWorld for bookkeeping
09:12:13 <shapr> roconnor: Come to lunch with me!
09:12:16 <quicksilver> d-snp: GHC IO is not implemented inhaskell.
09:12:20 <roconnor> shapr: are you here?
09:12:24 <d-snp> hmm, so why is (forever bar) = (forever foo)
09:12:29 <shapr> roconnor: No, I'm in Alabama :-/
09:12:34 <roconnor> :-/
09:12:38 <d-snp> don't they have 2 different realworlds
09:12:40 <tromp_> @hoogle (a->b->c) -> (d->a)->(d->b)->d->c
09:12:40 <lambdabot> No results found
09:12:40 <benmachine> d-snp: how can you tell them apart?
09:12:44 <d-snp> so aren't they by definitions always different?
09:12:49 <quicksilver> d-snp: GHC IO is implemented in an impure language which superficially resembles haskell
09:12:52 <benmachine> you can't match on the realworlds they produce because they don't produce any
09:12:59 <quicksilver> but is actually quite different because it has real side-effets
09:13:13 <quicksilver> and, as benmachine said, the RealWorld# token is the book-keeping to keep it all sane.
09:13:14 <d-snp> benmachine: so that makes them incomparable, not identical?
09:13:17 <tromp_> is there a std library function Q that does Q f g h x = f (g x) (h x) ?
09:13:41 <d-snp> thanks for the explanation roconnor, eat well :)
09:13:45 <benmachine> d-snp: they have the same meaning
09:13:57 <roconnor> @pl \f g h x -> f (g x) (h x)
09:13:58 <lambdabot> liftM2
09:14:05 <roconnor> tromp_: liftM2
09:14:10 <tromp_> thx
09:14:20 <benmachine> d-snp: it's like, \x -> x and id are the same, even though they are superficially different
09:14:21 <tromp_> :t liftM2
09:14:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:15:42 <d-snp> benmachine: I don't follow, how are \x -> x and id superficially different and how is that analogous to (forever foo) = (forever bar) ?
09:15:52 <augur> can anyone explain "why monads?"?
09:16:11 <d-snp> :t id
09:16:11 <lambdabot> forall a. a -> a
09:16:35 <benmachine> d-snp: I mean, they look different, but they produce the same output on all arguments, so they are equal as functions
09:17:09 <d-snp> ok, but forever foo and forever bar look different, do different things, and have different arguments..
09:17:17 <benmachine> do different things?
09:17:29 <d-snp> ok, they don't do different things
09:17:35 <benmachine> then they're not different :)
09:17:37 <d-snp> because the side effect doesn't count
09:17:50 <d-snp> but they get different arguments
09:18:14 <d-snp> and a function with a different argument might give a different result, and that's what makes the equality
09:18:27 <benmachine> ok you've lost me
09:18:52 <tromp_> isn't ((->) String) a Monad?
09:19:03 <benmachine> tromp_: ((->) r) is, for any r
09:19:11 <benmachine> tromp_: the instance isn't visible by default though
09:19:15 <tromp_> that's what i thought
09:19:22 <tromp_> oh, how to make it visible?
09:19:29 <benmachine> it's in Control.Monad.Instances
09:19:33 <tromp_> have to import reader?
09:19:43 <benmachine> probably also in reader modules
09:20:12 <d-snp> I don't get why you think they give the same output on all arguments..
09:20:33 <tromp_> main=liftM2(>>)putStr print"main=liftM2(>>)putStr print"
09:20:57 <byorgey> preflex: seen LazyCatManatee
09:20:58 <preflex>  Sorry, I haven't seen LazyCatManatee
09:21:01 <d-snp> everytime you give foo a realworld object, it gives you back a new one
09:21:40 <benmachine> d-snp: but forever (putStrLn "foo") doesn't produce *any* realworld
09:21:48 <benmachine> d-snp: it just eats it
09:22:09 <d-snp> :t (putStrLn "foo")
09:22:10 <lambdabot> IO ()
09:22:15 <d-snp> :t forever
09:22:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
09:22:36 <d-snp> eh oh
09:23:03 <benmachine> d-snp: the RealWorlds are continuously fed back into the putStrLn, and you can't get them out
09:23:22 <benmachine> d-snp: try it with a normal State monad
09:23:33 <revenantphx> Can I integrate hlint into ghci?
09:23:39 <yitz> preflex: seen ManateeLazyCat
09:23:39 <preflex>  ManateeLazyCat was last seen on #haskell 4 hours, 11 minutes and 55 seconds ago, saying: @hoogle show
09:23:41 <revenantphx> Other than ':! hlint myfile.hs'
09:23:46 <yitz> byorgey: ^
09:23:49 <benmachine> revenantphx: that's not enough? :P
09:23:54 <byorgey> yitz: ah, thanks =)
09:23:57 <revenantphx> heh its fine
09:24:04 <benmachine> what else do you want?
09:24:18 <d-snp> so.. ghc would sneakily go and break some rules to fetch the realworld objects from a function that would otherwise eat it?
09:24:19 <quicksilver> you can define a ghci command to do that
09:24:38 <quicksilver> d-snp: no, because GHC doesn't actually do any of this.
09:24:49 <benmachine> d-snp: no, ghc just cheats and uses impure functions
09:24:51 <benmachine> or rather
09:24:53 <benmachine> non-haskell
09:25:01 <benmachine> well, same thing I guess :P
09:25:07 <d-snp> :P
09:25:22 <benmachine> a RealWorld value in GHC contains no information
09:25:36 <benmachine> it's like the baton in a relay race, I think
09:25:38 <d-snp> it's just a 'dirty' marker?
09:25:52 <benmachine> it's passed along so things happen in the right order
09:27:22 <d-snp> hmm.. so the changing of the realworld object is actually something that is done impurely too
09:27:45 <turiya> any of you doing a PhD or a post doctorate?
09:28:09 <d-snp> turiya: hit me back in 2 years, I might ;)
09:29:09 <turiya> d-snp: you should, it is good
09:29:28 <byorgey> anyone with any experience with dbus know what I should do about "manatee: DBUS_SESSION_BUS_ADDRESS: getEnv: does not exist (no environment variable)" ?
09:29:51 <byorgey> turiya: I'm doing a PhD.
09:30:34 <turiya> byrogey: cool
09:31:33 <remy_o> me too
09:32:15 <Saizan> byorgey: try running it with dbus-launch
09:36:20 <turiya> thanks quicksilver, Saizan, for helping with the WX issue..crashing 
09:36:46 <byorgey> Saizan: thanks, that works
09:36:49 * hackagebot crypto-api 0.2.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.2.1 (ThomasDuBuisson)
09:39:14 <ash_> i am just learning haskell, so if there is something that explains this somewhere that would be awesome, but can you do something like: [y | x y <- [3...5]] where y is the position in the list and x is the item from the list? i know that example doesn't work, but i haven't really found how to do that one 
09:40:09 <benmachine> ash_: using zip [1 ..] list is a good trick
09:40:13 <byorgey> ash_: you can use the 'zip' function to pair elements of a list with their positions
09:40:23 <benmachine> > zip [1 ..] ["hello", "there", "guys"]
09:40:24 <lambdabot>   [(1,"hello"),(2,"there"),(3,"guys")]
09:40:44 <ash_> ah, cool, thanks
09:40:59 <byorgey> or use [0..] to use zero-based indices
09:41:59 * ash_ nods
09:45:24 <alip> I want to make cabal haddock output somewhere other than dist/doc/$pkg/html, --haddock-option=--odir=/foo/bar doesn't work though :S
09:46:23 <bblum> hey guys, what's the best way to do IntMap.mapKeys :: (Int -> Int) -> IntMap a -> IntMap a ?
09:46:33 <bblum> i.e., that function does not actually exist, and i want its functionality
09:46:36 <dcoutts_> alip: that's only a temporary location, the installed location is specified at configure time with --docdir (or --htmldir)
09:46:37 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
09:46:43 <abstractstone> where can I find a self contained .hs file that factors numbers quickly?
09:47:49 <Saizan> bblum: use fromList/toList
09:48:42 <bblum> Saizan: in any particular manner?
09:49:17 <Saizan> ?type \f -> M.toList . map (\(k,v) -> (f k, v)) . M.fromList
09:49:18 <lambdabot>     Couldn't match expected type `M.Map k a'
09:49:19 <lambdabot>            against inferred type `[(t1, t)]'
09:49:19 <lambdabot>     In the first argument of `(.)', namely `map (\ (k, v) -> (f k, v))'
09:49:30 <Saizan> ?type \f -> M.fromList . map (\(k,v) -> (f k, v)) . M.toList
09:49:31 <lambdabot> forall k a t. (Ord k) => (t -> k) -> M.Map t a -> M.Map k a
09:50:16 <Saizan> if 'f' produces the same key twice one of the elements will be discarded, btw
09:50:18 <Cale> You may want to use fromListWith to handle collisions.
09:51:07 <bblum> hmm
09:53:53 <byorgey> abstractstone: have you tried searching on the Haskell wiki?  there's likely to be a page somewhere with some factoring code
09:54:18 <abstractstone> oh I'll look there, thanks
09:54:28 <revenantphx> Um guys. I have a small issue.
09:54:42 <djahandarie> I have multiple large issues.
09:54:54 <revenantphx> Haskell's Double and Float are instanced with Binary in some weird way.
09:54:58 <revenantphx> Is there any way to get... raw bytes?
09:55:12 <revenantphx> Like, just put the double/float in big endian ear TT_TT
09:56:08 <mtnviewmark> revenatphx - this is, saddly, a well worn problem
09:56:24 <mtnviewmark> the issue is that there is now way to get at the IEEE-754 binary values in pure Haskell
09:56:24 <byorgey> isn't this what the  data-binary-ieee754 package is for?
09:56:43 <revenantphx> that's convenient :|
09:56:51 <revenantphx> Wow. Thanks.
09:56:56 <revenantphx> Thats like "problem solved"
09:58:03 <mtnviewmark> If I recall - that is VERY VERY slow
09:58:30 <revenantphx> like, how slow D:
09:58:57 <zygoloid> slower than unsafeCoerce to Int64 *duck*
09:59:11 <revenantphx> Oh god. t uses unsafePerformIO (figures)
09:59:16 <revenantphx> F.castPrt!?
09:59:21 <revenantphx> Oh shit, it's INTERFACING WITH C.
09:59:26 <revenantphx> At least I think.
09:59:32 <zygoloid> FFFFUUUUUUU... ;)
09:59:48 <revenantphx> should be fine for now, until I have an alternative.
10:00:02 <revenantphx> mtnviewmark: how would it compare to a malloc or three?
10:00:15 <mtnviewmark> no - there is one if you are GHC specifc
10:00:16 <djahandarie> It isn't interfacing with C, it's just doing manual memory management
10:00:23 <mtnviewmark> http://bitbucket.org/lindenlab/llsd/src/ab26307d0db8/haskell/Network/Format/LLSD/IEEE754.hs
10:00:27 <mtnviewmark> look at that code
10:00:41 <mtnviewmark> it is very fast, and safe, 
10:00:57 <mtnviewmark> if I recall, you might have to NOINLINE pragmas on those
10:00:59 <djahandarie> It says unsafe right in the definition!
10:01:04 <mtnviewmark> otherwise it tickles a bug in some versions of GHC
10:01:30 <mtnviewmark> true - there is no cheep safe way to get the IEEE-754 values as they are not defined in the language that way
10:01:38 <augur> guise
10:01:40 <augur> why monads
10:01:55 <Zao> augur: Why not?
10:02:01 <augur> Zao: :P
10:02:37 <augur> i just see a bunch of things that say "oh yay, we can do a monadic analysis!"
10:02:47 <augur> and im curious why we like aiming for monads
10:02:51 <mtnviewmark> but - unsafe in my code is pretty safe: the only thing it is requiring is that size of W64# is the size of D#
10:03:06 <Zao> augur: Because it's a common idiom due to it being commonly used in the Prelude?
10:03:10 <copumpkin> augur: I try to avoid monads if I can
10:03:13 <Zao> s/Prelude/report or whatever/
10:03:23 <Saizan> augur: http://www.haskell.org/haskellwiki/Monads_as_computation#Motivation
10:03:34 <mtnviewmark> bos: didn't you have an improved version of that IEEE-754 code somewhere?
10:03:35 <augur> Saizan: !
10:03:36 <Saizan> that's for monads in programming languages
10:04:08 <Saizan> but i guess in CT you can substitute "embedded domain specific language" with "an algebra"
10:05:33 <augur> ya
10:06:04 <Saizan> and what you reuse are theorems :)
10:07:08 <bos> mtnviewmark: uh, i did, but i forget where
10:07:10 <augur> Saizan: did you see my blog post?
10:07:27 <mtnviewmark> fie
10:07:27 <Saizan> augur: i don't think so
10:07:31 <augur> http://www.wellnowwhat.net/blog/?p=434
10:07:37 <augur> i'd love your opinion
10:08:46 <Eduard_Munteanu> o/
10:09:26 <augur> \o
10:10:47 <arcatan> \o/
10:11:17 <Eduard_Munteanu> Could somebody take a look at this and tell me why it is so slow compared to an almost equivalent C code? http://paste.pocoo.org/show/298551
10:11:50 <Eduard_Munteanu> It's Shannon-Fano compression. Basically I build a tree then lookup symbol codes in it, and pack them into bytes bit by bit.
10:12:29 <Eduard_Munteanu> On a ~ 1.5MiB file, this runs in 2.5s, while the C code runs in 0.3s.
10:13:04 <Eduard_Munteanu> I kinda tried everything so far, it's compiled with -O2, tried unboxing strict fields etc., but I can't really make it faster.
10:14:33 <Eduard_Munteanu> Profiling generally places the burden on lookupCode and pack, but I'm clueless how I could make those faster.
10:15:54 <Eduard_Munteanu> (I'm interested about the compression part mostly.)
10:17:41 <Saizan> augur: shouldn't "âŸ¦râŸ§ = lift_n(âŸ¦râŸ§)" be "âŸ¦râŸ§ = lift_n(r)" ? otherwise it seems circular to me
10:21:45 <augur> Saizan: probably, lemme check
10:21:49 <roconnor> Eduard_Munteanu: using [Bool] seems bad
10:22:55 <augur> Saizan: ahh, yeah, sorry, i had had other stuff there and tried to simplify XD
10:23:17 <Botje> Eduard_Munteanu: why not build the binary number directly?
10:23:26 <roconnor> Eduard_Munteanu: unless you think it will fuse/deforest away, and since you aren't using Higher order combinators, that seems unlikely to fuse/deforest.
10:23:45 <Eduard_Munteanu> roconnor: I already tried using BitPut inside compress, thus not using any list of Bools, but it didn't improve things.
10:23:53 <Eduard_Munteanu> (inside compress _and_ lookupCode)
10:24:23 <Eduard_Munteanu> Botje: well it's not that easy, compressing one symbol yields a variable number of bits.
10:24:49 <roconnor> @hoogle BitPut
10:24:49 <lambdabot> No results found
10:24:55 <roconnor> I don't know what BitPut is
10:25:04 <Eduard_Munteanu> roconnor: http://hackage.haskell.org/packages/archive/binary-strict/0.4.8/doc/html/Data-Binary-BitPut.html
10:25:18 <Botje> Eduard_Munteanu: so shift left and or ?
10:25:45 <Eduard_Munteanu> BitPut might even be slower though. It's basically a monad which packs bits to ByteStrings.
10:26:26 <Eduard_Munteanu> Botje: I tried it using BitPut. The only thing I didn't try yet is writing lookupCode on top of some ST and packing them myself.
10:26:34 <Botje> also, have you tried IntSet instead of Set?
10:26:46 <Eduard_Munteanu> Botje: hm, no.
10:26:54 <Eduard_Munteanu> Thanks, I'll have a try.
10:26:58 <roconnor> Eduard_Munteanu: isn't a monad which packs bits into ByteStrings exactly what you want?
10:27:06 <Botje> another idea to get rid of the tree
10:27:12 <Eduard_Munteanu> roconnor: yes.
10:27:32 <Botje> is to use a big-ish array, and simply use the lookup path you use as index
10:27:44 <Botje> (so 1110 is array ! 0b1110)
10:27:46 <roconnor> Eduard_Munteanu: so use BitPut
10:28:20 <Eduard_Munteanu> roconnor: I already tried, it doesn't improve performance at all, I think it's even a bit slower.
10:29:02 <roconnor> Eduard_Munteanu: did you try using BitBuilder?
10:29:16 <Eduard_Munteanu> roconnor: nope, /me looks that up
10:29:21 <roconnor> http://hackage.haskell.org/packages/archive/binary-strict/0.4.8/doc/html/Data-Binary-BitBuilder.html
10:29:23 <Eduard_Munteanu> Botje: hm, that could work.
10:29:40 <Saizan> augur: are you familiar with applicative functors?
10:29:43 <Eduard_Munteanu> But I never thought I'd use more abstraction in the C variant than in Haskell :)
10:29:48 <augur> Saizan: not yet
10:30:25 <Botje> Eduard_Munteanu: I think the [Bool] is your biggest source of misery
10:31:28 <Eduard_Munteanu> Botje: maybe, but when I tried BitPut instead of [Bool] things got even slower.
10:31:38 <Botje> yes yes, i saw that
10:31:51 <roconnor> Eduard_Munteanu: I think BitBuilder will be better for you than BitPut
10:31:52 <Saizan> augur: i guess it wouldn't help much since your normal denotations for terminals are uncurried, but otherwise using (<*>) would avoid the need for the lift_n family, you'd just need lift_0 and (<*>) where the latter is the S combinator from the SKI calculus, (and lift_0 is K)
10:32:01 <Eduard_Munteanu> Yep, I'm coding that right now.
10:32:30 <augur> Saizan: well, no, im assuming the terminals are curried, but i wanted to keep the thing simple
10:32:38 <roconnor> Make sure all your supporting libraries are compiled with -O2.  ... Does cabal do that by default now?
10:32:53 <augur> so if theres a way to do the lifting magically, sure, but, for this presentation..
10:33:04 <augur> Saizan: ill take a look at af's. links??
10:33:12 <Eduard_Munteanu> roconnor: hm, I didn't think about that.
10:33:27 <Eduard_Munteanu> I wonder if Gentoo's ebuilds do supply -O2.
10:33:47 <roconnor> Eduard_Munteanu: heh, I only know of this because I found out that back in the day Unbuntu packages were not built optimized :O
10:34:03 <Eduard_Munteanu> Aww, I'd really love if this was the problem.
10:34:30 <Saizan> augur: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Applicative.html and the paper linked from it
10:34:49 <Botje> Eduard_Munteanu: come on, it's gentoo :P
10:35:05 * Eduard_Munteanu wonders if there's a GHCFLAGS
10:35:32 <Eduard_Munteanu> I'm using the +binary GHC so I guess base libs are optimized.
10:36:38 <Eduard_Munteanu> (though if it was built by Gentoo people, IDK)
10:36:43 <dcoutts_> roconnor: the default is -O
10:36:52 <dcoutts_> roconnor: because that is the default optimisation level
10:37:29 <roconnor> Eduard_Munteanu: so there you go, if you are using cabal your code is slow ;)
10:37:39 <roconnor> (by default)
10:38:13 <dcoutts_> -O2 should be used selectively
10:38:34 <Eduard_Munteanu> Yeah, or at least -O, they should be about the same.
10:38:43 <roconnor> Eduard_Munteanu: so there you go, if you are using cabal your code is less likely to have errors made by the compiler ;)
10:38:43 <yitz> dcoutts: why does the dependancy of directory on unix/Win32 not show in hackage?
10:38:55 <Eduard_Munteanu> Heh :).
10:39:01 <dcoutts_> yitz: it's doing something funny with conditional deps I think
10:39:08 <conal> jmcarthur: ping
10:39:11 <yitz> dcoutts: and why does ghc ignore me when i hide new unix and try to use directory?
10:39:19 <dcoutts_> yitz: I've never tried to understand that code, I think it's taking the wrong approach
10:39:23 <revenantphx> Yay. In class we're finally hitting interfaces.
10:39:32 <yitz> dcoutts_: sure looks that way :)
10:39:33 <revenantphx> hurray for polymorphism.
10:39:34 <dcoutts_> yitz: not sure what you mean exactly
10:39:36 <revenantphx> <3 <3 <3
10:39:51 <dcoutts_> yitz: heh, I mean the approach of disjunctive normal form
10:40:08 <yitz> dcoutts_: oh :)
10:40:26 <augur> Saizan: check it now ey? :D
10:40:40 <yitz> dcoutts_: so what didn't you understand in what i said then?
10:40:48 <dcoutts_> yitz: about hiding unix
10:41:14 <Eduard_Munteanu> Is there a way to ask GHC what flags have been used to build it?
10:41:28 <Eduard_Munteanu> I might be able to generalize them to the rest of the base packages.
10:41:32 <yitz> dcoutts_: ghci -hide-package unix-<new> is ignored, it loads it anyway when you use the directory package, causing directory to fail.
10:41:36 <Saizan> augur: i'm not sure what a category label/head is :)
10:41:44 <revenantphx> Holy shit, is he completely missing the point of interfaces?
10:41:45 <revenantphx> I hope not D:
10:42:50 <Eduard_Munteanu> -O --enable-optimization[=n]      Build with optimization (n is 0--2, default is 1)
10:42:58 <Eduard_Munteanu> That's from cabal install --help
10:43:10 <revenantphx> He's explaining interfaces without anyone knowing how subclasses work.
10:43:13 <revenantphx> This is a bit silly.
10:43:14 <Eduard_Munteanu> Oh wait, that means it's -O1 if -O is supplied I guess.
10:43:50 <dcoutts_> yitz: presumably the directory package depends on the unix package
10:44:12 <yitz> dcoutts_: it apparently does, even though that does not show on hackage.
10:44:16 <Saizan> augur: though i guess that in "âŸ¦r_CâŸ§ = liftn(âŸ¦râŸ§)" âŸ¦râŸ§ is supposed to be the "normal denotation" ?
10:44:48 <dcoutts_> yitz: ghc-pkg field directory depends
10:44:54 <dcoutts_> yitz: and yes it does
10:44:56 <yitz> dcoutts_: but this happens even if i use an old version of directory that definitely does not require the new version of unix. so if i hide the new version of unix, why does directory not use the old version?
10:45:06 <kmc> revenantphx, i don't think so.  it's good to keep the two concepts separate
10:45:22 <dcoutts_> yitz: it always uses the version it was compiled against, hiding is irrelevant
10:45:44 <kmc> inheritance for code reuse is almost always a bad idea, imo
10:46:01 <yitz> dcoutts_: so re-install directory, hiding the new unix in cabal?
10:46:09 <Eduard_Munteanu> roconnor: nope, looks like cabal install is already supplying -O2, I just did 'cabal install --reinstall -v binary'
10:46:18 <dcoutts_> yitz: what are you trying to do exactly?
10:46:26 <revenantphx> kmc: Well yes, but they're predictably going to get confused.
10:46:29 <revenantphx> Ah, yep.
10:46:31 <revenantphx> There one goes
10:46:34 <revenantphx> "So this is how X works"
10:46:35 <dcoutts_> Eduard_Munteanu: that'll be because the binary package specifies -O2
10:46:41 <revenantphx> (where X is using superclasses, not interfaces)
10:46:47 <yitz> dcoutts_: enable System.Directory.doesDirectoryExist. it doesn't work currently on mac.
10:46:48 <kmc> it's regrettably necessary in poorly-designed OOP languages, where alternatives like proxying method calls to a contained object are cumbersome
10:47:21 <kmc> and it's popular even outside that context because most of the world thinks OOP = must emulate Java's design flaws
10:47:43 <monochrom> don't boast how you know about OO until you have learned clos, smalltalk, and scala.
10:47:46 <dcoutts_> yitz: ok, so I'd specify --constraint='unix == x.y.z' when you reinstall the directory package
10:47:46 <EvanCarroll> I just deleted rm -rf`ed /home/USER/.cabal, now I see `ghc-pkg check` fails
10:47:53 <Eduard_Munteanu> dcoutts_: actually I'm seeing "-O -O2 -Wall -fliberate-case-threshold=1000 [...]"
10:47:56 <monochrom> or at least ocaml
10:48:03 <Eduard_Munteanu> dcoutts_: could it be cabal already supplies -O at least?
10:48:10 <EvanCarroll> how do I get it working, I can't believe that needed shit was installed to my user directory rather than shared (like perl)
10:48:10 <dcoutts_> Eduard_Munteanu: yep
10:48:23 <yitz> dcoutts_: ok i'll try it. think it will work with the new directory package, or should i just do the old one?
10:48:39 <Eduard_Munteanu> Ok, so I'm good there.
10:49:12 <Eduard_Munteanu> It doesn't make me happy though, it means GHC doesn't deforestate my code well enough.
10:49:13 <dcoutts_> yitz: I'd just be guessing
10:49:18 <Saizan> EvanCarroll: rm -fr ~/.ghc as well, so at least it won't look for the files you've deleted
10:49:31 <yitz> dcoutts_: ok we'll see :) thanks
10:54:35 <revenantphx> hey guys
10:54:42 <revenantphx> Theres only up to LiftM5
10:54:45 <revenantphx> I need LiftM7
10:54:46 <revenantphx> halp.
10:55:05 <c_wraith> write it yourself :)
10:55:06 <sioraiocht> revenantphx: you could write it?
10:55:16 <c_wraith> or, you know, use Applicative
10:55:20 <revenantphx> true, but then I have to wrry about it conflicting with other peoples code, if they did it too.
10:55:32 <monochrom> Haskell 2134 will include liftM7
10:55:33 <sioraiocht> revenantphx: no you don't
10:55:38 <revenantphx> ?
10:55:43 <sioraiocht> just don't export that function
10:55:45 <c_wraith> Just use Applicative.
10:55:45 <sioraiocht> from your module
10:55:46 <monochrom> just don't export it
10:55:47 <revenantphx> oh, right you can choose what to export.
10:55:49 <revenantphx> >_<
10:55:59 <mee> that should really be an operator
10:56:21 <c_wraith> mee, can't be.  It uses name and operator characters
10:56:46 <unkanon> is it possible to do pattern matching in a where clause?
10:56:55 <mee> aw. :(
10:57:00 <c_wraith> You can pattern match in any assignment.
10:57:15 <c_wraith> err, in any name binding, to be more precise :)
10:57:26 <sioraiocht> c_wraith: the pendant squad almost attacked, there
10:57:38 <c_wraith> I know, they're dangerous
10:57:41 <revenantphx> How can you specify which instances to export?
10:57:42 <unkanon> c_wraith: how do I do it?
10:57:46 <revenantphx> Or are they ALWAYS exported?
10:57:47 <c_wraith> and they have necklaces :)
10:57:53 <yitz> unkanon: you can do it in a name binding as c_wraith says. you can also use case.
10:57:56 <c_wraith> instances are always exporteded
10:58:03 <c_wraith> ...  with an extra "ed"
10:58:29 <roconnor> revenantphx: welcome to a huge wart in Haskell.
10:58:31 <unkanon> yitz: c_wraith: let p10 [] = []; p10 (ys) = (length x, head x) : p10 xs where (x:xs) <- p9 ys
10:58:44 <revenantphx> roconnor: what's the issue?
10:58:47 <c_wraith> ah.  you can't use <- there in a where clause
10:58:50 <revenantphx> and how can it be fixed? (will it be?)
10:58:54 <roconnor> revenantphx: instances are always exported
10:59:04 <unkanon> c_wraith: and = doesn't work either so how do I do?
10:59:06 <c_wraith> <- is only valid within a do block
10:59:13 <unkanon> c_wraith: that's what I thought
10:59:23 <unkanon> I only tried <- because = didn't work
10:59:24 <c_wraith> and...  what's the type of p9?
10:59:47 <unkanon> @let p9 [] = []; p9 xs@(x:xs') = (takeWhile ((==) x) xs) : p9 (dropWhile ((==) x) xs')
10:59:49 <lambdabot>  Defined.
10:59:52 <kmc> liftM7 x a b c d e f g = x <$> a <*> b <*> c <*> d <*> e <*> f <*> g
10:59:53 <unkanon> p9 "aaaabbbcccddefff"
10:59:56 <unkanon> > p9 "aaaabbbcccddefff"
10:59:59 <lambdabot>   ["aaaa","bbb","ccc","dd","e","fff"]
11:00:07 <c_wraith> I mean, the syntax "where (x:xs) = p9 ys" is fine.
11:00:09 <unkanon> c_wraith: ^
11:00:16 <c_wraith> But it creates an irrefutable pattern match
11:00:26 <c_wraith> meaning that you'll get an error if the result was []
11:00:52 <unkanon> oh!
11:01:00 <unkanon> so I have to handle the [] case inside the where?
11:01:32 <c_wraith> If it's possible, you need to handle it somehow
11:01:45 <c_wraith> At the moment, you're claiming it's not possible
11:01:48 <unkanon> @let p10 [] = []; p10 (x:xs) = (length x, head x) : p10 xs
11:01:49 <lambdabot>  Defined.
11:01:59 <unkanon> > p10 . p9 $ "iaaaaabbbbbcccedtttaa"
11:02:00 <lambdabot>   [(1,'i'),(5,'a'),(5,'b'),(3,'c'),(1,'e'),(1,'d'),(3,'t'),(2,'a')]
11:02:04 <yitz> > let ans = x where {Just x = lookup 3 (zip [1..] "abcdefg" )} in ans
11:02:05 <lambdabot>   'c'
11:02:20 <unkanon> c_wraith: ^ I'm just trying to avoid having to call it like that
11:02:31 <unkanon> c_wraith: I want to only call p10, not p10 . p9 $
11:03:03 <unkanon> c_wraith: in other words, I want p10 to only work on the result of p9, and I'd like for that to happen inside p10 
11:03:14 <c_wraith> unkanon, fundamentally, if p9 can return an empty list, p10 has to pattern match on the result of p9.  You can't do that in an irrefutable pattern match, which is what you get in a where or let
11:03:35 <unkanon> so what are my choices for solving this?
11:03:49 <c_wraith> You need to either use a case statement or create a helper function.  the case statement is probably easier
11:04:02 <yitz> unkanon: if you define a function in the where, it can have multiple equations that match whatever you need
11:04:48 <unkanon> so I'd have to declare p9 again inside a where clause inside p10?
11:04:57 <c_wraith> Not at all.
11:05:06 <c_wraith> but I really think using a case statement is clearer
11:05:07 <revenantphx> if I do module ( ) where
11:05:11 <Eduard_Munteanu> roconnor, Botje: http://paste.pocoo.org/show/298568   -- I changed lookupCode and compress to use BitBuilder but it seems more than twice slower.
11:05:14 <Eduard_Munteanu> *sigh*
11:05:14 <revenantphx> it exports everything still.
11:05:36 <c_wraith> revenantphx, how are you determining what it exports?  :load in ghci ignore the export list
11:05:44 <revenantphx> >_>
11:05:46 <revenantphx> figures.
11:05:57 <c_wraith> :load puts you inside the namespace of the module
11:06:04 <revenantphx> ah :m +module...
11:06:05 <c_wraith> rather than giving you an external namespace
11:06:30 <revenantphx> so I'd use :m +modulename?
11:06:31 <unkanon> c_wraith: like where result = case p9 xs of ... and pattern match in there?
11:06:41 <revenantphx> awesome, perfect.
11:06:54 <EvanCarroll> Saizan++ # thanks
11:07:11 <Eduard_Munteanu> I even used an accumulator and foldl' and whatnot :/
11:07:16 <revenantphx> what about data types?
11:07:30 <c_wraith> unkanon, actually, I'd do it with p10 ys = case p9 ys of ...
11:07:33 <revenantphx> They don't seem to be being exported.
11:07:44 <Eduard_Munteanu> How come these libs are slower than code _I_ wrote... :)
11:08:27 <c_wraith> unkanon, where ... would expand to (x:xs) -> ... ; [] -> ...
11:09:20 <unkanon> c_wraith: oh I think I got it now, thanks!
11:09:35 <revenantphx> One question...
11:12:29 <swarmer> is it possible to write multi-line function type signature in haskell?
11:12:49 <c_wraith> swarmer, sure.  Just make sure the lines other than the first are indented
11:13:04 <swarmer> thanks
11:14:32 <dpratt71> apologies for a not so quick question: I'm toying around with something in Haskell that represents a board game or a puzzle, of sorts...
11:15:14 <dpratt71> ...and thinking about how to represent something where the contents of cells in some grid will change as the game progresses...
11:16:23 <dpratt71> ...I came across a technique some time ago that would seem to fit what I want, but I'm not 100% sure it's the best approach...
11:17:02 <dpratt71> essentially, the grid state is represented as a function from cell id to cell value...
11:17:57 <dpratt71> ...to modify the value of a cell, construct a new function that returns the new value for the specified cell, otherwise delegates to the 'old' function. Does that explanation make sense?
11:18:01 <c_wraith> preflex: seen blackh
11:18:01 <preflex>  blackh was last seen on #haskell 17 hours, 2 minutes and 10 seconds ago, saying: aavogt: I was just talking about the fact that IO enables you to express things like "modifyIORef xRef (1+)", which is not referentially transparent.  From my point of view, this constitutes "part of your Haskell program".  You could argue that IO actions are not Haskell programs, but that's just semantics.
11:19:08 <Eduard_Munteanu> dpratt71: it sounds a bit contrived, why not use an array or a map?
11:20:45 <dpratt71> Eduard_Munteanu: how would one mutate an individual element of an array? copy the array? 
11:21:23 <mauke> no, you'd use a mutable array
11:22:51 <dpratt71> mauke: I see; does that involve the ST and/or IO Monads or somesuch?
11:22:59 <mauke> yes
11:23:13 <mauke> but their monaditude is not really important here
11:23:18 <mauke> it involves ST or IO
11:23:23 <Eduard_Munteanu> Or DiffArray but it's currently having performance issues.
11:23:45 <dpratt71> mauke: is there any significant advantage to keeping things 'pure'?
11:24:03 <mauke> I don't know
11:24:14 <Eduard_Munteanu> They are pure, perhaps monadic though.
11:24:31 <unkanon> is there a way to declare data types in ghci?
11:24:46 <c_wraith> unkanon, no.
11:24:53 <Eduard_Munteanu> But since it's a game you're dealing with IO anyway, I'd just take care to keep evaluation as a a non-monadic function and lift that.
11:25:01 <unkanon> c_wraith: aww I was having so much fun without files :)
11:25:24 <c_wraith> unkanon, maybe in a future version of ghci.  Everyone involved acknowledges it would be a good feature.
11:25:35 <c_wraith> it's just a matter of finding time to implement it
11:25:53 <unkanon> cool, I'll keep an eye on out for new tickets on this
11:27:40 <dpratt71> Eduard_Munteanu: thanks for the advice
11:30:47 <dpratt71> as I look at the Map type and it's associated operations, I think it may be what I was trying to conjure...but I'm not sure
11:32:13 <augur> Saizan: yeah, basically
11:32:45 <Eduard_Munteanu> roconnor, Botje: IntSet improved things by 400ms. Now it's 2.1s Haskell vs 0.3s C
11:32:57 <Eduard_Munteanu> But I had to give up BitBuilder it was hellishly slow.
11:33:09 <Eduard_Munteanu> My [Bool] thingy is faster.
11:33:16 <Eduard_Munteanu> But I still don't like performance.
11:33:16 <kmc> dpratt71, the nice thing about Map is that updating is pure functional, but without a full copy
11:33:17 <monochrom> God, HaLVM lets you write haskell OSes on top of Xen...
11:33:37 <kmc> it copies O(log n) data, and shares the rest with the old copy
11:33:49 <ash_> can you compile haskell for an embedded system like an AVR or an ARM?
11:33:52 <Eduard_Munteanu> monochrom: it still uses GHC's RTS, IIRC
11:33:58 <augur> Saizan: i mean, i'd like to have compositional principles that don't need to make reference to a million different individual things, you know? lifting things into the reader domain should be a generic process that happens to things, but then how does that work at the terminals, you need a way to get the denotations of those terminals, but you also need some way to trigger the lifting
11:33:59 <Eduard_Munteanu> Which isn't that cool I think.
11:34:01 <kmc> and the nice thing about *Haskell* is that writing data structures in the natural idiomatic way gives you this behavior
11:34:08 <augur> i suppose you could have some sort of secondary operation for terminals
11:34:22 <augur> [[r]] = lift0(lex(r)) or something
11:34:24 <kmc> ash_, pretty big difference there... Debian has ARM GHC packages
11:34:35 <kmc> for the bigger ARMs that run Linux and such
11:34:37 <augur> i was just trying to stick with traditional semantic notations :p
11:34:44 <kmc> for small embedded systems you might use JHC (lower code size)
11:34:57 <kmc> but you probably can't use Haskell anyway because Haskell programs tend to use a lot of RAM
11:35:07 <kmc> so you could use something like "atom" (a Haskell-embedded domain specific language)
11:35:18 <kmc> there's a tutorial somewhere on programming the Arduino in atom
11:35:20 <Eduard_Munteanu> Does anybody have suggestions? http://paste.pocoo.org/show/298587/
11:35:51 <monochrom> \âˆ©/ new haskell.org server and face
11:36:13 <monochrom> (so, did any disaster happen yesterday during the move? :) )
11:37:36 <ash_> thanks kmc, that helps
11:37:37 <revenantphx> How many people here have implemented liftM6 or greater?
11:37:47 <kmc> i've not.  just use Applicative revenantphx
11:37:53 <revenantphx> what do you mean by that anyhow
11:37:58 <kmc> liftM7 x a b c d e f g = x <$> a <*> b <*> c <*> d <*> e <*> f <*> g
11:38:10 <kmc> the operators (<$>) and (<*>) live in Control.Applicative
11:38:13 <Eduard_Munteanu> That or refactor your code using Reader or something.
11:38:19 <kmc> it's actually more general this way
11:38:21 <monochrom> first suggestion (superficial): use a better pastebin so â†’ doesn't get a red box like in the old days do-gooders mark adultery offenders with the scarlet letter.
11:38:26 <Eduard_Munteanu> Do you really need all those separate params?
11:38:32 <revenantphx> kmc: that's amusing.
11:38:38 <kmc> it works for every instance of Applicative, which is morally a superclass of Monad
11:38:45 <revenantphx> ...morally?
11:38:57 <kmc> meaning that Applicative was invented later, so the actual code does not enforce this
11:38:57 <remy_o> :src Applicative
11:39:00 <Eduard_Munteanu> monochrom: I would but copy-pasting from Vim into hpaste seems to wreck Unicode, so I'm using wgetpaste which doesn't support hpaste.
11:39:05 <kmc> but you can write a 2-line boilerplate Applicative instance for any Monad instance
11:39:09 <Eduard_Munteanu> Heh.
11:39:24 <Botje> Eduard_Munteanu: what's the slowest now?
11:39:37 <kmc> and most "standard" monads have Applicative already
11:39:41 <Eduard_Munteanu> Botje: uh, I didn't profile, lemme see...
11:40:08 <kmc> revenantphx, if you already understand Monad, then you can understand Applicative as what you get with *only* return and liftM*
11:40:11 <kmc> but not (>>=)
11:40:20 <kmc> in other words, you can perform some actions and feed the results into a function
11:40:26 <revenantphx> kmc: Applicative confused me and still does.
11:40:27 <kmc> but you can't perform one action and use its result to choose what to do next
11:40:31 <kmc> revenantphx, did you read Typeclassopedia?
11:40:36 <kmc> what are you confused about?
11:40:46 <revenantphx> Just... the point of applicative.
11:40:52 <revenantphx> or rather
11:40:54 <revenantphx> what they represent
11:41:05 <revenantphx> Like functors represent something than can be mapped over... so what's an applicative?
11:41:16 <kmc> something that can be liftM'd over
11:41:23 <kmc> except now we call it liftA*
11:41:26 <Eduard_Munteanu> Botje: http://paste.pocoo.org/show/298590
11:41:31 <Eduard_Munteanu> Botje: seems like lookupCode
11:41:41 <sipa1024> can someone give an example of a non-applicative functor?
11:41:58 <Eduard_Munteanu> I'm really worried about those allocations though, maybe that's a bottleneck?
11:42:01 <kmc> :t fmap
11:42:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:42:06 <kmc> :t (<*>)
11:42:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:42:12 * Eduard_Munteanu thinks region inference wouldn't be a bad idea to have in GHC :/
11:42:30 <kmc> revenantphx, the key difference is "a -> b" versus "f (a -> b)"
11:42:48 <kmc> if fmap maps a function over a container, then (<*>) maps a *container* of functions over a container
11:42:53 <dpratt71> kmc: just caught your comment to me, thanks; it is a property that I would like to retain, if possible, if for no other reason than pedantry
11:43:05 <remy_o> sipa1024: a -> (a,Int) is a non-applicative functor
11:43:11 <kmc> and this turns out to be enough to implement liftA2, liftA3, ...
11:43:55 <revenantphx> kmc... so you could map a list of functions over a list?
11:43:57 <kmc> remy_o, you mean data F a = F (a, Int)
11:43:59 <kmc> revenantphx, yes
11:44:05 <revenantphx> And if you did, would it do every combination or match the indices
11:44:11 <kmc> > [pred,succ] <*> [5,8]
11:44:12 <lambdabot>   [4,7,6,9]
11:44:18 <revenantphx> lambdabot works!
11:44:24 <kmc> revenantphx, there's actually *two* consistent Applicative instances for lists
11:44:29 <revenantphx> ?
11:44:33 <remy_o> kmc: yes
11:44:35 <kmc> that one matches the list monad and uses all pairs
11:44:41 <kmc> the other can be had by using the "ZipList" wrapper
11:44:47 <kmc> > ZipList [pred,succ] <*> ZipList [5,8]
11:44:48 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
11:44:48 <lambdabot>    arising ...
11:44:55 <kmc> > fromZipList (ZipList [pred,succ] <*> ZipList [5,8])
11:44:56 <lambdabot>   Not in scope: `fromZipList'
11:44:59 <kmc> grr
11:45:19 <kmc> > getZipList (ZipList [pred,succ] <*> ZipList [5,8])
11:45:20 <lambdabot>   [4,9]
11:45:22 <kmc> yeah
11:45:50 <kmc> so in one case liftAn gives the Cartesian product of the lists 
11:45:58 <kmc> in the other case liftAn = zipn
11:46:06 <kmc> for n in 2,3,...
11:46:19 <jro> do you put all your tests in a project to a single file?
11:46:24 <Botje> Eduard_Munteanu: lists occupy 24 bytes per cell
11:46:45 <Botje> so they are pretty alloc-heavy
11:46:46 <revenantphx> Oh, thats useful :\
11:46:50 <Eduard_Munteanu> I see.
11:47:10 <revenantphx> wait, what did you just do with... zip lists?
11:47:17 <sipa> Botje: on both 32-bit and 64-bit systems?
11:47:22 <Eduard_Munteanu> Botje: well my 'pack' isn't really fast but I'm astounded it's the fastest thing for this so far. It still takes like 33% of the time.
11:48:05 <Eduard_Munteanu> sipa, Botje: I'm on 64-bit if it matters.
11:48:07 <chrisdone> jro: if the project is small
11:48:07 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:48:17 <chrisdone> for anyone interested in discussing development of lisk, there is a #lisk channel now
11:48:18 <Botje> on 64bit it's a bit bigger, i guess
11:48:43 <chrisdone> @messages
11:48:43 <lambdabot> alpounet said 7d 20h 14s ago: *awesome* post about has and has-th. Thanks!
11:48:44 <lambdabot> djahandarie said 6d 21h 9m 22s ago: Add SQL to hpaste?
11:48:45 <Eduard_Munteanu> It could be that deforestation really works out there.
11:48:54 <unkanon> kmc: I eavesdropped your explaining Applicatives >:P - things make more sense to me now. thanks.
11:49:00 <Eduard_Munteanu> But could it be that hPut isn't reading the list linearly?
11:49:06 <chrisdone> lambdabot already showed me these messages
11:49:10 <jro> I'm using cabal test to run the tests, with a hook that it runs program called "test" in buildDir
11:49:12 <Eduard_Munteanu> That could be a bottleneck.,
11:49:20 <Eduard_Munteanu> *the Bytestring.
11:49:22 <chrisdone> jro: yeah, I use the same thing
11:49:22 <zygoloid> lists are 24 bytes per cons on 64-bit and 12 bytes per cons on 32-bit
11:49:55 <Eduard_Munteanu> Maybe I could mapM_ hputting individual words.
11:49:58 <unkanon> zygoloid: are lists doubly-linked, then?
11:49:59 <jro> is there "standard" way to separating tests to different parts
11:50:04 <Eduard_Munteanu> unkanon: no
11:50:21 <unkanon> I thought 12 bytes = 2 4 byte pointers + 4 bytes of data
11:50:22 <zygoloid> unkanon: no, GHC's RTS adds a pointer for its own purposes.
11:50:26 <chrisdone> jro: with the cabal test you can provide an argument, e.g. cabal test this, cabal test that
11:50:28 <unkanon> zygoloid: oh ok
11:50:42 <Eduard_Munteanu> unkanon: not really, the thunk is a bit more complex, it has to keep track of evaluation and such
11:50:46 <dcoutts_> jro, chrisdone: Cabal-1.10 has direct support for test progs like that, without any need to write a test hook
11:51:05 <unkanon> Eduard_Munteanu: I see
11:52:15 <Botje> Eduard_Munteanu: tiny tweak, maybe .. eight' = take 8 (take 8 xs ++ [0,0,0,0,0,0,0,0])
11:53:55 <Eduard_Munteanu> Botje: how does that work?
11:54:22 <Botje> uh, replace the zeros by False :)
11:54:44 <djahandarie> If I have a big list of [(Double, Double)], is there a way to make that not spam the hell out of my core?
11:54:59 <Eduard_Munteanu> Botje: oh, and that way remove the padding part.
11:54:59 <Botje> Eduard_Munteanu: also, does replacing the ifs with fromEnum help?
11:55:08 <Eduard_Munteanu> Hmm, possibly
11:55:12 <Eduard_Munteanu> > fromEnum False
11:55:13 <lambdabot>   0
11:55:24 <Botje> fromEnum a `shiftL` 7
11:55:27 <Botje> and so on
11:55:42 <Botje> although i guess ghc is smart enough for that
11:57:23 <Botje> Eduard_Munteanu: and you only need to pad if rest is null, too
11:57:45 <Botje> also, also, splitAt :o)
11:58:20 <unkanon> > repeat 8 0
11:58:21 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
11:58:34 <kmc> revenantphx, each type can only have one Applicative instance
11:58:39 <unkanon> > replicate 8 0
11:58:40 <lambdabot>   [0,0,0,0,0,0,0,0]
11:58:42 <Botje> (eight, rest) = splitAt 8 xs; eight' = if null rest then take 8 (eight ++ replicate 8 False) else eight
11:58:44 <kmc> and like i said, there's two reasonable instances for []
11:58:45 <unkanon> do that instead of its result :)
11:58:47 <unkanon> yeah
11:59:04 <kmc> so the actual type [] gets the all-pairs instance
11:59:13 <kmc> and then we have: newtype ZipList a = ZipList { getZipList :: [a] }
11:59:13 <Botje> Eduard_Munteanu: that way you save another traversal of your list
11:59:16 <kmc> with the other instance
11:59:23 <revenantphx> Oh... I see.
11:59:34 <Botje> Eduard_Munteanu: your current code has three , now you only have one
11:59:35 <kmc> this is a common trick for making alternative instances for a type
11:59:38 <revenantphx> I'd hate to think of applicative 4d vectors :D
11:59:41 <Botje> that's hopefully good for a bit of a speedup
11:59:42 <kmc> regrettably introduces extra noise in the code
11:59:52 <kmc> but no run-time penalty
12:00:03 <revenantphx> It'd be nice if there was a typeclone keyword.
12:00:03 <Botje> (note: i could be missing the ball completely, but it's worth a shotÃ 
12:00:16 <revenantphx> The same as type, but the type is creates is 'unique'
12:00:23 <revenantphx> so you can do additional instances and that.
12:00:24 <Botje> Eduard_Munteanu: it might also be eudcational to look at the generated Core
12:00:37 <unkanon> kmc: so the fact that a type can only have one Applicative instance is something to be fixed in the future?
12:00:42 <kmc> revenantphx, how would the compiler know when you mean one and when you need the other
12:01:00 <kmc> unkanon, no, it is a pretty fundamental part of how type classes work that there's at most one instance for each type
12:01:00 <jmcarthur> revenantphx: that's newtype
12:01:06 <revenantphx> Yes, except if I do
12:01:06 <remy_o> unkanon: you can create copies of types
12:01:11 <revenantphx> newtype MyString = MyString Stirng
12:01:16 <jmcarthur> right
12:01:17 <revenantphx> then you can't use MyString in place of String
12:01:22 <kmc> yeah, that's the whole point
12:01:25 <jmcarthur> the constructor is necessary to disnguish the type
12:01:26 <Eduard_Munteanu> Botje: hm, using fromIntegral .  fromEnum doesn't change much
12:01:30 <jmcarthur> *distinguish
12:01:33 <revenantphx> M.
12:01:34 <revenantphx> mm*
12:01:36 <Eduard_Munteanu> I'll try your other suggestion.
12:01:42 <kmc> the point of newtype is that you can't use it in place of the other thing
12:01:54 <kmc> and if you could use it in place of the other thing, then it would have to have the same instance too
12:01:58 <remy_o> but it's easy to define constructors/deconstructors
12:02:06 <kmc> anyway if you are building an API without a 1:1 type:instance mapping
12:02:12 <kmc> then it's probably a sign that you're overusing type classes
12:02:18 <burp> wouldn't it be nice to have the ability to hide instances?
12:02:20 <kmc> and should just pass around (records of) functions instead
12:02:35 <kmc> burp, yes, i would like better control of instance scoping / importing, but i think that's a separate issue
12:02:37 <jmcarthur> burp: you can just use explicit dictionaries instead then
12:02:58 <kmc> bad things will happen if one module defines (Ord Int) one way, and another defines it another way.  now what happens when you pass a (Map Int T) between those modules?
12:03:05 <Eduard_Munteanu> Botje: nope, the eight trick doesn't improve it.
12:03:15 <kmc> that's why instances are global today; it's often annoying but there is a good reason
12:03:19 <jmcarthur> the whole idea behind type classes is the 1:(0/1) mapping of types to instances
12:03:29 <Botje> what about the splitat + null rest .. thing?
12:03:36 <kmc> if you want to play with a class system that works more like that, look at Scala
12:03:52 <kmc> whose "implicits" system works like locally-scoped instances
12:04:00 <Eduard_Munteanu> lemme see...
12:04:20 <jmcarthur> scala's way is cool, but i haven't used it enough to say whether i actually would like it. i like it from afar
12:05:29 <Botje> Eduard_Munteanu: my intuition says that should eliminate *some*, because you're going from three traversals to one, and eliminating the padding except at the end
12:05:39 <Eduard_Munteanu> Botje: hm, marginal improvement with that.
12:05:47 * hackagebot cpsa 2.2.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.0 (JohnRamsdell)
12:05:49 <Botje> marginal is better than none :)
12:05:55 <Eduard_Munteanu> Yeah.
12:06:43 <Eduard_Munteanu> I initially thought "hell, I'd be happy if Haskell code was 2x slower than C", but it's much slower.
12:06:45 <sshc> Does the standard library define the natural number?
12:06:56 <Saizan> no
12:07:02 <jmcarthur> i wish :\
12:07:09 <sipa> data Nat = Z | S Nat
12:07:10 <jmcarthur> Word is as close as you'll get
12:07:11 <sipa> done ;)
12:07:27 <Botje> Eduard_Munteanu: i /still/ think your use of [Bool] is to blame somehow.
12:07:57 <Botje> Eduard_Munteanu: will your tree ever become more than 64 levels deep?
12:08:03 <Botje> or 32, even?
12:08:05 <sshc> Sorry, I meant Euler's number, "e"
12:08:17 <jmcarthur> that would be a freaking deep tree :)
12:08:19 <mauke> > exp 1
12:08:20 <lambdabot>   2.718281828459045
12:08:31 <jmcarthur> at least if it's balanced
12:08:53 <nux> hello everyone!
12:09:01 <Botje> hallo nux!
12:09:01 <sshc> "exp"?  Seems awfully obvious.
12:09:04 <sshc> Thanks mauke
12:09:23 <nux> Hallo Botje
12:09:31 <Botje> hallo nux
12:09:38 <Botje> oops
12:09:49 * Botje unhallo's nux once
12:09:53 <Botje> there, balance is restored :)
12:10:02 <nux> new to Haskell...
12:10:02 <nux> I've read about it... 
12:10:02 <nux> like python
12:10:11 <chrisdone> Botje: do you pronounce your nick ``botie''?
12:10:11 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
12:10:20 <chrisdone> what the hell. lambdabot, leave me alone
12:10:26 <nux> but, haskell is completely different
12:10:52 <Botje> chrisdone: kind of like "butcher"
12:11:00 <nux> this is my first time on tryaskell.org... very nice indeed
12:11:02 <Botje> except with an o and without the r :)
12:11:19 <mauke> preflex: GET BACK HERE
12:11:19 <sipa> Botje: are you dutch?
12:11:33 <Botje> .be
12:11:35 <Botje> but yes :)
12:11:38 <chrisdone> Botje: ah, ok
12:11:48 <sipa> Botje: me too :)
12:12:12 <chrisdone> then I guses you two were at belhac!? ;-)
12:12:26 <sipa> i was friday evening and sunday afternoon
12:12:29 <sipa> *there
12:12:31 <chrisdone> nux: yeah, haskell is very different to python
12:12:36 <Botje> well, my birthday was on friday
12:12:53 <Botje> and i was too exhausted to drag myself to the train in the weekend
12:13:03 <Botje> i promise i'll be there for the next one :)
12:13:25 <nux> @ chrisdone ...I see. Is it powerfull too?...
12:13:37 <Botje> nux: it's turing complete
12:13:38 <chrisdone> nux: what do you mean?
12:13:46 <Botje> that's about as powerful as you get :)
12:13:55 <nux> I mean... can we aplly in a lot of fields
12:14:08 <nux> :)
12:14:31 <Botje> Eduard_Munteanu: if your tree will never become more than 32 levels deep, i don't see why you can't replace your [Bool] with a simple bitset in an Int or something
12:15:11 <nux> I mean... like python, you can apply to a very different fields
12:15:11 <nux> sockects, OOP, etc etc
12:15:23 <Botje> those aren't quite fields :)
12:15:37 <chrisdone> nux: sure. ai, games, web, operating systems, compilers, etc. the usual. it's a general purpose language despite its strict purity is paradoxically pragmatic, e.g. interfacing to C is one of the nicest of high level languages about
12:16:15 <sipa> Botje: which city are you from?
12:16:24 <kmc> Haskell actually has a pragmatic, delicately balanced design
12:16:25 <chrisdone> sockets, yes. oop, if you like.. but there are many flavours of that, and most of them aren't used
12:16:25 <Eduard_Munteanu> Botje: I think my tree is log_2 256 deep at most.
12:16:39 <Botje> Eduard_Munteanu: .. so eight bits
12:16:45 <Botje> Eduard_Munteanu: use an Int or a Word8 dude :)
12:16:50 <Eduard_Munteanu> Botje: since length(A0) = 256 and we split it at each level.
12:16:54 <kmc> OOP doesn't belong in that list.  it's not an application or a problem you solve
12:16:57 <kmc> it's a design style
12:17:06 <Botje> OOP is a problem you solve with the delete key
12:17:11 <kmc> ;)
12:17:28 <Botje> sipa: south of brussels
12:17:31 <Botje> but still on the good side ;)
12:17:40 <sipa> haha
12:17:45 <Eduard_Munteanu> Botje: it makes me really unhappy that I didn't spend so much time on the C variant. Even the C code uses a tree made up of structs and pointers and it isn't optimized that much.
12:17:46 <sipa> i'm from leuven
12:17:47 <kmc> OOP is a fine style for some things, but every school now teaches that it is the One True Hammer for all nails, screws, and balloons
12:17:51 <Eduard_Munteanu> But maybe it's my experience there.
12:18:43 <Eduard_Munteanu> Botje: and plus this is an assignment I really want to try and do nicely in Haskell, so I'd like to follow their instructions more or less.
12:18:43 <Botje> Eduard_Munteanu: did you use a linked list for your path construction?
12:18:56 <Botje> sipa: /whois told me so far :)
12:19:02 <ash_> can you runtime-dispatch in haskell? (i don't think so, but just curious) 
12:19:19 <mauke> I'll dispatch your runtime
12:19:21 <Saizan> Eduard_Munteanu: i'm pretty sure your C code doesn't have anything like a [Bool] in it :)
12:19:22 <Eduard_Munteanu> Botje: no, I simply traverse the tree. At each edge, I call a packing function that keeps some state and packs a bit.
12:19:26 <nux_> sorry guys..went down
12:19:33 <sipa> Botje: hmm, i didn't expect it would - the hostname is usually ulyssis.org
12:19:38 <Eduard_Munteanu> Saizan: actually my C code is more like BitPut/BitBuilder
12:19:41 <chrisdone> nux_: did tryhaskell crash?
12:19:43 <jmcarthur> ash_: sure you can
12:19:49 <Botje> Eduard_Munteanu: creating a cons sell is an order of magnitude more work than flipping a bit and shifting
12:19:53 <Botje> *cell
12:20:12 <kmc> runtime dispatch means passing/storing a function as a value and then calling it
12:20:16 <kmc> effectively?
12:20:19 <Eduard_Munteanu> Saizan, Botje: for the record http://paste.pocoo.org/show/298628/
12:20:20 <nux_> @  <Botje> ...I meant Calculus, Algebra, etc. But was spefically talking about features
12:20:22 <Eduard_Munteanu> my C code ^
12:20:38 <jmcarthur> ash_: type classes in ghc are implemented with dictionary passing, for example. while most cases can be inlined statically, sometimes it can't, e.g. with existential quantification
12:20:40 <kmc> is this what you mean ash_?
12:20:41 <Eduard_Munteanu> Botje: well I'd be happy not to do it, but the Bit* thingy is slower.
12:21:14 <kmc> never mind type classes, first-class functions are basically run-time dispatch
12:21:14 <nux_> no no <chrisdone>...I am with Wirelless and far from Router, which is on my basement. So I went offline beacuse of network
12:21:32 <Botje> Eduard_Munteanu: no, not BitBuilder or BitPut
12:21:47 <chrisdone> encapsulation, polymorphism, inheritence are possible in Haskell and are kind of normal, in Haskell's own flavour of OO
12:21:52 <Eduard_Munteanu> I suppose I could hack up my own ST function for that.
12:21:56 <Botje> Eduard_Munteanu: just an Int that you .&. 1 and `shiftL` for each iteration
12:22:16 <chrisdone> er, inheritance
12:23:30 <Eduard_Munteanu> Hm, okay I'll try doing what I did in C using ST.
12:23:30 <ash_> kmc: I wasn't necessarily thinking of passing a function as a parameter, I was thinking of more of an analogy to Obj-C's message passing if your familiar 
12:24:25 <Botje> Eduard_Munteanu: i don't even think you need ST
12:24:29 <Botje> simple recursion will do
12:24:34 <Eduard_Munteanu> But frankly I wouldn't have gained much elegance writing that in Haskell.
12:25:00 <kmc> ash_, kind of familiar; which aspect of it are you asking about?
12:25:22 <Eduard_Munteanu> Botje: hm, perhaps but it seems difficult to do so.
12:25:29 <kmc> ash_, if you want to look up a function by name, you can use (Map String (A -> B))
12:25:36 <chrisdone> nux_: e.g. type this in the prompt :t show
12:25:52 * hackagebot rdtsc 1.1.3.1 - Binding for the rdtsc machine instruction  http://hackage.haskell.org/package/rdtsc-1.1.3.1 (MartinGrabmueller)
12:25:53 <augur> Saizan: any good papers on monad transformers?
12:25:57 <kmc> in general a lot of "special" features in OOP languages are just specific use-patterns of first-class functions
12:26:10 <jmcarthur> whole papers on transformers? i'm not even sure if they exist
12:26:24 <kmc> there was the Monad Zipper paper
12:26:25 <augur> well, intro articles, something
12:26:25 <kmc> that was fun
12:26:29 <ash_> kmc: if i was speaking perl6, i'd just say: multi f(Str $a) { ... }; multi f(Int $a) { ... };  
12:26:43 <jmcarthur> monad transformers are just type constructors that... transform monads
12:26:44 <Eduard_Munteanu> Botje: the thing is I need to produce multiple Word8s from a varying number of bits, so ST should naturally keep track of how many bits I have left in my accumulator and such.
12:26:47 <Saizan> augur: http://web.cecs.pdx.edu/~mpj/pubs/modinterp.html
12:26:57 <jmcarthur> :o
12:26:59 <chrisdone> jmcarthur: they do... I've seen a few... let me think
12:27:00 <augur> look at this guy, hes on top of things
12:27:02 <augur> man
12:27:02 <kmc> ok i don't speak perl6 either
12:27:14 <chrisdone> ah, there's one
12:27:20 <jmcarthur> i guess everything was a new idea at some point :)
12:27:20 <ash_> then when you call f, the function isn't looked up until runtime, and dispatched then 
12:27:28 <chrisdone> kmc: and thank yourself lucky!
12:27:28 <kmc> it sounds like you want different behavior from f based on the *type* of the argument
12:27:42 <kmc> in Haskell you could use a type class
12:27:43 <jmcarthur> ash_: type classes
12:28:01 <kmc> which is (usually) sugar for passing functions as parameters
12:28:05 <jmcarthur> or gadts could be another way
12:28:07 <ash_> type classes it is then, i need to read up more on them 
12:28:11 <Botje> Eduard_Munteanu: you mean like the concatMap in compresS?
12:28:17 <kmc> yeah
12:28:27 <chrisdone> jmcarthur: I *love* reading Wearing the Hair Shirt and reading about how we're trying this neat idea called monads with 'unit' and (>>=), and look, many things are monads! :D
12:28:29 <kmc> type classes are one of the most fundamental ways that Haskell differs from "classical" FP
12:28:43 <jmcarthur> chrisdone: heh, yeah, that's a fun paper
12:28:49 <kmc> in some ways they're just sugar, but quite clever and convenient sugar
12:28:54 * hackagebot cpuid 0.2.1.2 - Binding for the cpuid machine instruction on x86 compatible  processors  http://hackage.haskell.org/package/cpuid-0.2.1.2 (MartinGrabmueller)
12:29:11 <Eduard_Munteanu> Botje: yes, but each lookupCode call results in a varying number of bits.
12:29:24 <jmcarthur> i've ben (ab)using GADTs a lot lately
12:29:27 <jmcarthur> *been
12:29:38 <Botje> Eduard_Munteanu: Integer is an instance of Bits
12:29:48 <jmcarthur> it occurs to me that usually when i use GADTs i feel like i'm actually abusing them. i wonder if there's a good reason i feel that way...
12:29:50 <Botje> Eduard_Munteanu: so worst case you can do the packing from number to number
12:29:51 <chrisdone> jmcarthur: for what?
12:30:05 <chrisdone> jmcarthur: haha. see M-x doctor
12:30:10 <Eduard_Munteanu> Botje: I'm wary of using Integer to represent the output file :/
12:30:33 <jmcarthur> chrisdone: my off-and-on quest to make a more haskelly low-level opengl interface
12:30:42 <Eduard_Munteanu> ... if that's what you were suggesting.
12:31:17 <jmcarthur> chrisdone: using GADTs for various texture formats and pixel buffer formats/types
12:31:32 <jmcarthur> and some type families to make sure they are used in compatible ways
12:31:51 <chrisdone> so last night I read a chapter about godel's numbering, interesting, and the provability inconsistency in axiomatic set theory. kind of cool, then I went to sleep and now I don't remember how it works. I should go and read instead of chatting on irc
12:31:57 <chrisdone> jmcarthur: that's kind of neat. can I see source?
12:32:11 <jmcarthur> so now i have to make a Storable instance for a GADT with 35 constructors...
12:32:17 <chrisdone> hahaha
12:32:26 <chrisdone> guy at work was complaining of something similar
12:32:47 <Botje> Eduard_Munteanu: okay, then i'm kind of out of ideas.
12:33:02 <jmcarthur> chrisdone: i will be sticking it on hackage once it's doing anything useful. this is actually like my 6th attempt or something like that... i keep changing fundamental things about my approach
12:33:35 <chrisdone> jmcarthur: ah, ok. I know that feeling
12:33:58 <Eduard_Munteanu> Botje: thanks for helping.
12:34:12 <Eduard_Munteanu> I'll try do packing like in C then, and see if that improves it.
12:34:45 <jmcarthur> chrisdone: originally i was also going to make a high level wrapper on top of this, but i think i might just stick with this interface instead. it's getting simple (stateless!) enough that there isn't much point in going higher level unless i wanted to implement some semantic model
12:35:02 <djfm> Hi, I'm a bit struggling and not starting with the most easy things I think, but quick question : does it make sense to define a Matrix datatype as "data Matrix a = Matrix [[a]]" ?
12:35:33 <Eduard_Munteanu> djfm: it's pretty difficult to operate with that meaningfully, but it's doable
12:35:50 <Eduard_Munteanu> djfm: I'd use an array, or something more specialized like hmatrix
12:35:52 <engla> djfm: it's valid.
12:36:15 <jmcarthur> djfm: it makes sense but i might not be fast for many operations
12:36:18 <jmcarthur> *it
12:36:43 <Eduard_Munteanu> @hoogle hmatrix
12:36:43 <lambdabot> No results found
12:36:48 <Eduard_Munteanu> @hayoo hmatrix
12:36:48 <lambdabot> Unknown command, try @list
12:36:55 <Eduard_Munteanu> Anyway, Google that.
12:36:57 <monochrom> <hask>...</hask> on the new haskell wiki is causing troubles left right and centre.
12:37:01 <jmcarthur> chrisdone: btw, your blog convinced me to set my ghci prompt to "Î»> " :D
12:37:06 <djfm> probably not fast indeed, its mostly for the purpose of learning
12:37:18 <Eduard_Munteanu> jmcarthur: wow nice idea.
12:37:18 <djfm> ok
12:37:34 <jmcarthur> i think it was chrisdone's blog anyway
12:38:21 <jmcarthur> ha, i should set it to ">Î»= "
12:38:29 <chrisdone> jmcarthur: hahaha. just as planned ~>_>
12:38:34 <jmcarthur> with an appropriate font it might look a lot like the haskell logo
12:38:47 <Eduard_Munteanu> Is this part of a plan to take over the world? :)
12:38:49 <kmc> when will the haskell logo get its own unicode codepoint?
12:38:54 <kmc> communists already have their logo in
12:38:57 <jmcarthur> heh
12:39:12 <tg_> always gotta pick on the communists...
12:39:15 <chrisdone> I think they got first dibs
12:39:28 <unkanon> jmcarthur: can I have a link to that blog post? ;)
12:40:03 <djfm> If I define my matrix as above, and try to do a (mathematically wrong, obviously, just for testing) a multiplication as such "matrixMul (Matrix [[a]]) b = Matrix [[b]]" I get a "non exhaustive pattern" error at runtime
12:40:19 <monochrom> set your prompt to Î»_Î»~>_>
12:41:14 <jmcarthur> unkanon: i think i saw it first here: http://chrisdone.com/posts/2010-11-22-duck-typing-in-haskell.html
12:41:25 <kmc> djfm, that pattern only matches a list of one element, which is a list of one element
12:41:35 <unkanon> jmcarthur: thanks
12:41:50 <kmc> matrixMul (Matrix a) b = Matrix b
12:42:02 <kmc> > case [[1]] of [[x]] -> x
12:42:03 <lambdabot>   1
12:42:06 <kmc> > case [[1,2]] of [[x]] -> x
12:42:07 <lambdabot>   *Exception: <interactive>:1:141-166: Non-exhaustive patterns in case
12:42:17 <djfm> oh I see! Thanks a lot!
12:42:21 <kmc> :D
12:42:27 <chrisdone> jmcarthur: hmm. regarding design issues, I've been struggling coming up with a few designs for various problems (GUIs DSL, plugin DSL). my first instinct is "it's got to be a monad", then I think, well it could be applicative, or maybe even an arrow if I think about it... I'm leaning to attempting a "pure" prototype version first to gather more insight
12:43:17 <kmc> yeah
12:43:27 <kmc> since Arrow / Applicative / Monad are just generic APIs
12:43:35 <kmc> you can design the specialized API that feels right
12:43:41 <kmc> and then see how well it fits with one of those interfaces
12:43:47 <chrisdone> aye
12:43:52 <kmc> it is hard not to see everything as a monad :D
12:43:58 <chrisdone> haha
12:43:59 <kmc> that's how we get things like "Put"
12:44:26 <unkanon> what's Put?
12:44:29 <chrisdone> Put, what's that from? I recognise the name
12:44:36 <kmc> from Binary
12:44:40 <chrisdone> oh yeah
12:44:44 <kmc> it's a "monad" you use to write bits
12:45:00 * hackagebot disassembler 0.1.0.1 - Disassembler for X86 & AMD64 machine code  http://hackage.haskell.org/package/disassembler-0.1.0.1 (MartinGrabmueller)
12:45:04 <kmc> but you only use the type "Put ()" and the only primitive Put actions you get have that type
12:45:12 <revenantphx> Seems more to me to be for defining serialization/deserialization actions for types.
12:45:23 <revenantphx> Put being for encoding, Get being for decoding.
12:45:36 <kmc> so the monad Put gives you little more than a monoid
12:45:48 <kmc> but people want to use "do" syntax, or someone decided they should...
12:46:11 <aristid> type KmcPut = Put ()
12:46:14 <jmcarthur> i'm more a fan of "fold [a, b, c, d]" than "do { a; b; c; d }"
12:46:26 <aristid> :t fold
12:46:27 <lambdabot> Not in scope: `fold'
12:46:31 <revenantphx> :t foldl
12:46:32 <jmcarthur> :t Data.Foldable.fold
12:46:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:46:33 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
12:47:07 <aristid> > getSum $ Data.Foldable.fold [Sum 1, Sum 2]
12:47:08 <lambdabot>   3
12:47:16 <chrisdone> kmc: (the blaze-html Html monad is similar (defined Html = HtmlM ()). all the actions return unit ...but that's specifically to abuse do-notation)
12:47:22 <aristid> jmcarthur: so fold is a generalised mconcat?
12:47:23 <jmcarthur> a list of things to put just makes more sense to me than a list of things to do when all you can do is put things
12:47:29 <jmcarthur> :t mconcat
12:47:30 <lambdabot> forall a. (Monoid a) => [a] -> a
12:47:33 <jmcarthur> yup :)
12:47:51 <chrisdone> kmc: yeah, blaze is also little more than a monoid. it seems there will crop up more and more of this kind of thing
12:47:57 <jmcarthur> a list of things to put just makes more sense to me than a *statement* of things to do when all you can do is put things
12:48:01 * hackagebot harpy 0.4.3.0 - Runtime code generation for x86 machine code  http://hackage.haskell.org/package/harpy-0.4.3.0 (MartinGrabmueller)
12:48:07 <jmcarthur> yeah i hate that in blaze :(
12:48:42 <jmcarthur> i like using monoids for template libraries
12:49:01 <aristid> there's little knowledge how to make good APIs in haskell
12:49:32 <jmcarthur> if you define  instance IsString b => (a -> b)  then you can have a lot of fun with folds and records to make templates
12:49:59 <monochrom> there is some slippery rope about EDSLs and computations (in Moggi's sense) and (>>=) being generalized "let" that quickly lands you in a monad.
12:50:15 <jmcarthur> thingToString :: MyThing -> String ; thingToString = fold ["blah ", foo, " weee! ", bar]
12:50:20 <monochrom> s/EDSLs/most EDSLs/
12:50:40 <jmcarthur> where the foo and bar functions are just normal record accessors :D
12:50:50 <chrisdone> jmcarthur: I mean I like using do notation, I used it to whip up something urgent at work and it's nice to read and write (or maybe it isn't? what do you think? http://hpaste.org/42006/blazehaskelldb), but the not-really-a-proper-monad thing is pretty icky, yeah
12:51:13 <revenantphx> > (Î» Î± -> Î± * Î±) 10
12:51:13 <lambdabot>   Pattern syntax in expression context: Î» Î± -> Î± * Î±
12:51:21 <revenantphx> unicode fails :|
12:51:24 <revenantphx> aww
12:51:25 <tphyahoo> ghc-pkg / cabal install misbehavior. any suggestsions? 
12:51:28 <tphyahoo> cabal: dependencies conflict: marketpsychHsUtils-1.1 requires parsec ==2.1.0.1
12:51:28 <tphyahoo> however
12:51:28 <tphyahoo> parsec-2.1.0.1 was excluded because marketpsychHsUtils-1.1 requires parsec
12:51:31 <tphyahoo> ==3.1.0
12:51:35 <tphyahoo> (this is for a private package)
12:51:43 <monochrom> (\ Î± -> Î± * Î±) 10
12:51:46 <chrisdone> (on that subject haskelldb's monad is a pretty sweet example of a monad EDSL imo)
12:51:48 <monochrom> > (\ Î± -> Î± * Î±) 10
12:51:49 <lambdabot>   100
12:51:54 <revenantphx> I can't use an actual lambda?
12:51:57 <revenantphx> I was hoping you could :P
12:52:04 <chrisdone> you can with an extension
12:52:05 <djahandarie> revenantphx, there is a GHC extension for it
12:52:06 <jmcarthur> chrisdone: it's okay. i'd edit that to show you my syntactic tastes if it wouldn't take so long
12:52:08 <revenantphx> (I totally would)
12:52:08 <monochrom> > (\ Î» -> Î» * Î») 10
12:52:09 <lambdabot>   100
12:52:13 <tphyahoo> I just tried bumping the version number from 0 to 1.0 to 1.1 but that didn't fix the issue 
12:52:26 <revenantphx> No, I mean instead of `\`
12:52:27 <chrisdone> jmcarthur: you can do a trivial example
12:52:31 <monochrom> it is a letter. think of what haskell's grammar say about a letter.
12:52:31 <dcoutts_> tphyahoo: presumably marketpsychHsUtils-1.1 is already installed
12:52:37 <jmcarthur> revenantphx: you can use Î» as a variable or function :)
12:52:41 <tphyahoo> nope, it wasn't.
12:52:50 <djahandarie> revenantphx, there is a GHC extension for using an actual lambda for \
12:52:52 <tphyahoo> also, ghc-pkg recache yields ghc-pkg: /home/thomas/.ghc/x86_64-linux-6.12.1/package.conf.d/unix-compat-0.2-2c2ef95f130082b2dbb971c24ef4ef3f.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
12:53:06 <djahandarie> revenantphx, and other unicode syntax nifty things
12:53:07 <tphyahoo> not sure what recache does, or if it's relevant here -- just playing around
12:53:32 <monochrom> the theorem prover HOL4 makes a special case and says "all greek letters except Î» are letters, Î» is special" to work around this.
12:54:17 <revenantphx> Can haskell use any unicode character set?
12:54:29 <chrisdone> "HOL4, treat Î² not as a letter."
12:54:29 <chrisdone> "I'm afraid I can't do that, Dave."
12:54:34 <dcoutts_> tphyahoo: does that package really specify such tight == constraints for parsec?
12:54:36 <revenantphx> Like, could I use hiragana or chinese characters for function names?
12:54:44 <monochrom> there is only one unicode character set. what do you mean by "any"?
12:54:51 <revenantphx> any langauge, sorry
12:55:11 <tphyahoo> yes, I did it to work around some other cabal complaint. in the past i have resolved this kind of thing by wiping .cabal and .ghc and reinstalling everything. but that takes a while.
12:55:17 <tphyahoo> I just wonder if there are any other suggested workarounds.
12:55:17 <revenantphx> > (\ ã‚ -> ã‚ * ã‚) 10
12:55:18 <lambdabot>   100
12:55:19 <chrisdone> variable names are quite limitless but constructors need to start with upper case letters
12:55:21 <revenantphx> :O 
12:55:40 <dcoutts_> tphyahoo: I'd suggest not constraining in the .cabal file, but using --constraint= flags during install
12:55:53 <monochrom> > (\ æ—¥æœˆæ˜Ÿè¾° -> æ—¥æœˆæ˜Ÿè¾° && æ—¥æœˆæ˜Ÿè¾°) True
12:55:54 <lambdabot>   True
12:56:03 <chrisdone> monochrom: what's that say?
12:56:11 <dcoutts_> tphyahoo: as for the immediate problem, would you mind posting a log of cabal install blah -v, so we can see what the constraint solver is doing
12:56:12 <monochrom> sun moon star
12:56:13 <revenantphx> neat
12:56:27 <tphyahoo> thanks, i'll try that. cabal install --constraint="parsec >= 3" ?
12:56:42 <tphyahoo> dcoutts, you noticed that the initial output I posted was contradictory right?
12:56:43 <chrisdone> monochrom: it *only* says sun moon and star? that looks like three poems about the sun, the moon and stars
12:56:49 <dcoutts_> tphyahoo: yes
12:56:50 <revenantphx> (\ â™¥ -> â™¥ + â™¥) 10
12:56:59 <revenantphx> > (\ â™¥ -> â™¥ + â™¥) 10
12:57:00 <lambdabot>   <no location info>: parse error on input `â™¥'
12:57:01 <monochrom> â™¥ is not a letter
12:57:07 <revenantphx> Can't use symbols? :\
12:57:10 <dcoutts_> tphyahoo: well, not contradictory but not solvable (which is why it complains)
12:57:27 <monochrom> > let xâ™¥y = True in "you" â™¥ "me"
12:57:28 <lambdabot>   True
12:57:36 <tphyahoo> oh, for clarity, marketpsychHsUtils installs fine, and when I do ghc-pkg describe marketpsychHsUtils, it shows it depends on parsec 3.
12:57:44 <monochrom> READ THE BLOODY REPORT ALREADY
12:57:50 <revenantphx> sorry >_<
12:58:06 <unkanon> monochrom: that's beautiful *sniff*
12:58:08 <chrisdone> the Bloody Report sounds more interesting than The Report
12:58:16 <revenantphx> I concur.
12:58:30 <tphyahoo> also, at one point I did cabal install marketpsychHsUtils, and then bumped the parsec dependency inside there without bumping the version numer of marketpsychHsUtils, and I surmise this is when cabal began to get confused.
12:58:41 <tphyahoo> But you would think then bumping the version number would solve that.
12:58:42 <dcoutts_> tphyahoo: oh, so you get this when trying to configure/install something else that depends on marketpsychHsUtils?
12:58:46 <tphyahoo> yes.
12:59:57 <revenantphx> It'd be fun to write a chess program defining functions with the unicode characters for the chess pieces.
13:00:04 <revenantphx> â™”â™•â™–â™—â™˜â™™
13:00:08 <dcoutts_> tphyahoo: I still wonder if that package indirectly depends on two versions of parsec
13:00:16 <tphyahoo> how could I tell?
13:00:17 <jmcarthur> chrisdone: dangit, i just wrote up a big paste and then accidentally closed the tab and now it's gone :(
13:00:20 <dcoutts_> tphyahoo: which would certainly upset cabal
13:00:28 <chrisdone> jmcarthur: re-open the tab?
13:00:36 <chrisdone> jmcarthur: oh, it's gone from the textarea?
13:00:48 <jmcarthur> chrisdone: i did it with some weird accidental keystroke. i reopened the tab and the content was gone
13:00:51 <dcoutts_> tphyahoo: by tracing the dependencies of the package, using ghc-pkg field $pkg depends
13:00:59 <monochrom> > let xâ™–y = x ++ " root " ++ y in "I" â™– "you"
13:01:00 <lambdabot>   "I root you"
13:01:11 <revenantphx> ...ROOK
13:01:13 <revenantphx> NOT ROOT.
13:01:14 <dcoutts_> tphyahoo: or by you magically knowing that it depends on something else that uses parsec, and checking what version of parsec that used
13:01:17 <monochrom> pun!
13:01:22 <jmcarthur> i'll try this again...
13:01:24 <kmc> > let à¤¹à¤¿à¤¨à¥à¤¦à¥€ = () in à¤¹à¤¿à¤¨à¥à¤¦à¥€
13:01:25 <lambdabot>   <no location info>: lexical error at character '\2367'
13:01:26 <revenantphx> If you're _drunj_
13:01:31 <revenantphx> kmc: awww.
13:01:34 <revenantphx> No.... farsi?
13:01:36 <revenantphx> what is that?
13:01:39 <kmc> devangari script
13:01:45 <tphyahoo> dcoutts, for the first idea, does mean doing dependency tracing all the way, or just one ghc-pkg command tells us enough?
13:01:46 <kmc> used by hindi and other indian languages
13:01:53 <revenantphx> Somewhat close :\.
13:01:57 <revenantphx> Not really though.
13:02:05 <chrisdone> jmcarthur: interesting.. if I close and re-open in chrome the text is still there. firefox, too. what browser are you using?
13:02:05 <unkanon> jmcarthur: never write stuff in a webpage's textbox :/ (I've learned that lesson more than once)
13:02:06 <ion> > (Î»x â†’ xÂ·2) 42
13:02:07 <lambdabot>   Pattern syntax in expression context: Î»x -> x Â· 2
13:02:07 <tphyahoo> this is one of those situations where there are a lot of deps. Pretty much always the case when you're in happstack btw.
13:02:11 <dcoutts_> tphyahoo: sadly there's no single ghc-pkg command
13:02:14 <ion> :-(
13:02:21 <dcoutts_> tphyahoo: it's not really designed for graph browsing
13:02:39 * kmc tries to test farsi, fails at editing embedded RTL text
13:02:45 <chrisdone> jmcarthur: unkanon is right of course. we all know this due to those blasted javascript-generated textareas, but sometimes we forget and this happens :-(
13:03:11 <ion> > (Î»x â†’ x) 42
13:03:12 <lambdabot>   Pattern syntax in expression context: Î»x -> x
13:03:18 <tphyahoo> one last question, what is the ghc-pkg recache command supposed to do, and would one think it would be helpful in this type of situation?
13:03:21 <ion> Lambdaâ€™s still not reserved as \? Meh.
13:03:24 <revenantphx> > let (âœ„) a b = "No! Don't do it!" in "you" âœ„ "yourself" 
13:03:25 <lambdabot>   "No! Don't do it!"
13:03:35 <tphyahoo> as you recall, there seemed to be some corruption when I tried running it.
13:04:06 <dcoutts_> tphyahoo: recache is only needed if you changed the package db directly, without going via the ghc-pkg register/unregister commands
13:04:28 <dcoutts_> tphyahoo: there was a bug in 6.12.1 where it did not check UTF8 encoding correctly during register
13:04:30 <chrisdone> I saw a t-shirt with "runs with scissors" on it, hehe
13:04:49 <tphyahoo> that's the version I'm on.
13:04:51 <dcoutts_> tphyahoo: you might want to edit the offending file (utf8 thing) and ghc-pkg recache
13:04:59 <revenantphx> that reminds me of the old :sex joke in ruby.
13:05:06 <sproingie> when i think about you i âœ„ myself
13:05:08 <revenantphx> To someone who knows ruby it's a 'sex symbol'
13:05:09 <jmcarthur> chrisdone: chrome
13:05:20 <revenantphx> But to someone who doesn't, it looks like "colon sex"
13:05:21 <jmcarthur> chrisdone: it wasn't just a normal tab close that i accidentally did though. it was something weird
13:05:39 <tphyahoo> this file? /home/thomas/.ghc/x86_64-linux-6.12.1/package.conf.d/unix-compat-0.2-2c2ef95f130082b2dbb971c24ef4ef3f.conf:
13:05:50 <tphyahoo> what did you mean by utf8 thing?
13:06:17 <chrisdone> jmcarthur: haha. that's so disturbing. like in Emacs when I accidentally hit a key combo that I've never hit before, and something magical (or frightening) happens, and I sit there wondering what I pressed, disturbed O_O
13:06:17 <tphyahoo> any easy way to bump by ghc-pkg version to a better one?
13:06:51 <Alan> You probably hear this all the time but... is there any good reference that explains monads well?
13:07:04 <sproingie> Alan: LYAH
13:07:07 <tphyahoo> alan: allabout monads
13:07:08 <Alan> I've read a few different descriptions and none of them are giving me the "lightbulb momemnt" of "getting" it :|
13:07:27 <Rembane> Alan: http://learnyouahaskell.com/a-fistful-of-monads
13:07:29 <jmcarthur> chrisdone: oh i think i know what i did now. just did it again and realized what happened
13:07:31 <tphyahoo> also -- don't worry about monads. you can use haskell productively without understanding all the details. it's more of a fetish.
13:07:32 <c_wraith> Alan: there isn't a lightbulb moment.  There's a gradual understanding that there's nothing to get. :)
13:07:34 <sproingie> Alan: anything that describes monads with an analogy to real world objects is not useful
13:07:37 <chrisdone> jmcarthur: what was it?
13:07:41 <Alan> c_wraith: bah :(
13:08:01 <jmcarthur> chrisdone: i apparently did a keystroke for "Back", saw an empty tab, and thought i had accidentally opened an empty tab and instinctively closed it
13:08:02 <Zao> http://www.haskell.org/haskellwiki/Monads_as_computation http://horna.org.ua/books/All_About_Monads.pdf
13:08:03 <Alan> sproingie: "LYAH?"
13:08:09 <c_wraith> Alan: just use function.  Follow type signatures.  Don't worry about what a monad "is"
13:08:09 <jmcarthur> chrisdone: but this time i didn't close it
13:08:10 <tphyahoo> learn you a haskel
13:08:13 <byorgey> Alan: c_wraith is correct that there isn't necessarily a lightbulb moment.  But there is definitely something to get.
13:08:16 <sproingie> Alan: it's a typeclass that defines a couple of major operations (and a few more supporting ones) and they all work differently and are only similar on some deeply abstract level
13:08:28 <Zao> http://learnyouahaskell.com/
13:08:49 <chrisdone> jmcarthur: hitting back and then closing the tab loses the text in the textarea?
13:08:57 <Alan> c_wraith: i'm trying to "get" monads because i'm failing to understand how the parsec library even does anything :P
13:09:14 <jmcarthur> chrisdone: apparently
13:09:17 <sproingie> pretty much the only thing i can describe monads as is an operation to mean "this thing" and "this thing with that thing"
13:09:20 <c_wraith> Alan: parsec's a good place to start.  It just works. :)
13:10:15 <byorgey> Alan: I'm biased, but I recommend reading the Typeclassopedia
13:10:20 <byorgey> @where typeclassopedia
13:10:20 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:10:28 <c_wraith> parsec is what made me realize I was trying to make too big of a deal out of it.  Monads are just an interface that means "works with do syntax" and some additional contract which is essentially "works like you think it should with do syntax"
13:11:05 <Alan> byorgey: the link there is head
13:11:09 <Alan> *head
13:11:12 <Alan> **dead
13:11:16 <Alan> wtf, i can't type today...
13:11:17 <jmcarthur> chrisdone: i don't know if i inadvertantly screwed anything up, but here is a subset of your function in a style i find a little less abusive and still readable: http://hpaste.org/paste/42006/monoidlist_subset#p42007
13:11:19 <chrisdone> Alan: then that isn't really about monads per se as what the hell does the parsec library do? it's quite clever. it's similar to the state monad but with more bells and whistles. the state monad is simpler to understand and is the same kind of closure cleverness. you'll be able to write your own parsec once you understand the state monad. the fact these are monads is just that they're implemented as the Monad class methods instead of
13:11:19 <chrisdone> their own custom doThisDoThat (>>), passThisAlong (>>=), etc.
13:11:23 <byorgey> @go typeclassopedia
13:11:23 <lambdabot> Maybe you meant: google googleit do
13:11:28 <byorgey> @google typeclassopedia
13:11:29 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:11:29 <lambdabot> Title: Typeclassopedia - HaskellWiki
13:11:40 <byorgey> hrm
13:11:48 <byorgey> works for me
13:12:03 <sproingie> click the link
13:12:14 <byorgey> Alan: try community.haskell.org/~yitz/typeclassopedia.pdf
13:12:14 <jmcarthur> chrisdone: i had to make up the foldFor function. just think of it like flip foldMap
13:12:30 <unkanon> sproingie: that's a pretty good explanation actually
13:12:36 <chrisdone> but yeah trying to learn instances of Monad and the concept of Monads simultaneously is hard. it's easier to figure out how a couple implementations work and then realise, oh, they both have an operation in common that match up with the Monad class
13:12:36 <Alan> byorgey: i mean the PDF link is dead...
13:12:47 <chrisdone> jmcarthur: looking
13:13:07 <byorgey> Alan: oh, I see. does the other link work?
13:13:11 <kmc> Alan, don't look for the lightbulb moment because there may not be one.  "Monad" is just the name of a small API implemented by a lot of different unrelated types
13:13:12 <jmcarthur> i pretty much just cut out one of the td tags i think
13:13:17 <jmcarthur> the more complex one
13:13:18 <kmc> there's not necessarily a lot in common between Monad instances
13:13:26 <sproingie> unkanon: well technically that's more like a monoid.  gets you most of the way there.
13:13:47 <Alan> kmc: i see
13:14:01 <unkanon> sproingie: I thought "this thing" = unit and "this thing with that thing" = bind, no?
13:14:08 * hackagebot hexpat 0.19.5 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.5 (StephenBlackheath)
13:14:26 <jmcarthur> monads are a kind of monoids, actually
13:14:37 <jmcarthur> in a couple different ways
13:14:47 <chrisdone> jmcarthur: that looks pretty nice too. it replaces `do' for '[' and ']'
13:14:55 <jmcarthur> chrisdone: exactly
13:15:17 <Alan> byorgey: yeah, the other link is fine...
13:15:26 <chrisdone> jmcarthur: one thing that you *do* gain, I just realised, with a monad, is that you can do the `when' I used in that example. in the list way, you have to do a kind of (++ if ... then ... else []) kind of thing
13:16:12 <jmcarthur> chrisdone: yeah, or use catMaybes and put some []s around a few extra things
13:16:14 <jmcarthur> err
13:16:15 <augur> chrisdone: why did you delete your stuff on reddit?
13:16:15 <jmcarthur> Justs
13:16:27 <kmc> a monad is just a monoid object in the category of endofunctors 
13:16:29 <kmc> *rolls eyes*
13:16:32 <jmcarthur> mixing up my catMaybes with with concat
13:16:37 <sproingie> unkanon: right, those being the monoid operations.  monads just involve functions (well "endofunctors" actually) so as the user's concerned, there's more than one "this with that" function
13:17:01 <chrisdone> jmcarthur: or, indeed, mconcat
13:17:01 <unkanon> kmc: you're saying it's not necessary to understand how to parse that sentence to understand and use monads?
13:17:10 <Cale> unkanon: right
13:17:10 <jmcarthur> heh yeah
13:17:11 <chrisdone> :t mconcat -- I always confuse this with mplus
13:17:12 <lambdabot> forall a. (Monoid a) => [a] -> a
13:17:17 * chrisdone nods
13:17:18 <jmcarthur> :t Data.Foldable.fold
13:17:19 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
13:17:28 <chrisdone> oh sweet
13:17:31 <mtnviewmark> @quote jello
13:17:31 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
13:17:32 <unkanon> Cale: *phew* that's encouraging then :)
13:17:34 <Alan> byorgey: 51 pages? :|
13:17:54 <sproingie> but still what makes monads "click" for me is an intuition of them as a monoid.  i go by intuition because i have no formal math edumacation
13:18:03 <byorgey> Alan: well, sure.  It's comprehensive.
13:18:09 <byorgey> Alan: and it isn't all about monads, mind you.
13:18:09 <chrisdone> > Data.Foldable.fold [Just "Hello ",Nothing," World!"]
13:18:10 <mtnviewmark> @unkanon - no, it's necessary to understand how to parse that sentence to understand and use monads!
13:18:10 <lambdabot> Unknown command, try @list
13:18:10 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe [GHC.Types.Char]'
13:18:10 <lambdabot>         ag...
13:18:16 <mtnviewmark> (the one about jello, :-)  )
13:18:17 <rubitawapa_27> hi
13:18:17 <chrisdone> > Data.Foldable.fold [Just "Hello ",Nothing,Just " World!"]
13:18:18 <lambdabot>   Just "Hello  World!"
13:18:28 <augur> byorgey: i still think inverse species are an interesting idea :|
13:18:29 <chrisdone> perfect?
13:18:31 <Cale> sproingie: The monoidal structure is pretty abstract though.
13:18:45 <chrisdone> then again how's this gain from mconcat?
13:18:53 <Alan> byorgey: fair enough :)
13:18:59 <byorgey> augur: and I still think you're crazy ;)
13:19:21 <Cale> sproingie: Instead of a multiplication A x A -> A, you have a multiplication which is a natural transformation M . M -> M  -- that is, a polymorphic function M (M a) -> M a
13:19:23 <jmcarthur> return :: Id a -> M a ; join :: (Mâˆ˜M) a -> M a   -- if you drop the 'a's it looks quite a bit like a monoid :)
13:19:26 <augur> byorgey: well thats CERTAINLY true
13:19:58 <sproingie> Cale: right, which is only why i got it after seeing a bunch of examples.  but it still showed me how things like lists and Maybe are related
13:20:03 <augur> i just think itd be interesting to try and draw out the analogy to functions as much as possible
13:20:12 <augur> after all, if functions can have inverses, why not species
13:20:17 <jmcarthur> chrisdone: well, it means you can use things aside from lists, for one
13:20:19 <unkanon> mtnviewmark: that was a funny quote
13:20:20 <byorgey> augur: but the analogy isn't to functions, it's to functors
13:20:22 <chrisdone> augur: I only created it to reply to some stuff. reddit requires registration, shrug
13:20:36 <jmcarthur> chrisdone: imagine using a Set for an unordered bullet list ;)
13:20:38 <mtnviewmark> yes - I like it very much --- 
13:20:44 <augur> byorgey: eh, but you still have analogies to polynomials, etc.
13:20:45 <jmcarthur> dunno if that's useful in any way
13:20:48 <chrisdone> jmcarthur: in the general case true. are maps foldable? I don't think they fit the class
13:20:52 <chrisdone> jmcarthur: haha, that's nice
13:20:57 <jmcarthur> @instances Foldable
13:20:58 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
13:21:07 <sproingie> Cale: i can't remember which tutorial had the graph path finding example but that was the eye opener, showing how the exact same code could return Nothing for failure, throw an exception, or return a list of successes
13:21:09 <jmcarthur> @instances-importing Data.Foldable Foldable
13:21:09 <lambdabot> Maybe, []
13:21:10 <mtnviewmark> I'm a firm believer that one can be a very excellent Haskell programmer and not know Category Theory at all (ducks)
13:21:20 <jmcarthur> Set isn't foldable??
13:21:25 <chrisdone> there're more than that..
13:21:27 <augur> byorgey: we should try to work out what laws an inverse would have to satisfy, i think. even if you think it's a crazy idea :p
13:21:28 <jmcarthur> @instances-importing Data.Foldable Data.Set Foldable
13:21:28 <lambdabot> Maybe, Set, []
13:21:28 <chrisdone> let's check the docs
13:21:35 <jmcarthur> it's just not getting all of it
13:21:39 <chrisdone> hah
13:21:40 <jmcarthur> @instances-importing Data.Foldable Data.Set Data.Map Foldable
13:21:40 <lambdabot> Map k, Maybe, Set, []
13:21:44 <kmc> mtnviewmark, i think that's the widely held view here
13:21:58 <Cale> sproingie: Ah, of course, that would be monads with the extra monoidal structure from MonadPlus :)
13:22:01 <chrisdone> ah, Map k, yeah
13:22:22 <kmc> CT doesn't really change the concepts you have; it gives them more widely-used names
13:22:24 <byorgey> augur: if you work out some more details and send it to me, you may be able to convince me to spend some time thinking about it.
13:22:33 <augur> :P
13:22:58 <mtnviewmark> yes, but those that don't hold it like throwing pies... er, Ï€s... ;-)
13:23:12 <jmcarthur> return and (<=<) are also the same as Category's id and (.), which are also a lot like Monoid
13:23:24 <augur> also, does anyone know if there are any papers on combinatorial monads? that is to say, some basic monads which can somehow combine (via transformers?? i dont know) in such a way as to guarantee the result is also a monad?
13:23:42 <jmcarthur> augur: Composing Monads
13:23:46 <mtnviewmark> though today, a category theorist I happen to sit next to, finally explained to me why CTers thing of return & join as the essential aspects of monads
13:23:51 <augur> jmcarthur: aha!
13:23:52 <augur> :P
13:24:02 <mtnviewmark> but... don't... go... there....
13:24:21 <mtnviewmark> must... get... back... to... real... code....
13:24:34 <Cale> kmc: Well... it has certainly changed the whole emphasis of mathematics over the last 50 years. The emphasis on structure-preserving transformations has grown and grown even in settings where they haven't traditionally been considered.
13:24:42 <lispy> mtnviewmark: I've stumbled on some awkward return/join stuff in Haskell several times and found out it's more easily done with >>=, so I can see why they might feel it's more natural :) 
13:25:49 <byorgey> augur: Monads and Modularity, by Christoph LÃ¼th and Neil Ghani
13:25:49 <mtnviewmark> OH NO - the new wiki changed the link structure and didn't provide redirects
13:25:57 <mtnviewmark> everything on Google is now generating 404s
13:26:24 <augur> nifty. ive got plenty of reading to do :T
13:29:41 <chrisdone> mtnviewmark: looks okay to me. which links are broken for you?
13:29:41 <jro>     Warning: Defaulting the following constraint(s) to type `Integer'
13:29:41 <jro>              `Integral b'
13:29:41 <jro>                arising from a use of `floor' at Ultra/Converters.hs:10:56-62
13:29:41 <jro>     In the first argument of `fromIntegral', namely `(floor t)'
13:29:42 <chrisdone> :t 1
13:29:42 <Cale> jro: -Wall?
13:29:42 <chrisdone> lambdabot: I'm waiting...
13:29:42 <jro> yes
13:29:42 <Cale> jro: That seems like a rather innocuous thing to warn about.
13:29:43 <lambdabot> forall t. (Num t) => t
13:29:43 <mtnviewmark> @chrisdone: google found http://www.haskell.org/haskell-symposium/2010/   --- that doesn't work
13:29:43 <lambdabot> Unknown command, try @list
13:29:44 <Cale> jro: It just means that the numeric type to use as the result of floor was not made specific in the code, and it's defaulting it to Integer.
13:29:45 <Cale> (so that it can actually compute something and not just complain about ambiguous types)
13:29:53 <chrisdone> mtnviewmark: ah, was that ever on the wiki?
13:30:07 <mtnviewmark> well- Google thinks so
13:30:08 <byorgey> augur: also, the original paper on monad transformers has a nice discussion: Functional programming with overloading and higher-order polymorphism, by Mark Jones
13:30:26 <jro> Cale, how do I do it specific?
13:30:38 <augur> byorgey: ill check it out
13:33:08 <chrisdone> mtnviewmark: I think Google is being clever these days and thinks Haskell.org is called HaskellWiki. all the documentation pages hosted on haskell.org have - HaskellWiki at the end of the name, it didn't use to, and the HTML pages don't have that string in them
13:33:09 <Cale> jro: Add a type signature which pins the type down.
13:33:10 <Cale> jro: (floor ...) :: Integer
13:33:10 <mtnviewmark> hmmm... who knows - other wiki entries I google for come up with the right link
13:33:11 <mtnviewmark> is the interpose of haskellwiki new? if so, shouldn't it be redirecting at least for a while
13:33:12 <chrisdone> mtnviewmark: if they have /wiki/ in the URL, that's wiki, otherwise it's probably a custom page. either way, it looks like some stuff wasn't restored properly...
13:33:12 <mtnviewmark> 'k - just so's your aware!  
13:33:12 <mtnviewmark> thanks for the new server/site -- tis lovely!
13:33:19 <djahandarie> Oh sweet jesus. Switching from lists to vectors and ST makes my core freaking EXPLODE
13:33:34 <jro> Cale, sounds like I'll probably disable -Wall
13:33:36 <monochrom> is that a good thing?
13:33:37 <cheater99> try pilates
13:33:44 <cheater99> strenghtens the core
13:33:44 <djahandarie> monochrom, no. :P
13:33:57 <djahandarie> But it runs fast as hell now so all is well
13:34:22 <mtnviewmark> just make sure you've got containment in case of a core breach....
13:34:23 <jro> what kind of warning options you use?
13:34:30 <jro> in ghc
13:34:35 <Cale> jro: I usually just go with the defaults.
13:34:46 <unkanon> jro: that was exactly my path
13:34:48 <chrisdone> jro: you can use -Wall and disable the specific ones you don't care to hear about with -f-no-whatever
13:35:03 <unkanon> jro: I had :set jro in ghci, it started giving warnings for every little thing, so I disabled it :)
13:35:11 <Cale> unkanon: hehe
13:35:11 <monochrom> I learn the language properly and do away with warnings.
13:35:31 <unkanon> my ghci screen was scrolling up fast! (with all the warnings, lol)
13:35:43 <unkanon> chrisdone: I'll try that -f-no- tip, thanks
13:35:44 <chrisdone> monochrom: you don't use -Wall?
13:35:50 <monochrom> I don't use -Wall
13:35:51 <Cale> unkanon: :set jro  eh?
13:35:59 <Cale> ;)
13:36:12 <monochrom> I am not arrogant enough to use -w but I may in the future.
13:36:24 <chrisdone> what's -w?
13:36:33 <monochrom> turn off all bloody warnings
13:36:47 <opqdonut> but the non-bloody ones are left
13:36:49 <opqdonut> ?
13:36:57 <monochrom> all warnings are bloody
13:37:04 <chrisdone> I like being told about missing cases
13:37:12 <monochrom> ok, the real reason I don't use -w is mere laziness.
13:37:13 <unkanon> Cale: lol I hadn't noticed! (obviously!)
13:37:29 <jro> well, I still do not understand what to do to disable this particular warning
13:37:58 <jro> "disable" -> code properly
13:38:02 <unkanon> chrisdone: I like warnings about missing cases too, but sometimes it'll tell me which case it's missing and smetimes it won't, it's weird
13:38:08 <chrisdone> when I add a new data constructor to a type, my whole code-base is checked for me and it tells me which pattern matching cases are incomplete now. that's a great time saver. the alternative is sitting thinking, "now where in this 6k code base did I use this data type?"
13:38:35 <chrisdone> unkanon: you're saying it makes mistakes?
13:38:59 <unkanon> chrisdone: no, just that sometimes it'll say "you're missing a pattern match case" but won't say which
13:39:03 <Cale> jro: Well, it's not really a what I'd call a problem that I'd normally do something about (defaulting is there for a reason!) but you just add type signatures.
13:39:17 <jro> Prelude Text.Printf> :set -Wall
13:39:17 <jro> Prelude Text.Printf> fromIntegral (floor 2.2)
13:39:17 <Anonymous1991> Hey guys, I was wondering if it was possible to create a special character data type like data C = and then ONLY the lowercase and uppercase of the letters...
13:39:18 <monochrom> Well that is a good application and it requires turning on one very specific warning at a very specific moment, not -Wall and not pervasively.
13:39:26 <Anonymous1991> without summing them up
13:39:27 <Anonymous1991> ofcourse
13:39:49 <unkanon> > head . tail [1,2,3]
13:39:50 <lambdabot>   No instance for (GHC.Num.Num [a])
13:39:50 <lambdabot>    arising from a use of `e_1123' at <int...
13:39:51 <Anonymous1991> I got data C = 'a' | 'b' and so on...
13:39:57 <dskippy> I'm looking to add a graphical front end to a board game program I am writing. I'm hoping to make it a native (not web) GUI application. What GUI tool kits and graphics drawing libraries do people recommend I use?
13:39:58 <Cale> Anonymous1991: That's not valid syntax.
13:40:04 <aristid> > head . tail $ [1,2,3]
13:40:05 <lambdabot>   2
13:40:11 <Anonymous1991> no?
13:40:14 <jro> Cale: but how you override floor type signature?
13:40:17 <Makoryu> dskippy: Oh boy
13:40:20 <jro> by not defining new floor
13:40:29 <dskippy> Makoryu: :) Got opinions?
13:40:39 <Cale> Anonymous1991: Each case in a data declaration must start with a fresh (not already taken) data constructor name starting with an uppercase letter.
13:40:53 <Anonymous1991> oh I see, sorry for that
13:41:06 <Cale> Anonymous1991: which is then followed by a possibly empty sequence of types for the arguments of the data constructor
13:41:08 <Makoryu> dskippy: Do you want it to be cross-platform?
13:41:21 <Cale> Character literals are built in syntax, so you can't really define them like that.
13:41:28 <dskippy> Makoryu: I am unlikely to port it to anything but Linux, I suppose.
13:41:36 <Cale> You can think of the type Char as being defined a bit like that, but it's not really :)
13:41:44 <Anonymous1991> I see
13:41:48 <Makoryu> dskippy: Then feel free to use Gtk and such.
13:41:49 <chrisdone> monochrom: sure, but turning it on specifically would be tiresome. I very rarely get warnings from -Wall so I just have it enabled. I'm not good enough to always get it right and see every single implication of my changes
13:41:50 <Anonymous1991> but can I define a type that only gives me a - z?
13:42:00 <Anonymous1991> without summing it up ofcourse
13:42:02 <dskippy> Makoryu: What would your answer be otherwise?
13:42:21 <kmc> Anonymous1991, make a new module.  "data Alpha = MkAlpha Char".  then export "toAlpha :: Char -> Alpha" which performs the check, but don't export MkAlpha
13:42:25 <opqdonut> Anonymous1991: "newtype Alpha = Alpha char", and then only expose a constructor function that checks that the letter is in the range
13:42:28 <kmc> that's called the "smart constructor" approach
13:42:28 <monochrom> there is a condom-wearing analogy to this, you know.
13:42:33 <opqdonut> oh, kmc got there first
13:42:37 <Cale> Anonymous1991: One thing that you could do is to make a newtype of Char, but hide the data constructor for that newtype behind a module boundary, and only provide functions for constructing values of your new type which allow letters.
13:43:02 <unkanon> Cale: why did you decide (.) = fmap in lambdabot?
13:43:10 <chrisdone> monochrom: what? using a type system is like wearing a condom and without is like going out clubbing and believing everyone when they say "I'm clean"?
13:43:19 <copumpkin> dammit, disassembler on hackage is x86-only?
13:43:20 <Cale> unkanon: Because I like that generalisation of (.)
13:43:30 <copumpkin> seems short-sighted to take such general names for specific things
13:43:34 <monochrom> inexhaustive pattern is not exactly type system
13:43:35 <chrisdone> monochrom: s/type system/-Wall
13:43:57 <monochrom> do you wear condoms like babies wear diapers, i.e., 24/7 ?
13:43:57 <Anonymous1991> I don't quite get that guys with "not exposing" things...
13:44:10 <jmcarthur> copumpkin: like this? http://hackage.haskell.org/package/functors
13:44:10 <monochrom> you know, "just in case I may have sex"
13:44:11 <Anonymous1991> newtype Alpha = Alpha Char, I get that...
13:44:11 <jmcarthur> :(
13:44:14 <jro> floor' :: Double -> Int
13:44:16 <jro> floor' = floor 
13:44:19 <jro> oh well
13:44:20 <Cale> Anonymous1991: When you define a module, you specify what gets exported from it.
13:44:31 <Anonymous1991> how do I specify that?
13:44:36 <chrisdone> monochrom: I think they're kind of the same. both are ways to consider a whole code base someone's given to you, and look that they have a type system, or look that they have -Wall, and you can make some assumptions about certain properties being correct if it compiles with no errors
13:44:49 <copumpkin> jmcarthur: yeah
13:44:51 <Cale> module A (Alpha) where
13:44:59 <monochrom> do you consider "taking on condoms just before, taking off just after, that's tiresome, so let me wear 24/7"?
13:45:04 <Cale> newtype Alpha = MkAlpha Char
13:45:09 <Anonymous1991> is this possible without making new modules?
13:45:11 <unkanon> Cale: it's scary though, that sometimes it works exactly like the "regular" .
13:45:19 <unkanon> > head `fmap` tail $ [1,2,3]
13:45:20 <lambdabot>   2
13:45:22 <unkanon> > head . tail $ [1,2,3]
13:45:23 <lambdabot>   2
13:45:29 <Cale> Anonymous1991: Modules are the primary way of hiding implementation details in Haskell.
13:45:54 <kmc> i'd say closures rank up there too
13:46:10 <kmc> but they're so natural we don't think about it
13:46:11 <Cale> Anonymous1991: There's no way within the module where it's defined to prevent functions from using the MkAlpha constructor with other characters which are not alphabetic
13:46:15 <kmc> while modules can be fairly clunky
13:46:26 <jro> can you expose certain properties e.g. just to a Test module?
13:46:33 <kmc> unfortunately no
13:46:43 <Anonymous1991> Cale: but I will never be able to make a subset of characters that only contain a - z just like the how Haskell implemented itself?
13:46:49 <kmc> sometimes you'll have Foo.Internals, exporting everything, and Foo which imports it and re-exports a subset
13:46:51 <Makoryu> jro: That would be a nice feature
13:47:09 <kmc> this also lets adventurous users extend your library, if they are willing to accept more complexity and be more careful
13:47:12 <Makoryu> Anonymous1991: Sorry, nope :V
13:47:13 <kmc> ByteString works this way, to good effect
13:47:23 <Cale> Anonymous1991: Well, by only exporting functions which make values of type Alpha satisfying that constraint, it's essentially like you have.
13:47:25 <chrisdone> monochrom: I don't think your analogy works. a condom is a hinderance other than that one case. -Wall just sits silently not bothering you until you do X dangerous thing
13:47:35 <Cale> Anonymous1991: But 'a' :: Char, there's nothing that you can do about that.
13:47:39 <monochrom> well it bothers me.
13:47:48 <Cale> Anonymous1991: It's not going to belong to some other type.
13:47:52 <monochrom> it is not silent to my correct code and so it bothers me
13:48:01 <Anonymous1991> True
13:48:07 <chrisdone> monochrom: for example?
13:48:11 <kmc> you can overload string syntax in GHC
13:48:13 <kmc> but not char syntax
13:48:17 <monochrom> I have intentional inexhaustive patterns.
13:48:27 <monochrom> I have intentional defaulting, too.
13:48:30 <kmc> and you can overload numeric literals in standard Haskell
13:48:34 <Anonymous1991> well actually I thought I didn't have to do checking, but seems out to be much more complex than just checking...
13:48:49 <Anonymous1991> and it only hides my "checks"
13:48:59 <chrisdone> monochrom: intentional inexhaustic patterns... is that common?
13:49:00 <Cale> Anonymous1991: It's really hard to statically check that values you construct are in a given range.
13:49:10 <monochrom> It is common to me.
13:49:18 <chrisdone> monochrom: that's what I meant
13:49:23 <kmc> the nice thing about the "smart constructor" approach is that you do whatever checks you'd otherwise do, but what you get back is evidence that the check passed
13:49:26 <Anonymous1991> I thought data could actually block those by specifying all the "characters"...
13:49:41 <kmc> which means you can omit the check elsewhere with a fairly high degree of confidence
13:49:52 <Anonymous1991> Thanks guys! You all helped me a lot today!
13:49:56 <chrisdone> monochrom: well in that case I suppose I wouldn't enable that particular warning
13:50:03 <Cale> Anonymous1991: For example, if you wanted to define a type of integers between 0 and 100, then to do the tests statically, the operations on that type like addition would have to take proofs that the result of the operations will never be out of bounds.
13:50:16 <Anonymous1991> I see =)
13:50:37 <Cale> (and that's doable, but in Haskell, probably too much trouble to really be worth the effort)
13:50:59 <monochrom> My bugs have evolved to be warning-resistant, i.e., no warning will catch them. My correct code has also evolved to cause false alarms. -Wall has ceased to be useful or harmless.
13:51:35 <Anonymous1991> Cale: Thanks! I understand it now =)
13:51:48 <Twey> monochrom: Haha
13:53:20 <chrisdone> personally I don't remember the last non-exhaustic pattern match I had. other ones that are annoying (like unused do bind) I disable per-file sometimes. but I don't throw the baby out with the bath water, mostly warnings are helpful to me, fwiw
13:53:45 <dmwit> data MyNewChar = A | B | C | D | ... | Z -- Anonymous1991?
13:53:45 <unkanon> Cale: what does it *mean* to say (.) = fmap when fmap's implementation depends on the functor?
13:54:10 <dmwit> unkanon: It means (.) depends on the functor, too.
13:54:40 <Anonymous1991> dmwit: Yes, but I did not want to sum it all up =)
13:54:43 <dmwit> Anonymous1991: Forgive me if I'm suggesting something that's already been knocked down, I've only read about ten minutes back. =P
13:54:45 <unkanon> > (+1) . Just 5
13:54:46 <lambdabot>   Just 6
13:54:56 <unkanon> that's crazy
13:55:05 <dmwit> Anonymous1991: "sum it all up"?
13:55:38 <chrisdone> monochrom: I would be interested to see some of your code some time :p
13:55:53 <Anonymous1991> I do not want to just say A, B, C, D, E, F, but I would like to just have something that only let's characters through
13:56:00 <Anonymous1991> that are between A till Z
13:56:09 <Anonymous1991> and I would like to do that with lowercase as well
13:56:25 <Anonymous1991> lowercase a | b | c is not possible (accourding from what I've learned here)
13:56:32 <dmwit> data MyNewChar = A | ... | Z | LowerA | ... | LowerZ
13:56:39 <Anonymous1991> plus your types are not characters
13:56:41 <chrisdone> ('according')
13:56:49 <Anonymous1991> Sorry for my english
13:56:58 <unkanon> dmwit: shouldn't (.) = fmap violate the monomorphism restriction?
13:57:08 <dmwit> No, you need a new type. My understanding is that you were asking for a new type with different (more restricted) inhabitants.
13:57:09 <chrisdone> (no problem, just letting you know in case you didn't)
13:57:19 <Makoryu> Anonymous1991: It ought to be possible to write an extension that makes character literals polymorphic
13:57:25 <Anonymous1991> dmwit: true
13:57:30 <dmwit> unkanon: I doubt it, but the MR is easily worked around by adding an explicit type annotation.
13:57:44 <Anonymous1991> Makoryu: that sounds really difficult to do XD
13:57:49 <benmachine> Makoryu: you could write an extension to make most things polymorphic but how often would it actually be used
13:58:14 <Makoryu> benmachine: ...Which is probably why it doesn't exist already >_>
13:58:58 <Makoryu> Anonymous1991: I've heard it's not all that difficult to write extensions so long as you know the code base
13:59:16 <unkanon> dmwit: I can't seem to write code with . that would be "broken" under that (.) = fmap definition (I'm playing with lambdabot). does that always work, then?
13:59:22 <Anonymous1991> Makoryu: I don't know the code base XD
13:59:49 <dmwit> unkanon: I'm not sure what you mean by "always".
14:00:03 <dmwit> > 'a' . 'b' -- obviously not _always_
14:00:04 <lambdabot>   Couldn't match expected type `a -> b'
14:00:04 <lambdabot>         against inferred type `GHC.Ty...
14:00:10 <Makoryu> Anonymous1991: Well in the meantime, make do with charToAlpha and alphaToChar functions  â”(ã€€Â´ã€°`)â”Œ 
14:00:32 <unkanon> dmwit: I mean, will the "new" . always work where the old . worked?
14:00:42 <dmwit> unkanon: Oh, yes, absolutely.
14:00:51 <dmwit> (->) a is a Functor.
14:01:09 <unkanon> dmwit: then I should really always hide Prelude's . and use . = fmap? 
14:01:12 <dmwit> :t (.) `asTypeOf` (Prelude..)
14:01:13 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> a1 -> b
14:01:17 <Anonymous1991> Makoryu: I think I will keep my code simple, than making it extremely complex without checking...
14:01:42 <benmachine> unkanon: I think one could contrive a case with type classes
14:01:44 <dmwit> unkanon: If you like. The con of more polymorphism is worse error messages.
14:02:18 <unkanon> oh I don't need worse error messages at the moment :)
14:02:22 <dmwit> benmachine: Pierce's Conjecture: for all X, X is possible with type classes
14:03:06 <benmachine> dmwit: it's not just worse error messages: more polymorphism can make wrong code typecheck
14:03:27 <dmwit> If it typechecks, is it really wrong? ;-)
14:03:31 <chrisdone> (included in appendix is proof by Oleg)
14:03:51 <benmachine> dmwit: my favourite example is
14:03:54 <unkanon> dmwit: so . = fmap only works because (->) is a Functor?
14:04:09 <benmachine> :t forever putStrLn "foo"
14:04:10 <lambdabot> forall b. b
14:04:24 <benmachine> doesn't do what it looks like :P
14:04:29 <dmwit> unkanon: (.) = fmap is a sensible generalization because ((->) e) is a Functor, yes.
14:04:50 <chrisdone> :t forever putStrLn
14:04:51 <lambdabot> forall b. String -> b
14:04:53 <Makoryu> unkanon: Yep. And moreover, the definition of fmap for ((->) a) is the same as the definition of (.)
14:04:55 <chrisdone> :t forever
14:04:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:05:01 <unkanon> dmwit: so that now the new (.) is really lifting a function to work on "the next function" - we could think of it that way?
14:05:12 <chrisdone> ah, lol
14:05:15 <chrisdone> function monad
14:05:16 <dmwit> We could always think of it that way.
14:05:17 <chrisdone> I like it
14:05:27 <unkanon> Makoryu: that stuff is mind-blowing to me
14:05:36 <unkanon> in a very good way
14:05:38 <benmachine> chrisdone: the beautiful part is it isn't even a runtime error, it's just an infinite loop >_<
14:06:09 <chrisdone> benmachine: that is a cute nightmare
14:06:23 <benmachine> I discovered it the hard way :P
14:06:30 <chrisdone> I can imagine
14:06:45 <unkanon> @src (->) fmap
14:06:45 <lambdabot> fmap = (.)
14:06:53 <unkanon> :))
14:07:00 <unkanon> Makoryu: ^
14:07:27 <chrisdone> well it's like map and fmap
14:07:40 <unkanon> dmwit: if (->)'s fmap is indeed (.) then why does Prelude go out of its way to define a different (.)?
14:07:41 <chrisdone> I believe it used to just be 'map', but I can't remember if that's true or just a joke
14:07:49 <unkanon> dmwit: to make error messages easier, simply?
14:08:06 <dmwit> No, I doubt the decision was nearly so conscious as that.
14:08:18 <chrisdone> :t map -- newbs understand this
14:08:19 <chrisdone> :t fmap -- easier than this, was the argument I heard
14:08:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:08:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:08:40 <dmwit> They wanted a name for function composition, and chose (.) because it looked quite a lot like the symbol for function composition in math.
14:09:29 <chrisdone> ah, yes, I think it *was* just map. I remember reading a mailing list post from the 90s of someone saying "WTF happened to my map?"
14:09:44 <unkanon> dmwit: I'm sorry to bang on the same key here, but why did they want a name for function composition if (->)'s fmap *is* function composition?
14:10:01 <unkanon> chrisdone: I've seen that post too :D
14:10:10 <opqdonut> function composition came before Functors
14:10:19 <unkanon> oh.... it all makes sense now
14:10:34 <unkanon> I was starting to think we had a chronology problem
14:10:47 <copumpkin> the (.) = fmap is an oddity
14:10:49 <dmwit> Well, function composition came before the instance we're discussing, anyway.
14:11:04 <opqdonut> ueah
14:11:12 <unkanon> copumpkin: to me it looks like Prelude's (.) is an oddity, why do you say that?
14:11:32 <copumpkin> unkanon: because (.) is composition of something
14:11:34 <copumpkin> fmap is not
14:11:46 <dmwit> I dunno. If we only ever wanted the most general thing, every new language would consist only of the W combinator or some such.
14:11:50 <copumpkin> it's sort of a reverse generalization
14:11:52 <chrisdone> it's a coincidental thing
14:11:53 <unkanon> but fmap for the (->) functor is composition of functions
14:11:56 <copumpkin> fmap = (.) so (.) = fmap
14:12:02 <copumpkin> unkanon: yeah, but that's backwards
14:12:03 <aristid> copumpkin: it's pretty useful tho
14:12:08 <copumpkin> it's convenient
14:12:16 <copumpkin> short syntax for something you use a lot
14:12:17 <aristid> you often end up having code like this: (f . g . h) `fmap` x
14:12:19 <copumpkin> that's about the only justification
14:12:23 <aristid> f . g . h . x <- nicer
14:12:27 <benmachine> copumpkin: that's not a good one? ::
14:12:28 <benmachine> :P
14:12:43 <copumpkin> aristid: that obscures it, a bit, to me
14:12:56 <copumpkin> aristid: before, I knew that x is a functorial value of some sort
14:12:59 <aristid> copumpkin: f . g . h <$> x <- better?
14:12:59 <copumpkin> and f g h are functions
14:13:06 <copumpkin> yeah, I write that kind of stuff all the time
14:13:14 <unkanon> copumpkin: after all the explanations from the kind people here I really now see (.) = fmap as normal and the "old" (.) as "weird" :)
14:13:30 <aristid> unkanon: haha, now prepare to be turned back
14:13:40 <copumpkin> unkanon: the only explanation for it is syntactic convenience :P
14:13:41 <unkanon> aristid: please go on :)
14:13:42 <copumpkin> it has no "basis"
14:13:44 <aristid> (.) = fmap is quite controversial :D
14:13:58 <revenantphx> How does that even work... :\
14:13:59 <chrisdone> mathematically it's not analogous
14:14:00 <revenantphx> :t (.)
14:14:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:14:04 <revenantphx> :t fmap
14:14:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:14:14 <aristid> copumpkin: it sure has a basis: the fact that (.) is a special case of fmap
14:14:14 <unkanon> same thing :)
14:14:21 <copumpkin> aristid: yes, that's backwards
14:14:27 <unkanon> but is it special enough to warrant it's own name?
14:14:42 <dmwit> > (flip replicate "hello, " ++ (["dmwit", "world", "kitty"]!!) ++ const "!") 1 -- unkanon, how about this one?
14:14:42 <copumpkin> let's go calling concatMap on arbitrary monads
14:14:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:14:43 <lambdabot>         against inferred ty...
14:14:44 <aristid> unkanon: why does map exist when we could use fmap?
14:14:47 <copumpkin> might as well
14:14:48 <revenantphx> I always though (.) would be (a->b) -> (b -> c) -> (a -> c)
14:14:50 <orlandu63> revenantphx: replace f with e -> in the type definition
14:14:51 <revenantphx> :\
14:14:54 <unkanon> dmwit: let me see...
14:14:54 <aristid> unkanon: why does concat exist when we could use join?
14:15:00 <dmwit> hm...
14:15:04 <aristid> unkanon: why does (++) exist when we could use mappend?
14:15:05 <copumpkin> @let concatMap = (=<<)
14:15:06 <unkanon> dmwit: didn't work
14:15:06 <lambdabot>  Defined.
14:15:08 <revenantphx> :t Prelude.(.)
14:15:09 <lambdabot> Not in scope: data constructor `Prelude'
14:15:15 <revenantphx> :t Main.(.)
14:15:16 <lambdabot> Not in scope: data constructor `Main'
14:15:22 <revenantphx> :t cake
14:15:23 <lambdabot> [[Char]]
14:15:24 <aristid> revenantphx: (Prelude..)
14:15:26 <ndrsndrs> :t (Prelude..)
14:15:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:15:33 <unkanon> aristid: I really don't know, I catch myself using fmap all the time with lists
14:15:39 <revenantphx> Oh, so it is what I thought it what.
14:15:39 <dmwit> :t (++)
14:15:40 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:15:45 <revenantphx> was*
14:15:55 <revenantphx> So then there are two different (.)?
14:16:01 <aristid> unkanon: i usually use map with lists, because it makes the code more readable.
14:16:02 <Watermind> is  Data.Functor.(<$)  Haskell 2010?
14:16:06 <dmwit> oh, duh
14:16:23 <dmwit> > ((concat . flip replicate "hello, ") ++ (["dmwit", "world", "kitty"]!!) ++ const "!") 1 -- unkanon, how about this one?
14:16:24 <lambdabot>   "hello, world!"
14:16:36 <unkanon> aristid: I catch myself using fmap for everything because mythought process is "I want to lift that function to work on functors, so I'll use fmap"
14:16:40 <chrisdone> I pretty much always use map for lists and fmap for everything else. funny that
14:16:47 <benmachine> Watermind: http://haskell.org/onlinereport/haskell2010/ Data.Functor isn't
14:16:54 * Twey uses fmap for lists too, for consistency.
14:16:57 <unkanon> aristid: I usually don't care that it's the list functor or whatever other functor
14:16:58 <Watermind> thanks benmachine
14:17:00 <chrisdone> lol
14:17:20 <aristid> chrisdone: also fmap for functions?
14:17:26 <chrisdone> technically map is more descriptive because you know immediately we're dealing with lists
14:17:29 <Watermind> :t Category.(.)
14:17:30 <lambdabot> Not in scope: data constructor `Category'
14:17:31 <unkanon> I don't think in terms of the specific functor, I think in terms of lifting a *function* to work inside a functor
14:17:37 <Watermind> :t Control.Category.(.)
14:17:37 <lambdabot> Couldn't find qualified module.
14:17:43 <dmwit> :t (Control.Category..)
14:17:44 <Watermind> :(
14:17:44 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
14:17:49 <dmwit> Watermind: ^^
14:17:56 <Watermind> oh
14:18:00 <unkanon> dmwit: that is a complex bit of code
14:18:09 <unkanon> dmwit: what do you want to show there?
14:18:10 <aristid> Watermind: that's the other generalisation of (.) :)
14:18:22 <Watermind> aristid: yeap that's what I wanted to show
14:18:26 <unkanon> Twey: yes, consistency :)
14:18:29 <dmwit> unkanon: It was mostly a question of whether you find the generalized (++) better than the normal one.
14:18:41 <chrisdone> I tried (.) = fmap and (++) = mconcat for a while but it didn't rub off
14:19:10 <dmwit> If only we could write (;) = flip (.)
14:19:27 <chrisdone> I prefer fmap (+2) to (. (+2)) 
14:19:33 <aristid> Watermind: except you failed to properly use the right syntax for qualified operators :)
14:19:48 <Watermind> aristid: yeap :S
14:19:50 <chrisdone> dmwit: hehe. and (>>>) is way to LOUD
14:20:04 <chrisdone> f >>> g >>> x
14:20:04 <chrisdone> HERE COMES ANOTHER FUNCTION
14:20:10 <unkanon> lol
14:20:20 <unkanon> isn't >>> like F#'s |>
14:20:20 <Watermind> dmwit: that would actually be really cool
14:20:20 <unkanon> ?
14:20:28 <aristid> chrisdone: how about |- or so?
14:20:35 <Watermind> dmwit: not exactly backwords compatible but very cool 
14:20:37 <chrisdone> I don't know F#
14:20:37 <ndrsndrs> unkanon: it's f#'s >>
14:20:37 <unkanon> dmwit: there's a generalized (++)? I didn't know about it
14:20:41 <Watermind> *backwards
14:20:49 <aristid> :t let (|-) = flip (Prelude..) in 4 |- succ
14:20:50 <lambdabot> forall a b. (Num b, Enum b) => a -> b
14:20:50 <chrisdone> unkanon: (++) = mconcat
14:20:52 <ndrsndrs> unkanon: |> is flip ($)
14:20:54 <aristid> > let (|-) = flip (Prelude..) in 4 |- succ
14:20:55 <lambdabot>   Not in scope: `Prelude..'
14:21:00 <chrisdone> :t mconcat
14:21:01 <chrisdone> :t (++)
14:21:01 <lambdabot> forall a. (Monoid a) => [a] -> a
14:21:02 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:21:03 <dmwit> unkanon: Well, in that code I pasted the things on either side of the (++)'s are functions, so that should tip you off a bit... =P
14:21:06 <chrisdone> woops
14:21:07 <aristid> > let (|-) = flip (.) in 4 |- succ
14:21:07 <lambdabot>   No instance for (GHC.Num.Num (f a))
14:21:08 <chrisdone> mappend
14:21:08 <lambdabot>    arising from a use of `e_14' at <int...
14:21:10 <chrisdone> I meant
14:21:19 <chrisdone> :t mappend
14:21:19 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:21:27 <unkanon> ndrsndrs: I believe I defined a |> for haskell for me to use, but its definition wasn't as concide as flip id :P
14:21:39 <chrisdone> > [Just "hello"] ++ [Just "world"]
14:21:40 <lambdabot>   [Just "hello",Just "world"]
14:21:48 <chrisdone> > Just "hello" ++ Just "world"
14:21:49 <lambdabot>   Just "helloworld"
14:21:49 <aristid> > let (|-) = flip (.) in (*2) |- succ $ 5
14:21:51 <lambdabot>   11
14:22:06 <aristid> > let (|>) = flip (.) in (*2) |> succ $ 5
14:22:07 <lambdabot>   11
14:22:26 <aristid> unkanon: well, you can still change the definition
14:22:33 <aristid> :t flip fmap
14:22:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
14:22:42 <chrisdone> aristid: seems alright but I'd personally never use it
14:22:59 <Watermind> where are all the Functor instances defined?
14:23:06 <Watermind> like ((->) a)
14:23:12 <chrisdone> I often start with a (b (c ...)) and then rewrite to a . b . c
14:23:13 <aristid> Watermind: Control.Monad.Instances
14:23:13 <unkanon> dmwit: but the functions on either side of (++) are returning strings
14:23:18 <Watermind> aristid: oh in monad?
14:23:25 <aristid> Watermind: i think so
14:23:44 <aristid> i think the (e ->) instance should be in Prelude
14:23:46 <djahandarie> Grr
14:23:48 <Watermind> aristid: thanks... would be nice if the libs documentation had these links
14:23:52 <unkanon> > let (|>) = flip ($) in tail "hey" |> head
14:23:53 <lambdabot>   'e'
14:23:59 <unkanon> yeah that's really |>
14:24:09 <djahandarie> Failing to make this program parallelize in any nice fashoin
14:24:11 <aristid> unkanon: ok, my |- is something else
14:24:33 <chrisdone> djahandarie: boo, you suck! go back to java
14:24:45 <chrisdone> djahandarie: what's the program?
14:24:57 <unkanon> aristid: I don't get how that one is useful, |-
14:24:58 <djahandarie> Just some stupid numeric performance golfing I'm doing
14:25:08 <aristid> unkanon: it's like (>>>), just shorter
14:25:21 <unkanon> aristid: you're assuming I get >>> :)
14:25:33 <unkanon> aristid: for instance, I see |> being useful to aid readability
14:25:42 <Watermind> aristid: yeap me too
14:26:04 <aristid> unkanon: (>>>) is just flip (<<<), and (<<<) is a generalisation of the Prelude (.)
14:26:04 <chrisdone> Arrows are Yet Another Haskell Concept That Seems Pointless At First But Then Is Useful For ...
14:26:06 <Watermind> is it possible to flip a binary type constructor?
14:26:08 <chrisdone> ... Figuring Out How To Use This Damn Library
14:26:27 <aristid> Watermind: type Flip f a b = f b a
14:26:27 <chrisdone> Watermind: it is indeed, my friend!
14:26:28 <Watermind> well, flip and apply
14:26:41 <chrisdone> ^
14:27:08 <Saizan> "type Flip f a b = f b a" is not very useful
14:27:21 <djahandarie> chrisdone, http://hpaste.org/42009/lalala
14:27:43 <djahandarie> I saw some program on reddit and tried to make it go faster
14:27:45 <Saizan> you might need "newtype Flip f a b = Flip (f b a)"
14:27:48 <unkanon> > let (|-) = flip (.) in (+1) |- succ 5
14:27:49 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
14:27:49 <lambdabot>    arising from a use of `...
14:27:51 <unkanon> > let (|-) = flip (.) in (+1) |- succ $ 5
14:27:52 <lambdabot>   7
14:27:53 <djahandarie> And I did. But not as fast as I want it to go. :P
14:28:07 <chrisdone> Saizan: normal type alias can also be useful
14:28:16 <copumpkin> chrisdone: what for
14:28:18 <Watermind> aristid: chrisdone: thanks... is this H98?
14:28:22 <chrisdone> haskelldb :D
14:28:34 <chrisdone> I have: type a :%: f = f a
14:28:36 <copumpkin> you can't partially apply it, and for fully applied cases you can flip the arguments yourself
14:28:36 <chrisdone> mmmm
14:28:52 <aristid> Watermind: type Flip f a b = f b a is valid H98, yes
14:28:54 <Watermind> copumpkin: you can't? that's what I wanted
14:28:55 <unkanon> > let (|-) = flip (.) in (*2) |- succ $ 5
14:28:56 <lambdabot>   11
14:29:04 <copumpkin> Watermind: type synonyms must be fully applied
14:29:12 <Watermind> copumpkin: :S
14:29:13 <unkanon> aristid: oh, f |- g $ x is the same as g . f $ x
14:29:18 <Watermind> I wanted (->a)
14:29:21 <aristid> copumpkin: in H98?
14:29:25 <aristid> unkanon: yes.
14:29:27 <copumpkin> aristid: in haskell
14:29:30 <copumpkin> Watermind: it's actually a fairly deep limitation
14:29:30 <unkanon> > succ . (*2) $ 5
14:29:31 <lambdabot>   11
14:29:38 <Saizan> Watermind: you need a newtype
14:29:42 <copumpkin> and removing it would change a lot of things
14:29:42 <Watermind> argh :S
14:29:49 <copumpkin> and come at a cost
14:29:56 <ziman> http://kyberia.sk/id/4432031 <-- this is why
14:30:31 <aristid> copumpkin: somehow i feel like type synonyms are second-class in haskell (probably for some good reasons)
14:30:33 <Watermind> ziman: yes makes sense
14:30:39 <copumpkin> aristid: in that paste ziman just linked to
14:31:11 <benmachine> aristid: I'd say they are second-class, yeah
14:31:34 <jro> unkanon, can you explain what happens in succ . (*2) $ 5 , dont get it?
14:31:58 <unkanon> jro: what part of it don't you understand?
14:32:10 <jro> . is composition, right
14:32:21 <tromp_> 500*0.49
14:32:26 <jro> oh, sorry
14:32:27 <tromp_> > 500*0.49
14:32:27 <unkanon> jro: yes.
14:32:28 <lambdabot>   245.0
14:32:41 <jro> now I got it
14:32:45 <unkanon> jro: :)
14:33:25 <applicative> 'that thing where you add one after multiplying by two' -- apply that to five.  There's my deep analysis
14:33:32 <copumpkin> lol
14:33:50 <unkanon> yep
14:33:50 <chrisdone> copumpkin: type a :%: f = f a  -- for what I use this for you don't want to flip them yourself
14:33:58 <copumpkin> oh okay
14:34:08 <chrisdone> author :: Table :$: Expr
14:34:08 <chrisdone>   :%: Id            ::: Int
14:34:08 <chrisdone>   :+:  Submission   ::: Int
14:34:08 <chrisdone>   :+:  AuthorWeight ::: Int
14:34:11 <chrisdone> -- ten more lines
14:34:21 <unkanon> applicative: I find it weird that the fixity of (.) is so low
14:34:48 <unkanon> it would be prettier to say succ . (*2) 5
14:34:50 <chrisdone> djahandarie: ah 
14:35:13 <applicative> unkanon, i think its optimized for just this case, and a few like it
14:35:26 <djahandarie> It usually just ends up making way too many sparks and destroying itself
14:35:47 <jro> (.) succ (*2)  5
14:35:52 <djahandarie> I bet I could somehow make DPH handle this nicely
14:35:59 <Makoryu> djahandarie: I've seen cars do that
14:36:09 <djahandarie> lol
14:36:18 <chrisdone> djahandarie: which is fastest?
14:36:48 <djahandarie> chrisdone, there are only two version in there. closest and closestNaive
14:36:56 <djahandarie> Naive was just for a reference implementation
14:37:11 <djahandarie> chrisdone, http://neonstorm242.blogspot.com/2010/11/closest-pair-of-points-problem.html
14:37:33 <djahandarie> Jacked the code from there. I was originally just making it nicer to paste back and show the guy, but somehow I went down the performance rabbit hole
14:39:01 <djahandarie> It's too bad Vector code generally don't look too nice due to all the qualified importage. I suppose I could hide all the Prelude stuff for this
14:39:39 <jro> unkanon, things are different in prefix and infix application
14:39:40 <unkanon> applicative: what do you mean it's optimized?
14:40:03 <unkanon> > (.) succ (*2) $ 5
14:40:04 <lambdabot>   11
14:40:15 <jro> > (.) succ (*2) 5
14:40:16 <lambdabot>   11
14:40:20 <chrisdone> djahandarie: cute problem
14:40:57 <applicative> unkanon, wrong expression (I was quoting E. Meijer).  I think it just turns out to be more useful.  For example in >>= foo . goo >>= boo . hoo 
14:40:57 <chrisdone> djahandarie: hahaha. look I made your code nicer to .. oh wait, if I can just tweak this .. brb
14:41:15 <djahandarie> Yeah basically haha
14:41:32 <djahandarie> Interestingly, the core for the list version is tiny, and the vector version is massive. Yet the vector version outperforms it almost 5x
14:41:36 <unkanon> applicative: I see
14:44:21 <applicative> infixr 9 .    infixr 0 $    infixl 1 >>=  it's hard to figure out why its reasonable that it is so
14:44:53 * applicative knows fixities by having his hand slapped by hlint.  almost as good as the typechecker
14:46:59 <aristid> applicative: ghci :info shows fixities too
14:47:02 <unkanon> applicative: yeah I gotta start using hlint, only heard about it yesterday
14:47:27 <aristid> unkanon: relax, rome wasn't built in 27 hours
14:47:42 <Makoryu> Goddammit, not again
14:47:58 <unkanon> aristid: wow you can tell from over IRC that I'm impulsive? :D
14:48:07 <Makoryu> I wish there was a "cabal nuke-and-pave" command to wipe ~/.cabal :|
14:48:09 <aristid> unkanon: yes, my special skill
14:48:25 <applicative> aristid, yeah, thats how i got those.  for some reason I can't take them in from the fixity declaration, just from experience. 
14:48:28 <jro> hlint-1.8.3 depends on haskell-src-exts-1.9.6 which failed to install
14:48:49 <unkanon> applicative: so if . is fixity 9 then function application is 10 ?
14:49:02 <applicative> it's the tightest of all!!
14:49:03 <unkanon> that's why head . tail "hey" doens't work
14:49:03 <aristid> unkanon: yes, that's a way of saying it
14:49:09 <applicative> superglue!
14:49:15 <aristid> gluesuper
14:49:25 <Saizan> jro: a common cause is that you need to install happy, and make sure it's in your PATH after that
14:49:37 <jro> yes, I noticed
14:50:45 <tromp_> @hoogle Data.Ratio->Int
14:50:46 <lambdabot> Parse error:
14:50:46 <lambdabot>   --count=20 Data.Ratio->Int
14:50:46 <lambdabot>                  ^
14:51:45 <aristid> @hoogle Ratio -> Int
14:51:45 <lambdabot> Did you mean: Ratio a -> Int /count=20
14:51:46 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
14:51:46 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
14:52:00 <aristid> @hoogle Ratio a -> Int
14:52:00 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
14:52:00 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
14:52:00 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
14:52:15 <aristid> lambdabot: you are being incredibly useful there
14:52:34 <aristid> i think @vixen should react to "lambdabot:"
14:52:41 <tromp_> @hoogle Ratio Int -> Int
14:52:41 <lambdabot> Data.Ratio denominator :: Integral a => Ratio a -> a
14:52:41 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
14:52:42 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
14:52:48 <applicative> unkanon, somewhere theres a speech by Peyton Jones where he says something like, 'the most important function in the language is application, and for this reason we denote it with a blank space.'
14:52:51 <aristid> tromp_: wtf
14:52:52 <dmwit> ?hoogle Rational -> Integer
14:52:52 <lambdabot> Data.Ratio denominator :: Integral a => Ratio a -> a
14:52:52 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
14:52:52 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
14:52:56 <dmwit> better?
14:53:33 <tromp_> what's easiest way to get  Ratio Int rounded up or down to an Int?
14:53:38 <dmwit> aristid: If you had tried Ratio a -> a, you would have gotten results as good as tromp_'s, too. =)
14:53:46 <dmwit> tromp_: floor, ceiling
14:53:47 <unkanon> applicative: yes I have the link
14:53:53 <unkanon> applicative: it's his 3 hour lecture 
14:54:20 <applicative> unkanon right, yes, now i remember it.  i listened when i was first learning haskell. 
14:54:20 <ndrsndrs> tromp_: floor/ceil?
14:54:22 <aristid> dmwit: i did not really know what tromp_ was actually searching for
14:54:26 <ndrsndrs> *ceiling
14:54:48 <unkanon> applicative: he says that just like Smalltalk has white space for message passing, so is white space in haskell for function application
14:55:19 <revenantphx> Hey, I have an interesting question to ask you guys.
14:55:30 <revenantphx> If you had to choose, what would each of you say is "the worst thing about haskell"
14:55:34 <unkanon> applicative: I'm still "first learning haskell" :)
14:55:42 <jro> hlint was eager to suggest things
14:56:09 <applicative> unkanon, oh i forgot the smalltalk part. 
14:56:15 <unkanon> revenantphx: I remember people telling me that the Num is broken in haskell
14:56:22 <revenantphx> what?
14:56:26 <Twey> Not really brokenâ€¦ just ugly
14:56:30 <applicative> revenantphx, turing completeness
14:56:37 <revenantphx> ?...
14:56:37 <lambdabot> Not enough arguments to @.
14:56:41 <revenantphx> applicative: what do you mean?
14:56:42 <ndrsndrs> revenantphx: the Functor/Applicative/Monad subclassing business
14:56:58 <Philippa_> applicative: given Haskell's type system, I'd have to disagree vehemently
14:56:59 <Makoryu> unkanon: It's not *broken*.... Just not terribly useful
14:57:01 <applicative> copumpkin will agree.  him and three other people
14:57:04 <applicative> haha
14:57:07 <jro> that seems as broken suggestion to me: distancebytime predictor $ vo2maxtime Why not: distancebytime predictor vo2maxtime
14:57:16 <monochrom> the worst thing about haskell is still stuck with plain text file
14:57:19 <Twey> The record system, to me, I think
14:57:27 <Philippa_> if you get to move to Agda or something, fair enough, but haskell itself? I'll take fix, thanks
14:57:29 <dmwit> MR, negative numbers, fixity of ($), indentation of if-then-else in do blocks, ... I could go on
14:57:48 <jro> isn't it so, that function application has higher precedence than taking filed "distancebytime" from data?
14:57:52 <applicative> Philippa, of course.  The type system is shameless in this respect.
14:57:53 <Philippa_> insufficient support for modular programming ala ML (and yes, I know the translations)
14:58:11 <ndrsndrs> dmwit: i thought the do/if indenting was fixed in H2010..?
14:58:18 <unkanon> Makoryu: I mean like, I can't define a (+) for another type because Num took it all to itself
14:58:25 <Philippa_> not really, modulo inference concerns the type system's as principled as anything else in the general vicinity of its half of the lambda cube
14:58:30 <aavogt> jro: substitute the definition of $
14:58:30 <lambdabot> aavogt: You have 1 new message. '/msg lambdabot @messages' to read it.
14:58:32 <dmwit> jro: Only record syntax has higher precedence than function application. I have no idea what "taking filed 'distancebytime' from data means", but maybe this answers your question anyway.
14:58:33 <Twey> unkanon: Ummm, that's not really how typeclasses workâ€¦
14:58:37 <djahandarie> unkanon, ... typeclasses?
14:58:38 <djahandarie> lol
14:58:38 <benmachine> fixity resolution upsets me in general
14:58:41 <chrisdone> the record system is Haskell's biggest issue right now
14:58:50 <Philippa_> ins... yeah, I was about to generalise that slightly
14:58:51 <aristid> unkanon: of course you can define (+) for another type. you just have to hide the default (+)
14:58:53 <unkanon> monochrom: what should it use? image, like smalltalk?
14:58:53 <benmachine> I mean I don't have a better idea, but it seems to cause a lot of headaches
14:58:57 <aristid> chrisdone: why?
14:59:02 <djahandarie> unkanon, the problem with Num is only a problem for Math people. :P
14:59:03 <Philippa_> insufficient lightweight support for a variety of extensible types, records included
14:59:13 <Philippa_> lightweight from the user's POV, that is
14:59:22 <aristid> djahandarie: and people who care about not having many partial functions
14:59:28 <applicative> wouldn't that be a menace for the typesystem?
14:59:35 <unkanon> aristid: I remember people telling me I can't ahve (+) work for Strings because of Num's fault alone
14:59:40 <Philippa_> applicative: wouldn't which?
14:59:43 <Twey> unkanon: Rubbish
14:59:49 <monochrom> visual language. for example just show the abstract syntax tree. get rid of "operator precedence"
14:59:53 <applicative> lightweight extensible records, etc
14:59:57 <chrisdone> aristid: the current solution is not a good solution and there are many proposed solutions each with merits and quirks and none of which SPJ or anyone with GHC chops have chosen or proposed-and-been-accepted to be included in GHC or Haskell 2056
15:00:01 <Twey> unkanon: You can have + work for anything you care to make a Num
15:00:07 <Twey> unkanon: That's what typeclasses are for
15:00:08 <unkanon> Twey: can you show me how to have (+) work as (++) for strings, then? (without defining a new String type)
15:00:11 <applicative> i hate what is called record syntax. 
15:00:23 <unkanon> Twey: that's the problem right there
15:00:28 <Philippa_> monochrom: I have to disagree there. Support for it, sure, but textual rep is still important - not least, because some people can write better than an AST dump
15:00:30 <unkanon> Twey: that Num took (+) for itself
15:00:44 <Twey> unkanon: instance Num [Char] where â€¦ (+) = (++) â€¦
15:00:46 <monochrom> the nice thing about showing the abstract syntax tree is you can customize how it is shown to you, independent of how it is shown to me.
15:00:47 <ndrsndrs> applicative: actually yes, i want to change my vote to records :)
15:00:50 <aristid> chrisdone: well, i firmly believe that solutions cannot be judged in absolute terms, and as long as there is no known better solution...
15:00:52 <unkanon> Twey: I should be able to use (+) just because I want to
15:00:59 <Twey> unkanon: Errr, no you shouldn't?
15:00:59 <aristid> unkanon: no.
15:01:00 <chrisdone> aristid: SPJ has tried several times in the past, and you can see the mailing list logs, to resolve this, asking for opinions and suggestions, but it's difficult to get a straight answer and to get people to agree
15:01:11 <Philippa_> applicative: if you asked that in '95 I'd agree. 2010? Not so much. There's perhaps a bit of work to do on some of the kinds of types I'd like to be extensible and extensible in what directions, but in principle we've known what to do for records since row types happened
15:01:20 <Twey> unkanon: You're not complaining about Num, you're complaining about typeclasses and possibly strong typing.
15:01:30 <jro> dmwit: ok thanks, I was talking about records, data Predictor = Predictor { distancebytime :: (Double -> Double) } and then distancebytime predictor time really works without $
15:01:33 <aavogt> > let (+) = (Prelude.++) in "hello" + "there"
15:01:34 <lambdabot>   Not in scope: `Prelude.++'
15:01:44 <aavogt> > let (+) = (++) in "hello" + "there"
15:01:44 <Philippa_> (and '95 is still borderline: there were extant record systems at the time that weren't complete shite)
15:01:45 <lambdabot>   "hellothere"
15:02:06 <dmwit> jro: Yes, that works, but it has nothing to do with precedence.
15:02:11 <aristid> instance Num String where (+) = (++)
15:02:19 <applicative> Philippa_, i see. I don't know the ins and outs; clearly people have been complaining forever.
15:02:42 <unkanon> aristid: Twey : isn't (+) just a symbol? it shouldn't be special, then?
15:02:44 <Philippa_> applicative: it's also been an active area of research for more than two decades. There are results, many of them viable, especially for records
15:02:53 <Twey> unkanon: It isn't specialâ€¦
15:03:14 <Philippa_> incidentally, I reckon Haskell's biggest contribution on the types side is the development of the theory of qualified types
15:03:21 <aristid> unkanon: of course it's not special.
15:03:22 <applicative> Philippa_, yes, I know of it
15:03:29 <Philippa_> (they're a mild generalisation of type classes, for those who don't know)
15:03:30 <unkanon> Twey: sorry I may well be wrong but people here gave me an ugly hack to make (+) be like (++) for Strings
15:03:31 <monochrom> > let return x = 4 in return ()
15:03:32 <lambdabot>   4
15:03:39 <monochrom> even return is not special
15:03:52 <Philippa_> (though it was less mild given the state of type classes at the time)
15:03:54 <Twey> unkanon: That's because you shouldn't be making (+) be like (++) for Strings
15:03:54 <applicative> are there pre-Haskell type-classes in the Haskell sense
15:03:55 <chrisdone> @vixen is `return' a snowflake?
15:03:55 <lambdabot> first you tell me.
15:04:02 <applicative> we associate them with the name of Wadler
15:04:17 <Philippa_> who developed them specifically for Haskell
15:04:26 <Twey> unkanon: (+) is for Nums, and for Nums it should stay
15:04:38 <aristid> Philippa_: what is a "qualified type"?
15:04:40 <Philippa_> and in response to the problem being posed during the Haskell design process
15:04:47 <applicative> right, but you'd think they'd be as important a contribution as a 'slight generalization'
15:04:50 <Twey> unkanon: The only problem with the setup is that Num includes a lot more stuff than it should (really there should be a more granular tower of numeric types)
15:05:11 <unkanon> Twey: if I want to create a typeclass (I dn't even know if I'm using this word correctly) that has nothing to do with String and I want to use the (+) symbol, do I have to make my type an instance of Num?
15:05:13 <applicative> that's the answer:  class Num.   what a chamber of horrors!
15:05:16 <Twey> Which is inconvenient and ugly, but hardly the worst feature of Haskell
15:05:16 <benmachine> the real problem is that it's not easy to split apart Num without breaking everything that uses it
15:05:20 <revenantphx> A "Combineable" typeclass for things that you can use + and - for would make sense I suppose.
15:05:21 <Philippa_> aristid: it's a universal type with some qualification attached to the quantification - for example, "has a Name field of type String", or "is in the Eq class"
15:05:27 <Twey> unkanon: Yesâ€¦ that's how typeclasses work
15:05:44 <Twey> revenantphx: No, not really
15:05:46 <aristid> unkanon: or you could use the symbol (+) and hide the default (+) symbol
15:05:51 <Twey> revenantphx: â€˜Combineâ€™ is not a single operation
15:05:53 <dmwit> Are there any classes that absolutely *must* have more than one function in them to make sense?
15:06:00 <chrisdone> I read somewhere about this effect. if you have something merely good enough people get by and add bits to it. but if you have something totally crap that everyone recognises needs to be replaced, you have endless debate over what to replace it with
15:06:01 <aristid> Philippa_: Eq a => a?
15:06:04 <applicative> Unkanon (+) (-) 1 2 3 are all bound to the typeclass Num.  
15:06:15 <Twey> revenantphx: Having (+) = (+) and (++) = mplus would be okay
15:06:18 <Philippa_> unkanon: type classes are approximately "programmable qualified types", but QTs can allow some things a given type class system may not support due to the more general requirements
15:06:19 <benmachine> dmwit: no, but there are plenty of type classes whose functions are pretty much useless on their own
15:06:22 <unkanon> applicative: but that makes those symbols unusable outside the Num class? I don't get that
15:06:29 <Philippa_> aristid: right, the bit before the => is a "qualification"
15:06:30 <applicative> unkanon, there have been some pretty amusing Num instances for this reason
15:06:31 <aristid> Philippa_: but i don't know how to translate "has a Name field of type String" to haskell
15:06:38 <benmachine> dmwit: like, if you want to specify that mempty is a unit for mappend, you have to know they both exist
15:06:44 <Philippa_> aristid: exactly, they're a more general theory
15:06:48 <djahandarie> I cannot read a thing in here...
15:06:49 <Twey> unkanon: You can't have a symbol bound to two types at once, for obvious reasons
15:07:01 <Philippa_> it's worth noticing that qualified types are also approximately constraints on quantified type variables
15:07:12 <Philippa_> that's got major implications for type inference: it's why they play nicely together
15:07:14 <dmwit> benmachine: I could imagine class Pointed a and class Pointed m => Monoid m or so.
15:07:17 <Twey> unkanon: There's nothing magical about that; it's just an obvious question of name resolution
15:07:23 <aristid> Philippa_: haskell only supports a more limited version of them?
15:07:24 <Philippa_> the qualified types become the semantics behind a constraint system, essentially
15:07:39 <benmachine> dmwit: but when would you ever use Pointed without Monoid?
15:07:39 <Philippa_> aristid: haskell supports a specific, but fairly "generalised" instance of them
15:07:40 <Twey> unkanon: If you had it being two things at once, you'd never know what a particular usage referred to
15:07:53 <aristid> Philippa_: type families and functional dependencies vastly extend the possibilities there, don't they?
15:08:02 <chrisdone> djahandarie: That's why we're #6 top channel in the world!
15:08:12 <applicative> unkanon, this causes problems, but it seems to me worth it. I just wish (+) were bound to something more general, maybe Monoid and similarly with other chunks of Num   
15:08:30 <Philippa_> those just modify your instance of qualified types: type equalities in GHC are an instance of qualified types, or at least of a mild generalisation of the formalisations of it
15:08:32 <djahandarie> chrisdone, lol.
15:08:38 <Twey> applicative: I don't think Monoid makes sense for Num
15:08:43 <unkanon> Twey: couldn't you know from looking at x and y, when I do x + y ?
15:08:46 <applicative> twey, for (+) 
15:08:49 <Twey> applicative: Right
15:08:53 <Philippa_> qualified types are a framework of which these things are an instance
15:08:55 <Twey> applicative: It doesn't make sense for numbers
15:08:55 <applicative> of course, then there's (*) 
15:09:00 <Twey> Right
15:09:15 <Twey> There are various different algebraic structures that do this sort of thing, but I don't think Monoid is the right one
15:09:19 <Twey> Group and Field and stuff
15:09:36 <chrisdone> move (+) and (*) out of Num and have MonoidPlus and MonoidProduct?
15:09:37 * Twey doesn't really know about this sort of thing, but it's mostly in the numeric-prelude
15:09:47 <applicative> Twey, I see, yes.  
15:09:49 <Twey> chrisdone: There's also LeftMonoid and RightMonoid and so on
15:09:50 <djahandarie> Monoid is just as good as Group and Field and stuff for numbers
15:10:11 <Twey> unkanon: Noâ€¦ you can have a type be an instance of more than one typeclass (it would be damn useless if you couldn't)
15:10:23 <djahandarie> All algebraic constructs are just operators associated with sets, and laws along with those operators
15:10:41 <Twey> djahandarie: Rightâ€¦ Monoid doesn't have enough laws, though, does it?
15:10:48 <applicative> chrisdone, yes, in Lang, both are associated with 'monoid', which can be 'expressed additively' or 'multiplicatively', thus with 0 or 1 respectively as 'mappend'
15:10:49 <chrisdone> djahandarie: is that a group?
15:10:52 <applicative> as mempty
15:10:57 <hpc> ping
15:11:25 <chrisdone> applicative: what's Lang? ddarius's play language?
15:11:26 <djahandarie> The integers are a ring
15:11:41 <Philippa_> aristid: type equalities require a mild generalisation because applying a type equality isn't an operation with a simple type - to write one you'd need a type that expresses the substitution they carry out. Which puts you in a slightly larger type system than the usual framework. It's not a big deal though
15:11:44 <applicative> there seems to be a tendency of the mathematicians to use (+) when there's commutativity (*) when there maybe isn't
15:12:00 <djahandarie> Which means they form an abelian group under addition and a multiplicative monoid
15:12:13 <djahandarie> (abelian group being a commutative group)
15:12:15 <aavogt> dmwit: how abou   class C a b | a -> b, b -> a
15:12:25 <applicative> so we could have commutativity as a law of "AdditiveMonoid" .... don't know what good it would do
15:13:03 <chrisdone> applicative: the aesthetic choices of mathematicians do not comfort me
15:13:06 <aavogt> say the methods have types a and b
15:13:06 <applicative> chrisdone, I was just thinking of this textbook I have, i think once well known, Serge Lang, Algebra
15:13:11 <Philippa_> it'd piss off people who have two non-commutative monoids on a type?
15:13:43 <applicative> chrisdone, i was thinking this one made sense, but I agree.  in any case, they get away with murder, since they presuppose an intelligent being as interpreter
15:14:11 <tromp_> :t round
15:14:12 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:14:17 <djahandarie> Writing out these structures in Haskell would mainly be a bunch of identical typeclasses since often just the laws differ between them
15:14:31 <djahandarie> Agda has a neat math library somewhere
15:14:51 <chrisdone> applicative: I don't know what you mean
15:14:52 <dmwit> benmachine:       5401 Westbard Ave #803
15:14:52 <dmwit>       Bethesda, MD 20816
15:14:55 <dmwit> ...uh
15:15:03 <dmwit> http://hackage.haskell.org/packages/archive/data-default/0.2/doc/html/Data-Default.html
15:15:08 <dmwit> That's essentially Pointed.
15:15:19 <dmwit> (And I've used it a lot to good effect.)
15:15:27 <revenantphx> Hm, so one question.
15:15:33 <applicative> chrisdone I just mean that they don't have to worry about niceties of symbolism.  Their meaning is clear -- to each other; but not to a machine....
15:15:35 <chrisdone> I use def a lot
15:15:39 <revenantphx> I need to choose a backing for a data type.
15:15:49 <revenantphx> I will be storing large amount of bytes in it.
15:15:55 <aavogt> dmwit: if you had a dummy function    const :: C a b => a -> b -> a, can you encode that with two separate classes    class A a; class B b?
15:15:55 <revenantphx> so ByteString or the lazy version.
15:15:55 <djahandarie> dmwit, how is that Pointed?
15:15:59 <revenantphx> I'm not sure which is preferable.
15:16:07 <aavogt> @type pure
15:16:08 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
15:16:23 <dmwit> aavogt: That's a good example, but are there any classes that do that? I was asking for practical examples, not theoretical ones. =)
15:16:46 <dmwit> djahandarie: How is it not?
15:17:36 <djahandarie> dmwit, because it's not? lol
15:17:37 <revenantphx> @hoogle const :: C a b => a -> b -> a
15:17:37 <lambdabot> Warning: Unknown class C
15:17:38 <lambdabot> Prelude const :: a -> b -> a
15:17:38 <lambdabot> Data.Function const :: a -> b -> a
15:17:45 <ndrsndrs> dmwit: def :: forall (a :: *). a; pure :: forall (f :: * -> *) (a :: *). a -> f a
15:17:49 <dmwit> djahandarie: What is Pointed, then?
15:17:54 <ndrsndrs> (pointed is the one with pure, right?)
15:18:16 <dmwit> Oh, is Pointed the name of an actual existing class? Sorry about that.
15:18:17 <djahandarie> dmwit, a typeclass that guarentees a -> f a.
15:18:24 <dmwit> I just meant Pointed as in pointed sets.
15:18:34 <dmwit> Sorry for the confusion.
15:18:39 <aavogt> dmwit: well it's beside your point, because you could still have     class A a b | ... ; which doesn't use b in any methods
15:18:48 <applicative> revenantphx, i don't know the answer, obviously you dont want to invite a monster strict bytestring into memory without careful arrangements...
15:18:57 <revenantphx> applicative: the size of the data is fixed.
15:19:02 <revenantphx> And it's not *that* big.
15:19:21 <aavogt> @src asTypeOf 
15:19:21 <lambdabot> Source not found. I feel much better now.
15:19:36 <hpc> asTypeOf = const
15:19:49 <orlandu63> http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html
15:19:51 <applicative> revenantphx, maybe you should see which is presupposed by the libraries you might want to use that employ Data.ByteString... 
15:19:51 <chrisdone> in this math book I have the author is talking about computer programming and goes on to show a BASIC-like pseudo-code with GOTOs and whatnot. I know math guys such at programming but it seemed to make more sense to introduce lambda calculus or something
15:20:00 <Twey> aavogt: The type is important, not the source
15:20:03 <Twey> :t asTypeOf
15:20:04 <lambdabot> forall a. a -> a -> a
15:20:15 <aavogt> Twey: well the implementation isn't apparent from the type
15:20:23 <unkanon> Twey: aristid: applicative: I gotta learn more about that before we can discuss this (typeclasses and stuff)
15:20:28 <chrisdone> (it was like in tv shows when the writers don't have experience in a technical subject but have a go at explaining anyway because they're good at explaining things)
15:20:35 <aavogt> it could give you either, seq something
15:20:36 <sinelaw> hey chrisdone 
15:20:45 <chrisdone> hi sinelaw
15:20:51 <aristid> unkanon: great
15:20:54 * chrisdone does a sine wave
15:21:01 <applicative> this yegge guy is not nice
15:21:01 <sinelaw> :)
15:21:11 <sinelaw> well done ;)
15:21:23 <chrisdone> lawl
15:21:51 <chrisdone> applicative: yeah, probably a waste of time reading his blog. I never learned anything from reading it
15:21:53 <aavogt> Twey: it was supposed to be an actual example of the trick being looked for with @hoogle const :: C a b => a -> b -> a
15:22:02 * applicative grants that the yegge headline "Microsoft to Introduce Mutually Recursive Error Messages" has some wit about it
15:22:03 <aavogt> for revenantphx's benefit
15:22:04 <aristid> chrisdone: huh? he has like 3 blog posts in 2010
15:22:12 <aristid> chrisdone: not like you'd waste a lot of time on that
15:22:29 <monochrom> heh mutually recursive error messages
15:23:06 <chrisdone> aristid: I don't waste "a lot" of time talking to bible salesmen at the front door but I wouldn't want to waste my time on that either
15:23:08 <monochrom> "the next message is lying" "the previous message is lying'
15:23:24 <applicative> monochrom, i see, it's a link to an oreilly book on windows error messages.  
15:24:06 <dmwit> monochrom: Well, at least those claims are satisfiable.
15:24:07 <chrisdone> sinelaw: got cool stuff?
15:24:11 <aristid> chrisdone: i think that implies your problem is not wasted time, but something else.
15:24:29 <dmwit> Never mind that there are multiple models.
15:24:32 <sinelaw> chrisdone, heh
15:24:40 <sinelaw> am I known for having cool stuff?
15:24:45 <chrisdone> aristid: "not wasting time" is a polite way of saying "avoiding torture"
15:24:52 <chrisdone> sinelaw: sure you are!
15:24:55 <aristid> chrisdone: ok, that makes more sense.
15:25:01 <applicative> At first it seemed like a parody: "Developing Windows Error Messages: Error Messages that Communicate"
15:26:52 <mtnviewmark> news flash: "Error Messages to Introduce Mutually Recursive Microsoft"
15:26:56 <revenantphx> What's the equivalent for mapM_ for a bytestring?
15:27:24 <mtnviewmark> sequence_ . B.map
15:27:55 <revenantphx> kk.
15:28:00 <revenantphx> :t sequence
15:28:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:28:04 <sinelaw> chrisdone, you still in italy?
15:28:07 <revenantphx> right...
15:28:14 <mtnviewmark> :t sequence_
15:28:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:28:35 <revenantphx> yep I know.
15:28:42 <mtnviewmark> :-)
15:28:58 <aavogt> mtnviewmark: [] isn't ByteString?
15:29:30 <mtnviewmark> oh fie, right ... so something like    sequence_ . flip foldr []
15:30:14 <applicative> :t mapM
15:30:15 <mtnviewmark> wish ByteString had mapToList :: (Word8 -> a) -> ByteStirng -> [a]
15:30:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:30:35 <revenantphx> mtnviewmark: i specifically don't want to keep the results.
15:30:40 <revenantphx> I want to iterate through all bytes writing them.
15:30:44 <revenantphx> wait. idea.
15:30:44 <mtnviewmark> yup
15:31:31 <mtnviewmark> :t flip B.foldr [] . ((:).)
15:31:32 <lambdabot> Couldn't find qualified module.
15:31:34 <applicative> isnt there ByteString -> [Word8], or is that horrible?
15:31:43 <mtnviewmark> :t flip Data.ByteString.foldr [] . ((:).)
15:31:44 <lambdabot> forall a. (Word8 -> a) -> BSC.ByteString -> [a]
15:31:54 <mtnviewmark> so
15:31:58 <hpc> @hoogle ByteString -> [Word8]
15:31:58 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
15:31:58 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
15:31:58 <lambdabot> Data.ByteString head :: ByteString -> Word8
15:32:05 <mtnviewmark> :t sequence_ . flip Data.ByteString.foldr [] . ((:).)
15:32:06 <lambdabot>     Couldn't match expected type `[m a]'
15:32:06 <lambdabot>            against inferred type `BSC.ByteString -> a1'
15:32:07 <lambdabot>     In the first argument of `flip', namely `BS.foldr'
15:32:07 <hpc> :t map . unpack
15:32:08 <lambdabot> Not in scope: `unpack'
15:32:10 <applicative> right. their unpack
15:32:43 <Anonymous1991> I got another question, let's say I am defining my data as follows data Something = S Optional Required, how can I make Optional optional and not required?
15:32:57 <mtnviewmark> or mapM_ . Data.ByteString.unpack
15:33:07 <Anonymous1991> Like data Something = S Int String, where Int should be actually optional
15:33:13 <mtnviewmark> so many ways... so little time.....
15:33:16 <monochrom> data Something = S (Maybe Int) Required
15:33:28 <applicative> Something a b = S a (Maybe b)
15:33:33 <dmwit> data Something = WithOpt Optional Required | WithoutOpt Required
15:33:43 <monochrom> or: data Something = S0 String | S1 Int String
15:33:51 <revenantphx> I could just use putByteString, in Data.Binary.Put
15:33:52 <dmwit> bonus: use records so you can pull out the required bit from either one with equal ease
15:33:52 <revenantphx> :\
15:33:56 <Anonymous1991> I came up with what monochrom came up with
15:34:03 <Anonymous1991> at his last reaction
15:34:30 <Anonymous1991> but if I did that and I would have like data Something = S Optional Optional Optional, I would get a huge permutation
15:34:37 <Anonymous1991> or no, I mean subset
15:34:38 <aavogt> @type Data.ByteString.foldr (\x past -> past >> ?f x) (return ())
15:34:39 <lambdabot> forall (m :: * -> *). (?f::Word8 -> m (), Monad m) => BSC.ByteString -> m ()
15:34:47 <applicative> data Something = Inted String Int | Uninted String
15:34:58 <revenantphx> :t (Data.Binary.Put.putByteString)
15:34:59 <lambdabot> BSC.ByteString -> Data.Binary.Put.Put
15:35:09 <dmwit> Anonymous1991: data Tag = A | B | C; type Something = Map Tag Value
15:35:15 <Cale> Anonymous1991: Maybe
15:35:21 <Anonymous1991> so i should use Maybe?
15:35:23 <revenantphx> Or as it says 
15:35:23 <revenantphx> putByteString       :: S.ByteString -> Put
15:35:32 <dmwit> ...in case they all have the same Optional type.
15:35:32 <monochrom> go with your heart
15:35:41 <dmwit> monochrom++
15:35:45 <mtnviewmark> sh.... no reading the manual.... you have to derive everything from first principles yourself! 
15:35:47 <Cale> Anonymous1991: I would. If you have lots of fields, also use record syntax, and think about defining an operation for combining partial values.
15:36:13 * revenantphx is not using record syntax for 40+ packets with overlapping field names.
15:36:14 <revenantphx> fuck that shit.
15:36:19 <applicative> Anonymous1991, the two constructor form is  (String x Int) + String  but (String x Int) + String  = (String + 1) Int  -- i.e. the Maybe form
15:36:23 <revenantphx> (with 3-7 average fields each)
15:36:28 <kyagrd> I just saw that haskell.org has updated to a new design
15:36:41 <Cale> Of course, if you have lots of fields it can also indicate a problem with the structuring of your data.
15:36:47 <Anonymous1991> ah ic
15:36:49 <revenantphx> It looks more modern except the serif font is... idk.
15:36:51 <mtnviewmark> revenatphx - you could have a separate sub-module for each packet type
15:36:55 <Cale> Particularly if you feel the need to reuse names of fields.
15:37:01 <revenantphx> mtnviewmark: No. Fucking. way.
15:37:05 <revenantphx> This is clean and works fine XD
15:37:07 <mtnviewmark> :-)
15:37:10 <Cale> (because that usually indicates that things are factored poorly)
15:37:20 <Anonymous1991> well actually I am writing a small thing that parses a PGN
15:37:26 <chrisdone> sinelaw: yup
15:37:26 <revenantphx> Cale: It's just that a lot of packets involve entity ids.
15:37:33 <revenantphx> so they have an "eid" field.
15:37:51 <revenantphx> I don't want to have to remember "oh right, eid___ goes to 0x17, and eid_ is for packet 0x13"
15:37:53 <revenantphx> no thank you.
15:37:58 <kyagrd> When I log in to haskell.org layout dissapears though
15:38:06 <Cale> revenantphx: Well, there's nothing so bad about including part or all of the type name in that field name and possibly abstracting the eid operation into a class.
15:38:08 <Anonymous1991> I should have something like part ::== Int? Move Int?
15:38:09 <revenantphx> The serif font on haskell.org is bleck.
15:38:18 <Anonymous1991> as a syntax
15:38:21 <monochrom> known issue. go to your preference and change "skin"
15:38:27 <Anonymous1991> at least the assignment said so
15:38:29 <Anonymous1991> therefore I thought
15:38:33 <Anonymous1991> instead of writing everything
15:38:37 <applicative> I refuse to use a record type even though my type has these fields: (a) belonging to the emperor, (b) embalmed, (c) tame, (d) sucking pigs, (e) sirens, (f) fabulous, (g) stray dogs, (h) included in the present classification, (i) frenzied, (j) innumerable, (k) drawn with a very fine camelhair brush, (l) et cetera, (m) having just broken the water pitcher, (n) that from a long way off look like flies.
15:38:37 <Anonymous1991> down
15:38:38 <Cale> Anonymous1991: That doesn't look like Haskell...
15:38:40 <monochrom> font is really chosen by your browser
15:38:42 <hpc> revenantphx: i see no serif font on haskell.org
15:38:47 <Anonymous1991> Cale: that's not haskell
15:38:48 <revenantphx> Scrrenshot?
15:38:52 <revenantphx> Maybe I'm missing the font.
15:38:52 <sm> haskell.org needs to keep its new design when you log in 
15:38:59 <Anonymous1991> it only says how I should parse things in a data structure
15:39:10 <Anonymous1991> it actually means that Int is optional
15:39:15 <Anonymous1991> and Move is required
15:39:23 <Anonymous1991> and the last one is also optional
15:39:39 <Eduard_Munteanu> Hm, why would some code in the ST monad overflow the stack? 
15:40:08 <Anonymous1991> I wrote it as follow: data Something = SIMI Int Move Int | SIM Int Move | SM Move | SMI Move Int
15:40:22 <revenantphx> Look at the fugly
15:40:22 <revenantphx> http://cl.ly/2l2T1B3Y1N401x3C1D0X
15:40:26 <Anonymous1991> but I thought maybe you guys could help me make it more compact
15:40:28 <revenantphx> What font should it be in?
15:40:37 <revenantphx> I have all of the Liberation fonts, so it's not that I don't think.
15:40:40 <aavogt> Eduard_Munteanu: the same way pure code overflows
15:41:07 <monochrom> that's what I get too. but it's really your computer rather than the web page
15:41:09 <aavogt> you're not forcing something that should get forced (or will never terminate anyways)
15:41:09 <Cale> Anonymous1991: Yeah, use the Maybe type.
15:41:20 <revenantphx> monochrom: As in, I don't have whatever font it wants to use.
15:41:26 <Cale> Anonymous1991: It's the direct analogue to what ? means in your other syntax
15:41:32 <revenantphx> And why does it want Proxima-Nova (aka a payed licensed font)
15:41:32 <monochrom> if you, say, change OS and use safari instead, you will get a different picture
15:41:37 <applicative> Anonymous1991,why SIM Int Move and SMI Move Int
15:41:55 <applicative> If you want two ways, they can be in the same order. 
15:41:56 <revenantphx> monochrom: full window: http://cl.ly/1y2r2c3W44460r253X0e
15:42:01 <revenantphx> >_>
15:42:07 <Eduard_Munteanu> Hm, why does this overflow since I added the ST stuff to 'compress'? http://paste.pocoo.org/show/298744/
15:42:10 <monochrom> in fact I'm going to precisely switch to iPod Touch
15:42:17 <dmwit> data Something = S Move (Map Bool Int) -- MAKE IT AS OPAQUE AS POSSIBLE
15:42:30 <Anonymous1991> @applicative because I did that to distinguish the first int from the second
15:42:31 <lambdabot> Unknown command, try @list
15:42:48 <applicative> Anonymous i get it.  I mean that part
15:42:53 <revenantphx> haskell.org is broken on iOS Safari T_T
15:42:58 <Eduard_Munteanu> Erm, the '!' and '$!' are attempts to fix it :)
15:43:02 <revenantphx> It goes grayed out and doesnt react to anything... 
15:43:03 <revenantphx> the f
15:43:07 <hpc> dmwit: data Something
15:43:09 <hpc> er
15:43:17 <Anonymous1991> applicative, I am sorry I don't quite follow
15:43:28 <hpc> data Something' = S Move (Map Bool Int); type Something = Identity Something'
15:43:29 <Eduard_Munteanu> Is there anything out of the ordinary?
15:43:40 <applicative> Anonymous1991, it wasn't important 
15:44:00 <monochrom> interesting, looks like the same font on iPod Touch.
15:44:02 <Anonymous1991> hpc: you guys take my question to a whole new level XD
15:44:15 <monochrom> well, I couldn't care less. good luck with being picky about font appearance.
15:44:28 <applicative> Anonymous1991 if the first and second ints are representing radically different things you can make synonyms for them, which might help intelligibility
15:45:11 <Anonymous1991> that will introduce even more data types XD, which is actually something I do not want... but I agree with you
15:45:18 <applicative> Anonymous1991  maybe just SIMI Move (Maybe Int) (Maybe Int)
15:46:20 <dmwit> hpc: data SomethingT m = S { unSomething :: m (Move, Map Bool Int) }; type Something = SomethingT Identity
15:46:31 <applicative> Anonymous1991 or SIMI {move :: Move, firstInt :: Maybe Int, secondInt: Maybe Int}
15:46:54 <Anonymous1991> ah ic
15:47:08 <dmwit> SMII, do something intelligent!
15:47:22 <dmwit> http://www.youtube.com/watch?v=65PiKsNhCsc
15:47:22 <Anonymous1991> well I think I am going for the Maybe approach, that is a lot more compact
15:47:26 <Anonymous1991> thanks for the ideas!
15:47:45 <aavogt> Eduard_Munteanu: does it still happen if you use a strict bytestring instead?
15:47:56 <applicative> then little functions to construct the different ones.  goodSimi :: Move -> Int -> Int -> SIMI   
15:48:44 <applicative> firstSimi :: Move -> Int -> SIMI  firstSimi m n = SIMI m (Just n) Nothing
15:49:06 <elliott> I assume http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html has already been linked :)
15:49:21 <monochrom> no, it hasn't.
15:49:27 <Eduard_Munteanu> aavogt: I can't try, it seems encode/decode stuff from Data.Binary wants lazy ByteStrings. And somehow I think this is the root of the performance problems.
15:49:32 <aristid> monochrom: yes, it has
15:49:37 <monochrom> but there was mention of yegge being a waste of time
15:49:41 <aristid> elliott: it has been linked, yes
15:49:54 <elliott> i like yegge :p
15:49:54 <applicative> elliot, monochrom is lying. how can we trust his advice about the typesystem
15:50:04 <aristid> precisely 30 minutes ago
15:50:12 <elliott> applicative: I'm going to have to stop typechecking my programs with monochrom
15:50:16 <elliott> I guess I could check this "GHC" thing out...
15:50:28 <aavogt> Eduard_Munteanu: well when you use ST I don't think you can get the contents of the STRef until the last time it has been modified
15:50:34 <monochrom> ?
15:50:54 <elliott> monochrom: pure silliness, that's all
15:50:56 <applicative> monochrom, just nonsense. yegge was linked
15:51:44 <Eduard_Munteanu> *sigh*
15:51:49 <aavogt> otherwise you can't expect to the implementation to predict that the value in the stref you have at the start is right one at the end
15:52:02 <aavogt> Eduard_Munteanu: and you aren't forcing the whole bytestring as-is
15:52:22 <Eduard_Munteanu> aavogt: what do you mean by forcing?
15:52:24 <applicative> elliot, it was the mutually recursive message-passing windows error messages that were amusing
15:53:28 <Eduard_Munteanu> aavogt: I thought using ST to accumulate those bits would improve performance, but I can't even try it :)
15:53:52 <aavogt> Eduard_Munteanu: you know how the order of evaluation (at least in a loose sense) is changed by strict fields, $! and so on?
15:54:30 <Eduard_Munteanu> aavogt: oh, those '!' and '$!' are attempts to fix the stack overflow.
15:54:34 <aavogt> well your loop in ST (if it actually ends up as one) doesn't make sure the whole bytestring is evaluated
15:54:46 <aavogt> only the first chunk
15:54:52 <Eduard_Munteanu> Oh.
15:55:01 <dmwit> data RealMan'sBoolean = True | False | FileNotFound
15:55:09 <hpc> dmwit: :D
15:55:21 <Eduard_Munteanu> aavogt: I don't really want it evaluated as such, the idea is B.hPut should write that to disk.
15:55:23 <sinelaw> ...  | Cookies
15:55:35 <Eduard_Munteanu> in doCompress, that is.
15:55:43 <applicative> dmwit, how do you define if then else with that?
15:55:52 <dmwit> if then else 404
15:56:21 <applicative> maybe it should be "if .. then .. else .. and_if_no_file ...
15:56:56 <aavogt> Eduard_Munteanu: did you randomly choose ST.Lazy?
15:57:06 * aavogt didn't see that earlier
15:57:12 <dmwit> You have to be very careful not to need the literal number 404 in your else clause, or the parser will do bad things. Source of a whole new class of messages to haskell-cafe@.
15:57:22 <Eduard_Munteanu> aavogt: no, before I saw the stack overflow it was ST.
15:57:36 <dmwit> -(-404) becomes the standard hack to work around this.
15:57:49 <dmwit> thereafter, --404 becomes the most common comment on Hackage
15:57:54 <sinelaw> onses and zeros
15:57:57 <hpc> dmwit: (-(-404))
15:58:05 <sinelaw> they sure don't make 'em like they used to
15:58:08 <hpc> don't forget how haskell fails at unary minus
15:58:23 <dmwit> > -(-404) --404
15:58:24 <lambdabot>   404
15:58:35 <sinelaw> where do you buy your bits, people?
15:58:36 <hpc> > -5
15:58:37 <lambdabot>   -5
15:58:42 <hpc> ah, nvm
15:58:55 <dmwit> > 404 - -404 --404?
15:58:56 <lambdabot>   Precedence parsing error
15:58:56 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
15:58:59 <elliott> sinelaw: on iTunes</snark>
15:59:00 <dmwit> ;-)
15:59:03 <revenantphx> So I'm wondering about Lazy ByteStrings
15:59:10 <dmwit> > -4 `mod` 5 -- also confusing
15:59:11 <lambdabot>   -4
15:59:12 <revenantphx> if they're lazy, could you use them like streams sort of?
15:59:14 <applicative> aavogt, are you suggesting that random choice of type is somehow bad?  my new package mtl-random uses avant garde extensions to give the compiler a random complex monad
15:59:16 <shapr> Are there any "how to write an assembler" tutorials in Haskell?
15:59:19 <sinelaw> hipster bits
15:59:38 <revenantphx> shapr: this is intepreted but relevant
15:59:39 <revenantphx> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:59:45 <revenantphx> No compiler stuff here though.
16:00:06 <hpc> perhaps read the dragon book, and adapt it to your needs
16:00:08 <sinelaw> when i was a young warthog, every zero and one was hand-crafted by haitian slaves
16:00:20 <sinelaw> nowaday they mass-produce them in argentina
16:00:30 <aavogt> applicative: no, that's my way of asking whether there was any reasoning in the choice (and whether that was always the case)
16:00:30 <Eduard_Munteanu> Ok now what's something that reads/writes does serialization to/from a ByteString _other_ than Data.Binary?
16:00:40 <hpc> sinelaw: haha, is that a lion king reference?
16:01:06 <sinelaw> hpc, mixed with being past bedtime, yes
16:01:11 * applicative grants to aavogt that he was being a little silly
16:01:14 <hpc> :D
16:01:20 * Eduard_Munteanu goes comment stuff out and try strict BS
16:01:27 <Eduard_Munteanu> (pun intended)
16:03:59 <revenantphx> If I have something like 
16:04:00 <revenantphx> STCEntityTeleport a b c d e f -> putInt8 0x22 >> put a >> put b >> put c >> put d >> put e >> put f
16:04:06 <revenantphx> (in a definition of put in an instance)
16:04:12 <revenantphx> is there any way to... simplify that?
16:04:24 <dmwit> put (a,b,c,d,e,f)
16:04:31 <revenantphx> T_T.
16:04:32 <revenantphx> fuck.
16:05:06 <applicative> foldr (>>) Ox22 . map put [....]
16:05:14 <dmwit> The derived Put instance will probably also do put (a,b,c,d,e,f), by the way.
16:05:26 <revenantphx> Yeah.
16:05:44 <Eduard_Munteanu> Ok, strict ByteString sucks even more.
16:05:46 <revenantphx> applicative: but that doesn't specify the type of 0x22
16:05:57 <revenantphx> What's the idea behind lazy bytestrings?
16:06:26 <applicative> revenantphx yes, i see not whats going on  i was just seeing an arbitrary "put"
16:06:59 <Eduard_Munteanu> revenantphx: they should be just like ordinary Strings, except faster for I/O
16:07:55 <dmwit> ByteString is not a String replacement, please.
16:08:03 <dmwit> ByteString is for bytes, Text is for strings.
16:08:21 <Eduard_Munteanu> It's a replacement for String-based IO.
16:08:30 <dmwit> Not really.
16:08:42 <revenantphx> I don't see it as a string replacement at all tbh.
16:08:50 <revenantphx> It seems to be for.. bytes
16:08:53 <revenantphx> >_>
16:08:55 <Eduard_Munteanu> Erm, rather for binary stuff, if you're concerned about text.
16:09:31 <dmwit> Yes, that's more accurate. But still a bit misleading (thank you endianness!).
16:09:41 <applicative> i see the docs contain a binary instance: (Binary a, Binary b, Binary c, Binary d, Binary e, Binary f, Binary g, Binary h, Binary i, Binary j) => Binary (a, b, c, d, e, f, g, h, i, j)
16:09:49 * Twey chuckles.
16:09:58 <benmachine> just in case!
16:10:31 <applicative> dmwit, is there a parsing library to use with Text?
16:10:45 <benmachine> applicative: many parsing libraries aren't picky about their input type
16:10:56 <benmachine> as long as you define the right class instances
16:11:03 <applicative> benmachine, as long as it isn't Text
16:11:04 <dmwit> applicative: Parsec will soon handle it, if it doesn't already.
16:11:08 <revenantphx> @hoogle gzip
16:11:08 <lambdabot> Data.Generics.Twins gzip :: GenericQ (GenericM Maybe) -> GenericQ (GenericM Maybe)
16:11:08 <lambdabot> module Codec.Compression.GZip
16:11:09 <lambdabot> Codec.Compression.Zlib.Internal GZip :: Format
16:11:10 <benmachine> parsec only requires uncons :: s -> Maybe (a, s)
16:12:11 <revenantphx> so I can't gunzip a Lazy ByteString.
16:12:14 <revenantphx> Here I have a conundrum.
16:12:26 <revenantphx> getByteString in Data.Binary.Get says that it will fail if there are not enough bytes.
16:12:47 <revenantphx> since I'll use binary-protocol, I don't want that happening ,so lazy seemed like a good option in any case.
16:12:57 <revenantphx> but gzip only takes NON lazy.
16:14:25 <revenantphx> Ideas?
16:14:32 * hackagebot Etage 0.1.4 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.4 (MitarMilutinovic)
16:15:24 <Eduard_Munteanu> High performance serialization my ass... my code is way faster :/
16:15:48 <revenantphx> nmd, gzip can use what I need.
16:19:06 <revenantphx> yeck. How am I going to approach this one :\.
16:22:44 <applicative> benmachine, well, my Text instance compiles.  Now I have to think what to parse
16:22:55 <applicative> benmachine, my Text instance of Stream
16:24:17 <benmachine> heh
16:24:26 <benmachine> a solution in search of a problem?
16:25:24 <unkanon> applicative: you're looking for something to parse just for the sake of it?
16:25:49 <benmachine> such is the magnetic pull of haskell :P
16:26:05 <applicative> unkanon, yeah
16:26:57 <Eduard_Munteanu> At the moment I feel it like a like pole.
16:28:22 <unkanon> applicative: may I suggest latin verbs? (I'm not joking)
16:28:54 <unkanon> applicative: that is to say, parse a latin verb and return it's tense and person and voice and mood etc
16:29:36 <aristid> or better yet, latin phrases
16:29:44 <aristid> but that only requires ascii
16:29:51 <aristid> applicative: parse hungarian.
16:30:44 <revenantphx> Um... this is a bit weird, but it has to be done.
16:30:57 <revenantphx> I have an Int16.
16:30:59 <unkanon> aristid: well latin phrases would be next :)
16:31:13 <revenantphx> Of which the top 4 bits are one number, the next 4 are another, and the remaining 8 are another.
16:31:23 <revenantphx> What do I want to use to put that together and take it apart?
16:31:29 <revenantphx> (this looks to be painful)
16:31:30 <unkanon> latin verbs is a good challenge because it's not too easy like nouns but not so hard like sentences
16:32:53 <revenantphx> Data.Bits I guess.
16:33:09 <revenantphx> so lets call these three Int8's a, b and c
16:33:15 <Eduard_Munteanu> revenantphx: bitwise ops, and you should probably use Word16, that is unsigned stuff
16:33:41 <revenantphx> true.
16:33:58 <revenantphx> Lets start with assuming I already have it.
16:34:05 <revenantphx> have the three Int8's.
16:34:29 <revenantphx> In C I'd do
16:34:49 <revenantphx> actually, I'm not typing out a mess of casts and shifts.
16:35:33 <revenantphx> ( (int16_t) a << 4) | ( (int16_t) b << 8) ) | c
16:35:55 <revenantphx> I think that'd work, if I assume b truncates of course.
16:36:10 <revenantphx> Well, doesn't have additional stuff in its upper bits.
16:36:15 <sohum> I was going to go "I assume <yegge link> has already been linked", but then I actually looked through the logs :P
16:37:31 <aristid> sohum: in a nice 30 minute rhythm
16:37:31 <monochrom> you should ask so I could give a correct answer this time so people wouldn't leap to conclude about my type-checking ability.
16:38:00 <revenantphx> With haskell I guess I'd have to use fromInteger to convert all of them to 16 bit values. :\
16:38:05 <aristid> monochrom: the damage has been done
16:38:32 <nominolo> revenantphx: what's broken with haskell.org on iOS?
16:38:45 <revenantphx> The whole thing is just grayed out an unresponsive. Might just be me?
16:39:00 <monochrom> works fine on my iPod Touch
16:39:24 <revenantphx> yeah now its fine
16:40:17 <revenantphx> alright, time to test stuff out and put together a fun bit shuffling routine
16:41:09 <JeroenDL> Hi
16:41:13 <revenantphx> Hi.
16:41:16 <nominolo> revenantphx: btw, the font is http://www.fontsquirrel.com/fonts/Adelle-Basic
16:41:27 <revenantphx> Which font?
16:41:37 <revenantphx> I see that font when I open it.
16:41:49 <revenantphx> I was just saying The serif doesnt seem to fit
16:41:53 <monochrom> interesting
16:41:55 <revenantphx> I see this.
16:41:57 <revenantphx> http://cl.ly/0O2e0p2W0r0W0l112123
16:42:05 <JeroenDL> Does anyone know why I cant install on OSX? http://www.dauntless.be/p/6bda0144215986721af860fda89132f4.png
16:42:14 <revenantphx> Wait a second.
16:42:20 <JeroenDL> I cant click the install button
16:42:23 <revenantphx> Also, make sure you selected the proper destination.
16:42:45 <revenantphx> You also might have failed to authenticate earlier if it asked?
16:42:53 <revenantphx> Close the package and try again I suppose?
16:43:04 <JeroenDL> tried again 10 times already
16:43:10 <nominolo> revenantphx: yes, that's how it's supposed to look
16:43:16 <unkanon> JeroenDL: are you trying to install the haskell platform or just the GHC?
16:43:34 <nominolo> It looked too boring with all sans-serif fonts
16:43:45 <unkanon> JeroenDL: did you try rebooting? (I know it's silly but it does work sometimes)
16:43:56 <JeroenDL> I want to install the platform, but it says to first install the new GHC
16:44:06 <JeroenDL> tried rebooting ...
16:44:40 <Alan> What's the difference between "let ... in ..." and "... where ..." ?
16:44:43 <revenantphx> That's odd.
16:44:48 <revenantphx> I've never had that issue.
16:44:53 <JeroenDL> maybe I dont have the latest XCode ?
16:44:56 <monochrom> no difference wherever both could be used
16:44:58 <dmwit> Alan: "let" makes an expression; "where" doesn't.
16:45:07 <revenantphx> JeroenDL: HP is entirely separate from XCode (except GCC)
16:45:14 <revenantphx> (which should be 4.2.x regardless of Xcode)
16:45:16 <Alan> dmwit: but they are 2 language constructs which achieve the same thing?
16:45:23 <dmwit> Alan: Yes.
16:45:34 <Makoryu> revenantphx: ....But you need the linker, assembler, etc. bundled with Xcode
16:45:38 <revenantphx> Yes.
16:45:40 <Alan> dmwit: assuming that the result of the "let" is the result of what's in the "in"...
16:45:49 <Alan> Ok, in that case, which is preferred?
16:45:49 <revenantphx> But Makoryu, XCode hasn't switched from GCC 4.2 in years.
16:45:58 <dmwit> Alan: Another difference is that "let" makes new bindings before the expression to evaluate, and "where" puts them after (syntactically). =)
16:46:00 <revenantphx> Apple refuses to update to GCC 4.3 due to the GPLv3 license on it.
16:46:04 <dmwit> "go with your heart"
16:46:10 <revenantphx> Instead they're pushing llvm (w00t)
16:46:20 <revenantphx> (shiftL a 12) .|. (shiftL b 8) .|. c works perfectly.
16:46:22 <dmwit> Personally, I never use let.
16:46:33 <Alan> Our lecturer used "while" exclusively (obviously to reduce the number of concepts that needed to be introduced or something) but most examples i see use "let"
16:46:51 <monochrom> at some places only one of them is legal. but when both are legal, go with your heart.
16:46:53 <Twey> ITYM â€˜whereâ€™â€¦
16:47:42 <revenantphx> How is "fromIntegral" performance wisE?
16:47:44 <Alan> Twey: yeah, haha
16:47:47 <revenantphx> i'm using it for all my integer conversions
16:47:51 <revenantphx> (8 to 16 bit etc)
16:47:55 <revenantphx> (16 to "int")
16:48:12 <nominolo> revenantphx: it's usually free
16:48:18 <monochrom> "where" has an advantage when you use guards.  f x | y>0 = 0 | y<0 = 1 | y==0 = 2 where y=x-x
16:48:21 <revenantphx> Awesome.
16:48:22 <Eduard_Munteanu> How's llvm-clang these days? I saw some benchmarks but they still weren't on par with GCC.
16:48:28 <Twey> Alan: We usually prefer â€˜whereâ€™, IME
16:48:29 <Alan> holy crap i think i'm getting this monad stuff
16:48:35 <FauxFaux> OUT
16:48:44 <Twey> FauxFaux: Haha
16:48:51 <Eduard_Munteanu> (GCC isn't on par with ICC also, but it's good enough IMHO)
16:49:06 <Makoryu> Eduard_Munteanu: Moving right along
16:49:07 <monochrom> "let" has an advantage when you use do.  do {x<-getLine; let f y = x++y; print (f "0" ++ f "1") }
16:49:09 <Twey> Alan: â€˜whereâ€™ scopes further and clutters up the body of the function less
16:49:12 <JeroenDL> Can I download GHC without the HP for OSX ?
16:49:14 <Makoryu> Eduard_Munteanu: It's self-hosting now
16:49:18 <Makoryu> JeroenDL: Yes
16:49:18 <revenantphx> put $ (shiftL (fromIntegral x :: Int16) 12) .|. (shiftL (fromIntegral z :: Int16) 8) .|. (fromIntegral y :: Int16)
16:49:20 <revenantphx> :\
16:49:27 <revenantphx> JeroenDL: Yes you can, it's also on homebrew.
16:49:28 <unkanon> Makoryu: I didn't know where-let variables could be used in guards, that's cool
16:49:29 <FauxFaux> Eduard_Munteanu: The problem with clang is that all c++ programs are undefined and clang reveals completely different bugs to gcc.
16:49:29 <Makoryu> JeroenDL: In fact, if you want GHC 7, you have to do this
16:49:30 <JeroenDL> Makoryu: and without building it from source ?
16:49:33 <Alan> also, is it normal to put helper functions in the "where" or as separate functions, when they're relevant to only one function?
16:49:38 <Makoryu> unkanon: Damn tab-complete!
16:49:41 <Alan> or should such functions probably be folded in somehow anyway?
16:49:41 <revenantphx> brew ahs ghc 6.12.3
16:49:44 <Makoryu> JeroenDL: There's a binary installer
16:49:50 <Eduard_Munteanu> Heh.
16:49:51 <unkanon> Alan: I'd say yes
16:50:04 <unkanon> Alan: that's exactly why where is useful I think
16:50:13 <unkanon> Makoryu: wha-? what happened?
16:50:31 <Alan> unkanon: ok :)
16:50:33 <Twey> do { f <- fmap (++) getLine; print $ f "0" ++ f "1" }
16:50:39 <Alan> also, IO monad = winhack
16:50:45 <dmwit> unkanon: You meant to address your previous comment (about where-bound variables) to monochrom, but it went to Makoryu, instead.
16:50:49 <JeroenDL> How come GHC is a whopping 131MB ?
16:50:50 <Twey> Alan: Depends
16:51:11 <Alan> FINALLY found an article which explained what i wanted to know re: State and IO monads and stuff...
16:51:16 <dmwit> JeroenDL: It's got all the standard libraries in.
16:51:18 <Twey> Alan: I prefer the â€˜whereâ€™, but sometimes it's cleaner to use separate functionsâ€¦ especially when they're big
16:51:22 <unkanon> dmwit: Makoryu: got it, sorry!
16:51:33 <Makoryu> No sweat
16:51:37 <Alan> Twey: but then often when they are big there might be reusable components :p
16:51:45 <unkanon> monochrom: I didn't know where-let variables could be used in guards, that's cool
16:51:48 <Twey> Alan: Sure, but nested â€˜whereâ€™s aren't much nicer
16:51:49 <monochrom> The only way to win is to not mention nicks.
16:51:52 <unkanon> dmwit: (trying again now :P)
16:51:55 <Alan> I've just realised i need to rewrite pretty much all of the haskell i've written so far :(
16:52:01 <Alan> Twey: true
16:52:15 <unkanon> Alan: which article did you like so much?
16:52:16 <Alan> also, lazy evaluation makes me happy, if i'm understanding it properly...
16:52:23 <Alan> unkanon: http://ertes.de/articles/monads.html
16:52:49 <unkanon> monochrom: but then irssi won't help me know when people talk to me
16:52:53 <Twey> Oh look, a monad tutorial
16:53:11 <unkanon> Alan: thanks
16:53:15 <monochrom> You seem to notice I talk to you just fine.
16:53:22 <Alan> so you have a function which has guards, and one "branch" does something expensive, and the other does something cheap... I can put the expensive stuff in the "where" if i want because it only gets evaluated if the "expensive" branch gets taken?
16:53:31 <unkanon> yes it does work sometimes
16:53:43 <revenantphx> Haskell is a bit cracklike.
16:53:44 <unkanon> but #haskell can scroll up quite fast sometimes
16:54:05 <Twey> Alan: Yes, but that's not what lazy evaluation is.
16:54:20 <monochrom> the next-generation irc software needs explicit flow-control.
16:54:32 <unkanon> where doesn't have anythign to do with lazy evaluation
16:54:49 <Twey> I mean, it is lazy evaluation, but it's lazy evaluation pretty much all programming languages have.  Imagine if every code branch got executed every time you ran a program!
16:54:50 <unkanon> it needs threads, maybe, like a forum
16:54:50 <Alan> unkanon, Twey: that's not what i'm saying
16:55:02 <Alan> I'm just asking if i'm correct in assuming that as a side-effect of lazy evaluation
16:55:24 <unkanon> read what Twey said
16:55:24 <Alan> the worst part of haskell is trying to unlearn thinking procedurally...
16:55:41 <monochrom> > let x = sum [0..10^100] in if True then 0 else x
16:55:41 <lambdabot>   0
16:55:42 <revenantphx> monochrom: what?
16:55:44 <unkanon> I'd say that's the best part of haskell
16:56:10 <Alan> monochrom: basically what i'm getting at
16:56:17 <revenantphx> So how are Lazy ByteStrings special?
16:56:23 <Alan> i like the "define something and it gets computed if it gets used" thing
16:56:31 <revenantphx> From what I understand they can be "incomplete" until they're actually requested.
16:56:42 <revenantphx> So, I asked before, are they useable for streams?
16:56:54 <revenantphx> But if you do that, wouldn't you have to somehow "clear out" the old data at the beginning?
16:56:55 <Alan> Anyway, i'm going to STFU now just because i'll get a misunderstanding on every "just trying to understand the language" statement i say and that eats everybody's time
16:57:12 <kmc> revenantphx, concetpually type LazyBytestring = [StrictBytestring]
16:57:22 <kmc> where the list elements ("chunks") have some smallish size like 4k
16:57:30 <kmc> so it's lazy the same way a list is, but with larger granularity
16:57:31 <revenantphx> right
16:57:43 <kmc> and yeah they're usable for streams
16:57:43 <revenantphx> So here's my issue.
16:57:56 <kmc> but lazy IO is kind of sketchy, and lazy bytestring IO no different
16:58:00 <revenantphx> If I read a lazy bytestring off of a socket through binary-protocol, how woudl it work?
16:58:02 <copumpkin> applicative: talking about me while I was gone, eh!
16:58:04 <revenantphx> is it going to block or not?
16:58:20 <revenantphx> From what I understand, it wont, and will just fetch the rest of the data when needed, but I could see that being messy.
16:58:38 <lowasser> ::sigh:: I'm having problems getting cabal-install running with GHC 7.0.1.
16:58:49 <revenantphx> The issue is that in Data.Binary.Get, getByteString is defined to FAIL if there isn't enough data TT_TT
16:58:50 <lowasser> Configuring Cabal-1.8.0.2...
16:58:50 <lowasser> Setup: At least the following dependencies are missing:
16:58:50 <lowasser> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
16:58:50 <lowasser> Error during cabal-install bootstrap:
16:58:50 <lowasser> Configuring the Cabal package failed
16:58:53 <revenantphx> And I don't want that to happen.
16:59:06 <monochrom> it blocks if the next 4k piece is not yet completely available, I guess?
16:59:19 <revenantphx> what would happen if I tried to use a non lazy one :\
17:00:00 <dcoutts_> lowasser: if you don't already have a cabal-install binary from your previous ghc install, then you can grab the darcs version of cabal-install and build it with ghc 7
17:00:12 <lowasser> ahhh, so the darcs head will do it? lovely
17:01:07 <monochrom> ok, the lazy one blocks and unblocks the socket suspends and resumes spewing out stuff. the non-lazy one just blocks until the socket says EOF
17:01:23 <monochrom> (my untested understanding)
17:01:35 <monochrom> oops, there is a severe typo.
17:01:41 <monochrom> ok, the lazy one blocks and unblocks as the socket suspends and resumes spewing out stuff. the non-lazy one just blocks until the socket says EOF
17:02:44 <monochrom> you can test it with various toy experiments
17:02:57 <applicative> benmachine my first Data.Text csv parse.  Right [["Date "," Prozac "," Lithium"," Beer"," Gloom Count"," Lethargy Level"," Gaiety Index"],["Aug 21"," 1 ton"," 2 lbs"," 3 cases"," 10 "," 10 "," 400"],["Aug 22"," 0 oz","  .5 "," six pack"," 1000"," 1"," 2"]]
17:03:07 <revenantphx> monochrom: Did you check the source?
17:03:11 <monochrom> no
17:03:28 <monochrom> oh, actually I briefly read it a long time ago.
17:03:30 <revenantphx> the function getByteString in here scares me http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/src/Data-Binary-Get.html
17:04:50 <monochrom> no, I didn't read that. I only read briefly source code of the two ByteString's.
17:05:23 <revenantphx> hm
17:06:36 * benmachine hi5 applicative 
17:07:34 <revenantphx> I'll have to test if its blocking.
17:07:48 <revenantphx> I can make a tuple type that has two values, only send 1, and see if it blocks waiting on the next or something.
17:08:10 <monochrom> the scientific method is the best
17:08:12 <applicative> benmachine, but the values that were being separated are just String. That's not very high  powered
17:08:31 * benmachine shrug
17:08:36 <benmachine> I am easily impressed
17:09:09 <haskeller> for a data Number = One | Two | Three, how can I instance the Enum class? more precisely, the toEnum and fromEnum
17:09:28 <applicative> deriving Enum?
17:09:37 <haskeller> not deriving
17:09:58 <applicative> @type fromEnum
17:09:59 <lambdabot> forall a. (Enum a) => a -> Int
17:10:11 <applicative> @type toEnum
17:10:12 <lambdabot> forall a. (Enum a) => Int -> a
17:10:16 <orlandu63> haskeller: pattern matching
17:10:26 <haskeller> uhum.
17:10:43 <applicative> I recommend that everything over 3 goes to Three.  But I think it should be One | Two | Many
17:10:55 <haskeller> in fact, it's for colors.
17:11:01 <elliott> Isn't it zero, one, infinity?
17:11:02 <haskeller> let me pastie it
17:11:15 <monochrom> @src Enum
17:11:15 <lambdabot> class  Enum a   where
17:11:16 <lambdabot>     succ                     :: a -> a
17:11:16 <lambdabot>     pred                     :: a -> a
17:11:16 <lambdabot>     toEnum                   :: Int -> a
17:11:16 <lambdabot>     fromEnum                 :: a -> Int
17:11:17 <lambdabot> [3 @more lines]
17:11:22 <monochrom> @more
17:11:23 <lambdabot>     enumFrom                 :: a -> [a]
17:11:23 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
17:11:23 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
17:11:35 <monochrom> implement all those methods
17:11:37 <haskeller> but the minimum definition is toEnum and fromEnum
17:11:48 <monochrom> nice, implement those two methods
17:12:29 <haskeller> I've tried
17:12:46 <monochrom> use a lot of pattern matching for fromEnum
17:13:04 <applicative> did you hpaste.org , haskeller
17:13:07 <unkanon> applicative: those are all the numbers some languages have
17:13:13 <monochrom> and for toEnum too, I suppose.  toEnum 0 = Zero ...
17:13:15 <orlandu63> fromEnum One = 1; fromEnum Two = 2; ... and write the inverse for toEnum
17:13:34 <applicative> that was my point data RusticCount = One | Two | Many
17:13:48 <monochrom> and rejoice at the fact that this is linear search :)
17:14:25 <monochrom> data ComputerUserCount = Click | DoubleClick | RepeatedlyClick
17:14:29 <haskeller> http://hpaste.org/42011/color
17:15:02 <haskeller> (it's an exercise of haskell school of expression, btw)
17:15:32 <haskeller> if I use deriving, [Red ..] gives me the list with the seven colors.
17:15:41 <haskeller> but using my definition, it goes forever.
17:16:26 <unkanon> haskeller: cool, I have that book, but I skip all the math stuff :P
17:16:30 <applicative> Oh i see, this is a subtlety indeed.
17:16:47 <Alan> is haskell.org down or something at the moment+?
17:17:16 <Alan> or has just every damned link on the thing been broken?
17:17:19 <haskeller> it's amazing, I learn something new almost every day
17:17:35 <Alan> well, let's put it this way, google seems to be turning up nothing but dead links to haskell.org subpages...
17:17:52 <monochrom> Then you have to implement enumFrom too
17:18:02 <Alan> at least hoogle is back up...
17:18:06 <Mithos> Alan: the main site was working a second ago
17:18:26 <monochrom> indeed deriving's toEnum is just as partial as your toEnum. toEnum 80 aborts in both cases.
17:18:28 <Alan> Mithos: yeah, the main site is, but pretty much everything that isn't at /haskellwiki/ is dead
17:18:44 <Mithos> Alan: and the links from there are working, just not the site itsel it seems :P
17:19:23 <Mithos> hmmm, the main site is haskellwiki :P
17:19:24 <applicative> monochrom, but does it end in error for [Red..] ?
17:19:30 <monochrom> no
17:19:41 <Mithos> I wonder if everything's just been moved
17:19:54 <haskeller> I suppose not, the original enumFromTo x y         = map toEnum [fromEnum x .. fromEnum y] would be fine
17:20:18 <applicative> how does GHC do it?  It must be simple.  
17:21:11 <Alan> Mithos: yeah, that's what i'm getting at... which is currently making google's index of haskell.org worthless
17:21:20 <Mithos> :/
17:21:44 <revenantphx> OW
17:21:45 <revenantphx> OW
17:21:47 <revenantphx> OW NECK PAIN
17:21:57 <revenantphx> Weird.
17:22:04 <revenantphx> It's the back of my nect, towards the top.
17:22:10 <monochrom> "these default methods only make sense for types that map injectively into Int using fromEnum"
17:22:11 <revenantphx> Like, back of my skull on the left...
17:22:35 <monochrom> you are not supposed to let the default code take over, period.
17:22:46 <haskeller> Oh, right.
17:24:19 <monochrom> file:///usr/local/share/doc/haskell98-report-html/derived.html#sect10.2
17:24:21 <monochrom> oops
17:24:37 <monochrom> http://haskell.org/onlinereport/derived.html#sect10.2
17:24:46 <monochrom> if anything, steal code from there instead
17:25:07 <monochrom> interestingly the first 4 colours match :)
17:26:07 <haskeller> What do you mean?
17:26:41 <monochrom> I don't know what I mean.
17:27:10 <haskeller> my definition or Color is exactly the same from the book.
17:27:46 <monochrom> who wrote the book? maybe related to who wrote the Report.
17:27:56 <haskeller> simply Paul Hudak.
17:28:14 <monochrom> He probably wrote that part of the Report too.
17:29:30 <haskeller> Too sad he didn't change it much from the book, so any doubt can mistakenly turn into homework like questions.
17:30:49 <monochrom> I'm agnostic to homework-or-not. False dichotomy anyway.
17:30:53 <applicative> I see, so adding enumFrom x  = enumFromTo x Violet  plugs that problem, or so it seems
17:32:18 <Alan> woo, my functional programming lecturer is in the list of people on that report
17:32:30 <monochrom> heh
17:32:41 <Alan> \o/
17:32:59 <Alan> also he is the most awesome lecturer ever
17:33:06 <monochrom> haskell world is small world
17:33:22 <Alan> not always a bad thing
17:33:48 <applicative> haskeller, I guess the default definitions of enumFrom and enumFromTo can be overridden, if you add those to the list with toEnum and fromEnum.
17:33:53 <monochrom> not like c++ world. there is no chance "my c++ lecturer is in the list of authors of The C++ Programming Language"
17:34:18 <Alan> heh
17:34:19 <adekoba> how's haskell doing
17:34:33 <djahandarie> Haven't seen him for awhile, I think something might have happened to him
17:35:10 <applicative> haskeller , and they're obviously what's used of [Red..]  and [Red .. Yellow]   That structure is familiar enough.
17:35:40 * applicative substitutes 'in' for 'of'
17:36:31 <haskeller> I see
17:36:34 <haskeller> thank you.
17:37:25 <applicative> haskeller, for example, sometimes the definition of a type class gives you choice 'define any two of these..' and derives the others.
17:37:50 <Philippa_> defaults rather than derives
17:38:18 <unkanon> applicative: I remember that from RWH I think
17:38:40 <Philippa_> it uses a generic implementation as a default, it doesn't build it the way that something like deriving Show might
17:40:45 <applicative> Philippa_ the word derives has other, non-technical senses.
17:41:12 <monochrom> "don't drink and derive" :)
17:41:16 <aavogt>  [Red..] is likely not what you think it is
17:41:28 <applicative> aavogt, what do you think it is
17:41:46 <aavogt> I think it's the . from namespace Red, in a singleton list
17:42:04 <monochrom> yeah, I had to type in [Red ..]
17:42:19 <applicative> import Data.Category as Red
17:42:36 <applicative> import qualified Data.Category as Red
17:42:37 <monochrom> but the phrase [Red..] has other, non-technical senses.  <duck>  XD
17:45:46 <applicative> @type [(.)]
17:45:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
17:46:08 <applicative> @type [(.), flip (.)]
17:46:09 <lambdabot> forall b. [(b -> b) -> (b -> b) -> b -> b]
17:46:27 <applicative> guess i'm kind of at an end there.
17:46:56 <aavogt> why? composition    f . g  has the same type as   g . f sometimes
17:47:04 <applicative> > length [(.), flip (.)]
17:47:05 <lambdabot>   2
17:47:22 <applicative> aavogt, i mean, there's nothing else to put in the list
17:47:29 <Aiden> hi people...
17:47:39 <ndrsndrs> hello
17:47:44 <applicative> hello Aiden
17:47:47 <monochrom> > map (\op -> op not not True) [Prelude..]
17:47:48 <lambdabot>   <no location info>: parse error on input `]'
17:48:10 <aavogt> ?ty [(.), flip (.), join (.)]
17:48:11 <djahandarie> monochrom, read the report!
17:48:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
17:48:11 <lambdabot>     Probable cause: `join' is applied to too many arguments
17:48:11 <lambdabot>     In the expression: join (.)
17:48:16 <revenantphx> djahandarie: hah.
17:48:17 <monochrom> plain text syntax is so weird
17:48:17 <Aiden> im kindda new in this thing... someone would recommend me a good haskell introduction material?
17:48:27 <revenantphx> monochrom: what?
17:48:31 <applicative> what is join in this context
17:48:35 <djahandarie> @where lyah
17:48:35 <lambdabot> http://www.learnyouahaskell.com/
17:48:40 <djahandarie> Aiden, see that link
17:48:54 <applicative> Aiden, ^^^ It's a wonder
17:48:55 <revenantphx> :t join
17:48:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:49:11 <Aiden> heheh
17:49:14 <Aiden> thanks
17:49:21 <applicative> if you are a knowledgable programmer, 
17:49:26 <djahandarie> yw. Feel free to stick around and ask questions
17:49:27 <applicative> @where RWH
17:49:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:49:31 <applicative> afterward
17:49:40 <Aiden> im starting collegue... im studying programming
17:50:21 <monochrom> I see, [Red..] is a syntax error either way
17:50:22 <applicative> lyah is great, you can see if you like it.  there are people here to help with apparent nonsense.
17:50:38 <dibblego> what is the best way to denote an algebraic data type in javascript?
17:51:00 <djahandarie> monochrom, I think the only time M.. is valid is when it is surrounded by whitespace or parenthesis
17:51:03 <ndrsndrs> dibblego: by its church representation, of course :)
17:51:05 <monochrom> yeah
17:51:19 <ndrsndrs> *encoding
17:51:21 <ndrsndrs> bluh
17:51:23 <dibblego> ndrsndrs, that's one way, but is it really "of course"?
17:51:37 <monochrom> use GÃ¶del numbering
17:51:45 <ndrsndrs> no i was joking, i don't know if there's a better answer
17:51:49 <ndrsndrs> sorry
17:51:53 <Philippa_> applicative: Perhaps, but there's a wider technical use of derive than the haskell deriving system that's commonly used in pseudo-mathetical contexts that's either inapplicable or misleadingly broad. Even if I'm not correcting I'm adding info
17:51:59 <monochrom> actually sometimes you may prefer scott representation/encoding
17:52:06 <Aiden> pizza's here.. gotta go..
17:52:09 <applicative> monochrom, yes, the parens mess it up [(Red..)] :: (Red.Category cat) => [cat b c -> cat a b -> cat a c]
17:52:33 <aavogt> those parens?
17:52:35 <dibblego> I guess nobody has thought about it further than I have, thanks
17:52:40 <aavogt> > [True..]
17:52:41 <lambdabot>   <no location info>: parse error on input `]'
17:52:45 <aavogt> > [True.. ]
17:52:46 <lambdabot>   <no location info>: parse error on input `]'
17:52:52 <applicative> Philippa_ it was misleading, in the context, I grant that
17:52:59 <aavogt> ah, I see
17:54:00 * applicative is deriving a contradiction from his own remarks.
17:55:16 <Philippa_> so, something I was kicking around for a few minutes (okay, okay, I needed something to think about while I was on the loo): what do we need in a DSL to support "overloaded pattern-matching" in a useful manner, akin to the way that >>= gives us "overloaded let/binding"?
17:55:18 <haskeller> > [True ..]
17:55:19 <lambdabot>   [True]
17:55:44 <djahandarie> > [1..]
17:55:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:55:58 <djahandarie> It's interesting that numeric literals have a slightly different syntax for that
17:56:02 <Philippa_> unfortunately I don't think it's easy to do well without heavyweight sugar /because we only get to see 'complex' patterns and not the 'simple' non-nested patterns they're composed of/ :-(
17:56:11 <lars9> > repeat [1..3]
17:56:12 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
17:56:23 <benmachine> Philippa_: implicit view patterns?
17:56:25 <lars9> > cycle [1..3]
17:56:26 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
17:56:29 <Philippa_> if you don't mind not being able to overload the nesting process, then it may be that fail is all you need
17:56:32 <benmachine> (not that I think those are necessarily a good idea)
17:57:01 <lars9> is 'continuation' everywhere in haskell? for lazy evaluation
17:57:18 <Philippa_> benmachine: well, if you've got a syntactic marker already it's not a horrible one and it's approximately the kind of effect needed, yeah
17:58:23 <Philippa_> if you don't mind only getting to munge the input value prior to matching, then you can make do with fail and bind but something that doesn't require a full-blown monad would be preferable
17:58:40 <Philippa_> arrows /do/ have something in this vein, but it's rather heavyweight
17:59:18 <djahandarie> All I really ever use arrows for is golfing my tuple operations
17:59:22 <Philippa_> I'm too tired to figure out a good name for the distinction between arrow-style classes and applicative/monad-style classes, but I want something on the applicative/monad-style side
17:59:31 <djahandarie> Except when I do FRP with arrows, but that isn't really that often
18:00:01 <Philippa_> something where computations are things-that-yield-values, not things-that-are-function-like
18:00:12 <blackh> I spontaneously used arrows the other day.  I *was* doing graphics, though.
18:00:53 <Ziphilt> when compiling, should i just always use -O2? is there any reason not to?
18:01:18 <romildo> How can one rewrite the following expression without using case?
18:01:21 <romildo> case exp of
18:01:22 <romildo>   Just x -> action
18:01:22 <romildo>   Nothing -> return ()
18:01:31 <djahandarie> Ziphilt, it's very aggressive so it can mess stuff up sometimes
18:01:37 <djahandarie> Ziphilt, that's pretty rare though
18:01:45 <blackh> romildo: maybe (return()) action exp
18:02:01 <djahandarie> It's what I use by default, and if the performance still isn't good I start messing around past that
18:03:06 <Ziphilt> i'll do a pseudoscientific experiment with the 'time' program :)
18:03:31 <Cale> romildo: (blackh's response assumes that action is a function of x)
18:04:52 <romildo> Cale, yes, I see that. Indeed the situation I have in my program, action is really a function of x. I have just typed the code wrongly.
18:05:12 <monochrom> maybe (return()) (\x -> action) exp
18:05:42 <o4b> Can anyone help me with some haskell?
18:05:50 <blackh> o4b: You've come to the right place!
18:05:56 <monochrom> is it hard?
18:07:08 <monochrom> perhaps blackh also thinks it's hard :)
18:07:11 <djahandarie> blackh bailed
18:07:14 <djahandarie> ha
18:07:25 <applicative> o4b, it's all we ever do 
18:07:32 <Philippa_> so I guess there's two problems with my overloaded pattern-matching construct to solve - one's the nested pattern thing, which is going to need chunky sugar and suck on that level but otherwise boil down to "call the same combinator lots", the other's the need to do binding without being let
18:07:36 <djahandarie> applicative, hey, I program sometimes too!
18:07:46 <o4b> Great, I am working in the haskell platform, and I receive this error, "test1.hs:6:18: parse error on input `|". Line 6 is as such: type Set a = [a+2 | a <- [1,2,3,4]]
18:07:57 * applicative was quoting James Dean in Rebel without a Cause
18:08:09 <Philippa_> (especially, without be a form of let that gives you higher-order computation)
18:08:11 <djahandarie> o4b, your are trying to make a type with a value
18:08:14 <o4b> I am trying to create a type synonym for that set
18:08:28 <monochrom> can't be done. not in haskell.
18:08:30 <o4b> could you explain what you mean by that?
18:08:49 <djahandarie> o4b, well. Values stay on the value level. Types are on the type level
18:08:53 <applicative> >  [a+2 | a <- [1,2,3,4]]
18:08:54 <lambdabot>   [3,4,5,6]
18:08:54 <djahandarie> o4b, you can't have a 5 in your type
18:09:01 <djahandarie> (For example)
18:09:23 <applicative>  [a+2 | a <- [1,2,3,4]] is a perfectly good item, it's just not a type.  Not in this system.
18:09:33 <djahandarie> o4b, if you explain what your trying to do more in context maybe we can help more
18:09:38 <monochrom> You could do it in the theorem prover PVS.
18:09:54 <applicative> mySet = [a+2 | a <- [1,2,3,4]]  -- o4b, that's ok
18:10:03 <blackh> o4b: The concrete type of [a + 2 | a <- [1,2,3,4]] would typically be [Int] or [Integer]
18:10:11 <applicative> > let mySet = [a+2 | a <- [1,2,3,4]]  in length mySet
18:10:12 <lambdabot>   4
18:11:02 <o4b> ok, 1 sec
18:14:00 <djahandarie> http://hpaste.org if you want to paste something btw (or any other paste site if you want)
18:14:04 <Cale> o4b: [a+2 | a <- [1,2,3,4]] is a value, (it's the list [3,4,5,6]) but you've written it in a place where you want to write a type, not a value.
18:14:42 <revenantphx> hlint is wonderful.
18:14:44 <Cale> (I suppose other people have already said as much, just thought I'd try my phrasing :)
18:15:01 <o4b> yep, I see that - I am just trying to figure out how to pose my next question
18:16:26 <Cale> o4b: Haskell has no explicit notion of subtypes, so you can't define a new type whose values are some subset of the values of another type satisfying some property. You can do things which are equivalent to that if you're willing to go to enough trouble, but it's usually easier to do runtime tests.
18:16:41 <Ziphilt> djahandarie: with my program, optimization doesn't seem to do much, but i'll continue using it. how will i know if it "messes stuff up"?
18:17:06 <djahandarie> Ziphilt, I only mean messes it up performance wise. It won't change the semantics of the program.
18:17:09 <djahandarie> Ziphilt, so you'd usually notice.
18:17:35 <Ziphilt> it'll make it /worse/? how does that happen?
18:18:11 <djahandarie> It will inline more agressively (sometimes incorrectly), and it does some common subexpression elimination in -O2 which can go wrong as well
18:18:13 <aavogt> djahandarie: maybe the program depends on whether things are inlined
18:18:44 <djahandarie> Ziphilt, but these cases are rare. Usually -O2 helps.
18:18:48 <Ziphilt> okay
18:19:02 <o4b> Ok, can you tell me if I am understanding this correctly - If I wanted to construct a list of infinite cardinality (say "x > 0") I would say this: [x | x > 0]
18:19:25 <revenantphx> One question.
18:19:28 <djahandarie> o4b, nope, with list comprehensions you start with a list (or multiple lists) and then filter them down / combine them
18:19:34 <aavogt> > [1.. ]
18:19:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:19:49 <monochrom> that won't do. [x | x<-[0..], x>0] will. but then you may as well write [x | x<-[1..]]
18:19:57 <revenantphx> If I have an Word16 in which 3 different values are encoded bitwise.
18:20:02 <monochrom> haskell is not math notation
18:20:10 <revenantphx> How would I want to extract the 4 bits AFTER the upper 4 bits.
18:20:26 <revenantphx> For the top ones I can just rshift. :\
18:20:42 <aavogt> @hoogle bit
18:20:42 <lambdabot> Data.Bits bit :: Bits a => Int -> a
18:20:43 <lambdabot> module Data.Bits
18:20:43 <lambdabot> Data.Bits class Num a => Bits a
18:21:00 <aavogt> there's a function just for extracting bits
18:22:11 <applicative> o4b, you could do 
18:22:25 <applicative> > [x | x <- [-1..] , x > 0] -- here you have a list you're drawing members from 
18:22:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:22:32 <o4b> Then it appears as I am going at this problem the wrong way - I would like to pass in any boolean returning function and yield the set (possibly infinite) that contains those values
18:22:51 <ndrsndrs> revenantphx: shiftR and (.&.)?
18:22:58 <applicative> o4b, this is what led Frege into Russells contradiction
18:23:00 <ndrsndrs> (or testBit)
18:23:14 <o4b> I'm sorry, I dont follow...
18:23:20 <applicative> o4b, the list comprehension is like comprehension in standard set theory. 
18:24:01 <applicative> you don't say "the set of all self-identical things" but "the set of all members of {0,{0}} that are self identical"
18:24:04 <djahandarie> o4b, so say, if I write a function that only returns true when given a prime number, you want a list of prime numbers back?
18:24:24 <o4b> yes
18:24:41 <djahandarie> o4b, what if the set is infinite in both directions. Where does it start?
18:24:43 <o4b> that is why I was trying to use a polymorphic type, so you could pass in any function
18:24:46 <applicative> o4b, then you use the predicate, 'isPrime' to filter [0..]
18:24:53 <revenantphx> ndrsndrs: how would i do it with (.&.)?
18:25:03 <revenantphx> you mean & it with a bitmask for the lower bits?
18:25:13 <revenantphx> .&. 2**(n)
18:25:15 <ndrsndrs> yes
18:25:21 <o4b> but that wouldnt accept, say, string values
18:25:49 <applicative> > let isPrime n = n `elem` [2,3,5,7,11,17] ; let thePrimes = filter isPrime [1...] in thePrimes
18:25:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:25:55 <revenantphx> er, (^) I guess.
18:26:06 <djahandarie> o4b, you want to look into the filter function.
18:26:13 <o4b> ok, one sec
18:26:17 <revenantphx> er, not qutie
18:26:32 <djahandarie> :t filter
18:26:33 <revenantphx> I need to do 2^n .&. 2^n-1 etc
18:26:33 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:26:49 <revenantphx> I should just right it in as 15...
18:27:21 <revenantphx> Can haskell do binary literals?
18:27:37 <ndrsndrs> i don't think so. you have hex and octal, though, of course
18:27:44 <revenantphx> True.
18:27:53 <applicative> > filter (= 'o') "hello o4b"
18:27:54 <lambdabot>   <no location info>: parse error on input `='
18:27:56 <revenantphx> 0xF should be fine for masking out 4 bits.
18:28:13 <applicative> > filter (== 'o') "hello o4b"  --apologies for lambdabot spam
18:28:14 <lambdabot>   "oo"
18:29:19 <applicative> > filter isDigit "hello o4b, haskell is 4 everyone"
18:29:20 <lambdabot>   "44"
18:33:26 <yescalona> !karma python
18:35:11 <revenantphx> http://hpaste.org/42013/broken_decoder
18:35:22 <revenantphx> I'm wondering how I should get the type mismatches resolves.
18:35:30 <revenantphx> on line 15+
18:35:42 <revenantphx> the fromIntegral should be removed I think, and the type of x y and z is inferred.
18:35:52 <revenantphx> So should I annotate the literals?...
18:36:47 <revenantphx> oh shit, I'm just mixing up arguments
18:37:18 <revenantphx> :t (Data.Binary.shiftR)
18:37:19 <lambdabot> Not in scope: `Data.Binary.shiftR'
18:37:29 <revenantphx> :t (Data.Bits.shiftR)
18:37:30 <lambdabot> forall a. (Bits a) => a -> Int -> a
18:38:13 <revenantphx> https://gist.github.com/724644
18:38:17 <revenantphx> Issue as it stands :\
18:38:19 <haskeller> you need to get bits 8->11?
18:38:38 <revenantphx> mm.
18:38:51 <revenantphx> I need the 4 most significant in one, the next four in another, then the remaining 8 in the third
18:38:56 <revenantphx> (x z and y respectively)
18:39:45 <ndrsndrs> replace `x <- something_nonmonadic` with `let x = something_nonmonadic`
18:39:58 <ndrsndrs> i.e. for x, z, y in blks
18:40:06 <revenantphx> ah, right.
18:40:19 <ndrsndrs> (since it's in a do, you don't need the `in`, btw)
18:41:19 <revenantphx> mm
18:41:36 <revenantphx> Fuck, it's not type inferring.
18:41:44 <revenantphx> At least, it's inferring wrong.
18:42:01 <revenantphx> I mean. Poop.
18:42:04 <revenantphx> https://gist.github.com/724644
18:42:19 <revenantphx> MCBlockChange is defined as a tupe of 5 Int8's
18:42:43 <BMeph> revenantphx: I'm willing to bet that it's inferring just fine, and the "wrongness" is on the programmer's part... ;)
18:42:59 <revenantphx> idk, there are two ways I can see it inferring the type.
18:43:12 <djahandarie> BMeph, no, this must be a compiler bug!
18:43:25 <revenantphx> aha, I think I see the issue.
18:43:33 <revenantphx> djahandarie: Yes that's it. GHC is broken. It's not my fault.
18:43:41 <ndrsndrs> it's because x,z,y are also Word16s, since cd is
18:43:43 <BMeph> Five Int8s sounds almost certainly in error. Word8, surely? ;)
18:43:59 <revenantphx> ... no
18:44:05 <revenantphx> The protocol specifies all types as signed.
18:44:11 <revenantphx> ndrsndrs: yep
18:44:12 <djahandarie> revenantphx, I was actually making fun of someone else who always says that... could never tell if he was serious or not either
18:44:36 <revenantphx> let x = (fromIntegral shiftR cd 12) :: Int8
18:44:39 <revenantphx> does that look right then?
18:44:39 <ndrsndrs> so more fromIntegrals
18:44:46 <ndrsndrs> if in doubt, more fromIntegrals :)
18:44:46 <revenantphx> REQUIRE MORE FROMINTEGRALS
18:44:56 <revenantphx> So they're free in most cases?
18:45:01 <ndrsndrs> i think so
18:45:08 <ndrsndrs> well, as free as they are in c
18:45:14 <ndrsndrs> (i should know this, but i don't :( )
18:45:21 <Eduard_Munteanu> Interesting... if I cabal-install bytestring, performance gets worse.
18:45:29 <revenantphx> ndrsndrs: If they're just casts internally, yeah.
18:45:44 <revenantphx>  No instances for (Integral (a1 -> Int -> a1),
18:45:44 <revenantphx>                       Num (Word16 -> t1 -> Int8))
18:45:46 <revenantphx> aw crap.
18:45:51 <djahandarie> Eduard_Munteanu, ... performance gets worse in packages unrelated to bytestring? What?
18:46:08 <ndrsndrs> more brackets
18:46:15 <revenantphx> ndrsndrs: ?
18:46:15 <ndrsndrs> if in doubt, more brackets
18:46:28 <ndrsndrs> fromIntegral (shiftR cd 12), etc
18:46:31 <revenantphx> I can't fromIntegral shiftR though...
18:46:36 <revenantphx> yeah...
18:46:38 <revenantphx> more brackets!
18:46:53 <ion> or dollars
18:46:57 <ndrsndrs> or that
18:47:00 <revenantphx> My current solution is
18:47:10 <revenantphx> 1) Bracket the hell out of code when in doubt
18:47:14 <revenantphx> 2) Let hlint help me clean up
18:47:18 <ndrsndrs> you might be able to ditch the type annotations as well
18:47:28 <revenantphx> the outer onesp robably.
18:47:56 <revenantphx> in the end this is fine let x = fromIntegral (shiftR cd 12)
18:48:21 <Eduard_Munteanu> djahandarie: no, in my code that uses ByteString.
18:48:34 <Eduard_Munteanu> Also veeeryyy interesting.... performance is better in Wine.
18:48:38 <Eduard_Munteanu> Much better.
18:48:41 <revenantphx> alright ,great
18:48:59 <djahandarie> Eduard_Munteanu, oh, so you already had ByteString from your distro/platform or something?
18:49:01 <Eduard_Munteanu> 2.1s Linux vs 1.45 in Wine.
18:49:19 <medfly`> but wine is linux?
18:49:20 <Eduard_Munteanu> djahandarie: isn't it in ghc?
18:49:26 <djahandarie> Oh yeah, it's in base
18:49:27 <djahandarie> lol
18:49:28 <Eduard_Munteanu> medfly`: um, I meant native Linux :)
18:50:05 <djahandarie> Err
18:50:05 <Eduard_Munteanu> Ok, so somehow Gentoo's GHC is fscked up?
18:50:06 <djahandarie> No it isn't
18:51:13 * Eduard_Munteanu does equery
18:51:22 <Eduard_Munteanu> dev-lang/ghc-6.12.3 (/usr/lib64/ghc-6.12.3/bytestring-0.9.1.7)
18:51:35 <Eduard_Munteanu> It isn't separate.
18:51:55 <djahandarie> Wouldn't any of your distro provided haskell packages go in there?
18:52:05 * applicative informs benmachine that he now has a Data.Text instance for the parsimony library too. We'll see what good it does
18:52:37 <Eduard_Munteanu> djahandarie: yes, but I just did equery b /usr/lib64/ghc-6.12.3/bytestring-0.9.1.7, which tells me the ghc ebuild provides that file.
18:52:39 <djahandarie> I think GHC has a bytestring dependency but I'm not entirely sure how Gentoo handles bootstrapping and such to compile GHC
18:52:54 <djahandarie> Yeah, must be in order to compile GHC
18:53:15 <djahandarie> Can't see why that code would be any different from the one you get from cabal though
18:53:32 <djahandarie> Except that it is 0.0.0.1 version earlier than the latest version
18:53:46 <Eduard_Munteanu> Well that's not the interesting thing... why is it faster in Wine?
18:53:55 <Eduard_Munteanu> $ wine ghc -V
18:53:56 <Eduard_Munteanu> The Glorious Glasgow Haskell Compilation System, version 6.10.3
18:54:16 <Eduard_Munteanu> and I'm using 6.12.3 on Gentoo
18:54:19 <djahandarie> Older version of GHC apparently
18:54:28 <djahandarie> Don't ask me!
18:55:28 <Eduard_Munteanu> wine ghc-pkg list bytestring says this Win Platform has bytestring-0.9.1.4
18:55:53 <Eduard_Munteanu> So there is a performance regression or might be 32 vs 64-bit related.
18:56:15 <djahandarie> I think there are too many variables. :P
19:00:37 <revenantphx> https://gist.github.com/724669
19:00:43 <revenantphx> Needs some clean up but... not bad :)
19:00:51 <revenantphx> 280 lines, for something that took others 400-800
19:00:58 <revenantphx> yay for concise descriptions.
19:01:24 <tg_> that means, by tloc standards, you'll be paid twice as much. Unfortunately, 2 times 0 is 0.
19:01:27 <Eduard_Munteanu> Ok so now I'm down from 8x slower than C code to 5x slower, it's better but still...
19:01:43 <revenantphx> tloc?
19:01:57 <copumpkin> revenantphx: omg those huge liftMs
19:01:58 <Eduard_Munteanu> TeraLinesOfCode?
19:01:59 <tg_> thousands [of] lines of code
19:02:08 <Eduard_Munteanu> Oh :)
19:02:11 <revenantphx> copumpkin...?
19:02:15 <copumpkin> revenantphx: have you considered just using <$> and <*> ?
19:02:20 <copumpkin> revenantphx: you have up to liftM9 :P
19:02:21 <revenantphx> ... maybe.
19:02:25 <revenantphx> Yes. Yes I do.
19:02:34 <revenantphx> I wanted them all to be consistent :P
19:02:39 * Eduard_Munteanu usually sees kloc
19:02:41 <revenantphx> I need to simplify the puts using tuples.
19:02:42 <dmwit> revenantphx: You need badly need putFloat64Listbe/getFloat64Listbe functions.
19:02:50 <revenantphx> dmwit: I do?
19:03:17 <dmwit> revenantphx: putFloat64Listbe = mapM_ putFloat64be, getFloat64Listbe = flip replicateM getFloat64be
19:03:22 <tg_> Eduard_Munteanu: that's probably right, but we the prefix matters not.
19:03:49 <tg_> s/we//
19:03:49 <revenantphx> Why do I need that > >
19:03:55 <dmwit> revenantphx: e.g. CTSPlayerPosition a b c d e -> putInt8 0x0B >> putFloat64Listbe [a,b,c,d] >> put e on line 51.
19:04:07 <revenantphx> I like how you totally ignore
19:04:09 <Alan> This is going to sound like a really poorly-thought-out question, but here goes anyway... is there a way to "mix-in" several partial definitions for a function?
19:04:13 <revenantphx>         STCPickupSpawn a b c d e f g h i -> putInt8 0x15 >> put a >> put b >> put c >> put d >> put e >> put f >> put g >> put h >> put i
19:04:21 <o4b> Can the "." operator be nested? For example, "((&& . f1) . f2)" - f1 and f2 are bool returning functions
19:04:30 <revenantphx> I'm going to condense those to tuples now.
19:04:46 <dmwit> revenantphx: Yes, there are many such places where it could use a bit of work. I'd only gotten to line 51. =P
19:04:54 <revenantphx> Oh yes.
19:04:58 <orlandu63> o4b: of course
19:05:00 <revenantphx> This is my first piece of haskell code over 100 lines
19:05:00 <Eduard_Munteanu> o4b: '.' is associative anyway, it doesn't matter
19:05:01 <revenantphx> >_<
19:05:07 <dmwit> =)
19:05:17 <o4b> hmm, then I wonder why I am getting compiler errors
19:05:25 <Eduard_Munteanu> (f . g) . h = f . (g . h) = f . g . h
19:06:57 <dmwit> revenantphx: I'd be pretty surprised if there wasn't already something to associate tags to constructors in a derived Binary instance.
19:07:05 <dmwit> That could save you a lot of work...
19:07:09 <revenantphx> ?
19:07:47 <revenantphx> Oh, well it's not 1 for 1.
19:07:52 <revenantphx> Since I have to put the id as well.
19:08:32 <dmwit> put the id?
19:09:53 <revenantphx> Can I declare a constant in a data constructor...?
19:10:08 <dmwit> No.
19:10:11 <revenantphx> mm.
19:10:51 <revenantphx> So you know anything I can do for the gets?
19:10:56 <revenantphx> all those repeated get get get get
19:11:47 <revenantphx> dmwit: modfied: https://gist.github.com/724685
19:11:50 <dmwit> All I could think of off the top of my head was something like "constructor4 c = liftM8 c get get get get".
19:12:06 <dmwit> Also, wow! The Data.Binary docs recommend exactly what you're doing. Crazy.
19:12:14 <dmwit> I would think there was some template Haskell out there by now to do this.
19:12:16 <revenantphx> which part?
19:12:32 <dmwit> the "put a tag, then put all the bits" and "get a tag, then get all the bits" part.
19:12:39 <Eduard_Munteanu> Perhaps HList would help with abstracting all those different things you "put".
19:12:42 <dmwit> It just seems so automateable.
19:12:49 <revenantphx> dmwit: agreed.
19:12:53 <revenantphx> For now however, this works :D
19:12:58 <revenantphx> And in a remakeably short amount of lines.
19:13:03 <ndrsndrs> if there were uncurryN up to a high number, `uncurry5 CTSPlayerDigging <$> get`
19:13:15 <ndrsndrs> ...but there isn't. :(
19:13:29 <dmwit> ndrsndrs: Perhaps you mean joinN, rather than uncurryN.
19:13:36 <dmwit> But even that wouldn't be right.
19:13:41 <dmwit> It wouldn't be polymorphic enough.
19:13:52 <revenantphx> The shortest implementation I've seen other than this one is in ruby and is 380 lines.
19:13:55 <Alan> huh, so list comprehensions are a special case of "do-notation" ?
19:13:57 <revenantphx> 280 in haskell is amazing.
19:14:04 <revenantphx> the C# I've seen was 760ish.
19:14:11 <revenantphx> I'm very very content with this at the moment :)
19:14:19 <ndrsndrs> i meant `get :: Get (a, b, c, d, e)`
19:14:30 <dmwit> ah yes
19:14:33 <ndrsndrs> but it's late so i might be missing something :)
19:14:46 <dmwit> Yes, I like that way a lot.
19:14:51 <dmwit> revenantphx: Did you catch that?
19:14:55 <revenantphx> What?
19:14:58 <revenantphx> using tuples?
19:15:05 <revenantphx> See my most recent gist, I changed them all to tuples.
19:15:15 <revenantphx> Oh wait, get?
19:15:20 <dmwit> Rather than liftM1..liftM8, you can use just liftM and uncurry1..uncurry8 for the get bits.
19:15:28 <Eduard_Munteanu> revenantphx: well all that '>>' chaining would be considered cheating LOC in C.
19:15:31 <dmwit> And there's even a package that provides those for you.
19:15:40 <revenantphx> Eduard_Munteanu: this is true, but this is not C.
19:15:42 <revenantphx> This is haskell :#
19:15:42 <copumpkin> Eduard_Munteanu: I don't think so
19:15:48 <revenantphx> @hoogle uncurry9
19:15:48 <lambdabot> No results found
19:15:53 <revenantphx> @hoogle uncurry8
19:15:53 <lambdabot> No results found
19:15:54 <ndrsndrs> dmwit: really?
19:15:56 <copumpkin> Eduard_Munteanu: since it's in the put monad, which C doesn't have ;)
19:15:58 <revenantphx> @hoogle uncurry4
19:15:59 <lambdabot> No results found
19:16:02 <revenantphx> :|
19:16:07 <ndrsndrs> this is something i want a lot but it's not annoying enough to do something about
19:16:16 <dmwit> http://hackage.haskell.org/package/tuple
19:16:30 <ndrsndrs> :o
19:16:33 <revenantphx> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Curry.html ?
19:16:34 <dmwit> (See especially Data.Tuple.Curry)
19:16:51 <Cale> http://www.flickr.com/photos/cgibbard/ -- a bunch of new constructions posted :)
19:16:56 <revenantphx> So how would I use that for say...the foldM9 one
19:17:13 <dmwit> lol@OneTuple
19:17:27 <dmwit> liftM9, you mean?
19:17:33 <revenantphx> yes, sorry XD
19:17:36 <ben> Does haskell have a decent java binding that people actually use?
19:17:43 <revenantphx> :t (<$>
19:17:44 <lambdabot> parse error (possibly incorrect indentation)
19:17:46 <dmwit> liftM CTSPickupSpawn (uncurryN get)
19:17:59 <dmwit> sorry
19:18:06 <dmwit> liftM (uncurryN CTSPickupSpawn) get
19:18:22 <revenantphx> so it converts the dataconstructor to work on tuples
19:18:29 <revenantphx> and then the actual tuple size is inferred for get
19:18:36 <dmwit> yes
19:18:39 <revenantphx> (and the data constructor is lifted)
19:18:42 <revenantphx> awesome :D
19:19:01 <dmwit> You would probably do well with something like "constructorN c = liftM (uncurryN c) get".
19:19:02 <revenantphx> what about 0x33 -> liftM7 STCMapChunk get get get get get get getMCData
19:19:09 <dmwit> That one's a bit harder.
19:19:16 <dmwit> I was going to recommend this earlier, actually.
19:19:19 <Eduard_Munteanu> Cale: when are the tesseracts coming up? :P
19:19:25 <revenantphx> dmwit: I can't define it to work for a bunch of numbers though
19:19:29 <revenantphx> without writing a lot of those.
19:19:33 <dmwit> Instead of ByteString, make a newtype like LengthIndexedByteString and define custom get/put methods for it.
19:19:33 <Eduard_Munteanu> But really, congrats, I imagine that's a lot of work.
19:19:38 <dmwit> Then it's just like get.
19:19:43 <Cale> It goes faster than it looks :)
19:19:47 <dmwit> revenantphx: ...yes, you can, by the magic of typeclasses!
19:19:52 <revenantphx> :O
19:19:56 <ndrsndrs> liftM STCMapChunk (uncurryN get) `ap` getMCData
19:19:57 <ndrsndrs> right
19:19:58 <ndrsndrs> ?
19:20:06 <revenantphx> oh, it's actually CALLED uncurryN
19:20:07 <dmwit> ndrsndrs: I don't think so.
19:20:07 <revenantphx> I see.
19:20:11 <ndrsndrs> wait, no
19:20:12 <Cale> Actually, for a lot of these things, the majority of the time is spent making 2-layer hexagons over and over :)
19:20:18 <dmwit> ndrsndrs: I posted the answer above, if you want to cheat.
19:21:13 <Cale> (and I salvage them from most of my constructions, so that I don't have to remake them all)
19:21:44 <dmwit> revenantphx: (I'm not sure whether the latter suggestion about newtype wrapping the ByteStrings is worth it or not, actually. Just a thought.)
19:22:07 <revenantphx> dmwit: If I do that, I lose access to their associated functions.
19:22:14 <revenantphx> And I can't use get/putByteString
19:23:03 <dmwit> Sorry, I meant String everywhere I wrote ByteString, I think.
19:23:24 <Eduard_Munteanu> Cale: ah, I suppose carefully planning ahead helps a lot.
19:23:34 <revenantphx> I thought about it.
19:23:42 <revenantphx> But losing access to the String and List functions is a harsh hit.
19:23:54 <revenantphx> if I could make ALL of the data types use get/put it'd be great, but I cant.
19:24:11 <dmwit> revenantphx: Another possibility that you might consider to be something of a hack:
19:24:25 <Philonous> Cale, What is this magnet game called / where can you get one?
19:24:44 <Cale> Eduard_Munteanu: Well, I usually get in my head which symmetry group I want, and then work out what the vertex figure or face figure for my object will be
19:24:48 <revenantphx> dmwit: hm?
19:24:49 <revenantphx> also
19:24:50 <revenantphx> constructorN :: (Curry (a -> b) c), Binary a) => c -> Get b
19:24:51 <revenantphx> look right?
19:25:00 <Cale> Philonous: zenmagnets.com
19:25:01 <revenantphx> er
19:25:01 <dmwit> data Foo a = Foo a deriving Functor; then you can have Get and Put instances for Foo WrappedString, and use fmap unwrapString :: Foo WrappedString -> Foo String.
19:25:02 <revenantphx> constructorN :: (Curry (a -> b) c, Binary a) => c -> Get b
19:25:02 <revenantphx> 
19:25:12 <Philonous> Cale thanks a bunch
19:25:29 <dmwit> Yeah, that looks pretty good.
19:26:43 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Neodymium_magnet_toys
19:26:44 <Cale> Philonous: There are a bunch of other companies which sell neodymium magnet spheres as well, but this company has been really pleasant doing business with, and their product is supposedly one of the highest quality (and lowest price at the same time). If you submit photos to their gallery, for each 3 that they accept, they'll send you another 216 magnets for free :)
19:26:55 <dmwit> revenantphx: Oh, by the way, you should definitely consider using "fail" instead of "error" inside of the get/put monads.
19:27:03 <revenantphx> Right.
19:27:11 <Cale> They're essentially paying me in magnets to make things with magnets ;)
19:27:44 <Philonous> Cale, Wow, that's really a great deal. That certainly makes a great gift (maybe to myself :D )
19:27:55 <lowasser> Silly question: how do I get a hold of the value NaN?
19:27:59 <lowasser> or the value +infinity?
19:28:00 <Twey> â€¦ why are you being paid in magnets?  :Ã¾
19:28:03 <Eduard_Munteanu> Heh, thinking Christmas already?
19:28:04 <dmwit> revenantphx: Anyway, this looks awesome! Nice work, I look forward to seeing what people do with it. =)
19:28:05 <Twey> lowasser: Divide zero by stuff?
19:28:08 <Twey> > 1/0
19:28:09 <lambdabot>   Infinity
19:28:10 <lowasser> lol
19:28:14 <Twey> > -1/0
19:28:15 <lambdabot>   -Infinity
19:28:16 <lowasser> how do I get NaN then?
19:28:18 <Twey> > -0/0
19:28:19 <lambdabot>   NaN
19:28:21 <lowasser> bingo
19:28:23 <lowasser> thanks
19:28:26 <revenantphx> dmwit: Yeah, if I fix it up a bit I'll publish it.
19:28:38 <revenantphx> It basically takes 99% of the monotonous work out of writing anything that uses this protocol.
19:28:44 <revenantphx> I JUST DID IT FOR THEM.
19:28:49 <Veinor> gasp! haskellwiki is pretty!
19:28:50 <revenantphx> Over the course of 24 hours
19:29:06 <Twey> Pretty, but has a serious hyphen-deficiency
19:29:06 <Veinor> it has a real logo!
19:29:08 <Veinor> and css!
19:29:18 <Veinor> hyphen deficiency?
19:29:37 <revenantphx> dmwit: ack, my constructorN method is failing.
19:29:57 <Twey> â€˜open-source productâ€™, â€˜cutting-edge researchâ€™
19:30:04 <Twey> Missing a couple of commas, too
19:30:06 <dmwit> uh-oh
19:30:47 <revenantphx> btw
19:30:50 <revenantphx> what does this even MEAN
19:30:51 <revenantphx> "class Curry a b | a -> b where"
19:30:55 <revenantphx> I see a pipe.
19:30:59 <Eduard_Munteanu> revenantphx: fundeps
19:31:02 <ivanm> functional dependency
19:31:07 <revenantphx> 0.o
19:31:12 <revenantphx> Sounds fun :D
19:31:16 <dmwit> It means that the type "a" determines the type "b".
19:31:17 <ivanm> revenantphx: type a determines type b
19:31:18 <revenantphx> (ba dum KISH)
19:31:34 <Eduard_Munteanu> It's not standard, but it's an extension.
19:31:41 <Veinor> it means you can't have a Curry Integer Float and a Curry Integer Bool
19:31:43 <revenantphx> so what should the type for constructorN be?
19:31:47 <dmwit> e.g. you can't write both instance Curry [Int] Bool and instance Curry [Int] Int.
19:31:57 <Chaze> you probably all have read this http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html
19:32:04 <dmwit> :t uncurryN
19:32:05 <lambdabot> Not in scope: `uncurryN'
19:32:07 <dmwit> :t uncurry
19:32:08 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:32:27 * Cale hyphenates
19:32:44 <revenantphx> tried this and it failed
19:32:44 <revenantphx>             -- 0x15 -> liftM9 STCPickupSpawn get get get get get get get get get
19:32:44 <revenantphx>             0x15 -> constructorN STCPickupSpawn
19:33:00 <Veinor> Finally, each of us upvoted the post, which was unexpectedly contentious because nobody could agree on what the reddit voting arrows actually mean."
19:33:03 <Veinor> hahahahahaha
19:33:05 <revenantphx> The error was "Non type-variable argument in the constraint: Curry (a -> b) c
19:33:06 <ivanm> Chaze: yeah, didn't think much of it
19:33:12 <revenantphx> Which was what ghci thought was a good constraint.
19:33:19 <revenantphx> constructorN :: (Curry (a -> b) c, Binary a) => c -> Get b
19:33:23 <Chaze> ivanm: oh come on, was a good laugh
19:33:28 <ivanm> I beg to differ
19:33:35 <dmwit> revenantphx: Is there an instance of Binary for 9-tuples?
19:33:39 <revenantphx> says to use FlexibleContexts
19:33:57 <dmwit> Hm, yep, up to 11-tuples, I see.
19:34:11 <dibblego> Chaze, it was a clueless idiot demonstrating that he is still clueless, despite appeals to achieve the contrary
19:34:14 <revenantphx> They go up to 10
19:34:27 <dmwit> err, 10
19:34:40 <dmwit> revenantphx: Give me a sec.
19:34:43 <Eduard_Munteanu> Heh, that blog post.
19:34:50 <revenantphx> it says to use FlexibleContexts
19:34:52 <Chaze> dibblego: does he actually make a point beside the posts title?
19:34:52 <Veinor> i found it humorous
19:35:01 <Veinor> a good community can appreciate people making fun of it
19:35:05 <Eduard_Munteanu> It is... /me is reading it.
19:35:20 <dibblego> Chaze, the only useful information I can glean from that is "Yegge is still utterly clueless and advertising himself to the contrary"
19:35:27 <leakofwiki> @xseen 
19:35:27 <lambdabot> Unknown command, try @list
19:35:39 <leakofwiki> @list
19:35:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:36:17 <ivanm> dibblego: I think he was trying to poke fun of the way most people view Haskell... but meh
19:36:18 <dibblego> Chaze, his nonsense also has a detrimental effect on potential learners
19:36:24 <leakofwiki> @slap ivanm
19:36:24 * lambdabot hits ivanm with a hammer, so they breaks into a thousand pieces
19:36:31 <dibblego> ivanm, that's rather optimistic
19:36:52 <ivanm> leakofwiki: wtf?
19:37:04 <djahandarie> Yeay, haskell.org migration is complete
19:37:13 <ivanm> dibblego: yeah, I generally try to pretend that people act in a good fashion
19:37:20 <revenantphx> dmwit: anything?
19:37:32 <dibblego> ivanm, perhaps I am biased by my interactions with Yegge, whose behaviour I find repulsive
19:37:37 <leakofwiki> @seen sexualchocolate
19:37:37 <lambdabot> Unknown command, try @list
19:37:38 <preflex>  Sorry, I haven't seen sexualchocolate
19:37:53 <ivanm> dibblego: heh
19:38:12 <leakofwiki> @seen Lord Of The Rings
19:38:12 <lambdabot> Unknown command, try @list
19:38:12 <preflex>  Lord was last seen on ##javascript 190 days, 3 hours, 19 minutes and 28 seconds ago, saying: <Typos_King> overflow visible just add an scroll bar and that looks kinda ugly...
19:38:13 <ivanm> leakofwiki: are you actually doing something serious or just playing around with lambdabot?
19:38:42 <dmwit> revenantphx: You're not going to like it... =P
19:38:47 <revenantphx> uh oh.
19:39:17 <dmwit> I can get it to work, but I have to give uncurryN an explicit type signature.
19:39:18 <Twey> Cale: :-D
19:39:34 <dmwit> So you're back to writing constructor1..constructor8 by hand. =/
19:39:34 <revenantphx> dmwit: okay, what is it?
19:39:38 <revenantphx> oh.
19:39:39 <dmwit> e.g.
19:39:40 <revenantphx> Yeah, not thanks.
19:39:45 <Twey> Cale: Much better.  Thanks.  â˜º
19:40:06 <Cale> No problem
19:40:06 <dmwit> revenantphx: Though, it's only the type signature that's annoying. You can still write constructor1 :: blah; constructor1 = contsructorN
19:40:12 <revenantphx> wait a second.
19:40:17 <revenantphx> shit. Why were we using curry?
19:40:21 <revenantphx> uncurry*
19:40:33 <revenantphx> Why not just curry f a1 a2 a3 ... to f (a1, a2, a3 ...)
19:40:40 <revenantphx> and let get infer its tuple type from that.
19:40:58 <dmwit> ...that's what uncurry does.
19:41:04 <revenantphx> no, you have them backwards :P
19:41:09 <dmwit> Do I?
19:41:09 <revenantphx>     curryN f a1 a2 = f (a1,a2)
19:41:10 <revenantphx>     uncurryN f ~(a1,a2) = f a1 a2
19:41:56 <dmwit> You're right, I have got it backwards. =)
19:42:12 <revenantphx> so a valid one would be ...
19:42:13 <revenantphx> constructorN c = liftM (curryN c) get
19:42:16 <dmwit> Wait, no.
19:42:28 <revenantphx> yeah...
19:42:32 <revenantphx> in goes constructor of tupe
19:42:36 <revenantphx> a -> b -> c -> r
19:42:51 <revenantphx> out comes (a, b, c) -> r
19:43:03 <revenantphx> we want to turn multiple parameters into a single tuple.
19:43:10 <revenantphx> so curryN is what I want.
19:43:16 <dmwit> Yeah. f :: a -> b -> c -> r; so it's uncurryN f :: (a, b, c) -> r.
19:43:31 <dmwit> No, look at your definitions above. haha
19:43:39 <revenantphx> ?...
19:43:39 <lambdabot> Not enough arguments to @.
19:43:40 <dmwit> You're the one that has it backwards.
19:43:47 <revenantphx> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/src/Data-Tuple-Curry.html#Curry
19:43:48 <revenantphx> how?
19:44:36 <revenantphx> you use curryN on a function that takes n parameters, and get back a function take an n-tuple!
19:44:44 <dmwit> class Curry a b where uncurryN :: b -> a; instance Curry ((a, b) -> r) (a -> b -> r); therefore uncurryN :: (a -> b -> r) -> ((a,b) -> r)...
19:44:54 <dmwit> No, you don't!
19:44:59 <dmwit> That's what *uncurry* does!
19:45:02 <revenantphx> HOW!?
19:45:16 <revenantphx> I'm looking at the source!
19:45:33 <dmwit> uncurry f = \(a, b) -> f a b
19:45:42 <dmwit> It takes a function of two arguments, and returns a function of one tuple.
19:45:49 <revenantphx> :t (uncurry)
19:45:49 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:45:51 <revenantphx> :t (uncurryN)
19:45:52 <lambdabot> Not in scope: `uncurryN'
19:46:06 <revenantphx> god damn file transfers
19:46:24 <revenantphx> the fuck thinks their so pro spamming DCC (broken) hacks
19:46:35 <revenantphx> :t (Data.Tuple.Curry.uncurryN)
19:46:37 <lambdabot> Couldn't find qualified module.
19:46:47 <revenantphx> here, its uncurryN :: (Curry a b) => b -> a
19:46:48 <dmwit> uncurryN :: Curry a b => b -> a
19:46:54 <dmwit> Yes.
19:47:05 <dmwit> And, e.g., instance Curry ((a, b) -> r) -> (a -> b -> r).
19:47:19 <dmwit> So, e.g., uncurryN :: (a -> b -> r) -> ((a, b) -> r).
19:48:02 <revenantphx> >_<
19:48:06 <revenantphx> I'm confused now.
19:48:08 <dmwit> The real problem here is that the Curry class should have a (b -> a) fundep, as well, but they shot themselves in the foot by including a OneTuple instance.
19:48:18 <revenantphx> this seems pretty obvious.
19:48:19 <revenantphx> curryN f a1 a2 a3 = f (a1,a2,a3)
19:48:19 <revenantphx>     uncurryN f ~(a1,a2,a3) = f a1 a2 a3
19:48:37 <dmwit> Right. So uncurryN takes a function of three arguments and returns a function of one 3-tuple.
19:48:55 <dmwit> ...exactly what we want to do to your constructor, which is a function of three (okay, 9) arguments.
19:49:00 <revenantphx> what? no, thats curryN D:
19:49:06 <dmwit> Nope, look again.
19:49:11 <revenantphx> uncurryN is taking a function and tuple as its params.
19:49:13 <dmwit> uncurryN f = \(a, b, c) -> f a b c
19:49:28 <dmwit> Here, f is a function of three arguments (you can tell by the "f a b c" bit).
19:49:40 <dmwit> And the RHS, e.g. the return value, is a function of a 3-tuple.
19:49:59 <dmwit> So, once again, uncurryN takes a function of three arguments and returns a tuple-based function instead.
19:50:21 <revenantphx> then these type signatures are really confusing ,e.
19:50:22 <revenantphx> me*
19:50:42 <dmwit> The type signature says the same thing!
19:50:54 <revenantphx> how D:
19:51:10 <dmwit> uncurryN :: (a -> b -> c -> r) {- that is, a three-argument function -} -> ((a, b, c) -> r) {- that is, a 3-tuple function -}
19:51:23 <revenantphx> oh, I'm looking at the definition itself.
19:51:39 <revenantphx> Who knwos what that ~ is.
19:51:44 <revenantphx> this is what's confusing me
19:51:45 <revenantphx> curryN f a1 a2 a3 = f (a1,a2,a3)
19:51:45 <dmwit> ~ is a laziness annotation
19:52:14 <razvandimescu> hello, when doing a foldl/foldr can I break the folding if i found the value i was looking for in the list>
19:53:00 <heatsink> razvandimescu: Usually if you are looking for a value in a list, you would use find, not fold
19:53:01 <Eduard_Munteanu> razvandimescu: not really
19:53:06 <dmwit> razvandimescu: No. You must munge the list before folding.
19:53:17 <dmwit> razvandimescu: takeWhile/dropWhile may help
19:53:33 <Eduard_Munteanu> Depending on the actual values involved you might be able to ignore the rest, but generally no.
19:53:45 <dmwit> razvandimescu: You may also like scanl, then use laziness to only compute as far as you're interested.
19:54:12 <dmwit> revenantphx: So, let me rewrite that definition, and see if you agree that it's equivalent.
19:54:27 <dmwit> revenantphx: curryN f = \a1 a2 a3 -> f (a1, a2, a3)
19:54:32 <dmwit> revenantphx: Equivalent, yes?
19:54:49 <revenantphx> aaah
19:54:56 <micahjohnston> I am getting some parsec linking errors
19:55:05 <razvandimescu> ok, thanks
19:55:10 <revenantphx> so is there any way we can simplify all these gets?
19:55:35 <micahjohnston> http://hpaste.org/42014/parsec_linking_errors
19:56:15 <heatsink> micahjohnston: -package parsec
19:56:34 <revenantphx> or --make
19:56:39 <micahjohnston> heatsink: that works, thanks :)
19:57:40 <heatsink> I have this function containing repeated code, but I can't figure out how to factor out the common part
19:57:53 <dmwit> revenantphx: Not really. It comes down to writing uncurry1..uncurry9 = uncurryN, but with explicit type signatures. =/
19:57:53 <heatsink> foo3 f g = foo (\k'' -> Just . foo (\k' -> Just . foo (\k -> f (g k'' k' k))))
19:58:03 <revenantphx> Which I would rather now.
19:58:05 <revenantphx> Not*
19:58:12 <revenantphx> so I'll just leave it as is.
19:59:31 <heatsink> I can't figure out how to de-inline around the lambdas
20:01:47 <unkanon> > 1 >>= (return :: Maybe)
20:01:47 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
20:01:48 <lambdabot>  Expected kind `...
20:01:52 <unkanon> how do I specify which return to use?
20:02:30 <unkanon> > 1 >>= Maybe.return
20:02:31 <lambdabot>   Not in scope: `Maybe.return'
20:02:46 <heatsink> > 1 >>= (return :: (Int -> Int) -> Maybe  (Int -> Int))
20:02:47 <lambdabot>   No instance for (GHC.Num.Num
20:02:48 <lambdabot>                     (Data.Maybe.Maybe (GHC.Typ...
20:03:11 <blackh> > 1 >>= return :: Maybe Int
20:03:12 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
20:03:12 <lambdabot>    arising f...
20:03:27 <unkanon> who wants to try next? ;)
20:03:36 <heatsink> > 1 >>= (return :: Int -> Maybe Int)
20:03:37 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
20:03:37 <lambdabot>    arising f...
20:03:42 <dmwit> > return 1 :: Maybe Int
20:03:42 <lambdabot>   Just 1
20:03:46 <dmwit> newbs =)
20:03:51 <unkanon> no no no
20:03:58 <blackh> > return 1 >>= return :: Maybe Int
20:03:58 <unkanon> that's not what I'm trying to do
20:03:59 <lambdabot>   Just 1
20:04:02 <dmwit> > (return :: Int -> Maybe Int) 1
20:04:03 <lambdabot>   Just 1
20:04:06 <dmwit> ?
20:04:18 <revenantphx> dmwit: now to do something with this :#
20:04:20 <revenantphx> :D*
20:04:24 <heatsink> > return (1 >=)
20:04:25 <dmwit> =)
20:04:25 <lambdabot>   No instance for (GHC.Show.Show (m (t -> GHC.Bool.Bool)))
20:04:25 <lambdabot>    arising from a ...
20:04:31 <unkanon> no, I'm trying to prove that c >>= return == c
20:04:35 <unkanon> prove to myself
20:04:52 <unkanon> I really want to make a bare value 1 go through >>= and return and come out intact on the other side
20:04:54 <dmwit> unkanon: Then c must have a monadic type.
20:04:55 <blackh> unkanon: Then you need to say ...  Just 1 >>= return
20:05:18 <unkanon> > (Just 1) >>= return
20:05:18 <dmwit> > (Just 1 >>= return, Nothing >>= return)
20:05:19 <lambdabot>   Just 1
20:05:19 <lambdabot>   (Just 1,Nothing)
20:05:27 <blackh> unkanon: '1' is of type Int and Int is not an instance of Monad, so you can use it with >>=
20:05:44 <unkanon> hmm gotcha
20:05:48 <dmwit> Or, in the new parlance, c must be a mote. =)
20:06:15 <unkanon> yes I remember that entioned 3 days ago or so :)
20:06:19 <unkanon> now what about this law:
20:06:27 <unkanon> return x >>= f == f x
20:06:45 <unkanon> > return 1 >>= (+1) :: Maybe
20:06:46 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
20:06:46 <lambdabot>  Expected kind `...
20:06:52 <unkanon> should f be monadic?
20:07:04 <unkanon> > return 1 >>= (Just . (+1)) :: Maybe
20:07:05 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
20:07:05 <lambdabot>  Expected kind `...
20:07:19 <unkanon> > return 1 >>= (Just (+1)) :: Maybe
20:07:19 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
20:07:20 <lambdabot>  Expected kind `...
20:07:21 <blackh> unkanon: f has type 'a -> m b'
20:07:34 <unkanon> :t (Just . (+1))
20:07:35 <lambdabot> forall a. (Num a) => a -> Maybe a
20:07:38 <unkanon> there ya go
20:07:43 <unkanon> > return 1 >>= (Just (+1))
20:07:43 <dmwit> revenantphx: If I can find the repository for Data.Tuple, I'll be sending a patch shortly that makes constructorN Just Work.
20:07:44 <lambdabot>   Couldn't match expected type `t -> m b'
20:07:44 <lambdabot>         against inferred type `Data...
20:07:48 <unkanon> ain't working :(
20:07:54 <blackh> Missing dot
20:08:00 <unkanon> > return 1 >>= (Just . (+1))
20:08:01 <lambdabot>   Just 2
20:08:02 <unkanon> oops, yay
20:08:09 <dmwit> revenantphx: (Just adding a "b -> a" fundep seems to give GHC enough information to work out the correct instance here.)
20:08:11 <revenantphx> dmwit: awesome
20:08:12 <unkanon> okay I will save these examples to file :P
20:08:13 <unkanon> thanks
20:08:22 <revenantphx> how do fundeps work?
20:08:49 <dmwit> Perhaps you should have a look at the manual. I'm sure it's got a link to a paper in there or something.
20:09:01 <revenantphx> Got it.
20:09:06 <dmwit> http://haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#functional-dependencies
20:09:16 <revenantphx> I'm very content right now, for my first piece of actual haskell code, it's not bad.
20:09:30 <revenantphx> I mean, first piece written with zero instruction or anything.
20:09:39 <revenantphx> (zero tutorial I guess would be more correct)
20:10:15 <dmwit> preflex: seen lennart
20:10:15 <preflex>  Sorry, I haven't seen lennart
20:10:24 <revenantphx> preflex seen dmwit
20:10:25 <preflex>  dmwit was last seen on #haskell 10 seconds ago, saying: preflex: seen lennart
20:10:35 <copumpkin> preflex: seen augustss
20:10:36 <preflex>  augustss was last seen on #haskell 31 days, 11 hours, 17 minutes and 40 seconds ago, saying: ddarius: and by induction, all finite numbers are nothing?
20:11:39 <dmwit> excellent
20:11:42 <revenantphx> I think i'm going to faint.
20:11:43 <revenantphx> I should sleep.
20:11:45 <revenantphx> good night
20:12:47 <heatsink> What do you call a function that you write by starting from a type signature and then flailing at the keyboard until the code typechecks?
20:12:49 <dmwit> ?tell augustss In Data.Tuple.Curry, adding a fundep b -> a would really make using uncurryN much more pleasant. I'd send a patch, but I can't find a repository anywhere. =)
20:12:49 <lambdabot> Consider it noted.
20:13:40 <dmwit> ?djinn (a -> b) -> a -> a -> b
20:13:41 <lambdabot> f a b _ = a b
20:13:46 <dmwit> heatsink: djinnish ;-)
20:14:13 <dmwit> ?djinn (a -> a -> b) -> a -> b
20:14:13 <lambdabot> f a b = a b b
20:14:13 <heatsink> Hm, I like that.
20:14:14 <Eduard_Munteanu> undefined
20:14:26 <Eduard_Munteanu> That would type check
20:14:54 <Eduard_Munteanu> Haskell never says no to a bottom.
20:15:25 <dmwit> Suppose you have two sets of strings A and B. Is there an algorithm for finding a minimal regex/DFA that matches everything in A but nothing in B?
20:15:37 <dmwit> (Go ahead and assume A and B are disjoint, of course.)
20:15:54 <FunctorSalad> are regular langs even closed under complement?
20:16:01 <dmwit> Sure they are.
20:16:13 <FunctorSalad> oh right, invert set of goal states
20:16:19 <dmwit> I'm not sure that matters, though.
20:16:29 <FunctorSalad> well it matters for my plan ;)
20:16:33 <dmwit> A is a finite language; almost every interesting class includes those. =)
20:16:51 <dmwit> Oh, what's your plan?
20:16:57 <FunctorSalad> just apply the usual minimal dfa procedure to the A and not(B) language?
20:17:10 <dmwit> A is a language, and not(B) is a language.
20:17:18 <dmwit> But there's lots of other languages that meet the criteria, too.
20:17:42 <FunctorSalad> the 'and' was supposed to be the intersection operator, sorry ;)
20:17:52 <dmwit> A intersect not(B) is just A.
20:17:56 <dmwit> Since A and B are disjoint.
20:18:21 <FunctorSalad> hmm, but isn't B irrelevant in your original statement then too?
20:18:22 <dmwit> It's harder than the usual problem, because you have to choose both a language and a DFA for that language.
20:18:48 <dmwit> It's not clear that the minimal DFA for A will be smaller than the minimal DFA for some other language that includes A (but doesn't intersect B at all).
20:19:06 <FunctorSalad> ah, get it now
20:19:07 <dmwit> For example, if B is the empty set, the regex .* is much better than any regex that matches exactly A.
20:19:17 <FunctorSalad> it has to match everything in A, but possibly more
20:19:21 <dmwit> yes
20:19:42 <Eduard_Munteanu> Is '.' standard notation in DFAs?
20:19:45 <Eduard_Munteanu> I thought not.
20:19:49 <FunctorSalad> ok, I agree that doesn't make it a simple apply-minimization-procedure problem
20:19:53 <FunctorSalad> (at least not obviously)
20:20:06 <dmwit> Eduard_Munteanu: Perhaps not.
20:20:57 <Eduard_Munteanu> Ah, nevermind, sigma* is just as short.
20:23:44 <dmwit> On a more Haskell related note, I'm now curious: what is the type families version of "class Curry a b | a -> b, b -> a"?
20:23:59 <FunctorSalad> dmwit: counterexample for not(B) being optimal?
20:24:14 <dmwit> Let A be the empty set this time.
20:24:17 <FunctorSalad> sorry I'm lazy, not saying I think it's very likely it is ;)
20:24:30 <FunctorSalad> ok
20:24:39 <blackh> dmwit: I don't think you can express | a -> b, b -> a as a type family.
20:24:44 <blackh> But don't quote me.
20:24:46 <dmwit> ah
20:25:14 <FunctorSalad> I think you get that with a *data* family
20:25:25 <FunctorSalad> but that wouldn't accomplish the goal judging from the name ;)
20:25:25 <Eduard_Munteanu> "For security reasons, by default, the only RTS flag that programs accept is +RTS --info." in GHC 7. I suspect that's mainly aimed at set{u,g}id binaries, right?
20:25:42 <blackh> Even with a data family, you can't get the two way injective thing.
20:25:52 <Alan> Hmmm, this didn't get answered earlier
20:25:56 <Alan> maybe i can try again...
20:26:52 <Alan> Is there any way to group the constructors from several types into one type, and/or group the patterns of several functions into one?
20:26:55 <FunctorSalad> blackh: not? class Curry a where data C a :: * would give a -> C a (since it's a function) and C a -> a (since it's a fresh type each time)
20:27:52 <Eduard_Munteanu> Alan: you mean pattern matching? You can use guards or case of.
20:28:06 <dmwit> Alan: Can you give a little (code) context?
20:28:08 <dmwit> ?hpaste
20:28:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:28:28 <blackh> FunctorSalad: I do believe you're right.
20:28:31 <Eduard_Munteanu> @where hpaste
20:28:31 <lambdabot> http://hpaste.org/
20:29:05 <blackh> Alan: Or explain a little more what you want to achieve.
20:29:16 <FunctorSalad> tried 'class Curry a | C a -> a where
20:29:17 <FunctorSalad>     type C a :: *' but that's a syntax error
20:29:24 <Alan> dmwit: not sure I have an easy code example, but basically, I have an emulator for some instruction set, and then i have permutations of that emulator which support additional instructions
20:29:55 <Alan> my emulator is basically a function of Instruction -> State -> State
20:30:14 <blackh> Alan: You have to make a new type that contains a value of the original type. You can't "extend" a type by adding more constructors to it.
20:30:54 <Alan> so problem 1 is my Instruction type: it need to contain all instructions, or be different for each emulator?
20:31:02 <dmwit> FunctorSalad: Cool, thanks.
20:31:23 <Alan> and problem 2 is combining 2 functions so it could execute anything that matches from either 1 or 2
20:31:24 <dmwit> Alan: You could consider a few things.
20:31:59 <Alan> I'm looking at a really obvious "refactor me" thing here, since i have 4 emulators that look almost the same.... :(
20:32:00 <dmwit> One is enriching the type of your emulator to something like emulator :: Emulatable a => a -> State -> State
20:32:46 <dmwit> You could then make instances for a bunch of different instruction types, and one like (Emulatable a, Emulatable b) => Emulatable (Either a b).
20:32:56 <FunctorSalad> blackh: tried it... "foo :: C a ~ C b => a -> b; foo x = x" does indeed typecheck for data family C a
20:33:01 <dmwit> Another possibility is enriching your Instruction type to take a parameter.
20:33:10 <dmwit> e.g. data Instruction a = Inc Register | Other a
20:33:38 <blackh> FunctorSalad: Great - I think you just filled a small gap in my understanding.
20:33:40 <Zeiris> Has anything interesting happened with FRP in the last few months? A stable, usable library perhaps?
20:33:48 <dmwit> Your emulation functions might then look like emulateA :: Instruction Void -> State -> State; emulateB :: Instruction Multiply -> State -> State, etc.
20:33:57 <dmwit> later implementations can call earlier ones.
20:34:42 <copumpkin> Alan: which instruction set?
20:35:11 <copumpkin> Zeiris: hah!
20:35:19 <Zeiris> :(
20:35:43 <Alan> copumpkin: a theoretical one
20:35:45 * applicative passes his copy of FRP Weekly News to Zeiris, apologizing for the coffee stains...
20:35:49 <copumpkin> Alan: ah okay
20:35:58 * hackagebot cuda 0.3.2 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.3.2 (TrevorMcDonell)
20:36:17 <Alan> :o
20:36:20 <Alan> haskell + CUDA?
20:36:40 <blackh> Alan: If you're interested in that, take a look at accelerate.  It's rather nice.
20:36:51 <Alan> that sounds unbelievably "screw you" to all the "OMG YOU MUST C TO HAVE FAST CODES"
20:37:09 <blackh> Exactly!
20:37:18 <Eduard_Munteanu> @faq CUDA HASKELL HAVE FAST CODES?!?!
20:37:18 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:25 <Alan> haha
20:37:48 <Alan> dmwit: not sure i grasp what is going on there
20:38:03 <Eduard_Munteanu> Well I'm myself struggling with a major performance issue here.
20:38:21 <dmwit> Alan: You may also like http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.4131&rep=rep1&type=pdf
20:38:43 <applicative> Eduard_Munteanu, its all your fault for not using the CUDA bindings.
20:39:00 <Alan> dmwit: do you mean that each more specific instruction set has a constructor that allows instructions from the "parent" instruction set?
20:39:41 <jmcarthur> Zeiris: not that i'm aware of
20:39:44 <dmwit> Alan: I suppose that's possible, though I was assuming the less specific instruction sets would have constructors for instructions from the extension!
20:39:52 <jmcarthur> Zeiris: it's been quiet lately
20:39:52 <djahandarie> Eduard_Munteanu, got a paste somewhere?
20:40:40 <Alan> dmwit: that requires the less specific to "know about" the existence of more specific, wouldn't it?
20:41:02 <Eduard_Munteanu> djahandarie: http://paste.pocoo.org/show/298587/
20:41:05 <blackh> Alan: The way you describe would be a perfectly good way of doing it.  Then make all your data types instances of 'Emulatable'.
20:41:07 <ben> I am being dumb and trying to use the FFI with java's JNI. Trying to load a .so created by ghc -shared -dynamic -fPIC from java, I get "/usr/lib64/ghc-7.0.1/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc7.0.1.so: undefined symbol: stg_newByteArrayz". Any suggestons what I am doing wrong?
20:41:07 <Zeiris> Shame. I want to play with GUI/data visualization via a Haskell DSL, and FRP looked like it had some kernel of use for that. Guess I'll try and hack together something of my own.
20:41:19 <dmwit> Alan: e.g. data RISC a = Inc Register | Dec Register | Jump Offset | CISC a
20:41:42 <dmwit> Alan: Instantiating with different types for 'a' would give different extensions.
20:41:53 <djahandarie> Eduard_Munteanu, what does the GHC profiler say?
20:42:08 <Eduard_Munteanu> djahandarie: it takes about 2.4s on a 1.5MiB file. In comparison it takes 1.5s on Wine, and 0.3s in C code.
20:42:28 <Eduard_Munteanu> djahandarie: it blaims lookupCode and pack
20:42:36 <Alan> dmwit: interesting
20:42:41 <Alan> blackh: true
20:42:51 <djahandarie> Eduard_Munteanu, do you have a paste of it?
20:42:52 <Alan> OH GOD CITESEERX WHAT IS WRONG WITH YOU?
20:43:01 <Alan> the ONLY thing in the filename you download is the DOI
20:43:10 <Alan> guess what the one field you CAN'T search on is?
20:43:13 <Eduard_Munteanu> djahandarie: http://paste.pocoo.org/show/298590/
20:43:36 * Eduard_Munteanu hopes that's related to the same code
20:44:03 <djahandarie> Eduard_Munteanu, what about GC stats and such?
20:44:24 <Eduard_Munteanu> djahandarie: lemme re-run it.
20:44:40 <djahandarie> The stuff that normally comes when you do +RTS -sstderr
20:45:08 <Alan> dmwit: could you give me a non-download link to that paper?
20:45:31 <Alan> actually, hang on
20:45:36 <Alan> I can probably just mess with URLs
20:45:40 <dmwit> http://scholar.google.com/scholar?q=data+types+la+carte
20:46:31 <Eduard_Munteanu> djahandarie: http://paste.pocoo.org/show/298830/
20:46:32 <dmwit> http://scholar.google.com/scholar?q=data+types+la+carte+swierstra is probably better
20:46:45 <Eduard_Munteanu> djahandarie: yes +RTS -s
20:47:07 <stubert> hi Eduard_Munteanu, did you get your cod running fast?
20:47:20 <stubert> woops
20:47:32 <Eduard_Munteanu> djahandarie: the trouble is lookupCode is pretty simple on its own, and I couldn't replace 'pack' with anything else (BitPut/BitBuilder) without _degrading_ performance further.
20:47:46 <Eduard_Munteanu> oO
20:47:57 <Alan> dmwit: thanks :)
20:48:58 <blackh> Alan: If you have typeclass with functions giving smart constructors for each subset of your instructions...
20:50:40 <blackh> Alan: You can choose the machine you're using with the context, e.g.  someAssemblyCode :: (Arm7 i, Arm9 i) => i
20:50:54 <blackh> Just some ideas.
20:51:02 <djahandarie> Eduard_Munteanu, hmmm. Have you tried messing with strictness?
20:51:15 <djahandarie> Eduard_Munteanu, like on lookupCode
20:51:51 <Eduard_Munteanu> djahandarie: yeah, a bit, I annotated the tree nodes with !, sprinkled a few $! here and there, but not much happened even with -funbox-strict-fields
20:52:53 <Eduard_Munteanu> Of course, I tried both -O and -O2
20:53:37 <Alan> blackh: thanks :)
20:55:10 <djahandarie> eight = take 8 (xs ++ repeat False) could be marginally faster Eduard_Munteanu 
20:55:23 <djahandarie> Not the bottleneck obviously though
20:55:42 <Eduard_Munteanu> djahandarie: yes, I know, somebody else suggested that, but this is an older paste I had in a tab.
20:55:53 <djahandarie> lol damn, beat to it
20:55:54 <Eduard_Munteanu> djahandarie: it's only marginally faster.
20:56:56 <Eduard_Munteanu> not more than 50-100ms
20:57:12 <djahandarie> Could you give me some examples if input/output of pack?
20:59:07 <djahandarie> What I'm really interested in is how much time that would take if it was just   pack = pack rest where ...
20:59:18 <Eduard_Munteanu> djahandarie: it takes in a list of bools that represents the output and packs them into Word8s. [True, False] -> 128:[]   [True, False, False, False,  False False False False,  True] -> 128:128:[]
20:59:29 <Eduard_Munteanu> well, in a ByteString.
20:59:31 <djahandarie> Oh
20:59:34 <djahandarie> I see
20:59:42 <djahandarie> Was misreading it slightly
21:00:20 <Eduard_Munteanu> djahandarie: it's doing Shannon-Fano compression, and I'm looking up codes for symbols in that tree. Which yields a varying number of bits which need to be packed into bytes.
21:01:11 <Eduard_Munteanu> I know I could remove that tree completely, but I don't really want to. This is assignment I already did in C and I wanted to do this Haskell implementation in a similar manner.
21:01:16 <Eduard_Munteanu> *an assignment
21:02:43 <djahandarie> Drop some {-# SCC "blah" #-} pragmas in pack
21:03:06 <Eduard_Munteanu> Oh, okay, lemme see...
21:04:38 <applicative> Alan, did you find the paper? http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
21:05:30 <djahandarie> Eduard_Munteanu, beyond doing small optimizations like this, or entirely changing your data representation, I'd say the only easy thing you could do is memoize lookupCode, but I don't know if that is beneficial for your problem or not (or possible)
21:06:38 <djahandarie> It'd pretty much be changing the data structure anyways if you did that
21:09:31 <Eduard_Munteanu> djahandarie: http://paste.pocoo.org/show/298836/
21:09:52 <djahandarie> Heh
21:11:27 <djahandarie> Eduard_Munteanu, pad and eight' shouldn't be there at all if you use the code I suggested
21:12:21 <Eduard_Munteanu> djahandarie: looks to me like ByteString is just slow, since eight' takes a lot of that time
21:12:46 <Eduard_Munteanu> um no
21:12:52 <djahandarie> Huh?
21:12:58 <djahandarie> eight' is just a list operation
21:14:37 <Eduard_Munteanu> djahandarie: anyway pack on the whole is 8% time and lookupCode takes 34.5%
21:14:43 <Eduard_Munteanu> But I'm not sure why it's so slow.
21:15:13 <djahandarie> pack is 35.5% cumulative
21:15:32 <djahandarie> The 8.1% would be for the B.cons
21:15:43 <Eduard_Munteanu> Oh.
21:16:39 <Eduard_Munteanu> I'd do the same thing to doCompress, add SCCs
21:17:01 <Eduard_Munteanu> erm compress
21:19:25 <djahandarie> Why compress? Doesn't seem to take up much time
21:20:43 <djahandarie> I still think eight = take 8 (xs ++ repeat False) will be faster than whatever is there currently
21:22:04 <Eduard_Munteanu> djahandarie: hm, rather 'take 8 (take 8 xs ++ repeat False)'
21:22:16 <djahandarie> Oh yeah, you're right
21:22:42 <djahandarie> Not sure of it being faster anymore lol
21:22:51 <djahandarie> Wait
21:23:15 <Eduard_Munteanu> Yes...?
21:23:31 <djahandarie> Mine should work fine
21:23:41 <djahandarie> It would only matter when xs is smaller than 8 anyways
21:24:20 <Eduard_Munteanu> djahandarie: xs is the whole output stream, if I make it infinite, so is the output file :)
21:24:29 <djahandarie> You don't change xs.
21:24:41 <djahandarie> This is only used in eight, which gets fed to pack'
21:24:53 <djahandarie> pack rest is still based on the original non-infinite xs
21:25:05 <Eduard_Munteanu> Oh, right.
21:25:10 <Boxo> > let head' = foldr const undefined in head "abc"
21:25:11 <lambdabot>   'a'
21:25:17 <Boxo> How can that work?
21:25:53 <djahandarie> Boxo, head' is never called
21:26:00 <Boxo> > let head' = foldr const undefined in head' "abc"
21:26:01 <lambdabot>   'a'
21:26:06 <Boxo> !
21:26:20 <djahandarie> const is lazy in its first parameter, doesn't matter that it is undefined
21:26:26 <djahandarie> Err
21:26:41 <djahandarie> Second parameter, and it's a foldr
21:27:08 <djahandarie> Man I should probably go to bed, slowing down here lol
21:27:10 <Boxo> const :: a -> b -> b, a is Char, b is [Char], that thing returns the result of a const ...
21:27:11 <Eduard_Munteanu> djahandarie: not much changed, pack takes 35.3% of cumulative running time
21:27:34 <Boxo> How can the types do that!?
21:28:30 <djahandarie> b is also Char.
21:29:16 <djahandarie> > let head' = foldr const undefined in head' [x,y,z]
21:29:17 <lambdabot>   x
21:29:37 <djahandarie> > let head' = foldr (+) a in head' [x,y,z]
21:29:38 <lambdabot>   x + (y + (z + a))
21:29:52 <djahandarie> Replace + with const, and it should be clear why it works
21:30:18 <Boxo> Ah yeah I said something wrong up there. I see why it would work in untyped lambda calculus anyway...
21:30:44 <Boxo> @type foldr
21:30:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:30:50 <Boxo> @type const
21:30:51 <lambdabot> forall a b. a -> b -> a
21:31:08 <Boxo> so should be const :: a -> a -> a for some a
21:31:14 <djahandarie> Yes
21:31:36 <djahandarie> foldr const undefined "abc" => const 'a' (const 'b' (const 'c' undefined))
21:32:04 <djahandarie> > let head' = foldr const undefined in head ['a', undefined, undefined, undefined, undefined]
21:32:05 <lambdabot>   'a'
21:32:12 <djahandarie> Which is why that works too
21:34:23 <Eduard_Munteanu> djahandarie: anyway, thanks, I have to go now. I'll try to narrow it down later.
21:34:34 <djahandarie> Yep, good luck
21:34:38 <djahandarie> I'm sure it's possible ;)
21:34:54 <Boxo> My mind is being blown here. I guess it doest legitimately work...
21:36:51 <Boxo> s/doest/does
21:44:10 <Zeiris> I really like the wiki's new look. Sexy.
21:44:52 <Zeiris> I don't like the fact that the semi-broken "erlang" package is up on hackage, but the very functional Haskell BERT bindings aren't.
21:45:26 <Zeiris> (Admittedly, people on the Erlang side of things are more likely to bump into github... But I went to Hackage first, and thus missed the BERT thing.)
21:47:03 <augur> anyone know if parsec uses difference lists at all?
21:50:11 <ddarius> It doesn't.
21:50:49 <augur> *nod*
21:50:52 <augur> hrmph
21:50:53 <dolio> It's safe to say that anything written in Haskell doesn't use difference lists.
21:51:01 <augur> dolio: yeah probably
21:51:19 * ddarius wins people to his cause.
21:51:33 <augur> ddarius: what
21:51:45 <shachaf> dolio: Why?
21:52:34 <monochrom> I forgot. What is difference list?
21:52:49 <shachaf> dolio: I know of at least one parser that does.
21:52:57 <dolio> Because difference lists are a logic language phenomenon, or at least a single-assignment/unification phenomenon.
21:53:20 <dolio> The things that people call difference lists in Haskell aren't difference lists.
21:55:42 <shachaf> dolio: Well, I remember the person who wrote this parser kept talking about how Data.DList etc. didn't use proper difference lists, and how he would prefer to write it in Prolog.
21:56:31 <ddarius> Data.DList has an interface that would be rather unsuitable for a parser.
21:56:46 <ddarius> Data.DList is more about generating strings, not analyzing them.
21:58:50 <dolio> The idea that DList puts to use (I believe) is that for a monoid (M, e, *), you can instead work with the monoid of endofunctions (M -> M, id, .).
21:59:09 <dolio> And the latter happens to be more efficient for operations that people want.
22:00:06 <dolio> But I don't think that has much to do with difference lists in logic languages (where the term came from), so DList is rather misnamed.
22:00:08 <Cale> Or at least for concatenation, since (.) is O(1), while (++) is O(n)
22:00:29 <Cale> (and yeah, that's what DList is all about :)
22:01:20 <ddarius> :t Endo . mappend
22:01:20 <lambdabot> forall a. (Monoid a) => a -> Endo a
22:02:03 <ddarius> While the motivation is arguably different, the differences in API seems the much more compelling argument to me.
22:02:39 <Cale> I usually just use functions directly, rather than DList
22:05:44 <monochrom> oh, yeah, Wadler's list
22:08:24 <ddarius> It was probably Bird's list before Wadler's, but attributing things to Bird is a safe bet.   (Certainly the earliest reference to the representation that I've seen is by Bird.)
22:15:49 <ddarius> "You can only live once, but if you do it right, once is enough."
22:16:08 <monochrom> oops, Bird's list
22:16:48 <monochrom> you can only RTS_init once.
22:25:49 <kadoban> hmm.  is there some function to get the log of very large integers? (too big for Doubles?)
22:29:57 <Cale> kadoban: Not in the standard library, but you can do a doubling/bisective search...
22:30:26 <kadoban> Cale: hmm, okay, thanks
22:30:41 <c_wraith> yeah, the straight-forward search is O(number of bits)
22:32:37 <Cale> heh, or if you want to be extra cheesy, you can use show and length ;)
22:33:14 <c_wraith> didn't we recently decide show is O(n^2), where n is the number of bits?
22:33:32 <c_wraith> On the other hand, it's cheap to code :)
22:33:41 <kadoban> show does seem to slow down faster than i thought it would...doing this goofy project euler thing, so the numbers get big really quick...
22:34:09 <shachaf> Log in what base?
22:34:24 <ion> How do you define very large integers?
22:34:25 <kadoban> 10, although it doesn't really matter.  what i really need is the first 10 digits
22:34:26 <c_wraith> does that matter?  the algorithm's the same :)
22:34:29 <ion> > log 1e100
22:34:30 <lambdabot>   230.25850929940458
22:34:37 <ion> Large enough?
22:34:53 <kadoban> no :(  it blows up at 1e309 or so
22:35:25 <c_wraith> you might be able to re-cast your algorithm to calculate only the first X bits of the answer
22:35:27 <ion> Ok, thatâ€™s large indeed. :-)
22:36:01 <kadoban> c_wraith: it's fibonacci numbers...i was trying to think of a way to do that, but...i dunno.  maybe i'm missing it.  if this doesn't work, i'll probably have to find one
22:36:29 <augur> applicative reader!
22:41:35 <c_wraith> hmmm.
22:55:17 <profmakx> oje
22:55:20 <profmakx> wikileaks bei ovh
22:57:21 <endojelly> profmakx, hm?
23:00:19 <pkrumins> how do I find the signature of `main`?
23:01:26 <pkrumins> i guess it's IO a
23:01:40 <pkrumins> or is it IO ()
23:02:19 <pkrumins> i am thinking about C's main, it has return type int, because it returns the exit code to the calling process.
23:02:27 <shachaf> pkrumins: It's IO () usually.
23:02:29 <pkrumins> so therefore i am thinking it might as well be IO a.
23:02:39 <ddarius> The most general type of main is IO a.
23:02:53 <shachaf> pkrumins: If it's (Show a) => IO a, it looks like it'll print whatever value it returns.
23:03:04 <pkrumins> aha i see
23:03:12 <ddarius> No.
23:03:22 <pkrumins> :/
23:03:51 <shachaf> ddarius: Is that a GHC-specific behavior?
23:04:09 <ddarius> No, it's not even the behavior of GHC.
23:04:33 <shachaf> ddarius: Really? What is it the behavior of?
23:04:56 <ddarius> If you execute an IO action in GHCi, it will display the result.  Whether it is main or not is irrelevant.
23:05:00 <augur> seriously guise
23:05:02 <augur> applicative reader
23:05:04 <augur> its awesome
23:05:10 <pkrumins> augur: teach it to me
23:05:25 <pkrumins> augur: i dont know anything about it yet.
23:05:28 <augur> im not confident enough to teach it in haskell
23:05:30 <pkrumins> i have only heard its name
23:05:30 <shachaf> ddarius: Oh. And running a program is equivalent to executing main in ghci?
23:05:31 <ddarius> The type of main, i.e. IO a, means that the only thing that can be done with the result, modulo RTS magic, is to discard it.
23:05:39 <pkrumins> augur: well you could try to explain what it's all about
23:05:39 <ddarius> shachaf: No.
23:06:10 <pkrumins> augur: want to try? :)
23:06:53 <augur> pkrumins: the reader monad in applicative form, so you can write   `pure f <*> pure x <*> pure y`  and have it automatically lift f as you go along
23:07:36 <shachaf> ddarius: If I runghc "main :: IO Int; main = return 5", it prints "5". What am I missing?
23:07:37 <pkrumins> augur: oh is that it?
23:07:48 <pkrumins> augur: umm, what is reader monad? :)
23:07:59 <pkrumins> shachaf: interesting!
23:08:42 <ddarius> shachaf: If you compile, it will print nothing.
23:09:00 <jmcarthur> that is interesting that runghc does that though (to me)
23:09:09 <shachaf> ddarius: Ah. So it's a ghci thing.
23:09:29 <dskippy> I am having trouble getting events to trigger when using Glade and GTK2. I have setup menu items for my program and given the menu items names. Then I call onActivateItem and add a handler. I have not selected a handler in glade using the menu. Am I doing this correctly?
23:10:37 <augur> pkrumins: the reader monad lets you turn normal values into values that can depend on a variable assignment function, implicitly rather than explicitly, so that you can write, say,    lift2 f a b   instead of   \e -> f (a e) (b e)
23:10:42 <ddarius> jmcarthur: I agree.  I think it is an unintentional artifact.
23:10:43 <Cale> dskippy: That sounds right...
23:11:04 <dskippy> It compiles but the menu items just do nothing.
23:11:59 <shachaf> pkrumins: The equivalent of C's main return value is exitWith :: ExitCode -> IO (), by the way.
23:12:05 <augur> as it happens, for Reader, pure = return and (<*>) = flip (>>=)
23:12:35 <shachaf> (Well, I guess it's the equivalent of exit().)
23:12:37 <augur> i wonder if there are any other applicative monads like that
23:13:06 <pkrumins> augur: trying to understand that
23:13:11 <pkrumins> shachaf: oic!
23:13:21 <ddarius> augur: Identity
23:13:26 <augur> ddarius: :o
23:13:35 <pkrumins> i guess i have to read the RWH chapter on RM
23:13:37 <augur> so theres some magic connection between reader and id
23:14:36 <ddarius> Incidentally, pure f <*> pure x <*> pure y is kind of pointless.  It's the same as pure (f x y), which is to say it doesn't really use the applicative functor at all.
23:26:27 <augur> ddarius: true, but it matters when you use something other than pure :)
23:26:45 <augur> pure f <*> pure x <*> lookup v
23:27:26 <augur> incidently, is it just me, or is Reader e a just a fancy way of saying (->) e a
23:31:17 <jmcarthur> that's exactly what Reader is
23:32:42 <augur> i like that. reader is essentially just the auto-forking monad, basically
23:45:04 <paolino> hi, I'm trying to write a function , but I'm not sure it's possible
23:45:07 <paolino> http://hpaste.org/42015/scanf_like_function
23:47:13 <paolino> it is even wrong without the recursive case
23:47:19 <ddarius> :t partition
23:47:20 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:50:24 <paolino> the idea is given a list of boxes of typeables and a function of a number of arguments matching in length and types the given list,  evaluate the function feeding the right args
23:52:09 <paolino> the fact that I'm not able to write the right signature is not a good starting point :-/
23:52:51 <kadoban> is there some reason that my code would lazily produce its output in ghci, but not when run as a separate program? (it produces a list of values)
23:53:06 <paolino> kadoban hFlush ?
23:53:41 <kadoban> paolino: hmm...
23:54:13 <paolino> maybe haskeline (ghci) behaves different on flushing stdout
23:54:43 <kadoban> it seems weird...if i remove a filter, it produces lazily, otherwise it doesn't (when compiled/run)
23:54:56 <paolino> try mapM_ print xs instead of print xs
23:55:21 <EvanCarroll> @src foldr
23:55:21 <lambdabot> foldr f z []     = z
23:55:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:55:39 <EvanCarroll> How come that is so clean, and this so ugly: http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/src/GHC-Base.html#foldr
23:56:36 <kadoban> paolino: that worked, thanks.  not sure i understand why, but well i guess i won't worry about it
23:56:50 <EvanCarroll> @src foldl
23:56:50 <lambdabot> foldl f z []     = z
23:56:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:57:17 <paolino> kadoban: hSetBuffering stdio should fix
23:57:32 <paolino> see the System.IO docs
23:57:46 <kadoban> cool, i'll take a look
23:58:51 <paolino> anyone has a hint on my problem, please ?
23:59:04 <jmcarthur> paolino: "data TB = forall a . Typeable a => TB a"   that looks a lot like Dynamic to me
23:59:20 <jmcarthur> paolino: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Dynamic.html
23:59:59 <paolino> jmcarthur: I guess so
