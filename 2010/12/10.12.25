00:00:01 <edwardk> here's hoping ;)
00:00:19 <edwardk> ported attoparsec, thinking about porting parsec
00:00:48 <edwardk> i started a uu-parsinglib port, but that is REALLY dependent upon ubiquitous laziness =/
00:02:52 <ddarius> edwardk: What's wrong with the parsing combinator libraries Scala already has?
00:03:40 <edwardk> the main one backtracks by default, the backup fix for that is a packrat parsing library that can't be gracefully extended, and which has a bug when using left-recursion that was found recently
00:04:03 <edwardk> personally i'd rather not build a house on such a shaky foundation
00:05:25 <edwardk> i build some layout combinators that still provide the nice linear packrat asymptotics as long as layout only depends on a visibly pushdown language erasure of the overall language
00:05:40 <edwardk> so that much was nice, but i really hated that i had to copy and paste the packrat codebase they have to make it work
00:06:04 <edwardk> plus i can't thread any sort of monadic side effects into their parsers (not the attoparsec ones to be honest)
00:06:05 * ddarius thinks Google Scholar might have partially banned my IP.
00:06:13 <edwardk> understandable ;)
00:06:37 <edwardk> your daily habits might be construed as a denial of service attack =P
00:07:37 <adu> edwardk: o that's brilliant
00:07:50 <ddarius> I've been downloading a bunch of DBMS papers lately, but not using Google Scholar.  However, I installed Mendeley Desktop again and it has a find information by title via Google Scholar and that's probably actually in violation of the terms of service.
00:08:02 <edwardk> adu: the ddos comment or the packrat layout stuff?
00:08:11 <ddarius> I got a captcha when I went to Google Scholar myself.
00:08:17 <edwardk> ah
00:08:47 <edwardk> https://github.com/ekmett/layout/tree/master/src/main/scala/scala/util/parsing is the layout code
00:08:57 <ddarius> It seems to work from a browser, but Mendeley Desktop doesn't work, but then it could just be a piece of crap.
00:09:04 <edwardk> never tried it
00:09:41 <ddarius> edwardk: It's mostly a piece of crap.  You aren't missing much.  There's a reason I didn't immediately install it when I got a new laptop.
00:09:44 <edwardk> that code is still subject to the bug found in http://tratt.net/laurie/research/publications/papers/tratt__direct_left_recursive_parsing_expression_grammars.pdf but i don't use left recursion in my grammars out of habit anyways
00:09:49 <edwardk> fair nuff
00:10:18 <edwardk> chris apparently ran out and picked up a clone of my laptop about 12 hours ago
00:11:18 <ddarius> edwardk: I thought you would've gotten a different laptop had you waited a week (?)
00:11:24 <edwardk>  yeah
00:11:51 <edwardk> i was thinking about trading him mine and paying for the new macbook air, but meh
00:13:10 <edwardk> found a lib i rather like in scala, called akka
00:13:27 <edwardk> erlang style distributed share-nothing threading
00:14:05 <ddarius> My understanding is that there's quite a bit of that in the Scala libraries.
00:16:07 <edwardk> i had spent all of my time focused on parsing, language ast's, category theory and containers and hadn't really looked at it before today
00:19:16 <ousado_> edwardk: have you seen all of akkas dependencies?
00:19:34 <edwardk> ousado_: exploring them now, somewhat .. terrifying ;)
00:19:42 <ddarius> Hmm.  Mendeley Desktop has a --quit commandline flag with the description: "Quit immediately after loading the main window."
00:19:47 <ddarius> What the heck would you use that for?
00:20:44 <edwardk> ousado: i have a nice little datalog/dedaelus/overlog EDSL that i was looking at making distributed.
00:20:51 <edwardk> er ddarius
00:21:48 <edwardk> fire it up on a few dozen nodes, and run mixed deductive/inductive code in a distributed fashion using all my crazy sorted linear bloom filters to try to cut down traffix
00:21:51 <edwardk> er traffic
00:22:53 <edwardk> plus i was curious to see if it'd be worth trying to structure a code base that way for more mundane tasks, like writing a compiler, etc.
00:23:21 <edwardk> though i strongly suspect the answer in the latter case is a fairly strong no, unless you're google
00:23:40 <ousado_> edwardk: worth trying as in feasible?
00:24:34 <edwardk> worth trying as in i have a toy code base i'm putting together, i need to deal with logging, messaging, multiple processes, workers, and getting it all right anyways, so i might as well learn something along the way ;)
00:25:05 <ddarius> edwardk: On a tangentially related vein, I've considered trying to program things that don't (apparently) fit the stream programming model well with stream programming like compilers and evaluators, just to see what happens.
00:25:47 <edwardk> hrmm, stream programming in the comonadic stream processing 'fby'-everywhere dataflow sense?
00:26:49 <ddarius> I didn't think of it that way, but I think equivalently so.  Stream programming in the SICP, lazy list sense.
00:27:09 <edwardk> hrmm
00:27:29 <edwardk> lotsa data in them thar streams ;)
00:27:49 <shachaf> ddarius: On the first run of Mendeley, it shows a setup window. Maybe it's used by automated install scripts to go through setup without running the program.
00:28:00 <ddarius> Yeah, the trick is to actually break the problem up and not to just fall into (map eval input)
00:28:48 <edwardk> well, if problems like that do reasonably decompose nicely, then there might be hope for the distributed actor'ish version of things
00:43:02 <Philippa> ddarius: what sort of thing are you looking at? I imagine you could do interesting things for typechecking where your constraint system has appropriate properties, for example
00:43:36 <Philippa> but I'm way too used to thinking of those sorts of tasks as folds in some monad or something along those lines
00:43:36 <ddarius> Philippa: I'm not sure which statement you are responding to.
00:43:53 <Philippa>  <ddarius> edwardk: On a tangentially related vein, I've considered trying to program things that don't (apparently) fit the stream programming model well with stream programming like compilers and evaluators, just to see what happens.
00:44:01 <Philippa> got particular languages etc in mind?
00:45:11 <ddarius> Philippa: For what to actually work on the details of the problem (i.e. what language to evaluate/compile) aren't too important and the implementation language would probably be Haskell.  As for approaches, I think stream processing the terms with the small-step semantics would be reasonably compelling.
00:45:28 <ddarius> I have no idea how to structure a compiler in a not completely contrived way as a stream transducer
00:46:44 <ddarius> The optimization phase would probably fit reasonably well though...
00:53:02 <adu> edwinb: the parsec idea
00:53:15 <adu> er edwardk
00:54:45 <ddarius> edwardk left.
01:00:05 <Philippa> 'lo
01:00:18 <Philippa> edwardk: glad you got the layout sorted
01:00:25 <edwardk> Heya
01:00:34 <edwardk> Yeah works well
01:01:18 <dabblego> hey edwardk !!
01:01:29 <Philippa> did you bother covering the separator cases?
01:01:34 <edwardk> Nah
01:01:50 <edwardk> Heya dabblego 
01:02:55 <edwardk> I suppose technically there should be some way to cause a parse error
01:03:01 <Philippa> layout lang description separate from parser lang description?
01:03:26 <Philippa> (but v.simple, I imagine?)
01:03:36 <edwardk> Its just a combinator atm
01:04:44 <edwardk> Switching from phone to laptopbrb
01:08:55 <edwardk1> back
01:09:10 <Philippa> "a" combinator? In the parsing layer?
01:09:18 <edwardk1> yeah
01:09:24 <Philippa> *nod*
01:09:32 <edwardk1> one sec. i'll pull up a link
01:09:53 <Philippa> the parse-level bit of my brute-force parsec 3 parse-error implementation works like that too
01:10:15 <Philippa> not sure I want to see in case I get hyper one night and write a paper :p
01:10:22 <edwardk1> https://github.com/ekmett/layout/blob/master/src/main/scala/scala/util/parsing/combinator/LayoutParsers.scala last few lines
01:10:44 <edwardk1> 'laidout' does all the work
01:10:55 <edwardk1> other than that space absorbs all whitespace and comments into a space token
01:30:51 <Bynbo7> jlouis: you around?
01:43:01 <Bynbo7> > do { [x] <- Just []; return x }
01:43:03 <lambdabot>   Nothing
01:49:06 <pumpkin> preflex: seen SamB
01:49:06 <preflex>  SamB was last seen on ##javascript 11 hours, 49 minutes and 42 seconds ago, saying: Why is it when I press the serialize button nothing happens? Is there some error? http://pastie.org/1403830
01:56:04 <Bynbo7> geeze, why is irc so dead on christmas day
01:58:36 <listofoptions> bc its christmas day
02:07:38 <Juicer> hi
02:13:26 <mreh> how do you split a darcs change up into two smaller changes?
02:44:42 <ezyang> @tell copumpkin Heh. You can fix that using git commit --amend --author, I think. 
02:44:42 <lambdabot> Consider it noted.
02:55:40 <mreh> you there boy! what day is it today?!
02:56:23 <Bynbo7> Why it's Christmas day sir!
02:57:18 <monadic_kid> bar humbug
02:57:19 <mreh> Do you remember that prize turkey in the window of the butchers? Has it been sold yet?
02:57:57 <mreh> Here's 100 lambdas, go and buy it and meet me at the door of SPJ's house!
03:17:03 <lispy_> mreh: it depends on 'when' you're trying to do it.  At record time, IIRC there is a UI for splitting hunks.  Once the change has been recorded you would have to amend-record it to change it
03:18:12 <lispy_> mreh: ah, "e: interactively edit this change"
04:15:59 <qwr> hmm, is it so, that to do substring replace with regex, I should use the Text.Regex compat package??
04:17:45 <qwr> (or write that replacement routine by myself...)
04:19:43 <qwr> with matchText it isn't very hard, of course...
04:20:08 <qwr> or matchAll
04:32:18 * hackagebot unusable-pkg 0.1 - Utility construction of the graph depending unusable packages.  http://hackage.haskell.org/package/unusable-pkg-0.1 (YuriyIskra)
05:01:49 <dankna> Merry Haskellmas!  (Trying to stay on-topic.)
05:02:20 <Phyx-> Merry Hmas to you too!
05:02:27 <dankna> hehe
05:37:31 <revenantphx> Well, time to "find" digital copies of all my books :)
05:38:28 <Bynbo7> on the pirate b^w^wAmazon?
05:38:51 <revenantphx> I do wish Amazon had a "buy print, get free kindle"
05:39:00 <revenantphx> They should do that >_>
05:39:10 <danderson> they never will though
05:39:14 <revenantphx> Until they do they cannot expect me to buy two copies then :P.
05:39:24 <revenantphx> Oh well, I can read PDF's or convert them
05:39:27 <danderson> it was hard enough to sell publishers on the idea that digital books were a money making idea
05:39:58 <danderson> to now propose the scandalous idea that buying the rights to a work *once* might entitle you to enjoy the work in multiple forms
05:40:03 <danderson> it would be madness.
05:40:21 <revenantphx> Madness I say.
05:40:49 <danderson> http://mimiandeunice.com/wp-content/uploads/2010/11/ME_240_KillingMusic.png
05:41:04 <revenantphx> You never know though, some publisher might see it as an opportunity.
05:41:06 <danderson> somewhat relevant, although the challenges of books in the digital age are somewhat different.
05:41:11 <revenantphx> Yeah.
05:41:27 <danderson> (also, questioncopyright.org, which is where that strip came from)
05:41:47 <revenantphx> I literally only pay for software when I know the payment is directly do the developer.
05:41:47 <danderson> revenantphx: google books apparently found favor with various indie publishers
05:42:13 <revenantphx> Hm.
05:42:24 <revenantphx> copyright's a touchy issue these days.
05:42:34 <danderson> I can't comment on why they like it specifically because I haven't looked into it, but the buzz was that it might be an interesting alternative to amazon's current hegemony
05:42:38 <revenantphx> I need to go read through the FCC net neutrality draft that was published.
05:42:51 <danderson> (of which I am an embarassed participant, as I own a kindle :/)
05:43:02 <danderson> oh, right, I remember
05:43:23 <revenantphx> Oh they approved the rules.
05:43:28 <revenantphx> Yes I do need to read through these.
05:44:05 <danderson> didn't read through that either, mostly because I have no illusions :)
05:46:39 <Bynbo7> O'Reilly seems to do an alright job, giving you book/ebook bundles for not much  more than the book alone
05:47:04 <danderson> true, though that's a rarity
05:47:32 <danderson> and arguably, the electronic edition should be free, since the books are originally created in an electronic form amenable to automatic translation to ebook format.
05:48:08 <arcatan> i gather it's not just the dead tree we're paying for when buying books
05:48:17 <danderson> but yeah, better than "pay X for the book, then 0.9*X for the ebook!"
05:48:45 <danderson> arcatan: you're buying a share of all the work that went into the book, as well as the dead tree
05:48:57 <arcatan> yeah
05:49:01 <revenantphx> Oh you can get Mobi format from Oreilly, nice.
05:49:12 <danderson> but then, if you bought your share of the work + the dead tree, shouldn't the electronic form, which is all the work minus the dead tree, come as a free bonus?
05:49:21 <arcatan> danderson: sure
05:49:26 <revenantphx> Dunno though, I never really used the O'Reilly books.
05:49:29 <danderson> except it doesn't.
05:49:48 <danderson> it comes at a cost that is on the same order of magnitude as the dead tree
05:49:53 <arcatan> but the price for just the electronic form prolly isn't that much less than the price for the dead tree version
05:49:55 <revenantphx> I think what's changed today is that "the book" is not what you're paying for anymore.
05:50:12 <revenantphx> It used to be that an illuminated scripture or finely typeset book was very expensive, no matter what it was.
05:50:17 <revenantphx> Just because it was _hard to produce_.
05:50:23 <revenantphx> Nowadays, that's not the case.
05:50:40 <revenantphx> The definition of "book" had changed.
05:50:42 <danderson> revenantphx: right, digital media has forced lots of industries to distinguish between the work itself and the medium on which you receive it
05:50:58 <revenantphx> A "book" is now a published written work, not a bundle of dead tree.
05:51:01 <danderson> except that most of them still charge you per delivery system
05:51:04 <danderson> instead of once for the work.
05:51:26 <danderson> (plus incidentals for each delivery system, obviously - fair is fair)
05:51:26 <revenantphx> Music not so much, since all of the distribution mediums are digital.
05:51:43 <revenantphx> If Amazon offered say, 49.99 for some book
05:51:49 <revenantphx> and then 1.99 to get the ebook on top of that,
05:51:51 <revenantphx> that's reasonable.
05:52:08 <danderson> indeed, though I'd rather go with the opposite
05:52:20 <revenantphx> sorry, when I say "book" I don't mean the paper book.
05:52:27 <danderson> day, 40 for a book, plus <cost of printing> if I want a dead tree
05:52:31 <revenantphx> I mean you buy the book itself, and then pay a small fee per distribution.
05:52:38 <danderson> yeah, so we agree :)
05:52:52 <revenantphx> Yeah, I think that's a great model. Amazon keeps saying it themselves, 
05:52:57 <revenantphx> people like reading across multiple devices.
05:52:58 <danderson> I just see the electronic form as free, since books these days are born and bred in a computer in the first place.
05:53:00 <revenantphx> Why not multiple media?
05:55:07 <danderson> revenantphx: the future of books seems to be electronic, with multiple media meaning "multiple devices from different vendors"
05:55:18 <revenantphx> yeah...
05:55:23 <danderson> I fully expect to end up old in a world that considers paper books an oddity
05:55:31 <revenantphx> Oh yeah, by 2010 at the latest.
05:55:33 <revenantphx> 2020*
05:55:53 <shachaf> danderson: Do you have a suitable replacement?
05:55:54 <revenantphx> But you know, paper books will always have their consumers. We have huge libraries that aren't going anywhere.
05:56:09 <danderson> which, until ereaders can produce the scent of aging book, is a loss for me.
05:56:16 <revenantphx> danderson: yeah.
05:56:30 <danderson> revenantphx: I suspect that in 20 years you'll be telling youngsters to get off your lawn :)
05:56:35 * shachaf *hates* this weird modern abuse of commas. Where did it come from?!
05:56:39 <revenantphx> danderson: what? I'll be 36 D:
05:56:43 <shachaf> Never mind. I haven't slept in too long.
05:57:00 <revenantphx> On all trips, take with you a Kindle and a 40 year old dictionary. Every 15 minutes, take a good hard whiff of the book.
05:57:33 <danderson> shachaf: the kindle, or e-ink based displays in general. As much as I enjoy the feel and scent of paper, I must admit that e-ink electronic readers are exceedingly convenient and comfortable.
05:57:45 <shachaf> danderson: I've never found it to be so.
05:58:05 <danderson> to each his own, I guess.
05:58:35 <danderson> But I've definitely read more with a kindle, and the ability to buy a book at any time (yay free 3g)
05:58:50 <revenantphx> The free 3g alone is great.
05:58:57 <shachaf> medfly`: You're in .il?
05:59:13 <danderson> I just wish that the various players would settle on a single format
05:59:15 <shachaf> DRM on e-books is evil.
05:59:17 <danderson> for portability.
05:59:39 <revenantphx> Yeah, really...
05:59:40 <danderson> unfortunately, given that amazon has the market cornered, it's in their interest to remain unique.
05:59:46 <shachaf> Can we fast-forward through the realization that it took the music people N years to get through?
05:59:56 <danderson> shachaf: unfortunately not.
06:00:08 <danderson> The good news is that the DRM is quite weak
06:00:13 <revenantphx> Seeing animated JS content like google's current homepage on the kindle is hilarious.
06:00:20 <revenantphx> It's seizure inducing as well.
06:00:25 <shachaf> danderson: That's not really good news. I don't want to break DRM.
06:00:44 <danderson> shachaf: it's good news in the sense that I can act to maintain my own freedom
06:00:51 <danderson> not in that it's a good idea in general.
06:01:11 <revenantphx> http://xkcd.com/548/
06:01:12 <shachaf> danderson: Yes, but I'm not about to buy DRMed books no matter how weak the DRM.
06:01:14 <revenantphx> ^ revelant
06:01:20 <danderson> unfortunately, we live in a world of compromise.
06:01:34 <revenantphx> shachaf: there is the convenience of more flexiblity however
06:01:45 <shachaf> revenantphx: As in "revelantphx"?
06:01:50 <revenantphx> :|
06:01:53 <revenantphx> shachaf: nice.
06:01:54 * shachaf suspects you're too used to typing out your nick.
06:01:58 <revenantphx> maybe.
06:02:24 <danderson> I'd love to be idealistic, but the world won't let me
06:02:38 <shachaf> revenantphx: Yes, I understand that paying for convenience with your "essential liberties" is a standard practie. :-)
06:02:45 <danderson> so I compromise by keeping free backups of the stuff I legitimately acquired :)
06:02:56 * relevantphx has PDF's of half his print books.
06:03:05 <relevantphx> PDF is kind of a shit format to read books in sadly.
06:03:09 * Bynbo7 wonders if this conversation is more apropriate to #haskell-blah
06:03:10 <relevantphx> (on a kindle or such)
06:03:11 <danderson> yup
06:03:27 <danderson> ePub looks to be the format of the Future for at least a couple of years
06:03:37 * shachaf thinks the #-blah boundary has been crossed a couple pages ago.
06:03:41 <danderson> unfortunately, the kindle has everything to gain by not supporting it
06:04:08 <danderson> (also, yeah, what shachaf said - then again we're not disrupting any hugely insightful haskell discussion :)
06:04:31 * shachaf monadicates loudly.
06:04:41 <relevantphx> danderson: I know what we can do.
06:04:56 <relevantphx> Write a *good* epub-->mobi converter.
06:04:58 <relevantphx> In haskell.
06:05:25 <danderson> heh
06:05:36 <danderson> I'm full to the brim of haskell projects right now, no time for more
06:06:16 <danderson> the back burner is a meshed VPN router in haskell (my original "learn haskell through extreme pain" project)
06:06:33 <danderson> next is a binary translator using LLVM
06:06:55 <danderson> and most recently, a morse code reader DSP program
06:07:01 <danderson> (that works, to my shock and awe)
06:07:46 <revenantphx> Are you kidding me.
06:07:51 <revenantphx> The PDF reader has no Table of Contents.
06:07:57 * revenantphx rages silently.
06:09:14 * shachaf contemplates organizing a Kindle-burning.
06:09:20 <shachaf> It seems appropriate, after all.
06:09:39 <danderson> doesn't burn as well
06:09:56 <danderson> a kindle magnetizing would be the appropriate analogy, I guess
06:10:04 <danderson> pile kindles over a big electromagnet
06:10:10 <shachaf> danderson: Huh? "kindle" doesn't burn well?
06:10:14 <shachaf> Preposterous.
06:12:05 <medfly`> shachaf, yes
06:12:18 <danderson> well, it probably burns okay
06:12:20 <Bynbo7> "A group of angry programmers has died today, where they were attempting to hold a kindel "book" burning, after inhaling noxious fumes"
06:12:26 <danderson> but not as magestically as books
06:12:36 <danderson> and yeah, toxic fumes.
06:12:47 <revenantphx> http://www.youtube.com/watch?v=s4_j4c7Bop0
06:12:49 <revenantphx> :|
06:12:52 <shachaf> danderson: S: (n) kindling, tinder, touchwood, spunk, punk (material for starting a fire)
06:13:07 <revenantphx> They burn really well.
06:13:10 <danderson> shachaf: that's in oldspeak. Are you a revolutionary?
06:13:17 <danderson> oldspeak doubleplusungood.
06:13:25 <revenantphx> :)
06:14:14 <revenantphx> danderson is goodthinkful
06:14:21 <danderson> anyway, excessive beer has been consumed
06:14:21 <medfly`> Bynbo7, really?
06:14:23 <danderson> sleep time.
06:14:28 <shachaf> @localtime danderson
06:14:28 <lambdabot> Local time for danderson is Sat Dec 25 06:14:01 2010
06:14:40 <Bynbo7> O.O
06:14:40 <revenantphx> @localtime revenantphx
06:14:42 <lambdabot> Local time for revenantphx is 2010-12-25 09:14:14 -0500
06:14:47 <danderson> lambdabot: it's creepy that my client told you that.
06:14:53 <Bynbo7> @localtime
06:14:53 <shachaf> danderson: Turn it off.
06:14:57 <lambdabot> Local time for Bynbo7 is Sun Dec 26 01:14:26 2010
06:15:04 <danderson> shachaf: meh, I don't care. It just surprised me :)
06:15:07 <revenantphx> lambdabot is really person with your client.
06:15:10 <revenantphx> She gets around ;)
06:15:14 <revenantphx> personal*
06:15:15 * Bynbo7 pointfree's lambdabot like a bitch!
06:15:26 <shachaf> danderson: Was that time actually accurate?
06:15:31 <revenantphx> @vixen How well do you know danderson's client?
06:15:32 <lambdabot> yeah, i know
06:15:37 <revenantphx> @vixen Really?
06:15:38 <lambdabot> yes
06:15:42 * shachaf suspects that danderson's IRC client runs on a server somewhere.
06:15:46 <revenantphx> @vixen Sex penis vagina 
06:15:47 <lambdabot> Always wanting to talk about the member, eh?
06:15:48 <Bynbo7> heh, that time's wrong, because <this> machine is in a different timezone from >this< one
06:15:52 <danderson> shachaf: yup, it's accurate.
06:16:05 <danderson> it does run on a server somewhere, but it's my server
06:16:10 <danderson> so the timezone is set correctly.
06:16:22 <shachaf> @precise-location danderson
06:16:22 <lambdabot> Unknown command, try @list
06:16:25 <shachaf> Aw.
06:16:26 <revenantphx> Am I like the only person who actually turns on their client when they're online?
06:16:41 <revenantphx> and doesn't use some online server, bouncer, or quassel-core?
06:16:42 <shachaf> revenantphx: Probably?
06:16:45 <revenantphx> :(
06:16:46 <Bynbo7> medfly`: heh, no :P
06:16:48 <shachaf> revenantphx: Why would you do that?
06:16:50 <revenantphx> What's the obsession?
06:16:54 <danderson> shachaf: San Francisco bay area.
06:17:39 <danderson> revenantphx: irc is about the closest I have to a "phone number" for friends :)
06:17:46 <revenantphx> haha.
06:17:51 <revenantphx> It is an invaluable resource.
06:18:03 <revenantphx> If I taught a programming course I would instruct all students to "bug other strangers, not me"
06:19:36 <arcatan> i'm turning irc on and off all the time, so it's easier to just attach and detach a tmux session
06:24:40 <shachaf> revenantphx: Being present in an IRC channel foils your plans.
06:26:03 <medfly`> I actually take this one class, and the TA said that he suggested making students who don't ask for help from the prof/TA directly (they have like an hour for that) several times during the semester, fail the course
06:27:45 <dolio> Automatically?
06:27:50 <dolio> Why would you do that?
06:31:57 <Rutix> Lol wut
06:32:12 <Rutix> Most stupid thing i ever heard
06:32:54 <danderson> being smarter than your TA is dangerous business, clearly.
06:33:00 <Rutix> Idd
06:33:38 <dolio> I've never understood basing grades on anything other than whether you complete the work and pass the tests and such.
06:34:00 <dolio> If it's a lecture course, and someone can complete all the assignments and pass the tests without coming to class, so be it.
06:34:14 <MoALTz> medfly`: supremely retarded
06:35:08 <medfly`> they really valued it for some reason
06:35:10 <dolio> If part of the course is class discussion, then some level of attendance is required as a byproduct.
06:35:23 <MoALTz> grading on a curve only makes sense if you're an employer or some other stupid entity that must cull the bottom X% regularly
06:35:50 <MoALTz> (promoting on a curve is worse because it will favor people who game the system IMO)
06:37:05 <dolio> There was a post on the math reddit about a teacher who had a reputation of having a class full of failing students, and then grading on a curve to get the actual grades.
06:37:18 <MoALTz> perhaps this should be taken to #haskell-blah 
06:37:19 <dolio> So the poster worked his ass off to actually get a passing grade.
06:37:19 <medfly`> promoting on a curve seems troublesome for more ways than one - it discourages you from helping your peers 
06:37:26 <MoALTz> (i didn't notice before replying sorry)
06:37:43 <dolio> And then the teacher got mad at him.
06:57:49 <MrHOLO> Merry Christmas all
07:18:00 <jmcarthur> dolio: i had a teacher like that once. i hated that class
07:18:21 <jmcarthur> i constantly felt like i was going to fail it, and a huge portion of the class dropped
07:18:46 <jmcarthur> then it turns out that i ended up with a nearly "perfect" score after the curve
07:19:08 <medfly`> sounds really mean
07:19:14 <jmcarthur> felt that way, too
07:19:27 <jmcarthur> i honestly think i learned *less* because of that, too
07:19:42 <jmcarthur> i was so worried about the grade that once the class was over i just wanted to distance myself from the topic
07:22:19 <revenantphx> lul. pdf to epub/mobi conversion fails like a boss.
07:22:31 <revenantphx> Do I want chapter 2, 2, 4, 6, 10, 10, 10, 10 or 13?
07:23:04 <revenantphx>  I like hoe the first five of those kind of have a fibonacci number-esque sequence.
07:33:57 <Bram> revenantphx: I'm personnaly converting my pdf to mobi by hand via writting html using abusing quantity of macro/:g/:s/:norm in vim then converting the html to mobi, best solution I've found but not really funny
07:34:13 <revenantphx> Well you really learn the book that way.
07:36:29 <revenantphx> Bram: You have any already converted I can have :D?
07:37:33 <Bram> revenantphx: I have convert learn you haskell for great good, h2g2 and I'm finishing 7 habits of hightly effective people right now
07:37:43 <revenantphx> h2g2?
07:37:47 <revenantphx> I'll take lyah for sure.
07:38:21 <Bram> hitchhiker's guide to the galaxy
07:39:24 <revenantphx> aaah gotcha
07:39:32 <Bram> revenantphx: http://blog.worlddomination.be/lyhfgg/
07:40:34 <revenantphx> awesome thanks
07:42:16 <pozic> Is there a parallel version of logict?
07:45:36 <jmcarthur> pozic: not that i know of, but that would be awesome
07:46:32 <pozic> jmcarthur: how terribly slow is logict, btw?
07:48:17 <revenantphx> Bram: your lyah is missing a working toc
07:49:01 <Bram> revenantphx: yeah, dunno how to do it :/ I haven't found any officiel specification for .mobi on how to create those
07:49:12 <pozic> jmcarthur: (I read some people complain about it. ) I programmed something using it myself now, but I am afraid I would have to rewrite it using explicit datastructures.
07:49:27 <Bram> revenantphx: if you have any documentation ...
07:49:41 <revenantphx> http://www.mobipocket.com/dev/default.asp
07:50:01 <revenantphx> http://www.mobipocket.com/dev/article.asp?BaseFolder=prcgen&File=section.htm
07:50:09 * hackagebot blaze-html 0.3.2.0 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.3.2.0 (JasperVanDerJeugt)
07:50:17 <revenantphx> http://www.mobipocket.com/dev/article.asp?BaseFolder=creatorpublisher&File=toc_wizard.htm
07:51:45 <Peaker> Hey, I have "hmatrix" installed, it claims it has the module "Numeric.LinearAlgebra" in it, but import of it failed... what gives?
07:52:11 <pozic> Peaker: maybe it depends on a C lib?
07:52:25 <pozic> Peaker: (at configure time)
07:52:26 <Bram> revenantphx: oh, thx
07:52:27 <Peaker> pozic, but hmatrix supposedly successfully installed and I even see it compiling Numeric.LinearAlgebra
07:52:37 <pozic> Peaker: in that case, no idea.
07:53:03 <Peaker> where are the modules located so I can look what's there?
07:53:09 <Peaker> installed to user by cabal
07:53:22 <revenantphx> Bram: You should also consider scaling the images a bit better.
07:54:10 * hackagebot blaze-html-hexpat 0.1.0.0 - A hexpat backend for blaze-html.  http://hackage.haskell.org/package/blaze-html-hexpat-0.1.0.0 (JasperVanDerJeugt)
07:54:20 <Peaker> if I use -package hmatrix on ghci, it tells me there's a QuickCheck problem
07:55:18 <Bram> revenantphx: do you have an idea of witch kind of size they should have ? 
07:55:30 <revenantphx> Well, have them scale with font size preferably.
07:55:35 <Peaker> That's pretty horrible, it would be nice if "ghci" could tell me about packages it failed to load, at least when trying to import them
07:55:41 <revenantphx> Try to define their size relative to the font.
07:56:44 <pozic> runghc: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
07:56:49 <pozic> Peaker: that's what I get.
07:57:04 <pozic> Peaker: 6.12.1
07:59:08 <Bram> revenantphx: didn't find anything like that, but found this http://www.mobipocket.com/dev/article.asp?BaseFolder=prcgen&File=images.htm#rez
08:00:24 <pozic> jmcarthur: do you know how you can express that if option X is not possible that there is no point in choosing some other option?
08:00:40 <JBaptist> Hi there everybody.
08:00:57 <Bram> hum, have thinks to do, I'll patch it later
08:01:20 <JBaptist> Is anyone here familiar with the Network module?
08:01:33 <pozic> JBaptist: do not ask to ask.
08:03:07 <JBaptist> Okay, I will ask directly: Network.setSocketOption seems to be broken, as suggested here: http://markmail.org/message/gi4wxwsbxo4wxbbc There was a patch submitted a while ago, as mentioned here: http://article.gmane.org/gmane.comp.lang.haskell.libraries/7514/match=socket I am wondering if anyone has any further information on this, or suggestions for a workaround, as I'd like to use this function.
08:07:49 <JBaptist> Maybe Christmas isn't the best time to ask these kind of questions.
08:10:03 <revenantphx> Nah it's fine.
08:10:27 <revenantphx> In #haskell on christmas you just get groups of carolers singing your answers instead of the norm.
08:10:30 <revenantphx> @quote fugue
08:10:30 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:11:25 <JBaptist> revenantphx: What I mean is, there doesn't seem to be any answer, carolled or otherwise, forthcoming.
08:11:50 <revenantphx> Ah, quick question, are you trying this in ghci?
08:12:02 <revenantphx> When I was using SO_REUSEADDR, it worked per "run" of the program.
08:12:23 <revenantphx> However, running the port is kept by the ghci instance as a process, not my program, so it didn't seem to be working.
08:12:32 <revenantphx> Try compiling and running instead, and see if it works for you then.
08:13:38 <JBaptist> SO_REUSEADDR works for me. It's specifically SO_SENDTIMEO and SO_RECVTIMEO that don't work, because they expect timeval structs as parameters, rather than just ints. So setsockopt fails with "Invalid parameter," both in ghci and from a compiled binary.
08:15:17 <JBaptist> Looking at the source of Network, I see that there's no way to pass anything other than a regular CInt to the underlying C function, which is why the patch linked to above creates a new API. But I don't know if the patch has been accepted.
08:16:33 <revenantphx> hm, I see.
08:17:30 <pozic> JBaptist: if you have to wait for that you can wait a month. 
08:17:43 <pozic> JBaptist: just solve your immediate problem. 
08:18:23 <BottL> guys, a silly question: I'm reading from input, reading each line with getLine, but the problem is that the last line doesn't have a newline after it so I never get to read it, how do I fix that?
08:19:02 <JBaptist> pozic: If you mean I shouldn't wait for the patch to be accepted, it was submitted in 2007, so waiting is clearly not the issue. At solving my immediate problem in any fashion would be nice, but short of re-writing the Network.BSD module, I don't see how. Any suggestions?
08:19:14 <benmachine> JBaptist: network has a github, if it helps
08:19:34 <JBaptist> benmachine: It does, and the version there doesn't contain the patch, either.
08:19:42 <benmachine> https://github.com/haskell/network
08:19:53 <benmachine> hmm
08:20:17 <jlouis> byorgey: yes
08:20:24 <jlouis> argh, mistell, sorry Brent
08:20:27 <jlouis> Bynbo7: yes
08:20:52 <listofoptions> huzza and let there be algebraic data types for all
08:20:59 <benmachine> JBaptist: the patch you linked was ages old, so I guess it's just been lost, I'd advise checking if it still applies and possibly resubmitting it?
08:22:17 <JBaptist> benmachine: Yes, probably. The protocol in this case is to contact the package maintainer directly?
08:22:41 <benmachine> the protocol differs per-package, but contacting the maintainer is the most usual way
08:23:25 * benmachine has a look
08:23:46 <benmachine> ah
08:23:56 <benmachine> JBaptist: the cabal file suggests http://trac.haskell.org/network/
08:24:28 <benmachine> http://trac.haskell.org/network/report/1
08:24:48 <benmachine> http://trac.haskell.org/network/ticket/31
08:25:08 <benmachine> that suggests a possible workaround
08:25:20 <benmachine> what was the socket option you wanted to set, anyway?
08:25:30 <benmachine> oh right, the timeouts
08:26:01 <benmachine> JBaptist: I agree that the API should be fixed but the suggested workaround is to use System.Timeout I think
08:26:09 <benmachine> or your own solution with threads
08:26:38 <benmachine> JBaptist: why do you need to set those options?
08:26:44 <JBaptist> benmachine: Aha, okay, thanks for that
08:27:05 <Eduard_Munteanu> Can record names be reused for different constructors of the same datatype?
08:27:23 <Eduard_Munteanu> (as in record syntax)
08:27:27 <benmachine> Eduard_Munteanu: yes, I think so
08:27:44 <Eduard_Munteanu> Ah, thanks.
08:27:44 <benmachine> (but the easiest way to find out for sure is to try :P)
08:27:52 <Eduard_Munteanu> I guess so :)
08:28:05 <JBaptist> benmachine: I'd like network connections to automatically reconnect if one side disappears
08:28:25 <benmachine> JBaptist: so you're setting the timeout to discover if your partner's vanished?
08:29:05 <benmachine> I guess System.Timeout would cover you for that, although the socket option sounds like it could be more convenient
08:29:18 <benmachine> but you could definitely do it with threads (and possibly async exceptions)
08:29:48 <benmachine> threads are much less scary in haskell than in C, so some problems are solved more naturally with them
08:30:10 <JBaptist> I'm setting the timeout so we don't wait forever for a peer that has disappeared.
08:30:15 <benmachine> right
08:30:25 <JBaptist> Yes, my program is very mutlithreaded as it is, I was hoping to avoid even more threads.
08:30:58 <benmachine> haskell threads are super-cheap
08:31:11 <benmachine> you can spawn literally millions of them :)
08:31:19 <benmachine> or so I've heard
08:31:23 <benmachine> certainly thousands, anyway
08:31:38 <JBaptist> It was my only mental facilities that I was trying to avoid overtaxing, rather than the system. :)
08:31:43 <benmachine> heh, fair enough
08:31:47 <ezyang> depends on what each of them are doing 
08:32:10 <JBaptist> ezyang: Hi Edward, this is Jeff. I got your email.
08:32:32 <ezyang> JBaptist: Ah! Excellent :-) 
08:37:29 <JBaptist> But yeah, it looks like System.Timeout should do what I need
08:43:04 <JBaptist> benmachine: Thanks for your help, and have a good night.
08:43:30 <benmachine> you too :)
08:45:45 <Znudzon_> Hi. Can anyone tell me how to get time in Haskell i need time with msec to mesure algoritm time. ?
08:45:46 <revenantphx> quick poll, does anyone in here have some relevant non-pdf haskell ebooks I can have?
08:46:27 <revenantphx> Znudzon_: System.CPUTimeI believe?
08:46:36 <revenantphx> System.CPUTime *
08:46:58 <revenantphx> It claims picoseconds. I doubt it will ever get that kind of resolution though :3
08:47:44 <Znudzon_> thank you very much. i fill serch examples on google. Thank you one more time 
08:48:44 <Eelis> is it possible to get a   Ptr Int  out of an  UArray Int  ?
08:49:16 <Eelis> erm, i mean an UArray Int Int
08:49:33 <benmachine> Eelis: you might have to copy the array if you want to do it safely
08:49:39 <Eelis> how about unsafely?
08:50:28 <benmachine> Eelis: would Data.Array.Storable suit you better?
08:50:33 * Eelis looks :)
08:50:42 <benmachine> http://hackage.haskell.org/packages/archive/array/0.3.0.2/doc/html/Data-Array-Storable.html
08:50:56 <Eelis> hm, very interesting
08:52:18 <Eelis> ok, i'll use that instead i guess. i'm still interested in why i have to change array types for this though. it just seems that it shouldn't be hard to get an   Ptr Int  out of an  UArray Int Int
08:53:18 <benmachine> Eelis: I guess UArrays might do soemthing exotic, or be moved around by the GC or something
08:53:49 <Eelis> hmm..
08:58:59 <ziman> @pl f = g >>= \x -> h x >> return x
08:59:00 <lambdabot> f = liftM2 (>>) h return =<< g
09:00:01 <benmachine> ziman: h x >> return x is the same as x <$ h x
09:00:14 <benmachine> which is ap (<$) h x
09:01:07 <benmachine> so f = g >>= ap (<$) h
09:01:19 <benmachine> :t \g x -> g >>= \x -> h x >> return x
09:01:20 <lambdabot> Not in scope: `h'
09:01:26 <benmachine> :t \g h x -> g >>= \x -> h x >> return x
09:01:27 <lambdabot> forall t (m :: * -> *) a a1. (Monad m) => m a -> (a -> m a1) -> t -> m a
09:01:35 <benmachine> :t \g h -> g >>= \x -> h x >> return x
09:01:36 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> m a1) -> m a
09:01:50 <benmachine> :t \g h -> g >>= ap (<$) h
09:01:51 <lambdabot> forall (m :: * -> *) a b. (Functor m, Monad m) => m a -> (a -> m b) -> m a
09:02:04 <benmachine> :t \g h -> g >>= ap (liftM . const) h
09:02:04 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => m a -> (a -> m a1) -> m a
09:06:17 <ziman> benmachine, yeah, thanks much!
09:18:39 <cpa> hi there
09:18:50 <cpa> I have a Data.Int question
09:18:51 <ManateeLazyCat> cpa: Hi. :)
09:19:03 <ManateeLazyCat> cpa: Ask directly. :)
09:19:51 <cpa> Say, I read a byte from a handle, it's an Int8, and I want to use it as an Int. I currently do so:
09:19:59 <cpa> x <- hGet h 1
09:20:25 <ManateeLazyCat> @hoogle fromIntegral
09:20:25 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
09:20:27 <cpa> fromIntegral ((decode x) :: Int8)::Int
09:20:41 <cpa> is there a better way to do that?
09:21:04 <cpa> because it's quite boring to write this kind of code
09:21:44 <ManateeLazyCat> cpa: Why not (fromIntegral . decode) x ? 
09:22:06 <benmachine> the intermediate type will need to be made explicit
09:22:19 <benmachine> although the result type may well not be
09:22:41 <benmachine> cpa: you should only have to write such code once, though
09:22:46 <benmachine> it's easy to make a function that does that for you
09:23:16 <ManateeLazyCat> cpa: fun x = fromIntegral ((decode x) :: Int8)::Int ?
09:23:22 <ManateeLazyCat> cpa: Then just use `fun`?
09:23:33 <cpa> yes but I'm also using Int16 and Int32
09:23:40 <cpa> so basically I'll need 3 functions
09:23:50 <cpa> that's better, though
09:24:26 <benmachine> cpa: you might be able to reduce repeated code by using something like 'asTypeOf'
09:24:38 <ManateeLazyCat> cpa: data YourInt = Int8 | Int16 | Inte32 ?
09:24:47 <Botje> int9
09:24:52 <benmachine> ManateeLazyCat: I'm not sure how that helps
09:25:04 <Botje> PDP-11 for real yo
09:25:09 <benmachine> anyway, asTypeOf is a function that ignores its second argument but requires the two arguments to have the same type
09:25:19 <ManateeLazyCat> benmachine: Then it can write convert :: YourInt -> Int
09:25:37 <cpa> how should I use it ?
09:25:56 <benmachine> cpa: can we see more of your code? like, a function or two on hpaste.org
09:26:09 <benmachine> it's hard to give advice based on tiny snippets
09:26:27 <cpa> Would this type-check: List.length [] (asTypeOf (3::Int8) (0::Int))
09:26:28 <cpa> ?
09:26:42 <ManateeLazyCat> @hoogle asTypeOf
09:26:42 <lambdabot> Prelude asTypeOf :: a -> a -> a
09:26:46 <benmachine> cpa: no
09:27:08 <benmachine> cpa: asTypeOf requires the two arguments to be the same type, but those have different types
09:27:10 <tswett> ManateeLazyCat: ah, recall the syntax for data declarations.  The first thing is the name of the data constructor, and the following things are the types that the data constructor takes.
09:27:21 <cpa> so I don't get how it would help me
09:27:52 <tswett> cpa: how do you know whether you want decode to return an Int8, an Int16, or an Int32?
09:28:10 <cpa> well, it's part of a spec I have
09:28:18 <ManateeLazyCat> cpa: But you just need `fun`, and don't need fun8, fun16, fun32.
09:28:51 <benmachine> although tbh I think if you just did
09:28:59 <benmachine> toInt :: Integral n => n -> Int
09:29:03 <benmachine> toInt = fromIntegral
09:29:22 <benmachine> then toInt (decode x :: Int8) really isn't very noisy
09:29:37 <cpa> cool
09:29:55 <cpa> it'll do the job
09:29:59 <cpa> thanks!
09:30:03 <benmachine> or you could define getDecode h n = fmap decode $ hGet h n
09:30:09 <Guest29140> ?
09:30:10 <benmachine> then it's just
09:30:18 <benmachine> x <- getDecode
09:30:22 <benmachine> toInt (x :: Int8)
09:31:06 <ManateeLazyCat> Hmm, i think benmachine's suggestion is better.
09:31:17 <cpa> i like it
09:35:06 <Guest29140> exit
09:40:42 * hackagebot quicktest 0.1.3 - A reflective batch tester for Haskell.  http://hackage.haskell.org/package/quicktest-0.1.3 (DavidSiegel)
09:48:37 <Phyx-> this is odd...
09:48:47 <Phyx-> i never wrote code to evaluate this expression
09:48:49 <Phyx-> yet.. it works
09:48:52 <Phyx-> what the...
09:51:08 <Phyx-> how is this working...
09:52:01 <copumpkin> ezyang: amended :)
09:52:02 <lambdabot> copumpkin: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:53:08 <ezyang> cool. 
09:53:29 * Phyx- scratches head
09:53:36 <Phyx-> maybe i've had a bit too much to drink today
10:04:06 <Phyx-> :t quiet
10:04:06 <lambdabot> Not in scope: `quiet'
10:04:15 <Phyx-> where is everyone?
10:05:07 <dom96> probably celebrating christmas :P
10:05:57 <Phyx-> oh i forgot it's christmas
10:06:45 <JuanDaugherty> shouldn't matter much here
10:07:43 <Phyx-> lol
10:07:45 <JuanDaugherty> *that much
11:09:00 <samisaf> I am trying to build my own version of length as follows
11:09:25 <samisaf> length1 l = if l == [] then 0 else 1 + length1 (tail l)
11:10:04 <samisaf> I would like the type signature of the function to be length1 :: [a] -> Int
11:10:30 <samisaf> but I am getting (Eq a) => [a] -> Int
11:10:33 <samisaf> any ideas??
11:11:15 <arcatan> samisaf: using == requires the typeclass Eq even if the list is empty
11:11:22 <arcatan> but you could use null instead
11:11:24 <arcatan> > null []
11:11:25 <lambdabot>   True
11:11:32 <arcatan> > null [ 1,2,3]
11:11:33 <lambdabot>   False
11:12:13 <samisaf> Ok great, thanks lambdabot, although I though I was testing the list itself l, not its contents
11:12:16 <arcatan> or actually, use pattern matching
11:13:28 <samisaf> Yep, I tried pattern matching, and it worked fine. I was just interested in why my other version worked that way
11:13:34 <samisaf> Thanks guys
11:14:03 <arcatan> if you wouldn't been comparing l to an empty list, it would obviosuly need to Eq to see if the contents are equal
11:14:30 <arcatan> and now it doesn't know that other list is empty, so it still needs Eq even though it won't use ti
11:14:34 <arcatan> *ti=it
11:14:40 <BMeph> samisaf: It's kind of a philosophical argument; it doesn't make sense to tell if two lists are equal, if there's no way to tell if the elements iof the list are equal, even if the list you're interested in doesn't have elements.
11:16:22 <samisaf> I see, thanks a lot
11:16:54 <BMeph> samisaf: Thank you for not getting more confused from my statement. :)
11:17:37 <samisaf> No, it actually kind of make sense, but just a side question, any ideas then how null is implemented?
11:18:21 <BMeph> samisaf: That's easy; we cheat! ;)
11:18:36 <samisaf> Fair enough ;)
11:19:14 <BMeph> samisaf: More seriously, it's done by pattern-matching. We use the "special knowledge" of how a list is constructed.
11:19:57 <BMeph> samisaf: Example: { null [] = True; null _ = False }
11:21:23 <BMeph> samisaf: That way, you're effectively doing an "if <my list> == []" but without imposing an Eq requirement on it.
11:32:48 <Zutak> Hy guys, I have a noob question to do
11:34:04 <Zutak> so anyone can tell me how I make the ghci export the .hs file to .txt file ?
11:34:33 <systemfault> Wait, what?
11:34:55 <systemfault> Isn't a .hs file... a text file?
11:35:07 <Zutak> i have a hs file
11:35:16 <ziman> do you mean the output of the program?
11:35:19 <Zutak> that convert my list to something that i want
11:35:28 <Zutak> but i want that the ouput be a .txt file
11:35:32 <systemfault> Ahhh
11:35:33 <Zutak> is that possible =
11:35:35 <Zutak> ?
11:35:39 <systemfault> Zutak: What is your OS?
11:35:46 <Zutak> mac os x
11:36:09 <systemfault> In a terminal: yourprogram > yourtextfile.txt
11:36:19 <systemfault> ./foo > myresult.txt
11:36:20 <gwern> hee hee. I thought systemfault was going that route
11:36:20 <dschoepe> Zutak: writeFile "results.txt" (yourFunction ...) from within ghci would work too
11:36:25 <ziman> if your function returns String, you can do: writeFile "myfile.txt" (yourFunction arg1 arg2)
11:36:37 <systemfault> :P
11:36:46 <systemfault> I took the wrong route it seems..
11:36:47 <Zutak> ooh realy thanks
11:36:59 <Zutak> I search on google but could find anything
11:37:02 <Zutak> thanks guys
11:37:29 <ziman> Zutak, you're welcome. :)
11:42:51 <listofoptions> sigh...i just realized that what i'm doing can be don in about 5 mins with arrows
11:46:24 <Phyx-> systemfault: there is no wrong, just less right :P
11:46:54 <systemfault> :)
11:53:34 <dark> I'm reading http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-ParserCombinators-Parsec-Token.html , how to define a "GenLanguageDef", that is, a language? I mean I'm looking at http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Token.html#GenLanguageDef , is that the {-# LANGUAGE PolymorphicComponents #-} ?
11:54:15 <rrc7cz> why doesn't pattern matching like (x:x:xs) work on (Eq a) => [a], meaning two consecutive equal values in the list? 
11:54:40 <dark> it seems that i should not be messing directly with whitespace, parens, etc. first i define a "lexer" that would do this low level thing, then writing the grammar using combinators would be simpler
11:54:51 <Ke> rrc7cz: it's just not allowed
11:55:09 <dark> rrc7cz, i think you can use a guard
11:55:25 <dark> i think it is case l of x:y:xs -> .. when x = y
11:55:34 <dark> or something
11:55:46 <Phyx-> (x:y:xs) | x == y = ...
11:55:48 <rrc7cz> Ke,dark: okay, thanks. I think I got the idea from Prolog or Erlang, but I'm pretty sure I saw that ability somewhere before
11:56:05 <dark> oh, haskell uses ==
11:56:05 <Ke> yup
11:56:10 <dark> :t (=)
11:56:10 <lambdabot> parse error on input `='
11:56:17 <Phyx-> let (x:x:xs) = [1,2,3] in x
11:56:22 <Phyx-> > let (x:x:xs) = [1,2,3] in x
11:56:23 <lambdabot>   Conflicting definitions for `x'
11:56:24 <lambdabot>  In the binding group for: x, x, xs
11:56:46 <Phyx-> interesting.. i expected the second x to shadow the first
11:57:21 <dark> > case [1, 1, 3] of x:y:xs | x = y -> Just x | _ -> Nothing
11:57:22 <lambdabot>   <no location info>: parse error on input `='
11:57:31 <dark> > case [1, 1, 3] of x:y:xs | x == y -> Just x | _ -> Nothing
11:57:32 <lambdabot>   Pattern syntax in expression context: _
11:57:38 <dark> er.
11:58:11 <rrc7cz> I guess one problem in allowing this type of functionality is that you assume the arguments are members of the Eq typeclass
11:58:21 <dark> ok, without the | _ -> Nothing thing it works, but now i think I should return to LYAH
11:58:25 <dark> > case [1, 1, 3] of x:y:xs | x == y -> Just x
11:58:25 <lambdabot>   Just 1
11:58:36 <monochrom> dark: http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements has an example
11:58:45 <Phyx-> aww monochrom beat me to it
11:58:57 <Phyx-> jumping out of no where :P
11:59:00 <dark> monochrom, is this for parsec 2 or 3?
11:59:23 <monochrom> well you're using Text.ParserCombinators.Parsec.Token so it's both
11:59:45 <Phyx-> is it strange that i've never used Parsec
12:00:57 <lelf> > case [1, 2, 3] of x:y:xs | x == y -> Just x | otherwise -> Nothing
12:00:58 <lambdabot>   Nothing
12:01:13 <dark> oh, otherwise
12:01:28 <lelf> ?src otherwise
12:01:28 <lambdabot> otherwise = True
12:01:49 <Phyx->  > case [1, 2, 3] of {x:y:xs | x == y -> Just x; otherwise -> Nothing}
12:01:55 <Phyx-> > case [1, 2, 3] of {x:y:xs | x == y -> Just x; otherwise -> Nothing}
12:01:56 <lambdabot>   Nothing
12:02:07 <Phyx-> > case [1, 2, 3] of {x:y:xs | x == y -> Just x; _ -> Nothing}
12:02:08 <lambdabot>   Nothing
12:02:31 <Phyx-> why did that first one work..
12:02:36 <dark> > case Just 1 of Just x -> x | Nothing -> error "q"
12:02:36 <lambdabot>   <no location info>: parse error on input `|'
12:02:56 <Phyx-> dark: that's a multiline expression
12:03:02 <Philonous> Is there a way to make webkit use a proxy?
12:03:12 <Phyx-> you need to override the layout rule with {} and ; to use it in lambdabot
12:04:11 <shachaf> Phyx-: No, that's a meaningless expression. | is used for guards.
12:04:12 <dark> oh.. so | can never separate case clauses like ml's match. | is for putting guards
12:05:18 <Phyx-> shachaf: true, i was still thinking of his earlier one
12:05:24 <Phyx-> didn't read the second one
12:05:45 <Phyx-> but it still holds, he needs to use {} to make that one work afaik
12:05:46 <shachaf> > case 1 of x | even x -> True | odd x -> False -- No semicolons needed, either.
12:05:47 <lambdabot>   False
12:06:31 <Phyx-> > case Just 1 of {Just x -> x; Nothing -> error "q"} -- they are needed to do what he wanted
12:06:32 <lambdabot>   1
12:06:47 <shachaf> Although they are needed for regular pattern-matching, yes. But {} isn't needed there.
12:06:52 <dark> > case 1 of { x | even x -> True; x | odd x -> False }
12:06:53 <lambdabot>   False
12:09:10 <shachaf> dark: That's not quite the same (you have to type the pattern twice).
12:09:23 <monochrom> > case 1 of { x | even x -> True | odd x -> False }
12:09:24 <lambdabot>   False
12:10:21 <dark> it seemed one form could be translated mechanically to the other
12:10:27 <Phyx->  > case 1 of x | even x -> True | odd x -> False
12:10:31 <Phyx-> > case 1 of x | even x -> True | odd x -> False
12:10:32 <lambdabot>   False
12:10:51 <monochrom> case blah of { Just x | even x -> 0 | otherwise -> 1 ; Nothing -> 2 }
12:11:11 <monochrom> that is a more general example
12:11:56 * shachaf doesn't really like that syntax.
12:12:20 <shachaf> I wonder if there could be an ambiguity with nested cases or something.
12:12:34 <dark> it seemed a bit strange, but case is more concise / lighter than ocaml's match. ocaml uses a keyword where haskell puts |, and puts | where haskell code usually has only indentation
12:12:52 <monochrom> there is no ambiguity with nesting because of { }
12:13:10 <rrc7cz> how can you type list nesting? for example (Num [[t]], Num [t], Num t) => [[[t]]] but that makes assumptions about the depth, right? What if you want unlimited nesting support?
12:13:30 <monochrom> this is also why there is no dangling-else problem using if-then-else-fi
12:13:32 <dark> ocaml syntax is a hell with nested match :( like one has to put () or begin .. end around the inner match if it is not on the last clause
12:16:07 <mikeg> (Num [t]) doesn't make sense
12:16:23 <shachaf> monochrom: Well, yes.
12:16:37 <shachaf> mikeg: Sure it makes sense.
12:18:16 <mikeg> > [4] + [5]
12:18:17 <lambdabot>   No instance for (GHC.Num.Num [t])
12:18:17 <lambdabot>    arising from a use of `e_145' at <inte...
12:18:32 <shachaf> mikeg: Sure, the instance in't defined. But there are various sensible definitions for it.
12:18:37 <dark> maybe Num [t] could be a polynomial?
12:18:56 <dark> (t being the type of coefficients)
12:18:59 <monochrom> "Num [t] makes sense" in the sense that different people can assign different senses to it.
12:19:30 <copumpkin> you'd probably want Num t => Num [t]
12:19:38 <copumpkin> for whatever you do with it
12:19:40 <monochrom> it's like saying "manatee makes sense" :)
12:19:42 <copumpkin> unless you treat it as a natural
12:20:16 <shachaf> monochrom: Sure. But "(Num [t]) doesn't make sense" doesn't make sense. :-)
12:20:19 <shachaf> http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
12:20:46 <shachaf> Yes, and lazy naturals.
12:20:51 <shachaf> That way genericLength = id. :-)
12:21:03 <MrHOLO> Is Haskell a machine level language?
12:21:17 <MrHOLO> I mean a low level language
12:21:20 <shachaf> MrHOLO: Haskell is used to program machines, if that's your question.
12:21:26 <MrHOLO> Like C
12:21:32 <shachaf> MrHOLO: That depends on what you mean by "low level".
12:21:47 <MrHOLO> A language that is more closer to the machine 
12:21:56 <shachaf> MrHOLO: Than what?
12:22:07 <HugoDaniel> :D
12:22:08 <systemfault> He probably wants to know if you can generate native binaries with haskell
12:22:11 <Watermind> I just noticed mdo is now deprecated and changed to rec
12:22:19 <Watermind> where can I find more info on it?
12:22:20 <systemfault> Compared to.. let's say.. java that needs the jvm
12:22:32 <systemfault> (That was my interpretation... )
12:22:37 <Watermind> everything I find regarding recursive monads is with respect to mdo
12:22:46 <shachaf> systemfault: I doubt that has anything to do with a language being high-level or low-level.
12:23:06 <MrHOLO> Than the ones that are not 
12:23:15 <HugoDaniel> data Container a = Container a
12:23:19 <HugoDaniel> does this make any sense ?
12:23:21 <HugoDaniel> :/
12:23:29 <MrHOLO> C is an example for a low level language I guess
12:23:30 <HugoDaniel> isn't it useless ?
12:23:38 <shachaf> MrHOLO: ...That depends which ones are not.
12:23:45 <Watermind> nevermind
12:23:48 <Watermind> found it
12:24:12 <dark> MrHOLO, I heard that some algorithms can't be efficiently implemented in haskell. (the guy of bitC in some mailing list message seemed to imply that first-class mutability and heap-free allocation is a must for some present-day systems programming problems)
12:24:30 <shachaf> MrHOLO: Can you give a *meaning* for the term you're asking about, rather than an unexplained example?
12:24:37 <MrHOLO> Sure 
12:24:45 <MrHOLO> Give me some time 
12:25:24 <MrHOLO> What I want to know is this 
12:26:04 <MrHOLO> How much can I influence the machine to optimize my computations with Haskell?
12:26:25 <shachaf> MrHOLO: Run ghc -O. It will influence it to optimize your program.
12:26:59 <MrHOLO> So GHC does it own its own.
12:27:11 <MrHOLO> And I can't interfere. 
12:27:15 <dark> i think you can't make sure a piece of code will not do heap allocations
12:27:23 <MrHOLO> Interfere is too heavy a word I guess
12:27:24 <shachaf> MrHOLO: I did not say anything of the sort.
12:27:28 <shachaf> MrHOLO: Alternatively, read some of http://shootout.alioth.debian.org/
12:27:29 <dark> this normally is not a problem
12:29:42 <dark> MrHOLO, I think what you need is to learn how to use a profiler
12:30:03 <MrHOLO> dark, what would that mean?
12:30:10 <dark> I don't know :( I heard haskell profilers are "non-conventional", because haskell is non-strict
12:30:21 <Phyx-> MrHOLO: using the correct structures are the biggest influinces you can have
12:30:26 <dark> MrHOLO, it is a program used to analyze the performance of your program
12:30:36 <dark> it may let you find bottlenecks
12:30:37 <copumpkin> you can tell it what to unbox and help the optimizer with strictness annotations
12:30:46 <MrHOLO> It is not just about the speed that I am concerned about 
12:30:48 <Phyx-> but yeah, you can tweak the compiler by instructing it to unpack datatypes, custom rewrite rules etc
12:31:27 <MrHOLO> Something that I love about C is that I could play with memory allocation
12:31:44 <shachaf> Mmm, yes, so much fun.
12:31:48 <systemfault> How much time does it takes to become confortable with haskell? 
12:31:53 <dark> MrHOLO, it seems haskell has some restrictions on that
12:32:13 <djahandarie> You can play with memory allocation in Haskell too, if you feel like digging your own grave
12:32:14 <dark> I am comfortable with ocaml, have been trying some haskell thing (with parsec), without success. But will keep trying, haskell is so fun :)
12:32:33 <Phyx-> djahandarie: or if you're writing storable instances :P
12:32:43 <MrHOLO> Once shachaf told me I could program fibonacci series better 
12:32:57 <shachaf> MrHOLO: You wrote fib n = fib (n-1) + fib (n-2)
12:33:01 <MrHOLO> Yeah 
12:33:05 <MrHOLO> I can write it better now 
12:33:07 <shachaf> MrHOLO: That has nothing to do with being a "low-level language".
12:33:09 <MrHOLO> ;)
12:33:17 <winxordie> systemfault: as in general time or time you put into it? Personally, I'm still not comfortable that I can *do* what I can in haskell.
12:33:39 <MrHOLO> Yeah true.
12:33:47 <systemfault> winxordie: General... example, it took me years to properly grasp most of OOP + C++
12:34:30 <HugoDaniel> data Container a = Container a is just stupid, right ?
12:34:47 <dark> HugoDaniel, isn't this a phantom type?
12:34:47 <dschoepe> HugoDaniel: not in general
12:34:57 <dark> it has one value, undefined
12:35:02 <MrHOLO> If I can think of a way to compute a formula better, then I can code it better in Haskell
12:35:04 <HugoDaniel> well hmm
12:35:08 <HugoDaniel> the deal is simple
12:35:11 <HugoDaniel> i have a type class
12:35:19 <HugoDaniel> called "ToHTML"
12:35:34 <MrHOLO> But at times I wouldn't have to evaluate things.
12:35:35 <winxordie> systemfault: That's an interesting combination of statements; my commentary on them is best reserved to -blah . I'd say a year's worth of time (given sufficient effort every week) would do.
12:35:42 <HugoDaniel> with one function that renders html for the data type
12:35:53 <shachaf> dark: Huh? Why is it a phantom type?
12:35:57 <HugoDaniel> and i want to render a diferent kind of html 
12:36:01 <dschoepe> dark: no, it is essentially the same as `a'.
12:36:11 <systemfault> winxordie: Good
12:36:11 <shachaf> HugoDaniel: To make a new type for something you usually use "newtype".
12:36:14 <MrHOLO> Say I am trying to make a database of some application forms.
12:36:31 <HugoDaniel> so, i just wrap the data types in containers like those, and then instance that typeclass for the containers
12:36:36 <HugoDaniel> ah
12:36:38 <dark> uhm, i read it as something you can't actually put an actual value there
12:37:01 <MrHOLO> There I am really concerned about how to use memory better
12:37:03 <dschoepe> dark: that would be something like data Container a = MakeContainer (Container a)
12:37:36 <dschoepe> dark: the `Container' on the right hand side is a data constructor, and the one on the left is a type constructor
12:37:45 <dschoepe> (in the original example)
12:37:55 <shachaf> dark: That has more values than "undefined".
12:38:01 <dark> MrHOLO, http://www.haskell.org/haskellwiki/Performance
12:38:28 <dark> oh. right
12:38:39 <winxordie> systemfault: it's like learning how to ride a bike; playing with ghci (or hugs) and the different monads should get you running up to speed in no time.
12:38:43 <HugoDaniel> then how do i transform my datatype into the type defined by the newtype ?
12:38:51 <HugoDaniel> so that i can instance it ?
12:39:06 <shachaf> HugoDaniel: The same way you do it with the data type.
12:39:16 <systemfault> winxordie: Thank you :)
12:39:19 <HugoDaniel> calling the constructor ?
12:39:33 <shachaf> @src Sum
12:39:33 <lambdabot> Source not found. Do you think like you type?
12:39:44 <HugoDaniel> ok
12:39:46 <HugoDaniel> let me try it out :D
12:39:49 <HugoDaniel> thanks for the tip
12:39:50 <shachaf> > getSum $ Sum 5 `mappend` Sum 8
12:39:51 <lambdabot>   13
12:40:06 <dark> MrHOLO, it seems to me that in haskell you would first write a correct program, then refine it into making it run fast. (that's the part you get to learn how to use profilers)
12:40:10 <hgolden> hi. has there been any recent discussion or papers on the functior hierarchy proposal and the class system extension proposal?
12:40:23 <hgolden> s/functior/functor/
12:40:43 <MrHOLO> OKay 
12:40:53 <MrHOLO> Thanks. dark
12:41:39 <MrHOLO> I will read up on that and come back. I wanted to know what all I have in hand when using Haskell. That is all. 
12:44:12 <HugoDaniel> yes, newtype is exactly what i need :)
12:44:16 <HugoDaniel> thanks shachaf :)
12:44:27 <HugoDaniel> im such a noob eheh
12:46:05 <systemfault> A noob question I never dared to ask.... How good at maths do you need to be to learn haskell?
12:46:19 <djahandarie> No skill at all needed.
12:46:26 <djahandarie> (In math.)
12:46:29 <monochrom> grade school algebra
12:46:33 <systemfault> Ah ok :)
12:46:46 <monochrom> just for the sake of being comfortable with equations and variables
12:46:47 <HugoDaniel> systemfault: just the basics is enough
12:46:59 <djahandarie> As long as you can recognize patterns (required for learning anything really), Haskell will be fine.
12:47:04 <systemfault> No problem then :)
12:47:14 <shachaf> @quote maths
12:47:15 <lambdabot> kmc says: programming is inherently mathematical.  furthermore, the connection between haskell and maths is overblown by people who don't understand the language
12:47:15 <HugoDaniel> djahandarie:  :D
12:47:30 <dark> http://www.haskell.org/haskellwiki/Performance/Overloading Each type class constraint on an overloaded function corresponds to an extra argument passed at runtime (called a dictionary) (except in Jhc!), and a reference to a class method is implemented by extracting a field from the dictionary.
12:47:53 <djahandarie> dark, you can avoid that by specializing the function
12:47:53 <monochrom> in particular the skill of seeing an identity like "f x = not (not x)" and being able to go "oh so I could instantiate it as f False = not (not False)"
12:47:58 <dark> why can't type classes be resolved at compile time? producing a different function for each instantiation. (like c++ templates)
12:48:01 <djahandarie> (In GHC)
12:48:10 <monochrom> Don't laugh. Lots of people can't even do that.
12:48:11 <djahandarie> dark, that's what specialization is for, though you need to do it manually.
12:48:21 <dark> djahandarie, with a type annotation?
12:48:27 <djahandarie> No, GHC pragma
12:48:32 <dark> oh, neat
12:48:38 <djahandarie> @google GHC specialize
12:48:39 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html
12:48:39 <lambdabot> Title: 7.13.Pragmas
12:49:01 <HugoDaniel> monochrom: :)
12:49:09 <shachaf> monochrom: When I read the beginning of that sentence I thought you were going to say something that would make intuitionists unhappy with you.
12:50:29 <monochrom> Actually there is also a slightly more advanced requirement after instantiation. Unification.
12:51:14 <Phyx-> ah it feels good when hours of working on a braindump just compiles right away
12:51:39 <shachaf> Phyx-: And then proceed to segfault.
12:51:51 <shachaf> Oh, wrong channel (maybe).
12:51:52 <Phyx-> hey, don't ruin it :P
12:52:09 <Phyx-> actually, been getting alot of segfaults with ghc 7 
12:52:11 <Phyx-> way too much
12:52:18 <Phyx-> i might go back to 6.12
12:52:33 <djahandarie> People keep on talking about segfaults in 7
12:52:37 <djahandarie> Are you reporting these bugs?
12:53:05 <Phyx-> djahandarie: i really don't know what's cauzing it, so far i have only 1 program that consistenly does it
12:53:11 <Phyx-> and it's dependencies are huge
12:53:12 <djahandarie> hpaste?
12:53:15 <djahandarie> Hm
12:53:17 <dark> MrHOLO, another random bit: because c is close to the machine, its semantics is too restricted in certain ways. you can't express a lot of useful things in c. sometimes this lead to c code being larger (than something like haskell)
12:53:39 <Phyx-> djahandarie: it's a package on hackage
12:53:54 <Phyx-> if i knew specifically what did it i would have reported it
12:54:12 <djahandarie> I don't mind trying to narrow it down
12:54:25 <Peaker> every single signal processing/plotting library I found in Hackage used a different vector type, most of which don't have a way to translate to each other except via lists!
12:54:25 <gwern> IIRC, doesn't C sometimes suck at numerics precisrly because it's so low it can't optimize loops like Fortran can?
12:54:44 <monochrom> you're expected to optimize by hand
12:54:51 <Peaker> fft uses C-arrays, vector-fft uses the vector package.  hmatrix has its own (lame) vector and plotting based on it, bah!
12:55:01 <Phyx-> djahandarie: well, let me see if it segfaults on a smaller input file
12:55:03 <djahandarie> I just want to see auto-vectorization get into GHC somehow. Somehow.
12:55:25 <Peaker> I want everyone to adopt a single Vector already!
12:55:28 <Peaker> this is ridiculous
12:55:51 <monochrom> that's like saying everyone should adopt a single monad transformer lib. :)
12:57:40 * hackagebot web-encodings 0.3.0.6 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.6 (MichaelSnoyman)
12:58:42 * hackagebot persistent 0.2.4.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.2.4.1 (MichaelSnoyman)
12:59:10 <monochrom> on this christmas day, the snowman strikes again. or the snoyman
13:00:51 <robinhoode> Are all monads with side effects build on top of IO?
13:01:32 <edwardk> robinhoode: 'kinda' - they under the hood tend to all look like ST s.
13:01:54 <robinhoode> Okay.. is IO built from ST somehow?
13:02:00 <edwardk> yeah, IO is just ST RealWorld
13:02:10 <robinhoode> Gotcha.. 
13:02:12 <edwardk> (modulo some syntactic noise)
13:03:44 <edwardk> basically IO/STM/ST s all look like State# s > (# State# s, a #) for some choice of s
13:03:51 <edwardk> er ->
13:04:33 <dark> any (ST something) can be run? but the sole guy that can run anything is main, and it has type IO a
13:04:39 <robinhoode> My motivation is that, if I grab any library of the shelf, I *should* be able to perform any monadic action *inside* that library's monads..
13:05:07 <edwardk> ?
13:05:14 <robinhoode> But the only way to get back to main :: IO () is to join all of the IO actions back together.. I think..
13:05:25 <edwardk> in general its not always safe to do so
13:05:42 <robinhoode> Okay..
13:05:49 <Phyx-> djahandarie: It seems that it only does it on a big input file, my guess is it's something in fgl triggering the segfault, but I can't really give the input file atm. If i find something else that segfaults i'll let you know
13:05:54 <edwardk> for instance while STM is implemented mechanically like IO, you shouldn't perform arbitrary IO actions inside of the STM monad without a good reason
13:06:04 <cozachk> do as much as you can outside of the IO monad 
13:06:08 <edwardk> plus some will crash you (like invoking another STM action)
13:06:08 <MrHOLO> dark, I understand that. It would be great to have both you know. Closer to machine and better semantics.
13:06:45 <edwardk> robinhoode: yes, ultimately haskell code is structured so that you chain together all of the IO actions at the top level
13:07:05 <dark> MrHOLO, take a look at bitC. not quite finished, but they aim exactly that
13:07:17 <MrHOLO> Okay.
13:08:12 <edwardk> dark: there is a runST which will take any ST action that is polymorphic in its 'world', because no side-effects from that pure computation are visible
13:08:27 <dark> oh, found out the bitc kind-of claim about performance: "As a litmus test, it is possible to write a MPEG decoder or SHA-1 hash algorithm in BitC that is fully safe, but performs competatively with the C implementation. Today, that can't be done in SML, O'Caml, or Haskell."
13:08:29 <edwardk> ST RealWorld isn't parametrically polymorphic in the choice of world, so runST can't be used to run IO actions
13:08:43 <edwardk> BitC is a bit oversold ;)
13:09:11 <edwardk> shap went off to work for microsoft and only recently got back to it when they realized they weren't made for one another
13:09:21 <dark> uhm. yeah
13:09:27 <edwardk> so despite the length of time the project has been around, it hasn't made much progress in a year or two
13:09:38 <MrHOLO> dark, any idea how Haskell was made?
13:10:11 <dark> MrHOLO, i once read a paper about that. it was made for standardizing "functional, non-strict" languages
13:10:42 <MrHOLO> dark, could give me a lead?
13:11:16 <MrHOLO> dark, bitC is still in the making as it seems. I will keep track of the developments. 
13:11:16 <dark> they actually wanted something miranda-like, but the miranda guy didn't liked. so they went to design and came with this monad thing. maybe http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/ is the paper i'm talking about?
13:12:52 <dark> yes it is
13:14:19 <edwardk> more anal retentively they didn't realize how nicely monads worked for a while. they started with lazy request/response transformers, then went to cps then to monads
13:15:16 <dark> "Another potent ingredient was the possibility that all this would lead to a radically different non-von Neumann hardware architectures. Several serious projects were underway (or were geting underway) to build dataflow and graph reduction machines of various sorts", would like to see this as viable alternatives today, for some reason
13:25:49 <MrHOLO> And yeah to all
13:25:59 <MrHOLO> Oh crap, Christmas is over
13:26:31 <MrHOLO> But to some who are still on the 25th day of December, Merry Christmas
13:27:32 <Oejet> MrHOLO: Merry Christmas to you too.
13:29:44 <hgolden> MrHOLO: a second chance: http://en.wikipedia.org/wiki/Christmas#Orthodox_Christian_Churches
13:31:24 <MrHOLO> Never knew, hgolden
13:33:26 <dark> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html this says so much.. i had no commitment, yeah
13:38:10 <hgolden> dark: i hope my wife never sees Bone's post!
13:40:43 <unkanon> dark: that's a funny post
13:41:02 <dark> also this follow-up http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044106.html - so true
13:41:20 <dark> "Djinn generates Haskell code from a type declaration, using a decision procedure from intuitionistic propositional calculus." o.o lambdabot runs djinn right?
13:41:33 <djahandarie> Yes
13:42:02 <monochrom> @djinn a->a
13:42:02 <lambdabot> f a = a
13:42:17 <djahandarie> @djinn a -> (a -> Ans) -> Ans
13:42:17 <lambdabot> Error: Undefined type Ans
13:42:33 <monochrom> use a type variable
13:42:38 <Phyx-> "Djinn" any relation to Golden Sun?
13:43:09 <djahandarie> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
13:43:10 <lambdabot> f a b =
13:43:10 <lambdabot>     case a of
13:43:10 <lambdabot>     Nothing -> Nothing
13:43:10 <lambdabot>     Just c -> b c
13:43:51 <djahandarie> @djinn ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
13:43:52 <lambdabot> f a = a (\ b -> Left (\ c -> a (\ _ -> Right (\ d -> b (c, d)))))
13:44:14 <djahandarie> @djinn ((Either (a -> f) (b -> f) -> (a, b) -> f) -> f) -> f
13:44:14 <lambdabot> f a =
13:44:14 <lambdabot>     a (\ b ->
13:44:15 <lambdabot>        case b of
13:44:15 <lambdabot>        Left c -> \ (d, _) -> c d
13:44:15 <lambdabot>        Right e -> \ (_, f) -> e f)
13:45:01 <dark> would like to do something with logic
14:30:50 <navaati> hi
14:35:28 <lelf> hey
14:35:35 <sipa1024> hi
14:39:26 <Zao> Heh, seems like I forgot to add glasgow-haskell-users to my .muttrc.
14:39:33 <Zao> I've got a fair bit to catch up on now.
14:54:13 <Znudzon_> How i can get only picoseconds from time ? 
15:06:26 <applicative> Znudzon_ you mean from a TimeDiff?
15:22:13 <level1> hi guys
15:25:04 <level1> I'm reading "Real World Haskell".  I'm at the section on alegebraic data types.  It seems like types is pretty similar to classes in an object oriented programming langauge, but apparently Haskell is not object oriented.  Heres what I'm curious about: why don't the different components or fields of a type have names?
15:25:33 <level1> It seems like that could cause confusion.  Is that the case?  Is there a particular reason why the designers of Haskell made this choice?
15:26:31 <Ke> you can use the record syntax, where you can name the fields
15:26:56 <aristid> level1: you just need to read further :)
15:27:10 <level1> aristid, okay, Ill keep reading
15:27:21 <[jmc]> hello guys, please excuse the noobieness...
15:27:39 <[jmc]> I'm trying to package haskell for a linux distribution
15:28:49 <[jmc]> it seemed to work fine, but a haskell software complains about the lack of "mtl >=1.0 && <1.2", for example
15:29:25 <[jmc]> which should be included in the platform itself: is there a way to check manually in the filesystem for the installed & registered libraries in the platform?
15:29:51 <Zao> You can use ghc-* to query about packages.
15:29:57 <Zao> Assuming you work with GHC.
15:30:04 <applicative> ghc-pkg list for one.  it tells you the files its reading
15:30:04 <Zao> ghc-pkg, that is.
15:30:26 <applicative> ghc-pkg has several subordinate commands
15:31:40 <[jmc]> oh great :)
15:31:53 <[jmc]> thanks for helping, I'll do some more research
15:32:49 <applicative> [jmc] various distributions have fairly systematic approaches.  I'm not sure who is best to ask.
15:37:10 <applicative> [jmc] I don't know if anyone is awake in #arch-haskell or maybe #haskell-FreeBSD #fedora-haskell ; there are a few such places
15:38:22 <[jmc]> I don't know, my need is a little different here... in my case, it's me that's trying to create a package for the other users :)
15:38:43 <[jmc]> only, I didn't have GHC here, I installed it from the binary distribution on the website, then installed the platform
15:38:59 <[jmc]> but they seemed not to communicate well: but this is my problem, I guess
15:39:20 <[jmc]> so I'll dig more into it, I don't want to bother you or them about this. :)
15:41:22 <dark> [jmc], i like gentoo's approach: there is a script that generates an ebuild (a gentoo package) from a cabal file
15:41:46 <dark> and there is an overlay (kind of alternative repository) with such automatically generated ebuilds
15:42:01 <sshc> How can I make threadDelay more precice?
15:42:12 <[jmc]> dark, thanks for pointing that out! I'll go and see it now.
15:42:27 <dark> but 'gentoo platform' itself is kind of broken here, so people at #gentoo-haskell says i should not actually install the 'haskell platform' package
15:43:42 <arcatan> arch linux has a similar solution
15:44:04 <systemfault> haha
15:44:07 <arcatan> (don't know about their stance on platform)
15:48:36 <[jmc]> systemfault, are you everywhere? :P
15:48:40 <[jmc]> don't laugh at me.
15:51:20 <gwern> haha. that's gentoo alright
15:51:33 <gwern> man, I remember gentoo. it was a barrelful of monkeys
15:51:41 <gwern> or laughs. depending on what problem it was that day
15:52:02 <systemfault> [jmc]: :)
15:52:02 <Hunner> I haven't used gentoo in a long time, but supposedly it's kept up with the times. I should try it again=
15:52:27 <aristid> Hunner: "Life is too short..."
15:52:55 <Hunner> Compile once, deploy everywhere
15:53:23 <Hunner> I like arch, but imho it makes a poor server OS
15:54:06 <gwern> if I were running a server, I'm not sure I'd use any of the compile-based distros. maybe one of the BSDs if I didn't like linux, but not the linux ones
15:54:10 <sshc> Hunner: How so?
15:57:13 <Hunner> sshc: everything is bleeding edge, and bleeding often means bleeding. Also how do you manage software/services/configs? Most config management systems don't work on arch and I'm sure not just going to write a bunch of shell scripts to do it.
15:58:57 <Hunner> I don't know if gentoo can be packaged nicely or managed in a per-internal-release form that makes deploying and upgrading nice, but because of the flexibility and automatability of the build system I can imagine it'd play nicer
16:00:14 <Hunner> But this is why people like rhel/debian
16:01:17 <Hunner> But they also have "outdated" software packages and a cumbersome build/packaging system compared to arch/gentoo
16:01:59 <Hunner> ... this is probably offtopic. the arch and gentoo cabal packages are both nicely scripted to be automatically packaged :)
16:02:19 <gwern> gentoo also had a lot of buggy and outdated ebuilds when I used it
16:02:40 <gwern> Hunner: oh, arch is only as good as it is because dons is using it now. kind of like openbsd had good haskell support - while dons was using it...
16:03:43 <Znudzon> Hi any one can tell me how I can get picosecond from time ?
16:11:38 <Eelis> i read some blog posts from some months ago about a new garbage collector for GHC. is that in HEAD yet?
16:18:37 <[jmc]> thanks to everyone for the answers and the tips
16:18:39 <[jmc]> bye!
16:20:28 <duckinator> does haskell have any sort of fraction literals?
16:20:46 <duckinator> if not, anyone know of a language which does?
16:21:14 <Eelis> > 2%3
16:21:15 <lambdabot>   2 % 3
16:21:58 <duckinator> Eelis: do i need to import something for that? in ghci `2 % 3` says "Not in scope: `%'"
16:22:14 <Eelis> :t (%)
16:22:14 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
16:22:20 <Eelis> Data.Ratio
16:22:23 <Cale> duckinator: Data.Ratio
16:22:43 <duckinator> alright. thanks :)
16:24:39 <duckinator> ooh, the fractions auto-reduce. very nice...especially compared to Ruby's >.>
16:27:43 <ion> What do you mean by that? "4/6".to_r returns (2/3).
16:43:52 <aristid> duckinator: there is no way to construct a non-reduced fraction :)
16:44:07 <aristid> > 4%6
16:44:08 <lambdabot>   2 % 3
16:44:20 <aristid> @src (%)
16:44:20 <lambdabot> x % y = reduce (x * signum y) (abs y)
16:44:25 <aristid> :t reduce
16:44:25 <lambdabot> Not in scope: `reduce'
16:44:54 <systemfault> reduce??? in haskell?
16:45:28 <systemfault> Ah! nevermind :P
16:52:43 <augur> wee
16:53:09 <augur> i just got Computational Semantics with Functional Programming
16:53:10 <augur> :D
16:54:56 <duckinator> aristid: i noticed :P
17:01:49 <revenantphx> Out of curiosity, do haskellers say "point-free" just because they don't want to say "pointless"?
17:02:32 <sipa> i suppose
17:02:42 <aristid> what a pointless question
17:04:01 <Gracenotes> both come from math. you'll have to ask them mathees.
17:04:19 <revenantphx> Them mathees.
17:08:06 <dobblego> is there a formal definition of referential transparency that can also be used for teaching?
17:08:34 <systemfault> I'd check on wikipedia :P
17:08:37 <dobblego> http://projects.tmorris.net/public/what-does-fp-mean/artifacts/0.3/chunk-html/ar01s04.html <-- I often use something like this, but I also wonder if it is most appropriate
17:19:20 <Gracenotes> ...arbitrary?
17:19:59 <dobblego> what about arbitrary?
17:20:12 <copumpkin> coarbitrary!
17:20:23 <dobblego> coreferential-transparency!
17:22:03 <Gracenotes> is arbitrary a metasyntactic name?
17:22:09 <dobblego> yeah
17:22:14 <Gracenotes> ah
17:22:34 <dobblego> nothing to do with quickcheck
17:22:48 <dobblego> might change it to "anything"
17:23:03 <Gracenotes> or foo and bar, like the pros
17:23:09 <Gracenotes> that looks like a sufficient condition for ref. transparency at least
17:24:12 <Gracenotes> I suppose you could do the same thing calling function an arbitrary number of times... or passing arguments even...
17:24:35 <dobblego> OK ta, I'll just roll with it
17:26:16 <Gracenotes> the wikipedia definition seems nice of course
17:26:37 <Gracenotes> but you're trying to go at it from an imperative point of view
17:26:51 <dobblego> I might also give a counter-example
17:27:05 <Gracenotes> but you do get a stronger concept saying that applies to expressions, not just calls to functions
17:27:12 <Gracenotes> and a more abstract one
17:27:21 <dobblego> yeah
17:27:35 <dobblego> I actually gave that talk a while ago, but I'm trying to put it into writing
17:34:13 <Gracenotes> dobblego: I tried to do a mini what-is-FP thing within a what-is-Haskell talk that I gave once... not as many words in slides though.
17:34:44 <Gracenotes> I think I largely focused on expressions vs statements...
17:34:52 <Gracenotes> https://docs.google.com/viewer?a=v&pid=explorer&chrome=true&srcid=0B_a5MxwyB_zYOTIwOWU3OWUtZjEyYy00YjU1LWJlYmYtY2FiNDc0N2YxMDA4&hl=en
17:36:02 <revenantphx> I have a kind of odd arbitrary pattern for $ vs ( ) 
17:36:19 <dobblego> Gracenotes, thanks
17:36:22 <revenantphx> if it's for something that takes multiple arguments, I put them both in their own ( )
17:36:23 <Gracenotes> the sooner you tell us the sooner we can create a haskell-writing automaton to replace you
17:36:44 <revenantphx> i.e) coolHigherOrderFunc (\x -> x * 2) (\y -> y)
17:36:52 <revenantphx> Or when its a constructor.
17:37:00 <revenantphx> But when it's a regular function i dont...
17:37:06 <revenantphx> Is there some more standard practice in this regard?
17:37:57 <dobblego> revenantphx, in general I (and most people?) use $ however, there is also a tendency to overuse them in that the expression can be point-free
17:38:12 <revenantphx> I use $ in all cases except above.
17:38:38 <dobblego> above is (*2) id
17:38:52 <revenantphx> mm I do that too.
17:39:00 <revenantphx> I tend to put little functions like that in parens.
17:39:24 <revenantphx> map (*2) [1,2,3...]
17:41:18 <Gracenotes> you must, if a section it is
17:42:28 <revenantphx> It'd be fun if someone made a pyborg style haskell generator.. :\
17:42:45 <shachaf> revenantphx: You should try Caleskell-style $.
17:42:45 <revenantphx> Like some bot that analyzes existing code and then spews out random (and probably useless) functions.
17:42:53 <revenantphx> shachaf: Oh god what?
17:43:15 <shachaf> revenantphx: Cale likes it to be infixl instead of infixr.
17:43:24 <revenantphx> Explain?
17:43:47 <dobblego> to prevent f $ g $ x ?
17:43:59 <shachaf> a b $ c d $ e f = (((a b) (c d)) (e f))
17:44:19 <shachaf> dobblego: Yes, because taht can be expressed as f . g $ x.
17:44:34 <shachaf> So this allows further parenthesis-elimination.
17:44:34 <revenantphx> normally it'd be ( a b (c d (e f))) yes?
17:44:47 <shachaf> Yep.
17:45:11 <revenantphx> @quote Cale balls
17:45:14 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
17:45:25 <revenantphx> @quote shiny balls
17:45:25 <lambdabot> No quotes for this person. stty: unknown mode: doofus
17:45:29 <revenantphx> booh.
17:45:48 <revenantphx> Time to go bite the bullet and write that javascript :|
17:45:56 <shachaf> revenantphx: Javascript?
17:46:05 <revenantphx> Yeah, website stuff for a friend.
17:46:30 * shachaf wants monad syntax in Javascript.
17:46:48 <aristid> shachaf: write a javascript preprocessor :P
17:46:59 <shachaf> aristid: Some people have done it.
17:47:03 * dobblego wants type-checking in javascript
17:47:13 <dobblego> shachaf, oh?
17:47:15 <systemfault> Some day written a haskell interpreter in javascript :P
17:47:15 <shachaf> aristid: Though not as a general monad syntax.
17:47:21 <systemfault> s/day/guy
17:47:26 <dobblego> I noticed some Javascript parsers on hackage
17:47:41 <shachaf> dobblego: Well, things like the "defer" keyword proposal for CoffeeScript are pretty close, I seem to remember.
17:47:44 <dobblego> however, every single one I tried had a blocking bug, but the author fixed one of them
17:48:03 <revenantphx> :O
17:48:04 <shachaf> And there were a few others.
17:48:05 <revenantphx> HOLY SHIT.
17:48:11 <dobblego> is coffeescript a reasonable answer to javascript?
17:48:16 <revenantphx> I was going to put my stocking away, and ANOTHER Toblerone fell out of it.
17:48:20 <revenantphx> Awesome.
17:48:39 * shachaf doesn't get why Javascript people have no problem writing their code in explicit CPS.
17:48:51 <aristid> revenantphx: yay for chocolate
17:49:16 <systemfault> CPS?
17:49:18 <medfly`> CPS?
17:49:31 <revenantphx> if I had to be on an island forever, and I had to choose three things to take with me (other than food/water/etc)
17:49:42 <shachaf> Continuation-passing style.
17:49:44 <revenantphx> I'd choose infinite internet, my laptop, and chocolaste.
17:49:55 <revenantphx> shachaf: example?
17:50:00 <shachaf> revenantphx: Infinite Internet? You can get that?!
17:50:01 <revenantphx> I'm not JS person by any means.
17:50:05 <revenantphx> shachaf: Actually, yes.
17:50:06 <systemfault> shachaf: Chaining?
17:50:13 <medfly`> I'd get a friggin oil rig. global warming, maybe it's true.
17:50:15 <revenantphx> I have the utility line for a dial up company in Illinois actually.
17:50:17 <revenantphx> And a user/pass.
17:50:19 <shachaf> revenantphx: Of what?
17:50:33 <revenantphx> So I can actually get free internet wherever there's a phone jack.
17:50:59 <medfly`> don't you pay for the call in dialup? :/
17:51:06 <revenantphx> Yes >_>
17:51:13 <revenantphx> Which is why I don't use it on my own phone line.
17:51:13 <medfly`> <_<
17:51:24 <revenantphx> I rarely if ever use it anyhow.
17:51:26 <medfly`> I don't waste other people's resources even if I can...
17:51:52 <revenantphx> I've used it twice in the last two years.
17:51:57 <revenantphx> Both times at a hotel.
17:52:05 <medfly`> those damned hotels :P
17:52:25 * shachaf >> return ()
17:52:48 <revenantphx> > return "Shachaf"
17:52:49 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
17:52:49 <lambdabot>    arising from a use ...
17:52:59 <revenantphx> shachaf: You are now in the IO monad. How will you escape?
17:53:15 <shachaf> revenantphx: Who brought IO into it?
17:53:15 <dobblego> @type \x -> x >> return () -- nothing to do with IO
17:53:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
17:53:27 <shachaf> Anyway, I really must go.
17:53:30 <revenantphx> true.
17:53:36 * shachaf detaches.
17:55:13 <bsmntbombdood> revenantphx: unsafePerformIO
17:55:25 <revenantphx> bsmntbombdood: thats what I was thinking of :)
17:55:36 <revenantphx> but then I was going to do it again, and create a clone shachaf >:D
17:56:08 <bsmntbombdood> revenantphx: sounds dangerous
17:56:36 <drbean> augur: It looks like the downloadable PDF of the book at http://www.computational-semantics.eu/ has gone.
17:56:57 <bsmntbombdood> oh, is unsafePerformIO in the haskell standard or is it an extension?
17:58:06 <revenantphx> doesn't seem to be in the report :\?
17:58:41 <revenantphx> rofl
17:58:44 <revenantphx> "Rule of thumb: If your name isn't Simon*, you shouldn't use unsafePerformIO."
17:59:54 <bsmntbombdood> is  there another besides peyton jones?
17:59:58 <dobblego> Marlow
18:00:49 <revenantphx> I've heard like three I think.
18:01:16 <revenantphx> hey guys, should I go into #javascript and ask what the best json parser to use is?
18:01:41 <systemfault> There's none for haskell?
18:01:51 <systemfault> I mean, even RWH shows how to write one.
18:02:04 <revenantphx> No no, I'm just writing javascript for someone.
18:02:11 <revenantphx> Hm, a parsec JSON interpreter would be fun :)
18:02:15 <revenantphx> As a small project.
18:02:17 <bsmntbombdood> that's unfortunate
18:02:21 <revenantphx> Yeah :\
18:02:26 <dobblego> there are already three on hackage
18:02:34 <dobblego> I wrote a combinator library that operates on all of them
18:03:22 <systemfault> revenantphx: You could simply go to json.org
18:03:30 <systemfault> There's probably a few for haskell
18:03:30 <revenantphx> >_>
18:03:32 <bsmntbombdood> parsing json is pretty easy in any language actually
18:03:41 <revenantphx> You guys are missing the point.
18:03:53 <systemfault> Seems it's the case..
18:04:26 <bsmntbombdood> json.org is awesome
18:04:43 <bsmntbombdood> had an argument about whether single-quotes where allowed, settled that in a few seconds flats
18:05:34 <revenantphx> json.org is no nonsense ._.
18:05:43 <revenantphx> "HERE IS THE SYNTAX TREE. YOU'RE WECOME"
18:06:03 <bsmntbombdood> big-ass railroad diagrams
18:06:13 <revenantphx> ...lol
18:06:18 <revenantphx> solidus/reverse solidus
18:06:50 <bsmntbombdood> i like how unicode defines the solidus backwards
18:06:54 <BMeph> reverse solidus\solidus
18:07:21 <BMeph> solidus maximus flavius
18:13:16 <bsmntbombdood> in english, solidus:  , slash: /
18:13:49 <bsmntbombdood> but in unicode, FRACTION SLASH: , SOLIDUS: /
18:35:08 <Bynbo7> revenantphx: you should totally use this, compile it using Emscripten so you can use it in your JS: http://fara.cs.uni-potsdam.de/~jsg/json_parser/JSON_parser.c
18:56:29 * hackagebot secure-sockets 1.2.0 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.0 (DavidAnderson)
19:08:53 <augur> drbean: yes, this is true.
19:09:09 <ManateeLazyCat> Looks GHC can't load same package twice even package have different ABI hash.
19:09:12 <augur> drbean: but i got a hardcopy ;)
19:17:27 <ManateeLazyCat> Hmm, this trick is not good http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/18742/focus=18749 
19:22:46 <Darkone> Huh
19:23:18 <Darkone> sum [x | x <- [3,6..], x < 1000] doesn't seem to work. I am confuzzled
19:24:15 <ManateeLazyCat> > sum [x | x <- [3,6..999]]
19:24:16 <lambdabot>   166833
19:24:22 <Darkone> Same thing
19:24:34 <Darkone> But why? Doesn't the x < 1000 cut it off at 999?
19:24:37 <hpc> > sum [x | x <- [3,6..], x < 1000]
19:24:38 <ManateeLazyCat> > sum [3,6..999]
19:24:39 <lambdabot>   166833
19:24:40 <lambdabot>   mueval-core: Time limit exceeded
19:24:50 <hpc> wtf
19:24:58 <aristid> Darkone: no, it just makes sure there are no additional list elements, but there's no list end to be found
19:25:10 <aristid> > [x | x <- [3,6..], x < 10]
19:25:14 <lambdabot>   mueval-core: Time limit exceeded
19:25:19 <aristid> > [x | x <- [3,6..], x < 10]
19:25:23 <lambdabot>   mueval-core: Time limit exceeded
19:25:23 <kmc> Darkone, it's not smart enough to know that, once x exceeds 1000, it will never again be below 1000
19:25:28 <ManateeLazyCat> > sum [x | x < 1000, x <- [3,6..]]
19:25:28 <lambdabot>   0
19:25:42 <Darkone> Ahh
19:25:47 <kmc> Darkone, that's just sugar for:  sum (filter (<1000) [3,6..])
19:25:47 <aristid> ManateeLazyCat: oO recursive?
19:25:51 <kmc> in fact i'd argue it's anti-sugar
19:25:53 <kmc> in this case
19:25:58 <kmc> why name 'x' when you don't have to
19:26:12 <ManateeLazyCat> > sum [x | x <- [3,6..y], y < 1000] 
19:26:13 <lambdabot>   *Exception: not a number
19:26:26 <Darkone> sum.takewhile (<1000) $ [3,6..] I guess
19:26:45 <kmc> yeah, takeWhile is the substitute for filter which gives up after the first "False" element
19:26:55 <Darkone> Was part of something larger, which I , oh, nope, nevermind, remembered
19:27:20 <ManateeLazyCat> Damn, GHC discard ABI hash, just care PackageID
19:29:22 <Darkone> Sum of all multiples of 3 and 5 that are less than 1000
19:29:56 <Darkone> There's got to be a pretty way to do that, other than adding two sums or something equally fugly.
19:30:19 <pastorn> Darkone: tried with list comprehensions?
19:30:23 <ManateeLazyCat> But just reload Module is problem, if some import module exist in different packages, we need handle depend problem myself...
19:31:13 <ManateeLazyCat> kmc: Any idea about "ghc load same package twice" ?
19:33:47 <ManateeLazyCat> My current library can dynamic-linking different *install* package, but it's painful that we need install *new* version in cabal once touch configure file.
19:38:37 <robinhoode> Has anyone written a serious secure server in Haskell before? It looks as though Network.TLS is still in development, and Snap only started offering SSL a week ago.
19:39:34 <bsmntbombdood> is snap any good?
19:40:23 <robinhoode> I dunno.. But it's got a fair amount of marketing behind it.. 
20:01:43 <danderson> I wish there were a list of useful type classes that new types might want to implement, beyond the Prelude classes.
20:02:03 * danderson just discovered NFData, which feels like a very useful instance to define for most data types
20:03:05 <pastorn> danderson: typeclassopedia
20:03:07 <pastorn> ?
20:03:24 <pastorn> haven't read it myself, but i'm guessing there's a lot in it...
20:03:49 <danderson> well Typeclassopedia is a great work, but it's more about explaining those classes that are initially somewhat confusing
20:03:51 <kmc> typeclassopedia focuses on a particular sort of type classes
20:04:03 <danderson> I was thinking of a more general list
20:04:07 <kmc> the "control" classes like Functor, Applicative, Monad, Arrow
20:04:27 <monochrom> Eq, Ord, Show, Read, NFData, Typeable, Data, Foldable, Traversible...
20:04:37 <danderson> right, what monochrom said.
20:04:39 <Gracenotes> in some apps Binary are important
20:04:53 <Gracenotes> ..or whichever library you use
20:05:09 <kmc> NFData can be useful but i'd argue that using it is usually a sign of Doing It Wrong
20:05:19 <danderson> I'm not thinking of anything terribly fancy, just a "Can your type be iterated over? Consider Traversable"
20:05:32 <kmc> traversing a big structure to evaluate it will take time
20:05:46 <kmc> and it's easy to end up using deepseq in a context where most of that effort is wasted
20:05:48 <pastorn> Gracenotes: shouldn't Binary be derivable for any datatypes not containing functions?
20:05:57 <kmc> with a little more thought, one can add WHNF-strictness at the right places to achieve the same result
20:06:03 <Gracenotes> pastorn: should be.
20:06:06 <danderson> kmc: in my case, it's to use Control.Concurrent.MVar.Strict
20:06:07 <kmc> GHC does not have support for deriving Binary
20:06:09 <Gracenotes> Functor is a good one for arbitrary data types. as well as Monoid.
20:06:21 <Gracenotes> there are murky ways to extend it
20:06:23 <kmc> danderson, ah, it's unfortunate that the library will insist on traversing your structure
20:06:34 <pastorn> maybe with some template haskell magic?
20:06:38 <kmc> what if i want to put a huge syntax tree into a Strict MVar?
20:06:38 <Gracenotes> well, neither of them good for arbitrary data types, but for those with structure to support it..
20:06:51 <kmc> what if i already know it's evaluated
20:06:58 <Gracenotes> yes, there are TH derivings scattered throughout libraries
20:07:01 <danderson> kmc: well, if you do that, you're doing it wrong, obviously.
20:07:03 <kmc> if the library forces to WHNF, the user can make it force to NF.  but not the other way around.
20:07:30 <kmc> ndm's "derive" package can derive Binary
20:07:33 <danderson> I'm keeping a small map in the MVar, seems like a no-brainer to keep it NF
20:07:35 <kmc> and is awesome and magical
20:07:59 <danderson> then again, could be premature optimization. It just doesn't feel like a place where laziness has any benefit.
20:08:18 <kmc> danderson, it's not about the benefit of laziness. it's about the cost of traversing that structure over and over
20:08:34 <Gracenotes> if it's a concern with memory leaks...
20:08:44 <danderson> true.
20:09:21 <danderson> well, glad I ranted. At least the realization that I was doing it wrong came out of it :)
20:10:15 <danderson> also, whoa derive.
20:10:29 <danderson> I think its list of derivations may be the list I was hoping for
20:10:36 <danderson> and it's scary that it can do what it does.
20:10:37 <Gracenotes> I mean, with not forcing strictness, you might get several threads waiting on a single map to rebalance itself
20:11:14 <Gracenotes> which is not necessarily a bad thing... the more threads graph-reducing the merrier
20:11:28 <danderson> it's not a terribly critical section, if a thread has to wait a couple hundred ms, tough.
20:13:39 <ddarius> kmc: newtype Don'tForce a = Don'tForce { unDon'tForce :: a }; instance NFData (Don'tForce a) where rnf = r0
20:21:14 <Boxo> :t \x -> const x >=> id $ ()
20:21:14 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
20:22:22 <parcs> :t id >=> id
20:22:22 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
20:23:13 <Boxo> :t (\f x -> const x >=> return . f $ ())
20:23:13 <lambdabot> forall b b1 (m :: * -> *). (Monad m) => (b -> b1) -> m b -> m b1
20:24:25 <parcs> @type (return .) >=> id
20:24:26 <lambdabot> forall b a. (a -> b) -> a -> b
20:29:52 <danderson> yay, I made my haskell program segfault!
20:29:59 * danderson shakes fist at FFI
20:47:21 <BuddingProgramme> Hello, I have a quick question, I am trying the following simple function to show a list of numbers
20:47:23 <BuddingProgramme> let printNums n = [putStrLn (show x) | x <- [1..n]]
20:47:39 <ddarius> @src print
20:47:39 <lambdabot> print x = putStrLn (show x)
20:47:50 <BuddingProgramme> but I am getting an error message: No instance for (Show (IO ()))
20:48:37 <BuddingProgramme> Even when I try print x 
20:48:38 <ddarius> All you are doing is making a list of actions that, when executed, would display a number.  You are then trying to show that list.
20:48:59 <BuddingProgramme> Yes, I am trying to show that list
20:49:15 <ddarius> Of course, it does the same thing with print.  It is defined to be exactly what you had before.
20:49:20 <BuddingProgramme> I also tried let printNums n = map putStrLn [(show x) | x <- [1..n]] with same result
20:49:30 <djahandarie> There is a difference between [IO a] and IO [a]
20:49:52 <ddarius> That's because [f x | x <- xs] <=> map f xs and map f . map g <=> map (f . g)
20:50:01 <ddarius> So again, those statements are equivalent.
20:50:24 <ddarius> BuddingProgramme: At any rate, read my first sentence more closely.  You don't want to be displaying that list.
20:50:49 <BuddingProgramme> ok, so how can I fix my function to do what I want(displaying the list)
20:51:12 <djahandarie> BuddingProgramme, you want to display a list of numbers, not a list of actions.
20:51:26 <BuddingProgramme> yes, I know that
20:51:50 <djahandarie> :t sequence
20:51:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:55:35 <byorgey> BuddingProgramme: first, turn the list into a String
20:55:45 <byorgey> then use putStrLn to show that String
20:56:17 <djahandarie> That being the better way to do it. :) Move IO to the outside of your program rather than trying to compose together small IOs.
20:57:03 <byorgey> BuddingProgramme: you may find the "unlines" function useful.
20:57:21 <byorgey> > unlines ["hey", "there", "BuddingProgramme"]
20:57:22 <lambdabot>   "hey\nthere\nBuddingProgramme\n"
21:01:14 <phr0zen> woot up
21:02:31 <BuddingProgramme> Thanks guys for the help
21:03:02 <applicative> @elite frozen
21:03:02 <lambdabot> FROsEn
21:03:04 <applicative> @elite frozen
21:03:04 <lambdabot> fros3N
21:03:07 <applicative> @elite frozen
21:03:07 <lambdabot> FrOzen
21:03:16 <systemfault> Haha
21:03:21 <djahandarie> @. elite nixon
21:03:22 <lambdabot> THE Pr3Sid3NCy |-|A$ /\/\aNy PROBL3m5, 8u7 8orEdO/\/\ iz0rz +|-|3 1E4z7 oF T|-|3M.
21:03:28 <systemfault> applicative has been pwn3d
21:03:33 * djahandarie pretends to be kmc
21:03:38 <kmc> :D
21:03:43 <kmc> @. elite ghc
21:03:43 <lambdabot> 9HC $AYs: kiND 5IGNATUR3 on DaTA 7YPe decl4R4+I0n |-|as n0n-* r3TuRN xIND
21:04:44 <djahandarie> @. elite quote OlegFacts
21:04:44 <lambdabot> O13gfAc7z 54Y$: O1eg zo|\/ez0rz Np-haRd PRob|EMS iN N |o9 n +iME... in +he TYpe SYz7E/\/\
21:05:08 <djahandarie> O13g is one mad h4x0r.
21:05:25 <Jonno_FTW> are there any significant changes from the haskell 98 standard to the 2010?
21:06:39 <djahandarie> Jonno_FTW, I wouldn't really say so. Things you probably want to be aware about though, yeah.
21:06:54 <Jonno_FTW> what would I want to be aware of?
21:06:55 <djahandarie> http://hackage.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&state=accepted&milestone=Haskell+2010&order=priority
21:09:04 <kmc> Jonno_FTW, http://www.haskell.org/pipermail/haskell/2009-November/021750.html
21:09:47 <Jonno_FTW> thanks
21:52:04 <ddarius> Yellowstone's site uses <blink>, but it is perhaps acceptable because the inner text is "Do not approach bears!"
21:59:40 <co_dh> Merry Christmas . 
22:00:53 <co_dh> I don't understand the coproduct of monoids much, can somebody give me an example ? for example, what' the coproduct of monoid ( N  , + , 0) , and ( {a,b,c}, ++, " " )  ( strings generated by "a","b", "c")
22:06:03 <co_dh> got it from wikipedia . 
22:09:49 <kmc> co_dh, i think it's like the free product on groups: http://en.wikipedia.org/wiki/Free_product
22:10:08 <co_dh> kmc: thanks. I got it :)
22:10:12 <kmc> ah cool
22:10:34 <kmc> so it's a word which alternates between non-zero integers and non-empty abc-words?
22:14:59 <co_dh> yes, if I really got it :)
22:21:20 <ddarius> Incidentally, each of your examples are free monoids and since the free monoid construction is a left adjoint it preserves coproducts.  Thus the free monoid on a coproduct is isomorphic to the coproduct of free monoids.  In your particular case it would be something like, data ABC = A | B | C; type Coproduct = [Maybe ABC].  And then you have to define the operations.
22:28:16 <revenantphx> late night hasssskelll
22:28:19 <revenantphx> partyyyy whooo
22:28:26 <revenantphx> chocolate powered coding gooo...
22:28:31 <revenantphx> sleep deprivation wheee.
22:29:42 <Gracenotes> gah. making tea, then doing computer stuff with mug nearby, then tea getting neglected and cold. why.
22:30:41 <Gracenotes> perfectly good tea too
22:36:03 <revenantphx> I hate when that happens.
22:39:00 <jmcarthur> every morning i make a cup of coffee. it's usually the only cup of coffee i make all day. half the time i set it on my desk thinking how good is smells and then start coding and forget the coffee until it's cold
22:39:07 <jmcarthur> *it smells
22:40:46 <ManateeLazyCat> jmcarthur: Me too, i most time in smelling. :)
22:41:03 <ManateeLazyCat> Haha, i suppose just me smell it. :)
22:45:06 <ddarius> Just lay out the bag of beans and don't bother brewing it.
22:57:28 <lars9> @instances Functor
22:57:29 <lambdabot> IO, Maybe, []
23:39:50 <bsmntbombdood> why are monads functors?
23:40:29 <djahandarie> Are you looking for a category theory answer, or...?
23:40:58 <djahandarie> In Haskell, they are technically actually not due to a library flaw.
23:41:23 <djahandarie> But you can write a Functor instance for any Monad instance
23:41:52 <bsmntbombdood> library flaw?
23:42:19 <djahandarie> fmap f m   <=>   m >>= (\x -> return (f x))
23:42:49 <djahandarie> bsmntbombdood, yes, when the typeclasses were originally written it was just not done. And now it's too late to fix.
23:42:57 <ddarius> Categorically monads are functors by definition.
23:44:29 <danderson> FFFUUUUUUUUU mtl.
23:44:40 <djahandarie> A slightly nicer hierarchy would be    class Functor f; class Functor f => Applicative f; class Applicative f => Monad f;
23:44:45 <danderson> 2 hours wasted because of mtl1 vs. mtl2 borkage
23:45:10 <djahandarie> Could throw in Pointed too if you wanted
23:45:12 <djahandarie> And other stuff
23:45:24 <danderson> and, apparently, I can't use mtl2 until every single one of my dependencies uses it
23:45:29 <danderson> which will never happen. Great.
23:45:30 <bsmntbombdood> fmap id x = x, so m >>= return <=> m?
23:45:32 <bsmntbombdood> always?
23:48:11 <ddarius> Neither of those laws are enforced, and the former does not imply the latter.
23:48:37 <bsmntbombdood> what good is a law if it's not enforced?
23:49:05 <djahandarie> It's not enforced by the compiler. It should be enforced by the programmer.
23:51:32 <bsmntbombdood> so assuming the laws are followed, m >>= return <=> m?
23:51:46 <ddarius> bsmntbombdood: That is one of the laws.
23:52:35 <bsmntbombdood> oh
23:52:45 <bsmntbombdood> well that makes sense then
23:59:53 * ddarius is constantly frustrated by the lack of memory layout control in Haskell.
