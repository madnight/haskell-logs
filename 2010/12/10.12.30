00:00:49 * BMeph prefers C <--g-- B <--f-- A
00:01:38 <j-invariant> BMeph: now I don't know whether the notation is backwards or the diagrams..
00:05:18 <jekor> Is there a way to use haskell-src-exts (parseExp) with template-haskell, or a way to get haskell-src-meta to compile on ghc 7?
00:09:04 <jekor> I mean, not parsing template haskell code, but rather parsing Haskell expressions and then using returnQ.
00:21:43 <JuanDaugherty> categorist, should such a class exist, would be the "good guys" here
00:22:00 <JuanDaugherty> *categorists
00:39:14 <tekknolagi> WHOAH
00:39:16 <tekknolagi> HASKELL
00:39:29 <j-invariant> lol
00:44:22 <ion> tekknolagi: A double combinator all the way across the sky?
00:46:58 <banisterfiend> ion: what are you wearing
00:47:09 <ion> banisterfiend: My robe and wizard hat.
00:47:48 * banisterfiend goes back to #c
00:59:36 <acx0> if you reflect a matrix horizontally, you reflect about the x-axis, right?
01:03:54 <banisterfiend> acx0: no
01:04:11 <banisterfiend> acx0: of course it's about the y axis
01:04:21 <banisterfiend> acx0: i thought haskell programmers were meant to be good at math? :P
01:04:40 <acx0> to be honest I don't know haskell - only came here because of the number of users
01:04:54 <banisterfiend> hehe, i dont know haskell either ;)
01:05:09 <acx0> for some reason I just assumed that reflecting horizinally meant reflecting about the horizon, i.e. x-axis
01:05:33 <acx0> s/horizinally/horizontally/
01:16:51 * hackagebot bindings-audiofile 0.1.0.1 - Low level bindings to audiofile  http://hackage.haskell.org/package/bindings-audiofile-0.1.0.1 (MasatakeDaimon)
01:18:16 <Cin> Is it possible to disable the 'loading X ...' messages when TemplateHaskell is in use?
01:19:13 <jeltsch> Cin: What would this be good for?
01:25:53 * hackagebot bindings-EsounD 0.1.0.1 - Low level bindings to EsounD (ESD; Enlightened Sound Daemon)  http://hackage.haskell.org/package/bindings-EsounD-0.1.0.1 (MasatakeDaimon)
01:27:25 <Cin> Is it possible to disable the 'loading X ...' messages?
01:28:06 <Cin> (I actually rarely care to see what's being loaded.)
01:28:20 <ivanm> people still use ESD? :o
01:28:23 <ivanm> Cin: in ghci?
01:30:12 <Cin> ivanm: Either GHC/GHCi seeing as GHCi tends to support GHC's options.
01:30:23 <ivanm> Cin: I've only ever seen that in ghci
01:30:32 <ivanm> and it just happens the first time a library is loaded for that session
01:31:32 <Cin> ivanm: It also happens in GHC if you use TemplateHaskell.
01:31:42 <ivanm> well, TH uses ghci IIRC
01:31:45 <Cin> Regardless of how many times it happens, I don't care to see it.
01:31:48 <ivanm> doesn't appear to a configurable option anyway
01:40:57 <Jafet> Cin: grep -v
01:42:22 <qfr> Cin hmm well you could just write add a patch for that, no?
01:42:28 <qfr> -write
01:43:15 <j-invariant> is category theory practical?
01:44:22 <c_wraith> occasionally, much to the great dismay of the theorists
01:44:32 <j-invariant> hah
01:45:13 <Veinor> category theory made me realize that graphs are just categories that don't bother being transitive or reflexive
01:45:28 <Veinor> there's a very nice way to prove this diagrammatically
01:45:50 <j-invariant> graphs are transitive arean't they?
01:46:00 <Veinor> existence of edges isn't.
01:46:10 <j-invariant> oh yeah I see
01:55:26 <banisterfiend> is there a book on haskell with a more theoretical than practical approach? i hear 'real world haskell' is n't so heavy on theory/concepts
01:55:31 <banisterfiend> (dead tree book)
01:56:59 <vegai> theoretical in what way?
01:57:52 <vegai> banisterfiend: http://learnyouahaskell.com/chapters would you consider this too practical?
01:58:00 <c_wraith> Haskell's just a programming language.  A bit different than most, but most CS theory still applies.  What are you looking for?
01:58:04 <banisterfiend> vegai: im not so interested in solving real world problems, i just want to learn some of the supposedly 'mind expanding' ideas in khaskell
01:58:16 <ivanm> banisterfiend: Haskell Road to Logic, Maths and PRogramming?
01:58:25 <ivanm> Haskell: Craft of Functional Programming?
01:58:34 <ivanm> Bird's book (whatever it's called)?
01:58:43 <vegai> the Multimedia book might work for ya also
01:58:55 <vegai> http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089
01:58:55 <ivanm> vegai: I figured SoE would be too practical for him
01:58:57 <banisterfiend> c_wraith: well, i dont knwo much about the advantages/disadvantages on 'pure functions' or much about the lambda calculus, or about the advantages of 'lazy evaluation' etc
01:59:00 <vegai> oh
01:59:08 <banisterfiend> c_wraith: or monads, and o on
01:59:18 <banisterfiend> so on*
01:59:36 <c_wraith> banisterfiend, I think that at the moment, the best way to learn those things is experience with them.
01:59:42 <vegai> haskell books won't talk about disadvantages of either of those :)
01:59:44 <ivanm> banisterfiend: very simplistically, purity means you _know_ that it won't do evil stuff (like launch nuclear missiles)
01:59:58 <c_wraith> I think it's probably possible to write a book on those topics, but I doubt it's been written
02:00:01 <ivanm> and in practice usually means that the compiler can be more agressive with its optimisations
02:00:28 <banisterfiend> c_wraith: well supposedly SICP is about this a bit? but about scheme rather than haskell
02:00:34 <ivanm> laziness means you can have "infinite" data structures, or a function that uses its own output as part of its input, etc.
02:00:49 <ivanm> but it does make it harder to reason about runtime, execution, etc.
02:00:54 <ivanm> and can result in space leaks
02:01:03 <ivanm> banisterfiend: there isn't really a SICP for Haskell
02:01:20 <c_wraith> banisterfiend, I'd just recommend *using* Haskell for a while.  Use it for small one-off tasks you have.  Ask all the questions here you want.  Toy with random features...  It all starts coming together.
02:01:26 <qfr> SICP = ?
02:01:34 <ddarius> Laziness results in -different- space leaks than eagerness, not really more or less of them.
02:01:51 <ivanm> qfr: Structure and Interpretation of Computer Programs
02:01:55 <banisterfiend> c_wraith: ok, but i'd still like a book :) and 'real world haskell' isn't the right one... :/
02:01:56 <ivanm> famous book out of MIT
02:01:57 <ddarius> @where sicp
02:01:57 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
02:01:57 <lambdabot> classes/6.001/abelson-sussman-lectures/>
02:02:11 <qfr> Oh, I believe I saw some of those
02:02:14 <ivanm> uses Scheme more becaues it has small syntax, etc.
02:02:16 <qfr> Wasn't that Lisp stuff?
02:02:18 <ivanm> yup
02:02:20 <qfr> Ah, Scheme
02:02:42 <c_wraith> banisterfiend, it's true that it's not a book.  But I'm not sure that you can learn the things that make haskell different just by reading about them.
02:02:49 <ddarius> ivanm: And the authors were instrumental in the development of Scheme, and Haskell didn't exist at the time, though they do mention Miranda, and ...
02:03:28 <ivanm> ddarius: oh, were they? (instrumental to development of scheme)? :o
02:03:36 <c_wraith> I mean.  Look how many monad tutorials there are.  If reading a tutorial made you understand them...  There would be one.  Not eleventy billion :)
02:03:47 <banisterfiend> c_wraith: this one is meant to be good: http://www.cs.nott.ac.uk/~gmh/book.html
02:04:03 <ddarius> "Sussman and his former student, Guy L. Steele Jr., invented the Scheme programming language in 1975."  from Wikipedia
02:05:03 <c_wraith> Huh.  I hadn't heard of that book.  but if dcoutts recommends it...  :)
02:05:40 <dcoutts> @arr!
02:05:40 <lambdabot> Aye Aye Cap'n
02:07:11 <c_wraith> wow.  That new dcoutts-signal works really fast.
02:14:20 <augustss> howdy
02:14:57 <j-invariant> hi
02:15:20 <j-invariant> what does arrow category have to do with programming
02:19:02 <c_wraith> As I understand it, Hughes Arrows aren't exactly category theory arrows.
02:19:32 <c_wraith> Also, I've never bothered learning more about them than how to apply their combinators to functions.
02:20:09 <c_wraith> So I'm not the most useful one to ask.  I believe Hughes' paper where he introduces the concept is generally considered pretty good.
02:20:31 <augustss> And Ross Paterson's paper for the notation.
02:20:53 <j-invariant> Arrow category is comma category 1|1
02:23:25 <harlekin> ivanm, ping
02:26:11 <j-invariant> who cares that data types are initial algebras?
02:26:25 <j-invariant> in terms of programming haskell: What's the benefit?
02:26:36 <j-invariant> I can define foldr and maybe and stuff using pattern matching
02:29:08 <ddarius> j-invariant: What do sets or trees have to do with programming?
02:29:24 <lars9> im using parsec to parse a string, how to tell the length of consumed string when error happens?
02:33:36 <harlekin> @seen ivanm
02:33:36 <preflex>  ivanm was last seen on #haskell 30 minutes and 8 seconds ago, saying: ddarius: oh, were they? (instrumental to development of scheme)? :o
02:33:37 <lambdabot> Unknown command, try @list
02:34:28 <Jafet> @scene
02:34:28 <lambdabot> Unknown command, try @list
02:35:44 <ivanm> harlekin: pong
02:36:31 <harlekin> ivanm, hey. You are maintaining gentoo's ghc binary packages, aren't you?
02:37:08 <ivanm> kinda...
03:09:32 <j-invariant> if I have a whole bunch of symbols and a set of relations {a<b,b<d,c<a,..} is there a category theoretic way to describle the problem of mapping the symbols to numbers such that all the < relations hold?
03:14:32 <copton> j-invariant: if your set of symbols is countable just use the reverse mapping function.
03:14:50 <j-invariant> what is the reverse mapping function?
03:15:14 <copton> j-invariant: do you know what a countable set is?
03:15:18 <j-invariant> yes
03:15:53 <copton> j-invariant: the mapping function is the function from the natural numbers to your set
03:16:12 <j-invariant> so  1 -> a, 2 -> b, ...?
03:16:18 <copton> j-invariant: yes
03:16:33 <j-invariant> the inverse of that maps c to 3 and a to 1, so c<a is not satisfied
03:17:03 <copton> j-invariant: so use 1->c, 2->b, 3->a
03:17:25 <j-invariant> yeah
03:17:26 <ddarius> j-invariant: You haven't specified the relation to use on numbers, from the notation I assume you want to map it to the less-than relation?
03:17:33 <j-invariant> ddarius: yes
03:17:42 <j-invariant> I want to find a function from symbols to natural numbers (or rational numbers)
03:18:01 <copton> j-invariant: sort your symbols according to less-than and count them through
03:18:05 <ddarius> Then, if the < relation is completely unstructured, that is impossible.
03:18:18 <j-invariant> sometimes there is no solution, but sometimes there is one
03:18:23 <ddarius> As a trivial example a<a would never be able to map through.
03:18:25 <j-invariant> (or more)
03:19:09 <copton> ddarius: less-then should not be reflexive, should it?
03:19:31 <j-invariant> basically it's just topologiacl sort
03:19:45 <ddarius> copton: < is (also) the, as far as I can tell, completely arbitrary relation on symbols.
03:19:59 <copton> ddarius: oh, ic. Didn't know that.
03:20:05 <ddarius> copton: If there is more structure to it, j-invariant has not mentioned it.
03:20:05 <j-invariant> is it possible to build a category and specify this algorithm in terms of "decide whteher or not an initial foo object exists in there between X and Y"
03:20:16 <j-invariant> < is the less than relation on natural numbers
03:20:28 <ddarius> j-invariant: What is it -for symbols-?
03:20:54 <j-invariant> we start with some set like {a<b,c<a,d<a} and we want to find values (e.g.a=2,c=1,d=1) that satisfy it
03:21:06 <ddarius> j-invariant: Or rather what properties, if any, do you assume, for example irreflexive.
03:21:30 <j-invariant> the set {a<b,c<a,d<a}  can be anything at all, it might not be solvable
03:21:43 <ddarius> Okay.
03:22:06 <ddarius> Then you have a set S of symbols, and an arbitrary subset of SxS, i.e. a completely arbitrary relation.
03:22:38 <ivanm> @tell tomberek http://ivanmiljenovic.wordpress.com/2010/12/30/graphs-and-labels/
03:22:39 <lambdabot> Consider it noted.
03:23:37 <ddarius> Call that relation R : SxS -> 2 for clarity.  You want a function f : S -> N such that forall s1, s2. R(s1,s2) => f(s1)<f(s2) if it exists.
03:23:40 <j-invariant> One problem is that there (N,<) is not a category (but (N,<=) is)
03:23:51 <j-invariant> ddarius: yes exactly
03:24:17 <j-invariant> can it be thought of as a universal object in some category?
03:24:31 <ddarius> Since it is not unique, no.
03:24:40 <ddarius> Unless you quotient like mad.
03:25:47 <j-invariant> ddarius: oh in that case it could be a map into {1,2,3,4,5} (when you have 5 symbols) - adding the additional constraint that on two symbols are equal
03:26:29 <j-invariant> in terms of programming I thoguht that would make things harder (like an additional post processing step)(
03:27:19 <ddarius> The problem is that f neither necessarily exists nor is unique so it certainly isn't characterized by a universal property in the setup as you have described.
03:28:02 <j-invariant> I guess the universal object idea is wrong - but maybe there is another category theory approach to it
03:31:48 <j-invariant> how do you get past the problem of (N,<) not being a category?
03:32:04 <ddarius> j-invariant: By not caring as that is hardly relevant.
03:32:24 <ddarius> j-invariant: Category theory isn't done by trying to make bunches of things into categories.
03:32:38 <j-invariant> ddarius: could have fooled me :S
03:34:03 <ddarius> j-invariant: The vast majority of examples of categories are not some structure as a category.  Set, Top, Grp, Mon, CPO, Grph are not structures-as-categories, they are categories of structures.
03:35:00 <ddarius> There are several examples of structures that can be viewed as "special" categories, but usually this doesn't add too much.
03:35:05 <osfameron> aren't graphs quite problematic structures, purely functionally?
03:35:18 <ddarius> osfameron: Graphs are quite problematic structures period.
03:36:15 <osfameron> heh
03:37:15 <osfameron> but whereas trees have only a single route to a node (and therefore have nice log n update), isn't a graph rather inefficient under FP?
03:37:39 <ddarius> j-invariant: The typical approach to tackling some topic with category theory is to think about the things you want to talk about and how they relate to each other and build a category of those things with some (hopefully) natural arrows.  You then study what properties this category has, such as what (co)limits or what adjunctions exist in it.
03:38:26 <ddarius> osfameron: There are multiple ways to represent a graph.  I could represent a graph as a map from node ids to labels and then update would just be a map update.
03:38:50 <osfameron> ddarius: ah, yes.  that makes sense
03:39:23 * osfameron usually thinks about the structure the naive way with nodes physically pointing to other nodes
03:39:33 <ddarius> If you did indeed make a graph as a recursive, cyclic data structure, then in the general case changing anything anywhere would require rebuilding the entire graph.
03:39:51 <osfameron> yarr
03:39:59 <ivanm> osfameron: that mapping definition is the most common one people tend to use in haskell
03:40:12 * ivanm wonders how many people actually use Data.Graph
03:50:43 <ddarius> j-invariant: If you wanted to apply this methodology to your example, you might say that the objects are pairs of a set of "symbols" S and a binary relation on the set R.  The arrows are functions between the symbol sets that preserve the relations, e.g. f : (S,R) -> (S',R') is a function f : S -> S' such that forall s1, s2. R(s1,s2) => R'(f(s1),f(s2)).  You need to define a composition and identities which seem clear 
03:50:43 <ddarius> in this case, and check that the laws hold.
03:51:04 <ddarius> j-invariant: Your question then would simply be: what is Hom((S,R), (N,<))
03:58:54 <lars9> isn't try in parsec a kind of backtracing?
03:59:11 <Bynbo7> it is backtracking
03:59:38 <cads> ivan, I remember trying and it being too complicated
03:59:56 <cads> ivanm*
04:00:01 <ddarius> It isn't exactly backtracking, rather it enables a unbounded look ahead.
04:00:06 <lars9> i read some source code of regexp-parsec, it's converting a regexp pattern into a Parser monad
04:00:20 <j-invariant> ddarius: actually that works nicely because you can use composition to subdivide the problem
04:01:31 <ivanm> cads: what, Data.Graph?
04:01:35 <ivanm> I find it too limiting ;-)
04:01:48 <cads> ivanm, someone here said they'd implemented their own graph structure using maps instead of using data.graph because they said it was too slow
04:01:57 <j-invariant> I want to make a programming language
04:02:15 <ivanm> cads: well, that's what FGL is...
04:02:49 <cads> wait, that's right.. he said FGL was too slow, so he wrote his on graph doodad
04:03:06 <cads> I was using the code and scratching my head at the representation
04:03:36 <cads> except the funny thing is I learned to understand that, while FGL is still beyond me :P
04:03:51 <cads> I guess it was the code reading practice
04:05:01 <cads> ivanm, does FGL have the same limitations you see in data.graph?
04:05:31 <cads> and what are the limitations?
04:08:00 <ddarius> j-invariant: An alternative/complementary approach is simply to say that these functions are just a subset of all set function S -> N and this subset is defined by conditional equations.  The solution to a system of conditional equations is just a limit, so your problem is simply finding the limits of a certain class of diagrams.
04:10:30 <ivanm> cads: no labels
04:10:39 <ivanm> can't grow/shrink the graph (at least not nicely)
04:10:46 <ivanm> and not having the graph type be abstract
04:11:02 <ivanm> FGL does solve all those problems, albeit with problems all of its own (primarily due to age IMO though)
04:16:06 <lars9> @src seq
04:16:06 <lambdabot> Source not found. Do you think like you type?
04:22:12 * ddarius thinks he's going to start making up fancy sounding words like "peristalithic."
04:26:45 <Jafet> How much of gmp does ghc use?
04:27:31 <Zao> Jafet: Depends on if you use GMP or the non-silly replacement.
04:27:37 <Jafet> Eg. can I get stuff like n^2 = internal_mpz_square n
04:28:10 <Jafet> I've heard of a mythical integer-gmp package, but I can't find any documentation for it
04:28:43 <ddarius> GHC more or less does not use the special purpose GMP functions.
04:29:55 <Jafet> So does integer-gmp just provide the basic Integer implementation, or does it expose those special functions?
04:30:12 <cads> thanks ivanm
04:32:55 <Jafet> Looks like the former, and there's no bindings to the latter
04:41:55 <parcs> does there exist an alias for flip maybe id?
04:42:23 <mauke> @ty flip maybe id
04:42:24 <lambdabot> forall a. a -> Maybe a -> a
04:42:41 <mauke> @. hoogle ty flip maybe id
04:42:41 <lambdabot> Plugin `compose' failed with: Unknown command: "ty"
04:42:45 <mauke> @. hoogle type flip maybe id
04:42:46 <lambdabot> Parse error:
04:42:47 <lambdabot>   --count=20 "forall a. a -> Maybe a -> a
04:42:47 <lambdabot> "
04:42:49 <mauke> aww
04:42:54 <mauke> @hoogle a -> Maybe a -> a
04:42:55 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
04:42:55 <lambdabot> Prelude asTypeOf :: a -> a -> a
04:42:55 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
04:43:02 <parcs> ah, forgot about hoogle
04:43:05 <parcs> neat
04:43:48 <cads> ivanm, would you have any insights about making interactive graph editors in haskell?
04:46:12 <cads> well, that's more of a UI widget thingy than anything to do with a graph library
04:47:50 <cads> if someone made a graph editor interface, does haskell have any UI libraries that would let you extend the interface?
04:49:03 <knobo> is it possible to install ghc7 with cabal install ?
04:49:24 <dcoutts> no
04:49:49 <knobo> is there ghc7 for ubuntu, then?
04:50:13 <dcoutts> the generic binaries should work
04:51:06 <tomh1> foldl and foldr have different type sigs? Why is this? do they take different args?
04:52:10 <Zao> @type foldl
04:52:11 <Zao> @type foldr
04:52:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:52:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:52:37 <mauke> :t foldl `asTypeOf` foldr
04:52:38 <lambdabot> forall b. (b -> b -> b) -> b -> [b] -> b
04:52:43 <Zao> tomh1: The reason is because it does not assume that the functions are commutative.
04:52:49 <cads> what I meant was this. Are there any well documented libraries or UI development techniques known to you guys that would let me create a graph editor interface which I could later extend, for example, to serve as a circuit designer interface?
04:52:52 <Zao> Or something along those lines.
04:53:26 <tomh1> OK. So I just need to switch the arguments around?
04:53:49 <Zao> For a foldr, you get (f0 `op` (f1 `op` acc)), while with a foldl you have ((acc `op` f0) `op` f1)
04:54:27 <tomh1> OK, thank you
04:54:29 <mauke> > foldr f z [a,b,c]
04:54:30 <lambdabot>   f a (f b (f c z))
04:54:34 <mauke> > foldl f z [a,b,c]
04:54:35 <lambdabot>   f (f (f z a) b) c
04:55:20 <Zao> @botsnack
04:55:20 <lambdabot> :)
04:55:43 <lars9> what's the equivalence of liftM concat . sequence ?
04:56:24 <Zao> @pl liftM concat . sequence
04:56:25 <lambdabot> fmap join . sequence
04:56:44 <mauke> :t liftM concat. sequence
04:56:45 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
04:59:12 <ClaudiusMaximus> cads: i'd be interested in something like that too, perhaps - i made a hacky thing in OpenGL/GLUT that let me edit untyped lambda calculus terms as graphs, ported some of it to GTK but i decided to drop the point and click stuff because it's quicker to type in terms than mouse about
05:12:15 <ivanm> cads: pozic was working on one IIRC
05:26:39 <Xilon> Just wondering, what's the difference between liftM and fmap?
05:27:01 <Bynbo7> liftM only works on monads
05:27:23 <Bynbo7> and because not all monads have to be functors, fmap doesn't work on all monads (though in practive it does)
05:27:40 <Bynbo7> there is also liftA and (<$>) which are the same as well
05:28:12 <Bynbo7> :t [fmap, liftA, (<$>), liftM]
05:28:13 <lambdabot> forall a b (f :: * -> *). (Applicative f, Monad f) => [(a -> b) -> f a -> f b]
05:28:42 <Xilon> Ah right. So they're all semantically equivalent (apart from the type differences)?
05:28:52 <Bynbo7> yeah
05:29:54 <Xilon> Cool. I was importing liftM all the time and just realised I could have been using fmap
05:30:17 <Bynbo7> yeah
05:30:20 <Xilon> although liftM is a bit more intuitive for me
05:30:55 <Bynbo7> really?
05:31:32 <Bynbo7> i thought that Functor was probably one of the easiest of all type classes to understand
05:32:10 <mauke> easier than Show?
05:32:14 <Xilon> Yeah. Due to map only working on lists, I keep thinking of fmap as traversing a structure, which I guess is true, but liftM makes a bit more sense for a monad with a single value like Maybe
05:32:30 <mauke> Maybe is just a list with at most 1 element
05:32:56 <Xilon> Yeah but I don't think of it as a list-like/traversable structure
05:35:09 <Bynbo7> i just think of fmap in terms of the types, it takes f's with a's in them and turns them into f's with b's in them
05:36:01 <Xilon> Well types are half the story. You can have two functions with the same type that do completely different things ;)
05:37:13 <Xilon> I wouldn't find liftM intuitive for lists either, even though it does the same thing as [f]map
05:37:41 <Bynbo7> what do you mean they do completely different things?
05:38:06 <Bynbo7> they're just names. for Monads, fmap f x == x >>= return . f
05:42:27 <tomh1> What does it mean if I get a _ whilst debugging?
05:42:38 <tomh1> When looking at variables
05:42:40 <Xilon> They _could_ do different things
05:43:29 <Bynbo7> Xilon: but would be breaking the monad laws if they did so
05:43:53 <Bynbo7> and/or functor laws
05:44:54 <Xilon> liftM isn't mentioned in the monad laws, but that's besides the point. Just saying that types don't define the semantics
05:45:32 <Bynbo7> well, liftM should be defined as liftM f x = x >>= return . f
05:49:21 <Jafet> tomh1: a thunk; see the ghc manual.
05:49:43 <Jafet> @src liftM
05:49:44 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:53:12 <Bynbo7> Xilon: based on that definition, fmap and liftM have to do the same things, or the monad laws for return have been broken
06:21:35 <mm_freak> Bynbo7: fmap is a generalization of liftM
06:21:51 <mm_freak> conceptually you can implement liftM in terms of fmap, but not fmap in terms of liftM
06:24:06 <Jafet> Only because Functor is a generalization of Monad
06:30:35 <benmachine> mm_freak: you can implement fmap in terms of liftM
06:51:15 <ManateeLazyCat> Why you still need C since you can use Haskell write everything? Ask for discuss. :)
06:51:32 <Jafet> Because you can't write everything in Haskell
06:51:39 <ManateeLazyCat> Jafet: Example?
06:51:41 <Jafet> Why, you can't even write everything in C
06:51:54 <Zao> Even if you can write "everything" in C, you don't want to.
06:52:01 <Jafet> Eg. video game shaders
06:52:05 <Zao> Same goes for Haskell.
06:52:20 <Zao> Even if you may be able to express anything, it's most probably not idiomatic and quite painful.
06:53:11 <ManateeLazyCat> I want to know which task C is better, and which haskell is better. I want listen those from you....
06:53:44 <benmachine> C programs aren't garbage-collected, so their performance is more predictable
06:53:52 <Zao> ManateeLazyCat: Why did you bump the version number of all the manatee-* libraries the other day? Something changed in the core?
06:53:53 <benmachine> I believe
06:53:56 <Jafet> Since haskell has a C FFI, and nearly everything else has a C FFI, C is a halfway decent FFI layer
06:54:08 <ManateeLazyCat> Zao: Yeap, for compatible with manatee-core.
06:54:08 <Zao> Sounds like a rather strange platform to be using if you're so tightly bound to the core version.
06:54:19 <Zao> Probably better in the future though, I guess.
06:54:23 <benmachine> and the lack of an RTS probably leads to a smaller memory footprint for lightweight programs
06:54:58 <Jafet> Well, entire systems have been made in only one pair of high level and low level languages
06:55:01 <ManateeLazyCat> Zao: Because manatee-core define DBus protocol detail, you still can install manatee extension on older manatee-core, but it's perhaps break and you don't know hwy.
06:55:08 <Jafet> Like Oberon from Modula/M-microcode
06:55:22 <ManateeLazyCat> Zao: So i focus all manatee extension use newest manatee-core 
06:56:11 <ddarius> Jafet: C has a relatively consistent and simple ABI.  Few other languages provide that.
06:56:15 <Jafet> benmachine: still needs the runtime named libc, although libc is usually much smaller
06:56:25 <ManateeLazyCat> I'm learning C deeply recently, but i don't know which program i want should use C since i'm happy with Haskell.
06:56:38 <ManateeLazyCat> So i want listen your point.
06:56:50 <Zao> ManateeLazyCat: The domain of "systems programming" typically has resided in the realm of C.
06:57:06 <Zao> Kernels, bootloaders, core system tools, etc.
06:57:07 <benmachine> Jafet: sure
06:57:18 <ManateeLazyCat> Zao: Yeap, that's why i want write more C code, i want deep in system, something like linux kernel.
06:57:30 <ddarius> Jafet: And the runtime named linux.
06:57:36 <ddarius> (Except in non-hosted versions.)
06:57:56 <Zao> ManateeLazyCat: Consider looking at a kernel that doesn't suck, like FreeBSD or OpenSolaris.
06:58:35 <ManateeLazyCat> Zao: Ok, i will, thanks for your suggestion.
06:59:01 <Jafet> Or minix!
06:59:06 <Zao> Or look at the sources for some common utilities from coreutils, like ls, cat, etc.
06:59:12 <mrdk> I get 'waitForProcess: does not exist (No child processes)' when I run this code: http://hpaste.org/42661/dmenu. What is the problem?
06:59:29 <Zao> ManateeLazyCat: A good read is APUE if you like books.
06:59:43 <Zao> "Advanced Programming in an Unix Environment" I think it expands to.
06:59:43 <ManateeLazyCat> Zao: APUE?
07:00:25 <ManateeLazyCat> Maybe i found C is better than Haskell when i deep in system programming.
07:00:35 <Zao> http://www.apuebook.com/
07:01:14 <ManateeLazyCat> I found my C knowledge is not enough for my need, like my English.
07:01:34 <ManateeLazyCat> Zao: Thanks for link
07:02:21 <benmachine> Zao: I seem to recall looking at GNU coreutils and hating their coding style
07:02:32 <benmachine> why are coreutils a good example of C programming anyways
07:02:44 <Zao> benmachine: Of course, their guidelines are horribad.
07:03:00 <ManateeLazyCat> Yep, suggestion about good C example are welcome! :)
07:03:08 <Zao> benmachine: I mentioned them as an example of small utilities where C is at suitable impedance with the syscalls used.
07:03:16 <Zao> As for "good" C, I doubt that exists.
07:03:27 <Zao> It lacks the ability to sustain decent abstraction :)
07:03:30 <Jafet> They're not very small, actually
07:04:06 <Jafet> There's Lions' on research unix 6, if you're going for small
07:04:18 <tomjnixon> do people still recommend K&R? It's quite old, but i think the style is still decent?
07:04:28 <benmachine> I have the K&R book
07:04:33 <benmachine> actually never finished reading it >_<
07:04:40 <Jafet> It's actually kind of sad that Lions' book is still relevant to modern operating systems
07:04:54 <benmachine> but I was told when I was given it that the ideas in it are still relevant
07:05:09 <tomjnixon> benmachine: me neither, but it's still usefull i think
07:09:44 <ManateeLazyCat> Perhaps study C try to write new OS core? :)
07:11:23 <ManateeLazyCat> Zao: You think Linux is suck kernel? ;p
07:11:55 <Jafet> I believe Microsoft is commissioning an operating system made from assembly language and C#.
07:12:14 <Zao> Jafet: You mean Singularity or whatever they called it?
07:12:19 <Zao> No idea where that research project went.
07:12:37 <Zao> MSR is like Google's 20% time projects, except they filter out the stuff that didn't work instead of slapping a "Beta" label on it.
07:13:27 <andy_> I have a question related to multiparameter types and type classes - though related to type level functions
07:13:35 <Jafet> It's more like 100% time, but for 3% of the people
07:13:55 <Jafet> (Perhaps unsurprisingly, their research tends to be deeper?)
07:14:22 <ManateeLazyCat> andy_: Please ask you real question! :)
07:14:35 <andy_> sorry, gonna be a second to get a paste out
07:14:39 <andy_> but the general idea is:
07:15:05 <andy_> do you perfer having some type class (with not functions) and creating instances of it
07:15:09 <andy_> then having a function:
07:15:20 <andy_> dup :: OneWord a => ...
07:15:27 <andy_> or having a type class:
07:15:28 <Zao> (hpaste is cool)
07:15:42 <andy_> class Dup a where dup :: ...
07:15:42 <knobo> Does yesod have a mailinglist?
07:15:58 <andy_> and defining instance Dup I, instance Dup Z, etc.
07:18:03 <andy_> http://hpaste.org/42662/type_classes_and_type_function
07:18:30 <ManateeLazyCat> Zao: Now you can hot-swap any code in Manatee. :)
07:18:47 <Zao> ManateeLazyCat: Good to know, if I ever feel a need to try Manatee.
07:18:59 <Oejet> knobo: This one is mostly about Yesod, it seems: http://news.gmane.org/gmane.comp.lang.haskell.web
07:19:24 <andy_> http://hpaste.org/42663/type_classes_and_type_function is the correct version - only more correct because of the instance Dup B
07:19:28 <ManateeLazyCat> Zao: I will like to move Manatee to Windows, if someone help me
07:19:51 <ManateeLazyCat> I will consider that after IDE and Mail-Client....
07:20:42 <andy_> and i forgot it should be Code ... c -> Code b c
07:21:34 <knobo> Oejet: thanx
07:22:14 <djahandarie> :t fix(\m l->let(d,e)=splitAt(div(length l)2)l;z=null;n x@(~(a:b))y@(~(c:d))=let{f|z y=x|z x=y|a<c=a:n b y|True=c:n x d}in f in concat[if z i then[h]else n(m d)(m e)|h:i<-[l]])
07:22:15 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:22:15 <ManateeLazyCat> I found it's really *hard* to find a haskeller can do GUI task, like find haskell job in China.
07:22:36 <djahandarie> @let mergeSort = fix(\m l->let(d,e)=splitAt(div(length l)2)l;z=null;n x@(~(a:b))y@(~(c:d))=let{f|z y=x|z x=y|a<c=a:n b y|True=c:n x d}in f in concat[if z i then[h]else n(m d)(m e)|h:i<-[l]])
07:22:37 <lambdabot>  Defined.
07:22:50 <djahandarie> > mergeSort [65471,434,7,8,5,3452,1,3,5,67,4,2,3]
07:22:51 <lambdabot>   [1,2,3,3,4,5,5,7,8,67,434,3452,65471]
07:23:03 <djahandarie> Not quite 140 characters though
07:23:14 <mm_freak> benmachine: conceptually you can't, because you need fmap in the first place to get liftM
07:23:35 <mm_freak> benmachine: but haskell is category-theoretically incorrect here, because Monad is not a subclass of Functor
07:23:59 <Jafet> @src Functor
07:24:00 <lambdabot> class  Functor f  where
07:24:00 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
07:24:09 <Jafet> Hm, I was wrong all this time then
07:25:03 <mm_freak> Jafet: you need to look at the Monad class to find this out
07:25:29 <mm_freak> should be:  Functor f => Monad f
07:25:32 <mm_freak> current state:  Monad f
07:25:42 <mm_freak> then in fact you wouldn't need liftM at all
07:26:01 <mm_freak> you wouldn't need any of the liftM* functions
07:26:20 <mm_freak> with a proper class hierarchy that is
07:28:28 <parcs> ghc can't handle circular dependencies at all?
07:28:38 <benmachine> mm_freak: actually, even if Functor was a superclass of Monad, you could still define fmap = liftM
07:29:14 <lars9> a ABC.hs defining module ABC is in current directory, how to import it in ghci?
07:30:02 <ManateeLazyCat> lars9: :l ABC.hs
07:30:08 <absentia> sorry to be daft -- if ghc 6.8.2 a later rev than ghc 6.10 and 6.12 ?
07:30:51 <absentia> I remember installing 6.12 (or something?) manually... to get 64bit on osx .. and I have a new debian (elsewhere) and apt-get gets 6.8.2 (??)
07:30:57 <djahandarie> preflex, seen bos
07:30:58 <preflex>  bos was last seen on #haskell 6 days, 15 hours, 39 minutes and 45 seconds ago, saying: @hoogle liftIO
07:31:20 <mm_freak> benmachine: true
07:31:42 <mm_freak> has GHC 7.0 ScopedTypeVariables turned on by default?
07:31:43 <lars9> ManateeLazyCat: that will import everything in ABC.hs
07:31:55 <absentia> anyone ?
07:32:02 <ddarius> parcs: If you are talking about modules, read the user guide.
07:32:09 <mm_freak> that would be a possible explanation why my library isn't compiling on GHC 7.0, while it compiles fine on 6.12
07:32:10 <ManateeLazyCat> lars9: That's not you want?
07:32:14 <parcs> absentia: 6.12 is the latest 6.x version
07:32:23 <parcs> ddarius: will do
07:32:27 <lars9> ManateeLazyCat: not, ABC exports only one function
07:32:43 <lars9> i dont want to mess ghci up :)
07:33:08 <absentia> so, 6.12 is much later than 6.8.2?
07:33:14 <absentia> ok.  I'll go install 6.12 manually.
07:33:16 <benmachine> mm_freak: I very much doubt it
07:33:17 <alinabi> @pl \x y -> y x
07:33:18 <lambdabot> flip id
07:33:21 <ManateeLazyCat> lars9: But you ask "how to import ABC module"? right?
07:33:31 <benmachine> mm_freak: but it has some let-polymorphism changes I think?
07:34:05 <tomjnixon> lars9: you could use ':m + ABC', which should have the same effect as 'import ABC' in regular haskell.
07:34:13 <mm_freak> benmachine: yeah, something like that
07:34:30 <mrdk> I really need help with this issue: I get 'waitForProcess: does not exist (No child processes)' when I run this code: http://hpaste.org/42661/dmenu. What's the problem?
07:35:03 <lars9> oh it works now, dunno why, maybe i should :l first, then :m
07:35:20 <ManateeLazyCat> lars9: Yes, you can't use :m if you don't use :l load it first.
07:35:42 <Jafet> > let qsort = foldr(ap(ap.((++).).takeWhile.(>))(liftM2(.)(:)$dropWhile.(>)))[] in qsort [65471,434,7,8,5,3452,1,3,5,67,4,2,3]
07:35:43 <lambdabot>   [1,2,3,3,4,5,5,7,8,67,434,3452,65471]
07:35:46 <ManateeLazyCat> lars9: You should tell ghci which *file* you need *load*, then *module* name with ";m" 
07:35:50 <ManateeLazyCat> :
07:36:06 <lars9> ManateeLazyCat: yeah, that works, good
07:36:18 <benmachine> Jafet: would that not benefit from a partition?
07:36:30 <benmachine> @unpl foldr(ap(ap.((++).).takeWhile.(>))(liftM2(.)(:)$dropWhile.(>)))[]
07:36:31 <lambdabot> foldr ((\ r w -> (\ al -> (++) (takeWhile ((>) r) al)) >>= \ t -> w >>= \ s -> return (t s)) >>= \ k -> ((:) >>= \ c -> (\ ai -> dropWhile ((>) ai)) >>= \ b -> return (\ i -> c (b i))) >>= \ j ->
07:36:31 <lambdabot> return (k j)) []
07:36:36 <benmachine> erk
07:37:03 <ManateeLazyCat> lars9: If you touch source code, you can type :r to *reload* module. :)
07:37:12 <ManateeLazyCat> Less type
07:38:06 <lars9> good to know that
07:38:11 <lars9> thanks:)
07:38:16 <ManateeLazyCat> NP . :)
07:39:44 <andy_> btw, the solution i found was this:
07:39:44 <andy_> http://hpaste.org/42664/dup_function
07:41:08 <andy_> (the type variable c and d are the previous and next max operand stacks, respectively)
07:41:46 <mm_freak> does anyone have GHC 7.0 installed?
07:42:43 <andy_> i have 7.1
07:42:51 * hackagebot contstuff 1.0.1 - Fast, easy to use CPS-based monad transformers  http://hackage.haskell.org/package/contstuff-1.0.1 (ErtugrulSoeylemez)
07:43:14 <ManateeLazyCat> mm_freak: I guess you want other people help you test package on ghc-7
07:45:07 <mm_freak> ManateeLazyCat: yeah
07:45:26 <mm_freak> andy_: would you try to compile the latest contstuff library please?
07:45:45 <lars9> is this blog english or chinese to you? http://songcq.blogspot.com/
07:45:48 <mm_freak> i just made a little change, which should solve an error reported by GHC 7, but not by my 6.12
07:46:40 <andy_> sure
07:48:14 <andy_> mm_freak, the compilation was successful
07:48:33 <mm_freak> andy_: many thanks
07:48:38 <mm_freak> you saved my day =)
07:48:44 <andy_> np
07:49:04 <andy_> (compiled via cabal unpack, cabal configure, cabal build, cabal install)
07:49:15 <andy_> so i did not really check the dependencies
07:49:24 <andy_> well, i guess the cabal configure does
07:49:25 <andy_> nm
07:49:52 <benmachine> lars9: a combination?
07:50:15 <mm_freak> andy_: it has only two dependencies anyway, which are likely installed
07:51:07 <lars9> benmachine: i see, thanks, i can not find anywhere to change language setting of my google account
07:51:52 <ManateeLazyCat> lars9: Chinese for me.
07:52:05 <benmachine> lars9: the UI elements are in chinese, I guess
07:52:05 <ManateeLazyCat> lars9: And you know, some link block by GFW
07:52:15 <lars9> benmachine: i hate it when i can not run man and search by /.
07:52:28 <benmachine> oh
07:53:14 <lars9> benmachine: yep, not where to edit and no help info found, give up
07:56:01 <ManateeLazyCat> lars9: Say hello at you blog. :)
07:56:18 <lars9> parsec is so handy, just scratched a simple regexp lib in parsec: http://hpaste.org/paste/42666
07:57:24 <ddarius> Jaynes makes me happy.
07:57:59 <lars9> ManateeLazyCat: thanks, but blogspot's editbox is too awkward, i guess i need to find a better blog
07:58:55 * hackagebot dnscache 1.0.1 - Caching DNS resolver library and mass DNS resolver utility  http://hackage.haskell.org/package/dnscache-1.0.1 (ErtugrulSoeylemez)
07:58:57 * hackagebot ismtp 1.0.2 - Fast, incremental ESMTP sessions  http://hackage.haskell.org/package/ismtp-1.0.2 (ErtugrulSoeylemez)
07:59:24 <djahandarie> > length "let z=null;n(x,y)=let a:b=x;c:d=y;f|z y=x|z x=y|a<c=a:n(b,y)|True=c:n(x,d)in f;m l=concat[if z i then[h]else n(m***m$splitAt(div(length l)2)l)|h:i<-[l]]"
07:59:25 <lambdabot>   152
07:59:28 <djahandarie> So damn close heh
07:59:56 <djahandarie> Quicksort was so much easier ;_;
08:00:05 <mm_freak> djahandarie: what are you doing?
08:00:14 <djahandarie> mm_freak, golfing mergesort to 140 chars
08:00:22 <mm_freak> ah, ok
08:00:31 <djahandarie> (To tweet it)
08:01:04 <Jafet> Twats
08:01:29 <ddarius> djahandarie: http://www.sics.se/~adam/twip.html
08:01:55 <mm_freak> djahandarie: so no imports allowed?
08:02:36 <djahandarie> mm_freak, I'm importing Arrow and List there
08:02:41 <djahandarie> I guess that's kind of cheating
08:03:45 <djahandarie> > length "fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])"
08:03:46 <lambdabot>   <no location info>:
08:03:46 <lambdabot>      lexical error in string/character literal at chara...
08:03:50 <djahandarie> > length "fix(\\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])"
08:03:50 <lambdabot>   72
08:03:53 <djahandarie> This was quicksort
08:04:07 <djahandarie> Probably could get it even smaller, but I didn't need to try
08:05:33 <ddarius> @pl \l -> splitAt (div (length l) 2) l
08:05:33 <lambdabot> splitAt =<< flip div 2 . length
08:06:30 <djahandarie> Tried already
08:06:43 <djahandarie> With (`div`2) also
08:08:44 <djahandarie> I wish there were a shorter way to write if elses
08:08:53 <djahandarie> Like if' being in Prelude
08:09:46 <benmachine> djahandarie: replace True with n[] :P
08:09:56 <benmachine> er z[]
08:09:59 <benmachine> > null[]
08:10:01 <lambdabot>   True
08:10:01 <djahandarie> Heh, nice
08:10:42 <rjo> instance Eq Double where (==) a b | trace "a" ++ "b" False = undefined (==) a b = (abs (a-b)) < epsilon
08:11:03 <Jafet> > length "let m(a:x,b:y)=[a:m(x,b:y),a:b:m(x,y),b:m(a:x,y)]!!fromEnum(compare a b);m([],x)=x;m(x,_)=x;s[]=[];s[x]=[x];s l=m$(s***s)$splitAt(length l`div`2)l"
08:11:04 <lambdabot>   146
08:12:10 <tomh1> Fold will only call the function its given n times, where the length of the list its given is n, right?
08:12:29 <Jafet> > foldr f z [a,b,c]
08:12:30 <lambdabot>   f a (f b (f c z))
08:12:39 <djahandarie> Jafet, nice!
08:13:04 <djahandarie> For some reason I thought my concat[] trick had it shorter but it didn't
08:13:30 <tomh1> because this function is only called from the fold (I ctrl-f'd to see) is getting called more times than that...
08:14:59 <mauke> > map length ["s l@(_:_:_)=...;s x=x", "s[]=[];s[x]=[x];s l=..."]
08:15:00 <lambdabot>   [21,23]
08:16:22 <Jafet> Meh, we're still playing in the rough here
08:19:48 <ddarius> > map length ["m([],x)=x;m(x,_)=x", "m(x,y)=x++y"]
08:19:49 <lambdabot>   [18,11]
08:20:41 <djahandarie> ... wouldn't it always fall into that case? lol
08:20:46 <ddarius> So 135 characters is the bust right now it seems.
08:20:51 <ddarius> djahandarie: No.
08:21:00 <ddarius> s/bust/best
08:21:22 <djahandarie> Oh, right
08:21:51 <Jafet> Well, I think the last case is never encountered
08:23:00 <djahandarie> It's still 142 chars
08:23:04 <Jafet> map length ["m([],x)=x", "m x=snd x", "m(x,y)=x++y"]
08:23:07 <Jafet> > map length ["m([],x)=x", "m x=snd x", "m(x,y)=x++y"]
08:23:08 <lambdabot>   [9,9,11]
08:23:19 <Jafet> > length "let m(a:x,b:y)=[a:m(x,b:y),a:b:m(x,y),b:m(a:x,y)]!!fromEnum(compare a b);m x=snd x;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l"
08:23:20 <lambdabot>   133
08:23:27 <djahandarie> in s
08:23:41 <djahandarie> Should be an expression
08:23:55 <benmachine> that doesn't look right
08:24:09 <parcs>  @pl (\f (a, b) -> (a, f b)) -- is there a better way?
08:24:26 <parcs> @pl (\f (a, b) -> (a, f b))
08:24:26 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
08:24:33 <djahandarie> benmachine, seems to run fine
08:24:38 <Jafet> @check (\xs -> let m(a:x,b:y)=[a:m(x,b:y),a:b:m(x,y),b:m(a:x,y)]!!fromEnum(compare a b);m x=snd x;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l in s xs == sort xs)
08:24:39 <lambdabot>   "OK, passed 500 tests."
08:24:45 <EvanR-work> parcs: would an arrow work there?
08:24:52 <ddarius> > let m(a:x,b:y)=[a:m(x,b:y),a:b:m(x,y),b:m(a:x,y)]!!fromEnum(compare a b);m x=snd x;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l in s[19,18..0]
08:24:53 <lambdabot>   [0]
08:24:55 <parcs> EvanR-work: probably
08:25:14 <djahandarie> Heh
08:25:18 <djahandarie> quickcheck fail
08:25:23 <benmachine> djahandarie: what if merge runs out of the second list before the first?
08:25:33 <ion> Does @check use QuickCheck?
08:25:38 <benmachine> uh, like that
08:25:49 <Jafet> > splitAt 5 [1..10]
08:25:50 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
08:25:50 <benmachine> djahandarie: uhm
08:25:54 <parcs> ah, Control.Arrow.second :)
08:25:56 <benmachine> @check (\xs -> sort xs == xs)
08:25:57 <lambdabot>   "OK, passed 500 tests."
08:25:59 <benmachine> :)
08:26:05 <Jafet> Pft
08:26:10 <benmachine> @check (\xs -> sort xs == (xs :: Int))
08:26:10 <djahandarie> lol
08:26:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:26:14 <ddarius> > let m(a:x,b:y)=[a:m(x,b:y),a:b:m(x,y),b:m(a:x,y)]!!fromEnum(compare a b);m(x,y)=x++y;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l in s[19,18..0]
08:26:15 <benmachine> @check (\xs -> sort xs == (xs :: [Int]))
08:26:16 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
08:26:16 <lambdabot>   "Falsifiable, after 0 tests:\n[-2,-3]\n"
08:26:28 <djahandarie> Right, it likes [()]
08:26:30 <ddarius> > length "let m(a:x,b:y)=[a:m(x,b:y),a:b:m(x,y),b:m(a:x,y)]!!fromEnum(compare a b);m(x,y)=x++y;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l in s"
08:26:31 <lambdabot>   140
08:26:51 <djahandarie> Heh
08:26:58 <djahandarie> Cutting it pretty close
08:27:28 <ddarius> You said to golf -to- not less than or equal to 140 characters.
08:28:12 <djahandarie> ... even smaller wouldn't be a problem
08:28:30 <djahandarie> Because then I can write Mergesort: next to it in the tweet ;)
08:28:45 <benmachine> but but but
08:28:51 <benmachine> working out what it is is half the fun :(
08:28:51 <ddarius> That seems unnecessary.  It's obviously mergesort.
08:29:23 <ion> Those Unicode characters probably count as one in Twitter, btw. :-) http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
08:29:34 <djahandarie> Yeah that's dumb though. :P
08:29:47 <djahandarie> I can golf much better in APL but who the hell cares
08:30:02 <yrlnry> Yes.  I sometimes abbreviate tweets by using nonsense like № in place of "No", etc.
08:30:06 <Jafet> We didn't use any of them
08:30:47 <djahandarie> I just tweet in Japanese if I feel like saying a lot!
08:30:58 <djahandarie> Except that usually ends up with extremely broken grammar and me looking like an idiot
08:31:07 <ManateeLazyCat> djahandarie: Haha. :)
08:31:34 <ManateeLazyCat> djahandarie: I found CJK contain 2 ~ 8 information than English, special on Twitter. :)
08:31:47 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.8937
08:32:06 <djahandarie> ddarius...?
08:32:08 <yrlnry> I would be surprised if Korean got you the kind of density you can achieve with Chinese.
08:32:32 <ion> Assuming your readers can understand it. For me personally, CJK tweets contain 0 times the information. ;-)
08:32:38 <ManateeLazyCat> In CJK, you don't need space between word
08:32:42 <djahandarie> I imagine Chinese is most dense. But I can't speak it so Japanese is good too. :)
08:32:54 <ddarius> ManateeLazyCat: You could reasonably avoid that in English as well.
08:32:57 <EvanR-work> you dont need to speak a chinese to be able to read it ;)
08:33:15 <yrlnry> http://twitter.com/#!/mjdominus/status/9989218122072064
08:33:48 <ion> Hah
08:33:57 <djahandarie> yrlnry, heh
08:34:10 <yrlnry> Check out Ranjit's counterproposal: http://yfrog.com/1x6nr0j
08:34:56 <djahandarie> lol
08:35:27 <mauke> ツ
08:35:32 <ManateeLazyCat> My Twitter : https://twitter.com/manateelazycat you will found many Chinese. :)
08:35:34 <yrlnry> heh
08:35:54 <ddarius> You could get a few by exploiting how missing unicode characters sometimes render as boxes with hex codes.
08:36:16 <ion> They add vowels as combining characters to consonants in Hebrew, don’t they? Does twitter count combining characters separately?
08:36:21 <yrlnry> But you can't know ahead of time whether any particular user will see a particular glyph.
08:36:42 <ddarius> yrlnry: You can't know that anyway other than, perhaps, for ASCII.
08:36:50 <ManateeLazyCat> Most unicode space use by CJK, special Chinese :)
08:37:53 <yrlnry> ddarius:  sure, but if you send someone "切", you know they got character U+5207.  Your proposal requires you to also know whether they happen to have a Chinese font installed on the particular machine on which they are reading.
08:38:14 <Jafet> Hrm, we all missed something obvious
08:38:20 <Jafet> @check (\xs -> let m(a:x,b:y)=[a:m(x,b:y),b:m(a:x,y)]!!fromEnum(a>b);m(x,y)=x++y;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l in s xs == sort (xs :: [Bool]))
08:38:21 <lambdabot>   "OK, passed 500 tests."
08:38:29 <djahandarie> Hah
08:38:34 <Jafet> > length "let m(a:x,b:y)=[a:m(x,b:y),b:m(a:x,y)]!!fromEnum(a>b);m(x,y)=x++y;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l in s"
08:38:35 <lambdabot>   121
08:38:37 <djahandarie> I was just looking at that
08:38:40 <gwern> yrlnry: well, korean does employ chinese characters some times
08:38:50 <gwern> yrlnry: and korean did use chinese before the invention of hangul
08:39:12 <yrlnry> I was going to point that out, but it seemed excessively fussy.
08:39:22 <gwern> yrlnry: so at least on a script level, they can be equal. the question is not the script but the language itself
08:39:28 <ManateeLazyCat> 切 哈哈
08:39:33 <gwern> yrlnry: legacy support is never fussy! :)
08:39:56 <yrlnry> Let me say rather that it seemed to me that it was not germane to the discussion.
08:40:10 <mauke> did someone say germans!
08:40:21 <djahandarie> germane
08:40:26 <yrlnry> Über Alles in der Welt!
08:40:39 <djahandarie> Aw, totally thought that was a trigger due to how fast you responded
08:40:47 <mauke> yrlnry: no "!" there, there's actually a condition following
08:41:04 <ion> yrlnry: Whatever, I’m hung’ry.
08:41:20 <gwern> mauke: no, he said germane, which etymologically traces back to 'brother'
08:41:43 <mauke> yrlnry: incidentally, this book has an awesome title: http://www.amazon.de/Alles-alles-%C3%BCber-Deutschland-Halbwissen/dp/346204091X
08:42:06 <djahandarie> I wonder if this golfed version performs the same
08:42:32 <yrlnry> What is "Halbwissen kompakt"?
08:43:12 <mauke> half-knowledge in compact form?
08:43:55 <yrlnry> That's what I thought, but I don't understand.
08:44:07 <mauke> that's what this book promises
08:44:28 <mauke> it's very small but contains all the half-knowledge you need
08:44:58 <djahandarie> Oh well, I guess I'll tweet this
08:45:06 <gwern> I was just thinking the other day, if only I had some half-knowledge of type theory
08:45:43 <mauke> well, this book only tells you "everything, everything about germany"
08:45:43 <yrlnry> mauke:  that sounds really useful.  
08:49:27 <djahandarie> http://twitter.com/#!/djahandarie/status/20521207187111936 \o/
08:49:34 <djahandarie> Even managed to fit in attribution ;)
08:49:56 <mauke> I'm tempted to hack my terminal to remove #! from twitter links
08:50:30 <djahandarie> I've had enough of sorting algorithms though, need something more interesting...
08:50:44 <djahandarie> I've realized now how crazy a 140 char golf is
08:52:42 <mauke> hmm, easier than expected
08:57:43 <Cale> That seems like a weird mergesort
08:58:08 <Cale> Oh, I see, you're using !! as if :)
08:58:16 <copumpkin> is that really shorter?
08:58:16 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
08:58:22 <copumpkin> cause !! with fromEnum and [ ] seems long
08:58:27 <Cale> It doesn't seem like it should be
08:59:12 <copumpkin> > [length "if  then  else ", length "fromEnum!![,]"
08:59:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:59:15 <copumpkin> > [length "if  then  else ", length "fromEnum!![,]"]
08:59:16 <lambdabot>   [15,13]
08:59:19 <copumpkin> I guess so :)
08:59:26 <copumpkin> cause you need more spaces for the if thingy
08:59:38 <Cale> > length "if x then y else z" == length "[y,z]!!fromEnum(x)"
08:59:38 <lambdabot>   True
08:59:54 <djahandarie> Heh
09:00:22 <djahandarie> That one would probably compile to something faster
09:02:38 <Cale> hmm
09:03:11 <Cale> splitAt seems really unfortunate to be using
09:03:24 <Cale> shouldn't need to splitAt for mergesort
09:03:34 <djahandarie> It's the shortest though
09:03:48 <djahandarie> I don't think I could write a full split shorter than 'splitAt'
09:04:17 <Cale> map (:[])
09:05:21 <ray> that's 2 more characters
09:05:25 <dpratt71> @seen mtnviewmark
09:05:26 <preflex>  mtnviewmark was last seen on #ghc 16 hours, 9 minutes and 6 seconds ago, saying: I'm hoping for a little sooner ... 'cause HP 2011 is gated on it
09:05:26 <lambdabot> Unknown command, try @list
09:05:40 <Cale> well, yes, but presumably we won't use length or div either
09:05:59 <Cale> It'll be different...
09:06:23 * djahandarie -> lunch break
09:08:45 <lars9> what's limitation of parsec as a parsing lib?
09:09:02 <Cale> lars9: ?
09:09:25 <lars9> reading some posts about parsing on LtU
09:09:49 <Cale> lars9: It's not going to be as fast at parsing regular languages for example as a proper finite automaton implementation would.
09:10:04 <mauke> it's less powerful than perl regexes
09:10:07 <Cale> It is restricted to LL(k) grammars
09:10:16 <Cale> er, hmm
09:10:34 <Cale> Well, for arbitrary k?
09:11:11 <lars9> is LL1 equivalent to context free?
09:12:05 <taotree> is there a sample code somewhere that would show how to do a simple animation in gtk2hs?
09:12:35 <lars9> oh subset
09:12:52 <Cale> actually, I'm not sure that it is so restricted
09:13:12 <Cale> Parsec can parse at least some context sensitive grammars
09:13:30 <lars9> but parsec can parse non-contextfree language when using State
09:13:47 <mauke> but it can't do \b :-(
09:14:23 <lars9> can parse a^nb^n at least
09:15:08 <mauke> foo = char '(' *> foo <* char ')' <|> return 42
09:26:57 <ddarius> Parsec is embedded in a Turing-complete language...
09:29:09 <tswett> I just realized that if I want to create a programming language, I don't need to write a parser for it.  I can just make it a Haskell library.  :P
09:29:40 <ddarius> tswett: You could also make its syntax a subset of a language that already has a conveniently available parser.
09:29:58 <ddarius> In Haskell that would be C, Haskell, Python, and Javascript I believe.
09:30:15 <tswett> That would be convenient indeed.
09:30:27 <token22> hello
09:30:34 <yrlnry> Chances are that your language is already a subset of Perl.
09:31:00 <yrlnry> Since Perl is the maximal element of the language syntax lattice.
09:31:01 <ddarius> yrlnry: That's pretty restrained of you.
09:31:18 <tswett> Oh, true.
09:31:26 <yrlnry> how so?
09:31:36 <ddarius> Oh yeah, Perl is also something that should have a Haskell parser handily available.
09:31:44 <ddarius> yrlnry: The "chances are" part.
09:31:56 * tswett goes ahead and writes his Haskell in a proportional font.
09:31:56 <token22> i've got something like pok = id (const (+)) its type is a->Int->Int->Int how would it look as pok x y z = ... ?
09:31:59 <systemfault> Well, I do think that Perl is just a frankenstein of a lot of langauges :P
09:32:10 <yrlnry> I believe that it is advertised as such.
09:32:13 <tswett> @unpl id (const (+))
09:32:13 <lambdabot> (\ _ -> (+))
09:32:23 <tswett> lambdabot: come on, you can do better than that.
09:32:38 <ray> well, in perl you just set $ℚ="Haskell" and then the rest of the program is interpreted as haskell
09:32:48 <tswett> token22: I must say, that looks a lot like a homework question.  But anyway, it would be pok x y z = y + z
09:32:50 <systemfault> I was looking at an article yesterday.. comparing a perl 6 fibonnacci implementation to a haskell equivalent...
09:33:07 <yrlnry> "Perl combines (in the author's opinion, anyway) some of the best features of C, sed, awk, and sh, so people familiar with those languages should have little difficulty with it."
09:33:20 <yrlnry> "(Language historians will also note some vestiges of csh, Pascal, and even BASIC-PLUS.)"
09:33:39 <ray> the only best features any of those have are "beloved of unixbeards"
09:33:44 <ddarius> Did/do sed programmers have little difficulty with Perl?
09:33:54 <Tanmoy> Hi
09:33:59 <yrlnry> I'm not sure there ever really were any "sed programmers".
09:33:59 <Tanmoy> I am new to Haskell
09:34:01 <tswett> Hi, Tanmoy.
09:34:06 <ray> i'll just find a sed programmer and ask
09:34:10 <systemfault> Python is the new perl..
09:34:28 <ddarius> Python, in many ways, is the antithesis of Perl.
09:34:55 <ray> but then what is the hegelian synthesis
09:34:56 <ray> and it's not ruby
09:34:59 <token22> tswett i thought so, but i cant find the particaular steps to find it out
09:35:01 <yrlnry> They seem extremely similar to me.
09:35:16 <tswett> token22: first, note that pok x y z = id (const (+)) x y z.
09:35:30 <tswett> token22: then, figure out what id (const (+)) x y z is.
09:35:48 <mauke> > id (const (+)) x y z
09:35:49 <lambdabot>   y + z
09:36:02 <tswett> lambdabot: quit being so fancy.  :P
09:38:12 <token22> i think i got it, const (+) x y z - > (+) y z
09:38:25 <tswett> token22: yup, precisely.
09:38:33 <token22> const just take (+)
09:38:37 <token22> okay thanks
09:39:51 <merijn> :t const
09:39:51 <lambdabot> forall a b. a -> b -> a
09:40:12 <lars9> added support for backslash into the tiny regex lib: http://hpaste.org/42670/regex
09:40:42 <ddarius> I love reading Bolthouse Farms ingredients lists: "Ingredients: Pomegranate juice from concentrate (water, pomegranate juice concentrate), pomegranate juice (not from concentrate)"
09:41:33 <tswett> They used a mixer tap in order to blend together all possible blends of water and pomegranate juice concentrate.
09:41:41 <token22> i was confused because of brackets 
09:42:56 <ion> Ingredients: Pomegranate juice from concentrate (water, pomegranate juice concentrate (from pomegranate juice (not concentrate))), pomegranate juice (not from concentrate (from pomegranate fruit))
09:43:15 <tswett> (not from pomegranate fruit concentrate)
09:44:06 <ion> (ingredients '(pomegranate juice))
09:44:12 <tswett> (from pomegranate fruit (from pomegranate fruit (from pomegranate fruit (. . . (from primordial ooze) . . .))))
09:44:46 <ddarius> @google ooze programming language
09:44:48 <lambdabot> http://www.primordia.com/blog/archives/programming/
09:44:48 <lambdabot> Title: Primordial Ooze: Programming Archives
09:46:26 <ddarius> That was not as rewarding as I was hoping.
09:49:37 <tswett> In Haskell, do not use tabs for indentation unless you are writing in a proportional font.  :P
09:50:11 <tswett> (And a tab should never be preceded by anything except another tab.)
09:50:17 <merijn> s/ unless.*/./
09:50:33 <merijn> eh, \. in the second, I suppose
09:50:34 <tomjnixon> (and have visible whitespace turned on!)
09:50:51 <ion> merijn: No need to escape dots in the substitution part.
09:51:24 * hackagebot cmdargs 0.6.6 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.6 (NeilMitchell)
09:51:27 <tswett> Are there any fancy monad-like tricks that make zippers easier?
09:51:55 * tswett realizes that he's writing a graph datatype, and is scared.
09:52:08 <copumpkin> comonad!
09:52:27 <tswett> Comonads make zippers easier?
09:52:50 <roconnor> copumpkin: I'm not sure that comonads are really related to zippers, though they are really close.
09:53:05 <copumpkin> looks like you could treat a zipper as state: http://www.haskell.org/haskellwiki/Zipper_monad
09:53:10 <balor> Is there an email type defined in a library somewhere?
09:53:15 <rjo> is it possible to overload Double:s (==) wo affecting the implementation of other instances?
09:53:25 <tswett> Isn't being really close a type of relation?  :P
09:53:44 <monochrom> a confusing type of relation, yeah
09:53:48 <copumpkin> http://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/ is about the comonads
09:53:48 <roconnor> rjo: it isn't possible to overload Double's (==) since it has already been instantiated
09:54:02 <copumpkin> more here, too: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
09:54:13 <roconnor> rjo: write your own approximatelyEqual function. :)
09:54:18 <yrlnry> roconnor:  funny, I just finished reaeding a bunch of papers and things pointing out that zippers are essentially comonadic.
09:54:23 <rjo> but I already succeeded in that?
09:54:42 <rjo> import Prelude hiding((==)) ..
09:54:43 <roconnor> yrlnry: I'd like to see that.  I think there is some confusion between zippers and comonads.
09:55:09 <roconnor> yrlnry: zippers highlight substrucutres, while comonds highlight individucal elements
09:55:22 <yrlnry> Is that distinction necessary?
09:55:25 <copumpkin> comonads can be seen as adding context
09:55:26 <rjo> it just wiped out all instances of (==)
09:55:34 <copumpkin> zippers give values a context within the structure containing them
09:55:43 * copumpkin shrugs
09:55:49 <roconnor> rjo: Yes you can write your own definition of (==) in your own module.
09:55:51 <aristid> rjo: of course, hiding() hides all instances of the symbol :)
09:56:11 <benmachine> rjo: don't forget about /= :P
09:56:13 <roconnor> rjo: the fully qualified name of your (==) will be different from Prelude.==.
09:56:36 <roconnor> rjo: as long as you manage your qualfied imports carefully there will be no problem.
09:56:54 <benmachine> roconnor: apart from the problem of qualified operators being ugly as heck
09:57:03 <aristid> or you can use the fact that haskell allows arbitrary operators and define =~=
09:57:12 <rjo> the idea was to add traces to a test module
09:57:27 <roconnor> rjo: also your code will be considered confusing by many people and that is frowned upon
09:57:42 <roconnor> but it will work, and may be acceptable in some circumstances
09:57:48 <rjo> (==) | trace "asdf" = undefined
09:57:54 <yrlnry> http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html begins with the statement "Uustalu points out that behind every zipper lies a comonad."
09:58:07 <yrlnry> I have not yet read the referenced work, however.
09:58:11 <roconnor> copumpkin: yes, but the comonads have an fmap that change the type of the values to another type
09:58:12 <rjo> I've not bothered to check what == means for doubles
09:58:16 <roconnor> copumpkin: you cannot do that with zippers
09:58:40 <benmachine> rjo: ah, you could hide (==) and then define a new local function that traced, but it does make your code more confusing
09:58:49 <roconnor> rjo has a fair point.  Doubles shouldn't even be part of an Eq class :D
09:58:58 <merijn> roconnor: Why not?
09:59:10 <copumpkin> roconnor: look at the Functor instance in that blog post?
09:59:17 <copumpkin> you just map it to the rest of the structure too
09:59:17 <yrlnry> Double should be Eq, but Real should not.
09:59:23 <roconnor> merijn: it probably makes your code not portable or something.
09:59:24 <benmachine> Doubles should be set on fire and then shot into space
09:59:52 <ddarius> Can't you feel the love tonight / the peace the evening brings
09:59:54 <rjo> I thought that Double is boxed double
09:59:54 <benmachine> but they are unfortunately necessary sometimes >_>
10:00:02 <rjo> machine double
10:00:09 <benmachine> yeah
10:00:16 <ddarius> It doesn't have to be.
10:00:32 <benmachine> but in practice it is
10:00:35 <yrlnry> A lot of the suckage of floating-point arithmetic would be avoided if they were internally base-10 instead of base-2.  
10:01:13 <merijn> yrlnry: Why?
10:01:24 <merijn> base 10 has the exact same problems as base-2
10:01:31 <merijn> Also, every base is base 10.
10:01:31 <sproingie> if they were internally BCD, they would be FREAKING SLOW
10:01:33 <yrlnry> merijn:  it has one fewer problem,
10:01:37 <dataangel> Is there any reason this call to readProcess would result in no arguments getting passed? It runs a shell script that reports "$@" and "$1" are empty: readProcess (joinPath [home_folder, "etc/utils/pick_best_browser"]) ["-n"] []
10:01:49 <rjo> yrlnry, what do you mean that Double should be in Eq?
10:02:03 <benmachine> yrlnry: as in, one more prime factor?
10:02:04 <merijn> yrlnry: Which problem would that be?
10:02:11 <tswett> So, I'd like to write an object-oriented language, in which objects can have pointers to other objects.
10:02:25 <monochrom> A paper by Knuth shows why base-2 has less problem.
10:02:26 <sproingie> tswett: isn't that what an object reference usually is?
10:02:36 <tswett> sproingie: probably.
10:02:37 <benmachine> dataangel: try passing two arguments to see if it says differently
10:02:55 <yrlnry> Maybe I don't know what Haskell Double is, but if it's exposing IEEE double-precision floating point arithmetic, as I think, then there is no problem doing exact comparisons of those values.
10:03:02 <yrlnry> The algorithm is quite well-specified.
10:03:15 <roconnor> copumpkin: Okay I agree that CxtTree E is a comonad, but that is simply a concidnece, and not a general pheonomon of zippers.
10:03:16 <tswett> I'd like objects to be representable as Haskell values.
10:03:17 <dataangel> benmachine: same deal, no arguments
10:03:29 <yrlnry> The issue you need to confront is that results of arithmetic operations are subject to rount-off error.
10:03:36 <copumpkin> roconnor: alright :)
10:03:56 <tswett> So, it seems like either I have to have only one execution context, or I have to somehow prevent an Object value in one context from escaping and entering another context.
10:04:12 <yrlnry> Now you might take an internal double x as actually representing an external Double of unknown value in the range (x-epsilon, x+epsilon), in which case I agree that it does not make sense to put it into Eq.
10:04:18 <pozic> Can I generate a cabal file from a working directory given a Main module?
10:04:38 <copumpkin> roconnor: oh, I have proof that you're wrong
10:04:42 <roconnor> good
10:04:46 <tswett> Having only one execution context seems like it would require having everything be in the IO monad.
10:04:50 <copumpkin> roconnor: reductio ad conorum: [01:03:55 PM] <pigworker> yes
10:05:09 <roconnor> which channel?
10:05:16 <copumpkin> #agda 
10:05:18 <copumpkin> I just asked him
10:05:39 <copumpkin> [01:04:31 PM] <pigworker> if F is a differentiable functor, then D F * Id is a comonad
10:05:43 <ddarius> copumpkin: Clearly that proof rule is non-constructive.
10:06:12 <tomh1> I've narrowed down a bug to one bit of code. Its probably something really simple, so go easy on me: http://hpaste.org/42671/why_is_this_printing_3_0s
10:06:56 <copumpkin> probably conorem, as I feel conor would be a third-declension noun
10:07:05 <copumpkin> ddarius: surely not!
10:07:08 <tswett> Who's conor?
10:07:17 <copumpkin> we just have a lazy proof language
10:07:19 <dataangel> nevermind, i was testing it wrong ;P
10:07:21 <tomh1> Why does that code, when run, print 3 0s, not 2?
10:07:32 <copumpkin> you just gotta ask him and he'll provide the proof terms on demand
10:07:42 <copumpkin> tswett: conor mcbride, a knowledgeable dude
10:07:49 <merijn> tomh1: You forgot the empty list?
10:08:19 <merijn> Conor's papers make me feel extremely dumb :p
10:08:45 <merijn> > "hh" == 'h' : 'h' : []
10:08:46 <lambdabot>   True
10:09:04 <merijn> tomh1: So the third zero is for calling foldCommand with the empty list as input
10:09:43 <tomh1> merijn: What? When run with 3 hs instead, it produces 7 0s. When run with 4 it produces 15. its 2^n-1, took me a while to figure that out
10:10:14 <merijn> copumpkin: So "reductio ad conorum" is really a lazy-evaluation proof strategy? ;)
10:10:19 <tomh1> and fold should only call once for every item in the list, I believe (thats what it did in a test I did)
10:10:39 <copumpkin> merijn: certainly, where "<pigworker> yes" is a thunk
10:11:09 <copumpkin> and 
10:11:12 <ddarius> tomh1: You should be able to figure out what is going on from that behavior.
10:11:20 <copumpkin> "pigworker: could you elaborate on that?" is forcing said thunk
10:11:21 <merijn> It's more then a thunk, I guess. It provides some info on the answer already
10:11:28 <djahandarie> "<djahandarie> yes" is a thunk too. Just don't try forcing it
10:11:45 <merijn> A true thunk would be "I know the answer" :p
10:12:02 <copumpkin> merijn: let's assume a total language with lazy evaluation behavior
10:12:04 <djahandarie> merijn, that's what you thunk!
10:12:17 <copumpkin> merijn: in that case, any value you can provide is a proof that the type is inhabited
10:12:26 <copumpkin> but you might not get the term until you ask for it
10:12:57 <tomh1> ddarius: I've looked at it loads, but I think my knowledge of dos and IOs is failing me. I know that when I remove the y at the end of the do, it works, but I need that there as it returns the accumulator (not evident in this small snippet)
10:13:13 <merijn> I swear, this channel exists for the sole purpose of making me feel less intelligent ;p
10:13:29 <benmachine> tomh1: what's acc <- y for?
10:13:43 <djahandarie> Stay out of #agda then, I have little clue what goes on in there at all
10:14:01 <copumpkin> djahandarie: you coming to the next boston haskell?
10:14:03 <merijn> djahandarie: Probably the same scary stuff as #coq and #epigram? :p
10:14:11 <copumpkin> rumor has it edwardk will make me introduce agda
10:14:14 <djahandarie> copumpkin, oh, when is it?
10:14:20 <copumpkin> I have no idea
10:14:23 <copumpkin> I don't think edwardk does either
10:14:27 <djahandarie> lol
10:14:36 <tomh1> benmachine: I had some buggy code, and this was the smallest I could get it without it working, but not all is evidently neccesary here
10:14:37 <djahandarie> Well, I'd like to but it depends
10:14:51 <djahandarie> Make it happen before my semesters starts, then yes. :P
10:15:03 <copumpkin> when is that?
10:15:05 <ddarius> I think he was thinking sometime in early-ish January, like the 9th or something, but I don't recall.
10:15:06 <benmachine> tomh1: oh. well, the problem is, that acc <- y runs 'y' and binds the result to 'acc'
10:15:08 <token22> how would you find out the type of max . map (uncurry min) if you know types of individual functions (is there any trick?)
10:15:27 <djahandarie> copumpkin, Jan 18
10:15:30 <benmachine> tomh1: but then the y at the end runs y again
10:15:31 <copumpkin> aha
10:15:35 <ddarius> token22: The algorithm is completely mechanicall.  No tricks are necessary.
10:15:39 <copumpkin> well, if ddarius is correct, it'll be fine!
10:15:59 <token22> okay i think it could be [(a,a)]-[a]-[a]
10:16:06 <djahandarie> I've been feeling more comfortable with Agda now that I've been reading more Agda code though
10:16:09 <Cale> byorgey: I loved your recent talk on vimeo with The Great Combinatorialist :)
10:16:31 <merijn> token22: By simply plugging it into ghci/lambdabot?
10:16:38 <yrlnry> token22:  When I was first learning SML, I found it very enlightening to grovel through the type unification algorithm manually.
10:16:38 <burp> :t max . map (uncurry min)
10:16:39 <lambdabot> forall a. (Ord a) => [(a, a)] -> [a] -> [a]
10:16:43 <burp> correct ^^
10:16:50 <tomh1> benmachine: thank you so much, this has been bugging me for like 5 hours
10:17:00 <benmachine> tomh1: this is what 'return' is for
10:17:31 <benmachine> tomh1: 'return acc' -- an IO action whose result value is acc and which doesn't do anything else
10:17:55 <tomh1> Yeah, I just realised. It wasn't happening on any other of some guards I had set up, because I needed to modify acc imbetween, so I had to use return. There I was just lazy. Thanks!
10:17:58 <token22> merijn sure but i can't use interpreter on exams
10:18:21 <merijn> token22: Then by doing the substitutions in your head/on paper
10:18:27 <copumpkin> djahandarie: yeah, it's not that bad :)
10:18:39 <merijn> That seems like a really pointless examination, though >.>
10:18:40 <copumpkin> djahandarie: the most painful thing (for me at least) is getting complicated pattern matches to typecheck
10:19:01 <ddarius> Just learn Prolog.
10:19:06 <merijn> I heard Agda is kinda like Coq with a less awful syntax?
10:19:22 <djahandarie> i herd u liek mudkip
10:19:30 <merijn> Because Coq's syntax just annoys me to hell and back...
10:19:37 <copumpkin> merijn: it looks mostly like haskell
10:19:48 <copumpkin> with more flexible syntax, and is pretty similar to coq in many ways
10:19:53 <token22> merijn actually i just imagine what whole expression do.. (bad will be when i get function i do not know)
10:20:01 <pozic> Except Coq is more stable.
10:20:05 <copumpkin> pozic: yeah :)
10:20:26 <merijn> As if anyone does "real" work with either of them :p
10:20:28 <burp> just chain the function applications, defintions
10:20:38 <pozic> The expression "Your proof is not correct anymore" is kind of icky.
10:20:47 <pozic> merijn: some people do.
10:21:12 <pozic> merijn: but yes, it's 0.<lots of zeros>1% of the number of PHP programmers.
10:21:40 <copumpkin> I definitely don't think agda is what DT programming will look like 10 years from now
10:21:48 <merijn> I don't think I'd qualify most PHP code as "real" work either ;)
10:21:49 <copumpkin> but it's exciting to watch things improve
10:22:24 <merijn> I always get the feeling that I'd find Epigram really awesome, if only I understood what was going on :p
10:22:37 <merijn> Sorta how I feel about FRP...
10:22:43 <copumpkin> well, epigram is two languages
10:22:49 <copumpkin> one that doesn't quite exist yet but will be awesome
10:22:53 <copumpkin> and the other with odd syntax :)
10:23:44 <monadic_kid> there is ATS but the syntax is a bit unfortunate at the moment...
10:24:08 <copumpkin> I wouldn't really put ATS in the same bag
10:24:17 <merijn> copumpkin: I think it's the latter one I'm messing around with atm
10:24:19 <copumpkin> also, I don't have much hope for ATS' syntax improving
10:25:18 <monadic_kid> why not it has a dependant type system mean for programming, you can write proofs and what not
10:25:27 <monadic_kid> *meant for
10:25:29 <merijn> I feel like I'm partially grokking Epigram 1 now, but I feel I'm missing out on a critical part of this "Elimination with a Motive" thing
10:26:02 <monadic_kid> i didn't read the entire discussion so I'm most definately missing something
10:26:35 <copumpkin> monadic_kid: they're not really full dependent types
10:27:02 <copumpkin> http://www.bluishcoder.co.nz/2010/09/01/dependent-types-in-ats.html
10:27:33 <copumpkin> monadic_kid: ATS still maintains a separation between terms and types, as far as I've been able to tell
10:27:33 <copumpkin> but you have way more flexible manipulation of types than you can in common haskell
10:27:58 <sproingie> .o( ANSI Common Haskell )
10:28:21 <merijn> Which ISO version is that? :>
10:28:31 <monadic_kid> anyway lets help John!: http://www.haskell.org/pipermail/jhc/2010-December/000848.html
10:28:57 <monadic_kid> and indirectly help me :D
10:29:44 <monadic_kid> I've never had to deal with strict aliasing bugs before fortunately
10:29:47 <copumpkin> preflex: seen luqui
10:29:47 <preflex>  luqui was last seen on #haskell 21 days, 23 hours, 23 minutes and 59 seconds ago, saying: Unity3D's object model is entirely component-based
10:34:50 <andy_> does http://www.haskell.org/haskellwiki/Type_arithmetic
10:35:04 <andy_> well, let me reword
10:35:16 <andy_> does that link define Add in such a way that you can define Subtract in terms of add
10:35:45 <andy_> (i am having trouble doing so - the definition is easy enough, but it fails when i try to actually get an Int from it)
10:36:22 <benmachine> andy_: Subtract is actually already defined, in a sense
10:36:35 <benmachine> uh, not in a sense
10:36:36 <andy_> class Add x y z => Subtract z y x
10:36:46 <andy_> make that an instance..
10:36:56 <benmachine> but have a look at the second fundep on Add
10:37:34 <andy_> that i was wondering about - why not b ab -> a instead, or as well?
10:38:12 <benmachine> I guess it doesn't make a difference
10:38:15 <benmachine> it would be as well
10:38:27 <andy_> does the ordering before the -> make any difference?
10:38:36 <andy_> i.e. are a b -> c and b a -> c equivalent?
10:38:51 <benmachine> I can't imagine what difference it would make
10:38:52 <monochrom> I think so
10:39:13 <copumpkin> andy_: yeah
10:39:38 <andy_> why is the base case Add Zero x Zero instead of Add x Zero Zero, and does that make any difference?
10:40:04 <copumpkin> andy_: you have to make a choice :P
10:40:08 <andy_> i.e. should an instance Subtract x y z be defined with an Add context, with ordering altered?
10:40:17 <copumpkin> andy_: it makes a difference to how you prove things about it, if you want to do so
10:40:34 <andy_> i.e. Add x y z => Subtract z x y vs. Add x y z => Subtract z y x
10:40:35 <andy_> ok
10:40:44 <copumpkin> also, what will reduce easily and what won't
10:40:49 <andy_> (assuming that def of Subtract is possible)
10:40:53 <andy_> ok
10:41:10 <copumpkin> if you're recursing on the left, doing Add x (Suc Zero) won't reduce
10:41:33 <andy_> ok
10:41:41 <copumpkin> andy_: also, this stuff is a lot cleaner using type families, but then you don't get subtraction magically from addition
10:41:45 <andy_> that may explain some of the errors i was seeing
10:48:53 <frerich_> Hmm, is it somehow possible to "partially apply" (not sure that's the correct term here) a function "notOdd = not odd"? My problem is that 'not' expects a Bool, so ghci complains.
10:49:22 <frerich_> I'm trying to do something like any (not odd) [1,3,5,6,7] <-- this should yield True
10:49:35 <andy_> i always think of this as lifting it, but not sure if thats the correct term
10:49:40 <andy_> not . odd
10:49:47 <benmachine> it's composition
10:50:04 <benmachine> 'not odd' passes a function to not, which wants a Bool
10:50:16 <andy_> [...] >>= (return . not . odd)
10:50:18 <frerich_> Yes, I gathered that much but I didn't see how to avoid this.
10:50:31 <benmachine> what you want is to make a new function, such that when you give it x it gives you 'not (odd x)'
10:50:35 <copumpkin> @pl (>>= (return . f))
10:50:36 <lambdabot> (f `fmap`)
10:50:37 <copumpkin> :)
10:50:39 <andy_> do you want a single value for all terms, i.e. none of them?
10:50:55 <andy_> @import Control.Applicative
10:50:55 <lambdabot> Unknown command, try @list
10:50:57 <andy_> meh
10:51:08 <frerich_> benmachine: Yes, exactly! Ah, I always somehow thought the '.' is just syntactic sugar but now I realize it's actually very important :)
10:51:24 <frerich_> Knowing this, I bet I could make use of this to compose clever 'step' functions for foldr...
10:51:29 <benmachine> yep
10:51:31 <copumpkin> we already have Control.Applicative in scope
10:51:37 <andy_> ok
10:52:02 <ddarius> frerich: There is rather little syntactic sugar in Haskell.
10:52:18 <frerich_> andy_: I'm currently (as a little exercise) trying to write my own functions of all the list functions in the Prelude. It's actually a lot of fun to do so and then compare my solutions with what the Prelude has.
10:52:21 <mauke> except for the whole do-notation
10:52:23 <andy_> monads, list (/monad) comprehensions, and arrows?
10:52:27 <mauke> and lists
10:52:38 <Eduard_Munteanu> So I'm working on this mutable, STRef-based binary tree. And I'm noticing some overlap between algebraically-imposed structure vs. STRef.
10:53:35 <andy_> frerich_, yeah, i'm usually pretty surprised on how many times i don't use a fold when its easy to (at least last time i did something similar)
10:53:43 <Eduard_Munteanu> I can't decide whether to combine pointers with an ADT-like structure or make the simplest ADT possible and use "null" pointers.
10:53:49 <roconnor> Eduard_Munteanu: the algebraically imposed structure is immurable.
10:53:56 <roconnor> immutable
10:54:59 <ddarius> mauke: Those are probably the heaviest and they are both very light.
10:55:15 <ddarius> mauke: Now "comprehensive" comprehensions or arrow notation on the other hand...
10:55:50 <andy_> is there anyway to describe f >>> g >>> h as do { f; g; h }, or something similar?
10:56:09 <andy_> the state monad won't work - the types on each end are important
10:56:24 <Eduard_Munteanu> roconnor: yeah. But basically I can't decide whether to have forks, leaves and roots (which gives some algebraic structure, specific to my problem), or simply go with pointers, like 'Node (STRef s a) (TreeRef s a) (TreeRef s a)'.
10:57:23 <Eduard_Munteanu> roconnor: if I chose the first variant, then some things are arbitrary, like the basic units of the tree.
10:57:24 <copumpkin> Eduard_Munteanu: why bother having mutable values if you have mutable structure?
10:57:49 <copumpkin> oh I guess because you don't have an easy parent finder
10:58:16 <Eduard_Munteanu> copumpkin: I don't bother about mutable values if I choose some "structure". But if I don't I guess I need mutable values.
10:58:38 <Eduard_Munteanu> copumpkin: I do have backlinks for parents.
10:58:45 <roconnor> Eduard_Munteanu: I thought you were going to ecshew mutabliltiy (and efficiency) and stick with zippers and such?
10:58:48 <Eduard_Munteanu> (forgot to tell about those)
10:59:01 <Eduard_Munteanu> roconnor: I'm experiencing a bit of OCD about this :)
10:59:09 <roconnor> understandable
11:12:28 <taotree> I'm seeing the following behavior. I'm using gtk2hs. Right before calling maingui, I call forkIO, inside the forkIO, I call threadDelay. That threadDelay is not returning until a new draw event happens on my component...  This happens when I compile with ghc, but if I use runhaskell, it doesn't happen.
11:12:34 <taotree> Here's my code: http://pastebin.com/5QeYvVcD
11:12:47 <vegai> have you tried to compile with -threaded?
11:13:13 <vegai> without that, many things may be blocking
11:13:19 <monochrom> you have to use -threaded. I testify that it works.
11:13:32 <frerich_> Hm, somehow 'concatMap' and 'notElem' look like the ugly ducklings of the Prelude. They seem to provide very little extra value over 'concat . map' and 'not . elem'.
11:13:36 <monochrom> runghc and ghci are -threaded
11:13:38 <taotree> thanks, that seemed to do the trick.
11:14:27 <frerich_> I guess notElem is more efficient than 'not . elem' since it can use 'all' instead of 'any'
11:14:47 <copumpkin> yep
11:14:47 <BMeph> frerich_: Worse, is this: "concatMap = (=<<)". ;)
11:14:49 <copumpkin> that's why it exists
11:15:08 <frerich_> but why concatMap? :-}
11:15:15 <copumpkin> why map instead of fmap?
11:15:19 <copumpkin> why isn't fmap called map?
11:15:24 <copumpkin> cause of history :P
11:15:35 <BMeph> Why isn't map called lmap? ;þ
11:15:45 <monochrom> why english?
11:15:50 <copumpkin> maybe notElem should be private and there should just be a rewrite rule taking not . elem to it
11:15:51 <systemfault> Someone should create a time machine.
11:15:52 <BMeph> why worry? 
11:16:01 <roconnor> monochrom: because Jesus spoke english.
11:16:07 <roconnor> haven't you read the bible
11:16:09 <copumpkin> s/english/american/
11:16:12 <systemfault> roconnor: Of course.. and was american
11:16:18 <ion> and white
11:16:19 <systemfault> Damn you copumpkin :P
11:16:42 <monochrom> what does it mean to be a good person? what does it mean to be a person? what does it mean to be? what does it mean? what does it? what?
11:16:48 <ion> ?
11:16:53 <systemfault>  
11:17:37 <BMeph> The Machiavellian Pumpkin Straikes again! :)
11:17:44 <BMeph> *Strikes
11:18:01 <copumpkin> :)
11:18:11 <djahandarie> This really has nothing to do with Haskell does it
11:18:31 <ddarius> all isn't any more efficient than any
11:18:51 <ion> I see what you did there.
11:19:00 <monochrom> and, any isn't all that more efficient than all
11:19:07 <ddarius> fmap was called map in Gofer where the Monad and Functor classes were first introduced (as Haskell 1.0 didn't have constructor classes.)
11:19:44 <ddarius> Anyway, it wouldn't be concat . map, it would be (concat .) . map
11:20:12 <ddarius> Similarly for notElem
11:21:00 <ion> @unpl (foo .) . bar
11:21:01 <lambdabot> (\ d g -> foo (bar d g))
11:22:18 <djahandarie> Can anything besides supercompilation fuse concatMap anyways?
11:22:24 <aristid> ion: that happens to be foo .: bar :>
11:22:41 <dskippy> If I have a function written like this: "foo arg1 arg2 = not (bar arg1 arg2)" is there a better way to write by omitting the arguments and composing not and bar? It's easy to do with one argument. I can figure out how to do it with two.
11:23:00 <ddarius> djahandarie: foldr/build fusion does an -excellent- job on multiple concatMaps and concat . map f
11:23:11 <djahandarie> Oh, right
11:23:18 <monochrom> @pl \arg1 arg2 -> not (bar arg1 arg2)
11:23:19 <lambdabot> (not .) . bar
11:23:26 <djahandarie> And that's one of the main reasons stream fusion can't replace it
11:23:32 <monochrom> not sure it's better, but it's one way
11:23:45 <dskippy> monochrom: Thanks.
11:23:51 <ion> @pl \a b c -> f (g a b c)
11:23:52 <lambdabot> ((f .) .) . g
11:24:36 <dskippy> I find it funny that point-free style in Haskell makes such abundant use of the "." character.
11:24:42 <aristid> :t (/2) .: (+)
11:24:43 <lambdabot> forall a. (Fractional a) => a -> a -> a
11:25:15 <aristid> dskippy: it's even funnier when you call it "pointless style" :)
11:25:19 <monochrom> . is called o in SML
11:25:35 <ion> Where is .: defined? My hoogle-fu isn’t good enough.
11:25:39 <Zao> monochrom: Quite confusing when you try to name a variable o.
11:25:40 <dskippy> I like o better. Looks more like the actual symbol.
11:25:54 <dskippy> Zao: A valid point though.
11:25:56 <aristid> ion: in lambdabot, and in the functors package
11:26:05 <Zao> dskippy: It sucks when people abbreviate "and" 'o' in your native language.
11:26:05 <aristid> (lambdabot does not use that package)
11:26:13 <aristid> @hackage functors -- ion
11:26:13 <lambdabot> http://hackage.haskell.org/package/functors -- ion
11:26:16 <ion> Thanks
11:26:36 <dskippy> I wish it were more common to have text files with unicode and have keyboards that have lambda, the composition symbol, the forall symbol, etc. Programs would look so nice. :)
11:27:03 <aristid> i can easily type this symbol at least: …
11:28:08 <unkanon_> dskippy: you need an APL keyboard ;)
11:28:54 <dskippy> unkanon: Man, I do.
11:29:49 <ion> > let (∘) = (.) in (2*) ∘ (2*) $ 42
11:29:51 <lambdabot>   168
11:30:22 <unkanon_> that is indeed very nice looking
11:30:59 <dskippy> ion: I guess I can just make a library and define my own stuff and get a new keyboard, huh?
11:31:37 <unkanon_> no need for a new keyboard, just map a bunch of keys in vim for when you're working on a .hs file
11:31:44 <ion> > let (∘) = (.); (·) = (*); (−) = (-) in (2·) ∘ (−1) $ 42
11:31:46 <lambdabot>   82
11:31:57 <unkanon_> like, map . to that pretty little thingy there
11:32:20 <aristid> ion: that's a neat trick to allow subtraction sections
11:32:40 <dskippy> unkanon_: Yeah, maybe that'd be nice. It certainly wouldn't make the code harder to read. 
11:32:43 <aristid> > let (∘) = (.); (·) = (*) in (2·) ∘ subtract 1 $ 42
11:32:43 <unkanon_> inoremap . ∘ for instance
11:32:45 <lambdabot>   82
11:33:06 <unkanon_> dskippy: not at all
11:33:26 <ion> I want Haskell to parse λ as \
11:33:47 <dskippy> ion: Yeah, me too.
11:34:03 <sproingie> problem is that λ is alpha
11:34:11 <sproingie> i suppose it could special-case it
11:34:13 <dskippy> Dr. Scheme has a shortcut key for inserting a lambda and will parse it as lambda.
11:34:14 <unkanon_> not a symbol, right
11:34:36 <djahandarie> concat (map f xs) = foldr (++) [] (build (\c n -> foldr (mapFB c f) n xs) f xs) = foldr (mapFB (++) f) [] xs = foldr (\x ys -> f x ++ ys) [] xs = foldr ((++) . f) [] xs = concatMap f xs       \o/
11:34:37 <unkanon_> oh I know! you can probably have vim display a lambda for a /
11:34:45 <sproingie> so λx parses as one identifier
11:34:57 <unkanon_> wow if that's possible that'd be even nicer than inoremapping things
11:35:08 <sproingie> leksah and emacs both have modes that will render lambdas with λ
11:35:08 <dskippy> unkanon_: Going in that direction is likely problematic.
11:35:19 <unkanon_> sproingie: oh nice to know
11:35:25 <sproingie> i find it screws up copy/paste tho so i never use it
11:35:28 <unkanon_> dskippy: why do you think?
11:36:59 <dskippy> unkanon_: Replacing all '/' is wrong. You need to replace only the ones that mean lambda. Just a hunch but, vim doesn't have a great parser. I think it would mess up. It's not parsing using lex/yacc. It's doing regexp, isn't it?
11:38:01 <monochrom> wait, shouldn't it be \ ?
11:38:17 <dskippy> Yeah, typo. Point still holds.
11:38:46 <sproingie> yeah it has to be syntax-aware
11:38:59 <dskippy> For example turning the \\ into λλ would be a mistake and be very confusing to read.
11:38:59 <unkanon_> dskippy: I see your point. I don't know how vim parses but I doubt it's sophisticated
11:39:05 <sproingie> emacs and leksah do fine with it.  but like i said it screws up copy-paste
11:39:13 <monochrom> yeah, an example is \x41 -> putStrLn "\x41 -> putStrLn ..."
11:40:58 <dskippy> I'd rather just be able to type it and store it in my text file. I might actually make a library to define such things and then see how I like the way my programs look. I'd need macros to type them in my editor though.
11:41:17 <unkanon_> but the macros are easy
11:41:31 <unkanon_> just map C-. to ∘ etc
11:41:36 <dskippy> unkanon_ yeah I bet if I google for it now I'll find one already.
11:41:48 <unkanon_> right
11:43:29 <dskippy> http://www.vim.org/scripts/script.php?script_id=2603
11:44:04 <mm_freak> djahandarie: ah, ok
11:44:05 <unkanon_> aww the screenshot is a no go
11:44:59 <djahandarie> mm_freak, huh?
11:45:31 <mm_freak> djahandarie: about your 140 char mergesort =)
11:45:37 <mm_freak> and the fact that you use imports
11:46:06 <djahandarie> Right, only Data.Arrow actually. Might have been able to remove that since people in here got it all the way down to 121
11:47:20 <rjo> ok, now I do not get this correct: I have typeclass class My where op :: t->t, and I want the instance to be Monoid as well
11:47:27 <djahandarie> Gah
11:47:35 <rjo> how do I define it?
11:47:35 <djahandarie> Control.Arrow of course
11:47:42 <djahandarie> Who came up with this stupid hierarchy anyways
11:50:53 <rjo> instance Monoid XType => My XType where { mappend = ... ; mempty = ... ; op }
11:51:40 <rjo> e.g. I want to my instance to implement multiple "interfaces"
11:52:30 <andy_> so, is there a better way to do this:
11:52:31 <andy_> http://hpaste.org/42672/dup2_function
11:53:53 <andy_> i have not checked that it compiles, but hopefully the intention is apparent
11:54:03 <andy_> of course, i could do a type class instead
11:54:13 <sshc> How would I combine irrefutable pattern matching and strict pattern matching (~ and !)?
11:54:27 <andy_> is there a resource that explains when type classes add overhead, and when they are free?
11:54:44 <mikeg> rjo: how about: class Monoid a => My a where op :: a -> a
11:54:58 <allbery_b> sshc: I think those are incompatible, since ~ is really "match lazily"
11:55:02 * roconnor ponders if strict pattern matching can be irrefutable.
11:57:05 <rjo> mikeq: m.hs:16:2: `mappend' is not a (visible) method of class `My'
11:57:37 <rjo> do I have to (re)define mappend and mempty to typeclasss my
11:57:40 <rjo> My
11:58:17 <rjo> instance My ConcreteType where
11:58:57 <mikeg> you define mappend as part of the Monoid instance
11:58:59 <rjo> and class Monoid t => My t where, which contains only the op :: t -> t
11:59:11 <mikeg> instance Monoid XType where mappend = ...
12:01:11 <rjo> ok, thanks
12:01:41 <phao> what is the character for the end of line character?
12:02:19 <mauke> \n
12:03:29 <phao> hmm
12:03:39 <phao> why doesn't print "hi\nworld" puts the new line then?
12:03:45 <mauke> because you used print
12:03:49 <phao> hmm
12:03:53 <mauke> @src print
12:03:53 <phao> which should I use?
12:03:54 <lambdabot> print x = putStrLn (show x)
12:03:58 <mauke> putStr
12:04:00 <phao> ah right
12:04:08 <phao> much better hehe
12:04:14 <sproingie> @src putStrLn
12:04:14 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
12:09:23 <ddarius> You can nest strict and lazy patterns arbitrarily.
12:09:42 <ddarius> For example you can irrefutably match a tuple but be strict in the components.
12:10:16 <ddarius> You can also do stuff like let !(~x) = ... if you want, but that's pointless .
12:11:30 <javagamer> hi
12:15:41 <javagamer> Can someone help me with this: http://pastebin.com/Eb49neTK ?  It's a really simple program, but I'm just learning Haskell.
12:17:04 <mauke> (x) is the same as x
12:17:20 <dskippy> javagamer: What's wrong with it?
12:17:32 <mauke> dskippy: line 19
12:18:03 <dskippy> Yeah what's the error message?
12:18:23 <dskippy> nextLine (start) looks suspicious though.
12:18:42 <dskippy> Oh mauke: That's that you meant be (x) is the same a x
12:18:49 <mikeg> f a(b) is the same thing as f a b, not f(a(b))
12:19:06 <monochrom> computeThing (nextLine start) (lines - 1)
12:19:14 <dskippy> javagamer: I don't know what your error message is but I bet you mean (nextLine start)
12:19:39 <javagamer> Yeah, thanks!
12:19:47 <javagamer> Now that I'm looking at it that makes a lot of sense
12:20:17 <monochrom> erase all other languages from your memory. or set up a clean-slate virtual machine.
12:20:19 <javagamer> Wow, my first Haskell program finally works :D
12:20:33 <dskippy> javagamer: Congrats.
12:21:43 <dskippy> javagamer: line 3 "(x:[])" = "[x]"
12:22:47 <javagamer> dskippy, hmm?
12:23:04 <monochrom> not an error but more common to write [x]
12:23:06 <dskippy> You can use [x] as your pattern.
12:24:11 <javagamer> ah
12:25:34 <dixie> > sort <$> "haskell"
12:25:35 <lambdabot>   Couldn't match expected type `[a]'
12:25:35 <lambdabot>         against inferred type `GHC.Types...
12:25:56 <dixie> > Data.Char.ord <$> "haskell"
12:25:56 <lambdabot>   [104,97,115,107,101,108,108]
12:26:04 <dskippy> javagamer: What does countSameNumbers do?
12:26:47 <javagamer> It counts the number of times the first number in a list is repeated
12:27:12 <dskippy> Do you want to know how to do this much more simply?
12:27:14 <javagamer> and then returns the rest of the list along with the number that is repeated and how many times it's repeated (not in that order)
12:27:37 <javagamer> Sure, I figured there was a better way to do this
12:28:11 <dskippy> Do you need the list to be returned back to you?
12:28:24 <dskippy> Or did you just write it that way because it was easier for you?
12:28:37 <dskippy> Or do you really just want the count of the number of times the first element appears?
12:29:25 <javagamer> I need it returned because of how I wrote the rest of the code, but I think there's a way to accomplish this without doing that.  My intended result was to be able to compute: http://pastebin.com/txrPRMju
12:29:33 <javagamer> From the first line
12:30:26 <dskippy> Do you want the list without those numbers in it or you want the whole list returned or you want the whole list without the first element in it?
12:31:05 <rjo> @src Just
12:31:06 <lambdabot> Source not found. My pet ferret can type better than you!
12:31:13 <mauke> @src Maybe
12:31:14 <lambdabot> data Maybe a = Nothing | Just a
12:31:40 <dskippy> javagamer: myCount l = length $ filter (==(head l)) l
12:31:44 <dskippy> There's a start.
12:31:55 <dskippy> You need to handle the empty case.
12:32:00 <javagamer> dskippy, for the rest of my code to work I want that to return the list without the first element and all consecutive ones with the same value
12:32:22 <dskippy> javagamer: So get rid of all copies of the first element.
12:32:48 <mauke> > partition ('a' ==) "abracadabra"
12:32:49 <lambdabot>   ("aaaaa","brcdbr")
12:32:52 <benmachine> you'd want span, not filter
12:32:57 <mikeg> @src span -- probably useful here
12:32:57 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:33:22 <dskippy> Partition is the right thing. I was just Googling for that.
12:34:06 <benmachine> no, span not partition
12:34:11 <benmachine> we're looking for consecutive runs
12:34:37 <dskippy> benmachine: Are we?
12:34:57 <benmachine> yes
12:35:10 <dskippy> Oh all consecutive ones. I see.
12:35:17 <benmachine> according to http://pastebin.com/txrPRMju anyway
12:37:28 <javagamer> Back in elementary school a teacher gave the first 5 lines of that and asked us to find the next.
12:37:55 <javagamer> Figured it'd be a cool program to write in Haskell now that I'm learning it
12:38:07 <mauke> > group "111221"
12:38:08 <lambdabot>   ["111","22","1"]
12:38:26 <mauke> > map (head &&& length ) $ group "111221"
12:38:27 <lambdabot>   [('1',3),('2',2),('1',1)]
12:38:28 <javagamer> Ooh, that could have been useful
12:38:39 <mikeg> > let f (x:xs) = (head y, 1+length y, z) where (y,z) = span (x==) xs in f [1,1,1,1,2,3,4]
12:38:40 <lambdabot>   (1,4,[2,3,4])
12:38:54 <mauke> > map (length &&& head) . group $ "111221"
12:38:56 <lambdabot>   [(3,'1'),(2,'2'),(1,'1')]
12:39:02 <qfr> The next one could be anything. That isn't a formally well defined problem at all. Sigh :(
12:39:17 <dskippy> count (x:xs) = (x, length copies, rest) where (copies, rest) = span (==x) xs
12:39:26 <dskippy> Then you need that "count [] = (0,0,[])"
12:39:31 <mauke> > map (intToDigit . length &&& head) . group $ "111221"
12:39:33 <lambdabot>   [('3','1'),('2','2'),('1','1')]
12:39:43 <_el_loco> qfr, why anything?
12:40:18 <mauke> > concatMap (\xs@(x : _) -> [intToDigit (length xs), x]) . group $ "111221"
12:40:20 <lambdabot>   "312211"
12:40:43 <mauke> > iterate (concatMap (\xs@(x : _) -> [intToDigit (length xs), x]) . group) "1"
12:40:44 <qfr> _el_loco yep
12:40:45 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
12:40:47 <qfr> Precisely
12:42:05 <copumpkin> intToDigit?
12:42:13 <_el_loco> qfr, the next line is well defined in terms of the previous one.
12:42:15 <copumpkin> why not show?
12:42:28 <copumpkin> > intToDigit 10
12:42:29 <lambdabot>   'a'
12:42:34 <copumpkin> nice
12:42:54 <mauke> > iterate (concatMap (\xs@(x : _) -> show (length xs) ++ [x]) . group) "1"
12:42:56 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
12:43:42 <mikeg> Wow ^^
12:43:53 <qfr> _el_loco: I am talking about those "given a sequence a_0, .., a_n, what is the value of a_{n + 1}?" `problems'. They are common in primary school and highschool but they aren't mathematically well defined problems.
12:44:15 <qfr> It's more like... an informal game.
12:44:22 <_el_loco> qfr, oh, I understand now. I agree.
12:45:15 <Rotaerk> given a sequence o_O, .., O_o
12:45:18 <mauke> this sequence stuff has practical applications in string obfuscation
12:45:30 <qfr> "1, 2, 3, ... what comes next?" Most people would say 4. Most mathematicians would be annoyed.
12:45:54 <_el_loco> 5 :)
12:46:09 <copumpkin> > sequence ["o^-$O", "_.", "O^_$-"]
12:46:10 <lambdabot>   ["o_O","o_^","o__","o_$","o_-","o.O","o.^","o._","o.$","o.-","^_O","^_^","^...
12:46:32 <mauke> http://mauke.ath.cx/exe/jslinenc?what+comes+next?
12:46:38 <copumpkin> > sequence ["o^-x$O", "_.", "O^xo$-"]
12:46:39 <lambdabot>   ["o_O","o_^","o_x","o_o","o_$","o_-","o.O","o.^","o.x","o.o","o.$","o.-","^...
12:47:19 <Rotaerk> heh
12:47:45 <Cale_> 1,2,3,5,7,11,...
12:48:10 <mauke> @oeis 1 2 3 5 7 11 12
12:48:12 <lambdabot>  Numbers n such that 210*n+1 is prime.
12:48:12 <lambdabot>  [1,2,3,5,7,11,12,13,16,17,20,22,23,28,29,30,35,36,39,42,44,46,47,50,51,53,55...
12:48:36 <copumpkin> that's a bit of a stretch
12:48:48 <Cale> @oeis 1,2,3,5,7,11
12:48:49 <lambdabot>  a(n) = number of partitions of n (the partition numbers).
12:48:49 <lambdabot>  [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1...
12:48:51 <aristid> > length <$> sequence ["o^-$O", "_.", "O^_$-"]
12:48:52 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
12:49:05 <aristid> > filter (/=3) . length <$> sequence ["o^-$O", "_.", "O^_$-"]
12:49:05 <copumpkin> ah, that one's nicer
12:49:06 <lambdabot>   Couldn't match expected type `[a]'
12:49:06 <lambdabot>         against inferred type `GHC.Types...
12:49:21 <aristid> > filter (/=3) $ length <$> sequence ["o^-$O", "_.", "O^_$-"]
12:49:22 <lambdabot>   []
12:49:30 <copumpkin> > length $ sequence ["o^-$O", "_.", "O^_$-"]
12:49:30 <lambdabot>   50
12:49:49 <djahandarie> Whoa, oeis is working again
12:49:50 <djahandarie> Why?
12:49:53 <mauke> > product $ map length ["o^-$O", "_.", "O^_$-"]
12:49:54 <lambdabot>   50
12:49:54 <aristid> @src sequence
12:49:54 <lambdabot> sequence []     = return []
12:49:55 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:49:55 <lambdabot> --OR
12:49:55 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:49:55 <Cale> No idea
12:49:58 <djahandarie> lol
12:50:05 <mauke> djahandarie: it wasn't me!
12:50:15 <Rotaerk> 1,2,3,6,11,20,...
12:50:20 <aristid> @oeis 1,1,2,4,8
12:50:21 <lambdabot>  Expansion of (1-x)/(1-2x) in powers of x.
12:50:21 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
12:50:21 <copumpkin> djahandarie: I fixed it with my voodoo mind control
12:50:52 <djahandarie> @. (run fix) oeis
12:50:53 <lambdabot> Plugin `compose' failed with: Unknown command: "(run"
12:50:54 <djahandarie> :(
12:50:58 <aristid> copumpkin: i know your real name now! *mwahaha*
12:51:01 <Rotaerk> @oeis 1,2,3,6,11,20
12:51:02 <lambdabot>  Triangular array T read by rows: T(n,0)=T(n,2n)=1 for n >= 0, T(n,1)=0 for n...
12:51:02 <lambdabot>  [1,1,0,1,1,0,1,2,1,1,0,1,2,3,4,1,1,0,1,2,3,6,9,8,1,1,0,1,2,3,6,11,18,23,18,1...
12:51:14 <copumpkin> aristid: hah, I never made much effort to hide it :)
12:51:21 <Rotaerk> o_O
12:51:50 <copumpkin> man, I thought oeis used a trie to represent its knowledge
12:51:55 <copumpkin> but that result kind of breaks that
12:52:15 <aristid> what? :)
12:52:50 <boegel> does Haskell run on Alpha systems?
12:53:02 <copumpkin> JHC would
12:53:09 <boegel> copumpkin: really?
12:53:13 <copumpkin> and an unregistered GHC probably could be made to
12:53:14 <boegel> copumpkin: nice
12:53:17 <copumpkin> JHC just produces legit C
12:53:26 <copumpkin> so if you have a c compiler, you can get it working
12:53:55 <boegel> how about getting JHC to build in that Alpha sytem? :)
12:54:10 <boegel> copumpkin: itself is not written in Haskell like GHC is?
12:55:43 <sproingie> if it compiles to c, then it could translate itself to c
12:55:52 <thoughtp1lice> ISTR the latest JHC actually uses some glibc specific macros etc (like __predict_false and whatnot) in the RTS - the code generated by the C compiler is ISO C99 IIRC, but parts of the RTS are not
12:55:56 <boegel> sproingie: once you have it running... ;)
12:56:19 <thoughtp1lice> those could be easily fixed however, and in general JHC generated code will build mostly anywhere (especially if you have gcc)
12:56:23 <thoughtp1lice> that is, when JHC works ;)
12:56:27 <sproingie> sure but if it outputs vanilla c then you could port that
12:57:06 <thoughtp1lice> if JHC ever self-hosts that'll be ridiculous but awesome
12:57:17 <thoughtp1lice> I wonder if GCC will be able to handle 20,000,000 C files
12:57:25 <thoughtp1lice> *20,000,000 LOC C files
12:57:32 <sproingie> sure.  it'll take 30 years to compile but sure.
12:57:42 <monochrom> haha
12:57:57 <tomjnixon> it would seem that LLVM has an Alpha target, so that would be another possible route?
12:58:26 <tomjnixon> (GHC can compile via LLVM now, can't it?)
12:59:24 <thoughtp1lice> parts of the RTS would need to be ported, but that is likely possible
13:00:22 <thoughtp1lice> also LLVM would need modification in that case too
13:00:32 <thoughtp1lice> because the GHC calling convention is only supported on x86/x86_64 currently
13:00:51 <tomjnixon> ah, yeah. i forgot about that :(
13:01:01 <boegel> tomjnixon: but can it bootstrap on LLVM?
13:02:20 <thoughtp1lice> I think the bitcode GHC generates from modules is mostly pretty platform independent - that's the main practical problem with bitcode, because if you want one bitcode file to run on say, ARM and Alpha and x86, the bitcode has to be generated with that in mind. lots of times, it isn't (example: C compilers may #include code that depends on the endianness that your platform specific headers, so while the C itself may be portable, the generated cod
13:02:51 <tomjnixon> boegel: i don't think so, again because of the calling convention and the RTS, but i honestly don't know
13:04:30 <thoughtp1lice> the RTS wouldn't be a problem I'd think; it's got the necessary registers pinned for the calling convention to work in practice. the reason LLVM even needed a backend for GHC in the first place is because it needed to pin those same registers, so e.g. code built against the native code generator can link and work with code built using the LLVM codegen, as well as the RTS
13:05:02 <thoughtp1lice> i still don't think GHC can bootstrap with it though
13:05:36 <thoughtp1lice> you can add -fllvm to your HcSrcOpts in mk/build.mk though and give it a whirl (I think that's the variable, anyway)
13:12:42 <yrlnry> I want Uustalu and V. Vene to write a paper with William W. Wadge.
13:15:23 <monochrom> www.vv.u?
13:25:18 <valium97582> whoa. "Quit: FATAL ERROR"
13:25:20 <valium97582> ouch
13:25:21 <qfr> http://upload.wikimedia.org/wikipedia/commons/d/d0/Simon_Peyton_Jones_01.jpg Haskell is scary
13:25:42 <qfr> He looks like the host of an 80s horror/anthology thing.
13:26:12 <qfr> The only thing that is missing, is some stuffed animals in the background.
13:27:21 <dskippy> To The Gimp!
13:27:50 <luite> even more scary is the image quality of that picture
13:28:00 <qfr> dskippy haha.
13:28:09 <yrlnry> qfr:  Wadler appeared in that "Computer scientist or serial killer" quiz a while ago.
13:28:29 <qfr> http://upload.wikimedia.org/wikipedia/commons/6/6b/Wadler2.JPG heh
13:28:42 <qfr> Hahah the lambda insignium
13:28:53 <qfr> Looks like he is a member of some deathcult
13:29:14 <qfr> Wadler, the head of the purely functional deathcult
13:30:02 <Twey> Haha
13:30:52 <qfr> yrlnry I got only 6 out of 10 right
13:31:08 <qfr> Which, considering my knowledge of Wadler, is bad.
13:33:00 <token22> hi again, how would you manually determine type of any.any.(>) ? 
13:35:34 <dskippy> @type any . any . (>)
13:35:35 <lambdabot> forall a. (Ord a) => a -> [[a]] -> Bool
13:35:54 <dskippy> token22: Is that manual enough for you?
13:36:07 <copumpkin> token22: run unification in your head
13:36:42 <qfr> Prelude> :t any.any.(>)
13:36:42 <qfr> any.any.(>) :: (Ord a) => a -> [[a]] -> Bool
13:36:45 <qfr> token22 like that
13:37:21 <token22> dskippy actually i found out that there is some method with substitution to finding out it
13:37:46 <token22> but i can't find any examples of that
13:37:52 <benmachine> hmm
13:38:03 * benmachine wrote a program to demonstrate the method but it's not finished yet
13:38:07 <aristid> qfr: 7/10 :)
13:38:10 <dskippy> token22: You mean you want to do out the derivation by hand on paper knowing the types for any and (>)?
13:38:21 <qfr> aristid you are wiser than me
13:38:27 <luite> bah 6/10 :(
13:38:33 <aristid> qfr: indeed. but i almost got wadler wrong, lol
13:38:45 <dskippy> token22: That's pretty simple. You just use something like beta reduction on the types.
13:38:53 <token22> yes i know types of any (.) and (>) and need to find the result type (i can use only paper and pen)
13:39:04 <copumpkin> token22: unification?
13:39:43 <token22> something like this http://www.mail-archive.com/haskell-cafe@haskell.org/msg54904.html
13:41:15 <dskippy> token22: Simple enough. any:: (a->Bool) -> [a] -> Bool and (>) :: Ord a => a->a->Bool. In a composition chain the right-most function takes an argument and the result is passed to the next function.
13:41:42 <dskippy> token22: So the result of (>) applied to one argument is a->Bool, that becomes the first argument to the first any.
13:41:56 <EvilMachine> he... ii'm wondering what the haskell equivalent of a choice matrix is. you know, like guards with nested guards where the nested guards always are the same.
13:43:30 <EvilMachine> like a selector for a function in a 2-dimensional field of functions.
13:43:52 <dskippy> token22: that makes a new function [a]->Bool which becomes the argument to the left-most any and then 'a' for that any becomes [[a]]
13:44:16 <EvilMachine> i don't want to write the same thing twice. feels wrong.
13:44:53 <token22> Hm
13:45:50 <aristid> @hoogle (a->Bool) -> [a] -> Bool
13:45:51 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
13:45:51 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
13:45:51 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
13:46:02 <aristid> @hoogle [Bool] -> Bool
13:46:03 <lambdabot> Prelude and :: [Bool] -> Bool
13:46:03 <lambdabot> Prelude or :: [Bool] -> Bool
13:46:03 <lambdabot> Data.List and :: [Bool] -> Bool
13:46:06 <roconnor> nikki has a lot of dependencies
13:46:11 <roconnor> has anyone built it?
13:46:11 <aristid> :t and . map
13:46:12 <lambdabot>     Couldn't match expected type `[Bool]'
13:46:12 <lambdabot>            against inferred type `[a] -> [b]'
13:46:12 <lambdabot>     Probable cause: `map' is applied to too few arguments
13:46:15 <aristid> :t and .: map
13:46:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:46:22 <aristid> :r or .: map
13:46:29 <aristid> :t or .: map
13:46:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:48:59 <EvilMachine> hm...
14:26:10 <parcs> monads-fd and monads-tf are inferior to mtl, right?
14:26:33 <ClaudiusMaximus> > (const 2 $ undefined, const 2 $! undefined)
14:26:34 <lambdabot>   (2,*Exception: Prelude.undefined
14:26:50 <aristid> parcs: in fact, mtl 2.0 is now the successor to monads-fd
14:27:02 <aristid> parcs: but monads-fd was better than mtl <2
14:27:57 <ClaudiusMaximus> i added strictness to my untyped lambda calculus interpreter:  "(const 2) loop" -> "2" and "!(const 2) loop" -> non-termination
14:31:34 <ClaudiusMaximus> is there a better way to do that kind of thing than adding another node type to all the AST variations?
14:35:50 <ClaudiusMaximus> and the reason i added that strictness stuff was a bit ugly too - to allow "primitives" (yet to be added) to know that their operands are fully evaluated before they are called...
14:37:34 <mm_freak> ClaudiusMaximus: do it the same way as haskell does it
14:37:56 <mm_freak> > let x = undefined in const 2 x
14:37:57 <lambdabot>   2
14:38:02 <mm_freak> > let x = undefined in x `seq` const 2 x
14:38:03 <lambdabot>   *Exception: Prelude.undefined
14:38:20 <mauke> > const 2 x
14:38:21 <lambdabot>   2
14:39:32 <ClaudiusMaximus> mm_freak: is implemnting 'seq' better than implementing '$!' ?
14:39:53 <mm_freak> ClaudiusMaximus: yes
14:40:05 <mauke> @src ($!)
14:40:06 <mm_freak> seq can be used outside of function application
14:40:06 <lambdabot> f $! x = x `seq` f x
14:40:40 <polarina> Using FlexibleInstances, I made an instance Binary [Message] where ...  , but it overlaps with  instance (Binary a) => [a] where ...  .  How can I use my Binary [Message] instance?
14:41:09 <mauke> seq a b = const b $! a
14:41:10 <mm_freak> polarina: make an instance for Message, not [Message]
14:41:39 <polarina> I have an instance for Message.
14:41:50 <mm_freak> then you don't need the [Message] instance
14:44:00 <ClaudiusMaximus> so, seq and $! can each be defined in terms of the other - i find $! more intuitive for some reason
14:44:52 <mm_freak> ClaudiusMaximus: how can you define 'seq' in terms of ($!)?
14:45:31 <ClaudiusMaximus> mm_freak: mauke pointed it out:  seq a b = const b $! a
14:45:42 <mm_freak> true
14:46:20 <ClaudiusMaximus> :t \a b -> const b $! a
14:46:21 <lambdabot> forall a a1. a1 -> a -> a
14:51:03 <zmbmartin> I am new to haskell, is cabal same idea as ruby gems?
14:51:40 <Twey> zmbmartin: What is the idea of ‘ruby gems’?
14:52:03 <zmbmartin> basically a package management system for haskell?
14:52:12 <Bynbo7> yeah
14:52:25 <Bynbo7> but gems breaks far less often than cabal sadly
14:52:54 <Twey> Sort of.  You can use it to install stuff and it'll grab dependencies and build it for you.
14:53:03 <dankna> gems is a package-management system
14:53:06 <dankna> cabal is not, really
14:53:09 <aristid> @index ($!)
14:53:09 <lambdabot> Prelude
14:53:18 <dankna> cabal is a build-and-install tool
14:53:21 <Bynbo7> zmbmartin: cabal is a build system more than a package management system. 
14:54:14 <monochrom> cabal is not a package management system. does not track files.
14:56:04 <monochrom> infrastructure and tool chain are cultural. expect no isomorphism.
14:56:25 <mm_freak> cabal is actually just a library, but there is a frequently used command line utility with the same name, which you can use to do all sorts of stuff with online haskell packages and local projects
14:56:34 <zmbmartin> ok thanks for the explanations
14:56:59 <mm_freak> including building, installing and creating distribution tarballs
14:57:17 <snk_kid> zmbmartin: cabal install works with an online package repository hackage
14:57:47 <snk_kid> zmbmartin: http://hackage.haskell.org/packages/hackage.html
14:58:22 <zmbmartin> I just noticed that I had installed xmonad with my distro's package manager but cabal shows an update for it.
14:59:40 <TTimo> quick Q for emacs users .. is there a haskell-shell, or should I just M-x terminal-emulator ghci ?
15:00:22 <monochrom> read http://www.vex.net/~trebla/haskell/sicp.xhtml before you tell cabal to install new versions
15:00:36 <parcs> TTimo: there is haskell-mode
15:01:20 <ivanm> monochrom: lol at your title
15:01:29 <Bynbo7> lol
15:01:31 <monochrom> heh
15:01:48 <Bynbo7> ok, i need to head to the office and get my phone charger!
15:03:43 <rjo> was there some option to enable n+k patterns?
15:03:58 <rjo> in ghci
15:04:35 <ivanm> rjo: unless you're using haskell2010 mode in ghc 7, n+k patterns should be available
15:04:42 <ivanm> > let f (n+2) = n in f 3
15:04:44 <lambdabot>   <no location info>: Parse error in pattern
15:04:46 <ivanm> bah
15:05:10 <ivanm> well, that works in ghci
15:05:25 <azaq23> Prelude> :t test
15:05:25 <azaq23> <interactive>:1:0: Not in scope: `test'
15:05:37 <azaq23> after I did Prelude> let test + 4 = 10
15:05:50 <ivanm> azaq23: yeah, that won't work ;-)
15:06:00 <rjo> fact n+1 = (n+1) * fact n
15:06:04 <rjo> parse error in pattern
15:06:05 <ClaudiusMaximus> rjo: maybe: :set -XNPlusKPatterns 
15:06:13 <ivanm> rjo: parens needed on LHS
15:06:16 <mauke> rjo: 'fact n' is not a valid pattern
15:06:48 <rjo> oh, parentheissis
15:07:04 <ClaudiusMaximus> rjo: also inspect "ghc --supported-languages" 
15:07:05 <azaq23> ivanm: I assumed it should since there's no error message after the let binding
15:07:15 <ivanm> laziness!
15:07:39 <ClaudiusMaximus> > let test + 4 = 10 in 3 + 4 -- i think you redefined (+)
15:07:40 <lambdabot>   10
15:08:16 <azaq23> ClaudiusMaximus: Oh, you're right, now it's obvious
15:09:13 <rjo> ok, import Prelude hiding((+)) does not work, but e.g. for (==) it works
15:10:24 <rjo> I was trying to see, if redefining (+) changes also pattern matching
15:10:33 <rjo> n+k patterns
15:11:55 <mm_freak> > let f (g + cos) = g^2 in f sin 15
15:11:56 <lambdabot>   <no location info>: Parse error in pattern
15:12:02 <mm_freak> > let f (g+cos) = g^2 in f sin 15
15:12:03 <lambdabot>   <no location info>: Parse error in pattern
15:12:08 <mm_freak> hmm
15:12:58 <mm_freak> n+k patterns work only for certain types?
15:13:11 <rjo> it must be positive int literal
15:13:15 <rjo> says haskell report
15:13:17 <monochrom> n+k pattern has nothing to do with importing (+) from Prelude or other modules.
15:13:56 <mm_freak> > let f (x+3.4) = x in f 4.4
15:13:57 <lambdabot>   <no location info>: Parse error in pattern
15:14:07 <mm_freak> > let f (x+3) = x in f 4
15:14:08 <lambdabot>   <no location info>: Parse error in pattern
15:14:12 <mm_freak> ?!
15:14:12 <lambdabot> Maybe you meant: . ? @ v
15:15:14 <rjo> monochrom: then probably k is not Int
15:15:30 <parcs> mm_freak: i think they're disabled in lambdabot
15:15:45 <mm_freak> ok
15:15:52 <raichoo> n+k patterns are no more in haskell2010 anyway
15:17:06 <rjo> oh, I should read h10 report instead of h'98
15:18:21 <mm_freak> rjo: just read on haskellwiki
15:18:25 <mm_freak> there is a summary of changes
15:21:05 <rjo> it is 329 against 277 pages
15:21:20 <rjo> not much changes
15:35:40 <byorgey> Cale: thanks =)
15:39:24 <zmbmartin> do I need to import something into ghci to have access to toUpper. I am getting not in scope?
15:39:42 <ivanm> Data.Char
15:39:50 <ivanm> :m +Data.Char
15:40:01 <shachaf> @index toUpper
15:40:01 <lambdabot> Data.Char
15:41:42 <zmbmartin> Is there a reason that is not included automatically?
15:44:49 <enitharmon> Hello -- I'm approximately the most ignorant person in the world, I'm afraid.  I am trying to install the GHC 6.12.3 binaries on CentOS in order to build the current Haskell Platform from the source.  I am getting an error which I think might have a very obvious solution; when I type ./configure it says, `checking for path to top of build tree... ./configure: line 1690: utils/ghc-pwd/ghc-pwd: 
15:44:49 <enitharmon> cannot execute binary file\n configure: error: cannot determine current directory.'  Is this an appropriate place to ask about such things?  I'm sorry that perhaps I am probably doing something which I shouldn't even be trying to do. 
15:46:58 <monochrom> this is a suitable channel. but I don't know why ghc-pwd goes wrong.
15:47:12 <benmachine> can you try running it directly?
15:48:01 <enitharmon> It just says, `cannot execute binary file.'
15:48:20 <benmachine> executable permissions?
15:48:26 <enitharmon> I'm logged in as root...
15:48:33 <benmachine> yes but
15:48:37 <benmachine> is it mode +x
15:48:39 <enitharmon> And actually everybody has +x.
15:48:42 <benmachine> oh
15:48:47 <benmachine> hmm
15:49:14 <mikeg> here's a shot in the dark: cp /bin/pwd utils/ghc-pwd/ghc-pwd
15:49:32 <enitharmon> Let me try that...
15:49:35 <benmachine> hm
15:49:40 <benmachine> that sounds like a bad idea
15:49:44 <benmachine> well
15:49:45 <benmachine> it might work
15:49:49 <benmachine> but it won't tell you what's wrong
15:49:56 <benmachine> might you have the wrong architecture binaries?
15:51:50 <enitharmon> Hm.  It is possible.  But I think I am i386 and I took the second download here: http://haskell.org/ghc/download_ghc_6_12_3#x86linux
15:52:35 <enitharmon> Let me try the copying, though...
15:52:37 <mikeg> you ran `perl boot` too?
15:52:53 <enitharmon> No-- was I supposed to?
15:52:55 <Bynbo7> enitharmon: do you have ghc installed already?
15:53:11 <enitharmon> I don't have it installed yet.
15:54:58 <monochrom> you have /lib/libtinfo.so.5 ?
15:55:21 <enitharmon> Oh!  Actually copying /bin/pwd to ghc-pwd did it...
15:55:35 <enitharmon> I do have /lib/libtinfo.so.5.
15:56:05 <enitharmon> Thank you so much... what exactly did I do?
15:56:48 <Bynbo7> enitharmon: just so you know, you need to have ghc installed to compile ghc
15:57:07 <monochrom> no one is compiling ghc
15:58:31 <enitharmon> Well, I'm doing it from the old binaries, so supposedly it should work; but it's also not something I've tried before.  I'm just following the instructions on the Platform page...
16:01:11 <mikeg> it could just be an i386/x64 mismatch.. what is your uname -a?
16:01:52 <enitharmon> It is: Linux ip-10-113-23-233 2.6.34.7-56.40.amzn1.i686 #1 SMP Fri Oct 22 18:48:33 UTC 2010 i686 i686 i386 GNU/Linux
16:02:12 <enitharmon> (You can see I'm not totally familiar with this machine because it is from Amazon's cloud...)
16:03:40 <mikeg> Ah, well the cp trick comes from http://hackage.haskell.org/trac/ghc/wiki/Building/Porting for building GHC on different targets
16:04:58 <benmachine> it looks like ghc-pwd is only necessary on windows, maybe?
16:05:18 <benmachine> it's basically pwd | sed 's#\\#/#'
16:05:31 <enitharmon> Ah, thank you.  I'll definitely keep an eye on that page as I work through the more tractable looking errors I get from make.
16:29:01 <enitharmon> mikeg, benmachine, Bynbo7, monochrom: thank you all very much for your help.  I have to be away from the machine now while it is running, but I wish you a good evening.
16:29:35 <benmachine> aww, have one too
16:32:28 <polarina> What happens when two threads attempt to write to the same handle at the same time?
16:33:05 <dankna> I could be wrong, but I would assume that there's no special attempt to make that more atomic than the underlying system calls are
16:33:16 <dankna> so you should handle synchronization yourself
16:33:25 <Eduard_Munteanu> Hm, I could use some help here... I'm writing a mutable binary tree lib, based on STRefs. I want to abstract the ST thingy completely, so I'm thinking of making a wrapping monad.
16:33:26 <polarina> All right. Thanks.
16:34:04 <Eduard_Munteanu> However I want to keep some sort of references to those tree nodes. I don't know how to do this without keeping some sort of 's' parameter to my wrapper, like the one in 'ST s a'.
16:37:01 <Eduard_Munteanu> I can't really expose the STRefs directly, because that would also expose the existentially quantified 's' parameter.
16:37:59 <Eduard_Munteanu> Should I make up my own references and use a Map internally to lookup the STRefs?
16:38:26 <Eduard_Munteanu> (I'm not sure what's the best way to approach it, though.)
16:40:00 <Eduard_Munteanu> My API would look like this, for example:  new :: a -> MutTree (MutRef a), where MutTree could be a newtype wrapper (the monad) and MutRef some sort of reference to a node.
16:47:03 <parcs> what is the strict equivalent of readFile?
16:49:01 <ivanm> parcs: do v <- readFile; return $ v `deepSeq` v ?
16:49:19 <mauke> I'd rather evaluate (length v)
16:49:59 <ivanm> duh, I was thinking readFile then did read
16:50:08 <ivanm> which is why I was using deepSeq there
16:50:16 * ivanm hasn't done any file-based I/O for a while
16:50:29 <benmachine> I'd just write a recursive version with try getLine
16:50:42 <benmachine> *hGetLine
16:51:03 <ivanm> benmachine: why?
16:51:20 <ivanm> an alternative would be to use string bytestrings/text values
16:51:34 <benmachine> iono it's just less magic :P
16:51:38 <benmachine> and I know when the close happens
17:07:06 <fysx> hey, I find I'm using functions like "fstmap f (a, b) = (f a, b)" and "sndmap f (a, b) = (a, f b)"  fairly often.  Is there an equivalent function in the libraries somewhere that I've missed?  
17:07:27 <Twey> fysx: first and second, from Control.Arrow
17:08:08 <Twey> > first (+ 1) (3, 4)
17:08:09 <lambdabot>   (4,4)
17:08:11 <gwern> fysx: hoogle would've told them, by the way
17:08:16 <Twey> > second (subtract 1) (3, 4)
17:08:16 <gwern> :t first
17:08:17 <lambdabot>   (3,3)
17:08:17 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
17:08:22 <Twey> And if you need to do them together:
17:08:37 <Twey> > ((+ 1) *** subtract 1) (3, 4)
17:08:38 <lambdabot>   (4,3)
17:08:41 <gwern> @hoogle a b c -> a (b, d) (c, d)
17:08:42 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
17:08:42 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:08:42 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
17:09:05 <fysx> hmmm
17:09:26 <fysx> thanks!
17:10:17 <benmachine> @hoogle (a -> b) -> (c, a) -> (c, b)
17:10:17 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
17:10:17 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:10:18 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
17:13:02 <fysx> any good arrow tutorials ?  
17:14:04 <fysx> that's pretty cool/bizarre (first and second that is)
17:15:09 <parcs> > Control.Arrow.first (+) (1, 1)
17:15:09 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
17:15:10 <lambdabot>    arising from a use of `...
17:15:12 <parcs> > Control.Arrow.first (+1) (1, 1)
17:15:13 <lambdabot>   (2,1)
17:16:52 <Eduard_Munteanu> How would I abstract the use of ST away? http://paste.pocoo.org/show/312318/
17:17:13 <Eduard_Munteanu> I'm thinking of doing the computations in a monad, say MutTree.
17:17:43 <Eduard_Munteanu> So creating a node is done by a function like   new :: a -> MutTree <some sort of reference>      but how?
17:21:49 <banisterfiend> Eduard_Munteanu: hi, i already know a few languages and i would like to learn haskell. however i dont want to go through the tedium and frustration of being a noobie programmer and not knowing the language. I was wondering if you could somehow just give me a tip how to become instantaneously competent at haskell without having to put in any hard work
17:22:01 <Twey> Haha
17:24:47 <Eduard_Munteanu> Hm, you could hire a competent Haskell programmer and pretend you're doing the work.
17:28:51 <monochrom> is that supposed to be trolling?
17:29:07 <monochrom> in any case, a usb port on your head might help
17:29:46 <mm_freak> banisterfiend: get reborn and do /not/ learn all the other languages ;)
17:29:59 <mm_freak> and yes, buying someone helps, too
17:30:36 <Random75> Is haskell ever used in the workplace?
17:30:50 <benmachine> yes
17:30:50 <mm_freak> Random75: i use it for a few things
17:31:18 <mm_freak> also there are companies hiring haskell programmers, although not many
17:38:57 <qfr> Hahaha I wonder how hard outsourcing Haskell development is
17:39:11 <qfr> To like... India.
17:39:31 <monochrom> very easy. you're talking to an over-supply :)
17:40:18 <Eduard_Munteanu> Bah, I could just give up and use IORefs instead of STRefs. I don't get why it's so goddamn difficult to hide an implementation detail.
17:40:39 <qfr> I bet that the market share of Haskell within in India is lower than Europe and North America though
17:40:44 <qfr> -in
17:40:55 <monochrom> no, don't insist on India. take anyone here.
17:41:25 <benmachine> Eduard_Munteanu: I guess the problem is thinking about what your run function for the MutTree monad would look like
17:41:44 <qfr> monochrom: What do you mean here? IRC is disproportionally populated by North Americans and Europeans
17:41:49 <benmachine> what type would it have
17:42:04 <monochrom> outsource to people in this channel.
17:42:48 <benmachine> tell someone you're trying to implement your program in as few characters as possible
17:42:56 <qfr> monochrom: Noo, the point wasn't the outsourcing, the point was to confront somebody who has been doing nothing but Java/C++/C/PHP for years with Haskell, for commercial reasons
17:42:57 <EvilMachine> oooh daaamn! I guess I need monadic rounding. I have a very high amount of exact .5 values in my data, and the rounding errors are approaching 50% of total!
17:42:58 <benmachine> *function
17:43:03 <benmachine> repeat for every function in the project
17:43:05 <benmachine> et voila
17:43:16 <Eduard_Munteanu> benmachine: yeah, that's something too. The idea is to use it like foo :: ... MutTree (); foo = runMutTree { x <- new 5; ... }
17:43:26 <lars9> could anyone familiar with yacc tell me if a yacc parser can generate another yacc parser from source code? like in the case of regex, when building a regex we parse a string into a regex parser, then the generated parser can be used to parse all strings to be matched.
17:43:52 <monochrom> Is lying an option? You could lie "I can outsource it to India for you", and then outsource it to us instead.
17:44:00 <Eduard_Munteanu> *runMutTree do ...
17:44:22 <benmachine> Eduard_Munteanu: ...why does foo have MutTree in its type? what do you do when you want to get MutTree out of your types?
17:44:24 <EvilMachine> lars9: hmm, yes, i think it can. isn't yacc implemented in yacc?
17:44:25 <monochrom> In fact it is observationally not a lie as long as the price is the same.
17:45:08 <Eduard_Munteanu> benmachine: I'm thinking of using MutTree as a monad in which I do all my computation. Then I could do something useful with it if I convert the inner ST to IO, or stack a WriterT on top of it.
17:45:26 <EvilMachine> monochrom: well, it is a lie. i does not hurt, so it's a rare example of a lie that is ok. ^^
17:45:50 <benmachine> Eduard_Munteanu: if all you're going to do with the inner ST is convert it to IO then you might as well use IORefs
17:46:11 <lars9> EvilMachine: is it convinient to do so? it seems easy in parsec, but im not familiar with yacc
17:46:28 <Eduard_Munteanu> benmachine: well, not really, let's say I could tack a WriterT on top of it.
17:46:49 <benmachine> Eduard_Munteanu: but then runWriterT would give you a MutTree (writertype, a)
17:46:51 <benmachine> or whatever
17:47:05 <benmachine> and you'd still need a way to get stuff out of MutTree
17:47:46 <Eduard_Munteanu> benmachine: hm yeah.
17:47:46 <benmachine> actually it'd give you MutTree (a, w) because it's backwards like that
17:47:49 <benmachine> but whatever
17:48:11 * benmachine hates bad design descisions that aren't bad enough to actually fix
17:48:19 <EvilMachine> lars9: parsec is of course much better suited for Haskell. yacc was created with C-like language in mind, from what i can tell.
17:48:48 <Eduard_Munteanu> benmachine: well I don't particularly like the fact that 's' leaks outside. Ideally, an implementation could use either IO or ST inside, and the user shouldn't care.
17:49:14 <benmachine> Eduard_Munteanu: but whether it uses IO or ST inside is important to the API
17:49:24 <benmachine> because if it uses ST it can give a pure result, but if it uses IO it can't
17:49:37 <benmachine> unless you never allow a pure result, in which case using ST doesn't gain you anything
17:50:01 <benmachine> this is why thinking about the type of the run function is important
17:50:17 <Eduard_Munteanu> benmachine: so you're saying there's no way someone can transform that monad to produce "side-effects" like Writer or IO?
17:50:30 <benmachine> huh?
17:51:13 <Eduard_Munteanu> Well, is there a way to abstract that computation away, and get out some useful values without exposing the internals?
17:51:34 <benmachine> hmm
17:51:50 <benmachine> if you have a pure run function, then you need the 's' for the same reason ST needs it, I think
17:51:52 <Eduard_Munteanu> The phantom existential technique looks a bit leaky to me.
17:52:23 <benmachine> if you allow an impure run function, you can use ST internally and then do stToIO or whatever
17:52:37 <benmachine> I'm a bit hazy on the details here
17:52:48 <Eduard_Munteanu> Actually , I was considering stToIO myself for the actual use.
17:52:48 <benmachine> but I think if you decide on a type for your run function then that will help
17:53:09 <benmachine> i.e. you decide what the user does to get information out of your monad when they're finished with it
17:53:49 <benmachine> ok my answer is just confused and you shouldn't listen to most of it
17:53:50 <Eduard_Munteanu> benmachine: I was thinking the user could stack some transformers to get the actual results out, or simply use stToIO.
17:53:54 <benmachine> but the types will help
17:54:06 <benmachine> Eduard_Munteanu: transformers tend to have result types inside the monad
17:54:15 <benmachine> so you still need a run function
17:54:28 <monochrom> You probably want http://hackage.haskell.org/package/ref-fd which can be instantiated to either IO or (ST s).
17:54:34 <banisterfiend> benmachine: dont yuou think haskell is too difficult
17:54:52 <benmachine> banisterfiend: it's way too difficult, I'm basically just making stuff up
17:54:54 <Eduard_Munteanu> monochrom: thanks, I'll have a look at it.
17:55:20 <benmachine> what you find out when you 'learn' haskell is that it's actually like a huge game of Mornington Crescent
17:55:23 <lars9> we should suggest wordpress add haskell support to its [sourcecode] tag 
17:55:40 <banisterfiend> benmachine: what is mornington crescent
17:55:44 <lars9> it supports tens of languages except haskell
17:55:54 <banisterfiend> benmachine: is haskell is difficult as git
17:55:57 <banisterfiend> as*
17:56:04 <benmachine> banisterfiend: http://en.wikipedia.org/wiki/Mornington_Crescent_(game) hth
17:56:43 <benmachine> banisterfiend: I never got that good at git so I dunno
17:56:50 <benmachine> I think haskell is hard to start off with
17:56:59 <benmachine> but once you know it it's easier than anything else
17:57:03 <Eduard_Munteanu> benmachine: I suppose my run function will unpack the "result" without exposing any state. So it would look something like runST, but that leaks type info away as well.
17:57:09 <banisterfiend> fuck that wikipedia faggot is going crazy, look on the wikipedia page, he's now changes his advert to a flashing logo and there's a 'please help' button on it
17:57:19 <banisterfiend> and he's standing there with his arms folded, what a dick
17:57:28 <Twey> benmachine: Did you just poil Mornington Crescent without giving the chap a proper initiation?
17:57:35 <Twey> spoil**
17:57:42 <benmachine> Twey: yes sry :(
17:57:48 <Twey> Shame on you
17:57:55 <benmachine> I am not really creative enough to play :P
17:58:09 <benmachine> it's fine he got distracted by shiny jimbo wales
17:58:12 <Twey> Maths in general is like that, really
17:58:15 <Twey> Haha
17:58:32 <EvilMachine> does anyone know a solution to allow rounding every second .5 value *down* in a elegant way? i specifically need this, and not to odd or even.
17:58:39 <Twey> A lot of maths is prior knowledge and terminology, I find
17:58:55 <benmachine> Twey: depends how you count, no pun intended
17:59:03 <Twey> EvilMachine: Umm, isn't that the same thing as rounding to odd?
17:59:12 <Twey> Oh, except for negatives, I guess
17:59:21 <benmachine> a lot of the maths I do is coming up with new stuff, but that's because I'm being taught it by people much cleverer than me
17:59:38 <Twey> benmachine: *Coming up* with maths, sure
18:00:04 <Eduard_Munteanu> newtype STM a
18:00:08 <benmachine> EvilMachine: sounds nasty. you change the way you compute something and suddenly all your results change
18:00:10 <Twey> But maths tends to be the sort of stuff that's blindingly obvious once someone points it out
18:00:15 <Eduard_Munteanu> So basically STM doesn't need that existential trick? :/
18:00:22 <benmachine> Twey: heh, often, but not always
18:00:31 <Twey> I suppose so
18:00:40 <benmachine> Eduard_Munteanu: STM's run function has IO in the result
18:00:49 <Eduard_Munteanu> Grr... my bad.
18:00:55 <benmachine> Twey: I always enjoy talking to people about countability and watching them go 'wat' :)
18:01:02 <Twey> Haha
18:01:14 <banisterfiend> benmachine: what type of math are you into
18:01:56 <Random75> benmachine: why on earth would you be talking to normal people about countability?
18:02:32 <benmachine> Random75: to make them go wat :P
18:02:34 <Twey> Random75: To watch them go ‘wat’ ;)
18:02:35 <benmachine> banisterfiend: all of them
18:02:41 <Eduard_Munteanu> Ok, I definitely have to revisit the how and why of the ST's phantom type trick.
18:02:41 * benmachine hi5 Twey 
18:02:44 <banisterfiend> benmachine: fourier analysis?
18:02:48 <Twey> ⁵
18:02:54 <benmachine> heh
18:03:15 <benmachine> banisterfiend: I might not have done that yet
18:03:24 <benmachine> I've done fourier series and some of fourier transforms
18:03:39 <banisterfiend> benmachine: oh you're still an undergrad :)
18:03:46 <benmachine> yes
18:03:47 <monochrom> haskell is very hard. not as hard as putting a usb port in your head.
18:04:03 * benmachine chews on an ethernet cable
18:04:05 <Random75> monochrom: you just need a hammer?
18:04:07 <Bynbo7> or putting your head in a USB port
18:04:09 <benmachine> I can taste the internet :o
18:04:26 <monochrom> but if you successfully endure a usb port in your head, I can just download haskell to it.
18:04:56 <benmachine> banisterfiend: this looks like fun http://en.wikipedia.org/wiki/Pointless_topology
18:05:00 <Bynbo7> benmachine: it tastes tingly eh
18:05:07 <dpratt71> benmachine: feel free to talk to me about countability; it's on my (long) list of things I wish to understand better
18:05:11 <benmachine> Bynbo7: bitter
18:05:16 <benmachine> and full of rage.
18:05:21 <Twey> Haha
18:05:23 <Bynbo7> heh
18:05:28 <dpratt71> "countably many" what the heck does that mean?
18:05:41 <Bynbo7> "I can taste the rage! it's hurting :("
18:05:42 <banisterfiend> benmachine: not my kind of math, im into fourier analysis and signal processing in general
18:05:45 <monochrom> eh? countability is easy. has bijection with the natural numbers. THE END
18:05:52 <dpratt71> oh
18:06:01 <Twey> ‘A peculiar scent… as of many unwashed shirts and neckbeards crying bitter tears of despair…’
18:06:06 <Random75> benmachine: Would algebraic topology be considered pointless?
18:06:24 <benmachine> Random75: I have no idea, the name just makes me giggle :(
18:06:25 * benmachine shallow
18:06:42 <Twey> dpratt71: E.G. real numbers are not countable: there's no such thing as the ‘next real number along’ because there's always another real number in between any two real numbers you pick
18:06:52 <Random75> benmachine: I don't think it would... 0-cells are points :(
18:06:53 <mauke> Twey: that argument also applies to Q
18:07:02 <benmachine> Random75: :(
18:07:07 <dpratt71> Twey: ah
18:07:28 <Random75> dpratt71: What do you want to know?
18:07:35 <Twey> mauke: Yep
18:07:45 <Twey> Rationals are uncountable, right?
18:07:52 <Random75> Twey: Yeah
18:07:58 <Twey> Okay
18:08:01 <ivanm> Twey: I think in the same way as integers though
18:08:02 <mauke> no
18:08:09 <Twey> Oh
18:08:09 <mauke> ℚ is countable
18:08:11 <benmachine> rationals are countable
18:08:16 <ivanm> then again, I might be mis-remembering
18:08:45 <Random75> woops, i misread Twey 
18:08:52 <dpratt71> Random75: nothing specific; finding math a lot more interesting after getting into Haskell
18:08:52 <benmachine> you can count them like, 1/1, 2/1, 1/2, 3/1, 3/2, 2/3, 1/3, ...
18:08:53 <Twey> Hrmph
18:08:57 <banisterfiend> Rationals are countable
18:09:12 <dpratt71> too bad I wasn't this interested in Math while still in school
18:09:15 <benmachine> hilbert's hotel
18:09:40 <Random75> benmachine: whatre you studying in school?
18:09:52 <benmachine> Random75: uhm, maths, at university
18:10:48 <dpratt71> is math (vs. maths) a US-ism?
18:10:53 <benmachine> yes
18:10:55 <Random75> dpratt71: yep
18:11:01 <dpratt71> suspected as much
18:11:14 <benmachine> we contract mathematics as maths because we pretend that anyone can remember what a mathematic is
18:11:21 <benmachine> or why there are so many of them
18:11:28 <Twey> Heheh
18:11:37 <EvilMachine> Twey: nope. suppose you have overwhelmingly many rounded-to-even values. you inevitably end up with a wrong total. same thing for many to-odd
18:11:37 <Twey> A mathematic is a field of mathematics, I think
18:11:42 <benmachine> (we = UK/commonwealth types)
18:12:24 <benmachine> Twey: in fact, you can count the set of finite subsets of natural numbers
18:12:53 <benmachine> so you can count any set whose members can be represented as a finite string from a finite alphabet :)
18:12:55 <Twey> EvilMachine: Rounding every other down means that 0.5 -> 1, 1.5 -> 1, 2.5 -> 3, 3.5 -> 3, right?
18:13:13 <Twey> Which is the same as to odd (0.5 -> 1, 1.5 -> 1, 2.5 -> 3, 3.5 -> 3)
18:13:29 <benmachine> (from a countable alphabet actually, but whatever)
18:13:36 <mauke> 0.5 -> 1, 0.5 -> 0, 0.5 -> 1, 0.5 -> 0, 0.5 -> 1
18:13:58 <Twey> Oh!  I see
18:14:02 <Twey> I misunderstood the question
18:14:05 <Twey> (and, urgh)
18:14:16 <benmachine> urgh is what I said :)
18:14:34 <benmachine> EvilMachine: can you find some other property of your numbers such that half of them have it and half of them don't, on average?
18:14:44 <benmachine> EvilMachine: it sounds really icky to have rounding depend on number of operations
18:15:06 <benmachine> very unpleasant to debug
18:15:26 <augustss> howdy
18:15:36 <mauke> http://www.xkcdb.com/?4383
18:15:37 <benmachine> howdo
18:16:40 <j-invariant> is there a self contained multivariable polynomial data type?
18:16:44 <dpratt71> just curious: would anyone dare to guess what % of #haskell participants are 'in school'?
18:16:51 <bsmntbombdood> can you write fmap in terms of >>= ?
18:17:15 <mauke> bsmntbombdood: you also need return
18:17:46 <augustss> dpratt71: what does "in school" mean?
18:17:54 <bsmntbombdood> is it just fmap f x = x >>= return . f?
18:18:01 <mauke> @src liftM
18:18:01 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:18:06 <Random75> I have an idea to try learning haskell... does categorizing a surface by using a triangulation of that surface sounds feasible for somebody just starting out haskell (using Betti numbers)? Possibly then calculating the homology groups?
18:18:10 <mauke> yes
18:18:32 <benmachine> j-invariant: if you make a single-variable polynomial type you can just make multivariable polynomials by making polynomials with polynomial coefficients, I think
18:18:33 <bsmntbombdood> liftM === fmap then?
18:18:35 <dpratt71> augustss: perhaps I should have worded it as what % are students?
18:18:38 <mauke> bsmntbombdood: yes
18:24:17 <Bynbo7> bsmntbombdood: fmap = liftA = (<$>) = liftM
18:24:40 <ivanm> Bynbo7: well, only the liftA = (<$>) is true by definition... ;-)
18:24:42 <bsmntbombdood> i've never seen liftA
18:24:46 <j-invariant> I need to sort by a monomial ordering
18:24:55 <ivanm> bsmntbombdood: it's lifting a function into an applicative
18:26:09 <ivanm> @doc Control.Applicative
18:26:10 <lambdabot> Control.Applicative not available
18:26:12 <ivanm> bah
18:26:35 <Bynbo7> :t liftA
18:26:35 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
18:28:07 <ivanm> preflex: seen tomberek
18:28:07 <preflex>  tomberek was last seen on #haskell 31 days, 20 hours, 20 minutes and 33 seconds ago, saying: ddarius: hey, sorry my internet crashed
18:28:13 <ivanm> bah
18:28:36 <benmachine> ivanm: pretty sure you could have an (law-breaking) Applicative instance with (<$>) /= liftA
18:28:49 <ivanm> benmachine: isn't it defined like that?
18:29:05 <mauke> @src liftA
18:29:06 <lambdabot> liftA f a = pure f <*> a
18:29:14 <benmachine> ivanm: nope, <$> is fmap
18:29:16 <ivanm> oh, wait, is <$> = fmap?
18:29:19 <ivanm> OK, I got them mixed up
18:29:24 <Bynbo7> @src (<$>)
18:29:24 <lambdabot> f <$> a = fmap f a
18:29:27 <ivanm> so only <$> = fmap is true by definition then
18:31:14 <j-invariant> http://www.amazon.com/Combinatorial-Structures-Encyclopedia-Mathematics-Applications/dp/0521573238 <--- WAT THE FK
18:31:18 <Bynbo7> @src (<*>)
18:31:18 <lambdabot> Source not found.
18:31:27 <Bynbo7> @src Maybe (<*>)
18:31:27 <lambdabot> (<*>) = ap
18:31:34 <j-invariant> I can't buy a book that costs 189 dollars
18:31:35 <ivanm> Bynbo7: it's a class method
18:31:40 <ivanm> j-invariant: why can't you?
18:31:54 <Random75> j-invariant: international or used?
18:32:15 <medfly> you can use the library
18:32:30 <ivanm> try book depository as well, etc.
18:32:40 <ivanm> but academic texts are often expensive, probably due to relative scarcity
18:32:48 <EvilMachine> benmachine: well, what i need is this to be true: 
18:32:50 <EvilMachine> let test x n = foldl1 (+) (replicate n x) - fromIntegral (foldl1 (+) (replicate n (round x))) in sum [ test x n | x <- [0.5,1.5..100.5], n <- [1..20] ] == 0.0
18:32:58 <j-invariant> mathematicans don't want us to know this stuff
18:33:06 <j-invariant> that's why it's so expensive
18:33:15 <ivanm> j-invariant: _publishers_ set the price
18:33:16 <medfly> heh
18:33:30 <Random75> ivanm: If it isn't scarce, they create a new edition every year and just rearange the exercises 
18:33:42 <ivanm> Random75: and it's still relatively high priced :/
18:33:58 <monochrom> hilbert's brothel is a great way to have fun with countability :)
18:34:10 <Random75> ivanm: so the market doesn't get saturated with used books, otherwise they would have to lower the price
18:34:10 <EvilMachine> guys, don't worry. publishers as they exist today, won't exist anymore soon. :)
18:34:12 <j-invariant> "I dare make a prediction on the future acceptance of this book. At first, the old fogies will pretend the
18:34:15 <j-invariant> book does not exist.
18:34:18 <j-invariant> "
18:34:38 <ivanm> EvilMachine: well, no; instead they'll be charging that much to make a copy of an electronic file :s
18:35:02 <Random75> j-invariant: is that for a graph theory class?
18:35:03 <ivanm> monochrom: is that more commonly known as hilbert's hotel?
18:35:09 <j-invariant> haha
18:35:14 <monochrom> yeah!
18:35:23 <monochrom> hotel is too boring
18:35:26 <j-invariant> Random75: no, that would be funny if it was the required text and you were exepected to buy it
18:35:27 <EvilMachine> ivanm: nope. since the internet, the point of a publisher has vanished. nobody will make contracts with them anymore.
18:35:41 <EvilMachine> ivanm: because one can simply publish it one one's own site.
18:35:57 <ivanm> EvilMachine: someone still typesets, proof-reads, etc.
18:36:02 <dankna> I agree with ivanm here.  Publishers will still make money, and people will be even more mystified about what value they can possibly be adding than they are today.
18:36:04 <ivanm> and that is the preferred approach for texts
18:36:19 <monochrom> there is some bribery from publisher to profs or department heads when choosing a textbook
18:36:20 <EvilMachine> ivanm: since when do publishers do that? ;;
18:36:22 <EvilMachine> ;)
18:36:37 <ivanm> EvilMachine: unless you personally are well known, I would be more trustful of a book with your name on it from a reputable publisher than a self-published book
18:36:44 <ivanm> EvilMachine: in _theory_ they do that
18:36:51 <ivanm> monochrom: yeah :(
18:37:04 <EvilMachine> ivanm: that's the job of proof-readers and typesetters. *publish*ers are people who take something, and spread it to the masses. minus marketing.
18:37:24 <ivanm> the publishing companies usually handle that though, don't they?
18:37:33 <ivanm> (with great failings for RWH :p)
18:38:04 <EvilMachine> ivanm: nope, i don't trust publishers further than my own nose. like Elsevier, who disguised marketing as publishing journals for doctors.
18:38:17 <EvilMachine> ivanm: what we need, are new trust networks
18:38:20 <j-invariant> I gduess you have to learn french
18:38:28 <EvilMachine> ivanm: but i'm already working on that. :)
18:38:41 <j-invariant> http://www.cambridge.org/gb/knowledge/isbn/item1154037/?site_locale=en_GB <-- 100 pounds
18:38:48 <blackdog> EvilMachine: how will you get me to trust your new trust network?
18:38:49 <ivanm> EvilMachine: pray tell
18:38:50 <j-invariant> this is something else
18:38:58 <ivanm> j-invariant: what are you after?
18:39:06 <ivanm> that specific book?
18:39:08 <j-invariant> that's 25p a page
18:39:10 <ivanm> or something on the topic?
18:39:21 <EvilMachine> ivanm: well, they won't handle it anymore, since nobody wants to buy their complete package. but yes, they might exist as typesetters and proof-readers in the future. :)
18:39:30 <j-invariant> I thought everything else on the same topic was written in french
18:39:35 <EvilMachine> ivanm: but that is a different deal, where you still control things.
18:39:49 <ivanm> j-invariant: what actual topic? combinatorial species?
18:40:07 <j-invariant> This book is the first complete presentation in English of the combinatorial theory of species, introduced by A. Joyal in 1980
18:40:21 <ivanm> EvilMachine: you would still need someone to handle distribution, etc.
18:40:38 <EvilMachine> blackdog: my trust network will be a small piece of open source software. you don't have to trust more than the people you already trust, plus a code check from one of them.
18:40:49 <EvilMachine> blackdog: or from one they trust.
18:40:58 <EvilMachine> blackdog: or... so on
18:41:21 <ivanm> preflex: seen Cale 
18:41:21 <preflex>  Cale was last seen on #haskell 5 hours, 51 minutes and 27 seconds ago, saying: No idea
18:41:31 <EvilMachine> ivanm: what distribution? distribution is called "putting a link in a directory" nowadays. ^^
18:41:43 <ivanm> EvilMachine: people usually want to make money off of these things...
18:41:45 <dankna> I fail to see how an exercise in graph theory or whatever your trust network thing is is going to convince me to buy academic books that haven't had peer review.
18:41:55 <ivanm> especially if you're paying someone for proof-reading and type-setting
18:42:20 <ivanm> dankna: well, peer-review isn't necessarily done by the publishers either
18:42:24 <dankna> granted
18:42:25 <blackdog> EvilMachine: I guess it was more of a social question than a theoretical one. I use software from people i don't trust every day - it'd be very hard not to.
18:42:36 <EvilMachine> ivanm: well, since information is not a physical object, they can make money by treating ther work as a service. that's the proper business model anyway. :)
18:42:38 <dankna> but my basic point is that even if all the publisher did were add their name to it
18:42:40 <ivanm> and it depends on the topic: does an introductory programming text need peer review?
18:42:44 <dankna> that would still be a genuine value
18:42:57 <ivanm> EvilMachine: what, you really think that's going to happen?
18:43:13 <j-invariant> why would a book need to be peer reviewed?
18:43:20 <j-invariant> the papers it cites would be
18:43:33 <dankna> depends on the book, really
18:43:40 <EvilMachine> blackdog: well, with my trust network you could actually achieve trusting every single piece of software and hardware you use.
18:43:42 <dankna> but I should have used a better example
18:43:43 <parcs> @hoogle (.:) -- which module exports that?
18:43:43 <lambdabot> Parse error:
18:43:43 <lambdabot>   --count=20 "(.:) -- which module exports that?"
18:43:44 <lambdabot>                   ^
18:43:51 <EvilMachine> blackdog: if your complete network of trust includes people that checked it all,
18:43:55 <EvilMachine> :)
18:44:12 <EvilMachine> ivanm: i can prove that it will not only happen, but is inevitable.
18:44:28 <blackdog> EvilMachine: that sounds very binary :) trust is often a fuzzy and probabilistic thing
18:44:45 <ivanm> parcs: where did you find that operator?
18:44:49 <EvilMachine> blackdog: you are of course correct. :) i just simplified it.
18:44:59 <ivanm> EvilMachine: where is this proof you claim to have?
18:45:14 <parcs> @type (.:)
18:45:15 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
18:45:27 <EvilMachine> blackdog: in reality, you could measure the trust in your hard-/software as a number between 1.0 (complete) and 0.0 (not at all) and then decide if that's enough. :)
18:45:28 <ivanm> @hoogle (.:)
18:45:29 <lambdabot> No results found
18:45:29 <parcs> ivanm: it's user-defined here, i think. but i remember seeing it in another package
18:45:56 <EvilMachine> blackdog: or let someone in your trust network decide. (from 0.0..1.0 to binary) :)
18:45:57 <ivanm> hayoo says synthesizer
18:46:07 <ivanm> but with a different type sig
18:46:11 <ivanm> @type fmap fmap
18:46:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
18:46:16 <ivanm> @type fmap . fmap
18:46:17 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:46:24 <ivanm> parcs: ^^
18:46:38 <EvilMachine> ivanm: bit late for that proof right out of your head. with some time (1-2h) on another day, i could do it.
18:46:42 <EvilMachine> :)
18:46:51 <ivanm> excuses, excuses!
18:46:52 <blackdog> EvilMachine: you'd almost want a drop-off
18:46:59 <j-invariant> does haskell have monoid instances for () and proudct?
18:47:10 <EvilMachine> ivanm: i know that i have proven it once. i don't care for the approval of others. :)
18:47:22 <blackdog> ie, i trust ivan 90%, so if he trusts someone else 90% I trust them 81%...
18:47:40 <EvilMachine> ivanm: it's ok if you don't trust my opinion right now. :)
18:47:44 <monochrom> has Monoid instance for ()
18:47:46 <j-invariant> does haskell have natural number?
18:47:53 <EvilMachine> blackdog: exactly.
18:47:55 <blackdog> i'm reminded of the PKI debacle, though
18:47:56 <monochrom> no natural number
18:47:59 <ivanm> j-invariant: there are various Nat and Natural types
18:48:02 <ivanm> in other libraries
18:48:04 <ivanm> there's also Word
18:48:08 <blackdog> there were meant to be registrars, and webs of trust, and all this stuff
18:48:14 <EvilMachine> blackdog: but there is no absolute trust. trust always is in relation to some topic or something.
18:48:17 <blackdog> well, less so the web of trust stuff
18:48:28 <blackdog> but that big creaking edifice of RAs and CAs
18:48:32 <ivanm> blackdog: and flying cars, don't forget the all-important flying cars!
18:48:38 <dankna> some of it is happening, with EV certs
18:48:45 <EvilMachine> blackdog: i may trust ivanm and you on haskell topics. but flirting tips...? ;)
18:48:48 <dankna> but yes, the CAs are just rubberstamping whatever they're paid to rubberstamp
18:48:59 <ivanm> EvilMachine: heh, I wouldn't trust _myself_ for flirting tips ;-)
18:49:01 <dankna> most of the time at least
18:49:14 <dankna> moon cities.  I want moon cities.
18:49:27 <EvilMachine> ivanm: i could help you with that though. :)
18:49:37 <dankna> with rockets that land on their tailfins, as God and Robert Heinlein intended
18:49:37 <monochrom> next eclipse will eat the moon cities
18:49:49 <ivanm> EvilMachine: eh, no real opportunities to put them into practice :(
18:50:10 <dankna> monochrom: egads, I didn't think of that!
18:50:14 <EvilMachine> ivanm: i wrote a tool to calculate how the trust a person has in you changes with his state, experience and what you say/do
18:50:47 <EvilMachine> ivanm: ok, this is becoming majorly off-topic. but i still wonder: why not?
18:51:03 <fqsxr> newbie Q: why this doesn't compile??
18:51:03 <fqsxr> foo :: (Num a) => a
18:51:04 <fqsxr> foo = 1 :: Int
18:51:29 <EvilMachine> on topic: does anyone know a replacement for "round" that can make this True?
18:51:31 <EvilMachine> let test x n = foldl1 (+) (replicate n x) - fromIntegral (foldl1 (+) (replicate n (round x))) in sum [ test x n | x <- [0.5,1.5..100.5], n <- [1..20] ] == 0.0
18:51:51 <monochrom> "Int" contradicts "(Num a) => a"
18:51:55 <EvilMachine> (ok, using "==" is bad here. but you know what i meant)
18:52:17 <fqsxr> isn't Int a type of Num?
18:52:22 <banisterfiend> EvilMachine: i dont know anything about that. But i do know that friendship is important and i'd like to be your friend. And who knows, with a friend like me at your back, you may have the confidence to go on and solve this difficult problem.
18:52:26 <monochrom> yes. irrelevant.
18:53:12 <erikina> fqsxr: as I understand it, your declaration has said "a is a Num" -- and then you contradict that declaration to say "a is an Int (and not generic, like a Num"
18:53:21 <blackdog> EvilMachine: you should definitely trust me on flirting tips more than you trust me on haskell:)
18:53:52 <erikina> tips on how to flirt itself? Or tips on getting results with flirting?
18:53:59 <EvilMachine> banisterfiend: my good state right now, multiplied by two positive triggers and a negative one, cause an overall small rise in trustworthiness for you. :)
18:54:18 <EvilMachine> blackdog: lool. so bad at haskell?
18:54:47 <blackdog> EvilMachine: either that, or just so smooth it hurts.
18:54:58 <monochrom> tips on how to flirt haskell
18:55:05 <EvilMachine> blackdog: i want to see that. :)
18:55:21 <erikina> By hurts, i assume he gets slapped a lot?
18:55:34 <blackdog> EvilMachine: *grin* retired now. my girlfriend treats me too well.
18:55:45 <EvilMachine> well, if you can combine haskell with positive triggers in her, it will cause a positive reaction. simple. :)
18:56:28 <blackdog> erikina: a slap is just enthusiastic flirting.
18:56:31 <EvilMachine> blackdog: ok. happy for you. :)
18:56:50 <lars9> @src sequence
18:56:50 <lambdabot> sequence []     = return []
18:56:50 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:56:51 <lambdabot> --OR
18:56:51 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:56:51 <freedrull> what would be a good way to pass the string from readFile to pack here? change the hello function to type IO Application?
18:56:57 <freedrull> http://pastebin.com/zqyV4M5z
18:56:59 <banisterfiend> when enjoy a bit of roughness, it makes them feel they're desired
18:57:21 <banisterfiend> women*
18:57:45 <freedrull> women want you to make fun of them
18:57:46 <erikina> banisterfiend: how has that held up in court?
18:57:47 <blackdog> banisterfiend: hey, i meant _getting_ slapped.
18:58:09 <monochrom> yeah if you have readFile, you involve IO.
18:58:45 <banisterfiend> erikina: depends on the lawyer ;) 
18:58:49 <monochrom> But I don't know this Hack.Happstack business so I don't know what is expected
18:59:21 <banisterfiend> erikina: appeals to human nature actually do pretty well, so long as you have professors of status to back it up
18:59:38 <banisterfiend> they've worked successfully in the provocation defense for example
18:59:45 <freedrull> run :: Application -> IO () -- Defined in Hack.Handler.Happstack
19:00:21 <mikeg> type Application = Env -> IO Response
19:00:23 <EvilMachine> this has *got* to be the most crazy/awesome channel on the web! ;)
19:00:42 <EvilMachine> one line: haskell crazyness. another line: pickup talk
19:00:50 <lars9> @pl foldl1 (>=>)
19:00:51 <lambdabot> foldl1 (>=>)
19:00:59 <freedrull> EvilMachine: :P
19:01:06 <erikina> I can just picture it now. Michael Jaskon's "Human Nature" playing softly in the background and banisterfiend speaks up "Your honor. She enjoyed it."
19:01:47 <mikeg> freedrull: something like: \env -> readFile "..." >>= (\contents -> def { body = contents })
19:02:54 * hackagebot mysnapsession 0.1 - Memory-backed sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.1 (ChrisSmith)
19:05:41 <j-invariant> say you have a monoid on haskell
19:05:59 <j-invariant> and you want to chek if it's 0 or 1.. how do you do that
19:06:29 <c_wraith> What?  You mead additive or multiplicative?
19:06:51 <c_wraith> err, *mean
19:07:09 <j-invariant> Ill use Integer instead of Monoid m
19:07:27 <c_wraith> Integer isn't an instance of Monoid anyway.
19:07:56 <c_wraith> Mostly because there are two very obvious ways to make it one, and probably infinite less-obvious ways.
19:09:01 <c_wraith> :t Sum
19:09:02 <lambdabot>     Ambiguous occurrence `Sum'
19:09:02 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
19:09:02 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
19:10:18 <Cale> Certainly infinitely many less obvious ways :)
19:11:19 <c_wraith> I guess either add or multiply with "mod x", for all x
19:11:40 <c_wraith> maybe all positive x.
19:11:59 <c_wraith> And probably lots of other ways to get infinite options, too :)
19:12:44 <freedrull> *sigh* cabal took over half an hour to link :0
19:13:01 <c_wraith> how much ram do you have?
19:13:10 <ivanm> not enough I would guess
19:13:21 <ivanm> and I don't think gold works with ghc IIRC
19:14:56 <freedrull> c_wraith: 256megs on this vps ;3
19:14:56 * hackagebot mysnapsession-example 0.1 - Example project using mysnapsession  http://hackage.haskell.org/package/mysnapsession-example-0.1 (ChrisSmith)
19:15:14 <c_wraith> freedrull, yep, that's not enough for linking ghc programs, in general.
19:15:15 <Cale> c_wraith: Yeah, basically any countable monoid together with a (computable) bijection to Integer :)
19:15:53 <Cale> Most of those will be really weird things though :)
19:21:27 <monochrom> manateelazycat used the gold linker with ghc successfully, I heard.
19:22:38 <ivanm> hmmm
19:26:51 <parcs> is there any way to go from polymorphic -> specific strings when using OverloadedStrings?
19:27:00 <parcs> oops, i mean specific -> polymorphic
19:27:34 <shachaf> @src IsString
19:27:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:27:42 <shachaf> class IsString a where fromString :: String -> a
19:27:52 <parcs> nice!
19:32:51 <ivanm> which is precisely how OverloadedStrings works
19:38:17 <lars9> @instances Monad
19:38:18 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
19:47:18 <FreezingCold> How much would getting connected with canarie cost?
19:48:51 <ivanm> FreezingCold: huh?
19:49:03 <ivanm> do you know what this channel is?
19:49:22 <FreezingCold> Not really :/
19:49:30 <ivanm> it's about the programming language Haskell
19:49:45 <ivanm> I have no idea what you're referring to
19:49:58 <ivanm> if you don't know what this channel is for, why did you come in here (just curious)?
19:50:08 <FreezingCold> because nobody knows what I'm talking about :/
19:50:12 <FreezingCold> Thought I might get lucky here
19:50:44 <medfly> ?
19:50:50 <ivanm> well, if you know what canarie is, why not ask someone involved with it, what ever it is?
19:50:50 <medfly> maybe because you're only providing a name
19:51:00 <FreezingCold> It's a ISP
19:51:12 <ivanm> FreezingCold: why not check out their web page?
19:51:17 <ivanm> or ring them up?
19:51:17 <FreezingCold> they don't say
19:51:18 <medfly> call them
19:51:18 <freedrull> mikeg: 
19:51:25 <ivanm> since they would surely know their own fees and charges...
19:59:33 <valium97582> the last time I've seen #haskell this quiet was... was...
19:59:39 <valium97582> I can't remember really.
19:59:53 <ivanm> this time yesterday
19:59:53 <ivanm> :p
20:00:06 <Twey> It's what happens at four in the morning
20:00:14 <ivanm> @time
20:00:15 <lambdabot> Local time for ivanm is Fri Dec 31 13:59:48
20:00:17 <ivanm> I beg to differ!
20:00:17 <ivanm> :p
20:00:18 <medfly> which is interesting, because it's 6am here.
20:00:22 <Twey> Hehe
20:00:31 <medfly> anyway, this place is always full of crap
20:00:36 <blackdog> suspect half the waking people here are australians:)
20:00:44 <Random75> What do you use for Haskell on windows?
20:00:56 <Cale> Random75: GHC
20:01:06 <medfly> blackdog, maybe suspect all of them are nerds and unrestricted by timezones
20:01:08 <ivanm> Random75: a Linux live CD :p
20:01:25 <Twey> Heh
20:01:27 <Random75> ivanm: I don't feel like switching over to linux lol. 
20:01:30 <Twey> Random75: http://hackage.haskell.org/platform/
20:01:38 <medfly> Random75, I just fetched haskell platform, but it's probably easier to use putty 
20:01:39 <Cale> Random75: Well, probably on Windows, the Haskell Platform (which includes GHC and a bunch of other stuff) is a good way to get set up quickly.
20:02:00 <Cale> Hehe, stereo :)
20:02:06 <djahandarie> @time
20:02:09 <lambdabot> Local time for djahandarie is Thu Dec 30 23:45:46 2010
20:02:14 <djahandarie> Don't underestimate my timezone. ;)
20:02:25 <ivanm> djahandarie: where are you?
20:02:29 <medfly> america
20:02:38 <medfly> eastern
20:02:40 <medfly> so hard?
20:02:55 <djahandarie> medfly... you should probably check what time it is in EST right now then
20:03:06 <medfly> I didn't say a specific timezone, asshole
20:03:16 <ivanm> medfly: I have nfi what the USA timezones are
20:03:20 <Twey> 040252 Thu Dec 30 23:02:52 EST 2010
20:03:25 <Twey> Wha'
20:03:35 <Twey> One of those crazy half-timezones?
20:03:40 <medfly> ivan, they're several hours less than europe/africa
20:03:44 <djahandarie> Not only half. Quarter.
20:04:04 <ivanm> medfly: "several" is rather non-specific :p
20:04:04 <Twey> That's even nuttier
20:04:16 <blackdog> medfly: we've probably got more work-whenever-graduate-student types here than usual, true.
20:04:46 * Twey didn't think it went below half-hours
20:04:55 <djahandarie> My time zone is...
20:04:55 <medfly> ivan, it depends on where you are too, and combining the two errors makes anything I say kinda redundant ("about 4-12 hours")
20:05:09 * hackagebot mysnapsession 0.1.1 - Memory-backed sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.1.1 (ChrisSmith)
20:05:12 <tsbo> @time
20:05:13 <lambdabot> Local time for tsbo is 2010-12-31 12:04:45 +0800
20:05:23 <djahandarie> "The clock in this server runs a little whacky and doesn't have ntpd" timezone
20:05:29 <Twey> Haha
20:05:42 <Twey> Hey, my server is in that timezone, too ;)
20:05:46 <ivanm> medfly: well, I meant +/- UTC
20:06:12 <mikeg> freedrull: ?
20:19:01 <freedrull> mikeg: any tips? http://pastebin.com/KGQmR2F4
20:20:13 <mikeg> get rid of the IO, and >>= (\def -> return def) is redundant
20:20:29 <mikeg> type Application = Env -> IO Response -- Application already has the IO monad
20:21:25 <sshc> Why did GHC 6.12 deprecate ImprecativeTypes?
20:23:39 <sshc> What should I use instead if I have a list of functions of type :: Integer -> a, where a is a member of typeclass "Foo"?
20:25:34 <ivanm> :: (Foo a) => Integer -> a
20:25:46 <ivanm> or are all the a's of a different type?
20:26:05 <j-invariant> how many new programming languages are made a month?
20:26:50 <ivanm> depends if you count toy languages that someone makes that never really sees the light of day or not
20:27:20 <djahandarie> Man, Hackage is still incredibly slow for me and I have little clue as to why
20:27:45 <djahandarie> It's the only box that has ever done this to me and it is unfortunately one that I use regularly
20:28:33 <valium97582> ivanm: and don't forget the DSLs
20:28:33 <ivanm> how is Hackage slow?
20:28:38 <ivanm> valium97582: oh, right
20:29:32 <EvilMachine> ! let test x n = foldl1 (+) (replicate n x) - fromIntegral (foldl1 (+) (replicate n (round x))) in sum [ test x n | x <- [0.5,1.5..100.5], n <- [1..20] ] == 0.0
20:29:41 <EvilMachine> hmm, how does this work?
20:30:26 <sshc> ivanm: It's a list of functions, not a function, so :: [(Foo a) => Integer -> a]
20:31:07 <ivanm> sshc: you need some kind of "data Bar a = (Foo a) => Bar a" type, similar to how hlist works IIRC
20:31:23 <sshc> ivanm: I'm wondering what the difference between "(Foo a) => [Integer -> a]" and "[(Foo a) => Integer -> a]" is
20:31:48 <ivanm> sshc: the former says all the `a's are the same; the latter is usually used to mean that the `a's can be unique
20:34:41 <elliott> what's the correct cabal-install version for ghc 7? It's complaining about the cabal version. ...unless ghc doesn't come with cabal any more?
20:35:11 <c_wraith> elliott, cabal and cabal-install are not the same.
20:35:20 <c_wraith> ghc comes with cabal, but not cabal-install
20:35:21 <elliott> c_wraith: of that i am aware :)
20:35:22 <sshc> cabal comes in bags
20:35:28 <c_wraith> So which are you asking about?
20:35:30 <elliott> Configuring cabal-install-0.8.2...
20:35:30 <elliott> Setup.hs: At least the following dependencies are missing:
20:35:30 <elliott> Cabal ==1.8.*,
20:35:32 <elliott> cabal-install
20:35:37 <elliott> on a fresh, from-source GHC 7 install
20:35:44 <elliott> do I need to use a darcs version or something?
20:36:14 <c_wraith> I would try it.
20:36:18 <c_wraith> I don't actually know
20:36:46 <elliott> well, that's why I'm asking #haskell :)
20:37:06 <elliott> ghc-pkg tells me I have cabal 1.10.
20:37:14 <EvilMachine> how can i make "sum $ map round $ replicate 20 1.5" equal "sum $ replicate 20 1.5"? (alternatively with 1.5 being any other .5 number)
20:37:48 <c_wraith> EvilMachine, you would need stateful rounding for that.  Which can't happen in a pure function.
20:38:11 <EvilMachine> c_wraith: what i thought too... :/
20:38:31 <c_wraith> > map round [1.5, 2.5] :: Int
20:38:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:38:32 <lambdabot>         against inferred type ...
20:38:36 <c_wraith> > map round [1.5, 2.5] :: [Int]
20:38:37 <lambdabot>   [2,2]
20:38:41 <c_wraith> But there is that :)
20:38:43 <EvilMachine> c_wraith: is there a existing or normally used solution for the problem?
20:39:27 <c_wraith> EvilMachine, my solution is not ever depending on properties like that.  Somehow, it never matters for code I write.  Possibly because of the domain I work in.
20:39:29 <EvilMachine> c_wraith: i want to avoid having to use monads. maybe a bare state-tracking variable?
20:39:32 <elliott> Oh dear... to get the darcs cabal-install I need darcs.
20:39:36 <elliott> To get darcs I need a bunch of cabal packages.
20:40:00 <c_wraith> elliott, you can get a cabal-install binary from a different version of GHC.  That's probably easiest.
20:40:04 <EvilMachine> c_wraith: well, correct. except that i'm in that very rare situation where it *does* matter. 
20:40:07 <EvilMachine> ;/
20:40:21 <elliott> c_wraith: yes. and then get darcs, and get the new cabal-install, and install that. joy :)
20:40:44 * elliott is sceptical that anyone's made OS X binaries of cabal-install though.
20:40:48 <EvilMachine> elliott: emerge ghc # done. (?) ;)
20:42:12 <zmbmartin> Why is round 2.5 -> 2
20:42:37 <EvilMachine> zmbmartin: because haskell rounds to even numbers on exact .5
20:42:43 <j-invariant> zmbmartin: 2.5 probably is notation for 2.4444672 or something stupid
20:42:52 <elliott> EvilMachine: I'm compiling it by hand for a _reason_, dammit, and that's because I'm crazy!
20:42:58 <j-invariant> no I'm wrong
20:42:58 <EvilMachine> zmbmartin: the reason is, because always rounding up on .5 would cause an uneven distribution
20:43:25 <zmbmartin> OK thanks
20:43:34 <c_wraith> yeah, 2.5 is exact in a Double.  It really is about the distribution of rounded values.
20:43:55 * EvilMachine turns into the "Oh... OK" owl. (@elliott) ;)
20:44:44 <EvilMachine> zmbmartin: only when you want what i want above (for the total sum to stay the same) this still is not good enough.
20:44:54 <zmbmartin> It looks like odds round up and evens round down.
20:45:19 <EvilMachine> zmbmartin: map round $ [0.5,1.5..10.5] == [0,2,2,4,4,6,6,8,8,10,10] /= [1,2,3,4,5,6,7,8,9,10,11]
20:46:10 <ivanm> http://en.wikipedia.org/wiki/Bankers_rounding#Round_half_to_even
20:47:40 <tolkad> My computer seems to be missing the ar command after an OS update and cabal doesn't like that
20:47:55 <djahandarie> ivanm, it simply takes ages to load every single page for me. From any computer on this connection
20:48:02 <tolkad> any ideas how I could fix this?
20:48:11 <ivanm> djahandarie: for hackage? have you tried clearing your cache, etc.?
20:48:25 <elliott> tolkad: um being without ar is not a good thing
20:48:30 <djahandarie> Yes, and this has been happening for nearly a year now
20:48:33 <elliott> tolkad: you might want to look into getting that fixed
20:48:34 <ivanm> tolkad: lemme find which package it's in for me
20:48:34 <djahandarie> Even pings take forever
20:48:43 <tolkad> ivanm: it's a unix command
20:48:46 <ivanm> djahandarie: just to hackage or to other sites as well?
20:48:59 <zmbmartin> I am just learning haskell and the rounding is interesting. Ruby does not do that.
20:49:02 <ivanm> tolkad: yeah, but presumably from a specific distro package...
20:49:02 <tolkad> elliott: I'm on Mac OS X. I am not sure why I am missing ar... but it's definitely not there
20:49:09 <zmbmartin> Thanks for the examples
20:49:12 <ivanm> oh, not linux
20:49:16 <djahandarie> ivanm, just hackage
20:49:18 <elliott> tolkad: that's ... not good
20:49:23 <elliott> i have ar here btw
20:49:25 <elliott> day-old mac
20:49:33 <tolkad> I installed 10.6 recently
20:49:38 <elliott> tolkad: try reinstalling XCode?
20:49:39 <tolkad> why would it delete ar though 0_o
20:49:57 <elliott> the thing about apple is that they never do anything that makes sense :-)
20:49:59 <tolkad> elliott: ugh long download
20:50:08 <tolkad> I'll get started on it I guess
20:50:13 <EvilMachine> djahandarie: how about that server compressing technology that they use in opera mini? would that help with your slow connection?
20:50:19 <elliott> tolkad: if you have an OS X DVD lying around, it'll be on the second disc
20:50:24 <elliott> that might be an older version though
20:50:31 <tolkad> yeah
20:51:04 <EvilMachine> zmbmartin: there is a lengthy discussion about the rounding on the mailing list: http://www.mail-archive.com/haskell-cafe@haskell.org/msg47982.html
20:51:15 <EvilMachine> zmbmartin: an interesting read
20:51:28 <zmbmartin> EvilMachine: cool thanks
20:51:29 <elliott> tolkad: but since you obviously *bought* 10.6 *legitimately* XCode should be on that disc, right? ;-)
20:51:54 <EvilMachine> zmbmartin: wikipedia's page on rounding fills the gaps.
20:52:15 <EvilMachine> elliott: you mean *licensed*. nobody can buy software. ^^
20:52:48 <elliott> EvilMachine: I can conceive of a program where everyone who buys it gets the rights to it under the agreement that they transfer the rights to the next person to buy it.
20:53:07 <tolkad> elliott: I did bye it actually. I'll go check the disk
20:53:10 <tolkad> buy*
20:53:30 <elliott> tolkad: yeah I'm not actually sure if you get the second disc if you buy an OS upgrade rather than what comes with the Mac ... or if there even are two DVDs any more
20:53:43 <elliott> (this is an Air so it just came with a tiny USB drive ...)
20:55:52 <EvilMachine> elliott: buying is defined as paying to own something. for something to be owned, you have to be able to control it.
20:56:00 <EvilMachine> elliott: and how do you control information when you have already passed it on?
20:56:08 <tolkad> Yup, there's XCode, thanks elliott
20:56:16 <elliott> EvilMachine: you have to delete your current copy when the next person dies it, duh
20:56:18 <elliott> tolkad: no problem :)
20:56:33 <elliott> EvilMachine: honestly, it's not COMPLICATED :D
20:57:03 <EvilMachine> elliott: computers have no delete or move function. they have copying and overwriting. which is also copying. and moving is copying with "deletion".
20:57:36 <EvilMachine> elliott: :)
20:57:52 <elliott> EvilMachine: transfer across network; overwrite with zeroes
20:57:56 <elliott> (Except in legalese.)
20:58:05 <EvilMachine> elliott: i've thought about this topic *a lot*. 
20:58:05 <pedro3005> if I have a list and I want to divide it into lists of defined length, is there a standard haskell function for that? like divide 2 [1, 2, 3, 4] = [1, 2], [3, 4]
20:58:06 <EvilMachine> :)
20:58:06 <elliott> EvilMachine: I CAN MAKE WATER DRY IF I TRY HARD ENOUGH
20:58:10 <tolkad> Have we moved into an "information wants to be free" debate just because elliott used the word "bought" when talking about information?
20:58:18 <EvilMachine> elliott: well, you freeze it. duh
20:58:19 <elliott> EvilMachine: Yeah yeah, I'm all on the anti-copyright bandwagon too, I'm just kidding.
20:58:27 <elliott> tolkad: Technically I referred to bought as in a disc.
20:58:45 <elliott> I don't think anybody denies it's perfectly all right to sell discs with information on them (heck, GNU link to services that do so IIRC)
20:58:51 <elliott> but this is really offtopic.
20:59:00 <EvilMachine> elliott: i'm not on a bandwagon. i don't like bandwagons. :) i thought about i a lot, because i wanted to check for mynelf
20:59:32 <EvilMachine> elliott: lool. if this is off-topic (and it is), then what was that above about picking up girls? :P
20:59:54 <elliott> I didn't even see that :p
21:00:05 <EvilMachine> elliott: no girls for you then. ;)
21:00:28 <elliott> I don't think #haskell is top on my (non-existent) list of places to go to figure out how to obtain girls.
21:00:33 <gienah> @vixen
21:00:33 <lambdabot> you're cute. :)
21:00:42 <alej> haha 'obtain'
21:00:47 <EvilMachine> elliott: lool. agreed
21:00:59 <EvilMachine> who got lambdabot ot say that?
21:01:03 <elliott> gienah.
21:01:06 <gienah> @vixen list of places to go to figure out how to obtain girls?
21:01:07 <lambdabot> let me answer that later, okay?
21:01:17 <elliott> alej: I make inventories of all the girls I have obtained!
21:01:23 <gienah> @vixen doing anything tonight?
21:01:23 <lambdabot> is that really what you want to know?
21:01:27 <EvilMachine> @vixen what are you?
21:01:27 <lambdabot> i truely am
21:01:33 <aefjt> @. vixen quote
21:01:34 <lambdabot> i'm 19
21:01:46 <elliott> @. vixen yow
21:01:46 <lambdabot> i find it hard to masturbate when the lights are on.
21:01:48 <EvilMachine> @vixen hope that you don't become like Bucket.
21:01:48 <lambdabot> yeah, i like
21:01:54 <gienah> @vixen what's this channel about?
21:01:55 <lambdabot> i dunno, what about?
21:02:03 <pedro3005> so...... anyone?
21:02:05 <elliott> @faq Can lambdabot do @vixen?
21:02:05 <lambdabot> The answer is: Yes! Haskell can do that.
21:02:07 <EvilMachine> Haskell?
21:02:17 <elliott> pedro3005: what's the question
21:02:25 <pedro3005> if I have a list and I want to divide it into lists of defined length, is there a standard haskell function for that? like divide 2 [1, 2, 3, 4] = [1, 2], [3, 4]
21:02:27 <aefjt> @hackage split
21:02:28 <lambdabot> http://hackage.haskell.org/package/split
21:02:33 <cads> Hey, would it be hard to use H to scrape search results?
21:02:34 <gienah> @vixen would you like to come back to my place to look at my paintings?
21:02:35 <lambdabot> i might :)
21:02:48 <EvilMachine> @faq Can lambdabot give the answer to life, the universe and everything?
21:02:48 <lambdabot> The answer is: Yes! Haskell can do that.
21:03:13 <EvilMachine> @lambdabot I'd like to see that.
21:03:13 <lambdabot> Unknown command, try @list
21:03:13 <cads> Specifically, I want to query the Online Encyclopedia of Integer Sequences
21:03:23 <EvilMachine> @vixen I'd like to see that.
21:03:23 <lambdabot> I consider rabits as an endangered species.
21:03:27 <cads> wait a sec, lemme see if they have any kind of api already
21:03:39 <aefjt> @hackage oeis
21:03:40 <lambdabot> http://hackage.haskell.org/package/oeis
21:03:59 <tolkad> elliott: You said you are anti-copyright. Do you support the complete abolition of copyright law?
21:04:24 <EvilMachine> elliott: i think there is no point in living in a delusional reality. :)
21:04:45 <EvilMachine> tolkad: oops, i thought elliott had written that.
21:04:45 <elliott> tolkad: now who's turning the channel into a debate :)
21:05:29 <EvilMachine> Can we go back to the practical application of Haskell for picking up girls? I mean what's the point of everything else anyway? :P
21:05:38 <tolkad> Great, reinstalling XCode fixed ar
21:05:58 <pedro3005> I imported Data.List and it still says splitEvery is out of scope
21:06:13 <gienah> @vixen I'm only in it for the chicks
21:06:13 <lambdabot> we get along well, you know?
21:06:14 <aefjt> pedro: you need to install the split package
21:06:36 <pedro3005> I see
21:07:52 <aefjt> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) [1..10]
21:07:53 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
21:10:18 <elliott> does Cabal support separate run-time and install-time prefixes?
21:10:28 <elliott> i.e. build executables as if they're going into /foo, but actually put the files in /bar.
21:12:06 <freedrull> do you need a certain version of ghc or something for mps to work? this won't compile even though i have mps installed... http://pastebin.com/Skc2ZE2F
21:13:17 <gienah> elliot: runghc ./Setup.hs register ${VERBOSE} --gen-pkg-config=%{name}-%{version}.conf
21:13:28 <gienah> elliot: runghc ./Setup.hs copy ${VERBOSE} --destdir=${RPM_BUILD_ROOT}
21:14:05 <gienah> elliot: then later when installing it: /usr/bin/ghc-pkg register --global --force %{_cxx_libdir}/ghc-%{ghc_version}/%{name}-%{version}/%{name}-%{version}.conf
21:14:34 <gienah> elliot: and uninstalling it: /usr/bin/ghc-pkg unregister --global --force %{name}-%{version}
21:14:42 <elliott> gienah: thanks ... although, actually, question
21:14:52 <elliott> does GHC actually record the build location in any compiled output?
21:15:07 <elliott> if not, then setting the prefix to /bar and then later putting the files in /foo should work just fine, right?
21:16:41 <gienah> elliot: I do not really know, I am sort of guessing that ghc just records where it is installed when the package is registered, hence the deferred registeration
21:17:18 <elliott> gienah: right ... I don't suppose I can coerce cabal-install into doing this either.
21:19:01 <elliott> does anyone know if cabal _does_ record paths on register?
21:20:01 <elliott> eurgh. it does
21:20:42 <tolkad> huh, Parsec is cool. it made writing a lambda function parser trivial if incredibly inefficient due to my use of try for detecting application
21:21:20 <tolkad> but I didn't need it to be inefficient anyway
21:21:25 <tolkad> efficient*
21:21:42 <gienah> elliot: so in the step: runghc ./Setup.hs register ${VERBOSE} --gen-pkg-config=%{name}-%{version}.conf it does not actually register, it just writes a file that is used to register it later after its installed in the final location
21:22:31 <gienah> elliot: maybe the fedora packaging guide might give some hints: http://fedoraproject.org/wiki/Packaging:Haskell
21:24:33 <j-invariant> I'm using GTK
21:25:22 <j-invariant> i have a text box you type things in and hit enter to "do" them -- anyone know how to make it so when you press the up arrow it gives you history?
21:25:56 <EvilMachine> ok, bye all. have a nice new year's eve! go out for a change and party like it's the last time ever! :D
21:26:03 <j-invariant> bye!
21:26:03 <gienah> elliot: the solaris spec file I copied those lines above from: http://pkgbuild.svn.sourceforge.net/viewvc/pkgbuild/spec-files-extra/trunk/SFEghc-iteratee.spec?revision=2863&view=markup
21:29:54 <jonathan__> is there a Read instance for fgl Graph that I could pull out of a package?
21:30:12 <jonathan__> I could right my own, but I can't be the first person to need to
21:30:28 <jonathan__> I mean write :p
21:31:34 <elliott> Is there documentation for all the ~/.cabal/config properties anywhere?
21:35:17 <ivanm> elliott: the default file
21:35:37 <ivanm> jonathan__: if you're the guy who just emailed me about this, see my reply ;-)
21:35:43 <jonathan__> haha
21:35:48 <elliott> ivanm: um, the default file I got doesn't have any docs.
21:35:49 <jonathan__> yeah I just saw you
21:35:58 <ivanm> elliott: what do you mean by "docs"?
21:36:13 <elliott> ivanm: a brief description of what each property does? for instance: root-cmd
21:36:14 <j-invariant> what are good GTK tutorials? does it matter if they're not haskell ones
21:36:22 <tolkad> elliott: I think he means that there is no documentation and that you should infer what you can by reading the default file
21:36:22 <jonathan__> ivam: thanks, I
21:36:27 <jonathan__> 'll do that
21:36:31 <elliott> tolkad: "-- root-cmd:" Hard to infer from that.
21:36:43 <ivanm> elliott: no idea
21:36:50 <ivanm> but you typically don't need to touch most of those
21:36:50 <elliott> reassuring :)
21:36:57 <tolkad> elliott: Oh, I found some documentation: http://darcs.haskell.org/cabal-install/Distribution/Client/
21:37:07 <ivanm> uncomment things like "documentation: True" (or whatever it is), put your Hackage login details in, etc.
21:37:13 <ivanm> jonathan__: np
21:37:31 <elliott> ivanm: In this case, I want to override how cabal-install installs a package (making it register and copy in two separate steps with a command in-between), and also want to run a command after every install/remove/modification. The response is going to be "hack the code", I guess.
21:37:41 <elliott> I know how to use the simple options though :-)
21:37:43 <ivanm> jonathan__: too many people whine about FGL changing for me to go and add instances in :s
21:37:59 <ivanm> elliott: yeah, I think it will be :/
21:38:09 <ivanm> especially since there is no "remove" :p
21:38:15 <elliott> Oh yeah, there isn't, is there.
21:38:30 <elliott> ivanm: That is a shame. (I'm trying to "integrate" cabal with GNU stow...)
21:38:56 <ivanm> elliott: maybe if possible use Cabal directly rather than cabal-install?
21:39:02 <elliott> (Initially going for everything in /opt/stow/ghc and auto-stowing after installation, and then moving to e.g. /opt/stow/haskell-{foo} for a package foo.)
21:39:09 <elliott> ivanm: That would be possible, sure ... but for every install?
21:39:11 <elliott> That would suck a bit.
21:39:18 <jonathan__> ivanm: speaking of which, how's the new version coming?  
21:39:19 <ivanm> write a wrapper script
21:39:40 <elliott> ivanm: It'll turn into a Greenspunning of cabal-install soon enough.
21:39:43 <elliott> I might just hack the code up.
21:39:45 <ivanm> jonathan__: I'm going to be working on-and-off on the overall graph-class setup during my summer break (i.e. the next month)
21:39:50 <elliott> Or install into ~/.cabal, like normal people.
21:40:08 <ivanm> and then FGL (or maybe we will just call it inductive-graphs *shrug*) will just have the inductive stuff in there and that's it
21:40:26 <j-invariant> http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Entry-Entry.html <-- doesn't seem to be a way to make it so that pressing "up" pulls history
21:40:37 <jonathan__> ivanm: cool, and my vote is for inductive-graph
21:40:47 <ivanm> jonathan__: mine isn't Lo
21:40:48 <qfr> Haskell: Putting back the ML into HTML (??)
21:40:51 <ivanm> s/Lo/:p/
21:40:57 <jonathan__> heh
21:41:35 <elliott> Haskell: Putting the H back into askell. (If you don't understand this pun, you're being too lazy.)
21:42:27 <qfr> http://journal.batard.info/post/2009/11/05/tail-recursion.jpg
21:50:49 <tolkad> http://en.wikipedia.org/wiki/Haskell_class_attack_transport
21:55:34 <mtnviewmark> heh! That's right! We're gonna take over computing by amphibious assault!  yah! 
21:56:30 <mtnviewmark> Next maneuver: We sail a ship under a new moon through the Golden Gate, down the bay, and dock at the levee between the Google campus and NASA/Ames....
21:56:52 <mtnviewmark> 1,500 Haskell elite corps will de-board under the cover of night, in black ninja suits
21:57:35 <mtnviewmark> and march the 2 mi. down the Steven's Creek trail to the computing headquarters known as "Hacker Dojo"
21:58:23 <mtnviewmark> There, in a surprise attack on Friday, February 11th -- Haskellers will overpower the weaker enemy, who are armed only with imperative tools....
21:59:44 <aefjt> Just take off your pants and their computers will be rendered helpless by your bottoms.
22:00:35 <flux> mtnviewmark, I'm not certain if that's going to work.. imperative tools are much more brutal, and haskeller tools have no side-effects on reality?
22:00:42 <aefjt> But your bottoms will emerge unscathed, as long as you apply some lub
22:02:18 <tolkad> aefjt: But we could curry their functions until they stack overflow
22:02:24 <mtnviewmark> ah, but flux, we'll foldr 'em , foldl 'em, foldl' 'em even!
22:02:51 <mtnviewmark> and .....
22:02:58 <mtnviewmark> we have the POWER OF MONADS!
22:03:11 <j-invariant> is ther ea built in way to go from strings to Either Integer String? Like "3" --> Left 3 ; "foo" --> Right "foo"?
22:03:47 <mtnviewmark> > Right "foo" :: Either Integer String
22:03:49 <lambdabot>   Right "foo"
22:03:59 <mtnviewmark> just type annotate it
22:04:08 <mtnviewmark> if you're doing it alot, define a helper functoin
22:04:10 <j-invariant> yeah but I want to turn numbers to Integer
22:04:18 <j-invariant> that's the difficult part
22:04:24 <mtnviewmark> ah, you want a function that takes either Integer or String?
22:04:28 <j-invariant> yeah
22:04:38 <mtnviewmark> you can... but you'd have to do it with a type class
22:04:52 <j-invariant> infact only positive numbers
22:04:58 <j-invariant> I don't even care about "-3"
22:05:12 <aefjt> "-3" isn't a number, but a string
22:05:16 <aefjt> (-3) is a number
22:05:25 <j-invariant> yeah I want a converter
22:05:47 <mtnviewmark> class MakeEIS a where { makeEIS :: a -> Either Integer String; }
22:05:48 <aefjt> In better words, you want to parse a string as a number?
22:05:50 <roconnor> > read "-3" :: Integer
22:05:51 <lambdabot>   -3
22:06:00 <mtnviewmark> instance MakeEIS Integer where { makeEIS = Left; }
22:06:00 <roconnor> > read "-3" == -3
22:06:01 <lambdabot>   True
22:06:09 <mtnviewmark> instance MakeEIS String where { makeEIS = Right; }
22:06:11 <mtnviewmark> done
22:06:53 <j-invariant> but what bout String -> Either Integer String
22:06:57 <mtnviewmark> AH
22:06:59 <j-invariant> incase it cant turn it into an integr
22:07:02 <mtnviewmark> different beast - I misunderstood you
22:07:59 <j-invariant> i can just build it from scratch then
22:08:08 <mtnviewmark> you want to use reads
22:08:15 <j-invariant> okay
22:08:28 <aefjt> > map (reads :: String -> [(Integer, String)]) ["1", "2", "-3", "4a", "nan"]
22:08:29 <lambdabot>   [[(1,"")],[(2,"")],[(-3,"")],[(4,"a")],[]]
22:08:33 <tolkad> I read this long rant by some guy saying it's terrible that many haskell programmers use terms from category theory in haskell without understanding their meaning in the context of category theory
22:08:48 <tolkad> Do I need to learn category theory to really understand haskell?
22:08:52 <j-invariant> tolkad: haha I read that too - that guy is hilarious
22:08:58 <Philippa_> tolkad: yeah. Which is crap really, it's enough to understand what they mean on the categories we used them on
22:09:11 <Philippa_> *use
22:09:16 <j-invariant> tolkad: you can learn category theory if you like but don't listen to that stupid blog post 
22:09:28 <mtnviewmark> let makeEIS s = case (reads s :: [(Integer, String)]) of [(i,"")] -> Left i; _ -> Right s    in map makeEIS [ "3", "abc", "42", "bob"]
22:09:37 <mtnviewmark> > let makeEIS s = case (reads s :: [(Integer, String)]) of [(i,"")] -> Left i; _ -> Right s    in map makeEIS [ "3", "abc", "42", "bob"]
22:09:38 <lambdabot>   [Left 3,Right "abc",Left 42,Right "bob"]
22:09:45 <j-invariant> great!!
22:09:59 <aefjt> It's terrible that we don't use category theory properly in Haskell, and it's even worse that you don't need to learn category theory to use Haskell
22:10:09 <aefjt> What oh what will we do
22:10:45 <c_wraith> replace all modules with Control.Category
22:11:14 <mtnviewmark> in theory, reads could return other shaped valid results for parsing... but unlikely in practice.... 
22:11:36 <mtnviewmark> > let makeEIS s = case filter (null . snd) (reads s :: [(Integer, String)]) of ((i,""):_) -> Left i; _ -> Right s    in map makeEIS [ "3", "abc", "42", "bob"]
22:11:38 <lambdabot>   [Left 3,Right "abc",Left 42,Right "bob"]
22:11:56 <mtnviewmark> slightly more general and correct... though for Integer, I don't think it will make a difference
22:13:17 <mtnviewmark> aefjt: I think we should just ship Haskell Platform with PDFs of fill-in-your-name PhD diplomas in Category Theory
22:13:42 <mtnviewmark> then - by definition - every Haskeller will be an expert in CT
22:14:22 <lars9> for those who want a simple, monadic regex: http://wp.me/p1gCkL-3
22:15:09 <mtnviewmark> > let makeEIS s = case filter (null . snd) (reads s :: ReadS Integer) of ((i,_):_) -> Left i; _ -> Right s    in map makeEIS [ "3", "abc", "42", "bob"]
22:15:10 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
22:15:10 <lambdabot>           ...
22:16:13 <mtnviewmark> > let makeEIS s = case filter (null . snd) (reads s :: (ReadS Integer)) of ((i,_):_) -> Left i; _ -> Right s    in map makeEIS [ "3", "abc", "42", "bob"]
22:16:14 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
22:16:14 <lambdabot>           ...
22:16:16 <mtnviewmark> ?
22:16:22 <mtnviewmark> :t Reads
22:16:23 <lambdabot> Not in scope: data constructor `Reads'
22:16:27 <mtnviewmark> :info ReadS
22:16:41 <aefjt> :t ReadS Int
22:16:41 <lambdabot> Not in scope: data constructor `ReadS'
22:16:42 <lambdabot> Not in scope: data constructor `Int'
22:16:54 <aefjt> There we go
22:17:06 <mtnviewmark> > let makeEIS s = case filter (null . snd) (reads :: ReadS Integer $ s) of ((i,_):_) -> Left i; _ -> Right s    in map makeEIS [ "3", "abc", "42", "bob"]
22:17:08 <lambdabot>   Couldn't match expected type `GHC.Base.String
22:17:08 <lambdabot>                              ...
22:17:27 <mtnviewmark> > let makeEIS s = case filter (null . snd) ((reads :: ReadS Integer) s) of ((i,_):_) -> Left i; _ -> Right s    in map makeEIS [ "3", "abc", "42", "bob"]
22:17:29 <lambdabot>   [Left 3,Right "abc",Left 42,Right "bob"]
22:17:32 <mtnviewmark> finally - 
22:17:44 <mtnviewmark> that little tweak to readability took way too much work
22:19:02 <mtnviewmark> :t listToMaybe
22:19:03 <lambdabot> forall a. [a] -> Maybe a
22:19:07 <aefjt> > let makeEIS :: String -> Either Integer String; makeEIS s = case reads s of [(n,"")] -> if n<0 then Left s else Right n; _ -> Left s in map makeEIS ["3", "abc", "-42", "5 bob"]
22:19:07 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
22:19:07 <lambdabot>         against inf...
22:19:26 <aefjt> > let makeESI :: String -> Either String Integer; makeESI s = case reads s of [(n,"")] -> if n<0 then Left s else Right n; _ -> Left s in map makeESI ["3", "abc", "-42", "5 bob"]
22:19:27 <lambdabot>   [Right 3,Left "abc",Left "-42",Left "5 bob"]
22:19:43 <aefjt> Either String is the proper monad, mind you
22:22:34 <tolkad> > fix (10:)
22:22:38 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
22:22:44 <aefjt> > let makeESI :: String -> Either String Integer; makeESI s = case reads s of [(n,"")] -> if n<0 then fail s else return n; _ -> fail s in map makeESI ["3", "abc", "-42", "5 bob"]
22:22:45 <lambdabot>   Overlapping instances for GHC.Base.Monad
22:22:45 <lambdabot>                              (Data...
22:22:55 <aefjt> Typical
22:22:58 <tolkad> > fix Right
22:22:59 <lambdabot>   Occurs check: cannot construct the infinite type:
22:22:59 <lambdabot>    a = Data.Either.Either...
22:23:03 <mtnviewmark> >  let maybeRead = listToMaybe . map fst . filter (null . snd) . reads; makeEIS s = maybe (Right s) Left (maybeRead s :: Maybe Integer) in map makeEIS ["3", "abc", "-42", "5 bob"]
22:23:05 <lambdabot>   [Left 3,Right "abc",Left (-42),Right "5 bob"]
22:23:35 <mtnviewmark> what is missing from Prelude is maybeRead --- a fine utility function
22:24:32 <aefjt> They're not called utility functions if you don't rewrite them for every project
22:24:44 <mtnviewmark> :-)
22:24:49 <tolkad> > fix (In . Maybe)
22:24:49 <lambdabot>   Not in scope: data constructor `Maybe'
22:24:54 <tolkad> > fix (In . Just)
22:24:56 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
22:25:36 <tolkad> > fix In
22:25:37 <lambdabot>   Couldn't match kind `(* -> *) -> *' against `* -> *'
22:26:08 <tolkad> > fix (In In)
22:26:08 <lambdabot>   Occurs check: cannot construct the infinite type:
22:26:09 <lambdabot>    f = (->) (f (L.Mu f))
22:26:38 <tolkad> how can I fix that?
22:26:56 <tolkad> (no pun intended)
22:27:04 <aefjt> newtype Identity a = Identity a
22:27:42 <tolkad> (no pun intended)
22:27:44 <tolkad> whoops
22:27:49 <tolkad> > fix (In . In)
22:27:50 <lambdabot>   Couldn't match kind `* -> *' against `(* -> *) -> *'
22:27:59 <tolkad> > fix (In Identity)
22:27:59 <lambdabot>   Couldn't match expected type `L.Mu ((->) a)'
22:28:00 <lambdabot>         against inferred type ...
22:28:04 <aefjt> No pun indented
22:28:10 <tolkad> > fix (In . Identity)
22:28:10 <lambdabot>   No instance for (GHC.Show.Show
22:28:11 <lambdabot>                     (Data.Functor.Identity.I...
22:28:25 <tolkad> why is there no show instance for identity?
22:28:38 <tolkad> > fix (In . Just)
22:28:40 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
22:28:45 <aefjt> Because someone didn't write it
22:29:06 <tolkad> > fix (In . In . In . In . Just)
22:29:07 <lambdabot>   Couldn't match kind `(* -> *) -> *' against `* -> *'
22:33:15 <Boxo> > fix (In . (:[]))
22:33:16 <lambdabot>   In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In [In ...
22:38:26 <Veinor> okay
22:38:53 <Veinor> I'm going to be teaching a 6-hour class on haskell in 2-hour chunks
22:39:18 <mtnviewmark> cool - where? when? who's the audience?
22:39:50 <systemfault> I wish I could be there..
22:39:51 <djahandarie> Neat
22:39:52 <systemfault> :'(
22:39:57 <systemfault> I would LOVE that.
22:39:58 <mtnviewmark> I'm going to be co-teaching a 6-hour workshop on haskell in one 6-hour chunk in Feb.
22:40:00 <Veinor> at MIT during IAP
22:40:08 <Veinor> so... in four days
22:41:09 <mtnviewmark> mine is at the Hacker Dojo in Feb.
22:41:17 <Veinor> the target audience will have programming experience with procedural languages
22:41:31 <shachaf> mtnviewmark: Who's going to be co-teaching with you?
22:41:44 <mtnviewmark> some combination of bos and tibbe
22:41:57 <ddarius> tibos
22:42:19 <aefjt> Colearning
22:43:02 <mtnviewmark> and perhaps others... it depends on who we get signed up for the workshop -- we may have several "sections" --- the web2.0 programmers, the "i've coded Euler 1-99 now what...?", those that want to understand iterees...
22:43:31 <mtnviewmark> my aim is the "I've done PHP and some Java and/or Python.... what's this Haskell stuff?"
22:43:50 <systemfault> eww
22:44:09 <systemfault> PHP and Python... :#
22:44:11 <systemfault> :/
22:44:12 <mtnviewmark> Veinor: what are you using as a Haskell system: getting them to all install GHC on their laptops?
22:44:33 <mtnviewmark> has to admit that he is - AT THIS VERY MOMENT - coding PHP for a website project....
22:44:46 <mtnviewmark> .... and dreading every line of it 
22:47:13 <shachaf> You should Greenspin some Haskell into it.
22:48:08 <qfr> Implement Haskell in PHP
22:51:48 <erikina> I saw something about that once. Someone as part of their job requirement had to code something in PHP
22:51:50 * mtnviewmark wonders why there isn't a PHP backend for GHC
22:51:57 <erikina> so they wrote a lisp interpreter in PHP
22:52:01 <erikina> and then did it all in lisp
22:53:38 <qfr> erikina HAHAHA I was just thinking about that
22:53:45 <qfr> Because Lisp seemed like the obvious approach
22:53:58 <qfr> Or at least something Lisp'esque
22:55:28 <blackdog> erikina: https://github.com/facebook/lex-pass ?
22:56:11 <erikina> Nah, this had nothing to do with haskell
22:56:22 <erikina> it was just a lisp interpreter in PHP
22:57:48 * ddarius has a (pure) Prolog interpreter in Javascript...
22:58:40 * djahandarie swears at hackage.haskell.org
22:59:01 <qfr> ddarius hahahaha
22:59:54 <aefjt> The obvious dual of EDSLs
23:00:16 <mtnviewmark> I know of a Logo done in Javascript
23:02:26 * shachaf has a GIF interpreter in Javascript...
23:03:02 <Veinor> mtnviewmark: yeah, or pointing them at tryhaskell if they don't feel like it
23:03:23 <mtnviewmark> really? tryhaskell - can't get too much done in that
23:04:11 <mtnviewmark> alas Barley isn't quite ready (but it better be by Feb...)  --- they'd still need to install Haskell Platform... but then Barley gives 'em a local Haskell IDE ... in a web page!
23:04:35 <mtnviewmark> That's what we're using for the workshop
23:04:42 <shachaf> There's codepad.org.
23:04:51 <rjo> goodmorning haskellers
23:05:32 <rjo> nub says that it is O(N^2) 
23:05:52 <horms> rjo: what do you say it is?
23:06:04 <rjo> however, if I nub Ord list, is it NlogN?
23:06:20 <Saizan> no, nub doesn't take advantage of that
23:06:22 <kmc> rjo, no, it doesn't detect that and use a different algorithm
23:06:30 <kmc> :t S.toList . S.fromList
23:06:30 <lambdabot> forall a. (Ord a) => [a] -> [a]
23:06:31 <Saizan> the type itself prevents it
23:06:35 <kmc> that will do it
23:06:37 <kmc> S = Data.Set
23:06:52 <kmc> > S.toList . S.fromList $ "mississippi"
23:06:53 <lambdabot>   "imps"
23:07:03 <shachaf> kmc: That won't maintain the ordering, though.
23:07:08 <kmc> correct
23:07:22 <kmc> a more complicated version which folds a set could, though
23:08:27 <gienah> @src nub
23:08:27 <lambdabot> nub = nubBy (==)
23:08:36 <gienah> @src nubBy
23:08:37 <lambdabot> nubBy eq []             =  []
23:08:37 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:09:03 <wagle> @type flip . (. flip id)
23:09:04 <lambdabot> forall a b a1 b1. (((a1 -> b1) -> b1) -> a -> b) -> a -> a1 -> b
23:13:54 <aefjt> On the other hand, nub works on infinite lists
23:14:26 <aefjt> > map head . group . sort $ "mississippi"
23:14:28 <lambdabot>   "imps"
23:15:11 <c_wraith> sort doesn't work on infinite lists either, of course.
23:15:44 <tomh1> this @src thing, is there a way to do that in ghci? :src didn't work
23:16:01 <shachaf> tomh1: Kind of, but not practically.
23:16:03 <ddarius> You can actually embed lambdabot into GHCi.
23:16:48 <shachaf> You can @src types, though.
23:16:49 <aefjt> @where goa
23:16:49 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
23:16:53 <tomh1> Yeah, until I saw people using stuff like @src, I thought it was just piping commands to ghci, and returning the result.
23:18:06 <gienah> I recently added ebuilds of goa and lambdabot to gentoo, however the patch to make them work has not been applied yet, I patched them to compile with ghc 6.12.3 and 7.0.1
23:18:11 <kmc> lambdabot's @src is just reading a flat text file
23:18:18 <kmc> it frequently differs from the real source used by ghc
23:18:22 <tomh1> Where can I see the source online then?
23:18:27 <shachaf> @version
23:18:28 <lambdabot> lambdabot 4.2.2.1
23:18:28 <lambdabot> darcs get http://code.haskell.org/lambdabot
23:18:31 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
23:18:41 <kmc> there are source links on all the module docs
23:18:45 <shachaf> tomh1: There /State/source, or something like that.
23:18:50 <kmc> also for individual packages at http://hackage.haskell.org/packages/archive/pkg-list.html
23:18:58 <gienah> you can search the docs with hayoo and hoogle
23:19:13 <tomh1> Thanks, that ghci on acid looks awesome... 
23:19:46 <tolkad> Does anyone want to help me debug my lambda calculus parser? I tried to fix a bug in it and now it runs forever
23:19:50 <gienah> you should look at my patches and ebuilds if you want to build lambdabot and goa on some other platform other than gentoo
23:20:07 <tolkad> (sorry that was rhetorical, linking it in a sec)
23:20:57 <gienah> gentoo ebuilds and patches are here: http://code.haskell.org/gentoo/gentoo-haskell/
23:21:35 <tolkad> here it is: http://pastebin.com/WrCRykNt
23:23:11 <tolkad> I think it has something to do with the recursiveness in the application parsing code
23:23:19 <tolkad> but I'm not very familiar with Parsec
23:24:25 <djahandarie> ddarius, Text.Parsec.Token seems to annoyingly restrict you to Strings rather than ByteStrings. Is there a reason for this?
23:27:56 <gienah> it seems my ebuilds of goa and lambdabot have not been applied to the gentoo repo yet, I guess they will be soon
23:28:15 <tomh1> Where should I put the .ghci file on Mac OS X?
23:28:32 <Veinor> /Users/yourusername
23:28:41 <ddarius> djahandarie: A lot of the operations are character specific, though it could be generalized.
23:29:33 <tomh1> veinor: thanks, google failed as it doesn't like punctuation
23:30:03 <banisterfiend> anyone here any good at markdown? how do i create a sub-bullet points inside a bullet point?
23:30:24 <banisterfiend> so the bullet points should be indented and look different
23:30:37 <mafs> * Foo\n** Bar <-- Like that?
23:30:45 <Veinor> tomh1: if you're in a terminal, you can use ~ for that
23:30:51 <banisterfiend> mafs: double bullet points? ** ?
23:30:57 <mafs> banisterfiend: Yep. Should work.
23:31:20 <banisterfiend> mafs: thanks
23:31:25 <mafs> banisterfiend: Anytime.
23:32:52 <tolkad> I'm still not sure how to go about figuring out why my parser is running forever. shouldn't it fail when it runs out of input?
23:34:19 <ivanm> banisterfiend: which variant of markdown is that?
23:34:33 <ivanm> in pandoc you just indent with four spaces and start a new bulleted section
23:49:03 <mtnviewmark> Shamless plug: vote for my Haskell code-golf entry on SO: http://stackoverflow.com/questions/4551054/codegolf-find-the-unique-paths
23:51:38 <djahandarie> I should just write a codegolf package which makes all common expressions into one character each
23:51:59 <djahandarie> Then this'll all be easy!
23:52:45 <mtnviewmark> actually -- I think runhaskell should have command line options like perl, that would translate into     
23:55:21 <shachaf> djahandarie: HasQ9+?
23:55:43 <mtnviewmark> -e <code>   ->   main = print $ <code>
23:56:14 <shachaf> mtnviewmark: ghc does that.
23:56:29 <mtnviewmark> -n -e <code> -> main = interact $ unlines . <code> . lines
23:56:36 <mtnviewmark> but it doesn't have -n, does it?
23:57:07 <shachaf> Ah. No.
23:57:19 <shachaf> mtnviewmark: Do you really need to lines the input?
23:57:20 <mtnviewmark> there are several other nice perl things like -a (autosplit lines on fields) and -p 
23:57:32 <mtnviewmark> in the code-golf?
23:57:42 <shachaf> mtnviewmark: You can probably get away with just words and then splitting into pairs.
23:57:47 <mtnviewmark> perhaps not
23:58:54 <mtnviewmark> but pairing up is going to be hard to do less than the the six characters of .lines  
