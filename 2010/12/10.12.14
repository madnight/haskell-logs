00:00:17 <qfr> dibblego what's the problem?
00:06:25 <shachaf> qfr: Did you try writing one in Haskell? :-)
00:07:00 <qfr> shachaf no
00:07:27 <shachaf> qfr: Then try it and see.
00:07:58 <qfr> shachaf I would need to learn Haskell for that first
00:08:08 <qfr> Which is why I asked
00:08:26 <lispy> Isn't the list zipper the same as a double-linked list?
00:08:35 <shachaf> lispy: Not particularly.
00:08:58 <lispy> How is it different?
00:09:03 <qfr> Lisp isn't FP anyways, is it?
00:09:06 <lispy> Maybe I'm just really out of touch with double-linked lists
00:09:07 <shachaf> lispy: How is iti similar?
00:09:25 <lispy> shachaf: you are at a node and you follow pointers to either end of the list
00:09:34 <shachaf> lispy: A doubly-linked list has a pointer to the next node and a pointer to the previous node.
00:09:43 <lispy> data ListZ a = LZ ([a], a, [a])
00:09:47 <shachaf> lispy: In Haskell, you couldn't cons onto it.
00:10:17 <shachaf> lispy: Well, I suppose it depends on what operations you want on the list.
00:10:22 <lars9> lispy: \l->(head l, last l) takes O(1) if l is doubly linked list, and it's O(N) if you use zipper
00:10:26 <Axman6> lispy: the point is that it would take O(1) time to append to the list, as well as prepend
00:10:58 <lars9> lispy: zipper is only good for traverse, not for random access
00:11:00 <Axman6> zippers give you O(1) access to the current element you're up to in the list
00:11:16 <shachaf> lars9: Doubly-linked lists aren't great at random access either.
00:11:38 <lars9> shachaf: only at head and tail 
00:11:40 <Axman6> they're great and head and tail access
00:11:50 <shachaf> lars9: That's an interesting meaning of "random".
00:12:13 <lispy> How is \l -> (head l, last l), O(1) for any kind of linked list?
00:12:32 <shachaf> lispy: Usually you'd store a pointer to both the beginning and the end.
00:12:33 <Axman6> you keep a pointer to the head and the tail of a linked list
00:12:41 <shachaf> lispy: A doubly-linked list in Haskell would be like a B-tree with a "parent" pointer on nodes. :-) How is that going, by the way?
00:13:33 <lispy> When I was taught linked lists it was just that each cons had two pointers, one forward, one back.  none of this funny stuff with also storing the head and tail.
00:13:39 <Axman6> struct elem_t { int i; elem_t * left, * right;} struct dlist { elem_t * head, * tail}
00:14:02 <shachaf> Axman6: "dlist" usually has a different meaning. :-)
00:14:32 <Axman6> sure, i've never actually written a doubley linked list implementation before
00:14:34 <shachaf> lispy: Well, OK, but in an mutable context it makes perfect sense to store both ends.
00:14:51 <Cale> If you just want a pointer to the end of the list, it's easy to just use a pair ([a],a) of the list together with its last element. ;)
00:14:56 <shachaf> lispy: (Alternatively, circular doubly-linked lists are also common.)
00:15:23 <shachaf> Cale: Of course, but you want O(1) unsnoc. :-)
00:15:28 <Cale> But that's probably not so useful in most cases, since the whole thing is immutable
00:15:42 <Cale> snocnu
00:15:50 <Cale> :)
00:16:48 <c_wraith> double-linked lists in immutable languages are painful.  Mostly because if you want to change something, you can't share nodes.
00:17:14 <shachaf> c_wraith: Yep. It's O(n) anything except access.
00:17:27 <shachaf> Er, at *least* O(n). :-)
00:18:43 <Cale> c_wraith: not to mention turning a circularly linked list into an infinite one :)
00:19:05 <c_wraith> Eh.  circular lists are infinite in mutable languages, too :)
00:19:32 <c_wraith> I shouldn't call langauges mutable or immutable, because it's sloppy, but I'm tired and lazy :)
00:19:37 <shachaf> Cale: You *could* have an immutable circular linked list in a language that let you look at the addresses of nodes.
00:20:00 <Axman6> you sure?
00:20:09 <shachaf> Axman6: No?
00:20:16 <shachaf> Axman6: Why not?
00:21:29 <Axman6> i'm trying to figure out how you build such a thing, and i think at least one of the nodes needs to be mutated (the first/last one will have to be created to be referenced, and then modified when the noce on its other side is created no?
00:22:15 <shachaf> Axman6: You can do l = 1 : 2 : l in Haskell without mutation.
00:22:57 <c_wraith> Yeah, it's straight-forward knot-tying.
00:22:58 <Axman6> but i don't think that works here. maybe i'm too sleepy to see how it works
00:23:14 <Axman6> i guess with thunks it does make sense
00:23:43 <c_wraith> let l = Cons 1 r r ; r = Cons 2 l l
00:24:09 <c_wraith> assuming a proper data type, that's a very short circular doubly-linked list :)
00:24:14 <Axman6> ouch
00:24:27 <Axman6> but yes, that works, thanks
00:24:30 <c_wraith> throw a third element in to make the circle more triangular and less linear :)
00:24:47 * Axman6 switched into C mode for a bit. damn papers about IO make me thing in C >_<
00:25:10 <shachaf> c_wraith: If that's triangular, does that mean you need an infinite number of elements to make a "truly circular" list?
00:25:20 <Axman6> indeed
00:25:25 <c_wraith> yep.  But 7 is a pretty good approximation!
00:25:42 <shachaf> 7 is a pretty good approximation for just about anything.
00:26:00 <Axman6> @let pi = 7.0
00:26:01 <lambdabot>  Defined.
00:26:04 <Axman6> >_>
00:26:12 <shachaf> Proof: There are 7 things that 7 is a pretty good approximation for.
00:26:35 <Axman6> :t pi
00:26:35 <lambdabot>     Ambiguous occurrence `pi'
00:26:35 <lambdabot>     It could refer to either `L.pi', defined at <local>:1:0
00:26:35 <lambdabot>                           or `Prelude.pi', imported from Prelude at State/L.hs:3:0-36
00:26:43 <Axman6> @undefine
00:26:47 <Axman6> :t pi
00:26:48 <lambdabot> forall a. (Floating a) => a
00:32:39 * hackagebot webserver 0.4.4 - HTTP server library  http://hackage.haskell.org/package/webserver-0.4.4 (KazuYamamoto)
01:39:58 * hackagebot hmatrix 0.10.0.2 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.10.0.2 (AlbertoRuiz)
01:43:27 <Nibble> @src sum
01:43:27 <lambdabot> sum = foldl (+) 0
01:44:41 <Nibble> actually not that much faster than sum (x:xs) = x + (sum xs)
01:45:44 <pacak> Nibble: No, but it looks better
01:45:49 <Nibble> indeed
01:46:11 <Nibble> also
01:46:38 <Nibble> I have an objection against the traditional fibonacci sequence example used in haskell guides
01:46:41 <Nibble> not good for beginners :/
01:47:10 <pacak> fibs = 1: zipWith (+) fibs (tail fibs)
01:47:16 <Nibble> pacak: that is the one
01:47:31 <Nibble> it requires an extensive understanding of laziness and its consequences
01:47:39 <Nibble> for people that understands those, it is natural
01:48:23 <quicksilver> Nibble: surely the purpose of that is to show people how clever laziness is
01:48:30 <quicksilver> I wouldn't use it as an example of anything else
01:48:34 <quicksilver> but it's a good example of laziness.
01:48:47 <Nibble> quicksilver: I don't think it is, IIRC it is often used as a beginners example
01:48:55 <Nibble> I remember seeing it when I first started out
01:48:58 <quicksilver> I agree with your objection :)
01:49:09 <geheimdienst> ... feel free to move up one rung on the 'evolution of a haskell programmer' ...
01:49:13 <geheimdienst> ;)
01:49:20 <quicksilver> it's a good example of laziness and a certain kind of very simple automatic memoisation or dynamic programming
01:53:14 <Jafet> @quote undoubtedly
01:53:14 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
01:53:33 <Nibble> lol?
01:56:06 <lars9> what if fn = fn-1 + fn-2 + fn-3 ?
01:56:09 <Jafet> newtype BB = BB Word64; is it possible to derive the STUArray instance of MArray?
01:58:19 <Jafet> (It should be possible, unless single-constructor newtypes might have different representations than their wrapped types)
02:01:11 <Jafet> (...which the GHC manual implies is possible. Oh well, manual fromEnum instance time.)
02:03:55 <Axman6> @src MArray
02:03:55 <lambdabot> Source not found. You type like i drive.
02:07:29 <Nibble> why are user types called user types
02:07:40 <Nibble> what is the reason for the user part
02:08:11 <ivanm> hey Axman6 
02:08:23 <ivanm> the second copy of that book arrived, so I can give it to you in Feb
02:08:23 <Jafet> Because every library programmer wants to imagine a category of people he can abuse.
02:08:25 <sipa> what are user types? adts? newtypes? type aliases?
02:09:03 <Axman6> ivanm: ah awesome, i should have some money by then too :P
02:09:19 <ivanm> assuming you don't spend it all in japan? :p
02:09:24 <Axman6> yeah :P
02:09:35 <Nibble> turns out the guy was just wordshitting
02:09:37 <ivanm> or else, if Sarah is going to visit you there, I might be able to pass it on to her if you want
02:09:56 <Nibble> apparently his reason was because they could be made by the user and "entered into the system"
02:09:56 <Axman6> i think i've got about $800 left for this month, and i should be getting paid something like another $1250
02:10:12 <Axman6> oh yes, she is going to visit, she leaves on the 30th
02:10:22 <ivanm> well, I leave on the 24th ;-)
02:10:29 <Axman6> that would be an excellent thing to be reading while i'm here too. how is it?
02:10:35 <Axman6> where to?
02:10:48 <ivanm> not too bad what little I've read so far
02:10:59 <ivanm> heading back to Brisbane; coming back beginning of feb
02:11:08 <Axman6> ah nice
02:11:20 <Axman6> well i'll talk to her about getting that off you before you go
02:11:39 <ketil> Anybody using Emacs and C-c C-l to load files into GHCi?  My session insists on cd'ing up above my src/ directory, and then GHCi can't find other modules it depends on.
02:11:45 <ketil> This used to work!
02:12:18 <Nibble> horey shit
02:12:28 <ivanm> ketil: sounds like the 'ol cabal-file problem
02:12:29 <Nibble> dividing by zero in ghci
02:12:31 <Nibble> == infinity
02:12:33 <ivanm> create a useless/empty foo.cabal file
02:12:34 <Nibble> that is so wrong -____-
02:12:59 <ketil> ivanm, but, but - what's wrong with my current cabal file?
02:13:10 <ivanm> oh, you already have one?
02:13:11 <Axman6> Nibble: no it's not
02:13:13 <ketil> Cabal seems to like it - why can't Emacs just get along? :-)
02:13:16 <ivanm> maybe because you have a src/ sub-directory :s
02:13:32 <ketil> ivanm, yes.  Maybe I should hide it?
02:13:32 <ivanm> try making a useless .cabal file inside the src/ sub-directory
02:13:43 <ivanm> "hide it"?
02:13:47 <ivanm> isn't your source code inside it?
02:13:50 <ivanm> preflex: seen Baughn 
02:13:50 <preflex>  Baughn was last seen on #haskell 15 days, 19 hours, 34 minutes and 41 seconds ago, saying: I haven't been paying attention.. the canonical monad transformer package is now mtl again?
02:14:06 * hackagebot applicative-extras 0.1.7 - Instances for Applicative  http://hackage.haskell.org/package/applicative-extras-0.1.7 (ChrisEidhof)
02:15:05 <ketil> ivanm, hide the .cabal file, I mean.
02:15:16 <ketil> dummy.cabal didn't seem to help.
02:15:40 * ketil sighs deeply, and goes to get a cup of tea.
02:15:49 <Baughn> ivanm: O hai
02:18:29 <ivanm> Baughn: can you help ketil?
02:19:15 <Baughn> ..not right away, unfortunately. I don't use that functionality myself, and I can't really take time off from work right at the moment
02:19:37 <Baughn> ketil: Ping me in.. eight hours, if you still haven't gotten it to work
02:20:09 * hackagebot gnuplot 0.4.1 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.4.1 (HenningThielemann)
02:21:46 <merijn> Isn't the IO monad essentially (in concept, not actual implementation) the state monad carrying two [[Char]] (input and output) where input is essentially lazily generated and getLine is just head and putStrLn is essentially append for the output list? (I'm aware this idea breaks for stuff like getChar, but I'm pretty sure it can adapted to work in that case too, just slightly less elegant)
02:22:22 <shachaf> merijn: Well, except for everything else that IO can do.
02:22:28 <Baughn> merijn: So basically, no.
02:22:58 <shachaf> merijn: (And the fact that even for just input and output that analogy doesn't really hold).
02:23:12 <shachaf> merijn: See `interact`, though. :-)
02:23:26 <merijn> shachaf: I guess, I was just trying to come up with a better explanation/intuition then the usual "RealWorld" passing
02:23:33 <Baughn> merijn: Something like that used to be the case before monads were implemented, but I think it was more of a general event stream thing
02:24:02 <Baughn> merijn: ..how about "standard imperative program like you'd cee in C?"
02:24:34 <shachaf> I've heard that at one point main was something like :: [Response] -> [Request].
02:24:48 <charliesome> hey guys, i'm having a little trouble with haskell. How would I go about reading a number from a file, running my function on it, and writing the result back? No matter what I try I get parse errors or type errors.
02:25:03 <sipa> an IO action is a chain of primitive IO operations, connected using pure functions - the main function evaluates (lazily) to big such chain, which is then executed
02:25:18 <merijn> charliesome: Paste your code on a pastebin?
02:25:22 <charliesome> alright
02:25:58 <charliesome> one second
02:26:18 <Baughn> charliesome: hpaste.org, please
02:26:44 <charliesome> http://hpaste.org/42321/my_attempt_at_fibonacci
02:26:49 <Jafet> merijn: Haskell's IO used to be modelled like that. So if they changed it to something inscrutable, there should be a good reason for it.
02:27:04 <Baughn> charliesome: Use do-syntax. Seriously.
02:27:25 <charliesome> how would i do that?
02:27:26 <Axman6> charliesome: you have the :: Int in the wrong place, you trying to tell that input is an Int when it's a String
02:27:45 <Nibble> that is the ugliest code I have ever seen
02:27:47 <Nibble> srsly
02:27:55 <Baughn> Nibble: It has its charm..
02:28:11 * Baughn sweatdrops
02:28:13 <Axman6> charliesome: also, son't use tabs. set your editor to use spaces instead of tabs
02:28:21 <charliesome> alright
02:28:26 <Axman6> don't*
02:28:31 <Baughn> charliesome: GHC does have a defined meaning for tabs, but chances are it doesn't match with your editor's
02:28:58 <charliesome> Baughn, thanks, i'll try that
02:29:04 <merijn> Jafet: I was reading the Wadler paper on monads and he showed an example of doing output as essentially a monad appending to an output list, that's where the idea came from
02:29:33 <Baughn> charliesome: But anyway - do-syntax. I don't know what you've been reading to try using the raw combinators *first*, but that's generally considered a more advanced topic.
02:29:46 <Baughn> charliesome: Awfully convenient later, mind you. ;)
02:30:07 <charliesome> Baughn, I've only been using haskell for about 30 minutes so I don't really know what I'm doing :\
02:30:08 <Axman6> also, that impoementation of fibonacci, while being fairly standard and correct is horrible performance-wise
02:30:09 <Axman6> implementation*
02:30:15 <Axman6> heh
02:30:17 <merijn> charliesome: Which book/site are you using?
02:30:23 <Baughn> charliesome: Ah. In that case it's amazingly close to correct. :P
02:30:43 <charliesome> merijn, I've been looking at bits from learn you a haskell as well as other sites for the i/o stuff
02:30:59 <Baughn> charliesome: One thing: That definition of fib would be exceedingly slow. Can you see why?
02:31:01 <Axman6> my advice is stick to lyah
02:31:08 <Axman6> follow it from start to finish
02:31:26 <Axman6> before looking elsewhere. your willingless to use IO is not a good thing
02:31:34 <merijn> I'd finish learn you a haskell first (or close to finish) then start reading Real World Haskell for the messy IO bits
02:31:38 <Twey> charliesome: Your fibs are wrong, too ☺
02:31:44 <charliesome> merijn, alright thanks
02:31:51 <Twey> Well, not wrong, but undefined for 0
02:31:59 <Baughn> Mm. Canonically, fib 0 = 1
02:32:15 <merijn> And then when it starts making sense suddenly the IO part also becomes less messy
02:32:21 <Jafet> merijn: if you want to make a monad specifically to mean interaction with stdin and stdout, you can do that. And possibly lift with MonadIO or something
02:33:52 <merijn> Jafet: I wasn't trying to exactly understand IO's implementation just trying to form some intuition on how one could implement something like the IO monad
02:34:25 <Baughn> merijn: The actual implementation of IO involves /blatant cheating/, though. :P
02:34:47 <Baughn> merijn: Including assumptions on how the compiler works. Which admittedly works out well when it's part of the compiler.
02:34:48 <Jafet> That's just a sneaky way to ask oneself what the semantics of IO are.
02:35:01 <Twey> merijn: It's not so hard
02:35:13 <Twey> merijn: You can just have values representing various operations
02:35:15 <Jafet> Baughn: every implementation cheats fairly
02:36:10 <Twey> data IO a = GetChar (a -> IO b) | PutChar Char (IO b) | …
02:36:14 <Baughn> Jafet: Like fighting fairly before the match?
02:36:26 <merijn> Twey: My original concept sparking this discussion was treating it as the state monad carrying an input and output list (the former being infinite, lazily generated) and reducing stuff like getLine to something akin to head
02:36:49 <merijn> Baughn: Of course the compiler cheats, compilers always cheat
02:37:03 <Twey> merijn: That's lovely, except that it only allows you to work with stdin and stdout
02:37:08 <Baughn> merijn: And sure, you *could* implement IO like that. No-one *does*, but you *could*
02:37:21 <Twey> merijn: What about stderr?  Sockets?  Files?  Memory access?
02:37:28 <Jafet> In some sense, a monad that only lets you work with certain file streams is lovelier than IO
02:37:29 <Axman6> compilers are supposed tgo cheat, that's why we love them!
02:37:32 <Baughn> merijn: You'd need to extend the i/o list to handle all other IO operations, though.. then it gets ugly..
02:37:47 <merijn> Twey: Of course, but the concept could be expanded. Since I'm not actually implementing it I can view that as "implementation details" :p
02:38:02 <Twey> merijn: How about read errors?
02:38:37 <Twey> merijn: No, you see, the thing about having other streams is that you don't know in advance what streams the user is going to want.
02:38:50 <Jafet> Twey: actually, there aren't that many primitives. RTS interaction, FFI, and system calls are all I can really think of.
02:39:24 <Twey> Jafet: Yeah, but they're primitives that don't fit the list model
02:40:44 <Jafet> Well, your proposed definition looked like CPS
02:40:50 <Twey> Yep
02:40:54 <Twey> Which works :þ
02:40:59 <Jafet> Which is horrific in its own ways
02:41:10 <Twey> Well, it's basically what we do now, no?
02:41:11 <Jafet> But that's another bedtime story
02:41:20 <charliesome> so i tried the do syntax, and it's saying it can't match Int against 'm a': http://hpaste.org/42323/fibo_attempt_2
02:41:35 <merijn> Well, if you're working in a model based on the state monad nothing is restricting you to just lists. But in any case my goal was served, I sorta figured out the other monads and at least I can now see how IO fits into the list of other monads
02:41:46 <Nibble> charliesome: try to use read instead of the :: Int
02:41:57 <Nibble> only read
02:41:59 <Nibble> or
02:42:04 <merijn> charliesome: Because "read ns" is of type IO Int, not Int
02:42:13 <Jafet> CPS doesn't model the semantics of interleavedIO, etc. That is, if you ever want it to.
02:42:13 <Axman6> charliesome: use let n = read ns
02:42:21 <charliesome> ok
02:42:26 <Axman6> merijn: eh?
02:42:37 <merijn> oh wait
02:42:40 <merijn> ns is a string
02:42:43 <Axman6> read has type String -> a ;)
02:42:43 <merijn> Silly me
02:43:04 <merijn> In which case "n <- read ns" makes no sense
02:43:21 <charliesome> yay! it compiles when i changed the n <- to let n =
02:43:23 <charliesome> thanks everyone
02:43:46 <merijn> Why not just "show $ fib $ read n"?
02:43:55 <Nibble> because
02:44:12 <charliesome> merijn, what do the dollar signs mean?
02:44:21 <merijn> @src ($)
02:44:21 <lambdabot> f $ x = f x
02:44:33 <charliesome> oh cool
02:44:36 <merijn> charliesome: They remove the need for parenthesis
02:44:49 <merijn> Otherwise you'd have to write: "show (fib (read n))"
02:44:57 <earthy> plus, you can now pass 'application' as an argument to higher-order functions
02:45:37 <Nibble> fun fact
02:45:43 <earthy> i.e. zipWith ($) [(+1),(+3),(+5)] [6,7,8]
02:46:14 <Nibble> it can also be written as ($) f x = (f x)
02:46:17 <Nibble> I think.
02:46:27 <merijn> charliesome: $ has a very low priority, so it means "apply the function before the dollar to the result of everything after" because "show fib read n" would try to call show with fib as argument and cause other errors like to many arguments
02:46:28 <earthy> nibble: yes, 
02:46:29 <Nibble> haskell is just awesome
02:46:32 <merijn> Nibble: yes
02:46:43 <earthy> however, the extra () around (f x) are not needed
02:46:58 <charliesome> merijn, ahh that's handy
02:47:26 <merijn> charliesome: Like many people here I am too lazy to type all the parenthesis by hand
02:47:40 <Axman6> charliesome: now let that be enough IO for you until you've got up to it in lyah ;)
02:48:21 <charliesome> Axman6, I'm only using IO because I wanted to try Haskell to solve problems on an informatics site.
02:48:41 <charliesome> Axman6, I usually use C, but I thought it would be interesting to solve a problem in each offered language
02:48:47 <merijn> charliesome: You know you can call functions directly from the interpreter?
02:49:00 <Axman6> well, IO in haskell is designed to be more difficult than in languages like C, and there's a very good reason for that
02:49:05 <merijn> charliesome: You can even compile code in a file and call it from the interpreter without IO
02:49:21 <charliesome> merijn, how do you mean?
02:49:34 <merijn> charliesome: I'm assuming you're using GHC?
02:49:40 <Axman6> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 100
02:49:44 <lambdabot>   mueval-core: Time limit exceeded
02:49:47 <Axman6> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 10
02:49:47 <lambdabot>   89
02:49:57 <charliesome> merijn, yes.
02:50:16 <merijn> If you run "ghci" you'll get a prompt for an interactive GHC interpreter which will execute code as you type it
02:50:28 <charliesome> merijn, yes, i've been playing with that
02:50:52 <merijn> You can also write a function like fib in as Haskell file, then import it in the interpreter and then test it by calling "fib 100" in the interpreter
02:51:07 <merijn> (I forgot exactly how to load it, someone here can probably remind me)
02:51:25 <Axman6> ghci foo.hs, or in ghci, :load foo.hs
02:51:37 <charliesome> :l foo
02:51:39 <charliesome> i think
02:52:11 <merijn> Yeah
02:52:20 <merijn> And then you can reload it with ":r" when you make changes
02:52:33 <stroem> what is the name of the source-bot?
02:52:37 <stroem> the bot
02:55:24 <Axman6> stroem: eh
02:55:26 <Axman6> ?
02:55:58 <Axman6> @src map -- this?
02:55:58 <lambdabot> Source not found. That's something I cannot allow to happen.
02:56:02 <Axman6> @src map
02:56:02 <lambdabot> map _ []     = []
02:56:02 <lambdabot> map f (x:xs) = f x : map f xs
03:44:29 <scan> hi, I have a problem: I tried installing the haskell-platform on ubuntu over the apt network, and I always get configuration errors... anyone know how to solve "hGetContents: invalid argument (invalid UTF-8 byte sequence)" or how to uninstall unconfigured packages over apt?
03:48:55 * hackagebot timeplot 0.2.7 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.7 (EugeneKirpichov)
03:56:23 <tsbo> scan: That's because someone has used an ISO encoding in their cabal file. Edit the file it mentions and replace the o-umlaut with plain o and it should work!
03:56:37 <tsbo> scan: Or, at least, that's what I do on OS X. :-)
03:57:12 <scan> tsbo: seems to be the AES package...
03:57:56 <scan> tsbo: I wanted to build ghc myself anyway, but I needed the bootstrap
03:58:36 <tsbo> scan: Edit the file it mentions (probably in packages.conf.d/ in some /lib/ directory) and remove the ø from Tromsø.
03:59:35 <scan> tsbo: thanks, works now =D
03:59:58 <tsbo> scan: No worries. There're a few packages broken like that. They really should be fixed...
04:00:35 <scan> tsbo: Maybe it's people actually working with windows? I don't believe it's possible to do that, but I heard rumours...
04:04:12 <scan> tsbo: but thanks a lot
04:04:35 <tsbo> scan: I think it must be Windows. And no worries.
04:04:59 <Nibble> why does windows use UTF-16 or is it UTF-6 instead of UTF-8?
04:05:32 <quicksilver> because it's the best compromise according to some metrics.
04:06:31 <scan> Nibble: no windows uses ASCII rather than UTF-8
04:06:40 <Nibble> scan: made me lol
04:07:05 <tsbo> Or, rather, ISO-8859-1
04:07:30 <Nibble> no wau
04:07:31 <Nibble> y
04:07:36 <Nibble> it is utf 16
04:07:36 <scan> yes way
04:07:41 <tsbo> An UTF-16 means that almost always strlen = bytes / 2
04:08:08 <scan> if it was that easy...
04:08:23 <tsbo> Far more often than with UTF-8 anyway. :-)
04:08:48 <scan> but I don't think the overhead is worth it
04:08:58 <sipa> if you want that, use UTF-18!
04:09:00 <scan> i mean, 95% of the time the first byte is empty
04:09:27 <scan> no, UTF-23 is the solution
04:10:05 <scan> until it's succeeded by wtf-42
04:10:09 <tsbo> Does Windows actually UTF-16 (still multiple words per character) or UCS-2 (each char is a Word16)?
04:10:21 <Nibble> utf 16
04:10:33 <theorbtwo> utf-16 in newer versions, ucs-2 in very old versions.
04:11:01 <scan> really? i thought utf-16 is only within the java-environment
04:11:23 <theorbtwo> Fairly certian.
04:11:44 <scan> and .net, too?
04:11:46 <tsbo> Yeah. I knew it's some Unicode representation internally.
04:11:47 <theorbtwo> ucs-2 is incapable of going beyond the basic multilingual plane, and there's a lot of Chinese stuff outisde of it.
04:12:25 <tsbo> theorbtwo: Yeah, but there's plenty of Chinese characters (names and stuff) not even in Unicode. :-)
04:15:27 <scan> time to invent a haskell-only code and force the world to accept haskell as the one and only language
04:15:41 <scan> until the UN uses Haskell as their lingua franca
04:15:52 <Nibble> indeed
04:16:12 <Bynbo7> how easy is it to program in French?
04:16:53 <quicksilver> je ne sais pas
04:17:07 <tsbo> Depends on if you know it; I don't and find it painful indeed! :-)
04:17:11 <quicksilver> data PeutEtre a = Seulement a | Rien
04:17:17 <quicksilver> seems not much harder to me.
04:17:25 <scan> i think it's like perl while someone whacks you over the head with a baguette
04:17:40 <quicksilver> I don't know french for zygomorphism though.
04:18:15 <scan> i am fine with german and english, both widely accepted
04:21:59 <scan> anyone any idea when ghc7 will be usable?
04:22:30 <Bynbo7> it's released and usable now no?
04:23:16 <xplat> probably 'usable' as in 'you can pick up popular hackage packages and be pretty sure they build on it', i bet
04:23:18 <Nibble> not for arch linux users :/
04:23:34 <scan> i tried, but after compiling and installing it was already package-broken
04:23:55 <scan> patching up was like beheading a hydra
04:24:47 <scan> i read somewhere it's only for the early adopters currenty
04:31:25 <Nibble> also
04:31:35 <Nibble> > let 2 + 2 = 5 in 2 + 2
04:31:35 <lambdabot>   5
04:31:55 <Nibble> that worked because it pattern matches 2+2 to five. right?
04:31:57 <Nibble> magic
04:33:22 <pacak> > let 2 + 3 = 5 in 2 + 2
04:33:22 <lambdabot>   *Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
04:33:36 <pacak> Nibble: You redefine function +
04:34:34 <Nibble> > let 2 + 2 = 5 in 2 + 2 + 3
04:34:35 <lambdabot>   *Exception: <interactive>:1:161-169: Non-exhaustive patterns in function +
04:34:37 <nlogax> it's just shadowing the old one, right?
04:34:47 <Nibble> actually looks like you are correct
04:36:07 * hackagebot flowsim 0.2.8 - Simulate 454 pyrosequencing  http://hackage.haskell.org/package/flowsim-0.2.8 (KetilMalde)
04:37:09 <Chaze_> @pl (\n -> (`div` 10^(n-3)).(`mod` 10^n))
04:37:09 <lambdabot> ap ((.) . flip div . (10 ^) . subtract 3) (flip mod . (10 ^))
04:37:54 <Chaze_> is the some command in the haskell platform that does roughly what pl does?
04:38:44 <Bynbo7> no, but i believe you can install the pointfree program with cabal-install: cabal install pointfree
04:39:52 <nlogax> yes, then you can add that as a command in your .ghci
04:39:55 <nlogax> for example
04:40:39 <Nibble> oh lol
04:40:58 <Nibble> this made me lol: "But no one can match our military strength and we have the best living conditions in the world."
04:41:06 <Nibble> Someone about the US
04:42:23 <nostrand> someone from North Korea would say the same
04:42:34 <lars9> the military part is real
04:42:43 <Nibble> yes. but that is not what made me lol
04:43:44 <lars9> the difference between NK and US is that in NK the poor are starving to death and in US the poor are too fat to move.
04:43:46 <Nibble> "best living conditions" An unemployed drug addict that goes around and steal from people lives better here than the whole lower class there -___-
04:45:17 <sipa> let p = (+) in let { 2 + 2 = 5; a + b = p a b} in 3 + 3
04:45:20 <sipa> > let p = (+) in let { 2 + 2 = 5; a + b = p a b} in 3 + 3
04:45:21 <lambdabot>   6
04:45:24 <sipa> > let p = (+) in let { 2 + 2 = 5; a + b = p a b} in 2 + 2
04:45:25 <lambdabot>   5
04:46:36 <pacak> > let p = (+) in let { 2 + 2 = 5; a + b = p a b} in 2 + 5
04:46:37 <lambdabot>   7
04:46:53 <sipa> > let p = (+) in let { 2 + 2 = 5; a + b = p a b} in 2 + (2 + 2)
04:46:53 <lambdabot>   7
04:47:11 <Chaze_> @pl (\x -> zipWith mod (f x) [1..])
04:47:11 <lambdabot> flip (zipWith mod . f) [1..]
04:47:34 <lars9> this is an easy way to write mind blowing code.
04:48:17 <nlogax> it's easy to get carried away :)
04:49:56 <cheater2> hi!
04:50:15 <cheater2> Cale: you there? :)
05:00:47 <xplat> yeah, overusing pointless code can be a problem, but 'thinking pointless' is neat
05:01:20 <xplat> from the pointless pov, lambda and let are abstractions to hide the plumbing
05:02:08 <xplat> when too much plumbing is obscuring the purpose of your code, use a lambda
05:26:35 <xplat> actually, when you think of things from that pov, it's clear where the basic advantage of haskell over forth lies--better ways to abstract away from plumbing and make the structure of your code visible when it involves complex dataflow
05:28:11 <xplat> types help too, but we know how to type forth if we want
05:29:59 <Jafet> Forth always seemed to me like a platform-independent machine language for calculators
05:33:09 <hpc> the wikipedia article makes it look like a toy stack language
05:33:25 <hpc> what with all the unintuitive syntax
05:35:08 <Jafet> I thought toy languages would be the one with unsettlingly simple syntax
05:35:16 <Jafet> Unless they're sadist toys
05:45:32 <abstractstone> Is it possible to install haskell 7 on ubuntu 10?
05:45:46 <Zao> Sure.
05:45:49 <Nibble> you mean ghc 7?
05:45:51 <abstractstone> I was using 6 before bust now I have a clean install
05:45:52 <abstractstone> yes
05:45:53 <Zao> You might not want to though.
05:46:13 <abstractstone> best play safe with 6 then?
05:46:25 <Zao> As 6 has a properly working HP and most of the ecosystem, yes.
05:46:39 <abstractstone> cool thanks - you probably saved me a lot of trouble
05:48:33 <Mitar> is there some list of articles based on haskell or for haskell?
05:48:39 <Mitar> i would like to make a reference to it so that i can show my point that around haskell much academic research is happening
05:49:31 <xplat> it's not hard to find stuff
05:49:32 <cheater2> Mitar, point someone to haskell cafe logs
05:49:45 <cheater2> http://www.haskell.org/pipermail/haskell-cafe/
05:49:58 <xplat> just look for philip wadler's and spj's papers and follow references forward and back on some citation index or other
05:50:18 <xplat> you'll get plenty just from that
05:50:53 <Mitar> i would like to add this as a footnote in the project paper i am writing
05:51:36 <xplat> ah, so you want a single page that makes your case for you
05:52:21 <Mitar> yes
05:52:51 <lars9> > let _ + _ = "eh?" in 1 + 2 + 3
05:52:52 <lambdabot>   "eh?"
05:53:39 <xplat> good old let-polymorphism
05:55:31 <lars9> ghc7 is still not in arch's repo, dunno when it will be
05:55:56 <Nibble> lars9: never, at the current rate of progress
05:56:13 <Nibble> lars9: ghc packages have no maintainer
05:56:30 * hpc shudders to think how long it will take to get into the debian repo
05:56:32 <exDM69> lars9: copying ghc 6 package and regex-replacing ghc6 -> 7 won't work?
05:56:37 <lars9> you mean ghc pkgs or haskell pkgs?
05:56:57 <exDM69> lars9: or otherwise manually editing the arch build files
05:57:57 <lars9> exDM69: i usually don't edit PKGBUILDs
05:58:20 <lars9> exDM69: arch is experimental enough.
05:58:25 <Nibble> they edit themselves
05:59:29 <mercury^> :t let _ 
05:59:30 <lambdabot> parse error (possibly incorrect indentation)
05:59:48 <mercury^> :t let _ + _ = "eh?" in (+)
05:59:48 <lambdabot> forall t t1. t -> t1 -> [Char]
06:00:14 <lars9> and building haskell pkgs usually take a lot of mem, my ram is only 1G.
06:00:15 <mercury^> Why did you call that "let-polymorphism"?
06:02:11 <lars9> gtk2hs in arch repo is only 0.11 now, i tried to build the 12 myself, but given up after running out of mem
06:02:51 <exDM69> lars9: I thaught you want to hurry up the process of getting packages/builds for ghc7 somehow
06:04:33 <lars9> exDM69: nah, i want to use binary directly:)
06:11:09 <wtcross> how does the implementation of Data.Map differ from a typical association list
06:11:19 <wtcross> does haskells Map work just like a hash table?
06:11:32 <wtcross> or does it work like a list
06:11:34 <fadax> hi
06:11:47 <aleator> wtcross: it is a balanced tree
06:12:11 <exDM69> lars9: happy waiting, then :)
06:12:34 <wtcross> am i remembering correctly that a lookup takes O(n log n ) time in a balanced tree?
06:12:48 <aleator> wtcross: log n
06:13:37 <lars9> wtcross: read the doc, the time complexity is specified
06:13:41 <lars9> for each function
06:13:59 <wtcross> lars9: thanks i will read the docs
06:14:12 <wtcross> sorry for questions that can be answered by the docs, i'm still learning haskell :p
06:14:21 <fadax> i want to write a function which takes an Int n and finds the integers i and j such that n = 2^i * ((2*j) + 1) .   can this be done easily in Haskell? I've tried:   decode :: Int -> (Int, Int)    decode (2^i * ((2*j) + 1)) = (i, j)    -  but this didn't work
06:14:25 <wtcross> not used to going to the docs right away
06:15:11 <abstractstone> fadax write the number in binary to get 1010101100000 then chop the zeros off to get i and the remaining number is 2j+1
06:15:40 <tromp> make it a simple recursion
06:16:33 <tromp> first testing whether argument is odd
06:16:54 <fadax> oh i see, thanks abstractstone.. can i convert it to binary using haskell?
06:17:15 <tromp> no need to convert
06:17:15 <abstractstone> I dont' know..
06:17:23 <abstractstone> every number in a computer is binary
06:18:23 <aleator> fodax: See Data.Bits. It might help.
06:21:24 <fadax> ah ok thanks :)
06:22:17 <lars9> fadax: use this to get i: length $ takeWhile even $ iterate (`div` 2) n
06:29:02 <mercury^> lars9: that's horribly inefficient.
06:30:18 <fadax> oh thanks lars9 . can't say i understand how that works though. what does $ do? i see you are dividing the number by two until it's no longer even, which makes sense. but then what are you taking the length of?
06:30:37 <lars9> mercury^: oh why?
06:30:54 <tromp> that's only slightly inefficient 
06:31:51 <Xilon> > takeWhile even $ iterate (`div` 2) n
06:31:51 <lambdabot>   []
06:32:03 <mercury^> If by slightly you mean worse by a factor of around 70 on average, yeah.
06:32:09 <Xilon> > takeWhile even $ iterate (`div` 2) 15
06:32:09 <lambdabot>   []
06:32:14 <Xilon> bah
06:32:50 <mercury^> lars9: your code results in a right shift followed by a bit test for every trailing zero.
06:33:00 <mercury^> Instead of the single instruction that gives the wanted result.
06:34:16 <lars9> mercury^: which instruction?
06:34:24 <tromp> you cant avoid testing bits
06:34:29 <Jafet> Shifting like that would be O(i*n), mercury's magical instruction would be O(n), and a manual testBit loop would be O(i)
06:34:45 <Jafet> Constants are left as an exercise
06:35:36 <mercury^> lars9: that depends on the architecture, but most have one.
06:35:49 <lars9> is that about the efficient way to "test and shift"?
06:35:58 <Jafet> Oh, the question uses Int. Lame.
06:37:41 <tromp> if odd n then (0,n) else  (1+i,m) where ...
06:39:06 <lars9> mercury^: so how to do fast test-and-shift in haskell? ghc, intel core duo, linux 64 bit
06:39:16 <ManateeAuthor> Hi all. :)
06:39:30 <lars9> hi manatee
06:39:39 <ManateeAuthor> lars9: hi. :)
06:39:41 <lars9> how's everything going?
06:40:00 <ManateeAuthor> lars9: Well, i'm looking for haskell job, so haven't time develop manatee.
06:40:39 <lars9> ManateeAuthor: cool, but afaik there is no haskell job in china, right?
06:40:40 <mercury^> lars9: the instruction is bsf; I suppose there is a way to access it through Data.Bits
06:41:04 <ManateeAuthor> lars9: I don't know.
06:41:15 <ManateeAuthor> lars9: Maybe i will find some Linux job.
06:41:53 <lars9> mercury^: i just checked, unfortunately no. 
06:42:46 <ManateeAuthor> lars9: Don't query me, my irc client haven't support private talk. :)
06:42:46 <lars9> mercury^: if that's the bottleneck maybe he can add it through c interface:)
06:43:46 <lars9> ManateeAuthor: yeah linux job is much easier to find
06:43:52 <tromp> c doesnt have bsf either:(
06:44:10 <ManateeAuthor> lars9: Maybe i will find some linux OS job. :)
06:44:36 <mercury^> Yes it does. __builtin_ctzXX in gcc for example
06:44:43 <mercury^> Or through inline assembler.
06:44:49 <lars9> tromp: usually i'll beleive(or pretend to beleive) compiler can opt that
06:45:15 <lars9> ManateeAuthor: i'm sure you can do it
06:45:36 <ManateeAuthor> lars9: I will working on new features after i find job.
06:45:47 <ManateeAuthor> lars9: Some cool ideas in my TODO list.
06:46:21 <medfly> will it be a wild assumption to say that if I just make my  company work with haskell, then i will be able to get lots of competent people from #haskell jumping on me for a job?
06:46:31 <medfly> :-D
06:46:59 <medfly> or do I need to pay well too?
06:47:25 <ManateeAuthor> 等我有了钱以后， 我会创建一个 H
06:47:31 <ManateeAuthor> askell 
06:47:32 <ManateeAuthor> 公司
06:47:38 <ManateeAuthor> Damn ibus
06:47:47 <ManateeAuthor> I want to translate by irc client
06:48:01 <lars9> ManateeAuthor said when he is rich he'll found a haskell company
06:48:23 <luite> medfly: hmm, I believe the company where chrisdone works had a hard time filling a haskell position
06:48:31 <merijn> medfly: To quote lambdabot in its absense:
06:48:31 <ManateeAuthor> lars9: IBus post my words before my irc client translate it.
06:48:38 <merijn> <SyntaxNinja> You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean I'll keep doing what I'm doing." ;)
06:48:54 <medfly> aww...
06:48:57 <ManateeAuthor> Then all you smart guys can working in my company. :)
06:49:09 <lars9> ManateeAuthor: that means you type faster than how ibus can response :)
06:49:24 <merijn> Galois seems interesting to work with their recent HaLVM work
06:49:28 <ManateeAuthor> lars9: :)
06:50:06 <lars9> merijn: Galois has only 4x employees... i read it from dons' slides
06:50:26 <luite> 4x, for what x?
06:50:30 <medfly> you guys need to have better discipline :)
06:50:38 <merijn> luite: I'm assuming 40-49
06:50:41 <lars9> forty to fifty
06:50:42 <luite> hehe
06:51:13 <ManateeAuthor> lars9: I wonder have other company like Galois, use Haskell for everythig.
06:51:26 <AirRic> hey guys, got a problem with some haskell code, its about working with Strings
06:51:27 <ManateeAuthor> lars9: Jane Street is good, but i'm failed on Spoken English, you know.
06:51:30 <merijn> I fail to see how the number of employees impacts how interesting it'd be to work there
06:51:30 <lars9> ManateeAuthor: i quite doubt that
06:51:37 <ManateeAuthor> AirRic: Paste it.
06:51:39 <medfly> if it's really so bad maybe it's a bad idea to use haskell for anything with commercial potential at all
06:52:11 <lars9> merijn: the impact is on how hard it is to get in, i mean, for newbies like me.
06:52:14 <ManateeAuthor> lars9: I will find some Linux job, when i rich, i will create HaskellOS company. :)
06:52:33 <merijn> medfly: I think the main problem is that the intersection of people who thrive in languages like Haskell and people who are good at starting business may well be the empty set
06:52:57 <merijn> ManateeAuthor: Check out House (bare metal Haskell) and HaLVM (Haskell runtime on Xen)
06:53:02 <medfly> haha
06:53:06 <lars9> ManateeAuthor: there are a dozen of good companies in china, you'll make alot of money soon.
06:53:14 <medfly> so I either suck at Haskell or my commercial ideas are about to fail
06:53:15 <medfly> )
06:53:16 <ManateeAuthor> merijn: Check out http://goo.gl/MkVw
06:53:29 * medfly thinks it's the first
06:53:31 <ManateeAuthor> @package manatee
06:53:31 <lambdabot> http://hackage.haskell.org/package/manatee
06:53:32 <merijn> medfly: And if no one starts a business using Haskell then no businesses will hire people who program it since they don't want to trash their existing code
06:53:48 <merijn> medfly: You're overlooking a third option
06:53:54 <medfly> I do not exist?
06:53:58 <medfly> ? :O
06:53:59 <merijn> medfly: Both :p
06:54:05 <AirRic> could any1 help me please? got a type Error on a function
06:54:11 <medfly> I'm not that pessimistic :)
06:54:15 <ManateeAuthor> merijn: Or hackage.haskell.org/package/manatee
06:54:30 <ManateeAuthor> AirRic: Please post your code, then we can help you.
06:54:31 <merijn> AirRic: Paste your code on hpaste.org
06:54:31 <medfly> I have a number of really really cool ideas up my sleeve
06:54:58 <merijn> medfly: As do I, they vary from downright impossible to merely wildly impractical ;p
06:55:10 <AirRic> merijn: pastebin.com is also possible?
06:55:14 <medfly> mine tend to be insanely practical
06:55:18 <Nibble> ManateeAuthor: China is looking (the gov at least) to create their own OS
06:55:19 <merijn> Hence my prolonged stay in the sheltering bubble of academia :p
06:55:20 <Nibble> IIRC
06:55:34 <Nibble> there is your chance
06:56:01 <merijn> AirRic: Something like hpaste/codepad/dpaste would be preferred, but pastebin works
06:56:13 <ManateeAuthor> Nibble: I'm not intersested Gov's job.
06:56:35 <ManateeAuthor> Nibble: I don't want work with the people that create GFW.
06:56:50 <AirRic> merijin: i'll try hpaste 
06:57:27 <ManateeAuthor> Nibble: IMO, China gov use some BSD system.
06:57:57 <Nibble> ManateeAuthor: FYI, IMO = In My Opinion
06:58:26 <Nibble> The great firewall is just that, great!
06:59:27 <AirRic> merijn: shouldn't I get a link or something on hpaste, so I can send it here? sry, I'm new to IRC
07:00:03 <bxc> k
07:00:04 <bxc> oops
07:00:27 <AirRic> merijin: ah, I got it (I guess) : http://hpaste.org/42325/print_lists_as_sets
07:01:46 <merijn> AirRic: What's the exact error you're getting?
07:03:26 <AirRic> merijin: expected Type: [Char], inferred Type: String -> String in the showHelp function
07:05:58 <notallama> hey guys. anyone have some good links about type inference and/or compilers handy? (i'm trying to write yet another programming language for .NET)
07:05:59 <notallama> so far, i have written a rather dumb unification algorithm, and some parser combinators. not quite sure where to go from here. (i do know the semantics i want, just not how to get there yet)
07:06:13 <merijn> AirRic: I'm unsure what shows and showChar do, but maybe you want: http://hpaste.org/paste/42325/print_lists_as_sets_annotatio#p42326 ?
07:06:33 <ManateeAuthor> Anyway, i will back to develop Manatee. :)
07:07:28 <ManateeAuthor> Bye all:)
07:07:34 <ManateeAuthor> lars9: Bye. :)
07:09:20 <AirRic> merijin: shows and ShowChar are defined in Class Show, AFAIK
07:10:36 <AirRic> merijin: using fold is more elegant, but it's not the point, I guess
07:11:28 <merijn> Oh!
07:11:35 <merijn> I know where it fails >.>
07:11:41 <merijn> It's quite obvious too
07:12:09 <merijn> AirRic: What's the type of "showChar '}'"?
07:12:41 <sipa> :t showChar
07:12:42 <lambdabot> Char -> String -> String
07:12:59 <sipa> > showChar '}' "blabla"
07:13:00 <lambdabot>   "}blabla"
07:13:04 <merijn> sipa: That was a question a la socratic method >.>
07:13:16 <Rutix> pow
07:15:36 <AirRic> merijin: showType has the type showChar :: Char -> String -> String
07:15:54 <merijn> AirRic: To spoil the answer, you're composing a bunch of functions type ShowS (i.e. String -> String), the last value passed into this construction is "showChar "}"" which is also of type "String -> String", so the value you're returning is "String -> String" rather then "String".
07:16:21 <merijn> AirRic: So your result value from showHelp is waiting for a String to turn "String -> String" into "String"
07:16:49 <merijn> You should either change the definition of "showl []" or at some other point give the function a string
07:17:24 <merijn> Anyhoo, I'm off
07:36:02 <krey> hello, trying to understand continuations, I was wondering if you know any good exercises to do
07:40:56 <cheater2> Cale, you there? :)
07:41:26 <applicative> krey, do you mean, e.g. the Cont monad in Control.Monad.Cont or something more general?
07:42:01 <krey> applicative: general please
07:42:15 <krey> applicative: i'm thinking about learning scheme, maybe that would help...
07:43:52 <cheater2> hey guys, i'm on tryhaskell.org and try to do something simple like print "123" but it throws up errors about IO - what can i do about this?
07:44:13 <applicative> i suppose scheme has the most wildly developed infrastructure.  maybe haskell is better for learning the basic idea, though.
07:44:35 <quicksilver> cheater2: tryhaskell.org can't do IO.
07:44:50 <quicksilver> that's a security restriction
07:44:54 <applicative> kery, i suppose youve seen the amusing http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
07:44:58 <quicksilver> install ghci instead
07:45:13 <applicative> cheater2, print is an io function
07:45:20 <applicative> oh, what quicksilver said
07:45:33 <cheater2> i don't have access to ghci right now
07:45:41 <cheater2> how can i print something to the terminall on tryhaskell?
07:45:43 <applicative> do you want it to print 123 or the phrase "123"
07:46:01 <cheater2> i just want to be able to print things
07:46:04 <applicative> cheater, that's what happens when you press return
07:46:07 <cheater2> for example from functions
07:46:15 <cheater2> yes, i know, i can type in "123" and press enter
07:46:33 <applicative> if you write 2 + 2 , what happens is print (2 + 2)
07:46:48 <applicative> which is putStrLn (show (2 + 2) )
07:47:04 <applicative> which is putStrLn (show 4) which is putStrLn "4"
07:47:07 <krey> applicative: I read it some time ago when I didn't really know what a continuation is. time to read it again
07:47:41 <applicative> krey it brings out well enough how the Cont monad works I think, with the usual verve and intelligence
07:48:29 <applicative> cheater2, say more about what you want to do.   there is also e.g. codepad or ideone, which lets you do a bit of IO
07:48:52 <cheater2> ah, i just want to learn basic haskell stuff
07:49:01 <cheater2> experiment a little bit with list and state monads, that's all
07:49:46 <applicative> > [1,2,3] >>= show
07:49:47 <lambdabot>   "123"
07:49:57 <applicative> the list monad!
07:50:52 <tux_mark_5> hello
07:51:28 <fadax> thanks for the help guys, i figured it all out :-)
07:51:49 <ion> This description may or may not be helpful: print x returns a value that is an IO action. That is, when print x is evaluated, nothing is actually printed. runhaskell.org doesn’t implement the running of any IO actions, it just tries to show the value which isn’t implemented for IO actions, thus the error. For instance, the ghci REPL explicitly runs IO actions in addition to ‘show’ing values of other types.
07:52:49 <applicative> cheater2, you can talk to lambdabot in private.  you issue commands by prefixing "> " 
07:54:42 <tux_mark_5> could anyone compile that with -O and without -O ? http://hpaste.org/42331/something
07:55:37 * ManateeLazyCat Login Emacs in my another box. :)
07:55:40 <tux_mark_5> this 230 line file, which doesn't import anything produces 1.1 MB object file, when compiled with -O
07:55:50 <tux_mark_5> at least that's what happens on my system
07:55:55 <tromp> why not use deriving Enum?
07:56:27 <tux_mark_5> this code was generated by c2hs i think
07:56:57 <tux_mark_5> and i'm trying to figure out why libraries compiled with -dynamic are so huge
07:57:52 <tux_mark_5> i've been experimenting with cairo-0.12.0, and i've found out that Types.hs file, which is produced out of Types.chs is the cause, why compiled library is so huge
07:58:20 <edlinde> does anyone know of a haskell binary search tree implementation that takes key,value ?
07:58:25 <tux_mark_5> these two enums when compiled with -O are larger than the rest of cairo library ;D
07:58:40 <edlinde> have been looking around on the web and cannot find a good implementation
07:59:07 <ManateeLazyCat> tux_mark_5: Any problem with cairo? Are you binding something?
07:59:32 <tux_mark_5> ManateeLazyCat: i'm trying to figure out why all libs compiled with -dynamic are so huge
07:59:53 <tux_mark_5> ManateeLazyCat: and as an example i'm using cairo
08:00:10 <tux_mark_5> ManateeLazyCat: when compiled and stripped it weighs about 1.6 MB
08:00:13 <ManateeLazyCat> tux_mark_5: I think ghc static compile those library together.
08:00:21 <krey> applicative: nope, still don't make too much sense
08:00:36 <tux_mark_5> ManateeLazyCat: i compiled it with -dynamic
08:00:44 <tux_mark_5> so there is no static linking involved
08:00:47 <tux_mark_5> ldd confirms that
08:01:09 <ManateeLazyCat> tux_mark_5: Maybe ask in #ghc, i remember ghc not support dynamic linking in default.
08:01:26 <tux_mark_5> they don't seem to care about size of executables
08:01:55 <ManateeLazyCat> tux_mark_5: Maybe have some unnecessary import in your source code?
08:02:02 <nostrand> tux_mark_5: i replaced the explicit instansiation of Enum with deriving(Enum) and got 83K instead of 1.1M =)
08:02:04 <quicksilver> tux_mark_5: it's not that they don't care.
08:02:08 <tux_mark_5> http://hpaste.org/42331/something
08:02:17 <tux_mark_5> try compiling this with and without -O
08:02:23 <quicksilver> tux_mark_5: it's that there is no one there at the moment who knows the answer to your question.
08:02:28 <tux_mark_5> without -O i get 69 K
08:02:32 <quicksilver> tux_mark_5: the codegen was only written by 2 or 3 people
08:02:38 <tux_mark_5> with -O i get 1.1 M
08:02:55 <tux_mark_5> quicksilver: oh
08:03:05 <quicksilver> tux_mark_5: you can post an email to glasgow-haskell-users if you want to get the attention of an implementor
08:03:07 <tux_mark_5> quicksilver: i wasn't aware of that ;)
08:03:25 <tux_mark_5> quicksilver: ok. that's what i'll do then
08:04:01 <nostrand> tux_mark_5: remove line 44-203
08:04:39 <fliebel> What would be a good place to start learning Haskell for someone who knows Python and Clojure? Clojure is quite functional, but a few people recommended me to learn Haskell for some hardcore FP stuff :)
08:05:13 <nostrand> fliebel: learnyouahaskell and real world haskell are two good online books
08:05:18 <edlinde> can someone here help me just understand how I can change this binary search tree shown in --> http://oreguix.wordpress.com/2010/01/22/binary-search-tree-walks/   using key,value pairs?
08:05:48 <edlinde> the implementation has both keys and values as the same thing... but I need to separate them out
08:06:02 <tux_mark_5> nostrand: it helped
08:06:20 <pedro3005> what's the function for the absolute value of a number?
08:06:23 <nostrand> tux_mark_5: =)
08:06:23 <edlinde> any suggestions?
08:06:27 <nostrand> pedro3005: abs
08:06:29 <tux_mark_5> nostrand: but i don't get why these 2 lines can cause like 10x increase in size
08:06:52 <nostrand> tux_mark_5: 2 lines? its more like 160 lines.
08:07:25 <tux_mark_5> err
08:07:28 <fliebel> nostrand: Thanks
08:07:32 <int-e> edlinde: data Tree a b = EmptyTree | Node (Tree a b) a b (Tree a b) deriving (Show)  would be a suitable datatype. Of course if your purpose is to /use/ a key-value map, then Data.Map is your friend.
08:07:32 <nostrand> tux_mark_5: look at the core output, i suspect deriving... is more optimized
08:07:35 <tux_mark_5> i looked at the wrong terminal
08:07:37 <nostrand> fliebel: =)
08:08:03 <edlinde> int-e: can I say Tree a b?
08:08:28 <tux_mark_5> nostrand: personally, i think it's a bug
08:08:34 <int-e> edlinde: yes, a type constructor (as Tree here) can take several arguments.
08:08:39 <edlinde> I think the idea is that when its time to insert I will check the keys and know the position in the tree to palce it in
08:08:52 <tux_mark_5> it sounds so *stupid* that 2 enums can consume as much as 1 MB
08:08:58 <fliebel> nostrand: Uhm, isn't Clojure a functional language? "This tutorial is aimed at people who have experience in imperative programming languages but haven't programmed in a functional language before."
08:09:24 <edlinde> int-e: so you saying that I can change the defn to what you have... but then how will it affect the insert function?
08:09:25 <nostrand> tux_mark_5: on the other hand, you have a function with 160 cases
08:09:44 <tux_mark_5> nostrand: does it matter?
08:09:46 <nostrand> fliebel: it's easier if you have experience in a functional language =)
08:09:54 <nostrand> tux_mark_5: yeah
08:10:01 <tux_mark_5> nostrand: its about 100 LOCs we are talking about
08:10:15 <tux_mark_5> nostrand: and not some overblown Qt-GUI library
08:10:26 <nostrand> tux_mark_5: if people rarely write such code, why optimize for it?
08:10:33 <fliebel> nostrand: I hope it's still mind twisting :)
08:10:52 <nostrand> fliebel: yep
08:10:57 <tux_mark_5> nostrand: i don't think this kind of code is written rarely
08:11:01 <int-e> edlinde: well, it would take an extra argument, and wherever Node is used, you need to match an additional value. singleton  will also change.
08:11:10 <nostrand> tux_mark_5: i don't know =)
08:11:14 <tux_mark_5> nostrand: i suspect that 90% of all my haskell libs are oversized because of something like this
08:11:20 <edlinde> int-e: sent you a pvt
08:13:05 <fryguybob> fliebel: Perhaps you would be interested in: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:13:08 <pedro3005> is there a function for checking if an element is in a list?
08:13:23 <fliebel> fryguybob: Sure :)
08:13:43 <quicksilver> pedro3005: elem
08:15:37 * edwardk wakes up.
08:16:05 <applicative> hello edwardk
08:16:24 <edwardk> @tell copumpkin the Eckmann-Hilton argument
08:16:24 <lambdabot> Consider it noted.
08:16:59 <applicative> tux_mark_5, are you using ghc 7
08:17:30 <edlinde> what is singleton?
08:17:38 <edlinde> I get an error when I call it in my code
08:17:40 <applicative> edwark, Dr Chang has an excellent account of the  Eckmann-Hilton argument on youtube.
08:18:00 <edlinde> is this a predefined haskell keyword?
08:18:12 <tux_mark_5> applicative: no, i'm using ghc 6.12.1
08:18:14 <edwardk> applicative: yeah. i did a quick run through for copumpkin on the whiteboard
08:18:27 <edwardk> applicative: it comes up a lot in Richard Bird's work as 'abide'
08:18:39 <edlinde> any ideas?
08:18:50 <edwardk> edlinde: singleton is a convention not a keyword
08:19:04 <edwardk> edlinde: lots of modules export some 'singleton' method that builds a container out of a single value.
08:19:19 <edlinde> edwardk: I have a line of code that says --> insert x EmptyTree = singleton x
08:19:23 <edwardk> Data.Sequence.singleton :: a -> Seq a
08:19:29 <edlinde> and its complaining about that
08:19:34 <teki> Data.Set.singleton a -> Set a
08:19:42 <edwardk> did you make up the Tree?
08:19:56 <teki> edlinde: you may not have implemented the singleton method for the custom data type tree
08:19:57 <edlinde> nah
08:20:05 <edlinde> http://oreguix.wordpress.com/2010/01/22/binary-search-tree-walks/
08:20:05 <edwardk> then define something like singleton x = Fork EmptyTree x EmptyTree -- or whatever you called the binary node in your tree
08:20:11 <fliebel> UhOh, MacPorts has GHC 6.10.4_4, what is different in GHC 7?
08:20:16 <edlinde> edwardk: I am following this code and trying to compile it
08:20:24 <teki> edlinde: you will need to do
08:20:39 <edwardk> edlinde: they failed to provide the code for singleton
08:20:41 <teki> singleton :: a -> Tree a
08:20:45 <edlinde> ah crap
08:21:01 <applicative> heres the catster eckman hilton discussion, for the record http://www.youtube.com/watch?v=Rjdo-RWQVIY
08:21:23 <edwardk> edlinde: i dropped a comment on the blog with the code for it
08:21:35 <edwardk> but it is awaiting moderation
08:21:45 <teki> edlinde: if you're just copying the code in the provided example you should do singleton x = EmptyTree x EmptyTree
08:21:48 <edwardk> singleton x = Node EmptyTree x EmptyTree
08:21:50 <teki> yep
08:22:02 <teki> oh oops forgot the node
08:22:04 <edwardk> teki: s/=/= Node/ =)
08:22:06 <edwardk> yeah
08:22:27 <edlinde> thanks
08:22:33 <applicative> fliebel, the macports one is okay. you would need it anyway to build ghc 7.  On the other hand, why not the haskell platform installer for os x
08:23:00 <edwardk> applicative: yeah, she also has a nice page of an eckmann-hilton clock iirc
08:23:16 <applicative> the clock bit, was very memorable. 
08:23:33 <applicative> i wish i could teach so well
08:24:52 <fliebel> applicative: GHC 7 is bootstrapped on GHC 6? So.. is GHC 6 written in C?
08:25:26 <Twey> No, GHC 6 is bootstrapped on a slightly earlier version of GHC 6… ;)
08:25:46 <applicative> no, it's all written in haskell.  maybe i should take this back. it's the dev versions that require a ghc. twey seems to kknow
08:26:14 <Twey> All GHCs require a GHC to build
08:26:15 <applicative> an inital install ex nihilo uses some C and sed and so on.
08:26:27 <fliebel> Twey: So how does MacPorts manage to compile it?
08:26:30 <Twey> Well… I imagine there's a C one back in the mists of time somewhere
08:26:31 <Adamant> also, the RTS is in C
08:26:39 <Adamant> fliebel: it downloads a copy of GHC
08:26:41 <Twey> If you want to build one from source, you generally need to get a binary one and use that
08:26:52 <Twey> That's the way compilers generally work
08:26:55 <applicative> fliebel, the process is remarkable, I advise dropping acid and watching it in --vervose
08:27:14 <Adamant> fliebel: that's what a lot of port-like package managers do for similar language installs
08:27:22 <Adamant> when you're installing from source
08:27:27 <applicative> Twey, I have certainly built it many times without a shred of haskell binary on my system
08:27:32 <applicative> thats what macports does.
08:27:42 <Twey> applicative: By downloading a binary for you
08:27:43 <cheater2> will haskell platform work on vista?
08:27:49 <Adamant> applicative: again, it downloads
08:27:50 <Twey> applicative: (see Adamant's comment)
08:27:53 <Adamant> then compiles
08:28:00 <Twey> Then deletes :þ
08:28:04 <Adamant> yup
08:28:10 <Twey> cheater2: I believe so, yes
08:28:53 * applicative is too tired to prove this by finding old portfiles
08:29:30 <fliebel> applicative: I'm doing it for you. Only if port could do 'port locate ghc'
08:30:13 <applicative> fliebel, i'm not sure its the same now.  I use the Haskell Platform Installer now, which has its plusses and minuses.  
08:30:38 <teki> cheater2: i'm on win7 and haskell platform 6 works fine
08:31:26 <applicative> fliebel, it's a million times more convenient. it links in with the standard os x unix machinery; this can occasionally come into conflict with macports
08:31:37 <cheater2> thanks guys
08:32:25 <fliebel> applicative: I prefer MacPorts unless proven wrong. I quite like 'port upgrade outdated'
08:32:40 <iago> hi all, there is some way to force that all instances of a data family must be instances of some type class ? For example, I have a data family Bndr param1 param2 = ... for different binders types depending on some parameters, but I would like to restrict Eq binders
08:33:55 <applicative> fliebel, if you use macports a lot, and are skilled at it, it may be the best way.  I think I am going over to homebrew the next time i set up
08:34:38 <applicative> the Platform Installer, by the way has ghc-6.12     The macports one is 6.10, as you note, but it's 64 bit
08:34:40 <teki> iago: iirc it's considered bad practice to put typeclass restrictions in a data-type declaration
08:34:40 <quicksilver> if macports distributed binaries I'd love it.
08:34:51 <quicksilver> unfortunately they appear to be stuck in 1965
08:35:00 <teki> it's better to put them in constructors for the data type
08:35:04 <quicksilver> or they're ricers :)
08:35:27 <teki> iago: make sense?
08:35:32 <applicative> quicksilver, yeah, its a drag, the unixy infrastructure seems so nice, but everything is a bit of a trial.
08:35:42 <applicative> on the other hand, i'm using xmonad :)
08:36:28 <applicative> fliebel, i seem to remember a not too long ago reddit/r/haskell tempest, where people gave their different approaches to this question.
08:37:11 <fliebel> Hah, MacPorts is indeed using a bootstrap version.
08:37:20 <iago> teki, well, I think what I have asked is slightly different, I'm talking about restrict instances of a data family
08:37:28 <applicative> fliebel http://www.reddit.com/r/haskell/comments/d9wm2/is_it_time_for_a_strike_team_to_form_dedicated_to/
08:37:30 <iago> maybe the same applies here, though it is different
08:37:37 <applicative> so what is it using to bootstrap?
08:37:46 <applicative> fliebel ^^
08:38:26 <fliebel> applicative: Just a GHC binary a few minor versions behind.
08:38:52 <quicksilver> I thought it was bootstrapping from .hc files
08:38:53 <fliebel> applicative: It seems to depend on the architecture you're running. The portfile is rather complex.
08:38:55 <quicksilver> but you're probably right.
08:40:26 <applicative> fliebel, yes, the portfile defeated me.  I first used the macports one like 2 years ago, I'm confident I was building ex nihilo
08:40:53 <edlinde> edwardk: I get an error for insert :: (Ord a b) => a b -> Tree a b -> Tree a b
08:41:00 <edlinde> I think its the Ord
08:41:05 <edlinde> I didn't know what to put there
08:41:06 <edlinde> :(
08:41:11 <edwardk> edlinde: you only need the key to be ordered
08:41:14 <fliebel> applicative: How do you do that?
08:41:19 <edwardk> Ord a => 
08:41:23 <edlinde> right
08:41:31 <teki> iago: i'm not quite sure what you mean by that, but good luck with finding the answer
08:41:50 <iago> http://www.haskell.org/haskellwiki/GHC/Type_families
08:41:55 <applicative> fliebel, i'm just describing what i thing the port file for ghc 6.8 did.  i could be wrong but i doubt it
08:42:05 <applicative> the build would sometimes take 3 or 4 hours
08:42:12 <edlinde> edwardk: still get an error :(
08:42:13 <edlinde> insert :: (Ord a)  => a b -> Tree a b -> Tree a b
08:42:26 <edlinde>  Kind error: `a' is applied to too many type arguments
08:42:27 <edlinde>     In the type `a b'
08:42:27 <edlinde>     In the type `a b -> Tree a b -> Tree a b'
08:42:27 <edlinde>     In the type `(Ord a) => a b -> Tree a b -> Tree a b'
08:42:32 <danr> @djinn Monad m => m (m (m a)) -> m a
08:42:32 <lambdabot> -- f cannot be realized.
08:42:37 <danr> :(
08:42:56 <edwardk> insert :: Ord a => a -> b -> Tree a b -> Tree a b
08:43:00 <edlinde> ah its a -> b
08:43:05 <edlinde> yep gotcha
08:43:16 <applicative> fliebel, i'm confident that it's nonsense to say ghc can't be built without ghc; else it couldn't be ported to new architectures as it often is; or maybe that's a bad argument
08:44:11 <edlinde> edwardk: Still no luck :( will paste
08:44:43 <edlinde> http://paste.lisp.org/display/117689#2
08:44:45 <quicksilver> applicative: you get a version of GHC on a different archictecture to bootstrap via C files.
08:45:00 <quicksilver> it took 8 hours on my iBook G4, IIRC.
08:46:01 <edlinde> fixed
08:47:53 <applicative> quicksilver, yes, that's what i'm talking about.  you use some C to get it going, not a prior ghc
08:48:19 <applicative> quicksilver, it occurs  to me it may sometimes have taken that long; I would go to bed
08:48:29 <fliebel> quicksilver: So can you copile Haskell to C source?
08:48:43 <applicative> -fvia-C 
08:48:45 <quicksilver> fliebel: sort of.
08:48:55 <applicative> it's 'rather unusual' C
08:48:56 <quicksilver> it's not actually C.
08:49:08 <quicksilver> it's a horrendous mess which GCC compiles to invalid assembly
08:49:16 <quicksilver> which gets post-processed by a perl script
08:49:25 <quicksilver> and then assembled by an assembler.
08:49:31 <Adamant> quicksilver: isn't the Evil Mangler removed now?
08:49:34 <fliebel> *invalid* assemby...
08:49:40 <applicative> the llvm seems to be what the bosses think is the wave of the future
08:49:44 <Adamant> fliebel: invalid until processed
08:49:45 <quicksilver> Adamant: yes, but not for the special case we discuss above
08:49:59 <fliebel> Adamant: It's still around in the portfile I just saw.
08:49:59 <quicksilver> Adamant: you still use it if you're doing an .hc-bootstrap
08:50:11 <Adamant> ah
08:50:23 <quicksilver> applicative: we'd rather have a proper cross-compiler, which some people have been working on.
08:50:31 <applicative> fliebel, if you are interested in compilation to C and the like, you might look into the jhc, which is very experimental incomplete, avante garde etc
08:50:34 <quicksilver> (although a proper cross-compiler doesn't solve the macports bootstrap)
08:50:47 <Zao> I've never managed to compile GHC via HC.
08:50:51 <Zao> Not even on the same arch.
08:50:59 <Zao> I've tried since 6.6 or so :D
08:52:24 <applicative> fliebel, I think fvia-C is not intended to produce portable C exactly.  Rather, it is to take advantage of possible gcc optimizations and that sort of thing
08:52:46 <fliebel> okay
08:52:47 <quicksilver> applicative: FYI, I'm pretty sure the bosses have not abanded the native codegen.
08:52:49 <applicative> or that's one purpose
08:52:54 <quicksilver> extensive work is still going on in it.
08:53:05 <quicksilver> it's not clear that llvm can be as clever, because it's generic by its nature.
08:53:10 <quicksilver> but.... it's good to have the option.
08:53:21 <applicative> quicksilve, i meant, that -fviaC might be less of a focus, not native codegen
08:53:51 <quicksilver> yes, via-C is definitely deprecated.
08:54:00 <quicksilver> except as a bootstrapping path for now.
08:54:56 <applicative> that's all I meant.
08:57:40 <edlinde> I am trying to make sense of this code
08:57:43 <edlinde> select (x:xs) = (x,xs) : [ second (x:) (y,ys) | (y,ys) <- select xs]
08:57:55 <edlinde> wondering what the "second (x:) ... bit does?
08:58:08 <quicksilver> "second" applies a function to the right-hand half of a tuple
08:58:09 <quicksilver> watch:
08:58:18 <edlinde> ah ok 
08:58:18 <quicksilver> > second (*2) (5,7)
08:58:19 <lambdabot>   (5,14)
08:58:26 <edlinde> ok 
08:58:41 <quicksilver> there is really no reason to write "second (x:) (y,ys)" though
08:58:46 <edlinde> so in that case it was consing x to the head of ys
08:58:47 <quicksilver> you could just write (y,x:ys)
08:58:48 <quicksilver> ;)
08:58:53 <quicksilver> but, yes, exactly.
08:58:57 <edlinde> ok
08:59:08 <edlinde> yeah it looked slightly mysterious
08:59:11 <edlinde> with the second :)
08:59:16 <edlinde> thanks to you ... its no more
08:59:18 <applicative> is 'compilation' to C the standard route of the jhc, i'm confused looking at it.  can't remember much about it
09:00:15 <dumael> applicative: yes.
09:02:45 <tromp> :t second
09:02:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
09:03:32 <applicative> dumael, i see i'm looking at the user manual. do you have much experience with it?
09:05:44 <dumael> I have a wee bit of experience. It can be very fiddly as the error messages aren't great and the GC isn't precise.
09:06:21 <dumael> so compiling large programs can be somewhat beyond it.
09:07:06 <dumael> it auto-invokes the GCC compiler when compiling, so there is no 'middle step' in compiling your code.
09:07:14 <applicative> i see. I had some experience a year or so ago.  it would be nice if there were proper tutorials, i think Mr Meacham is not the voluble communicative type
09:07:16 <quicksilver> nonetheless it's quite remarkable how good it is
09:07:20 <quicksilver> even within its limitations
09:07:34 <quicksilver> after all, conventional wisdom is that standard C is a terrible intermediate language
09:07:44 <quicksilver> and it makes a pretty good job of it for some cases
09:08:22 <applicative> it seems to have an interpreter now, jhci?  don't remember that.
09:10:26 <dumael> yeah, I haven't use that at all. I'm not sure when that feature appeared, but it was around since 7.2 at least.
09:16:06 <applicative> maybe i'll install it again.  wish there were 'tutorials' other than e.g. http://mostlycode.wordpress.com/2010/07/28/its-jhcs-turn/
09:20:34 <applicative> i see, yes, this picture makes the role of the gcc in jhc's work plain http://repetae.net/computer/jhc/big-picture.pdf
09:22:27 <fliebel> Okay, I found myself yawning during Learn Yourself a Haskell. Besides the strange syntax, it's much like Clojure with some Python list magic strapped on. Type inference is fun, but I don't like the infix/prefix stuff. And why are the commas in the list syntax?
09:23:25 <sleepynate> haha, "much like clojure with some python..." cute :)
09:23:30 <Jafet> Guy who's making fliebel learn Haskell at gunpoint, please stop. It's bad for our success.
09:24:11 <fliebel> sleepynate: I could say something about Java and PHP as well, but I don't want to upset people ;)
09:24:24 <sleepynate> riiiiiight
09:25:10 <pedro3005> I wish someone would hold me at gunpoint and make me learn haskell
09:25:16 <pedro3005> I've been putting it off for so long
09:25:29 <fliebel> Jafet: I did this to myself. But I think I need a book or tut where they assume I know more ;)
09:25:39 <Jafet> @where rwh
09:25:39 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:25:53 <Zao> fliebel: To separate list elements.
09:25:54 <sleepynate> fliebel: check out haskell school of expression :P
09:26:09 <Zao> fliebel: A bit annoying to write things like   [f x, rofl copter bbq, 9001] otherwise.
09:26:14 <Jafet> And no, "clojure with some python list magic" isn't funny
09:26:15 <fliebel> Zao: But you separate function arguments with spaces!
09:26:45 <Zao> fliebel: After having to use SML for a month, Haskell's syntax is divine.
09:27:13 <sleepynate> function arguments in lisp are separated by spaces...
09:27:38 <fliebel> Zao: I'm not saying it's ugly. I just wonder why it is like it is.
09:27:48 <Jafet> Well, function calls in lisp are lists.
09:27:57 <Zao> fliebel: What alternatives would there be?
09:28:06 <Zao> Space already has lots of semantics.
09:28:29 <Philonous1> fliebel: Actually, elements of a list a separated by a colon, and that's because (:) is one of the list constructors
09:28:38 <fliebel> Zao: Ah, right… It's be hard to write [1 + 1] otherwise.
09:29:12 <Jafet> Philonous: except Read disowned that
09:31:08 <sleepynate> fliebel: short and sweet: i like haskell 'cause it lets me think in lisp with 1/5 the typing
09:31:37 * sleepynate ducks for bringing personal taste to #haskell
09:31:59 <Jafet> ...Haskell isn't all that great for programming Lisp in
09:32:34 <fliebel> Talking about ducks, where do I find a nice piece about the famous Haskell type system?
09:32:56 <applicative> fliebel, the miracle of Haskell is (1) the sublime type system (2) the consequent sublime treatemnt of IO (3) the beautiful syntax
09:33:08 <sleepynate> fliebel: check out the Haskell Typeclassopedia
09:33:25 <applicative> @where typeclassopedia
09:33:25 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:33:49 <applicative> fliebel ^^^ this presupposes a bit of knowledge, like what Learn You.. is teaching. 
09:34:06 <Jafet> http://okmij.org/ftp/Haskell
09:34:11 <sleepynate> he said he wanted more power
09:34:20 <Jafet> Lots of type system on that site
09:34:33 <applicative> haha
09:34:39 <fliebel> applicative: (1) Great! (2) Monads? (3) Hm, I hope I'll get used to it :)
09:34:51 <applicative> fliebel, right; you just need the typesystem really, you can chuck the rest
09:35:30 <applicative> fliebel, the type system is what gives rise to the abstractions of Functor, Applicative, Monad, Arrow and all the rest.  
09:36:00 <applicative> learning them is like entering a new world, that's my experience for what little it may be worth
09:36:12 <benmachine> I like lightweight syntax for functions
09:36:17 <Jafet> Brought to you by -fglasgow-exts! Terms and conditions apply.
09:36:21 <benmachine> so that you can abstract out basically all repetition
09:37:17 <zygoloid> fliebel: Monads aren't really what's nice about the treatment of IO. they're just an API which lets you do stuff with the quarantined IO values.
09:37:19 <applicative> fliebel, really it is the "declarative" aspect that makes this all so wonderful.  your module is just a series of definitions of terms
09:37:31 <fliebel> applicative: That typeclassopedia seems to be an empty page?
09:37:46 <applicative> fliebel, which since they are subject to a certain discipline can be executed by lambda reduction
09:37:54 <Saizan_> does typeclassopedia explains how typeclasses work?
09:38:09 <benmachine> mmm delicious declarations
09:38:14 <Jafet> If he's bored with LYAH, he should already know how type classes work
09:38:31 <Saizan_> i'm not sure about that
09:38:33 <applicative> fliebel, this one is working for me http://community.haskell.org/~yitz/typeclassopedia.pdf
09:38:46 <Jafet> That's a moral should, not a technical should
09:39:03 <benmachine> hmm
09:39:13 <applicative> Saizan_, I think it doesn't explain them. thats why one needs a prior tutorial
09:39:41 <fliebel> Jafet: Might be that I just need to skim a few chapters before I get to the interesting stuff.
09:40:59 <applicative> fliebel, i think that the tedium you are experiencing may be important.  it is crucial that in the first instance one views a haskell implemenation as an extensible calculator
09:41:34 <benmachine> erm
09:41:35 <benmachine> if you say so
09:41:47 <benmachine> I do remember lyah being slow to get started
09:42:12 <applicative> like the 'kent recursive calculator' . benmachine, the above remark is an almost quotation from Simon P J
09:43:36 <fliebel> applicative: But I already have 3 of those. Python: 1 + 1 Ruby: 1 + 1 Clojure: (+ 1 1) That last one was hard to master. Now, Haskell: 1 + 1 :(
09:43:58 <sleepynate> fliebel: (+ 1 1) works fine in haskell :)
09:44:09 * sleepynate ducks again
09:44:30 <Jafet> > (+ 1 1)
09:44:31 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:44:31 <lambdabot>    arising from a use of `...
09:44:35 <applicative> > (+) 1 1
09:44:36 <lambdabot>   2
09:44:44 <sleepynate> yes that
09:45:12 <Jafet> > 2 1
09:45:12 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:45:12 <lambdabot>    `GHC.Num.Num t' arising f...
09:45:14 <applicative> fliebel, yes, thats just what i'm saying. for haskell it turns out that writing a complex executable is via composition of expression like that
09:45:22 <fliebel> So how do I make my own infix functions?
09:45:40 <zygoloid> applicative: the 'kent recursive claculator' being k&r c? ;)
09:45:48 <Jafet> @where cheat
09:45:48 <lambdabot> I know nothing about cheat.
09:45:49 <fliebel> (this is my way to learn ^)
09:45:51 <Jafet> @where cheatsheet
09:45:51 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
09:45:58 <Saizan_> > let x +++ y = x - y in 4 +++ 6
09:45:59 <lambdabot>   -2
09:46:00 <applicative> > let (******) = foldr in (+) ****** 0 $ [1,2,3,4,5]
09:46:00 <lambdabot>   15
09:46:44 <Jafet> > let (******) = const x in (f******)
09:46:45 <lambdabot>   Ambiguous type variable `a' in the constraint:
09:46:45 <lambdabot>    `SimpleReflect.FromExpr a...
09:47:05 <Jafet> > let (******) = const 42 in (f******)
09:47:06 <lambdabot>   Ambiguous type variable `a' in the constraint:
09:47:06 <lambdabot>    `SimpleReflect.FromExpr a...
09:47:30 <applicative> zygoloid, no way http://en.wikipedia.org/wiki/Kent_Recursive_Calculator
09:47:34 <Saizan_> > let (******) x = const 42 x in (f******)
09:47:35 <lambdabot>   Ambiguous type variable `a' in the constraint:
09:47:35 <lambdabot>    `SimpleReflect.FromExpr a...
09:48:18 <Jafet> Hm, I thought that section wasn't allowed
09:48:28 <Saizan_> it is by ghc
09:48:35 <applicative> > let (&%^%$) = const in "Obama" &%^%$ "Bush"
09:48:36 <lambdabot>   "Obama"
09:48:58 <Jafet> Saizan: do you know the name of the extension?
09:49:17 <fliebel> Saizan_: So what made your let with the +++ make it an infix?
09:49:36 <applicative> the use of !@#$%^&*()_ makes it infix by default
09:49:45 <applicative> the use of 
09:49:48 <magicman> Jafet: PostfixOperators
09:50:20 <applicative> > ['a'..'z']++['A'..'Z'] -- makes it prefix by default
09:50:20 <lambdabot>   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
09:50:21 <Saizan_> fliebel: the fact that the name is composed by symbols and/or punctuation character (except for a few reserved ones)
09:50:55 <applicative>  _ and ' count as letters. 
09:51:12 <Saizan_> fliebel: when you have an identifier like that enclosing it with parens makes it work like a prefix one
09:51:14 <fliebel> > let x $^ z = x + z in 4 $^ 6
09:51:15 <lambdabot>   10
09:51:37 <fliebel> > let x $^ z = x + z in ($^) 4 6
09:51:38 <lambdabot>   10
09:51:39 <applicative> fliebel, but if you put parentheses around it goes prefix
09:51:42 <Saizan_> fliebel: vice versa if you have an alphanumeric one putting it between backticks makes it work like an infix one
09:51:53 <applicative> similarly if you put backticks around another its infix
09:51:58 <Saizan_> > 1 `elem` [1,2,3]
09:51:59 <Jafet> magicman: heh, I'd never find it in the manual with a name like that
09:51:59 <lambdabot>   True
09:52:02 <applicative> @quote fugue
09:52:02 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
09:52:42 <applicative> flievel, so the 'operator' 'function' distinction is completely superficial, just elegance
09:53:08 <fliebel> applicative: Can either form take more than 3 args?
09:53:14 <fliebel> *2
09:53:32 <applicative> fliebel, secretly everything just has one argument
09:53:34 <magicman> Jafet: Aye. For reference, it's here: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
09:53:44 <applicative> but fold, which I used above has three arguments
09:54:27 <applicative> but the 'operator' i made for it could only stand between two expressions, so I had to separate it from the list I was applying the op and seed to
09:54:39 <applicative> > let (******) = foldr in (+) ****** 0 $ [1,2,3,4,5]
09:54:39 <lambdabot>   15
09:54:59 <kmc> :t (`map`)
09:55:00 <lambdabot> parse error on input `)'
09:55:28 <applicative> kmc, aren't we supposed to be able to do that? It never seems to work
09:55:45 <kmc> i'm not sure what the Report says
09:55:48 <fliebel> applicative: Important question: Is there a function that will give me some help on a function? like 'doc foldr'
09:55:54 <kmc> you can do sections that way though
09:55:59 <kmc> :t (`map` [1,2,3])
09:56:00 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
09:56:11 <kmc> fliebel, :i in ghci will give you some info
09:56:12 <applicative> i was thinking more like
09:56:26 <kmc> and then you can look up docs at http://www.haskell.org/ghc/docs/latest/html/libraries/ or http://hackage.haskell.org/packages/archive/pkg-list.html
09:56:37 <fliebel> kmc: Thanks :)
09:56:48 <applicative> :t (`fold` 0)
09:56:48 <ion> > 1 `(`(`(+)`)`)` 2
09:56:49 <lambdabot> Not in scope: `fold'
09:56:49 <lambdabot>   <no location info>: parse error on input `('
09:56:53 <applicative> :t (`foldr` 0)
09:56:53 <lambdabot> forall a b. (Num b) => (a -> b -> b) -> [a] -> b
09:56:57 <applicative> oh it worked
09:57:32 <fliebel> gtg, thanks for the help. I'll likely be back later with more questions :)
09:57:49 <applicative> fliebel, please do
09:59:33 <comb> hi, I'm doing some profiling of a ghc-compiled program. The heap plot shows a large fraction of ARR_WORDS object. What are those?
09:59:53 <applicative> fliebel, right in ghci theres :i foldr   and also of course :t foldr for the type   :I can be used for types, typeclasses too
10:00:27 <applicative> if you bring a standard module into scope with :m Data.List, then :browse will list the functions exported with types
10:13:09 <Jesin> hmm
10:13:31 <Jesin> @unpl flip . (. flip id)
10:13:31 <lambdabot> (\ k b c -> k (\ f -> f c) b)
10:13:56 <Botje> wow
10:14:28 <Jesin> hm?
10:14:54 <Jesin> @unpl (.).(.)
10:14:54 <lambdabot> (\ i b c f -> i (b c f))
10:15:54 <Jesin> @pl \a b c d -> a b $ c d
10:15:54 <lambdabot> ((.) .)
10:16:02 <Jesin> @pl \a b c d -> a b (c d)
10:16:02 <lambdabot> ((.) .)
10:16:10 <Jesin> :p
10:16:21 <Jesin> these combinators are kinda interesting  :p
10:17:02 <zygoloid> @unpl ap return ap
10:17:02 <lambdabot> (return >>= \ b -> (\ j k -> j >>= \ h -> k >>= \ g -> return (h g)) >>= \ a -> return (b a))
10:17:49 <Jesin> @pl \fs x -> map ($ x) fs
10:17:49 <lambdabot> flip (map . flip id)
10:17:56 <Jesin> :D
10:18:01 <zygoloid> @@ @pl @unpl @pl @unpl ap return ap
10:18:01 <lambdabot>  ((. ((. (return .)) . (>>=))) . (>>=) >>=) . ((return .) =<< return)
10:18:07 <Jesin> ...
10:18:11 <Jesin> what's with all the @
10:18:23 <Jesin> @unpl flip (map . flip id)
10:18:23 <lambdabot> (\ b c -> map (\ f -> f c) b)
10:18:27 <zygoloid> composing multiple @commands
10:18:39 <zygoloid> i was hoping that it'd give me 'id'
10:18:50 <zygoloid> ap return ap is SKS which is I :)
10:18:55 <Jesin> ...
10:18:56 <Jesin> wow
10:18:58 <benmachine> @. pl unpl ap return return
10:18:58 <lambdabot> (return >>=) . (return .) =<< return
10:18:58 <Jesin> ok
10:19:00 <Jesin> :p
10:19:15 <benmachine> actually
10:19:17 <benmachine> :t ap return ap
10:19:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
10:19:21 <benmachine> ^ not id
10:19:31 <augur> what is it with you people
10:19:32 <augur> stop this nonsense
10:19:33 <augur> :|
10:19:37 <Jesin> lol
10:19:40 <benmachine> :t ap return return
10:19:41 <lambdabot>     Ambiguous type variable `m' in the constraint:
10:19:41 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
10:19:41 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:19:43 <benmachine> eek
10:20:08 <benmachine> :t ap const return
10:20:09 <lambdabot>     Ambiguous type variable `m' in the constraint:
10:20:09 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:9-14
10:20:09 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:20:12 <benmachine> bah
10:20:25 <Jesin> @unpl ((.).)
10:20:25 <lambdabot> (\ d g b c -> d g (b c))
10:20:31 <benmachine> :t ap return const
10:20:32 <lambdabot> forall b. b -> b
10:20:37 <benmachine> of course, that makes sense
10:21:50 <Jesin> hmm
10:22:06 <Jesin> @unpl f . . . g
10:22:06 <lambdabot>  Parse error at "." (column 5)
10:22:20 <Jesin> ah
10:22:24 <Jesin> so it doesn't work without parens
10:22:26 <Jesin> ok
10:22:46 <zygoloid> benmachine: it is id, in the untyped lambda calculus. in haskell it's id with a restricted type. and @pl tends to generalize, so...
10:22:55 <benmachine> oic
10:23:00 <benmachine> tends to!
10:23:13 <benmachine> I guess it's just not clever enough in this instance
10:23:15 <Jesin> @unpl (***)
10:23:15 <lambdabot> (***)
10:23:27 <Jesin> @unpl f *** g
10:23:27 <lambdabot> (f *** g)
10:23:38 * zygoloid gives a facetious example
10:23:41 <benmachine> unpl doesn't know about *** I guess
10:23:41 <zygoloid> @pl \f g x -> g (f x)
10:23:41 <lambdabot> flip (.)
10:23:44 <zygoloid> @type flip (.)
10:23:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
10:23:56 <benmachine> @pl liftM
10:23:56 <lambdabot> fmap
10:23:59 * benmachine more facetious
10:24:08 <zygoloid> :D that's not even a generalization
10:24:22 <benmachine> it's spiritually a generalisation :P
10:25:04 <Jesin> @type \f g x -> g (f x)
10:25:05 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t2) -> t -> t2
10:25:24 <Jesin> hmm
10:25:45 <Jesin> I'm not experienced enough with functors and monads to have an intuition for how that's a generalization  =/
10:26:31 <kmc> @unpl ap return ap
10:26:31 <lambdabot> (return >>= \ b -> (\ j k -> j >>= \ h -> k >>= \ g -> return (h g)) >>= \ a -> return (b a))
10:26:56 <Jesin> @unpl \(a,b) -> [a,b]
10:26:56 <lambdabot> \ (a, b) -> [a, b]
10:27:07 <Jesin> @unpl \(a,b) -> a:b:[]
10:27:07 <lambdabot> \ (a, b) -> a : b : []
10:27:14 <Jesin> erm
10:27:17 <Jesin> wrong command
10:27:21 <kmc> @pl \(a,b) -> a:b:[]
10:27:21 <lambdabot> uncurry ((. return) . (:))
10:27:22 <Jesin> @pl \(a,b) -> [a,b]
10:27:22 <lambdabot> uncurry ((. return) . (:))
10:27:30 <pedro3005> I get that it's great that a function given the same parameters will always return the same value, but what if it's a very expensive function and I don't want to have to compute it more than once, how can I store the return value to make some checks on it? (x is even, x is < 4 000 000)
10:27:41 <fliebel> applicative mentioned that functions secretly all have only one argument, how's that?
10:27:47 <kmc> pedro3005, using "let"
10:28:02 <kmc> let v = f x in ... use v many times, f x is only computed once ...
10:28:14 <Jesin> umm
10:28:24 <shachaf> fliebel: It's not particularly secret.
10:28:26 <pedro3005> kmc, can I use that in a list comprehension?
10:28:27 <Jesin> doesn't GHC generally make those optimizations itself?
10:28:29 <kmc> fliebel, instead of taking two arguments, take one argument and return a function which takes the second arg
10:28:38 <kmc> Jesin, not generally
10:28:51 <kmc> pedro3005, yes.  "let ... in ..." is an expression; you can use it anywhere an expression is allowed
10:29:02 <Jesin> hmm
10:29:16 <Jesin> how not generally?  :p
10:29:43 <fliebel> kmc: That is a weird thing to do, but it's interesting. :) Does Haskell have varargs?
10:29:43 <Jesin> umm
10:29:46 <kmc> i don't think GHC does common subexpression elimination
10:29:51 <Jesin> this is with -O2 turned on
10:29:53 <Jesin> and, what?
10:29:56 <Jesin> but
10:30:02 <ion> It’s a very useful thing to do. :-)
10:30:11 <Jesin> haskell has more referential transparency than most languages
10:30:19 <leimy> if it's a pure computation, it doesn't need to be recomputed
10:30:19 <Saizan_> ghc doesn't do CSE because it can introduce space leaks
10:30:22 <Jesin> how could GHC with optimizations turned on not do that?
10:30:35 <kmc> fliebel, it's simplifying (because you don't have to think about arity) and powerful (because you can partially apply functions, rather than writing explicit lambdas)
10:30:39 <c_wraith> Jesin: because it's rarely actually correct in haskell code.
10:30:41 <kmc> fliebel, sum = foldr (+) 0
10:30:46 <fliebel> ion: How is it useful? Can I give a function one argument, and call the second argume t somewhere else?
10:30:46 <kmc> rather than sum xs = foldr (+) 0 xs
10:30:50 <c_wraith> Jesin: or at least, rarely actually an optimization
10:30:59 <kmc> yep
10:31:02 <kmc> :t (+ 3)
10:31:03 <lambdabot> forall a. (Num a) => a -> a
10:31:08 <pedro3005> kmc, "let v = fib x in sum [v | x <- [1..34], v <= 4000000, v `mod` 2 == 0]" didn't work, how would I write that?
10:31:11 <kmc> (that's using a bit of syntactic sugar as well)
10:31:17 <Saizan_> Jesin: by keeping the result around you're trading space for time, but using too much space has a bad effect on time too
10:31:20 <leimy> I suppose with lazy evaluation, you might not want something fully evaluated every time.
10:31:32 <Jesin> hmm
10:31:49 <leimy> Yeah, locality is where it's at :-)
10:31:58 <Jesin> how good is GHC at parallelizing stuff?  (perhaps this question is too general?  :p )
10:32:08 <c_wraith> It doesn't auto-parallelize anything.
10:32:18 <fliebel> whoa, you guys are typing faster than I can think and read at the same time ;)
10:32:23 <leimy> lazy evaluation is really a form of implicit concurrency :-)
10:32:35 <leimy> but not necessarily parallelization -)
10:32:48 <kmc> yes, you'll find Haskellers tend to make a distinction between parallelism and concurrency
10:32:54 <kmc> while other groups muddle together these concepts
10:33:06 <leimy> kmc: yes... it's important to draw some good definitions
10:33:07 <kmc> because GHC Haskell has parallelism without concurrency; that is, multi-core utilization without changing semantics
10:33:11 <kmc> see the "parallel" package
10:33:16 <leimy> yep
10:33:21 <kmc> if you want explicit threads and thread communication, we also have that
10:33:27 <Saizan_> and then other groups make different distinctions :)
10:33:33 <kmc> specifically, GHC has lightweight threads
10:33:35 <Jesin> I meant without changing the code much
10:33:37 <Jesin> :p
10:33:45 <leimy> There's data parallelization, and there's thread level concurrency that might have the threads run in parallel.
10:33:46 <fliebel> kmc: So Haskell is almost stack based?
10:34:00 <kmc> fliebel, I'm not sure what that means
10:34:11 <Saizan_> Jesin: parallel annotations are very lightweight, as in the parallel package
10:34:13 <kmc> fliebel, Haskell is a standardized language with a spec, and that spec says very little about operational details of the implementation
10:34:18 <Jesin> hmm.
10:34:18 <leimy> Does GHC 64bit work on Mac OS X yet?
10:34:32 <Jesin> I guess I'll look at that package sometime then  :p
10:34:58 <fliebel> kmc: You have a function that slurps up the next argument on the line every time. In a stack based lang, functions slurp input from the stack instead.
10:35:00 <leimy> Anyone ever  tried out Factor.  Concatenative programming is fun.  Like point-free Haskell style :-).
10:35:13 <kmc> fliebel, oh, right.  it's a little bit like that, but not very
10:35:17 <Saizan_> Jesin: there's also DPH which is Data Parallel Haskell which offers some special brand of arrays whose operations are automatically parallelized, but it's still somewhat experimental
10:35:18 <Jesin> @pl swing f c a = f ($ a) c
10:35:18 <lambdabot> swing = flip . (. flip id)
10:35:21 <Zao> leimy: Sounds a bit pointless :D
10:35:29 <fliebel> leimy: Just what I mean!
10:35:31 <leimy> Zao: it's totally pointless, and interesting :-)
10:35:39 <leimy> fliebel: yeah, tha's what made me think of factor :-)
10:36:25 <Jesin> heh, I kinda like the swing combinator (seen here: http://www.haskell.org/haskellwiki/Pointfree )
10:36:29 <Jesin> p
10:36:33 <Jesin> *:p
10:36:43 <Jesin> hmm
10:37:36 <MHD0> What does Arrow parsers do better than Monadic ones?
10:37:44 <fliebel> I think the world needs more tutorials of the "wow, why did it do that?" kind. Stuff like (+) 1 2 can keep my attention for hours, but 1 + 2 is rather boring.
10:37:48 <Saizan_> i'm pretty sure there's some theorem relating stack based languages and SKI combinators
10:37:59 <fliebel> SKI?
10:38:13 * fliebel ducks
10:38:36 <Jesin> swing partition :: forall a. [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
10:38:38 <Jesin> :D
10:38:39 <ion> fliebel: In many languages, you can refer to functions as f, returning the function itself, or the equivalent of f 42 "foo" True, passing all the parameters and returning the function’s return value. Currying makes it possible to refer to a partial application, e.g. let g = f 42 "foo" in g True. That’s often useful when combining functions, e.g. let f = reverse . filter isAlpha in f "foo". Here we’re thinking in terms of putting functions together, instead
10:38:45 <ion> of in terms of moving data around.
10:38:54 <xrch> s x y z = x z (y z), k x y = x, i x = x
10:39:22 <pedro3005> kmc, hello?
10:39:26 <ion> > let f = reverse . filter isAlpha in f "foo 42 bar"
10:39:27 <lambdabot>   "raboof"
10:39:29 <kmc> fliebel, http://en.wikipedia.org/wiki/Combinatory_logic
10:39:35 <Jesin> ooh
10:39:37 <Jesin> even more fun
10:39:38 <kmc> pedro3005, you should ask the whole room; maybe someone else can help you
10:39:48 <fliebel> kmc, thanks
10:39:49 <Saizan_> fliebel: s, k, and i that xrch wrote are sufficient to write every lambda calculus expression (which is basically haskell stripped down to a minimum, with no datatypes nor pattern matching) without ever mentioning variables
10:40:08 <pedro3005> Hi room; "let v = fib x in sum [v | x <- [1..34], v <= 4000000, v `mod` 2 == 0]" didn't work, how would I write that?
10:40:21 <mauke> and i is redundant
10:40:28 <Jesin> so are S and K, if you do this
10:40:34 <kmc> pedro3005, x isn't in scope out there; x is bound within the list comprehension by "x <- ..."
10:40:51 <pedro3005> kmc, yeah, that's what ghci said, but I don't know how to fix it
10:40:58 <xrch> i = s k k
10:41:00 <mauke> pedro3005: what is that supposed to do?
10:41:07 <nlogax> the pandoc binary has a --no-wrap option, is this in the library somewhere? i can't find it :)
10:41:07 <kmc> you can actually use a different form of "let" within the list compr.
10:41:22 <kmc> [v | x <- [1..34], let v = fib x, v <= 4000000, v `mod` 2 == 0]
10:41:26 <Jesin> u f = (f s) k
10:41:33 <mauke> ah! that didn't even occur to me
10:41:36 <Jesin> define u like that
10:41:46 * Jesin is pulling this off wikipedia  :p
10:41:52 <Jesin> and then I = UU
10:41:55 <pedro3005> mauke, sum all the fibonacci values up to the 34th which are even and less than or equal to 4 million
10:41:57 <Saizan_> fliebel: but composing functions in haskell is not normally viewed as manipulating a stack
10:41:57 <Jesin> K = U(UU)
10:42:14 <fliebel> Saizan_: I see
10:42:14 <Jesin> and S = UK
10:42:16 <kmc> pedro3005, note that the <= condition will not actually terminate your list
10:42:31 <pedro3005> yes, that's why I added the 34
10:42:32 <kmc> pedro3005, try this:  [x | x <- [1..], x < 50]
10:42:37 <kmc> yeah
10:42:38 <kmc> it will hang
10:42:54 <kmc> basically the boolean condition desugars to "filter" but sometimes you want "takeWhile" instead
10:42:56 <kmc> :t takeWhile
10:42:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:43:00 <mauke> pedro3005: sum . filter even . takeWhile (<= 4000000) . take 34 $ fibs
10:43:03 <mightybyte> Is anyone maintaining the lambdabot code?
10:43:06 <pedro3005> oh I see
10:43:09 <fliebel> kmc: Okay, I get the composition point. Everything can be composed of S, K and I, but what are they?
10:43:18 <kmc> they're defined on that wikipedia page
10:43:19 <pedro3005> I hadn't learned about takeWhile yet
10:43:27 <kmc> s f g x = f x (g x)
10:43:29 <Jesin> :t flip . (. flip id) $ map
10:43:30 <lambdabot> forall a b. [a -> b] -> a -> [b]
10:43:31 <kmc> k x y = x
10:43:38 <mauke> Jesin: sequence
10:43:39 <Jesin> :t flip . (. flip id) $ partition
10:43:40 <lambdabot> forall a. [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
10:43:53 <Jesin> :t sequence
10:43:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:44:05 <Jesin> hmm.
10:44:09 <roconnor> I = SKK
10:44:09 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
10:44:18 <mauke> I = SKS
10:44:21 <mauke> I'm a rebel
10:44:26 <kmc> :t let s f g x = f x (g x); k x y = x in s k k
10:44:27 <lambdabot> forall t. t -> t
10:44:30 <Jesin> :t flip . (. flip id) $ zipWith
10:44:30 <lambdabot> forall a b c. [a -> b -> c] -> a -> [b] -> [c]
10:44:42 <ozataman> hi all - has anybody seen where Bulat's TemplateHaskell tutorials went? The links are not working on the haskell wiki...
10:44:48 <Jesin> :t zipWith
10:44:48 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:44:51 <kmc> note that you can't write all programs in a *typed* SK calculus
10:44:51 <Jesin> hmm...
10:44:55 <mauke> > sequence [f, g, h] x
10:44:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:44:56 <lambdabot>    `GHC.Show.Show a'
10:44:56 <lambdabot>      a...
10:44:56 <roconnor> @seen koninkje_away
10:44:56 <lambdabot> Unknown command, try @list
10:44:56 <preflex>  koninkje_away was last seen on #haskell-in-depth 10 days, 11 hours, 41 minutes and 31 seconds ago, saying: @tell roconnor assuming composePlate is associative and complete (i.e., closed, not total) and assuming purePlate is the identity for composePlate, then it is a category regardless; with multiplate an endofunctor
10:45:00 <roconnor> @seen koninkje
10:45:00 <preflex>  koninkje was last seen 13 hours, 42 minutes and 56 seconds ago, saying: <private message>
10:45:00 <lambdabot> Unknown command, try @list
10:45:38 <paolino> > (1%10 :: Rational) ^ (-1)
10:45:38 <lambdabot>   *Exception: Negative exponent
10:45:40 <mauke> > sequence [f, g, h] x :: [Expr]
10:45:40 <lambdabot>   [f x,g x,h x]
10:45:43 <Jesin> :t flip . (. flip id) $ foldr
10:45:43 <lambdabot> forall a a1. a -> a1 -> [a1 -> a -> a] -> a
10:45:47 <Jesin> :t flip . (. flip id) $ foldl
10:45:48 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> a -> b
10:45:48 <lambdabot>     Probable cause: `foldl' is applied to too few arguments
10:45:48 <lambdabot>     In the second argument of `($)', namely `foldl'
10:45:57 <Jesin> :t flip . (. flip id) $ flip foldl
10:45:58 <lambdabot> forall a b b1. (((a -> b) -> b) -> b1 -> (a -> b) -> b) -> a -> [b1] -> (a -> b) -> b
10:46:04 <mauke> > 0.1 ^^ (-1) :: Rational
10:46:05 <lambdabot>   10 % 1
10:46:06 <Jesin> wtf did I just do
10:46:09 <Jesin> :p
10:46:12 <paolino> ooh
10:46:30 <Jesin> :t flip . (. flip id) $ foldl . flip
10:46:31 <lambdabot> forall a a1. a -> a1 -> [a1 -> a -> a] -> a
10:46:34 <paolino> :t (^^)
10:46:34 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
10:47:09 <Jesin> @unpl flip . (. flip id)
10:47:09 <lambdabot> (\ k b c -> k (\ f -> f c) b)
10:47:28 <paolino> thanks mauke
10:50:35 <sleepynate> i love when i come back to the channel and it looks like bad ascii art signed by lambdabot
10:50:46 <roconnor> @tell koninkje Yes.  I figured out it was a monoid natural transformation (an endo- one as you note since it transforms the functor to itself).  Interestingly the required laws of the monoid natural transformation line up exactly with the laws of a coalgebra of a comonad.  I wonder if this coincidence is a lucky consequence of my particular instance, or there is a general relationship between monoid natural transformations and coalgebras of 
10:50:46 <lambdabot> Consider it noted.
10:50:47 <roconnor> comonads?
10:50:54 <Jesin> @ pl qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
10:50:58 <Jesin> eh
10:51:00 <Jesin> missed
10:51:03 <Jesin> @pl qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
10:51:03 <lambdabot> qsort = fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))
10:51:05 <roconnor> @tell koninkje comonads?
10:51:05 <lambdabot> Consider it noted.
10:51:12 <Jesin> that's horrible
10:51:24 <Jesin> hmm
10:51:28 <Jesin> maybe I should've done this instead
10:51:28 <aristid> Jesin: it is
10:51:28 <roconnor> Jesin: that is really tree sort
10:51:47 <Jesin> I know, haskell doesn't do true in-place quicksort easily
10:51:49 <roconnor> quicksort is supposed to be in place
10:51:50 <Jesin> because it's in place
10:51:52 <Jesin> :p
10:51:55 <roconnor> right :)
10:52:10 <c_wraith> also, using partition instead of filter twice would be a constant-factor improvement :)
10:52:14 <Jesin> haskell doesn't do in-place easily  :p
10:52:15 <c_wraith> :t partition
10:52:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:52:17 <aristid> i think quicksort also does not use lists ;)
10:52:34 <sleepynate> can we start a new memgenerator face called "overcorrecting haskeller" ?
10:52:43 <aristid> Jesin: it's definitely doable :)
10:52:50 <Jesin> I said easily
10:52:52 <Jesin> :p
10:53:03 <aristid> it's probably not hard either
10:53:03 <Jesin> @pl qsort [] = []; qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
10:53:03 <lambdabot> (line 1, column 10):
10:53:03 <lambdabot> unexpected "="
10:53:03 <lambdabot> expecting variable, "(", operator or end of input
10:53:15 <benmachine> @pl qsort (x:xs) = let (ys, zs) = partition (x >=) xs in ys ++ [x] ++ zs
10:53:15 <lambdabot> (line 1, column 14):
10:53:15 <lambdabot> unexpected "="
10:53:15 <lambdabot> expecting variable, "(", operator or end of input
10:53:17 <Jesin> eh.
10:53:21 <c_wraith> Eh.  Mutable arrays in haskell are pretty easy.
10:53:22 <aristid> Jesin: but the code won't look as beautiful as that of tree-sort ;)
10:53:25 <benmachine> aw
10:53:55 <benmachine> @pl qsort (x:xs) = (\(ys, zs) -> ys ++ [x] ++ zs) (partition (x >=) xs)
10:53:55 <lambdabot> qsort = ap (ap ((.) . (`ap` snd) . (. fst) . flip ((.) . (++)) . (:)) (partition . (>=)) . head) tail
10:53:57 <Jesin> hmm
10:54:01 <benmachine> beautiful.
10:54:09 <aristid> :t let qsort (x:xs) = let (ys, zs) = partition (x >=) xs in ys ++ [x] ++ zs
10:54:09 <lambdabot> <no location info>:
10:54:09 <lambdabot>     not an expression: `let qsort (x:xs) = let (ys, zs) = partition (x >=) xs in ys ++ [x] ++ zs'
10:54:22 <aristid> :t let qsort (x:xs) = let (ys, zs) = partition (x >=) xs in ys ++ [x] ++ zs in qsort
10:54:23 <lambdabot> forall t. (Ord t) => [t] -> [t]
10:54:45 <aristid> :t let qsort (x:xs) = let (ys, zs) = (x:) <$> partition (x >=) xs in ys ++ zs in qsort
10:54:45 <lambdabot> forall t. (Ord t) => [t] -> [t]
10:54:46 <Jesin> how's the "sort" function in the standard library implemented btw?
10:54:58 <benmachine> mergesort I think
10:55:21 <aristid> :t let qsort (x:xs) = uncurry (++) $ (x:) <$> partition (x >=) xs in qsort
10:55:21 <lambdabot> forall t. (Ord t) => [t] -> [t]
10:55:23 <Jesin> is there anywhere I can conveniently find the code for that?
10:55:31 <aristid> @pl qsort (x:xs) = uncurry (++) $ (x:) <$> partition (x >=) xs
10:55:31 <lambdabot> qsort = ap ((uncurry (++) .) . ap ((.) . (<$>) . (:)) (partition . (>=)) . head) tail
10:55:43 <aristid> benmachine: :)
10:56:04 <benmachine> aristid: neat
10:56:44 * sleepynate clap
10:56:47 <aristid> > let qsort (x:xs) = uncurry (++) $ (x:) <$> partition (x >=) xs in qsort [4,5,1,9,3,7,8,2,9,1]
10:56:47 <lambdabot>   [1,3,2,1,4,5,9,7,8,9]
10:57:01 <aristid> except it does not work :D
10:57:20 <benmachine> wups
10:57:28 <benmachine> is the comparison right?
10:57:33 <benmachine> I didn't think about it too hard
10:57:44 <benmachine> Jesin: http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/src/Data-List.html
10:59:29 <Jesin> hmm
10:59:31 <Jesin> #ifdef USE_REPORT_PRELUDE
10:59:42 <Jesin> in what situations would that succeed?
11:00:05 <benmachine> aristid: oh wait, you didn't qsort the halves
11:00:07 <c_wraith> in the case someone passed -DUSE_REPORT_PRELUDE to the compilation
11:00:09 <benmachine> aristid: you also don't have a [] case
11:00:37 <aristid> benmachine: nor do you?
11:00:48 <benmachine> possibly
11:01:43 <benmachine> that's beside the point >_>
11:02:36 <Jesin> umm
11:02:38 <Jesin>   where
11:02:40 <Jesin>     sequences (a:b:xs)
11:02:42 <Jesin>       | a `cmp` b == GT = descending b [a]  xs
11:02:43 <Jesin>       | otherwise       = ascending  b (a:) xs
11:02:46 <Jesin> why do they use `cmp` instead of >
11:02:56 <benmachine> mystery to me
11:03:14 <aristid> Jesin: because cmp is a parameter?
11:03:20 <benmachine> oya
11:03:23 <benmachine> makes sense
11:03:23 <Jesin> ...
11:03:25 <Jesin> ah.
11:03:26 <benmachine> it's not compare
11:03:30 <Jesin> yeah, now it does
11:03:31 <Jesin> ok
11:03:34 <Jesin> oops!  :p
11:04:53 <fliebel> What is the -> for I keep seeing everywhere? It's a bit hard to Google that without a name, you see :)
11:05:08 <benmachine> fliebel: in types, it means a function
11:05:37 <c_wraith> @where lyah
11:05:37 <lambdabot> http://www.learnyouahaskell.com/
11:05:52 <fliebel> benmachine: Okay, back to types. :)
11:05:52 <Saizan_> "your patterns are inexhaustive!" "so are yours!" is quite funny
11:05:53 * bxc sees someone trying to paste url http://www.haskell.org/~pairwise/intro/intro.html
11:05:55 <c_wraith> fliebel, I suggest read through the first few chapters of that to get a handle on haskell's syntax, at least
11:06:01 <bxc> which doesn't work any more
11:06:05 <bxc> presumably with server more
11:06:09 <bxc> server moVe
11:06:25 <fliebel> c_wraith: Totally true :)
11:06:48 <bxc> does anyone own that url?
11:07:34 <Guest29911> can anyone tell me the latest LOIC HIVE address please 
11:07:40 <benmachine> fliebel: http://haskell.org/haskellwiki/Keywords#-.3E
11:07:48 <Zao> Guest29911: No.
11:08:36 <benmachine> fliebel: a bit more in-depth than you wanted, but that page is good for un-googleable things
11:09:09 <Rutix> Guest29911: Not on this network so learn to google
11:12:46 <Jesin> ...
11:12:55 <Jesin> I just saw something about a continuation monad
11:13:08 <Saizan_> and?
11:13:22 <Jesin> is that built into GHC's libraries?
11:13:34 <c_wraith> No.
11:13:34 <Saizan_> no
11:13:39 <Jesin> k
11:13:56 <c_wraith> I think, as of GHC 7, the only monads built in are IO, [], Maybe, and Either a
11:14:16 <c_wraith> With Either a being a new addition
11:14:28 <Saizan_> it's just defined within the language by abstracting Continuation-Passing-Style into a Monad
11:14:52 <benmachine> c_wraith: (->) r -- :P
11:15:02 <c_wraith> Ah, yes.  I did forget that one.
11:15:08 <kmc> yeah, most of the "generic" monads come from the package "mtl", which is (as of version 2) a compatibility layer for the package "transformers"
11:15:16 <Saizan> Monad ((->) r) is defined in the base libraries?
11:15:20 <kmc> mtl is in Haskell Platform though
11:15:24 <benmachine> Saizan: Control.Monad.Instances
11:15:52 <Saizan> benmachine: heh, i always thought that was from mtl
11:16:13 <tehgeekmeister> lazy evaluation has ruined other languages for me.
11:16:15 <tehgeekmeister> =/
11:16:17 <benmachine> nah, it's in base but just tucked away so that it doesn't interfere with the prelude
11:16:24 <benmachine> tehgeekmeister: I know :(
11:16:41 <Jesin> @pl func2 f g l = filter f (map g l)
11:16:41 <lambdabot> func2 = (. map) . (.) . filter
11:17:09 <augur> im in a good mood
11:17:09 <augur> :D
11:17:13 * augur GHCs everyone
11:17:26 * sproingie fails to compile
11:17:35 <augur> nooooooo D:
11:17:59 <sleepynate> No instance for (Sleepynate (t -> a))
11:18:06 * fliebel feels the protons from augur's great hadron collider fly through his head.
11:18:09 <tehgeekmeister> i just want to print the output of a function call, but nooooooooo, ruby insists on evaluating the whole thing first.  which makes debugging it a pain.  I DON'T KNOW IF IT'LL EVER HALT.
11:18:21 <Jesin> @pl (\k t -> chr $ a + flip mod 26 (ord k + ord t -2*a))
11:18:21 <lambdabot> ((chr . (a +) . flip mod 26) .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
11:18:25 <augur> tehgeekmeister: what
11:18:29 <Jesin> D:
11:18:38 <augur> tehgeekmeister: #haskell-blah
11:18:40 <Jesin> @unpl flip
11:18:40 <lambdabot> (\ a b c -> a c b)
11:18:44 <Jesin> @unpl flip flip
11:18:44 <lambdabot> (\ b c f -> c f b)
11:18:50 <Jesin> @unpl flip flip flip
11:18:50 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
11:19:07 <Jesin> @pl flip flip flip
11:19:08 <lambdabot> flip flip flip
11:19:11 <Jesin> @pl flip flip flip flip
11:19:11 <lambdabot> flip flip flip
11:19:16 <Jesin> @pl flip flip flip flip flip
11:19:16 <lambdabot> flip flip flip
11:19:16 <augur> tehgeekmeister: seriously. #haskell-blah
11:19:17 <tehgeekmeister> augur: right, sorry
11:19:47 <benmachine> man I don't think it was that big a deal :P
11:20:22 <mauke> augur: that was off-topic for #haskell-blah
11:20:45 <Jesin> http://blog.hackers-cafe.net/2010/07/real-point-free-haskell-program.html ...lol
11:20:55 <augur> mauke: which was? ruby?
11:21:02 <augur> ruby is NEVER off topic for a non-haskell channel!
11:21:20 <mauke> augur: oh, true. it was specifically about lazy evaluation and ruby. sorry
11:21:33 <sleepynate> augur: so i'm trying to rewrite ruby in haskell so that it will actually be good...
11:22:18 <fliebel> I heard of some Clojure guy who is trowing together all sorts of lazy and immutable stuuf together to make a nice Ruby :)
11:23:24 <Jesin> eh, have to go
11:24:58 <fliebel> I'm starting to like this stack-like stuff :)
11:25:05 <fliebel> > take 20 (map (2 *) [1..])
11:25:06 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]
11:25:19 <mauke> > take 20 . map (2 *) $ [1 ..]
11:25:20 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]
11:25:41 <fliebel> mauke: What's . and $ for?
11:25:45 <kmc> @src ($)
11:25:45 <lambdabot> f $ x = f x
11:25:47 <kmc> @src (.)
11:25:47 <lambdabot> (f . g) x = f (g x)
11:25:47 <lambdabot> NB: In lambdabot,  (.) = fmap
11:25:54 <kmc> (.) is function composition
11:26:01 <kmc> ($) is just function application, with a low operator precedence
11:26:22 <kmc> (f . g . h $ x) === f (g (h x))
11:26:38 <kmc> but (unlike what some beginners believe) $ and . are ordinary operators, not special syntax, so you can use them in other ways too
11:26:42 <kmc> > map ($3) [pred, succ, id]
11:26:43 <lambdabot>   [2,4,3]
11:26:50 <xrch> > (+3) . Just 4
11:26:51 <lambdabot>   Just 7
11:26:58 <xrch> hey hey, cool
11:27:06 <kmc> yeah, lambdabot's (.) is generalized beyond the Prelude one
11:27:06 <Zao> xrch: Silly fmap'd . :D
11:27:12 <fliebel> kmc: That is what I mean, you type faster than I can think/figure out what you just said :)
11:27:24 <xrch> didn't know that until now
11:29:05 <McManiaC> btw, did they fix the bytestring lately? there are some serious typos in version 0.9.1.8 which won't let it compile at all
11:29:05 <fliebel> kmc: I think I get the dot, but… if f $ a = f a, why write the extra $?
11:29:14 <xrch> for example
11:29:25 <xrch> f (3 + 3) is f $ 3 + 3
11:29:41 <xrch> because ($) has a low precedence
11:29:53 <xrch> so (3 + 3) is evaluated first
11:30:28 <benmachine> McManiaC: uhm, I have 0.9.1.8 installed
11:30:35 <xrch> > (+1) 3 * 3
11:30:35 <lambdabot>   12
11:30:38 <fliebel> ah, right, so $ is just a way of saying do the stuff on the right first.
11:30:40 <xrch> > (+1) $ 3 * 3
11:30:41 <lambdabot>   10
11:31:41 <fliebel> cool
11:31:44 <tromp> no, $ is just a way to group operations
11:31:52 <tromp> it implies no evaluation order
11:32:08 <tromp> const 0 $ undefined
11:32:12 <tromp> > const 0 $ undefined
11:32:13 <lambdabot>   0
11:32:26 <McManiaC> benmachine: Data\ByteString.hs:1959:21: Parse error in pattern  (no "do" here), and after fixing that: http://npaste.de/sI/ (h -> hh, import those functions -> everything works again)
11:32:29 <kmc> the point is that "f $ g x y" is f (g x y) but "f g x y" is not
11:32:47 <tromp> it is also useful in sections
11:33:09 <tromp> map ($3) [pred,succ]
11:33:12 <tromp> > map ($3) [pred,succ]
11:33:13 <lambdabot>   [2,4]
11:34:34 <tromp> finally, it associates differently from application
11:34:47 <tromp> > succ $ pred $ 2
11:34:48 <lambdabot>   2
11:35:11 <sproingie> $ just effectively groups everything to the right of it in parenthesis because of its low precedence.  don't assume something forces evaluation in haskell
11:35:17 <sproingie> unless that something is seq
11:35:27 <tromp> but that is not particularly useful, since you normally avoid multiple $
11:35:38 <sproingie> > succ . pred $ 2
11:35:39 <lambdabot>   2
11:38:08 <benmachine> McManiaC: on linux it compiles fine, are you windows?
11:38:40 <augur> byorgey_!
11:38:49 <aristid> tromp: the usefulness comes from the fact that normally function application has the highest precedence. now with ($) you also have the same with the lowest precedence
11:39:12 <Zao> benmachine: His paste hints towards that.
11:39:17 <Zao> However, it does not reveal what GHC version.
11:39:24 <tromp> yes, the precedence is very useful, the associativity not much
11:39:40 <benmachine> Zao: true
11:40:06 <benmachine> wait hold on
11:41:24 <aristid> tromp: i also like using ($) as a function, because it is sometimes easier to understand than it
11:41:33 <aristid> *than id
11:41:49 <McManiaC> benmachine: yes
11:42:02 <kmc> :t zipWith ($)
11:42:03 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
11:42:05 <kmc> :t zipWith id
11:42:05 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
11:42:59 <benmachine> McManiaC: where did you get the source?
11:46:00 <McManiaC> benmachine: cabal unpack
11:46:10 <benmachine> weird.
11:46:23 <benmachine> the errors you are reporting are fixed in the darcs version
11:46:32 <benmachine> it looks like they were also introduced in the darcs version
11:46:48 <benmachine> so it seems odd that you would get them from a unpacked tarball
11:46:58 <McManiaC> hmhm :S
11:47:13 <benmachine> anyway, they are fixed yes
11:47:21 <McManiaC> kk good
11:49:27 <augur> :t (***)
11:49:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:49:29 <augur> hahaha
11:49:33 <augur> so close
11:49:41 * augur makes window bigger
11:49:42 <augur> HAH
11:49:47 <benmachine> <_<
11:49:50 <augur> TAKE THAT BYORGEY_
11:55:18 <c_wraith> Is there a fast way to get the ghc source tree?
11:55:26 <c_wraith> the darcs checkout takes approximately 10 years.
11:56:07 <benmachine> c_wraith: you can get tarballs I think, which you then darcs pull
11:57:14 <Saizan> isn't the repo in hashed format now? it should be fast if you don't want all the history
11:57:35 <c_wraith> Ok, grabbing a tarball.  That should be faster anyway.  I don't care about updating it.
12:03:22 <c_wraith> hah, found the file I was looking for.  Panic.lhs.  what a great name
12:08:47 <Zao> Hrm, is there anything in base to reverse an Ordering?
12:09:16 <c_wraith> like a Reverse newtype?  Nothing I'm aware of
12:10:45 <tonkman> “To iterate is human, to recurse divine.”
12:10:48 <tonkman> - L. Peter Deutsch
12:11:59 <benmachine> Zao: no, but 'flip compare' is a good trick
12:12:04 <Zao> http://hpaste.org/42332/ordering
12:12:06 <Zao> Almost elegant :D
12:12:31 <ahihi> > map (compare EQ) [LT .. GT]
12:12:31 <lambdabot>   [GT,EQ,LT]
12:12:40 <benmachine> hah, neat
12:12:51 <benmachine> Zao: isn't that just comparing snd b a `mappend` comparing fst b a
12:13:12 <benmachine> or wait
12:13:22 <benmachine> yeah
12:13:38 <benmachine> comparing (\(x,y) -> (y,x)) b a
12:13:38 <Zao> I want to order by snd decreasing and by fst ascending.
12:13:44 <benmachine> ohh right
12:13:54 <benmachine> comparing snd b a `mappend` comparing fst a b
12:14:09 <benmachine> I think.
12:14:29 <benmachine> :t flip (comparing snd) `mappend` comparing fst
12:14:30 <lambdabot> forall a b. (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
12:14:53 <benmachine> > sortBy (flip (comparing snd) `mappend` comparing fst) [(1,2), (3,4), (5,4)]
12:14:54 <lambdabot>   [(3,4),(5,4),(1,2)]
12:15:03 <benmachine> monoids <3
12:15:16 <benmachine> > sortBy (flip (comparing snd) ++ comparing fst) [(1,2), (3,4), (5,4)]
12:15:17 <lambdabot>   [(3,4),(5,4),(1,2)]
12:15:21 <benmachine> lambdabot <3
12:15:33 <Zao> It's going to be a pain to translate this code into SML later.
12:15:41 <Zao> I'm prototyping it in Haskell to not go insane.
12:15:57 <benmachine> heh
12:15:59 <benmachine> cool.
12:20:44 <paolino> is there a special syntax to use symbols as constructors ?
12:20:58 <mauke> no, you just have to start with an uppercase symbol
12:21:48 <paolino> mh, I meant operator symbol
12:21:56 <paolino> like ?
12:22:05 <mauke> yes
12:22:08 <ezrakilty> in that case they must start with a colon
12:22:17 <mauke> colon is the only uppercase symbol
12:22:22 <paolino> ah
12:25:49 <romildo> Hi.
12:26:54 <romildo> Has anybody used TreeModelFilter from gtk2hs? I am having issues with it.
12:28:18 <romildo> It seems that the attribute treeModelFilterVirtualRoot is  always the empty. Has anybody used it?
12:37:45 <McManiaC> what is HsNet.h? I get a "missing header file" error when trying to install network with ghc 7 on windows
12:39:06 <Zao> McManiaC: Aren't all those packages supposed to be in the core distro already?
12:39:28 <McManiaC> I didn't install the haskell platform
12:39:32 <Zao> No, core.
12:39:41 <McManiaC> uhm, not sure
12:40:02 <Zao> Well, maybe not network, but bytestring for sure.
12:40:04 <McManiaC> ghc-pkg doesn't show it
12:40:29 <McManiaC> Zao: yeah, bytestring
12:40:32 <McManiaC> is in core
12:43:21 <Zao> How are you building it?
12:45:09 <McManiaC> Zao: cabal install network
12:46:10 * Zao twiddles thumbs while cabal-install is cloned.
12:48:52 <Zao> "Writing inventory 7/6"
12:48:54 <Zao> You go, darcs :D
12:50:26 <sleepynate> permission to speak blatantly off-topic?
12:50:28 <Zao> McManiaC: Soo, where'd you get a cabal-install?
12:50:48 <Zao> Considering that you need network to build cabal-install :D
12:51:42 <sm> sleepynate: granted
12:52:23 <sleepynate> humble bundle is live -- get your game on and give to the EFF/Child's play at the same time : http://www.humblebundle.com/?live
12:52:31 <sleepynate> for anyone that didn't know :P
12:52:36 * Zao pets sleepynate 
12:52:52 <ion> Yeah, gonna buy it.
12:53:20 <sm> nice!
12:53:22 <sleepynate> you can even make sure all your money goes to charity
12:53:30 <sleepynate> if you so choose
12:53:43 <sm> maybe the next one will have a haskell game or two
12:53:59 <sleepynate> and since i give to both those charities anyways... it's be nice if people passed it around :)
12:55:15 <Zao> McManiaC: As I suspected...
12:55:18 <Zao> |Setup: The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin.|
12:55:27 <Zao> McManiaC: Didn't cabal-install tell you this?
12:56:12 <Zao> (I don't have cabal-install, so I built dependencies manually and  ghc --make Setup && Setup configure && Setup build && Setup install )
12:56:15 <Zao> (it fails on configure)
12:57:16 <Zao> Something as simple as msysgit would probably float your boat.
12:57:59 <Zao> McManiaC: The reason for all this is that it assumedly generates platform-dependent headers from wherever.
12:58:47 <Zao> Builds like a charm from inside msys here.
13:02:36 <McManiaC> meh
13:15:09 <jst> Hi, everyone! Noobie question: what is the difference between LET .. IN and WHERE?
13:16:25 <sipa> (let .. in ..) is an expression
13:16:28 <McManiaC> jst: you cant use local variables in where
13:16:29 <sipa> and can be used anywhere
13:16:33 <benmachine> jst: only the places you can use them
13:16:34 <mauke> jst: they're both syntax errors
13:17:00 <sipa> where is a special syntax that can be used while defining functions, but you can't nest it
13:17:07 <benmachine> mauke provides an entirely correct and entirely unhelpful answer >_>
13:17:18 <Twey> benmachine: Film at eleven?  :þ
13:17:26 <benmachine> :P
13:17:34 <jst> Wow! Thanks guys!
13:17:47 <jst> You are my heroes!
13:17:47 <benmachine> where can also attach to case statements
13:17:52 <jst> Even mauke.
13:17:53 <Twey> where is a magical bit of syntax that scopes over all the guards in an equation; let is an expression that can be used anywhere expressions are
13:18:23 <benmachine> case alternatives, strictly speaking
13:18:25 <benmachine> but whatever
13:18:27 <Twey> let also has syntax sugar in do-notation
13:18:30 <mee> paraphrased from yesterday: where is part of the declaration syntax, let is part of the expression syntax
13:19:55 <mee> jst: search for '16:41:27 <Cale>' at http://tunes.org/~nef/logs/haskell/10.12.13
13:19:56 <dpratt71> in cases where 'let' and 'where' are basically interchangeable, is there a preferred choice?
13:20:20 <benmachine> dpratt71: I think where is prettier
13:20:36 <sipa> personal preference :)
13:21:54 <jst> mee: Thanks, I will!
13:21:58 <burp> @hoogle (*>)
13:21:58 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
13:21:58 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:21:58 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:22:49 <Twey> dpratt71: where is usually preferred in the code I've seen
13:23:40 <dpratt71> Twey, benmachine: ok, thanks
13:23:47 <c_wraith> Layout rules are less wacky for where, when you can scope over a full expression
13:24:22 <c_wraith> But unless I'm horribly mistaken, you can't attach a where clause to a branch in a case statement
13:24:32 <c_wraith> So sometimes they aren't an option
13:24:38 <benmachine> c_wraith: you are horribly mistaken :)
13:24:45 <c_wraith> I am?  damn it!
13:24:49 <benmachine> :P
13:24:51 <Twey> Polarly, in fact
13:24:52 <c_wraith> I need to go make my code less ugly now!
13:24:58 <Twey> Heheh
13:24:59 <benmachine> you can have guards in case statements too
13:25:06 <benmachine> somehow tutorials don't mention this, I think
13:25:07 <c_wraith> I knew about guards, and use them all the time
13:26:14 <c_wraith> but yeah, attaching a where clause to case branches will make my code much less ugly
13:26:29 <c_wraith> (in the cases I'm currently using let .. in .., at least)
13:26:54 <Cale> guards in case expressions are actually really nice to exploit even if you don't have a pattern to match
13:27:20 <c_wraith> yeah, I've seen case () of ... before
13:27:44 <Cale> yep
13:28:04 <Cale> It's much nicer than nested if/then/else :)
13:28:13 <c_wraith> Anything's better than nested ifs
13:28:30 <c_wraith> ...  ok, maybe not manual jump tables :)
13:28:33 <benmachine> for nested if/then/else I think I use lookup id
13:28:44 <Cale> Computed jumps! :D
13:28:49 <benmachine> or, well, something similar
13:31:20 <Twey> benmachine: ITYM ‘lookup True’?
13:31:44 <Twey> Or ‘maybe default id . lookup True’
13:31:47 <c_wraith> No, lookup id 
13:31:56 <Twey> :t lookup
13:31:56 <benmachine> :t lookup id
13:31:56 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:31:57 <lambdabot> forall a b. [(a -> a, b)] -> Maybe b
13:32:01 <Twey> Oh
13:32:04 <benmachine> eeerm
13:32:08 <benmachine> no Twey is right
13:32:09 <c_wraith> then you make your list look like:  [(a == b, b)..]
13:32:10 <benmachine> I mean find id
13:32:13 <benmachine> :t find id
13:32:13 <lambdabot> [Bool] -> Maybe Bool
13:32:14 * Twey scratches his head.
13:32:16 <Cale> :t lookup True
13:32:16 <lambdabot> forall b. [(Bool, b)] -> Maybe b
13:32:19 <benmachine> no I didn't >_<
13:32:23 <benmachine> whatever
13:32:33 <c_wraith> The main problem with lookup id is that maybe in there.
13:32:37 <Cale> :t fromJust . lookup True
13:32:37 <lambdabot> forall a. [(Bool, a)] -> a
13:32:39 <Twey> ‘lookup id’ only works if you have Eq for functions, doesn't it?
13:32:46 <Twey> Which is silly
13:32:51 <c_wraith> Eh?  no.
13:32:57 <Cale> Twey: right
13:33:00 <benmachine> Twey: yes, I meant lookup True
13:33:04 <Twey> Alright.
13:33:09 <Cale> :t find id
13:33:10 <lambdabot> [Bool] -> Maybe Bool
13:33:14 <Twey> *nod*
13:33:22 <Cale> :t find fst
13:33:22 <Twey> Though that's not too useful.
13:33:23 <lambdabot> forall b. [(Bool, b)] -> Maybe (Bool, b)
13:33:32 <Twey> or = find id
13:33:34 <Twey> I guess
13:33:42 <Twey> Oh
13:33:51 <Twey> Not quite
13:33:57 <Cale> :t fmap snd . find fst
13:33:58 <lambdabot> forall b. [(Bool, b)] -> Maybe b
13:33:58 <Twey> Semantically ☺
13:41:27 <leimy> :t lookup
13:41:28 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:42:52 <leimy> > (fromJust . lookup True) [(False, 5)]
13:42:53 <lambdabot>   *Exception: Maybe.fromJust: Nothing
13:43:07 <leimy> so much for pure functions?  :-)
13:43:42 <benmachine> that's a pure error!
13:43:51 <Cale> leimy: Well, it's analogous to what happens if you have guards that are incomplete
13:43:55 <leimy> yeah but the error is not captured in the expressions type.
13:43:57 <lambdor> How do you update to GHC 7 with Haskell Platform on Windows?
13:43:57 <alpounet> using fromJust is rarely wise
13:44:01 <leimy> er expression's
13:44:05 <alpounet> unless you're *sure* there'll be an error
13:44:06 <benmachine> leimy: arguably it is
13:44:14 <leimy> I'd love to hear that argument
13:44:16 <benmachine> in haskell, every type contains _|_
13:44:24 <Cale> Every type contains a value _|_ which represents all the nonterminating values
13:44:25 <aristid> > (fromMaybe 0 . lookup True) [(False, 5)]
13:44:26 <lambdabot>   0
13:44:28 <alpounet> that's like calling code that can throw an exception without catching it in Java
13:45:00 <Cale> The error which is caused by that code cannot be caught (at least from pure code) and so is treated as a form of nontermination.
13:45:05 <benmachine> alpounet: I'd argue that using fromJust is basically never wise, since let Just x = e in x gives a better error message
13:45:29 <Cale> fromMaybe (fix id) . lookup True $ [(False, 5)]
13:45:30 <Cale> > fromMaybe (fix id) . lookup True $ [(False, 5)]
13:45:31 <alpounet> benmachine, I think the same
13:45:31 <benmachine> Cale: I would argue that the error is treated as a form of nontermination and so cannot be caught :P
13:45:34 <lambdabot>   mueval-core: Time limit exceeded
13:45:45 <Cale> benmachine: Either way :)
13:45:46 <alpounet> benmachine, I was just trying to go smoothly on that topic
13:46:00 * hackagebot wxFruit 0.1.2.1 - An implementation of Fruit using wxHaskell.  http://hackage.haskell.org/package/wxFruit-0.1.2.1 (HenkJanVanTuyl)
13:46:11 <benmachine> delicious fruit
13:46:45 <cheater99> Cale: hi!
13:46:51 <Cale> hi!
13:46:56 <cheater99> what's up?
13:46:59 <leimy> I guess my point is that bottoms really dork up purity :-)
13:47:06 <leimy> and the sense of a guarantee that code will run.
13:47:10 <benmachine> @pl runKleisli (Kleisli (peekElemOff ptr 0) &&& Kleisli (peekElemOff ptr 1) &&& Kleisli (peekElemOff ptr 2))
13:47:10 <lambdabot> runKleisli (Kleisli (peekElemOff ptr 0) &&& Kleisli (peekElemOff ptr 1) &&& Kleisli (peekElemOff ptr 2))
13:47:21 <cheater99> leimy: ah, that's too bad. i was hoping you're point-free.
13:47:23 <Twey> It's already point-free, you silly benmachine
13:47:24 <benmachine> leimy: sure, but totality really dorks up turing-completeness :P
13:47:30 <benmachine> Twey: yeah wups
13:47:36 <benmachine> @pl \ptr -> runKleisli (Kleisli (peekElemOff ptr 0) &&& Kleisli (peekElemOff ptr 1) &&& Kleisli (peekElemOff ptr 2))
13:47:36 <lambdabot> runKleisli . ap ((&&&) . Kleisli . flip peekElemOff 0) (ap ((&&&) . Kleisli . flip peekElemOff 1) (Kleisli . flip peekElemOff 2))
13:47:41 <benmachine> hmmmm
13:47:45 <leimy> benmachine: that's true.
13:47:45 <Cale> Waking up, getting a new version of GHC iPhone set up properly in my Mac VM, and talking on IRC while that happens :P
13:47:47 <cheater99> Cale: so what about that bind thing you told me about?
13:47:53 <Cale> cheater99: okay :)
13:47:57 <cheater99> :)
13:47:59 <Cale> so we had:
13:48:10 <Cale> newtype State s a = S (s -> (s,a))
13:48:20 <Cale> runState :: State s a -> s -> (s,a)
13:48:40 <Cale> S :: (s -> (s,a)) -> State s a
13:48:40 <cheater99> mhm
13:48:52 <Cale> return :: a -> State s a
13:49:07 <Cale> and I think that was all we had up to that point
13:49:13 <jst> Alright, I'm off. Thanks for the help, everyone!
13:49:21 <cheater99> yep
13:49:26 <cheater99> we've spoken about return a bit
13:49:27 <Cale> So, the next operation we need (and the final one in order to make it into a monad) is (>>=)
13:49:36 <Cale> In general,
13:49:38 <cheater99> ok!
13:49:43 <cheater99> go on please
13:49:46 <Cale> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
13:49:56 <Cale> and in our case  m = State s
13:49:59 <Cale> and so
13:50:08 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
13:50:22 <Cale> What will it do?
13:50:27 <cts> I read in LYAH that >>= can be expressed by join and vice versa.
13:50:29 <cts> Why is join not in the definition of Monad, together with default definitions for join and >>=?
13:50:36 <lambdor>  \join #ghc
13:50:37 <Cale> cts: No good reason
13:51:09 <Cale> (x >>= f) will be a state computation which when run will run x, and then capture the result of x, apply f to it to get a second computation, and run that
13:51:30 <cheater99> hm
13:51:34 <cheater99> wait a sec
13:51:36 <Cale> If it helps, x >>= f is the desugared version of   do v <- x; f v
13:51:52 <cheater99> i don't know "do" blocks yet
13:51:57 <byorgey> cts: in fact, there is currently a proposal (in very early stages) to do exactly that (along with a few other things)
13:52:12 <Cale> Right, that's not to be taken too literally anyway -- just think of it schematically
13:52:13 <cheater99> but it seems like it does what i'd expect it to do
13:52:19 <cheater99> i.e. put x in v and run f on it
13:52:31 <cheater99> right?
13:52:38 <Cale> "put x in v" is the wrong description
13:52:38 <benmachine> I'm not keen on class instance defaults
13:52:49 <Cale> put the *result of running* x in v
13:52:50 <cts> byorgey: like the Functor constraint on the argument of Monad?
13:52:58 <cheater99> ok
13:53:02 <benmachine> I see how they're useful but they can easily lead to nasty bugs
13:53:03 <cheater99> wait a second now
13:53:08 <Cale> x is a computation, v is its result
13:53:22 <Cale> So x might do some stuff with the state as it runs
13:53:36 <Cale> and aside from that, it'll have a result
13:53:39 <cheater99> what i was saying: does "do v <- x" mean "put x in v"?
13:53:47 <cts> byorgey: Where can I find that proposal?
13:53:58 <Cale> No, x :: State s a, but v :: a
13:54:05 <cheater99> mhm
13:54:06 <cheater99> ok wait
13:54:09 <byorgey> cts: yes, Functor => Applicative => Monad in fact
13:54:59 <cheater99> (>>=) :: State s a -> (a -> State s b) -> State s b   <<< i would expect the final output of >>= to be a computation which hadn't been run yet?
13:55:05 <cts> byorgey: There is also a function >=> in LYAH, with which the Monad laws are much better to memorise.  I didn't check, but I'm sure that >=> deserves the same status as >=> and join.
13:55:10 <cheater99> but you say "(x >>= f) will be a state computation which when run will run x, and then capture the result of x, apply f to it to get a second computation, and run that"
13:55:16 <Cale> cheater99: right
13:55:34 <Cale> cheater99: Well, internally, it'll be a function again, from an initial state, to a (final state, result) pair
13:55:40 <cheater99> i would expect "(x >>= f) will be a state computation which when run will run x, and then capture the result of x, apply f to it to get a second computation, and run that" to have a type of State s a -> (a -> State s b) -> b   for example
13:56:01 <Cale> cheater99: Don't forget that "which when run" bit
13:56:14 <cheater99> oh
13:56:39 <cheater99> right!
13:56:41 <Cale> So, let's dive in and see if we can wire this thing up
13:56:47 <Cale> (x >>= f) = ...
13:56:56 <Cale> Well, it's going to be something of type State s b
13:56:56 <cheater99> hm
13:57:04 <Cale> and we only have S and return to make those so far
13:57:13 <Cale> and it's probably not return that we need :)
13:57:17 <Cale> So let's go with S
13:57:20 <cheater99> mhm
13:57:21 <Cale> (x >>= f) = S ...
13:57:33 <Cale> and S takes a function of type s -> (s,b) as its parameter
13:57:39 <Cale> So, might as well be a lambda
13:57:42 <Cale> (x >>= f) = S (\s -> ...)
13:57:58 <Cale> and now we said that we want to run x first, on the initial state, of course
13:57:58 <cheater99> we can use return now right?
13:58:08 <Cale> nope, we're going to use runState
13:58:14 <cheater99> ok go on
13:58:47 <Cale> So the (final state, result) pair from running x on the initial state can be obtained by  runState x s
13:58:56 <Cale> So we'll use let to capture that:
13:59:09 <Cale> (x >>= f) = S (\s -> let (s',v) = runState x s in ...)
13:59:20 <cheater99> mhm
13:59:30 <Cale> and then we wanted to apply f to the result of x (which is v)
13:59:39 <Cale> and run f v on the new state
13:59:49 <Cale> (x >>= f) = S (\s -> let (s',v) = runState x s in runState (f v) s')
14:00:08 <cheater99> mhmm
14:00:16 <Cale> and that's the complete definition
14:00:29 <cheater99> that has whirred by fast
14:00:39 <Cale> okay, give it a moment to sink in :)
14:00:44 <cheater99> i'm 100% certain i won't be able to remember it
14:00:49 <cheater99> but i understand how it works
14:00:54 <cheater99> (at this moment)
14:01:06 <Cale> Well, you're supposed to understand it and then just think about what it's doing in a more abstract way
14:01:11 <cheater99> so how do i use it?
14:01:30 <Cale> So, up to now, we don't have many interesting primitive values of type State s a to combine together
14:01:49 <Cale> But, for example, we could make some with S...
14:02:03 <Cale> inc = S (\s -> (s+1, s))
14:02:28 <Cale> This  State Integer Integer  computation will increment the current state before returning the old one as its result
14:03:17 <Cale> inc >>= (\x -> inc >>= (\y -> return (x,y)))
14:03:29 <Cale> In do-notation, that would be written:
14:03:37 <Cale> do x <- inc; y <- inc; return (x,y)
14:03:43 <Cale> (just for reference)
14:04:04 <Cale> This will increment the state twice, and return the previous two states in a pair
14:04:14 <Cale> So for instance, if the initial state was 0
14:04:28 <Cale> then the result of this composed action will be (0,1), and the final state will be 2
14:04:32 <cheater99> i didn't understand this notation: "inc >>= (\x -> inc >>= (\y -> return (x,y)))"
14:04:38 <cheater99> what do the -> do here?
14:04:47 <Cale> That's part of the syntax of lambda
14:04:52 <Botje> standard lambda notation
14:05:07 <Cale> (\x -> x^2) is the function which when applied to a value x will produce the result x^2
14:05:10 <Twey> λx. x
14:05:16 <Cale> > (\x -> x^2) 5
14:05:17 <lambdabot>   25
14:05:20 <cheater99> oh ok right
14:05:23 <cheater99> i remember now
14:05:32 <cheater99> it's just the "goes to" from mathematics
14:05:41 <Cale> Yeah |-->
14:05:54 <cheater99> ok
14:05:56 <cheater99> cool :)
14:06:15 <cheater99> do you normally do stateful functions with S or with State?
14:06:27 <Cale> Well, State is our type constructor here
14:06:42 <Cale> and S is our data constructor, which we're sort of thinking of as temporary
14:06:58 <Cale> I haven't finished introducing the primitive State s computations
14:07:06 <cheater99> can i paste 5 lines?
14:07:14 <Cale> So, the next two things we'll need are a way to get and set the current state.
14:07:16 <Cale> sure
14:07:20 <cheater99> fromStoAandS :: Int -> (String,Int)
14:07:20 <cheater99> fromStoAandS c | c `mod` 5 == 0 = ("foo",c+1)
14:07:20 <cheater99>                | otherwise      = ("bar",c+1)
14:07:25 <cheater99> stateIntString :: State Int String
14:07:26 <cheater99> stateIntString = State fromStoAandS
14:07:33 <cheater99> they use "State" here, and not S.
14:07:39 <Cale> Oh, right, they named their data constructor State
14:07:45 <cheater99> ohhh right
14:08:07 <cheater99> State is also the type, isn't it?
14:08:08 <Cale> Which I opted not to do, because I find it helps keep the discussion clear to do less punning.
14:08:12 <cheater99> yes
14:08:26 <Cale> Types and values live in separate namespaces, so it's okay to name them the same thing
14:08:28 <cheater99> i remember now being surprised that you called it S.
14:08:43 <cheater99> ok, so we're using S to do things.
14:09:30 <Cale> So, let's do get and put
14:09:45 <cheater99> i'm not sure what get and put are
14:09:51 <cheater99> never heard of them
14:09:59 <Cale> get will be a computation which does not affect the value of the current state, and whose result is the current state
14:10:11 <Cale> Can you guess what type it will have?
14:12:16 <cheater99> hmm
14:12:25 <cheater99> let me try
14:12:51 <cheater99> get :: State s a -> s ?
14:13:20 <aristid> cheater99: with result, Cale probably means the result of the action, when run
14:13:49 <cheater99> hm
14:14:25 <cheater99> let me think about it
14:14:26 <Cale> yes, that's what I mean
14:14:38 <Cale> So get will not (outwardly) be a function
14:15:09 <cheater99> get spits out a computation, so it will be get :: ... -> ( ... -> ...)   yes?
14:15:51 <cheater99> Cale: ^ :-)
14:16:18 <Cale> get will itself *be* a computation
14:16:30 <cheater99> erm
14:16:36 <cheater99> i thought get was a function
14:16:39 <cheater99> i'm a bit lost here
14:16:39 <Cale> nope
14:16:50 <Cale> okay
14:16:50 <cheater99> how do you "define a computation"?
14:16:54 <Cale> Using S :)
14:17:02 <Cale> :t S
14:17:03 <lambdabot> Not in scope: data constructor `S'
14:17:06 <cheater99> oh
14:17:07 <cheater99> hm
14:17:07 <Cale> er, right ;)
14:17:11 <Botje> a computation is of type State s a
14:17:17 <Cale> S :: (s -> (s,a)) -> State s a
14:17:24 <Cale> The result of S is a State s computation
14:17:39 <cheater99> ok, just a sec
14:17:44 <cheater99> so we need to use S
14:18:16 <cheater99> get :: State s a ?
14:18:19 <cheater99> something like that?
14:18:36 <Cale> close :)
14:18:43 <cheater99> State s a -> s?
14:18:45 <Cale> nope
14:18:49 <Cale> (colder ;)
14:18:50 <aristid> the last one was closer
14:18:54 <cheater99> dunno then :-)
14:19:02 <Cale> Well, the result of get will be a state
14:19:03 <aristid> cheater99: don't give up, man
14:19:11 <cheater99> mhm
14:19:16 <aristid> cheater99: a is the type of the result of the computation, right?
14:19:24 <cheater99> but i thought get was a computation, and not a function
14:19:27 <aristid> cheater99: we want a computation that returns the current state
14:19:46 <Cale> So the result type must be the same type as the state type
14:19:56 <cheater99> mhm
14:20:15 <Cale> So State s a is a little too general, because s and a might be different
14:20:20 <cheater99> so can it be something like say State s (State a) for example?
14:20:24 <Cale> get :: State s s
14:20:32 <cheater99> hm
14:20:52 <Cale> I think that'll be clear when we implement it at least
14:21:00 <aristid> cheater99: do you think you can implement get with S?
14:21:09 <Cale> Yeah, give that a try :)
14:21:18 <Cale> Use the same method that I used with return and >>=
14:21:21 <cheater99> oh right, i see why it's State s s now
14:21:23 <Gracenotes> ah yes.. state.. it was the darned newtypes that got me
14:21:24 <Cale> :)
14:21:50 <aristid> cheater99: data State s a = S (s -> (a, s))
14:21:57 <Cale> Gracenotes: sorry that the beginning of the conversation was the other day (yesterday?), so it might be a bit of work to find it
14:22:00 <cheater99> just a sec, brb
14:22:20 <Cale> (If you want to read my explanation)
14:23:00 <Cale> (Or maybe you've already got the idea and you're just talking about when you were learning this? :)
14:23:35 <cheater99> it was my first conversation in here since a few days so it should be easy to find
14:24:04 <cheater99> ok, so get :: State s s, right
14:24:09 <cheater99> now get = ...
14:24:32 <cheater99> it needs to return State so we need to use S
14:24:37 <cheater99> get = S ...  right?
14:25:35 <Cale> yep
14:25:45 <cheater99> ok...
14:25:54 <Cale> Well, not just return a State, but be one :)
14:26:17 <cheater99> yep
14:26:37 <cheater99> ok... just a sec
14:27:34 <cheater99> i think maybe get = S (\s -> s)       ?
14:28:05 <Cale> Remember that S :: (s -> (s,a)) -> State s a
14:28:07 <cheater99> or actually
14:28:18 <cheater99> get = S (\s -> ...)    that part is right, yes?
14:28:21 <Cale> yes
14:28:34 <Accidus> Cale, did you have a chance to look at Moggi's and Jaskelioff's paper on monoid transformers?
14:28:35 <Cale> So if the initial state is s, what will the final state and result be?
14:28:35 <cheater99> i think maybe it would be get = S (\s -> (s, s))
14:28:41 <Cale> Accidus: nope
14:29:01 * Accidus scratches his head.
14:29:05 <Accidus> Pity.
14:29:07 <Accidus> :)
14:29:23 * cheater99 buys Accidus some anti-dandruff shampoo
14:29:51 <Accidus> Thanks cheater99, but what I could use instead is some help with that paper. Some things don't make sense :)
14:30:04 <cheater99> Cale: so how does that look? :)
14:30:21 <cheater99> Accidus: good luck :)
14:30:30 <cheater99> Accidus: when in doubt, read it backwards
14:30:30 <Accidus> Heh, thanks.
14:30:58 <Cale> Accidus: I can look at it if you'd like :)
14:30:59 <Accidus> I'm sort of doing centre-spiralling-outwards now, out of desparation
14:31:05 <Cale> cheater99: good :)
14:31:12 <cheater99> Cale: yaay :)
14:31:17 <Accidus> Cale, it's a bit annoying to dive into, though. Up to you.
14:31:25 <cheater99> Cale: now put is probably something that sets the current state?
14:31:29 <Cale> yeah
14:32:09 <Cale> put *is* a function, it takes a new state, and gives the computation for setting the current state to that (and it returns () as its result)
14:32:16 <Accidus> But if you want to, then I'm looking at http://www.fceia.unr.edu.ar/~mauro/pubs/monoid_transformers.pdf
14:32:34 <cheater99> i am guessing it would be put :: s -> (..., s)
14:32:40 <cheater99> i don't know how to return ()
14:32:42 <cheater99> erm
14:32:50 <cheater99> would it just be s -> ((), s) ?
14:32:56 <cheater99> i remember tuples are "their own type"
14:33:01 <Cale> Accidus: Oh, this looks nice :)
14:33:07 <Cale> I like the abstract, anyway :)
14:33:18 <Accidus> contrasting definition 3.1 with the examples (say, 3.10)
14:33:21 <Cale> cheater99: put :: s -> State s ()
14:33:27 <cheater99> hmmm
14:33:30 <cheater99> oh right
14:33:46 <Accidus> Cale, it's sort of nice. I haven't made up my mind yet.
14:34:06 <Accidus> I need to understand it first to make a fair judgement
14:34:26 <Cale> Accidus: What does the hat on a category mean in their notation?
14:34:35 <Accidus> It's the category of monoids
14:34:56 <Accidus> So unhatted is the monoidal category
14:35:02 <Accidus> hatted is monoids
14:35:17 <Accidus> oh, sorry
14:35:17 <cheater99> ok, i am guessing put looks like this:    put = S (\s -> \s' -> (s', ()))       right?
14:35:36 <aristid> cheater99: no :)
14:35:47 <Accidus> unhatted is just a category
14:35:47 <aristid> put = \s -> S (...)
14:35:50 <Accidus> hatted is monoidal
14:35:58 <cheater99> ohhh
14:36:04 <Accidus> Mon(\hat E) is monoids
14:36:08 <cheater99> right, it takes s as the parameter
14:36:17 <sipa> cheater99: S takes as argument a function, that takes a state and returns a state + return value
14:36:21 <sipa> cheater99: you're almost there
14:36:27 <sipa> but what is that s' doing there?
14:36:47 <Accidus> (\hat M is the monoid with an object M in \hat E)
14:36:57 <cheater99> so it woudl be put = \s' -> S ( \s -> (s', ()))     maybe?
14:37:10 <cheater99> *would
14:37:14 <cheater99> sorry, i'm supertired
14:37:24 <sipa> yes
14:37:27 <sipa> looks right to me
14:37:30 <Accidus> Cale, so the definition seems straightforward enough
14:37:34 <cheater99> greattt :))
14:37:39 <sipa> @src put
14:37:39 <lambdabot> Source not found. There are some things that I just don't know.
14:38:00 <McManiaC> http://npaste.de/sJ/ <- directory fails to build, can anyone tell my why? :> the HsDirectory.h is in the include directory mentioned in the cabal file...
14:38:13 <Cale> cheater99: yes, that's right
14:38:22 <cheater99> Cale: omg :)
14:38:26 <Cale> (sorry, I've been bouncing around between conversations)
14:38:27 <cheater99> Cale: i feel great now :)
14:38:33 <cheater99> nahh, that's ok :)
14:38:50 <sipa> you could write is as: put s = S (const (s, ())
14:39:02 <Cale> cheater99: So now in terms of return, >>=, get and put, we can actually write any State s computation, and we could even forget that S exists if we wanted to.
14:39:09 <cheater99> i've never heard of const until now
14:39:30 <cheater99> i think you're missing a ) there?
14:39:39 <sipa> cheater99: yes :)
14:39:45 <cheater99> Cale: hmmm
14:39:52 <McManiaC> is there a separate channel for cabal-install maybe?
14:40:06 <cheater99> Cale: i'm not sure how >>= is used. i can sort of see how get and put would be used..
14:40:14 <Cale> McManiaC: This is it, sorry for missing your question :)
14:40:20 <dcoutts_> McManiaC: something in the header, or something it includes, fails to compile
14:40:31 <Cale> McManiaC: I'm talking to 3 people and conducting a tutorial here :)
14:40:33 <aristid> cheater99: i have a little exercise for you :) write S (\s -> (show s, s * 2)) with get and put and >>=
14:41:09 <aristid> the type is Num s => State s String
14:41:17 <Cale> ... and patching fclabels...
14:41:18 <sipa> aristid: unless s is String, that doesn't typecheck
14:41:33 <aristid> sipa: did i get the tuple order wring?
14:41:38 <dcoutts_> McManiaC: run with -v3 to see the error message
14:41:43 <aristid> sipa: i thought it was S :: s -> (a, s)
14:41:45 <McManiaC> ah, k
14:41:55 <aristid> @unmtl State s a
14:41:55 <lambdabot> s -> (a, s)
14:42:07 <aristid> sipa: and @unmtl agrees
14:42:08 <sipa> aristid: apologies, it seems it was cheater99 who mixed it up, and i didn't notice
14:42:19 <aristid> :)
14:42:52 <sipa> cheater99: so put is \s -> S (\_ -> ((), s))
14:43:30 <cheater99> sipa: i think that's exactly what i wrote
14:43:34 <benmachine> mtl has it s -> (a,s) but s -> (s,a) is cooler
14:43:37 <cheater99> except different names for variables
14:43:51 <kmc> there's a channel #hackage McManiaC
14:44:02 <kmc> but it sees very little traffic besides confused wannabe haxors
14:44:09 <benmachine> heheh
14:44:16 <sipa> cheater99: the ((),s) instead of (s,())
14:44:35 <aristid> benmachine: why is s -> (s,a) cooler?
14:44:44 <cheater99> ah right
14:44:49 <McManiaC> dcoutts_: http://npaste.de/sK/
14:44:52 <sipa> cheater99: it's just convention though
14:44:54 <benmachine> aristid: because then State = (s ->) . (s ,)
14:44:55 <benmachine> er
14:44:56 <McManiaC> no idea what HsFFI.h is
14:45:03 <cheater99> sipa: mhm
14:45:03 <benmachine> State s = (s ->) . (s ,)
14:45:05 <dcoutts_> McManiaC: it comes with ghc
14:45:07 <cheater99> ok next..
14:45:12 <benmachine> using notation that doesn't exist :P
14:45:13 <aristid> benmachine: oh :)
14:45:20 <aristid> i understand you tho
14:45:30 <benmachine> aristid: in particular, instance Functor (State s) where fmap = fmap fmap fmap
14:45:34 <cheater99> get put and >>= for        S (\s -> (show s, s * 2)) 
14:45:39 <dcoutts_> McManiaC: something is screwed :-)
14:45:41 <cheater99> let me try that..
14:45:47 <McManiaC> -.-
14:46:09 <aristid> benmachine: haha, fmap fmap fmap is the king of functions
14:46:26 <unkanon> aristid: I read that as fap fap fap
14:46:28 <aristid> cheater99: yeah :)
14:46:31 <McManiaC> dcoutts_: but does it mean that HsFFI.h couldn't be found or that HsFFI.h couldn't find HsDirectory.h ?
14:46:40 <cheater99> do v <- get; show s; put 2*s
14:46:41 <aristid> unkanon: if it helps you ;)
14:46:45 <cheater99> that's my first guess
14:47:03 <sipa> cheater99: what is the type of (show s)
14:47:12 <dcoutts_> McManiaC: it's starting with HsDirectory.h, and that presumably #includes HsFFI
14:47:13 <cheater99> i don't know, i've never used show
14:47:22 <sipa> ok, show :: a -> String
14:47:24 <unkanon> aristid: joking aside, fmap fmap fmap is more general than (.) . (.) right? (not counting lambdabot's way of doing things)
14:47:29 <cheater99> ok
14:47:38 <McManiaC> dcoutts_: ah, right
14:47:39 <cheater99> just a sec
14:47:43 <dcoutts_> McManiaC: cabal only knows about HsDirectory.h, it does not know what it includes, but gcc does
14:47:43 <McManiaC> #include "HsFFI.h"
14:47:47 <sipa> you couldn't just write a string there, so you can't write show x there either
14:48:30 <cheater99> :t return
14:48:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:48:47 <sipa> that type may be confusing for you, for now?
14:48:52 <cheater99> hm yeah
14:48:56 <cheater99> do v <- get; put 2*s; return show s          i think maybe?
14:49:04 <sipa> almost
14:49:14 <sipa> you need parenthesis around "show s"
14:49:38 <mtnviewmark> and your variable got renamed in there
14:49:46 <sipa> right :)
14:49:48 <cheater99> ah yes it has
14:49:51 <cheater99> :-)
14:49:58 <cheater99> sorry, i'm very very very tired :-)
14:50:13 <sipa> and () around 2*s as weel
14:50:13 <cheater99> that was a nice excercise
14:50:21 <benmachine> aristid: sorry, that's fmap f = State . fmap fmap fmap f . runState -- damn newtype wrappers
14:50:21 <cheater99> exercise 
14:51:40 <aristid> unkanon: i think fmap fmap fmap is equivalent to fmap.fmap, which is indeed far more general than (.).(.)
14:51:46 <aristid> :t fmap.fmap
14:51:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:51:57 <aristid> :t fmap Prelude.. fmap
14:51:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:52:05 <aristid> :t fmap fmap fmap
14:52:06 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:52:09 <unkanon> @unpl fmap fmap fmap
14:52:09 <lambdabot> fmap fmap fmap
14:52:12 <unkanon> grr
14:52:15 <unkanon> @unpl (.) . (.)
14:52:15 <lambdabot> (\ i b c f -> i (b c f))
14:52:16 <aristid> :D
14:52:53 * unkanon doesn't understand why sometimes unpl doesn't work
14:52:56 <sipa> > fmap fmap fmap show [Maybe 5,Nothing,Maybe 3]
14:52:57 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe'
14:53:06 <sipa> > fmap fmap fmap show [Just 5,Nothing,Just 3]
14:53:07 <lambdabot>   [Just "5",Nothing,Just "3"]
14:53:44 <unkanon> > ((.).(.) show) [Just 5, Nothing, Just 3]
14:53:44 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
14:53:57 <benmachine> unkanon: what were you expecting?
14:54:07 <unkanon> benmachine: that it worked like fmap fmap fmap?
14:54:07 <sipa> > ((.).(.)) show [Just 5, Nothing, Just 3]
14:54:08 <lambdabot>   [Just "5",Nothing,Just "3"]
14:54:11 <unkanon> right
14:54:28 <unkanon> I always get the parens wrong
14:54:30 <sipa> what you wrote was ((.).((.) show)) ...
14:54:31 <benmachine> oic
14:54:38 <unkanon> yeah I noticed now
14:54:44 <aristid> > show .: [Just 5, Nothing, Just 3] -- awesomenss
14:54:45 <lambdabot>   [Just "5",Nothing,Just "3"]
14:54:54 <sipa> :t (.:)
14:54:55 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
14:54:55 <unkanon> .: = (.).(.)
14:55:14 <sipa> :t (.).(.).(.)
14:55:15 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:55:26 <sipa> nice
14:55:39 <Accidus> Cale, I think I'll just email Jaskelioff
14:55:41 <McManiaC> dcoutts_: maybe not exactly haskell related - but at what locations if gcc looking for its header files?
14:55:57 <unkanon> @pl \a b c d e ->  a (b c d e)
14:55:57 <lambdabot> (.) . (.) . (.)
14:56:05 <unkanon> indeed.
14:56:14 <unkanon> @pl \a b c d e f ->  a (b c d e f)
14:56:14 <lambdabot> (.) . (.) . (.) . (.)
14:56:18 <unkanon> how regular
14:56:30 <Cale> Accidus: Yeah, I'm too distracted to help :(
14:56:35 <Accidus> :)
14:56:44 <Accidus> Don't worry about it.
14:56:48 <unkanon> so then we should say that .:: = (.).(.).(.)
14:56:49 <Accidus> Hopefully Jaskelioff wouldn't :)
14:56:52 <Cale> But thanks for the paper :)
14:57:15 <dcoutts_> McManiaC: note that cabal is passing -IC:\\Haskell\\ghc-7.0.1/include  which is where HsFFI.h should live
14:57:41 <McManiaC> dcoutts_: it's in lib/include
14:57:51 <sipa> hmm, could this be extended further
14:57:58 <McManiaC> but my --extra-include-dirs gets ignored :(
14:58:00 <sipa> using type-level natural numbers
14:58:01 <aristid> cheater99: any progress? :)
14:58:26 <dcoutts_> McManiaC: really? that should work
14:58:37 <aristid> sipa: yeah, sure, that would be possible
14:58:37 <cheater99> aristid: we've spoken with sipa about it already :)
14:58:44 <dcoutts_> McManiaC: but sounds like a packaging bug in ghc, the HsFFI.h is a public header file
14:58:46 <aristid> cheater99: huh?
14:58:55 <dcoutts_> McManiaC: in ghc 7 I mean, I suggest you report it
14:59:09 <cheater99> it would be do s <- get; put (2*s); return (show s)
14:59:10 <dcoutts_> McManiaC: is there anything in the C:\Haskell\ghc-7.0.1\include  ?
14:59:12 <McManiaC> dcoutts_: oh, did call -lib-dirs instead of -include- ...
14:59:13 <aristid> <cheater99> do v <- get; put 2*s; return show s          i think maybe?
14:59:18 <McManiaC> dcoutts_: yes
14:59:24 <aristid> cheater99: right, except that that doesn't use >>= :)
14:59:26 <McManiaC> actually no
14:59:31 <cheater99> aristid: oh
14:59:38 <sipa> aristid: and that it does use return
14:59:39 <McManiaC> dcoutts_: everything is in lib/include
14:59:39 <dcoutts_> McManiaC: that include dir is empty is it?
14:59:44 <cheater99> is it correct as it is though?
14:59:46 <aristid> sipa: i didn't disallow return
14:59:48 <dcoutts_> McManiaC: ok, file a ticket, that's broken.
14:59:48 <cheater99> apart from not using >>=
14:59:51 <McManiaC> there's no lib\include
14:59:57 <sipa> aristid: oh, i thought it was "only using ..." :)
15:00:04 <aristid> cheater99: i think it is, yes
15:00:14 <aristid> sipa: no, only S is forbidden :)
15:00:15 <cheater99> ok
15:00:21 <cheater99> let me think of the >>=
15:00:37 <McManiaC> dcoutts_: should it be save to move the include from lib to the toplevel ghc directory?
15:00:55 <cheater99> what was the type for >>= in State again?
15:01:10 <dcoutts_> McManiaC: you're confusing me, you said "everything is in lib/include" but then you said "there's no lib/include"
15:01:17 <aristid> (>>=) :: State s a -> (a -> State s a) -> State s a
15:01:38 <sipa> you need it to be more general for your example
15:01:39 <aristid> or wait, wrong
15:01:40 <kmc> isn't it: (>>=) :: State s a -> (a -> State s b) -> State s b
15:01:43 <dcoutts_> McManiaC: the header files are split into public and private, the private ones have all the details of the internal RTS APIs
15:01:44 <aristid> (>>=) :: State s a -> (a -> State s b) -> State s b
15:01:46 <sipa> yes, what kmc said
15:01:48 <aristid> kmc: yes, i made a mistake
15:02:02 <McManiaC> dcoutts_: sorry :) theres no ghc/include, but there is ghc/lib/include
15:02:44 <dcoutts_> McManiaC: ok, right, so file a ticket
15:02:53 <McManiaC> ok
15:02:56 <Accidus> Cale, you're welcome. It's about time I read that paper...
15:04:20 <sipa> :t fmap
15:04:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:04:33 <McManiaC> dcoutts_: what category? package system/ghc api/.. ?
15:05:43 <aristid> cheater99: you need two (>>=). one for each ; in the do expression
15:06:00 <dcoutts_> McManiaC: either package system or runtime system
15:06:11 <dcoutts_> McManiaC: it's the rts headers we're talking about
15:06:28 <McManiaC> ok
15:08:09 <cheater99> :t put
15:08:10 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
15:08:51 <Cale> Accidus: What sort of stuff are you working on?
15:08:51 <cheater99> get >>= put (2*\s) >>= return (show s)       ?
15:09:08 <sipa> cheater99: almost, but that lambda syntax looks wrong
15:09:10 <Accidus> Modular Semantics of Computational Effect
15:09:15 <Accidus> * Effects
15:09:20 <cheater99> oh
15:09:50 <Accidus> So... This kind of stuff :)
15:09:54 <Cale> yeah :)
15:10:24 <Accidus> Yeah, but they have something weird with algebraic operations there.
15:10:28 <cheater99> get >>= (\s -> (put (2*s) >>= return (show s) )  )      ?
15:10:40 <Cale> I know you almost certainly mean modular in the usual sense, but it would be pretty awesome if you meant it in the ring-theoretic sense somehow ;)
15:10:45 <aristid> cheater99: almost correct :)
15:10:57 <cheater99> aristid: which part is right?
15:11:12 <aristid> everything except >>= return (show s)
15:11:27 * hackagebot asn1-data 0.3.0 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.3.0 (VincentHanquez)
15:11:46 <aristid> cheater: >>= gives you a value, which you don't care about in this part, but you have to EXPLICITLY ignore it
15:12:02 <aavogt> by using >>
15:12:08 <aristid> or \_ ->
15:12:27 <cheater99> i've never heard of >>
15:12:27 <aavogt> @src Monad
15:12:27 <lambdabot> class  Monad m  where
15:12:27 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:12:27 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:12:27 <lambdabot>     return      :: a -> m a
15:12:27 <lambdabot>     fail        :: String -> m a
15:12:42 <aristid> cheater99: a >> b = a >>= \_ -> b
15:12:46 <aavogt> in theory (>>) can be more efficient than    >>= \_ -> ?
15:13:05 <Accidus> Cale,  lol. I think there are modules in there somewhere
15:13:10 <aristid> aavogt: hmm, maybe
15:13:11 <cheater99> hm
15:13:34 <Accidus> Cale, I think my supervisor mentioned something about modelling some kind of non-determinism using modules
15:13:53 <Cale> :)
15:14:03 <cheater99> get >>= (\_ -> \s -> (put (2*s) >>= return (show s) )  )      ?
15:14:05 <Accidus> Cale, and, of course, Levy has a notion of a module for his CBPV, but that's not the ring theoretic notion (only a similar notion)
15:14:17 <aavogt> cheater99: no
15:14:22 <cheater99> i'm lost
15:14:24 <aristid> cheater99: no, you changed the part that was good
15:14:37 <aristid> the mistake was here: >>= return (show s)
15:14:43 <cheater99> hmm
15:14:47 <cheater99> ok
15:14:50 <sipa> cheater99: >>= 'sends' data to a function
15:15:02 <sipa> however, (return x) is not a function
15:15:06 <cheater99> get >>= (\s -> (put (2*s) >>= \_ -> return (show s) )  )      ?
15:15:07 <cts> There are the functions >=> and <=< in Control.Monad, and I wondered if one can express >>= in terms of e.g. <=<, which is defined by f <=< g  =  (\y -> g y >>= f).
15:15:08 <aavogt> @ty  \x -> undefined >>= x
15:15:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m b
15:15:09 <cts> My best try up to now is (f <=< (\z -> x)) 0, which actually is  (\y -> (x >>= f) ) 0, i.e. x >>= f.  Is that correct?  Can I simply use 0 here?  Or do I break some type rules here?
15:15:19 <aristid> cheater99: yes, i think that's correct
15:15:21 <sipa> cheater99: yes, that is correct
15:15:24 <cheater99> ahh yes
15:15:25 <cheater99> ok
15:15:38 <sipa> now, ">>= \_ ->" is the same as ">>"
15:15:44 <cheater99> i forgot to "plug the monad in" into the return bit
15:15:50 <Accidus> Oh well. Emailed Jaskelioff. Hopefully I wouldn't look like too much of a fool
15:15:53 <sipa> it's a shorthand for discarding the return value
15:16:19 <cheater99> i have a question
15:16:19 <aristid> :t put . (*2) =<< get
15:16:19 <lambdabot> forall (m :: * -> *) a. (MonadState a m, Num a) => m ()
15:16:21 <merijn> Isn't it more shorthand for consuming rather then discarding
15:16:27 <cheater99> every monad has its own definition of >>= yes?
15:16:31 <merijn> cheater99: Yes
15:16:41 <cheater99> how does haskell know which version of >>= i want?
15:16:52 <aristid> cheater99: from the type
15:16:53 <cheater99> is this dictated by the monad of the left parameter?
15:17:01 <cheater99> ok
15:17:08 <alpounet> i'm playing with some continued fractions in haskell
15:17:14 <aavogt> merijn: consuming sounds like the argument gets forced
15:17:18 <alpounet> in both ways
15:17:19 <Cale> cheater99: from either parameter
15:17:34 <alpounet> (double to list of continued fraction coefficients, and in the other way around)
15:17:40 <aavogt> or from the result type
15:17:49 <merijn> cheater99: The same way haskell handles other type classes. (Think of Eq's type class providing == and /=)
15:17:49 <Cale> cheater99: It can be disambiguated anywhere in the code, and the typechecker will distribute the information throughout.
15:18:08 <Cale> Or even abstracted over.
15:18:08 <alpounet> with the latter, giving 50 '1' and 100 '1' in the list should yield a different result right ?
15:18:13 <cheater99> mhm
15:18:14 <alpounet> (yeah, trying to approach the golden ratio)
15:18:22 <alpounet> but... it isn't the case
15:18:27 <Cale> If you write a definition which would work in any monad, it can just be polymorphic :)
15:18:33 <cheater99> :)
15:18:36 <alpounet> is it because standard Double aren't precise enough ?
15:18:42 <ddarius> Cale: A categorical version of modules is used for the semantics of call-by-push-value (and is related to profunctors which have been applied to the semantics of concurrency.)
15:18:51 <merijn> alpounet: You're using doubles for fractions?
15:18:54 <Cale> ddarius: cool :)
15:18:57 <ddarius> Ah, Accidus mentioned that.
15:19:08 <merijn> alpounet: 9 times out of 10.00000000000238578 using floats or doubles will screw you over
15:19:18 <Cale> Yeah, though I wasn't sure what CBPV stood for :)
15:19:21 <alpounet> merijn, no, for continued fraction
15:19:51 <merijn> alpounet: Maybe I misunderstood your problem?
15:19:53 <alpounet> merijn, i have Double -> [Integer], that gives me the list of the continued fraction representation coefficients of my Double
15:20:11 <Accidus> ddarius, but that notion of modules is superfluous. It's there just to make sure the adjunction is actually indexed (or "strong")
15:20:18 <alpounet> and i have [Integer] -> Double, approaching the Double represented by the continued fraction whose coefficients are the ones in the list
15:20:23 <mux> some haskell guys need to look into the wikipedia "generic programming" page
15:20:44 <aavogt> cts: yes, you're allowed to substitute function definitions for uses of those functions
15:20:53 * Accidus is shocked at Cale.
15:20:57 <Cale> http://www.cs.bham.ac.uk/~pbl/cbpv.html -- heh, "I have lots more questions." "Then email me." -- something funny about the tone of that for some reason.
15:21:07 <alpounet> for the latter, whether i give 'replicate 50 1' or 'replicate 100 1' yields the same Double
15:21:14 <exDM69> generic programming is a great idea, unfortunately the best language to support it has been c++. (or are there any better ones?)
15:21:16 <Cale> Accidus: why?
15:21:23 <exDM69> c++0x is pretty decent, tho
15:21:27 <alpounet> should I give a shot at CDouble for a better precision, or does the problem come from my code ?
15:21:28 <mux> it correctly states in its introduction that what is called "generic programming" in java, c#, etc, is called "parametric polymorphsm" in other languages such as haskell; it even says that haskell uses the term "generic" for a related but different concept
15:21:33 <Accidus> Because CBPV has been around for 15 years
15:21:44 <mux> BUT, in the haskell part later on, it describes polytypic programming and not parametric polymorphism
15:21:53 <cts> aavogt: So actually we can give a default definition of >>= in terms of <=< and >=>?
15:21:56 <exDM69> the by-value semantics are pretty strange and c-compatible syntax is awful
15:22:04 <aristid> mux: then fix it!
15:22:06 <mux> that must surely scare some people wondering how to do generic programming in Haskell
15:22:07 <alpounet> Cale, maybe you would know about this ?
15:22:31 <mux> aristid: it involves going to a talk page and stuff; I don't have the time nor the english skills for that anyways
15:22:51 <Cale> Accidus: Yeah, but there are lots of things which have been around longer than that which I'm completely unaware of :)
15:23:01 <cts> aavogt: Then >=> and <=< should be part of the Monad definition, too!
15:23:04 <exDM69> is there some sort of haskell equivalent for C++ template specialization?
15:23:05 <aavogt> cts: not when you write a Monad instance, (unless you're calling  <=< in a different Monad instance) but you can do that when you're looking at how code works
15:23:45 <Accidus> Cale, I guess I'm just used to thinking that the reason people don't know about CBPV is because it's inapproachable, not because it's not widely advertised
15:23:45 <mux> hah, right on exDM69 
15:23:51 <Bynbo7> GHC can do specialisation for polymorphic functions, is that what you mean exDM69?
15:24:16 <Cale> alpounet: *looking*
15:24:28 <McManiaC> dcoutts_: http://hackage.haskell.org/trac/ghc/ticket/4843
15:25:02 <dcoutts_> McManiaC: great
15:25:16 <Cale> alpounet: Double has limited precision, and it's the same amount of precision as CDouble
15:25:59 <alpounet> Cale, the closer i get to the golden ratio is 1.618033988749895
15:26:00 <Cale> alpounet: You could try one of the arbitrary precision or computable real numbers libraries
15:26:13 <alpounet> is it normal ?
15:26:16 <McManiaC> dcoutts_: thanks once again for fixing my stupid windows-linking/gcc errors :>
15:26:23 <Cale> > (1 + sqrt 5) / 2
15:26:23 <lambdabot>   1.618033988749895
15:26:29 <aavogt> cts: sure. Some modules/packages have every definition involving a given class as a method, even if default implementations exist. For example see edison
15:26:30 <Cale> yes?
15:26:31 * hackagebot certificate 0.4.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.4.0 (VincentHanquez)
15:26:46 <alpounet> Cale, ok, I thought we could get closer
15:26:56 <Cale> alpounet: Every digit is correct, what more do you want?
15:27:47 <dcoutts_> McManiaC: np
15:27:50 <alpounet> more digits! :P
15:28:03 <Cale> alpounet: If you want more digits, you'll need to change your numeric type to something more than what your CPU's floating point unit can handle on its own, which will slow things down a bunch.
15:28:07 <ddarius> > showCReal pi 200
15:28:08 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
15:28:08 <lambdabot>    arising from a use of...
15:28:16 <ddarius> > showCReal 200 pi
15:28:17 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
15:28:27 <Cale> > showCReal 200 ((1 + sqrt 5) / 2)
15:28:28 <lambdabot>   "1.618033988749894848204586834365638117720309179805762862135448622705260462...
15:29:43 <alpounet> ok, yeah CReal will yield more precise results
15:29:45 <alpounet> thanks guys
15:29:50 <Cale> > showCReal 200 . (!! 50) . iterate (\x -> 1 + 1/x) $ 1
15:29:51 <lambdabot>   "1.618033988749894848203508519241181336761987561883120044504229175554437019...
15:30:52 <ddarius> CReal will yield exact results, you just can't observe that.
15:31:00 <cts> aavogt: I don't understand your last remark.  What is a method?  And what is edison? http://hackage.haskell.org/package/EdisonCore/ has no Monad definition, has it?
15:31:32 * hackagebot tls 0.3.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.3.2 (VincentHanquez)
15:31:57 <McManiaC> > showCReal 100 $ sum [ 1/(product [1..n]) | n <- [1..2000] ]
15:32:00 <lambdabot>   mueval-core: Time limit exceeded
15:32:04 <McManiaC> > showCReal 100 $ sum [ 1/(product [1..n]) | n <- [1..200] ]
15:32:08 <lambdabot>   mueval-core: Time limit exceeded
15:32:10 <McManiaC> damn
15:32:11 <McManiaC> :D
15:32:38 <Cale> CReal gets *slooooow* with large calculations
15:32:38 <McManiaC> > showCReal 100 $ sum [ 1/(product [1..n]) | n <- [1..50] ]
15:32:40 <lambdabot>   "1.718281828459045235360287471352662497757247093699959574966967627723419298...
15:32:47 <McManiaC> hmhm
15:33:06 <ddarius> > sum [1 / product [2..n] | n <- [1..2000]] :: Rational
15:33:10 <lambdabot>   mueval-core: Time limit exceeded
15:33:34 <aavogt> cts: I was just remarking that other libraries enjoy writing large classes http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison-Seq.html#t:Sequence
15:34:04 <aavogt> cts: by method I mean x or y in    class C a where x, y :: a
15:34:15 <Cale> I really wish that we had something as usable as CReal, but which produced approximations which were appropriately fast for the given number of digits demanded at the end.
15:35:20 <Cale> I don't actually understand where the slowness comes from in CReal's case
15:35:39 <Cale> > showCReal 100 (sum [1..200])
15:35:39 <lambdabot>   "20100.0"
15:35:42 <Cale> hmm :)
15:35:48 <Cale> > showCReal 100 (sum [1..1000])
15:35:51 <lambdabot>   mueval-core: Time limit exceeded
15:36:00 <Cale> ^^ that is unacceptable
15:36:08 <sipa> aristid: http://hpaste.org/42338/deep_fmap_using_typelevel_nat
15:36:12 <ddarius> It would make Zetagrid easier.
15:37:27 <cts> aavogt: I get it.  You want me to provide examples where it is useful to have default implementations for >>= in terms of >=> and <=<, right?  Sorry, I don't have any.
15:37:30 <IvarTJ> Hello. I'm attempting to recompile xmonad-contrib with cabal, but my first attempt got interrupted. Now cabal doesn't seem to be able to get any further.
15:38:09 <dcoutts_> IvarTJ: try cabal clean?
15:38:48 <McManiaC> ok, next issue: why is cabal/process broken? http://npaste.de/sM/
15:38:48 <IvarTJ> dcoutts_: I have done so. It then appears to go through all the steps before the step when it fails. It still fails at this step.
15:38:54 <aavogt> @ty \x y -> (x =<< y, x <=< const y $ undefined)
15:38:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> (m b, m b)
15:39:05 <aavogt> cts: you'd do something like that ^^
15:39:17 <dcoutts_> IvarTJ: you'll need to give people more details or they cannot help you
15:39:36 <Kaidelong> :t flip (((>=> . return) .) $)
15:39:37 <lambdabot> parse error on input `.'
15:39:38 <McManiaC> (with my ghc-pkg list: http://npaste.de/sN/ )
15:39:47 <Kaidelong> :t flip ((((>=>) . return) .) $)
15:39:48 <lambdabot> forall a (m :: * -> *) b c a1. (Monad m) => a1 -> (a1 -> m b) -> (b -> m c) -> a -> m c
15:39:56 <IvarTJ> dcoutts_: I will post a paste.
15:40:02 <Kaidelong> hmm not right
15:40:40 <aristid> sipa: :)
15:40:41 <dcoutts_> McManiaC: you don't want to reinstall the same versions of process and directory in your user package db
15:40:48 <Kaidelong> :t (>=>) . const
15:40:49 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> a -> m c
15:40:50 <IvarTJ> dcoutts_: http://pastie.org/1377877
15:41:14 <dcoutts_> McManiaC: hmm, you also seem to have two instances of the same version of process installed, which should be impossible
15:41:20 <aavogt> Kaidelong: exactly. you're safe to use undefined for the 'a' there
15:41:52 <McManiaC> dcoutts_: I did a "cabal install process Cabal --reinstall --global" after I got that error
15:42:19 <dcoutts_> IvarTJ: I suggest you ask the xmonad people what's going on there
15:42:36 <IvarTJ> dcoutts_: Very well.
15:42:39 <dcoutts_> McManiaC: why did you want to reinstall those packages when you have them already?
15:42:42 <cts> aavogt: undefined matches every type, that's terrific!
15:42:55 <Kaidelong> aavogt: how would that one be bind?
15:43:18 <aavogt> @ty (=<<
15:43:19 <McManiaC> dcoutts_: because I got that "unusable due to missing/recursive dependencies" error
15:43:19 <lambdabot> parse error (possibly incorrect indentation)
15:43:21 <aavogt> @ty (=<<)
15:43:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:43:40 <McManiaC> dcoutts_: what else should I have done?
15:43:52 <Kaidelong> hmm, so I'd have to umm, oh I see!
15:44:04 <Kaidelong> give it undefined for the a
15:44:07 <aavogt> yes, a little @unpl makes things easier
15:44:14 <dcoutts_> McManiaC: oh ok, I suspect something was broken previously
15:44:28 <dcoutts_> McManiaC: eliminate the duplicate package instances in your user package db
15:44:28 <cts> aavogt: Is there any naming convention in >>=, =<<, >=> and <=<?  Some way to memorize this?
15:44:35 <aavogt> @pl \x y -> x <=< const y $ undefined
15:44:35 <lambdabot> flip flip undefined . (. const) . (<=<)
15:44:46 <dcoutts_> McManiaC: I'm not sure what to do about the duplicates in the global db, that should be impossible
15:45:07 <Kaidelong> flip flip undefined . (. const) . (<=<)
15:45:24 <Kaidelong> well
15:45:34 <Kaidelong> I guess all you have to define is >=> or <=< after all
15:45:41 <aavogt> cts: a function on the side with the =.  <=<  the same but functions on both sides
15:46:09 <aavogt> cts: or just  :t  (=<<) whenever you forget
15:47:21 <aavogt> Kaidelong: return
15:47:33 <aristid> ghci's :t is most invaluable
15:47:35 <Kaidelong> aavogt: and that
15:47:51 <cts> aavogt: I still like the idea to give default definitions for all these binding functions in the definition of the Monad class.  It allows more flexibility, as Kaidelong says.
15:48:20 <aavogt> people rarely write Monad instances
15:48:24 <McManiaC> dcoutts_: thanks, I'll try
15:48:24 <Kaidelong> is >=> really easier to implement than >>= in most cases?
15:48:31 <aavogt> it's not a big deal
15:48:38 <Kaidelong> aavogt: I've done so twice in my career if that counts
15:48:59 <Kaidelong> once for my backtracker thing and another for an abstraction for coroutines that was a lot like lists
15:49:43 <cts> aavogt: All the good monads are there already?
15:49:48 <Kaidelong> also use Cale's wonderful Rand monad all the time from the libraries
15:49:56 * jmcarthur has written lots of monad instances
15:50:04 <jmcarthur> but maybe that's because i'm kind of a researchy person
15:50:14 <hpc> i have only written one
15:50:29 <hpc> and it's just hand-done transformers
15:50:31 <aavogt> jmcarthur: things you can't make from mtl and associated libraries?
15:50:32 * ddarius just writes monad writing monads.
15:50:36 <Cale> Kaidelong: It's easier to specify the monad laws in terms of >=>
15:50:42 <jmcarthur> aavogt: yeah
15:50:54 <Cale> Kaidelong: But I don't think it's any easier to define in general
15:51:03 <Cale> Kaidelong: join can be easier to define than >>= though
15:51:19 <kolmodin> ?tell waern http://hackage.haskell.org/packages/archive/haddock/2.9.0/logs/failure/ghc-7.0 I get the same message as this
15:51:19 <lambdabot> Consider it noted.
15:51:24 <Kaidelong> haskell doesn't stop you from saying that you can define any one of those, right?
15:51:25 <jmcarthur> aavogt: a lot of them a just free monads which i expanded into a direct ADT representation, some of which could be made from transformers, but not all of them
15:51:28 <jmcarthur> *are just
15:51:50 <sipa> :t join
15:51:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:52:00 <kolmodin> ?seen waern
15:52:00 <lambdabot> Unknown command, try @list
15:52:04 <Cale> Kaidelong: When you write instances of Monad, you have to write them in terms of return and >>=, but nothing's stopping you from defining specialisations of the other equivalent functions first
15:52:07 <ddarius> Jake always hanging out with those lawless types.
15:52:11 <Kaidelong> I do find that sometimes I'd rather define return and join than return and bind
15:52:13 <kolmodin> hmm. which bot should I be asking to use seen?
15:52:13 <lambdabot> kolmodin: You have 4 new messages. '/msg lambdabot @messages' to read them.
15:52:17 <Cale> (though you'll have to name them differently)
15:52:27 <hpc> kolmodin: preflex
15:52:29 <jmcarthur> ddarius: ?
15:52:30 <Kaidelong> I suppose that's analogous to eta and mu
15:52:33 <ddarius> Kaidelong: You have to define return, fmap, and join.
15:53:04 <Kaidelong> ddarius: why fmap? Wouldn't you define that for the functor instance?
15:53:07 <kolmodin> preflex: ?seen waern
15:53:10 <Cale> The monad laws in terms of Kleisli composition are: (1) return <=< f = f   (2) f <=< return = f   (3) f <=< (g <=< h) = (f <=< g) <=< h
15:53:23 <hpc> Kaidelong: without fmap, you can't implement bind
15:53:26 <kolmodin> hpc: like that?
15:53:30 <hpc> but yes, it should be written already
15:53:31 <ddarius> Kaidelong: fmap is not definable in terms of return and join alone.
15:53:39 <hpc> preflex: seen waern
15:53:40 <preflex>  waern was last seen on #haskell 7 days, 11 hours, 48 minutes and 16 seconds ago, saying: seems like hackage passes -XHaskell98 to ghc 7 by default
15:53:45 <kolmodin> ok, thanks
15:53:49 <Cale> Which is another way to say that return and <=< define the identity and composition for a category
15:53:57 <Cale> The Kleisli category for the monad
15:54:19 <Mitar> how can i cite GHC?
15:54:27 <Accidus> Oooh, Kleisli category!
15:54:30 <koninkje> hpc: sure you can (implement bind without fmap)
15:54:41 <Accidus> The (nearly) Lawvere theory for the monad
15:54:54 <Kaidelong> :t (>>=) . return
15:54:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> (a -> m b) -> m b
15:55:17 <Kaidelong> :t ((>>=) . (. return)) . return
15:55:17 <lambdabot>     Ambiguous type variable `m' in the constraint:
15:55:17 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:12-17
15:55:17 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
15:55:18 <hpc> koninkje: this is assuming you can't implement bind by itself; it can be implemented in terms of fmap, return, and join
15:55:29 <Kaidelong> :t ((>>=) . (return .)) . return
15:55:30 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (Monad m, Monad m1, Functor m) => a -> (m1 a -> m b) -> m b
15:55:38 <Kaidelong> I see
15:55:56 <Kaidelong> @src liftM
15:55:56 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
15:56:05 <Cale> Mitar: Maybe provide a link to the GHC website?
15:57:27 <Kaidelong> :t  \x-> ((x >>=) . (return .))
15:57:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> b) -> m b
15:57:54 <Kaidelong> that works
15:57:58 <Kaidelong> just flip it
15:58:38 <koninkje> hpc: aha
15:58:56 <Kaidelong> you just couldn't encode that into actual code because you'll run into overlapping instances
16:00:42 <Kaidelong> :t (=<<) . (return .)
16:00:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b) -> m a -> m b
16:01:23 <cts> I've got another question.  I read LYAH and I'm somewhere in the middle of RWH.  They both seem to avoid category theory on purpose, which is a good thing for many, but where do I go for the categories and their connection to Haskell?  Are there more "old style" books explaining that?  Or research articles?
16:01:32 <cts> :t (.)
16:01:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:01:40 <Kaidelong> cts: try looking up "The Catsters" on youtube
16:01:44 <Kaidelong> I like her lectures
16:02:16 <Kaidelong> lambdabot has a genericized version of . I see
16:02:28 <Kaidelong> "the other prelude"?
16:03:51 <Cale> cts: There aren't a whole lot of great resources for beginners on the connection of category theory with Haskell, but if you know something about categories, the basic connection is is mostly pretty easy.
16:04:16 <Cale> cts: I highly recommend Awodey's Category Theory for learning the basics of CT
16:04:28 <aristid> :t let result=(.); parameter=flip (.) in (result . parameter) return (=<<)
16:04:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
16:04:44 <Cale> You can get a PDF of it from http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf but it's not really free.
16:04:49 <aristid> :t let result=(.); parameter=flip (.) in (parameter . result) return (=<<)
16:04:50 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> m a1 -> m a
16:05:00 <aristid> SEC version
16:05:43 <ddarius> Kaidelong: The Catsters isn't just Eugenia Cheng.
16:06:30 <blackh> Cale: Thanks for that recommendation. Now all I need is the time to read it. Maybe I can put it under my pillow.
16:07:05 <blackh> (I keep trying to chip away at learning category theory.)
16:07:20 <ddarius> blackh: Just read it instead of chatting on IRC.
16:07:52 <blackh> ddarius: I can _now_ that I know about it... (from IRC)
16:08:43 <cts> Cale, Kaidelong: Thank you!
16:10:50 <aristid> blackh: don't listen to ddarius, what does he know. staay ooon IRC *ghosts of addiction*
16:19:12 <aristid> @remember Catfish_Man Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
16:19:12 <lambdabot> Done.
16:19:23 <aristid> @quote Fibonacci
16:19:23 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
16:20:25 <c_wraith> > fix $ (0:) . scanl (+) 1
16:20:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:20:30 <c_wraith> do I win?
16:21:51 <aristid> c_wraith: i cannot say with certainty that there is no shorter version, sorry
16:22:34 <hpc> > fix$(0:).scanl(+)1
16:22:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:22:40 * hpc cheats like a boss
16:23:00 <aristid> hpc: i would discard whitespace in the count anyways, so c_wraith still has the lead
16:23:27 <c_wraith> really, I wasn't aware this was golf anyway
16:23:39 <hpc> :D
16:23:50 <Saizan> it's always gold
16:23:54 <Saizan> *golf
16:23:59 <geheimdienst> nobody is aware of anything, until someone makes it up
16:24:08 * geheimdienst nods wisely
16:24:08 <c_wraith> heh.  I typod that the same way.
16:25:26 <ddarius> > ap(zipWith(+))tail[0..]
16:25:26 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
16:25:39 <ddarius> Curses
16:25:53 <blackh> Cale: I like the CT book already. It starts with a concrete example. Most texts I've read seem to be almost afraid that, unless they start ridiculously generally, you will get some specific idea stuck in your head and you will never understand how general CT is.
16:25:53 <ddarius> Ah, yeah, not enough fix
16:26:07 <c_wraith> ddarius, you discovered odd numbers!
16:26:08 <aristid> > length . ["ap(zipWith(+))tail[0..]", "fix$(0:).scanl(+)1"]
16:26:08 <lambdabot>   [23,18]
16:26:21 <aristid> it's longer, and wronger
16:26:33 <Kaidelong> :t ap
16:26:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:26:38 <ddarius> c_wraith: Those aren't the odd numbers, those are the differences of successive squares.
16:26:40 <sproingie> blackh: which book is that?
16:26:48 <revenantphx> With no computer, ive been slowly working through concrete math...
16:26:51 <Saizan> > fix$ap(zipWith(+))tail -- just to show it
16:26:54 <lambdabot>   mueval-core: Time limit exceeded
16:26:57 <blackh> sproingie: Awodey's Category Theory
16:26:59 <c_wraith> ddarius, which are odd numbers.  2n + 1
16:27:08 <aristid> Saizan: it needs the seed
16:27:13 <Kaidelong> :t (<*>)
16:27:14 <Saizan> heh, true
16:27:14 <revenantphx> Im ALMOST done with chApter 1 exercises :D
16:27:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:27:19 <revenantphx> Almost...
16:27:21 <ddarius> My humor is lost on c_wraith.
16:27:46 <revenantphx> I got that Awodey book. I'm going to read it later
16:27:47 <Kaidelong> why use ap instead of <*>?
16:27:53 <Kaidelong> or was that code golf?
16:28:02 <aristid> Kaidelong: it always is code gold
16:28:13 <geheimdienst> what does ap do again?
16:28:18 <revenantphx> Haskell is kind of always code golf...
16:28:19 <aristid> geheimdienst: same as <*>
16:28:29 <Kaidelong> but for monads
16:28:33 <aristid> ya
16:28:36 <Kaidelong> as opposed to applicative functors
16:28:39 <revenantphx> I like that it's generally rewarding to come up with a clever solution
16:28:54 <Kaidelong> revenantphx: clever is not the same as code golf
16:29:06 <revenantphx> Never said it was
16:29:08 <Kaidelong> using ap instead of <*> to save one character is code golf
16:29:15 <revenantphx> They coincide often though
16:29:38 <Saizan> it might also just be tradition
16:29:40 <revenantphx> Let's not have a flame war €_€
16:29:43 <Saizan> @quote aztec
16:29:43 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:30:04 * ddarius started Haskell long before (<*>) was in the standard libraries.
16:31:10 <Kaidelong> hmm is this religious material? why fear a flame war?
16:32:01 <tswett> @type ap zip tail
16:32:01 <lambdabot> forall b. [b] -> [(b, b)]
16:32:10 <hpc> :t zip`ap`tail
16:32:11 <lambdabot> forall b. [b] -> [(b, b)]
16:32:28 <Twey> > length ("fix$ap(zipWith(+))tail", "fix$ap zipWith(+)<*>tail")
16:32:29 <lambdabot>   Couldn't match expected type `[a]'
16:32:29 <lambdabot>         against inferred type `([GHC.Typ...
16:32:33 <maurer_> > (zip`ap`tail) [1..3]
16:32:34 <lambdabot>   [(1,2),(2,3)]
16:32:37 <Kaidelong> > zip`ap`tail [1..]
16:32:37 <lambdabot>   Couldn't match expected type `[a] -> [b]'
16:32:37 <lambdabot>         against inferred type `[t]'
16:32:38 <Twey> > (length "fix$ap(zipWith(+))tail", length "fix$ap zipWith(+)<*>tail")
16:32:39 <lambdabot>   (22,24)
16:32:47 <Twey> D'oh
16:32:50 <Twey> > (length "fix$ap(zipWith(+))tail", length "fix$zipWith(+)<*>tail")
16:32:50 <lambdabot>   (22,21)
16:32:51 <Saizan> > zip`ap`tail $ [1..]
16:32:51 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
16:32:56 <Twey> The <*> is actually shorter
16:32:58 <Twey> FTR
16:32:59 <Kaidelong> oh my god
16:33:04 <Kaidelong> zip`ap`tail is...
16:33:06 <Kaidelong> pairwise
16:33:16 <Cale> blackh: Yeah, and he develops some of the most important examples of categories internally to the book, which makes it a lot more accessible to nonmathematicians
16:33:19 <Twey> zip<*>tail ;)
16:34:22 <aristid> Twey: except it's no aztec god that way ;)
16:34:28 <aristid> @quote aztec
16:34:28 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:34:53 <Kaidelong> zip<*>tail would be more general in a strict sense wouldn't it?
16:34:59 <Kaidelong> err
16:35:01 <Kaidelong> no it wouldn't
16:35:07 <Kaidelong> zip and tail are for lists only anyway
16:35:07 <Twey> Heh
16:35:10 <Kaidelong> so you don't gain anything
16:35:19 <aristid> Kaidelong: stupid (->) not being polymorphic ;)
16:35:35 <Twey> Kaidelong: That's true, but that <*> is for (->)
16:35:49 <Twey> Still doesn't gain anything, but hey ;)
16:36:08 <Twey> It's more elegant from a type perspective, I think, since we don't have the unnecessary dependency on Monad.
16:36:40 <Kaidelong> zip`ap`tail
16:36:52 <ddarius> Instead you have an unnecessary dependency on Applicative.
16:37:00 <Kaidelong> dear god that is a J-like idiom
16:37:09 <blackh> Cale: When I was learning (Haskell) monads, the biggest problem I had was that I was trying to understand type classes at the same time.  Monads are a lot easier if you already know Haskell, and correspondingly, category theory is a lot easier if you already know the conventions of mathematics.
16:37:44 <Kaidelong> I suppose I could just put "pairwise = zip`ap`tail" somewhere and be done with it
16:37:46 <Cale> blackh: indeed
16:38:28 <Jesin> hmm
16:38:52 <Jesin> @unpl flip . (. flip id)
16:38:52 <lambdabot> (\ k b c -> k (\ f -> f c) b)
16:39:04 <Saizan> Kaidelong: pairwise doesn't sound like a good name
16:39:08 <Jesin> does lambdabot respond if I privmsg it?
16:39:11 <Twey> Ye/
16:39:12 <Twey> Yes**
16:39:17 <Jesin> yes it does
16:39:19 <Kaidelong> Saizan: why not? also that's what F# uses for the concept
16:39:19 <Jesin> :D
16:39:30 <Cale> blackh: That's become more and more true over the last 50 years, as the notations used throughout mathematics have moved toward those originating from category theory, and the whole approach to studying various structures has been transformed quite a bit. You basically never introduce a new kind of structure anymore without at least giving a bit of consideration to what the mappings are between them.
16:39:41 <Saizan> Kaidelong: anyhow, (\xs -> zip xs (tail xs)) is also short enough
16:39:43 <hpc> "zip`ap`tail" has an entertaining aesthetic to it
16:40:26 <Kaidelong> hpc: well in J people supposedly keep dictionaries of things like that around
16:40:33 <Saizan> Kaidelong: pairwise is quite vague, it makes me think more of just zip
16:40:55 <hpc> Kaidelong: they don't have humorous IRC quotes to help them remember :D
16:42:20 <ddarius> > zip=<<tail $ [0..]
16:42:20 <lambdabot>   [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,1...
16:42:58 <aristid> > flip zip=<<tail $ [1..]
16:42:59 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
16:43:40 <Kaidelong> Saizan: would you rather see "Seq.pairwise" or "zip`ap`tail" though?
16:43:53 <ddarius> apfgx=fx(gx), (=<<)fgx=f(gx)x
16:44:41 * ddarius would rather see zipWith f . tail
16:45:45 * Saizan agrees with ddarius
16:45:58 <Twey> 00:37:28 < Kaidelong> I suppose I could just put "pairwise = zip`ap`tail" somewhere and be done with it
16:46:06 <Saizan> also because pairwise sounds like you're doing something with the pairs
16:46:12 <Twey> Kaidelong: Talk about code-golfing… you save three characters with that name :þ
16:46:41 <Kaidelong> saizan: usually yes
16:46:54 <jmcarthur> it's not always about saving characters
16:46:57 <Kaidelong> in F# the idiom is to put pairwise in a pipeline
16:47:03 <jmcarthur> it's also about having a higher level name for it
16:47:15 <Kaidelong> pairwise is generally some intermediate step in a more complex pipeline
16:47:51 <ddarius> Kaidelong: And I'm saying fuse it.
16:48:28 <Kaidelong> ddarius: have a special pairwiseFold or something?
16:48:41 <Kaidelong> (a -> a -> b) -> [a] -> [b]
16:48:43 <Kaidelong> ?
16:49:05 <hpc> :t zipWith . join
16:49:06 <lambdabot> forall a b c. (a -> a -> b -> c) -> [a] -> [b] -> [c]
16:49:09 <aristid> :t zipWith .: tail
16:49:10 <lambdabot> forall a b c. [a -> b -> c] -> [[a] -> [b] -> [c]]
16:49:20 <jmcarthur> :t (.:)
16:49:20 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:49:32 <Saizan> :t \f -> join $ zipWith f . tail
16:49:33 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
16:49:33 <jmcarthur> ah
16:49:38 <aristid> :t \f -> zipWith f `ap` tail
16:49:38 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
16:49:47 <aristid> @pl \f -> zipWith f `ap` tail
16:49:47 <lambdabot> (`ap` tail) . zipWith
16:50:09 <Saizan> (trading ap for join and . is quite amusing from a readability perspective :)
16:53:15 <Saizan> (also, is (ap `specializesTo` S) such an obscure fact?)
16:53:58 <Twey> I don't think so
16:54:17 <Twey> It seems pretty obvious, but maybe that's just because I've seen zip`ap`tail so often :þ
16:54:31 <aristid> :t specializesTo
16:54:32 <lambdabot> Not in scope: `specializesTo'
16:54:41 <Twey> > let fibs = zipWith (+) `ap` tail $ fibs in take 10 fibs
16:54:44 <lambdabot>   mueval-core: Time limit exceeded
16:54:47 <aristid> Saizan: lambdabot does not know what specializesTo is!
16:54:48 <Twey> :<
16:55:00 <aristid> Twey: add the damn seed
16:55:04 <Kaidelong> Twey: stuff like "zip`ap`tail" is what turned me off to J
16:55:15 <Twey> aristid: Seed?
16:55:19 <Twey> Oh
16:55:20 <Twey> Seed.
16:55:25 <Twey> > let fibs = 0 : 1 : zipWith (+) `ap` tail $ fibs in take 10 fibs
16:55:25 <lambdabot>   Couldn't match expected type `[a -> t]'
16:55:25 <lambdabot>         against inferred type `[a1]...
16:55:27 <ddarius> What aristid is trying to say is prime the pump.
16:55:42 <ddarius> Kaidelong: It wasn't the 0:!3 ?
16:55:43 <Twey> > let fibs = 0 : 1 : ap (zipWith (+)) tail fibs in take 10 fibs
16:55:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
16:56:33 <Kaidelong> unreadable programs
16:56:49 <Kaidelong> and too much abstraction
16:57:19 <mm_freak> > filterM (const [True, False]) "abc"
16:57:20 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
16:57:51 <aristid> Kaidelong: and your cure was... haskell?
16:57:59 <Twey> Haha
16:58:07 <Twey> Haskell has way more abstraction than J
16:58:13 <Twey> Though it's arguably more readable ☺
16:58:26 <Kaidelong> well haskell has abstraction with types
16:58:31 <ozataman> Can one splice arbitrary/custom datatypes using TemplateHaskell?
16:58:37 <aristid> Kaidelong: yeah i guess types help
16:58:37 <Twey> Fair
16:58:38 <Kaidelong> and types sort of annotate what the abstractions are doing
16:58:52 <aristid> i use :t all the time
16:59:17 <Kaidelong> J uses higher order functions all the time but you can't do :t
16:59:35 <Saizan> ozataman: you can splice declarations, so yes
17:00:14 <ozataman> Saizan: OK, that's what I thought from looking at the 0 documented API, thank you :)
17:00:47 <ozataman> Saizan: How would you, say, splice a Map Text Text with a bunch of data loaded in it, for example?
17:01:32 <ozataman> Saizan: I'm trying to load the Map Text Text from a file at compile time and splice in as a top-level declaration so I can have direct access to it throughout my program
17:01:35 <Saizan> ozataman: oh, i understood you wanted to define new types
17:01:54 <ozataman> Saizan: Well Map Text Text doesn't have an already defined Lift instance
17:02:16 <ozataman> Saizan: So I can't juse use the quasi quotation syntax
17:02:18 <Saizan> ozataman: to embed a precomputed value you have to build an expression that will evaluate to that value at runtime
17:02:38 <ozataman> Saizan: That's that I was afraid of
17:02:59 <ozataman> Saizan: Just too inconvenient to do that... I guess this is where lispers declare victory
17:03:20 <Saizan> too incovenient in which sense?
17:04:08 <ozataman> Saizan: Well, I've already got code that nicely loads a text file into a Map Text (CustomDataType). sounds a bit ugly to convert it to use the AST defined by TH
17:04:13 <Saizan> i know it's too inconvenient in the sense that it doesn't work well for abstract types, especially functions
17:06:02 <Saizan> ozataman: it's something like "VarE 'fromList `AppE` map lift (toList yourmap)"
17:06:38 <Saizan> though Lift for Text has to go via String literals, i'm afraid
17:07:44 <Saizan> we should ask SPJ for an Embed :: a -> Exp constructor :)
17:08:14 <ozataman> Saizan: I see. So I would have to unpack the Text and repack on the receiving end.. but then the whole point of memoizing is lost..
17:08:26 <ozataman> I have been hunting for a function with that signature in the TH library for the past hour!!
17:09:23 <ozataman> the original paper talks about some issues with Cross-stage Persistence and why lift was necessary..
17:10:46 <Saizan> i guess problems arise if you try to embed something like an Handle, though that could give a compile time error, i've not read the papers though
17:36:43 <Jesin> ...oh god the amtrak logo  D:
17:37:51 <Zao> Interesting. In the process of translating this Haskell into Moscow ML, I find that my functions are ordered in reverse as what ML requires.
17:38:27 <Pseudonym> I agree with that observation, Zao.  ML programs are best read standing on your head.
17:38:55 <Pseudonym> The order that you think is the opposite of the order that you write it.
17:39:08 <Pseudonym> So you can't read an ML program as you would a piece of text.
17:39:10 <Jesin> hmm
17:39:32 <Jesin> where would I be able to access the code used in the GHC standard libraries?
17:39:50 <kmc> http://hackage.haskell.org/packages/archive/pkg-list.html http://www.haskell.org/ghc/docs/latest/html/libraries/
17:39:50 <Zao> Jesin: Either from links in the docs, or just fetch the whole source tarball.
17:39:56 <kmc> there are "Source" links
17:40:28 <Jesin> ah, nice
17:40:30 <Jesin> thanks
17:40:54 <Zao> @src map
17:40:54 <lambdabot> map _ []     = []
17:40:54 <lambdabot> map f (x:xs) = f x : map f xs
17:41:16 <blackh> Jesin: Haskell is a democracy. That's why it has such a terrible logo. :)
17:41:23 <Jesin> yup  :p
17:41:24 <Jesin> umm
17:41:34 <Jesin> there's an @src command, ok
17:41:35 <kmc> i think the new logo is pretty good
17:41:35 <Jesin> nice
17:41:37 <Adamant> Haskellia, fuck yeah?
17:41:40 <Jesin> @src fix
17:41:40 <lambdabot> fix f = let x = f x in x
17:41:44 <kmc> Jesin, @src just reads a small flat file database
17:41:46 <Zao> Jesin: It grabs from some text file bundled with teh bot or something.
17:41:53 <kmc> it's missing a lot of stuff and may not be accurate
17:41:54 <hpc> Jesin: a bit more clearly, fix f = f (fix f)
17:42:05 <Jesin> how does that definition work...
17:42:06 <kmc> http://www.vex.net/~trebla/haskell/fix.xhtml
17:42:16 <kmc> Jesin, that link is an excellent intro
17:42:23 <Zao> > let x = x + 1 in x
17:42:25 <hpc> Jesin: fix (1:) = 1:(fix (1:))
17:42:27 <lambdabot>   mueval-core: Time limit exceeded
17:42:38 <c_wraith> Jesin: it works whenever f produces output before looking at its input.
17:42:38 <kmc> > fix ((0:).scanl(+)1)
17:42:38 <hpc> Jesin: if you match on the head of the list, it evaluates 1
17:42:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:42:44 <Zao> > take 10 $ fix (1:)
17:42:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
17:42:45 <hpc> and queues a thunk for the rest of the list
17:43:46 <Pseudonym> blackh: There's a better logo, but nobody has evaluated it yet.
17:44:04 <kmc> i think the new Haskell logo is pretty good
17:44:52 <hpc> indeed, the latest logo is excellent
17:45:01 <hpc> simple and stylish
17:45:28 * hackagebot split 0.1.3 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.3 (BrentYorgey)
17:45:46 <blackh> I think it looks old-fashioned, but I love the thing it stands for, so I use it proudly.
17:47:30 <hpc> http://haskell.org/wikistatic/haskellwiki_logo_white.png is old-fashioned?
17:48:17 <hpc> er, that image, but on a colored background
17:48:25 <Jesin> @src join
17:48:25 <lambdabot> join x =  x >>= id
17:48:37 <Jesin> @src ap
17:48:37 <lambdabot> ap = liftM2 id
17:48:40 <kmc> hpc, no drop shadow, no bubble text, no missing-vowel name
17:48:52 <kmc> hsklr 2.0 beta
17:49:01 <hpc> kmc: i see; now that i think of it, it's not webscale either
17:49:37 <kmc> yeah
17:49:45 <kmc> they should use javascript, it has first-class functions
17:50:23 <hpc> indeed; static images are static; they can't yield dynamic multifaceted interactive hypertext!
17:50:57 <Jesin> ...
17:51:17 <Jesin> I don't have a problem with the new logo
17:51:20 * hpc is done with the silliness
17:51:30 <Jesin> I just saw this: http://blog.plover.com/prog/haskell/logo.html
17:51:42 <Pseudonym> http://creatr.cc/creatr/logo/Haskell.png?1292377860 <- This better?
17:51:45 <Jesin> and was like, oh noes amtrak
17:51:47 <Jesin> hmm
17:52:06 <Jesin> maybe amtrak runs on haskell
17:52:20 <Pseudonym> http://creatr.cc/creatr/ <- Warning: Productivity sink for at least 10 minutes.
17:53:00 <hpc> Pseudonym: that site gives me the willies
17:53:07 <hpc> someone out there is going to take it seriously
17:54:06 <Pseudonym> If it puts a bunch of inappropriately-priced conslutants out of business, it will have been worth it.
17:54:48 <blackh> Pseudonym: The latest trend in graphic design is, apparently, to. put. a. full. stop. between. every. word.
17:54:57 <Pseudonym> Worst. Trend. Ever.
17:55:23 <Pseudonym> Is it to do with domain names or something?
17:55:32 <Axman6> i saw a shop in japan the other day that spelt its as I.T.'S.
17:55:35 <Axman6> it's*
17:55:49 <Pseudonym> That could just be a language barrier.
17:56:21 <hiredman> there is a huge sign on a building near my parent's place in korea that says SH.I.T.
17:57:11 <hpc> that. sounds. like. the. doing. of. william. shatner.
17:58:59 <Kaidelong> I see we are all talking about haskell in here
17:59:31 <Pseudonym> Yeah, that Haskell is a pretty good language, isn't it.
17:59:37 <Pseudonym> Yes sir, I like programming in Haskell!
17:59:46 <Kaidelong> because . we . put . a . full . stop . between . every . word (. ?)
17:59:56 <Kaidelong> . (?)
17:59:57 <Kaidelong> I mean
18:00:01 <etpace> Axman6: have you not seen how to open the emergency rid in our apartments yet?
18:00:05 <etpace> rid (sic)
18:00:16 <Cale> > let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 + 3*y*x + 2*y^2 + 2*y - x^6 + x^2 + x in take 10 [f x y | n <- [0..], x <- [0..n], let y = n - x, f x y >= 0]
18:00:17 <lambdabot>   [0,2,1,3,5,8,13,21,34,55]
18:00:23 <Cale> > let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 + 3*y*x + 2*y^2 + 2*y - x^6 + x^2 + x in take 20 [f x y | n <- [0..], x <- [0..n], let y = n - x, f x y >= 0]
18:00:27 <lambdabot>   mueval-core: Time limit exceeded
18:00:33 <Cale> > let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 + 3*y*x + 2*y^2 + 2*y - x^6 + x^2 + x in take 15 [f x y | n <- [0..], x <- [0..n], let y = n - x, f x y >= 0]
18:00:36 <lambdabot>   [0,2,1,3,5,8,13,21,34,55,89,144,233,377,610]
18:00:46 <hpc> oh god, the polynomial
18:00:53 <Axman6> etpace: heh, yeah, i'm looking forward to the next fire so i can try it out
18:01:25 <Cale> > let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 + 3*y*x + 2*y^2 + 2*y - x^6 + x^2 + x in take 15 [f x y | n <- [0..], y <- [0..n], let x = n - y, f x y >= 0]
18:01:28 <lambdabot>   [0,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
18:01:32 <Pseudonym> let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 + 3*y*x + 2*y^2 + 2*y - x^6 + x^2 + x in take 15 [f x y | n <- [0..], x <- [0..n], let y = n - x]
18:01:43 <Pseudonym> > let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 + 3*y*x + 2*y^2 + 2*y - x^6 + x^2 + x in take 15 [f x y | n <- [0..], x <- [0..n], let y = n - x]
18:01:44 <lambdabot>   [0,2,1,-116,3,-58,-1434,5,-284,-717,-8152,-665,-354,-2395,-4076]
18:02:22 <Cale> http://math.ucalgary.ca/~jpjones/abst1988.htm
18:04:00 <Pseudonym> Don't give away the answer before I've finished eigenanalysing.
18:07:14 <lars9> hmmm, what's the relationship between the two pkgs mtl and transformers?
18:09:12 <Saizan> since version 2, mtl is a re-exporting of transformers and monads-fd
18:09:26 <Saizan> before they just conflict
18:10:09 <lars9> so i can just use mtl?
18:10:42 <lars9> transformers will be tranparent then?
18:11:37 <Saizan> i guess so, i haven't tried 
18:11:42 <lars9> thanks
18:13:14 <Pseudonym> > let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 - x^6 + (2*y + x)^2 + (2*y + x) in take 15 [f x y | n <- [0..], x <- [0..n], let y = n - x, f x y >= 0]
18:13:16 <lambdabot>   [0,4,1,6,15,32,78,189,476,1210,3115,8064,20970,54665,142740]
18:13:27 <Pseudonym> Hrm.
18:21:25 <pedro3005> How do I convert an int to a string?
18:21:44 <Saizan> > show 1
18:21:45 <lambdabot>   "1"
18:22:27 <pedro3005> thanks
18:23:41 * hackagebot atomo 0.3 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.3 (AlexSuraci)
18:26:17 <Kaidelong> the omega ordinal really reminds me of bottom
18:31:43 * hackagebot anatomy 0.3 - Anatomy: Atomo documentation system  http://hackage.haskell.org/package/anatomy-0.3 (AlexSuraci)
18:33:57 <Saizan> and yet it's used to prove some things are not bottom
19:01:24 <Davorak> I just started learning haskell a little while ago. I am working on problem 10 of haskell 99 questions found goo.gl/HapIy. My proposed code, error, and example can be found at hpaste: goo.gl/0kAwF.
19:02:57 <Kaidelong> that is a terrible error
19:03:01 <Kaidelong> but
19:03:21 <Kaidelong> :t map (\xs -> (length xs, head xs))
19:03:22 <lambdabot> forall a. [[a]] -> [(Int, a)]
19:03:33 <Kaidelong> what you probably want is mmm
19:03:38 <Kaidelong> :t map (\xs -> (length xs, head xs)) . group
19:03:39 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
19:04:15 <Kaidelong> > map (\xs -> (length xs, head xs)) . group $ "aaaabccaadeeee"
19:04:15 <lars9> > map (length &&& head) $ group "aaaabccaadeeee"
19:04:16 <lambdabot>   [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]
19:04:16 <lambdabot>   [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]
19:04:33 <lars9> Kaidelong: ^^
19:05:18 <Davorak> Thanks kaidelong.
19:05:18 <Axman6> > length "aaaabccaadeeee"
19:05:18 <lambdabot>   14
19:05:32 <Axman6> > length "[(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]"
19:05:33 <lambdabot>   49
19:05:33 <Jesin> hmm
19:05:37 <Axman6> >_>
19:05:37 <Jesin> I just found a thing
19:05:39 <Jesin> 'It would be nice if join could combine the duplicate heads into a single ("heads", 0.55) entry. But that would force an Eq a constraint on the event type, which isn't allowed, because (>>=) must work for all data types, not just for instances of Eq. This is a problem with Haskell, not with the monad itself. It's the same problem that prevents one from making a good set monad in Haskell,...
19:05:40 <Kaidelong> Davorak: basically the reason you got that error message is because if there was some type that was both a and [a] at the same time, that could have worked
19:05:41 <Jesin> ...even though categorially sets are a perfectly good monad. (The return function constructs singletons, and the join function is simply set union.)'
19:05:57 <Kaidelong> but haskell disallows such things
19:07:32 <Jesin> @src &&&
19:07:32 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
19:07:36 <lars9> Jesin: how to ensure singleton if Eq is not allowed?
19:08:05 <Jesin> umm
19:08:17 <Jesin> I think that was an argument that an Eq constraint should be allowed
19:08:40 <Davorak> Kaidelong: I do not think I followed that completely. I get that  [a]->[(Int,a)] was not specific enough, but not what contradictory cases it allowed.
19:09:03 <Jesin> (eh, I'm a little tired, sorry  =/ )
19:09:08 <Jesin> @src >>>
19:09:08 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:09:15 <Jesin> what
19:09:20 <Axman6> @src (>>>)
19:09:20 <lambdabot> Source not found. :(
19:09:46 <lars9> >>> is seperately defined for different arrows
19:09:59 <Jesin> @src arr
19:09:59 <lambdabot> Source not found. Just try something else.
19:10:11 <Jesin> @src ***
19:10:11 <lambdabot> f *** g = first f >>> second g
19:11:55 <Kaidelong> Dvorak: you gave something of type [[a]]->[(Int,a)] the type annotation [a]->[(Int,a)]
19:12:52 <Kaidelong> Davorak: instead of the useful error message "cannot match [a]->[(Int,a)] with [[a]]->[(Int,a)]" it gave you the occurs check because it is valid for a type where a and [a] are the same thing, but haskell does not allow such types
19:14:20 <Zao> @src inits
19:14:20 <lambdabot> inits []     =  [[]]
19:14:20 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
19:14:48 <Davorak> Kaidelong: Thanks that makes more sense.
19:28:52 <Davorak> Kaidelong: Let me know if this is right. [a]->[(Int,a)] allows for a and [a] to hold equal footing. After adding the type class (Eq a) the ambiguity between a and [a] was dissolved because a and [a] can not be compared with Eq.
19:33:28 <Cale> Davorak: It's more that a cannot be equal to [a], because this leads to an infinite type: [[[[[...]]]]]
19:33:48 <Cale> Davorak: and while such things are theoretically possible to deal with, they usually indicate type errors
19:34:13 <Cale> That is if a = [a], then a = [a] = [[a]] = [[[a]]] = [[[[a]]]] = ...
19:34:45 <Cale> and the occurs check is a test that the compiler does to see if the same type variable occurs on both sides of an equation when it unifies
19:35:01 <Saizan> [a]->[(Int,a)] is a perfectly valid type by itself, it just doesn't match the code
19:38:59 <Jesin> @type inits
19:39:00 <lambdabot> forall a. [a] -> [[a]]
19:41:07 <Davorak> Cale: Saizan: with Saizans comment it makes sense. I see the type mismatch of [a] and [(Int, a)] now.
19:46:08 <sumcallmetim118> hello
19:46:20 <Cale> hi!
19:46:44 <sumcallmetim118> anyone here know c++ and willing to help some1 stressed to death?
19:46:51 <ew> sure
19:47:06 <ew> what's the problem?
19:47:22 <sumcallmetim118> well...i kinda scratched the whole program lol
19:47:41 <ew> how big is this program?
19:48:20 <sumcallmetim118> umm its not to big just need to make a program that gives math problems for grades k-6 basicly
19:48:21 <ew> dump your question on pastie.org
19:48:49 <sumcallmetim118> i dont have a specific question yet, but i will for sure
19:48:52 <pedro3005> can someone help with http://codepad.org/gGXMxtC6 ?
19:51:06 <ew> you want to generate a printable document?
19:51:06 <Saizan> pedro3005: head xs :: [a], but flatten expects an [[a]]
19:51:26 <Saizan> ew, sumcallmetim118: c++ questions should go to #c++ :)
19:51:37 <Saizan> (or how it's called)
19:52:16 <pedro3005> Saizan, well, assuming the list is something like [[1, 2], [3, 4]], head xs = .. oh
19:52:23 <pedro3005> hm
19:52:46 <Saizan> there isn't much to flatten in [1,2]
19:53:05 <pedro3005> you're right
19:53:19 <Saizan> (however your code has other problems too)
19:53:26 <sumcallmetim118> I am asking the user what grade they are in. and they answer either k,1,2,3,4,5, or 6. What should i save the answe as so it can recognize a k or numbers?
19:54:24 <pedro3005> Saizan, yeah. http://codepad.org/qKuf4qiI , but it doesn't work
19:54:48 <pedro3005> oh wait, it kind of does
19:54:50 <ew> a std::string would be fine
19:55:15 <Saizan> pedro3005: you should pick a better base case
19:55:15 <pedro3005> http://codepad.org/F9pm9oe7
19:55:38 <Saizan> [[1, 2], [3, 4], 5] is not well typed
19:55:48 <Saizan> [[1, 2], [3, 4], [5]] would be
19:56:12 <pedro3005> ghci> flatten [[1, 2], [3, 4], [5]]
19:56:12 <pedro3005> [1,2,3,4,5*** Exception: Prelude.head: empty list
19:56:13 <Saizan> 5 is a number, [5] is a list of one element, which is that number
19:56:53 <pedro3005> does haskell have try/catch? :P
19:57:06 <Saizan> you don't need try catch here
19:57:08 <Zao> pedro3005: It has exceptions, yup.
19:57:15 <ew> yes it does
19:57:16 <ew> =D
19:57:18 <Saizan> just use better cases
19:57:23 <Zao> Just don't be stupid, and you'll rarely need it :D
19:57:32 <pedro3005> yeah, I'll try to think of something
19:57:41 <Zao> In other news, SML's List.take throws if you feed it a length longer than the list.
19:57:43 <Saizan> pedro3005: you haven't defined what flatten should do when it's given an empty list
19:57:45 <Zao> $@#$
19:58:03 <sumcallmetim118> string doesnt work or that i tried
19:58:04 <ew> pedro3005: also try using recursion
19:58:33 <Saizan> he's already using recursion, actually
19:58:34 <pedro3005> Saizan, oh.. that seems to work now. thanks!
19:58:34 <ew> sumcallmetim118: you can't store 1 in a string, but you can store "1"
19:58:35 <Zao> sumcallmetim118: You could store it in a String, a Char, a custom type, or anything else.
19:59:00 <Zao> I'd go with data Grade = GradeK | GradeN Int
19:59:17 <Zao> As that gets you a decent ordering if you derive it.
19:59:42 <Cale> Zao: I think sumcallmetim118 is asking about C++, btw
19:59:43 <Saizan> pedro3005: also, when you have "foo xs = ... head xs ... tail xs" you should write that with pattern matchin as "foo (x:xs) = .. x ... xs"
19:59:54 <Zao> Cale: This is an awfully odd place to ask about C++, I'd say.
20:00:05 <sumcallmetim118> id desperate
20:00:08 <Cale> sumcallmetim118: You just might have better luck if you were to ask in a channel about C++ instead of about Haskell :)
20:00:08 <ivanm> @hoogle concatMapM
20:00:09 <lambdabot> No results found
20:00:13 <Zao> Although as I'm currently ranting about SML... *ahem*
20:00:33 <Zao> I've reimplemented a fair chunk of the Prelude and Data.* by now :D
20:00:41 <ivanm> is it worth explicitly defining concatMapM (ala concatMap) or just doing liftM concat . mapM ?
20:01:00 <Cale> sumcallmetim118: Like ##c++ or ##c++-basic
20:01:06 <ivanm> Zao: wait, what? why are you re-implementing the Prelude, etc.?
20:01:28 <ew> ivanm: seems like agreat way of learning haskell
20:01:41 <Zao> ivanm: Because I'm writing SML code.
20:01:45 <Saizan> Zao: i think there are support groups for your situation, or there should be
20:01:54 <Zao> I started off by writing a correct program in Haskell, and then porting :D
20:02:09 <ivanm> Zao: and you're trying to turn SML into Haskell? or because the standard/base library in SML is lacking?
20:02:18 <Zao> ivanm: The SML Basis is severely lacking.
20:02:22 <Jesin> hmm
20:02:26 <Zao> http://www.standardml.org/Basis/manpages.html
20:02:28 <Zao> That's about it.
20:02:40 <Jesin> so, for functions at least, (>>>) is essentially flip (.) yes?
20:02:44 <Zao> No 'inits', no [0..x], no sane List.take, etc.
20:02:47 <Cale> Jesin: yes
20:02:50 <Zao> Heck, it doesn't even have a Set or Map :D
20:02:59 <ivanm> Zao: but it has inbuilt networking and tty stuff! how can it be lacking!
20:02:59 <ivanm> :p
20:03:28 <Zao> I also love the schizoid mixture of tupled and curried function arguments.
20:03:33 <Saizan> ListPair?
20:03:39 <Zao> Saizan: Contains 'zip' and friends.
20:03:47 <Zao> And other functions to work on lists of 2-tuples :D
20:04:58 <Saizan> or tuples of lists
20:05:11 <Saizan> i guess it's a separate structure to reuse the names
20:05:46 <Pseudonym> Oh, man.
20:05:50 <Saizan> and zip throws exceptions instead of truncating..
20:06:26 <Pseudonym> Every recursively enumerable set is the solution set of a Diophantine equation.
20:06:30 <Pseudonym> That's freaky.
20:07:01 <Zao> Saizan: It does? Oh crap.
20:07:27 <Saizan> Zao: ah, no, only zipEq
20:10:07 <andrewsw> Pseudonym: where do you find that?
20:10:24 <Pseudonym> I was looking up the polynomial that Cale gave earlier.
20:11:24 <Pseudonym> http://en.wikipedia.org/wiki/Diophantine_set
20:11:38 <andrewsw> right
20:12:28 <Cale> Yeah, that's a really important result. Number theory is as hard as can be, folks :)
20:12:37 <andrewsw> yeah, very cool
20:12:43 <Pseudonym> And no harder, which is a relief.
20:13:18 <Cale> I find it quite interesting that the polynomial earlier is of such low degree though.
20:13:28 <Cale> (and small coefficients)
20:13:34 <Pseudonym> There's one of lower degree, but it returns numbers multiple times.
20:13:48 <andrewsw> I missed the polynomial, care to repeat it (or suggest how far back in the scrollback it might be)
20:13:51 <Pseudonym> Well, it's based on the fact that Fibonacci numbers have nice properties.
20:13:56 <Cale> > let f x y = 7*y^4*x^2 - 7*y^2*x^4 - 5*y*x^5 + y^3*x^3 + y^5*x - 2*y^6 + 3*y*x + 2*y^2 + 2*y - x^6 + x^2 + x in take 15 [f x y | n <- [0..], y <- [0..n], let x = n - y, f x y >= 0]
20:13:59 <lambdabot>   [0,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
20:14:53 <Pseudonym> let f x y = 2*y^4*x + y^3*x^2 - 2*y^2*x^3 - y^5 - y*x^4 + 2*y in take 15 [f x y | n <- [0..], y <- [0..n], let x = n - y, f x y >= 0]
20:15:02 <Pseudonym> > let f x y = 2*y^4*x + y^3*x^2 - 2*y^2*x^3 - y^5 - y*x^4 + 2*y in take 15 [f x y | n <- [0..], y <- [0..n], let x = n - y, f x y >= 0]
20:15:03 <lambdabot>   [0,0,1,0,1,0,2,0,0,3,0,0,0,5,0]
20:15:08 <Pseudonym> > let f x y = 2*y^4*x + y^3*x^2 - 2*y^2*x^3 - y^5 - y*x^4 + 2*y in take 15 [f x y | n <- [0..], y <- [0..n], let x = n - y, f x y > 0]
20:15:12 <lambdabot>   mueval-core: Time limit exceeded
20:15:21 <Pseudonym> Anyway.
20:15:26 <Pseudonym> It also has a structure.
20:15:51 <Pseudonym> It's a bilinear polynomal plus a biquadratic polynomial plus a bisextic polynomial.
20:16:18 <Cale> "Corresponding to any given consistent axiomatization of number theory, one can explicitly construct a Diophantine equation which has no solutions, but such that this fact cannot be proved within the given axiomatization."
20:16:29 <Cale> (which is sort of obvious from the previous result)
20:16:52 <Pseudonym> So is there a procedure to convert a program into a Diophantine equation?
20:16:53 <Jesin> Prelude> let f x y = 2*y^4*x + y^3*x^2 - 2*y^2*x^3 - y^5 - y*x^4 + 2*y in take 15 [f x y | n <- [0..], y <- [0..n], let x = n - y, f x y > 0]
20:16:54 <Jesin> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
20:16:56 <Cale> yeah
20:16:57 <Jesin> Prelude> let fibs = 1 : scanl (+) 1 fibs
20:16:58 <Jesin> Prelude> take 15 fibs
20:16:59 <Jesin> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
20:17:01 <Jesin> success
20:17:26 <Pseudonym> Yay.
20:18:58 <Pseudonym> > let l x y = y*y - x*y - x*x in take 15 $ filter (\x -> some (\y-> abs (l x y) == 1) [0..x]) [0..]
20:18:59 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
20:19:31 <Pseudonym> > let l x y = y*y - x*y - x*x in take 15 $ filter (\x -> any (\y-> abs (l x y) == 1) [0..x]) [0..]
20:19:34 <lambdabot>   mueval-core: Time limit exceeded
20:20:04 <Pseudonym> > let l x y = y*y - x*y - x*x in take 10 $ filter (\x -> any (\y-> abs (l x y) == 1) [0..3*x]) [0..]
20:20:05 <lambdabot>   [1,2,3,5,8,13,21,34,55,89]
20:20:20 <Pseudonym> The rest is left as an exercise.
20:46:12 <lars9> @where lars9
20:46:12 <lambdabot> I know nothing about lars9.
21:12:39 <Zao> @src minimumBy
21:12:39 <lambdabot> Source not found. Are you on drugs?
21:12:41 <Zao> @src minimum
21:12:42 <lambdabot> minimum [] = undefined
21:12:42 <lambdabot> minimum xs = foldl1 min xs
21:22:08 <Zeiris> I don't know if Luke Palmer lurks there, but the graphics-drawingcombinators package is kinda cool.
21:36:43 <lars9> > _|_ == undefined
21:36:43 <lambdabot>   <no location info>: parse error on input `|'
21:37:15 <Cale> Zeiris: yes it is. If you liked that, also see data-memocombinators :)
21:37:31 <Cale> (I realised the other day that they're done by the same person :)
21:37:41 <lars9> > _|_
21:37:42 <lambdabot>   <no location info>: parse error on input `|'
21:37:48 <lars9> > (_|_)
21:37:49 <lambdabot>   <no location info>: parse error on input `|'
21:38:28 <lars9> m(_ _)m
21:39:26 <redd_> Is there a library fixpoint function on two arguments, e.g., fix f x y | f x y == y = f x y | otherwise = fix f (f x y) x ? or can this be expressed using default fixpoint?
21:39:42 <Zeiris> lars9, Haskell code looks like emoticons, but emoticons aren't valid Haskell code.
21:40:19 <lars9> Zeiris: you know what this emotion is? m(_ _)m
21:41:20 <lars9> how to use _|_ ? i saw it in tutorial but never in code
21:41:45 <Cale> lars9: It's just ascii art for a mathematical symbol
21:41:51 <Cale> lars9: It's not actual Haskell syntax
21:42:00 <redd_> You can use undefined. E.g., data True = undefined for type level booleans. This is equivalent to bottom.
21:42:27 <lars9> Cale redd_ i see, thanks
21:42:31 <Cale> lars9: It represents any computation which doesn't terminate (or produces an error)
21:42:37 <jmcarthur> Zeiris: luke goes by luqui here
21:44:00 <lars9> yeah i know the meaning of buttom
21:47:26 <Axman6> redd_: uh, no you can't
21:48:00 <Axman6> you can use `data True` or data True = True, but undefined doesn't make any sense there
21:50:01 <redd_> You're right. But you can do data True; true :: True; true = undefined. My bad.
21:50:19 <Axman6> yeah
22:13:52 * hackagebot redis-hs 0.1.1 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.1.1 (WillLangstroth)
22:45:08 <lispy> hey
22:45:12 <lispy> how's it going?
22:49:24 <kfish> quietly
23:32:27 <zong_sharo> if i want to re-export contents of some module almost completely, but for the symbols i don't want to export i want them to use localy
23:32:46 <zong_sharo> i suppose something like:
23:33:00 <zong_sharo> module Blah (module Foo) where
23:33:05 <pedro3005> I made this implementation of zip using a list comprehension http://codepad.org/hA67ntOc , but http://learnyouahaskell.com/recursion shows one with recursion.. is one necessarily better than the other?
23:33:16 <zong_sharo> import module Foo hiding (functionsForLocalUse)
23:33:26 <zong_sharo> import qualified Foo as Foo
23:33:29 <Cale> pedro3005: yes
23:33:32 <zong_sharo> ... Foo.functionsForLocalUse
23:33:39 <Cale> pedro3005: Your implementation has quadratic complexity
23:33:40 <zong_sharo> will do the trick, i'm right?
23:33:43 <c_wraith> pedro3005, !! is a very bad idea to use.
23:33:47 <Cale> pedro3005: and won't work with infinite lists
23:33:52 <c_wraith> also, !! is defined recursively.
23:34:25 <pedro3005> Cale, it seems linear to me
23:34:29 <zong_sharo> > [1..] !! 11
23:34:29 <lambdabot>   12
23:34:42 <zong_sharo> Cale: huh? it's wotks with infinite lists
23:34:46 <zong_sharo> *works
23:34:55 <zong_sharo> still linear tile access, but woks
23:34:55 <c_wraith> pedro3005, lists aren't arrays.  !! is O(n)
23:34:57 <jmcarthur> > let zip xs ys = [(x, y) | x <- xs | y <- ys] in zip [1..] [1..]
23:34:58 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,...
23:35:06 <zong_sharo> *works
23:35:09 <zong_sharo> damn
23:35:14 <Cale> zong_sharo: length doesn't
23:35:20 <zong_sharo> Cale: sure
23:35:25 <jmcarthur> (of course that's really just using zip (or zipWith?) under the hood)
23:35:40 <zong_sharo> can please someone elaborate on my export issue?
23:35:42 <Cale> > let { zip' _ [] = []; zip' [] _ = []; zip' n m = [((n !! k), (m !! k)) | k <- [0..(minimum [length n, length m])-1]] } in zip' [0..] [0..]
23:35:47 <lambdabot>   mueval: ExitFailure 1
23:35:53 <Cale> > zip [0..] [0..]
23:35:55 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
23:35:57 <zong_sharo> i want to re-export module almost completely, but for the rest - i want to use it in module
23:36:00 <Cale> ^^
23:36:20 <Cale> > let { zip' _ [] = []; zip' [] _ = []; zip' n m = [((n !! k), (m !! k)) | k <- [0..(minimum [length n, length m])-1]] } in zip' [0..10000] [0..10000]
23:36:21 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
23:36:28 <Cale> > let { zip' _ [] = []; zip' [] _ = []; zip' n m = [((n !! k), (m !! k)) | k <- [0..(minimum [length n, length m])-1]] } in zip' [0..1000000] [0..1000000]
23:36:29 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
23:36:37 <Axman6> zong_sharo: can't you just try what you suggested and see if it works?
23:36:38 <Cale> hmm, fast computer is fast :)
23:36:58 <c_wraith> cale, It only slows down as it produces more output
23:37:14 <c_wraith> it produces enough output to fill the mueval buffer before it slows down
23:37:15 <Cale> c_wraith: right, there's still the linear cost at the beginning though
23:37:28 <pedro3005> Hm, I'm more used to thinking in list comprehensions than recursion :/
23:37:35 <c_wraith> yeah, but 100k is nothing to count
23:37:43 <Cale> pedro3005: You should use the parallel list comprehension in that case
23:37:57 <Cale> zip xs ys = [(x,y) | x <- xs | y <- ys]
23:38:09 <Cale> But the semantics of those are defined in terms of zip :P
23:38:35 <pedro3005> hm yeah, silly to loop over indexes and not elements
23:40:08 <Cale> pedro3005: !! and length are both things which you always want to do your very best to avoid
23:40:14 <pedro3005> Cale, I tried that and it said  Illegal parallel list comprehension: use -XParallelListComp
23:40:16 <redd_> Using Data.Set always makes me want set comprehensions so bad. Too bad Data.Set doesn't form a monad.
23:40:28 <Cale> pedro3005: Then use that flag ;)
23:40:45 <Cale> pedro3005: Or add {-# LANGUAGE ParallelListComp #-} to the top of your file
23:41:00 <redd_> Put {-# LANGUAGE ParallelListComp #-} in the module header
23:41:04 <redd_> beat me to it
23:41:31 <Cale> redd_: It actually does form a monad, just not a monad on all of Hask.
23:41:44 <Cale> redd_: There are tricky ways to support restricted monads.
23:41:59 <Cale> http://hackage.haskell.org/package/rmonad
23:42:55 <redd_> Well Set is a monad, but Data.Set cannot be made a member of the monad type class, is what I meant.
23:43:59 <c_wraith> I suppose it works in cartesian products?
23:45:14 <redd_> Hmm, RMonad looks interesting. And puts data families to good use :)
23:46:00 <Cale> c_wraith: It's like the list monad, only it collapses duplicate elements of course, because they're sets.
23:46:32 <redd_> It's interesting that everyone wants list comprehensions (Python, Haskell), though, but nobody cares about set comprehensions, since it's so natural to everyone to express algorithms in such a notation.
23:47:39 <Cale> Well, sets are a bit different from a programming perspective, because a set datatype isn't quite the same thing as a mathematical set.
23:49:25 <redd_> I'm not sure what you mean by "programming perspective." Wouldn't a set ADT, ideally, implement the behavior of a mathematical set?
23:51:04 <Axman6> well, a mathematical set can hold things of any type no?
23:52:10 <Cale> redd_: Not really... determining if an element is a member of a mathematical set can be uncomputable
23:52:31 <Cale> Mathematical sets are really quite subtle things
23:53:37 <Cale> Our computational representation of finite sets is one which relies on having a computable total ordering on the element type to be efficient, or at least computable equality if not.
23:54:33 <Cale> In mathematics, we always assume that it's okay to ask if two things are equal or not -- it's a valid question regardless.
23:54:50 <Cale> But in programming, we need to back that comparison up with an actual mechanism.
23:56:05 <redd_> That makes sense. The element type requirse a total ordering (if the implementation does not use sequences) in order to support recursion or iteration over the elements of the set, also.
23:57:35 <Cale> I suppose this isn't the only issue -- the other issue is that we want to have values in our programming languages which aren't okay to compare, like functions.
