00:31:39 <dobblego> has any written a ExitCodeIsSillypackage?
00:34:48 <dobblego> @type \x y -> x >>= \x' -> if x' == mempty then return x' else y
00:34:49 <lambdabot> forall (m :: * -> *) a. (Monoid a, Eq a, Monad m) => m a -> m a -> m a
01:21:27 <Veinor> He's instantiating a list, traversing it twice! His decision problem yields int NAUGHTY | NICE. Santa Knuth is parsing, top-down.                                                                                                          
01:23:18 <Twey> Hahahaha
01:23:47 <lars9> @hoogle comparing
01:23:47 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:24:14 <Bynbo7> he knows when you've been dereferencing, he know when you mutate...
01:40:51 <jkff> Hi. I wonder what other uses are there for a static type system, except for correctness, performance and documentation? One "non-trivial" use is auto-deducible parts of the program, like in the case with type classes or Scala's implicits. Anything else?
01:42:05 <alpounet> you cover quite much with "correctness, performance and documentation" already
01:42:42 <jkff> I understand, but I think that the "type-classes" argument is quite compelling, and I think other compelling arguments also exist
01:43:41 <jkff> Type systems also allow to enforce abstraction sometimes (for example by not exporting implementation details). I think this falls in neither of the aforementioned categories
01:44:30 <jkff> Another use is IDE support, quite near to the "type classes" argument - parts of the program are auto-deducible, but not by the compiler but by the IDE
01:49:24 <lars9> @hoogle mzero
01:49:24 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
01:53:22 <kmc> yeah, we can define behaviors by inspecting the structure of types
01:53:39 <kmc> which relates to type classes and also generic programming
01:55:02 <kmc> another (somewhat degenerate) use of a static type system is interfacing to another static type system
01:55:18 <kmc> for example, I can turn a Haskell type definition into an XML schema or vice versa
01:55:44 <kmc> you can define serialization formats, display formats, GUIs, etc. by defining types
01:56:11 <kmc> database schemata etc
01:56:29 <Saizan_> pretty syntax for your de-brujin terms!
01:56:33 <kmc> of course there are plenty of ORMs in languages typically considered dynamically typed
01:57:29 <kmc> but they might do processing at the time a class is defined, which is another "static" point
01:59:34 <jkff> kmc: Indeed, static means for inspecting the structure of types are a valid example
02:00:05 <jkff> (sorry, need to go, but will read the chatlog later)
02:01:44 <lars9> @instances MonadPlus
02:01:44 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
02:03:23 <lars9> @hoogle msum
02:03:23 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
02:03:23 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
02:48:00 <kstt> Hi ! 
02:50:27 <kstt> I'm about to begin a quiet long journey in train, traversing france from end to end. Snow is covering the land, and the train will probably be delayed. Because every event is also an opportunity, I'll take this one to learn Iteratees.
02:51:16 <kstt> I've distantly followed their recent popularity, and as I understand them, they are now provided in several diffrent packages, with various approaches. 
02:51:47 <kstt> The one that I'd like to start with in enumerator. So I'm looking for reading recommandation.
02:53:00 <kstt> It's better if I it is less than 20 pages so I can print it. I found John Lato paper in the Monad Reader #16, what do you think of it as a start ?
02:59:55 <kstt> while this paper looks well written, it seems to target an other package, that brings a lot more that the most basic concept of iteratees.
03:46:24 <monadic_kid> it's such a shame that ghci crashes quite easily under leksah
04:00:00 <dobblego> is there a filter for Maybe?
04:00:11 <dobblego> @hoogle (a -> Bool) -> Maybe a -> Maybe a
04:00:11 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:00:11 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
04:00:11 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
04:08:54 <monadic_kid> dobblego: to filter all Nothings?
04:09:09 <monadic_kid> dobblego: to filter all Justs
04:10:13 <luite> dobblego: perhaps you mean catMaybes ? (or possibly mapMaybe), both in Data.Maybe
04:11:13 <monadic_kid> :t Data.Maybe.isJust
04:11:14 <lambdabot> forall a. Maybe a -> Bool
04:11:20 <monadic_kid> :t filter Data.Maybe.isJust
04:11:21 <lambdabot> forall a. [Maybe a] -> [Maybe a]
04:11:51 <monadic_kid> > filter Data.Maybe.isJust [Just 1, Just 2, Nothing, Nothing, Just 4]
04:11:52 <lambdabot>   [Just 1,Just 2,Just 4]
04:12:35 <ClaudiusMaximus> :t \f -> listToMaybe . filter f . maybeToList
04:12:36 <lambdabot> forall a. (a -> Bool) -> Maybe a -> Maybe a
04:32:20 <michie1> hey, I've got a question that may seem a little argumentative and trollish, so I apologise beforehand.  Apart from a abstraction, Monads are presented as an abstraction, much likes object-oriented programming, that can hide implementation details and make changing fundamentals at a later date much easier.
04:33:03 <michie1> Can anyone give a concrete example of that?  I've seen a program in the IO monad turned into one with rudementary profiling using a monad combinator, but that felt a bit contrived.
04:33:43 <ezyang> michie1: Probably the easiest way to see this is when you add a nother transformer to a monad transformer stack. 
04:34:03 <companion_cube> well, you can use list monad for some kind of backtracking, and later change to a monad less naive
04:35:17 <michie1> hmm
04:36:24 <michie1> I don't know ... it's like I can easily see the advantages for complicated pieces of code, but for the kind of dull, everyday programming most people do for a living, it's not at all obvious.
04:38:15 <Boxo> The bery fact that monad combinators exist and are useful is one example. Like
04:38:20 <Boxo> @src sequence
04:38:21 <lambdabot> sequence []     = return []
04:38:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:38:21 <lambdabot> --OR
04:38:21 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
04:38:31 <alpounet> michie1, for everyday use, well, you have the Maybe monad for example
04:38:40 <Boxo> That's a generic monad combinator that everyone uses all the time
04:39:02 <companion_cube> :t sequence
04:39:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:41:43 <michie1> hmhm
04:45:05 <lysgaard> Does there exist some sort of two way Data.Map, where i can lookup both the keys and the values?
04:46:36 <lysgaard> Wold be like two Data.Set types with a one to one mapping between.
04:46:52 <JuanDaugherty> "everyone uses all the time"
04:53:10 <ndm> lysgaard: http://hackage.haskell.org/package/bimap/
04:53:49 <Twey> (A.K.A. two maps stuck together :þ)
04:54:00 <silbo_> ou yea, good morning
04:54:37 <silbo_> what do you mean by stuck together
04:57:34 <silbo_> if I have a data like data Color = Red | Geen how do I construct a Green
04:57:42 <Twey> silbo_: Green
04:57:46 <Twey> Er
04:57:51 <Twey> Dam
04:57:52 <Twey> n
04:58:06 <Twey> Trick question — you don't, since there is no ‘Green’.  There's a ‘Geen’ though.  Fooled me!
04:58:11 <silbo_> it tells me Undefined data constructor "Green"
04:58:35 <Twey> silbo_: That would be because you wrote ‘Geen’ instead
04:58:51 <silbo_> no I wrote just Green
04:58:56 <Twey> 12:57:07 < silbo_> if I have a data like data Color = Red | Geen how do I construct a Green
04:59:00 <Twey> ‘Geen’.
04:59:02 <lysgaard> ndm: Spot on!
04:59:37 <silbo_> sorry it was data Color = Red | Green
04:59:45 <Twey> Then ‘Green’
04:59:51 <silbo_> ok ill try
05:00:53 <silbo_> Syntax error in expression (unexpected backquote)
05:01:14 <silbo_> how do i get the frontquote or something
05:02:37 <silbo_> when I tried your quotes, it says Unrecognised character
05:03:16 <Boxo> just
05:03:17 <Boxo> Green
05:03:19 <Boxo> no quotes
05:05:13 <silbo_> ok found the error 
05:05:13 <silbo_> thx
05:12:38 <Phantom_Hoover> How do you indicate typeclasses in data declarations?
05:13:22 <aristid> Phantom_Hoover: why do you want to?
05:14:01 <aristid> data Foo a => Bar a = B a, iirc, but that is usually not necessary to do at all
05:14:12 <Phantom_Hoover> How is Complex done, then?
05:14:40 <twanvl> you shouldn't do that
05:14:57 <twanvl> instead, add the typeclass constraint to all functions that use the datatype
05:15:18 <aristid> Phantom_Hoover: it is done like that, but it's not necessary even for Complex.
05:15:41 <monadic_kid> Phantom_Hoover: best to avoid doing it, because it forces you to use constraint on every polymorphic function when only a few operations really need it
05:16:53 <twanvl> For example, the current Complex type makes it impossible to use "Complex Integer", even though that does make sense in some situations
05:18:15 <monadic_kid> he/she disconnected
05:18:43 <aristid> twanvl: uh, which situations?
05:24:52 <waterlaz> is there actually any open source web applications written in haskell?
05:31:28 <monadic_kid> this looks like an interesting question: http://stackoverflow.com/questions/4482987/how-about-haskells-gc-performance-for-realtime-games
05:38:36 <burp> hm, anyone has a hint for me with attoparsec? manyTill anyWord8 (AP.try $ choice [string (BS.pack "http://"), string (BS.pack "https://")])       url <- AP.takeTill isSpace_w8
05:38:55 <burp> now I'd like to return something like "http://" `append` url or "https://" `append` url
05:39:05 <burp> depending whether https or https was found
05:39:21 <burp> with this I'd like to catch all http and https urls in a string
05:41:51 <burp> or I split by spaces first, and then run the parser for each part
05:45:02 <burp> :t (*>)
05:45:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
05:47:36 <alpounet> @tell monadic_kid the gc for RT games question has been explored here : http://www.haskell.org/pipermail/haskell-cafe/2010-February/thread.html#73881 (the thread started by Luke Palmer)
05:47:36 <lambdabot> Consider it noted.
06:09:27 <Boxo> @src (*>)
06:09:27 <lambdabot> (*>) = liftA2 (const id)
06:11:41 <aristid> :t liftM2 (const id)
06:11:41 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => m a1 -> m a -> m a
06:11:52 <aristid> :t (>>)
06:11:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:12:26 <aristid> :t \a b -> a >>= const b
06:12:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:12:31 <aristid> @pl \a b -> a >>= const b
06:12:31 <lambdabot> (. const) . (>>=)
06:27:40 <SEcki> @pl \a -> (a `mod` 2) == 0
06:27:40 <lambdabot> (0 ==) . (`mod` 2)
06:28:01 <SEcki> @pl \a b-> (a `mod` b) == 0
06:28:01 <lambdabot> flip flip 0 . ((==) .) . mod
06:28:25 <hpc> O.O "flip flip 0"
06:28:32 <hpc> :t flip flip 0
06:28:32 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num a) => f (a -> b) -> f b
06:28:40 <Boxo> :t 0
06:28:41 <lambdabot> forall t. (Num t) => t
06:29:41 <olsner> since lambdabot has a Num instance for every type, that could just as well say forall t. t :)
06:30:00 <Boxo> :t flip 0
06:30:00 <lambdabot> forall (f :: * -> *) a b. (Num (f (a -> b)), Functor f) => a -> f b
06:31:27 <blenderer> is there a defacto standard web dev framework in haskell?
06:31:40 <companion_cube> happstack ?
06:33:24 <hpc> olsner: /every/ type?
06:33:36 <hpc> > 0 :: ()
06:33:36 <lambdabot>   No instance for (GHC.Num.Num ())
06:33:37 <lambdabot>    arising from the literal `0' at <intera...
06:34:05 <mauke> > () :: 0
06:34:06 <lambdabot>   Only unit numeric type pattern is valid
06:34:13 <mauke> > () :: 1
06:34:14 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
06:34:14 <lambdabot>         against inferred t...
06:34:24 <hpc> wtf
06:34:30 <hpc> > 1 :: 1
06:34:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
06:34:30 <lambdabot>    arising from the literal...
06:34:46 <blenderer> companion_cube: any other not so defacto ones? There was some buzz about yesod recently I think..
06:35:08 <olsner> o.O you seem to be confusing types and values there
06:35:09 <companion_cube> maybe, i'm not a specialist at all
06:36:29 <hpc> > Unit :: 1
06:36:30 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
06:36:30 <lambdabot>    arising from a use of ...
06:36:41 <alpounet> blenderer, i guess you have seen yesod, snap etc
06:36:41 <hpc> :t (Unit :: 1)
06:36:42 <lambdabot> Unit
06:36:45 <hpc> aha!
06:37:28 <olsner> hpc: ok, maybe not *every* type... but I'm sure it can be arranged! just figure out the full set of types imported in lambdabot, find the ones that are missing Num instances, implement
06:37:45 <hpc> olsner: haha, that would be hilarious
06:39:41 * hackagebot blaze-html 0.3.0.4 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.3.0.4 (JasperVanDerJeugt)
06:41:57 <hpc> blaze looks exactly like what i was trying to do ^^
06:42:26 <Bynbo7> what were you trying to do?
06:42:42 <Cin> Any Haskellers in Frankfurt?
06:43:01 <hpc> Bynbo7: write the shortest website i could
06:43:53 <Bynbo7> html $ head >> body $ "Hello, world!"
06:43:54 <Bynbo7> ?
06:44:40 <hpc> Bynbo7: short but /useful/ ;)
06:44:51 <Bynbo7> that is useful, and happy as well!
06:45:00 <hpc> i ended up with very similar style to blaze
06:45:33 <Cin> In BlazeHtml + CGI:
06:45:34 <Cin> main = runCGI . outputFPS . renderHtml $ html $ body $ p "What's up?"
06:46:14 <Cin> (And s/runcGI/runFastCGI for FastCGI version.)
06:46:33 <hpc> for my website, it's autoCGI $ do {response 200; header . h1 $ out "What's up?"}
06:46:52 <Bynbo7> out?
06:46:52 <hpc> a few more steps, but i have more control over output
06:46:59 <hpc> out = liftIO putStrLn
06:47:07 <hpc> er, liftIO . putStrLn
06:47:35 <Bynbo7> oh, does CGI use stdout
06:47:42 <hpc> yes
06:47:48 * Bynbo7 hasn't ever used CGI directly
06:47:53 <hpc> autoCGI reads in cookies, env, form, connects to the database, checks if a user is logged in, etc
06:47:56 <Bynbo7> i had no idea it was so basic :)
06:48:16 <hpc> Bynbo7: GET is parsed in from env, POST is read from stdin
06:48:19 <Cin> Sure, you output the HTTP headers and content. It's literally outputting a HTTP response.
06:48:25 <hpc> output is stdout
06:48:35 <Bynbo7> how interesting
06:49:32 <hpc> i have a few other combinators, to require the "root user" (me), require https, etc
06:50:18 <hpc> plus blaze-like html functions, and surprisingly little hdbc wrapping
06:50:49 <hpc> the visible end result is http://faidio.visuallycreated.com:8000/blog/
06:52:11 <hpc> the individual scripts run in negligible time, and compiling the site takes about a minute
06:53:09 <hpc> unfortunately, all that compilation means that tiny site is 90Mb
07:06:49 * hackagebot hoogle 4.1.2 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.1.2 (NeilMitchell)
07:34:43 <unkanon> whose theory was it that the chat here starts at 10:30 EST? or should it only work for weekdays? :)
07:35:22 <aristid> unkanon: if it was a scientific theory, it would use UTC. therefore, it should not be taken seriously.
07:37:27 <unkanon> well the chat indeed was right on time every day
07:59:38 <wornof> Why does 'let func q w = (>) q w' work fine, making func behave exactly like >, but 'let func = (>)' doesn't work
08:01:05 <medfly> the second works for me
08:01:25 <medfly> oh
08:01:34 <wornof> I get the wrong type
08:02:04 <wornof> func :: () -> () -> Bool   but   (>) :: (Ord a) => a -> a -> Bool
08:02:23 <kosmikus> monomorphism restriction
08:02:59 <Nakilon> vingardia leviossum
08:03:17 <Botje> levio-SAH!
08:04:19 <wornof> kosmikus: Okay, thank you
08:04:35 <Martty> avada haskellabra
08:06:26 <nus> @. elite quote
08:06:26 <lambdabot> [31D1] S4Yz: LINuX Is NICe UNDEr xM0nAD
08:06:35 <nus> heh
08:06:39 <nus> @quote
08:06:39 <lambdabot> ilyas says: Haskell is a language where you start reading up on random abstract algebra before you feel ready to implement a simple bayesian network app.
08:06:46 <nus> @quote
08:06:46 <lambdabot> EdLin says: there's ##windows, but it's more of a support group than a support channel.
08:07:16 <nus> @quote windows
08:07:16 <lambdabot> windows says: Keyboard doesn't found. To rescan - press any key
08:07:21 <nus> @quote windows
08:07:21 <lambdabot> windows says: Keyboard doesn't found. To rescan - press any key
08:07:32 <nus> @quote channel
08:07:32 <lambdabot> chessguy says: [in regards to #haskell] man, it's amazing the difference between what happens when someone asks for help here, and what happens when they ask for help in another language channel
08:07:47 <nus> @quote network
08:07:47 <lambdabot> ilyas says: Haskell is a language where you start reading up on random abstract algebra before you feel ready to implement a simple bayesian network app.
08:08:30 <nus> hmm, smells quote caching
08:08:34 <nus> @quote network
08:08:34 <lambdabot> ddarius says: releases network version 127.0.0.1
08:08:39 <nus> @quote network
08:08:39 <lambdabot> ilyas says: Haskell is a language where you start reading up on random abstract algebra before you feel ready to implement a simple bayesian network app.
08:08:47 <nus> @quote release
08:08:47 <lambdabot> bd_ says: [SamB_XP] what is this "release" thing anyway? [bd_] SamB_XP: it's when you disown a project [SamB_XP] bd_: why would I want to do that? [bd_] Well, for example, in case of death.
08:09:39 <nus> and some quotes apparently lack context
08:09:58 <nus> @quotes ccc
08:09:58 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
08:10:04 <nus> @quotes ccc
08:10:04 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
08:10:31 <nus> @quotes ism
08:10:31 <lambdabot> wchogg says: We don't say "moan-oid" or "moan-o-morphism" or any other such silliness.
08:11:09 <nus> @quote arency
08:11:09 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
08:11:24 <nus> @quote arency
08:11:24 <lambdabot> Berengal says: I just can't get over how awesome it [referential transparency] is. I feel like instituting a holiday or something...
08:11:35 <nus> @quote ncy
08:11:35 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
08:11:44 <nus> @quote concur
08:11:44 <lambdabot> pkhuong says: [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
08:12:12 <nus> @quote pkhuong
08:12:12 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
08:12:23 <nus> @quote pkhuong
08:12:23 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
08:12:32 <nus> @quote augustss 
08:12:33 <lambdabot> augustss says: Haskell already has enterprise monads; there is a fail method.
08:12:36 <nus> @quote augustss 
08:12:36 <lambdabot> augustss says: ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
08:14:22 <nus> @quote nixos
08:14:22 <lambdabot> No quotes match. I am sorry.
08:14:42 <wunki> I'm getting errors when trying to update TexMath, ByteString etc. on MacOSX (Haskell Platform)
08:14:58 <nus> be more specific?
08:14:58 <wunki> is the GHC version of the platform outdated?
08:15:32 <nus> @lastlog osx
08:15:32 <lambdabot> Unknown command, try @list
08:15:36 <nus> err
08:15:53 <tonkman> hey, I have to parse a configuration from command line arguments, like -a 123 -b "asd"
08:15:58 <wunki> see: http://hpaste.org/42425/texmath_error
08:16:11 * hackagebot haddock 2.9.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.9.1 (DavidWaern)
08:16:23 <tonkman> and then deduce how program will act
08:17:08 <wunki> anyone know how to fik this error: http://hpaste.org/42425/texmath_error
08:17:49 <tonkman> should I use State monad for "saving" those options
08:20:26 <tonkman> and if arguments can have variable amount of values, with different types, how should I store them
08:20:48 <tonkman> make a datatype with all possible combinations?
08:22:50 <unkanon> tonkman: I can't help you but see this: http://leiffrenzel.de/papers/commandline-options-in-haskell.html
08:23:07 <tonkman> yeah, I have read that
08:23:41 <tonkman> my problem is variable arguments
08:23:57 <tonkman> its hard to store them
08:30:45 <monadic_kid> tonkman: how is it hard? you should know exactly what program options your program needs, a State monad isn't about "saving" anything. You probably just want a settings data type, and weather you want to changes those settings throughout the duration of the program or not will depend whether you could do wtih a state monad I mean state monads are best if you're doing a lot of stateful computations
08:30:45 <lambdabot> monadic_kid: You have 1 new message. '/msg lambdabot @messages' to read it.
08:31:53 <gustavderdrache> i'm a little bit confused about the behavior of cabal-install: it appears to completely ignore packages which have already been installed, whether through it or via apt-get
08:31:53 <lambdabot> gustavderdrache: You have 1 new message. '/msg lambdabot @messages' to read it.
08:32:31 <revenantphx> Good morning.
08:32:39 <monadic_kid> gustavderdrache: you have to specifiy your dependicies in your cabal file
08:33:28 <gustavderdrache> monadic_kid: oh, no, i meant in regards to pulling from Hackage (i.e., installing Yi)
08:33:44 <tonkman> Its hard to make a datatype for different type of values, when all those different type of values are parsed from same source
08:33:47 <monadic_kid> gustavderdrache: did you try "ghc pkg list"
08:33:47 <gustavderdrache> i keep getting a build failure, but cabal goes through all of the dependencies
08:34:02 <monadic_kid> gustavderdrache: what was the error message
08:34:26 <tonkman> for example, ["-d","abc","-e","123","-R"]
08:34:33 <gustavderdrache> hold on, i'll put it up on a pastebin
08:34:55 <monadic_kid> tonkman: are talking about parsing or just storing values?
08:35:02 <tonkman> both
08:35:22 <tonkman> parsing from argumentlist, and then storing data
08:35:30 <gustavderdrache> monadic_kid: http://paste2.org/p/1150978
08:36:04 <gustavderdrache> monadic_kid: doing a ghc-pkg list shows the apt-get'ed packages just fine
08:36:06 <revenantphx> :t (<*)
08:36:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:36:11 <revenantphx> :t (*>)
08:36:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:36:17 <gustavderdrache> so i'm at a loss to explain why cabal would ignore them
08:36:42 <monadic_kid> gustavderdrache: that error message doesn't say anything about not finding packages
08:36:57 <gustavderdrache> monadic_kid: i don't get any about not finding packges
08:37:09 <gustavderdrache> cabal just goes about its merry way
08:37:23 <nus> wunki: texmath doesn't list bytestrings as a direct dependency. Try this: cabal upgrade  texmath --constraint="bytestring < 0.9.1.8" 
08:37:30 <gustavderdrache> does it matter if i'm doing a user installation, and these are available at the system level?
08:37:55 <wunki> nus: I just removed .cabal and .ghc directory and installed it freshly. Now it seems to be working.
08:38:22 <nus> that's... brutal (-:
08:38:40 <revenantphx> @hoogle ($!)
08:38:40 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
08:39:01 <wunki> desperate times ask for desperate measures :)
08:39:08 <monadic_kid> gustavderdrache: the problem I see is you're buildling a package that fails because it didn't list what ghc extensions it uses, check the cabal file, i'd also look at the depends list for dependencies and versions it's asking for
08:40:03 <gustavderdrache> monadic_kid: okay, that should solve the bigger problem
08:40:16 <gustavderdrache> but it's still annoying that cabal goes and installs every dependency without checking that it exists
08:40:42 <monadic_kid> gustavderdrache: you didn't show me that message, and it suppose to check before installing
08:40:51 <gustavderdrache> there isn't a message :/
08:41:33 <monadic_kid> gustavderdrache: then the problem probably isn't to do with dependency checking, unless the cabal file just says for each package use any version
08:42:04 <monadic_kid> tonkman: the simplest thing I would do is store map of strings (keyword, value), then the client of the library can do the parse of the values to various types
08:42:17 <monadic_kid> tonkman: or you don't make it general
08:42:42 <monadic_kid> tonkman: don't make it hard for yourself
08:43:19 <monadic_kid> gustavderdrache: which package is it? I'll have a look
08:43:33 <gustavderdrache> it's yi (0.6.something)
08:43:49 <tonkman> I think Im going to write a big Options data type
08:44:26 <gustavderdrache> monadic_kid: http://paste2.org/p/1150988 
08:44:40 <gustavderdrache> but no matter what i do, 'cabal install yi' will go and build gtk
08:46:25 <monadic_kid> tonkman: why not use http://users.skynet.be/jyp/html/base/System-Console-GetOpt.html
08:46:34 <monadic_kid> tonkman: I've used it before
08:47:24 <tonkman> I wrote my own, for a practice
08:47:29 <tonkman> *write
08:48:55 <monadic_kid> gustavderdrache: which version of ghc are you using?
08:49:12 <gustavderdrache> monadic_kid: 6.12.1
08:49:13 <nus> gustavderdrache: have you looked at -g option of cabal install?
08:49:34 <gustavderdrache> nus: actually, no
08:49:36 <gustavderdrache> nus: what does it do?
08:50:17 <gustavderdrache> nus: oh, never mind, it's right there in the --help output
08:50:29 <monadic_kid> gustavderdrache: well it doesn't list any extensions it uses in the cabal file, then that probably means that particular file that is being compiled doesn't have extensions defined in the file
08:50:32 <nus> gustavderdrache: err, s/-g/--global/ I mean
08:51:20 <gustavderdrache> nus: i'd almost like to avoid that, so as to avoid stepping on apt-get's toes
08:51:52 <monadic_kid> gustavderdrache: trying adding in the cabal file: extensions: TypeSynonymInstances
08:52:04 <monadic_kid> extensions: TypeSynonymInstances
08:52:25 <gustavderdrache> monadic_kid: does that go into the Library: field?
08:52:34 <gustavderdrache> i'm new to cabal
08:52:58 <monadic_kid> gustavderdrache: ah yeah it goes in library section
08:53:23 <monadic_kid> gustavderdrache: I'm gonna try this myself now
08:53:30 <gustavderdrache> monadic_kid: okay, thanks
08:54:18 <gustavderdrache> ah-ha, it installed
08:56:03 <monadic_kid> gustavderdrache: did that fix it?
08:56:10 <monadic_kid> gustavderdrache: adding the extensions field
08:56:13 <gustavderdrache> monadic_kid: it let derive install
08:56:24 <gustavderdrache> monadic_kid: but cabal is now going and installing a different version for some reason
08:57:08 <monadic_kid> gustavderdrache: are using cabal install to get this?
08:57:12 <gustavderdrache> yep
08:57:26 <gustavderdrache> i did a 'cabal unpack derive'
08:57:50 <nus> gustavderdrache:  what does cabal info gtk|grep 'Latest version installed:' say?
08:58:15 <gustavderdrache> 0.11.0
09:01:02 <nus> gustavderdrache: hmm, yi deps on 'gtk ==0.11.*', weird. Oh, so you've already installed gtk as a user?
09:01:15 <gustavderdrache> nus: yeah, and i also pulled it from apt-get
09:01:21 <gustavderdrache> so it's available at both the system and user level
09:01:49 <monadic_kid> cabal is installing gtk 0.11.2 for me
09:03:43 <arcatan> blarg. i want to do a HTTP post request with basic authentication.
09:04:24 <nus> gustavderdrache: ah, so it wants the latest version available, right. Well, you could pass a constraint to cabal install
09:05:05 <monadic_kid> gustavderdrache: have you done "cabal update" recently?
09:05:13 <gustavderdrache> monadic_kid: just yesterday afternoon
09:05:30 <gustavderdrache> monadic_kid: doing another one right now, though :)
09:05:51 <monadic_kid> gustavderdrache: lets see if it finishes for me and then see if you need to add a depends constraint like nus is saying
09:05:57 <gustavderdrache> okay
09:09:50 <monadic_kid> now i need to fix cabal file for derive
09:10:36 <nus> gustavderdrache: let me get this straigt, if you want cabal (at its current version) to stick to versions you've installed globally through apt-get, that won't happen unless you maintain a list of constraints you always pass to cabal upgrade.
09:10:56 <gustavderdrache> nus: ouch
09:11:15 <gustavderdrache> nus: but even so, cabal is downloading and installing version 0.11.0 of the various gtk libs
09:11:19 <gustavderdrache> which i already have
09:11:35 <gustavderdrache> and then it registers the packages
09:11:54 <gustavderdrache> but attempting to rebuild yi, it downloads all of the dependencies, ignoring their installed state
09:12:14 <nus> cabal's update plan is get whater latest version is available (within dependency constraints), apt-get OTOH may have some packages pinned/unavailable. 
09:12:25 <nus> s/whater/whatever/
09:12:34 <ddarius> > 7.125 * pi
09:12:35 <lambdabot>   22.383847656827275
09:13:20 <monochrom> don't use "cabal upgrade"
09:13:36 <monochrom> of course "cabal update" is unrelated
09:13:46 <monochrom> yay for meaningful identifiers
09:13:49 <gustavderdrache> yeah, but i've never run a 'cabal upgrade' :/
09:14:02 <nus> rather choose one of apt-get or cabal to maintain haskell packages and stick to it
09:14:36 <hpc> apt-get is more stable, but extremely dated
09:14:52 <monochrom> indeed. see http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave for ways to con yourself
09:15:06 * hpc uses apt-get, then when he finds something it doesn't have, installs the latest tarball from hackage
09:15:31 <monochrom> that is the most harmful advice ever. see my url.
09:15:38 <hpc> oh
09:15:46 <gustavderdrache> oh boy
09:15:57 <gustavderdrache> is there a way to back out of all this?  i've used Ubuntu to install the haskell platform and xmonad...
09:16:14 <gustavderdrache> so most of the haskell packages in use on my system are from apt
09:16:36 <monochrom> it is okay if you do purely apt-get up to a certain point of time and then never do it.
09:16:43 <gustavderdrache> hmmmm
09:17:22 <monochrom> the harmful advice is harmful in implicitly suggesting you to interleave.
09:17:30 <gustavderdrache> ah
09:17:55 <gustavderdrache> i'm starting to prefer the Perl workaround here...
09:18:04 <gustavderdrache> i pine for local::lib in other languages
09:18:25 <nus> gustavderdrache: so, if you want do it the distribution way, each time you need a haskell package, you first repackage it for the distro
09:19:01 <gustavderdrache> do you know of a way to do that automatedly?
09:19:19 <gustavderdrache> or at least is there a command like, e.g., make-apt-package-from-this-cabal-file?
09:19:24 <nus> which distro is this?
09:19:36 <gustavderdrache> nus: Ubuntu 10.10
09:20:03 <gustavderdrache> the haskell wiki has this page http://pupeno.com/2006/12/12/the-lambda-revolution-v/ which is dead
09:21:36 <monadic_kid> gustavderdrache: well i couldn't get derive built, there was another problem with overlapping instances that i'm going to fix that
09:21:48 <monadic_kid> gustavderdrache: *i'm not going to fix that
09:21:48 <gustavderdrache> monadic_kid: okay
09:21:53 <gustavderdrache> yeah
09:22:36 <monadic_kid> gustavderdrache: try leksah or eclipse plugin instead :P
09:22:49 <gustavderdrache> monadic_kid: i'll stick with vim :)
09:22:59 <gustavderdrache> i was just curious about yi and wanted to play with it
09:23:10 <gustavderdrache> but it appears i have some cabal-related house keeping to do first
09:24:32 <unkanon> when I do runhaskell does it compile before running or does it interpret the file somehow? will it usually be slower than compiling?
09:25:03 <revenantphx> how does this look for a basic error handling system? 
09:25:03 <revenantphx> https://gist.github.com/747495
09:25:12 <revenantphx> (It's just Either)
09:25:47 <nus> gustavderdrache: http://wiki.debian.org/Haskell/CollabMaint/PackageTemplate
09:25:48 <revenantphx> I thought Fallible would be an understandable name, but if you have a more succinct idea, do tell.
09:26:28 <rndm> why isn't the second argument of onConnect evaluated? the intention looks like it should be setting up some kind of callback, but i don't see anything there to delay evaluation. http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html#PodMainGUI.hs:connectGui
09:26:49 <rndm> sorry, onClicked
09:27:33 * hackagebot heist 0.4.0.1 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.4.0.1 (GregoryCollins)
09:28:52 <ddarius> monochrom: Incidentally, with regards to the packaging problem it seems the solution is a) fix the packages that don't register correctly and b) only allow global packages to depend on other global packages, which makes sense to me.
09:29:30 <revenantphx> Gr. There's no IEEE754 for cereal?
09:30:38 <ddarius> revenantphx: I thought you wanted to do some low-level bit munging.  Now's your chance.
09:30:59 <revenantphx> I could also just change a few lines in Data.Binary.IEEE754 and republish it for Cereal.
09:31:20 <revenantphx> I wanted to do some bit twiddling last night... today I'm feeling higher level.
09:31:47 <revenantphx> tbh, the only thing that would have to change is the import.
09:32:38 <revenantphx> Or I could just use wordToFloat, wordToDouble
09:33:06 <Cndy> Why there is no qtHaskell ebuild in tree ?
09:33:31 <rndm> Cndy: wondered the same thing lastnight. ended up trying to use gtk2hs
09:34:08 <Cndy> mdm http://hpaste.org/42418/devhaskellqtqt114ebuild
09:34:19 <Cndy> rndm: *
09:34:54 <rndm> Cndy: thanks
09:36:07 <revenantphx> ddarius: Is my little Fallible type sufficient?
09:36:28 <revenantphx> Seems like it'd be good enough for any possible errors here, plus I can let the user do stuff with them.
09:36:36 <revenantphx> I need to get around to instancing Error for them.
09:37:15 <Eelis> @pl \(x,y,z)->[x,y,z]
09:37:15 <lambdabot> (line 1, column 6):
09:37:15 <lambdabot> unexpected ","
09:37:15 <lambdabot> expecting letter or digit, operator or ")"
09:37:15 <lambdabot> ambiguous use of a non associative operator
09:37:18 <Eelis> hmm
09:37:30 <Eelis> is there some nice off-the-shelf function that does this ^ ? or do i realy have to write it out.
09:37:45 <byorgey> edwinb: nope, you have to write it
09:37:51 <Eelis> ugh. ok, thanks
09:37:54 <byorgey> *Eeelis, rather
09:38:01 <Eelis> i figured :)
09:38:01 <byorgey> **Eelis
09:38:12 <byorgey> I kant typ today
09:38:31 <revenantphx> @hoogle (x,y,z) -> [x,y,z]
09:38:31 <lambdabot> Parse error:
09:38:31 <lambdabot>   --count=20 "(x,y,z) -> [x,y,z]"
09:38:32 <lambdabot>                           ^
09:38:37 <Boxo> @pl \(a,b,c,d,e) -> [a,b,c,d,e]
09:38:37 <lambdabot> (line 1, column 6):
09:38:37 <lambdabot> unexpected ","
09:38:38 <lambdabot> expecting letter or digit, operator or ")"
09:38:38 <lambdabot> ambiguous use of a non associative operator
09:38:57 <revenantphx> @hoogle (a,a,a) -> [a]
09:38:57 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
09:38:57 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
09:39:03 <revenantphx> guess not.
09:39:06 <remy_o> @pl \x -> \y -> \z -> [x,y,z]
09:39:07 <lambdabot> (. ((. return) . (:))) . (.) . (:)
09:39:34 <alpounet> much simpler yeah.
09:39:43 <Boxo> @pl \a b c d e f -> [a,b,c,d,e,f]
09:39:43 <lambdabot> (. ((. ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:))) . (.) . (.) . (.) . (:))) . (.) . (.) . (.) . (.) . (:)
09:40:50 <osfameron> much clearer
09:41:58 <mathstuf> hi, is there a way to get system information into cpp-options with cabal?
09:44:30 <ddarius> > repeat '*' ++ "Eelis"
09:44:31 <lambdabot>   "**************************************************************************...
09:46:11 <Eelis> maybe i'll sent Augustsson a patch to add conversions to list to his tuple package
09:46:15 <Eelis> *send
09:59:51 <byorgey> Eelis: why do you have 3-tuples?
10:11:41 * byorgey makes bacon-wrapped lambda with mango-apricot chutney
10:13:45 * augur eats byorgey's baconlambda
10:15:47 <newsham> byorgey's typeopedia and delicatessen.
10:15:59 <newsham> now serving specialty lambdas
10:22:27 <Eelis> byorgey: i have a record type for triangles in 3d space, and one of the fields contains the triangle's 3 vertices.
10:22:39 <ziman> @pl map nt = cata $ In . nt
10:22:39 <lambdabot> map = cata . (In .)
10:59:08 * hackagebot ssh 0.2.3 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.3 (AlexSuraci)
11:12:01 <mathstuf> why would this cause an ambiguous type error over the `Exception e' type in handle?
11:12:04 <mathstuf> pRead def str = handle (return . const def) (return $ read str)
11:13:17 <c_wraith> :t handle
11:13:17 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
11:13:33 <mathstuf> :t Contol.Exception.handle
11:13:34 <lambdabot> Couldn't find qualified module.
11:13:46 <mauke> Cont ol
11:13:57 <mathstuf> ah
11:13:59 <ndm> almost everything in exceptions causes an overloaded exception error
11:13:59 <mathstuf> :t Control.Exception.handle
11:14:00 <lambdabot> forall e a. (GHC.Exception.Exception e) => (e -> IO a) -> IO a -> IO a
11:14:16 <ndm> if you want to catch everythign you usually want to :: SomeException somewhere
11:14:32 <ndm> although don't do catching with read, use reads instead
11:14:38 <gwern> anyone familiar with the Gawker leak? what does a line like 'LaurenCoeus ::: NULL ::: NULL ::: gwern0@gmail.com' mean? (I want to say the first item is the username, except I've never used that name in my life; I'm not even female!)
11:14:40 <mauke> you should probably define a catchAll
11:14:49 <mauke> but yeah, not for read
11:14:58 <ndm> > reads "12"
11:14:58 <lambdabot>   []
11:15:07 <mathstuf> ah
11:15:11 <ndm> > reads "foo" :: [(Int,String)]
11:15:11 <lambdabot>   []
11:15:37 <mathstuf> the docs on "reads" isnt much help there
11:15:39 <mathstuf> "equivalent to readsPrec with a precedence of 0."
11:15:44 <ndm> > reads "12" :: [(Int,String)]
11:15:45 <lambdabot>   [(12,"")]
11:15:59 <ndm> if you get back [(x,"")] then read was successful
11:16:00 <mathstuf> ah, nvm, read readsPrec closer
11:16:04 <ndm> and x is the result
11:16:15 <ndm> if you don't, then there was a parse error
11:16:25 <mauke> mathstuf: readm :: (Read a) => String -> Maybe a; readm s = case reads s of [(x, "")] -> Just x; _ -> Nothing
11:16:56 <mathstuf> that looks better
11:16:59 <mathstuf> thanks
11:18:52 <Zao> gwern: I would say that some idiot fed in the wrong address.
11:19:19 <gwern> Zao: that's a rather precise and unusual wrong address though
11:19:42 <gwern> o.0 reset-password using gwern0@gmail.com works
11:19:54 <mathstuf> spammers?
11:20:06 <Zao> gwern: I get delivery notifications to a Mr. Zao in NYC for expensive watches.
11:20:12 <gwern> well, let's log in and se...
11:20:21 <gwern> Zao: sure but there are a couple million Zao aren't there?
11:21:22 <Zao> If I was a Zao, I'd double-check whether the email I gave fedex for tracking was in fact mine.
11:23:47 <gwern> ok, that's weird, this Lauren account is attributed some Scifi comments I rmember making
11:23:59 <gwern> perhaps my account got renamed or something...
11:27:14 <gwern> well, doesn't matter. I'm deletin that sucker
11:28:40 <revenantphx> I feel like parsec lacks facilities for reading fixed-size integers and such.
11:28:49 <revenantphx> attoparsec*
11:29:23 <revenantphx> in the end, integers are a large part of binary file formats.
11:29:38 <conal> I fiddled around with the point-free list builders that came up earlier (e.g., \a b c d e f -> [a,b,c,d,e,f]). Some nice structure emerged. http://hpaste.org/42426/toying_with_pointfree_list_con
11:30:05 <olsner> revenantphx: attoparsec is made for parsing text rather than binary file formats, I think
11:30:35 <revenantphx> Well, ...aimed particularly at dealing efficiently with network protocols and complicated text/binary file formats.
11:30:49 <revenantphx> It's great for text formats like xml or html it'd seem.
11:30:57 <revenantphx> But at that point, parsec would be fine too.
11:31:15 <olsner> you do have e.g. take :: Int -> Parser ByteString
11:31:23 <revenantphx> Sure.
11:31:37 <revenantphx> But there's no built in utilities for reading specific sized integers and such.
11:31:48 <revenantphx> You can use the ones out of Data.Binary/Serializable.Get of course.
11:32:16 <revenantphx> But that seems a tad silly sometimes.
11:32:48 <revenantphx> I guess I could put together a Data.Attoparsec.Integer module... that'd be fun to try to very low-level like.
11:32:53 <revenantphx> try to do*
11:39:40 <roconnor> heh, this delayed choice quantum eraser experiment is mind-blowing
11:41:18 <gwern> roconnor: is that the quantum free will one? or the quantum bomb tester?
11:41:39 <roconnor> I don't think it is either
11:44:09 <roconnor> gwern: they put a downconverter after a double slit experiment spliting the photons into two correleted pairs
11:44:36 <roconnor> gwern: on one side they run a standard double slit interference pattern
11:45:00 <roconnor> gwern: on the other side they run a long elaborate system of beam splitters and mirrors
11:45:23 <dobblego> luite, Data.Foldable.find does it
11:45:38 <dobblego> luite, i.e. filters Maybe
11:46:01 <roconnor> such that if the photon hits dector 3 it must have passed through slit A, if the photon hits dectector 4 it must have passed through slit B, and if it hit either detectors 1 or 2 you cannot tell which slit it when through.
11:47:01 <roconnor> gwern: then they count considences between the standard double slit expermient and the exaborate detector
11:47:01 <Zao> roconnor: Is it the quantum eraser experiment?
11:47:14 <roconnor> Zao: ya, the delayed choice quantum eraser
11:47:19 <Zao> roconnor: I recommend reading Motl's explanation of it.
11:47:20 <gwern> but what's the payoff or motivation to this whole setup?
11:47:27 <roconnor> Zao: oh, do you have a link.
11:47:32 <Zao> http://motls.blogspot.com/2010/11/delayed-choice-quantum-eraser.html
11:47:32 <roconnor> I was reading the wikipedia page
11:48:07 <roconnor> gwern: the optical path of the standard double slit experiment is shorter than the elaborate mirror setup
11:48:25 <Zao> He covers the experiments leading up to it for the first half, and the experiment itself for the second half.
11:49:00 <roconnor> so whether or not the elaborate setup detects which slit the photons passed through or not is determined "after" the double slit detector is hit.
11:50:22 <SEcki> @pl \f c b a -> f a b c
11:50:22 <lambdabot> flip . (flip .) . flip
11:50:43 <SEcki> @pl \f c a b -> f a b c
11:50:44 <lambdabot> flip . (flip .)
11:50:56 <conal> pretty
11:51:07 <conal> (flip .) (flip .)
11:51:18 <conal> (result flip) (result flip)
11:51:29 <hpc> result = flip (.)?
11:51:39 <hpc> :t flip flip
11:51:40 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
11:52:09 <conal> result = (.) ; argument = flip (.)
11:52:18 <conal> for the special case of functions.
11:52:36 <hpc> oh
11:52:40 <hpc> :t result
11:52:41 <lambdabot> Not in scope: `result'
11:52:55 <conal> @wiki DeepArrow
11:52:55 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
11:53:06 <conal> @hackage DeepArrow
11:53:06 <lambdabot> http://hackage.haskell.org/package/DeepArrow
11:54:16 <hpc> :t flip (.)
11:54:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
11:55:18 <hpc> :t fmap ($)
11:55:18 <conal> the function versions of result & argument and ~> are also in TypeCompose
11:55:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
11:55:26 <conal> @hackage TypeCompose
11:55:26 <lambdabot> http://hackage.haskell.org/package/TypeCompose
11:57:45 <revenantphx> Does anyone have some attoparsec/network exampels?
11:58:26 <ManateeLazyCat> revenantphx: IIRC, fastirc use attoparsec
11:58:32 <ManateeLazyCat> @package fastric
11:58:32 <lambdabot> http://hackage.haskell.org/package/fastric
11:58:42 <revenantphx> @hackage fastirc
11:58:42 <lambdabot> http://hackage.haskell.org/package/fastirc
11:58:47 <ManateeLazyCat> :)
11:59:18 <revenantphx> so it does.
11:59:45 <revenantphx> I need to learn <*>, <* and *>
11:59:52 <revenantphx> to google!
11:59:59 <mauke> <*> is ap
12:00:01 <revenantphx> @hoogle <*
12:00:01 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
12:00:01 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:00:01 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:00:02 <mauke> *> is >>
12:00:06 <xarch> try Applicative programming with effect
12:00:06 <revenantphx> oh, << and >>?
12:00:10 <xarch> s
12:00:13 <mauke> << doesn't exist
12:00:18 <ManateeLazyCat> revenantphx: I remember some command will give you how many package packages use attoparsec, ivanm know it.
12:00:26 <revenantphx> <* is like << if it existed.
12:00:27 <revenantphx> ?
12:00:28 <revenantphx> @list
12:00:28 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:00:34 <mauke> according to me, yes
12:00:40 <mauke> other people don't like that definition of <<
12:01:22 <mauke> @src (<*)
12:01:22 <lambdabot> (<*) = liftA2 const
12:01:30 <ManateeLazyCat> @time
12:01:31 <lambdabot> Local time for ManateeLazyCat is Mon Dec 20 04:01:07 2010
12:01:36 <revenantphx> @time
12:01:37 <lambdabot> Local time for revenantphx is 2010-12-19 15:01:10 -0500
12:01:47 <revenantphx> 0.o...
12:01:49 <mauke> @time mauke
12:01:52 <lambdabot> Local time for mauke is Pungenday, the 61st of The Aftermath in the YOLD 3176.
12:02:02 <revenantphx> :|
12:02:11 <ManateeLazyCat> @time doctor
12:02:20 <mauke> @time mauke
12:02:22 <lambdabot> Local time for mauke is Pungenday, the 61st of The Aftermath in the YOLD 3176.
12:02:26 <mauke> aww
12:02:33 <xarch> what?
12:02:44 <revenantphx> @localtime
12:02:45 <lambdabot> Local time for revenantphx is 2010-12-19 15:02:18 -0500
12:02:49 <revenantphx> @localtime-reply
12:02:49 <lambdabot> Plugin `localtime' failed with: Prelude.last: empty list
12:02:52 <ManateeLazyCat> I need save http://code.haskell.org/lambdabot/COMMANDS always forgot lambdabot command.
12:02:52 <pacak> @time
12:02:54 <lambdabot> Local time for pacak is Sun Dec 19 23:02:25 2010
12:02:59 <mauke> @time mauke
12:03:02 <lambdabot> Local time for mauke is just silly. I mean, has anyone really been far even as decided to use even go want to do look more like?
12:03:04 <revenantphx> @localtime-reply Hrp Hrp Drp
12:03:07 <revenantphx> @localtime
12:03:08 <lambdabot> Local time for revenantphx is 2010-12-19 15:02:41 -0500
12:03:14 <revenantphx> Well, that does nothing.
12:03:32 <revenantphx> @freshname
12:03:32 <lambdabot> Hadt
12:03:36 <revenantphx> @freshname
12:03:36 <lambdabot> Hadu
12:03:40 <revenantphx> @freshname
12:03:40 <lambdabot> Hadv
12:04:15 <mauke> @time idoru 
12:04:15 <lambdabot> Local time for idoru is :Sun Dec 19 20:03:50 2010
12:04:34 <ManateeLazyCat> @check 10 > 1
12:04:35 <lambdabot>   "OK, passed 500 tests."
12:04:49 <mauke> @check (> 1)
12:04:50 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
12:04:57 <mauke> @check (< 1)
12:04:58 <lambdabot>   "Falsifiable, after 3 tests:\n1\n"
12:06:03 <urv> Does the compiler assume that the monad laws are satisfied by any monad typeclass?
12:06:16 <dobblego> urv, yes
12:06:31 <xarch> @check \a b -> length a + length b == length (a ++ b)
12:06:32 <lambdabot>   "OK, passed 500 tests."
12:06:49 <urv> dobblego: why are those laws needed at all? In order to simplify expressions?
12:07:12 <dobblego> urv, otherwise the invariants of certain monadic functions are violated
12:07:36 <mauke> those laws define what a monad is
12:08:00 <nus> "if it ducks like a monad, and it..." (-:
12:08:07 <applicative> does it use the fact or would be fact that the monad laws are satisfied, or does it just work with >>= and >> as if they were any old functions?
12:08:35 <urv> mauke: yes but why must it be a monad at all? why isn't it enough to just have a bind operator? 
12:09:07 <urv> what are the monad laws good for?
12:09:11 <mauke> urv: huh?
12:09:17 <mauke> things don't have to be monads
12:09:29 <applicative> there's nothing wrong with not being a monad. 
12:09:37 <Philippa> the monad laws are good for making sure code doesn't make you go WTF when you find out what it's doing
12:09:42 <mreh> you say that because you are applicative
12:09:49 <applicative> ZipLists cant make a monad.
12:09:59 <applicative> but they're applicative, what's wrong with that?
12:10:13 <mauke> applicative: no, YOU are applicative
12:10:13 <mreh> i dunno... APPLICATIVE!
12:10:21 <mreh> heh
12:10:34 <applicative> i was going to say, I'm no monad, nothing wrong with that...
12:12:16 <applicative> What do we call the sort of thing that is a functor or monad in haskell?  I mean like Maybe or Either String or whatever.  It seems wrong to call it a type simply
12:12:34 <mauke> type constructor?
12:12:38 <applicative> A general type construction?
12:12:50 <urv> I still don't get it. I mean why is it a good thing to have a monadic structure?
12:13:05 <mauke> urv: why do you think it's a good thing?
12:13:49 <applicative> urv, it isnt good or bad, but some general type constructions do form a monad 
12:13:52 <urv> mauke: i don't 
12:14:01 <mauke> urv: then your question makes no sense
12:14:20 <copumpkin> urv: it's a common pattern that we notice and declare when we see it
12:14:20 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
12:14:22 <copumpkin> that's about it
12:14:52 <applicative> urv, does it seem good that some 'general type constructions' like Maybe ... or [...] are functors, ie. satisfy the functor laws with some definition of fmap?  
12:14:52 <copumpkin> it's only as good as you consider factoring repeated code out, if you use those aspects of the repeated code
12:16:03 * applicative thinks this is surprisingly deflationary for someone going by the name of copumpkin
12:16:22 <urv> i am just wondering if the compiler uses those laws in order to change expressions
12:16:22 <revenantphx> Goddamit.
12:16:25 <revenantphx> there we go.
12:16:59 <urv> or is it only a common pattern thing
12:17:06 <kmc> urv, no Haskell compiler does so at present, to my knowledge
12:17:12 <kmc> you can write custom rewrite rules in GHC
12:17:17 <kmc> but i don't think there are any about the monad rules
12:17:22 <revenantphx> There we go, un-klined
12:17:28 <kmc> most monadic code is in a *particular* monad, not generic
12:17:29 <applicative> that's what I was asking.  of course you can write a RULE
12:17:36 <kmc> and so there might be a list RULE or an IO RULE or a Parsec RULE that fires
12:18:12 <applicative> but there are obvious rules about like fmap f . fmap g = fmap (f.g) 
12:18:14 <kmc> for lists the right-identity rule is just:  concatMap (\x -> [x]) xs = xs
12:18:22 <kmc> which is kidna silly
12:18:34 <kmc> yeah, i would be very surprised if (<<) were not equal to flip (>>).  but (<*) is not flip (*>)
12:18:45 <kmc> (<*) and (*>) both perform "effects" in the same order
12:18:46 <urv> kmc: so those laws are only good for the coder?
12:19:31 <kmc> urv, they're mostly important if you're defining a monad in a library you expect other people to use
12:19:35 <Philippa> including coders who write functions that are polymorphic in the monad they run in, yes
12:19:54 <urv> ok i see
12:19:54 <Philippa> for example, return shouldn't have side-effects
12:19:55 <kmc> your users will be very surprised if they find that do { m } ≠ do { x <- m; return x }
12:20:10 <urv> no i got it 
12:20:12 <urv> thanks a lot
12:20:18 <urv> now 
12:20:34 <Philippa> yeah, or that the associativity rules don't apply
12:20:56 <kmc> yeah, your users will be very surprised if ((a >> b) >> c) ≠ (a >> (b >> c))
12:21:24 <Philippa> (there's a certain amount of handwaving that's sometimes accepted for things that're monads modulo termination, for example, but even that handwaving follows a certain kind of rule, too)
12:21:41 <urv> I just wondered if those laws were used internaly ... but now i understand - thanks a lot
12:21:59 <kmc> yeah there's "monad modulo ⊥" and "monad modulo output ordering"
12:22:01 <Philippa> hypothetically they can be, they just aren't currently
12:22:12 <kmc> the worst is the ST "monad transformer" on hackage
12:23:12 <kmc> urv, compilers are free to do many things that aren't mentioned in the Haskell standard, as long as they don't conflict with what the standard says
12:23:30 <mauke> class Stream s a | s -> a; instance (Stream s a) => Stream (Counted s) a
12:23:34 <urv> kmc: i see
12:23:36 <mauke> why does this require undecidable instances?
12:23:50 <kmc> mauke, it doesn't without the fundep?
12:23:57 <applicative> urv, the ghc has its own way of implementing IO and obviously lists, so there's no doubt much use of the laws that make them functors or monads in the typesystem.
12:24:11 <nostrand> i want to convert an integer to a Bytestring, like show, but for ByteStrings. is there a good way?
12:24:16 <mauke> kmc: huh?
12:24:26 <mauke> nostrand: B.pack . show
12:24:27 <kmc> nostrand, makes no sense.  ByteString stores bytes, not characters
12:24:39 <kmc> ByteString.Char8 is a wretched hack
12:25:01 <kmc> you should convert your integer to Data.Text and then use the desired Unicode encoding to turn those characters into bytes
12:25:28 <nostrand> mauke: doesn't that make an unneccessary list?
12:25:32 <Eelis> hm, is there no binding for clock_gettime yet?
12:25:55 <kmc> mauke, http://haskell.org/ghc/docs/7.0-latest/html/users_guide/type-class-extensions.html#instance-rules
12:26:11 <nostrand> kmc: i want i.e "1223" but as a ByteString, why doesn't that make sense?
12:26:23 <kmc> because '1' is a character
12:26:24 <kmc> not a byte
12:26:29 <mauke> nostrand: e.g., not i.e.
12:26:30 <kmc> ByteString stores bytes, not characters
12:26:38 <nostrand> mauke: ah, thanks =)
12:27:09 <urv> thnx guys - helped me a lot! 
12:28:30 <kmc> there are more than 256 characters in use by all the writing systems of the world
12:28:40 <kmc> so clearly one can't represent characters by bytes in a 1:1 fashion
12:29:04 <kmc> so there are several different ways to encode a string of characters as a string of bytes
12:29:15 <kmc> and no, they don't all agree on which string of bytes corresponds to the string of characters "1223"
12:29:21 <Eelis> ah, the bindings-posix package has clock_gettime. excellent!
12:29:43 <mauke> do I understand this right? if I were to introduce a phantom type parameter in Counted and write instance (Stream s a) => Stream (Counted s a) a, then the coverage condition would be satisfied?
12:29:45 <kmc> :D is that just "stuff missing from the unix package"?
12:29:51 <Eelis> kmc: looks like it :)
12:29:59 <Saizan_> mauke: yep
12:30:07 <nostrand> kmc: ah. Might as well use a Vector of ints =). But ByteString has a nice sort and stuff =).
12:30:19 <kmc> Data.Text doesn't?
12:30:27 <nostrand> i dont' know
12:30:37 <mauke> this angers and confuses me
12:31:06 <Saizan_> mauke: it's known to be a quite strict condition
12:31:28 <kmc> nostrand, i mean you can ask "how do I show an Int using Arabic numerals encoded as ASCII / Latin-1 / UTF-8"
12:31:39 <kmc> that's a sensible question with a sensible answer
12:32:11 <Saizan_> heuristics to ensure termination aren't always nice
12:32:24 <kmc> yeah, don't fear the UndecidableInstances
12:32:27 <nostrand> kmc: yeah, but i thought anyone would assume i meant roman numerals
12:32:41 <kmc> nostrand, it's not so much that as the assumption about character encoding
12:33:04 <kmc> there's plenty of places where UTF-16 or some other encoding is used
12:33:24 <mauke> UTF-16 needs to die
12:33:49 <kmc> Haskell Chars don't have a particular encoding; they just stand for unicode values
12:33:57 <kmc> and so there's not one particular way to turn a Char into some bytes
12:34:25 <kmc> (just as Haskell Ints aren't explicitly little-endian or big-endian.  the compiler is free to represent them in memory however it likes, and you can't tell)
12:34:29 <Eelis> who decided that scientific notation for numeric constants shouldn't be available for integral types? that guy should be shot. let me write 1e9 for an Integer already, goddammit!
12:34:57 <mauke> Eelis++
12:35:14 <mauke> 10^9
12:36:07 <kmc> > 10^9
12:36:08 <lambdabot>   1000000000
12:36:22 <mauke> > 1e9
12:36:23 <lambdabot>   1.0e9
12:36:24 <applicative> > floor 1e9
12:36:25 <lambdabot>   1000000000
12:36:53 <kmc> > let x`e`y = x * 10^y in 3`e`9
12:36:54 <lambdabot>   3000000000
12:37:09 <kmc> > let x€y = x * 10^y in 3€9
12:37:10 <lambdabot>   3000000000
12:37:20 <kmc> pick your favorite e-like unicode symbol
12:37:32 <mauke> blargh, can't use (Counted s a)
12:37:35 <mauke> I don't know what 'a' is
12:38:14 <parcs> > let € = 9 in €+€
12:38:15 <lambdabot>   <no location info>: parse error on input `€'
12:38:31 <parcs> > let € = 9 in € + €
12:38:32 <lambdabot>   <no location info>: parse error on input `€'
12:38:58 <parcs> haskell symbols must be alphanumeric?
12:39:09 <mauke> mostly
12:39:11 <kmc> > generalCategory '℮'
12:39:12 <lambdabot>   OtherSymbol
12:39:24 <Eelis> kmc: yes, i'm aware there are various workarounds. but the fact that workarounds is needed is an embarrassment.
12:39:27 <Eelis> *are
12:39:36 <kmc> > let x℮y = x * 10^y in 3℮9
12:39:36 <lambdabot>   3000000000
12:40:01 <kmc> parcs, infix operators use symbol characters; ordinary names use alphanumeric characters
12:40:51 <kmc> of course alphabets other than the Latin alphabet are allowed
12:41:47 <kmc> > let привет=3; мир=5 in привет*мир
12:41:48 <lambdabot>   15
12:42:13 <kmc> this is also why you can't use λ instead of \
12:43:01 <applicative> mauke, will you call " Person " a 'type constructor' if I write " data Person = P String Int (Int, Int , Int) " ? 
12:43:35 <mauke> applicative: yes
12:43:47 <parcs> so ghc has a list of symbolic characters that it uses to determine whether or not something is infix?
12:44:08 <ddarius> No, it just uses the Unicode character classes.
12:44:16 <applicative> I see, this is what is missing then, a word for the ones with a hole in them, they're the things that are Monads, Functors etc
12:44:32 <parcs> ah
12:44:33 <mauke> applicative: type constructor of kind * -> *
12:44:40 <applicative> mauke right.
12:44:50 <applicative> but we don't have a rustic natural name for that sort of thing
12:45:14 <applicative> which means we dont have a natural name for the things that are instances of Functor, Monad etc
12:45:30 <ddarius> Why should we?
12:45:43 <mauke> arity-1 constructors
12:45:50 <applicative> ddarius, in order to explain the concept to people who dont know Haskell yet
12:45:57 <ddarius> And just because something is of kind * -> * doesn't mean it's an instance of Functor or Monad.
12:46:07 <ddarius> applicative: So explain the pattern rather than making up colorful words.
12:46:07 <applicative> indeed not, that's the point
12:46:12 <applicative> it's the other way around
12:46:41 <ddarius> Usually people say "unary" for "arity-1".
12:46:52 <applicative> but when I say, e.g. data Maybe a = Nothing | Just a   this is very comprehensible, suppose I called it a polymorphic type
12:47:21 <Boxo> Type constructors. Maybe is a type constructor. Standard word.
12:47:38 <applicative> Boxo, but it needn't be (* -> *)
12:47:52 <Boxo> What's so special about *->* anyway?
12:48:06 <applicative> its the sort of thing that can be a monad or functor
12:48:45 <applicative> I was just thinking about the pedagogy of these things, based on some questions earlier. 
12:48:59 <ddarius> applicative: Should we have another word for * -> * -> * which are things that potentially can be Categories or another for (* -> *) -> * for things that are potentially monad transformers usw.
12:49:00 <ddarius> ?
12:49:21 <mauke> GERMAN DETECTED
12:49:31 <applicative> ddarius, if people are going to instance Category ..., they will need a name for that too
12:49:34 <ddarius> Again, it seems the pedagogically correct thing to do is to explain the pattern rather than creating arbitrary terminology.
12:49:40 <applicative> but Functor and Monad are level one Haskell
12:49:52 <ddarius> applicative: They have one, binary type constructors or type constructors of kind * -> * -> *.
12:49:53 <mauke> applicative: oh, I wasn't aware I needed a name
12:49:57 <mauke> all those years, wasted
12:50:13 <monochrom> software engineering is the greatest source of creative wording for really repeatable patterns
12:50:51 <ddarius> applicative: What is your magic word for functions of arity 1?  map is certainly "level one Haskell".
12:50:57 <applicative> This is not a theoretical point, I think it is difficult to manage the grammar of people's sentences without a word for the sort of thing that might or might not be
12:51:01 <applicative> a monad or functor
12:51:46 <applicative> yes, but the intelligibility of map is one of the things we begin with; you use it to explain fmap
12:51:55 <monochrom> "asterisk arrow asterisk"
12:52:14 <ddarius> monochrom: I usually read * -> * as "type to type".
12:52:18 <Boxo> Star to star...
12:52:28 <monochrom> that's even better
12:54:12 <ddarius> applicative: Also one of the potential pitfalls of making such a word is people then get confused about things like instance Monad (Reader r).
12:54:26 <applicative> Is everything I can get on the page in Haskell that has kind * -> * also a potential functor instance?
12:54:36 * hackagebot ssh 0.2.4 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.4 (AlexSuraci)
12:54:39 <applicative> ddarius, yes, I see that point
12:55:06 <conal> how about "type functions"? including "first-order" type functions, etc. and like term functions, some type functions are injective, allowing for syntactic-style pattern-matching.
12:55:41 <conal> we now use "constructor" inconsistently in values vs types.
12:55:43 <applicative> right, something like that
12:56:21 <applicative> conal, I remember seeing you complain rightly about people speaking e.g. of the IO monad where they might as well have said the IO functor 
12:56:35 <applicative> but then you had no word for the thing that IO is, except: type
12:57:01 <monochrom> in software engineering there is much artificial hair-splitting bikeshed-colouring distinction between "high-level design", "design specification", "functional specification", etc, which are all really just "level n specification"s for particular values of n, and from one level to another all you do is refinement.
12:57:03 <ddarius> conal: Counting type renames induced by type synonyms as constructors and now with type families, yes, but otherwise it seems at both the value and type level, "constructors" are injective functions.
12:57:23 <conal> applicative: yeah. and some folks argued that IO isn't a type, though i hear talk of "higher-kinded types", of which IO is an example.
12:57:40 <ddarius> It's a higher kinded type constructor.
12:57:52 <ddarius> conal: I hear some people argue that in x = 1, x is not a function.
12:58:05 <applicative> yes, that is the word for it, but it seems too fancy.  Writing Maybe a = Nothing | Just a is so ordinary
12:58:32 <conal> i'd drop the "constructor" and just say "higher kinded type"
12:58:33 <applicative> a word that expressed that ordinary thing, would cast a flood of light for the learner
12:58:39 <monochrom> this is a great way to help create essay-type exams that just talk the talk and never walk the walk. not sure of its pedagogical value but its grading value is pretty evident.
12:58:42 <ddarius> (Actually, I'd reserve "higher kinded" for type constructors like Mu or monad transformers.)
12:58:55 <conal> just like "sin" is a higher-typed value, not a higher-typed value constructor.
12:59:17 <frustrated> I'm trying to write a happy parser for the i -> (letter | digit | + | - )+ does anyone know how to do this?
12:59:19 <applicative> sin is a higher typed value does seem dreadful
12:59:22 <Saizan_> except that you can't pattern match on sin
12:59:26 <conal> another source of confusion is lack of terminology to distinguish type expressions from types (syntax from semantics).
12:59:30 <frustrated> the grammar*
12:59:30 <Saizan_> while you pattern match on IO with typeclasses
12:59:44 <Saizan_> as opposed to type (family) synonyms
12:59:58 <conal> Saizan_: right. not all type functions are injective and not all value functions are injective.
13:00:24 <applicative> conal, yes use/mention confusion is rampant
13:00:32 <Saizan_> yeah, but i've only seen type constructors in this discussion :)
13:01:09 <applicative> the things that are instances of Monad or Functor are always type constructors, if you use that word
13:01:30 <Saizan_> not true
13:01:35 <ddarius> applicative: I don't see how calling what Maybe is a special word makes it seem -more- ordinary.
13:01:42 <applicative> Saizan, no?  
13:01:42 <frustrated> Does anyone know something about Happy here?
13:02:20 <applicative> ddarius, we cant say what a monad is, or what a thing has to be to be a monad
13:02:39 <Saizan_> applicative: they can be partially applied type constructors
13:02:42 <ddarius> applicative: Yes we can.  Several options have been provided.
13:03:38 <applicative> Saizan, indeed, this is a problem.  But there is also an intellectual step in any case to grasp how (Either a) is a Functor instance
13:03:44 <ddarius> The only precise answer is "type constructor of kind * -> *", even "unary type constructor" is imprecise as Mu is a unary type constructor.
13:04:15 <ddarius> Of course, if you explain kinds then it is very easy to clear up confusion about (Either e) if it arises at all.
13:04:50 <applicative> yes, but kinds are another step or two ahead in intellectual apprehension, it seems to me. 
13:05:00 <ddarius> applicative: I vehemently disagree.
13:05:06 * Saizan_ too
13:05:14 <Saizan_> kinds are as basic as type classes
13:05:38 <Saizan_> and you shouldn't talk about Functor before you've explained the latter ones
13:05:40 <mauke> kinds are like function types, only simpler
13:05:50 <ddarius> The kind system is a miniature version of the type system in general.  If your "students" have trouble apprehending it, you will have far more troubles with monads and type classes.
13:06:06 <monochrom> I don't see people being crazy about naming "a->b", "(b->a)->c", "((c->a)->b)->d"...
13:06:31 <ddarius> monochrom: Indeed, I've already asked for applicative's name for "A -> B" functions such as what would be passed to map.
13:06:35 <applicative> monochrom, what is the thing that you instance as a Monad?
13:06:39 <monochrom> In any case what Feynman says about how people spend time on names in order to avoid understanding.
13:06:43 <applicative> or that you can't since it's ZipList?
13:07:28 <monochrom> A monad is a type of kind *->* with such-and-such operators satisfying such-and-such laws
13:07:46 <Saizan_> you want a name for "instance of Monad" ?
13:07:49 <applicative> so the answer is, it's a type of kind * -> *
13:08:03 <monochrom> that's less than what I said
13:08:04 <copumpkin> Monad :: (* -> *) -> %
13:08:11 <applicative> -- the sort of thing that is or isn't a monad
13:09:15 <ddarius> applicative wants a name for type constructors of kind * -> *, the ones that can legally, if not meaningfully, be instances of Functor/Monad/etc.   Somehow though, he keeps forgetting that it is "type constructor of kind * -> *".
13:10:40 <applicative> ddarius, I know to call it that.  But the question: what does "->" mean in the case of kinds, is the same question
13:11:21 <monochrom> I don't think you have ever learned what "+" means, what "->" means, etc.
13:11:24 <applicative> * is the kind of any concrete type.  what is a * -> *
13:11:41 <ddarius> A type level function from a type to a type.
13:11:51 <medfly> :k []
13:11:52 <lambdabot> * -> *
13:11:53 <ddarius> In Haskell (98) all such functions are "trivial".
13:12:03 <applicative> ddarius, indeed now you are getting closer to what I am looking for
13:12:13 <ddarius> I.e. (->) means pretty much the same thing at the type level as at the value level.
13:12:30 <conal> a "type function"
13:12:36 <ddarius> You could, if you wanted, introduce a notion of sorts and say (->) has sort [] -> [] -> [].
13:12:38 <conal> (injective or noninjective)
13:12:46 <applicative> but there is more.  If I understand "function" more or less set theoretically, it won't be just any function from types to types
13:12:59 <copumpkin> ddarius: but then what are those arrows between the []!? :P
13:13:33 <applicative> it must be associated with a general form of construction of members of the target type 
13:13:56 <ddarius> (->) at the type level (as opposed to the kind level) is also not just any function from the given type to the given type either.
13:14:20 <applicative> right  
13:14:38 <ddarius> If you want to use a more precise/limited term, you could call them injective type functions, but I don't see that making things simpler for a student.
13:15:08 <ddarius> You can say * -> * is the kind of all conceivable type functions, but Haskell only allows a limited set to actually be expressed.
13:15:09 <applicative> but I can easily explain functions from the Haskell types to the Haskell types that are calculable, so to speak, but that wont correspond to anything that could be a Functor or Monad instance, no?
13:15:27 <applicative> like [a], except I swap Int with [Char] for the hell of it
13:15:42 <ddarius> You could, but Haskell provides you no way to write such functions.
13:15:54 <ddarius> (Well, it didn't...)
13:16:58 <ddarius> With type families you can write things like that.  Now the term "type constructor" carries more weight.  Just like not every function is a data constructor but data constructors are still functions.
13:17:30 <applicative> ddarius, you keep coming around to my position ....
13:20:58 <applicative> a bit of weather there
13:20:59 <ddarius> applicative: I don't see how.  1) I don't see introducing type families early on as the best pedagogical approach currently, and 2) I still completely agree with using the terminology "type constructor of kind * -> *" which seems to capture exactly what you want.  Perhaps it is you coming around to my position.
13:21:06 <applicative> ddarius, i dont think type families are necessary in order to understand the thing that Maybe a and [a] have in common
13:21:08 <ddarius> applicative: That's what I'm saying.
13:22:58 <applicative> The question is, what is the meaning of -> in (*->*)
13:24:06 <ddarius> applicative: It's a type function constructor just like (->) at the type level is a value function constructor.
13:24:10 <ddarius> If you can explain the type level (->) you can explain the kind level (->) because they are the same thing at different levels.
13:24:16 <ddarius> Type constructors are a subset of all possible type functions, just like data constructors are a subset of all possible value functions.
13:24:17 <Nakilon> where does have to go and what does have to read a rubyist, who wants to learn haskell to use the best of it? I need resource with examples of practical use of functional programming and lazy evaluating to learn how get the best of applying haskell to part of the most usual tasks
13:24:18 <ddarius> Nakilon: Why do you want to learn Haskell at all?
13:24:19 <applicative> to each data constructor a function  corresponds, once it has been introduced. 
13:24:44 <augur> applicative: obviously its a kind operator
13:24:44 <augur> holy moly look at all this sudden text
13:24:53 <ddarius> applicative: A data constructor doesn't "correspond to" a function.  It -is- a function.
13:25:15 <Cale> Nakilon: Of course you know about Real World Haskell already?
13:25:34 <applicative> ddarius, the target values arent there without the constructors.  This makes for a difference, however we describe it.  
13:26:04 <ddarius> applicative: I don't know what that sentence means.  What "target values" aren't where? Why?
13:26:22 <applicative> Just 1
13:26:40 <Nakilon> ddarius, 1) sometimes haskell solved my tasks (for example, some ACM, ICPC contests) more efficiently and with less code, than ruby; 2) I want to know, what does functional programming give to programmer - I'm learning
13:27:00 <ddarius> Nakilon: Okay.
13:27:44 <applicative> Just maps Ints to Maybe Ints, for example.  But you need Maybe Int s in your system before you can consider functions of type Int -> Just Int
13:28:18 <applicative> Maybe Int rather
13:28:34 <ddarius> So you were saying "values aren't there without the types" ?
13:29:22 <applicative> Well if I am defining a function, I need some idea of the sort of thing I'm mapping to.
13:29:49 <applicative> You can say that Just is a function, but then you can't say it is defined
13:30:15 <Saizan_> you should read about herbrand models :)
13:30:18 <ddarius> Programmers in dynamically typed languages get by without an explicit notion, but that's fine.  You could explain type functions using a language that only had types and not type constructors and the generalize from there.
13:30:54 <ddarius> (And indeed this is exactly what is happening at the type level.)
13:31:23 <applicative> How many types does the language you're thinking of have?
13:31:27 <ddarius> (You cannot "reify" any of the kind constructors which is to say the "metakind" or "sort" level is trivial.)
13:31:37 <ddarius> applicative: As many as it wants.
13:32:10 <applicative> Maybe I'm not following "You could explain type functions using a language that only had types and not type constructors and generalize from there"
13:32:11 <ddarius> The simply typed lambda calculus doesn't need any type constructors.  C has very few type constructors.
13:32:26 <ddarius> Sorry that should be value functions.
13:34:10 <ddarius> (Note in the STLC statement and the above I'm using "type constructor" in a more restrictive sense than normal, i.e. type constructors that aren't types (i.e. aren't of kind *)).
13:35:17 <mauke> .oO( t :/: * )
13:36:20 <applicative> yes, you are using 'type constructor' to mean, the sort of thing that might or might not have a Functor or Monad instance
13:36:28 <ddarius> applicative: No, I'm not.
13:36:35 <applicative> :)
13:36:57 <ddarius> I'm using it to mean things like Mu and (->) and many other things which aren't of kind * -> * but also those things.
13:37:10 <mauke> ∃t: t ∉ { *, * -> * }
13:37:18 <applicative> (-> Int) is of kind (*->*)
13:37:35 <mauke> (-> Int) is not Haskell
13:38:00 <applicative> I wasn't insisting it was
13:38:22 <ddarius> (Also in GHC (-> Int) if it were legal would have kind ?? -> *)
13:38:38 <applicative> hmmm okay  
13:39:02 <monochrom> * is like the singleton pattern. *->* is like the command pattern. *->*->* is like the visitor pattern. (*->*)->* is like the enumeratee pattern. (*->*)->*->* is like the iteratee pattern. names are like burrito analogies.
13:39:03 <applicative> but then the supposed lucidity of "type constructors that aren't types (i.e. aren't of kind *))." 
13:39:05 <applicative> goes out
13:39:21 <ddarius> I'd don't see how.
13:39:34 <applicative> monochrom, your conviction that it is a matter of names is groundless
13:40:03 <applicative> our gentlemen are driven deeper and deeper into theory in order to explain what the kind of thing that can be a monad or functor instance is
13:40:18 <ddarius> To make (Int -> Int) you have to have (->) has kind * -> * -> * unless you just have a primitive "type value" of that kind.
13:40:58 <ddarius> I haven't really gone any deeper into theory except when the question changed from "I want a short name for a type constructor of kind * -> *" to "What's the (->) in kinds?"
13:41:06 <applicative> and to make * -> * -> * what do I have to have?
13:41:28 <monochrom> data F a b = Whee. F has kind * -> * -> *
13:41:33 <ddarius> applicative: You don't need to "make" it.  You can posit it as a primitive.
13:42:15 <applicative> why not do that with the -> in Int -> Int   That corresponds with common sense after all  
13:42:27 <applicative> * -> * basically involves treating the type system as a type
13:42:49 <ddarius> applicative: That is what we do.  It is a primitive type value of kind * -> * -> *.  My STLC example was saying to simply not have any primitives of such kinds.
13:42:56 <ddarius> Only have primitive type values of kind *.
13:43:06 <monochrom> the pedagogical process of learning *->* is the same of that learning Int->Int
13:43:51 <ddarius> I agree with monochrom, but then I should as that's pretty much exactly what I said twenty minutes ago.
13:44:08 <applicative> There would be no reason to introduce the jargon of kinds if we didn't have general type constructions like Maybe a and [a]
13:44:51 <ddarius> applicative: Agreed.  So you can remove type level application and not reify (->) and you are don't need the jargon of kinds.  This is why kinds can get away without needing sorts.
13:45:08 <applicative> I arrive at * -> *, the concept, by analogy from Maybe, [] , Either String, etc
13:48:15 <ddarius> The only reason kinds exist as a notion in Haskell is because it is possible for you to make malformed (ill-kinded) types.  It is not possible to make malformed kinds because in Haskell 98/2010 you can't write kinds at all, and even in extensions that allow you, it is possible to disallow them syntactically because there are no kind variables.
13:48:30 <ddarius> If we had kind polymorphism, we would then need to introduce "metakinds".
13:48:44 <ddarius> (And indeed, Omega does introduce a whole tower of such.)
13:49:08 <applicative> ddarius, yes, then soon enough, you would insist that we explain what a metakind is, in order to explain what a Functor or Monad instance is.
13:49:15 <Cin> 'Sup chaps.
13:49:47 <monochrom> Examples are always a great way to learn something. I dare say the only effective way.
13:50:09 <ddarius> applicative: Possibly if it was relevant.  For example, Category would more nicely have the polymorphic kind: forall k. k -> k -> * and I would expect people to be able to understand the metakinds involved before being able to understand that.
13:50:15 <applicative> monochrom, we are in agreement. 
13:51:46 <monochrom> The use of a lot of philosophical musings such as in the wikibook and YAHT are now proven to be ineffective by LYAH and RWH.
13:52:06 <kmc> that's not how proofs work
13:52:07 <Cin> I only read YAHT for the exercises.
13:52:17 <applicative> monochrom, your complaints are groundless, if they are directed at me
13:52:31 <applicative> monochrom, BONUS calls [1] a functor
13:52:45 <Cin> Which it is?
13:52:50 <mauke> it isn't
13:53:00 <Cin> Bah, types are functors, yeah, great.
13:53:06 <applicative> BONUS calls putChar 'a' a monad
13:53:10 <mauke> no, that's a mote
13:53:11 <Cin> It's a value, yeah. Whoopdedo.
13:53:14 <applicative> functors are things you can map over 
13:53:17 <mauke> hmm, does that make [1] a fute?
13:53:20 <applicative> like [1,2,3]
13:53:20 <BONUS> applicative: did i?
13:53:25 <applicative> that's a functor
13:53:28 <applicative> YES
13:53:29 <BONUS> i gotta fix that "functors are things you map over" line
13:53:33 <applicative> REPEATEDLY
13:53:44 <applicative> the trouble is, it's a good line
13:53:48 <kmc> futes?
13:53:49 <BONUS> i'm going over the book and fixing things
13:53:49 <monochrom> well then it will be repaired
13:53:52 * ddarius hates this "mote" crap.
13:53:56 <kmc> futex?
13:53:56 <luite> functors are things you fmap over
13:54:10 <applicative> our friends are attacking me though, for wanting a good way of writing the relevant lines, without technical drivel
13:54:11 <BONUS> however, i dont recall calling putChar 'a' a monad
13:54:20 <kmc> i just ate a burrito so i think i'm uniquely qualified to weigh in on this issue
13:54:23 <monochrom> no cash bonus for christmas!
13:54:32 <mauke> ddarius: why?
13:54:33 <applicative> BONUS in that case, I was abstracting from the method
13:54:37 <BONUS> i just know i did that thing for functors, for which i apologize and will put up a fix
13:54:59 <test1321> Hey guys, I have a question is it possible to run Happy (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happy) without installing it using cabal? I thought I could just import it, but I don't know what to import =(
13:55:11 <BONUS> test1321: just install the platform
13:55:16 <test1321> I can't
13:55:18 <applicative> BONUS, i'm not sure it's good to fix it. It has a genius to it, though it's maddening.
13:55:23 <kmc> test1321, happy is not a library you import; it's a command-line tool which generates Haskell code
13:55:30 <test1321> I don't have the priveledges, to install it
13:55:36 <kmc> oh, you can install stuff locally
13:55:44 <mambo> hi, maybe someone help me with yamc: i have function: "z  = take 5 $ filter id $ repeat up" where up is function returning IO Bool, but z currently  pure and not working and i want reweite it monadic way.
13:56:05 <test1321> uhm... so Happy actually generates my code???!!!
13:56:12 <mauke> z = [True, True, True, True, True]
13:56:21 <ddarius> applicative: You could say "unary type function" and be completely correct, particularly if you are going for intuition.  Just because Haskell doesn't allow you to write all type functions doesn't make that incorrect.  Furthermore, several options of varying precision have been suggested.  The most precise one is only important if you care about the precision.  If you -do-, care about the precision then you -do- need t
13:56:21 <ddarius> o talk about kinds.
13:56:22 <BONUS> applicative: kind of, but it oversimplifies the thing a bit and ulitmately i think it's worth distinguishing between functor values & functors, applicative values & applicatives and monadic values & monads
13:56:23 <kmc> test1321, yes, it's like yacc/bison if you've used those tools in C
13:56:36 <mambo> the goal is to call "up" x times, but 5 of them must return True
13:56:45 <kmc> test1321, parser generators are kind of clunky; we tend to favor parser combinator libraries like Parsec
13:56:54 <kmc> but there's a few valid reasons to use Happy still
13:56:58 <burp> http://abstrusegoose.com/strips/proof_found_but_not_enough_room_in_margin.PNG
13:57:09 <test1321> oh well I just wanted to experiment with it =)
13:57:39 <test1321> Can someone tell me what the difference is between (http://www.haskell.org/alex/) Alex and Happy?
13:58:02 <test1321> (I read it, but I'm not quite getting the meanings =()
13:58:03 <monochrom> regex lexer vs cfg parser
13:58:05 <ddarius> Even if you make up a word for "stuff that can be an instance of Monad/Functor" how are you going to explain/characterize it?  You have exactly the same problem and the same solutions.
13:58:48 <test1321> please correct me if I am wrong alex is used to "check whether it has some syntaxis" and Happy is used to generate the code?
13:58:55 <mikeg> Is Alex pronounced A-Lex or Al-ex?
13:58:56 <monochrom> no
13:58:58 <applicative> obviously, i am only interested in whatever can most conveniently draw someone's attention to the thing, which is a condition of a word's being put on it
13:59:00 <kmc> alex and happy both generate code
13:59:07 <applicative> i repeatedly denied wanting a name
13:59:07 <kmc> alex generates the code for a lexer; happy generates the code for a parser
13:59:18 <kmc> a lexer turns a string of characters into a string of tokens
13:59:23 <kmc> a parser turns a string of tokens into a syntax tree
13:59:38 <mauke> a string of tokens is a very simple syntax tree
13:59:51 <mauke> characters are very simple tokens
13:59:51 <applicative> i want the simplest most lucid way of making clear what could then be given a name, if one wanted to
13:59:53 <test1321> yes I get it what a parser is =), but what's exactly a lexer?
14:01:05 <monochrom> lexer looks at "hi = 4" and says, "that's an identifier hi, followed by reserved symbol =, followed by numeric literal 4".
14:01:20 <conal> BONUS: i worry about confusion resulting the terms "functor value", "applicative value", "monadic value". an "integer value" is an integer, but a "functor value" is not a functor (etc).
14:01:50 <mauke> is an integral value an integral?
14:01:51 <monochrom> you could but you wouldn't want to do that kind of classification (and whitespace handling) in your parser.
14:01:52 <ddarius> applicative: And the problem is the thing you want to name is fairly arbitrary which is -why- it doesn't yet have a name.  "Type" usually just means a type constructor of kind *.  Why bother giving it a special name?  Why not say "type constructor of kind *"?  Well, values can only be members of types, not arbitrary type constructors.  This is important.
14:02:06 <BONUS> conal: yeah i agree, it's hard to make the terminollogy both consistent and complete (hehe).
14:02:06 <mauke> monochrom: actually, why not?
14:02:07 <kmc> if you want to be precise, just write code
14:02:10 <mauke> monochrom: I do that all the time
14:02:12 <test1321> but isn't a lexer than also "parsing" something?
14:02:16 <monochrom> not in Happy
14:02:24 <kmc> test1321, sort of
14:02:24 <conal> BONUS: yeah. hard.
14:02:25 <ddarius> That only type constructors of kind * -> * can be Monads or Functors, isn't too important.  Monad and Functor are both user-defined classes and otherwise not particularly notable.
14:02:30 <BONUS> i'm going to fix the "functors are things that are mapped over thing though" when i introduce other changes from the editing phase
14:02:37 <mambo> maybe somebody help me with this snippet: http://hpaste.org/42428/yamq
14:02:54 <kmc> test1321, a lexer is a parser whose input is raw characters and whose output is a flat list rather than tree-shaped
14:02:57 <conal> BONUS: glad to hear.
14:02:57 <test1321> but if lexer is parsing something, and defining what is an identifier and what is something, why should one need both (happy and alex)?
14:02:58 <monochrom> yes a lexer also parses something. this is why I carefully say regex lexer. it can only do what regex does.
14:03:22 <applicative> ddarius, indeed.  The crucial thing is that in Haskell and suchlike languages you can write: data B a where ..... a......  
14:03:32 <monochrom> what regex cannot do: check and make sense out of matching parentheses.
14:03:33 <kmc> test1321, because the output of a lexer is a flat list of tokens, but the syntax of your language is not
14:03:43 <test1321> oh icic
14:04:01 <kmc> test1321, your language is built out of nested constructs like "expression" and "statement" and "declaration"
14:04:08 <monochrom> but regex is enough for classification of "identifier" "reserved word" etc.
14:04:09 <test1321> yes true
14:04:11 <kmc> or "noun phrase" and "clause" and "sentence"
14:04:15 <test1321> kmc: yes
14:04:45 <BONUS> test1321: a token is a pair consisting of a token name and a lexeme, which is kind of its value. example tokens (EQ,=), (IDENTIFIER,foo), (NUMBER,4) etc
14:05:06 <test1321> oh
14:05:23 <BONUS> it's easier to make a parse tree if you have a series of tokens as such, instead of having to account for whitespace and such in that phase
14:05:29 <test1321> well my language is rather simple.. it's all simple logical statements
14:05:59 <monochrom> as long as you allow arbitrary whitespaces, you benefit from a lexer.
14:06:09 <test1321> oh icic
14:06:41 <monochrom> feeding this stuff directly to Happy is possible but more tedious
14:06:53 <test1321> so how should / can I use happy? :( I actually can't import it... should I just make an example file (from the documentation) and thn trying to execute it?
14:07:00 <monochrom> however feeding this stuff directly to parsec is still easy
14:07:06 <test1321> ah icic
14:07:39 <test1321> does someone know how I can actually "run" / execute someting of Alex / Happy?
14:07:40 <monochrom> this is why mauke says he skips the lexer stage all the time. well I do all the time. but we mean we use parsec etc
14:07:51 <kmc> test1321, i suggest you read the manual for alex and/or happy
14:07:51 <monochrom> you have to write a grammar file for Happy
14:07:56 <kmc> as i recall they both have fairly extensive documentation
14:08:08 <BONUS> test1321: try going to your command line and type in alex
14:08:12 <test1321> kmc: that's true, but however I can't install it
14:08:18 <mauke> test1321: why not?
14:08:21 <kmc> test1321, they both come with Haskell Platform
14:08:33 <test1321> mauke: I don't have the privilidges for installation
14:08:35 <test1321> ok Ill try
14:08:37 <monochrom> I am kind of blissful in not having learned the Happy way or generally the Yacc way etc.
14:08:41 <mauke> test1321: what privileges do you mean?
14:08:43 <kmc> test1321, the answer is that you *shouldn't* use Happy; you should use a library like Parsec instead
14:08:48 <kmc> then your parser is ordinary Haskell code
14:08:57 <kmc> and you don't have to do anything special to "compile" it
14:09:07 <monochrom> simple logic expression benefits from parsec
14:09:23 <BONUS> kmc: i kind of like the strict separation of lexer/parser phase of the alex/happy approach
14:09:30 <BONUS> with parsec it's much easier to mix those up
14:09:36 <kmc> test1321, you can install Haskell packages (including the entire Haskell Platform) in a local prefix
14:09:41 <test1321> kmc: I see, I can't install it because I can't install anything on this computer
14:09:47 <test1321> but Haskell platform is installed
14:09:54 <test1321> so I should be able to run it
14:09:58 <mauke> BONUS: that means parsec is more fit for real world use
14:09:59 <test1321> and I can from the command window
14:10:08 <BONUS> mauke: hmm, how so?
14:10:09 <test1321> I thought I should execute Alex from the GHCi
14:10:22 <BONUS> test1321: no alex is a program
14:10:23 <mauke> BONUS: what if your lexer depends on your parser state?
14:10:34 <mauke> see also: perl, javascript
14:10:40 <BONUS> hmm i see your point
14:11:23 <applicative> test1321, type " alex --help"
14:12:05 <test1321> applicative: only typing alex would result the same =)
14:13:16 <applicative> good plan
14:14:01 <test1321> So let me get this straight. I use Alex to generate haskell code to identify elements and I use happy to generate code for parsing elements and I use GhCi for executing those "compiled" code?
14:15:33 <gwern> that doesn't sound right. the ghc RTS is bundled with executable code, but it's not the same thing as ghci at all
14:16:59 <mambo> is there monadic version of repeat ?
14:17:17 <mauke> :t forever
14:17:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:17:42 <Zao> @src forever
14:17:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:18:26 <applicative> forever a = a >> forever a
14:18:47 <emef0> forever alone?
14:19:13 <BONUS> story of my life
14:20:16 <emef0> wouldn't make a good story if you were forever alone, I don't think
14:21:19 <chrisf> BONUS: chicks dont dig LYAH? o_O
14:21:42 <BONUS> haha
14:21:57 <mambo> so, still anyone help me to rewrite upmilti in monadic way in this snippet: http://hpaste.org/42429/upmulti  ?
14:22:01 <emef0> but there's cute pictures!
14:22:13 <emef0> chicks must love it
14:22:25 <mambo> i tried, but code become clobbered high, which is not good
14:22:40 <BONUS> i try to keep my internet identity a secret. like some sort of nerdy batman
14:23:18 <blackdog> BONUS: why_?
14:23:30 <mambo> sorry, not clobbered but obfuscated and loses its brewity and cleanness
14:23:41 <mauke> mmh, brewity
14:23:43 <BONUS> haha. i guess i just like batman
14:23:45 <osfameron> BONUS: but we know your internet identity.  It's "BONUS" ;-)
14:23:56 <mauke> BONUS: Batman's identity is public knowledge
14:24:00 * hackagebot JSON-Combinator 0.1.1 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.1.1 (TonyMorris)
14:24:01 <mauke> Batman, Inc.
14:24:02 <chrisf> too much brewity in this code.
14:24:30 <osfameron> it it the soul of vit?
14:25:12 <ddarius> BONUS: Why do you try to keep your internet identity a secret?
14:25:13 <mambo> brevity
14:25:22 <blackdog> BONUS: sorry, couldn't resist the obvious rubyist joke:)
14:25:25 <BONUS> :D
14:26:08 <BONUS> ddarius: hehe i was kidding around a bit, but you know how it is when you're hanging out with non-CS people
14:26:25 <benmachine> "what's an IRC?"
14:26:49 <ddarius> BONUS: Okay.  I can see why you wouldn't randomly bring it up.
14:27:09 <ddarius> I don't and I make no effort to disconnect my online and real life identities.
14:27:13 <BONUS> yeah, pretty much that. but if people ask me i tell them about it in an approachable and hopefully fun way
14:27:42 <ddarius> BONUS: "I'm the pimp master of Haskell bitcheses!"
14:27:47 <BONUS> lol :D
14:27:51 <benmachine> what could possibly go wrong
14:27:51 <BONUS> i'm pretty sure that's dons
14:28:05 <benmachine> heh
14:28:48 <applicative> mambo, why do you have " return $ not r " in the last line of the definition of up?  are you going to use r, or not r other than as you did in the previous line?
14:29:36 <mambo> applicative: is only to force type to be Bool
14:30:15 <applicative> mambo, doesn't that follow from the fact that you apply "not" to it in the previous line?
14:30:42 <mambo> applicative: nope, string with print no matter, can be ignored
14:30:46 <applicative> mambo, i see, maybe that's why you used not to begin with
14:31:13 <mikeg> @hoogle replicateM <-- i think this is what you are looking for
14:31:13 <lambdabot> Warning: Unknown type <--
14:31:13 <lambdabot> No results found
14:32:01 <benmachine> mambo: if you just gave a type signature to up, you wouldn't need to do that 'not' trick
14:32:05 <benmachine> alternatively you could do
14:32:12 <benmachine> r <- randomIO :: IO Bool
14:32:26 <benmachine> or
14:32:44 <benmachine> print ("doing up: " ++ show (r :: Bool))
14:32:52 <benmachine> which will fix the type of r everywhere
14:33:55 <mambo> benmachine: thats cool tip, thanks
14:34:31 <applicative> mambo, if you scrap the return line then "up" has type IO (); then you can just say " replicate n up " for upmulti
14:34:54 <applicative> mambo, but then you have a list of IO () actions, [IO ()] so you need 
14:34:56 <mambo> i wonder is it possible to rewrite "upmulti" monadic way to be nearly as succinct as pure version
14:34:58 <applicative> @type sequence_
14:34:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:36:18 <applicative> mambo, you could do it recursively fairly easily   upmulti 0 = return () ; upmulti n = up >> upmulti (n - 1)  --- isn't that right?
14:36:47 <mikeg> applicative: that's exactly replicateM :) i think he doesn't have a defined "n" value though. i.e. recur until he has five True values?
14:37:25 <mikeg> which is more like (take 5 . filter id . sequence . repeat)
14:37:28 <gwern> I think it's pbvious why BONUS keeps his True Name secret - admiration for why
14:37:53 <applicative> mikeg, yes, I wasnt seeing the 5 true values part though, there's no trace of it in the paste
14:38:46 <mikeg> Mhmm his name is on the Amazon page :-/
14:38:49 <mambo> applicative: "filter id" is supposed to filter out Trues
14:39:01 <applicative> i see, so he does need the return $ not r   
14:39:33 <gwern> mikeg: oops!
14:44:14 <monochrom> test1321: parsec example: http://hpaste.org/42430/logic_parsing_example
14:45:04 <cole_> Is there some way to list the names of all modules? What about all the names exported from a module?
14:45:40 <blackdog> cole_: :browse Foo in ghci
14:46:00 <blackdog> don't think it's possible in ghc without breaking out something like the ghc-api or Hint
14:46:12 <blackdog> or TH maybe
14:56:38 <applicative> mambo, dont you want " up " to be something like this?  http://hpaste.org/paste/42429/upmulti_annotation#p42431
14:57:45 <applicative> mambo, it will keep going till it gets a new one to add to the list.   This should be easily glued into the right master action
14:58:05 <SinDoc> How can I have list comprehension on a state monad? http://hpaste.org/42432/list_comprehension_for_the_sta
14:59:08 <sipa> SinDoc: in standard haskell, list comprehensions are only for lists
14:59:51 <mambo> applicative: yes, i think its way to go also
15:00:48 <mambo> i see monads kinda disallow writing things in my favorite function compisiition way
15:01:04 <SinDoc> sipa: yeah, the original code is in Gofer, which apparently used to generalise list comprehension
15:01:28 <Hilbert> Hey, I'm reading real word haskell and am confused why do you need type constructor and value constructors?
15:01:44 <applicative> return [] >>= up >>= up >>= up >>= up  is then multiup 4, return [] >>= up >>= up >>= up  is multiup 3 
15:02:23 <monochrom> because I have types and I have values.
15:02:30 <applicative> Hilbert, the type constructor, crudely, is the name of what you introduce with the 'value constructors'
15:02:39 <mambo> applicative: i rewritten the snippet this way: http://hpaste.org/paste/42429/upmulti_annotation#p42433
15:02:54 <mambo> not sure how correct is it, but it works
15:03:46 <Hilbert> applictive: the example given is data BookInfo = Book Int String [String] deriving (Show)     What good does the word Book do?
15:03:47 <mambo> but code still lost part of beauty
15:04:25 <SinDoc> sipa: Thanks, I guess I'll go ahead and re-write the parts with list-comprehension on the state monad
15:05:43 <mambo> applicative++
15:07:07 <nus> applicative: hmm, speak of the devil... (-;
15:08:30 <applicative> mambo, somehow I was thinking we wanted a list of recovered bools at the end, not that it's interesting !  http://hpaste.org/paste/42429/upmulti_annotation#p42434
15:09:35 <applicative> Hilbert, I see, well, your values will be of the form Book 5 "The Bible" ["God"], etc  without it what would you have?
15:09:50 <ddarius> The difference between people who have trouble with Parsec and people who don't: the existence of BNF in the source code.
15:11:52 <applicative> mambo, yes, it can certainly be more beautiful.   It was taking me a while to see what you wanted, though.  (Maybe it should have been obvious)
15:12:33 <mambo> applicative: the goal was to run "up" repeatedly until it return true n times
15:13:34 <Hilbert> applicative: I now see how to implement it, but the synatax is very strange to me
15:14:21 <nus> Hilbert: the world BookInfo helps your type checker check expressions you make (constructions or sometimes deconstructions) with the word Book
15:14:28 <nus> s/world/word/
15:14:30 --- mode: ChanServ set +o monochrom
15:14:41 <applicative> mambo, yes, I was trying to infer from the original paste.  
15:15:01 <applicative> mambo, but we seem to have that now, in at least two ways?
15:15:14 --- topic: set to '["GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://is.gd/iTnkV", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
15:15:24 --- mode: monochrom set -o monochrom
15:16:03 <applicative> Hilbert, you can use the same word, Book, since the 'namespaces' are different:  data Book = Book Int String [String] deriving (Show) 
15:16:16 <mambo> applicative: yes, thats cool, thnaks for advance
15:17:00 <monochrom> when you later look at "data X = Case1 Int | Case2 Bool" you will appreciate having Case1 and Case2
15:17:53 <applicative> Hilbert, what monochrom said.  The need for two namespaces comes from cases like his, for example
15:18:41 <applicative> data Book = Book Int String [String] | EBook Int Int  String [String] deriving (Show)
15:19:42 <monochrom> All questions like "why is Haskell designed like this" can be answered by forward references.
15:20:15 <applicative> monochrom, that suggests there's always an answer
15:20:33 <monochrom> oh there is always an answer
15:20:49 <applicative> i agree.
15:21:04 <nus> more like some answers are search for always
15:21:42 <monochrom> "there is an answer" is not a very useful thing to know
15:22:03 <applicative> "It happens sometimes, languages just explode" to paraphrase Repo Man
15:22:41 <monochrom> about as useful as "everyone has a price"
15:23:04 <monochrom> Oh I have "a price" sure. Perhaps it is CDN$10^100.
15:23:28 <nus> monochrom: are futures accepted?-)
15:23:35 <monochrom> haha
15:24:52 <nus> why don't they trade pasts, though?-)
15:25:08 <monochrom> too boring
15:25:53 <monochrom> people like incomplete-information games because each player thinks he/she is smarter than other players
15:28:51 <monochrom> the best way to win is not to play
15:29:07 <ddarius> Life is an incomplete-information game.
15:29:10 <nus> too long term 
15:37:18 * ddarius needs to decide between garter stitch and stockinette stitch.
15:38:39 <ddarius> > 18 * 60
15:38:39 <lambdabot>   1080
15:44:06 <applicative> mambo, maybe something like this, still too clutzy though http://hpaste.org/paste/42429/upmulti_annotation#p42436
15:47:54 <gwern> 'git-annex allows managing files with git, without checking the file contents into git. While that may seem paradoxical, it is useful when dealing with files larger than git can currently easily handle. (But why oh why in Haskell?)'
15:47:57 <gwern> ouch
15:48:33 <mambo> applicative: expressed in 7 words, pretty cool!
15:59:29 <porc> exit
16:02:50 <Bynbo7> gwern: link?
16:03:09 <gwern> Bynbo7: the sentence is unique
16:03:20 <gwern> wonder how it compares to darcs without pristine tree or whatever it was
16:16:05 <benmachine> 00:02:42 < gwern> Bynbo7: the sentence is unique
16:16:07 <ezyang> Would the "monad laws" be considered "axiomatic semantics" for monads? 
16:16:12 <benmachine> lies!
16:16:13 <benmachine> 2 results (0.28 seconds) 
16:16:22 <nus> gwern: still planning to download interwebs?-)
16:18:38 <c3l> does it work fine to write a program in haskell that uses sdl and opengl?
16:21:07 <applicative> benmachine, at first google claimed 4,690 results for the quoted sentence; then it slowly dawned on it there were only 31.  Their system is the REAL lie
16:21:25 <benmachine> applicative: gasp
16:21:38 <applicative> notice it takes forever to clone it since it's not github....
16:21:56 <benmachine> c3l: should do!
16:23:17 * applicative is disappoined it doesn't introduce System.Git alongside System.Posix , System.Process, etc
16:23:24 <c3l> benmachine: ..it should do, but is it recommended?
16:24:16 <benmachine> c3l: I've written SDL programs, I know people have written OpenGL programs, I assume they mix fine?
16:24:23 <benmachine> but I've not tried
16:24:28 <unkanon> yes they mix fine
16:24:49 <unkanon> I usually use SDL for window/keyboard/mouse and openGL for graphics
16:25:18 <kafee> hi, can I use Existentially quantified types with the type keyword ?
16:26:22 <c3l> ah nice, I was just worried that it might not work well since sdl and so is c. but im new to all this, and I find haskelly very fun and powerful, and I also want to learn some 3d graphics. So I thought doing that in haskell might be a good learning experience if nothing else. is that right?
16:26:43 <unkanon> I'e never used SDL + OpenGL with haskell, only c
16:28:14 <monochrom> kafee: I think you can't.
16:28:45 <kafee> type S = forall a . S a
16:29:23 <applicative> c3l, i guess that's how they're used together in graphics-drawingcombinators http://hackage.haskell.org/package/graphics-drawingcombinators-1.0.3
16:30:03 <Eduard_Munteanu> Existential type synonyms? :)
16:30:12 <gwern> nus: I decided to compromise by not version-controlling it, and by scrapping a few quasi-pathological domains, which got me down to 14GB or so
16:30:15 <gwern> which is acceptable
16:30:18 <benmachine> kafee: you can do that but I think it's a rank-n type, not an existential
16:30:35 <benmachine> maybe they're the same, I've never been that clear on the details >_>
16:31:12 <kafee> the compiler says if I perhaps intended rank-n ou rank-2 type
16:31:22 <Eduard_Munteanu> Also you can't really use there S as a constructor I think.
16:31:22 <benmachine> right
16:31:24 <c3l> applicative: interresting, thanks. 
16:31:52 <ddarius> gwern: What were some of the "quasi-pathological" domains?
16:32:04 <nus> gwern: what was the previous number?
16:33:05 <kafee> Eduard_Munteanu, yeah I miswrote
16:33:18 <kafee> the type I wanted was type MyPushButton = forall a. QPushButtonSc a
16:33:37 <gwern> ddarius: well, one blog for some reason resulted in like 2GB, despite being principally text and something that ought to have been no more than <10MB; and wikipedia had similar problems
16:33:45 <ddarius> kafee: You should think of type synonyms as just textual substitutes.
16:34:15 <gwern> ddarius: I didn't investigage too thoroughly why they exploded like that. probably all the posts were transcluded on monthly and yearly compilations or something like that
16:34:39 * ddarius thinks robots.txt is pointless.  Instead you should just have a page that cats /dev/zero over the network.
16:34:52 <gwern> nus: I think before I cut them down, it was at around 22GB
16:35:02 <gwern> ddarius: how very hostile
16:35:36 <ddarius> gwern: -Really- hostile would be for that page to be robots.txt.
16:35:54 <monochrom> ddarius: do you mean it cats /dev/zero for both human visiters and program visitors?
16:36:03 <monochrom> s/visiters/visitors/
16:36:06 <ddarius> monochrom: How do you tell the difference?
16:36:15 <monochrom> alright, just checking
16:36:41 <gwern> ddarius: hah.
16:36:50 <nus> ddarius: it had some imaginary point in minds like Stallman's (-;
16:37:02 <gwern> ddarius: well, user-agents are about as reliable as one gets with that sort of metaphysical question...
16:38:02 <ddarius> A human will just be like, "This is taking too long."  Admittedly, most robots probably have a timeout too.  So what you'll need to randomly generate links that, ultimately, point to the same source.
16:38:40 <blackdog> coming in late, but usually #haskell is less evil than this...
16:39:42 <ddarius> Moral of the story: one should be careful with the connotations of the word "productive" in "productive algorithm."
16:39:53 <monochrom> heh heh heh
16:41:57 <dibblego> does Sigbjorn Finne (Galois) still maintain Text.JSON?
16:41:58 <bsmntbombdood> is there a way to check for the '*** Exception: Non-exhaustive patterns in function' error at compile time?
16:42:21 <dibblego> bsmntbombdood, only a warning (since general coverage is equivalent to solving the halting problem)
16:42:45 <bsmntbombdood> ah
16:43:20 <bsmntbombdood> even without guards?
16:43:29 <dibblego> even then
16:43:40 <dibblego> such a language would be called a total language. Haskell is not a total language
16:44:01 <bsmntbombdood> interesting
16:44:38 <blackdog> dibblego: that's only if you're trying to be precise, i think - you could err on the side of just making sure every patternmatch possibility is statically covered
16:44:39 <monochrom> http://www.vex.net/~trebla/tmp/zero.cgi :)
16:44:56 <dibblego> blackdog, what does it mean to not be precise?
16:44:57 <blackdog> overly conservative in a dynamic sense, but safe
16:45:19 <kosmikus> Coq is total. Agda is (more or less) total. And yes, they are overly conservative.
16:45:31 <dibblego> there is this if you're interested http://community.haskell.org/~ndm/catch/
16:46:10 <bsmntbombdood> what will the warning check then?
16:46:20 <dibblego> exhaustiveness
16:46:22 <bsmntbombdood> do is end up giving false negatives or false positives?
16:46:57 <bsmntbombdood> s/do is/does it/
16:47:39 <blackdog> bsmntbombdood: it might complain about errors that can't come up.
16:48:00 * blackdog has a weird blind spot about the difference between false positive and false negative :/
16:48:15 <dibblego> bsmntbombdood, http://paste.pocoo.org/show/307215/
16:52:00 <bsmntbombdood> ok
17:17:11 <gwern> @wn invidious
17:17:13 <lambdabot> *** "invidious" wn "WordNet (r) 2.0"
17:17:13 <lambdabot> invidious
17:17:13 <lambdabot>      adj : containing or implying a slight or showing prejudice;
17:17:13 <lambdabot>            "discriminatory attitudes and practices"; "invidious
17:17:13 <lambdabot>            comparisons" [syn: {discriminatory}]
17:21:32 <gwern> > 12 * 3500
17:21:33 <lambdabot>   42000
17:25:55 <ddarius> > 7 * 5^3 * 2^2
17:25:55 <lambdabot>   3500
17:27:37 <zygoloid> > map (toEnum.(+65)) [4,8,15,16,23,42] :: String
17:27:38 <lambdabot>   "EIPQXk"
17:31:32 <ujihisa> > map (toEnum . (+65)) [7, 4, 11, 11, 14] :: String
17:31:33 <lambdabot>   "HELLO"
17:51:08 <smerz> hey guys i got a simple question
17:51:12 <smerz> pasToeOpElkElement :: [Fun]->[Int]->[Int]
17:51:28 <smerz> [fun] is not right. but the first variable needs to be a function :|
17:51:35 <kmc> what kind of function?
17:51:36 <ion> “pasToeOpElkElement”? :-D
17:51:40 <smerz> yeah lmao
17:51:41 <kmc> what does it take and what does it return?
17:51:48 <smerz> uni course. they make us prog map function lol
17:51:55 <smerz> the function is
17:51:59 <smerz> Int->Int
17:52:05 <kmc> also why is it in brackets? is it a list of functions?
17:52:09 <smerz> oh
17:52:10 <smerz> no
17:52:12 <monochrom> (Int -> Int) -> [Int] -> [Int]
17:52:13 <smerz> not a list of functions
17:52:16 <kmc> pasToeOpElkElement ::  (Int -> Int) -> [Int] -> [Int]
17:52:20 <smerz> ah
17:52:21 <smerz> thanks
17:53:19 <smerz> awesome that did the trick :)
17:53:32 <monochrom> types are very logical
17:53:57 <kmc> monochrom, my friends Curry, Howard, and de Bruijn would agree
17:54:00 <smerz> yeah. haskell seems nicer than ocaml so far :D
17:54:19 <kmc> smerz, I prefer Haskell although it's good to know both
17:54:19 <hpc> smerz: pasToeOpElkElement = map
17:54:24 <hpc> :t map
17:54:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:54:26 <kmc> Haskell's syntax is a lot nicer
17:54:35 <smerz> i  know it's map function
17:54:36 <kmc> i do miss some ocaml features like parametrized / first-class modules
17:55:41 <smerz> for one the haskell compiler gives usable info
17:55:47 <smerz> well more so than ocaml i find :)
17:56:43 <kmc> heh
17:56:50 <kmc> ocaml is more usable if you speak french
17:57:01 <kmc> we had to do a project compiling Lisp to the OCaml VM
17:57:06 <kmc> which is /only/ documented in french
17:57:12 <smerz> oh
18:02:08 * hackagebot JSON-Combinator 0.1.2 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.1.2 (TonyMorris)
18:05:38 <cole_> I have a question: What is "Var" called in the following: "data Factor = Int Int | Var String"?
18:05:47 <dibblego> cole_, data constructor
18:05:56 <cole_> What's Factor called?
18:05:59 <kmc> type
18:06:06 <kmc> or "type constructor", but it has no arguments here
18:06:09 * hackagebot JSON-Combinator-Examples 0.0.1 - Example uses of the JSON-Combinator library.  http://hackage.haskell.org/package/JSON-Combinator-Examples-0.0.1 (TonyMorris)
18:06:14 <cole_> What's the whole thing called, a type declaration?
18:06:23 <kmc> yeah or a data declaration
18:06:34 <kmc> the declaration which uses the keyword "type" doesn't declare a new type
18:06:37 <kmc> "data" does
18:06:42 <cole_> Is it an "algebraic type declaration?"
18:06:45 <kmc> sure
18:06:52 <kmc> Factor is an algebraic type
18:07:07 <cole_> What's the "algebraic" mean?
18:07:22 <kmc> it's built as a "sum" of "products"
18:07:34 <kmc> the sum is the choice between the different constructors
18:07:44 <kmc> the product is how each constructor holds potentially multiple fields
18:08:09 <cole_> My conception of sum of products: "2*2 + 3*3"
18:08:15 <cole_> Very different.
18:08:15 <kmc> yes, it's like that
18:08:32 <dibblego> not too different actually :)
18:08:35 <kmc> for example if type A has two different values and type B has three different values
18:08:48 <kmc> then "data Foo = Bar A A | Baz B B" has 2*2 + 3*3 different values
18:08:53 <kmc> (ignoring undefined values)
18:10:55 <kmc> also you can take the "derivative" of a one-parameter type constructor
18:11:01 <kmc> following the usual sum and product rules
18:11:35 <kmc> and what you get is a "one-hole context" for the type; a type which represents the original type + a cursor of a "current position" within that structure
18:11:58 <kmc> also called a "zipper"
18:25:30 <revenantphx> wait, how does a zipper relate to a derivative?
18:26:11 <revenantphx> And what kind of derivative?
18:26:59 <kmc> http://en.wikipedia.org/wiki/Zipper_(data_structure) http://en.wikibooks.org/wiki/Haskell/Zippers
18:27:59 <revenantphx> I don't know about fixed points or any of that yet :(
18:28:45 <revenantphx> I should read that part more thoroughly.
18:29:40 <kmc> i wrote a thing about fixed points
18:29:45 <kmc> http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
18:30:12 <revenantphx> "char* main"
18:30:12 <djahandarie> That was more about going from fixed points to more interesting things though, wasn't it? :P
18:30:13 <revenantphx> really?
18:30:18 <revenantphx> char *main :P?
18:30:46 <kmc> fuck that noise
18:30:55 <revenantphx> int a, b, *c;
18:31:05 <kmc> don't write code like that
18:31:12 <kmc> don't declare variables of different types within the same statement
18:31:17 <revenantphx> :P
18:31:17 <kmc> i know you can, that doesn't mean you should
18:31:20 <revenantphx> Well yeah.
18:31:31 <revenantphx> Still, I prefer putting the asterisk on the right out of habit.
18:31:59 <kmc> i follow the style of whatever project i'm working on
18:32:05 <revenantphx> always a good idea 
18:32:08 <kmc> but for my own code i write "type name"
18:32:15 <kmc> the * is part of the type obviously
18:32:48 <revenantphx> * is part of the type, but it "belongs" to the name.
18:32:53 <revenantphx> I find it a bit weird.
18:33:03 <kmc> how does it "belong" to the name
18:33:06 <kmc> who says
18:33:12 <revenantphx> In how it's parsed.
18:33:13 <kmc> and does it "belong" any more than "int" does?
18:33:18 <revenantphx> It's probably a GCC thing that spread.
18:33:24 <kmc> no i understand that C allows you to write "char *main = ..."
18:33:25 <revenantphx> I don't think there's any good logic behind it.
18:33:31 <kmc> and no it's not a GCC thing, that's part of the original C
18:33:44 <kmc> i understand this is allowed; i think it's dumb and i avoid it
18:34:06 <revenantphx> at least it's not "type * name"
18:34:29 <revenantphx> All I know is it's parsed as type (*name) either way, and that's how I've been doing it forever.
18:34:36 <revenantphx> Doesn't really matter at the end of the day.
18:34:40 <kmc> yay Wadler's Law
18:35:11 <revenantphx> It's also a bit nicer when you declare multiple pointers.
18:35:45 <revenantphx> i.e) struct sockaddr *a, *b
18:35:53 <revenantphx> (to be specific about a case where you'd use it)
18:36:06 <revenantphx> I find "type *name" let's you be more consistent, that's all I suppose.
18:36:11 <kmc> that doesn't make sense to me
18:36:14 <kmc> the * is part of the type
18:36:21 <revenantphx> I agree.
18:36:24 <kmc> a, b, c :: Ptr SockAddr
18:36:30 <kmc> Ptr a, Ptr b, Ptr c :: SockAddr
18:36:33 <kmc> which of these makes more sense
18:36:41 <revenantphx> the first?
18:36:43 <revenantphx> I never said it was a good thing XD
18:36:52 <revenantphx> I agree with you it doesn't make sense allways.
18:36:58 <kmc> You said "it's a bit nicer when you declare multiple pointers"
18:37:17 <revenantphx> Yes.
18:37:28 <kadoban> kmc: well when you're using C, you get used to making the best of a bad situation
18:37:41 <revenantphx> kadoban: so true... >_>
18:37:49 <revenantphx> I think of it as "a and b are pointers to a `struct sockaddr`"
18:38:11 <revenantphx> In the end, since it's in C, it's unlikely anyone other than you will _ever_ understand the code anyways.
18:38:49 <djahandarie> Only if you're writing something that no one else cares about
18:39:14 <revenantphx> or that no one else cares to read.
18:39:49 <sipa> kmc: the * is not part of the type, at least not the way it is intended
18:39:56 <kmc> and why not?
18:40:08 <sipa> you declare "*c" to be an int
18:40:17 <kmc> that's dumb though
18:40:24 <revenantphx> sipa: See, I'd see "int *c" to be declaring "c to contain an int"
18:40:29 <revenantphx> It logically makes more sense as part of the type, but it's actually parsed as part of the name.
18:40:32 <revenantphx> Yes, a lot of C is dumb kmc.
18:40:38 <sipa> it may have been a bad decision, yes
18:40:44 <sipa> and i think it is
18:40:46 <kmc> i understand the logic behind it, but I don't agree
18:41:05 <sipa> but C is a lot more consistent if you look at it that way
18:41:13 <revenantphx> I wouldn't even say "int*" is a type. 
18:41:17 <sipa> in particulat when you're mixing pointers and arrays
18:41:27 <dankna> we also have to view this in historical context - I wouldn't say it was kmc's fault per se, since there was no alternative at the time
18:41:29 <ion> const int *const a;
18:41:37 <revenantphx> ion: goddamit.
18:41:39 <dankna> even dmr hates type qualifiers
18:42:11 <dankna> er I meant Kernighan, not kmc :)
18:42:20 <revenantphx> In my book, a pointer is of the pointer type. The type associated with the pointer is just a convenience for the programmer/compiler.
18:42:47 <revenantphx> int* and char* are only different in that the compiler forces you to cast between them.
18:42:50 <ion> Read from right to left: a is a constant pointer to int that is constant :-P
18:43:06 <revenantphx> ion: I can read it ;)
18:43:08 <revenantphx> I've seen worse.
18:43:11 <dankna> I like Haskell's take on the situation.  "pointer" is just another type constructor.  the source of the confusion is that in C it's the only type constructor of a non-arity-one kind.
18:43:19 <revenantphx> ion: mix in function pointers and it gets worse.
18:43:22 <ion> I didn’t say you can’t. I didn’t address the message to you either. :-)
18:43:41 <revenantphx> dankna: * as a type constructor... I never thought of that. heh.
18:44:04 <dankna> well, it is one :)
18:44:37 <revenantphx> const int (*(*foo)(const void *))
18:44:43 <revenantphx> stuff like that is irritating.
18:44:54 <kmc> yeah, * is a type constructor.  in Haskell we call it Ptr
18:44:55 <kmc> :k Ptr
18:44:56 <lambdabot> Not in scope: type constructor or class `Ptr'
18:45:01 <dankna> pointer to function taking a pointer to (const) data of unspecified type and returning a pointer to an int
18:45:03 <ion> Function pointers aren’t that bad when using typedefs in the way any somewhat sane C programmer would do. :-)
18:45:04 <dankna> did I get that right?
18:45:20 <kmc> just run 'cdecl'
18:45:20 <revenantphx> pointer to const int.
18:45:36 <revenantphx> ion: yep.
18:45:44 <revenantphx> typedefs make function pointers bearable thankfully.
18:46:11 <kmc> and the typedef syntax makes no sense until you think of it as a fake variable declaration
18:46:22 <revenantphx> what do you mean kmc?
18:46:31 <revenantphx> for function pointers?
18:46:36 <kmc> yeah
18:46:40 <revenantphx> I never really made sense of it TT_TT
18:46:45 <revenantphx> just memorized it and rolled with it.
18:47:20 <benmachine> why are we even arguing about this :P
18:47:20 <kmc> i mean that "typedef stuff" is the same as "stuff" except that you get a type synonym rather than a variable of that type
18:47:28 <kmc> i don't think anyone's arguing
18:47:32 <kmc> it is pretty off-topic though
18:47:47 <revenantphx> So guys, how about them FFI's
18:48:18 <dankna> we aren't arguing
18:48:22 <dankna> we're discussing
18:48:33 <dankna> and anyone who says it's an argument is WRONG! :D
18:48:47 <revenantphx> YEAH.
18:48:54 <dankna> anyway I think it has some value to think about how we would model C in Haskell's terms
18:54:21 <revenantphx> mm.
18:59:24 * hackagebot mongoDB 0.9 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.9 (TonyHannan)
19:02:52 <adnap> Hello!  How can I go over all the elements of a Tree (like map) but with an accumulator (like fold)?  I see that Tree is an instance of Foldable, but I'm not sure if it is possible to resconstruct the Tree as a go.
19:04:34 <kmc> i think you'd need Traversable to map and reconstruct a tree
19:04:54 <kmc> :t Data.Traversable.mapAccumR
19:04:54 <lambdabot> forall a b c (t :: * -> *). (Data.Traversable.Traversable t) => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
19:07:16 <adnap> kmc: Oh, thanks!  I was a little unsure how to use that at first, but I see now what each variable is supposed to be.
19:07:45 <adnap> kmc: I guess I didn't realize that it's automatically taking your c's and putting them in a new tree.
19:08:08 <kmc> well, it returns (a, t c)
19:08:10 <kmc> here t = Tree
19:08:16 <adnap> Yeah, I see that.
19:08:39 <kmc> *nod* it's hard to work with functions this abstract
19:08:59 <kmc> you think really hard and then write a tiny amount of code which does everything you need
19:09:18 <spvensko> hi, i realize that you can download a pdf version of "Learn You a Haskell" but I was wondering if there is a PDF version floating around with the included cartoons. Call me childish but they make the book even more entertaining.
19:09:30 <adnap> Yeah, I think it's just harder to identify a function such as this as the one you need as opposed to figure out how to use it once you've found it.
19:10:13 <kmc> Yeah.
19:10:14 <adnap> It's pretty funny how close the name is to what I requested though!  I don't know how I missed it. XD
19:10:30 <kmc> it's also close to Data.List.mapAccumR
19:10:54 <adnap> Well, I've never used either of those functions, or perhaps I would have caught on!
19:12:16 <kmc> i've used them, like, once ever
19:12:26 <revenantphx> hey kmc, do you have a good name for something that could be an error? (Either Error MyThing)
19:12:31 <revenantphx> I'm using "Fallible" right now.
19:12:41 <revenantphx> Fallible MyThing => Either Error MyThing
19:12:44 <Zao> Scary.
19:12:50 <revenantphx> Scary is a good name.
19:12:54 <kmc> you mean "type Falliable t = Either Error t" ?
19:13:04 <revenantphx> type Fallible = Either Error
19:13:06 <Veinor> JSON uses Result
19:13:18 <revenantphx> Result is taken by libs I'm using.
19:14:22 <adnap> why don't you just use Maybe?
19:14:28 <adnap> Maybe MyThing
19:14:31 <kmc> because you care what the error is?
19:14:32 <revenantphx> Because Error can be multiple things.
19:14:37 <adnap> oh
19:14:48 <revenantphx> Maybe doesn't tell me anything beyond that it failed.
19:14:54 <revenantphx> That's less useful than an STL error.
19:14:58 <kmc> haha
19:15:04 <revenantphx> Do you have a better name though kmc?
19:15:04 <adnap> okay :)
19:15:54 <revenantphx> A few ideas I had floating around, "Hopefully", "IfImLucky", "MaybeError"
19:16:03 <adnap> Why don't you just keep the long name?
19:16:11 <adnap> I think it's better than Fallible
19:16:18 <revenantphx> I'm considering that.
19:16:25 <revenantphx> I don't want to leave it though :\ dunno
19:16:56 <revenantphx> besides
19:17:20 <revenantphx> if I make it "Fallible Something" etc etc, I can change the Error types name or something without rewriting other stuff.
19:17:24 <revenantphx> Not especially pressing though.
19:18:05 <adnap> Hm... I don't see any other appealing options in the thesaurus.
19:18:19 <revenantphx>  Conceivably
19:18:20 <revenantphx> :P
19:18:26 <adnap> ew
19:18:33 <revenantphx> (i'm just messing with you now)
19:18:53 <adnap> errant?
19:19:03 <revenantphx> No...
19:19:10 <adnap> whimsy? :P
19:19:17 <revenantphx> Silly?
19:19:22 <kmc> OCaml calls it "option"
19:19:33 <revenantphx> Troublesome
19:19:35 <revenantphx> XD
19:19:37 <mikeg> Result' ?
19:19:43 <revenantphx> mikeg: definitely not.
19:20:05 <revenantphx> I need to get some links to iteratee stuff.
19:20:19 <revenantphx> In the end, I want to use Binary/Cereal... but I want to use strict io
19:20:22 <adnap> how about Unstable?
19:20:32 <revenantphx> adnap: that indicates to me it could change, so no.
19:20:40 <revenantphx> Thats more in the vein of what I want though.
19:20:50 <revenantphx> Kooky
19:20:59 <adnap> Go with Fallible
19:21:06 <adnap> I think that's the best so far.
19:21:19 <revenantphx> I ended up going with it because it seemed to indicate "this could fail"
19:21:21 <revenantphx> >_>
19:21:25 <adnap> yep
19:21:38 <adnap> trust your instincts! :P
19:22:05 <revenantphx> Anyways, if I were to go with iteratees instead of lazy io, could I use cereal for the actual parsing?
19:22:20 <kmc> type OhShit t = Either Error t
19:22:20 <revenantphx> There are a few specific concerns I have.
19:22:25 <revenantphx> XD
19:23:08 <revenantphx> Mainly how cereal's handling of incomplete values works.
19:23:21 <revenantphx> In that aspect, attoparsec's incremental parsing is way nicer.
19:23:51 <revenantphx> However, if I use attoparsec, then I have to have completely different schemes for encoding/decoding, and I have to write up some Parser routines for specificly sized integers.
19:24:03 <revenantphx> That may not be a bad idea anyhow.
19:24:18 <revenantphx> (Parser routines for integers)
19:36:54 <revenantphx> I feel sorry for whoever wrote this
19:36:54 <revenantphx> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/src/Data-Tuple-Select.html#sel1
19:37:00 <revenantphx> I hope they had a script do it TT_TT
19:37:59 <kmc> haha
19:38:15 <kmc> show that to the next person who claims Haskell is boilerplate-free
19:38:32 <kmc> "---- Machine generated code below"
19:38:48 <mikeg> revenantphx: check this one: http://svn.codehaus.org/groovy/trunk/groovy/groovy-core/src/main/org/codehaus/groovy/runtime/ArrayUtil.java
19:38:58 <kmc> it's really rare to need a tuple bigger than 2
19:39:08 <kmc> if you need one you should probably define a new type instead
19:39:09 <revenantphx> What. The. Fuck.
19:39:20 <revenantphx> I just need 3 tuple stuff TT_TT
19:39:27 <revenantphx> Up to 249 arguments? what?
19:41:03 <revenantphx> @where hoogle
19:41:03 <lambdabot> http://haskell.org/hoogle
19:41:32 <adnap> i wish they could get hoogle.com.  i'm always getting this hypocrisy web page
19:43:27 <revenantphx> is there any way to JUST import part of Prelude qualified?
19:43:41 <revenantphx> like, one function.
19:43:51 <kmc> yes
19:43:59 <kmc> import qualified Prelude(foo, bar) as P; import Prelude
19:44:04 <revenantphx> perfect.
19:44:04 <kmc> or
19:44:07 <kmc> import qualified Prelude(foo, bar) as P; import Prelude hiding(foo, bar)
19:45:02 <revenantphx> import qualified Prelude(take) as P; import Prelude
19:45:07 <revenantphx> parse error on input 'as'
19:45:08 <revenantphx> 0.o
19:46:07 <jonathan_> anyone know package that has arbitrary instance for generating valid urls?
19:46:18 <revenantphx> from what?
19:46:39 <jonathan_> I just read that comment I was horrified how little sense it made
19:46:53 <jonathan_> I just want to generate urls for quickcheck
19:47:02 <jonathan_> something like newtype url
19:47:13 <jonathan_> with an Arbitrary instance
19:47:41 <revenantphx> No clue :D.
19:48:20 <jonathan_> oh well hopefully i'm making sense
19:48:35 <revenantphx> hey kmc, how could I make this endianness specific?
19:48:35 <revenantphx> https://gist.github.com/747986
19:49:13 <revenantphx> Is there a #ifdef I can use for endianness?
19:52:34 <revenantphx> kmc?
19:52:46 <kmc> i don't know, sorry
19:52:59 <revenantphx> I could handroll a quick checker with the old check.
19:53:34 <revenantphx> (store 0x00000001 as a literal, peek the "last" byte. If it's one, its big endian, if its zero it's little endian)
19:53:53 <revenantphx> (store (0x00000001 as a literal), peek the "last" byte. If it's one, its big endian, if its zero it's little endian)
19:54:00 <revenantphx> that made no sense without those parens
20:03:56 <revenantphx> :D
20:27:37 <fhobia> i'm using the HTTP library, and it sometimes calls the fail function terminating my program - is there anyway to catch that failure or i can recover without abruptly terminating the program?
20:27:50 <fhobia> s/or/so/
20:28:03 <kmc> you can catch it within an IO action
20:28:10 <kmc> see the docs for Control.Exception
20:28:19 <fhobia> thanks kmc 
20:30:09 <adnap> does this function already exist somewhere? branches :: Tree a -> [[a]]
20:30:10 <adnap> branches (Node x []) = [[x]]
20:30:10 <adnap> branches (Node x ts) = map (x:) $ ts >>= branches
20:30:50 <ion> @hoogle Tree a -> [[a]]
20:30:51 <lambdabot> Data.Tree levels :: Tree a -> [[a]]
20:30:51 <lambdabot> Data.Tree flatten :: Tree a -> [a]
20:30:51 <lambdabot> Data.Graph.Inductive.Basic postorder :: Tree a -> [a]
20:31:02 <adnap> nope
20:31:17 <adnap> that's really strange
20:31:26 <kmc> yeah the Data.Tree API is kind of weak
20:31:46 <adnap> maybe i should add it?  does it seem useful?
20:31:47 <kmc> though see Traversable and Foldable
20:33:06 <adnap> do people more commonly use something else as an alternative to trees in haskell?
20:33:25 <kmc> well if you want a binary search tree, you'd use Data.Map
20:33:33 <kmc> if you want a tree for some other purpose, it depends
20:33:42 <adnap> i need an n-ary tree
20:33:52 <adnap> or something that can stand in for that
20:34:14 <adnap> so far Tree seems to be fine, but i was just curious
20:45:32 <ddarius> I don't think Data.Tree is used very much at all.
20:45:51 <ddarius> It's rare that it is exactly what you want, and it is -very- easy to roll your own tree type.
20:47:07 <Pseudonym> That's a key point.  If you need new abstractions, it's often easier to roll your own.
20:47:12 <Chaze> is there a built-in 'orderedElem' function? http://hpaste.org/42441/orderedelem
20:47:13 <Pseudonym> Abstractions are cheap.
20:47:56 <Pseudonym> If you need balancing as you'd find in a search tree, then obviously that's trickier.
20:48:10 <Pseudonym> But if there are no complex structural invariants to maintain, it's often easier just to do it.
20:51:15 <nsmryan> Chaze: A quick hoogle search of the type suggests there is not.
21:04:35 <Chaze> @pl (\a b -> even a && even b)
21:04:36 <lambdabot> (. even) . (&&) . even
21:05:12 <Chaze> @pl liftM2 (&&) even even
21:05:12 <lambdabot> liftM2 (&&) even even
21:06:47 <ddarius> maybe Nothing (== e) . listToMaybe . dropWhile (<= e)
21:06:57 <ddarius> s/Nothing/False
21:07:27 <ddarius> And I guess that should be < not <=.
21:07:59 <Chaze> ddarius: yeah, that should work
21:08:05 <Chaze> any difference in efficiency?
21:08:48 <ddarius> Not any asymptotic difference.
21:41:04 <phao> this language is cool =)
21:42:44 <ddarius> Unfortunately you came too late and we decided to shut down production due to lack of interest.
21:43:49 <phao> =)
21:46:17 <Zao> Heh, some of my students wish in their assignment reports that we'd migrate from SML to Haskell next year :D
21:46:31 <phao> you give lectures on programming?
21:46:59 <Zao> TA for a course in programming languages.
21:48:13 <phao> Cool
21:50:44 <djahandarie> Undergraduates that know Haskell? Cool
21:51:37 <phao> djahandarie, there is a course, called functional programming, in a university here in brazil
21:51:42 <phao> first semester course
21:51:45 <phao> uses haskell
21:52:35 <edwardk> hrmm, can someone more familiar with the guys of attoparsec than me tell me what the point of the adds/noAdds stuff is in attoparsec internals?
21:52:38 <edwardk> er guts of
21:54:18 <djahandarie> Seems like the question is 'what is the point of S'?
21:54:50 <edwardk> djahandarie: well, at first i thought that it was something like s ++ t, with the addition deferred, but its not actually being done like that
21:55:38 <edwardk> now, put leaves the 'add' part of S alone
21:56:22 <djahandarie> plus is the one that affects it
21:56:32 <edwardk> and a few other things actually swap explicitly blank it, but i'm trying hard to find any actual references to it
21:57:00 <djahandarie> It's the Monoid instance, so anything that mappends the S?
21:57:21 <edwardk> but the only thing that mappends the state is when it goes to fetch more input
21:57:50 <edwardk> ahh
21:57:53 <edwardk> addS
21:58:15 <edwardk> adS (S s0 a0 c0) (S _s1 a1 c1) = S (s0 ++ a1) ...
21:58:18 <djahandarie> Isn't that what we were talking about? :P
21:58:37 <edwardk> that is the first thing that actually moves the a into s position
21:58:49 <edwardk> i was not seeing that line
22:00:08 <djahandarie> I doubt I'm being of any help here anyways, so I'm checking out. Night.
22:02:04 <ddarius> edwardk: What's been up with you?
22:02:47 <edwardk> ddarius: not much, hacking on scala, giving up in frustration, hacking on scala, repeat.
22:03:30 <dibblego> I used to do that a lot
22:03:55 <edwardk> have most of attoparsec ported over as a consequence of my latest frustrations
22:04:31 <edwardk> next i get to see if i can bolt a packrat layer on top, since i don't have to concern myself with side-effects as much ;)
22:05:34 <edwardk> but i'm somewhat worried about the native scala packrat parser, because i recall reading a paper showing that left-recursion hack they reference has been shown not to always find the correct parse
22:05:46 <edwardk> i've lost the reference though
22:07:23 <ddarius> Just prove it again.
22:09:18 <etpace> anyone here used jmacro?
22:09:28 <etpace> getting a "No instance for (ToExp Hs.Exp) when installing
22:14:19 <ddarius> edwardk: Any plans for Boston HUG?
22:19:16 <edwardk> ddarius: looking like early january. david spivak and i have kept having scheduling conflicts
22:19:39 <edwardk> in other news, we should finally have recording equipment 
22:20:09 <ddarius> Just in time for me not to be recorded by it.  Excellent.
22:20:31 <edwardk> hah
22:23:43 <ddarius> edwardk: So when are you going to start hacking on the Scala compiler directly?
22:24:07 <edwardk> ddarius: that is more yak shaving than i'm willing to engage in at this point ;)
22:24:24 <edwardk> right now i just want to get my kata-in-scala interpreter working
22:24:39 <edwardk> which i'm using as an excuse to learn the scala-ey way to do parsing, etc.
22:25:09 <edwardk> which mostly seems to be "beat your head on it for a weekend, then port a haskell library"
22:25:19 <ddarius> edwardk: Have you looked at Gilad Bracha's Newspeak language at all?
22:25:55 <ddarius> I tried that for C# once.  It didn't work so well.  But that was C# 2.0.  I think it would work now.  And Scala is not C#.
22:26:00 <ddarius> (Yay sentence fragments!)
22:26:01 <edwardk> a little bit, but not as much as i should have
22:27:03 <ddarius> edwardk: It's a pretty clean design.  Not too many "new" ideas, but a pretty good realization of several good ideas.  He'll probably fuck it all up when he adds concurrency though.
22:27:09 <ddarius> (But maybe not.)
22:27:10 <edwardk> hah
22:27:55 <edwardk> i thin i haven't looked at it since around 2008, so it'll do me good to catch up on it
22:28:21 <ddarius> I don't think it is moving that quickly, so you probably haven't missed much (unless a lot has happened since last I looked.)
23:24:38 <nCdy> Hello
23:24:52 <nCdy> How can I works with Excel ? :)
23:26:08 <medfly> ?
23:26:37 <nCdy> I want to read -> calculate -> write from/to excel file ) is it possible with haskell ? )
23:27:16 <medfly> excel can read CSV files
23:27:27 <medfly> and write
23:29:04 <nCdy> no ...
23:29:12 <nCdy> I need to work directly with xls
23:31:29 <Zao> nCdy: Unless there's a module for it, you're in for a world of pain.
23:31:40 <Zao> Heck, you're in for a world of pain even if there _exists_ a module for it :)
23:32:13 <nCdy> Zao
23:32:38 <nCdy> that's sad )
23:32:59 <nCdy> Zao so I think qt Haskell is my only the way
23:33:31 <Zao> Eh?
23:33:55 <nCdy> Zao if I can use qt libs to work with excel should be fine
23:34:28 <nCdy> offtopic : I hate Leksah
23:37:05 <hamishmack> nCdy: Why?
23:37:51 <nCdy> hamishmack: I need to press 10 different buttons to rebuild my program
23:38:29 <nCdy> hamishmack: and after all I can't understand for what I got right side of IDE , I use it like a notepad with highlighings )
23:40:13 <hamishmack> nCdy: Ctrl+B is not working?
23:40:45 <nCdy> hamishmack: it's working
23:40:52 <hamishmack> nCdy: What are you buttons are you pressing?
23:40:55 <nCdy> hamishmack: but it's not rebuild
23:41:19 <lars9> @hoogle shuffle
23:41:19 <lambdabot> No results found
23:41:26 <lars9> oops, no shuffle?
23:41:50 <hamishmack> nCdy: You want to clean and configure first?
23:42:23 <nCdy> hamishmack: I use about half of buttons on package menu ) clean -> config -> build ... yes and then I need to press this strange button to load/upload ghci )
23:43:38 <nCdy> hamishmack: but first I need to install qt haskell ...
23:44:00 <hamishmack> nCdy: when in ghci mode Ctrl+B should do a :reload
23:44:36 <hamishmack> nCdy: are you working with multiple pacakages?
23:45:11 <hamishmack> nCdy: :reload will only work on the package that was active when ghci mode was started
23:46:23 <nCdy> hamishmack: seriosly I've got a lot of questions about leksah ... I can't just tell you what exactly I can't understand ) but is there some easy steps how to rebuild my project ?
23:46:26 <hamishmack> When you are not in ghci mode build does a "runhaskell Setup.hs build" on the changed package
23:46:55 <hamishmack> nCdy: and the packages in your workspace that depend on it
23:48:02 <hamishmack> nCdy: If you are not in GHCi mode it should rebuild automatically as you type
23:48:18 <hamishmack> If you are in ghci mode it should :reload
23:48:55 <hamishmack> nCdy: What platform are you on?
23:49:26 <nCdy> hamishmack: Windows .
23:49:42 <hamishmack> ghc 6.12.1 or 6.12.3?
23:49:44 <nCdy> hamishmack: but using linux also
23:49:59 <Chaze> @pl (\f a -> f a a)
23:49:59 <lambdabot> join
23:50:09 <Chaze> ..oh!
23:50:56 <nCdy> hamishmack: 6.12.3
23:50:57 <Chaze> i only thought of join as join f = f >>= id
23:51:05 <hamishmack> nCdy: Official Windows build is for 6.12.1 is a dev windows build Leksah 0.9.0.0 for ghc 6.12.3
23:51:26 <Chaze> how is >>= defined in the function monad again?
23:51:47 <nCdy> hamishmack: my leskah is 0 8 0 6
23:52:01 <nCdy> hamishmack: should I download new ?
23:52:03 <hamishmack> nCdy: 0.9.0.0 build is worth trying
23:52:52 <hamishmack> nCdy: It has some more logic in there to try to make it easier to set up workspaces
23:53:14 <hamishmack> nCdy: Also the metadata is likely to work better since it was built with ghc 6.12.3
23:53:18 <nCdy> hamishmack: where to get it ?
23:54:37 <hamishmack> nCdy: http://leksah.org/packages/leksah-0.9.0.0.exe
23:55:09 <nCdy> hamishmack: thank you very much )
23:56:04 <nCdy> hamishmack: can you also help me to build qtHaskell ? )
23:56:08 * smerz had a problem. and i fixed it. http://nopaste.php-q.net/370519             and the nopaste showed me.             whitespaces argh :D:D
23:56:35 <hamishmack> nCdy: I've not tried it yet (leksah uses Gtk2Hs)
23:56:49 <Auxentiu97> So.....
23:57:03 <Auxentiu97> I wanna get into this, but dunno where to start..??
23:57:09 <Auxentiu97> Any help?
23:57:48 <nCdy> hamishmack: but I need to work with Excel and qt can be a great helper with that for me
23:57:50 <Axman6> @where lyah
23:57:50 <lambdabot> http://www.learnyouahaskell.com/
23:57:56 <ion> ncdy: I take it you’re Russian ? )))))))))))
23:57:57 <Axman6> Auxentiu97: Start there! :)
23:58:22 <nCdy> ion: I am so
23:58:29 <Auxentiu97> where?
23:58:33 <Axman6> @where lyah
23:58:34 <lambdabot> http://www.learnyouahaskell.com/
23:58:37 <Axman6> there
23:58:38 <Auxentiu97> oh kk
23:59:58 <blenderer> From the leksah site: "First and most important Haskell is different from mainstream imperative and object oriented languages and a dedicated IDE may exploit this specialness."
