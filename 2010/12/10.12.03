00:04:48 <oconnore> every Haskell tutorial I can find only uses single line guards. So how do I do something like this? http://paste.lisp.org/display/117290
00:05:14 <ndrsndrs> put the where after all the guards, or use a let
00:05:52 <oconnore> that doesn't solve my problem. How do I put a multiple line expression after a guard.
00:06:16 <ndrsndrs> oh. then, just indent it more than the |
00:06:28 <oconnore> but look at my paste, I did that
00:06:49 <dskippy> Put your where on the next line
00:06:49 <oconnore> it says >> unexpected '|' <<
00:06:53 <Boxo> You can use a lot, you can't use a where. Wheres are special
00:06:57 <Boxo> s/lot/let
00:07:11 <dskippy> oconnore: res must be indented past the where.
00:07:19 <ndrsndrs> the where scopes over all the guards, and has to go after the last one
00:07:36 <dskippy> oops, right. That too
00:08:03 <oconnore> now it says "unexpected keyword let"
00:09:05 <oconnore> http://paste.lisp.org/display/117290#1
00:09:27 <dskippy> let x = 3 in x+x
00:09:28 <Boxo> let ... in ...
00:09:30 <dskippy> you need an in
00:09:47 <ndrsndrs> | x < 10 = let res = sumBetween(1, x) in res
00:10:18 <dskippy> oconnore: Also you can't put the res before the let.
00:10:53 <oconnore> oh, ok
00:11:09 <oconnore> it works now
00:11:12 <oconnore> thanks
00:11:26 <dskippy> :)
00:59:56 <rothwell> 'lo. any recommendations for a JSON parser? i need it for some one-off throwaway thing
01:00:03 <rothwell> there are too many on hackage to evaluate
01:06:29 <augur> rothwell: pick the highest rated one!
01:06:43 <rothwell> augur: hehe
01:06:49 <rothwell> there are ratings?
01:07:34 <ndrsndrs> rothwell: write another one!
01:07:52 <rothwell>  /o\
01:07:57 <shachaf> Use a YAML parser!
01:08:23 <ndrsndrs> make up your own markup language and write a parser for that!
01:08:58 <rothwell> use Text.JSON, got it
01:09:15 <ndrsndrs> probably, yeah
01:09:26 <rothwell> just have to parse some nightmarish json from someone else
01:09:35 <rothwell> once that's done, i can forget i ever did it
01:10:15 <shachaf> rothwell: Use JavaScript. :-)
01:10:41 <rothwell> "now i have N problems"
01:10:48 <ndrsndrs> shachaf: and eval(). what could possibly go wrong?
01:12:58 <shachaf> eval('eval(' + json + ')')
01:14:32 <ndrsndrs> perfect!
01:18:48 <Veinor> yeah, i use json
01:18:54 <Veinor> that is, Test.JSON
01:20:00 <ddarius> let json = "eval("++json++")" in json
01:20:49 * ddarius likes how the semantics of appending to an infinite list is const.
01:21:14 <ddarius> (Actually, it's seq.)
01:21:37 <ddarius> (well, flip seq)
01:23:45 <lars9> what's the difference of writing a function inside or outside of GAT's data ABC where ... block?
01:24:29 <augur> ddarius: what
01:24:30 <augur> :|
01:26:14 <lars9> *GADT
01:35:43 <ddarius> "Do you refuse to answer dichotomous questions? ( ) Yes ( ) No"
01:39:19 <quicksilver> lars9: inside the where... block it's a constructor.
01:45:12 * ddarius likes how you can make layout blocks from which you cannot escape.
01:45:14 <Jafet> let ttp = "The " ++ ttp ++ " project" in ttp
01:46:30 <beerpages> Kostenlose mini Homepages für Umfragen, Videos und vielem mehr auf www.beerpages.de - Beispiel: http://www.beerpages.de/view/1P/Magst%20du%20%C3%84pfel%3F
01:46:39 <Elbar> grrr
01:50:37 <Jafet> ich vorziehe meinungspages
02:01:48 <Elbar> ;)
02:10:53 <augur> byorgey! :|
02:11:37 <augur> byorgey, you bastard, i think inverse species are possible >|
02:11:52 <augur> which is to say i think i have an idea of how to define them
02:12:50 <augur> tho now im unsure which of these laws should hold:   enumerate (Inv F) (enumerate F ls) == ls   or   enumerate ((Inf F) . F) ls = ls
02:12:54 <augur> maybe they're the same, who knows
02:16:27 * hackagebot uAgda 1.0.0.2 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.0.0.2 (JeanPhilippeBernardy)
02:17:33 <Watermind> what is happeneing here
02:17:37 <Watermind> I defined, 
02:17:39 <Watermind> (test, n)  = (id, 0)
02:18:09 <Watermind> the type of test now is, test :: GHC.Prim.Any -> GHC.Prim.Any
02:18:12 <Watermind> ?
02:18:36 <quicksilver> really that should be forall a . a -> a
02:18:43 <quicksilver> it's a bug that leaks a GHC implementation detail
02:19:15 <Watermind> also I cannot add a signature  test :: a-> a
02:20:40 <Watermind> let me try making the quantifier explicit
02:21:02 <quicksilver> you need an extention to annotate test, which is in a pattern
02:21:09 <quicksilver> but you can annotate the value tuple or the id
02:21:29 <quicksilver> (test,n) = (id,0) :: (a -> a,Int)
02:22:24 <Watermind> quicksilver: which extension?
02:22:33 <quicksilver> PatternSignatures
02:22:36 <quicksilver> I believe it's called
02:22:43 <Watermind> I see
02:23:46 <Watermind> and why does it fail with this particular error message when trying to add the type signature without that extension
02:24:05 <Watermind> Couldn't match expected type `forall a. a -> a'  against inferred type `a -> a'
02:24:07 <Watermind> ?
02:26:07 <dolio> (id, 0) will be given the type: forall a n. Num n => (a -> a, n)
02:26:46 <dolio> When you annotate test :: forall a. a -> a, that pattern expects the type: forall n. Num n => (forall a. a -> a, n)
02:27:06 <dolio> Which is not the same.
02:27:25 <Watermind> I see your point, but you can substitue 0 by undefined
02:27:43 <Watermind> ok but then you'd have forall a b.
02:29:17 <Watermind> ok I think I got it
02:30:04 <Watermind> so to access each member of the patter you have to instantiate the 'a' therefore removing the quantification
02:30:07 <dolio> You can solve the Any thing by enabling NoMonoPatBinds.
02:31:25 <Watermind> dolio: ok thanks, I'll look into that extension too
02:31:51 <dolio> I'm not really sure why that's even on by default. I guess it's no longer experimental.
02:32:09 <dolio> It's a departure from the standard, I think.
02:32:28 <quicksilver> dolio: Ah. So "Any" is what you get when monomorphic binding requires a specific type, but the expression doesn't force anything more specific?
02:32:39 <ndrsndrs> i thought pattern binds were subject to the MR?
02:32:51 * ndrsndrs finds the report
02:32:57 <dolio> It's what you get when GHC needs to monomorphize an unconstrained type.
02:33:02 * quicksilver nods
02:33:06 <dolio> Because there's no default for those.
02:33:13 <quicksilver> Any = "Something specific but I don't know what"
02:33:22 <dolio> Although () might be less cryptic.
02:34:06 <Watermind> I think I'd be more confused if I saw ()
02:34:17 <quicksilver> ndrsndrs: MR only applies to type-class bounded polymorphism though.
02:34:27 <quicksilver> ndrsndrs: ... in that case you'd get either an error, or a default.
02:34:40 <ndrsndrs> ...of course
02:34:41 <ndrsndrs> sorry
02:34:57 <quicksilver> this is different from ML's value restriction
02:35:13 <dolio> It's a little weird that it isn't an error.
02:35:13 <quicksilver> which is a royal pain, and does apply to parametric polymorphism
02:35:30 <quicksilver> makes it really hard to define combinator libraries in standard ML
02:35:32 <dolio> I think I'd prefer an error to Any.
02:35:52 <quicksilver> dolio: I think it's a gap in haskell98, isn't it?
02:36:03 <quicksilver> by which I mean, the report doesn't mandate what you should do
02:36:32 <dolio> Haskell 98 doesn't require that all pattern bindings be monomorphic unless types are explicitly given.
02:37:07 <ndrsndrs> quicksilver: the value restriction might be what i was thinking of :) sorry about that
02:38:20 <quicksilver> dolio: ah.
02:40:05 <dolio> The only way I can recall getting Any prior to that is doing something like 'r <- newIORef undefined' in the REPL, which required r to be monomorphic, but there was no basis for choosing anything.
02:40:31 <dolio> But that can't happen in a source file that you'd notice.
02:40:46 <quicksilver> well it can't happen in a way that matters.
02:40:58 <quicksilver> it only happens if 'r' is never used, in which case you don't care
02:41:07 <quicksilver> arguably an unused variable like that might be a bug, though ;)
02:41:09 <dolio> Right.
02:41:18 <quicksilver> and merit an error or at least warning.
02:41:28 <dolio> However, with MonoPatBinds, you can write '(f, g) = (id, id)' at the top level in a source file, and get f, g :: Any -> Any.
02:41:47 <quicksilver> dolio: presumably, xs <- newIORef [] would get you [Any] ?
02:42:03 <dolio> Probably. That's a better example.
02:42:24 <ndrsndrs> (it does)
02:42:36 <ndrsndrs> :t newIORef []
02:42:37 <lambdabot> Not in scope: `newIORef'
02:42:47 <ndrsndrs> :t Data.IORef.newIORef []
02:42:48 <lambdabot> forall a. IO (GHC.IOBase.IORef [a])
02:42:50 <Watermind> dolio: that exaple works without MonoPatBinds
02:42:54 <ndrsndrs> well it does in GHC anyway
02:43:07 <dolio> Which?
02:43:17 <Watermind> (f,g) = (id,id)
02:43:58 <dolio> Without MonoPatBinds, f and g will have type a -> a.
02:44:17 <Watermind> ah nevermind sorry you're right
02:44:38 <Watermind> wait
02:44:47 <Watermind> no I don't have it on
02:45:05 <Watermind> dolio: are you sure? I'm getting Any
02:45:18 <dolio> MonoPatBinds is on by default in GHC 7.
02:45:20 <Watermind> I'm not using any extensions
02:45:35 <dolio> And possibly earlier versions.
02:45:39 <Watermind> dolio: ok got it
02:45:41 <dolio> You have to disable it with NoMonoPatBinds.
02:46:04 <Watermind> dolio: I see understood, makes sense
02:48:19 <quicksilver> dolio: the MonoPatBinds webpage suggests that let (f,g) = (id,id) should, indeed, be an error.
02:48:36 <dolio> In the GHC manual?
02:48:55 <quicksilver> no, I misread it.
02:49:02 <quicksilver> the example was applying f at two different types
02:49:08 <quicksilver> that was what was producing the error.
02:49:12 <quicksilver> http://hackage.haskell.org/trac/haskell-prime/wiki/MonomorphicPatternBindings
02:49:31 <edlinde> is there a function to divide a list into left half and right half?
02:51:52 <dolio> Actually, it seems you can't override the monomorphic behavior with explicit signatures.
02:52:04 <dolio> It just turns into the higher-rank/impredictaive problem.
02:53:42 <dolio> @type let (f, g) = (id, id) in f
02:53:43 <lambdabot> forall a. a -> a
02:53:44 <Boxo> > partition odd [0..5]
02:53:45 <lambdabot>   ([1,3,5],[0,2,4])
02:54:45 <edlinde> is there a better implementation for merge sort than --> http://en.literateprograms.org/Merge_sort_(Haskell)#chunk%20def:split
02:54:50 <quicksilver> dolio: it seems Haskell' decided on a different solution http://hackage.haskell.org/trac/haskell-prime/wiki/SpecifyPatternBindingSemantics
02:54:52 <edlinde> was just looking at it
02:55:09 <edlinde> and it seems like it needs a lot of helper functions to partition, merge etc
02:56:10 <Veinor> edlinde: http://www.csc.depauw.edu/~bhoward/courses/0203Spring/csc122/haskintro/
02:57:09 <edlinde> Veinor: thanks that looks much neater
02:59:29 <Veinor> i wonder what the big-O running time on that is given that you need to compute the length
02:59:35 <edlinde> is there a way in Haskell to say  something like I want "X" to represent "x:xs"
02:59:48 <edlinde> hmm
03:00:03 <Veinor> > let f z@(x:xs) = (z,x,xs) in f [1,2]
03:00:04 <lambdabot>   ([1,2],1,[2])
03:00:20 <edlinde> ok cool
03:00:24 <Veinor> can't use X, because initial uppercase means that it's a type
03:00:31 <edlinde> right 
03:00:44 <edlinde> its just that I am doing two more languages at the same time
03:00:47 <edlinde> like erlang and lisp
03:00:54 <quicksilver> Veinor: an extra O(n) at each level leaves it n logn
03:01:11 <edlinde> and erlang uses uppsercase for vars
03:01:13 <edlinde> :)
03:01:16 <Veinor> ah
03:01:24 <quicksilver> Veinor: however, it would be a bit neater to calculate the length once and then carefully pass it down recursively
03:01:42 <Veinor> quicksilver: i'll buy that
03:01:48 <edlinde> is that let syntax good?
03:02:05 <edlinde> I usually see haskell code with where at the bottom
03:02:20 <Veinor> whether you use let or where is a stylistic choice
03:02:46 <edlinde> they both do the same thing?
03:02:50 <Veinor> pretty much
03:02:54 <edlinde> I heard the where can go past guards
03:02:57 <edlinde> and a let cannot
03:02:59 <Veinor> that's true
03:03:00 <edlinde> is that true?
03:03:04 <edlinde> okie
03:03:54 <Veinor> quicksilver: yeah, i'll buy that it's still n ln n, because it adds an extra n + 2*n/2 + 4*n/4 + ...
03:04:25 <Veinor> but yeah, an implementation that did that would be neat. seems fairly simple to do.
03:23:49 <edlinde> is there a resource which has a lot of haskell problems and solutions?
03:24:11 <edlinde> just lots of exercises
03:24:25 <edlinde> any suggestions?
03:28:01 <edlinde> wish there was like a schaum's series on haskell
03:28:12 <edlinde> but doesn't anyone here know about such a site
03:31:01 <Jafet> Haskell doesn't have problems, only solutions!
03:31:05 * hackagebot blaze-from-html 0.3.0.0 - Tool to convert HTML to BlazeHtml code.  http://hackage.haskell.org/package/blaze-from-html-0.3.0.0 (JasperVanDerJeugt)
03:31:14 <edlinde> ok if I define a polymorphic typeclass ... do I then have to write instances for each different concrete type?
03:31:21 <edlinde> is that how it works?
03:31:23 <quicksilver> edlinde: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems ?
03:31:58 <quicksilver> edlinde: I don't know what you mean by "polymorphic" typeclass, but you don't always have to write concrete instances, no.
03:32:06 * hackagebot blaze-html 0.3.0.0 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.3.0.0 (JasperVanDerJeugt)
03:32:08 <quicksilver> the instance of Monoid for [a] is not concrete, for example
03:32:16 <edlinde> ok I am just preparing for a FP exam :)
03:32:32 <edlinde> ok
03:32:38 <edlinde> quicksilver: that site looks cool
03:32:52 <edlinde> quicksilver: you think those problems are difficult to solve?
03:33:22 <edlinde> and you also think its good to know some predefined functions... say for lists?
03:33:31 <alpounet> yes
03:33:35 <alpounet> definitely
03:33:41 <alpounet> as for any standard library for any language
03:33:59 <edlinde> ok is there a list of everything available?
03:34:15 <alpounet> http://www.haskell.org/ghc/docs/latest/html/libraries/ ?
03:34:18 <alpounet> you also have hoogle
03:34:24 <alpounet> usable from here
03:34:26 <edlinde> hmm hoogle
03:34:33 <alpounet> @hoogle [a] -> [a]
03:34:33 <lambdabot> Prelude cycle :: [a] -> [a]
03:34:33 <lambdabot> Prelude init :: [a] -> [a]
03:34:33 <lambdabot> Prelude reverse :: [a] -> [a]
03:34:43 <alpounet> @hoogle repeat
03:34:44 <lambdabot> Prelude repeat :: a -> [a]
03:34:44 <lambdabot> Data.List repeat :: a -> [a]
03:34:44 <lambdabot> Data.ByteString.Lazy repeat :: Word8 -> ByteString
03:34:46 <alpounet> etc
03:34:46 <quicksilver> http://hackage.haskell.org/packages/archive/pkg-list.html 
03:35:11 <edlinde> say I wanted to look up a function that would return the nth element in a list
03:35:18 <edlinde> how does one go about doing that in hoogle?
03:35:26 <alpounet> it takes a list
03:35:27 <alpounet> a number
03:35:31 <alpounet> and returns an element of the list
03:35:37 <Veinor> @hoogle [a] -> Int -> a
03:35:37 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:35:37 <lambdabot> Data.List (!!) :: [a] -> Int -> a
03:35:37 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
03:35:38 <edlinde> you cannot till you know the name of the function though
03:35:41 <alpounet> just figure out the type :)
03:35:50 <edlinde> ah so you can search by types
03:35:53 <alpounet> yeah
03:35:56 <Veinor> yep
03:35:59 <alpounet> see my first search
03:36:03 <alpounet> and the one Veinor just did
03:36:03 <edlinde> neat
03:36:14 <Veinor> half the fun of haskell is 'okay, the function i want must have this type, let's see what hoogle finds me for it'
03:36:25 <edlinde> hehehe ok
03:36:41 <edlinde> but maybe in exams the prof is expecting us to write out this function from scratch
03:36:49 <edlinde> without using predefined ones I suppose
03:36:52 <alpounet> we can't know
03:36:54 <edlinde> I know its retarded
03:36:57 <edlinde> :)
03:37:03 <alpounet> the prof will tell you I guess
03:37:08 <funkyjunkyrobot> can anyone help me with prolog?
03:37:21 <edlinde> thanks guys
03:37:22 <sipa> try #prolog ? :)
03:37:26 <funkyjunkyrobot> ha!
03:37:31 <funkyjunkyrobot> that channel is a ghost town
03:37:43 <funkyjunkyrobot> plus the haskell channel has so many smart people in it :)
03:38:19 <Jafet> robot: No.
03:38:34 <funkyjunkyrobot> k
03:38:48 <funkyjunkyrobot> i'm getting an error when i try to join the prolog channel anyway, says it's invite only
03:38:50 <romildo> Are there standard functions for acessing each component of a tiple?
03:39:02 <romildo> s/tiple/triple/
03:39:22 <Veinor> romildo: nope
03:39:28 <Veinor> only 2-tuples
03:39:29 <sipa> romildo: only for 2-tuples
03:40:09 <sipa> funkyjunkyrobot: maybe ##prolog ?
03:40:29 <funkyjunkyrobot> i've been in the #prolog recently the invite thing is very new
03:42:13 <edlinde> thanks for the 99 problems, are there any problems that help understand typeclasses better?
03:42:27 <edlinde> like how to make your types, typeclasses and instances?
03:43:07 <sipa> types are made using 'newtype' or 'data', type classes using 'class', and  instances using 'instance' ?
03:43:10 <sipa> ;)
03:43:29 <Jafet> @where rwh
03:43:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:43:47 <edlinde> sipa: yeah I know
03:44:08 <edlinde> sipa:  its just that given a type definition if you are asked to cook up say a function ... how does one do that for example
03:44:32 <edlinde> or write a whole typeclass for a binary search tree and it should be polymorphic ... blah blah :)
03:44:37 <jro> Parsec is fun
03:45:08 <Jafet> edlinde: instead of wondering aloud, you could start reading a book and ask real questions?
03:45:21 <quicksilver> edlinde: the LYAH stuff on typeclasses is quite good
03:45:42 <edlinde> quicksilver: yep I read that
03:45:43 <alpounet> edlinde, experience helps quite a lot
03:45:48 <quicksilver> Jafet: I believe he's trying to revise for a test; he knows the basics but is getting nervous now, and trying to find ways to test himself.
03:45:56 <edlinde> heheeh yeah
03:46:11 <Jafet> Bah, no child left ahead
03:46:30 <edlinde> its just that I read all this theory from LYAH ... a whole bunch of things haskell can do.. but never got the time to write actual code ... like a project or something
03:46:35 <edlinde> :)
03:46:49 <Jafet> If it's a programming test, you don't need typeclasses to compute anything
03:46:52 <edlinde> but 99 probs is certainly a good start
03:46:53 <jro> however, one simple question: stringtime = do hours <- many1 number  _ <- separator minutes <- many1 number _ <- separator seconds <- many1 number
03:47:11 <edlinde> Jafet: I know I know... I still need to remember their syntax etc
03:47:17 <sipa> jro: is that one line?
03:47:18 <alpounet> edlinde, well, actually writing haskell code for a project is what will help you the most IMO
03:47:25 <Jafet> @where cheatsheet
03:47:25 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
03:47:30 <edlinde> alpounet: true
03:47:40 <jro> this parser correctly expressions "12:00:00" "12:12:00.1123
03:47:45 <edlinde> alpounet: I intend to use it later down the track for some other projects
03:47:48 <jro> sipa: no
03:47:55 <Jafet> And quit wasting time here, write some code, do your book's exercises
03:47:56 <alpounet> good luck then
03:47:58 <alpounet> i'm leaving
03:48:00 <edlinde> which involve data structures ... so haskell would be good for it
03:48:11 <edlinde> Jafet: ok boss :)
03:48:47 <jro> how do I extend it so, that it also founds types like "12:00" matching hours 12 and minutes 00?
03:49:57 <ndrsndrs> something with optionMaybe would work
03:50:03 <jro> do I have to write second representation and say parse (stringtime >> stringtimeshort)
03:52:24 <quicksilver> jro: I didn't quite follow you, but you want to put "optional" around the separate and the seconds
03:52:29 <quicksilver> or was it called 'option'
03:52:33 * quicksilver checks parsec docs
03:53:30 <quicksilver> jro: option 0 (seperator >> many1 number)
03:53:48 <quicksilver> jro: will parse the seconds if it finds the separator, but default to 0 if there is no separator.
03:54:31 <quicksilver> jro: by the way, no need for the _ <- before separators. If you don't need the return value, don't bind.
03:54:49 <quicksilver> do { hours <- many1 number ; separator; minutes <- many1 number }
03:55:17 <jro> ok, thanks
03:55:29 <Twey> Newer GHCs give a warning, I think?
03:56:05 <quicksilver> Twey: for which case?
03:56:29 <Jafet> If you're bored enough to ask for warnings
03:56:38 <quicksilver> oh, right, warnings.
03:56:44 <quicksilver> I never have GHC warnings on :)
03:56:47 <MasseR> Does HTTP package support https?
04:00:53 <Twey> quicksilver: For ignoring a non-unit result from a monadic action in do-notation
04:01:27 <quicksilver> Twey: you might be right. I've never got on with GHC warnings. Perhaps I should try again.
04:02:38 <maurer_> quicksilver: The main point of that one is to prevent people from discarding results they probably should look at (like errors/failures) without first thinking about it.
04:02:55 <maurer_> Most likely what should be done in this case is for separator to return (), but I may be wrong.
04:03:22 <Twey> quicksilver: For ignoring a non-unit result from a monadic action in do-notation
04:03:34 <quicksilver> maurer_: yes, I understand the reason.
04:03:43 <quicksilver> :)
04:03:50 <Twey> maurer_: Depends what separator does… you could have more than one possible separator, and be interested in which one was used
04:05:54 <quicksilver> I kind-of don't like a warning treating () differently.
04:05:59 <quicksilver> but I think that's me being daft.
04:07:30 <Twey> I agree
04:11:31 <jro> I did not properly understand, but that does not giva a warning with -Wall
04:17:29 <sohum> @pl \l c -> (a *) . (foldl (+)) . (b:) (zipWith (*) l c)
04:17:29 <lambdabot> (((((a *) . foldl (+)) .) . (b :)) .) . zipWith (*)
04:19:36 <Twey> @unpl (a *) . (foldl (+)) . (b:) (zipWith (*) l c)
04:19:37 <lambdabot> (\ h -> a * (foldl (+) ((b : (zipWith (*) l c)) h)))
04:19:53 <Twey> @pl \l c -> (\ h -> a * (foldl (+) ((b : (zipWith (*) l c)) h)))
04:19:53 <lambdabot> (((((a *) . foldl (+)) .) . (b :)) .) . zipWith (*)
04:20:00 <Twey> Ah, it is the same
04:25:59 <benmachine> maurer_: iirc it's more to do with making people use mapM_ instead of mapM where appropriate, because the latter can lead to memory leaks
04:26:04 <benmachine> (but I might not rc)
04:35:18 <ajnsit> I've been trying to bootstrap cabal install from sources using GHC 7 and I keep on getting an error about unsatisfied dependencies base < 3 and base >= 4
04:35:38 <ajnsit> So I downloaded and built GHC 6 from sources and tried using that and it worked fine
04:36:00 <ajnsit> what could be the problem with GHC 7 configuration?
04:38:03 <Jafet> ghc 7 ships with base-5.
04:38:07 <benmachine> no it doesn't
04:38:12 <benmachine> it ships with 4.4
04:38:13 <benmachine> er
04:38:14 <benmachine> 4.3
04:38:33 <Jafet> Er, I blame whoever it was that told me that
04:38:38 <benmachine> ajnsit: I think the error message is bad
04:39:14 <mightybyte> @pl (\a b c -> f (g a b) c)
04:39:14 <lambdabot> (f .) . g
04:40:08 * hackagebot temporary 1.0 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.0 (MaxBolingbroke)
04:40:37 <ajnsit> benmachine, what do you mean?
04:40:56 <benmachine> ajnsit: I think that some other dependencies are failing and it's just not explaining that very well
04:41:34 <benmachine> ajnsit: I know the current released version has some dependencies that need updating to work with GHC 7
04:41:48 <benmachine> ajnsit: on the time package, I think? you might just manually check the deps, there aren't that many
04:42:15 <ajnsit> benmachine, okay thanks let me check
04:42:45 <benmachine> I gotta go someone else can finish dealing with you
04:47:29 <ajnsit> which c library headers should I install to be able to install unix-compat using cabal? I see an error message about Missing header file: HsUnixCompat.h
04:47:49 <ajnsit> and I can't file any dev package related to unix-compat in my package list for Ubuntu
04:48:18 <ceii_> If it starts with Hs then it's probably supposed to be a file that comes with GHC
04:48:27 <ceii_> apart from that, no idea
04:49:05 <ajnsit> I see this package in Ubuntu 10.10 - libghc6-unix-compat-dev
04:49:12 * hackagebot temporary 1.1 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1 (MaxBolingbroke)
04:49:20 <ajnsit> but not in Ubuntu 10.04 :(
04:54:47 <ceii_> I have a HsUnixCompat.h in the source tarball for unix-compat
04:54:58 <ceii_> and cabal seems to find it just fine
04:59:23 <Borgvall> hi, is there any possibility to overload the operators '^' and '^^', for a special Num/Fractional datatype?
05:00:07 <sipa> you can write your own Num/Fractional instances for data types, but you can't change an existing one
05:00:20 <sipa> however, you can create a newtype wrapper around an existing type
05:00:29 <sipa> and create an own instance for it
05:00:38 <sipa> reusing the underlying implementations
05:01:00 <mightybyte> The PVP says that you have to upgrade A.B if a dependency changes.  Would upgrading a monads-fd dependency to an mtl 2 dependency be considered a change?  I thought I heard that they were the same thing.
05:01:10 <revenantphx> Ok... this is not working.
05:01:47 <Borgvall> my problem is, that the operators are defined in the Prelude, and not in the class interface.
05:02:06 <sipa> Borgvall: oh, right
05:02:23 <sipa> Borgvall: in that case you can do an explicit import of Prelude hiding those operators, and write your own
05:02:42 <Borgvall> so it is no problem to define '^' and '^^' in the instances. 
05:02:56 <quicksilver> well they're not in the class, so you can't put them in the instances of that class.
05:03:32 <sipa> Borgvall: you still want them to behave the normal way for existing types, but differently for an own type?
05:03:35 <quicksilver> you can hide the prelude.^, invent a new class, and put your new operators in the new class, and then given instances for some types using Prelude.^ and for some types in some other way.
05:03:57 <Borgvall> @sipa: yes exactly
05:03:58 <lambdabot> Unknown command, try @list
05:04:12 <sipa> use quicksilver's solution :)
05:04:13 <quicksilver> I recall being annoyed by the instance when trying to do a Num instance for interval arithmetic.
05:05:07 <Jafet> class (Num a, Caretable a) => DoubleCaretable a
05:06:36 <Borgvall> ok i will try it
05:13:28 <lispy_> CareTable?
05:13:37 <sipa> Caret-able
05:17:45 * byorgey read CareTable at first too
05:19:36 <Jafet> Haskell would be great with structural polymorphism
05:19:48 <Jafet> If it's possible, that is
05:20:10 <sipa> what's that?
05:20:11 <byorgey> what is structural polymorphism?
05:22:26 * hackagebot heist 0.3.0.0 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.3.0.0 (DougBeardsley)
05:22:40 <quicksilver> byorgey: it's when a car turns into a big robot.
05:23:04 <byorgey> ohhhh, I get it.
05:23:21 <byorgey> instance StructuralPolymorph OptimusPrime where  transform = ...
05:24:11 <Twey> byorgey: Hehe
05:24:49 <RenJuan> sounds like another name for GADT
05:25:05 <Jafet> Like ML's type system
05:25:20 <Jafet> Gunpla sold separately
05:26:53 <ndrsndrs> structural polymorphism = row types, i.e. OCaml's objects, right?
05:27:02 <ndrsndrs> like statically checked ducks
05:27:32 <Jafet> Well, it's more like inventing a new taxonomy for every flock of birds you see
05:28:19 <quicksilver> the extensible records stuff?
05:28:38 <aleator_> Can I use Data.Binary to read a dump of ieee754 floats that are terminated by EOF? 
05:28:51 <quicksilver> the basic system where you always name all the fields is fine, I think.
05:29:03 <quicksilver> but the sub-and-super-type polymorphism is, I believe, problematic.
05:30:44 <mm_freak> i'm using the iterator package…  how do i use the 'take' function inside of an Iterator computation?  currently i'm doing this: take 3 stream2stream
05:31:02 <byorgey> aleator_: use the data-binary-ieee754 package.
05:31:24 <byorgey> aleator_: the standard Binary instances for Double/Float will not work for that.
05:32:12 <aleator_> byorgey: I found that already, but if I don't know how many numbers there are, can I still make data.binary behave?
05:32:36 <quicksilver> mm_freak: well, IterateeG is a monad
05:32:43 <byorgey> aleator_: I would imagine so, but I don't know for sure
05:32:47 <quicksilver> mm_freak: so I imagine you want liftM (take 3) stream2stream
05:33:31 <aleator_> byorgey: I can't figure it out. I don't seem to be able to check if there are more bytes to read.
05:33:38 <mm_freak> hmm…  what am i saying?
05:33:43 <mm_freak> iteratee, of course
05:33:47 <mm_freak> not iterator =)
05:33:55 <mm_freak> worked too much with PHP recently
05:34:18 <mm_freak> quicksilver: can't find IterateeG…  seems like it disappeared
05:34:35 <quicksilver> maybe I'm looking at the wrong version of the docs, mm_freak 
05:34:46 <quicksilver> but whatever type stream2stream has for you, it's still surely a monad
05:34:53 <quicksilver> mind you I'm not sure that 'take 3' is the right thing to do.
05:35:03 <aleator_> ah.. nwm. Figured it out.
05:39:37 <mm_freak> quicksilver: 'take' is an enumerator
05:39:41 <quicksilver> mm_freak: OH
05:39:42 <mm_freak> that's why i'm asking
05:39:55 <mm_freak> using 'replicateM 3 head' seemed not the right thing to do for me
05:40:19 <quicksilver> mm_freak: which package are you using?
05:40:58 <mm_freak> * iteratee         (program and library)
05:41:04 <quicksilver> mm_freak: which version?
05:41:09 <mm_freak>     Latest version installed: 0.5.0.0
06:18:17 <revenantphx> why would this block?
06:18:18 <revenantphx> https://gist.github.com/727000
06:19:06 <quicksilver> revenantphx: it won't, on its own.
06:19:18 <quicksilver> if the lazy bytestring you're reading from had evil interleaved IO in it
06:19:21 <quicksilver> then that might block.
06:21:43 <revenantphx> what?
06:22:06 <revenantphx> I'll just look at how the original implementation of string does stuff
06:22:15 <quicksilver> revenantphx: nothing in your code there can block.
06:22:29 <quicksilver> revenantphx: but where do you get that bytestring from, that you're running Get on?
06:22:39 <quicksilver> there are ways to get bytestrings from IO which 'lazily' defer the IO
06:22:43 <quicksilver> and that IO can, of course, block.
06:23:17 <quicksilver> basically, I don't think there's anything wrong with the code you pasted, but there might be something wrong with how you call it.
06:23:30 <quicksilver> calling getContents on a network Handle would be a classic mistake, for example.
06:23:50 <revenantphx> That's done by the underlying binary-protocol...
06:24:02 <revenantphx> on the read handle.
06:24:09 <revenantphx> But this works perfectly fine for larger blocks.
06:24:29 <revenantphx> this is fine for instance: https://gist.github.com/727011
06:24:30 <quicksilver> The problem is not in the code you pasted. THe problem is in other code.
06:24:56 <quicksilver> no.
06:25:04 <quicksilver> there is no substantial difference between those pieces of code.
06:25:11 <quicksilver> the problem lies in the way you are calling them.
06:25:19 <revenantphx> the unpacking?...
06:25:51 <quicksilver> no.
06:26:05 <quicksilver> basically, pure code can't block.
06:26:18 <quicksilver> you either have an infinite loop (there isn't one in the code you pasted) or the problem is elsewhere.
06:27:02 <revenantphx> https://gist.github.com/727000
06:27:15 <revenantphx> When I replace the latter with the former, it blocks.
06:27:29 <revenantphx> (the issue is that the length is not the character count, but the length in bytes)
06:27:48 <revenantphx> (and Chars default implementation reads an entire 2 byte unicode character as "1")
06:27:59 <revenantphx> So it reads past the boundary of the packet.
06:28:36 <quicksilver> sure. and reading past the boundary of the packet would be an error, not a block
06:28:44 <quicksilver> unless you have some nasty lazy IO going on
06:28:55 <quicksilver> hence my repeated point that the error is outside this code.
06:29:00 <revenantphx> No no, the one that reads past the boundary errors otherwise, but it works.
06:29:12 <revenantphx> The one that should be correct (the byte string and unpack one) blocks apparently.
06:29:17 <revenantphx> I'm pasting the rest.
06:29:51 <revenantphx> https://gist.github.com/727018
06:31:36 <quicksilver> revenantphx: your binary instance looks wrong, by the way ;)
06:31:44 <revenantphx> which one?
06:31:51 <revenantphx> And how?
06:31:55 <quicksilver> ClientToServerPacket
06:32:00 <revenantphx> whats wrong with it.
06:32:18 <quicksilver> seems to miss tags for CTSPlayerInventory and CTSUseEntity
06:32:20 <quicksilver> in the put case
06:32:30 <revenantphx> oh, right you are.
06:32:43 <revenantphx> Wait, no I dont
06:33:08 <revenantphx> 49 and 50
06:33:46 <revenantphx> The issue is from line 165
06:33:52 <merijn> So I saw a book called "Basic Category Theory for Computer Scientists", is it any good? If no, any better recommendations for learning category theory?
06:34:02 <revenantphx> When it contains unicode, my original one failed (as expected)
06:34:11 <revenantphx> so I tried reading it as raw bytes, but now it blocks forever :(
06:34:30 <lispy> merijn: It's probably more than adequate if you also have a community
06:34:54 <quicksilver> revenantphx: OK, the reason for the blocking is presumably Control.Monad.BinaryProtocol
06:35:00 <lispy> merijn: I think it's hard to learn math if you're not sharing the experience with anyone
06:35:07 <quicksilver> revenantphx: which uses lazy IO.
06:35:10 <revenantphx> Yes.
06:35:18 <merijn> lispy: I thought that was what #haskell was for? :D
06:35:23 <quicksilver> revenantphx: the "bug" will be that you're reading more bytes than are in the packet.
06:35:28 <quicksilver> and so it's blocking.
06:35:38 <revenantphx> hm?
06:35:44 <revenantphx> I should be reading the right amount though.
06:35:57 <lispy> merijn: :)  You should also checkout #math and look for a mailing list
06:35:59 <quicksilver> perhaps, but that's the only explanation I know for the blocking.
06:36:03 <revenantphx> yeah :\
06:36:18 <quicksilver> revenantphx: maybe your packets get out of sync
06:36:19 <merijn> lispy: In my experience #math is less useful for CS math then #haskell :p
06:36:31 <quicksilver> revenantphx: and the length word is bogus
06:36:39 <lispy> merijn: I'm on the Isabelle and Agda mailing lists as I intend to learn me some theorem proving at some point :)
06:36:46 <merijn> type theory and logic almost get no response in #math, math.stackexchange is supposed to be ok
06:37:05 <revenantphx> quicksilver: ..heh?
06:37:09 <revenantphx> how is it ogus?
06:37:18 <quicksilver> revenantphx: well I mean what you think is a length word isn't a length word
06:37:27 <quicksilver> revenantphx: because you read too little (or too much) on an earlier packet
06:37:27 <merijn> lispy: Unfortunately irl there seems to be a lack of ambition to learn "hard" or formal CS :\
06:37:41 <revenantphx> quicksilver: the other packets are fine it seems.
06:37:51 <revenantphx> The issue manifests when this action is changed.
06:37:54 <quicksilver> revenantphx: what is the text encoding in the protocol?
06:38:05 <revenantphx> two bytes big endian length, and then the bytes in UTF-8
06:38:10 <quicksilver> and what is the length supposed to be? a char length or a byte length.
06:38:13 <revenantphx> but its the length in *bytes*
06:38:17 <merijn> Oh, do I hear another "game packets" = "tcp packets" flawed assumption as usual? :>
06:38:34 <revenantphx> No, these are tcp packets.
06:38:38 <revenantphx> They're not UDP.
06:38:46 <quicksilver> merijn: I don't think so, no. It's a TCP stream.
06:39:06 <quicksilver> unless his server is hanging up halfway through a game packet, which would legitimately make him block of course.
06:39:45 <merijn> quicksilver: Well if the code doesn't account for eating 1.5 game packet in one TCP receive he'd be screwed if he doesn't handle buffering locally
06:39:53 <quicksilver> revenantphx: is this a protocol of your own invention or is this the real minecraft wire protocol?
06:40:04 <quicksilver> merijn: he's just using haskell Handles which buffer just fine
06:40:23 <revenantphx> It's the real protocol.
06:40:44 <merijn> quicksilver: I'm assuming Handles work pretty much the same as sockets in any language in which case the problem I mentioned still exists
06:40:48 <revenantphx> It runs perfectly as it is, if I use the broken string routine.
06:40:51 <quicksilver> shame. I would never design a protocol like this.
06:40:55 <revenantphx> (except when unicode is sent)
06:41:03 <revenantphx> quicksilver: me neither, the 0x05 packet is bullshit.
06:41:13 <quicksilver> I would always have a meta-protocol around the which has chunk lengths
06:41:20 <revenantphx> I agree aentirel.
06:41:24 <revenantphx> entirely*
06:41:25 <quicksilver> and then I'd only decode chunks which I knew I had read the right amount for.
06:41:26 <revenantphx> Lazy IO is actually perfect for this protocol though
06:41:34 <revenantphx> It's been very convenient.
06:41:46 <revenantphx> quicksilver: I've complained at the dev multiple times about framing his packets.
06:42:02 <revenantphx> Anyways...
06:42:05 <revenantphx> any idea why that blocks?
06:42:05 <quicksilver> merijn: it doesn't matter if one TCP receive gets 1.5 game packets; they are buffered in a haskell handle
06:42:13 <quicksilver> merijn: and he only reads the bytes he wants to out of it
06:42:19 <quicksilver> merijn: or do I misunderstand you?
06:42:30 <revenantphx> I know how to use TCP relatively wlel.
06:42:49 <revenantphx> UDP not so much. I've done a lot of BSD TCP stuff.
06:43:01 <merijn> quicksilver: Oh, duh. I hadn't thought of lazy IO >.>
06:43:12 <merijn> That of course removes the issue
06:43:18 <quicksilver> revenantphx: I'm confused about why the working code works, if what you say is right.
06:43:30 <quicksilver> revenantphx: you said Chars always Get 2 bytes. Did you mean they always Get 1 byte?
06:43:39 * quicksilver is not familiar with the binary instance for Char.
06:44:24 <revenantphx> no, Chars will get 1 or 2 bytes.
06:44:26 <revenantphx> they use TF-8
06:44:28 <revenantphx> UTF-8*
06:44:38 <lispy> UTF-8 could be as many as 4 bytes
06:44:54 <revenantphx> The set present here only goes up to 2, as far as I know.
06:45:02 <lispy> ah, fair enough
06:45:16 <quicksilver> OK, so as long as it happens to pure ascii, everything is 1 byte, and then length in bytes = length in chars and just replicateM n (get :: Get Char) works
06:45:16 <revenantphx> The problem is that if I tell it to read "1 character" in that version, it could be 1 to 4 bytes.
06:45:19 <quicksilver> right?
06:45:19 <revenantphx> And the length in bytes.
06:45:24 <revenantphx> quicksilver: precisely.
06:45:34 <revenantphx> then it works perfectly, but the second its a two octet character...
06:46:06 <merijn> Finding out the length in chars requires reading in all the bytes and checking manually, though
06:46:56 <revenantphx> Which is why my solution was to read in all of the bytes into a bytestring, and then decode it.
06:46:58 <quicksilver> revenantphx: it's as if getLazyByteString is getting one more byte than needed, to check something.
06:47:02 <revenantphx> (unpack)
06:47:22 <quicksilver> hmmm
06:47:53 <revenantphx> could you refresh the git?
06:48:05 <quicksilver> done
06:48:09 <quicksilver> which bit did you change?
06:48:22 <revenantphx> I was using one of one set and one of the other for the put/getMCSTr
06:48:24 <revenantphx> I changed that
06:48:32 <revenantphx> the ones with apostrophes are not both the bytestring version
06:48:38 <revenantphx> so ok, so putMCStr' works.
06:48:54 <quicksilver> you have two definitions of each now
06:49:02 <quicksilver> you only changed the name in the type sig, not the actual definition
06:49:20 <revenantphx> ah, lemme fix that _<
06:50:04 <quicksilver> I would try getByteString instead of getLazyByteString
06:50:14 <quicksilver> although that's just to eliminate the possibility of a bug in getLazyByteString
06:50:36 <gds>  @type first
06:51:07 <revenantphx> quicksilver: that will fail if its not all there though.
06:51:11 <merijn> gds: You're looking for the function to get an item from a tuple?
06:51:24 <gds> merijn: No :)
06:51:24 <quicksilver> revenantphx: with lazy IO it will be all there
06:51:33 <revenantphx> I suppose.
06:51:36 <gds> I was just idly wondering how the arrow type was formulated :)
06:51:36 <quicksilver> revenantphx: (it will block until it is)
06:51:58 <gds> merijn: and when lambdabot didn't answer immediately, it was faster to fire up ghci than to mess about ;)
06:52:00 <quicksilver> (but so would getLazyByteString)
06:52:02 <gds> So I now have it:)
06:52:06 <merijn> gds: From what I understand of category theory probably using goats blood and stuff :p
06:52:16 <merijn> Also, it'd be
06:52:18 <merijn> :t first
06:52:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
06:52:22 <quicksilver> the only difference is when they're applied on a bytestring of fixed (too short) length
06:52:40 <revenantphx> one moment
06:52:43 <gds> Oh - didn't it use to be "@type" ? I guess either not, or it changed :)
06:53:03 <Liam> hi guys
06:53:11 <quicksilver> gds: it still is, you had an extra space
06:53:20 <gds> Ah :)
06:53:29 * gds fails at basic IRC :)
06:54:36 <revenantphx> odd.
06:54:42 <revenantphx> It works nw with nonlazy bytestrings.
06:54:54 <revenantphx> But lazy byte string work fine for MCData and MCChunkData
06:54:57 <revenantphx> :\\
06:55:07 <quicksilver> revenantphx: I think it's a bug in getLazyByteString
06:55:19 <quicksilver> revenantphx: (or at least, a poor interaction between getLazyByteString and lazy IO)
06:55:29 <revenantphx> Weird...
06:55:31 <quicksilver> revenantphx: I have some vague memory of this which is why I suggested it
06:55:34 <revenantphx> well, it seems to work now.
06:55:39 <revenantphx> do tell me if you figure it out.
06:55:40 <quicksilver> I think it 'examines' one element too far
06:55:43 <quicksilver> and thus waits for more IO
06:55:57 <revenantphx> So why doesn't it do that for the MCData and MCChunkData
06:56:11 <quicksilver> because you never run that in a context where nothing comes after
06:56:13 <quicksilver> (guessing)
06:56:29 <revenantphx> what...?
06:56:38 <revenantphx> So I should make those non lazy?
06:57:02 <quicksilver> yup
06:57:24 <quicksilver> getLazyByteString looks entirely incompatible with lazyIO to me.
06:57:29 <quicksilver>     S s ss bytes <- get
06:57:32 <quicksilver> (from the source)
06:57:41 <quicksilver> makes no mention of 'n' the maximum number of bytes to get.
06:57:51 <quicksilver> of course lazy IO is wicked and evil, so we should encourage libraries which break it.
06:58:27 <quicksilver> hmm, no my analysis is wrong.
06:58:37 <quicksilver> that "get" is a different "get"
06:58:56 <revenantphx> Why is lazy IO evil?
06:59:13 <raj> raj here
06:59:33 <quicksilver> revenantphx: for this kind of reason. Because it interposes blocking in surprising places
06:59:47 <revenantphx> It is convenient for dealing with a shitty protocol :)
06:59:54 <quicksilver> it puts all the evilness of IO and hooks into suprising parts of pure functions, where you can't debug it
07:00:09 <revenantphx> So should I make my chunk reading non-lazy?
07:00:22 <quicksilver> I think so
07:00:31 <quicksilver> the laziness is no advantage if you'r egoing to use it all immediatley
07:00:53 * hackagebot process-leksah 1.0.1.4 - Process libraries  http://hackage.haskell.org/package/process-leksah-1.0.1.4 (HamishMackenzie)
07:01:38 <revenantphx> mmk
07:02:00 <lispy> FWIW, lazy IO is typically a bug waiting to happen
07:02:05 <revenantphx> I have to say, this has been some of the easiest network code I've ever written though. :P
07:02:16 <lispy> It's usually only safe in programs that border on trivial
07:02:28 <revenantphx> what kind of bugs?
07:02:50 <lispy> Memory leaks are really common
07:03:25 <revenantphx> I'm not sure how else to do this easily. As it stands it works quite nicely.
07:03:27 <lispy> Exception handling becomes trickier because the exception appears during pure code instead of in the IO code where it really happened (if that makes sense)
07:03:36 <revenantphx> Yeah, I have noticed that.
07:04:03 <lispy> left-folds are a way to avoid laziness in situations like this
07:04:05 <revenantphx> The *only* error I get is "could not read bytes" regardless of what really happened (socket closed, w/e)
07:04:09 <lispy> left-folds make good stream processors
07:04:24 <revenantphx> Well maybe in the future I can rewrite a non-lazy version of binary-protocol
07:04:27 <blenderer> wow this channel is really high volume these days.
07:04:34 <revenantphx> If it has the same methods, it shouldn't be too hard to supplant it.
07:04:38 <revenantphx> functions*
07:04:39 <lispy> blenderer: been that way for a while :)
07:04:44 <merijn> blenderer: It's been high volume as long as I know it :p
07:04:50 <merijn> Actually pretty quiet now
07:04:59 <revenantphx> mm.
07:05:30 <lispy> revenantphx: have you looked at Oleg's iteratees or the enumerator library on hackage?  Those should provide you with examples/reading material if you want to move away from lazy IO in the future
07:06:24 <revenantphx> Alright then.
07:06:42 <revenantphx> I heard about iteratees at one point.
07:06:48 <revenantphx> While I was looking through attoparsec.
07:07:24 <revenantphx> Yay, this bot is now running perfectly.
07:07:35 <lispy> revenantphx: congrats
07:07:50 <quicksilver> it's not trivial to write a non-lazy-IO version of Binary.Protocol, because Binary instances don't have a way to calculate length without reading.
07:07:55 <revenantphx> This is really the first siginificantly sized piece of haskell I've written... :\
07:08:04 <revenantphx> quicksilver:hm true.
07:08:15 <revenantphx> Thats why the lazy io was convenient for this shitty protocol
07:08:19 <quicksilver> quite.
07:08:33 <quicksilver> Binary itself is not suited for transport layers
07:08:38 <quicksilver> (it's fine for a lower layer)
07:08:52 <revenantphx> heh, it works nicely here :P
07:08:55 <quicksilver> you couldn't write an iteratee-Binary, because Binary instances don't have enough information.
07:08:58 * hackagebot bson 0.1.1 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1.1 (TonyHannan)
07:09:08 <lispy> quicksilver: ah, that's interesting.  I actually haven't had a reason to learn/use binary/cereal yet
07:09:09 <revenantphx> Do you have any recommendations for what to use instead in the future for network protocols?
07:09:11 <quicksilver> there's no way for the iteratee to ask the binary instance "is this enough data to run you on, yet"
07:09:36 <quicksilver> there isn't even a way for the iteratee to "just try it and catch the error if it was too short"
07:09:46 <quicksilver> because Binary doesn't have proper exceptions.
07:09:56 <raj> .
07:09:59 <jmcarthur> (unless you count spoon...)
07:10:05 <quicksilver> Binary is only suited to work on data which you *know* is the right format.
07:10:11 <quicksilver> it's not suited for untrusted data.
07:10:16 <jmcarthur> and that's a shame
07:10:20 <revenantphx> Well, I see it this way.
07:10:24 <revenantphx> TCP is trustworthy
07:10:29 <jmcarthur> eh
07:10:33 <quicksilver> I'm not doubting TCP, revenantphx  ;)
07:10:36 <revenantphx> If its being untrustworthy, than the entire connection is void anyhow.
07:10:45 <quicksilver> within the protocol, though
07:10:49 <revenantphx> ?
07:10:52 <quicksilver> you could have a string which said it was 666 bytes long
07:10:56 <quicksilver> and then only 45 bytes were sent.
07:10:58 <quicksilver> (or the reverse)
07:11:08 <quicksilver> Binary can't handle that kind of error in any remotely elegant way.
07:11:11 <revenantphx> Right. And if that was the case I'd expect it to fail.
07:11:22 <quicksilver> but it doesn't even fail in a way you can sensibly catch + report.
07:11:31 <quicksilver> it just throws an async exception.
07:11:34 <revenantphx> I can't possibly know if a string is not the length it says.
07:11:34 <merijn> btw, are there any plans to steal Erlang's binary handling syntax to Haskell? :p
07:11:38 <revenantphx> It's an assumption I have to make...
07:11:40 <revenantphx> g2g
07:11:59 <theorbtwo> revenantphx: Ah, that's the rub.  A "real" haskell programmer doesn't believe in failure.
07:12:06 <quicksilver> jmcarthur: yes, it's a shame, but it as out-of-scope for Binary.
07:12:20 <quicksilver> jmcarthur: the problem is that lots of people use Binary without realising its deliberate limitations.
07:12:43 <quicksilver> it's more suited to fast, trusted persistence.
07:12:54 <merijn> I have come to realize binary protocols suck balls :>
07:13:06 <theorbtwo> merijn: In some ways, yes.
07:13:35 <quicksilver> certainly, writing a parser for a binary protocol which behaves robustly with untrusted input is a pain in the backside.
07:13:36 <theorbtwo> They are harder to parse, and harder to debug, often.  They can also be much faster, sometimes.
07:13:57 <quicksilver> mind you most of that is true for text protocols too.
07:14:01 <quicksilver> untrusted input is a bitch.
07:14:17 <merijn> Untrusted anything is a bitch
07:14:32 <Jafet> Viewed another way, a "text" protocol is just a binary protocol with a layer of vagueness
07:14:45 <revenantphx> Oh hey, I have history class...
07:14:54 <revenantphx> In other words... I have 45 minutes of "ignore the teacher and play with haskell"
07:16:21 <dankna> you shouldn't do that - those who don't learn from history class are doomed to repeat it
07:17:01 * sleepynate http://www.hiyoooo.com/
07:17:13 <Jafet> dankna: heh
07:17:17 <revenantphx> dankna: eh, I fork my ear and have it listen.
07:17:19 <sleepynate> dankna: that was terrible. i approve
07:17:37 <revenantphx> allocate ~5% of my cycles to listening.
07:17:39 <dankna> thanks :) haha
07:18:12 <revenantphx> Also, this isn't an AP course, so it's really easy.
07:18:21 <revenantphx> Its a course in knowing the general trends of history and bullshitting the rest.
07:18:23 <dankna> fair
07:18:30 <revenantphx> I have a 96%, not worried in the slightest.
07:18:36 <revenantphx> I can skip the final and get a B.
07:18:39 <revenantphx> >_>
07:18:42 <revenantphx> anyways...
07:18:54 <revenantphx> I'm wondering how to abstract me having... the same state everywhere.
07:19:08 <revenantphx> I worry about using Reader or something because I'd be... you know, adding ANOTHER monad.
07:19:27 <sleepynate> revenantphx: will it get the job done?
07:19:30 <revenantphx> SHIT
07:19:32 <revenantphx> g2g
07:21:33 <Jafet> A burrito wrapped in a tart wrapped in a pastry wrapped in... a SHRUBBERY!
07:22:07 <sleepynate> a python reference in a haskell channel?!
07:22:11 <zygoloid> composing applicatives?
07:22:11 * sleepynate shock / awe
07:23:06 <zygoloid> so is the comonadic "m a -> m (m a)" the functorial form of demanding another shrubbery?
07:23:50 <quicksilver> win 22
07:24:02 <sleepynate> i think revenantphx just had to forkIO (popquiz)
07:27:02 * Twey wonders if there's a Python library called ‘shrubbery’.
07:27:21 <Twey> Ah yes, here we are
07:27:26 <Twey> http://pypi.python.org/pypi/shrubbery/0.3.4
07:28:59 <sleepynate> yea, it's actually mostly useless
07:29:18 <Jafet> HTML templating? NIH! NIH! NIH!
07:30:12 <lars9> Data A = A {x :: Int, y :: Int}, if for some a::A we only care about x, can we define A{x=1}, without specified y? error is reported here
07:30:25 <kmc> a run-time error if you access y
07:30:31 <kmc> and a compile-time warning
07:30:32 <kmc> iirc
07:30:33 <revenantphx> Do I dare use ReaderT on top of the monads I already have?
07:30:46 <revenantphx> also, if I have two transformers present, will liftIO still go all the way to IO?
07:30:51 <kmc> yes
07:31:00 <kmc> that's the point of liftIO
07:31:23 <Jaak> exit
07:31:26 <revenantphx> mmk.
07:31:33 <Jaak> oh yeah, that doesn't look like a terminal
07:31:42 <Jaak> :]
07:31:55 <revenantphx> So if I have a lot of stuff I'm using throughout here, I could add ReaderT for my state?
07:32:04 <lars9> kmc is that syntax designed for such purpose?
07:32:12 <kmc> lars9, the record construction syntax?
07:32:25 <lars9> kmc: yeah
07:32:31 <kmc> hmm, not really
07:32:36 <revenantphx> but wait.
07:32:39 <kmc> the point is more to have labels so you know what fields are what
07:32:47 <revenantphx> If I apply ReaderT to BinaryProtocol...
07:32:53 <lars9> kmc i see, thanks
07:32:56 <revenantphx> then how do I use binaryprotocol stuff?
07:33:00 <revenantphx> do I have have to lift those too?
07:33:01 <kmc> lars9, i'd rather be more explicit, like  A{ x = 1, y = error "y is undefined and here's a helpful message explaining why" }
07:33:19 <lars9> kmc lol that works
07:33:19 <kmc> yeah revenantphx
07:33:44 <kmc> because your binaryprotocol stuff returns values of type (BinaryProtocol T)
07:33:57 <kmc> and you're building values of type ReaderT R BinaryProtocol T
07:34:00 <revenantphx> So what would be the optimal way to keep track of stuff like Player records.
07:34:01 <kmc> and these are not the same type
07:34:03 <revenantphx> Or the map data.
07:34:09 <revenantphx> Basicaly, complex mutable data types.
07:34:28 <kmc> do you know how you'd write it without monads?
07:34:51 <revenantphx> STRef passed in a tuple?
07:34:56 <revenantphx> Or TVar more likely.
07:35:08 <revenantphx> or IORef
07:35:08 <kmc> oh, and you want the ReaderT to remember the refs for you?
07:35:10 <kmc> that's not crazy
07:35:15 <revenantphx> ?
07:35:27 <revenantphx> I'm just wondering how it would be done most appropriately
07:35:35 <revenantphx> this is it now
07:35:36 <revenantphx> https://gist.github.com/727092
07:35:43 <revenantphx> I'm just passing around a tuple.
07:36:05 <revenantphx> But I'm later going to want state (which is available regardless of thread) so STM seemed good (for now)
07:36:17 <revenantphx> Sticking TVar's in the tuple would work fine I think.
07:36:28 <kmc> are you using any vars now?
07:36:48 <kmc> oh there's a TChan
07:36:49 <revenantphx> Theres a TChan
07:36:53 <kmc> anyway
07:36:56 <revenantphx> I use that to synchronize writes.
07:37:06 <kmc> the pattern you're trying to eliminate is the part where every function has "AmityState -> ..." ?
07:37:18 <revenantphx> pretty much.
07:37:21 <kmc> ok
07:37:26 <revenantphx> Is Reader my best bet?
07:37:34 <kmc> yeah, that's exactly what it does
07:37:41 <fxr> hmm, any ideas how to generate all the sequences of a list [a] efficiently?
07:37:49 <kmc> fxr, all the sequences?
07:38:14 <fxr> kmc: subsets
07:38:19 <kmc> revenantphx, btw i'd define a custom type for AmityState rather than using tuples
07:38:23 <quicksilver> > concatMap inits . tails $ [1,2,3,4,5]
07:38:24 <lambdabot>   Ambiguous occurrence `concatMap'
07:38:24 <lambdabot>  It could refer to either `L.concatMap', d...
07:38:30 <revenantphx> kmc: like a data?
07:38:32 <kmc> fxr, what kind of efficiency do you need / why do you care about efficiency?
07:38:34 <quicksilver> > concat . map inits . tails $ [1,2,3,4,5]
07:38:34 <kmc> yeah revenantphx
07:38:35 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[],[2],[2,3],[2,3,4],[2,3,4,5],...
07:38:38 <kmc> maybe a record even
07:38:51 <revenantphx> hm yeah, record syntax would be cleaner.
07:38:52 <kmc> that's a good one quicksilver
07:39:02 <kmc> but that's contig. subsequences only, right?
07:39:06 <quicksilver> yes
07:39:12 <kmc> > filterM (const [False..]) "abcd"
07:39:12 <quicksilver> that's what the word suggested to me ;)
07:39:12 <lambdabot>   <no location info>: parse error on input `]'
07:39:15 <Jafet> > subsequences [1..5]
07:39:16 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
07:39:17 <kmc> > filterM (const [False ..]) "abcd"
07:39:18 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
07:39:31 <revenantphx> Kadanes in haskell must be very easy
07:39:39 <Jafet> subsequences is nice in that it works with infinite lists
07:39:46 <revenantphx> hah
07:39:47 <revenantphx> maxSublist = maximum . scanl (\m e -> max 0 (m + e)) 0
07:39:55 <fxr> how scalable is "concat . map inits . tails $ [1,2,3,4,5] `using` parListChunk N rdeepseq"?
07:40:01 <Jafet> Every finite subsequence whose elements are finitely far from the head, is finitely far from the head too
07:40:33 <revenantphx> kmc: I'm noticing often that Haskell is common on forums, irc, mailing lists and such, but not so much otherwise.
07:40:37 <quicksilver> even in an infinite list, all elements are finitely far from the head :)
07:40:45 <revenantphx> kmc: It'd seem to indicate to me its heavily discussed, not heavily used.
07:40:47 <quicksilver> I think you may have accidentally had a transfinite list there.
07:40:58 <kmc> fxr, deepseq is suspicious since you'll end up traversing whole lists
07:41:02 <kmc> revenantphx, i think that's accurate
07:41:18 <kmc> revenantphx, Haskell is interesting because it's different, and it's where a lot of research and experimental ideas end up
07:41:23 <revenantphx> Yeah, it's cool.
07:41:24 <revenantphx> I like it :)
07:41:28 <kmc> so there's a lot of discussion
07:41:35 <unkanon> I've noticed that too, revenantphx 
07:41:39 <quicksilver> kmc: different in interesting ways, too :)
07:41:41 <unkanon> I was thinking about that yesterday in fact
07:41:44 <kmc> i think it's technologically a good language for some practical stuff too
07:41:45 <fxr> kmc: should I use r0 instead?
07:41:48 <kmc> but the business case is harder to make
07:41:51 <quicksilver> kmc: you could be different in really dumb ways instead.
07:41:52 <kmc> r0 does nothing i thought
07:41:59 <fxr> yeah
07:42:00 <kmc> you could use rseq or something?
07:42:02 <unkanon> I think it's how we should all be programming in the near future
07:42:04 <kmc> i don't know honestly
07:42:10 <Jafet> quicksilver: well, you can't make it a list of all finite-length subsequences, since that's uncountable on [0..]
07:42:18 <revenantphx> kmc: what would you state as the pros of functional programming?
07:42:27 <kmc> fxr, i'm just suggesting to think a bit about whether the deepseq traversal is a problem
07:42:30 <Jafet> Actually it might be countable.
07:42:32 <kmc> revenantphx, i don't have time to list that now, sorry :/
07:42:34 <revenantphx> What does function purity get you, in your opinion.
07:42:39 <revenantphx> I mean like top 3 XD
07:42:40 <kmc> revenantphx, instead i will mention that Haskell is far from a typical functional language
07:42:41 <quicksilver> Jafet: you can :)
07:42:46 <revenantphx> kmc: this is true.
07:42:53 <quicksilver> Jafet: it's only the list including all the *infinte* subsequences which is a problem.
07:42:55 <unkanon> revenantphx: composability for one
07:43:01 <fxr> kmc: parListChunk with a big list gives stack space overflow
07:43:07 <revenantphx> currying
07:43:10 <sipa> Jafet: all finite length subsequences of N? that's countab;e
07:43:13 <sipa> countable
07:43:13 <quicksilver> Jafet: and in fact, my version doesn't give you any of the infinite ones. 
07:43:54 <kmc> if you make a big list of Haskell's features, some are clearly Good Ideas (and have been adopted widely); others are more ambiguous
07:44:03 <kmc> i'd hesitate to say that most code should use lazy evaluation
07:44:08 <kmc> though it is damn useful in certain places
07:44:13 <fxr> I think this is because I am using rdeepseq and the traversal of such big list yields a deep recursion
07:44:50 <kmc> some people come to Haskell having only used Java and they think that Haskell is the One True Way because it has first-class functions and the like, but actually every language that isn't Java has that ;)
07:45:12 <sleepynate> i think the think that's best about functional programming is i don't feel bad about my whole program being one big function call.
07:46:01 <sleepynate> now show us on the doll where this variable assignment touched you.
07:46:51 <merijn> kmc: No, java has first class functions in the newest version
07:47:05 <merijn> kmc: Its so cute to see them brag about it like its an awesome amazing achievement
07:47:21 <FauxFaux> It totally doesn't, merijn. </Java fanboy>
07:47:31 <fxr> quicksilver: thanks for the example, but isn't it uses a lot of intermediate lists, if I need only the length 3 of those subsets?
07:47:41 <ousado_> merijn: which version? 
07:47:58 <quicksilver> fxr: yes. If you'd said you only needed the length 3 ones I would have given a different answer.
07:48:10 <quicksilver> > map (take 3) . tails $ [1..10]
07:48:11 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[1...
07:48:35 <revenantphx> kmc, yeah record syntax is a much better idea here.
07:48:46 <revenantphx> since i don't have to change the function definitions every time i add a field.
07:48:54 <merijn> ousado_: Lemme check
07:50:21 <kmc> merijn, last i heard lambda was coming in late 2010
07:50:25 <kmc> 2012 i mean
07:50:58 <merijn> It might be an alpha/beta type release thingy
07:51:06 <merijn> I think they're calling them first class methods
07:51:21 <Jafet> > map (map snd . filter fst) $ zip (permutations (replicate 3 True ++ repeat False)) [1..10]
07:51:22 <lambdabot>   Couldn't match expected type `[(GHC.Bool.Bool, b)]'
07:51:22 <lambdabot>         against inferre...
07:51:52 <kmc> of course you can already fake them with inner classes
07:51:57 <kmc> which is slightly better than in C++
07:52:25 <fxr> quicksilver: could you please compare your next example with a (Vector Int). Do you think using a Vector instead of a list gives better performance and low memory footprint?
07:52:48 <revenantphx> Apple's GCC block extension is nice >_>... 
07:52:58 <revenantphx> It's a lot of evil compile time struct generation (which is fun to play with)
07:53:49 <quicksilver> fxr: lol. Are you trying to use me as a homework answerer.
07:54:26 <fxr> quicksilver: sure no
07:55:10 <fxr> quicksilver: I'm not a student, just trying to understand why my algorithms doesn't scale well with strategies.
07:55:15 <quicksilver> fxr: well that certainly looked like a question copied from an exam paper to me :)
07:55:30 <quicksilver> fxr: with lists of length 3, the memory overhead is unlikely to be significant.
07:55:37 <ousado_> kmc:  have you looked at C++0x?
07:55:42 <kmc> yeah
07:55:43 <fxr> quicksilver: ok, thanks.
07:55:53 <quicksilver> with very long lists, the sharing between sequences in that example would be nice.
07:56:06 <quicksilver> mind you some of the vector libraries can share sequences too, I believe.
07:56:28 <jmcarthur> fusion kills quite a bit of sharing, but slicing by default shares
07:57:01 <fxr> quicksilver: ok that's why I migrated it to Vectors. But I think I also need to write a parallel evaluation strategy over Vectors.
07:57:04 <jmcarthur> of course if the vector you're slicing out of is going to just be fused away it might not be so cheap. i never know what will be shared and what won't be with vector
07:57:46 <jmcarthur> it's funny to hear about parallel strategies with vector considering the vector was made for dph
07:57:51 <jmcarthur> *that
07:58:08 <edlinde> whats the best resource for lots of "infinite lists" and "lazy evaluation" in Haskell?
07:58:11 <edlinde> :)
07:58:32 <jmcarthur> > tails [1..]
07:58:33 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:58:46 <jmcarthur> an infinite list of infinite lists, lazily evaluated!
07:59:00 <edlinde> jmcarthur: yeah I want to read about it though
07:59:12 <jmcarthur> i'm not sure where to direct you about something so specific
07:59:19 <jmcarthur> lazy evaluation, sure, but infinite lists...
07:59:20 <edlinde> hmmm
07:59:25 <quicksilver> fxr: parallel strategies are harder to use than they appear :-/
07:59:28 <fxr> oh one last question, is there any explanation of threadscope output graph?
07:59:32 <jmcarthur> the latter is just something you can do with the former
07:59:49 <jmcarthur> edlinde: a good place to start is googling "call-by-need"
07:59:53 <edlinde> I just think that I see a lot of cool stuff with list comprehensions and infinite lists.. that I want to see some more tricks
07:59:57 <jmcarthur> ah
08:00:02 <jmcarthur> you really want haskell-specific
08:00:06 <edlinde> yeah
08:00:10 <jmcarthur> i don't know then
08:00:31 <Philippa_> list-as-control-structures is a cool trick
08:01:00 <edlinde> hmm thats no good :)
08:01:24 <edlinde> like I saw this example somewhere on generating all primes, or permutations etc 
08:01:31 <edlinde> stuff like that
08:01:49 <Philippa_> really, the individual list comprehensions aren't so cool: it's understanding the trick and technique behind them that's interesting
08:01:59 <Philippa_> and most of that generalises, which is why we don't have so many that we think're really cool
08:02:16 <Philippa_> (also, generating all primes is a slightly controversial one for the same way the really-really-short quicksort is)
08:02:52 <quicksilver> fxr: there are some links here : http://research.microsoft.com/en-us/projects/threadscope/ but I don't know if there are detailed docs.
08:02:57 <fxr> I'm seeing threads are delaying (which is shown as green zone below the base line for each HEC). What can be the reason for this?
08:02:58 <quicksilver> fxr: JaffaCake is around sometimes.
08:03:19 <fxr> okay, thank you very much
08:03:39 <JaffaCake> fxr: small green lines are GC
08:03:43 <edlinde> Philippa_: ok
08:03:58 <edlinde> I notice our prof has a thing for them ;)
08:03:59 <fxr> JaffaCake: isn't orange for gc?
08:04:28 <JaffaCake> in 7.0.1, we show the active parts of GC as green, with the setup/shutdown of GC in orange
08:04:50 <Philippa_> edlinde: the thing that's cool about lazy evaluation is getting to have /all your intermediate structures/ built as you need them
08:04:52 <JaffaCake> I wanted to know how much time we were spending in the GC doing non-GC stuff
08:05:08 <edlinde> Philippa_: how do you mean?
08:05:09 <fxr> oh great information, btw thank you very much ghc 7 performs parallel execution much better than 6.12
08:05:15 <Philippa_> so where you would've had eg a complex loop in C, you can just have a list in Haskell and take the items (and throw the head of the list away for preference) when you need them
08:05:35 <edlinde> Philippa_: the examples I have seen are like using a "take 10 ... and then some list comprehension on an infinite list
08:05:40 <Philippa_> taking-and-throwing-away does the equivalent of stepping through the loop for you - only it's when the code calling it needs it, so you don't have to worry about sync
08:05:47 <Philippa_> right, and the 'take' bit is just demonstration
08:05:56 <edlinde> ok
08:05:59 <Philippa_> that infinite list? Often has infinite lists involved in how it's built
08:06:08 <Philippa_> sometimes, earlier entries in the same infinite list
08:06:49 <Philippa_> (the class where you hang onto the entire list is... actually less than ideal, you get a situation where you can't GC any of the list until you're done with all of it)
08:06:51 <edlinde> so I mean when someone says "Lazy Evaluation" I just understand it to be that we don't evaluate till the very last moment and only evaluate what is needed
08:06:57 <Philippa_> right
08:07:06 <kmc> yes, specifically you evaluate when pattern-matching
08:07:08 <edlinde> so when I say take 10... blah
08:07:10 <Philippa_> well, technically 'lazy' also implies that you don't /re-evaluate/
08:07:13 <Philippa_> but yes
08:07:20 <edlinde> its really just going to calculate the 10 entries I want
08:07:26 <kmc> if i say "case x of Just _ -> ...; Nothing -> ...", then it has to evaluate x far enough that the outermost constructor is known
08:07:26 <edlinde> ok
08:07:32 <kmc> this is called "evaluation to weak head-normal form"
08:07:36 <Philippa_> kmc: or another primitive demands, yes
08:07:56 <kmc> an expression is in whnf if the outermost construct is a constructor or a lambda
08:08:01 <edlinde> I found a chapter in "Craft of FP"
08:08:03 <kmc> even if there's reducible expressions buried within
08:08:09 <merijn> edlinde: Not even that
08:08:12 <edlinde> wonder if someone here has read it and has any opinions
08:08:26 <merijn> edlinde: It'll only calculate the first 10 once someone actually uses them :p
08:08:36 <edlinde> merijn: yep 
08:08:37 <edlinde> true
08:08:39 <Philippa_> (like the show function printing your output for you)
08:08:43 <kmc> Philippa_, yeah.  well in GHC primitives don't force, they act on unboxed values which have been pattern-matched out.  but this isn't part of Haskell-the-language
08:09:31 <edlinde> there was this tricky question our prof asked us... and I don't think anyone found an "elegant solution" to it .. lemme dig it up
08:09:38 <edlinde> had to do with infinite lists again
08:10:15 <edlinde> Compute the (infinite) list of all integers that can be expressed as products of 2, 3, and 5.
08:10:15 <edlinde> First consider the problem of computing the list of producs of 2 and 3.
08:10:15 <edlinde> Use take to look at the first elements of the list.
08:10:16 <edlinde> The first ten elements should be [2,3,4,5,6,8,9,10,12,15].
08:10:47 <edlinde> the thing I found tricky was that .. how do you stop printing say ...  2*5, then 5*2
08:10:54 <edlinde> 10 would repeat in this list
08:11:29 <zygoloid> edlinde: do you want them in sorted order?
08:11:45 <edlinde> zygoloid: preferably.
08:11:57 <Philippa_> generate in sorting order, filter out those generated 'so far'
08:12:07 <edlinde> I was thinking I need 3 lists yeah?
08:12:14 <Philippa_> 3 lists is a good start, yeah
08:12:16 <edlinde> lists of 2s 3s and 5s
08:12:22 <zygoloid> edlinde: consider this: extend your problem to also generate 1
08:12:27 <edlinde> and then it will permute over those 3 lists
08:12:40 <edlinde> hmm
08:12:48 <merijn> :t cycle $ take 10 $ filter (\x -> x `div` 2 == 0 || x `div` 3 == 0) [1..]
08:12:49 <lambdabot> forall a. (Integral a) => [a]
08:12:56 <merijn> > cycle $ take 10 $ filter (\x -> x `div` 2 == 0 || x `div` 3 == 0) [1..]
08:12:56 <zygoloid> then if your list is ns, then your list is also 1 plus the result of multiplying everything in ns by 2, 3,  and 5
08:13:00 <lambdabot>   mueval-core: Time limit exceeded
08:13:04 <merijn> Oh, ofc
08:13:14 <merijn> > take 20 $ cycle $ take 10 $ filter (\x -> x `div` 2 == 0 || x `div` 3 == 0) [1..]
08:13:17 <lambdabot>   mueval-core: Time limit exceeded
08:13:20 <merijn> blah
08:13:29 <zygoloid> and [1], (2*) <$> ns, (3*) <$> ns and (5*) <$> ns are all in sorted order
08:13:29 <edlinde> is there a smarter way of doing this without having to do a div?
08:13:36 <edlinde> just wondering
08:13:43 <zygoloid> so if you can merge sorted lists to form a sorted list then you're done
08:13:59 <zygoloid> (insert proof that this is productive here)
08:14:12 <edlinde> I haven't seen cycle
08:14:17 <merijn> doh
08:14:18 <edlinde> will check it out.. one sec
08:14:26 <merijn> The == is wrong for filter :p
08:14:37 <merijn> > take 20 $ cycle $ take 10 $ filter (\x -> x `div` 2 /= 0 || x `div` 3 /= 0) [1..]
08:14:38 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,2,3,4,5,6,7,8,9,10,11]
08:14:53 <merijn> eh
08:15:00 <merijn> > take 20 $ cycle $ take 10 $ filter (\x -> x `div` 2 /= 0 && x `div` 3 /= 0) [1..]
08:15:01 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,3,4,5,6,7,8,9,10,11,12]
08:15:06 <merijn> hmm
08:15:10 <merijn> I fail at this :p
08:15:14 <edlinde> hehe
08:15:17 <merijn> That's what I get for coding without thinking
08:15:19 <fxr> JaffaCake: sorry, is there a way to understand which part of the threadscope output corresponds to exactly which function?
08:15:19 <edlinde> its a bit tricky
08:15:41 <JaffaCake> fxr: not really, no
08:15:53 <JaffaCake> fxr: you can use GHC.Exts.traceEvent
08:15:54 <edlinde> zygoloid: I am not sure I understood your merge sort argument
08:16:26 <merijn> > take 20 $ cycle $ take 10 $ filter (not . \x -> x `div` 2 /= 0 || x `div` 3 /= 0) [1..]
08:16:30 <lambdabot>   mueval-core: Time limit exceeded
08:17:22 <fxr> JaffaCake: thanks
08:17:45 <zygoloid> > let ns = nub $ 1:foldr merge [] (flip map ns . (*) <$> [2,3,5]) in ns
08:17:46 <lambdabot>   [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,7...
08:18:10 <jmcarthur> of course that one gets slower and slower as you evaluate the list
08:18:13 <jmcarthur> and more and more memory
08:18:21 <zygoloid> yeah :)
08:18:26 <jmcarthur> i suspect that div is probably going to be the best way
08:18:46 <edlinde> is that a monad?
08:18:51 <edlinde> we haven't been taught those
08:18:56 <edlinde> though I looked them up
08:18:58 <jmcarthur> you already know monads
08:19:09 <edlinde> jmcarthur: do I? ;)
08:19:15 <jmcarthur> i'm *kind of* joking
08:19:19 <kmc> the list type is a monad
08:19:28 <merijn> Ignore the fact the IO is a monad and look at the Maybe and list monads first
08:19:32 <kmc> edlinde, "monad" is the name of a general API implemented by lots of types
08:19:37 <edlinde> k
08:19:44 <kmc> so you already know most of those types, even if you don't know that this API generalizes across them
08:19:48 <jmcarthur> > [] 5
08:19:49 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
08:20:01 <kmc> for lists, (>>=) is concatMap
08:20:01 <jmcarthur> why did i think that would work
08:20:14 <merijn> jmcarthur: Youthful optimism?
08:20:31 <jmcarthur> [] is a type constructor, not a function :\
08:20:40 <edlinde> zygoloid: so is that the best answer?
08:20:46 <merijn> > [] Int
08:20:47 <lambdabot>   Not in scope: data constructor `Int'
08:21:02 <jmcarthur> zygoloid's answer is certainly not the best if you want it to be fast far down the list
08:21:02 <zygoloid> no, you can dobetter
08:21:03 <merijn> That'd be
08:21:06 <merijn> :k [] Int
08:21:06 <lambdabot> *
08:21:10 <merijn> \o/
08:21:17 <merijn> :t [] Int
08:21:18 <lambdabot> Not in scope: data constructor `Int'
08:21:19 <edlinde> ok hmmm
08:21:46 <merijn> edlinde: Something with div is going to be best I think
08:21:59 <jmcarthur> mod
08:22:18 <edlinde> merijn: ok
08:22:27 <edlinde> have to think of some way then
08:22:37 <edlinde> its just being able to filter the dups
08:22:49 <edlinde> do you think its good to then just do a filtering of dups in the end?
08:22:56 <edlinde> or would that be stupid?
08:23:14 <Philippa_> thought: 2,3 and 5 are prime
08:23:22 <Philippa_> therefore, every number can be described by a 3-tuple
08:23:35 <Jafet> 4 is subprime
08:23:47 <tg_> Philippa_: 4
08:23:48 <sipa> Philippa_: how?
08:23:55 <Philippa_> (2,0,0) is 4
08:24:02 <sipa> what about 7?
08:24:08 <jmcarthur> > filter (\n -> any (== 0) $ map (mod n) [2,3,5]) [1..]
08:24:09 <lambdabot>   [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30,32,33,34,35,36,...
08:24:35 <jmcarthur> @pl filter (\n -> any (== 0) $ map (mod n) [2,3,5]) [1..]
08:24:36 <lambdabot> filter (any (0 ==) . flip map [2, 3, 5] . mod) [1..]
08:24:52 <jmcarthur> tada!
08:24:56 <Philippa_> that is foldNat (* 2) 2 $ foldNat (* 3) 0 $ foldNat (* 5) 0 $ 1
08:25:00 <emiel_> hey guys, just a quick question, but it's turning me crazy i can't find it on google - how the hell do bitwise operators work in haskell? how the hell do i apply Data.Bits.xor to integers? 
08:25:19 <Philippa_> so we need to generate all such tuples /once/, and sort the results
08:25:19 <sipa> :t (.&.)
08:25:20 <lambdabot>     Ambiguous occurrence `.&.'
08:25:20 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
08:25:21 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
08:25:27 <jmcarthur> Philippa_: nice one
08:25:31 <sipa> :t Data.Bits.(.&.)
08:25:32 <lambdabot> Couldn't find qualified module.
08:25:37 <jmcarthur> sort stinks though
08:25:39 <sipa> :t (Data.Bits..&.)
08:25:40 <lambdabot> forall a. (Bits a) => a -> a -> a
08:25:45 <jmcarthur> for an infinite list
08:25:49 <edlinde> Philippa_: whats foldNat?
08:25:58 <Philippa_> edlinde: "apply n times"
08:26:05 <edlinde> k
08:26:08 <jmcarthur> :t foldNat
08:26:09 <lambdabot> Not in scope: `foldNat'
08:26:10 <Philippa_> (where 0 = id)
08:26:24 <emiel_> sipa: yes, so how do i use it with Num's?
08:26:33 <Philippa_> yeah, if it's in the libs it's "repeat" or similar
08:26:47 <Philippa_> called foldNat because I figure at least some of the chan know what it means by that name
08:26:50 <emiel_> or construct a Bits instance
08:26:57 <sipa> do you need to?
08:27:01 <jmcarthur> @let foldNat f n x = iterate f x !! n
08:27:02 <lambdabot>  Defined.
08:27:03 <sipa> > 5 .&. 7
08:27:04 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:27:04 <lambdabot>    `Data.Bits.Bits a'
08:27:04 <lambdabot>      a...
08:27:14 <jmcarthur> > foldNat (*2) 5
08:27:15 <sipa> > (5 .&. 7) :: Int
08:27:15 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:27:16 <lambdabot>    arising from a use of `...
08:27:16 <lambdabot>   5
08:27:20 <edlinde> Philippa_: I get a Not in scope
08:27:26 <jmcarthur> > foldNat (*2) 5 1
08:27:27 <lambdabot>   32
08:27:50 <Jafet> > let merge (x:xs) (y:ys) = case compare x y of LT -> x:merge xs (y:ys); EQ -> x:merge xs ys; GT -> y:merge (x:xs) ys; m = 1 : merge (map (2*) m) (merge (map (3*) m) (map (5*) m))) in m
08:27:50 <jmcarthur> edlinde: it's not in the standard libs
08:27:51 <lambdabot>   <no location info>: parse error on input `='
08:28:08 <Philippa_> next Q: can we work out how the ordering works on these without just ordering the results?
08:28:08 <emiel_> sipa: Ambiguous type variable `t' in the constraint: `Data.Bits.Bits t' arising from a use of `Data.Bits..&.' at <interactive>:1:0-16
08:28:09 <edlinde> yeah I couldn't find it in hoogle
08:28:33 <Philippa_> (1 *5 is worth more than a *3 or a *2 or 2 *2 but less than any other combination...)
08:28:34 <applicative> revenantphx you there?  https://gist.github.com/727175 
08:28:37 <sipa> emiel_: .&. doesn't fix what type its argument or result is
08:28:46 <emiel_> ahh
08:28:49 <emiel_> hell
08:28:59 <tg_> Philippa_: I wasn't here until about 3 minute ago. What are we trying to do here?
08:29:00 <sipa> > (31 .&. 48) :: Int
08:29:01 <lambdabot>   16
08:29:05 <emiel_> i see
08:29:09 <sipa> > (31 .&. 48) :: Integer
08:29:10 <lambdabot>   16
08:29:10 <Philippa_> tg_: generate in order all products of 2, 3 and 5
08:29:24 <tg_> Philippa_: for exercise?
08:29:27 <Philippa_> yeah
08:29:30 <tg_> ok
08:29:37 <sipa> @instance Bits
08:29:37 <lambdabot> Maybe you meant: instances instances-importing
08:29:42 <Jafet> > let merge (x:xs) (y:ys) = case compare x y of { LT -> x:merge xs (y:ys); EQ -> x:merge xs ys; GT -> y:merge (x:xs) ys; }; m = 1 : merge (map (2*) m) (merge (map (3*) m) (map (5*) m)) in take 100 m
08:29:43 <lambdabot>   [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,7...
08:29:44 <jmcarthur> tg_: and we know filter with mod works, but Philippa_ is trying something cooler
08:29:47 <sipa> @instances-importing Data.Bits Bits
08:29:47 <lambdabot> Int, Integer
08:29:47 <Philippa_> I assume edlinde is going to own up to having asked in here, not least due to risk of lecturer reading the logs :-)
08:30:20 <edlinde> Jafet: pretty neat
08:30:31 <Philippa_> right, I want to find a sensible way to characterise the 'flattening' of the 3-tree generated by multiplying by one of our primes that gives us the right ordering
08:30:46 <revenantphx> Oh hey applicative
08:30:57 <revenantphx> what'd you change applicative 
08:30:58 <edlinde> hehe
08:30:58 <quicksilver> every night, lambdabot zips the days logs and sends them to all lecturers giving haskell-based courses. It's a neat feature.
08:31:02 <Philippa_> so en route, I'm defining our numbers as three-tuples that give the coefficient we use for each of *2, *3 and *5
08:31:14 <Philippa_> only now I've got to do other stuff for a while, so someone else pick up the baton?
08:31:29 <applicative> revenantphx, i couldn't resist trying idiom brackets to get rid of the liftM9 liftM7 
08:31:36 <edlinde> Jafet: why do you use the merge?
08:31:45 <jmcarthur> liftM9? :(
08:31:51 <applicative> revenantphx, I just wanted to see if the preprocessor would bear up. 
08:31:54 <revenantphx> what did you do 0.o
08:31:59 <revenantphx> is this crazy template haskell shit?
08:32:03 <Philippa_> (we know that 0 is /not/ an element of our output, but no biggie: nominally it's the starting value of my tree which'd have (0,0,0) at root)
08:32:17 <jmcarthur> @where she
08:32:18 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
08:32:20 <jmcarthur> revenantphx: ^^
08:32:38 <applicative> no, it's a preprocessor for things like f <$> x <*> y <*> z
08:32:42 <revenantphx> 0.o
08:32:46 <revenantphx> interesting
08:32:50 <jmcarthur> she is cool
08:33:22 <applicative> the nastiness of liftM9 is overcome by the <$> <*> 's but, they take up space....
08:33:42 <applicative> so the preprocessor rewrites them
08:34:08 <applicative> the brackets are not that useful -- as Philippa can attest -- this seemed like a case where they were
08:34:48 <applicative> i've been trying to extract the handler of them from the rest of she, of which this is a minor element
08:34:49 <jmcarthur> yeah i don't really care so much for idiom brackets
08:35:00 <jmcarthur> i love other parts of she though. too bad error messages get weird
08:35:22 <jmcarthur> and it of course breaks haddock :\
08:35:22 * Philippa_ tries to remember why she can attest as opposed to merely wanting other sugar too
08:35:33 <applicative> jmcarthur, I like them, but grant that they aren't that useful.  They bring out whats going on with class Applicative
08:35:38 <Philippa_> (I'm one of the people to've proposed an 'applicative do', granted)
08:35:44 <Jafet> class AlgebraicStructure a where dwim :: a -> DWIM a
08:36:15 <applicative> Philippa_, yes, that's what I was thinking of, idiom brackets are constantly defeated by the need for something like applicative do
08:36:29 <jmcarthur> what do some applicative do proposals look like?
08:36:42 <jmcarthur> just idiom brackets with ; representing *>?
08:37:09 <jmcarthur> hmm, that's not quite equivalent to do notation either
08:37:13 <Philippa_> thought re the primes problem: you need a list of nodes that you haven't generated all the children for yet. Possibly, one you haven't generated the *2 child for, one you haven't generated the *3 child for, and one you haven't generated the *4 child for
08:37:20 <Philippa_> keep /those/ nodes sorted by output value
08:37:39 * applicative looks to see ; where did I see it carried out?
08:37:44 <Philippa_> not /all/ ungenerated nodes yet, just the ones that're imminent for traversal
08:38:05 <Philippa_> jmcarthur: you need <- as well, which you accomplish by replacing the 'return' line with a lambda
08:38:58 <Philippa_> (actually if we're generating by list comprehensions we probably need the all-the-children list - then you just pick whichever one'll have the smallest result, drop it off the list and put its kids on the back)
08:39:06 <applicative> jmcarthur, http://stackoverflow.com/questions/3336235/haskell-would-do-notation-be-useful-for-contexts-other-than-monads
08:39:12 <Philippa_> so I'm going to get a non-comprehension solution for now, someone else want to comprehensionise it?
08:39:28 <applicative> jmcarthur, the link to a haskell-cafe discussion with Philippa_ et al is very interesting
08:40:48 <merijn> All the problems listed in the accepted stackoverflow answer would be solved in Epigram style pattern matching, no?
08:41:05 <jmcarthur> so the applicative do proposal is just to make a subset of do notation desguar into applicative code instead of monadic?
08:41:19 <revenantphx> Does anyone know of a 2D hash map?
08:41:29 <sipa> revenantphx: ?
08:41:29 <revenantphx> X and Z coordinate to a data chunk.
08:41:35 <mauke> revenantphx: why does it have to be a hash?
08:41:41 <revenantphx> doens't have to be
08:41:45 <revenantphx> let me describe the usage case
08:41:47 <mauke> Map (a, b) c
08:41:48 <Philippa_> jmcarthur: there's two variants, one has 'applicative do' syntactically distinct from do. I prefer a variant that isn't, given the right typeclass relationships, but that's a bit more hard work
08:41:49 <quicksilver> Map (Int,Int) Blah
08:41:52 <revenantphx> I have 32x32x128 sized chunks which can arrive in any order.
08:41:54 <merijn> revenantphx: Map can already use tuples, afaik
08:42:04 <Philippa_> (but it's also nicer if you've got a monadic parser that optimises its applicative subset, for example)
08:42:04 <revenantphx> It'd be nice to access chunks by X and Z
08:42:14 <applicative> jmcarthur, yes, I don't find it that thrilling; but....
08:42:20 <revenantphx> however, it would also be nice to be able to access *within* each chunk by X, Y, Z
08:42:24 <revenantphx> 32x128x32*
08:42:31 <applicative> what Philippa_ said.  there can be optimizations
08:42:54 <Philippa_> it's not zomg-awesome, but it's potentially rather nice in the context of an applicative parsing lib even without a monadic component - use cases where you care about labelling the intermediates
08:43:10 <Philippa_> and in parsing, that can be valuable info for a reader
08:43:18 <jmcarthur> i see the appeal
08:43:26 <AdaHopper> hi, I'm sorry but I'm having problems trying to include a backslash into a regex. Using Text.Regex.Posis 
08:43:39 <applicative> but what seems more interesting is the idea of breaking open the "do" machinery.  cp the remark of yairchu
08:43:53 <jmcarthur> i'm one of those "minimize do notation when possible" guys, but even i use it sometimes, especially for IO. for parsing i tend to prefer the written out applicative code anyway though
08:44:01 <unkanon> AdaHopper: if I were you I'd use pcre instead of posix
08:44:09 <jmcarthur> but maybe given an alternative i would change my mind
08:44:19 <AdaHopper> thanks! :)
08:44:27 <applicative> blazehtml declares a monoid instance to be a monad, just to use do notation, for example.  
08:44:29 <Philippa_> there're definitely times when it's less than ideal, like when you're doing more with the data than just passing to a constructor
08:44:46 <Philippa_> (I tend to have ASTs with 'single lambda only', and concrete syntax with multi-lambda, for example)
08:44:51 <revenantphx> ?...
08:44:52 <lambdabot> Not enough arguments to @.
08:45:25 <Philippa_> I do need to get more into the habit of using applicatives for constraint problems
08:45:33 <zygoloid> > let muls m ns = mergeN $ map (flip map ns . (*)) (iterate (*m) 1) in muls 2 . muls 3 . muls 5 $ [1]
08:45:34 <lambdabot>   [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,7...
08:45:50 <zygoloid> ^^ i'm reasonably happy with this one.
08:46:00 <applicative> or take chrisdone's lispy desire for (+ 3 4 5 6 (10 * 2)) ; this could use a foldr' do, so to speak
08:46:03 <jmcarthur> revenantphx: Map (x,y) (Map (x,y,z) a)  ?
08:46:18 <revenantphx> but I've got a bytestring.... it'd be expensive to convert it all to bytestring yes?
08:46:19 <jmcarthur> revenantphx: or whatever
08:46:29 <Philippa_> but really I need 'applicative do' there for purpose of making it easy to verify against inference rules
08:46:32 <jmcarthur> convert what to bytestring?
08:46:41 <revenantphx> er, from bytestrings to that.
08:47:02 <jmcarthur> revenantphx: you have to convert from bytestrings to *something*. why not a Map?
08:47:08 <revenantphx> true
08:47:25 <Philippa_> anyway, I gotta go for a while
08:47:44 <jmcarthur> revenantphx: also if you know that the keys you will get from the bytestring are in ascending order you can use a special function to create the map that operates in linear time instead of inserting each one individually
08:47:47 <revenantphx> so map is a generic sparse map
08:48:03 <jmcarthur> revenantphx: if the keys are Int you could also use nested IntMaps
08:48:05 <revenantphx> the bytestring has to be ungzipped first of all.
08:48:08 <jmcarthur> they have pretty fast lookup
08:48:11 <revenantphx> and then it's arranged like this, in four sections
08:48:17 <revenantphx> Block type array (1 byte per block)
08:48:17 <revenantphx> Block metadata array (half byte/nibble per block)
08:48:17 <revenantphx> Block Light array (half byte/nibble per block)
08:48:18 <revenantphx> Sky Light array (half byte/nibble per block)
08:48:19 <applicative> Philippa_ inference rules are the ones in {#-RULES   -#} ? 
08:48:29 <revenantphx> (not full bytes, hurray)
08:48:33 <jmcarthur> revenantphx: your project is interesting :)
08:48:38 <revenantphx> I know :).
08:49:00 <revenantphx> It's a great protocol to play with. a) its shit and difficult, b) it involves a lot of different algorithms and management strategies.
08:49:12 <revenantphx> And 99% of it is so silly and contrived XD
08:49:16 <jmcarthur> minecraft has destroyed a lot of my productivity. you are managing to be productive *while* messing with minecraft :P
08:49:21 <revenantphx> Yep
08:49:28 <revenantphx> You should get on #mcc on espernet
08:49:36 <jmcarthur> no i shouldn't
08:49:42 <jmcarthur> i should get back to coding
08:49:58 <revenantphx> #mcc is just people coding mc related stuff :P
08:50:00 <revenantphx> anyways
08:50:10 <revenantphx> so could I break up the data into four chunks (predicting size)
08:50:22 <revenantphx> and then what would I use to add entries?
08:50:35 <revenantphx> the indexes are based on
08:50:35 <revenantphx>  index = y + (z * (Size_Y+1)) + (x * (Size_Y+1) * (Size_Z+1))
08:50:55 <revenantphx> this is the packet itself
08:50:56 <revenantphx> http://mc.kev009.com/wiki/Protocol#Map_Chunk_.280x33.29
08:50:58 <jmcarthur> i can't say i really understand *all* of this. i don't know mc internals very well
08:51:12 <revenantphx> We've got the entire thing dissasembled.
08:51:19 <jmcarthur> so are you wanting to have different maps for each part of the chunk or something?
08:51:38 <revenantphx> No no, I want to compose the chunks into some uniform storage.
08:52:04 <Philippa_> applicative: inference rules are nothing to do with haskell, they're the common format used for describing type systems (preferably, syntax-directed inference rules)
08:52:10 <aristid> heh, now even #haskell is talking about minecraft
08:52:15 <jmcarthur> "so could I break up the data into four chunks (predicting size)"   you use of the work "chunk" throws me off. i don't know what data you are talking about specifically, and "chunk" has special meaning in mc
08:52:26 <revenantphx> ah, four "parts"
08:52:35 <jmcarthur> and what data is it?
08:52:38 <revenantphx> Look at that link, the section on "Compressed DatA"
08:52:44 <applicative> oh i see, i thought it was coming under the heading of optimization 
08:52:49 <jmcarthur> oh, so it's data *in* each chunk?
08:52:54 <revenantphx> Yes.
08:53:08 <revenantphx> so my map table needs to be
08:53:23 <revenantphx> ChunkX, ChunkY, ChunkZ, X, Y, Z –> Type, Light
08:53:28 <revenantphx> and Metadata
08:53:39 <Philippa_> applicative: nope, it's under the heading of "what things are called is part of the problem domain" :-)
08:53:43 <revenantphx> I'm worried about it being *very slow* to add all of the block entries manualy.
08:54:06 * applicative knows what inference rules are in general; the type theoretical use is a rather esoteric developement of the idea
08:54:11 <jmcarthur> so the Chunk* coordinates index the chunks, and the x,y,z coordinates index the blocks inside a chunk?
08:54:16 <revenantphx> right.
08:54:36 <jmcarthur> revenantphx: if the blocks are in order in the bytestring then you can create a map out of them in linear time
08:54:39 <revenantphx> I'm thinking it might be best to do a map table for each chunk, and then make the blocks in each chunk linear.
08:54:48 <revenantphx> jmcarthur: it's access I worry about
08:54:54 <jmcarthur> access would be O(log n)
08:54:56 <jmcarthur> not bad
08:55:07 <revenantphx> But if within each chunk it's an array or vector
08:55:09 <revenantphx> and I use  index = y + (z * (Size_Y+1)) + (x * (Size_Y+1) * (Size_Z+1))
08:55:18 <revenantphx> I can get much better access time.
08:55:20 <jmcarthur> revenantphx: here's a cool package to consider: http://hackage.haskell.org/package/EnumMap
08:55:24 <theorbtwo> The blocks are in order within the chunk, but the chunks are not in order.
08:55:27 <revenantphx> O(log n) for CHUNK mappijng is good though.
08:55:29 <revenantphx> The issue is this.
08:55:35 <revenantphx> chunks are sparse, blocks within them are not.
08:55:38 <jmcarthur> revenantphx: EnumMap should give you effectively O(1) lookup
08:55:50 <jmcarthur> okay then use an array inside
08:55:52 <jmcarthur> that would be fine
08:56:05 <revenantphx> then I can have an access function to abstract  index = y + (z * (Size_Y+1)) + (x * (Size_Y+1) * (Size_Z+1))
08:56:10 <jmcarthur> do you need to mutate these often?
08:56:14 <revenantphx> Yes.
08:56:29 <revenantphx> The issue here is there's a *lot* of state to manage :3
08:56:34 <jmcarthur> i would seriously just go with EnumMap then
08:57:04 <jmcarthur> a mutable array would be good to, but of course would require IO or ST
08:57:27 <jmcarthur> there's always DiffArray, but i'm afraid of it now because it's so slow :\
08:57:27 <revenantphx> Yeah.
08:57:35 <revenantphx> Tbh, there's going to be a lot of data here.
08:57:41 <revenantphx> I want in place mutable state.
08:57:51 <jmcarthur> okay, then you definitely want an array
08:58:00 <revenantphx> whats the best package for that?
08:58:03 <quicksilver> everybody *thinks* they want in-place mutable state.
08:58:22 <revenantphx> quicksilver: I'm managing millions of blocks, I don't want to have to restore the whole chunk for every modification.
08:58:28 <jmcarthur> quicksilver: i believe him in this case since minecraft updates a lot of blocks one at a time
08:58:47 <jmcarthur> a map would still be okay though, IMO
08:58:48 <revenantphx> it does for chunk updates or multiupdates
08:58:58 <revenantphx> There are 131072 blocks per chunk
08:59:12 <revenantphx> 524288 bytes per chunk TT_TT
08:59:37 <aristid> > 524288 / 1024
08:59:38 <lambdabot>   512.0
08:59:48 <aristid> revenantphx: 0.5 megabytes per chunk
08:59:53 * applicative thinks its a bit strange to think the use of Gentzen's notation in type systems defines what an 'inference rule' is
09:00:02 <revenantphx> aristid: yep.
09:00:12 <jmcarthur> honestly that's not that bad
09:00:23 <revenantphx> And I'm going to have a LOT of edits.
09:00:27 <jmcarthur> revenantphx: just try a map of some sort first. i think you'll be fine
09:00:37 <revenantphx> the other question
09:00:48 <revenantphx> https://gist.github.com/727219
09:01:00 <revenantphx> Here I'm managing my state in a record, should that be fine?
09:01:06 <jmcarthur> revenantphx: Map has O(log n) lookup and update. IntMap has the same, but since Int is bounded it's effectively constant. EnumMap is just a more general version of IntMap
09:01:24 <revenantphx> I'm not looking up by a single int though.
09:01:31 <revenantphx> I'm looking up by 6 values.
09:01:34 <jmcarthur> revenantphx: EnumMap
09:01:47 <kmc> IntMap is much faster than (Map Int).  it's a completely different data structure
09:02:10 <jmcarthur> revenantphx: just make an index type and make an enum instance out of it
09:02:18 <jmcarthur> revenantphx: then you can get that O(1) access :)
09:02:25 <revenantphx> so er, I'm thinking first I'll do a Players record.
09:02:34 <revenantphx> Just track the movement and position of players.
09:02:45 <jmcarthur> revenantphx: records are a decent way to keep state. that's fine
09:02:52 <revenantphx> is there a better one?
09:02:57 <jmcarthur> revenantphx: there's always the FRP approach, but... that's a rabbit hole
09:03:18 <lispy> applicative: chrisdone has a desire for lispy?  What?
09:03:22 <revenantphx> ...FRP?
09:03:38 <revenantphx> I wont ask.
09:03:40 <jmcarthur> revenantphx: functional reactive programming. worth reading up on sometime. don't use it here though :)
09:04:03 <jmcarthur> well, i shouldn't recommend against it
09:04:14 <jmcarthur> but like i said, it's a rabbit hole. just heed that advice
09:04:57 <revenantphx> right.
09:05:20 <revenantphx> anyhow, so what data type would I want for a record of EID (entity ID) to.... lets see, position and some arbitrary dtaa
09:05:33 <revenantphx> I can have an EntityData data type with multiple constructors for each type.
09:05:45 <revenantphx> so Int32 -> (X, Y, Z, EntityData)
09:06:02 <jmcarthur> can there be more than one entity at each x,y,z?
09:06:19 <revenantphx> Yes.
09:06:22 <jmcarthur> oh, yes, nevermind
09:06:37 * jmcarthur just saw what that in on that wiki page
09:07:01 <revenantphx> Entity movement is always relative
09:07:20 <mino> hello im having troubles trying to install gtk under windows
09:07:28 <mino> gtk2hs i mean
09:07:29 <revenantphx> so X Y and Z are absolute double positions
09:07:40 <revenantphx> I'll be back...
09:07:43 <revenantphx> one moment
09:08:09 <mino> it basically says "cpp: Invalid option `-xc'  \ gtk2hsC2hs.exe: Error during preprocessing"
09:08:27 <mino> and i cannot find any reference to this problem in google
09:08:54 <kmc> did you cabal install gtk2hs-buildtools?
09:09:16 <mino> yeah
09:09:23 <mino> withouit problems
09:09:41 <mino> i also installed the gtk bundle 
09:09:58 <mino> as the INSTALL file of gtk2hs says
09:10:16 <mino> but i cant figure what this means
09:10:18 <mino> cpp: Invalid option `-xc'
09:10:56 <mino> i also i have before an error tyhat says * Missing C library: z, but i dont think it is related
09:12:26 <unkanon> jmcarthur: why is it a rabbit hole?
09:12:27 <kmc> did you get the libz headers installed?
09:13:10 <mino> uh... maybe not
09:13:25 <mino> but i think is in gtk bundle
09:13:41 <mino> i used extra-include-dirs flag
09:13:50 <mino> to the bundle who has libz
09:13:58 <mino> i dont know if it is enough
09:14:30 * hackagebot diagrams 0.2.2.2 - An EDSL for creating simple diagrams  http://hackage.haskell.org/package/diagrams-0.2.2.2 (BrentYorgey)
09:14:31 <mino> the include dir has zlib.h
09:14:35 <mino> i checked
09:15:10 <jmcarthur> unkanon: it looks safe enough to jump in but then it never ends
09:15:22 <revenantphx> So...
09:16:32 <unkanon> jmcarthur: you're saying basically that it's a good or a bad thing?
09:16:57 <quicksilver> unkanon: it's a good thing, but it contains unsolved problems.
09:17:02 <jmcarthur> unkanon: it was a warning, but i intended neither good nor bad in that
09:17:10 <quicksilver> not necessarily a recipe for getting things done.
09:17:27 <quicksilver> Conal Elliott's Reactive appears to be the nicest API - but no correct implementation exists.
09:17:50 <quicksilver> Yampa exists, but there are various - fundamental - practical provlems with the approach.
09:17:52 <jmcarthur> i also disagree with many of its API choices
09:17:54 <quicksilver> etc.
09:17:56 <jmcarthur> reactive's
09:18:09 <quicksilver> jmcarthur: fundamental disagreements with the model?
09:18:10 <jmcarthur> yampa at least works
09:18:15 <jmcarthur> quicksilver: Event, namely
09:18:32 <jmcarthur> also with the approach
09:18:34 <quicksilver> ah. I like event. I would like to discuss this with you but now is not the time ;)
09:18:44 <Philippa_> what's the current list of fundamental problems-or-at-least-design-choices with yampa, anyway?
09:19:06 <Philippa_> AIUI... Event was, well, something Yampa doesn't exploit properly as an idea as opposed to just have a type for? But I'm a long time out of date
09:19:19 <Philippa_> (is an Event still just a signal that flashes 'on' for an infinitessimal amount of time?)
09:19:24 <jmcarthur> conal painstakingly explained semantic design and then cherry-picked semantics from different models for different Event instances
09:19:42 <jmcarthur> even to the point of making a very broken monad instance
09:20:13 <quicksilver> jmcarthur: I disagree with the Monad instance for Event
09:20:22 <quicksilver> I don't think Event is a 'natural' Monad.
09:20:27 <quicksilver> my implementation skips that ;)
09:20:38 <alpounet> where's your impl ?
09:21:02 <jmcarthur> i also don't like that the Monoid instance doesn't seem to agree with the Applicative instance, if that even makes sense...
09:21:07 <revenantphx> Okay, so jmcarthur 
09:21:19 <quicksilver> alpounet: in a mailing list posting somewhere :)
09:21:23 <revenantphx> If I wanted a record of entities, then I'd want to store... a map of some sort...
09:21:29 <revenantphx> but should I wrap it in ST or STM?
09:21:59 <jmcarthur> the Monoid instance establishes that combining Events merges their event streams. the Applicative instance instead claims that instead you should take the max time of corresponding events
09:22:04 <Philippa_> * applicative thinks its a bit strange to think the use of Gentzen's notation in type systems defines what an 'inference rule' is <- sure, any notation capable of describing the same entities will do, but common practice around them is still pointed
09:22:11 <jmcarthur> doing a cross product
09:22:15 <quicksilver> jmcarthur: Ah, yes. I reject that applicative instance too.
09:22:19 <quicksilver> jmcarthur: I don't find it useful.
09:22:27 <alpounet> hm okay
09:22:30 <quicksilver> jmcarthur: I just have events as a Monoid + joinE.
09:22:31 <jmcarthur> but you do have an applicative instance?
09:22:34 <jmcarthur> ah
09:22:37 <jmcarthur> then that's okay
09:22:39 <unkanon> what is the point of FRP, in a sentence?
09:22:54 <jmcarthur> quicksilver: then we don't disagree so much on Event after all
09:22:59 <Philippa_> unkanon: describing continuous systems in a functional manner while letting them react to events
09:23:04 <kmc> unkanon, to describe time-varying reactive behaviors declaratively
09:23:10 <jmcarthur> unkanon: continuous, concurrent mutation
09:23:34 <unkanon> hmmm. does that break functional purity?
09:23:36 <kmc> more concretely: to write interactive programs without using imperative programming
09:23:40 <kmc> no
09:23:49 <jmcarthur> revenantphx: ST and STM are quite fundamentally different things
09:23:54 <unkanon> then aren't we already doing that with monads?
09:23:56 <kmc> no
09:24:04 <Philippa_> unkanon: no, only the bit where you hook them up to a wall clock and a bunch of side-effecting sensors and actuators does
09:24:06 <merijn> The goal of FRP struck me as "making it easier for me to write multiplayer games in a functional style" :p
09:24:07 <kmc> first of all "monads" are irrelevant, that just describes a common API
09:24:12 <unkanon> oh, FRP is like functional programming but event-oriented?
09:24:15 <jmcarthur> no
09:24:23 <jmcarthur> not all FRP models care so much about events
09:24:24 <kmc> unkanon, when you build IO actions you're still doing imperative programming
09:24:38 <Philippa_> unkanon: FRP is fundamentally about the "continuous" bit
09:24:39 <unkanon> oh....
09:24:56 <Philippa_> you might be doing imperative programming that can be treated as pure, but you're still doing imperative programming
09:24:56 <revenantphx> Is FRP something i want to look at?...
09:24:59 <jmcarthur> unkanon: the important thing about FRP, in my opinion, is the ability to declaratively talk about concurrently, continuously changing values
09:25:00 <kmc> most monads are not about imperative programming, though
09:25:06 <kmc> but IO is
09:25:10 <aristid> i might be wrong, but AFAIK there's no satisfying FRP library yet
09:25:13 <revenantphx> jmcarthur: that sounds useful :|
09:25:17 <jmcarthur> aristid: indeed
09:25:21 <jmcarthur> revenantphx: potentially
09:25:23 <Philippa_> revenantphx: possibly, it's a good idea to've run into even if you're not in a good place to use it yet
09:25:32 <kmc> in fact you could make an FRP lib with a monadic interface; that wouldn't defeat the purpose
09:25:32 <djahandarie> revenantphx, pretty much ends at "sounds" though ;)
09:25:39 <revenantphx> hahaha.
09:25:40 <unkanon> could there be an FRP lib for haskell without changing GHC?
09:25:49 <kmc> yes, there are several already
09:26:03 <jmcarthur> there are several already, to varying degrees of "good"ness
09:26:10 <revenantphx> FRP has a whole hackage category
09:26:12 <djahandarie> Different types of goodness too
09:26:13 <kmc> it's still an active research topic
09:26:14 <revenantphx> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:frp
09:26:18 <unkanon> but none implemented to a good standard?
09:26:35 <jmcarthur> unkanon: depends on your opinions about it ;)
09:26:36 <revenantphx> Anyways.
09:26:37 <Philippa_> unkanon: it's more that it's an ongoing research problem
09:26:42 <djahandarie> Performance, nice API, FRP... pick two
09:26:57 <jmcarthur> djahandarie: currently that may be the case...
09:27:00 <revenantphx> jmcarthur: how should I keep the map then? :\
09:27:04 <unkanon> so that's what is meant when people say Haskell is on the bleeding edge of research?
09:27:07 <jmcarthur> revenantphx: "keep" it?
09:27:11 <unkanon> that it's the first to get these new ideas
09:27:15 <revenantphx> I mean, wrap it.
09:27:16 <jmcarthur> revenantphx: it's a value. just pass it around as you need it :)
09:27:30 <merijn> unkanon: Lots of programming language researchers work in haskell or related languages, yes
09:27:33 <revenantphx> so if I use insert... how the hell is it modifying it?
09:27:38 <unkanon> very cool
09:27:38 <jmcarthur> revenantphx: architectural decisions depend on many things, and i don't think there's necessary a "one true way" here
09:27:45 <jmcarthur> revenantphx: it creates a new one
09:27:50 <jmcarthur> which you then pass around instead
09:27:57 <revenantphx> yeah...
09:28:09 <revenantphx> I'm wondering if theres an *in place* map.
09:28:11 <Philippa_> revenantphx: learning to think in haskell is full of 'dualities'
09:28:20 <jmcarthur> there is the State monad to help with this, but really, you should have a mastery of this idea *before* using State
09:28:22 <merijn> revenantphx: No, that defeats the purpose of haskell
09:28:25 <Philippa_> if you're throwing away the old one when you create the new one...
09:28:29 <mauke> revenantphx: wrap it in an IORef :-)
09:28:33 <revenantphx> I guess I don't know if its necessary, but it seems inefficient.
09:28:38 <jmcarthur> it's not inefficient
09:28:41 <Philippa_> merijn: opinions vary on that one. Being able to exploit linearity isn't a bad thing
09:28:47 <Philippa_> well, it's not /that/ inefficient
09:28:48 <revenantphx> I mean, I'm getting 20-40 entity changes per second.
09:28:48 <NickHu> Hey guys :)
09:28:49 <revenantphx> If not more.
09:28:55 <revenantphx> So I'd be trashing so many of them.
09:28:56 <jmcarthur> revenantphx: it's not copying the whole map
09:28:58 <jmcarthur> no
09:29:00 <Philippa_> you should be able to get within log of the imperative implementation every time
09:29:05 <revenantphx> No, for entity tracking.
09:29:12 <jmcarthur> revenantphx: 20-40 changes per second is tiny
09:29:18 <merijn> revenantphx: Keep in mind, when you have a tree you only have to create new nodes for the once above the one you're adding. Since the other nodes can't be changed you can just copy pointers to them
09:29:22 <revenantphx> That's with *no other players*
09:29:28 <mauke> s/once/ones/
09:29:28 <jmcarthur> it's still *tiny*
09:29:42 <revenantphx> merijn: so there is some optimization back end for it...
09:29:46 <jmcarthur> no
09:29:48 <revenantphx> it's not doing a deep copy for the new one.
09:29:49 <jmcarthur> it's just how haskell works
09:29:53 <jmcarthur> no way
09:29:57 <merijn> revenantphx: That's how the haskell compiler works
09:29:58 <revenantphx> Oh, thank god.
09:30:05 <mauke> revenantphx: haskell never copies anything
09:30:35 <merijn> revenantphx: The point of haskell is that since you *can't* do in place modification the compiler *knows* it's safe to just copy pointers to old data structures
09:30:49 <merijn> Since old parts of data can't change anyway
09:30:50 <NickHu> Hey, I was wondering if anyone could help me with a sh script outputting to xmobar
09:31:18 <revenantphx> merijn: aaaah, thank goodness.
09:31:21 <revenantphx> Then its okay :D
09:31:27 <jmcarthur> revenantphx: mutation is vastly overrated
09:31:34 <revenantphx> that changes everything for me.
09:31:41 * revenantphx paradigm shift
09:32:43 <jmcarthur> revenantphx: http://en.wikipedia.org/wiki/Purely_functional
09:32:50 <jmcarthur> revenantphx: check out the trees they show there
09:32:55 <funkyjunkyrobot> love those aha moments
09:32:55 <merijn> revenantphx: This also means ghc can do a lot of optimizations C can't. The C compiler always needs to think "What if someone changed this variable since this code ran?", GHC can just go "Oh, it can't change anyway" and do some ridiculous code restructuring like reordering instructions, function calls, etc
09:32:59 <jmcarthur> and the lists
09:33:00 <revenantphx> mm, looking at them.
09:33:08 <revenantphx> merijn: aha!
09:33:09 <revenantphx> I see :D
09:33:32 <revenantphx> those trees make be crack up, I don't know why.
09:33:36 <revenantphx> Just so funny.
09:33:39 <jmcarthur> ?
09:33:48 <revenantphx> Like... giddy.
09:33:49 <revenantphx> No
09:33:51 <jmcarthur> merijn: ghc's new vectorization stuff is the craziest transformation ever!
09:33:59 <revenantphx> not* that it's funny, its just... neat :D
09:34:04 <revenantphx> jmcarthur: what do you mean?
09:34:04 <jmcarthur> being written for dph
09:34:06 <djahandarie> V-v-v-vectorization!
09:34:19 <jmcarthur> revenantphx: i think that's a topic for another time :)
09:34:26 <revenantphx> 0.o
09:34:28 <revenantphx> okay
09:34:42 <jmcarthur> revenantphx: data parallel haskell pretty much turns your code inside out
09:34:48 <jmcarthur> in the compiler
09:34:51 <revenantphx> 0.o
09:34:54 <revenantphx> data parallel?
09:34:55 <augur> hey peeps
09:35:06 <jmcarthur> revenantphx: *nested* data parallel :)
09:35:11 <revenantphx> why are there all of these things like "Concurrent Haskell", "Data Parallel Haskell"
09:35:20 <jmcarthur> because there are many ways to use multiple cores
09:35:21 <revenantphx> Are they just extensions?
09:35:37 <djahandarie> jmcarthur, vectorization as in loop vectorization?
09:35:43 <jmcarthur> i think the idea is just that haskell has a unique take on some of this stuff
09:35:45 <mauke> THEY ARE UNJUST AND CRUEL
09:35:46 <kmc> yeah revenantphx the cool thing here is that GHC *doesn't* have some super fancy copy-on-write data optimization
09:35:49 <jmcarthur> djahandarie: yes, but not like GCC or something
09:36:02 <djahandarie> jmcarthur, good, because GCC sucks at it
09:36:03 <kmc> it's a natural consequence of the most straightforward way of implementing immutable algebraic data
09:36:14 <merijn> revenantphx: Example what C can't and Haskell can do: "map myInsanelyHardFunction myLongList", since variables can't change haskell can run myInsanelyHardFunction in parallel on X cores no problem. C needs to worry whether the function changes global variables
09:36:16 <jmcarthur> djahandarie: it's not for using SIMD or anything like that
09:36:17 <revenantphx> So basically it's differential kmc?
09:36:22 <kmc> new data is allocated when you invoke a constructor
09:36:27 <revenantphx> Reminds me of Io's object system.
09:36:35 <revenantphx> It's prototypical with differential inheritance.
09:36:37 <kmc> if i say f (Just x) = Just x, it will make a new structure
09:36:44 <kmc> if i say f x = x it doesn't
09:36:55 <kmc> but the x inside the Just is shared still
09:37:00 <djahandarie> jmcarthur, then what is it doing?
09:37:01 <revenantphx> merijn: Yeah I see that.
09:37:02 <Twey> Does f s@(Just x) = s?
09:37:21 <kmc> because each constructor is a tag + a record of pointers, conceptually
09:37:27 <kmc> Twey, won't copy but will force. afaik
09:37:30 <revenantphx> In short, functional languages are great on the systems of today... plenty of storage and memory, limited processing power, but plenty of cores.
09:37:34 <Twey> Aye
09:37:40 <jmcarthur> djahandarie: although SIMD might be supported with it later... the point is just that the vectorization pass transforms a bunch of recursive array operations into nice cache coherent operations that can be done in huge chunks at a time
09:37:42 <jeffwheeler> Is there any reason the gtk package doesn't depend on gtk2hs-buildtools? I've just got a bug report suggesting I add -buildtools as a dependency for Yi, and I just saw diagrams fail because -buildtools wasn't installed.
09:38:05 <merijn> revenantphx: Yes, the coming of the functional parallelism revolution! Java will be the first against the wall!
09:38:06 <unkanon> revenantphx: that's very well said :)
09:38:15 <jmcarthur> djahandarie: watch this next time you have 80 minutes to spare http://www.youtube.com/watch?v=NWSZ4c9yqW8
09:38:20 <revenantphx> merijn: Oh I can get behind the death of Java!
09:38:35 <revenantphx> I can definitely see Haskell and Erlang and such as very "upcoming"
09:38:38 <monochrom> gtk2hs-buildtools is an executable-only package. no one tracks its existence.
09:38:52 <jmcarthur> revenantphx: pure, functional programming has a bright future, judging from the trends in hardware design :)
09:38:55 <revenantphx> as I mentioned earlier, they regularly score in the top 5 most discussed languages on IRC, forums and mailing lists
09:38:59 <merijn> revenantphx: Google's Map Reduce is basically functional programming :p
09:39:02 * mzero wants a small black hat with a red star and the haskell logo on it!
09:39:03 <kmc> revenantphx, btw there are many reasons to prefer an immutable structure + IORef or TVar
09:39:04 <djahandarie> jmcarthur, I know how DPH works vaguely, if that is all you are talking about
09:39:10 <kmc> revenantphx, versus a fancy in-place structure
09:39:13 <revenantphx> But not so common in application.
09:39:15 <jmcarthur> djahandarie: that video goes into what the vectorizor does
09:39:20 <revenantphx> mzero: Me too :D
09:39:20 <jmcarthur> a bit late in it
09:39:27 <jeffwheeler> monochrom: I don't get it; why doesn't gtk depend on it if it needs the executables to compile?
09:39:32 <revenantphx> there's no haskell beret :\
09:39:33 <djahandarie> Okay, I'll watch it some time then... some time... time?
09:39:55 <monochrom> if gtk depends on it, it gets rebuilt and rebuilt every time
09:39:55 <mzero> Viva la λ Revolucîon
09:39:58 <merijn> "foldl mergeSort $ map linkRelevance listOfAllLinks" :p
09:39:59 <kmc> with immutable data + STM, you get consistent data snapshots for free; you can do all your data munging outside of any lock and perform an attempted update with a single compare-and-swap instruction
09:40:03 <revenantphx> mzero: damnit, ninja'd
09:40:07 <jmcarthur> djahandarie: i would try to find the time where SPJ starts talking about the vectorizor, but i can't seem to get the vid to work right now
09:40:25 <jeffwheeler> monochrom: oh, is that how that works? Hmm . . . both solutions seem bad, then.
09:40:35 <djahandarie> I'll just watch the whole thing anyways, SPJ is a good speaker
09:40:45 <jmcarthur> yeah
09:40:56 <unkanon> yes, he even gives talks about giving talks
09:40:57 <monochrom> and I am not sure that that is the worst it gets.
09:41:12 <unkanon> at least I watched 3 minutes of him explaning how to be enthusiastic about the topic of your lecture
09:41:27 <unkanon> he's a surprisingly good speaker
09:41:51 <merijn> revenantphx: These are the sorts of matrix-like revelations that attract people to haskell/functional programming ;)
09:41:52 <haskeller> what lecture would that be, unkanon ?
09:42:01 <revenantphx> merijn: yeah haha
09:42:03 <unkanon> haskeller: hold on, I'll get you the link
09:42:11 <jmcarthur> revenantphx: simplest example of purely functional update:   0 : [1..]    -- the infinite list won't be copied, as that would obviously be inefficient :)
09:42:21 <haskeller> thanks
09:42:28 <unkanon> haskeller: http://www.youtube.com/watch?v=mhmf3Q4n104
09:42:39 <unkanon> haskeller: it looks to be split up in small chunks of 3 mins
09:42:40 <revenantphx> jmcarthur: isn't that also lazyness?
09:42:44 <jmcarthur> revenantphx: that is, even if that infinite list is also used elsewhere
09:42:51 <unkanon> haskeller: so go from that video's linked videos on the right
09:43:02 <revenantphx> So jmcarthur the thing I'm wondering now.
09:43:09 <jmcarthur> > let inf = [1..] in (take 5 inf, take 4 (0 : inf))
09:43:10 <lambdabot>   ([1,2,3,4,5],[0,1,2,3])
09:43:16 <revenantphx> Is say I'm performing a bunch of transformations on the map.
09:43:27 <haskeller> sweet, thanks.
09:43:33 <haskeller> he really rocks
09:43:36 <revenantphx> Notice that I'm not calling recursively, I'm using forever
09:43:40 <unkanon> haskeller: np. I just really think he's an awesome presenter. :)
09:43:47 <revenantphx> https://gist.github.com/727266
09:43:53 <mauke> @src forever
09:43:53 <lambdabot> Source not found. My pet ferret can type better than you!
09:43:57 <revenantphx> I'm not sure how I'd "persist" it.
09:43:58 <unkanon> @type forever
09:43:58 <haskeller> though the accent really kills sometimes
09:43:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
09:44:20 <unkanon> haskeller: yes his R's are almost like W's
09:44:22 <jmcarthur> revenantphx: the State monad would allow that
09:44:30 <unkanon> some of his R's at least
09:44:31 <jmcarthur> revenantphx: or StateT MyData IO
09:44:49 <jmcarthur> revenantphx: or you could even just use an IORef MyData, if you wanted...
09:44:56 <revenantphx> Can't I just do State MapM within my MyData?
09:45:00 <haskeller> heh
09:45:00 <revenantphx> or should I wrap the whole thing in State
09:45:02 <jmcarthur> within?
09:45:09 <jmcarthur> State is a monad
09:45:09 <revenantphx> wait... StateT MyData IO?
09:45:13 <revenantphx> why that specifically?
09:45:22 <revenantphx> I need to learn more about State 
09:45:25 <jmcarthur> oh you're using BinaryProtocol
09:45:29 <revenantphx> mm.
09:45:30 <jmcarthur> StateT MyData BinaryProtocol
09:45:39 <revenantphx> binary protocol is actually
09:45:45 <revenantphx> StateT (Handle, Handle, ByteString) IO
09:45:46 <revenantphx> I believe.
09:45:58 <jmcarthur> @unmtl StateT MyData BinaryProtocol a
09:45:58 <lambdabot> MyData -> BinaryProtocol (a, MyData)
09:46:14 <mino> which is the main library for build GUI apps in haskell? i have troubles to install gtk2hs i dont know if there is any other(in haskell webpage it seems almost all based on this)
09:46:15 <revenantphx> https://gist.github.com/727266
09:46:16 <revenantphx> type BinaryProtocol = StateT (Handle,Handle,L.ByteString) IO
09:46:23 <jmcarthur> @unmtl StateT MyData (StateT (Handle, Handle, ByteString) IO) a
09:46:23 <lambdabot> MyData -> Handle -> Handle -> ByteString -> IO (a, MyData, Handle, Handle, ByteString)
09:46:35 <revenantphx> ?....
09:46:35 <lambdabot> Unknown command, try @list
09:46:36 <dcoutts_> mino: I'd use gtk2hs
09:47:00 <jmcarthur> revenantphx: that's just what StateT looks like if you unwrap it. it takes an input and returns a new version of it to use later
09:47:08 <merijn> High level haskell design question: For a game server you'd want a game loop which essentially has the type "WorldState -> StateChanges -> IO ()" which recursively calls itself until it terminates. Inside you'd want to block waiting for either new StateChanges to arrive or certain amount of time X has passed. How would this problem best be approached?
09:47:10 <revenantphx> k
09:47:38 <revenantphx> So what do I want to do here?
09:47:49 <mino> dcoutts_: ok then i will keep fighting with bugs; thanks
09:47:57 <jmcarthur> revenantphx: it's really up to you. there are many ways to do it
09:47:58 <mzero> merijn: model X amount of time passing as a StateChange!?
09:48:07 <kmc> merijn, use actual threads?
09:48:16 <jmcarthur> revenantphx: i personally would probably go with StateT or explicit recursion instead of forever, i think
09:48:32 <edlinde> Philippa_: you still around?
09:48:43 <jmcarthur> revenantphx: actually, i personally would probably not be using BinaryProtocol. it looks like it's been limiting you a lot
09:48:44 <revenantphx> is recursion tail call optimized?
09:48:55 <kmc> yes revenantphx
09:48:55 <jmcarthur> revenantphx: tail call optimization is a bit more meaningless in haskell
09:49:00 <revenantphx> jmcarthur: It's just very convenient, since i don't have to deal with other stuff I'm rather not.
09:49:00 <c_wraith> revenantphx, yes, but usually that's the wrong question to ask in haskell
09:49:01 <jmcarthur> revenantphx: kind of like copying ;)
09:49:04 <revenantphx> true.
09:49:11 <revenantphx> I'd rather not*
09:49:15 <unkanon> what's the right question?
09:49:16 <kmc> revenantphx, the stack in GHC code is not a call stack but a forcing stack
09:49:22 <c_wraith> because tail-call optimization means nothing without strictness
09:49:49 <merijn> kmc: Well, I was thinking I'd forkIO threads to handle communication and use something like MVar's to post updates to the main thread running the loop. But how do I block until I either receive an update from a thread *or* X amount of time has passed?
09:50:02 <kmc> merijn, wait on a Chan
09:50:15 <kmc> have threads put messages into that chan
09:50:21 <kmc> have a thread which sleeps for X then writes a message
09:50:25 <unkanon> I guess the question would be, can I overflow any stack if I have a tail recursive function?
09:50:31 <kmc> unkanon, yes
09:50:36 <merijn> kmc: I haven't really found any good examples of this sort of haskell code, if anyone could point me to an open source program that does something similar I can look at that'd be great too
09:50:38 <jmcarthur> unkanon: for some definition of "tail recursive"
09:50:38 <kmc> because the stack is not about calling but about forcing
09:50:39 <unkanon> what is that stack called?
09:50:45 <sm> mino: gtk2hs can be a pain but is installable.. what platform ?
09:50:47 <jmcarthur> IMO, "tail recursion" is pretty much meaningless in haskell
09:50:52 <revenantphx> Why is this in text-speek
09:50:53 <revenantphx> writeList2Chan
09:51:02 <kmc> unkanon, read about foldl versus foldl'
09:51:05 <jmcarthur> because somebody sucks at life, revenantphx ;)
09:51:08 <kmc> should be on the haskell wiki somewhere
09:51:11 <revenantphx> haha
09:51:15 <unkanon> kmc: I've read about that, that I understand
09:51:29 <mino> sm: Windows
09:51:35 <kmc> basically what matters is not that you're tail recursive (both are) but that you're not building up a bunch of nested thunks
09:51:43 <kmc> because it's the forcing of many nested thunks which overflows the stack
09:51:45 <djahandarie> revenantphx, they could have been talking about 2chan.net
09:51:49 <revenantphx> jmcarthur: so how would you recommend I change my program for state?
09:51:54 <kmc> conversely, a function can be non-tail-recursive but run in constant space
09:51:56 <revenantphx> djahandarie: right
09:52:09 <unkanon> kmc: oh ok. being that foldl' is the strict foldl, is foldl' just foldl using `seq` ?
09:52:13 <sm> aha, the wildest territory. Sorry, no experience to share
09:52:14 <kmc> @src foldl'
09:52:14 <lambdabot> foldl' f a []     = a
09:52:15 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:52:20 <jmcarthur> revenantphx: i've already said what i would do
09:52:24 <unkanon> there ya go, the seq there
09:52:39 <mino> sm: in the past i programmed in haskell and i remember gtk2hs come into a handy .exe intallator for deploy all the stuff, but now the webpage is down
09:52:54 <kmc> i would write it thus:  foldl' f = go where { go !a [] = a; go !a (x:xs) = go (f a x) xs }
09:52:57 <unkanon> kmc: really? non-tail-recursive but act as an assembly loop?
09:52:57 <kmc> i think that should be equivalent
09:53:06 <kmc> unkanon, yes, if fusion occurs
09:53:07 <mino> sm: well thanks, i know windows is wild territory for haskell
09:53:12 <revenantphx> jmcarthur: can you restate :P?
09:53:20 <unkanon> oh there comes the fusion thing you guys talk so much about
09:53:23 <jmcarthur> revenantphx: i personally would probably go with StateT or explicit recursion instead of forever, i think
09:53:28 <unkanon> I still have to read up on fusion
09:53:29 <jmcarthur> revenantphx: actually, i personally would probably not be using BinaryProtocol. it looks like it's been limiting you a lot
09:53:40 <sm> well, GHC, the HP and cross-platform packages work well.. I've installed yesod on windows. Not gtk2hs though
09:53:44 <jmcarthur> you can take your pick
09:53:48 <kmc> but moreover even if there's no fusion, the non-tail-recursive version doesn't run a stack-overflow risk
09:53:49 <jmcarthur> or do something entirely different
09:53:50 <revenantphx> Yes, well not using BinaryProtocol opens me up to a lot of explicit stuff which'd be nice not to deal with. What's the alternative here :\
09:53:56 <jmcarthur> it's really just up to your personal preferences
09:53:56 <revenantphx> I can do it recursively though.
09:54:00 <EnglishGent> hello :)
09:54:07 <sm> if you don't need widgets, opengl can be easier
09:54:08 <kmc> basically you might expect "length $ map (2*) xs" to take twice as much space as "length xs"
09:54:10 <kmc> but it probably won't
09:54:11 <revenantphx> I'll think about it...
09:54:16 <revenantphx> after reading up on State a bit.
09:54:17 <kmc> because length eats the constructors as map produces them
09:54:26 <kmc> it might increase the frequency of GC, though
09:54:41 <unkanon> because of laziness , right
09:54:43 <applicative> nickHu, no one's awake in #xmonad I guess?
09:54:54 <kmc> yes
09:54:56 <unkanon> so I should never worry about re-writing my function to be tail recursive?
09:55:03 <dcoutts_> mino: ah, gtk2hs is in the process of moving website from haskell.org to projects.haskell.org. You can probably find the .exe installer on the sourceforge gtk2hs website
09:55:04 <kmc> unkanon, no
09:55:14 <kmc> it depends what you're doing
09:55:19 <unkanon> kmc: that's a load off of programmers' shoulders everywhere
09:55:21 <kmc> sum = foldl' (+) 0
09:55:23 <kmc> not foldr
09:55:27 <dcoutts_> mino: http://sourceforge.net/projects/gtk2hs/
09:55:30 <kmc> foldr is non-tail-recursive but incremental
09:55:41 <kmc> but it doesn't matter because (+) won't produce a ctor until it's evaled both sides
09:55:41 <unkanon> yes foldr is thunk dependent
09:55:42 <kmc> (for Int et)
09:55:52 <mino> sm: i just need widgets, in fact gtk fits well to my idea, cairo, pango, and widgets
09:55:52 <kmc> so it's more efficient to accumulate with a strict parameter
09:56:04 <kmc> but map f = foldr ((:).f) []
09:56:22 <kmc> because ((:).f) will produce a (:) cell before forcing the rhs
09:57:16 <sm> mino: maybe check the manatee project, it's the biggest gtk2hs user afaik
09:57:27 <unkanon> hmm I see
09:57:52 <merijn> kmc: Ah, so the best way would be to have all connections fork of a thread then post to a single chan where the main thread/loop is listening and in addition fork of another thread which posts an "update" message every X seconds using threadDelay?
09:58:28 <kmc> that's how i would structure it
09:58:31 <kmc> in any language really
09:58:49 <kmc> (as long as threads are lightweight, which they are in GHC haskell)
09:58:50 <mino> dcoutts_: not latest version in that web, i tryed to install that version before but it seems problematic with latest ghc
09:59:14 <dcoutts_> mino: right, since it's a binary the ghc version needs to match
09:59:15 <mino> sm: thanks, i will
09:59:24 <merijn> kmc: Well, in other languages I'd probably use async IO instead of threads for demultiplexing incoming connections but I didn't really know how to translate that to haskell
09:59:43 <dcoutts_> mino: easiest thing would be to install the ghc version that that gtk2hs exe uses
09:59:45 <kmc> the way you translate it to GHC Haskell is to use threads :D
09:59:57 <kmc> the GHC IO manager will perform async IO behind the scenes
10:00:11 <merijn> Yeah, I know. But I didn't know about Chan's and threadDelay before
10:00:22 <merijn> I already read about GHC 7 now having kqueue support \o/
10:00:33 <kmc> i think this is better than coding async IO directly, because you don't have to turn everything inside out
10:00:44 <mino> dcoutts_: i will consider that if i cant solve the issue, thanks
10:00:44 <kmc> yep epoll too
10:01:03 <merijn> Well, I might actually start writing code at some point, then
10:01:04 <dcoutts_> mino: what are you trying at the moment?
10:01:46 <edlinde> can I have multiple let declarations?
10:01:58 <edlinde> or multiple declarations in the same let I mean
10:02:01 <FauxFaux> Try it and see?
10:02:01 <kmc> yes
10:02:02 <mino> dcoutts_: nothing just googling, i were like 2 years away from haskell and even programming, so it is going slow
10:02:05 <kmc> > let a = 2; b = 3 in a+b
10:02:05 <lambdabot>   5
10:02:11 <kmc> they can be mutually recursive too
10:02:29 <edlinde> kmc: do I need the ";" in between?
10:02:29 <edlinde> \
10:02:34 <kmc> edlinde, or a newline
10:02:36 <kmc> basically
10:02:37 <edlinde> ok
10:02:45 <kmc> 'b' should line up with 'a'
10:03:07 <kmc> > let evens = 0 : map succ odds; odds = map succ evens in evens
10:03:08 * applicative continues to be baffled by Philippa's doctrine of inference rules and Gentzen's representation of them
10:03:08 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
10:04:27 <djahandarie> Whenever I do one-line lets or dos I tend to also use the {}
10:04:48 <kmc> i usually don't
10:05:03 <kmc> *shrug*
10:05:32 <djahandarie> (Assuming more than one thing being let obviously)
10:06:10 <jro> how do I convert a list containing to elements to a pair?
10:06:33 <jro> to=two
10:06:37 <applicative> jro, what if it doesn't have two elements
10:06:51 <jro> stupid user
10:07:14 <applicative> > \[x,y] -> (x,y) $ "ha"
10:07:15 <lambdabot>   Couldn't match expected type `a -> b'
10:07:15 <lambdabot>         against inferred type `(t, t)'
10:07:29 <applicative> > (\[x,y] -> (x,y) ) $ "ha"
10:07:29 <lambdabot>   ('h','a')
10:07:37 <benmachine> jro: stupid library user, or stupid application user?
10:07:45 <sproingie> > (\[x,y] -> (x,y) ) $ "har"
10:07:46 <lambdabot>   *Exception: <interactive>:1:134-148: Non-exhaustive patterns in lambda
10:07:57 <applicative> sproingie beat me to it.
10:09:14 <jro> benmachine, basically that would be me
10:09:21 <benmachine> jro: ah right :)
10:09:25 <applicative> > let enpair (x:y:zs) = Just (x,y); enpair _ = Nothing in enpair "ha"
10:09:26 <lambdabot>   Just ('h','a')
10:09:31 <applicative> > let enpair (x:y:zs) = Just (x,y); enpair _ = Nothing in enpair "haha"
10:09:31 <lambdabot>   Just ('h','a')
10:09:43 <applicative> > let enpair (x:y:zs) = Just (x,y); enpair _ = Nothing in enpair "h"
10:09:43 <lambdabot>   Nothing
10:10:12 <benmachine> jro: basically it depends on what kind of error message you want when the list is the wrong size; if that's a programmer error, then (\[x,y] -> (x,y)) is fine
10:10:15 <applicative> jro, are you sure the function you are feeding these pairs to needs to take pairs rather than lists?
10:10:25 <benmachine> if it's a user error then applicative's solution is more sensible
10:11:10 <edlinde> was just converting one of the functions Jafet gave
10:11:12 <merijn> Wouldn't you want enpair (x:y:[]) Just (x, y) in that case?
10:11:13 <edlinde> http://ideone.com/m7IQx
10:11:32 <edlinde> i didn't know Haskell was fussy about indentation too
10:11:41 <jro> applicative: I've f x y = sthing and I say (uncurry f) pair
10:11:53 <benmachine> edlinde: the fussiness is optional, but recommended
10:11:59 <jro> and pair is constructed from the list
10:12:04 <merijn> edlinde: You can turn it of by using { } and ;
10:12:06 <edlinde> so do you see what I stuffed up ?
10:12:09 <benmachine> edlinde: you can bypass it with explicit {;} but then everyone looking at your code goes "ewww"
10:12:11 <jro> cmdline args in this case
10:12:19 <merijn> edlinde: But I'd recommend using indentation
10:12:22 <sshc> I'm trying to configure a package, and it's listing a dozen or so packages that it those dependencies says aren't satisfied
10:12:24 <edlinde> ok
10:12:29 <sshc> But I've installed them with cabal install
10:12:45 <benmachine> edlinde: I think the case should be indented more than the let
10:12:50 <benmachine> but I'm not sure
10:12:50 <sshc> Why isn't ./Setup.hs configure recognizing those packages?
10:12:58 <dcoutts_> sshc: use the 'cabal' program
10:12:59 <sshc> I'm not familiar with GHC's package system
10:13:04 <merijn> And shouldn't in have the same indent as let?
10:13:13 <benmachine> merijn: nah
10:13:14 <edlinde> http://ideone.com/CwpEw
10:13:18 <benmachine> not necessarily anyway
10:13:18 <edlinde> still doesn't work
10:13:36 <sshc> dcoutts_: I've already run "cabal install ConfigFile"
10:13:44 <benmachine> edlinde: a bit more :P
10:13:47 <edlinde> I thought the indentation looks fine.. unless haskell has some other things
10:13:47 <applicative> jro, will the string that has too many or too few parts be the one given by the user?
10:13:52 <benmachine> edlinde: indent it more than merge
10:13:57 <jro> yes
10:14:04 <edlinde> benmachine: the case?
10:14:06 <benmachine> edlinde: yes
10:14:07 <dcoutts_> sshc: if you really want to use the Setup.hs interface for some reason (e.g. if you're implementing a package system) then there's the --global or --user flag to control which package dbs it looks in.
10:14:11 <benmachine> indent it more than merge and m
10:14:12 <applicative> right, then you could pack in an error message with the usual expedient
10:14:24 <benmachine> which should be at the same level
10:14:29 <edlinde> worked
10:14:32 <benmachine> cool
10:14:32 <edlinde> thanks
10:14:37 <edlinde> man that shit is fussy
10:14:38 <dcoutts_> sshc: there's usually no need to use runghc Setup configure when you can just use cabal configure
10:14:39 <benmachine> heh
10:14:42 <benmachine> you get used to it
10:14:43 <merijn> edlinde: It was treating case as another let then :p
10:14:53 <merijn> Get a better editor ;)
10:14:57 <sshc> dcoutts_: I'm trying to figure out why ./Setup.hs thinks I don't have ConfigFile installed, but I've installed it with cabal
10:15:02 <edlinde> ok
10:15:30 <sshc> dcoutts_: "cabal configure" works, but I need Setup.hs for gettext to work properly
10:15:42 <applicative> > let enpair [x,y] = Right (x,y); enpair _ = Left "This program requires exactly two arguments!!" in enpair ["foo.txt","bar.txt"]
10:15:43 <lambdabot>   Right ("foo.txt","bar.txt")
10:15:52 <applicative> > let enpair [x,y] = Right (x,y); enpair _ = Left "This program requires exactly two arguments!!" in enpair ["foo.txt","bar.txt", "moo.hs"]
10:15:52 <dcoutts_> sshc: because the default for Setup configure is global installs, that's why I recommend using the 'cabal' program because its easier and its defaults are better
10:15:53 <lambdabot>   Left "This program requires exactly two arguments!!"
10:16:14 <edlinde> merijn: benmachine : witht he code I pasted, does m = an infinite list ?
10:16:18 <sshc> dcoutts_: Ahh, I remember now
10:16:20 <applicative> jro, like that ^^^
10:16:26 <dcoutts_> sshc: oh, why doesn't it work with cabal configure?
10:16:34 <edlinde> coz its calling merge recursively over and over again
10:16:39 <sshc> dcoutts_: It does?
10:16:53 <sshc> dcoutts_: Oh, but not the program
10:17:00 <dcoutts_> sshc: you said "I need Setup.hs for gettext to work properly", I'm wondering why
10:17:03 <sshc> dcoutts_: Setup.hs isn't the default Setup.hs?
10:17:39 <dcoutts_> sshc: that's ok, if you're using a custom Setup.hs then you specify build-type: Custom in the .cabal file and the cabal program will do the right thing
10:17:41 <benmachine> edlinde: I think so
10:17:45 <edlinde> k
10:17:56 <sshc> dcoutts_: I'll that up, thanks
10:18:07 <sshc> dcoutts_: I remember; I'd solved this in the past by passing --user
10:18:32 <applicative> jro, then your write main = do { args <- getArgs ; case (enpair args) of  Left s -> putStrLn s ; Right (a,b) -> (whatever you do with a and b)
10:18:58 <dcoutts_> sshc: right, that'll do it. I was just worried you'd found some case where using Setup.hs works, but using cabal didn't (any such case would be a bug in cabal)
10:21:48 <sshc> If I set build-type to custom, cabal works as well
10:24:57 <jro> thanks :-)
10:25:02 * hackagebot parallel-io 0.2 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.2 (MaxBolingbroke)
10:25:22 <jro> I just "finished" my first Haskell program
10:26:12 <jro> http://code.google.com/p/ultralaskuri/
10:26:32 <jro> that was kind of fun, actually
10:27:41 <sproingie> .oO( did i just get /quitrolled? )
10:28:31 <Adamant> never gonna quit you up, never gonna let you down
10:29:03 * hackagebot blaze-html 0.3.0.1 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.3.0.1 (JasperVanDerJeugt)
10:30:45 <roconnor> let enpair [x,y] = return (x,y); enpair _ = fail "hh:mm:ss.ii distance [m]"
10:31:01 <roconnor> args <- enpair =<< getArgs
10:31:10 <roconnor> er
10:31:18 <roconnor> (a,b) <- enpair =<< getArgs
10:31:49 <roconnor> print . preductions $ getpredictor (fromJust $ toTime a) (readDouble b)
10:31:54 <roconnor> *predictions
10:32:28 <applicative> roconnor, is that what fail does in this context?  I never use it, I confess
10:32:44 <roconnor> fail with throw an IO expection here I think
10:33:06 <roconnor> and an uncaught expection will print out on stderr maybe?  I'm not sure
10:33:38 <applicative> so it would bark the same to the user as the Either way  (I was just recommending it to jro)
10:33:40 <roconnor> jro: ^^
10:33:59 <roconnor> it will bark slightly differently, but still bark.
10:35:10 <mee> I think that can be simplified even further by getting rid of the case, yeah?
10:35:35 <mee> oh, that's what roconnor's "print . ..." is
10:36:24 <applicative> jro, this seems quite sound to my feeble eyes; don't let them golf it too far!
10:36:58 <jro>     Couldn't match expected type `Either [Char] [t]'
10:36:59 <jro>            against inferred type `IO [String]'
10:36:59 <jro>     In the second argument of `(=<<)', namely `getArgs'
10:36:59 <jro>     In a stmt of a 'do' expression:
10:36:59 <jro>         (time, distance) <- enpair =<< getArgs
10:37:28 <roconnor> let enpair [x,y] = return (x,y); enpair _ = fail "hh:mm:ss.ii distance [m]"
10:38:34 <roconnor> @botsnack
10:38:34 <lambdabot> :)
10:38:44 <applicative> jro, I was going to say users might be able to use runhugs on it, but I'm not sure about the imports, eg Printf
10:38:45 <monochrom> :)
10:39:32 <kmc> jro, enpair is not returning an IO action
10:39:39 <kmc> fmap enpair getArgs
10:39:52 <kmc> fmap :: (a -> b) -> IO a -> IO b
10:40:21 <jro> I applied roconnors fix to let stmt
10:40:25 <roconnor> kmc: my version of enpair returns an IO action
10:40:29 <jro> thx
10:40:44 * applicative stands by his sensible suggestion of Either error (String,String)
10:41:27 <revenantphx> One question I have.
10:41:27 <roconnor> jro: your solution isn't wrong.  What is better is a matter of taste.
10:41:41 <revenantphx> This was shown to be the case in haskell earlier.
10:41:41 <revenantphx> http://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Purely_functional_tree_after.svg/438px-Purely_functional_tree_after.svg.png
10:41:55 <revenantphx> So, if new trees are being created repeatedly, will old ones be collected?
10:42:03 <roconnor> applicative: the problem with Either Error is that you lose the free work done by monadic binding that would be available with EitherT Error
10:42:38 <applicative> sorry, I shouldn't hace said error, it was just Either String (String,String)
10:42:38 <revenantphx> Like in this map, if xs goes out of scope, but ys doesnt (somehow) then would d, a, c, g, and f all be disposed off?
10:42:44 <kmc> oh
10:42:45 <revenantphx> Since they have no active "use"?
10:42:51 <roconnor> applicative: I understood that
10:43:25 <roconnor> revenantphx: yes, that is what garbage collection does
10:43:35 <revenantphx> I'm just wondering if thats how it is in haskell :P
10:43:36 <roconnor> revenantphx: a and c wouldn't bet disposed
10:43:47 <roconnor> revenantphx: only d g and f
10:43:47 <revenantphx> oh riht, linked to fro b
10:43:50 <revenantphx> right right.
10:44:12 <roconnor> revenantphx: how did you generate that image?
10:44:18 <revenantphx> I didnt
10:44:19 <revenantphx> .
10:44:23 <revenantphx> It's on wikipedia :|
10:44:26 <roconnor> ah
10:44:28 <applicative> roconnor, okay
10:44:37 <jro> there are still problems related to that fromJust can fail and readDouble can fail
10:44:43 <ion> roconnor: Looks like graphviz.
10:44:48 <roconnor> it does
10:45:07 <roconnor> jro: where is fromJust?
10:45:11 <roconnor> oh
10:45:14 <roconnor> in to Time
10:45:27 <revenantphx> Hey, one question.
10:45:32 <revenantphx> (I need to stop saying that)
10:45:40 <monochrom> two questions
10:45:46 <monochrom> three little questions
10:45:49 <tswett> Is Cont in MonadFix?
10:45:52 <revenantphx> given that christmas is coming up and I'll have an influx of money for books... do you guys have anything you'd recommend for me?
10:45:53 <roconnor> jro: I'd be inclinded to put that work into "enpair"
10:45:58 <monochrom> five questions, eight questions, thirteen little questions
10:46:07 <tswett> The notation that uses the MonadFix instance is mdo, right?
10:46:15 <monochrom> Cont is not in MonadFix
10:46:15 <roconnor> jro: make enpair more sophistacted, and have it run toTime and readDouble.
10:46:24 <jro> yes
10:46:28 <roconnor> jro: and run fail "error message" on those cases that fail
10:46:37 <roconnor> @type readDouble
10:46:38 <lambdabot> Not in scope: `readDouble'
10:46:40 <tswett> Is there a MonadFix implementation that gives the desired behavior, or is that impossible?
10:46:41 <applicative> jro, right, some of this will require fancier error handling a la roconnor; my suggestion was bypassing just one obvious source of error.
10:46:44 <djahandarie> monochrom, stop raising the channel temperature ;)
10:46:55 <tswett> Of course, I'm not sure what the desired behavior is.  :P
10:47:07 <revenantphx> fibonacci questions!
10:47:25 <roconnor> jro: you can make a version of readDouble that returns Maybe Double as follows:
10:48:01 <roconnor> readDouble :: String -> Maybe Double
10:48:32 <monochrom> @quote monochrom rabbits
10:48:32 <lambdabot> No quotes match. Are you on drugs?
10:48:40 <roconnor> readDouble s = go (reads s) where go [d,""] = Just d; go _ = Nothing
10:48:50 <roconnor> I think that is right.
10:49:02 <roconnor> stupid thing is that internally GHC has a nice function that already does this :/
10:49:07 <roconnor> @src read
10:49:07 <lambdabot> read s = either error id (readEither s)
10:49:23 <roconnor> it's called readEither, but it isn't exported.
10:49:36 --- mode: monochrom set -o monochrom
10:49:38 <revenantphx> > let fibs = 1:1:[(a+b)|(a,b) <- zip fibs (tail fibs)]; fibqs = map ( (++ " questions") . show ) fibs; in take 10 fibqs
10:49:39 <lambdabot>   ["1 questions","1 questions","2 questions","3 questions","5 questions","8 q...
10:49:40 * roconnor wants access to readEither
10:49:46 <revenantphx> monochrom: :D
10:50:15 <tswett> Hm, I seem to remember @src giving the source code to some esoteric, primitive-looking functions, like + over the integers.
10:50:29 <monochrom> have you seen my http://www.vex.net/~trebla/haskell/scanl.xhtml ?
10:50:31 <jro> now I'm maybe conserned about Races.hs
10:50:38 <tswett> @src putStr
10:50:38 <lambdabot> putStr s  = hPutStr stdout s
10:50:44 <tswett> @src hPutStr
10:50:45 <lambdabot> Source not found. It can only be attributed to human error.
10:50:48 <tswett> Aw.
10:51:01 <revenantphx> @src Sytem.IO.Handle.hPutStr
10:51:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:51:11 <revenantphx> @src System.IO.Handle.hPutStr
10:51:11 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:51:14 <revenantphx> >_>
10:51:20 <jro> I'm not sure, if this structure is correctly done
10:51:35 <revenantphx> @src System.IO.hPutStr
10:51:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:51:47 <revenantphx> gr
10:51:47 <revenantphx> http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/src/GHC-IO.html#hPutStr
10:52:34 <roconnor> jro: doesn't look so bad to me
10:53:15 <roconnor> jro: I would be included to have fromTime simply return (error "foo") in case the time is negative, but what you have isn't bad.
10:53:19 <roconnor> *inclined
10:54:54 <jro> ok, I stick with that
10:55:08 <jro> I have to include heart rate predictions also to the result
10:55:26 <benmachine> readMaybe s = do [(a,_)] <- reads s; Just a
10:55:49 <roconnor> benmachine: replace _ with ""
10:56:10 <jro> and I partially apply (getprediction predictor heartrate), and this might make the getprediction complicated
10:56:10 <roconnor> that always tricks me up, which is why I hate rewriting this code
10:56:24 <benmachine> readMaybe s = do [(a,all isSpace -> True)] <- reads s; Just a -- >_>
10:56:25 <roconnor> partial application is good
10:56:36 <roconnor> > read "17 " :: Integer
10:56:37 <lambdabot>   17
10:56:42 * roconnor sighs
10:56:57 * roconnor wants readEither exported
10:57:10 * benmachine too
10:57:34 <roconnor> the code is non-trivial and very useful
10:58:17 <benmachine> I wonder how often reads actually returns an ambiguous parse
10:58:26 <benmachine> I imagine never for derived instances
10:58:30 <mzero> actually, there is no gurantee that the first result from reads will be the one that uses all of the (non-whitespace) input
10:58:40 <benmachine> mzero: >_< good point
10:59:06 <mzero> so I always write a version that grabs the first element of the result, if any, that meets that
11:00:37 <mzero> readMaybe = fmap fst . maybeFromList . filter ((all isSpace).snd) . reads
11:00:40 <byorgey> @oeis 2 3 5 7
11:00:40 <lambdabot>  Sequence not found.
11:00:52 <c_wraith> uh
11:00:56 <byorgey> darn.  looks like OEIS changed their format or something.
11:01:01 <c_wraith> commas?
11:01:03 <byorgey> I'll try to have it fixed soon.
11:01:09 <byorgey> @oeis 2,3,5,7
11:01:09 <lambdabot>  Sequence not found.
11:01:14 <c_wraith> oh, is it the plugin that's broken?
11:01:22 <byorgey> I've been testing it on my machine too
11:01:30 <byorgey> every query returns Nothing
11:03:23 <mzero> I met Neil Sloane (of OEIS) last month - and he gave a great talk on OEIS at the conf. we were at too
11:03:56 <byorgey> nice!
11:05:16 <roconnor> @src readEither
11:05:17 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:05:18 <tswett> > read "17 is a very nice integer"
11:05:19 <lambdabot>   *Exception: Prelude.read: no parse
11:05:29 <tswett> > reads "17 is a very nice integer"
11:05:30 <lambdabot>   []
11:05:48 * tswett blinks.
11:05:57 <roconnor> readEither s =
11:05:58 <roconnor>   case [ x | (x,"") <- readPrec_to_S read' minPrec s ] of
11:06:00 <roconnor>     [x] -> Right x
11:06:01 <roconnor>     []  -> Left "Prelude.read: no parse"
11:06:03 <roconnor>     _   -> Left "Prelude.read: ambiguous parse"
11:06:04 <roconnor>  where
11:06:06 <roconnor>   read' =
11:06:08 <roconnor>     do x <- readPrec
11:06:09 <roconnor>        lift P.skipSpaces
11:06:10 <roconnor>        return x
11:06:49 <monochrom> > reads "17 is a very nice integer" :: [(Double, String)]
11:06:50 <lambdabot>   [(17.0," is a very nice integer")]
11:07:14 <monochrom> > reads "() is a very nice unit"
11:07:15 <lambdabot>   [(()," is a very nice unit")]
11:07:22 <monochrom> \∩/
11:09:24 <benmachine> roconnor: huh, that seems an odd way to do it
11:09:53 <sshc> How should converting between between Char and Word8 be done?
11:10:05 <Botje> carefully
11:10:18 <byorgey> Char values can be more than one byte, you know
11:10:20 <roconnor> sshc: techncially it cannot be done
11:10:21 <monochrom> fromIntegral . fromEnum
11:10:38 <roconnor> but toEnum . fromEnum will do something
11:10:39 <monochrom> it will be lossy
11:11:21 <sshc> byorgey: Yes I know
11:12:29 <mzero> sshc: there are several ways to encode strings, if that is what you are after
11:13:57 <sshc> I'll toEnum . fromEnum to convert to Char and visa verso
11:14:08 <tswett> @type reads "17 is a very nice integer"
11:14:09 <lambdabot> forall a. (Read a) => [(a, String)]
11:14:19 * monochrom cues Gerald Weinberg's "I can make it a hundred times faster if it doesn't have to be correct" :)
11:14:25 <tswett> Ah.  What's the default instance of Read?
11:14:35 <mzero> what's a "default instance"?
11:14:53 <tswett> The thing that lambdabot gives you when you say reads "17 is a very nice integer".
11:14:56 <monochrom> there is no default instance. but some ghci trickery chooses a=()
11:15:10 <mzero> > reads "17 is a very nice integer"
11:15:11 <lambdabot>   []
11:15:17 <mzero> :t > reads "17 is a very nice integer"
11:15:18 <lambdabot> parse error on input `>'
11:15:24 <mzero> :t reads "17 is a very nice integer"
11:15:25 <lambdabot> forall a. (Read a) => [(a, String)]
11:15:33 <mzero> well - I'd say that there isn't one
11:15:43 <mzero> or perhaps it is () ?
11:15:51 <tswett> It seems to be ().
11:15:59 <monochrom> <monochrom> > reads "() is a very nice unit"
11:16:21 <mzero> lambdabot has some odd things about it....
11:16:47 <benmachine> defaulting rules are varied
11:16:48 <monochrom> yeah, don't trust lambdabot.
11:16:58 <benmachine> ghci has extra ones
11:17:12 <monochrom> don't trust any repl
11:17:21 <benmachine> don't trust anyone
11:17:36 <monochrom> don't trust those who don't trust themselves
11:18:17 * benmachine doesn't trust himself, and therefore, doesn't trust himself
11:19:42 <monochrom> seriously, there are some ghci trickeries for "user friendly" but they don't happen in compiled code. this implements the principle of maximum surprise.
11:20:34 <monochrom> think of it as a bait-and-switch con
11:21:25 * hackagebot ztail 1.0.1 - Multi-file, colored, filtered log tailer.  http://hackage.haskell.org/package/ztail-1.0.1 (DylanSimon)
11:22:01 <mjrosenb> in ghci, can I import a module, and access non-exported variables?
11:22:09 <jro> is import Text.Printf considered bad?
11:22:26 <monochrom> not unless you wrote the module yourself and load the source code
11:22:27 <benmachine> jro: it's not terrible-awful
11:22:47 <benmachine> monochrom: you don't have to have written it yourself for that surely :P
11:22:53 <monochrom> heh
11:23:07 <mjrosenb> monochrom: i wrote it myself, but ghci foo.hs and import foo both hide the variables that aren't exported :(
11:23:12 <benmachine> jro: I think generally speaking I would do something else, like concat on a list of strings
11:23:26 <benmachine> jro: but if printf works for you then I wouldn't worry about it too much
11:23:31 <monochrom> :load *foo.hs
11:23:56 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope
11:24:17 <mjrosenb> Prelude ParseConfig> :t ParseConfig.myWords
11:24:19 <jro> what was the reason for this runhugs and Printf comment?
11:24:19 <mjrosenb> <interactive>:1:0: Not in scope: `ParseConfig.myWords'
11:25:13 <monochrom> compulsory reading for ghci users
11:26:16 <benmachine> mjrosenb: note no * on ParseConfig
11:26:25 <sshc> What is the C Type for Word8?
11:26:34 <benmachine> sshc: uint8_t
11:26:43 <mjrosenb> benmachine: oh, totally missed that.  thanks.
11:26:49 <sshc> benmachine: FFI's C type
11:26:56 <benmachine> sshc: huh?
11:27:16 <sshc> @hoogle CDouble
11:27:16 <lambdabot> Foreign.C.Types data CDouble
11:27:22 * sshc checks that module
11:27:31 * benmachine already did
11:28:22 <sshc> CUChar?
11:28:30 <benmachine> ...Word8?
11:28:37 <benmachine> what do you mean by C type
11:28:42 <sm> what's wrong with Text.Printf ? I find it essential
11:29:03 <benmachine> sm: there's no static check that the expected/actual argument numbers match up
11:29:07 <monochrom> CUChar is not guaranteed to be 8-bit.
11:29:22 <sm> ah right. Runtime failures
11:29:40 * mzero >>= lunch
11:29:42 <monochrom> but if you only compile your program on one computer, sure.
11:29:50 <benmachine> mzero >>= lunch = mzero
11:29:59 <benmachine> pretty sure that's a law
11:30:05 <sshc> benmachine: I want a point to 8-bit bytes
11:30:21 <benmachine> sshc: what's wrong with Ptr Word8?
11:30:34 <sshc> benmachine: I thought Ptr only worked with the types defined in that module?
11:30:37 <benmachine> nope
11:30:45 <sshc> Oh
11:30:45 <benmachine> it's not magic
11:30:46 <sshc> then
11:30:49 <sshc> cool beans.
11:30:59 <benmachine> Ptr (Maybe (a -> a)) is permissible
11:31:03 <benmachine> just not very often useful :P
11:33:02 <lispy> benmachine: instance MonadPlus Eating where mzero = fail "I forgot my lunch!"
11:33:50 <monochrom> my dog ate my lunch
11:34:31 * hackagebot simple-css 0.0.3 - simple binding of css and html  http://hackage.haskell.org/package/simple-css-0.0.3 (AntonKholomiov)
11:35:53 <aristid> lispy: does that satisfy all MonadPlus laws?
11:36:24 <zachk> watch this:
11:36:25 <zachk> > let fiben n = (++) (replicate n 1) . map sum . transpose . take n . iterate tail $ fiben n in take 20  $ fiben 2 
11:36:26 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
11:36:43 <zachk> freeing lazy fibs from the restriction of 2 
11:37:26 <monochrom> what is "restriction of 2"?
11:37:32 <zachk> well the normal one is
11:38:03 <zachk> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 20 $ fibs 
11:38:04 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
11:38:38 <zachk> but now you can extend the sequence out to aribitray number of fib (tail fibs) (tail $ tail fibs) etc 
11:43:17 <leino> can someone tell me what an "occurs check" is?
11:43:37 <leino> Im gettin an error in ghc
11:43:48 <benmachine> leino: cannot construct the infinite type...
11:43:49 <benmachine> ?
11:43:55 <leino> yeah
11:43:58 <benmachine> basically
11:44:06 <byorgey> leino: an occurs check is when a type variable occurs in the type expression it is supposed to be equal to.
11:44:08 <aristid> zachk: is it just me, or does zipWith (+) fibs (tail fibs) cry for (<*>)? :)
11:44:09 <byorgey> e.g.  a = [a]
11:44:14 <benmachine> yeah, that
11:44:16 <monochrom> if you write something like "f x = f (Just x)"
11:44:21 <byorgey> a 'occurs' in the type [a], hence the name "occurs check"
11:44:33 <mee> When using RankNTypes, you can create a data type like `data Foo = Foo { things :: (myClass k) => [k] }`. But in functions that take instances of myClass and pile them into Foo's, you get type errors because you might try to put two different instances of myClass into a single Foo. The only way I can think to get around this are to (a) make the functions that build Foo's not be polymorphic over myClass, but stick to a single instance ( :: [k] -> Foo )
11:44:59 <byorgey> leino: if you're having trouble figuring out why you are getting that error, you could paste your code and the error message somewhere
11:45:07 <byorgey> e.g. hpaste.org
11:45:25 <leino> byorgey: yeah I think Ill do that, one sec
11:45:29 <monochrom> that is no fun.
11:45:46 <monochrom> people love mysteries and lack of real information
11:46:39 <sm> interesting.. I don't think ghci can parse a >255 digit number entered via emacs shell buffer
11:46:49 <leino> byorgey: http://hpaste.org/42048/parser
11:46:59 <byorgey> sm: that's probably just a limitation of the shell
11:47:22 <jmcarthur> conal: pong?
11:47:27 <byorgey> leino: can you paste the error message too please?
11:47:27 <leino> oh, forgot to define Parser but maybe it doesnt matter
11:47:54 <byorgey> leino: it might help, go ahead and paste the definition of Parser too
11:48:04 <leino> http://hpaste.org/42049/parser
11:48:18 <leino> allright
11:48:45 <byorgey> you can just put something in the "annotate paste" box
11:48:52 <benmachine> leino: foldr takes three arguments
11:49:05 <byorgey> benmachine wins =)
11:49:13 <leino> darn
11:49:17 <leino> foldr1?
11:49:41 * benmachine tries to work out what chain is supposed to do
11:49:42 <byorgey> sure, foldr1 is perfect here
11:49:48 <byorgey> since you know the list is non-empty
11:49:49 <leino> ok but how come the occurs check error then?
11:49:49 <monochrom> will reveal another type error: a is not Char
11:50:17 <benmachine> monochrom: why's that a problem?
11:50:25 <benmachine> ...what's >->
11:50:31 <byorgey> leino: because  foldr f (x:xs) has some type that involves a, but its type is supposed to be a
11:50:41 <leino> oh boy... I forgot a lot of definitions
11:50:50 <leino> >-> is >>
11:50:55 <monochrom> expect "foldr f char_here string_here", you gave "foldr f string_here". char = string?
11:51:14 <jmcarthur> dangit conal
11:51:25 <byorgey> monochrom: (x:xs) is not a String, it's an [a]
11:51:38 <monochrom> sorry
11:51:44 <mjrosenb> zachk: i have something slightly more challenging than an n-ary fibonacci sequence :)
11:52:03 <leino> well.. foldr1 seems to work
11:52:06 <monochrom> expect "foldr f a_here [a]_here", you gave "foldr f [a]_here". a = [a] ?
11:52:07 <leino> at least it compiles
11:52:34 <byorgey> @type foldr
11:52:35 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:52:48 <monochrom> they say correctly that you shouldn't trust me when I type-check.
11:52:51 <byorgey> foldr expects a starting value (the second argument)
11:52:55 <leino> but I would like to understand why I got the occurs check error
11:52:56 <byorgey> @type foldr1
11:52:57 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
11:53:24 <byorgey> leino: foldr :: (a -> b -> b) -> b -> [a] -> b
11:53:31 <byorgey> foldr f :: a -> [a] -> a
11:53:36 <byorgey> since f :: a -> a -> a
11:53:41 <byorgey> ok so far?
11:53:56 <leino> yeah
11:54:08 <zachk> mjrosenb: whats that? 
11:54:31 <byorgey> ok, so now   foldr f  is applied to  (x:xs)
11:54:39 <byorgey> foldr f  is expecting an  a,  but (x:xs) :: [a]
11:54:44 <mjrosenb> zachk: http://mathworld.wolfram.com/WythoffArray.html
11:54:46 <byorgey> so for this to work we must have  a = [a]
11:54:51 <leino> so I was returning something of the wrong type?
11:54:53 <byorgey> which is not allowed, hence the error
11:55:03 <byorgey> leino: you were calling foldr with arguments of the wrong type.
11:55:15 <byorgey> since the second argument to foldr should be the starting value, not the list to be folded
11:55:22 <byorgey> the list to be folded is the third argument
11:55:45 <leino> byorgey: yeah I understand that, but Im sure Ive made type errors before and never gotten back the occurs check
11:56:01 <zachk> mjrosenb: what can i use a wythoff array for? 
11:56:10 <byorgey> leino: well, it only happens when you make the particular sort of type error that means a type variable must be equal to some other type involving itself.
11:56:13 <byorgey> like a = [a].
11:56:14 <sproingie> .oO( storing wythoffs )
11:56:25 <adnap_> whoa conal
11:56:25 <mjrosenb> zachk: what can you use the n-ary fibonacci sequence for?
11:56:45 <dixie> @quote
11:56:45 <lambdabot> JustinBogner says: gitit's 46 dependencies convinced me to install cabal-install, and now I couldn't be happier!
11:56:49 <leino> byorgey: ok, Ill meditate on this, thanks
11:56:49 <byorgey> leino: you could also write something requiring  Int = Char,  which is also a type error, but not an occurs check error
11:56:54 <FauxFaux> @vixen
11:56:55 <lambdabot> what do you want to know about me?
11:57:00 <byorgey> because it doesn't involve type variables at all
11:57:45 <leino> everyone: thanks
11:57:55 <zachk> mjrosenb: I was using them to calculate "golden" ratios for things other then fib-2 
11:58:06 <mjrosenb> zachk: also, i believe that it is a covering for \mathbb{N} without any duplicates
11:58:12 <zachk> it seems to approach the number 2 as n increases 
11:58:28 <zachk> whats mathbb and whats a covering 
11:58:57 <mjrosenb> zachk: well if you take it to infinity, then you end up with the definition for (2^n) -1
11:59:41 <zachk> that would include the mersenne primes wouldnt it 
11:59:52 <mjrosenb> zachk: mathbb is an indication of blackboard bold; mathbb{n} means "the natural numbers"; it means that every natural number is in the array just *once*
12:00:11 <zachk> ahhh
12:00:12 <byorgey> zachk: that makes sense.  In the limit, if you form a sequence where each number is the sum of all the previous ones, you get  2^n - 1
12:00:22 <byorgey> oh, mjrosenb beat me to it =)
12:00:27 <mjrosenb> err, rather, if you start the sequence with 1,1; then you get 2^n
12:00:50 <mjrosenb> if you start with 1, 2, you get something else, which i do not remember the closed form for.
12:01:04 <zachk> im wondering if there are geometric constructions for this golden-n ratios 
12:01:15 <zachk> these* 
12:02:20 <byorgey> mjrosenb: you get 3 * 2^n, shifted appropriately
12:02:45 <mjrosenb> byorgey: believable.
12:03:49 <Twey> > [1, 1, ..]
12:03:49 <lambdabot>   <no location info>: parse error on input `..'
12:03:55 <Twey> > [1, 1 ..]
12:03:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:04:39 * Twey prefers \mathds, but isn't sure if that's technically correct.
12:04:57 <aristid> > map length ["repeat 1", "[1, 1 ..]"]
12:04:58 <lambdabot>   [8,9]
12:05:05 <aristid> > map length ["repeat 1", "[1,1..]"]
12:05:05 <lambdabot>   [8,7]
12:05:20 <aristid> > [1,1..]
12:05:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:05:32 <c_wraith> > fix (1:)
12:05:33 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:05:37 <aristid> i think repeat 1 wins anyways
12:05:43 <Twey> Yeah, but it's ugly without the whitespace
12:05:47 <aristid> because it's easier to read
12:05:54 <mjrosenb> > length "let o=1:o in"
12:05:55 <lambdabot>   12
12:05:59 <Twey> > length "fix (1 :)"
12:06:00 <lambdabot>   9
12:06:13 <Twey> Probably wins, yeah
12:08:27 <mjrosenb> byorgey: ahh, and if your sequence starts with x,y, then it will become (x+y)*2^n after the initial 2 elements.
12:08:36 <byorgey> mjrosenb: indeed.
12:09:41 <monochrom> \mathbb{N} is a niche notation for ℕ
12:10:14 <Twey> I don't understand what the difference is between \mathbb and \mathds
12:10:20 <Twey> Except that \mathds looks better, anyway
12:10:44 <monochrom> \mathbb is older.
12:11:11 <monochrom> the same reason why some people use c and not haskell
12:11:33 <benmachine> what does ds mean
12:11:41 <ion> doublestroke?
12:11:41 <fryguybob> double stroke
12:11:45 <benmachine> oic
12:11:52 <fryguybob> bb = blackboard bold
12:13:24 <mjrosenb> when was ds added?
12:13:37 * mjrosenb has been using bb since sophmore year of college :(
12:13:55 <monochrom> the power of tradition
12:20:12 <sm> I really don't like all these ExitFailure 11 's while cabal configuring :/
12:24:48 <sshc> Is it safe to use the pointer that the function in withStorableArray passes after the action is done executing if I call touchStorableArray at the end of that action?
12:25:16 <sshc> The documentation doesn't seem to be very specific
12:25:26 <sshc> http://hackage.haskell.org/packages/archive/array/0.3.0.2/doc/html/Data-Array-Storable.html
12:26:29 <benmachine> sshc: at the end of which action?
12:27:58 <sshc> withStorable array $ \ptr -> do{ containerThatContainsPtr <- doStuffWithPtr ptr; touchStorableArray array; return containerThatContainsPtr }
12:28:38 <benmachine> sshc: that seems like the finaliser could run when withStorable returned
12:29:32 <jmcarthur> conal: pong again?
12:29:47 <sshc> benmachine: Could it?
12:29:49 <conal> jmcarthur: hi. i'd lost my internet connection. 
12:30:01 <conal> jmcarthur: i saw your opengl lib. wondering what you're up to.
12:30:03 <jmcarthur> yeah i noticed ;)
12:30:08 <benmachine> sshc: I'm not an expert, but that's what I interpret the docs as saying
12:30:08 <sshc> benmachine: How would I use the pointer afterward (and free it properly) then?
12:30:19 <benmachine> sshc: the docs say, don't use it afterward :P
12:30:26 * sm moves closer to using a private per-project ghc/cabal db
12:30:32 <benmachine> sshc: but I imagine if you touch it after every use that might be fine?
12:30:33 <sshc> benmachine: But right below it says "If you want to use it afterwards, ensure that you touchStorableArray after the last use of the pointer, so the array is not freed too early. "
12:30:34 <conal> jmcarthur: and whether your opengl work might be an opportunity to make some improvements, such as gc'able graphics resources.
12:30:35 <benmachine> I don't know
12:30:35 <djahandarie> jmcarthur, ah you started on that?
12:30:55 <jmcarthur> conal: just making a game, and as part of that i'm working on a more haskelly but still low level opengl wrapper, and to help me be more clear on what platforms i'm supporting i made openglraw21
12:31:20 <sshc> Agh, that documentation really stinks
12:31:20 <jmcarthur> conal: my wrapper is currently just using finalizers. i'm not sure what fancier things i could attempt
12:31:32 <sshc> What should I do if I *want* to use the pointer later on?
12:31:44 <conal> jmcarthur: glad to hear.  finalizers is what i had in mind. i don't think hopengl could handle finalizers.
12:31:46 <mikeg> Is it a bug if Data.Time.Format.parseTime, which should give me a Maybe ParseTime, gives me an invalid Just when I try to read it?
12:31:57 <jmcarthur> why not?
12:32:01 <conal> jmcarthur: because of Ptr vs ForeignPtr or some such.
12:32:15 <mikeg> parseTime "%e %B %Y" "April 2000" is my scenario
12:32:26 <merijn> mikeg: What do you mean by "invalid Just"?
12:32:33 <jmcarthur> ah. i'm not really doing anything that uses Ptr in the interface directly
12:32:48 <mikeg> > parseTime defaultTimeLocale  "%e %B %Y" "April 2000" :: Maybe Day
12:32:49 <lambdabot>   Not in scope: type constructor or class `Day'Not in scope: `parseTime'Not i...
12:33:02 <mikeg> merijn: Just *** Exception: Prelude.read: no parse
12:33:36 <conal> jmcarthur: are you attaching finalizers to a container of the resource pointers?
12:33:40 <jmcarthur> conal: my wrapper is still exposing some impure things like mutable buffers and such, but a lot of it is pure at least
12:33:55 <sm> mikeg: looks like a bug to me
12:34:14 <djahandarie> With all these people working on games it'd be nice to see some good libraries come out of it. (So my life is easier whenever I do it.)
12:34:26 <mikeg> Eek, what do I do about it? :)
12:34:29 <devinus> what are some good cross platform haskell gui platforms?
12:34:33 * sm agrees with djahandarie 
12:34:48 <sm> mikeg: report it to the maintainer or bug tracker on the hackage page
12:34:51 <Phyx-> Hmm, is anyone else getting weird bounce messages from the haddock mailing list on mails they never send
12:34:55 <conal> devinus: do you care about ghci-friendliness?
12:35:05 <jmcarthur> conal: i haven't nailed own yet what can take a finalizer and what can't. currently i'm just trying to attach the finalizers to the GLuint identifiers that OpenGL generates. to make sure they don't get garbage collected while bound i'm using withBound* functions and forcing evaluation of the identifiers after it's done
12:35:07 <conal> devinus: (for your gui lib)
12:35:10 <devinus> conal: hrm, i guess so yeah
12:35:26 <sm> mikeg: and look for any newer version on hackage or in the repo 
12:35:47 <conal> devinus: me too. and i haven't found one yet. it's why i stopped working on functional guis & graphics.
12:35:59 <devinus> :(
12:36:02 <merijn> djahandarie: I'm hoping a good FRP library materializes as that seems to be perfect for games :p
12:36:07 <jmcarthur> i'm not sure if i can just assign finalizers to the OpenGL types like that. i haven't given this a thorough testing
12:36:12 <mtnviewmark> Phyx: not I, and I am subscribed to that list
12:36:17 <mikeg> sm: time-1.2.0.3 (ghc-7.0.1) is latest
12:36:24 <jmcarthur> *the OpenGLRaw types
12:36:57 <conal> jmcarthur: i've been stung by the subtleties of finalization vs ghc optimizations.
12:37:02 <jmcarthur> devinus: there's always the old standbys: gtk, wxwidgets, etc.
12:37:14 <merijn> BTW, any OS X users? How do I uninstall my current Haskell Platform version so I can install the latest one?
12:37:18 <jmcarthur> conal: that's worrying. what optimizations in particular?
12:37:20 <conal> wxhaskell kills ghci :(
12:37:22 <jmcarthur> if you know
12:37:38 <Phyx-> mtnviewmark: i'm getting daily reports on a bounce message i never send
12:37:59 <Phyx-> mtnviewmark: "The subject of the message is: Re: [haddock] #37: Hide instances that are "internal" to a module"
12:38:13 <conal> jmcarthur: i've attached finalizers to haskell structures and then had those structures discarded by the compiler, passing fields instead. hence premature finalization.
12:38:22 <merijn> Or better yet, can I just install GHC7 without touching my Haskell Platform installation?
12:38:27 <jmcarthur> ah stinky
12:38:36 <mtnviewmark> Phyx - that looks like it is coming from the trac
12:38:49 <jmcarthur> conal: i think in this case unless ghc is actually unboxing these identifiers it will probably be okay
12:39:35 <jmcarthur> maybe i should google for common errors around finalizers or something though
12:39:42 <conal> jmcarthur: ghc may well unbox. and if not in one ghc release, then perhaps in another.
12:39:43 <Phyx-> mtnviewmark: yeah it's comming from the ghc trac
12:39:51 <jmcarthur> yeah :\
12:40:16 <mtnviewmark> merijn: that may or may not be quite such an easy thing to do
12:40:36 <mtnviewmark> but basically, if you want to wipe the entire platform away (compiler + libraries)
12:40:36 <jmcarthur> i wonder if there's a way to *prevent* it from unboxing these
12:40:50 <jmcarthur> conal: i guess this is what you were getting at about containers?
12:41:06 <conal> jmcarthur: yeah.
12:41:22 <mtnviewmark> there is an Uninstaller script in /Library/Frameworks/GHC.framework/Tools
12:41:37 <conal> jmcarthur: e.g. i had to copy & reimplement the Chan type to add finalizability.
12:41:38 <mtnviewmark> which will get rid of the compiler
12:41:50 <merijn> mtnviewmark: What isn't easy to do? GHC7 + haskell platform?
12:42:07 <mtnviewmark> remove /Library/Frameworks/HaskellPlatform.framework/
12:42:18 <mtnviewmark> but then you have leftover symlinks in /usr/loca/bin
12:42:41 <Phyx-> mtnviewmark: anything i can do about it, it's starting to become spamish
12:42:58 <mtnviewmark> and if you installed packages --user, you need to wipe things in ~/.cabal
12:43:02 <mtnviewmark> (not everything there)
12:43:27 <mtnviewmark> and.... sigh, if you installed things --global, you've got packages all over hell-an-gone
12:43:31 <merijn> Naah, not done much with packages. Just wanna start with a fresh slate and play with the new IO manager
12:43:47 <mtnviewmark> mind you, leaving the old packages around is just diskspace....
12:43:57 <mtnviewmark> Phyx: no idea 
12:44:23 <mtnviewmark> merijn: Your problem is EXACTLY why I proposed a new layout for installed haskell packages
12:44:43 <merijn> mtnviewmark: I'll just not touch HaskellPlatform and drop in GHC7 after removing GHC and see if everything keeps working ;)
12:45:04 <mtnviewmark> it won't work at all
12:45:05 <mtnviewmark> http://mtnviewmark.wordpress.com/2010/12/02/haskell-package-layout/
12:45:24 <mtnviewmark> it won't work because a) none of those packages will have been compiled with GHC7, and so won't be compatible
12:45:40 <mtnviewmark> and even if they were, b) they won't be registered in the new compiler's package database
12:45:47 <merijn> Hmm
12:46:08 <mtnviewmark> you have to cabal reinstall the haskell-platform package
12:46:17 <mtnviewmark> after you install the new compiler
12:46:45 <mtnviewmark> and THAT, sigh, won't put them in the same place that the Haskell Platform installer put stuff
12:46:57 <mtnviewmark> but that old stuff will just hang around, not hurting anything 
12:47:22 <mtnviewmark> (Yes, I'm working on the next Haskell Platform Mac OS X installer, and I'm trying improve this situation in the next release)
12:47:29 <jmcarthur> conal: the only other way to control resources somewhat more nicely than the raw opengl api offers is something like monadic regions, but while you can get rid of having to manually deallocate resources, it's still awkward, and your types still end up exposing all that stuff :\
12:47:43 <jmcarthur> *the only other way *i can think of*
12:47:50 * sm cheers on mtnviewmark 
12:48:03 <conal> jmcarthur: ick. let's keep looking for better ways.
12:48:37 <jmcarthur> hmm
12:48:38 <mtnviewmark> thanks, sm -- actually I think the package layout idea would improve the same set if issues on *nix platforms as well 
12:48:54 <sm> seems so
12:49:08 <jmcarthur> what would be nice is if instead of finalizers, we could register callbacks for "GC just ran" and "object X is still here", "object Y is still here", etc.
12:49:10 <sm> let's see what the cabal gods think
12:49:25 <jmcarthur> might have some of the same problems i guess...
12:49:30 <mtnviewmark> the cabal gods suggested I take it to the masses, actually!
12:49:36 <mtnviewmark> up-vote it on the reddit if you like it!
12:49:37 <sm> ha!
12:49:47 <mtnviewmark> comment on the reddit or the blog to help make it better
12:49:53 <merijn> Ideally I'd use macports and let them porters handle it, but then I'm always behind so that's kinda annoying too :\
12:49:58 <jmcarthur> that could be slow too i suppose, considering the generational GC and all that
12:50:09 <jmcarthur> just thinking aloud. i think it may be a bad idea now
12:50:21 <conal> jmcarthur: i don't know if there are fundamental problems with integrating non-ram resource management into the gc.
12:50:36 <mtnviewmark> I don't know who is packaging Haskell Platform for macports -- I'm doing a standard Mac OS X installer package, like the last release was done
12:50:59 <mtnviewmark> (only it is now one install for both GHC + libraries, no longer two)
12:51:05 <conal> jmcarthur: rather than trying to bolt a different approach .
12:51:20 <merijn> mtnviewmark: Nice
12:51:22 <jmcarthur> conal: the "GC just ran" callback might still be nice though. could keep some global collection of weak references to various resources and then after a GC runs you can traverse that collection yourself and handle things however you please
12:51:22 * hackagebot sifflet-lib 1.2.2 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.2.2 (GregoryWeber)
12:51:25 <adnap_> what is an "opaque type contructor"?  Does that just mean it wraps up a value?
12:51:43 <conal> jmcarthur: maybe so.
12:51:50 <merijn> adnap_: It means "you don't know what happens inside"
12:51:56 <devinus> conal: which is the most mature of the gui libs?
12:52:02 <adnap_> merijn: okay
12:52:23 * hackagebot sifflet 1.2.2 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.2.2 (GregoryWeber)
12:52:36 <conal> devinus: wxhaskell or gtk2hs i guess. both are problematic on mac os x. 
12:52:53 <sshc> I want to use *and store* a pointer to the contents of a StorableArray (which I've created by safely thawing an array).  How should I do this?  The documentation on http://hackage.haskell.org/packages/archive/array/0.3.0.2/doc/html/Data-Array-Storable.html is unclear.
12:53:32 <adnap_> I'm looking at this here: http://hackage.haskell.org/packages/archive/GPipe/1.3/doc/html/Graphics-GPipe-Stream-Primitive.html#t:Vertex  It seems that I cannot call the Vertex data constructor.  Has the author possibly not exposed it on purpose?  Is that the reason he calls it an opaque constructor?
12:54:08 <revenantphx> So there are no Cocoa bindings for haskell?
12:54:39 <tg_> @hackage Cocoa
12:54:39 <lambdabot> http://hackage.haskell.org/package/Cocoa
12:54:55 <tg_> @hackage ArbitraryString
12:54:55 <lambdabot> http://hackage.haskell.org/package/ArbitraryString
12:54:56 <jmcarthur> adnap_: yeah that's the usual meaning for "opaque"
12:54:57 <tg_> :(
12:55:16 <gienah> There is Qt, which support MacOS, Windows, Unix
12:55:18 <aristid> @hackage unfortunately, @hackage does no checks
12:55:18 <lambdabot> http://hackage.haskell.org/package/unfortunately, @hackage does no checks
12:55:32 <merijn> adnap_: Opaque usually means "don't go messing with the insides!"
12:55:40 <tg_> aristid: more clever than mine
12:55:44 <adnap_> thanks
12:56:28 <gienah> http://qthaskell.berlios.de/ Qt is a very powerful GUI library
12:57:08 <adnap_> I guess I just need to figure out how the author intends for me to do things then.  I want to make vertices generated from a RandomGen, but Vertex isn't a member of Random.  So, I was thinking of taking Floats and making those into Vertices.
12:57:23 <devinus> gienah: how mature is qthaskell?
12:57:58 <gienah> devinus: I don't know how mature the Haskell bindings are, but obviously the underlying C++ libs are very mature
13:01:06 <jmcarthur> conal: if this becomes a problem for me i wonder if simply wrapping these things up in IORefs and using unsafePerformIO . readIORef all over the place would fix it
13:01:14 <jmcarthur> kind of stupid though...
13:01:52 <conal> jmcarthur: oh. hm. i hadn't thought of that hack.
13:02:01 <devinus> would be nice to have a cross platform gui library written in haskell...
13:02:45 <conal> devinus: another question is imperative vs functional/denotative.
13:03:26 <devinus> conal: we're looking at haskell because we want immutable, pure functional typed languages
13:03:38 <jmcarthur> devinus: are you with a company?
13:03:46 <devinus> jmcarthur: yes
13:03:58 <devinus> we're just tired of JS getting in our way
13:04:04 <devinus> tired of browsers
13:04:06 <jmcarthur> devinus: what's the company?
13:04:10 <conal> devinus: glad to hear it. many folks settle for imperative designs even in haskell.
13:04:37 <devinus> jmcarthur: it's a small travel company
13:04:59 <conal> devinus: does your company have a consulting budget? i'm available.
13:05:05 <jmcarthur> devinus: where is it based? might they be interested in hiring haskell guys?
13:05:12 <jmcarthur> conal: man, i can't compete with you! :P
13:05:38 <devinus> conal, jmcarthur: we're just exploring, no idea if we're going to be using haskell yet
13:07:23 <conal> devinus: if you'd like some consulting to explore possibilities, let me know. i've done a tone of thinking about & experimentation with functional guis (& other forms of functional interactive graphics).
13:07:30 <jmcarthur> devinus: is there a criteria you have in picking a language/platform? maybe we can help you out (despite our bias ;) )
13:08:32 <jmcarthur> devinus: conal has done a lot more of this than i have, but i'm also interested if anything comes up :)
13:08:54 <devinus> jmcarthur: we're sort of still building our criteria still
13:09:11 <devinus> conal, jmcarthur: and i'll keep both of you in mind btw
13:11:12 <conal> devinus: cool. for some ideas, check out not just low-level imperative libs (wxhaskell, gtk2hs, qthaskell), but also higher-level stuff, including phooey & TV/Eros.
13:12:32 <conal> i'd like to collaborate on an elegant denotative GUI library built out of modern graphics hardware (programmable shaders).
13:12:40 <djahandarie> Phooey would be broken right now wouldn't it?
13:12:49 <conal> djahandarie: yeah.
13:13:11 <conal> djahandarie: and i prefer the TV style now.
13:13:52 <conal> as TV is much more composition-friendly
13:15:06 <cgomez> hello
13:16:54 <sm> #17 was our best showing in the google-ai challenge ? bah
13:17:03 <djahandarie> Hm. code.haskell.org seems to be down.
13:17:20 <djahandarie> cgomez, hi
13:17:29 <tg_> conal: I would too.
13:17:45 <conal> tg_: :)
13:17:46 <djahandarie> sm, yeah. It's too bad there isn't much movement in the AI Haskell community
13:17:50 <jmcarthur> conal: okay after reading around a bit i think i've decided that i really should wrap these in IORef and arrange the finalizer using mkWeakIORef. it supposedly works around the unboxing issue, and i think using it under unsafePerformIO probably won't change that property
13:17:51 <tg_> And I have some concrete ideas about the interactivity, style, and vision of the program - and even a name
13:18:06 <tg_> but I need to get collaborators and get coding
13:18:35 <djahandarie> tg_, "the program"? What program? :o
13:18:36 <conal> tg_: have you written up some of your ideas, to share?
13:18:41 <jmcarthur> conal: thanks for scaring me into action on this
13:19:03 <tg_> conal: I have it all on notebook paper at the moment. I will do this in the next few days.
13:19:05 * djahandarie jumps up behind jmcarthur and scares him into more action
13:19:15 <conal> tg_: cool.
13:19:21 <tg_> Seeing Manatee working as it does made me get focused again
13:19:28 <cgomez> I need help with converting an String haskell to an image file; I am getting the string haskell with libcurl haskell from the web; any ideas?
13:19:59 <jmcarthur> cgomez: you could check out some of the image libraries on hackage
13:20:10 <sm> and the next haskell entry is #130 !
13:20:30 <sm> we, uh, mustn't have heard about the contest
13:20:32 <conal> jmcarthur: better think it through carefully. i'm nervous about these hacks in general. 
13:20:43 <djahandarie> sm, according to the charts on that reddit link we did alright overall though in terms of overall distribution
13:20:52 <conal> jmcarthur: do you have a blog yet? i'd love to see these issues discussed.
13:21:04 <sm> I couldn't see numbers of entries on those charts, so I don't read much from the haskell one
13:21:07 <tg_> conal: "d:rive" d (like derivative), really interactive visceral environment
13:21:17 <conal> tg_: neat
13:21:37 <tg_> I want a tool that is compelling enough to make a modern physicist (like myself) use it
13:21:47 <tg_> which is a huge leap
13:22:00 <sm> 51 haskell entries out of 4617 total
13:22:28 <tg_> conal: i'll do as much as I can this weekend and share whatever I get with you and a few others
13:22:31 <conal> tg_: i like that goal. 
13:22:34 * hackagebot dow 0.2.2 - Dungeons of Wor  http://hackage.haskell.org/package/dow-0.2.2 (GergelyPatai)
13:22:44 <djahandarie> sm, jaspervdj upgraded the provided starting code too. It wouldn't have been too hard to get more participants probably
13:23:03 <tg_> conal: I really do think it could be the kind of thing which could compel adoption of haskell - ie, a killer app
13:23:19 <sm> 1232 c++ entries, 948 python, 1634 java, 33 lisp 
13:23:47 <jmcarthur> conal: i have one, but it dies under load and i don't really update it
13:23:51 <conal> tg_: super.
13:24:09 <sm> djahandarie: yes, that was good.. I downloaded it but decided the comp. would be too expensive
13:24:12 <tg_> conal: plus, we already have the haskell-maths guys, and the manatee guy
13:24:27 <dons> sm: 1.1% 
13:24:29 <tg_> plus your no-longer-named reactive
13:24:45 <djahandarie> ManateeLazyCat. Who also goes by 'ManateeAuthor' these days.
13:24:58 <tg_> yeah.
13:25:13 <jmcarthur> conal: i do plan to put up a repo once things are running at all, even if running badly
13:26:26 <jmcarthur> maybe i should just go back to wordpress.org and blog once again
13:26:53 <jmcarthur> i love blogging, i just hate taking the time to do it
13:26:59 <monochrom> ManateeManateeAuthor
13:27:24 <tg_> jmcarthur: s/blogging/writing/, and that's an adage as old as papyrus
13:27:26 <monochrom> I should invent yet another blogging system so you have more choice.
13:27:38 <conal> jmcarthur: i really hope you do.
13:27:42 <monochrom> meanwhile you may just tweet.
13:27:45 <conal> jmcarthur: (write/blog)
13:27:56 <tg_> conal: watcha been workin on?
13:29:18 <conal> tg_: most recently i've been playing with common sub-expression elimination again for "deep DSELs". it was the main broken piece of my functional->GPU compiler.
13:29:46 <edlinde> is it possible to get the current time as an Int in Haskell?
13:29:55 <conal> tg_: also, various ideas about high-level numerics (in contrast to the machine types we usually use in haskell & other langs).
13:29:55 <edlinde> I want to use it as a seed for my pseudo RNG
13:30:13 <tg_> conal: not that I think it's directly applicapable, nor fast enough performance wise, but have you looked at the symmetric lens papers?
13:30:30 <conal> tg_: i don't think so.  what paper?
13:31:02 <unkanon> edlinde: getCurrentTime ?
13:31:04 <tg_> conal: http://www.cis.upenn.edu/~bcpierce/papers/symmetric-full.pdf
13:31:09 <conal> tg_: thx.
13:31:31 <unkanon> edlinde: you'll never get the time as a pure Int though
13:31:32 <edlinde> unkanon: doesn't work
13:31:34 <tg_> i doubt it will help your problem, but I read the paper last week
13:31:39 <edlinde> hmm
13:32:24 <mreh> DTD are actually quite a complicated structure
13:32:34 <mreh> I was hoping drawing a tree of one would be easy
13:32:44 <conal> i've also been thinking about various entrepreneurial projects. and realizing i need collaborators for areas in which i'm weak. for instance, i learned how to program iOS and made some nice libs, but i don't know what to do with it.
13:33:25 * monochrom fears DTD too
13:33:42 <devinus> conal: hrm...are there any haskell -> js libs, maybe like parenscript?
13:33:52 * monochrom learned it and wrote a small one, but it's a lot of work
13:34:09 <conal> devinus: yeah. there's some haskell -> js work going on.
13:34:21 <devinus> nice
13:34:25 <sm> edlinde: it works :)
13:34:27 <unkanon> edlinde: it works fine for me
13:34:41 <edlinde> what does?
13:34:47 <tg_> conal: I've been learning about lagrangian and hamiltonian mechanics, quantum loop theories, etc :o
13:34:53 <unkanon> edlinde: getCurrentTime
13:34:58 <conal> devinus: i hadn't seen parenscript. thx. i used to program in lisp & scheme quite a lot (before sml & haskell) and had a great time with it.
13:35:07 <conal> tg_: nice.
13:35:21 <jmcarthur> devinus: i think there is a ghc backend to target javascript, and there's an older project that uses YHC, iirc
13:35:39 <edlinde> <interactive>:1:0: Not in scope: `getCurrentTime'
13:35:45 <dankna> jmc is correct but both projects are a bit bitrotten
13:35:49 <monochrom> @hoogle getCurrentTime
13:35:49 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
13:35:49 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
13:36:02 <sm> edlinde: import Data.Time
13:36:05 <dankna> I tried a couple months ago to get the ghc one working but it required a lot of delving into the ghc core source and my conclusion was that it would be better to wait until some multi-target stuff had been added
13:36:11 <dankna> which it may have been by now
13:36:39 <jmcarthur> conal: re: CSE:  what are your thoughts on capturing sharing from the getgo instead of attempting to recapture it as an optimization pass? there have been a couple papers about that
13:37:17 <conal> jmcarthur: capture sharing by tweaking the api, as in some kind of explicit let-like combinator?
13:37:40 <jmcarthur> conal: i'm thinking of Type-Safe Observable Sharing in Haskell and also that Nikola paper
13:37:51 <jmcarthur> conal: here's the latter: http://www.eecs.harvard.edu/~mainland/publications/mainland10nikola.pdf
13:37:53 <monochrom> "HJScript library: HJScript is a Haskell EDSL for writing JavaScript programs."
13:38:00 <unkanon> edlinde: :m Data.Time.Clock
13:38:12 <monochrom> "jmacro library and program: QuasiQuotation library for programmatic generation of Javascript code."
13:38:13 <unkanon> edlinde: then getCurrentTime >>= return . utctDayTime
13:38:21 <edlinde> ok
13:38:26 <conal> jmcarthur: iiuc, andy's TSOS paper recovers sharing after the fact. and only rep sharing, not equal terms.
13:38:30 <jmcarthur> conal: in Nikola i believe they preserve sharing in the translation from HOAS to their internal AST
13:38:39 <jmcarthur> oh i thought it worked differently
13:38:54 <pome1> folks, how would i express (\f.f 3) (\x.x+2) in haskell?
13:39:05 <jmcarthur> Nikola uses the TSOS to preserve let sharing and something of their own to preserve lambda sharing
13:39:54 <jmcarthur> conal: yeah, terms which are merely equal will only be shared through CSE, as i understand it
13:39:59 <Philonous> > (\f -> f 3) (\x -> x+2) -- pome1 
13:40:00 <lambdabot>   5
13:40:47 <jmcarthur> conal: according to the nikola paper, andy's technique allows you to observe haskell's let sharing through the IO monad
13:40:57 <conal> jmcarthur: ah. i also used a typed variant of TSOS for my functional->gpu compiler. but rep (pointer) sharing isn't enough for me.  modular programming and aggressive optimization lead to more equal (but not pointer-equal) terms. so i have a thorough approach as well.
13:41:05 <Philonous> > ($ 3) (+ 2) -- maybe more idiomatic
13:41:06 <lambdabot>   5
13:41:39 <jmcarthur> conal: ah okay
13:41:52 <jmcarthur> so some of your optimizations are breaking sharing then?
13:41:56 <pome1> philonous - could you possibly write a few lines of code for me? i'm pretty new to haskell and not all too sure how to implement it.
13:42:32 <conal> jmcarthur: i don't think i break sharing. rather, equal terms arise fairly often during inlining. 
13:43:06 <Philonous> pome1, I doubt that it would be a good idea. But what are you trying to implement, anyway?
13:43:25 <jmcarthur> oh, i think i see what you mean
13:43:28 <conal> jmcarthur: a programmer could avoid such redundant computations by programming less modularly. which i guess is the most common solution. but i like modularity.
13:45:25 <jmcarthur> conal: it seems to me that modularity tends to result in *greater* sharing (common functionality is extracted into separate abstractions, etc.)
13:45:43 <jmcarthur> and decomposition tends to break problems apart into sharable parts
13:45:51 <jmcarthur> maybe i'm missing something
13:46:56 <jmcarthur> greater *potential* for sharing, i mean
13:47:37 <jmcarthur> whereas programming less modularly i see as usually used to fuse computations where the compiler is failing to do it for you, which reduces sharing
13:48:11 <conal> jmcarthur: suppose functions f & g have some expression in common. i can factor out that work to a function c (if it isn't already) called by both.  then when i define h via f & g, i'll get redundant computation of c x.
13:48:45 <conal> jmcarthur: a typical penalty of modular programming with functions.
13:49:22 <jmcarthur> conal: seems like f and g might be doing too much work then, to me
13:49:47 <conal> jmcarthur: would you say that if you looked at each in isolation?
13:50:05 <conal> jmcarthur: or only after you considered them being used together as in h?
13:50:35 <conal> jmcarthur: modularity pushes me to evaluate functions w/o considering interactions between them (n^2).
13:51:36 <jmcarthur> conal: e.g. i can't think of many list functions that take the length of the list as an intermediate step even though there are tons of potential functions to do that. the functions in Data.List are sufficiently decomposed that it's hard to accidentally take the length of the same list twice merely by composition
13:51:56 <jmcarthur> maybe i'm being simplistic
13:51:56 <conal> jmcarthur: brb
13:52:12 <unkanon> jmcarthur: shouldn't the compiler work these things out?
13:52:24 <roconnor> unkanon: sadly compilers are stupid
13:52:33 <unkanon> even ghc?
13:52:39 <roconnor> unkanon: GHC won't do CSE because it occasionally leads to spack leaks
13:52:58 <roconnor> *space
13:53:00 <jmcarthur> GHC does *some* CSE
13:53:01 <unkanon> I understand what conal is saying about the redundant computation of c x but I thought a functional language compiler would know better
13:53:11 <roconnor> jmcarthur: almost none
13:53:12 <unkanon> what's CSE?
13:53:12 <jmcarthur> unkanon: how can it?
13:53:18 <jmcarthur> common subexpression elimination
13:53:20 <byorgey> djahandarie: http://byorgey.wordpress.com/2010/12/03/typed-type-level-programming-status-report/
13:53:29 <djahandarie> Nice!!!!!
13:53:40 <mjrosenb> ghc won't pull declarations out of lambdas due to space leaks
13:53:53 <unkanon> jmcarthur: like a theorem prover, it could reduce h to a better definition than merely in terms of f and g
13:54:08 <jmcarthur> mjrosenb: are you sure about that?
13:54:22 <roconnor> AFAIK ghc won't even eliminate CSE from (1 + 2) + (1 + 2)
13:54:30 <roconnor> I could be too pessimistic here
13:54:31 <jmcarthur> mjrosenb: the full laziness optimization leads to space leaks pretty often for exactly that reason
13:54:45 <mjrosenb> jmcarthur: it was true when i looked at a faq about it a *while* back
13:54:48 <conal> jmcarthur: the more one programs at the function level, the more this redundant computation happens.
13:55:05 <djahandarie> byorgey, sounds good. :)
13:55:08 <jmcarthur> roconnor: i've seen somebody report that GHC changed the algorithmic complexity of something in Writer due to CSEing a couple uses of the tell function
13:55:09 <unkanon> oh well, one day compilers will take care of that for us
13:55:12 <byorgey> djahandarie: =)
13:55:23 <unkanon> I won't stop programming with beautiful composable functions because of a few redundancies
13:55:25 <roconnor> jmcarthur: improved the complexity?
13:55:32 <unkanon> like SPJ says, computers just need to get fast enough
13:55:34 <jmcarthur> roconnor: it was a recursive function of some sort
13:55:48 <roconnor> Supero might do some CSEing.
13:55:53 <conal> unkanon: neither will i. that's why i'm working on cse.
13:56:27 <unkanon> conal: well then let me thank you :) as your work will be benefitting everyone really
13:56:59 <conal> unkanon: btw, i'm doing cse in my own dsel compiler, not in ghc.
13:57:09 <proq> does anyone know a good algorithm for detecting the count and length of waves in data?  for example  f [1,2,3,8,2,1,1,1,2,3,8,3,2,1] would return 2 for two waves and 1.5,1.2 for the length of those waves? 
13:57:15 <unkanon> that's ok, everyone benefits
13:57:46 <unkanon> proq: wow that is a cool exercise
13:58:06 <proq> unkanon: it's more of a real-life problem, but yes it is interestintg
13:58:17 <mjrosenb> jmcarthur: perhaps I was wrong.
13:58:19 <byorgey> proq: I don't understand the 1.5, 1.2 numbers
13:58:22 <unkanon> well who knew real life could be interesting! :)
13:58:27 <mjrosenb> proq: is there a formal definition of waves?
13:58:35 <ddarius> You could use autocorrelation and thresholding, but I think you are looking for something more exact.
13:58:37 <proq> byorgey: that's just a made-up number for the length of the wave
13:58:57 <proq> mjrosenb: no.  consider a wave in the ocean  :)
13:59:03 <njoubert> proq: sounds a bit like edit-distance to me
13:59:08 <byorgey> maybe start with  zipWith (<) xs (tail xs)
13:59:11 <unkanon> proq: I have an intuition that that's the sort of problem where Prolog shines
13:59:20 <byorgey> > zipWith (<) xs (tail xs) [1,2,3,8,2,1,1,1,2,3,8,3,2,1]
13:59:21 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
13:59:24 <conal> jmcarthur: for instance, trig functions come up a lot in graphics. pretty common for various higher-level operations to need some sines & cosines. and to precompute them and pass into every op that needs them would complicate the interfaces solely for performance. cse gives me that performance without compromising the interfaces.
13:59:26 <unkanon> but haskell is very prolog-ish (being declarative too) so...
13:59:41 <byorgey> > (\xs -> zipWith (<) xs (tail xs)) [1,2,3,8,2,1,1,1,2,3,8,3,2,1]
13:59:42 <lambdabot>   [True,True,True,False,False,False,False,True,True,True,False,False,False]
13:59:44 <jmcarthur> conal: alright, convinced
14:00:22 <ddarius> unkanon: I disagree with both of your last statements.
14:00:57 <jmcarthur> my main complaint about CSE is that it makes it difficult to reason about a lot of time and space behaviors of your code, but i guess for a shader it won't be doing weird things like sharing infinite lists anyway
14:01:16 <conal> jmcarthur: i think a lot of Applicative interfaces have this same issue.
14:01:30 <roconnor> jmcarthur: does it really make it difficult to reason about the *time* of your code?
14:01:42 <conal> jmcarthur: optimization in general makes time/space reasoning harder, doesn't it?
14:01:48 <roconnor> how can CSE increase time complexity?
14:01:49 <jmcarthur> roconnor: i'm looking for that exponential speedup that i read about a couple years ago
14:01:53 <jmcarthur> it was a speedup
14:01:56 <unkanon> ddarius: how?
14:01:57 <jmcarthur> which is great...
14:02:00 <jmcarthur> but it was fragile
14:02:02 <unkanon> @let p8 [] = []; p8 (x:xs) = x : p8 (dropWhile ((==) x) xs)
14:02:03 <lambdabot>  Defined.
14:02:04 <roconnor> so you are worried that your code might go too fast?
14:02:13 <unkanon> > p8 [True,True,True,False,False,False,False,True,True,True,False,False,False]
14:02:14 <lambdabot>   [True,False,True,False]
14:02:26 <jmcarthur> roconnor: my worry is that it can go fast but then a minor change kills it even if you were relying on it before
14:02:34 <unkanon> now just count how many times it changes 
14:02:36 <unkanon> proq: ^
14:02:40 <ddarius> Well there is a nice example from powersets of the difference sharing makes.
14:02:45 <unkanon> or how many trues
14:03:03 <proq> unkanon: looks like a nice start, thanks  :)
14:03:08 <roconnor> hmm
14:03:16 <unkanon> proq: thank byorgey , he did the tough part :)
14:03:39 <byorgey> my part wasn't that tough =)
14:03:46 <unkanon> > p8 ((\xs -> zipWith (<) xs (tail xs)) [1,2,3,8,2,1,1,1,2,3,8,3,2,1])
14:03:47 <lambdabot>   [True,False,True,False]
14:04:02 <dolio> Using asymptotically more space doesn't help runtime.
14:04:07 <ddarius> Incidentally, p8 is a foldr.
14:04:08 <jmcarthur> massive speedups are great when reliable, terrible when not
14:04:11 <conal> function-level programming leads to lots of redundant computation w/o cse. since the sharable values cannot be named.
14:04:12 <dolio> At least, not necessarily.
14:04:17 <unkanon> byorgey: then make a function that counts Trues and we'll be done
14:04:19 <unkanon> :)
14:04:34 <byorgey> length . filter id
14:04:45 <unkanon> ddarius: I guess, yeah
14:05:06 <unkanon> > length . filter id $ [True, False, True, False]
14:05:07 <lambdabot>   2
14:05:22 <dolio> I suspect recomputing things for the powerset will ultimately use less time than sending my machine into swap thrashing for the majority of the computation.
14:05:23 <unkanon> > length . filter id $ p8 ((\xs -> zipWith (<) xs (tail xs)) [1,2,3,8,2,1,1,1,2,3,8,3,2,1])
14:05:24 <lambdabot>   2
14:05:27 <unkanon> ta-da!
14:05:46 <unkanon> now ddarius will make it look pretty :P
14:05:55 <unkanon> proq: ^
14:06:29 <ddarius> length, filter, and p8 can all be expressed as a foldr so you can probably fuse them into one.
14:06:43 <aristid> :t count
14:06:44 <lambdabot> Not in scope: `count'
14:06:47 <jmcarthur> roconnor: lol, it was you! http://www.reddit.com/r/programming/comments/8mmcu/i_tried_to_translate_the_ironpython_code_to/c09rjua
14:06:53 <tg_> lfilp8dr, in other words
14:06:57 <byorgey> > let among f xs = zipWith f xs (tail xs) in length . filter id . among (\x y -> x && not y) . among (<) $ [1,2,3,8,2,1,1,1,2,3,8,3,2,1]
14:06:58 <unkanon> ddarius: one day, when I'm not just 2 weeks into Haskell, I will see what you see :)
14:06:59 <lambdabot>   2
14:07:01 <aristid> @let count = length .: filter
14:07:02 <lambdabot>  Defined.
14:07:06 <jmcarthur> roconnor: ironically, you were confused about the speedup ;)
14:07:15 <aristid> @let countTrue = count id
14:07:16 <lambdabot>  Defined.
14:07:32 <aristid> > countTrue $ p8 ((\xs -> zipWith (<) xs (tail xs)) [1,2,3,8,2,1,1,1,2,3,8,3,2,1])
14:07:33 <lambdabot>   2
14:07:33 * unkanon is watching
14:07:45 <unkanon> prettier
14:08:21 <byorgey> I wonder if there is an interesting law about  among f . among g
14:08:23 <aristid> > countTrue $ p8 ((zipWith (<) <*> tail) [1,2,3,8,2,1,1,1,2,3,8,3,2,1])
14:08:24 <lambdabot>   2
14:08:39 <aristid> > countTrue . p8 $ (zipWith (<) <*> tail) [1,2,3,8,2,1,1,1,2,3,8,3,2,1]
14:08:40 <lambdabot>   2
14:08:49 <unkanon> @let findWaves = (zipWith (<) <*> tail)
14:08:50 <lambdabot>  Defined.
14:08:58 <unkanon> @let mergeSame = p8
14:08:59 <lambdabot>  Defined.
14:09:27 <unkanon> > countTrue . mergeSame $ (findWaves [1,2,3,8,2,1,1,1,2,3,8,3,2,1]
14:09:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:09:30 <unkanon> > countTrue . mergeSame $ (findWaves [1,2,3,8,2,1,1,1,2,3,8,3,2,1])
14:09:31 <lambdabot>   2
14:10:02 <aristid> superfluous parentheses.
14:10:08 <unkanon> I bet, yes
14:10:15 <unkanon> > countTrue . mergeSame $ findWaves [1,2,3,8,2,1,1,1,2,3,8,3,2,1]
14:10:16 <lambdabot>   2
14:10:32 <aristid> > countTrue . mergeSame . findWaves $ [1,2,3,8,2,1,1,1,2,3,8,3,2,1]
14:10:33 <lambdabot>   2
14:10:52 <aristid> and that's the beauty of decomposition
14:11:02 <sleepynate> that it grows new plants.
14:11:28 <aristid> *not understands*
14:11:35 <unkanon> nice job, guys
14:12:02 <unkanon> now excuse me as I will go ahead and try to understand why byorgey's code works
14:12:39 <byorgey> unkanon: should I explain it, or do you want to think about it for a while?
14:12:50 <unkanon> byorgey: let me think :)
14:12:55 <byorgey> ok =)
14:14:37 <unkanon> well looking at the simplest case we have
14:14:39 <unkanon> > zipWith (<) [1] [2]
14:14:40 <lambdabot>   [True]
14:14:46 <unkanon> so I understand what the algorithm does
14:15:05 <unkanon> it's comparing xs with xs minus its head, zipping both lists with <
14:15:35 <unkanon> so that now we have a list of booleans representing whether the element on xs is (<) than the element on (tail xs)
14:15:50 <byorgey> right
14:15:54 <unkanon> I understand what it does but not why it matters for the problem
14:16:05 <unkanon> I thought the problem was to detect that a certain pattern repeats
14:16:07 <ddarius> findWaves is really findPeaks.
14:16:19 <unkanon> oh....
14:16:23 <unkanon> that helps a lot
14:16:29 <byorgey> unkanon: well, I'm not exactly sure what the problem is, since proq didn't really specify ;)
14:16:37 <byorgey> so I just made up my own interpretation =)
14:17:04 <unkanon> > countTrue . mergeSame . findWaves $ [2,2,2,3,3,3,2,2,2,3,3,3,2,2,2,3,3,3]
14:17:05 <lambdabot>   3
14:17:36 <unkanon> I understand now, naming it findPeaks makes it clearer what its intention is
14:17:49 <unkanon> wow, lesson learned about how important it is to name your functions properly
14:18:06 <byorgey> hehe
14:19:27 <proq> byorgey: the problem is mainly to take the numbers and count the number and length of the waves.  some fuzzy logic could be involved because if there were other ripples in the wave it could throw off a <.  for example 1,2,7,8,7,8,3,1 would be one wave, not two
14:19:40 <augur> can anyone give a simple example of a monad transformer? like, dead dead simple, not some marginally useful example for evaluators, etc. just a simple maybe useless monad transformer
14:19:53 <proq> or maybe just a threshhold value for what denotes two waves versus one
14:20:44 <unkanon> > countTrue . mergeSame . findWaves $ [1,2,7,8,7,8,3,1,1,2,7,8,7,8,3,1]
14:20:45 <lambdabot>   4
14:20:52 <unkanon> hmm yeah that's a problem
14:22:09 <hpc> :t findWaves
14:22:10 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
14:22:12 <byorgey> proq: well, sure, you just have to define what constitutes a wave.
14:22:26 <hpc> > findWaves [0,0,1,1,0,1,0,3]
14:22:27 <lambdabot>   [False,True,False,False,True,False,True]
14:22:47 <hpc> nifty
14:23:01 <tg_> :t findWaves
14:23:02 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
14:23:19 <tg_> >findWaves [0,0,0,0,1,0,0,1,1,1]
14:23:28 <tg_> > findWaves [0,0,0,0,1,0,0,1,1,1]
14:23:29 <lambdabot>   [False,False,False,True,False,False,True,False,False]
14:23:46 <monochrom> augur: newtype IntStateT m a = Ctor (Int -> m (a, Int)) .  If m is a monad, then IntStateT m is also a monad.
14:23:53 <unkanon> > mergeSame . findWaves [0,0,0,0,1,0,0,1,1,1]
14:23:54 <lambdabot>   Couldn't match expected type `[a]'
14:23:54 <lambdabot>         against inferred type `GHC.Bool....
14:24:01 <unkanon> > mergeSame . findWaves $ [0,0,0,0,1,0,0,1,1,1]
14:24:02 <lambdabot>   [False,True,False,True,False]
14:24:07 <kmc> augur, data IdentityT m a = IdentityT { runIdentityT :: m a }
14:24:14 <augur> monochrom: ok but how do you do that
14:24:26 <monochrom> IntStateT m does everything m does plus tracks an Int "state variable"
14:24:34 <aristid> kmc: newtype!
14:24:59 <monochrom> I don't know the meaning of "how do you do that". Just copy and paste the code?
14:25:15 <tg_> are there any FP books published this year I should put on my christmas list?
14:25:21 <tg_> that aren't LYAH :o
14:25:26 <augur> kmc: hmm.. so an IdentityT is (presumably) the type of those things which get you an m a
14:25:48 <augur> er, well, IdentityT m a, rather
14:25:50 <jmcarthur> tg_: i think Bird came out with something that's supposed to be neat
14:26:14 <kmc> aristid, that would be less simple ;)
14:26:16 <ddarius> proq: It sounds more and more like you want to apply signal processing techniques.
14:26:17 <tg_> Introduction to Functional Programming using Haskell (2nd Edition) ?
14:26:33 <augur> kmc: can you complicated it ever so slightly now?
14:26:34 <jmcarthur> tg_: i think this: http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
14:26:42 <kmc> IdentityT is a monad transformer which produces a monad functionally identical to the monad it's given
14:26:45 <proq> ddarius: hmm... maybe I will read up on it
14:26:51 <augur> with all due respect to monochrom, his example is one step beyond the complexities i can get right now
14:26:52 <monochrom> bird's new book is http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
14:26:52 <kmc> augur, i think you should first try to write the appropriate Monad and MonadTrans instances for IdentityT
14:28:08 <tg_> any others?
14:28:12 <tg_> or just books I should read in general
14:28:30 <tg_> so far I have one about mirror neurons, one called Bomb Power
14:28:35 <augur> kmc: ok, so you mean the definitions of return and >>= for IdentityT qua Monad, and also .. lift :: m a -> t m a? for IdentityT qua MonadT?
14:29:37 <monochrom> White and Strunk's "the Elements of Style" is a must-read in general. "Write direct sentences" and not "Write sentences that are direct" for example.
14:29:55 <tg_> that I bought in high school :)
14:30:13 <tg_> that book is canonical reading in my circles
14:30:50 <augur> tg_: ignore Strunk and White, acquire Wardhaugh
14:30:51 <augur> http://itre.cis.upenn.edu/~myl/languagelog/archives/001803.html
14:31:15 <augur> and anything else there
14:31:56 <kmc> yeah augur
14:32:00 <augur> or anything else recommended on language log
14:32:09 <tg_> augur: Frankly, I don't addressing weaknesses in the style of my prose is a top priority right now
14:32:15 <augur> well then!
14:32:35 <kmc> oh the irony
14:32:48 <tg_> Not that I don't have room for improvment, but I am trying to master quantum mechanics and functional programming.
14:32:54 <monochrom> "It simply isn't true that the constructions they instruct you not to use are not used by good writers." is a prime example of what you shouldn't do. Too many not-not-not's. This is objectively unreadable, and it is not just English - you wouldn't even do it in formal logic.
14:33:22 <monochrom> And this is precisely where Strunk and White triumphs.
14:33:43 <sshc> How would I convert Word8 to Char?
14:33:53 <kmc> toEnum . fromIntegral
14:33:59 <sshc> Thanks
14:34:02 <tg_> I could use help when I get to the stage of publishing, but that is over a horizon for me right now.
14:34:29 <sshc> > toEnum . fromEnum $ 100 :: Char
14:34:30 <lambdabot>   'd'
14:34:35 <sshc> > toEnum . fromIntegral $ 100 :: Char
14:34:36 <lambdabot>   'd'
14:34:39 <sshc> What's the difference?
14:34:45 <monochrom> If you want to write docs that saves programmers' time, you should care about better writing too.
14:35:13 <hpc> sshc: different typeclass; for numbers, they will typically be the same
14:35:14 <hpc> but
14:35:29 <hpc> actually i can't think of a counter-example
14:35:36 <tg_> monochrom: I do, and I do care - but it's not a weakness. I understand that it *is* a common weakness among my fellow computer scientists.
14:35:41 <monochrom> how to send maximum information in minimum reader's parsing time
14:35:55 <sshc> hpc: Which of the two is cleaner?
14:36:18 <unkanon> monochrom: Ending a sentence with a preposition is something up with which I will not put -- Winston Churchill.
14:36:20 * theorbtwo prefers the symmetry of toEnum . fromEnum.
14:36:21 <kmc> you can also use "chr . fromIntegral"
14:36:22 <hpc> toEnum . fromEnum probably
14:36:26 <hpc> :t toEnum . fromEnum
14:36:27 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
14:36:28 <kmc> chr being toEnum specialized to Int -> Char
14:36:33 <hpc> :t toEnum . fromIntegral
14:36:34 <lambdabot> forall a a1. (Enum a, Integral a1) => a1 -> a
14:37:05 <lars9> @hoogle Entry
14:37:06 <lambdabot> Trace.Hpc.Mix createMixEntryDom :: Show a => [(HpcPos, a)] -> [MixEntryDom [a]]
14:37:06 <lambdabot> Network.BSD endHostEntry :: IO ()
14:37:06 <lambdabot> Network.BSD endNetworkEntry :: IO ()
14:37:23 <theorbtwo> chr . fromInegral seems like the best choice, probably, since chr is the most self-documenting.
14:37:30 * hpc is pinged by @hoogle
14:37:31 <monochrom> Oh there are certain Strunk and White instructions I disagree with, too. But only a few of them.
14:37:46 <ddarius> tg_: If you are interested in quantum mechanics, or physics in general, you should read Hestenes' work.
14:37:58 <augur> kmc: now, is it class (Monad m, Monad (t m)) => MonadT t m ??
14:38:01 <lars9> @hoogle Item
14:38:01 <lambdabot> module Data.Graph.Inductive.Internal.FiniteMap
14:38:01 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap data Ord a => FiniteMap a b
14:38:01 <lambdabot> System.Console.Editline.Readline getCompletionQueryItems :: IO Int
14:38:05 <sshc> I see, thanks.
14:38:17 <unkanon> :)
14:38:54 <lars9> anyone configed VIM do align by ( and ) and , ?
14:40:41 <kmc> augur, http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-Class.html
14:41:01 <kmc> so actually the class MonadTrans has no superclass constraint
14:41:05 <kmc> but the method is
14:41:09 <kmc> lift :: Monad m => m a -> t m a
14:41:18 <augur> right ok
14:41:30 <mee> ah, you guys just inadvertantly answered a question I had this morning. Thanks :)
14:41:50 <kmc> so you can make things which are instances of MonadTrans but which aren't monads when given a monad
14:41:55 <kmc> however i'm not sure this is useful
14:43:37 <unkanon> what's wrong here? I know I'm close...
14:43:38 <unkanon> > foldl ((&&).(==)) True [1,2,3]
14:43:39 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:43:39 <lambdabot>         against inferred type ...
14:44:08 <c_wraith> . doesn't compose properly there
14:44:16 <augur> unkanon: first try to understand whats up with (&&).(==)
14:44:22 <Phyx-> @where createProcess
14:44:22 <lambdabot> I know nothing about createprocess.
14:44:23 <c_wraith> it works with one-arg functions, and you're trying to use it with two-arg functions
14:44:29 <Phyx-> @index createProcess
14:44:30 <lambdabot> bzzt
14:44:40 <c_wraith> :t (&&) <=< (==)
14:44:41 <lambdabot> Bool -> Bool -> Bool
14:45:02 <ezyang> Hallo all. Has anyone actually managed to build HaLVM? 
14:45:10 <augur> :t (<=>)
14:45:10 <lambdabot> Not in scope: `<=>'
14:45:12 <augur> whoops
14:45:12 <unkanon> > foldl ((&&) <=< (==)) True [1,2,3]
14:45:13 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
14:45:13 <lambdabot>    arising from the literal `1'...
14:45:19 <augur> :t (<=<)
14:45:20 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:45:33 <c_wraith> > ((&&) <=< (==)) True True
14:45:33 <lambdabot>   True
14:45:34 <ddarius> ezyang: I would be willing to bet that the Galois people have.
14:45:38 <c_wraith> > ((&&) <=< (==)) True False
14:45:39 <lambdabot>   False
14:45:42 <ezyang> It's true! 
14:45:49 <ezyang> I wonder if anyone outside Galois has managed it :-) 
14:46:20 <c_wraith> > liftM2 ((&&) <=< (==)) [False, True] [False, True]
14:46:21 <lambdabot>   [False,False,False,True]
14:46:36 <aristid> :t ((+) <=< (*))
14:46:37 <lambdabot> forall b. (Num b) => b -> b -> b
14:46:42 <aristid> > ((+) <=< (*)) 1 2
14:46:43 <unkanon> uhmm no that's not what I'm looking for
14:46:43 <lambdabot>   4
14:46:50 <Twey> @src (>=>)
14:46:50 <lambdabot> Source not found. My brain just exploded
14:47:02 <unkanon> I want f [1,2,3] to return false, f [1,1,1] to return true
14:47:18 <unkanon> the fold is to answer the question "are all the elements equal"
14:47:26 <aavogt> > all (==1) [1,1,1]
14:47:27 <lambdabot>   True
14:47:32 <unkanon> I tried the naive foldl (==) True [1,2,3] but that didn't work
14:47:38 <unkanon> equal to each other, I mean
14:47:48 <unkanon> > all (==) [1,1,1,1]
14:47:49 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:47:49 <lambdabot>         against inferred type ...
14:48:03 <Twey> > foldl (==) a [b, c] :: Expr
14:48:04 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:48:04 <lambdabot>         against inferred type ...
14:48:11 <aavogt> > case nub [1,1,1] of [_] -> True; _ -> False
14:48:12 <lambdabot>   True
14:48:21 <Twey> Hard to show you because of the type error
14:48:34 <unkanon> > (\x -> all ((==) head x)) [1,1,1,1]
14:48:35 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
14:48:35 <lambdabot>         against inferred ...
14:48:40 <Twey> But it basically means something like 1 == True && 2 == True && …
14:48:50 <unkanon> > (\x -> all (== head x)) [1,1,1,1]
14:48:51 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Bool.Bool)
14:48:51 <lambdabot>    arising f...
14:49:06 <aavogt> still missing the second x
14:49:11 <Twey> @let list d _ [] = d; list _ f (x : xs) = f x xs
14:49:12 <lambdabot>  Defined.
14:49:32 <Twey> allEqual xs = list True (all . (==))
14:49:35 <Twey> Err
14:49:36 <unkanon> what second x? the function should only take one param
14:49:39 <Twey> allEqual = list True (all . (==))
14:49:53 <Twey> @let allEqual = list True (all . (==)) in allEqual [1, 1, 1, 1]
14:49:54 <lambdabot>   Parse error: KW_In
14:49:59 <Twey> > let allEqual = list True (all . (==)) in allEqual [1, 1, 1, 1]
14:50:00 <lambdabot>   True
14:50:03 <Twey> > let allEqual = list True (all . (==)) in allEqual [1, 1, 1, 2]
14:50:04 <lambdabot>   False
14:50:12 <micahjohnston> is there a form of foldl :: (a->a->a) -> [a]?
14:50:13 <Twey> > let allEqual = list True (all . (==)) in allEqual []
14:50:14 <lambdabot>   True
14:50:36 <micahjohnston> @t foldl1
14:50:36 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:50:37 <Twey> micahjohnston: Did you mean (a -> a -> a) -> [a] -> [a]?
14:50:50 <micahjohnston> @type foldl1
14:50:51 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:50:55 <micahjohnston> Twey: I don't think so
14:50:59 <unkanon> @let allEqual2 xs = length (nub xs) == 1
14:51:00 <lambdabot>  Defined.
14:51:05 <micahjohnston> yeah that's what I meant
14:51:05 <unkanon> > allEqual2 [1,1,1,1]
14:51:06 <lambdabot>   True
14:51:08 <unkanon> > allEqual2 [1,1,1,1,2]
14:51:09 <micahjohnston> foldl1 probably
14:51:09 <lambdabot>   False
14:51:12 <Twey> micahjohnston: I don't know what you did mean, then… (a -> a -> a) -> [a] doesn't mean much
14:51:15 <Twey> Ah, okay
14:51:20 <Twey> Yeah
14:51:29 <Twey> Careful how you use it, though: it errors on the empty list
14:51:40 <micahjohnston> oh yeah it would
14:51:52 <aavogt> > allEqual2 [1..]
14:51:55 <lambdabot>   mueval-core: Time limit exceeded
14:51:59 <Twey> It's not as useful as you might think
14:52:00 <unkanon> mwahaha
14:52:02 <Twey> unkanon: That works, but is slower
14:52:09 <micahjohnston> Twey: it's useful when you're using many1 in parsec :)
14:52:10 <unkanon> Twey: yeah that's what I thought too
14:52:15 <unkanon> it's doing unnecessary work
14:52:25 <Twey> micahjohnston: Alright ☺
14:52:39 <aavogt> @src nub
14:52:39 <lambdabot> nub = nubBy (==)
14:52:42 <benmachine> micahjohnston: if you're doing that though you could do foldl f <$> p <*> many p -- :P
14:52:42 <aavogt> @src nubBy
14:52:43 <lambdabot> nubBy eq []             =  []
14:52:43 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:53:01 <micahjohnston> benmachine: I have no default value
14:53:22 <benmachine> micahjohnston: neither do I
14:53:40 <augur> kmc: http://hpaste.org/42053/id_transformer
14:53:44 <micahjohnston> oh I get it
14:53:45 <micahjohnston> :P
14:53:53 <micahjohnston> benmachine: thanks
14:54:06 <kmc> augur, does it typecheck?
14:54:08 <kmc> 	lift (m a) = IdT m a
14:54:14 <kmc> that looks like a suspicious pattern to me
14:54:22 <augur> i think so
14:54:26 <kmc> well try it
14:54:52 <augur> lift :: Monad m => m a -> IdT m a
14:54:59 <stroan> goes GHC expose its internals in library form. Can I get at the typechecker?
14:55:01 <Twey> Type ≠ pattern
14:55:04 <Twey> The syntax is different
14:55:05 <aavogt> Twey: if you're lazy about nub, you'd get two elements different elements why do you think it's slower than allEqual?
14:55:08 <augur> Twey: yes, but
14:55:23 <augur> m a :: M A
14:55:26 <Twey> aavogt: You can't be lazy about nub
14:55:29 <augur> IdT m a :: IdT M A
14:56:03 <edlinde> am trying to solve this 
14:56:04 <Twey> aavogt: Also, parse failure on ‘two elements different elements’; please rephrase
14:56:06 <edlinde>  Write a function that takes a finite list and a list of 'random' numbers and generates a random permutation of the first list.
14:56:07 <aavogt> Twey: I mean it won't bother filtering to get 3 unique elements
14:56:24 <edlinde> so wondering how I can make a permutation of a string based on a list of random numbers
14:56:41 <Twey> aavogt: It will, unless you have lazy numbers and use genericLength
14:56:55 <benmachine> edlinde: what range are the random numbers in?
14:56:59 <benmachine> edlinde: or can you choose?
14:57:07 <Twey> aavogt: It'll filter all the way, then check the whole length, then compare it against 1
14:57:16 <aavogt> I'm refering to > case nub [1,1,1] of [_] -> True; _ -> False
14:57:20 <edlinde> benmachine: It can be anything
14:57:23 <Twey> aavogt: I wasn't
14:57:31 <benmachine> edlinde: anything? skewe's number?
14:57:36 <Twey> aavogt: In fact, I never even saw it
14:57:44 <benmachine> er, skewes'
14:57:58 <Cale> heh
14:58:09 <edlinde> benmachine: ave to look that up :)
14:58:23 <Cale> edlinde: It's just a very large number unrelated to this problem
14:58:26 <benmachine> :P
14:58:30 * benmachine is being silly
14:58:31 <edlinde> hehe
14:58:34 <edlinde> ok ok
14:58:44 <benmachine> it's like, 10^10^10^963
14:58:47 <aavogt> Twey: that's what I mean about being lazy about nub...  it still traverses the whole list, but calls filter only twice (I think)
14:58:49 <edlinde> so yeah lets say I get a list of 100 random numbers
14:59:07 <edlinde> and then use to to permute a string like "Whatever"
14:59:10 <edlinde> dunno
14:59:11 <aavogt> rather than a call to filter for every unique element remaining in the list
14:59:11 <benmachine> edlinde: what distribution do the random numbers have
14:59:30 <edlinde> say from 0 to 7000
14:59:42 <benmachine> every number equally likely in that range?
14:59:48 <edlinde> yeah
14:59:50 <benmachine> ok
14:59:51 <Twey> aavogt: Sure, works
14:59:56 <edlinde> cool
14:59:58 <Twey> aavogt: I still prefer mine though ☺
15:00:01 <edlinde> phew all that questioning
15:00:04 <benmachine> :P
15:00:04 <edlinde> :)
15:00:06 <benmachine> well, think about it in parts
15:00:13 <aavogt> Twey: any difference in constant factors?
15:00:14 <edlinde> I been asked to use the !! 
15:00:21 <Twey> aavogt: Not AFAICT
15:00:21 <benmachine> what could the first letter of your permuted string be?
15:00:25 <Cale> edlinde: So, what you might want to do is to extract randomness from those numbers and get it into a useful form for choosing a permutation. A permutation of n things (a permutation in S_n) can be selected by choosing n numbers where the kth is selected from [1..k]
15:00:25 <edlinde> so I am wondering how I can solve this 
15:00:28 <Twey> aavogt: I just don't like case expressions :þ
15:00:57 <aavogt> the nub version seems to be shorter
15:01:22 <Twey> aavogt: But the list version encapsulates a common pattern
15:01:29 <Cale> Obviously, it would be nice if this selection is uniform, but you might have to settle for less.
15:01:30 <aavogt> Twey: also, your list function seems to be a case expression :)
15:02:09 <Twey> > length *** length $ ("case nub [1,1,1] of [_] -> True; _ -> False", "list True (all . (==))")
15:02:09 <lambdabot>   (43,22)
15:02:19 <Cale> Just modding out the kth number in your sequence by k will give you an approximately uniform distribution, assuming that the numbers were originally selected uniformly from a sufficiently large range.
15:02:23 <aavogt> list isn't in any libraries
15:02:25 <benmachine> :t null . nub
15:02:26 <cgomez> thanks jmcarthur, I am using gd haskell to convert from ByteString to Image. It works very well.
15:02:26 <lambdabot> forall a. (Eq a) => [a] -> Bool
15:02:27 <edlinde> Cale: its just that the example I was given had no letters repeating
15:02:27 <Twey> aavogt: Should be
15:02:43 <edlinde> so what if your random list of numbers has some duplicate values
15:03:31 <edlinde> Cale: I am not sure I follow
15:03:42 <Cale> edlinde: Right, so what you do is to start at the large end of this list of numbers, with i from [1..n], and you select out the ith element, separating it from the rest of the list, leaving n-1 elements remaining.
15:03:54 <edlinde> Cale: I made something like  
15:03:56 <edlinde> *Main> randomsequence 7897 10
15:03:56 <edlinde> [6924,3166,1195,2063,1228,3587,1254,2634,2471,5712]
15:04:02 <Cale> This is the first entry of your permutation
15:04:15 <edlinde> so given it generates 10 random numbers in range 0..7897
15:04:26 <augur> kmc: i dont know :(
15:04:34 <micahjohnston> what should I import to use Applicative and Parsec at the same time? there seem to be a lot of things implemented more generally in Applicative with the same name as things in Parsec
15:04:48 <Cale> edlinde: Right, so start by zipWith mod xs [1..]
15:05:11 <unkanon> > waveSize [1,2,7,8,7,8,3,1,1,2,7,8,7,8,3,1] -- ^ proq
15:05:12 <lambdabot>   8
15:05:12 <Cale> edlinde: where, say,  xs = randoms g :: [Integer]
15:05:15 <unkanon> proq: ^
15:05:23 <Cale> (for some g :: StdGen)
15:05:48 <edlinde> this is a bit confusin
15:05:53 <edlinde> *confusing 
15:05:55 <edlinde> sorry :(
15:06:08 <Cale> edlinde: Okay, let's start back with fundamentals about choosing a permutation
15:06:13 <edlinde> ok cool
15:06:24 <Cale> Suppose we have a list of n elements, and we want to choose a permutation from it
15:06:24 <edlinde> also say I have that list like above
15:06:29 <edlinde> of 10 rand numbers
15:06:39 <edlinde> and say I got a string like "Cale" to permute
15:06:41 <edlinde> :)
15:07:03 <Cale> The first element of our permutation is one of these n, and it has an index from 1 up to n (or from 0 up to n-1, if you prefer)
15:07:07 <edlinde> the list you want to permute is a string yeah?
15:07:14 <Cale> I don't care about its type
15:07:17 <edlinde> ok
15:07:28 <jmcarthur> cgomez: yay!
15:07:36 <edlinde> ok index 0 to n-1 as I want to use !!
15:07:40 <Cale> yeah
15:07:42 <edlinde> ok
15:07:45 <c_wraith> Oh, hmm.  I never did report that my version of the permutations function was faster than the one in Data.List.
15:08:01 <proq> unkanon: nice  :)
15:08:04 <Cale> After choosing that element for our permutation, we have n-1 elements remaining to select from
15:08:09 <monochrom> micahjohnston: if you use parsec version 3, it's already an instance of Applicative, so just import both to ensure you get all the names.
15:08:18 <edlinde> Cale: agreed
15:08:24 <Cale> and so our next selection will have an index [0..n-2]
15:08:25 <unkanon> proq: it's a bit fragile now, I'll make it better (I like that kind of exercise)
15:08:30 <micahjohnston> monochrom: all right
15:08:39 <Cale> and so on until we have only one element remaining and its index is 0
15:08:46 <micahjohnston> monochrom: I have 3 installed; how do I get it to use it instead of 2
15:08:46 <edlinde> Cale: are you selecting the last element in the list?
15:09:02 <Cale> Well, each time we choose an element, we have to separate it from the rest of the list
15:09:09 <edlinde> ok
15:09:19 <edlinde> I thought its easier to do this taking the head of the list?
15:09:19 <Cale> For this purpose, I recommend the following function:
15:09:28 <edlinde> but go on.
15:09:46 <monochrom> normally if you fire up ghci or compile with "ghc --make", higher version number gets the priority automatically, so parsec 3 is chosen and parsec 2 put aside.
15:09:47 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
15:09:52 <benmachine> micahjohnston: import one or the other hiding a few names, there aren't that many duplicates
15:09:53 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
15:09:54 <augur> kmc: halp? :(
15:09:54 <lambdabot>  Defined.
15:09:58 <Cale> select [1,2,3]
15:09:59 <Cale> > select [1,2,3]
15:10:00 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
15:10:06 <benmachine> micahjohnston: just, (<|>), many, that I can think of
15:10:10 <edlinde> ok
15:10:22 <Cale> This gives a list of the elements of the original list, together with the remainder with that element deleted
15:10:34 <micahjohnston> monochrom: I'm using --make :/
15:11:02 <edlinde> Cale: yep so far so good
15:12:03 <Cale> So, now if we were given an index [0..n-1] we could pick one of these separations, use the first component for the first element of our permutation, and the second component would be material for recursing.
15:13:13 <edlinde> hmm
15:13:15 <edlinde> ok
15:13:21 <monochrom> perhaps you had parsec-3 hidden
15:13:41 <edlinde> but then the random number should somehow be in the range of 0 to length of string yeah?
15:13:46 <edlinde> is that what you mean?
15:13:47 <monochrom> ghc-pkg expose parsec-exact_version_here
15:14:12 <edlinde> or whatever it turns out to be I just mod it with (length string)?
15:14:17 <Cale> edlinde: We need a sequence of random numbers where the first one is in the range 0 to n-1, the second from 0 to n-2, and so on
15:14:32 <Cale> (where n is the length of the permutation)
15:14:46 <edlinde> okie
15:15:03 <edlinde> its just that the prof's example seemed to have some much larger range
15:15:29 <edlinde> it wasn't associated to the length of the input string... kinda threw me off 
15:15:37 <Cale> That's good
15:15:51 <edlinde> it is?
15:16:11 <edlinde> is it good because its got a much larger range and less chances of a collision?
15:16:13 <Cale> because if you want to mod the kth element out by k in order to get a roughly uniform distribution from [0..k-1]
15:16:32 <micahjohnston> monochrom: nope, that didn't fix it
15:16:35 <knobo> I'm not convinced about the continuation monad yet. All examples I have seen looks much better without the Cont 
15:16:41 <Cale> then you want the initial range to be large, or else the distribution won't be very even
15:16:47 <knobo> Can anyone help me?
15:16:58 <Cale> knobo: Cont is very rarely used
15:17:02 <edlinde> Cale: could you explain with an example possibly?
15:17:11 <Cale> knobo: But it can be handy if you want goto-like control structures
15:17:12 <edlinde> Cale: I am not seeing how this is working from here on
15:17:14 <kmc> like most other monads, Cont is just sugar
15:17:22 <kmc> i use continuation-passing style fairly frequently in Haskell
15:17:26 <edlinde> this is the tricky bit
15:17:27 <kmc> but rarely use the Cont monad interface to it
15:17:34 <Cale> edlinde: Sure, let's write the function which given an appropriate list of indices, picks a permutation
15:17:39 <monochrom> knobo: http://www.vex.net/~trebla/haskell/cont-monad.xhtml
15:17:50 <edlinde> ok
15:18:06 <kmc> CPS is useful for things like multi-value return or the ability to return to one of multiple points
15:18:22 <kmc> these are the CPS transforms of product and sum types respectively
15:18:26 <kmc> so obviously there's another way to do it
15:18:31 <kmc> but sometimes the CPS comes out looking nicer
15:18:46 <Cale> @let indexPermutation [] xs = []; indexPermutation (n:ns) xs = let (y,ys) = select xs !! n in y : indexPermutation ns ys
15:18:47 <lambdabot>  Defined.
15:18:49 <edlinde> Cale: did you want me to try writing this function?
15:18:57 <edlinde> ok too late
15:19:03 <Cale> > indexPermutation [2,0,0] "Cat"
15:19:04 <lambdabot>   "tCa"
15:19:19 <aristid> :t indexPermutation
15:19:19 <lambdabot> forall a. [Int] -> [a] -> [a]
15:19:58 <aristid> > indexPermutation [2,0,1] "Cat"
15:19:59 <lambdabot>   "tC*Exception: Prelude.(!!): index too large
15:20:04 <aristid> heh.
15:20:09 <knobo> Thanks. It helped some how :)
15:20:24 <edlinde> Cale: is there a reason for 0 being repeated?
15:20:26 <Cale> So the input here is a list of n numbers where the ith number is in the range [0..n-i]
15:20:46 <aristid> monochrom: you need your own domain! :)
15:20:51 <Cale> (So the last one must be 0)
15:20:58 <knobo> (I lost the interest to study monads for now)
15:21:18 <Cale> knobo: Cont is an interesting monad, but it
15:21:19 <knobo> I'll grab some other haskell things to learn first.
15:21:23 <aristid> > indexPermutation [2,0] "Cat"
15:21:23 <lambdabot>   "tC"
15:21:27 <Cale> But it's not very useful in real programs
15:21:30 <edlinde> ok I still need to understand this
15:21:44 <knobo> Any suggestion on what to study?
15:21:56 <aristid> > indexPermutation [2,0,0,0] "Cat"
15:21:57 <lambdabot>   "tCa*Exception: Prelude.(!!): index too large
15:22:13 <Cale> knobo: How about concurrency and STM?
15:22:23 <knobo> STM?
15:22:26 <Cale> It's pretty and you can put your knowledge of basic monads to use :)
15:22:32 <aristid> :t select
15:22:32 <lambdabot> forall t. [t] -> [(t, [t])]
15:22:39 <Cale> Software transactional memory, a system for thread communication.
15:22:45 <aristid> > select [1,2,3,4]
15:22:45 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
15:22:55 <kwos> hi
15:23:02 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/
15:23:05 <Cale> start with...
15:23:14 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
15:23:44 <knobo> looks interesting
15:23:48 <aristid> > let indexPermutation [] xs = xs; indexPermutation (n:ns) xs = let (y,ys) = select xs !! n in y : indexPermutation ns ys in indexPermutation [2] "Cat"
15:23:49 <lambdabot>   "tCa"
15:23:51 <ezyang> "cabal: cannot configure haddock-2.7.2. It requires ghc >=6.12 && <6.14" ==> I'm using GHC 6.12.3. Any ideas? 
15:23:57 <aristid> > let indexPermutation [] xs = xs; indexPermutation (n:ns) xs = let (y,ys) = select xs !! n in y : indexPermutation ns ys in indexPermutation [2,1,0] "Cat"
15:23:58 <lambdabot>   "taC"
15:24:04 <kmc> Cont *would* be useful in a lot of real programs, if it weren't for laziness
15:24:06 <ezyang> According to ghc-pkg the ghc package is broken, but I'm not sure how to unbreak it. 
15:24:12 <kmc> which absorbs a lot of the traditional uses cases of CPS
15:24:20 <kmc> (or of continuations generally)
15:24:29 <edlinde> Cale: I am trying to understand how  indexPermutation [2,0,0] "Cat"
15:24:29 <edlinde> "tCa" works
15:24:45 <aristid> > select "Cat"
15:24:46 <lambdabot>   [('C',"at"),('a',"Ct"),('t',"Ca")]
15:24:46 <edlinde> so "t" is index = 2 in original string
15:24:55 <aristid> > select "Cat" !! 2
15:24:56 <lambdabot>   ('t',"Ca")
15:25:32 <edlinde> so whats the 0, 0 for?
15:25:52 <Cale> edlinde: Choosing the index 0 element from "Ca" -> ('C',"a")
15:26:05 <Cale> and then choosing the index 0 element from "a" -> ('a',"")
15:26:11 <xplat> 0 is the initial element of whatever's left
15:26:36 <edlinde> oh i see
15:26:49 <edlinde> my brains stopped working
15:26:50 <edlinde> :(
15:26:55 <xplat> indexPermutation makes a tradeoff where it's harder to see what the permutation does but easier to see if it's valid :)
15:26:57 <edlinde> ok I see but
15:27:04 <Cale> > map (\ns -> indexPermutation ns "Cat") [[0,0,0],[1,0,0],[2,0,0],[0,1,0],[1,1,0],[2,1,0]]
15:27:05 <lambdabot>   ["Cat","aCt","tCa","Cta","atC","taC"]
15:27:51 <edlinde> ok
15:28:05 <aristid> Cale: have you seen my slight tweak of indexPermutation that lets you skip trailing zeros?
15:28:35 <edlinde> Cale: so I get this part now... what needs to happen next?
15:28:37 <Cale> aristid: I didn't see it, but I can imagine what it is :)
15:28:47 <edlinde> in association with the random generator's list
15:28:54 <Cale> edlinde: We just need to take our list of random numbers and get it into the required form
15:28:55 <aristid> Cale: indexPermutation [] xs = xs
15:29:00 <Cale> aristid: yes
15:29:19 <aristid> Cale: did you deliberately not do that?
15:29:21 <edlinde> Cale: also can this "indexPermutation" be done purely as a list comprehension?
15:29:27 <Cale> aristid: Somewhat deliberately
15:29:37 <Cale> aristid: It doesn't matter in this application though
15:29:57 <Cale> edlinde: I don't think so.
15:30:10 <edlinde> I have seen something somewhere that does it
15:30:15 <edlinde> gimme 2 mins plz
15:32:19 <edlinde> found it
15:32:20 <edlinde> perms [] = [[]]
15:32:20 <edlinde> perms xs = [ x: ps | x <- xs, ps <- perms( xs \\ [x])]
15:32:34 <edlinde> *Main> perms "Cat"
15:32:35 <edlinde> ["Cat","Cta","aCt","atC","tCa","taC"]
15:32:35 <augur> kmc: :|
15:32:53 <edlinde> Cale: is that doing basically the same thing?
15:33:15 <Cale> edlinde: No, that's actually a really bad implementation of perms, because it relies on Eq
15:33:29 <Cale> We can write a better one using select
15:33:33 <edlinde> okie
15:33:46 <edlinde> plus I suppose that one doesn't use indexes too
15:33:51 <edlinde> like the split you did
15:34:09 <Cale> perms [] = [[]]; perms xs = [y : ps | (y,ys) <- select xs, ps <- perms ys]
15:34:13 <Cale> @let perms [] = [[]]; perms xs = [y : ps | (y,ys) <- select xs, ps <- perms ys]
15:34:14 <lambdabot>  Defined.
15:34:19 <Cale> perms "Cat"
15:34:20 <Cale> > perms "Cat"
15:34:21 <lambdabot>   ["Cat","Cta","aCt","atC","tCa","taC"]
15:34:27 <Cale> :t perms
15:34:28 <lambdabot> forall a. [a] -> [[a]]
15:34:42 <Cale> ^^ no Eq constraint, and no bug where the input list contains duplicates
15:35:00 <lars9> @hoogle focus
15:35:01 <lambdabot> No results found
15:35:03 <edlinde> ok so you suggest I use the last one?
15:35:06 <edlinde> or?
15:35:16 <kwos> what is the best data structure for efficiently storing large amount of data (essentially n-tuples of ints and doubles)? array? vector? what's a good alternative to list?
15:35:20 <djahandarie> You can just use the one in Data.List if you need one
15:35:24 <djahandarie> :t permutations
15:35:25 <lambdabot> forall a. [a] -> [[a]]
15:35:28 <Cale> Yeah, or just use the permutations function from Data.List
15:35:49 <edlinde> ok
15:36:08 <Philonous> :t select
15:36:09 <lambdabot> forall t. [t] -> [(t, [t])]
15:36:24 <edlinde> what needs to happen next?
15:36:55 <Cale> Not much, we just need to coerce our list of random numbers such that it's a valid input to indexPermutation
15:37:14 <edlinde> hmm
15:37:24 <Cale> So, reverse (zipWith mod rs [0..])
15:37:30 <Cale> well...
15:37:31 <hpc> :t (<<<)
15:37:32 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
15:37:41 <Cale> So, reverse . take n . zipWith mod rs $ [0..]
15:37:41 <edlinde> whats mod rs?
15:37:44 <hpc> :t uncurry (:) . select
15:37:45 <lambdabot>     Couldn't match expected type `(a, [a])'
15:37:45 <lambdabot>            against inferred type `[(t, [t])]'
15:37:45 <lambdabot>       Expected type: [t] -> (a, [a])
15:37:55 <Cale> Where rs = randoms g :: [Integer], say
15:38:01 <hpc> :t map (uncurry (:)) . select
15:38:02 <lambdabot> forall a. [a] -> [[a]]
15:38:06 <Cale> and g :: StdGen
15:38:18 <edlinde> Cale:  so you saying in my case rs is the list of random numbers yeah?
15:38:25 <Cale> yes
15:38:28 <edlinde> ok
15:38:53 <aristid> @index select
15:38:53 <lambdabot> Text.Html
15:38:58 <Cale> mod is just the function which gives the remainder after division
15:38:59 <aristid> @hoogle select
15:38:59 <lambdabot> Text.Html select :: Html -> Html
15:39:00 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
15:39:00 <lambdabot> Text.XHtml.Strict select :: Html -> Html
15:39:03 <edlinde> Cale: I am trying to understand your expression
15:39:07 <aristid> Cale: where is select from?
15:39:13 <Cale> aristid: I defined it above
15:39:14 <edlinde> reverse . take n . zipWith mod rs $ [0..]
15:39:19 * hackagebot hsXenCtrl 0.2.0 - FFI bindings to the Xen Control library.  http://hackage.haskell.org/package/hsXenCtrl-0.2.0 (ThomasDuBuisson)
15:39:36 <edlinde> Cale: I know zipWith will make a list of pairs 
15:39:43 <Cale> No
15:39:47 <edlinde> no?
15:39:58 <edlinde> ah thats just zip
15:40:13 <Cale> zipWith f xs ys = map (uncurry f) (zip xs ys)
15:40:15 <Cale> Or:
15:40:25 <Cale> zip = zipWith (,)
15:40:30 <c_wraith> > let interleave x [] = [[x]] ; interleave x (y:ys) = (x : y : ys) : [y : zs | zs <- interleave x ys] ; perms [] = [[]] ; perms (x:xs) = concatMap (interleave x) (perms xs) in perms [1..3]
15:40:31 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
15:40:48 <edlinde> Cale I see now
15:41:03 <c_wraith> That definition of perms was faster than Data.List.Permutations last time I checked.
15:41:27 <c_wraith> And neither have a nice lexicographic ordering property
15:41:43 <Cale> > let interleave x [] = [[x]] ; interleave x (y:ys) = (x : y : ys) : [y : zs | zs <- interleave x ys] ; perms [] = [[]] ; perms (x:xs) = concatMap (interleave x) (perms xs) in map (take 3) (perms [1..])
15:41:44 <lambdabot>   *Exception: stack overflow
15:41:55 <Cale> > map (take 3) (permutations [1..])
15:41:56 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4...
15:42:17 <c_wraith> Ah.  cute.
15:42:36 <c_wraith> That's why they used such a complicated implementation
15:43:08 <edlinde> Cale: 
15:43:10 <edlinde> *Main> reverse . take 10 . zipWith mod (randomsequence 7905 100) $ [0..]
15:43:10 <edlinde> [7,5,4,4,4,2,1,1,0,*** Exception: divide by zero
15:43:19 <edlinde> I was just trying it out
15:43:22 <Cale> Yeah, it was the fastest implementation which handled infinite lists
15:43:25 <augur> can anyone link to a definition for IdentityT?
15:43:33 <knobo> Any real world programs that uses stm, and kicks ass because of it?
15:43:50 <Eigen> Is anyone familiar with career opportunities relating to / working with haskell?
15:43:57 <edlinde> Cale: so what went wrong in that test I was doing?
15:44:15 <Cale> knobo: I'm sure there are, but I don't know of which open source projects are using STM off-hand.
15:44:38 <Cale> edlinde: [1..], not [0..]
15:44:44 <edlinde> Cale: ah ok
15:44:47 <Cale> edlinde: Modding out by 0 doesn't work
15:44:58 <Cale> (taking the remainder after division by 0 doesn't make sense ;)
15:45:01 <edlinde> yep gotcha
15:45:04 <augur> bah. im off
15:45:05 <edlinde> hehe yeah
15:45:51 <user88> Hello guys, I have a small question. I am trying out parser combinators. Uhm but I am having a little bit trouble of accessing my stuff after I have parsed them. Parser a b, is actually [a] -> [(b, [a])]. In my case I am using Char as a and Int as b, now my question is, let's say I have the type of this [(b, [])] meaning I have parsed everything (there can be multiple parses [(b, []), (b', 
15:45:51 <user88> [])]. How do I actually get my "b"? (Without writing head and fst functions or writing functions that act as such) 
15:45:51 <Cale> Eigen: That's an excellent question... there are some employers which hang around in here...
15:46:09 <Cale> Eigen: I don't know if we have any more positions available at iPwn at the moment.
15:46:14 <Cale> (I'm using Haskell for work)
15:46:36 <c_wraith> JanRain is still hiring for engineers.  (that's where I work, and yes, we do haskell work)
15:46:43 <Cale> user88: Pattern matching?
15:46:51 <edlinde> Cale: will try and complete the rest and give it a shot
15:46:53 <edlinde> hope it works now
15:46:54 <user88> yes but that's what head and fst do to right?
15:47:00 <Cale> user88: Or map fst, and then do stuff?
15:47:02 <aristid> :t sum .: zipWith (*)
15:47:03 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
15:47:07 <user88> like (b, _):rest
15:47:14 <user88> and then match that you mean right?
15:47:26 <Twey> user88: Your parser combinator library should provide access functions, runParser or so.  The fact that they're represented internally as [(b, [a])] probably shouldn't be exposed.  If abstractions are not offered, fmap fst . listToMaybe is the way to go.
15:47:46 <user88> fmap fst... let's see
15:47:48 <c_wraith> knobo: the GHC implementation of STM has some issues that make the real-world use cases it is well-suited to *very* narrow.
15:47:59 <Twey> :t listToMaybe
15:47:59 <lambdabot> forall a. [a] -> Maybe a
15:48:02 <Twey> :t fmap fst
15:48:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f a
15:48:04 <user88> oh icic
15:48:07 <Cale> c_wraith: I'm not sure I'd say that :)
15:48:07 <Twey> :t fmap fst . listToMaybe
15:48:08 <lambdabot> forall a b. [(a, b)] -> Maybe a
15:48:23 <c_wraith> knobo: in particular, optimistic locking causes very poor performance under high contention, so you need a use case with low contention.
15:48:28 <user88> fmap fst, why can't I use just map?
15:48:58 <Saizan> :t map fst . listToMaybe
15:48:59 <lambdabot>     Couldn't match expected type `[(a, b)]'
15:48:59 <lambdabot>            against inferred type `Maybe a1'
15:48:59 <lambdabot>       Expected type: [a1] -> [(a, b)]
15:49:05 <Cale> c_wraith: The implementation of STM in GHC is quite good. It's not a silver bullet for concurrency, but it's a reasonably good substrate on which to build more abstractions.
15:49:16 <Twey> user88: Because it's over Maybe, not over lists
15:49:22 * hackagebot parallel-io 0.2.1 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.2.1 (MaxBolingbroke)
15:49:25 <Twey> user88: map only works for lists; fmap is more general
15:49:25 <user88> icic
15:49:33 <aristid> :t indexPerm
15:49:33 <user88> icic
15:49:33 <lambdabot> Not in scope: `indexPerm'
15:49:34 <Twey> You could do it the other way around
15:49:41 <Twey> listToMaybe . map fst
15:49:48 <Twey> It doesn't make a huge amount of difference
15:49:50 <mtnviewmark> user88: are you using Parsec? If so:    runParser and parse
15:50:05 <aristid> :t indexPermutation
15:50:05 <lambdabot> forall a. [Int] -> [a] -> [a]
15:50:11 <user88> I'm using this http://www.cs.uu.nl/docs/vakken/b3tc/dist/doc/html/uu-tc/index.html
15:50:21 <c_wraith> Cale: it's fine under low contention, but it just falls over under high contention.  having every thread retry simultaneously on bad transactions leads to the system completely falling over.
15:50:34 <user88> I am not taking that course though =(, because it was full...
15:50:55 <user88> therefore I might lack some deep understanding about it
15:51:12 <aristid> @let indexPerm n xs = permutations xs !! (sum . zipWith (*) [0,1..] . reverse) n
15:51:13 <lambdabot>  Defined.
15:51:24 <user88> I don't see a function that actually does like runParser
15:51:34 <Cale> c_wraith: Well, you keep transactions small, and have them operate on immutable datastructures, and it works reasonably well.
15:51:47 <Twey> Ah, okay… your runParser gives you the [(r, [s])]
15:51:48 <mtnviewmark> user88: parse in ParseLib.Abstract.Core is all they've got, eh?
15:51:52 <c_wraith> Cale: the net result of that is that you want to use it in cases where there are many TVars in play, and most transactions are on small subsets of TVars
15:52:02 <user88> yes
15:52:04 <aristid> Cale: this is probably the least reasonable method to get a specific permutation :D
15:52:17 <Twey> Odd design, but I guess I understand
15:52:22 <mjrosenb> what is the difference between mod and rem again?
15:52:25 <Twey> listToMaybe or case it
15:52:47 <Twey> > negate 6 `mod` negate 5
15:52:48 <lambdabot>   -1
15:52:51 <Twey> > negate 6 `rem` negate 5
15:52:52 <lambdabot>   -1
15:52:56 <Twey> Not that.
15:52:56 <c_wraith> Cale: I've got plenty of experience with this.  Switching an immutable structure stored in a a TVar to an immutable structure stored in an MVar lead to a HUGE speedups under load.
15:52:58 <Twey> :þ
15:53:01 <user88> Twey: why should I want to use maybe and not just give an error like error "Cannot be parsed"?
15:53:04 <c_wraith> err, *led
15:53:04 <Twey> > negate 6 `quot` negate 5
15:53:05 <lambdabot>   1
15:53:13 <Twey> user88: Nobody's stopping you
15:53:37 <Twey> user88: fromMaybe (error "Cannot be parsed") . fmap fst . listToMaybe
15:53:42 <c_wraith> like, the runtime never fell over with an mvar, because it never woke up all the threads simultaneously when the mvar was filled again.
15:53:48 <mtnviewmark> firstParser = fmap fst . listToMaybe . parse
15:54:06 <Twey> user88: But we don't generally like ‘error’ for user errors — it's (theoretically) uncatchable, so it's meant for programmer errors that should never occur in normal operation
15:54:25 <user88> Oh icic
15:54:46 <user88> Now I wonder which module I should import to get listToMaybe?
15:55:02 <user88> my GHCI doesn't recognize it =(
15:55:07 <Twey> user88: (more directly, you can define a combinator list d _ [] = d; list _ f (x : xs) = f x xs; and write fst . list (error "Cannot be parsed") const)
15:55:12 <Twey> user88: Data.Maybe
15:55:34 <user88> oh thanks!
15:55:48 <user88> let me try my own implementation (no fun copying you guys :P)
15:55:58 <mtnviewmark> Data.Maybe has some lovely nice helper functions
15:56:19 <mtnviewmark> worth learning 'em, user88
15:57:26 <user88> oh one small question, if I give this to a friend or someone else and he wants to run it. Does he needs to download Data.Maybe or is it just standard in the Haskell Platform?
15:58:01 <Twey> user88: It's standard with GHC
15:58:04 <monochrom> if you send an executable, that's it. ghc libs code are normally statically linked.
15:58:09 <user88> oh cool!
15:58:14 <Twey> That too
15:58:30 <monochrom> so be prepared to send a 10MB executable
15:58:47 <edlinde> Cale: you still around
15:59:06 <edlinde> Cale: I am done but I noticed that changing the random list.... doesn't seem to change the permutation
15:59:19 <edlinde> it always comes up with the same permutation
16:00:22 <Eigen> c_wraith: What kind of work do you do?
16:00:40 <ousado_> edlinde: maybe you have to seed the rng?
16:00:57 <edlinde> the rng is fine
16:01:04 <edlinde> its getting new vals all the time
16:01:14 <ousado_> ah ok
16:01:19 <ousado_> blind shot
16:01:24 <benmachine> dcoutts_: am I allowed to close bugs on the cabal trac, or should only developers do that? (e.g. invalid bugs)
16:01:35 <edlinde> Cale: http://ideone.com/p4Aby
16:02:00 <dcoutts_> benmachine: yep, just use your judgement
16:02:08 <benmachine> ok cool
16:02:17 <user88> actually the listToMaybe function isn't really that great I think, I can create it too...  myVersion :: [a] -> Maybe a;
16:02:17 <user88>     myVersion (a:_) = Just a;
16:02:17 <user88>     myVersion _ = Nothing;
16:02:35 <Eigen> Cale: What does iPwn do?
16:04:05 <monochrom> I have an executable that uses gtk2hs (our gtk binding) and multi-threading. It's 14MB before stripping.
16:04:18 <monochrom> 6.8MB after stripping.
16:04:53 <dcoutts_> shared libs ftw!
16:05:22 <monochrom> yeah, shared libs require the recipient to install ghc
16:05:28 <dcoutts_> not that it reduces the amount you'd need to ship, since you'd have to ship shared libs too
16:05:52 <dcoutts_> monochrom: they wouldn't, but you would need to ship the appropriate libs, so it's not a clear win
16:06:56 <dcoutts_> it's a win if you have several executables you need to ship that share the same libs
16:07:52 <monochrom> furthermore since ghc abi is fragile, you cannot just suggest the recipient to "apt-get install ghc libghc6-xxx-dev" unless you built your exe against exactly them.
16:08:52 <monochrom> it is a win if you use the ghc-api.
16:09:39 <monochrom> wait, last time I tried, something broke when I used ghc-api and -dynamic my exe
16:15:20 <Phyx-> grrrr
16:15:24 <Phyx-> why is cabal suddenly failing
16:15:53 <Phyx-> http://phyx.pastebin.com/5zRNHXNM
16:17:07 <dcoutts_> Phyx-: what command did you run?
16:17:51 <Phyx-> dcoutts_: cabal install
16:18:02 <Phyx-> on cabal inself
16:18:23 <dcoutts_> Phyx-: using --enable-tests ?
16:18:38 <Phyx-> no, with no args
16:19:14 <dcoutts_> Phyx-: have you added a dependency on quickcheck?
16:19:48 <Phyx-> no, I haven't added any dependencies, In test I only removed unix,
16:20:20 <Phyx-> it was working fine, then i just unregistered it, went to build it again it refused with that error
16:21:02 <dcoutts_> Phyx-: can you post cabal install --dry-run -v
16:21:18 * dcoutts_ suspects its pulling in a dependency on quickcheck
16:21:45 <dcoutts_> Phyx-: are you using stable cabal program, or darcs version?
16:21:51 <Phyx-> dcoutts_: http://phyx.pastebin.com/nCc5MmcB
16:22:07 <Phyx-> dcoutts_: an older darcs version
16:22:17 <revenantphx> So, jmcarthur.
16:22:20 <Phyx-> dcoutts_: it could be, it recently did install the dependencies for "tests"
16:22:27 <revenantphx> Looking at BinaryProtocol, it's relatively simple so...
16:22:38 <revenantphx> maybe i should rewrite it, adding an AmityProtocol to it's state tuple?
16:22:54 <revenantphx> So make a modified version which works easily for me.
16:23:10 <dcoutts_> Phyx-: so it's certainly pulling in the dependencies of the test-suite, but it's not clear why
16:23:18 <augur> ugh
16:23:30 <augur> what is the definition of IdentityT :|
16:23:40 <dcoutts_> Phyx-: you don't have enable tests set in your config file? does --disable-tests make any difference?
16:23:52 <Phyx-> dcoutts_: well, the odd thing is, when i did cabal isntall outside the tests folder, it also tried to build the tests
16:24:26 <dcoutts_> Phyx-: I think we must not have taught cabal-install about enabling/disabling tests, so it's pulling in all the deps
16:24:31 <Phyx-> dcoutts_: no, same thing happened with the flag
16:25:08 <Phyx-> dcoutts_: doing cabal configure; cabal build; seems to be working
16:25:16 <augur> anytone?
16:25:17 <Phyx-> so it's something install does
16:25:17 <dcoutts_> Phyx-: and the problem in this case is that quickcheck depends on the ghc package
16:25:20 <augur> does ANYONE know?
16:25:29 <dcoutts_> Phyx-: does it not warn during configure?
16:25:41 <Phyx-> dcoutts_: nope, just configures and builds, no warnings
16:26:05 <dcoutts_> Phyx-: does it warn if you do cabal configure --enable-tests ?
16:26:29 <sipa> augur: http://hackage.haskell.org/packages/archive/transformers/0.2.1.0/doc/html/src/Control-Monad-Trans-Identity.html#IdentityT ?
16:26:35 <augur> aha!
16:26:37 <augur> thank you :)
16:26:43 <sipa> newtype IdentityT m a = IdentityT { runIdentityT :: m a }
16:26:53 <Phyx-> dcoutts_: then it gives me another error, that the unix dependency is missing. odd I thought I removed that
16:27:00 <augur> nah i mean for the monad stuff, sipa. but it has that, so
16:27:23 <dcoutts_> Phyx-: so the problem is that cabal-install's dep resolver does not know about enabling/disabling tests
16:27:27 <Phyx-> ah, it's in the main Cabal.cabal file aswell
16:27:49 <dcoutts_> Phyx-: combined with the fact that older QC versions depend on the ghc api package (since fixed)
16:27:55 <Phyx-> dcoutts_: removing the unix dependency cabal configure --enable-tests works too
16:28:07 <dcoutts_> Phyx-: what's wrong with the unix dep?
16:28:13 <EvanCarroll> how do i get the type of `fmap` for a specific instance?
16:28:14 <Phyx-> dcoutts_: i'm on windows
16:28:36 <dcoutts_> Phyx-: oh but in Cabal.cabal it's guarded by !os(windows)
16:28:49 <Phyx-> dcoutts_: but --enable-tests bypasses that
16:28:54 <Phyx-> it's lower down
16:29:00 <Phyx-> under test-suite unit-tests
16:29:03 <Phyx-> it's also mentioned
16:29:11 <dcoutts_> Phyx-: right, yes, that's the one you emailed about
16:29:22 <dcoutts_> which is quite unnecessary
16:30:02 <Phyx-> well, the module PackageTests.PackageTester does have code there that uses createProcess
16:30:11 <Phyx-> so I just uncommented it
16:30:17 <Phyx-> and commented the createPipe calls
16:30:32 <Cloe> can anyone tell me if its possible to play audio from ghc. i have tried using the function getWAVEFile from the following library, but could not hear anything http://hackage.haskell.org/packages/archive/WAVE/0.1.1/doc/html/Data-WAVE.html
16:31:26 <Phyx-> dcoutts_: is there a difference between the configure that cabal install does and just cabal configure?
16:31:36 <Cale> Cloe: It is possible, but GHC itself includes no audio code. That library only implements the reading of the wave file format.
16:32:03 <Cale> Cloe: You'll want something like SDL-Mixer to play audio.
16:32:06 <revenantphx> jmcarthur: I'm just seeing that BinaryProtocol is kind of a general case of something easy to do (lazy IO) which is restricting my options a bit.
16:32:21 <dcoutts_> Phyx-: yes, cabal configure tries using the constraint solver, if that fails it tries something stupid
16:32:43 <dcoutts_> Phyx-: in the case of install, there's no second stupid option if the solver fails
16:32:55 <dcoutts_> there are no stupid defaults that you can just try
16:33:41 <Phyx-> dcoutts_: it seems that cabal install is selecting the cabal package it's trying to build as the cabal to use, and not an already build one
16:34:09 <Cloe> Cale: so should i try using another library for playback in combination with the getWAVEFile function, or is this function of little use?
16:34:19 <dcoutts_> Phyx-: I'm not sure I follow
16:35:00 <Phyx-> dcoutts_: well, i'm trying to build Cabal 1.11.1, it doesn't exist yet in ghc-pkg list,
16:35:08 <Phyx-> dcoutts_: but the error it reports is "Cabal-1.8.0.2 was excluded because Cabal-1.11.1 was selected instead"
16:35:13 <Cale> Cloe: I think SDL-mixer implements reading of various file formats as well. That library is probably not so convenient unless you just want to process audio on disk.
16:35:27 <dcoutts_> Phyx-: right, as we expect
16:35:46 <benmachine> Phyx-: it's trying to build an install plan for Cabal-1.11.1, surely
16:36:00 <Phyx-> oh ok, I read the error wrong then
16:36:54 <Cale> Cloe: To be honest though, I haven't done much audio stuff in Haskell.
16:36:58 <Cloe> Cale: thanks I'll give that a try.
16:37:19 <byorgey> Cloe: what is it you're trying to do?
16:37:45 <Cale> byorgey: Load and play audio files from ghci
16:38:18 <byorgey> yes, but for what purpose?
16:38:29 <djahandarie> Oh god, talk about confusing names
16:38:42 <byorgey> surely if all one wants to do is play audio files there are better ways to do it ;)
16:38:44 <djahandarie> I thought Cale was talking to himself for a second there
16:38:56 <Phyx-> djahandarie: it's been known to happen...
16:39:24 <djahandarie> djahandarie, I bet only crazy people talk to themselves
16:39:38 <Phyx-> djahandarie: and Haskell programmers..
16:39:56 <benmachine> Phyx-: covered by the above, no? :P
16:40:02 <jmcarthur> revenantphx: why change it when you can just use StateT?
16:40:21 <revenantphx> jmcarthur: To add state.
16:40:28 <Phyx-> benmachine: just stating it explicitly :P
16:40:35 <revenantphx> Or are you saying I should layer on another StateT?
16:40:40 <jmcarthur> revenantphx: but... that's what StateT does
16:40:43 <jmcarthur> yeah
16:41:21 <revenantphx> I'm wondering how this would work..
16:41:23 <revenantphx> type BinaryProtocol = StateT (Handle,Handle,L.ByteString) IO
16:41:25 <Cale> Is it just me, or is Hackage being a little slow and flaky right now? (It's working, but documentation pages are taking a long time to come up for me)
16:41:26 <revenantphx> so I could do...
16:41:37 <revenantphx> type MyBinaryProtocol = StateT AmityState BinaryProtocol
16:41:43 <revenantphx> does that sounds right?
16:41:57 <jmcarthur> honestly, i don't think BinaryProtocol should even be a type alias like that
16:42:03 <jmcarthur> but whatever
16:42:08 <revenantphx> One of the reasons I wanted to redo it.
16:42:09 <jmcarthur> it should be a newtype
16:42:10 <EvanCarroll> I'm trying to learn more about the type system, and applicatives, how do i do something useful with (+) <$> Just (+ 5) 
16:42:18 <revenantphx> Yeah, in my redo i newtyped it.
16:42:30 <EvanCarroll> that returnsa type of (Num (a -> a), Num a) => Maybe ((a -> a) -> a -> a)
16:42:31 <jmcarthur> ah
16:42:33 <Cale> I think BinaryProtocol shouldn't even be a monad.
16:43:06 <Phyx-> dcoutts_: the old fashion, .\Setup.exe configure --user; .\Setup.exe build; .\Setup.exe install seems to have worked
16:43:23 <aavogt> revenantphx: are type definitions allowed to be pointfree like that?
16:43:36 <revenantphx> aavogt: well "type BinaryProtocol = StateT (Handle,Handle,L.ByteString) IO" works
16:43:39 * hackagebot text 0.11.0.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.1 (BryanOSullivan)
16:43:47 <dcoutts_> Phyx-: right, because again it's using the simple stupid method, and not pulling in the test suite deps, so ends up working
16:43:54 <revenantphx> How are there even any points?
16:44:09 <jmcarthur> aavogt: yes
16:44:33 <jmcarthur> revenantphx: he means as opposed to  type BinaryProtocol a = StateT (Handle,Handle,L.ByteString) IO a
16:44:37 <aavogt> revenantphx: exactly why it's pointfree. There should be a type variable there
16:44:38 <jmcarthur> i think
16:44:43 <revenantphx> Oh.
16:44:53 <jmcarthur> but it *is* allowed to be pointfree
16:44:58 <Phyx-> dcoutts_: heheeh :) guess your first guess was right, install doesn't know about disabling/enabling the tests
16:45:05 <revenantphx> So jmcarthur 
16:45:07 <revenantphx> jmcarthur: So what I was thinking is makin
16:45:10 <revenantphx> http://hackage.haskell.org/packages/archive/binary-protocol/1.0/doc/html/src/Control-Monad-BinaryProtocol.html#BinaryProtocol
16:45:31 <revenantphx> I'm thinking of just reimplementing this with a modified state tuple, to also contain my program state.
16:45:40 <jmcarthur> but why?
16:45:49 <revenantphx> Because then I don't have to additionally do more lifting.
16:46:02 <revenantphx> If I stack another stateT on, every line except one will have to be lifted.
16:46:13 <revenantphx> (that one being mystate <- get)
16:46:21 <jmcarthur> all you have to do is implement some reasonable functions to get at the state in one place
16:46:32 <revenantphx> ?...
16:46:32 <lambdabot> Not enough arguments to @.
16:46:40 <jmcarthur> it's not a good idea to use lift everywhere. it's better to wrap it in more meaningful functions
16:46:59 <jmcarthur> revenantphx: like getGameState, etc.
16:47:09 <revenantphx> getGateState woudn't have to be lifted though.
16:47:15 <jmcarthur> right
16:47:16 <revenantphx> It's at the top level (my StateT)
16:47:21 <jmcarthur> oh
16:47:21 <revenantphx> but *everything else* does.
16:47:22 <hpc> yeah, lift is really annoying to throw around everywhere
16:47:40 <revenantphx> jmcarthur: could I import BinaryProtocol's send as send' and then do send = liftM . send'
16:47:41 * hackagebot multiplate 0.0.1.1 - Lightweight generic library for mutually recursive data types.  http://hackage.haskell.org/package/multiplate-0.0.1.1 (RussellOConnor)
16:47:44 <revenantphx> And so on for those?
16:47:49 <revenantphx> I feel that would be cleaner, but a bit confusing.
16:48:13 <roconnor> Multiplate: now with laws!
16:48:19 <Phyx-> dcoutts_: another question, how does an unconstrained dependency get resolved. E.g. the test cabal file just mentions requiring "Cabal" but when I try building, the Oldest cabal is selected 1.8
16:48:19 <jmcarthur> revenantphx: monads that are likely to be transformed like this should really have type classes as their interfaces...
16:48:37 <revenantphx> jmcarthur what do you mean
16:48:39 <jmcarthur> revenantphx: this BinaryProtocol things really seems pointless to me
16:48:46 <jmcarthur> revenantphx: look at how mtl does it
16:48:58 <Phyx-> dcoutts_: or is that due to ghc's dependence on 1.8.0.2?
16:49:04 <revenantphx> Which is why I'm consdiering just ditching it and implementing a lazy IO that is similar that does *exactly what I want*
16:49:09 <jmcarthur> revenantphx: all the monads in mtl have type classes so that you can use monads even very deep in a stack without lift
16:49:52 <revenantphx> so wait, how does having the typeclasses work?
16:50:05 <dcoutts_> Phyx-: if it's genuinely unconstrained then it either picks the installed version, or the latest one
16:50:35 <jmcarthur> revenantphx: if BinaryProtocol had a MonadBinaryProtocol type class then you could just instantiate it for your state wrapper and be good
16:50:43 * hackagebot matrix-market-pure 0.1 - Pure and composable reader and writer of the Matrix Market format.  http://hackage.haskell.org/package/matrix-market-pure-0.1 (SergeyAstanin)
16:50:46 <dcoutts_> Phyx-: but yes, if something else requires an older Cabal then it has to pick the older one
16:50:47 <revenantphx> jmcarthur: Oh I see.
16:50:50 <jmcarthur> revenantphx: or could even have a predefined instance for StateT and you'd have no extra work at all
16:51:05 <revenantphx> jmcarthur: to be honest, reimplementing this monad seems to be the best option in multiple ways.
16:51:14 <Cale> I'd probably go with just making a datastructure which contains the information needed to continue parsing. In your case, it's really just a string. (and sure, an output handle too...)
16:51:17 <jmcarthur> revenantphx: you could make this type class without reimplementing the whole thing
16:51:18 <revenantphx> Consistently my issue is "because binary protocol..."
16:51:53 <jmcarthur> i may disagree with you using it, but if you're going to use it you might as well just use it and not rewrite it :)
16:52:13 <revenantphx> I mean, all it is is, is very simple lazy io.
16:52:20 <revenantphx> It's not something hard to implement by any means, 20 lines ish
16:52:23 <jmcarthur> lazy IO is never simple
16:52:27 <Cale> yeah
16:52:37 <revenantphx> Well, the amount of code and how it's done is simple.
16:52:39 <Cale> and you're just making life hard for yourself with this monad, I think :)
16:52:45 <jmcarthur> yeah, deceptively
16:52:47 <revenantphx> Cale: and what would you recommend :|
16:52:52 <jmcarthur> revenantphx: strict IO
16:53:10 <jmcarthur> revenantphx: or iteratee/enumerator if you want lazy-ish style
16:53:11 <Cale> I wouldn't necessarily use strict IO here
16:53:16 <Cale> But it doesn't matter
16:53:18 <revenantphx> The problem there is I run into the issues I originally had in other languages.
16:53:19 <Phyx-> dcoutts_: ah ok, it seems to be the quickcheck version again, it seems to be forcing the dependency to ghc, which inturns makes it pick cabal 1.8 and the test suite then fails to compile
16:53:26 <jmcarthur> what issues?
16:53:39 <Cale> Something more like:   receive :: (Binary a) => Port -> IO a
16:53:49 <Cale> Where Port is a datastructure containing the information which you're using.
16:53:52 <revenantphx> Um, namely that some of the packets are retarded and you cannot know their length until you've finished parsing them?
16:54:11 <jmcarthur> binary is pretty stupid :(
16:54:13 <Cale> (Maybe an IORef with a lazy String in it, and some handles)
16:54:25 <revenantphx> Cale, this is what binary protocol does http://hackage.haskell.org/packages/archive/binary-protocol/1.0/doc/html/src/Control-Monad-BinaryProtocol.html#BinaryProtocol
16:54:30 <Cale> Or maybe use cereal instead :)
16:54:39 <Cale> Right, I know, I read the code :)
16:54:47 <revenantphx> Cale: whee, rewrite my entire list of packet definitions.
16:54:53 <Cale> But you don't need a monad, you're just passing parameters around.
16:54:59 <jmcarthur> does cereal at least give you a total function for deserialization?
16:55:14 <Cale> It's really a lot less hassle to pass around one value than it is to use liftIO everywhere.
16:55:18 <jmcarthur> or is it incremental even?
16:55:20 <Cale> jmcarthur: yeah
16:55:23 <jmcarthur> i don't remember... anything about it
16:56:05 <jmcarthur> do we have an incremental binary library anywhere? that would be the best
16:56:24 <Cale> Meh, you don't need incremental parsing for this :)
16:56:38 <jmcarthur> heh
16:56:58 <Cale> But it would be better to have cereal's error handling.
16:57:03 <jmcarthur> much
16:57:16 <revenantphx> Hrmm
16:57:37 <jmcarthur> i remember cereal now. basically binary without the assumption of correct input
16:57:48 <jmcarthur> ah, and strict bytestrings
16:58:30 <Cale> ah, that aspect might be mildly annoying
16:58:49 <revenantphx> mm
16:58:59 <Cale> Yeah, so maybe stick with Binary, since you want lazy bytestrings.
16:59:45 <revenantphx> so then Cale, how would you suggest either a) supplanting binary protocol, b) modifying it, c) doing typeclass stuff i don't quite understand.
16:59:56 <revenantphx> I'm looking at the typeclass for Reader and such in mtl
17:00:01 * mjrosenb has a puzzle; i've already solved it, but I am wondering if there is a better solution
17:00:16 <jmcarthur> i thnk cale's advice is fine. just implement a read and write function on your own in IO
17:00:16 <EvanCarroll> @src id
17:00:17 <lambdabot> id x = x
17:00:55 <jmcarthur> there is no perfect way, unfortunately
17:00:57 <mjrosenb> write a function myWords :: String -> [String] that acts like words, but supports bash-like quoting with just the character "'"
17:01:28 <Cale> Iteratee is maybe technically the "right" way, but at the same time, I think it's ridiculous :)
17:01:40 <Twey> Why ridiculous?
17:01:41 <revenantphx> I remember last night someone saying iteratee would be impossible for this.
17:01:49 <revenantphx> Due to the lack of being able to know the length.
17:01:51 <jmcarthur> mjrosenb: so "foo 'bar baz' wibble" => ["foo", "bar baz", "wibble"]?
17:02:01 <jmcarthur> revenantphx: umm... that's just binary sucking
17:02:06 <revenantphx> :P
17:02:09 <Cale> revenantphx: That's exactly what iteratee is for
17:02:11 <jmcarthur> cereal would be much better in that regard
17:02:16 <revenantphx> how does iteratee work ?
17:02:58 <jmcarthur> i hear enumerator is at least a bit simpler to use than iteratee, albeit still kind of overly complicated
17:03:24 <mjrosenb> jmcarthur: yes, 
17:03:54 <mjrosenb> jmcarthur: the annoying bit (for me) was "foo '' bar" -> ["foo", "", "bar"]
17:04:08 * mjrosenb was not able to do it without using two bits of state
17:05:09 <mjrosenb> whoops :(
17:05:12 <revenantphx> Cale: okay then, so how would I do my own read/write here? I'm afraid I'm a bit biased by binaryprotocol.
17:05:32 <revenantphx> I'd dread having to rewrite all of my packet definitions though :\... but oh well.
17:05:39 <mjrosenb> why is the internet connection in my apartment doing that :(
17:06:25 <Cale> revenantphx: Okay, so we'll just this the lazy way. Let's mimic the way that BinaryProtocol works internally, but make use of the fact that we're in the IO monad, and so have IORefs.
17:06:31 <monochrom> because it is not written in haskell
17:07:06 <revenantphx> Cale: so hGetContents and then block on extracting data from that?
17:07:18 <revenantphx> That seems to be the common pattern in lazy IO...
17:07:31 <jmcarthur> revenantphx: weren't you also needing to send a keepalive or something?
17:07:36 <Cale> yes, that's what we'll do. We'll put that lazy bytestring into an IORef, and update the IORef when we do operations to read.
17:07:36 <jmcarthur> how are you doing that?
17:07:37 <revenantphx> I got that.
17:07:41 <revenantphx> jmcarthur: here's the code as it stands.
17:08:06 <revenantphx> http://hpaste.org/42057/amity_bot
17:08:07 <jmcarthur> Cale: the IORef will still have to be passed around. why not just have a state object?
17:08:14 <jmcarthur> a tuple or something
17:08:22 <Cale> jmcarthur: Yes, that's my plan :)
17:08:25 <jmcarthur> okay
17:08:34 <revenantphx> the thing is, for data AmityState, I'm going to have a lot more stuff.
17:08:40 <Cale> jmcarthur: So a record containing this IORef together with the relevant output handle
17:08:48 <revenantphx> an Entity lookup table, MapData, Inventory, and more.
17:09:19 <revenantphx> Cale: So I could still use my Binary instances as templates for reading though.
17:09:28 <revenantphx> (decode)
17:09:39 <Cale> data Port = Port { inputRef :: IORef L.ByteString, outputHandle :: Handle }
17:09:54 <revenantphx> Should I put this in another file maybe?
17:10:03 <Cale> revenantphx: Mostly, you'll need to pass a Port to the relevant receive and send operations
17:10:07 <jmcarthur> revenantphx: your code as it stands will never send the keepalive if it doesn't receive anything for a long time
17:10:13 <revenantphx> What?
17:10:15 <Cale> So, in terms of Port, we can write:
17:10:29 <revenantphx> (how so jmcarthur?)
17:10:30 <Cale> receive :: Binary a => Port -> IO a
17:10:44 <jmcarthur> revenantphx: your keepalive thread is just pushing the keepalive message to a TChan. your main thread still blocks on receive and only *then* sends things from the queue
17:10:58 <revenantphx> Oh, thats true.
17:11:39 <jmcarthur> if you're going to stick with blocking IO you'll need to have the sending stuff go on in a different thread from the receiving stuff i think
17:11:49 <jmcarthur> so that you can still squeeze the keepalive in
17:11:59 <revenantphx> Cale, continue, I'm listening :P.
17:12:11 <revenantphx> jmcarthur: yes but I can't be writing and reading to it at the same time :\
17:12:24 <jmcarthur> then i'd say you don't want blocking IO
17:12:43 <revenantphx> Except the protocol is a ridiculous pain in the ass non blocking.
17:12:44 <adnap_> Does anyone know if there is already a library designed purely for handling polygons and/or other geometry?
17:12:51 <jmcarthur> why can't you read and write it at the same time?
17:13:01 <Cale> receive p = do in <- readIORef (inputRef p); let (value, rest, _) = runGetState get in 0; writeIORef (inputRef p) rest; return value
17:13:03 <adnap_> I couldn't find one on Hackage.
17:13:33 <revenantphx> jmcarthur: Well... to be honest I'm not sure...
17:13:58 <Cale> send :: Binary a => Port -> a -> IO (); send p x = do L.hPut (outputHandle p) (encode x)
17:14:04 <Cale> er, even without the do ;)
17:14:31 <Cale> flush :: Port -> IO (); flush = hFlush . outputHandle
17:14:42 <Cale> and there you go
17:14:56 <Cale> Now all you need to do is make a Port value and pass it where you need it.
17:15:17 <revenantphx> :O
17:15:24 <revenantphx> Cale strikes again!
17:15:30 <Cale> It uses lazy IO, and it makes the rather strong assumption that you'll never receive any bad data.
17:15:49 <revenantphx> Well, the thing is, if i do receive any bad data, I can't recover from that.
17:15:55 <Cale> But hey, it's simpler than using this StateT monad and having to liftIO half your program :)
17:16:00 <Cale> Yeah
17:16:16 <Cale> (BinaryProtocol already had the problem with not being able to manage bad data)
17:16:24 <revenantphx> TCP promises to send me whatever the server puts out (give or take some bits due to neutrinos on the wires)
17:16:37 <revenantphx> so if I'm getting bad data, to me the connection is already invalid.
17:17:06 <Cale> But you'll get a potentially rather difficult-to-catch exception in that case
17:17:14 <revenantphx> mm.
17:17:26 <Cale> So if you want to be kind to your users and not have the whole program die when that happens, it can be a little annoying.
17:17:42 <Cale> But try it, maybe just plain catch will work.
17:17:56 <Cale> Or maybe you don't even care :)
17:18:27 <Cale> Oh, but definitely use the catch from Control.Exception, and not the one in the Prelude. The Prelude catch is only there for hysterical raisins.
17:18:38 <revenantphx> what? XD
17:18:48 <hpc> more specifically, to comply with h98
17:19:04 <Cale> (historical reasons)
17:19:40 <adnap_> I was thinking of implementing a polygon as a list of points, but this could be limiting if I want to specify algorithms that work on certain types of polygons like quads or triangles.  I guess I could have multiple value constructors that include specific types, and then the last constructor could be a general polygon.  Does this sound like a good idea?
17:20:23 <Cale> adnap_: Another option, make separate types and functions to convert
17:20:40 <Cale> (rather than separate cases of a single type
17:20:42 <Cale> )
17:20:52 <adnap_> Cale: But there are certain algorithms that could work on all types of Polygons, so it would be nice to unify them.
17:21:19 <Cale> adnap_: Maybe a typeclass?
17:21:27 <Cale> class GeneralPolygon a where
17:21:36 <Cale>   toPolygon :: a -> Polygon
17:22:06 <adnap_> Yeah, I thought about doing a typeclass.
17:22:35 <adnap_> One thing that I started to get hung up on was polygons in higher dimensions than 2.
17:22:54 <revenantphx> So then in my code, I'll add a Port to my AmityState and just continue to pass that around.
17:23:01 <revenantphx> And then I'll be running entirely in the IO monad.
17:23:34 <adnap_> It would be cool to have operations that deal with polygons in any dimension, or project to certain dimensions.
17:24:02 <Cale> revenantphx: yep! :)
17:24:08 <adnap_> I can't believe there's not already a library though.
17:24:30 <Cale> adnap_: Yeah, you could have Polygon be parametrised by the type of point.
17:24:35 <Cale> (or vector)
17:24:38 <revenantphx> Cale: Oh one other question, how should I lay out this project underneath my project directory?
17:24:41 <revenantphx> So that it can find all the files.
17:24:48 <adnap_> Yeah
17:24:50 <revenantphx> (module style layout)
17:24:55 <adnap_> I'm planning on using Data.Vec
17:24:56 <Cale> revenantphx: You put module Foo in Foo.hs
17:25:06 <Cale> revenantphx: and module Foo.Bar in Foo/Bar.hs
17:25:08 <revenantphx> Amity in Amity.hs, what about Amity.Networking
17:25:09 <revenantphx> Ok
17:25:13 <revenantphx> simple enough!
17:25:17 <Sunhay_> ls
17:25:20 <Sunhay_> whoops
17:25:21 <Sunhay_> =D
17:26:58 <ezyang> Mmm 
17:27:09 * ezyang is kind of starting to understand STG and C-- 
17:27:22 <revenantphx> I think... one thing I like about haskell... is it makes you smarter :\
17:27:32 <revenantphx> Or rather, "more knowledgeable"
17:27:38 <revenantphx> you learn something new every time you revisit it.
17:29:37 <adnap_> Cale: It looks like I can't parameterize Polygon if I use Data.Vec, because the Vec class is paremeterized with Naturals.
17:29:46 <ManateeLazyCat> Morning! :)
17:29:56 <haskeller> Evening! =)
17:30:16 <revenantphx> Night!
17:30:23 <ManateeLazyCat> hehe . :)
17:31:09 <revenantphx> Is there a way to tell GHC to trash .hi and .o files?
17:31:33 <ManateeLazyCat> revenantphx: Don't use .hi and .o?
17:31:44 <c_wraith> not really.  That's why using cabal is nice.  it puts all build products in a subdirectory
17:31:54 <revenantphx> They're just cluttering up the directory and inhibitting my auto-completion >:D
17:32:11 <ManateeLazyCat> revenantphx: So use cabal
17:32:17 <revenantphx> cabal compiles?
17:32:22 <revenantphx> I'm just using ghc make
17:32:25 <revenantphx> ghc --make*
17:32:28 <ManateeLazyCat> revenantphx: Cabal will put .hi .o in dist directory
17:32:37 <ManateeLazyCat> revenantphx: Won't dirty your directory. :)
17:32:40 <revenantphx> oh
17:32:59 <revenantphx> oh Cale
17:33:05 <revenantphx> one amusing failure in your code
17:33:09 <revenantphx> They're produced during the compile phase and I want to remove
17:33:10 <revenantphx> in <- readIORef (inputRef p);
17:33:10 <revenantphx>     let (value, rest, _) = runGetState get in 0
17:33:15 <revenantphx> let... in
17:33:30 <Cale> lol, right
17:33:35 <Cale> in is a keyword, use inp
17:33:42 <ManateeLazyCat> revenantphx: Example, your cabal project directory at /home/revenantphx/project, cabal will put all temporary files ( *.hi *.o ) at /home/revenantphx/project/dist. :)
17:33:46 <Cale> (I obviously just wrote the code on the spot)
17:33:51 <revenantphx> yep :P
17:34:09 <revenantphx> god dammit, I always end up alphabetizing my imports
17:34:15 <revenantphx> and then organizing them by length.
17:34:20 <revenantphx> -_-
17:34:31 <ManateeLazyCat> revenantphx: Use 'sort-lines' in Emacs.
17:34:43 <ManateeLazyCat> revenantphx: I always use it sort my imports automatically. :)
17:34:51 <revenantphx> this is how mine look
17:34:52 <revenantphx> https://gist.github.com/727816
17:35:17 <revenantphx> I do group them by module.
17:35:32 * ManateeLazyCat pasted "sort-lines by Emacs" at http://paste2.org/get/1124081
17:35:34 <ManateeLazyCat> revenantphx: ^^^^
17:35:46 <revenantphx> I need to get into using emacs >_>
17:36:02 <edenc> emacs owns
17:36:22 <Eduard_Munteanu> Are lists of unboxed elements possible?
17:36:38 <revenantphx> At some point during winter break, I'll try to use emacs a bit.
17:36:49 <Eduard_Munteanu> Seemingly they should be.
17:38:10 <haskeller> dont know if you are on it yet, revenantphx , but you could set the -outputdir option
17:38:25 <Eduard_Munteanu> like if there's a standard data List a = Nil | Cons !a (List a)
17:38:31 <haskeller> or -odir and -hidir
17:38:31 <ManateeLazyCat> revenantphx: Best way is use Cabal, don't afraid it.
17:38:44 <ManateeLazyCat> revenantphx: No way better than Cabal
17:38:45 <haskeller> agreed
17:38:47 <Eduard_Munteanu> ... which would then behave well enough with -funbox-strict-fields.
17:38:57 <haskeller> just providing options =)
17:39:08 <Eduard_Munteanu> Or for that matter, [Int#].
17:39:08 <revenantphx> :|
17:39:28 <revenantphx> The only thing I use emacs for is playing tetris >_>
17:39:31 <revenantphx> seriously.
17:40:29 <ManateeLazyCat> revenantphx: If want study Emacs, can read my homepage : http://www.emacswiki.org/emacs/AndyStewart
17:40:56 <revenantphx> kk
17:41:33 <ManateeLazyCat> revenantphx: I recommend use my AutoInstall and MultiTerm :)
17:41:40 <revenantphx> What are those 0.o
17:41:45 * revenantphx knows nothing about emacs.
17:41:54 <ManateeLazyCat> revenantphx: Those are elisp extension for Emacs.
17:42:07 <ManateeLazyCat> revenantphx: Like JavaScript extension for firefox.
17:42:09 <revenantphx> emacs is scripted in lisp?
17:42:14 <revenantphx> (I got that aspect)
17:42:15 <ManateeLazyCat> revenantphx: yes, elisp 
17:42:45 <ManateeLazyCat> revenantphx: Emacs have C core execute performance code, then mix elisp interpreter in it.
17:42:58 <ManateeLazyCat> revenantphx: Any elisp extension is running in runtime.
17:43:17 <ManateeLazyCat> revenantphx: So you can extension it don't need restart Emacs, just fix-and-continue in runtime.
17:44:30 <revenantphx> I'll be back later
18:03:56 <sshc> How do I hide a module (preventing it from being imported when it's in the export list) when I import a module?
18:05:50 <monochrom> I'm afraid can't be done.
18:05:57 <Eduard_Munteanu> Hm good, perhaps unboxing improves performance.
18:06:23 <djahandarie> It can't be helped.
18:08:18 <sshc> I'm writing module A, which import module B.  B has module C in its export list.  My ultimate goal is the export C in module A.  If I add "module C" in A's export list, ghc complains with many warnings that "x is exported by A and B".  But if I remove the "import C" line from module A, GHC has an *error* "The export item `C' is not imported", even though B exports C and A imports B.
18:10:22 <sshc> I'm building with GHC v6.12.3
18:10:50 <jmcarthur> maybe you can use an explicit import list where you import B in A?
18:10:59 <jmcarthur> and then import C in A
18:12:32 <sshc> jmcarthur: I don't like the solution, but it seems to be my only option (without errors and warnings).  Thanks.
18:13:16 <Eduard_Munteanu> Awww... why can't I embed an unboxed type in a data declaration?
18:13:24 <Eduard_Munteanu> More specifically I want a list of Int#s.
18:13:40 <jmcarthur> Eduard_Munteanu: it just doesn't work that way
18:13:50 <jmcarthur> Eduard_Munteanu: however, you could make a specialized list
18:13:52 <Eduard_Munteanu> jmcarthur: but -funbox-strict-fields does just that!
18:14:11 <Eduard_Munteanu> Oh.
18:14:17 <Eduard_Munteanu> like declaring it myself.
18:14:22 <jmcarthur> Eduard_Munteanu: data IntList = Cons {-# UNPACK #-} !Int IntList | Nil
18:14:52 <Eduard_Munteanu> Thanks, I'll try it.
18:15:11 <jmcarthur> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/adaptive-containers/0.3/doc/html/Data-Adaptive-List.html
18:16:14 <Eduard_Munteanu> Grr, they say it doesn't fuse, I kinda need that.
18:16:45 <jmcarthur> do you need lists? you can't use vector or something?
18:17:46 <jmcarthur> Eduard_Munteanu: because this works quite well http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Unboxed.html
18:18:03 <Eduard_Munteanu> jmcarthur: I don't think so, at least not easily. Here's what I'm working on... http://paste.pocoo.org/show/300087/
18:18:27 <Eduard_Munteanu> jmcarthur: the idea is to bring the performance of the boxed variant of that code close to C code.
18:18:56 <Eduard_Munteanu> Currently it's slower than a very very naive C version that simulates consing and allocation patterns.
18:19:10 <jmcarthur> Eduard_Munteanu: i don't see why that's not possible with vector
18:21:00 <jmcarthur> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Unboxed.html#10
18:22:20 <gheh> ghci core dumps whenever I press tab. does anyone know why?
18:22:24 <Eduard_Munteanu> Nice, I'm also looking at 'force'.
18:22:47 <jmcarthur> why would you need force?
18:24:31 <Eduard_Munteanu> jmcarthur: well I figure my packing function (which produces bytes from bits) could force a slice of it hinting the GC it can collect immediately.,
18:24:59 <jmcarthur> you must be talking about code i haven't seen
18:25:01 <Eduard_Munteanu> (Oh, I forgot)
18:25:27 <Eduard_Munteanu> I was about to tell you this was for a real application where I produce a list of bits (Bools) which are then packed into bytes.
18:25:37 <Eduard_Munteanu> Lazily.
18:25:46 <gheh> would anyone know why ghci would core dump whenever i press tab?
18:26:18 <Axman6> gheh: have you tried asking in #ghc?
18:26:26 <c_wraith> gheh: you installed it via a package manager, instead of from the generic binaries?
18:26:35 <Eduard_Munteanu> jmcarthur: surprisingly most of the overhead I'm noticing is during tree traversal.
18:26:55 <c_wraith> For some reason, lots of package managers like to mangle ghci
18:27:11 <Eduard_Munteanu> like cons and fromIntegral were not very good.
18:27:35 <Cale> Eduard_Munteanu: I thought we worked out that it was that library's fault.
18:28:01 <Cale> Did you ever contact the library's authors?
18:28:02 <Eduard_Munteanu> Cale: which library?
18:28:23 <Cale> (Or was that someone else)
18:28:26 <Eduard_Munteanu> Cale: well in my example I'm not using anything out of the ordinary.
18:28:40 <Cale> Oh, you were doing the compression stuff
18:28:41 <djahandarie> Is GHC 7 GC still stop-the-world?
18:28:44 <Cale> Not the 3D
18:28:49 <c_wraith> djahandarie, yes
18:29:18 <c_wraith> The concurrent GC is still a few months out, as far as ghc releases are concerned
18:29:19 <Eduard_Munteanu> Cale: yeah. But I'm not happy with the performance of this stuff compared to C... http://paste.pocoo.org/show/300087/ (forgive the mess, I was about to rewrite it using unboxed types)
18:29:35 <djahandarie> c_wraith, is there any info about that somewhere?
18:29:43 <rks> hi
18:29:47 <Eduard_Munteanu> Though I need another kind of List to represent unboxed stuff.
18:29:49 <c_wraith> djahandarie, there was something on the haskell blog
18:29:54 <rks> I need a bit of help with this http://hpaste.org/42058/either_as_a_monad please
18:30:23 <djahandarie> All I remember is Simon M saying it was hard ;)
18:30:27 <djahandarie> And I think that was in here
18:30:40 <rks> ghc tells me he cant match the the type "Result a" with the (infered) type "Either a1 b" (on line 3)
18:30:44 <c_wraith> djahandarie, http://hackage.haskell.org/trac/ghc/blog/new-gc-preview
18:30:44 <adnap_> is length for a list linear or constant time?
18:30:48 <Boxo> rks: your data definition has to constructor
18:30:52 <Boxo> *has no
18:30:57 <Axman6> adnap_: linear
18:31:02 <adnap_> okay
18:31:04 <rks> Boxo: come again?
18:31:04 <Boxo> "Either" is already taken
18:31:05 <Cale> rks: Your data declaration isn't right.
18:31:12 <Axman6> @src length
18:31:12 <lambdabot> Source not found. Sorry.
18:31:13 <adnap_> is there a way to improve tail xs ++ [head xs]?
18:31:16 <Axman6> o.O
18:31:19 <rks> hm, yeah ok
18:31:34 <rks> but hum, I couldn't use « type » here
18:31:37 <rks> (or could I?)
18:31:44 <Axman6> adnap_: use ZipLists i think... or is it the other one i can never remember the name of...
18:31:48 <c_wraith> djahandarie, looks like it's about a year out, I seem to have been reading the date it would land in the GHC codebase, not when it would be released officially
18:31:50 <Boxo> data Result a = Result (Either String a) -- rks, this would work but the instance would have to be tweaked
18:32:00 <rks> Boxo: hmmm
18:32:04 <rks> yeah, that would work
18:32:07 <rks> but it's heavy
18:32:12 <adnap_> I'm just saying, tail xs ++ [head xs] is linear, right?  Can you do it in constant time?
18:32:12 <Cale> rks: The syntax of data declarations is that you have the keyword data followed by the name of a type constructor and a possibly empty sequence of distinct type variables, followed by an = sign, and then a | separated list of cases
18:32:18 <rks> (or hmm, with the right orthograph :°)
18:32:19 <Boxo> But in fact, rks, it's better to make "Either String" an monad instance
18:32:20 <Axman6> why not use type Result a = Either String a?
18:32:27 <Cale> rks: Where each case consists of the name of a new data constructor
18:32:37 <rks> yep Cale, I get it thanks
18:32:49 <Cale> rks: Followed by a possibly empty sequence of types for the parameters of that data construction
18:32:52 <rks> I just wanted Result to be an alias for Either String
18:32:54 <Cale> constructor*
18:33:03 <rks> and « type Result a = Either String a » didn't work
18:33:12 * hackagebot pcre-light-extra 0.0.0 - pcre-light extra functionality  http://hackage.haskell.org/package/pcre-light-extra-0.0.0 (SteffenSiering)
18:33:14 <Cale> rks: Then you want 'type', rather than 'data', but you can't write instances for type synonyms.
18:33:16 <rks> so I don't know what to do
18:33:19 <Boxo> rks, it works, the instance just doesn't work
18:33:24 <Cale> rks: instance Monad (Either String) where ...
18:33:29 <Boxo> you can't make "type" things instances
18:33:30 <rks> hmmm
18:33:44 <rks> I tried that Cale
18:33:49 <Cale> (You'll probably still need the FlexibleInstances extension for that
18:33:55 <jmcarthur> Eduard_Munteanu: i think unboxed arrays (as in the array package) pack bits automagically, btw, but i don't know how easy it is to get the bytes out of that
18:34:02 <djahandarie> c_wraith, hmm... that still isn't really concurrent
18:34:02 <sshc> aavogt: I was complaining about openDisplay earlier, and you replied to me but somehow I completely missed what you said.  Yes, passing an empty string to openDisplay results in the desired behaviour.
18:34:03 <rks> « Illegal instance declaration for `Monad (Either String)' »
18:34:06 <jmcarthur> Eduard_Munteanu: i'm pretty sure vector still doesn't though :\
18:34:06 <Cale> instance Monad (Either e) where -- will work
18:34:10 <djahandarie> c_wraith, more than what we have right now though
18:34:12 <Cale> But you won't be able to implement fail
18:34:22 <Cale> (which is fine, since fail shouldn't even be in that class)
18:34:36 <Boxo> Cale, can't make partially applied type synonyms instances, at all. So no monad, functor...
18:34:44 <c_wraith> djahandarie, it is in that nursery generations can be collected concurrently...  And the whole point of generational GC is that most of the trash is in the nursery generation
18:34:47 <rks> Cale: it works with Either e, all right
18:34:50 <gheh> sorry, i was gone for a bit
18:34:55 <Cale> With {-# LANGUAGE FlexibleInstances  #-} you can write one for Either String
18:34:56 <rks> and yes, I'll get rid of fails
18:34:57 <djahandarie> c_wraith, yeah
18:35:03 <gheh> i didn't install it myself. it's on my universitie's computers
18:35:11 <gheh> running solaris 
18:35:18 <gheh> actually
18:35:19 <Cale> (of course, you should choose one or the other, but I prefer the more general one myself)
18:35:22 <c_wraith> gheh, you probably can't do anything except report the problem to your administrator then
18:35:26 <rks> hum Cale, about that, what's the "politic" with all these GHC extensions
18:35:27 <gheh> they have ubuntu. maybe i'll try it on the ubuntu computers
18:35:35 <rks> I mean
18:35:56 <gheh> hmm alright
18:36:03 <rks> is it better (moraly speaking) not to use them or ?
18:36:06 <Cale> rks: People use them pretty liberally, and different implementations of Haskell support them to varying extents.
18:36:29 <c_wraith> rks: there are many extensions that are so much better than the alternatives that they're worth using.  IncoherentInstances is not one of them :)
18:36:54 <rks> :D
18:37:07 <rks> ok :°
18:37:09 <c_wraith> rks: which is my way of saying, it kind of depends on what extension you're talking about.  There are a bunch that no one will ever hesitate to use.
18:37:38 <rks> ok
18:37:45 <rks> well, thank you every one :)
18:52:26 <benmachine> hmm, it's conventional to use greek letters for type variables, isn't it
18:52:35 <benmachine> but what happens when you get up to κ :P
18:52:50 <benmachine> (i.e. what's after that)
18:53:10 <rks> αα ?
18:53:23 <benmachine> I could just skip λ I guess
18:53:28 <benmachine> and go straight to μ
18:53:35 <benmachine> or would that be wrong
18:53:44 <rks> (oh ok, you are not at the end of the alphabet :°)
18:53:52 <benmachine> I'm not at the end no
18:53:57 <jmcarthur> why skip lambda?
18:54:10 <rks> (same question here)
18:54:20 <benmachine> it's already used for lambdas?
18:54:21 <jmcarthur> lambda is conventionally used for many things aside from the lambda calculus as well
18:54:35 <jmcarthur> actually no, unicode lambda is an identifier
18:54:43 <benmachine> yes but I am type-checking a haskell expression here :P
18:54:47 <jmcarthur> ^^
18:54:48 <benmachine> it probably has lambdas in it
18:54:54 <jmcarthur> unicode lambda is an identifier
18:54:59 <benmachine> yeah
18:55:03 <benmachine> it's not wrong as such to use λ
18:55:12 <benmachine> it just seems a little odd
18:55:24 <jmcarthur> i wouldn't worry about it
18:55:28 <benmachine> k
18:55:29 * benmachine doesn't
18:55:30 <unkanon> speaking of odd:
18:55:33 <unkanon> @pl f x y = bla $ ok x y
18:55:34 <lambdabot> f = (bla .) . ok
18:55:39 <unkanon> this is indeed pointless, but...
18:55:42 <unkanon> @pl f x y = bla $ ok x y z
18:55:42 <lambdabot> f = (bla .) . flip flip z . ok
18:55:45 <unkanon> this has z in it!
18:55:50 <benmachine> z isn't a point
18:55:55 <unkanon> ?
18:55:56 <jmcarthur> z isn't on the lhs there
18:56:00 <benmachine> it's not a parameter
18:56:02 <jmcarthur> @pl f x y z = bla $ ok x y z
18:56:03 <lambdabot> f = ((bla .) .) . ok
18:56:05 <unkanon> oh sorry, my fault
18:56:06 <jmcarthur> there
18:56:11 <benmachine> it's actually pretty useful
18:56:13 <unkanon> sorry sorry :)
18:56:16 <benmachine> that that happens
18:56:28 <benmachine> it means if you get something really perverse from @pl you can try a 'partial pointfree'
18:56:31 <benmachine> like
18:56:39 <benmachine> @pl mapM f xs = sequence (map f xs)
18:56:39 <lambdabot> mapM = (sequence .) . map
18:56:45 <benmachine> I might decide I didn't like that
18:56:48 <benmachine> so I can do this instead
18:56:52 <benmachine> @pl mapM xs = sequence (map f xs)
18:56:52 <lambdabot> mapM = sequence . map f
18:57:00 <benmachine> and then put the f back afterward
18:57:06 <unkanon> oh I see, because that looks prettier?
18:57:11 <min> what is the equivalent of the block `do { f e1; f e2; ... f en}`, e.g., in an error monad (computation fails when `f ei` returns Left)? Without making a recursive function, can I do something like `mapM_ f [e1, ..., en]`?
18:57:29 <benmachine> unkanon: mm
18:58:06 <unkanon> benmachine: you say you would decide you didn't like that for what reason? because it's too confusing?
18:58:09 <benmachine> min: doesn't mapM_ do exactly that?
18:58:16 <benmachine> unkanon: basically yeah
18:58:19 <unkanon> right
18:58:22 <unkanon> I get it
18:58:25 <unkanon> it is indeed useful
18:58:33 <unkanon> now, how can I learn how to do pointless by hand?
18:58:40 <unkanon> what should I google for?
18:58:52 <unkanon> th source code of lambdabot isn't an answer :)
18:58:59 <benmachine> well
18:59:07 <benmachine> usually it's straightforward
18:59:22 <unkanon> yeah I have an intuition of how it works
18:59:38 <unkanon> @pl f x y z t = bla $ ok x y z t
18:59:38 <lambdabot> f = (((bla .) .) .) . ok
18:59:42 <benmachine> when it's not straightforward you just have to learn the tricks I guess
18:59:46 <min> I thought mapM_ did that; I was just unsure, and so checking :)
18:59:46 <unkanon> the pattern basically repeats itself
18:59:57 <benmachine> unkanon: do you understand why it's that though?
19:00:13 <unkanon> benmachine: yes, I've eval'ed it by hand
19:00:16 <benmachine> k
19:00:22 <unkanon> it was fun :P
19:00:25 <benmachine> I'll bet
19:00:32 <unkanon> brb 15 min
19:02:31 <fryguybob> @where SEC -- unkanon
19:02:31 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
19:04:39 <Eduard_Munteanu> Wow... this is better, although I'm still not sure... real    1m19.141s
19:05:03 <Eduard_Munteanu> http://paste.pocoo.org/show/300092/
19:05:16 <Eduard_Munteanu> (down from 1m30-ish)
19:05:29 <Eduard_Munteanu> Any comments on that?
19:06:25 <gheh> hmm this code example from learnmeahaskell doesn't compile correctly. i copied it exactly from the site
19:06:59 <Eduard_Munteanu> gheh: link?
19:07:11 <Eduard_Munteanu> I suppose you mean LYAH, as in...
19:07:13 <Eduard_Munteanu> @where lyah
19:07:13 <lambdabot> http://www.learnyouahaskell.com/
19:07:49 * Cale grumbles about how his video is uploading to YouTube at only 20 KiB/s.
19:08:10 <gheh> hold on. let me find it
19:08:19 <Eduard_Munteanu> Do you guys have any ideas for improving that further?
19:08:24 <Cale> "About 858 min. remaining..." lol
19:08:52 <Cale> There we go, restarting it helped :P
19:09:09 <gheh> initials :: String -> String -> String  
19:09:09 <gheh> initials firstname lastname = [f] ++ ". " ++ [l] ++ "."  
19:09:09 <gheh>     where (f:_) = firstname  
19:09:09 <gheh>           (l:_) = lastname  
19:09:18 <Eduard_Munteanu> (the input is a 512MiB file generated from /dev/urandom)
19:09:58 <Eduard_Munteanu> gheh: are you using tabs?
19:10:32 <Cale> gheh: That code looks fine, just make sure that your editor is configured to expand tab characters into spaces
19:10:34 <Eduard_Munteanu> I figure some indentation error might have slipped in. What's the error?
19:10:50 <gheh> exmple.hs:4:18: parse error on input `='
19:11:09 <gheh> being right around (l:_)
19:11:32 <Cale> gheh: Yeah, it might not be indented properly. Make sure that it lines up with the (f:_) from above
19:11:33 <jmcarthur> sounds exactly like an indentation problem to me
19:11:46 <jmcarthur> and that you aren't using tabs
19:11:46 <Cale> Note that tab characters count as aligning to the next multiple of 8 spaces
19:11:46 <gheh> oh. i didn't know that haskell paid attention to indentation
19:11:51 <Cale> (so don't use them)
19:12:00 <jmcarthur> or that if you are using tabs you are treating them as cale just said
19:12:08 <jmcarthur> but don't use them, please :)
19:12:20 <Cale> Tab characters are antisocial
19:12:40 <Eduard_Munteanu> Hm yeah, they kinda force conventions on others.
19:12:47 <Cale> (The compiler accepts them, but everyone will hate you)
19:13:08 <revenantphx> Yep.
19:13:12 <revenantphx> Softtabbing ftw.
19:13:13 <jmcarthur> repa uses tabs :(
19:13:36 <gheh> OK. i got it work
19:13:40 * Eduard_Munteanu really needs to setup Vim to use softtabs in .hs files.
19:13:55 <Cale> http://hpaste.org/40299/my_vimrc
19:14:13 <Cale> The ColorScheme/Syntax lines make tabs show up in bright red :)
19:14:29 <Cale> (and end of line whitespace show up in green)
19:14:34 <jmcarthur> -fwarn-tabs rocks as well
19:14:48 <gheh> thatd be useful for when i have to use (ugh..) motif
19:15:21 <Eduard_Munteanu> Cale: I autocmd this stuff, it's nice with UnicodeSyntax: http://paste.pocoo.org/show/300096/
19:15:21 <gheh> trailing spaces count in your labels so "addBtn" isn't the same as "addBtn "
19:15:32 <jmcarthur> yuck
19:15:35 <Eduard_Munteanu> I don't remember where I got it from.
19:15:41 <gheh> (and there aren't quotes in the resource file so the spaces are invisible)
19:15:49 <gheh> its very obnoxious
19:16:07 <Eduard_Munteanu> gheh: vim?
19:16:10 <gheh> thankfully we're getting out of motif. hurray for finally leaving the late 80s
19:16:12 <gheh> yes
19:16:19 <Eduard_Munteanu> gheh: use :set list
19:16:20 <gheh> switching to qt
19:16:30 <Eduard_Munteanu> That shows you invisible characters.
19:16:39 <gheh> ah, ok
19:16:43 <gheh> thats very useful. thank you
19:16:53 <revenantphx> Why can't we get a good IDE/text editor :\
19:17:08 <revenantphx> That's as powerful as a command line one but with a GUI.
19:17:11 <gheh> vims perfect
19:17:18 <gheh> well, not perfect
19:17:18 <revenantphx> I don't mind CLI at all anyhow.
19:17:21 <gheh> but pretty good
19:17:28 <gheh> it suites my needs 90% of the time
19:17:29 <revenantphx> I generally just use TextMate along with a spam of terminal windows.
19:17:35 <revenantphx> >_>
19:17:41 <jmcarthur> vim and emacs satisfy basically 100% of my needs
19:17:49 <gheh> and i use sed if i need to refactor
19:17:56 <Cale> It would be really nice to have a vim extension which knew about the layout keywords in Haskell and caused any edit which moved a layout keyword to move its contained block in a corresponding fashion
19:18:01 <sshc> What is an efficient way of converting an array of Word8's to a lazy Char8 ByteString?
19:18:10 <gheh> id choose vim and sed over using IDE
19:18:10 <revenantphx> Cale: mm yeah.
19:18:14 <Eduard_Munteanu> Vim and Emacs? That's like being a Muslim and a Christian at the same time.
19:18:16 <Cale> sshc: pack
19:18:25 <revenantphx> @hoogle [Word8] -> ByteString
19:18:25 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
19:18:25 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
19:18:25 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
19:18:27 <jmcarthur> Eduard_Munteanu: i use them for different things
19:18:27 <Cale> sshc: (from Data.ByteString.Lazy)
19:18:33 <sshc> Cale: I have an array, not a list
19:18:38 <jmcarthur> Eduard_Munteanu: vim is *great* for general text editing. i use emacs more like an IDE
19:18:44 <Eduard_Munteanu> Oh.
19:18:50 <Cale> sshc: Oh, then pack . elems
19:18:51 <xplat> Eduard_Munteanu: people basically used to do that in Spain until the respective church authorities stopped them
19:18:58 <gheh> what does emacs have that vim doesn't jmcarthur?
19:19:00 <revenantphx> @hoogle Array i e -> ByteString
19:19:00 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
19:19:00 <lambdabot> Data.Graph.Inductive.Graph ufold :: Graph gr => (Context a b -> c -> c) -> c -> gr a b -> c
19:19:01 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
19:19:01 <jmcarthur> Eduard_Munteanu: some people even use vi-mode ;)
19:19:07 <Eduard_Munteanu> I don't remember last time I used Emacs. I know I used it when Vim seemed difficult, but that was a long time ago.
19:19:13 <revenantphx> Oh snap, editor wars time :O
19:19:17 <Axman6> sshc: using one of the binary builder packages (i'd recommend blaze-builder)
19:19:22 <Eduard_Munteanu> xplat: heh.
19:19:29 <Cale> I like emacs well enough too, but I don't use it as much for whatever reason.
19:19:33 <revenantphx> During the summer maybe I'll just write up my own basic IDE, hah.
19:19:40 <gheh> its just what you get used to i guess. i use vim, and emacs seems hard because i don't know the keyboard shortcuts
19:19:56 <Eduard_Munteanu> The first time I opened a Vim I had to switch vtys and kill it, I didn't know how to quit it :
19:19:57 <revenantphx> tbh, TextMate is perfectly fine for my general use.
19:19:59 <Eduard_Munteanu> :)
19:20:01 <Cale> There was a fair period of time where I used emacs.
19:20:03 <gheh> i mean, if vim is hard you could just use it entirely in "insert mode" 
19:20:12 <revenantphx> gheh: this is what I do when I have to use it :3
19:20:16 <revenantphx> (since I haven't learned it)
19:20:24 <Cale> Any editor which can convert tabs to spaces and does a bit of syntax colouring is fine with me really :P
19:20:29 * Axman6 loves his TextMate but has been forced to use vim on linux
19:20:36 <revenantphx> Axman6: TextMate 2!
19:20:43 <dolio> I use emacs to write Haskell, but I don't use many of its fancy features.
19:20:44 <revenantphx> IS IT EVER COMING? Who knows...
19:20:55 <benmachine> obviously everyone should use yi
19:20:57 <xplat> lots of vis still don't let you move the cursor in insert mode
19:20:59 <Eduard_Munteanu> I'd still like if Vim could just put a damn vertical coloured bar at 80-columns or so.... it seems it can't.
19:21:06 <Axman6> revenantphx: they're already using it... to write duke nukem forever
19:21:15 <jmcarthur> gheh: emacs has RSI by default ;)
19:21:16 <Cale> yi at least tries to do that indentation trick
19:21:16 <Cale> :)
19:21:16 <revenantphx> Axman6: Um... that's actually coming out.
19:21:20 <Eduard_Munteanu> And the workaround are stupid :/.
19:21:21 <gheh> RSI?
19:21:23 <Axman6> so's TM2 :P
19:21:24 <Cale> (it doesn't get it right, imo)
19:21:31 <revenantphx> Axman6: TM2?
19:21:32 <xplat> Eduard_Munteanu: workardound is resize your terminal :P
19:21:36 <jmcarthur> gheh: Repetitive Strain Injury. i was joking around
19:21:46 <gheh> i mostly program c. im just picking haskell for the fun of it
19:21:46 <Axman6> textmate 2...
19:21:52 <revenantphx> Oh, hah.
19:21:55 <Eduard_Munteanu> xplat: heh, no, there's some highlighting stuff, but it's not a vertical line :)
19:22:00 <revenantphx> gheh: same.
19:22:07 <jmcarthur> gheh: emacs has too many control-key shortcuts, so i map it to capslock instead so i don't kill my pinky
19:22:07 <revenantphx> I'm starting to ... get stuck
19:22:08 <revenantphx> erp
19:22:15 <gheh> ah. ok
19:22:26 <jmcarthur> gheh: i learned the necessity to do that after making my left pinky very sore :\
19:22:35 <revenantphx> jmcarthur: ugh yeah, I prefer :shortcut to Esc-Meta-Alt-Ctrl-Shift
19:22:35 <Cale> I never really got into using the keyboard shortcuts extensively in emacs.
19:22:37 <xplat> jmcarthur: supposedly you should do that anyway, but i make mine compose
19:22:40 <Eduard_Munteanu> Ok, since now everybody is on talking... maybe you could help me get this running even faster: http://paste.pocoo.org/show/300092/
19:22:43 <Axman6> I mostly program Haskell, i program C for the fun of it
19:23:09 <jmcarthur> revenantphx: i've never had a shortcut with that many buttons! :P
19:23:11 <gheh> are there many job options available for haskell programmers?
19:23:17 <jmcarthur> gheh: not really
19:23:19 <xplat> Axman6: does that make you a masochist?
19:23:26 <gheh> just curious. im happy being a c programmer
19:23:26 <revenantphx> jmcarthur: I'm pretty sure that's actually what "EMACS" stands for btw.
19:23:29 <jmcarthur> gheh: there are some, but they are tough to find
19:23:32 <Axman6> n ot at all, C's a lovely language
19:23:33 <gheh> ah
19:23:36 <revenantphx> gheh: Haskell will rape your mind. >:D
19:23:43 <Cale> For that matter, I hardly use vim very effectively either. :P
19:23:44 <jmcarthur> and you'll like it!
19:23:50 <revenantphx> jmcarthur: a lot!
19:23:57 <revenantphx> Just, one thing I think I got from being stuck on not a few hours ago.
19:24:02 <Cale> (Maybe a little more effectively than I do emacs)
19:24:04 <Axman6> gheh: if you stick with haskell long enough, you'll start to hate C
19:24:11 <revenantphx> gheh: don't worry so much about recreating the same data structures. It doesn't do deep copying.
19:24:11 <Eduard_Munteanu> Sometimes when use 'time' on my programs I really want to just program in C. :)
19:24:13 <jmcarthur> Axman6: not true
19:24:22 <Eduard_Munteanu> *some Haskell programs
19:24:30 <revenantphx> gheh: read this before you PrematureOptimize http://en.wikipedia.org/wiki/Purely_functional
19:24:37 <jmcarthur> Axman6: C has its niche, IMO
19:24:40 <Axman6> ok, you're right jmcarthur, i still love C. but you do begin to think and dream in haskell
19:24:42 <revenantphx> jmcarthur: definitely.
19:24:48 <revenantphx> I don't think C's going anywhere.
19:24:48 <gheh> i like low-level programming though
19:24:50 <jmcarthur> Axman6: definitely
19:24:57 <revenantphx> Axman6: yep
19:25:01 <revenantphx> We're always doing to need a low level language like C.
19:25:06 <jmcarthur> gheh: you might like Atom
19:25:14 <revenantphx> You have to build higher level abstractions on *something*
19:25:16 <Axman6> haskell can be used for some pretty low level stuff mind you
19:25:21 <Eduard_Munteanu> I'm 4-5 days into optimizing a Haskell variant of a C program I wrote in a morning :/
19:25:26 <xplat> something like BitC might be better in the long run
19:25:29 <revenantphx> Axman6: sure, but it'd be a lot more of a pain in the ass.
19:25:34 <jmcarthur> gheh: a dsl in haskell for generating hard real time C :D
19:25:38 <xplat> for low-level
19:26:03 <gheh> does haskell have an escape for assembly?
19:26:11 <Cale> gheh: I find that for most of the things where you really want low-level programming, you're still probably better off writing a small special-purpose compiler in a high-level language. (You can use Haskell as a higher-order assembler, along with things like the LLVM bindings, Atom, or Harpy)
19:26:14 <jmcarthur> gheh: you can call out to C pretty easily with haskell
19:26:21 <revenantphx> So guys. I'm a bash user simply out of habit.
19:26:31 <revenantphx> Are any of you going to try to make me use something else?
19:26:37 <revenantphx> (I'd like to know in advance)
19:26:38 <Cale> gheh: Harpy sort of implements an escape for assembly of sorts.
19:26:49 <Cale> (x86 assembly in particular)
19:26:55 <gheh> i really don't mind what shell i use. bash is just more familiar
19:26:58 <Axman6> harpy is types x86 assembly in haskell right?
19:27:05 <jmcarthur> revenantphx: i'm not at all religious about it, but i kind of like zsh
19:27:05 <Axman6> typed*
19:27:11 <gheh> but as long as a shell has tab-complete and command history i'm happy (which i think all do now-a-days)
19:27:13 <jmcarthur> bash is really fine though
19:27:14 <revenantphx> I've heard good things about zsh
19:27:16 <Cale> revenantphx: I use bash. I used to use zsh moar.
19:27:19 <revenantphx> the tab completion is really nice.
19:27:25 <revenantphx> bash is imo really good for basic use.
19:27:28 <ion> I like zsh’s extended globs.
19:27:29 <djahandarie> Cale, why'd you switch off of zsh?
19:27:31 <revenantphx> It works out of the box, and it's complicated.
19:27:37 <revenantphx> zsh seems more... specialized.
19:27:42 <jmcarthur> specialized?
19:27:43 <xplat> i kind of like bash's way of handling tab completion better for most things
19:27:43 <revenantphx> And for people who care to invest time into their shell.
19:27:45 <tg_> fish!
19:27:46 <Cale> The tab completion in bash has improved to the point where using a different shell wasn't really worth it.
19:27:52 <Axman6> fish++!
19:27:57 <gheh> ksh has tab completion though too. and command history. but i like bash's way better
19:27:57 <tg_> fish++ exists?
19:27:59 <revenantphx> Cale: all it is is "double tap tab to see list"
19:28:01 <tg_> the original fish went stale
19:28:02 <xplat> except that it explodes when you have an unescaped colon :I
19:28:04 <Cale> I used zsh back when bash's completion wasn't programmable
19:28:04 <revenantphx> zsh can provide a modal list.
19:28:08 <Axman6> now, i was saying fish was awesome
19:28:10 <jmcarthur> revenantphx: i pretty much use zsh on whatever settings it leaves me with after initial configuration, which it guides you through
19:28:11 <gheh> zsh is really nice. it's my favorite shell
19:28:27 <revenantphx> jmcarthur: I need to set up zsh on this box.
19:28:37 <Axman6> gheh: what are you using to learn haskell?
19:28:44 <Axman6> as in what tutorial
19:28:50 <Axman6> s/what/which
19:28:53 <gheh> learnyouahaskell.com
19:28:57 <Axman6> good work
19:29:05 <Cale> I found that bash actually prepared me pretty well for programming in Haskell, in a strange way. :)
19:29:06 <tg_> @google lyah
19:29:08 <lambdabot> http://www.lyahbethleflore.com/
19:29:08 <lambdabot> Title: Lyah Beth LeFlore - Available Books
19:29:09 <gheh> its a good tutorial
19:29:15 <tg_> err
19:29:15 <revenantphx> BONUS's Ego ++;
19:29:18 <Cale> @where lyah
19:29:18 <lambdabot> http://www.learnyouahaskell.com/
19:29:19 <tg_> @hoogle lyah
19:29:19 <lambdabot> No results found
19:29:31 <xplat> i do miss the extended globs in bash, though, especially when programming scala.  it's not that bad losing them in haskell though
19:29:37 <gheh> i had to take a functional course in college using scheme, but i didn't pay attention and i didn't even understand the professor (accent problem). 
19:29:39 <revenantphx> extended globs?
19:29:46 <gheh> i got a C but had no idea what i was doing by the end
19:29:52 <revenantphx> Am I the youngest person here :\?
19:29:52 <Cale> I miss having zsh's globs in bash.
19:29:58 <revenantphx> I feel alone.
19:30:06 <gheh> just threw lots of parenthesis everywhere when in doubt 
19:30:10 <Cale> revenantphx: How old are you?
19:30:14 <revenantphx> 16
19:30:14 <tg_> i used to be forced to use csh with a hybrid config file that worked on SunOS5
19:30:15 <xplat> like ** for * but recursing into directories
19:30:21 <tg_> I *hate* csh.
19:30:30 <gheh> how come tg_?
19:30:32 <Eduard_Munteanu> Hm, I wish I discovered Haskell sooner, nice revenantphx 
19:30:32 <Cale> Ah, I wish I'd found Haskell that young :)
19:30:32 <Axman6> revenantphx: yeah, you are
19:30:36 <Eduard_Munteanu> Hah.
19:30:38 <revenantphx> Axman6: ?
19:30:46 <Axman6> the youngest
19:30:47 <gheh> im worked to use ksh on a HP-UX box. (they don't have bash or zsh installed)
19:30:48 <revenantphx> Aw.
19:30:50 <gheh> forced*
19:30:54 <Axman6> i think i've seen an 11 year old in here before
19:30:56 <jmcarthur> gheh: you want low level? we'll give you low level! http://halvm.org/wiki/
19:30:58 <tg_> gheh: university admin-ing
19:30:59 <Axman6> but they didn't last
19:31:01 <revenantphx> I was in #ruby when I was 10.
19:31:01 <xplat> oh god csh, why did you remind me that existed?
19:31:24 <tg_> gheh: csh was the default shell because the homebrew user management system said so
19:31:27 <xplat> i had a job where the tech lead for the division insisted on all build scripts being in csh
19:31:28 <gheh> why do you hate it though, tg_?
19:31:32 <revenantphx> I started coding in ruby, graduated to python, then jumped to C, got stuck there a few years, started doing Objective-C stuff, and now I'm learning functional programming (mostly haskell)
19:31:40 <revenantphx> (also scheme)
19:31:43 <gheh> the only thing i hate is using escape for completion. that key is so far away
19:31:45 <Axman6> hmm, i should go out and get some breakfast... i wonder what tokyo has to offer on a saturday around lunchtime...
19:31:45 <ion> revenantphx: echo foo/**/bar*(.) is more or less equivalent to find foo -name 'bar*' -type f -print0 | xargs -0 echo
19:31:51 <tg_> gheh: well, tab completion works totally differently on different machines, sometimes expands to ANSI characters
19:32:01 <revenantphx> ion: shell script I don't know >_>
19:32:01 <tg_> xargs had all kinds of bugs on csh on SunOS5
19:32:18 <gheh> ah. yeah
19:32:21 <revenantphx> ion: neither side of that names sense to me :|
19:32:30 <revenantphx> Actually, I started in TI-BASIC... 
19:32:32 <tg_> it broke screen
19:32:37 <Cale> Somehow I look at ruby and python as being practically the same language, which is a view that would probably piss off ruby and python users alike. ;)
19:32:38 <tg_> there were others... thankfully I've blocked out most of that
19:32:39 <gheh> i don't even get VIM on the HP-UX box at work. just vi. i miss my split windows so much :(
19:32:47 <revenantphx> TI-89 Z80 BASIC is a gateway language.
19:32:48 <jmcarthur> gheh: more low level-ish fun: http://hackage.haskell.org/package/copilot
19:32:53 <Cale> They're both bastardisations of Smalltalk :P
19:32:57 <xplat> revenantphx: i think you seem to be using age-appropriate languages, the problem is you'll run out by the time you're 25
19:33:04 <tg_> They built rush - (ruby). Why not us build lash - lambdashell
19:33:12 <revenantphx> xplat: what do you mean? 
19:33:23 <gheh> ive developed an intense hatred of HP-UX (although it could just be a bad configuration)
19:34:37 <revenantphx> Oh, this may get a lot of biased answers but... what universities (in the US) do you guys recommend I look at? There are a lot :P, and I have to start looking through them soon
19:34:49 <gheh> is there any way to get an assembly output for haskell? like -S for gcc?
19:34:59 <gheh> im curious to see what it translates to 
19:35:06 <Axman6> gheh: sure
19:35:12 <revenantphx> gheh: GHC can produce C code.
19:35:15 <Axman6> i believe it may even be -S
19:35:19 <Cale> revenantphx: I'd recommend Waterloo if you were in Canada ;)
19:35:21 <Eduard_Munteanu> objdump -d suffices
19:35:24 <Axman6> or -ddump-asm or something
19:35:27 <xplat> revenantphx: i mean you're picking good languages to develop your mind at the given ages.  you will become an awesome programmer.  it's a track that will let you achieve your full potential.  but i don't think anyone's made the language you should be using at age 25 on that track yet
19:35:39 <xplat> it has yet to be invented
19:35:45 <revenantphx> xplat: Well there's only one solution then.
19:35:52 <revenantphx> I'll have to invent it myself ;)
19:35:54 <Axman6> gheh: but most people use the ghc-core package, which shows you ghc's Core language output, ad well as the assembly
19:35:59 <xplat> that's the spirit!
19:36:13 <revenantphx> I'm already planning to design a simple language next year as an independent study
19:36:28 <Cale> revenantphx: If you want to be a programmer, study mathematics in undergrad, and learn computer science as a hobby (and perhaps do a graduate degree in CS)
19:37:01 <Eduard_Munteanu> I think a pure math undergrad is a bit too much.
19:37:10 <revenantphx> I had this pipedream idea about a language heavily influenced by economic theory...
19:37:11 <Cale> Nah, it's fun
19:37:14 <revenantphx> It was a weird idea :P.
19:37:29 <revenantphx> I'm finishing up my second year of calculus right now.
19:37:33 <Eduard_Munteanu> Mostly because I hear most math universities do physics and whatnot as applications of actual math.
19:37:35 <revenantphx> I want to get into discrete soon >_>
19:37:47 <revenantphx> Eduard_Munteanu: I'm in AP Physics B (without calculus)
19:37:47 <Cale> Pure mathematics makes a great undergraduate degree, because it's flexible, and it makes a lot of CS stuff easy to learn.
19:37:49 <revenantphx> It's terrible.
19:37:52 <tg_> Cale: unless you can find a good university
19:37:58 <Eduard_Munteanu> OTOH, CS BEngs do too little math.
19:38:01 <Cale> Yeah, you don't want to be stuck in applied mathematics courses.
19:38:16 <revenantphx> I'm interning in an applied math lab right now.
19:38:28 <revenantphx> That's what the ant sim is for.
19:38:39 <Cale> tg_: At a sufficiently good uni, they'll practically be the same thing :)
19:38:50 <gheh> discrete math is fun
19:38:51 <xplat> physics without math is like a painting class without ... paint.
19:39:14 <xplat> and by math i mean calculus
19:39:18 <revenantphx> xplat: I know, it's terrible.
19:39:32 <Cale> At Waterloo, the good CS programs give you a BMath in computer science.
19:39:51 <revenantphx> The teacher has a masters in mathematics though, he also teaches CS, but doesn't know it well enough to teach imo.
19:39:53 <Cale> (and you take a lot of the same courses as the pure mathematics students)
19:40:11 <revenantphx> But all too often in the curriculum theres a "well, we're going to pretend this is getting as big as possible"
19:40:19 <revenantphx> And then a bunch of calculus is hand-waved off.
19:40:41 <Eduard_Munteanu> Here we have kinda two sorts of CS degrees: BEng and something that's more of a BMath (it says informatics). The former doesn't cover much math, but delves into physics, electronics etc.
19:40:44 <Cale> They also have a BCS degree now, but it's more intended as a lighter thing for people who want to do a double major with a science degree.
19:40:59 <revenantphx> I'd love to do double major CS and pure math
19:41:05 <revenantphx> Something along those lines.
19:41:11 <Eduard_Munteanu> And of course the BEng takes 4 years, the other one only 3.
19:41:19 <Cale> (So people would go BCS + Biology or BCS + Physics, etc.)
19:41:21 <revenantphx> tbh, right now i don't know what I was to use any of this four, I'm just really interested in learning.
19:41:26 <revenantphx> for*
19:41:57 <revenantphx> I've seen the work style in both enterprise and academia... my conclusion is... not enough time for learning stuff :(.
19:42:03 <Eduard_Munteanu> I'm in the final year at a similar BEng focused on automation.
19:42:40 <revenantphx> I'm getting really pissed off at the AP Computer Science course right now.
19:43:05 <Eduard_Munteanu> Sadly, the math is just crammed tightly.
19:43:25 <Eduard_Munteanu> Although we need lots of linear algebra and such stuff.
19:43:39 <Cale> When I was signing up for university, I applied to Waterloo for pure mathematics, computer science, and physics, hoping that they'd make the decision for me, but I got in for all three, and then went with mathematics because it has a timelessness to it which appeals to me.
19:44:05 <revenantphx> I'm hoping I have a good resume.
19:44:11 <revenantphx> Community Service: 0
19:44:15 <revenantphx> Extracurriculars: 0
19:44:18 <Eduard_Munteanu> Do you need that?
19:44:18 <revenantphx> TT_TT
19:44:25 <Eduard_Munteanu> Here's just exams.
19:44:41 <revenantphx> Well, for high ranking colleges, they look at more than just grades.
19:44:50 <Cale> Waterloo had this really nice section on their application where you could basically describe your general interests and hobbies, and I think that helped me out a lot.
19:44:52 <xplat> in america all that is needed for a good college
19:44:53 <Eduard_Munteanu> And an average grade from highschool which matters less at important faculties.
19:44:54 <revenantphx> They don't just take "the best 100"
19:45:01 <gheh> i can't wait to graduate so that i can study on my own, tbh
19:45:09 <Cale> (I didn't have any community service or formal extracurricular stuff)
19:45:15 <Eduard_Munteanu> gheh: yeah, same here.
19:45:21 <gheh> i picked up programming on my own when i was 12 (QBASIC back then)
19:45:40 <gheh> tbh i do better learning on my own and without direction from other people 
19:45:45 <revenantphx> I have A's and B's (mostly A's) in all my courses, by senior year I'll have 7 AP credits, and I have two internships (one at an enterprise consultancy, the other at U of Pitt)
19:45:54 <xplat> partly it's philosophical, partly it's that grading is not standardized across schools and the uniform tests (SAT) don't cover all as much as they should
19:46:02 <revenantphx> The SAT is a joke.
19:46:07 <gheh> not that college was a waste of time though, i did learn a lot
19:46:12 <revenantphx> I need to make sure I take a few subject tests.
19:46:22 <Eduard_Munteanu> gheh: yeah, I don't really like how school has been teaching me stuff as well.
19:46:25 <gheh> just that i miss the freedom and the time to study in a free and explorative manner
19:46:35 <revenantphx> Ugh, I dread losing that.
19:46:51 <revenantphx> Right now I can just spend History, English and Calc II doing haskell :)
19:47:08 <revenantphx> I should probably stop in calc though, since we're actually moving on to new topics that aren't review now.
19:47:47 <Cale> revenantphx: Oh, and if you're interested in getting ahead with Calculus or mathematics in general, I recommend "Calculus" by Michael Spivak
19:47:57 <jmcarthur> gheh: more low level stuff in haskell http://potential-lang.org/   <-- i really like this one
19:47:58 <Eduard_Munteanu> Sometimes I think we should have just 4 years of elementary then university :)
19:48:00 <Cale> (If you don't mind book piracy, I can send you a PDF :P)
19:48:01 <gheh> i need to review integration methods for my physics course..
19:48:02 <jmcarthur> haven't used it though
19:48:11 <revenantphx> While I like differential/integral calculus to be honest... it's not my favorite thing.
19:48:23 <jmcarthur> gheh: it says it's a language, but it's actually embedded in haskell
19:48:24 <luite> Cale: do you have a non-scanned one?
19:48:24 <revenantphx> I like it better than geometry or trigonometry, but it really doesn't ring with me.
19:48:27 <xplat> history class in the USA is a joke.  studied the revolutionary war 10 times, civil war 5, and not much else worth relating
19:48:32 <Cale> luite: yes
19:48:38 <revenantphx> Cale: calculus isn't something I care to read books about.
19:48:41 <Cale> I have the original that it was printed from :)
19:48:46 <luite> ooh send me :p
19:48:54 <revenantphx> History in the USA is not a class in facts (unless you take the AP course).
19:49:02 <Cale> revenantphx: Well, this is actually not really Calculus as such, but mathematical analysis :)
19:49:05 <jmcarthur> gheh: here's a cool thing it can do http://potential-lang.org/2010/07/02/quasi-quoting-ascii-art-to-define-data-structures/
19:49:07 <revenantphx> oh, I see.
19:49:11 <revenantphx> It's a course in knowing the large events, some trends, and bullshitting the rest.
19:49:39 <Eduard_Munteanu> Most of my 12 years of pre-university school have been a major waste of time.
19:49:55 <Cale> Okay, this link will be probably really slow for the next hour or so, since I'm uploading to YouTube atm.
19:50:01 <Cale> http://cale.yi.org/share/Michael%20Spivak%20-%20Calculus.pdf
19:50:12 * jmcarthur DoSes Cale
19:50:19 <Cale> (but give it a try :)
19:50:20 <luite> what are you uploading? a zen magnets construction? :)
19:50:27 <Cale> luite: yep :)
19:50:32 <Cale> two, actually
19:50:40 <xplat> revenantphx: there's a point of view from which calculus is incredibly natural and useful outside of its original field, but they don't teach it in actual calculus classes
19:50:44 <Cale> Or, two videos, maybe 4 or 5 constructions
19:50:46 <luite> hehe I found it funny that you said that knowing mathematics was like cheating :)
19:50:55 <Cale> heh, yeah
19:51:15 <revenantphx> xplat: For instance, I have a friend who is incredibly talented at calculus, and he uses it regularly for physics based problems.
19:51:45 <revenantphx> He's like me, except with calculus. (he builds rockets as a hobby)
19:52:14 <Eduard_Munteanu> How's pre-univ math in US? Here we even do some abstract algebra in the last year of highschool, and calculus (integration and such).
19:52:30 <revenantphx> Eduard_Munteanu: It's kind of sad.
19:52:38 <revenantphx> The expectation is usually Calculus I during the last year.
19:52:44 <revenantphx> Which is differential/integral.
19:52:47 <Cale> Eduard_Munteanu: It's awful. Terrible here in Canada as well.
19:52:56 <xplat> actually there are 4 or 5 good ways of thinking about calculus.  infinitesimals and analytic limits are the ones that get taught, but there are also commutators and hole-punching
19:52:59 <revenantphx> It's really bad to be honest.
19:53:05 <revenantphx> xplat: hm?
19:53:07 <Eduard_Munteanu> Oh, I see.
19:53:10 <revenantphx> I know infinitesimals.
19:53:16 <Cale> In fact, I almost wish they wouldn't even try to teach anything called "math" in highschool if they're going to fuck it up that badly.
19:53:27 <revenantphx> Seriously.
19:53:44 <xplat> oh, and there are 3 different ways to think of infinitesimals, too
19:53:44 <revenantphx> Do you guys have any recommendations for books I should reach math/cs wise?
19:53:48 <revenantphx> I have chrismtas money soon.
19:53:55 <revenantphx> xplat: I think I know 2 :P
19:54:01 <luite> what kind? textbooks, recreational?
19:54:08 <revenantphx> either way.
19:54:10 <Eduard_Munteanu> *sigh* and I wonder why kids don't like math these days. Of course they don't if it's all about calculation and less about insight.
19:54:19 <revenantphx> Eduard_Munteanu: yep :\
19:54:29 <revenantphx> The worst thing is, the contrived science curriculum that's being pushed.
19:54:39 <revenantphx> Basically, they want to order them Physics -> Chem -> Bio for some reason.
19:54:52 <Cale> revenantphx: As a sort of compromise between a recreational book and a textbook, you should definitely read "Gdel, Escher, Bach: An Eternal Golden Braid" by Douglas Hofstadter
19:54:52 <revenantphx> But Calc is not usually taught till the last two years... 
19:55:00 <revenantphx> so physics is dumbed down a lot.
19:55:01 <Eduard_Munteanu> Ah, that's bad.
19:55:07 <revenantphx> AP Physics C is what I wish I could take.
19:55:10 <Cale> revenantphx: It probably influenced the course of my life more than any other book :)
19:55:40 <Eduard_Munteanu> Seriously it's a waste of time to reteach physics over and over and over, you might as well introduce elementary calculus in earlier years.
19:55:45 <revenantphx> It's kinematics, basic fluid mechanics, wave mechanics and and electromagnetics, with calculus.
19:55:49 <revenantphx> Basic introductory stuff.
19:55:58 <xplat> revenantphx: infinitesimals are: algebra on a nilpotent element, ultrapowers, tangent bundles (aka normal differential geometry), synthetic differential geometry
19:56:01 <revenantphx> The one I'm in, Physics B, is the same except without calculus.
19:56:02 <jmcarthur> Cale: i read about half of it and can't really say it has affected me quite the same way...
19:56:08 <revenantphx> xplat: you've confused me.
19:56:08 <gheh> CS students here are required to take 3 physics courses and 2 physics electives
19:56:17 <gheh> to be honest, I'm not very good at physics (not horrible though)
19:56:20 <jmcarthur> Cale: i mean, it's interesting and all, but... maybe i'm just missing something
19:56:29 <gheh> astrophysics kicked my ass
19:56:44 <xplat> revenantphx: that's because i've only named them, not explained them
19:56:46 <Cale> jmcarthur: It's probably better read when you're still a muggle :)
19:56:48 <revenantphx> Oh, my school library has that book.
19:56:53 <revenantphx> I should go chek it out.
19:57:01 <revenantphx> I remember seeing it and thinking it sounded amusing.
19:57:27 <jmcarthur> Cale: ah, so you mean it turned you on to... that certain kind of thinking?
19:57:42 <Cale> To a fair degree, yeah.
19:58:07 <jmcarthur> i do still want to finish it
19:58:08 <Cale> Or at least, the nice way that it connected things together convinced me that mathematics was the right thing to be studying.
19:58:15 <jmcarthur> ah
19:58:28 <Eduard_Munteanu> gheh: hm we have like 3 math courses (analysis, linear algebra, diff eqs), and only one physics. But then there are other math/physics-related courses, like numerical algorithms and analog electronics respectively.
19:58:29 <luite> revenantphx: hmm, I really loved GEB as well... if you're lookign for something on calculus and its development, I liked The Calculus Gallery by William Dunham
19:58:29 <xplat> revenantphx: i can explain the ways of thinking of calculus and infinitesimals if you'd like, but not now unfortunately, no time :I
19:58:42 <jmcarthur> what i've read of it was quite beautiful and entertaining
19:58:44 <Eduard_Munteanu> But little physics there.
19:59:09 <Cale> Of course, if you already know lots of mathematical logic and model theory and such, you're going to find the first half of it drags on a bit :)
19:59:17 <revenantphx> Those zen magnets are going on my christmas list 0.o
19:59:31 <revenantphx> Just need to keep them away from my electronics >_>
19:59:34 <jmcarthur> i still enjoyed it
20:00:04 <jmcarthur> electronics are tougher against magnets than you might think
20:00:11 <Cale> revenantphx: http://www.flickr.com/photos/cgibbard/ -- my constructions :)
20:00:20 <revenantphx> mm, a thin ipod with an SSD is not.
20:00:27 <Cale> revenantphx: I find they don't really affect electronics as much as people would expect
20:00:34 <jmcarthur> i don't know how resistant SSDs are to magnets
20:00:37 <luite> hmm, I don't think SSD's are very much affected by magnets?
20:00:37 <revenantphx> :O
20:00:47 <Eduard_Munteanu> Yeah, only particular electronic devices can get hurt by magnets, like HDDs, CRT displays.
20:00:56 <revenantphx> oh, true
20:00:58 <Cale> revenantphx: Obviously you wouldn't want to stick a bunch of them directly on your hard drive.
20:01:02 <revenantphx> mm.
20:01:05 <orlandu63> i put an earth magnet against my ipod and all it did was reset it; no data loss
20:01:07 <jmcarthur> Eduard_Munteanu: even HDDs need *very* strong magnets to mess them up
20:01:11 <revenantphx> They are quite neat though :3
20:01:20 <luite> orlandu63: hdd or flash based ipod?
20:01:26 <orlandu63> flash-based
20:01:27 <revenantphx> I keep wondering whats going to happen when the magnetic poles reverse...
20:01:28 <Cale> revenantphx: But I've had them stick to my iPod by accident with no ill effects.
20:01:28 <jmcarthur> hard drives pretty much *are* strong magnets
20:01:32 <revenantphx> its scheduled to happen pretty soon.
20:01:45 <Cale> (and I can get the camera right up close to them)
20:01:50 <Eduard_Munteanu> jmcarthur: yeah, same for CRTs.
20:02:00 <jmcarthur> CRTs mess up more easily, in my experiences
20:02:09 <Cale> Yeah, hard drives contain *giant* neodymium magnets
20:02:10 <Eduard_Munteanu> I remember using a soldering gun to degauss an older computer display.
20:02:21 <xplat> HDDs used to be affected by much weaker magnets, but the newer ones are low-susceptibility so they can record at a higher density
20:02:29 <Cale> which would outpower all but the largest aligned bars of these
20:02:34 <Eduard_Munteanu> It was a big thing with a transformer inside.
20:02:51 <Cale> When working with the magnet spheres, you generally keep the magnetic ends tied nicely into loops
20:03:03 <Cale> and so the outside of the structures isn't very magnetic
20:03:39 <xplat> these days it's more likely a magnet would ruin an HDD by crashing the head than by affecting the platters directly
20:04:09 <luite> hehe zen magnets says that you only need to contact a doctor if you swallow more than 1 magnet :)
20:04:22 <Eduard_Munteanu> I suppose a slightly magnetic screwdriver isn't that dangerous around them/
20:04:33 <jmcarthur> no, not at all
20:04:36 <xplat> er, i think you might want to contact a doctor anyway ....
20:04:39 <revenantphx> One day I was at my friends house and he was on his computer.
20:04:43 <revenantphx> And I was sitting bored against the wall...
20:04:53 <jmcarthur> interesting friend
20:04:54 <revenantphx> and I noticed the side of his computer was slightly misaligned.
20:05:00 <revenantphx> He was looking up some stuff.
20:05:00 <Eduard_Munteanu> :))
20:05:01 <Cale> Yes, no matter how delicious they look, you don't want to eat them :)
20:05:09 <revenantphx> So I pulled it off.
20:05:18 <revenantphx> And I was looking at the inside while he looked up movie times.
20:05:32 <revenantphx> And he was liek "okay its at 8:30", I responded "good, now I can do this"
20:05:40 <revenantphx> and then proceeded to stick my finger onto the leads of his CPU.
20:05:44 <revenantphx> (this was a bad idea)
20:05:53 <Cale> lol
20:05:56 <revenantphx> Light little zap (nothing much) and it went black.
20:05:56 <adnap_> wtf
20:06:10 <jmcarthur> you're kind of an ass, aren't you? ;)
20:06:13 <revenantphx> :P
20:06:16 <revenantphx> It was an old Dell he was about to replace.
20:06:21 <revenantphx> He laughed, it was fine.
20:06:42 <Cale> Did it power back on, or did the short kill it?
20:06:54 <revenantphx> It powered back up.
20:07:00 <adnap_> I'm imagining one of those classic scenarios where you're both nervously laughing and the... FIGHT TO THE DEATH
20:07:08 <revenantphx> pretty much
20:07:21 <Eduard_Munteanu> I think it's static electricity that kills this stuff.
20:07:33 <revenantphx> There was this great moment where he looked down at me as I said it, and then heard the sound of the CRT dying, looked up, then looked back down realizing where my finger was.
20:07:53 <Cale> haha
20:08:07 <revenantphx> It was a Pentium III, no great loss if it had died.
20:08:38 <Eduard_Munteanu> Interestingly I can immediately tell if a TV is on in a near room just by the ultrasound.
20:08:55 <revenantphx> Same.
20:09:04 * jmcarthur too
20:09:14 <orlandu63> how can you sense ultrasound?
20:09:18 <jmcarthur> well, not LCDs
20:09:20 <revenantphx> It's not ultrasound really.
20:09:28 <Eduard_Munteanu> Yeah, it gets harder when you're older.
20:09:31 <jmcarthur> to some people it is
20:09:32 <revenantphx> But with CRT's you can hear that high-frequency sound.
20:09:33 <Cale> Eduard_Munteanu: I can tell as well
20:09:42 <jmcarthur> i hate that sound
20:09:45 <luite> I thought it was around 16kHz
20:09:45 <revenantphx> I'm worried I have tinnitus or something.
20:10:01 <Eduard_Munteanu> I think it's specific to TVs, not computer displays.
20:10:01 <luite> for regular tv's
20:10:01 <revenantphx> I can here 17khz with a lot of difficulty.
20:10:05 <Cale> Yeah, me too, it's awful.
20:10:06 <revenantphx> I tested this yesterday actually.
20:10:07 <orlandu63> wikipedia says 20kHz
20:10:18 <revenantphx> when it's really really quiet, I can here that ring like a CRT all the time.
20:10:21 <revenantphx> Is this normal > >?
20:10:30 <Eduard_Munteanu> *TV CRTs
20:10:34 <Cale> We replaced our TV with an LCD recently, and so I don't have to put up with it anymore :)
20:10:45 <luite> Eduard_Munteanu: yeah it depends on the horizontal scan frequency
20:10:57 <Eduard_Munteanu> Oh.
20:11:01 <jmcarthur> at my last job they bought a couple of these and it sucked http://www.thinkgeek.com/gadgets/electronic/8c52/
20:11:09 <Eduard_Munteanu> Because it's interlaced and it uses lower frequencies?
20:11:22 <Cale> revenantphx: At a certain point of quietness, apparently you can hear noise in your nervous system.
20:11:29 <revenantphx> Maybe thats it :\
20:11:52 <revenantphx> It's definitely REALLY quiet
20:11:52 <luite> tell your nervous system to be less noisy :p
20:11:52 <jmcarthur> oh and btw, those nice, expensive bose noise cancellin headphones that are really awesome and block all noise? guess what happens if you are wearing those when an annoyatron goes off? yeah, you guessed it, they *amplify* it
20:12:09 <revenantphx> I can listen to my music at 1/2 a volume incrmenet (OS X), when in normal school conditions I need 4 or 5
20:12:13 <Eduard_Munteanu> Annoyatron?
20:12:18 <revenantphx> jmcarthur: hahahahaha
20:12:20 <jmcarthur> Eduard_Munteanu: http://www.thinkgeek.com/gadgets/electronic/8c52/
20:12:26 <tg_> what about klystrons?
20:12:39 <Eduard_Munteanu> Ah, heh.
20:12:52 <jmcarthur> actually i think these are the ones they had http://www.thinkgeek.com/gadgets/electronic/b278/
20:13:14 <jmcarthur> oh, nope, it was the old one, nevermind
20:13:34 <luite> do those active noise cancelling headphones block much more than regular in-ear headphones (like those made by shure)?
20:13:55 <revenantphx> luite: they dont block, they produce out-of-phase waves that cancel out noise.
20:14:01 <luite> yeah I know
20:14:10 <jmcarthur> luite: they are amazing
20:14:12 <revenantphx> Oh, I'd imagine they do simply because they're additionally cushioned.
20:14:19 <revenantphx> i had some non-noise cancelling bose over ears.
20:14:28 <revenantphx> They were great even without NQ
20:14:30 <revenantphx> NC*
20:14:35 <Draconx|Laptop> luite, it's quite surreal when you first put them on.
20:14:41 <revenantphx> mm
20:14:46 <revenantphx> You know those post cards that make noise or play a song when you open them?
20:15:01 <luite> revenantphx: the higher end shure headphones have foam plugs, which already block a lot
20:15:07 <revenantphx> mm nice
20:15:21 <luite> much more than the cheaper sennheiser or creative headphones
20:15:33 <luite> have never tried the active once though
20:15:34 <revenantphx> This channel is so knowledgeable.
20:15:35 <luite> ones
20:15:42 <jmcarthur> luite: i was on a very noisy economy class plane once. it was so noisy that my voice distorted beyond recognition when i tried to talk. these noise cancelling headphones pretty much completely blocked it
20:15:46 <luite> revenantphx: off-topic too :p
20:15:55 <Cale> http://www.youtube.com/watch?v=4WZmEefkeBE :)
20:16:12 <revenantphx> Cale... I like your balls.
20:16:15 <jmcarthur> luite: i tried normal headphones immediately before that and they couldn't even play music because the noise was pusing the diaphrams harder than the magnets could
20:16:16 <revenantphx> They're shiny.
20:16:18 <Eduard_Munteanu> LOL
20:16:27 <luite> no sound?
20:16:28 <luite> oh wait
20:16:31 <revenantphx> You obviously take good care of them.
20:16:35 <luite> I tripped over my headphone wire
20:17:00 <Eduard_Munteanu> @remember revenantphx Cale... I like your balls. They're shiny. You obviously take good care of them.
20:17:00 <lambdabot> Done.
20:17:09 <revenantphx> :D
20:17:13 <revenantphx> I've been quoted! Happy day!
20:17:23 <unkanon> so what's a link for a good headphone that does all that (the cushion, the noise cancelling, etc)? I'm only seeing links for annoyatrons :)
20:17:58 <revenantphx> Cale: a set of 216 of these is certainly on my list this year..
20:18:05 <jmcarthur> unkanon: http://www.bose.com/controller?url=/shop_online/headphones/noise_cancelling_headphones/index.jsp
20:18:10 <luite> wow those bridges are much sturdier than I expected
20:18:35 <Cale> I haven't really found a very comfortable way to make videos of magneting. The camera I'm using is really more intended for taking photos and I can choose between autofocus from hell, or 0.5m focal point blur.
20:18:49 <revenantphx> autofocus from hell is right.
20:18:58 * jmcarthur watches the video of Cale showing off his balls
20:19:06 <revenantphx> :)
20:19:13 <revenantphx> Cale, your balls are very popular in this channel.
20:19:22 <Cale> haha
20:19:33 <Cale> I should get some of you guys to idle in #magnets
20:19:34 <luite> mapM makeTetrahedron
20:19:53 <revenantphx> Cale: quick! Write an OpenGL/Haskell virtual magnet set!
20:19:55 <Cale> I've been trying to get the channel going, there are a few people from flickr that occasionally stop by.
20:20:33 <revenantphx> I'm entranced by your balls, seriousl.
20:20:34 <unkanon> jmcarthur: thanks
20:20:39 <Axman6> oh man, i've got a friend who'd love that
20:21:08 <Cale> It would be nice to write a B field simulator. I think it would probably improve my understanding of that bit of physics a good deal :)
20:21:09 <revenantphx> I'm seriously considering jumping for the big set now TT_TT, but I fear *all of my free time would die*
20:22:18 <Cale> revenantphx: If you submit photos to the zen magnets gallery, for each 3 they accept, you get a free set of 216
20:22:21 <luite> what's the big set? 2160?
20:22:31 <revenantphx> Cale: hah.
20:22:35 <Cale> 12^3 = 1728
20:22:41 <revenantphx> How many have you gotten?
20:23:06 <Cale> I'm up to 12^3 + 4*6^3 = 2592
20:23:12 <revenantphx> So, one thing I wonder.
20:23:26 <revenantphx> I always get pissed off when magnets shiny coating comes off, are these *actually just shiny*?
20:23:30 <Cale> (I've been winning 2 free sets/month since I got them)
20:23:37 <Cale> These are actually just shiny
20:23:42 <revenantphx> Cale: Wow, you're really good with your balls.
20:23:50 <revenantphx> And you're good at showing them off.
20:23:50 <Cale> They're not coated
20:23:57 <Cale> heh
20:24:12 <revenantphx> "How Magnetting is Like Being a Porn Star", by revenant
20:24:28 <djahandarie> Cale, what is your favorite number of magnets? You mentioned it once but I don't remember
20:24:35 <Cale> 2160
20:24:46 <Cale> Or, multiples of 1080 really
20:25:18 <Cale> 1080 magnets "want" to become a structure with icosahedral symmetry
20:25:48 * Eduard_Munteanu wonders what Cale's Erdos number is, if applicable :)
20:25:57 <tg_> djahandarie: the number that the LHC has
20:25:59 <Eduard_Munteanu> I know I don't have one.
20:26:02 <Cale> Infinity, probably.
20:26:02 <revenantphx> I'm sorry, but I think this guy is missing the point Cale
20:26:03 <revenantphx> I'm guessing the gender balance in here
20:26:05 <tg_> their magnets > your magnets
20:26:05 <revenantphx> http://www.youtube.com/watch?v=c0fHLXG7jug&feature=related
20:26:07 <revenantphx> wrong paste.
20:26:12 <revenantphx> >_>
20:26:18 <revenantphx> I liked the icosahedrons *way* more.
20:27:50 <Eduard_Munteanu> I'd think these days it isn't hard to get a less-than-infinity Erdos number if you publish a couple of papers in math.
20:28:12 <luite> it would be hard to keep your infinity number :p
20:28:28 <Cale> My strategy for magneting has basically been to always start from hexagons, usually 2-layer hexagons because anything larger is a bit wasteful, and then folding those up in some fashion, attaching sets of 3, 4, 5 (or occasionally 6) identically-folded hexagons in a symmetric fashion, and then using that as the face or vertex figure for a construction with an appropriate symmetry group.
20:28:30 <luite> unless you're the only author of all your papers
20:28:46 <Eduard_Munteanu> luite: yeah, in which case you don't have an Erdos number: )
20:29:10 <luite> oh is that different from infinity?
20:29:11 <tg_> unless you're paul Erdos
20:29:13 <Axman6> Cale: ... that video was awesome :D
20:29:19 <Eduard_Munteanu> Yeah.
20:29:38 <Cale> There's another video which is currently uploading too.
20:29:39 <Eduard_Munteanu> Infinity == no chain of connections with Erdos.
20:29:41 <luite> oh I'm not really familiar with the algebra of Erdos numbers :p
20:30:07 <Cale> (It'll be about 21 min apparently)
20:32:02 <Eduard_Munteanu> Hm, things settled down... perhaps somebody knows how to make this faster? http://paste.pocoo.org/show/300092/
20:32:39 <Eduard_Munteanu> It currently runs in 1m20s on a 512MiB file generated from /dev/urandom. I have reasons to believe it's possible to get under 1m.
20:32:42 <Cale> Other numbers of magnets which I run into a lot in my constructions are 720 and 1440
20:33:42 <Cale> I hate how almost every website seems to be incompetent when it comes to quoting and unquoting strings.
20:34:09 <adnap_> is there any sort of function that cleans up a fold inside a map?
20:34:12 <Axman6> “what do you mean''?
20:34:27 <Axman6> adnap_: cleans up?
20:34:44 <Axman6> oh, when you're doing map (fold...)?
20:34:49 <adnap_> Yeah
20:34:52 <Cale> Flickr will automatically turn URLs into links which if they happened to contain a %20 in them, the automatic links somehow get destroyed if you reopen the text for editing and then save it again.
20:34:54 <adnap_> Want me to paste code?
20:35:54 <adnap_> http://hpaste.org/42059/form_factors
20:37:03 <Cale> adnap_: If you put maps and folds together, the fusion rules in the list library will tend to combine them -- so from an efficiency perspective, it's not a problem
20:37:39 <adnap_> Cale: But is there a clean way to combine them?
20:39:23 <Cale> adnap_: Perhaps not in the particular way that you have them there, but I would consider taking the foldl there and defining that as a separate function on its own...
20:39:41 <Cale> adnap_: (I'd also consider using foldl')
20:39:56 <adnap_> Cale: Okay.  I'm not familiar with foldl'.  I'll check it out.
20:40:16 <Cale> adnap_: It's just foldl, but strict in the accumulating parameter
20:40:33 <adnap_> Cale: Strict?
20:40:49 <Cale> adnap_: So, while foldl will build up a large expression in the accumulating parameter, foldl' will do a bit of evaluation to it on each step
20:40:50 <Eduard_Munteanu> adnap_: as opposed to lazy. It's always evaluated.
20:40:59 <Cale> (up to determining the top-level constructor)
20:41:07 <Eduard_Munteanu> It's faster in many cases.
20:41:12 <adnap_> Hm...
20:41:20 <adnap_> Why is it faster?
20:41:20 <Eduard_Munteanu> and doesn't overflow the stack in others.
20:41:24 <Cale> Well, not just faster. It prevents things like stack overflows from happening
20:41:43 <Cale> In the case that the combining function you're applying is strict.
20:41:46 <adnap_> Wow, thank you very much for the tip.  I might not have caught that right away.
20:42:09 <Axman6> stopping stack overflow should be looked at as the main reason to use foldl', better performance is secondary
20:42:09 <Cale> The stack in GHC Haskell consists of pattern matches which are waiting to happen.
20:42:24 <revenantphx> aw we're all on topic again.
20:42:24 <Eduard_Munteanu> Good, I'm down to 1m13.625s with $ time ./very_simple +RTS -s -H128m
20:42:26 <adnap_> Wait, but I'm folding over something that's 10 elements large.
20:42:37 <adnap_> I have a question.
20:42:41 <Cale> adnap_: Then it doesn't matter
20:42:47 <Cale> adnap_: You could even just use a foldr :)
20:42:56 <adnap_> Will the fold be evaluated for each element when I'm mapping?
20:43:00 <Eduard_Munteanu> But it's still worse than intentionally stupid C code.
20:43:10 <Eduard_Munteanu> (that is, around 1m)
20:43:34 <Cale> Eduard_Munteanu: I still don't *really* understand what your code is actually doing.
20:43:56 <revenantphx> int i = 1000000000;
20:43:56 <revenantphx> void* ptr;
20:43:56 <revenantphx> while(ptr = malloc(i)){ i--; free(ptr); }
20:43:57 <adnap_> Also, why would I want to use foldr as opposed to foldl?
20:44:11 <Cale> adnap_: Well, foldr can handle infinite lists, for one
20:44:24 <Cale> adnap_: foldr is actually what you usually want to use
20:44:45 <Cale> It has a natural interpretation of replacing the list constructors with other values
20:44:52 <Eduard_Munteanu> Cale: basically lots of tree traversals and consing. Then it sums all the results. It's easy to find a real application in my Shannon-Fano implementation.
20:45:00 <Cale> foldr f z will replace each (:) with f and the [] at the end (if any) with z
20:45:47 <adnap_> It is kind of scary that there are such subtle differences between foldl and foldr.  I guess that
20:45:48 <Cale> Eduard_Munteanu: Your Haskell code is running within 100% of the performance of the C code for the simple program though, so that's not bad.
20:46:01 <adnap_> I guess that's one of the downsides of a very high-level language.
20:46:17 <Cale> > foldr (++) [] [[k,10*k] | k <- [1..]]
20:46:18 <lambdabot>   [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,1...
20:46:26 <Cale> > foldl (++) [] [[k,10*k] | k <- [1..]]
20:46:31 <lambdabot>   mueval-core: Time limit exceeded
20:46:33 <revenantphx> oh, one thing Cale...
20:46:35 <Cale> ^^ fail
20:46:57 <Eduard_Munteanu> Yeah, but I still don't get good results on my actual application.
20:46:57 <Cale> adnap_: If you think about what foldl actually does, it makes no sense to apply it to an infinite list
20:46:58 <kadoban> so is there often any reason to use foldl, rather than either foldr or foldl' ?
20:47:07 <revenantphx> would you recommend, using your better lazy IO, that I stick my state inside Port, or pass it alongside, or use State
20:47:08 <Cale> Eduard_Munteanu: Right.
20:47:09 <Eduard_Munteanu> Oh wait, I forgot I was willing to runST inside the lookup.
20:47:26 <Eduard_Munteanu> That would do well with unboxed types.
20:47:55 <Cale> kadoban: Well, in the rare case that you really want the traversal order of foldl, but the combining function is non-strict, or at least is able to produce some of its result without looking at the entirety of its input.
20:48:17 <Cale> kadoban: reverse is such an example
20:48:26 <Eduard_Munteanu> *actually putting all my lookups in a single ST.
20:48:53 <kadoban> ahh, i see.  thanks, i'll take a glance at reverse.  been thinking of that for a while, and couldn't think of much reason
20:48:58 <adnap_> Cale: When I have a non-strict fold inside a map, does the fold get fully evaluated for each element while I'm mapping?
20:48:58 <Cale> revenantphx: You could make another datatype for your state and pass it around in a similar way, and just include a Port in it.
20:49:08 <revenantphx> Cale: true.
20:49:28 <Cale> adnap_: Not necessarily
20:49:37 <Cale> adnap_: In fact, it might not be evaluated at all.
20:49:57 <Cale> adnap_: map f xs produces a list without evaluating f at all
20:50:07 <Cale> > length (map undefined [1..10])
20:50:09 <lambdabot>   10
20:50:10 <adnap_> crap
20:50:21 <adnap_> I need to consider than when I'm mapping over potentially large lists then
20:50:32 <Cale> It's usually a good thing
20:50:42 <adnap_> So, I assume there's a foldr', which I ought to use?
20:50:47 <Cale> Note that the map itself is also lazy
20:50:50 <Cale> No.
20:50:58 <Cale> foldr' doesn't really make much sense usually.
20:51:15 <Cale> (It could exist, but it'd almost never be what you want)
20:51:32 <Cale> If you want foldr, you usually don't want extra strictness, or you don't care
20:51:39 <Cale> With 10 element lists, you don't need to care
20:51:46 <adnap_> But I do care
20:51:56 <adnap_> because I'm mapping that fold over a thousand element list
20:52:03 <adnap_> or larger
20:52:05 <jmcarthur> ha! http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector.html#v:foldr-39-
20:52:16 <adnap_> Right?
20:52:17 <Cale> adnap_: That's fine -- and somewhat irrelevant :)
20:52:41 <Cale> adnap_: The strictness matters in the case of foldl' because it avoids problems with the depth of the individual fold
20:52:49 <revenantphx> Cale: wait... how do I create the Port at the beginning?
20:52:50 <Cale> Let's look at a concrete example to see
20:52:59 <adnap_> Okay, good.  I'm so confused.
20:53:17 <adnap_> So, foldr does a bunch of :'s right?
20:53:27 <Cale> revenantphx: lazily read the file and use newIORef with the lazy ByteString you get
20:53:31 <adnap_> And what does foldl do?  []'s?
20:53:33 <revenantphx> Port{inputRef = newIORef (hGetContents handle), outputHandle = handle)
20:53:35 <revenantphx> }
20:53:46 <Cale> revenantphx: Not quite -- do the newIORef beforehand
20:53:53 <adnap_> Agh
20:53:59 <revenantphx> mmk
20:54:02 <Cale> revenantphx: What you have there would be storing the action to make the new IORef inside the structure
20:54:05 <revenantphx> right.
20:54:22 <Cale> adnap_: Let's take a look at foldl (+) 0 [1,2,3]
20:54:26 <Cale> and evaluate it by hand
20:54:30 <Cale> @src foldl
20:54:30 <lambdabot> foldl f z []     = z
20:54:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:54:39 <Cale> foldl (+) 0 [1,2,3]
20:54:46 <Cale> -> foldl (+) (0 + 1) [2,3]
20:54:52 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
20:54:58 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
20:55:05 <Cale> -> ((0 + 1) + 2) + 3
20:55:10 <adnap_> yeah
20:55:19 <adnap_> So, left-associative
20:55:21 <revenantphx> @hoogle hGetContents
20:55:22 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
20:55:22 <lambdabot> System.IO hGetContents :: Handle -> IO String
20:55:22 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
20:55:25 <Cale> Up to this point, our pattern matches have all succeeded immediately, and so there's no need to use the stack
20:55:27 <Cale> But now
20:55:33 <Cale> The outermost + here
20:55:37 <Cale> (...) + 3
20:55:40 <revenantphx> I want the one in Lazy ByteString no?
20:55:44 <Cale> can't do its work until (...) is evaluated
20:55:49 <Cale> So it goes on the stack
20:55:59 <Cale> and we continue evaluation with (0 + 1) + 2
20:56:00 <adnap_> ohh
20:56:27 <Cale> (you can see (+) as pattern matching on both its arguments, making it strict)
20:56:27 <revenantphx> I could just make a mkPort constructor to do this for me :\
20:56:34 <Cale> revenantphx: yes, you should
20:56:55 <revenantphx> newIOPort probably?
20:57:04 <Cale> revenantphx: Or just newPort
20:57:05 <Sic[NOH8]> wow there's tons of niggers in here
20:57:10 --- mode: ChanServ set +o Cale
20:57:11 <revenantphx> yeah, since it's only going to be there.
20:57:13 -Sic[NOH8](~sicasssfu@173-30-206-121.client.mchsi.com)- /\ A HOT SEX STORY /\
20:57:14 --- mode: Cale set +b *!*@173-30-206-121.client.mchsi.com
20:57:14 --- kick: Sic[NOH8] was kicked by Cale (Sic[NOH8])
20:57:20 <revenantphx> That was fst.
20:57:20 --- mode: Cale set -o Cale
20:57:21 <adnap_> so, with foldr I have (0 + (1 + (2 + 3)))
20:57:23 <revenantphx> Good job.
20:57:31 <Cale> adnap_: yes, and the same problem, as it happens
20:57:41 <Cale> adnap_: Because (+) is strict in *both* its arguments
20:57:46 <Cale> foldr (+) 0 [1,2,3]
20:57:48 <Axman6> well  1 + (2 + (3 + 0))
20:57:56 <Cale> -> 1 + foldr (+) 0 [2,3]
20:58:05 <revenantphx> Why does fold remind me so much of lisp---
20:58:20 <Cale> now, if we could imagine (+) being able to produce part of its result without using its second parameter
20:58:21 <revenantphx> I just got a bad feeling I shouldn't have said that.
20:58:22 <dolio> @karma lisp-
20:58:22 <lambdabot> lisp- has a karma of -1
20:58:26 <Cale> then this might stop here
20:58:29 <Cale> yeah?
20:58:32 <dolio> @karma+ lisp-
20:58:33 <lambdabot> lisp-'s karma raised to 0.
20:58:53 <Cale> (maybe we should move to #haskell-overflow or something
20:58:55 <Cale> )
20:58:59 <adnap_> huhk
20:59:00 <adnap_> k
20:59:03 <adnap_> lol
20:59:11 <Cale> Well, whatever ;)
21:01:11 <revenantphx> if this right Cale
21:01:12 <revenantphx> iref <- L.hGetContents h >>= newIORef
21:01:22 <revenantphx> (since hGetContents returns an IO ByteString)
21:01:28 <revenantphx> is this right*
21:02:00 <Cale> yes, though it'll look nicer if you flip it over
21:02:13 <Cale> iref <- newIORef =<< L.hGetContents h
21:02:14 <revenantphx> :t (>>=)
21:02:14 <revenantphx> :t (=<<)
21:02:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:02:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:02:18 <revenantphx> they're just flips?
21:02:20 <Cale> yep
21:02:27 <revenantphx> wonderful.
21:02:35 <revenantphx> I think the sugar is starting to make a lot more sense now.
21:02:58 <revenantphx> I'm definitely starting to see how do translates to bind notation
21:04:05 <BMeph> Didn't ezyang talk about that in his blog today? :)
21:04:15 * monochrom was stumped by an interesting combination of forkIO and block. now solved and understood.
21:04:37 <revenantphx> So er, do you guys have any book recommendations?
21:05:06 <revenantphx> I got like 2...
21:05:38 <byorgey> lots.  what do you want to learn about?
21:05:47 <Gracenotes> everything
21:05:49 * monochrom was doing this in the spirit of "safe alloc-dealloc idiom": bracket (forkIO long_time) (killThread) (\_ -> wait for an mvar)
21:05:50 <Gracenotes> bagels
21:05:56 <byorgey> you have only 2 books?
21:06:28 <Gracenotes> The Name of the Rose is turning out to be quite good
21:07:15 <monochrom> now the problem: because forkIO inherits exception-blocking state, and bracket runs (forkIO long_time) in exception-blocking mode, therefore the new thread also blocks all exceptions. now it is unkillable.
21:08:38 <revenantphx> grr, ghc is fialing.
21:08:58 <revenantphx> byorgey: I mean, I need some recommendations on books to get.
21:09:24 <revenantphx> I don't have much a shelf beyond a bunch of OpenGL, C and algorithm related books 
21:09:44 <revenantphx> by bunch I mean like under 10.
21:09:53 <Gracenotes> I like this book too http://www.amazon.com/dp/0226685349/
21:10:08 <revenantphx> god dammit bash, stop being case insensitive
21:10:21 <revenantphx> when I type "touch amity" I don't want it touching the directory Amity
21:10:26 <revenantphx> NOTICE THE CAPITAL LETTER >:(
21:10:52 <Gracenotes> bash? case insensitive? :o .. really?
21:10:59 <revenantphx> somethings screwed up.
21:10:59 <kadoban> ya, seriously..since when?
21:11:03 <revenantphx> It shouldnt be.
21:11:06 <byorgey> revenantphx: right, but what sorts of books do you want recommendations on?  what do you want to read/learn about?
21:11:08 <BMeph> Ah, 1) Nicholas Wu; 2) Two days ago.
21:11:12 <revenantphx> byorgey: idk ><
21:11:13 <luite> revenantphx: there was a "recreational math books you'd buy for your aunt" thread on mathoverflow some time ago, which contained some good suggestions (although most people there seem the assume that all aunts are familiar with things like integration by parts or the axiom of choice)
21:11:19 <revenantphx> haha.
21:11:42 <revenantphx> I know integration by parts, but not the axiom of choice...
21:11:46 <revenantphx> I need to learn some discrete.
21:11:47 <byorgey> Types and Programming Languages by Benjamin Pierce is nice
21:11:50 <Gracenotes> it is very nice
21:11:53 <tg_> luite: Dear Auntie May: Could you please let me know if the Possion bracket of p with the Hamiltonian is equal to 0?
21:12:04 <Gracenotes> its chapter on induction and coinduction blew my mind a little.
21:12:20 <revenantphx> adding to list
21:12:32 <Gracenotes> er well more than the other chapters, by a good margin
21:12:36 <tg_> P.S. I loved the gingerbread cookies.
21:12:52 <revenantphx> P.S.S. Don't get eaten by a polymorphic wolf.
21:13:25 <revenantphx> "See... obviously the wolf in Red Riding Hood just implemented the Grandma interface"
21:13:37 <revenantphx> Nevermind, terrible joke.
21:13:44 <Xilon> revenantphx: It's more likely the filesystem is case insenstivive...
21:13:55 <revenantphx> Xilon: hngh, which it shouldnt me.
21:14:22 <revenantphx> dammit, it is.
21:14:44 <revenantphx> Why the hell isn't HFS+ case sensitive...
21:15:13 <Gracenotes> I don't get why case insensitivity in file systems.
21:15:18 <Xilon> You need to make it so. I think by default it's not on Mac OS X
21:15:32 <revenantphx> Xilon: it's by default case insensitive
21:15:40 <revenantphx> I'd imagine I'd break shit if I made it case sensitive though
21:15:47 <Xilon> Yeah, Steam doesn't work if it's sensitive :(
21:15:56 * edwardk waves hello.
21:15:56 <Eduard_Munteanu> Bah, I wish we had kind polymorphism.
21:16:04 <Eduard_Munteanu> o/
21:16:14 <Axman6> o/ edwardk 
21:16:17 <edwardk> Eduard_Munteanu: a long standing gripe of mine =)
21:16:21 <edwardk> heya alex
21:16:27 <Gracenotes> how does steam on mac work..?
21:16:29 <revenantphx> Why are we heiling edwardk
21:16:32 <Eduard_Munteanu> I can't even use an unboxed type as a state for the State monad.
21:16:33 <revenantphx> Just... curious.
21:16:50 <revenantphx> Maybe I'm just use to a different use of o/
21:16:51 <Axman6> revenantphx: because he waved hello, and we're polite creatures!
21:16:59 <revenantphx> I usually it in the context of
21:17:04 * Axman6 uses o/ as a wave...
21:17:15 <revenantphx> [-- o/o/o/o/o/o/ HEIL FUHERE \o\o\o\o\o\o\ --]
21:17:20 <edwardk> revenantphx: didn't you hear, i was confirmed as der fuehrer last week
21:17:22 <revenantphx> or some other similar trolling.
21:17:22 <Axman6> some people use o/~
21:17:36 <Eduard_Munteanu> No no, that would be   /o
21:17:40 <Xilon> Axman6: with a hankie?
21:17:42 <Eduard_Munteanu> or   o\
21:17:51 <revenantphx> heh.
21:18:01 <Axman6> Xilon: yeah that's how i interpret it too, so i don't use it :P
21:18:03 <Gracenotes> cd ~/o
21:18:12 <Axman6> /o\
21:18:40 <revenantphx> Cale: yay, that was easy to switch too.
21:19:17 <revenantphx> so, now I am curious...
21:19:37 <revenantphx> how can I simplify the situation where *all* off my methods take AmityState -> Port -> IO ()
21:19:42 <tg_> having had a moment to think about it
21:19:55 <Cale> revenantphx: Put a Port into your AmityState
21:20:13 <revenantphx> Cale: okay, thats part of it I guess.
21:20:13 <tg_> surely, if you're being mauled to death by a wolf - and you have the audacity to ask said creature what kind of wolf it is - you can't trust his/her/its answer
21:20:24 <dolio> edwardk: Did you really need an excuse to not read Yegge?
21:20:33 <revenantphx> tg_: If it's an NSWolf you can just check its isa pointer.
21:20:37 <Eduard_Munteanu> How does I# work? It's kind should be # -> *, is it an exception?
21:20:58 <tg_> revenantphx: and this is something one can check without limbs?
21:21:04 <Eduard_Munteanu> Oh crap, it's not.
21:21:05 <dolio> I# is a value constructor. It doesn't have a kind.
21:21:10 <Eduard_Munteanu> It's *
21:21:11 <revenantphx> tg_: there's a wonderful emacs command for it.
21:21:19 <revenantphx> So in short, no.
21:21:22 <tg_> revenantphx: oh. I use vim. I knew one day it would be the death of me.
21:21:34 <revenantphx> Oh, if you're using vim you'll be fine.
21:21:44 <revenantphx> Just type it out with your tongue before the wolf bites that off.
21:21:55 * tg_ scribbles notes
21:22:16 <revenantphx> I hate my computer science class.
21:22:32 <tg_> Did you fine gentlemen know that Newton wrote the diagram explaining his discovery on the nature of light on the back of some scratch parchment?
21:22:36 <revenantphx> given a method in which an interface type is passed in, the teacher actively suggested casting from the interface type to the actual type.
21:23:02 <revenantphx> Imo, if you get pass an interface type to a method, you should treat it as that interface (and nothing more) throughout the method.
21:23:02 <Eduard_Munteanu> Basically any computation I'd like to do in an unboxed State would be plagued by boxing and unboxing overhead, *sigh*
21:23:25 <tg_> revenantphx: that's a pretty classic issue with interfaces
21:23:29 <Eduard_Munteanu> Any thoughts how to do that another way?
21:23:33 <tg_> i'm sure c2wiki has a boatload about it
21:23:36 <revenantphx> tg_: It's not an issue though.
21:23:42 <revenantphx> It's a matter of good design.
21:23:47 <Cale> http://www.youtube.com/watch?v=keed1HXhGqc
21:24:03 <revenantphx> If something implements "Enumerable" your method shouldn't *care* about what kind of Enumerable thing it is.
21:24:09 <tg_> revenantphx: it's an issue in languages where you're forced to do otherwise
21:24:16 <revenantphx> You shouldn't be imo.
21:24:29 <revenantphx> so if me.eatByWolf(IWolf aWolf) is called
21:24:46 <revenantphx> Then you shouldn't care what kind of IWolf it is, just that it implements "eatPerson" and "dismember"
21:25:56 <Gracenotes> types are contracts
21:26:00 <tg_> what if ICanine comes along, and fulfills eatPerson and dismember
21:26:12 <tg_> should it not tear limb from limb as well?
21:26:23 <Gracenotes> tg_: then you need structural subtyping!
21:26:30 <pastorn> Cale: it's like watching a cooking show, but cooler
21:26:47 <pastorn> though you should have an oven filled with those pre-folded
21:27:50 <Gracenotes> melted neodymium.. what could go wrong
21:28:18 <tg_> it's pretty useless once it gets too hot?
21:28:27 <tg_> what is the magnetization temperature of neodymium?
21:28:34 <Cale> pastorn: haha
21:28:42 <revenantphx> Okay.
21:28:44 <tg_> the physicist asks the funpro
21:29:12 <Gracenotes> tg_: er. 310–400°C evidently.
21:29:38 <tg_> that's pretty low
21:29:52 <Gracenotes> still, rare earth metals melting in your oven, sounds sketchy
21:29:58 <tg_> yeah, it does
21:30:03 <pastorn> Cale: isn't there a risk that you might destroy your hexagons? it looks like there's some space inside them
21:30:03 <tg_> i would have just ballparked 2000 C
21:30:13 <tg_> revenantphx: http://c2.com/cgi/wiki?PolymorphismAndInheritance
21:30:17 <pastorn> so that you might accidenticcaly squish one
21:30:32 <tg_> revenantphx: http://c2.com/cgi/wiki?TypesAreContracts
21:31:13 <Gracenotes> http://www.c2.com/cgi/wiki?LiskovSubstitutionPrinciple
21:31:19 <Eduard_Munteanu> I like the CaveProgrammer and spinoff pages from that wiki.
21:31:27 <sohum> @hoogle IO File -> Map (Int,Int) Colour
21:31:27 <lambdabot> Warning: Unknown type File
21:31:28 <lambdabot> No results found
21:31:46 <Cale> pastorn: Yeah, though they sort of don't want to squish down too easily
21:31:48 <revenantphx> See, I see inheritance and implementation of interfaces differently.
21:31:48 <tg_> Gracenotes: I am humbled by the speed at which you outsourced me from my own source.
21:32:01 <Cale> pastorn: Somehow the magnets repel a bit.
21:32:03 <revenantphx> anyways.
21:32:04 <Gracenotes> google power go
21:32:19 <Gracenotes> although the wikipedia page is a bit clearer
21:32:24 <Cale> pastorn: But if you push down, it will get into another stable configuration and stick.
21:33:05 <pastorn> hehe
21:33:05 <tg_> revenantphx: which sort of typing?
21:33:09 <sohum> @hoogle FilePath -> IO Map (Int,Int) Colour
21:33:09 <lambdabot> Did you mean: FilePath -> IO (Map a a) /count=20
21:33:10 <lambdabot> No results found
21:33:13 <tg_> duck? weak(est)?
21:33:17 <revenantphx> ?
21:33:21 <revenantphx> depends on the language
21:33:24 <sohum> @hoogle FilePath -> IO (Map a b)
21:33:24 <lambdabot> Data.Map singleton :: k -> a -> Map k a
21:33:25 <lambdabot> Data.Map delete :: Ord k => k -> Map k a -> Map k a
21:33:25 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
21:33:36 <tg_> revenantphx: right, but usually programmers *think* in one
21:33:53 <tg_> or think against one (pick one they don't like/disagree with, and structure arguments from that)
21:33:59 <revenantphx> languages are just a metaphor.
21:34:10 <revenantphx> They're a way to express underlying ideas which exist throughout multiple languages.
21:34:25 <tg_> revenantphx: I agree
21:34:33 <Gracenotes> revenantphx: there's subtyping and then there's subclassing
21:34:40 <tg_> that doesn't mean my brain doesn't think about the languages I learned first
21:34:49 <Gracenotes> interfaces are pure subtyping. inheritance is subtyping with subclassing.
21:35:05 <Gracenotes> it's a reasonable way to think of things
21:35:47 <Kaidelong> can a class give default implementations of methods in a class it requires?
21:35:49 <tg_> Gracenotes: smalltalk example would use?
21:36:37 <sohum> @hoogle HImage -> Map a b
21:36:37 <lambdabot> Warning: Unknown type HImage
21:36:37 <lambdabot> Data.Map singleton :: k -> a -> Map k a
21:36:38 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
21:36:57 <Eelis> what's the reason for this weird restriction on what a view pattern's expression can refer to?: http://codepad.org/0jeglXQq
21:37:04 <Kaidelong> I'd like to make a class for genes where you can use them normally as if though they are Ord's and if you implement the Gene the Gene class automatically implements "comparing fitness" for compare
21:37:12 <Gracenotes> tg_: not so great with smalltalk
21:37:25 <Kaidelong> so you don't have to make them instances of Ord first
21:37:57 <Gracenotes> instance Gene a => Ord a where [...]
21:37:59 <tg_> Gracenotes: IIRC, if you respond to the methods, then you are fine
21:38:10 <Gracenotes> however this is begging for overlapping instances trouble
21:38:20 <Kaidelong> Gracenotes: overlapping instances
21:38:21 <Kaidelong> yes exactly
21:38:38 <Kaidelong> you're basically making an instance of Ord for a
21:38:49 <Kaidelong> which is not really what I want to do
21:39:28 <Kaidelong> I was just wondering about some mechanism that, if there is no instance already, it automatically makes one
21:39:47 <Kaidelong> way to do it without resorting to template haskell?
21:40:12 <Kaidelong> well okay it can't work with that either
21:40:23 <Eduard_Munteanu> Why does this fail to run until the end? http://paste.pocoo.org/show/300110/
21:40:27 <Gracenotes> geneCompare :: Gene a => a -> a -> Ordering
21:40:35 <Eduard_Munteanu> It gets killed, possibly it eats all memory.
21:40:39 <Gracenotes> make one-line instances everywhere. one solution.
21:40:59 <Gracenotes> but it does need to be declared somewhere.. after all it's a data structure that's passed around to resolve the instances at  runtime
21:41:08 <Kaidelong> oof
21:41:14 <Kaidelong> hmm, well
21:41:30 <Kaidelong> I guess that's just a limitation then that I'll have to deal with?
21:41:39 <Kaidelong> just make instance declarations with "comparing fitness"
21:43:08 <Eduard_Munteanu> And note I'm using the strict state monad.
22:06:51 <moozilla> hi, does anyone know of a function like show that outputs in hex?
22:07:01 <dolio> @type showHex
22:07:02 <lambdabot> forall a. (Integral a) => a -> String -> String
22:07:19 <moozilla> -_-
22:07:21 <moozilla> thanks
22:07:29 <Eduard_Munteanu> Ok so State is unusable for large computations that involve the state? I'm just reading something about how it's lazy on the ml.
22:07:32 <dolio> It's in Numeric, as I recall.
22:08:00 <moozilla> wait, would I be able to use that on a ByteString?
22:08:25 <moozilla> I'm trying to return something like "0x2, 0x3, 0x4" given a ByteString [2,3,4]
22:08:40 <Xilon> @type unpack
22:08:41 <lambdabot> Not in scope: `unpack'
22:09:51 <Xilon> showHex (unpack someBytesString) -- Haven't used ByteString yet so not sure if this is the recommended way
22:09:57 <moozilla> isn't unpack just ByteString -> [Word8]
22:10:40 <moozilla> @type Data.ByteString.unpack
22:10:41 <lambdabot> BSC.ByteString -> [Word8]
22:11:14 <Xilon> @type Data.ByteString.Char8.unpack
22:11:15 <lambdabot> BSC.ByteString -> [Char]
22:13:10 <bblum> hey guys, what's a good concise+consistent way to do asserts in a non-monadic let-binding? "when (condition) $ error blah" works as a stand-alone in a do statement, but a corresponding attempt "let () = if (cond) error blah else ()" doesn't work due to laziness.
22:16:26 <Eduard_Munteanu> What can I use to do *huge* computations with mutable data? Besides State, I also tried ST, but that overflowed on me as well.
22:19:45 <JoeyA> Maybe something wasn't getting seq'd that needed to be?
22:20:34 <Cale> Eduard_Munteanu: ST and STArray or IO and MArray
22:20:40 <Cale> er, IOArray
22:20:51 <Cale> MArray is the general interface to mutable arrays
22:21:29 <Cale> Eduard_Munteanu: stack overflow means that you're building a large expression which isn't being evaluated until too late. The stack consists of case expressions which are waiting to pattern match.
22:22:14 <Eduard_Munteanu> Cale: I only want a single value as state, do I really need an array for that?
22:22:16 <Cale> Eduard_Munteanu: This can happen with boxed arrays if you're not careful to evaluate the elements as you update them -- you can store expressions in the array cells, and if you don't actually look at them, they can build up to be quite large
22:22:22 <Cale> Oh, not at lal
22:22:23 <Cale> all*
22:22:40 <Cale> If it's just one value, then even parameter passing can work fine.
22:23:04 <Cale> Just be cautious about not building up a large expression in your accumulating parameter
22:23:09 <Eduard_Munteanu> Cale: this is a testcase for something more complex: http://paste.pocoo.org/show/300114/
22:23:13 <Cale> If the computation is a fold, use foldl'
22:23:14 <Eduard_Munteanu> it dies on me.
22:23:21 <Eduard_Munteanu> It's not a fold.
22:23:37 <Eduard_Munteanu> (At least not easily)
22:23:42 <Cale> Okay, your problem is that you're not ever evaluating the state
22:23:50 <Cale> and so what happens is that it starts out as 0
22:23:54 <Cale> and then becomes (+1) 0
22:24:01 <Cale> and then becomes (+1) ((+1) 0)
22:24:04 <Cale> and so on
22:24:17 <Eduard_Munteanu> I also tried doing get `seq` ...
22:24:20 <Eduard_Munteanu> But it didn't help.
22:24:23 <Cale> until the very end, where you have (+1) ((+1) ((+1) ... ((+1) 0) ...)))
22:24:28 <Eduard_Munteanu> Yeah.
22:24:39 <Cale> So try this...
22:24:44 <Cale> x <- get
22:24:49 <Cale> x `seq` put (x+1)
22:25:11 <Axman6> or put $! (x+1)
22:25:18 <Cale> right
22:25:26 <Eduard_Munteanu> Oooh... yes. I know. get `seq` modify evaluates the whole m a
22:25:26 <Cale> Or you can even define modify'
22:25:27 <Axman6> (nicer imo)
22:25:30 <Eduard_Munteanu> Not a.
22:25:37 <Cale> yeah
22:25:48 <Cale> and since it's more or less a lambda anyway, it won't do much
22:26:05 <Cale> Well, it'll turn  get  into  State (\s -> (s,s))
22:26:14 <Cale> Which isn't helpful
22:31:21 <Eduard_Munteanu> Cale: strange, that didn't work either.
22:31:59 <sohum> I just want an image library that I can hand any bitmap image and get a 2d map to colours back
22:32:05 <sohum> any suggestions?
22:34:15 <Eduard_Munteanu> sohum: I remember I was pleased with GTK's gdk
22:34:29 <Eduard_Munteanu> GD might be usable as well.
22:34:54 <sohum> *preferably* one with an easy way to do the reverse and an easy way to integrate into a UI, but that's not necessary
22:35:45 <Eduard_Munteanu> Oh then use GTK (gtk2hs) and you'll have your UI toolkit too.
22:36:17 <Cale> Eduard_Munteanu: oh, try Control.Monad.State.Strict
22:36:21 <sohum> Eduard_Munteanu: as in http://hackage.haskell.org/package/gtk ?
22:37:33 <Cale> Eduard_Munteanu: The problem now is really subtle, and has to do with the way that pairs are matched on in the internal State monad implementation. The lazy state monad can do some lovely things which the strict one can't, but those have more to do with cyclic infinite computations, and not simply large ones like you have :P
22:38:00 <Eduard_Munteanu> sohum: hm, gtk2hs's main stuff from haskell.org seems to be down
22:38:18 <Eduard_Munteanu> sohum: but yeah, that's the package
22:38:31 <Cale> Eduard_Munteanu: importing Control.Monad.State.Strict fixes the remaining problem
22:38:50 <sohum> Eduard_Munteanu: *nod* what do you mean by "gtk2hs's main stuff"?
22:39:23 <Eduard_Munteanu> sohum: I mean its website
22:39:44 <sohum> ah, okay
22:39:57 <Eduard_Munteanu> Cale: thanks, it worked.
22:40:09 <Eduard_Munteanu> I tried it before, but the `seq` was wrong.
22:40:23 <Eduard_Munteanu> Now I thought only the proper seq would do :).
22:41:00 <Cale> Eduard_Munteanu: Yeah, you need both of those things to be right in order to do such a gigantic comptuation with the State monad.
22:45:38 <Eduard_Munteanu> Oh, wow...
22:46:09 <Eduard_Munteanu> Synthetic benchmark, that against a C version of that code.    13.9s vs 0.001s
22:47:17 <Eduard_Munteanu> I know it's not really relevant, but maybe it's the reason I'm was seeing differences in performance C vs Haskell?
22:48:50 <Eduard_Munteanu> (I did add 0 :: Int as initial state)
22:49:12 <Eduard_Munteanu> (That should eliminate concerns related to GMP)
22:52:53 <ddarius> Integer is way more expensive than Int.  You also want to be sure you are compiling with optimizations.
22:53:38 <Eduard_Munteanu> ddarius: yes, of course, -O2
22:53:52 <Eduard_Munteanu> ddarius: I also tried -fvia-c -optc-O2
22:54:15 <Eduard_Munteanu> *adding that on top of -O2
22:55:09 <ddarius> Going via C doesn't really improve performance.  I think it is still better for some floating point heavy computations (though I'm not sure how the LLVM backend fares there), but otherwise it's not much different.
22:55:21 <ddarius> (Other than compilation takes quite a bit longer.)
22:56:20 <Eduard_Munteanu> ddarius: both versions here: http://paste.pocoo.org/show/300118/
22:57:06 <Eduard_Munteanu> Hm, maybe the 1..500000000 might fare better as list of ints.
22:58:18 <Eduard_Munteanu> Yep, but down only to 8-9s.
23:00:14 <Eduard_Munteanu> LOL, it seems gcc reduced that whole loop at compile-time.
23:00:25 * Eduard_Munteanu tries volatile on 's'
23:01:37 <Eduard_Munteanu> Hm, that gives real    0m1.299s for C.
23:01:40 <Eduard_Munteanu> We're getting closer.
23:02:50 <ddarius> Yeah, 1 ms for incrementing 50,000,000 times is hardly possible as that would require roughly a 50 GHz processor assuming each iteration of the loop can be dispatched in a single cycle.
23:04:43 <Eduard_Munteanu> How far would I be from truth if I inferred that, for any fully CPU-bound program, Haskell will be about 6-7 times slower than C?
23:05:21 <ddarius> I suspect the list creation and forM_ is not being fully eliminated (or quite possibly eliminated at all.)  You could definitely rewrite the code so that it gets approximately the same speed (+/- 5% or so) as the C, but it would be kind of pointless.
23:05:25 <Eduard_Munteanu> I'd like to take that as an upper bound.
23:05:38 <ddarius> The performance difference will depend on you.
23:05:48 <Eduard_Munteanu> Hm, I never tried the folding.
23:10:03 <Eduard_Munteanu> Uh oh, not good, it's 12s on main = putStrLn . show $ foldl' (\x y -> x + 1) (0 :: Int) ([1..500000000] :: [Int]
23:10:23 <Eduard_Munteanu> )
23:11:27 <ddarius> Also you C code displays i not s.
23:11:52 <Eduard_Munteanu> Oops.
23:12:00 <ddarius> Eduard_Munteanu: [1..50000000] creates a list unless it gets fused away.  Also putStrLn . show = print
23:13:00 <moozilla> hey guys, is there an easy way I can change this to ByteString -> ByteString?
23:13:03 <moozilla> toHex :: ByteString -> String
23:13:04 <moozilla> toHex = B.foldr wrap ""
23:13:04 <moozilla> where wrap x y = showString "0x" $ showHex x $ showString ", " y
23:13:23 <Cale> moozilla: You can stick a B.pack on there
23:13:24 <Eduard_Munteanu> moozilla: see pack
23:13:36 <ddarius> So while this isn't really fair to the C, due to the volatile, I can readily write Haskell code that runs faster than the C.
23:13:55 <Cale> Er, you'll want it to be Data.ByteString.Char8.pack, probably
23:13:58 <moozilla> I know I can do B.pack, but is there a way I can avoid showString in general?
23:14:07 <Eduard_Munteanu> ddarius: same thing with displaying s. (I also used < instead of <= improperly.)
23:14:26 <Cale> moozilla: Well, if you want to use showHex, you'll have some involvement with String regardless...
23:14:52 <moozilla> ah yeah
23:16:01 <Cale> I love that I can honestly say that I turn category theory into games for a living.
23:16:48 <ddarius> http://paste.pocoo.org/show/300120/
23:16:51 <Eduard_Munteanu> ddarius: 28,054,429,664 bytes allocated in the heap.
23:17:18 <ddarius> Cale: How have you applied category theory (please don't just say that you've "used monads.")
23:17:28 <Eduard_Munteanu> ddarius: wow, nice, that looks good enough. Thanks.
23:18:12 <moozilla> right now I get results like "0x10, 0xff, 0x2d, 0x4, "
23:18:26 <moozilla> is there a way I can do something like implode
23:18:29 <Eduard_Munteanu> ddarius: though I don't understand why the list isn't fused away, it should be pretty simple.
23:18:36 <Cale> ddarius: Well, some of the arrow interface stuff was inspired by 2-categorical ideas and adjunctions
23:18:41 <moozilla> so there isn't that trailing ", "
23:18:46 <kadoban> Eduard_Munteanu: is it me, or are you benchmarking really useless things?  it seems like you're just getting closer and closer to seeing how fast C and Haskell add two integers...
23:18:58 <djahandarie> ddarius, with LLVM that could just be evaluated to a constant. ;)
23:19:04 <ddarius> The problem is these microbenchmarks hardly reflect how performance is going to be in real programs as GCC's elimination of the loop demonstrates.
23:19:41 <Eduard_Munteanu> kadoban: I wouldn't have done this if I didn't have performance problems in a real application. I progressively went to simpler stuff to see what patterns would be causing it.
23:19:52 <ddarius> djahandarie: It would not be hard for GHC to do such things as well, and it accidentally does upon occasion, but what's the point when such things rarely, if ever, come up in real programs.
23:20:19 <kadoban> ah, i see
23:20:20 <Eduard_Munteanu> ddarius: yeah, that's a mistake on my part, I should've added the volatile sooner.
23:20:51 <djahandarie> ddarius, bragging?
23:21:14 <Cale> ddarius: Actually, I haven't really quite been able to use monads, and have been struggling to get to a point where I can use a monad :)
23:21:54 <Eduard_Munteanu> Well, here's a challenge... suppose you have a huge input file, and you read it in. That's a list. No matter how simple the stuff you do on it, it won't fuse.
23:21:55 <djahandarie> Use the monad, Cale.
23:21:57 <Cale> ddarius: I've got as far as something with an operation that looks like a -> Widget (Event (Widget a)) -> Widget a, which is *kinda* like join
23:22:11 <Cale> ddarius: and analogously, I have something which is almost like bind
23:22:20 <Eduard_Munteanu> Actually, wait!
23:22:32 <Eduard_Munteanu> Maybe if you read the file char by char, without hGetContents, it's faster!
23:22:34 <Cale> (which I wouldn't have been able to see without lots of monad experience :)
23:22:53 <Cale> ddarius: and Widget is an applicative functor
23:27:40 * Eduard_Munteanu wonders if he could write a deforestation rule like: hGetContents >>= mapM f   ==  <some loop reading char by char using f>
23:28:35 <Eduard_Munteanu> I imagine the semantics of mapping over an input file implies some sort of ordering, right?
23:28:53 <Eduard_Munteanu> At least for performance reasons.
23:30:03 <ddarius> hGetContents should be avoided.  String IO in general should be avoided.
23:31:26 <augur> are there any tools online that let you interactively poke at haskell expressions' type trees?
23:32:04 <Eduard_Munteanu> ddarius: ByteString doesn't help me much, unless I can use its maps directly, which are a bit restrictive.
23:33:35 <ddarius> I'm pretty sure reading a bytestring in and unpacking it would still be faster than directly reading in a String (though, of course, you'd want to avoid unpacking as much as possible.)
23:34:38 <Eduard_Munteanu> Ah, I tried that too, about the same. Even Cale told me I should skip ByteString if I'm composing with B.unpack on the right anyway.
23:35:01 <adu> i wonder if i still have messages
23:35:09 <Eduard_Munteanu> I suppose I could try really hard to write my program as a B.foldl'
23:35:28 <Eduard_Munteanu> Seems not :D
23:35:33 <Eduard_Munteanu> (adu)
23:35:44 <adu> what?
23:36:05 <adu> oh right, lambdabot didn't squak at me
23:36:15 <Eduard_Munteanu> :)
23:37:04 <ddarius> Did adu mean "sqwuak or squeak"?  We'll never know.
23:37:28 <ddarius> Er move that w.
23:37:30 <adu> the former
23:38:01 <adu> i.e. the thing that parrots say, not mice
23:38:55 <adu> although, just for the record, mice are cute
23:38:57 <Eduard_Munteanu> Ok, time to try what I learned on the real app.
23:39:53 * ddarius didn't realize that his bag of salad came with dressing and toppings until after he ate half of it.
23:40:06 <Xilon> moozilla: Pershaps you're looking for intercalate?
23:40:24 <moozilla> yeah, I believe that is what I'm looking for
23:41:45 <ManateeLazyCat> Erlang guys, talk everything about "hot-swapping", i need someone open my mind. (PS: i can't understand Erlang code)
23:42:50 <ManateeLazyCat> Maybe ask in #erlang is better idea. :)
23:42:58 <Axman6> indeed
23:43:23 <ManateeLazyCat> Welcome discuss if have erlang guy at here. :)
23:43:42 <Eduard_Munteanu> I wonder if it's possible to use B.foldl' to do IO directly from my folding function, it's (a -> Word8 -> a) -> a -> ByteString -> a
23:44:19 <Xilon> Not familiar with Erlang but from what I understand Erlang basically loads up a new version of the module while keeping the old one in memory. Once the new version is referenced it starts being used.
23:44:41 <ddarius> ManateeLazyCat: Do you have a more concrete question?
23:45:05 <ManateeLazyCat> ddarius: I have some idea, but i want open my mind before write real code.
23:45:57 <ManateeLazyCat> ddarius: I plan build "hot-swapping" daemon process to monitor hot-swapping module's change, it will send "update" message to client process once user touch customize file.
23:50:24 <Eduard_Munteanu> Does this look okay to you? B.foldl' (f env) (return ()) bs    where f :: Something -> IO () -> Word8 -> IO (), f env ios = ios >> do_something_io_ish
23:51:39 <Eduard_Munteanu> (erm forgot about the Word8 but still)
23:55:44 <sohum> Eduard_Munteanu: would you remember if there was a wrapper around pixbufGetPixels, or do I have to write the obvious one?
23:57:37 <Eduard_Munteanu> sohum: to get an array? I did the conversion myself.
23:58:36 <sohum> Eduard_Munteanu: *nod*
23:59:36 <Eduard_Munteanu> sohum: I used pixbufGetPixels and getElems to get the actual data. And pixbufGet{Width,Height} to figure its dimensions.
