00:00:03 <ddarius> paolino: My hint would be:  Don't do that.
00:00:16 <jmcarthur> yeah, mine too
00:00:27 <ddarius> EvanCarroll: It's not very different.  The GHC version avoids passing the parameters around.
00:05:30 <paolino> ddarius: I'm implementing part of RDF and I don't want to reason on predicates as String, to stay polytipic, when I can write cleaner code giving a type to each predication. That is why I use Dynamics (as jmcarthur suggests) and predicates can hold other predicates. Anyway , it would be at least interesting as an exercise on type system to me
00:07:40 <paolino> anyway thanks for considering it, I go to my farmer duties for a while
00:30:05 <Philippa_> interesting EDSL design problem: can we find the 'shape' of DSL that corresponds to visibly pushdown languages?
00:33:45 <ddarius> Philippa_: I'm having trouble interpreting what you mean.  I'm not sure where you are going with "shape" and I'm not sure what you mean by "visibly."
00:35:25 <Gracenotes> what's the shape of visibly finite languages?
00:35:53 <ManateeLazyCat> I think best do an investigate before i write any code: "What's your most need feature if i add *script* ability in Manatee? "
00:36:32 <ManateeLazyCat> Something more like elisp for Emacs, but much safe than that. :)
00:39:07 <Philippa_> ddarius: Visibly Pushdown Languages're a class defined in "Visibly Pushdown Languages" by Alur and Madhusudan
00:39:42 <Philippa_> "shape" as in the different structures that eg applicative languages have compared to monadic languages
00:40:50 <Gracenotes> ..a subset of CFGs? :| honestly.. wat.
00:41:19 <Philippa_> Visibly Pushdown Languages are only allowed to push iff they read specific symbols and pop iff they read specific symbols
00:41:50 <Philippa_> to put it another way, they know that brackets always bracket
00:42:14 <Gracenotes> so, as an example, what's an example of the shape of regular languages (FSMs)?
00:43:21 <Philippa_> Gracenotes: flat, no recursion
00:43:37 <Gracenotes> flitting from state to state.. presumably just a switch statement in a while loop (in imperative terms)
00:45:20 <Philippa_> (obv. you've got */many, and there's 'grouping', but that's not the sense I mean 'flat' in)
00:46:33 <Gracenotes> regular PDAs, I wonder if you could embed the stack in a function call stack. unfortunately a lot of transitions don't look at the top stack element..
00:47:42 <Philippa_> *nod* - applicatives're the corresponding shape, though
00:48:40 <Philippa_> I'm probably looking for some form of restricted applicative in a language that won't let me write infinite grammars
00:49:02 <Philippa_> (infinite grammars are both the biggest boon and the biggest PITA of embedded parsing languages...)
00:49:51 <augur> Philippa_: applicative reader!
00:50:16 <Gracenotes> how does the environment help?
00:50:28 <augur> it doesnt for what you're talking about
00:50:39 <augur> but it does for natural language semantics!
00:50:40 <augur> :D
00:50:45 <Gracenotes> besides providing for the nourishment of future generations and continuation of life on our planet
00:50:54 <Philippa_> augur: applicative reader is great for writing lambda calculus evaluators :-)
00:51:02 <augur> Philippa_: not just!
00:51:05 <jekor> Anyone have experience using hamlet outside of yesod? I'd like to just use hamletFile to get Html. Is there a way to skip the hamlet monad or some method to give it what it needs?
00:51:13 <augur> its also great for natural language semantics evaluators :T
00:52:15 <Gracenotes> well you use lambdas right? close enough
00:52:30 <augur> Gracenotes: well yes, but more to the point, it interprets from the _syntax_
00:52:56 <ski> @hoogle Cont Life
00:52:57 <lambdabot> Did you mean: :: Cont Life a /count=20
00:52:57 <lambdabot> No results found
00:56:33 <ddarius> Applicative reader is great for bracket abstraction ...
00:57:07 <ski> ("bracket abstraction" ?)
00:57:32 <gju_> hi guys, i want to compile a program i wrote but it does fail with some linking errors. when i load it into ghci it works fine. it says that there are unresolvable references to storeablevector. any ideas how i can fix this?
00:58:49 <blackh> gju_: Did you add --make to the ghc command line?
00:59:00 <gju_> uhm, no!? i'll try.
00:59:29 <blackh> Finally in ghc-7.0.1 --make is the default.
00:59:49 <gju_> works! thank you!
01:00:17 <gju_> then binary gets pretty big though.
01:00:49 <blackh> That's the constant overhead of the runtime system.
01:01:23 <blackh> (It's statically linked.)
01:01:39 <gju_> ah ok
01:09:53 <gju_> can i force haskell to evaluate sth as soon as it sees it?
01:10:08 <gju_> for example writing to the screen.
01:10:41 <companion_cube> i'd say seq or bang patterns
01:16:12 <ddarius> Evaluation order is irrelevant to writing to the screen.
01:17:23 <gju_> well i want to do sth like "generating sequence...", doing sth wich takes some time, "OK".
01:17:46 <gju_> just to inform that the program is doing something.
01:18:28 <gju_> because at the moment it seems that the programm writes everything to the screen at once, after everything is done.
01:20:04 <Gracenotes> then you want to know when things are done.. somewhat in advance of using the things
01:21:02 <Philippa_> hmm, I think there's a paper to be written about VPLs and layout
01:22:44 <Philippa_> I've a feeling VPLs give you the class of language where haskell-style layout (with effect equivalent to the parse-error rule) doesn't actually have to involve a parse-error rule
01:23:43 <Philippa_> or if not, something close enough to it to be pretty pleasant (IIRC there's a case with non-; separators?)
01:23:43 <Gracenotes> yeah.. I was going to say an error applicative seems appropriate... but I'm not sure what happens if pop/push are restricted
01:24:39 <Philippa_> yeah, I'm not asking so much "how would you embed this specifically?" (I probably want a heavier-weight embedding initially) as "is there an entire class of interesting language embedding to be found here?"
01:24:43 <blackh> gju_: Controlling when evaluation takes place is definitely possible in Haskell, but it takes a little getting used to.  I can help you out with it if you like.  Maybe you could paste your code to the pastebin.
01:25:03 <gju_> sure.
01:28:42 <gju_> blackh: http://haskell.pastebin.com/T69dVSLJ
01:29:10 <augur> ddarius: what is the monad    return a = \_ _ -> a	M a >>= f = \x y -> (f x y) (a x y)
01:29:13 <augur> anything interesting?
01:29:30 <augur> there should be some more spaces in there somewhere, obviously
01:29:46 <blackh> gju_: add 'hFlush stdout' just after your putStrLn
01:29:57 <blackh> also 'import System.IO' at the top
01:30:01 <blackh> The problem is line buffering
01:30:28 <augur> ddarius: or is it something isomorphic to a reader-within-a-reader?
01:30:41 <blackh> gju_: I meant.. just after your putStr
01:31:22 <gju_> ok
01:31:48 <taruti> Which web frameworks are popular atm in the Haskell land?
01:32:29 <augur> i think theres one called snap out there, taruti
01:33:23 <blackh> taruti: http://www.reddit.com/r/haskell/comments/e7wiw/which_web_framework_should_i_use/
01:33:27 <blackh> ^ Good discussion here
01:33:40 <taruti> thanks
01:34:29 <gju_> blackh: thx, works.
01:36:49 <ddarius> augur: Module bottoms and seq, it is isomorphic to ReaderT r (Reader s a) which is itself isomorphic to Reader (r,s) a
01:37:09 <augur> hmm
01:37:45 <augur> ddarius: you're so totally on my thank-you list, you know this, right?
01:38:20 <ddarius> s/Module/Modulo *sigh*
01:38:28 <Zeiris> Are there any good linear algebra libraries for working with OpenGL? I remember seeing some posts about type dependencies on the mailing list in the last few months, seems like there may've been new developments.
01:38:52 <augur> ddarius: who are you, btw
01:45:51 <ddarius> augur: I don't understand the question.  My full name is in /whois.
01:46:16 <augur> what do you do? are you an academic somewhere?
01:50:36 <Gracenotes> augur: have you seen my amazing expansion of the Reader monad to environment-passing? no, because it sucks >.>
01:50:52 <augur> what
01:51:16 <augur> imma sleep
01:51:17 <augur> ping
01:51:19 <augur> er
01:51:26 <augur> ping me with stuff
01:52:23 <Gracenotes> augur: ping you? where? :o
01:53:59 <Gracenotes> http://hpaste.org/42016/reader_and_environments
02:24:49 <Philippa_> OK, I think I've got an interesting class of languages that could sensibly support layout to sketch out
02:28:14 <oliverdamian> and so here I go committing myself to learning haskell, got haskell platform installed, now starting with 'learn you a haskell'... don't know where this would take me but I'll give it a go
02:30:17 <ski> hi there, oliverdamian
02:30:34 <oliverdamian> hello ski
02:30:35 <ski> if/when you get questions, we're happy to attempt to answer them
02:30:46 <oliverdamian> thank you
02:30:53 <Philippa_> working on the assumption that the layout stack should keep track of brackets /and separators/, and that within those you're looking at some limited class: I want to say regular languages that get to treat bracketed blocks as one thing, but that's enough to allow separators so maybe some mild generalisation of precedence languages (without parens) that's capable of handling juxtaposition
02:31:13 <Philippa_> also hi oliverdamian, don't let me scare you off
02:31:45 <oliverdamian> OK philippa i will try my best
02:33:53 <Philippa_> (hmm: need to handle type annotations okay - I know haskell not being dependently typed is sufficient to give the 'okayness' I need, but not sure I want to rely on that particular grammatical quirk... or I can just give up getting a well-characterised class for now and bash up an implementation and say "don't do something stupid with it" :-) )
02:35:05 <Philippa_> oliverdamian: I say that just because I'm thinking about some syntax design issues that might be relevant to a future version of haskell, in case you're wondering WTF I'm talking about :-)
02:35:22 * ski feeds `Arbitrary' strings to Philippa_'s parser
02:37:13 <sexyblondexx> The best porn in 12www.pornbest.tk
02:37:13 <oliverdamian> Philippa_: no problem, sticking with the haskell present for now :-)
02:37:15 <sexyblondexx> --------------The best porn in 12www.pornbest.tk
02:37:16 <Philippa_> oh, it's not the input strings that'd count as "something stupid", it's the grammars :-)
02:37:19 <sexyblondexx> The best porn in 12www.pornbest.tk
02:38:04 <Philippa_> and if you believe that, I've got a bridge to sell you
02:40:14 <paolino> I've made up a verbose solution to my problem, but really wonder if there is a geneal form http://hpaste.org/paste/42015/small_success_cheating#p42017
02:40:21 * ski ponders writing `Gen' instances for parsers ..
02:40:41 <ski> .. would we need a `Gen1' class ?
02:41:41 * ddarius is feeling pretty good right now.  Nine hours of work will fix that.
02:43:10 * ski misses the `hello' command in lambdabot .. :/
02:43:31 <ddarius> Feeling unwelcomed?
02:43:35 <Philippa_> hmm, ambiguity detection in VPLs is viable too
02:44:03 <Philippa_> well, FCVO viable: VPL equivalence takes exponential time
02:44:25 <ddarius> HM type inference takes at least exponential time.
02:44:50 <Philippa_> but that's viable enough to let a parser for a language like Haskell spot the local ambiguity/need for backtracking in types, for example
02:45:07 <ski> ddarius : well, somehow it feels impolite to start a private conversation with lambdabot (opening a new window/tab), without some kind of initial greeting
02:45:16 <ski> currently i use `> ()' as a greeting
02:45:17 <Philippa_> HM's linear in the total size of the types involved in the program though, no?
02:45:44 <Philippa_> (OK, that's space rather than time, granted)
02:45:53 <Philippa_> I'm not aware of an equivalently useful bound for VPL equivalence
02:48:15 <aleator_> Hi, Anyone know what the status is with GUM, or what might be the preferred haskell on a cluster solution?
02:48:43 <ddarius> @vixen how are you?
02:48:43 <lambdabot> i'm good, you?
02:49:06 <Philippa_> (amusingly abusable thing about the 'local ambiguity' for types: it's mostly /structurally/ ambiguous too, you can hang on to the parse info and then work out if it's a qualification or a type based on whether you hit , => or something that ends the type)
02:49:29 <jro> I got Segmentation fault from prelude
02:50:13 * ski idly wonders what "VPL" stands for
02:50:13 <jro> or from ghci actually
02:50:29 <jro> Prelude Text.Regex.Posix> let pat = "(a)(b)(c)"
02:50:30 <jro> Prelude Text.Regex.Posix> "abc" =~ pat :: (String,String,String)
02:50:30 <Philippa_> Visibly Pushdown Automata
02:50:33 <Philippa_> er, Language
02:50:36 <jro> ("","abc","")
02:50:38 <jro> Prelude Text.Regex.Posix> Segmentation fault
02:51:00 <Philippa_> a CFG where pushes and pops only happen on terminals that are marked as "always pushing" or "always popping"
02:51:01 * ddarius doesn't see how Text.Regex.Posix == Prelude.
02:51:12 <jro> dddarius, I meant ghci
02:58:38 <quicksilver> and there's me thinking it was Visible Panty Line
02:58:42 <quicksilver> learn a lot, in this channel, you do.
02:59:05 <jro> I thought that regex groupings are part of posix regex
02:59:20 <jro> $ echo abc | sed 's/\(a\)\(b\)\(c\)/\3\2\1/'
02:59:21 <jro> cba
03:00:35 <jro> grouping "(a)(b)(c)" matches abc and then segfaults
03:00:45 <ski> > "abc" =~ "(a)(b)(c)" :: (String,String,String)
03:00:46 <lambdabot>   ("","abc","")
03:01:55 <Philippa_> hmm, you can probably derive an at least somewhat useful AST from a VPL too
03:02:25 <jro> so groups seem to be there, need to find out how access those
03:02:34 <Philippa_> possibly more so for the class I'm contemplating that's good for layout
03:23:56 <oliverdamian> why is [3,2,1] > [2,10,100] True?, is the comparison just dependent on the head?
03:24:36 <luite> no, it uses lexicographic order, [3,2,1] > [3,1,1] > [3,1]
03:24:40 <companion_cube> it is lexicographical order
03:25:40 <Jafet> > [1,2,3,4] `compare` [1,2,3,3,9,9,99]
03:25:42 <lambdabot>   GT
03:27:13 <luite> > [2] `compare` (1 : repeat 9)
03:27:14 <lambdabot>   GT
03:27:25 <quicksilver> > let compRev = compare `on` reverse in [3,2,1] `compRev` [2,10,100]
03:27:26 <lambdabot>   LT
03:27:51 <quicksilver> jro: did you work it out? you need another overload to get the groups.
03:28:30 <ddarius> Or one could just not use =~ ...
03:28:43 <quicksilver> yes, you can use the non-overloaded matchRegexAll
03:28:58 <ddarius> oliverdamian: It works the same way string comparison works (which is a good thing as in Haskell Strings are just lists of characters.)
03:29:11 <quicksilver> > matchRegexAll (mkRegex "(a)(b)(c)") "abc"
03:29:12 <lambdabot>   Not in scope: `matchRegexAll'Not in scope: `mkRegex'
03:29:17 <quicksilver> hmm
03:29:32 <quicksilver> I wonder what the qualification is, if anything
03:30:38 <ddarius> > Text.Regex.Posix.mkRegex "abc"
03:30:39 <lambdabot>   Not in scope: `Text.Regex.Posix.mkRegex'
03:30:41 <quicksilver> > "abc" =~ "(a)(b)(c)" :: (String,String,String,[String])
03:30:42 <lambdabot>   ("","abc","",["a","b","c"])
03:30:54 <quicksilver> jro: that's the overload equivalent to matchRegexAll anyway.
03:31:09 <quicksilver> I view text.regex as a successful experiment in a certain style of overloading.
03:31:16 <ddarius> Successful?
03:31:22 <quicksilver> It was successful, because it successfully demonstrated that it's a terrible idea.
03:31:28 <quicksilver> so now we know.
03:31:42 <ddarius> I think we mostly knew that beforehand.
03:33:14 <quicksilver> ddarius: but now we have *proof* ;) That's what experiments are for.
03:33:28 <quicksilver> Sadly it seems that the author of the modules doesn't interpret the results the same way as me :-/
03:34:46 <Jafet> > readP_to_S (do { a <- string "a"; b <- string "b"; c <- string "c"; return (a,b,c)}) "abc"
03:34:47 <lambdabot>   Not in scope: `readP_to_S'Not in scope: `string'Not in scope: `string'Not i...
03:36:05 <sipa> > let s x = [x] in s "bla" :: [[Char]]
03:36:05 <lambdabot>   ["bla"]
03:37:34 <sipa> > let x @@ y = (x,y) in "bla" @@ "ble" :: (String,String)
03:37:35 <lambdabot>   ("bla","ble")
03:37:54 <jro> quicksilver: thanks, I did not found that. I started to write it by different way
03:38:14 <quicksilver> jro: don't use regular expressions :)
03:38:42 <quicksilver> regular expressions are, basically, a mini-language designed so that the users of your program can do arbitrary searches.
03:38:52 <oliverdamian> ah so it's like ordering in alphabetical order, got it thank you
03:39:03 <jro> I've "hh:mm:ss.ii" and I want to find seconds in double
03:39:14 <jro> toTime :: String -> Maybe Double
03:39:24 <quicksilver> they're quite an appropriate, if ugly, piece of user-interface for an editor or a browser (to allow their user to do custom searches)
03:39:32 <jro> and it might be "h:m:ss"
03:39:48 <quicksilver> as a programmer, though, you have more powerful and more understandable tools available.
03:39:59 <quicksilver> either string manipulation functions or parser combinators.
03:40:10 <jro> test_toTime :: Assertion
03:40:10 <jro> test_toTime = assertEqual "toTime" [100.0, 60.1] (map toTime ["0:1:40.0", "0:0:1"])
03:41:13 <jro> ops, latter should be 60
03:42:05 <jro> maybe I should solve this with "parser combinators"?
03:42:10 <quicksilver> jro: simplest way is to install Data.List.split
03:42:16 <quicksilver> that gives you a quick way to split on ":"
03:42:42 <jro> I do not want to be simple, I want to learn
03:42:45 <quicksilver> you could then do let (h,m,s) = splitOn ":" string
03:42:49 <Jafet> oliverdamian: it's the other way round: most "alphabetical orders" are lexicographic, but some are not. See "collation", which covers the general field of alphabetical ordering.
03:43:07 <quicksilver> jro: if you want to learn, it is a very simple example for Parsec
03:43:23 <jro> ok, maybe I go for Parsec then
03:43:32 <Jafet> For example, "ß" is a single Char but a proper collation will treat it as "ss"
03:43:43 <arcatan> a while back I had to parse some RFC822 dates with C and I'm positive regular expressions were the simplest way to do it
03:43:47 <oliverdamian> Jafet: thanks I'll look that up
03:44:01 <sipa> > let s x = [x] in s $ "bla" :: [[Char]]
03:44:02 <lambdabot>   ["bla"]
03:44:20 <sipa> so, :: has lower precendence than every other operator?
03:44:32 <Jafet> :: isn't an operator, but something like that.
03:44:42 <sipa> yes, i know, it's special syntax
03:45:09 <sipa> but at the parser level, it binds less tightly than all user-definable operators
03:45:39 <quicksilver> arcatan: in C, it probably is, due the absence of good parser combinator libraries.
03:45:43 <Jafet> I'm not sure if you can parse it as an operator
03:46:07 <quicksilver> I'm pretty sure you can't parse it as an operator
03:46:12 <arcatan> quicksilver: yeah, i'd have used a parser combinator library if one would have been easily available
03:46:17 <quicksilver> you get a maximal "expression" to the left of it
03:46:22 <quicksilver> because it's not part of the expression
03:46:43 <Jafet> > return :: (a -> [a]) 1 :: Int
03:46:43 <lambdabot>   <no location info>: parse error on input `::'
03:47:07 <Jafet> So, better not pretend it's one.
03:48:17 <benmachine> quicksilver: is that absence because it hasn't been done or because it isn't doable, do you think?
03:49:13 <benmachine> (well, the latter implies the former, but you get what I mean)
03:49:31 <quicksilver> benmachine: well, C doesn't admit very useful combinators, and if the only syntax you have is prefix function application it looks a bit ufly
03:49:55 <quicksilver> benmachine: that's probably why most C parser libraries are generators which take a non-C grammar description.
03:50:02 <Philippa_> quicksilver: I pretty much missed what the actual regex problem is, mind if I ask you to spell it out? (would it be solveable by a better module system, for example?)
03:50:04 <benmachine> ah
03:50:08 <quicksilver> (regular expressions are, after all, one such)
03:50:17 <ski> jro : s/map/mapM/ and wrap the first list in `Just' ?
03:50:28 <benmachine> quicksilver: you wouldn't use one of those in preference to regexes?
03:50:33 <quicksilver> Philippa_: I have described two unrelated objections to the haskell regex library
03:50:58 <quicksilver> Philippa_: the first is just the excessive overloading of =~ which I find an ugly API.
03:51:03 <jro> ski, thanks, I just started to add error handling
03:51:32 <jro> i.e. changed signature to Double -> Maybe String
03:51:42 <ski> jro : yeah, that should check that every test in that list succeeds, and matches the successful result list
03:51:49 <quicksilver> Philippa_: the second is simply that regular expressions are an ugly string-based DSL, and it's much nicer to use a prettier language level DSL, unless you want user-specified expressions.
03:52:03 <ski> jro : you should also consider writing QuickCheck properties
03:52:05 <Jafet> Like this? http://www.boost.org/doc/libs/1_45_0/doc/html/xpressive/user_s_guide.html#boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes.static_xpressive_syntax_cheat_sheet
03:52:25 <Jafet> (compile-time recursive perl-style irregular regex in C++ dsl)
03:52:38 <quicksilver> benmachine: personally, I probably wouldn't, for RFC822 dates, due to unfamiliarity with C parser generators. But it would probably be better to.
03:52:54 <quicksilver> Jafet: Yes, I have been going to say "but I bet someone has done it in C++" but I got derailed off that tack ;)
03:53:17 <Philippa_> quicksilver: yeah, I feel that one's... well, you need both, because string-formatted regexes are going to be part of someone's problem domain, but you need both and not just strings
03:53:48 <quicksilver> Philippa_: string-formatted regexps are great if you're writing a browser or an editor (and you want to give the user the option to enter custom search strings)
03:53:56 <quicksilver> Philippa_: IMO that's what they're *for*, in fact.
03:54:07 <Jafet> The current syntax for regexes is just unfortunately stuck at this level of ugliness and inability
03:54:17 <quicksilver> they're not a (good) general solution to matching and extracting.
03:54:25 <Philippa_> yeah, but sometimes you're in a situation where your boss is saying "parse this stuff I've got a bunch of existing regexes for" too
03:54:50 <Jafet> For quicksilver's GUI scenario, awk might have been better, and possibly cleaner to use, but the missiles have already been launched
03:54:58 <Philippa_> obvious, annoying example: you're being asked to port some perl and in the short term you can't rewrite with a different parser style
03:55:22 <jro> ski, what do you mean by QuickCheck properties?
03:56:03 <quicksilver> Philippa_: oh, sure. yes.
03:56:19 <jro> prop_x :: Type -> Property is not ok?
03:58:00 <ski> jro : something like `prop_Time time = Just time == toTime (fromTime time)'
04:04:41 <jro> ski, I ended up doing these kind of things since I do prop_t t' = t > epsilon ==> t==t where t = abs t' 
04:06:08 <jro> oh well, my OS X started to be unresponsive 5 minutes ago and it do not seem to normalize, and I am hungry
04:06:16 * hackagebot template 0.2.0.4 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.4 (JohanTibell)
04:06:39 <jro> and when I start to do one thing I realise that I have to learn million other things
04:07:40 <jro> thanks for the help. 
04:08:10 <ski> you're welcome
04:08:42 <ski> > let nan = 0 / 0 in nan == nan
04:08:43 <lambdabot>   False
04:12:31 <dcsobral> How's >>= pronounced?
04:12:35 <quicksilver> bind?
04:12:37 <ski> "bind"
04:12:50 <quicksilver> the question mark is optional :)
04:13:09 <ski> jro : hm, i'm not really seeing the point of `t > epsilon ==> t==t' .. is it the case that denormalized floating point numbers are self-comparing strange ?
04:13:27 <ski> (also `>>' is pronounced "then")
04:13:31 <dcsobral> Oh. I thought it would be called something else, so it wouldn't be confused with "bind". :-)
04:13:39 <sipa> :t bind
04:13:40 <lambdabot> Not in scope: `bind'
04:14:00 <sipa> which "bind" would it be confused with?
04:14:45 <quicksilver> "....and in the darkness bind them!" ?
04:14:51 <yitz> @hoogle bind
04:14:51 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
04:14:52 <lambdabot> System.Console.Editline.Readline bindKey :: Char -> Callback -> IO ()
04:14:52 <lambdabot> Language.Haskell.TH.Syntax bindQ :: Q a -> (a -> Q b) -> Q b
04:15:21 <ski> @hoogle+
04:15:21 <lambdabot> Language.Haskell.TH BindS :: Pat -> Exp -> Stmt
04:15:22 <lambdabot> Language.Haskell.TH.Syntax BindS :: Pat -> Exp -> Stmt
04:15:22 <lambdabot> Language.Haskell.TH bindS :: PatQ -> ExpQ -> StmtQ
04:16:48 <dcsobral> the one in the text I'm reading, which is defined slightly differently. :-)
04:17:00 <sipa> @let krimpatul = (>>=)
04:17:02 <lambdabot>  Defined.
04:20:16 <arcatan> sipa: :D
04:20:25 <dcsobral> Is there any repl for haskell at all that will accept data declarations?
04:20:37 <Kaidelong> so neither || nor && is commutative in haskell?
04:20:55 <benmachine> Kaidelong: right, but to be fair it isn't in most languages
04:21:07 <Kaidelong> would that mean we're not working with boolean logic but some kind of non-commutative three-valued logic?
04:21:14 <ski> conal possibly has commutative versions of them
04:21:27 <quicksilver> dcsobral: no, although there was once.
04:21:34 <ski> preflex: seen conal
04:21:34 <preflex>  conal was last seen on #haskell 17 hours, 42 minutes and 26 seconds ago, saying: jmcarthur: ping
04:21:40 <quicksilver> Kaidelong: if you consider _|_ a value then, yes, indeed, Bool is three-valued.
04:21:40 <Kaidelong> in the case of a strict language like ML it would be Bochvar's three valued logic
04:21:50 <Kaidelong> but not in haskell
04:22:03 <ski> you can't detect `_|_', though
04:22:04 <quicksilver> if you consider _|_ more like the absence of a value, then perhaps Bool is only two-valued.
04:22:18 <Kaidelong> well, ML comes with non-strict conjunct and disjunct
04:22:21 <ski> (the sierpinski space is not the boolean space)
04:22:39 <benmachine> it's fair to say at least that a || b and b || a agree if they take a non-bottom value
04:22:40 <ski> Kaidelong : yeah, but those are special syntax
04:23:06 <Kaidelong> quicksilver: well in Bochvar's three valued logic N is assigned to things that equate to the liar's paradox, so does _|_ doesn't it?
04:23:24 <ski> benmachine : s/they take/they both take/
04:23:40 <quicksilver> Kaidelong: well the fact that _|_ isn't observable may or may not change your opinion about whether this is true Bochvar.
04:24:11 <Kaidelong> well in the case of haskell it definitely isn't
04:24:18 <ski> (benmachine : there's an alternative equality for partial expressions, that say that both expressions are as defined as the other, and if both are defined, have the same value)
04:24:22 <Kaidelong> > True || not undefined
04:24:22 <lambdabot>   True
04:24:52 <benmachine> ski: mm
04:25:30 <ski> (well, i suppose for clarity i could just as well say s/if both/if any/, there)
04:27:19 * Kaidelong wonders what the equivalent of the liar's paradox would be for bochvar's
04:27:21 <tiz> The following is accepted by GHC 6.12, but rejected by 6.8 and by Hugs Sep 2006. Is it a new feature of GHC or a bug?
04:27:24 <tiz> foo :: Int
04:27:26 <tiz> foo = do 1
04:29:07 <quicksilver> tiz: I consider it a bug of GHC.
04:29:17 <quicksilver> but it's not considered very important :)
04:29:27 <quicksilver> as I recall, the report doesn't make it particularly clear.
04:30:22 <benmachine> I wonder if it's related to rebindable syntax with NoImplicitPrelude
04:31:04 <dixie> > sum [1..]
04:31:06 <quicksilver> could be, yes
04:31:09 <lambdabot>   mueval-core: Time limit exceeded
04:31:15 <jro> ski: t==t was just example of some arbitrary condition. I use both HUnit and QuickCheck and now I've written HUnit tests first, then try to get them working
04:31:19 <ski> > product [0 ..]
04:31:25 <lambdabot>   mueval-core: Time limit exceeded
04:31:52 <ski> > product [0 ..] :: Expr
04:31:56 <lambdabot>   mueval-core: Time limit exceeded
04:31:58 <ski> hmpf !
04:32:14 <ski> jro : i see
04:32:52 <jro> I think that both ways to write tests add a value
04:32:53 <quicksilver> > show (product [0..] :: Expr)
04:32:58 <lambdabot>   mueval-core: Time limit exceeded
04:33:14 <quicksilver> > show (foldr1 (*) [0..] :: Expr)
04:33:15 <lambdabot>   "0 * (1 * (2 * (3 * (4 * (5 * (6 * (7 * (8 * (9 * (10 * (11 * (12 * (13 * (...
04:33:22 <quicksilver> > foldr1 (*) [0..] :: Expr
04:33:23 <lambdabot>   0 * (1 * (2 * (3 * (4 * (5 * (6 * (7 * (8 * (9 * (10 * (11 * (12 * (13 * (1...
04:33:30 <quicksilver> ski: damn those foldls :P
04:34:06 <ski> aye
04:35:31 <Kaidelong> I get GADTs but what do you use them for in practice?
04:38:58 <Kaidelong> wait I see now
04:44:29 <jro> > :t mapM
04:44:31 <lambdabot>   <no location info>: parse error on input `:'
04:45:01 <quicksilver> jro: no > for use of :t
04:45:05 <quicksilver> :t mapM
04:45:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:45:11 <preyalone> Is there a Haskell equivalent to Lisp's (cond)?
04:45:46 <preyalone> I love guards, but I want to do something like guards/cond inside of my main function.
04:47:16 <Kaidelong> preyalone: you could define an operator (?) and use it much the same way
04:47:24 <jro> test_fromtimesmall = assertEqual "fromSmallTime" [Just "53:20.20", Just "10:00.00", Just "01:00.01", Just "02:45.00", Nothing] (mapM fromTime [3200.20, 600.0, 60.01, 164.99753086419753, -10])
04:47:30 <quicksilver> preyalone: some people just write their own cond
04:47:35 <Kaidelong> True ? = const
04:47:43 <quicksilver> preyalone: cond :: [(Bool,a)] -> a
04:47:43 <Kaidelong> False ? = id
04:47:47 <jro> I have not proceeded up to monads yet
04:48:04 <Kaidelong> then something like
04:48:27 <Kaidelong> a = 1 ? q $ a = 2 ? 3 ... etc
04:48:35 <Kaidelong> ==*
04:48:37 <ski> preyalone : you can also say `case () of () | foo -> ... ; bar -> ...'
04:48:57 <Kaidelong> err
04:49:03 <Kaidelong> False ? = flip const
04:49:04 <Kaidelong> I meant
04:49:08 <ski> (er, s/;/|/)
04:49:16 <ski> so
04:49:19 <Kaidelong> (False ?) = flip const
04:49:20 <ski>   case () of
04:49:25 <ski>     () | foo -> ...
04:49:26 <jro> oh, it is just ordinary map
04:49:28 <ski>     () | bar -> ...
04:50:00 <ski> jro : in the `Maybe' case, it is `mapM :: (a -> Maybe b) -> ([a] -> Maybe [b])'
04:50:23 <ski> so if any of the calls for the elements give `Nothing', you'll get a `Nothing' overall result
04:50:59 <ski> > mapM (\n -> if even n then Just (n `div` 2) else Nothing) [0,1,2,3]
04:51:00 <lambdabot>   Nothing
04:51:04 <ski> > mapM (\n -> if even n then Just (n `div` 2) else Nothing) [0,2,3]
04:51:05 <lambdabot>   Nothing
04:51:07 <ski> > mapM (\n -> if even n then Just (n `div` 2) else Nothing) [0,2]
04:51:08 <lambdabot>   Just [0,1]
04:52:08 <ski> jro : does the `test_fromtimesmall' you gave above typecheck ?
04:52:44 <ski> (i don't see it type-checking if you don't replace `mapM' by `map' (or rewrite in another way) there)
04:53:09 <jro> I replaced mapM with map
04:53:15 <jro> my  tests go through now
04:53:47 <ski> ok
04:54:01 <jro> well, that was good excercise for job interview
04:54:04 <jro> have to go. bye
04:54:29 <ski> if you only want to check succeeding tests, it is simpler to use `mapM', and replace `[Just ..,Just ..,...]' with `Just [..,..,...]'
04:54:38 <ski> jro : ok
04:55:58 <Kaidelong> is the test's return type specialized to Maybe?
04:56:06 <Kaidelong> because otherwise you could just use msum
04:56:42 <Kaidelong> unless there is some particular advantage to Maybe over []
05:08:20 <Fuco> is there some simple way to print execution trace in hugs?
05:08:32 <Fuco> similar to clisp (trace function)
05:12:35 <Kaidelong> I think I just understood Curry-Howard
05:12:46 <quicksilver> I don't think so, Fuco. I don't use hugs but I don't think it has a tracer.
05:13:25 <Kaidelong> if you can prove a type is inhabited, and the type of functions from that type to another type is inhabited, you've proved the other type is also inhabited?
05:13:59 <Fuco> sounds like transitivity :D
05:15:18 <quicksilver> Kaidelong: it's suficient to prove that the function type is inhabited.
05:15:34 <quicksilver> or...
05:15:39 <quicksilver> no, you were right.
05:15:42 <quicksilver> what you said :)
05:16:34 <Kaidelong> yay I'm making progress!
05:42:25 <Fuco> why can't there be a simple random function @_@
05:42:56 <sipa> it would not be referentially transparent
05:43:16 <Kaidelong> what's wrong with MonadRandom
05:43:23 <quicksilver> it would not be a function.
05:43:44 <bremner> well, it could not be very random.
05:43:44 <quicksilver> well, the best you can do as a function is g -> (v,g)
05:43:50 <quicksilver> bremner: good solution.
05:43:54 <sipa> random :: Int
05:44:02 <ksf> @remember camccann A humor monad? So basically that's a model where jokes about something are equivalent to jokes about jokes about something. In other words, meta-humor in-jokes.
05:44:02 <lambdabot> It is stored.
05:44:02 <ksf> No wonder it's not working!
05:44:11 <sipa> random = 4  -- decided by a fair dice roll, guaranteed to be random
05:44:12 <ksf> @quote camccann
05:44:12 <lambdabot> camccann says: I think it's more just that Haskell occasionally beats up category theorists and steals their l̶u̶n̶c̶h̶ ̶m̶o̶n̶e̶y̶ useful terminology.
05:44:13 <quicksilver> bremner: http://xkcd.com/221/
05:44:15 <ksf> @quote camccann
05:44:16 <lambdabot> camccann says: I think it's more just that Haskell occasionally beats up category theorists and steals their l̶u̶n̶c̶h̶ ̶m̶o̶n̶e̶y̶ useful terminology.
05:44:26 <ksf> @quote humor.*monad
05:44:26 <lambdabot> camccann says: A humor monad? So basically that's a model where jokes about something are equivalent to jokes about jokes about something. In other words, meta-humor in-jokes.
05:44:32 <ksf> argh.
05:44:46 <ksf> how to attach that "No wonder it's not working!", there?
05:44:48 <Fuco> oh god what have I started
05:45:14 <Kaidelong> I have no idea
05:45:20 <Kaidelong> anyway Fuco use MonadRandom
05:45:35 <ksf> @forget camccann A humor monad? So basically that's a model where jokes about something are equivalent to jokes about jokes about something. In other words, meta-humor in-jokes.
05:45:35 <lambdabot> Done.
05:45:52 <ksf> @rememberg A humor monad? So basically that's a model where jokes about something are equivalent to jokes about jokes about something. No wonder it's not working!
05:45:53 <lambdabot> Nice!
05:45:57 <ksf> argh.
05:46:03 <ksf> @forget A humor monad? So basically that's a model where jokes about something are equivalent to jokes about jokes about something. No wonder it's not working!
05:46:03 <lambdabot> Done.
05:46:07 <sipa> Fuco: functions in haskell are always deterministic, since they can always be replaced by their evaluation without any other effects
05:46:15 <ksf> @remember camccann A humor monad? So basically that's a model where jokes about something are equivalent to jokes about jokes about something. No wonder it's not working!
05:46:15 <lambdabot> I will never forget.
05:46:33 <sipa> Fuco: that makes Haskell's function concept fundamentally incompatible with anything that changes state
05:46:41 <Kaidelong> can't that be taken to a private message with lambdabot?
05:47:26 <Fuco> It's "let's spam the channel" week
05:47:59 <Fuco> and by the way I have no idea what are you talking about... I just want random :: Int -> Int function that takes n and return random 0-n number
05:48:14 <Kaidelong> > evalRandIO $ do {n <- getRandomR (0,10); replicateM n (getRandomR (1,5))}
05:48:15 <lambdabot>   <IO [Integer]>
05:48:16 <benmachine> Fuco: well, you can't have it
05:48:21 <benmachine> it would ruin everything
05:48:23 <Kaidelong> oh right lambdabot won't do IO
05:48:26 <benmachine> heh
05:48:31 <Kaidelong> > evalRand 4 $ do {n <- getRandomR (0,10); replicateM n (getRandomR (1,5))}
05:48:33 <lambdabot>   Ambiguous type variable `m' in the constraint:
05:48:33 <lambdabot>    `Control.Monad.Random.Cla...
05:48:45 <sipa> Fuco: the problem is, if you'd call it multiple times with the same n, it would return the same value 
05:49:10 <sipa> at least, in pure haskell
05:49:11 <Kaidelong> > evalRand 4 $ do {n <- getRandomR (0,10); replicateM n (getRandomR (1,5) :: Rand StdGen Int)}
05:49:12 <lambdabot>   No instance for (System.Random.RandomGen
05:49:12 <lambdabot>                     (Control.Monad...
05:49:31 <benmachine> Fuco: one of the best things about haskell is that writing, say, f x + f x is the same as let y = f x in y + y
05:49:39 <Fuco> ok, so can we make it random :: Int -> [Int] ?
05:49:56 <sipa> Fuco: you could
05:50:06 <benmachine> Fuco: this makes it easy to restructure expressions without changing their meaning
05:50:13 <sipa> random 10 eg would always give the same list though
05:50:14 <fryguybob> I'm trying to install gitit and it requires cautious-file which defaults to having its posix flag true.  I separately install cautious-file, but when I try gitit again, cabal wants to reinstall cautious-file.  Anyone know what to do?
05:50:18 <benmachine> but it means that f x has to be the same however many times it was called
05:50:22 <Fuco> people I don't care about haskells pureness or anything, I just want a list of random numbers
05:50:24 <Kaidelong> > evalRand 4 $ do {n <- getRandomR (0,10); return  n}
05:50:24 <benmachine> otherwise you can't do that transformation
05:50:25 <lambdabot>   Ambiguous type variable `m' in the constraint:
05:50:25 <lambdabot>    `Control.Monad.Random.Cla...
05:50:38 <benmachine> Fuco: haskell cares :(
05:50:44 <Fuco> Ok, so it's not possible?
05:50:47 <bremner> Fuco: that is sortof like saying I don't care about gravity, I just want to fly
05:50:51 <dcoutts> fryguybob: cabal install gitit cautious-file -f-unix
05:50:52 <hpc> @hoogle random [a]
05:50:52 <lambdabot> Control.Monad.List runListT :: ListT m a -> m [a]
05:50:53 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
05:50:53 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
05:50:57 <Fuco> not everyone is a haskell pro
05:51:03 <benmachine> Fuco: exactly what you are asking is not possible, but there are plenty of things which are basically as good
05:51:06 <Fuco> it seems you guys don't realize it
05:51:24 <Kaidelong> oh right
05:51:35 <Kaidelong> > evalRand (mkStdGen 4) $ do {n <- getRandomR (0,10); replicateM n (getRandomR (1,5) :: Rand StdGen Int)}
05:51:36 <lambdabot>   Couldn't match expected type `Control.Monad.Random.Rand a a1'
05:51:36 <lambdabot>         again...
05:51:58 <benmachine> Kaidelong: maybe work it out in PM and then come back :P
05:52:21 <Kaidelong> no I got it!
05:52:29 <Kaidelong> > flip evalRand (mkStdGen 4) $ do {n <- getRandomR (0,10); replicateM n (getRandomR (1,5) :: Rand StdGen Int)}
05:52:30 <fryguybob> dcoutts: Thanks.  That works (with -f-posix).
05:52:31 <lambdabot>   [1,2]
05:52:43 <Kaidelong> well that's not a very interesting random list
05:52:46 <benmachine> heh
05:52:48 <Kaidelong> but that is how you would do it
05:52:54 <benmachine> try a different seed?
05:53:04 <Kaidelong> > flip evalRand (mkStdGen 4435) $ do {n <- getRandomR (0,10); replicateM n (getRandomR (1,5) :: Rand StdGen Int)}
05:53:05 <lambdabot>   [5,3,2,2,3,4,3,4,3,4]
05:53:08 <benmachine> yay
05:53:26 <scree> > randomRs (1,100) (mkStdGen 1235)
05:53:27 <lambdabot>   [74,93,39,77,70,5,77,75,83,28,13,48,98,34,11,86,86,25,65,55,65,77,31,16,98,...
05:53:38 <bremner> Fuco: there is a pretty comprehensive discussion of random number generation in real world haskell.
05:53:38 <sipa> Fuco: there you have it
05:54:07 <Kaidelong> I'd really recommend you use MonadRandom rather than working with System.Random directly
05:54:23 <benmachine> Kaidelong: but monads are scary :O :O :O
05:54:49 <Kaidelong> MonadRandom isn't hard though
05:54:51 <hpc> benmachine: that reminds me of one of my CS teachers
05:55:21 <scree> Fuco: if you're happy to learn MonadRandom, you should; otherwise, call randomRs with your favourite seed and pass the list around
05:55:34 <hpc> he is very derisive of haskell because "monads are too complicated", then says haskell has syntactic loops, when scheme doesn't
05:55:38 <Kaidelong> Fuco: basically, MonadRandom lets you label values as Rand in the same way you can label values as IO. Inside a do block you can use the <- arrow to get the value out of a rand value just like inside IO.
05:56:03 <Fuco> I don't understand monads very well
05:56:14 <Kaidelong> well you should look at LYAH
05:56:24 <Kaidelong> they have some really nice examples of using IO
05:56:26 <hpc> @where lyah
05:56:26 <lambdabot> http://www.learnyouahaskell.com/
05:56:34 <Kaidelong> MonadRandom isn't that different from IO
05:56:57 <scree> Fuco: is this part of some 'learning haskell' project, or is it a real-world thing you want to get done?
05:57:30 <Fuco> no, it's just me fooling around
05:57:30 <Kaidelong> hpc: why would he say that? Ignorance?
05:57:36 <hpc> Kaidelong: so much ignorance
05:57:44 <Kaidelong> willful?
05:57:50 <hpc> no idea
05:58:21 <hpc> he is also the robotics professor, and claims "robots don't always do what you want" while giving us buggy drivers
05:58:36 <Fuco> what I want pretty much is test some of my algorithms and I'm lazy to handcraft 1000 inputs...
05:58:41 <Fuco> so I want a random list :P
05:58:57 <Kaidelong> Fuco: well then you really should be using QuickCheck!
05:59:02 <Kaidelong> or HUnit perhaps
05:59:06 <hpc> (i thankfully only have him for 101, so the deepest we get into his obsession is a roomba)
05:59:08 <Fuco> and yes, I could prove them with math but that won't tell me how fast it is
05:59:20 <Fuco> well, fast on a real machine, not in theory :)
05:59:24 <scree> Fuco: just a random list of integers, or data with a more complex structure?
05:59:56 <Fuco> yes, just a random list of integers
06:00:04 <Kaidelong> Fuco: replicateM 1000 getRandom :: Rand [Int]
06:00:10 <benmachine> Fuco: do you know how to do basic IO?
06:00:32 <Fuco> not really
06:00:42 <Axman6> time to learn!
06:00:50 <scree> then "randomRs (1, n) (mkStdGen 100)" is your simplest solution ATM
06:00:53 <Axman6> @googler axman's io tutorial
06:00:54 <lambdabot> No Result Found.
06:00:58 <Axman6> bah
06:01:00 <Fuco> yea, gonna write a C random gen and pipe it into haskell :P
06:01:01 <Kaidelong> I'd really worry about getting IO down before worrying about testing or profiling
06:01:21 <Kaidelong> Fuco: that sounds a lot more complicated than just learning how to do IO
06:01:25 <sipa> :t randomRs
06:01:26 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
06:01:27 <Kaidelong> well
06:01:31 <Kaidelong> you'll have to learn IO anyway
06:01:44 <sipa> and you'll IO to get the data from C into Haskell as well
06:01:50 <Kaidelong> in which case you'd basically already know MonadRandom
06:01:56 <Axman6> > take 20 $ randoms (1,100) (mkStdGen 173)
06:01:57 <lambdabot>   Couldn't match expected type `System.Random.StdGen -> [a]'
06:01:57 <lambdabot>         against ...
06:02:11 <Kaidelong> @more
06:02:14 <Axman6> > take 20 $ randomRs (1,100) (mkStdGen 173)
06:02:14 <sipa> :t mkStdGen
06:02:15 <lambdabot>   [6,37,4,13,80,95,97,55,100,19,17,56,59,39,16,37,13,68,57,53]
06:02:15 <lambdabot> Int -> StdGen
06:02:34 <Axman6> > take 80 $ randomRs (1,100) (mkStdGen 173)
06:02:35 <lambdabot>   [6,37,4,13,80,95,97,55,100,19,17,56,59,39,16,37,13,68,57,53,39,90,21,63,93,...
06:02:47 <scree> I think it's fair enough to want to get something done before you've learnt a large chunk of the language
06:02:52 <Fuco> well, all right then
06:03:13 <Kaidelong> scree: you can't write useful programs without knowing IO
06:03:14 <benmachine> scree: all right, but you'll have to know how to do IO to get much done
06:03:24 <benmachine> you won't have to know how it works or why or how to do clever tricks with it
06:03:33 <Kaidelong>  
06:03:36 <benmachine> but you will at least need to know stuff like "getting input", "printing output"
06:03:48 <benmachine> if you know stuff like that you can do random numbers
06:04:15 <Fuco> benmachine: well I'm more interested in just figuring out the algorithm then actually using it :D
06:04:32 <sipa> which algorithm?
06:04:38 <Kaidelong> Fuco: what's the algorithm? Perhaps you could just handle it with quickcheck
06:04:56 <Kaidelong> @type quickCheck
06:04:57 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
06:04:58 <hpc> quickcheck isn't that much easier than just learning IO
06:05:01 <Fuco> I'm doing some graph algos... search, flows and such
06:05:02 <Fuco> for our course
06:05:09 <Fuco> like a prep for exam
06:05:14 <Fuco> and I said well haskell looks like math
06:05:16 <Fuco> so why not
06:05:34 <scree> benmachine: I agree you then know how to call "a <- random"
06:05:41 <hpc> :t random
06:05:42 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
06:05:46 <Kaidelong> :t getRandom
06:05:47 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m a
06:05:48 <scree> benmachine: I agree you then know how to call "a <- randomIO"
06:05:53 <scree> (sorry)
06:05:56 <ksf> oh, but functional versions of graph algorithms look vastly different from the imperative versions.
06:05:57 <hpc> heh
06:06:05 <ksf> Fuco, but you might seriously enjoy reading the fgl paper
06:06:06 <Kaidelong> :t getRandomIO
06:06:07 <lambdabot> Not in scope: `getRandomIO'
06:06:12 <Axman6> Fuco: haskell has some very good graph libraries i believe
06:06:14 <Fuco> ksf: probably, but it is a math course
06:06:17 <Fuco> not a programming course
06:06:17 <Kaidelong> oh right
06:06:18 <scree> benmachine: but that's different to a <- replicateM 100 (rondomIO)
06:06:19 <hpc> @instances Random
06:06:19 <lambdabot> Couldn't find class `Random'. Try @instances-importing
06:06:26 <Axman6> :t randomIO
06:06:27 <lambdabot> forall a. (Random a) => IO a
06:06:29 <hpc> @instances-importing Control.Random Random
06:06:29 <lambdabot> Couldn't find class `Random'. Try @instances-importing
06:06:34 <ksf> Fuco, http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01
06:06:37 <Fuco> Axman6: and library will help me learn it how exactly? :D
06:06:41 <ksf> "Inductive Graphs and Functional Graph Algorithms"
06:06:44 <hpc> @instances-importing System.Random Random
06:06:45 <lambdabot> Bool, Char, Double, Float, Int, Integer
06:06:49 <Fuco> I can do "import graph" in any language :)
06:07:00 * hpc wishes for a Random a => [a] instance
06:07:24 * sipa wasn't aware that [] is a type class
06:07:32 <hpc> sipa: instance for Random
06:07:33 <benmachine> scree: but it's not that different from gen <- newStdGen; let xs = randomRs gen
06:07:41 <sipa> hpc: sorry, i was nitpicking :)
06:07:42 <ksf> Fuco, there's important represantation questions, though.
06:07:45 <hpc> :D
06:07:51 <scree> benmachine: no, sure
06:08:24 <ksf> and fgl, being inductive, tends to look _very_ mathy.
06:08:38 <scree> I was more disputing Kaidelong> in which case you'd basically already know MonadRandom
06:09:15 <ksf> not as general and concise as graph rewriting frameworks, but then you don't want to stumble across np-completeness all the time.
06:09:33 <Kaidelong> what'd you still need to learn do be able to do stuff like "a <- getRandom" or "b <- someRandomValue"?
06:10:04 <Kaidelong> the one thing that would be different would be evalRand, evalRandT, and evalRandIO?
06:10:55 * hackagebot derive-trie 0.1.0 - Automatic derivation of Trie implementations.  http://hackage.haskell.org/package/derive-trie-0.1.0 (AndreasBaldeau)
06:10:57 * hackagebot control-monad-failure-mtl 0.7.0.1 - A class for monads which can fail with an error for mtl 1  http://hackage.haskell.org/package/control-monad-failure-mtl-0.7.0.1 (MichaelSnoyman)
06:11:08 <revenantphx> threadDelay waits in *microseconds?*
06:11:15 <revenantphx> As in, millionth of a second?
06:11:30 <ksf> no that'd be nano.
06:11:34 <ksf> micro is thousdandth.
06:11:46 <Kaidelong> wouldn't that be milli?
06:11:54 <ksf> no that's 100
06:11:56 <hpc> http://en.wikipedia.org/wiki/Micro-
06:12:04 <tg_> 10 ^ -6 seconds
06:12:13 <ksf> er.
06:12:14 <sipa> miliseconds = 1/1000s
06:12:20 <sipa> microseconds = 1/1000000 s
06:12:20 <Kaidelong> ksf: language difference perhaps?
06:12:38 <ksf> well, no. I'm talking about milliseconds.
06:12:43 <sipa> mili micro and nano are SI standard prefixes
06:12:45 <tg_> http://lmgtfy.com/?q=1+microsecond+in+seconds
06:12:46 <ksf> ms, not μs
06:12:46 <hpc> at that level of detail, you might as well be threadDelaying in clock cycles
06:13:17 <sipa> revenantphx: answer to your questions: yes, millionth of a seconds
06:13:43 <revenantphx> milli is thousanth, micro is millionth.
06:13:49 <ksf> ...but don't expect to get anywhere near than resolution.
06:13:57 <benmachine> threadDelay only guarantees "at least this long"
06:14:24 <revenantphx> I'm silly and find it funny when people thing 2 km * 2 km is 2 km^2
06:14:48 <revenantphx> it's (2 km)^2 or 4km^2
06:14:48 <tg_> revenantphx: multiply the units and not the numbers?
06:14:54 <hpc> revenantphx: it's an understandable mistake for a high-schooler
06:14:58 <revenantphx> Yeah, people dont get that *both* are multiplied.
06:15:09 <revenantphx> For instance, a 40km by 40km area is 1600km^2
06:15:11 <revenantphx> not 40km&2
06:15:21 <Jafet> > (2 * k*m)^2
06:15:22 <ksf> it's (2*2)(km*km)
06:15:22 <lambdabot>   2 * k * m * (2 * k * m)
06:15:24 <tg_> i would have thought the other mistake more common
06:15:30 <tg_> to not give units of area, but to give the right constant
06:15:32 <sipa> clearly, the "km" suffix operator binds more tightly than the square :)
06:15:37 <benmachine> but it always annoys me when people say two kilometre square and don't say whether they mean two square kilometres or two kilometres squared
06:15:38 <sipa> problem solved
06:16:02 <revenantphx> The thing is, english is not associative
06:16:12 <Jafet> Or even a two-kilometer square
06:16:17 <hpc> english is barely even transitive
06:16:18 <revenantphx> yeah really
06:16:25 <revenantphx> I usually just say "square kilometers"
06:16:30 <revenantphx> So it's unmistakeable.
06:16:35 <benmachine> Jafet: uhm which one is that
06:16:39 <revenantphx> 4 square kilometers. Pretty simple.
06:16:49 <Jafet> A square that's two kilometers, whatever that means
06:16:50 <tg_> that is to say, 4 really uncool kilomters.
06:16:54 <benmachine> oh right
06:16:57 <benmachine> heh
06:17:00 <revenantphx> tg_: hah.
06:17:04 <hpc> hehe
06:17:13 <benmachine> personally I avoid the issue by never referring directly to measures of area
06:17:21 <tg_> oh?
06:17:25 <benmachine> "big" and "small" are enough for me.
06:17:28 <tg_> oh
06:17:31 <revenantphx> I just refer to land as "as much as your best steed is worth"
06:17:31 <koala_man> and people who say they have a 21" monitor!
06:17:31 <benmachine> :P
06:17:38 <benmachine> yes
06:17:38 <revenantphx> bbl
06:17:52 <hpc> benmachine: "two-dimensional" is enough for me :P
06:17:56 <benmachine> heheh
06:18:06 <tg_> i work with fractals, so even that won't suffice
06:18:55 <tg_> and I suppose slightly less worse are dimensionless numbers
06:18:57 * hackagebot bson 0.1 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1 (TonyHannan)
06:20:48 <Jafet> "A nerd wants to carry a 2' screen onto a plane, but the security man insists he must check in any item larger than 21". How should he proceed?"
06:20:53 <tg_> If I say something bad about Steve Yagge's article, is anyone here going to be offended?
06:22:22 <hpc> Jafet: the answer to all such airport problems is a cavity search
06:22:30 <revenantphx> dmwit: I tested binary-protocol, and it seems it's fine sending partial values.
06:22:51 <revenantphx> I sent 3 ints at one second delays to a server expecting a data type made up of three ints 
06:22:58 <revenantphx> and it just delayed till it had it all.
06:25:58 <Jafet> hpc: more seriously, whether he can bring in carry-on without bothering the security man depends on the screen's aspect ratio
06:26:29 <Eduard_Munteanu> Guys, I'm having a real performance issue here, I have a test case: http://paste.pocoo.org/show/298982/
06:26:52 <Eduard_Munteanu> This runs in real    0m0.434s on a 2.2MiB file.
06:27:01 <Eduard_Munteanu> I think this is way too much.
06:27:20 <Eduard_Munteanu> What the hell is going on?
06:27:42 <Philippa_> tg_: I doubt it
06:28:12 <dankna> if that isn't sarcasm, generate a file of about a gig and try it on that
06:28:17 <dankna> you may simply be seeing startup overhead
06:28:29 <Jafet> System.Process.system $ "gzip " ++
06:28:54 <Eduard_Munteanu> Here's the profile: http://paste.pocoo.org/show/298983/
06:29:00 * hackagebot smallarray 0.1.0 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.1.0 (AntoineLatter)
06:29:15 <Eduard_Munteanu> Compiled with ghc -O2 --make perf.hs -fforce-recomp (-prof -auto-all -caf-all)
06:29:19 <lars9> @instances Monoid
06:29:20 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
06:29:37 <tg_> Eduard_Munteanu: double the file size, run again. Then, increase the file size by 100, and try again.
06:29:38 <tg_> Check the scaling
06:30:06 <Eduard_Munteanu> Thanks, lemme see...
06:31:20 <Eduard_Munteanu> tg_: real    0m0.835s  when doubled
06:31:26 <Eduard_Munteanu> Seems to scale linearly.
06:32:03 <Eduard_Munteanu> Most of the time is spent in 'user' (using 'time' on Linux)
06:32:25 <tg_> try something bigger
06:32:30 <tg_> just to be sure
06:32:42 <tg_> try 100 times larger than the original
06:33:19 * Eduard_Munteanu tries...
06:33:51 <revenantphx> Um.
06:34:02 <revenantphx> For a data type, do I have to explicitly export all of the data constructors?
06:34:21 <Eduard_Munteanu> revenantphx: no, you can use Type(..)
06:34:24 <dankna> DataType(..) in the export list will export all the constructors
06:34:28 <revenantphx> what?
06:34:32 <revenantphx> (..)
06:34:38 <Eduard_Munteanu> Yes, literally.
06:36:07 * hackagebot smallstring 0.1.0 - A string type optimized for size in memory  http://hackage.haskell.org/package/smallstring-0.1.0 (AntoineLatter)
06:38:59 <Eduard_Munteanu> tg_: real    1m42.257s on a 512MiB file.   512/2.2 = 232.73, (60 + 42.257) / 0.434 = 235.62   ===> linear scaling
06:39:15 <Eduard_Munteanu> generated using dd from /dev/urandom
06:40:08 <revenantphx> Um.
06:40:09 <revenantphx> One question.
06:40:17 <tg_> Eduard_Munteanu: okies
06:40:26 <revenantphx> If I'm using receive from binary-protocol
06:40:42 <revenantphx> how can I force it to use a certain *data-constructor* for the data it receives
06:40:48 <revenantphx> If I did something like pkt <- receive :: BinaryProtocol ClientToServerPacket
06:40:59 <revenantphx> then it doesn't know which data constructor to use D:
06:41:30 <Jafet> @hoogle receive
06:41:30 <lambdabot> Network.HTTP receiveHTTP :: HStream ty => HandleStream ty -> IO (Result (Request ty))
06:41:30 <lambdabot> Network.HTTP.HandleStream receiveHTTP :: HStream bufTy => HandleStream bufTy -> IO (Result (Request bufTy))
06:41:31 <lambdabot> Network.HTTP.Stream receiveHTTP :: Stream s => s -> IO (Result Request_String)
06:41:39 <revenantphx> not that one.
06:41:47 <revenantphx> @hoogle Control.Monad.BinaryProtocol.receive
06:41:47 <lambdabot> No results found
06:41:51 <Eduard_Munteanu> revenantphx: you'll have to pattern match, it might not receive what you want.
06:41:52 <tg_> Eduard_Munteanu: I was just instructing you to carry out dankna's suggestion, I don't have any further ones
06:42:01 <tg_> sorry :(
06:42:11 <revenantphx> Eduard_Munteanu: But what if it blocks waiting for the largest one or something TT_TT
06:42:13 <revenantphx> http://hackage.haskell.org/packages/archive/binary-protocol/1.0/doc/html/Control-Monad-BinaryProtocol.html
06:42:16 <Eduard_Munteanu> tg_: thanks.
06:42:32 <Eduard_Munteanu> dankna: it seems it's not only startup overhead.
06:42:37 <revenantphx> for send I can do
06:42:41 <revenantphx> send (CTSHandshake "handshakestr")
06:42:55 <Eduard_Munteanu> dankna: < Eduard_Munteanu> tg_: real    1m42.257s on a 512MiB file.   512/2.2 = 232.73, (60 + 42.257) / 0.434 = 235.62   ===> linear scaling
06:43:07 <dankna> okay, hmm
06:43:35 <Jafet> Eduard: why is IntSet O?
06:43:38 <dankna> I confess I haven't looked at the code closely enough to really grasp what it's doing
06:44:15 <Eduard_Munteanu> Jafet: heh, it corresponds to some real code I've written, where I also used Seq and didn't have S available. And O looked like a Venn diagram :)
06:44:46 <sipa> O?
06:45:05 <tg_> OO, a venn diagram, explaining disjointedness
06:45:15 <Eduard_Munteanu> dankna: it simulates something I do in a real program. It traverses a tree to figure out a coding for a certain symbol. In this testcase it really means nothing. Also you can change the levels of the tree to increase overhead, but it's high even with 1 level.
06:45:23 <dankna> gotcha
06:45:55 <dankna> so the actual application is like Huffman coding or whatever
06:45:56 <Jafet> Still on prefix-free coding?
06:46:03 <revenantphx> What
06:46:03 <revenantphx> the 
06:46:04 <revenantphx> fuck
06:46:05 <Eduard_Munteanu> dankna: yep, it's Shannon-Fano though.
06:46:05 <revenantphx> is this magic?
06:46:08 <dankna> gotcha
06:46:10 <Jafet> I don't get why you need a Tree of IntSet...
06:46:10 <revenantphx> I just case statement'd my packets.
06:46:15 <revenantphx> And it SOMEHOW FIGURES OUT WHICH IS WHICH
06:46:17 <revenantphx> 0.o
06:46:27 <revenantphx> There's some kind of black magic going on here. Seriously.
06:46:35 <Jafet> revenantphx: calm down, then look at erlang's magic bitwise pattern matching
06:46:38 <dankna> yeah, pattern matching is nice
06:46:38 <haskel_newbie> ;]
06:46:52 <revenantphx> But I can't tell which way it's matching D:
06:46:56 <Eduard_Munteanu> Jafet: I don't. I want to keep Haskell code as close as possible to my C code, and seemingly this kind of design should be suited to Haskell code.
06:47:03 <revenantphx> is it matching what it receives to the case statement, or both?
06:47:03 <Eduard_Munteanu> As in it shouldn't pose problems.
06:47:09 <revenantphx> Is it somehow jumping back and forth inferring?
06:47:50 <Eduard_Munteanu> %GC time      69.8%  (69.4% elapsed)
06:48:04 <sipa> revenantphx: both
06:48:13 <revenantphx> This is so magic it's not even funy.
06:48:17 <Eduard_Munteanu> But I don't think that's a problem, I increased the heap in smaller runs, thus reducing GC to < 3%. But it didn't help much.
06:48:26 <sipa> revenantphx: i tries to infer types that match, and it uses all information available
06:48:35 <dankna> Eduard_Munteanu, well, of course the profile says lookupTree' is the cost center, but I'm not immediately sure how to improve it
06:48:36 <revenantphx> That is so amazing I don't even.
06:48:40 <Jafet> Pattern matching is extremely simple. It checks which data constructor was used to make a value.
06:48:49 <Jafet> Unless you're doing some other kind of pattern matching
06:48:57 <dankna> he's using Erlang
06:49:19 <Jafet> Oh crap!
06:50:23 <JeroenDL> Is there a way I can have a 'contains' function of my own and still use the List.contains function ?
06:50:44 <sipa> yes
06:50:52 <JeroenDL> How ? :)
06:51:09 <sipa> import qualified List
06:51:13 <quicksilver> JeroenDL: import qualified List(contains) as L
06:51:20 <Eduard_Munteanu> joni6128: import Data.List qualified for contains.
06:51:20 <quicksilver> import List hiding (contains)
06:52:29 <JeroenDL> Thx :)
06:52:51 <Jafet> @hoogle contains
06:52:51 <lambdabot> No results found
06:53:17 <Eduard_Munteanu> I get 1m37s after cabal install --reinstall bytestring-0.9.1.7 binary --disable-library-profiling --disable-executable-profiling -O
06:53:30 <Eduard_Munteanu> I previously had the profiling version. Something, but not much.
06:53:46 <Jafet> If the non-profiling version ran much faster, you'd have a bug to report in the profiler
06:54:11 <Saizan> when you enable library profiling you get both versions built
06:54:12 <Eduard_Munteanu> Yeah, I don't think it's significant.
06:54:15 <benmachine> Eduard_Munteanu: why do you have an accumulator in lookupTree' instead of guarded recursion?
06:54:18 <Eduard_Munteanu> Saizan: oh.
06:54:30 <Eduard_Munteanu> benmachine: that's an attempt on my part to improve performance.
06:54:39 <Eduard_Munteanu> Didn't do much.
06:54:49 <benmachine> Eduard_Munteanu: it looks to me like it would worsen things because then the whole list needs to be kept
06:55:10 <Eduard_Munteanu> benmachine: the whole list so far is 1-2 elements long.
06:55:21 <benmachine> oh
06:57:42 <learning_haskell> quit
06:57:45 <learning_haskell> exit
06:58:50 <benmachine> Eduard_Munteanu: so why did the profile say cons was being entered like 2 million times?
06:58:53 <revenantphx> Holy shit.
06:58:55 <revenantphx> This is amazing.
06:59:17 <revenantphx> My hypothesis: haskell is being lazy and when its asked to "get" a ServerToClientPacket, it's only getting as much as it needs for the case statement (1 byte)
06:59:25 <revenantphx> So it can always figure out the type.
06:59:45 <benmachine> revenantphx: lazy IO is evil :P
07:00:02 <Axman6> heh, nice
07:00:04 <revenantphx> Ah, but in this case it's oh so helpful.
07:01:04 <benmachine> revenantphx: there isn't really anything it can do that normal IO can't
07:01:12 <revenantphx> No, but it's just easier :P.
07:01:14 <Eduard_Munteanu> benmachine: because the file size is large.
07:01:35 <Eduard_Munteanu> benmachine: I run it on a 512MiB file. For each Word8, lookupCode is called.
07:01:47 <benmachine> Eduard_Munteanu: so if the cons is being used a lot, then surely the list is being accumulated a lot?
07:02:49 <Eduard_Munteanu> benmachine: not really, I use concatMap. So the list is accumulated only for each lookupCode call. This results in a list of lists, but the smaller lists are only 1-2 elements long.
07:03:20 <benmachine> Eduard_Munteanu: remind me how you generate your input files
07:03:34 <Eduard_Munteanu> benmachine: dd if=/dev/urandom of=... bs=1M count=512
07:03:56 <revenantphx> this is so magic
07:03:56 <revenantphx> https://gist.github.com/725486
07:04:11 <Eduard_Munteanu> benmachine: the computation itself is meaningles.s
07:04:35 <benmachine> yeah I got that
07:06:28 <Eduard_Munteanu> Improved version, more strictness: http://paste.pocoo.org/show/298997/
07:06:48 <Eduard_Munteanu> Compiled with ghc -O2 --make perf.hs -fforce-recomp -funbox-strict-fields, kinda the same results.
07:07:37 * hackagebot uAgda 1.0.0.0 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.0.0.0 (JeanPhilippeBernardy)
07:08:09 <Eduard_Munteanu> I could try making a simpler version without IntSet and/or bytestrings, maybe I can narrow it down.
07:09:58 <identity_> Wrapping a monad one is basically making out of other monads in a newtype, is that mainly done to hide the interface or some such?
07:09:59 <Eduard_Munteanu> But somehow I think consing is slow, perhaps due to allocation overhead.
07:10:10 <identity_> And what do I need to be doing when I do this? Do I need to derive any instances?
07:12:44 * hackagebot uAgda 1.0.0.1 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.0.0.1 (JeanPhilippeBernardy)
07:13:49 <Twey> Is that µAgda?
07:13:54 <shapr> Aw, I'm going to miss meeting Adam Chlipala at the BostonHaskell dinner tonight in Cambridge MA!
07:15:38 <benmachine> Eduard_Munteanu: you might be right, I tried inlining the summing into the lookupTree and it went about three times faster
07:15:42 <Saizan> shapr: voluntarily?:D
07:16:24 <identity_> If I create a newtype wrapper around stateT without -XGeneralizedNewtypeDeriving, will I have to make it an instance of all the different monad classes myself for it to work conveniently?
07:16:55 <benmachine> identity_: depends what you need it to do
07:17:07 <benmachine> you will have to make a few instances but none of them should be hard
07:17:40 <identity_> benmachine: Well, I'm kind of struggling here. As I understand, wrapping your stuff in a newtype (as opposed to just using a type synonym) can be good practice to hide the implementation or some such
07:17:42 <Saizan> there's another approach
07:17:59 <Saizan> where you don't make instances of the MonadFoo classes
07:18:26 <Saizan> but you rather implement some domain specific operations and use only those as an API for your monad
07:18:26 <benmachine> identity_: right, if you want to hide the implementation you might not want to instance everything
07:18:39 <Eduard_Munteanu> benmachine: hm, that's interesting. But how would you inline the summing there?
07:18:54 <identity_> Saizan: Hmm
07:19:03 <Saizan> (cale.yi.org is down though, or i could have pointed you to the article about this)
07:19:12 <benmachine> Eduard_Munteanu: http://paste.pocoo.org/show/299001/
07:19:26 <benmachine> (the bang pattern is probably unnecessary)
07:19:42 <Eduard_Munteanu> Oh, I see.
07:19:58 <identity_> Saizan: All in all, what I want to do with newtype FooMonad a = FooMonad { doFoo :: StateT FooData IO a } is to be able to run stuff in that monad whilst retrieving state and all that. Will it need to be an instance of MonadState for that to work?
07:20:16 <identity_> (and lift to IO)
07:20:35 <Eduard_Munteanu> Very very simple example that runs even slower!  http://paste.pocoo.org/show/299002/
07:20:48 <Eduard_Munteanu> 2m4.258s on the same data set.
07:21:11 <Saizan> identity_: you need a MonadState instance if you want to use get and set
07:21:22 <Saizan> identity_: directly, i mean
07:21:26 <identity_> I see
07:21:31 <identity_> ah
07:21:36 <benmachine> Eduard_Munteanu: I don't know why you do those weird cases on booleans
07:21:36 <identity_> I think I'm just confusing myself
07:21:42 <benmachine> Eduard_Munteanu: guards will end up as cases anyway
07:22:02 <Eduard_Munteanu> Hm yeah, style could be better.
07:22:05 <Saizan> identity_: you could write "FooMonad get" of course
07:22:17 <Eduard_Munteanu> Though it shouldn't affect performance.
07:22:20 <benmachine> sure
07:22:27 <benmachine> but I thought you were doing it for performance
07:22:30 <benmachine> which would be a waste of time
07:22:31 <benmachine> :P
07:23:10 <JeroenDL> Can someone help me with this? I'm trying to use map to edit all the tree elements at once (like 'add 20'): http://pastebin.com/535rX7re
07:23:12 <benmachine> anyway I gotta go
07:23:14 <benmachine> good luck
07:23:24 <JeroenDL> But the tree remains unchanged
07:23:45 <Axman6> JeroenDL: things don't change in haskell, you make new things with the modifications you want
07:23:50 <Eduard_Munteanu> benmachine: thanks
07:23:51 <Saizan> benmachine, Eduard_Munteanu: what is cons there? just (:) ?
07:24:05 <Eduard_Munteanu> Saizan: yes, I separated it to toplevel for profiling.
07:24:12 <Eduard_Munteanu> (so I don't add messy SCC annotations)
07:24:35 <shapr> Saizan: Well, I'm in Alabama, not Massachusetts... so, sort of?
07:24:36 <Saizan> then the seq on acc is quite useless
07:25:10 <Eduard_Munteanu> Yeah, it doesn't improve things.
07:25:26 <JeroenDL> Axman6:  isnt that what I'm doing ? :$
07:25:50 <Axman6> JeroenDL: yes, but are you looking at the thing that mapmtree returns or not?
07:27:02 <Saizan> JeroenDL: http://pastebin.com/GA0GAPWA
07:27:11 <tg_> shapr: I was going to remark: oh shucks, I won't see him either! Though I didn't know that I wouldn't until you told me. So, in effect, you made me sad. :(
07:27:47 <shapr> tg_: Aw, I'm sorry.
07:27:56 <JeroenDL> Oh, right, I forgot an '(f)'
07:27:59 <Eduard_Munteanu> So it is a performance bug or not?
07:28:05 <JeroenDL> Thx Saizan, trying it out now
07:28:11 <shapr> tg_: If you have the chance to attend the Boston Haskell User's group, lots of smart people writing awesome code there!
07:28:36 <JeroenDL> Its working ... Should have seen that myself, but thx Saizan & Axman6 !
07:28:43 <Eduard_Munteanu> I could try making a similar C implementation.
07:29:00 <Eduard_Munteanu> *is it
07:29:25 <tg_> shapr: you should join the Atlanta HUG
07:29:37 <shapr> tg_: I've got a Huntsville Knitting & Haskell group started.
07:29:57 <tg_> shapr: I'm only impressed if you're knitting hyperbolic geometry
07:30:21 <tg_> in which case I'm very, very impressed
07:30:30 <shapr> tg_: Bah, I haven't even gotten past this functional purl - data Stitch = Purl | Knit
07:31:23 <tg_> surely that's a good starting point
07:31:56 * hackagebot regular-extras 0.2.2 - Additional functions for regular: arbitrary,  coarbitrary, and binary get/put.  http://hackage.haskell.org/package/regular-extras-0.2.2 (JosePedroMagalhaes)
07:31:58 <shapr> Truly... I should ask sioraiocht if he has other ideas for modeling knitting in Haskell.
07:31:58 * hackagebot hslogger-template 1.1.2 - Automatic generation of hslogger functions  http://hackage.haskell.org/package/hslogger-template-1.1.2 (BrianLewis)
07:32:06 <sioraiocht> hihi
07:32:20 <tg_> shapr: by the way, the knitting thing was a reference to  http://www.ted.com/talks/margaret_wertheim_crochets_the_coral_reef.html
07:32:30 <sioraiocht> well
07:32:32 <revenantphx> Is there a way to take two monadic actions of the same type (both just BinaryProtocol())
07:32:36 <revenantphx> and compose them into one?
07:32:45 <sioraiocht> shapr: you need increase/decrease stitches as well
07:33:03 <revenantphx> @hoogle m a -> m a -> m a
07:33:03 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
07:33:04 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
07:33:04 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
07:33:04 <quicksilver> revenantphx: >>
07:33:08 <sioraiocht> shapr: are you trying to construct a DSL for knitting patterns?
07:33:18 <revenantphx> quicksilver: within the context of the parameter of a function, but true
07:33:28 <revenantphx> I'm wondering if theres a more (.) like thing.
07:33:29 <tg_> shapr: what have i done
07:33:34 <quicksilver> revenantphx: I don't understand what you mean.
07:33:37 <tg_> sioraiocht: no, I think we've taken a joke far out of context
07:33:40 <revenantphx> Ok, I have two actions.
07:33:42 <quicksilver> revenantphx: (>>) is very (.)-like.
07:33:44 <revenantphx> One I want to do once, the other forever.
07:33:55 <sioraiocht> tg_: it wouldn't be a bad idea, though
07:34:00 <shapr> sioraiocht: Not really, I've been spending more time trying to finish this scarf by Christmas. But I would be interested since my plan is to knit with conductive thread.
07:34:03 <sioraiocht> automagically generate knitting charts...
07:34:12 <revenantphx> I want to do something like this
07:34:13 <revenantphx> runProtocol (initBot >> forever $ minecraftBotProtocol) h h
07:34:29 <revenantphx> oh right, remove the $ and thats perfect
07:34:31 <sioraiocht> shapr: I have one more sweater to finish before christmas =)
07:34:37 <roconnor> revenantphx: correct
07:34:40 <quicksilver> revenantphx: right, it looks fine part from the $ ;)
07:34:48 <sioraiocht> I decided at the last minute to knit it top-down even though the pattern is written bottom up
07:35:08 <roconnor> runProtocol (initBot >> (forever $ minecraftBotProtocol)) h h
07:35:10 <aristid> revenantphx: do you mean: runProtocol (initBot >> forever minecraftBotProtocol) h h?
07:35:11 <roconnor> would also work
07:35:14 <roconnor> but would be silly
07:35:18 <revenantphx> yeah, my bot.
07:35:20 <aristid> roconnor: well, or just skip the $
07:35:27 <nostard> how do i install profiling support for cabal packages?
07:35:29 <revenantphx> :D
07:35:34 <revenantphx> even without the case, its figuring it out.
07:35:58 * hackagebot stepwise 1.0 -   http://hackage.haskell.org/package/stepwise-1.0 (ArieMiddelkoop)
07:35:59 <shapr> sioraiocht: Have you seen Travis Goodspeed's recent hack of a Brother automated Knitting machine? I know he's using msp430s, so I've been curious about turning the atom library from hackage into an msp430 lib instead.
07:36:18 <roconnor> I don't quite get what minecraft is.  From the video I saw it looked like rollercoster tycoon.
07:36:20 <dcoutts_> nostard: see cabal install --help, there's a flag to enable it
07:36:22 <sioraiocht> shapr: hahah nice
07:36:26 <nostard> dcolish: thanks =)
07:36:38 <sioraiocht> shapr: no, I haven't, though
07:38:07 <aristid> roconnor: you mine, and build shelters and stuff, and be attacked by spiders and zombies and, worst of all, exploding green creatures. that's minecraft, basically
07:38:22 <roconnor> aristid: where does the rollercoaster fit in?
07:38:27 <sioraiocht> shapr: ah, I have now
07:39:32 <nostard> dcoutts: thanks =)
07:39:46 <shapr> Multi-Threaded Banjo Dinosaur Knitting Adventure 2D Extreme ! Needs a Knitting DSL in Haskell!
07:39:50 <roconnor> ``The game is a lot like that, but also has enemies and cave exploring and mining and farming and flowing water and dynamic lighting and a huge (huge) randomly generated world map.
07:40:08 <roconnor> that description sounds like dwarf fortress, ... except for the dynamic lighting bit
07:40:33 <quicksilver> in general genre it is like dwarf fortress, I believe
07:40:49 <quicksilver> in that it's open-ended, with rules complex enough to allow for surprising creations and/or behaviours
07:41:19 <quicksilver> I saw this with the certain knowledge of someone who has played neither, but I heard about them on the intertubes.
07:46:30 <lars9> need some simple GUI, is gtk2hs the best choice now?
07:46:36 <Jafet> Until your game can implement a 16-bit adder that involves tossing little people into pits of lava after they complete the computation, it's not dwarf fortress.
07:47:46 <aristid> roconnor: well, the rollercoaster is something you can build
07:47:50 <quicksilver> lars9: it's certainly a reasonable choice; wx is a reasonable choice.
07:47:57 <aristid> roconnor: it's essentially just a huge rail track
07:48:16 <quicksilver> lars9: not many people have used both to compare.
07:48:22 <ash_> are there conditional maps? Like, for instance, say I have a list and I want to find just the first occurrence of a value, can you use a map that will stop iterating after it is successful? 
07:48:46 <revenantphx> What would I do if I have "runProtocol (initBot >> forever minecraftBotProtocol) h h" and want to handle it disconnecting?
07:49:16 <revenantphx> It will throw a "not enough bytes" error when it can't read anymore it seems, so catching with const return () and using finally could wokr, wondering if there's a cleaner way.
07:49:16 <roconnor> is anyone else finding that http://sequence.complete.org/ is out of date?
07:49:22 <lars9> quicksilver: i see, thanks:)
07:54:08 <identity_> Ah
07:54:13 <identity_> Nasa finds new life, apparently
07:54:23 <tg_> hmm?
07:54:32 <tg_> the conference today? is from Ames
07:54:34 <Botje> they've finally started washing their coffee cups?
07:54:37 <identity_> http://gizmodo.com/5704158/ .. Time to start sending haskell books to space
07:54:45 <tg_> probably not finding life out there, they are probably finding new conditions
07:54:50 <tg_> but we'll have to wait for the news conference
07:55:04 <identity_> Aye
07:55:20 <tg_> Ames isn't the rocket and telescopey-kind of place
07:55:57 <quicksilver> arsenic-based instead of phosphorus-based bacteria at the bottom of a lake, apparently
07:56:11 <roconnor> Yegge says: `` `I believe the root cause of the popularity problem is Haskell's lack of reasonable support for mutually recursive generic container types.' ''
07:56:32 <roconnor> Awesome, that is problem Multiplate is supposed to solve!
07:56:34 <tg_> roconnor: just because it's not funny, doesn't mean it wasn't humor
07:56:37 <JaffaCake1> Mitar: I tried the program in #4813, I get DissolvingException "Control.Etage.Fail.FailNeuron"
07:56:56 <roconnor> Yegge goes on to say `` `If we can create a monadic composition-functor wrapper that is perceived as sufficiently sexy by hardened industry veterans, then I think we will see an uptick in giving a shit, possibly as much as a full extra person.' ''
07:57:05 <roconnor> actualy it is comonadic, but Yegge was close.
07:58:20 <JaffaCake> Mitar: oh wait, it hung once
07:58:36 <Botje> pffrt. he's jus banging the types together until they work ;)
07:59:11 <tg_> roconnor: I think (I hope, if I can be clever enough and do some of the work myself) Haskell will see more adoption when some sort of killer app is created in Haskell, and used by a community who won't moan about the scientific and mathematical nature of it.
07:59:18 <tg_> ie, physicists
08:00:04 <roconnor> :)
08:00:05 <shepheb> tg_: one could say that's what Rails did for Ruby. I certainly wouldn't want that huge-hype-then-it-sucks to happen to Haskell
08:00:32 <roconnor> I'm quite content if no one adopts Haskell.
08:00:47 <Jafet> > fail "Haskell"
08:00:48 <lambdabot>   No instance for (GHC.Show.Show (m a))
08:00:48 <lambdabot>    arising from a use of `M3184732026...
08:00:52 <forall> I prefer ivory tower languages
08:01:18 <roconnor> me too
08:01:36 <tg_> I think even Steve would agree that being the language of choice for advanced computer scientists doesn't mean success of any sort
08:01:48 <aristid> roconnor: there is a comonadic composition-functor wrapper? oO what is that?
08:02:07 <tg_> aristid: he was talking about Multiplate
08:02:13 <aristid> what is multiplate?
08:02:19 <roconnor> @hackage multiplate
08:02:19 <lambdabot> http://hackage.haskell.org/package/multiplate
08:02:58 <roconnor> the comonad is kinda hidden in there.  It is hard to see it.
08:04:50 <Saizan> which is the corresponding functor?
08:05:01 <aristid> roconnor: oh, your package?
08:05:27 <roconnor> yes
08:10:24 <revenantphx> so ah
08:10:30 <revenantphx> sup
08:12:41 <aristid> roconnor: i don't understand Multiplate at all oO
08:14:38 <nostard> i got really bad performance when i changed from UArray to Vector. Both unboxed, mutable in ST. 10s vs 1s. I'm using a boolean array, could that be the problem?
08:14:45 <Botje> it 'only' requires rank 3 polymorphism
08:14:47 <Botje> hooray!
08:14:51 <Botje> I don't even get rank-2 :P
08:15:03 <roconnor> :D
08:15:49 <identity_> Why does cabal keep telling me that there's a new version available, but only keeps downloading 0.8.2?
08:16:02 <identity_> I assume that is the new version
08:16:11 <identity_> but it keeps telling me I need to update
08:16:15 <mornfall> identity_: Could be you aren't running ~/.cabal/bin/cabal?
08:16:36 <identity_> hmm
08:16:43 <tromp_> cabal has annoying habit to install in two places
08:17:04 <identity_> ah, that is indeed the issue, thanks!
08:17:18 <identity_> I'll remove the /usr/bin one and make it a symlink instead
08:17:27 <mornfall> tromp_: Well, it's something you can't defy, unless you forego either system-wide or user-local installs.
08:17:43 <mornfall> tromp_: Both of which are really useful, actually. :)
08:22:58 <identity_> If my project uses cmdargs, does that go into build-depends or other-modules in the .cabal?
08:23:26 <dancor> getTimeZone :: UTCTime -> IO TimeZone
08:23:30 <dancor> how does that work
08:23:44 <FauxFaux> How does that not work?
08:24:16 <dancor> utcToLocalTime :: TimeZone -> UTCTime -> LocalTime
08:25:07 <paolino> identity_: build-depends I guess
08:25:35 <aristid> dancor: it uses the current system time zone to get the TimeZone for a UTCTime
08:26:07 <roconnor> aristid: why does it take a parameter?
08:26:16 <roconnor> why not getTimeZone :: IO TimeZone
08:26:39 <dancor> :t getCurrentTimeZone
08:26:41 <lambdabot> Not in scope: `getCurrentTimeZone'
08:26:47 <aristid> roconnor: because TimeZone does not include DST information
08:26:54 <dancor> getCurrentTimeZone :: IO TimeZone
08:27:20 <dcoutts> identity_: exposed and other modules are the module you write, in your package, not dependencies
08:27:25 <aristid> roconnor: a TimeZone is little more than a UTC offset
08:27:30 <dancor> i guess i don't see when you would ever use getTimeZone
08:27:47 <aristid> roconnor: when you think of a "time zone", however, you probably think of a whole timezone series with DST adjustments
08:27:53 <roconnor> okay
08:28:07 <dancor> and it certainly seems like the time libraries give the short names to the obscure weird functions..
08:28:11 <roconnor> so the "date" is the relevent data used by UTCTime
08:28:15 <aristid> there's a package for that, by yitz
08:28:18 <aristid> timezone-series
08:28:27 <roconnor> though of course since DST changes at 2:00 am the time is a little important too
08:28:44 <aristid> roconnor: yes
08:29:05 <roconnor> I got it now
08:29:17 <roconnor> Hopefully so does dancor
08:30:05 <dancor> what is a scenario where you would use getTimeZone
08:30:54 <aristid> dancor: to implement utcToLocalZonedTime
08:32:11 <aristid> dancor: and because utcToLocalTime takes a TimeZone argument
08:33:15 <roconnor> oh and of course the date taht DST starts depends on whether it is a year that G W Bush is president or not :D
08:34:23 <sipa> and the phase of the moon
08:34:34 <dancor> i think of TimeZone as something you start with.  i still can't imagine a scenario where i have a UTCTime and need to get a TimeZone.
08:35:03 <aristid> dancor: you start with a TimeZone? where do you get it? oO
08:35:28 <aristid> dancor: and you are aware that in all countries with DST, a TimeZone is only valid for half of the year?
08:35:30 <roconnor> dancor: the timezone I'm in varies through the year and through the various presidents.
08:35:31 <dancor> getCurrentTimeZone, user input, stored in my data structure, stored in a db
08:35:48 <roconnor> dancor: remember a TimeZone is the offset from UTC
08:35:52 <aristid> dancor: do you know what DST is?
08:36:17 <roconnor> getCurrentTimeZone changes from day to day on my computer
08:36:21 <Ke> DST is a sin and you should never do it
08:36:24 <dancor> roconnor: i guess i find it very odd that the info to get the offset from UTC is a part of UTCTime
08:36:31 <aristid> Ke: you cannot avoid it.
08:36:32 <roconnor> it isn't
08:36:35 * hackagebot safe-plugins 0.1 - A small wrapper over hs-plugins to allow loading safe plugins  http://hackage.haskell.org/package/safe-plugins-0.1 (IlyaPortnov)
08:36:57 <Ke> aristid: only if you kill everyone else
08:36:58 <roconnor> dancor: getTimeZone tells you want getCurrentTimeZone would/will return if you ran it at the time you pass to getTimeZone
08:37:02 <dancor> it really seems like the cart is in front of the horse somewhere here
08:37:06 <aristid> dancor: you're looking at it the wrong way.
08:37:32 <aristid> dancor: a TimeZone is just an offset from UTC in minutes, along with useless metadata
08:38:15 <aristid> dancor: if your time changes from winter time to summer time at, say, April 2nd 2011 at 2:00 UTC, then the TimeZone needs to be changed at that time (UTCTime)
08:39:07 <roconnor> dancor: look if I run getCurrentTimezone right now I get the result "EST", but if when I ran getCurrentTimezone last June 1st, I got the result "EDT"
08:39:36 <roconnor> so if I want to know right now, what result I would have gotten last June 1st I need to run getTimeZone (read "2010-06-01 00:00:00") which results in EDT
08:40:26 <aristid> i love pineapple juice
08:40:31 <Twey> Ugh, DST
08:40:43 <Twey> Ugh, timezones >.>
08:40:57 <benmachine> ugh, time
08:41:01 <aristid> the facilities for dealing with dst in the time package are very incomplete
08:41:04 <roconnor> DST takes the messiness of timezone to a whole new level
08:41:07 <sipa> let's just switch to a single base-10 time system
08:41:22 <aristid> timezone-series and timezone-olson improves on that
08:41:26 <roconnor> sipa: swatch did that.  They called it internet time right?
08:41:27 <Twey> Base-60 is nicer
08:41:39 <Twey> Swatch's was base-1000
08:41:42 <benmachine> let's count time in base e
08:41:46 <benmachine> just to upset and confuse people
08:41:48 <Twey> And they based it on GMT+1, for goodness knows what reason
08:41:48 <dancor> getMayanStardate
08:41:53 <Twey> Haha
08:41:57 <sipa> roconnor: yes, but i don't mean just the sub-day part
08:42:04 <roconnor> Twey: probably has to do with switzerland
08:42:54 <aristid> Twey: switzerland is in GMT+1
08:43:04 <aristid> at least during winter
08:43:05 <Twey> Bah
08:43:06 <Twey> Bah!
08:43:10 <aristid> :D
08:43:21 <aristid> it's in CET/CEST like most of europe
08:43:50 <dancor> TimeZone should not be called TimeZone
08:43:59 <aristid> dancor: yes, but the damage is done
08:44:22 <dancor> no, the damage is ongoing
08:45:10 <roconnor> <dancor> TimeZone should not be called TimeZone
08:45:13 <roconnor> this is correct
08:46:14 <roconnor> but on the bright side, actualy timezone are almost useless when it comes to figureing out what time it is.
08:46:34 <roconnor> because different regions within timezones go on and off DST at random times.
08:47:35 <roconnor> actually even the wikipedia article is inconsistent
08:47:50 <roconnor> it says ``A time zone is a region on Earth, more or less bounded by lines of longitude, that has a uniform, legally mandated standard time,
08:47:54 <roconnor> but then it goes on to say
08:47:59 <dancor> the tz database should encapsulate that info
08:48:03 <roconnor> Time zone are written as offset from UTC in the format ±[hh]:[mm], ±[hh][mm], or ±[hh].
08:48:06 <dancor> shouldn't it?
08:48:13 <ray> does no one else think time zones are antiquated
08:48:50 <dancor> ray: they are important for consumer activity trends
08:49:07 <sipa> DST is definitely antiquated
08:49:09 <roconnor> dancor: the tz database should encapsulate what info?
08:49:23 <Jafet> Time sucks
08:49:25 <dancor> roconnor: different regions having different DST behaviors
08:49:29 <ray> they're basically a compromise between local solar time and a well-defined planetary time
08:49:52 <ray> dst is a whole other issue, that's clearly wrong but too politically connected
08:50:10 <roconnor> dancor: it does I think.
08:50:22 <dancor> dst and time zones are sort of the same issue if you think about consumerism
08:50:29 <roconnor> dancor: because the tz database is about regions that are not "time zones" :D
08:50:42 <roconnor> they are regions that are smaller than timezones
08:50:54 <roconnor> such as America/Toronto
08:51:00 <ray> are you callin' the big apple small
08:51:08 <benmachine> ray: all clock times are a convenience, I think complexity is sometimes justified
08:51:17 <dancor> i think the tz database is the most sane/formal "time zone" formulation
08:51:29 <roconnor> benmachine: I just wish it wasn't so political.
08:51:35 <ray> it just formalizes the insanity
08:51:44 <benmachine> roconnor: that can be applied to virtually everything :P
08:52:10 <dancor> and i think "TimeZone" in code should refer to tz database
08:52:46 <blubsala> the division of months in a year is even more insane but the people are used to it
08:52:50 <ray> it's unfortunately necessary to display times in legally mandated regional formats
08:52:57 <roconnor> ``Because the earliest and latest time zones are 26 hours apart, any given calendar date exists at some point on the globe for 50 hours.
08:53:32 <ray> there are 50 24 hour days in one earth rotation?
08:54:02 <ray> er 26 i suppose
08:54:14 <ray> i was never the best cubic thinker
08:54:34 <roconnor> ray: it is even more important than that.  Imagine schedualing a meeting for 9:00 every wednesday for a year.  It is important for that meeting to change UTCtime when DST starts and ends.
08:55:06 <roconnor> i.e. you cannot just use UTC internally for everything and localtime for display purposes
08:55:07 <benmachine> just schedule meetings at dawn
08:55:08 <ray> yes input matters as well i should say
08:55:24 <benmachine> works even better inside the arctic circle
08:55:28 <ray> it is also important to accept regional times as input
08:55:44 <byorgey> no meetings all summer, hooray =)
08:55:44 <sproingie> blame the babylonians
08:56:17 <ray> the babylonians were alright
08:56:29 <aristid> <dancor> the tz database should encapsulate that info
08:56:34 <aristid> dancor: timezone-series. it's on hackage.
08:56:44 <aristid> @hackage timezone-series
08:56:44 <lambdabot> http://hackage.haskell.org/package/timezone-series
08:56:45 <sproingie> the 12/24/60 divisions aren't too bad, timezones are freaking insane
08:57:17 <benmachine> people are complicated
08:57:22 <ray> dividing things using numbers with lots of factors is pretty sensible
08:57:27 <benmachine> always be suspicious of simple solutions to complicated problems :P
08:57:38 <sproingie> all of india is on one time zone.  and it's a freaking *half hour* off
08:57:51 <Twey> ray: Indeed they are.  We should all be using consistent base-60 UTC time.  >.>
08:58:43 <ray> we are even very lucky that our solar year is close to 360 solar days
08:58:52 <benmachine> @unmtl WriterT w (StateT s m) a
08:58:52 <lambdabot> s -> m (a, w, s)
08:58:55 <roconnor> apperently when you cross the boarder from china into afghanistan you have to adjust your watch by 3.5 hours
08:59:16 <benmachine> @unmtl StateT s (WriterT w m) a
08:59:16 <lambdabot> s -> m (a, s, w)
08:59:22 <benmachine> ...that's useless
08:59:23 <sproingie> ray: that's no doubt part of why we have 12 months in the first place
08:59:35 <roconnor> ray: wow, that is the same as the number of degrees in a circle
08:59:42 <benmachine> degrees ew
08:59:52 <aristid> !calc 360/60
09:00:03 <aristid> > 360/60
09:00:04 <lambdabot>   6.0
09:00:38 <dancor> :t 360/60
09:00:38 <copumpkin> @where tapl
09:00:39 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
09:00:39 <lambdabot> forall t. (Fractional t) => t
09:00:44 <copumpkin> @where ttfp
09:00:44 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
09:00:48 <ray> we have gps these days, how hard could it be to calculate a longitudinal offset to utc
09:01:08 <Jafet> We should shift the earth into a lower potential well to have perfect 360-day years.
09:01:11 <ray> and imagine if the year were 577 days
09:01:20 <sproingie> national borders don't neatly follow longitudnal lines
09:01:25 <roconnor> Jafet: I think it would be easier to slow the rotation of the earth
09:01:29 <ray> what a NIGHTMARE
09:01:42 <Jafet> roconnor: but then it would no longer be 86400 seconds!
09:01:49 <roconnor> change the definition of a second
09:02:00 <identity_> Anyone use cmdargs regularly? I'm not getting output consistent with the example on ndm's site
09:02:11 <Jafet> I don't think the french will allow that
09:02:26 <roconnor> screw the french WE ARE AMERICANS!
09:02:27 <sproingie> so get rid of the french
09:02:42 <sproingie> they keep trying to move the prime meridian anyway
09:02:48 <ray> you just set your clock by longitudinal offset, correct for axial tilt, and get solar time
09:03:01 <roconnor> pffft
09:03:02 <AmunRa> Hello! I'm working with Arrays for the first time (the pure sort) and find that my code looks quite "low level" .. specifically It's a matrix of point data: Data.Array (Int,Int) PointDef ... Is there a richer API with folds, maps and the like anywhere?
09:03:07 <ray> then you display legal jurisdiction time in tiny print below it
09:03:14 <roconnor> I want sidereal time
09:03:27 <EvanCarroll> AmunRa: sort will handle (Int,Int)
09:03:47 <AmunRa> I don't want to sort
09:04:11 <EvanCarroll> oh, (the pure kind)
09:04:11 <roconnor> http://en.wikipedia.org/wiki/Tz_database
09:04:14 <Cale> sort?
09:04:30 <sproingie> istr being able to map pretty simply over the indices of an array.  not so much directly over the contents tho
09:04:33 <ray> if you're going to be biased in favor of some astronomical object it might as well be the huge glowy one
09:04:52 <Cale> AmunRa: What sort of fold are you looking for? Usually if you're just going to fold over the stuff, you might as well put it in a list.
09:04:56 <sproingie> oh hm there's another one that iterates over the contents too, i just needed the indices
09:05:02 <AmunRa> I want to fold one row at a time, for example... 
09:05:26 <sproingie> "row" is something that Data.Array doesn't really have a concept of built-in
09:05:35 <sproingie> so you'll probably have to invent something there
09:05:38 <Cale> Okay, then I would extract the list of entries of the row and fold over that :)
09:05:43 <AmunRa> well.. ok... fold over a range :-) that's good enough
09:06:01 <sproingie> AmunRa: you should be able to take the range as a list and fold over that
09:06:23 <sproingie> AmunRa: if it's lazy then it won't result in any extra copying
09:06:46 <sproingie> well unless you keep the list around
09:07:36 <Jafet> If it's lazy and gets fused
09:07:38 <sproingie> there's probably a more direct path but you'd have to write it 
09:08:59 <AmunRa> hrm.. ok.. I mean.. I know how to write the code.. it's just that what's coming out doesn't seem to reflect much the intention of the code.. :-) Eh well.. some other day
09:09:03 <Cale> I usually think of an array as being a way to memoise a function on a finite domain.
09:09:28 <Cale> In that regard, you might also consider using Data.MemoCombinators for the same jobs :)
09:09:38 <AmunRa> Cale: Maybe you're right.. i.e. I'm using the wrong data structure.. I
09:09:54 <sproingie> true, but Data.Array isn't quite so abstract
09:09:55 <AmunRa> am after something like a matrix that I can manipulte easily
09:10:25 <sproingie> it's more like trading away abstraction for a more compact representation.  well at least the UArrays i use
09:10:28 <AmunRa> or a grid, more precisely (don't really care about the mathematical aspects
09:10:29 <Eduard_Munteanu> Pretty naive C version of the Haskell code: http://paste.pocoo.org/show/299046/
09:10:35 <Cale> If you want matrix algebra, you might look at libraries like hmatrix
09:10:45 <Eduard_Munteanu> Runs in 1m02s as opposed to Haskell 1m40s
09:11:18 <dskippy> Does anyone have a second to run my code and tell me why I can't get a simple Glade UI to work? This functions and creates a window. And doesn't complain about mistyped menu-item names. But the menu-item new should print out "test" and it does not. I can't figure out why.   http://hpaste.org/42022/mainhs   http://hpaste.org/42023/uiglade
09:11:21 <Eduard_Munteanu> ByteString should be better than my fgetc stuff and I think the allocation pattern I'm using isn't optimized at all.
09:11:39 <Eduard_Munteanu> And it's just gcc -O2.
09:12:05 <Eduard_Munteanu> Here's the Haskell code for those who didn't see it: http://paste.pocoo.org/show/299002/
09:12:12 <sproingie> -fspeed-holes
09:12:21 <Eduard_Munteanu> The input file is 512MiB, generated from /dev/urandom.
09:12:59 <Eduard_Munteanu> As you can see, the C code is written much like Haskell lists would behave I think, or worse.
09:13:00 <Cale> Eduard_Munteanu: Why the separate definition of cons if you're going to use it infix anyway? :)
09:13:14 <Eduard_Munteanu> Cale: profiling. So I don't add ugly SCC pragmas.
09:13:18 <Eduard_Munteanu> It shouldn't hurt.
09:13:52 <Cale> Also, there are tabs in your file
09:14:16 <Eduard_Munteanu> Yes, I know, bad habits. I use 4-space softtabs for hacking on Qemu but didn't bother on doing that on Haskell code :)
09:14:43 <Eduard_Munteanu> But I do use them correctly.
09:15:41 <Cale> um, hmm... I wonder if this B.readFile followed immediately by B.unpack is really the right thing to do. How does it compare with just doing a simple readFile?
09:15:59 <Eduard_Munteanu> Hm, good point, lemme try...
09:16:34 <Eduard_Munteanu> (though profiling says the overhead is in lookupCode)
09:16:56 <Eduard_Munteanu> Cale: erm, I can't just readFile, that returns a ByteString.
09:16:56 <Cale> What is this tema2 file?
09:17:15 <Cale> I mean the one in the Prelude
09:17:21 <Cale> Not the ByteString one
09:17:29 <Eduard_Munteanu> Cale: ah, it's my test file (nvm the name), 512MiB of /dev/urandom
09:17:49 <Eduard_Munteanu> I see no other.
09:18:20 <Cale> :t readFile
09:18:21 <lambdabot> FilePath -> IO String
09:18:45 <Eduard_Munteanu> Cale: I'm using readFile from Data.ByteString.Lazy
09:18:49 <Cale> I know
09:19:05 <Kaidelong> does anyone know a heap data structure that is fixed size, has elements overwrite "lesser" elements if the heap is full, and can do batch updates in place?
09:19:06 <Cale> But you're not really using lazy bytestrings to any effect, because you're immediately unpacking
09:19:09 <Eduard_Munteanu> Oh, I tried using the regular IO it's not much better.
09:19:11 <Kaidelong> or do I need to write it?
09:19:21 <Eduard_Munteanu> Lemme quantify it...
09:20:05 <Cale> Kaidelong: I don't understand what the last bit means
09:21:17 <Cale> Kaidelong: Maybe you could use a Data.Map?
09:21:18 <Kaidelong> Cale: I give it 6 elements to perhaps add to it if they are "better" than elements already on the heap. It thaws the array representation of the heap and updates it in place, then freezes it again
09:21:31 <Cale> oh, err
09:21:36 <Cale> Which will make a copy, of course.
09:21:52 <Kaidelong> with what I'm planning mutation will probably be more efficient
09:22:15 <Cale> (Freezing a mutable array makes a copy of it)
09:22:20 <Kaidelong> I know
09:22:34 <Eduard_Munteanu> Cale: 1m22.179s
09:22:43 <Eduard_Munteanu> Cale: it seems better.
09:22:51 <Cale> Eduard_Munteanu: okay
09:22:58 <Eduard_Munteanu> But I still think it's slow :)
09:23:21 <Eduard_Munteanu> Mind the C implementation closely mimics Haskell.
09:23:34 <Kaidelong> hmm
09:23:51 <Kaidelong> well I guess for the time being I'll keep it simple and do it naively with a set
09:24:00 <Eduard_Munteanu> Mainly the fgetc() thing is not very smart.
09:24:38 <Kaidelong> I was just hoping someone already needed something like that and might have put it on hackage
09:24:46 <Eduard_Munteanu> Cale: my problem with lazy ByteString ops is I can't build intermediate structures. Like the bytestring map maps Word8 to Word8, I can't really do anything in between.
09:25:01 <Cale> Eduard_Munteanu: It looks like the values in the tree are different.
09:25:15 <Cale> (does that matter?)
09:25:31 <Eduard_Munteanu> Not really, the output is garbage.
09:26:07 * Eduard_Munteanu tests again with updated values to be extra sure.
09:27:43 <Cale> wait, what is the accumulating parameter for?
09:27:52 <Eduard_Munteanu> 1m7.868s
09:28:03 <Cale> Also, you're putting constructors in there, there's no reason to force the list.
09:28:05 <Eduard_Munteanu> Cale: I thought it would improve performance.
09:28:23 <Eduard_Munteanu> It didn't change anything significantly though.
09:28:26 <Cale> The seq is useless, apart from unravelling the cons
09:28:37 <Eduard_Munteanu> That too.
09:28:45 <Cale> That is, forcing  cons -> (:)
09:28:54 <Eduard_Munteanu> Oh.
09:29:19 <Eduard_Munteanu> I thought at least that would be CSEd then evaluated.
09:29:36 <Cale> It'll probably be inlined
09:29:52 <Cale> But if you care about performance, you probably shouldn't rely on the compiler in that way :)
09:30:28 <Cale> So, is it important that the lists be in reverse order like that? No, because you're summing the results
09:30:34 <Eduard_Munteanu> Cale: I don't actually care _that_ much about performance. But when I reimplemented some stuff in Haskell I noticed it was about 8 times slower, I can't take that :)
09:30:38 <Cale> So, why not do it the straightforward way?
09:30:41 <Eduard_Munteanu> This is a testcase.
09:31:01 <Eduard_Munteanu> Ok, I'll retest with a simplified version.
09:31:07 <Cale> (remove the accumulating parameter, and produce list cells immediately)
09:31:26 <Cale> That'll result in less memory usage as well
09:31:52 <Cale> Because the results get pumped into the foldl' (+) 0 immediately to be summed
09:33:28 <Eduard_Munteanu> I thought it would help concatMap.
09:34:22 <Cale> Producing elements of the list as early as possible is usually better than accumulating them in a parameter until you've finished recursing.
09:35:04 <Cale> (remember that evaluation is outermost-first)
09:35:14 <basvandijk> Does anybody know why the mtl package in the ghc repository is still at version 1.1.1.1 while the one on hackage is at 2.0.1.0?
09:35:53 <Eduard_Munteanu> 1m29.729s
09:35:59 <Eduard_Munteanu> http://paste.pocoo.org/show/299065
09:36:46 <Eduard_Munteanu> Cale: also the recursion is very short.
09:37:47 <Cale> basvandijk: new release?
09:40:38 <Eduard_Munteanu> Cale: lookupCode and all that stuff looks like a major bottleneck: http://paste.pocoo.org/show/299069/   0m20.364s
09:41:08 <Eduard_Munteanu> Cale: I only changed main, look there
09:41:28 <Cale> lookupCode?
09:41:43 <Cale> fromIntegral is expensive
09:41:58 <Eduard_Munteanu> um, lookupTree, sorry.
09:42:34 <Eduard_Munteanu> Cale: I doubt fromIntegral is the culprit, I remember profiling showing lookupTree ate most of the CPU cycles.
09:42:39 <Eduard_Munteanu> And time.
09:43:10 <benmachine> Eduard_Munteanu: it's best to be sure, eg?
09:43:12 <benmachine> *eh
09:43:44 <Eduard_Munteanu> Ok, lemme profile and paste.
09:45:52 <Eduard_Munteanu> It also showed consing as a big time consumer, but I won't SCC that now.
09:47:48 <Cale> Well, I tend not to think of (:) as consuming time, but it does count as part of the allocation of whatever produces it, which counts toward that thing's time.
09:49:13 <Cale> All in all, I don't see these results as being significantly different from the C code's timings, considering that the C code is using significantly different data structures.
09:49:41 <Cale> (Despite appearances)
09:49:45 <Eduard_Munteanu> Cale: it isn't really, I wouldn't have used recursion in production code.
09:50:51 <Cale> Remember that a cons cell x : xs in GHC consists of two pointers to code (along with an integer tag marking it as a cons and not a [])
09:51:09 <Eduard_Munteanu> Cale: I wouldn't have complained but when tried to actually write a Haskell program similar to C code I already had, it ran 8 times slower.
09:51:22 <Eduard_Munteanu> Actually similar to a language-agnostic algorithm.
09:51:44 <Eduard_Munteanu> Hm yeah.
09:51:49 <Cale> Well, that's not great, but not altogether unexpected.
09:51:57 <Cale> Where is that code?
09:52:09 * Eduard_Munteanu looks it up...
09:52:17 <Cale> 8x difference is easier to attack than 30% difference.
09:52:32 <yrlnry> Aint' that the truth.
09:53:29 <Eduard_Munteanu> Cale: http://paste.pocoo.org/show/299076/
09:53:31 <Cale> Generally direct translations of imperative algorithms don't fare well without some transformation
09:53:45 <Eduard_Munteanu> Cale: I'm clueless. I tried everything, except fundamentally changing the algorithm.
09:53:53 <tg_> Eduard_Munteanu: doh!
09:54:55 <Eduard_Munteanu> tg_: the same algorithm written in C runs in 0.3s vs 2.4s for Haskell. And I really took care to cater for language differences.
09:55:41 <Jafet> Be patient; when we all run out of ideas we will then break out the dons
09:55:47 <Eduard_Munteanu> Cale: it's Shannon-Fano compression. I build the tree, then for each Word8 in the input I lookup a coding that consists of a variable number of bits. Then 'pack' packs them into bytes.
09:55:52 <Cale> What does succA do?
09:56:43 <Eduard_Munteanu> Cale: A stands for alphabet. succA takes the alphabet and splits it so that the left slice has the sum of counts close to the right slice.
09:57:01 <Zao> I keep associating 'A' to applicative.
09:57:05 <Eduard_Munteanu> Cale: it does that by going through that Seq from both ends, adding elements.
09:57:14 <Cale> Eduard_Munteanu: hmm...
09:57:31 <Cale> Eduard_Munteanu: There's probably a better way to approach that.
09:57:46 <Eduard_Munteanu> I tried my best to keep close to the original algorithm description, while also making sure it doesn't impact performance because of the paradigm difference.
09:58:05 * hackagebot regexp-tries 0.1.0 - Regular Expressions on Tries.  http://hackage.haskell.org/package/regexp-tries-0.1.0 (AndreasBaldeau)
09:58:18 <Eduard_Munteanu> Nevertheless, tree building isn't the bottleneck.
09:59:14 * Eduard_Munteanu was trying to translate a C/Matlab assignment he had into Haskell code.
09:59:28 <tg_> ut oh, he used the P word
10:00:50 <Eduard_Munteanu> (pack contains some cruft that could be removed, it was optimized)
10:02:32 <Eduard_Munteanu> Cale: yes, people suggested I could use a lookup table instead of the tree. I also think that would be a major improvement, but I'm not sure I should go that way just to get performance.
10:02:39 <Eduard_Munteanu> Haskell should be good with trees.
10:03:35 <Jafet> Does your C program use the same tree structure?
10:04:33 <Eduard_Munteanu> Jafet: yes, more or less. Actually it's dumber. It does a linear search of an array stored in the node, up to the split point. If the byte is there, go left, otherwise right.
10:04:38 <Jafet> (It does)
10:05:22 <Eduard_Munteanu> Actually it's not exactly a copied array but a pointer to an array along with indices.
10:05:41 <Eduard_Munteanu> http://paste.pocoo.org/show/299081/
10:05:44 <Eduard_Munteanu> The C code ^
10:05:44 <Jafet> And the haskell version uses an IntSet
10:05:53 <Eduard_Munteanu> Yeah, which should be faster anyway.
10:06:06 <ddilinger> playing arround in ghci, i have x :: IO (Either String Text.Feed.Types.Feed), i can do liftIO x from ghci, but not let y = liftIO x, why not?
10:06:09 <Jafet> Are you sure linear search is being "dumber" than hierarchical search?
10:06:40 <ddilinger> the specific error is Ambiguous type variable 'm' in constraint MonadIO m
10:07:27 <Eduard_Munteanu> Jafet: IntSet looks mighty fast to me. I think it's a radix search.
10:08:16 <magicman> ddilinger: Short explanation: monomorphism restriction.
10:08:27 <Eduard_Munteanu> Anyway, the C code does some stuff which are really hackish, like reversing bits in bytes before writing them to disk and such.
10:08:49 <Jafet> I'd use a 256-bit bitset
10:08:51 <Eduard_Munteanu> I wrote it in a morning and didn't spend much time optimizing it.
10:09:17 <magicman> ddilinger: Long explanation: ghci doesn't like it if you define polymorphic constants. But you could do something like:
10:09:31 <magicman> ddilinger: let y = x :: MonadIO m => m (Either String Text.Feed.Types.Feed)
10:09:39 <Eduard_Munteanu> Also profiling showed that IntSet lookup was minor in comparison with tree traversal.
10:10:21 <magicman> ddilinger: Or start ghci with the -XNoMonomorphismRestriction flag.
10:11:20 <ddilinger> magicman: hmm, ok.  Basically its just that that IO goes out to the internet every time i evaluate it, using the liftIO will store the results yes?  also using the full type signature at the end still says "Ambiguous type variable 'm' in the constraint: `MonadIO m'
10:11:57 <Cale> ddilinger: IO actions do nothing when they're evaluated. They only cause things to happen when they're executed, which is separate.
10:12:08 <magicman> (Oh, hey, I see I left out a liftIO there, sorry >_>)
10:12:16 <copumpkin> > putStrLn "abc" `seq` ()
10:12:17 <lambdabot>   ()
10:12:23 <Cale> liftIO turns an IO action into another sort of action in a different monad.
10:12:36 <joe6> @hoogle squared
10:12:37 <lambdabot> No results found
10:12:40 <ddilinger> hmm, ok
10:12:50 <magicman> ddilinger: That's... okay. There was something with using explicit type signatures in ghci to stop the monomorphism restriction from complaining. I may be completely wrong about that in this case, though :-/
10:13:25 <joe6> @hayoo squared
10:13:25 <lambdabot> Unknown command, try @list
10:13:30 <Jafet> > unsafePerformIO (putStr ":-)") `seq` ()
10:13:31 <lambdabot>   Not in scope: `unsafePerformIO'
10:14:56 <joe6> isn't there a standard squared function?
10:15:12 <Cale> Eduard_Munteanu: btw, the fromIntegral in lookupCode is more expensive than any of the other SCCs there (It takes 5% of your program's time, and 10% of its allocation), and the O.member lookup takes 17.5% of your program's time
10:15:28 <Cale> joe6: (^2)?
10:15:37 <joe6> oh, ok. thanks.
10:15:38 <augur> Gracenotes: whats this now
10:15:39 <Cale> > 5^2
10:15:40 <lambdabot>   25
10:15:45 <Cale> > (^2) 5
10:15:46 <lambdabot>   25
10:15:52 <Gracenotes> wait how many hours ago was what
10:16:05 <danr> > join (*) 5
10:16:06 <lambdabot>   25
10:16:07 <dskippy> Can anyone think of a way in which creating a Glade file, loading it with gtk2hs, naming a menuitem, and then calling 'onActivateItem menuitem (putStrLn "Test")' would cause the program to compile file, run, display the window, not complain, but not do anything when the menu item is clicked?
10:16:10 <augur> Gracenotes: what is this reader-like thing you linked me to
10:16:49 <Cale> dskippy: Oh right, I was going to try your program :)
10:16:50 <Gracenotes> oh. you asked something about function and reader monads corresponding, the Reader s (Reader t a)
10:16:57 <augur> yes..
10:17:04 <dskippy> Cale: want the links again?
10:17:16 <augur> Gracenotes: something about environment-passing
10:18:01 <Eduard_Munteanu> Cale: I'm really unsure how I could improve that. If a linear search is better than that... *sigh*
10:18:04 <Gracenotes> a direct transformation. it's actually a bit tedious.
10:18:05 <Cale> dskippy: I've got it
10:18:15 <Eduard_Munteanu> I have to go, I'll be back a bit later.
10:18:45 <dskippy> Cale: Thanks.
10:18:46 <Eduard_Munteanu> Thanks for your help guys.
10:19:03 <Cale> Eduard_Munteanu: dons would probably know what to do better than any of us :)
10:19:19 <Cale> Eduard_Munteanu: There are things I can think of trying, but they're a little extensive
10:19:22 <Eduard_Munteanu> Heh. I'll try asking again when he's around.
10:19:41 <Eduard_Munteanu> o/
10:20:32 <augur> Gracenotes: i dont understand
10:20:43 <roconnor> Eduard_Munteanu: Grover's algrothm can do a search in sub-linear time.
10:21:04 <sproingie> what about Big Bird's algorithm?
10:21:19 <tg_> cause I live in a f****** trash can!
10:21:19 <roconnor> It was invented by Lov Grover in 1996.
10:22:12 <sproingie> oh it's one of those mind bendy quantum things
10:22:15 <Gracenotes> augur: errr http://hpaste.org/42016/reader_and_environments ... something I wrote once. it seemed relevant. tis all.
10:22:36 <augur> Gracenotes: youll have to explain it
10:22:45 <augur> haskell code is a poor explanation device
10:23:40 <Gracenotes> well, at the very least, the top and bottom (eval and feval) are the same
10:33:57 <Evious> The wiki migration seems to have broken image links - are old images still available on some other address?
10:37:38 <Gracenotes> ohmygodnomyteaisgettingcold
10:41:27 <revenantphx> Hm.
10:41:59 <revenantphx> In one packet I'm receiving a packet... I need to somehow "store" it... I guess an STRef at the top level would work.
10:43:09 <dskippy> Hey Cale, did you run that? Sorry I don't mean to be a pest. :) You're just the only I feel is likely to be able to help me on this.
10:43:22 <dskippy> *only one
10:43:51 <romildo> My application needs to download an html document whose charset is ISO-8859-1. I am using "Network.HTTP.simpleHTTP" to download it. How do I get it as an UTF8 string?
10:45:25 <c_wraith> romildo, UTF8 String is a bit vague in haskell.
10:45:54 <romildo> c_wraith, as a String.
10:45:56 <c_wraith> Strings in haskell are unicode.  UTF8 is an encoding of unicode to bytes
10:46:20 <romildo> c_wraith, as Unicode, then.
10:46:35 <romildo> c_wraith, my mistake.
10:46:46 <Cobra> @src foldl
10:46:46 <lambdabot> foldl f z []     = z
10:46:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:47:02 <c_wraith> So, what you really want is the document you are fetching to be decoded into unicode as specified by the encoding in the content-type?
10:47:39 <monochrom> simpleHTTP not recommended for this
10:47:46 <romildo> c_wraith, yes.
10:47:56 <c_wraith> yeah, simpleHTTP probably won't do what you want
10:48:29 <c_wraith> Well, I guess you can do it manually using simpleHTTP, though
10:48:48 <c_wraith> just use the ByteString result type
10:48:57 <c_wraith> and do the conversion yourself, using the encodings package
10:49:34 <revenantphx> I'm running into a mystery issue with binary-protocol I think.
10:49:40 <revenantphx> It's not sending something... I think?
10:49:42 <romildo> I am using simpleHTTP because sometimes the pages downloaded are in gzip format, and they are truncated if not downloaded with simpleHTTP  with HdrAcceptEncoding "gzip"
10:50:22 <c_wraith> romildo, well, simpleHTTP is polymorphic in the result type.
10:51:02 <c_wraith> If you use one of the ByteString result types, it will give you back the bytes returned, without attempting to convert them to a string
10:51:20 <c_wraith> Then you can do the string conversion manually, based on the encoding you either detect, or already know the page is
10:51:53 <c_wraith> @hackage encodings
10:51:53 <lambdabot> http://hackage.haskell.org/package/encodings
10:52:02 <c_wraith> oops
10:52:05 <c_wraith> @hackage encoding
10:52:05 <lambdabot> http://hackage.haskell.org/package/encoding
10:53:01 <romildo> c_wraith, is there any other library that would download and automatically encode the page for me?
10:53:39 <monochrom> I don't know of it.
10:53:41 <monochrom> err
10:53:43 <c_wraith> technically, that direction is decoding. :)   And I don't know what the state of the art in download packages is
10:53:44 <monochrom> I don't know of one.
10:54:10 <c_wraith> unicode -> bytes is encoding, bytes -> unicode is decoding :)
10:54:31 <revenantphx> hey, I've got a broken thing here
10:54:32 <revenantphx> http://hpaste.org/42024/broken_bot
10:54:55 <revenantphx> So, I start the connection by sending a handhshake.
10:55:19 <revenantphx> In the minecraftBotProtocol function,  I receive one packet (handshake back) correctly.
10:55:24 <revenantphx> Then the next time I hangs at
10:55:25 <revenantphx> Got: 
10:55:31 <revenantphx> and it's not receiving the next one.
10:55:48 <blackh> revenantphx: What version of GHC are you using?
10:56:00 <revenantphx> 6.12.3
10:56:11 <revenantphx> "Glasgow Haskell Compiler, Version 6.12.3, for Haskell 98, stage 2 booted by GHC version 6.12.2"
10:56:13 <merijn> Good evening, my lambda loving friends.
10:56:27 <blackh> (I have my doubts about 7.0.1, as I've had some trouble, but 6.12.3 has always worked for me with networking.)
10:56:32 <Cale> http://www.theonion.com/articles/julian-assange-fired-from-it-job-at-pentagon,18572/ -- haha
10:57:41 <blackh> merijn: Morning!
10:57:43 <djl> Cale: *laugh*
10:57:58 <revenantphx> But here's the weird bit.
10:58:04 <revenantphx> I don't receive the packet but if I wait a while...
10:58:10 <revenantphx> the server sends a kick saying I took too long.
10:58:15 <revenantphx> So I'm tempted to think it's not sending it
10:59:25 <blackh> I'm not familiar with BinaryProtocol, but I have evidence of handles not working with sockets properly on Linux.
10:59:37 <blackh> (Reporting bugs is something I'm trying to find the time for.)
11:00:18 <blackh> Using sockets directly definitely works on 6.12.3.
11:00:32 * hackagebot improve 0.1.6 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.1.6 (TomHawkins)
11:00:52 <blackh> revenantphx: I'll find the details.
11:01:05 <revenantphx> I don't think its a haskell issue.
11:01:10 <revenantphx> I'm on OS X
11:01:14 <revenantphx> I'm receiving a packet afterwards.
11:01:17 <revenantphx> (the kcik)
11:01:22 <merijn> Anyone here have some experience with Erlang? I've decided to try attempt 15 billion at writing my perfect game and I'm sorta torn between attempting it in Haskell to learn it better and doing it Erlang (since writing a game with state/impurity seems easier and lots of concurrent processes and hot swappable code also seem intriguing from a game perspective)...any input?
11:01:26 <revenantphx> so I must be authenticating wrong.
11:03:04 <dumael> merijn: I have a bit.
11:04:50 <blackh> revenantphx: Anyway, here are the details: on ghc-6.10.4 and ghc-6.12.2 with network-2.2.1.7, hGetContents was
11:05:11 <revenantphx> It's not haskell issue I think. I sniffed packets and the one i want jsut isnt there.
11:05:14 <blackh> acting in such a way that when a block was received over a TCP connection, it was queued up and not delivered immediately.
11:05:29 <merijn> dumael: What's your experience been like? Its syntax looks a lot worse then haskell's, but then again some of the other things look more interesting/easy to do then in Haskell
11:05:41 <revenantphx> I get a packet after the one I want ( a kick) though
11:05:47 <blackh> Buffering settings didn't make any difference.
11:06:00 <blackh> revenantphx: That's probably not your problem, but I thought I should mention it.
11:06:37 <revenantphx> hm
11:07:01 <dumael> merijn: the syntax is a bit wonky at first but you'll get the hang of it after a while.
11:07:13 <revenantphx> I can verify the packet is getting out (packet sniffer says so)
11:07:18 <revenantphx> and that the response is definitely not coming.
11:07:59 <Johnny_> hello guys. im just starting to learn haskell but having harsh problems :( im trying to write a function that checks whether a char is a number between certain limits, but so far, it wont work.. what ive got is this:
11:08:08 <Johnny_>   isDigit     :: Char -> Bool   isDigit c                    = ('0' <= c) && (c <= '9')
11:08:18 <Johnny_> so this checks whether the digit is between 0 and 9. so far so good
11:08:26 <mauke> @hoogle isDigit
11:08:26 <lambdabot> Data.Char isDigit :: Char -> Bool
11:08:30 <Johnny_> but i want to check numbers up to thousand
11:08:40 <Johnny_> and he wont let me check, e.g. 13 or 1234
11:08:46 <neckbeard1> yo is it me or the language specification pdf down at http://haskell.org/definition/haskell2010.pdf
11:08:57 <dumael> merijn: aside form that be careful about types. there's no static type system to save you from wholly studpidly embarassing errors.
11:09:01 <Twey> Johnny_: '12' is not a char
11:09:10 <Twey> It's a string of two chars, "12"
11:09:15 <revenantphx> let isDigit = flip elem ['0'..'9'] in isDigit 'd'
11:09:21 <revenantphx> > let isDigit = flip elem ['0'..'9'] in isDigit 'd'
11:09:21 <lambdabot>   False
11:09:25 <revenantphx> failed
11:09:27 <mauke> > isDigit 'd'
11:09:28 <lambdabot>   False
11:09:28 <revenantphx> let isDigit = flip elem ['0'..'9'] in isDigit '4'
11:09:31 <revenantphx> erp.
11:09:34 <Johnny_> isDigit 50
11:09:35 <Twey> revenantphx: Slower
11:09:36 <revenantphx> let isDigit = flip elem ['0'..'9'] in isDigit '0'
11:09:37 <applicative> > chr 12
11:09:38 <lambdabot>   '\f'
11:09:45 <revenantphx> That's not right ...
11:09:46 <mauke> Johnny_: 50 is a number, not a string
11:10:26 <Johnny_> what do i have to write in the signature then to make him check numbers? i tried num but he tells me, he doesnt know that constructor
11:10:30 <dumael> merijn: oh, that and strings. There aren't any. they're just list of numbers which can bite hard when you're experimenting with the REPL.
11:10:35 <blackh> dumael: In "Erlang the Movie" they made a mistake that the Haskell type checker would have caught, and then they hot-swap the fix in (which you can't do in Haskell).  It sounds terrible programming without the static type system.
11:10:39 <mauke> Johnny_: in what signature?
11:10:50 <Twey> @ let (n >< m) x = x > n && x < m
11:10:51 <Johnny_>   isDigit     :: Char -> Bool
11:10:53 <Twey> @let (n >< m) x = x > n && x < m
11:10:55 <lambdabot>  Defined.
11:11:04 <mauke> Johnny_: uh, leave that function alone
11:11:10 <Twey> isDigit = '0' >< '9'
11:11:18 <mauke> Johnny_: if you want to check that a number is <= 1000, write another function
11:11:21 <Twey> Hm, need an equality version
11:11:31 <Twey> @let (n >=< m) x = x >= n && x =< m
11:11:31 <lambdabot>  <local>:9:26: Not in scope: `=<'
11:11:33 <merijn> blackh: I think Erlang does support type annotations which can be statically checked
11:11:35 <Twey> isDigit = '0' >=< '9'
11:11:38 <dumael> blackh: Once upon a time I performed some modifications to the erlang compiler. Let's just say that compilers written in dynamically typed languages can be painful.
11:11:46 <Twey> @let (n >=< m) x = x >= n && x <= m
11:11:47 <lambdabot>  Defined.
11:12:01 <Twey> > '0' >=< '9' $ '5'
11:12:02 <lambdabot>   True
11:13:02 <Johnny_> isnt this "  isDigit     :: Char -> Bool" called the signature of the function?
11:13:11 <dumael> merijn: also, be prepared to experience frequent problems with things like 'x = 45'. variables in erlang have to start with uppercase letters.
11:13:25 <Twey> Johnny_: Yes
11:13:30 <Johnny_> they trouble me most
11:13:32 <c_wraith> dumael, that one made me feel so dumb. :)
11:13:34 <merijn> Johnny_: In Haskell you'd more likely to call it the type of the function, but it boils down to the same, yes
11:13:47 <blackh> Thanks, merijn & dumael - that's stuff I've wanted to know a bit more about.
11:13:49 <Twey> Johnny_: But your isDigit function is fine.  "500" is *not* a digit.
11:14:03 <Johnny_> i still havent really gotten the catch of how to write signatures yet.. 
11:14:12 <Johnny_> @twey well the problem is that i want to check numbers up to thousands
11:14:12 <lambdabot> Unknown command, try @list
11:14:23 <Twey> Johnny_: So you don't want to check whether it's a digit
11:14:27 <merijn> Johnny_: The main revelation (for me) was the idea that "functions only take one argument"
11:14:40 <Johnny_> what i want to do is check whether a given date is actually a date
11:14:48 <Johnny_> so there is dd.mm.yyyy
11:14:55 <Johnny_> and e.g. 31 of februrary shouldnt be possible
11:15:02 <dumael> merijn: another thing that may not be mentioned in the docs: do *not* use list_to_atom. If you dynamically generate atoms, your app *will* crash eventually.
11:15:13 <merijn> Johnny_: So you want "isDate :: String -> Bool"?
11:15:14 <Johnny_> but the first check is supposed to be, whether the entered ?strings? are actually  numbers
11:15:40 <Johnny_> maybe? as ive said, i really got problems with those signatures. can i really just use string -> bool although im entering a tuple of numbers?
11:16:02 <blackh> Johnny_: all isDigit str  Are we doing your assignment for you?
11:16:07 <merijn> Johnny_: Depends, *are* you entering tuples of numbers or a String containing numbers?
11:16:29 <Johnny_> no, blackh, since i only want help with the very basic part
11:16:40 <Johnny_> well what i want to enter is something like this
11:16:44 <blackh> Johnny_: It's all right. I'm only teasing.
11:16:51 <Johnny_> 31.2.1945
11:17:07 <Johnny_> or, if necessary, '31.2.1945'
11:17:08 <merijn> And then get back whether its a date?
11:17:18 <Johnny_> well there are different possible reactions
11:17:30 <Johnny_> but one would be that it could be a date
11:17:30 <Twey> I think regexen would be appropriate here
11:17:32 <applicative> so first you need a function that splits the strings into substrings on '." right?
11:17:33 <merijn> Johnny_: You could use a tuple of integers, like so: (31, 2, 1945)
11:17:42 <Johnny_> later on, i want him to check whether its possible (like i said, 31.2. is impossible etc.)
11:18:18 <Johnny_> when i wrote my isdigit function, i often tried to tell him to do Int -> Bool but he never accepted that
11:18:34 <blackh> Johnny_: Standard Haskell strings don't have very many fancy support functions.  If you want to parse it, you'll have to write a function to split it up at the dots.  Data.Text (which is a different string type) can help with this (from the 'text' package).
11:18:34 <Johnny_> then i thought i had to write it like (Int, Int, Int) -> Bool
11:18:48 <Twey> Johnny_: Looks good
11:18:52 <merijn> Johnny_: Could you pastebin your latest attempt somewhere?
11:19:12 <Johnny_> its actually that isDigit stuff i posted.  (    isDigit     :: String -> Bool   isDigit c                    = ('0' <= c) && (c <= '9'))
11:19:16 <merijn> "(Int, Int, Int) -> Bool" lookis good to me
11:19:22 <Johnny_> ill try again
11:19:28 <merijn> Johnny_: Ah, of course
11:19:44 <merijn> So don't compare to characters?
11:19:45 <blackh> Johnny_: You probably want one parse function 'parse :: String -> Maybe (Int, Int, Int)' and one 'validDate :: (Int, Int, Int) -> Bool' then compose them together with a case statement.
11:19:48 <Johnny_> *** Expression     : c <= '9' *** Term           : c *** Type           : (Int,Int,Int) *** Does not match : Char
11:20:13 <merijn> Johnny_: isDigit expect a string, (Int, Int, Int) is not a string
11:21:06 <Johnny_> to be honest, i don't even know what a parse function is
11:21:26 <Johnny_> googling it atm
11:21:35 <blackh> Johnny_: I'm just suggesting you write a function to take the string and turn it into numbers, and call it 'parse'.
11:21:46 <Johnny_> ah, hm
11:21:48 <merijn> isPseudoDate :: (Int, Int, Int) -> Bool
11:21:49 <merijn> isPseudoDate (day, month, year) = day > 0 && day <= 31 && month > 0 && month <= 12
11:21:56 <applicative> > span isDigit "12.30.1935"
11:21:57 <lambdabot>   ("12",".30.1935")
11:22:35 <merijn> @let isPseudoDate (day, month, year) = day > 0 && day <= 31 && month > 0 && month <= 12
11:22:37 <lambdabot>  Defined.
11:22:50 <merijn> > isPseudoDate (10, 5, 1986)
11:22:52 <lambdabot>   True
11:22:58 <Johnny_> ohhhh
11:23:15 <Johnny_> why did that work now, hehe
11:23:20 <merijn> Johnny_: Obviously that example is broken, but I hope it helps?
11:23:32 <Johnny_> yes it does, im trying to figure out what you did differently from me
11:23:43 <blackh> Johnny_: Haskell compilers are very fussy. :)
11:23:47 <merijn> Johnny_: 0 is a number, '0' is a character (letter)
11:24:07 <merijn> Characters can be compared, but they are not numbers
11:24:10 <Johnny_> my whole code broke because i used ' ' ?
11:24:13 <merijn> > 0 == '0'
11:24:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:24:15 <lambdabot>    arising from the literal `0...
11:24:21 <merijn> > 0 == 0
11:24:22 <lambdabot>   True
11:24:23 <Johnny_> argh
11:24:42 <Johnny_> ok, just checking whether it works in my interpreter too
11:24:52 <theorbtwo> Johnny_: One of the basic tennants of Haskell is that bad code should fail at compile-time, not runtime.
11:25:03 <merijn> Johnny_: The compiler was trying to tell you "You're comparing a number and a character and that makes no sense!". Except you don't know enough haskell yet to understand its warning :)
11:25:15 <Johnny_> exactly.. ;)
11:25:17 <theorbtwo> Another is that if it won't always work, then it's bad code.
11:25:27 <merijn> Johnny_: What are you reading to learn Haskell?
11:25:52 <Johnny_> lots of google, sometimes a haskell wikipedia and 2 tutorial.pdfs
11:25:54 <Johnny_> dont have a book yet
11:26:01 <merijn> I recommend Learn You A Haskell
11:26:01 <Johnny_> but our prof suggested "the craft of programming" or so
11:26:02 <theorbtwo> 'x' == 9 doesn't make sense, so any code that could potentally be doing 'x' == 9 is bad code.
11:26:06 <merijn> @where lyah
11:26:06 <lambdabot> http://www.learnyouahaskell.com/
11:26:11 <dskippy> Johnny_: Real Wold Haskell is a great bood and free on line.
11:26:27 <dskippy> Johnny_: http://book.realworldhaskell.org/
11:26:34 <merijn> I think LYAH is better for beginners then Real World Haskell, but RWH is a good second book once you read LYAH
11:26:45 <merijn> Or mix up the two
11:26:49 * applicative considers there needs to be a "@where lyah and rwh" command on lambdabot
11:26:50 <jro> any good Parsec tutorial?
11:27:05 <Johnny_> thanks, bookmarked
11:27:11 <applicative> jro, there's the parsec tutorial
11:27:34 <dskippy> merijn: Johnny_ I concede Real World Haskell is more for the audience of "So you know a little haskell and are having trouble with writing real programs?" audience.
11:27:35 <blackh> Johnny_: I hope you stick with Haskell, at least until you've tried it out properly.  It really is an excellent programming language.
11:28:07 <Johnny_> yeah i like it actually but the beginning is quite difficult for me since i dont have any experience with programming
11:28:09 <merijn> Johnny_: The start of it should give you a slightly better understanding of the way types work and why your first attempt failed :)
11:28:21 <merijn> Johnny_: That's actually an advantage
11:28:22 <blackh> Johnny_: That's probably an advantage.
11:28:38 <Johnny_> twins?
11:28:42 <merijn> I had to spend half a year unlearning what I knew about programming when I started haskell :p
11:29:06 <blackh> I had to spend... oh...
11:29:10 <applicative> jro, of course there's this http://book.realworldhaskell.org/read/using-parsec.html
11:29:15 <blackh> :)
11:30:25 <jro> I did like LYAH, then yet another haskell tutorial had some good parts
11:30:39 <jro> I have not yet proceeded properly to more complicated stuff
11:31:02 <merijn> Johnny_: People here are pretty helpful to new people, if you ignore the extreme math geekiness that pops up :p
11:31:09 <merijn> @quote psychic
11:31:09 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
11:31:20 <Johnny_> :D yeah you guys really are very helpful
11:31:33 <Johnny_> btw. little problem with my interpreter or something:
11:31:50 <Johnny_> i tried out your code ( isPseudoDate :: (Int, Int, Int) -> Bool isPseudoDate (day, month, year) = day > 0 && day <= 31 && month > 0 && month <= 12 ) and then tried to check whether it works
11:32:01 <blackh> Johnny_: Hugs is really old now.  You might want to consider using GHC.
11:32:04 <Johnny_> i entered isPseudoDate "xx.xx.xxxx." and it didnt work
11:32:05 <merijn> Are you using ghci?
11:32:16 <mauke> Johnny_: it worked fine
11:32:32 <Johnny_> i know guys :( i was using ghci until today and asked my professor why we should continue using hugs since the rest of the world is using ghci
11:32:33 <merijn> Ah, but "xx.xx.xxxx" is a string, mine was a tuple of 3 Int's
11:32:42 <Johnny_> but he told me that "if you write a code and it doesnt work in my hugs, you get 0 points"
11:32:46 <Johnny_> so im forced to use hugs now..
11:32:58 <Johnny_> well to be precise, i entered "20.3.1945"
11:33:01 <merijn> You could always use GHCi and then once it works try and test in hugs
11:33:30 <Johnny_> btw how did you guys know im using hugs :D
11:33:39 <merijn> Johnny_: That's a string (i.e. a list of characters) you'll have to turn it into 3 parts and convert those into numbers
11:33:48 <blackh> Johnny_: Hugs will be fine for what you're doing.  We know because of the ***'s in the error messages.
11:33:55 <Johnny_> ah
11:34:07 <Johnny_> alright.. then ill have to do what blackh suggested
11:34:14 <applicative> Johnny_ don't let these guys diss Hugs.  It is a great contribution to humankind.
11:34:23 <Johnny_> :D
11:34:42 <Johnny_> and you could just let the lambdabot test it without having to turn the 3 parts into numbers?
11:34:50 <Johnny_> why cant my interpreter be as smart as lambdabot?
11:35:13 <applicative> your interpreter is as smart as lambdabot
11:35:30 <merijn> Johnny_: I gave lambdabot numbers
11:35:39 <mtnviewmark> (it is depressing to hear the state of professors who teach Haskell... from what I hear on this channel, there seem to be many of them who put Haskell in their curriculum with only the barest understand or experience...)
11:35:39 <merijn> :t (10, 5, 1986)
11:35:40 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1, t2)
11:35:53 <merijn> :t "10.5.1986"
11:35:54 <lambdabot> [Char]
11:36:02 <merijn> Way to be depressingly confusing, lambdabot...
11:36:34 <merijn> Johnny_: Split your problem in smaller steps: First you need to find a function that does "String -> [String]" (i.e. turn your string into a list of 3 strings) and then use "String -> Int" to make a function "[String] -> [Int]" and then "[Int] -> (Int, Int, Int)" (there's other possible steps, this is just an example)
11:36:49 <applicative> Johnny_ so besides an improved isPseudoDate, you need a way to go from a list of characters to three real numbers. 
11:37:01 <Johnny_> argh
11:37:34 <merijn> Johnny_: Trick number one of programming is: If a problem is too hard, stop trying to solve it and split it in smaller steps. Repeat until you know how to solve
11:37:54 <ash_> mtnviewmark: I am in college still, at my college when we had a class about programming languages, the only functional language we touched was lisp and scheme, (other languages in that class were prolog and smalltalk) 
11:37:55 <Johnny_> do i have to use function conjunction then?
11:38:01 <Johnny_> to make him turn my strings into numbers etc?
11:38:07 <aristid> merijn: that trick is not limited to programming :)
11:38:26 <jro> ash_: that was good list of languages
11:38:33 <merijn> aristid: Ssshh, I'm trying to mind-fake him to peek into the rabbit hole :p
11:38:41 <Cin> mtnviewmark: "There seem to be many [CS lecturers] of them who put [material] in their curriculum with only the barest understand or experience...", you don't say?
11:38:46 <aristid> merijn: ok :)
11:38:49 <merijn> Programming is like a red pill for the universe :p
11:39:00 <merijn> Or blue pill, whatever. I forget.
11:39:04 <ash_> jro: but it didn't include haskell, i didn't even know people statically typed functional languages until like 6 months ago 
11:39:17 <aristid> And the other pill is like, not going into the rabbit hole.
11:39:40 <aristid> merijn: is this "rabbit hole" thing from alice in wonderland? or earlier? hmm
11:39:42 <jon_of_arc> merijn: I thought the trick was "stop trying to solve it and combine it with other problems to make it bigger. Repeat until you can get funding for some assistants."
11:39:42 <magaio> Instead of printing out an array with its index values, how can I just print all elements of an array, one on each line?
11:39:53 <mtnviewmark> Cin - you think this is prevalent in general, I take it?
11:39:58 <merijn> aristid: Alice in Wonderland, yeah
11:39:59 <Johnny_> yep, from alice in wonderland
11:40:13 <merijn> I think you can replace a CS education with Alice in Wonderland, GEB and SICP :p
11:40:16 <Cin> mtnviewmark: From what I've seen, heard and experienced, yes.
11:40:17 <aristid> alice in wonderland and matrix combined :D
11:40:36 * mtnviewmark sighs long and quitely
11:40:36 <roconnor> @type unfoldr
11:40:36 <merijn> ash_: In the grand scheme of things that's not such a big crime. Many curriculums don't even treat functional languages
11:40:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:40:37 <dankna> Through the Looking Glass also has relevant material :D
11:40:44 <aristid> merijn: what is GEB?
11:40:51 <aristid> oh, Gödel Escher Bach?
11:40:55 <merijn> aristid: Gödel, Escher and Bach
11:41:35 <Cin> mtnviewmark: At least institutions like Utrecht exist which seems to be pumping out quality programmers like a factory.
11:41:45 <derekwright> join #anglohaskell
11:42:18 <mtnviewmark> don't read GEB - read Gödel's actual paper, look at Escher prints, listen to Bach -- all quite approachable! :-)
11:42:24 <Johnny_> how to you guys write to a person specifically?
11:42:26 <Cin> mtnviewmark: Quality Haskell programmers, that is. I can sound off Haskellers from there who have contributed significant and interesting libraries.
11:42:33 <Johnny_> do you just write his name?
11:42:43 <Johnny_> blackh test
11:42:45 <Johnny_> hm
11:42:55 <mtnviewmark> Cin - indeed the seem to. 
11:42:58 <merijn> Johnny_: Yeah, although most use tab completion to finish it :p
11:43:04 <ash_> Johnny_: in irc in general? 
11:43:08 <Johnny_> blackh: test2
11:43:12 <ash_> Johnny_: /msg Johnny_ hi
11:43:25 <merijn> I should check if Utrecht has some interesting PhD stuff then
11:43:42 <Johnny_> ah thanks, got the answer
11:43:57 <Johnny_> blackh: the "Maybe" you used is a haskell function?
11:44:11 <Johnny_> blackh: our prof never taught us that. you used it like Maybe (Int, Int, Int) or so
11:44:25 <merijn> Johnny_: Go take a look at LYAH it has a good explanation about Maybe
11:44:34 <mtnviewmark> Maybe is a type constructor
11:45:20 <Cin> Johnny_: I don't mean to sound rude; what *did* your prof teach you?
11:45:24 <mtnviewmark> given a type, like String, it designates a new type, Maybe String. Values of this type have either the value Nothing, or Just s, where s is some string 
11:45:27 <aristid> Maybe is both a type constructor and Just is a ... constructor. what to fill in for "..." there?
11:45:29 <aristid> -both
11:45:49 <mtnviewmark> It is useful when you need a case where there might not be any answer
11:46:23 <mauke> aristid: data
11:46:42 <Johnny_> Cin: well.. 
11:46:52 <Johnny_> Cin: its strange because sometimes they teach us really basic stuff
11:47:05 <Johnny_> Cin: and then he started with some fib.step and fib.pair that nobody understood
11:47:34 <mreh> which is the best XML library?
11:47:41 <mtnviewmark> > let m = Data.Map.fromList [(42, "answer"), (3, "magic number")] in (Data.Map.lookup 3 m, Data.Map.lookup 4 m)
11:47:42 <lambdabot>   Not in scope: `Data.Map.fromList'Not in scope: `Data.Map.lookup'Not in scop...
11:47:50 <aristid> mauke: could i also say data constructor for a newtype constructor?
11:47:56 <mtnviewmark> silly lambdabot
11:48:14 <mtnviewmark> > let m = Map.fromList [(42, "answer"), (3, "magic number")] in (Map.lookup 3 m, Map.lookup 4 m)
11:48:15 <lambdabot>   Not in scope: `Map.fromList'Not in scope: `Map.lookup'Not in scope: `Map.lo...
11:48:33 <mreh> :t M.Map
11:48:34 <lambdabot> Couldn't find qualified module.
11:48:37 <ajnsit> I managed to break my ghc installation pretty badly.. What's the best way to delete everything and start with a fresh installation of ghc?
11:48:42 <mtnviewmark> :t Map
11:48:43 <lambdabot> Not in scope: data constructor `Map'
11:48:51 <mtnviewmark> I thought lambdabot knew about Map
11:48:58 <mtnviewmark> ajnsit - what platform?
11:49:12 <ajnsit> mtnviewmark, Linux Ubuntu 10.04
11:49:32 <mtnviewmark> do you think you just broke things that you installed --user?
11:49:34 <mtnviewmark> or --global?
11:50:17 <mtnviewmark> user stuff is under ~/.cabal -- -you could just blow that (or just it's contents) away
11:50:18 <ajnsit> mtnviewmark, well I initially used to install things --global but then I realised that was a bad practice so I started going --user and now I think the whole system is confused
11:50:28 <ajnsit> I deleted .cabal and .ghc
11:50:39 <ajnsit> and I still can't get ghc 7 to build
11:50:44 <aristid> :t M.fromList
11:50:45 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
11:50:48 <mtnviewmark> run ghc-pkg check
11:50:50 <aristid> \o/
11:50:55 <ajnsit> cannot satisfy -package time-1.2.0.3: 
11:50:55 <ajnsit>     time-1.2.0.3-inplace is shadowed by package time-1.2.0.3-13780049521550a016083589927d00df
11:50:55 <ajnsit>     time-1.2.0.3-13780049521550a016083589927d00df is unusable due to missing or recursive dependencies:
11:50:55 <ajnsit>       base-4.3.0.0-b91367e4fa5bd47d8e75958171ad21b7 old-locale-1.0.0.2-2aaf7d0f12fe71bd6e7c53c1018bd289
11:50:55 <mtnviewmark> if it is happy, then you are good to go
11:51:06 <iago> hi, someone have tested HPC with recent versions of GHC?
11:51:13 <mtnviewmark> oh - fie
11:51:19 <aristid> > let m = M.fromList  [(42, "answer"), (3, "magic number")] in (M.lookup 3 m, M.lookup 4 m)
11:51:20 <lambdabot>   (Just "magic number",Nothing)
11:51:38 <mtnviewmark> ghc-pkg unregister time-1.2.0.3
11:51:55 <Cin> Johnny_: Basic stuff that Chapter 1 LYAH or Try Haskell could cover? ;-)
11:52:11 <ajnsit> mtnviewmark, ghc-pkg: unregistering time-1.2.0.3 would break the following packages: haskell98-1.1.0.0 random-1.0.0.3 (use --force to override)
11:52:13 <moosefish> So, one interesting way to structure code in imperial languages is "guard style" (http://hpaste.org/42025/guard_style). Idea is to check all preconditions, abort a function if one fail, and then at the bottom completely do the actual work once we know everything is dandy.
11:52:25 <mtnviewmark> oh dear
11:52:31 <mtnviewmark> okay - it DOES look messed up
11:52:38 <ajnsit> yeah :(
11:52:40 <moosefish> Since haskell's 'if' is actually an expression, you get deeply nested statements (or recursive functions, or w\e). Any compromise to be had in a do block?
11:53:29 <ajnsit> what else can I do except remove .ghc and .cabal?
11:53:35 <Johnny_> Cin: well i introduced the command "head" and "tail" today if that makes it clearer to you ;)
11:54:04 <mtnviewmark> I think the DB is in /var/lib/ghc--x.x.x/...
11:54:18 <mtnviewmark> you could, I suppose blow that away, and reinstall from the Ubuntu pckages
11:54:31 <Cin> Johnny_: 'K...
11:54:34 <applicative> ajnsit, I think you may have overwritten the original versions of some of the basic packages
11:55:07 <ajnsit> applicative, yes I have been living with a broken system for a while
11:55:35 <ajnsit> but it really went kaput this time
11:55:40 <applicative> you need ghc to build ghc-7 i guess
11:56:05 * applicative has done this sort of thing several times
11:56:52 <ajnsit> I have a ghc 7 binary
11:57:07 <ajnsit> I managed to build it on my machine earlier
11:57:14 <applicative> oh, and it works?
11:57:21 <ajnsit> yes it worked then
11:57:29 <ajnsit> but I cannot repeat the build now
11:57:41 <ajnsit> but the binary still works
11:58:17 <applicative> the ghc-pkg you were using is the one for that ghc?
11:58:31 <ajnsit> applicative, hmm I would think so
11:58:42 <ajnsit> yes it is
11:58:59 <ajnsit> it's in the same folder (I installed everything under $HOME/apps)
11:59:09 <ajnsit> the old ghc is in a different place
11:59:26 <applicative> did you use cabal install with the new ghc?
11:59:34 <ajnsit> applicative, yes
11:59:47 <ajnsit> I did a cabal install cabal-install
11:59:51 <applicative> yes, if you have a local ghc it
11:59:56 * mtnviewmark >>= lunch
12:00:10 <applicative> is easy to forget to still make a global local distinction.  
12:00:43 <ajnsit> hmm
12:00:48 <applicative> then cabal install can easily overwrite stuff essential to the system.   At least I think that is the problem you have, and I had.
12:01:31 <ajnsit> applicative, okay so how did you solve this problem?
12:01:35 <applicative> ajnsit, this is why it is referring to packages it has and has had, with hashes.
12:01:39 <gienah> on gentoo I would recover from similar situation by emerge -C everything that depended on ghc, then emerge -C ghc, then emerge ghc again
12:02:13 <ajnsit> gienah, I really want to install ghc from sources
12:02:24 <ajnsit> not the os specific packages
12:03:12 <gienah> the way I play with ghc 7.0.1 is to install a chroot for 7.0.1, hence keeping the 6.12.3 and 7.0.1 stuff sepearate
12:03:43 <gienah> so in the chroot, install 6.12.3, then build 7.0.1 from sources
12:04:12 <ajnsit> gienah, yeah that makes sense, if only I had had the foresight :(
12:04:50 <ajnsit> okay I'm going to remove everything on my system related to ghc and then try going the chroot way
12:04:59 <applicative> ajnsit. i solved it by chucking the install of ghc, and starting over with a clearer idea of the distinction
12:05:17 <applicative> ajnsit, i take it you have an older ghc in like /usr/local/bin though?
12:05:27 <ajnsit> applicative, yes
12:05:37 <applicative> i mean, that you're using to build.  
12:05:39 <ajnsit> applicative, and a bunch of packages in /usr/local/lib
12:06:22 <ajnsit> I think that installation of GHC 6 in /usr/local is really messed up I need to remove it so it cannot interfere with the installation of 7
12:07:15 <applicative> ajnsit, i see, i thought it was seven that was messed up only.  it's hardet to build ghc without a ghc around :)
12:08:18 <ajnsit> applicative, yes maybe the way to do this is to install the ubuntu ghc and then use that to bootstrap 7
12:09:26 <applicative> maybe, yes if you think the old ubuntu one is wrecked to.  the important thing will the keep track of where cabal is putting things when you get to that point
12:10:37 <Johnny_> ok me again. so ive got isPseudoDate :: (Int, Int, Int) -> Bool isPseudoDate (day, month, year) = day > 0 && day <= 31 && month > 0 && month <= 12    | month = [1,3,5] = day 
12:10:51 <Johnny_> the part after | month is just what im trying to do now
12:11:24 <Johnny_> the idea is that i want him to check whether the number given for month corresponds to a certain number (e.g. 1,3,5) and as a consequence, change the limits to day
12:11:29 <Johnny_> can i do this using guards?
12:11:40 <applicative> the ghc and the accompanying libs and maybe the haskell platform libs should be kept separate from anything else you install, if you use cabal install, that's my wisdom
12:11:48 <Botje> Johnny_: check the "elem"
12:11:51 <Botje> function
12:11:56 <Johnny_> k
12:12:43 <blackh> Johnny_: You have to say isPseudoDate (day, month, year) | .... = but if you're outputting a boolean, you don't need a guard.
12:13:01 <blackh> Johnny_: There's no point in saying  | something = True. You might as well say = something
12:13:15 <blackh> (unless you have lots of them)
12:15:56 <Johnny_> is the explanation to "elem" written in "learn you a haskell" included?
12:16:01 <Johnny_> whops
12:16:23 <blackh> > 5 `elem` [1,3,5]
12:16:23 <lambdabot>   True
12:17:29 <Johnny_> yes, i found a short explanation in "zvon" but i need to use it differently
12:17:49 <Johnny_> its not supposed to just say true or false but instead have a consequence if it turns out true
12:18:09 <byorgey> Johnny_: maybe you want an if-expression ?
12:18:18 <byorgey> if (5 `elem` [1,3,5]) then ... else ...
12:18:24 <Botje> Johnny_: guards accept expressions that return a Bool
12:18:30 <blackh> You can say daysPerMonth m | m `elem` .. = 31
12:18:30 <blackh>                                                            | m `elem` .. = 30
12:19:03 <Johnny_> hmm that sounds more or less like what im looking for
12:21:20 <Johnny_> does m 'elem' .. = 31 mean from 0 to 31?
12:21:42 <Johnny_> blackh: does m 'elem' .. = 31 mean from 0 to 31?
12:22:02 <blackh> No... I meant that you want to put a list in there, e.g. | m `elem` [1,3,5] = 31
12:22:24 <blackh> You'll need a few more months in there.
12:22:36 <Johnny_> yes ;) i was just starting off with 1,3,5
12:22:38 <blackh> That means "if m is an element of [1,3,5] then the value is 31"
12:23:02 <Johnny_> but i want to change the limits, not the value
12:23:09 <Johnny_> so if m stands for months and d stands for days
12:23:23 <bss03> daysPerMonth February = 28; daysPerMonth m | m `elem` [September, April, June, November] = 30 | otherwise = 31;
12:23:42 <blackh> Johnny_: If you do it like that, then you're splitting the problem up nicely.  if d > daysPerMonth m then ...
12:23:52 <Johnny_> | m 'elem' [4,6] = d (from 1-31)
12:24:19 <blackh> Or use a 'data' declaration for months like bss03 suggests
12:25:16 <blackh> Johnny_: You'll probably find it easier if you split the problem of 'how many days are there in month m' out into a separate function.  That's what I'm saying.
12:25:27 <bss03> monthDays m = take (daysPerMonth m) [1..]
12:25:54 <bss03> validDate m d = d `elem` monthDays m
12:26:14 <bss03> validDate February 29 -- False :(
12:27:03 <merijn> bss03: That's awful
12:27:24 <Johnny_> wait, i think i expressed myself unclearly here
12:27:39 <merijn> Why not just "validDate m d = d > 0 && d < daysPerMonth m"
12:27:51 <Johnny_> my function is not really supposed to tell me how many days the month X has, instead, when i enter a date, like 31.2.1945 hes supposed to check whether this date is even possible
12:28:09 <merijn> Johnny_: Yes, but how do you know if a date is possible?
12:28:25 <Johnny_> well i meant like that:
12:28:36 <blackh> Johnny_: I realize that, but it's still probably a good idea to separate the concept of "how many days are there in month m" out into a separate function, so that your intended function doesn't turn into too much spaghetti.
12:28:36 <monochrom> give it to the date parser and watch it bomb
12:28:37 <bss03> merjin: validDate m = (&&) <$> (> 0) <*> (< daysPerMonth m)
12:28:44 <merijn> By checking that the day number is smaller then the number of days in that month, no?
12:29:05 <monochrom> as a bonus you also get it parsed
12:29:07 <merijn> Johnny_: How do you know how many days are in a given month? Answer: write a function that tells you
12:29:15 <Johnny_> well yes (and in some cases whether the year number is divideable by 4 etc.)
12:29:41 <blackh> Johnny_: Incidentally, if you express your date as (year, month, day) then < and > will automatically work correctly for them.
12:30:12 <merijn> Johnny_: So, first solve "how many days are in a month?", then use that solution to solve "is this date valid?"
12:30:31 <monochrom> > parseTime
12:30:32 <lambdabot>   Not in scope: `parseTime'
12:30:42 <monochrom> > Data.Time.Format.parseTime
12:30:42 <lambdabot>   Not in scope: `Data.Time.Format.parseTime'
12:31:05 <sm> anyone else interested in talking to agilezen.com's api ?
12:31:24 <sm> I've got a quick script, but time's up
12:33:25 <Johnny_> im only allowed to write 1 single function for all of this, unfortunately
12:33:45 <sm> and what is the current recommended easy json lib for unpacking to custom haskell data types ?
12:34:10 <blackh> Johnny_: That's ridiculous.
12:34:31 <bss03> Johnny_: Seems like bad programming practice.  You could always stick them in the where clause if you don't want them as top-level declarations.
12:34:35 <blackh> Johnny_: You can put your extra functions in a 'where' clause, then it's only "one function".
12:34:53 <Johnny_> hm
12:34:54 * monochrom knows how to even eliminate the "where" and the "let"
12:35:22 <merijn> monochrom: Trivial substitution using lambda's?
12:35:30 <bss03> Johnny_: If you have to have only one function, it's just gonna be a mess of case statements, probably with some duplicated code.
12:35:36 <monochrom> yeah, and use fix if there is recursion
12:35:50 <blackh> Johnny_: If your professor doesn't give you marks for writing more than one function, I'm sure we can arrange an open letter with 100 signatories.
12:36:11 <AmunRa> Hello! Is there some trick to make records less awkard to work with? .. it's the namespace pollution that's particulary annoying -- i.e. `data Point = Point { pointX, pointY :: Int };` but then `someFunc (pointX p)` is really not all that great
12:36:15 <monochrom> screw 100 signatures. DDoS the prof with 100 emails.
12:36:23 <bss03> If someone considered a function in a where as "invalid" I think using lambda notation is equaly "invalid".
12:36:33 <Johnny_> hehehe ;)
12:36:38 <Twey> AmunRa: Make a module
12:37:18 <monochrom> "write a function to ..." does not mean forbidden to write helper functions
12:37:21 <bss03> AmunRa: Modules are the only way to isolate names. :(
12:38:08 <AmunRa> `module Point where data Point = Point { x,y :: Int }` and then `import qualified Point as P`  ... making `someFunc (P.x p)`
12:38:14 <AmunRa> I guess it is slightly better
12:38:30 <blackh> AmunRa: It's not ideal.  What I do is ugly but practical:  I prefix field names with something that identifies the type, e.g. poX, poY.  It has the advantage that you can spot field accessor functions in your code easily, and they don't get confused with values of fields.
12:38:49 <AmunRa> `p.x` would be great
12:39:32 <blackh> AmunRa: In a nutshell, the situation with this is that everyone agrees it's not ideal, and there have been a number of proposals, but nobody has found it annoying enough in practice to build up the "political" will to have it changed.
12:39:41 <augur> Saizan: do you have a blog that i can link to?
12:39:53 <AmunRa> blackh, yeah.. that's what I usually do too.. see code in question
12:40:34 <blackh> AmunRa: I use a two or three letter prefix because 1. it's not much typing, and 2. I don't do that in any other situation so it becomes very clear that it's a field accessor.
12:40:42 <Twey> I don't think that's the case… AIUI, it's more that everybody hates it, but nobody can settle on one alternative
12:40:47 <blackh> AmunRa: By the way, my favourite field accessor library is 'fclabels'.
12:41:36 <ndrsndrs> AmunRa: http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
12:41:41 <ndrsndrs> (you may have already seen it)
12:41:44 <blackh> AmunRa: What Twey said.  Part of the problem is that the way it's done in C and other languages just doesn't translate to Haskell at all.
12:45:46 <Cale> I've never really minded prefixing my field labels that much. In fact, I like prefixes better than module qualifiers a lot of the time.
12:47:39 <osaunders> Cale: Do you prefix with the full name of the type or an abbreviation?
12:48:05 <Cale> usually an abbreviation
12:48:49 <Cale> I started using Haskell in the days when we still had FiniteMap in place of Map, and all the identifiers were fooFM
12:49:40 <Cale> which I actually kind of like better than having to import the module qualified, and use qualified names (which make compositions annoying to read)
12:49:41 <AmunRa> blackh: how's that? Data.List.map   the dot here already means scope resolution.   Yes... there could be code breaking.. but I think that's manageable through a warning
12:50:22 <radicality> hi. how do you set up precision properly in ghci ? i'm doing some simple arithemetic, and the result ends up being something like 0.199999999999996, instead of 0.20…. any ideas ? thanks
12:50:24 <Cale> It's already bad enough that we're reusing . for module qualification.
12:50:49 <AmunRa> radicality... import Data.Ratio ... 1 % 3
12:51:01 <Twey> Cale: Wouldn't matter if we had whitespace-sensitivity… ;)
12:51:02 <mauke> radicality: that is "proper"
12:51:26 <Cale> radicality: That's just how floating point works. You can display rounded versions of numbers using showFFloat from Numeric
12:51:30 <radicality> hmm, i'm just doing subtraction, 0.47 − 0.27
12:51:38 <radicality> how do use Ratio for this ?
12:51:56 <Cale> > 0.47 - 0.27 :: Rational
12:51:57 <lambdabot>   1 % 5
12:52:06 <mauke> preflex: calc '2 0.47
12:52:06 <preflex>  0.01111000010100011110101110000101000111101011100001
12:52:09 <mauke> preflex: calc '2 0.27
12:52:09 <preflex>  0.010001010001111010111000010100011110101110000101001
12:52:19 <mauke> preflex: calc '2 0.47 - 0.27
12:52:20 <preflex>  0.0011001100110011001100110011001100110011001100110011
12:52:28 <Johnny_> ok this is just a more or less pseudo code, but once ive fixed the syntax, is it possible to do it like this? 
12:52:30 <Johnny_> isPseudoDate :: (Int, Int, Int) -> Bool isPseudoDate (day, month, year) = day > 0 && day <= 31 && month > 0 && month <= 12  if month = [4,6,9,11]        then day <=30 else if year 'div' 4 && month = 2       then day <= 28 else if month == 2 || year 'div' 4      then day <= 29 if day || month || year < 0       then False
12:52:33 <merijn> 9 times out of 10.0000000000000000028747 you don't really want floating points
12:52:44 <AmunRa> Data.Ratio is like working with fraction when the numbers you're working with don't translate well to base-2 arithmetic
12:52:58 <blackh> Also, TDNR doesn't solve the problem of record names not being first class.  We really need a complete solution to the problem.
12:53:24 <Twey> > showFFloat (Just 1) (0.47 - 0.27) ""
12:53:25 <lambdabot>   "0.2"
12:53:38 <blackh> radicality: use showFFloat from 'Numeric' package
12:53:57 <radicality> hmm ok, showFFloat seems to work, thanks guys. wow, this is complicated for just a simple thing, haha....
12:54:39 <blackh> Johnny_: That looks fine except for several small details (which the compiler will happily tell you about).
12:54:53 <Johnny_> yeah he told me he didnt expect "if"
12:54:56 <Cale> radicality: Well, it's really the same in any programming language. Blame the fact that your CPU does floating point arithmetic which doesn't have an exact representation of 0.2
12:54:57 <merijn> radicality: This is the same in any programming language. I recommend you read up on floating points, they're tricky beasts and will kill you if you're not on your guard
12:55:27 <merijn> radicality: You know how 1/3 is 0.33333... and calculators round causing errors?
12:55:42 <blackh> Johnny_: Well, that's ridiculous too.
12:55:44 <radicality> ok yeah, thanks, i'll read up. i know you can't represent that, but I was just hoping ghci would display it more nicely by default
12:55:57 <merijn> radicality: The same happens with floating points, but since your CPU uses binary which fractions repeat differs from decimal
12:57:37 <blackh> Johnny_: 'if' is a perfectly valid way of implementing that function.  So is |, and so is using extra functions.  Using extra functions is the preferred way.
12:58:07 <Johnny_> damn, even ghci told me he didnt expect if
12:58:34 <Cale> Johnny_: hm?
12:58:37 <blackh> Johnny_: Every 'if' has to have a 'then' and and 'else' (no exceptions to this rule)
12:59:18 <Johnny_> isnt it if ....  then .... else if .... 
12:59:37 <blackh> Johnny_: That's fine, as long as every if has both 'then' and 'else'
12:59:58 <Johnny_> well in my case:
13:00:05 <Johnny_> i start with if, followed by a then
13:00:14 <Johnny_> and from then on its onle else if.. then... else if... then..
13:00:28 <Cale> You should consider using guards
13:00:30 <mauke> <blackh> Johnny_: That's fine, as long as every if has both 'then' and 'else'
13:00:33 <blackh> The last 'if' has to have an 'else' too.
13:00:38 <AmunRa> `if` isn't as useful in haskell as it is in other languages... 
13:01:04 <Johnny_> isPseudoDate :: (Int, Int, Int) -> Bool isPseudoDate (day, month, year) = day > 0 && day <= 31 && month > 0 && month <= 12  if month = [4,6,9,11]        then day <=30 else if year 'div' 4 && month = 2       then day <= 28 else if month == 2 || year 'div' 4      then day <= 29 else if day || month || year < 0       then False
13:01:14 <mtnviewmark> was the "he" in "he didn't expect 'if'" the professor? or does your version of gchi have a gender :-)  ?
13:01:30 <ddilinger> i was using "map (\(Just x) -> x)" to turn Maybe a into a (removing all Nothing elements), is there a more direct route?
13:01:33 <Johnny_> yeah mc ghci is pure masculinity
13:01:38 <Johnny_> my*
13:01:44 <ddilinger> err, turn [Maybe a] into [a]
13:01:52 <blackh> ddilinger: map fromJust (from Data.Maybe)
13:02:00 <blackh> ddilinger: or catMaybes
13:02:34 <mtnviewmark> Data.Maybe is just full of gems 
13:03:07 <blackh> Johnny_: = day > 0 && day <= 31 && month > 0 && month <= 12  if <- this 'if' is misplaced
13:03:23 <blackh> Johnny_: You probably want: if day >0 && day <= 31 ...
13:03:37 <Johnny_> hmm
13:04:00 <Johnny_> so if day>0 && day<= .... then true?
13:04:36 <blackh> (I thought 'he' was your professor before, not ghci.)
13:04:46 <AmunRa> some of the things, however I am surprised are there... `Data.List.safeHead :: [a] -> Maybe a` doesn't exist.. it's instead present as `Data.Maybe.listToMaybe` which is somewhat of an odd place to find it
13:04:50 <Johnny_> btw i noticed a small error concerning if month == 2 || year 'div' 4 
13:04:55 <Johnny_> heheh ok, in that case i meant ghci
13:04:58 <blackh> Johnny_: That would be valid syntax but doesn't seem like the right logic
13:05:08 <Johnny_> yeah thats what i meant
13:05:17 <blackh> Johnny_: Then your professor is not (quite) as crazy as I thought. :)
13:05:17 <Johnny_> yeah thats what i meant februrary
13:05:18 <Cale> That wouldn't be valid syntax, actually
13:05:18 <opqdonut> @src fromJust
13:05:18 <opqdonut> and that doesn't remove Nothing elements, it throws an error
13:05:18 <lambdabot> fromJust Nothing  = undefined
13:05:19 <lambdabot> fromJust (Just x) = x
13:05:32 <Cale> 'div' looks like an invalid character literal
13:05:36 <Cale> You want `div`
13:05:40 <mtnviewmark> :t catMaybes
13:05:41 <lambdabot> forall a. [Maybe a] -> [a]
13:05:47 <Johnny_> oh
13:05:49 <Johnny_> thanks, cale
13:05:52 <Johnny_> ` test
13:06:25 <laker> quick question, why is this, haskell: 
13:06:25 <laker> Prelude> -0.134 / 6
13:06:25 <laker> -2.2333333333333334e-2
13:06:32 <laker> python: >>> -0.134 / 6
13:06:32 <laker> -0.022333333333333334
13:06:33 <Twey> catMaybes = map fromJust . filter isJust = \ xs -> [ x | Just x <- xs ]
13:06:36 <mtnviewmark> > let ml = [Just 3, Nothing, Just 1, Just 4, Nothing, Nothing] in catMaybes ml
13:06:37 <lambdabot>   [3,1,4]
13:06:45 <Twey> laker: Same thing
13:06:56 <Cale> laker: I guess, because the default is to use scientific notation
13:07:07 <laker> how can i change it
13:07:11 <Twey> Just different representations
13:07:16 <Cale> by using showFFloat
13:07:21 <laker> ok, thanks
13:07:29 <blackh> laker: showFFloat comes from the 'Numeric' module
13:08:45 <ash_> printf "%0.10f" ((-0.134/6)::Float)
13:08:59 <ash_> > printf "%0.10f" ((-0.134/6)::Float)
13:09:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:09:01 <lambdabot>    `GHC.Show.Show a'
13:09:01 <lambdabot>      a...
13:09:24 <Cale> > printf "%0.10f" ((-0.134/6)::Float) :: String
13:09:24 <lambdabot>   "-0.0223333330"
13:09:34 <ash_> ah, oops
13:19:59 <tromp_> :t cacth
13:20:00 <lambdabot> Not in scope: `cacth'
13:20:02 <tromp_> :t catch
13:20:03 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
13:20:56 <Johnny_> isPseudoDate :: (Int, Int, Int) -> Bool isPseudoDate (d, m, y) =    if m == [4,6,9,11]    then d <=30   else if y `div` 4 && m == 2     then d <= 29     else if m == 2        then d <= 28       else if d || m || y < 0          then "False"         else if d > 0 && d <= 31 && m > 0 && m <= 12           then "True"           else "False"
13:21:07 <Johnny_> he tells me:
13:21:40 <mtnviewmark> consider using http://hpaste.org  for this
13:22:23 <mtnviewmark> if m == [4,6,9,11]       --- did you really mean to test if m was the array with four number 4, 6, 9, & 11?
13:24:02 <mtnviewmark> if d || m || y < 0   -- this works in COBOL, but not Haskell --- the < 0 test isn't applied to each item, only y  -- so you are asking "if d is True or m is True or y less than zero"
13:24:29 <Johnny_> test: isPseudoDate :: (Int, Int, Int) -> Bool isPseudoDate (d, m, y) =    if m == [4,6,9,11]    then d <=30   else if y `div` 4 && m == 2     then d <= 29     else if m == 2        then d <= 28       else if d || m || y < 0          then "False"         else if d > 0 && d <= 31 && m > 0 && m <= 12           then "True"           else "False"
13:24:30 <Johnny_> hm
13:24:34 <mtnviewmark> at this point m has been assumed to be a list of numbers, and a boolean
13:24:47 <Johnny_> how do i paste it nicely?
13:24:52 <mtnviewmark> but I bet you want it to be just a number
13:24:56 <mauke> @hpaste
13:24:56 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:24:57 <mtnviewmark> you can't paste it nicely into IRC
13:25:00 <mauke> @where hpaste
13:25:00 <lambdabot> http://hpaste.org/
13:25:16 <Johnny_> yes, ive got it there
13:25:17 <mee> mtnviewmark: I'd do something like: and $ map (<0) [d,m,y] 
13:25:21 <Johnny_> i thought its meant to make it more readable for you
13:25:23 <mee> but there are probably better ways
13:25:43 <mtnviewmark> well, mee, I think for Johnny_, doing the slightly more verbose way will be clearer to start
13:25:45 <mee> err, that should be 'or $', obviously
13:25:55 <ndrsndrs> mee: any (<0) [d,m,y]
13:26:05 <mee> oh, sorry I missed the context there
13:26:09 <merijn> Johnny_: You're supposed to paste it on one of those sites and paste the link in here so we can look at it :p
13:26:10 <arkonten> consider the get-functions that we get when defining a data type using record syntax. is there an equally neat way to "modify" fields?
13:26:19 <Johnny_> ohhh
13:26:21 <Johnny_> wait then :D
13:26:27 <mee> any, right.   (/me returns to lurking)
13:26:35 <Johnny_> http://hpaste.org/42026/ispseudodate#3
13:26:48 <mauke> arkonten: r{ f = x }
13:27:08 <Johnny_> mtnviewmark: ok i understand the problem with the boolean 
13:27:28 <Johnny_> mtnviewmark: how do i solve this? do i have to check every single one?
13:27:47 <mtnviewmark> well isn't that what you want to happen?
13:28:04 <arkonten> mauke: that's indeed neat! thanks! 
13:28:42 <blackh> Johnny_: Using guards, i.e. |, would definitely be nicer
13:28:54 <Johnny_> yes im trying to copy from the page
13:29:05 <azudem> Hi. (Sorry fot my bad english.) I define 'data Point = Point Float Float', then 'type Vector = Point'. But wgen I use 'Vector', Haskell say error: Not in scope: data constructor `Vector'. Help me please
13:29:06 <blackh> Johnny_: m `elem` [4,6,9,11] rather than ==
13:29:09 <Johnny_> i didnt know you can use guards that easily
13:29:42 <blackh> azudem: The constructor's name is still 'Point' (even though you can call the *type* Vector).
13:30:15 <Johnny_> and mtnviewmark: yes thats what i want to happen. what i meant is, do i have to write each check explicitly or is there a way to "combine" the check like i tried using the logical disjunctor
13:30:42 <mtnviewmark> yes, as you do in every programming language I know of, (except COBOL... seriously...)
13:31:04 <azudem> blackh: I must change Vector to Point in the function's declarations? Why vector don't work. I think vector is full synonym for point, isn't it?
13:31:22 * hackagebot web-routes-quasi 0.6.2 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.2 (MichaelSnoyman)
13:31:46 <blackh> azudem: 'type' makes the type into a synonym, but it doesn't make a constructor called 'Vector'.
13:32:15 <merijn> Johnny_: There are ways to combine them, yes. But generally they are more complicated then the simple approach which is why they are not always told to new people immediately
13:32:17 <azudem> blackh: when 'Vector' will work?
13:32:24 * hackagebot yesod 0.6.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.5 (MichaelSnoyman)
13:32:28 <Johnny_> merijn:  ok
13:32:31 <blackh> azudem: So, Vector looks like "data Vector = Point Float Float"
13:32:46 <merijn> Johnny_: For example:
13:32:59 <merijn> > all (>0) [1,2,3,4,5]
13:33:00 <lambdabot>   True
13:33:06 <merijn> > all (>0) [-1,2,3,4,5]
13:33:06 <lambdabot>   False
13:33:18 <revenantphx> What's the haskell equivellent of strtok?
13:33:26 <benmachine> parsec?
13:33:27 <Johnny_> i see
13:33:27 <revenantphx> @hoogle [a] -> [[a]]
13:33:28 <lambdabot> Data.List inits :: [a] -> [[a]]
13:33:28 <lambdabot> Data.List permutations :: [a] -> [[a]]
13:33:28 <lambdabot> Data.List subsequences :: [a] -> [[a]]
13:33:33 <benmachine> <_<
13:33:35 <revenantphx> No, I want to split a list at a certain value.
13:33:38 <merijn> :t all
13:33:38 <benmachine> ah
13:33:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:33:39 <mauke> revenantphx: split
13:33:45 <merijn> :t (>0)
13:33:46 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
13:33:46 <blackh> revenantphx: splitAt
13:33:47 <Johnny_> hmm, ghci doesnt like my use of `div`4
13:33:50 <benmachine> span/break may do what you want
13:33:53 <revenantphx> blackh: split at splits only once.
13:33:55 <blackh> revenantphx: Oh, break
13:34:07 <blackh> revenantphx: There isn't one that splits a string into tokens, but Data.Text has that.
13:34:07 <benmachine> revenantphx: so does strtok :P
13:34:16 <revenantphx> kk
13:34:17 <mauke> yes, there is
13:34:17 <benmachine> revenantphx: see: the split package on hackage
13:34:34 <merijn> Johnny_: Basically, "all" takes a function "a -> Bool" and a list of a's and then returns true if for every a in the list the function you gave it returns true
13:34:39 <revenantphx> splitOn is perfect
13:34:58 <azudem> azudem: I write 'type Vector Float Float = Point Float Float' -- it doesn't work. How I can save functions declarations with 'Vector' word?
13:35:15 <azudem> blackh: I write 'type Vector Float Float = Point Float Float' -- it doesn't work. How I can save functions declarations with 'Vector' word?
13:35:19 <mauke> what?
13:35:19 <merijn> Johnny_: (>0) obviously checks whether a number is greater then zero, so "all (>0)" returns true if all elements in a list are greater then zero
13:35:46 <Johnny_> http://hpaste.org/42028/ispseudocode
13:36:13 <Johnny_> thanks merijn 
13:36:13 <blackh> azudem: 'type' takes a type after =, and 'data' takes a constructor.
13:36:23 <blackh> azudem: You're trying to give a constructor to 'type'.
13:36:52 <mauke> blackh: you keep using that word
13:36:55 <blackh> Johnny_: I have to say, that code is looking very nice.
13:37:43 <azudem> blackh: Ok. It's impossible to save functions declarations with 'Vector' word?
13:37:45 <blackh> mauke: What's wrong with the word 'a' ?
13:38:05 <blackh> azudem: What do you mean by 'save' ?
13:38:33 <mauke> blackh: 'constructor'
13:38:54 <blackh> mauke: Oh. So what's wrong with the word 'constructor'?
13:39:00 <azudem> blackh: I have 'foo: Vector -> Vector -> Blablabla'. I don't want to change Vector to Point.
13:39:27 <mauke> blackh: nothing, but 'Maybe' is a constructor, and so is 'Just'
13:39:40 <merijn> Johnny_: I'd do something like: http://hpaste.org/paste/42028/ispseudodate#p42029
13:39:42 <azudem> blackh: ok. tnx
13:39:44 <blackh> azudem: If you say 'data Point = Vector Float Float ; type Vector = Point' then that signature 'Vector -> Vector -> Blablalba' is fine.
13:39:47 <mauke> ('Maybe' is a type constructor, 'Just' a data constructor)
13:39:48 <merijn> (Warning: I didn't test it)
13:39:53 <blackh> mauke: Good point
13:40:42 <EvanCarroll> What is the cleanest way to write [(*2),(*3)] <*> [1..10] wo/ applicatives
13:40:49 <blackh> azudem: But you have to say "foo (Point x y) = ..."  ... oh, bye bye
13:40:51 <EvanCarroll> and wo/ [ x xs | x <- [(*2),(*3)], xs <- [1..10] ]
13:41:01 <mauke> > [(*2),(*3)] `ap` [1..10]
13:41:01 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,3,6,9,12,15,18,21,24,27,30]
13:41:34 <EvanCarroll> @src ap
13:41:35 <lambdabot> ap = liftM2 id
13:41:51 <companion_cube> :t ap
13:41:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:41:52 <blackh> Please ignore the mistakes in what I just wrote to azudem above. ;)
13:41:53 <EvanCarroll> liftM2..  never even heard of it
13:42:38 <Botje> liftM? I hardly knewM!
13:44:13 <revenantphx> any good way to get a String out an IO String?
13:44:22 <zachk> NO 
13:44:29 <Cale> By running the action
13:44:33 <ndrsndrs> noooo
13:44:35 <revenantphx> I guess I just need to lift this function
13:44:43 <Cale> do x <- myIOString; ... x is a string here ...
13:44:49 <zachk> you could fmap it 
13:44:52 <zachk> or lift it 
13:45:05 <zachk> or use a let 
13:45:11 <Cale> The do-block as a whole will be another IO action
13:45:14 <Johnny_> oh i didnt know you could combine guards and if/then
13:45:14 <mauke> revenantphx: IO String does not contain a String
13:45:29 <revenantphx> Its an action that will produce one?
13:45:31 <Johnny_> merijn: oh i didnt know you could combine guards and if/then
13:45:33 <Cale> yes
13:45:54 <mauke> revenantphx: do you know javascript?
13:46:40 <revenantphx> not much
13:46:49 <revenantphx> I have a HTTP request you see, and I'm trying to do this
13:46:50 <revenantphx> sid <- liftM2 splitOn (return ":") (getResponseBody rq)
13:46:51 <revenantphx> (this works)
13:47:02 <revenantphx> It's just... not pretty :P
13:47:30 <merijn> Johnny_: You can, the guards just say "only look at this if the guard is true", you can use anything you want in the result of that guard
13:47:31 <Johnny_> merijn: he gives me an error stating ""no instance for (integral bool) arising from a use of ´div´
13:47:33 <dschoepe> revenantphx: you can also write it as splitOn <$> pure ":" <*> getResponseBody rq
13:47:44 <Cale> Well, to start with, return ":" always produces the same result
13:47:50 <revenantphx> That's the same thing with allicatives.
13:47:52 <revenantphx> Cale: and?
13:47:55 <ndrsndrs> revenantphx: there's also liftM (splitOn ":") (getResponseBody arg)
13:48:00 <Cale> sid <- liftM (splitOn ":") (getResponseBody rq)
13:48:02 <revenantphx> yeah.
13:48:06 <revenantphx> Thats probably a better option.
13:48:14 <merijn> Johnny_: Oh, duh. You want "y `div` 4 == 0", told you I didn't test it ;)
13:48:18 <benmachine> hmm I seem to have come up with a monoid transformer
13:48:24 <benmachine> ...sort of
13:48:39 <Johnny_> oh what he meant to tell me is "i dont know whats supposed to happen if it turns out positively" ?
13:48:58 <Johnny_> i really have to get a feeling what all these error message really try to tell me, hehe
13:48:59 <Cale> Johnny_: who?
13:49:04 <Johnny_> mr. ghci ;)
13:49:07 <Cale> oh
13:49:48 <merijn> Johnny_: It's trying to tell you that "if expects a boolean", and "y divided by 4" is an integer and integers are not booleans
13:50:13 <Johnny_> ok so the module loaded... now starts the most tense part
13:50:43 <merijn> If it compiled I'm reasonably sure my version works :p
13:50:54 <benmachine> http://hpaste.org/42030/monoid_transformer is this interesting?
13:51:59 <zachk> whats it do 
13:52:08 <revenantphx> how about this
13:52:09 <revenantphx>  sid <- liftM (!! 3) $ liftM (splitOn ":") (getResponseBody rq)
13:52:10 * zachk is interested and can barely understand it 
13:52:14 <revenantphx> see a good wat to simplify it?
13:52:21 <revenantphx> Or rather, increase the legibility.
13:52:24 <benmachine> zachk: I just noticed State can be made a Monoid
13:52:26 <Johnny_> YAY it works!
13:52:35 <Johnny_> working code is here http://hpaste.org/paste/42028/working_module#p42031
13:52:38 <benmachine> wait is this just kleisli composition
13:52:43 <Johnny_> thanks so much to all 
13:52:45 <zachk> arent all monads actually monoids? 
13:52:52 <benmachine> zachk: yes, they are
13:52:54 <blackh> Johnny_: Nice!
13:52:57 <benmachine> I'm not sure they are in this way though
13:53:01 <mauke> @quote monoids
13:53:01 <lambdabot> stepcut says: I wish someone had told the designers of XML about monoids :(
13:53:07 <benmachine> zachk: actually, wait, sort of
13:53:07 <Botje> revenantphx: ((!! 3) . splitOn ":") `liftM` getResponseBody rq
13:53:17 <revenantphx> ah :D
13:53:23 <merijn> Botje: That hardly improves legibility :p
13:53:28 <benmachine> zachk: if m is a monad, then (a -> m a) is a Monoid
13:53:30 <revenantphx> It does to me.
13:53:31 <revenantphx> >_<
13:53:36 <benmachine> zachk: and a -> m b is sort of monoidal
13:53:40 <Botje> merijn: it does if you let fourth = (!!3) :p
13:53:44 <blackh> Johnny_: Should be < 1, not < 0
13:53:45 <revenantphx> well, the liftM doesn't need to be up front.
13:53:58 <benmachine> oh, and m () is a monoid too
13:54:04 <benmachine> but a less interesting one
13:54:07 <merijn> My bad :p
13:54:10 <revenantphx> liftM ((!! 3) . splitOn ":") $ getReponseBody rq
13:54:12 <revenantphx> looks better to me
13:54:29 <mauke> <$>
13:54:40 <merijn> I was thinking "d > 0" instead of "d < 0" so I screwed up the logic
13:55:04 <mauke> (!! 3) . splitOn ":" . getResponseBody $ rq
13:55:17 <merijn> Anyhoo, bed time
13:55:24 <blackh> revenantphx: (!! 3) . splitOn ":" `fmap` getResponseBody rq
13:55:29 <zachk> @pl (!!3) . splitOn ":" . getResponseBody $ rq 
13:55:30 <lambdabot> splitOn ":" (getResponseBody rq) !! 3
13:55:47 <djahandarie> A monad is only a monoid in the category of endofunctors I think. I don't think you can generalize all monads to monoids in any other way
13:55:55 <revenantphx> what
13:55:57 <revenantphx> amity.hs:57:42: Not in scope: `getReponseBody'
13:55:58 <djahandarie> At least it isn't clear to me
13:56:00 <zachk> whoa pl actually simplified something for a change 
13:56:01 <revenantphx> what.
13:56:04 <revenantphx> for
13:56:05 <revenantphx>     sid <- liftM ((!! 3) . splitOn ":") $ getReponseBody rq
13:56:12 <revenantphx> No it IS in scope, it just was.
13:56:18 <benmachine> djahandarie: do you mean Monoids or monoids?
13:56:21 <tromp_> what's the easiest way to evaluate an expression for at most 1 sec?
13:56:25 <djahandarie> revenantphx, you spelt response wrong
13:56:32 <Twey> Heh
13:56:33 <mauke> zachk: it also broke it
13:56:38 <ajnsit> I'm getting the following error when running bootstrap.sh for cabal-install - Setup: At least the following dependencies are missing:
13:56:38 <ajnsit> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
13:56:39 <djahandarie> benmachine, monoids
13:56:41 <zachk> really?
13:56:55 <ajnsit> what could possible be the problem?
13:57:05 <djahandarie> benmachine, I'm pretty sure a Monoid is only for monoids in Hask 
13:57:26 <djahandarie> In which case I don't think you can define a Monoid at all for all Monads
13:57:52 <blackh> ajnsit: That doesn't look normal.
13:57:56 <benmachine> you can define instance Monad m => Monoid (m ())
13:58:03 <benmachine> (with flexible instances)
13:58:24 <benmachine> you can also define instance Monad m => Monoid (a -> m a), with suitable newtype wrappers
13:58:29 <ajnsit> blackh, I have base and filepath installed
13:58:36 <djahandarie> I mean for m a
13:58:36 <blackh> tromp_: What do you mean?
13:58:58 <benmachine> djahandarie: ok but kleisli arrows are sort of monoidy
13:58:58 <blackh> ajnsit: I think something is screwed up with your ghc installation. Maybe cabal can't find ghc, or maybe you've got an ancient version installed.
13:59:18 <benmachine> djahandarie: and having kleisli composition is equivalent to having bind
13:59:25 <tromp_> seems my issue came up alrd at http://stackoverflow.com/questions/930595/concurrent-haskell-actions-with-timeout
13:59:31 <benmachine> :t (id <=<)
13:59:32 <lambdabot> forall (m :: * -> *) c a. (Monad m) => (a -> m (m c)) -> a -> m c
13:59:36 <benmachine> wups
13:59:40 <benmachine> :t (<=< id)
13:59:41 <lambdabot> forall b (m :: * -> *) c. (Monad m) => (b -> m c) -> m b -> m c
13:59:45 <benmachine> there we go
14:00:13 <ajnsit> blackh, well I just built my ghc executable and I'm using that to bootstrap cabal-install. There is no other GHC on the system
14:00:29 <mauke>  base >=4 && <3
14:00:56 <ajnsit> mauke, yeah that looks problematic
14:01:06 <monochrom> eh? that's a contradiction :)
14:02:14 <ajnsit> Here's what I see in Cabal.cabal - Library
14:02:15 <ajnsit>   build-depends:   base       >= 1   && < 5,
14:02:15 <ajnsit>                    filepath   >= 1   && < 1.2
14:02:15 <ajnsit>   if flag(base4) { build-depends: base >= 4 } else { build-depends: base < 4 }
14:02:15 <ajnsit>   if flag(base3) { build-depends: base >= 3 } else { build-depends: base < 3 }
14:02:34 <ajnsit> so looks like the flags are messed up
14:02:50 <monochrom> they are fine.
14:03:54 <ajnsit> monochrom, well I guess the Cabal file is fine but somehow the system is trying to satisfy all the conditions
14:06:21 <monochrom> ghc 6.12.3?
14:06:47 <Vaevictus> hey guys ... i'm not even slightly educated about haskell... but i was told that all variables are immutable... what's the proper way to handle a situation like this: 1. call url for a bit of data.  2. connect to a server to start a binary conversation 3.) after several packets are sent back and forth (question/response) send some of the initial url data
14:07:27 <Vaevictus> i.e. 1.) fetch data A 2.) do stuff until a particular message 3.) return data A again
14:08:11 <benmachine> does anyone know anything about using foreign import with functions declared with 'inline'?
14:08:13 <djahandarie> Vaevictus, there are special functions to work with I/O (network, files, mutation, etc.)
14:08:43 <Vaevictus> djahandarie: my question is "how do you pass data returned from one message to another one that's wholly removed from the first one?
14:08:59 <Vaevictus> i know i'm not communicating well :D
14:09:00 <monochrom> 1. most haskell implementations provide mutable variables. 2. even without user-usable mutable variables, you can still do I/O to fetch data, process, report.
14:09:00 <Cale> Vaevictus: parameter passing?
14:09:07 <Vaevictus> Cale: can't.  
14:09:10 <Cale> Vaevictus: hm?
14:09:22 <Vaevictus> well... where do i pass it? 
14:09:27 <Vaevictus> i mean.
14:09:47 <Cale> To the function which produces the action for handling the next bit of the conversation
14:09:54 <Vaevictus> i receive packets... i send packets ... do i pass along that one parameter to *ALL* network calls just for one piece of info for one packet?
14:10:09 <Vaevictus> hmm
14:10:17 <benmachine> Vaevictus: you pass it where it is needed
14:10:24 <benmachine> if it is needed everywhere you pass it everywhere
14:10:32 <benmachine> but usually you'll have things separated
14:11:35 <micahjohnston> for the Applicative typeclass, do <* and *> come for free, or do you have to implement them yourself?
14:11:36 <monochrom> See http://hpaste.org/42033/http_client_example for an http fetch example. No mutable variables, at least not any I use directly.
14:11:50 <Vaevictus> benmachine: i think i may have a clue
14:11:51 <benmachine> micahjohnston: they come for free
14:12:09 <micahjohnston> @source (*>)
14:12:09 <lambdabot> (*>) not available
14:12:15 <benmachine> micahjohnston: but you can implement them yourself, because sometimes the fastest way is not the default
14:12:17 <blackh> Vaevictus: I encourage you to take a look at Haskell - it really is an excellent language.
14:12:25 <Vaevictus> blackh: it's on my list :D 
14:12:36 <benmachine> :t \x y -> const <$> x <*> y
14:12:37 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f a
14:12:43 <Vaevictus> i'm not sure i subscribe to some of its tenants and insinuations :D
14:12:46 <blackh> Vaevictus: People here love answering questions about it.
14:12:50 <benmachine> :t \x y -> const id <$> x <*> y
14:12:51 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a1 -> f a -> f a
14:12:54 <micahjohnston> benmachine: aha, thanks
14:13:03 <Vaevictus> that, and it appears that a lot of haskell users write syntax i don't like :D
14:13:18 <blackh> Vaevictus: The syntax is one of the best things about Haskell
14:13:29 <monochrom> You will save yourself a lot of time by ignoring syntax.
14:13:33 <benmachine> the other best things about haskell are its semantics, and implementations
14:13:35 <Vaevictus> aesthetically, i don't like to read python-style syntax ... and i know haskell doesn't care :D
14:13:37 <monochrom> or rather, by being oblivious to syntax.
14:13:51 <benmachine> and libraries
14:13:52 <Vaevictus> but that still means my help would be in that style :D
14:13:53 <benmachine> and community
14:13:54 <monochrom> Small minds debate over mere syntax.
14:13:57 <dancor> "base-4.0.0.0 was excluded because of the top level dependency base -any"  does this make any sense?
14:14:00 <Vaevictus> monochrom: i'm not debating
14:14:08 <monochrom> I know.
14:14:09 <Vaevictus> monochrom: i'm saying that it's my aethetics :D
14:14:11 <tromp_> hmm; just got a internal error: schedule: invalid what_next field
14:14:18 <Cale> Vaevictus: I/O in Haskell is handled by encoding I/O stuff to be done as values of a particular type. Evaluation of those values does nothing visible, but there's a separate notion of execution which actually carries them out. In a compiled program, only the action called main actually gets run (but in turn it'll be built up from simpler actions)
14:14:24 <blackh> I think syntax is important, since you have to type an awful lot o fit.
14:14:36 <monochrom> Then you will save yourself a lot of time by discarding any aesthetics.
14:14:49 <Vaevictus> Cale: in the situation i'm working with, it's a Control.Monad.BinaryProtocol
14:14:50 <benmachine> syntax is important sometimes
14:15:03 <blackh> Vaevictus: Haskell completely separates the idea of evaluation from the idea of execution (of I/O), and this is extremely valuable.
14:15:15 <Vaevictus> Cale: so, i suppose i've got to pass the data to the creation of that binaryprotocol
14:15:30 <Cale> Yeah
14:15:54 <Cale> The BinaryProtocol a actions are really just thin wrappers around IO actions anyway.
14:16:02 <mm_freak> is there a somewhat good library for image processing?  i need to apply some transformations to thousands of pictures
14:16:17 <mm_freak> more specifically i need to add a banner to them
14:16:47 <Vaevictus> Cale: well... basically, my friend has written a tcp client for a special protocol, and needs to augment the protocol with a bit of data snagged from simpleHTTP
14:16:49 <Botje> mm_freak: imagemagick is nice
14:17:03 <mm_freak> Botje: a haskell library, obviously
14:17:11 <Botje> doesn't it have bindings?
14:17:11 <mm_freak> otherwise i wouldn't ask here =)
14:17:12 <Vaevictus> mm_freak: imagemagick, afterimage, gd, gimpfu
14:17:17 <monochrom> I am recently learning gtk2hs and it is my instinctive suggestion :)
14:17:19 <mm_freak> Botje: can't find any
14:17:26 <Botje> boo :(
14:17:55 <mm_freak> oh, there are gd bindings
14:17:58 <mm_freak> Vaevictus: thanks
14:18:23 <Vaevictus> i'm not 100% sure gd will do it, it's been ages since i messed with that
14:18:31 <blackh> Vaevictus: You would pass the data 'through' the protocol, and have the protocol pull the bits out it needs.  It all depends on the details.
14:18:47 * hackagebot fclabels 0.11.0 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-0.11.0 (SebastiaanVisser)
14:19:07 <ndrsndrs> dancor: cabal-install selects base-3.* for base -any, since lots of old things require base 3 but don't say so
14:19:11 <mm_freak> Vaevictus: gd itself can do it, i just hope, its haskell binding can do it, too
14:19:27 <Vaevictus> blackh: that completely goes over my head.
14:19:36 <Vaevictus> or around it :D
14:19:45 <ndrsndrs> or at least, it did; maybe not now
14:20:13 <blackh> Vaevictus: Well, your data from simpleHttp would be represented as some sort of data structure, and you would just pass that to your code to talk to the protocol...
14:20:23 <blackh> and when it needs to send something from that data, it just pulls out the bit of it that it needs.
14:20:23 <mm_freak> hmm, haskell gd can't do it
14:20:30 <mm_freak> no haskell library i'm afraid =/
14:20:34 <dancor> ndrsndrs: can i disable that Feature
14:20:35 <mm_freak> unless i write one myself
14:20:42 <blackh> Vaevictus: If you need to iterate over a list, you would use forM_ or mapM_.
14:20:56 <Vaevictus> mm_freak: use imagemagick.  if it doesn't have a lib, you can do it from the commandline, i'm almost certain, assuming a decent OS
14:21:04 <ndrsndrs> dancor: dunno. try --constraint 'base == 4.*'
14:21:16 <ndrsndrs> if not, you might find yourself editing cabal files
14:21:19 <dancor> ndrsndrs: no dice
14:21:19 <mm_freak> Vaevictus: yes, i can do it, but it's not well documented
14:21:23 <Vaevictus> blackh: simpleHTTP's payload would be a string with 4 colon separated fields, one of which is important
14:21:40 <blackh> Vaevictus: This sounds familiar. :)
14:21:51 <dancor> i think i'll find myself editing cabal-install
14:22:21 * dancor undertakes spiritual journey
14:22:23 <ndrsndrs> most things should have changed to 'base >= 3 && < 5', which correctly picks 4; i don't know how many things haven't yet though
14:22:34 <Vaevictus> blackh: lol ... as long as your familiarity doesn't involve big blocks and pickaxes, we should be okay
14:23:04 <Vaevictus> blackh: oh ... looky there, revenantphx ... lol
14:23:20 <Vaevictus> small planet, don't know why i'm suprised
14:23:27 <Vaevictus> blackh: yeah, rev's my friend
14:23:31 <Vaevictus> dunno what he asked :D
14:23:55 <blackh> Vaevictus: Well, certainly, the immutability isn't a problem - just pass the data blob across.
14:26:37 <monochrom> mutable variable is the most boring, dispensible aspect of imperative programming
14:26:38 <Vaevictus> mm_freak: http://www.imagemagick.org/Usage/compose/
14:27:19 <dancor> monochrom: and what are the most interesting least dispensable parts?
14:27:27 <monochrom> I/O for example
14:28:24 <mm_freak> Vaevictus: thanks
14:30:21 <Vaevictus> blackh: well... that solves this problem i think, which is fetch ; process protocol; send data...  but what if the fetch is in response to a protocol packet, and the send is a response to a different packet?
14:31:32 <blackh> Vaevictus: talk valueFromSimpleHTTP = do { send "x" ; x <- recv ; send valueFromSimpleHttp }
14:32:00 <blackh> Vaevictus: Does your protocol handler use callbacks?  In that case, you'd have to do it differently.
14:32:43 <Vaevictus> blackh - his doesn't appear to yet
14:32:57 <blackh> Vaevictus: Callbacks are not a very Haskelly way to implement a communications protocol.
14:32:58 <Vaevictus> but it seems necessary considering there's 50 packets or something
14:33:17 <blackh> But callbacks can be converted to a flow of control easily using Chan
14:34:12 <Vaevictus> Chan ?
14:34:33 <monochrom> yeah, use several threads, have thread-local state, transform thread-local state to tail calls and parameter passing.
14:34:38 <blackh> Vaevictus: It's a channel for talking between threads
14:34:48 <blackh> Vaevictus: Threads are a good thing in Haskell.
14:35:24 <dancor> will cabal-install ever be made to allow more than one version of a package (other than base)?
14:35:55 <dancor> in its constraint solver
14:36:00 <monochrom> the self-inflicted constraint of (single-threaded architecture using event loop) is a reason why you think you need mutable variables. eliminate that, and you won't need.
14:36:33 <dancor> for example, currently i've run across a number of packages that cabal install won't build but if i cabal install the dependencies and then the package it works
14:37:04 <dancor> is this a defect in cabal-install, in the packages, or hat
14:37:06 <dancor> What
14:37:39 <Vaevictus> definately a defect in hat
14:37:52 <Vaevictus> are you using a bowler? :D
14:38:06 <dancor> i've often felt that a better haskell tracer would help solve many problems faster
14:40:05 <monochrom> the cabal-install constraint solve is itself under many near-impossible constraints. polynomial-time, conservative, backward-compatible with a historical transition, automatic, ...
14:40:24 <dancor> life is hard, i kno
14:40:49 <dancor> pacman et al seem to do alright
14:41:16 <monochrom> the polynomial-time part is particularly crippling. it implies non-optimal solutions.
14:42:22 <monochrom> what exact problem does pacman solve? I wildly guess that it solves a trivial problem.
14:42:31 <dancor> idk
14:42:45 <ndrsndrs> dancor: pacman and things only have one (or few) version(s) of a package, which are only updated when someone has checked it works with the versions of everything else.
14:43:42 <monochrom> versioning on hackage is chaotic. I don't feel that any linux distro's versioning policy is anything near 1/10 as hard
14:44:22 <tg_> monochrom: careful there. Some haskell geek might try and impose that versioning actually *be* mathematically chatoic, and then we're all doomed
14:44:29 <monochrom> and yeah, every linux distro enjoys centralized big-brother control. all problems are solved by humans already.
14:44:29 <tg_> chaotic* even
14:45:17 <Saizan> augur: no blog
14:45:37 <augur> Saizan: lame. well, im going to thank you as just Saizan, then
14:45:46 <dancor> things are still much better in arch with the community repo
14:45:49 <monochrom> if you study comp sci long enough, you find that every problem (except single-point-of-failure) is solved by centralized big brother.
14:45:52 <dancor> err the aur/ repo
14:46:13 <monochrom> (well, single point of failure and inefficiency)
14:46:19 <tg_> that's akin to saying, every problem can be solved by somebody else, first
14:46:29 <Saizan> augur: ok :)
14:46:46 <dancor> i don't see how you can argue that archlinux + aur is vastly different from cabal-install + hackage
14:47:17 <Saizan> for haskell packages the main difference is that pacman has uninstall
14:47:34 <augur> Saizan: any preferred appendages? like, 'from #haskell on irc.freenode.net' or some such?
14:48:14 <Vaevictus> well anyway... i think i grok the ideas involved here.  we'll see if i can express them :D
14:48:19 <Vaevictus> thanks for your time, guys. :D\
14:48:32 <Saizan> augur: that one is fine
14:48:50 <monochrom> do you routinely ask pacman to let you have all three of firefox-3.0.1, firefox-3.0.2, firefox-3.1.2 installed together?
14:49:16 <monochrom> that would be equivalent to one problem ghc+cabal needs to cope with
14:49:16 <unkanon> I have a wil idea for solving the problem of package managers and dependencies: don't allow dependencies. if your package uses package X version Y then you need to include that inside your package
14:49:18 <dancor> i used to ask that of emerge
14:49:22 <unkanon> s/wild/wild/
14:49:24 <unkanon> s/wil/wild/
14:50:21 <monochrom> did emerge do better than cabal-install?
14:50:24 <dancor> yes
14:50:42 <monochrom> could you tell me more? I have never used them.
14:50:51 <tg_> emerge is a package builder and manager
14:50:53 <unkanon> mm_freak: hey I'm currently going through your tutorial
14:50:58 <unkanon> mm_freak: thanks for that :)
14:51:34 <monochrom> tell me some crazy thing that emerge can do and cabal-install purports to do
14:51:55 <mm_freak> unkanon: which one?  monads?
14:52:08 <unkanon> mm_freak: yes monads (sorry I didn't know you had more than one)
14:52:12 <dancor> is there a consensus on best-practice for package constraints -- should you do: A) >= 1.5  B) >= 1.5 && < 1.6  C) >= 1.5 && < 2
14:52:22 <mm_freak> unkanon: i don't, just wanted to make sure =)
14:52:47 <mm_freak> unkanon: you're welcome, but when you're done with it, read a tutorial about applicative functors, because my tutorial doesn't cover that
14:52:51 <unkanon> mm_freak: I'm having trouble understanding the State monad even though I already understand IO. the state monad looks a bit like a difference list so far to me
14:52:56 <blackh> dancor: B is the best practice, because that rules out API changes (according to the hackage versioning policy).
14:52:56 <monochrom> the consensus seesm to be never A, and choose between B and C depending on your risk assessment
14:53:07 <unkanon> mm_freak: cool, I will
14:53:09 <mm_freak> unkanon: look at how the state monad is defined
14:53:13 <monochrom> but most likely you want B normally
14:53:26 <mtnviewmark> @dancor: I do (C)
14:53:27 <lambdabot> Unknown command, try @list
14:53:32 <mm_freak> unkanon: newtype State s a = State (s -> (a,s))
14:54:01 <mm_freak> unkanon: a value of type 'State s a' is a state transformer, a function, which takes a state and returns a result as well as a new state
14:54:08 <monochrom> transition 1.5->1.6 means "some functions deleted" so it is highly likely incompatible.
14:54:09 <ndrsndrs> dancor: B (but it can be abbreviated to 1.5.*)
14:54:31 <blackh> dancor: I used to use A, but it got me into trouble. It's probably sensible for really pre-alpha stuff that you're not intending to maintain much.
14:54:32 <ndrsndrs> i think this is what the PVP says to do, as well
14:54:41 <unkanon> mm_freak: yes, but I don't see the use of the state monad I guess
14:54:44 <dancor> blackh: surely you can expect API possible changes for 0.4 vs 0.5?  and so many important packages are 0.*
14:54:49 <ndrsndrs> (not that you can count on people using it for their version numbers anyway, i suppose)
14:54:57 <unkanon> mm_freak: there's no real state going on
14:55:09 <mtnviewmark> though I think (B) is also popular
14:55:17 <mtnviewmark> and matches the versioning policy, now that I reread it
14:55:18 <dancor> blackh: oh nm
14:55:19 <blackh> dancor: Yes - API changes are allowed when the second point changes (hackage versioning policy)
14:55:20 <mm_freak> unkanon: i didn't find state monads themselves very useful so far (other than for parsing), but state monad transformers are very useful
14:55:25 <mtnviewmark> http://haskell.org/haskellwiki/Package_versioning_policy
14:55:35 <pkrumins> haskell.org down
14:55:41 <unkanon> mm_freak: is Parsec written in terms of State ?
14:55:43 <mm_freak> unkanon: there is state going on, just no mutable variables
14:55:44 <pkrumins> my bad it's up
14:55:47 <benmachine> unkanon: no
14:55:48 <monochrom> haha
14:55:54 <mm_freak> unkanon: no, Parsec is more clever
14:56:14 <benmachine> unkanon: in principle it could be, but it isn't for performance reasons
14:56:17 <unkanon> mm_freak: I thought State == mutation
14:56:24 <benmachine> nope
14:56:29 <unkanon> benmachine: does Parsec cheat or something?
14:56:33 <monochrom> State == function
14:56:41 <c_wraith> State = s -> (a, s)
14:56:45 <c_wraith> give or take :)
14:56:56 <benmachine> unkanon: parsec doesn't cheat, no, it just uses ingenuity
14:57:07 <benmachine> a.k.a. continuations
14:57:12 <unkanon> I'll look at Parsec later when I understand things more
14:57:16 <unkanon> oh continuations, I know those
14:57:17 <mm_freak> unkanon: state is just, well, state
14:57:25 <mm_freak> unkanon: some environment, which can change
14:57:29 <monochrom> well stated
14:57:34 <unkanon> lol
14:57:45 <mm_freak> unkanon: state doesn't tell you how the state is represented and how it is changed…  it's just an environment
14:58:09 <mm_freak> unkanon: mutable variables are another kind of state, and state monads don't even model them
14:58:21 <mm_freak> unkanon: state monads just get rid of explicit parameter passing
14:58:23 <unkanon> mm_freak: one of the basic things I fail to see in the getRandom function implemented with State is, where does the first state comes from?
14:58:33 <benmachine> unkanon: you give it to the runState function
14:58:45 <mm_freak> unkanon: from outside of the monadic computation, e.g. from runState
14:58:56 <unkanon> oh...
14:59:04 <monochrom> You could in your main get a good seed from the outside world
14:59:07 <unkanon> but then that didn't save much trouble
14:59:24 <benmachine> sure it did
14:59:35 <unkanon> well a bit
14:59:49 <unkanon> because I can do getRandom + getRandom to add 2 together
14:59:53 <monochrom> it saves N occurrences of the word "IO"
15:00:03 <monochrom> I mean N-1
15:00:04 <dancor> well if you really want that level of safety (and constant trivial dependency changes as new versions of packages come out), maybe cabal-install needs a non-polynomial algorithm
15:00:08 <unkanon> but it's still not like a global variable in an imperative language
15:00:15 <unkanon> is that what the Environment monad is for?
15:00:23 <mm_freak> unkanon: the advantage is that you get rid of explicit state passing
15:01:00 <mm_freak> unkanon: let's say you have some large bunch of code, which doesn't use a state anywhere but in a very deeply nested function
15:01:06 <unkanon> hmm. it hasn't sunk in yet :)
15:01:21 <mm_freak> this is one example, where state monads are useful
15:01:49 <mm_freak> but as said, i haven't found many uses for State yet, but a lot of uses for StateT
15:01:49 <monochrom> you should write different code using different approaches and compare
15:02:01 <unkanon> yeah that's what I'll do
15:02:13 <unkanon> maybe try and adapt an imperative code to use State
15:02:45 <monochrom> you stare at actual code and you can immediately tell which one is elegant, hassleless...
15:03:05 <monochrom> this can't be done by millions of hours of essay-type "discussions"
15:03:15 <unkanon> just one last question before I head home
15:03:38 <unkanon> is State (like the State that is defined by s -> (s,a)) usedin real world code?
15:04:02 <unkanon> like mm_freak is saying, he hasn't found a use for it except for parsing
15:04:09 <c_wraith> well, StateT is.  and it's almost the same
15:04:24 <c_wraith> @unmtl StateT Int IO a
15:04:24 <lambdabot> Int -> IO (a, Int)
15:04:28 <monochrom> yeah go for StateT directly
15:04:36 <c_wraith> @unmtl StateT s m a
15:04:36 <lambdabot> s -> m (a, s)
15:04:46 <mm_freak> unkanon: i wouldn't parse using State…  there are better approaches
15:04:47 <adnap_> hey, out of curiosity i was wondering: for those of you who work, do you ever get to mess around with haskell at work?
15:05:00 <monochrom> you may like to look for it in xmonad. I don't know whether xmonad uses it. I know xmonad uses ReaderT
15:05:04 <mm_freak> adnap_: i do sometimes
15:05:07 <c_wraith> adnap_: daily.  and my company is hiring. :)
15:05:19 <unkanon> ok cool
15:05:21 <adnap_> do any of you actually write haskell for your work?
15:05:21 <mm_freak> adnap_: but mostly i'm forced to use PHP, but in some cases i can get at least haxe
15:05:38 <mm_freak> haskell i use only locally as a tool
15:05:44 <unkanon> c_wraith: you serious?
15:05:52 <mm_freak> but i may be writing a commercial site soon using yesod and haxe
15:05:55 <c_wraith> unkanon, yes.
15:06:04 <mm_freak> yesod is a great web framework in haskell
15:06:07 <dancor> (the current hackage versioning guidelines) and (cabal-install's current polynomial algorithm) require (package-developers-frequently-and-rapidly-making-trivial-updates)
15:06:17 <mm_freak> and haxe i would use for javascript and flash
15:06:18 <adnap_> mm_freak: i would like to play around with the web dev tools available in haskell too, but i'm currently interested in graphics and gpipe!
15:06:18 <unkanon> c_wraith: now say you're based in new york city, pretty please :)
15:06:27 <c_wraith> No, pdx. :)
15:06:50 <adnap_> c_wraith: so, do you mean to imply that you do haskell for your work, or that you simply play around with it daily?
15:06:58 <mm_freak> adnap_: image processing isn't so great in haskell (lack of libraries), but writing opengl apps is fun and easy =)
15:06:59 <mtnviewmark> you guys are hiring now? man.... you weren't when I was looking earlier in the summer... ah well...
15:07:05 <c_wraith> adnap_: work in it.
15:07:15 <adnap_> c_wraith: whoa, that's cool
15:07:23 <unkanon> aww
15:07:52 <c_wraith> eh.  At some level, business software boils down to "implement these convoluted business rules", which is tedious no matter what the language.
15:07:55 <adnap_> i was thinking i might not even get a programming job just so i don't get burnt out writting shitty dot net stuff or whatever.  then i can do haskell in my free time
15:08:11 <c_wraith> Still, at least it's *safer* in haskell!
15:08:16 <adnap_> but i would be so psyched to do a haskell job!
15:08:20 <unkanon> c_wraith: we need a business-oriented programming language
15:08:34 <unkanon> a purely businessy language :)
15:08:37 <monochrom> blessed are those who do merely the GUI part or the DB part of enterprise software :)
15:08:44 <c_wraith> unkanon, didn't cobol try that?
15:08:46 <adnap_> unkanon: wouldn't that be one of the many languages out there?
15:09:01 <adnap_> unkanon: java maybe?
15:09:02 <sproingie> BPEL
15:09:08 <unkanon> java, yes perhaps lol
15:09:12 <adnap_> what's a business language anyway?
15:09:23 <mtnviewmark> hmmm... a COmmon, Business Oriented Langauge....
15:09:30 <unkanon> one that uses business buzzwords for keywords 
15:09:33 <adnap_> haskell is a business language!  it takes care of business :)
15:09:38 <sproingie> adnap_: one of those mythical beasts wherein you can express all the complex logic of business processes "without writing code"
15:09:50 <mtnviewmark> Functional COBOL!!!!!
15:09:50 <adnap_> i don't even know what business logic is
15:09:58 <unkanon> mm_freak: the horro!
15:10:00 <unkanon> horror/
15:10:01 <adnap_> i live an an ideal world of my own creation
15:10:13 <adnap_> i'm not jaded yet
15:10:19 <mm_freak> unkanon: what?
15:10:23 <Kaidelong> I put a dependency for GHood in my cabal file but when I try "runhaskell Setup.lhs --build" it complains that GHood isn't installed (it is)
15:10:30 <unkanon> mm_freak: what?
15:10:30 <sproingie> "process X starts when user submits ticket, approval goes to Y, notification goes to Z, if escalation occurs within ABC then route to blahblah gromish gromish gromish..."
15:10:33 <Kaidelong> err
15:10:37 <Kaidelong> --configure, not --build
15:10:38 <sproingie> that's business logic
15:10:42 <unkanon> gromish ? lol
15:10:44 <mm_freak> unkanon: what's the horror?  PHP?  yes ;)
15:10:45 <sproingie> it makes program logic look sane
15:10:51 <unkanon> mm_freak: oh, functional cobol!
15:10:51 <jon_of_arc> SYNERGIZE COBOL WITH CORE COMPETENCIES GIVING COBOL
15:10:59 <adnap_> c_wraith: do you find yourself learning new stuff in haskell while at work, or do you get stuck doing similar things?
15:11:00 <unkanon> jon_of_arc: yes, those buzzwords
15:11:01 <sproingie> jon_of_arc: .
15:11:09 <Kaidelong> configure
15:11:24 <alpounet> would you guys have a good use case to demonstrate the power of laziness for graph algorithms ?
15:11:30 <sproingie> basically business logic == workflow engines 
15:11:31 <c_wraith> business logic is best described as "a set of rules and procedures things must follow for business reasons rather than technical reasons"
15:11:36 <adnap_> oh my gosh lets talk about graph problems
15:11:43 <adnap_> i've been thinking about that lately
15:11:53 <mm_freak> unkanon: cobol is worse…  PHP at least has some of the modern control constructs…  but what's really stupid is that the libraries don't use them consistently
15:12:02 <adnap_> graphs seem really hard in functional languages
15:12:07 <mm_freak> for example lots of functions return false instead of throwing an exception
15:12:14 <mtnviewmark> LET ADDONE BE APPLY PLUS TO 1
15:12:15 <c_wraith> adnap_, I learn a fair amount.  And I'm a contributor to the Snap project simply because we needed an HTTP engine, it was close to what we needed, and I felt like giving them back all the changes I made :)
15:12:17 <mm_freak> this is especially painful
15:12:18 <dancor> adnap_: i guess they are harder than trees..
15:12:19 <sproingie> cobol was designed so auditors could have a hope of reading the code and not specs and the code
15:12:36 <adnap_> c_wraith: cool
15:12:49 <dancor> adnap_: but you can still express them inductively..
15:13:05 <mtnviewmark> actually, sproingie - that's not true....
15:13:15 <adnap_> i'm about to have to implement a data structue that has been described with a bunch of pointers.  i think i might just do everything in an array, since i have a deadline (for school)
15:13:20 <mtnviewmark> ...but an amusing thought, nonetheless
15:13:35 <adnap_> has anyone ever heard of the winged-edge data structure?
15:13:54 <sproingie> adnap_: quiet now winged-edge data structures spook easy.  crikey!
15:14:07 <adnap_> sproingie: i have no idea what you just said
15:14:27 <sproingie> lame steve irwin joke
15:14:40 <monochrom> o hai can you do winged-edge data structures in cobol? oops wrong channel.
15:14:40 <adnap_> oh
15:14:44 <adnap_> now i get it
15:15:08 <adnap_> it's still not funny :P
15:15:23 <sproingie> i joke because it staves off the stabbies
15:15:27 <adnap_> neither is this blog post that my friend sent me about haskell.  did anyone see that?
15:15:37 <adnap_> something about people giving a shit about haskell
15:15:37 <monochrom> the yegge one?
15:15:41 <monochrom> yes
15:15:57 <adnap_> omg haskell so hard lol monads!
15:16:05 <monochrom> I still haven't read it.
15:16:08 <sproingie> yay success avoided
15:16:12 <adnap_> it's dumb
15:16:29 <jon_of_arc> adnap_: it's funnier with the contextual knowledge that it's most likely tongue-in-cheek (Yegge has spoken favourably about Haskell in the past, IIRC)
15:16:50 <adnap_> jon_of_arc: contextual knowledge about the author?
15:16:53 <monochrom> three things I'm glad I never read: lex, yacc, yegge
15:16:56 <mm_freak> adnap_: there is a lot of dumb stuff about haskell on the net
15:17:00 <kfish> heh
15:17:03 <ion> I loved this part: ‘The Perl lists are brimming with discussions about the value of adding monads to Perl. "We don't really know what they do, but it doesn't make sense _not_ to have something in Perl," said Perl hacker Landon Ricketts.’
15:17:03 <mm_freak> adnap_: just ignore it
15:17:36 <adnap_> ion: that sounded very matter of fact to me.
15:17:43 <jon_of_arc> adnap_: yes, or at least his previous blog posts.
15:17:47 <adnap_> ion: like, i wouldn't be surprised if perl did that
15:18:10 <alpounet> i believe this post is just ironic
15:18:13 <sproingie> that post of yegge's is very meta
15:18:22 <monochrom> I see. Interesting.
15:18:26 <sproingie> it's also less than 30 paragraphs long.  what happened to him?
15:18:40 <dancor> adnap_: http://www.mail-archive.com/haskell-cafe@haskell.org/msg41019.html
15:18:52 <ion> Well, Perl “has monads” just as any other language with lambdas as first-class objects, it just doesn’t have syntactic sugar for them. :-P
15:18:54 <adnap_> dancor: i saw that
15:18:56 <sproingie> that's practically a tweet as yegge goes
15:18:58 <adnap_> dancor: couple days ago
15:19:12 <mee> sproingie: didn't he get some nasty RSI? That might be a factor ;)
15:19:24 <adnap_> dancor: i think i might do something like that
15:19:28 <jon_of_arc> ion: including that link was cruelty. I got as far as the guy who said that monads meant you needed fmap as well as map before my common sense kicked in and I stopped reading.
15:19:37 <sproingie> mee: oh didn't know that
15:19:45 <adnap_> one question i have is
15:20:12 <adnap_> well, it's more of a concern
15:20:20 <adnap_> that data structure looks like it duplicates a lot of info
15:20:55 * dancor wonders about proving winged-edge has no inductive form
15:21:17 <adnap_> dancor: it would be really cool to do it in a functional style
15:21:34 <adnap_> dancor: but that's not the bulk of my project, so i'm not that concerned atm
15:22:03 <ddarius> The syntactic sugar for monads in Haskell is rather light, albeit, it is more necessary in an eager language.
15:22:11 <adnap_> perhaps another topology data structure would be more suited
15:22:30 <adnap_> i need to support euler operators still though
15:23:32 <mee> sproingie: yeah, he got 'Trigger Finger', which sounds pretty horrible: http://steve-yegge.blogspot.com/2010/07/blogger-finger.html
15:26:20 <adnap_> speaking of blogs, there was this one dude that i found really interesting, but i think i bookmarked him on my other computer
15:26:28 <adnap_> all i remember is that he wrote a graphics library
15:27:41 <adnap_> he was talking about making pictures in very abstract terms, giving a very fresh interpretation of graphics rendering
15:28:54 <adnap_> ah, this guy: http://conal.net/blog/
15:31:22 <c_wraith> adnap_, you know he's a regular in here, right? :)
15:32:05 <adnap_> c_wraith: nope
15:32:14 <ddarius> I would say he is at least context free.
15:32:16 <adnap_> c_wraith: what's his name in here?  is it conal?
15:32:22 <c_wraith> yes
15:33:02 <adnap_> c_wraith: hm, maybe i just never noticed.  honestly, i didn't even remember his name when i read his post originally, so i guess it's no surprise.  however, the post was really interesting!
15:34:43 <c_wraith> He's done some really cool mathy stuff, like lub and unamb.  He's also one of the main driving forces behind FRP
15:35:07 <adnap_> c_wraith: yeah, the first thing i read of his was the fran tutorial
15:35:43 <adnap_> c_wraith: that was months before i came across his blog.  even then, i didn't know it was the same guy at first.  i guess this guy just likes a lot of the same stuff as me.
15:36:21 <adnap_> makin' da pictures
15:56:01 <thartman> I got a compile error trying to compile hackage-server : 
15:56:12 <thartman> http://hpaste.org/42034/compile_error_installing_hacka
15:56:14 <thartman> any idea?
15:57:20 <monochrom> you may lack a clib
15:57:51 <thartman> how can I find out which one?
15:58:04 <monochrom> what is hackage-server? I can't find it on hackage.
15:58:25 <thartman> not there.
15:58:48 <thartman> http://code.haskell.org/hackage-server
16:00:51 <monochrom> it's called libgcrypt11-dev on ubuntu
16:01:10 <dancor> if (package A needs B == 1 and C) and (package C needs B == 2), is ok to compile C with B == 2 and then A with C and B == 1?  or will that not always work?
16:02:31 <monochrom> that depends on B-1 and B-2. I can make an example where it is ok. I can make two examples where they conflict and can't be linked together.
16:02:39 <dancor> Saizan: how far did you get with using gecode in cabal-install?
16:02:51 <dancor> monochrom: how would you make them conflict
16:02:52 <monochrom> the two examples involve C code and type classes.
16:03:05 <dancor> good old global instances?
16:03:09 <dancor> or something else
16:03:13 <monochrom> yeah
16:03:56 <monochrom> if B-1 and B-2 both come with C code "int haha(int) { ... }" they can't be linked together. name clash on "haha" at the C level.
16:04:11 <sm> hey there thartman 
16:04:13 <aavogt> cabal install doesn't seems to allow neither, since I don't think it can tell the two situations appart
16:04:20 <dancor> that could always be resolved with namespacing but it would possibly break everything
16:04:20 <monochrom> in fact the ELF level
16:04:40 <monochrom> there is namespacing at the C or ELF level? :)
16:04:46 <thartman> sm howdy
16:04:54 <dancor> no i mean the nature of ffi could be changed!
16:04:56 <dancor> think big
16:04:57 <thartman> monochrom: libgcrypt11-dev is already the newest version. cabal clean and reinstalled, but no dice.
16:05:04 <thartman> thanks anyway though
16:05:21 <dancor> i guess i just don't understand if you are "supposed" to do this
16:05:37 <Saizan> dancor: are you sure it was me?
16:06:05 <dancor> the aggressively tight version constraint guidelines seem to imply that multi-version libs in a multi-step compile are a reality
16:06:31 <dancor> Saizan: i thought you were playing with monadiccp a while back for this purpose..
16:10:21 <thartman> I'll ask matthew gruen, hackage 2.0 is his gsoc project
16:14:17 <monochrom> in hackage-server.cabal, in the "executable hackage-mirror" section, you also need "extra libraries: crypt", just like in the "executable hackage-server" section. At the linker level, you're missing "-lcrypt"
16:15:44 <monochrom> and actually libgcrypt11-dev is probably not needed. crypt is in libc6-dev
16:17:48 <thartman> monochrom: install seems to be getting further...
16:27:39 <thartman> yay. it seems to have worked.
16:28:43 <thartman> I'm patching and sending to matthew gruen
16:30:27 <hpc> wtf: http://hackage.haskell.org/package/hscolour-1.17
16:30:37 <hpc> the debian build of this package isn't a version on hackage
16:36:55 <Saizan> dancor: ah, yeah, got sidetracked by learning constraint logic programming
16:37:44 <revenantphx> :O
16:37:47 <revenantphx> type error~
16:38:12 <revenantphx> https://gist.github.com/gists/726379
16:38:23 <revenantphx> Couldn't match expected type `IO String'
16:38:23 <revenantphx>            against inferred type `Control.Monad.State.Lazy.StateT (Handle, Handle, Data.ByteString.Lazy.Internal.ByteString) IO String'
16:38:44 <revenantphx> (this is within the context of the BinaryProtocol monad)
16:38:48 <aavogt> that's not a valid expression
16:39:27 <aavogt> you can try adding  lift
16:39:35 <Cale> revenantphx: Looks like you missed a liftIO
16:39:44 <Cale> Er, just by the error
16:39:54 <aavogt> maybe I have that backwards
16:40:10 <aavogt> you're putting a StateT action when the block should be IO...
16:40:19 <aavogt> so missing  runStateT
16:41:05 <Cale> I think putStrLnBP is a StateT action
16:41:14 <Cale> (Or BinaryProtocol perhaps)
16:41:17 <revenantphx> putStrLnBP is my own function
16:41:20 <Cale> yeah
16:41:23 <revenantphx> putStrLnBP = liftIO . putStrLn
16:41:33 <revenantphx> I should rename it to liftedPuStrLn
16:41:34 <Cale> So, try putting a liftIO on the getResponseBody
16:41:37 <revenantphx> mmk
16:41:46 <aavogt> that definition runs you into the monomorphism restriction
16:41:46 <Cale> Though, this whole block is lifted now
16:41:50 <revenantphx> Couldn't match expected type `a -> IO a1'
16:41:50 <revenantphx>            against inferred type `IO String'
16:41:51 <revenantphx>     In the second argument of `(.)', namely `getResponseBody rq'
16:42:15 <Cale> You missed a $
16:42:20 <revenantphx> gar
16:42:25 <revenantphx> wait, how should it be?
16:42:31 <aavogt> liftIO (f x)
16:42:38 <aavogt> not (liftIO f x)
16:42:42 <revenantphx> got it.
16:43:47 <revenantphx> working with stacked monads is a bit of a pain.
16:44:05 <revenantphx> Is there any way to lift an entire group of statements?
16:44:09 <djahandarie> You can use newtype deriving to make it less of a pain often
16:44:16 <revenantphx> what do you mena?
16:44:23 <aavogt> I don't think that makes it any less painful
16:44:27 <revenantphx> newtype seems to generally be pretty unpleasant to me.
16:44:35 <revenantphx> It gets rid of any conveniences that previously existed.
16:44:47 <aavogt> revenantphx: you can write     lift $ do a;b;c
16:44:53 <revenantphx> true.
16:44:56 <djahandarie> aavogt, not for what is going on right now, but other things.
16:45:08 <Cale> revenantphx: I never transform the IO monad
16:45:34 <Cale> revenantphx: Monad transformers are useful, but rarely for transforming IO
16:45:51 <djahandarie> Cale, not even ReaderT?
16:46:06 <Cale> Especially not ReaderT :)
16:46:18 <aavogt> it's reasonably popular, ex. happstack and xmonad use tranformed IO
16:46:20 <Cale> Maybe ContT, I would consider, if there were a real need for it.
16:47:48 <revenantphx> Hrm I have an annoying situation now.
16:48:12 <dolio> The problem with transforming IO is that it's so inconvenient. It isn't worth it.
16:48:25 <revenantphx> it's just for printing.
16:48:33 <revenantphx> and that HTTP, which runs in the IO monad.
16:48:41 <revenantphx> Is it an okay solution, when I need to have a mutable package of state.
16:48:53 <dolio> Conceivably ReaderT IO would be convenient, making a parameter implicit. But instead of having one extra parameter, you have to write 'liftIO' on every IO action.
16:48:56 <revenantphx> And I'm running this action forever.
16:49:04 <revenantphx> to pass an STRef as a parameter?
16:49:25 <revenantphx> Basically in lieu of passing a struct with all my state and calling recursively, call it repeatedly with the same STRef
16:49:34 <aavogt> revenantphx: you're in IO though?
16:49:39 <revenantphx> No, I'm in BinaryProtocol
16:49:50 <revenantphx> Which is Reader or State and IO.
16:49:56 <revenantphx> It's stacked a couple deep (at least).
16:50:08 <aavogt> then just use IORef for mutable variables
16:52:27 <bscanzoni> any way to take out the parens in " zip (snd k) $ head d " ?
16:52:53 <revenantphx> I haven't touched IORef yet :\
16:53:10 <revenantphx> type BinaryProtocol = http://hackage.haskell.org/packages/archive/mtl/1.1.1.1/doc/html/Control-Monad-State-Lazy.html#t:StateT (http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/GHC-IO-Handle.html#t:Handle, http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/GHC-IO-Handle.html#t:Handle, http://hackage.haskell.org/packages/archive/bytestring/0.9.1.8/doc/html/Data-ByteString-Lazy.html#t:ByteString
16:53:10 <revenantphx> http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/System-IO.html#t:IO
16:53:12 <revenantphx> feck
16:53:17 <aavogt> snd k `zip` head d -- bscanzoni
16:53:24 <bscanzoni> oh duh
16:53:25 <bscanzoni> thanks man
16:53:29 <revenantphx> type BinaryProtocol = StateT (Handle, Handle, ByteString) IO
16:53:38 <revenantphx> I'm not quite sure what to make of that.
16:54:01 <djahandarie> IORef is easier to use/understand than STRef anyways
16:54:19 <djahandarie> Unless you want to runST of course :)
16:55:03 <hpc> i would make data BinaryConnection = BC {in :: Handle, out :: Handle, buffer :: ByteString}
16:55:10 <hpc> or similar
16:56:07 <Saizan> transforming IO still makes sense when you are implementing a handful of primitives and the rest of the code doesn't even know how your monad stack is implemented
16:56:15 <djahandarie> revenantphx, this is theoretically what MonadIO is for
16:56:21 <revenantphx> djahandarie: explain?
16:57:11 <hpc> MonadIO is entirely capable of being a lifesaver
16:57:14 <aavogt> @google monadmorphio
16:57:14 <lambdabot> No Result Found.
16:57:25 <djahandarie> revenantphx, IO functions are written like (MonadIO m) => Int -> m Int instead of Int -> IO Int
16:57:35 <revenantphx> hm
16:57:41 * hpc manually transformed State, Either, and IO for his website
16:57:44 <djahandarie> revenantphx, and if you make your new type an instance of MonadIO, then you can just use all the IO functions directly on that type
16:58:03 <revenantphx> Ah, I see.
16:58:17 <revenantphx> So could I just instance MonadIO BinaryProtocol 
16:58:28 <revenantphx> Since it's apparently not provided?
16:58:34 <djahandarie> Note that I said "theoretically"
16:58:40 <revenantphx> TT_TT
16:58:41 <djahandarie> You can newtype derive it
16:58:43 <hpc> there has to be a useful instance first
16:58:51 <aavogt> StateT should have the instance
16:58:53 <revenantphx> explain...?
16:59:15 <hpc> oh yes, if it is a type alias for StateT, it is already MonadIO
16:59:38 <hpc> instance MonadIO (StateT s IO) where ...
16:59:48 <hpc> (where liftIO = lift, iirc)
17:00:19 <aavogt>  instance MonadIO m => MonadIO (StateT s m) where liftIO m = lift (liftIO m) = StateT (\ st -> liftM (\x -> (x,st)) (liftIO m)) -- or similar
17:00:25 <aavogt> @src StateT
17:00:25 <lambdabot> Source not found. There are some things that I just don't know.
17:00:34 <aavogt> @unmtl StateT s m a
17:00:34 <lambdabot> s -> m (a, s)
17:01:21 <revenantphx> aavogt: newlines, they are good.
17:01:37 <revenantphx> I'm guessing the newline there goes between lift anf liftIO?
17:01:42 <aavogt> they are also unnecessary for the code
17:02:06 <hpc> aavogt: yeah, that would work nicer than mine
17:02:07 <revenantphx> makes it  a tad confusing, mm
17:02:36 <aavogt> note that I wrote    f = g = h, since you might not know what lift does for that specific type
17:02:43 <revenantphx> instance MonadIO IO where
17:02:43 <revenantphx>     liftIO = id
17:02:44 <revenantphx> No way!
17:02:45 <hpc> and instance MonadIO IO where liftIO = id
17:02:46 <hpc> :P
17:02:52 <revenantphx> aavogt: how are there two =?
17:02:53 <hpc> or i can be ninja'd
17:02:56 <revenantphx> I'm confused by that.
17:03:03 <revenantphx> hpc: yes, yes you can :3
17:03:18 <hpc> revenantphx: what aavogt posted is valid for either of the second two parts
17:03:19 <aavogt> revenantphx: two possible definitions
17:03:27 <revenantphx> oh...
17:03:28 <hpc> he is using mathematical equals, not syntactic equals
17:03:38 <hpc> :P
17:03:39 <revenantphx> The prior looks nicer.
17:03:47 <revenantphx> :|
17:03:54 <aavogt> hpc: not sure there's that much of a difference :)
17:03:56 <hpc> lift . liftIO is a pretty cunning definition
17:04:10 <revenantphx> It is quite clever.
17:04:12 <hpc> aavogt: one is transitive
17:04:50 <aavogt> revenantphx: because it leaves out details... can you say what the types of lift and liftIO are in that case?
17:05:00 <revenantphx> hm no.
17:05:33 <revenantphx> oh hey
17:05:34 <revenantphx>     Duplicate instance declarations:
17:05:34 <revenantphx>       instance (MonadIO m) => MonadIO (StateT s m)
17:05:34 <revenantphx>         -- Defined at amity.hs:29:9-41
17:05:34 <revenantphx>       instance (MonadIO m) => MonadIO (StateT s m)
17:05:35 <revenantphx>         -- Defined in Control.Monad.State.Lazy
17:05:36 <revenantphx> :|
17:06:09 <aavogt> we've already covered that you don't need to write the instance
17:06:29 <aavogt> revenantphx: you can get ghci to tell you types instead:
17:06:49 <revenantphx> aavogt: you're confusing me
17:06:57 <revenantphx> 1) how can I remove the need for liftIO
17:07:00 <revenantphx> 2) why does it work
17:07:03 <revenantphx> In that order.
17:07:49 <aavogt> @type (\a b m -> (lift `asTypeOf` a) ((liftIO `asTypeOf` b) m) :: StateT Int IO String)
17:07:50 <lambdabot> (IO String -> StateT Int IO String) -> (IO String -> IO String) -> IO String -> StateT Int IO String
17:08:07 <aavogt> or:
17:08:34 <aavogt> @type (\m -> (lift `asTypeOf` ?a) ((liftIO `asTypeOf` ?b) m) :: StateT Int IO String) -- now there's no need to remember parameter order
17:08:35 <lambdabot> (?b::IO String -> IO String, ?a::IO String -> StateT Int IO String) => IO String -> StateT Int IO String
17:09:00 <aavogt> @type (\m -> (lift `asTypeOf` ?lift) ((liftIO `asTypeOf` ?liftIO) m) :: StateT Int IO String) -- better names
17:09:01 <lambdabot> (?liftIO::IO String -> IO String, ?lift::IO String -> StateT Int IO String) => IO String -> StateT Int IO String
17:09:06 <revenantphx> question marks???
17:09:12 <revenantphx> You're just confusing me.
17:09:20 <revenantphx> Really.
17:09:45 <aavogt> yes, question marks
17:10:10 <aavogt> do you see how this gets ghc to tell you the types?
17:10:23 <revenantphx> No. Not at all.
17:10:32 <revenantphx> Sadly, you've done nothing but confuse me
17:10:45 <aavogt> how many seconds did you think about it?
17:10:59 <revenantphx> I just don't understand what it's doing, or what you're trying to show me.
17:11:05 <revenantphx> the second part is key there.
17:11:17 <aavogt>  aavogt | revenantphx: you can get ghci to tell you types instead:
17:11:36 <revenantphx> instead of what.
17:11:45 <aavogt> instead of thinking about what they should be
17:11:50 <revenantphx> yes I know this.
17:11:55 <revenantphx> I've done it before.
17:11:59 <revenantphx> What about it TT_TT
17:12:07 <revenantphx> How is this relevant to implementing MonadIO
17:12:16 <freedrull> i dont think this part of my parsing function is doing what i think its doing.... skipMany space; skipMany1 comment <|> skipMany1 eol
17:12:26 <aavogt> it has to do with understanding an implementation of liftIO
17:12:41 <revenantphx> if it does, then please explain why.
17:12:54 <freedrull> this will parse 0 or more spaces, and then if it cannot parse a comment or an eol, the whole function will fail, correct?
17:13:08 <revenantphx> What you're doing is saying "this is an integral, it is vaguely related to rectangles"
17:13:13 <aavogt> you said that you didn't know which instances of MonadTrans and MonadIO were being used
17:13:26 <revenantphx> I don't recall asking that.
17:13:34 <revenantphx> I was asking how to implement it, I got that answer.
17:13:37 <revenantphx> then you asked me something.
17:16:03 <aavogt> revenantphx: which 'it' do you mean by  "why does it work?"
17:16:07 <revenantphx> brb
17:18:37 <cpa> @type (>>=)
17:18:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:19:24 <tolkad> Does anyone know where I can find a binary lambda calculus interpreter in haskell?
17:20:41 <sshc> Why does xmonad still use base 3?
17:21:18 <aavogt> because a new version hasn't been released yet
17:23:34 <sshc> Is it possible to enable the 2010 standard with ghc 7.0.1?
17:23:52 <sshc> That if-semicolon extension thing is supported, right?
17:24:36 <freedrull> HOTDOGS
17:26:56 <sshc> freedrull: Elaborate, please.
17:28:47 <Cin> sshc: I believe Haskell 2010 is default in GHC7.
17:29:03 <sshc> Wonderful.
17:29:08 <Cin> Not that that's a big deal.
17:30:19 <monochrom> what is a binary lambda calculus interpreter? as opposed to a lambda calculus interpreter?
17:31:52 <sdj> I was wondering too, just looked it up: http://en.wikipedia.org/wiki/Binary_lambda_calculus
17:32:31 <tolkad> monochrom: just a binary encoding of lambda calculus
17:33:17 <sdj> Why not just decode, and run a regular interp
17:33:51 <monochrom> do you accept ascii as a binary encoding? :)
17:34:16 <tolkad> monochrom: binary lambda calculus is more space-efficient
17:34:50 <tolkad> monochrom: because there are no invalid binary lambda caluclus programs
17:35:23 <tolkad> I can make any ascii string and interpret it as binary lambda calculus
17:35:52 <monochrom> where can I read more about binary lambda calculus?
17:36:19 <tolkad> http://en.wikipedia.org/wiki/Binary_lambda_calculus
17:37:30 <tolkad> at least, I think there are no invalid programs
17:37:37 <tolkad> I just learned about it, so I may be wrong
17:37:57 <monochrom> I'm afraid no one has implemented this in haskell yet.
17:39:11 <sdj> But the left-inverse of the encoding is straight forward. 
17:39:52 <mee> wow, the vim haskell plugins have gotten pretty good from the look of this screencast
17:40:15 <sdj> But no - not all binary strings are programs
17:40:42 <monochrom> you could ask for or find an interpreter that assumes an abstract syntax tree - a data structure. you write the decoding from bits to AST yourself.
17:41:27 <monochrom> I almost have an interpreter, but it doesn't use de Bruijn, so it is unsuitable.
17:43:04 <tolkad> wait, I'm wrong, there are invalid programs
17:43:19 <tolkad> you can write one with free variables
17:43:35 <monochrom> I'm wondering why i is encoded as 1^i 0 rather than 1 0^i
17:44:14 <sdj> monochrom: 0 is the delimiter
17:44:38 <sdj> ..in the two other cases
17:45:12 <monochrom> If you use 1^i 0, it's fundamentally important that i>=1, so as to disambiguate from abstraction and application
17:45:32 <monochrom> But that's crappy. Comp sci people should start from 0.
17:46:12 <sdj> the i is the de Bruijn index
17:47:05 <monochrom> In another project I have used de Bruijn index starting from 0 just fine. 1 is inessential.
17:47:41 <sdj> Then the rule would be 1^(i+1) 0
17:48:49 <revenantphx> is !! indexed from zero?
17:48:53 <BMeph> MOAR comonadZ kthxbai! ;þ
17:48:54 <monochrom> yes
17:51:36 <monochrom> But then one might as well encode variable i by 1^(i+1).
17:52:26 <monochrom> oh, nevermind.
17:56:06 <interferon> does the new IO manager in ghc 7 give threaded haskell programs performance similar to what you'd see in node.js?
17:57:07 <interferon> my understanding is that it lets you make blocking calls and have them handled with asynchronous i/o behind the scenes
17:58:24 <sdj> monochrom: You need the 0's as delimiters (think of decoding).
17:58:46 <sdj> Ah - sorry. Didn't see the nvm. :-)
18:01:24 <tolkad> why is there no parallel Functor?
18:05:29 <kmc> interferon, that's been the case before GHC7; it just got a lot better
18:06:03 <interferon> oh, i didn't know that
18:06:04 <kmc> i think before it just used select(); now it knows kqueue() and epoll()
18:06:05 <djahandarie> tolkad, parallel Functor?
18:06:06 <interferon> that's great
18:06:13 <kmc> and also a bunch of internal changes
18:06:13 <interferon> kmc: oh i see
18:06:16 <kmc> there's a paper on it
18:06:58 <kmc> i think it should compare favorably to node.js but i haven't run the tests myself
18:07:26 <interferon> are there any other languages that transparently 'asynckify'?
18:07:32 <kmc> well, this isn't a language property
18:07:38 <kmc> it's an implementation property
18:08:07 <kmc> in fact Haskell the language doesn't have any concurrency primitives, iirc.  unless you consider the "Concurrent Haskell" paper to be an addendum to the spec
18:08:22 <preyalone> How can I combine readInt and Maybe to handle bad input?
18:08:39 <djahandarie> Non-GHC Haskell sucks for doing anything real, so you might as well just ignore it
18:08:44 <preyalone> I tried let x = readInt "booger" :: Maybe Int but that's not quite right.
18:09:23 <djahandarie> :t readInt
18:09:24 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
18:09:32 <kmc> djahandarie, i don't agree -- for example, JHC, UHC, and Hugs all have interesting extensions that GHC lacks
18:09:40 <kmc> and i think it's important to be clear about the difference
18:09:49 <interferon> kmc: that's right, i should have said GHC
18:09:51 <tolkad> djahandarie: For example, I might like to fmap over an IntMap, evaluating each member in parallel
18:09:52 <kmc> between language requirements and accidents of implementation details
18:09:59 <djahandarie> kmc, sure they do, but they don't make up their sucking
18:10:05 <kmc> sure i'm not saying you should use JHC
18:10:09 <kmc> i'm saying you shouldn't ignore it
18:10:20 <kmc> anyway i bet there are lots of other implementations of stuff that asyncify thread IO
18:10:26 <kmc> since there are a lot of implementations of green threads
18:10:30 <djahandarie> I was trolling when I said that anyways
18:11:04 <djahandarie> tolkad, so you want a Functor typeclass that guarantees a parallel fmap?
18:11:17 <preyalone> djahandarie: Could you supply an expression that safely parses a String to Just Int or Nothing?
18:11:39 <tolkad> djahandarie: yeah
18:12:58 <djahandarie> preyalone, hmm... something like maybeRead = fmap fst . listToMaybe . reads
18:13:07 <djahandarie> That should have Read a => String -> Maybe a
18:13:41 <preyalone> ?
18:14:13 <aavogt> but it might be good to make sure the parse wasn't ambiguous:
18:14:45 <aavogt>   maybeRead str = case reads str of [(r,"")] -> Just r; _ -> Nothing
18:16:18 <aavogt> preyalone: there's an instance of   Read Int, so djahandarie's expression can take the type you specified
18:16:53 <preyalone> k
18:17:33 <djahandarie> preyalone, if there is a specific part of that you didn't understand I can explain it
18:18:38 <djahandarie> reads :: Read a => String -> [(a, String)]
18:18:51 <djahandarie> listToMaybe . reads :: Read a => String -> Maybe (a, String)
18:18:55 <monochrom> > (fmap fst . listToMaybe . reads) "34" :: Maybe Int
18:18:56 <lambdabot>   Just 34
18:19:00 <monochrom> > (fmap fst . listToMaybe . reads) "a" :: Maybe Int
18:19:01 <lambdabot>   Nothing
18:19:12 <djahandarie> fmap fst . listToMaybe . reads :: Read a => String -> Maybe a
18:19:16 <monochrom> > (fmap fst . listToMaybe . reads) "3a" :: Maybe Int
18:19:16 <bblum> 'when' needs a "m Bool -> m () -> m ()" version in addition to the "Bool -> ..." version :\
18:19:17 <lambdabot>   Just 3
18:19:38 <aavogt> @type (when =<<)
18:19:39 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
18:20:14 <bblum> not quite :P
18:20:26 <monochrom> x >>= flip when y
18:20:40 <djahandarie> @type (=<<) when
18:20:40 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
18:20:48 <bblum> i mean, i can just use do x <- blah; when x ...
18:21:03 <djahandarie> :t when
18:21:04 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:21:06 <monochrom> blah >>= flip when y
18:21:17 <bblum> ugly :|
18:21:54 <aavogt> @pl \x y -> (`when` y) =<< x
18:21:54 <lambdabot> (. flip when) . (>>=)
18:22:11 <monochrom> you may like to go to hackage and count how many times it is needed.
18:22:16 <djahandarie> Yeah, no nice way to write it
18:22:44 <haskeller> does is it work to put a lambda inside a lambda?
18:22:54 <monochrom> compare to how many times general pattern matching is needed inside a do-block.
18:23:50 <aavogt> haskeller: are you familiar with the notation   \x y -> ... ?
18:23:59 <haskeller> Yes.
18:24:24 <aavogt> well that's the same as   \x -> (\y -> ... ) , which is a lambda inside a lambda
18:25:14 <haskeller> (λ x.λ y. x + ((λ x.8) - y)) 5 6
18:25:30 <haskeller> I have to put translate this to haskell
18:25:52 <haskeller> ops, only translate.
18:26:01 <monochrom> I mean, a monadic "whenM" would be useful in lisp, since you would write like "whenM (null? getLine) (go somewhere)"
18:26:17 <monochrom> But in haskell you just don't care about "null?"
18:26:30 <aavogt> there is a whenM
18:26:33 <aavogt> @hoogle traverse
18:26:33 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:26:33 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
18:27:21 <aavogt> oh, more like a whenJust or so
18:27:23 <haskeller> And I've tried everything, it just doesn't make sense
18:27:55 <aavogt> haskeller: I see only question marks :(  are they all lambdas?
18:27:57 <monochrom> The 1% usefulness of "whenM" is for example "whenM (doesDirectoryExist "haha") ..."
18:28:06 <haskeller> Yes
18:28:22 <monochrom> but since it is always False lately, it's kind of moot :)
18:28:42 <djahandarie> haskeller, well... just read what aavogt said
18:28:51 <haskeller> Is is possible to use "\x" two times in a definition?
18:29:01 <haskeller> *it
18:29:05 <haskeller> sorry, terrible keyboard.
18:29:13 <aavogt> djahandarie: do you see how to subtract from a constant function?
18:29:24 <djahandarie> haskeller, yes, but it is bad practice
18:29:53 <aavogt> does it just reduce to 8...
18:30:04 <monochrom> > let y = (\x -> \x -> x+1) in y 3 4
18:30:05 <lambdabot>   5
18:30:14 <haskeller> no clue
18:30:52 <aavogt> @type  \x y -> x + ((\x -> 8) - y)
18:30:53 <lambdabot> forall t t1. (Num t1, Num (t -> t1)) => (t -> t1) -> (t -> t1) -> t -> t1
18:31:12 <aavogt> @type  \x y -> x + (8 - y) -- has a type which makes much more sense
18:31:13 <lambdabot> forall a. (Num a) => a -> a -> a
18:32:23 <aavogt> or, do you read it as  ((\x.8) (-y) )
18:33:36 <haskeller> \x y -> x + ((\x -> 8) - y) was precisely what I got, though it doesn't work on ghci.
18:34:00 <monochrom> it doesn't type-check. function minus number? not going to happen.
18:34:35 <monochrom> not even in untyped lambda calculus
18:35:07 <preyalone> Thanks all! maybeRead works! Is there a builtin maybeRead in the stdlib?
18:35:14 <monochrom> no
18:35:45 <preyalone> Well, at least it's easy to write.
18:37:21 <haskeller> How can I make it work, then?
18:38:14 <monochrom> unsafePerformIO (try (readIO your_string >>= evaluate) >>= \e -> case e of { Left _ -> return Nothing; Right n -> return (Just n) } )
18:38:56 <monochrom> \x y -> x + (8 - y)
18:40:21 <benmachine> monochrom: unsafePeformIO for that? o_ó
18:40:26 <monochrom> haha
18:41:14 <monochrom> perhaps I don't need >>= evaluate
18:41:26 <benmachine> I don't think you do
18:41:32 <benmachine> I think that's the idea of readIO
18:41:58 <ivanm> @hoogle mapAccum
18:41:58 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
18:41:58 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
18:41:58 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
18:43:02 <monochrom> whenM b a = when (unsafePerformIO b) a
18:43:21 <revenantphx> @hoogle [a] -> [b] -> [c] -> [(a,b,c)]
18:43:21 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
18:43:21 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
18:43:28 <revenantphx> wonderful
18:43:40 <monochrom> easy as a,b,c
18:43:45 <revenantphx> but what about
18:44:03 <revenantphx> @hoogle [(a,a,a)] -> [b] -> [c] -> [(a,a,a,b,c)]
18:44:03 <lambdabot> No results found
18:44:07 <revenantphx> didnt think so
18:44:18 <haskeller> let k = (\x y -> x + ((\x -> 8) (-y))) in k 5 6
18:44:21 <haskeller> > let k = (\x y -> x + ((\x -> 8) (-y))) in k 5 6
18:44:22 <lambdabot>   13
18:44:47 <monochrom> lambdabot has some evil code loaded to abuse functions like that.
18:45:03 <djahandarie> That isn't abuse
18:45:05 <djahandarie> He changed it
18:45:39 <revenantphx> so er
18:45:46 <revenantphx> is there a way to do what I just hoogled?
18:45:50 <haskeller> the parenthesis, you say?
18:46:02 <monochrom> not the parenthesis
18:46:06 <revenantphx> [(a,a,a)] -> [a] -> [a] -> [(a,a,a,a,a)]
18:46:13 <revenantphx> @hoogle [(a,a,a)] -> [a] -> [a] -> [(a,a,a,a,a)]
18:46:13 <lambdabot> No results found
18:46:22 <monochrom> oh, djahandarie is right, different piece of code entirely.
18:46:34 <haskeller> > (\x y -> x + ((\x -> 8) (-y))) 5 6
18:46:35 <lambdabot>   13
18:46:36 <djahandarie> haskeller, the parentheses are the difference between subtracting a number from a function and applying a negative number to a function
18:47:00 <djahandarie> haskeller, note that 'k' can just be reduced to (\x _ -> x + 8)
18:47:34 <djahandarie> ( The _ means to ignore that parameter in Haskell)
18:47:59 <ndrsndrs> :t zipWith3 (\ ~(a,b,c) d e -> (a,b,c,d,e))
18:47:59 <haskeller> I'm aware of that
18:48:00 <lambdabot> forall t t1 t2 b c. [(t, t1, t2)] -> [b] -> [c] -> [(t, t1, t2, b, c)]
18:48:50 <ndrsndrs> :t zipWith3 (\ ~(a,b,c) d e -> (a,b,c,d,e) `asTypeOf` (a,a,a,a,a)) -- well, strictly
18:48:51 <lambdabot> forall b. [(b, b, b)] -> [b] -> [b] -> [(b, b, b, b, b)]
18:49:52 <revenantphx> whats the ~ for?
18:50:05 <monochrom> more laziness
18:50:06 <revenantphx> :t zipWith3
18:50:07 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
18:50:11 <revenantphx> why is it there?
18:50:19 <djahandarie> NEED MOAR LAZINESS
18:50:25 <revenantphx> Is it needed...?
18:50:28 <ndrsndrs> probably not
18:50:30 <haskeller> thank you.
18:50:39 <revenantphx> so why did you put it there? I'm curious :P
18:50:56 <monochrom> safer
18:50:59 <revenantphx> how?
18:51:00 <ndrsndrs> > case undefined of (_, _) -> "foo"
18:51:01 <lambdabot>   "*Exception: Prelude.undefined
18:51:09 <ndrsndrs> case undefined of ~(_, _) -> "foo"
18:51:19 <ndrsndrs> > case undefined of ~(_, _) -> "foo" -- woops
18:51:20 <lambdabot>   "foo"
18:51:35 <revenantphx> So... why would I use ~
18:51:37 <revenantphx> In this case.
18:52:07 <monochrom> you have, actually, presented no use case yet. so no one knows.
18:52:34 <revenantphx> Well, I mean why did he put it there.
18:52:34 <monochrom> there is no "this case" yet.
18:52:47 <revenantphx> Oh, I just need to combine three separate lists I've parsed.
18:52:51 <revenantphx> For storage and future use.
18:52:55 <revenantphx> They're all int types.
18:52:56 <ndrsndrs> if the triple is _|_, but you only need the last two elements, without the ~ you get an error, with it you don't
18:53:27 <ndrsndrs> if the parsing is strict anyway (which is presumably is), it won't make a difference though
18:53:36 <monochrom> because without ~ there are use cases that bomb, with ~ all uses cases are fine, but may be slower
18:54:43 <revenantphx> Well, considering that if I don't have the data ,it bombs anyways
18:54:46 <revenantphx> I don't think I need it.
18:55:10 <ndrsndrs> probably not, no.
18:55:30 <djahandarie> > let { f = (\ ~(a,b,c) d e -> (a,b,c,d,e)); (i1,i2,i3,i4,i5) = f undefined 2 3; } in (i4, i5)
18:55:31 <lambdabot>   (2,3)
18:55:36 <djahandarie> > let { f = (\ (a,b,c) d e -> (a,b,c,d,e)); (i1,i2,i3,i4,i5) = f undefined 2 3; } in (i4, i5)
18:55:37 <lambdabot>   (*Exception: Prelude.undefined
18:57:04 <revenantphx> ok...
18:57:40 <Causalien> Hi everyone
18:58:02 <ndrsndrs> hi Causalien 
19:00:41 * ivanm waves idly in Causalien's general direction
19:00:57 <Causalien> howdy. Slow night?
19:01:13 <ivanm> @time
19:01:20 <monochrom> 22:00
19:01:25 <ivanm> OK, lambdabot can't tell my time...
19:01:31 <ivanm> but it's 14:00 here!
19:01:34 <djahandarie> @time
19:01:37 <lambdabot> Local time for djahandarie is Thu Dec  2 22:42:32 2010
19:01:48 <djahandarie> I have my own timezone.
19:01:51 <monochrom> that's interesting
19:02:08 <monochrom> @time
19:02:09 <ivanm> djahandarie: ... >_>
19:02:09 <lambdabot> Local time for monochrom is 3.1415926535897932384626433832795028841972
19:02:14 <monochrom> hehehehe!
19:02:22 <djahandarie> Hmmm
19:02:31 <ivanm> have you two had enough mucking around with your CTCP settings yet?
19:02:39 <monochrom> yes, I hacked my irc software's "ctcp time" response.
19:03:06 <monochrom> well, you are the greatest mucker, to the point lambdabot can't even get anything from you
19:03:12 <djahandarie> @time
19:03:16 <lambdabot> Local time for djahandarie is Thu Dec  2 22:44:09 2010
19:03:19 <djahandarie> Gr
19:03:25 <ivanm> I think this client is too dumb to know about CTCP time
19:03:35 <c_wraith> monochrom, are you saying it's time for pi?
19:03:39 <Causalien> Studying haskell is taking longer than I thought. Only 11% done since I started. How long did it took for most of you to go through them?
19:03:52 <djahandarie> Them???
19:04:18 <Causalien> Lyah and RWH
19:04:20 <djahandarie> You are never finished studying Haskell. Until you start studying Agda.
19:04:22 <c_wraith> It took me about 3 months to really feel comfortable with everything I was doing.  And I still don't know nearly everything. :)
19:05:00 <ivanm> Causalien: I have never looked at LYAH
19:05:18 <c_wraith> That 3 months was just how long it took me to build up a core of comfort I felt comfortable expanding from
19:05:24 <ivanm> and RWH took me under a month IIRC (admittedly, I was only reading it, not actively doing problems, etc.)
19:05:34 <Causalien> Anyway, for me that's considered finished studying and moving on to projects.
19:05:54 <Causalien> Provided that there are projects I can participate in.
19:06:24 <liyang> djahandarie: at which point you become horribly disillusioned with how ad-hoc Haskell is.
19:06:59 <Cale> It took me maybe about 2 months to feel like I could actually do useful stuff with Haskell, and probably about a year to really say that I was comfortable. I wasn't studying it so intensely that whole time though (I had a full course load of mostly mathematics courses :)
19:07:35 <ivanm> I think I was about the same as Cale, except that I learnt Haskell whilst using it to work on a summer project
19:07:41 <haskeller> I'm entering my fourth month
19:07:55 * monochrom integrates diracdelta to get the number 1
19:08:09 <ivanm> monochrom: have fun with that
19:08:24 <djahandarie> It takes me forever to learn everything
19:08:33 <djahandarie> But that's only because I'm learning a bunch of other stuff at the same time
19:08:46 <haskeller> Same here
19:08:51 <djahandarie> I'm like a massively parallel but slow clocked processor
19:09:01 <ivanm> is there a function that lets you apply another function n times?
19:09:17 <ivanm> @remember djahandarie I'm like a massively parallel but slow clocked processor
19:09:17 <lambdabot> Nice!
19:09:17 <djahandarie> iterate and !!
19:09:24 <monochrom> we tend to iterate f x !! n
19:09:29 <ivanm> djahandarie: duh, yeah
19:09:32 <ivanm> forgot about iterate...
19:09:34 <Cale> Learning everything ought to take forever
19:09:43 <Causalien> Looks like I have to take this on in a more structured way like I'd take a school class.
19:09:50 <ivanm> Cale: especially since more knowledge appears as you learn old knowledge...
19:10:21 <Cale> Yeah. Everything is a lot of stuff. :)
19:10:46 <jon_of_arc> Well, it presumably takes either forever or no time at all
19:11:13 <jon_of_arc> (Assuming infinite everything)
19:12:11 <jon_of_arc> (Come to that, assuming countable everything. Don't mind me.)
19:17:32 <interferon> Causalien: 11% of wht?
19:17:54 <djahandarie> See the next line after that. :P
19:18:03 <Causalien> 11% of the tutorial
19:22:39 <jmcarthur> and that's not even all of GHC-Haskell or all of the cool, useful libraries!
19:22:47 <jmcarthur> in any particular tutorial
19:24:12 * ivanm heads off
19:24:14 <ivanm> bye all!
19:24:22 <djahandarie> Later!
19:24:24 <djahandarie> Damn
19:38:17 <lars9> anyone dislikes camelcase very much?
19:38:49 <ndrsndrs> yes, a lot
19:39:18 <ndrsndrs> but not as much as inconsistency so (in haskell) i use it anyway
19:39:23 <ndrsndrs> :(
19:39:34 <lars9> exactly the same situation
19:39:40 <aavogt> that doesn't seem to be popular from code I've seen
19:39:52 <monochrom> I don't like camel case.
19:39:56 <lars9> i like pure c style
19:40:07 <lars9> vector.push_back()
19:40:17 <aavogt> sometimes you'll have   internal_function, but then exportedFunction
19:42:05 <monochrom> camel case implies that you can't tell exportChina from exportChina
19:42:27 <monochrom> proper case allows you to distinguish them: export_China and export_china
19:42:47 <lars9> and editor can do highlighting, we dont need Upper case for class name...
19:43:48 <monochrom> also runGUIInstance is just strange. run_GUI_instance.
19:44:34 <jmcarthur> i dislike that underscores are abused for this purpose in identifiers though. i wish it could be hyphens or something more sensible
19:44:37 <lars9> i prefer lower_case or lowercase
19:44:40 <orlandu63> hyphenation is the nicest imo
19:45:00 <jmcarthur> in haskell we can at least do terrible things like run'GUI'Instance
19:45:02 <lars9> jmcarthur: if we dont need to do minus
19:45:12 <dankna> phn'gluiFtaghn
19:45:23 <jmcarthur> lars9: agda manages fine supporting both minus and hyphen in identifiers
19:45:35 <jmcarthur> lisps too
19:45:53 <lars9> lisp can not do (1 + 2)
19:46:00 <lars9> :D
19:46:04 <monochrom> Get rid of concrete plain text file syntax. Any string can be an identifier because the AST marks it as identifier.
19:46:09 <jmcarthur> sure it can if 1 means something :)
19:46:27 <jmcarthur> (1 + 2) is just syntax for whatever you interpret it with
19:46:44 <oconnore> lars9: I have seen Lisp do {1 + 2} though :D
19:46:58 <monochrom> In fact you can write a whole paragraph or several lines of equations or a whole web page for an identifier.
19:47:14 <jmcarthur> monochrom: or an image or video :P
19:47:19 <orlandu63> (quote (1 + 2)) should work
19:47:23 <monochrom> You can write quickcheck properties right into your function name.
19:47:40 <CodexArcanum> I hate underscores in names, pain to type.  Camel case is ok.  I'm used to c# so I'm fond of methods and class in upper case, variables in lower or camel
19:48:20 <CodexArcanum> Heh, so I guess in haskell that's pretty much what it is, except functions are in camel. eh...
19:48:31 <haskeller> About using the same identifiers in a lambda... where did you get that information?
19:48:31 <orlandu63> underscores stand out too much
19:48:36 <jmcarthur> i'm reasonably happy with camel case when the alternative is underscores. i know it's strictly less expressive, but it just fits my aesthetic preferences
19:49:10 <haskeller> I mean, code on hackage an the like, or reading tutorials/books?
19:49:14 <monochrom> My favourite identifier format is the full formal specification as the identifier. But yeah if you prefer a video I support it too.
19:49:15 <lars9> yeah, ClassInCamelCase, var_in_lower_case this style is good
19:49:34 <lars9> butThisIsReallyUgly
19:49:49 <haskeller> i was afraid to use variable.
19:49:52 <monochrom> haskeller: you may read the Haskell 2010 Report at http://www.haskell.org/onlinereport/haskell2010/
19:50:23 <djahandarie> haskeller, just experience
19:50:33 <djahandarie> I've never fully read through the report
19:50:46 <djahandarie> I've only skimmed it and read certain parts
19:50:54 <lars9> camel case with 1st char in lower case is ugly. ClassName is ok, functionName is ugly
19:51:04 <revenantphx> lars9: deal with it.
19:51:10 <djahandarie> I don't mind camel case.
19:51:17 <revenantphx> me neither
19:51:37 <jmcarthur> could always do something terrible like this:   [v|my variable] + [v|my other variable]   :D
19:52:02 <jmcarthur> using quasiquoters to desugar it into something like underscores or something
19:52:07 <Causalien> What does !! do again?
19:52:12 <djahandarie> :t (!!)
19:52:13 <lambdabot> forall a. [a] -> Int -> a
19:52:15 <monochrom> If you have used javascript, you also know and have some expectation about what happens with using the same name.
19:52:18 <pkrumins> take nth element from the list, Causalien 
19:52:22 <haskeller> Guess it's a long path for me then
19:52:31 <Causalien> Thanks. pkrumins
19:53:07 <lars9> ok, i'll use this style: ClassName, functionName, var_name; it's consistent with std lib, and some flexibility in var naming.
19:53:14 <djahandarie> mauke, did the hostmask on that change recently?
19:53:26 <djahandarie> I recall it being unaffiliated/preflex at some point...
19:53:32 <jmcarthur> [v|enum from then to]
19:54:45 <jmcarthur> [C|class name], [v|function or variable name]
19:54:47 <jmcarthur> okay i'll stop
19:55:16 <aavogt> jmcarthur: that's allowed now? (leaving out the $)
19:55:40 <ndrsndrs> aavogt: in ghc 7
19:55:48 <monochrom> lars9: I'm wondering if you may get a good laugh at this iphone game: http://appshopper.com/games/peaceful-war
19:57:10 <jmcarthur> aavogt: yeah i think it's new
19:57:23 <lars9> monochrom: is it played by drawing?
19:57:27 <aavogt> but the C won't work
19:57:35 <jmcarthur> ah i didn't think about that
19:57:46 <monochrom> In fact only the aircrafts can be hand-drawn when you build them.
19:57:50 <jmcarthur> i don't think i've actually used a QQ yet
19:58:09 <lars9> very interesting!
19:58:18 <monochrom> The rest, you click "build" and it happens automatically, e.g., flags and walls.
19:58:39 <aavogt> well unfortunately haskell-src-meta is still not fixed for ghc-7
19:58:42 <monochrom> When you attack, you just touch the target spot.
19:58:50 <lars9> omg, if my stone age ipod1 still work, i'll play it
19:58:59 <jmcarthur> monochrom: so the game is about penises attacking each other? because that's all that's going to happen
19:59:25 <monochrom> Yes, it's pretty boring actually, this particular implementation.
20:00:01 <aavogt> so it can't be used for the new quasiquoter features
20:00:13 <revenantphx> ugh
20:00:16 <revenantphx> I have a serious issue here :\
20:00:22 <revenantphx> https://gist.github.com/726523
20:00:26 <revenantphx> I have this using BinaryProtocol
20:00:47 <revenantphx> however, I additionally have to spontaneously send packets (including a keepalive) that are not in response to others.
20:01:12 <aavogt> forkIO
20:01:19 <revenantphx> aavogt: but then how will I write to the handle.
20:01:35 <revenantphx> binaryprotocol says it does stuff with the handle.
20:01:42 <revenantphx> Im thinking of somehow getting a handle to a Chan?
20:01:47 <monochrom> The authentic implementation is everything-done-by-hand. So you get to be more creative with hand-drawings. Moreover, when you attack, it is not as easy as clicking. You hold a pencil vertically at the aircraft that launches the attack, pencil tip on aircraft and one finger on the other pencil end, now push your finger down hard, and just hope that this causes the pencil to draw a line that hits somewhere useful
20:01:50 <revenantphx> then having a thread dequeue stuff and send it.
20:02:18 <monochrom> And oh, if it hits your own stuff instead, too bad!
20:02:38 <lars9> monochrom: fight by drawing is a very interesting idea
20:02:55 <revenantphx> what
20:03:41 <lars9> monochrom: i guess nintendo has developed similar games for nds
20:05:33 <revenantphx> aavogt: any idea?
20:14:23 <oconnore> Does hugs not allow you to use let? Or am I missing something?
20:15:05 <aavogt> oconnore: you should be allowed: let ... in
20:15:07 <Sic[NOH8]> jayne is a stupid fucking cunt, a fatass bitch that couldn't take my massive 8" cock
20:15:13 <Sic[NOH8]> i'd smash that fucking nigger faggot's cervix so hard
20:15:17 <Sic[NOH8]> make that cunt bleed from my dicking
20:15:23 <ndrsndrs> what is happening
20:15:27 <danderson> well, that's nice.
20:15:29 --- mode: ChanServ set +o monochrom
20:15:35 --- mode: monochrom set +b *!*@c-67-175-21-246.hsd1.il.comcast.net
20:15:35 --- kick: Sic[NOH8] was kicked by monochrom (Sic[NOH8])
20:15:55 <ndrsndrs> do people do that often?
20:16:00 <monochrom> no
20:16:01 <copumpkin> only dumb ones
20:16:05 <danderson> not too often on freenode
20:16:14 <danderson> trolls roam other networks much more
20:16:53 <ndrsndrs> that's what i thought, it seemed much more civilised here :)
20:18:55 <oconnore> aavogt: let x = 5  ==> ERROR - Syntax error in expression (unexpected end of input)
20:19:14 <oconnore> that is literally the first example of the tutorial i am looking at :P
20:19:26 <aavogt> oconnore: does the tutorial tell you to use ghci?
20:19:54 <tg_> he at least could have sewn some haskell in to that lewd story
20:20:05 <lispy_> oconnore: if that's the first line, you might want to read ahead
20:20:10 <oconnore> aavogt: i think that's what the author was using. do haskell compilers really differ that much?
20:20:39 <lispy_> oconnore: they agree on the syntax, but ghci is an interpreter (hence the i)
20:20:52 <lispy_> oconnore: it's for interactive use and thus assumes a certain part of the Haskell grammer
20:20:55 <lispy_> grammar*
20:20:56 <oconnore> lispy_: right, hugs is an interpreter too
20:21:05 <sshc> X11 needs to enable Nothing to be passed to "openDisplay" instead of always a String (passing NULL to this functional after all is the most common use of it).  Until then, I'll have to import this function myself.
20:21:22 <aavogt> oconnore: exactly what's allowed in the interactive mode doesn't seem to be specified in the haskell report
20:21:44 <aavogt> sshc: don't you get the same answer with    openDisplay "" 
20:21:51 <oconnore> lispy_: it's the first example. I already wrote my basic fibonnacci and factorial programs that i can load... I was just wondering why the interactive examples weren't working.
20:22:14 <lispy_> oconnore: in ghci you start inside an implicit do-block (for the IO monad).  Inside a do-block, "let" has the form above
20:22:34 <oconnore> ah, i see
20:22:39 <oconnore> thanks
20:22:54 <lispy_> oconnore: normally, let is like, let x = 5 in y
20:23:04 <lispy_> note the "in y" part
20:23:16 <sshc> X11 needs to enable Nothing to be passed to "openDisplay" instead of always a String (passing NULL to this functional after all is the most common use of it).  Until then, I'll have to import this function myself.
20:23:18 <lispy_> > let x = 5 in x
20:23:19 <lambdabot>   5
20:23:20 <sshc> To whom should I complain?
20:23:53 <sshc> Hackage says "Maintainerlibraries@haskell.org"
20:24:24 <oconnore> let x = 5 in 2*x
20:24:30 <sshc> I'll email that silly libraries tomorrow.  /me bed
20:24:36 <oconnore> > let x = 5 in 2*x
20:24:37 <lambdabot>   10
20:24:40 <oconnore> nice
20:25:03 <oconnore> I'll stop bothering you all now.
20:25:19 <revenantphx> ...is there a function to get the name of the type of something?
20:25:39 <jmcarthur> at the value level?
20:25:50 <jmcarthur> there is, but in 99% of cases you shouldn't use it
20:25:52 <revenantphx> Well, to see what data constructor at least.
20:25:56 <revenantphx> I jsut need it for debugging.
20:25:56 <jmcarthur> also it's only available for certain types
20:26:06 <jmcarthur> ah, well, look into Typeable then
20:26:22 <revenantphx> this looks overkill :\
20:26:24 <jmcarthur> if all you care about is data constructor and not type constructor then maybe you could just use Show?
20:26:50 <revenantphx> yeah but then since it's derived, for the packet which has a kb or more of data in it, it likes to print that.
20:26:52 <revenantphx> (and I dont)
20:26:57 <jmcarthur> > typeOf "foo"
20:26:58 <lambdabot>   [Char]
20:27:03 <jmcarthur> not that crazy ^^
20:27:21 <jmcarthur> > typeOf 5
20:27:22 <lambdabot>   Integer
20:27:24 <jmcarthur> > typeOf True
20:27:25 <lambdabot>   Bool
20:27:33 <djahandarie> > typeOf typeOf
20:27:34 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:27:34 <lambdabot>    `Data.Typeable.Typeable a...
20:28:19 <jmcarthur> > typeOf (undefined :: Int -> Int)
20:28:20 <lambdabot>   Int -> Int
20:28:31 <revenantphx> can you derive Typeable?
20:28:37 <jmcarthur> with an extension, yes
20:28:51 <jmcarthur> DeriveTypeable, i believe it's called
20:28:51 <revenantphx> which one
20:28:55 <revenantphx> this is just temporaey
20:29:11 <djahandarie> A lot of people derive Typeable, it's not uncommon
20:29:16 <jmcarthur> indeed
20:29:32 <jmcarthur> it's not a bad idea to do so because it just means more flexibility. it doesn't hurt those who don't use it
20:30:31 <lars9> i'm writing a zipper for a special rose tree, i found it's hard to write the function: moveSubTreeTo :: Zipper -> Zipper -> Zipper, which moves current subtree to a location indicated by another zipper, how to implement it?
20:31:36 <chrys> can someone explain this line:      removeAt :: Int -> [a] -> (a, [a])
20:32:02 <lars9> i've implemented removeSubTree :: Zipper -> Zipper and insertSubTree :: Tree -> Zipper -> Zipper
20:32:02 <tg_> @type removeAt
20:32:03 <lambdabot> Not in scope: `removeAt'
20:32:13 <djahandarie> chrys, it's a type for the function removeAt
20:32:17 <revenantphx> "An instance of Typeable can only be derived if the data type has seven or fewer type parameters, all of kind *."
20:32:18 <revenantphx> what
20:32:25 <jmcarthur> chrys: that's a type signature saying that removeAt takes an Int and a list of somethings and gives you a something and another list of somethings
20:32:30 <revenantphx> I have a constructor with 9
20:32:31 <revenantphx> fuck it.
20:32:47 <djahandarie> chrys, it takes an integer, a list of something, and returns a tuple containing something and a list of something
20:32:57 <lars9> chrys: removeAt 2 "abcd" = ('c', "abd")
20:33:08 <djahandarie> lars9, you don't know that just from the type signature
20:33:12 <djahandarie> But yeah that's probably what it does
20:33:44 <jmcarthur> we know that if the list is empty then at least the first component of the result is undefined
20:33:56 <jmcarthur> that's all we can really tell about the implementation from that as far as i can tell
20:34:24 <jmcarthur> well, and the list in the result would be either empty or undefined as well
20:34:39 <jmcarthur> or the whole result could be undefined
20:34:54 <djahandarie> jmcarthur, or [undefined, undefined], etc
20:35:01 <jmcarthur> oh right
20:35:04 <jmcarthur> i didn't consider that one
20:35:16 <tg_> @hoogle removeAt
20:35:16 <lambdabot> No results found
20:35:20 <jmcarthur> silly _|_
20:35:22 <tg_> where is it?
20:35:25 <chrys> y do i get an error wen i type it in haskell
20:35:38 <jmcarthur> chrys: well it's not a complete function. that's just its type
20:36:34 <chrys> thats y i get a "not in skope msg?"
20:37:16 <lars9> how to describe the path between two zippers?
20:39:14 <lars9> hmm.. if zipper is a differentiation of a data structure, then the diff between two zippers should be order-2 differentiation...
20:39:35 <aavogt> revenantphx: did you try to write the instance yourself? You could also workaround by using two   data A a b c d rest = A a b c d rest, where   rest turns out to be a type containing yet more type variables
20:39:39 <tg_> lars9: tensor?
20:40:31 <revenantphx> hm
20:40:38 <tg_> i don't think so
20:40:49 <revenantphx> okay
20:40:55 <revenantphx> So does this sound reasonable
20:41:12 <lars9> too complicated... i guess (root, [L, R, L, R]) is enough for a not-too-large data structure
20:41:26 <revenantphx> 1) I fork a thread which runs over a TChan/Chan and writes packets to the handle
20:41:34 <revenantphx> 2) I fork a thread that enqueues keepalives
20:41:45 <revenantphx> 3) I have the main thread infinite respond to received packets.
20:42:06 <revenantphx> The only issue is binary-protocol reading in the middle of my writes or something :\
20:44:19 <revenantphx> Would I have to run the reads atomically? if so I have another issue.
20:44:41 <revenantphx> because atomically is STM to IO, and I'm inside StateT (something something) IO AKA BinaryProtocol and
20:44:44 <revenantphx> oh god its all weird TT_TT
20:45:27 <chrys> is that y i get a "not in scope" msg?
20:45:29 <djahandarie> Once you fix this program you will have graduated to Haskell proficiency
20:46:00 <djahandarie> That first program where monad transformers, IO and STM all get screwed up in one giant mess is what makes you learn how to think about types properly ;)
20:46:16 <revenantphx> This scares me.
20:46:28 <djahandarie> STM is particularly confusing due to rank-2 types though
20:46:45 <c_wraith> eh?
20:46:46 <jmcarthur> STM doesn't use rank 2 types that i'm aware of. do you mean ST?
20:46:48 <c_wraith> do you mean ST?
20:46:49 <djahandarie> Er
20:46:50 <djahandarie> Haha
20:46:53 <djahandarie> Oops
20:46:54 <djahandarie> ST
20:47:01 <djahandarie> He was using ST too, I swear!
20:47:14 <c_wraith> anyway, the rank-2 type in ST is something you just ignore, and you're fine.
20:47:16 <revenantphx> StateT
20:47:24 <c_wraith> It's there for the compiler, not for the programmer
20:47:29 <jmcarthur> chrys: that sounds like the kind of error i would expect, yes
20:47:37 <revenantphx> Okay, well maybe you can help me out a bit jmcarthur :)
20:48:48 <revenantphx> https://gist.github.com/726592
20:48:49 <djahandarie> revenantphx, you were using STRefs weren't you?
20:48:57 <revenantphx> No, I'm not (yet0
20:49:11 <jmcarthur> a haskell minecraft bot? :D
20:49:15 <revenantphx> Yes.
20:49:17 <djahandarie> Heh
20:49:18 <revenantphx> And... it works (mostly)
20:49:20 <revenantphx> Seriously.
20:49:36 <revenantphx> There is one packet I need to find that doesn't work.. and I need to send keepalives.
20:49:41 <revenantphx> That latter part is the basis of my trouble.
20:49:51 <revenantphx> See, sadly, all send's can't be in response to receives
20:50:02 <revenantphx> So I need a way to have arbitrary threads enqueue packets to send.
20:50:05 <revenantphx> So i thought "ok, easy"
20:50:21 <revenantphx> I have a tchan that all of the threads enqueue onto, and another writes from
20:50:25 <preyalone> How can I check if two expressions use the same constructor? Should I use typeOf?
20:50:27 <revenantphx> except, oh shit, the write and read handle are the same.
20:50:42 <revenantphx> So I need to make sure it's not reading while its writing...
20:50:48 <djahandarie> Normally you should pretend typeOf doesn't exist
20:50:51 <preyalone> I can check for specific constructors using guards, but that's boilerplate.
20:50:52 <revenantphx> so I think "okay... I could wrap the handle in some concurrency shit"
20:51:00 <revenantphx> but then I realize, OH BUT THEN BINARYPROTOCOL WILL HATE ME FOR IT.
20:51:09 <revenantphx> See the root of the issue here?
20:51:10 <jmcarthur> revenantphx: i would just have a single thread do everything relating to the handle
20:51:10 <chrys001> so would this b better?
20:51:13 <chrys001> removeAt :: Int -> [a] -> (Maybe a, [a]) removeAt _ [] = (Nothing, []) removeAt 1 (x:xs) = (Just x, xs) removeAt k (x:xs) = let (a, r) = removeAt (k - 1) xs in (a, x:r)
20:51:21 <revenantphx> jmcarthur: and where on earth am I going to put the keepalive?
20:51:30 <revenantphx> Ohwait.
20:51:34 <revenantphx> shit. I see.
20:51:47 <revenantphx> You mean I should have the thing that writes enqueued packets just be in minecraftBotProtocol
20:51:50 <kadoban> maybe this is a dumb question, but what's the point of having liftM /and/ fmap?  aren't they kind of the same, just in different typeclasses, except aren't Functors almost always Monads and the reverse?  or maybe that last bit isn't true?
20:52:15 <revenantphx> :t fmap
20:52:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:52:19 <revenantphx> :t liftM
20:52:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:52:22 <revenantphx> hm
20:52:23 <c_wraith> kadoban, the only reason both exist is because a monad doesn't require a functor constraint
20:52:25 <Funktorsalat> kadoban: functor not being a superclass of monad is a legacy problem
20:52:33 <Funktorsalat> the fmap/liftM one follows from it
20:52:43 <ndrsndrs> preyalone: if it's an instance of Data, you can do toConstr x == toConstr y perhaps
20:52:55 <preyalone> ndrsndrs: Thanks, will try.
20:53:02 <jmcarthur> revenantphx: you could alternatively stick the handle in an MVar or something
20:53:24 <revenantphx> yeah, but I also fed it to BinaryProtocol, and it won't respect an Mvar
20:53:35 <revenantphx> So I'm forced into making all read/writes through binary-protocol
20:53:36 <jmcarthur> i have no idea what that is
20:53:47 <chrys001> hmm?
20:54:04 <revenantphx> It's a little package I found that does really simple things to abstract protocols involving packets implementing Binary.
20:54:19 <revenantphx> It does shit with lazy ByteStrings I don't understand :)
20:54:45 <kadoban> okay so why does Functor exist then?  all it supplies is fmap, right?  but...if liftM does the same thing?
20:55:07 <jmcarthur> kadoban: not every functor is a monad
20:55:09 <c_wraith> Because fmap can apply to things that aren't monads
20:55:28 <kadoban> oh okay, so there are Functors that aren't Monads...then it makes sense.  i guess i just haven't seen them yet
20:55:30 <kadoban> thanks
20:55:31 <chrys001> aww
20:55:32 <ndrsndrs> preyalone: this only notices the topmost constructor, though, of course, so toConstr [(),(),()]==toConstr [5] == (:)
20:55:39 <c_wraith> > fmap (+7) (False, 5)
20:55:39 <lambdabot>   (False,12)
20:55:52 <ndrsndrs> (well not really (:), but the Constr value representing it. you know what i mean :p]
20:55:58 <kadoban> oh :) i just didn't notice they were functors, hehe
20:56:11 <lars9> which data structure supports efficient indexing, insert, del, modify? sounds like a BST, is there any BST in haskell?
20:56:12 <c_wraith> that's the (a, b) instance for functor.  It can't be an instance of Monad because you can't implement return for an arbitrary (a, b)
20:56:33 <c_wraith> lars9: Data.Map, Data.IntMap, Data.Set
20:56:34 <chrys001> heyy... can sum1 explain this?
20:56:34 <chrys001> removeAt :: Int -> [a] -> (Maybe a, [a]) removeAt _ [] = (Nothing, []) removeAt 1 (x:xs) = (Just x, xs) removeAt k (x:xs) = let (a, r) = removeAt (k - 1) xs in (a, x:r)
20:56:41 <jmcarthur> > let removeAt :: Int -> [a] -> (Maybe a, [a]) ; removeAt _ [] = (Nothing, []) ; removeAt 1 (x:xs) = (Just x, xs) ; removeAt k (x:xs) = let (a, r) = removeAt (k - 1) xs in (a, x:r) in removeAt 2 "foobar"
20:56:41 <lambdabot>   (Just 'o',"fobar")
20:56:45 <preyalone> ndrsndrs: toConstr helps me a lot! Does this work? toConstr (Store "FoodCo") == toConstr (Store) -- no arguments
20:56:58 <Funktorsalat> kadoban: you're still right though that liftM wouldn't be necessary if Functor was a superclass of Monad as it mathematically should be
20:57:21 <jmcarthur> chrys001: are you going through a tutorial or a class or something?
20:57:21 <ndrsndrs> preyalone: no, it has to be a full value (though you can fill the fields with undefined or something if you need to)
20:57:23 <tg_> chrys001: what's expected. it removes the thing in the specificed position in the list
20:57:24 <kadoban> okay, cool, i think i get it then
20:57:25 <lars9> c_wraith: i want array style indexing
20:57:26 <jmcarthur> chrys001: because if not, you should
20:57:33 <jmcarthur> @where lyah
20:57:34 <lambdabot> http://www.learnyouahaskell.com/
20:57:49 <c_wraith> lars9, you mean the syntax?  There's also Data.Sequence
20:57:51 <Cale> Actually, liftM would still be useful to keep around if Functor was a superclass of Monad
20:58:08 <ndrsndrs> toConstr Store == (->), presumably (or would be if there were an instance Data (a->b))
20:58:13 <Cale> Because it provides an easy way to construct the Functor instance given the Monad instance.
20:59:16 <c_wraith> Cale, you can just tell GHC to derive functor these days.  It *is* completely mechanical, after all :)
21:00:09 <Cale> For polynomial types it's completely mechanical, anyway.
21:00:13 <c_wraith> oh, that's true
21:00:21 <c_wraith> functions are exponential, aren't they?
21:00:24 <Cale> yeah
21:00:39 <Funktorsalat> I'd be surprised if it can derive Reader or Cont
21:00:57 <Cale> Well, djinn could do it
21:00:58 <Funktorsalat> though it still seems mechanical
21:01:37 <djahandarie> But Djinn wouldn't be able to do List
21:01:50 <Cale> right
21:01:54 <c_wraith> on the other hand, List is polynomial :)
21:02:37 <preyalone> ndrsndrs: I'd like toConstr to ignore the number of constructor arguments, but I guess some boilerplate is always necessary. Thanks again!
21:02:56 * hackagebot text 0.10.0.2 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.10.0.2 (BryanOSullivan)
21:03:15 <c_wraith> what's new in this release, bos?
21:03:17 <Funktorsalat> omg it works: data R e a = R (e -> a) deriving (Functor)    
21:03:24 <Funktorsalat> I retract
21:03:36 <Cale> Does it manage State?
21:03:49 <bos> c_wraith: undoing an accidental API change in 0.10.0.1
21:03:52 <Cale> data S s a = S (s -> (s,a)) deriving Functor
21:03:58 <ManateeLazyCat> Here is video without sound (without copyright issue):  http://www.youtube.com/watch?v=A3DgKDVkyeM , I think it can watch everywhere. Enjoy! :)
21:04:00 <bos> c_wraith: 0.11.0.0 is the new shiny, 0.10.0.1 was a booboo
21:04:11 <c_wraith> bos:  oops.
21:04:14 <Funktorsalat> Cale: yep
21:04:37 <Axman6> on ubuntu, does anyone know what package need to be installed to get ghc-7 to be able to use llvm? installing the llvm-2.8 package doesn't seem to fix the error (ghc: could not execute: opt)
21:04:43 <c_wraith> blackh probably should be told about that, as he already updated hexpat to work with the accidental api change
21:04:48 <Cale> Nice :)
21:04:55 <augur> peeps!
21:05:11 <Cale> It also manages Cont
21:05:11 <Funktorsalat> the reason I doubted it was that generics stuff tends to balk at functions normally
21:05:39 <Funktorsalat> at runtime, in case of syb, iirc :|
21:06:26 <Cale> So all the straightforward things involving functions will be okay.
21:06:47 <revenantphx> okay seriously.
21:06:52 <revenantphx> How can I implement MonadIO for this monad.
21:06:56 <revenantphx> I'm really tired of typing liftIO
21:06:58 <revenantphx> :P
21:07:11 <Cale> revenantphx: liftIO is the sole method of the MonadIO class.
21:07:15 <c_wraith> err, typing liftIO suggest that it *does* implement monadIO
21:07:19 <revenantphx> shit.
21:07:25 <Cale> revenantphx: If you're using liftIO, it means you already have a MonadIO instance.
21:07:27 <revenantphx> oh well then >_<
21:08:07 <ndrsndrs> the problem is that the functions are Stuff -> IO Thing, not MonadIO m => Stuff -> m Thing
21:08:21 <revenantphx> mm
21:08:36 * ndrsndrs waits for "there's something on hackage that fixes that!", again
21:08:40 <Funktorsalat> are there any haskell-expressible functors that aren't built from a combination of polynomial functors and functions that have the variable occuring in a positive position?
21:08:52 <revenantphx> so, if I'm doing all work on this handle within one thread here...
21:09:00 <revenantphx> should I just keep reading from the tchan till tis empty each time?
21:09:04 <djahandarie> Axman6, libllvm probably?
21:09:10 <revenantphx> And on that note, how can I loop on that?
21:09:16 <c_wraith> Funktorsalat, maybe some GADT?
21:09:19 <djahandarie> It's either that or llvm-dev
21:09:19 <lars9> c_wraith: sequence seems good
21:09:21 <dropdrive> What's the currently recommended way of parsing a binary file format (different types of packets)?
21:09:32 <revenantphx> I guess abstract it into an action.
21:09:37 <Funktorsalat> (after recursing into newtype and data fields)
21:09:38 <ManateeLazyCat> djahandarie: Do you build ghc-7 with llvm? How about it? Stable or faster?
21:09:43 <Funktorsalat> c_wraith: ah, could be
21:09:50 <revenantphx> @hackage binary attoparsec
21:09:51 <lambdabot> http://hackage.haskell.org/package/binary attoparsec
21:09:53 <djahandarie> ManateeLazyCat, nope, I haven't
21:09:55 <revenantphx> @hackage attoparsec
21:09:55 <lambdabot> http://hackage.haskell.org/package/attoparsec
21:10:09 <revenantphx> dropdrive: those are what I've been looking through for stuff
21:10:12 <ManateeLazyCat> djahandarie: I will try ghc-7 after next HP release. :)
21:10:18 <c_wraith> I don't know much about GADTs.  I can read them and work with them, but I don't know enough to know how they work, really
21:10:24 <revenantphx> Same here.
21:10:29 <dropdrive> revenantphx: Thanks, are there any examples of attoparsec in action for binary data?
21:10:38 <revenantphx> Theres an HTML parser example. :\
21:10:44 <revenantphx> HTTP*
21:10:45 <revenantphx> sorry
21:10:46 <c_wraith> attoparsec isn't designed for binary data.
21:10:52 <Funktorsalat> c_wraith: they can be reduced to existentials and type equality constraints IIRC
21:10:56 <c_wraith> it's designed for byte-oriented protocals
21:11:01 <Funktorsalat> c_wraith: that's often a good strategy for theory
21:11:06 <c_wraith> err, protocols.  my typing is horrible tonight
21:11:20 <Cale> mm, it even manages  data T a = Tip a | Branch (T (a,a))  okay :)
21:11:23 <revenantphx> http://bitbucket.org/bos/attoparsec/src/14961a428103/examples/RFC2616.hs
21:11:34 <dropdrive> c_wraith: What do you recommend for binary data?  e.g. packet size|int|short|double|string|byte|byte|byte
21:11:38 <preyalone> I can't get if blocks to work. if thePeanutButter > 0 then putStrLn "YOU BOUGHT PEANUT BUTTER!!!"
21:11:39 <Funktorsalat> existentials seem irrelevant for functors at first glance
21:11:45 <c_wraith> dropdrive: binary or cereal
21:11:58 <c_wraith> dropdrive: those being names of packages on hackage
21:12:05 <lars9> c_wraith: sequence has no insert and delete?
21:12:06 <Cale> preyalone: You're missing an 'else'
21:12:22 <Cale> preyalone: if expressions are expressions, and so they must always have a value
21:12:22 <preyalone> Cale: How can I do an empty else?
21:12:24 <dropdrive> c_wraith: Thanks
21:12:27 <Funktorsalat> hmm except if the existential is somehow coupled with the parameter (data A a = forall b. A (Foo a b))
21:12:36 <ndrsndrs> preyalone: when (condition) (action)
21:12:37 <Cale> preyalone: Put an IO action which does nothing like  return ()
21:12:41 <ndrsndrs> from Control.Monad
21:12:49 <Cale> preyalone: Or use a library function like ndrsndrs suggests :)
21:12:53 <revenantphx> What's a good way to... simulate a loop *gulp*
21:13:01 <revenantphx> I want to read things out of a TChan until its emptuyu.
21:13:03 <Funktorsalat> but then you can still apply the derivation procedure too /\ a. Foo a b
21:13:09 <preyalone> ndrsndrs: Not in scope: `when'
21:13:11 <revenantphx> Should I just use recursion with an if statement or guards?
21:13:12 <Funktorsalat> (with b now a fresh constant)
21:13:22 <preyalone> ah
21:13:31 <ndrsndrs> preyalone: import Control.Monad
21:13:32 <c_wraith> lars9: that appears to be true.  I didn't realize that.
21:14:02 <preyalone> ndrsndrs: What's the syntax? when condition expr
21:14:03 <Cale> revenantphx: Sure
21:14:30 <Cale> revenantphx: Though... unbounded-time operations in STM transactions are a bit risky.
21:14:33 <Funktorsalat> ghc refuses though: Can't make a derived instance of `Functor A':
21:14:33 <Funktorsalat>       Constructor `A' has existential arguments
21:14:46 <revenantphx> Cale: do you have a better idea?
21:14:50 <ndrsndrs> preyalone: yeah, it's just a normal function
21:14:57 <revenantphx> I just need to, at each recursive call, dequeue everything.
21:15:04 <revenantphx> How are they risky?
21:15:29 <Cale> Well, maybe you don't have another option, but long-running transactions may get trampled by smaller, faster ones and never complete.
21:15:50 <preyalone> ndrsndrs: main: Couldn't match expected type `a -> b' against inferred type `Bool' when thePeanutButter > 0 putStrLn "YOU BOUGHT PEANUT BUTTER!!!"
21:16:09 <ndrsndrs> preyalone: you need parentheses round the arguments
21:16:19 <preyalone> ah
21:16:25 <Funktorsalat> it manages nested types too data A a = A0 a | A1 (Maybe a) deriving(Functor)
21:16:28 <Cale> So, if there are other threads committing transactions to write to the TChan, then the reader might never finish, as it will have a harder and harder time getting through the entire channel before a transaction in another thread adds to it.
21:16:36 <revenantphx> Cale: When I see myself typing "liftIO . atomically" I chuckle a bit.
21:16:38 <Funktorsalat> err nvm, that isn't nested ;)
21:16:46 <revenantphx> Stacking monads... up and up we go.
21:17:02 <Funktorsalat> but this: data A a = A0 a | A1 (A (Maybe a)) deriving(Functor)
21:17:02 <lars9> c_wraith: a BST with each node storing number of children nodes, should be able to do indexing, modification etc all at log(n)
21:17:19 <Cale> revenantphx: What monad transformer over IO are you using? Is it really essential?
21:17:22 <preyalone> ndrsndrs: Couldn't match expected type `()' against inferred type `IO ()'
21:17:25 <revenantphx> Cale: yes.
21:17:33 <preyalone> and when doesn't like do blocks
21:17:40 <revenantphx> brb
21:17:46 <Cale> Er, which one?
21:18:26 <revenantphx> BinaryProtocol
21:18:36 <revenantphx> in any case, I have an interesting predicament now... which i must resolve.
21:18:40 <Cale> preyalone: when (thePeanutButter > 0) (putStrLn "YOU BOUGHT PEANUT BUTTER!!!")
21:18:50 <preyalone> Cale: Thanks dude!
21:18:51 <Cale> BinaryProtocol is hardly essential :P
21:19:08 <ndrsndrs> also, the do needs to be in brackets or have a $ before it
21:19:13 <revenantphx> Cale: well it's lets me ignore buffer management >_<
21:19:14 <revenantphx> (whew)
21:19:22 <ndrsndrs> (since `f $ g x` == `f (g x)`)
21:19:51 <Cale> revenantphx: You're exchanging passing Handles around to where you need them for applying liftIO everywhere
21:20:11 <revenantphx> Cale: and managing reads.
21:20:15 <Cale> revenantphx: hm?
21:20:29 <revenantphx> With binary-protocol I can just say 'pkt <- receive' and then do a case statement over the packet types.
21:20:34 <revenantphx> It's very very convenient.
21:20:44 <revenantphx> liftIO is a small price to pay.
21:21:41 <Cale> You could still implement a receive function which was a function of the input Handle and worked in exactly the same way
21:22:15 <djahandarie> revenantphx, l = (liftIO .) might help
21:22:31 <revenantphx> is that an l or I?
21:22:38 <djahandarie> l
21:22:41 <djahandarie> ...
21:22:42 <kadoban> haha
21:22:45 <revenantphx> ...
21:22:45 <djahandarie> I imagine that didn't help
21:22:46 <ndrsndrs> lowercase L
21:22:47 <djahandarie> L
21:23:00 <revenantphx> I imagine it would help.
21:23:31 <revenantphx> How can I perform a loop :\
21:23:36 <revenantphx> hm...
21:23:42 <revenantphx> recursion wont work here.
21:23:51 <revenantphx> well, no it can.
21:24:39 <Cale> fix $ \loop -> do ... ; loop
21:24:52 <revenantphx> fix?
21:24:53 <revenantphx> :t fix
21:24:54 <lambdabot> forall a. (a -> a) -> a
21:25:03 <Axman6> > fix error
21:25:04 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:25:07 <djahandarie> lol
21:25:08 <Axman6> fixed!
21:25:18 <revenantphx> > fix "the car"
21:25:18 <lambdabot>   Couldn't match expected type `a -> a'
21:25:19 <lambdabot>         against inferred type `[GHC.T...
21:25:19 <Cale> You could also define a recursive function in-place
21:25:26 <Cale> (or just a recursive action)
21:25:31 <ndrsndrs> Axman6: my favourite error
21:25:33 <djahandarie> revenantphx, it's the fixed point operator.
21:25:48 <revenantphx> Well, I have a TChan and I want to read things out of it into a list until it's empty.
21:25:56 <revenantphx> so it has to inside the context of the STM monad.
21:26:21 <c_wraith> reading form a TChan needs to be inside STM, but you can work with each result value outside of it
21:27:15 <Cale> fix works anywhere :)
21:27:26 <djahandarie> forever maybe be more useful for monad uage
21:27:27 <djahandarie> usage
21:27:28 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
21:27:29 <lambdabot>   3628800
21:27:43 <revenantphx> c_wraith: of course.
21:28:06 <Cale> fix (\loop n -> do print n; if n > 0 then loop (n-1) else return ()) 10
21:28:26 <revenantphx> pkts <- liftIO . atomically $ ....... 
21:28:29 <revenantphx> then do stuff with pkts
21:28:48 <revenantphx> so I need within that STM monad, to read repeatedly...
21:28:59 <revenantphx> I could lift fix I suppose.
21:29:06 <Cale> You don't need to lift fix
21:29:17 <Cale> fix just lets you do recursion in-place
21:29:26 <Cale> (without having to define a separate function)
21:29:31 <BMeph> Haskell is trouble. Usually, you need a loop to do something, and Haskell lets you just do the something, without having to set up the loop for it first. That's confusing! :)
21:30:43 <revenantphx> so wait, what is fix doing there?
21:31:01 <revenantphx> You're making the first parameter of the lambda into the function name ???
21:31:04 <revenantphx> "name"
21:31:14 <Cale> yes, sort of :)
21:31:19 <Cale> fix f = x where x = f x
21:31:29 <djahandarie> Why it works isn't immediately clear
21:31:36 <Cale> So  fix (\loop n -> do print n; if n > 0 then loop (n-1) else return ())
21:31:49 <Cale> is the function x such that  x = (\loop n -> do print n; if n > 0 then loop (n-1) else return ()) x
21:31:57 <Cale> which if we apply the lambda, gives us
21:32:09 <Cale> x = \n -> do print n; if n > 0 then x (n-1) else return ()
21:32:31 <revenantphx> hm
21:33:04 <Cale> All recursion can be encoded in terms of fix
21:33:37 <revenantphx> ok, I'm lost now trying to implement this XD
21:33:47 <Cale> Well, let's try something better
21:34:20 <revenantphx> Ok, I'm trying to implement a function in the BinaryProtocol monad
21:34:23 <revenantphx> that will do the following
21:34:41 <Cale> while p x = do b <- p; if b then (do v <- x; vs <- while p x; return (v:vs)) else return []
21:34:43 <revenantphx> 1) Retrieve from an STM monad all of the packets that were, within that transaction, in the TChan
21:34:46 <revenantphx> 2) Send them all.
21:34:50 <revenantphx> The first part idk.
21:34:56 <revenantphx> the second is a matter of forM_ or mapM_
21:34:57 <Cale> ^^ that'll also work in any monad, and gives you a while loop
21:35:15 <Cale> (which returns the results of each iteration in a list)
21:35:41 <revenantphx> Cale: any ideas for this?
21:35:48 <Cale> while (fmap not . isEmptyTChan c) (readTChan c)
21:36:02 <Cale> will produce a list of all the entries in the channel
21:36:14 <revenantphx> Is while already there, or using the one you just defined?
21:36:14 <Cale> er, oops
21:36:20 <Cale> while (fmap not . isEmptyTChan $ c) (readTChan c)
21:36:43 <Cale> Using the one I just defined
21:36:56 <Cale> The problem with while loops is that there are so many minor variations that you might want.
21:37:19 <Cale> and they're all pretty easily handled by explicit recursion anyway
21:37:34 <Cale> But sometimes it's nice to write the control structure first
21:38:07 <revenantphx> so out of curiosity, can fmap there be replaced verbatim with liftM?
21:38:11 <Cale> yes
21:38:11 <revenantphx> are they exact synonyms?
21:38:24 <ndrsndrs>  apart from the slightly different type, yes
21:38:28 <revenantphx> so...
21:38:32 <Cale> It would be considered a serious bug in STM for them to differ
21:38:36 <ndrsndrs> (one is (Monad m) =>, the other (Functor f) =>)
21:38:40 <revenantphx> Trying to see exactly how that works.
21:39:04 <dropdrive> How do I find the docs for Data.Binary?
21:39:08 <Cale> while :: (Monad m) => m Bool -> m a -> m [a]
21:39:13 <revenantphx> @hackage binary
21:39:13 <lambdabot> http://hackage.haskell.org/package/binary
21:39:29 <revenantphx> Cale: already got that.
21:40:22 <Cale> while runs its first argument to test whether to continue looping, and so long as it gets a True result, it runs the second argument, collecting the results into a list which is returned from the overall action
21:40:48 <Cale> So, we check to see if the TChan is not empty, and as long as that is the case, we read from it
21:40:55 <revenantphx> mm.
21:40:59 <Cale> and our while loop collects the results into a list for us
21:42:02 <revenantphx> so
21:42:03 <revenantphx> dequeuePackets ast@(_, pktqueue) = do
21:42:03 <revenantphx>     pkts <- liftIO . atomically $ while (liftM not . isEmptyTChan $ pktqueue) (readTChan pktqueue)
21:42:03 <revenantphx>     forM_ pkts send
21:42:11 <revenantphx> simple enough :)
21:44:31 <revenantphx> blar everything is (predictably) broken.
21:45:38 <Cale> It might actually be worthwhile to break that abstraction up and only do one emptiness-test/read per atomic transaction
21:46:00 <revenantphx> why?
21:46:16 <revenantphx> In any case I need to have it *work* first... it's not dequeueing anything for the moment
21:46:17 <Cale> Because if you have some other thread which is continually writing to that TChan, this is almost certain to livelock.
21:47:05 <Cale> Because by the time it's read all the elements off the TChan and is ready to commit, another element will have been put into the TChan, invalidating the transaction, and it'll have to retry
21:47:16 <revenantphx> Oh, I see...
21:48:06 <Cale> (and it just gets more and more likely to retry as the TChan gets longer)
21:49:13 <revenantphx> heres the code as it stands
21:49:14 <revenantphx> https://gist.github.com/726630
21:49:27 <revenantphx> It's not working, nothing is being sent from the queue apparently.
21:50:14 <revenantphx> It could be livelocking as you said, given the keepAlive, though with 1s intervals (and earlier 30s) i'd think it'd be fine.
21:51:05 <revenantphx> It claims to have dequed packets but...
21:51:08 <revenantphx> dequeued*
21:51:24 <revenantphx> I put a print and it says it got a single keep alive and a login request
21:51:35 <revenantphx> but the connection doesn't go through.
21:51:44 <revenantphx> (it hangs, meaning its not being *sent*)
21:51:45 <revenantphx> oh.
21:51:46 <revenantphx> flush
21:51:47 <revenantphx> dammit
21:52:25 <revenantphx> Grr. forked threads keep living after killing the execution in ghci
22:05:41 <revenantphx> @hoogle ByteString -> String
22:05:41 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
22:05:41 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
22:05:41 <lambdabot> Prelude show :: Show a => a -> String
22:06:34 <revenantphx> @hoogle String -> ByteString
22:06:34 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
22:06:34 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
22:06:34 <lambdabot> Prelude read :: Read a => String -> a
22:11:45 <funkyjunkyrobot> can anyone help me with prolog? the prolog channel is a ghost town.
22:14:04 <Cale> possibly
22:17:02 <adu> hi Cale
22:17:02 <lambdabot> adu: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:17:30 <Cale> hi
22:17:54 <adu> funkyjunkyrobot: i can
22:18:03 <funkyjunkyrobot> awesome
22:18:24 <funkyjunkyrobot> well here is my problem
22:20:28 <funkyjunkyrobot> i am trying to keep track of fuel, I have a FuelCap which is permanent, it represents how much fuel i can have. then i have FuelCur , it is my current fuel. essential I am traveling on a grid, if i am adjacent to a gas station i want to fill up if not, then i want to decrement my fuel by one. now I am having trouble because i don't understand how to change something once it's been bound
22:20:56 <funkyjunkyrobot> or if i even can
22:21:15 <Cale> You probably shouldn't change things even if you can.
22:21:56 <Cale> funkyjunkyrobot: What can change though is that you can apply predicates to different parameters.
22:22:16 <funkyjunkyrobot> i'm trying that 
22:22:25 <adu> funkyjunkyrobot: what is your goal?
22:22:47 <funkyjunkyrobot> i am setting a new paramater FuelNew
22:22:52 <funkyjunkyrobot> as FuelCur -1
22:23:08 <adu> ok that makes sense
22:23:09 <funkyjunkyrobot> then making the recursive call with FuelNew
22:23:15 <adu> but what is the ultimate goal?
22:23:36 <funkyjunkyrobot> well i have a grid and it has numbers in the positions
22:23:49 <funkyjunkyrobot> and it is a "train" system
22:23:52 <adu> ok
22:23:54 <funkyjunkyrobot> a 1 represents a track
22:24:08 <funkyjunkyrobot> 2 represents a depot
22:24:15 <funkyjunkyrobot> 3 represents fuelStation
22:24:29 <funkyjunkyrobot> I want to find pieces of track that cannot be reached
22:24:46 <funkyjunkyrobot>  noRepairCoverage(2, ThisRegion, Cell)
22:24:56 <funkyjunkyrobot> would be a train with fuel capacity  of 2 units
22:24:57 <adu> so are you building a linked list of grid locations?
22:25:17 <funkyjunkyrobot> well, it's prolog so, it just spits out the locations
22:25:23 <funkyjunkyrobot> my design anyway is like this
22:25:25 <adu> ok
22:25:27 <funkyjunkyrobot> i'll explain
22:25:49 <funkyjunkyrobot> I have it find a depot, and use that as a start point
22:26:10 <funkyjunkyrobot> then I have a function that will find any track, so some place in the grid that has a 1
22:26:22 <funkyjunkyrobot> then it will try to recrusively travel to that place
22:26:33 <funkyjunkyrobot> if it fails, it prints out the cell it failed on
22:26:33 <bblum> is there something similar to when that does (Maybe a) -> (a -> m b) -> m b ?
22:26:50 <funkyjunkyrobot> then backtracks and finds a new track piece and tries to go to that
22:27:20 <bblum> sorry, i guess it would have to be Maybe a -> (a -> m ()) -> m ()
22:27:34 <funkyjunkyrobot> i'm doing it in prolog. i'm in here asking questions because the prolog channel is a ghost town. 
22:27:35 <Cale> :t maybe (return ())
22:27:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
22:28:52 <bblum> Cale: that looks good; thanks
22:29:08 <bblum> not convinced it's less verbose than case-analyzing it myself though
22:30:05 <adu> funkyjunkyrobot: i see
22:30:26 <adu> so you're passing the decremented fuel as a parameter
22:30:33 <adu> that sounds like an elegant solution
22:30:35 <funkyjunkyrobot> yeah
22:30:36 <adu> what's the issue?
22:30:41 <funkyjunkyrobot> whats the link to paste code?
22:30:50 <adu> hpaste or pastie
22:30:54 <funkyjunkyrobot> k
22:32:51 <adu> er, sorry codepad.org does haskell, pastie doesn't
22:33:02 <funkyjunkyrobot> http://hpaste.org/42039/train
22:33:07 <funkyjunkyrobot> well it's prolog
22:33:17 <funkyjunkyrobot> but hpaste does prolog syntax
22:33:24 <funkyjunkyrobot> thats what i have
22:33:51 <funkyjunkyrobot> so i use route to find out if there is a possible route from my start (depot) to all track pieces
22:34:21 <funkyjunkyrobot> keep in mind though that i'm a total noob. so some of it may need clarification on what i am really trying to do :)
22:35:47 <adu> 'adjacent' makes sense
22:37:30 <funkyjunkyrobot> yeah
22:38:37 <funkyjunkyrobot> so i start by calling        setRegion(Region),noRepairCoverage(2,Region,Cell).
22:38:45 <funkyjunkyrobot> so that starts it off with a fuel capacity of 2
22:38:48 <adu> where do you use find()?
22:38:56 <adu> what that your first attempt?
22:39:01 <funkyjunkyrobot> no
22:39:04 <funkyjunkyrobot> it is used in find 2
22:39:12 <adu> oh ic
22:39:12 <funkyjunkyrobot> find searches a list
22:39:21 <funkyjunkyrobot> find2 searches a list of lists
22:39:28 <funkyjunkyrobot> so find2 calls find on all the sub lists
22:40:03 <funkyjunkyrobot> so i get 2 indexes back one from find which is my y cord, and one from find2 which is the x cord.
22:40:13 <funkyjunkyrobot> i guess thats the best i can explain that... but it works
22:40:22 <funkyjunkyrobot> i've verfied that
22:40:22 <adu> ok
22:40:27 <funkyjunkyrobot> my problem is just with fuel
22:40:41 <funkyjunkyrobot> i get stuff like 2 = 1+1  FAIL
22:40:59 <funkyjunkyrobot> so it's got to do with my weather to use is or equals
22:41:05 <funkyjunkyrobot> is or =
22:41:11 <funkyjunkyrobot> is there a good rule of thumb?
22:43:29 <funkyjunkyrobot> seems to run faster after i swap find2 and adjacent in the next predicates
22:43:34 <funkyjunkyrobot> next track and next fuel
22:46:38 <adu> well, = doesn't allow expressions
22:46:45 <adu> (is) does
22:47:13 <adu> (=:=) is used for arithmetic equality, which might be more appropriate in this case
22:49:16 <funkyjunkyrobot> at what point?
22:49:54 <funkyjunkyrobot> i think i ended up solving the issue, but there is still something else wrong... as usual, i'm tracing it right now.... :(
22:49:56 <funkyjunkyrobot> long trace
22:52:50 <lars9> @hoogle space
22:52:50 <lambdabot> Text.Parsec.Char space :: Stream s m Char => ParsecT s u m Char
22:52:51 <lambdabot> Text.PrettyPrint.HughesPJ space :: Doc
22:52:51 <lambdabot> Language.Haskell.TH.PprLib space :: Doc
22:56:56 <adu> ok
22:57:13 <adu> funkyjunkyrobot: I finally got it to run
22:57:22 <adu> it seems stuck
22:57:24 <funkyjunkyrobot> cool
22:57:32 <funkyjunkyrobot> :S
22:57:37 <funkyjunkyrobot> i knowz 
22:57:42 <funkyjunkyrobot> and i'm stuck
22:57:43 <adu> i tried: noRepairCoverage(2,_,[1,1]).
22:57:44 <funkyjunkyrobot> :)
22:58:01 <funkyjunkyrobot> ohh, u really should supply it with the middle, thats the grid
22:58:09 <funkyjunkyrobot> with no grid it just starts generating numbers
22:58:14 <funkyjunkyrobot> from 1 to forever
22:58:21 <adu> o, i guess i didn't understand %setRegion
22:58:46 <funkyjunkyrobot> setRegion just sets the region by binding the grid to Region
22:58:57 <funkyjunkyrobot> then u use Region instead of that underscore
22:59:03 <funkyjunkyrobot> and it will search the grid
23:04:48 <Saizan> i thought my irssi was confusing #haskell with #prolog
23:05:03 <adu> well I'm pretty sure its because you don't check that Ncol and Nrow are > 0 and < len
23:05:16 <adu> but i could be wrong
23:06:57 <adu> funkyjunkyrobot: but it might be that you're not printing things with findall() for example
23:07:14 <funkyjunkyrobot> what does that do?
23:07:20 <funkyjunkyrobot> same as hitting ; ?
23:07:44 <adu> i don't know, I'm not a prolog expert, I only wrote a puzzle solver in it
23:08:15 <funkyjunkyrobot> where did u see the unchecked Ncol Nrow?
23:08:23 <adu> everywhere
23:08:29 <funkyjunkyrobot> :)
23:08:35 <adu> where do you see a checked col/row?
23:08:46 <funkyjunkyrobot> well
23:08:52 <funkyjunkyrobot> didn't think it was necesary
23:09:00 <funkyjunkyrobot> it comes from the grid, so it can't be out of bounds
23:09:24 <adu> funkyjunkyrobot: I also think you should be building a linked list of grid points, because that way you won't overlap
23:09:41 <funkyjunkyrobot> of places i've visited?
23:09:44 <funkyjunkyrobot> or what?
23:09:48 <adu> yes
23:09:48 <funkyjunkyrobot> cuz i am doing that
23:10:09 <funkyjunkyrobot> in route
23:10:29 <funkyjunkyrobot> it tacks on to visited all the intermediate cells
23:10:47 <adu> oh in route()
23:10:54 <funkyjunkyrobot> and it checks that Via is not a member of visted before it recurses further
23:11:08 <funkyjunkyrobot> route is doing the walking here
23:11:13 <adu> but you don't check that Cell is not in Visited
23:11:15 <funkyjunkyrobot> it is actualy going through the list
23:11:26 <adu> oh the not(member()) duh
23:11:27 <funkyjunkyrobot> not(member(Via,Visited)),
23:11:31 <funkyjunkyrobot> :)
23:11:37 <funkyjunkyrobot> so what is happening w/ route is this
23:11:40 <adu> i must be a noob
23:11:43 <funkyjunkyrobot> i give it a start and end point
23:11:52 <funkyjunkyrobot> if the start is adjacent to end point, success
23:12:21 <funkyjunkyrobot> else, it find an adjacent piece to the start and see's if that adjacent piece "Via" is adjacent to end, if not it finds and adjacent piece to Via recursively
23:12:46 <funkyjunkyrobot> until it hits a via that is adjacent to the end, and at that point, visited is populated with the route
23:13:06 <adu> oh, sounds like a depth-first problem
23:13:24 <funkyjunkyrobot> so the base case of route is hit, and Route gets the list of visted with End tacked on the front
23:13:28 <funkyjunkyrobot> yeah pretty much
23:13:38 <funkyjunkyrobot> tracing this shit sucks the big one
23:13:50 <adu> although that should be solved with FuelNew > 0, which you do check for
23:14:04 <funkyjunkyrobot> yeah
23:14:22 <funkyjunkyrobot> here is a link to the specs if u wana read it and get a visual
23:14:35 <adu> i think i need sleep
23:14:39 <funkyjunkyrobot> http://cse.unl.edu/~jsukup/4-4.pdf
23:14:40 <funkyjunkyrobot> ok
23:14:45 <funkyjunkyrobot> thanks for your efforts
23:15:12 <funkyjunkyrobot> that is something i will not be getting any of tonight :)
23:15:16 <adu> i wish i could take that class
23:15:28 <funkyjunkyrobot> it's programming languages concepts
23:15:38 <funkyjunkyrobot> they throw a new language at us every couple weeks
23:15:41 <adu> Prolog is a good choice then
23:15:43 <funkyjunkyrobot> last one was haskell
23:15:51 <adu> also good
23:16:05 <funkyjunkyrobot> thats when i realized this channel is full of awesome people who just enjoy programming
23:16:15 <funkyjunkyrobot> and helping each other learn
23:16:19 <funkyjunkyrobot> :)
23:16:25 <funkyjunkyrobot> prolog channel is dead...
23:17:06 <adu> I also recommend Oz, Funge, Io, SQL, Regex, and Unlambda
23:17:15 <djahandarie> lol.
23:17:37 <funkyjunkyrobot> k
23:18:08 <adu> can you guess which ones are standardized?
23:19:16 <djahandarie> I recommend Cayenne, Agda, Idris, Coq, and Epigram. Note that I have very little experience with any of these. But they are on my "slowly process these" list atm. ;)
23:19:28 <adu> I like Coq
23:19:35 <adu> er i mean good choices
23:19:59 <augur> byorgey!
23:20:23 <adu> Haskell was on my list 10 years ago
23:25:58 <adu> augur: where?
23:26:11 <augur> adu: what?
23:26:30 <adu> augur: who?
23:26:40 <augur> adu: what are you asking me
23:26:58 <adu> byorgey doesn't appear to be here
23:27:08 <augur> he's in the channel
23:27:41 <adu> by "here" i mean active
23:27:56 <adu> anyways, n/m igtg sleep
23:28:00 <augur> yes, this seems to be true
23:32:12 <funkyjunkyrobot> ?
23:59:27 <dskippy> I am drawing to a drawarea in gtk2hs  but when the window is resized the image goes away. Anyone know the signal to listen to to redraw it? I guess that's more of a GTK channel question but no one in there is awake.
