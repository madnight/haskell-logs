00:29:34 <handonson> http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Windows-Dialog.html "dialogNewWithButtons is recommended" and where is dialogNewWithButtons?
00:34:02 <paolino> hi, is there a simple reason why TypeRep is not instance of Ord ?
00:35:28 <c_wraith> paolino, there's no natural meaning of Ord for TypeRep, especially since mkTypeRep is impure.
00:36:13 <c_wraith> Any implementation would have to be completely arbitrary.  Meaning it could be used as keys for Data.Map, I suppose, but sort would be totally meaningless.
00:37:59 <c_wraith> I wonder what TypeRep looks like on the inside.  Probably has a counter field for determining actual type equality, which is the value initialized impurely.
00:38:53 <paolino> c_wraith, ok, I will go with O (2) nub and such, it's not actually a problem of runtime complexity
00:39:44 <paolino> probably sorting on instance of Show would do
00:40:23 <handonson> speaking of which, why is Bool an instance of Ord?
00:40:28 <c_wraith> just be aware that Show results needn't be unique for distinct TypeReps
00:40:40 <paolino> sure
00:40:42 <kmc> paolino, i've used that before
00:41:04 <kmc> :t compare `on` show
00:41:05 <lambdabot> forall a. (Show a) => a -> a -> Ordering
00:41:44 <paolino> handonson also of Enum
00:41:50 <c_wraith> yeah, looks like TypeRep contains a newtyped Int value that's initialized impurely.
00:42:15 <paolino> c_wraith: Data.Typeable.Key ?
00:42:18 <c_wraith> yeah
00:43:05 <paolino> well , in some way nub and company just fight purism, they don't need it
00:44:01 <handonson> once I harshly criticized Python for False + True = True (historical reason), then my friend showed me False < True = True in Haskell ... I was so embarrassed
00:44:29 <paolino> handonson: looks different
00:44:34 <kmc> i don't think those are the same
00:44:52 <Asdf765> Hey anyone know if I can use this old 40gb hard drive with my new am3 socket motherboard?
00:44:58 <kmc> Asdf765, not the place to ask
00:45:02 <handonson> i believe that coders shouldn't be comparing the greatness of boolean values
00:45:03 <kmc> this is a channel about the programming language Haskell
00:45:15 <Asdf765> I see...
00:45:21 <kmc> handonson, plenty of Ord instances are essentially arbitrary
00:45:39 <handonson> you know, false is not 'less' than true
00:45:39 <kmc> do you also object to Ord Char?
00:45:43 <kmc> what about (Ord a) => Ord (Maybe a)
00:45:49 <handonson> it's just... not true
00:46:02 <kmc> > Nothing < Just 3
00:46:03 <lambdabot>   True
00:46:52 <kmc> > '!' < '3'
00:46:53 <lambdabot>   True
00:46:56 <kmc> that seems pretty arbitrary too
00:47:20 <handonson> yeah. i think i object to Ord Char too.
00:47:23 <kmc> what about the tuple and list instances? who's to say you wanted left-to-right lexical ordering?
00:47:49 <kmc> and of course Double and Float are *totally* invalid
00:47:52 <kmc> because of NaN and such
00:48:13 <handonson> and that Maybe instance is... what the... why why why would.. what the hell
00:48:24 <paolino> the unorderable brigade on show
00:48:31 <kmc> so in your Prelude, we have Ord Int and Ord Integer
00:48:33 <kmc> and that's about it
00:48:38 <kmc> maybe Ord () is uncontroversial enough
00:49:15 <kmc> and really Int is a stupid abstraction leak, and shouldn't be in Prelude
00:49:49 <paolino> so class Integer where compare ....
00:50:03 <handonson> i partially agree to that
00:50:16 <handonson> i don't even like the int in C
00:50:24 <kmc> it fits with the idea of C
00:50:27 <kmc> a low level systems language
00:50:36 <handonson> i always use the int32_t stuff
00:50:37 <kmc> it's a bad fit as a default in Haskell
00:51:11 <kmc> and of course Int32 should be renamed to FiniteFieldOfOrder2toThe32
00:51:16 <kmc> just like [a] should be renamed to FreeMonoid a
00:51:35 <sipa> but it is not a field
00:51:55 <sipa> it is a ring, no?
00:52:20 <kmc> you're right
00:52:26 <handonson> then what should [a] be
00:52:43 <handonson> Data.Sequence?
00:52:56 <kmc> and Monad should be renamed to EndofunctorCategoryMonoidObject
00:54:29 <handonson> so that MonadIO will be EndofunctorCategoryMonoidObjectInputOutput?
00:54:54 <kmc> no, we need a more mathy term for Input / Output
00:55:29 <kmc> anyway these steps are necessary, as Haskell has become too accessible
00:55:58 <kmc> :)
00:56:07 <kmc> must sleep ttyl
00:56:21 <handonson> * applause *
00:56:22 <ion> NonDeterminismAndSideEffects
00:56:39 <handonson> Ion
00:57:13 <handonson> hmm, maybe that's sciency rather than mathy
01:09:49 * hackagebot blaze-builder 0.2.0.3 - Efficient construction of bytestrings.  http://hackage.haskell.org/package/blaze-builder-0.2.0.3 (SimonMeier)
01:13:01 <dmwit> Oh, Stack Overflow.
01:13:10 <dmwit> Q: "How can you tell if someone is a programmer?"
01:13:17 <dmwit> A: "They aren't. This method is 99% accurate."
01:13:52 <dolio> I think the programming reddit is the place to go if you want to learn to identify programmers.
01:13:55 <dolio> Especially elite ones.
01:20:29 <kalven> or the ones who like to consider themselves elite
01:24:49 <dolio> Well, I hear they have lots of articles about elite programmers.
01:24:57 <dolio> And how to tell if you are one.
01:37:01 <kurenai> an obscure term like this surely needs a lot of different explanations.
01:41:41 <aleator> Hi, remind me again how to fix this so it doesn't eat all the memory: "(flip mapM) (\i->do {bigData <- load i; let c = complicatelyCalculate bigData; return abs(c)})?
01:42:48 <c_wraith> uh.  c is something like Int or Integer?
01:43:05 <aleator> c is some small datatype like int
01:43:28 <c_wraith> I think you just want like...  return $! abs c
01:43:40 <c_wraith> that forces the evaluation of c
01:44:05 <c_wraith> also, flip mapM = forM
01:44:05 <aleator> Ok. And if I change c into a tuple?
01:44:20 <Jafet> That doesn't eat any memory, it's all eaten by main!
01:44:21 <c_wraith> Then you'll need to force each component of the tuple.
01:44:46 <aleator> is `using` rdeepseq proper way to do this?
01:45:19 <c_wraith> if you want to go that way, I'd use tuple `deepseq` return tuple
01:45:36 <c_wraith> @src $!
01:45:37 <lambdabot> f $! x = x `seq` f x
01:45:58 <c_wraith> As you can see, it's basically the deepseq expansion of return $! foo
01:46:05 <Jafet> I doubt forcing at this code would do much for whatever specific memory problem aleator is having.
01:46:25 <c_wraith> Jafet, do you know more about the problem than aleator has posted?
01:46:55 <c_wraith> Because what was posted right there is very much "the values in the list aren't being forced, so all the data is being held in memory"
01:47:03 * hackagebot haskell-mpi 0.5.0 - Distributed parallel programming in Haskell using MPI.  http://hackage.haskell.org/package/haskell-mpi-0.5.0 (DmitryAstapov)
01:47:45 <aleator> Jafet: I'm quite sure that the problem is what c_wraith said.
01:48:13 <aleator> Jafet: Since print c does fix things
01:48:38 <Jafet> Do you? I wonder if complicatelyCalculate [sic?] bigData isn't going to cause allocation by itself
01:49:22 <aleator> Well, if it does, then forcing c would still fix it, right?
01:49:29 <Jafet> Fix what, exactly?
01:49:45 <c_wraith> Jafet, doesn't really matter if it does.  The issue is that in the code there, it the calculation isn't forced, so the closure retains bigData
01:50:01 <aleator> Jafet: Fix the program so it does not eat all the memory.
01:50:09 <c_wraith> Whereas if the calculation is forced before the action can be sequenced, bigdata can be released
01:50:57 <Jafet> Well, in response to c_wraith's earlier question, I know next to nothing about your code. If forcing c fixes it, that's great
01:51:13 <Jafet> Though I would guess it's something related to your previous questions here
01:51:17 <c_wraith> also, I'm failing at typing, so it's time to sleep
01:52:17 <aleator> Jafet: Well, it is related to this datacube processing, yes. But deducing from the fact that print is enought cause it run nicely, I would deduce that major part of the problem is retaining bigDaa
01:52:51 <aleator> Jafet: If you're interested, I did manage to load the datacube in reasonable time by just converting bytestring to an array and then fiddling the bits in place.
01:52:58 <Jafet> If your specific issue is that your map reads all the bigData before processing any of it, you might look at sequence.
01:53:01 <Jafet> :t sequence
01:53:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:53:16 <c_wraith> Jafet, that's...  identical
01:53:23 <c_wraith> mapM = sequence . map
01:53:35 <c_wraith> well.  sorta.
01:53:41 <c_wraith> mapM f = sequence . map f
01:53:46 <c_wraith> to be correct :)
01:54:02 <Jafet> Oh, so it is. Then I continue to wonder what exactly this "memory problem" is.
01:54:35 <c_wraith> the problem is that sequence binds each action before returning
01:54:51 <aleator> Jafet: IO action has to load a big hunk of data. Then pure calculation is done. Except that it is lazy, so it returns thunk for it and does not release the big chunk of data.
01:54:57 <c_wraith> So it's impossible to consume the result of it lazily in a monad that has bind strict in the first argument of >>=
01:55:33 <yitz> @pl let mapM f = sequence . map f
01:55:34 <lambdabot> (line 1, column 30):
01:55:34 <lambdabot> unexpected end of input
01:55:34 <lambdabot> expecting variable, "(", ".", "`", "!!", operator, ";" or "in"
01:55:39 <c_wraith> sequence isn't lazy unless >>= is lazy in its first argument
01:55:53 <yitz> @pl let mapM f = sequence . map f in mapM
01:55:54 <lambdabot> (sequence .) . map
01:56:42 <c_wraith> So, sequence results in executing all the IO actions.
01:56:46 <c_wraith> But return is lazy
01:56:59 <c_wraith> so the calculations using the data from the IO actions aren't performed
01:57:20 <c_wraith> So the result is that you have everything in memory until the values in the list are forced
02:02:07 * hackagebot packdeps 0.0.1 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.0.1 (MichaelSnoyman)
02:03:13 <romildo> Hi.
02:07:32 <romildo> I am using getDirectoryContents to get a list of the names of the files in a directory, but the file names are damaged regarding accented characters like 'á' and 'õ'. It seems that the function is not correctly encoding the UTF-8 file names. Any clues?
02:09:25 <quicksilver> romildo: which OS?
02:10:14 <romildo> quicksilver,  Gentoo Linux. The file system uses unicode and encode file names in utf-8.
02:10:44 <quicksilver> romildo: actually, you're wrong.
02:10:53 <quicksilver> romildo: linux filesystems do not use unicode.
02:11:00 <quicksilver> linux filesystems have paths which are named in bytes.
02:11:11 <quicksilver> not characters, and with no encoding information :)
02:11:14 <DL> If "abc" is just a list of chars, why cant I execute    > intersperse "-" "abc" ?
02:11:37 <danr> @type intersperse
02:11:38 <lambdabot> forall a. a -> [a] -> [a]
02:11:43 <quicksilver> Gnome (and, for all I know, KDE) make the convention to interpret these bytes as UTF-8
02:11:47 <dolio> Because you can't do intersperse [1] [1,2,3], either.
02:12:05 <DL> But I can do intersperse "-" ["a", "b", "c"] ?
02:12:20 <freiksenet> DL: you need to use char, not string
02:12:21 <mux> :t intercalate
02:12:22 <lambdabot> forall a. [a] -> [[a]] -> [a]
02:12:28 <quicksilver> yes. And also intersperse '-' "abc"
02:12:44 <mux> > intercalate "foo" ["a", "b", "c"]
02:12:45 <lambdabot>   "afoobfooc"
02:13:07 <quicksilver> romildo: so, the root problem here is that POSIX/Linux makes no guarantees what the bytes in file paths represent, so there doesn't seem to be a standard 'right thing' for GHC to do.
02:13:32 <DL> thx quicksilver
02:13:34 <romildo> quicksilver, ok. But how can I get those paths encoded using utf8 in the result of getDirectoryContents ?
02:13:36 <quicksilver> romildo: there should probably be a way to explicitly set the encoding to use, but for now, decode UTF8 manually (and be aware your program might now be broken on windows + osx)
02:15:07 <quicksilver> romildo: you'll have to decode yourself.
02:16:28 <romildo> quicksilver, my application should be run also in Windows.
02:17:38 <romildo> quicksilver, will I have to detect myself the environment the program is being run, and decide what to do with the result of getDirectoryContents, if it should be decoded or not?
02:18:15 <quicksilver> romildo: I believe so. I don't know what getDirectoryContents does on windows in dact.
02:18:18 <quicksilver> fact.
02:19:02 <romildo> quicksilver, the standard library could have a way of detecting the OS and give the result taking it into account. In Linux it could use the locale settings for deciding how to decode the file names.
02:19:16 <quicksilver> romildo: it coukd.
02:19:21 <quicksilver> romildo: of course, that would be wrong.
02:19:33 <quicksilver> romildo: because two users of the system might have different locales and be accessing shared files
02:19:38 <quicksilver> but still, you could do it ;)
02:20:52 <quicksilver> romildo: http://hackage.haskell.org/trac/ghc/ticket/3307
02:20:58 <romildo> quicksilver, so, in practice, how would I solve this problem?
02:20:59 <augur> heyo
02:21:26 <quicksilver> romildo: in practice, you consider what your target audience will be doing in practice, decode manually and if necessary make the encoding used user-configurable.
02:21:40 <quicksilver> (and you'll have to experiment on windows because I don't know what it does)
02:25:44 <Eelis> what are "extensible records"? i found http://hackage.haskell.org/trac/ghc/wiki/ExtensibleRecords which points to various proposals of complex features and whatnot, but fails to succinctly state what the problem is that extensible records solve
02:26:17 <quicksilver> Eelis: normally it means something like formalised duck-typing on records.
02:26:36 <quicksilver> Eelis: so you can have a function which accepts "any record which defines at least the fields x :: Int and y :: Int"
02:26:44 <Eelis> oh, like in ocaml?
02:26:47 <quicksilver> right.
02:26:51 <Eelis> ah, i see. thanks
02:27:06 <Eelis> i never liked that anyway, so i guess i can safely ignore all this talk about extensible records then :)
02:36:05 <kowey> what does "fval[3] is not in the data" mean in hpaste?
02:36:29 <quicksilver> I think it means you didn't fill in one of the fields/popup menus
02:36:37 <quicksilver> although I managed to get hpaste confused the other day and couldn't fix it
02:36:48 <quicksilver> (except by going back to hpaste.org nd trying again)
02:37:42 <augur> ezyang: as a visual thinker, i have to say, hooray pictures
02:37:45 <kowey> I've filed https://github.com/chrisdone/amelie/issues/issue/2
02:41:48 <quicksilver> kowey: and you got an instant answer. THat's what I call service!
02:41:50 <kowey> wow, that's some fast response... was a regression introduced a couple of days ago
02:42:11 <cts> I get a Bus error from "Numeric.LinearAlgebra.Tests.runTests 20".  What does that mean?
02:43:10 <ian_mi> Hi, I am using accumArray to create a histogram but am getting stack overflows with large arrays. I tried using seq in my accumulation function but that doesn't seem to help. Is there a way to create large arrays safely?
02:43:51 <kowey> funny, could have sworn I built gitit 0.7.3.8 just fine on a different machine last night: https://gist.github.com/734584
02:49:20 * hackagebot haskell-mpi 1.0.0 - Distributed parallel programming in Haskell using MPI.  http://hackage.haskell.org/package/haskell-mpi-1.0.0 (DmitryAstapov)
02:57:45 <handonson> it seems most widget events in Graphics.UI.Gtk has type of EventM e Bool ... what does this Bool return value do?
02:59:37 <mux> it means the event handler has to return a Bool value
02:59:43 <handonson> yeah i know
02:59:49 <handonson> but what does that value do?
03:00:09 <handonson> what happens if i return True? what about False? what difference does it make?
03:00:13 <mux> a value does nothing; now, if you want to know what will be the effect of returning either True or False, it depends on the event handler
03:00:35 <mux> returning False is often used to tell gtk to ignore the event
03:01:01 <handonson> hmm, okay
03:01:05 <handonson> thanks
03:09:50 <cts> Here are details to the bus error with hmatrix / Numeric.LinearAlgebra.Tests.runTests:
03:09:52 <cts> http://hpaste.org/42181/bus_error_with_hmatrix
03:09:54 <cts> My question is, how to pinpoint what causes the error.
03:09:56 <cts> Google with keywords hmatrix bus error haskell didn't help.
03:09:58 <cts> I don't want to file a bug to hmatrix without being sure that it's actually in there.
03:10:01 <handonson> apparently returning True means the handler has done all the handling
03:10:28 <handonson> returning False means the widget should get the event as well
03:13:33 <Trying2LearnHask> hello can anyone help me with this http://pastebin.com/ctxTgqMb ??? 
03:20:03 <int-e> Trying2LearnHask: What are you trying to do there? What are cages, and what are positions?
03:20:14 <cts> Wow, the bus error does not appear, when I compile a litte program with ghc and run the tests from there.  See http://hpaste.org/42182/bus_error_with_hmatrix_annota
03:21:23 <Trying2LearnHask> int - e: sorry, this is from a kenken puzzle 
03:21:36 <Trying2LearnHask> do u know about kenken
03:21:53 <int-e> cts: it's possible that the bus error only happens during GC -- try System.Mem.performGC
03:22:37 <Trying2LearnHask> Int-e : kenken is like sudoku, in some ways 
03:23:18 <Trying2LearnHask> int-e: my is a 1D grid though
03:24:00 <aleator> cts: os x?
03:24:20 <cts> aleator: I use ubuntu 10.10.
03:24:24 <int-e> Trying2LearnHask: I found out what it is. So I guess I see what you're asking now. What does it have to do with Haskell?
03:24:51 <aleator> cts: ah. I just run into os x specific bus errors every now and then.
03:25:35 <Trying2LearnHask> int-e: I have a 1D kenken solver which does the job, but I need to modify it to do couple of things in Haskell
03:25:59 <Trying2LearnHask> Int-e would u like to c what I have so far
03:26:08 <cts> int-e: I can call performGC from in ghci and in the little program without any bus error.
03:26:26 <cts> int-e: And I cannot get it between runTests and the bus error.
03:27:11 <cts> int-e: Maybe I didn't understand what you suggest.  Can you be more specific, please?
03:27:16 <int-e> cts: you might try  runTests >> putStrLn "blah" >> performGC >> putStrLn "blub"
03:28:22 <int-e> Trying2LearnHask: so in "Cage 4 Multiply [2, 4]", [2,4] are the candidate numbers? But then why is [1,4] a solution?
03:28:49 <int-e> Trying2LearnHask: or is [2,4] the set of positions?
03:29:38 <Trying2LearnHask> int-e: the set of positions
03:29:59 <cts> int-e: Hm, same result as before.  But GC can still be between runTests 20 and putStrLn "blah", can't it?
03:31:45 <Trying2LearnHask> so [2,4] are positions of a Cage where I must mult permutation of values that equal 4
03:31:49 <int-e> cts: Perhaps. But maybe GC is not the trigger at all. It's just something that happens in ghci but not as much in compiled programs. Another difference is that ghci implements its own linker. That may break things as well.
03:32:38 <int-e> > filter ((4 ==) . product) $ replicateM 2 [1..5]
03:32:39 <lambdabot>   [[1,4],[2,2],[4,1]]
03:33:19 <cts> int-e: I see.  Do you have an idea how to nail down the linker?
03:35:28 <int-e> cts: oh and another difference: ghci uses the threaded RTS by default, while programs compiled with ghc use the non-threaded one.
03:35:32 <int-e> cts: sadly, no
03:37:52 <Trying2LearnHask> int-e: here is everything I am trying to do http://pastebin.com/YQC7qRZi ... I have some of this I think 
03:38:27 <cts> int-e: What does RTS mean? (I found out GC = garbage collection only with help of the package you named. :-)
03:38:38 <int-e> cts: RTS = run time system
03:39:35 <quicksilver> int-e, cts : in particular, compiled with GHC your are running in the main C thread, in ghci you are definitely *not* the main C thread.
03:39:42 <int-e> cts: you can link with the threaded RTS by using  ghc -threaded  ... but it may have no effect on your tests, because the main thread is bound.
03:39:45 <quicksilver> that can cause a bus error in broken^W non-thread-safe C libraries.
03:40:34 <quicksilver> I wouldn't be entirely suprised if the C lirbaries hmatrix uses are not thread-safe
03:42:51 <cts> int-e quicksilver: No, the -threaded option to ghc does not lead to the bus error.
03:48:14 <quicksilver> cts: yeah, but that's not enough.
03:48:24 <quicksilver> just using '-threaded' doesn't put you not-in the main thread.
03:49:11 <aristid> Haskell is the #15 most popular language on GitHub (before Erlang and Scala and Clojure): https://github.com/languages/Haskell
03:49:16 <Zvpun> "[1] ++ (return 2)" gives [1,2] and "return 2" gives 2. I am confused. I looked at ":t return" it says "(Monad m) => a -> ma" which has the scary Monad m in it that frightens me ...
03:50:19 <aristid> oh, and also before common lisp :D
03:50:45 <cts> quicksilver: Hm.  How do I get out of the main thread?
03:51:33 <cts> int-e quicksilver: And besides, can you reproduce the error?
03:51:35 <Boxo> Zvpun, no, "return 2" gives [2]
03:51:56 <Boxo> > return 2 :: [Int]
03:51:57 <lambdabot>   [2]
03:52:05 <Zvpun> Boxo: but when I type "return 2" into ghci it says 2 and not [2]
03:52:09 <Boxo> > return 2
03:52:11 <lambdabot>   No instance for (GHC.Show.Show (m t))
03:52:11 <lambdabot>    arising from a use of `M3491212227...
03:52:13 <quicksilver> you need to run with +RTS -N2 and use forkIO
03:52:26 <Boxo> really..?
03:52:29 <int-e> cts: I haven't tried.
03:53:18 <Zvpun> Boxo: well yes
03:53:31 <Zvpun> Boxo: how sure can a learning person be?
03:53:49 <Boxo> How weird. But rest assured "return 2" actually is [2] :P
03:54:01 <sipa> since [] is a monad, it can be
03:54:17 <sipa> the type return gives you depends on what you want
03:54:17 <Boxo> yes
03:54:18 <ion> zvpun: For [1] ++ (return 2) the definition of return for the list monad is used. For ‘return 2’ in the ghci prompt, some other version happens to be used.
03:54:26 <int-e> > (return 2 == Just 2, return 2 == [2], return 2 == Right 2)
03:54:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
03:54:27 <lambdabot>    `Control.Monad.Error.Cla...
03:54:29 <sipa> > (return 2) :: Maybe Int
03:54:30 <lambdabot>   Just 2
03:54:32 <int-e> aww
03:54:34 <sipa> > (return 2) :: [Int]
03:54:35 <lambdabot>   [2]
03:54:44 <sipa> > (return 2) :: Either () Int
03:54:45 <lambdabot>   No instance for (Control.Monad.Error.Class.Error ())
03:54:45 <lambdabot>    arising from a use ...
03:54:52 <sipa> > (return 2) :: Either Int ()
03:54:53 <lambdabot>   No instance for (GHC.Num.Num ())
03:54:53 <lambdabot>    arising from the literal `2' at <intera...
03:54:57 <sipa> bleh
03:55:03 <ion> Prelude> return 2 :: IO Int
03:55:03 <ion> 2
03:55:06 <ion> Perhaps this one.
03:55:12 <int-e> > return 2 :: Either String Int
03:55:13 <lambdabot>   Right 2
03:55:29 <Jafet> Monad has kind *->*
03:55:40 <Jafet> So (Either String), and fail
03:55:41 <int-e> (stupid Error constraint. but it's interesting that () has no Error instance.)
03:55:55 <Zvpun> See, this is why I am so scared of the word Monad. Damit this is the second time haskell tricked me badly when I tried to learn something.
03:56:11 <Boxo> > do {x <- return 1; y <- return 2; return $ x+y}
03:56:12 <lambdabot>   No instance for (GHC.Show.Show (m a))
03:56:12 <lambdabot>    arising from a use of `M8417326313...
03:56:12 <Jafet> Okay, a Monad instance has kind *->*
03:56:23 <Boxo> in ghci, that shows "3"!
03:56:58 <Boxo> ghci can "show monads" :o
03:57:03 <int-e> Monads are cute fuzzy things. cf. http://en.wikipedia.org/wiki/File:STTroubleTrib.jpg ;)
03:57:58 <Boxo> Zvpun, well, rest assured anyway that the "2" that it shows when you type "return 2", and the 2 that is shows when you type "1+1" are different. Pretty confusing that it shows them as the same.
03:58:07 <quicksilver> Boxo: ghci "tries" various types for the things you type into it.
03:58:16 <quicksilver> Boxo: it tries "some Show type"
03:58:22 <quicksilver> Boxo: but it also tries "IO action"
03:58:39 <quicksilver> return 2 got typed as IO Integer
03:58:45 <Jafet> ghci's magic extra defaulting is documented in the ghc manual
03:58:48 <Boxo> Oh, that makes sense
03:58:48 <quicksilver> ...and then ghci prints the results of IO actions.
03:58:56 <quicksilver> Jafet: this isn't (just) defaulting, though
03:59:10 <quicksilver> this is also ghci's dual-purpose "expression as well as IO-action repl"
03:59:20 <Zvpun> Boxo: yes, yeah hell I might quote you to my friend as "the 2 is different from the 2=1+1", hell yeah.
03:59:38 <Zvpun> Boxo: thank you though
03:59:59 <Jafet> I think the manual also mentions how it interacts with IO there
04:00:01 <Boxo> Zvpun: it's like how "print 2", it's different from "1+1"
04:00:51 <Zvpun> Boxo: how? And how can I tell when its 2 and when its [2]
04:00:58 <Boxo> you can type "print 2" to ghci, it gives you back 2, but it's not the same as typing in "1+1" and getting back "2"
04:01:09 <Boxo> well
04:01:22 <Boxo> > return 2 :: [Int]
04:01:23 <lambdabot>   [2]
04:01:40 <ion> > return 2 :: IO Integer
04:01:41 <lambdabot>   <IO Integer>
04:01:41 <Zvpun> okay so i can force it with []
04:01:44 <Jafet> Boxo: try investigating what happens to the variable it.
04:01:45 <Boxo> put (:: [Int]) after it. If you are using lists and Ints that is.
04:01:55 <Zvpun> sorry with ::
04:02:01 <Zvpun> thanks
04:02:07 <Zvpun> and how is print 2 different from 1+1
04:02:17 <Jafet> Err, zvpun can investigate that too
04:02:28 <quicksilver> "print 2" is the action which prints the number 2 to standard output
04:02:39 <quicksilver> "1+1" is merely the number 2, as a mathmatical notion.
04:02:41 <Boxo> "print 2" is an IO action, an IO command, that prints the string "2". "1+1" is an expression that evaluates to 2.
04:03:02 <Boxo> it's an inconvenient coincidence that ghci shows them identically
04:03:04 <Zvpun> okay, at least I get some basic understanding now
04:03:41 <Zvpun> thanks
04:03:45 <Zvpun> got to go
04:15:43 <cts> quicksilver: The forkIO took me some while to grasp, but I think I got it working.
04:15:45 <cts> http://hpaste.org/paste/42181/bus_error_with_hmatrix_annota#p42183
04:15:47 <cts> Unfortunately, it does not reproduce ghci's bus error.
04:21:23 <cts> quicksilver int-e: Thank you two a lot, I learned something about ghc, ghci, GC, RTS, threads and forks.  But I think I'll leave the bus error as it is for now and simply use ghc.
04:27:18 <_oggy> hi, i'm trying not to export certain names from a module: http://hpaste.org/42184/name_hiding
04:27:33 <_oggy> but i can still access, say "q" and "Q" constructor from ghci
04:27:42 <int-e> cts: seems to work here, in ghci. (ghc-6.12.3, x86, lapack 3.2.2-1.2, blas 1.2-8, gsl0-1.14+dfsg-1. (debian unstable))
04:45:28 <handonson> does Socket (not Handle) have concept of BufferMode?
04:46:28 <quicksilver> handonson: no.
04:46:38 <quicksilver> handonson: the BufferMode stuff is all done in the Handle mode
04:46:44 <quicksilver> Handle layer, I mean
04:47:54 <handonson> I'm using Sockets (to send/receive ByteStrings) and the code works fine when I interpret it, but it seems to buffer at some point when I compile/execute it
04:49:43 <int-e> handonson: have you tried compiling with -threaded?
04:50:23 <handonson> ...oh.
04:54:05 <cts> int-e: Hm.  I used ghc-6.12.1.  Maybe it's that.  Can cabal update ghc, too?
04:56:02 * hackagebot delimited-text 0.2.0 - Parse character delimited textual data  http://hackage.haskell.org/package/delimited-text-0.2.0 (StefanKersten)
05:00:05 <int-e> cts: no, it cannot. The usual advice is to download a Haskell platform binary if your distribution does not provid you with up-to-date packages ( http://hackage.haskell.org/platform/ ).
05:05:04 * hackagebot stm-io-hooks 0.7.1 - An STM monad with IO hooks  http://hackage.haskell.org/package/stm-io-hooks-0.7.1 (PeterRobinson)
05:11:06 * hackagebot threads 0.4 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.4 (BasVanDijk)
05:16:31 <Xilon> @hoogle m a -> m b -> m a
05:16:31 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
05:16:31 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
05:16:31 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
05:19:33 <Xilon> Hmm, is a Monad always a Functor? The definition doesn't appear to enforce this.
05:19:49 <sajkr> is there a floor function of type Floor -> Floor?
05:20:47 <hpc> @hoogle Floor
05:20:47 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
05:21:11 <sajkr> i understand that it's sometimes nice that floor/ceil/round return integral types...
05:22:02 <sajkr> ... but i really hate writing fromIntegral . floor, and i'm not quite sure that the compiler can figure out to skip the whole pointless conversion to an int.
05:23:07 <Xilon> @src (<*)
05:23:07 <lambdabot> (<*) = liftA2 const
05:23:35 <cts> Xilon: http://learnyouahaskell.com/a-fistful-of-monads#the-monad-type-class says that Monads were introduced to haskell first.  We suffer from tradition / backwards compatibility here.
05:23:49 <sajkr> as far as i can remember from my C days, float->int and int->float conversions end up as slow piles of instructions.
05:24:44 <sajkr> and i need to use floor to map unboxed vectors of floats.
05:24:58 <hpc> sajkr: indeed; float is a horrid cespool of a format
05:25:06 <Twey> :t floor
05:25:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:25:14 <cts> sajkr: Why don't you just define the function you want to have? One line with ifloor = fromIntegral . floor suffices.
05:25:15 <Twey> sajkr: That's not an Int, it's an Integral
05:25:44 <Twey> sajkr: There's no type specified there, so the result will never be converted to a specific Integral type
05:25:47 <xplat> yes, backward compatibility is the reason.  unfortunately typeclasses don't let you introduce new base classes in a nice and backward-compatible way.
05:26:01 <Xilon> cts: Yeah thought it might be the case, but that means that applying <* to two monads could potentially fail if they're not instances of Functor?
05:26:15 <int-e> heh. http://www.janeysaur.com/monad-aka-warm-fuzzy-thing is adorable.
05:26:47 <int-e> (old, perhaps mentioned before, but I'd never seen it.)
05:27:15 <Xilon> int-e: The new Haskell mascott? ;)
05:27:59 <sajkr> so, can anyone tell me if fromIntegral . floor won't do the unneccesary conversion to and from an integral type, down there in machine code?
05:28:23 <xplat> you can probably tell by reading the core
05:28:43 <xplat> and it's easier to read than machine code
05:29:04 <Twey> sajkr: I just did.
05:29:15 <Twey> There *is* no integral type specified.
05:29:25 <Twey> It wouldn't know which type to use if it wanted to.
05:29:50 <luite> floor is a method of the RealFrac class, which is defined in terms of properFraction. this uses an Integral for the, erm, integral part of the fraction, and the original type for the remainder. I don't think that will be optimized away :)
05:29:59 <luite> but check the core if in doubt
05:30:26 <int-e> Xilon: it's Monica Monad (The original one is somewhere in the middle of http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas )
05:30:43 <sajkr> weak, there is apparently a floor :: Double -> Double in the cmath library. no Float. :(
05:31:03 <cts> luite xplat: What is "the core"?
05:31:04 <int-e> Xilon: and of course, she's a warm, fuzzy thing. So it's nice to see an actual stuffed toy version of her.
05:31:22 <luite> cts: haskell core, an intermediate language generated by the compiler
05:31:45 <luite> cts: there are more intermediate languages (at least with ghc), but this one is the closest to the original haskell
05:32:28 <cts> luite: How can one access it?  Is it in .hi-files or .o-files?
05:33:27 <luite> cts: I believe it's a ghc command line option, but there's a ghc-core package on hackage, which makes it a bit more convenient
05:34:43 <Xilon> @src liftA2
05:34:44 <lambdabot> liftA2 f a b = f <$> a <*> b
05:35:08 <Taejo> can one make Text values which are substrings of one large string share memory?
05:35:34 <Xilon> Taejo: Sounds kind of like rope
05:36:09 <Taejo> Xilon: I know there are rope libraries that do this, but does the "rope" library on hackage?
05:36:24 <xplat> Taejo: they probably should by default if they're implemented as ByteStrings wrapped in the simplest way possible
05:37:38 <Taejo> xplat: that would mean that if I read in a gigabyte file, find ten characters in it that I'm interested in, and never use the rest again, none of that memory can be reclaimed
05:37:51 <Taejo> or is GHC's GC cooler than I though?
05:38:01 <ezyang> This is an odd constraint to have to write: forall e. ElemOf LabelSet ~ Label => block n e C -> LabelSet -> LabelSet 
05:38:05 <xplat> Taejo: that's what the function 'copy' is for, afaict
05:38:25 <Xilon> Taejo: Well if it's truly a rope data structure, then by definition it would
05:38:27 <ezyang> oh, in fact, it's not necessary 
05:39:56 <xplat> ropes automatically reclaim memory like that, but ByteStrings and Data.Text are not ropes
05:40:44 <merijn> :t (->)
05:40:45 <lambdabot> parse error on input `->'
05:40:59 <Jafet> I wonder if unsafeInterleavedIO is sufficient to make a pure-looking rope
05:41:02 <xplat> as it turns out ByteStrings behave pretty similarly to perl strings ...
05:41:08 <Taejo> xplat: ah, it's obvious text does this from tail being O(1)
05:41:08 <merijn> :k (->)
05:41:09 <lambdabot> ?? -> ? -> *
05:41:35 <Taejo> xplat: I don't know perl; in python, substring is O(n)
05:41:39 <Jafet> My gut says no, because of random access requiring fseek
05:42:52 <Taejo> Jafet: perhaps you could include a lock in the data
05:43:46 <Jafet> You could use mmap and shove the task of lazy file loading to the operating system
05:44:50 <xplat> i don't see why unsaveInterleaveIO can't handle fseeks ...
05:45:04 <ezyang> When I'm resolving MonoLocalBinds errors, should I go for the most general signature GHC gives me, or try to specialize it a way that makes sense for the use cases? 
05:45:18 <xplat> you would need a lock, though
05:45:45 <xplat> some OSes provide atomic positioned reads, you wouldn't need one there
05:47:33 <xplat> and on other OSes you could use mmap-and-copy, that wouldn't have problems if it got interleaved with another thread
05:48:41 <xplat> (mmaping each leaf individually and keeping it that way would lead to resource exhaustion, though, and doing the whole file at once would eat address space)
05:49:17 <Jafet> That happens even without mmap.
05:49:34 <xplat> 'that' == ?
05:50:04 <Jafet> The file is read and kept in memory if it is part of a pure data structure.
05:50:41 <krey> o/, trying to parse arithmetic expression, can someone help me figure out predence?
05:51:08 <krey> i think I need a lexer | tokeniser
05:51:15 <Jafet> Well, the rope might get gc'ed and the mmap region wouldn't be, but then the system would page them out anyway, so it should be fine
05:51:16 <merijn> :t ($)
05:51:18 <lambdabot> forall a b. (a -> b) -> a -> b
05:51:57 <xplat> right, but i meant: if you mmap the 2GB file all at once it will eat 2GB regardless of you only reading the first 1K.  if you map leaves you will run out of memory slab slots long before you would run out of memory.  so you map leaves (or 4K chunks or whatever), copy them to pure structures, and unmap
05:52:02 <Jafet> krey: "tokenizers" generally don't care about precedence.
05:52:35 <krey> Jafet: so I use tokenisers to split the string up
05:52:46 <krey> Jafet: but where do I start worrying about predence
05:52:47 <krey> ?
05:52:56 <Jafet> xplat: right. But if the leaves are evaluated in parallel without mutex between them, you'd run right out of fd's.
05:53:16 <krey> Jafet: atm, I have no tokens, I just go StateT on the string
05:53:22 <Jafet> unsafe IO is a road to semantics hell
05:53:39 <Jafet> krey: when you're combining the tokens into a parse tree.
05:54:01 <xplat> Jafet: yes, it is, but i was only trying to make it work as well as existing lazy IO, not do the impossible
05:54:05 <krey> Jafet: ok, so can you help me with that step?
05:54:11 <Jafet> For simple "arithmetic expression", you could just merge the lexing and rest of the parsing steps.
05:54:31 <krey> how?
05:54:48 <xplat> krey: there is something known as a 'precedence parser'
05:54:50 <Jafet> By combining the token grammar and the rest of the grammar.
05:54:59 <romildo> quicksilver, Regarding the application we talked about earlier this morning, where I need to present to the user part of some file paths, which library is recommended to decode the FilePath into a Unicode String? 
05:55:18 <xplat> which you could google.  although it requires a separate tokenizer for this.
05:55:34 <xplat> it's probably easier to just use attoparsec or something
05:55:38 <Jafet> Recursive descent and RPN conversion work just as well.
05:55:52 <quicksilver> romildo: utf8-string is nice and simple if UTF8 is the only encoding you need.
05:55:52 <krey> xplat: ok, google time
05:56:18 <krey> xplat: I think I can manage from scratch
05:56:35 <Xilon> @src FilePath
05:56:35 <lambdabot> type FilePath = String
05:57:28 <Xilon> Isn't Data.Text recommended these days?
05:57:31 <krey> xplat: http://en.wikipedia.org/wiki/Operator-precedence_parser <- did you mean this?
05:57:40 <romildo> quicksilver, Most of the systems I use uses the utf-8 locale, but some may still be set to iso-8859-1. I want the application to work both in Linux and Windows.
05:57:52 <xplat> krey: yes
05:57:55 <krey> xplat: cos that's the same thing that Jafet is talking about (RPN conversion)
05:58:19 <quicksilver> romildo: I think in windows getDirectoryContents doesn't need decoding, but I'm not sure.
05:58:39 <quicksilver> romildo: if you want more than just utf8 I recommend the 'encoding' package.
05:59:58 <xplat> krey: RPN conversion is the abstract thing that both our approaches have in common.  the difference is his is top-down and mine is bottom-up
06:00:51 <krey> xplat: I don't really understand the "top-down" and "bottom-up" parsing, these adjectives sound very imperative
06:01:07 <krey> xplat: the one i'm using currently, StateT, which one is that?
06:01:36 <romildo> quicksilver, So I may check if I am on Windows or not. Which library is used for that?
06:01:44 <Jafet> StateT isn't a parser, krey.
06:01:51 <xplat> krey: neither, StateT is a lower-level detail than top-down vs bottom-up
06:01:53 <Jafet> What kind of parser are you writing with StateT?
06:02:36 <quicksilver> romildo: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Info.html
06:02:37 <krey> xplat, Jafet: oh, I'm getting really confused now. I use StateT to parse context free stuff
06:02:49 <quicksilver> romildo: you should avoid doing this in most cases, but in the case you're talking about now, I don't know a better way.
06:03:43 <krey> here's an example: https://github.com/krey/Parsers-and-Interpreters/blob/master/LambdaParse.hs
06:03:47 <xplat> that sounds like saying 'if you build a house with wood, is it victorian or ranch-style?'
06:04:00 <krey> xplat: I see
06:04:18 <krey> xplat: so, the thing I link, is that topdown or bottomup?
06:05:04 <krey> xplat: line 62
06:06:14 <xplat> that is classic, top-down recursive descent
06:06:51 <krey> xplat: so, can you turn it into bottom-up for me to see the difference?
06:07:24 <Jafet> No matter what kind of house it is, you're still a LUMBERJACK
06:07:36 <romildo> What does the "?" symbol mean in a variable declaraction like "do let ?enc = UTF8"
06:08:52 <Taejo> romildo: it's an implicit parameter
06:09:08 <xplat> krey: i can, but that is more work than i am willing to invest in clarifying a concept for one person.  maybe if i had a blog going already.
06:09:20 <Taejo> romildo: you can see a description at http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html
06:09:30 <Taejo> it doesn't seem to be a very popular extension
06:09:43 <krey> xplat: I understand, time to look on google...
06:09:56 <Jafet> I think implicit parameters are very promising
06:10:02 <xplat> Taejo: it has toxic side effects
06:10:14 <romildo> Taejo, it is used in the encoding library.
06:10:16 <Jafet> That is, there is the potential to write wonderfully insane code with it.
06:10:25 <xplat> (in the informal, not techical sense)
06:10:37 <Jafet> (If we could tear oleg from his type systems...)
06:10:52 <Taejo> romildo: also in the WordNet library, which I cabalized -- and that's the only time I've used it
06:12:26 <xplat> scala's implicit arguments are awesome, but they come at less cost, since there are fewer nice algebraic properties of the language in the first place for them to screw up
06:13:04 <Taejo> xplat: lol
06:15:22 <xplat> scala programmers now use them to implement what amounts to lexically-scoped typeclasses
06:16:13 <Taejo> xplat: how do they avoid the problems that causes? or don't they?
06:16:22 <xplat> (both the classes and the instances lexically scoped, and can be imported from modules)
06:17:11 <xplat> they avoid the problems by keeping the scope small to minimize interference, and by having compile failure on most kinds of interference
06:18:14 <xplat> unfortunately this makes it hard to use typeclasses for some things they are really good at, like polymorphic integer arithmetic in the standard library -- they end up using OO for that instead (ugh)
06:19:02 <Taejo> the example I was thinking of was Set -- if you union two sets created with different Ord classes, things go wrong
06:20:52 <xplat> partly that comes from implicits being introduced late in the language design process, and their potential discovered even later, and the extensions to typechecking to realize more of that potential even later ... but i think they'd have problems if they tried to do it with that system
06:21:08 <xplat> Taejo: oh, they can check that kind of thing with path-dependent types
06:21:31 <Taejo> now that sounds like some oleg-level hack
06:22:21 <krey> Taejo: what's an oleg-level hack?
06:23:16 <Taejo> krey: something as mind-blowing and surprising (given the constraints) as the work of Oleg Kiselyov
06:23:21 <xplat> basically, the set object remembers what instance it was created with, both on the value and type levels, and if you try to use two with different instances they blow up at compile time
06:24:12 <xplat> the type system features were originally created for OO scenarios, but they work just as well for typeclasses
06:25:20 <xplat> (original idea was things like trying to connect vertices in two different graphs)
06:27:25 <xplat> having this feature isn't free though, it makes some questions about typing equivalent to undecidable questions about CFGs
06:30:04 <xplat> there are also arbitrary-seeming restrictions on the use of path-dependent types to keep them from being equivalent to full-on dependent types
06:31:54 <xplat> i think lately the scala team are thinking they're just going to dive into that, though
06:32:57 <xplat> since only a few more things become impossible that weren't impossible already with the restricted version
06:43:02 <xplat> it's kind of frustrating that there's no language with most of the strengths of both haskell and scala ...
06:49:35 <redd> @pl (\a b c -> a : b ++ c)
06:49:35 <lambdabot> (. (++)) . (.) . (:)
07:01:16 <romildo> An interactive program writes a prompt on standard output and then reads a response from standard input. But the prompt only appears after reading the response, even when the output is flushed. How to solve this?
07:02:24 <Twey> romildo: I don't think you flushed it properly
07:06:04 <romildo> Twey, you are right. The hFlush function call was misplaced. I was a bit tired when wrote the code and did not see it was in the wrong line. Thanks.
07:07:30 <duckinator> xplat: make a new one, call it haskalla! (pronounced has-ka-la) ;)
07:07:57 <sipa> or just hascala
07:08:22 <duckinator> but that's no fun, you aren't mixing pronunciations very much with that
07:08:57 <duckinator> i also fail at explaining what i'm trying to say, so i'm just going to stop that before i look like a fool. back to working on that haskell irc bot o/
07:10:37 <Jafet> Haskalla sounds like an indian curry
07:26:39 <augur> hey peeps
07:27:43 <augur> anyone interested in logic programming at all?
07:29:43 <roconnor> what is logic programming?
07:30:17 <sipa> programming using logical variables and unification
07:30:37 <roconnor> LogicT doesn't do unification does it?
07:31:48 <Philippa> no, it does get you backtracking though - you can drop an implementation of unification on top
07:35:10 <Saizan> and start writing things like (add :: Var Nat -> Var Nat -> Var Nat -> L ()) if you want bidirectionalization
07:38:04 <phao> Hi. I'm new to haskell and I'm seeing some code. The syntax is very ... non-strange hehe
07:38:14 <phao> I mean... some of it looks like math syntax actually.
07:38:26 <medfly> ok
07:38:30 <phao> are there many symbols and syntax to learn?
07:38:42 <phao> because, at first, looks like there are a bunch of syntax for each special case
07:38:52 <phao> instead of some few generic ones
07:39:00 <Saizan> in haskell you can define your own operators, so a lot of symbols are actually user defined functions
07:39:09 <phao> right
07:39:19 <phao> like meta programming?
07:39:21 <Saizan> the syntax of the language itself is not that large
07:39:53 <engla> even tuples are defined using the language, not in the language
07:40:05 <phao> tuples?
07:40:25 <Saizan> it's not commonly associated with meta programming, it's just that you are allowed a larger class of characters for your identifiers than usual
07:40:36 <phao> right
07:40:38 <phao> like in scheme
07:40:42 <phao> in scheme, lisp, etc.
07:40:58 <phao> that's a good thing... =)
07:40:58 <Saizan> tuples have actually special syntax, you couldn't define them within haskell
07:41:03 <phao> I like being able to use '?' as part of the name
07:41:05 <phao> and '-' instead of spaces
07:41:07 <engla> Saizan: ok
07:41:16 <phao> ops
07:41:20 <phao> instead of '_' for spaces
07:41:41 <Saizan> yeah, the rules are different in haskell, but the concept is the same
07:41:55 <Blkt> good day everyone
07:44:06 <engla> Saizan: oh ok, I confused this with the explicit , and ,, etc operators
07:44:34 <MrHOLO> I am new to haskell
07:44:45 <MrHOLO> So I have an elementary doubt 
07:44:55 <MrHOLO> How do I make a source file in haskell?
07:45:18 <Ke> use an editor
07:45:28 <MrHOLO> notepad?
07:45:30 <JeroenDL> Yes
07:45:32 <JeroenDL> and save as .hs
07:45:42 <MrHOLO> Where should I save it?
07:45:42 <JeroenDL> (make sure it isnt a .hs.txt)
07:45:46 <JeroenDL> wherever you want
07:45:55 <JeroenDL> then navigate to it in Dos
07:45:58 <JeroenDL> and call ghci
07:45:59 <MrHOLO> And then how will ghc load it 
07:46:31 <MrHOLO> Yeah I did it 
07:46:46 <JeroenDL> and then use :l myfile.hs
07:46:48 <JeroenDL> colon + l
07:46:57 <ion> Notepad is one of the worse editors, though. You might want to use one with e.g. syntax highlighting and more or less smart/automatic indentation.
07:47:08 <MrHOLO> I have octave 
07:47:08 <MrHOLO> I can use that too 
07:47:09 <JeroenDL> You can use any editor you want
07:47:12 <MrHOLO> I will just try and tell you 
07:47:14 <Saizan> engla: you can't define operators with those names in haskell
07:48:37 <phao> btw
07:48:43 <phao> are spaces ignored in haskell as they are in C?
07:48:48 <unkanon_> no
07:48:52 <phao> I mean... name-2 is like name - 2.
07:48:59 <unkanon_> oh then yes
07:49:00 <phao> right. thx.
07:49:19 <phao> so '-' can't be part of a name?
07:49:47 <tromp_> only as part of an operator
07:50:38 <unkanon_> phao: it's not like in lisp where you can name a function my-function
07:50:43 <tromp_> > let (-/-) = (+) in 3 -/- 5
07:50:44 <lambdabot>   8
07:50:44 <MrHOLO> I made a file add.hs and then saved it in my desktop 
07:51:08 <MrHOLO> And then I used the command :l C:\Documents and Settings\Rayne\Desktop\add.hs
07:51:20 <MrHOLO> But it gave me the following message
07:51:49 <tromp_> lisp doesnt have infix operators
07:51:51 <MrHOLO> target 'C:\Documents' is not a module name or source file 
07:51:52 <pacak> MrHOLO: Did you tried yo escape spaces?
07:52:01 <Martty> yeah yo
07:52:02 <tromp_> a bigger loss than not allowing - in names
07:52:05 <JeroenDL> and its easier to just navigate to the folder first
07:52:15 <Martty> :l "C:\Documents and Settings\Rayne\Desktop\add.hs"
07:52:24 <MrHOLO> Oh okay 
07:52:40 <Martty> are you related to rayner wolfcastle
07:52:53 <phao> ok unkanon_ 
07:53:03 <phao> I'll just wait untill I see info on that on the book I'm reading
07:53:08 <phao> but thx for the heads on
07:53:55 <MrHOLO> Okay thanks 
07:54:02 <MrHOLO> Atleast it is trying to load 
07:54:12 <MrHOLO> now 
07:55:50 <unkanon_> ok'
07:56:40 <Jonno_FTW> @src length
07:56:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:57:17 <tromp_> do you play go, phao?
07:57:43 <phao> tromp_, you mean the language go?
07:57:49 <tromp_> no, the game
07:58:00 <phao> never heard of it
07:58:15 <phao> the only game I mess up with is UO
08:00:00 <Twey> Haha
08:00:31 <exDM69> tromp_: I play some go every now and then. My friends are just too good so I can't really get even opponents
08:01:09 <phao> Twey, you play UO?
08:01:17 <tromp_> i thought if he knew go he might like to see how easilyt haskell can implement the rules
08:01:25 <Twey> No :þ
08:01:35 <kurenai> eastern sounding of your nickname must be misleading then, phao.
08:01:36 <tromp_> i never heard of UO
08:01:48 <kurenai> ultima online probably
08:01:53 <tromp_> oh
08:02:43 <phao> kurenai, it is 
08:02:52 <phao> kurenai, what would be 'eastern sound'?
08:03:00 <phao> phao are the initials of my name 
08:03:14 <rjo> there is a type signature: decode :: JSON a => String -> Result a
08:03:25 <rjo>   case ((decode jsonInput) :: Result JSObject) of
08:03:39 <rjo> I do not get how I have to formulate this case?
08:03:57 <phao> hmm
08:03:58 <phao> just saw something
08:04:13 <phao> ops, neverming
08:04:18 <phao> nevermind*
08:04:48 <kurenai> it sounds similar to morphemes in some eastern languages, like chineese.
08:05:08 <handonson> is there any function like { stack 5 f x = f $ f $ f $ f $ f x }
08:05:41 <handonson> so that :: Int -> (a -> a) -> a -> a
08:06:08 <ezyang> @src iterate 
08:06:09 <lambdabot> Source not found. Just try something else.
08:06:12 <ezyang> :t iterate 
08:06:13 <lambdabot> forall a. (a -> a) -> a -> [a]
08:06:22 <ezyang> > iterate (+2) 0 
08:06:23 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
08:07:45 <handonson> cool, but seems a bit wasteful
08:07:47 <kmc> phao, Haskell has an optional mechanism whereby whitespace can stand for implicit { } ;
08:08:05 <kmc> if you don't like it, you can use the explicit punctuation
08:08:50 <kmc> (though the vast majority of Haskell code in the wild does use whitespace layout)
08:08:53 <tromp_> @let stack n f x = (iterate f x)!!n
08:08:54 <lambdabot>  Defined.
08:09:12 <tromp_> > stack 3 tail "hello"
08:09:13 <lambdabot>   "lo"
08:09:37 <kmc> > head $ stack 90000 (x:) []
08:09:37 <lambdabot>   x
08:09:54 <quicksilver> handonson: I don't think iterate is particularly inefficient.
08:09:56 <kmc> > head $ stack 9000000 (x:) []
08:10:01 <lambdabot>   mueval: ExitFailure 1
08:10:08 <quicksilver> a direct counting iteration would be a little faster but probably not much.
08:10:40 <Twey> > map (2 *) [0 ..] -- is probably faster
08:10:43 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
08:10:44 <kmc> @let stack2 0 f x = x; stack2 n f = f (stack2 (n-1) f x)
08:10:44 <lambdabot>   arity mismatch for 'stack2'
08:10:49 <kmc> @let stack2 0 f x = x; stack2 n f x = f (stack2 (n-1) f x)
08:10:51 <lambdabot>  Defined.
08:10:51 <quicksilver> forcing as you go might be faster.
08:10:54 <kmc> > head $ stack2 9000000 (x:) []
08:10:56 <lambdabot>   x
08:14:38 <kmc> > stack2 900000 (1+) 0
08:14:40 <lambdabot>   *Exception: stack overflow
08:14:43 <kmc> > stack 900000 (1+) 0
08:14:44 <lambdabot>   *Exception: stack overflow
08:15:02 <kmc> @let stack3 0 f x = x; stack3 n f x = f $! stack3 (n-1) f x
08:15:04 <lambdabot>  Defined.
08:15:07 <kmc> > stack3 900000 (1+) 0
08:15:08 <lambdabot>   *Exception: stack overflow
08:16:36 <unkanon_> > stack3 4 (+1) 3
08:16:37 <lambdabot>   7
08:16:40 <unkanon_> cool
08:18:08 <magicman> > let stack4 0 f x = x; stack4 n f x = stack4 (n-1) f (f x) in stack4 900000 (1+) 0
08:18:11 <lambdabot>   *Exception: stack overflow
08:18:28 <magicman> > let stack4 0 f x = x; stack4 n f x = (f x) `seq` stack4 (n-1) f (f x) in stack4 900000 (1+) 0
08:18:31 <lambdabot>   900000
08:19:45 <magicman> (though that has horrible lazyness properties :-/)
08:23:18 <magicman> > let stack5 n = foldr (.) id . replicate n in stack5 5 (1:) []
08:23:19 <lambdabot>   [1,1,1,1,1]
08:23:39 <magicman> > let stack5 n = foldl (.) id . replicate n in stack5 5 (1:) []
08:23:39 <lambdabot>   [1,1,1,1,1]
08:23:43 <magicman> Right.
08:23:46 * magicman stops >_>
08:27:04 <NewUser> How can i do this Tree includes a Leaf constructor for nodes with values but without descendents.
08:27:05 <NewUser> ?
08:27:44 <kmc> data Tree a = Leaf a | Node (Tree a) (Tree a)
08:27:54 <kmc> is this homework?
08:27:55 <NewUser> i have this data BinTree a = EmptyBinTree | BinNode a (BinTree a) (BinTree a) deriving (Show, Read, Eq)
08:27:59 <NewUser> no
08:28:18 <kmc> (it's okay if it is, just wondering)
08:28:49 <NewUser> kmc: i have this   data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
08:29:29 <NewUser> kmc: is this data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) ok for this Tree includes a Leaf constructor for nodes with values but without descendents
08:29:41 <kmc> no
08:29:54 <kmc> your "EmptyTree" constructor has no value
08:30:00 <kmc> your "Node" constructor has values and descendents
08:30:10 <kmc> all you did was change the names of stuff in what you had before
08:30:21 <NewUser> kmc: ok
08:30:40 <kmc> i gave you the answer above
08:30:41 <NewUser> kmc: how can i do it?
08:30:46 <kmc> <kmc> data Tree a = Leaf a | Node (Tree a) (Tree a)
08:30:51 <NewUser> oh ok
08:30:54 <NewUser> thank you
08:31:07 <engla> Which of the two solutions is better?
08:31:23 <NewUser> the first one
08:31:33 <NewUser> kmc: both are the same 
08:31:53 <engla> kmc's or NewUser's with EmptyTree
08:32:24 <kmc> in my mind "has no descendents" and "has two empty trees as descendents" are different properties
08:33:18 <NewUser> yes
08:33:22 <engla> kmc: that would lead to a combination of both then,  Empty | Leaf | Node
08:33:48 <NewUser> engla: so I need to have an Empty as well
08:33:49 <NewUser> ?
08:33:57 <kmc> no
08:33:58 <engla> NewUser: you don't need that to represent a tree
08:34:07 <kmc> NewUser, you need it if the problem says you need it
08:34:15 <kmc> i mean, what are the requirements on this data type?
08:34:29 <quicksilver> there is not one answer to what makes a tree.
08:34:43 <quicksilver> you can have binary, or n-ary, and you can have values at branches or values at leaves or both.
08:34:57 <quicksilver> (some of these options are the same as some other ones represented differently)
08:35:02 <NewUser> kmc: this BinTree includes a Leaf constructor for nodes with values but without descendents.  i have this data BinTree a = Leaf a | BinNode (BinTree a) (BinTree a)
08:35:10 <kmc> indeed it does
08:35:30 <NewUser> kmc: i am ok correct?
08:35:41 <kmc> the type you pasted satisfies the property you pasted
08:35:59 <NewUser> kmc: indeed thank you
08:36:00 <kmc> but whether you also need an Empty constructor depends on what other properties you want
08:36:10 <engla> but it's now very different -- your BinNode doesn't carry a value
08:36:25 <NewUser> kmc: the one i paste is the one i needed it
08:36:31 <kmc> i'm personally a fan of the ∞-ary tree
08:36:55 <kmc> data Tree = Node (Integer -> Tree)
08:37:18 <aristid> kmc: would be nice to have a type for only integers >=0
08:37:31 <aristid> but still arbitrary size
08:37:36 <phao> Hi. Shouldn't this code work: http://ix.io/1iE
08:37:43 <Saizan> you mean naturals?
08:37:45 <sipa> data N = Z | S N
08:37:47 <sipa> done :)
08:37:57 <aristid> sipa: yeah, but efficiently too, please ;)
08:37:58 <sipa> or do you want it do be efficient af well? :)
08:37:59 <xplat> the rest is just trivial optimizations
08:38:10 <xplat> left as an exercise to the reader
08:38:11 <phao> I'm talking about the layout rules. I'm trying to use { ... ; ... ; ....... } rules, but doesn't seem to be working in that code.
08:38:13 <kmc> that N is also a good deal lazier than Integer
08:38:21 <aristid> phao: no, it looks wrong
08:38:26 <sipa> kmc: as lazy as you can get
08:38:26 <kmc> it lets you do things like (genericLength [1..] > (S N))
08:38:32 <NewUser> kmc: but with that definition I cant do this foldr treeInsert EmptyBinTree [8,9,6,4,1,7,3,5]  
08:38:36 <phao> aristid, why is that?
08:38:42 <aristid> kmc: why are the two declarations in braces?
08:38:45 <aristid> argh
08:38:47 <aristid> i mean phao
08:39:00 <phao> aristid, I mean... I'm delimiting with { and }, and separating each definition with an ';'
08:39:24 <aristid> phao: and that is illegal.
08:39:40 <aristid> i think definitions must be top-level
08:39:46 <aristid> no indentation, no {}
08:39:58 <phao> no clue what you mean by that
08:40:13 <aristid> phao: well, just try removing the {} and ;
08:40:29 <phao> same error
08:40:33 <xplat> the semicolon after the 2 is misplaced
08:40:59 <monochrom> {x = y;<newline>y = True}  works. Try it!
08:40:59 <Saizan> phao: thos works http://hpaste.org/42189/layout
08:41:08 <xplat> it ends up being interpreted as inside the impliled braces for the where clause
08:41:31 <xplat> put it on the next line, even with the f
08:41:44 <xplat> that should work
08:41:59 <Saizan> ah, yeah, it does
08:42:23 <phao> yes... it works
08:43:16 <phao> so
08:43:18 <phao> in haskell
08:43:21 <phao> lines count.
08:43:40 <phao> I mean... something in a line may mean something else if there was a '\n' before it
08:43:52 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1 is the real definition of "top level", which has {}.
08:43:55 <younder> doh
08:43:58 <Saizan> yeah, layout in general does
08:44:00 <quicksilver> only inside a layout construct.
08:44:06 <phao> Hmm
08:44:08 <phao> right
08:44:30 <Saizan> if you put explicit {} and ; everywhere it won't
08:44:47 <Saizan> but if you mix {;} and layout you have to be careful
08:45:18 <younder> Which NO-ONE actually does...
08:45:30 <phao> this makes me remember python.
08:45:31 <Saizan> yeah, fortunately :)
08:45:38 <kmc> i mix {;} and layout
08:45:43 <kmc> usually only on a single line
08:45:50 <kmc> do x <- a; y <- b
08:45:52 <phao> I don't intent to... This is only for learning.
08:46:12 <kmc> phao, i think it's nicer than python, especially in that the whitespace-independent form *exists*
08:46:26 <aristid> monochrom: is that why haskell-mode always wants to indent everything after the module's where?
08:46:49 <monochrom> No.
08:46:55 <aristid> hmm, ok
08:47:11 <phao> but doesn't seem to be much regular... I mean I can write
08:47:12 <phao> a
08:47:13 <phao> =
08:47:13 <phao> 3
08:47:26 <phao> is that ';' a special case?
08:47:33 <kmc> you can't
08:47:41 <phao> I just did.
08:47:53 <kmc> in what context?
08:47:59 <kmc> also which ';' do you refer to?
08:47:59 <phao> ops
08:48:10 <kmc> @where layout
08:48:10 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
08:48:16 <monochrom> parse error on input `='
08:48:30 <phao> I did this: http://ix.io/1iF
08:48:35 <unkanon_> it's much nicer than python, I agree
08:48:43 <NewUser> I am having an error message http://pastebin.com/ReqfaNi3
08:48:57 <phao> that code, on the file, works.
08:49:20 <NewUser> phao: me
08:49:22 <NewUser> ?
08:49:24 <kmc> yes, you have whitespace before the = and 3
08:49:36 <kmc> the layout column of top level is 0
08:49:39 <unkanon_> uhm... where's toLower? not Data.List, not Data.String...
08:49:48 <kmc> @hoogle toLower
08:49:48 <lambdabot> Data.Char toLower :: Char -> Char
08:49:54 <unkanon_> thanks :)
08:49:59 <kmc> phao, so any line that starts at column 0 gets an implicit ; prepended
08:50:08 <kmc> but your = starts further in, so it doesn't
08:50:19 <phao> kmc, hmm
08:50:21 <phao> thx
08:50:28 <younder> You might want to look into the Monad version.
08:50:31 <kmc> it won't work if you line up = and 3 with a
08:50:43 <Boxo> NewUser you have EmptyTree where you should have Leaf
08:50:45 <kmc> younder?
08:51:06 <phao> kmc, this 'any line that starts at column 0 gets an implicit ; prepended' is valid outside {} right?
08:51:12 <NewUser> Boxo: which line I need to change?
08:51:35 <kmc> right
08:51:37 <Boxo> You have choices. Point is "EmptyTree" isn't even defined anywhere
08:51:39 <younder> kmc: http://en.wikibooks.org/wiki/Haskell/Advanced_monads
08:51:48 <kmc> if you write an explicit { then layout does not apply to that construct
08:52:02 <Boxo> Also you are applying BinNode to 3 arguments, while it only takes 2
08:52:13 <kmc> layout applies whenever the keyword 'let', 'of', 'where', or 'do' is followed by a token which isn't '{'
08:52:22 <Boxo> in "singleton'"
08:52:28 <NewUser> oh ok
08:52:30 <kmc> and the column is set by the next token
08:52:37 <phao> kmc, but if layout rules don't apply inside {}
08:52:40 <kmc> this includes the implicit "module Main where" for a file without a module
08:52:56 <phao> why is that I have to put the ';' outside that 'c=3' line
08:53:00 <kmc> if you're getting into this level of detail i suggest you just read the relevant section of the Report; it's actually quite approachable
08:53:08 <kmc> can you send me the link to your code again phao?
08:53:20 <NewUser> Boxo: like this singleton' x = BinNode x
08:53:32 <phao> http://ix.io/1iE
08:53:35 <augur> eep
08:53:36 <xplat> layout rules still apply inside {}, there's just no layout column for that level of braces
08:53:40 <augur> logic programming anyone?
08:53:41 <Boxo> NewUser, singleton x = Leaf x 
08:53:47 <NewUser> oh ok
08:53:54 <sipa> augur: maybe there are more appropriate channels for that?
08:54:22 <augur> sipa: #haskell is essentially the all-CS channel :P
08:54:25 <xplat> LogicT is as appropriate as it gets :)
08:54:28 <augur> there is no more appropriate channel than this!
08:54:32 <kmc> some people would disagree augur
08:54:42 <augur> kmc: those people are wrong, as xplat has shown!
08:54:42 <NewUser> Boxo: can I use this definition data BinTree a = EmptyBinTree | BinNode a (BinTree a) (BinTree a) deriving (Show, Read, Eq)
08:54:57 <augur> xplat: ive been wracking my head over monad transformers just so i could understand LogicT
08:55:05 <monochrom> LogicT doesn't do all of logic programming. lacks resolution.
08:55:16 <Boxo> NewUser, sure
08:55:21 <kmc> phao, that gives me a parse error; is that what you expected?
08:55:30 <kmc> on the line with 'h'
08:55:47 <Boxo> NewUser, however, then you can't make a "singleton tree"
08:55:49 <monochrom> If it doesn't have to do all of logic programming, you may also say Java is logic programming and go to ##java or something.
08:56:01 <kmc> phao, it works if i put the ';' on the blank line, directly above h
08:56:08 <Boxo> NewUser, oh wait, disregard that
08:56:10 <xplat> monochrom: i don't think there's any logic language that does all of logic programming either.  *maybe* Oz.
08:56:13 <NewUser> Boxo:ok
08:56:20 <kmc> but where you have it, it's:  where { b = 3; c = 2; }
08:56:25 <phao> I don't even know exactly what my doubt is... but why does it work if you put that ';' in the blank line?
08:56:49 <kmc> because then it comes after the implicit closing brace of the "where"
08:56:52 <xplat> LogicT doesn't do everything Prolog or Datalog does, but it does handle a simple level of logic programming
08:56:57 <sipa> prolog is logic :)
08:57:20 <phao> right
08:57:21 <phao> but
08:57:26 <phao> why is that a problem?
08:57:33 <kmc> prolog is logic just like scheme is functional programming.  in that it's what you learn in intro CS
08:57:53 <kmc> phao, it's not a problem... i thought you had a question about this behavior
08:58:20 <NewUser> Boxo: it doesnt recognize Leaf http://pastebin.com/4Ckxfmj4
08:58:56 <phao> kmc, it is a problem... the code doesn't run...
08:59:03 <kmc> the code you pasted doesn't run phao 
08:59:08 <kmc> because you put the ; in the wrong place
08:59:08 <phao> yes.
08:59:13 <Boxo> NewUser, of course not, you removed Leaf from BinTree. Now your old singleton would work
08:59:13 <phao> that's right
08:59:17 <kmc> it works if you put it directly above h
08:59:21 <phao> I wanna know why is that place considered wrong.
08:59:34 <kmc> because it's within the "where" block
08:59:35 <phao> I don't see the logic there...
08:59:42 <NewUser> oh ok
08:59:47 <xplat> because it is inside an invisible brace around the 'where' block
08:59:49 <NewUser> i forgot the old one
08:59:52 <monochrom> it is within a chunk in layout mode
08:59:57 <NewUser> Boxo: i forgot
09:00:01 <NewUser> the old one
09:00:04 <kmc> phao, because the closing } of the "where" block is not inserted until just before the next line which starts left of the first line of "where"
09:00:09 <kmc> and your ; is before that
09:00:12 <xplat> the 'where' block does not close until the beginning of the first line that is less indented
09:00:13 <phao> xplat, the implicit ending } only happens after the '\n'?
09:00:21 <Boxo> NewUser, well then figure it out again :)
09:00:23 <phao> right
09:00:31 <phao> kmc, how many rules like that there is?
09:00:32 <kmc> the implicit ending } happens at the beginning of the first line which isn't in "where"
09:00:35 <kmc> i suggest you read the Report
09:00:40 <kmc> it gives the set of rules quite precisely
09:00:44 <phao> right
09:00:45 <monochrom> kmc already gave a url.
09:00:46 <kmc> first in prose and then as a pseduo-Haskell function
09:00:56 <monochrom> or rather, he did this:
09:00:56 <xplat> all layout gets translated into something at the beginning of a line
09:00:58 <monochrom> @layout
09:00:59 <lambdabot> Unknown command, try @list
09:01:01 <kmc> @where layout
09:01:02 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
09:01:02 <monochrom> @where layout
09:01:02 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
09:01:11 <kmc> and someone else pasted the H2010 link above
09:01:31 <monochrom> oh, but the H2010 link is not layout. it is top-level {}
09:01:35 <kmc> oh
09:01:38 <kmc> @where layout2010
09:01:38 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
09:01:42 <monochrom> ha
09:01:49 <kmc> not that the rule has changed
09:01:52 <kmc> but the presentation has
09:02:48 <xplat> 2010 is such an exciting year for haskell.  new report, GHC7, lots of nice stuff
09:02:58 <xplat> hope next year is even better!  :)
09:03:02 <kmc> HaLVM :D
09:03:06 <Twey> Not a very exciting report, though :þ
09:03:13 <kmc> 2010 is the year of Haskell on the Desktop
09:03:40 <NewUser> Boxo: I am in trouble i am getting this BinNode 5 (BinNode 3 (Leaf 1) (Leaf 4)) (BinNode 7 (Leaf 6) (BinNode 9 (Leaf 8) EmptyBinTree))  but i need to get this BinNode 5 (BinNode 3 (Leaf 1) (Leaf 4)) (BinNode 7 (Leaf 6) (BinNode 9 (Leaf 8) EmptyBinTree))
09:04:14 <xplat> NewUser: those are the same
09:04:29 <NewUser> oh really i dint know
09:04:41 <Boxo> wtf
09:04:47 <kmc> > "BinNode 5 (BinNode 3 (Leaf 1) (Leaf 4)) (BinNode 7 (Leaf 6) (BinNode 9 (Leaf 8) EmptyBinTree))" == "BinNode 5 (BinNode 3 (Leaf 1) (Leaf 4)) (BinNode 7 (Leaf 6) (BinNode 9 (Leaf 8) EmptyBinTree))"
09:04:48 <lambdabot>   True
09:04:55 <NewUser> ok
09:05:50 <xplat> is it a mispaste or did you really not notice your result was the same as what you wanted?
09:06:16 <xplat> you don't have to answer that unless it was a mispaste :7
09:13:10 <mm_freak> is darcs suitable for binary files?
09:13:19 <younder> yes
09:13:52 <NewUser> Boxo: I get confuse with the tree thing
09:14:16 <unkanon_> so if Haskell accepts that I define a function name with a unicode character, then I could define all APL functions in Haskell and use them as if I were writing APL?
09:14:22 <NewUser> Boxo: I want to get this Define a Tree data type that allows an arbitrary number of children at each node. Include a TreeLeaf constructor for values with no children 
09:14:30 <unkanon_> (probably somebody already did that)
09:14:49 <mm_freak> younder: even for large files?  video files?
09:15:16 <mm_freak> unkanon_: almost
09:15:22 <xplat> unkanon_ syntax differences will bite you.  apl has unary prefix and postfix operators which haskell will not support.
09:15:23 <mm_freak> unkanon_: haskell is space-sensitive
09:15:51 <xplat> and also, yes, you need more whitespace between things
09:15:58 <NewUser> Boxo: I have this data Tree = EmptyTree | Tree (a) Tree (a) is this ok
09:16:03 <Boxo> NewUser, well here's a hint. You can do an arbitrary number of things with a list. 
09:16:15 <kmc> in fact APL lets you use the *same* symbol as two different functions depending on fixity, iirc
09:16:15 <NewUser> oh ok
09:16:32 <unkanon_> hmm interesting.
09:16:43 <NewUser> Boxo: like this data Tree = EmptyTree | Tree [a] 
09:16:46 <mm_freak> i don't think you can write a DSL for APL, which looks like APL
09:16:54 <kmc> NewUser, that's not a tree, it doesn't have sub-trees
09:16:55 <xplat> kmc: just like prolog or erlang
09:16:59 <kmc> that's a dumb requirement -- why have a special constructor for the zero-node case
09:17:08 <kmc> zero-child*
09:17:14 <NewUser> ok
09:17:16 <kmc> data Tree a = Node a [Tree a]
09:17:20 <kmc> those are called "rose trees"
09:19:18 <xplat> kmc: maybe the professor used to teach scheme and wants data Tree a = Cons { car :: Tree a, cdr :: Tree a } | Atom a | Nil
09:19:46 <BeginnerHere> To have a Tree data type that allows an arbitrary number of children at each node can I do this data Tree  a = TreeLeaf | Node a  [Tree a]  deriving (Show, Read, Eq
09:19:50 <BeginnerHere> )
09:19:58 <younder> May I recommend a book 'Purely functional data structures'. There is a appendix in Haskell.
09:20:22 <Boxo> Wow, BeginnerHere and NewUser in the same haskell class?
09:20:31 <NewUser> yes
09:20:45 <Boxo> BeginnerHere, that
09:20:50 <xplat> that's technically a binary tree, but if people programmed lisp before they will think it is N-ary :)
09:21:07 <Boxo> that works*
09:21:40 <BeginnerHere> Boxo: for a arbitrary tree ???
09:21:43 <monochrom> in fact you can be in the same class too: http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010  now you're in the same class :)
09:21:56 <xplat> (mine, not BeginnerHere's.  although technically that one is binary too, but nobody gets that technical)
09:23:27 <kmc> hmm
09:23:52 <kmc> NewUser, didn't i ask if you were doing homework?
09:24:08 <mee> haha, someone got a -30 on the midterm?
09:24:14 <NewUser> kmc: i told yes afterwork
09:24:41 <Twey> -30?!
09:24:46 <kmc> did you
09:24:51 <NewUser> yes
09:24:57 <NewUser> kmc: no kidding 
09:25:00 <NewUser> afterwork 
09:25:07 <kmc> i must have missed it then
09:25:16 <Boxo> BeginnerHere, sure, why not
09:25:17 <Twey> kmc: Depending on arity, not fixity
09:25:22 * shepheb atomically the whole TVar
09:25:35 <medfly> so a guy that got 100 has to receive 90? weird.
09:25:38 <c_wraith> how do you part of a TVar? :P
09:25:48 <medfly> oh, nvm
09:26:00 <mee> 16:27 < kmc> is this homework?
09:26:02 <mee> 16:27 < NewUser> no
09:26:14 <Boxo> busted
09:26:34 <medfly> what's so horrible about asking for homework help?
09:27:24 <kmc> nothing's horrible about it
09:27:26 <engla> it's not wrong, it's just wrong if you expect someone else to do the homework
09:27:29 <kmc> in fact i said as much immediately after
09:27:54 <jmcarthur> mee: some people just like to know as it can affect your style of instruction
09:28:01 <kmc> i'm okay helping people with hw
09:28:01 <jmcarthur> and gives you context
09:28:04 <kmc> i'm not okay being lied to
09:28:12 <jmcarthur> yeah i hate that
09:28:16 <younder> Hin's are fine. But you should always explicitly SAY it's homework. After all many people here have taken the same courses.
09:28:33 <kmc> i'm also not okay "helping" with hw when the other person is only capable of saying "is this right: <code>"
09:28:42 <kmc> learning is a dialogue; you have to explain your thought process to the teacher
09:28:58 <jmcarthur> i was particularly ticked off that time recently that somebody came in here offering to pay somebody to do his homework, but even then it wasn't really something i could kick them for or anything like that
09:28:59 <kmc> (one should not confuse the concepts of "school" and "learning" as they often have little to do with each other)
09:29:19 <younder> lol, good point
09:29:45 <kmc> basically if you can't be arsed to test your own code or explain why you think it works, i will lose interest
09:29:52 <kmc> and i've seen this happen here enough times to know i'm not the only one
09:30:12 <jmcarthur> yeah i get frustrated with people that "guess" by generating random code and then asking if it's correct, over and over and over. i don't understand the thought process behind that at all
09:30:24 <jmcarthur> homework or not, although it tends to be people that have it as homework
09:30:26 <kmc> the thought process is "omg i'm so screwed if i don't barely pass this class"
09:30:33 <kmc> that is, has nothing to do with learning
09:30:54 <jmcarthur> i don't know. i think some people really just don't know *how* to approach learning this stuff, so they guess
09:31:01 <kmc> and so, if you make a credible enough guess, the prof might have pity and pass you
09:31:12 <kmc> and you've avoided having to learn anything
09:31:25 <BeginnerHere> Can anyone help me with this http://pastebin.com/fxP9zNw6
09:31:30 <kmc> remember that Haskell is difficult and useless
09:31:41 <xplat> i would so not make it as a prof
09:31:50 <BeginnerHere> I just to need to apply Leaf it
09:32:09 <xplat> i would take pity on people who didn't do any of the homework as long as they can ask intelligent questions in class
09:32:26 <xplat> but if someone made guesses i would give them 0 credit
09:32:31 <jmcarthur> students would hate me if i was a professor, i think
09:32:47 <shapr> xplat: My cs447 final must be submitted to the instructor today. I got a txt message from a classmate asking me to send him the answers.
09:32:52 <mee> I found it very hard to be as much of a hardass as I wanted to be when I TA'd in grad school
09:32:54 <medfly> I harass people to check my homework a lot
09:33:06 <jmcarthur> shapr: forward it to the teacher
09:33:39 <jmcarthur> medfly: i don't think anybody here has an issue with that
09:33:50 <xplat> i would also have a policy that if you write someone else's wrong answer on a test and whose it was, you get extra credit for the question
09:34:09 <jmcarthur> xplat: lol
09:34:17 <c_wraith> shapr, did you take the time to write up a set of plausible but totally wrong answers to send back?
09:34:37 <mee> xplat: that's seriously devious >:)
09:34:43 <shapr> c_wraith: Tempting, but no.
09:34:48 <medfly> heh
09:35:03 <BeginnerHere> Boxo: how is possible to apply Leaf to this http://pastebin.com/fxP9zNw6
09:35:07 <medfly> people here don't seem to care so much about cheating...
09:35:27 <medfly> it's very frustrating when you don't cheat. meh
09:35:33 <c_wraith> once upon a time, I was grading for the data structures lab I'd taken the previous term, and came across someone's submission that was a copy of my solution to that assignment the previous term.  That was bizarre.
09:35:40 <jmcarthur> medfly: right. if somebody fails to learn it because they cheat, they only hurt themselves
09:35:49 <medfly> c_wraith, hahahaha.
09:36:16 <medfly> c_wraith, I actually had a lab instructor say that we shouldn't cheat in his lab, because some of the reports circulating are slightly modified copies of his lab report for the same lab
09:36:22 <medfly> I guess you're not alone
09:36:38 <medfly> the real question is how did it get public? I kinda leave my solutions on public computer..
09:37:04 <c_wraith> They were failed, the person who gave him a copy of the assignment (he got it from my world-readable homework directory on our shared CS system) was expelled...
09:37:07 <Twey> c_wraith: Haha!
09:37:09 <handonson> no, it was just a coincidence
09:37:17 <Twey> ‘It's the ghost of me past!’
09:37:20 <kmc> jmcarthur, not only themselves, also everyone they bump down the curve and everyone whose GPA and degree are devalued by it
09:37:39 <mee> jmcarthur: well, and everyone else whose grade they depressed in curved classes, and everyone who had a lower class ranking because of cheating, and everyone whose diploma is worth less because there are know-nothings running around with the same degree :(
09:37:56 <xplat> yeah, it's like saying 'people who counterfeit money instead of learning to make an honest living only hurt themselves'
09:38:02 <engla> BeginnerHere: your data type definition is not in sync with your algorithms
09:38:24 <jmcarthur> maybe it's just because i've never done it, but if i was a professor i'd think i'd try to have different assignments each term so that past assignments can't be used for cheating in the first place
09:38:32 <kmc> that's a *ton* of work
09:38:35 <medfly> over here cheating was simply made less important. it's very rare that it counts towards anything, and in the less case, it is needed in order to attend the final exam
09:38:36 <medfly> and that's it
09:38:38 <jmcarthur> some professors do it, but i imagine it's a lot of work
09:38:39 <xplat> heh, you've seriously never done it
09:38:44 <jmcarthur> depending on the nature of the assignments
09:38:47 <kmc> remember that the system is set up to reward the professors who spend the minimum effort possible on teaching
09:38:56 <kmc> especially if you haven't made tenure yet
09:39:00 <medfly> you have to cheat on the final in order for your cheating to be any good
09:39:05 <xplat> writing assignments and tests is like coming up with a test suite for human beings
09:39:05 <medfly> hahaha
09:39:05 <jmcarthur> i would try to give assignments that require few words to explain but much work to complete ;)
09:39:13 <BeginnerHere> engla: so how can I fix it 
09:39:17 <kmc> "Prove P != NP"
09:39:20 <medfly> basically, almost none of my homework is checked 
09:39:20 <xplat> and you know how much developers love to write tests
09:39:28 <kmc> BeginnerHere, by learning Haskell.  do you have a book?
09:39:48 <medfly> kmc, professors like that should just not check homework
09:40:04 <BeginnerHere> kmc: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures
09:40:18 <engla> BeginnerHere: that's good, read that book
09:40:49 <mee> Homework should count for less than the difference between an A and a B, anyway, imo.
09:41:00 <xplat> heh, yes, all unchecked homework, tests only checked for your information, all the credit comes from the final test, final project and class participation
09:41:04 <engla> BeginnerHere: you have picked up the treeinsert algorithm from somewhere? anyway the way you use BinNode and EmptyTree is not in sync with how they are defined
09:41:18 <BeginnerHere> engl: I tried some stuff but I get Leaf out of scope error
09:41:24 <c_wraith> I think I'd go with "100% of your grade is 3 oral tests."  I'd expect about a 75% failure rate.
09:41:39 <xplat> (or not class participation if it's a 200-person lecture)
09:41:39 <medfly> heh..
09:41:48 <medfly> c_wraith, most of my courses are final exam as the grade only
09:42:37 <medfly> c_wraith, but to account for people having some mishaps on the day of the test, you can take it another time later, and if you had some unusual occasion, you can take it a third time :P
09:42:39 <engla> BeginnerHere: let's start here: you use EmptyTree, but it is not defined. How do you want your program to represent a singleton?
09:42:46 <c_wraith> I got an A in a class once.  The instructor later told me I should have taken the alternate oral final, which would have probably given me an A+
09:42:59 <medfly> I would never take oral finals
09:43:08 <medfly> thankfully they do not exist here
09:43:13 <medfly> yet :D
09:43:14 <c_wraith> Actually, that instructor is someone who is known to this community...  Zena Ariola.
09:43:21 <BeginnerHere> Well I have to have EmptyTree Constructor right
09:43:31 <kmc> most of our tests were take-home, often unlimited time
09:43:35 <medfly> every time I talk in here it feels like no one is paying attention to me
09:43:37 <medfly> kmc, cool!
09:43:44 <kmc> that was nice... except that you end up spending all of your unlimited time on them
09:43:50 <medfly> hahaha
09:43:56 <kmc> others were take-home but you have to stop 4 hours after you start
09:43:57 <kmc> etc
09:44:39 <medfly> kmc, sounds like it's even cheaper to the system than what we have
09:44:42 <medfly> which is pretty unusual to have
09:44:51 <engla> BeginnerHere: this was discussed before, whether you should use 'Leaf a' or 'EmptyTree' -"style" trees.
09:44:55 <BeginnerHere> engl: I tried this treeInsert x EmptyBinTree = Leaf x 
09:44:57 <shapr> I'd take oral finals, I'm much better with that approach.
09:45:05 <BeginnerHere> error
09:45:10 <medfly> shapr, how come?
09:45:41 <engla> BeginnerHere: for simplicity, choose either Leaf or Empty-"style" tree and define that
09:45:54 <shapr> medfly: I'm not sure why, but I do know that verbal questions asked by another human activate my memory more easily.
09:46:29 <mee> I think purely oral finals would sometimes pass students with low aptitude but high charisma.
09:46:43 <shapr> mee: Oh, that's totally me :-)
09:46:48 * shapr grins
09:47:03 * mee fights the desire to give shapr money
09:47:19 <medfly> I consistently get panic attacks during exams lately. I imagine that freaking out like that during an oral exam would be bad for my grade
09:47:30 <kmc> that's why you have to get drunk first
09:47:39 <mee> kmc: haha
09:47:39 <medfly> I've received that tip before
09:47:56 <c_wraith> just aim for the ballmer peak?
09:48:09 <shapr> I don't understand panic during exams... I flunked out of college once already, what's the worst that could happen now?
09:48:24 <c_wraith> shapr: you might become a professor
09:48:29 <medfly> shapr, I don't know...
09:48:39 <shapr> c_wraith: oh no, that's worse than I ever thought...
09:48:49 <mee> and it'd fail students with passable aptitude but poor language skills -- like my friend in college who grew up in the ghetto and would explain that you forgot plank's constant by saying "yo mein, your h is messed up mang"
09:48:50 <c_wraith> shapr: just warning you :)
09:49:47 <monochrom> I change attitude from "oral exam is when they judge the lowly me" to "oral exam is when I teach the lowly them". This turns the game around. Also s/oral exam/giving a talk/
09:49:48 <medfly> I can't imagine how to answer most of the questions that I get verbally...
09:49:59 <kmc> independent, original projects are hard to cheat on
09:50:37 <medfly> shapr, just talking to the professors makes me uncomfortable.
09:50:57 <shapr> kmc: That is an excellent idea...
09:51:12 <shapr> kmc: "Write a simple xmpp chat client in Haskell"
09:51:16 <medfly> kmc, but they are more expensive to check
09:51:51 <shapr> medfly: But the point of an education is to teach. It was never designed to be a rich kid's prerogative.
09:52:05 <medfly> besides, original projects ARE easy to cheat on
09:52:09 <shapr> how so?
09:52:11 <medfly> you just post them on rentacoder.
09:52:24 <jmcarthur> i always hated "class participation" grades
09:52:40 <jmcarthur> what's the point if i'm pretty sure i already know the subject well enough to pass the tests?
09:52:49 <jmcarthur> it's my own fault if i was wrong
09:52:54 <shapr> I do know of at least one instance where a student from City College in the UK paid a #haskell user several hundred dollars to have their final project written for them.
09:53:12 <shapr> jmcarthur: I agree.
09:53:16 <monochrom> class participation grade is there to increase class participation.
09:53:28 <medfly> what the hell is class participation grade?
09:53:41 <shapr> jmcarthur: Maybe if they refunded some of your tuition each time you attended class?
09:53:42 <jmcarthur> medfly: points docked if you don't show up, usually
09:53:49 <jmcarthur> shapr: ha!
09:53:57 <shapr> That way it would be clear whether it's a "donation" to get a credit.
09:54:15 <shapr> Which is my current approach to college... I just want a piece of paper.
09:54:17 <monochrom> class participation grade encourages you to speak up when the teacher wants someone to speak up.
09:54:25 <shapr> I don't think it's likely I'll learn anything useful in this degree program.
09:54:37 <jmcarthur> shapr: when that's all a degree is, it's not different from a certification :\
09:54:38 <kmc> jmcarthur, in my experience participation grades are a way for the prof to pass otherwise marginal students who are trying really hard
09:54:41 <shapr> Maybe at MIT or Harvard, or Chalmers or Oxford... but where else?
09:54:46 <medfly> man that sounds horrible...
09:54:56 <jmcarthur> shapr: same boat for my degree though :(
09:54:57 <monochrom> Toronto
09:55:07 <kmc> i'm told MIT has almost no PL these days
09:55:10 <kmc> they don't even teach SICP
09:55:17 <medfly> PL?
09:55:20 <jmcarthur> wait, at all? even in an elective?
09:55:21 <kmc> programming languages
09:55:25 <shapr> medfly: Feel horrible too, I spend $300 per credit hour.
09:55:32 <monochrom> MIT is all about AI and robots
09:55:37 <medfly> I think MIT is a university :)
09:55:44 <kmc> jmcarthur, only during IAP
09:55:47 <kmc> medfly, it's an Institvte
09:56:05 <monochrom> eh, nice Roman word :)
09:56:13 <jmcarthur> IMO, education and certification should be separated
09:56:23 <jmcarthur> they are different things with different purposes
09:56:39 <medfly> I don't really see why anyone would learn some of the more popular things if not to get a job
09:56:40 <monochrom> MIT is not a university because it lacks some subjects.
09:56:44 <ezyang> monochrom: Unfortunately, it's not too far from the truth :-) 
09:57:11 <shapr> jmcarthur: That's an excellent point. #haskell does education
09:57:16 <monochrom> OTOH, MIT couldn't care less about those subjects.
09:57:29 <jmcarthur> as an extension to my thought, certification should be a lot more difficult to get than it usually is
09:57:45 <kmc> MIT is fantastically well-rounded compared to Caltech
09:57:48 <shapr> I learned lots of useful stuff at the MIT CS AI Lab... but I was there for the Boston Haskell meetings.
09:57:50 <mee> shapr: speak for yourself, I'm hear to become mayor of #haskell on 4sq's new IRC website
09:57:55 <kmc> (being several times as large)
09:57:56 <shapr> mee: rock on!
09:58:08 <shapr> mee: Being mayor of #haskell is very much work, seriously.
09:58:17 <mee> here, even. :P
09:58:52 <ezyang> Yeah, the first three disappeared mysteriously after a week. 
09:59:01 <ezyang> Something about an escaped Skolem variable. 
09:59:11 <kmc> @quote skolem
09:59:11 <lambdabot> No quotes match. Where did you learn to type?
09:59:25 <shapr> ezyang: I don't know if that's why the first founder of #haskell disappeared..
09:59:25 <jmcarthur> i hunt loose skolems for sport
09:59:49 <shapr> ezyang: His nickname is no longer registered, it was linoleum.
10:00:03 <mee> kmc: yeah I love the HUM classes at caltech.. math as economics, math as sociology, math as art, ...
10:00:18 <kmc> hehe
10:00:23 <monochrom> wow, so the theory "there was something before the big bang" is true!
10:00:35 <kmc> to be fair "math as economics" is a better way to approach economics than 90% of what's written
10:00:54 <mee> yeah, I tease but I am honestly quite jealous :P
10:01:27 <shapr> mee: You want to be the mayor of #haskell? I hear the position is free for the taking.
10:01:53 <monochrom> I'd rather be the mayor of Terminus.
10:02:49 <shapr> mee: or do you want to learn Haskell at MIT after hours? That's also monetarily free, but requires other effort.
10:03:30 <shapr> I just want an undergrad CS degree!
10:03:41 <monochrom> haskell as astrology
10:03:50 <Boxo> btw, can one get this lambdabot into one's channel?
10:04:07 <shapr> I was born under the sign of schönfinkelling.
10:04:14 <monochrom> some privileged people can
10:04:28 <mee> I'm not cut out for politics -- and learning haskell after hours at MIT would be great except that I'm very far away (unless I move there next spring)
10:04:31 <medfly> yes
10:04:33 * hackagebot digestive-functors 0.0.2.0 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.0.2.0 (JasperVanDerJeugt)
10:04:46 <shapr> hyvää huomenta boxo! Have you tried cabal install lambdabot?
10:05:04 <shapr> mee: Mayor of #haskell just requires time spent helping out, nothing more.
10:05:19 <Boxo> nah shapr, never ran an irc bot
10:05:33 * hackagebot digestive-functors-snap 0.0.2.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.0.2.0 (JasperVanDerJeugt)
10:05:38 <Boxo> also, "hyv huomenta?". Where did you learn finnish?
10:05:41 <medfly> you can ask someone to make it join you
10:05:45 <shapr> If you want to learn Haskell and you want to run an irc bot, try cabal install lambdabot !
10:06:08 <shapr> Boxo: The bits I remember I learned on Tornio, southwest of Rovaniemi.
10:06:30 <Boxo> well we had it on #lesswrong a few weeks back, but then it disappeared. If you want to give us the gift of lambda we'd appreciate it
10:06:34 * hackagebot digestive-functors-happstack 0.0.2.0 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.0.2.0 (JasperVanDerJeugt)
10:06:44 <medfly> lol, the gift of lambda
10:06:51 <sm> that's one way of putting it
10:06:59 <mee> (it's an anonymous gift)
10:07:20 <monochrom> pun!
10:08:07 <monochrom> gift of combinators - does not contain free items
10:08:39 <benmachine> :(
10:08:54 <monochrom> why are you unhappy?
10:09:23 <benmachine> I want free items
10:09:36 <Boxo> sweet! thanks, anonymous benefactor
10:10:22 <shapr> Boxo: But it is a temporary gift, I'd suggest cabal install lambdabot 
10:10:23 <kmc> anonymous benefunctor
10:10:30 <shapr> hah
10:10:34 * hackagebot digestive-functors-blaze 0.0.2.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.0.2.0 (JasperVanDerJeugt)
10:10:38 <monochrom> but you don't want someone else to just go around colllecting free samples of shampoos etc and give you as gift, do you?
10:13:08 <unkanon_> lambdabot isn't that easy to install
10:13:56 <Saizan> Boxo: if you want it to be stable you should @ask Cale
10:14:12 <Boxo> ookay
10:18:53 <monochrom> "I will find some time develop GUI mail-client..." - Manatee
10:19:36 <xplat> manatee-kitchen-sink, will LITERALLY be on hackage by year's end
10:19:41 <monochrom> The law of software envelopement is true! All software evolves to include an email client.
10:20:37 <xplat> oh, come on, that's hardly a good example, manatee (the program) was designed to be an emacs-like living space from the get-go
10:20:49 <chsigi> Hi guys! I am trying to enumerate all the items in a list, the best I can come up with is        myNumList aList = map (\x -> snd x ++ ":" ++ show (fst x)) (zip [1 .. (length aList)] aList)
10:20:58 <chsigi> What would you do better?
10:22:00 <monochrom> zip [1 .. ] aList  is just as safe
10:22:29 <BestCode> how can i check if a tree is empty with a booelan function
10:22:30 <BestCode> ?
10:22:42 <xplat> chsigi: i'd switch the fst and the snd
10:22:51 <monochrom> map f (zip x y) = zipWith (rewrite f a bit) x y
10:23:02 <chsigi> xplat: I want the number at the end ...
10:23:09 <BestCode> how can i check if a tree is empty with a booelan function having this type  [a] -> Bool.
10:23:25 <xplat> chsigi: sorry, i can't help you then :)
10:23:25 <Boxo> > let f xs = [show i ++ ":" ++ show x | (x,i) <- zip xs [1..])] in f [12,65,2]
10:23:27 <lambdabot>   <no location info>: parse error on input `)'
10:23:58 <Boxo> > let f xs = [show i ++ ":" ++ show x | (x,i) <- zip xs [1..]] in f [12,65,2]
10:23:59 <lambdabot>   ["1:12","2:65","3:2"]
10:24:04 <xplat> BestCode: you can't
10:24:13 <BestCode> oh man
10:24:17 <monochrom> "[a]" is not even the type of your tree.
10:24:30 <chsigi> monochrom: Thanks, I will have a look at zipWith
10:24:42 <BestCode> i have a type like this quicktree :: (Ord a) => [a] -> BinTree a 
10:25:08 <monochrom> "BinTree a" is your tree type, no?
10:25:24 <BestCode> yes
10:25:47 <monochrom> I need your signature here so you can't deny it later.
10:25:53 <chsigi> Boxo: Ah. Thanks.
10:26:06 <BestCode> what you mean
10:26:11 <BestCode> oh lol
10:26:12 <nostard> chsigi: myNumList2 xs = zipWith (\i x -> show i ++ ":" ++ show x) [1..] xs, this works to =)
10:26:43 <chsigi> Boxo: Is there a reason that you don't use zipWith like everyone else is suggesting?
10:26:55 <monochrom> the type for "is this tree empty?" is BinTree a -> Bool
10:27:16 <nostard> chsigi: you could also use fold with a counter :P
10:27:19 <monochrom> And now I need to know the details of BinTree
10:27:29 <Boxo> chsigi, not really. I just like list comprehension.
10:28:25 <Boxo> zipWith is more elegant in this case, gotta admit
10:34:51 <ExtremeTomato> I don't suppose you guys offer any help with Cabal errors, do you?
10:35:00 <Twey> > let f = zipWith ((++) . (++ ":") `on` show) [1 ..] in f [12, 65, 2]
10:35:01 <lambdabot>   ["1:12","2:65","3:2"]
10:35:36 <zygoloid> > (filter(`notElem`"0+.").intercalate", ".map show.flip(zipWith(:+))[1..]) [5,10,3,9,8]
10:35:36 * monochrom attempts at sarcasm again!
10:35:37 <lambdabot>   "5 : 1, 1 : 2, 3 : 3, 9 : 4, 8 : 5"
10:35:43 <Twey> > let f = zipWith (printf "%s:%s" `on` show) [1 ..] in f [12, 65, 2]
10:35:44 <lambdabot>   Ambiguous type variable `c' in the constraints:
10:35:44 <lambdabot>    `Text.Printf.PrintfType ...
10:36:07 <Twey> Hmph
10:36:16 <zygoloid> complex numbers ftw
10:36:45 <Twey> > let f = zipWith (on colon show) [1 ..] where colon x y = x ++ ":" ++ y in f [12, 65, 2]
10:36:46 <lambdabot>   ["1:12","2:65","3:2"]
10:36:51 <Twey> Maybe
10:37:49 <platzhirsch> Omg, I just saw LYAHFGG is being published?
10:38:19 <Botje> yes
10:38:24 <Botje> PREORDER OR DIE
10:38:43 <monochrom> in fact the author expects to receive much money soon so he can buy his favourite books
10:39:11 <platzhirsch> awesome
10:39:36 <platzhirsch> Will there be exlusive material inside?
10:40:45 * hackagebot ncurses 0.1.0.3 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.1.0.3 (JohnMillikin)
10:41:19 <Botje> platzhirsch: i'm secretly hoping for an A0 poster of the list monster.
10:41:45 <jmcarthur> lol
10:42:04 <monochrom> A0 is bigger than A1, isn't it?
10:42:22 <monochrom> Is there also A(-1)? :)
10:42:30 <zygoloid> yes
10:42:31 <platzhirsch> monochrom: sure
10:42:36 <zygoloid> used by some industrial plotters iirc
10:42:47 <monochrom> oh god, be careful what I wish for
10:42:51 <Twey> Heh.
10:43:06 <monochrom> thank god for integers!
10:43:14 <ExtremeTomato> ISO 216
10:43:52 <Twey> I don't see a -1
10:43:55 <Twey> But there is an A0+
10:44:05 <Twey> Which, confusingly, is larger than A0
10:44:19 <ziman> What about A0.5? :)
10:44:33 <zygoloid> B0?
10:44:38 <ziman> or Aπ :)
10:44:42 <c_wraith> It just occured to me you don't mean Aleph0 and Aleph1
10:44:49 <zygoloid> haha
10:44:56 <Twey> Heh
10:45:00 <c_wraith> I was like, no, A1 is bigger than A0!!!!!
10:45:14 <zygoloid> haha
10:45:27 <zygoloid> wut, Aleph 1 is exactly half the area of Aleph 0?
10:45:33 <Twey> Heh
10:45:42 <c_wraith> But both have infinite area
10:45:46 <xplat> you can pack it tighter because it's continuous!
10:46:03 <xplat> lol
10:46:18 <cads_> hey augur
10:46:24 <zygoloid> does this channel assume the continuum hypothesis then? :)
10:46:27 <augur> cads_!
10:46:32 <cads_> man!
10:46:42 <augur> my sweetest dearest cads_
10:46:46 <augur> oh mon cherise
10:46:47 <cads_> I have a language issue
10:46:49 <augur> mon amour
10:46:54 <augur> language huh
10:46:59 <cads_> but it's a natural language processing problem, nothing else
10:47:11 <cads_> and I'm not sure you like that area much
10:47:32 <xplat> zygoloid: prepending 'in the constructible universe, ' takes a little of the punch out of a punchline, is all ...
10:47:33 <cads_> heh, my dearest, I think of you whenever these come up though
10:47:35 <augur> i hate it, but ill give it a shot
10:48:29 <xplat> especially when the statement is a non sequitur to begin with :)
10:48:40 <cads_> I was just thinking of a word lookup that takes IPA as input, for use when you're looking for a word that sounds one particular way.
10:48:53 <monochrom> I would love that!
10:49:10 <cads_> And then I thought about what about if you pronounce the word wrong?
10:49:11 <unkanon_> cads_: are you implementing that?
10:49:13 <xplat> heh, IPA is largely a metric space, too
10:49:15 <unkanon_> that would be way cool
10:49:30 <cads_> unkanon_, I might just have to :)
10:49:30 <xplat> so you could get a good metric for approximate lookup
10:49:35 <ExtremeTomato> cads_: the US military did that with the ascii phonetic system they use
10:49:55 <ExtremeTomato> (d)
10:50:05 <cads_> oh I bet this would be "pick and choose" research/development at its finest - there's got to be mounds of work already done
10:51:56 <cads_> heh, it all started because some daft autocorrection engine didn't have the word analyses in its dictionary and it was making me freak out thinking I'd forgotten how to spell analyses :P
10:52:14 <ExtremeTomato> isbn 013095069 has a decent selection of stuff on phonetics and state machines therefor
10:54:07 <unkanon_> cads_: it's tough, though, to allow for all levels of ipa detail
10:54:12 <cads> check that once. neither zotero or google recognize the isbn
10:54:36 <ExtremeTomato> I typed it into google and got the book in front of me back
10:54:40 <ExtremeTomato> but it does have no checkdigit
10:54:59 <cads> unkanon_, tbh, I know little of ipa's full syntax
10:55:09 <cads> and, augur, I mostly just wanted to say hi :)
10:55:25 <cads> unkanon_, but this is exciting
10:56:03 <ExtremeTomato> 0130950696 with the check digit.  Sorry
10:56:49 * hackagebot splot 0.1.5 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.5 (EugeneKirpichov)
10:56:59 <cads> nice
10:57:15 <augur> cads_: what is your question, exactly
11:01:07 <ExtremeTomato> Aspell also has fast soundalike routines, but they're designed for speed.  There's a wealth of literature in the spellchecking community too, but I think everyone uses soundex, which parses its own phoneme structure from the text.
11:02:05 <cads> augur, well, so as the first step we have some language that is interpreted more or less easily into phonemes by a set of rules. I have a pretty vague idea about that.
11:02:25 <augur> wait but what is the question :|
11:02:29 <cads> But not really good enough that I could start off and say  "data Phoneme = ...."
11:02:42 <cads> and provide some first BS approximation  :)
11:02:59 <unkanon_> cads: spanish is easily interpreted into phonemes but it might be too easy to make it worth it
11:03:21 <cads> so I guess I want to ask what is the set of phonemes and how might we represent it with a data-structure?
11:03:31 <augur> uh
11:03:37 <augur> the set of phonemes for what, english?
11:03:43 <unkanon_> for ipa
11:03:50 <augur> ipa has no phonemes.
11:04:00 <unkanon_> meh ya know what I mean :)
11:04:06 <cads> ok, so a language has its own set of phonemes
11:05:00 <cads> can a phoneme be any sound that humans can consistently make and recognize?
11:05:16 <cads> with their mouths, that is
11:05:20 <unkanon_> you know what would be cool to? a function :: WaveFile -> IPAtext
11:05:30 <augur> phonemes are essentially sets of phones
11:05:31 <ExtremeTomato> A phoneme is the smallest valid utterance
11:05:41 <augur> unkanon_: praat?
11:05:48 <augur> ExtremeTomato: no, that is false.
11:05:56 <ExtremeTomato> In what way?
11:05:58 <unkanon_> augur: I thought praat just showed you the waves and stuff
11:06:00 <unkanon_> not the ipa
11:06:00 <augur> in every way.
11:06:11 <ExtremeTomato> haha, please correct me
11:06:13 <augur> unkanon_: probably true. i dont use praat, so.
11:06:28 <augur> ExtremeTomato: see my answer above.
11:06:57 <sipa> you may want to define 'phone', augur :)
11:07:03 <ExtremeTomato> ahh, sorry
11:07:06 <cads> hmm, apparently phones are individual sound units of speech, though not necessarily phonemes in a language
11:07:32 <augur> sipa: type Phone = IPA
11:07:43 <cads> err, to give the definition, "an individual sound unit of speech without concern as to whether or not it is a phoneme of some language"
11:08:14 <unkanon_> augur: yeah it doesnt output ipa
11:08:35 <augur> cads: type Phoneme = [Phone]
11:09:23 <kmc> the selfish phoneme
11:09:29 <tehgeekmeister> anyone heard talk of turning halvm into an ec2 image somehow?
11:09:53 <xplat> a phoneme is a set of phones, sure, but isn't it only represented by a single phone in a particular utterance?
11:11:04 <augur> xplat: that depends on whether you're talking about a phonetic or phonemic transcription.
11:11:28 <augur> type PhoneticTranscription = [Phone]
11:11:34 <augur> type PhonemicTranscription = [Phoneme]
11:11:46 <augur> really, we might want to say type Phoneme = Set Phone
11:11:50 <augur> or whatever
11:12:26 <ExtremeTomato> Aren't they equivalent for comparative purposes (I mean linguistically), augur?
11:12:34 <augur> no.
11:13:04 <Saizan> different languages have different phonemes
11:13:27 <cads> augur, is the set of phones determined more or less by the distinct actions the average person can perform to utter sounds?
11:13:45 <sipa> and whether two (sequences of?) phones are considered to belong to the same phoneme also depends on the language?
11:14:22 <cads> augur, rather, how is it determined
11:14:52 <Saizan> sipa: it seems so: see the second paragraph here http://en.wikipedia.org/wiki/Phoneme
11:15:04 <xplat> phones, afaik, as being used here are the most fine discrimination of sound that a human could be trained to produce and recognize as speech.  phoneme is a somewhat broader region of sound-space that represents the distinctions people actually make in a particular language/dialect
11:15:05 <augur> cads: the set of phones is roughly language specific
11:15:40 <xplat> but i may have phones a little wrong
11:16:08 <augur> xplat: youre basically exactly correct
11:16:23 <augur> tho what constitutes a phone is a matter of debate
11:16:35 <Twey> xplat: Phones are generally considered to be only those sounds that are actually distinguished in some languages
11:16:59 <chsigi>  /j #xmonad
11:17:02 <augur> Twey: eh. sort of.
11:17:20 <Twey> There's only so much accuracy you can reasonably encode
11:17:37 <augur> Twey: acoustic signals!
11:17:39 <sipa> hmmm
11:17:47 <Twey> augur: Still analogue :þ
11:18:02 <augur> Twey: but 100% accurate!
11:18:17 <xplat> Twey: there's only so much accuracy with which a human can handle sound at the speed of fluent speech, too
11:18:22 <Twey> Nah, I'm sure you'd lose some of the finer details :þ
11:18:25 <Twey> xplat: Right
11:18:33 <Twey> Or at all, in fact
11:18:34 <cads> so a unique sound that someone has learned to make is not necessarily a phone?
11:18:38 <augur> Twey: in an ideal world
11:18:47 <augur> cads: what
11:18:57 <Cin> THEN WHO WAS PHONE?
11:18:57 <xplat> cads: well, beatboxing
11:19:14 <Twey> If I pronounce [s] with my tongue half a millimeter further back than I usually do, I doubt there are many people who would argue I'd just created a new phone :þ
11:19:21 <Twey> (or even be able to tell >.>)
11:20:29 <augur> Twey: s_<
11:20:44 <Twey> augur: A quarter of a millimeter? :þ
11:20:44 <cads> augur, a phone seems to be an equivalence class of a lot of different actual utterances - made at different pitches, different speeds, volumes, having lots different 'qualities' to the sound
11:20:45 <sipa> is there any language which has both the english approximant-R, and some form of trill-R, and distinuishes between both?
11:20:49 <augur> or whatever it is
11:21:00 <cads> rather than just one distinct sound
11:21:06 <xplat> blowing your nose, slapping your knees, or having a horrible couching fit are meant to be excluded, but clicking your tongue isn't
11:21:19 <cads> but all sounding alike to a human and recognizable as the same phone
11:21:51 <cads> I should say, all sounding alike to a human that has learned a language it's used in
11:21:57 <Twey> sipa: Some dialects of Spanish apparently do
11:22:45 <cads> twey, I wondered that too :)
11:22:55 * monochrom combines Morse code and tongue clicking to form a new spoken language!
11:23:23 <augur> afk
11:23:41 <bestcodeone> hello can anyone help me with this: http://pastebin.com/cka8L6vp
11:24:47 <ziman> sipa, for example Spanish has both pero (short r, meaning "but") and perro (trill r, meaning "dog")
11:25:01 <Twey> bestcodeone: What's it supposed to do?
11:25:12 <ion> dog buts stink
11:25:14 <Twey> ziman: Nah, that's [ɾ] vs. [r]
11:25:34 <Twey> But some dialects apparently use [ɹ] as an allophone of [s] before [θ]
11:25:50 <Twey> dosciento [doɹθiento]
11:26:00 * hackagebot hamlet 0.6.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.6.1 (MichaelSnoyman)
11:26:05 <Cin> Anyone got a talk I can listen to while cooking my dinner?
11:26:52 <ziman> Twey, is there any table anywhere where I can look up (and listen to) these sounds?
11:27:16 <sm> Cin: this developer's life podcast ?
11:27:16 <bestcodeone> Twey: ok this is suppose to be a 1D kenken puzzle solver
11:27:43 <Twey> ziman: Wikipedia for Ogg Vorbis; http://www.paulmeier.com/ipa/charts.html for Flash
11:27:58 <bestcodeone> I can solve it
11:28:46 * Twey has no idea what one of those is, so leaves it for someone else.
11:29:17 <ziman> cool, thanks :)
11:30:03 <rredd> @pl \a as -> f a (g as)
11:30:03 <lambdabot> (. g) . f
11:37:11 <xplat> hm, i've heard of prefix, postfix, infix, circumfix, and mixfix, but what is distfix?
11:39:20 <tromp_> what is circumfix?
11:39:55 <xplat> an operator with a prefix and a postfix part, like () or []
11:40:19 <ExtremeTomato> "A distfix operator is a syntactic construct in which an operator symbol is distributed among its operands" --- Simon L. Peyton Jones
11:40:19 <tromp_> is if-then-else circumfix?
11:40:40 <xplat> i guess it's distfix
11:40:47 <Botje> so smalltalk's keyworded messages are distfix
11:40:51 <ExtremeTomato> he gives if-then-else as a common example
11:41:43 <xplat> and the C ternary operator
11:43:07 <xplat> hm, the package cautious-file presents a dilemma
11:43:54 <kmc> i've heard circumfix called "outfix" too
11:43:55 <xplat> on the one hand, it takes precautions, when writing a file, to reduce the chance of incidental data loss due to crashes or power failures
11:44:25 <kmc> and i've heard "mixfix" as the generic term for operators with n parts with holes between and around them
11:44:29 <kmc> i.e. what Agda supports :D
11:44:38 <xplat> otoh, using a 0.1.5, stability-experimental package seems like it would increase the risk of data loss for other reasons :)
11:45:46 <xplat> otgh, if i don't use cautious-file to write my files, i will probably write my own insufficiently-tested cautious-writing code anyway
11:46:00 <ExtremeTomato> Are mixfix operators re-orderable, kmc?
11:51:26 <kmc> i don't know what that means
11:51:47 <ExtremeTomato> nor do I now I've read more about it
11:52:43 <ExtremeTomato> distfix == mixfix, it seems
11:53:15 <shapr> I prefer chixflix
11:53:37 * shapr kicks himself to the off-topic channel
11:54:18 <shapr> heippa hei ion, opetko Haskellia? Or something like that?
11:55:24 <ion> “osaatko”? A bit.
11:55:46 <sleepynate> wat
11:55:59 <shapr> ion: I can't remember the verb for learning :-/
11:56:13 <sleepynate> oh you guys are speaking another language
11:56:23 <olsner> shapr: why so finnish?
11:56:24 <sleepynate> wow my brain is fried... is it friday yet? :/
11:56:32 <olsner> or whatever that is
11:56:35 <shapr> sleepynate: Yah, that's my rendition of Finnish as spoken by someone born in Alabama.
11:57:01 <shapr> olsner: I'm not getting any Swedish discussion here in Alabama, so....
11:57:19 <xplat> try minnesota
11:57:42 <sleepynate> shapr: you could speak finish with Toastertron, who is finnish from st louis :)
11:57:58 <sleepynate> you have my permissions to annoy him
11:57:59 <ion> Ah, “opitko”. A more fluent way to put it would be e.g. “oletko oppinut/opettelemassa” (“have you learned/been learning / are you studying”).
11:58:09 <xplat> not this time of year though, if you move from alabama to minnesota in winter you will become an involuntary cryonaut
11:58:29 <ion> “oletko oppinut” would fit as a continuation for an earlier conversation about “oletko opettelemassa”. :-)
11:58:34 <chsigi> I want to use the return value of findIndex which is of type Maybe as a string. How do I do it? If I use "show (findIndex "foo" ["foo", "bar", "baz"])" I get 'Just 1'.
11:58:45 <engla> xplat: if you're truly finnish it should be ok
11:59:02 <unkanon_> chsigi: fromJust ?
11:59:10 <unkanon_> @type fromJust
11:59:12 <lambdabot> forall a. Maybe a -> a
11:59:21 <unkanon_> it unboxes a Just
11:59:28 <Boxo> > let x = Just 1 in case x of {Just q -> q; Nothing -> 13} -- chsigi
11:59:29 <lambdabot>   1
11:59:35 <kmc> fromJust considered harmful
11:59:44 <kmc> since it throws an extremely unhelpful error message if it's Nothing
11:59:51 <benmachine> chsigi: er, you want to use it as a string?
11:59:53 <kmc> you should use 'fromMaybe', 'maybe', or straight-up pattern matching
11:59:56 <aristid> > fromJust Nothing
11:59:57 <lambdabot>   *Exception: Maybe.fromJust: Nothing
12:00:06 <benmachine> chsigi: what string to you want exactly
12:00:08 <aristid> :t fromMaybe
12:00:08 <lambdabot> forall a. a -> Maybe a -> a
12:00:13 <unkanon_> I can never get fromMaybe to work
12:00:19 <Boxo> > fromMaybe Nothing
12:00:20 <lambdabot>   Overlapping instances for GHC.Show.Show
12:00:20 <lambdabot>                              (Data....
12:00:21 <xplat> maybe show "Not found" $ findIndex "foo" ["foo", "bar", "baz"]
12:00:22 <aristid> > fromMaybe (error "kmc wants a nice error") Nothing
12:00:22 <lambdabot>   *Exception: kmc wants a nice error
12:00:23 <unkanon_> > fromMaybe (Just 1)
12:00:24 <lambdabot>   Overlapping instances for GHC.Show.Show
12:00:24 <lambdabot>                              (Data....
12:00:26 <benmachine> unkanon_: eer, how so
12:00:27 <unkanon_> see?
12:00:40 <aristid> unkanon_: you need to supply the default value for fromMaybe
12:00:45 <benmachine> > fromMaybe 0 (Just 1)
12:00:46 <lambdabot>   1
12:00:46 <aristid> unkanon_: but that can be an error value, too
12:00:50 <Boxo> > let x = Just 1 in fromMaybe 333 x
12:00:51 <lambdabot>   1
12:00:54 <unkanon_> oh I misread the sig, sorry
12:00:56 <xplat> > maybe show "Not found" $ findIndex "fob" ["foo", "bar", "baz"]
12:00:57 <lambdabot>   Couldn't match expected type `a -> a1 -> GHC.Base.String'
12:00:58 <lambdabot>         against i...
12:01:07 <alpounet> @type maybe
12:01:08 <alpounet> :)
12:01:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:01:09 <unkanon_> gotcha
12:01:12 <kmc> > fromMaybe 'x' Nothing
12:01:13 <lambdabot>   'x'
12:01:17 <kmc> > fromMaybe 'x' (Just 'y')
12:01:18 <lambdabot>   'y'
12:01:25 <xplat> oh, wrong way
12:01:29 <unkanon_> @type maybe
12:01:30 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:01:38 <kmc> fromMaybe d = maybe d id
12:01:39 <xplat> > maybe "Not found"  show $ findIndex "foo" ["foo", "bar", "baz"]
12:01:40 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:01:41 <lambdabot>         against inferred ...
12:02:13 <Boxo> > maybe False odd Nothing
12:02:14 <lambdabot>   False
12:02:19 <Boxo> > maybe False odd (Just 3)
12:02:20 <lambdabot>   True
12:03:10 <ion> Is there a way to ask ghci to list known modules that export a function by a given name? For instance, “where is fromJust” or “which modules implement (>>=)”.
12:03:13 <xplat> > maybe "Not found" show $ Just 1
12:03:14 <lambdabot>   "1"
12:03:26 <unkanon_> ion: I think you have to use hoogle for that
12:03:33 <unkanon_> but I wish I'm wrong
12:03:36 <tromp_> maybe Nothing Just Nothing
12:03:39 <tromp_> > maybe Nothing Just Nothing
12:03:40 <lambdabot>   Nothing
12:04:13 <xplat> @type findIndex "foo" ["foo", "bar", "baz"]
12:04:14 <lambdabot>     Couldn't match expected type `a -> Bool'
12:04:14 <lambdabot>            against inferred type `[Char]'
12:04:14 <lambdabot>     In the first argument of `findIndex', namely `"foo"'
12:04:50 <xplat> > maybe "Not found" show $ findIndex ("fob" ==) ["foo", "bar", "baz"]
12:04:51 <lambdabot>   "Not found"
12:04:51 <tromp_> elemIndex
12:04:59 <xplat> > maybe "Not found" show $ findIndex ("foo" ==) ["foo", "bar", "baz"]
12:05:00 <lambdabot>   "0"
12:05:53 <ion> Bliss! cabal install hoogle provides a nice CLI command. No need to switch to the browser. :-)
12:05:59 <ziman> ion, you can also use lambdabot's @index ;)
12:06:10 <unkanon_> ion: you can even make hoogle work inside ghci
12:06:41 <aristid> :t flip maybe id
12:06:42 <lambdabot> forall a. a -> Maybe a -> a
12:06:46 * xplat fails to find anything on hackage for heuristic filetype detection by magic numbers :(
12:06:47 <aristid> :t fromMaybe
12:06:48 <lambdabot> forall a. a -> Maybe a -> a
12:06:50 <unkanon_> I never use it inside ghci though because sometimes it gives so much output, and ghci doesn't have | less
12:07:09 <ion> I’m actually happy to use it directly from the shell prompt, since i always have at least one open for any given project i’m working on.
12:07:39 <xplat> i wish other repls were as nice about paging as psql
12:08:30 <xplat> it's not perfect, but at least it usually engages the pager if you need one
12:08:31 <ion> Indeed! Git DTRT as well, but it shouldn’t need to do that, that should be the job of the shell or the terminal.
12:08:34 <Twey> I wish shells were nicer for embedding EDSLs into
12:08:58 * Twey adds an entry to his TODO list.
12:09:41 <ion> hsh, the Haskell shell? :-)
12:09:55 <xplat> yeah, if i ever get around to designing my own OS, the CLI will *not* run on a glorified vt100
12:10:30 <aristid> xplat: why not?
12:10:37 <ion> The <whatsitsname> programming language has a brilliant REPL.
12:10:47 <ion> Factor
12:11:08 <Twey> Yeah, it's nice
12:11:11 <flux> a terminal with graphical elements would be nice. something like mathematica. or possibly like xmlterm..
12:11:12 <kmc> xplat, is there a c lib you can bind?
12:11:16 <xplat> aristid: the terminal should help with things like paging, tracking progress for background jobs, and so on
12:11:18 <flux> (well, s/would/could/)
12:11:27 <xplat> plus, yes, graphics
12:11:27 <unkanon_> why don't terminals seem to evolve?
12:11:29 <Twey> But nothing so ambitious… it would just be nice to have a REPL that worked together with the shell instead of replacing it with a specialised process
12:12:03 <xplat> kmc: there's the library from the unix 'file' command
12:12:09 <Twey> So you can pipe commands through less, for example
12:12:23 <xplat> it's what i used when i ported this thing to python before i ported it to haskell
12:12:40 <Twey> > [ghci$ :hoogle Foo -> Bar $] | less
12:12:41 <lambdabot>   <no location info>: parse error on input `:'
12:12:54 <ion> Factor: http://img40.imageshack.us/img40/2602/stencilv.png
12:12:57 <Twey> lambdabot: Shush… that prompt wasn't for you
12:13:22 <Twey> ion: It's pretty cool, yeah
12:13:28 <opqdonut> nice
12:13:41 <xplat> heh, shells with quasiquotation ... sounds awkward to use, though
12:13:43 <Twey> Factor has lots of nice stuff, for an untyped abomination ;)
12:14:14 <Twey> xplat: You could have an option to do it the other way around, too
12:14:34 <ezyang> What. /usr/bin/ld: libraries/dph/dph-seq/dist-install/build/Data/Array/Parallel/Lifted.dyn_o: relocation R_386_GOTOFF against undefined symbol `__stginit_dphzmseq_DataziArrayziParallelziLiftedziPArray_' can not be used when making a shared object /usr/bin/ld: final link failed: Bad value collect2: ld returned 1 exit status 
12:14:47 <Twey> xplat: ghci> :hoogle Foo -> Bar [sh$ | less $]
12:15:23 <Twey> ezyang: o.@
12:15:36 <mauke> zizizi
12:15:54 <xplat> i mean, as it is, you could turn ghci into a daemon and do $ ghciq ':hoogle Foo -> Bar' | less    in bash
12:16:04 <ezyang> actually I should probably post this to GHC 
12:16:15 <opqdonut> I think the .->zi rewrite gives cute names for symbols
12:17:27 <xplat> now i want to name packages things like 'Data.PapArray'
12:18:07 <Botje> Fuz.D.ze
12:18:16 <monochrom> FuzziDizze :)
12:18:23 <unkanon_> FizzBuzz
12:18:24 <unkanon_> oh wait
12:18:45 <mauke> preflex: zenc FizzBuzz
12:18:46 <preflex>  FizzzzBuzzzz
12:18:53 <Botje> (well, Dzize, but close enough :P)
12:19:08 <unkanon_> mauke: looking for a funny quote?
12:19:28 <mauke> unkanon_: no, why?
12:20:04 <unkanon_> oh, I thought you were looking for something somebody said about fizzbuzz that was funny and somebody had @remember'ed it
12:20:39 <mauke> 1) preflex is not lambdabot, so @remember does not apply
12:20:44 <mauke> 2) I didn't use the quote command
12:20:52 <mauke> 3) preflex didn't reply with a quote (or an error)
12:22:01 <Guest89770> Hello guys, could someone please help me a little with my code? Im trying to make my program check for a subsequence of strings, meaning, if i enter "gtr" and "aligator", it's supposed to return "true"
12:22:15 <Guest89770> So far, I've only got a basic first step in the form of:
12:22:16 <Guest89770> isSubsequence (x:xs) (y:ys)   | x == y = True   | otherwise = False
12:22:20 <unkanon_> ok, sorry then :/
12:22:40 <Guest89770> But in this case, it's also true if just the first letter is correct and the rest isn't
12:22:48 <Guest89770> I don't know to tell him to "keep checking" 
12:22:55 <Botje> Guest89770: call isSubsequence again.
12:23:26 <Guest89770> as a guard?
12:23:35 <Guest89770> Botje: as a guard?
12:23:46 <mauke> m(
12:24:07 <parcs> Guest89770: are you comfortable with recursion?
12:24:25 <Guest89770> parcs: not much, im still at my first steps with haskell and programming in general
12:24:39 <ezyang> What does the Haskell Report mean when it says “For the same reason, the existence of seq weakens Haskell's parametricity properties.” ? 
12:24:47 <xplat> have you done a factorial function or anything before?
12:25:21 <Botje> Guest89770: assuming you called isSubsequence "gtr" "gator", what should the next step be?
12:25:22 <Guest89770> xplat: well yes, but I can't code them "right away"
12:25:50 <Guest89770> Botje: well in that case he should return true, but if i entered "grt" and "gator", he should say "false"
12:26:00 <Guest89770> because the order of the strings should be important
12:26:02 <Botje> Guest89770: true should be the end result, yes
12:26:06 <Guest89770> yes
12:26:09 <Botje> Guest89770: but surely you need to check the t and the r too?
12:26:11 <mauke> Guest89770: the question is not what it should return. what should the next step be?
12:26:14 <monochrom> you have to break it down into smaller steps
12:26:24 <xplat> a lot of programming is about learning to break tasks down like that
12:26:46 <xplat> into steps so tiny you could teach your dog to do them :)
12:26:51 <unkanon_> I don't understand, "gtr" and "aligator" = true but "gtr" and "gator" = false?
12:26:58 <mauke> unkanon_: grt
12:27:10 <Guest89770> well ill say it like this:
12:27:16 <monochrom> alternatively you have to formalize, not just know examples.
12:27:17 <unkanon_> oh so the order matters
12:27:22 <mauke> <Guest89770> because the order of the strings should be important
12:27:46 <Guest89770> the idea is that he checks whether the first entered string is contained in the second one and in correct order
12:28:05 <Guest89770> so "gtr" is part of "aligator" and in right order, whereas "grt" is not
12:28:14 <Guest89770> because the R is after the T in "aligator"
12:28:21 <unkanon_> Guest89770: I usually draw graphs on a blank page of how I want my function to go about its business
12:28:27 <Botje> Guest89770: an idea would be to call isSubSequence again, but drop the first letter of the first word
12:28:30 <unkanon_> that usually helps to see how to write something I don't know yet
12:28:33 <xplat> maybe you should ask yourself: how much can you learn about the answer just by looking at the first letter of each word?
12:28:45 <Botje> and everything up to (the second letter of the first word) or the end of the string
12:29:45 <unkanon_> Guest89770: I think it'd be advantageous for you to get used to the list functions that Data.List provides, especially things like span, break, dropWhile, etc
12:29:46 <Twey> > let isSubstring [] _ = True; isSubstring _ [] = False; isSubstring xs@(x : xt) ys@(y : yt) | x == y = isSubstring xt yt | otherwise = isSubstring xs yt in isSubstring "gtr" "alligator"
12:29:47 <lambdabot>   True
12:29:53 <Twey> > let isSubstring [] _ = True; isSubstring _ [] = False; isSubstring xs@(x : xt) ys@(y : yt) | x == y = isSubstring xt yt | otherwise = isSubstring xs yt in isSubstring "gtr" "alligarot"
12:29:53 <lambdabot>   False
12:30:17 <Guest89770> whoa
12:30:21 <Guest89770> Twey: what does the @ mean?
12:30:32 <monochrom> what happens with "gtgtr" "gtr" ?
12:30:32 <Guest89770> Twey: is it like -> ?
12:30:33 <unkanon_> as-pattern. it means that xs is the same as x:xt
12:30:42 <Twey> Guest89770: Bind to the pattern on the right, and also the name on the left
12:31:00 <Cin> pC = do many pA; many pB; return ()
12:31:00 <Cin>  where pA = string "(foo)"; pB = string "(bar)"
12:31:00 <Cin>  Can anyone suggest a way in which I can express the notion of zero or more pA's, followed by zero or more pB's?
12:31:01 <Cin> As it stands, the pA parser is triggered first and thus short-circuits the whole parse when I try to parse "(bar"). With (try pA) and (try pB), I can parse "(bar)", but "(fo" is a valid, empty parse. No error is triggered.
12:31:03 <Cin> If I put an `eof' at the end, an error is triggered. Perhaps this is the key. But it's not great.
12:31:03 <Twey> So xs = (x : xt), except we're not reconstructing the list
12:31:20 <Twey> monochrom: False, I'd hope
12:31:23 <Twey> > let isSubstring [] _ = True; isSubstring _ [] = False; isSubstring xs@(x : xt) ys@(y : yt) | x == y = isSubstring xt yt | otherwise = isSubstring xs yt in isSubstring "gtgtr" "gtr"
12:31:24 <lambdabot>   False
12:31:38 <BONUS> > let isSubstring xs = elem xs . filterM (const [True,False]) in (isSubstring "gtr" "aligator", isSubstring "grt" "aligator")
12:31:39 <lambdabot>   (True,False)
12:31:56 <TeachmeHaskell> Hello
12:32:34 <monochrom> Cin: you are supposed to use eof once somewhere.
12:32:35 <BONUS> Hello
12:32:38 <Twey> :t filterM
12:32:38 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:32:46 <benmachine> BONUS: hmm, I'm sure it can be done cheaper than that :P
12:33:05 <Twey> Yes, well… of course I was just keeping it simple for the newbie… >.>
12:33:11 * Twey goes and cries in a corner.
12:33:11 <BONUS> sure, but this cost me $0 :)
12:33:19 * benmachine hugs Twey 
12:33:36 <benmachine> BONUS: it cost twey his dignity :(
12:33:44 <BONUS> im sorry :(
12:33:47 <benmachine> or, something
12:33:50 <Twey> Hehe
12:33:50 <Guest89770> hmm
12:33:51 <BONUS> ignore m
12:33:51 <BONUS> e
12:33:53 * monochrom prefer aligato to aligator
12:33:58 <Guest89770> Twey: as it seems, your code is working, but i still wonder why
12:34:01 <Twey> I like alligarots
12:34:02 * benmachine hugs BONUS too
12:34:05 <BONUS> wee
12:34:12 <Twey> Guest89770: Don't worry, I'm in the same position with BONUS' ;)
12:34:23 <mauke> > let []..._=True;a:b...(dropWhile(a/=)->c:d)=a==c&&b...d;_..._=False;infixl 4...in "gtr"..."alligator"
12:34:24 <lambdabot>   True
12:34:48 <Guest89770> Twey: at first you tell him "if there is an empty list and something, return true. if there is something and an empty list, return false" why did you do that?
12:34:50 <unkanon_> I like twertles
12:35:01 <benmachine> mauke: beautiful
12:35:26 <xplat> Guest89770: well, is "gtr" a subsequence of ""?
12:35:28 <Guest89770> alright and i dont understand maukes code at all :D
12:35:39 <benmachine> Guest89770: the empty list is a sublist of anything
12:35:45 <Twey> Guest89770: That's okay.  He intended it to be that way.  :þ
12:36:01 <benmachine> Guest89770: if the first list isn't an empty list, then it isn't a sublist of the empty list
12:36:13 <mauke> > let a:b...(dropWhile(a/=)->c:d)=a==c&&b...d;(null->a)..._=a;infixl 4...in "gtr"..."alligator"
12:36:14 <lambdabot>   True
12:36:18 <mauke> simplified
12:36:24 <Guest89770> "simplified" :D
12:36:46 <xplat> i don't even understand that code
12:36:49 <parcs> what is `(dropWhile(a/=)->c:d)`?
12:36:53 <xplat> what are those '...'s?
12:37:03 <monochrom> a use of view patterns
12:37:09 <BONUS> the ... is the function name
12:37:11 <benmachine> xplat: he's calling the function ...
12:37:23 <Guest89770> benmachine: ok so if the first list isnt an empty list (like in our case: grt), then it isnt a sublist of the empty list.. alright i see that
12:37:28 <Guest89770> benmachine: but why do i have to tell him?
12:37:35 <benmachine> Guest89770: tell who
12:37:42 <Guest89770> oh, that explains A LOT to me @ "he calls the function ..."
12:37:47 * monochrom transforms it into the longest increasing subsequence problem :)
12:37:50 <Guest89770> benmachine: well, the computer
12:37:58 <mauke> Guest89770: "it"
12:38:12 <benmachine> Guest89770: oh right, well, basically, if neither list is empty we reduce the problem into a smaller one
12:38:13 <xplat> Guest89770: your dog?  because your dog is stupid.  and a computer is stupider than your dog.
12:38:27 <BONUS> is the empty string a substring of the empty string?
12:38:29 <benmachine> Guest89770: and we keep doing that until one of the lists are empty
12:38:33 <benmachine> BONUS: yes
12:39:18 <Guest89770> hm
12:39:19 <xplat> or i should say, a computer can be smart, but it has no common sense.  if you didn't tell it something, it doesn't know
12:39:23 * hackagebot language-java-classfile 0.2.0 - Parser for Java .class files  http://hackage.haskell.org/package/language-java-classfile-0.2.0 (GergoErdi)
12:39:43 <monochrom> the computer has more common sense than the human
12:40:08 <monochrom> the computer knows "p implies q" and "q implies p" are different. the human doesn't.
12:40:25 <Guest89770> just by the way: what do you guys say instead of "it" or "him" etc? i always get mocked for it :D
12:40:33 <Martty> the computer simulates common sense, it doesnt have it
12:40:46 <sipa> what's the difference?
12:40:49 <benmachine> Guest89770: in english, "him" only refers to living things
12:40:49 <monochrom> http://www.umsu.de/logik/trees/ is a very useful page for logic homework
12:40:56 <benmachine> or well, things with personalities
12:40:56 <mauke> Guest89770: I say "it"
12:41:01 <benmachine> or erm
12:41:03 <xplat> Guest89770: we mostly don't talk about the computer, here, we talk about defining functions
12:41:04 * benmachine confuses things
12:41:16 <Botje> don't anthropomorphize computers. they hate that.
12:41:22 <benmachine> :D
12:41:24 <monochrom> hahahaha
12:41:26 <mauke> "it" can refer to the computer, the language, the compiler, or the runtime system
12:42:19 <mauke> also, I think that was the first time I used view patterns
12:42:23 <monochrom> the human doesn't even simulate common sense.
12:43:16 <monochrom> all the human has or simulates is prejudices. and you should be glad the computer doesn't do that.
12:43:51 <mauke> > let a:b.:(dropWhile(a/=)->c:d)=a==c&&b.:d;(null->a).:_=a;infixl 4...in "grt".:"alligator"
12:43:52 <lambdabot>   The fixity declaration for `...' lacks an accompanying bindingPrecedence pa...
12:43:57 <mauke> > let a:b.:(dropWhile(a/=)->c:d)=a==c&&b.:d;(null->a).:_=a;infixl 4.:in "grt".:"alligator"
12:43:58 <lambdabot>   False
12:44:06 <benmachine> mauke: aren't they fun?
12:44:07 <mauke> does this look more or less horrible?
12:44:25 <benmachine> mauke: erm, which are you hoping for :P
12:44:35 <benmachine> > let in"foo"
12:44:36 <lambdabot>   "foo"
12:44:39 <mauke> haha
12:44:45 <xplat> mauke: more horrible, but less obviously horrible
12:45:05 <BONUS> i can't hear you over that line noise
12:45:05 <BONUS> haha
12:45:14 <mauke> > do let
12:45:15 <lambdabot>   <no location info>:
12:45:15 <lambdabot>      The last statement in a 'do' construct must be an ...
12:45:31 <mauke> > do let; ""
12:45:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:45:36 <mauke> ah, I see
12:45:41 <xplat> the triple dots were like a flag waving around going 'look at me, i am horrible'
12:46:34 <xplat> but now people get to confuse your custom operator with function composition, eeeee
12:46:41 <dikdik> so those neckbeard bitches in #ubuntu-women kicked me out
12:46:50 <dikdik> where else can i go to meet women on freenode?
12:46:55 --- mode: ChanServ set +o monochrom
12:46:56 <unkanon_> I usually use .> for ugly throw-away functions
12:47:15 * BONUS waves at boegel
12:47:25 * boegel waves back
12:47:31 <boegel> YO DUDE!!!1!!
12:47:36 <BONUS> yo :D
12:47:39 <dikdik> does anyone know if this book is any good: http://i.imgur.com/UnQLW.jpg
12:47:44 <boegel> BONUS: how you a'doin?
12:47:55 --- mode: ChanServ set +o mauke
12:47:55 --- mode: mauke set +q *!*@c-98-192-175-103.hsd1.ca.comcast.net
12:48:01 --- mode: monochrom set -o monochrom
12:48:04 <boegel> dikdik: I met my wife through that book
12:48:22 <BONUS> cool, just heading out to town. you?
12:48:26 <monochrom> haha, through that book but still not through irc? :)
12:48:33 <boegel> BONUS: staying in with a sore neck :(
12:48:46 <boegel> monochrom: ;)
12:48:47 <BONUS> that's too bad :[ i'll have a drink for you then
12:49:38 <boegel> BONUS: have at least three drinks for me, pls
12:49:44 <BONUS> haha will do :D
12:49:45 <xplat> i should just install an up-to-date haskell platform on my laptop instead of trying to develop over ssh to my desktop, shouldn't i?
12:49:52 <boegel> BONUS: that'll make the pain go away
12:49:54 <monochrom> yes
12:49:55 --- mode: mauke set -o mauke
12:50:02 <BONUS> yeah lol, hope it works long distance
12:50:13 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
12:50:15 <boegel> BONUS: hmm, better make that 5 drinks
12:50:20 <BONUS> will do
12:50:40 <boegel> BONUS: nice drinks! no cheap vodka shit! I don't want a headache in the morning
12:51:08 <BONUS> only the best whiskey for you! haha, welp, im out. seeya later!
12:51:38 <boegel> BONUS: have fun!
12:51:43 <monochrom> "the best way to win is not to drink"
12:54:01 <unkanon_> BONUS: can you explain to me that marvelous thing you did with filterM and const?
12:54:11 <unkanon_> I have no idea why that works
12:54:28 <unkanon_> > filterM (const [True,False]) "abcd"
12:54:29 <lambdabot>   ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","...
12:54:38 <mauke> unkanon_: we're using the list monad here
12:54:44 <unkanon_> yes
12:54:47 <mauke> which means multiple worlds of possibilities
12:54:58 <burp> haha yeah, that's tricky
12:55:04 <mauke> we select elements by filtering with (\_ -> [True, False])
12:55:06 <kmc> :t filterM
12:55:06 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:55:07 <unkanon_> well the main part I can't understand is how can const be helpful at all?
12:55:09 <lispy> > filterM (consts [False, True]) "abcd"
12:55:10 <lambdabot>   Not in scope: `consts'
12:55:12 <xplat> i guess i should build ghc from source so it won't interfere with my package manager
12:55:12 <kmc> filterM :: (a -> [Bool]) -> [a] -> [[a]]
12:55:18 <mauke> i.e. for each element we both take it and drop it
12:55:19 <lispy> > filterM (const [False, True]) "abcd"
12:55:20 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
12:55:34 <kmc> > filterM (const [False ..]) "abcd"
12:55:34 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
12:55:40 <mauke> filterM then nests those worlds for us, generating a result for each combination
12:56:09 <lispy> ?check \x -> filterM (consts [False, True]) (x::String) == filterM (const [True,False]) x
12:56:10 <lambdabot>   Not in scope: `consts'
12:56:13 <lispy> gah
12:56:20 <lispy> ?check \x -> filterM (const [False, True]) (x::String) == filterM (const [True,False]) x
12:56:21 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\90966\"\n"
12:56:32 <xplat> yeah, 'const [True, False]' means 'we don't care at all what the element is, we say both yes and no'
12:56:35 <lispy> ?check \x -> filterM (const [False, True]) (x::String) == reverse (filterM (const [True,False]) x)
12:56:39 <lambdabot>   mueval-core: Time limit exceeded
12:57:14 <benmachine> 20:54:45 < xplat> i guess i should build ghc from source so it won't interfere with my package manager
12:57:17 <benmachine> be aware it takes ages
12:57:22 <benmachine> get a prebuilt binary if possible
12:57:30 <unkanon_> hmm I'm fascinated by const...
12:57:44 <mauke> @src const
12:57:44 <lambdabot> const x _ = x
12:57:46 <unkanon_> it looks so simple
12:57:47 <xplat> benmachine: but prebuilt binaries are not allowed if they live in /usr
12:57:48 <unkanon_> yeah I know
12:57:49 <thoughtpolice> building GHC on my home machines (2.2ghz core2) takes little over an hour with 'make -j3'
12:58:00 <thoughtpolice> on a build optimized for performance, that is
12:58:02 <unkanon_> one has to wonder how the heck const can ever be helpful anywhere
12:58:04 <mauke> heh, we can make this example a bit more awesome looking
12:58:09 <thoughtpolice> with a fast build it can go down to like 25 minutes
12:58:09 <mauke> and by awesome I mean misleading
12:58:12 <xplat> otherwise there's hell to pay later, like mixing local and global cabal
12:58:21 <unkanon_> let's do it!
12:58:24 <mauke> > filterM (return [minBound ..]) "abc"
12:58:25 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
12:58:54 <acowley> maybe 0 const
12:59:00 <benmachine> unkanon_: const is super-simple but very often useful
12:59:00 <unkanon_> @type minBound
12:59:01 <acowley> (for example)
12:59:01 <mauke> the nice thing here is that filterM and return use completely unrelated monads
12:59:02 <lambdabot> forall a. (Bounded a) => a
12:59:09 <xplat> my laptop has a faster CPU than my desktop.  faster graphics, too.
12:59:18 <kmc> nice for maximum confusion
12:59:26 <kmc> > filterM (pure [False ..]) "abc"
12:59:27 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
12:59:28 <unkanon_> mauke: whose return is that?
12:59:30 <benmachine> xplat: I have ghc 6.12 in /usr/bin and ghc 7 in /usr/local/bin
12:59:33 <benmachine> unkanon_: function
12:59:36 <thoughtpolice> xplat: I normally install a pre-built binary into my /usr/local when I do on debian, because I don't like waiting for HP releases typically
12:59:39 <unkanon_> wow
12:59:41 <kmc> it's the ((->) Char) monad
12:59:45 <thoughtpolice> it's probably terrible practice as far as debian is concerned
12:59:57 <kmc> return = const
13:00:07 <xplat> thoughtpolice: the pre-built can go in /usr/local?  good enough then
13:00:25 <thoughtpolice> xplat: yeah, if you download a pre-built binary of GHC, by default ./configure will put stuff under /usr/local
13:00:36 <xplat> no, debian actually allows unpackaged stuff in /usr/local as well as opt
13:00:43 <unkanon_> kmc: what? how can return = const?
13:00:53 <thoughtpolice> (the normal steps are download, unpack, go inside the dir and just do './configure; make install')
13:00:59 <thoughtpolice> you can also --prefix it to where-ever you want
13:01:08 <unkanon_> first people tell me that (.) = fmap, now that return = const, I'll tell you, Haskell is an elusive language ;)
13:01:13 <ziman> > return 5 6 :: Int
13:01:14 <lambdabot>   5
13:01:16 <unkanon_> when you think you're starting to get it... boom!
13:01:20 <monochrom> ./configure --prefix=/usr/local/haskell-platform-2010.2.0.0
13:01:22 <kmc> unkanon_, what I mean is that for the ((->) e) instance of Monad, return is defined as const
13:01:24 <xplat> unkanon_: return for the ((->) a) monad is const
13:01:28 <kmc> @src (->) return
13:01:29 <lambdabot> return = const
13:01:29 <unkanon_> oh!
13:01:31 <benmachine> unkanon_: return :: a -> m a
13:01:34 <kmc> @src (->) (>>=)
13:01:34 <lambdabot> f >>= k = \ r -> k (f r) r
13:01:35 <xplat> helps if you think of it as the reader monad
13:01:38 <unkanon_> (->)'s return is const, got it
13:01:38 <benmachine> let m be (r ->)
13:01:43 <mauke> unkanon_: huhu, try to figure out the type of 'fmap fix return'
13:01:46 <benmachine> then return :: a -> (r -> a)
13:02:37 <xplat> const is the only a -> r -> a in a sufficiently pure world
13:02:48 <benmachine> xplat: and total!
13:03:06 <unkanon_> @hoogle fix
13:03:06 <lambdabot> Data.Function fix :: (a -> a) -> a
13:03:06 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
13:03:06 <lambdabot> module Control.Monad.Fix
13:03:28 <mauke> @src fix
13:03:28 <xplat> benmachine: recursion is an effect :P
13:03:28 <lambdabot> fix f = let x = f x in x
13:03:39 <benmachine> xplat: <_<
13:03:47 * mauke hears brains deflate
13:03:57 <xplat> well, technically it's nontermination that is, but w/e
13:04:36 * thoughtpolice really needs to finish up his GHC patches sometime this week...
13:04:45 <xplat> general recursion is definitely an effect, since it allows nontermination
13:04:57 <thoughtpolice> there aren't enough hours in the day it seems now
13:04:57 <alpounet> @djinn a -> r -> a
13:04:58 <lambdabot> f a _ = a
13:05:01 <alpounet> :)
13:05:04 <xplat> primitive recursion is okay though!
13:05:52 <thoughtpolice> i normally think of 'nontermination' as the effect rather than 'general recursion' being an effect
13:05:54 <xplat> and an infinite number of other kinds, if you happen to possess an infinitely long logic text to tell you what they are
13:06:10 <kmc> thoughtpolice, what are you adding?
13:06:38 <thoughtpolice> kmc: I'm trying to get compiler plugins merged into GHC HEAD
13:06:58 <xplat> thoughtpolice: well, the relation is something like 'assignment to reference slots' (general recursion) vs 'observable mutation' (nontermination)
13:07:10 <thoughtpolice> so you can write fancy-shmancy core passes and what not
13:07:10 <benmachine> why is nontermination an effect?
13:07:19 <xplat> the latter is what you get when you fail to totally encapsulate the former
13:07:39 <benmachine> can't you interpret it as any other partiality
13:07:48 <thoughtpolice> kmc: it was originally slated to be part of GHC, but simonpj never got around to pulling the patches so they bitrotted and I updated them (the original work was done by bolingbroke AKA bsp/batterseapower)
13:07:53 <xplat> benmachine: because partiality is already an effect
13:08:03 <kmc> cool! :)
13:08:17 <benmachine> xplat: why does it need to be that
13:09:09 <thoughtpolice> kmc: the interface and actual implementation of the dynamic loading part is ridiculously simple really. i would like to extend plugins to be able to write Cmm passes later, perhaps once the new codegen work finally is merged into HEAD (which I think they're trying to do ASAP)
13:09:23 <xplat> partiality is an effect because it introduces funkiness in the semantics, and damages things like parametricity and curry-howard
13:09:31 <thoughtpolice> it would be very nice to be able to write pluggable optimizations at the C-- level that uses hoopl, for example
13:09:52 <xplat> for example, with partiality, curry and uncurry are no longer isomorphisms
13:10:05 <benmachine> xplat: ah, okay
13:10:08 <benmachine> hmm
13:11:39 <xplat> and Either no longer divides neatly into Left and Right
13:11:55 <kmc> hooplheads
13:12:14 <benmachine> xplat: what does 'effect' *mean* though?
13:12:18 <xplat> and you have to start doing all this worrying about how lazy or eager your functions are, because it affects the outcome
13:13:06 <xplat> benmachine: don't need to worry about the general case, because partiality happens to be represented by the Maybe monad, that's as standard an effect as you get really
13:15:37 <xplat> if you want to know what 'effect' actually MEANS you have to read the literature.  moggi, wadler, filinski and all them
13:16:37 <benmachine> k
13:16:55 <xplat> the definition is more involved, looser, and more evolving than something like 'monad'
13:17:23 <benmachine> k
13:17:56 <unkanon_> mauke: I can only get as far as deriving the type of fmap fix, but I get stuck afterwards, check it out: http://hpaste.org/42194/fmap_fix
13:18:54 <mauke> the second line confuses me
13:19:10 <mauke> actually, the first
13:19:24 <unkanon_> mauke: well I don't know the correct syntax for doing those things
13:19:34 <unkanon_> but on the first line I'm saying here's fmap, and I will apply fix to it
13:19:54 <unkanon_> then on the second line I say "from here on, I will replace every a with (c->d)
13:20:53 <mauke> http://hpaste.org/42195/blah
13:21:16 <Guest89770> mauke: mauke?
13:21:19 <mauke> wtf, why did it make a new paste?
13:21:22 <mauke> I clicked on "annotate"
13:21:31 <mauke> hpaste--
13:21:36 <unkanon_> yes that's what I did
13:21:43 <unkanon_> but with sloppy syntax :P
13:21:54 <unkanon_> now give me a hint on how to proceed
13:21:55 <mauke> sloppy syntax will kill you
13:22:08 <xplat> fmap's type is Functor f => (a -> b) -> f a -> f b.  fix is (b -> b) -> b.  so fmap fix is Functor f => f (b -> b) -> f b
13:22:37 <unkanon_> I don't know how to reconcile fmap fix's f (functor) and return's m (monad)
13:22:41 <unkanon_> that's where I get stuck
13:23:02 <c_wraith> unkanon_, you just require both Functor and Monad for the type.
13:23:35 * hackagebot checkers 0.2.8 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.2.8 (ConalElliott)
13:23:41 <c_wraith> :t fmap (+7) $ return 5
13:23:42 <lambdabot> forall a (f :: * -> *). (Num a, Functor f, Monad f) => f a
13:23:47 <unkanon_> but I still have trouble changing f (a -> a) to fit an  a -> m a
13:24:24 <Guest89770> mauke: mauke?
13:24:38 <mauke> Guest89770: stop annoying me
13:24:54 <Guest89770> whoa
13:24:56 <benmachine> unkanon_: write a -> m a as (->) a (m a)
13:25:21 <Guest89770> i didnt know i was annoying you
13:25:43 <unkanon_> benmachine: I thought I always had to change the left side?
13:25:55 <benmachine> unkanon_: nope, you can change either side
13:26:51 <unkanon_> I also thought I should never change where the -> are located (I thought no good could come out of it)
13:27:16 <unkanon_> I don't even know how to reason about (->) a (ma) as a type
13:27:18 <benmachine> unkanon_: (->) is like any other type constructor
13:27:58 <mauke> unkanon_: http://hpaste.org/paste/42195/blah#p42196
13:28:16 <unkanon_> well I also thought that I should only concern myself with abstract things like f, m, a, b, c, and not things like (->) or Int, for instance
13:28:44 <benmachine> unkanon_: well, try to work out the type of 'id 4'
13:28:57 <xplat> heh, m and f end up as the same type constructor, but no one instance of that type constructor unifies with both m and f
13:28:58 <unkanon_> :t id
13:28:59 <lambdabot> forall a. a -> a
13:29:02 <unkanon_> Int
13:29:15 <benmachine> unkanon_: well, there you go then :)
13:29:18 <roconnor> :type id 4
13:29:22 <roconnor> @type id 4
13:29:23 <lambdabot> forall t. (Num t) => t
13:29:26 <unkanon_> well but...
13:29:29 <unkanon_> :D
13:29:35 <mauke> Guest89770: why do you keep saying "mauke: mauke?"
13:29:35 <xplat> fine, id 4#
13:29:36 <unkanon_> let me look at mauke's paste
13:29:49 <xplat> wait, id doesn't work on 4# :(
13:29:56 <benmachine> heheh
13:30:01 <xplat> id '4'
13:30:21 <roconnor> unkanon_: try to figure out the type of '(id 4) :: Int'
13:30:38 <xplat> :t id '4'
13:30:39 <lambdabot> Char
13:30:42 <unkanon_> mauke: how did you go from "f ((->) c c) = (->) d (m d)
13:30:43 <unkanon_> "
13:30:46 <unkanon_> to the next line?
13:30:59 <mauke> unkanon_: well, f x y = (f x) y
13:31:03 <unkanon_> roconnor: right, that should be Int
13:31:07 <roconnor> :D
13:31:15 <mauke> unkanon_: so (->) d (m d) = ((->) d) (m d)
13:31:17 <roconnor> @type (id 4) :: Int
13:31:18 <lambdabot> Int
13:31:24 <mauke> unkanon_: and then I just match both sides
13:31:44 <mauke> that gives me the next two lines
13:31:49 <xplat> @type (id 4) :: Maybe Int
13:31:50 <lambdabot>     No instance for (Num (Maybe Int))
13:31:50 <lambdabot>       arising from the literal `4' at <interactive>:1:4
13:31:50 <lambdabot>     Possible fix: add an instance declaration for (Num (Maybe Int))
13:32:02 <mauke> general rule: a b = c d  ==>  a = c; b = d
13:32:08 <xplat> (type-level _|_ :)
13:32:11 <ben> Where is the Functor instance for (->) r defined?
13:32:26 <unkanon_> mauke: I don't see how ((->) d (m d) matches the left side at all
13:32:40 <mauke> unkanon_: it's ((->) d) (m d)
13:32:55 <unkanon_> you're saying that f ((->) c c) matches ((->) d) m d ?
13:33:00 <mauke> no
13:33:03 <mauke> unkanon_: it's ((->) d) (m d)
13:33:15 <unkanon_> that's what I wrote
13:33:17 <mauke> no
13:33:32 <unkanon_> ok, so you're saying that f ((->) c c) matches ((->) d) (m d) ?
13:33:37 <mauke> yes
13:33:44 <xplat> ((->) d) (m d) has parens around the (m d), that makes a difference
13:33:48 <unkanon_> I don't see it, I need the intermediary steps
13:33:59 <xplat> f matches ((->) d)
13:34:08 <mauke> unkanon_: A B = C D where A = f; B = ((->) c c); C = ((->) d); D = (m d)
13:34:13 <xplat> ((->) c c) matches (m d)
13:34:34 <unkanon_> ok ((->) d) matches f because it is a functor, right?
13:34:49 <mauke> I'm ignoring classes here
13:34:58 <xplat> in which ((->) c) matches m and c matches d
13:35:02 <unkanon_> how does ((->) c c) match (m d) then? because d = c c ?
13:35:12 <Guest89770> mauke: i had a question to your code
13:35:12 <xplat> yeah, this is pure herbrand unification at this point
13:35:17 <mauke> unkanon_: a b c = (a b) c, not a (b c)
13:35:24 <xplat> no, c = d
13:35:33 <xplat> m = ((->) c)
13:35:43 <mauke> Guest89770: then why don't you ask it?
13:35:43 <xplat> reader monad
13:36:19 <Guest89770> mauke: because it seemed like you couldve been busy working on the other code. doesnt matter anymore, got the answer already
13:36:32 <mauke> Guest89770: you don't have to ask me; ask the channel!
13:37:10 <mauke> also, I *was* busy working on the other code, and you highlighting me with no content just annoyed me
13:37:28 <unkanon_> oh I see it now!
13:38:37 <mauke> hmm, I think this is the first time I've actually derived the type of fmap fix return
13:39:01 <jmcarthur> 8:t fmap fix return
13:39:04 <jmcarthur> :t fmap fix return
13:39:05 <lambdabot> forall a. a -> a
13:39:05 <unkanon_> that's really complex
13:39:06 <mauke> (I came up with it by looking at what the functions actually do, not their types)
13:39:52 <jmcarthur> it's just \x -> fix (const x), right?
13:39:57 <mauke> ((fix is unconst, and fmap = (.)))
13:40:03 <xplat> > fmap fix return 1
13:40:04 <lambdabot>   1
13:40:41 <unkanon_> ok so what was the point of deriving the type of fmap fix return?
13:41:12 <xplat> if you know the type, you can tell what it does
13:41:15 <mauke> <unkanon_> when you think you're starting to get it... boom!
13:41:24 <mauke> pointless obfuscation!
13:41:30 <mauke> also, I think it's beautiful
13:41:43 <mauke> kind of like e^(i*pi) + 1 = 0
13:41:44 <xplat> and you learn something about types
13:42:03 <unkanon_> :))
13:42:32 <xplat> e^(i*pi) + 1 = 0 is trivial in itself, but it teaches you all kinds of things about sines and exponentials and calculus and so on if you try to figure out why it's true
13:42:34 <mauke> it brings together several fundamental parts of Haskell: monads, functors, general recursion, composition, functions, type-level currying if you look at the derivation
13:44:00 <unkanon_> mauke: thanks
13:44:08 <xplat> it's not obvious at first why e and pi have any relation between them at all.  indeed they seem to have no polynomial relations whatever...
13:44:17 <unkanon_> I'll need to sleep on it to fully grok it and be able to do it again by myself like I can do flip id now
13:44:30 <unkanon_> what's the next step, if step 1 was flip id and step 2 was fmap fix return? 
13:44:47 <mauke> I don't know, I'm still at step 2 myself :-)
13:44:48 <xplat> step 3 is Xenu's Functor
13:44:56 <mauke> delimited continuations?
13:44:57 <unkanon_> lol
13:45:18 <unkanon_> but I'm talking just about deriving types
13:46:30 <xplat> step 3 is figure out what all the functions made only of (.) have in common
13:46:52 <unkanon_> they are all point-free?  :)
13:46:53 <xplat> you know, (.), (.) . (.), ((.) .), things like that
13:46:58 <mauke> they look like boobs?
13:47:02 <xplat> okay, besides those
13:47:34 <unkanon_> xplat: is it something they also have in common with functions made only of (.) and flip?
13:47:45 <unkanon_> is that anything to do with BCKW or whatever that's called?
13:47:47 <unkanon_> or SKI?
13:47:50 <xplat> all functions made without lambda are point-free.  and no, flip changes things.
13:47:57 <unkanon_> oh ok
13:48:02 <mauke> .oO( the SKI's the limit )
13:48:18 <unkanon_> no, iota is the limit
13:48:23 <unkanon_> only one combinator
13:48:26 <unkanon_> :P
13:48:34 <unkanon_> xplat: ok, hints please
13:48:56 <mauke> HQ9+ has only four combinators
13:49:08 <sproingie> i don't really buy the "one combinator" thing when there's syntax that affects the order of application
13:49:12 <xplat> it's too early for hints for step 3, you just finished step 2
13:49:38 <unkanon_> xplat: well then rephrase the challenge. "what they have in common" is too broad
13:50:13 <unkanon_> sproingie: then you think the SKI's the limit like mauke said?
13:50:16 <xplat> > let c = (Prelude..)
13:50:17 <lambdabot>   not an expression: `let c = (Prelude..)'
13:50:24 <xplat> > let c = Prelude.(.)
13:50:25 <lambdabot>   not an expression: `let c = Prelude.(.)'
13:50:32 * xplat sighs
13:50:34 <sproingie> unkanon_: I can be expressed in terms of S and K
13:50:36 <unkanon_> @let c = (.)
13:50:37 <lambdabot>  Defined.
13:50:44 <unkanon_> xplat: that what you mean?
13:50:44 <xplat> that's going to be fmap
13:50:48 <tromp_> I=S(SK)
13:50:49 <mauke> @undefine
13:50:55 <sproingie> tho taking unlambda as a guide, i would consider 'apply' to be a combinator
13:51:01 <unkanon_> sproingie: yeah I know only S and K are needed
13:51:04 <tromp_> or more commonly SKK :)
13:51:05 <xplat> @let c = (Prelude..)
13:51:06 <lambdabot>  <local>:1:4: Not in scope: `Prelude..'
13:51:16 <mauke> stop trying to break the bot
13:51:28 <benmachine> :t ap (ap const)
13:51:29 <lambdabot> forall a a1. ((a -> a1) -> a) -> (a -> a1) -> a
13:51:31 <unkanon_> how's that breaking the bot?
13:51:36 <benmachine> :t ap const const
13:51:36 <sproingie> i guess the application technically isn't a combinator, but it's still some basic element of computation
13:51:37 <lambdabot> forall b. b -> b
13:51:43 <mauke> unkanon_: well, it adds another definition for c
13:51:49 <unkanon_> "another" ?
13:51:51 <mauke> which means you can't use c in expressions anymore
13:51:53 <mauke> > c
13:51:54 <xplat> oh, right, it's probably importing prelude hiding (.)
13:51:54 <lambdabot>   c
13:51:54 <unkanon_> you mean one?
13:52:06 <xplat> oh, i forgot c was already a metavariable
13:52:14 <unkanon_> > d
13:52:14 <xplat> i usually use x y z
13:52:15 <lambdabot>   d
13:52:18 <benmachine> there's nothing meta about it
13:52:20 <unkanon_> that makes no sense to me
13:52:23 <tromp_> i agree defining an X such that XXX=K and X(XX)= S is a bit silly
13:52:58 <sproingie> so, taking one combinator and an explicit "appply", and an arbitrarily long string of those, couldn't those serve as a boolean encoding of a UTM number?
13:53:09 <mauke> > [i,n, s,c,o,p,e]
13:53:11 <lambdabot>   [i,n,s,c,o,p,e]
13:53:28 <unkanon_> and that's useful how?
13:53:43 <mauke> > foldr f z [a,b,c,d]
13:53:44 <lambdabot>   f a (f b (f c (f d z)))
13:53:47 <unkanon_> anyhoo, xplat, what were you trying to do?
13:54:03 <xplat> i was trying to provide some examples
13:54:05 <mauke> > foldr f z []
13:54:06 <lambdabot>   z
13:54:09 <tromp_> yes, but there are more compact encodings of UTMs, sproingie
13:54:21 <unkanon_> @type c
13:54:22 <lambdabot> Expr
13:54:23 <mauke> @let cc = (P..)
13:54:24 <lambdabot>  <local>:1:5: Not in scope: `P..'
13:54:36 <sproingie> tromp_: oh certainly
13:54:45 <mauke> @let cc f g x = f (g x)
13:54:46 <lambdabot>  Defined.
13:54:47 <xplat> anyway, it doesn't matter if you can encode a UTM number unless you have something that can read and interpret the coding
13:55:00 <tromp_> in fact, there are optimal encodings:)
13:55:13 <unkanon_> xplat: you have cc now, courtesy of mauke
13:55:23 <tromp_> the blc encoding can be decoded in 210 bits
13:55:27 <xplat> iow, an actual UTM
13:55:39 <roconnor> what is the terminal functor?
13:55:44 <xplat> :t cc
13:55:45 <lambdabot> forall t1 t2 t. (t1 -> t2) -> (t -> t1) -> t -> t2
13:55:48 <roconnor> Presuming Id is the inital functor?
13:56:21 <xplat> :t cc cc
13:56:23 <lambdabot> forall t1 t2 t t11. (t11 -> t1 -> t2) -> t11 -> (t -> t1) -> t -> t2
13:56:53 <sproingie> i wasn't thinking of combinators as an ideal or useful encoding, i was just idly musing about the correspondence
13:56:58 <xplat> :t cc cc (cc cc) cc
13:56:59 <lambdabot> forall t t1 t11 t2 t21. (t -> t11 -> t2) -> t -> (t1 -> t21 -> t11) -> t1 -> t21 -> t2
13:57:22 <tromp_> i showed that combinators are not quite as ideal as lambda calculus
13:57:23 * unkanon_ is thinking
13:57:56 <tromp_> in terms of conciseness
13:57:58 <xplat> cc cc (cc cc) cc f x g y z
13:58:14 <xplat> > cc cc (cc cc) cc f x g y z
13:58:15 <lambdabot>   Ambiguous type variable `t1' in the constraints:
13:58:15 <lambdabot>    `GHC.Show.Show t1'
13:58:15 <lambdabot>     ...
13:58:19 <sproingie> my machine is very concise, it has one machine instruction: DWIM
13:58:29 <unkanon_> > cc cc (cc cc) cc $ f x g y z
13:58:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:58:30 <lambdabot>    `SimpleReflect.FromExpr ...
13:58:50 <unkanon_> sproingie: there's a way to have a machine with only one machine instruction: subleq
13:58:57 <unkanon_> sproingie: there're other ways too
13:58:59 <xplat> argh, i forgot how much of a pain the type annotations are doing this with simplereflect
13:59:18 <ddarius> roconnor: What makes you think Id is the initial functor?
13:59:20 <xplat> what does subleq do?
13:59:23 <mauke> unkanon_: http://mauke.ath.cx/stuff/asm/yhbt.s
13:59:31 <unkanon_> xplat: subleq = subtract if less or equal
13:59:44 <mjrosenb> @pl (\x -> (f x) . (g x))
13:59:45 <lambdabot> liftM2 (.) f g
14:00:03 <unkanon_> mauke: eww why at&t syntax?
14:00:11 <mauke> unkanon_: because it's nicer
14:00:20 <mauke> also, only one I know
14:00:36 <sproingie> unkanon_: subtract if less than or equal?
14:00:37 <unkanon_> oh, if it's the only one I know then I can see why you'd think that's nicer :)
14:00:42 <unkanon_> sproingie: yes
14:00:46 <sproingie> oops it's in scrollback too :)
14:01:07 <sproingie> i suspect it has similarities to logic using only NAND gates
14:03:24 <unkanon_> holy cow mauke's .xmonad's huge
14:03:47 <roconnor> ddarius: ya, I just realized my mistake
14:04:01 <roconnor> ddarius: I should have said terminal, but even taht is wrong :D
14:06:53 <xplat> okay, i give up on making SimpleReflect print out my examples for me
14:07:18 <xplat> @type cc cc (cc cc) cc
14:07:19 <lambdabot> forall t t1 t11 t2 t21. (t -> t11 -> t2) -> t -> (t1 -> t21 -> t11) -> t1 -> t21 -> t2
14:07:25 <unkanon_> I'll still be thinking about what all the . . . functions have in common
14:07:51 <xplat> it happens that cc cc (cc cc) cc f x g y z = (f x (g y z))
14:08:44 <tensorpudding> @type cc
14:08:45 <lambdabot> forall t1 t2 t. (t1 -> t2) -> (t -> t1) -> t -> t2
14:09:06 <tensorpudding> just composition?
14:09:44 <xplat> yeah, it gets less cluttered if you write it with an alphanumeric name
14:09:53 <xplat> at least, it does in this kind of use
14:10:39 <xplat> also, lambdabot's definition of (.) is not (only) function composition
14:12:01 <tromp_> so combinations of cc parenthesize a bunch of arguments in arbitrary ways
14:12:41 <unkanon_> hmm
14:14:25 <Nubkakes> Oy! Quick question. When I am writing a function, how do I identify a list in it?
14:14:41 <ddarius> That question makes no sense.
14:14:45 <unkanon_> how do you mean?
14:15:01 <Nubkakes> Eh... Sorry my vocab in programming lingo is terrible. 
14:15:03 <Nubkakes> gimme a sec
14:15:07 <BONUS> if you wrote a [ and then a bunch of stuff separated by , and then a closing ], that's a list
14:15:16 <BONUS> that's how you know there's a list in your function
14:15:29 <ddarius> BONUS: That's far from a comprehensive approach.
14:15:34 <sinelaw> ahoy
14:15:35 <xplat> or you can look for the lovely golden plumage
14:15:45 <BONUS> i was being facetious :)
14:15:56 <unkanon_> BONUS: that was pretty funny, i loled
14:16:15 <unkanon_> I'm curious now as to what the question is
14:16:59 <Nubkakes> I got a simple function I am writing but it keeps giving me errors. I'll just copy and paste what I have. It'll be simplier that way instead of dancing around terms I am not familiar with. 
14:17:00 <xplat> but if it's got a red-striped belly, it's a finite map, trying to disguise itself as a list.
14:17:10 <Nubkakes> nonneg :: [Int] -> Int
14:17:10 <Nubkakes> nonneg (x) = length[filter (<0) (x)]
14:17:27 <Nubkakes> winhugs keeps giving me an error with that
14:17:34 <unkanon_> you mean () instead f [] on that second line
14:18:01 <unkanon_> > length $ filter (<0) [1,2,-4,-5,3]
14:18:02 <lambdabot>   2
14:18:03 <xplat> yes, that is the problem.  also you mean >0.
14:18:16 <unkanon_> no it's <0 
14:18:29 <xplat> oh, then why is it called nonneg?
14:18:30 <shachaf> xplat: (>=), rather.
14:18:43 <xplat> shachaf: er, yes, of course
14:18:44 <unkanon_> oh right, I've no idea
14:18:48 <sipa> also the ( ) around x are redundant, but not wrong
14:19:04 <Nubkakes> So I can just use x by itself?
14:19:07 <sipa> yes
14:19:08 <xplat> yes
14:19:15 <Nubkakes> Gimme a sec, I'll try that
14:19:23 <shachaf> Nubkakes: In Haskell, function application in just space-separated. () is used for grouping.
14:19:30 <sipa> and tuples
14:19:35 <Nubkakes> Ah..
14:19:42 <shachaf> sipa: Tuples are a type of grouping. :-)
14:20:05 <xplat> shachaf: semantic grouping, though, not syntactic
14:20:07 <Nubkakes> Long story short, comp sci class professor decided we needed to learn a functional language in 2 weeks >_>
14:20:18 <roconnor> @hoogle [a] -> [b] -> [(a,b)]
14:20:19 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
14:20:19 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
14:20:19 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
14:20:43 <roconnor> @type \a b -> [(x,y)|x <- a, y <- b]
14:20:44 <lambdabot> forall t t1. [t] -> [t1] -> [(t, t1)]
14:20:48 <shachaf> Nubkakes: Seems reasonable. Have you used another functional language before?
14:21:15 <Nubkakes> Never, I've worked with C++ and 68K assembly only. Well, qbasic aswell.
14:21:17 <Adamant> shachaf: for people starting with functional languages, no, it isn't
14:21:22 <sipa> shachaf: maybe, but (a,b) is a distinct type, while (a) is of the same type as a, so i see (,) as a semantic element (data constructor for tuples) but () only as a grouping :)
14:21:40 <Adamant> for someone going from ML to Haskell or Haskell to Scala, then yes
14:21:45 <shachaf> sipa: I also said "is used", not "is only used". :-)
14:21:58 <sipa> shachaf: ok ok :)
14:21:58 <Nubkakes> I'll tell ya, going from C++ to Haskell is mind boggling. 
14:22:03 <Adamant> oh yeah.
14:22:07 <sipa> it is
14:22:35 <shachaf> Nubkakes: Isn't the point of a CS class to be "mind boggling"?
14:22:40 <sinelaw_> going TO c++ is mind boggling
14:22:54 <sipa> i think spreadsheets are closer to functional programming than C++ is :)
14:22:56 <Nubkakes> Touche shachaf
14:22:58 <xplat> roconnor: you are looking for Data.List.⊗, which does not exist
14:23:36 <Nubkakes> I hated haskell at first, but now its like a game almost... Writing functions that is...
14:23:43 <sinelaw_> sipa, ya, spreadsheets are da funk
14:24:09 <Nubkakes> Anyway, the function doesnt give an error now, but it always gives back "1"
14:24:27 <sipa> Nubkakes: replace [] by ()
14:24:32 <sipa> [] is for constructing lists
14:24:44 <Nubkakes> Oh
14:24:49 <Nubkakes> gimme a sec
14:24:50 <sipa> so you create a one-element list, containing the list of results
14:24:53 <sipa> and take the length of that
14:24:58 <xplat> if you want to reuse an old list, you don't use [].
14:24:59 <Nubkakes> In which line? Both lines
14:25:04 <Nubkakes> ?
14:25:12 <sipa> Nubkakes: the second one
14:25:20 <sipa> [Int] is the type of lists of integers
14:25:23 <Nubkakes> Awesome, thanks sipa
14:25:26 <sipa> so that's correct
14:26:14 <xplat> you can mostly consider types as a totally different thing than values/functions
14:26:36 <Nubkakes> Got it! ... ... and it works perfectly now! 
14:27:05 <sipa> show what you have now?
14:27:10 <xplat> if you see a symbol/name in a type and the same one in a value or function, they are probably related, but there's no telling exactly how they're related
14:27:11 <thoughtpolice> re: mind boggling, I would say haskell is definitely a much different and more awesome kind of mind-boggling than C++.
14:27:37 <unkanon_> thoughtpolice: I love you for using re instead of w.r.t. :)
14:27:48 <xplat> like in a type, [] only has exactly one thing inside it, but as a value it can have any number
14:28:41 <Nubkakes> Well, 68K assembly was the first language I learned. To me that was the gold standard. C++ felt like I was just given the hands of god
14:29:01 <Nubkakes> ... and haskell feels like I was reborn as an alien :P
14:29:04 <sipa> Haskell will make you feel God himself ;)
14:29:09 <xplat> then when you get used to haskell you will feel like you were given the hands that MADE god
14:29:14 <Nubkakes> XD
14:29:29 <sipa> unfortunately: http://xkcd.com/224/
14:29:46 <Nubkakes> I take that back, the first form of coding I did was in a game/gamemaker called ZZT. Anyone ever hear of it?
14:30:22 <thoughtpolice> i think I've been lurking around this channel for like 3 years now since I started haskell, and my mind is still boggled fairly frequently.
14:30:35 <Nubkakes> Very nice!
14:30:46 <thoughtpolice> of course, for true mind blowing, you can just go read, uh, anything sigfpe has ever written, ever.
14:30:54 <xplat> i think i heard of ZZT but 'heard of' is it
14:30:55 <thoughtpolice> or oleg for that matter
14:30:59 <kmc> if C++ is the preferred tool of God then i am converting to Satanism immediately
14:31:13 <mauke> preflex: seen God
14:31:14 <preflex>  God was last seen on ##c++ 1 year, 66 days, 23 hours, 25 minutes and 45 seconds ago, saying: I don't really know either actually
14:31:30 <danderson> hehehe.
14:31:46 <xplat> oleg is much more mindblowing than sigfpe
14:31:49 <monochrom> Everyone thinks his/her favourite language is the preferred tool of God.
14:32:03 <Nubkakes> I am not saying its the endall/be all It's just all that I got right now. We play the card we're dealt, ya know?
14:32:18 <xplat> also, comonad reader
14:32:34 <thoughtpolice> xplat: they both explore different subjects, both are mind-blowing. oleg is impressive because he has HM implanted in his brain, sigfpe because he is a crazy mad scientist somewhere (I assume.)
14:32:43 <monochrom> I play the card I'm dealt, yes, and the card is Haskell and GHC now.
14:32:54 <thoughtpolice> also, I assume edward k. is just a random type-theory ninja somewhere; nobody knows where he is at any time.
14:33:19 <monochrom> but do we know his momentum? :)
14:33:21 <thoughtpolice> an insanely productive type-theory ninja, at that.
14:33:22 <Nubkakes> getting back to haskell, I got to write a couple functions and this was at the end of the directions for one particuliar function: Use inserts sort technique. What the heck does that mean?
14:33:30 <xplat> they can't know where he is, because then they don't know how fast he's moving
14:33:44 <monochrom> haha
14:33:54 <Nubkakes> Like an Electron eh?
14:34:04 <mauke> Nubkakes: insertion sort?
14:34:23 <Nubkakes> Not sure 
14:34:41 <thoughtpolice> xplat: speaking of oleg, I was on LtU today, and oleg struck again with his powers - http://lambda-the-ultimate.org/node/4158
14:34:45 <Nubkakes> I quoted it word for word since I've never heard of it before
14:34:48 <monochrom> Have you written insertion sort? It uses this helper function, have you written it? "assume xs is already sorted, now insert c into xs at the right place"
14:34:54 <xplat> insertion sort is a sorting technique where at each step you keep a sorted list and you add one more value to it by finding the proper place and inserting it there
14:35:05 <Nubkakes> I'll go with "no I have not
14:35:19 <monochrom> But you can do it now.
14:35:28 <monochrom> We have just specified it fully twice.
14:35:33 <Nubkakes> Ah
14:35:40 <Nubkakes> Lemme take a crack at it
14:35:56 <Nubkakes> see if I write me the fucntion(s).
14:36:57 <unkanon_> xplat: I just heard that today about oleg, went to his site at all but didn't find any code, what should I look at to see the mindblowing stuff?
14:37:16 <shachaf> unkanon_: There's plenty of code on his site.
14:37:27 <shachaf> Also papers.
14:37:36 <unkanon_> ok I'll take a second look
14:37:38 <mauke> unkanon_: http://okmij.org/ftp/Haskell/de-typechecker.lhs
14:41:01 <unkanon_> that looks like ghci masturbation frankly
14:41:23 <mauke> huh?
14:41:47 <xplat> oleg doesn't host much in the way of packaged, ready-to-use libraries on his site, most of that is on hackage or elsewhere
14:42:11 <xplat> the code on the site is exposition of techniques, and libraries just baked enough to support that
14:42:27 <thoughtpolice> unkanon_: the second paragraph explains the overall gist of his work -"We ask the Haskell typechecker to derive us a function of the
14:42:30 <thoughtpolice> specified type. We get the real function, which we can then apply to
14:42:33 <thoughtpolice> various arguments. The return result does behave like a `composition'
14:42:33 <thoughtpolice> `undefined' to defined."
14:42:35 <thoughtpolice> -- which is what the type specifies. Informally, we converted from
14:42:42 <Nubkakes> Is it possible to combine 2 strings? Like if you have "hey you" and "78ui Go Home" combining them would be "hey you78ui Go Home" ?
14:43:01 <mauke> forget it, it's NP-complete
14:43:04 <jmcarthur> > "hey you" ++ "78ui Go Home"
14:43:05 <lambdabot>   "hey you78ui Go Home"
14:43:08 <xplat> you use (++) for that.  like ("foo" ++ "bar")
14:43:14 <Nubkakes> Outstanding
14:43:15 <shachaf> > mappend "hey you" "78ui Go Home"
14:43:16 <lambdabot>   "hey you78ui Go Home"
14:43:21 <Nubkakes> sorry for the stupid questions
14:43:29 <unkanon_> thoughtpolice: so he came up with something like djinn? 
14:43:32 * unkanon_ keeps reading
14:43:38 <jmcarthur> > concat ["hey you", "78ui Go Home"]
14:43:39 <lambdabot>   "hey you78ui Go Home"
14:43:46 <mauke> unkanon_: yes, except it's a library function, not a separate tool that generates code
14:43:49 <shachaf> Nubkakes: Are you reading a Haskell tutorial or book or something?
14:44:01 <mauke> @hoogle String -> String -> String
14:44:02 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
14:44:02 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
14:44:02 <lambdabot> System.FilePath.Posix addExtension :: FilePath -> String -> FilePath
14:44:42 <xplat> it is ... odd ... that hoogle lists those higher than Prelude.++
14:44:43 <Nubkakes> Not really, prof just gave us a series of random print outs and some homework. The questions dont seem hard but I dont know how to do much in haskell
14:44:55 <mauke> xplat: not really, they're more specific
14:45:02 <mauke> ++ is [a], not just [Char]
14:45:05 <xplat> maybe you should check out something like learnyouahaskell
14:45:08 <thoughtpolice> @hoogle [a] -> [a] -> [a]
14:45:09 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
14:45:09 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
14:45:09 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
14:45:21 <xplat> mauke: hm, true
14:45:32 <kmc> Nubkakes, a lot of seemingly trivial stuff is hard in Haskell, when you're a beginnerd
14:45:37 <kmc> beginner*
14:45:41 <kmc> nice word i've coined there
14:46:10 <thoughtpolice> unkanon_: I also like this work of his, http://okmij.org/ftp/Haskell/types.html#ls-resources
14:46:13 <Nubkakes> Like the question I am on now is to write a function that takes and int and string and replicates a string made up of int copies of the string you put in. I am sure I can do this with recursion... I think I might be able to anyway
14:46:26 <mauke> > replicate 5 "wut"
14:46:28 <lambdabot>   ["wut","wut","wut","wut","wut"]
14:46:37 <thoughtpolice> unkanon_: basically, just go through http://okmij.org/ftp/Haskell/ and everything there is pretty interesting, some things moreso than others
14:46:46 <xplat> concat . replicate 5 $ "wut"
14:46:47 <nfrs> hi
14:46:50 <xplat> > concat . replicate 5 $ "wut"
14:46:52 <lambdabot>   "wutwutwutwutwut"
14:47:09 <thoughtpolice> iteratees and implicit configurations are also 2 works of his that I really like
14:47:35 <mauke> implicit configurations is awesome; it shows you how to teleport arbitrary values through the type system
14:47:38 <thoughtpolice> iteratees are now enjoying a bit of success with the spread of the `enumerator` and `iteratee` packages, implicit configurations are less used but still quite neat
14:47:43 <thoughtpolice> mauke: yeah, I love that paper
14:48:02 <nfrs> beginner here (sorry). I'm trying to make my function print an integer, however it resists. f x = let _ = print x in ...
14:48:22 <thoughtpolice> mauke: and edward's implementation in the 'reflection' library is very nice and clear, as well
14:48:27 <xplat> basically the thing about oleg that impresses me and freaks me out is that he is The Unfettered when it comes to programming
14:48:40 <sproingie> xplat: as in nothing gets in his way?
14:48:50 <unkanon_> thoughtpolice: I will, but just to get me more interested, 'cause the paper isn't clear on what it sets out to do: so that first link is about creating a djinn using only haskell's type checker?
14:48:56 <mauke> nfrs: 'let _ = ' is pointless
14:49:14 <nfrs> mauke: what would you replace it with?
14:49:14 <ion> Prelude> let f x = print x in f 42
14:49:15 <ion> 42
14:49:20 <xplat> no, as in he has no limits, no blinders, neither conventions nor aesthetics get in the way of his accomplishing something
14:49:21 <mauke> nfrs: uh, nothing?
14:49:26 <ddarius> The trick with stable names in Edward's implementation is very slick.
14:49:31 <mauke> nfrs: 'let _ = A in B' is equivalent to 'B'
14:49:35 <nfrs> mauke: then nothing would be printed
14:49:43 <mauke> nfrs: yes, that's what your code does
14:49:52 <nfrs> yes... now what I *want* is something to be printed
14:50:10 <mauke> nfrs: f x = print x
14:50:18 <ion> nfrs: f x = print x, or just f = print :-)
14:50:21 <xplat> like, getting stable pointers from the FFI and marshalling and unmarshalling them into phantom types
14:50:24 <thoughtpolice> unkanon_: the de-typechecker one? yes that's roughly along the lines of what he's doing, as he says, converting 'undefined' to 'defined' based on type.
14:50:37 <Nubkakes> Hmm... I am getting "unexpected '='" errors now.
14:50:58 <Nubkakes> Xplat mind if I send you want I got in pm? I dont want to clog up the main chat
14:51:25 <xplat> i never would have thought of that because it's just too sick and wrong, but what he does with it has a beauty in itself regardless of how he did it
14:51:38 <shachaf> f = join traceShow
14:51:39 <nfrs> but I need to do more stuff in that function after print. how can I separate between "print x" and "do_something_else" that comes after print?
14:51:40 <xplat> Nubcakes: sure
14:51:43 <Nubkakes> thanks
14:51:46 <jmcarthur> Nubkakes: hpaste
14:51:49 <shachaf> Nubkakes: You should @paste it.
14:51:58 <jmcarthur> Nubkakes: hpaste.org i mean
14:52:05 <mauke> nfrs: print x >> doStuff
14:52:12 <ion> nubkakes: Wouldn’t it be better to get help from the entire channel than a more or less arbitrarily chosen single person?
14:52:18 <mauke> >> combines two actions into one
14:52:33 <thoughtpolice> unkanon_: his other example makes it a bit more clear -where 'test9 = reify (undefined::(((a -> b -> c) -> (a -> b) -> a -> c) -> (t3 -> t1 -> t2 -> t3) -> t) -> t) gamma0' - the evaluation of 'test9' will yield '\y -> y (\d h p -> d p (h p)) (\d h p -> d)' which is a function of the specified type
14:52:38 <Nubkakes> I suppose ifya dont mind
14:52:39 <jmcarthur> ion: i think Nubkakes is unaware of the convention of using paste bins
14:52:43 <Nubkakes> xtrg :: Int -> String -> String
14:52:43 <Nubkakes> xtrg x v 
14:52:43 <Nubkakes> 	| if x == 0  = ""
14:52:43 <Nubkakes> 	| if x == 1  = v
14:52:43 <Nubkakes> 	| otherwise  = xtrg (x-1) (v++v)
14:52:44 <mauke> ion: generally, no :-)
14:52:48 <Saizan> Nubkakes: you should put code on a pastebin.
14:52:53 <thoughtpolice> unkanon_: so yes, it's just like djinn, only with no 'magical' things happening, it's just library code
14:52:53 <mauke> Nubkakes: don't paste in the channel
14:52:54 <Nubkakes> pastebin?
14:52:55 <jmcarthur> Nubkakes: we were trying to tell you to use a paste bin like hpaste.org
14:53:03 <Saizan> Nubkakes: e.g. hpaste.org
14:53:09 <Nubkakes> hold a sec, I'll check it out
14:53:22 <thoughtpolice> well, for certain definitions of 'magical' i guess, but in this case he does not use unsafe extensions or compiler modifications, etc
14:53:33 <jmcarthur> Nubkakes: the idea is you can submit your code to a web site and then link to it
14:53:38 <jmcarthur> so you don't flood the channel
14:53:52 <Nubkakes> I see
14:53:56 <ion> nfrs: Also note that do print x; doOtherStuff is syntactic sugar for print x >> doOtherStuff
14:55:12 <Nubkakes> Okay, so I think I used hpaste correctly... Lets try this. http://hpaste.org/42197/replicatestring
14:55:37 <Nubkakes> The link works for me...
14:55:52 <jmcarthur> Nubkakes: the ifs are unnecessary
14:56:45 <Nubkakes> They are?
14:57:00 <unkanon_> thoughtpolice: that's extremely cool, I'll definitely check it out. what's the other example that makes it more clear? the second link you gave me?
14:57:01 <jmcarthur> Nubkakes: you have to either use if-then-else or guards, not both
14:57:20 <xplat> ah, right, that was the problem
14:57:31 <Nubkakes> Ah
14:57:36 <jmcarthur> Nubkakes: aside from that there's an error in your recursive call, but you will figure that out once you get it running
14:58:01 <Nubkakes> will do, what do you mean by "guards" the | lines?
14:58:05 <jmcarthur> yeah
14:58:10 <Nubkakes> ah
14:58:18 <thoughtpolice> unkanon_: sorry, check here - http://okmij.org/ftp/Haskell/types.html#de-typechecker - you can see the 'test9' i was referring to
14:58:25 <jmcarthur> e.g.    | x == 0  = ""
14:58:37 <thoughtpolice> unkanon_: that little blurb also has a link to the full explanation and some other references and stuff
14:58:57 <Nubkakes> Awesome, thanks jmcarthur!
14:59:25 <nfrs> ion: I need that function to return a value. how do I mix that with the fact that it needs to have IO now in its signature?
14:59:40 <mauke> :t return
14:59:41 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:59:58 <unkanon_> thoughtpolice: cool, thanks for the links, I'll eat them up. 
15:00:01 <xplat> but also about oleg: he never says 'this language does not have x feature', he asks 'where can i find x feature in this language?'
15:00:03 <Nubkakes> Yea... it seems to double the number I put in! XD
15:00:23 <xplat> and he pretty much always finds it somewhere, even if you didn't think that feature was in any language
15:01:05 <mauke> hey, I've found self-resizing dynamic arrays in C
15:01:16 <sipa> 'found' ?
15:01:26 <tg_> they were there, all along!
15:01:29 <thoughtpolice> xplat: yeah, I always love when he formulates solutions using only haskell98, for example.
15:01:29 <ion> nfrs: return of v returns v wrapped in the monad, so f x = print x >> return "foo" would have type a -> IO String.
15:01:30 <xplat> Nubcakes: if you think it doubles the number, you didn't do enough tests.  it only doubles if you test on 4
15:01:39 <thoughtpolice> or haskell98 + MPTCs or something
15:02:38 <xplat> well, and 0, but that's trivial
15:03:12 <xplat> 0 -> 0 copies, 1 -> 1 copy, 2 -> 2 copies, 3 -> 4 copies, 4 -> 8 copies, 5 -> 16 copies
15:03:26 <Nubkakes> Yep
15:03:55 <mauke> well, v ++ v
15:03:59 <Nubkakes> this is alittle tricky since you dont just get variables that stay as they were until you change them like in X++
15:04:01 <Nubkakes> c++*
15:04:07 <mauke> you double the string at each step
15:04:22 <Nubkakes> yep, gotta find a way to fix it
15:04:29 <xplat> Nubcakes: indeed, you just get variables that stay as they were.
15:04:29 <shachaf> Nubkakes: Haskell variables are even better: They stay as they are forever.
15:04:30 <sproingie> > fix error
15:04:30 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:04:40 <jmcarthur> Nubkakes: actually variables never change in haskell
15:04:47 <sproingie> "variables don't vary"
15:04:58 <jmcarthur> variables don't mutate
15:04:58 <lispy> constants in haskell are constant?
15:05:00 <sproingie> i avoid saying variable.  "binding" is more appropriate
15:05:03 <c_wraith> call them names.
15:05:20 <c_wraith> You're giving a name to an expression, not assigning a variable
15:05:28 <shachaf> c_wraith: Call them names? That sounds mean.
15:05:28 <sproingie> or yeah "name".  you bind names to values
15:05:33 <shachaf> @slap variables
15:05:34 * lambdabot puts on her slapping gloves, and slaps variables
15:05:47 <kmc> they are variables the way "x" is a variable in maths
15:05:51 <kmc> f(x) = x^2
15:05:57 <thoughtpolice> lispy: mind = blown :P
15:06:01 <Nubkakes> Hmm I think I could do this by creating a seperate function that just returns its self and use that for reference
15:06:02 <kmc> we say it "varies" because you call f different times on different x
15:06:08 <kmc> but x won't change within a call
15:06:12 <ion> @slap herself for using PRIVMSG where NOTICE is the appropriate command, as per RFC
15:06:12 * lambdabot hits herself for using PRIVMSG where NOTICE is the appropriate command, as per RFC with a hammer, so they breaks into a thousand pieces
15:06:14 <kmc> you can't say f(x) = set x to 3, then x^2
15:06:17 <kmc> that's not maths
15:06:43 <c_wraith> ion: she was changed to using NOTICE a while ago.  more people complained about that than have ever had about her using PRIVMSG
15:06:51 <xplat> that's not maths, it's lunacy!
15:06:52 <sproingie> there's the RFC and there's what people actually want to see
15:07:00 <sproingie> and what they don't want is some weird colored message in their client
15:07:12 <nfrs> ion: ok, now I have a function that receives (IO b) from another function and needs to extract b
15:07:17 <Nubkakes> If you want lunacy try contour and elliptical integrals!
15:07:19 -mauke(~mauke@p3m/member/mauke)- fuck people
15:07:28 <mauke> nfrs: no, you don't
15:07:30 <ion> The weird colors make it easier to distinguish bot messages from people messages, which makes it easier to selectively ignore or pay attention to bot messages. :-)
15:07:34 <sproingie> bots should be designed act like users, screw the RFC
15:07:36 <jmcarthur> mauke: ?
15:07:40 <cubi> mmh
15:07:41 <mauke> nfrs: actually, you can't "extract" b because that value doesn't contain b
15:07:41 <kmc> nfrs, that makes no sense.  the type "IO b" is very different from the type "b" and doesn't have a "b" inside
15:08:02 -ben(~v@dslb-088-066-019-002.pools.arcor-ip.net)- fuck irc clients that implement acustic notifications on NOTICEs
15:08:09 <kmc> a value of type "IO b" is a "recipe" which, if excuted, would yield a value of type "b"
15:08:10 <mauke> sproingie: that just means I have to talk more in NOTICEs
15:08:20 <kmc> nfrs, http://www.haskell.org/haskellwiki/Introduction_to_IO
15:08:31 <sproingie> nothing about the IRC protocol that can't be fixed by a total rewrite by people not smoking cheap crack
15:08:33 <kmc> nfrs, the key is that in Haskell, evaluation and execution are distinct
15:08:35 <jmcarthur> oh bots
15:08:35 <xplat> something like '@slap' should be integrated into the conversation anyway, it's meant to be responsive rather than administrivia
15:08:38 * shachaf extracts an Int from a Nothing :: Maybe Int.
15:08:42 <nfrs> kmc: thanks... I was hoping to avoid that for a while...
15:08:49 <xplat> and most of what lambdabot does is like that
15:08:55 <jmcarthur> xplat++
15:08:58 <mauke> nfrs: what languages do you know?
15:09:07 <shachaf> nfrs: If you want to avoid it, just use ghci.
15:09:10 <nfrs> mauke: ocaml, for example
15:09:15 <sipa> nfrs: you can use a IO a as an a, as long as you are inside an IO action yourself
15:09:16 <mauke> nfrs: any javascript?
15:09:22 <nfrs> mauke: javascript, too
15:09:34 <mauke> nfrs: async XMLHttpRequest?
15:09:36 <sproingie> generally you can use Foo a as an a as long as you are in Foo
15:09:39 <kmc> you can turn "action producing A" and "function taking A and returning action producing B" into "action producing B"
15:09:42 <kmc> that's how you use the A
15:09:50 <kmc> the function which does this is named (>>=)
15:09:57 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
15:10:21 <kmc> at no point is the action executed; you're just combining some recipes to produce a bigger recipe
15:10:26 <nfrs> well, the compiler doesn't like (IO Bool) where Bool is expected
15:10:40 <kmc> it won't actually bake your cake until you name some recipe "main" or execute some recipe in ghci
15:10:52 <kmc> yeah, (IO Bool) and Bool are totally different types
15:10:57 <xplat> nfrs: right, that's to keep you from doing something unsafe
15:11:05 <mauke> s/unsafe/nonsensical/
15:11:09 <jmcarthur> not only that. an IO Bool doesn't even have a Bool in it
15:11:29 <shachaf> @ty return True
15:11:30 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool
15:11:44 <xplat> yeah, it just knows how to get a Bool, it doesn't have one yet
15:11:55 <xplat> well, it might have one, there's just no telling
15:12:10 <jmcarthur> just like (String -> Bool) doesn't have a Bool in it (well, it might have on in a closure, but closures aren't directly accessible anyway)
15:12:15 <ion> nrfs: let f x = print 42 >> return x; g x = print $ "g got " ++ x in f "foo" >>= g
15:12:18 <jmcarthur> *one
15:12:18 <shachaf> You can never tell with bees.
15:12:36 <mauke> type 'a box = Empty
15:12:42 <mauke> Empty : int box
15:12:59 <nfrs> well, I have these 3 functions: main calling f calling g. both f and g return values. g wants to print something, so I have to carry IO through the signatures. now f wants to act upon the value returned by g. but apparently, that value is IO Bool instead of Bool. how do I solve it?
15:13:23 <c_wraith> :t return False >>= print
15:13:24 <lambdabot> IO ()
15:13:54 <mauke> nfrs: by attaching yourself to the IO action, not by trying to extract a value from the action
15:13:55 <Nubkakes> I got it! though it's a little bit of a run around in circles method! http://hpaste.org/42198/replicatingstrings
15:14:13 <Nubkakes> And you have to put the string in twice on the input >_>;;
15:14:39 <xplat> well, you could just make a wrapper function to do that for you
15:14:40 <mauke> Nubkakes: foo x v | x == 0 = ""  | otherwise = v ++ foo (x-1) v
15:14:59 <ion> nrfs: In the IO monad, the >>= operator takes an action of type IO a on the left hand side and a function of type a -> IO b on the right hand side. The value returned by f of type IO String in this case. That string will be passed to g as a parameter.
15:15:01 <kmc> nfrs, read "Introduction to IO"
15:15:11 <kmc> the key is this function:  (>>=) :: IO a -> (a -> IO b) -> IO b
15:15:31 <kmc> if you like, it lets you glue an IO action to a "callback" which will eventually get the result of the action
15:15:37 <xplat> Nubkakes: anyway, what you have works, but you don't need the 1 case
15:15:47 <kmc> you can use the "do" syntax, but that's merely shorthand for using this (>>=) function
15:16:15 <Nubkakes> true, a wrapper would be nice... Trying to wrap my mind around how to do it though @_@ I am kinda slow in haskel right now
15:18:21 <xplat> Nubkakes: wait, actually you do need the 1 case the way you wrote this ...
15:18:45 <Nubkakes> Oh?
15:19:17 <mauke> if you need a 1 case, you're probably doing it wrong
15:19:21 <mauke> ^ general rule
15:19:38 <xplat> yeah, that's the only time you look at the v that you patiently built up through those layers of recursion
15:19:53 <ion> you’re probably doing it wrong
15:19:56 <ion> ↑ general rule
15:21:37 <xplat> man, i hate gnome and its non-mappable compose key
15:21:47 <xplat> well, non-remappable
15:22:00 <jmcarthur> Nubkakes: i'm not sure if it goes without saying or not, but you don't have to add an extra argument like that at all, even with a wrapper
15:22:12 <xplat> no broken pipe, no arrows ...
15:22:27 <jmcarthur> Nubkakes: i just mean there are cleaner ways
15:22:41 <mauke> I already gave them a nicer solution
15:22:54 <xplat> i can get them with AltGr+numeric keypad, but on a laptop ...
15:23:10 <mauke> xplat: what do you mean by "non-remappable"?
15:23:28 <Nubkakes> No doubt there are, but I have to learn how to do this stuff by hard without any references by tuesday next week. At the moment, as bad as it makes me look, I just care about understanding how to use haskell even if its a crude understanding
15:23:46 <xplat> mauke: the compose pairs (and occasional triplet) are a fixed set hardcoded into the library, it's not configurable
15:24:07 <mauke> xplat: doesn't it use the standard X compose system?
15:24:12 <xplat> no
15:24:30 <mauke> huh
15:24:41 <Nubkakes> Okay how does this loook; http://hpaste.org/42200/replicatingtry4
15:24:45 <mreh> I don't understand why mtl has bothered to depend on transformers
15:24:58 <mreh> transformers does more
15:25:06 <mauke> Nubkakes: terrible
15:25:06 <mreh> but without the typeclasses
15:25:14 <xplat> mtl depends on transformers now?
15:25:22 <mreh> since 2
15:25:42 <Cale> Nubkakes: Perhaps think about it this way. xtrg 0 x = "", and xtrg n x otherwise is equal to x ++ <something>
15:26:06 <monochrom> mtl is intended to be a legacy thing
15:26:14 <mreh> aaaah, they've included the COntrol.Monad.IO.Class
15:26:31 <monochrom> a kind of "mtl kung fu: the legend continues"
15:26:35 <mreh> monochrom, isn't the most progressive? It uses fun deps. or am I way out of touch
15:26:38 <ion> nubkakes: It might be helpful to figure out how the recursive function should expand in each step before implementing it: http://hpaste.org/42203/expected_expansion
15:26:54 <monochrom> there is monad-tf using type families
15:27:56 <mreh> are they good?
15:28:13 <monochrom> yes
15:28:21 <Nubkakes> XD thanks for the help and tips guys...
15:28:23 * mreh reads
15:28:41 <mreh> also, I've got to give argue my case for darcs tomorrow
15:28:44 <xplat> it's just amazing how much typeclasses with all the special sauce resemble datalog.  and how they have such a good reason to.
15:29:00 <Nubkakes> Regretibly I have to run to my thermal dynamics final! Talk to y'all afterwards... If you're still here XD
15:29:04 <ion> nubkakes: Updated the paste
15:29:05 <mreh> why would be better off using darcs?
15:29:10 <jmcarthur> Nubkakes: i added several annotations to your paste showing some simplifications or cleanup steps: http://hpaste.org/paste/42198/drop_a_parameter_more_point_f
15:29:19 <mreh> I don't know enough to suport that proposition
15:29:36 <monochrom> what if you don't use darcs?
15:29:46 <mreh> monochrom: yah
15:29:58 <Nubkakes> jmcarthur, I appreciate it alot. Thanks
15:30:28 <mreh> it seems stupid to propose it if I don't really know about it, but I felt like shaking things up
15:30:35 <monochrom> I have just begun using git. I have not looked into darcs. I don't think it matters for my feeble use.
15:31:24 <xplat> i mean, what the typechecker and instance-locating thingy does when dealing with typeclasses is exactly what a datalog toplevel does: try to prove a relation holds and provide the evidence
15:31:45 <Nubkakes> anyway, I'm off to the first of many finals! TALLY HO! 
15:32:39 <xplat> mreh: shaking things up when you don't have a case is a bad idea, gets you ignored later on when you do have a case
15:33:13 <alexis> hi, I'm trying to use a variable in a takeWhile statement, but I don't know how to proceed.
15:33:31 <xplat> why does handonson keep exploding in korean?
15:33:31 <alexis> here is a paste of what I'm trying to do: http://hpaste.org/42208/use_a_variable_in_a_takewhile
15:34:16 <xplat> or was it handonson before?  is that a server message?
15:34:27 <kmc> mreh, mtl2 depends on transformers because transformers / monads-tf / monads-fd is the future direction, and this makes legacy mtl code compatible
15:34:28 <alexis> well, I've replaced for the sake of the paste, max by maximum, but maybe it's a reserved word, it appears in blue
15:34:50 <hpc> alexis: why wouldn't that work?
15:34:54 <Cale> alexis: it's not reserved, but it's a function defined in the Prelude
15:35:00 <kmc> if your library exports some monads built with mtl2 then a client can use transformers together with monads-?? and it will work
15:35:03 <Cale> alexis: There's nothing wrong with your code
15:35:08 <alexis> arf
15:35:16 <alexis> will try again then
15:35:55 <mreh> :t suc
15:35:56 <lambdabot> Not in scope: `suc'
15:35:59 <mreh> :t sicc
15:36:00 <lambdabot> Not in scope: `sicc'
15:36:02 <mreh> :t scc
15:36:04 <lambdabot> Graph -> Forest Vertex
15:36:05 <mreh> :t succ
15:36:06 <lambdabot> forall a. (Enum a) => a -> a
15:36:12 <alexis> ah, it was my call
15:36:28 <alexis> I always miss to put the parenthesis in the right place
15:36:41 <mreh> kmc: monads-fd is deprecated
15:37:11 <mreh> in favour of mtl
15:37:56 <xplat> there is a lot of monad-stuff that is deprecated, but unfortunately Prelude.Monad will remain undeprecated and provide the root of all monadic evi^Wcruft
15:38:38 <xplat> with its missing parents and all
15:38:42 <Cale> mreh: Which is funny, because mtl has been around longer
15:39:20 <mreh> Cale: you're telling me
15:39:23 <xplat> it's not unusual for a new project to be deprecated in favor of a new version of an old project
15:39:44 <mreh> I know, but it doesn't seem clear what's going on
15:40:01 <xplat> the mother of all such examples: xemacs and fsfmacs
15:40:34 <ion> I thought *macs was deprecated in favor of vim.
15:40:35 * ion ducks
15:40:49 * xplat aims low
15:41:23 <xplat> people on irc need to learn to jump out of a sweep kick
15:41:41 <ion> Nah, i deserved it.
15:42:04 * tg_ severs xplat's legs with a rusty hacksaw
15:42:26 <sproingie> so now mtl is the new old new hotness?
15:42:28 <tg_> i dunno what that'll teach ya, but I suspect it'll make an impression
15:44:06 <xplat> tg_: you'll be sorry you did that when you experience an uppercut to the crotch
15:44:54 <xplat> but this is getting seriously offtopic ;)  and i have to go eat anyway
15:45:09 <tg_> cup check!
15:46:18 <Mathnerd314> how close can I get to a local copy of haskell.org? (on windows)
15:47:54 <Zao> Mathnerd314: For what? Docs?
15:47:55 --- mode: ChanServ set +o mauke
15:47:55 --- mode: mauke set -q *!*@c-98-192-175-103.hsd1.ca.comcast.net
15:48:40 <Mathnerd314> Zao: yeah. though a nice way of installing all the packages at once would be good too
15:48:56 <Zao> Are you talking about hackage then?
15:49:22 <Zao> Take package list, cabal fetch them all, then install as needed?
15:49:55 --- mode: mauke set -o mauke
15:50:21 <Mathnerd314> something like that.
15:51:08 <dcoutts_> Mathnerd314: if you --enable-documentation (or set it persistently in your cabal config file) then cabal will generate and maintain an index of all documentation for all packages you have installed.
15:51:58 <Mathnerd314> but apparently it doesn't do source highlighting, or hoogling, or the other nice features of haskell.org...
15:52:33 <tac-tics> Question for #haske
15:52:36 <tac-tics> ll
15:52:58 <tac-tics> Once you know enough type theory to be dangerous, wtf do you do with it?
15:53:10 <dcoutts_> Mathnerd314: no, we don't have support yet in cabal-install for maintaining a hoogle index
15:53:38 <jmcarthur> tac-tics: dangerous things?
15:53:55 <dcoutts_> tac-tics: write programs you would not dare do otherwise, since you'd never have the confidence that you could do them right
15:54:11 <dcoutts_> e.g. more extreme abstractions giving shorter nicer safer code
15:54:30 <dcoutts_> it's actually a huge confidence booster
15:54:37 <lispy> refactor!
15:54:51 <ezyang> Refactoring with static types is pretty glorious. 
15:55:20 <tac-tics> In principle, once would say so
15:57:52 <kmc> tac-tics, write your programs in Coq or Agda and prove them correct
15:58:54 <jmcarthur> i get scared when i use dynamically typed languages now
15:59:09 <jmcarthur> like, i don't even know where to begin coding
15:59:18 <Mathnerd314> dcoutts_: right... so the next-best thing is a clone of haskell.org, which does have support
15:59:33 <tac-tics> They are a madman's tool
15:59:36 <Mathnerd314> jmcarthur: write the types in comments
15:59:36 <kmc> i get scared when i use dynamically typed languages *and* am modifying code where other people wrote ill-typed functions
15:59:42 <lispy> jmcarthur: I tend to write out haskell type signatures (sometimes in comments) and code from that specification as much as possible
15:59:45 <tac-tics> But madmen sometimes do great things
15:59:56 <kmc> there's a world of difference between "average Python code" and "Python code written by people who know Haskell"
16:00:20 <dcoutts_> Mathnerd314: I think you mean of hackage, but if you do mean the core docs on haskell.org, I think there are tarballs of those, but no hoogle there
16:00:39 <mpiechotka> @undo do x' <- x; y' <- y; f x' y'
16:00:39 <lambdabot> x >>= \ x' -> y >>= \ y' -> f x' y'
16:00:49 <jmcarthur> Mathnerd314: i do!
16:00:59 <jmcarthur> i even include IO
16:01:06 <mpiechotka> @pl \x y -> g x >>= \x' -> g y >>= \y' -> f x' y'
16:01:06 <lambdabot> (. ((. f) . (>>=) . g)) . (>>=) . g
16:02:04 <alpounet> much clearer this way yeah.
16:03:03 <tac-tics> I hit a point this week where all of type theory clicked, and system F became the most obvious thing ever
16:03:21 <kmc> :D
16:03:27 <kmc> what about dependent types?
16:03:39 <tac-tics> Dependent types were the key
16:03:41 <kmc> what some people don't realize is that dependent types are *really simple*
16:03:51 <kmc> there's fewer things, because you unify type and value levels
16:03:55 <tac-tics> System F is dependent types, neutered before puberty
16:04:00 <kmc> i expect you reached the same path
16:04:00 <kmc> yeah
16:04:23 <maurer_> kmc: The only issue is that this makes typechecking a function extremely difficult.
16:04:35 <kmc> yep
16:04:49 <kmc> well typechecking isn't so hard, but it requires evaluation
16:04:58 <kmc> what becomes intractable is inference
16:05:03 <maurer_> However evaluation is not always possible.
16:05:23 <tac-tics> And now I finally get that in haskell, Functor f => (a->b)->f a ->f b is a function of 4 parameters, but hindley milner applies the first two "for free"
16:05:23 <maurer_> Say I give you a function which takes an integer
16:05:36 <maurer_> You cannot evaluate it on all integers, so to typecheck it, you actually have to do type inference
16:06:08 <alpounet> 4 parameters ?
16:06:08 <kmc> tac-tics, yes; in fact you can think of the "Functor f" constraint as an argument as well
16:06:30 <alpounet> f, a -> b, f a ... ?
16:06:36 <jix> isn't typechecking with dependent types without implicit arguments pretty simple?
16:06:45 <tac-tics> kmc, yes. The "forall f" and "witness of functorhood" 
16:06:54 <kmc> it's also forall a and b
16:06:58 <Boxo> If f is an argument, why aren't a and b arguments too
16:07:01 <Boxo> yeah
16:07:07 <tac-tics> Kmc yeah, correct
16:07:17 <Boxo> so, six args
16:07:36 <tac-tics> Foralls and class constraints are implicit params
16:07:49 <kmc> tac-tics, have you done any dependently typed programming?
16:08:00 <tac-tics> And in DDC, regions and purity constraints work the same
16:08:25 <tac-tics> kmc, only a bit. I have the "big picture" of how it works
16:08:34 <tac-tics> No real experience
16:08:37 <kmc> ah
16:08:56 <kmc> i found it really fun to work through "Software Foundations" by pierce et al
16:09:06 <kmc> which involves some programming and proving in coq
16:09:14 <kmc> and some mechanized metatheory of programming languages
16:09:19 <tac-tics> I wanted to write a depend typexd language with only Nats
16:09:25 <tac-tics> Seems pretty straightforward
16:09:38 <tac-tics> Pierce is brilliantly articulate
16:09:53 <tac-tics> I have his type book, and it's super readable
16:11:02 <tac-tics> Coq is confusing as hell for a beginner, though. You don't know what's primitive and what's sugar
16:11:49 <kmc> yep
16:12:06 <kmc> and Ltac is ugly as hell
16:14:12 <tac-tics> I am intrigued by proof terms
16:14:27 <tac-tics> And how they might be used in more mainstream langs
16:14:38 <tac-tics> To enforce data constraints
16:14:51 <kmc> you sometimes see things like proof terms in Haskell
16:14:59 <tac-tics> But they are so messy once you do anything nontrivial
16:15:05 <kmc> usually as a GADT value
16:16:46 <tac-tics> Yeah
16:18:31 <tac-tics> I had a neat idea today
16:18:52 <tac-tics> For a plugin system that allowed untrusted plugins from the web or whatever
16:19:11 <tac-tics> To encode computational complexity info in the type
16:19:38 <tac-tics> To ensure it doesn't run forever or that it terminates in a "reasonable time"
16:19:53 <jix> even more interesting for realtime systems
16:20:40 <tac-tics> Sadly, comp. complexity never made any real sense
16:21:18 <tac-tics> I wouldn't know how to formulate it except in naive ways
16:21:44 <Draconx> It doesn't help that Haskell types are incapable of expressing it.
16:21:50 <dcoutts_> tac-tics: I'm not sure it'd help a lot, even if you know the complexity you can still spend a long time running O(n) algorithms
16:22:07 <ddarius> tac-tics: You may want to look at Proof Carrying Code of which that would be a relatively simple case.
16:22:20 <jamwt> heyas.. does it sound crazy if a data.map mapping 10 character strict bytestrings to 10 char strict bytestrings is having a ~1000 byte per map entry overhead?
16:22:26 <tac-tics> I've heard of that before
16:22:33 <ddarius> Draconx: You might want to be careful on what you say Haskell types are incapable of expressing.
16:22:33 <dcoutts_> Draconx: not the types, but the language. System F has more or less the same types as Haskell, but the language is termination
16:22:37 <dcoutts_> terminating
16:23:09 <Draconx> ddarius, _|_ is a member of every type, no?
16:23:23 <kmc> jamwt, did you heap profile by type?
16:23:33 <dcoutts_> Draconx: but that's not really a problem with the types but the value language
16:23:47 <jamwt> kmc: in the process right now.. did RTS -hc and firing up hp2any manager
16:24:15 <jamwt> to see if I'm leaking thunks or something
16:24:19 <tac-tics> Draconx: in haskell, it is. In something like Coq, no.
16:24:26 <dcoutts_> Draconx: remove 'fix', keep inductive and co-inductive data
16:24:30 <jamwt> seems ubsurdly high to me
16:25:00 <Draconx> dcoutts, well, that doesn't mean that our types magically gain expressive power.
16:25:05 <tac-tics> _|_ will be in any type where you have a non-terminating, but well-typed expression
16:25:12 <Draconx> dcoutts, only that all programs are trivially terminating.
16:25:22 <tac-tics> Such as  undefined or fix fix
16:26:26 <tac-tics> _|_ is a pain in the ass more than anything else
16:26:30 <Draconx> dcoutts, if our type system could express program termination, then there would have to be (a) at least one non-terminating program, and (b) at least one type of which no non-terminating program is a member.
16:27:33 <dcoutts_> Draconx: well you could have a type system that separated the terminating subset from the part with fix
16:27:34 <Philippa> which is achievable, just not how you expect it to be
16:27:53 <Philippa> yeah, or one that just forces you to express the non-terminating program as a productive corecursion
16:28:25 <Philippa> ("my turing machine never hangs mid-step!")
16:28:36 <Cale> tac-tics: There's some research regarding the integration of something called combinatorial species into type systems, and there are apparently algorithms for automatically computing the complexity of wide classes of terminating computations on those. (So, doing complexity inference)
16:29:00 <tac-tics> Cale: neat. I'll look it up
16:29:12 <Philippa> you can already do proofs about time taken in Coq, it's just a bit painful
16:29:20 <dcoutts_> Philippa: right, a combination of recursive and co-recursive programs
16:29:20 <Philippa> (because you have to embed the system that defines "time" first)
16:29:49 * dcoutts_ notes that skipping streams are like this
16:30:05 <Philippa> yeah, I noticed: I like the idea of skip
16:31:11 <dcoutts_> Bove, A., Capretta, V.: Modelling general recursion in type theory. Mathematical Structures in Computer Science 15(04), 671–708 (2005)
16:31:18 <dcoutts_> Philippa: ^^
16:31:35 <dcoutts_> apparently it's very much like skip
16:32:11 <Philippa> *nod* - don't really have good time for paper-reading these days sadly, I've got good cause to be devoting my efforts to cognitive psychology and a few related areas
16:32:31 * dcoutts_ has not read it yet either, but probably should
16:32:37 <Philippa> (however much I want to write a paper or two nabbing some low hanging fruit from Visibly Pushdown Languages)
16:32:55 <Philippa> (...and not just to conclude that "VPLs are attractive")
16:37:02 <Cale> tac-tics: http://www.cas.mcmaster.ca/%7Ecarette/species/msfp08_species.pdf
16:37:34 <Draconx> dcoutts, ok, so I guess it's pretty meaningless to consider the type system in isolation.
16:37:54 <nfrs> is there a very fast immutable hashtable?
16:38:05 <nfrs> something you construct once and then use for lookups
16:39:00 <dcoutts_> Draconx: mm, they often have to be considered together
16:39:03 <Cale> nfrs: You wouldn't want it to be a hashtable. Balanced tree structures are nicer, use Data.Map :)
16:39:23 <nfrs> Cale: log(n) vs 1...
16:39:26 <dcoutts_> nfrs: using an ordinary array of lists would work pretty well
16:39:36 <dcoutts_> and be only a few lines of code
16:39:45 <dcoutts_> since the hash functions already exist
16:39:46 <Cale> nfrs: Note that computing a hash for a hashtable with n buckets takes at least O(log(n)) time
16:40:14 <Cale> nfrs: People lie about the complexity of hashtables :P
16:40:34 <nfrs> Cale: that's one log(n), and then there are m lookup operations, where m >> n
16:40:49 <sproingie> use a perfect hash and lookup is plenty fast
16:40:50 <dcoutts_> but the complexity is not the real point when it comes to this particular comparison, it's the benchmarks that matter
16:40:51 <Draconx> nfrs, if you only need to create the table once and then only do lookups, you can construct a perfect hash.
16:40:54 <Cale> Er, what?
16:40:55 <luite> hmm, you have to calculate the hash for each lookup?
16:40:55 <sproingie> it's all about the tradeoff
16:41:10 <Cale> luite: In general, you would.
16:41:47 <luite> I can't really think of a hash table where you'd have to do it only once :)
16:42:02 <Draconx> luite, compilers frequently have such a thing.
16:42:08 <Cale> The same thing which lets people argue that hashtable lookups are O(1) would let us argue that lookups in Data.Map are O(1)
16:42:37 <sproingie> i like cuckoo hashing
16:42:44 <Cale> Basically, they're assuming that the hashtable has a fixed maximum size. If you assume that, then lookups in any datastructure are O(1).
16:42:56 <luite> in practice, locality of reference in hash tables might be better though
16:43:01 <Cale> That's true
16:43:06 <sproingie> best case hash lookup is O(1).  best case in a tree is log(n)
16:43:12 <Draconx> Cale, you can amortize the cost of table expansion.
16:43:23 <luite> sproingie: I'd say it's the other way around
16:43:27 <dcoutts_> sproingie: not if you're after the root ;-)
16:43:43 <Cale> sproingie: bzzt, you can't compute a function whose range has n elements in time which is constant in n
16:44:03 <Cale> Any function whose range has n elements takes at least O(log n) time to compute
16:44:06 <luite> hmm, wait, you'd have to test for equality, which is O(log(n))
16:44:22 <Cale> Because you have to examine at least O(log(n)) bits of the input to compute it
16:45:14 <Cale> So any lookup in a datastructure containing n distinct elements will take at least O(log n) time
16:45:27 <Draconx> Cale, usually, people are counting the number of _comparisons_.
16:45:49 <luite> I can sort a list of integers without any comparisons ;p
16:46:23 <sproingie> quantum sort.  if list is not sorted, destroy the universe.
16:46:45 <luite> unfortunately there is not quantum operator to do that ;p
16:46:52 <luite> no
16:47:19 <sproingie> let's hope no one implements it in this universe
16:49:35 <mm_freak> well, hash tables are great, if you do much more lookups than modifications
16:49:53 <luite> and it would still take O(n log(n)) time to check whether a list is sorted
16:50:10 <mm_freak> luite: huh?
16:50:23 <xplat> the O(1) time for hashtables holds in the RAM machine model, which is both more and less realistic than pointer machines
16:50:23 <luite> (maybe not strictly true if you allow duplicates :p )
16:50:27 <mm_freak> checking whether a list is sorted should be O(n)
16:50:39 <luite> mm_freak: the point was that comparisons are not O(1) in practice
16:51:01 <xplat> more because on a real CPU you pay for a full word operation even if you don't use all the bits, less because when you scale to more than one machine it matters again
16:51:21 <sproingie> and you pay just as much for a halfword operation
16:51:40 <mm_freak> luite: greater doesn't mean larger…  also note that, for example, comparing Ints is atomic O(1) on most architectures
16:51:52 * ddarius sticks to 1/pi word operations.
16:52:01 <sproingie> if you do SIMD i suppose you can pay less
16:52:28 * ddarius makes a MISD machine.
16:52:31 * sproingie ponders a SIMD binary trie algorithm
16:52:44 <mm_freak> luite: it really depends on what you're comparing
16:53:05 <mm_freak> generally saying that checking sortedness is O(n * log n) is wrong…  it is in certain special cases
16:53:24 <xplat> and as for quantum sort, a 'destroy the universe' operator is one possible explanation of the fermi paradox
16:53:58 <xplat> there's a possibility that every lifeform which figures out how proceeds to destroy the universe by replacing it with a new one
16:53:59 <sproingie> "they destroyed themselves" has long been one hypothesis, yes
16:54:25 <xplat> which unlike destroying themselves is not necessarily even stupid to do
16:54:53 <ddarius> A simpler explanation is that the universe is large.
16:55:01 <Rotaerk> if destroying yourself is stupid, then destroying the universe you're in is stupid
16:55:13 <sproingie> and any signal given off is drowned out in the noise
16:55:20 <kmc> "destroy the universe, locally"
16:55:31 <xplat> in string theory there may be lower-energy vacuum states that create a larger, longer-lasting universe that doesn't expand as rapidly
16:55:35 <Veinor> it destroys the universe, but the destruction propagates at light-speed
16:55:51 <tac-tics> Stupid (destroy self)->Stupid (destroy universe) :Prop
16:56:32 <kmc> can we put up a sign that says "it has been [n] hours since the last argument about hash tables"
16:56:58 <tac-tics> Destroy universe -> forall a. (a ->a)->a
16:57:01 <sproingie> kmc: i would totally code that for \bot if my supply of round tuits wasn't fresh out
16:57:04 <xplat> Veinor: exactly.  so this universe is still here for us, until the wave gets here.  luckily if this is true MWI is probably true too so we would only get partially destroyed ...
16:57:12 <Veinor> :D
16:57:14 <djahandarie> The universe creates a costate comonad
16:57:38 <xplat> but we wouldn't be able to notice that our measure just decreased
16:57:55 <kmc> @let n = 1096.6331584284585
16:57:56 <lambdabot>  Defined.
16:57:58 <kmc> > log n
16:57:59 <lambdabot>   Ambiguous occurrence `n'
16:57:59 <lambdabot>  It could refer to either `L.n', defined at <local...
16:58:02 <kmc> > log L.n
16:58:03 <lambdabot>   7.0
16:58:12 <dankna> kmc: nice concept haha
16:58:34 <hpc> > L.n
16:58:35 <lambdabot>   1096.6331584284585
16:59:18 <dibblego> TaPL: "Of course, since the pure lambda-calculus is Turing complete, ..." (no reference) <-- how can I know for sure?
16:59:42 <ezyang> pure lambda calculus with fix? 
16:59:57 <dibblego> you mean you need fix?
17:00:08 <aavogt> perhaps there's a thesis on it
17:00:20 <dibblego> yeah I can't google it up
17:00:28 <dibblego> there is SKI of course
17:00:42 <tac-tics> Pure typeless lambda calculus always includes fix
17:00:48 <ezyang> The dingy little bool/int calculus that TAPL starts off with is not Turing complete 
17:00:57 <xplat> you need fix or syntax equivalent to fix.  but you can write fix in pure typeless LC
17:01:00 <aavogt> dibblego: I mean this one http://en.wikipedia.org/wiki/Church???Turing_thesis
17:01:24 <aavogt> err, %E2%80%93  instead of the ???
17:01:33 <Boxo> \f.(\x.f(xx))(\x.f(xx)) -- here's your fix
17:01:42 <BMeph> sproingie: What is that, the Mythbuster Cosmological Theory? "I reject your universe, and substitute my own." ;)
17:01:52 <tac-tics> Boxo: ahhh that's the stuff!
17:02:00 <ezyang> only in call-by-name ;-) 
17:02:30 <Philippa> nope, in plenty of reduction strategies
17:02:42 <Philippa> just not in strict ones :-)
17:02:57 <ezyang> Oh, sure :o) 
17:03:05 <revenantphx> Ugh
17:03:11 <Boxo> an fixpoint combinator that works strictly, now taht would be something
17:03:19 <revenantphx> Hot chocolate and computers don't mix
17:03:28 <revenantphx> Bzzzt.
17:03:55 <dolio> Eager reduction strategies just need some eta expansion.
17:04:03 <dolio> So you get ((a -> b) -> (a -> b) -> (a -> b)
17:04:13 <revenantphx> )
17:04:14 <dolio> Missing a paren.
17:04:31 <dolio> ((a -> b) -> (a -> b)) -> (a -> b)
17:06:01 <Boxo> Wikipedia says that this is an applicative-order fixed point combinator: Z = ?f. (?x. f (?y. x x y)) (?x. f (?y. x x y))
17:06:08 * Boxo fires up the lambda calculus interpreter
17:06:55 <mauke> hmm, makes sense
17:07:34 <revenantphx> Question: If a use is found for "pure mathematics", then is it rendered impure?
17:07:36 <mauke> needs more ?x. x x
17:07:40 <Cale> revenantphx: No.
17:07:46 <revenantphx> What happens then?
17:08:02 <revenantphx> It's just "somewhat applicable pure mathematics"?
17:08:06 <Cale> revenantphx: Pure mathematics is mathematics which is studied without explicit reference to applications.
17:08:11 <revenantphx> Ah ok
17:08:12 <Cale> There can still be applications of it
17:08:19 <revenantphx> I see the subtlety now
17:08:38 <Philippa> do applications within another area of pure maths count? :-)
17:08:47 <Cale> No, they get a pass :)
17:09:04 <revenantphx> What if they in turn are applied somewhere else?
17:09:09 <Cale> In fact, it's funny, you'll see a section on "applications" and it'll consist of just more pure mathematics :)
17:09:40 <Cale> revenantphx: Yeah, mathematics is a big tapestry of interconnections, and you can never be sure where the applications will come.
17:09:55 <nfrs> hmm, what's wrong?   undefined reference to `containerszm0zi3zi0zi0_DataziSet_Tip_closure'
17:09:59 <revenantphx> Ughhhh
17:10:01 <Cale> nfrs: --make
17:10:19 <kmc> ghc --make
17:10:20 <nfrs> Cale: thx
17:10:22 <revenantphx> Hot chocolate fell onto my computer before I saved my essay edits
17:10:36 <revenantphx> I salvaged the files...
17:10:38 <Cale> nfrs: Your program wasn't linked against the containers package. If you add --make, it automatically guesses the packages you'll need (based on the modules you import)
17:11:20 <revenantphx> I then drank the hot chocolate out of revenge...
17:11:58 <ddarius> dibblego: You could always prove it yourself.
17:12:06 <ddarius> How would a reference make you know for sure?
17:12:09 <dibblego> yeah I reckon I could
17:12:16 <dibblego> by reading the proof
17:12:33 <ddarius> There are lies, damn lies, and proofs.
17:12:42 <dibblego> indeed
17:13:58 <djahandarie> ddarius... I don't think that's how you're suppose to use that phrase.
17:14:13 <dibblego> djahandarie, ?
17:14:27 <djahandarie> dibblego, original being "Lies, damned lies, and statistics"
17:14:50 <dibblego> I like ddarius' better
17:15:07 <djahandarie> Which puts statistics in a poor light since they are often used to support weak arguments
17:15:10 <tac-tics2> crap, I wish I had my Pierce book here
17:15:15 <djahandarie> I think the opposite is true of proofs ;)
17:15:24 <tac-tics2> I havent' written an interpreter in a while
17:15:28 <dibblego> so do I, which is why I like it :)
17:15:49 <ddarius> Why do you need a book to write an interpreter?
17:15:54 <dibblego> a modification on a quip that more closely coincides with reality is fine with me :)
17:16:04 <tac-tics2> Because it's been a while :P
17:16:18 <tac-tics2> And the last couple I wrote were in languages like Scheme or C
17:16:39 * ddarius wonders what the first interpreter he wrote was.
17:17:39 <tac-tics2> Ah,
17:17:43 <tac-tics2> Brain, yes, remember
17:17:53 <xplat> "lies, damned lies, and proofs" might apply pretty well to cryptography so far
17:17:56 <tac-tics2> eval ISN'T :: Ctx -> Term -> Term
17:18:05 <tac-tics2> it's Ctx -> Term -> LanguageObject
17:18:10 <tac-tics2> is the way I usually set it up
17:18:25 <xplat> there have been a lot of proofs there that sounded like they proved something strong but were really very weak, almost useless
17:18:45 <Philippa> yeah. Ones involving "free markets" are a common offender
17:18:46 <xplat> and not many of the actual strong proofs connect to applications in any way
17:19:02 <xplat> oh, that's economics, you run into it there too
17:19:35 <djahandarie> God, hackage still hardly loads for me (only after like a few seconds of waiting).
17:20:01 <dolio> Seconds of waiting? How do you stand it?
17:20:17 <djahandarie> On every page!!
17:20:20 <djahandarie> The inhumanity...
17:20:34 <xplat> HURRY UP HACKAGE!  PEOPLE ARE DYING ALL AROUND ME!  THE BOMBS ARE FALLING!
17:20:54 <djahandarie> It's honestly been like this for me for nearly a year now, and I have not the slightest clue why
17:20:55 <tac-tics2> xplat: That's what you get for messing around in IO
17:21:21 <ville> Any idea if Haskell development for Android is possible?
17:21:32 <Johnny1> hi guys. im trying to write a code that sorts a list and then gives me number at listlength /, but i keep getting an error i dont quite understand. could someone please help me out?
17:21:35 <Johnny1> quicksort :: (Ord a) => [a] -> [a]   quicksort [] = []   quicksort (x:xs) =      let smallerSorted = quicksort [a | a <- xs, a <= x]         biggerSorted = quicksort [a | a <- xs, a > x]           in  smallerSorted ++ [x] ++ biggerSorted      median (x:xs) = (x:xs) !! (length (x:xs) `div` 2) 
17:21:40 <Johnny1> (link coming)
17:22:22 <Johnny1> http://hpaste.org/42209/median
17:23:13 <xplat> there are faster ways to find a median
17:23:30 <djahandarie> Is there any documentation on Parsec 3 by the way? I think I have yet to come across any besides the small notes written for the Hackage documentation
17:23:33 <Johnny1> i guess what youre thinking of is just dividing the list by 2 etc
17:23:53 <Johnny1> but the problem is, if i had a list like [2,4,6,10,12] id probably get a number thats not even contained in my list
17:24:26 <djahandarie> Integer division of the list length?
17:24:29 <xplat> but more on point, why are you pattern-matching the argument of median as x:xs?  you're only ever using the whole list
17:24:29 <tg_> Johnny1: if you get a median that's not in the sample, then you don't have a median
17:24:47 <dolio> That's not true.
17:24:57 <tg_> is my understanding of median incorrect?
17:25:09 <xplat> tg_: yes
17:25:20 <dolio> If you have an even number of values, the median can fail to be in the set.
17:25:37 <dolio> It's the mean of the two central values.
17:25:41 <tg_> dolio: sort of. I always viewed that as just having two medians
17:25:45 <Johnny1> the pattern matching was a leftover because the code looked differently some minutes ago
17:25:49 <tg_> but you still need to pick elements from the list
17:26:20 <dolio> So the median of [0,2,4,6,8,10] is 5.
17:26:26 <Johnny1> yes, e.g. if i have [2,3,4,5], hes supposed to pick 3
17:26:48 <mauke> sigh. germans.
17:26:53 <xplat> and it's impossible to not have a population median for a totally-ordered variable short of maybe some really exotic and bizarre distributions, and impossible to not have a sample median period
17:27:54 <tg_> dolio: what about [4,6]
17:27:59 <dolio> Also 5.
17:28:04 <djahandarie> Anyways, for quicksort you want to pick a pivot, so a median not in the set is pretty useless
17:28:17 <tg_> dolio: wikipedia says 'usually' on this.
17:28:18 <Johnny1> in my case hes supposed to pick 4
17:28:35 <xplat> tg_: that's an acceptable definition for some purposes and some people use it, but most use the mean of those two numbers because it's easier to work with
17:28:49 <dolio> If you're required to pick something from the set, obviously you shouldn't follow that rule.
17:29:04 <tg_> xplat: yeah... I just always thought that a definition of median which uses the mean is... strange
17:29:08 <Shane_> hi
17:29:08 <djahandarie> Johnny1, see div and length
17:29:19 <tg_> but I'm clearly wrong about that being standard
17:29:24 <tg_> so I disappear into the dust
17:29:41 <Johnny1> djahandarie: what exactly do you mean?
17:29:49 <djahandarie> Johnny1, those are built-in functions
17:29:50 <Shane_> http://stackoverflow.com/questions/4404663/haskell-equation-expander-1111
17:29:50 <djahandarie> :t div
17:29:51 <lambdabot> forall a. (Integral a) => a -> a -> a
17:29:51 <djahandarie> :t length
17:29:52 <lambdabot> forall a. [a] -> Int
17:30:00 <JamesTheDolphin> Haskell got me laid last night. True story...
17:30:00 <djahandarie> Johnny1, div is integer division.
17:30:07 <djahandarie> Johnny1, length gets you the length of a list.
17:30:13 <Johnny1> yes but im using them already
17:30:18 <Johnny1> http://hpaste.org/paste/42209/median_annotation#p42210
17:30:58 <Cale> Shane_: Someone wrote a web one, but I'm not sure what the URL is anymore...
17:31:11 <Cale> Shane_: There isn't a really complete one
17:31:24 <Shane_> Thanks Cale
17:31:25 <Cale> (which is sad, because I'd like to have one as well)
17:31:29 <moosefish> err... so. Is it expected that anything polling the filesystem (think stat(2) ) on Mac OS X would be returning garbage?
17:31:54 <kmc> JamesTheDolphin, oh?
17:31:55 <xplat> i don't think i would expect that
17:32:01 <djahandarie> Johnny1, what is the problem with ((length list) `div` 2) ?
17:32:04 <moosefish> I have System.Directory.doesFileExist return the wrong thing; previous experiments had the same issue with System.Posix.Files
17:32:20 <djahandarie> Oh
17:32:20 <djahandarie> lol
17:32:28 <Johnny1> djahandarie: well my main problem seems to be that when i try to make him quicksort a list and then give me the median, he gives me errors
17:32:30 <Johnny1> like:
17:33:00 <Johnny1> "couldnt match expected type a -> [t]"
17:33:12 <mauke> what's the actual error?
17:33:59 <Johnny1> "couldnt match expected type 'a -> [t]' against inferred type '[t1]' 
17:34:07 <Johnny1> in the second argument of '(.)', namely
17:34:17 <Johnny1> quicksort [4,3,2,1,...]'
17:34:27 <Johnny1> in the expression: median . quicksort [4,3,2,1...]
17:34:31 <mauke> oh hey
17:34:32 <djahandarie> That is not how you define a list
17:34:41 <xplat> oh.  you want median . quicksort $ [stuff]
17:34:42 <mauke> that expression is not in your code
17:34:44 <Cale> Johnny1: unless quicksort has a second parameter,  quicksort [4,3,2,1...] isn't a function
17:35:00 <Johnny1> well i tried "median.quicksort [34,2,5,64,4]
17:35:04 <mauke> why?
17:35:06 <Johnny1> i wanted him to do quicksort first and then median
17:35:07 <Cale> Johnny1: and so composing it with another function doesn't make sense
17:35:14 <Johnny1> hmm
17:35:18 <mauke> Johnny1: spacing doesn't affect precedence
17:35:21 <Cale> Johnny1: You want (median . quicksort) [...]
17:35:28 <Johnny1> oh
17:35:29 <Johnny1> ill try
17:35:29 <mauke> 1+2 * 3 is still 7
17:35:30 <Cale> Johnny1: Or:  median . quicksort $ [...]
17:36:01 <Johnny1> now it works.. thanks ;)
17:36:41 <Cale> It would be pretty funny if spacing did affect precedence like that.  1+2 * 3+4  +  5+6
17:36:57 <xplat> i've thought about having that in a language design
17:37:41 <jix> iirc ruby does that for unary minus
17:37:50 <xplat> it's a lot easier and less cluttered than parentheses as long as you don't have too many levels
17:38:19 <xplat> and if you do, well, you can save the parens for where they're most needed
17:39:44 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave new section :)
17:42:09 <pygmalion> can someone tell me what the fokker trick is? i see it in my notes but i failed to define it (studying for a final exam)
17:42:44 <dolio> Never heard of it.
17:42:52 <xplat> i think it has something to do with unloading all your missiles at the enemy and then dying
17:43:01 <pygmalion> xplat: bahaha
17:43:36 <FauxFaux> pygmalion: It's probably mentioned in http://people.cs.uu.nl/jeroen/courses/fp-eng.pdf
17:43:53 <deech> Does anyone know if there are efforts to develop a good IDE for Haskell? I've looked into Leksah, are there any others?
17:43:54 <FauxFaux> Just learn the whole thing and you'll be fine.
17:44:04 <pygmalion> FauxFaux: haha thanks
17:44:28 <tac-tics2> weeeeee I remember this crap ^^;
17:45:05 <djahandarie> monochrom, it's annoying how 60% of your site doesn't scroll when I scroll the page
17:45:13 <tac-tics2> I can eval (\x -> Suc x) (Zero) and I get the result 1
17:46:10 <kmc> deech, the emacs and vim bindings
17:46:13 <kmc> also http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#inf-haskell.el:_the_best_thing_since_the_breadknife
17:46:46 <kmc> and 'scion', which provides the backend for an IDE to talk to GHC API
17:47:00 <kmc> and yi, a text editor written in Haskell
17:47:18 <kmc> also some projects to support Haskell in VS; not sure if any are fresh
17:48:36 <deech> kmc: interesting. I'm using emacs but I never took advantage of inf-haskell. 
17:49:44 <deech> I've been doing a bunch of Java development lately and thinking how much better an IDE could do with Haskell. 
17:50:13 <xplat> yes it would
17:50:38 <xplat> however haskell is good enough already that it doesn't produce the level of desperation for an IDE that java does ...
17:52:06 <deech> I dunno ... automatic import management and module lookup are very handy tools.
17:52:27 <mee> vim and emacs seem to be closest to that ideal
17:52:28 <dibblego> I use leksah 8 hours per day and I get paid for it
17:52:48 <mee> I could never get leksah to work at all :(
17:52:53 <dibblego> sometimes I use intellij idea for java and/or scala, but I consider that after-hours work :)
17:52:59 <deech> dibblego: Yeah leksah is very nice. I wish it supported emacs key bindings.
17:53:01 <xplat> you think 'oh, that would be pretty handy', not 'oh god i must have that or i will go insane'
17:53:02 <thoughtpolice> ghc-mod is awesome if you use emacs, IMO
17:53:29 <deech> whats ghc-mod
17:53:30 <lispy> ghc-mod?
17:53:37 <thoughtpolice> http://www.mew.org/~kazu/proj/ghc-mod/en/
17:53:59 <thoughtpolice> ^^ i'm surprised how few people know about it, considering I figured there were many emacs haskell users
17:54:05 <deech> wtf?
17:54:12 <thoughtpolice> it's on hackage btw, so 'cabal install ghc-mod'
17:54:19 <deech> Why did I not know about this?
17:54:40 <lispy> Did the author(s) announce it on haskell-cafe and/or reddit?
17:54:41 <thoughtpolice> yep. the flymake mode is very awesome IMO, although some people don't like it
17:54:58 <thoughtpolice> I think there was an initial announcement but I'm not sure, you'd have to ask kazu I guess
17:55:23 <deech> So flymake-haskell comes with ghc-mod?
17:55:27 <thoughtpolice> hm, it does not look like it.
17:55:32 <lispy> I ignored reddit for a long time, which seems to be a mistake.  Lots of Haskell stuff happens there now
17:55:39 <thoughtpolice> deech: yes, just install it like it says on the webpage and everything Just Works
17:55:50 <djahandarie> lispy, yeah, that's what I use for most of my Haskell news
17:55:56 <deech> criminy!
17:56:14 <lispy> djahandarie: I recently discovered you can make RSS feeds appear like IRC channels by using twitter.  So I do that now.
17:56:26 <lispy> I get my news in an IRC-like format via twitter
17:56:37 <thoughtpolice> it's quite handy although there are some rough edges to ghc-mod
17:56:52 <lispy> (I previous did not see any value in twitter)
17:57:05 <djahandarie> I have never got into twitter though
17:57:23 <thoughtpolice> i use twitter to stalk people, AKA I basically only follow people to see interesting things go by
17:57:40 <thoughtpolice> so yeah, same thing kinda I guess
17:57:48 <lispy> tweetfeed makes it a useful tool though
17:58:15 <lispy> and pidgin/adium both support oauth so you can get your twitter feed in a tab in your chat client
17:58:27 <luite> hmm, cabal: cannot configure ghc-mod-0.5.1. It requires ghc -any
17:58:42 <xplat> i always had ways to stalk some interesting people so twitter didn't do anything for me :7
17:59:01 <dcoutts_> luite: ghc-pkg check, perhaps your ghc package is missing deps
17:59:43 <xplat> maybe i should put up a twitter feed so my groupies can stalk me though :P
18:00:08 <luite> dcoutts_: ah thanks, there's some problem with the template-haskell package (ghc 7.0.1 comes with 2.5.0.0, but some package from hackage required 2.4.something)
18:00:10 <lispy> xplat: you can tweet about your haskell exploits and I'd follow you
18:00:41 <lispy> I've gained followers by tweeting about Isabelle/HOL recently too
18:01:22 <xplat> that's only natural
18:02:31 <luite> hmm, I wonder how I can restore the included template-haskell package
18:02:45 <Mathnerd314> is there a name for the datatype transformation data Tree = Empty | Node [Tree] -> data Tree' a = Empty a | Node a [Tree'] ?
18:03:17 <lispy> luite: Any new/modified ones are likely to be installed user while the original is likely installed global.  So you can often hide the local one or (more drastic/less safe) unregister it.  See ghc-pkg
18:04:12 <luite> lispy: hiding the 2.4.x package didn't work, and now I've (stupidly ;p) unregistered the one that was included in the ghc distribution
18:04:41 <xplat> Mathnerd314: i'd call it either 'node labelling' (technical) or 'containerfication' (cute)
18:04:49 <monochrom> first suggestion: reinstall ghc 7
18:05:35 <Johnny1> i dont understand. i hardly changed something in my code (was trying out something else) and suddenly he tells me that x and xs is not in scope? http://hpaste.org/paste/42209/median_annotation#p42210
18:05:46 <Johnny1> i must have changed something without noticing
18:05:50 <tac-tics2> @djinn a -> a
18:05:50 <lambdabot> f a = a
18:06:14 <tac-tics2> @djinn a -> (Int -> a -> a) -> Int -> a
18:06:15 <lambdabot> Error: Undefined type Int
18:06:23 <tac-tics2> @djinn Nat -> Nat
18:06:23 <lambdabot> Error: Undefined type Nat
18:06:55 <Boxo> @djinn (a -> b) -> (b -> a)
18:06:55 <lambdabot> -- f cannot be realized.
18:07:14 <xplat> @djinn a -> (b -> a -> a) -> b -> a
18:07:14 <lambdabot> f a b c = b c a
18:07:22 <Johnny1> median (x:xs) !! (length (x:xs) `div` 2) 
18:07:39 <Johnny1> let median (x:xs) !! (length (x:xs) `div` 2) 
18:07:52 <Boxo> @djinn (Either a b -> x) -> Either (a -> x) (b -> x)
18:07:52 <lambdabot> f a = Right (\ b -> a (Right b))
18:08:17 <xplat> Johnny1: i ask again, why do you write (x:xs) there instead of just xs?
18:08:52 <xplat> with just xs it would do exactly the same thing
18:09:04 <Johnny1> because the haskell syntax still confuses me
18:09:07 <monochrom> which is to syntax error
18:09:10 <Johnny1> changed it, but still get the error
18:09:12 <engla> Johnny1: media missing parameters
18:09:16 <engla> Johnny1: median
18:09:37 <Mathnerd314> xplat: but it works for most monads, e.g. data IOTree =  Empty | Node (IO [IOTree])
18:09:52 <xplat> no, actually median is missing an equal sign too
18:09:59 <engla> oh yes
18:10:09 <Johnny1> hm, where? right at the beginning?
18:10:16 <engla> Johnny1: median (x:xs) = ...
18:10:39 <Johnny1> ahh.. maybe it works now
18:10:46 <mauke> median xs =
18:10:59 <Johnny1> ah thanks.. 
18:11:01 <monochrom> haskell syntax is very simple. something = something
18:11:10 <xplat> median xs = xs !! (length xs `div` 2)
18:11:48 <mauke> median = ap (!!) ((`div` 2) . length)
18:11:56 <Johnny1> ( working version is here: http://hpaste.org/paste/42209/median_annotation#p42211 )
18:12:33 <Mathnerd314> xplat: though for continuity with my previous example the new type should actually be IO IOTree
18:12:42 <Johnny1> monochrom: the part that sometimes confuses me is the x:xs; xs; [x] part
18:13:02 <Johnny1> monochrom: but i think ill get used to it
18:13:28 <monochrom> they serve rather mutually exclusive purposes so there is little to confuse.
18:13:45 <xplat> Mathner314: oh, and the original is just the transformation with the reader monad?
18:14:04 <Mathnerd314> xplat: yeah, in slightly nicer terms
18:14:08 <xplat> that is kind of cool, but i don't know what to call it
18:15:14 <xplat> it seems like a lot of haskell things, like hxt arrows and iteratees, use that transformation
18:15:29 <xplat> usually on ST or IO
18:15:54 <revenantphx> I need to read up on iteratees when my computer is fixed
18:16:09 <xplat> Oleg calls the iteratee version that is transformed that way generically a 'monadic iteratee'
18:16:12 <tac-tics2> @type fix
18:16:13 <lambdabot> forall a. (a -> a) -> a
18:16:24 <tac-tics2> @type fix
18:16:25 <lambdabot> forall a. (a -> a) -> a
18:16:33 <monochrom> perhaps you can call it parameterization
18:16:36 <xplat> (it's his IterateeM type)
18:17:15 <tac-tics2> @type fix
18:17:16 <lambdabot> forall a. (a -> a) -> a
18:17:18 <tac-tics2> bah
18:17:21 <tac-tics2> alt tab fail
18:17:32 <xplat> he has also called it 'Iteratees parameterized by a monad' but i think 'parameterization' is too generic and 'monadic' is too vague
18:17:54 <monochrom> also you don't have to plug in a monad
18:17:56 <xplat> there should really be a better name for it
18:18:31 <xplat> maybe there's one in category theory to steal
18:18:48 <monochrom> you add a parameter and the kind of the parameter is *->*. perhaps you can call it *->* parameterization.
18:20:31 <xplat> well, really what you are doing to the (recursive) type is you transform it before applying the fixpoint
18:21:00 <monochrom> ah, if you parameterize for the sake of fix later, it's called open recursion
18:21:43 <xplat> heh, that is it!  type-level open recursion.
18:22:20 <xplat> eat your heart out, OO languages without higher-kinded types!
18:24:49 <tac-tics2> alt tab fail
18:24:51 <tac-tics2> bah
18:25:12 <monochrom> do you have a macro for "alt tab fail"? :)
18:26:02 <xplat> allowing arbitrary parameters is probably not useful very often because you need a typeclass to have any way to write polymorphic functions that recurse through the fixpoint
18:26:32 <tac-tics2> what am I doing here...... something about primitive function parameter count
18:26:56 <monochrom> the type class constraint is important but it is given elsewhere
18:27:16 <xplat> but if you want to be generic as possible you could just not make it a policy and let each function ask for the typeclass bound it needs
18:27:25 <tac-tics2> if I want rec to be the structural recursive operator on Nats, rec :: a -> (Nat -> a -> a) -> Nat -> a
18:27:27 <deech> ghc-mod makes me happy.
18:27:46 <tac-tics2> but rec z n, only giving it two parameters, doesn't have any useful meaning
18:27:46 <monochrom> especially since history has taught us that if you specify "monad" too close to the type definition, eventually someone will yell "I have a use of it just needing Applicative".
18:27:51 <tac-tics2> err
18:28:00 <tac-tics2> giving it only one parameter is the meaningless thing
18:28:03 <xplat> monochrom: heh, true
18:28:23 <xplat> the paradigm case being, of course, applicative
18:28:33 <xplat> Applicative, rather
18:30:15 <xplat> tac-tics2: not completely meaningless, although less meaningful than if you gave it just the second parameter
18:31:19 <tac-tics2> I know I want to lift rec into my object language, but I'm not sure how to do it correctly, because of the recursion
18:31:31 <tac-tics2> data Obj = Nat Int 
18:31:37 <tac-tics2> | Func (Obj -> Obj)
18:31:37 <xplat> which is why structural recursors usually are specified with the arguments that handle the recursive cases before the ones that handle the base cases
18:32:47 <sshc> I'm folding over an array from (0, 0) to (1, 9).  But instead of foldring row-major ((0, 0), (0, 1), …), how would I foldr in the order (0, 0), (1, 0), etc.?
18:32:57 <tac-tics2> I could probably lift fix into my object language, but then I have to worry about my eval's evaluation order
18:33:43 <xplat> tac-tics2: your object language is untyped.  how exactly you lift it depends on what you want to do about type errors.
18:33:58 <tac-tics2> error "crap" is good enough for type errors
18:34:03 <Mathnerd314> xplat: so you see it's a good transformation; but implementing it AFAIK requires adding a parameter and using type-level fixed points
18:34:30 <Mathnerd314> xplat: but it seems like there should be a better way
18:35:11 <xplat> Mathnerd314: you probably missed some of the discussion, but we decided it was 'type-level open recursion'
18:35:49 <xplat> languages that depend heavily on open recursion at the value level, like OO languages, usually have special syntactic or semantic support for it
18:35:50 <tac-tics2> hmm.... I could also write the Obj->Obj in terms of eval
18:36:24 <xplat> that's one of the things that makes it awkward to program OO-style in languages not designed for it.
18:38:05 <xplat> (the whole 'object-based' versus 'object-oriented' kerfluffle was basically over whether using a lot of open recursion was a good idea or not)
18:39:17 <klogdar> Hey I dont know if this is the place but anyways I am new to Haskell. When I try to use 
18:39:33 <klogdar> % it says not in scope
18:40:18 <xplat> use `mod`
18:40:48 <Zao> @type mod
18:40:50 <lambdabot> forall a. (Integral a) => a -> a -> a
18:40:50 <monochrom> try: mod 34 5
18:40:53 <klogdar> I mean I want to use it as the ratio thing.
18:40:58 <monochrom> also try: 34 `mod` 5
18:41:05 <monochrom> oh, import Data.Ratio
18:41:07 <Zao> Did you import the module?
18:43:11 <tac-tics2> Maybe if I include a Recur Term constructor and have eval do full recursion with it, but then disallow programs to use Recur in the syntax.
18:43:14 <xplat> tac-tics2: you probably want to write a few combinators for lifting functions into your object language
18:43:31 <tac-tics2> xplat: what kind of combinators are you thinking?
18:43:52 <tac-tics2> xplat: right now, I'm using brute force ;)
18:45:32 <xplat> like, a function of type (a -> Obj) -> (Nat -> a) -> Obj, plus one Nat -> Obj
18:45:47 <klogdar> Thanks for the help, I didn't import the module. Works now.
18:46:03 <xplat> you'd need a couple others to handle HOFs
18:47:02 <ddarius> Two questions: Why do people give you weird looks when you walk down the street singing, and why don't people sing more?
18:47:18 <Johnny1> ok, another question: ive already got a function that checks whether a sequence is a subsequence of another string. but now i need to check whether its a substring aswell. the difference is that the subsequence can be "interrupted" by chars that are not part of the subsequence, whereas this is not possible for the substring. examples:
18:47:46 <Johnny1> [a,b,c] is a subsequence of [f,a,s,b,c]
18:47:52 <xplat> ddarius: because they are worried they might be extras in a musical, and because they are pretty sure they are not leads or chorus in a musical
18:48:15 <Johnny1> [a,b,c] is a substring (and a subsequence at the same time) of [f,a,b,c]
18:48:57 <Johnny1> as i said, ive got the code for the subsequence and tried to change it in order to make it work for the substring too, but so far, ive encountered a problem
18:49:01 <Chaze> if i define fac = scanl1 (*) [1..], it should be cached (memoized), right?
18:49:31 <ddarius> It depends on the type of fac.
18:49:38 <Johnny1> (the code: http://hpaste.org/42214/subsequence_substring )
18:49:40 <c_wraith> Chaze: also depends on if it ever goes out of scope
18:49:42 <ddarius> This is where the monomorphism restriction comes in.
18:50:16 <Chaze> c_wraith: well, for now i just defined it top-level and try it in ghci
18:50:22 <Johnny1> now the problem is this: im trying to make him check that the string is not "interrupted" by chars that are not part of the substring
18:50:25 <Chaze> for some reason, it seems to recalculate every time
18:50:29 <c_wraith> then ddarius answer is the important one.
18:50:38 <c_wraith> Did you provide a type signature for fac?
18:50:46 <Chaze> no
18:51:01 <xplat> ddarius: oh, heh, haskell runtimes will mostly cons a new dictionary in that case so the `fac` won't be shared
18:51:12 <Johnny1> i know, more or less, how to do that if both strings start of identically, but i get lost if they dont match right away 
18:52:06 <xplat> this problem is actually easier in some ways to get the answer right, but it's harder to make fast (so don't try to make it fast :) )
18:53:10 <Chaze> what if i define fac = list !! where list = scanl1 (*) [1..]
18:53:17 <Chaze> can it be memoized?
18:53:25 <tac-tics2> grr
18:53:26 <tac-tics2> stupid fix
18:53:50 <xplat> Johnny1: the problem you're having is if you found a start of a match but not a whole match, you have to go back and look for matches of the whole substring again, not just the part that is left
18:53:53 <c_wraith> Chaze: depending on optimization level, sometimes.  Which is actually not the answer you want.
18:53:53 <tac-tics2> normal order evaluation always minimizes the amount of time an expression takes to compute
18:54:06 <tac-tics2> which means if you use fix and you DON'T use normal order evaluation
18:54:12 <tac-tics2> everything takes an infinite amount of time to evaluate
18:54:13 <tac-tics2> ;/
18:54:21 <Johnny1> hm
18:54:40 <xplat> Chaze: same problem, there's a hidden argument so you get a new thunk for the whole list every time you call it
18:54:47 <Cale> Chaze: You'll want to pull the list up a level
18:54:49 <Chaze> c_wraith: being pragmatical here: how would you define a fac function that gets easily memoized?
18:54:56 <Cale> Chaze: if you want the results to be stored
18:55:09 <tac-tics2> is there no way to define rec without fix?
18:55:17 <c_wraith> Chaze:  facs :: [Integer] ; facs = scanl1 (*) [1..]
18:56:02 <Cale> Though, !! is slow. It's hard to say whether defining fac like that will really save much work.
18:56:54 <xplat> tac-tics2: you can define rec without fix, but you have to use SOME stronger recursion operator.  in haskell, every recursive function uses syntactic recursion, which is equivalent to fix
18:57:57 <Johnny1> xplat: can you give ma a hint how to code that please?
18:58:45 <Johnny1> i need a way how to make him check for all the chars in their correct order without interruptions
18:58:47 <Johnny1> not char by char
18:59:03 <xplat> Cale: computing factorials from scratch is worse than O(n).  depending on cache behaviour and various things scanning the list could be faster than doing your first operation on the returned answer, for large n
18:59:05 <Johnny1> i tried using using " ", but always got errors
19:00:23 <tac-tics2> xplat: yeah, I got that. But without using "defines" or "letrecs", I'm not sure if there's a simpler way to do this
19:00:38 <xplat> Johnny1: first try writing a function startsWith a b that checks if string b starts with string a.  then see if you can use that to define the function you want.
19:00:44 <tac-tics2> I guess I need a form of letrec
19:01:02 <xplat> Johnny1: (by using startsWith, not by changing it into the function you want)
19:01:45 <xplat> Johnny1: it's okay to write two functions for one problem and have one call the other
19:03:13 <xplat> tac-tics2: i would just lift the haskell function rec to your object language and let the object language programs use it as a constant, unless you have a reason not to do that
19:05:45 <tac-tics2> xplat: I'm not sure how to do that exactly, because of the recursion aspect. It would be a really tricky use of fix
19:06:07 <elzurk> I have a function that get's the ith page from a forum type website:  getPage :: Int -> [Entries]
19:06:34 <elzurk> well, sorry, it's: getPage :: Int -> IO [Entry]
19:07:08 <elzurk> and I'd like to create a function that returns an "infinite stream" of entries
19:07:13 <elzurk> how can I go about doing that?
19:08:09 <Chaze> i often end up doing something like (uncurry (==)) . (id &&& someFunction)
19:08:09 <Chaze> is there some idiom for that?
19:08:21 <elzurk> I guess the type is:  getStream :: IO [Entry], correct?  In that case, how could I do something like a takeWhile on that function?
19:11:35 <Chaze> using cale's example from yesterday, i tried using "liftM2 (==) id myFunction", but it doesn't seem to work
19:11:46 <xplat> tac-tics2: what at all does it have to do with fix?
19:12:01 <xplat> fix is only inside rec, it doesn't affect lifting at all
19:12:13 <Cale> > liftM2 (==) id (*2) 5
19:12:13 <lambdabot>   False
19:12:18 <Cale> > liftM2 (==) id (*2) 0
19:12:18 <lambdabot>   True
19:13:11 <Cale> Chaze: Make sure that you've imported Control.Monad.Instances
19:13:57 <Chaze> Cale: turned out the error wasn't related, works now
19:14:28 <Johnny1> xplat: ok i wrote a function that does what you advised me to ( http://hpaste.org/paste/42214/subsequence_substring_annota#p42215 )
19:14:34 <Johnny1> ill now try to make it help me
19:16:44 <Cale> Johnny1: Based on how you're pattern matching, you know that head xs = x and head ys = y
19:16:54 <Cale> Johnny1: So you should just use x and y :)
19:17:07 <Johnny1> hm
19:17:35 <Cale> btw, anything starts with the empty string, doesn't it?
19:17:56 <Cale> and you're sort of ignoring the tail of the lists
19:18:03 <Cale> are you sure that's what you want?
19:18:46 <Johnny1> i wondered about the same thing but i thought, i was supposed to write a function that only checks whether they start of equally and then check in another function whether the tail is equal too
19:20:07 <Johnny1> off *
19:21:21 <Cale> In general, you should try to avoid explicitly applying the head and tail functions whenever you can, and instead let pattern matching do the work for you.
19:21:29 <Cale> (or higher-order functions, of course)
19:22:29 <Johnny1> hmm i now tried out two versions of my startswith. one using my x:xs y:ys code and the "shorted" one using only x and y
19:22:31 <ddarius> :t let hofHead = (. head) in hofHead
19:22:32 <lambdabot> forall a b. (a -> b) -> [a] -> b
19:23:11 <Johnny1> the shorted version says that "a,b,c," and "a,d,b" is false and only "a,b,c," and "a,b,c" is true, whereas my code says that the first is true too
19:23:27 <Johnny1> (ill upload)
19:23:58 <Johnny1> http://hpaste.org/paste/42214/subsequence_substring_annota#p42217
19:24:20 <Johnny1> oh, dont mind the [ ] _ = false stuff
19:24:58 <Cale> Johnny1: You weren't meant to change the pattern
19:25:09 <Cale> You changed it to startsWith x y
19:25:32 <Johnny1> then i mustve misunderstood
19:25:41 <deech> Hi all, I am reading about polyvariadic functions. The form seems to be a typeclass "Class" with a "func" and instances , Class (a -> b) and Class b. My question is how does "func" know when its done receiving arguments?
19:26:14 <Cale> deech: Because the type at which it's used isn't a function type
19:26:20 <aavogt> deech: because somehow the context forces it to use the instance b
19:26:58 <ddarius> Note that it wouldn't work with C b, you need concrete type constructors for the base case.
19:27:48 <Johnny1> ok now the short version works identically
19:27:51 <deech> So I was going with Edward Yang's example on the mailing list and the "callfunc" example in hslua.
19:28:04 <Cale> Johnny1: If a list matches (x:xs), then x is the head of the list, and xs is the tail of the list
19:28:56 <Johnny1> http://hpaste.org/paste/42214/subsequence_substring_annota#p42218
19:29:08 <tac-tics2> hell, I still can't figure this out
19:29:42 <Cale> tac-tics2: What are you trying to sort out?
19:30:32 <Nubkakes> Hey, can anyone help me clean up a function I wrote? It works... But I have a feeling there is a slightly cleaner way of doing what it does
19:30:32 <tac-tics2> I'm trying to write a simple untyped lambda calculus whose only objects are naturals and functions thereof 
19:30:53 <ddarius> Should be less than ten lines of Haskell.
19:31:02 <tac-tics2> Cale: the problem is I don't want general recursion. Only structural recursion, granted by the primitive rec : a -> (Nat -> a -> a) -> Nat -> a.
19:31:09 <Nubkakes> I  think I am at 13
19:31:10 <Cale> Johnny1: This function is different, but probably more useful: http://hpaste.org/paste/42214/subsequence_substring_annota#p42220
19:31:10 <Nubkakes> http://hpaste.org/42219/nth_term_of_fibonacci_sequence
19:31:35 <Cale> tac-tics2: Okay, that shouldn't be too bad
19:31:53 <ddarius> tac-tics: The untyped lambda calculus already gives general recursion, so how are you going to rein that in?
19:31:56 <Johnny1> Cale: thanks, what is the main difference?
19:31:56 <Cale> tac-tics2: Do you have a simply typed lambda calculus evaluator?
19:31:58 <tac-tics2> Cale: No, it shouldn't. Which is bothering me
19:32:05 <tac-tics2> I'll hpaste it
19:32:07 <tac-tics2> @hpaste
19:32:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:32:12 <Cale> tac-tics2: Er, actually, you don't want types?!
19:32:22 <tac-tics2> Lol, baby steps
19:32:23 <Cale> Types are what makes it possible to restrict recursion.
19:32:28 <tac-tics2> I haven't written an invaluator in a long time
19:32:31 <tac-tics2> I'm going to add types next
19:32:37 <tac-tics2> incremental development
19:32:44 <Cale> If you're in the untyped lambda calculus, you can just use Y to define general recursion
19:33:08 <Johnny1> hmm it gives back False when i check "a,b,c" and "a,d,b"
19:33:29 <Cale> Johnny1: Right, because neither of those starts with the other
19:33:52 <tac-tics2> http://hpaste.org/42221/evaluator
19:33:56 <tac-tics2> is what I have so far
19:34:30 <tac-tics2> I don't want to define Y, because I don't want to limit my eval to normal-order eval
19:34:40 <Cale> what?
19:35:06 <Cale> I mean that any untyped lambda calculus will admit Y, and then give you general recursion.
19:35:18 <ddarius> Y or Z.
19:35:23 <Cale> Sure.
19:35:30 <tac-tics2> yes, but as I evaluate Y x in a strict evaluator, it loops
19:35:32 <tac-tics2> in the bad way
19:35:50 <Nubkakes> Is it possible to find the "nth" term of the fibonacci sequence without using recursion in haskell?
19:35:57 <Cale> Oh, well, then use a different fixpoint combinator which works for that evaluation order
19:36:06 <tac-tics2> I didn't know they did that
19:36:12 <tac-tics2> I only knew about Y
19:36:22 <Cale> Nubkakes: Without using recursion?
19:36:29 <Cale> Nubkakes: That seems impossible in any language.
19:36:37 <Nubkakes> I figured as much
19:36:39 <tac-tics2> another combinator would work, but I'm thinking there's probably an easier way 
19:36:49 <ddarius> Nubkakes: Since the only way to iterate at all in Haskell is via recursion, no, not for all values of n.  There will be recursion hidden somewhere (or looping in foreign code.)
19:36:56 <Cale> Nubkakes: You at least need to loop, which counts as recursion.
19:37:07 <tac-tics2> a new Term or Obj I can add to the evaluator
19:37:28 <ddarius> You can calculate some using phi, but even that has looping in the hardware, possibly unrolled.
19:37:45 <Johnny1> i cant think of a way how to incorporate my startswith into my issubstring in a useful way..
19:38:04 <Nubkakes> Awesome! Then my method is valid! Proff is asking for a function that finds the Nth term of the fibonacci sequence without recursion if possible. I assumed it was impossible so thats how I got the code I did
19:38:06 <Johnny1> what i want him to do is something like
19:38:08 <Chaze> how would i use liftM2 in this case? (uncurry splitAt) . (((`div` 2).length) &&& id)
19:38:21 <Johnny1> "if startswith gives back true, check whether the rest is identical, too"
19:38:39 <Johnny1> and "if not, check for the next char whether its true now"
19:39:02 <Cale> Johnny1: him?
19:39:09 <Johnny1> mr computers
19:39:28 <Cale> it
19:39:57 <Nubkakes> Hmmm does anyone know of a haskell guide for Lambda Calculus?
19:40:17 <Cale> Johnny1: I suppose you could do something like that, but it's easier to do it the way I showed you
19:40:29 <jmcarthur> Nubkakes: the lambda calculus from a haskell perspective?
19:40:30 <Mathnerd314> GHC has implicit parameters. Do they work for type variables?
19:40:41 <Cale> Johnny1: If both the lists are not empty, compare their first elements, and only if they match, compare the tails
19:40:48 <Chaze> Nubkakes: shouldn't the syntactic difference by neglectable?
19:40:52 <Johnny1> hm
19:40:54 <Cale> and in the other cases, give True or False accordingly
19:40:59 <jmcarthur> Nubkakes: i don't know of anything in particular, but i promise that the lambda calculus is simple enough in isolation that you shouldn't have trouble with something more generic
19:41:00 <Nubkakes> jmcarthur: I think so
19:41:05 <Johnny1> but
19:41:20 <Johnny1> in that case [a,b,c] and [f,a,b,c] would return False, no?
19:41:38 <Johnny1> i want it to return True in that case
19:41:54 <Cale> Johnny1: We're just checking if one list is a prefix of the other
19:42:20 <Johnny1> yes
19:42:35 <Cale> Johnny1: This is a useful building block for determining if one list is a sublist of another, because that's the case if it's a prefix of some tail of the list.
19:42:57 <Cale> contains xs ys = any (startsWith xs) (tails ys)
19:43:23 <Johnny1> Cale: is "any" a function in haskell?
19:43:30 <Cale> yes
19:43:43 <Johnny1> oh
19:43:47 <Cale> any p xs = or (map p xs)
19:43:52 <Nubkakes> Yea since I am supposed to make a function that returns the square of the product of 2 numbers using only lambda calc. I can do it without lambda calc but...  
19:44:17 <Cale> or = foldr (||) False
19:44:30 <Nubkakes> I thought lambda calc was a haskell exclussive thingy
19:44:35 <Cale> Nubkakes: nope
19:44:49 <Cale> Nubkakes: Lambda calculus is older than electronic computers.
19:45:26 <ddarius> A mere child.
19:45:27 <Cale> It was among the first formalisations of what computation means, in fact, I think it may even be a bit older than Turing machines
19:45:34 * ddarius programs in Babbage's notation.
19:46:41 <tg_> Cale: I am pretty sure I read somewhere that Turing read Church's work
19:46:56 <Cale> yeah, they were contemporaries
19:47:11 <Cale> Aha, LC was introduced in 1930, and Turing machines in 1937
19:47:56 <tg_> Cale: upon further investigation
19:47:56 <Cale> 1936 was when Church isolated the part useful for computation and published about that
19:48:00 <tg_> Church was Turing's doctoral advisor
19:48:05 <tg_> so...
19:48:21 <Cale> So, pretty much the same time :)
19:48:46 <tg_> From September 1936 to July 1938 he spent most of his time at the Institute for Advanced Study, Princeton, New Jersey, studying under Alonzo Church.
19:49:34 <tg_> surely at some point in their relationship, he said "Alan, have you read my work on lambda calculus?"
19:49:51 <Mathnerd314> GHC has implicit parameters. Is there some equivalent notion for type variables, so I do not have to keep passing around 10 parameters every time I use a type?
19:50:01 <Johnny1> ok
19:50:04 <Johnny1> i just wont get it to work
19:51:47 <xplat> tac-tics2: hey, i came up with a function to wrap rec
19:52:01 <Cale> tg_: It would be pretty funny if it just never came up
19:52:29 <tg_> Cale: Turing was a big fan of the Greek
19:52:36 <tac-tics2> xplat: yeah?
19:52:58 <tac-tics2> I was just about to move on to using a continuation-based eval
19:54:10 <xplat> first you write functions unNat and unFunc which you can do just by using record syntax in your object language data declaration.  they unwrap that constructor or blow up.
19:54:47 <Chaze> amazing how simple the power function in lambda calculus is: λab.b a
19:55:02 <Chaze> (using church encoding)
19:56:17 <tg_> before I go afk,
19:57:15 <tg_> Chaze: that's a little like saying it's amazing how powerful GR is, R - 1/2Rg = kT... using Einstein's notation
19:57:21 <xplat> then you write unwrapStep = (fmap.fmap) unfunc $ (. nat) . unfunc
19:57:32 <xplat> er
19:57:43 <xplat> then you write unwrapStep = (fmap.fmap) unFunc $ (. Nat) . unFunc
19:57:50 <tg_> which glosses over the fact that it takes years to learn what that means :)
19:57:54 <Chaze> tg_: no idea what you're talking about :(
19:58:16 <tg_> Chaze: Einstein invented a few notational steps when he discovered General Relativity
19:58:18 <xplat> that one is kind of magic, it should unwrap your step function from an Obj
19:58:39 <tac-tics2> xplat: Haskell is the Magician's programming language
19:58:41 <Chaze> tg_: but this is not a notation
19:58:46 <freedrull> can i get the pure value from a state monad.... -__- ? im sure this is a common question...
19:58:57 <tac-tics2> Looks like it does the impossible, but really, it's just doing the very obfuscated possible
19:59:11 <Chaze> it's simply "apply second argument to first argument", no more hidden semantics than that
19:59:35 <tg_> Chaze: And Einstein's trick is simply "sum over all indices"
19:59:47 <Johnny1> http://hpaste.org/paste/42214/subsequence_substring_annota#p42222 he returns several errors about every entered char not being in scope when i try out the code :(
19:59:56 <tg_> Chaze: I suppose it's a poor analogy
20:00:12 <Chaze> tg_: but einstein just 'defined' a notation for something complex
20:00:33 <Chaze> the power function simply turns out to be like that - kind of a revelation
20:00:43 <xplat> then you write wrapFunc unwrap wrap = func . (. unwrap) . (wrap .)
20:01:50 <xplat> then wrapRec = wrapFunc id $ wrapFunc unwrapStep $ wrapFunc unNat $ id
20:02:27 <xplat> then wrappedRec = wrapRec rec
20:02:33 <xplat> that should be of type Obj
20:04:17 <Johnny1> please, help me somebody with my code. everything seems to be out of scope http://hpaste.org/paste/42214/subsequence_substring_annota#p42222
20:04:53 <xplat> and it should work like rec in any evaluator for your language
20:06:26 <xplat> that line '| Func (Obj -> Obj)' in your data declaration allows for all kinds of secret black magic, including this
20:07:43 <Johnny1> Cale: ive tried using your "any" function but it doesnt work yet because everything seems to be out of scope http://hpaste.org/paste/42214/subsequence_substring_annota#p42222
20:08:10 <Chaze> Johnny1: first of all, you ignore the first element in both lists in isSubstring
20:08:42 <Chaze> :t tails
20:08:43 <lambdabot> forall a. [a] -> [[a]]
20:08:57 <Chaze> i haven't read his code, but i guess he was using tails
20:09:02 <Cale> Johnny1: Why the pattern matching in isSubstring?
20:09:20 <Cale> Johnny1: It shouldn't be required to handle the empty and nonempty cases any differently
20:09:41 <Cale> Johnny1: also, tails, not tail
20:10:23 <Chaze> yeah, isSubstring x y = any (startsWith x) (tails y)
20:11:30 <Johnny1> he tells me xs, ys and tails not in scope
20:11:38 <Johnny1> IT!
20:12:02 <Cale> isSubstring xs ys = any (startsWith xs) (tails ys)
20:12:20 <Cale> If tails is not in scope, import Data.List
20:12:27 <Cale> Or write your own :)
20:13:06 <Johnny1> now it loads the module
20:13:10 <Johnny1> but it doesnt work yet
20:13:16 <Johnny1> (thanks for import data btw. solved the tails problem)
20:13:43 <Johnny1> all chars remain to be out of scope
20:14:33 <Chaze> does someone bother to make this more elegant? palindromic = (uncurry (==)).(first reverse).(uncurry splitAt).(((`div` 2).length) &&& id)
20:14:48 <applicative> > let isSubstring xs ys = any (startsWith xs) (tails ys) in isSubstring "foo" "fool"
20:14:48 <lambdabot>   Not in scope: `startsWith'
20:14:53 <applicative> duh
20:15:20 <Cale> Johnny1: what?
20:16:03 <Chaze> > startswith "f" "foo"
20:16:04 <lambdabot>   Not in scope: `startswith'
20:16:17 <c_wraith> > "f" `isPrefixOf` "foo"
20:16:18 <lambdabot>   True
20:16:39 * hackagebot yajl-enumerator 0.3 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.3 (JohnMillikin)
20:17:55 <Johnny1> Cale: hmm, still doesnt work quite
20:17:58 <xplat> Chaze: palindromic = join $ (==) . reverse
20:18:07 <Johnny1> still gives back false for "a,b,c" and "f,a,b,c"
20:18:12 <Johnny1> the new code looks like this:
20:18:13 <Chaze> xplat: thanks
20:18:15 <Chaze> i wonder if someone ever wrote a commit hook which applies #haskell-transformation, which essentially pastes it here and waits for a more elegant, and efficient version
20:18:36 <xplat> mine is more elegant in this case, but less efficient
20:18:51 <applicative> >  let isSubstring xs ys = any (isPrefixOf xs) (tails ys) in isSubstring "foo" "fool"
20:18:52 <lambdabot>   True
20:18:58 <Johnny1> http://hpaste.org/paste/42214/subsequence_substring_annota#p42223
20:19:15 <Johnny1> let isSubstring xs ys = any (isPrefixOf xs) (tails ys) in isSubstring "foo" "bfool"
20:19:31 <Johnny1> how do you guys use lambdabot?
20:19:41 <xplat> Johnny1: you need a > before the haskell to get lambdabot to evaluate it
20:19:45 <Johnny1>   > let isSubstring xs ys = any (isPrefixOf xs) (tails ys) in isSubstring "foo" "bfool"
20:19:58 <xplat> no space before the >
20:20:02 <Johnny1> > let isSubstring xs ys = any (isPrefixOf xs) (tails ys) in isSubstring "foo" "bfool"
20:20:03 <lambdabot>   True
20:20:07 <Johnny1> wtfsdfdsaijfasiof
20:20:36 <Johnny1> > let isSubstring xs ys = any (isPrefixOf xs) (tails ys) in isSubstring "foo" "sfoolfoo"
20:20:37 <lambdabot>   True
20:20:49 <Johnny1> man
20:20:55 <Johnny1> thanks!
20:21:06 <kmc> > 2 + 2
20:21:07 <lambdabot>   4
20:24:16 <aavogt> > ((==) =<< reverse) x y :: Expr
20:24:16 <lambdabot>   Couldn't match expected type `t -> SimpleReflect.Expr'
20:24:17 <lambdabot>         against infe...
20:24:27 <Mathnerd314> GHC has implicit parameters. Is there some equivalent notion for type variables, so I do not have to keep passing around 10 parameters every time I use a type?
20:24:49 <aavogt> Mathnerd314: type inference
20:25:07 <aavogt> > ((==) =<< reverse :: Expr -> Expr -> Expr) x y :: Expr
20:25:08 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
20:25:08 <lambdabot>                           ...
20:25:23 <xplat> aavogt: probably means when defining types
20:25:34 <Mathnerd314> yeah, when defining them
20:25:46 <xplat> in which case, no
20:25:53 <nejucomo> Is it possible to declare an instance for (T S a b) without specifying a or b?
20:26:06 <aavogt> > ((==) =<< reverse :: Expr -> Expr) x :: Expr
20:26:06 <Johnny1> how can it be that lambda bot can use that code by applicative and my computer cant
20:26:07 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:26:07 <lambdabot>         against inferred ...
20:26:16 <xplat> unless oleg thought of something that's already possible in haskell98, in ml, and somehow, in scheme
20:26:19 <kmc> nejucomo, you can declare that this one instance should work for all a and b
20:26:25 <Mathnerd314> e.g. data A a = A a, data B b = B b, data C a b = A' a | B' a 
20:26:28 <kmc> nejucomo, but if it fails it won't try a more specific instance
20:26:30 <Johnny1> > let isSubstring xs ys = any (isPrefixOf xs) (tails ys) in "a,b,c" "f,a,b,c"
20:26:32 <lambdabot>   Couldn't match expected type `t1 -> t'
20:26:32 <lambdabot>         against inferred type `[GHC....
20:26:54 <nejucomo> kmc: How do I make that declaration?
20:26:59 <Mathnerd314> s/B' a/B' b/
20:27:01 <xplat> (do you think oleg would let the fact that scheme doesn't have type parameters at all stop him?)
20:27:19 <kmc> nejucomo, is T a class or a type?
20:27:29 <nejucomo> T is a type.
20:27:32 <aavogt> > (((==) :: Expr -> Expr -> Expr) =<< reverse :: Expr -> Expr) x :: Expr
20:27:33 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:27:33 <lambdabot>         against inferred ...
20:27:39 <kmc> and you have some single-parameter typeclass?
20:27:42 <Johnny1> > let isSubstring xs ys = any (isPrefixOf xs) (tails ys) in isSubstring "a,b,c" "f,a,b,c"
20:27:43 <lambdabot>   True
20:27:46 <jmcarthur> xplat: there are of course typed schemes that you can implement in scheme pretty easily
20:27:51 <Johnny1> why does it work here, wtf..
20:27:53 <kmc> instance C (T S a b) ...
20:27:54 <nejucomo> So I have:  instance MyClass (T X a b) where ...
20:27:58 <nejucomo> -currently.
20:28:09 <kmc> you'd need to turn on FlexibleInstances in GHC, I expect
20:28:11 <aavogt> > let palin = (==) =<< reverse in (palin "hah", palin "no")
20:28:12 <lambdabot>   (True,False)
20:28:22 <nejucomo> I have TypeSynonymInstances.
20:28:28 <jmcarthur> xplat: although i'm not sure how sophistacted the existing ones are
20:28:31 <aavogt> how does one convince Expr to print that?
20:28:37 <nejucomo> I wonder why I have that.  I'll try FlexibleInstances.
20:28:55 <xplat> aavogt use 'f' instead of 'reverse'
20:29:04 <nejucomo> No luck.
20:29:07 <aavogt> > (((==) :: Expr -> Expr -> Expr) =<< f :: Expr -> Expr) x :: Expr
20:29:07 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:29:08 <lambdabot>         against inferred ...
20:29:15 <kmc> nejucomo, and your error message is?
20:29:15 <Johnny1> applicative: in your code, startswith is not neccessary, is it?
20:29:21 <jmcarthur> i always wondered why FlexibleInstances and FlexibleContexts are two separate extensions
20:29:23 <aavogt> > (((==) :: Expr -> Expr -> Expr) =<< (f::Expr->Expr) :: Expr -> Expr) x :: Expr
20:29:23 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:29:24 <lambdabot>         against inferred ...
20:29:39 <deibit> Hello, sorry for the noob issue: Can anybody help me with a cabal cuestion?
20:29:42 <aavogt> xplat: other suggestions? Surely it doesn't need the type of =<<?
20:29:45 <xplat> oh, i guess you can't use == either
20:29:46 <Johnny1> http://hpaste.org/paste/42214/subsequence_substring_annota#p42224
20:29:49 <kmc> deibit, sure, just ask
20:29:55 <nejucomo> kmc: http://codepad.org/JxNTJWry
20:29:58 <aavogt> > x == y :: Expr -- xplat
20:29:58 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:29:58 <lambdabot>         against inferred ...
20:30:03 <jmcarthur> deibit: never ask to ask. just ask and you might get an answer
20:30:07 <xplat> == always returns a boolean, not an Expr
20:30:09 <deibit> I install a fresh cabal on a ubuntu box
20:30:16 <deibit> cabal install gtk
20:30:18 <kmc> nejucomo, oh, but the instance goes through?
20:30:26 <deibit> reports me a Alex not there
20:30:30 <deibit> cabal install alex
20:30:32 <deibit> ok, fine
20:30:41 <deibit> but if I try to cabal install gtk
20:30:44 <jmcarthur> deibit: make sure that ~/.cabal/bin is in your PATH
20:30:48 <aavogt> xplat: finally it makes sense :)
20:30:55 <deibit> ok, doing that
20:31:11 <nejucomo> kmc: I'm not sure what you mean.  Here's the complete source to the module: http://codepad.org/elR7UwAV
20:31:37 <jmcarthur> deibit: i bet it will also say you need to install Happy
20:31:44 <applicative> Johnny1, no i used the standard function isPrefixOf, following c_wraith 
20:31:58 <nejucomo> In the instance I use parse which effectively does: GenParser tok st t -> t
20:32:02 <Johnny1> http://hpaste.org/paste/42214/subsequence_substring_annota#p42224 look i tried to bind it into my code
20:32:03 <nejucomo> -so I really only care about t.
20:32:04 <Johnny1> but it doesnt work
20:32:33 <Johnny1> he still complains about all the strings that i enter not being in scope
20:32:38 <kmc> it's not clear that the problem has to do with the shape of the type you're making an instance of
20:32:41 <deibit> :) it is saying it now jmcarthur
20:32:42 <kmc> it sounds like you just have a type error
20:33:11 <nejucomo> Hm.  Okay, time to reread the code.
20:33:13 <kmc> deibit, fwiw, if you're installing gtk i think you need to cabal install gtk2hs-buildtools first
20:33:22 <applicative> Johnny1, I'm not sure, but as Cale said at the outset, you only need the last of the four lines, not the previous pattern matching
20:33:36 <deibit> yes kmc, I'm on that now, thanks
20:34:28 <Johnny1> applicative: ok i deleted them but the errors remain
20:35:11 <nejucomo> Oh, right I see the first type error.  I generalized Char to tok, so I need to generalize String to [tok].
20:35:14 <Johnny1> http://hpaste.org/paste/42214/subsequence_substring_annota#p42225
20:35:31 <interferon> Suppose I want to send a message from one haskell thread to another and have the response correctly returned back to me. What kind if primitive would suit me? MVar's?
20:35:46 <applicative> http://hpaste.org/42226/subsequence_substring_annota   --Johnny1
20:36:10 <Chaze> here's another function i feel is unnecessarily complex: transform integer to list of digits: http://hpaste.org/42228/todigits
20:36:18 <Johnny1> yay it works
20:36:20 <Johnny1> thanks everyone!
20:36:26 <freedrull> how do you remove a package with cabal?
20:37:54 <nejucomo> kmc: The other type error surprised me:
20:37:56 <kmc> freedrull, you can't really, but you can unregister it with ghc-pkg
20:37:57 <nejucomo> :t parse
20:37:58 <lambdabot> Not in scope: `parse'
20:38:05 <applicative> Johnny1, the overlap was coming from line 3 in isSubstring  -- isSubstring x y = x == y  -- this decides all further cases, so you have to stop defining.
20:38:12 <kmc> interferon, Chan, probably passing a message containing an IO action for the response
20:38:17 <nejucomo> :t Text.ParserCombinators.Parsec.parse
20:38:18 <lambdabot> forall t s a. (Text.Parsec.Prim.Stream s Identity t) => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
20:38:18 <freedrull> kmc: :0
20:39:04 <nejucomo> Hm, that's a different parsec version than I use.
20:39:06 <applicative> freedrull, what is the difficulty?
20:39:08 <kmc> data Request a b = Req a (b -> IO ()) -- interferon
20:39:25 <nejucomo> But notice that the state in the parser (first argument) of parse is ().
20:39:32 <kmc> or «data Request a b = Req a (Chan b)»
20:39:39 <kmc> either way you can then make a Chan (Request a b)
20:39:45 <interferon> And then would I run that action on the sending thread?
20:39:48 <nejucomo> How am I able to use different parser states in the Monad instance?
20:40:03 <kmc> i prefer to make closures over concurrency primitives rather than passing them bare
20:40:32 <freedrull> i figured it out :3
20:41:43 <interferon> kmc: Does it make sense to use a Chan (a, MVar b) and have the calling thread create that MVar b and push it onto the Chan?
20:41:59 <kmc> yeah
20:42:14 <kmc> what i suggested is Chan (a, b -> IO ())
20:42:23 <kmc> which is about the same; you'd just pass (writeMVar v) instead of v
20:42:39 <kmc> i like that because it limits what the other side can do with the var, and hides implementation details
20:42:58 <elzurk> this seems so simple, and yet it's been frustrating me all night: http://hpaste.org/42229/help
20:43:02 <interferon> kmc: Thanks
20:43:43 <kmc> interferon, i think it's more common to spawn a new thread and wait for a result
20:43:55 <kmc> rather than communicating bidirectionally with an existing thread
20:43:57 <Chaze> :t sequence_
20:43:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
20:44:02 <interferon> kmc: So if I were passing in an IO (), what sort of action would it perform?  Would it always invoke some kind of concurrency primitive to get back to the sender?
20:44:10 <nejucomo> That is, because parse requires a "GenParser tok () t" how can I compose with some other parser state, like "GenParser tok MyState t" ?
20:44:13 <kmc> for that you can use http://hackage.haskell.org/package/spawn or any of the many other similar libs
20:44:21 <kmc> interferon, if your type is Chan (a, b -> IO ())
20:44:32 <kmc> then you could use MVar or Chan to get the result back
20:44:36 <kmc> or you could pass "print" to have it sent to the screen
20:44:41 <kmc> or you could drop it
20:44:46 <kmc> or stuff it in a TVar or an IORef
20:44:53 <kmc> or send it to a FFI function
20:44:56 <nejucomo> I should have used "GenParser tok MyState u" in my example, because I understand how Monad composition allows mapping that type to a new type.
20:45:08 <kmc> so it's also more flexible
20:45:17 <interferon> I see
20:45:42 <nejucomo> -but I don't understand how an "instance Monad (GenParser tok st)" allows me to provide parse with a my own state type.
20:45:42 <kmc> or you could do some complicated combination of those
20:45:51 <kmc> like copying the result to many parties
20:45:56 <kmc> or e.g. to the requester and also a log file
20:46:30 <elzurk> I can't seem to be able to conjure up a good way to do this
20:46:47 <elzurk> concatMap type solution doesn't  want to work
20:46:51 <interferon> So here is the ultimate use case - I want to build a lazy cache service so I van fire off a request to the "service" thread, which will either return the element from it's cache or do some I/O to get the appropriate value. Are there any patterns fir that kind if thing?
20:47:08 <kmc> why make it a persistent service thread?
20:47:20 <nejucomo> Oh, of course.
20:47:22 <Cale> elzurk: Are you sure you want those in the IO monad?
20:47:31 <kmc> why not spin up a thread for each request
20:47:32 <nejucomo> :t Text.ParserCombinators.Parsec.setState
20:47:33 <lambdabot> forall u s (m :: * -> *). (Monad m) => u -> Text.Parsec.Prim.ParsecT s u m ()
20:47:53 <Cale> elzurk: Executing an infinite number of IO actions is usually a bit tricky.
20:48:04 <nejucomo> How can I ask lambdabot which version of a given module it uses?
20:48:28 <interferon> kmc: Yeah I was coming to that conclusion while discussing this :)
20:48:30 <Cale> elzurk: If you want to make it lazily cause the execution of getPage to occur as elements of the list are demanded, you'll want unsafeInterleaveIO
20:48:34 <kmc> interferon, i'm picturing a type like IO (Request -> IO Response)
20:48:43 <kmc> this action initializes the shared data store for caching
20:48:53 * hackagebot improve 0.2.1 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.2.1 (TomHawkins)
20:48:53 <kmc> and returns a function for servicing requests
20:48:57 <kmc> which, the user doesn't even have to care
20:49:01 <interferon> kmc: So would it be correct to keep the cache in an TVar?
20:49:08 <kmc> whether there are persistent threads or they're spun up on demand
20:49:21 <kmc> it would be correct if the code is correct and does what you want
20:49:27 <kmc> i'm not sure what you mean by that question
20:49:27 <interferon> kmc: Cool, that makes sense
20:49:33 <kmc> it's a reasonable design, yes
20:49:46 <kmc> the choice of STM versus other stuff like MVar depends on a few things
20:49:56 <interferon> kmc: I guess I mean: are there better primitives for a concurrently accessed map?
20:50:04 <interferon> Better/other
20:50:07 <kmc> it affects coding style and also performance
20:50:17 <Cale> elzurk: If x is any IO action, then unsafeInterleaveIO x is an IO action which finishes immediately, but whose result is a magical value whose evaluation causes the execution of x
20:50:23 <kmc> well your alternatives to TVar are at least IORef and MVar
20:50:28 <elzurk> Cale, what approach would you suggest for something like what I'm trying to do?
20:50:36 <kmc> IORef has an atomic modify operation which is sometimes the fastest thing
20:50:45 <Cale> elzurk: I'm not really 100% sure about what it is that you're trying to do.
20:50:51 <kmc> MVar is useful if you need to block
20:51:00 <elzurk> I'm trying to get a "stream" of StackOverflow entries
20:51:01 <nejucomo> Is there a more elegant way to translate an arbitrary parser state to () than this?  http://codepad.org/lmeTkbfN
20:51:07 <kmc> TVar is useful if you want the performance characteristics of optimistic lock-free code
20:51:18 <kmc> and/or if you want to write in transactional style
20:51:22 <kmc> and get more composable code that way
20:51:31 <elzurk> the deal is that I can get then only a page at a time, due to paging on their side
20:51:50 <Chaze> @pl (\(a,b)->(b,a))
20:51:50 <lambdabot> uncurry (flip (,))
20:51:59 <elzurk> So, I'd like to have something that is akin to saying getStream while predicate is true
20:52:29 <elzurk> so, get top 12 entries, or get latest 41 entries, or get entries older than x date
20:52:51 <kmc> i've found that closure over functions + closure over actions + lightweight threads is a *really* powerful model
20:52:53 <Cale> Well, that much isn't so hard.
20:53:11 <kmc> you can build very complex arrangements of threads, and carefully control how they interact in order to ensure correctness
20:53:17 <kmc> in very little code
20:53:33 <kmc> and without exposing concurrency in the API
20:53:37 <elzurk> my test on hpaste was trying to do what I end up doing, but without doing the actuall http calls
20:53:38 <interferon> kmc: Yeah I'm definitely thinking that you're right about dropping the persistent thread and just bringing them up on demand
20:53:45 <interferon> kmc: Trye
20:53:46 <Cale> The unrestricted one with no termination condition is harder, because it has to be lazy, and defining new lazy IO primitives requires trickery.
20:54:00 <kmc> interferon, i like the design where you can change this detail without affecting so much other code
20:54:05 <kmc> maybe you'll find it matters for performance
20:54:16 <nejucomo> Ah, so the code I pasted does not type check, so I'm back to my original question:  How do I use any parser state type other than () ?
20:54:23 <elzurk> so, you would suggest having a function that takes a predicate, instead of the unrestricted one?
20:54:25 <kmc> there is some cost to spawning a thread in GHC's runtime, though far less than the cost of spawning an OS thread
20:54:35 <Cale> elzurk: That should be quite doable, anyway
20:56:05 <elzurk> been hitting my head against the wall, because at some level it seems that it having an infinite stream of data I get from calling out to the web should be doable
20:56:10 <nejucomo> Here's a paste with a minimal module and the type error exemplifying my problem: http://codepad.org/GVVBqtm1
20:56:26 <Cale> Well, another approach...
20:57:18 <Cale> data IOList a = Nil | Cons a (IO (IOList a))
20:57:34 <elzurk> passing in the predicate starts to feel too much like doing while loops again
20:58:19 <kmc> Cale, if we generalize that to Monad m, do we get ListT?  Or is it the wrong way around?
20:58:21 <Cale> elzurk: Some people would use Iteratees for this.
20:58:37 <Cale> kmc: Something like that. It's not really a monad.
20:59:38 <qun> hello, I'm a newbie in haskell community, I'm trying to compile haskell from source in Fedora 10. The error message is below, do you have any idea what's going wrong? http://hpaste.org/42231/make_error_message
20:59:40 <elzurk> I'll have a look at them. That sounds like the right department, anyway.
21:00:21 <kmc> qun, Haskell is not a program, it's a language.  you can't compile a language
21:00:26 <kmc> you're compiling ghc, a haskell compiler
21:00:34 <kmc> and if you're a beginner, you probably shouldn't compile ghc yourself
21:00:42 <Cale> qun is trying to compile ghc
21:00:45 <Cale> qun: Don't compile ghc yourself
21:00:59 <kmc> qun, get the Haskell Platform from http://hackage.haskell.org/platform/
21:01:00 <elzurk> Cale: thanks for your time!
21:01:12 <Cale> qun: Get the binary ghc, or the Haskell platform, yeah.
21:01:21 <monochrom> wait, is fedora 10 very outdated?
21:01:22 <qun> Cale: ok... I've already install ghc from 'yum'
21:01:23 <kmc> Fedora 13 and 14 are supported
21:01:37 <qun> kmc: maybe my platform is way too old..
21:01:42 <Cale> qun: Save worrying about compiling ghc yourself for when you're actually adding code to it :)
21:01:57 <kmc> i built Haskell Platform 2009 dot something on RHEL4
21:01:58 <Cale> The generic linux binary of GHC should work
21:01:59 <kmc> but it was not fun
21:02:00 <interferon> kmc: Thanks for the help
21:02:07 <Chaze> is this the way to lift a function into the maybe monad? ">>= Just . (+ 4)"
21:02:09 <Cale> I usually just get the generic linux binary, and then install cabal-install
21:02:16 <qun> Cale: maybe you're right, what i'm worrying about is its language itself.
21:02:20 <applicative> nejucomo, if your type is GenParser tok () t then you cant set the state to (), it's already () since () is the only ()
21:02:23 <Cale> Chaze: fmap (+4)
21:02:28 <Cale> Chaze: or liftM
21:02:33 <kmc> fwiw Fedora 10 was released Nov 25 2008
21:02:37 <kmc> so not nearly as old as RHEL4
21:02:59 <nejucomo> applicative: That doesn't make sense to me, because "setState ()" should type check.
21:03:23 <qun> my linux box was installed years ago and then its CD-ROM drive was removed then...
21:03:28 <nejucomo> But my question isn't really about (), it's about how I can compose parsers with different state types.
21:03:57 <qun> thank your guys for your info.
21:04:02 <Cale> qun: As for the actual build error, it looks like the unix package isn't installed somehow.
21:04:04 <nejucomo> -or more specifically, how can I ever have any parser state type *other than* (), since parse requires a "GenParser Char () t" ?
21:04:07 <monochrom> oh you can setState (), it's just useless
21:04:21 <Cale> qun: It might be that the Fedora people separated the unix library from the ghc package.
21:04:25 <freedrull> how can i get pure values out of my user defined state in parsec? (i.e. without it having a GenParser tok MyState a constructor)
21:04:32 <Cale> (I know that the Debian/Ubuntu people do that)
21:04:46 <nejucomo> freedrull: I think you want "getState".
21:05:06 <qun> Cale: maybe it's separated... then I tried to install it via cabal, it says: "cabal: cannot configure unix-2.4.1.0. It requires base >=4.2 && <4.4"
21:05:17 <qun> oops, lots of error messages for me..
21:05:18 <qun> heh
21:05:23 <freedrull> nejucomo: well that returns GenParser tok st st...i just want the "st"...
21:05:24 <Cale> qun: ghc --version
21:05:33 <Cale> qun: which version of ghc do you have right now?
21:05:36 <qun> version 6.10.1
21:05:39 <monochrom> runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
21:05:49 <nejucomo> Oh.  Doh.
21:05:54 <qun> Cale: I installed it from yum install ghc.
21:06:02 <nejucomo> Ok, I lose.  I thought there was only parse.
21:06:03 <monochrom> :)
21:06:08 * nejucomo looks up the source code to parse.
21:06:17 <Cale> qun: Oh, okay, I think base-4.2 requires a newer GHC.
21:06:43 <nejucomo> freedrull: I suspect what you want isn't possible (or at least not intended by parsec).  What's the use case?
21:06:52 <qun> Cale: thanks, I should upgrade my distribution and try again..
21:07:06 <Cale> qun: Or just install the binary ghc
21:07:12 <kmc> i really doubt Fedora 10 is too old
21:07:27 <qun> kmc: i think so..
21:07:28 <kmc> like i said, i got Haskell Platform working last year on RHEL4, from early 2005
21:07:32 <Cale> http://www.haskell.org/ghc/download_ghc_6_12_3#x86linux
21:07:36 <qun> Cale: thanks. I'll try it.
21:07:37 <kmc> just get the generic binary ghc
21:07:44 <monochrom> I concur.
21:07:47 <nejucomo> freedrull: The way to use getState is within a Monad composition, ie:  do { string "foo"; fooCount <- getState; setState (fooCount + 1); return 42; }
21:07:54 <freedrull> nejucomo: well, i need to get values out of my user state...because my main function is of type IO ()
21:08:32 <Chaze> > let test = liftM (`divMod` 10) Just -- what's wrong here? 
21:08:33 <lambdabot>   not an expression: `let test = liftM (`divMod` 10) Just -- what's wrong her...
21:09:07 <Chaze> :t liftM (`divMod` 10) Just
21:09:08 <lambdabot> forall a. (Integral (Maybe a)) => a -> (Maybe a, Maybe a)
21:09:11 <nejucomo> freedrull: So you pass your parser to runParser or parse to get the parse result.
21:09:17 <monochrom> runParser (do  ..... x<-your_stuff; y<-getState; return (x,y) ) init_state "" "hello"
21:09:24 <freedrull> nejucomo: runParser
21:09:45 <nejucomo> What monochrom said.
21:10:04 <freedrull> yes :3
21:10:08 <Cale> Chaze: That's in the function monad because Just is a function.
21:10:37 <Chaze> Cale: i just want a version of divMod which always wrappes in Just
21:10:53 <Chaze> which is my ignorant concept of 'lifting it to the maybe monad'
21:10:57 <Chaze> am i way off?
21:11:17 <Cale> Chaze: divModJ x y = Just (divMod x y) ?
21:11:47 <Chaze> that's (Just . divMod) right?
21:11:52 <monochrom> no
21:11:58 <Cale> It's (Just .) . divMod
21:11:58 <kmc> no, because (.) only composes one-argument functions
21:12:11 <Cale> or fmap Just . divMod
21:12:19 <kmc> :t let f (.:) g = \x y -> f (g x y) in Just .: divMod
21:12:20 <lambdabot>     Occurs check: cannot construct the infinite type:
21:12:20 <lambdabot>       t = (t1 -> t2 -> t3) -> t1 -> t2 -> t
21:12:20 <lambdabot>     Probable cause: `f' is applied to too few arguments
21:12:21 <Cale> or fmap (fmap Just) divMod
21:12:38 <Chaze> now i'm entirely confused
21:12:52 <Cale> Well, let's have a look
21:13:02 <Cale> ((Just .) . divMod) x y
21:13:06 <monochrom> confusion is good. incentive to throw away wrong assumptions
21:13:13 <Cale> = (Just .) (divMod x) y
21:13:22 <Cale> = (Just . divMod x) y
21:13:30 <Cale> = Just (divMod x y)
21:13:30 <kmc> yes
21:13:46 <kmc> it is great when you have five rules in mind and then you get confused and then you end up with one rule
21:14:05 <freedrull> gah i guess my main problem is i need to access the state in in my main :: IO () function
21:14:10 <Cale> Now, what would happen with only one (.)?
21:14:23 <Cale> (It's a type error, but let's forget about that, and reduce anyway)
21:14:26 <djahandarie> Hell!
21:14:31 <nejucomo> freedrull: Can you explain your use case?
21:14:33 <Cale> (Just . divMod) x y
21:14:43 <Cale> = Just (divMod x) y
21:14:51 <Cale> ^^ oops! too many parameters to Just
21:15:09 <Chaze> :t Just . divMod
21:15:10 <lambdabot> forall a. (Integral a) => a -> Maybe (a -> (a, a))
21:15:18 <nejucomo> The only available way to access your parser user state is to return it as a parse result.  You cannot access intermediate states (but you can of course record intermediate info in the state).
21:15:26 <Chaze> I see, there can never be a Maybe (a -> (a, a))
21:15:32 <Cale> Heh, it's not a type error with lambdabot's generalised (.)
21:15:33 <Cale> because
21:15:35 <Cale> :t (.)
21:15:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:15:55 <Cale> There can certainly be a Maybe (a -> (a,a))
21:16:00 <Cale> but it's still not what you want
21:16:29 <Chaze> how would you define a Maybe (a -> (a, a)) ?
21:16:37 <Cale> Just (\x -> (x,x))
21:16:46 <Cale> for example
21:16:56 <Cale> :t Just (\x -> (x,x))
21:16:57 <lambdabot> forall t. Maybe (t -> (t, t))
21:17:21 <Cale> :t Just (\x -> divMod x 10)
21:17:25 <lambdabot> forall a. (Integral a) => Maybe (a -> (a, a))
21:17:46 <freedrull> nejucomo: thanks... let me see if i can formulate my question more clearly...
21:17:53 <Cale> :t Just (divMod 10)
21:17:54 <lambdabot> forall t. (Integral t) => Maybe (t -> (t, t))
21:18:01 <nejucomo> you can always codepad.org it.  ;-)
21:18:50 <djahandarie> I'd like to see that alternative to > added which just evaluates Haskell with a fairly vanilla environment
21:18:59 <djahandarie> Rather than crazy lambdabot times
21:19:08 <nejucomo> If you are persistent, like me, then after banging your head against the type system for a long time and then monochrom will point out there's already a function that does what you want with the right type.
21:19:30 <freedrull> haha hopefully there is..
21:19:42 <monochrom> that's just because I'm encyclopedic
21:20:11 <applicative> @type Just (join (curry id))
21:20:11 <lambdabot> forall b. Maybe (b -> (b, b))
21:20:14 <djahandarie> I didn't realize you could use that adjective to describe people
21:20:45 <applicative> his knowledge is encyclopedic?
21:20:49 <monochrom> there are more. I'm also unificating
21:20:53 <djahandarie> encyclopedimaniac
21:21:14 <djahandarie> lol
21:22:32 <Chaze> Cale: in fact, i'm even more lost on my actual goal: write a version of divMod that is Nothing when fst (divMod 10 n) == 0
21:22:50 <Chaze> i am sure there's some really elegant way in do-notation, or similar
21:24:01 <Cale> foo n | q == 0 = Nothing | otherwise = Just (q,r) where (q,r) = divMod 10 n   ???
21:24:07 <monochrom> dm x y = do {guard (q/=0); return answer} where answer@(q,r) = divMod x y
21:24:56 <monochrom> mine is too general
21:25:16 <Chaze> monochrom: i was wondering how Maybe is inferred there
21:25:18 <monochrom> s/return/Just/ and it will be exactly right
21:25:34 <Chaze> nice
21:25:35 <Chaze> thanks
21:26:09 <freedrull> nejucomo: i will paste some code... http://hpaste.org/42232/parser
21:26:26 <djahandarie> Chaze, it will infer the right type if your Maybe constraint is elsewhere
21:27:01 <djahandarie> That function would just have (Monad m) => ... -> m a  instead of ... -> Maybe a
21:27:02 <freedrull> i need to pass (ins st) to toBits....so i was thinking if i could write a function that just returns the ParseState i could write a function to do that...
21:27:15 <djahandarie> Thankfully return in the Monad instance for Maybe is Just
21:27:23 <monochrom> MyParser = ?
21:27:27 <freedrull> (line 37)
21:27:36 <freedrull> monochrom: ahh ill add that
21:28:12 <Chaze> monochrom: is there a way to remove the arguments x and y from that definition?
21:28:34 <freedrull> http://hpaste.org/paste/42232/parser_annotation#p42233
21:28:49 <monochrom> yes but depends on what you want to plug into x,y
21:29:21 <Chaze> monochrom: i want to pass it to unfoldr
21:29:37 <Chaze> in the end, it should convert an integer to a list of digits
21:30:20 <nejucomo> freedrull: The case in line 26 has your parser state, so you could return it from parseFile by changing the return type to: IO ParseState
21:30:43 <monochrom> dm x = do {guard (q/=0); Just answer} where answer@(q,r) = divMod x 10
21:30:46 <nejucomo> However, your parse state will always be equal to the starting state in this example (because you never use setState, only getState).
21:30:54 <monochrom> you absolutely want to keep x as parameter.
21:31:51 <monochrom> no reason why parseFile should end as IO ().
21:32:47 <nejucomo> Right, the type IO () means main cannot access any computations within parseFile.
21:33:20 <nejucomo> Does all of this make sense?
21:33:35 <freedrull> i think so
21:34:09 <monochrom> I would parseFile :: MyParser ParseState -> FilePath -> IO (Either ParseError ParseState)
21:34:23 <monochrom> Let the main do the casing.
21:34:37 <freedrull> oh ok that makes sense
21:35:36 <monochrom> The art of pushing the problem elsewhere.
21:37:34 <freedrull> then just return the result of runParser? thats not type IO though..
21:38:20 <monochrom> do { input <- readFile fname; return (runParser p initialState "" input) }
21:38:50 <monochrom> in fact, do { input <- readFile fname; return (runParser p initialState fname input) }, that's what "SourceName" is for
21:39:17 <freedrull> i using fname instead of "" before but it didnt seem to matter..
21:39:35 <freedrull> is that just for printing line numbers of errors 
21:39:42 <monochrom> it only shows when there are parser errors
21:39:46 <monochrom> yes
21:39:49 <freedrull> oh okay :3
21:43:00 <freedrull> okay so the new parseFile is working now...thanks
21:43:10 <monochrom> \∩/
21:43:43 <freedrull> so now i can check if the result is Right x, in main, and if so i can access the fields in ParseState?
21:43:53 <monochrom> yes
21:44:10 <freedrull> awesome
21:50:17 <freedrull> cool its working, thanks for your help!
21:50:31 <monochrom> you're welcome
22:00:30 --- mode: holmes.freenode.net set +o ChanServ
22:21:16 <EvanCarroll> how do I take a slice of ++
22:21:16 <EvanCarroll> or any typically infix opprforthat matter
22:21:16 <kmc> slice?
22:21:16 <EvanCarroll> (`div` 5) vs (5 `div`)
22:21:16 <kmc> (5 ++) and (++ 5)
22:21:56 <EvanCarroll> easy enough
22:22:00 <EvanCarroll> how would i write this point-free
22:22:02 <EvanCarroll> (\acc x -> acc ++ [x])
22:22:12 <kmc> @pl \acc x -> acc ++ [x]
22:22:12 <lambdabot> (. return) . (++)
22:22:28 <EvanCarroll> how the hell does that work
22:22:37 <EvanCarroll> God, I want that bot in my ghci.
22:22:49 <kmc> @hackage goa
22:22:49 <lambdabot> http://hackage.haskell.org/package/goa
22:23:00 <EvanCarroll> yes, but it aparently doesn't work
22:23:00 <EvanCarroll> per that page.
22:23:06 <kmc> maybe you can fix it
22:23:15 <kmc> also ghci can execute shell commands
22:23:19 <EvanCarroll> I'd even like to know why the source it displays makes more sense then the source i findin the prelude.
22:23:40 <kmc> probably because lambdabot is reading its source from a .txt file which is explicitly compiled for teaching purposes
22:23:44 <kmc> (and full of half-truths)
22:24:15 <EvanCarroll> I'd be interested in knowing why they're only half-truths, but it sure is easy to understand
22:24:31 <kmc> i can't think of a good example now
22:25:09 <kmc> :t \acc -> (acc ++) . pure
22:25:10 <lambdabot> forall a (f :: * -> *). (Monoid (f a), Applicative f) => f a -> a -> f a
22:25:26 <kmc> :t \acc -> (acc Prelude.++) . pure
22:25:27 <lambdabot> forall a. [a] -> a -> [a]
22:26:33 <kmc> sleep, bbl
22:27:03 <EvanCarroll> how does (. return).(++) work
22:28:33 * hackagebot forkable-monad 0.1.1 - An implementation of forkIO for monad stacks.  http://hackage.haskell.org/package/forkable-monad-0.1.1 (DavidAnderson)
22:41:40 <duckinator> how can i join an array of strings with spaces? as in, ["this", "is", "a", "test"] -> "this is a test"
22:42:34 <duckinator> i feel silly asking such a simple question, but i can't figure it out. probably related to it being 1:40am :P
22:43:19 <duckinator> ...of course, i find it after asking. "unwords" :P
22:43:22 <BrianHV> > intercalate " " ["this", "is", "a", "test"]
22:43:23 <lambdabot>   "this is a test"
22:43:32 <BrianHV> unwords is cool too...
22:44:28 <duckinator> ahh, thank you though. i'm sure intercalate will probably come in handy sometime :)
22:45:38 <duckinator> in case you're wondering, this is for an insanely bad attempt at an irc bot. it's how i teach myself new languages for most things (see: "everything except assembly and languages with no networking abilities")
22:50:02 <dmwit> IRC bots are fun. =)
22:50:15 <dmwit> It's such a nice, simple protocol.
22:50:51 <duckinator> dmwit: yea, and on the note of 'simple protocol', either i'm doing something wrong or parsing isn't haskell's strong suite ;) ..or both
22:51:57 <dmwit> Wow, you're doing something wrong.
22:52:11 <dmwit> Parsec is about the nicest parser library I know of.
22:52:46 <duckinator> dmwit: i'm not using a parser library of any sort, trying to do as much of it myself as i can for learning purposes :P
22:53:12 <duckinator> dmwit: i figured i'd make it as generic as i could... following the pattern of "[:prefix ]command [[:]args]"... i have prefix/command handled fine, args is a bit of a trip due to the potential for a lack of a colon :(
22:53:43 * mtnviewmark is considering the irony that he's writing a complex Makefile to build the Mac OS X installer package for Haskell Platform
22:53:54 <mtnviewmark> any know of some Haskell based replacements for Make?
22:57:28 <tg_> cabal-make?
22:58:36 <mtnviewmark> no, I don't need to build just haskell code -- I'm looking for something more general
22:59:01 <mtnviewmark> most of what has to happen is various commands in the shell to create files, directories, archives, etc...
22:59:02 <duckinator> 'night
23:04:29 <dcoutts_> mtnviewmark: there's a bunch of shell-like combinator libs
23:04:48 <dcoutts_> there's not a decent dependency based one however afaik
23:04:56 <mtnviewmark> didn't someone present something in this space at Haskell Symposium this year?
23:05:07 <dcoutts_> not something with code available :-)
23:05:14 * mtnviewmark rummages around Google
23:05:25 <dcoutts_> mtnviewmark: yes, Neil did, but no code
23:05:27 <mtnviewmark> ah, that's right - it was cool but not available
23:05:29 <mtnviewmark> sigh
23:05:35 <tg_> lol
23:05:42 <mtnviewmark> okay - back to the Makefile then....
23:06:04 <dcoutts_> mtnviewmark: and I've got an implementation but no code, it's still in my head :-)
23:06:44 * mtnviewmark is deeply fighting the urge to shave yaks....
23:06:55 <dcoutts_> mtnviewmark: don't do it, it's harder than it looks
23:07:31 <mtnviewmark> heh
23:08:19 <dcoutts_> especially if you want something general, flexible and correct
23:10:12 <tg_> from my understanding of seth godin's blog result for 'shaving yaks', his urge would imply he wants to replace make?
23:10:34 <dcoutts_> tg_: right
23:10:57 <dcoutts_> but we've already got a dozen poor reimplementations of make :-)
23:11:14 <tg_> hm
23:12:49 <mtnviewmark> well, I want to build an installer for Haskell Platform, but before that I need to build a Makefile, but before that I need to build a better Make, but before that I need dependency analysis package, but before that I need a generalized graph library, ...  and pretty soon your shaving yaks!
23:13:18 <mtnviewmark> you're
23:14:24 <tg_> well some sort of depanalysis package just got release today?
23:14:32 <tg_> i think yaks should be left alone
23:14:52 <tg_> but to me, the shaving yaks thing sounds a lot like http://www.structuredprocrastination.com/
23:14:59 <mtnviewmark> exactly! so ... back to the mysteries of GNUMake for me....
23:15:17 <tg_> mtnviewmark: i can suggest totally other ways to do it
23:15:27 <tg_> ie, using lenses (and possibly the new symmetric lens package)
23:15:42 <tg_> which is one way the puppet package (used for configuration change & mgt) can do make-like things
23:15:44 <tg_> at an OS level
23:16:02 <tg_> which puppet (written in ruby) does through an interface to augeas (written in C)
23:16:24 <tg_> s/symmetric lens package/$1$2 paper/
23:16:36 <mtnviewmark> clearly - first we'll have to re-write those in Haskell first
23:16:55 <tg_> mtnviewmark: wel, I view that route as fundamentally different than what Make does
23:17:03 <tg_> lenses should exist in Haskell
23:17:16 <tg_> http://hackage.haskell.org/package/pointless-lenses
23:17:28 <mtnviewmark> I'm jokin' -- really, I'm going to stay focused - we need alpha installers in a week or so !
23:17:48 <tg_> this is for platform?
23:18:09 <tg_> i mean, officially
23:18:09 <mtnviewmark> yes
23:18:16 <tg_> not just your attempt at something
23:18:20 <mtnviewmark> correct
23:18:33 <mtnviewmark> I am the maintainer of the Mac OS X installer
23:18:44 <tg_> oh. OSX, too.
23:19:22 <mtnviewmark> er, OSX, only.  that is, I'm only the maintainer of the Mac OS X Haskell Platform installer
23:19:47 <tg_> yeah
23:20:19 <tg_> I was recounting the differences between OSX and all the linuxes when using a tool like puppet
23:20:26 <tg_> and empathizing a bit
23:21:04 <tg_> anyway, best of luck
23:21:10 <mtnviewmark> thanks
23:26:54 <mjrosenb> does anyone in here use snap?
23:30:22 <gienah> mtnviewmar: maybe it might help with packaging haskell platform on mac to look at how it is packaged on other operating systems, this is how I did it on solaris:
23:30:31 <gienah> http://pkgbuild.svn.sourceforge.net/viewvc/pkgbuild/spec-files-extra/trunk/SFEghc-haskell-platform.spec
23:31:02 <gienah> the fedora way of doing things is described in: http://fedoraproject.org/wiki/Packaging:Haskell
23:32:29 <mtnviewmark> thanks, I'll look at those for comparison -- I've already got the installer building -- I'm in the cleaning up the final nits phase (things like a good docs landing page, and uninstaller options)
23:32:40 <gienah> mjrosenb: snap has its own channel: #snapframework
23:33:12 <mjrosenb> gienah: i know, I asked a question in there 3 hours ago
23:33:44 <mjrosenb> gienah: to say the least, #haskell  is a bit higher traffic
23:34:18 <mtnviewmark> gienah - how do you generate that pkgbuild file? by hand? and I guessing you've had to hand build everything first?
23:34:26 <mjrosenb> gienah: i would not be suprised if at any given moment, the number of people looking at the channel in #haskell who know how to use snap is more than the corresponding number for #snapframework.
23:35:12 <gienah> mtnviewmark: yes the solaris spec is all built by hand, not a very smart way of doing things but it does make it easy to follow since there are not really any macros called
23:36:08 <mtnviewmark> ah - I've got the Mac OS X installer building from scratch via a Makefile --- just put in the haskell platform .cabal file at the top.... out pops an installer at the bottom
23:36:21 <mtnviewmark> mjrosenb - I've used snap a bit
23:36:30 <mtnviewmark> but only a bit --- what's the question?
23:36:32 <dcoutts_> mtnviewmark: yay!
23:37:21 <mtnviewmark> dcoutts_: it even downloads the right GHC distribution at the start if it isn't in the build tree
23:37:23 <mjrosenb> mtnviewmark: i'd like to be able to perform some IO when a page request comes in
23:37:42 <mjrosenb> and the only documentation that i can find is "we use iterators for IO"
23:38:29 <mtnviewmark> ah, no, it is easier than that
23:38:47 <mtnviewmark> the Snap monad is an instance of MonadIO
23:38:59 <mjrosenb> oh really?
23:39:05 <mtnviewmark> so you can use liftIO to take any IO computation into the Snap monad
23:39:32 <mtnviewmark> yup!
23:39:51 <mjrosenb> this seems like it would be useful information to put into the 10 minute tutorial that they have
23:42:04 <mtnviewmark> so, for example, in a form handler I have: https://gist.github.com/735922
23:43:22 <mjrosenb> @hoogle liftIO
23:43:22 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
23:48:41 <mtnviewmark> wow - who did the Fedora packaging - it is very complete and nicely documented
23:49:11 <mjrosenb> hrmm, it looks like after importing Data.Bytestring, I cannot see join.  Is this some trickery of Cabal?
23:49:54 <gienah> mtnviewmark: I don't know, it is good documentation on it
23:50:10 <mtnviewmark> that doesn't seem likely.... so you import Data.Bytestring and now you get an error on using join?
23:50:32 <dcoutts_> Data.Bytestring doesn't export join
23:50:53 * hackagebot generic-deriving 0.3.1 - Generic programming library for generalized deriving.  http://hackage.haskell.org/package/generic-deriving-0.3.1 (JosePedroMagalhaes)
23:51:09 <Axman6> good to know there's some Snap users around, we're about to start using it for an internal project
23:52:29 <Axman6> any advantages of using heist over say Blaze?
23:52:50 <mjrosenb> dcoutts_: it seems to be documented?
23:53:54 <mjrosenb> oh, this documentation is from hugs
23:53:59 <mjrosenb> it must be ancient :-o
23:54:12 <dcoutts_> oh, only 4 years old :-)
23:57:03 <gienah> mtnviewmark: for the "good docs landing page", if the libraries are installed in a location other than where the ghc libraries are, then the gen_contents_index script could be copied and modified something like:
23:57:11 <gienah> http://hpaste.org/42236/gen_contents_index
23:57:53 <mtnviewmark> already have equivalent in my Makefile
23:58:10 <gienah> neat
23:58:52 <mtnviewmark> though I derive all the places to gather the docs from the actual package database -- 
23:59:06 <mtnviewmark> which is actually a useful general script I've been meaning to publish one day
23:59:42 <mtnviewmark> but yes, the Mac OS X install includes full Haddock for all modules, GHC & Platform, and all with source pages as well
