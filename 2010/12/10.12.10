00:00:45 <gienah> that's neat (my dumb solaris spec does as well, even though it is all manual)
00:01:33 * mtnviewmark >>= bed
00:01:37 <gienah> on gentoo it is controlled with use flags: doc hscolour
00:01:39 <gienah> goodnight
00:05:39 <Chaze> i often want to pair all the stuff from a list a, with all the stuff from list b. like this:
00:05:39 <Chaze> > sequence ["abc","12"]
00:05:40 <lambdabot>   ["a1","a2","b1","b2","c1","c2"]
00:06:07 <Chaze> but what if i don't just want to concatenate lists but supply the 'zipping' operation?
00:11:33 <dibblego> Chaze, use zip
00:11:43 <dibblego> @type zip
00:11:45 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:12:02 <Chaze> that matches just pairs at the same position
00:12:25 <dibblego> Chaze, what do you want exactly?
00:12:38 <Chaze> the same as my sequence example up there
00:12:54 <dibblego> you said a "list a" and a "list b"
00:13:01 <dibblego> then you proceeded to use only one list
00:13:06 <Chaze> abc is list a
00:13:10 <Chaze> 12 is list b
00:13:19 <dibblego> and you want?
00:13:37 <Chaze> ["a1","a2","b1","b2","c1","c2"]
00:13:44 <dibblego> sequence
00:13:55 <Chaze> but instead of concatenation, i want to supply the operation
00:14:11 <dibblego> and you want?
00:14:12 <Chaze> to perform on ('a','1')-like tuples
00:14:45 <dibblego> that would depend on the number of elements in the outer list right?
00:15:44 <Chaze> in my case the 'outer' list has just 2 elements, but yeah.. a more general version would match arbitrary number of lists
00:16:06 <dibblego> perhaps you want liftAN for som value of N
00:20:58 <Chaze> i wouldn't know where the permutating would come from then
00:21:09 <Chaze> in case of sequence, it is simply the nature of the list monad
00:21:51 <dibblego> Chaze, how about you write the function out long-hand then we'll try to tidy it up with existing library functions
00:23:26 <shachaf> > liftA2 (,) "abc" "12"
00:23:27 <lambdabot>   [('a','1'),('a','2'),('b','1'),('b','2'),('c','1'),('c','2')]
00:23:44 <Chaze> yep, that's it
00:23:47 <Chaze> :t liftA2
00:23:48 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
00:23:57 <Chaze> what does A mean+
00:24:07 <dibblego> Applicative
00:24:31 <dibblego> so you do want liftAN for some value of N right?
00:24:59 <shachaf> Chaze: You can use liftM2 if you want "the nature of the list monad". :-)
00:25:38 <Chaze> well, liftA2 is exactly what i want, in this case i wanted liftA2 ($)
00:26:00 <dibblego> that's just (<*>)
00:26:06 <dibblego> @type (<*>)
00:26:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:26:28 <dibblego> @type liftA2 ($)
00:26:29 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
00:26:31 <dibblego> @type liftA2 id
00:26:32 <resistor> anyone able to help a new(ish) haskeller decode some GHC type errors?
00:26:33 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
00:26:53 <shachaf> resistor: That's quite likely. But only if they know what those type errors are.
00:27:15 <resistor> source is here: http://haskell.pastebin.com/Jrc6BVTb
00:27:24 <resistor> errors are here: http://pastebin.com/LGw9kqx5
00:27:35 <Chaze> <*>.. interesting
00:28:06 <Chaze> that was what i was building
00:28:22 <Chaze> how do you pronounce it? :)
00:28:28 <dibblego> Chaze, there is a paper called Applicative Programming With Effects that goes into detail about this function
00:28:34 <dibblego> I pronounce it "apply"
00:28:47 <resistor> i was trying to implement comonadic arrays with in-place arrays, but i can't get the bloody types to work out with STArrays
00:35:26 <Chaze> is this something special? produce f x = f x : produce (f x)
00:35:40 <Chaze> produce f x = f x : produce f (f x)
00:36:54 <Chaze> oh, i messed up
00:37:01 <Cale> It's similar to iterate
00:37:10 <Cale> > iterate (*2) 1
00:37:11 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
00:38:05 <minsa> > iterate (*3) 3
00:38:06 <lambdabot>   [3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,1434...
00:38:07 <Chaze> i forgot a concatMap somewhere in there
00:38:35 <minsa> > iterate (*3) 1
00:38:36 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
00:40:10 <Chaze> more like this
00:40:10 <Chaze> produce _ [] = []
00:40:10 <Chaze> produce f x = let n = concatMap f x in n : produce f n
00:43:53 <Chaze> as opposed to iterate, this should produce finite lists for some f - although i'm not sure if i'm thinking correctly
00:44:59 <Cale> Chaze: ah, okay
00:46:30 <Cale> Chaze: So you can think of that as giving the levels of a breadth first search, I suppose
00:46:50 <Chaze> yeah, it should be kinda like that
00:48:26 <sgtarr> i prefer an out-of-breath search myself.
00:51:41 <sgs> Hi, why can I do [0..4] => [0,1,2,3,4] but the other way around [4..0] gives an empty list? I know I can to [4,3..0] but is there any reason I should know why it's done this way? 
00:54:22 <CindyLinz> > [4,3..0]
00:54:24 <lambdabot>   [4,3,2,1,0]
00:56:24 <sgs> I know. But why not [4..0]?
00:58:03 <CindyLinz> sgs: I'm just trying ^^|
00:58:09 <sgs> ok :)
01:00:44 <kurenai> good question, sgs. you should probably ask it a little bit later, when there's more gurus around :)
01:01:52 <sgs> Yes. I'll try that. 
01:02:44 <ManateeLazyCat> Hi all. :)
01:46:59 * hackagebot cabal-sort 0.0.2.1 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.2.1 (HenningThielemann)
02:34:27 <kkkzzz> who am i
02:34:45 <kkkzzz> zzz
02:34:46 <kkkzzz> kkk
02:35:51 <Jafet> If I make a port of plan 9 and improve its shell, I'll be sure to call it irc
02:38:07 <Eduard_Munteanu> Any idea what I should use to pretty-print a binary tree?
02:43:35 <Jafet> As a really wide ascii-art graph?
02:44:29 <Eduard_Munteanu> Jafet: yeah. Or let's say the root is leftmost and leaves rightmost.
02:44:47 <Jafet> Print subtrees, join them horizontally, print the current node centered above
02:45:17 <Jafet> Text.PrettyPrint has some primitives that could save time on that
02:45:18 <quicksilver> it's simpler to code (but uglier to look at) to print one leaf per line of text
02:45:26 <quicksilver> and indent appropriately
02:45:38 <quicksilver> with or without ascii art ( +----- Leaf 1 )
02:45:59 <Jafet> Depending on what "binary tree" means, this or that would be uglier
02:46:31 <Eduard_Munteanu> It's really a binary tree, like data Tree a = Leaf a | Fork a (Tree a) (Tree a)
02:47:29 <danr> Eduard_Munteanu: what about the empty tree?
02:47:50 <Eduard_Munteanu> Well, it's never empty.
02:48:13 <danr> ok :)
02:48:24 <Jafet> Sure, sure. But what does the tree represent?
02:48:39 <Eduard_Munteanu> Jafet: it's a Huffman coding tree.
02:49:14 <Jafet> If a is long Strings, quicksilver's line-by-line printing will probably look least ugly (and more compact)
02:49:29 <Eduard_Munteanu> Not much data inside, tree HMTree = Tree Symbol, where data Symbol = Sym Word8 Count | Phi Count
02:49:41 <Eduard_Munteanu> s/tree/type/
02:49:52 <Jafet> But in your case, a is just one bit or something
02:50:34 <Eduard_Munteanu> Not really, each edge is a bit. 'a' is either a symbol with associated count, or a virtual symbol.
02:50:35 <Jafet> You could alternatively just hand it off to graphviz and let it do whatever it does
02:50:52 <Eduard_Munteanu> Hm, that sounds nice. I'll look for graphviz bindings.
02:51:03 <Eduard_Munteanu> I don't really need ASCII pretty-printing.
02:51:04 <Jafet> Or whatever the native haskell graphing package is
02:51:14 <Eduard_Munteanu> Native?
02:52:49 <Jafet> Injuns
02:54:07 <quicksilver> there are haskell bindings for graphviz
02:54:11 <quicksilver> and maybe other things.
02:54:22 <Jafet> There doesn't seem to be one. Hm
02:55:20 <quicksilver> http://hackage.haskell.org/package/graphviz
02:57:14 <Eduard_Munteanu> Yeah, I'm looking at that. Thanks.
03:12:01 <romildo> I need help on how to write a url to search in a giving site: http://www.interfilmes.com/busca.html. There is the input text labeled  "Busca Filme", followed by a submit input "Buscar". How would be a URL to do such a search?  Then the resulting page will be downloaded from my Haskell program.
03:14:24 <blackh> romildo: Sounds like you need to know how web forms work.
03:14:59 <blackh> How much do you know already? Do you know about method="POST" and method="GET"?
03:15:34 <romildo> blackh, yes. I read about them, but do not understandig everything.
03:16:04 <uchchwhash> hello, trying to build GHC7 from source but after installation it still says some packages are broken, even haskell98, hints?
03:16:59 <ManateeLazyCat> uchchwhash: My suggestion, waiting next "haskell platform". :)
03:17:01 <blackh> romildo: Well, it's a bit involved, so I think you will need to read up.  You need to know about the POST method words, and how the encoding of CGI parameters works.
03:17:32 <blackh> It isn't that difficult, but it'd be easier for you to find a web page about it than for me to explain it.
03:17:48 <uchchwhash> ManateeLazyCat: :D I guess I can do that
03:18:46 <uchchwhash> still, rather offensively, hmatrix fails to build with lib/Data/Packed/Internal/Vector.hs:96:15: Empty 'do' construct
03:18:55 <uchchwhash> is this known? or is it just me?
03:19:43 <romildo> blackh, I promise I will study the subject. But just now I want someone to construct the URL for me. I suppose that for those with the knowledge it is trivial.
03:20:00 <blackh> romildo: Yes - that's correct.
03:20:05 <blackh> OK...
03:21:02 <quicksilver> romildo: the URL for the search is the same as the URL for the page.
03:21:35 <quicksilver> romildo: but you still need to POST to it, whereas using a standard tool to "download" a page will use GET>
03:23:24 <blackh> romildo: I am trying it with GET (because that's easy) but it doesn't want to work for me.
03:23:37 <blackh> I think you're going to have to just teach yourself how it works.
03:27:03 <romildo> quicksilver, in general every time a form mehtod is POST the response cannot be retrieved simply with a URL containing the needed data? As I understand it, such urls works only for the GET method. Is that right?
03:27:17 <ezyang> omildo: Yes. 
03:27:36 <ezyang> GET is "idempotent". You can do it as many times as you wnt without changing the result. 
03:28:35 <quicksilver> romildo: no, that's not right.
03:28:44 <quicksilver> romildo: GET and POST are both methods used to access a URL.
03:29:03 <quicksilver> but GET is the default, implied, method when you enter a URL into (Almost all) programs and web browsers.
03:29:17 <blackh> romildo: The only difference between GET and POST is that, for GET, the CGI arguments go in the URL after a ?.  For POST, they go into the body of the request.
03:29:34 <quicksilver> romildo: I'm sorry, but I"m not going to teach you HTTP and FORM-encoding in #haskell. I don't have time.
03:30:02 <romildo> So I suppose I need a tool to automatically fill the text input and them post the form.
03:30:13 <imc> romildo: you use some console tools that allow you to define POST data fields for specified form, or write a tiny http client doing the post request 
03:30:35 <imc> console tools: wget or curl
03:30:47 <romildo> I wil search the subject and read more about form submission.
03:31:39 <romildo> There are Haskell  bindings for curl. I will see if it can be done in Haskell using such bindings.
03:33:25 <romildo> Learning how to write a http client does to do the post request probably is not easier.
04:13:56 <Imk0tter> how would I go about exporting a bianry tree to a file, to then be re-built upon import (given all the pointers)
04:18:08 <quicksilver> Imk0tter: lots of ways. Number all the nodes and use numbers for the links? just use () or <tag></tag> for nesting?
04:20:54 * hackagebot hasktags 0.68.1 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.68.1 (MarcWeber)
04:33:57 * hackagebot timeplot 0.2.6 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.6 (EugeneKirpichov)
04:48:01 * hackagebot epic 0.1.7 - Compiler for a supercombinator language  http://hackage.haskell.org/package/epic-0.1.7 (EdwinBrady)
04:48:33 <ville> Well 0.1.7 that's not very epic now is it?
05:01:04 <aristid> ville: it's a SUPERCOMBINATOR language, how could that not be epic?
05:04:19 <fryguybob> "currently used as a back end for Epigram" -- that is epic.
05:13:33 <Eduard_Munteanu> Epic morphisms FTW.
05:20:32 <xplat> heh, that actually makes sense.  an epic win is one that wins in every possible way.  and an epic fail fails in every possible way.
05:20:56 <xplat> i guess a monic fail would be a fail where every aspect fails differently
05:22:04 <xplat> quite impressive (?) in itself
05:33:10 <zygoloid> xplat: 'data EpicMonad a; instance Monad EpicMonad where' <-- epic fail. also epic return and epic bind ;)
05:35:09 <xplat> alas, the only epic monad from Hask to Hask is Identity :)
05:35:27 <xplat> (and even that, only up to equivalence ...)
05:35:54 <zygoloid> maybe as a type synonym :/
05:38:17 <xplat> well, actually there are others, but that's the only one you can express as a typeclass instance
05:39:33 <xplat> and probably they are all equivalences
06:05:33 <jeltsch> S
06:06:13 <jeltsch> Say I have some type synonym family T. I want to apply T to an argument and let GHCi show me the result. How can I do that?
06:06:45 <jeltsch> If I say :type undefined :: T Int, for example, GHCi just says T Int instead of the result.
06:08:03 <dolio> I'm not sure there's a good way to do that.
06:08:33 <ezyang> I seem to recall an Oleg trick for this. 
06:09:16 <quicksilver> it's generally considered a feature that type synonyms are not expanded
06:09:22 <quicksilver> :t "Hi"
06:09:22 <lambdabot> [Char]
06:09:28 <quicksilver> hrm, bad example ;)
06:09:30 <jeltsch> quicksilver: I know. :-( 
06:09:31 <quicksilver> :t putStrLn
06:09:32 <lambdabot> String -> IO ()
06:09:50 <quicksilver> in the context of type synonym *families* you make a very interesting point.
06:09:54 <fryguybob> jeltsch: does it show up in an error, like no show instance for ...
06:10:20 <jeltsch> fryguybob: No error. It just prints the type I had originally entered.
06:11:04 <fryguybob> jeltsch: I mean don't ask for the type: > undefined :: T Int
06:11:37 <twb> setup: <file descriptor: 4>: resource exhausted
06:11:44 <twb> ...not a helpful message
06:11:58 <twb> It should use strerror or whatever it's called
06:12:17 <twb> ("write error: No space left on device")
06:13:12 <fryguybob> jeltsch: Example towards the end of:  http://byorgey.wordpress.com/2010/07/06/typed-type-level-programming-in-haskell-part-ii-type-families/
06:14:04 <ezyang> Ok, byorgeyan trick :-) 
06:14:19 <fryguybob> :D
06:14:29 <dolio> I thought they were going to add a type-evaluate command, but I don't see anything like that.
06:14:49 <jeltsch> fryguybob: If I deliberately trigger a ‚ÄúNo instance for ‚Ä¶‚Äù error, GHCi expands the type, but only lazily, i.e., as far as it needs to. So I usually don‚Äôt get a normal form.2
06:15:28 <fryguybob> jeltsch: Bummer.
06:19:53 <twb> How can I diagnose the following build failure?
06:19:53 <twb> Linking dist/build/gitit/gitit ...  cabal: Error: some packages failed to install: gitit-0.7.3.8 failed during the building phase. The exception was: ExitFailure 9
06:20:38 * twb tries --verbose=3
06:24:28 * Jafet wonders if "ExitFailure" means a program failed to exist
06:24:45 <Jafet> Hmm
06:24:48 <flux> "Terminate And Stay Resident"
06:24:49 * Jafet decides to keep that typo
06:24:51 <twb> Aha, dmesg found the problem
06:25:00 <twb> [191940.116505] Memory cgroup out of memory: kill process 8368 (ld) score 139920 or a child
06:25:00 <twb> [191940.131554] Killed process 8368 (ld)
06:25:35 <twb> Apparently the linked needs more than 1GB resident, and I'm having trouble convincing LXC to give it that
06:26:58 <quicksilver> nasty linker
06:27:16 <quicksilver> you could possibly try gold, although I don't know how much work that is to get going.
06:27:36 <ezyang> Not difficult at all, in my experience 
06:27:45 <ezyang> If you're on Fedora 14, just update alternatives. 
06:27:57 <twb> echo $((2 * 1024*1024*1024)) >/var/cgroup/greed/memory.limit_in_bytes
06:27:58 <twb> -bash: echo: write error: Invalid argument
06:28:16 <twb> ezyang: change that first 2 to a 1 and it's happy.
06:28:40 <twb> Oh, you mean "not difficult to use gold"
06:28:57 <ezyang> yah 
06:29:25 <twb> Ergh, installed it on the wrong host
06:30:44 <twb> quicksilver: that worked
06:30:53 <twb> I'm not sure if I should be happy about that
06:31:32 <twb> Huzzah
06:38:31 <dpratt71> Someone has attempted to rank language popularity via correlating github projects with stackoverflow tags: http://goo.gl/pFJ2d
06:38:44 <dpratt71> I was surprised to see where Haskell landed
06:40:23 <Axman6> what's so surprising about it?
06:41:58 <dpratt71> I guess I expected it to fall far more to the middle or even left
06:42:35 <Axman6> it's becomming a quite popular language
06:42:43 <dpratt71> so it would seem
06:43:59 <dpratt71> perhaps I'll have to go learn Coq now :)
06:44:39 <Axman6> Haskell too mainstream for you now? :pp
06:44:42 <Axman6> -p
06:44:53 <dpratt71> :)
06:45:48 <dpratt71> since Haskell's been around a while, I wonder what factors have contributed to its recent rise in popularity
06:46:22 <Imk0tter> i'm fairly sure it has a lot to do with the fact that it's being now being used in schools
06:47:01 <geheimdienst> the reason are the emergence of lambdacats
06:47:11 <geheimdienst> uh, s/are/is
06:47:17 <dpratt71> geheimdienst: :)
06:48:00 <Jafet> @quote coq
06:48:00 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
06:48:15 <dpratt71> heh
06:48:34 <aristid> nice quote
06:48:56 <aristid> @quote haskell
06:48:56 <lambdabot> haskell says: Haskell - it's like a Lamborghini in the village. A little jerk - and went to work on the tractor.
06:49:18 <aristid> that makes no sense
06:49:26 <Axman6> indeed
06:49:34 <dpratt71> I note that many former and current Haskell luminaries now work for the Evil Empire, and have been using that as a platform for evangelizing Haskell
06:49:36 <geheimdienst> the grammar seems less than cromulent
06:49:36 <Jafet> @quote agda
06:49:36 <lambdabot> roconnor says: [on Agda] and if your code is pink, you might as well write it in some crappy langauge like Haskell
06:49:39 <Axman6> although, Lamborghini do make tractors i believe
06:49:51 <aristid> dpratt71: evil empire stands for what again?
06:49:54 <Axman6> dpratt71: the what?
06:50:02 <Axman6> MSR?
06:50:05 <dpratt71> Microsoft
06:50:17 <Jafet> Microsoft Research isn't exactly organized into soviets.
06:50:19 <Axman6> MSR and MS are rather different entities
06:50:27 <aristid> Jafet: yeah, only MS is
06:50:32 * geheimdienst doesn't get all that microsoft bashing ... i mean, come on, guys
06:50:34 <dpratt71> Erik doesn't work in MSR
06:50:53 <aristid> i have this hypothesis that the rise of haskell is due to the internet :)
06:50:58 <dpratt71> geheimdienst: entirely in jest, I assure you; I'm pretty close to an MS schill
06:51:09 <Jafet> ("And we present our department's five-year plan for ghc-par. Context switching beyond your wildest dreams, Premier!"
06:51:14 <geheimdienst> fair enough
06:51:15 <Jafet> )
06:51:46 <Eduard_Munteanu> The increase in the average IQ? No more starvation? .1 less and you don't get monads :P
06:51:55 <dpratt71> speaking of Erik, LINQ was the gateway drug that got me interested in Haskell
06:52:10 <aristid> Jafet: Dawai!
06:52:43 <aristid> dpratt71: well, for me the gateway drug was c++ templates :P
06:53:05 <Axman6> well, learning haskell has paid off for me, right now i'm sitting in my apartment in tokyo, where's i'm doing an internship writing programs exclusively in Haskell (though with a Ruby build system)
06:53:36 * geheimdienst thinks compared to msr, there is many a university where you have more publishing pressure and less discretion how to use your research time. just from what i've heard
06:53:38 <dpratt71> aristid: didn't stick with C++ long enough to get into that part; is it true that they're Turing Complete?
06:53:48 <geheimdienst> Axman6: woah, not bad. tsuru capital ...?
06:54:51 <aristid> dpratt71: yeah, to some degree. the amount of recursion is limited, but in most compilers you can crank it up
06:54:55 <Axman6> yup :)
06:55:07 <geheimdienst> congrats, dude :)
06:55:15 <Axman6> i'm really liking working here, it's good fun
06:55:28 <Jafet> aristid: just like undecidable instances!
06:55:37 <aristid> Jafet: heh
06:59:42 <kurenai> i've discovered haskell this spring and was amazed by it's beauty. it was hard not to share it with my programmer friends. so i guess we deal with a critical mass example here.
07:00:50 <Axman6> oh and thanks geheimdienst :)
07:00:54 * PhilRod_ knows only a tiny bit of haskell and it mostly serves to make me miserable about having to write C++ for my job
07:01:14 <Axman6> heh
07:01:31 <geheimdienst> the prime use case of haskell, for sure
07:02:01 <Axman6> i have no idea what i'm going to do when i need to find another programming job that's probably not going to be using haskell :(
07:02:10 <PhilRod_> well, more miserable about looking at other people's code - I avoid the standard library ugliness as much as possible
07:03:19 <PhilRod_> "what? you have to define a whole object and write two lines' worth of loop just to do 'sortBy (comparing foo) xs'?"
07:03:53 <Axman6> :D
07:03:57 <Axman6> D: even
07:04:24 <dpratt71> PhilRod_: similarly, I think I would've really liked F# had I not seen Haskell first
07:04:44 <Eduard_Munteanu> Yeah, Visitor patterns are incredibly verbose.
07:04:56 <PhilRod_> ooh I've never looked at F#. Might waste some time on that
07:05:29 <Eduard_Munteanu> F# is certainly not as "interesting" as Haskell.
07:05:54 <Eduard_Munteanu> (just as Haskell is certainly not as interesting
07:05:57 <Eduard_Munteanu> as Coq)
07:05:57 <dpratt71> of course the other part of my lack of desire for F# is that C# (the language I use the most) has become much more functional as well
07:05:58 <Eduard_Munteanu> :)
07:06:25 <PhilRod_> Eduard_Munteanu: basically everything in C++ is incredibly verbose. what other language has (the equivalent of) "for x in xs"-style loops taking multiple lines to write?
07:06:44 <aristid> PhilRod_: BOOST_FOREACH(T &x, xs) i think
07:06:51 <geheimdienst> speaking of verbosity, i've a new job that entails wading through mediocre objective-c code. nothing is as horribly verbose as the apple apis
07:07:28 <Eduard_Munteanu> Does it sucketh more whan WINAPI? :)
07:07:46 <Eduard_Munteanu> *than
07:07:51 <Jafet> "Doth it"
07:08:07 <geheimdienst> "moar then"
07:08:16 <Jafet> @quote moar
07:08:16 <lambdabot> tensorpudding says: lolcategory demands moarphisms
07:08:22 <Eduard_Munteanu> :))
07:08:42 <roconnor> @unpl (<=) . g
07:08:42 <lambdabot> (\ c -> (<=) (g c))
07:09:10 <roconnor> :(
07:09:11 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
07:09:14 <roconnor> needs more eta
07:09:41 <roconnor> @type (<=) . g
07:09:42 <lambdabot> forall a (f :: * -> *). (Ord a, SimpleReflect.FromExpr (f a), Functor f) => f (a -> Bool)
07:09:53 <roconnor> damn it Cale
07:10:00 <roconnor> @type (<=) Prelude.. g
07:10:01 <lambdabot> forall b a. (Ord b, Show a, SimpleReflect.FromExpr b) => a -> b -> Bool
07:10:07 <roconnor> @unpl (<=) Prelude.. g
07:10:08 <lambdabot> ((Prelude..) (<=) g)
07:10:09 <PhilRod_> aristid: less ugly I guess, but sadly there's no chance I could persuade the powers-that-be to allow a dependency on boost. Anyway, I'm probably getting too far OT...
07:10:18 <Eduard_Munteanu> @undefine g
07:10:30 <Eduard_Munteanu> @type (<=) . g
07:10:31 <lambdabot> forall a (f :: * -> *). (Ord a, SimpleReflect.FromExpr (f a), Functor f) => f (a -> Bool)
07:10:31 <aristid> PhilRod_: ah, the joy of using c++ without boost ;)
07:10:49 <roconnor> @unpl  \g -> (<=) . g
07:10:50 <lambdabot> \ g c -> (<=) (g c)
07:10:54 <roconnor> bah
07:10:58 <Jafet> :t let g x = undefined in (<=) . g
07:10:58 <roconnor> oh
07:10:59 <lambdabot> forall a t. (Ord a) => t -> a -> Bool
07:11:05 <roconnor> unpl doesn't know about the types of things
07:11:15 <roconnor> ah
07:11:22 <duckinator> hi
07:11:30 <Eduard_Munteanu> duckinator: hi
07:14:29 <dolio> roconnor: I don't know if anyone answered your question yesterday, but I think Const 0 is initial and Const 1 is final.
07:14:51 <dolio> Where 0 and 1 are initial and terminal objects.
07:15:33 <roconnor> dolio: I was mistaken in thinking id would be terminal.  It is simply the identity for the tensor between functors.
07:15:50 <dolio> Yes.
07:17:01 <roconnor> what is the name of the catagorical structure which has a "comoposition" of type  f a -> f b -> f (a ‚äó b) ? 
07:17:41 <roconnor> all applicative functors have this function: liftA2 (,)
07:17:53 <roconnor> and my plates from multiplate have this structure too.
07:18:24 <dolio> If you mean f a ‚äó f b -> f (a ‚äó b), then it's part of the definition of a lax monoidal functor.
07:18:28 <geheimdienst> > "comoposition" == "cosmoposition"
07:18:29 <lambdabot>   False
07:19:19 <dolio> Which is basically the categorical notion that applicative functors correspond to.
07:22:01 <roconnor> Hmm, looks like I also need a function from Identity -> Plate Identity.
07:22:17 <roconnor> er that isn't a type
07:22:43 <roconnor> Hmm, looks like I also need a function from () -> Plate Identity.
07:24:02 <roconnor> ah, and that is purePlate :: Plate Identity
07:26:26 <xplat> ~[6~[6~[6~[6~[6~[6~[6~C++
07:26:40 <xplat> oops
07:27:08 <roconnor> so multiplate is some endofunctor on a lax monoidal category over applicative functors that preserves the lax monoid structure.
07:27:14 <xplat> C++ wouldn't have been too horrible if the compiler writers had used smarter algorithms to search for existing templates
07:27:22 <roconnor> I think that is too much for my brain to handle
07:27:35 <dolio> No. The category is just monoidal.
07:27:42 <dolio> Lax refers to the functor.
07:27:44 <mm_freak> xplat: C++ would still be horrible
07:27:57 <xplat> as it is, you try to use something like proto to make life easier and instead a single source file takes over an hour to compile
07:28:08 <mm_freak> templates are almost useless for anything more complicated than some dumb data structure
07:28:09 <roconnor> so multiplate is some endofunctor on a lax monoidal category over applicative functors that preserves the monoid structure.
07:28:33 <roconnor> ah
07:28:37 <roconnor> http://en.wikipedia.org/wiki/Monoidal_natural_transformation
07:28:46 <Eduard_Munteanu> They now have some sort of typeclasses, at least it's proposed (but not in C++0x IIRC)
07:28:48 <dolio> Lax means that the functor isn't on-the-nose about preserving tensor products.
07:28:49 <xplat> applicative functor or lax monoidal functor?
07:29:01 <AmunRa> mm_freak, templates are very powerful C++.. ..you can use them for all sort of things -- very ugly, but nonetheless powerfull
07:29:04 <dolio> Rather there's a natural transformation between the two.
07:29:13 <xplat> what haskell people call an applicative functor is a lax monoidal functor in maths iirc
07:29:28 <xplat> and applicative functor would be something else
07:29:34 <Eduard_Munteanu> :t ap
07:29:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:29:49 <mm_freak> AmunRa: templates are a bad excuse for not having interfaces and accompanying contexts/contracts/whatever you call them
07:29:52 <dolio> And there are other adjectives for when f a (x) f b is isomorphic/equal to f (a (x) b).
07:30:08 <mm_freak> AmunRa: and they are horrible to work with, especially when you write a portable template library
07:30:09 <dolio> One of which is 'strict', but I forget which that is.
07:30:32 <Eduard_Munteanu> (x) somehow goes to (->) ?
07:31:45 <AmunRa> I agree hard to work with, lead to confusing compiler errors et cetera.. but what you're saying is that they are "almost useless" -- these are different things.. once you get over the difficulty barrier you realise they can do a lot
07:31:57 <roconnor> dolio: http://en.wikipedia.org/wiki/Monoidal_natural_transformation  <-- I think these are the multiplate laws
07:32:12 <Eduard_Munteanu> Indeed they can do more than Haskell's type system it seems.
07:32:19 <Eduard_Munteanu> Though it doesn't make it consistent.
07:32:20 <roconnor> dolio: which is a little ironic since I actually derived them from the laws of a colagebra over a comonad.
07:32:31 <AmunRa> Anyways.. I have no intent for a C++ flame, after all this is #haskell ... and here to the rest of the channel, I apologise
07:32:52 <Eduard_Munteanu> They're a bit like dependent types IIRC.
07:34:17 <Jafet> Hmm, left this mandelbrot plotter running for two days and it's not even finished yet, some pixels are at 7 million iterations in 80-bit floating point. I wonder if the output means anything anymore
07:34:32 <roconnor> dolio: that first square seems like my multiplate / compose plate law
07:35:05 <xplat> so what is multiplate?
07:35:43 <geheimdienst> xplat, it's much like singleplate, but moar of it
07:35:44 <geheimdienst> ;)
07:35:45 <roconnor> dolio: And since J = () I guess the second digram is the multiplate / pureplate law.
07:35:59 <geheimdienst> (honestly i have no clue)
07:36:36 <roconnor> xplat: http://hackage.haskell.org/package/multiplate http://haskell.org/haskellwiki/Multiplate
07:37:12 <quicksilver> geheimdienst: s/single/uni/; and you weren't far off.
07:38:21 <Eduard_Munteanu> "Multiplate does not require GADTs and does not require multi-parameter type classes. It *only* requires rank 3 polymorphism."
07:38:24 <geheimdienst> "plate" as in thing-you-put-noms-on, or plate as in boilerplate ...?
07:38:24 <Eduard_Munteanu> :)
07:38:50 <quicksilver> geheimdienst: as in boilerplate.
07:39:00 <roconnor> dolio: is empty :: Alternative f => f a the anhilator for this (f a, f b) -> f (a, b) operation?
07:39:02 <geheimdienst> thanks
07:39:04 <quicksilver> uniplate is simplified generics for the case when you only care about one leaf type at a time.
07:39:24 <tg_zzz> I can't wait until 100 years from now when 'eating food' will be deprecated from our lexicon in favor of 'oming noms'
07:39:27 <quicksilver> multiplate is a way to preserve uniplates simplicity (or most of it) whilst dealing with more complex transformation.
07:39:38 <roconnor> geheimdienst: plate is sort of derived from boilerplate
07:41:18 <dolio> roconnor: I expect so.
07:41:21 <Jafet> @remember tg_ I can't wait until 100 years from now when 'eating food' will be deprecated from our lexicon in favor of 'oming noms'
07:41:21 <lambdabot> I will never forget.
07:41:35 <roconnor> dolio: is there any categorical theory for tis?
07:41:48 <dolio> Don't know about that.
07:41:57 <quicksilver> although, I maintain that roconnor should have used 'getVegetablesPlate' instead of 'getVariablesPlate' as his example on the wikipage.
07:42:18 <roconnor> quicksilver: it's a wiki so you can edit it
07:42:36 <quicksilver> roconnor: I know. However, I was joking ;)
07:42:58 <kmc> Eduard_Munteanu, :)  I think that's a reasonable statement and I *also* think it's hilarious
07:43:15 <roconnor> :)
07:43:48 <xplat> kmc: agreed!
07:43:52 <mm_freak> AmunRa: i know what C++ templates can do
07:44:10 <Jafet> There's no such thing as rank 3 polymorphism; it's 1, 2, or infinity
07:44:16 <mm_freak> but i also know what they can't do‚Ä¶  you can't write interfaces with them
07:44:59 <roconnor> dolio: is there a better categoraical term I can search for that "annihilator"
07:45:02 <roconnor> there must be
07:45:16 <roconnor> Jafet: that is why you have to enable RankNTypes :(
07:45:32 <dolio> Not that I know of.
07:45:35 <AmunRa> mm_freak: you mean something like this: http://www.boost.org/doc/libs/1_45_0/libs/concept_check/concept_check.htm ?
07:45:39 <xplat> Jafet: nonsense.  it's pretty unnatural to come up with a language or logic that only allows up to rank 3 polymorphism, but it's a lot easier to find examples that only use up to rank 3
07:46:29 <Jafet> I was referring to the increasing insignificance of large numbers
07:46:31 <kmc> i'm not sure i've ever needed above rank 3 polymorphism
07:46:58 <kmc> i wonder if even category-extras uses rank-4 polymorphism
07:47:13 <Jafet> It wouldn't make any difference whether it used rank 4 or 5, because the flags are the same and it's inscrutable as ever
07:47:25 <xplat> if it doesn't, file a bug
07:47:37 <mm_freak> AmunRa: nothing is impossible‚Ä¶  after all TMP is turing-complete
07:48:03 <mm_freak> so, "it's possible" doesn't make C++ templates good
07:48:47 <dolio> Properly polymorphic call/cc is rank-3, I think.
07:48:50 <mm_freak> AmunRa: the HList library makes a limited form of dependent types possible in haskell, even though the language itself doesn't allow it
07:48:55 <xplat> yeah, C++ templates have a lot of power for metaprogramming, but they're sort of a turing tarpit language, and slow to boot
07:48:56 <kmc> maybe the 9,639,482nd time we argue about C++ we will finally resolve the issue
07:49:13 <kmc> every type system is a "limited form of dependent types"
07:49:16 <dolio> ((forall s. a -> Cont r s) -> Cont r a) -> Cont r a
07:49:20 <mm_freak> AmunRa: that doesn't make either haskell or HList good for programming in that style
07:49:21 <xplat> plus they still have limitations, or the Boost Preprocessor Library wouldn't exist
07:49:28 <kmc> dolio, yeah, that's where i've needed rank-3
07:49:29 <geheimdienst> @remember kmc maybe the 9,639,482nd time we argue about C++ we will finally resolve the issue
07:49:30 <lambdabot> It is stored.
07:50:00 <mm_freak> AmunRa: HList also allows extensible records, but you really don't want to do it that way
07:50:02 <Jafet> @quote c++
07:50:03 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
07:50:10 <mm_freak> proper language support is the way to go
07:50:18 <Jafet> @quote c\+\+
07:50:18 <lambdabot> v_ says: C++ is a pitfall-based language
07:50:41 <Jafet> That sounds about right
07:50:57 <AmunRa> mm_freak: agree :-) I'm not saying it's a good idea.. but you're saying it's not possible (stating: you can't write interfaces with them) .. clearly it is not the case.
07:51:08 <aristid> Jafet: think of all the job security that creates!
07:51:42 <mm_freak> AmunRa: it's meant in the same sense you can't use generics in C‚Ä¶  sure you can, if you write a corresponding DSL ;)
07:51:47 <xplat> yeah, you will be fully employed until you die at age 33 from a brain aneurysm
07:52:07 <geheimdienst> maybe after 9,639,482 discussions, people will cease to be wrong on the internet
07:52:23 <mm_freak> AmunRa: if the effort to use a certain feature in a language is as great as implementing a language on top of it, which supports it, then it's valid to say that you can't do it in that particular language
07:52:28 <AmunRa> ehh well.. if only I could write as much Haskell as I write C++ :D
07:52:30 <kmc> C++ is a fascinating language
07:52:43 <kmc> and i mean that statement without judgement as to goodness
07:52:55 <mm_freak> AmunRa: otherwise you couldn't make any statements about language quality whatsoever
07:53:02 <mm_freak> (objective statements that is)
07:53:12 <xplat> kmc: i agree with you again
07:53:23 <kmc> mm_freak, what makes you think you can make objective statements about language quality
07:53:29 <kmc> why is that a reasonable goal
07:54:24 <mm_freak> kmc: well, wouldn't you find the statement, "C++ is better for object-oriented programming than assembler", objective?
07:54:53 <xplat> filinski says you can make objective statements about language power, if not quality.  he defines a metric of 'macro-expressibility' that makes finer and more pertinent distinctions than reducibility.
07:55:15 <mm_freak> well, yes
07:55:24 <mm_freak> maybe i should have used the wort "power" instead of "quality"
07:55:31 <kmc> mm_freak, not quite, i'd say it can be argued persuasively but will still rest on a judgement call
07:56:21 <kmc> if you want to compare C with C++ in terms of support for OOP then you will find people on both sides
07:56:26 <AmunRa> mm_freak: It is all very subjective.. as an experienced C++ developer I find it easier to write C++ code than express the same concepts in $OTHER_LANGUAGE. Does that automatically mean $OTHER_LANGUAGE is worse? Of course not.. it's very subjective.. It is easier for me to call into boost to use it's concepts checking library than re-write the whole software stack into $OTHER_LANGUAGE and then learn $OTHER_LANGUAGE
07:56:50 <mm_freak> kmc: now i just say that a language has a certain feature, if and only if you don't need to write an interpreter for a higher-level language to use it
07:57:19 <kmc> AmunRa, right.  and it's hard to see the utility of features your language doesn't have, when you're not used to thinking in those terms
07:57:22 <mm_freak> AmunRa: i'm not talking about expressiveness or ways of expressing, just about language features
07:57:25 <AmunRa> Let alone that I may have real-time requirements (as in fact, I do) that would preclude me from using most other things out there
07:57:42 <kmc> static types seem useless when all you know is Java
07:57:47 <kmc> macros seem shitty until you learn Lisp
07:57:47 <kmc> etc
07:57:49 <mm_freak> after all most people can write code much quicker in C++ than in haskell
07:57:59 <mm_freak> that doesn't make haskell worse =)
07:58:10 <AmunRa> Exactly :-)
07:58:19 <geheimdienst> ... most people can add weight to the airplane quicker ...?
07:58:20 <mm_freak> we're not disagreeing here
07:58:27 <aristid> mm_freak: i think most people have a speed of 0 on both languages, which is equivalent speed
07:58:40 <mm_freak> aristid: at least as quick
07:59:00 <xerbee> Hi, I'm studying for a FP exam and got stuck on foldr/foldl. Can someone help a newbie? http://hpaste.org/42238/foldl_or_foldr
07:59:22 <kmc> not disagreeing, just agreeing vigorously
08:00:50 <AmunRa> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29   --- They are the same, almost.. it just depends which end you start from when accumulating a result, which in turn affects your use of the stack.. and is all a little more complicated in Haskell because of lazyness
08:01:14 <iago> xerbee, you need to use foldl being aware of the maximum
08:01:17 <mm_freak> or, in haskell terms, the only difference is associativity =)
08:01:24 <iago> they are asking you to implement something like maximumBy
08:01:30 <jmcarthur> it's actually *simpler* due to laziness. you just have to "forget" the usual notion that parens affect evaluation order
08:01:34 <ezyang> I think of foldr as replacing : with the function 
08:01:57 <ezyang> And I think of foldl as iterating down the list. 
08:02:14 <xerbee> ezyang: yep that was what I was told during the lectures too. Not sure about the fold function though
08:02:47 <iago> ezyang, foldr is a natural transformation, you replace [] and : by something else
08:02:49 <jmcarthur> the parens just mean the difference between "x is applied to y and the result is applied to z" and "x is applied to the (lazily!) result of applying y to z"
08:03:01 <jmcarthur> *lazy
08:03:09 <AmunRa> probably the easiest way to understand folding is by example.. sum of a list === start with 0 and add each number in the list     -- try implementing that to begin with
08:03:30 <iago> foldl is just the same, but it is simulating that lists are defined in this way List a = Nil | Cons List a
08:03:36 <kmc> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg -- xerbee
08:03:43 <merijn> The best way to understand is to grab a paper and do the term substitution by hand
08:04:08 <AmunRa> then see that with virtually the same code you can write "product :: [Int]"
08:04:16 <Axman6> i agree with merijn 
08:04:33 <iago> xerbee, if you replace [] by first week sales, and you replace : by max, you get what do you want
08:04:35 <merijn> I still do that occasionally if I get confused
08:05:13 <iago> the only difficulty is that you need to work 'modulo sales'
08:05:47 <xerbee> I've been playing with scanr/scanl and (-).
08:05:56 <xerbee> but this question is harder :)
08:06:47 <xerbee> iago: but i'm not allowed to use any prelude function
08:07:34 <Axman6> does that include (.)?
08:07:35 <kmc> (+) is a prelude function
08:07:38 <iago> xerbee, use if instead of max
08:07:46 <kmc> so is (>)
08:08:01 <iago> yep
08:08:12 <xplat> in strict languages you often want to use two foldls or foldl-and-reverse where in haskell you would just use one simple foldr
08:08:38 <iago> I see quite hard to do comparisons without some prelude function
08:12:04 <xplat> you could always implement data Nat = Z | S Nat and go from there
08:13:56 <xplat> and just to prevent accidents, do 'import Prelude ()' or '{-# LANGUAGE NoImplicitPrelude #-} first
08:17:09 <unkanon_> iago: what do you mean that foldl simulates that lists are implemented that way? they are alread: [a] = [] | (:) [a]
08:17:48 <tromp_> > foldr (:) [] "Hello"
08:17:50 <lambdabot>   "Hello"
08:18:06 <xplat> > foldl (:) [] "Hello"
08:18:07 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:18:17 <xplat> > foldl (flip (:)) [] "Hello"
08:18:18 <lambdabot>   "olleH"
08:18:39 <iago> unkanon_, 
08:18:43 <iago> :t foldr
08:18:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:18:57 <unkanon_> xplat: yes I get that
08:19:22 <iago> a -> b -> b is like Cons : a -> List a -> List a
08:19:30 <iago> :t foldl
08:19:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:19:59 <iago> is like Cons : List a -> a -> List a
08:20:36 <iago> foldr is the natural transformation for lists as you know them in Haskell
08:20:53 <iago> foldl is the natural transformations if lists where defined fliping Cons arguments
08:21:01 <iago> Cons = (:)
08:21:11 * unkanon_ is thinking
08:21:11 <iago> s/where/were
08:21:22 <aristid> iago: foldr is the natural transformation for lists after they are reversed? :)
08:21:27 <aristid> argh, foldl
08:21:46 <unkanon_> how do you make foldl an identity for lists?
08:21:56 <unkanon_> > foldr (:) [] [1,2,3]
08:21:57 <lambdabot>   [1,2,3]
08:21:59 <unkanon_> that's easy
08:22:05 <unkanon_> but what about foldl?
08:22:39 <Saizan> with foldl it can never truly be an identity, if we include infinite lists
08:23:08 <aristid> > foldl (flip (:)) [] (reverse [1,2,3])
08:23:09 <lambdabot>   [1,2,3]
08:23:29 <unkanon_> Saizan: so in other words what you're saying is that for foldl to be an id for lists it would necessarily have to use reverse
08:23:33 <iago> :)
08:23:56 <unkanon_> aristid: that ain't the identity :P
08:24:04 <Saizan> unkanon_: you can write it like foldl (\xs x -> xs ++ [x]) [] 
08:24:27 <Saizan> > foldl (\xs x -> xs ++ [x]) [] [1,2,3]
08:24:28 <lambdabot>   [1,2,3]
08:24:38 <unkanon_> > foldl (\xs x -> xs ++ [x]) [] "hello"
08:24:39 <lambdabot>   "hello"
08:24:47 <unkanon_> > foldl (\xs x -> xs ++ [x]) [] [1..]
08:24:54 <lambdabot>   mueval: ExitFailure 1
08:25:50 <aristid> just give it infinite time
08:26:27 <xplat> the list type that foldl 'simulates' is accurately: data Tsil a = Lin | Snoc (Tsil a) a
08:26:30 <unkanon_> yeah I'll just wait a bit
08:26:34 <unkanon_> heh
08:26:46 <unkanon_> lol
08:26:57 <xplat> that list type has the elements at the end on the 'outside'
08:27:03 <duckinator> So, i'm attempting to parse IRC without any parsing libraries just for learning, assuming I have ":foo!bar@baz PRIVMSG #asdf :this is a test" i can easily get the sender (foo!bar@baz) and command (PRIVMSG), however i can't figure out how to get the rest -- with everything trailing the : grouped together. Any tips/ideas? I'm having a hell of a time with this lol
08:27:16 <Saizan> xplat: no, it's not just that
08:27:22 <xplat> it can't represent lists with no end, but can represent lists with no beginning, which the 'normal' list type can't do
08:27:41 <aristid> xplat: lists with no beginning... interesting :D
08:28:11 <Saizan> foldl isn't the equivalent of foldr for another type, since the "accumulator" is really used as an accumulator, it doesn't just represent the recursive call 
08:28:32 <xplat> however, you can't access that ability through foldl because you're not actually working with lists of that type, just simulations ... you only get the intersection, which is finite lists
08:28:57 <unkanon_> duckinator: when you're done getting the sender and the command, are you holding just the rest of the string or all of it still?
08:29:11 <duckinator> unkanon_: i have the entire string
08:29:45 <xplat> Saizan: from this point of view, the actualized accumulator is an artifact of the bidirectional type conversion that Tsil's (natural) foldl is wrapped in
08:30:12 <unkanon_> duckinator: how are you getting the sender? are you slicing the string from ':' to ' '?
08:31:27 <Saizan> xplat: ok, i see
08:31:32 <duckinator> unkanon_: yea, right now i'm using this to get the sender (probably a better method than this, but i'm a bit new...):  head . words . drop 1 $ s
08:34:11 <unkanon_> duckinator: well I'm a newbie too so don't take what I say too seriously
08:34:27 <duckinator> fair enough :)
08:34:29 <unkanon_> however, if I had to use "my own parsing functions" for that I'd do something like this:
08:34:32 <unkanon_> > let getSender = takeWhile ((/=) ' ') . dropWhile ((==) ':') in getSender ":foo!bar@baz PRIVMSG #asdf :this is a test"
08:34:34 <lambdabot>   "foo!bar@baz"
08:35:01 <unkanon_> which says that the sender is between ':' and the first occurrence of ' ' after that. (that might not be the case, I don't know IRC that much)
08:36:13 <duckinator> unkanon_: yea, the format of IRC messages you receive from the server are either ":sender COMMAND arg1 arg2 :this bit after the colon is arg3" or "COMMAND arg1 arg2 :..."
08:36:50 <duckinator> unkanon_: so the main reason it's not hilariously short is because i'm trying to make a complete implementation that actually handles stuff i probably wont use ;P
08:37:25 <unkanon_> oh that's always a problem, ever heard of YAGNI? ( == "you ain't gonna need it") :)
08:37:34 <unkanon_> > span ((/=) ' ') ":foo!bar@baz PRIVMSG #asdf :this is a test"
08:37:35 <lambdabot>   (":foo!bar@baz"," PRIVMSG #asdf :this is a test")
08:37:47 <duckinator> oooh
08:38:03 <quicksilver> that's just takeWhile + dropWhile combined, duckinator 
08:38:10 <quicksilver> but it can certainly make your code a bit shorter.
08:38:29 <unkanon_> > span ((/=) ':') . snd $ span ((/=) ' ') ":foo!bar@baz PRIVMSG #asdf :this is a test"
08:38:30 <lambdabot>   (" PRIVMSG #asdf ",":this is a test")
08:38:36 <unkanon_> that's a good start
08:39:15 <duckinator> quicksilver: yea, main issue is getting everything after the colon as one word...which i think unkanon_ just solved. awesome :D
08:39:33 <unkanon_> :)
08:39:34 <duckinator> unkanon_: awesome, i think i can (ab)use span to do what i need :D
08:39:48 <unkanon_> lol great then
08:40:36 <unkanon_> duckinator: have a skim at http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-List.html
08:40:49 <unkanon_> you'll discover plenty of useful functions that work on lists
08:40:51 <duckinator> unkanon_: oh, btw, you can just use (/= ':') instead of ((/=) ':')
08:40:54 <unkanon_> they'll save you a bunch of time
08:41:25 <unkanon_> duckinator: oh cool, I'm always afraid of getting imcomprehensible errors because of precedence so I exaggerate on the parens :)
08:42:23 <duckinator> well, idk about you, but i've not had any precedence issues with haskell, aside from misunderstanding $ at 1am ;)
08:43:13 <sshc> How do I hide the global mtl-1.1.0.2 package as a sure?
08:43:43 <unkanon_> I'm too distracted to take the time to memorize precedences so I just flip them the bird and sprinkle parens all around
08:44:16 <Saizan> that wasn't a matter of precendences though
08:44:19 <sshc> How do I hide the global mtl-1.1.0.2 package as a user?
08:44:24 <quicksilver> duckinator, unkanon_: technically, (/= ':') and ((/=) ':') are different.
08:44:37 <duckinator> quicksilver: to what extent?
08:44:38 <quicksilver> in the former, the ':' is the second parameter, in the latter it's the first.
08:44:41 <unkanon_> how so?
08:44:45 <quicksilver> fortunately /= is commutative.
08:44:46 <unkanon_> oh...
08:44:52 <duckinator> interesting
08:45:01 <quicksilver> > (/ 5) $ 2
08:45:02 <lambdabot>   0.4
08:45:05 * geheimdienst has the rule to throw in some parens whenever he thinks "now i'd have to look up the precedence ..."
08:45:06 <quicksilver> > ((/) 5) $ 2
08:45:06 <lambdabot>   2.5
08:45:06 <unkanon_> the former is a section, the latter is prefix, right?
08:45:12 <quicksilver> right.
08:45:12 <Saizan> sshc: you can call ghc(i) with -hide-package
08:45:24 <sshc> ((/=) ':') is (':' /=)
08:45:26 <sshc> Saizan: Thanks
08:45:30 <unkanon_> geheimdienst: that's exactly it
08:46:34 <unkanon_> right, so ((/=) ':') is using the operator in prefix form, while (/= ':') is in section form
08:46:48 <unkanon_> oh quicksilver had already replied, cool
08:46:52 <unkanon_> just checking
08:48:09 <duckinator> now... `span (/= ' ') ":foo!bar@baz PRIVMSG #asdf :this is a test"` gives (":foo!bar@baz", " PRIVMSG #asdf :this is a test") .... what exactly is that? the haskell equivalent of what some languages call a tuple?
08:48:22 <unkanon_> yes
08:48:26 <quicksilver> haskell calls it a tuple too.
08:48:29 <duckinator> alright
08:48:32 <quicksilver> or a pair, in this simple case.
08:48:51 <geheimdienst> it's the haskell equivalent of a tuple. haskell calls it a tuple. ;-)
08:48:52 <unkanon_> right, a 2-tuple is a.k.a. a pair, a 3-tuple is a triple, and so on
08:49:20 <unkanon_> until you can't find any more latin words to describe the tuples
08:49:22 <geheimdienst> 163-tuple = sasquatchuple
08:49:37 * unkanon_ doesn't get the joke
08:52:32 <xplat> the joke is 'sasquatch' (a word for Bigfoot) sounds kind of like latin numeric prefixes.  this explanation won't make it funny, but at least you'll stop wondering.
08:52:58 <unkanon> oh, indeed
08:53:07 <geheimdienst> xplat, true. not that explanation and nothing else will make that joke funny :)
08:53:59 <geheimdienst> http://dictionary.reference.com/browse/sexagenarian <- was thinking of this
08:54:23 <unkanon> gotcha
08:56:20 <unkanon> so a long time ago when I was doing openGL programs in C I used SDL to give me the window and the keyboard access on a given OS (it would work on windows and linux)
08:56:41 <unkanon> is that still how I'd do now if I want to write an openGL program in haskell and strive for cross-OS support?
08:57:05 <kmc> that is a reasonable plan
08:57:20 <kmc> you can use GLUT to do that stuff, but GLUT kind of sucks
08:57:23 <augur> http://xkcd.com/832/ so cool
08:57:28 <unkanon> there's nothing more practical then? (yes, glut sucks)
08:57:31 <augur> this is xkcd's saving grace
08:57:32 <kmc> (SDL sucks too, if you're drawing with it, but it's okay for getting a graphics context)
08:57:38 <augur> the occassionally awesome visualizations
08:57:45 <unkanon> oh gosh I'd never draw with SDL :)
08:58:36 <unkanon> cool, haskell has a wrapper for SDL
08:58:47 <kmc> that's pretty cool augur
08:58:53 <kmc> and i agree
08:59:36 <tromp_> xkcd reminds my of my thesis cover, showing values of connect4 http://www.cwi.nl/~tromp/thesis.html
09:00:51 <kmc> nice tromp_
09:06:01 <tromp_> the difference being that mine show all moves for both sides
09:06:12 <tromp_> rather than onyl optimal moves for one side
09:06:23 <tromp_> but then mine only goes down 4 ply :(
09:07:14 <techrascal> looking for a haskell based open source project for machine learning .... any suggestions?
09:07:25 <unkanon> what kind of machine learning?
09:08:47 <techrascal> i have some prior work in the field of computer vision, and wanted to start off with some work in haskell
09:10:58 <unkanon> hmm can't help with that, sorry
09:12:06 <kmc> techrascal, browse hackage.haskell.org
09:12:10 <kmc> there's some machine learning stuff
09:12:15 <kmc> also some bindings to OpenCV i think
09:12:25 <techrascal> kmc: great
09:43:38 <unkanon> ungooglable question: I read somewhere that I can use ? to shorten lambdas, how's that?
09:43:54 <monochrom> implicit parameters
09:44:13 <Axman6> eh?
09:44:22 <Eduard_Munteanu> Is there a Data.Map analogue that uses an array behind the scenes? Some sort of hashtable, but I know there won't be collisions.
09:44:35 <unkanon> monochrom: thanks!
09:44:50 <kmc> Eduard_Munteanu, array updates are slow
09:44:53 <kmc> is it read-only?
09:44:56 <Eduard_Munteanu> unkanon: you could use the Reader monad to reduce the number of function parameters.
09:45:07 <Eduard_Munteanu> kmc: I build it only once, then I do lookups.
09:45:13 <unkanon> monochrom: by the way just got the book (bird's intro to func prog) and so far it's indeed amazing
09:45:16 <kmc> Eduard_Munteanu, the "hashmap" package provides a hash trie based on IntMap
09:45:21 <monochrom> nice
09:45:27 <duckinator> unkanon, monochrom: would one of you care to elaborate on implicit parameters? i'm curious now... :P
09:45:35 * Axman6 is too
09:45:37 <kmc> Eduard_Munteanu, so you can just use Array
09:45:45 <sm> g'day all. Can someone tell me where GMP.framework comes from ? I suspect it of causing osx version compatibility issues
09:45:51 <monochrom> look for it in old ghc user guides. it's being phased out.
09:45:55 <Eduard_Munteanu> kmc: yeah, it's just that I liked the purely functional interface of Data.Map :)
09:45:59 <kmc> you'll need to implement Ix for your key type, or write a conversion function
09:46:05 <kmc> Array has a purely functional interface
09:46:14 <Eduard_Munteanu> kmc: my Ix is Word8.
09:46:15 <monochrom> ghc 6.8.x should suffice
09:46:25 <kmc> it's just that "update" is a full copy, while for Data.Map it's only logarithmically much copying
09:46:29 <unkanon> implicit parameters are being phased out? then I won't even bother...
09:46:41 <kmc> Eduard_Munteanu, so why not the type Array Word8 Whatever
09:46:51 <Eduard_Munteanu> kmc: yeah, but I do updates during the map/array creation. I still want updates to be reasonably fast, but my focus is on lookups.
09:47:00 <Zao> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#implicit-parameters
09:47:08 <unkanon> yeah that's what I'm reading now
09:47:13 <Zao> monochrom: What replaces them, if at all?
09:47:13 <kmc> Eduard_Munteanu, so build it as a Map, then build the array from that
09:47:20 <mauke> some kind of freezable array?
09:47:22 <Eduard_Munteanu> kmc: oh, good idea, thanks.
09:47:23 <monochrom> I don't know
09:47:29 <kmc> :t \b -> listArray b . M.toList
09:47:30 <lambdabot> forall i k a. (Ix i) => (i, i) -> M.Map k a -> Array i (k, a)
09:47:58 <kmc> yeah, you could build it as an STArray, then freeze it to an Array, safely i think
09:48:29 <Eduard_Munteanu> Ah, runSTArray pollutes.
09:48:32 <kmc> Eduard_Munteanu, it's possible that copying the array is fast enough not to matter
09:49:14 <kmc> also since your key range is so small, performance of Array versus Map will be driven not by the misleading CS 101 asymptotic analysis, but by caching and RTS behavior and other tricky shit
09:49:29 <kmc> i wouldn't be totally surprised if Map or IntMap had faster lookups
09:49:31 <kmc> so, profile it
09:50:10 <Eduard_Munteanu> kmc: in my 'a i e', 'i' is Word8, but 'e' is a list of Bools.
09:50:24 <Eduard_Munteanu> So I can't really use IntMap.
09:50:28 <kmc> why not?
09:50:31 <kmc> IntMap [Bool]
09:50:42 <Eduard_Munteanu> Oh sorry, I was confusing with IntSet.
09:50:47 <mauke> IntMap Integer -- :-)
09:51:05 <kmc> yes, [Bool] is a very inefficient way to store a bit vector
09:51:08 <kmc> but again, it may not matter
09:51:20 <kmc> you can code the simple version and then see how it performs
09:51:22 <Eduard_Munteanu> kmc: I do it lazily, I'm hoping the list would fuse.
09:51:25 <kmc> ok
09:51:51 <kmc> when i say [Bool] is inefficient for a bitvector i don't mean to prejudge that you're using it as a bitvector
09:51:58 <kmc> just that if you are, be aware of tihs
09:52:09 <Eduard_Munteanu> It's that, or traversing the tree each time.
09:52:23 <kmc> what tree?
09:52:32 <Eduard_Munteanu> Huffman coding tree, for compression I need to go from leaves towards the root.
09:52:50 <kmc> oh, so you want to associate each byte with its path in the tree
09:52:59 <Eduard_Munteanu> Yes.
09:53:04 <kmc> got it
09:53:38 <Eduard_Munteanu> I'm currently traversing the tree once, building a Map from Word8s to [Bool], then using that to do lookups.
09:53:45 <kmc> but the Map is too slow?
09:53:50 <kmc> if you need it, a still more efficient structure would unbox that [Bool] into the array
09:53:58 <kmc> if you're willing to give up building the array lazily
09:54:23 <kmc> the maximum depth of your tree is a lot less than the number of bits in a machine word
09:54:27 <Eduard_Munteanu> kmc: hm, I'd like to.
09:54:43 <Eduard_Munteanu> Yeah.
09:54:54 <kmc> i'm thinking at the level of squeezing more into cache
09:55:35 <Eduard_Munteanu> Well is there a theorem putting an upper bound on the size of the code in bits?
09:55:48 <Eduard_Munteanu> I'm not sure the depth of the tree is always < 8.
09:56:37 <kmc> i think there is a theorem
09:56:45 <kmc> the huffman code is as efficient as any prefix code
09:57:51 <Eduard_Munteanu> I see. I was trying to determine how to store my paths through the tree.
10:02:19 <xplat> kmc: if you have a really long text with one value that only ever occurs once, the codeword for that value can be unboundedly long
10:03:44 <xplat> in practice, you can either cut off your pathlengths at some point when building the tree (27 bits would work, leave 5 for the path length) or you can handle really long codes specially
10:04:28 <xplat> the former case is not a true huffman code, but may work better in practice because there's less logic in your inner loop and less cache hurting
10:04:31 <Eduard_Munteanu> Oh, I see.
10:05:44 <Eduard_Munteanu> It seems composing on the left with 'array (0,255) . M.assocs' reduces runnning time from 0.85 to 0.7. That's as good as my Shannon-Fano implementation.
10:07:55 <Eduard_Munteanu> Do real implementations avoid bitwise operations somehow? Perhaps by using larger symbols (>8 bits)?
10:08:19 <Eduard_Munteanu> gzip is so much faster than my C implementation of Shannon-Fano.
10:09:50 <Eduard_Munteanu> I remember WinRAR had an option regarding the dictionary size, and it could go up to 1MiB or so. I assume that uses LZ or something like that as well, but can Huffman benefit from byte-sized units?
10:10:52 <sm> when ghc links on a mac, it seems to add -framework GMP. How can I stop that ?
10:11:30 <Eduard_Munteanu> sm: why do you want to do that?
10:11:57 <xplat> gzip does not avoid all the bitwise operations, i'm sure of that
10:11:58 <sm> Eduard_Munteanu: to make a portable binary.. most macs don't have that framework
10:12:11 <sm> I'm pretty sure my app doesn't need it, as I remember somehow linking without it in the past
10:12:16 <xplat> gzip has been getting optimized for at least 15 years, though
10:12:27 <Eduard_Munteanu> sm: gmp is used for Integer stuff.
10:12:43 <xplat> it would be even faster if they weren't trying to avoid the patent minefield, i bet
10:12:53 <Eduard_Munteanu> sm: but anyway, GHC does static linking by default so it's portable unless you disable it.
10:13:08 <Eduard_Munteanu> xplat: oh, that makes sense.
10:13:28 <Eduard_Munteanu> Admittedly my C code didn't try very hard to be fast.
10:13:41 <sm> hm that's not what I'm seeing. otool -L shows https://gist.github.com/736496 , and if you try to run that executable without the framework in place it fails
10:13:42 <c_wraith> Eduard_Munteanu, that's only true of haskell packages, not native libraries.  haskell dynamically links to native libraries by default
10:14:16 <c_wraith> sm, what version of ghc?
10:14:26 <sm> c_wraith: 6.12.3 currently
10:14:38 <c_wraith> also, I should say *ghc* links to ... not haskell does
10:14:43 <Eduard_Munteanu> Oh, right. I think there was a -static flag for that, at least if you pass it to the GCC backend.
10:14:45 <xplat> doing LZ and then huffman can probably be faster than huffman alone, too, the LZ phase is more aligned and it delivers fewer symbols to the huffman phase
10:14:54 <sm> great.. searching
10:15:26 <Eduard_Munteanu> I see.
10:16:29 <xplat> heck, just the improved compression could make it faster depending on the ratio between CPU speed and CPU->memory bulk transfer rates
10:17:11 <sm> also: when I run the link command by hand without -framework GMP, the resulting GMP-less executable seems to work just fine
10:17:13 <xplat> that's probably not the case for gzip tho :)
10:18:01 <xplat> (and it is -certainly- not the case for lzma ...)
10:18:54 <Eduard_Munteanu> Heh, yeah, LZMA is slower.
10:19:22 <Eduard_Munteanu> (But do they only do LZMA, or Huffman as well?)
10:19:54 <Eduard_Munteanu> ZIP is a combination of LZ and Huffman, IIRC.
10:20:40 <sm> ack, -static doesn't work on mac
10:21:22 <c_wraith> I think -static has to do with haskell packages
10:21:32 <Axman6> sm: how have you managed to break your GMP.framework?
10:21:35 <c_wraith> I think you need to tell the linker
10:21:41 <c_wraith> Not ghc
10:21:51 <c_wraith> (which means you need the set linker option option)
10:21:58 <sm> c_wraith: right, I'm running gcc directly now
10:22:06 <monochrom> something about "optl"
10:22:11 <c_wraith> yes, that's the one
10:22:12 <sm> it understands -static, but the mac lacks some essential static system libs
10:22:14 <xplat> LZMA uses a range encoder, which is like a fractional encoder only not patented
10:22:39 <monochrom> ah, lacking the *.a files can't be helped
10:22:52 <Eduard_Munteanu> Unfortunately, I think there isn't a good way to get .a-s from .so-s.
10:22:57 <sm> Axman6: my GMP.framework isn't broken, it's just that other people don't have it
10:23:13 <xplat> the M part provides the probability model for the range encoder
10:23:32 <Eduard_Munteanu> xplat: yeah, Markov chains ring a bell (though vaguely)
10:23:46 <Eduard_Munteanu> I think I heard of them during a control theory course :)
10:24:11 <Axman6> sm: doesn't ghc compile statically by default?
10:24:14 <Axman6> hmm, maybe not
10:24:32 <Eduard_Munteanu> Axman6: yeah, as c_wraith said before, not for native (non-Haskell) libs.
10:24:33 <sm> not with system libs
10:25:04 <c_wraith> For native libs, it uses whatever the system linker does by default.  Which is usually dynamic linking
10:25:36 <Eduard_Munteanu> I think it does static linking on Windows/MinGW, IIRC.
10:25:53 <Eduard_Munteanu> (I need to do something like that soon, I'll just supply -optc-static for safety)
10:27:42 <sm> I guess everyone who has shipped a mac binary so far has bundled GMP.framework with it
10:27:43 <Eduard_Munteanu> sm: you could do dynamic linking and supply the missing .so. That could be neatly wrapped in a bash script, setting LD_LIBRARY_PATH (is there such a thing on Mac?) before calling the executable.
10:28:35 <c_wraith> sm: if you don't install GMP.framework, ghc doesn't link against it. :)
10:28:50 <Eduard_Munteanu> Or... you could build a static version of GMP.
10:28:56 <Eduard_Munteanu> That shouldn't be difficult.
10:29:02 <sm> c_wraith: aha, so it didn't come with ghc ? I wonder why I installed it ?
10:29:23 <Eduard_Munteanu> GHC does require GMP for Integers.
10:29:29 <kmc> if you're trying to build Haskell code with everything (even C libs) linked statically then you will run into the problem that glibc doesn't like to be linked statically on Linux
10:29:33 <sm> to uninstall it now means rebuilding my haskell environment.. all the tools depend on it
10:29:38 <Eduard_Munteanu> um, I mean the RTS.
10:29:52 <kmc> you can also build a GHC which does not use GMP; it can use an alternative "integer-simple" package
10:29:55 <monochrom> isn't computing fun
10:30:08 <kmc> but this must be set up when you build ghc, and not when you compile your code, unfortunately
10:30:12 <sm> Eduard_Munteanu: for doing what with integers exactly ? This app is doing integer and floating point operations without it
10:30:17 <Eduard_Munteanu> monochrom: not really, that's why we leave it to the computers :P
10:30:36 <kmc> afaik no platform uses integer-simple by default
10:30:40 <monochrom> yeah, I'm being sarcastic :)
10:30:43 <sm> kmc: good to know
10:30:48 <kmc> it's relatively new; was funded by the IHG due to license concerns about GMP
10:30:57 <lispy> http://www.dataists.com/2010/12/ranking-the-popularity-of-programming-langauges/   discuss!
10:31:13 <lispy> Haskell is actually pretty well ranked there
10:31:43 <Eduard_Munteanu> Haskell > Erlang?
10:31:44 <sm> Eduard_Munteanu: you say build a static version of GMP, what do you mean ? 
10:31:46 <Eduard_Munteanu> That's a new one.
10:32:17 <Eduard_Munteanu> sm: download a tarball of gmp, ./configure with the appropriate flags and 'make'
10:32:17 <kmc> maybe erlangers don't use StackOverflow or Github
10:32:23 <kmc> for whatever reason
10:32:42 <kmc> use of these tools correlates with a particular subset of programmers
10:32:49 <Eduard_Munteanu> I think it's something like --disable-shared --enable-static
10:32:53 <kmc> a particular subculture
10:33:54 <Eduard_Munteanu> "shell"? That's a bit nonspecific.
10:33:54 <kmc> i think it's hard to draw meaningful conclusions from such data, and i think it's mainly useful for starting flamewars
10:34:00 <Eduard_Munteanu> Yeah.
10:34:14 <sm> Eduard_Munteanu: and then what .. I still can't build a static app for the mac ?
10:34:37 <kafee> hello, why can't I do foldl1 (==) [1,2,3] ?
10:34:48 <sm> because of the aforementioned unavailable static system libs.. crt0.o is one
10:35:02 <Eduard_Munteanu> Though, since when did the Haskell subculture go online on stuff like SO? I thought they stayed in their ivory tower and churning out papers on FP :P
10:35:06 <kmc> kafee, because (==)'s type doesn't match a -> a -> a
10:35:12 <kmc> the error message should say that, roughly
10:35:16 <Axman6> :t foldl1
10:35:17 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:35:23 <kmc> 1 == 2 is False, now what's False == 3 ?
10:35:27 <kmc> a type error is what.
10:35:34 <kmc> > (1 == 2) == 3
10:35:35 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
10:35:35 <lambdabot>    arising from the literal `3'...
10:35:45 <Eduard_Munteanu> sm: that's the libc if I'm not mistaken, maybe you could assume that's the same .so everywhere?
10:35:47 <kmc> > ('x' == 'y') == 'z'
10:35:48 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:35:48 <lambdabot>         against inferred type ...
10:35:54 <sgs> Hi, why can I do [0..4] => [0,1,2,3,4] but the other way around [4..0] gives an empty list? I know I can to [4,3..0] but is there any reason I should know why it's done this way?
10:36:20 <mauke> sgs: because it's right
10:36:20 <kmc> sgs, it's more consistent
10:36:26 <Axman6> and useful
10:36:31 <sm> sorry, not following. To be clear, mac's gcc man page says of -static: "This option will not work on Mac OS X unless all libraries (including libgcc.a) have also been compiled with -static.  Since neither a static version of libSystem.dylib nor crt0.o are provided, this option is not useful to most people."
10:36:34 <kmc> the upper bound might be dynamically computed, and you want to handle the case of it being below the lower bound correctly
10:37:31 <Eduard_Munteanu> sm: hm, maybe not with static, but  perhaps you can statically link with the gmp .a only?
10:37:40 <Eduard_Munteanu> *with -static
10:38:21 * roconnor finds the galois connection between division and multiplication pretty neat
10:38:53 <sm> hm that sounds like another option to explore, thanks
10:39:12 <Eduard_Munteanu> sm: you might want to play with 'ld' directly; ask Haskell to output you a '.o' instead of linking as well.
10:39:58 <sm> sounds like lots of fun too. Well, I'll first play around with the current easiest workaround - running gcc without -framework GMP
10:40:10 <Eduard_Munteanu> Hm, that too.
10:44:24 <sm> dunno how to persuade ghc to do that. But compiling by hand is a start
10:44:31 <sm> thanks, all
10:44:32 * Eduard_Munteanu wished more projects published universal (fully statically-linked) binaries for Linux
10:45:09 <kmc> Eduard_Munteanu, glibc really doesn't like to be statically linked
10:45:18 <Eduard_Munteanu> sm: -c     Do not link
10:45:50 <Eduard_Munteanu> kmc: hm, I've seen a few such binaries. What problems could it cause?
10:46:12 <Eduard_Munteanu> sm: -C     Stop after generating C (.hc file)
10:47:01 * Eduard_Munteanu was actually about to stop Gentoo from making .a files, but then considered he could need to make static builds.
10:47:32 <sm> good. I wonder if all of this stuff is needed: -u _ghczmprim_GHCziTypes_Czh_static_info
10:47:59 <kmc> that's the info table for the data constructor of Char
10:48:20 <mauke> preflex: zdec zm zh
10:48:20 <preflex>  - #
10:48:22 <Eduard_Munteanu> GHC's output C code isn't really readable. I think JHC was better at that.
10:48:23 <kmc> Eduard_Munteanu, foo.c:(.text+0x5): warning: Using 'getpwent' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
10:48:40 <kmc> Eduard_Munteanu, s/getpwent/any other nsswitch-able function/
10:49:12 <Eduard_Munteanu> Grr... I wonder why. Maybe they use some LD_PRELOAD hacks for some functionality?
10:49:21 <kmc> it's because they're nsswitch-able
10:49:30 <kmc> it can plug in different name server modules dynamically
10:49:35 <Eduard_Munteanu> Uh.
10:49:40 <kmc> i don't know if LD_PRELOAD specifically is involved, but that's the idea
10:49:48 <kmc> you can build a special glibc that doesn't work this way
10:50:22 <Eduard_Munteanu> Yeah, there are a couple of alternate libcs too.
10:50:36 <Eduard_Munteanu> Mostly geared towards embedded / very small systems.
10:51:01 * Eduard_Munteanu wonders what busybox uses.
10:51:13 <kmc> busybox is sometimes built against uClibc
10:51:19 <kmc> i think it works with many libcs
10:51:25 <Eduard_Munteanu> Ah, neat.
10:51:45 <kmc> debian wants to switch to eglibc for everything
10:51:47 <endojelly> what libcs are there? i only know of glibc and ¬µlibc
10:51:53 <kmc> for reasons relating to the personality of the libc maintainer
10:52:03 <mauke> drepper--
10:52:14 <kmc> there's at least one bsd libc
10:52:30 <kmc> iirc android's libc is a frankenstein monster combo of that and glibc
10:52:44 <Eduard_Munteanu> Oh, btw, I read on LWN recently they're considering the possibility of embedding a libc with the kernel.
10:52:56 <monochrom> > "Haskell" > "Erlang"
10:52:57 <lambdabot>   True
10:52:59 <kmc> i mean every c compiler for every whack-ass obscure embedded system came with at least some libc
10:53:02 <monochrom> biased opinion :)
10:53:09 <mauke> endojelly: dietlibc
10:53:24 <kmc> Eduard_Munteanu, interesting. link?
10:54:07 <Eduard_Munteanu> kmc: http://lwn.net/Articles/417485/   (last story on the page)
10:54:20 <endojelly> mauke, for embedded systems, too, I guess?
10:54:36 <mauke> I don't know
10:55:00 <Eduard_Munteanu> Or initramfs/initrd images maybe.
10:55:50 <zygoloid> endojelly: there's a fairly comprehensive list of libcs here: http://www.uclibc.org/other_libs.html
10:56:04 <endojelly> zygoloid, great, thanks
11:09:51 <xplat> glibc's nssswitch plugin stuff is horrible, because it does cause that compatibility problem
11:10:48 <zygoloid> it kills fully-static linking ;(
11:11:01 <xplat> nssswitch has been around for so many years there's no excuse not to have a stable ABI so you can upgrade in-place
11:11:41 <xplat> nevermind the fact that when you static link you should be able to link in a basic set of nss modules
11:12:07 <sproingie> libc is horrible full stop
11:12:22 <sproingie> they should just rename it libmonolithicunixruntime
11:13:53 <leino> can someone tell me quickly why I get an occurs check error on: removeOne (x:xs) = [xs]:[x:ys | ys <- removeOne xs]
11:14:07 <adnap> is there an easy way to see what packages your code depends on, and subsequently all the packages that you packages depend upon?
11:14:40 <adnap> essentially i need to tell someone which packages to install without them having to figure it out for themselves
11:14:56 <mauke> leino: what is the type of that supposed to be?
11:15:09 <leino> mauke: removeOne :: [a] -> [[a]]
11:15:18 <leino> all ways of removing one element from a list
11:15:20 <unkanon> is that like tails?
11:15:24 <mauke> leino: then [xs] is wrong
11:15:27 <adnap> can't i create an auto-installer with cabal or something?
11:15:32 <mauke> [xs] : ... would give you [[[a]]]
11:15:48 <leino> doh!
11:15:54 <leino> fixed it now
11:16:17 <leino> > let removeOne (x:xs) = xs:[x:ys | ys <- removeOne xs]
11:16:17 <lambdabot>   not an expression: `let removeOne (x:xs) = xs:[x:ys | ys <- removeOne xs]'
11:16:18 * unkanon saw a glimpse of how a haskell master debugs his functions
11:16:38 <leino> anyways.. removeOne (x:xs) = xs:[x:ys | ys <- removeOne xs], is correct I think
11:16:46 <unkanon> > let removeOne (x:xs) = xs:[x:ys | ys <- removeOne xs]
11:16:47 <lambdabot>   not an expression: `let removeOne (x:xs) = xs:[x:ys | ys <- removeOne xs]'
11:16:51 <unkanon> > let removeOne (x:xs) = xs:[x:ys | ys <- removeOne xs] in removeOne "hello"
11:16:52 <lambdabot>   ["ello","hllo","helo","helo","hell"*Exception: <interactive>:1:137-185: Non...
11:17:09 <leino> aha
11:17:32 <leino> this is not the first time I get an occurs error when I would have wanted a type error :)
11:17:32 <adnap> what are you trying to do?
11:18:00 <xplat> > let { removeOne [] = []; removeOne (x:xs) = xs:[x:ys | ys <- removeOne xs] } in removeOne "hello"
11:18:01 <lambdabot>   ["ello","hllo","helo","helo","hell"]
11:18:09 <mauke> leino: uh, that is a type error
11:18:15 <leino> yeah of course the edge case
11:18:23 <adnap> what is removeOne supposed to do?
11:18:24 <Eduard_Munteanu> leino: technically it is a type error, in some cases it means you're implying a = f a
11:18:35 <unkanon> well yeah but how is that function useful? (I'm curious)
11:18:43 <mauke> it means "this would be valid if we allowed recursive types"
11:18:44 <Eduard_Munteanu> But I suspect some type systems might allow that.
11:18:52 <Eduard_Munteanu> Yeah.
11:18:53 <mauke> ocaml -rectypes
11:18:58 <Eduard_Munteanu> s/recursive/infinite ?
11:19:17 <monochrom> adnap: exploit cabal. write a project.cabal file with "build-depends:" empty. then try to build and enjoy the complaints. may need to iterate until no complaints.
11:19:18 <mauke> same thing
11:19:23 <mauke> you can't stop the recursion
11:19:35 <monochrom> oh wait, that isn't transitive.
11:21:14 <Eduard_Munteanu> I remember I could've used infinite types when playing with Peanos :)
11:21:54 <monochrom> use ghci to load a crucial module, preferrably the module that has your main. run some function, preferrably main. admire the multitude of "Loading package walahala-0.8.2 ... linking ... done.".
11:21:59 <Eduard_Munteanu> I wonder what it would take to actually implement them in Haskell.
11:22:27 <Eduard_Munteanu> (but first whether they're consistent)
11:22:30 <unkanon> adnap: I guess we'll never know what removeOne is good for :)
11:22:43 <monochrom> "[a] = [[a]]" is infinite types
11:22:55 <adnap> unkanon: i came in in the middle of the conversation, so i wasn't sure
11:23:05 <adnap> unkanon: at first i thought it was just tail
11:23:20 <unkanon> well I know what it does but I don't know why
11:23:29 <unkanon> yeah I thought he wanted tails actually
11:23:38 <Eduard_Munteanu> monochrom: yeah, I know. Generally for any type operator 'f', a = f a is an infinite type
11:24:07 <Eduard_Munteanu> s/is/implies/
11:26:01 --- mode: ChanServ set +o monochrom
11:26:31 <aristid> Eduard_Munteanu: monochrom will punish you for your error
11:26:48 <unkanon> lol
11:26:54 <Eduard_Munteanu> Heh.
11:27:03 --- mode: monochrom set -bbb *!*@c-67-175-21-246.hsd1.il.comcast.net *!*@74.198.148.18 *!*@190.189.27.206
11:27:58 <Eduard_Munteanu> Maybe this would allow arbitrary type-level Peanos at compile time: toPeano :: Int -> Mu Succ; toPeano 0 = Zero; toPeano n = Succ . toPeano $ n - 1     -- ?
11:28:25 <Eduard_Munteanu> It'd be just like looking for a fixed-point of that.
11:28:55 <Eduard_Munteanu> (seems very natural as well)
11:29:06 --- mode: monochrom set -bb *!*@188.247.74.24 *!~USCHostin@*
11:29:10 --- mode: monochrom set -o monochrom
11:29:28 <unkanon> well you can make that work now except for the Int -> Mu Succ business, right?
11:29:49 <kmc> (Mu Succ) is type-level omega, isn't it?
11:29:51 <Eduard_Munteanu> Not really, IIRC you needed rank-2 types to hide the infinite type.
11:29:59 <kmc> "fix succ" is value-level omega
11:30:04 <kmc> :t fix (In . Just)
11:30:05 <lambdabot> Mu Maybe
11:30:26 <Eduard_Munteanu> kmc: mm, I'm thinking the type-level Y combinator.
11:30:37 <kmc> i know
11:30:38 <Eduard_Munteanu> Succ (Succ (...))
11:30:42 <kmc> that's omega
11:30:55 <Eduard_Munteanu> Really? I didn't think omega had any use.
11:31:05 <kmc> omega the ordinal number
11:31:11 <xplat> in this case it ... doesn't have much use
11:31:15 <Eduard_Munteanu> It was \x -> (x x) (x x)
11:31:18 <Eduard_Munteanu> IIRC.
11:31:18 <kmc> omega is the set of all naturals
11:31:21 <kmc> that's a different thing named omega
11:31:30 <kmc> sorry for the confusion
11:31:32 <xplat> toPeano 0 doesn't belong to your type, so you get a type error
11:31:35 <Eduard_Munteanu> Ah, I saw that in TAPL.
11:31:46 <kmc> by the way, not all fixed point combinators are called "Y combinator"
11:31:54 <kmc> Y = Œªf.(Œªx.f (x x)) (Œªx.f (x x))
11:31:56 <kmc> it's a specific one
11:32:06 <kmc> (which does not typecheck in Haskell)
11:32:12 <Eduard_Munteanu> xplat: hm true, I could use an accumulating parameter and supply a value that corresponds to toPeano 1.
11:32:40 <Eduard_Munteanu> kmc: yeah, I know, TAPL mostly concerns itself with the strict Y combinator, they say it's Z.
11:33:11 <kmc> can you actually write a type-level Y combinator?
11:33:12 <Eduard_Munteanu> (it has an additional 'y', in there, can't remember now)
11:33:21 <kmc> perhaps with type families
11:33:24 <Eduard_Munteanu> Ah, I'm not sure, they mostly talk about the value-level one.
11:33:30 <xplat> anyway you can't make a function from value-level integers to type-level integers
11:33:34 <Eduard_Munteanu> kmc: isn't Mu exactly that?
11:33:44 <Eduard_Munteanu> Type-level fix?
11:33:45 <kmc> Eduard_Munteanu, no.  it's a fixed point combinator on types, sure
11:34:00 <kmc> but as i was saying, the Y combinator is a *specific* lambda term Œªf.(Œªx.f (x x)) (Œªx.f (x x))
11:34:22 <kmc> you are using the terms "fixed-point combinator" and "y combinator" interchangeably
11:34:28 <kmc> when they are not equivalent
11:34:29 <Eduard_Munteanu> kmc: yes, but let f be a type operator and x a type variable.
11:34:43 <kmc> Y is extensionally equivalent to any other fixed point combinator
11:34:46 <Eduard_Munteanu> It looks the same to me :).
11:34:49 <monochrom> To find type-level analogues of value-level things, simply replace Œª by Œõ :)
11:34:54 <kmc> but to say "the Y combinator" is to identify a particular term
11:35:05 <Eduard_Munteanu> Ah, that's a point.
11:35:23 <kmc> there's infinitely many different fixed-point combinators
11:35:40 <kmc> (fun fact: the set of fixed point combinators is recursively enumerable; i believe this is a fairly recent result)
11:36:12 <Eduard_Munteanu> I'm not sure exactly how a fixed-point combinator is defined though.
11:36:49 <monochrom> my_combinator f = f (my_combinator f)
11:37:17 <Eduard_Munteanu> @src fix
11:37:17 <lambdabot> fix f = let x = f x in x
11:37:22 <Eduard_Munteanu> Oh, makes sense.
11:37:31 <kmc> the definition is that "fix f === f (fix f)"
11:37:39 <Eduard_Munteanu> Yeah.
11:37:42 <monochrom> the "=" there is not "definition". it is equality for real.
11:37:45 <kmc> and it happens that "fix f = f (fix f)" suffices to actually define "fix" in Haskell
11:37:48 <Eduard_Munteanu> But I suppose 'fix' could be something more complex.
11:38:01 <kmc> but we use the "let" version instead, as it uses asymptotically less space sometimes
11:40:56 <Eduard_Munteanu> Is the Z combinator of any use in a language like Haskell?
11:41:31 <Eduard_Munteanu> (the Y-like combinator from "strict" languages)
11:44:52 <mm_freak> ok, cabal problem: cabal: cannot configure ListLike-1.1.0. It requires mtl >=1.1.0 && <1.2
11:45:04 <mm_freak> another package, which i need, requires mtl 2
11:45:11 <mm_freak> is there anything i can do about this?
11:45:23 <c_wraith> mm_freak: hack .cabal files
11:45:38 <mm_freak> is this the only option?
11:45:46 <c_wraith> Bug the maintainer of ListLike
11:45:47 <kmc> yell at the ListLike maintainer
11:45:55 <c_wraith> Those are your only two options, really
11:45:56 <mm_freak> i see
11:46:01 <mm_freak> ok, thanks
11:46:10 <kmc> "break your project up into two packages"
11:47:17 <mm_freak> oh, wait
11:47:26 <mm_freak> seems like 'cabal install' doesn't update deps automatically
11:47:48 <mm_freak> updating ListLike manually seems to help
11:49:36 <roconnor> why do I keep getting sucked into the world of category theory when doing haskell programming?
11:49:40 <duckinator> .....lot of good that did :( brb
11:51:29 <duckinator> back
11:52:55 <monochrom> what you need is a dual category theory so it keeps repelling you :)
11:53:02 <mm_freak> roconnor: i don't‚Ä¶  it's only when you want it =)
11:53:15 * sm doesn't
11:53:42 <mm_freak> in fact i have no idea about CT, only the very basics, and i still do a lot of haskell programming
11:54:21 <Twey> It's very tempting, though
11:54:47 <roconnor> mm_freak: but it is so sweet to say that my multiplate is a monoidal natural transformation from a (functor from applicative functors to types) to itself.
11:54:55 <roconnor> mm_freak: even though I didn't know that when I wrote it
11:55:52 <monochrom> I don't treat category theory differently from other math. It's just another algebra-like thing like "y . f x = g y . x". Notice I don't use commuting diagrams.
11:56:34 <roconnor> monochrom: me too.  I wrote out the multiplate laws like that. ... even before I knew that were the same laws as a monoidal natural transformation.
11:56:59 <monochrom> ah, duplicate invention/discovery is common.
11:57:12 <monochrom> this is why the Go language happens :)
11:57:38 <roconnor> I wrote the library well before I knew all the categorial stuff.
11:58:07 <roconnor> monochrom: did you see http://r6research.livejournal.com/23705.html ?
11:58:13 <monochrom> no
11:58:44 <roconnor> It all started with that observation of mine.  That the standard laws for getter and setters are exactly the laws of a coalgebra for a comonad
11:58:57 <roconnor> then I translated those laws up to multiplate
11:59:19 <roconnor> and found out they tranlate to exactly the lwas of a monoidal natural transformation
11:59:33 <roconnor> it's all crazy
12:00:15 <roconnor> none of these three sets of laws look like they are related to me.
12:00:24 <roconnor> or at least they wouldn't have before I knew better
12:00:46 <roconnor> now I can squint and see hints of them in each other.
12:04:34 <cole> Does anyone know of anyone, any group, who is looking for a haskell programmer?
12:04:47 <roconnor> cole: did you check on haskellers.com?
12:05:04 <cole> no. I will though.
12:05:14 <roconnor> There are no active job listings.
12:05:15 <roconnor> :(
12:05:25 <kmc> did you check the CUFP jobs board?
12:06:07 <mm_freak> roconnor: you could probably write a whole book about the CT aspects of my contstuff library
12:06:12 <mm_freak> well‚Ä¶  you could
12:06:17 <mm_freak> i couldn't, because i have no idea about CT =)
12:06:25 <kmc> cole, Allston Trading was looking for someone
12:06:31 <kmc> read backlogs of haskell-cafe
12:06:38 <roconnor> mm_freak: which library is that?
12:06:44 <mm_freak> roconnor: contstuff
12:08:20 <roconnor> nice
12:08:26 <roconnor> we need more comonad stacks :P
12:12:39 <romanandreg> is there a way to know if a list is infinite?
12:12:42 <romanandreg> like
12:12:46 <romanandreg> isInfinite :: [a] -> Bool
12:12:47 <romanandreg> ?
12:12:54 <mauke> how would that work?
12:13:02 <mauke> psychic powers?
12:13:29 <monochrom> there is no way
12:13:33 <mauke> romanandreg: http://en.wikipedia.org/wiki/Halting_problem
12:13:43 <mm_freak> roconnor: unless you solve the unsolvable halting problem, no
12:13:54 <mm_freak> - roconnor + romanandreg 
12:14:20 <jon_of_arc> romanandreg: no, but you can know if it's not infinite ;)
12:14:22 <mm_freak> a haskell list is a program, and you want to know, whether that program ends
12:14:30 <roconnor> >> isInfinite twinPrimes
12:14:33 <roconnor> True
12:14:38 <mm_freak> jon_of_arc: you can't
12:14:54 <romanandreg> mm_freak: that makes sense
12:14:58 <jon_of_arc> mm_freak: sure you can. Advance along it looking for []
12:14:59 <roconnor> mm_freak: yes jon can
12:15:10 <mm_freak> jon_of_arc: and if you don't find []?
12:15:19 <mauke> then you don't know it's finite
12:15:20 <ziman> then it's infinite!
12:15:20 <ziman> :2
12:15:25 <jon_of_arc> mm_freak: Then you keep looking :)
12:15:28 <romanandreg> lol
12:15:30 <romanandreg> yeah
12:15:31 <romanandreg> makes sense
12:15:32 <mm_freak> yes, forever ;)
12:15:34 <romanandreg> I was just wondering
12:15:35 <romanandreg> that's all
12:15:37 <monochrom> english is ambiguous. "you can know if xs is finite" has two different interpretations.
12:15:46 <mm_freak> monochrom: yeah, true
12:15:47 <jon_of_arc> mm_freak: exactly. You return that it's finite or _|_
12:16:03 <mauke> isFinite _ = True
12:16:14 <monochrom> formally, one interpretation is "semi-decision" and the other is "decision"
12:16:17 <mauke> PROVE ME WRONG
12:16:17 <mm_freak> jon_of_arc: ok, how do you /return/ ‚ä•, if ‚ä• denotes a nonreturning function? =)
12:16:18 <conal> isFinite might be useful with lub
12:16:18 * roconnor 's implemenation of == for his CReals are like that.  It either returns False or _|_.  Not sure why anyone would use it :D
12:16:22 <Boxo> > let isInfinite xs = case xs of {[] -> False; (z:zs) -> isInfinite zs} in isInfinite "abcde"
12:16:23 <lambdabot>   False
12:16:24 <conal> (partial isFinite)
12:16:45 <roconnor> interesting
12:16:51 <roconnor> these things might be useful with lub
12:16:52 <jon_of_arc> mm_freak: ok, I'm short a cup of afternoon caffeine and am using imprecise language :)
12:16:58 <monochrom> @quote monochrom debates
12:16:58 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
12:17:00 <mm_freak> hehe
12:17:34 <conal> yeah. i bet there are some very powerful techniques waiting to be discovered in programming with lub
12:17:53 <mauke> all you need is lub
12:17:58 <conal> :)
12:18:07 <conal> mauke: good one.
12:18:07 <roconnor> :
12:18:11 <roconnor> *lol*
12:18:19 <mm_freak> in these cases only one can help
12:18:20 <unkanon> the halting problem only affects turing complete languages, so just put a cap on a language and you can do away with the halting problem
12:18:27 <mm_freak> our toot toot super hero!
12:18:28 <monochrom> the haskell kind of non-strictness can be implemented by lazy evaluation. the lub kind of non-strictness can be implemented by crazy evaluation.
12:18:32 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
12:18:33 <unkanon> like, lists can only be 1 million elements in size
12:18:33 <lambdabot>   ("TOOTOOT","ASCIICAT")
12:19:10 <roconnor> unkanon: not in haskell
12:19:26 <roconnor> in agda you can write isInfiniteList _ = False.
12:19:35 <shachaf> unkanon: Or just use a strict language, for that matter. Lists are guaranteed finite.
12:19:37 <roconnor> at least for inductively defined lists
12:19:56 <conal> programming with limited list lengths would be programming with finite precision numbers.
12:20:16 <unkanon> we only have finite precision numbers anyway
12:20:21 <roconnor> conal: you mean like how it is in "Real Life"?
12:20:31 <unkanon> right :)
12:20:41 <conal> roconnor: i was thinking more like digital life.
12:20:49 <roconnor> @quote ultrafinite
12:20:49 <lambdabot> No quotes match. Maybe you made a typo?
12:20:52 <roconnor> @quote ultrafinit
12:20:52 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
12:21:43 <unkanon> they say you only need, what, 20 digits of pi for any application ?
12:21:46 <monochrom> @quote <monochrom>
12:21:46 <lambdabot> <monochrom> says: the selfish program's motive is to fool the programmer
12:22:11 <unkanon> you'd be off by one inch if you calculated the circumference of the universe or something like that
12:22:37 <roconnor> an inch is huge!
12:22:45 <monochrom> But you don't just calculate the circumference of the universe.
12:22:53 <conal> unkanon: for composability, we'd want more precision.
12:22:55 <roconnor> how many atoms can I fit in a cubic inch?
12:23:03 <Rotaerk> it's over nine thousand light years
12:23:26 <roconnor> Rotaerk: that seems conservative
12:23:30 <unkanon> conal: how much more? not much more I think.
12:23:52 <conal> unkanon: as much more as you want to compose.
12:24:04 <roconnor> unkanon: depends on if you are trying to predict the behaviour of unstable systems
12:24:08 <Rotaerk> roconnor, yea I figured it was a safe guess
12:24:16 <monochrom> Indeed, compositions. If you calculate the circumference of every planet and add them up and so on so forth, truncation errors show up much earlier.
12:24:18 <conal> unkanon: limiting precision is limiting composition, assuming you care about correctness.
12:24:26 <conal> http://conal.net/blog/posts/why-program-with-continuous-time/ -- unkanon
12:24:29 <unkanon> I see now
12:25:00 <monochrom> There are probably enough planets to exhaust your 20 digits.
12:25:23 <conal> "programming is more about the middle than the end". so the amount of precision needed in the end isn't very relevant to how much is needed in the middle.
12:26:11 <conal> (quote from that blog post)
12:26:19 <shachaf> monochrom: My 20 digits can only count to 2^20. I'm quite sure there are.
12:26:22 <monochrom> well, relevant, but not proportionally.
12:26:46 <monochrom> n digits at the end may require 4^n digits inside.
12:27:20 <conal> monochrom: or even 1 digit of output may require 4^m, where m has to do only with composition.
12:27:24 <unkanon> conal: I understand it now, I think
12:27:30 <conal> s/digit/bit
12:28:04 <roconnor> of course discrete is just continuous with the discrete topology :P
12:28:08 <monochrom> this is why people should never opine, period.
12:28:09 <conal> and so i'm very dubious about any claims that Float or Double is "good enough"
12:28:41 * roconnor always begins his programs with default CReal.
12:28:50 <kmc> surely the selfish program's motive is to be copied, whether through helpfulness or duplicity
12:28:56 <Twey> conal: You look very jolly in your blog picture :√æ
12:29:15 <conal> Twey: :) thx. most of the time i'm a pretty happy guy.
12:30:18 <djahandarie> Laughter is the best medicine
12:30:49 <Twey> Good article
12:31:03 <conal> :)
12:31:06 <Twey> I think a lot of lower-level coders don't really get that
12:33:36 <conal> Twey: maybe a lot of haskellers also, considering that we still mostly use low-level numerics.
12:33:58 <conal> ie machine-oriented, composability-thwarting numerics.
12:34:02 <quicksilver> I don't know. I think smart people know this.
12:34:12 <quicksilver> but they don't have an alternative which is adequately fast
12:34:26 <quicksilver> so they accept the risk of precision problems
12:34:38 <quicksilver> (and try to measure / test their boundaries)
12:34:57 <conal> quicksilver: i think so also. what i wonder is why there isn't more work on inventing & engineering practical correct/composable numerics.
12:35:06 <conal> more maybe there is plenty of work and i don't notice it.
12:35:13 <quicksilver> I bet someone has done some work on it.
12:35:22 * quicksilver wonders if roconnor knows
12:35:58 <quicksilver> conal: I spent a *long* time thinking about it quite a long time ago, trying to work out how to do a mandelbrot viewer with infinite zoom.
12:36:24 <quicksilver> conal: it took me weeks to convince myself that there was no clever solution - arbitrary zooming into a mandelbrot set really *does* require arbitrary precision.
12:36:49 <conal> quicksilver: cool. great driving application for lazy exact numerics
12:38:09 <roconnor> quicksilver: it isn't known if madelbrot is computable
12:38:28 <roconnor> quicksilver: though it is semidecidable, so we do know algorithms that work if it is computable.
12:41:01 <quicksilver> roconnor: sure, although of course I wasn't really trying to compute the *actual* set
12:41:16 <quicksilver> roconnor: I was just illustrating the number of iterations before divergence with pretty colours, like most pepople do :)
12:41:33 <mreh> i've always wondered what determines the order of the arguments in fold*
12:41:36 <mreh> :t foldl
12:41:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:41:47 <roconnor> quicksilver: by a computable compact set, I mean that it can be approximated arbitrarily closely by finite sets.
12:43:28 <Twey> As quicksilver says
12:43:56 <Twey> I'd much rather use CReal everywhere.  In practice, though, it tends to fall below the level even of ‚Äòacceptably fast‚Äô.
12:44:41 <Twey> mreh: It's the way we conceive of them‚Ä¶ Cale has a nice diagram somewhere
12:45:06 <roconnor> Twey: ya, it becomes quite slow for any signifgant nesting
12:45:09 <conal> infinitely zoomable mandelbrot could be a great example around with to rally some creative thought & engineering work on practical correct numerics.
12:45:22 <roconnor> Twey: sometimes I'm tempted to use it in finacial computations
12:45:24 <conal> as an alternative to the wrong-vs-slow choice we have now.
12:45:36 <Twey> Yeah
12:46:17 <conal> quicksilver: do you have a blog?
12:46:52 <conal> i like blogging as a way to exchange ideas with some clarity but while still partially baked.
12:46:58 <Evious> Can QuickCheck be used to test non-pure code?
12:47:10 <Twey> Evious: Not AFAIK
12:47:13 <conal> Evious: what kind of properties would you like to check?
12:47:19 <Twey> Evious: That's why we have HUnit
12:47:57 <Evious> I'd like to know if the Erlang quickcheck equivalents are missing a feature, or if it's just a limitation of using types to test code. 
12:49:01 <thoughtpolice> i do remember a paper that described using quickcheck to check IO a values, i think the name was 'beauty in the beast' or somesuch
12:49:02 <conal> i'm curious about what properties one could even formulate about IO code.
12:49:28 <Evious> IO, probably not. But a more restrictive monad, like State?
12:49:46 <Evious> Or a Network/Socket monad.
12:50:26 <Twey> We could formulate all sorts of interesting stuff if IO weren't opaque.
12:50:37 <conal> Evious: if your particular type (monad or not) has a clear semantics, you'll be able to formulate useful properties.
12:50:47 <roconnor> Twey: let's make IO into a free monad!
12:50:49 <conal> Evious: eg State has a simple meaning.
12:50:51 <roconnor> free IO!
12:50:55 <Twey> Hehehe
12:51:19 <thoughtpolice> ah, here we go - http://www.cs.nott.ac.uk/~txa/publ/beast.pdf
12:51:34 <ziman> why does IO need to be opaque?
12:51:57 <unkanon> so that the programmer doesn't try to get too smart with it
12:51:59 <roconnor> ziman: 'cause no one knows what it really is
12:52:02 <unkanon> and taint his pure functions
12:52:38 <conal> hm. i like ziman's question.
12:52:43 <Twey> ziman: To allow for varying implementations, AIUI
12:52:51 <monochrom> I agree. Abstraction is one way to say "I may change it later".
12:53:06 <DDave> Hello, can somebody explain me what the "dot" means in the following line?    nub . (mapreduce words_with_P (++))
12:53:12 <conal> abstraction -- that's my best understanding also
12:53:17 <monochrom> This is why in OOP no one knows what an object is, either. :)
12:53:19 <unkanon> DDave: it means composition
12:53:26 <ziman> I imagine IO as (State [Instruction]) where the resulting impure program gets composed, for example
12:53:37 <unkanon> DDave: so that the result of the expression on the right of the . is fed as an argument to the stuff on the left of it
12:53:49 <Boxo> (f . g) x = f (g x)
12:53:51 <ziman> (but that might be completely wrong in some respects...)
12:53:55 <DDave> Oh, thank you unkanon  and Boney 
12:53:55 <monochrom> DDave: in particular f . g = \x -> f (g x)
12:53:57 <DDave> Boxo* sorry
12:54:46 <conal> if IO had a denotation, then i'd have a clearer reason for wanting the representation to be hidden.
12:54:51 <unkanon> DDave: that looks like some interesting code you're working on there, btw
12:55:03 <revenantphx> Thanks everyone for the book recommendations.
12:55:05 <conal> e.g. i wouldn't want a syntactic/free interface.
12:55:06 <DDave> unkanon, Indeed it is.. if I could only figure out how to use it ;)
12:55:15 <monochrom> SPJ wanted a denotation for IO 10 years ago.
12:55:18 <revenantphx> They came today and as soon as I finish my report I can start reading.
12:55:18 <tibbe> Does Haskell define a tab as 8 spaces for purpose of layout?
12:55:23 <revenantphx> monochrom: thanks especially for hte nice list.
12:55:27 <conal> (which would violate the semantics)
12:55:31 <monochrom> you're welcome
12:55:37 <dino-> No tabs!
12:55:37 <unkanon> tibbe: I think it's just for the purpose of having a standard
12:55:49 <unkanon> but as dino said you shouldn't be using tabs in haskell anyway
12:55:55 <unkanon> DDave: :)
12:56:03 <tibbe> unkanon: sure, but when I search-and-replace tabs for 8 spaces the code fails to compile
12:56:29 <roconnor> tab /= 8 spaces
12:56:31 <monochrom> because tab doesn't simply mean "insert 8 spaces here".
12:56:41 <unkanon> for haskell it does, no?
12:56:52 <unkanon> a tab and 8 spaces should be interchangeable in haskell I thought
12:56:54 <roconnor> it means insert enough spaces to make the column number a multiple of 8, or something like that
12:56:56 <monochrom> rather "insert enough spaces to align to the next 8k column"
12:57:10 <monochrom> so it is a global thing, not a local thing.
12:57:17 <revenantphx> Tab is '\t', 8 spaces is '\20\20\20\20\20\20\20\20
12:57:29 <monochrom> as in, you have to know your absolute coordinates
12:57:38 <aristid> > showHex 32
12:57:39 <lambdabot>   Overlapping instances for GHC.Show.Show
12:57:39 <lambdabot>                              (GHC.B...
12:57:40 <roconnor> it's comonadic :P
12:57:44 <aristid> :t showHex
12:57:45 <lambdabot> forall a. (Integral a) => a -> String -> String
12:57:50 <Twey> > showHex 32 ""
12:57:51 <lambdabot>   "20"
12:57:52 <tibbe> roconnor: I see
12:58:00 <unkanon> but if tibbe replaces each tab with 8 spaces shouldn't the resulting code run if the previous code did?
12:58:01 <aristid> Twey: i was about to type that :P
12:58:05 <monochrom> example: "hi\ty" -> "hi    y" 6 spaces
12:58:08 <tibbe> roconnor: (I'm trying to fix the random mix of spaces and tabs in the network package)
12:58:24 <revenantphx> \t moves ahead to the nearest tab stop, which is editor defined.
12:58:29 <roconnor> tibbe: be sure your program does something in the whitespace langauge
12:58:32 <revenantphx> There's no rule that says "a tab means this many spaces"
12:58:41 <tibbe> roconnor: haha
12:58:55 <tibbe> revenantphx: I thought the report defined something
12:59:02 <unkanon> yeah me too
12:59:11 <unkanon> I thought it specifically said 1 tab = 8 spaces
12:59:32 * hackagebot oeis 0.3.0 - Interface to the Online Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/oeis-0.3.0 (BrianLewis)
12:59:51 <unkanon> tibbe: do you have only leading tabs on that file or tabs in between text as well?
12:59:55 <monochrom> We're talking about Haskell 98 and Haskell 2010. It defines how it treats \t. I know you're a liberal guy and you like to use \t as you see fit, but we're talking about communicating with a Haskell interpreter properly, not your human rights.
12:59:57 <roconnor> revenantphx: the haskell 98 report says "Tab stops are 8 characters apart." in section 9.3
13:00:06 <unkanon> try doing s/^\t+//g
13:00:22 <roconnor> revenantphx: and then it says ``A tab character causes the insertion of enough spaces to align the current position with the next tab stop. 
13:00:25 <tibbe> unkanon: both, but if I could fix the leading tabs that would be a start. emacs untabify fails for some reason
13:00:50 <revenantphx> roconnor:I don't think the Haskell 98 report is the definitive source for how all editors use tabs.
13:00:56 <roconnor> tibbe: maybe you need to set emac's tabstops to 8
13:01:04 <monochrom> no, not talking about editors at all.
13:01:07 <roconnor> revenantphx: the topic is Haskell I believe
13:01:10 <revenantphx> "Oh hey, this is John at Eclipse, we're going to switch our tabs to match the Haskell 98 report, kk?"
13:01:15 <unkanon> tibbe: run something like the regex I just showed you
13:01:17 <revenantphx> Yeah I got that.
13:01:26 <unkanon> try doing s/^\t+/        /g
13:01:35 <unkanon> that's still not it, but you get the idea
13:01:39 <monochrom> Perhaps you should take a look at the channel name?
13:01:47 <revenantphx> #haskell...
13:01:50 <revenantphx> why is it unboxed :\
13:01:54 <roconnor> :D
13:01:58 <monochrom> haha
13:01:58 <c_wraith> that would be Haskell#
13:02:06 <revenantphx> c_wraith: touche.
13:02:12 <monochrom> anyway no one is criticizing editors.
13:02:18 * revenantphx criticizes editors.
13:02:21 <c_wraith> Which kind of sounds like a .NET language, actually
13:02:29 <roconnor> ``to avoid visual confusion, programmers should avoid writing programs in which the meaning of implicit layout depends on the width of non-space characters
13:02:44 <revenantphx> roconnor: I cannot agree more >_>
13:03:07 <revenantphx> Dealing with people who write python with tabs.. hnnnh,
13:03:40 <qeeeewx> It's easy enough to write myself, but for the sake of science, does anyone know the standard way of generating a list that counts backwards? List ranges such as [10..1] don't work. I remember there being a way, but I've long since forgotten.
13:03:52 <unkanon> > [10,9..1]
13:03:54 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
13:04:13 <c_wraith> > [10,8..1]
13:04:14 <qeeeewx> unkanon: Oops. Now I feel stupid.
13:04:15 <lambdabot>   [10,8,6,4,2]
13:04:25 <qeeeewx> Thanks.
13:04:31 <unkanon> np
13:04:40 <revenantphx> > let backwards = 10 : [x | x <- tail backwards - 1] in backwars
13:04:41 <lambdabot>   Not in scope: `backwars'
13:04:49 <revenantphx> > let backwards = 10 : [x | x <- tail backwards - 1] in backwars
13:04:50 <lambdabot>   Not in scope: `backwars'
13:04:51 <tibbe> sucess!
13:04:53 <revenantphx> > let backwards = 10 : [x | x <- tail backwards - 1] in backwards
13:04:54 <lambdabot>   No instance for (GHC.Num.Num [a])
13:04:54 <lambdabot>    arising from a use of `e_1101' at <int...
13:04:57 <revenantphx> darn.
13:05:06 <unkanon> please don't declare backwars, we have enough wars already
13:05:11 <mtnviewmark> tibbe - both SubEthaEdit and TextMate will detabify text correctly even with tabs mid-line 
13:05:16 <revenantphx> > let backwards = 10 : [x | x <- (tail backwards) - 1] in backwards
13:05:18 <lambdabot>   No instance for (GHC.Num.Num [a])
13:05:18 <lambdabot>    arising from a use of `e_1101' at <int...
13:05:24 <tibbe> mtnviewmark: my emacs tabstop was incorrect
13:05:29 <mtnviewmark> ah
13:05:41 <mtnviewmark> nm - surely emacs can detabify!
13:05:47 <monochrom> > let backwards = 10 : [y | x <- tail backwards, let y = x - 1 ] in backwards
13:05:51 <lambdabot>   mueval-core: Time limit exceeded
13:05:56 <monochrom> > let backwards = 10 : [y | x <- tail backwards, let y = x - 1 ] in take 5 backwards
13:06:00 <lambdabot>   mueval-core: Time limit exceeded
13:06:08 <monochrom> well, at least it type-checks :)
13:06:40 <mtnviewmark> actually, I always wanted tabs to act like column indicators mid-line in source I want:   foo bar\t--la la\nvery long thing and stuff\t-- fa fa
13:06:47 <mtnviewmark> I want the comments in those to line up
13:07:01 <monochrom> and oh, these runaway programs accumulate and slow down lambdabot to an eventual hang
13:07:36 <b6> who's in charge of lambdabot?
13:07:48 <unkanon> gammabot
13:07:56 <monochrom> I use an editor that does that. tab creates tabstop on spot.
13:08:22 <monochrom> But it is dead. http://www.cs.nott.ac.uk/~rcb/mathspad/
13:08:59 <monochrom> Also a bit involved to set up. But once setup you will never write LaTeX manually again!
13:09:28 <unkanon> I never wrote latex manually. that sentence also works without "manually".
13:09:41 <monochrom> You are blessed.
13:09:49 <tibbe> the diff now shows exactly how messed up the whitespacing in network was
13:09:56 <tibbe> it's amazing that it actually compiles
13:09:57 <unkanon> from seeing latex snippets, I believe you
13:10:06 <revenantphx> I still don't get the whole \blah[x,y,z]{a,b,c}
13:10:18 <revenantphx> I never understood the different between the arguments in [] and in {}
13:10:26 <revenantphx> difference*
13:10:26 <kmc> the [] args are optional
13:10:33 <revenantphx> Aaaah, so that's it >_<
13:10:57 <monochrom> The greatest wonder for you is that #math people (both efnet and freenode) prefer to see "D \cup \alpha" rather than "D ‚à™ Œ±"
13:11:09 <thoughtpolice> my resume is written in latex, and holy crap does writing it manually suck. math equations are no problem because the latex math syntax is used all over and pretty well known, but in general, damn
13:11:26 <revenantphx> what do you mean manually?
13:11:31 <dino-> thoughtpolice: Something like lyx help with that?
13:11:35 <revenantphx> as in using the latex syntax for everything?
13:11:49 <revenantphx> Instead of like a WYSIWYG type editor?
13:11:53 <jmcarthur> thoughtpolice: pandoc is awesome since it lets you write markdown and then convert to latex :)
13:11:56 <thoughtpolice> yep, my resume is ridiculously small and I figured it was worth a try. i could probably re-do it in lyx in 5 seconds now, i just haven't bothered
13:12:02 <monochrom> usually the arguments in [] are optional arguments. that's why.
13:12:03 <dino-> I keep my resume in plain ascii text with idiot line breaks. Not ideal.
13:12:15 <thoughtpolice> jmcarthur: yes, I use pandoc for everything on my site (via hakyll)
13:12:19 <jmcarthur> although i guess markdown might not be great for resume
13:13:00 <revenantphx> My resume is a quine.
13:13:15 <unkanon> my resume is written in crayon and markers
13:13:23 <thoughtpolice> i still have not figured out how to get hakyll + pandoc with highlighting to work, though :( code highlighting support should be enabled by default in pandoc IMO, highlighting-kate isn't that big of a dependency
13:13:27 <revenantphx> I also wrote my resume using dd
13:13:32 <sproingie> ascii for me too.  that's what the recruiters turn it into anyway 
13:13:48 <dino-> sproingie: They bitch that it's not Word. But too bad.
13:13:55 <b6> my resume is a blank piece of paper and when they hold it up to look at it i punch through it into their face. /eot
13:13:58 <sproingie> well ascii or word.  rtf if it's word
13:14:07 <revenantphx> rtf is nice.
13:14:13 <sm> another linking question. On linux, why does ghc --make -optl-static ... spew a bunch of link errors if the app uses gtk ?
13:14:19 <sproingie> they like word because they have macros that pull out headings and bullet points
13:14:34 <sproingie> but they basically flatten it to ascii anyway
13:14:40 <sm> like /usr/lib/gcc/x86_64-linux-gnu/4.4.1/../../../../lib/libcairo.a(cairo-matrix.o): In function `_cairo_matrix_to_pixman_matrix':
13:14:41 <sm> (.text+0xeb1): undefined reference to `pixman_transform_point_3d'
13:14:48 <dino-> I suppose maintaining resume in html isn't a bad idea.
13:15:01 <revenantphx> dino-: It's easy to publish :\
13:15:26 <dino-> And can be structured, rely on css for presentation details.
13:15:27 <monochrom> I write my r√©sum√© with magnetic bananas, magnetic envelopes, magnetic lenses, and magnetic barbed wire.
13:15:27 <sproingie> meh.  i just maintain it on linkedin
13:15:31 <sproingie> havent for many a year tho
13:15:36 <revenantphx> Make all your formatting generated at load-time via JS (and then CSS).
13:15:44 <revenantphx> that way they can c/p the source if they want ascii.
13:16:14 <revenantphx> Also, make sure you use enterprise javascript.
13:16:23 <sm> oh I guess I need to add more -llibs
13:16:31 <revenantphx> (http://enterprise-js.com/)
13:17:05 <thoughtpolice> can i use enterprise javascript with node.js to scale to the clouds?
13:17:32 <sproingie> "Prefixing Variable Names With an Abbreviation of Their Type"
13:17:38 <monochrom> haha nice "this is a joke" "enterprise javascript is creating really random numbers"
13:17:41 <sproingie> sadly, i have seen hungarian notation in quite a lot of js
13:17:53 <dino-> sproingie: That's very sad.
13:18:14 <monochrom> and "for (var i = 0; i < 9001; i++)" a rub on the number 9001 :)
13:18:18 <revenantphx> "FUNCTION CALLS ARE EXPENSIVE, ALWAYS EVAL A FUNCTION'S CODE"
13:18:40 <revenantphx> We should have an Enterprise Haskell page...
13:18:53 <shapr> H2EE
13:19:15 <revenantphx> Enterprise Haskell is: Just Monads‚Ñ¢
13:19:22 <monochrom> "enterprise haskell is:  UNSAFEPEFORMIO . UNSAFEINTERLEAVE"
13:19:30 <revenantphx> XD
13:19:58 <revenantphx> "Enterprise Haskell is using unsafePerformIO on every line, just to keep it pure."
13:20:00 <monochrom> "enterprise haskell is: reverse (x:xs) = reverse xs ++ [x]"
13:20:01 <sproingie> unsafePerformEnterprise
13:20:42 <monochrom> eh, there is also enterprise css!
13:20:46 <revenantphx> Yep.
13:20:48 <revenantphx> And HTM.
13:20:51 <revenantphx> L*
13:20:59 <revenantphx> It pulls it all off a git repository.
13:21:07 <revenantphx> js is the best one though.
13:21:39 <monochrom> "enterprise css is: using hard-core abstractions" and then a lot of examples of ".w140 {width:140px !important;}" ".w187 {width:187px !important;}" etc. :)
13:21:55 <bavardage> I have some type screwyness happening: https://gist.github.com/736832 the first piece of code here compiles and works correctly, but the second bit refuses to compile
13:22:02 <bavardage> it dies with type errors
13:22:05 <Twey> ENTERPRISE JAVASCRIPT IS: USE BITWISE OPERATORS FOR ARRAY BOUNDS CHECKS
13:22:07 <bavardage> but howcome the first one works?
13:22:12 <sproingie> monochrom: i actually had some use for that trick once
13:22:14 <Twey> Hahahaha, this makes me laugh
13:22:27 <bavardage> (even dies if I put the constraints of cos , i.e. test2 :: Fractional a => (a -> a) -> String
13:22:27 <xplat> roconnor: isn't the selection comonad just a zipper for a function type?
13:22:32 <sproingie> monochrom: mind you it was for prototyping a design that was rewritten for proper css later
13:22:32 <Twey> Hahaha
13:22:34 <bavardage> (superpose returns string)
13:22:39 <monochrom> well, you don't really want to call it "w140"
13:23:19 <sproingie> the trick was that things had hardwired sizes already and we wanted to get rid of them, so we moved it all into css classes.  then we deliberately started breaking those
13:23:28 <sproingie> whatever didn't render right needed something else fixed
13:23:29 <roconnor> xplat: I only know how to define a zipper for recursive types
13:23:33 <monochrom> oh, of course.
13:23:34 <revenantphx> I just noticed, Awodey is at CMU. If I have any questions I'll trap him in a closet and force him to answer.
13:24:04 <monochrom> He knows how to dualize so you become the one trapped and he escapes.
13:24:18 <revenantphx> D:
13:24:56 <revenantphx> He can't if he doesn't *know* he's trapped in the clost...
13:25:13 <revenantphx> I'll just have to move his entire office into the closet. It's a math professor's office... I'm sure it will fit ;D
13:26:24 <sproingie>  // <- plenty of room for comments here
13:26:31 <sproingie> that's gotta be my favorite
13:27:29 <sm> pixman_transform_point_3d is defined in /usr/lib/pixman-1.*, ghc is happily linking with -lpixman-1, but it still says this is an undefined reference, how can this be ?
13:32:05 <revenantphx> sproingie: that one was pretty great.
13:32:30 <revenantphx> Someone go fork it and make an enterprise haskell we can contribute too >_<
13:32:34 <sm> my link command: https://gist.github.com/736861
13:33:04 <sproingie> Enterprise Haskell Monads
13:33:37 <revenantphx> "Enterprise Haskell is: remarkably non-existant"
13:33:41 * revenantphx prepares for flame war.
13:33:51 <c_wraith> type EnterpriseT = IdentityT
13:33:52 <revenantphx> (I'm just playing off the stereotype, don't shoot me)
13:33:59 <revenantphx> c_wraith: XD
13:34:28 <c_wraith> That would be the strict identity transformer, by the way.
13:34:46 <revenantphx> In other words, it does just abot nothing?
13:35:12 <revenantphx> (except being strict)
13:35:22 <c_wraith> No, for a transformer, being strict does nothing.
13:35:31 <revenantphx> Ah, gotcha.
13:35:32 <c_wraith> err, wait, it would be lazy.
13:35:38 <revenantphx> ¬¨‚Äì¬¨
13:35:40 <c_wraith> gah, right.  newtype = lazy
13:35:44 <c_wraith> I need to remember that
13:35:50 <revenantphx> Yeah. Jeez.
13:37:34 * revenantphx is trying to decide what to read first.
13:41:05 <tibbe> reading the network code is like time travel
13:41:12 <tibbe> back to the early days of haskell
13:41:18 <monochrom> poor you
13:42:01 <monochrom> this is an excellent window for you to learn from history. remember: those who have learned from history are bound to helplessly watch it repeat again and again. :)
13:42:33 <Adamant> monochrom: history doesn't repeat itself, but it does on occasion rhyme
13:42:37 <Adamant> - Mark Twain
13:42:41 <monochrom> OK!
13:44:09 <Adamant> revenantphx: do we mean Enterprise as in Getting Shit Done or as in a hypothetical Real Company that tends not to actually exist and would in any case be better served by other technologies?
13:44:30 <revenantphx> As in "shit haskell that people who don't know better think is a good idea"
13:44:52 <revenantphx> "an work for companies who purportedly trying to get shit done" 
13:45:11 <Adamant> 500,000 line objects it is, then
13:45:49 <revenantphx> Enterprise Haskell is: Managing your salary information in a hard-coded record
13:46:19 <monochrom> You can almost algorithmically lurk in #haskell for beginner code and add to your enterprise haskell collection
13:46:43 <revenantphx> Or I could just use 99% of the code I attempt to type into lambdabot.
13:46:46 <monochrom> The prime example is the "mapReduce" "recursionEngine" thing we're now so familiar with. :)
13:46:51 <revenantphx> What...?
13:47:15 <revenantphx> (brb)
13:48:16 <sproingie> yeah that thing is enterprisey
13:48:50 <Adamant> I am sure Shatner will be pleased
13:49:16 <monochrom> http://www.google.ca/search?q=site%3Ahpaste.org+mapReduce  have fun.  See also http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010/Week_4._Oct_14#mapReduce
13:51:17 <kmc> needs more higher rank types
13:57:36 <Zvpun> I read in the converting numbers wiki that one can construct Rational values using the % operator but I seem to miss something since typing into ghci 1%4 says not in scope: %.
13:57:53 <mauke> type: import Data.Ratio
13:57:54 <kmc> import Data.Ratio
13:58:07 <mauke> also, 1/4 :: Ratio
13:58:10 <mauke> 0.25 :: Ratio
13:58:12 <mauke> er
13:58:14 <mauke> Rational
13:58:30 <Zvpun> thank you
13:59:29 <Zvpun> could you add this to the haskellwiki? I can imagine that this is new to the people that read this part.
14:12:57 <phao> Hi
14:13:10 <phao> In a book I'm reading, the author uses this notation very often: a op b
14:13:19 <phao> and he said that this is the same as op a b
14:13:25 <phao> for all functions that takes two arguments
14:13:28 <phao> ops
14:13:30 <phao> a 'op' b
14:13:33 <phao> not a op b
14:13:39 <phao> but ghci doesn't seem to accept it
14:13:53 <jao> a `op` b
14:13:57 <phao> ah right
14:14:05 <aristid> > 4 `min` 5
14:14:05 <lambdabot>   4
14:20:11 <unkanon> phao: which book is that?
14:20:24 <unkanon> is he bolding the op at least?
14:20:44 <unkanon> I have a book that bolds the op instead of putting backticks around it
14:21:17 <phao> Programming in Haskell
14:21:27 <unkanon> hmm ok
14:21:30 <phao> doesn't bold it
14:22:14 <unkanon> weird
14:28:30 <dino-> If the op is punctuation, like + or >>= then it's:  a + b  or  (+) a b
14:32:05 <adnap> how can i tell which function in my program is eating up memory over time?
14:32:20 <adnap> can someone give me specific profiling instructions?
14:32:56 <sproingie> use a heap profiler
14:33:09 <sproingie> there's a nice one for eclipse, i forget its name
14:34:13 <adnap> oh god not eclipse
14:34:31 <TTimo> lol
14:34:35 <TTimo> seconded
14:34:47 <adnap> eclipse my free hard drive space
14:35:08 <unkanon> there's certainly a command line tool to do that?
14:35:26 <adnap> i think there is a way to run the program with a command line arg that generates heap info
14:35:40 <adnap> i tried to do it once with someone on here, but we had trouble
14:36:13 <adnap> it gaves us a file with data points, and we were supposed to be able to turn that into a figure, but it didn't work.  i can't remember what we did though.
14:37:26 <c_wraith> hp2ps?
14:37:59 <c_wraith> I mean, compile with profiling on, run it with the necessary profiling options to dump profiles
14:38:08 <adnap> yes
14:38:17 <c_wraith> Then, if you got a heap profile, run hp2ps to convert the dump into a visualization
14:38:19 <adnap> i just can't remember what the arguments are
14:38:25 <mm_freak> again i'm facing the choice between the iteratee and the enumerator packages‚Ä¶  what would be your choice?
14:38:45 <c_wraith> from sanity's perspective, enumerator
14:38:53 <adnap> i need to figure out which function is causing endless memory consumption
14:39:15 <mm_freak> c_wraith: what other perspectives are there?
14:41:35 <unkanon> adnap: when you do, and if you have a blog, please make a blog post about it for future reference for us all :)
14:42:10 <adnap> unkanon: i don't have a blog but i could maybe put something on the haskell wiki
14:45:05 <Saizan> ?google ghc heap profiling
14:45:06 <lambdabot> http://www.haskell.org/ghc//docs/latest/html/users_guide/prof-heap.html
14:45:06 <lambdabot> Title: 5.4.ÔøΩProfiling memory usage
14:47:00 <unkanon> adnap: that'll work :)
14:47:51 <adnap> it takes so much longer to run the program with profiling on
14:48:00 <adnap> also, what is a cost-centre stack?
14:50:26 <adnap> unkanon: it was actually pretty easy.  this is the guide i was using before: http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
14:50:54 <adnap> the graph it made kind of sucks though
14:51:15 <adnap> all the color keys are in greyscale, and it's hard to tell which grey corresponds to which piece of the program
14:51:32 <Saizan> adnap: use -c
14:51:41 <adnap> Saizan: :D
14:51:44 <Saizan> hp2ps -c
14:51:48 <adnap> Saizan: ooo
14:53:10 <adnap> aw man
14:53:21 <adnap> the thing that is spiking is called "OTHER"
14:58:54 <adnap> by default, everything in a module is visible, right?
14:59:20 <alpounet> yes
15:00:57 <mjrosenb> i'm guessing that I can't tell ghc to optimize based on the fact that I don't care what order the elements of a list are in, can I?
15:04:03 <Cale> mjrosenb: Not really...
15:04:59 <adnap> I'm reading this page: http://en.wikibooks.org/wiki/Haskell/Packaging trying to figure out how to make a cabal package.  How am I supposed to determine what my build depends on?  There are so many things I'm sure.
15:05:05 <byorgey> mjrosenb:out of curiosity,  what sort of optimization would you hope to get?
15:05:06 <Cale> mjrosenb: There might be some tricky RULES pragmas that you could tell it with regard to the list operations you're using, but you definitely would want to start a new list library in that case.
15:05:25 <Cale> (I don't know exactly what optimisations you have in mind either)
15:05:45 <byorgey> adnap: one way is to just not put any dependencies and try to build it with 'cabal install', and see what it complains about.  then add that dependency, and repeat.
15:06:10 <adnap> byorgey: that's so awful though
15:06:37 <Cale> adnap: Well, which modules are you using?
15:06:47 <adnap> Cale: modules or libraries?
15:06:57 <Cale> modules, which will tell you which libraries
15:07:26 <Cale> It's sort of your responsibility to determine which packages you're relying upon.
15:07:30 <adnap> Cale: I'm using hmatrix, GPipe, Data.Vec, Data.Vec.LinAlg, Data.Vec.LinAlg.Transform3D, Data.Vec.AABB, maybe others
15:07:35 <Cale> okay
15:07:43 <adnap> Cale: what about what those depend on?
15:07:54 <Cale> You don't have to explicitly put those.
15:08:27 <adnap> and I don't have to put version numbers?
15:08:33 <Cale> Unless you import modules from something, it's not a direct dependency.
15:08:50 <Cale> Hackage will tend to complain at you, but I think you're still allowed to leave version numbers off.
15:09:15 <adnap> i'm not putting on hackage yet anyway
15:09:21 <adnap> i just need my prof to be able to install it
15:12:17 <adnap> does it generate the LICENSE file that i specify in the cabal file, or do i have to provide that?
15:12:43 <byorgey> adnap: you have to provide it.
15:13:00 <byorgey> adnap: but note that if you use 'cabal init' it will auto-generate most of the various types of LICENSE files
15:13:19 <byorgey> although be sure to save your existing .cabal file somewhere else first if you use it
15:13:59 <adnap> holy crap
15:14:01 <adnap> cabal init?
15:14:06 <adnap> why didn't i see that
15:14:14 <adnap> i thought i had to make the file myself
15:14:26 <jmcarthur> cabal init -m is nice too, for the record
15:14:40 <jmcarthur> i prefer not having all those comments sprinkled all over it
15:14:52 <kmc> or you can copypasta your last project's .cabal file
15:15:01 <jmcarthur> i think you can also set up a template for cabal init to use
15:15:04 <bitte> hello, do you know some algorithm to find contiguous substrings such as "na" in "banana" ?
15:15:11 <adnap> i've never made a cabal package
15:15:45 <byorgey> jmcarthur: you can't, but that would be a nice feature
15:16:16 <adnap> I think this is outdated: http://en.wikibooks.org/wiki/Haskell/Packaging
15:16:16 <mjrosenb> byorgey: i was thinking munge l = map fst l ++ map snd l => munge' l = concatMap (\(x,y) -> [x,y]) l
15:16:48 <mjrosenb> byorgey: if you don't care what order your list is in, they are equivalent, and one is much faster (or at least I assume it is)
15:21:12 <ddarius> What's GHC going to do with size types?
15:21:40 <djahandarie> That's what I thought when I read that thing
15:21:44 * djahandarie doesn't remember what it was
15:21:50 <djahandarie> Galois crypto stuff?
15:22:12 <c_wraith> mjrosenb, I'm not sure either of those is going to be faster than the other, with list fusion.
15:22:20 <adnap> how do i separate build dependencies?  I tried commas and just spaces.  There's only one dependency in the example on the web page.
15:22:32 <sipa> bitte: kmp?
15:22:46 <adnap> spaces failed to parse, and after trying commas, it said the packages were missing
15:22:51 <monochrom> build-depends: base >= 3 && < 5, mtl >= 2 && < 1
15:22:57 <adnap> ohh
15:23:10 <monochrom> without versions: build-depends: base, mtl
15:23:24 <sproingie> mtl being >=2 and < 1 would be hard to satisfy
15:23:25 <mjrosenb> c_wraith: if nothing, i'd imagine that the second is more memory efficient, since you can theoretically start gc'in elements of l sooner.
15:23:30 <adnap> monochrom: the second one doesn't seem to work
15:23:32 <monochrom> yeah, that's a joke :)
15:23:33 <mjrosenb> *nothing else
15:23:36 <adnap> monochrom: that's what i initally tried
15:23:50 <monochrom> mtl >= 0 && < 13
15:24:34 <adnap> monochrom: it said, "at least the following dependencies are missing: package1 -any, package2 -any," etc
15:24:55 <adnap> monochrom: which doesn't make any sense since i've run my own program before
15:25:16 <monochrom> build-depends: base, mtl, package1, package2
15:25:32 <adnap> yeah, i've done that
15:25:45 <monochrom> then it cannot be reproduced.
15:25:45 <adnap> unless casing matters with "build-depends"
15:26:06 <adnap> but it said every single dependency was missing, which cannot be true
15:26:09 <sproingie> case matters
15:26:20 <monochrom> casing matters. build-depends: cAbAl  will not work. no such package.
15:26:35 <adnap> no, just "Build-Depends: cabal"
15:26:57 <adnap> i followed this: http://en.wikibooks.org/wiki/Haskell/Packaging#Add_a_build_system
15:26:59 <monochrom> there is no such package as cabal either. there is Cabal
15:27:02 <sproingie> you'd think cabal would be implicit in a .cabal
15:27:05 <adnap> it it's wrong then that's annoying
15:27:35 <adnap> i did not mess up the casing on the actual package names.  I just have 
15:27:43 <adnap> "Build-Depends" capitalized like so
15:27:51 <sproingie> oh duh i guess you would use it to depend on a version of cabal
15:27:53 <monochrom> that part should be fine
15:29:10 <adnap> if i specify the exact version then i can just list it right?  i don't need == or anything, yeah?
15:29:17 <monochrom> use ==
15:29:56 <monochrom> unless you can find the exact clause in the cabal manual itself that allows some alternatives.
15:29:57 <handonson> is Data.ByteString in hackage currently broken?
15:30:05 <handonson> [5 of 8] Compiling Data.ByteString  ( Data/ByteString.hs, dist/build/Data/ByteString.o )
15:30:05 <handonson> Data/ByteString.hs:1959:21: Parse error in pattern
15:32:04 <adnap> monochrom: when do i need && and when can i use commas?  once you said i could use commas if the version number was unspecified.
15:32:27 <monochrom> 1. always use commas. comma separates two packages
15:32:39 <adnap> monochrom: then what is && for?
15:32:48 <monochrom> 2. for each package, use && to separate the lower bound and the upper bound
15:33:07 <monochrom> <monochrom> build-depends: base >= 3 && < 5, mtl >= 2 && < 1
15:33:12 <monochrom> that clearly contains a comma
15:33:21 <adnap> oh, that makes perfect sense
15:34:14 <monochrom> is your irc font monospace or proportional-width?
15:34:54 <adnap> what about more specific version numbers?  one of my packages has versions 0.1.0 and 0.1.1 available.  would i just put > 0?  Can I also put > 0.1.1?
15:34:58 <adnap> monochrom: monospace
15:35:15 <monochrom> you can use > 0.1.1
15:42:57 <adnap> omg i think i did it finally
15:43:14 <sm> dcoutts: what could I try to troubleshoot cabal configure dying with non-zero exit status, with -v3 showing no error message ? cabal install shows "ExitFailure 11"
15:43:25 <dtm99> Hey all. I'm just wondering what is the best way to uninstall an existing version of ghc and then reinstall a later one. I have installed the Haskell Platform on Ubuntu, which comes with ghc-6.12.1. However, I want to upgrade to ghc-6.12.3. Should I first uninstall ghc, and if so how? Given that 6.12.1 is the latest version of ghc in the ubuntu repository, what is the easiest way to install 6.12.3?
15:44:11 <ddarius> You don't need to uninstall an older version to install a newer version.
15:44:25 <ddarius> However, just use the package manager to uninstall the old version if that's what you want to do.
15:44:27 <monochrom> you can install 6.12.3 in /usr/local or even /usr/local/your-directory and it will not conflict with ubuntu a bit.
15:44:50 <monochrom> and yeah, independent decide the fate of 6.12.1
15:45:01 <monochrom> s/independent/independently/
15:45:21 <sshc> How do I depend on the library of a cabal package?
15:45:50 <monochrom> but 6.12.1 has a nasty package bug. I recommend incinerating it altogether. http://www.vex.net/~trebla/haskell/sicp.xhtml#ghc6121
15:46:01 <sshc> To be less confusing, I'm adding an executable to a cabal package which exports a library, and I want to use a module of that library.
15:46:30 <sshc> Sshould I add the package name to build-depends?
15:46:43 <sshc> Or simply not add anything at all?
15:46:52 <aavogt> sshc: I think you have to add itself as a dependency
15:46:59 <aavogt> at least that worked last I tried it
15:47:20 <phao> Hi... is add just a syntactic sugar for _add? http://ix.io/1iW
15:47:23 <sshc> I'll try that, thanks
15:47:36 <sshc> I won't be able to actually test it for a while
15:47:50 <phao> like (define (a b c) (+ b c)) is the syntatic sugar for (define a (lambda (b c) (+ b c)) in scheme (for those who know scheme).
15:48:18 <monochrom> phao: I forgot whether there is a fine print that says "no, here is counterexample" but practically yes
15:48:29 <ddarius> monochrom: An unusable system is a stable system.
15:48:37 <phao> monochrom, ok
15:48:46 <aavogt> _add may be slower
15:49:21 <aavogt> since an optimizing compiler might not remove that indirection
15:49:24 <nettok> Hi
15:49:56 <phao> right... I thought one would become the other
15:50:05 <phao> like some kinda of textual substitution
15:50:11 <phao> before compiling or interpreting the code
15:51:29 <nettok> How do i "foldl" over the boxed values of a list of Maybe's ?
15:51:47 <phao> I'm starting to not like the "Programming in Haskell" book
15:51:58 <nettok> I want to make a "and" function, but the list is something like [Just True, Just False, ...]
15:52:01 * ddarius is pretty sure nettok is abusing the term "boxed."
15:52:10 <dtm99> Thanks monochrom
15:52:34 <ddarius> nettok: And what do you want to happen with the Nothings?
15:52:41 <nettok> ddarius: The truth is I don't know what is the right term for what i want to say
15:52:46 <nettok> ddarius: Nothings are already filtered
15:53:11 <pheaver> nettok: maybe you should remove the Justs when you filter the Nothigns
15:53:16 <ddarius> nettok: Why are you producing a list of Justs?  Why not produce a list of the values themselves.
15:53:36 <monochrom> roll back, use catMaybes to both filter out Nothing and convert the Just's.
15:53:46 * djahandarie feels like it has to do with actually using 'filter'
15:53:48 <nettok> pheaver, ddarius: good idea :)  I'll try that
15:54:03 <monochrom> > catMaybes [Nothing, Just "saying hi", Nothing, Just "saying bye"]
15:54:04 <lambdabot>   ["saying hi","saying bye"]
15:54:14 <aavogt> list comprehensions are an import-free alternative to catMaybes
15:54:32 <ddarius> catMaybes is a super handy function.
15:55:27 <sipa> wouldn't catJusts be a more appropriate name?
15:55:42 <jmcarthur> how would catNothings even work?
15:55:44 <monochrom> meaningful name war again
15:56:05 <monochrom> but catJusts suggests that it doesn't know what to do with Nothing
15:56:20 <monochrom> catMaybes suggests it can handle all Maybes.
15:56:28 <ddarius> monochrom: I'm telling you, getting rid of all these people will make your life simpler and happier.
15:56:36 <aristid> :t concatMap (maybe [()] (const []))
15:56:37 <lambdabot> forall a. [Maybe a] -> [()]
15:56:43 <aristid> jmcarthur: ^ catJusts
15:56:47 <dtm99> Hey monochrom, would apt-get autoremove ghc6 suffice to 'incinerate' ghc-6.12.1?
15:56:49 <aristid> argh, catNothings
15:57:05 <monochrom> I don't know what autoremove does.
15:58:10 <dtm99> hmm, neither do I it appears. I should have said apt-get remove?
15:58:39 <aristid> :t concatMap (maybe [] return)
15:58:40 <lambdabot> forall a. [Maybe a] -> [a]
15:58:44 <dtm99> I guess my question is do I need to fiddle around anywhere else ...e.g. with cabal?
15:58:55 <monochrom> I think apt-get remove works.
15:59:01 <dtm99> Cool thx.
15:59:31 <monochrom> I normally use aptitude.
15:59:50 <sm> dtm99: to completely purge your setup, I think this will work: apt-get purge haskell-platform; apt-get autoremove; rm -rf /var/lib/ghc-6.12.1 ~/.ghc ~/.cabal
15:59:53 <ddarius> I believe autoremove removes packages that were installed as dependencies but whose dependents are no longer installed.
16:00:15 <ddarius> I usually use synaptic though, since I'm usually searching for a package.
16:01:27 <phao> monochrom, funny
16:01:37 <monochrom> I search with aptitude too. I enter ^git$ so I am not trolled by millions of things like libpython-git-wicked-gui
16:01:38 <dtm99> Thanks ddarius. I guess that would mean I have to reinstall everything in the haskell platform? Or am I going to have to do that anyway?
16:01:53 <dtm99> @sm
16:01:53 <phao> having add x y = x + y, and doing :t (add 1)
16:01:53 * lambdabot will count to five...
16:02:09 <phao> gives me the type of a function that takes a number and returns a number
16:02:37 <ddarius> dtm99: You're going to have to do that anyway.
16:02:51 <romildo> Hi.
16:02:58 <monochrom> if you use ghc 6.12.3 you will have to install a newer haskell platform, and unlikely from ubuntu. try this: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
16:03:04 <sm> if you're contemplating a purge, you could also just try installing the HP first and see how it works. I'm about to do it myself
16:05:14 <romildo> I want to download a page on the web in a Haskell program I am writing. In a browser the page can be downloaded by submitting a form which uses the POST method. In a terminal I can download the page using curl with the command line: curl --data "search=Bourne" http://www.interfilmes.com/busca.html
16:05:34 <romildo> I need help on writing a Haskell function to do the same.
16:05:55 <ddarius> You could just use the curl bindings...
16:06:11 <dtm99> ah ok. Oh well. thanks for your help guys. So to clarify, if I want to build the haskell platform from source, I should purge my current haskell platform, then install the appropriate ghc, then use the new ghc to build the haskell platform?
16:07:19 <ddarius> You don't have to do anything to your installed libraries.
16:07:21 <monochrom> purging your current haskell platform is up to you. there is little interference.
16:08:06 <monochrom> then again I admit I recommended purging it
16:09:11 <dtm99> I think I'm just going to purge everything. Thanks.
16:10:01 <sm> monochrom: is there any reason not to use ubuntu's ghc 6.12.1 to built the latest HP ?
16:10:06 <sm> build
16:10:17 <romildo> ddarius, do you (or anybody else) have any tips on how to use the Network.Curl module for this? I have never done it before, and the documentation of the module is not that clear.
16:10:35 <sm> I mean, does the warning you gave in your nice doc apply to that combo ?
16:12:19 <Eduard_Munteanu> sm: any luck at that static linking problem? (I might hit that sometime.)
16:12:23 <mtnviewmark> sm: you want to use 6.12.1 to build and install HP 2010.2.0.0?
16:12:33 <Eduard_Munteanu> (Though I stay away from Macs :) )
16:12:45 <sm> mtnviewmark: no, 2010.2.0.0 of course
16:12:54 <sm> er, yes. What you said.
16:13:37 <sm> Eduard_Munteanu: I didn't spend any more time attempting to build in GMP, I just ran the linker commands by hand to omit it
16:13:46 <mtnviewmark> hmmm... there is a chance that that won't work - in that something in 2010.2.0.0 might rely on an extension or core lib in 6.12.3 that isn't in 6.12.1 --- but barring that, should work
16:13:48 <sm> all tests passing, so...
16:13:48 <mtnviewmark> no harm in trying
16:13:49 <Eduard_Munteanu> Oh, so it worked, nice.
16:14:03 <mtnviewmark> good then - that is perfectly viable environment to use then
16:14:31 <sm> mtnviewmark: sorry, that was to Eduard_Munteanu. Thanks for the advice
16:15:14 <Nubkakes> Hey can anyone help me clean up some code? I got a couple of functions that I think can be cleaned up a little.
16:15:14 <sm> Eduard_Munteanu: and next time I install ghc or HP on mac, I'll try to do without GMP.framework from the start
16:16:32 <mtnviewmark> sm: next time you install on a Mac, hopefully you can use the HP all-in-one installer!
16:16:43 <sm> mtnviewmark: yay! 
16:16:47 * mtnviewmark is the current Mac OS X Haskell Platform maintainer
16:17:18 <sm> thanks for working on that. FYI the issue I had was trying to build a portable binary that doesn't dynamically link GMP.framework
16:17:44 <sm> I don't know if HP will still build haskell executables that do that
16:18:08 <mtnviewmark> It is a GHC issue, not an HP issue, actually
16:18:12 <Eduard_Munteanu> Hm, I think HP uses GMP, that's a reasonable choice I think.
16:18:34 <mtnviewmark> but I think in GHC 7.0.1 that is now static
16:18:39 <mtnviewmark> (but don't quote me on that)
16:18:48 <sm> right, I guess I'm looking ahead to when "HP" includes a ghc
16:18:55 <Eduard_Munteanu> It does.
16:19:17 <Eduard_Munteanu> You only need a GHC when compiling HP.
16:19:20 <mtnviewmark> right - today as two installers, tomorrow as one-- but the one is just rebuilt from the "official" GHC one
16:19:22 <Eduard_Munteanu> s/a/another/
16:19:40 <mtnviewmark> right HP will install on a mac that has never heard of Haskell before!
16:19:55 <sm> and will the executables it builds ?
16:20:22 <sm> maybe with 7.x, it sounds like
16:21:00 <Eduard_Munteanu> I use HP in Wine as a substitute for cross-compiling stuff for Windows platforms, statically linked and all that.
16:21:06 * sm also solved an ubuntu glibc bug to build linux binaries today
16:21:39 <sm> Eduard_Munteanu: oh nice. I've done that a bit, but having new troubles.. maybe I can pick your brains when I try again
16:22:19 <Eduard_Munteanu> :)
16:23:28 <Eduard_Munteanu> The only thing is I had trouble with getting gtk2hs to work. I could only do it with an older platform and the pre-Cabal gtk2hs binaries.
16:23:46 <dtm99> Hey guys, I'm now having trouble installing ghc-6.12.3 from the tar.bz2 binary. When I invoke .\configure, it complains with something like: ghc-pwd: cannot execute binary file. I'm probably doing something stupid, any suggestions? Thanks.
16:25:18 <dtm99> i.e. I want to install the build from here: http://www.haskell.org/ghc/dist/6.12.3/ghc-6.12.3-i386-unknown-linux-n.tar.bz2
16:25:38 <ezyang> Does this data type have a name? data Foo = S Foo 
16:26:06 <Eduard_Munteanu> ezyang: isn't that malformed?
16:26:07 <ddarius> Stream () (almost)
16:26:15 <ddarius> Eduard_Munteanu: No.
16:26:20 <ezyang> Eduard_Munteanu: Nope, cuz I can put bottom in it. 
16:26:35 <ezyang> ddarius: Maybe Stream Empty? 
16:26:44 <Eduard_Munteanu> Oh. How does that constructor fixity works?
16:26:52 <ddarius> for data Empty; yes.
16:27:17 <ezyang> What's the definition of Sream? 
16:27:21 <ezyang> *Stream 
16:27:34 <ddarius> data Stream a = Cons a (Stream a)
16:27:41 <ezyang> ah. :-) 
16:27:46 <adnap> is base >= 4 usually sufficient, or for such an important package, are specific version numbers preferred?
16:28:19 <Eduard_Munteanu> ddarius: mind explaining that a bit?
16:28:31 <ddarius> Eduard_Munteanu: Explaining what?
16:28:41 <Eduard_Munteanu> ddarius: how 'S Foo' is a valid rhs there.
16:28:51 <ddarius> Eduard_Munteanu: Why do you think its not valid?
16:29:13 <deadguys> hi all.  does anyone know how to get a profiling-enabled ghc on arch?
16:29:19 <Eduard_Munteanu> ddarius: because you can only have normal constructors, like Foo ..., or infix like a `Foo` b
16:29:33 <Eduard_Munteanu> ddarius: and you do need constructors for data decls
16:29:45 <aavogt> deadguys: it is in my experience
16:29:50 <ddarius> Eduard_Munteanu: Foo is not a data constructor.
16:30:07 <sshc> How do I determine whether a socket is already bound for a given port?
16:30:12 <Eduard_Munteanu> ddarius: oh, you mean 'S' is.
16:30:16 <Eduard_Munteanu> I see it now, nevermind :)
16:30:23 <aavogt> deadguys: but additional libraries are not built with profiling, so use cabal-install instead
16:30:32 * Eduard_Munteanu needs Haskell glasses.
16:30:46 <ddarius> Eduard_Munteanu: Foo is a type constructor, so you may want to be more careful with using "constructor" by itself.
16:31:10 <Eduard_Munteanu> Yeah, I meant data constructor.
16:32:24 <lpsmith> ok,  I'm a "par" noob.   I want to understand the difference between these three implementations of a function:  http://hpaste.org/42241/mappair
16:33:02 <sshc> How do I determine whether a socket is already bound for a given port?
16:33:11 <sm> Eduard_Munteanu: impressive, my hat is off to you (gtk2hs in wine/windows)
16:33:48 <deadguys> aavogt:  thanks.
16:34:25 <lpsmith> so if I demand the first element of the result,  and ignore the second,  does "par" force some level of evaluation of the second anyway?
16:34:25 * ddarius doesn't recall having any particular troubles building/using gtk2hs in (real) Windows, seven or eight years ago.
16:34:42 <ddarius> par doesn't force anything semantically.
16:35:09 <adnap> holy crap... haskell for 8 years...
16:35:55 <deadguys> aavogt:  now I'm getting "dynamic linking required, but this is a non-standard build (eg. prof)" after "loading ffi..."  any idea what that means?
16:35:59 <adnap> how long have you all been programming in haskell?
16:36:08 <lpsmith> I've been using haskell for 12 years, though the first year was slow going.
16:36:16 <adnap> this is my first year :)
16:36:38 <adnap> i bet the tutorials are a lot better now
16:36:57 <sproingie> lot better than the Gentle Introduction i can tell you that
16:36:58 <aavogt> deadguys: nope. Some more context could help
16:36:59 <Eduard_Munteanu> sm: gtk2hs-0.10.1 (binary), HP 2009.2.0.1 (binary too)  -- if you ever need it.
16:37:11 <lpsmith> ddarius, so what is the difference between the three variants in my hpaste,  or is there none?
16:37:11 <adnap> i read gentle intro, but then halfway through i discovered lyah
16:37:22 <sproingie> LYAH is freakin awesome
16:37:29 <Eduard_Munteanu> sm: might be due to Wine issues I couldn't make it work it through Cabal with newer versions.
16:37:29 <ddarius> lpsmith: There is no semantic difference.  That's the point of par.  It doesn't change semantics.
16:37:46 <sproingie> RWH is about 90% awesome but seriously needs good editing
16:38:01 <lpsmith> ddarius, I understand there is no *semantic* difference,  but I'm talking *operational* semantics :)
16:38:03 <adnap> i haven't read that yet
16:38:16 * ddarius still thinks the Gentle Introduction is one of the best introductions.
16:38:21 <lpsmith> err, operational differences
16:38:32 <sproingie> i'd read it after LYAH.  some parts may confuse you but a lot of it is due to editing and some dubious choices of examples
16:38:33 <Eduard_Munteanu> I've been doing so for about a year more or less reasonably I suppose (though I think I started about 2 yrs ago).
16:38:48 <lpsmith> adnap, I started learning Haskell from a book on SML :-P
16:38:49 <sproingie> the weird Doc abstraction in the prettyprinter is never explained well
16:38:56 <adnap> i didn't have many troubles with gentle intro--the examples were a bit harder--but it was kind of dull
16:38:57 <lpsmith> (supplemented with the gentle introduction)
16:39:50 <Eduard_Munteanu> sm: I mainly used it because Chart needed it.
16:40:40 <sm> Eduard_Munteanu: that's why I want it too
16:40:41 <ddarius> lpsmith: Each par creates a spark.  More pars mean more sparks.
16:40:59 <Eduard_Munteanu> Heh, I just went "okay, what if I do this assignment in Haskell, unlike others who choose C, PHP etc.".
16:41:19 <sm> Chart actually only needs cairo & pango, but depends on gtk by default
16:41:28 <deadguys> aavogt: http://hpaste.org/42242/ghc_make_prof_error
16:41:29 <Eduard_Munteanu> Yeah.
16:42:28 <aavogt> deadguys: you're doing the build yourself?
16:42:48 <aavogt> perhaps the easiest option is to turn off the flag that does dynamic linking
16:42:58 <adnap> so wait, yeah, how long have you all been programming in haskell?
16:43:26 <Eduard_Munteanu> Summed up? Hundreds of years, eons? :)
16:43:47 <adnap> why is there nothing good on hackage yet?
16:43:50 <adnap> :P
16:44:05 <aavogt> you're too picky
16:44:30 <adnap> i'm only kidding.  i've used some much stuff on hackage already.
16:44:49 <sm> adnap: bah
16:44:50 <ddarius> Hackage is pretty young.
16:44:57 <deadguys> aavogt: tried -static, no difference.  could it be that a dependency is forcing -dynamic?
16:45:19 <sm> adnap: pandoc is pretty good
16:45:28 <monochrom> spark = s + par + k
16:45:32 <Eduard_Munteanu> C has no Kerningage, or some equivalent.
16:45:36 <sm> as is darcs
16:45:40 <adnap> xmonad
16:45:45 <lpsmith> ddarius, so are any of my hpastes the "proper" implementation if you want to apply a function to two arguments and get the results back in parallel?
16:46:46 <Eduard_Munteanu> lpsmith: one of them seems to spawn a thread for the first component, one for the second, and there's also the main thread.
16:46:55 <Eduard_Munteanu> (well still, considering 'par' a hint)
16:47:17 <ddarius> lpsmith: I'm leaning toward "no."
16:47:19 <aavogt> deadguys: no idea. You could try following the directions in the error message too, though I can't help you there either
16:47:39 <lpsmith> ddarius, yeah,  so am I :-)
16:47:50 <lpsmith> I think I'm using it as I would seq,  which is wrong.
16:48:37 <deadguys> aavogt:  yeah, I don't understand what it's asking me to do.  thanks, I'll keep digging
16:49:31 <Eduard_Munteanu> Now I'm not sure of the semantics of that, given lazy evaluation. Does 'par' there behave like 'a `par` b `seq` ...'? Otherwise it looks pretty difficult to reason whether spawning the computation is worth it just from that.
16:49:35 <ddarius> b0 `par` b1 `par` (b0, b1) is probably what you want.
16:50:02 <ddarius> Eduard_Munteanu: As I said earlier, par doesn't change semantics.
16:50:19 <ddarius> Eduard_Munteanu: If you omit all pars from your code, your code evaluates to the same result.
16:50:20 <Eduard_Munteanu> ddarius: performance-related nothing else.
16:50:30 <lpsmith> ddarius, yeah,  I kind of figured that out.
16:50:41 <lpsmith> so what does my mistaken code do,  if anything interesting?
16:51:05 <Eduard_Munteanu> Because if those two things are evaluated at different times, parallelization might not be a good idea.
16:51:08 <ddarius> lpsmith: It's not necessarily mistaken, it just probably isn't what you are going for.
16:51:30 <Eduard_Munteanu> :t parSeq
16:51:31 <lambdabot> Not in scope: `parSeq'
16:51:41 * Eduard_Munteanu remembers something similar...
16:51:49 <lpsmith> ddarius:  we agree on that much :)
16:51:50 <aavogt> @hoogle pseq
16:51:50 <lambdabot> Control.Parallel pseq :: a -> b -> b
16:51:59 <lpsmith> I'm just curious what it does
16:52:04 <Eduard_Munteanu> Oh.
16:52:25 <ddarius> All three do nothing until a component of the tuple is looked at.  If it's the component without the par, then it will be evaluated and when the other is looked at the spark will fizzle and there will be no parallelism.
16:52:40 <ddarius> If it is the component with the par then it will spark the other and they will execute in parallel.
16:53:26 <ddarius> For the first implementation, you should always get parallelism between the components.
16:53:38 <Eduard_Munteanu> Ah, hence a `par` b `par` ...
16:55:08 <Eduard_Munteanu> But with two pars you end up with three threads/sparks? (you could think microoptimization, and blame me :D)
16:55:21 <lpsmith> so is the first implementation the equivalent of b0 `par` b1 `par` (b0,b1)  ?
16:55:21 <Eduard_Munteanu> s/micro/premature/
16:55:26 <ddarius> lpsmith: No.
16:56:56 <lpsmith> ok,  so here's another question
16:56:59 <Eduard_Munteanu> So I could say '  b0 `par` b1 `par` (b0, b1)   ` could be better?
16:57:05 <Eduard_Munteanu> erm...
16:57:15 <Eduard_Munteanu> b0 `par` b1 `seq` (b0, b1)
16:57:48 <ddarius> Eduard_Munteanu: No, that actually semantically means something different.
16:59:26 <lpsmith> If demand for a computation doesn't happen in parallel,  how does (b0 `par` b1 `par` (b0,b1)) evaluate things in parallel
16:59:38 <lpsmith> ?
17:00:12 <c_wraith> that expression doesn't do much, by itself.
17:00:20 <ddarius> Your question doesn't make any sense, particularly the antecedent.
17:00:23 <c_wraith> It might as well be (b0,b1)
17:00:40 <Eduard_Munteanu> I'd guess the RTS is thread-safe enough to determine dependencies and which have been evaluated.
17:01:07 <Eduard_Munteanu> So one will block for the other, right?
17:01:15 <ddarius> Eduard_Munteanu: No.
17:01:35 <c_wraith> You really probably want (b0 `par` b1) `pseq` (b0,b1)
17:01:37 <jmcarthur> more like it just doesn't matter than much
17:01:42 <ddarius> There is no need to be thread safe and there is indeed a race condition that can lead to an expression being evaluated multiple times.
17:01:58 <ddarius> c_wraith: That means something different.
17:02:05 <Eduard_Munteanu> Oh.
17:02:15 <c_wraith> indeed it does, but it's probably what anyone doing that actually wants.
17:02:28 <xplat> romildo, ddarius: based on my experience using curl as a library i don't recommend it, it tends to have a lot of bugs anywhere the command-line version doesn't exercise
17:02:36 <ddarius> xplat: I've never used it.
17:02:37 <jmcarthur> if two threads try to evaluate the same thing then one of two things can happen: one thread finishes before the other even starts, in which case the second might be able to benefit from the first; or, the second thread starts before the first thread is finished, in which case work is redundant
17:02:41 <Eduard_Munteanu> But aren't thunks managed by the RTS? That should be threadsafe ,really.
17:02:47 <jmcarthur> Eduard_Munteanu: ^^
17:02:55 <c_wraith> Eduard_Munteanu, being threadsafe would slow it down
17:03:01 <Eduard_Munteanu> Grr... :)
17:03:03 <c_wraith> at least, if it was done via locking
17:03:11 <c_wraith> Instead, it's threadsafe via purity
17:03:14 <jmcarthur> it's threadsafe anyway
17:03:20 <jmcarthur> it just doesn't keep a mutex
17:03:28 <ddarius> c_wraith: (b0 `par` b1) `pseq` (b0, b1) is most likely -not- what someone actually wants.
17:03:30 <c_wraith> Who cares if you evaluate something twice, if the answer is the same both times?
17:03:36 <revenantphx> Hm, I'm starting with "a logical approach o discrete math", monochrome
17:03:52 <Eduard_Munteanu> Yeah, and I suppose here it's a distinction between evaluation and execution, right?
17:04:01 <Eduard_Munteanu> So it wouldn't affect IO actions?
17:04:04 <revenantphx> It seems to be the lowest level concept wise.
17:04:17 <jmcarthur> Eduard_Munteanu: par means nothing for IO
17:04:30 <lpsmith> ddarius, but evaluation in Haskell only happens because of the need to do some kind of IO,  if nobody ever did some kind of IO,  evaluation would never happen.
17:04:47 <ddarius> lpsmith: I don't know why you said that to me.
17:04:48 <Eduard_Munteanu> jmcarthur: I was thinking a IO action and two threads that might evaluate it twice.
17:04:51 <revenantphx> Defining assignment and equality in terms of textual substitution is neat to me...
17:05:03 <c_wraith> Eduard_Munteanu, par doesn't do that for IO, though.
17:05:04 <jmcarthur> Eduard_Munteanu: yeah, sure, the IO isn't performed at evaluation
17:05:17 <c_wraith> err, par does execute IO.  so it's fine
17:05:18 <revenantphx> Evaluation vs Execution?
17:05:19 <Eduard_Munteanu> Ah, I'm okay with the "no locking" thingy then.
17:05:23 <c_wraith> err, *doesn't
17:05:27 <adnap> i get a warning with my build saying A package using section syntax should require
17:05:29 <jmcarthur> i think Eduard_Munteanu was saying the correct thing but we are interpreting it as the incorrect thing
17:05:30 <adnap> "Cabal-Version: >= 1.2" or equivalent.
17:05:35 <adnap> but is there such a package?
17:05:42 <lpsmith> <lpsmith>  If demand for a computation doesn't happen in parallel,  how does (b0 `par` b1 `par` (b0,b1)) evaluate things in parallel?
17:06:02 <Eduard_Munteanu> jmcarthur: at first I thought the wrong thing, then I said the "evaluation vs execution" stuff which I think it's correct
17:06:04 <jmcarthur> lpsmith: what the heck is parallel demand?
17:06:09 <lpsmith> <ddarius>  Your question doesn't make any sense, particularly the antecedent.
17:06:17 <adnap> i assume it means Cabal
17:06:29 <jmcarthur> Eduard_Munteanu: yeah
17:06:34 <ddarius> lpsmith: Okay, then I don't see how your later statement even relates to that.
17:06:46 <c_wraith> lpsmith, par is opportunistic parallelism.  Things sparked may be executed in parallel.  If the RTS has free capabilities to work with.
17:07:00 <c_wraith> err, evaluated.  I'm getting tired. :(
17:07:04 <Eduard_Munteanu> revenantphx: as in evaluating an IO action does nothing wrt its execution
17:07:07 <adnap> should i really be including Cabal in my build dependencies?
17:07:25 <ddarius> lpsmith: However, to answer some guess at what you are trying to ask.  par is what -makes- "parallel demand."
17:07:31 <c_wraith> par puts "reduce my first argument to WHNF" in a spark.
17:07:33 <aavogt> include it if you use parts of the library adnap
17:07:45 <adnap> aavogt: but i don't
17:07:45 <c_wraith> if the RTS has free capabilities, it might run some sparks.
17:07:51 <aavogt> for example if you want to pretty-print the version numbers
17:07:52 <adnap> aavogt: did you see the warning it gave me though?
17:07:58 <revenantphx> I'm giddy with excitement to read these books ^_^
17:08:05 * aavogt reads the scrollback
17:08:16 <revenantphx> Hopefully my computer is repaired by wednesday
17:08:35 * Eduard_Munteanu remembers writing pissy userspace threads in C :)
17:08:44 <Eduard_Munteanu> (not anything practical though)
17:08:45 <lpsmith> c_wraith, it might evaluate some sparks, even though the result might not ever be used...
17:09:01 <revenantphx> Btw, how should R[x := E] be read?
17:09:02 <c_wraith> lpsmith, indeed.  It can result in doing more work than is needed
17:09:36 <revenantphx> I keep thinking of it as "R where x becomes (is replaced by) E"
17:09:54 <revenantphx> Just wondering.
17:10:19 <Eduard_Munteanu> I wonder... is there a deepPar that does automatic parallelization? Some annotation, some inference/prediction.
17:10:26 <lpsmith> ok,  that's what I've been trying to get at.   At the very beginning I asked  ' does "par" force some level of evaluation of the second anyway?' 
17:10:40 <c_wraith> Eduard_Munteanu, look at Strategies
17:10:44 <lpsmith> and ddarius made it sound like "no" :-P
17:10:50 <Eduard_Munteanu> Ah, I see.
17:11:04 <lpsmith> thanks c_wraith 
17:11:04 <c_wraith> Does it force?  no, it doesn't.  It suggests to the RTS that it might be profitable to do so, though.
17:11:30 <lpsmith> Yes,  "force" was too strong a word
17:11:47 <aavogt> adnap: it's two things. One is the version of the Cabal library to use whereever your package imports it. The   cabal-version   is for newer syntax features like specifying versions like   1.2.*, or an executable + library in the same package that doesn't recompile the library twice to build both
17:11:54 <ddarius> lpsmith: I don't see you saying anything like that in the scrollback.
17:12:48 <adnap> aavogt: yeah, i didn't realize it wasn't referring to build dependencies with that suggestion since it looks just like how you would specify a build dependecy and i've just started trying to put together my first cabal file about an hour ago
17:13:20 <lpsmith> [19:33]  <lpsmith> so if I demand the first element of the result,  and ignore the second,  does "par" force some level of evaluation of the second anyway?
17:13:24 <adnap> aavogt: i realize it's a field like the others, such as description
17:14:11 <c_wraith> lpsmith, This changed recently, too.  sparks work differently now, in terms of how they interact with GC
17:14:43 <ddarius> lpsmith: I see it now.
17:15:38 <ddarius> revenantphx: "Substitute E for x in R"
17:15:50 <ddarius> revenantphx: Or even "let x be E in R"
17:16:03 <revenantphx> The latter is closer to what I was thinking
17:16:25 <revenantphx> I was thinking "R where x is E"
17:16:29 <revenantphx> Huh.
17:16:52 <revenantphx> Those two phrasings... Are just like the similarly named Haskell constructs.
17:17:32 <revenantphx> Actually, straight substitution like this keeps reminding me of lambdas
17:18:27 <monochrom> [it:=], [it:=], [it:=], [it:=]. whisper words of wisdom, [it:=]
17:19:35 <ddarius> Do I want to ride in a helicopter piloted by people who are learning tomorrow morning?
17:19:52 <monochrom> when will your ride be?
17:19:58 <ddarius> 0700
17:20:08 <monochrom> when they begin learning at the same time?
17:20:27 <Eduard_Munteanu> With an instructor?
17:20:53 <monochrom> are you altruistic?
17:21:11 * ddarius doesn't see where altruism comes in.
17:21:37 <monochrom> if you're altruistic, you risk your life in hope of giving them morale support. otherwise don't.
17:22:13 <Eduard_Munteanu> Moral support --- "you're already great at it, you don't even need to take lessons, I'll fly with you."
17:22:30 <ddarius> One doesn't need altruism to risk one's life.  Everyone does it every day for much less than that.
17:23:54 <monochrom> If you are not altruistic, you risk your life in hope of getting benefits for yourself rather than for others.
17:23:54 <adnap> cabal is telling me now that i need to add my own package to the build-depends field because it cannot find one of my modules, which it needs to build one of the executables i've specified.  i don't know if this is right or not, so i added my own package to the build-depends.  now it says (big surprise) that it cannot construct a valid install plan because my own package is involved in a dependency cycle.
17:24:03 <ddarius> monochrom: Indeed.
17:25:04 <Eduard_Munteanu> I s'pose helis should be safe to learn with an instructor.
17:25:55 <Eduard_Munteanu> They're hella sensitive to input, but  still, there are instances where learning to drive is as dangerous, I think.
17:26:46 <ddarius> I suspect learning to drive is more dangerous.
17:27:07 <adnap> can anyone help me out?  i'm kind of confused.
17:27:49 <Eduard_Munteanu> Maybe, but starting a car (or even a small plane) and moving it around isn't nearly as dangerous as unprepared heli flight, I think.
17:27:54 <Eduard_Munteanu> (I don't mean to scare.)
17:28:31 <ddarius> I want to jump out of planes and I've climbed rocks but never with a rope.
17:29:06 <spacebar> hello, how do i do the following ioctl call: ioctl(<socketfd>, SIOCGIFCONF, (struct ifconf)&buffer) ?
17:29:18 <spacebar> i am using ioctl-0.0.1
17:29:25 * Eduard_Munteanu remembers to play Flightgear some moar :)
17:29:47 <spacebar> what is the req option to ioctlsocket'?
17:31:13 <Eduard_Munteanu> spacebar: hm, it could correspond to the actual ioctl, say SIOCGIFCONF
17:32:22 <Eduard_Munteanu> I can't find actual instances of IOControl, look around or make your own.
17:32:42 <Eduard_Munteanu> It seems like 'req' should return a CInt represinting the ioctl code.
17:33:04 <Cale> Haha, awful choice of variables, "- Xi'/Xi" (imagine that written with a proper capital Xi, and vertical fraction :)
17:33:49 <ddarius> Cale: I've probably seen exactly what you describe before.
17:34:31 <Cale> (It's from a listing of statements equivalent to the Riemann hypothesis)
17:34:36 <monochrom> http://mathbin.net/56595 :)
17:35:07 <Eduard_Munteanu> Heh.
17:35:50 <adnap> Hey, can anyone help me?  I found this guy who is having the same problem, but he never got a response: http://www.mail-archive.com/haskell-cafe@haskell.org/msg71025.html
17:35:50 <ddarius> Cale: Yep, that would be where I saw it.
17:36:39 <ezyang> > let f x = Just (case x of Just _ -> ()) in fix f 
17:36:40 <lambdabot>   Just ()
17:36:43 <ezyang> whoo 
17:37:17 <monochrom> nice
17:41:08 <Cale> adnap: hmm
17:41:57 <Cale> adnap: That's really strange... maybe it's somehow not able to see that the modules are available in your project's directory?
17:42:09 <ezyang> > let f x = Just (case x of Just y -> y) in fix f 
17:42:12 <lambdabot>   mueval-core: Time limit exceeded
17:42:16 <ezyang> boo 
17:42:53 <Cale> adnap: Assuming your situation is similar enough to this guy's, I'd separate the executable into a separate project.
17:42:59 <ezyang> > let f x = Just (case x of Just y -> y) in case fix f of Just _ -> True 
17:42:59 <lambdabot>   True
17:44:27 <OscarZ> is that turing complete language must be able to "implement" an infinite loop ? 
17:44:42 <adnap> Cale: All I want it to be is a package that makes an executable.  I'm not interested in having a library.  I didn't export anything, but I assumed that everything is exported by default.
17:45:07 <JoeyA> If a Haskell interpreter checked types at run-time instead of compile-time, but had the same semantics as standard Haskell, would it still be considered "statically typed"?
17:45:58 <adnap> Cale: Under Executable, do I need to specify more than main-is?
17:46:09 <adnap> Cale: Such as the other modules included by Main?
17:46:21 <ddarius> JoeyA: Haskell doesn't have semantics without types.
17:46:24 <Cale> adnap: I don't *think* so...
17:46:36 <adnap> Cale: I couldn't find how to do that anyhow.
17:47:04 <Cale> JoeyA: It's hard to see how typeclasses could work like that.
17:47:19 <JoeyA> I think you got me on that one.
17:47:34 <Cale> JoeyA: But it wouldn't be considered statically typed if it didn't check types statically.
17:47:43 <JoeyA> When I was implementing a toy language with dynamic typing and monads, I had a bit of a problem implementing `return`
17:47:48 <Cale> yep
17:48:17 <JoeyA> (I ended up wrapping list accessors in functions like is_list, list_head, and list_tail which handle returns)
17:48:19 <ddarius> Haskell is Church-style rather than Curry-style.
17:48:19 <Cale> return is deceptively simple, but it's tricky for OO to capture
17:49:01 <Cale> (or anything which doesn't pre-compute types, really)
17:49:44 <Cale> You need polymorphism in the result type of functions, which most dynamically-typed systems can't really do in general.
17:54:05 <JoeyA> What I'm wondering is, what is a good way to represent inferred types compactly in bytecode?
17:54:34 <ddarius> To not represent them at all would probably be the most compact way.
17:55:08 <JoeyA> I'm considering implementing a toy language with the goal of having its bytecode as compact as possible.
17:55:33 <JoeyA> I don't want it to have to be expanded into RAM, though.
17:55:40 <monochrom> If you don't need "run time type information", represent nothing. If you need some extent of it, represent to that extent.
17:56:21 <Cale> JoeyA: The type system used by Haskell is designed such that types can be erased by compilation.
17:56:28 <monochrom> For example if you just want to distinguish "function" "non function", you just need 1 bit.
17:56:36 <Cale> So you have no runtime representation of types at all.
17:56:48 <JoeyA> But then what do you do about return?
17:57:02 <JoeyA> or any polymorphic function, for that matter?
17:57:07 <JoeyA> Just drop in the appropriate one?
17:57:19 <Cale> JoeyA: Typeclass polymorphic values are compiled into functions having additional parameters which are for the dictionary of methods for that typeclass.
17:57:22 <JoeyA> as in, >>= has an implementation for (->) e, [], IO, etc.
17:57:35 <Cale> So, for example,  return :: (Monad m) => a -> m a
17:57:49 <Cale> is compiled into something like   return :: Monad m -> a -> m a
17:57:56 <JoeyA> > filter isAlpha "(Monad m) => a -> m a"
17:57:57 <lambdabot>   "Monadmama"
17:58:03 <Cale> lol
17:58:04 <JoeyA> sorry...
17:58:43 <Cale> Where Monad becomes a record type parametrised on the monad
17:58:58 <JoeyA> ah, that makes sense.
17:59:01 <Eduard_Munteanu> I was reading today that JHC avoids dictionary passing.
17:59:18 <Cale> data Monad m = M { return :: forall a. a -> m a, (>>=) :: forall a b. m a -> (a -> m b) -> m b }
17:59:19 <JoeyA> I wonder if multi-parameter type classes make the dictionary harder to implement.
17:59:24 <Cale> something like that
17:59:46 <ddarius> JoeyA: Not really.
18:00:04 <ddarius> And as Eduard_Munteanu indirectly suggests, this is but one implementation approach.
18:00:09 <Cale> (note the higher rank types there though, which might be an issue to be aware of if you want a typed intermediate language)
18:01:02 <Cale> If you want to avoid dictionary passing, you're almost forced into whole-program compilation though.
18:01:07 <iago> you usually don't need to infer types in an intermediate language
18:01:34 <Eduard_Munteanu> I suppose it's like SPECIALIZE by default.
18:01:40 <Eduard_Munteanu> and enforced.
18:03:24 <iago> yep, I think so
18:03:35 <iago> JHC does some kind of pattern matching over types
18:03:42 <iago> to decide what instance to use
18:03:51 <Cale> (At least, if you come up with an alternative to dictionary passing which can be nicely separately compiled, please let everyone know about it. :)
18:04:30 <Cale> Oh, I suppose gobs of runtime type information would be another way
18:04:34 <JoeyA> Perhaps adding the notion of polymorphism to the bytecode representation wouldn't really help in terms of compactness, as the types can be erased during compilation and dictionary passing can be used as needed.
18:05:20 <JoeyA> As would duplicating implementations for every instance, but that would blow up the program size.
18:05:46 <Eduard_Munteanu> I think polymorphic types are specialized before/during erasure.
18:05:53 <Cale> Note that in general the number of instances which a program will need can be infinite/unbounded
18:05:53 <ddarius> Duplicating doesn't work in general unless you are willing to JIT.
18:06:07 <JoeyA> oh, because it could be infinitely large due to recursion?
18:06:28 <JoeyA> or just in practice?
18:06:45 <ddarius> JoeyA: There are only a few scenarios in Haskell where the number of instances are unknown or infinite.
18:06:57 <Cale> Recursion :)
18:07:01 <ddarius> (Number of actually needed instances I should say.)
18:07:32 <Cale> > let f :: (Show a) => Integer -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f 5 0
18:07:32 <lambdabot>   "(((((0,0),(0,0)),((0,0),(0,0))),(((0,0),(0,0)),((0,0),(0,0)))),((((0,0),(0...
18:07:39 <ddarius> Though in practice, specializing is often prohibitive as well.
18:07:53 <ddarius> Specifically, in that case, polymorphic recursion.
18:07:53 <Eduard_Munteanu> Well who said typeclasses aren't like classes, this is exactly the vtable problem in OOP, it seems.
18:08:01 <aavogt> Cale: does that need extensions for that kind of recursion?
18:08:06 <Cale> no
18:08:08 <ddarius> Eduard_Munteanu: Nope, it isn't, though it is similar and related.
18:08:12 <Cale> That's standard Haskell
18:08:30 <Cale> Haskell has always had fancy polymorphic recursion.
18:08:42 <Eduard_Munteanu> "exactly" was exaggerated, I admit
18:09:16 <ddarius> The other problematic scenario is, however, almost exactly the vtable situation and that is existentials.
18:10:03 <Cale> JoeyA: There's an instance  (Show a, Show b) => Show (a,b)  which is compiled into a function  Show a -> Show b -> Show (a,b)  which is used to combine dictionaries for the Show instances.
18:10:57 <JoeyA> interesting
18:11:02 <Cale> So that you don't end up having to compile moar instances dynamically at runtime
18:11:48 <Eduard_Munteanu> ddarius: I suspect that holds for rank-2/N types too?
18:11:48 <Cale> .oO(<protoss voice> You must construct additional instances)
18:12:02 <ddarius> Eduard_Munteanu: Yes, because you can encode existentials with rank-2 types.
18:12:25 <JoeyA> You've not enough memory.
18:14:38 <ezyang> Does anyone have an example of a continuous (in the sense that it is monotonic and preserves chains) uncomputable function? 
18:15:32 <ddarius> The idea in domain theory was to have continuity imply computability.
18:15:47 <ezyang> Ah. 
18:15:50 <ezyang> Did they succeed? 
18:15:54 <Cale> um, wait, are we sure?
18:16:01 <ddarius> To varying degrees.
18:16:13 <ddarius> There are different approaches.
18:18:07 <ttvd> hi, is there a way to run something like ghci ":t <expression" from cmd line?
18:18:27 <ttvd> without actually loading ghci and typing :t expr
18:18:44 <ben> $ echo ':t 42' | ghci
18:19:00 <ttvd> thank your Sir
18:19:13 <ezyang> ddarius: Do you know which approaches manage it? 
18:19:43 <ben> ttvd: Actually, use ghc -e ':t 42'
18:19:53 <ttvd> oh there's a key? yeah i must have missed that
18:20:07 <ttvd> thanks again
18:20:16 <ben> No problem
18:36:28 <sshc> In template haskell, is "TupleT 0" the unit type ("()")?
18:40:16 <aavogt> ConT ''() == TupleT 0
18:40:18 <aavogt> False
18:40:21 <aavogt> ^^ sshc
18:42:18 <sshc> aavogt: I see.  I'm assuming I should use "ConT ''()" for that type?
18:42:53 * BMeph prefers: .oO(<Zerg voice> Spawn more instances!)
18:43:28 <adnap> why when i run cabal install now does it say "there is no installed version of base" when ghc-pkg list base shows that base is indeed installed?
18:45:23 <aavogt> sshc: I dunno, haskell-src-meta has a bunch of functions for normalizing such expressions I think
18:52:06 <adnap> ah, nvm.  i put build-depends in the wrong section of my cabal file
18:59:38 <Cale> http://www.math.uwaterloo.ca/~kpurbhoo/co630/pageonefinal.pdf -- heh, this is an awesome grading system
19:04:51 <Eduard_M1nteanu> Cale: heh, nice
19:05:27 <Cale> When I took that class, I seem to recall that we didn't even have a final. There was just 4 homework assignments which were each worth 25% of the mark, and had lots of open-ended stuff on them (some of the problems were even open questions). If you did enough work, you got a good mark. Sort of an unusual approach for a mathematics course, but I enjoyed it.
19:05:38 <Eduard_M1nteanu> We also had lots of exams where we could bring any materials (sometimes even laptops)
19:06:02 <Eduard_M1nteanu> I see.
19:07:17 * ddarius wonders what "equitably" means.
19:08:00 <Cale> That's a good question. Probably either equally or proportionally.
19:09:33 <unkanon> newbie question: how much should I worry about polluting namespaces? I'm writing a backprop neural net, can I say type Inputs = [Double] or is Inputs too generic and I should use NNInputs ?
19:09:52 <ddarius> unkanon: You certainly shouldn't worry that much.
19:10:06 <ddarius> It's really package and module names that you have to worry about.
19:10:16 <unkanon> ok, I won't worry then :)
19:10:58 <unkanon> oh I get it, because one can always import qualified and call my functions with Something.myfunction
19:11:05 <ddarius> Correct.
19:11:20 <unkanon> thanks, I'll crack on with code now
19:12:55 <Cale> unkanon: You should try to use type synonyms sparingly though
19:13:14 <unkanon> why?
19:14:11 <Cale> unkanon: Well, they obscure to some extent what it is that things really consume or produce without giving any additional type safety.
19:14:16 <unkanon> this is what I have now: http://hpaste.org/42244/th
19:15:29 <Cale> You might also consider  data Neuron = Neuron { inputs :: [Double], weights :: [Double] }
19:16:20 <badkins> Haskell newbiew question. I'm coming from the dynamic typing world, and tried [1,2,3] ++ [[4,5,6]] expecting [1,2,3,[4,5,6]]. Anyway to achieve that?
19:16:31 * unkanon is looking for advantages to that on RWH
19:16:37 <ddarius> badkins: No.
19:16:39 <Cale> badkins: It's ill-typed unless 1 can be interpreted as a list
19:16:49 <Cale> badkins: (along with 2 and 3)
19:16:53 <badkins> that makes me sad
19:17:03 <ddarius> Cale: If 1 can be interpreted as a list, then so can 2 and 3.
19:17:03 <Cale> badkins: Well, what would you use such a list for?
19:17:09 <Cale> ddarius: Yeah
19:17:13 <ddarius> badkins: If you want a tree, use a tree.
19:17:22 <badkins> a container
19:17:42 <ddarius> Programmers getting sad about this makes me sad.
19:17:44 <badkins> just exploring the boundaries currently
19:17:47 <argiopeweb> 'Evening folks. I'm busy reading through all the material I can find with the end goal of integrating an application in Haskell into a pre-existing system which relies heavily on proprietary network packet protocols and requires a GUI with OpenGL display as a front-end. I'm moderately familiar with functional programming (CL, a bit of Erlang) so I'm having no problem picking up the language, but I would appreciate it if anyone could 
19:17:47 <argiopeweb> guide me toward some areas I might like to focus on as I wade through the vast amount of information available on Haskell.
19:17:59 <Cale> badkins: Functions which operate on lists always (or almost always) do something roughly uniform with the elements.
19:18:13 <badkins> I agree that's more common
19:18:36 <Cale> badkins: If the elements could have different types, the set of operations you could safely perform on an arbitrary element of the list dwindles
19:18:46 <badkins> true
19:19:03 <Cale> (without discriminating at runtime on which type the elements are, which is impossible because type information isn't present at runtime)
19:19:06 <badkins> I'm not arguing that Haskell *should* allow it, just discovering what can and can't be represented properly.
19:19:35 <Cale> So, one thing you could do if you wanted this is to define a type whose cases correspond to the types of list element you'd like to handle
19:19:40 <badkins> Cale: thanks, that's an important point re: lack of type at runtime
19:19:52 <Cale> data Value = JustANumber Integer | ListOfNumbers [Integer]
19:20:33 <Cale> Or probably more idiomatic, just use  Either Integer [Integer]
19:20:38 <Cale> (or something)
19:20:58 <Cale> So, then you could write [Left 1, Left 2, Left 3, Right [4,5,6]]
19:21:12 <badkins> so if you used that data declaration, would you use pattern matching to "know" whether you had just an int vs. [int] ?
19:21:16 <Cale> yeah
19:21:33 <Cale> > [Left 1, Left 2, Left 3, Right [4,5,6]]
19:21:33 <lambdabot>   [Left 1,Left 2,Left 3,Right [4,5,6]]
19:22:02 <Cale> > map (\x -> case x of Left v -> v; Right vs -> sum vs) [Left 1, Left 2, Left 3, Right [4,5,6]]
19:22:03 <lambdabot>   [1,2,3,15]
19:22:19 <badkins> Cale: excellent - thanks!
19:22:38 <Cale> badkins: If you want an arbitrarily deep tree, you'd want to define a real tree type
19:23:03 <Cale> (Possibly with multiple node types if you want different sorts of data in the nodes)
19:23:30 <Cale> So, it's not really a problem in practice that lists are homogeneous. You can always work out some type which expresses what types of data your program is actually capable of handling.
19:23:41 <badkins> yeah
19:24:13 <unkanon> Cale: awesome, I can even pattern match on the record :)
19:24:27 <badkins> Cale: that's basically what I meant by "any way to achieve that", the type decl helped.
19:24:32 <Cale> unkanon: Using either syntax even.
19:24:41 <Cale> badkins: Yeah :)
19:25:33 <unkanon> Cale: I'll discover the second syntax in due time
19:26:07 <Cale> unkanon: I mean, you can either write  foo (Neuron { inputs = is, weights = ws }) = ...
19:26:11 <duckinator> is there a cleaner alternative to `foo = list ++ [item]`?
19:26:16 <Cale> unkanon: Or  foo (Neuron is ws) = ...
19:26:53 <unkanon> Cale: oic, the first one's good if I want to declare stuff out of order, but the second is more concise. thanks.
19:26:56 <duckinator> hey again, unkanon
19:26:56 <Cale> duckinator: No. If you're doing that a lot, you should probably watch out, because (xs ++ ys) takes O(length xs) time (and potentially space) to compute.
19:27:13 <Cale> unkanon: Yeah, or if you're only interested in a subset of the fields.
19:27:14 <duckinator> Cale: well it's for an irc bot, doing it once per message
19:27:26 <Cale> duckinator: yeah, that's probably file
19:27:29 <Cale> fine*
19:27:35 <sshc> Is it possible to get the referent of a Name?
19:27:36 <duckinator> Cale: so, the potential issue would be space for something like that, but that's assuming it's getting the crap spammed out of it
19:28:01 <Cale> duckinator: Well, it's only a space problem if the old list is still needed for some reason
19:28:14 <Cale> duckinator: Otherwise, it just immediately becomes garbage
19:28:32 <duckinator> ah, yea. the old list isn't used after that so it should be fine
19:29:38 * ddarius wonders how Cale typoed "fine" as "file"
19:29:59 <duckinator> ddarius: magic, of course
19:32:01 <Cale> I've done sillier things than that. I often typo entire words as other words.
19:32:13 <Cale> (with similar beginning characters)
19:32:56 <Berengal> I feel a bit stupid now... I had this nice project I assumed I could spend the afternoon on. I spent my drive from work planning it out and all, but when I sat down at my computer I finished it in 5 minutes using one line of bash
19:33:27 <ddarius> Berengal: The power of waterfall design.
19:34:58 <Berengal> ddarius: I don't think any other methodology would've lead me to bash either. I just randomly tripped over the solution trying to get some working data
19:35:52 <medfly> g'morning
19:36:24 <duckinator> 'evening :P
19:36:37 <medfly> evening, but not good
19:36:42 <Axman6> Cale: i do that all the time, and i fear it's getting worse :(
19:39:03 <duckinator> aw damn, i thought i was being sneaky. haskell out-sneaked me though :D
19:39:14 <ddarius> It's so bad that what Axman6 meant to write was "I don't notice myself making typoes at all."
19:39:34 <duckinator> i tried `let ret = io (putStrLn s); handle ....; ret` to try to get it to print s first, but return that value.......yea... didn't work
19:39:37 <Axman6> D:
19:39:49 <duckinator> not surprising to anyone who's been using haskell for a while, i'm sure
19:40:03 <duckinator> (and hope, actually..)
19:40:35 <aavogt> are you actually looking for Debug.Trace?
19:41:21 <duckinator> me? not sure what would be best there
19:41:54 <phao> Hi.
19:42:52 <phao> Scheme is "mainly functional", but it's actually multi-paradigm, same is for Common Lisp I think. Is haskell like that too? I mean, functional, but lets the program do, for example, OOP, Structured Programming, and other paradigms.
19:43:27 <unkanon> no, that's what makes it "purely functional" I'd say
19:43:35 <phao> right
19:43:36 <Axman6> phao: i would say it's almost completely puerly functional, with the only IO being what's necessary to get work done
19:44:09 <duckinator> from what i've read, it is in fact "purely functional", due to using Monads for IO
19:44:10 <phao> right
19:44:11 <Berengal> unkanon: I thought the "purely" in "purely functional" refered to the immutability of values...
19:44:19 <Axman6> @src IO
19:44:20 <lambdabot> Source not found. My brain just exploded
19:44:30 <phao> isn't there assignment in haskell?
19:44:30 <Axman6> bah, you used to know, you stupid forgetful bot
19:44:50 <unkanon> Berengal: I think it refers to that as well but not only that
19:44:50 <Axman6> phao: not destructive assignment
19:44:51 <shachaf> phao: Not of the standard variety.
19:44:58 <phao> wow
19:44:59 <phao> but
19:44:59 <duckinator> phao: you can define something, but you can't redefine it
19:45:04 <phao> right.
19:45:11 <Axman6> you can't say x = 3; x = 4
19:45:13 <phao> I wonder how that works for big programs.
19:45:16 <shachaf> phao: You can simulate state in various ways.
19:45:16 <unkanon> there's no assignment, only declaration. haskell is declarative.
19:45:18 <Berengal> phao: There's also reference types hidden away in some minads.
19:45:22 <duckinator> Axman6: well you CAN, but... ;)
19:45:23 <Berengal> monads*
19:45:28 <phao> Berengal, like C pointers?
19:45:31 <unkanon> phao: it works very well ;)
19:45:32 <Axman6> it works fine, start folowing a tutorial and find out ;)
19:45:36 <Berengal> phao: Yes, basically
19:45:43 <phao> unkanon, I'm not good at it, but I like this functional programming thing
19:45:49 <Berengal> phao: But they're not used much
19:45:52 <shachaf> Well, not like pointers in that you can't do pointer arithmetic and so on.
19:45:59 <Axman6> @where lyah
19:45:59 <lambdabot> http://www.learnyouahaskell.com/
19:46:06 <Axman6> time to get good phao! ^^^^^
19:46:06 <unkanon> phao: we're both in the same group, but we'll get better :)
19:46:22 <duckinator> i'm actually writing an irc bot in it, at 129 lines it's actually one of the cleanest looking i've written -- i can't say how much smaller an experienced haskell coder could make it, though.... :D
19:46:41 <duckinator> that includes dispatching based on the message type, btw :)
19:46:45 <phao> Axman6, what is that?
19:46:58 <phao> duckinator, the program size
19:47:03 <phao> is not what attracts me
19:47:08 <Axman6> it's the best programming tutorial on the internet phao ;)
19:47:09 <unkanon> duckinator: that's cool, do you have that up on github or something?
19:47:09 <phao> I mean... at first it was
19:47:19 <phao> I remember seeing some Common lisp program being written in really small size
19:47:23 <phao> but then I start seeing that
19:47:26 <phao> programs written in this way
19:47:28 <medfly> isn't there a scheme channel too?
19:47:29 <phao> were more clean
19:47:41 <duckinator> unkanon: i will after i clean it up. it's got a few embarrassing areas to it ;)
19:47:44 <phao> like easier to read, understand
19:47:52 <phao> if compared to a C or Java equivalent
19:47:55 <Axman6> phao: have you heard of Xmonad before?
19:48:01 <phao> used to use it Axman6 
19:48:14 <shachaf> phao: Comparing to C isn't really fair.
19:48:15 <Axman6> right, well it's onlt a full thousand lines of code
19:48:24 <duckinator> phao: your pinky is getting sleepy, very sleepy... ;)    (and your enter key is crying)
19:48:25 <phao> shachaf, hhehe
19:48:30 <Axman6> and the code is clear and concise
19:48:34 <duckinator> and i was lagging...quite a bit. awesome.
19:48:38 <phao> duckinator, =) old habits die hard
19:48:49 <phao> duckinator, I'm getting better... I used to type one word per line
19:48:49 * ddarius liked xmonad better when it was 90 lines...
19:49:04 * Berengal liked xmonad better when it was on vinyl
19:49:09 <duckinator> phao: if you did that now, i would track you down and set your keyboard on fire :)
19:49:15 <phao> hahahahaha
19:49:22 <shachaf> ddarius: Xmonad used to be 90 lines? And also do window management?
19:49:26 <phao> I wanna make a game in haskell
19:49:31 <phao> like 2d game... zelda style.
19:49:35 <Axman6> @remember Berengal * ddarius liked xmonad better when it was 90 lines... * Berengal liked xmonad better when it was on vinyl
19:49:35 <lambdabot> Done.
19:49:43 <phao> is it possible? using opengl
19:49:48 <ddarius> Sure.
19:49:56 <djahandarie> Berengal, it was just so much... richer!
19:50:05 <phao> do you know if compiled code using ghc is fast?
19:50:07 <unkanon> duckinator: ok, let me know
19:50:11 <Berengal> djahandarie: I just like the taste better
19:50:18 <Axman6> heh, yeah, ghc's compiled code is fast
19:50:21 <ddarius> phao: It varies wildly with the programmer.
19:50:28 <phao> Axman6, i've heard that a lot about haskell
19:50:29 <unkanon> phao: yes, I also think functional programs are easier to read than procedural or OO
19:50:49 <phao> I mean.. how fast it can be... even people from scheme told me that "If you wanna look at fast functional stuff, check with haskell people"
19:51:12 <phao> and.. chicken (scheme implementation) can generate some REALLY FAST code.
19:51:15 <Berengal> unkanon: I think golfed procedural is easier to read than golfed functional... Which basically says something about the expressibility of the paradigms
19:51:15 <phao> I mean.. FAST.
19:51:24 <ddarius> It's really easy to write really slow Haskell if you don't know what you are doing.
19:51:35 <phao> ddarius, I hope I don't do that.
19:51:41 <ddarius> You probably will.
19:51:44 <phao> Axman6, what book is that one?
19:51:45 <Berengal> phao: Many compiled functional languages compile to fast code
19:51:50 <unkanon> phao: I think the haskell masters can write code that runs at half the speed of C
19:51:57 <Axman6> phao: we have an unfair advantage, writing highly concurrent and parallel programs in haskell is braindead easy (making them fast takes a little more work, but not too much)
19:51:59 <djahandarie> Not good C.
19:52:12 <djahandarie> fsvo good
19:52:17 <Axman6> djahandarie: or good haskell :P
19:52:31 <phao> I like C, a lot. But I don't like it to write most of the programs I want or have to. Hehe.
19:52:33 <unkanon> Berengal: but non-golfed functional is still less code than golfed procedural :)
19:52:38 <Axman6> phao: what book?
19:52:47 <phao> Axman6, http://www.learnyouahaskell.com/
19:52:48 <ddarius> There are some things that GHC does very well where the "naive" code is the fast code.
19:52:58 <Berengal> unkanon: Often, yes.
19:53:00 <Axman6> phao: it's a haskell tutorial, get reading, it's free!
19:53:11 <phao> Axman6, I'm reading "Programming in Haskell"
19:53:30 <Axman6> read lyah, it;s the best introduction we have, and the most fun too
19:53:50 <phao> maybe next. I've already started that one... I don't wanna stop in the middle.
19:54:05 <Axman6> ok
19:54:09 <phao> and, I agree that it's better than "Programming in Haskell", but that book.. geeee
19:54:14 <ddarius> phao must not be good at multi-tasking.  Perhaps too much C?
19:54:19 <Axman6> lyah is enjoyable enough you won't mind learning the same things twice
19:54:25 <phao> ddarius, hehehe
19:54:47 <phao> ddarius, I'm studying haskell, C, PHP and some other program for a game.. but what takes my time too much is Supernatural
19:55:01 <djahandarie> PHP...
19:55:10 <phao> djahandarie, don't mention it.
19:55:25 <Axman6> PHP..? Game..?
19:55:30 <phao> I had a line... a foreach(fun_call() as $value) ...
19:55:40 <phao> fun_call didn't exist
19:55:43 <phao> and the code run.
19:55:54 <phao> I mean.. no error message, nothing.. the code run..
19:56:10 <phao> I don't know how it ran calling an inexistent function... but it did.
19:56:34 <Cale> http://www.sharingmachine.com/prodimages/logo-400.jpg -- awesome
19:56:40 <phao> php is strange... and its documentation is crap
19:57:11 <syntaxglitch> oh man, I loved playing with logo as a kid
19:57:22 <Axman6> i thought one of the good things was its documentation. i wish haskell's was more like php's
19:57:28 <Berengal> php actually has decent documentation
19:57:36 <unkanon> in php, the string "0" evals to boolean False  :S
19:57:37 <ddarius> There are bigger turtles than that.
19:57:38 <djahandarie> Only good thing about PHP is its documentation
19:57:40 <duckinator> holy shit, i officially love haskell
19:57:58 <phao> unkanon, if a variable has "0" as value, it is considered empty.
19:58:04 <phao> well
19:58:12 <phao> I've see some mistakes in its documentation.
19:58:18 <handonson> hey, can you guys cabal install bytestring now? it seems for me that Data.ByteString in hackage is currently broken
19:58:20 <duckinator> unkanon: with my bot: `handle s "PRIVMSG"  [_, "o/"] = reply "\\o"` makes it send \o to any channel you send o/ in
19:58:41 <phao> djahandarie, documentation-wise
19:58:44 <phao> I like MS's stuff.
19:58:52 <duckinator> unkanon: handle s "PRIVMSG" ["#foo", "o/"] = reply "\\o in #foo" -- specific to #foo 
19:58:55 * ddarius likes C#'s @"
19:58:57 <djahandarie> Technically Haskell is MS's stuff...
19:59:11 <phao> is that so?
19:59:14 <unkanon> duckinator: nice!
19:59:16 <djahandarie> MSR's.
19:59:17 <ddarius> Where "technically" means "not at all"
19:59:17 <syntaxglitch> not really
19:59:26 <syntaxglitch> they just sign a couple people's paychecks
19:59:30 <djahandarie> :P
19:59:43 <ddarius> Not only that, they didn't originally sign their paychecks.
19:59:43 <djahandarie> Basically the ideal relationship with MS
19:59:45 <phao> I also like the man pages
19:59:46 <Axman6> handonson: it's possible it was updated for ghc7
20:00:12 <Cale> GHC was already pretty far along before Simon came to MSR :)
20:00:23 <syntaxglitch> not to mention that GHC /= Haskell
20:00:33 <djahandarie> Yeah yeah technicalities blah blah
20:00:34 <Saizan> handonson: it works with ghc-7.0.1
20:00:39 <unkanon> what's Haskell - GHC?
20:00:40 <handonson> [5 of 8] Compiling Data.ByteString  ( Data/ByteString.hs, dist/build/Data/ByteString.o )
20:00:41 <handonson> Data/ByteString.hs:1959:21: Parse error in pattern
20:00:51 <unkanon> Gofer?
20:00:52 <handonson> has GHC changed how to parse patterns?
20:01:56 <handonson> (the above is what i get by cabal install bytestring, with library-profiling option True)
20:02:11 <Saizan> handonson: apparently so
20:02:34 <Berengal> 2k lines in Data/ByteString.hs? That can't be right
20:03:57 <Cale> unkanon: Haskell is just the language, or class of languages, not the implementation :)
20:04:23 <Saizan> there are some #ifdef around there
20:04:31 <Saizan> so it might be a bug
20:05:10 <unkanon> Cale: well that I know, but without the implementation one can't use it
20:05:19 <duckinator> unkanon: hahahaha.... my reply/react/renotice functions use the initial channel(s) the bot joins. woops :D
20:05:50 <unkanon> duckinator: in which room are you testing it?
20:05:53 <handonson> Berengal: yeah, that file does have 2087 lines. whew
20:06:07 <sshc> How do I use template haskell to print the TH code of a top-level declaration again?
20:06:30 <duckinator> unkanon: it's on a diff network. if you want to join, irc.ninthbit.net in #offtopic
20:07:40 <unkanon> hmm now you got me, I don't even know if irssi can connect to two different networks at a time
20:08:05 <Saizan> handonson: it seems the #else clause of that #ifdef never got tested, since it lacks a 'do', and after filling that in i get out of scope errors
20:08:17 <duckinator> unkanon: i know it can (i used to use it to get on 3 networks at once), although i haven't used it in ages so i'm not sure how :P
20:10:03 <handonson> Saizan: really? so it *is* a bug?
20:10:33 <Saizan> yeah, a bug in bytestring, afaiu
20:10:46 <handonson> huh.
20:11:24 <Saizan> (so it's not due to a change in the way ghc parses patterns)
20:12:23 <handonson> where do we file this bug? :)
20:16:46 <Mathnerd314> are there any types between Functor and Applicative?
20:17:08 <Berengal> There's Pointed, but it's not a standard class
20:17:33 <Saizan> http://trac.haskell.org/bytestring/ <- i thought it was here, but it gives 500
20:17:47 <unkanon> functor -> pointed -> applicative -> monoid -> monad?
20:19:09 <redd_> @pl \f a b -> h (f (g a) (g b))
20:19:10 <lambdabot> ((h .) .) . flip flip g . ((.) .) . (. g)
20:19:33 <redd_> not really worth it
20:20:08 <Axman6> :t on
20:20:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:20:19 <dobblego> @hoogle Word8 -> Char
20:20:19 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
20:20:19 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:20:19 <lambdabot> Prelude show :: Show a => a -> String
20:20:30 <Axman6> :t \f a b -> h (f (g a) (g b))
20:20:31 <lambdabot> forall t t1 t2 t3 t4 t5. (SimpleReflect.FromExpr (t -> t2), SimpleReflect.FromExpr (t1 -> t3), SimpleReflect.FromExpr (t4 -> t5)) => (t2 -> t3 -> t4) -> t -> t1 -> t5
20:20:35 <Mathnerd314> Berengal: but one cannot derive Functor from Pointed, whereas one can create a Functor instance for any Applicative using only its operations. so Pointed isn't really "between"
20:20:37 <Axman6> :\
20:20:43 <Axman6> :t \f g a b -> h (f (g a) (g b))
20:20:44 <lambdabot> forall t t1 t2 t3. (SimpleReflect.FromExpr (t2 -> t3)) => (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t3
20:20:56 <Axman6> :t \f g a b -> (f (g a) (g b))
20:20:56 <redd_> Huh, `on` has to be the most useful function I've seen in a while :)
20:20:57 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
20:21:01 <handonson> dobblego: Data.Char.chr . fromIntegral
20:21:13 <dobblego> handonson, thanks
20:21:19 <Axman6> > (++) on show 2 7
20:21:19 <lambdabot>   Couldn't match expected type `(a -> b) -> a -> a -> c'
20:21:20 <lambdabot>         against infe...
20:21:24 <Berengal> Mathnerd314: True
20:21:26 <Axman6> > (++) `on` show 2 7
20:21:27 <lambdabot>   Couldn't match expected type `t -> a -> b'
20:21:27 <lambdabot>         against inferred type `G...
20:21:43 <Axman6> > ((++) `on` show) 2 7
20:21:44 <lambdabot>   "27"
20:21:46 <Berengal> By the way, where's the typeclassopedia hosted these days?
20:21:49 <handonson> what would be the fastest way to writeFile a [Word8]? can I avoid converting it into a ByteString before writing?
20:22:10 <aavogt> @check liftM2 (==) chr toEnum
20:22:11 <lambdabot>   "*Exception: Prelude.chr: bad argument
20:22:22 <unkanon> @where typeclassopedia
20:22:22 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:22:32 <aavogt> @check \x -> x > 0 || liftM2 (==) chr toEnum
20:22:32 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:22:40 <aavogt> @check \x -> x > 0 || liftM2 (==) chr toEnum x
20:22:40 <lambdabot>   "*Exception: Prelude.chr: bad argument
20:22:52 <Berengal> unkanon: It's not up there anymore
20:23:10 <unkanon> if you can't find it I can email it to you
20:23:31 <aavogt> @check \x -> x < 0 || liftM2 (==) chr toEnum x
20:23:32 <lambdabot>   "OK, passed 500 tests."
20:23:39 <handonson> what? Monad.Reader is not being hosted?
20:24:14 <Berengal> unkanon: I have it myself, I just thought it was relevant to the type class discussion
20:24:23 <unkanon> Berengal: community.haskell.org/~yitz/typeclassopedia.pdf
20:24:34 <Berengal> handonson: I can't find any issues < 14 online
20:24:57 <duckinator> holy shit...
20:25:07 <duckinator> unkanon: this is beyond amazing :D
20:25:21 <unkanon> wuh?
20:25:24 <duckinator> unkanon: this one line makes it so if you say `!foo` my bot says `foo` back:  handle s "PRIVMSG"  [c, ('!':xs)] = privmsg c xs
20:25:59 <duckinator> unkanon: most insane part? none of that is tailored specifically to make handling PRIVMSG easier...
20:26:30 <Mathnerd314> Berengal: so, roughly, I am looking for a set of functions, not containing (a -> b) -> f a -> f b, that when composed/applied are sufficient to derive (a -> b) -> f a -> f b but insufficient to derive f (a -> b) -> f a -> f b
20:26:51 <unkanon> duckinator: that's very understandable code you have there
20:27:28 <Berengal> Mathnerd314: Yeah... I don't know of any
20:27:34 <duckinator> unkanon: haskell is just amazing me to no end, even on a simple thing like an irc bot. this destroys even my nicest irc library i wrote in ruby hands-down :P
20:28:23 <unkanon> I'll only experience what you are experiencing now when I finally get at least halfway through my first large haskell program. can't wait :)
20:29:01 <dobblego> is there a Data.List.Split for ByteString?
20:29:43 <redd_> @pl \f l r -> h ((f `on` g) l r)
20:29:43 <lambdabot> ((h .) .) . (`on` g)
20:33:02 <badkins> Working through "Programming in Haskell", I noticed: even n = n `mod` 2 == 0. Is there a way to define a function in Haskell such that it behaves differently for an Int than Integer e.g. just check a bit ?
20:33:25 <Zao> Kind of.
20:33:26 <shachaf> badkins: You could make a type class.
20:33:29 <dobblego> badkins, yes note the type for mod
20:33:36 <Zao> It has to be semantically the same though.
20:33:46 <Zao> (I'm thinking of SPECIALIZE and whatever)
20:34:07 <redd_> One thing I love about Haskell is building "mini-EDSLs" projects, so that the final, operational code captures the "essence" of the algorithm.
20:34:15 <badkins> I'm hoping the prelude doesn't do mod for Int
20:34:20 <badkins> (for an even function)
20:35:35 <badkins> if mod is defined for Integral, is it possible to define mod for Int which would take precedence ?
20:35:36 <parcs> @type even
20:35:37 <lambdabot> forall a. (Integral a) => a -> Bool
20:35:39 <parcs> @src even
20:35:40 <lambdabot> even n = n `rem` 2 == 0
20:36:05 <badkins> hmm
20:36:40 <Berengal> redd_: I usually start with the "essence" of whatever I'm writing, stubbing out any details until I'm happy with the types.
20:36:43 <shachaf> badkins: `mod` is an Integral method.
20:36:57 <shachaf> s/`//g
20:37:31 <badkins> shachaf: yes, I'm wondering if mod can also be defined on a more specific class e.g. Int
20:37:56 <shachaf> badkins: Int is a type, not a class.
20:39:20 <badkins> I see, so if I created a class that contained Int and not Integer, and defined mod for that, would it take precendence for Int args ?
20:39:37 <shachaf> badkins: I'm not sure what you mean.
20:40:12 <badkins> currently there exists a mod that operates on Int and Integer args, I'd like to create a new mod that only operates on Int that is a different implementation. Possible?
20:40:23 <badkins> (same name though)
20:40:41 <Berengal> badkins: That's how type classes work already
20:41:04 <redd_> berengal: that's an efficient way to look at programming in Haskell; I can't count the number of times that I've written half a program, then realized I should have typed my functions differently.
20:41:22 <shachaf> badkins: That's what a type class *is*. "mod" is a method of the class "Integral", which means that you can do "instance Integral Int where mod = ..." and "instance Integral Integer where mod = ...".
20:41:50 <dobblego> badkins, please note the type for mod
20:41:53 <dobblego> @type mod
20:41:54 <lambdabot> forall a. (Integral a) => a -> a -> a
20:42:02 <dobblego> please note the non-existence of Int or Integer in that signature
20:42:30 <Berengal> redd_: I don't know about efficient. I often type myself into a corner using GADTs, type families, higher ranked polymorphism etc, before giving up in frustration ;)
20:43:01 <badkins> dobblego: I understand that means mod will work on Int and Integer, I want my own mod that works only on Int that has a different impl than the mod that works on Integreal
20:43:05 <Berengal> (Learning agda was the dumbest thing I ever did)
20:43:05 <badkins> make sense?
20:43:27 <dobblego> badkins, no, since there is no specific mod that works on Integral
20:43:32 <dobblego> Integral is a type-class
20:43:36 <dobblego> note the => which is not ->
20:43:46 <Berengal> badkins: mod isn't a function, it's just a name with a type. The functions belong to the types, not the class.
20:43:56 <badkins> ahhh!!!
20:43:58 <redd_> Berengal: I was recently introduced to type families, fundeps, and so on (mostly through Oleg's papers). I'm having more fun with Haskell, and finding it more frustrating, than I have in a long time. :)
20:44:01 <badkins> sorry - wow
20:44:14 <badkins> so Int already has it's own mod then
20:44:31 <badkins> which is presumably more efficient than Integer's mod - ok, cool
20:44:46 <redd_> Agda is basically just Gallina compiled with GHC, right?
20:45:22 <Berengal> redd_: Agda is a programming language / proof assistant
20:47:13 <Berengal> redd_: It's sort of a haskell with dependent types
20:47:15 <redd_> Yeah, Gallina is the specification language for Coq. I was under the impression that Agda doesn't support tactics, etc., though.
20:47:40 <unkanon> @src Int mod
20:47:40 <lambdabot> Source not found. That's something I cannot allow to happen.
20:48:26 <Berengal> redd_: I haven't looked at agda recently, but I think they were talking about some sort of tactics language, or some other way of making proofs easier. I don't think it uses Gallina though.
20:49:13 <Berengal> Also, agda has the best emacs mode ever
20:51:43 <dmwit> But the worst vim mode. =/
20:52:31 <Berengal> I desperately want holes in haskell-mode
20:52:56 <dmwit> They are pretty awesome.
20:54:11 <badkins> Berengal: I think I missed something. I just defined a function with type: bja1 :: Num a => a -> a
20:54:26 <badkins> single function, works on both Int and Integer, etc. right?
20:54:42 <badkins> so in what way does it "belong" to the type vs. the type class ?
20:55:08 <badkins> i.e. there's not one impl for Int and a different impl for Integer
20:55:13 <dobblego> @hoogle Word8 -> Bool
20:55:13 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
20:55:13 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
20:55:13 <lambdabot> Data.ByteString notElem :: Word8 -> ByteString -> Bool
20:55:14 <Berengal> badkins: In that case it doesn't. It isn't a class function
20:55:20 <dobblego> @hoogle isSpace
20:55:21 <lambdabot> Data.Char isSpace :: Char -> Bool
20:55:21 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
20:55:21 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
20:55:33 <Berengal> badkins: It just uses class functions
20:55:36 <dobblego> what is that Internal business about?
20:56:06 <badkins> Berengal: the type looks similar to mod though (except Num instead of Integral)
20:56:12 <badkins> so it seems analogous to me
20:56:35 <Berengal> badkins: The type is the same
20:56:52 <badkins> not exactly
20:56:59 <Berengal> badkins: Well, no, not exactly
20:57:20 <Berengal> But you can't look at the type alone to determine if a function is a class function or not
20:57:26 <badkins> I see
20:57:48 <badkins> so you're saying that mod does in fact have separate implementations for Int and Integer though
20:58:09 <Berengal> badkins: Yes. And if you think about it, so does your bja1 function
20:58:20 <Berengal> e
20:58:33 <badkins> really?
20:58:50 <Berengal> The difference is in the real class functions
20:59:10 <Berengal> And since your function use those, your function will behave differently depending on the type as well
20:59:20 <badkins> Ok, I get it. My function is just x * 2, but * has different implementations.
20:59:27 <badkins> gotcha
20:59:32 <Berengal> Right
20:59:42 <badkins> phew - thx for being patient
21:00:25 <Berengal> You can look at classes as interfaces, if you're familiar with java and friends
21:00:35 <badkins> ok
21:00:48 <dobblego> I really do not like that analogy
21:01:07 <Berengal> dobblego: It's simplistic at best, true
21:01:18 <dobblego> it causes havoc for some people
21:01:26 <Berengal> It's true, but it's not the entire truth
21:01:39 <dobblego> more true is that data types are like interfaces
21:02:09 <Berengal> most true is that interfaces are like interfaces and haskell is not like java ;)
21:02:36 <monochrom> eh? data types are like data types. that is all. not cigarettes. not rectangles. just data types.
21:02:38 <badkins> this is a separate question, but if for some reason I didn't like the implementation of mod on the Int type, is it possible to create a mod that overrides the "built-in" ?
21:02:53 <redd_> badkins: Or you can think of type classes as constraining the set of types over which a type variable ranges.
21:02:56 <dobblego> the closest approximation that haskell has to java interfaces is data types
21:02:59 <BMeph> Most true, is that time flies liek an arrow, and fruit flies like a banana. ;√æ
21:03:06 <Berengal> badkins: you could create a newtype
21:03:27 <badkins> no, I'd want it to be used for all Int's
21:03:32 <NemesisD> hi all. working on some haskell problems and was having some trouble getting the types to check out. I have a list of type [(Int, Int)], i'm trying to map randomRIO over it (which is (Random a) => (a, a) -> IO a
21:03:59 <dobblego> NemesisD, I shall take a punt and guess that you want mapM
21:04:26 <Berengal> badkins: You don't really want that. It's okay to change the definition in your code, but you don't want to change the definition in library code (and you can't really do that with separate compilation either)
21:04:45 <badkins> No, for this example, I really *do* want that :)
21:05:12 <NemesisD> dobblego: ah i do. isn't this something to do with the whole controversy having to do with functors and lists being a special case in haskell?
21:05:34 <badkins> Berengal: maybe it's not possible in the same way as Smalltalk/Ruby, etc.
21:05:36 <dobblego> NemesisD, I know of no such controversy, nor can I imagine one, so *shrug*
21:05:50 <dobblego> badkins, you want to newtype Int
21:06:05 <Berengal> badkins: You can always recompile everything from source
21:06:18 <NemesisD> as per usual, i fail to come up with the right terminology when it comes to haskell
21:06:28 <dobblego> NemesisD, do you have a link?
21:06:39 <dobblego> NemesisD, it might be related to the fact that monads do not compose well
21:07:00 * badkins is looking up newtype in The Craft of Functional Programming...
21:07:16 <Berengal> badkins: You'd have to change the standard definition of mod though, or compile with -XNoImplicitPrelude (which causes lots of trouble for modules not designed for that, though a preprocessor could probably fix it up easily enough)
21:07:19 <NemesisD> i know i read something about it in learn you a haskell. let me see if i can find it
21:07:53 <badkins> Berengal: yes, I'm trying to fit a Ruby peg in a Haskell hole, different paradigms, np.
21:09:22 <Berengal> badkins: Yeah. In Haskell, everything compiles "at once", so if there are multiple definitions of something that's an unresolvable conflict. Nothing comes first... conceptually speaking
21:09:40 <ttvd> hi, is it possible to do multiple instructions in ghci on same line?
21:09:45 <ttvd> basically something like let add a b = a + b ; (add 1 2)
21:10:06 <kmc> let add a b = a + b in add 1 2
21:10:07 <dobblego> ttvd, yes exactly as you just did
21:10:19 <kmc> that's a single expression
21:10:25 <dobblego> oh sorry, you want let/in and separate expressions with ;
21:10:39 <ttvd> yeah, or any separator
21:10:48 <dobblego> > let add a b = a + b; minus a b = a - b in add 1 2
21:10:49 <lambdabot>   3
21:11:05 <ttvd> basically i want to run stuff with ghc -e "expr"
21:11:06 <NemesisD> gah i can't find it. i just know it had something to do with list being made a special case for user friendliness or something
21:11:30 <ttvd> dobblego, awesome thanks, i completely forgot about in
21:11:33 <kmc> NemesisD, list comprehensions could be generalized to all monads but aren't
21:11:36 <kmc> (but were in Haskell 1.4)
21:12:34 <dobblego> where is isDigit :: Word8 -> Bool 
21:12:35 <Berengal> NemesisD: several functions are specialized for lists in the Prelude, with the same functions with more general types existing in modules that aren't imported as standard
21:12:37 <dobblego> ?
21:12:57 <kmc> dobblego, makes no sense; numbers and digits aren't the same type
21:13:04 <kmc> digits are characters
21:13:21 <handonson> dobblego: you'd have to Data.Char.isDigit . Data.Char.chr . fromIntegral
21:13:32 <dobblego> handonson, that's what I am doing, but it feels ick
21:13:45 <djahandarie> kmc, though there is an extension for that now :) (I think it's finished.)
21:14:03 <kmc> yep
21:14:18 <handonson> well, since Word8 is not intended to 'be digit' or not be digit, there's no built-in function for that, but you can always define yours
21:14:33 <redd_> Haskell wish list: Set is a monad and monad comprehensions come back, giving us set comprehensions.
21:14:41 <Berengal> There might be a function like that in bytestring
21:15:36 <kmc> let isDigit n = n <= 9
21:16:05 <dobblego> there is isSpaceWord8
21:17:00 <djahandarie> redd_, there are multiple ways to make a set monad in Haskell, but yeah, too bad Data.Set isn't one
21:17:33 <djahandarie> Oh, usually those ways mean it is slow as hell though
21:17:40 <Axman6> you need to use the free monoid!
21:17:53 <kmc> i don't see how a Set type can avoid requiring Eq
21:18:10 <kmc> you can roll up the Eq into the value but then you lose "union" and such
21:18:18 <kmc> or lose efficient implementations of union anyway
21:18:55 <Berengal> kmc: Or you could allow the constraint by adding context aliases/families or some similar magic extension
21:19:33 <djahandarie> You can straight up use a data type around a list for a Set monad if you wanted
21:19:48 <djahandarie> It'd just be sloww
21:20:06 <shachaf> type Set a = a -> Bool
21:20:34 <Saizan> good luck with making that a Monad
21:20:57 <dobblego> instance Contrafunctor Set ... :)
21:22:27 <shachaf> Saizan: Monad? I just wanted to get rid of the Eq requirement.
21:22:31 <redd_> shachaf: isn't there an implementation of that under the name "infinite search"?
21:23:01 <redd_> Yeah, <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time>
21:23:09 <redd_> which is pretty cool.
21:23:12 <bigfred> are there any haskell tutorials  ???
21:23:18 <augur> man you know.. screw this programming crap. ive been having semi-hallucinatory dreams about monads. :|
21:23:30 <Axman6> (>>=) :: Set a -> (a -> Set b) -> Set b -- (a -> Bool) -> (a -> b -> Bool) -> (a -> Bool)
21:23:33 <Axman6> hmm
21:23:38 <Axman6> uh b
21:23:53 <Axman6> @djinn (a -> Bool) -> (a -> b -> Bool) -> (b -> Bool)
21:23:53 <lambdabot> f _ _ _ = False
21:24:00 <Axman6> monad!
21:24:24 <bigfred> OK  tutorilals 
21:24:37 <Axman6> @where lyah
21:24:37 <lambdabot> http://www.learnyouahaskell.com/
21:24:40 <Axman6> bigfred: start there!
21:24:45 <bigfred> can i get one ????
21:24:56 <Axman6> i just gave you one!
21:24:59 <Axman6>  !!!!
21:25:08 <redd_> @where yaht
21:25:09 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
21:25:09 <bigfred> ok thanks
21:25:20 <Axman6> redd_: eh :\
21:25:20 <shachaf> bigfred: Save your question marks for the questions you get after reading that. You only get a limited number in your life. :-)
21:25:35 <redd_> eh?
21:25:38 <shachaf> People still recommend YAHT?
21:25:53 <bigfred> yes   thanks   i am from China 
21:25:59 <bigfred> my english is not good 
21:26:26 <Axman6> bigfred: when you have finished lyah, try real world haskell:
21:26:30 <Axman6> @where rwh
21:26:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:27:06 <bigfred> Ok  thanks 
21:27:47 <redd_> I like YAHT. It's succinct and comprehensive.
21:27:49 <bigfred> axman6  can i send    your a email 
21:28:02 <Axman6> why?
21:28:23 <bigfred> i want to make afriend to you 
21:28:40 <bigfred> especaily foreigin peple
21:28:52 <Axman6> make lots of friends in here :D
21:29:11 <Axman6> bigfred: also, you should talk to ManateeLazyCat when he's here, he's from china
21:29:22 <bigfred> OK
21:29:24 <bigfred> thanks 
21:29:34 <bigfred> where are you from  ???
21:29:36 <Axman6> there's a few other chinese people here too
21:29:38 <monochrom> you don't need email to be friends
21:29:44 <Axman6> Australia, i'm in Japan at the moment
21:29:59 <bigfred> oh 
21:31:41 <djahandarie> It'd be neat to learn Chinese... but it also looks difficult and like a big pain
21:31:54 <bigfred> ÂìàÂìà
21:31:56 <bigfred> ÁúüÁöÑÂêó
21:32:02 <bigfred> ‰Ω†ÂñúÊ¨¢‰∏≠ÊñáÔºü
21:32:30 <bigfred> <djahandarie>  you like Chinese ?
21:32:38 <Hunner> djahandarie: it's easier than japanese :)
21:32:40 <Cale> djahandarie: It's more manageable than you'd think (I don't actually know much Chinese though, just some Japanese.)
21:32:47 <bigfred> i can teach you Chinese
21:33:20 <Cale> The Chinese characters are built somewhat systematically from repeated parts, so it's not insane :)
21:33:32 <djahandarie> "Haha" "It is true" "Are you glad to be letters something or another"
21:33:37 <Axman6> i should really know more japanese... since i'm living in tokyo :\
21:33:37 <djahandarie> Just from my kanji knowledge
21:33:38 <djahandarie> lol
21:33:44 <bigfred> Janese is east than Chinese  ,all right ?
21:33:51 <djahandarie> Last one was hard
21:34:05 * monochrom is glad to be letters
21:34:09 <Cale> djahandarie: Okay, so you already know :)
21:34:38 <bigfred> Is Chinese hard than Haskell  ???
21:34:42 <djahandarie> monochrom, I probably did a better job than google translate
21:34:54 <djahandarie> Oh damn
21:34:57 <djahandarie> It beat me
21:34:58 <djahandarie> Haha
21:35:02 <Cale> bigfred: Probably most natural languages are harder than Haskell to learn.
21:35:04 * djahandarie hangs head in shame
21:35:13 <bigfred> haha 
21:35:22 <bigfred> you are right ! Cale 
21:35:26 <Hunner> Cale: Except for Esperanto and Toki Pona :)
21:36:30 * BMeph demands a Pona!
21:36:41 <Axman6> cabal install pona!
21:36:46 <dobblego> @hoogle lines :: ByteString -> [ByteString]
21:36:46 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
21:36:46 <lambdabot> Data.ByteString.Lazy.Char8 lines :: ByteString -> [ByteString]
21:36:46 <lambdabot> Data.ByteString.Char8 unlines :: [ByteString] -> ByteString
21:37:23 <monochrom> cabala installa pona
22:00:53 <phao> Hi..
22:01:10 <phao> WIth languages like haskell, common lisp, java, and all those other high level languages out there
22:01:34 <phao> why do people still use languages like C to develop programs that could be design with those other languages?
22:01:51 <phao> unix software is a big example of that...
22:04:18 <PatrickRobotham> phao: Sometimes they want to get the extra speed boost.
22:05:10 <kmc> sometimes they need speed or low level control
22:05:21 <kmc> sometimes they know C really well and can't justify learning a new language for the project
22:05:23 <kmc> sometimes it's because they're dumb
22:05:38 <dmwit> Are these discussions ever actually productive?
22:05:57 <kmc> even if you need C performance, you probably don't need it in all the boring initialization and glue code that every program has
22:06:05 <kmc> and every respectable HLL has a way to link to C functions
22:06:34 <kmc> (i don't know about CL but Haskell and Java do, as well as Python, Lua, Javascript, ...)
22:07:18 <phao> dmwit, I ask more out of curiosityu
22:11:08 <argiopeweb> All the mature CL compilers of which I'm aware do.
22:13:44 <c_wraith> phao, in general the answer is "inflexibility on the part of developers"
22:15:20 <kmc> if your idea of a high level language is C++ and Java then perhaps you'd like to stick with C
22:15:56 <kmc> that's part of it
22:16:25 <phao> the only language I actually consider low level is assembly
22:16:35 <phao> the rest I believe is high level, but obviously there are some more expressive than others
22:16:50 <kmc> that seems arbitrary
22:16:56 <kmc> there's a continuum anyway
22:17:02 <kmc> so why care too much about where to draw the line
22:17:04 <edenc> phao: any language that maps directly to binary is low-level
22:17:25 <kmc> haskell maps directly to binary.  the mapping is named "GHC"
22:17:35 <kmc> anyway, nothing good will come of this
22:17:36 <kmc> ttyl
22:17:39 <phao> edenc, what do you mean?
22:18:35 <edenc> phao: if I decide to write a language and it supports the complete instruction set of the architecture it's going to run in, it's low-level
22:18:57 <phao> C doesn't do that, right?
22:19:16 <edenc> you can inline machine code in C
22:19:40 <phao> but then you'd be writing assembly
22:19:44 <edenc> if you consider that to be "supporting the complete instruction set" then it does
22:19:53 <edenc> no, you'd be writing machine code
22:20:13 <phao> where can I find an example of that?
22:21:30 <edenc> in any introductory C course
22:23:05 <edenc> phao: the point is, kmc's question deserves attention: "why care too much about where to draw the line"
22:23:42 <phao> I honestly didn't understand what he meant by that question
22:23:48 <phao> and, I've read K&R, twice
22:23:55 <phao> don't remember seeing this you're talking there.
22:24:28 <phao> I've heard some things about writing assembly code inside C source, but that's all I heard
22:27:20 <edenc> phao: the concept of low-level vs high-level is very obtuse and subjective because there are all sorts of theoretical holes you can exploit in the discussion
22:27:35 <edenc> again kmc is right, there's no point discussing it
22:27:37 <Cale> Also, they're relative terms
22:33:07 <max> ?
22:33:08 <lambdabot> max: You have 1 new message. '/msg lambdabot @messages' to read it.
22:33:10 <max> whoa
22:33:18 <max> this is COOOOOOOOOOOOOOOOOOOL
22:47:08 <rillian> newbie question. I'm trying to install git-annex on debian lenny
22:47:15 <rillian> but it's a bit of a dependency hell
22:47:56 <rillian> the system has ghc 6.8.2
22:48:03 <rillian> I build and installed cabal from source
22:48:14 <rillian> which let me install the pcre-light dependency
22:48:37 <rillian> and everything else but 'missingh' is in the system packages
22:49:06 <handonson> lol
22:49:14 <rillian> however, missingh depends on base 4.*, which cabal says conflicts
22:50:03 <rillian> is there an easy way around this, or am I better off just building a local copy of the latest GHC?
22:50:18 <rillian> handonson: indeed :)
22:53:51 <Cale> rillian: ghc 6.8.2 is super-old
22:54:33 <Cale> (It's from 2007 :)
22:54:45 <shachaf> GHC 6.8 is from 2007?
22:54:49 <Cale> yeah
22:54:49 <shachaf> That's ridiculous.
22:55:00 * shachaf must have been kidnapped by aliens.
22:55:13 <Cale> rillian: Don't compile ghc yourself, there are generic linux binaries available on the GHC website
22:55:21 <rillian> three whole years!
22:55:34 <Cale> rillian: The reason you don't want to build GHC yourself is that it requires a working recent GHC :)
22:56:05 <Cale> (and it takes hours and hours)
22:56:10 <rillian> Cale: I vaguely remember this from the first time I used darcs. I had to bootstrap through three different versions of ghc
22:56:50 <Cale> Basically, if you're not hacking on it yourself, you shouldn't be compiling GHC.
22:57:50 <rillian> so the answer to 'is there an easy way around dependency hell' is 'no' then? :)
22:58:45 <handonson> don't use system packages
22:58:49 <handonson> use cabal packages
22:59:02 <rillian> how do I cabal-install ghc?
22:59:10 <handonson> you can't, but you don't need to
22:59:15 <rillian> and the reset of the 'haskell-platform'
22:59:33 <Cale> rillian: Well, what I recommend is to grab the generic linux binary of GHC, and then get cabal-install, and install all the rest of the packages you need as user.
22:59:50 <Cale> (whereas you'll tend to install GHC globally)
23:00:04 <rillian> how do I tell it to ignore the system packages?
23:00:09 <Cale> uninstall them
23:00:33 <rillian> what if someone else is using them?
23:00:33 <handonson> wait, lenny doesn't have the pacakge haskell-platform?
23:00:44 <handonson> oh, of course. lenny is the stable one, right?
23:00:50 <Cale> Well, once you install ghc locally, it'll go to /usr/local, which will tend to override anything in /usr anyway
23:01:09 <rillian> right (to both)
23:01:52 <rillian> also, it cabal needs a 'remove' command :P
23:02:14 <handonson> grr yeah
23:02:25 <Cale> rillian: This is why you install cabal packages as user. They'll all go into ~/.cabal and ~/.ghc that way, making it easy to blow them away if you need to.
23:02:47 <Cale> If you get them mixed up with the packages that come with ghc, you'll invite dependency hell on yourself.
23:11:01 <rillian> is the generic ghc binary supposed to come with cabal?
23:11:17 <Axman6> it comes with cabal, not cabal-install
23:11:55 <rillian> aha, but if I use it to bootstrap cabal-install, I can then cabal install haskell-platform?
23:12:08 <Axman6> no
23:14:18 <rillian> there's not associated meta-package?
23:15:45 <Axman6> i don't believe cabal has meta packages
23:16:28 <Cale> haskell-platform comes with ghc and a bunch of packages
23:17:12 <Cale> (including cabal-install)
23:20:21 <dobblego> someone asked me about cabal meta-packages the other day, but I suppose it can't be too difficult
23:20:44 <Cale> All the machinery is pretty much there to make meta-packages, I think.
23:20:55 <Cale> Just make an empty package which depends on stuff.
23:21:03 <dobblego> yeah that's all I'd do
23:25:44 <rillianbis> sorry, had to switch terminals
23:33:50 <rillianbis> ok, git-annex compiled. thanks for your help!
