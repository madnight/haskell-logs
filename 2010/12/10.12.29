00:00:50 <flipped> it seems its idea for parsing tree can be used to parse my regex, i'm read more before start coding my own parser
00:01:10 <j-invariant> oh good
00:01:45 <flipped> this is a similar one using parsec http://en.wikibooks.org/wiki/Haskell/Practical_monads
00:03:26 <Philippa_> flipped: many such parsing libraries exist, there's a huge range of them for haskell, I just don't know them all well
00:04:22 <Philippa_> hackagedb would be the place to look to explore what's there
00:10:02 <bsmntbombdood> is IO a MonadPlus?
00:10:27 <ddarius> @instances MonadPlus
00:10:28 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
00:10:30 <ddarius> Yes.
00:10:49 <bsmntbombdood> how is it defined?
00:11:04 <ddarius> I'm pretty sure it uses fail and catch.
00:11:12 <ddarius> @src IO mplus
00:11:12 <lambdabot> m `mplus` n = m `catch` \_ -> n
00:14:17 <bsmntbombdood> hmm
00:14:18 <Gracenotes> which makes mzero a bit of a downer
00:14:35 <bsmntbombdood> i'm not sure how that makes sense as mplus
00:14:55 <c_wraith> it doesn't, really.
00:15:03 <Gracenotes> it's not terribly useful
00:15:07 <shachaf> Where is that instance normally defined?
00:15:15 <Gracenotes> but I believe it satisfies the MonadPlus laws
00:15:22 <c_wraith> That instance is someplace crazy
00:15:36 <c_wraith> @instances MonadPlus
00:15:37 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
00:15:42 <c_wraith> bah, that's no help
00:15:44 <ddarius> There are two sets of (conflicting) laws that one could argue a MonadPlus instance could hold.
00:16:00 <ddarius> Cale describes one set as MonadOrElse and that IO instance fits that.
00:16:29 <c_wraith> heh.  But there's not STM instance
00:16:32 <c_wraith> err, *no
00:16:39 <ddarius> The other is, in Cale's opinion and mine as well, the one that MonadPlus should mean, which has a distributive mplus.  I think there is a good case for having both classes in the Haskell libraries.
00:16:53 <ddarius> @instances-import Control.Concurrent.STM MonadPlus 
00:16:54 <lambdabot> Couldn't find class `MonadPlus'. Try @instances-importing
00:17:18 <Gracenotes> distributive on which two operators?
00:17:32 <ddarius> @instance-importing Control.Monad.STM
00:17:33 <lambdabot> Couldn't find class `Control.Monad.STM'. Try @instances-importing
00:17:36 <ddarius> @instance-importing Control.Monad.STM MonadPlus
00:17:36 <lambdabot> Couldn't find class `MonadPlus'. Try @instances-importing
00:17:45 <ddarius> Well, there is a MonadPlus instance in that module.
00:17:54 <bsmntbombdood> mplus m mzero == catch m (\_ -> mzero) == m
00:18:12 <ddarius> Gracenotes: Er rather, (>>=) is distributive over mplus.
00:18:23 <ddarius> @wiki MonadPlus
00:18:24 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
00:18:37 <Gracenotes> welll. if m throws an exception, mzero may not be the same exception
00:18:53 <ddarius> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
00:18:55 <c_wraith> I assume the one in STM is MonadOrElse.  given, you know, the existence of orElse :)
00:19:33 <bsmntbombdood> ohh
00:21:21 <Gracenotes> finished Good Omens today. would recommend.
00:21:25 <j-invariant> can all the diagrammatic definitions in category theory (like 1 => GF, FG => 1) be written in terms of isomorphism (like D(FX,Y)~=C(X,GY))?
00:22:36 <ddarius> A (plain) commutative diagram is just a representation for a system of equations.  It has nothing to do with isomorphisms.
00:23:00 <bsmntbombdood> @type fail
00:23:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
00:23:59 <bsmntbombdood> are there any cases where mzero isn't the same as fail?
00:24:23 <c_wraith> how technically?  I mean, fail in IO isn't mzero in IO.
00:24:45 <c_wraith> They both throw exceptions, but fail includes the text as part of the error message
00:24:55 <bsmntbombdood> that counts as the same
00:25:03 <Gracenotes> the semantics of fail are... er... are they prescribed anywhere?
00:26:07 <Gracenotes> they're a rather syntactic thing in use
00:26:33 <c_wraith> I don't think I've seen anything other than "fail is called if the pattern-match fails"
00:26:53 <c_wraith> Which describes when it's called, but not what it should do
00:27:21 <Gracenotes> MonadZero and MonadPlus... where's that proposal going
00:27:50 <ddarius> Haskell 1.4 2.0
00:29:15 <Philippa_> c_wraith: I think it's deliberately unconstrained. Obviously it's not supposed to launch missiles without some further layer causing it, but that's unsafePerformIO for you
00:29:40 <ddarius> "The arcing marks and smoke residue on the side plate is a giveaway as to the failure mode."
00:29:42 <Philippa_> it /can/ do anything that's convenient: maybe the monad has a sensible way of representing it, but it doesn't attempt to constrain the semantics of that. Maybe it's just bottom
00:30:21 <Philippa_> the string part is bad, IMO - I know it's meant to be by analogy to error, but yeesh
00:30:21 <c_wraith> Yeah.  the type constricts it to be bottom in some cases, but in the cases where it's not, I suppose it's worth having all the options be available.
00:30:41 <ddarius> I think the intent is that it behaves like mzero (and in fact in Haskell 1.4 mzero is what was used for this), but they can't actually say that because several monads have no sensible mzero.
00:30:44 <ddarius> So they just said nothing.
00:31:04 <Philippa_> mmm. Plus you can imagine cases that don't quite behave that way
00:31:22 <ddarius> Well, with the string there, yes.
00:31:49 <Philippa_> that too, though that'd come under the frequent "modulo ..." clause
00:32:21 <Philippa_> (has anyone actually written an article or post on the subject of tasteful cases along those lines?)
00:32:24 <c_wraith> I'd be happy without special rules for irrefutable pattern match failures in monadic binds.
00:32:45 <bsmntbombdood> mzero/fail being bottom is sensible
00:32:47 <c_wraith> If there weren't special rules for that, fail probably just wouldn't exist.
00:32:55 <Gracenotes> you could allow them with a MonadPlus instance. But... suppose the instances are in separate modules. yarr.
00:33:34 <erikina> is " f . g x" the same as "f (g x)"
00:33:43 <c_wraith> erikina, not quite.
00:33:59 <c_wraith> "(f . g) x" is the same as "f (g x)"
00:34:16 <c_wraith> function application binds more tightly than infix operators
00:34:47 <Veinor> erikina: f . g x is the function that takes y and returns f ( (g x) y )
00:34:53 <Veinor> @unpl f . g x
00:34:53 <lambdabot> (\ c -> f (g x c))
00:34:59 <erikina> so "f . g x" is the same as "(f g) x"
00:35:19 <c_wraith> Not at all.
00:35:24 <c_wraith> that's just "f g x"
00:35:30 <Philippa_> c_wraith: I'd like for non-trivial pattern matches to invoke a separate class myself, but that's life for you
00:36:08 <Gracenotes> [ h = f . g x ], and h y = f (g x y)
00:36:19 <erikina> Ohhh, I think I see
00:36:31 <erikina> So . is actually a function, rather than some syntax
00:36:34 <c_wraith> yes
00:36:38 <c_wraith> :t (.)
00:36:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:36:42 <c_wraith> err.
00:36:42 <Philippa_> (then you'd have a standard wrapper newtype for when you don't care, and separate deriving clauses or something)
00:36:46 <Gracenotes> lol
00:36:48 <c_wraith> :t (Prelude..)
00:36:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
00:36:51 <c_wraith> there
00:37:13 <j-invariant> why is (.) a functor?
00:37:22 <Gracenotes> If [ h = f . g x . u v ], and h y = f (g x (u v y))
00:37:25 <j-invariant> f.X is a functor
00:37:38 <dibblego> j-invariant, ((->) t) is a functor given by (.)
00:37:41 <j-invariant> if F is a functor
00:37:45 <Gracenotes> it doesn't need to be a dot, but it wouldn't look like function composition otherwise
00:37:49 <c_wraith> > fmap (*2) (+1) 5
00:37:51 <lambdabot>   12
00:37:53 <j-invariant> given f :: a -> b then  f.Fa = Fb ?
00:37:54 <erikina> so: "(.) f g x" is the same as "f g x" 
00:37:57 <Gracenotes> ...or some other dot-like thing
00:38:17 <j-invariant> that doesn't make sense
00:38:21 <Gracenotes> uh.. close. f (g x).
00:38:37 <ddarius> Gracenotes, c_wraith: You should look at the Haskell 1.4 design if you haven't already.
00:38:53 <bsmntbombdood> what does ((->) t) mean?
00:39:07 <c_wraith> it's a type
00:39:16 <Gracenotes> (->) is a type constructor taking two types. ((->) t) is a partially applied type.
00:39:19 <c_wraith> In particular, it's the type of functions from t
00:39:35 <bsmntbombdood> that
00:39:36 <c_wraith> @kind ((->) a)
00:39:38 <lambdabot> Not in scope: type variable `a'
00:39:40 <c_wraith> @kind ((->) Int)
00:39:41 <lambdabot> ? -> *
00:39:42 <arcatan> :t fmap (+ 1)
00:39:43 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
00:39:45 <j-invariant> f : A --> B and for a functor F : C --> D, f . (x :: FA) :: FB
00:39:51 <Gracenotes> > let foo :: (->) Int ((->) Int Int); foo = (+) in foo 3 4
00:39:53 <lambdabot>   7
00:39:59 <j-invariant> how does that work
00:40:12 <Philippa_> ddarius: same for me, or am I saying something vaguely new?
00:40:26 <bsmntbombdood> oh cool, didn't know you could do that with types
00:40:34 <ddarius> Philippa_: Probably same for you.
00:40:45 <j-invariant> that (.) thing is wrong
00:40:46 <c_wraith> Though the kind of (->) is rather different from most kinds
00:40:51 <j-invariant> it's Ff . Fx
00:41:00 <j-invariant> a . b = Ff Fb
00:41:02 <c_wraith> @kind (->)
00:41:04 <lambdabot> ?? -> ? -> *
00:41:07 <j-invariant> sorry
00:41:10 <j-invariant> a . Fb = Ff Fb
00:41:16 <Gracenotes> > let bar :: (->) ((,) Int Int) Bool; bar = uncurry (==) in bar (3, 4)
00:41:17 <lambdabot>   False
00:41:38 <bsmntbombdood> is there any reason to actually write a type signature like that?
00:41:48 <j-invariant> 5~08:36 < lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:41:50 <Gracenotes> circumfixity is weird both at type-level and expression-level
00:41:52 <c_wraith> Only in the case where you want to partially apply it
00:41:57 <Philippa_> c_wraith: that's a GHC artefact rather than H2010 though
00:42:01 <j-invariant> ^ this thing looks wrong to me if you think in terms of category theory
00:42:11 <c_wraith> Philippa_, yes, indeed.  That's an implementation detail
00:42:39 <ddarius> j-invariant: Most of what you've written is non-sensical, so I recommend getting more familiar with both category theory and Haskell.
00:42:40 <j-invariant> in fact it's just (.) = F for a functor F
00:42:47 <bsmntbombdood> a partially applied type signature?
00:43:00 <RayNbow`TU> :t fmap
00:43:00 <j-invariant> (.) f = Ff
00:43:00 <Gracenotes> instance Functor ((,) a) where ...
00:43:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:43:02 <Philippa_> j-invariant: the forall a b. part says it's an endofunctor across the /whole/ of haskell, * -> * is what you'd expect - you feed a type in and get one out. What's confusing?
00:43:10 <c_wraith> bsmntbombdood, The most common reason for doing that is instance declarations:  instance Monad ((->) r) where ...
00:43:12 <j-invariant> if  f : a -> b  then  Ff : Fa -> Fb
00:43:25 <Gracenotes> > fmap (+100) (2, 2)
00:43:26 <lambdabot>   (2,102)
00:43:27 <j-invariant> so (.) f = Ff why is that called compose rather than map?
00:43:51 <remy_o> @type (.)
00:43:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:45:00 <remy_o> j-invariant: (.) is compose when you take f x = (c -> x)
00:45:31 <remy_o> j-invariant: so it is the expected thing is usual cases
00:45:38 <j-invariant> that is the covariant Hom functor?
00:45:42 <remy_o> yes
00:45:44 <ddarius> Yep.
00:45:47 <tomh1> If I want to perform an IO action inside a function, will that function have to return IO something?
00:45:53 <remy_o> I don't know if it's standard or only in lambdabot
00:46:02 <c_wraith> remy_o, it's only in lambdabot 
00:46:05 <Philippa_> ddarius: so 1.4 is almost my proposal except it's also got to be the monad's zero - fair enough
00:46:06 <j-invariant> can you define the contravariant Hom functor without using composition?
00:46:07 <bsmntbombdood> Gracenotes: how is that different from (a,b) and ignoring the value of b?
00:46:12 <erikina> So why does "(.) succ negate 8" work (returns -7) but "succ . negate 8" not work?
00:46:28 <bsmntbombdood> Gracenotes: how is that different from (a,b) and ignoring the value of b?
00:46:37 <c_wraith> erikina, parsing rules.  (.) is a function.  . is an infix operator.  they parse differently
00:46:38 <ddarius> j-invariant: The Hom bifunctor -is- pre-/post-composition on the arrows.
00:46:44 <remy_o> j-invariant: composition is in syntax and does not need the dot
00:46:47 <j-invariant> ddarius: the (.) is circular then?
00:46:53 <Gracenotes> bsmntbombdood: the instance declaration..?
00:46:53 <j-invariant> circular definition (meaningless)
00:46:57 <Bynbo7> erikina: that parses as succ . (negate 8)
00:47:02 <bsmntbombdood> Gracenotes: yeah
00:47:11 <Gracenotes> bsmntbombdood: you don't say instance Functor (Maybe a). You say instance Functor Maybe
00:47:12 <j-invariant> remy_o: oh good point
00:47:25 <remy_o> @type flip
00:47:26 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
00:47:32 <remy_o> this one is also tricky
00:47:34 <j-invariant> I understand it now thanks
00:47:45 <j-invariant> does that correspond to anything in category theory?
00:47:45 <Gracenotes> where there's class Functor f where, and (f a) in all the type signatures
00:48:04 <j-invariant> I don't think I've ever seen F(a->b) before
00:48:11 <erikina> Bynbo7,  c_wraith: thanks, i understand a little more :)
00:48:12 <Gracenotes> bsmntbombdood: so, if you want to say (a, b) is a functor, you declare it as (a, __).
00:48:18 <ddarius> :t (<*>)
00:48:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:48:24 <Gracenotes> for tuples, that's via the expanded syntax (,) a b
00:48:33 <Gracenotes> bsmntbombdood: make sense?
00:50:04 <bsmntbombdood> not really
00:50:20 <Gracenotes> :3
00:50:38 * RayNbow`TU tries to remember what is being flipped in lambdabot's definition of flip...
00:50:39 <c_wraith> bsmntbombdood, are you familiar with the concept of a Kind?
00:50:40 <Gracenotes> well what would you expect instead
00:50:57 <bsmntbombdood> c_wraith: yeah, barely
00:50:57 <RayNbow`TU> (I know I've once asked this question before here in #haskell)
00:51:10 <bsmntbombdood> Functor needs a type of kind * -> *, right?
00:51:23 <c_wraith> bsmntbombdood, Well, when you define a class, there's a specific kind instances have to be.
00:51:34 <c_wraith> And yes, Functor needs to be * -> *
00:51:40 <bsmntbombdood> why?
00:51:42 <Gracenotes> kind inference
00:51:47 <c_wraith> Look at the definition
00:51:49 <c_wraith> @src Functor
00:51:50 <lambdabot> class  Functor f  where
00:51:50 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
00:52:08 <c_wraith> f is being applied to a type that's being used as an argument and return value
00:52:11 <Veinor> what was the name of -fvia-C's assembly monger?
00:52:14 <olsner> is there any type-system extension to allow some flexibility on that?
00:52:18 <Gracenotes> the kind of the function (->), simplified, is * -> * -> *.
00:52:18 <Veinor> *munger
00:52:24 <c_wraith> Veinor, Evil Mangler
00:52:27 <bsmntbombdood> oh, of course
00:52:27 <Gracenotes> so we know that (f a) has kind *.
00:52:35 <Gracenotes> thus, f has kind (* -> *)
00:52:38 <Veinor> ah
00:52:40 <olsner> Veinor: there's also the Satanic Splitter
00:52:47 <Veinor> ... which does?
00:52:54 <Gracenotes> ..one two skip a few logical derivations
00:53:55 <Gracenotes> try some :k-ing in your ghci
00:54:11 <c_wraith> bsmntbombdood, So, you know Functor needs * -> *.  But (a, b) has kind *.  So you need a syntax to partially apply the tuple type.
00:54:37 <c_wraith> Same with [a] going to [] a, and (a -> b) going to ((->) a b)
00:55:01 <olsner> Veinor: something evil and magical :) I'm shady on the details, but there are magic markers inserted in the assembly code output by gcc (inserted through inline assembly, I guess), and the splitter splits functions at those markers
00:55:11 <bsmntbombdood> does that mean you can't define a functor across homogenous tuples that fmaps across all their values?
00:55:18 <Veinor> ahh.
00:55:23 <c_wraith> bsmntbombdood, yes, it does
00:55:38 <ddarius> olsner: I'd be amazed if you -weren't- shady on the details.
00:55:40 <c_wraith> bsmntbombdood, You could fake it with a newtype, though. :)
00:55:50 <ddarius> No one really knows who the Evil Mangler does or how it does it anymore.
00:55:56 <Gracenotes> or how about with type synonyms and a GHC extension
00:55:57 <c_wraith> who?
00:56:09 <Veinor> ddarius: thank god -fvia-C is deprecated
00:57:15 <ddarius> The Evil Mangler started off as a hacky solution to a ugly problem and the organically grew over the next -twenty- years.
00:57:34 <Veinor> dear god
00:58:19 <RayNbow`TU> :t flip . flip
00:58:20 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
00:58:34 <Gracenotes> I think a complete description of the Evil Mangler is described in an affidavit somewhere
00:58:48 <c_wraith> was someone sued over it?
00:58:48 <bsmntbombdood> c_wraith: newtype Tuple a = Tuple (a, a); and then instance Functor Tuple, right?
00:58:49 <Gracenotes> not yet released to the general public
00:58:56 <c_wraith> bsmntbombdood, exactly
00:59:06 <Gracenotes> nailed it bsmntbombdood 
00:59:13 <bsmntbombdood> sweet
00:59:37 <c_wraith> newtypes are sometimes used to fake type-level lambdas :)
00:59:51 <bsmntbombdood> so... a newtype is like a function of types
01:00:04 <c_wraith> Or at least they can be used that way
01:00:32 <c_wraith> I mean, newtype X = X Int isnt' a type function :)
01:21:20 <jaspervdj> Axman6: I can't make form a monad, see comment :-(
01:22:14 <Bynbo7> really? i managed to make it a monad, though i'm not sure if the semantics are right
01:24:30 <Bynbo7> jaspervdj: see https://github.com/axman6/digestive-functors/blob/master/digestive-functors/src/Text/Digestive/Types.hs
01:27:38 <Bynbo7> jaspervdj: does that look somewhat reasonable? i wasn't sure what to do with the View values
01:28:35 <Bynbo7> i just anted it because it gives me more flexibility in what i can use digestive fuctors for. it would suck if there's a whole bunch of forms i can't create with them
01:51:36 <phao> lol
01:51:47 <phao> translating simple grammars to haskell is almost as rewriting text
01:52:26 <Jafet> Clearly we should have a grammar rewriting grammar
01:53:00 <ddarius> @hackage BNFC
01:53:00 <lambdabot> http://hackage.haskell.org/package/BNFC
01:53:59 <phao> hehehehe
01:54:09 <phao> I mean
01:54:19 <phao> even without using the do value <- parser ... return ...
01:54:20 <phao> syntax
01:54:25 <phao> even then it's easy
01:54:53 <phao> I think it's all about thinking which are the right primitives, or at least good ones
01:57:43 <portnov> hi all
01:58:18 <c_wraith> phao: take the parsec approach, throw in everything you think anyone might want
01:58:39 <portnov> Q: with code http://paste.in.ua/1585/ , are there any guaranties that c_closePDF will be called after all peekCString's ?
01:59:18 <Bynbo7> none at all. use something like catch or bracket
01:59:22 <Bynbo7> :t bracket
01:59:23 <lambdabot> Not in scope: `bracket'
01:59:32 <Bynbo7> :t Control.Exception.bracket
01:59:32 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
01:59:35 <portnov> hmm.
01:59:49 <c_wraith> Well.  If the question was "will it only be called after the others finish", yes.
02:00:03 <c_wraith> But if the question was "will it be called even if one of the others raises an exception", no
02:00:04 <portnov> hmm.
02:00:04 <ddarius> I don't actually think peekCString can throw an exception Haskell can catch.
02:00:35 <ddarius> Of course, I have no idea what c_getAuthor and co. could throw.
02:01:00 <portnov> ok
02:03:16 <ddarius> I also find it bizarre that you line up three out of four of the <-s.
02:03:28 <jaspervdj> Bynbo7: hang on, looking at it
02:04:11 <mrdk_> How could I simplify this code? http://hpaste.org/42641
02:05:00 <portnov> main question was, can GHC try to execute first c_closePDF and only then peekCString. As you can see, c_closePDF does not depend on peekCString-s results explicitly.
02:05:10 <mrdk_> maybe using list comprehensions?
02:05:35 <Bynbo7> portnov: this is exactly what the IO monad guarantees :\
02:05:35 <j-invariant> I define product in category theory but I have given Y --> A and Y --> B a map AxB --> Y.. shouldn't I have Y --> AxB?
02:05:37 <Bynbo7> well, sort of
02:05:52 <Bynbo7> unless you use lazy IO or threads...
02:06:08 <portnov> ok, nice.
02:06:19 <c_wraith> huh.  Oleg just sent an email to -cafe pointing out a paper from 1965 that talked about the monad/IO connection.  In algol.
02:06:30 <remy_o> j-invariant: you don't need AxB -> Y for that
02:06:40 <jaspervdj> Bynbo7: right, it looks reasonable, but the problem is that, say if you have two fields, X & Y
02:06:56 <jaspervdj> Bynbo7: the validation of X fails, resulting in an error
02:07:06 <jaspervdj> Bynbo7: then the Y field won't show up in the HTML
02:07:06 <j-invariant> remy_o: I managed to find AxB --> Y and I cannot find Y --> AxB so it makes me think I have done something wrong
02:08:16 <remy_o> @type \f g x -> (f x, g x)
02:08:18 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
02:08:56 <remy_o> j-invariant: the product is such that Hom(Y, AxB) = Hom(Y,A) x Hom(Y,B)
02:10:00 <ddarius> j-invariant: The universal property characterizes the existence of an arrow Y -> AxB given two arrows Y -> A and Y -> B.  When you want to say that a given concrete category has products you need to make that mapping.  When you are talking about arbitrary categories with products, you are given (assuming/asserting) that the mapping exists (or equivalent data.)
02:10:38 <ddarius> You can't create the mapping just from knowing that something is a category and having some arrows because products don't exist in all categories.
02:11:41 <j-invariant> I defined the cone from the Bool diagram into C by F True = A ; F False = B ; F id_True = id_A ; F id_False = id_B
02:12:04 <j-invariant> so C is the product of AxB if we can make an initial cone with that vertex
02:12:44 <j-invariant> but I constructed AxB --> X from X --> A and X --> B
02:12:55 <j-invariant> so somehow mine is backwards
02:14:20 <j-invariant> it's not porduct and it#s not coproduct so I wonder what object it is, maybe it never exists?
02:15:16 <Bynbo7> jaspervdj: hmm, not sure how to get around that. maybe keep a list of errors or something?
02:15:54 <jaspervdj> Bynbo7: it can't be done in monad unfortunately
02:16:01 <jaspervdj> @type (>>=)
02:16:02 <Bynbo7> :\
02:16:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:16:36 <jaspervdj> Bynbo7: What I would do is create a simple ADT for which you can easily create an Applicative
02:16:56 <jaspervdj> Bynbo7: and then have a Tmp -> WhateverYouWant function
02:17:11 <jaspervdj> Bynbo7: and then apply this function with fmap
02:17:15 <jaspervdj> (on the Form)
02:17:35 <Bynbo7> hmm, that could work, but seems unnecessary
02:17:38 <ddarius> j-invariant: You would want to look for the terminal cone, not the initial cone.
02:18:29 <jaspervdj> Bynbo7: you can convince yourself it isn't possible in monad by looking at the type of (>>=)
02:18:30 <j-invariant> ddarius: thanks! That was confusing the heck out of me - terminal cones are for limits (like product) and initial cones are for colimits then
02:18:41 <ddarius> Initial cocones.
02:18:58 <jaspervdj> Bynbo7: The problem is that for `x >>= f`, `f` really needs an `a`
02:19:15 <jaspervdj> Bynbo7: which will not be produced if any previous field fails
02:19:22 <j-invariant> is a Terminal cone and an initial cocone the same thing?
02:19:27 <ddarius> No.
02:19:32 <j-invariant> oh :(
02:19:32 <ddarius> Cone and cocone aren't the same thing.
02:20:23 <c_wraith> My friend likes to joke that a nut and a coconut are the same, though.
02:20:38 <Bynbo7> jaspervdj: hmm, true
02:20:48 <j-invariant> what if cones and cocones are the same?
02:20:52 <ddarius> c_wraith: Start throwing some coconuts at him and he may change his mind.
02:20:56 <j-invariant> a cone from N to F is a cocone from F to N
02:22:13 <j-invariant> is that wrong?
02:22:19 <j-invariant> http://en.wikipedia.org/wiki/Category_of_cones#Category_of_cones
02:22:20 <ddarius> j-invariant: (Co)cones are just natural transformations which naturally sit at the 2-categorical level.  There are two different notions of "op" in a 2-category.
02:22:46 <jaspervdj> Bynbo7: I'm going afk, got some more studying to do, feel free to ping me if anything comes up though, I'll read it later
02:23:13 <j-invariant> I wonder if I am capable of understanding 2-category yet
02:23:46 <Bynbo7> jaspervdj: cheers, take care
02:27:07 <romildo> Is there any Haskell library that would let me query some information of video files, like the bitrate, audio languages and subtitle languages?
02:27:07 <lambdabot> romildo: You have 1 new message. '/msg lambdabot @messages' to read it.
02:32:39 <ClaudiusMaximus> romildo: not Haskell, but i have a bash script that parses the output of "mplayer -vo null -ao null -frames 0 -quiet -really-quiet -identify $1" into something more human readable
02:34:01 <ClaudiusMaximus> @hackage gstreamer
02:34:02 <lambdabot> http://hackage.haskell.org/package/gstreamer
02:45:39 <ddarius> j-invariant: The reason why the initial cone is not the same thing as a terminal cocone is because the category of cones has as -objects- cones and as arrows cone morphisms.  The op construction only swaps arrows, it's the identity on objects, so Cone^op still has cones as objects.
02:46:34 <j-invariant> ah I see
03:01:12 <j-invariant> http://en.wikipedia.org/wiki/Group_object m:GxG-->G and i:G-->G should not let you form mxi  
03:03:08 <aristid> ClaudiusMaximus: you could write a media player with human-readable output with the gstreamer package?
03:04:58 <ClaudiusMaximus> aristid: maybe possible - but i'm not the one to do it
03:07:48 <aristid> ClaudiusMaximus: mplayer is way too hard to use IMO
03:17:02 <ddarius> Guglielmi's site needs an RSS feed.
03:17:27 <mrdk_> is there a way to simplify an expression like '[0..2] ++ [0..2]'?
03:17:43 <dibblego> @type join (++)
03:17:44 <lambdabot> forall a. (Monoid a) => a -> a
03:18:04 <ddarius> [0,1,2,0,1,2]
03:18:21 <dibblego> > concat $ replicate 2 [0..2] -- :)
03:18:22 <lambdabot>   [0,1,2,0,1,2]
03:19:54 <mrdk_> oh well ;)
03:20:16 <dibblego> how do you mean simplify? ddarius clearly simplified it
03:21:11 <shapr> Has anyone tried lambdabot with xmpp recently?
03:22:49 <rjo> why there are certain type classes of mathematical structures, e.g. Monoid
03:23:09 <rjo> but not others, like Group
03:23:36 <ddarius> rjo: Some fit better than others and some are more useful to programmers than others.
03:23:46 <ddarius> There are plenty of Group classes about.
03:24:29 <rjo> is there some example how (++) being a Monoid is useful
03:24:50 <dibblego> [a] is the monoid
03:25:18 <ddarius> rjo: The same way [] being a monad is useful.  There are library functions that operate generically over all monoids and monads.
03:25:39 <remy_o> like mconcat
03:25:43 <ddarius> :t Data.Foldable.fold
03:25:44 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
03:26:25 <Cale> rjo: There's no way to really enforce laws.
03:26:46 <Cale> rjo: Though, having a Group class with an inverse operation would make sense
03:27:04 <Cale> rjo: Monoids tend to be more important in a lot of programming situations too.
03:27:57 <Cale> OT: Any other Haskellers play StarCraft 2?
03:28:10 <rjo> so certain type classes just come through evolution to the language
03:28:41 <Cale> rjo: Yeah, there are just so many libraries which define monoid operations, it's handy to have that formalised
03:29:00 <Cale> Also, because you can use typeclasses to get lots of instances for free.
03:29:29 <Cale> For example, since Ordering is a monoid, so is e -> Ordering, for any type e, and thus so is e -> (e -> Ordering), which is the monoid of comparison functions.
03:29:44 <Cale> (lexicographic monoid)
03:30:24 <j-invariant> Cale: why is (.) f = Ff  for a functor F?
03:30:38 <Cale> j-invariant: Because I think it's decent notationally :)
03:31:03 <Cale> and the hom functor gives us the usual composition as a special case
03:31:04 <j-invariant> can you defin composition in category theory using that idea?
03:31:15 <Cale> Sort of :)
03:31:28 <Cale> It would take some trickery, I think.
03:32:18 <Cale> (just because composition is usually so fundamental)
03:32:20 <rjo> @type Ordering
03:32:21 <lambdabot> Not in scope: data constructor `Ordering'
03:32:32 <Cale> data Ordering = LT | EQ | GT
03:32:44 <Cale> > 3 `compare` 5
03:32:45 <lambdabot>   LT
03:32:49 <Cale> > 3 `compare` 1
03:32:49 <lambdabot>   GT
03:32:51 <Cale> > 3 `compare` 3
03:32:52 <lambdabot>   EQ
03:33:18 <rjo> are LT and GT related somehow?
03:33:27 <Cale> Less Than, Greater Than
03:33:32 <Cale> EQual
03:33:49 <Cale> The monoid instance for Ordering gives the first parameter if it's LT or GT, and the second if it's EQ
03:33:52 <Cale> That is,
03:34:01 <Cale> LT ++ y = LT
03:34:05 <Cale> GT ++ y = GT
03:34:09 <Cale> EQ ++ y = y
03:34:39 <Cale> Which is the usual sort of way of combining comparisons when you compare words in a dictionary
03:34:56 <rjo> I'm just trying to think, that if Maybe's having Ordering break the monoid structure somehow
03:35:02 <Cale> If the first element is less or greater, then the word is less or greater, if it's equal, check the tails.
03:35:37 <aristid> rjo: huh? the ordering of Maybe Ordering is Nothing, Just LT, Just EQ, Just GT
03:35:48 <rjo> e.g. foldl (<) over maybes is different than foldr (>)
03:36:06 <Cale> rjo: Why should that ever be the same?
03:36:18 <Cale> er, also, type error?
03:36:18 <silbo_> i get mattern match error in function mkTree http://hpaste.org/paste/42631/quarto_annotation_annotatio#p42643
03:36:19 <Cale> :)
03:36:23 <silbo_> can someone see the problem?
03:37:00 <rjo> > Just 5 > Nothing
03:37:02 <lambdabot>   True
03:37:05 <rjo> > Just 5 < Nothing
03:37:06 <lambdabot>   False
03:37:14 <rjo> > Nothing > Just 5
03:37:15 <lambdabot>   False
03:37:49 <Cale> silbo_: That doesn't look possible
03:37:52 <rjo> e.g. then if I have finding max element, it is different using foldl and foldr
03:38:01 <rjo> then I do not have an associativity law true
03:38:22 <Cale> rjo: What?
03:38:26 <Bust> Good day, all!     I'm a novice in Haskell. I've downloaded and installed GHC 7.0.1 for Windows.  And I have problem with the State monad: neither "import State", nor "import Control.MOnad.State" work.  Can somebody explain, what is the reason?
03:38:48 <Cale> Bust: import Control.Monad.State and make sure to compile with --make
03:38:57 <silbo_> Cale: Program error: pattern match failure: v1623_v1691 mkInitTree
03:39:07 <Cale> silbo_: See, mkInitTree is different ;)
03:39:23 <monadic_kid> Bust: on an unrelated note, do you know about haskell platform?
03:39:23 <Cale> silbo_: hmm, still looks pretty impossible...
03:39:27 <silbo_> Cale: it just calls mkTree with initConfig
03:39:31 <Cale> silbo_: right
03:39:40 <Cale> silbo_: Are you using hugs?
03:39:45 <silbo_> Cale: yes
03:39:46 <mm_freak> hackage has moved to GHC 7.0 way too early
03:39:56 <Cale> silbo_: Do you have GHC? Could you try it?
03:39:58 <mm_freak> it should move back to 6.x
03:40:09 <Cale> mm_freak: There should be two hackages
03:40:10 <silbo_> Cale: I could install ghc
03:40:19 <mm_freak> too much stuff is broken right now
03:40:30 <Cale> silbo_: If you want I'll just give your program a shot. That error message is nonsense.
03:40:32 <aristid> IO has birthday today?
03:40:49 <silbo_> Cale: is ghc6 ok?
03:40:58 <Cale> yeah
03:41:11 <ivanm> aristid: well, back in February it did
03:41:29 * aristid raises eyebrow
03:41:36 <aristid> ivanm: when was it born?
03:41:41 <mm_freak> Cale: or that, yes…  someone has been too keen resulting in half of my packages breaking down, which also means that there is no online documentation anymore
03:41:43 <ivanm> oleg's email says the paper was published in February 1965
03:41:51 <mm_freak> this is really annoying
03:42:19 <silbo_> Cale: getting parse error from an "else if" in the play function
03:42:20 <ivanm> aren't they even bothering to to 6.12.3 in parallel with 7?
03:42:29 <ivanm> IIRC they did that for a while with 6.10.1 and 6.12.1...
03:42:30 <walrus_> account on 0
03:42:39 <dibblego> mm_freak, do you depend on category-extras?
03:42:49 <Cale> silbo_: Right, because you didn't indent properly
03:42:55 <rjo> Cale, hm, I just feel non-intutive about the results when comparing Maybes, and I try to think if those are correct in a structural sense. However, my last statement was not sensible
03:42:58 <Cale> silbo_: Always indent if/then/else like this:
03:42:59 <Cale> if foo
03:43:02 <Cale>    then bar
03:43:04 <Cale>    else quux
03:43:14 <Cale> The important thing being that 'then' and 'else' line up.
03:43:27 <Cale> and are indented farther than the 'if'
03:43:29 <mm_freak> dibblego: no
03:43:35 <aristid> ivanm: profmakx says that it was invented a while before publication :)
03:43:48 <ivanm> aristid: well, it would have been, yes
03:43:49 <Cale> rjo: Nothing is less than Just x
03:44:00 <ivanm> since the idea had to be thought up, paper written, accepted, etc.
03:44:00 <Cale> rjo: Just x < Just y if and only if x < y
03:44:13 <ivanm> but the publication date would be the _official_ date
03:44:21 <mm_freak> dibblego: my 'contstuff' package failed to compile with GHC 7.0 and many of my other packages depend on it
03:44:24 <Cale> silbo_: There's another problem
03:44:26 <ivanm> aristid: e.g. do you count your birthday from when you were conceived? ;-)
03:44:34 <aristid> ivanm: hahaha
03:44:38 <Cale> silbo_: case navail of null -> ...; _ -> ...
03:44:53 <silbo_> Cale ?
03:44:54 <Cale> silbo_: 'null' is just a variable name, and will always match
03:45:13 <aristid> case navail of x | null x -> ... ; _ -> ...
03:45:21 <silbo_> Cale: it was a hint from hlint xD I had length 0 check before that
03:45:31 <Cale> oh, use the null function
03:45:41 <Cale> if null navail then ... else ...
03:45:45 <Cale> Or:
03:45:51 <mm_freak> dibblego: effectively that means that for half of my packages no online documentation is generated
03:45:55 <Cale> case null navail of True -> ...; False -> ...
03:46:04 <dibblego> mm_freak, I know what you mean, I have similar problems
03:46:09 <Cale> Or simply pattern match on navail
03:46:13 <Cale> case navail of
03:46:16 <Cale>   [] -> ...
03:46:22 <Cale>   (x:xs) -> ...
03:46:25 <silbo_> ok
03:47:07 <silbo_> ill go eat my dumplings now
03:47:10 <Cale> The reason it's bad to compute the length is that length takes time on the order of the length of the list
03:47:44 <silbo_> Cale: yes I see the point
03:47:45 <mm_freak> hackage has to implement a fallback to 6.x
03:50:36 <rjo> I've most of the time feeling, that there must be better way do it, when I try to write something
03:51:14 <mm_freak> rjo: most of the time you will be right about that, but don't worry about it
03:52:10 <mm_freak> if you start to worry about that all the time, you won't get anything done…  it's a common pitfall in programming and especially in haskell
03:54:47 <Cale> There's a balance between on the one hand typing out the first thing that comes to mind and keeping it and on the other hand not typing anything at all as you think about better and better ways to do something.
03:55:42 <Cale> I tend to err on the latter side of the spectrum, but yeah, for getting things done quickly it kinda sucks.
03:55:45 * ddarius has a hankering for some liver.
03:56:35 <rjo> mm_freak, I read (quickly) your Monad tutorial today, thx for writing
03:56:36 <ivanm> ddarius: luckily for you you already have some! :p
03:57:47 <mm_freak> rjo: you're welcome
03:57:50 <Jafet> The way it works for haskell is through a careful division of labour. Programmers do the former and grad students the latter
03:59:00 <mm_freak> Cale: well, nowadays i think that it suffices to do it /well/ and not even try to do it /perfectly/
03:59:12 <mm_freak> and that helps a lot to get things done
03:59:36 <Cale> The main thing I find I'm afraid of when writing code is painting myself into a corner where I'll either end up with an unmaintainable mess or have to start over. If I can convince myself that I'm not just adding to an unmaintainable mess, then I'll press forward. :)
03:59:38 <ddarius> Jafet: I thought grad students were just professor's code monkeys?
03:59:42 <osfameron> "the perfect is the enemy of the good" and all that
04:00:09 <mm_freak> i remember that i've rewritten the 'ismtp' library about three times from scratch, because each time i realized that it could be done much better…  ok, now it /is/ much better, but it took weeks to write in my spare time
04:00:40 <Jafet> ddarius: perhaps; I've never experienced being one
04:01:26 <ddarius> Jafet: Me neither, but this seems to be the consensus view.
04:01:40 <silbo_> Cale: can I compile the programm with utf chars somehow?
04:01:54 <Jafet> Perfection is predicting the future; that sounds fairly hard
04:02:03 <ddarius> Cale: You should program in ruby or some such.
04:02:26 <ivanm> ddarius: and math-writing ones
04:02:42 <mm_freak> Jafet: not predicting the future, but knowing the future, which is even harder
04:02:51 <mm_freak> predicting the future is good
04:02:57 <ddarius> "The best way to predict the future is to invent it."
04:02:58 <Cale> ddarius: Oh? Why?
04:03:17 <mm_freak> ddarius: great quote and very applicable
04:03:28 <Jafet> Well, I intended "predicting" to be qualified by "accurately"
04:04:02 <ddarius> Cale: Well, you'll never paint yourself into a corner where you can't -do- something, and you'll have an unmaintainable mess before you write a line of code, so you don't need to worry about that either.
04:04:04 <mm_freak> Jafet: predicting accurately is the same as knowing, i think
04:04:11 <Cale> ddarius: hahaha
04:09:06 <aristid> i found a nice pattern today: catMaybes [ fmap f a, fmap g b, fmap h c ] :)
04:09:24 <sipa> :t catMaybes [ fmap f a, fmap g b, fmap h c ]
04:09:25 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `Expr'
04:09:26 <lambdabot>     In the second argument of `fmap', namely `a'
04:09:26 <lambdabot>     In the expression: fmap f a
04:09:57 <aristid> :t catMaybes [ fmap ?f ?a, fmap ?g ?b, fmap ?h ?c ]
04:09:58 <lambdabot> forall a a1 a2 a3. (?c::Maybe a3, ?h::a3 -> a1, ?b::Maybe a2, ?g::a2 -> a1, ?a::Maybe a, ?f::a -> a1) => [a1]
04:10:30 <dom96> :O
04:12:10 <aristid> yeah these, uh, implicit variables or how they are called, make for pretty freaky type signatures
04:12:35 <mm_freak> what's so special about that pattern?
04:13:30 <ddarius> If the types work out, it looks like you'd want (catMaybes .) . zipWith fmap
04:13:51 <ddarius> Where "types working out" means f,g,h all have the same type (and thus so do a,b,c)
04:14:04 <mm_freak> yeah
04:17:31 <Cin> Has anyone done any work on type safe string encodings? I'm thinking of whipping up a layer library on top of ByteStrings.
04:18:13 <aristid> ddarius: no, they don't have the same type
04:19:04 <aristid> mm_freak: well, it's better than what i had before, which was basically case a of Nothing -> []; Just x -> [f x] ++ case b ...
04:19:33 <ManateeLazyCat> juhp: Wait me 12 hours, Scriptable Manatee, manatee-ircclient almost finish. :) 
04:19:33 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
04:19:41 <aristid> :t catMaybes .: zipWith fmap
04:19:42 <lambdabot> forall a a1. [a1 -> a] -> [Maybe a1] -> [a]
04:19:47 <mm_freak> hi there ManateeLazyCat 
04:19:56 <ManateeLazyCat> mm_freak: Hi. :)
04:20:08 <ManateeLazyCat> mm_freak: Scriptable Manatee will release 12 hours later. :)
04:20:20 <mm_freak> great =)
04:20:49 <ManateeLazyCat> mm_freak: Then haskell for Manatee like elisp for Emacs, but much much fast and absolute type safe. :)
04:21:05 <mm_freak> ManateeLazyCat: SMTP library is finally there, <http://hackage.haskell.org/package/ismtp>, but you'll want to use GHC < 7.0
04:21:55 <mm_freak> so online docs are not working
04:22:05 <ManateeLazyCat> mm_freak: I will write Mail-Client after IDE for manatee.
04:22:13 <mm_freak> ah, ok
04:22:18 <ManateeLazyCat> mm_freak: Your SMTP looks great.
04:23:00 <aristid> mm_freak: GHC < 7 because some of your dependencies do not work with it?
04:23:07 <mm_freak> aristid: yes
04:23:18 <mm_freak> i don't know whether ismtp would work with GHC 7.0
04:23:32 <mm_freak> the code is fairly standard, so it should
04:23:40 <ManateeLazyCat> mm_freak: I just will move to ghc-7 after next HP release.
04:24:00 <mm_freak> i will move to GHC 7 when it's available in arch
04:24:26 <aristid> is running multiple GHC versions in parallel hard? :)
04:25:12 <mm_freak> so unless the hackage admins revert the overhasty choice to upgrade to GHC 7.0, there will be no online docs
04:25:56 <aristid> user-uploadable docs would help, too
04:26:17 <Jafet> Compiling with multiple package versions is hard enough
04:28:09 <mux> http://hpaste.org/42645/nfa -- ain't this cute? :-)
04:29:02 <j-invariant> how do you turn NFA to DFA?
04:29:22 <mux> that's the next step for me to implement; you use an algorithm called powerset construction
04:29:33 <j-invariant> is that efficient?
04:29:49 <j-invariant> or exponential time
04:30:02 <sipa> worst case exponential
04:30:05 <sipa> typically less :)
04:30:11 <mux> it's O(2^n) worst-case memory
04:30:16 <j-invariant> oh cool
04:30:24 <j-invariant> so you can find a pathological NFA?
04:30:25 <mux> I don't know for algorithmic complexity, but I don't think there's any way around that
04:31:57 <aristid> mux: the only thing i don't really like is that it uses Int for the states :)
04:32:05 <profmakx> pathological NFA: detect a symbol n-th last of the string
04:32:08 <ddarius> mux: It takes O(n) time to actually set n memory.
04:32:15 <mux> aristid: I don't like it either but you cannot go any other way if you need to navigate in the NFA
04:32:17 <Taejo> @pl \f g -> curry (g . uncurry f)
04:32:17 <lambdabot> (curry .) . flip (.) . uncurry
04:32:18 <ddarius> +cells
04:32:20 <profmakx> (say, the nth last symbol is a 1)
04:32:24 <Taejo> @pl \g f -> curry (g . uncurry f)
04:32:24 <lambdabot> (curry .) . (. uncurry) . (.)
04:32:26 <aristid> mux: why?
04:32:41 <mux> aristid: direct recursion would make you loop
04:33:06 <aristid> mux: wouldn't a type with an isomorphism to Int suffice? :)
04:33:21 <mux> I have code for DFAs that is very cute because it doesn't use Int and uses direct recursion; but as a consequence you can only use it to run it
04:33:30 <aristid> hmm, is there an efficient wrapper of IntMap for types with an isomorphism to Int?
04:33:42 <mux> aristid: oh, you meant using something else to represent states; that could be done but I had no need for that generalization for now
04:33:49 <c_wraith> aristid, there was an EnumMap package that did that.  Not sure if it still compiles
04:34:40 <aristid> mux: http://hackage.haskell.org/package/EnumMap/
04:34:45 <c_wraith> Though it was a complete copy of the entire IntMap code.  It would be easier and more flexible to just wrap the IntMap API in fromEnum and toEnum
04:34:46 <aristid> c_wraith: i found the package, too :)
04:35:02 <aristid> c_wraith: and hackage says that it compiles
04:35:09 <aristid> Built on	ghc-6.10, ghc-6.12, ghc-7.0
04:35:23 <silbo_> http://hpaste.org/paste/42631/quarto_annotation_annotatio#p42644 has someone any idea why I get patter match error in function mkTree ?
04:35:28 <mux> I still see no need for that for now :-P and as c_wraith said, I could just use fromEnum/toEnum if I want to generalize rather than another map type
04:36:33 <aristid> mux: well that's your decision :)
04:39:39 * ddarius thinks the creators of the Handbook of Modal Logic don't know what a handbook is.
04:40:10 <ddarius> (Admittedly, they wouldn't be the only ones.)
04:41:21 <ivanm> @wn handbook
04:41:22 <lambdabot> *** "handbook" wn "WordNet (r) 2.0"
04:41:22 <lambdabot> handbook
04:41:23 <lambdabot>      n : a concise reference book providing specific information
04:41:23 <lambdabot>          about a subject or location [syn: {enchiridion}, {vade
04:41:23 <lambdabot>          mecum}]
04:41:41 <ivanm> why, how big is the Handbook of Modal Logic?
04:42:51 <ddarius> Well for the quite reasonable price of $292.35 USD you can get this 1260 handbook from Amazon.
04:42:58 <ddarius> +page
04:43:18 <aymeric> avé bûcheur
04:44:29 <aymeric> Évangile de Jésus Christ selon saint Luc
04:44:29 <aymeric> Quand arriva le jour fixé par la loi de Moïse pour la purification, les parents de Jésus le portèrent à Jérusalem pour le présenter au Seigneur, selon ce qui est écrit dans la Loi : Tout premier-né de sexe masculin sera consacré au Seigneur.Ils venaient aussi présenter en offrande le sacrifice prescrit par la loi du Seigneur : un couple de tourterelles ou deux petites colombes.Or, il y avait à Jérusalem un homme appelé Sy
04:44:29 <aymeric> C'était un homme juste et religieux, qui attendait la Consolation d'Israël, et l'Esprit Saint était sur lui.L'Esprit lui avait révélé qu'il ne verrait pas la mort avant d'avoir vu le Messie du Seigneur.Poussé par l'Esprit, Syméon vint au Temple. Les parents y entraient avec l'enfant Jésus pour accomplir les rites de la Loi qui le concernaient.Syméon prit l'enfant dans ses bras, et il bénit Dieu en disant :« Maintenant, ô 
04:44:30 <aymeric> Maître, tu peux laisser ton serviteur s'en aller dans la paix, selon ta parole. Car mes yeux ont vu ton salut,que tu as préparé à la face de tous les peuples :lumière pour éclairer les nations païennes, et gloire d'Israël ton peuple. »Le père et la mère de l'enfant s'étonnaient de ce qu'on disait de lui. Syméon les bénit, puis il dit à Marie sa mère : « Vois, ton fils qui est là provoquera la chute et le relèvement d
04:44:30 <aymeric> beaucoup en Israël. Il sera un signe de division.- Et toi-même, ton coeur sera transpercé par une épée. - Ainsi seront dévoilées les pensées secrètes d'un grand nombre. »
04:44:41 <aymeric> lecture du jour 8)
04:44:43 --- mode: ChanServ set +o Cale
04:45:23 --- mode: Cale set -o Cale
04:46:32 <qfr> Haha
04:46:34 <aristid> ddarius: it's a steal
04:46:48 <qfr> Theist's trolling programming channels, that's a first for me
04:46:52 <Bynbo7> wtf? did we just get preached to in french?
04:46:54 <qfr> Theists* :(
04:48:30 <c_wraith> Bynbo7, it appears we did.
04:48:55 <c_wraith> From the gospel of saint luke, if my french is like infant-level :)
04:53:58 <raichoo> O_o
04:54:10 <aymeric> I pasted on the wrong channel, very sorry about that!...
04:54:31 <taotree> I'm seeing links to http://www.haskell.org/gtk2hs/ in various places but that and anything under it are giving 404...
04:55:30 <mux> Bynbo7: yes we did
04:55:34 <Cale> taotree: Oh, interesting. I wonder why it's down.
04:55:57 <Cale> taotree: There's been a lot of stuff done with gtk2hs lately, maybe the site has moved...
04:56:06 <silbo_> Cale: http://hpaste.org/paste/42631/quarto_annotation_annotatio#p42644 it is running with ghc now
04:56:21 <Cale> silbo_: Do you get the same error?
04:56:40 <Cale> silbo_: (GHC tends to report a bit more information about it)
04:57:16 <Cale> silbo_: Or is everything working now? :)
04:59:15 <silbo_> Cale: ok i did not try to excute the mkTree function yet
04:59:27 <silbo_> Cale: am trying right now
04:59:47 <taotree> I wanted to go through some tutorials for Haskell gui programming.
05:00:56 <manateeUser> 运行时更新。
05:01:26 <manateeUser> Runtime zu aktualisieren.
05:01:43 <manateeUser> क्रम अद्यतन करें.
05:02:04 <manateeUser> Rund
05:02:07 <manateeUser> ランタイム更新してください。
05:02:12 <silbo_> Cale: a.out: koduyl2.hs:(155,2)-(156,63): Non-exhaustive patterns in function show
05:02:42 <silbo_> Cale: tried to show the tree in the main function
05:03:15 <ManateeLazyCat> See? Hot-swap in haskell, change language translate in runtime.
05:03:25 <Kaidelong> http://www.haskell.org/haskellwiki/Gtk2Hs this works
05:03:52 <Cale> ManateeLazyCat: :)
05:03:57 <Cale> silbo_: Aha!
05:04:11 <ManateeLazyCat> clog: I change all haskell option and swap in runtime.
05:04:11 <Cale> silbo_: So you can see how the patterns are incomplete in your Show instance for Tree
05:04:34 <Cale> silbo_: There's no case there for handling Nodes with more than 1 subtree.
05:04:35 <ManateeLazyCat> Cale: So it's not just power for Manatee, it will give extreme power for all haskell program.
05:04:51 <taotree> Kaidelong, ok, I'll use that for now, thank you
05:04:53 <medfly`> hi!
05:04:57 <Kaidelong> http://home.telfort.nl/sp969709/gtk2hs/ here is what you might have been looking for
05:05:02 <ManateeLazyCat> Kaidelong: That's just wiki.
05:05:05 <Kaidelong> there is also some tutorial about trees
05:05:10 <silbo_> Cale: there isn't xD ?
05:05:15 <ManateeLazyCat> Kaidelong:  gtk2hs homepage still not fix.
05:05:23 <Cale> silbo_: You handle the case of an empty list, and a list with one item.
05:05:41 <yitz> hi. sorry i didn't notice that my irc client wasn't open when i created an hpaste just now. do hpastes get announced here these days?
05:05:53 <silbo_> Cale: a I see xD
05:06:01 <aristid> yitz: no
05:06:03 <ManateeLazyCat> yitz: Which irc client?
05:06:16 <yitz> ok: http://hpaste.org/42646/can_this_be_written_as_an_appl
05:06:32 <ManateeLazyCat> yitz: Which irc client do you use?
05:06:49 <yitz> i have been writing all of my parsers applicatively these days, but i was stuck on this one and wrote it monadically.
05:06:57 <yitz> is it possible to write applicatively?
05:07:04 <yitz> ManateeLazyCat: Colloquy
05:07:21 <ManateeLazyCat> yitz: Oh, i see. 
05:07:30 <ivanm> yitz: no announcements yet, no
05:07:33 <Bynbo7> yitz: can we see it?
05:07:41 <yitz> Bynbo7: link above
05:07:43 <Bynbo7> oh, you did paste it, sorry
05:07:49 <ManateeLazyCat> yitz: If you use emacs irc client, i have handy paste extension let you share information in irc client quickly
05:08:01 <yitz> ManateeLazyCat: nice!
05:08:01 <ivanm> chrisdone just put the UI part of the announcement, but hasn't gotten the hpaste bot up and running
05:08:09 <ManateeLazyCat> yitz: Look http://www.emacswiki.org/emacs/Paste2
05:08:13 <yitz> ManateeLazyCat: maybe i should switch to emacs :)
05:09:01 <yitz> ivanm: nice to hear that there's progress :)
05:09:09 <ManateeLazyCat> yitz: My paste2.el will popup window let you fill, then just hit Return, it will fill link in irc channel when upload finish.
05:09:32 <yitz> ManateeLazyCat: sounds slick
05:09:34 <ManateeLazyCat> yitz: Like above message is generate by my paste2.el 
05:09:34 * ManateeLazyCat pasted "paste2.el" at http://paste2.org/get/1167908
05:09:40 <Kaidelong> my first experience with emacs was managing to do C-X C-X instead of C-V while turning a page in the tutorial
05:09:47 <Kaidelong> C-X C-C*
05:10:20 <ManateeLazyCat> yitz: You just paste in irc client, and do other work, you even don't need focus on irc channel, paste2.el will looking for correct channel buffer to generate link information.
05:10:38 <ManateeLazyCat> yitz: It won't ask you any question until you really want to paste.
05:11:19 <yitz> ManateeLazyCat: i hope it also won't paste until you really want it to :)
05:11:53 <yitz> anyway, any ideas about an applicative version for that parser?
05:12:02 <ManateeLazyCat> yitz: My point is, it just ask you when you upload it, don't like other paste tool, waste your time ask question before you paste it.
05:12:18 <jonkri> how often do you experience problems doing production system software upgrades since haskell (as opposed to erlang) uses static typing? as far as i understand it, software upgrades were the primary reason for the erlang developers to go with soft typing
05:12:20 <yitz> ManateeLazyCat: got it. sounds nice.
05:12:55 <Kaidelong> looking through the GTK tutorial, the whole setup seems silly
05:13:01 <ManateeLazyCat> I will rewrite my paste2.el with haskell to support my irc client. :)
05:13:18 <c_wraith> jonkri, GHC supports dynamically loading typechecked code.  The main issue with hot upgrades is that there's no framework for it.  But in most applications, hot upgrades aren't necessary.
05:13:21 <Kaidelong> why do they do everything in IO as opposed to making some data type that represents windows in the abstract and then "running" them?
05:13:50 <ManateeLazyCat> c_wraith: I have finish framework to support dynamically loading.
05:14:25 <ManateeLazyCat> jonkri: I have make my haskell software update in runtime, and type check.
05:14:34 <ManateeLazyCat> jonkri: Won't lose any state.
05:14:34 <silbo_> Cale: I quess it works know, the tree is very long xD
05:14:39 <c_wraith> jonkri, In particular, for many services, it suffices to bring up a new server instance running new code, then having a front-end mechanism switch its routing.
05:15:13 <yitz> jonkri: one usually prefers to recompile in haskell, because the compiler provides such powerful verification services. you *want* to recompile. so usually you design your project around that.
05:15:35 <yitz> jonkri: therefore, there is far less support in the haskell ecosystem for other models
05:15:44 <ManateeLazyCat> Haskell software can update itself and don't need *restart*
05:15:48 <ManateeLazyCat> yitz: ^^^^
05:15:53 <c_wraith> ManateeLazyCat, But what you've done is *far* short of what erlang's OTP does, in terms of community use.  Basically all erlang code uses the OTP
05:16:00 <yitz> jonkri: even dynamic linking is just becoming mature now.
05:16:47 <ManateeLazyCat> c_wraith: Well, if you want, any haskell software can use dynamic linking.
05:17:23 <Kaidelong> You don't have to rebuild everything ever time, do you, anyway?
05:17:53 <yitz> Kaidelong: no only whatever changed, and then relink whatever needs to be relinked
05:18:07 <c_wraith> Kaidelong, No, but that's basically irrelevant.  You never do your entire build process after taking down the service you're updating :)
05:18:08 <yitz> Kaidelong: ghc does all of that automatically with the --make flag
05:18:20 <ManateeLazyCat> Ok, less talk, more coding. bye. 
05:18:20 <mux> which is the default in 7.x
05:19:02 <Kaidelong> wouldn't just releasing a patch for the binary suffice?
05:19:15 <yitz> Cale: can my parser be written applicatively?
05:19:47 <c_wraith> Kaidelong, that's basically useless, unless you intend to patch it while it's running.  And if you changed some data type's representation, that's going to be a nightmare
05:20:06 <Kaidelong> oh, the intention is to change the software while it is running?
05:20:22 <jonkri> Kaidelong: yes
05:20:23 <Kaidelong> that doesn't seem like a good thing to do with haskell itself, perhaps something built atop haskell to facilitate it...
05:21:05 <vegai> I wonder if ManateeLazyCat's reload idea is similar to what some unixy C programs do
05:21:32 <jonkri> i'm thinking about developing a web shop server and availability is an important concern, so that's why i'm thinking about live updates
05:21:41 <Kaidelong> perhaps you could do some kind of incremental compilation that makes the program as modular as possible, and allows modules to be swapped out? I think FSI and GHCi both do something like that
05:22:08 <jonkri> thank you all for your replies... very interesting! :)
05:22:12 <c_wraith> Kaidelong, loading code is no big deal.  The only issue is developing a platform for maintaining state across code reloads.
05:22:27 <c_wraith> that's what erlang's OTP is, essentially
05:22:33 <Kaidelong> this sounds more like something you'd want to do with smalltalk or erlang
05:22:34 <Kaidelong> yes
05:23:22 <c_wraith> And the answer is...  Haskell has nothing like Erlang's OTP.  Not because it's impossible, but because no one has felt the need for it.
05:24:05 <c_wraith> And even if something along those lines was created, it would never get the basically-universal adoption it got in Erlang
05:24:36 <Kaidelong> the problem is maintaining the state when changing the program, right?
05:24:46 <Kaidelong> wouldn't the elegant way be to separate the two as much as possible?
05:24:52 <vegai> jonkri: you check what software like irssi, nginx, unicorn do 
05:24:58 <Kaidelong> which is something Haskell is good at
05:25:10 <vegai> jonkri: all of those implement zero-downtime upgrades and they're written in C or ruby
05:25:51 <c_wraith> Kaidelong, the big issue is it would mean restricting access to state to a limited interface, in one way or another
05:26:04 <Kaidelong> yeah, you'd have to implement a runtime to mediate it
05:26:12 <Kaidelong> if you need to change that, you need downtime
05:27:08 <mux> trans q x r (NFA q0 ts fs) = NFA q0 (insert ts) fs
05:27:08 <mux>   where insert = IM.insertWith (M.unionWith IS.union) q
05:27:08 <mux>                                (M.singleton x (IS.singleton r))
05:27:08 <mux> final :: Ord a => State -> NFA a -> NFA a
05:27:08 <mux> final q (NFA q0 ts fs) = NFA q0 ts (IS.insert q fs)
05:27:11 <mux> step :: Ord a => NFA a -> State -> Input a -> StateSet
05:27:13 <mux> step (NFA _ ts fs) q i = maybe IS.empty next (IM.lookup q ts)
05:27:16 <mux>   where next = fromMaybe IS.empty . M.lookup i
05:27:19 <c_wraith> Also, I'm not convinced this is a real problem anymore.  At work, when we do an upgrade, it's a matter of "start up a series of images with the new release, switch the router to direct requests to them, shut down the old images".  zero downtime, and nothing in the software knows how
05:28:39 <jonkri> Kaidelong: why would erlang be more suitable for that in your opinion? (i don't mean to be flaming!)
05:29:23 <Kaidelong> It comes with runtime support for changing things around out of the box?
05:29:29 <Kaidelong> or I understood that it did
05:29:36 <Kaidelong> I haven't gotten around to learning Erlang yet
05:30:00 <Kaidelong> but my understanding was that individual erlang processes can be shut down and replaced
05:30:01 <rjo> can someone explain this I've, prop_exp :: Bool
05:30:23 <rjo> then I say quickCheck prop_exp
05:30:31 <Kaidelong> without everything else breaking around it
05:30:34 <rjo> ++++ OK, passed 100 tests
05:30:40 <ddarius> c_wraith: Even with dynamic upgrades you're going to do something like that.
05:30:41 <vegai> Kaidelong: OTP standardizes some messages so all your processes will answer to them (in addition to what they answer to for business logic reasons)
05:30:46 <rjo> however, putting trace on it, it executes only once
05:31:07 <jonkri> you seem to mostly be mentioning the lack of a framework such as otp... to what degree is haskell's static type system a problem for software upgrades in your opinion?
05:31:09 <Zao> rjo: Isn't that treated like   () -> Bool?
05:31:17 <Zao> rjo: Which kind of only has one non-bottom input?
05:31:48 <Kaidelong> jonkri: Is it?
05:31:58 <c_wraith> jonkri: basically not at all.  Minor issues in that each time you load module A, the type B within it is different from all the other times it's been loaded, but that's not too bad to work around.
05:32:15 <Kaidelong> I'd imagine that so long as your upgrades carry proofs that they are well typed with regard to everything else, you should have no problem
05:32:28 <Kaidelong> basically, if the haskell compiler accepts it, it is probably well typed
05:32:32 <rjo> ok, and when it has evaluated all inputs, it can claim, that all 100 tests give same result, executing only one
05:32:43 <vegai> I think the problem is that a haskell program compiled with ghc ends up in a single binary lump
05:32:46 <Kaidelong> so no proof needed
05:33:03 <vegai> whereas erlang modules are separate and can be loaded and reloaded separately
05:33:20 <vegai> and also the VM keeps track of old modules vs new modules so you can have both loaded at the same time
05:33:22 <c_wraith> rjo: It's lazy evaluation.  Once it's evaluated once, it doesn't need to evaluate it again.  something with the type Bool isn't a function, it's just an expression
05:33:51 <c_wraith> vegai, dynamic code loading isn't a problem in GHC.  there are several different strategies for doing it, all with pretty good library support.
05:33:56 <rjo> yes, but then I put side-effect inside it, and thought that it will force it to re-evaluate
05:34:13 <vegai> c_wraith: but it's something a dev has to implement, right?
05:34:18 <c_wraith> rjo: you've just discovered that unsafePerformIO does not make the language non-lazy
05:34:39 <c_wraith> rjo: Debug.Trace is implemented in terms of unsafePerformIO
05:34:49 <rjo> ok, thanks! :-)
05:35:36 <c_wraith> vegai: until there's some library tying everything together like Erlang's OTP does.  My position here is that it's technically possible, but no one cares enough to do the work.
05:37:05 <c_wraith> Well, there is one current limiting factor, which is that GHC doesn't unload code under any circumstances.  That would need to be fixed.
05:37:51 <vegai> c_wraith: I don't dispute that.
05:38:40 <vegai> might be a nice project for an aspiring, fame-hungry haskell hacker 
05:40:05 <c_wraith> I've done my time with it..  I implemented dynamic code loading in Snap.  I don't want to deal with the issues of generalizing it :)
05:41:38 <c_wraith> the kind of thing OTP does is entirely different than what I did, anyway.
05:42:51 <vegai> thing is, Erlang isn't afraid of being restrictive to get those features done
05:43:13 <c_wraith> right.  someone could do it, by making a set of good decisions
05:43:28 <c_wraith> then they'd have to convince everyone else they made good decisions :)
05:45:34 <jonkri> thanks once again for all the answers :)
05:46:17 <c_wraith> Erlang had a huge advantage here, in that the OTP was developed by the same company that designed the language, and both were made public at about the same time
05:47:27 <dpratt71> speaking of Snap, I thought that I had it working on Windows at one point without resorting to MinGW; I recently did a 'cabal upgrade', which failed; does someone know the official situation with Snap and Windows platforms support?
05:51:26 <c_wraith> the official situation is "supported".  The unofficial situation is "none of us have windows boxes, we don't know if what we're doing works there or not"
05:52:26 <dpratt71> c_wraith: ok, thanks
05:52:36 <c_wraith> still, cabal upgrade is nearly guaranteed to break stuff
05:52:53 <c_wraith> even if all the code works properly on windows
05:53:06 <dpratt71> c_wraith: why?
05:53:41 <c_wraith> it doesn't make sure it's not breaking packages
05:53:53 <c_wraith> at least with cabal install, you're generally only adding new packages
05:53:55 <dpratt71> I didn't do a bare 'cabal upgrade' by the way, I did 'cabal upgrade snap'. Does it matter (in regards to the likelyhood that it'll break something)
05:54:59 <c_wraith> well, it does lower the chances, but really..  pretend you're using the next version of cabal, where the upgrade command has been removed.  because it doesn't do what anyone thinks it should :)
05:55:12 <c_wraith> How is it broken, anyway?
05:56:04 <dpratt71> c_wraith: can't (apparently) configure the 'network-2.3' package on Windows without MinGW/Cygwin
05:56:38 <dpratt71> is there a way to determine how/where a Haskell package references stuff from another Haskell package?
05:57:12 <c_wraith> If you mean where specifically in the code, not quickly.
05:57:23 <c_wraith> You can look for imports from the package in question
05:57:41 <c_wraith> But it's still a pretty manual process in the best of cases
05:58:00 <dpratt71> c_wraith: thought that might be the case :(
06:12:13 <rhapsodhy> hi
06:12:50 <rhapsodhy> what is the simplest form of ipc i could use with haskell?
06:13:17 <Ke> simple is relative
06:13:43 <Ke> afaik haskell has no abstract libraries for ipc
06:13:52 <ManateeLazyCat> Cabal can install *.tar.gz package directly? How cabal install package after download it? Decompress it and install them delete temporary directory?
06:14:06 <ManateeLazyCat> Or any directly install command?
06:14:13 <rhapsodhy> ok, what i want to do: on every git commit send a line to a haskell process, which then does whatever with it
06:14:44 <ManateeLazyCat> rhapsodhy: DBus?
06:14:49 <rhapsodhy> no way
06:14:57 <ManateeLazyCat> rhapsodhy: Why not?
06:15:10 <ManateeLazyCat> @package dbus-core
06:15:10 <lambdabot> http://hackage.haskell.org/package/dbus-core
06:15:11 <rhapsodhy> because it is a bloated crap
06:15:27 <Ke> named pipe perhas
06:15:30 <ManateeLazyCat> @package dbus-client
06:15:31 <lambdabot> http://hackage.haskell.org/package/dbus-client
06:16:19 <rhapsodhy> named pipes would be cool, but if there's no data in it, read just returns, so i would have to poll
06:16:48 <balor> Is there a templating library for Happstack i.e. something similar to Kid or Cheetah for Pylons?
06:16:56 <Ke> rhapsodhy: just thread and let haskell IO engine do the rest
06:17:29 <rhapsodhy> Ke: you mean create a thread that polls?
06:17:50 <Ke> afaik pipes do block
06:18:00 <Ke> at least regular pipes do
06:18:11 <rhapsodhy> when writing, yes, when reading with no connection on the other end, no
06:18:49 <aristid> rhapsodhy: unix sockets do solve that problem :)
06:18:50 <rhapsodhy> try it out: mkfifo fifo; cat fifo; echo whatevz > fifo
06:19:16 <jonkri> what kind of lightweight http servers are there for haskell programs if you don't want to use apache? yaws performs a lot better than apache when forwarding to erlang processes so i was hoping there would be something similar
06:19:41 <Ke> rhapsodhy: for me the read blocks
06:20:02 <aristid> jonkri: snap?
06:20:03 <Ke> hmm
06:20:10 <Ke> actually open blocks
06:20:35 <aristid> jonkri: http://snapframework.com/
06:20:43 <jonkri> looks wonderful
06:21:31 <rhapsodhy> ok, so i must have screwed up something with the haskell code :)
06:21:56 <Ke> rhapsodhy: I guess you just create invalid IO handle while open blocks?
06:22:00 <Ke> ostl
06:22:25 <rhapsodhy> yeah, possible
06:22:38 <Ke> open seems to block until there is something at the other end
06:23:21 <Ke> I don't know haskell IO engine well enough to know how it handles these
06:23:25 <rhapsodhy> and even if open itself block, IO doesn't?
06:24:17 <Ke> well for unnamed pipes read and write are blocking
06:24:24 <Ke> to some extent
06:24:40 <Ke> there might be some buffering
06:25:37 * ManateeLazyCat I use DBus, works well, and clean code....
06:26:04 <ManateeLazyCat> snap looks impress.
06:26:36 <Ke> dbus handles restart poorly
06:27:01 <Ke> ie. drops all connections without notifying clients
06:27:29 <ManateeLazyCat> Ke: When time need restart?
06:28:37 <ManateeLazyCat> I use DBus because it's easy to mix in your project, and don't need change too much code.
06:29:00 <Ke> it's good for quite a few purposes
06:29:18 <Ke> I might not want to see dbus on a cellphone
06:30:09 <ManateeLazyCat> Ke: I use DBus on desktop, every application don't need each other, just send DBus, if somebody care, join DBus bus to listen.
06:30:21 <ManateeLazyCat> s/don't need/don't need know
06:30:52 <Zao> Why do packages have silly and completely meaningless names?
06:31:09 <aristid> Zao: why not?
06:31:10 <Zao> I found about wumpus-* today, through "recent additions" in a lull at work.
06:31:24 <Zao> I've seen the name before and assumed it was either a game or some AI project.
06:33:43 <Ke> dbus seems to use less than 2MiB of memory though
06:34:32 <Ke> on the other hand you probably have at least 2 of them running
06:36:21 <lars9> @src liftM
06:36:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:36:36 <lars9> :t liftM
06:36:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:36:41 <aristid> lars9: liftM is an implementation of fmap :)
06:36:47 <lars9> :t (return .)
06:36:48 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
06:36:49 <ManateeLazyCat> :t fmap
06:36:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:38:02 <lars9> aristid: i was verifying it's the same as (return .)
06:38:22 <aristid> :t (return Prelude..)
06:38:23 <lars9> *if
06:38:23 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
06:38:32 <aristid> lars9: no, it's not
06:38:40 <lars9> indeed
06:38:42 <aristid> :t fmap return
06:38:43 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
06:38:54 <aristid> :t join . fmap return
06:38:55 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m a -> m a
06:45:00 <djahandarie> (Monad m, Functor m) *sigh*
06:52:37 <yitz> http://hpaste.org/42646/can_this_be_written_as_an_appl
06:53:14 <balor> How do I build a project using the provided foo.cabal file?
06:53:32 <djahandarie> ddarius, I think it was sclv now that I think about it more
06:53:42 <yitz> can anyone write this monadically-written parser applicatively, or say why it can't be done?
06:55:55 <monadic_kid> balor: runhaskell Setup.hs (or .lhs) configure runhaskell Setup.hs/.lhs build runhaskell Setup.hs/.lhs install
06:56:34 <monadic_kid> where does template haskell look dlls on windows?
06:56:38 <sshc> Are STM transactions safe when they are done in an IO action performed by `unsafePerformIO'?
06:56:50 <balor> monadic_kid: thanks
06:57:54 <sshc> Is it safe to do STB transactionss with `unsafePerformIO'?
06:58:14 <Kaidelong> sshc: the actual transaction should still be atomic, if that is what you are asking
06:58:49 <Kaidelong> but why would you want to do this?
06:58:51 <sshc> Kaidelong: I see, thanks.
06:59:34 <sshc> I don't want to do it
07:02:42 <balor> I've installed happstack via cabal, but the sample guestbook project won't configure due to missing dependencies http://fpaste.org/oCKY/ I'm sure I'm doing something n00b and wrong, any pointers?
07:04:00 <monadic_kid> balor: try "runhaskell Setup.hs configure --user"
07:05:04 <balor> monadic_kid: thanks.  I presume that picks up the user installed ~/.cabal/lib stuff?
07:06:40 <monadic_kid> balor: yep, you can see the system wide and user-wide packages with  the command ghc-pkg using list argument "ghc-pkg list" you might have some issues with dependices with a few packages depending on a particular package but different versions because each package will probably have a versiosn contraints
07:11:35 <monadic_kid> template haskell is giving the me the error "can't load .so/.DLL for:..."
07:11:46 <ps-auxw> I usually do "cabal install" in the directory instead of those Setup.hs calls.
07:15:01 <monadic_kid> ps-auxw: are you writing to me?
07:17:12 <monadic_kid> balor: I didn't know but you can use cabal install in the directory of the package as ps-auxw said
07:24:42 <cpa> hi there, I have an import qualified issue
07:25:11 <cpa> I import Data.ByteString as Byte and I get:
07:25:12 <cpa>     Couldn't match expected type `Byte.ByteString'
07:25:13 <cpa>            against inferred type `ByteString'
07:25:22 <cpa> when using Byte.length
07:26:09 <cpa> I'm also import ByteString with import Data.ByteString.Lazy (ByteString)
07:26:16 <cpa> any ideas?
07:28:41 <fliebel> What is the preferred way to do Twitter in Haskell? A quick Google for "twitter haskell" didn't turn up a clear winner. Let alone one that supports OAuth.
07:29:08 * hackagebot kmeans 0.1.2 - K-means clustering algorithm  http://hackage.haskell.org/package/kmeans-0.1.2 (GershomBazerman)
07:32:28 <Portrait> Greetings everyone.
07:33:23 <Portrait> I'm a newbie at Haskell and would like some help understanding a basic concept.  Does anyone think that they are able to help me?
07:33:36 <merijn> Portrait: What are you reading to learn it?
07:34:10 <Portrait> Learn You a Haskell
07:34:23 <merijn> Ah, that's a good start
07:34:36 <Portrait> I'm a fan.  It's very accessible.
07:34:53 <djahandarie> fliebel, someone wrote a library for that, though I don't remember who...
07:34:55 <djahandarie> Veinor?
07:35:25 <Portrait> I had a question in nested list comprehensions.
07:35:50 <balor> Is there a "cabal remove foo" operation?  I've install happstack, but need the version from darcs head.
07:36:15 <merijn> Portrait: And that question would be...
07:36:17 <djahandarie> Though I don't know if what he wrote is 1) finished, or 2) supports OAuth.
07:36:52 <Portrait> If I defined this... let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]  
07:37:34 <Portrait> Why isn't [ [ x | x <- xs, even x ] | xs <- xxs]  equivalent to [ [ x | x<-xss, even x]
07:37:42 <Portrait> ****Why isn't [ [ x | x <- xs, even x ] | xs <- xxs]  equivalent to [ [ x | x<-xss, even x]]
07:39:23 <fliebel> djahandarie: Sounds great. But without a name… :(
07:39:42 <djahandarie> Portrait, the second will make you end up with each x having a type of [Int]
07:39:54 <djahandarie> Portrait, and using the even function on a list doesn't make much sense
07:40:24 <Portrait> So what does the statement xs<-xxs do?
07:40:55 <merijn> Portrait: Repeatedly take the first value of xxs and "assign" it to xs
07:41:11 <merijn> Portrait: xxs is type [[Int]] (not really, but close enough), i.e. a list containing lists of ints. The first list comprehension generates a new list comprehension for each item in xxs (i.e. one list comprehension per list) and nest those. The second one tries to apply "even" to a [Int], which of course doesn't work
07:41:35 <ProfElm> This is Portrait... just using a desktop client now.
07:42:12 <merijn> Although, personally I probably wouldn't use a list comprehension here
07:42:45 <ProfElm> Pardon... but what does the second part of the comprehension do again?  I closed out the other window....
07:42:57 <merijn> Portrait: Repeatedly take the first value of xxs and "assign" it to xs
07:43:28 <merijn> > let xs = [1..10] in [x | x <- xs]
07:43:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:44:00 <djahandarie> > fmap (filter even) [1..10] -- this is how I'd write it probably
07:44:01 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
07:44:01 <lambdabot>    arising from a use...
07:44:06 <merijn> ProfElm: [x | x <- xs] basically says "create a new list consisting of all x which get taken from xs
07:44:16 <pozic> I want to evaluate the elements of a list in parallel using exactly as many cores as are available. 
07:44:24 <djahandarie> Gah
07:44:37 <ProfElm> So...
07:44:39 <pozic> How can I do that? There is parListN, but it has no documentation.
07:44:56 <djahandarie> > fmap (filter even) [[1..10], [1..10], [5..10]] -- this is how I'd write it probably
07:44:57 <lambdabot>   [[2,4,6,8,10],[2,4,6,8,10],[6,8,10]]
07:45:00 <merijn> ProfElm: "[x | x <- xs, even x]" this says "create a new list consisting of all x which get taken from xs, IF and only IF "even x" is true
07:45:17 <merijn> > let xs = [1..10] in [x | x <- xs, even x]
07:45:18 <lambdabot>   [2,4,6,8,10]
07:45:36 <mux> what's wrong with just 'filter even' ?
07:45:38 <ProfElm> Since...
07:45:56 <Kaidelong> :t even
07:45:57 <lambdabot> forall a. (Integral a) => a -> Bool
07:46:01 <merijn> mux: Nothing, but he was asking about list comprehensions and filter doesn't explain those :p
07:46:08 <djahandarie> mux, it's a nested list
07:46:09 <mux> oh. I see :-)
07:46:10 <Kaidelong> @instances Integral
07:46:10 <lambdabot> Int, Integer
07:46:15 <djahandarie> (His original problem)
07:46:19 <merijn> > let xs = [[1..5],[5..10],[1..5]] in [x | x <- xs]
07:46:20 <lambdabot>   [[1,2,3,4,5],[5,6,7,8,9,10],[1,2,3,4,5]]
07:46:23 <mux> djahandarie: no worries
07:46:32 <ProfElm> Since xxs is a combination of lists, which is why we can't take even instances of xxs?
07:46:41 <mux> map (filter even) to the rescue :-P
07:46:49 <djahandarie> mux, see what I wrote moments ago. :P
07:46:55 <merijn> ProfElm: Is "[1,2,3,4,5]" even?
07:47:01 <ProfElm> Nope.
07:47:09 <ProfElm> It's a list, lol.
07:47:10 <mux> djahandarie: yes, you used fmap for no good reason, I suppose you tried to confuse him :-) j/k
07:47:23 <merijn> ProfElm: That's exactly the problem, yes :)
07:47:25 <djahandarie> Sorry, bad habbit I guess lol
07:47:27 <ProfElm> :)
07:47:28 * djahandarie hasn't used map for ages
07:47:30 <ProfElm> SWEET!
07:47:41 <merijn> ProfElm: But, as mux suggest I would use "map (filter even)"
07:47:45 <Kaidelong> :t filter even
07:47:46 <lambdabot> forall a. (Integral a) => [a] -> [a]
07:47:46 <ProfElm> merijn: Thanks a lot!
07:47:52 <Kaidelong> :t map (filter even)
07:47:53 <lambdabot> forall a. (Integral a) => [[a]] -> [[a]]
07:47:59 <ProfElm> merijn: How does one use map (filter even)?
07:48:09 <djahandarie> pozic, "evaluate"?
07:48:11 <merijn> > map (filter even) [[1..5],[5..10],[1..10]]
07:48:12 <lambdabot>   [[2,4],[6,8,10],[2,4,6,8,10]]
07:48:18 <djahandarie> pozic, there is parMap
07:48:34 <ProfElm> What does the map command do?  What does it take as values?
07:48:36 <Kaidelong> > map (filter even) [[x..y] | x <- [1..10], y <- [5..10]]
07:48:37 <lambdabot>   [[2,4],[2,4,6],[2,4,6],[2,4,6,8],[2,4,6,8],[2,4,6,8,10],[2,4],[2,4,6],[2,4,...
07:48:39 <merijn> ProfElm: Study these type signatures and see if you can figure it out:
07:48:43 <merijn> :t map
07:48:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:48:46 <merijn> :t even
07:48:47 <lambdabot> forall a. (Integral a) => a -> Bool
07:48:49 <merijn> :t filter
07:48:50 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:48:55 <merijn> :t filter even
07:48:55 <lambdabot> forall a. (Integral a) => [a] -> [a]
07:49:13 <ProfElm> O_o
07:49:29 <merijn> ":t" also works in ghci so you can try typing in various thing to see what type they are
07:49:37 <djahandarie> Typeclasses might be confusing you at this point if you haven't learned them
07:49:45 <ProfElm> Alright.
07:49:50 <djahandarie> :t filter even :: [Int] -> [Int]
07:49:51 <lambdabot> [Int] -> [Int]
07:50:04 <ProfElm> I was just reading through the Learn You a Haskell tutorial and tried doing that, and was wondering why it wasn't working.
07:50:07 <sipa> ProfElm: i suggest you to ignore every forall and everything before '=>' in those type signatures for now
07:50:17 <Kaidelong> list comprehensions are evil
07:50:24 <Kaidelong> except perhaps for the post trivial of cases
07:50:36 <ProfElm> Much like math, I think that the best way to troubleshoot these problems is to write it out and analyze what goes on in each step.
07:50:37 <merijn> Yeah, typeclasses can be confusing. Then again I think grokking type signatures is the most important part of learning haskell
07:50:45 <merijn> ProfElm: Agreed
07:51:16 <merijn> The moment I understood type signatures was for me the true Matrix-like enlightenment of Haskell :p
07:51:29 <ProfElm> Thanks a lot everyone!  I'm going to get back to reading through the tutorial and see if I can further my understanding of Haskell.
07:51:34 <ProfElm> :)
07:51:41 <merijn> ProfElm: You understand the basics of the type signatures, though?
07:51:46 <ProfElm> Yes.
07:51:49 <ProfElm> Err.
07:51:51 <ProfElm> No.
07:51:53 <ProfElm> ^^;;
07:52:47 <djahandarie> pozic, if you just want to reduce a list to whnf in parallel, use rwhnf as your initial Strategy, convert it to a list Strategy with parList, then use that Strategy on a list
07:52:54 <merijn> ProfElm: Ah, those are covered later in LYAH (in chapter 3). Just continue reading, it should make sense after that chapter
07:53:10 <ProfElm> Thanks!
07:53:40 <djahandarie> When we explain things in here, we tend to assume you know everything except the exact thing you are asking about
07:53:43 <djahandarie> Which is usually never the case
07:54:42 <applicative> ProfElm, maybe it's best not to think of 'map' as a command. It's just another function.
07:54:46 <monadic_kid> I'm getting  a wierd problem with ghc under windows, if try to print to stdout I get an error dialog message from the runtime: hPutChar: invalid argument (bad file descriptor)
08:00:36 <BorisL> is it possible to give class restrictions to the type families?
08:01:11 <BorisL> i want to define type in a class, so that this type must be instance of Show
08:01:21 * hackagebot yesod-examples 0.6.1 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.6.1 (MichaelSnoyman)
08:02:37 <djahandarie> Interesting to seperately package examples.
08:03:01 <djahandarie> I guess that's a nice way to keep track of the version the example worked with
08:07:06 <monadic_kid> where does cabal install data-dir fields on windows 7?
08:10:38 <mm_freak> BorisL: class Show a => MyClass a where type MyTF a
08:11:17 <mm_freak> BorisL: or alternatively (and generally better solution) put the context either into the class functions or into the instance
08:12:13 <mm_freak> class MyClass a where type MyTF a;  someFunc :: Show a => a -> String
08:12:26 <mm_freak> uhm
08:12:31 <mm_freak> class MyClass a where type MyTF a;  someFunc :: Show a => MyTF a -> String
08:14:03 <pmurias> has anyone here used reactive?
08:14:03 <dataangel> How do I convert a FilePath back to a String?
08:14:21 <monochrom> by the id function
08:14:36 <dataangel> monochrom: Oh, is it just an alias?
08:14:40 <monochrom> yes
08:14:47 <patrickthomson> dataangel: You can just do (x :: String), I think
08:14:53 <patrickthomson> where x is your FilePath
08:14:53 <dataangel> ooooooooh
08:15:06 <dataangel> I thought I had to convert strings to filepaths in order to join them properly :P
08:16:06 <pmurias> conal: i get an error trying to install reactive-glut from hackage
08:16:31 <conal> pmurias: oops. 
08:16:32 <ddarius> patrickthomson: The :: String notation doesn't have any operational significance.  It's just asking the compiler to attempt to unify the type it infers for x with String.
08:16:43 <mm_freak> patrickthomson: you don't need the type annotation
08:16:44 <patrickthomson> got a sticky problem (and rather ugly solution) of extracting the contents of boxed types; anyone care to have a look and make suggestions? https://gist.github.com/758689
08:16:47 <mm_freak> FilePath = String
08:17:09 <pmurias> conal: http://pastebin.com/uKveQcTb
08:17:12 <mm_freak> unless, of course, you want to be overly specific about your types
08:17:27 <patrickthomson> mm_freak: Yeah, I was trying to indicate that conversion is not necessary, since `type FilePath = String`.
08:17:44 <cpa> how should I encrypt/decrypt with RSA using HsOpenSSL?
08:17:55 <pmurias> conal: what FRP would you recommend for playing with?
08:18:03 <conal> pmurias: thanks. i guess a change to the OpenGL bindings.
08:18:22 <djahandarie> It's too bad that adding a type signature in other languages often automatically coerces stuff
08:18:25 <conal> pmurias: i don't have a FRP system recommendation right now.
08:18:28 <mm_freak> patrickthomson: your problem is not related to boxing at all
08:18:37 <mm_freak> patrickthomson: just use pattern matching
08:18:56 <conal> pmurias: but others on the channel might
08:18:57 <monochrom> beginners call it boxing and unboxing
08:18:57 <ddarius> djahandarie: Most languages don't have type annotations as an expression form.
08:19:14 <mm_freak> pmurias: i liked yampa and elerea
08:19:19 <pmurias> conal: do you use reactive for anything?
08:19:29 <mm_freak> the former is more elegant, but feels not mature yet
08:19:39 <mm_freak> the latter is fast, but not very featureful
08:19:40 <djahandarie> ddarius, I was thinking casts like (int)
08:20:04 <merijn> Speaking of FRP, anyone aware of universities working on FRP like projects (preferably ones looking for phd students in the coming year ;)?
08:20:09 <conal> pmurias: no. it's been on hold for a while.
08:20:09 <ddarius> djahandarie: Yeah that's what I thought, but casts aren't type annotations and are explicitly coercions.
08:20:41 <djahandarie> Hm, true
08:21:16 <pmurias> i tried playing with FrTime but the demos are laggy and freeze after a while
08:21:57 <djahandarie> ddarius, I guess I misused "type signature". I guess just "adding a type in other languages somewhere in your expression often automatically coerces stuff"
08:25:16 <ddarius> djahandarie: The thing is casts aren't used like type annotations and don't serve that purpose in theory or practice.
08:25:28 <fliebel> djahandarie: I think I found the Twitter lib you meant, but it's not very complete. https://github.com/veinor/askitter
08:25:28 <patrickthomson> mm_freak: what's the correct term, if not boxing and unboxing?
08:26:06 <silbo_> is there a nanotechnology channel in irc?
08:27:18 <djahandarie> ddarius, right. Either way, you are still writing 'int' in the expression, and people would be used to its behavior. So saying x :: String could be slightly misleading
08:27:43 <djahandarie> fliebel, okay. :( That's all I've heard mentioned about twitter rather than the one on hackage, hs-twitter or whatever it is called
08:28:35 <sipa> patrickthomson: wrapping in a constructor?
08:28:55 <patrickthomson> sipa: yes, wrapping is a more apt term.
08:29:15 <patrickthomson> in any case, i've now made it a recursive function that pattern matches on the head of the list.
08:30:03 <fliebel> djahandarie: hs-twitter had username and passwords on its frontpage. askitter depends on hoauth, which might be just as easy. Twitter is just HTTP in the end.
08:32:46 <rjo> what kind of work-flow you've in writing haskell code? 
08:33:20 <rjo> e.g. I mean that: I have terminal with ghci, emacs window with QuickCheck tests and then the file I'm writing
08:34:27 <merijn> One terminal running tmux (containing ghci, vim, etc) on one screen and browser with documentation/google on second screen
08:35:50 <rjo> for the documentation I use hoogle and too much direct google searches
08:36:09 <rjo> in Python I mostly use ipython doc facilities
08:36:48 <rjo> maybe there is same kind of system for ghci too that I'm not aware?
08:38:14 <mm_freak> patrickthomson: constructor application
08:38:30 <mm_freak> there are other terms, too
08:39:05 <monochrom> unfortunately not. but when you "cabal install blah" you have the option of building docs, and then you can just use a browser on local files.
08:39:33 <monochrom> it is really a principle of maximum surprise that building docs is not the default.
08:40:19 <parcs> rjo: cabal can optionally install packages' documentation which you can then view locally at ~/.cabal/share/doc
08:40:39 <rjo> ok, thanks. I did not know that
08:41:02 <monochrom> see? principle of maximum surprise
08:41:37 <parcs> your distribution might also have ghc bundled with its docs at /usr/share/doc/ghc
08:48:43 <rjo> parcs, fedora packages were quite funny: doc]$ for f in ghc-*/* ; do basename $f ; done | sort | uniq -c | sort -n
08:48:54 <rjo>       2 README
08:48:54 <rjo>      21 LICENSE
08:50:02 <rjo> i.e. each package contains typically only LICENSE, but nothing else
08:50:49 <ProfElm> Everyone, I have a really simple question to ask.
08:51:23 <ProfElm> I'm learning type classes and was wondering how I can set the type class in a command within ghci.
08:51:40 <ProfElm> For example, I'm trying to make factorial :: Integer->Integer
08:51:49 <ProfElm> But how would I type that command into terminal?
08:52:34 <rjo> ghc --make factorial.hs 
08:52:40 <rjo> ./factorial 10
08:52:56 <parcs> > let factorial :: Integer -> Integer; factorial x = product [1..x] in factorial 10
08:52:57 <lambdabot>   3628800
08:54:13 <ProfElm> parcs: In other words, I need to define factorial immediately after I set the type?
08:54:37 <parcs> ProfElm: i believe so
08:54:50 <ProfElm> parcs: i.e. "let factorial :: Integer->Integer; factorial x = product[1..x]
08:55:26 <parcs> ProfElm: you can give it a dummy definition like factorial x = undefined
08:55:41 <parcs> then afterwards you can redefine it with let factorial x = ...
08:56:04 <parcs> (i think; try it out)
08:56:57 <ProfElm> parcs++
08:57:25 <ProfElm> ^^;;  I'm new to IRC and Haskell... how do I give you Karma? Heheh.
08:57:29 <djahandarie> @karma parcs
08:57:29 <lambdabot> parcs has a karma of 1
08:57:32 <djahandarie> You just did
08:57:37 <ProfElm> :D
08:57:43 <djahandarie> It's not built into IRC, but lambdabot has that feature
08:58:03 <marmar> ciao
08:58:09 <djahandarie> Hi
08:58:32 <monochrom> rjo: "ghc-parsec-doc" for example
08:59:13 <rjo> monochrom: in which context?
08:59:29 <monochrom> fedora packages that contain the docs
09:07:53 <monochrom> what? the IO monad is 45 years old?
09:08:11 <ddarius> monochrom: No, not really.
09:08:59 <ddarius> Anyway, that would possibly put it before the term "monad" was even coined, or at least before it was significantly popularized.
09:09:17 <ddarius> Godemont introduced "standard constructions" (which I actually think were comonads, not monads) in 1958.
09:09:50 <monochrom> yeah, mathematician's monads are our comonads
09:10:14 <roconnor> standard constructions are comonads?
09:10:23 <monochrom> oh oh oh! more fuel for "cargo cult math"!
09:10:35 <roconnor> :(
09:11:04 <vegai> the mind of a 20-year old mathematician is a wondrous thing
09:11:13 <roconnor> In my papers I kept saying that "a monad are a standard construction in functional programming"
09:11:18 <roconnor> *is
09:11:27 * monochrom writes "I agree with you whole-heartedly. These haskellers even get the morphism directions wrong." :)
09:11:48 <ProfElm> I feel that I'm really behind the times as a mathematician.
09:12:02 <ProfElm> I'm 21 and have a C average in most of my math classes.
09:12:05 <ProfElm> .-.
09:12:29 <ProfElm> However, I would like to use Haskell to further my mathematical understanding.  This and Project Euler.
09:12:34 <merijn> meh
09:12:38 <roconnor> I didn't learn any Category Theory at the University of Waterloo
09:12:47 <merijn> High math grades doesn't equal understanding and vice versa
09:12:48 <roconnor> it's was like category theory didn't exist.
09:13:01 <roconnor> *it
09:13:06 <monochrom> not in Toronto either
09:13:19 <roconnor> monochrom: you went to U of T?
09:13:22 <monochrom> yes
09:13:30 <roconnor> where do you live now?
09:13:35 <monochrom> Toronto too
09:13:43 <roconnor> that's not far away!
09:13:49 <roconnor> have you met Cale?
09:13:52 <monochrom> no
09:13:58 <roconnor> me neither!
09:14:44 <rjo> have you followed J. Baez' blog?
09:15:10 <merijn> Canada have any universities with good CS (and then specifically PL/distributed systems oriented) departments?
09:15:15 <monochrom> I no longer mind a department missing out on a subject. It's a zero-sum game.
09:15:25 <Kaidelong> ProfElm: LEarning haskell is a good way to learn to program, not so much a good way to learn mathematics
09:15:51 <rjo> Kaidelong, but it might get reason to learn mathematics?
09:15:57 <monochrom> Toronto has no PL but several pretty famous distributed people
09:16:33 <rjo> get=give
09:16:36 <Kaidelong> I guess it'll motivate you to try to understand some of the papers about haskell
09:16:42 <vegai> I would imagine that any distributed people would be pretty famous.
09:17:02 <merijn> I'm shopping around for potential phd places abroad, but rather uninformed about which uni's have good departments for the stuff I'm interested
09:18:03 <roconnor> merijn: go to nijmegen
09:18:15 <merijn> That's not abroad >.>
09:18:23 <roconnor> oh right
09:18:25 <roconnor> merijn
09:18:53 <Kaidelong> What about Calgary?
09:19:02 <merijn> Supposedly Utrecht has a decent department working on Haskell as well
09:19:10 <roconnor> merijn: in that case, don't go abroad!
09:19:19 <roconnor> :D
09:19:40 <Kaidelong> didn't Dutch universities have a poor reputation? Or was that only for undegraduate education?
09:20:01 <merijn> That highly depends on which university I'd say
09:20:08 <sleepynate> that's only what the germans are saying Kaidelong :)
09:20:12 <Kaidelong> I suppose in any place there are outliers
09:20:16 <roconnor> Kaidelong: I certainly enjoyed doing type theory at Nijmegen
09:20:18 <Kaidelong> I hear the Germans are even worse
09:20:20 <roconnor> for a phd
09:20:23 <merijn> I'm pretty sure the Free University of Amsterdam has one the better CS departments
09:20:29 <Kaidelong> overcrowding and poor service quality
09:20:31 <roconnor> they also paid me a lot of money instead of charging me a lot of money
09:20:38 <sleepynate> Kaidelong: how else will they convince people to come to de!
09:21:26 <merijn> Kaidelong: Some of the "standard" programs are pretty poor (very Java/software engineering oriented nonsense) but with a bit of effort the less popular programs are pretty good
09:21:32 <roconnor> merijn: heh, sorry about the abroad thing.  I always suggest to people they should go to Europe, and the Netherlands specifically. :D
09:21:48 <djahandarie> I think Haskell is what convinced me to go learn more math
09:22:05 <djahandarie> I know abstract algebra and some category theory now as a result
09:22:08 <Kaidelong> Calculus is what convinced me to learn more math
09:22:15 <ddarius> djahandarie: Learn digital signal processing.
09:22:18 <Kaidelong> Haskell is what convinced me to take algebra more seriously
09:22:26 <merijn> roconnor: Yeah, there's some decent departments around here. But I think that if I don't go abroad *now* I never will
09:22:34 <roconnor> merijn: that is fair
09:22:40 <roconnor> How about Paris?
09:22:49 <roconnor> You'd have to learn ocaml though
09:22:55 <djahandarie> ddarius, isn't that an application of math?
09:23:33 <ddarius> Kaidelong: Read everything here and on the links from it: http://geocalc.clas.asu.edu/ and also here: http://bayes.wustl.edu/
09:23:38 <ddarius> djahandarie: Yes.
09:23:54 <ddarius> (and actually learn signal processing in general)
09:24:21 <djahandarie> What if I want to learn general abstract nonsense instead?
09:24:22 <ddarius> (Incidentally, the latter is a link on the former indirectly at least.)
09:24:51 <ddarius> djahandarie: You are unreasonably postulating a conflict.
09:24:56 <sleepynate> haskell is what convinced me ya'll are nuts. i now do engineering in VB.net.
09:25:19 <ddarius> sleepynate: VB.NET and all the .NET languages are taking a lot from Haskell.
09:25:31 <Kaidelong> which is not a bad thing at all
09:25:32 <ddarius> Admittedly, VB mostly gets it after being passed through C#.
09:25:46 <aristid> sleepynate: the voice of sanity?
09:25:49 <Kaidelong> C# got some of it from work done at MSR Cambridge
09:25:50 <mtnviewmark> yeah, does VB actually get any of the spiffy LINQ features?
09:25:56 <Kaidelong> and thus directly from Haskell or F#
09:25:59 <rjo> well, if you are studying electromagnetic nonsense far enough, you find that you end up learning category theory
09:25:59 <merijn> roconnor: I'm mostly thinking of Canada/New Zealand/US because 1) entirely different environment instead of "1 meter" constituting a hill and 2) English would make it considerably easier to get around
09:26:11 * sleepynate fires up his FunctionalVB interpreter
09:26:25 <mafs> merijn: what I'd do to have metric over here..
09:26:27 <Kaidelong> mtnviewmark: yes, and a special syntax for it
09:26:40 <Kaidelong> F# manages to do everything LINQ does without needing special syntax, Haskell too
09:26:41 <mtnviewmark> whee... nothing like shoehorning syntax!!!!
09:26:58 <ddarius> Haskell has special syntax, though it's not really necessary.
09:27:18 <merijn> Nothing is as sweet as nice syntactic sugar!
09:27:23 <Kaidelong> actually that is true for VB too
09:27:25 <roconnor> merijn: okay, but in Canada/US they universities will pay you crap and/or charge you tuition.
09:27:31 <Kaidelong> you can use method calls
09:27:38 <Kaidelong> it'd be wordy but doable
09:27:38 <ddarius> C# does actually need it due to the lack of polymorphism over higher kinds.
09:27:59 <monadic_kid> f# doesn't haver higher kinds
09:28:15 * roconnor was better paid as a PhD student in the Netherlands than as a post-doc in Canada.
09:28:16 <sleepynate> ddarius: i'm kidding of course. CLI can suck an egg. I just had a meeting with an engineer the other day who's a relatively recent graduate (where I guess they teach primarily .NET in engineering schools?) and was convinced we should spend an extra 4 dollars per microcontroller just to get ones that run C# instead of C
09:28:31 <merijn> roconnor: Yeah, that's a bit of a bummer :p
09:28:57 <ddarius> sleepynate: C# is a pretty nice language, but I don't think I'd want it on a microcontroller.
09:28:57 <roconnor> :)
09:29:06 <sleepynate> ddarius: precisely
09:29:10 <aristid> sleepynate: how much do the C-capable controllers cost?
09:29:18 * mtnviewmark wonders what HW a microcontroller needs to run C# that it doesn't for C...
09:29:18 <roconnor> merijn: when I was was studing at Berkeley I had to work as a TA, which wasn't bad
09:29:23 <Kaidelong> running managed code directly on hardware confers some advantages IIRC
09:29:28 <roconnor> merijn: then I got a fellowship and couldn't TA anymore
09:29:30 <sleepynate> aristid: standard PICs. 2-3 bucks, depending on which you want
09:29:32 <Kaidelong> ACM Communications had something on that recently
09:29:39 <roconnor> merijn: and ended up with less money than when I was TAing :(
09:29:39 <ddarius> mtnviewmark: A CLR implementation and the embedded .NET framework.
09:29:44 <sleepynate> aristid: so yes, it nearly triples the cost :)
09:29:50 <mtnviewmark> but in HW? or is that just a SW license?
09:29:51 <aristid> sleepynate: ah :)
09:29:57 <mtnviewmark> and ROM code?
09:30:17 <aristid> sleepynate: how complex is the software?
09:30:35 <rjo> what was again this "cargo cult math" link?
09:30:43 <djahandarie> It's on reddit
09:30:52 <sleepynate> aristid: well, the part he doesn't like is the http server / curl functionality
09:30:56 <roconnor> rjo: http://symbo1ics.com/blog/?p=788
09:31:00 <sleepynate> basically, he's afraid of C strings
09:31:11 <merijn> roconnor: Disregarding crappy payment, getting a position at one of the more famous universities is probably a challenge in itself
09:31:15 <mtnviewmark> makes you wonder if people who learn only .NET really know how this stuff gets implemented...
09:31:17 <merijn> sleepynate: Who doesn't?
09:31:23 <sleepynate> it's essentially several hundred sensors and an embedded webserver
09:31:29 <Kaidelong> mtnviewmark: the whole point is that you don't have to
09:31:31 <merijn> C strings are the stuff of nightmare's :x
09:31:47 <aristid> sleepynate: well, C strings _are_ evil. you could use C++ if the hardware is good enough :P
09:31:49 <mtnviewmark> and yet - if you're building something with microcontrollers... perhaps you aught to!
09:32:11 <ddarius> sleepynate: You ever look at Adam Dunkel's stuff.  I'm not saying it is useful to you, but it is amusing.
09:32:16 <sleepynate> merijn: except we have a limited set of acceptable commands! you can essentially use if (str[0] == 'G' && str[1] == 'E' ....
09:32:30 <sleepynate> else { /* */ }
09:32:30 <Kaidelong> mtnviewmark: Ought you really? You could break something.
09:32:42 <merijn> sleepynate: Yes, but handling unicode is a pain
09:32:50 <sleepynate> merijn: don't need to
09:32:52 <Kaidelong> anyway Java and .NET microcontrollers are around and sell well
09:32:59 <Kaidelong> so obviously there is a niche for them
09:33:06 <mtnviewmark> yes - I don't mean that you should program to the bare metal - but that when coding in small constrained systems, it is generally important to understand how your high level coding translates -
09:33:16 <sleepynate> it has a DSL over HTTP to talk to "real" webservers... that's about it :D
09:33:19 <monadic_kid> ddarius: F# doesn't suport higher-kinded polymorphism, they have special form for monadic code that gets desugared into bind/return/etc but you can't write generic monadic code in f# well you could probably emulate that with inline functions those are treated like templates in F#
09:33:22 <merijn> sleepynate: If you never have to interface with user strings or anything other then ASCII it's "ok"
09:33:42 <sleepynate> merijn: yea. they're only talking to other computers
09:33:43 <ddarius> monadic_kid: Why are you telling -me- this?
09:33:57 <sleepynate> merijn: so basically, there's 0 reason other than he is a C wuss
09:34:33 <rjo> so you're choosing C++ over C if you've the choice?
09:34:54 <monadic_kid> ddarius: because you mentioned C# earlier, no different in f# either
09:35:06 <Kaidelong> monadic_kid: what'd stop you from using an interface to do it?
09:35:11 <ddarius> monadic_kid: And what made you think I needed to be informed about this?
09:35:29 <Kaidelong> interfaces can have type parameters
09:35:39 <monadic_kid> Kaidelong: they can't take higher kinds
09:36:49 <ajjjajajjajj> hi, is there some alternative to the <- keyword in the do notation? I don't really want to give a name to my IO result, just feed it into my function....
09:37:21 <roconnor> ajjjajajjajj: do notation is synatic sugar for >>= and such
09:37:28 <monadic_kid> Kaidelong: you can't write a a type signature for functions like sequence, mapM, foldM, fmap etc in F# and .NET Generics in general.
09:37:30 <merijn> ajjjajajjajj: Yes, use >>=
09:37:37 <merijn> :t (>>=)
09:37:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:37:40 <roconnor> ioResult >>= myfunction
09:38:06 <ajjjajajjajj> ok, thanks!
09:38:15 <Kaidelong> 'T Monad -> ('T -> 'U) -> 'U Monad
09:38:22 <Kaidelong> what is wrong with that?
09:38:33 <Kaidelong> I forgot if you need the hash there
09:38:38 <Kaidelong> but Monad would be an interface
09:38:41 <ddarius> "Miniweb is a proof of concept that shows that it is possible to implement a TCP/IP stack and a web server using only around 30 bytes of RAM."
09:38:52 <roconnor> merijn: ya, you have take those stupid GREs
09:40:03 <Kaidelong> that said I write mostly in Haskell and not in F# so perhaps I am forgetting something
09:41:43 <ajjjajajjajj> hm, >>= works for channeling another action, but what I want to do is getPermissions "somefile" >>= readable
09:41:53 <ajjjajajjajj> so kinda the opposite of return
09:42:23 <roconnor> readable?
09:43:14 <merijn> ajjjajajjajj: "getPermissions "somefile" >>= return . readable"?
09:43:28 <parcs> ajjjajajjajj: fmap
09:43:39 <roconnor> ya you can use fmap instead of >>=
09:43:53 <roconnor> ioResult `fmap` myfunction
09:43:55 <roconnor> or
09:43:59 <roconnor> ioResult `liftM` myfunction
09:44:12 <parcs> or ioResult <$> myFunction :)
09:44:31 <ajjjajajjajj> thanks to all, will try these :)
09:48:38 <parcs> actually it's myFunction <$> ioResult
09:48:39 <Kaidelong> ddarius: Why was I supposed to be reading those?
09:48:51 <Kaidelong> having looked over them, I lack context
09:48:55 <ddarius> Kaidelong: Just do it.  You'll thank me in the end.
09:49:08 <Kaidelong> I am doing so!
09:50:15 <ddarius> Kaidelong: But to provide some motivation, here's Maxwell's equation(s) in geometric calculus, ∇F=J and ∇ is invertible and this isn't just some compact but semi-arbitrary notation.
09:51:12 <Kaidelong> motivation is not a problem, but that is very motivating. The page on probability theory looks quite interesting, but I'm reading in the order you suggested and starting with the geometric calculus
09:51:56 <ddarius> Kaidelong: They're independent so you can read them simultaneously.  Jaynes also has awesome stuff on statistical mechanics and entropy and quantum mechanics.
09:52:20 <ddarius> (Though his pet theory of the electron is... not one I agree with.  Hestenes has a much better one.)
09:52:53 <ddarius> Kaidelong: Probably a good overview of those aspects is the paper "Clearing up mysteries."
09:53:15 <roconnor> ddarius: best paper ever written!
09:53:31 <mtnviewmark> An electron is a monad in the category of endo-particles?
09:55:34 <ddarius> Kaidelong: Back to Geometric Algebra, Hestenes' page is a good resource but if you are -really- into physics you want to (continue reading Hestenes' page and) read this page as well: http://www.mrao.cam.ac.uk/~clifford/  For more CS-y applications (though also some really good foundation-laying papers) see http://www.science.uva.nl/ga/
09:56:12 <ddarius> The paper "The Inner Products of Geometric Algebra" is a deceptively named paper.  It is far more useful than the title suggests.
09:56:26 <mtnviewmark> Woot: 35 people signed up for BayHac!  
09:56:34 <mtnviewmark> gonna be a great Haskell Hackathon!
09:57:17 <roconnor> mtnviewmark: when?
09:57:24 <mtnviewmark> Feb 11-13
09:57:33 <mtnviewmark> in Mountain View, CA
09:57:39 <mtnviewmark> er, California, USA
09:58:27 <djahandarie> Not to be confused with Mountain View Canada
09:58:57 <mtnviewmark> exactly!
09:59:11 <mtnviewmark> I hear there are a lot of mountains viewable in Canada....
10:00:07 <mtnviewmark> details here -> http://groups.google.com/group/bayhac
10:02:20 <rjo> heh, I sent job application to position, which I thought to be in CA, but it was in NY
10:02:31 <djahandarie> Hacker Dojo? That's a pretty sweet name
10:02:47 <rjo> from here it does not have much difference
10:03:43 <mtnviewmark> And it's a pretty sweet space: http://www.hackerdojo.com/
10:05:54 * hackagebot jmacro 0.4.2 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.4.2 (GershomBazerman)
10:10:50 <jonathan__> I'm getting an overlapping instances error, but what is confusing me, is I am not importing one of the modules
10:11:08 <monochrom> perhaps you made some of your own
10:11:26 <jonathan__> no
10:11:57 <mescalinum> I'm failing to install a cabal package on windows (http://pastebin.com/MkXEWsiJ) is it this package's fault or what?
10:12:00 <jonathan__> here's the error: instance Monad (Either e) -- Defined in Control.Monad.Trans.Error
10:12:08 <jonathan__> instance (mtl-1.1.0.2:Control.Monad.Error.Class.Error e) => Monad (Either e)
10:12:27 <jonathan__> I am not importing the mtl stuff
10:12:31 <jonathan__> only the first one
10:14:23 <aristid> jonathan__: it suffices if one of the modules that you import imports it
10:14:32 <monochrom> in some sense it's windows's fault to insist on ".exe" :)
10:14:44 <jonathan__> aristid: how can I prevent that?
10:14:51 <aristid> jonathan__: you can't
10:15:09 <monochrom> more seriously, probably cabal's fault of getting confused when the executable name is "x.cgi" or "x.cgi.exe"
10:15:15 <jonathan__> artistid: what is the workaround?
10:15:45 <aristid> jonathan__: not import the less usual instance
10:16:53 <jonathan__> artistid: So if am using a package that imports mtl I have to also?
10:17:09 <aristid> aristid, not artistid :)
10:17:17 <jonathan__> haha sorry
10:17:26 <sproingie> yay tab-complete
10:18:05 <aristid> sproingie: unfortunately needs more than two characters before succeeding, so if he starts with art, it won't find my nick
10:18:16 <rjo> "cargo cult math" blog is enlightening to read
10:18:20 <sproingie> irssi will do it from one
10:18:23 <jonathan__> but I'm not even that smart
10:18:26 <MHD0> Hey, I have this problem with OpenGL, I have OpenGLUT installed, but when I compile a little hello world example, it pops up a DLL related error message when I run it.
10:18:47 <sproingie> MHD0: and what is that message?
10:19:04 <Zao> Never heard of OpenGLUT, heh.
10:19:08 <Zao> Isn't it built against freeglut?
10:19:14 <merijn> sproingie: Shush! You're taking all the fun out of guessing :p
10:19:31 <monochrom> rjo: what enlightenment does it bring to you?
10:19:31 <sproingie> it looks like a superset of glut
10:19:52 <MHD0> sprotinge: Well first off, it cant find glut32.dll, so I copy/rename OpenGLUT.dll to that name, and now it complains that it can't find the entry point "glutAddMenuEntry"
10:19:52 <sproingie> and it does look like it builds on freeglut
10:20:42 <rjo> that the community is very alive
10:20:57 <monochrom> interesting
10:21:02 <sproingie> MHD0: that kinda sucks.  do you get the same problem with freeglut?
10:21:43 <sproingie> or with the opengl sdk from your gpu vendor?
10:21:50 <ddarius> "Autobisimulation"
10:21:53 <MHD0> sporingie: Haven't tried with freeglut. Does it come precompiled? I dont know how to compile my own dll stuff... (on a sub optimal winxp machine)
10:21:53 <sproingie> (which is usually freeglut)
10:22:42 <ddarius> rjo: Nah, we're not alive, we just superficially go through the motions of being alive in the hope that that will bring that actual spark of life.
10:22:59 <sproingie> MHD0: there's precompiled versions around, yes
10:24:13 <sproingie> freeglut 2.6 supposedly has problems on windows7 so you might want to stick with 2.5
10:24:21 <sproingie> er 2.4
10:24:39 <sproingie> and binaries are at http://www.transmissionzero.co.uk/software/freeglut-devel/
10:26:10 <MHD0> sprongie: freeglut.dll as glut32, that did the trick, thanks.
10:26:29 <sproingie> MHD0: shame that the openglut dll wasn't binary compatible :(
10:27:41 <sproingie> but GLFW > GLUT anyway
10:31:13 <mescalinum> :q
10:31:14 <CindyLinz> It's my first time to use Cabal. It tells me to upgrade cabal-install by  cabal install cabal-install.  And then, it seems run out all my memory, forcing me to reboot my computer... I've tried many times. :(
10:31:24 <mescalinum> has anyone installed haskell cgi packages on windows?
10:31:52 <CindyLinz> How much memory is sufficient, though?
10:32:55 <monochrom> If it ain't broken, don't fix it.
10:33:48 <monochrom> All these "you should upgrade" automatic messages are really harmful
10:34:07 <Cale> CindyLinz: It really shouldn't take all that much...
10:34:14 <mescalinum> ls
10:34:23 <Cale> CindyLinz: Something is probably going horribly wrong.
10:34:53 <monochrom> Not to say that you should never upgrade. You should upgrade a whole suite of software together as a set that has been tested and recommended by others as "proven to work well together". Not piecemeal. Unless you're a pro.
10:35:21 <monochrom> So for example upgrading a whole linux distro is fine, upgrading a whole Haskell Platform is fine.
10:36:05 <djahandarie> How about updating chrome
10:36:11 <mtnviewmark> nonetheless, cabal shouldn't be running out of memory on CindyLinz's machine - 
10:36:21 <CindyLinz> It might be a bad habit of mine to apt-get dist-upgrade everyday ^^|
10:36:47 <CindyLinz> mtnviewmark: It hangs while runnig ld
10:37:25 <nwbi> Suppose I have the following function: http://pastebin.com/9rZyykgM .   I want to do something like: filter (foo n 1 1) [1,2,3,0,2]. That doesn't work obviously, but I guess somebody can understand my question. I want to set the last two parameters, and leave the first one to be used by filter.
10:37:28 <mtnviewmark> is it possible that it upgraded your GHC compiler out from under you?
10:37:55 <CindyLinz> So, you mean that it's not frequently happened to run out the memory?
10:38:10 <mtnviewmark> nwbi - you want     filter (\n -> foo n 1 1) [1,2,3,0,2]     perhaps?
10:39:01 <nwbi> mtnviewmark, oh, that seems good. It's like an anonymous function I guess
10:39:03 <mtnviewmark> nwbi: or are you trying to keep each element of the list only if it, and it's next two followers together pass foo
10:40:20 <mtnviewmark> nwbi: kind of, yes, though I'd say it is a "function"  or a "lambda expression"
10:41:19 <nwbi> mtnviewmark, not, the first one. But now that you ask that, I dont have an idea of that either. I mean, with filter. I could invet some nasty thing using header 3 times hehe
10:41:29 <roconnor> nwbi: I'd call it an anonymous function
10:42:12 <nwbi> Or pattern matching like (a:b:c:xs)
10:42:42 <mtnviewmark> > let q=[1,2,3,0,2], foo a b c= a < b+c in filter (\(a,b,c)-> foo a b c) (zip3 q (tail a) (tail $ tail q))
10:42:44 <lambdabot>   <no location info>: parse error on input `,'
10:42:52 <monochrom> djahandarie: upgrade piecemeal if you're a pro, as in, shrewd sysadmin
10:42:59 <mtnviewmark> > let q=[1,2,3,0,2]; foo a b c= a < b+c in filter (\(a,b,c)-> foo a b c) (zip3 q (tail a) (tail $ tail q))
10:43:00 <lambdabot>   Couldn't match expected type `[t]'
10:43:00 <lambdabot>         against inferred type `SimpleRef...
10:43:54 <mtnviewmark> > let q=[1,2,3,0,2]; foo a b c= a < b+c in filter (\(a,b,c)-> foo a b c) (zip3 q (tail q) (tail $ tail q))
10:43:55 <lambdabot>   [(1,2,3),(2,3,0)]
10:44:04 <mtnviewmark> something like that
10:44:35 <nwbi> I see, I know what zip is (dont know difference with zip3) but I see the idea, you zip the same list with a +1 and +2 offset or smth like that
10:45:05 <nwbi> Thanks for your help.
10:45:06 <mtnviewmark> > zip3 "123"  [10,20,...] "ABC"
10:45:07 <lambdabot>   <no location info>: parse error on input `]'
10:45:16 <mtnviewmark> > zip3 "123"  [10,20...] "ABC"
10:45:18 <lambdabot>   A section must be enclosed in parentheses thus: (20 ...)Not in scope: `...'
10:45:26 <mtnviewmark> > zip3 "123"  [10,20,30] "ABC"
10:45:27 <lambdabot>   [('1',10,'A'),('2',20,'B'),('3',30,'C')]
10:45:45 * mtnviewmark can't type today
10:45:58 <bsmntbombdood> @instances Monad
10:45:59 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
10:46:06 <nwbi> mtnviewmark, cool :)
10:46:13 <bsmntbombdood> where can I find the instance for Monad ((->) r)?
10:48:39 <Cale> bsmntbombdood: Control.Monad.Instances
10:48:44 <Cale> Or Control.Monad.Reader
10:49:16 <Cale> nwbi: zip3 just zips three lists
10:49:29 <Cale> nwbi: and produces a list of triples instead of a list of pairs
10:54:58 <bsmntbombdood> instance Monad ((->) r) where f >>= k = \ r -> k (f r) r
10:55:03 <bsmntbombdood> what is that useful for?
10:56:14 <Cale> Well, let's look at what it does...
10:56:31 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
10:56:31 <lambdabot>   ("hello","olleh","HELLO")
10:56:58 <Cale> "Running" a function in this monad means applying it to the parameter to which the whole function has been applied.
10:57:16 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
10:57:17 <lambdabot>   [5,7,10,25,32]
10:57:21 <aristid> > (,,) <$> id <*> reverse <*> map toUpper $ "hello"
10:57:22 <lambdabot>   ("hello","olleh","HELLO")
10:57:40 <Cale> > liftM2 (++) id reverse "hello"
10:57:42 <lambdabot>   "helloolleh"
10:58:50 <pozic> How can I put a block of text next to another block using some pretty printer combinator library? 
10:59:44 <BMeph> pozic: Prettily! ;þ
10:59:45 <monochrom> it is <> or <+> in Text.PrettyPrint.HughesPJ
11:00:05 <monochrom> lambdabot has this module so I could contrive an example...
11:01:07 <monochrom> recall that "x $+$ y" places x above y, i.e., vertically.
11:01:28 <pozic> monochrom: that function from ansi-wl does the same thing, AFAIK.
11:01:33 <pozic> monochrom: and it's not what I want.
11:01:40 <aristid> :t ($+$)
11:01:42 <monochrom> > (text "aa" $+$ text "bbb") <+> (text "bbc")
11:01:45 <lambdabot> Doc -> Doc -> Doc
11:01:47 <lambdabot>   Ambiguous occurrence `<+>'
11:01:49 <lambdabot>  It could refer to either `Control.Arrow.<+>', i...
11:01:58 <bsmntbombdood> i see
11:01:59 <monochrom> oh bother
11:02:02 <djahandarie> Arrow!!!!!!!
11:02:14 <monochrom> > (text "aa" $+$ text "bbb") Text.PrettyPrint.HughesPJ.<+> (text "bbc")
11:02:15 <lambdabot>   aa
11:02:16 <lambdabot>  bbb bbc
11:02:37 <djahandarie> ...
11:02:52 <djahandarie> Ah it still has an extra space at the beginning
11:02:57 <mux> aristid: damnit, I think I need to have DFAs polymorphic in the state type indeed, or the NFA determinisation algorithm won't be practical :-)
11:03:06 <aristid> mux: :)
11:03:20 <mux> aristid: I hate you for being right :-P
11:03:22 <aristid> mux: which different state types do you need?
11:04:03 <mux> aristid: That would allow to easily have DFAs with states that are sets of Int's (or rather, sets of the original NFA state type)
11:04:17 <mux> for the powerset-construction algorithm
11:04:39 <mux> I'd end up with something like this :
11:04:42 <aristid> mux: then you can't use IntMap at all
11:05:05 <mux> yes, of course
11:05:08 <mux> no big deal.
11:05:12 <mux> so
11:05:29 <aristid> good
11:05:47 <mux> determine :: (Ord a, Ord b) => NFA a b -> [a] -> DFA a (Set b)
11:05:52 <mux> if the alphabet is given explicitely.
11:06:04 <mux> which is, one has to admit, terribly cute
11:06:06 <rrc7cz> is there any good reference for when to use String, ByteString, or Text?
11:06:13 <aristid> mux: :)
11:06:31 <aristid> mux: why not give the alphabet as a Set?
11:06:37 <mux> aristid: I'll just switch to GMap when it's ready to get the benefits of IntMap/IntSet for free
11:06:46 <mux> well, I'm going to iterate it anyways
11:06:52 <mux> unless I'm missing something
11:06:55 <aristid> hmm
11:07:21 <mux> (I'm not validating that values are part of an alphabet, we have types for that if we want)
11:07:33 <monochrom> yes, here it is: String for prototype or if not too slow for you, ByteString for performant 8-bit things, Text for performant unicode things.
11:10:05 <mux> hmmm
11:10:33 * ManateeLazyCat Last testing....
11:11:52 <mux> aristid: I actually could go around using sets for the state type in DFAs/NFAs, I'd just need an injective function from sets of ints to ints :-P
11:11:55 <rrc7cz> monochrom: thanks, but how do I convert between all of these? I guess it doesn't make much sense to convert ByteStrings to Text because you already lost any unicode support
11:11:59 <mux> but that would feel a bit hackish maybe
11:12:45 <aristid> mux: just use Map for now :)
11:13:56 <monochrom> There are functions for String->Text and Text->String if you really want. But I would first try rewriting my program (from using String throughout to using Text throughout), which is usually fairly little work.
11:15:01 <rrc7cz> monochrom: I can rewrite my fns, but I'm more concerned about libs. For example, I'm trying to understand Snap, and it returns both lazy and strict ByteStrings in some places, but supports writing Text in others
11:15:08 <ManateeLazyCat> Now Manatee support customize and hot-swap, enjoy! ;p 
11:15:27 <mikeg> is overloadedstrings a compile-time thing? or does it just add a "pack" that has to be done before i can use the IsString version?
11:16:11 <monochrom> well, sometimes a lib uses ByteString because the data is inherently uninterpreted 8-bit things
11:16:30 <aristid> and sometimes it uses ByteString because ASCII is all the world needs(TM)
11:17:25 <rrc7cz> but wouldn't a web framework need to support multiple languages?
11:17:52 <monochrom> take for example fetching things from http. the correct thing to do, speedily, is put it in ByteString first, since you don't even know it's UTF-8 or iso-latin-1 or gzipped data or png or ...
11:18:17 <rrc7cz> I asked on #snapframework and gcollins says that you get a string of bytes, and it's up to you to interpret characters from that
11:18:42 <vegai> I tend to think that everything that was written after 1995 not in Unicode should have a damned good reason 
11:19:02 <rrc7cz> vegai: I agree with that
11:19:18 <monochrom> Then you pretend it's ascii for a moment so you could meaningfully look for "<meta blahblah content-type: text/html; charset=utf-8...>"
11:19:18 <vegai> then again, ByteString doesn't deny that
11:19:56 <monochrom> then you can validly say, "ah, these bytes are utf-8, now I can convert it to String or Text through a decoder"
11:20:17 <monochrom> for it is not always utf-8; it may very well be big5
11:20:23 <djahandarie> What if the content-type itself is written in utf-8?
11:20:38 <ManateeLazyCat> Sorry for late, I was tired of the many trivial this month.
11:20:43 <monochrom> then it is equivalent to ascii
11:20:46 <mtnviewmark> djahandarie --- IT IS! 
11:20:52 <ManateeLazyCat> Now i'm focus on IDE work. :)
11:21:12 <mtnviewmark> actually, Content-Type: header in HTTP must be in Latin1, though all MIME Types are limited to US-ASCII
11:21:13 * hackagebot manatee-core 0.0.7 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.7 (AndyStewart)
11:21:15 * hackagebot manatee-anything 0.0.7 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.7 (AndyStewart)
11:21:48 <mtnviewmark> when sniffing into the body of HTML, I believe the expectation is that all characters through the <meta> tag must be in US-ASCII -- 
11:22:10 <mtnviewmark> and hence sniffing isn't supported for encodings that aren't a superset of US-ASCII
11:22:17 * hackagebot manatee-browser 0.0.7 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.7 (AndyStewart)
11:22:20 * hackagebot manatee-editor 0.0.7 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.7 (AndyStewart)
11:22:21 <monochrom> conversely, if you're the server and you send out http stuff, you also have to choose an encoding and emit the correct bytes at the end. you will convert your String or Text to ByteString through an encoder.
11:22:22 * hackagebot manatee-filemanager 0.0.7 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.7 (AndyStewart)
11:22:24 * hackagebot manatee-pdfviewer 0.0.7 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.7 (AndyStewart)
11:22:24 <djahandarie> monochrom, I didn't realize 御前は馬鹿だ was ASCII
11:22:26 * hackagebot manatee-mplayer 0.0.7 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.7 (AndyStewart)
11:22:33 <ManateeLazyCat> Sorry, guys. :)
11:22:43 <djahandarie> ManateeLazyCat, lol, np
11:22:51 <djahandarie> hackagebot should just group updates
11:22:53 <sproingie> oh the huge manatee!
11:22:57 <monochrom> 御前は馬鹿だ is not supposed to appear in <meta blahblah content-type >
11:23:21 <djahandarie> monochrom, I know this now. ;)
11:23:25 <ManateeLazyCat> I will draw some picture to explain my new hot-swap framework "compile cache server". :)
11:23:28 * hackagebot manatee-ircclient 0.0.7 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.7 (AndyStewart)
11:23:30 * hackagebot manatee-processmanager 0.0.7 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.7 (AndyStewart)
11:23:32 * hackagebot manatee-imageviewer 0.0.7 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.7 (AndyStewart)
11:23:34 * hackagebot manatee-reader 0.0.7 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.7 (AndyStewart)
11:23:36 * hackagebot manatee-curl 0.0.7 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.0.7 (AndyStewart)
11:23:38 <djahandarie> lol dear god
11:23:45 <allbery_b> manatease
11:23:48 <monochrom> you asked about content-type. that part is standardized to be ascii-compatible.
11:23:52 <sproingie> spamatee
11:24:01 <djahandarie> Anyone idea what is running on hackagebot?
11:24:14 <djahandarie> Anyone have an idea*
11:24:38 * hackagebot manatee-terminal 0.0.7 - Terminal Emulator extension for Manatee.  http://hackage.haskell.org/package/manatee-terminal-0.0.7 (AndyStewart)
11:24:40 * hackagebot manatee 0.1.6 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.6 (AndyStewart)
11:24:47 <ManateeLazyCat> Ok, finish, sorry. :)
11:25:05 <djahandarie> Who runs hackagebot anyways?
11:25:47 <BONUS> yeah maybe he could do the announcements in batches if a lot of them come in a short time interval
11:25:48 <lambdabot> BONUS: You have 4 new messages. '/msg lambdabot @messages' to read them.
11:25:50 <monochrom> A joyful com
11:25:51 <BONUS> whoa
11:25:53 <ManateeLazyCat> djahandarie: Yes, hackagebot should fixed this problem, think about 1 year later. :)
11:26:23 <BONUS> @tell
11:26:23 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
11:26:43 <ManateeLazyCat> I use package 'dist-upload' upload Manatee package automatically
11:26:48 <ManateeLazyCat> @package dist-upload
11:26:48 <lambdabot> http://hackage.haskell.org/package/dist-upload
11:26:50 <monochrom> eventually hackagebot should move to twitter :)
11:27:29 <sipa> use bitlbee :p
11:29:34 <djahandarie> monochrom, I think it is on twitter
11:30:23 <ManateeLazyCat> Now Manatee support customize and hot-swap, and API almost stable, i hope more friends join Manatee team. :)
11:31:00 <mtnviewmark> which hot-swap tech. are you using? hs-plugins?
11:31:16 <ManateeLazyCat> mtnviewmark: My own code.
11:31:26 <monochrom> just calls ghc-api
11:31:31 <ManateeLazyCat> mtnviewmark: New framework base on GHC-API
11:31:54 <ManateeLazyCat> monochrom: Yeap, ghc-api is stronger.
11:32:10 <ManateeLazyCat> hs-plugins easy to break if GHC upgrade.
11:32:16 <mtnviewmark> ah - still can't unload code ever, right?
11:32:27 <monochrom> no one has unloaded code ever
11:32:28 <ManateeLazyCat> mtnviewmark: I will draw some picture later to explain my framework. :)
11:32:29 <mtnviewmark> (not that I worry about that too much)
11:33:24 <ManateeLazyCat> My framework fixed "speed" "safe" and "compatible"
11:33:45 <monochrom> Do you use Typeable somewhere?
11:33:51 <ManateeLazyCat> monochrom: No.
11:34:29 <ManateeLazyCat> monochrom: Any type you can use, not just Typeable
11:34:36 <mtnviewmark> we are using hs-plugins for the Barley project, and will be converting to a sort of hybrid approach like happs took soon
11:35:07 <ManateeLazyCat> My English not good enough to explain those, i will draw some picture...
11:35:19 <ManateeLazyCat> Simple, it's "compile cache server"
11:35:52 <mtnviewmark> looking forward to it... put it on reddit when you draw it -- 
11:36:05 <ManateeLazyCat> mtnviewmark: I will let you know when i finish. :)
11:37:06 <ManateeLazyCat> monochrom: I use GHC-API with TVar
11:41:36 * ManateeLazyCat Draw picture....
11:43:02 <c_wraith> TVar?  That doesn't seem sufficient.  You know the GHC api isn't thread-safe, right?
11:43:16 <ManateeLazyCat> c_wraith: No, no.
11:43:53 <monochrom> perhaps the TVar protects ghc-api
11:44:25 <ManateeLazyCat> c_wraith: TVar is *middle* layer between "GHC compile server" and "Application read thread"
11:44:41 <c_wraith> oh, ok.  the compile server is what enforces thread safety then?
11:45:10 <monochrom> solve thread-unsafety by more thread-unsafety
11:45:49 <ManateeLazyCat> c_wraith: I just simple catch GHC session, if compile server failed, it's not big deal, application still can use old value in TVar.
11:46:19 <c_wraith> ah.  I guess that works
11:46:20 <ManateeLazyCat> c_wraith: The key of my framework is "cache"
11:46:57 <ManateeLazyCat> c_wraith: Because application just read frome TVar cache layer, it's much much faster than interpreter solution.
11:47:20 <monochrom> dual-port memory
11:47:53 * monochrom re-invented hardware dual-port memory once
11:48:03 <ManateeLazyCat> monochrom: Yep, so it's just use for developer, once you adjust finish, Manatee can mix new conifgure to build new version
11:48:18 <ManateeLazyCat> monochrom: New version don't need dynamic loading anymore.
11:49:18 <ManateeLazyCat> monochrom: I don't what's the "dual-port memory", i just think which solution can fix "speed" and "safe" problem, then i get this idea.
11:49:42 <monochrom> that happened to me too
11:49:56 <monochrom> all re-inventions are like that
11:50:04 <ManateeLazyCat> monochrom: Infact, i have dynamic-loading code in first version Manatee, just too slow until now...
11:51:28 <ManateeLazyCat> monochrom: If GHC can release memory well, then we can use dynamic-loading always, and not just in *develop mode*.
11:54:20 <ManateeLazyCat> But i'm very happy now, my develop speed will grow because i can modified application in runtime.
11:55:26 <mtnviewmark> This is why we did it for Belay: If we're going to teach Haskell to PHP web programmers - they're going to expect to be able to save source and immediately try it
11:55:42 <mtnviewmark> er/ Barley (not Belay ... that's my OTHER project....)
11:56:15 <FireSnake> pdf2line is freezing my computer when I try it on the smallest of PDF files.  Anyone else have this experience or know how to fix it?  I just want to get the text from PDF using Haskell.
11:56:19 <ManateeLazyCat> mtnviewmark: What's the Barley? Any link?
11:56:34 <FireSnake> I'm on Ubuntu
11:56:55 <mjrosenb> how should i concatenate the contents of a tree of ByteStrings into a single ByteString?
11:56:59 <mtnviewmark> it's really not quite ready for first release: https://github.com/mtnviewmark/barley
11:57:23 <mtnviewmark> we will target 0.5 (first usable release) for end of January --
11:57:36 <mtnviewmark> and will be using it at the Workshop portion of BayHac in early February
11:57:53 <mtnviewmark> I think based on that experience, we'll have 1.0 end of March or so
11:58:27 <ClaudiusMaximus> i'm working on an untyped lambda calculus interpreter, and i'm getting fed up with writing things like: cons = \x xs c n . c x (xs c n) ; nil = \c n . n  -- i'd rather write:  List x = Cons x (List x) | Nil  and have the constructors generated automatically; any papers to recommend me?
11:58:56 <Veinor> oh hey, someone mentioned askitter. i should develop that some more.
11:59:29 <ManateeLazyCat> mtnviewmark: What's the aim of Barley? Online haskell environment?
12:00:05 <mtnviewmark> The aim is a tool for learning and exploring Haskell 
12:00:27 <mtnviewmark> I wouldn't put Barley on-line (at least until I know how to sandbox IO like tryhaskell does)
12:00:31 <ManateeLazyCat> mtnviewmark: I see. :)
12:01:00 <ManateeLazyCat> mtnviewmark: Don't allowed IO action.  :)
12:01:21 <mightybyte> > print 42
12:01:21 <mtnviewmark> It gives people a very quick - take a "hello world" web page app in Haskell, modify it a bit - hit save... see result of running
12:01:22 <lambdabot>   <IO ()>
12:01:44 <monochrom> ClaudiusMaximus: perhaps look for "church encoding", it's the general scheme
12:01:51 <mtnviewmark> and it is coupled with a tutorial to take you from zero to beginner (or at least it will be when we are done writing it!)
12:02:58 * mtnviewmark >>= lunch
12:03:02 * ManateeLazyCat Working on Google docs...
12:03:08 <ManateeLazyCat> @time
12:03:10 <lambdabot> Local time for ManateeLazyCat is Thu Dec 30 04:02:27 2010
12:03:12 <sipa> :t lunch
12:03:14 <lambdabot> Not in scope: `lunch'
12:03:15 <ManateeLazyCat> Funny. :)
12:04:33 <ClaudiusMaximus> monochrom: yeah - not found a good article about it yet though (i want something with algorithms, not just a list of examples and a rough description)
12:06:48 <Jesin> umm
12:07:06 <Jesin> wouldn't it be easy to modify the Monad typeclass definition
12:07:18 <Jesin> so that every Monad is automatically a functor, just by defining a default fmap
12:07:24 <Jesin> and adding a typeclass constraint
12:07:43 <Jesin> and then have that not break existing code, as long as it satisfies the monad laws?
12:15:08 <c_wraith> Jesin, I think that'd break things that implement the classes backwards.  that is where their Functor instance says fmap = liftM
12:16:09 <monochrom> ClaudiusMaximus: http://www.cs.uiowa.edu/~astump/papers/archon.pdf section 5.1 is as close to a recipe as I can get.
12:19:33 <BMeph> Would "Scott encoding" be useful? I get fuzzy on the differences between them.
12:19:48 <Jesin> hmm.
12:19:50 <Jesin> well
12:19:55 <Jesin> how is liftM defined?
12:20:06 <monochrom> 5.2 is scott encoding. you can see for yourself :)
12:20:28 <Jesin> @src liftM
12:20:28 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:20:35 * BMeph reads...
12:20:53 <Jesin> c_wraith: I was just considering
12:21:10 <monochrom> scott encoding is untypable in haskell or simply typed lambda calculus. scott encoding is much more inclined to CPS.
12:21:21 <lispy> ?undo do { x1 <- m1; return (f x1) }
12:21:21 <lambdabot> m1 >>= \ x1 -> return (f x1)
12:21:24 <Jesin> adding "fmap f m1 = do { x1 <- m1; return (f x1) }"
12:21:38 <Jesin> to the Monad typeclass declaration
12:21:41 <ClaudiusMaximus> monochrom: ah cool - thanks
12:21:55 <Jesin> c_wraith: wouldn't that fix any circularity problems?
12:22:17 <c_wraith> Honestly, I don't think it would
12:22:38 <Jesin> why not?
12:23:27 <Jesin> I don't see how it wouldn't...
12:23:38 <Jesin> though I'm not familiar with the nuances of typeclass declaration
12:25:03 <lispy> Jesin: all you'd be doing is adding liftM to the Monad type class
12:25:18 <lispy> Jesin: would you really call it fmap?
12:26:15 <Jesin> what I'm talking about, is making all instances of Monad automatically be Functor instances (or preferably Applicative, I'm just using Functor as an example)
12:26:24 <Jesin> without breaking existing code
12:26:37 <Jesin> as long as it follows the monad laws
12:30:38 <ClaudiusMaximus> as i don't care at all about typability, i think scott encoding will be nicer to write programs with (and it seems i was desugaring lists into scott encoding already, but using church encoding for numbers... no wonder i was getting confused)
12:30:40 <BMeph> Jesin: The issue is: How do you handle types that are first declared Functors, and then later made Applicative/Monad?
12:30:54 <alinabi> @help
12:30:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:31:02 <alinabi> @list
12:31:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:31:25 <Jesin> hmm
12:31:31 <BMeph> monochrom: Thanks for the link.
12:31:37 <Jesin> BMeph: I don't really know much about how default definitions work
12:32:05 <Jesin> would having that default definition of fmap, override the existing one when you made something a Monad instance
12:32:07 <Jesin> ?
12:32:48 <Jesin> some equivalent of "qualified" that works with default definitions in typeclass declarations, rather than just import, might be nice...
12:33:06 <BMeph> Jesin: The point is that if it's already a Functor, and the Monad definition tries to make another Functor definition for it, GHC will complain.
12:33:23 <Jesin> hmm
12:33:33 <Jesin> circular default definitions work within one typeclass
12:34:12 <Jesin> like, Num defines {x - y = x + negate y} and {negate x = 0 - x}
12:34:40 <Jesin> can you do the same thing among multiple typeclasses?
12:35:26 <BMeph> JEsin: Now, if there were some facility where the compiler would do an "if it doesn't have a class defn for ___, then define it like this...", that would solve everything. Unfortunately, the way classes are defined, there isn't a "not defined yet" sense for them.
12:35:45 <Jesin> hmm.
12:37:09 <Jesin> why not...
12:37:16 <BMeph> JEsin: Usually, those (Num) definitions are instantiated with one of the other of the circular definitions; when you make an Eq instance, for example, you don't define both '==' and '/='. :)
12:37:33 <Jesin> yes, I know
12:38:00 <BMeph> Jesin: You let the default circularity take care it for you.
12:38:03 <Jesin> I was wondering if there was a way to "not define both" that works across typeclasses, instead of just within one typeclass
12:38:20 <BMeph> Jesin: (That's the "why not" answer, BTW.) 
12:38:23 <kmc> it makes sense to define both (==) and (/=) for compound data, because both can short-circuit
12:39:02 <kmc> hmm, maybe that doesn't matter
12:39:03 <Jesin> kmc: I think they both short circuit the same way, so that doesn't actually optimize anythign
12:39:10 <kmc> yeah
12:39:20 <BMeph> kmc: I stand corrected; you can define them both, but that's usually done because there's some efficiency concern about using the default, right?
12:39:34 <Jesin> ^ exactly
12:39:34 <kmc> you didn't say you can't define them both ;)
12:39:49 <Jesin> why can't that extend across typeclasses?
12:40:02 <BMeph> kmc: True, I did just say "you don't". :)
12:40:35 <BMeph> Jesin: Short answer: "Because classes aren't types." :)
12:41:08 <Jesin> that doesn't tell me anything
12:41:11 <Jesin> =/
12:41:23 <Jesin> maybe the long answer?  :p
12:43:02 <Jesin> BMeph: do you have a long answer?  :p
12:43:15 <sipa> Jesin: how do you mean "extend across typeclasses" ?
12:43:43 <Jesin> I mean, Eq has circular default definitions for (==) and (/=)
12:43:54 <sipa> yes
12:44:12 <Jesin> they kick in if you only define one
12:44:16 <sipa> yes
12:44:18 <Jesin> but not if you define both yourself
12:44:31 <sipa> indeed
12:44:44 <Jesin> and, there is a trivial implementation of Functor for any Monad that follows the monad laws
12:45:10 <Jesin> in terms of the functions that Monad requires
12:45:15 <Jesin> so, I was wondering
12:45:21 <Jesin> @src liftM
12:45:21 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:45:47 <Jesin> why you can't add something like "fmap f m1 = do {x1 <- m1; return (f x1)}" to the Monad definition
12:46:11 <sipa> because fmap is defined in Functor, not in Monad
12:46:13 <Jesin> so that any Monad that defines the Monad functions, but does not define fmap
12:46:17 <Jesin> automatically defines Functor
12:46:20 <Jesin> err
12:46:24 <Jesin> automatically becomes a Functor
12:46:41 <sipa> you want an instance instance Monad m => Functor m ?
12:46:49 <Jesin> yes
12:47:03 <Jesin> preferably without using that wrappedMonad thing
12:47:04 <Jesin> :p
12:47:09 <c_wraith> Oh.  That's what you want?  It breaks everything, you realize?
12:47:14 <RLa> not sure if this is the right place to ask but if i have a meet operator on a lattice then it returns the smaller element of two?
12:47:22 <Jesin> I'm trying to understand how it breaks everything
12:47:46 <c_wraith> Jesin: Because you're declaring that *everything* is a Functor.
12:47:53 <sipa> when you use fmap somewhere, your instance will always match
12:48:21 <Jesin> c_wraith: no, not everything
12:48:27 <Jesin> just Monads
12:48:30 <sipa> Jesin: no
12:48:30 <kmc> Jesin, when the compiler chooses an instance it looks *only* at the head of the instance, not the context
12:49:01 <Jesin> I think what I want might be written as "Monad m => instance Functor m"
12:49:09 <c_wraith> You've declared "m is a Functor.  Also, blow up at a later typechecking phase if m is not a Monad"
12:49:09 <Jesin> not sure, though  :p
12:49:24 <Jesin> no...
12:49:25 <sipa> unless you use overlappinginstances or even worse voodoo, everything that has another Functor instance will break
12:49:40 <c_wraith> Right.  The real problem is that overlaps *every* instance of functor.
12:49:56 <mm_freak> Jesin: note that not every functor is a monad, so you'll get a lot of overlapping instances
12:49:56 <Jesin> hmm
12:50:04 <sipa> Jesin: what you want to do, doesn't exist
12:50:11 <kmc> not in GHC at present
12:50:14 <sipa> indeed
12:50:15 <kmc> i agree it's a desirable thing
12:50:24 <kmc> why doesn't GHC have an extension for backtracking instance resolution?
12:50:39 <kmc> i'm sure it's not easy; i'm just wondering what the particular difficulty is
12:51:04 <mm_freak> i'd rather vote for a saner class hierarchy
12:51:19 <Jesin> that would be nice, yes  :p
12:51:25 <c_wraith> kmc: I think it's actually impossible with separate compilation for each module.
12:51:31 <Jesin> hm?
12:51:37 <mm_freak> class Functor m => Applicative m; class Applicative m => Monad m
12:52:36 <aristid> mm_freak: to make that work well, it would be necessary to have the methods of Functor and Applicative defined automatically
12:52:57 <alinabi> > map (+1) [1,2,3,4,5,6]
12:52:58 <lambdabot>   [2,3,4,5,6,7]
12:53:01 <mm_freak> aristid: why?
12:53:11 <c_wraith> Well, Functor can be derived.  Applicative can't be, though, because it's not unique.
12:53:26 <alinabi> @help
12:53:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:53:34 <alinabi> @help eval
12:53:35 <lambdabot> eval. Do nothing (perversely)
12:53:45 <alinabi> @help run
12:53:45 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
12:53:54 <mm_freak> alinabi: try: /query lambdabot 
12:54:01 <c_wraith> run sounds like the same thing > does
12:54:11 <aristid> mm_freak: because having to write instance Functor X where fmap = liftM across thousands of packages is NOT FUN
12:54:20 <djahandarie> c_wraith, > is an alias for run
12:54:40 <frerich_> Hi, I'm trying to write my own version of the standard 'concat' version as an exercise. I came up with something which *looks* reasonable to me, but ghci refuses to load, yielding a "cannot construct infinite type" error message which I don't understand. I pasted my code at http://hpaste.org/42655/cannot_construct_infinite_typ - can anybody here maybe shed some light on what's going on?
12:54:41 <c_wraith> djahandarie, that's what it sounded like. :)
12:54:43 <mm_freak> aristid: liftM wouldn't exist in a sane class hierarchy
12:54:54 <djahandarie> @. elite run cake
12:54:55 <aristid> mm_freak: but we need a conversion path
12:54:56 <lambdabot> ["0N3 18.25 oun(e p4(KaG3 c|-|o(Ol4te (4kE /\/\iX.","onE CAN pREP4R3d (Oconu+ P3...
12:55:05 <mm_freak> or it would be defined trivially as:  liftM = fmap
12:55:08 <aristid> mm_freak: we can't destroy the world and start anew :)
12:55:20 <aristid> @src liftM
12:55:20 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:55:24 <c_wraith> frerich, use (x:xs) instead of [(x:xs)] as your pattern match
12:55:43 <c_wraith> frerich, the problem is that you're matching a single-element list that contains another list, instead of the outer list.
12:55:44 <Jesin> so, guys
12:55:52 <Jesin> the solution I was suggesting
12:55:54 <aristid> mm_freak: besides, automatically deriving fmap f m1 = do { x1 <- m1; return (f x1) } would be convenient
12:55:55 <alinabi> @help src
12:55:56 <lambdabot> src <id>. Display the implementation of a standard function
12:56:18 <alinabi> @src foldr
12:56:18 <lambdabot> foldr f z []     = z
12:56:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:56:32 <alinabi> @src runST
12:56:33 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
12:56:34 <Jesin> was to have Monad provide a default fmap implementation, which apparently needs backtracking instance resolution to work?
12:57:04 <alinabi> @src (>>=)
12:57:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:57:14 <alinabi> @src >>=
12:57:15 <lambdabot> Source not found. I am sorry.
12:57:31 <c_wraith> aristid, Functor is mechanical.  You don't need to use the monad implementation.  For any type, there's exactly one correct Functor implementation.  And as of GHC 6.12, GHC can automatically derive what that implementation is.
12:57:39 <mm_freak> aristid: i'd also vote for 'join' being a function of the Monad class
12:57:47 <mm_freak> alongside (>>=)
12:57:58 <c_wraith> :t (>>= id)
12:58:00 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:58:08 <mm_freak> a lot of monads can be defined much easier through fmap + return + join
12:58:52 <aristid> and some can be defined easier through return and bind
12:58:59 <mm_freak> yes
12:59:01 <aristid> also return and bind is what we have now
12:59:11 <aristid> compatibility is non-negotiable :)
12:59:14 <mm_freak> so have both in the class
12:59:24 <Jesin> so do the same thing you do with Num having negate and (-)
12:59:29 <Jesin> and only requiring one to be defined
12:59:31 <Jesin> :p
12:59:38 <mm_freak> exactly
12:59:41 <sipa> can something break by moving join into the Monad class, and providing a default implementation via return and bind?
12:59:54 <Jesin> ooh
12:59:55 <mm_freak> sipa: unlikely
12:59:57 <sipa> the types remain exactly the same
13:00:04 <mm_freak> yeah
13:00:06 <Jesin> did we just find an improvement we can make easily without having to overhaul things?
13:00:08 <Jesin> :p
13:00:11 <Jesin> yaaay
13:00:18 <mm_freak> hehe
13:00:18 <sipa> i think we're far from the first people to think about this
13:00:19 <c_wraith> sipa, the default implementation is just in terms of bind.  :)  (>>= id)
13:00:33 <sipa> c_wraith: i know, now it is a separate function
13:00:34 <Jesin> sipa: yeah, I'm pretty sure I've seen it mentioned elsewhere
13:00:38 <sipa> not one part of the class 
13:00:41 <Jesin> why hasn't it been done yet, though?
13:01:04 <Jesin> @src join
13:01:05 <lambdabot> join x =  x >>= id
13:01:19 <alinabi> @help djinn
13:01:19 <lambdabot> djinn <type>.
13:01:20 <lambdabot> Generates Haskell code from a type.
13:01:20 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
13:01:56 <alinabi> djinn (a -> b -> a) -> a -> [b] -> a
13:01:58 <Jesin> hmm
13:02:12 <Jesin> @djinn (a -> b -> a) -> a -> [b] -> a
13:02:13 <lambdabot> Error: Undefined type []
13:02:13 <c_wraith> alinabi, djinn doesn't do recursive types (like [])
13:02:37 <Jesin> @djinn (a -> b -> a) -> a -> (Maybe b) -> a
13:02:38 <lambdabot> f a b c =
13:02:38 <lambdabot>     case c of
13:02:38 <lambdabot>     Nothing -> b
13:02:38 <lambdabot>     Just d -> a b d
13:02:41 <alinabi> oh, ok. thanks
13:02:55 <mm_freak> @djinn Either e a -> Maybe a
13:02:55 <lambdabot> f a =
13:02:55 <lambdabot>     case a of
13:02:56 <lambdabot>     Left _ -> Nothing
13:02:56 <lambdabot>     Right b -> Just b
13:03:31 <Jesin> hmm
13:03:33 <Jesin> [15:52:08]	<aristid>	mm_freak: to make that work well, it would be necessary to have the methods of Functor and Applicative defined automatically
13:03:36 <Jesin> why can't we do this?
13:04:05 <mm_freak> Jesin: i'm not even understanding /why/ we would need this
13:04:20 <mm_freak> it appears to me that we don't
13:04:31 <Jesin> because it's prettier than requiring copypaste
13:04:40 <Jesin> :p
13:04:46 <mm_freak> why copy/paste?
13:04:50 <mm_freak> there is no redundancy
13:04:55 <Jesin> k
13:05:03 <Jesin> well, for Functor there is...
13:05:06 <Jesin> umm
13:05:11 <mm_freak> no
13:05:39 <Jesin> eh.
13:05:43 <Jesin> I guess what I'm looking for
13:06:08 <Jesin> [15:50:37]	<mm_freak>	i'd rather vote for a saner class hierarchy
13:06:09 <Jesin> [15:51:10]	<mm_freak>	class Functor m => Applicative m; class Applicative m => Monad m
13:06:11 <Jesin> is a way to do that
13:06:18 <Jesin> without breaking stuff if possible
13:06:20 <mm_freak> class Functor m where fmap; class Functor m => Applicative where pure, (<*>); class Applicative m => Monad m where (>>=), join
13:07:07 <mm_freak> it would break stuff, because there are many libraries, which define Monad instances, but not Applicative instances
13:07:23 <aristid> sometimes not even Functor instances
13:07:31 <Jesin> is there an easy fix for this?
13:07:43 <Jesin> umm
13:08:03 <Jesin> you say it would be saner to use "class Applicative m => Monad m"
13:08:43 <Jesin> but, if there are well-behaved Monads that do not trivially also behave like Applicative
13:09:01 <Jesin> then would, for example, "class Functor m => Monad m" make more sense?
13:09:11 <Boxo> :t ap
13:09:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:09:36 <aristid> Jesin: well, i think it should be possible to derive these instances mechanically, but GHC cannot do it
13:09:55 <Jesin> that is, GHC does not currently implement this?
13:09:58 <mm_freak> Jesin: there is a trivial Applicative instance for every monad
13:10:08 <Boxo> @src ap
13:10:08 <lambdabot> ap = liftM2 id
13:10:36 <mm_freak> cf <*> cx = do f <- cf; x <- cx; pure (f x)
13:10:40 <Boxo> that's pretty trivial!
13:13:04 <dpratt71> So I was day-dreaming the other day about being able to have expressions that are of n number of alternate types. Implicit ADTs, you might call them.
13:13:14 <dpratt71> ...here's a sketch of what I was thinking http://hpaste.org/42656/daydream
13:13:17 <dpratt71> is this a sane idea?
13:15:40 <mtnviewmark> dpratt71: sort of syntatic sugar for a normal ADT     data SafeDivReturn = SafeDivReturnFloat Float | SafeDivReturnException Exception
13:16:11 <dpratt71> mtnviewmark: yeah, that was the idea
13:17:14 <mtnviewmark> I imagine the problem would come with generic types... because all the alternatives would have to have distinct types 
13:18:04 <roconnor> dpratt71: sounds like varient types and ocaml has them
13:18:05 <mtnviewmark> so imagine     safeFoo ::  (Eq a) => a -> a ->  Int  |  a
13:18:10 <mtnviewmark> what happens if a is Int
13:18:13 <frerich_> c_wraith: Aaah, yes, of course - stupid that I didn't see this myself. (sorry, my [4 month old] son woke up all of a sudden)
13:18:21 <frerich_> c_wraith: Thanks for shedding some light :-)
13:18:27 <c_wraith> frerich_, no worries. :)
13:18:37 <dpratt71> roconnor: ah, cool
13:19:08 <roconnor> dpratt71: http://caml.inria.fr/pub/docs/u3-ocaml/ocaml051.html
13:19:29 <roconnor> Variants are tagged unions, like ML datatypes. Thus, they allow values of different types to be mixed together in a collection by tagging them with variant labels; the values may be retrieved from the collection by inspecting their tags using pattern matching.
13:19:30 <roconnor> However, unlike datatypes, variants can be used without a preceding type declaration. 
13:19:58 <mtnviewmark> actually...  can we define      type a :|: b = Either a b
13:20:21 <mtnviewmark> then    safeDiv :: Float -> Float -> Float :|: Exception
13:20:24 <Toxaris> mtnviewmark: yes
13:20:36 <mtnviewmark> doesn't help the case side of things....
13:20:38 <dpratt71> roconnor: yeah, that sounds like what I was imagining
13:21:04 <Toxaris> mtnviewmark: but then you need explicit Lefts and Rights both when constructing and destructing terms
13:21:19 <mtnviewmark> understood....
13:21:45 <aristid> sum types *want*
13:21:49 <Toxaris> However, IIRC, HList allows some magic
13:21:54 <Toxaris> (as usual)
13:22:16 * dpratt71 googles 'sum types'
13:22:37 <roconnor> aristid: sum types are untagged?
13:23:14 <aristid> roconnor: depends on the kind, i guess
13:23:29 <roconnor> aristid: does Foo + Foo = Foo?
13:24:03 <aristid> what?
13:24:10 <aristid> roconnor: sum types are like Either
13:24:11 <roconnor> aristid: I guess I want to know how your sum types differ from Either
13:24:19 <dpratt71> he
13:24:20 <dpratt71> h
13:24:52 <aristid> roconnor: i think ML has good sum types, but i'm not sure
13:25:22 <sipa> an ADT with multiple constructors is a sum type
13:25:36 <sipa> each constructor is a product type of its arguments
13:25:49 <Jesin> hmm
13:26:02 <Jesin> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative
13:26:11 <Jesin> this says
13:26:15 <Jesin> "Minimal complete definition: pure and <*>. "
13:26:17 <Jesin> and
13:26:24 <Jesin> "The Functor instance should satisfy
13:26:26 <Jesin>       fmap f x = pure f <*> x"
13:26:44 <Jesin> so, would it then be possible to do this?:
13:27:04 <Jesin> instance Applicative Something [...] (deriving Functor)
13:27:09 <Jesin> err
13:27:11 <Jesin> I meant
13:27:26 <roconnor> Jesin: we all wish you could do that
13:27:44 <monochrom> we wish you a merry christmas
13:27:51 <mtnviewmark> how do sum types (without explicit tags) handle pattern matching when two or more of the summands have the same type? or is that just not allowed?
13:27:55 <Jesin> ...
13:27:58 <Jesin> ok, so why can't we?
13:28:04 <Jesin> this should be trivial, shouldn't it...
13:28:07 <roconnor> but as a consolation you can write instance Functor Foo where fmap f x = pure f <*> x  (or fmap = (<$>) if you are lazy)
13:28:33 <aristid> mtnviewmark: maybe we need tagging, but of a different kind :)
13:28:36 <Toxaris> From the TR on HList, Appendix C: "We [...] arrive at so-called type-indexed sums (or co-products; TICs). A TIC-typed data structure holds a datum of one out of a fixed collection of types. So [...] a TIC typed data structure is [...] just one datum."
13:28:46 <Toxaris> http://homepages.cwi.nl/~ralf/HList/paper.pdf
13:28:57 <aristid> roconnor: (<$>) is defined in terms of Functor
13:29:00 <aristid> :t (<$>)
13:29:00 <Jesin> @src (<$>)
13:29:01 <lambdabot> f <$> a = fmap f a
13:29:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:29:06 <mtnviewmark> if you have tagging then I think what you want is a sort of anonymous, in-line standard ADT:
13:29:09 <monochrom> sum types with same summand types are allowed, e.g., Int+Int is allowed. there is always tagging or equivalent magic to discern "is it the left guy" "is it the right guy"
13:29:34 <mtnviewmark> safeDiv :: Float -> Float ->  Ok Float | Err Exception
13:29:42 <frerich_> How can I create a type which behaves like Int except that only values [1..13] are possible? Something like "data Value = 1 | 2 | 3" (except that digits are not valid constructor names).
13:29:53 <Jesin> so, why *can't* you do (deriving Functor) like that?
13:30:15 <sipa> frerich_: you can create data Value = One | Two | Three, and make it an instance of Num
13:30:32 <sipa> and implement fromInteger for it, so you can use the numbers 1, 2, 3 to refer to them
13:30:40 <ajjjajajjajj> i'd like to browse around some nice haskell code to see how things are done in practice: can you people recommend a project which is nicely documented and easy to get into?
13:30:43 <sipa> however, the question is what to do with 4 :)
13:30:50 <mtnviewmark> data CardRank = RAce | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | RJack | RQueen | RKing    deriving Enum, Eq, Bounded
13:30:58 <mtnviewmark> then provide a Num instance for it
13:31:11 <frerich_> sipa: Yes, I thought of using english names as well, but I didn't think of instantiating Num
13:31:13 <frerich_> hmm
13:31:15 <aristid> mtnviewmark: yeah, i want anonymous tagged ADT stuff
13:31:17 * frerich_ googles for Num...
13:31:26 <mtnviewmark> using fromEnum and toEnum to get back and forth to the actual numerical values
13:31:42 <monochrom> not sure "like Int" refers to "is Num" or "is Enum" or even merely "is Show". the wonder of analogies.
13:31:48 <aristid> exactly this: safeDiv :: Float -> Float ->  Ok Float | Err Exception
13:32:04 <mtnviewmark> aristid: then you end up with the issue that the tags are in the current name space, not scoped to only situations where you are inspecting the return type of that function
13:32:09 <roconnor> aristid: oh right
13:32:17 <frerich_> monochrom: I'm sorry for the imprecision; I meant 'is Enum'
13:33:03 * mtnviewmark was only guessing at the possible domain of frerich_'s question
13:34:00 <frerich_> mtnviewmark: Well it was a fairly educated guess as fas as I can tell :-) The card game analogy is pretty well, I'm trying to write a little game as well (in the game you have chips with values 1..13 and one of four colors. I tried to write a good type for the 1..13 field of a chip)
13:34:18 <MHD0> I have a problem with some OpenGL code, the line "displayCallback $= clear [ColorBuffer]" tells me that "SettableStateVar" is not an instance of "HasSetter"
13:35:20 <mtnviewmark> frerich_: if there were more values, then I'd probably do    data CardRank = Rank Int 
13:36:02 <mtnviewmark> and then not export Rank from the module --- and make it an instance of Enum and Bounded by hand
13:36:18 <mtnviewmark> but 13 is pretty on cusp for me.... 
13:36:21 <frerich_> mtnviewmark: I did that in the beginning (in fact I just did data Chip = Joker | Chip Int Int), but since this is my first real Haskell program I try to play with creating types while I'm at it :-)
13:43:24 <MHD0> I have a problem with some OpenGL code, the line "displayCallback $= clear [ColorBuffer]" tells me that "SettableStateVar" is not an instance of "HasSetter"
13:45:00 <ManateeLazyCat> mtnviewmark: Well, framework like this : http://www.flickr.com/photos/48809572@N02/5304662424/lightbox/
13:46:15 <ManateeLazyCat> monochrom: http://www.flickr.com/photos/48809572@N02/5304662424/lightbox/ looks this. :)
13:46:42 <mtnviewmark> so for each sub-system, there is a TVar that points at the running version of the code - but 
13:46:59 <mtnviewmark> you're using the TVar to sync. between the compile server and the system, right?
13:47:18 <mtnviewmark> how does the Application deal with migration of data? or is there none?
13:47:23 <ManateeLazyCat> mtnviewmark: Not sync, use for cache.
13:50:51 <ManateeLazyCat> mtnviewmark: Framework is fully asynchronous, application and compile server don't care each other.
13:51:31 <mtnviewmark> What is in the TVar? a Module descriptor? or an actual value?
13:51:50 <roconnor> ddarius: are you the one who told me about Jaynes' paper on 300% efficent furnances and free ovens for eskimos?
13:51:56 <ManateeLazyCat> mtnviewmark: Do you know STM?
13:52:03 <ManateeLazyCat> @hoogle TVar
13:52:04 <lambdabot> module Control.Concurrent.STM.TVar
13:52:04 <lambdabot> Network.CGI getVar :: MonadCGI m => String -> m (Maybe String)
13:52:04 <lambdabot> Network.CGI getVars :: MonadCGI m => m [(String, String)]
13:52:15 <ManateeLazyCat> mtnviewmark: Control.Concurrent.STM.TVar
13:52:28 <mtnviewmark> no - not really - 
13:52:55 <mtnviewmark> but I get the general idea of STM
13:53:04 <mtnviewmark> still - what is the type wrapped in those TVar's?
13:53:05 <ManateeLazyCat> mtnviewmark: STM is Software Transactional Memory
13:53:06 <mtnviewmark> what is a
13:53:13 <ManateeLazyCat> mtnviewmark: Any type.
13:54:32 <mtnviewmark> the configuration causes you to compile code, and then you get modules - what do you run in the modules to get the value that the compiler puts in the TVar?
13:54:45 <mtnviewmark> manateeMain?
13:54:47 <tonkman> how can I set color code in windows command line?
13:55:05 <tonkman> when putStrLn "\e" wont work
13:55:15 <dpratt71> mtnviewmark: I've been pondering the problem you presented with the 'implicit ADTs' idea...
13:55:20 <dpratt71> I'm tempted to think that maybe it doesn't matter.
13:55:34 <dpratt71> I'm thinking of "(Eq a) => a -> a ->  Int  |  a" less as specifying two alernates, and more of a union specifying the set of types that the expression can be.
13:55:49 <dpratt71> In the case that you pattern match on (::Eq a => a) before (::Int), that'd probably be a warning similar to overlapping patterns.
13:55:52 <mtnviewmark> dpratt71 - how would you pattern match in the case?
13:56:07 <ManateeLazyCat> mtnviewmark: I use GHC-API, use GHC.compileExr to get HValue in runtime, then convert HValue to TVar 
13:56:40 <ManateeLazyCat> mtnviewmark: https://patch-tag.com/r/AndyStewart/manatee-core/snapshot/current/content/pretty/Manatee/Core/Dynload.hs
13:57:21 <mtnviewmark> dpratt71: I don't think that that would be resolvable... but I'm not a type inference guy...
13:58:33 <dpratt71> mtnviewmark: that makes two of us :) (not being type inference guys)
13:59:44 <parcs> tonkman: look at the ansi-terminal package in hackage
13:59:52 <parcs> oh wait, windows
13:59:59 <zygoloid> dpratt71: you might be interested in some of this discussion: http://lambda-the-ultimate.org/node/1814
14:00:28 <tonkman> parcs: well, linux is fine too
14:00:48 <tonkman> I'll take a look at ansi-terminal package
14:01:07 <mtnviewmark> but, in the end, I think that if you want to express that the result (or argument for that matter) can be of two different types - it is the distinction "these" vs. "those" that is important, not that the types are themselves distinct. Hence, in general, you need a way to indicate during pattern matching "these" vs. "those" ---- and in light of type genericity, I think this problem becomes acute.
14:01:08 <dpratt71> zygoloid: reading, thanks
14:01:59 <mtnviewmark> I imagine that the real motivation you were after was conciseness, and the need to have an "ad hoc" or "single use" type on demand
14:02:33 <mtnviewmark> this I wish for too --- but to solve it would require some serious scoping rule issues that I think have been shown to poorly interact with type inference
14:03:18 <dpratt71> mtnviewmark: my real motivation was for someone to tell me "the idea is unworkable for reason x", which would allow me to stop thinking about it :)
14:03:21 <mtnviewmark> thanks for the pointer, zygoloid
14:03:43 <mtnviewmark> the "Does not mix with polymorphism" comment in that post is exactly what I was getting at
14:04:25 <mtnviewmark> and the "What is a hack?" response seems to be academic - because I can't imagine a real use of such a type where that solution would be meaningful
14:05:42 <mtnviewmark> "Hacks, IMO" is exactly my thoughts here
14:08:15 <ManateeLazyCat> I wonder how many people don't know "Owl City" ? ;p
14:09:15 <dpratt71> thanks for the feedback mtnviewmark, et al; alas I have to run away
14:09:34 <mtnviewmark> laters
14:10:00 <spetrea_> good news, I'm back
14:28:44 <ManateeLazyCat> Hi guys, what's favourites IDE feature do you want? Tell me, i help you implement it. :)
14:29:00 <frerich_> For a simple type "data Color = Red | Green | Blue", what typeclass do I have to instantiate in order to be able to say [Red..Blue] ?
14:29:09 <dibblego> frerich, Enum
14:29:11 <ManateeLazyCat> I will do "code completion", "code snippets", and "real-time check"
14:29:20 <proq> ManateeLazyCat: for what IDE?
14:29:30 <dibblego> ManateeLazyCat, rename, hover on an expression anywhere and see its type
14:29:56 <ManateeLazyCat> dibblego: Ok, thanks for suggestion, i have record it.
14:30:18 <ManateeLazyCat> proq: http://goo.gl/MkVw
14:30:34 <ManateeLazyCat> proq: This have a video : http://www.youtube.com/watch?v=weS6zys3U8k
14:30:45 <frerich_> dibblego: Hm, thanks. Can the compiler instantiate the class automatically if it sees all the possible value constructors (e.g. to I have to do anything else than "data Color = Red | Green | Blue deriving(Enum)"
14:31:12 <frerich_> I thought it could, but now I'm not sure anymore since doing that won't make [Red..Blue] work :-}
14:31:20 <dibblego> frerich, deriving Enum will do
14:32:53 <frerich_> Ah
14:32:53 <ManateeLazyCat> jutaro: Are you there?
14:33:32 <frerich_> dibblego: It turned out that I have to say "[Red .. Blue]" instead of [Red..Blue] since otherwise the "Red.." is taken as one token (or so it seems).
14:33:45 <dibblego> frerich, ah yes indeed
14:34:27 <frerich_> dibblego: Do you know why that is? I just wondered whether maybe the dot is a valid character in an identifier... but apparently it's not.
14:34:40 <dibblego> frerich, yeah it's valie
14:34:42 <dibblego> *vaid
14:34:45 <dibblego> valid
14:34:58 <frerich_> Really? I just tried 'let x..y = 3' in ghci but that didn't work.
14:35:06 <benmachine> frerich_: qualified name
14:35:15 <benmachine> :t id Prelude.. id
14:35:16 <lambdabot> forall a. a -> a
14:35:25 <ManateeLazyCat> @time
14:35:26 <lambdabot> Local time for ManateeLazyCat is Thu Dec 30 06:34:43 2010
14:35:32 <frerich_> benmachine: Ah!
14:35:35 <ManateeLazyCat> It's need sleep, bye all. :)
14:35:38 <benmachine> the terribly confusing syntax for explictly qualifying operators
14:35:49 <frerich_> benmachine: I wasn't aware of this feature, thanks!
14:36:16 <benmachine> np
14:36:51 <frerich_> benmachine: I guess it makes sense if you're aware of it, but I wish any of the tutorials I looked at would have mentioned it :)
14:37:06 <benmachine> it's quite niche
14:37:13 <benmachine> most people don't use operators qualified
14:37:28 <benmachine> and many people think that the syntax for them is ugly and should be changed
14:38:52 <Eduard_Munteanu> o/
14:39:53 <frerich_> I see; I'm looking at http://www.haskell.org/haskellwiki/Type and a bit further down the page it created a type 'data Suit = Club | Diamond | Heart | Spade deriving (Read, Show, Enum, Eq, Ord)'. Later, it did "deck = [Card val su | val <- [Two .. Ace], su <- [Club .. Spade]]".
14:40:08 <frerich_> I tried to reproduce that myself, but got the problem I mentioned. Turned out those spaces are significant!
14:40:27 <frerich_> (they weren't in all the other caese where I dud [1..5] or so, but now I see why)
14:42:02 <frerich_> In fact, I only noticed something is fishy because vim highlighted 'Red..' differently than 'Red ..' :-)
14:43:18 <dibblego> sorry mate, I knew that, I thought you did too
14:43:30 <dibblego> I thought you were asking about Enum
14:44:13 <frerich_> dibblego: Ah, no problem. I'm just getting started with Haskell (this is my longest Haskell  program so far and it's a mere 16 lines long...) :-]
14:44:14 <BMeph> That is an interesting flaw in Haskell, using capitals to signify both types and (type and value) constructors.
14:45:04 <BMeph> Well, that, _and_ module names. That's a lot of work for one syntactic element.
15:01:08 <Eduard_Munteanu> I don't particularly like the capitalization rules Haskell imposes onto the programmer.
15:01:42 <Jesin> well
15:01:56 <benmachine> I do
15:01:57 <Adamant> I don't like them in theory, they aren't particularly annoying in practice
15:01:57 <Jesin> the complier actually makes inferences based on capitalization
15:02:16 <Jesin> I think...
15:02:23 <acowley> Eduard_Munteanu: The only time they bug me is with constants like mAX_ELEMENTS
15:03:04 <Jesin> ...
15:03:10 <Jesin> wooow.
15:03:13 <Jesin> XD
15:03:17 <mreh> is there an extension for specifying a deriving clause with multiparameter types
15:03:43 <mreh> such as deriving(Monad (StateList s))
15:04:13 <mreh> StateList is a newtype transformer stack, so I tried GeneralisedNewtypeDeriving
15:04:36 <benmachine> mreh: where would you expect to put such a clause?
15:04:53 <mreh> benmachine: immediately after the newtype definition
15:05:10 <mreh> Can't make a derived instance of `Monad (StateList s) (StateList s)'
15:07:22 <roconnor> mreh: tell me more about StateList.  I discovered a monad like that
15:07:28 <roconnor> mreh: but I have no applications
15:07:47 <benmachine> mreh: the syntax is deriving (Monad)
15:07:57 <mreh> roconnor: it's a StateList s a = StateT s [] a
15:08:30 <roconnor> so the result in in the list rather than the states being in a list
15:08:33 <megajosh2> Hey has anybody successfully gotten their code to load Haskell modules dynamically? Every try I made, I get an error concerning unresolved symbols
15:08:39 <roconnor> sort of
15:08:41 <megajosh2> *got
15:09:04 <mreh> the monad is s -> [(s, a)] without the cruft
15:09:16 <FireSnake> anyone here use pdf2line?
15:09:17 <mreh> nondeterministic computations with state
15:09:31 <roconnor> ah
15:09:47 <roconnor> my monad is more like [s] -> ([s],a) though not quite
15:09:52 <FireSnake> the haskell library for extracting pdf -- thin wrapper to xpdf?
15:10:03 <roconnor> mreh: nevermind then
15:10:27 <FireSnake> mine freezes my computer
15:10:38 <FireSnake> I'm on Ubuntu
15:12:19 <mreh> @kind MonadState
15:12:21 <lambdabot>     Class `MonadState' used as a type
15:12:21 <lambdabot>     In the type `MonadState'
15:12:29 <Random75> Can somebody explain why myLast [x] = x returns the last element of a list?
15:12:56 <benmachine> Random75: it doesn't, it returns the only element of a single-element list
15:12:56 <mreh> x is the last element in [x]
15:13:07 <mreh> it also happens to be the first
15:13:10 <benmachine> Random75: I expect there is another clause to tell you what to do when the list isn't single-element
15:13:11 <monochrom> hehe
15:13:27 <parcs> Random75: [x] can be written as (x:[]), if that helps
15:13:36 <mreh> now I have to derive MonadState!
15:13:45 <Random75> benmachine: That function works with non-singleton lists? Unless I forgot to recompile.
15:14:21 <benmachine> Random75: like I said, that's probably not the entire definition of the function
15:14:25 * hackagebot parallel-io 0.3.1 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.3.1 (MaxBolingbroke)
15:14:41 <Random75> Ok, I forgot to save the file. Thanks all :)
15:16:18 <mreh> deriving(MonadState s (StateList s)) would seem sensible to me, but it is not accepted
15:16:49 <mreh> how else would the fun dep be resolved?
15:17:48 <mreh> how would the s be bound to the same s in my StateList?
15:18:31 <benmachine> mreh: newtype N = N T deriving (C) for some class C results in instance C N
15:19:31 <benmachine> mreh: i.e. the instance is of the class applied to the newtype being defined
15:19:34 <mreh> is that why we have all the fun dep faff?
15:19:48 <mreh> right, so they all must be arity one
15:19:55 <benmachine> so deriving Monad -> instance Monad N, deriving (MonadState s) -> instance MonadState N
15:20:04 <benmachine> modulo kinds
15:20:33 <mreh> instance MonadState s N?
15:20:43 <benmachine> uh yes
15:20:48 <mreh> phew
15:23:32 <aristid> does it actually work?
15:25:33 <mreh> deriving (MonadState s)? yes
15:25:41 <mreh> it typechecks
15:26:05 <mreh> having difficulty with MonadTrans now, just reading the language report
15:29:48 <mreh> Class `MonadTrans' expects an argument of kind `(* -> *) -> * -> *'
15:29:52 <mreh> that seems nutty to me
15:31:34 <mreh> maybe my expectations are too high
15:33:59 <aristid> mreh: MonadTrans wants something that looks like a transformer
15:34:26 <aristid> a transformer looks like T m a, where m has kind (* -> *) and a has kind *, giving (* -> *) -> * -> *
15:34:54 <aristid> such a T allows instance MonadTrans T
15:35:09 <aristid> mreh: there's nothing nutty about that.
15:37:35 <mreh> so I wish to create a lift for my own stack, which lifts the inner monad to a the same type as the whole stack
15:38:00 <mreh> how could I use the definition of MonadTrans of StateT then?
15:38:17 <mreh> and stay generalised
15:38:30 <mreh> i.e. still using the MonadTrans class
15:38:58 <mm_freak> mreh: you want to lift a base monad computation?
15:39:15 <mm_freak> or some computation, which is arbitrarily deep in the stack, without knowing the depth?
15:39:18 <mreh> yeah, but my trans is wrapped up in the newtype
15:39:45 <mm_freak> if it's just wrapped, you can use GeneralizedNewtypeDeriving
15:40:10 <aristid> mreh: instance MonadTrans (StateT s)
15:40:34 <mm_freak> the following rather applies to really new transformers:  MonadIO is probably close to what you want…  the monadLib and contstuff libraries generalize this to arbitrary base monads as well as arbitrary deep non-base monads
15:40:52 <mm_freak> like:  if you have a StateT somewhere in your stack, you can just use 'get' without lifting
15:41:27 <aristid> mm_freak: mtl gives you the same (not the arbitrary base, but the get anywhere)
15:41:40 * lowh sniffs the air
15:41:53 <mm_freak> aristid: huh?
15:42:06 <aristid> :t get
15:42:07 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
15:42:18 <aristid> there you have it, probably straight from mtl
15:43:08 <mm_freak> indeed, mtl gives you that
15:43:43 <mm_freak> but it has this broken ListT and generally not much functionality…  i don't like it
15:43:59 <mreh> I'm just confusing myself
15:44:20 <mreh> I'm not trying to make a monad transformer, i'm trying to use a monad transformer wrapped up in a newtype
15:44:31 <mreh> so I need to define all the lifts myself
15:44:39 <quvr> would it be possible to use f^n x for f(f(...f(f x))) nested n times? like D^2(f x) is used to denote the derivative of the derivative of f of x. just thought that'd be cool as the syntax i so mathlike =)
15:44:59 <aristid> mm_freak: i don't use ListT, so i have no problem with that, and now with the monads-fd+mtl unification, that mess is also largely resolved
15:45:01 <mm_freak> mreh: no, use GeneralizedNewtypeDeriving
15:45:31 <conal> quvr: yes possible, with some gotchas.
15:45:35 <aristid> mreh: if your newtype does not look and behave like a transformer, no MonadTrans instance for you :)
15:45:36 <Boxo> @define f .^ n = foldr (.) id (replicate n f)
15:45:41 <mreh> you can't derive MonadTRans
15:45:41 <mm_freak> mreh: then you can say:  newtype MyMonadT m a = MyMonadT (StateT MyState m a) deriving MonadTrans
15:45:48 <aristid> :t (.^)
15:45:49 <lambdabot> Not in scope: `.^'
15:45:55 <mreh> for something that isn't a transformer*
15:45:56 <mm_freak> uhm
15:46:02 <mm_freak> i see
15:46:09 <mm_freak> so it's not just a StateT
15:46:11 <Jesin> why .^
15:46:23 <Jesin> hmm
15:46:24 <mreh> no, it's state is bound to some s
15:46:27 <mreh> its*
15:46:36 <quvr> conal: hm, interesting. can I read more about this somewhere?
15:46:38 <Boxo> define doesn't work?
15:46:42 <mm_freak> mreh: yeah, no problem with that
15:46:47 <Jesin> I guess I'm used to other languages where .^ is like a mapped version of ^
15:46:48 <mreh> and its m is bound to some monad :)
15:47:09 <mm_freak> mreh: then it's not a monad transformer anyway
15:47:13 <mm_freak> it's simply a monad
15:47:16 <benmachine> 23:09:20 < roconnor> my monad is more like [s] -> ([s],a) though not quite
15:47:18 <mreh> yeah, I was confused
15:47:20 <conal> quvr: i doubt it. but you can ask around here.
15:47:21 <aristid> mreh: is m a transformer itself?
15:47:35 <Boxo> > let f .^ n = foldr (.) id (replicate n f) in (*2) ^. 10 $ 1
15:47:36 <mm_freak> aristid: kind mismatch =)
15:47:36 <lambdabot>   Not in scope: `^.'
15:47:38 <conal> quvr: Boxo's def looks right to me.
15:47:43 <Boxo> > let f .^ n = foldr (.) id (replicate n f) in (*2) .^ 10 $ 1
15:47:44 <benmachine> roconnor: I'm vaguely interested in this, what is it?
15:47:45 <lambdabot>   1024
15:47:45 <mreh> [s] -> ([s], a) is a state monad
15:47:48 <aristid> mm_freak: i mean an applied transformer :P
15:48:05 <mm_freak> ok =)
15:48:05 <benmachine> mreh: I know, I guess I'm interested in the 'not quite'
15:48:08 <mreh> it can be a state monad...
15:48:29 <roconnor> benmachine: I'm calling it the cartesian state monad.  It's type is actually isomorphic to forall n:Nat. s^n -> (s^n, a)
15:48:32 <mreh> benmachine: :) yeah, I just thought that myself
15:48:32 <aristid> mreh: then MonadState should be good enough as an interface, right?
15:48:34 <quvr> conal: Boxo: oh I missed that in the blurr. thanks ill try that =)
15:48:37 <mm_freak> mreh: your solution is something like this:  liftMyMonad c = MyMonad $ …
15:48:46 <conal> :)
15:49:02 <mreh> mm_freak: yeah, I've just got there myself :)
15:49:07 <mreh> thanks for the help though
15:49:11 <Boxo> @let f .^ n = foldr (.) id (replicate n f)
15:49:12 <lambdabot>  Defined.
15:49:20 <mm_freak> you're welcome =)
15:49:21 <mreh> just laziness on my part I think all this confusion
15:49:23 <Boxo> > (*2) .^ 10 $ 1
15:49:25 <lambdabot>   1024
15:49:27 <Boxo> ah
15:50:12 <roconnor> foldr (.) id l x = foldr ($) x l  I think
15:50:29 <Jesin> umm
15:50:32 <Jesin> ($) = id
15:50:37 <parcs> > let f .^ n = \x -> iterate f x ! n in (+1) ^. 10 $ 0
15:50:37 <lambdabot>   Not in scope: `^.'
15:50:39 <roconnor> sure
15:50:42 <Jesin> just a type-restricted version of it
15:50:44 <benmachine> roconnor: is that different from forall n. State s^n a
15:50:48 <parcs> > let f ^. n = \x -> iterate f x ! n in (+1) ^. 10 $ 0
15:50:49 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
15:50:49 <lambdabot>         against inferred t...
15:51:00 <parcs> meh. you get th eidea
15:51:09 <roconnor> benmachine: no.
15:51:19 <benmachine> oh right
15:51:20 <benmachine> k
15:53:03 <Jesin> > let f .^ n x = foldr id x (replicate n f) in (*2) .^ 10 $ 1
15:53:03 <lambdabot>   <no location info>: Parse error in pattern
15:54:00 <opqdonut_> > let (f .^ n) x = foldr id x (replicate n f) in (*2) .^ 10 $ 1
15:54:01 <lambdabot>   1024
15:54:02 <Jesin> ooh, iterate
15:54:24 <Jesin> hmm
15:54:25 <opqdonut_> fix'd the syntax for you
15:54:55 <Jesin> > iterate (2*) 1
15:54:56 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:55:06 <Jesin> thanks opqdonut_
15:55:39 <dmhouse> > 2 ^ 10
15:55:40 <lambdabot>   1024
15:55:44 * dmhouse wins
15:57:05 <Jesin> yes, I know  :p
15:57:33 <Jesin> @pl (f .^ n) x = foldr id x (replicate n f)
15:57:33 <lambdabot> (line 1, column 12):
15:57:34 <lambdabot> unexpected "="
15:57:34 <lambdabot> expecting variable, "(", operator or end of input
15:57:45 <Jesin> @pl (.^) f n x = foldr id x (replicate n f)
15:57:45 <lambdabot> (line 1, column 12):
15:57:46 <lambdabot> unexpected "="
15:57:46 <lambdabot> expecting variable, "(", operator or end of input
15:58:11 <Jesin> @pl ncompos f n x = foldr id x (replicate n f)
15:58:11 <lambdabot> ncompos = (flip (foldr id) .) . flip replicate
15:58:40 <Jesin> @unpl (flip (foldr id) .) . flip replicate
15:58:40 <lambdabot> (\ k n c -> foldr (\ d -> d) c (replicate n k))
15:59:08 <Jesin> @pl ncompos f n x = foldr ($) x (replicate n f)
15:59:08 <lambdabot> ncompos = (flip (foldr id) .) . flip replicate
15:59:40 <parcs> > (*2) ^. 0 $ 10
15:59:40 <lambdabot>   Not in scope: `^.'
16:00:22 <Jesin> > (*2) .^ 0 $ 10
16:00:24 <lambdabot>   10
16:00:33 <Boxo> > (\f n x -> foldr id x (replicate n f)) (*2) 10 1
16:00:34 <lambdabot>   1024
16:00:52 <Jesin> @define (f .^ n) x = foldr id x (replicate n f)
16:01:15 <Jesin> (did it listen to me?  Or do you need special permissions for that?)
16:01:22 <Boxo> it's @let
16:01:34 <Jesin> @let (f .^ n) x = foldr id x (replicate n f)
16:01:35 <lambdabot>  Defined.
16:01:38 <Jesin> yaay
16:01:44 <Jesin> :t (.^)
16:01:45 <lambdabot> forall b. (b -> b) -> Int -> b -> b
16:01:58 <Jesin> :t genericReplicate
16:01:59 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
16:02:08 <Jesin> @let (f .^ n) x = foldr id x (genericReplicate n f)
16:02:08 <lambdabot>  <local>:1:0:
16:02:09 <lambdabot>      Warning: Pattern match(es) are overlapped
16:02:09 <lambdabot>               In...
16:02:21 <Jesin> @list
16:02:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:02:43 <Jesin> @undefine (.^)
16:03:02 <Jesin> did it work?
16:03:06 <Jesin> :t (.^)
16:03:07 <lambdabot> Not in scope: `.^'
16:03:10 <Jesin> good
16:03:13 <Jesin> @let (f .^ n) x = foldr id x (genericReplicate n f)
16:03:14 <lambdabot>  Defined.
16:03:17 <Jesin> :t (.^)
16:03:18 <lambdabot> forall b i. (Integral i) => (b -> b) -> i -> b -> b
16:03:28 <Jesin> yaaay
16:04:52 <Jesin> :t \x y -> (x *) .^ y $ 1
16:04:53 <lambdabot> forall a i. (Num a, Integral i) => a -> i -> a
16:04:59 <Jesin> :t (^)
16:05:00 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:05:12 <parcs> :t (!) .: iterate
16:05:12 <lambdabot>     Couldn't match expected type `Array i e'
16:05:13 <lambdabot>            against inferred type `[a]'
16:05:13 <lambdabot>       Expected type: (a -> a) -> a -> Array i e
16:05:16 <parcs> :t (!!) .: iterate
16:05:17 <lambdabot> forall a. (a -> a) -> a -> Int -> a
16:05:25 <Jesin> :t (.:)
16:05:26 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:05:55 <Boxo> :t (..:)
16:05:56 <lambdabot> Not in scope: `..:'
16:05:58 <Boxo> :t (.::)
16:05:59 <lambdabot> Not in scope: `.::'
16:06:19 <parcs> man, why is the index operator !! instead of ! ?
16:06:25 <Jesin> :t genericIndex
16:06:26 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
16:06:37 <Boxo> @let f (.::) x = (fmap.fmap.fmap) f x
16:06:38 <lambdabot>  <local>:2:29:
16:06:38 <lambdabot>      Ambiguous occurrence `f'
16:06:38 <lambdabot>      It could refer to either `L...
16:07:18 <Jesin> @let f .:: x = (fmap . fmap . fmap) f x
16:07:19 <lambdabot>  Defined.
16:07:25 <Jesin> is that what you meant?
16:07:27 <Jesin> :p
16:07:27 <Boxo> ya
16:07:29 <Boxo> in fact
16:07:31 <Jesin> @src (.:)
16:07:31 <lambdabot> Source not found. Where did you learn to type?
16:07:33 <Jesin> @src (.::)
16:07:34 <lambdabot> Source not found. There are some things that I just don't know.
16:07:35 <Boxo> @let (.::) = fmap.fmap.fmap
16:07:36 <lambdabot>  <local>:2:0:
16:07:36 <lambdabot>      Equations for `.::' have different numbers of arguments
16:07:36 <lambdabot>   ...
16:07:36 <BMeph> parcs: ! _is_ the index operator, just for Arrays. ;)
16:07:44 <Boxo> damn
16:07:47 <Jesin> @undefine (.::)
16:07:55 <parcs> BMeph: yes, exactly. why the inconistency?
16:07:57 <Jesin> @let (.::) = fmap . fmap . fmap
16:07:58 <lambdabot>  Defined.
16:08:12 <mauke> parcs: you mean, why do different functions have different names?
16:08:15 <Boxo> :t (odd .::)
16:08:16 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Integral a, Functor f, Functor f1, Functor f2) => f (f1 (f2 a)) -> f (f1 (f2 Bool))
16:08:48 <Jesin> @let ($) = id
16:08:49 <lambdabot>  .L.hs:92:17:
16:08:49 <lambdabot>      Ambiguous occurrence `$'
16:08:49 <lambdabot>      It could refer to either `L....
16:08:52 <Jesin> hmm
16:08:53 <parcs> mauke: yeah, like Prelude.map and Data.Map.map ;)
16:09:20 <Jesin> I'm not going to undefine $ because I don't want to nuke the precedence rule
16:09:39 <Boxo> can you even
16:09:43 <Boxo> @undefine map
16:09:45 <BMeph> parcs: Because conceptually, while lists are a kind of sequence, they are different from Arrays (or Maps/Sequences). :)
16:09:47 <Boxo> :t map
16:09:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:09:58 <Jesin> :t map
16:09:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:10:01 <Jesin> hm.
16:10:05 <Jesin> @undefine ($)
16:10:10 <Jesin> :t ($)
16:10:11 <lambdabot> forall a b. (a -> b) -> a -> b
16:10:16 <mauke>  @undefine doesn't take arguments
16:10:23 <c_wraith> you can only undefine stuff that's been added through @let, also
16:10:24 <parcs> BMeph: they are, but both ! and !! perform very similar things
16:10:35 <Jesin> :t (.)
16:10:36 <Boxo> @undefine
16:10:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:10:43 <Boxo> :t (.^)
16:10:43 <lambdabot> Not in scope: `.^'
16:11:24 <BMeph> Jesin: Unless the 'bot has changed recently, all of the (user-added) definitions get wiped when you do "@ undefine"
16:11:47 <BMeph> parcs: They do similar things, but in dissimilar ways. :)
16:11:49 <Jesin> Functors should be better integrated into the language, there should be nothing called "fmap", the Functor method should be called "map", and the instance Functor [] should just define its map nicely
16:12:01 <Jesin> aww.
16:12:04 <Jesin> =/
16:12:51 <Jesin> @let (f .^ n) x = foldr id x (replicate n f)
16:12:52 <lambdabot>  Defined.
16:13:02 <Jesin> @let (.::) = fmap .^ 3
16:13:03 <lambdabot>  <local>:2:8:
16:13:03 <lambdabot>      Occurs check: cannot construct the infinite type: a = f a
16:13:03 <lambdabot> ...
16:13:09 <Jesin> :t (.^)
16:13:10 <lambdabot> forall b. (b -> b) -> Int -> b -> b
16:13:10 <roconnor> @type map
16:13:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:13:17 <Jesin> @undefine
16:13:38 <Jesin> @let (f .^ n) x = foldr id x (genericReplicate n f)
16:13:39 <lambdabot>  Defined.
16:13:45 <Jesin> :t (.^)
16:13:46 <lambdabot> forall b i. (Integral i) => (b -> b) -> i -> b -> b
16:13:50 <BMeph> Jesin: Shouldn't that be "@let f .^ n = foldr (.) id (replicate n f)" ;)
16:13:50 <Boxo> fmap is (a -> f b), but that thing wants a (b -> b)
16:14:04 <Boxo> so the occurs check makes sense
16:14:44 <Jesin> @undefine
16:14:50 <Jesin> :t let f .^ n = foldr (.) id (replicate n f) in (.^)
16:14:51 <lambdabot> forall b. (b -> b) -> Int -> b -> b
16:15:06 <Jesin> :t let f .^ n = foldr (.) id (genericReplicate n f) in (.^)
16:15:06 <lambdabot> forall b i. (Integral i) => (b -> b) -> i -> b -> b
16:15:21 <Jesin> :t let (f .^ n) x = foldr id x (genericReplicate n f) in (.^)
16:15:22 <lambdabot> forall b i. (Integral i) => (b -> b) -> i -> b -> b
16:15:37 <BMeph> > ((*2) .^ 4) 3
16:15:38 <lambdabot>   Not in scope: `.^'
16:15:44 <Jesin> @let (f .^ n) x = foldr id x (genericReplicate n f) in (.^)
16:15:44 <lambdabot>   Parse error: in
16:15:48 <Jesin> @let (f .^ n) x = foldr id x (genericReplicate n f)
16:15:48 <lambdabot>  Defined.
16:15:59 <BMeph> > ((*2) .^ 4) 3
16:16:00 <Jesin> ((*2).^4)3
16:16:02 <lambdabot>   48
16:16:15 <Jesin> > ((*2) .^ 0) 3
16:16:16 <lambdabot>   3
16:16:24 <Jesin> :t ((*2) .^ 0)
16:16:25 <lambdabot> forall a. (Num a) => a -> a
16:16:31 <Jesin> :t (*2) .^ 4
16:16:31 <lambdabot> forall a. (Num a) => a -> a
16:16:42 <Jesin> :t (.^)
16:16:43 <lambdabot> forall b i. (Integral i) => (b -> b) -> i -> b -> b
16:17:01 <Boxo> :t (.^ 3)
16:17:02 <lambdabot> forall b. (b -> b) -> b -> b
16:17:05 <Boxo> :t fmap
16:17:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:17:19 <Jesin> @pl let f .^ n = foldr (.) id (genericReplicate n f) in (.^)
16:17:19 <lambdabot> (line 1, column 7):
16:17:19 <lambdabot> unexpected "."
16:17:19 <lambdabot> expecting pattern or "="
16:17:24 <BMeph> Ah, applicative, vs. catenative.
16:17:42 <Jesin> @pl let ncompos f n = foldr (.) id (genericReplicate n f) in ncompos
16:17:42 <lambdabot> (foldr (.) id .) . flip genericReplicate
16:18:08 <Jesin> BMeph: sorry, what?
16:18:43 <BMeph> Jesin: "f (f x)" vs. "(f . f) x"
16:18:51 <Jesin> hmm, yes
16:19:05 <Jesin> I wonder if either is more efficient, depending on implementation?
16:19:20 <BMeph> Jesin: (describing our respective means of making that function.
16:19:24 <BMeph> )
16:19:42 <ion> I wouldn’t expect there to be any runtime difference.
16:19:44 <Jesin> (actually, the way I did it wasn't my idea, I grabbed it off somebody else a while back)
16:20:12 <Jesin> what about space efficiency, or performance in cases where strict evaluation is used?
16:20:39 <Jesin> I don't know how curried functions are actually stored in memory...
16:21:08 <c_wraith> They're converted into fully saturated lambdas
16:21:32 <c_wraith> if you look up STG Machine, that's the basic approach used by GHC.
16:21:38 <c_wraith> It has lots of implementation details
16:21:49 <c_wraith> Though GHC has tweaked a lot of them
16:22:32 <mtnviewmark> Jesin - a curried function is basically stored as a pointer to the n-ary function code, and a vector of the m saturated (already applied) values
16:24:33 <Jesin> k
16:24:46 <Jesin> what does that result in for composition, though?
16:24:47 * BMeph likes "(f .^ n) x = (head . drop n . iterate f) x", himself.
16:25:29 <Boxo> head . drop n = (!!n)
16:25:38 <Jesin> in that case
16:25:42 <Jesin> you don't need the x
16:25:53 <BMeph> Jesin: Exactly. ;)
16:26:06 <Jesin> :t let f .^ n = head . drop n . iterate f in (.^)
16:26:07 <lambdabot> forall a. (a -> a) -> Int -> a -> a
16:26:11 <Jesin> :t (.^)
16:26:11 <lambdabot> forall b i. (Integral i) => (b -> b) -> i -> b -> b
16:26:15 <Boxo> I'm paranoid that the iterate makes it inefficient. Does it?
16:26:42 <roconnor> I worry too
16:26:56 <Jesin> umm
16:26:58 <Jesin> waiiit
16:27:00 <Jesin> drop n?
16:27:04 <Jesin> hmm.
16:27:20 <Jesin> I don't think it would...
16:27:21 <Jesin> though
16:27:29 <BMeph> Boxo: Be paranoid that the lazy-by-default nature of Haskell makes it inefficient. It makes it a snap to express coherently, though, doesn't it? ;)
16:27:31 <Jesin> it might need to store a list of lenght n
16:27:33 <Jesin> *length
16:27:50 <Jesin> @src iterate
16:27:50 <lambdabot> iterate f x =  x : iterate f (f x)
16:28:14 <Jesin> hmm
16:28:17 <Jesin> looks like it wouldn't...
16:28:28 <Jesin> or at least, looks like it wouldn't if the replicate wouldn't be a problem
16:28:32 <Jesin> @src replicate
16:28:32 <lambdabot> replicate n x = take n (repeat x)
16:28:38 <Jesin> @src genericReplicate
16:28:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:28:46 <Jesin> @src take
16:28:46 <lambdabot> take n _      | n <= 0 =  []
16:28:46 <lambdabot> take _ []              =  []
16:28:46 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:28:48 <Jesin> @src drop
16:28:48 <lambdabot> drop n xs     | n <= 0 =  xs
16:28:48 <lambdabot> drop _ []              =  []
16:28:49 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
16:29:02 <BMeph> :t let f .^ n = genericIndex n . iterate f in (.^)
16:29:03 <lambdabot> forall a b. (Integral [a]) => (a -> a) -> [b] -> a -> b
16:29:12 <mtnviewmark> @src (.)
16:29:12 <lambdabot> (f . g) x = f (g x)
16:29:12 <lambdabot> NB: In lambdabot,  (.) = fmap
16:29:18 <BMeph> :t let f .^ n = flip genericIndex n . iterate f in (.^)
16:29:19 <lambdabot> forall b a. (Integral a) => (b -> b) -> a -> b -> b
16:29:35 <Jesin> :t (.^)
16:29:35 <lambdabot> forall b i. (Integral i) => (b -> b) -> i -> b -> b
16:29:42 <Jesin> hmm
16:29:48 <Jesin> @src (!!)
16:29:48 <lambdabot> xs     !! n | n < 0 = undefined
16:29:48 <lambdabot> []     !! _         = undefined
16:29:48 <lambdabot> (x:_)  !! 0         = x
16:29:48 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:29:55 <mtnviewmark> so - for composition,    foo . bar    is going to be a pointer to the code for (.), and a vector of the two argument foo and bar ----
16:29:56 <Jesin> @src genericIndex
16:29:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:30:06 <parcs> :t genericIndex .: iterate
16:30:07 <lambdabot> forall b a. (Integral a) => (b -> b) -> b -> a -> b
16:30:26 <BMeph>  genericReplicate n x = genericTake n (repeat x)
16:31:08 <BMeph> :t flip genericIndex .: iterate
16:31:09 <lambdabot> forall b a. (Integral [a]) => (a -> a) -> a -> [b] -> b
16:31:15 <uman> hey what do you guys think of this page? http://symbo1ics.com/blog/?p=788
16:31:29 <BMeph> Ah, must already flip the args. Good stuff, that.
16:31:29 <Jesin> :t (.:)
16:31:30 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:31:38 <roconnor> BMeph, Boxo: whether you should be worried or not depends on the strictness of the function being iterated
16:31:47 <Jesin> @where (.:)
16:31:48 <lambdabot> I know nothing about (.:).
16:31:57 <hpc> (.:) is not defined
16:32:03 <hpc> except in lambdabot
16:32:03 <BMeph> uman: I think it's obviously inflammatory. That is, it's inflamatory, in an obvious way.
16:32:10 <parcs> Jesin: f (.:) g = (f .) . g
16:32:17 <mtnviewmark> uman: I try not to
16:32:26 <hpc> alternatively, (.:) = fmap fmap fmap
16:32:35 <uman> BMeph: I thought it was pretty interesting
16:32:51 <roconnor> uman: I don't understand why the author thinks that haskellers inappropriately use mathematical terms.
16:32:54 <BMeph> uman: It's less interesting, the more Haskell you know, though. :(
16:32:54 <Boxo> alternatively, (.:) = fmap.fmap
16:33:13 <Boxo> = (.).(.) = (.)(.)(.)
16:33:44 <parcs> alternatively, (.:) = (.:)
16:33:54 <mtnviewmark> which looks like some assertion that all two eyed animals are three eyed!
16:34:18 <roconnor> uman: the author doesn't give any examples. 
16:35:05 <Boxo> Well haskell often inspires people to learn math, and in the process of that they're gonna use terms wrong
16:35:33 <roconnor> Boxo: still, I don't know of any examples
16:35:54 <Jesin> hmm
16:35:57 <sproingie> let eccentrica_gallumbits = (.)(.)(.)
16:36:08 <Jesin> my GHC says
16:36:10 <Jesin>     No instance for (Functor ((->) (a -> b)))
16:36:14 <Boxo> think of how people mangle monads when writing tutorials
16:36:25 <BMeph> Boxo: The Internet often inspires people to learn English, and in the process of that they're gonna use terms wrong. ;)
16:36:26 <mauke> Jesin: import Control.Monad.Instances
16:36:29 <hpc> Boxo: that's people using /haskell/ wrong
16:36:31 <hpc> ;_
16:36:33 <hpc> ;)
16:36:45 <Boxo> I didn't say his complaint was justified
16:37:07 <mtnviewmark> Well, I agree that we shouldn't be misleading anyone that learning Haskell is a primer on CT.
16:37:20 <roconnor> Boxo: You think bad monad tutorials was the thrust of his complaint?
16:37:29 <Boxo> It's a status attack. Silly haskell noobs think they know math with their big words but really they don't
16:37:30 <Jesin> thanks
16:37:45 <Jesin> wait, what?
16:37:46 <mtnviewmark> In fact I think we shouldn't even mention CT when teaching Haskell.... but that's just me.
16:37:46 <hpc> mtnviewmark: it's a primer on CT in the same way that VB.NET is a primer on programming
16:37:48 <Boxo> roconnor, it's an example of people using math terms wrong
16:37:57 <Jesin> haskell uses "Category" wrong, or something?
16:38:12 <roconnor> that being said, I'm not even aware of particularly wrong monad tutorials.  They may not be helpful, but I'm not really aware of errors.
16:38:28 <mtnviewmark> hpc: heh!.... BUT - you should know how to program to work in VB.net --- you don't need to know CT to work in Haskell
16:38:39 <hpc> mtnviewmark: fair
16:38:40 <roconnor> mtnviewmark: You are probably right
16:38:53 <hpc> mtnviewmark: but people manage in both with neither!
16:38:54 <mreh> :t evalState
16:38:55 <lambdabot> forall s a. State s a -> s -> a
16:39:10 <mtnviewmark> and thus - why I'm all for ignoring that blog post....
16:39:11 <sproingie> you could write monads in VB
16:39:30 <hpc> it doesn't even load for me
16:39:33 <hpc> i am taking it as a sign
16:40:26 <Jesin> hmm
16:40:28 <benmachine> hpc: nor I, in fact
16:40:51 <BMeph> roconnor: So monads really ARE space suits filled with nucleear waste! o.O
16:41:01 <BMeph> zOMG!
16:41:16 <roconnor> BMeph: they are kinda like space suits filled with nuclear waste
16:41:24 <Jesin> so, (Prelude..), (Control.Category..), and fmap
16:41:29 <roconnor> and they are kinda like burriotos
16:41:29 <sproingie> nuclear burritos
16:41:35 <Jesin> all provide valid definitions of function composition?
16:41:35 <roconnor> in fact
16:41:50 <Jesin> how does (Control.Category..) relate to the fmap version?
16:41:52 <roconnor> burriotos are kinda like space suits filled with nuclear waste
16:41:53 <hpc> Jesin: all should be the same function
16:42:00 <hpc> with different types
16:42:03 <roconnor> torrita is like a space suit
16:42:06 <mtnviewmark> nuclear waste... and jello....
16:42:11 <mtnviewmark> and they travel backward in time
16:42:15 <Jesin> so Categories count as Functors, I guess?
16:42:18 <hpc> or at least, different degrees of polymorphism
16:42:24 <roconnor> and guacamole is kinda like nuclear waste
16:42:33 <hpc> :t (Control.Category..)
16:42:34 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:42:36 <megajosh2> Hey has anyone successfully gotten modules to load dynamically in their code?
16:42:42 <mtnviewmark> Categories are 7-dimensional aliens with whiskers
16:42:46 <Jesin> :t fmap
16:42:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:42:54 <megajosh2> I can't figure out for the life of me what I've been doing wrong but I always get errors about unknown symbols when I try
16:42:57 <aristid> Jesin: the only thing common between fmap and Control.Category.. is that they both specialize to (.)
16:43:07 <BMeph> mtnviewmark: With 5-dimensional whiskers! :D
16:43:12 <mtnviewmark> megajosh2 - yes, using hs-plugins
16:43:28 <hpc> so for f = cat a, Functor can be a Category
16:43:39 <roconnor> aristid: I kinda feel like there must be some sort of slice category thingy relating the two
16:43:39 <mtnviewmark> megajosh2 - does it work if you invoke your code (and module loading) from within ghci?
16:44:03 <aristid> roconnor: i don't see how that could work
16:44:34 <roconnor> like hpc, (cat a) is a functor?
16:44:37 <roconnor> *said
16:44:48 <hpc> yeah, except i said it much less clearly :P
16:44:49 <megajosh2> mtnviewmark: I'll try
16:44:58 <Jesin> :k Control.Category.Category
16:44:59 <lambdabot>     Class `Control.Category.Category' used as a type
16:44:59 <lambdabot>     In the type `Control.Category.Category'
16:45:18 <mtnviewmark> megajosh2 - if that does work - try updating the latest hs-plugins --- I had exactly that problem
16:46:17 <Jesin> :k Control.Category.Category ((->) Integer)
16:46:18 <lambdabot>     Class `Control.Category.Category' used as a type
16:46:18 <lambdabot>     In the type `Control.Category.Category ((->) Integer)'
16:46:29 <megajosh2> mtnviewmark: Didn't work in GHCi
16:46:31 <Jesin> umm
16:46:32 <Jesin> halp
16:46:36 <parcs> @instnaces Category
16:46:36 <lambdabot> Couldn't find class `Category'. Try @instances-importing
16:46:40 <megajosh2> I switched to direct-plugins because plugins-1.5.1.3 wasn't working
16:46:44 <mtnviewmark> megajosh2: :-(
16:46:48 <parcs> heh, lambdabot recognized my typo
16:47:00 <roconnor> Jesin: Control.Category.Category isn't a type nor a type constructor.  It is a class name
16:47:06 <Jesin> k
16:47:13 <roconnor> :k ((->) Integer)
16:47:14 <lambdabot> ? -> *
16:47:46 <Boxo> why ? and not *?
16:47:57 <mtnviewmark> right - that version of plugins has something busted vis-a-vis current GHC... so try plugins >= 1.5.1.4
16:47:59 <Jesin> :k (->)
16:48:00 <lambdabot> ?? -> ? -> *
16:48:06 <mtnviewmark> that's what we needed to get loding to work in our project
16:48:22 <Jesin> @help instances-importing
16:48:22 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
16:48:31 <roconnor> Boxo: something about -> also working on kinds like *
16:48:36 <Jesin> @instances-importing Control.Category Category
16:48:37 <lambdabot> (->), Kleisli m
16:48:50 <Jesin> what's a Kleisli
16:49:00 <Jesin> @instances-importing Control.Category Arrow
16:49:00 <lambdabot> (->), Kleisli m
16:49:07 <Jesin> @instances-importing Control.Arrow Arrow
16:49:07 <lambdabot> (->), Kleisli m
16:49:27 <mtnviewmark> megajosh2: this is our loader code, if it will help:   https://github.com/mtnviewmark/barley/blob/master/src/Barley/Loader.hs
16:50:47 <mreh> I think I've discovered a new monad, where do I apply for a license?
16:51:22 <megajosh2> Hmm
16:51:23 <roconnor> @quote oasis
16:51:23 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
16:51:25 <hpc> mreh: the patent office
16:51:30 <megajosh2> Maybe compiling THEN loading will make things work
16:51:39 <hpc> (we should patent monads :P)
16:52:05 <Boxo> Kleisli m a b = a -> m b
16:52:16 <Boxo> :t (>=>)
16:52:17 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
16:52:20 <hpc> Jesin: the Kleisli category is the category defined by id = return and (.) = (<=<)
16:52:21 <mtnviewmark> you'd somehow think laziness would have the loader *pulling* the source through the compiler.... :-)
16:52:29 <mreh> sounds like Dijkstra's worst nightmare
16:52:58 <Jesin> :t (<=<)
16:52:59 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:53:24 <Eduard_Munteanu> :t flip (>=>)
16:53:24 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:53:32 <roconnor> @src (>=>)
16:53:32 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:54:12 <Jesin> @src (<=<)
16:54:12 <lambdabot> Source not found. I am sorry.
16:54:17 <hpc> (f >=> g) x = f =<< g x
16:54:26 <hpc> er
16:54:26 <Jesin> @src (=<<)
16:54:26 <lambdabot> f =<< x = x >>= f
16:54:34 <hpc> g x >>= f
16:54:47 <mreh> @src mapM
16:54:47 <lambdabot> mapM f as = sequence (map f as)
16:55:05 <Jesin> :t mapM
16:55:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:55:07 <Jesin> :t liftM
16:55:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:55:29 <Boxo> btw, you can define a monad with just return and (>=>)
16:55:51 <mreh> Monad laws are much nicer with >=>
16:55:53 <Eduard_Munteanu> Yeah, though not in Prelude.
16:56:06 <hpc> afaik, you can also define a category with id and ($)
16:56:19 <Eduard_Munteanu> And 'join' should really belong in the Monad typeclass too
16:56:39 <hpc> (and use (f . g) x = f $ (g $ x)
16:56:44 <mreh> then we should discard >>=
16:57:01 <Jesin> don't necessarily discard it
16:57:10 <mreh> place it outside the typeclass
16:57:19 <Jesin> why?
16:57:19 <mreh> as a synonym for join . map
16:57:25 <hpc> (>>=) is a fine thing to have inside the typeclass
16:57:37 <mreh> efficiency...
16:57:42 <mreh> fair
16:57:42 <hpc> just move join and (>=>) into it
16:57:52 <Jesin> efficiency?
16:57:56 <Eduard_Munteanu> And of course provide default definitions.
16:58:03 <Jesin> wouldn't the compiler be able to do the same optimizations either way?
16:58:07 <Jesin> also yes that
16:58:08 <parcs> why don't these changes become realized?
16:58:14 <hpc> Jesin: if the compiler is magic, it can do it every time
16:58:30 <hpc> Jesin: sadly, magic only exists in mathematical fairy-land
16:58:56 <Jesin> it doesn't have to do it every time, just most times that actually show up...
16:59:04 <mreh> I loled, but I don't understand why, now I feel bad
16:59:53 <Jesin> also, does this make mathematicians wizards?  :p
16:59:54 <hpc> mreh: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:00:03 <Jesin> XD
17:00:06 <Eduard_Munteanu> Heh.
17:00:16 <Jesin> what hpc just said was funny
17:00:22 <Jesin> I wonder if I should go prove it...
17:00:34 <Jesin> ...
17:00:35 <Random75> What is wrong with this? elementAt :: [a] -> Int -> a? I get a not in scope `x'
17:00:40 <Eduard_Munteanu> @remember hpc jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:00:41 <lambdabot> Done.
17:00:56 <Jesin> @help remember
17:00:57 <lambdabot> quote <nick>
17:00:57 <lambdabot> remember <nick> <quote>
17:00:57 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:01:05 <Jesin> @help quote
17:01:06 <lambdabot> quote <nick>
17:01:06 <lambdabot> remember <nick> <quote>
17:01:06 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:01:10 <Jesin> k
17:01:13 <Jesin> @quote hpc
17:01:14 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:01:16 <Jesin> @quote hpc
17:01:16 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:01:19 <hpc> @quote joke
17:01:19 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:01:27 <Jesin> @quote incompleteness
17:01:27 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:01:35 <Jesin> @quote mayonnaise
17:01:35 <lambdabot> No quotes match. I feel much better now.
17:01:43 <hpc> @quote monoid
17:01:43 <lambdabot> stepcut says: I wish someone had told the designers of XML about monoids :(
17:01:49 <Jesin> @quote begin
17:01:50 <lambdabot> Heffalump says: he's [Jon Harrop] not exactly a Haskell beginner, more like a Haskell fuckwit
17:02:07 <Jesin> @quote index
17:02:07 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
17:02:08 <mauke> preflex: quote . begin
17:02:11 <preflex>  <iicke> [learning Haskell] is like wearing a corset, at the beginning is annoying, but then your tits look bigger and the world becomes a better place
17:02:17 <parcs> blaze-html is an awesome combinator library. if you squint, your code looks almost like haml
17:03:09 <hpc> parcs: it really is
17:03:11 <Jesin> parcs: what's haml? or was that a typo?
17:03:21 <sproingie> jokes are like frogs.  they both die when you dissect them.
17:03:29 <Jesin> @quote frog
17:03:29 <lambdabot> No quotes match. It can only be attributed to human error.
17:03:30 <hpc> parcs: i accidentally wrote a weaker version of it myself, without knowing it existed
17:03:33 <aristid> Jesin: http://haml-lang.com/
17:03:42 <aristid> Jesin: so apparently there is a haml
17:03:58 <mreh> haxml
17:04:04 <aristid> google is our friend
17:04:08 <CESSMASTER> hey some guy was telling me there are things in haskell called cargomorphisms, but i can't find it on google
17:04:11 <CESSMASTER> was he just messing with me?
17:04:12 * lispy <3 google
17:04:25 <Random75> What is wrong with this? elementAt :: [x] -> Int -> x? I get a not in scope `x'
17:04:37 <lispy> CESSMASTER: hehe.  Sounds like a reference to cargocult.  do you think he/she meant catamorphisms?
17:04:53 <mreh> my god, they're using whitespace to build a hierachy of data... this must end!
17:05:01 <CESSMASTER> idk he said it had something to do with non-monotonic ints or something????
17:05:05 <sproingie> "cargomorphism" is way too cool a word to go unused
17:05:18 <aristid> CESSMASTER: i guess he was making fun of you?
17:05:20 <Jesin> :t elementAt
17:05:21 <lambdabot> Not in scope: `elementAt'
17:05:26 <mreh> catomorphism
17:05:32 <mreh> catamorphism
17:05:35 <sproingie> catoninemorphisms
17:05:47 <cncl> http://www.haskell.org/haskellwiki/Enumerator_and_iteratee why do the examples here use fix for recursion instead of let or where
17:06:01 <CESSMASTER> no he said it would help me understand monads
17:06:01 <cncl> i know it's valid, but it seems like a non-standard way to do it in haskell
17:06:04 <Eduard_Munteanu> Moarmorphism.
17:06:08 <Eduard_Munteanu> Like polymorphism, but moar.
17:06:12 <parcs> Random75: nothing is wrong with that. where are you inputting that?
17:06:14 <mreh> CESSMASTER: folds are your friend basically
17:06:15 <Jesin> cncl: because it's pointless, perhaps?
17:06:17 <Jesin> :P
17:06:20 <Boxo> @google "cargomorphism"
17:06:20 <lambdabot> No Result Found.
17:06:23 <cncl> :)
17:06:39 <Jesin> and by pointless
17:06:42 <Jesin> I mean pointfree
17:06:45 <Jesin> :p
17:06:59 <Random75> parcs: Before my definition: elementAt [x] k =....
17:07:41 <uman> how come everything in haskell has the word "morphism" in it
17:07:44 <CESSMASTER> he said cargomorphisms have something to do with intial algebra?
17:07:53 <mauke> CESSMASTER: ok, you can stop now
17:08:04 <CESSMASTER> what's initial algebra
17:08:10 <aristid> uman: that's part of the cargo cult
17:08:10 <CESSMASTER> i just had algebra I and II in school
17:08:12 <Jesin> uman: because haskell is math
17:08:13 <parcs> Random75: are you sure you're looking at the right line?
17:08:28 <Jesin> :p
17:08:35 <lispy> CESSMASTER: http://homepage.mac.com/sigfpe/Computing/fold.html
17:09:24 <Eduard_Munteanu> I hear some people have final algebras. It's like, there's nothing else to learn more?
17:09:32 <CESSMASTER> so is F the intial of the algebra?
17:09:40 <Jesin> aaaaah people are defining algebras
17:09:59 <Random75> parcs: I am losing my mind. Thanks for the help.
17:10:25 <roconnor> an initial algebra is the initial object in the categories of F-algebras
17:10:30 <lispy> parcs: when I see your name I think people are talking about darcs :)
17:10:31 <Jesin> huh
17:10:52 <Jesin> at first I read Random75's statement as thanking parcs for helping him lose his mind
17:10:53 <flippo> CESSMASTER, read the first page of Lang's Algebra, and you'll be good to go.
17:11:20 <CESSMASTER> so initial object means it's on the first page?
17:11:35 <lispy> conceptually, an algebra is some operations and some values and applying those operations to the values gives you more things that you can apply the operations too.
17:11:40 <flippo> CESSMASTER, pretty much.  That's about as far as most programmers get.
17:11:46 <Jesin> hmm
17:12:03 <CESSMASTER> lispy: i thought that was a group
17:12:11 <Jesin> is fmap in any way a special case of Control.Category.. ?
17:12:30 <shachaf> Jesin: Not really.
17:12:43 <lispy> CESSMASTER: others on here may disagree, but I consider a group to be an algebra (just one very specific kind of algebra)
17:12:47 <shachaf> Jesin: fmap and (Control.Category..) are both generalizations of (Prelude..).
17:12:57 <Quadrescence> lispy: are you sure that's not an algebraic structure, whereas an algebra is a module equipped with a bilinear product
17:13:06 <Jesin> "In mathematics, an algebra over a field is a vector space equipped with a bilinear vector product."
17:13:09 <roconnor> lispy: who says a group isn't an algebra?
17:13:15 <CESSMASTER> lispy: i thought there was no subjectivity in math
17:13:18 <Jesin> "an algebra over a commutative ring is a generalization of the concept of an algebra over a field, where the base field K is replaced by a commutative ring R."
17:13:20 <Eduard_Munteanu> I think he means universal/omega algebras.
17:13:26 <lispy> CESSMASTER: there is lots of subjectivity in math
17:13:43 <CESSMASTER> but what about axioms
17:13:53 <Jesin> people sometimes disagree on axioms
17:13:54 <CESSMASTER> like you prove things right?
17:14:20 <Jesin> you can prove that certain statements follow from certain axioms
17:14:35 <Jesin> and that certain statements are equivalent given a set of axioms, and such
17:14:40 <CESSMASTER> so if you prove that a group is a kind of algebra how can other opinions be valid
17:15:07 <Jesin> well, that's trivially based on the definition you use for "algebra"
17:15:11 <Eduard_Munteanu> They can be valid, given other definitions. Then we can disagree on definitions.
17:15:28 <Jesin> if there's consensus on what precisely that means, then there's one generally accepted answer
17:15:34 <roconnor> Jesin: I thought we were talking about F-algebras
17:15:37 <CESSMASTER> so why isn't there like a standard library of definitions
17:15:37 <Jesin> without such a consensus, though...  yeah  :p
17:15:43 <lispy> We can also disagree on the logic that you are allowed to use in your proofs
17:15:49 <Jesin> ooh!
17:16:02 <Jesin> no law of excluded middle!  :D
17:16:04 <Jesin> :p
17:16:07 <CESSMASTER> i'm sorry this is just really hard my friend told me to ask you guuys about morfisms
17:16:09 <lispy> Jesin: exactly
17:16:24 <lispy> This is why math people spend so much time on definitions
17:16:36 <lispy> Being precise...it's a pain, but sometimes the pain is necessary.
17:16:40 <CESSMASTER> what does excluded middle mean
17:16:50 <Eduard_Munteanu> Does your friend know about #haskell?
17:16:55 <Jesin> the law of the excluded middle says "P or not P"
17:16:58 <Jesin> for any statement P
17:17:05 <hpc> CESSMASTER: but not both
17:17:06 <CESSMASTER> is that like P = NP?
17:17:07 <Jesin> that is, either P is true, or its negation is
17:17:10 <Jesin> no
17:17:11 <hpc> CESSMASTER: no
17:17:11 <CESSMASTER> N = not?
17:17:16 <Jesin> this is a different P
17:17:34 <hpc> it's the promise of (P ∩ P')'
17:17:44 <mauke> this discussion seems unrelated to Haskell
17:17:44 <hpc> (i need to get the proper "not" symbol on this keyboard
17:17:46 <hpc> )
17:17:47 <CESSMASTER> so do people use P differently like you use algebra differently
17:17:53 <mauke> #haskell-blah?
17:17:57 <Jesin> hpc, no
17:18:05 <Jesin> that's not what I heard
17:18:12 <CESSMASTER> mauke: im trying to get to haskell but theres a lot of prereq material it looks like
17:18:18 <mauke> CESSMASTER: no, there isn't
17:18:22 <Jesin> sorry
17:18:26 <CESSMASTER> i just want to know about cargomorphisms
17:18:26 <Jesin> ...
17:18:36 <hpc> Jesin: oh right, i should have used xor
17:18:46 <hpc> P xor P' = false
17:18:49 <mauke> CESSMASTER: there is no such thing
17:18:51 <hpc> er, true
17:18:52 * Eduard_Munteanu founds #haskell-argh
17:18:58 <Boxo> law of excluded middle says: for any proposition P: P or ~P
17:19:25 <Boxo> @google learn you a haskell for great good
17:19:26 <lambdabot> http://learnyouahaskell.com/
17:19:26 <lambdabot> Title: Learn You a Haskell for Great Good!
17:19:34 <Eduard_Munteanu> @where lyah
17:19:34 <lambdabot> http://www.learnyouahaskell.com/
17:19:36 <Boxo> I recommend that CESSMASTER
17:19:42 <Eduard_Munteanu> (... is usually shorter to type)
17:19:54 <Jesin> CESSMASTER: learnyouahaskell is probably a good place to start
17:21:02 <CESSMASTER> "That goes well with referential transparency and it allows you to think of programs as a series of transformations on data. " is this like the algebras lispy was talking about?
17:21:08 <Jesin> don't mind the crazy math people babbling about the nature of logic and such
17:22:12 <Random75> Whats with the preference of learnyouahaskell over Realworld Haskell?
17:22:18 <Jesin> hmm... no, CESSMASTER, I think the algebras lispy was talking about were tangential to your question
17:22:51 <erikina> I think learnyouahaskell is better for learning, and realworldhaskell better for showing you what you can do with it
17:22:59 <erikina> At least that was my impression
17:23:07 <CESSMASTER> woah it says haskell was made by guys with PhDs
17:23:11 <CESSMASTER> does anyone here have one?
17:23:18 <Bynbo7> Random75: it's a better introduction to haskell. RWH somewhat assumes a little knowledge of haskell
17:23:19 <shachaf> rgomorphisms
17:23:23 <shachaf> Er.
17:23:38 <Boxo> ergomorphisms?
17:23:44 <erikina> CESSMASTER: I passed high school, does that count?
17:23:56 <thermoplyae> no
17:23:57 <CESSMASTER> erikina: wow and you know haskell?
17:24:07 <CESSMASTER> that's really impressive haskell seems hard
17:24:08 <erikina> Yeah, no i'm still learning haskell
17:24:18 <Jesin> I haven't graduated high school yet
17:24:25 <Eduard_Munteanu> No, people with PhDs relinquish their right to ever touch a computer again physically. They separate their minds from their bodies and transcend to another realm of existence.
17:24:39 <CESSMASTER> i tried learning ruby and there was no stuff about cargomorphisms and F-algebras
17:24:45 <CESSMASTER> but then the guy took his tutorial offline
17:25:00 <uman> Jesin: What do you mean Haskell is math, that sounds a bit extreme
17:25:01 <dpratt71> why
17:25:05 <Jesin> I was kidding!
17:25:10 <Boxo> there are no algomorphisms in LYAH, shees, jsut read it
17:25:10 <uman> Jesin: o lol
17:25:22 <Jesin> :p
17:25:23 <Random75> uman: It is mathy though!
17:25:43 <uman> Random75: can't argue with that
17:25:46 <Jesin> yeah, you can kinda tell by looking at it that it was designed by mathematicians
17:25:54 <flippo> You can taste the mathiness
17:26:13 <Jesin> (it's also named after one  :p )
17:26:26 <mm_freak> CESSMASTER: i think i'm a good haskell programmer, and i have about the lowest degree you can get in germany =)
17:26:29 <flippo> Goes well with curry!
17:26:47 <hpc> haskell curry was a fantastic role model of a mathematician
17:26:50 <mauke> mm_freak: hauptschulabschluss?
17:27:01 <hpc> way better than that freak, pythagoras
17:27:10 <CESSMASTER> mauke: woah more big words
17:27:12 <mm_freak> mauke: right
17:27:42 <flippo> hpc: computers don't like irrational numbers either.
17:28:16 <dpratt71> another non-degree-possessing Haskell-lover here
17:28:18 <mm_freak> hmm…  i think, CReal likes irrational numbers
17:28:32 <hpc> (to learn math from pythagoras, you had to be accepted into his freaky cult of the triangle or something)
17:28:41 <hpc> (and if you didn't, he killed you)
17:29:09 <Eduard_Munteanu> mauke: I sometimes wonder how difficult German spelling/reading is, considering the bunch of words that look like 'zygohistomorphic prepromorphisms' when written :)
17:29:14 <j-invariant> where can I get a multivariable polynomial data type in haskell?
17:29:25 <CESSMASTER> Eduard_Munteanu: hey wait what's that
17:29:33 <CESSMASTER> that sounds like what my friend asked me about that
17:29:42 <uman> hpc: is that the one who threw the guy overboard of a ship when he proved that sqrt(2) was irrational
17:29:47 <uman> or am I thinking of something else
17:29:56 <lowh> in case anyone was wondering CESSMASTER is a notorious troll from #math, my best advice to you is don't get drawn into a conversation with him
17:30:01 <hpc> uman: i think so
17:30:02 <CESSMASTER> :)
17:30:16 <CESSMASTER> lowh: jerk
17:30:19 <ajajjajjajj> are there haskell lirc bindings available?
17:30:20 <mm_freak> > ((sin^2 + cos^2) 3) + (iterate (+ (1/10 :: CReal)) 0 !! 9)
17:30:21 <lambdabot>   1.9
17:30:39 <mm_freak> > ((sin^2 + cos^2) 3) + (iterate (+ (1/10 :: CReal)) 0 !! 9) == 19/10
17:30:40 <lambdabot>   True
17:30:40 <uman> lowh: that was a pretty epic bout of trolling though
17:30:43 <mauke> lowh: yeah, I just checked my logs
17:30:55 <lowh> i believe i am also correct in stating that he's a close associate of the guy who wrote that blog post about the 'foul stench of mathematicians'
17:31:14 <CESSMASTER> yeah i think he was serious though
17:31:22 <uman> "the foul stench of mathematicians"
17:31:26 <uman> take another gander, mate.
17:31:31 <CESSMASTER> serious foul stench
17:31:36 <mm_freak> Eduard_Munteanu: german is one of the most difficult languages, but also one of the most expressive
17:31:42 <CESSMASTER> you should have smelled the guy in front of my in real analysis who was clipping his nails in lecture
17:31:46 <flippo> lowh, I think you left out the important adjective "cargo cult"
17:31:59 <uman> CESSMASTER: all you need to do is link a picture of Perelman and it's pretty much proven amirite
17:32:00 <mauke> you mean Quadrescence?
17:32:13 <Quadrescence> lowh: No, that is false. CESSMASTER isn't affiliated with me or what I do.
17:32:14 <testman> hi guys >)?
17:32:20 <testman> :-)
17:32:27 <Eduard_Munteanu> But somehow I remember seeing CESSMASTER and Quadrescence quite often on IRC (idling)
17:32:43 <JordiGH> mm_freak: No way, Dyirbal is much more complicated and much more expressive. It has many more noun classes than German.
17:32:44 <testman> is there any good reason to learn Haskell instead of Scheme?
17:32:44 <mauke> then I'm also "associated"
17:32:57 <hpc> testman: static types?
17:33:00 <mauke> testman: why not learn both?
17:33:06 <testman> mauke 
17:33:11 <mm_freak> JordiGH: i didn't say german is the most difficult
17:33:13 <thermoplyae> lowh: as a channel op in #math, i resent the implication that we'd let any trolls run amok
17:33:21 <lowh> thermoplyae: check whois
17:33:25 <testman> because i  want to learn from the SCIP book
17:33:32 <testman> from mit
17:33:34 <thermoplyae> what about it
17:33:46 <hpc> SICP isn't lisp-specific
17:33:46 <Eduard_Munteanu> mm_freak: I see. Unfortunately I don't know much about it.
17:33:51 <hpc> it just happens to teach in lisp
17:34:00 <testman> but to be hosnest the best option sounds
17:34:04 <mauke> testman: why not learn both?
17:34:07 <Quadrescence> lowh: I find it despicable that you would slander people from #math --- people who are generous and would help you.
17:34:09 <hpc> much in the same way that wikipedia's monads page happens to be in haskell
17:34:10 <mm_freak> Eduard_Munteanu: german is the haskell of natural languages =)
17:34:14 <testman> mauke
17:34:19 <Eduard_Munteanu> Heh.
17:34:25 <hpc> mm_freak: ostensibly consistent, but apples are masculine?
17:34:28 <mauke> testman
17:34:29 <mauke> testman
17:34:36 <testman> mauke it is a good idea to learn both 
17:34:41 <mm_freak> hpc: right
17:34:45 <mm_freak> der apfel
17:34:46 <hpc> :D
17:35:00 <mauke> der adamsapfel
17:35:02 <testman> mauke but it could be better if there was a good book for haskell
17:35:04 <lowh> thermoplyae: nm i thought my ~ would give away my secret identity as base3 but clearly it didn't 
17:35:08 <mauke> testman: there is
17:35:10 <testman> like the SCIP
17:35:13 <hpc> @where lyah
17:35:13 <lambdabot> http://www.learnyouahaskell.com/
17:35:16 <hpc> testman: ^
17:35:20 <aristid> hpc: of course apples are masculine.
17:35:21 <testman> mauke PLEASE tell me a 
17:35:22 <mm_freak> and bananas are female…  so many females enjoy lesbian stuff
17:35:46 <testman> mauke this is for children
17:35:51 <lowh> there's an unicode ellipsis?
17:35:53 <mauke> testman: no
17:36:00 <testman> mauke r u sure?
17:36:00 <Quadrescence> lowh: You just took slander to a new lowh.
17:36:03 <mm_freak> lowh: apparently
17:36:10 <monochrom> … is a unicode ellipsis
17:36:17 <testman> do you know the SCIP book?
17:36:17 <CESSMASTER> lowh: why can't you let me be man, someo f us like to troll channels without flooding them
17:36:24 <lowh> Quadrescence: no-one has ever helped me in #math… I help myself
17:36:25 <mauke> testman: no, I only know SICP
17:36:31 <McManiaC> how do you get the diff of one single patch with darcs?
17:36:41 <aristid> Quadrescence: aren't you the guy who accused the entire haskell community of cargo cult practices?
17:36:53 <lowh> CESSMASTER: maybe you should try trolling channels without being obvious?
17:36:53 <testman> mauke i mean http://mitpress.mit.edu/sicp/
17:36:56 <mm_freak> McManiaC: patch file or recorded patch?
17:37:01 <McManiaC> recorded
17:37:04 <CESSMASTER> lowh: i got a coupole didn't I
17:37:10 <testman> mauke do you know a book so good like the SICP ?
17:37:11 <mm_freak> McManiaC: darcs diff
17:37:20 <lowh> there's always a couple
17:37:24 <mauke> testman: learn you a haskell is pretty good
17:37:31 <CESSMASTER> those couple are the entertaining guys
17:37:46 <Quadrescence> aristid: no
17:37:55 <aristid> Quadrescence: ok, sorry.
17:37:59 <Quadrescence> np
17:38:01 <JordiGH> Aw, lowh finally caught on.
17:38:06 <Jesin> what counts as "got" anyway
17:38:08 <Jesin> :p
17:38:09 <McManiaC> mm_freak: can you give it a "hint" which patch it is? selecting it by hand might take a while on a big repo (like GHC)
17:38:12 <testman> mauke did it help you learn some advanced stuff ? (like i monads...or so ?)?
17:38:17 <testman> mauke ?
17:38:26 <mauke> testman: no, I learned Haskell before LYAH was written
17:38:26 <Eduard_Munteanu> Hey, am I in #math? Damn... Wait no.
17:38:40 <testman> mauke ha ha ok 
17:38:40 <mauke> testman: also, monads aren't advanced
17:38:41 <McManiaC> mm_freak: nevermind, sorry
17:38:42 <McManiaC> ^^
17:38:46 <CESSMASTER> testman: if you can find any resources about cargomorphisms, those will be helpful
17:38:52 <mauke> testman: (monads also aren't important)
17:38:56 <hpc> monads are a simple thing made complicated
17:39:02 <CESSMASTER> they're like space burritos
17:39:05 --- mode: ChanServ set +o mauke
17:39:05 --- mode: mauke set +q $a:CESSMASTER
17:39:11 <testman> mauke lol ok i don't know...
17:39:13 <Jesin> hm
17:39:13 <JordiGH> lol
17:39:16 <testman> mauke ok
17:39:24 <Jesin> +q means "quiet" on this server I guess?
17:39:32 <testman> mauke i 'll give it a second change
17:39:43 <aristid> Jesin: yes.
17:39:46 <Jesin> hmm, makes more sense than the other server I'm on where somehow it stands for "channel owner"
17:39:47 <Jesin> :p
17:39:49 <testman> mauke to that book
17:40:02 <JordiGH> wait wat http://codetojoy.blogspot.com/2009/03/monads-are-burritos.html
17:40:11 <Jesin> burritos.
17:40:24 <McManiaC> lol.
17:40:40 <j-invariant> What's th edifference between Charity and Hagino CPL?
17:40:40 <hpc> JordiGH: it is only appropriate that the only comment be regarding runescape
17:40:44 <JordiGH> Slides are like bras hanging from the ceiling fan?
17:41:05 --- mode: mauke set -o mauke
17:41:05 <testman> """Dude, a monad is a programmable semi-colon! """ 
17:41:07 <testman> LOL
17:41:20 <monochrom> you know, maybe we should go troll #math. "hi I heard that what you people do is cargo cult computing"
17:41:23 <mm_freak> i have to admit, this CESSMASTER has an elegant way to troll, so he might be right in the haskell world after all =)
17:41:38 <Jesin> what
17:41:46 <Jesin> elegant?
17:41:51 <Jesin> hmm...
17:41:52 <Eduard_Munteanu> I think byorgey made up the burrito part, but he wasn't far from the truth wrt the kind of explanations people try to give.
17:41:57 <Jesin> eh.
17:41:58 <lowh> mm_freak: if you find 'cargomorphisms' elegant I hate to think what your code looks like
17:42:00 <testman> mauke  sorry is that Real world Haskell a good book?
17:42:06 <hpc> monochrom: nonono, just bring up IEEE floats
17:42:34 <mm_freak> lowh: gonads are elegant, too
17:42:36 <tensorpudding> i think that random people talk about floats in there often
17:42:40 <roconnor> I still maintain burritos are like spacsuits holding nuclear waste
17:42:44 <tensorpudding> that i see
17:42:45 <testman> is there any better book i mean about a book that gives good examples about computer science and not only tricky tips
17:42:49 <hpc> mm_freak: my gonad monad has an enormous continuation
17:42:59 <testman> like the SICP one ( about scheme)?
17:43:11 <Jesin> oh, btw
17:43:20 <lowh> gonads are burritos
17:43:20 <Jesin> lambdabot has a CReal type
17:43:22 <BMeph> hpc: Oh, be-HAVE! ;þ
17:43:22 <mm_freak> hpc: is there a GonadT?
17:43:23 <tensorpudding> SICP is a "tricky tips" book?
17:43:44 <Jesin> where would I find a module for that?
17:43:44 <testman> tensorpudding: no it is a good book!
17:43:50 <parcs> octave developer? nice
17:43:58 <Jesin> :k CReal
17:43:59 <lambdabot> *
17:44:09 <hpc> SICP feels very "cutting edge of the sixties" though
17:44:13 <Eduard_Munteanu> This #math reunion over here was purely coincidental with CESSMASTER's trolling?
17:44:14 <hpc> which i suppose it is
17:44:15 <Jesin> @where CReal
17:44:15 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
17:44:23 <Jesin> ...
17:44:25 <Jesin> huh
17:44:39 <Jesin> I thought I asked it that before and it didn't work
17:44:43 <Jesin> perhaps I didn't  :p
17:44:58 * BMeph is now hungry for a space burrito! With nuclear waste guacamole inside!
17:45:04 <testman> hpc: feels but it is the fundamental as algoritms and complexity still are...
17:45:16 <j-invariant> basically haskell is different than math
17:45:29 <Quadrescence> but non-basically it's really the same
17:45:43 <testman> hpc: there is no aging in theory !!!
17:46:27 <testman> does anybody knows a good computer science book about haskell to suggest
17:46:42 <Eduard_Munteanu> Basically, it's math and sciences, no Haskell or CS :P.
17:46:55 <aristid> basically, haskell is a programming language
17:47:04 <tensorpudding> there's a book on type theory by the guy who made miranda
17:47:13 <tensorpudding> miranda's close enough to haskell
17:47:28 <lowh> basically, haskell is a word consisting of the letters 'h', 'a', 's', 'k', 'e', 'l' and 'l'
17:47:28 <quvr> aristid: its more than that, its pure functional!
17:47:37 <Eduard_Munteanu> TAPL has ML implementations of the described concepts.
17:47:38 <hpc> aristid: now bear with me for a moment while i waste hours of lecture time on tangental point
17:47:38 <testman> 'i am bored with the introductury books for kids that have no will to step you further!!!
17:47:42 <j-invariant> the thing about advanced math is it doesn't seem make anything easeir
17:47:46 <Eduard_Munteanu> But I don't know Haskell-oriented books.
17:47:50 <aristid> quvr: it is fun-ctional
17:47:53 <mm_freak> basically haskell is a male name
17:48:00 <Eduard_Munteanu> Maybe Okasaki's has some Haskell-specific stuff?
17:48:02 <testman> so a good computer science book about haskell ? anybody?
17:48:14 <mm_freak> haskelle might be the female variant
17:48:19 <hpc> testman: you can't find CS books about languages
17:48:19 <lowh> and when we say haskell is functional, it doesn't mean that it's a linear mapping from a function space to a field
17:48:21 <tensorpudding> err wait, not the miranda guy
17:48:28 <Eduard_Munteanu> (I mean "Purely functional data structures..." or whatsitsname)
17:48:30 <quvr> mm_freak: not haskella?
17:48:37 <hpc> you find programming books about languages, and CS books about computer science
17:48:41 <hpc> :P
17:48:46 <Eduard_Munteanu> That's a point.
17:48:53 <testman> hpc that a good point mostly i found only anout java c or c++ 
17:48:56 <testman> :(
17:49:04 <mm_freak> quvr: probably both
17:49:06 <hpc> testman: use lyah
17:49:08 <hpc> @where lyah
17:49:09 <lambdabot> http://www.learnyouahaskell.com/
17:49:14 <Eduard_Munteanu> TAPL is definitely not about those, though it covers concepts about them.
17:49:22 <testman> hpc ok i will do it man !!!!!!!!
17:49:23 <hpc> and read through it until you reach zen
17:49:25 <hpc> :P
17:49:27 <testman> hpc THANKS!!!
17:49:28 * shachaf notes that the "monads as spacesuits/nuclear waste" thing is finally off the Haskell wikibook.
17:49:37 <hpc> shachaf: thank GOD
17:49:42 <Jesin> mm_freak, quvr, you guys are so sexist  :p
17:49:47 <Eduard_Munteanu> testman: usually, by CS books we mean theory, not stuff describing how to program in a language.
17:49:49 <mm_freak> i'd never read a CS book about haskell…  people often forget in their perfectionism that haskell is actually a language, with which you can get things done pretty fast
17:50:16 <aristid> mm_freak: of course only when you're not busy writing monad transformer stacks using CPS :)
17:50:21 <Eduard_Munteanu> So a CS book is about theorems, lemmas, properties, lambda calculus etc.
17:50:23 <mm_freak> it is as practical as you use it
17:50:47 <mm_freak> aristid: i wrote them for practical purposes =)
17:51:02 <aristid> mm_freak: heh. where do you need them?:)
17:51:49 <mm_freak> aristid: look into its documentation (since it won't build with GHC 7.0 yet, you have to install it first right now)
17:52:11 <mm_freak> it's quite flexible and by now provides quite a few great features, which other libraries lack
17:52:20 <Jesin> aaah, CPS
17:52:29 <Jesin> I have never bothered to learn that, I think...
17:52:32 <mm_freak> both in terms of monadic effects and in terms of boilerplate code
17:53:00 <mm_freak> for example i found myself almost always combining StateT and ContT…  contstuff's StateT doesn't need that anymore
17:53:18 <medfly`> I don't get things done quickly with Haskell
17:53:30 <aristid> mm_freak: well i never use ContT, i fear it :)
17:53:53 <hpc> i haven't ever had need of ContT
17:53:57 <hpc> or Cont
17:54:02 <hpc> i don't see where the idiom is useful
17:54:12 <aristid> mm_freak: but is there a package where you have contstuff as a dependency?
17:54:21 <mm_freak> hpc: simple:  a server, which runs, until you shut it down
17:54:28 <hpc> mm_freak: hah, fair
17:54:39 <mm_freak> you can just use 'forever' with ContT
17:54:48 <hpc> :t forever
17:54:48 <mm_freak> aristid: dnscache
17:54:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:55:07 <Jesin> > forever
17:55:07 <lambdabot>   Overlapping instances for GHC.Show.Show (m a -> m b)
17:55:08 <lambdabot>    arising from a use ...
17:55:12 <Jesin> what.
17:55:16 <Jesin> @where forever
17:55:16 <lambdabot> I know nothing about forever.
17:55:17 <hpc> @src forever
17:55:17 <lambdabot> Source not found.
17:55:28 <hpc> forever x = x >> x, presumably
17:55:31 <JoeyA> :t forever
17:55:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:55:36 <JoeyA> bah
17:55:38 <shachaf> hpc: You mean >> forever x?
17:55:40 <hpc> er, x >> forever x
17:55:41 <aristid> mm_freak: cool. which transformers do you need there?
17:55:42 <hpc> yes
17:55:55 <hpc> :t fix (x >>)
17:55:56 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
17:55:56 <lambdabot>     In the first argument of `(>>)', namely `x'
17:55:57 <lambdabot>     In the first argument of `fix', namely `(x >>)'
17:56:00 <Axman6> :t f x = fix (x >>)
17:56:00 <lambdabot> parse error on input `='
17:56:08 <hpc> :t \x -> (x >>)
17:56:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
17:56:11 <aristid> :t let f x = fix (x >>) in f
17:56:11 <Axman6> :t let f x = fix (x >>) in f
17:56:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:56:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:56:14 <hpc> argh
17:56:17 <hpc> yes, that
17:56:19 <Eduard_Munteanu> :t fixM
17:56:20 <lambdabot> Not in scope: `fixM'
17:56:23 <Eduard_Munteanu> @hoogle fix
17:56:23 <lambdabot> Data.Function fix :: (a -> a) -> a
17:56:23 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
17:56:23 <lambdabot> module Control.Monad.Fix
17:56:32 <mm_freak> aristid: the internal resolver threads use StateT
17:56:46 <parcs> :t let fix . (>>)
17:56:47 <lambdabot> parse error (possibly incorrect indentation)
17:56:48 <Eduard_Munteanu> :t fixIO
17:56:49 <lambdabot> Not in scope: `fixIO'
17:56:53 <parcs> :t fix . (>>)
17:56:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:56:56 <parcs> :t fix . flip (>>)
17:56:57 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m b
17:57:04 <aristid> mm_freak: and they also need the continuation stuff?
17:57:05 <parcs> would the latter ever execute anything?
17:57:12 <hpc> parcs: no
17:57:13 <mm_freak> aristid: on a first glance they seem to be the same, but my StateT has an 'abort' function =)
17:57:28 <hpc> parcs: what's the first action?
17:57:35 <Jesin> :t fmap fix
17:57:36 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
17:57:42 <monochrom> mm_freak's StateT is pro-choice? :)
17:57:51 <aristid> mm_freak: so it's like ErrorT () StateT
17:57:58 <aristid> mm_freak: so it's like ErrorT () (StateT s)
17:58:04 <mm_freak> aristid: ContT + StateT
17:58:20 <mm_freak> there is an error monadt, too
17:58:23 <mm_freak> EitherT =)
17:58:32 <mm_freak> and another one:  MaybeT
17:58:38 <aristid> does your EitherT have an Error constraint on the Left type?
17:58:47 <mm_freak> no
17:59:14 <mm_freak> EitherT adds exception handling support as a side effect
17:59:29 <mm_freak> take a look at the HasExceptions class in Control.ContStuff.Classes
17:59:43 <hpc> ContStuff ^^
18:00:17 <Jesin> umm
18:00:22 <mm_freak> and you save to import Control.Exception, because IO is also an instane of HasExceptions =)
18:00:24 <Jesin> what's with appending T to stuff?
18:00:38 <hpc> Jesin: a transformer
18:00:51 <mm_freak> MaybeT is an interesting instance…  in contstuff you can say things like:  require (isBinaryFile h)
18:00:59 <mauke> Optimus'
18:01:05 <hpc> a foo transformer is a type that lets you combine other foos
18:01:11 <hpc> for whatever "foo" is
18:01:34 <hpc> so a monad transformer lets you combine monads to get behavior from both
18:01:35 <mm_freak> Jesin: Maybe is a monad, and MaybeT is a monad transformer
18:01:44 <mm_freak> hpc: right
18:01:54 <mm_freak> basically
18:02:19 <mm_freak> sometimes even more…  combining some monads with ContT also improves their performance, in some cases even asymptotically
18:02:21 * hpc recently wrote a triple-nested transformer by hand
18:02:22 <aristid> mm_freak: require looks a lot like guard?
18:02:29 <aristid> :t guard
18:02:29 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:02:54 <hpc> :t require
18:02:54 <lambdabot> Not in scope: `require'
18:02:55 <mm_freak> aristid: yes, but it requires truth from the underlying monad
18:02:59 * monochrom put ContT in ContT so you could callcc while you callcc
18:03:19 <aristid> mm_freak: "truth"?
18:03:37 <hpc> so require :: MonadTransPlusWhatever t, Monad m => m Bool -> t m ()
18:03:44 <mm_freak> aristid: in a MaybeT you say "require (isRegularFile h)" instead of "require (lift $ isRegularFile h)"
18:03:46 <hpc> or something like that
18:04:05 <aristid> mm_freak: ok, so require = guard . lift?
18:04:10 <j-invariant> Can we discover new types of lambda calculus from category theory?
18:04:11 <mm_freak> it's a special 'throwWhen'
18:04:25 <mm_freak> guard gives you mzero
18:04:33 <lowh> mm_freak: does your client automatically change three dots to the ellipsis or do you have to select it from a special menu?
18:04:34 <mm_freak> require throws an exception
18:04:42 <aristid> for MaybeT, mzero is an exception, i presume
18:04:55 <mm_freak> lowh: i press alt gr + .
18:05:10 <aristid> lol… awesome key combination…
18:05:20 <mm_freak> lowh: man xmodmap
18:05:23 <mm_freak> =)
18:05:24 <Jesin> my keyboard doesn't have altgr
18:05:35 * Jesin are in america
18:05:39 <ion> In X11, Compose . . generates …
18:05:40 <aristid> Jesin: ……………………………………………………………………………………
18:05:52 <aristid> ion: that works too
18:05:53 <ion> Compose - > generates → etc.
18:06:00 <aristid> but AltGr + . is faster
18:06:11 <Jesin> what's Compose
18:06:11 <mauke> ‼⁉⁇
18:06:13 <aristid> ion: woah, the arrows are cool
18:06:15 <mm_freak> 3 ∈ ℤ/4ℤ
18:06:21 <Jesin> GAH
18:06:28 <Jesin> mm_freak you have those on your keyboard?
18:06:31 <aristid> mm_freak: ok, how did you type THAT?
18:06:31 <Jesin> ...
18:06:34 <mm_freak> Jesin: yeah
18:06:42 <lowh> mm_freak: that smells like cargo cult math that you don't really understand
18:06:46 <Jesin> I have to pull those out of a character selector...
18:06:49 <hpc> mm_freak: ℵ ≥ ∞
18:06:59 <mm_freak> aristid: altgr + shift + 7 and altgr + shift + z
18:07:16 <aristid> mm_freak: i get different symbols for that :(
18:07:30 <lowh> ⅞
18:07:31 <mm_freak> lowh: but i do =)
18:07:32 <Jesin> I should map capslock to that or something
18:07:41 <mm_freak> aristid: sure, i have a custom xmodmap
18:07:46 <mauke> ⁷/₈
18:07:56 <aristid> Jesin: yes, good idea. i have mapped Right Ctrl to compose
18:08:21 <hpc> i mapped ctrl+shift to change keyboard layouts
18:08:24 <monochrom> I use one of the "windows key"s
18:08:29 <hpc> and alt+shift for languages
18:08:36 <ion> ximkeys <http://www.pixelbeat.org/scripts/ximkeys> is handy. % ximkeys ⅞
18:08:36 <ion> <Multi_key> <7> <8>			: "⅞"	U215E # VULGAR FRACTION SEVEN EIGHTHS
18:08:47 <ion> Read: Compose 7 8
18:08:57 <aristid> x₇³⁴
18:08:59 <hpc> i have the greek keyboard and a custom math keyboard
18:09:12 <hpc> planning to make a latex keyboard someday
18:09:14 <Eduard_Munteanu> I think lowh had a point there that '3' isn't the numerical '3' there.
18:09:26 <lowh> hpc: sounds like it would be a little soft
18:09:34 <ion> I use IBus with the LaTeX input method for some mathy characters.
18:09:35 <mm_freak> Eduard_Munteanu: yes, 3 is a class
18:09:38 <hpc> lowh: :P
18:10:02 <mm_freak> so 4ℤ + 3 ∈ ℤ/4ℤ should be a better notation
18:10:36 <lowh> or [3]
18:10:43 <aristid> mm_freak: that smells like foul cargo cult stench
18:10:46 <Eduard_Munteanu> Yeah, I think one can say it's explicitly '3' = {..., 3, 7, ...}
18:10:58 <Eduard_Munteanu> (so a set)
18:11:03 <monochrom> or you don't have to insist that every random statement made for testing your symbols must be true statements.
18:11:25 <mm_freak> monochrom: you see what happens in #haskell if you don't
18:11:39 <mm_freak> all the compilers complain
18:11:41 <hpc> mm_freak: that's how perl came about, donchaknow
18:11:42 <Jesin> XD
18:11:54 <j-invariant> 3 = 4Z + 3?
18:12:06 <Eduard_Munteanu> 4Z = 0? :P
18:12:09 <hpc> someone pulled that trick, and the other guy reacted by making /everything/ valid
18:12:20 <mauke> no
18:12:38 <mm_freak> pointOfThisDiscussion :: a
18:12:46 <hpc> pointOfThisDiscussion :: Void
18:12:49 <mauke> :: Void
18:12:53 <hpc> XD
18:13:04 <mm_freak> same effect
18:13:10 <hpc> also, you forgot to universally quantify a
18:13:18 <mm_freak> but i prefer 'a', because it's not so obvious =)
18:13:21 <monochrom> you have no life
18:13:29 <mm_freak> hpc: nope
18:13:30 <hpc> i prefer 'Void', because then it's more useless :P
18:13:49 <mm_freak> hpc: and you can't construct it in h98 =P
18:14:15 <hpc> mm_freak: have fun with your flat module structure :P
18:14:25 <Jesin> @where Void
18:14:25 <lambdabot> I know nothing about void.
18:14:30 <Jesin> :k Void
18:14:31 <lambdabot> Not in scope: type constructor or class `Void'
18:14:36 <mm_freak> Jesin: data Void
18:14:38 <shachaf> Jesin: data Void
18:14:38 <hpc> Jesin: data Void
18:14:42 <mm_freak> lol
18:14:43 <Jesin> ah.
18:14:58 <Jesin> 3 responses, yay
18:15:00 <Jesin> :p
18:15:03 <hpc> Jesin: basically, it's the type who's only value is bottom
18:15:16 <Jesin> :t undefined
18:15:17 <lambdabot> forall a. a
18:15:18 <Jesin> :p
18:15:40 <mauke> mm_freak: newtype Void = Void Void
18:15:51 <Jesin> what
18:15:54 <mm_freak> senseOfDiscussion :: a -> b
18:15:54 <shachaf> @ty unsafeCoerce id
18:15:55 <lambdabot> Not in scope: `unsafeCoerce'
18:15:55 <Jesin> ...
18:15:57 <Jesin> D:
18:15:58 <monochrom> newtype Newtype = Newtype Newtype
18:16:08 <hpc> mauke: that that compiles is a crying shame
18:16:18 <shachaf> hpc: Why?
18:16:25 <Jesin> :t Unsafe.Coerce.unsafeCoerce
18:16:26 <lambdabot> forall a b. a -> b
18:16:29 <Jesin> \o/
18:16:29 <hpc> shachaf: because... something
18:16:30 <Jesin> :p
18:16:33 <Jesin> I like that type signature
18:16:35 <mm_freak> mauke: true
18:16:42 <shachaf> > Unsafe.Coerce.unsafeCoerce id :: Int
18:16:43 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
18:16:46 <shachaf> Aw.
18:16:48 <Jesin> (Unsafe.Coerce.unsafeCoerce undefined) :: Int
18:16:53 <Jesin> > (Unsafe.Coerce.unsafeCoerce undefined) :: Int
18:16:53 <shachaf> @slap lambdabot
18:16:53 <lambdabot> go slap lambdabot yourself
18:16:54 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
18:17:01 <Jesin> :(
18:17:04 <mm_freak> mauke: but it's not the same in CH
18:17:09 <hpc> @let unsafeCoerce = undefined
18:17:10 <lambdabot>  Defined.
18:17:11 <aristid> @slap shachaf
18:17:11 * lambdabot locks up shachaf in a Monad
18:17:18 <mm_freak> you could construct a value of your Void version in it
18:17:18 <hpc> have fun :P
18:17:25 <mm_freak> you can't of the regular Void
18:17:25 <Jesin> > (Unsafe.Coerce.unsafeCoerce undefined) :: Int
18:17:26 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
18:17:30 * shachaf unsafePerformHoudini
18:17:31 <mauke> what's CH?
18:17:33 <Jesin> > (unsafeCoerce undefined) :: Int
18:17:35 <lambdabot>   *Exception: Prelude.undefined
18:18:07 <adnap> what does it mean for a type to be "flat"?
18:18:10 <Eduard_Munteanu> Curry-Howard iso?
18:18:17 <hpc> :t let f :: (a -> b); f = undefined in fix f
18:18:18 <lambdabot> forall a. a
18:18:22 <mm_freak> nightmare = fmap (unsafePerformIO . sex) getWrongWife
18:18:29 <Jesin> also
18:18:29 <aristid> oh, funny acronym guessing game
18:18:34 <Jesin> Data.Dynamic, WHY
18:18:38 <Jesin> why would such a module exist
18:18:39 <aristid> CH = Continuum Hypothesis *guess*
18:18:56 * Eduard_Munteanu thought about it, but it made little sense
18:18:56 <mm_freak> mauke: curry-howard isomorphism
18:19:00 <mauke> category hask?
18:19:04 <Axman6> mm_freak: doesn't that imply that getWrongWife :: IO (IO Wife)?
18:19:29 <monochrom> flat = apart from bottom, x⊑y implies x=y. or contrapositively, x/=y implies incomparable.
18:19:32 <j-invariant> can anyone help me understand what is HASK?
18:19:35 <mm_freak> :t fmap (unsafePerformIO . putStrLn) getLine
18:19:36 <lambdabot> Not in scope: `unsafePerformIO'
18:19:55 <aristid> Eduard_Munteanu: i thought that curry-howard isomorphism would be CHI...
18:19:56 <Eduard_Munteanu> j-invariant: Hask is *
18:20:04 <mauke> @let jesin === what = cast jesin == Just what
18:20:04 <shachaf> @ty fmap (?unsafePerformIO . putStrLn) getLine
18:20:05 <lambdabot>  Defined.
18:20:06 <lambdabot> forall b. (?unsafePerformIO::IO () -> b) => IO b
18:20:07 <aristid> CHI is also a TLA
18:20:09 <hpc> Hask is the kind *
18:20:12 <Axman6> @let unsafePerformIO :: IO a -> a; unsafePerformIO = undefined
18:20:13 <hpc> more specifically
18:20:14 <lambdabot>  Defined.
18:20:15 <j-invariant> so objects of Hask are haskell types?
18:20:25 <j-invariant> like Integer
18:20:29 <shachaf> mauke: cast is Data.Typeable.
18:20:30 <j-invariant> forall a. a -> a
18:20:37 <mm_freak> :t fmap (unsafePerformIO . putStrLn) getLine
18:20:38 <lambdabot> IO ()
18:20:39 <Eduard_Munteanu> The category of all (boxed) Haskell types
18:20:55 <aristid> :t cast
18:20:56 <mauke> > "Jesin" === 42
18:20:56 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
18:20:58 <lambdabot>   False
18:21:02 <el_loco> what the meaning of ":t"?
18:21:12 <hpc> el_loco: "type of"
18:21:13 <Jesin> :t cast
18:21:13 <aristid> :t (===)
18:21:14 <mm_freak> el_loco: infer the type
18:21:14 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
18:21:14 <lambdabot> Not in scope: `==='
18:21:15 <monochrom> it means "what is the type of"
18:21:18 <shachaf> el_loco: It's a smiley face. Turn your head 270 degrees and you'll see it.
18:21:23 <Jesin> :t jesin
18:21:24 <Eduard_Munteanu> j-invariant: yes, and the arrows of that category are the functions between them.
18:21:25 <lambdabot> Not in scope: `jesin'
18:21:37 <mm_freak> ok, this conversation leads nowhere
18:21:42 <mm_freak> we need a superhero now
18:21:49 <mm_freak> and i know who to call
18:21:50 <hpc> shachaf: alternatively, turn your head -450 degrees
18:22:07 <monochrom> degree is for losers
18:22:09 <mauke> at least it's the scenic route
18:22:23 <Eduard_Munteanu> j-invariant: though it doesn't make much sense if you don't have a little background in category theory.
18:22:32 <Eduard_Munteanu> (not that you need to)
18:22:42 <adnap> did someone answer my question regarding the meaning of a "flat" type?
18:22:51 <monochrom> yes
18:22:51 <Eduard_Munteanu> adnap: yes
18:22:52 <mm_freak> toot toot
18:22:56 <mm_freak> the ASCIICAT!
18:22:59 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
18:23:01 <lambdabot>   ("TOOTOOT","ASCIICAT")
18:23:01 <adnap> okay, i guess i missed it.
18:23:10 <monochrom> string-search for "flat = "
18:23:14 <adnap> maybe i didn't realize it was directed at me.
18:23:14 <Eduard_Munteanu> < monochrom> flat = apart from bottom, x⊑y implies x=y. or contrapositively, x/=y implies incomparable.
18:23:30 <Jesin> [21:22:32]	<mm_freak>	> splitAt 7 . drop 27 . map head $ cake
18:23:32 <aristid> > drop 27 cake
18:23:34 <lambdabot>   ["Two slash three cups granulated rhubarb.","One tablespoon all-purpose rhu...
18:23:37 <Jesin> wtf was that
18:23:39 <Jesin> ...
18:23:40 <Jesin> oh.
18:23:45 <aristid> :t splitAt
18:23:46 <lambdabot> forall a. Int -> [a] -> ([a], [a])
18:23:57 <Eduard_Munteanu> monochrom: '⊑' there is the subtyping relation?
18:24:00 <monochrom> I never direct at anyone
18:24:00 <aristid> > map head cake
18:24:02 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
18:24:12 <adnap> Eduard_Munteanu: i don't understad that.  what is a-hat?
18:24:23 <mauke> > cake === cake
18:24:25 <aristid> mm_freak: amazing discovery
18:24:25 <lambdabot>   Not in scope: `==='
18:24:32 <hpc> :t isLie
18:24:33 <lambdabot> Not in scope: `isLie'
18:24:41 <hpc> :t lie
18:24:42 <Eduard_Munteanu> adnap: "a-hat"? Do you see UTF-8 correctly?
18:24:42 <lambdabot> Not in scope: `lie'
18:24:48 <aristid> @let a === b = cast a == cast b
18:24:49 <monochrom> ⊑ is "information" order between values, for example 0:⊥ ⊑ 0:0:⊥
18:24:49 <lambdabot>  <local>:1:10:
18:24:49 <lambdabot>      Ambiguous type variable `b' in the constraints:
18:24:49 <lambdabot>        `T...
18:24:52 <hpc> > let lie = [[]] in cake == lie
18:24:52 <shachaf> > cast cake :: Maybe Bool
18:24:54 <lambdabot>   False
18:24:54 <lambdabot>   Nothing
18:24:58 <adnap> Eduard_Munteanu: i guess not.
18:25:06 <shachaf> > cast cake :: Maybe Bool -- It's not even a lie.
18:25:07 <adnap> it that bottom?
18:25:08 <lambdabot>   Nothing
18:25:16 <aristid> :t let a === b = cast a == cast b in (===)
18:25:17 <lambdabot> forall a a1. (Typeable a1, Typeable a) => a -> a1 -> Bool
18:25:20 <Jesin> > cake
18:25:20 <hpc> adnap: no, it's Nothing
18:25:20 <monochrom> ⊥ is bottome
18:25:21 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
18:25:27 <Eduard_Munteanu> < monochrom> flat = apart from bottom, x <non-strict inclusion> y implies x=y. or contrapositively, x/=y implies incomparable.
18:25:32 <adnap> Oh, i can't see it.  I just see goofy stuff.
18:25:34 <aristid> > let a === b = cast a == cast b in 4 == "4"
18:25:35 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
18:25:35 <lambdabot>    arising from the literal ...
18:25:43 <Jesin> > map (take 5) cake
18:25:45 <lambdabot>   ["One 1","One c","Three","Four ","One c","Three","One a","Two c","Don't","F...
18:25:48 <aristid> > let a === b = cast a == cast b in 4 === "4"
18:25:49 <JordiGH> Does functor have a common, fixed meaning in Haskell?
18:25:49 <lambdabot>   True
18:25:55 <hpc> > map (head . words) cake
18:25:57 <lambdabot>   ["One","One","Three","Four","One","Three","One","Two","Don't","Fish","Fish"...
18:26:01 <mauke> > True === False
18:26:01 <Eduard_Munteanu> monochrom: so you mean it relates to the definedness ordering?
18:26:02 <lambdabot>   Not in scope: `==='
18:26:07 <shachaf> > let a === b = cast a == cast b in 4 === "elephant"
18:26:07 <lambdabot>   True
18:26:14 <mauke> :-)
18:26:21 <Boxo> cast 4
18:26:25 <Boxo> > cast 4
18:26:26 <lambdabot>   Nothing
18:26:30 <adnap> what is "non-strict inclusion"?
18:26:31 <Jesin> umm
18:26:32 <monochrom> adnap: http://www.vex.net/~trebla/symbols/unleash.html?t=flat+%3D+apart+from+bottom%2C+x+%3Cnon-strict+inclusion%3E+y+implies+x%3Dy.+or+contrapositively%2C+x%2F%3Dy+implies+incomparable.
18:26:33 <Jesin> guys
18:26:36 <JordiGH> I guess it wouldn't make sense for functor in Haskell to mean what it means in C++.
18:26:36 <Jesin> [21:22:32]	<mm_freak>	> splitAt 7 . drop 27 . map head $ cake
18:26:38 <Jesin> [21:22:34]	<lambdabot>	("TOOTOOT","ASCIICAT")
18:26:38 <aristid> shachaf: ooh, (===) will return True for everything and i know why
18:26:42 <parcs> lambdabot must be very tired
18:26:42 <Jesin> how did you discover this?
18:26:44 <aristid> shachaf: defaulting for the evil
18:26:45 <shachaf> aristid: Not for everything.
18:26:51 <adnap> http://www.vex.net/~trebla/symbols/unleash.html?t=flat+%3D+apart+from+bottom%2C+x+%3Cnon-strict+inclusion%3E+y+implies+x%3Dy.+or+contrapositively%2C+x%2F%3Dy+implies+incomparable.
18:26:53 <Jesin> > map head cake
18:26:54 <adnap> http://www.vex.net/~trebla/symbols/unleash.html?t=flat+%3D+apart+from+bottom%2C+x+%3Cnon-strict+inclusion%3E+y+implies+x%3Dy.+or+contrapositively%2C+x%2F%3Dy+implies+incomparable.
18:26:55 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
18:26:58 <adnap> aw, sorry
18:26:59 <aristid> > let a === b = cast a == cast b in undefined === undefined
18:27:00 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:27:00 <lambdabot>    `Data.Typeable.Typeable a...
18:27:03 <monochrom> yes, "information" order is better called definedness order, I like that.
18:27:13 <aristid> > let a === b = cast a == cast b in (undefined :: Int) === (undefined :: String)
18:27:14 <lambdabot>   True
18:27:18 <mm_freak> JordiGH: basically a functor is a type constructor, which allows mapping over its elements of the parameter type
18:27:23 <mauke> aristid: your === is defective
18:27:26 <aristid> shachaf: make an example that returns False
18:27:27 <shachaf> Oh, never mind.
18:27:29 <aristid> mauke: i know.
18:27:46 <aristid> > let a === b = cast a == b in (undefined :: Int) === (undefined :: String)
18:27:47 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
18:27:47 <lambdabot>         against inferred ...
18:27:47 <mm_freak> :t fmap
18:27:47 <JordiGH> Great, functor in Haskell doesn't mean what it means in programming nor what it means in mathematics.
18:27:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:27:54 <aristid> > let a === b = cast a == Just b in (undefined :: Int) === (undefined :: String)
18:27:55 <lambdabot>   False
18:27:56 <monochrom> oops sorry adnap, wrong data. here: http://www.vex.net/~trebla/symbols/unleash.html?t=flat+%3D+apart+from+bottom%2C+x%E2%8A%91y+implies+x%3Dy.+or+contrapositively%2C+x%2F%3Dy+implies+incomparable.
18:27:58 <Eduard_Munteanu> http://www.vex.net/~trebla/symbols/unleash.html?t=flat+%3D+apart+from+bottom%2C+x⊑y+implies+x%3Dy.+or+contrapositively%2C+x%2F%3Dy+implies+incomparable. [+]
18:28:02 <shachaf> JordiGH: It means exactly what it means in programming.
18:28:02 <Eduard_Munteanu> Heh.
18:28:08 <mm_freak> JordiGH: yes it does mean what it means in math
18:28:18 <JordiGH> You two win.
18:28:19 <adnap> what is "
18:28:27 <mm_freak> JordiGH: look for category theory's functors
18:28:29 <adnap> non-strict inclusion"?
18:28:40 <Eduard_Munteanu> JordiGH: are there functors in C++?
18:28:43 <JordiGH> Category theory functors have got nothing to with types.
18:28:43 <Jesin> > let a === b = cast a == cast b in (undefined :: Int) === (let x = x in x :: String)
18:28:44 <lambdabot>   True
18:29:03 <mm_freak> JordiGH: yes they do in the Hask category, which is similar to Set
18:29:10 <mm_freak> because a type is in fact a set
18:29:12 <j-invariant> what are functors in Hask?
18:29:21 <Jesin> there's a Hask category
18:29:23 <Jesin> what
18:29:24 <j-invariant> functors in Hask are like Functor in haskell?
18:29:29 <Jesin> what's the Hask category?
18:29:37 <j-invariant> endo functors...
18:29:38 <monochrom> adnap: for example http://www.vex.net/~trebla/symbols/unleash.html?t=for+example+0%3A%E2%8A%A5+%E2%8A%91+0%3A0%3A%E2%8A%A5
18:29:39 <aristid> Jesin: the category of haskell types, i think
18:29:44 <Eduard_Munteanu> JordiGH: yeah, but technically functors in Hask are type operators.
18:29:47 <j-invariant> Why is it called Functor rather than EndoFunctor?
18:29:57 <JordiGH> A functor elsewhere in programming means a function object.
18:30:00 <Eduard_Munteanu> j-invariant: yeah, but technically functors in Hask are type operators.
18:30:10 <adnap> monochrom: is that the concat operator?
18:30:12 <Eduard_Munteanu> data Foo a = ...
18:30:12 <j-invariant> ah
18:30:14 <mm_freak> a haskell functor is always Hask → Hask
18:30:19 <Eduard_Munteanu> Foo :: * -> *
18:30:22 <mauke> JordiGH: only in c++
18:30:27 <monochrom> no, no concat here.
18:30:30 <Eduard_Munteanu> It is an endofunctor really
18:30:35 <adnap> monochrom: i see ":"
18:30:41 <monochrom> that is cons
18:30:44 <JordiGH> mauke: No, the concept exists elsewhere. I've seen it in Java and Python.
18:30:46 <Jesin> umm
18:30:48 <Jesin> btw
18:30:52 <adnap> monochrom: that's what i meant, sorry
18:30:56 <mm_freak> it maps objects from Hask (types) to objects in Hask:  a → F a
18:30:57 <Jesin> I may have asked this before but if I got an answer I don't remember it
18:31:00 <shachaf> JordiGH: Not by that name.
18:31:00 <Jesin> but anyway
18:31:03 <monochrom> concat operator is like "xxx"++"yyy", cons is like 'x':"yyy"
18:31:13 <adnap> monochrom: yes, i meant cons
18:31:25 <mm_freak> and it maps morphisms (functions) in Hask to Hask:  (a -> b) -> (F a -> F b)
18:31:44 <Jesin> could fmap be considered as a specialized instance of Control.Category.. ?
18:31:44 <adnap> monochrom: i don't see what this illustrates though.  i understand it's true though because i can see the elements zero and bottom in the larger set.
18:31:46 <j-invariant> but
18:31:57 <JordiGH> shachaf: Yes by that name: http://chaoticjava.com/posts/functors-in-java-and-beyond/
18:32:00 <j-invariant> it should be  (a ~> b) -> (Fa ~> Fb)
18:32:02 <j-invariant> different arrows
18:32:20 <j-invariant> I think the haskell "category theory" is a very simplified version of real category theory
18:32:32 <adnap> monochrom: is this an example of non-strict inclusion?
18:32:40 <okui_> 圏論
18:32:41 <monochrom> example of the partial order
18:32:52 <aristid> j-invariant: there's no "haskell category theory". just borrowed terms :)
18:32:56 <mauke> JordiGH: was that written by a C++ programmer?
18:33:10 <Eduard_Munteanu> That's like saying physics math is a very simplified real math.
18:33:16 <Jesin> "The fact that these functions are encapsulated by real objects is also the reason for its greatest benefit" lool
18:33:18 <monochrom> or rather, example of the definedness order
18:33:19 <JordiGH> looooool
18:33:27 <j-invariant> aristid: juts thinking.. maybe it would be simpler if we used non-category theory names?
18:33:34 <mm_freak> j-invariant: you could say, haskell makes limited use of CT =)
18:33:37 <adnap> monochrom: are they ordered by definedness?
18:33:41 <monochrom> yes
18:33:48 <Eduard_Munteanu> (It is, no one takes stuff like Banach-Tarski to be true.)
18:33:52 <aristid> j-invariant: that might bring less complaints about cargo cults, maybe. but Monad is such a nice and short name
18:34:03 <mm_freak> or rather, haskell uses a subset of CT's power
18:34:06 <Jesin> Eduard_Munteanu: what are you talking about?
18:34:13 <aristid> j-invariant: ProgrammableSemicolon or BurritoInSpacesuit don't have quite the same succinctness :)
18:34:18 * shachaf is of the opinion that category theory should import "warm fuzzy thing".
18:34:23 <Jesin> you can most certainly take it to be true of R^3
18:34:25 <Jesin> :p
18:34:28 <monochrom> in a flat type, you don't have many shades of definedness. you only have two: all-out bottom, all-out defined.
18:34:29 <JordiGH> mauke: Apologies if I've destroyed your worldview that functors were only appropriated by C++.
18:34:29 <j-invariant> mm_freak: in theory,  could you have a language that uses more of the power of category theory?
18:34:31 <Eduard_Munteanu> It is a usable, domain-specific subset of CT.
18:34:37 <mm_freak> j-invariant: you could do it like microsoft
18:34:43 <adnap> monochrom: what does this have to do with non-strict inclusion?
18:34:50 <mm_freak> forever :: ComputationExpression c => c a -> c b
18:34:52 <j-invariant> microsoft?
18:34:55 <j-invariant> oh lol
18:34:56 <Eduard_Munteanu> Jesin: yes, but not of RealWorld^3 :)
18:34:57 <adnap> monochrom: i'm still trying to understand what "flat" is.
18:34:58 <mauke> JordiGH: I know OCaml also uses the word
18:35:03 <Jesin> you don't necessarily have to believe that physical space is isomorphic to R^3
18:35:04 <monochrom> some other branches of math uses the same symbol for inclusion.
18:35:04 <Jesin> yes, exactly
18:35:25 <mauke> JordiGH: but java doesn't even let you overload operator()
18:35:41 <mm_freak> adnap: in simple terms, it's a type, which has only parameterless constructors
18:35:49 <Jesin> C++ lets you overload operator=
18:35:51 <mm_freak> data FlatType = A | B | C
18:35:57 <Jesin> which... wtf is with that, I don't get it
18:35:59 <Jesin> :p
18:36:04 <shachaf> Jesin: Why not?
18:36:13 <adnap> oh!  is non-strict inclusion just "subset", where it doesn't have to be a "perfect subset"?
18:36:20 <adnap> i can't see any symbols
18:36:25 <Eduard_Munteanu> It's not "subset".
18:36:31 <monochrom> you should really switch to utf-8
18:36:34 <adnap> what is inclusion?
18:36:40 <Eduard_Munteanu> It's less-than by the definedness ordering.
18:36:42 <mm_freak> j-invariant: i think haskell uses a good portion of CT and not too much
18:36:48 <Jesin> shachaf: I've never really gotten very far into C++
18:36:50 <Jesin> but
18:36:53 <mm_freak> i always found the category-extras package quite scary
18:36:54 <Eduard_Munteanu> *less-than-or-equal
18:37:01 <Eduard_Munteanu> mm_freak: yeah, it kinda is.
18:37:08 <j-invariant> if Hask is one programming language, would inter language commuication be a functor from Hask to Ruby (or whatever)?
18:37:11 <Jesin> that you can't just assume that assignment is always assignment
18:37:15 <monochrom> nothing to do with "inclusion", except that math symbols have strange names, ok?
18:37:16 <Jesin> seems a bit strange
18:37:23 <aristid> there is exactly one person understanding category-extras
18:37:28 <Jesin> hm?
18:37:33 <mm_freak> j-invariant: Hask is really like Set
18:37:34 <aristid> preflex: seen edwardk
18:37:34 <preflex>  edwardk was last seen on #haskell 3 days, 3 hours, 52 minutes and 27 seconds ago, saying: revenantphx: sorry, not familiar with the type signatures here in this lib, which is why i wanted to hack up something locally first ;)
18:37:38 <adnap> Eduard_Munteanu: inclusion is a binary operation?
18:37:47 <mm_freak> j-invariant: it's a category of sets together with functions
18:37:57 <Eduard_Munteanu> adnap: forget "inclusion".
18:38:21 <Eduard_Munteanu> adnap: that reads as x <= y, where '<=' stems from the underlying definedness ordering.
18:38:33 <monochrom> if you look up the latex code, it's \sqsubseteq. you will soon learn that latex code names mean nothing.
18:38:51 <adnap> Eduard_Munteanu: <= compares things by definednes, okay
18:39:33 <monochrom> for example if someone gives you ∪ you'll ask "what's that?" and someone will answer "\cup". you would think it has something to do with bras...
18:39:47 <Quadrescence> it does have to do with bras
18:39:49 <Eduard_Munteanu> monochrom: doesn't that say that in a flat type, apart from bottom, all other values have the same definedness?
18:39:50 <Quadrescence> also has to do with kets
18:39:52 <adnap> let me try to get utf8 working
18:40:04 <adnap> i think i will understand much faster
18:40:38 <monochrom> Yes. Int is a flat type. you have bottom, then you jump to 5 or 17 or 0.
18:40:52 <Eduard_Munteanu> Ah, I see.
18:40:58 <mm_freak> Eduard_Munteanu: a type is flat, iff x ≥ y for all elements x and y
18:40:58 <Jesin> ...
18:41:01 <Jesin> aaaah braket
18:41:48 <Random75> mm_freak: how is that possible? 
18:42:19 <mm_freak> Random75: ≥ is a partial order here…  it compares by definedness
18:42:32 <shachaf> Jesin: What does "assignment is always assignement" mean?
18:42:37 <adnap> ah, it's still not working
18:42:39 <mm_freak> don't confuse it with "greater or equal"
18:42:43 <adnap> i think it's 'cause i'm using putty
18:42:52 <adnap> normally, utf8 works fine on my server
18:42:58 <Random75> mm_freak: Ah, ok.
18:43:01 <Jesin> shachaf: I'm used to statements of the form "x = y" meaning assignment
18:43:09 <monochrom> putty can do utf-8 too but windows font misses some symbols
18:43:15 <Jesin> overriding operator= messes with that, if I recall correctly
18:43:26 <adnap> i don't want to mess with it since i wont be using this computer for very long
18:43:29 <shachaf> Jesin: Well, "assignment" means copying in this case, right?
18:44:05 <adnap> all i've understood so far is that you can order sets by definedness and there is an operator <= which does the ordering.
18:44:06 <monochrom> well you can always ask someone to use my http://www.vex.net/~trebla/symbols/unleash.html haha
18:44:16 <mm_freak> shachaf: writing to variables
18:44:21 <monochrom> no no, order values by definedness
18:44:22 <adnap> what else should i know?
18:44:29 <Eduard_Munteanu> Since Haskell, I now find C++'s idea of defining/overloading infix operators is really really limited.
18:44:36 <adnap> monochrom: right, i mean the values in the sets
18:44:38 <monochrom> but that's it
18:44:46 <shachaf> mm_freak: Yes, but writing what? :-)
18:44:46 <adnap> monochrom: not the sets themsel ves
18:45:03 <mm_freak> adnap: it's good to know that definedness is a partial order
18:45:07 <Eduard_Munteanu> adnap: no sets.
18:45:17 <aristid> Eduard_Munteanu: no wonder, haskell allows defining _arbitrary_ operators
18:45:18 <mm_freak> not a total one
18:45:24 <Jesin> shachaf: eh, I suppose so
18:45:24 <monochrom> isn't english great and perfectly clear? :)
18:45:30 <Jesin> like I said I haven't really used C++ much
18:45:39 <adnap> mm_freak: i know it is a partial order because it is not clear which bottom goes first in a set with two bottoms
18:45:42 <mm_freak> shachaf: whatever is on the right side =)
18:46:09 <Eduard_Munteanu> Bottoms up.
18:46:11 <adnap> Eduard_Munteanu: what about sets?
18:46:31 <monochrom> no, we don't allow two bottoms in one single type.
18:46:41 <adnap> monochrom: I was talking about a set
18:46:57 <adnap> monochrom: oh wait, i'm stupid
18:46:59 <monochrom> but we still have a partial order because for example inside Int we declare 5, 17 incomparable.
18:47:05 <adnap> monochrom: you can't have duplicate elements in a sety
18:47:20 <adnap> monochrom: nothing is comparable except to bottom, right>?
18:47:20 <Eduard_Munteanu> You misread our attempts to write down that UTF-8 in a manner you can read it.
18:47:45 <Eduard_Munteanu> Sets were never mentioned.
18:48:01 <adnap> Eduard_Munteanu: can you define a partial order without a set?
18:48:04 <Eduard_Munteanu> (unless yeah, you take the type as a set)
18:48:07 <testman> hey guys i clicked this link http://hackage.haskell.org.nyud.net/platform/contents.html
18:48:15 <monochrom> In [Int], 0:bottom <= 0:0:bottom. [Int] is not a flat type.
18:48:19 <testman> and it redirected me to http://planetflow.planet-lab.org
18:48:48 <Jesin> > splitAt 7 . map head . drop 27 $ cake
18:48:49 <monochrom> well then don't use nyud.net
18:48:50 <lambdabot>   ("TOOTOOT","ASCIICAT")
18:48:53 <testman> does this means that the haskell platform site is down or what?
18:49:22 <Eduard_Munteanu> @where platform
18:49:22 <lambdabot> http://hackage.haskell.org/platform/
18:49:33 <monochrom> just delete ".nyud.net"
18:49:35 <adnap> monochrom: is 0:bottom = 0:0:bottom, or is 0:0:bottom more defined than 0:bottom 'cause it has two zeros?
18:49:44 <Eduard_Munteanu> (and exert care when googling)
18:49:52 <monochrom> 0:0:bottom is more defined than 0:bottom
18:50:00 <adnap> monochrom: for the reason i gave?
18:50:06 <monochrom> reason: 0:bottom is more defined than bottom
18:50:25 <testman> ok know it linked correctly to http://hackage.haskell.org/platform/contents.html OK thanks
18:50:51 <adnap> monochrom: so, am i scanning the elements and comparing each one?
18:51:15 <monochrom> yes
18:51:18 <adnap> okay
18:51:39 <adnap> monochrom: so, i still don't get the "flat" thing.
18:51:49 <Eduard_Munteanu> monochrom: by the way, is that ordering set in stone by some definition, or is it generally arbitrary?
18:51:56 <monochrom> [Int] is not a flat type. Int is.
18:52:12 <adnap> i still don't know what it means to be flat
18:52:19 <adnap> what else do i need to know?
18:52:28 <Eduard_Munteanu> like Just 0:bottom vs 0:bottom bs (0, bottom)
18:52:35 <monochrom> flat = apart from bottom there is nothing to compare
18:52:45 <adnap> oh
18:52:58 <adnap> compare in terms of definedness?
18:53:01 <monochrom> yes
18:53:04 <Eduard_Munteanu> adnap: the rest are equal wrt definedness
18:53:08 <adnap> when is that ever not true?
18:53:18 <monochrom> [Int] is not a flat type
18:53:19 <Eduard_Munteanu> [Int], *sigh*
18:53:29 <monochrom> you need more memory
18:53:44 <adnap> but why?  aren't all ints equal in terms of definedness?
18:53:58 <Eduard_Munteanu> adnap: lists aren't equal in terms of definedness
18:54:00 <monochrom> are all [Int]s equal in terms of definedness?
18:54:04 <adnap> oh, right
18:54:13 <adnap> that example you gave
18:54:16 <adnap> now i get it
18:54:37 <adnap> 0:bottom and 0:0:bottom aren't equal in terms of definedness
18:54:54 <adnap> and they're of type [Int]
18:55:15 <monochrom> perhaps windows ate up all your memory
18:55:18 <Eduard_Munteanu> But 0, 1, 2, anything that inhabits Int has the same definedness.
18:55:35 <adnap> monochrom: it's not that i didn't remember each specific thing.  i just didn't make the connection.
18:56:03 <adnap> so, for something to not be flat, does it have to have multiple sort of values?
18:56:22 <adnap> like a list can hold multiple values
18:56:25 <monochrom> it needs non-strict constructors like cons
18:57:12 <adnap> what's a non-strict constructor?  i think i know, but i'm not sure.
18:57:25 <adnap> True is a strict constructor, right?
18:57:26 <monochrom> in haskell, constructor without "!"
18:57:59 <monochrom> hmm, True is probably agnostic about it. takes no parameter.
18:58:05 <Eduard_Munteanu> A non 0-ary non-strict constructor.
18:58:33 <adnap> But isn't Int defined like 0 | 1 | 2 | ...
18:58:44 <adnap> And Bool is True | False
18:58:44 <Eduard_Munteanu> '|' isn't a constructor.
18:58:50 <Axman6> adnap: no
18:58:52 <monochrom> Bool and Int are flat.
18:58:53 <Axman6> @src Int
18:58:53 <lambdabot> data Int = I# Int#
18:59:12 <monochrom> need constructor with parameters without "!" for non-flat
18:59:13 <adnap> right, i thought Bool and Int were flat
18:59:16 <Eduard_Munteanu> (but let's not get into that :) )
18:59:34 <Axman6> adnap: things like Int, Double etc are a little special in GHC, they are actually machine ints/doubles
18:59:59 <adnap> Axman6: meaning they don't have an infinity
19:00:12 <shachaf> > 1/0 :: Double
19:00:13 <lambdabot>   Infinity
19:00:17 <Eduard_Munteanu> So any actual rigourous definition of definedness? Or equivalently, a procedure of determining it.
19:00:28 <Eduard_Munteanu> (definedness as ordering)
19:00:42 <Eduard_Munteanu> adnap: no.
19:01:00 <monochrom> you could just axiomatize it. you could look at your operational semantics and deduce it.
19:01:03 <adnap> Eduard_Munteanu: the way i thought of int and integer was that int has an upper bound
19:01:16 <adnap> Eduard_Munteanu: a machine-determined upper bound
19:01:28 <shachaf> adnap: Integer has a machine-determined upper bound too.
19:01:32 <Random75> Is the a reference similar to the java API documentation but for haskell that lists all the typclasses and other things people might want to know?
19:01:47 <monochrom> the bound is irrelevant in this subject
19:02:01 <adnap> i thought integer was supposed to represent an ideal
19:02:06 <Eduard_Munteanu> Random75: look on...
19:02:10 <Eduard_Munteanu> @where hackage
19:02:10 <lambdabot> http://hackage.haskell.org/package/
19:02:14 <Eduard_Munteanu> @where hoogle
19:02:15 <lambdabot> http://haskell.org/hoogle
19:02:17 <Eduard_Munteanu> @where hayoo
19:02:17 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
19:02:28 <shachaf> adnap: No, it's limited by the amount of memory in your machine.
19:02:34 <Random75> Perfect, thanks Eduard_Munteanu 
19:02:48 <monochrom> why is it so easy to derail a discussion
19:03:01 <adnap> i think i'm being toyed with
19:03:06 <thermoplyae> entropy wins out
19:03:17 <j-invariant> adnap: an ideal?
19:03:17 <shachaf> @karma+ entropy
19:03:17 <lambdabot> entropy's karma raised to 1.
19:03:22 <j-invariant> adnap: you mean like ring theory?
19:03:32 <adnap> j-invariant: yeah, like the mathematical definition of an integer
19:03:44 <j-invariant> adnap: mathematical definition of integer is not based on ideals is it?
19:03:53 <Eduard_Munteanu> What do ideals have anything to do with this? :/
19:03:58 <shachaf> adnap: The mathematical definition of integers doesn't include "infinity". :-)
19:04:08 <monochrom> I'll let you take infinite time to verify that Integer does or does not have infinitely many values, so that you can come back and discover it's totally irrelevant to the definedness order.
19:04:25 <adnap> i guess let's go back to that
19:04:31 <adnap> although i think i understand what flat is now
19:04:52 <monochrom> You can easily define a flat type with infinitely many values. It doesn't even have to be called "Integer".
19:04:53 <adnap> what are some other examples of non-flat types besides [Int], or anything in a list for that matter?
19:05:07 <monochrom> or perhaps s/define/postulate/
19:05:11 <adnap> Is Either not flat?
19:05:20 <monochrom> Either is not flat.
19:05:34 <Eduard_Munteanu> Quite trivially though.
19:05:45 <adnap> Either bottom 0 is less defined than Either 0 bottom?
19:05:59 <shachaf> adnap: No. It's a partial ordering.
19:05:59 <Eduard_Munteanu> Either bottom 0 isn't a value.
19:06:12 <adnap> oh, whoops
19:06:18 <monochrom> Take Maybe for example. Actually let's pin down Maybe Bool.  there is (bottom of Maybe Bool). then there is Just (bottom of Bool), then there is Just True.
19:06:20 <Eduard_Munteanu> Left 0, for instance.
19:07:09 <monochrom> Left x and Right y are incomparable. Even when x,y may be bottom(s)
19:07:18 <adnap> monochrom: so bottom of Maybe Bool is less defined than Just undefined of bool
19:07:24 <monochrom> right
19:07:30 <adnap> monochrom: because at least you know the Just part?
19:07:34 <monochrom> yeah
19:07:37 <adnap> okay
19:08:10 <adnap> i guess i will go back to trying to understand this Conal blog post :P
19:08:22 <Eduard_Munteanu> Which one?
19:08:54 <adnap> well, actually a bunch of them, but i had to keep going back because they all depend on each other sort of
19:09:31 <adnap> i was on this one because it seemed to assume the least of the reader: http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice/
19:10:59 <monochrom> Eduard_Munteanu: So the usual presentation is like "Int, Bool... those very primitive types are flat. And then for general types B,C, we write down how to order BxC and how to order B+C, probably even B->C too". Usually you just say that's an axiom. Sometimes you also check that it is consistent with low-level computation.
19:11:07 <adnap> then "merging partial values" and then "lazier functional programming"
19:11:39 <adnap> monochrom: what "usual presentation".  is this a formally discussed topic?
19:11:55 <monochrom> yes. "programming language semantics"
19:11:58 <adnap> monochrom: did you learn this somewhere else other than #haskell?
19:12:00 <adnap> oh
19:12:10 <Eduard_Munteanu> monochrom: ah, so it's an inductive definition just like for 'depth'
19:12:23 <monochrom> I took great pain to read it from a 900-page book
19:12:26 <Eduard_Munteanu> which depends on the language itself.
19:13:02 <adnap> monochrom: wow, was it a good book?
19:13:27 <Eduard_Munteanu> (I'm curious about what book that was too.)
19:13:39 <monochrom> I don't know. I haven't compared.
19:14:04 <monochrom> It's Mitchell's "foundations for programming languages"
19:14:41 <adnap> what is "weak head normal form"?
19:15:10 <adnap> ah, sorry.  let me try to look that one up first.
19:15:11 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml is a glimps of my craziness
19:15:47 <monochrom> "introduction to lattices and order" is very good
19:15:48 <Eduard_Munteanu> That requires a bit of background though.
19:17:27 <andy_> can anyone recommend a good resource to learn about function dependencies, beyond the obvious places on the wiki?
19:18:30 <Eduard_Munteanu> andy_: do you mean functional dependencies?
19:18:40 <andy_> yes
19:18:49 <andy_> (its related to http://pastebin.com/xhhNjmW8 lines 151 to 161)
19:19:02 <andy_> ghc is not complaining, but hugs is
19:19:02 <Eduard_Munteanu> I think the Haskell prime proposal had some material on that too.
19:19:11 <andy_> ok
19:20:03 <Eduard_Munteanu> andy_: I don't think it's a good idea to use Hugs, at least not as a main choice.
19:20:19 <Eduard_Munteanu> @where platform
19:20:19 <lambdabot> http://hackage.haskell.org/platform/
19:20:22 <andy_> ok, mostly just trying to find out if ghc is being more permissive where it is maybe not completely correct
19:21:06 <andy_> it seems to be considering each dependency "clause" (not sure if its the correct term) independently
19:21:09 <andy_> i.e.:
19:21:27 <andy_> (the post is short, please excuse)
19:21:28 <andy_> class Invokevirtual a b c d e f | a b c -> e, d e -> f where
19:21:33 <ksf> https://events.ccc.de/congress/2010/Fahrplan/events/3983.en.html
19:21:37 <ksf> http://wmv.27c3.fem-net.de/saal2  (http://events.ccc.de/congress/2010/wiki/Documentation)
19:21:43 <ksf> ...that's MET, which is currently 04:20.
19:21:49 <ksf> (yeah I know I'm being OT)
19:21:52 <Eduard_Munteanu> GHC docs might be helpful too, although terse.
19:22:27 <andy_> ok, that sounds like the best resource - are functional dependencies formally defined across compilers?
19:22:44 <ksf> "From the theory standpoint, for a system that is a composition of several sufficiently complex parts, there is no general algorithm or formal method to deduce properties of the composed system even if properties of parts are known. (This can be reduced to the Halting Problem or, equivalently, to Rice's Theorem)"
19:22:47 <Eduard_Munteanu> andy_: they're a non-standard extension so far.
19:23:06 <Eduard_Munteanu> The standard (i.e. the report) doesn't include them.
19:23:09 <andy_> ok
19:23:27 <Eduard_Munteanu> The thing about Hugs is that it's old and probably unmaintained nowadays.
19:23:34 <andy_> in your opinion, are type associations more "correct" or often used?
19:23:37 <andy_> o
19:23:38 <andy_> ok
19:23:45 <andy_> was wondering about the "2006" part
19:23:50 <andy_> (on startup)
19:24:00 <Eduard_Munteanu> Heh.
19:24:00 <ksf> it's pretty bug-free, though.
19:24:28 <Eduard_Munteanu> andy_: from what I hear, asstypes do not cover fundeps completely.
19:24:49 <ksf> with closed classes, they would.
19:24:52 <ksf> at least afaiu
19:24:59 <andy_> ok
19:25:23 <ksf> in any case, typefams fit haskell's paradigm better.
19:25:53 <ksf> though fundeps make sense in some cases
19:26:01 <ksf> the actual evil part is overlapping instances.
19:26:20 <Eduard_Munteanu> Fundeps are also more clear than using asstypes for the same thing.
19:26:30 <ksf> depends on the thing.
19:26:48 <Eduard_Munteanu> For specifying fundeps, I mean :)
19:26:57 <ksf> as soon as you're doing any kind of computation, fundeps just become, well, prolog.
19:26:58 <andy_> i definitely agree on the clarity - with regards to succinctness - for where i have used it
19:27:01 <monochrom> I dislike overlapping instances
19:27:42 <ddarius> The type class system is already logic-y, fundeps actually make it -less- like prolog.
19:27:50 <monochrom> My dislike is probably irrational, stemming from having seen too much abuse by newbies.
19:28:29 <andy_> i should probably raise my hand now..
19:29:23 <monochrom> "oh, why can't I haz one behaviour for [Int], another behaviour for [Bool], and the third for other [a]s, just like my good old days with Java"
19:29:46 <andy_> or template specialization
19:29:56 <aristid> monochrom: part of the problem is that String is [Char], and not something different
19:29:59 <Jesin> hmm
19:30:30 <Jesin> http://www.haskell.org/haskellwiki/Class_system_extension_proposal
19:30:39 <andy_> Eduard_Munteanu, thanks for the help earlier
19:31:32 <ddarius> aristid: Now we have Text.
19:31:46 <Jesin> what
19:31:49 <Jesin> what is this Text
19:32:33 <aristid> ddarius: 99% (wild guess) of functions still use String
19:32:34 * qwr thinks that String = [Char] is a bit of design accident.
19:32:59 <Axman6> i think it works very well
19:33:06 <aristid> qwr: there are some reasons for it, i think. for example that way simple list functions can work on it
19:33:16 <Axman6> it has terrible performance, but makes learning haskell easier
19:34:11 <monochrom> haskell has head explode. sml has string explode.
19:34:11 <aristid> Axman6: the performance is not what bothers me. i'm bothered with the fact that you often want a different type class instance for Strings than for generic lists
19:34:13 <qwr> aristid: it probably could have been resolved with type class, where String/[a] are instances
19:34:25 <JoeyA> Actually, with fusion, String = [Char] can be really fast.
19:34:36 <JoeyA> (mainly for text processing things)
19:34:50 <Axman6> aristid: like OverloadedStrings?
19:35:01 * qwr has recently been bitten by lazy String memory usage
19:35:11 <aristid> Axman6: no, like showList
19:35:12 <JoeyA> like main = mapM_ putStrLn . filter (not . ('e' `elem`) . lines =<< getContents
19:35:13 <aristid> :t showList
19:35:14 <lambdabot> forall a. (Show a) => [a] -> String -> String
19:35:39 <aristid> > showList [1,2,3] "x"
19:35:40 <lambdabot>   "[1,2,3]x"
19:35:46 <aristid> > showList "abc" "x"
19:35:47 <lambdabot>   "\"abc\"x"
19:36:03 <JoeyA> err, main = mapM_ putStrLn . filter (not . ('e' `elem`)) . lines =<< getContents
19:36:12 <Eduard_Munteanu> JoeyA: does 'lines' fuse there?
19:36:28 <aristid> JoeyA: notElem makes that nicer
19:36:31 <aristid> :t notElem
19:36:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:36:36 <JoeyA> Thanks
19:37:26 <JoeyA> I recently wrote a program in Haskell to find the length of the longest line.
19:37:43 <JoeyA> I first used ByteString, and it turned out to be really slow (and it leaked memory, IIRC).
19:37:51 <JoeyA> When I used regular String, it went vroom.
19:37:53 <qwr> JoeyA: and the String/ByteString feels a bit like C++ const char*/std::string, where literals are one thing, but for real work you want some another type...
19:38:11 <Eduard_Munteanu> JoeyA: are you sure you didn't misuse ByteString? It's really easy :)
19:39:06 <Eduard_Munteanu> unpack is quite bad for example.
19:39:39 <aristid> Eduard_Munteanu: are concat and intercalate good?
19:40:23 <Eduard_Munteanu> Hm, I don't know how those perform in BS.
19:40:50 <aristid> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/src/Data-ByteString.html#concat
19:40:58 <aristid> and intercalate is implemented in terms of concat
19:41:01 <aristid> so that should be OK
19:41:52 <Eduard_Munteanu> They look ok.
19:42:04 <qwr> JoeyA: ByteString has the property where drop/take (and probably other functions taking slices) retain reference to the original string unless you copy. or was the leak something else?
19:42:11 <Eduard_Munteanu> At least if you don't have many tiny bytestrings.
19:42:43 <ddarius> If he was using strict bytestrings and the file was large, a strict bytestring readFile/getContents will read it into memory entirely.
19:43:14 <Eduard_Munteanu> Ah, that too. ByteString.Lazy is the main thing to use.
19:44:55 <aristid> Eduard_Munteanu: i'm not sure about that.
19:45:22 <aristid> but i guess if you can, you should use Text
19:45:23 * Eduard_Munteanu thinks Bytestring should include a mapM_
19:45:48 <Eduard_Munteanu> aristid: ah, I've been using ByteString mostly for binary data.
19:45:52 <JoeyA> Hmm, I tried it again, and now it's faster
19:46:01 <JoeyA> Not sure what I did for the slower version.
19:46:23 <Eduard_Munteanu> JoeyA: do you use -O or -O2 ?
19:46:27 <JoeyA> -O2
19:46:31 <JoeyA> I use -O2 by habit.
19:47:05 <Eduard_Munteanu> It's fine.
19:48:35 <banisterfiend> which is the best haskell book for noobs?
19:48:39 * hackagebot kit 0.6.1 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.1 (NickPartridge)
19:48:47 <Eduard_Munteanu> @where lyah
19:48:47 <lambdabot> http://www.learnyouahaskell.com/
19:48:47 <Axman6> @whhere lyah
19:48:48 <lambdabot> http://www.learnyouahaskell.com/
19:48:51 <Eduard_Munteanu> Heh.
19:48:52 <Axman6> banisterfiend: ^^^^^
19:48:58 <banisterfiend> no i mean a dead tree book :)
19:49:06 <gwern> lyah will be dead tree soon
19:49:19 <gwern> banisterfiend: because of monsters like you. won't someone think of the seedlings?
19:49:20 <djahandarie> banisterfiend, easy, just kill the trees yourself
19:49:22 <Eduard_Munteanu> I think RWH is already, isn't it?
19:49:24 <banisterfiend> sweet, but what about say, "real world haskell" ?
19:49:39 <gwern> banisterfiend: well naturally
19:49:44 <banisterfiend> is that good?
19:49:48 <Axman6> real world haskell is better once you know a little haskell
19:49:52 <gwern> is eating meat good?
19:50:02 <Eduard_Munteanu> RWH is a little more technical, but it's good. (as far as I read through)
19:50:16 <Axman6> i would not recommend it to a complete beginner, because it introduces the basics very quickly
19:50:27 <monochrom> the best book is the 3rd book you read.
19:50:30 <Eduard_Munteanu> (I actually know less about LYAH, but I keep recommending it because everybody here does :D)
19:50:34 <banisterfiend> by complete beginner, do you mean beginner to haskell or beginner to programming?
19:50:51 <gwern> I thought RWH's comments system was the cat's pyjamas
19:50:53 <Eduard_Munteanu> monochrom: heh, that's so true.
19:51:01 <gwern> (although I was mildly miffed I didn't make it into the credits)
19:51:29 <monochrom> I completely fail to understand the obsession with "what is the absolutely best book so I only need to read once"
19:51:46 <banisterfiend> ok, what other dead tree book besides RWH (which seems a bit advanced for me) what other dead tree books do you guys recommend?
19:51:46 <monochrom> won't work. learn programming in 10 years.
19:51:47 <ksf> your own mind.
19:51:51 <banisterfiend> slightly less advanced
19:52:00 <ksf> once you understand your preconceptions about a topic, you're bound to win.
19:52:09 <Axman6> banisterfiend: i mean a beginner to haskell, because being proficient with other languages make it even harder to learn haskell ;)
19:52:40 <banisterfiend> hehe
19:52:41 <ksf> banisterfiend, the wizard book.
19:52:53 <banisterfiend> ksf: what's it called?
19:52:57 <ksf> while it's not haskell, it's still one of the best ways to get the mindset rigth.
19:53:04 <banisterfiend> haha ok
19:53:07 <ksf> structure and interpretation of computer programs
19:53:13 <bombshelter13b> Axman6: I don't think that last part is actually true.
19:53:27 <ksf> ...first google hit for "wizard book", actually.
19:53:35 <Jesin> [22:52:46]	<bombshelter13b>	Axman6: I don't think that last part is actually true.
19:53:37 <Jesin> nor do I
19:53:43 <ksf> the lectures are great, too.
19:54:07 <Jesin> Python, for example, is not at all damaging for this I think
19:54:09 <Jesin> :p
19:54:15 <Axman6> bombshelter13b: like most things, i don't believe it to be completely true either, but there is truth to it
19:55:13 <ksf> banisterfiend, also do watch http://blip.tv/file/324976
19:55:26 <ksf> (slides are linked from the description)
19:55:26 <Eduard_Munteanu> monochrom: there is some truth to that, Teaching / writing books isn't easy, despite the enormous dead tree material out there.
19:56:08 <Eduard_Munteanu> They almost always have parts which could be improved.
19:56:49 <Jesin> so does the actual language
19:56:59 <Jesin> what with Monad not being explicitly related to Functor and so on
19:57:07 <Jesin> :p
19:57:09 <Eduard_Munteanu> (That being said, I don't advocate "learn yourself C in 2 days" or that kinda stuff, but books/teaching should be taken really seriously)
19:57:13 <monochrom> well you can possess the perfect book and you still have to read it 3 times. it's really PEBBAC
19:57:29 <Eduard_Munteanu> That's true as well.
19:57:58 <monochrom> something about the unwritable human mind that needs sheer repetition until it "gets it".
19:58:17 <Eduard_Munteanu> But I can't fail to notice how every teacher out there feels compelled to come up with his own material. Which usually sucks.
19:58:21 <ksf> most of all, it needs processing time.
19:58:38 <ksf> time to connect the dots, that is.
19:59:48 <Eduard_Munteanu> So I can understand if someone asks for a better book hoping to learn faster, if not in 48hrs.
20:00:58 <monochrom> I am more sympathetic to teachers who come up with their own material. Most existing books are way overpriced.
20:01:30 <monochrom> Of course I don't sympathesize with those who do this to eventually join the overpriced club.
20:01:37 <Eduard_Munteanu> That's true, but it's a different issue.
20:03:28 <Random75> Eduard_Munteanu: Teachers that cannot come up with their own material are worse IMHO. My real analysis class was literally memorizing the definitions and thereoms of the text, and memorizing the proofs to the thereoms. No original proofs.
20:03:29 <Eduard_Munteanu> I'm all for competition and free material, so that being said, someone up to the job can come up and take the best of RWH and LYAH. But I'd be suspicious of reinventing the wheel.
20:04:08 <djahandarie> I'd like a teacher who could come up with his own material if he wanted but doesn't bother and focuses more on the teaching :)
20:04:15 <Eduard_Munteanu> Random75: maybe, but I think they can't either way. They just strive to, but end up doing a really mediocre job.
20:04:27 <gwern> exercises are the real value in textbooks
20:04:34 <ksf> figuring out what exactly your students aren't getting is way more important.
20:04:37 <gwern> to me, anyway. I can turn them into flashcards and whatnot
20:05:08 <ksf> ...though university-level students are supposedly able to do that on their own.
20:05:11 <monochrom> I can turn students into flashcards too. Err wait...
20:05:35 <ksf> In reality, you have to be knuth or similar to do that. and nobody's teaching it.
20:05:39 <gwern> ksf: well, exercises help with that too - what did you get right or wrong etc
20:05:48 <Eduard_Munteanu> ksf: yeah. And I'm of the opinion that teachers aren't there to teach, but to give guidance and answer questions. There should be more time left for questions than lecturing.
20:05:57 <Eduard_Munteanu> (of course, that requires some discipline from the students)
20:05:59 <ksf> absolutely
20:06:09 <ksf> well work or fail exams.
20:06:21 <Random75> Are you guys grad students?
20:06:26 <ksf> nope.
20:06:46 <djahandarie> Grad students don't have time for IRC
20:06:49 <Eduard_Munteanu> *Under*grad here, yes.
20:06:52 <Eduard_Munteanu> :)
20:06:53 <Axman6> me too
20:06:58 <djahandarie> Me three!
20:07:00 <Random75> Eduard_Munteanu: CS?
20:07:02 <Veinor> me four!
20:07:03 <ksf> I'm an incurable autodidact.
20:07:16 <qfr> Not I! I am unemployed
20:07:34 * Axman6 is employed and an undergrad
20:07:44 * Random75 is too. 
20:07:49 <Eduard_Munteanu> Random75: not really. My faculty is engineering CS, but I'm in the automation / systems engineering department.
20:07:49 <djahandarie> I think 95% of the undergrads who are regulars here just talked
20:08:03 * djahandarie thinks of ezyang
20:08:20 <gwern> @quote grad.*student
20:08:21 <lambdabot> PaulGraham says: "There are few sources of energy so powerful as a procrastinating grad student."
20:08:30 <gwern> @quote grad.*student
20:08:30 <lambdabot> PaulGraham says: "There are few sources of energy so powerful as a procrastinating grad student."
20:08:34 <Eduard_Munteanu> (But basically my studies have nothing to do with Haskell.)
20:08:45 <gwern> hm. I should have a quote in there about dead-end grad students and #haskell
20:08:51 <djahandarie> gwern, hey! I feel like I haven't seen you for awhile
20:09:27 <djahandarie> Except the other ~10 times you talked today
20:09:31 <djahandarie> But not before that for awhile
20:09:45 <gwern> @quote OlinShivers
20:09:45 <lambdabot> OlinShivers says: Oh, yes, the *acknowledgements*. I think not. I did it. I did it all, by myself.
20:10:00 <gwern> djahandarie: yeah, I've been off IRC trying to get things done
20:10:14 <djahandarie> :(
20:10:35 <gwern> face it, irc do be a timesink
20:10:43 <Eduard_Munteanu> It is.
20:10:46 * djahandarie doesn't want to face it!
20:11:10 <djahandarie> I learn everything from my procrastination timesinks anyways, so this is a good place to be anywho
20:12:05 <djahandarie> I imagine if I wanted to get something done I'd get off IRC and use that period of confusion about how to procrastinate to actually get stuff done
20:12:16 <gwern> so then you understand
20:12:22 <djahandarie> But it'd only work for awhile, I'd eventually find something else
20:12:32 <djahandarie> And it'd probably more of a waste than chatting in here
20:12:38 <Eduard_Munteanu> < ksf> ...though university-level students are supposedly able to do that on their own.   -- indeed
20:14:06 <Jesin> I've been putting off homework while learning about haskell  :(
20:14:08 <Eduard_Munteanu> I usually find they don't guess what I don't get too well.
20:14:18 <Jesin> (I'm not even out of high school yet)
20:15:14 <Random75> Eduard_Munteanu: Isn't that the purpose of a test?
20:15:39 <Random75> Eduard_Munteanu: or at least seeing what the professor thinks you should know fully
20:16:11 <Jesin> rraar
20:16:16 <Jesin> haskell is too interesting  =/
20:16:16 <Eduard_Munteanu> Random75: usually tests are structured to give grades, not find what people don't get.
20:17:12 <Jesin> hopefully I'll get far enough to finally be able to get tired of it soon
20:17:14 <Jesin> :p
20:17:36 <Random75> Eduard_Munteanu: Bad grades = you don't understand :) But i see your point.
20:17:39 <Eduard_Munteanu> If I don't know how to solve an exercise, it might be because I don't know how to get from point A to point B. But the teacher can't usually see that.
20:19:03 <Eduard_Munteanu> Constructive teaching: find out what your students don't get, not simply that they don't get something :)
20:20:14 <monochrom> Lazy constructive teaching: interact (\s -> "any questions?" ++ f s)
20:20:43 <Eduard_Munteanu> Heh.
20:21:20 <Random75> monochrom: We don't have time for questions or examples! There's just too much information I have to regurgitate from the book onto the board! 
20:22:37 <Eduard_Munteanu> Usually it goes like 'interact id' or the just as useless "any questions" appended to id's output ;)
20:23:17 <Eduard_Munteanu> Now seriously, students should read materials _before_ class.
20:25:07 <Eduard_Munteanu> 'read book >> code >> ask on #haskell' would work a lot better if adopted into univ teaching
20:25:49 <Random75> Would doing all the excerises I have to write in matlab for my numerical analysis class be a good way to learn haskell?
20:26:00 <gwern> Eduard_Munteanu: but we don't want to throw away the results of read book or code!
20:26:12 <Eduard_Munteanu> Heh, that's a point.
20:26:21 <gwern> Random75: think so, as long as you don't get caught up in high performance considerations
20:26:26 <Eduard_Munteanu> Random75: for some things yes, but it will be annoying.
20:26:28 <Kaidelong> Random75: depends on the exercises
20:26:29 <Axman6> Random75: depends on what sort of exercises they are.
20:26:42 <ion> gwern: That syntax doesn’t exactly mean throwing out the results, depending on how the monad is implemented. :-P
20:26:59 <monochrom> onoes, sneaky state monad
20:27:05 <gwern> ion: then what would >>= correspond to in that monad?
20:27:12 <Axman6> some things can be very nice in haskell, some things can be very nice in haskell and slow, and some things need a fair bit of experience to make them nice in haskell
20:27:21 <Eduard_Munteanu> Well certainly IO doesn't throw away side-effects :)
20:27:21 <ion> gwern: “I want the result in a variable i can do stuff with”
20:27:30 <Axman6> (talking about numerical code specifically)
20:27:31 <variable> .....
20:27:32 <gwern> monochrom: im in ur do-blocks appending ur states
20:27:36 <ion> variable: Yes, you.
20:28:13 <Random75> Axman6: thanks
20:28:35 <monochrom> <student> I am not just a student number! <variable> I am not just a variable!
20:28:41 <Axman6> Random75: got any examples?
20:28:51 * Axman6 mutates variable 
20:28:58 * variable is a constant 
20:29:00 <gwern> @quote free.variable
20:29:01 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
20:29:03 <banisterfiend> is this a good explanation of monads: http://www.codecommit.com/blog/ruby/monads-are-not-metaphors
20:29:04 <banisterfiend> ?
20:29:24 <Axman6> i got bored by it and didn't finish, so i couldn't tell you
20:29:27 <djahandarie> banisterfiend, a good explanation of monads is one that doesn't start with monads
20:29:29 <monochrom> not sure what ruby is doing there
20:29:30 <BMeph> CBA
20:29:35 <Random75> Axman6: not yet, I am taking a numerical analysis couse next semester. The focus is for us math majors to learn some programming in matlab and get an overview of of numerical analysis
20:29:57 <djahandarie> banisterfiend, learnyouahaskell does a good job, use it.
20:30:27 <Axman6> Random75: matlab makes some things very nice, haskell can make some other things very nice. it depends on the task (i've used matlab and haskell for university assignments)
20:31:17 <Eduard_Munteanu> Apart from some functional idioms and "easy" matrix manipulation, Matlab is a really sucky language.
20:31:47 <Axman6> sure, the language sucks, but the tools are awesome
20:32:17 <eric_nl_> I've been reading the source to SamplerVar
20:32:22 <eric_nl_> specifically http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/src/Control-Concurrent-SampleVar.html#isEmptySampleVar
20:32:24 <Axman6> Simulink is fantastic
20:32:34 <Random75> im looking forward to the class because it'll be the first class that I have that is applied math and it also uses computers
20:32:59 <eric_nl_> I was wondering if someone knew why isEmptySampleVar is testing (readers == 0) instead of (readers <= 0)
20:33:00 <Eduard_Munteanu> Axman6: yeah, it's nice. I hear Scilab and maybe Octave got themselves some sort of Simulink these days.
20:33:30 <monochrom> perhaps because readers is never < 0
20:33:41 <Eduard_Munteanu> Now if only one would make an FRP Simulink-like thingy in Haskell ;)
20:33:50 <monochrom> oh, nevermind
20:33:57 <eric_nl_> yeah
20:34:06 <eric_nl_> it seems to come down to the semantics of what an "empty" SampleVar is
20:34:21 <qfr> <banisterfiend> is this a good explanation of monads: http://www.codecommit.com/blog/ruby/monads-are-not-metaphors
20:34:22 <Axman6> Eduard_Munteanu: well, i'm sure you could, but i'm not sure how easily
20:34:26 <qfr> Scala?! Really?
20:34:46 <eric_nl_> the docs sort of suggest that SampleVars are either "filled" or "empty", but then isEmptySampleVar is testing something different
20:35:21 <Axman6> the definition of SampleVar states that 1 = filled, 0 = empty
20:35:47 <eric_nl_> so < 0 will be neither empty nor filled?
20:35:54 <Axman6> not sure
20:36:03 <sshc> If I have a data type that encompasses a value of any type that is in a type class (for example, "data Foo = Bar :: forrall a. (Show a) => a"), which extension should I use?
20:36:06 <eric_nl_> yeah, I think the docs could be more clear
20:36:45 <Eduard_Munteanu> newtype SampleVar a = SampleVar ( MVar ( Int    -- 1  == full -- 0  == empty -- <0 no of readers blocked
20:37:02 <Adamant> qfr: it's pretty good, actually. I think explaining monads as a mathematical object works a lot better for most programmers than weird analogies
20:37:50 <qfr> Adamant: I don't know Scala, I stopped  following at the defun x = new { defun } part
20:37:56 <Eduard_Munteanu> I presume it might be overlapping some info there, like it's either empty, or <full or some readers blocked>
20:38:16 <Adamant> qfr: Scala is kinda oogly visual-wise, but it's an OK language
20:38:16 <qfr> I have no idea what the difference between defun a = b and defun a = defun b and defun a = new { b } and defun a = new { defun b } is
20:39:24 <Adamant> return b, return function b, return new instance of b, and return new instance of function b
20:39:26 <Adamant> IIRC
20:39:41 <monochrom> sshc: it should be "data Foo = forall a. (Show a) => Bar :: a". ExistentialQuantification
20:39:41 <qfr> Instance? Hmm
20:39:44 <BMeph> Just a friendly warning; Our Faavorite Commentator is up to more fun: http://stackoverflow.com/questions/4559399/can-parser-combination-be-made-efficient
20:39:57 <Adamant> I just started with Scala and Clojure so I could be wrong
20:40:15 <eric_nl_> hmm... how can I find out who the maintainers of Control.Concurrent.SampleVar are?  should I write haskell-cafe?
20:41:07 <sshc> The ExplicitForAll field has a typo in http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/flag-reference.html
20:41:16 <j-invariant> "is it possible to write parser combinators that generate state machines to obtain competitive performance or is it necessary to use code generation?" <--- generating a state machine *IS* code generation
20:41:28 <monochrom> heh
20:42:12 <j-invariant> why is he comparing a parsec code with direct style implementation?
20:42:22 <j-invariant> ...in a different language
20:42:24 <j-invariant> LOL
20:42:24 <monochrom> yeah, false dichotomy
20:42:26 <j-invariant> this guys mad
20:42:34 <j-invariant> it should bothe be haskell or both be ocaml
20:42:40 <j-invariant> oh that's f#... couldn't tell
20:43:30 <Adamant> j-invariant: he's an idiot who latches onto functional languages he thinks he can derive commercial benefit from then shits on any possible competitor
20:43:39 <j-invariant> hehe
20:43:51 <Adamant> he's been doing the same gig for almost a decade now
20:43:57 <monochrom> it is like the old "recursion is slow, loop is fast"
20:44:01 <j-invariant> anyway you can't compile parsec to state machine for various reasons
20:44:22 <j-invariant> the way it does recursion, the computational class .. etc
20:44:34 <Axman6> Adamant: JDH?
20:44:36 <monochrom> first of all source-code-level recursion and loop may very well become something completely different in machine code.
20:44:40 <Adamant> there was some nice new paper on using parser combinators for new stuff
20:44:44 <Adamant> Axman6: Harrop, yes
20:45:00 <Axman6> could be Harrop with that description :P
20:45:19 <Axman6> could only be*
20:45:22 <Adamant> Axman6: it's definitely Harrop, who else would I be talking about? :P
20:45:25 <Adamant> ah right
20:45:34 <monochrom> asking for speed is ok. setting up false debate between combinators and speed is wrong.
20:46:10 <Eduard_Munteanu> His question looks legitimate to me.
20:46:19 <Axman6> i would love to see a parser library that translates itself to LLVM (using the llvm package) and see how it performs
20:46:35 <Adamant> hand-hacked parsers are more likely to be fast if done right. they're also more likely to be buggy and incomplete for some valid inputs
20:46:36 <monochrom> not legitimate, on account of false equivalence "state table = speed"
20:46:52 <Adamant> even if done "right"
20:46:55 * hackagebot wai-handler-devel 0.1.1.2 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.1.1.2 (MichaelSnoyman)
20:47:23 <Eduard_Munteanu> I mean, code generation vs parser combinators.
20:47:26 <monochrom> "how to do a parser combinator lib that competes with yacc speed" would be legitimate.
20:47:44 <monochrom> See also the stupid internet shootout.
20:47:49 <Adamant> if done in languages that allow memory corruption, they're also a rich, tempting source of security vulnerabilities
20:48:14 <monochrom> "this benchmark measures the speed of your hash table!" wrong thing to measure.
20:48:40 <monochrom> "this benchmark measures the speed of your parameter passing!"
20:48:56 <djahandarie> It shouldn't be hard to come up with a solution that performs better than whatever he has
20:49:31 * djahandarie attempts
20:49:48 <monochrom> "code generation vs parser combinators" is a false dichotomy
20:49:50 <Random75> Who is this guy?
20:50:00 <Eduard_Munteanu> Those still look legitimate to me as long as you don't derive faulty conclusions from such synthetic benchmarks.
20:50:20 <monochrom> ok, s/legitimate/irrelevant/
20:50:22 <monochrom> err
20:50:26 <monochrom> ok, s/legitimate/elevant/
20:50:38 <monochrom> sigh. s/legitimate/relevant/
20:51:21 <djahandarie> I need a nasty expression to test this with
20:51:35 <Eduard_Munteanu> monochrom: well it theoretically is a false dichotomy, but wouldn't you accept it as a practical fact that compilers could generate better machine code if fed such a generated parser vs a combinator library + some code?
20:52:10 <Eduard_Munteanu> The bounds are blurry, yeah, but...
20:52:21 <Adamant> Eduard_Munteanu: normally yes, but there's been some interesting research lately on making parser generators more efficent and general.
20:52:42 <Adamant> gah, parser combinators
20:52:44 <Adamant> sorry
20:53:24 <monochrom> you can already conceive a parser combinator lib that gens code. there is no "vs".
20:53:26 <ManateeLazyCat> Hi all. :)
20:53:47 <Eduard_Munteanu> Hey ManateeLazyCat 
20:53:59 <ManateeLazyCat> Eduard_Munteanu: Hi. :)
20:54:07 <monochrom> and then, I only accept "gen code is faster than not gen code, so far". I fully expect surprises in the future.
20:54:38 <ManateeLazyCat> Any IDE idea are welcome, i'm working on it.
20:55:00 <ManateeLazyCat> My plan is provide best Haskell IDE for haskell programming.
20:55:42 <Eduard_Munteanu> That's true, monochrom 
20:55:47 <ManateeLazyCat> s/plan/aim
20:56:15 <ManateeLazyCat> Hmm, head still not clear ....
20:56:17 <monochrom> Asking for more speed is always good. But I'm tired of presumptions about which method has what speed.
20:59:17 <monochrom> You look at his question and you almost feel it is from a dishonest politician. OK, I, not necessarily you. "Are you with us or are you with the terrorists?"
21:00:30 <banisterfiend> ManateeLazyCat: are you from china?
21:00:35 <ManateeLazyCat> banisterfiend: Yes.
21:01:57 * ManateeLazyCat I will goto buy notebook, i want a ThinkPad...
21:02:22 <roconnor> goto is evil
21:02:39 <ManateeLazyCat> roconnor: mplayer use goto everywhere. :)
21:03:10 <monochrom> I use goto everywhere.
21:03:21 <ManateeLazyCat> Haha. :)
21:03:27 <banisterfiend> ManateeLazyCat: wow, will you go gentle on us when china takes over
21:03:29 <Eduard_Munteanu> 'goto' is fine if used in the right places.
21:03:39 <monochrom> I use goto everywhere in haskell.
21:03:53 <Eduard_Munteanu> call/cc? :)
21:04:26 <monochrom> f x = goto x 0 where goto 0 n = n; goto x n = goto (x-1) (n+1)
21:04:48 <ManateeLazyCat> If you think any awesome IDE idea, mail me (lazycat.manatee@gmail.com), i will help you implement it.
21:04:55 <monochrom> I am not joking. Function call subsumes goto.
21:05:01 <ManateeLazyCat> Use Haskell IDE develop Haskell!
21:05:09 <Eduard_Munteanu> Hm.
21:05:22 <monochrom> of course adding call/cc is even more fun
21:05:53 <banisterfiend> can i get haskell to return the source for a function?
21:05:58 <banisterfiend> like function.source ?
21:06:00 <monochrom> no
21:06:24 <banisterfiend> that's not very 31337
21:06:32 <Eduard_Munteanu> lambdabot can
21:06:37 <Eduard_Munteanu> You can install it locally.
21:06:52 <Eduard_Munteanu> @src head
21:06:52 <lambdabot> head (x:_) = x
21:06:52 <lambdabot> head []    = undefined
21:07:04 <Random75> @lambdabot
21:07:05 <lambdabot> Unknown command, try @list
21:07:07 <ManateeLazyCat> banisterfiend: This need IDE help, jump function define...
21:07:07 <monochrom> you're welcome to implement a haskell interpreter or compiler that can. then I will ask you about (goto 5).source
21:07:28 <Eduard_Munteanu> Heh.
21:07:32 <ManateeLazyCat> Haha. :)
21:08:16 <monochrom> "see source code" is for communities such as PHP's that aren't fond of writing clear precise docs.
21:08:40 <ManateeLazyCat> And GHC, see source code is only way.
21:08:53 <bombshelter13b_> why isn't the source code for that the portion to the left of the period?
21:09:00 <j-invariant> "is it possible to write parser combinators that generate state machines to obtain competitive performance or is it necessary to use code generation?" <--- What languge would you use and what automaton would you use for parsing?
21:09:18 <monochrom> machine language and x86 automaton
21:09:30 <banisterfiend> ManateeLazyCat is a ruby programmer, it's his favorite language
21:09:46 <ManateeLazyCat> banisterfiend: I'm not ruby guy.
21:10:02 <j-invariant> context free languages have nondeterministic automatta
21:10:05 <j-invariant> so you can't use them
21:10:07 <ManateeLazyCat> My Japanese friend use Ruby a lots.
21:10:10 <monochrom> I for one wouldn't want to see source code. I want to see well-written doc. Tell me what it does, I don't care how it's done.
21:10:15 <banisterfiend> ManateeLazyCat: but you like ruby
21:10:25 <ManateeLazyCat> banisterfiend: How do you know that?
21:10:26 <j-invariant> it must be weaker than context free but it can't be deterministic context free because it's undecidable whether a grammar is one of those or not
21:10:40 <ManateeLazyCat> banisterfiend: I even not write ruby code.
21:11:30 <banisterfiend> ManateeLazyCat: oh ok, sorry. 
21:11:30 <ManateeLazyCat> I love Haskell, that's ture.
21:11:38 <monochrom> things like LR(k)
21:14:08 <j-invariant> http://en.wikipedia.org/wiki/LR_parser this is really complicated...
21:14:18 <monochrom> absolutely
21:14:32 <otzi> hello. I'm trying to compile a package that generates a .buildinfo after I run ./configure. How I make cabal read that buildinfo? Do I need to do something in Setup.hs? Is there a way for cabal to call configure by itself?
21:14:35 <monochrom> I actually celebrate that I don't know it.
21:15:07 <monochrom> Best decision ever about my brain cells.
21:16:10 <ManateeLazyCat> otzi: Look http://hackage.haskell.org/packages/archive/Cabal/1.2.3.0/doc/html/Distribution-Simple.html
21:16:34 <monochrom> hrm, 1.2.3.0 sounds old
21:20:47 <otzi> ManateeLazyCat: could you be more specific? I can't quite find what I need to do there
21:21:14 <roconnor> is there any reason not to use LL-infinity parsers today?
21:21:55 <otzi> PackageDescription and LocalBuildInfo seems related, but the format of .buildifno doesn't seem the same format as dist/setup-config
21:21:59 <roconnor> It's not like it is 1970
21:22:25 <monochrom> @quote ray 1970s
21:22:25 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
21:22:29 <monochrom> there
21:22:39 <roconnor> ah
21:22:49 <otzi> also, .buildinfo complemens information, it doesn't have all that dist/setup-config has
21:23:25 <otzi> I use urxvt
21:23:35 <otzi> it's a modern terminal
21:24:40 <monochrom> more concretely, we may be talking about C programmers. their mindset is like "char buf[1000]". you have to give them a finite number. if you say "LL(1000)" they can just go "char buf[1000]". if you say "LL(infinity)" they don't know what to write in place of "1000".
21:24:56 * roconnor misses using presentation manager
21:25:23 <monochrom> oh oh oh! I knew how to program presentation manager a bit too.
21:25:44 <otzi> INT_MAX, probably
21:26:24 <otzi> maybe even ULONG_MAX
21:29:40 <roconnor> monochrom: do C programmers still write code like that?
21:30:24 <monochrom> I don't know. C programmers who use gtk may be a bit better.
21:30:40 <monochrom> I heard glib has real data structures.
21:32:52 <otzi> there's also sys/queue.h if you want to go back to the 70s
21:33:05 <otzi> man, this cabal thing is tough :(
21:37:32 <Huawei> does foldr cause space leak too?
21:38:06 * hackagebot kit 0.6.2 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.2 (NickPartridge)
21:39:32 <Huawei> i'm reading 'real time haskell', and it says that foldl may cause a space leak, because it thunks the expressions
21:39:42 <Huawei> but it says nothing about foldr
21:42:11 <wagle> anyone use the idea haskell plugin..  how is it?
21:42:58 <wagle> oops..  i mean xcode
21:45:59 <roconnor> Huawei: foldr can cause space leaks
21:48:08 <Huawei> thank you roconnor.. is there some work around for it ? (like Data.List.foldl' for foldl)
21:49:09 <ddarius> It doesn't need a work-around.
21:49:21 <roconnor> nope
21:50:02 <ddarius> Huawei: The behavior of program isn't determined simply by -which- functions are included in it.  It is how you use them.
21:50:03 <Huawei> oh.
21:50:21 <Huawei> I know that, ddarius
21:50:26 <roconnor> Huawei: make your function lazier
21:50:27 <ddarius> foldl doesn't always cause a space leak, neither does foldl' or foldr.
21:50:38 <ddarius> All of them can be used to cause space leaks too.
21:56:18 <qfr> Hmm so when I perform IO in one function, then every function that uses it needs to get IO marked, too?
21:57:13 <Huawei> humm
22:00:12 <chrisf> qfr: ostensibly yes.
22:01:27 <qfr> I've seen people remove IO or something like that, it looked like a nasty hack
22:01:37 <qfr> Is that frowned upon? Is it dangerous?
22:03:27 <Veinor> it's considered a nasty hack, yeah
22:03:49 <Veinor> the fact that the function that does so is called unsafePerformIO should attest to that ;)
22:06:02 <otzi> a-ha! Found it!
22:06:43 <otzi> main = defaultMainWithHooks autotoolsUserHooks is all I needed
22:09:08 <djahandarie> So I've made it 10x faster so far
22:09:19 <djahandarie> Could go farther but the code might start to get ugly
22:13:47 <otzi> if it's fast you'll have plenty of time to make it pretty again
22:15:38 <djahandarie> No, I mean like really ugly stuff like compiler pragmas and weird symbols littered all over the file
22:17:02 <ddarius> Pragmas aren't really ugly.
22:17:16 <djahandarie> They are when they're littered all over the file
22:17:29 <djahandarie> Littered!
22:30:25 <otzi> djahandarie: hehe I know, I was just joking :P
22:31:05 <otzi> efficient code tends to get ugly and hard to understand
22:31:23 <otzi> it's one of the many tradeoffs in life
22:33:48 <dsrogers> Hi.  Can someone explain how sec. 4.2.3 para 3 of the Haskell 2010 report explains the differences between data, type and newtype?
22:34:34 <dsrogers> and the notion of "unlifted" introduced in the paragraph before?
22:35:01 <Axman6> data is used to make new constructors, type is a way of giving a name to an existing type, and newtype lets you wrap existing types in a fake constructor, so they can be treated differently from the original type
22:35:22 <Axman6> i'm not sure there's much more you need to know than that
22:35:22 <dsrogers> in what sense is the constructor fake?
22:35:25 <shachaf> Axman6: type is a way of making new constructors too.
22:35:38 <shachaf> s/type/newtype/
22:35:54 <djahandarie> Yeay, 30x faster now!
22:35:56 <djahandarie> Not too ugly either
22:36:16 <Axman6> the constructor doesn't exist at runtime (so newtype Foo = F Int will be represented exactly as an Int at runtime,. but it is used for type checking mainly)
22:36:17 <dsrogers> Axman6: I more or less understand that.  I just don't understand the example given wrt the behavior of bottom in expressions involving various types
22:36:29 <dsrogers> Axman6: ah.
22:36:58 <Axman6> hmm, i wonder if you can say newtype Foo = F Foo
22:37:07 <dsrogers> Axman6: that, is what I assume the report means as "unlifted?"
22:38:28 <ddarius> Axman6: Yes.
22:38:30 <Axman6> no idea, sorry
22:38:44 <shachaf> Axman6: Yep. In Haskell 98, too (unlike "Data Foo").
22:39:12 <dsrogers> also why is (d1 _|_) equivilent to bottom?
22:39:14 * Axman6 's brain just exploded trying to figure out how Foo would be represented at compile time
22:39:55 <dsrogers> (from the section in the spec I mentioned, data D1 = D1 Int; d1 (D1 i) = 42)
22:40:09 <ddarius> Axman6: There's pretty much only one definition possible, foo = F foo, which is just foo = foo.
22:40:27 <ddarius> So it behaves like data Foo;
22:40:48 <dsrogers> why would d1 evaluate to bottom if it's argument is never evaluated?
22:41:10 <shachaf> Axman6: You can derive Show from it, though. :-)
22:41:16 <Axman6> heh
22:41:25 <Axman6> you're an evil man :P
22:42:12 <ddarius> dsrogers: It is evaluating it's argument.
22:42:24 <ddarius> It's argument is (D1 i) not i.
22:42:25 <shachaf> newtype Foo = F Foo; show (undefined :: Foo) -- -> "F (F (F (F (F ...
22:43:15 <dsrogers> ok. but still.  D1 isn't evalute it's argument, does it?
22:44:13 <ddarius> No, so?
22:44:55 <dsrogers> so if D1 doesn't evaluate, i, and d1 doesn't evaluate (D1 i) how does d1 evaluate to anything other than 42?
22:45:55 <ddarius> dsrogers: d1 is attempting to pattern match (D1 i) as I've already said.  Why do you think it isn't trying to evaluate it's argument?
22:46:26 <dsrogers> oh  Isee.  I misunderstood that syntax.
22:46:35 <dsrogers> (D1 i) is a pattern.
22:46:38 <dsrogers> thus it evalutes...
22:46:49 <dsrogers> (in order to extract i)
22:46:53 <dsrogers> correct?
22:47:37 <ddarius> It's not quite that simple in general as that section is demonstrating, but that is what's happening in this particular case.
22:47:41 <j-invariant> is the yoneda lemma the same as identity extension
22:47:56 <ddarius> j-invariant: Define "identity extension."
22:48:09 <dsrogers> why is it not that simple in general?
22:48:40 <dsrogers> err, in what circumstances does pattern matching not trigger evaluation?
22:48:52 <ddarius> dsrogers: Because if it was newtype D1 = D1 Int; d1 (D1 i) = 42 then d1 undefined would successfully evaluate to 42.
22:49:03 <ddarius> dsrogers: There are also irrefutable patterns.
22:49:22 <ddarius> And all pattern matches in let or where or at the top level are irrefutable.
22:49:35 <dsrogers> ah
22:50:16 <ddarius> But the reason newtype behaves the way it does can be understood by mentally erasing all the newtype constructors.
22:50:37 <dsrogers> they effectively only exist during type checking then?
22:50:44 <ddarius> So, given newtype N = N Int; f (N i) = 3; when you erase N you get f i = 3 and that clearly doesn't pattern match anything.
22:50:51 <ddarius> dsrogers: Newtypes do, yes.
22:52:11 <dsrogers> nothing about newtype N = N Foo extends into the realm of the enclosed type right?  If I define an instance for N, it doesn't grant that instance to Foo, correct?
22:52:13 <j-invariant> C(-,1) == {o} defines terminal objects
22:52:35 <ddarius> dsrogers: A newtype is indeed a completely new and distinct type.
22:52:42 <djahandarie> http://stackoverflow.com/questions/4559399/can-parser-combination-be-made-efficient/4560629#4560629
22:52:49 <j-invariant> how do you find the isomorphic form, from the diagram?
22:53:34 <ddarius> j-invariant: "Isomorphic form" of what?  What is an "isomorphic form"?  The image of the singleton?
22:53:58 <j-invariant> ddarius: I mean instead of defining in terms of a diagram you define by saying T is terminal iff C(T,1) is isomorphic to {o}
22:54:06 <dsrogers> thanks
22:54:19 <j-invariant> ddarius: it seems like most ofthe definitions can be recast in this isomorphism form
22:55:01 <ddarius> j-invariant: That's incorrect, -1- is terminal if the -functor- C(-,1) is -naturally- isomorphic to the (a) singleton set.
22:55:17 <j-invariant> aha
22:55:23 <ddarius> Well the constantly singleton set functor.
22:58:38 <Axman6> shachaf: ok, tried it out, newtype Foo = F Foo is a lot of fun
22:59:02 <ddarius> Axman6: It's what can be used for a Void type if you don't want to enable the EmptyDataDecl extension.
23:04:07 <dsrogers> "used for a Void type" => meaning that Foo is inhabitated only with bottom?
23:04:18 <shachaf> dsrogers: Yes.
23:13:01 <dsrogers> hmm, is there research on how to extend "default" more than just the Num class?
23:13:32 <Axman6> default?
23:13:56 <dsrogers> it's an expression.  I hadn'
23:14:05 <dsrogers> have not ever seen it before I read the report.
23:14:24 <dsrogers> it affects how type ambigities involving Num are resolved
23:14:40 <Axman6> interestingly i just found out it was a keyword because vim highlighted it differently
23:15:18 <dsrogers> heh.  it must be mostly unused.
23:15:34 <dsrogers> GHC's index doesn't mention it.
23:15:38 <Axman6> yeah, i've been using haskell for three years and never seen it
23:16:34 <dsrogers> why does the report declare that there must be only 10 fixities, yet detail an algorithm that works for any range of fixities?
23:17:27 <Axman6> because if there were an infinite number, people would use them, and we don't want that
23:17:50 <dsrogers> why?
23:19:19 <Axman6> well, look at the situation we have modules, there's nothing stopping people from using any module path they want, so people do, and we get conflicts and other horrible things happen
23:19:59 <Axman6> we'd get to a situation where something has a fixity of 1839 when it should be 1624, but changing it to 1624 would break a lot of code
23:20:18 <Axman6> with 10 fixities, at least this problem is constrained
23:21:30 <shachaf> There should be rational fixities.
23:21:34 <shachaf> Better yet, floating point.
23:21:54 <dolio> In what way is the latter better?
23:22:02 <j-invariant> surreal fixities
23:22:13 <Axman6> imaginary fixities
23:22:23 <shachaf> dolio: Better bugs.
23:22:48 <j-invariant> WQhere is harkell going?
23:23:00 <j-invariant> in the future
23:23:02 <Axman6> to the future, and beyond!
23:23:11 <Axman6> when it can get around to it
23:23:15 <Axman6> it's pretty lazy
23:23:19 <banisterfiend> haha
23:23:24 <banisterfiend> Axman6: not bad, pig
23:23:25 <banisterfiend> ;)
23:23:35 <Axman6> pig? PIG?
23:25:56 <ddarius> The most general approach to fixity resolution would be to explicitly specify the precedence partial order.
23:26:57 <dsrogers> ddarius: why isn't that done?
23:27:18 <dsrogers> that seems rather trouble free.
23:28:05 <ddarius> It would be a little more difficult to implement parsing algorithms for it and would require more specification, but mainly it isn't done just 'cuz it isn't.
23:28:26 <ddarius> There isn't a really good reason not to do it that way.
23:28:41 <j-invariant> why is the derivative of cycle a list?
23:29:00 <j-invariant> shouldn't it be a list but we don't know which end is which?
23:29:14 <ddarius> j-invariant: A cycle is oriented.
23:30:13 <dsrogers> hmm.. so given the type f x = let g y z = ([x ,y], z) in ... the report mentions that haskell cannot express a type for g.  Is this because g contains an existential type (i.e. could it's type be expressed if existential types existed?)
23:30:35 * hackagebot gnuidn 0.2 - Bindings for GNU IDN  http://hackage.haskell.org/package/gnuidn-0.2 (JohnMillikin)
23:30:52 <ddarius> dsrogers: No, it's simply that Haskell 98/2010 doesn't support lexically scoped type variables.
23:31:40 <dsrogers> oh I see.  a type variable expressed in a type signature that originated from a containing type...
23:32:13 <dsrogers> I take it that from your explicit clarification, that ghc does support lexically scoped type variables?
23:32:27 <ddarius> dsrogers: Yes.  g's type would be: forall b. a -> b -> ([a], b), where a is free, but Haskell 98/2010 doesn't let you even write that.
23:32:32 <ddarius> dsrogers: Yes.
23:33:16 <ddarius> f :: forall a. a -> X; f x = let g :: forall b. a -> b -> ([a], b); g y z = ([x,y], z) in ... would work in GHC with the appropriate extensions.
23:36:46 <ddarius> If you leave off the type of g, though, it will do the right thing in Haskell 98/2010, you just can't write down the type yourself.
23:38:46 <dsrogers> well it seems like there is a well understood solution.  what determines where that extension gets fold into official haskell?
23:39:04 <dsrogers> especially since official versions of haskell are quite rare.
23:46:09 <Veinor> 'does ghc support it?'
23:46:14 <Veinor> but seriously... I don't know.
23:46:48 <dsrogers> definately not.  There are a great many things GHC supports that 2010 only hints at.
23:46:58 <Veinor> yes, hence the quotes
23:47:11 <dsrogers> oh oops.
23:47:24 <Veinor> i forget that sarcasm quotes aren't a universal thing. my mistake.
23:47:25 * dsrogers kicks his less-than-trustworthy sarcasm detector
23:51:37 <j-invariant> why does everyone do  g . f
23:51:42 <j-invariant> fg  makes more sense
23:52:01 <dolio> How so?
23:52:14 <j-invariant> because  A --f--> B --g--> C
23:52:47 <Veinor> but (g . f) x = g (f x)
23:53:07 <j-invariant> it could just be xgf
23:53:21 <dolio> Some people do that.
23:53:39 <dolio> You have hundreds of years of mathematical convention fighting against you, though.
23:54:21 <dsrogers> you can redefine . if it bothers you.  Though you'll confuse everyone that reads your program.
23:55:45 <ddarius> j-invariant: There are plenty of categorists who use ; for diagrammatic order composition.
23:55:57 <j-invariant> are they the bad guys?
